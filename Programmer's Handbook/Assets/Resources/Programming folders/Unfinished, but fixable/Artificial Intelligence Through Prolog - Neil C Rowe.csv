Larger Text,Smaller Text,Symbol
Artificial Intelligence through Prolog by Neil C. ,NA,NA
Rowe,NA,NA
"Prentice-Hall, 1988, ISBN 0-13-048679-5",NA,NA
Full text of book (without figures),NA,NA
Table of Contents ,NA,NA
Preface ,NA,NA
Chapter 1 ,NA,NA
Chapter 2 ,NA,NA
Chapter 3 ,NA,NA
Chapter 4 ,NA,NA
Chapter 5 ,NA,NA
Chapter 6 ,NA,NA
Chapter 7 ,NA,NA
Chapter 8 ,NA,NA
Chapter 9 ,NA,NA
Chapter 10 ,NA,NA
Chapter 11 ,NA,NA
Chapter 12 ,NA,NA
Chapter 13 ,NA,NA
Chapter 14 ,NA,NA
Chapter 15 ,NA,NA
Appendix A ,NA,NA
Appendix B ,NA,NA
Appendix C ,NA,NA
Appendix D ,NA,NA
Appendix E ,NA,NA
Appendix F ,NA,NA
Appendix G ,NA,NA
Some figures in crude form ,NA,NA
"Instructor's Manual, containing additional answers and exercises ",NA,NA
Errata on the book as published,http://www.cs.nps.navy.mil/people/faculty/rowe/book/book.html [23/04/2002 17:38:27],NA
Table of contents ,NA,NA
Preface,NA,NA
Acknowledgements,NA,NA
To the reader,NA,NA
1. Introduction,NA,NA
1.1 ,NA,NA
What ,NA,NA
artificial ,NA,NA
intelligence ,NA,NA
is ,NA,NA
about ,NA,NA
1.2 ,NA,NA
Understanding ,NA,NA
artificial ,NA,NA
intelligence 1.3 Preview,NA,NA
2. Representing facts,NA,NA
2.1 Predicates and predicate expressions ,NA,NA
2.2 Predicates indicating types ,NA,NA
2.3 About types ,NA,NA
2.4 Good naming ,NA,NA
2.5 Property predicates ,NA,NA
2.6 Predicates for relationships ,NA,NA
2.7 Semantic networks ,NA,NA
2.8 Getting facts from English descriptions ,NA,NA
2.9 Predicates with three or more arguments ,NA,NA
2.10 Probabilities ,NA,NA
2.11 How many facts do we need?,NA,NA
3. Variables and queries,http://www.cs.nps.navy.mil/people/faculty/rowe/book/tableconts.html (1 of 8) [23/04/2002 17:38:31],NA
3.1 Querying the facts ,NA,NA
3.2 Queries with one variable ,NA,NA
3.3 Multi-directional queries ,NA,NA
3.4 Matching alternatives ,NA,NA
3.5 Multi-condition queries ,NA,NA
3.6 Negative predicate expressions ,NA,NA
3.7 Some query examples ,NA,NA
3.8 Loading a database ,NA,NA
3.9 Backtracking ,NA,NA
3.10 A harder backtracking example: superbosses ,NA,NA
"3.11 Backtracking with ""not""s ",NA,NA
3.12 The generate-and-test scheme ,NA,NA
"3.13 Backtracking with ""or""s (*) ",NA,NA
3.14 Implementation of backtracking ,NA,NA
3.15 About long examples,NA,NA
4. Definitions and inferences,NA,NA
4.1 Rules for definitions ,NA,NA
4.2 Rule and fact order ,NA,NA
4.3 Rules as programs ,NA,NA
4.4 Rules in natural language ,NA,NA
4.5 Rules without right sides ,NA,NA
4.6 Postponed binding ,NA,NA
4.7 Backtracking with rules ,NA,NA
4.8 Transitivity inferences ,NA,NA
4.9 Inheritance inferences ,NA,NA
4.10 Some implementation problems for transitivity and inheritance ,NA,NA
4.11 A longer example: some traffic laws ,NA,NA
4.12 Running the traffic lights program ,NA,NA
4.13 Declarative programming,NA,NA
5. Arithmetic and lists in Prolog,NA,NA
5.1 Arithmetic comparisons,http://www.cs.nps.navy.mil/people/faculty/rowe/book/tableconts.html (2 of 8) [23/04/2002 17:38:31],NA
5.2 Arithmetic assignment ,NA,NA
"5.3 Reversing the ""is"" ",NA,NA
5.4 Lists in Prolog ,NA,NA
5.5 Defining some list-processing predicates ,NA,NA
5.6 List-creating predicates ,NA,NA
5.7 Combining list predicates ,NA,NA
5.8 Redundancy in definitions ,NA,NA
5.9 An example: dejargonizing bureaucratese (*),NA,NA
6. Control structures for rule-based systems,NA,NA
6.1 Backward-chaining control structures 6.2 ,NA,NA
Forward chaining ,NA,NA
6.3 A forward chaining example ,NA,NA
6.4 Hybrid control structures ,NA,NA
6.5 Order variants ,NA,NA
6.6 Partitioned control structures ,NA,NA
6.7 Meta-rules ,NA,NA
6.8 Decision lattices ,NA,NA
6.9 Concurrency in control structures ,NA,NA
6.10 And-or-not lattices ,NA,NA
6.11 Randomness in control structures ,NA,NA
6.12 Grammars for interpreting languages (*),NA,NA
7. Implementation of rule-based systems,NA,NA
7.1 Implementing backward chaining ,NA,NA
7.2 Implementing virtual facts in caching ,NA,NA
7.3 Input coding ,NA,NA
7.4 Output coding ,NA,NA
7.5 Intermediate predicates ,NA,NA
7.6 An example program ,NA,NA
7.7 Running the example program ,NA,NA
7.8 Partitioned rule-based systems ,NA,NA
7.9 Implementing the rule-cycle hybrid,http://www.cs.nps.navy.mil/people/faculty/rowe/book/tableconts.html (3 of 8) [23/04/2002 17:38:31],NA
7.10 Implementing pure forward chaining (*) ,NA,NA
"7.11 Forward chaining with ""not""s (*) ",NA,NA
"7.12 General iteration with ""forall"" and ""doall"" (*) ",NA,NA
7.13 Input and output of forward chaining (*) ,NA,NA
7.14 Rule form conversions (*) ,NA,NA
7.15 Indexing of predicates (*) ,NA,NA
7.16 Implementing meta-rules (*) ,NA,NA
7.17 Implementing concurrency (*) ,NA,NA
7.18 Decision lattices: a compilation of a rule-based system (*) ,NA,NA
7.19 Summary of the code described in the chapter (*),NA,NA
8. Representing uncertainty in rule-based systems,NA,NA
8.1 Probabilities in rules ,NA,NA
8.2 Some rules with probabilities ,NA,NA
8.3 Combining evidence assuming statistical independence ,NA,NA
"8.4 Prolog implementation of independence-assumption ""and-combination"" ",NA,NA
"8.5 Prolog implementation of independence-assumption ""or-combination"" ",NA,NA
8.6 The conservative approach ,NA,NA
8.7 The liberal approach and others ,NA,NA
8.8 Negation and probabilities ,NA,NA
8.9 An example: fixing televisions ,NA,NA
8.10 Graphical representation of probabilities in rule-based systems ,NA,NA
8.11 Getting probabilities from statistics ,NA,NA
8.12 Probabilities derived from others ,NA,NA
8.13 Subjective probabilities ,NA,NA
8.14 Maximum-entropy probabilities (*) ,NA,NA
8.15 Consistency (*),NA,NA
9. Search,NA,NA
9.1 Changing worlds ,NA,NA
9.2 States ,NA,NA
9.3 Three examples ,NA,NA
9.4 Operators,http://www.cs.nps.navy.mil/people/faculty/rowe/book/tableconts.html (4 of 8) [23/04/2002 17:38:31],NA
9.5 Search as graph traversal ,NA,NA
9.6 The simplest search strategies: depth-first and breadth-first ,NA,NA
9.7 Heuristics ,NA,NA
9.8 Evaluation functions ,NA,NA
9.9 Cost functions ,NA,NA
9.10 Optimal-path search ,NA,NA
9.11 A route-finding example ,NA,NA
9.12 Special cases of search ,NA,NA
9.13 How hard is a search problem?,NA,NA
9.14 Backward chaining versus forward chaining (*) 9.15 ,NA,NA
Using probabilities in search (*) ,NA,NA
9.16 Another example: visual edge-finding as search (*),NA,NA
10. Implementing search,NA,NA
10.1 Defining a simple search problem ,NA,NA
10.2 Defining a search problem with fact-list states ,NA,NA
10.3 Implementing depth-first search ,NA,NA
10.4 A depth-first example ,NA,NA
10.5 Implementing breadth-first search ,NA,NA
10.6 Collecting all items that satisfy a predicate expression ,NA,NA
10.7 The cut predicate ,NA,NA
10.8 Iteration with the cut predicate (*) ,NA,NA
10.9 Implementing best-first search (*) ,NA,NA
10.10 Implementing A* search (*) ,NA,NA
10.11 Implementing search with heuristics (*) ,NA,NA
10.12 Compilation of search (*),NA,NA
11. Abstraction in search,NA,NA
11.1 Means-ends analysis ,NA,NA
11.2 A simple example ,NA,NA
11.3 Partial state description ,NA,NA
11.4 Implementation of means-ends analysis ,NA,NA
11.5 A harder example: flashlight repair,NA,NA
11.6 Running the flashlight program ,NA,NA
11.7 Means-ends versus other search methods ,NA,NA
11.8 Modeling real-word uncertainty (*) ,NA,NA
11.9 Procedural nets (*),NA,NA
12. Abstraction of facts,NA,NA
12.1 Partitioning facts ,NA,NA
12.2 Frames and slots ,NA,NA
12.3 Slots qualifying other slots ,NA,NA
12.4 Frames with components ,NA,NA
12.5 Frames as forms: memos ,NA,NA
12.6 Slot inheritance ,NA,NA
12.7 Part-kind inheritance ,NA,NA
12.8 Extensions versus intensions ,NA,NA
12.9 Procedural attachment ,NA,NA
12.10 Frames in Prolog ,NA,NA
12.11 Example of a frame lattice ,NA,NA
12.12 Expectations from slots ,NA,NA
12.13 Frames for natural language understanding (*) ,NA,NA
12.14 Multiple inheritance (*) ,NA,NA
12.15 A multiple inheritance example: custom operating systems (*),NA,NA
13. Problems with many constraints,NA,NA
13.1 Two examples ,NA,NA
13.2 Rearranging long queries without local variables ,NA,NA
13.3 Some mathematics ,NA,NA
13.4 Rearranging queries with local variables ,NA,NA
13.5 Rearranging queries based on dependencies ,NA,NA
13.6 Summary of guidelines for optimal query arrangements ,NA,NA
13.7 Rearrangement and improvement of the photo interpretation query ,NA,NA
13.8 Dependency-based backtracking ,NA,NA
13.9 Reasoning about possibilities ,NA,NA
13.10 Using relaxation for the photo interpretation example,http://www.cs.nps.navy.mil/people/faculty/rowe/book/tableconts.html (6 of 8) [23/04/2002 17:38:31],NA
13.11 Quantifying the effect (*) ,NA,NA
13.12 Formalization of pure relaxation ,NA,NA
13.13 Another relaxation example: cryptarithmetic ,NA,NA
13.14 Implementation of pure relaxation (*) ,NA,NA
13.15 Running a cryptarithmetic relaxation (*) ,NA,NA
13.16 Implementing double relaxation (*),NA,NA
14. A more general logic programming,NA,NA
14.1 Logical limitations of Prolog ,NA,NA
14.2 The logical (declarative) meaning of Prolog rules and facts ,NA,NA
14.3 Extending Prolog rules ,NA,NA
14.4 More about clause form ,NA,NA
14.5 Resolution ,NA,NA
14.6 Resolution with variables ,NA,NA
14.7 Three important applications of resolution ,NA,NA
14.8 Resolution search strategies ,NA,NA
14.9 Implementing resolution without variables (*),NA,NA
15. Testing and debugging of artificial intelligence programs,NA,NA
15.1 The gold standard ,NA,NA
15.2 Cases ,NA,NA
15.3 Focusing on bugs ,NA,NA
15.4 Exploiting pairs of similar cases ,NA,NA
15.5 Composite results ,NA,NA
15.6 Numbers in comparisons ,NA,NA
15.7 Preventive measures ,NA,NA
15.8 Supporting intuitive debugging ,NA,NA
15.9 Evaluating cooperativeness ,NA,NA
15.10 On problems unsuitable for artificial intelligence,http://www.cs.nps.navy.mil/people/faculty/rowe/book/tableconts.html (7 of 8) [23/04/2002 17:38:31],NA
Appendix A: basics of logic,NA,NA
Appendix B: Basics of recursion,NA,NA
Appendix C: Basics of data structures,NA,NA
Appendix D: summary of the Prolog dialect used in this book,NA,NA
D.1 Managing facts and rules ,NA,NA
"D.2 The format of facts, rules and queries ",NA,NA
D.3. Program layout ,NA,NA
D.4. Lists ,NA,NA
D.5. Numbers ,NA,NA
D.6. Output and input ,NA,NA
D.7. Strings ,NA,NA
D.8. Treating rules and facts as data ,NA,NA
D.9. Miscellaneous predicates ,NA,NA
D.10. Definable predicates ,NA,NA
D.11. Debugging,NA,NA
Appendix E: Using this book with Micro-Prolog,NA,NA
Appendix F: For further reading,NA,NA
Appendix G: Answers to selected exercises,http://www.cs.nps.navy.mil/people/faculty/rowe/book/tableconts.html (8 of 8) [23/04/2002 17:38:31],NA
Preface ,NA,NA
Artificial intelligence is a hard subject to learn. I have written a book to make it easier. I explain difficult ,NA,NA
"concepts in a simple, concrete way. I have organized the material in a new and (I feel) clearer way, a way ",NA,NA
"in which the chapters are in a logical sequence and not just unrelated topics. I believe that with this book, ",NA,NA
readers can learn the key concepts of artificial intelligence faster and better than with other books. This ,NA,NA
"book is intended for all first courses in artificial intelligence at the undergraduate or graduate level, ",NA,NA
requiring background of only a few computer science courses. It can also be used on one's own. ,NA,NA
"Students often complain that while they understand the terminology of artificial intelligence, they don't ",NA,NA
have a gut feeling for what's going on or how you apply the concepts to a situation. One cause is the ,NA,NA
"complexity of artificial intelligence. Another is the unnecessary baggage, like overly formal logical ",NA,NA
"calculi, that some books and teachers saddle students with. But an equally important cause is the often ",NA,NA
poor connection made between abstract concepts and their use. So I considered it essential to integrate ,NA,NA
"practical programming examples into this book, in the style of programming language and data structures ",NA,NA
books. (I stress ,NA,NA
practical,NA,NA
", not missionaries and cannibals, definitions of ""grandfather"", or rules for ",NA,NA
"identifying animals in zoos--at least rarely.) This book has about 500 chunks of code. Clear, concrete ",NA,NA
formalization of artificial intelligence ideas by programs and program fragments is all the more critical ,NA,NA
"today with commercialization and media discovery of the field, which has caused a good deal of throwing ",NA,NA
around of artificial intelligence terms by people who don't understand them. ,NA,NA
"But artificial intelligence is a tool for complex problems, and its program examples can easily be ",NA,NA
forbiddingly complicated. Books attempting to explain artificial intelligence with examples from the ,NA,NA
programming language Lisp have repeatedly demonstrated this. But I have come to see that the fault lies ,NA,NA
more with Lisp than with artificial intelligence. Lisp has been the primary language of artificial ,NA,NA
"intelligence for many years, but it is a low-level language, too low for most students. Designed in the ",NA,NA
"early 1960s, Lisp reflects the then-primitive understanding of good programming, and requires the ",NA,NA
"programmer to worry considerably about actual memory references (pointers). Furthermore, Lisp has a ",NA,NA
"weird, hard-to-read syntax unlike that of any other programming language. To make matters worse, the ",NA,NA
widespread adoption of Common Lisp as a de facto standard has discouraged research on improved Lisps. ,NA,NA
"Fortunately there is an alternative: Prolog. Developed in Europe in the 1970s, the language Prolog has ",NA,NA
"steadily gained enthusiastic converts, bolstered by its surprise choice as the initial language of the ",NA,NA
Japanese Fifth Generation Computer project. Prolog has three positive features that give it key advantages ,NA,NA
"over Lisp. First, Prolog syntax and semantics are much closer to formal logic, the most common way of ",NA,NA
"representing facts and reasoning methods used in the artificial intelligence literature. Second, Prolog ",NA,NA
"provides automatic backtracking, a feature making for considerably easier ""search"", the most central of all ",NA,NA
"artificial intelligence techniques. Third, Prolog supports multidirectional (or multiuse) reasoning, in ",NA,NA
which arguments to a procedure can freely be designated inputs and outputs in different ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/preface.html (1 of 5) [23/04/2002 17:38:32],NA
"ways in different procedure calls, so that the same procedure definition can be used for many different ",NA,NA
"kinds of reasoning. Besides this, new implementation techniques have given current versions of Prolog ",NA,NA
"close in speed to Lisp implementations, so efficiency is no longer a reason to prefer Lisp. ",NA,NA
"But Prolog also, I believe, makes teaching artificial intelligence easier. This book is a demonstration. This ",NA,NA
"book is an organic whole, not a random collection of chapters on random topics. My chapters form a ",NA,NA
"steady, logical progression, from knowledge representation to inferences on the representation, to rule-",NA,NA
"based systems codifying classes of inferences, to search as an abstraction of rule-based systems, to ",NA,NA
"extensions of the methodology, and finally to evaluation of systems. Topics hard to understand like ",NA,NA
"search, the cut predicate, relaxation, and resolution are introduced late and only with careful preparation. ",NA,NA
"In each chapter, details of Prolog are integrated with major concepts of artificial intelligence. For ",NA,NA
"instance, Chapter 2 discusses the kinds of facts about the world that one can put into computers as well as ",NA,NA
the syntax of Prolog's way; Chapter 3 discusses automatic backtracking as well as Prolog querying; ,NA,NA
Chapter 4 discusses inference and inheritance as well as the definition of procedures in Prolog; Chapter 5 ,NA,NA
discusses multidirectional reasoning as well as the syntax of Prolog arithmetic; and so on. This constant ,NA,NA
tying of theory to practice makes artificial intelligence a lot more concrete. Learning is better motivated ,NA,NA
since one doesn't need to master a lot of mumbo-jumbo to get to the good stuff. I can't take much of the ,NA,NA
"credit myself: the very nature of Prolog, and particularly the advantages of the last paragraph, make it ",NA,NA
easy. ,NA,NA
"Despite my integrated approach to the material, I think I have covered nearly all the topics in ACM and ",NA,NA
IEEE guidelines for a first course in artificial intelligence. Basic concepts mentioned in those guidelines ,NA,NA
"appear towards the beginning of chapters, and applications mentioned in the guidelines appear towards ",NA,NA
"the ends. Beyond the guidelines however, I have had to make tough decisions about what to leave out--a ",NA,NA
"coherent book is better than an incoherent book that covers everything. Since this is a first course, I ",NA,NA
concentrate on the hard core of artificial intelligence. So I don't discuss much how humans think (that's ,NA,NA
"psychology), or how human language works (that's linguistics), or how sensor interpretation and low-",NA,NA
"level visual processing are done (that's pattern recognition), or whether computers will ever really think ",NA,NA
(that's philosophy). I have also cut corners on hard non-central topics like computer learning and the full ,NA,NA
"formal development of predicate calculus. On the other hand, I emphasize more than other books do the ",NA,NA
"central computer science concepts of procedure calls, variable binding, list processing, tree traversal, ",NA,NA
"analysis of processing efficiency, compilation, caching, and recursion. This is a computer science ",NA,NA
textbook. ,NA,NA
A disadvantage of my integrated approach is that chapters can't so easily be skipped. To partially ,NA,NA
"compensate, I mark some sections within chapters (usually sections towards the end) with asterisks to ",NA,NA
"indicate that they are optional to the main flow of the book. In addition, all of Chapters 7, 10, and 14 can ",NA,NA
"be omitted, and perhaps Chapters 12 and 13 too. (Chapters 7, 10, 13, and 14 provide a good basis for a ",NA,NA
"second course in artificial intelligence, and I have used them that way myself.) Besides this, I cater to the ",NA,NA
different needs of different readers in the exercises. Exercises are essential to learning the material in a ,NA,NA
"textbook. Unfortunately, there is little consensus about what kind of exercises to give for courses in ",NA,NA
artificial intelligence. So I have provided a wide variety: short-answer questions for checking basic ,NA,NA
"understanding of material, programming exercises for people who like to program, ""play computer"" ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/preface.html (2 of 5) [23/04/2002 17:38:32],NA
"exercises that have the reader simulate techniques described, application questions that have the reader ",NA,NA
apply methods to new areas (my favorite kind of exercise because it tests real understanding of the ,NA,NA
"material), essay questions, fallacies to analyze, complexity analysis questions, and a few extended ",NA,NA
projects suitable for teams of students. There are also some miscellaneous questions drawing on the entire ,NA,NA
"book, at the end of Chapter 15. Answers to about one third of the exercises are provided in Appendix G, ",NA,NA
"to offer readers immediate feedback on their understanding, something especially important to those ",NA,NA
tackling this book on their own. ,NA,NA
"To make learning the difficult material of this book even easier, I provide other learning aids. I apportion ",NA,NA
"the book into short labeled sections, to make it easier for readers to chunk the material into mind-sized ",NA,NA
bites. I provide reinforcement of key concepts with some novel graphical and tabular displays. I provide ,NA,NA
"""glass box"" computer programs (that is, the opposite of ""black box"") for readers to study. I mark key ",NA,NA
"terms in boldface where they are defined in the text, and then group these terms into keyword lists at the ",NA,NA
end of every chapter. I give appendices summarizing the important background material needed for this ,NA,NA
"book, concepts in logic, recursion, and data structures. In other appendices, I summarize the Prolog ",NA,NA
"dialect of the book, make a few comments on Micro-Prolog, and provide a short bibliography (most of ",NA,NA
the artificial intelligence literature is now either too hard or too easy for readers of this book). The major ,NA,NA
"programs of the book are available on tape from the publisher for a small fee. Also, I have prepared an ",NA,NA
instructor's manual. ,NA,NA
"It's not necessary to have a Prolog interpreter or compiler available to use this book, but it does make ",NA,NA
"learning easier. This book uses a limited subset of the most common dialect of Prolog, the ""standard ",NA,NA
"Prolog"" of ",NA,NA
Programming in Prolog,NA,NA
" by Clocksin and Mellish (second edition, Springer-Verlag, 1984). ",NA,NA
But most exercises do not require programming. ,NA,NA
"I've tried to doublecheck all examples, programs, and exercises, but some errors may have escaped me. If ",NA,NA
"you find any, please write me in care of the publisher, or send computer mail to rowe@nps-cs.arpa. ",NA,NA
Acknowledgements ,NA,NA
Many people contributed ideas to this book. Michael Genesereth first suggested to me the teaching of ,NA,NA
introductory artificial intelligence in a way based on logic. David H. Warren gradually eroded my ,NA,NA
skepticism about Prolog. Harold Abelson and Seymour Papert have steered my teaching style towards ,NA,NA
student activity rather than passivity. ,NA,NA
"Judy Quesenberry spent many long hours helping me with the typing and correction of this book, and ",NA,NA
"deserves a great deal of thanks, even if she ate an awful lot of my cookies. Robert Richbourg has been ",NA,NA
"helpful in many different ways, in suggesting corrections and improvements and in testing out some of ",NA,NA
"the programs, despite his having to jump through all the hoops Ph.D. students must jump through. ",NA,NA
Richard Hamming provided valuable advice on book production. Other people who provided valuable ,NA,NA
"comments include Chris Carlson, Daniel Chester, Ernest Davis, Eileen Entin, Robert Grant, Mike ",NA,NA
"Goyden, Kirk Jennings, Grace Mason, Bruce MacLennan, Norman McNeal, Bob McGhee, James ",NA,NA
"Milojkovic, Jim Peak, Olen Porter, Brian Rodeck, Derek Sleeman, Amnon Shefi, and Steve Weingart. ",NA,NA
Mycke Moore made the creative suggestion that I put a lot of sex into this book to boost sales. ,NA,NA
"Besides those named, I am grateful to all my students over the years at the Massachusetts Institute of ",NA,NA
"Technology, Stanford University, and the Naval Postgraduate School for providing valuable feedback. ",NA,NA
"They deserve a good deal of credit for the quality of this book--but sorry, people, I'm poor and unwilling ",NA,NA
to share royalties. ,NA,NA
To the reader ,NA,NA
Artificial intelligence draws on many different areas of computer science. It is hard to recommend ,NA,NA
prerequisites because what you need to know is bits and pieces scattered over many different courses. At ,NA,NA
least two quarters or semesters of computer programming in a higher-level language like Pascal is ,NA,NA
"strongly recommended, since we will introduce here a programming language several degrees more ",NA,NA
"difficult, Prolog. If you can get programming experience in Prolog, Lisp, or Logo that's even better. It also ",NA,NA
"helps to have a course in formal logic, though we won't use much of the fancy stuff they usually cover in ",NA,NA
those courses; see Appendix A for what you do need to know. Artificial intelligence uses sophisticated ,NA,NA
"data structures, so a data structures course helps; see Appendix C for a summary. Finally, you should be ",NA,NA
"familiar with recursion, because Prolog is well suited to this way of writing programs. Recursion is a ",NA,NA
"difficult concept to understand at first, but once you get used to it you will find it easy and natural; ",NA,NA
Appendix B provides some hints. ,NA,NA
"Solving problems is the best way to learn artificial intelligence. So there are lots of exercises in this book, ",NA,NA
"at the ends of chapters. Please take these exercises seriously; many of them are hard, but you can really ",NA,NA
"learn from them, much more than by just passively reading the text. Artificial intelligence is difficult to ",NA,NA
"learn, and feedback really helps, especially if you're working on your own. (But don't plan to do all the ",NA,NA
exercises: there are too many.) Exercises have code letters to indicate their special features: ,NA,NA
--the code R means a particularly good problem recommended for all readers; ,NA,NA
--the code A means a question that has an answer in Appendix G; ,NA,NA
--the code H means a particularly hard problem; ,NA,NA
--the code P means a problem requiring actual programming in Prolog; --the ,NA,NA
code E means an essay question; ,NA,NA
--the code G means a good group project. ,NA,NA
"In addition to exercises, each chapter has a list of key terms you should know. Think of this list, at the ",NA,NA
"end of the text for each chapter, as a set of ""review questions"". ",NA,NA
"The symbol ""*"" on a section of a chapter means optional reading. These sections are either significantly ",NA,NA
"harder than the rest of the text, or significantly far from the core material. ",NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/preface.html (5 of 5) [23/04/2002 17:38:32],NA
Introduction ,NA,NA
What artificial intelligence is about ,NA,NA
Artificial intelligence,NA,NA
 is the getting of computers to do things that seem to be intelligent. The hope is that ,NA,NA
"more intelligent computers can be more helpful to us--better able to respond to our needs and wants, and ",NA,NA
more clever about satisfying them. ,NA,NA
"But ""intelligence"" is a vague word. So artificial intelligence is not a well-defined field. One thing it often ",NA,NA
"means is advanced software engineering, sophisticated software techniques for hard problems that can't ",NA,NA
"be solved in any easy way. Another thing it often means is nonnumeric ways of solving problems, since ",NA,NA
"people can't handle numbers well. Nonnumeric ways are often ""common sense"" ways, not necessarily the ",NA,NA
"best ones. So artificial-intelligence programs--like people--are usually not perfect, and even make ",NA,NA
mistakes. ,NA,NA
Artificial intelligence includes: ,NA,NA
"--Getting computers to communicate with us in human languages like English, either by ",NA,NA
"printing on a computer terminal, understanding things we type on a computer terminal, ",NA,NA
"generating speech, or understanding our speech (",NA,NA
natural language,NA,NA
); ,NA,NA
"--Getting computers to remember complicated interrelated facts, and draw conclusions ",NA,NA
from them (,NA,NA
inference,NA,NA
); ,NA,NA
--Getting computers to plan sequences of actions to accomplish goals (,NA,NA
planning,NA,NA
); ,NA,NA
--Getting computers to offer us advice based on complicated rules for various situations ,NA,NA
(,NA,NA
expert systems,NA,NA
); ,NA,NA
--Getting computers to look through cameras and see what's there (,NA,NA
vision,NA,NA
); ,NA,NA
--Getting computers to move themselves and objects around in the real world (,NA,NA
robotics,NA,NA
). ,NA,NA
"We'll emphasize inference, planning, and expert systems in this book because they're the ""hard core"" of ",NA,NA
"artificial intelligence; the other three subareas are getting quite specialized, though we'll mention them too ",NA,NA
from time to time. All six subareas are hard; significant progress in any will require years of research. But ,NA,NA
we've already had enough progress to get some useful programs. These programs have created much ,NA,NA
"interest, and have stimulated recent growth of the field. ",NA,NA
"Success is hard to measure, though. Perhaps the key issue in artificial intelligence is ",NA,NA
reductionism,NA,NA
", the ",NA,NA
degree to which a program fails to reflect the full complexity of human beings. Reductionism includes ,NA,NA
how often program behavior duplicates human behavior and how much it differs when it does differ. ,NA,NA
Reductionism is partly a moral issue because it requires moral judgments. Reductionism is also a social ,NA,NA
issue because it relates to automation. ,NA,NA
Understanding artificial intelligence ,NA,NA
Artificial intelligence techniques and ideas seem to be harder to understand than most things in computer ,NA,NA
"science, and we give you fair warning. For one thing, there are lots of details to worry about. Artificial ",NA,NA
"intelligence shows best on complex problems for which general principles don't help much, though there ",NA,NA
are a few useful general principles that we'll explain in this book. This means many examples in this book ,NA,NA
"are several pages long, unlike most of the examples in mathematics textbooks. ",NA,NA
Complexity limits how much the programmer can understand about what is going on in an artificial-,NA,NA
intelligence program. Often the programs are like simulations: the programmer sets conditions on the ,NA,NA
"behavior of the program, but doesn't know what will happen once it starts. This means a different style of ",NA,NA
"programming than with traditional higher-level languages like Fortran, Pascal, PL/1, and Ada | ",NA,NA
"REFERENCE 1|, .FS | REFERENCE 1| A trademark of the U.S. Department of Defense, Ada Joint ",NA,NA
Program Office. .FE where successive refinement of a specification can mean we know what the program ,NA,NA
"is doing at every level of detail. But artificial-intelligence techniques, even when all their details are hard ",NA,NA
"to follow, are often the only way to solve a difficult problem. ",NA,NA
"Artificial intelligence is also difficult to understand by its content, a funny mixture of the rigorous and the ",NA,NA
"unrigorous. Certain topics are just questions of style (like much of Chapters 2, 6, and 12), while other ",NA,NA
"topics have definite rights and wrongs (like much of Chapters 3, 5, and 11). Artificial intelligence ",NA,NA
"researchers frequently argue about style, but publish more papers about the other topics. And when rigor ",NA,NA
"is present, it's often different from that in the other sciences and engineering: it's not numeric but ",NA,NA
logical,NA,NA
", ",NA,NA
in terms of truth and implication. ,NA,NA
Clarke's Law says that all unexplained advanced technology is like magic. So artificial intelligence may ,NA,NA
"lose its magic as you come to understand it. Don't be discouraged. Remember, genius is 5% inspiration ",NA,NA
"and 95% perspiration according to the best figures, though estimates vary. ",NA,NA
Preview ,NA,NA
This book is organized around the important central ideas of artificial intelligence rather than around ,NA,NA
application areas. We start out (Chapters 2-5) by explaining ways of storing and using knowledge inside ,NA,NA
"computers: facts (Chapter 2), queries (Chapter 3), rules (Chapter 4), and numbers and lists (Chapter 5). ",NA,NA
"We examine rule-based systems in Chapters 6-8, an extremely important subclass of artificial ",NA,NA
"intelligence programs. We examine search techniques in Chapters 9-11, another important subclass. We ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap1.html (2 of 3) [23/04/2002 17:38:32],NA
address other important topics in Chapters 12-14: Chapter 12 on frame representations extends Chapter ,NA,NA
"2, Chapter 13 on long queries extends Chapter 3, and Chapter 14 on general logical reasoning extends ",NA,NA
Chapter 4. We conclude in Chapter 15 with a look at evaluation and debugging of artificial intelligence ,NA,NA
"programs; that chapter is recommended for everyone, even those who haven't read all the other chapters. ",NA,NA
"To help you, appendices A-C review material on logic, recursion, and data structures respectively. ",NA,NA
"Appendix D summarizes the Prolog language subset we use in this book, Appendix E summarizes the ",NA,NA
"Micro-Prolog dialect, Appendix F gives a short bibliography, and Appendix G provides answers to some ",NA,NA
of the exercises. ,NA,NA
Keywords: ,NA,NA
artificial intelligence,NA,NA
natural language,NA,NA
inference,NA,NA
planning,NA,NA
expert systems,NA,NA
vision,NA,NA
robotics,NA,NA
reductionism,NA,NA
Go to book index,NA,NA
Representing facts ,NA,NA
"If we want computers to act intelligent, we must help them. We must tell them all the common-sense ",NA,NA
knowledge,NA,NA
 we have that they don't. This can be hard because this knowledge can be so obvious to us that ,NA,NA
"we don't realize that a computer doesn't know it too, but we must try. ",NA,NA
Now there are many different kinds of knowledge. Without getting deep into philosophy (or specifically ,NA,NA
epistemology,NA,NA
", the theory of knowledge), there are two main kinds: facts and reasoning procedures. Facts ",NA,NA
"are things true about the world, and reasoning procedures (or ",NA,NA
inferences,NA,NA
) are ways to follow reasoning ,NA,NA
"chains between facts. Since facts are easier to represent than procedures, we'll consider them first, and ",NA,NA
postpone procedures to Chapter 4. ,NA,NA
Predicates and predicate expressions ,NA,NA
"To talk about facts we need a ""language"". Artificial intelligence uses many languages and sub-languages. ",NA,NA
"But in this introductory book we don't want to confuse you. We'll use only one, simple (",NA,NA
first-order,NA,NA
) ,NA,NA
predicate logic,NA,NA
 (sometimes called ,NA,NA
predicate calculus,NA,NA
 and sometimes just ,NA,NA
logic,NA,NA
). And we'll use a particular ,NA,NA
notation compatible with the computer programming language Prolog | REFERENCE 1|. .FS | ,NA,NA
"REFERENCE 1| In this book we use a subset of the ""standard Prolog"" in Clocksin and Mellish, ",NA,NA
Programming in Prolog,NA,NA
", second edition, Springer-Verlag, 1984. For a complete description of what we ",NA,NA
"use, see Appendix D. .FE Prolog isn't predicate logic itself; computer languages try to do things, whereas ",NA,NA
logic just says that certain things are true and false. But Prolog does appear close to the way logic is ,NA,NA
"usually written. That is, its ",NA,NA
grammar,NA,NA
 or ,NA,NA
syntax,NA,NA
" or form is that of logic, but its ",NA,NA
semantics,NA,NA
 or meaning is ,NA,NA
different. ,NA,NA
"And what is that grammar? Formally, a ",NA,NA
predicate expression,NA,NA
 (or ,NA,NA
atomic formula,NA,NA
", but that sounds like a ",NA,NA
nuclear weapons secret) is a name--a ,NA,NA
predicate,NA,NA
--followed by zero or more arguments enclosed in ,NA,NA
parentheses and separated by commas (see Figure 2-1) | REFERENCE 2|. .FS | REFERENCE 2| Several ,NA,NA
"terms closely related to ""predicate expression"" are used in the logic and artificial-intelligence literature. A ",NA,NA
literal,NA,NA
 is like a predicate expression only it can have a negation symbol in front of it (negations will be ,NA,NA
explained in Section 3.6). A ,NA,NA
structure,NA,NA
 or ,NA,NA
compound term,NA,NA
 is like a predicate expression only it isn't ,NA,NA
necessarily only true or false. A ,NA,NA
logical formula,NA,NA
 is a structure or a set of structures put together with ,NA,NA
"""and""s, ""or""s, and ""not""s. .FE Predicate names and arguments can be composed of any mixture of letters ",NA,NA
"and numbers, except that predicate names must start with a lower-case letter. (Upper-case letters first in a ",NA,NA
"word have a special meaning in Prolog, as we'll explain shortly.) The underscore symbol """,NA,NA
_,NA,NA
""" also counts ",NA,NA
"as a letter, and we will often use it to make names more readable. So these are all predicate expressions: ",NA,NA
p(x),NA,NA
"q(y,3)",NA,NA
"r(alpha,-2584,beta)",NA,NA
"city(monterey,california)",NA,NA
tuvwxy(abc345),NA,NA
noarguments,NA,NA
pi(3.1416),NA,NA
"long_predicate_name(long_argument_name,3)",NA,NA
We can put predicate expressions like these into computers. They can represent facts true about the ,NA,NA
world. But what exactly do these expressions ,NA,NA
mean,NA,NA
 (their ,NA,NA
semantics,NA,NA
")? Actually, anything you want--it's ",NA,NA
up to you to assign reasonable and consistent interpretations to the symbols and the way they're put ,NA,NA
"together, though there are some conventions. The better job you do, the more reasonable the conclusions ",NA,NA
you'll reach from all these facts. ,NA,NA
Predicates indicating types ,NA,NA
Predicates can mean many things. But they do fall into categories. We summarize the major categories in ,NA,NA
Figure 2-2. ,NA,NA
One thing they can mean is something like data-type information in a language like Pascal or Ada. ,NA,NA
Except that in artificial intelligence there are generally a lot more types than there are in most ,NA,NA
"programming, because there must be a type for every category in the world that we want the computer to ",NA,NA
know about. ,NA,NA
"For instance, suppose we want the computer to know about some U.S. Navy ships | REFERENCE 3|. We ",NA,NA
.FS | REFERENCE 3| The occasional use of military examples in this book is deliberate: to serve as a ,NA,NA
"reminder that much artificial intelligence work in the United States has been, and remains, supported by ",NA,NA
the military. We make no endorsements. .FE could tell it ,NA,NA
ship(enterprise).,NA,NA
"to say that the Enterprise is a ship (remember we must use lower case). Or in other words, the Enterprise ",NA,NA
"is an example of the ""ship"" type. We will put periods at the end of facts because Prolog uses the period to ",NA,NA
signal the end of a line. We could also tell the computer ,NA,NA
ship(kennedy).,NA,NA
ship(vinson).,NA,NA
"to give it the names of two more ships--two more things of the ""ship"" type. Here ",NA,NA
ship,NA,NA
 is a ,NA,NA
type predicate,NA,NA
. ,NA,NA
"If we knew code numbers for planes we could tell the computer about them too, using the code numbers ",NA,NA
as names: ,NA,NA
plane(p54862).,NA,NA
plane(p79313).,NA,NA
"Similarly, we can label people with types: ",NA,NA
commodore(r_h_shumaker).,NA,NA
president(r_reagan).,NA,NA
and label more abstract things like institutions: ,NA,NA
university(naval_postgraduate_school). ,NA,NA
university(stanford_university).,NA,NA
and label concepts: ,NA,NA
day_of_week(monday).,NA,NA
day_of_week(tuesday).,NA,NA
day_of_week(wednesday).,NA,NA
A thing can have more than one type. For instance: ,NA,NA
ship(enterprise).,NA,NA
american(enterprise). ,NA,NA
And types can have subtypes: ,NA,NA
carrier(vinson).,NA,NA
ship(carrier).,NA,NA
These are all ,NA,NA
type predicates,NA,NA
", and they are all have one argument. The argument is the name of some ",NA,NA
"thing in the world, and the predicate name is the class or category it belongs to. So the predicate name is ",NA,NA
more general,NA,NA
 than the argument name; this is usual for predicate names in artificial intelligence. So it ,NA,NA
wouldn't be as good to say ,NA,NA
enterprise(ship).,NA,NA
kennedy(ship).,NA,NA
About types ,NA,NA
"We've said these predicates are like the types in computer languages, but there are some differences. The ",NA,NA
"main one is that they need never be defined anywhere. If for instance we are using Pascal, we either use ",NA,NA
"the built-in types (integer, real, character, array, and pointer) or define the type we want in terms of those ",NA,NA
"built-in types. But for artificial intelligence, the type (predicate) names are just arbitrary codes used in ",NA,NA
"lookup. This is because you can put integers and characters in a computer, but not a ship. You can't even ",NA,NA
"put in a full representation of a ship, or a full representation of any other real object--real objects have too ",NA,NA
"many complexities, while integers and characters are abstractions. ",NA,NA
"How then, if we expect the computer to be intelligent, will it ever know what a ship is? Much the way ",NA,NA
"people know. Ships are defined in a dictionary using the concept of a vehicle, the concept of water, the ",NA,NA
"concept of floating, and so on. A dictionary might say a ship is ""an oceangoing vessel"". But it might ",NA,NA
"define ""vessel"" as a ""craft for travelling on water"", and ""craft"" as an ""individual ship""--so the definitions ",NA,NA
"are circular, as all dictionary definitions are sooner or later. But we can indirectly figure out what is being ",NA,NA
"talked about by the secondary words like ""oceangoing"" and ""travelling"". So words must be defined in ",NA,NA
terms of one another. ,NA,NA
So we won't expect each type predicate to be ,NA,NA
implemented,NA,NA
" (that is, understood by a computer) by a ",NA,NA
"separate procedure or processing routine. The same holds for arguments. In fact, we could store all ",NA,NA
"predicate names and arguments the same way in the computer, as characters. This is a bit wasteful of ",NA,NA
computer storage space--so some Prolog dialects do store numbers differently--but there's nothing wrong ,NA,NA
philosophically with it. ,NA,NA
Good naming ,NA,NA
So predicate and argument names can be arbitrary; we just have to remember what they represent. But ,NA,NA
"one name can be better than another, if it is easier to remember what it means. Writing facts for an ",NA,NA
"artificial-intelligence program to use is a kind of programming, and we should follow the usual rules of ",NA,NA
"good programming style. In choosing names, we suggest these guidelines: ",NA,NA
"1. As much as possible, use everyday English words for names. If you need more than one ",NA,NA
"word, use the underscore character between them for clarity, like in ",NA,NA
day_of_week,NA,NA
 (though ,NA,NA
sometimes you can leave out the underscores like in ,NA,NA
dayofweek,NA,NA
 when the reading is ,NA,NA
reasonably clear). ,NA,NA
"2. Choose names that describe their function precisely. For instance, use ",NA,NA
day_of_week ,NA,NA
instead of ,NA,NA
day,NA,NA
", which could describe both ",NA,NA
monday,NA,NA
 and ,NA,NA
october_19_1985,NA,NA
. ,NA,NA
"3. Avoid names with multiple meanings. For instance, if there is a Commander Kennedy as ",NA,NA
"well as a ship named Kennedy, include the first initial of the person; or if you call the ",NA,NA
"Enterprise a ""ship"", don't also say that a unit ""shipped"" somewhere. ",NA,NA
"4. Avoid numbers in names, with two exceptions: arithmetic (see Chapter 5) and closely ",NA,NA
related variables and predicates (like ,NA,NA
X,NA,NA
 and ,NA,NA
X2,NA,NA
 in Section 5.5 and ,NA,NA
iterate,NA,NA
 and ,NA,NA
iterate2,NA,NA
 in ,NA,NA
Section 10.8). ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap2.html (4 of 13) [23/04/2002 17:38:34],NA
5. Abbreviate only when absolutely necessary. Since artificial intelligence programs often ,NA,NA
"use many names, abbreviations can be confusing. ",NA,NA
"6. Predicate names should be more general than their argument names, but not so general ",NA,NA
that they don't really mean anything (for then facts can't be indexed well). ,NA,NA
"7. A few predicate names are reserved or ""special"" to Prolog, so you can't use them for ",NA,NA
your own predicates. ,NA,NA
"8. Of course, always use the same name for the same thing. ",NA,NA
Property predicates ,NA,NA
We can tell the computer (or ,NA,NA
assert,NA,NA
): ,NA,NA
ship(enterprise).,NA,NA
gray(enterprise).,NA,NA
big(enterprise).,NA,NA
"which could mean ""The Enterprise is a ship, it is gray, and it is big."" (Never mind that ""big"" is vague; we ",NA,NA
"could define it as ""more than 800 feet long"", and ""gray"" and even ""ship"" are vague to a lesser extent (is a ",NA,NA
"toy ship a ship? and is an imaginary ship a ship?), and much human knowledge is vague anyway.) Or this ",NA,NA
"could mean the Enterprise is a member of the class of ships, a member of the class of gray things, and a ",NA,NA
"member of the class of big things. But those last two phrases awkward. ""Gray"" and ""big"" are adjectives, ",NA,NA
"not nouns like ""ship"", and they should be treated differently. ",NA,NA
So we'll represent properties of objects as ,NA,NA
property predicate expressions,NA,NA
", two-argument expressions in ",NA,NA
"which the predicate name is the name of a property, the first argument is the name of an object, and the ",NA,NA
second argument is the value of the property. The preceding example could be rewritten better as: ,NA,NA
ship(enterprise).,NA,NA
"color(enterprise,gray).",NA,NA
"size(enterprise,big).",NA,NA
This has the advantage of using predicate names that are more general. It also shows the relation between ,NA,NA
gray,NA,NA
 and ,NA,NA
enterprise,NA,NA
", and that between ",NA,NA
big,NA,NA
 and ,NA,NA
enterprise,NA,NA
: ,NA,NA
color,NA,NA
 and ,NA,NA
size,NA,NA
 are the property names for ,NA,NA
which ,NA,NA
gray,NA,NA
 and ,NA,NA
big,NA,NA
" are the values. So we've made some implicit (unstated ""common-sense"") knowledge ",NA,NA
"explicit (stated), a key goal in artificial intelligence. ",NA,NA
"Again, the computer won't actually know what ",NA,NA
gray,NA,NA
 and ,NA,NA
big,NA,NA
 mean if we type in the preceding three ,NA,NA
"example lines; those are just codes that it uses for comparison. For instance, if the computer also knows ",NA,NA
"color(kennedy,gray).",NA,NA
"then it knows the Enterprise and the Kennedy have the same color, though it doesn't know what a ""color"" ",NA,NA
"is (but don't blame it, because most computers don't have eyes). ",NA,NA
An important class of property predicates concern space and time. For instance ,NA,NA
"location(enterprise,14n35e).",NA,NA
"last_docking(enterprise,16feb85).",NA,NA
"could mean that the Enterprise is currently at latitude 14N and longitude 35E, and its last docking was on ",NA,NA
"February 16, 1985. ",NA,NA
Predicates for relationships ,NA,NA
Perhaps the most important predicates of all relate two different things. Such ,NA,NA
relationship predicates,NA,NA
 are ,NA,NA
"important because a lot of human reasoning seems to use them--people need to relate ideas. For instance, ",NA,NA
we can use a ,NA,NA
part_of,NA,NA
 predicate of two arguments which says that its first argument is a component within ,NA,NA
its second argument. We could give as facts: ,NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"part_of(u_s_navy,u_s_government).",NA,NA
"part_of(naval_postgraduate_school,u_s_government).",NA,NA
"part_of(propulsion_system,ship).",NA,NA
"In other words, the Enterprise is part of the U.S. Navy, the Navy is part of the U.S. government, the Naval ",NA,NA
"Postgraduate School is part of the U.S. government, and the propulsion system is part of a ship. An ",NA,NA
owns,NA,NA
 ,NA,NA
relationship predicate can say that something is owned by someone: ,NA,NA
"owns(tom,fido).",NA,NA
"owns(tom,toms_car).",NA,NA
These facts say that Tom owns two things: something called ,NA,NA
fido,NA,NA
", and an unnamed car which we can just ",NA,NA
refer to as ,NA,NA
toms_car,NA,NA
. ,NA,NA
It's easy to get confused about argument order in relationship predicate expressions. So we'll try to follow ,NA,NA
"this convention: if the predicate name is inserted between the two arguments, the result will be close to an ",NA,NA
"English sentence giving the correct meaning. So if we insert ""owns"" between ""tom"" and ""fido"" we get ",NA,NA
"""Tom owns Fido"", and if we insert ""part of"" between ""enterprise"" and ""u. s. navy"" we get ""Enterprise part ",NA,NA
"of U. S. Navy"". ",NA,NA
An important class of relationship predicates relates things in space and time. A real-world object can be ,NA,NA
"north, south, east, west, etc. of another object. Viewed by a fixed observer, an object can also be right, ",NA,NA
"left, above, below, in front, and behind another object. We can describe a picture with these predicates. ",NA,NA
"Similarly, an event in time can be before, after, during, overlapping, or simultaneous with another event, ",NA,NA
so we can describe history with these predicates. ,NA,NA
"Relationship predicates can describe relationships between people. For instance, the ",NA,NA
boss_of,NA,NA
 relationship ,NA,NA
"is important for describing bureaucracies, an important application of artificial intelligence. It says that a ",NA,NA
"person (first argument) is the boss of another person (second argument), and this shows direction of ",NA,NA
responsibility. People can also be related by kinship relationship predicates (,NA,NA
father,NA,NA
", ",NA,NA
mother,NA,NA
", ",NA,NA
child,NA,NA
", ",NA,NA
uncle,NA,NA
", ",NA,NA
cousin,NA,NA
", ",NA,NA
stepfather,NA,NA
", ",NA,NA
half-brother,NA,NA
", ",NA,NA
grandfather,NA,NA
", etc.). People can also be related with ",NA,NA
friend,NA,NA
 and ,NA,NA
acquaintance,NA,NA
 relationship predicates. ,NA,NA
"Besides all these, another special relationship predicate is frequently used in artificial intelligence. It's ",NA,NA
called ,NA,NA
a_kind_of,NA,NA
 or ,NA,NA
is_a,NA,NA
" (we prefer the first name, because ""is"" is vague), and it can replace all type ",NA,NA
"predicates. Its first argument is a thing, and its second argument is the type of that thing (the predicate ",NA,NA
name in the one-argument form considered before). For instance: ,NA,NA
"a_kind_of(enterprise,ship).",NA,NA
"a_kind_of(tanker,ship).",NA,NA
"a_kind_of(tuesday,day_of_week).",NA,NA
"which says that the Enterprise is a kind of ship, a tanker is a kind of ship, and Tuesday is a kind of day of ",NA,NA
the week | REFERENCE 4|. .FS | REFERENCE 4| Some researchers don't agree with this use of ,NA,NA
a_kind_of,NA,NA
. They think that the first two facts should have different predicate names since the Enterprise ,NA,NA
is an individual while tankers are a group of individuals; often they'll use the predicate name ,NA,NA
element,NA,NA
 for ,NA,NA
"the ""Enterprise"" fact, and keep ",NA,NA
a_kind_of,NA,NA
" for the ""tanker"" fact. But a set whose size is 1 is still a set, and ",NA,NA
there doesn't seem to be anything fundamentally different between restricting the body type of a ship to be ,NA,NA
"a tanker and restricting the name of a ship to be the word ""Enterprise""--it just happens that people try, not ",NA,NA
"always successfully, to make names unique. Researchers who argue against this may be getting this issue ",NA,NA
"confused with the important ""extensions vs. intensions"" problem which we'll discuss in Section 12.8. .FE ",NA,NA
Some reasoning is easier with this two-argument form than the equivalent one-argument form. ,NA,NA
"There are other predicates, but as any psychotherapist will tell you, relationships are the key to a happy ",NA,NA
life. ,NA,NA
Semantic networks ,NA,NA
Pictures can make a complicated set of facts a lot clearer. There's a simple pictorial way to show the ,NA,NA
predicate expressions we've been discussing: the ,NA,NA
semantic network,NA,NA
". Unfortunately, there is a major ",NA,NA
restriction: semantic networks can only directly represent predicates of two arguments (so type predicates ,NA,NA
must be in the two-argument form) | REFERENCE 5|. .FS | REFERENCE 5| But we can represent ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap2.html (7 of 13) [23/04/2002 17:38:34],NA
"predicate expressions with more than two arguments indirectly, as sets of two-argument predicate ",NA,NA
expressions. .FE ,NA,NA
A semantic network is what computer scientists call a a ,NA,NA
labeled directed graph,NA,NA
 (see Appendix C for a ,NA,NA
definition). We make every possible fact argument a small named circle (node) in the graph. For each ,NA,NA
"two-argument fact, we draw an arrow (edge) from the circle for its first argument to the circle for its ",NA,NA
"second argument, and label the arrow with the predicate name. So the fact ",NA,NA
"p(a,b)",NA,NA
 is represented as an ,NA,NA
"arrow from a circle labeled ""a"" to a circle labeled ""b"", with the arrow itself labeled ""p"". If for instance our ",NA,NA
facts are: ,NA,NA
"a_kind_of(enterprise,ship).",NA,NA
"a_kind_of(kennedy,ship).",NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
"part_of(u_s_navy,u_s_government).",NA,NA
"a_kind_of(u_s_government,government).",NA,NA
"color(ship,gray).",NA,NA
"location(enterprise,15n35e).",NA,NA
"has(u_s_government,civil_service_system).",NA,NA
then our semantic network looks like Figure 2-3. ,NA,NA
Getting facts from English descriptions ,NA,NA
"Usually programmers building artificial intelligence programs don't make up facts themselves. Instead, ",NA,NA
"they look up facts in documents and books, or ask people knowledgeable about the subject (""experts"") to ",NA,NA
tell them what they need--the process of ,NA,NA
knowledge acquisition,NA,NA
". But English and other ""natural ",NA,NA
"languages"" are less precise than computer languages (though more flexible), and the programmer must be ",NA,NA
careful to get the meanings right. ,NA,NA
"The sorts of facts we've considered so far are usually often signalled by the verb ""to be"" in English (",NA,NA
is,NA,NA
", ",NA,NA
"""are"", ""was"", ""were"", ""will be"", ""being"", and so on). For instance: ",NA,NA
The Enterprise is a ship. ,NA,NA
A ship is a vehicle. ,NA,NA
The Enterprise is part of the U.S. Navy. ,NA,NA
A ship is gray. ,NA,NA
"Here ""to be"" is used for type predicates (the first and second sentences), a ",NA,NA
part_of,NA,NA
 relationship predicate ,NA,NA
"(the third sentence), and a property predicate (the fourth sentence). Plurals can also be used: ",NA,NA
Ships are gray. ,NA,NA
Ships are vehicles. ,NA,NA
English verbs with narrower meanings can be used too: ,NA,NA
The Enterprise belongs to the U.S. Navy. ,NA,NA
The Enterprise has a hull. ,NA,NA
They color ships gray. ,NA,NA
The Enterprise is located at 15N35E. ,NA,NA
The first two suggest ,NA,NA
part_of,NA,NA
" relationship predicates, and the last two are property predicates. ",NA,NA
Predicates with three or more arguments ,NA,NA
You can have as many arguments to a predicate as you want if you're not concerned about easily ,NA,NA
"representing them in a semantic network. One idea is to include multiple property values in a single fact, ",NA,NA
much like adjectives and adverbs modifying a noun or verb. So for instance we could put everything we ,NA,NA
know about a ship together: ,NA,NA
"ship_info(enterprise,15n35e,1200,16feb85,gray,j_kirk).",NA,NA
"which we could read as ""The Enterprise is a ship that was at 15N25E at 12 noon on February 16, 1985, ",NA,NA
"and its color is gray, and its captain is J. Kirk."" To interpret such facts we need to keep a description ",NA,NA
somewhere of the properties and their order within the arguments. ,NA,NA
These sort of predicates define a ,NA,NA
relational database,NA,NA
 of facts. Much research has studied efficient ,NA,NA
implementation and manipulation of such databases. The information about properties and their order for ,NA,NA
each such predicate is called a ,NA,NA
database schema,NA,NA
. ,NA,NA
Another important category of predicates with often many arguments (though they can also have just ,NA,NA
"two) is that representing results of actions--in mathematical terminology, ",NA,NA
functions,NA,NA
. Suppose we want to ,NA,NA
teach a computer about arithmetic. We could use a predicate ,NA,NA
sum,NA,NA
" of three numerical arguments, which ",NA,NA
says that the sum of the first two arguments is the third. We could give as facts: ,NA,NA
"sum(1,1,2).",NA,NA
"sum(1,3,4).",NA,NA
"sum(1,4,5).",NA,NA
"sum(1,5,6).",NA,NA
"sum(2,1,3).",NA,NA
"sum(2,2,4).",NA,NA
"sum(2,3,5).",NA,NA
"sum(2,4,6).",NA,NA
"And we could do this for lots of different numbers, and different arithmetic operations. Of course for this ",NA,NA
"to be useful in general, we would need very many facts and this would be unwieldy (we will describe a ",NA,NA
"better way in Chapter 5), but it will suffice to define operations on any finite set of numbers. ",NA,NA
"We will use function predicates frequently. To avoid confusion, we follow the convention that the last ",NA,NA
"argument always represents the result of (value returned by) the function, with the exception noted in the ",NA,NA
"next section | REFERENCE 6|. .FS | REFERENCE 6| If you're familiar with Lisp, be careful to include ",NA,NA
"the function result as an argument to Prolog predicates. In Lisp, a value is always associated with the ",NA,NA
"whole expression, something you can't do in Prolog. .FE ",NA,NA
"Functions can also be nonnumeric. An example is a function that gives, for two employees of a company, ",NA,NA
the name of the lowest-ranking boss over both of them. Since artificial intelligence emphasizes ,NA,NA
"nonnumeric reasoning, you'll see more nonnumeric than numeric functions in this book. ",NA,NA
Probabilities ,NA,NA
We have assumed so far that facts are always completely certain. In many situations (as when facts are ,NA,NA
"based on reports by people), facts are only probably true. Then we will use the mathematical idea of ",NA,NA
probability,NA,NA
", the expected fraction of the time something is true. We will put an approximate probability ",NA,NA
"as an optional last argument to a predicate, after the previously discussed function result if any. So for ",NA,NA
instance ,NA,NA
"color(enterprise,gray,0.8).",NA,NA
says that we're 80 percent sure (or sure with probability 0.8) that the Enterprise is gray. We'll ignore this ,NA,NA
topic until Chapter 8. ,NA,NA
How many facts do we need? ,NA,NA
An infinity of facts are true about the world. How then do we decide which to tell a computer? This ,NA,NA
"question has no easy answers. Generally, you must decide what you want the computer to do. Then make ",NA,NA
"sure to tell the computer in advance every fact that might be relevant to that behavior. ""Libraries"" of ",NA,NA
"useful facts for particular subjects will help. But the smarter you want the computer to be, the more facts ",NA,NA
"you must tell it. The next chapter will discuss the next question, how to get the computer to do things with ",NA,NA
facts. ,NA,NA
Keywords: ,NA,NA
knowledge,NA,NA
facts,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap2.html (10 of 13) [23/04/2002 17:38:34],NA
logic ,NA,NA
predicate calculus ,NA,NA
Prolog ,NA,NA
predicate ,NA,NA
predicate expression ,NA,NA
arguments ,NA,NA
semantics ,NA,NA
type predicate ,NA,NA
assertion ,NA,NA
property predicate ,NA,NA
relationship predicate ,NA,NA
part_of ,NA,NA
a_kind_of ,NA,NA
semantic network ,NA,NA
knowledge acquisition ,NA,NA
relational-database predicate ,NA,NA
function predicate ,NA,NA
probability predicate,NA,NA
Exercises ,NA,NA
"(Note: answers to exercises marked with the code ""A"" are given at the back of the book.) ",NA,NA
"2-1. (A,E) Which of the following facts is better knowledge representation? Explain. (""Better"" means ",NA,NA
less likely to confuse people.) ,NA,NA
"color(enterprise,gray). ",NA,NA
"size(enterprise,big).",NA,NA
"2-2. (R,A,E) Suppose you want to store facts about when and where memos were sent in an ",NA,NA
"organization. Which is the best Prolog format for such facts, and why? ",NA,NA
"(i) <date>(<name>,<author>,<distribution>). ",NA,NA
"(ii) memo(<name>,<date>,<author>,<distribution>).",NA,NA
"(iii) fact(memo,<name>,<date>,<author>,<distribution>). ",NA,NA
2-3. Draw a semantic network representing the following facts: ,NA,NA
Ships are things. ,NA,NA
Carriers are ships. ,NA,NA
Ships have a position. ,NA,NA
Ships have a crew. ,NA,NA
Carriers have planes. ,NA,NA
Planes are things. ,NA,NA
A crew consists of people. ,NA,NA
People are things. ,NA,NA
2-4. Represent the nonnumeric meaning of the picture in Figure 2-4 as a set of nonnumeric Prolog ,NA,NA
facts. (Hint: describe the circles and their relationships.) ,NA,NA
2-5. (A) One-argument and two-argument predicates are very common in Prolog knowledge ,NA,NA
representation. Most of the facts you want to put into computers can be represented with them. ,NA,NA
"Someone might say that this shouldn't be surprising, because most operations in mathematics are ",NA,NA
"either unary (applied to a single thing like the square root operation or the sine operation), or ",NA,NA
"binary (applied to two things, like addition and exponentiation). What's wrong with this comment? ",NA,NA
"2-6. (R,A) Consider the six-argument ship_info facts in Section 2.9. To represent them in a ",NA,NA
"semantic network, we need to convert each to a set of two-argument facts. Explain how. Assume ",NA,NA
that six-argument facts only record the most recent position of a ship. ,NA,NA
"2-7. (A,E) Why might it be a good idea to put falsehoods (statements false in the world) into a ",NA,NA
computer? ,NA,NA
"2-8. Suppose you want to write a program that reasons like Sherlock Holmes did, about the facts of ",NA,NA
some crime to decide who is responsible. You want to represent in Prolog style the facts you find ,NA,NA
"about the crime, and the reports of witnesses. The argument types used for facts will vary. But ",NA,NA
certain arguments must be included in every fact about the crime--what are they? And certain ,NA,NA
arguments must be included in every fact giving a report from a witness--what are they? ,NA,NA
2-9. (E) Why must the representation of these two facts be fundamentally different? ,NA,NA
Clint is mayor. ,NA,NA
Someone is mayor. ,NA,NA
"2-10. (E) Consider the use of the word ""boss"" in the following facts. Suppose you wanted to ",NA,NA
represent these facts in Prolog. Would it be a good idea for any two of these to use the same word ,NA,NA
"""boss"" as either a predicate name or an argument name? ",NA,NA
Mary is boss of Dick. ,NA,NA
Dick and Mary boss their children around. ,NA,NA
"""Boss"" has four letters. ",NA,NA
A boss has managerial responsibilities. ,NA,NA
2-11. (E) Another way to put facts inside computers is with a restricted subset of English. For ,NA,NA
instance: ,NA,NA
The Enterprise is a ship. ,NA,NA
The Enterprise is part of the US Navy. ,NA,NA
The color of the Enterprise is gray. ,NA,NA
The Enterprise is at 15N25A. ,NA,NA
(a) Discuss the advantages of storing facts this way instead of with predicate expressions as we have ,NA,NA
done in the chapter. ,NA,NA
(b) Give a disadvantage for efficient use of the facts. ,NA,NA
(c) Give a disadvantage for programming errors. ,NA,NA
Go to book index,NA,NA
Variables and queries ,NA,NA
"We can put facts into a computer. So what can we do with them? Well, we want to ",NA,NA
reason,NA,NA
 about facts ,NA,NA
and conclude new facts--what's called ,NA,NA
inference,NA,NA
". For this we'll need the concepts of queries, variables, ",NA,NA
and backtracking. ,NA,NA
Querying the facts ,NA,NA
One thing we can do with facts in a computer is to look them up. This is the usual mode of ,NA,NA
Prolog ,NA,NA
interpreters,NA,NA
", software that interprets and executes code written in the Prolog language | REFERENCE 1|: ",NA,NA
they wait for us to give them things they can try to look up. .FS | REFERENCE 1| Most Prolog-,NA,NA
understanding software are interpreters like this and not ,NA,NA
compilers,NA,NA
. A Prolog interpreter is not an ,NA,NA
"""artificial intelligence program"" but a tool to execute artificial-intelligence programs written in the Prolog ",NA,NA
language. .FE You're in this ,NA,NA
query mode,NA,NA
 when the Prolog interpreter types ,NA,NA
?- ,NA,NA
at the front of every line. ,NA,NA
"Query mode is the way database query languages work, like SQL and QUEL. ",NA,NA
"To make this clearer, assume these facts (the semantic network example from Section 2.7) have been ",NA,NA
entered into a computer running a Prolog interpreter: ,NA,NA
"a_kind_of(enterprise,ship).",NA,NA
"a_kind_of(kennedy,ship).",NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
"part_of(u_s_navy,u_s_government).",NA,NA
"a_kind_of(u_s_government,government).",NA,NA
"color(ship,gray).",NA,NA
"location(enterprise,15n35e).",NA,NA
"has(u_s_government,civil_service_system).",NA,NA
We call such a set of facts known to a Prolog interpreter a ,NA,NA
Prolog database,NA,NA
 or just ,NA,NA
database,NA,NA
. As we'll ,NA,NA
"explain shortly, databases can be loaded from files. The block diagram in Figure 3-1 summarizes these ",NA,NA
basics. ,NA,NA
Now in query mode we can type ,NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
so that what actually shows on the computer terminal will be ,NA,NA
"?- part_of(kennedy,u_s_navy).",NA,NA
Note the period; the interpreter will wait (forever if necessary) until we type it. Then the interpreter will ,NA,NA
type in reply the single word ,NA,NA
yes,NA,NA
 to acknowledge that the fact is in its database. If we ask instead ,NA,NA
"?- part_of(pequod,u_s_navy).",NA,NA
(again the ,NA,NA
?- ,NA,NA
"is typed by the interpreter and not us), the computer will type the single word ",NA,NA
no,NA,NA
. So ,NA,NA
yes ,NA,NA
"means ""I found it"" and ",NA,NA
no,NA,NA
" means ""I couldn't find it"". We call a ",NA,NA
yes,NA,NA
 a query ,NA,NA
success,NA,NA
 and ,NA,NA
no,NA,NA
 a query ,NA,NA
failure,NA,NA
. So to make the computer say ,NA,NA
no,NA,NA
 when a query is ,NA,NA
false,NA,NA
", the database must include every truth ",NA,NA
"about its subject, for otherwise ",NA,NA
no,NA,NA
 could mean incomplete data. ,NA,NA
Queries with one variable ,NA,NA
"But this isn't too interesting. A query must give the precise fact we want to look up, including every ",NA,NA
argument. We might instead want to ask if a ,NA,NA
part_of,NA,NA
 fact has ,NA,NA
enterprise,NA,NA
 as its first argument and ,NA,NA
anything at all as its second argument. We can do this by querying ,NA,NA
"?- part_of(enterprise,X).",NA,NA
"Read this as ""Find me an ""X"" such that ",NA,NA
"part_of(enterprise,X)",NA,NA
" is true,"" or simply as ""What is the ",NA,NA
"Enterprise part of?"" The Prolog interpreter will go through its facts in order, trying to match each to the ",NA,NA
"query. When it finds one that matches in predicate name and first argument, it will type """,NA,NA
X=,NA,NA
""" followed ",NA,NA
"by the fact's second argument, instead of typing ",NA,NA
yes,NA,NA
". Or in technical jargon, it ",NA,NA
binds,NA,NA
 or ,NA,NA
matches,NA,NA
X,NA,NA
 to a ,NA,NA
"value and prints it. So for this query with the previous database, we will get ",NA,NA
X=u_s_navy,NA,NA
or ,NA,NA
X,NA,NA
 is bound to ,NA,NA
u_s_navy,NA,NA
. ,NA,NA
X,NA,NA
 here is a ,NA,NA
variable,NA,NA
". Prolog variables have similarities to variables in other programming languages, but ",NA,NA
also important differences we'll encounter as we proceed. Prolog variables are designated by a capitalized ,NA,NA
"first letter in a word (followed by other letters and numbers, either capitalized or uncapitalized), and this ",NA,NA
is why in the last chapter we used lower case for other words in Prolog. ,NA,NA
Variables can only be arguments in Prolog; they can't appear as predicate names (though we'll give a way ,NA,NA
around this limitation in Chapter 12). This means Prolog represents only ,NA,NA
first-order logic,NA,NA
. First-order ,NA,NA
"logic is sufficient for nearly all artificial-intelligence applications, so that's no big deal. First-order logic is ",NA,NA
a reason we insisted in Chapter 2 on predicate names more general than their argument names: variables ,NA,NA
pay off when they stand for lots of possibilities. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (2 of 22) [23/04/2002 17:38:38],NA
Multi-directional queries ,NA,NA
"A variable can appear anywhere among the arguments to a predicate expression in a query, with some ",NA,NA
exceptions to be discussed later. So we could also query with the previous database ,NA,NA
"?- part_of(X,u_s_navy).",NA,NA
and the Prolog interpreter will type back ,NA,NA
X=enterprise ,NA,NA
"In other words, we can be flexible about which arguments are ",NA,NA
inputs,NA,NA
 (constants) and which are ,NA,NA
outputs ,NA,NA
(variables) in a query. This means Prolog can answer quite different questions depending on where we ,NA,NA
put variables in the query. This flexibility extends to calls of Prolog procedures (subroutines and ,NA,NA
"functions) too, as you will see in Chapter 4, a big difference from most programming languages. ",NA,NA
Matching alternatives ,NA,NA
"More than one thing (value) can match (bind) a query variable. The Prolog interpreter will find the first, ",NA,NA
"print it out, and stop and wait If just one is sufficient, type a carriage return. But to see the next answer (if ",NA,NA
"any), type a semicolon (""",NA,NA
;,NA,NA
"""). We can keep typing semicolons, and it will keep finding new matches, until ",NA,NA
it can't find any more and it must answer ,NA,NA
no,NA,NA
. So for our example database if we query ,NA,NA
"?- a_kind_of(X,ship).",NA,NA
"which means ""Find me an X that's a kind of ship,"" the interpreter will first type ",NA,NA
X=enterprise ,NA,NA
and then if we type a semicolon it will type ,NA,NA
X=kennedy ,NA,NA
and then if we type a semicolon it will type ,NA,NA
no,NA,NA
". The semicolon prints at the end of the line, so what this ",NA,NA
will all look like on the computer terminal will be: ,NA,NA
"?- a_kind_of(X,ship). ",NA,NA
X=enterprise; ,NA,NA
X=kennedy; ,NA,NA
no,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (3 of 22) [23/04/2002 17:38:38],NA
"where we typed the two semicolons and the first line except for the """,NA,NA
?- ,NA,NA
""", and the interpreter typed the ",NA,NA
rest. ,NA,NA
We can have more than one variable in a query. If we were to query for our example database ,NA,NA
"?- part_of(X,Y).",NA,NA
"(""What things are part of other things?"") and we kept typing semicolons, we would eventually see on the ",NA,NA
computer terminal some like this (some Prolog dialects format this output slightly differently): ,NA,NA
"X=enterprise, Y=u_s_navy; ",NA,NA
"X=kennedy, Y=u_s_navy; ",NA,NA
"X=u_s_navy, Y=u_s_government; ",NA,NA
no ,NA,NA
So semicolons find us every combination of bindings of the variables that satisfies a query. Since the ,NA,NA
"Prolog interpreter works top to bottom through the database, the bindings will reflect database order. ",NA,NA
Multi-condition queries ,NA,NA
A Prolog interpreter also lets us specify that several different conditions must succeed together in a ,NA,NA
"query. This lets us specify ""chains of reasoning"", like those so important to detectives in mystery fiction. ",NA,NA
Suppose we wanted to know the gray-color of the Enterprise. If we type ,NA,NA
"?- color(enterprise,C).",NA,NA
we get ,NA,NA
no,NA,NA
" with our example database, because the color fact is about ships in general and not the ",NA,NA
"Enterprise. This problem of information in the ""wrong place"" happens often in artificial-intelligence ",NA,NA
"systems. Instead we can ask if there is some category or type T that the Enterprise belongs to, such that ",NA,NA
everything of type T has color C: ,NA,NA
"?- a_kind_of(enterprise,T), color(T,C).",NA,NA
"This represents an ""and"" (",NA,NA
conjunction,NA,NA
") of two predicate expressions, both of which must succeed for the ",NA,NA
whole match to succeed. It works this way: we first try to answer the query ,NA,NA
"?- a_kind_of(enterprise,T).",NA,NA
Then for that particular ,NA,NA
T,NA,NA
", we answer the query ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (4 of 22) [23/04/2002 17:38:38],NA
"?- color(T,C).",NA,NA
"Using our example database, we first match ",NA,NA
T,NA,NA
 to ,NA,NA
ship,NA,NA
 in the first-listed fact. We then look for a ,NA,NA
color,NA,NA
 fact ,NA,NA
in which this ,NA,NA
T,NA,NA
" is the first argument, and the seventh-listed fact qualifies; we can then match ",NA,NA
C,NA,NA
 to ,NA,NA
gray,NA,NA
. ,NA,NA
The Prolog interpreter now types out: ,NA,NA
"T=ship, C=gray",NA,NA
So commas between predicate expressions in a query line mean reusing the same values for any same-,NA,NA
"named variables. Commas are like a logical ""and"" since all the subqueries (predicate expressions) must ",NA,NA
"succeed for the whole query to succeed. To make commas easier to spot, we'll often put spaces after them ",NA,NA
in queries; these spaces are ignored by the interpreter. (But don't put spaces in predicate expressions.) ,NA,NA
"As another example, suppose we want to know what the Enterprise is part of. We could say ",NA,NA
"?- part_of(enterprise,X).",NA,NA
and get ,NA,NA
X=u_s_navy,NA,NA
", but that's not the only reasonable answer since the U.S. Navy is part of something ",NA,NA
else. So we could say: ,NA,NA
"?- part_of(enterprise,X), part_of(X,Y).",NA,NA
and get back ,NA,NA
"X=u_s_navy, Y=u_s_government",NA,NA
. ,NA,NA
"Logical ""or"" (",NA,NA
disjunction,NA,NA
) is represented by a semicolon instead of a comma. For instance ,NA,NA
"?- color(enterprise,C); color(ship,C).",NA,NA
"asks for the color of the Enterprise if any is recorded, otherwise the color of ships in general. Parentheses ",NA,NA
"can group which predicate expressions go with which others in ""and""s and ""or""s. So for instance the two ",NA,NA
conditions under which something is part of something else could be compressed into one with: ,NA,NA
"?- part_of(enterprise,X); (part_of(enterprise,Y), part_of(Y,X)).",NA,NA
"This reads: ""Find me an X such that either the Enterprise is part of it, or the Enterprise is part of some Y ",NA,NA
"that is part of it."" We won't use these ""or"" semicolons much, because (1) ""and""s occur more often in ",NA,NA
"applications, (2) they often require parentheses and so are hard to read, and (3) there is a better way to get ",NA,NA
"the effect of an ""or"", to be discussed in the next chapter. ",NA,NA
"Figure 3-2 should help you keep straight the special symbols we've used so far, plus previewing a few to ",NA,NA
come. ,NA,NA
Negative predicate expressions ,NA,NA
"So we have ""and""s and ""or""s. All we need to complete a Boolean algebra is a negation or ""not"". This is ",NA,NA
accomplished by the built-in predicate ,NA,NA
not,NA,NA
 whose one argument is a predicate expression. (A ,NA,NA
built-in ,NA,NA
"predicate is one with special meaning to the interpreter, a meaning not given by facts.) A ",NA,NA
not,NA,NA
 succeeds ,NA,NA
"whenever querying its argument fails, a fails whenever querying its argument succeeds. So the query ",NA,NA
"?- not(color(enterprise,green)).",NA,NA
"will succeed whenever there's no fact that the color of the Enterprise is green, and fail when there is such ",NA,NA
"a fact. We'll extend the term ""predicate expression"" to include such ",NA,NA
not,NA,NA
 expressions too. ,NA,NA
How will the Prolog interpreter ever be sure something is ,NA,NA
not,NA,NA
" true? Strictly speaking, it can't, since facts ",NA,NA
that directly say something is false are not permitted in Prolog (Chapter 14 discusses this further). So ,NA,NA
not ,NA,NA
is defined to mean the interpreter couldn't find a fact in its database--,NA,NA
negation-by-failure,NA,NA
 or ,NA,NA
the closed-,NA,NA
world assumption,NA,NA
". Yet this is a curious and awkward interpretation of ""not"", not what we usually mean ",NA,NA
by the word in English. So we must be careful with ,NA,NA
not,NA,NA
" in Prolog. One big problem is that we can't, with ",NA,NA
"a few exceptions, put unbound variables within a ",NA,NA
not,NA,NA
. So this query won't work: ,NA,NA
"?- not(color(X,gray)), a_kind_of(X,ship).",NA,NA
(This asks for a ship ,NA,NA
X,NA,NA
 that isn't gray.) Instead we must reverse the order of the two things: ,NA,NA
"?- a_kind_of(X,ship), not(color(X,gray)).",NA,NA
Some query examples ,NA,NA
Questions in English about a database often map directly into Prolog queries. Words like ,NA,NA
is,NA,NA
", ""are"", ",NA,NA
"""does"", and ""did"" at the beginning of a question suggest queries without variables (yes/no queries). ",NA,NA
"Words like ""what"", ""which"", ""who"", ""where"", ""when"", and ""how"" suggest variables. ",NA,NA
Here are some examples. We assume the meanings of the ,NA,NA
part_of,NA,NA
", ",NA,NA
color,NA,NA
", ",NA,NA
a_kind_of,NA,NA
", etc. predicates ",NA,NA
we've been assuming all along. (These queries print out additional variable values than those desired; ,NA,NA
Chapter 4 will explain how to prevent this.) ,NA,NA
1. What things are part of gray things? ,NA,NA
"?- part_of(X,Y), color(Y,gray).",NA,NA
2. What things are part of parts of other things? ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (6 of 22) [23/04/2002 17:38:38],NA
"?- part_of(A,B), part_of(B,C). ",NA,NA
3. What things are gray or blue? ,NA,NA
"?- color(T,gray); color(T,blue).",NA,NA
4. What isn't an example of a gray thing? (,NA,NA
Example,NA,NA
 suggests the reverse of the ,NA,NA
a_kind_of,NA,NA
 relationship.) ,NA,NA
"?- a_kind_of(E,T), not(color(T,gray)).",NA,NA
"5. What is the Enterprise, either directly or through one level of indirection? ",NA,NA
"?- a_kind_of(enterprise,J); (a_kind_of(enterprise,K), a_kind_of(K,J)). ",NA,NA
"6. What things of which the Enterprise is part, are themselves part of something that has a civil service ",NA,NA
system? ,NA,NA
"?- part_of(enterprise,U), part_of(U,V), has(V,civil_service_system).",NA,NA
Loading a database ,NA,NA
How do we load a database of facts into a Prolog interpreter in the first place? This varies between ,NA,NA
"implementations of Prolog interpreters, but usually we must first enter the facts we want into a text file, ",NA,NA
using an editor program. We exit the editor and start up the Prolog interpreter. We then query a special ,NA,NA
built-in,NA,NA
" loading predicate, called ",NA,NA
consult,NA,NA
 in this book. This ,NA,NA
consult,NA,NA
 is not something we must give facts ,NA,NA
"for, but an internal Prolog name like ",NA,NA
not,NA,NA
"; it takes one argument, the name of a file to load into the Prolog ",NA,NA
"interpreter's internal memory (database). From then on, the facts in that file will be used to answer ",NA,NA
queries. ,NA,NA
"For instance, suppose we use the editor to create a file called ""test"", containing: ",NA,NA
boss(harry).,NA,NA
employee(tom).,NA,NA
employee(dick).,NA,NA
"We can start the Prolog interpreter, type the query ",NA,NA
?- consult(test). ,NA,NA
and then type the query ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (7 of 22) [23/04/2002 17:38:38],NA
?- employee(X).,NA,NA
and get ,NA,NA
X=tom,NA,NA
from the first fact in the file that matches. ,NA,NA
"We can load more than one file into the Prolog interpreter, if several files contain useful facts. Just query ",NA,NA
consult,NA,NA
" again. New facts are put after the old facts, so you can get answers in a different order if you load ",NA,NA
the same files in a different order. ,NA,NA
Backtracking ,NA,NA
Let's consider in more detail how the Prolog interpreter answers complicated queries. To make this ,NA,NA
"easier, consider for now queries with only commas (""and""s), no semicolons (""or""s) or ",NA,NA
not,NA,NA
s. ,NA,NA
"Predicate expressions ""and""ed in a query are first taken left to right. That is, the leftmost expression is ",NA,NA
"tried first, then the second expression from the left (using whatever variable matches were found for the ",NA,NA
"first) and so on. So predicate expressions in a query are initially done in order, like lines of a program in ",NA,NA
a conventional language like Pascal. ,NA,NA
"But suppose that a predicate expression fails--that is, no fact matching it can be found. If the expression ",NA,NA
"has variables that were bound earlier in the query line, the fault may just be in the bindings. So the ",NA,NA
interpreter automatically ,NA,NA
backtracks,NA,NA
 (goes back to the immediately previous expression in the query) and ,NA,NA
"tries to find a different fact match. If it cannot, then ",NA,NA
that,NA,NA
 predicate expression fails and the interpreter ,NA,NA
"backtracks to the previous one, and so on. ",NA,NA
"Anytime the Prolog interpreter cannot find another matching for the leftmost expression in a query, then ",NA,NA
there's no way the query could be satisfied; it types out the word ,NA,NA
no,NA,NA
 and stops. Anytime on backtracking ,NA,NA
"it can find a new matching for some predicate expression, it resumes moving right from there as it did ",NA,NA
originally. ,NA,NA
"The purpose of backtracking is to give ""second chances"" to a query, by revising earlier decisions. ",NA,NA
"Backtracking is very important in artificial intelligence, because many artificial-intelligence methods use ",NA,NA
"intelligent guessing and following of hunches. Guesses may be wrong, and backtracking is a good way to ",NA,NA
recover then. ,NA,NA
Here's an example: ,NA,NA
"?- part_of(X,Y), has(Y,civil_service_system).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (8 of 22) [23/04/2002 17:38:38],NA
which asks for an ,NA,NA
X,NA,NA
 that is part of some ,NA,NA
Y,NA,NA
 that has a civil service system. Assume the standard database ,NA,NA
example of this chapter. Then the only facts that will help with this query (the only facts with predicate ,NA,NA
names ,NA,NA
part_of,NA,NA
 and ,NA,NA
has,NA,NA
) are: ,NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
"part_of(u_s_navy,u_s_government).",NA,NA
"has(u_s_government,civil_service_system).",NA,NA
Here in detail is what the Prolog interpreter does to answer this query: ,NA,NA
"1. It takes the first predicate expression in the query, and matches ",NA,NA
X,NA,NA
 to ,NA,NA
enterprise,NA,NA
", and ",NA,NA
Y ,NA,NA
to ,NA,NA
u_s_navy,NA,NA
. It stores the information that it has chosen the first fact to match the first ,NA,NA
expression. ,NA,NA
"2. It then moves to the second predicate expression, and tries to answer the ",NA,NA
subquery,NA,NA
"?- has(u_s_navy,civil_service_system).",NA,NA
"That is, it ""substitutes"" in the value bound to variable ",NA,NA
Y,NA,NA
. But the subquery fails since ,NA,NA
there's no such fact. ,NA,NA
"3. So it must backtrack, or return to the first predicate expression in the query. From its ",NA,NA
"stored information, it knows it chose the first ",NA,NA
part_of,NA,NA
" fact last time, so now it tries the ",NA,NA
"second, binding ",NA,NA
X,NA,NA
 to ,NA,NA
kennedy,NA,NA
 and ,NA,NA
Y,NA,NA
 to ,NA,NA
u_s_navy,NA,NA
. It stores the information about what it ,NA,NA
chose. ,NA,NA
4. It then tries to answer the subquery ,NA,NA
"?- has(u_s_navy,civil_service_system).",NA,NA
"This is the same query it did in step 2, but the interpreter is stupid and doesn't remember ",NA,NA
"(Chapter 6 will explain how to force it to remember), so it checks the facts and fails to find ",NA,NA
anything again. The subquery fails. ,NA,NA
"5. So it backtracks again, to the first predicate expression in the query. It chose the second ",NA,NA
"fact last time, so it now chooses the third (and last) ",NA,NA
part_of,NA,NA
 fact. So ,NA,NA
X,NA,NA
 is bound to ,NA,NA
u_s_navy,NA,NA
 and ,NA,NA
Y,NA,NA
 is bound to ,NA,NA
u_s_government,NA,NA
. ,NA,NA
6. The second expression is considered with the new binding for ,NA,NA
Y,NA,NA
", and the interpreter tries ",NA,NA
to answer the subquery ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (9 of 22) [23/04/2002 17:38:38],NA
"?- has(u_s_government,civil_service_system).",NA,NA
And this succeeds because it's the fourth fact. ,NA,NA
"7. So both predicate expressions in the query succeed, and the whole query succeeds. The ",NA,NA
interpreter prints out the bindings that it found: ,NA,NA
"X=u_s_navy, Y=u_s_government",NA,NA
Notice that the interpreter wouldn't have had to backtrack if we just reversed the order of the query ,NA,NA
"(""and"" is commutative--see Appendix A): ",NA,NA
"?- has(Y,civil_service_system), part_of(X,Y).",NA,NA
because only one fact can match the ,NA,NA
has,NA,NA
 predicate expression. But that requires analyzing the facts in ,NA,NA
"advance, and probably won't be true for a complete database for an application. ",NA,NA
The automatic backtracking of the Prolog interpreter has both advantages and disadvantages. A big ,NA,NA
"advantage is that combinatorial problems are easier to specify than with most computer languages, ",NA,NA
because the interpreter does more work for you. It also means that Prolog is a more flexible language ,NA,NA
"than most: if you refer to an unbound variable in Pascal, Ada, PL/I, or Fortran, you get an error message ",NA,NA
and the program stops. The disadvantages are that Prolog programs run slower than those of other ,NA,NA
"languages, and they're sometimes harder to understand and debug, because the language tries to do more. ",NA,NA
A harder backtracking example: superbosses ,NA,NA
Here is another backtracking example. It's trickier than the last because two predicate expressions both ,NA,NA
"have alternatives. Furthermore, the same predicate name is used twice, and we have to distinguish the ",NA,NA
alternatives for each use. ,NA,NA
"Suppose we have facts about employees in an organization, represented with a two-argument predicate ",NA,NA
boss,NA,NA
". Its first argument a boss, and its second argument is an employee of that boss. Take the following ",NA,NA
example database: ,NA,NA
"boss(dick,harry).",NA,NA
"boss(tom,dick).",NA,NA
"boss(ann,mary).",NA,NA
"boss(mary,harry).",NA,NA
"Suppose we want find ""superbosses"", people who are bosses of bosses. That is, those X that are a boss of ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (10 of 22) [23/04/2002 17:38:38],NA
some Y while at the same time Y is a boss of some Z. We can issue the query ,NA,NA
"?- boss(X,Y), boss(Y,Z).",NA,NA
and every match the interpreter finds for variable ,NA,NA
X,NA,NA
 will be a superboss. (Matches for ,NA,NA
Y,NA,NA
 and ,NA,NA
Z,NA,NA
 will also ,NA,NA
"be found, but ",NA,NA
X,NA,NA
" is all that we want, according to the way we stated the problem.) ",NA,NA
"Let's trace query execution (summarized in Figure 3-3). As usual, assume facts are placed in the Prolog ",NA,NA
database in the order listed. ,NA,NA
"1. The first predicate expression in the query will match the first fact in the database, with ",NA,NA
X=dick,NA,NA
 and ,NA,NA
Y=harry,NA,NA
. ,NA,NA
"2. Moving to the second predicate expression in the query, the interpreter searches for a ",NA,NA
boss,NA,NA
 fact with ,NA,NA
harry,NA,NA
" as its first argument. But there's no such fact in the database, so the ",NA,NA
second expression in the query fails. ,NA,NA
"3. So the interpreter backtracks, returning to the first expression to make another choice. ",NA,NA
"Last time it used the first fact in the database, so this time it uses the second fact and sets ",NA,NA
X=tom,NA,NA
 and ,NA,NA
Y=dick,NA,NA
. ,NA,NA
4. Things proceed just as if these matchings happened originally. The interpreter goes to ,NA,NA
"the second predicate expression, and searches for a ",NA,NA
boss,NA,NA
 fact where ,NA,NA
dick,NA,NA
 is the first ,NA,NA
"argument. And yes, there is such a fact, the first fact in the database. ",NA,NA
5. So ,NA,NA
Z=harry,NA,NA
", and since we're at the end of the query, the query succeeds. Therefore Tom ",NA,NA
is a superboss. The interpreter types out ,NA,NA
"X=tom, Y=dick, Z=harry",NA,NA
. ,NA,NA
Now we can explain better what typing a semicolon does after the Prolog interpreter types out a query ,NA,NA
answer (not to be confused with a semicolon in a ,NA,NA
query:,NA,NA
" it forces failure and backtracking. For instance, ",NA,NA
suppose after that answer ,NA,NA
X=tom,NA,NA
 we type a semicolon instead of a carriage return. What happens now is ,NA,NA
"summarized in Figure 3-4, together with the previous events. ",NA,NA
"6. The interpreter will go back to what it just finished, the second expression of the query, ",NA,NA
and try to find a different match. ,NA,NA
"7. The old match for the second query expression was from the first fact, so now it ",NA,NA
"examines the second, third, and fourth facts in order. Unfortunately, none have ",NA,NA
dick,NA,NA
 as ,NA,NA
"their first argument, so the expression fails. ",NA,NA
8. So the interpreter must return to the first predicate expression yet again. The first and ,NA,NA
"second facts have been tried, so it uses the third fact and sets ",NA,NA
X=ann,NA,NA
 and ,NA,NA
Y=mary,NA,NA
. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (11 of 22) [23/04/2002 17:38:38],NA
9. It resumes normal left-to-right processing and tries to find a match for the second query ,NA,NA
"expression, starting at the top of the list of facts. (Each time it approaches a query predicate ",NA,NA
"expression from the left, it starts at the top of the facts.) This means finding a fact where ",NA,NA
mary,NA,NA
" is the first argument, and indeed the fourth fact qualifies. ",NA,NA
10. So ,NA,NA
Z=harry,NA,NA
", and the entire query succeeds when ",NA,NA
X=ann,NA,NA
", meaning that Ann is a ",NA,NA
superboss. The interpreter types out ,NA,NA
"X=ann, Y=mary, Z=harry",NA,NA
. ,NA,NA
"Backtracking with ""not""s ",NA,NA
Negated predicate expressions (expressions with a ,NA,NA
not,NA,NA
) are easy with backtracking. Since they can't bind ,NA,NA
"variables to succeed, they can be skipped in backtracking. For instance, we could add another expression ",NA,NA
to our superboss query to insist that the superboss not be the boss of Dick: ,NA,NA
"?- boss(X,Y), not(boss(X,dick)), boss(Y,Z).",NA,NA
Then when the interpreter executes the new query (see Figure 3-5): ,NA,NA
"1. The first predicate expression matches the first fact in the database as before, setting ",NA,NA
X=dick,NA,NA
 and ,NA,NA
Y=harry,NA,NA
. ,NA,NA
2. This binding of ,NA,NA
X,NA,NA
" satisfies the second condition, the ",NA,NA
not,NA,NA
 (Dick isn't his own boss). ,NA,NA
"3. For the third expression, there's no fact with ",NA,NA
harry,NA,NA
" as its first argument, so it fails. The ",NA,NA
interpreter backtracks to the immediately previous (second) expression. ,NA,NA
4. But the second expression is a ,NA,NA
not,NA,NA
", and ",NA,NA
not,NA,NA
"s always fail on backtracking, so the ",NA,NA
interpreter returns to the first expression and matches ,NA,NA
X=tom,NA,NA
 and ,NA,NA
Y=dick,NA,NA
. ,NA,NA
5. But this ,NA,NA
X,NA,NA
 now makes the second expression fail--there is a fact that Tom is the boss of ,NA,NA
Dick. ,NA,NA
6. The interpreter returns to the first predicate expression and takes the next matching from ,NA,NA
"the database, ",NA,NA
X=ann,NA,NA
 and ,NA,NA
Y=mary,NA,NA
. ,NA,NA
7. This ,NA,NA
X,NA,NA
 succeeds with the second expression since Ann isn't the boss of Dick. ,NA,NA
8. The ,NA,NA
Y,NA,NA
 match succeeds with the third expression if ,NA,NA
Z=harry,NA,NA
. So the interpreter reports ,NA,NA
that ,NA,NA
"X=ann, Y=mary, Z=harry",NA,NA
. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (12 of 22) [23/04/2002 17:38:38],NA
Notice the backtracking works differently if we rearrange the query into this equivalent form: ,NA,NA
"?- boss(X,Y), boss(Y,Z), not(boss(X,dick)).",NA,NA
"This is processed very much like the original two-expression superboss query, except that the ",NA,NA
not ,NA,NA
expression forces failure instead of success for ,NA,NA
X=tom,NA,NA
; we got the same effect by typing a semicolon ,NA,NA
after the first answer to the query in the last section. But the query won't work right if we reorder it as ,NA,NA
"?- not(boss(X,dick)), boss(X,Y), boss(Y,Z).",NA,NA
because now a ,NA,NA
not,NA,NA
" with an unbound variable is first, violating the guideline of Section 3.6. ",NA,NA
The generate-and-test scheme ,NA,NA
"When a variable occurs more than once in a Prolog query, the Prolog interpreter chooses a value ",NA,NA
"(binding) at the first occurrence, and then uses it in all other occurrences. So processing of the predicate ",NA,NA
"expression containing the first occurrence ""generates"" a value, which is ""tested"" by the predicate ",NA,NA
"expressions containing later occurrences. This idea is often used in artificial intelligence, and it's called ",NA,NA
the ,NA,NA
generate-and-test,NA,NA
 scheme or paradigm. Often the generating predicate expressions define the types of ,NA,NA
"the variables, so their predicates are type predicates (Section 2.2). ",NA,NA
Generate-and-test is a good way to attack problems for which we don't know any particularly good way ,NA,NA
"to proceed. We generate potential solutions, and apply a series of tests to check for a true solution. This ",NA,NA
works well when it's hard to reason backward about a problem (from a statement of the problem to a ,NA,NA
"solution), but it's easy to reason forward from a guess to a solution (or verify a proposed solution). An ",NA,NA
example is cryptography (decoding ciphers): an approach is to guess possible coding (encryption) ,NA,NA
"methods, and see if any of them gives coded text resembling a coded message. Many other interesting ",NA,NA
"problems work well for generate-and-test. But problems with well-defined solution methods, like many ",NA,NA
"mathematical problems, aren't suitable for it. ",NA,NA
"Backtracking with ""or""s (*) ",NA,NA
"Semicolons in queries (""or""s) are tricky for backtracking. We'll mostly ignore them in this book because, ",NA,NA
"as we say, there's a better way to get their effect; but for the record, here's what happens. When a ",NA,NA
"predicate expression before a semicolon succeeds, all the other expressions to the right that are ""or""ed ",NA,NA
"with it can be skipped. When such an expression fails, the next term to the right should be tried. If there ",NA,NA
"aren't any more, the whole ""or"" should fail, which usually means backtracking to the left. So while ",NA,NA
"backtracking with ""and""s always goes left, backtracking with ""or""s sometimes goes left and sometimes ",NA,NA
goes right. ,NA,NA
Implementation of backtracking ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (13 of 22) [23/04/2002 17:38:38],NA
Implementing backtracking requires allocation of a pointer (Appendix C defines pointers) for every ,NA,NA
"predicate expression in a query, a pointer to where in the database the interpreter last found a match for a ",NA,NA
predicate expression. So Prolog is more complicated to implement than conventional higher-level ,NA,NA
languages like Pascal that only need extra storage in the form of a stack for procedure calls (Appendix C ,NA,NA
"defines stacks too). Prolog needs a stack for this purpose too, as you'll see in Chapter 4. ",NA,NA
Queries don't necessarily require inspection of facts in the database in sequence (,NA,NA
sequential search,NA,NA
). All ,NA,NA
Prolog interpreters ,NA,NA
index,NA,NA
" facts in some way, usually at least by predicate name. This means keeping lists ",NA,NA
"of facts with the same predicate name, together with their addresses. So when the interpreter sees an ",NA,NA
a_kind_of,NA,NA
" predicate in a query, it need only search through the ",NA,NA
a_kind_of,NA,NA
 facts pointed to in the ,NA,NA
a_kind_of,NA,NA
 index list for a match. Figure 3-6 gives an example of a database and its index. More selective ,NA,NA
"indexing (not standard in most Prolog dialects, though) can examine the arguments too. ",NA,NA
Indexing by predicate name means that Prolog facts can go in many different orders and still provide ,NA,NA
"exactly the same behavior. For instance, the facts in Figure 3-6 ",NA,NA
"a_kind_of(enterprise,ship).",NA,NA
"a_kind_of(kennedy,ship).",NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
"part_of(u_s_navy,u_s_government).",NA,NA
can be rearranged as ,NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"a_kind_of(enterprise,ship).",NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
"a_kind_of(kennedy,ship).",NA,NA
"part_of(u_s_navy,u_s_government).",NA,NA
"and all queries will give the same answers in the same order, as they will for ",NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
"part_of(u_s_navy,u_s_government). ",NA,NA
"a_kind_of(enterprise,ship).",NA,NA
"a_kind_of(kennedy,ship).",NA,NA
But this is only because the three ,NA,NA
part_of,NA,NA
 facts maintain their order and the two ,NA,NA
a_kind_of,NA,NA
 facts ,NA,NA
"maintain their order. The following database will give answers in a different order than the preceding, ",NA,NA
though it gives the same answers: ,NA,NA
"a_kind_of(kennedy,ship).",NA,NA
"part_of(u_s_navy,u_s_government).",NA,NA
"part_of(enterprise,u_s_navy).",NA,NA
"a_kind_of(enterprise,ship).",NA,NA
"part_of(kennedy,u_s_navy).",NA,NA
The speed of query answering depends on how many facts are indexed for each predicate in a query; the ,NA,NA
"more facts, the slower the queries. Queries will also be slower when variables appear multiple times in the ",NA,NA
"query and there is no argument indexing. This situation, called a ",NA,NA
join,NA,NA
" in database systems, requires ",NA,NA
"embedded iterative loops, and loops can take a lot of time. With joins, possibilities literally multiply. For ",NA,NA
our previous example ,NA,NA
"?- a_kind_of(enterprise,X), color(X,C).",NA,NA
if there are 100 ,NA,NA
a_kind_of,NA,NA
 facts and 50 ,NA,NA
color,NA,NA
" facts, 50,000 combinations must be tried to find all possible ",NA,NA
X,NA,NA
 and ,NA,NA
C,NA,NA
" pairs, as when we type a semicolon repeatedly or when there are no such ",NA,NA
X,NA,NA
 and ,NA,NA
C,NA,NA
. ,NA,NA
About long examples ,NA,NA
We've studied several long examples in this chapter. Are all the examples of artificial intelligence like ,NA,NA
"this? Yes, unfortunately. Artificial intelligence is a set of techniques for managing complexity, and you ",NA,NA
can only see its advantages in at least moderately complex problems. ,NA,NA
This disturbs some students. They feel that since they can't get all of a long example into their heads at ,NA,NA
"once, they can't really understand what's going on. One reply is to think of programming languages. ",NA,NA
"There's a lot of activity behind the scenes that the programmer isn't usually aware of--parsing, storage ",NA,NA
"management, symbol tables, stacks, type checking, register allocation, and optimization. But you don't ",NA,NA
need to know this to program. The complexity of artificial-intelligence examples comes from the need to ,NA,NA
"explain, at least initially, similar behind-the-scenes details. Once you understand what details are ",NA,NA
"necessary, you can ignore them as you program. ",NA,NA
Most artificial-intelligence programs and systems do provide additional help for understanding complex ,NA,NA
program activities in the form of ,NA,NA
explanation,NA,NA
 facilities that summarize and answer questions about ,NA,NA
"reasoning activity. These facilities provide program tracing, and answer questions like ""Why did you ",NA,NA
"conclude boss(tom,dick)?"" and ""Why didn't you conclude boss(dick,tom)?"". More on this in Section ",NA,NA
15.8. ,NA,NA
Keywords: ,NA,NA
inference,NA,NA
Prolog database ,NA,NA
Prolog interpreter ,NA,NA
query ,NA,NA
success ,NA,NA
failure ,NA,NA
variable ,NA,NA
binding variables ,NA,NA
first-order logic ,NA,NA
inputs ,NA,NA
outputs ,NA,NA
match ,NA,NA
matching alternatives ,NA,NA
database order ,NA,NA
conjunction ,NA,NA
match ,NA,NA
disjunction ,NA,NA
negation ,NA,NA
not ,NA,NA
built-in predicates ,NA,NA
closed-world assumption ,NA,NA
consult ,NA,NA
backtracking ,NA,NA
failure ,NA,NA
indexing ,NA,NA
generate-and-test,NA,NA
Exercises ,NA,NA
3-1. (A) Good programming style in Prolog doesn't allow the argument to a not to be more than one ,NA,NA
"predicate expression, and doesn't allow composite queries (queries not just a single predicate ",NA,NA
"expression) ""or""d together. ",NA,NA
"(a) Using good programming style, write a Prolog query that is true if the ""nor"" of predicate ",NA,NA
expressions s a,NA,NA
" and b (both of no arguments) is true. (""Nor"" means the opposite of an ""or""). ",NA,NA
"(b) Using good programming style, write a Prolog query that is true if the ""exclusive or"" of ",NA,NA
"predicate expressions a and b is true. (""Exclusive or"" means either is true but not both). ",NA,NA
"3-2. (R,A) Suppose you have the following Prolog database: ",NA,NA
"incumbent(csprofessor,davis). ",NA,NA
"incumbent(csprofessor,rowe).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (16 of 22) [23/04/2002 17:38:38],NA
"incumbent(csprofessor,wu).",NA,NA
"incumbent(csprofessor,zyda).",NA,NA
"incumbent(cschairman,lum).",NA,NA
"incumbent(dean_ips,marshall).",NA,NA
"incumbent(provost,shrady).",NA,NA
"incumbent(superintendent,shumaker).",NA,NA
"incumbent(director_milops,bley).",NA,NA
"bossed_by(csprofessor,cschairman).",NA,NA
"bossed_by(cschairman,dean_ips).",NA,NA
"bossed_by(orchairman,dean_ips).",NA,NA
"bossed_by(dean_ips,provost).",NA,NA
"bossed_by(provost,superintendent).",NA,NA
"bossed_by(director_milops,superintendent).",NA,NA
(a) The incumbent predicate means that the person that is its second argument has the job ,NA,NA
description that is its first argument; the bossed_by predicate means that the boss of the first ,NA,NA
argument is the second argument. Paraphrase each of the following Prolog queries in English. ,NA,NA
"?- bossed_by(csprofessor,X), bossed_by(X,Y).",NA,NA
"?- bossed_by(X,Y), incumbent(X,rowe), incumbent(Y,Z).",NA,NA
"?- incumbent(dean_ip,X); incumbent(dean_ips,X).",NA,NA
"?- incumbent(J,P), (bossed_by(J,provost); bossed_by(J,dean_ips)). ",NA,NA
"?- bossed_by(P,superintendent), not(incumbent(P,shrady)).",NA,NA
"(b) Without using a computer, what will be the first answer found by a Prolog interpreter with the ",NA,NA
preceding database and with each query given? ,NA,NA
"3-3. Suppose two queries each represent an ""and"" of a number of predicate expressions. Suppose ",NA,NA
the expressions of query 1 are a subset of the expressions in query 2. How do the answers to query ,NA,NA
1 relate to the answers to query 2? ,NA,NA
"3-4. The words ""the"" and ""a"" mean different things in English. What important feature of Prolog ",NA,NA
querying does the difference between them demonstrate in the following sentences? ,NA,NA
Find a memo we sent headquarters last week. The memo reported on a board ,NA,NA
"meeting last October 10. The board meeting was noisy, and this is mentioned in the ",NA,NA
memo. ,NA,NA
3-5. (A) Suppose in your Prolog database you have N one-argument facts for the predicate name p ,NA,NA
and M one-argument facts for the predicate name q. ,NA,NA
"(a) What is the maximum number of answers, not counting no, that you will get to the query ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (17 of 22) [23/04/2002 17:38:38],NA
"?- p(X), q(Y).",NA,NA
(b) How many total times will the Prolog interpreter backtrack from q to p for the situation in part ,NA,NA
"(a), before it types no? ",NA,NA
(c) What is the minimum number of answers to the query in part (a)? ,NA,NA
"(d) What is the maximum number of answers, not counting no, you will get to the query ",NA,NA
"?- p(X), q(X).",NA,NA
(e) How many total times will the Prolog interpreter backtrack from q to p for the situation in part ,NA,NA
"(d), before it types no? ",NA,NA
(f) What is the minimum number of answers to the query in part (d)? ,NA,NA
"3-6. (R,A) Suppose we keep in a Prolog database information about grades on two tests in a course. ",NA,NA
(a) Suppose we ask if Joe got an A on test 1 and the Prolog interpreter says yes. Suppose we then ,NA,NA
ask if Joe got an A on test 2 and it says yes. It seems fair to summarize this by saying Joe got A's on ,NA,NA
both tests 1 and 2. Now suppose we ask if someone got an A on test 1 and the interpreter says yes. ,NA,NA
We ask if someone got an A on test 2 and it says yes. It is unfair now to conclude that someone got ,NA,NA
an A on both test 1 and test 2. How is this situation different? How does this illustrate an important ,NA,NA
feature of Prolog querying? ,NA,NA
(b) Suppose the database consists of facts of the form: ,NA,NA
"grade(<person>,<test-number>,<grade>).",NA,NA
"Write a query that establishes if everyone in the class got an A on test 1, without using an ""or"" ",NA,NA
(semicolon). (Hint: Use the exact opposite.) ,NA,NA
(c) Suppose you ask if everyone in the class got an A on test 1 and the Prolog interpreter says yes. ,NA,NA
Suppose you then ask if everyone in the class got an A on test 2 and it says yes. Can you conclude ,NA,NA
that everyone in the class got both an A on test 1 and an A on test 2? Why? Assume this is a real ,NA,NA
class at a real college or university. ,NA,NA
3-7. Here's a summary of the current situation on the fictitious television soap opera ,NA,NA
Edge of ,NA,NA
Boredom:,NA,NA
"Jason and Phoebe are married, but Phoebe is in love with Perry. Perry doesn't love her ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (18 of 22) [23/04/2002 17:38:38],NA
"because he is still married to Stacey, but Zack is romantically inclined toward Phoebe. He's ",NA,NA
"in competition with Lane, who also loves Phoebe despite being married to Eulalie, whom ",NA,NA
Jason is feeling romantic about. ,NA,NA
(a) Represent the basic meaning of these statements by facts using only two different predicate names. ,NA,NA
"Notice that if X is married to Y, Y is married to X. ",NA,NA
(b) A marriage is on the rocks if both its participants are in love with other people and not with each ,NA,NA
other. Which people are in marriages that are on the rocks? Show the necessary Prolog query and its ,NA,NA
result. ,NA,NA
"(c) A person is jealous when a person they love is loved by a third person, or a person is jealous when ",NA,NA
married to someone loved by a third person. Which people are jealous? Show the necessary Prolog query ,NA,NA
and its result. ,NA,NA
3-8.(a) Consider the query ,NA,NA
"?- a(X,Y), b(X,Y).",NA,NA
with the database ,NA,NA
"a(1,1).",NA,NA
"a(2,1).",NA,NA
"a(3,2).",NA,NA
"a(4,4).",NA,NA
"b(1,2).",NA,NA
"b(1,3).",NA,NA
"b(2,3).",NA,NA
"b(3,2).",NA,NA
"b(4,4).",NA,NA
"Without using a computer, what are all the answers that you will get to the query, in order (as you keep ",NA,NA
typing semicolons)? ,NA,NA
"(b) Without using a computer, what does this query print out (as you keep typing semicolons)? ",NA,NA
"?- a(X,Y), b(X,Y), a(Y,Y).",NA,NA
3-9. (A) Consider this Prolog query: ,NA,NA
"?- r(X,Y), s(Y,Z), not(r(Y,X)), not(s(Y,Y)).",NA,NA
with this database: ,NA,NA
"r(a,b)",NA,NA
. ,NA,NA
"r(a,c)",NA,NA
. ,NA,NA
"r(b,a)",NA,NA
. ,NA,NA
"r(a,d)",NA,NA
. ,NA,NA
"s(b,c)",NA,NA
. ,NA,NA
"s(b,d)",NA,NA
. ,NA,NA
"s(c,d)",NA,NA
. ,NA,NA
"s(c,c)",NA,NA
. ,NA,NA
"s(d,e)",NA,NA
.,NA,NA
"(a) Without using a computer, what is the first answer found to the query? Hint: you don't have to do it ",NA,NA
Prolog's way. ,NA,NA
"(b) Without using a computer, how many times does a Prolog interpreter backtrack from the third to the ",NA,NA
second predicate expression to get this first answer? ,NA,NA
3-10. Consider this Prolog database: ,NA,NA
"u(a,b)",NA,NA
. ,NA,NA
"u(b,b)",NA,NA
. ,NA,NA
"u(c,d)",NA,NA
. ,NA,NA
"u(c,a)",NA,NA
. ,NA,NA
"u(d,a)",NA,NA
. ,NA,NA
"u(d,c)",NA,NA
.,NA,NA
"Now consider this Prolog query, without actually using a computer: ",NA,NA
"?- u(X,Y), u(Y,Z), not(u(X,Z)).",NA,NA
(a) How many times will a Prolog interpreter backtrack to the first query predicate expression ,NA,NA
"u(X,Y)",NA,NA
 to ,NA,NA
find the first answer to this query? ,NA,NA
(b) How many times will a Prolog interpreter backtrack to the second query predicate expression ,NA,NA
"u(Y,Z) ",NA,NA
to find the first answer to this query? ,NA,NA
(c) How many times will a Prolog interpreter backtrack to the third query predicate expression ,NA,NA
"not(u(X,Z))",NA,NA
 to find the first answer to this query? ,NA,NA
(d) How many further times will a Prolog interpreter backtrack to the first query predicate expression ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (20 of 22) [23/04/2002 17:38:38],NA
"u(X,Y)",NA,NA
 to find the second answer to this query? ,NA,NA
(e) How many further times will a Prolog interpreter backtrack to the second query predicate expression ,NA,NA
"u(Y,Z)",NA,NA
 to find the second answer to this query? ,NA,NA
3-11. (H) Design a good set of predicates for the following data about an organization and its employees. ,NA,NA
"Assume you have to do this in Prolog. Try to be efficient: avoid duplicate data, empty data, and too many ",NA,NA
"linking arguments, while keeping data access reasonably fast. ",NA,NA
"Assume we have an organization with departments, subdepartments, and projects. A subdepartment can ",NA,NA
"belong to only one department, but a project can belong to more than one subdepartment or department ",NA,NA
(but most of the time only one). Employees belong to one subdepartment and one or more projects. ,NA,NA
"Employees have a name, social security number, date of birth, address, and a list of successfully ",NA,NA
completed projects that they participated in since they joined the organization. Employees also are ,NA,NA
"characterized by Personnel by ""job skills"" they have from a rough list (e.g. ""can type"", ""has truck ",NA,NA
"license"", ""experience in writing""). Projects have a name, code, starting date, projected or actual ",NA,NA
"completion date, and the room number for the office of each employee on the project. Employees have ",NA,NA
"only one office, but there may be more than one employee in the same office. ",NA,NA
Design these predicates to answer these questions easily: ,NA,NA
"--Give the name, department, and office number for each employee on project 93521. --",NA,NA
"Give the name, department, and office number for each employee on projects started last ",NA,NA
year. ,NA,NA
--Give the people in department 43 who have typing skills. ,NA,NA
3-12. Questions in English have subtleties that are sometimes hard to translate into Prolog queries. This ,NA,NA
became obvious in building the first ,NA,NA
natural language front ends,NA,NA
" to databases, computer programs that ",NA,NA
"tried to answer, in English, questions about the database contents. Here are illustrations of two bugs ",NA,NA
discovered in those early programs. Try to explain what a program like a Prolog interpreter is missing ,NA,NA
when it makes such errors. (Brackets give our explanatory comments.) ,NA,NA
(a) ,NA,NA
Person: Can you tell me the commander of the Enterprise and his rank? ,NA,NA
Computer: Yes. [That's all it types in response.] ,NA,NA
(b) ,NA,NA
Person: Who commands the Pequod? ,NA,NA
"Computer: Nobody. [That's strange, because every ship must have a commander.] ",NA,NA
Person: Where is the Pequod currently? ,NA,NA
Computer: Nowhere. [Strange ship this Pequod.] ,NA,NA
Person: Does the Pequod exist? ,NA,NA
Computer: No. [So that's the reason.] ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap3.html (22 of 22) [23/04/2002 17:38:38],NA
Definitions and inferences ,NA,NA
Much human intelligence consists of conclusions or ,NA,NA
inferences,NA,NA
" drawn from facts, instead of facts ",NA,NA
"themselves. We'll now show how inference methods can be represented, including a famous one called ",NA,NA
inheritance,NA,NA
". That is, we'll formalize chains of reasoning. ",NA,NA
Rules for definitions ,NA,NA
"If we ask a lot of queries of a database, especially queries about related things, we may be typing the same ",NA,NA
expressions over and over again. Nearly all programming languages have subroutines or procedures to ,NA,NA
"modularize knowledge, group it into its natural pieces. Prolog has them too, and they're called ",NA,NA
rules,NA,NA
 or ,NA,NA
definitions,NA,NA
". Rules are a way to create the ability to query new predicates without specifying new facts, by ",NA,NA
defining the new predicate names in terms of old predicate names. ,NA,NA
Prolog rules have a ,NA,NA
left side,NA,NA
 and a ,NA,NA
right side,NA,NA
", and the symbol ",NA,NA
:-,NA,NA
 in between (it is supposed to look like a ,NA,NA
"backward arrow, but you need a good imagination). Read the symbol as ""if"". To its left side is a single ",NA,NA
"predicate expression, usually with variables as arguments. To its right side is a query, with possibly ",NA,NA
"multiple predicate expressions combined with the comma (""and""), semicolon (""or"") and ",NA,NA
not,NA,NA
 symbols. For ,NA,NA
instance: ,NA,NA
"gray_enterprise :- part_of(enterprise,X), color(X,gray).",NA,NA
This says that predicate expression ,NA,NA
gray_enterprise,NA,NA
 succeeds if the query ,NA,NA
"?- part_of(enterprise,X), color(X,gray).",NA,NA
"succeeds. In other words, ",NA,NA
gray_enterprise,NA,NA
 is true if the Enterprise is part of something that is gray in ,NA,NA
color. So ,NA,NA
gray_enterprise,NA,NA
 is a code representing a query. ,NA,NA
"More formally, the ",NA,NA
gray_enterprise,NA,NA
 rule defines a new predicate of no arguments called ,NA,NA
gray_enterprise,NA,NA
. When queried: ,NA,NA
?- gray_enterprise.,NA,NA
the interpreter succeeds (answers ,NA,NA
yes,NA,NA
) if it can succeed in querying the right side of the ,NA,NA
gray_enterprise ,NA,NA
rule. Otherwise the interpreter fails (answers ,NA,NA
no,NA,NA
). It's like the right side of the rule is substituted for the ,NA,NA
left side whenever it occurs in a query. The variable ,NA,NA
X,NA,NA
 is a ,NA,NA
local variable,NA,NA
" in the rule, a variable whose ",NA,NA
"value will be ""thrown away"" when the rule is done, and will not be printed out in any query answer. Any ",NA,NA
Prolog variable that appears only on the right side of a rule is called local to that rule. ,NA,NA
But ,NA,NA
gray_enterprise,NA,NA
 isn't too useful because it only covers one color. What we really want is a rule that ,NA,NA
will ,NA,NA
tell us,NA,NA
" what color something is. We can do this with a variable on the left side of the rule, a variable ",NA,NA
representing the color: ,NA,NA
"color_enterprise(C) :- part_of(enterprise,X), color(X,C).",NA,NA
C,NA,NA
 is a ,NA,NA
parameter variable,NA,NA
" of the rule, and a value for it will be ""returned"" as a result of executing the ",NA,NA
rule. So if we query ,NA,NA
?- color_enterprise(C).,NA,NA
when our database is that of Section 3.1 and the interpreter uses the ,NA,NA
color_enterprise,NA,NA
" rule, it will type ",NA,NA
C=gray,NA,NA
"in reply. Rules can have any number of such parameter variables, as well as constants (ordinary words ",NA,NA
"and numbers), as arguments on their left sides. So if we wanted an even more general color rule, one that ",NA,NA
"would tell us the color for many objects, we could say: ",NA,NA
"color_object(X,C) :- part_of(X,Y), color(Y,C).",NA,NA
Here ,NA,NA
X,NA,NA
 and ,NA,NA
C,NA,NA
" are parameter variables, and ",NA,NA
Y,NA,NA
 is a local variable. So values for ,NA,NA
X,NA,NA
 and ,NA,NA
C,NA,NA
 only will be ,NA,NA
returned. ,NA,NA
Figure 4-1 summarizes our terminology about rules. You can think of local variables as being ,NA,NA
"existentially quantified (""there exists some X such that something is true""), and parameter variables as ",NA,NA
"universally quantified (""for every X something is true"")--see Appendix A for more about quantification, ",NA,NA
"an important concept in logic. Actually, the distinction of ""local"" from ""parameter"" variables is ",NA,NA
"misleading, because the opposite of ""local"" is ""global"", and there aren't any true ""global"" variables in ",NA,NA
"Prolog. Rules just give a shorthand for queries, and a variable ",NA,NA
X,NA,NA
 is one query is always different from a ,NA,NA
variable ,NA,NA
X,NA,NA
 in a separate query. The only way to get anything like a global variable in Prolog is to assert a ,NA,NA
fact. ,NA,NA
Here are more rule examples. This defines X to be the son of Y if X is the child of Y and X is male: ,NA,NA
"son(X,Y) :- child(X,Y), male(X).",NA,NA
"This defines X to be the ""superboss"" of Y if X is the boss of the boss of Y: ",NA,NA
"superboss(X,Y) :- boss(X,Z), boss(Z,Y).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (2 of 29) [23/04/2002 17:38:42],NA
This defines something X you own to be stolen if it isn't present and you haven't given it to someone: ,NA,NA
"stolen(X) :- owns(you,X), not(present(X)), not(given(you,X,Y)).",NA,NA
This defines the previous example predicate ,NA,NA
color_object,NA,NA
" in a different way, using ",NA,NA
a_kind_of,NA,NA
 instead of ,NA,NA
part_of,NA,NA
. It says that the color of X is C if X is a type of Y and the color of Y is C. ,NA,NA
"color_object(X,C) :- a_kind_of(X,Y), color(Y,C).",NA,NA
Usually predicates defined by rules can be used in queries just like fact predicates. This means that we can ,NA,NA
"usually make variables any of the arguments to defined-predicate expressions in queries, a powerful ",NA,NA
feature. (A few exceptions to this will be discussed in later chapters: some rules with ,NA,NA
not,NA,NA
"s, the arithmetic ",NA,NA
and ,NA,NA
is,NA,NA
" constructs of Chapter 5, and the ""cut"" (""",NA,NA
!,NA,NA
""") of Chapter 10.) That is, we can designate arbitrary ",NA,NA
inputs and outputs. This means that Prolog is fundamentally more powerful than conventional ,NA,NA
"programming languages, which usually require all but one argument (the output variable) to a procedure ",NA,NA
"to be filled in at the time of the call. But Prolog rules, the Prolog equivalent of procedures, rarely impose ",NA,NA
such requirements. ,NA,NA
Rule and fact order ,NA,NA
Rules can go into a Prolog database just like facts. And the interpreter then uses both those rules and ,NA,NA
facts to answer queries. But we must worry a little about rule and fact order. ,NA,NA
"To see why, consider combining several reasoning methods in the same rule, as for instance three ways ",NA,NA
of establishing the color of something: ,NA,NA
"color_object(X,C) :- color(X,C); (part_of(X,Y), color(Y,C));",NA,NA
"(part_of(X,Y), part_of(Y,Z), color(Z,C)).",NA,NA
(Queries and rules can take more than one line; the period at the end indicates where they stop.) But that's ,NA,NA
"poor rule-writing style, since it's hard to read the right side. Instead, we can write three separate rules with ",NA,NA
the same left side: ,NA,NA
"color_object(X,C) :- color(X,C).",NA,NA
"color_object(X,C) :- part_of(X,Y), color(Y,C).",NA,NA
"color_object(X,C) :- part_of(X,Y), part_of(Y,Z), color(Z,C).",NA,NA
Now each rule's right side gives ,NA,NA
sufficient,NA,NA
" conditions for the left-side predicate expression to be true, but ",NA,NA
not ,NA,NA
necessary,NA,NA
" conditions. That is, each describes some but not all the situations for which ",NA,NA
color_object ,NA,NA
"succeeds. When each rule is very specific, we have ",NA,NA
definition by examples,NA,NA
. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (3 of 29) [23/04/2002 17:38:42],NA
The order of those three rules matters. Whenever a query on predicate ,NA,NA
color_object,NA,NA
 with two arguments ,NA,NA
"is issued, the rules will be tried to answer the query in database order, just as if they were facts. The order ",NA,NA
"shown is probably the best, because the simplest rule will be tried first, then the next-simplest, then the ",NA,NA
"most complex (where we measure ""complexity"" by the number of expressions). ",NA,NA
Facts and rules can be freely intermingled in a Prolog database; the overall order is all that matters. Facts ,NA,NA
"should generally come first, though, if there are both facts and rules for a predicate name. That's because ",NA,NA
facts require less symbol matching than rules--and a lot less than some of the recursive rules we'll discuss ,NA,NA
later in this chapter. Putting facts before recursive rules of the same predicate is also the standard way to ,NA,NA
write recursive programs (see Appendix B). ,NA,NA
Rules as programs ,NA,NA
So this is how we'll write a Prolog program: by giving a list of facts and rules (definitions) that explain ,NA,NA
"about some area of human knowledge. To match a query, rules and facts will be considered in order, ",NA,NA
somewhat like sequential execution of the lines of a program in a conventional computer language. ,NA,NA
"""And""s on the right sides of queries will be initially be done in left-to-right order, like multiple procedure ",NA,NA
"calls in a line of a conventional language. And like those languages, we can have ""procedure"" (rule) ",NA,NA
"hierarchies; that is, a rule right side can use predicate names defined in rules, including its own left-side ",NA,NA
predicate name (the last is called ,NA,NA
recursion,NA,NA
). ,NA,NA
This mapping of predicate expressions to actions means that we can model ,NA,NA
procedures,NA,NA
" in Prolog, not just ",NA,NA
"facts. For instance, here's a way to describe a daily agenda for a student: ",NA,NA
"day_agenda :- wakeup, classes, lunch, classes, dinner, study, sleep.",NA,NA
"wakeup :- late, dress, travel(home,campus).",NA,NA
"wakeup :- not(late), shower, dress, breakfast, travel(home,campus).",NA,NA
"classes :- class, class, class.",NA,NA
"class :- check_schedule, go_room, take_notes.",NA,NA
"This notation is useful for describing processes, even if we never define what the basic actions (like ",NA,NA
take_notes,NA,NA
) are. A computer doesn't need to know ,NA,NA
everything,NA,NA
" to be intelligent, just the important things. ",NA,NA
"(However, we'll introduce a better way to describe sequences of actions in Chapter 9.) ",NA,NA
Rules in natural language ,NA,NA
"As we said in Section 2.8, an artificial-intelligence system is often built from natural-language (e.g. ",NA,NA
"English) specifications, either oral or written. Rules can be specified several ways in English. The easiest ",NA,NA
"to spot is the ""if...then"" statement: ",NA,NA
"If a vehicle floats on water, then it's a ship. ",NA,NA
which could become the Prolog rule (note the reversed order): ,NA,NA
"ship(X) :- vehicle(X), floats(X,water).",NA,NA
"But the ""then"" is often omitted: ",NA,NA
"If a vehicle floats on water, it's a ship. ",NA,NA
"""Define"" or ""assume"" often signals a rule, taking the things in the opposite (Prolog) order: ",NA,NA
Define a ship as anything that floats on water. ,NA,NA
Assume as a ship anything that floats on water. ,NA,NA
"""Anything"", ""anyone"", ""any"", ""something"", ""some"", and ""a"" in such definitions often map to Prolog ",NA,NA
variables. ,NA,NA
"Besides expressing facts, the verb ""to be"" can express rules: ",NA,NA
A ship is any vehicle that floats on water. ,NA,NA
Ships are water-floating vehicles. ,NA,NA
"The borderline between facts and rules can be fuzzy, but generally speaking, use a rule when variable ",NA,NA
"bindings seem possible. The ""a"" and ""any"" in the first sentence suggest a variable, and hence a rule. ",NA,NA
"When an ""and"" occurs in the ""if"" part of a definition, we can just put commas into the right side of the ",NA,NA
rule. For instance ,NA,NA
Something that is a vehicle and floats on water is a ship. ,NA,NA
takes the form of the preceding ,NA,NA
ship(X),NA,NA
" rule. If an ""and"" occurs in the ""then"" part of a definition, multiple ",NA,NA
"conclusions hold for some situation. Prolog doesn't allow ""and""s in rule left sides, but we can write ",NA,NA
multiple rules with the same right side and different left sides. So ,NA,NA
"If a vehicle floats on water and is gray, then it is a ship and of military origin. ",NA,NA
becomes ,NA,NA
"ship(X) :- vehicle(X), floats(X,water), gray(X).",NA,NA
"origin(X,military) :- vehicle(X), floats(X,water), gray(X).",NA,NA
Rules without right sides ,NA,NA
The right side of a rule represents sufficient conditions for the left-side predicate expression to be true. ,NA,NA
What if a rule doesn't have anything on its right side? Then we'd be saying that nothing is necessary to ,NA,NA
"make the left side true, that the left side always true. In other words, a fact. So facts are just a special case ",NA,NA
of rules. That's why Prolog facts and rules are put together in one big database: they're the same thing. ,NA,NA
But rules can have variables. What would it mean for a fact to have a variable? Consider: ,NA,NA
"part_of(X,universe).",NA,NA
"If you think of that as a rule with no right side, it says that for any ",NA,NA
X,NA,NA
", nothing is necessary to say that ",NA,NA
X,NA,NA
 is ,NA,NA
"part of the universe. In other words, every ",NA,NA
X,NA,NA
 is part of the universe. So using a term from logic (see ,NA,NA
"Appendix A), facts with variables are ",NA,NA
universally quantified,NA,NA
. ,NA,NA
Postponed binding ,NA,NA
"An interesting consequence of the Prolog interpreter's handling of rules is ""postponed"" binding of ",NA,NA
variables. This is interesting because most other programming languages can't do anything like this. ,NA,NA
Suppose we query: ,NA,NA
"?- color_object(enterprise,C).",NA,NA
"Here the first argument is bound (that is, it's an input) and the second argument is unbound (that is, it's an ",NA,NA
output). If there's a fact in the database ,NA,NA
"color_object(enterprise,gray).",NA,NA
then the query can immediately bind ,NA,NA
C,NA,NA
 to ,NA,NA
gray,NA,NA
. But if there are no ,NA,NA
color_object,NA,NA
" facts, only rules with ",NA,NA
color_object,NA,NA
" on their left sides, or if a rule is first in the database, the binding may be delayed. For ",NA,NA
"instance, suppose the interpreter picks the rule ",NA,NA
"color_object(X,C) :- part_of(X,Y), color_object(Y,C).",NA,NA
The variable ,NA,NA
C,NA,NA
" won't be bound when the rule is invoked, and it won't be bound in the ",NA,NA
part_of,NA,NA
 (which ,NA,NA
doesn't mention ,NA,NA
C,NA,NA
"), so if it's ever bound it won't be until the recursive query of ",NA,NA
color_object,NA,NA
. But this ,NA,NA
query may require other recursive calls. It may take a long time for an appropriate ,NA,NA
color_object,NA,NA
 fact to ,NA,NA
"be found, and hence a long time for variable ",NA,NA
C,NA,NA
 to get bound. ,NA,NA
"In fact, some query variables may ",NA,NA
never,NA,NA
 get bound to values in successful queries. Consider: ,NA,NA
"recommended(X,J) :- not(bad_report(X)).",NA,NA
a rule that recommends person ,NA,NA
X,NA,NA
 for job ,NA,NA
J,NA,NA
 if they haven't had a bad report recently. Here ,NA,NA
J,NA,NA
 is never ,NA,NA
bound if the query's second argument isn't initially bound. Most Prolog dialects will invent a name like ,NA,NA
"""",NA,NA
_14,NA,NA
""" for such unbound variables, to print out if they must. ",NA,NA
Postponing of binding in Prolog interpreters has the advantage that binding is only done when truly ,NA,NA
"necessary to answer a query. This saves on the computer's overhead cost of binding, for one thing. ",NA,NA
"Furthermore, ",NA,NA
multiway,NA,NA
" reasoning becomes easier, reasoning for which we don't know in advance which ",NA,NA
arguments to a predicate expression (procedure) will be bound (or be inputs). Multiway reasoning means ,NA,NA
the same rule can be used many ways. We'll look more into this in the next chapter. ,NA,NA
Backtracking with rules ,NA,NA
"As you remember from Chapter 3, backtracking is the ""backing up"" the interpreter does when it can't find ",NA,NA
"a match for a predicate expression in a query. When predicates in a query have rule definitions, the ",NA,NA
interpreter acts somewhat as if the right side of the definition were typed as part of a query instead of the ,NA,NA
"single predicate expression that is the left side. (We say ""somewhat"" because variables in a rule are local ",NA,NA
"in meaning, and parameter variables must get bound.) So backtracking into a predicate expression for a ",NA,NA
rule-defined predicate means returning to the last expression in the rule. Tracing backtracking with rules ,NA,NA
is hard because we move both left and right (through backtracking) and up and down (through procedure ,NA,NA
calls and returns). This is a common problem with powerful computer languages such as Prolog: simply ,NA,NA
"because they're powerful, it's hard to follow everything they're doing. ",NA,NA
Here's an example that isn't too hard. Suppose we have two kinds of facts about an organization: the ,NA,NA
department each employee works for and the manager of each department. Suppose we define a ,NA,NA
boss ,NA,NA
predicate of two parameter arguments ,NA,NA
B,NA,NA
 and ,NA,NA
E,NA,NA
", that says that ",NA,NA
B,NA,NA
 is the boss of ,NA,NA
E,NA,NA
 if ,NA,NA
B,NA,NA
 manages a ,NA,NA
department ,NA,NA
D,NA,NA
 in which ,NA,NA
E,NA,NA
 is an employee; ,NA,NA
D,NA,NA
 will be a local variable. Assume that Tom works in the sales ,NA,NA
"department, Harry works in the production department, Dick manages the sales department, and Mary ",NA,NA
manages the production department. Then the Prolog database is: ,NA,NA
"department(tom,sales).",NA,NA
"department(harry,production).",NA,NA
"manager(dick,sales).",NA,NA
"manager(mary,production).",NA,NA
"boss(B,E) :- department(E,D), manager(B,D).",NA,NA
Now suppose we want to find a boss different from Tom's. It will be ,NA,NA
X,NA,NA
 in the query: ,NA,NA
"?- boss(X,Y), not(boss(X,tom)).",NA,NA
Notice that the ,NA,NA
not,NA,NA
 must come second in the query because ,NA,NA
X,NA,NA
 must be bound. ,NA,NA
Let us trace execution (see Figure 4-2). ,NA,NA
"1. The first predicate expression in the query matches only a rule in the database, no facts, ",NA,NA
so the first job to do is searching for a match for the first expression on the right side of the ,NA,NA
"rule, ",NA,NA
"department(E,D)",NA,NA
". This can be matched to the first fact, with ",NA,NA
E=tom,NA,NA
 and ,NA,NA
D=sales,NA,NA
. ,NA,NA
"2. Moving on to the second predicate expression in the rule, ",NA,NA
"manager(B,D)",NA,NA
", the interpreter ",NA,NA
finds a match in the third fact with ,NA,NA
B=dick,NA,NA
", so the rule succeeds and the first expression in ",NA,NA
the original query succeeds. So ,NA,NA
X=dick,NA,NA
 and ,NA,NA
Y=tom,NA,NA
. ,NA,NA
"3. Moving to the second and last expression in the query, ",NA,NA
"not(boss(X,tom))",NA,NA
", the interpreter ",NA,NA
"tries to find if Dick is the boss of Tom. It has no memory of what it just proved, so it goes ",NA,NA
back to the rule. ,NA,NA
"4. Again, both predicate expressions on the right side of the rule can match the same facts, ",NA,NA
"so the rule succeeds. But the condition in the original query is the opposite (""not"" or ",NA,NA
"negation) of this, so the second half of the original query fails and the interpreter ",NA,NA
backtracks to the first expression. (There's never a new way to satisfy a ,NA,NA
not,NA,NA
 when it fails.) ,NA,NA
5. Backtracking into a predicate expression satisfied previously by a rule means that the ,NA,NA
interpreter must go to the last (rightmost) expression on the right side of the rule and see if ,NA,NA
it can find another match there. But there is no other boss of the sales department so it must ,NA,NA
"now backtrack to the first expression of the rule, ",NA,NA
"department(E,D)",NA,NA
 with unbound ,NA,NA
B ,NA,NA
and ,NA,NA
E,NA,NA
. ,NA,NA
6. Fortunately for this there is another choice: ,NA,NA
E=harry,NA,NA
 and ,NA,NA
D=production,NA,NA
. ,NA,NA
"7. With this success, the interpreter can start moving right again. It considers the second ",NA,NA
predicate expression in the rule. And it can find a match of ,NA,NA
B=mary,NA,NA
" (remember, ",NA,NA
D=production,NA,NA
" now). So the rule succeeds, and thus the first expression of the query ",NA,NA
succeeds with ,NA,NA
X=mary,NA,NA
 and ,NA,NA
Y=harry,NA,NA
. ,NA,NA
"8. Now in the second query expression, it must check that it is not true that Mary is the ",NA,NA
"boss of Tom. To do this, it tries to prove the ",NA,NA
boss,NA,NA
 rule fails with ,NA,NA
B=mary,NA,NA
 and second ,NA,NA
argument ,NA,NA
tom,NA,NA
. ,NA,NA
"9. In the first expression on the right side of the rule, it can match ",NA,NA
D,NA,NA
" to sales, but there is no ",NA,NA
"fact that Mary manages the sales department. So the rule fails, and since there is no other ",NA,NA
rule or fact for the ,NA,NA
boss,NA,NA
" predicate, the second ",NA,NA
boss,NA,NA
 expression in the query fails. ,NA,NA
10. But since there's a ,NA,NA
not,NA,NA
" in front of this expression, the whole query succeeds. So ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (8 of 29) [23/04/2002 17:38:42],NA
X=mary,NA,NA
 is the answer we needed. ,NA,NA
"To help in debugging, most Prolog interpreters will automatically print out abbreviated trace information ",NA,NA
"if you ask. To ask in most Prolog dialects, query the built-in predicate ",NA,NA
trace,NA,NA
 of no arguments. To stop the ,NA,NA
"tracing, query the built-in predicate ",NA,NA
notrace,NA,NA
 of no arguments. Some other debugging facilities of most ,NA,NA
Prolog dialects are described in Appendix D. ,NA,NA
Transitivity inferences ,NA,NA
Certain rule forms occur frequently in artificial intelligence. A very important form states ,NA,NA
transitivity,NA,NA
 of a ,NA,NA
"two-argument predicate. For instance, consider bosses in an organization. If your boss has a boss in turn, ",NA,NA
"that big boss is your boss too. If that big boss has a boss in turn, that even bigger boss is your boss too. So ",NA,NA
"bossing relationships form chains, and that's transitivity. ",NA,NA
"Formally, a relationship predicate ",NA,NA
r,NA,NA
 is transitive if this rule is correct: ,NA,NA
"r(X,Y) :- r(X,Z), r(Z,Y).",NA,NA
(See Figure 4-3.) This says that if predicate ,NA,NA
r,NA,NA
 holds from some ,NA,NA
X,NA,NA
 to some ,NA,NA
Z,NA,NA
", and also from ",NA,NA
Z,NA,NA
 to some ,NA,NA
Y,NA,NA
", ",NA,NA
the predicate always also holds from ,NA,NA
X,NA,NA
 to ,NA,NA
Y,NA,NA
". This rule can be used recursively too; that is, it can refer to ",NA,NA
"itself on its right side, not just to ",NA,NA
r,NA,NA
 facts. So the rule can follow indefinitely relationship long chains. For ,NA,NA
"instance, suppose these facts are placed in front of the rule in the Prolog database: ",NA,NA
"r(a,b).",NA,NA
"r(b,c).",NA,NA
"r(c,d).",NA,NA
Then if we query ,NA,NA
"?- r(a,d).",NA,NA
"no facts match, so the interpreter will use the rule, and will first query ",NA,NA
"?- r(a,Z).",NA,NA
"For this, ",NA,NA
Z,NA,NA
 can match ,NA,NA
b,NA,NA
 in the first fact. The interpreter will then query ,NA,NA
"?- r(b,d).",NA,NA
"There's no fact stating this either, so it must use the rule again recursively. For this new call of the rule, ",NA,NA
X=b,NA,NA
 and ,NA,NA
Y=d,NA,NA
", so the next query is ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (9 of 29) [23/04/2002 17:38:42],NA
"?- r(b,Z).",NA,NA
This new ,NA,NA
Z,NA,NA
 is different from the previous ,NA,NA
Z,NA,NA
", since each recursive call has its own variables (see ",NA,NA
"Appendix B), in the same way that ",NA,NA
X,NA,NA
's in different rules represent different ,NA,NA
X,NA,NA
"'s. For this new query, the ",NA,NA
interpreter can bind ,NA,NA
Z,NA,NA
 to ,NA,NA
c,NA,NA
 since there is a ,NA,NA
"r(b,c)",NA,NA
" fact, and then the second part of the rule becomes the ",NA,NA
query: ,NA,NA
"?- r(c,d).",NA,NA
That predicate expression is a fact. So the rule succeeds in proving ,NA,NA
"r(b,d)",NA,NA
. And thus it succeeds in ,NA,NA
proving ,NA,NA
"r(a,d)",NA,NA
", the original query. ",NA,NA
Many of the relationship predicates in Section 2.6 are transitive: ,NA,NA
a_kind_of,NA,NA
", ",NA,NA
part_of,NA,NA
", ",NA,NA
right_of,NA,NA
", ",NA,NA
during,NA,NA
", ",NA,NA
and ,NA,NA
ancestor,NA,NA
", for instance. Some example applications: ",NA,NA
"--If the Vinson is a kind of carrier, and the carrier is a kind of ship, then the Vinson is a ",NA,NA
kind of ship. ,NA,NA
"--If the electrical system is part of the car, and the battery is part of the electrical system, ",NA,NA
then the battery is part of the car. ,NA,NA
"--If the Vinson is north of the Enterprise, and the Enterprise is north of the Kennedy, then ",NA,NA
the Vinson is north of the Kennedy. ,NA,NA
"--If during the day Monday you had a meeting with your boss, and during the meeting you ",NA,NA
"found out you got promoted, then during the day Monday you found out you got promoted. ",NA,NA
"--If a number X is greater than a number Y, and Y is greater than a number Z, then X is ",NA,NA
greater than Z. ,NA,NA
And a graphical example is shown in Figure 4-4. Here we are representing facts about a pile of blocks on ,NA,NA
"a table. A block is above another block if it is resting on that block. Block b is above block a, block c is ",NA,NA
"above block b, and block d is above block c. Hence by transitivity, block d is above block a. ",NA,NA
"Why is transitivity important? Because it can save fact space, by figuring out ""indirect"" facts from a few ",NA,NA
direct ones. So it reduces redundancy. Transitivity will work best when we store facts relating only the ,NA,NA
"""closest"" things--like for ",NA,NA
part_of,NA,NA
", the very smallest thing B that still contains thing A. That's because ",NA,NA
transitivity explains relationships between things farther apart from the same relationships between things ,NA,NA
"closer together, not the other way around. ",NA,NA
Inheritance inferences ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (10 of 29) [23/04/2002 17:38:42],NA
An even more important rule form for artificial intelligence is the ,NA,NA
inheritance,NA,NA
 form. Consider a ,NA,NA
"bureaucratic organization. If it has only one business address, then that is the business address of all the ",NA,NA
employees. It wouldn't make sense for a computer to keep a separate business address fact for each ,NA,NA
employee; that would mean a lot of unnecessary facts. Instead it should store a single address fact with ,NA,NA
"the name of the organization, and reason from that. This reasoning is called inheritance; we say the ",NA,NA
address ,NA,NA
inherits,NA,NA
 from organization to employee. ,NA,NA
"Inheritance always involves two predicates, a property predicate and a relationship predicate. Formally, ",NA,NA
we say property predicate ,NA,NA
p,NA,NA
 inherits with respect to relationship predicate ,NA,NA
r,NA,NA
 if this rule is correct: ,NA,NA
"p(X,Value) :- r(X,Y), p(Y,Value).",NA,NA
"(See Figure 4-5.) That is, we can prove that property ",NA,NA
p,NA,NA
 of ,NA,NA
X,NA,NA
 has value Value if we can prove the ,NA,NA
Y,NA,NA
 is ,NA,NA
related to ,NA,NA
X,NA,NA
 by predicate ,NA,NA
r,NA,NA
", and ",NA,NA
Y,NA,NA
 does have value Value for property ,NA,NA
p,NA,NA
. (This generalizes the rule for ,NA,NA
predicate ,NA,NA
color_object,NA,NA
" in Section 4.1.) Sometimes we use the term ""inheritance"" when ",NA,NA
p,NA,NA
 is a relationship ,NA,NA
"predicate too. Like the transitivity rule, the inheritance rule can be used recursively--that is, the ",NA,NA
p,NA,NA
 on the ,NA,NA
right side can use the rule itself to achieve its ends--but this isn't too common because the ,NA,NA
r,NA,NA
 predicate can ,NA,NA
recurse too. ,NA,NA
Inheritance frequently occurs when the relationship predicate (,NA,NA
r,NA,NA
 in the preceding) is ,NA,NA
a_kind_of,NA,NA
". That is, ",NA,NA
if you want to know some property ,NA,NA
p,NA,NA
 of some ,NA,NA
X,NA,NA
", find some ",NA,NA
Y,NA,NA
" that Xis an example of, and ",NA,NA
Y,NA,NA
's value is ,NA,NA
X,NA,NA
's value too. Some examples: ,NA,NA
"--If people are animals, and animals eat food, then people eat food. ",NA,NA
"--If the Enterprise is a kind of ship, and ships float on water, then the Enterprise floats on ",NA,NA
water. ,NA,NA
But inheritance can occur with relationship predicates besides ,NA,NA
a_kind_of,NA,NA
: ,NA,NA
"--If the hood is part of my car's body, and my car's body is gray, then the hood is gray too. ",NA,NA
"--If the U.S. Navy is part of the U.S. Government, and U.S. Government is everywhere ",NA,NA
"mired in bureaucratic inefficiency, then the U.S. Navy is everywhere mired in bureaucratic ",NA,NA
inefficiency. ,NA,NA
"--If the Enterprise is at Norfolk, and Captain Kirk is on the Enterprise, then Captain Kirk is ",NA,NA
at Norfolk. ,NA,NA
And a semantic network example is shown in Figure 4-6. Here we have facts about a particular truck ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (11 of 29) [23/04/2002 17:38:42],NA
called ,NA,NA
truck_4359,NA,NA
 and its battery. The truck has a location (,NA,NA
nps_north_lot,NA,NA
) and an owner (,NA,NA
nps,NA,NA
). These ,NA,NA
properties inherit ,NA,NA
downward,NA,NA
 to the battery via the ,NA,NA
part_of,NA,NA
" relationship to the battery, and that's what ",NA,NA
"those two dotted lines from the battery node mean. (""Downward"" means from a larger or more general ",NA,NA
"thing to a smaller or more specific thing.) In other words, the location of the battery of a truck comes ",NA,NA
"from the location of the whole truck, and the owner of the battery comes from the owner of the whole ",NA,NA
truck. Inheritance can also proceed upward from the battery. The status property of the battery ,NA,NA
(,NA,NA
defective,NA,NA
") inherits upward, because we can say that the truck is defective when its battery is defective. ",NA,NA
"Generally, properties that represent universal or ""for every X"" quantification (see Appendix A) inherit ",NA,NA
"downward, while properties that represent existential or ""there exists an X"" quantification inherit upward. ",NA,NA
"For instance, the ""animals eat food"" example is downward: this says that for every X an animal, it eats ",NA,NA
"food, and so since people are animals, they eat food too. But consider the property of people that some of ",NA,NA
"them live in North America, i.e. that there exist some people that live in North America. Then since ",NA,NA
"people are animals, some animals live in North America, so that existential property inherits upward. ",NA,NA
"Inheritance of a property need not be absolute--there can always be exceptions. For instance, the battery ",NA,NA
"may be removed from the truck for repair, so even though the truck location is the NPS north lot, the ",NA,NA
"battery location isn't. For such an exception, the location of the battery can be put into the database in ",NA,NA
"front of the inheritance rule, so a query on the truck's battery location will find the fact first. So an ",NA,NA
inheritance rule is a ,NA,NA
default,NA,NA
", general-purpose advice that can be overridden. ",NA,NA
"Inheritance is often associated with transitivity, because when the relationship predicate ",NA,NA
r,NA,NA
" is transitive, ",NA,NA
the interpreter is actually following a transitivity chain to follow an inheritance chain. For instance (see ,NA,NA
"Figure 4-7), suppose we have the facts ",NA,NA
"a_kind_of(vinson,carrier).",NA,NA
"a_kind_of(carrier,ship).",NA,NA
"a_kind_of(ship,vehicle).",NA,NA
"purpose(vehicle,transportation).",NA,NA
and a rule for inheritance of ,NA,NA
purpose,NA,NA
 with respect to ,NA,NA
a_kind_of,NA,NA
: ,NA,NA
"purpose(X,V) :- a_kind_of(X,Y), purpose(Y,V).",NA,NA
and a rule for transitivity of ,NA,NA
a_kind_of,NA,NA
: ,NA,NA
"a_kind_of(X,Y) :- a_kind_of(X,Z), a_kind_of(Z,Y).",NA,NA
Suppose we query: ,NA,NA
"?- purpose(vehicle,P).",NA,NA
We can use the transitivity rule to prove first ,NA,NA
"a_kind_of(vinson,ship)",NA,NA
", then ",NA,NA
"a_kind_of(vinson,vehicle)",NA,NA
; ,NA,NA
"the latter inferred relationship is shown by a dotted link in the Figure. Then the inheritance rule succeeds, ",NA,NA
proving ,NA,NA
"purpose(vinson,transportation)",NA,NA
; this is also shown by a dotted link. ,NA,NA
Thus inheritance is useful for the same reason as transitivity: it can extrapolate an explicit set of facts to a ,NA,NA
"much larger implicit set of facts, by inferences with rules. It usually makes sense, then, to only store ",NA,NA
"""nonredundant"" property facts that can't be inherited (though it won't give wrong answers to store ",NA,NA
"redundant information, just increase the size of the database and slow other queries a little). So we ",NA,NA
typically should store property facts about properties for the ,NA,NA
most general,NA,NA
 things having those properties. ,NA,NA
This is because inheritance usually goes downward from more general things to more specific things. ,NA,NA
Some implementation problems for transitivity and inheritance ,NA,NA
"Unfortunately, peculiarities of Prolog interpreters can prevent transitivity and inheritance rules from ",NA,NA
working properly. The problem is a possible ,NA,NA
infinite loop,NA,NA
", a frequent danger in Prolog programming. An ",NA,NA
infinite loop is when the same thing is done over and over forever when trying to answer a query. ,NA,NA
"Typically, a rule calls itself forever or a set of rules call one another in cycle forever. (A good clue is the ",NA,NA
"error message ""Out of stack space"" when running a simple program.) You can get into infinite loops in ",NA,NA
"other programming languages too, but it's easier with Prolog because of its emphasis on recursion and ",NA,NA
complicated backtracking. ,NA,NA
"To avoid infinite loops for inheritance, we must pay careful attention to database order. We must put any ",NA,NA
rules about inheriting values for some property after facts about values of that property. We should also ,NA,NA
use ,NA,NA
"p(X,Value) :- r(X,Y), p(Y,Value).",NA,NA
instead of ,NA,NA
"p(X,Value) :- p(Y,Value), r(X,Y).",NA,NA
The second rule can cause an infinite loop in which ,NA,NA
p,NA,NA
 continually calls itself with the same arguments. ,NA,NA
"This won't happen at first, if facts that can match the ",NA,NA
p,NA,NA
 query come before this rule in the Prolog database; ,NA,NA
but whenever the proper answer is ,NA,NA
no,NA,NA
 (either when the only possible answer to the query is ,NA,NA
no,NA,NA
", or when ",NA,NA
"we type enough semicolons after other answers), the interpreter will recurse forever instead of saying ",NA,NA
no,NA,NA
. ,NA,NA
This is because Prolog executes ,NA,NA
top-down,NA,NA
 like other programming languages: the left side of a rule is ,NA,NA
"matched to some query, and then the right side provides new things to match. So be careful with ",NA,NA
"inheritance rules. In fact, as much British detective fiction demonstrates, inheritances can lead to murder. ",NA,NA
But it's tougher to eliminate the infinite loop with the transitivity rule: ,NA,NA
"r(X,Y) :- r(X,Z), r(Z,Y).",NA,NA
This works fine when the ,NA,NA
r,NA,NA
" relationship is provable from the facts, but will never say ",NA,NA
no,NA,NA
 when ,NA,NA
r,NA,NA
 is ,NA,NA
"unprovable. For instance, query ",NA,NA
"?- r(a,b).",NA,NA
won't say ,NA,NA
no,NA,NA
 when there are no facts in the database involving either ,NA,NA
a,NA,NA
 or ,NA,NA
b,NA,NA
: the first predicate expression ,NA,NA
on the right side has no choice but to call on this rule itself. Here reordering the expressions on the right ,NA,NA
"side of the rule won't change anything, because both have predicate ",NA,NA
r,NA,NA
. Instead we must rewrite the rule as ,NA,NA
"two, and use another predicate name, one for queries only. For instance, consider transitivity for the ",NA,NA
boss ,NA,NA
"relationship, where ",NA,NA
"boss(X,Y)",NA,NA
 means that person ,NA,NA
X,NA,NA
 is the boss of person ,NA,NA
Y,NA,NA
". To describe indirect bosses, ",NA,NA
we'll use a new predicate ,NA,NA
superior,NA,NA
 of two arguments: ,NA,NA
"superior(X,Y) :- boss(X,Y).",NA,NA
"superior(X,Y) :- boss(X,Z), superior(Z,Y).",NA,NA
"This will avoid the infinite loop because the only recursion is in the second rule, and the form of the ",NA,NA
second rule is the same as the first (better) form for inheritance rules given previously. ,NA,NA
A similar trick can be used to state symmetry or ,NA,NA
commutativity,NA,NA
 of a two-argument predicate. Examples of ,NA,NA
commutative predicates are the ,NA,NA
equals,NA,NA
" predicate for numbers, the ""distance-between"" predicate for ",NA,NA
"places, and the ""is-friends-with"" predicate for people. The obvious rule can easily cause infinite loops: ",NA,NA
"p(X,Y) :- p(Y,X).",NA,NA
Querying a ,NA,NA
p2,NA,NA
 instead avoids this problem: ,NA,NA
"p2(X,Y) :- p(X,Y).",NA,NA
"p2(X,Y) :- p(Y,X).",NA,NA
provided we don't use ,NA,NA
p2,NA,NA
 in a recursive rule itself. ,NA,NA
A longer example: some traffic laws ,NA,NA
"Rules can do many things. As we have seen, rules can define new predicates and extend the power of old ",NA,NA
"predicates. Rules can also state policies, prescriptions of what to do in particular situations. Here is an ",NA,NA
"example of the representation of California traffic laws. These are the laws about signal lights, for both ",NA,NA
"vehicles and pedestrians, from the ",NA,NA
California Driver's Handbook,NA,NA
", 1985. The letters in brackets are ",NA,NA
paragraph codes for later reference. ,NA,NA
[A] New Signals-Note: California is adopting red arrows and yellow arrows in addition to ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (14 of 29) [23/04/2002 17:38:42],NA
"green arrows, as signals for vehicle traffic. This is what the colors of traffic lights mean: A ",NA,NA
"red light or arrow means ""STOP"" until the green appears. A flashing RED traffic light or ",NA,NA
"arrow means exactly the same as a stop sign, namely STOP! But after stopping, proceed ",NA,NA
"when safe, observing the right-of-way rules. ",NA,NA
"[B] A GREEN light or arrow means ""GO"", but you must let any vehicles or pedestrians ",NA,NA
"remaining in the intersection when the signal changes to green, get through before you ",NA,NA
move ahead. Look to be sure that all cross traffic has stopped before you enter the ,NA,NA
intersection. ,NA,NA
[C] A YELLOW light or arrow warns you that the red signal is about to appear. When you ,NA,NA
"see the yellow light or arrow, you should stop if you can do so safely. If you can't stop, look ",NA,NA
out for vehicles that may enter the intersection when the light changes. A flashing ,NA,NA
YELLOW light or arrow is a warning of a hazard. Slow down and be especially alert. ,NA,NA
"[D] A lighted GREEN ARROW, by itself or with a RED, GREEN or YELLOW light, ",NA,NA
means you may make the turn indicated by the green arrow. But give the right-of-way to ,NA,NA
pedestrians and vehicles which are moving as permitted by the lights. The green arrow ,NA,NA
"pointing left allows you to make a ""protected"" left turn; oncoming traffic is stopped by a ",NA,NA
red light as long as the green arrow is lighted. ,NA,NA
"[E] If the green arrow is replaced by a flashing yellow light or arrow, slow down and use ",NA,NA
"caution; make the move which the green arrow would permit, only when safe for you and ",NA,NA
others. ,NA,NA
"[F] If the green arrow is replaced by a flashing red light or arrow, stop for either signal; ",NA,NA
then go ahead when it's safe to do so. ,NA,NA
[G] NEW SIGNALS--Note: California is adopting international symbols to guide ,NA,NA
"pedestrians at street crossings. An upraised hand (orange) means the same as the ""WAIT"" ",NA,NA
"or ""DON'T WALK"" sign. A walking person symbol (white) means the same as the ",NA,NA
"""WALK"" sign. ",NA,NA
"[H] Special signs for walkers: The ""DON'T WALK"" or ""WAIT"" or upraised hand sign, if ",NA,NA
"flashing, warns the walker that it is safe to cross, first yielding to any vehicles which were ",NA,NA
still in the crossing when the light changed. ,NA,NA
"[I] At a crossing where there are no special pedestrian signals, walkers must obey the red, ",NA,NA
"yellow, or green lights or arrows. But walkers facing a green arrow must not cross the ",NA,NA
street. ,NA,NA
"We can represent the preceding text as a set of Prolog rules in four groups: rules about arrows, rules ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (15 of 29) [23/04/2002 17:38:42],NA
"about cars, rules about pedestrians, and ",NA,NA
default,NA,NA
 rules (the last two ,NA,NA
action,NA,NA
" rules). As we said, defaults are ",NA,NA
"weak prescriptions for general cases, only used if more specific advice cannot be found; for instance, the ",NA,NA
"first default rule says that if nothing prevents you from going forward, go forward. ",NA,NA
"In listing these rules, we follow a standard Prolog convention of putting blank lines between groups of ",NA,NA
rules with the same left-side predicate name; this makes reading long programs easier. We also use ,NA,NA
"comments; anything between the symbols """,NA,NA
/*,NA,NA
""" and """,NA,NA
*/,NA,NA
""" is treated as a comment and ignored by the ",NA,NA
Prolog interpreter. The codes at the beginning of lines reference the relevant paragraph(s) of the ,NA,NA
Driver's ,NA,NA
Handbook,NA,NA
" text. Note that the text and rules do not correspond exactly; in fact, some ""obvious"" rules ",NA,NA
"included are nowhere in the text. What's ""obvious"" to people isn't always so obvious to computers. ",NA,NA
/* ------ Rules for arrow lights ------ */ ,NA,NA
"/* A */ action(car,stop) :- light(yellow_arrow,Direction), ",NA,NA
safe_stop_possible.,NA,NA
"/* D,E */ action(car,yield_and_leftturn) :-",NA,NA
" light(yellow_arrow,left), not(safe_stop_possible).",NA,NA
"/* D,E */ action(car,yield_and_rightturn) :-",NA,NA
" light(yellow_arrow,right), not(safe_stop_possible).",NA,NA
"/* D */ action(car,yield_and_leftturn) :- light(green_arrow,left). ",NA,NA
"/* D */ action(car,yield_and_rightturn) :- light(green_arrow,right).",NA,NA
/* ------ Rules for regular lights ------ */ ,NA,NA
"/* A */ action(car,stop) :- light(red,steady).",NA,NA
"/* A */ action(car,stop_and_go) :- light(red,flashing).",NA,NA
"/* C */ action(car,stop) :- light(yellow,steady), ",NA,NA
safe_stop_possible.,NA,NA
"/* C */ action(car,yield_and_go) :- light(yellow,steady), ",NA,NA
not(safe_stop_possible).,NA,NA
"/* B */ action(car,yield_and_go) :- light(green,steady).",NA,NA
"/* C */ action(car,slow) :- light(yellow,flashing).",NA,NA
"/* A */ action(car,stop) :- light(red_arrow,Direction).",NA,NA
/* ------ Rules for pedestrian lights ------ */ ,NA,NA
"action(pedestrian,stop) :- pedhalt(steady).",NA,NA
"/* I */ action(pedestrian,stop) :- not(pedsignals), greenfacing.",NA,NA
"action(pedestrian,stop) :- pedhalt(flashing), ",NA,NA
safe_stop_possible.,NA,NA
"/* H */ action(pedestrian,yield_and_go) :- pedhalt(flashing), ",NA,NA
not(safe_stop_possible).,NA,NA
"/* H */ action(pedestrian,yield_and_go) :- pedgo(steady).",NA,NA
/* ------ Default rules ------ */ ,NA,NA
"/* I */ action(pedestrian,A) :- not(pedsignals), not(greenfacing), ",NA,NA
"action(car,A).",NA,NA
"action(X,go) :- not(action(X,stop)), ",NA,NA
"not(action(X,stop_and_go)).",NA,NA
/* ------ Rules defining the special terms ------ */ ,NA,NA
"/* G */ pedhalt(State) :- light(wait,State).",NA,NA
"/* G */ pedhalt(State) :- light(dont_walk,State). ",NA,NA
"/* G */ pedhalt(State) :- light(hand,State).",NA,NA
"/* G */ pedgo(State) :- light(walk,State).",NA,NA
"/* G */ pedgo(State) :- light(walking_person,State).",NA,NA
pedsignals :- pedhalt(State). ,NA,NA
pedsignals :- pedgo(State).,NA,NA
"greenfacing :- light(green_arrow,right), ",NA,NA
not(clockwise_cross).,NA,NA
"greenfacing :- light(green_arrow,left), ",NA,NA
clockwise_cross.,NA,NA
"To understand programs like this, it's often a good idea to draw a ",NA,NA
predicate hierarchy,NA,NA
" (actually, a lattice) ",NA,NA
showing which predicates refer to which other predicates within their definitions. This helps distinguish ,NA,NA
high-level,NA,NA
 predicates about abstract things from ,NA,NA
low-level,NA,NA
 predicates about details. Figure 4-8 shows the ,NA,NA
predicate hierarchy for this program. ,NA,NA
"The rules of this program define legal actions in particular traffic situations. To use them, we query the ",NA,NA
predicate ,NA,NA
action,NA,NA
 with unbound variables (outputs) for one or both of its arguments. The first argument to ,NA,NA
action,NA,NA
" represents whether you are a pedestrian or in a car, and the second argument represents a legal ",NA,NA
"action in the situation. So for instance, ",NA,NA
"action(car,stop)",NA,NA
 means that it is legal for the car to stop. The ,NA,NA
most useful way to query ,NA,NA
action,NA,NA
 is to make the first argument an input and the second argument an ,NA,NA
"output. So to know what is legal for a car, query ",NA,NA
"?- action(car,X).",NA,NA
and the variable ,NA,NA
X,NA,NA
 will be bound to a description of some action legal with the current facts; to know ,NA,NA
"what is legal for a pedestrian, query ",NA,NA
"?- action(pedestrian,X).",NA,NA
"To check if some particular action is legal, fill in both arguments. If a sequence of actions is legal, ",NA,NA
"instead of just one, the program puts the characters """,NA,NA
_and_,NA,NA
""" between the actions to form one long word. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (17 of 29) [23/04/2002 17:38:42],NA
"To describe a situation, three kinds of facts are needed: ",NA,NA
--,NA,NA
"light(<kind-of-light>,<light-status>)",NA,NA
: this is the main kind of fact. The first argument is ,NA,NA
either: ,NA,NA
red,NA,NA
 (a circular red light) ,NA,NA
yellow,NA,NA
 (a circular yellow light) ,NA,NA
green,NA,NA
 (a circular green light) ,NA,NA
red_arrow ,NA,NA
yellow_arrow ,NA,NA
green_arrow ,NA,NA
wait,NA,NA
" (the word ""wait"" lit up) ",NA,NA
dont_walk,NA,NA
" (the words ""don't walk"" lit up) ",NA,NA
hand,NA,NA
 (a picture of a human palm) ,NA,NA
walk,NA,NA
" (the word ""walk"" lit up) ",NA,NA
walking_person,NA,NA
 (a picture of a walking person) ,NA,NA
The second argument describes the condition of the light; this is either ,NA,NA
left,NA,NA
 or ,NA,NA
right,NA,NA
 for the ,NA,NA
"arrow lights, and either ",NA,NA
steady,NA,NA
 or ,NA,NA
flashing,NA,NA
 for all the other lights. ,NA,NA
--,NA,NA
safe_stop_possible,NA,NA
: this predicate of no arguments asserts that you can stop quickly and ,NA,NA
safely. ,NA,NA
--,NA,NA
clockwise_cross,NA,NA
": if you are a pedestrian, this predicate of no arguments asserts that the ",NA,NA
path by which you will cross a street is clockwise with respect to the center of that street. ,NA,NA
"For example, here are the facts for when you are in a car approaching an intersection with plenty of room ",NA,NA
"to stop, and you see a steady yellow light and a green arrow light pointing to the left: ",NA,NA
safe_stop_possible.,NA,NA
"light(yellow,steady).",NA,NA
"light(green_arrow,left).",NA,NA
"Rule order matters, since it establishes priorities among actions. Rules for arrows should go before rules ",NA,NA
"for other kinds of lights, because arrows override other lights showing. Within each of the three main ",NA,NA
"groups of rules--arrows, regular lights, and pedestrian lights--the rules for stopping should go first to ",NA,NA
"handle malfunctions of the lights in which more than one light is lit. Finally, defaults should go last, like ",NA,NA
the last two ,NA,NA
action,NA,NA
 rules. ,NA,NA
Running the traffic lights program ,NA,NA
Here are some examples of the program working. Suppose our database is the example facts just given. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (18 of 29) [23/04/2002 17:38:42],NA
Suppose we ask what a car can do: ,NA,NA
"?- action(car,X).",NA,NA
The first three rules fail because there are no facts about yellow arrows. But a green arrow to the left is ,NA,NA
"visible, so the fourth rule succeeds, and we get ",NA,NA
X=yield_and_leftturn,NA,NA
"In other words, in this situation it is legal to yield and then make a left turn. Now if we type a semicolon, ",NA,NA
"the interpreter will try to find an alternative action. It starts from where it left off in the rules, so it next ",NA,NA
"examines the fifth rule. Neither the fifth, sixth or seventh rules are satisfied by the three facts, but the ",NA,NA
eighth rule does succeed. So we get ,NA,NA
X=stop,NA,NA
"In other words it is legal to stop your car. If we type a semicolon once more, the query will fail (the last ",NA,NA
"rule fails because it is legal to stop the car, as we just showed). So there are only two alternatives. ",NA,NA
"For another example, suppose a pedestrian walking along a sidewalk comes to an intersection where they ",NA,NA
wish to cross the street in a clockwise direction with respect to the center of the intersection. Suppose that ,NA,NA
in the direction the pedestrian wants to go there is a steady green light and a flashing white picture of a ,NA,NA
walking person. The representation is: ,NA,NA
clockwise_cross.,NA,NA
"light(green,steady).",NA,NA
"light(walking_person,flashing).",NA,NA
"To discover what we can do, the query is ",NA,NA
"?- action(pedestrian,X)",NA,NA
None of the first twelve rules succeed because this query specifies a pedestrian. For the thirteenth rule to ,NA,NA
"succeed, a ",NA,NA
pedhalt,NA,NA
" rules must succeed, but the lights we observe are not any of the three ",NA,NA
pedhalt,NA,NA
 types. ,NA,NA
"So the thirteenth rule fails, and similarly the fourteenth and fifteenth. For the sixteenth rule we must ",NA,NA
check the ,NA,NA
pedgo,NA,NA
 rules. The first ,NA,NA
pedgo,NA,NA
" rule fails, but the second matches our last fact with the ",NA,NA
State=flashing,NA,NA
". So the sixteenth rule succeeds, and we get typed out ",NA,NA
X=yield_and_go,NA,NA
"which recommends to the pedestrian to first yield the right-of-way, then go ahead. ",NA,NA
"This program should be invoked repeatedly, say every second to decide what to do for that second. And ",NA,NA
each second something must delete old facts and write new facts into the Prolog database. This general ,NA,NA
"approach is followed by most real-time artificial intelligence programs. For speed, each updating can be ",NA,NA
"done by a separate concurrent processor, to avoid interfering with inference. Notice that we have ignored ",NA,NA
"the biggest obstacle to making this program practical, the recognizing of lights in the real world. This is ",NA,NA
"addressed in the ""vision"" subarea of artificial intelligence. ",NA,NA
Declarative programming ,NA,NA
The traffic lights program may not seem much like programs in other programming languages. ,NA,NA
"Programming in Prolog (and much artificial intelligence programming, whatever the language) is ",NA,NA
"different in style from most programming. The style is programs in lots of small modular pieces, pieces ",NA,NA
smaller than the usual subroutines and procedures of other languages. The emphasis is on writing correct ,NA,NA
"pieces, and not on putting the pieces together. In writing and debugging each piece, the emphasis is on ",NA,NA
"whether it makes sense by itself and whether it is logically correct, not how it is used--the ""what"" instead ",NA,NA
"of the ""how"". This is called ",NA,NA
declarative,NA,NA
 programming | REFERENCE 1|. .FS | REFERENCE 1| It's also ,NA,NA
close to what is called ,NA,NA
nondeterminism,NA,NA
 or ,NA,NA
nondeterministic programming,NA,NA
. .FE ,NA,NA
This bothers some students. They feel they don't really understand artificial intelligence programs ,NA,NA
"because there's often no clear, easily understandable sequence in which programs do things. Prolog ",NA,NA
"interpreters for instance work from top to bottom through facts and rules with the same predicate name, ",NA,NA
"but for each new predicate in a query, they jump to the first occurrence of that predicate name, and jump ",NA,NA
around in quite complicated ways when they backtrack. And Prolog's operation represents one of the ,NA,NA
"simpler ways to do artificial intelligence programs, as we'll see in Chapter 6. A programmer accustomed ",NA,NA
to flowcharts may find this bewildering. ,NA,NA
"In reply, one can say that artificial intelligence solves hard problems, problems on which conventional ",NA,NA
"software-engineering techniques (including numerical ones) struggle, and for which artificial-intelligence ",NA,NA
"methods seem to be the only ones that work. And there are no clear criteria for ""intelligent behavior"", so ",NA,NA
in designing intelligent programs it would seem more important to ensure that the individual pieces of the ,NA,NA
program make sense rather than imposing some grand (necessarily controversial) organizing scheme. ,NA,NA
"Usually, researchers don't want artificial intelligence programs to be brilliant, just not dumb, and ",NA,NA
"concentrating on the pieces helps avoid being dumb. Also, the well-known software technique of ",NA,NA
"recursion (see Appendix B and Chapter 5) is best understood in a declarative way, and artificial ",NA,NA
intelligence often uses recursion. ,NA,NA
"This still may not sound too reassuring, but remember there are lots of ways to program. As we say in ",NA,NA
"California, stay mellow. ",NA,NA
Keywords: ,NA,NA
rule ,NA,NA
left side of a rule ,NA,NA
right side of a rule ,NA,NA
local variable in a rule ,NA,NA
parameter variable of a ,NA,NA
rule ,NA,NA
hierarchies of rules ,NA,NA
postponed binding ,NA,NA
transitivity of a predicate ,NA,NA
inheritance of a predicate ,NA,NA
commutativity of a ,NA,NA
predicate ,NA,NA
infinite loop ,NA,NA
database order ,NA,NA
default ,NA,NA
declarative programming,NA,NA
.SH Exercises ,NA,NA
"4-1. (E) What's the difference between """,NA,NA
:-,NA,NA
""" and logical implication? In other words, what's the difference ",NA,NA
between ,NA,NA
a :- b.,NA,NA
 and the logical statement ,NA,NA
"""If b is true, then a is true."" ",NA,NA
4-2. (A) (a) Suppose in a database you had a rule whose right side was guaranteed to be always true. ,NA,NA
How could you get the effect of such a rule in a simpler way? ,NA,NA
(b) Suppose in a database you had a rule whose right side was always guaranteed to be false for any ,NA,NA
assignment of bindings. How could you get the effect of such a rule in a simpler way? ,NA,NA
"4-3. Write rules for reasoning about genealogies (or ""family trees""). Assume the genealogy is represented ",NA,NA
by facts of the single four-argument form ,NA,NA
"child(<name_of_father>,<name_of_mother>,<name_of_child>,<sex>).",NA,NA
Define the following new predicates based on the ,NA,NA
child,NA,NA
 facts: ,NA,NA
"father(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the father of ,NA,NA
Y ,NA,NA
"mother(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the mother of ,NA,NA
Y ,NA,NA
"son(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the son of ,NA,NA
Y ,NA,NA
"grandfather(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the grandfather of ,NA,NA
Y ,NA,NA
"sister(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the sister of ,NA,NA
Y ,NA,NA
"uncle(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the uncle of ,NA,NA
Y ,NA,NA
"ancestor(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the ancestor of ,NA,NA
Y,NA,NA
"half_sister(X,Y)",NA,NA
", meaning ",NA,NA
X,NA,NA
 is the half-sister of ,NA,NA
Y ,NA,NA
4-4. (P) Figure 4-9 is a picture of three stacks of blocks on a table. ,NA,NA
"(a) Represent in Prolog the facts describing the relationships between the blocks. Use two predicates, one ",NA,NA
"that says a block is on another, and one that says a block is immediately to the left of another. Only give ",NA,NA
facts of the second type for blocks at the bottom of piles. ,NA,NA
(b) Type your facts into a file. ,NA,NA
(c) Now ask the Prolog interpreter: ,NA,NA
--what blocks are on block B; ,NA,NA
--what blocks block A is on; ,NA,NA
--what blocks are on other blocks; ,NA,NA
--what blocks are on blocks that are immediately to the left of other blocks. ,NA,NA
(d) Define a new predicate ,NA,NA
above,NA,NA
 which is true when a block is anywhere in the stack above another ,NA,NA
block. Define a new predicate ,NA,NA
stackleft,NA,NA
 when a block is in a stack that is immediately to the left of the ,NA,NA
"stack of another block. Put these into your file, and load the whole thing. ",NA,NA
(e) Now ask the Prolog interpreter: ,NA,NA
--what blocks are above other blocks; ,NA,NA
--what blocks are either above block F or in a stack immediately to the left of its stack; --,NA,NA
what blocks are above other blocks but are not in a stack immediately to the left of any ,NA,NA
block. ,NA,NA
4-5. (A) Consider the rules: ,NA,NA
a(X) :- not(b(X)).,NA,NA
b(X) :- not(c(X)).,NA,NA
Assuming predicate ,NA,NA
b,NA,NA
" is never referenced except in the preceding, and is never queried directly, and there ",NA,NA
are no facts with predicate ,NA,NA
b,NA,NA
", would it be equivalent to define a single rule ",NA,NA
a(X) :- c(X).,NA,NA
Why? ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (22 of 29) [23/04/2002 17:38:42],NA
4-6. (A) (a) Consider the following to be true: ,NA,NA
Clint is the mayor. ,NA,NA
The mayor is respected. ,NA,NA
From this we can conclude that: ,NA,NA
Clint is respected. ,NA,NA
But now suppose: ,NA,NA
Clint is the mayor. ,NA,NA
The mayor is an elected office. ,NA,NA
From this we would seem to be able to conclude: ,NA,NA
Clint is an elected office. ,NA,NA
What is the fallacy in reasoning? ,NA,NA
(b) Consider the following to be true: ,NA,NA
Clint is a movie star. ,NA,NA
Clint is mayor. ,NA,NA
From this it makes sense to conclude: ,NA,NA
A movie star is mayor. ,NA,NA
But now suppose as true: ,NA,NA
John is a little stupid. ,NA,NA
John is mayor. ,NA,NA
It is fallacious then to conclude: ,NA,NA
A little stupid is mayor. ,NA,NA
What is the fallacy? ,NA,NA
"4-7. (A,E) Explain using Prolog concepts the different meanings of the word ""and"" in the following. ",NA,NA
(a) A food crop is anything that is a plant and provides substantial human nutrition. ,NA,NA
(b) A department chairman is a professor and is responsible to the provost. ,NA,NA
"(c) To put out a fire, your options are to apply flame retardants and to let it burn itself out. ",NA,NA
(d) Tom and Sue are managers. ,NA,NA
(e) Tom and Sue are friends. ,NA,NA
4-8. Consider this query: ,NA,NA
"?- a(X,Y), b(X,Y). ",NA,NA
used with this database: ,NA,NA
"a(1,2).",NA,NA
"a(3,5).",NA,NA
"a(R,S) :- b(R,S), b(S,R).",NA,NA
"b(1,3).",NA,NA
"b(2,3).",NA,NA
"b(3,T) :- b(2,T), b(1,T).",NA,NA
"Without using the computer, what is the first answer found to the query? ",NA,NA
4-9. Inheritance involves a thing and a property. Suppose the thing is a computer program. Give two ,NA,NA
"different examples of relationship predicates that are involved in inheritance, and the corresponding ",NA,NA
properties. ,NA,NA
4-10. (A) Consider the type predicate ,NA,NA
some,NA,NA
 of two arguments ,NA,NA
<set>,NA,NA
 and ,NA,NA
<property>,NA,NA
 which is true ,NA,NA
whenever some members of ,NA,NA
<set>,NA,NA
 have ,NA,NA
<property>,NA,NA
. So for instance ,NA,NA
"some(people,american)",NA,NA
 means that ,NA,NA
"some people are American. Consider inheritance involving the ""set containment"" relationship predicate. ",NA,NA
(a) Does ,NA,NA
some,NA,NA
" inherit upward (to an including set), downward (to an included set), both, or neither? ",NA,NA
"(Note: inheritance is only ""yes"" or ""no"", never ""maybe"".) ",NA,NA
(b) Write the inheritance for part (a) as a Prolog rule. ,NA,NA
(c) Consider the similar predicate ,NA,NA
all,NA,NA
 which is true whenever all members of ,NA,NA
<set>,NA,NA
 have ,NA,NA
<property>,NA,NA
. So ,NA,NA
for instance ,NA,NA
"all(people,american)",NA,NA
" means that all people are American. Does it inherit upward, ",NA,NA
"downward, both, or neither? ",NA,NA
(d) Consider the similar predicate ,NA,NA
most,NA,NA
 which is true whenever most members of ,NA,NA
<set>,NA,NA
 have ,NA,NA
<property>,NA,NA
". Does it inherit upward, downward, both, or neither? ",NA,NA
"4-11. (R,A) Suppose we have facts about the components of a car. Suppose: ",NA,NA
--,NA,NA
"front_of(X,Y)",NA,NA
 means part ,NA,NA
X,NA,NA
 of the car is in front of part ,NA,NA
Y,NA,NA
 (towards the headlights); ,NA,NA
--,NA,NA
"inside_of(X,Y)",NA,NA
 means part ,NA,NA
X,NA,NA
 of the car is inside (contained in) part ,NA,NA
Y,NA,NA
. ,NA,NA
(a) Is ,NA,NA
inside_of,NA,NA
 transitive? ,NA,NA
(b) Does ,NA,NA
front_of,NA,NA
 inherit with respect to ,NA,NA
inside_of,NA,NA
"? If so, in which direction? ",NA,NA
(c) Why could it be more useful for a program to have a description of where things are under the hood ,NA,NA
of a car in terms of ,NA,NA
front_of,NA,NA
", ",NA,NA
right_of,NA,NA
", and ",NA,NA
above,NA,NA
" facts instead of in terms of Cartesian (x, y, and z) ",NA,NA
coordinates? ,NA,NA
4-12. Consider the accounting department of some organization you know. For each of the following ,NA,NA
"properties, say whether it inherits (1) upward, to some entity including the accounting department, (2) ",NA,NA
"downward, to some entity included in the accounting department, (3) both directions, or (4) neither ",NA,NA
direction. ,NA,NA
(a) There are crooks in it. ,NA,NA
(b) Half the employees in it are crooks. ,NA,NA
(c) Regulations controlling crookedness are enforced. ,NA,NA
(d) All crooks in it have been caught and punished. ,NA,NA
"4-13. (R,A,P) (a) Represent the following facts in Prolog (binary-relationship predicates are ",NA,NA
"recommended). Represent what the words mean, not what they say; each different word shouldn't ",NA,NA
necessarily be a different predicate name or argument. Type your Prolog facts into a computer file. ,NA,NA
An Acme hotplate has a cord and a body. ,NA,NA
Part of the body of an Acme hotplate is the heating element. ,NA,NA
The heating element is metal. ,NA,NA
Another part of the body of an Acme hotplate is the cover. ,NA,NA
The cover has a knob. ,NA,NA
Plastic is always used for knobs. ,NA,NA
One of the things a cord consists of is a wire. ,NA,NA
Metal comprises the wire. ,NA,NA
Part of the cord is an insulater. ,NA,NA
The insulater is fiber. ,NA,NA
"(b) Start up the Prolog interpreter, load the file, and ask ",NA,NA
--what things are stated to contain metal; ,NA,NA
--what things are stated to be parts of the body of a hot plate. ,NA,NA
(c) Define rules for transitivity of ,NA,NA
part_of,NA,NA
 and upward inheritance of material with respect to ,NA,NA
part_of,NA,NA
", ",NA,NA
rules that can be applied to your answer to part (a). Put these in the file. ,NA,NA
(d) Now ask: ,NA,NA
--what things contain plastic; ,NA,NA
--what things do not contain fiber; ,NA,NA
--what things containing metal also contain fiber. ,NA,NA
4-14. Suppose we have ,NA,NA
a_kind_of,NA,NA
 facts about 31 objects. Suppose by transitivity on these facts we can ,NA,NA
show that object ,NA,NA
a,NA,NA
 is a kind of object ,NA,NA
b,NA,NA
. Suppose the facts have no redundancy (two different routes ,NA,NA
between the same two objects by following arrows) and no cycles (ways to leave an object and return by ,NA,NA
following arrows). ,NA,NA
(a) What is the minimum number of times that you could successfully use the recursive transitivity rule ,NA,NA
"(the rule, not any fact) proving this? Use the two-rule form in Section 4.10. ",NA,NA
(b) What is the maximum number? ,NA,NA
(c) Suppose 30 of the 31 objects appear once and only once each as the first argument to the ,NA,NA
a_kind_of ,NA,NA
facts. Suppose 16 of the 31 objects never appear as a second argument and suppose the rest appear ,NA,NA
"exactly twice each as a second argument. Of the remaining 15 that do appear as a second argument, 8 of ",NA,NA
"them appear in facts with the 16; of the remaining 7, 4 appear in facts with the 8; of the remaining 3, 2 ",NA,NA
appear in facts with the 4; and the remaining one appears in facts with the 2. What data structure does the ,NA,NA
semantic network resemble? ,NA,NA
"(d) For the situation in part (c), what is the maximum number of times the recursive transitivity rule ",NA,NA
could be successfully used to prove that object ,NA,NA
a,NA,NA
 is a kind of object ,NA,NA
b,NA,NA
? ,NA,NA
(e) Suppose ,NA,NA
b,NA,NA
 has property ,NA,NA
v,NA,NA
", and suppose that ",NA,NA
a,NA,NA
 inherits this value because ,NA,NA
a,NA,NA
 is a kind of ,NA,NA
b,NA,NA
. Assume as ,NA,NA
before there are 31 objects total. What is the maximum number of times the inheritance rule (of the form ,NA,NA
of the first one in Section 4.9) could be successfully used proving this? ,NA,NA
"4-15. (a) Represent the following as Prolog facts and rules (definitions). Hint: represent what these mean, ",NA,NA
not what they literally say. Be as general as you can. ,NA,NA
A VW Rabbit is a VW. ,NA,NA
Tom's car is a VW Rabbit. ,NA,NA
Dick's car is a VW Rabbit. ,NA,NA
A VW has an electrical system. ,NA,NA
Part of the electrical system is the alternator. ,NA,NA
The alternator is defective on every VW. ,NA,NA
(b) Write Prolog inference rules that will allow conclusion that Tom's car or Dick's car is defective. Hint: ,NA,NA
you need to define transitivity and inheritance for concepts in part (a). ,NA,NA
"(c) Prove that Dick's car is defective, given the facts and rules of parts (a) and (b). (Don't prove it the way ",NA,NA
a Prolog interpreter would--omit dead ends.) ,NA,NA
"4-16. (P) Write Prolog definitions for the California speed laws that follow, as extracted from the ",NA,NA
California Driver's Handbook,NA,NA
. Your top-level predicate should be called ,NA,NA
limit,NA,NA
", with one argument, an ",NA,NA
output variable. The program should set that variable to the legal maximum speed under the current ,NA,NA
conditions. The current conditions should be specified as Prolog facts. ,NA,NA
"Don't worry too much about the predicates you use here; there's much room for personal taste. Instead, ",NA,NA
worry about the ,NA,NA
order,NA,NA
 of Prolog definitions and facts. Note you must handle the situation in which you ,NA,NA
"may have seen several road signs recently, some perhaps contradictory, and you must decide which ones ",NA,NA
apply. Assume though that any other facts (like the presence of children) apply to the immediate vicinity. ,NA,NA
Warning: you'll find the laws unclear about certain situations; just pick something reasonable in those ,NA,NA
cases. ,NA,NA
"""The maximum speed limit in California is 55 miles per hour. Other speed limit signs tell ",NA,NA
you the highest speed at which you can expect to drive with safety in the places where the ,NA,NA
"signs are set up...."" ",NA,NA
"""In business or residence districts, 25 miles per hour is the speed limit unless signs show ",NA,NA
"other limits. When you see a ""SCHOOL"" sign, the speed limit is 25 miles per hour while ",NA,NA
children are outside or are crossing the street during school hours. The 25 m.p.h. limit ,NA,NA
"applies at all times when a school ground is unfenced and children are outside, even ",NA,NA
"though the road is posted for a higher speed. Lower speed must be obeyed if posted...."" ",NA,NA
"""When you come within 100 feet of a railroad crossing and you cannot see the tracks for ",NA,NA
"400 feet in both directions, the limit is 15 m.p.h. This limit does not apply if the crossing is ",NA,NA
"controlled by gates, a warning signal or a flagman."" ",NA,NA
"""The 15 m.p.h. limit also applies at blind intersections where you cannot see for 100 feet ",NA,NA
"both ways during the last 100 feet before crossing, unless yield or stop signs on the side ",NA,NA
"streets give you the right of way--also in any alley."" ",NA,NA
"As tests, run the program to find the limit at each point in the following scenario: ",NA,NA
(a) You enter a residential district. A sign says 55 m.p.h. ,NA,NA
"(b) You are still in the residential district. You come to a SCHOOL sign, and students are on the ",NA,NA
sidewalks. The time is within school hours. ,NA,NA
(c) A speed limit sign says 35 m.p.h. You enter an alley. ,NA,NA
4-17. (E) Explain in what ways legal definitions are different from Prolog definitions. Is this a weakness ,NA,NA
"of legal definitions, a weakness of Prolog, both, or neither? Should the two evolve closer together? ",NA,NA
"4-18. (E) Definitions of terms in politics don't seem to be very much like Prolog terms. For instance, ",NA,NA
what one nation calls an unprovoked military attack may be considered by the attacking nation as ,NA,NA
"""claiming what is rightfully theirs"" or ""preventing terrorism"". These excuses are not arbitrary but are ",NA,NA
supported by dictionary definitions. What makes political definitions so much more slippery than the ,NA,NA
Prolog definitions of this chapter? ,NA,NA
"4-19. There are several part-whole relationships, even for the same object. Consider a piece of rock ",NA,NA
"consisting of | 10 sup 24 | molecules of silicon dioxide, whose chemical formula is |Si O sub 2|. ",NA,NA
(a) Give an interpretation of ,NA,NA
part_of,NA,NA
 for which the ,NA,NA
color,NA,NA
 property inherits to any part of this rock. ,NA,NA
(b) Give an interpretation of ,NA,NA
part_of,NA,NA
 for which the ,NA,NA
number_of_molecules,NA,NA
 property inherits to any ,NA,NA
subpart. ,NA,NA
4-20. Consider the following proof that God does not exist. Take the following statement as true from the ,NA,NA
definition of God: ,NA,NA
God saves those who can't save themselves. ,NA,NA
(a) Write this as a Prolog rule whose left side and right side both refer to a ,NA,NA
saves,NA,NA
 predicate of two ,NA,NA
arguments. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (28 of 29) [23/04/2002 17:38:42],NA
"(b) Suppose the person saved is God. Show the bindings in the rule, and explain what the rule becomes in ",NA,NA
this case. ,NA,NA
"(c) As you can see, there's a serious logical problem here. Does this prove God doesn't exist? Why? ",NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap4.html (29 of 29) [23/04/2002 17:38:42],NA
Arithmetic and lists in Prolog ,NA,NA
"Before going any further, we need to introduce two additional features of Prolog that will come in handy in ",NA,NA
"writing future programs, arithmetic and lists. These give rules new capabilities. As we've seen already, rules ",NA,NA
can: ,NA,NA
1. define new predicates in terms of existing predicates ,NA,NA
2. extend the power of existing predicates (as with inheritance rules) 3. ,NA,NA
recommend what to do in a situation (as with the traffic lights program) ,NA,NA
"To these, we'll now add: ",NA,NA
4. quantify and rank things ,NA,NA
"5. store, retrieve, and manipulate sets and sequences of data items ",NA,NA
Arithmetic comparisons ,NA,NA
Prolog has built-in arithmetic comparison predicates. But their predicate expressions are written differently ,NA,NA
from those shown so far: they're written in the ,NA,NA
infix,NA,NA
 notation of mathematics. The predicate name comes ,NA,NA
"between the arguments, like this: ",NA,NA
3 > 4,NA,NA
 means 3 is greater than 4 ,NA,NA
15 = 15,NA,NA
 means 15 equals 15 ,NA,NA
X < Y,NA,NA
 means ,NA,NA
X,NA,NA
 is less than ,NA,NA
Y ,NA,NA
Z >= 4,NA,NA
 means ,NA,NA
Z,NA,NA
 is greater than or equal to 4 ,NA,NA
PPPP =< 3,NA,NA
 means PPPP is less than or equal to 3 ,NA,NA
"We'll usually put spaces around infix symbols to make them easier to see, but it's not required. As an example, ",NA,NA
here's the definition of a predicate that checks if a number is positive: ,NA,NA
positive(X) :- X > 0.,NA,NA
"With this definition in our database, it could be used like this: ",NA,NA
?- positive(3).,NA,NA
yes,NA,NA
?- positive(-6).,NA,NA
no,NA,NA
Here's the definition of a predicate that checks if its first argument is a number lying in the range from its ,NA,NA
"second to its third argument, assuming all arguments are bound: ",NA,NA
"in_range(X,Y,Z) :- X >= Y, X =< Z. ",NA,NA
"Using this definition, the query ",NA,NA
"?- in_range(3,0,10).",NA,NA
gives the response ,NA,NA
yes,NA,NA
. ,NA,NA
Arithmetic assignment ,NA,NA
"Like any computer language, Prolog has arithmetic computations and assignment statements. Arithmetic ",NA,NA
assignment is done by expressions with the infix ,NA,NA
is,NA,NA
 predicate. Querying these peculiar expressions has the side ,NA,NA
effect of binding some variable to the result of some arithmetic computation. For instance ,NA,NA
X is ( 2 * 3 ) + 7 ,NA,NA
binds (assigns) ,NA,NA
X,NA,NA
 to the value 13 (2 times 3 plus 7). The thing to the left of the ,NA,NA
is,NA,NA
" must be a variable name, and ",NA,NA
"the stuff to the right must be an algebraic formula of variables and numeric constants, something that evaluates ",NA,NA
"to a number. The algebraic formula is written in standard infix form, with operations ",NA,NA
+,NA,NA
", (addition), ",NA,NA
-,NA,NA
"(subtraction), ",NA,NA
*,NA,NA
" (multiplication), and ",NA,NA
/,NA,NA
 (division). We'll often put spaces around these symbols to make them ,NA,NA
"more readable. The algebraic formula can have variables only if they're bound to values, as in ",NA,NA
"Y is 2, X is Y * Y.",NA,NA
where ,NA,NA
Y,NA,NA
" is first bound to 2, and then ",NA,NA
X,NA,NA
 is bound to 4. A practical example is this definition of the square of a ,NA,NA
"number, intended to be a function predicate: ",NA,NA
"square(X,Y) :- Y is X * X.",NA,NA
"If this rule is in the Prolog database, then if we query ",NA,NA
"?- square(3,Y).",NA,NA
"(that is, if we ask what the square of 3 is), the Prolog interpreter will type ",NA,NA
Y=9 ,NA,NA
"Notice that since predicate expressions aren't functions in Prolog, we can't write anything like ",NA,NA
"f(X,Y) + g(X,Z)",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap5.html (2 of 22) [23/04/2002 17:38:46],NA
even if ,NA,NA
f,NA,NA
 and ,NA,NA
g,NA,NA
" are function predicates, because expressions only succeed or fail; expressions don't have ",NA,NA
"""values"". Instead, to add the two function values we must say something like ",NA,NA
"f(X,Y), g(X,Z), T is Y + Z",NA,NA
Another warning: don't confuse ,NA,NA
=,NA,NA
 with ,NA,NA
is,NA,NA
. The ,NA,NA
=,NA,NA
 is a purely logical comparison of whether two things are ,NA,NA
"equal. (Originally intended for numbers, it also works for words.) The ",NA,NA
is,NA,NA
" is an operation, an arithmetic ",NA,NA
assignment statement that figures out a value and binds a variable to it. ,NA,NA
"Reversing the ""is"" ",NA,NA
"A serious weakness of arithmetic, which makes it different from everything else in Prolog we've talked about so ",NA,NA
"far, is that it isn't multiway or reversible. For instance, if we have the preceding definition of ",NA,NA
square,NA,NA
 in our ,NA,NA
"database, and we query ",NA,NA
"?- square(X,9).",NA,NA
"wondering what number squared is 9, the interpreter will refuse to do anything because the right side of the ",NA,NA
is ,NA,NA
statement refers to an unbound variable. This is different from having a bunch of arithmetic facts in ,NA,NA
prefix ,NA,NA
form like ,NA,NA
"square(0,1).",NA,NA
"square(1,1).",NA,NA
"square(2,4).",NA,NA
"square(3,9).",NA,NA
for which we could query ,NA,NA
"square(3,Y)",NA,NA
 or ,NA,NA
"square(X,9)",NA,NA
 or even ,NA,NA
"square(X,Y)",NA,NA
" and get an answer. Similarly, for ",NA,NA
the preceding definition of ,NA,NA
positive,NA,NA
", the query ",NA,NA
?- positive(X).,NA,NA
won't work: the interpreter can only do a ,NA,NA
>,NA,NA
 comparison when both things are bound to numbers. So it will ,NA,NA
complain and refuse to do anything. ,NA,NA
The Prolog interpreter's excuse for its behavior is that function inversion and other such ,NA,NA
multiway reasoning,NA,NA
 is ,NA,NA
"hard to do in general, and sometimes is impossible. A square of a number is easy to compute, but a square root ",NA,NA
requires iterative approximation and a lot more code. And there are an infinity of positive numbers; where ,NA,NA
should an interpreter start when asked to give one? Artificial intelligence requires flexible reasoning capable of ,NA,NA
going in many different directions--people seem to do it. So it's desirable to get around the interpreter's ,NA,NA
limitations. ,NA,NA
One way is to provide additional rules for a predicate definition. Helpful in this is the built-in Prolog predicate ,NA,NA
var,NA,NA
" of one argument, which succeeds if that argument is an unbound variable, and fails otherwise. As an ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap5.html (3 of 22) [23/04/2002 17:38:46],NA
"example of its use, consider a ",NA,NA
better_add,NA,NA
 predicate of three arguments which says the sum of the first two ,NA,NA
"arguments is the third argument. If all three arguments are bound (inputs), then it checks the addition. If the ",NA,NA
"first two arguments are bound, it binds the third to their sum. If the first and third arguments are bound, it ",NA,NA
binds the second to the difference of the third and the first. Similarly if the second and third arguments are ,NA,NA
"bound, it binds the first to the difference of the third and second. Here's the code (",NA,NA
Z,NA,NA
 is a temporary-storage ,NA,NA
variable): ,NA,NA
"better_add(X,Y,S) :- not(var(X)), not(var(Y)), not(var(S)),",NA,NA
" Z is X + Y, Z=S.",NA,NA
"better_add(X,Y,S) :- not(var(X)), not(var(Y)), var(S),",NA,NA
 S is X + Y.,NA,NA
"better_add(X,Y,S) :- not(var(X)), var(Y), not(var(S)),",NA,NA
 Y is S - X.,NA,NA
"better_add(X,Y,S) :- var(X), not(var(Y)), not(var(S)),",NA,NA
 X is S - Y.,NA,NA
We can't handle two arguments unbound; then there's an infinite number of possibilities for the bindings. But ,NA,NA
at least the preceding handles three more cases than the Prolog ,NA,NA
is,NA,NA
 can handle by itself. ,NA,NA
The ,NA,NA
in_range,NA,NA
 predicate of Section 5.1 can provide another example of a predicate enhancement. That ,NA,NA
predicate checked whether its first argument (an input number) was between the second and third arguments ,NA,NA
(input numbers too). We can improve ,NA,NA
in_range,NA,NA
 so that an unbound first argument will make it ,NA,NA
generate,NA,NA
 a ,NA,NA
"number between other two arguments, and generate further numbers on backtracking. To make things easier, ",NA,NA
we'll assume all numbers will be integers. Here's the definition of this ,NA,NA
integer_in_range,NA,NA
: ,NA,NA
"integer_in_range(X,Y,Z) :- not(var(X)), not(var(Y)), not(var(Z)),",NA,NA
" X >= Y, X =< Z.",NA,NA
"integer_in_range(X,Y,Z) :- var(X), not(var(Y)), not(var(Z)),",NA,NA
" Y =< Z, X is Y.",NA,NA
"integer_in_range(X,Y,Z) :- Y =< Z, Y2 is Y + 1,",NA,NA
"integer_in_range(X,Y2,Z).",NA,NA
This is a ,NA,NA
tail-recursive,NA,NA
" program of a form we'll use many times in this chapter. (Again, see Appendix B to ",NA,NA
review recursion.) The first rule handles the case handled before. The second rule says if ,NA,NA
X,NA,NA
 is unbound and ,NA,NA
Y ,NA,NA
and ,NA,NA
Z,NA,NA
" are bound, and we want to generate an integer on the range ",NA,NA
Y,NA,NA
 to ,NA,NA
Z,NA,NA
", we can always pick ",NA,NA
Y,NA,NA
. Otherwise (if a ,NA,NA
"semicolon is typed), the third rule is used. It ""crosses out"" ",NA,NA
Y,NA,NA
 from the range by increasing the lower limit of the ,NA,NA
"range by 1, and generates an integer from this new, narrower range. If the range ever decreases so much that it ",NA,NA
"disappears, all the rules fail. So if we query ",NA,NA
"?- integer_in_range(X,1,10).",NA,NA
the interpreter first replies ,NA,NA
X=1,NA,NA
"; then if we type a semicolon, ",NA,NA
X=2,NA,NA
"; then if we type a semicolon, ",NA,NA
X=3,NA,NA
; and so ,NA,NA
on up to 10. ,NA,NA
Lists in Prolog ,NA,NA
Another important feature of Prolog is linked-lists. Every argument in a predicate expression in a query must ,NA,NA
"be anticipated and planned for. To handle sets and sequences of varying or unknown length, we need ",NA,NA
"something else: linked-lists, which we'll henceforth call just ",NA,NA
lists,NA,NA
. ,NA,NA
"Lists have always been important in artificial intelligence. Lisp, the other major artificial intelligence ",NA,NA
"programming language, is almost entirely implemented with lists--even programs are lists in Lisp. The extra ",NA,NA
space that lists need compared to arrays (see Appendix C) is more than compensated in artificial intelligence ,NA,NA
applications by the flexibility possible. ,NA,NA
"Square brackets indicate a Prolog list, with commas separating items. For example: ",NA,NA
"[monday,tuesday,wednesday,thursday,friday,saturday,sunday]",NA,NA
"(Don't confuse square brackets """,NA,NA
[],NA,NA
""" with parentheses """,NA,NA
(),NA,NA
"""; they're completely different in Prolog. Brackets ",NA,NA
group lists and parentheses group arguments.) Lists can be values of variables just like words and numbers. ,NA,NA
Suppose we have the following facts: ,NA,NA
"weekdays([monday,tuesday,wednesday,thursday,friday]).",NA,NA
"weekends([saturday,sunday]).",NA,NA
"Then to ask what days are weekdays, we type the query ",NA,NA
?- weekdays(Days).,NA,NA
and the answer is ,NA,NA
"Days=[monday,tuesday,wednesday,thursday,friday]",NA,NA
"We can also bind variables to items of lists. For instance, if we query ",NA,NA
"?- weekends([X,Y]).",NA,NA
"with the preceding facts in the database, we get ",NA,NA
"X=saturday, Y=sunday",NA,NA
But that last query requires that the weekends list have exactly two items; if we query ,NA,NA
"?- weekends([X,Y,Z]).",NA,NA
we get ,NA,NA
no,NA,NA
 because the query list can't be made to match the data list by some binding. ,NA,NA
We can work with lists of arbitrary length by the standard methods for linked-pointer list manipulation. We can ,NA,NA
refer to any list of one or more items as ,NA,NA
[X|Y],NA,NA
", where ",NA,NA
X,NA,NA
 is the first item and ,NA,NA
Y,NA,NA
" is the rest of the list (that is, the ",NA,NA
list of everything but the first item in the same order) | REFERENCE 1|. .FS | REFERENCE 1| In the language ,NA,NA
"Lisp, ",NA,NA
X,NA,NA
 is called the ,NA,NA
car,NA,NA
 and ,NA,NA
Y,NA,NA
 is called ,NA,NA
cdr,NA,NA
" of the list. .FE We'll call """,NA,NA
|,NA,NA
""" the ",NA,NA
bar,NA,NA
 symbol. Note that ,NA,NA
[X|Y],NA,NA
 is quite ,NA,NA
different from ,NA,NA
"[X,Y]",NA,NA
"; the first can have any nonzero number of items, whereas the second must have exactly ",NA,NA
two items. Note also that ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 are different data types in ,NA,NA
[X|Y],NA,NA
; ,NA,NA
X,NA,NA
" is a single item, but ",NA,NA
Y,NA,NA
 is a list of items. ,NA,NA
So ,NA,NA
[X|Y],NA,NA
 represents an uneven division of a list. ,NA,NA
Here are some examples with the previous weekdays and weekends facts. ,NA,NA
?- weekdays([A|L]).,NA,NA
"A=monday, L=[tuesday,wednesday,thursday,friday]",NA,NA
"?- weekdays([A,B,C|L]).",NA,NA
"A=monday, B=tuesday, C=wednesday, L=[thursday,friday]",NA,NA
"?- weekends([A,B|L]).",NA,NA
"A=saturday, B=sunday, L=[]",NA,NA
"The """,NA,NA
[],NA,NA
""" is the list of zero items, the ",NA,NA
empty list,NA,NA
 | REFERENCE 2|. .FS | REFERENCE 2| Called ,NA,NA
nil,NA,NA
 in the ,NA,NA
language Lisp. .FE ,NA,NA
Defining some list-processing predicates ,NA,NA
Let's write some famous list-processing programs (summarized in Figure 5-1). Programs requiring many lines ,NA,NA
of code in conventional programming languages can often be quite short in Prolog because of its declarative ,NA,NA
"nature. We'll define mostly function predicates. Following the convention of Section 2.9, the function result is ",NA,NA
the last argument of their predicate expressions. ,NA,NA
"First, here's a definition of a predicate that computes the first item of an indefinitely long list: ",NA,NA
"first([X|L],X).",NA,NA
"This definition is a fact, not a rule--but remember, facts are just rules with no right side. So ",NA,NA
X,NA,NA
 stands for any ,NA,NA
"item, and ",NA,NA
L,NA,NA
 stands for any list. ,NA,NA
Here's a definition of the last item of a list: ,NA,NA
"last([X],X).",NA,NA
"last([X|L],X2) :- last(L,X2).",NA,NA
The first line says that the last item of a list of one item is that item. The second line says the last item of any ,NA,NA
other nonempty list is the last item of the list formed by removing the first item. This is a tail-recursive ,NA,NA
program with the first line the ,NA,NA
basis step,NA,NA
 (simple nonrecursive case) and the second line the ,NA,NA
induction step ,NA,NA
"(recursive case). Tail recursion is the standard way to define list-processing predicates in Prolog, with each ",NA,NA
recursion chopping one item off a list. ,NA,NA
We can use ,NA,NA
first,NA,NA
 and ,NA,NA
last,NA,NA
" just like the predicate definitions in Chapter 4, to work on data we type in. For ",NA,NA
instance: ,NA,NA
"?- last([monday,tuesday,wednesday,thursday,friday],X).",NA,NA
X=friday,NA,NA
We can also use it on lists in the database by doing a database retrieval first. Suppose we have a database fact: ,NA,NA
"weekdays([monday,tuesday,wednesday,thursday,friday]).",NA,NA
Then we could find out the last weekday by: ,NA,NA
"?- weekdays(L), last(L,X).",NA,NA
"L=[monday,tuesday,wednesday,thursday,friday], X=friday",NA,NA
"As another example of a list-processing definition, consider ",NA,NA
"member(X,L)",NA,NA
 which is true if item ,NA,NA
X,NA,NA
 is a ,NA,NA
member of list ,NA,NA
L,NA,NA
. We can give the following fact and rule (note the order: the recursive part of a definition ,NA,NA
"should always come after the nonrecursive, to avoid an infinite loop) | REFERENCE 3|: ",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
".FS | REFERENCE 3| Recursive list-processing predicate definitions, and many other recursive definitions too, ",NA,NA
"can be made considerably more efficient by Prolog's built-in ""cut"" predicate (symbolized by """,NA,NA
!,NA,NA
"""), to be explained ",NA,NA
"in Section 10.7. For instance, a better version of ",NA,NA
member,NA,NA
 for most purposes is: ,NA,NA
"member(X,[X|L]) :- !. ",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
 .FE The fact says that ,NA,NA
X,NA,NA
 is a member of any list where it is the first item; ,NA,NA
"there's no need to check the rest of the list then. Otherwise, figure out if ",NA,NA
X,NA,NA
" is a member of the rest of the list, and ",NA,NA
that's the answer. Notice there's no need to give conditions under which ,NA,NA
member,NA,NA
" fails, like ",NA,NA
"member(X,[]) :- 1=2.",NA,NA
"Since 1 can never equal 2, this rule never succeeds. But in Prolog, failure failing when we use a rule means the ",NA,NA
same thing as no rule at all. So the immediately preceding rule is completely useless. ,NA,NA
We just gave a declarative explanation of the ,NA,NA
member,NA,NA
 predicate. For a ,NA,NA
procedural,NA,NA
 explanation (though we ,NA,NA
"emphasize again that this is not the best way to understand recursive programs), consider the query ",NA,NA
"?- member(dick,[tom,dick,harry]).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap5.html (7 of 22) [23/04/2002 17:38:46],NA
The first line of the ,NA,NA
member,NA,NA
 definition fails because ,NA,NA
dick,NA,NA
 is not ,NA,NA
tom,NA,NA
". So the second line is used, creating a ",NA,NA
recursive call ,NA,NA
"?- member(dick,[dick,harry]).",NA,NA
for which the first line succeeds. So the original query gives ,NA,NA
yes,NA,NA
. ,NA,NA
The ,NA,NA
member,NA,NA
 definition will also work when the first argument is unbound (an output). Then the program ,NA,NA
generates,NA,NA
" members of a list in succession under backtracking, something quite useful for artificial-intelligence ",NA,NA
programs. Consider the query: ,NA,NA
"?- member(X,[tom,dick,harry]).",NA,NA
"When the interpreter executes this, the first line of the program can match ",NA,NA
X=tom,NA,NA
", and this binding is printed ",NA,NA
"out. If we now type a semicolon, we request a different binding, forcing the interpreter to use the second rule. ",NA,NA
So this recursive call is executed: ,NA,NA
"?- member(X,[dick,harry]).",NA,NA
"And for this new query the first line can succeed, giving the result ",NA,NA
X=dick,NA,NA
". If we type another semicolon, we'll ",NA,NA
be querying ,NA,NA
"?- member(X,[harry]).",NA,NA
and we'll get ,NA,NA
X=harry,NA,NA
"; and if we type yet another semicolon, we'll be querying ",NA,NA
"?- member(X,[]).",NA,NA
and we'll get ,NA,NA
no,NA,NA
. ,NA,NA
Here's a predicate ,NA,NA
"length(L,N)",NA,NA
 that computes length ,NA,NA
N,NA,NA
 of a list ,NA,NA
L,NA,NA
: ,NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2 + 1.",NA,NA
"Remember, ",NA,NA
[],NA,NA
 represents the ,NA,NA
empty list,NA,NA
", the list with no members. The first line says the empty list has length ",NA,NA
zero. The second line says that the length of any other list is just one more than the length of the list created by ,NA,NA
removing the first item. For instance: ,NA,NA
"?- length([a,b,c,d],N). ",NA,NA
N=4,NA,NA
Here's a predicate ,NA,NA
"max(L,M)",NA,NA
 that computes the maximum of a list ,NA,NA
L,NA,NA
 of numbers: ,NA,NA
"max([X],X).",NA,NA
"max([X|L],X) :- max(L,M), X > M. ",NA,NA
"max([X|L],M) :- max(L,M), X =< M.",NA,NA
The first line says the maximum of a list of one item is that item. The second line says that the first number in a ,NA,NA
list is the maximum of the list if it's greater than the maximum for the rest of the list. The third line says the ,NA,NA
maximum of a list is the maximum for all but the first item of the list if neither of the first two rules applies. ,NA,NA
For instance: ,NA,NA
"?- max([3,7,2,6,1],N). ",NA,NA
N=7,NA,NA
List-creating predicates ,NA,NA
"Suppose we want to delete every occurrence of some item from a list, creating a new list. We can do this with a ",NA,NA
predicate ,NA,NA
delete,NA,NA
 of three arguments: (1) the item ,NA,NA
X,NA,NA
" we want to get rid of (an input), (2) the initial list ",NA,NA
L,NA,NA
 (an ,NA,NA
"input), and (3) the final list ",NA,NA
M,NA,NA
 (an output). And we'll assume that's the only pattern of inputs and outputs we'll ,NA,NA
ever use. For instance: ,NA,NA
"?- delete(b,[b,a,b,b,c],M). ",NA,NA
"M=[a,c]",NA,NA
"To define this, we could write: ",NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],Mnew) :- not(X=Y), delete(X,L,M), Mnew is [Y|M].",NA,NA
But there's a better way to write the last rule: we can move the ,NA,NA
[Y|M],NA,NA
 list to the left side. This is good because ,NA,NA
(1) the ,NA,NA
is,NA,NA
" is unnecessary because left sides can also bind variables, and (2) ",NA,NA
is,NA,NA
" isn't completely reversible, and ",NA,NA
we'd like a more multiway program. So we could use instead: ,NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- not(X=Y), delete(X,L,M).",NA,NA
"This works the same, even with the third argument unbound, because nothing can be done with the ",NA,NA
[Y|M],NA,NA
 on ,NA,NA
the left side until the right side is executed and ,NA,NA
M,NA,NA
 is bound. So the construction of ,NA,NA
[Y|M],NA,NA
 remains the last thing ,NA,NA
done by the third rule. ,NA,NA
You may be puzzled why the ,NA,NA
not(X=Y),NA,NA
 in the third line is necessary. We could write ,NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- delete(X,L,M).",NA,NA
The ,NA,NA
delete,NA,NA
 predicate never fails for its first two arguments bound; one of those three rules must always ,NA,NA
"succeed. So if the second line fails, the left side must be at fault, and ",NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
" must be different, right? Yes, ",NA,NA
but only the ,NA,NA
first,NA,NA
 time through. If we ever backtrack into this ,NA,NA
delete,NA,NA
", we'll be in trouble because backtracking ",NA,NA
would use the third rule for some situation in which it used the second rule previously. For instance: ,NA,NA
"?- delete(b,[a,b,a,b,c],L).",NA,NA
"L=[a,a,c] ;",NA,NA
"L=[a,a,b,c] ;",NA,NA
"L=[a,b,a,b,c] ;",NA,NA
no,NA,NA
So be careful in Prolog programming: just because something works OK for its first answer doesn't mean it ,NA,NA
will work OK on backtracking to get new answers. ,NA,NA
"Next, here's a useful predicate that ""appends"" (concatenates) one list to another. It has three arguments: the ",NA,NA
"first list, the second list, and the combined list. ",NA,NA
"append([],L,L).",NA,NA
"append([X|L1],L2,Lnew) :- append(L1,L2,L3), Lnew is [X|L3].",NA,NA
As with ,NA,NA
delete,NA,NA
", we can rewrite the last rule to eliminate the awkward and undesirable ",NA,NA
is,NA,NA
", moving the ",NA,NA
[X|L3],NA,NA
 to ,NA,NA
the left side: ,NA,NA
"append([],L,L).",NA,NA
"append([X|L1],L2,[X|L3]) :- append(L1,L2,L3).",NA,NA
"This says first that the anything appended on the empty list is that thing itself. Otherwise, to append some ",NA,NA
nonempty list having first item ,NA,NA
X,NA,NA
 to a second list ,NA,NA
L2,NA,NA
", append the ",NA,NA
rest,NA,NA
 of that first list (without ,NA,NA
X,NA,NA
) to ,NA,NA
L2,NA,NA
", and ",NA,NA
then put ,NA,NA
X,NA,NA
 in front of that. Study this revised definition carefully; it's a good example of how the style of ,NA,NA
Prolog programming differs from the style of most other programming. ,NA,NA
Figure 5-2 shows an example using ,NA,NA
append,NA,NA
 with the first two arguments bound (inputs) and the third ,NA,NA
"argument unbound (an output), for the query ",NA,NA
"?- append([gas,oil],[tires,battery,radiator],Things_to_check_before_trip).",NA,NA
The nested boxes represent the rule invocation environments created with each recursion. The outer one holds ,NA,NA
the parameter and local variables for the initial invocation of ,NA,NA
append,NA,NA
". This invocation recursively calls itself, ",NA,NA
"creating the middle box, with its own distinct variables. This invocation of ",NA,NA
append,NA,NA
 in turn recursively calls ,NA,NA
"itself, resulting in the inner environment (box) with yet more distinct variables. The processing state at this ",NA,NA
point is depicted in the Figure. Now: ,NA,NA
1. The first line of ,NA,NA
append,NA,NA
 says to bind its third argument to its value of ,NA,NA
L,NA,NA
", ",NA,NA
"[tires,battery,radiator]",NA,NA
", and the invocation of the inner box succeeds. ",NA,NA
"2. Returning next to the middle box, ",NA,NA
"[tires,battery,radiator]",NA,NA
 is the value of ,NA,NA
L3,NA,NA
", and its ",NA,NA
X,NA,NA
 is ,NA,NA
oil,NA,NA
", so ",NA,NA
[X|L3],NA,NA
 is ,NA,NA
"[oil,tires,battery,radiator]",NA,NA
. So the invocation of the middle box succeeds. ,NA,NA
"3. Returning to the outer box, ",NA,NA
"[oil,tires,battery,radiator]",NA,NA
 is the value of ,NA,NA
its,NA,NA
L3,NA,NA
", so its ",NA,NA
[X|L3],NA,NA
 is ,NA,NA
"[gas,oil,tires,battery,radiator]",NA,NA
. The outer box succeeds. ,NA,NA
4. So the original third argument ,NA,NA
Things_to_check_before_trip,NA,NA
 is bound to ,NA,NA
"[gas,oil,tires,battery,radiator]",NA,NA
. ,NA,NA
Like the ,NA,NA
member,NA,NA
" predicate and many other predicates defined without arithmetic, ",NA,NA
append,NA,NA
 will work several ,NA,NA
"ways. In fact, it will work seven ways (see Figure 5-3). For instance, it will handle the case in which the third ",NA,NA
argument is bound (an input) but the first and second arguments are unbound (outputs). Then the first two ,NA,NA
arguments are bound to binary partitions (breakings-in-half) of the third argument. So ,NA,NA
"?- append(L1,L2,[tom,dick,harry]).",NA,NA
gives the following if you keep typing a semicolon: ,NA,NA
"L1=[], L2=[tom,dick,harry];",NA,NA
"L1=[tom], L2=[dick,harry];",NA,NA
"L1=[tom,dick], L2=[harry];",NA,NA
"L1=[tom,dick,harry], L2=[];",NA,NA
no.,NA,NA
The other rows in Figure 5-3 show other ways ,NA,NA
append,NA,NA
" can be used. Basically, we've got seven quite different ",NA,NA
programs in one. This comes about from the declarative interpretation of the definition: it describes conditions ,NA,NA
"that hold when its third argument is the result of appending the first two arguments, not how to do it. Again, it ",NA,NA
"describes ""what"" instead of ""how"". ",NA,NA
Combining list predicates ,NA,NA
"List predicate definitions can refer to other list predicates. For instance, we can use ",NA,NA
member,NA,NA
 to define a ,NA,NA
subset ,NA,NA
predicate that determines whether all the members of some list ,NA,NA
L1,NA,NA
 are members of some list ,NA,NA
L2,NA,NA
". Here it is, and ",NA,NA
we print ,NA,NA
member,NA,NA
 as well to refresh your memory. ,NA,NA
"subset([],L).",NA,NA
"subset([X|L1],L2] :- member(X,L2), subset(L1,L2).",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"We leave a blank line between the rule groups with the same predicate name, following a convention (also ",NA,NA
followed in the traffic lights program of Section 4.11). Here's an example use of the program: ,NA,NA
"?- subset([b,c],[a,c,e,d,b]). ",NA,NA
yes,NA,NA
"Here's a program for sorting lists of numbers into increasing order, ",NA,NA
insertion sort,NA,NA
 in particular: ,NA,NA
"sort([],[]).",NA,NA
"sort([X|L1],L2) :- sort(L1,L3), insert_item(X,L3,L2).",NA,NA
"insert_item(X,[],[X]).",NA,NA
"insert_item(X,[Y|L],[X,Y|L]) :- X < Y.",NA,NA
"insert_item(X,[Y|L1],[Y|L2]) :- X >= Y, insert_item(X,L1,L2).",NA,NA
The first argument to ,NA,NA
sort,NA,NA
" is an unsorted input list, and the second argument is the output sorted list. The first ",NA,NA
argument to ,NA,NA
insert_item,NA,NA
" is an input item, the second argument an input list, and the third argument is the ",NA,NA
"result of inserting that item into that list, an output. For instance: ",NA,NA
"?- sort([3,2,7,4],L). ",NA,NA
"L=[2,3,4,7]",NA,NA
Redundancy in definitions ,NA,NA
Basis conditions in a recursive definition are simple cases that don't require recursion. We always need at least ,NA,NA
"one basis condition in a recursion, but we can have more than one. For instance, we could define length of a list ",NA,NA
this way: ,NA,NA
"length([],0).",NA,NA
"length([X],1).",NA,NA
"length([X,Y],2).",NA,NA
"length([X,Y,Z|L],N) :- length(L,N2), N is N2 + 3.",NA,NA
instead of equivalently: ,NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2+1.",NA,NA
But the extra lines can speed calculation when our lists are very short on the average: we're able to answer ,NA,NA
many queries without recursion. Here's a similar alternative to the ,NA,NA
member,NA,NA
 definition of Section 5.5: ,NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y,X|L]).",NA,NA
"member(X,[Z,Y|L]) :- member(X,L).",NA,NA
"Here the second line is redundant, since its case can be covered by a slightly modified third line. But if lists are ",NA,NA
"often, or the things we're looking for are usually towards the front of the lists, the preceding definition may be ",NA,NA
faster than the original definition. ,NA,NA
Such modifications are a kind of ,NA,NA
caching,NA,NA
", a concept that occurs in many disguises in artificial intelligence, and ",NA,NA
which will reappear in a quite different form in Chapter 6. Caching means asserting unnecessary or redundant ,NA,NA
facts to improve efficiency. The idea is to waste a little space (the extra facts) in the hope of improving ,NA,NA
"calculation speed. Caching doesn't always improve speed significantly, so to justify it you first need to do ",NA,NA
"experiments, or do some mathematical analysis like that we'll do in Section 9.14 and 13.3. ",NA,NA
An example: dejargonizing bureaucratese (*) ,NA,NA
Natural language (human language) is a major subarea of artificial intelligence research. Lists and list ,NA,NA
processing routines are the obvious way to represent and use sentences and languages in Prolog. As an ,NA,NA
"example, consider a critical technical problem facing the United States today: the translation of bureaucratic ",NA,NA
jargon into real English. Bureaucratic organizations typically use their own terminology to make their ,NA,NA
accomplishments look a little less pathetic than they really are. It would be useful to take a sentence of such ,NA,NA
"bureaucratic jargon, expressed as a Prolog list, and convert it to understandable everyday English. Such a ",NA,NA
translation program might be used routinely on government documents. ,NA,NA
"For instance, ""impact"" is often misused as a verb, as in ""The study will impact the department."" When so used, it ",NA,NA
"can be replaced by the simpler and more standard English word ""affect"". Similarly, ""adversely impact"" and ",NA,NA
"""negatively impact"" can be replaced by ""hurt"". ""Transition"" is also misused as a verb, as in ""The project will ",NA,NA
"transition to phase 3,"" and can be replaced by ""change"". ""Evaluate options"" and ""consider options"" can be ",NA,NA
"changed to ""study"", and ""under advisement"" and ""under consideration"" to ""being studied"". You can probably ",NA,NA
"recall many more examples. These substitutions usually but not always have the same meanings, so the sentence ",NA,NA
created by applying them should always be carefully double-checked. ,NA,NA
"It's easy to write a Prolog program for this, once English sentences are represented in Prolog list format. First ",NA,NA
we represent the substitution pairs as facts. For example: ,NA,NA
"substitution([adversely,impact],[hurt]).",NA,NA
"substitution([negatively,impact],[hurt]).",NA,NA
"substitution([impact],[affect]),",NA,NA
"substitution([will,transition],[will,change]).",NA,NA
"substitution([must,transition],[must,change]).",NA,NA
"substitution([to,transition],[to,change]).",NA,NA
"substitution([consider,options],[study]).",NA,NA
"substitution([evaluate,options],[study]).",NA,NA
"substitution([under,advisement],[being,studied]. ",NA,NA
"substitution([under,consideration],[being,studied]. ",NA,NA
"substitution([expedite],[do]).",NA,NA
"substitution([expeditiously],[fast]).",NA,NA
"substitution([will,secure],[will,close]).",NA,NA
"substitution([must,secure],[must,close]).",NA,NA
"substitution([prioritize],[rank]).",NA,NA
"The first argument contains the original words, and the second argument the words to be substituted. Note that ",NA,NA
"extra words in the first argument narrow the applicability of the substitution, but reduce the possibility of ",NA,NA
making mistakes. ,NA,NA
"Next we define a predicate that recurses through the sentence list, like ",NA,NA
member,NA,NA
 and ,NA,NA
delete,NA,NA
 defined in Sections ,NA,NA
5.5 and 5.6 respectively: ,NA,NA
"dejargonize([],[]).",NA,NA
"dejargonize(L,NL) :- substitution(S,NS), append(S,L2,L),",NA,NA
" append(NS,L2,L3), dejargonize(L3,NL).",NA,NA
"dejargonize([X|L],[X|L2]) :- dejargonize(L,L2).",NA,NA
"The first line sets the basis condition as the empty list, and the last line recurses through the list. The middle ",NA,NA
two lines do the work of substitution. They check through the substitution facts for one whose first argument ,NA,NA
matches the front of the list (using the ,NA,NA
append,NA,NA
" predicate according to the third line of Figure 5-3, for second ",NA,NA
"argument unbound), and substitute (using ",NA,NA
append,NA,NA
" according to the second line of Figure 5-3, for the third ",NA,NA
"argument unbound), and recurse on the new list. Here's an example: ",NA,NA
?- dejargonize ,NA,NA
"([we,must,consider,options,to,transition,expeditiously],L).",NA,NA
"L=[we,must,study,to,change,fast]",NA,NA
"Despite the somewhat frivolous nature of this program, the idea of substituting into strings of words is ",NA,NA
"important in much natural language work, and we'll look some more into it at the end of the next chapter. ",NA,NA
Keywords: ,NA,NA
infix ,NA,NA
arithmetic assignment ,NA,NA
is ,NA,NA
prefix ,NA,NA
multiway reasoning ,NA,NA
recursion ,NA,NA
tail recursion,NA,NA
basis of a recursion ,NA,NA
induction step of a recursion ,NA,NA
lists ,NA,NA
Lisp ,NA,NA
linked-pointer list representation ,NA,NA
the bar symbol ,NA,NA
the member predicate ,NA,NA
the delete predicate ,NA,NA
the append predicate ,NA,NA
caching,NA,NA
Exercises ,NA,NA
"5-1. (A,P) Define a Prolog predicate max(X,Y,Z,M) that says that M is the maximum of the three input ",NA,NA
"numbers X, Y",NA,NA
", and Z. Use only "">"" to compare numbers. ",NA,NA
"5-2. (R,A) A student familiar with Pascal was writing a compiler in Prolog. This required translating an ",NA,NA
"error code number into an English description, so they wrote rules like this: ",NA,NA
"translate(Code,Meaning) :- Code=1, Meaning is integer_overflow.",NA,NA
"translate(Code,Meaning) :- Code=2, Meaning is division_by_zero. ",NA,NA
"translate(Code,Meaning) :- Code=3, Meaning is unknown_identifier.",NA,NA
This is poor Prolog programming style. How can it be improved? ,NA,NA
5-3. (P) Write a better_divide like better_add that handles similar cases for division. Have the program ,NA,NA
prevent division by zero. ,NA,NA
"5-4. To figure out a tax amount, you subtract the deductions from the gross and multiply by the tax rate ",NA,NA
(expressed as a decimal number less than 1). Using the better_add predicate defined in Section 5.3 and an ,NA,NA
"analogous predicate better_multiply that you define yourself, write a single Prolog rule that can be used ",NA,NA
to answer all the following questions by a single query each: ,NA,NA
"--If my gross is 1,000, my deductions 270, and my tax rate 0.15, what is my tax? ",NA,NA
"--If my tax was 170 at a tax rate of 0.17, with no deductions, what was my gross? ",NA,NA
"--If my tax was 170 at a tax rate 0.17 and a gross of 1500, what amount of deductions did I ",NA,NA
take? ,NA,NA
--What tax rate would result in a tax of 80 on a gross of 1200 with 400 in deductions? ,NA,NA
"If your Prolog dialect can handle decimal numbers, show your program works correctly for the ",NA,NA
preceding questions. ,NA,NA
"5-5. (P) (This requires a Prolog dialect with floating-point numbers.) Define a predicate square(X,Y) that ",NA,NA
says that its second argument is the square of its first argument (the result of multiplying the first ,NA,NA
"argument by itself). Using the built-in var predicate, have it handle each of the four cases of binding of ",NA,NA
its arguments: ,NA,NA
"--if both arguments are bound, it checks that the second argument is the square of the ",NA,NA
first; ,NA,NA
"--if the first argument is bound and the second argument unbound, it computes the square of ",NA,NA
the first argument; ,NA,NA
"--if the first argument is unbound and the second argument is bound, it computes an ",NA,NA
approximation of the first argument within 0.001 by bisection search or some other ,NA,NA
iterative method from numerical analysis; ,NA,NA
"--if both arguments are unbound, it generates all possible pairs of positive integers and ",NA,NA
their squares starting with 1. ,NA,NA
"5-6. (P) (a) Define a new predicate integer_better_add, like better_add but able to handle the case in ",NA,NA
"which its first two arguments are unbound (outputs), finding all pairs of integers that sum to a bound ",NA,NA
(input) integer third argument. ,NA,NA
(b) Use part (a) to write a program to generate three-by-three magic squares that have a given number ,NA,NA
as characteristic sum. (A ,NA,NA
magic square,NA,NA
 is a two-dimensional array of integers such that the sum of eight ,NA,NA
"things--the three columns, the three rows, and the two diagonals--is the same.) ",NA,NA
5-7. Consider this query: ,NA,NA
"a(X,Y), not(c(X)), d(X,Y).",NA,NA
"Suppose our Prolog database contains this, in order: ",NA,NA
"d(X,Y) :- X > 1, Y > 1.",NA,NA
"a(0,1).",NA,NA
"a(0,2).",NA,NA
"a(2,1).",NA,NA
"a(M,N) :- b(P,Q), b(Q,P), M is P + 1, N is Q + 1.",NA,NA
c(0).,NA,NA
"b(3,1). ",NA,NA
"b(2,1). ",NA,NA
"b(1,2).",NA,NA
"(a) Without using the computer, what is the first answer found to the query by a Prolog interpreter? ",NA,NA
"(b) Without using the computer, what is the second answer found to the query (when you type a ",NA,NA
semicolon after the first answer)? ,NA,NA
"5-8. (R,A) Suppose we have Prolog facts about named events in terms of the following three predicates: ",NA,NA
"start(<event>,<time>), an event started at a particular time ",NA,NA
"end(<event>,<time>), an event ended at a particular time ",NA,NA
"duration(<event>,<length>), an event lasted for a particular length of time ",NA,NA
"We may have one, two, or all three of these facts about some event, and we can't know in advance which ",NA,NA
we will have if we have one or two. ,NA,NA
"(a) Write Prolog rules to infer an end time for some event when there is no end(Event,Time) fact for it, ",NA,NA
"and to infer a start time when there is no start(Event,Time) fact for it. ",NA,NA
"(b) Define a new Prolog predicate after(Event1,Event2) which is true when its first argument Event1 ",NA,NA
definitely happened after its second argument Event2. ,NA,NA
"(c) Define a new Prolog predicate during(Event1,Event2) which is true when its first argument Event1 ",NA,NA
definitely happened while its second argument Event2 was happening. ,NA,NA
(d) Explain where in a Prolog database of facts these rules should go for things to work right. ,NA,NA
"5-9. (R,A) The transmission of a car contains gears that transmit power to the car's wheels. You can ",NA,NA
"infer the speed and direction of the wheels, given facts about what gears are connected to what other ",NA,NA
gears and what is driving them. ,NA,NA
"Assume gears are labeled g1, g2, g3, and so on. Assume the number of teeth on each gear is specified by ",NA,NA
facts of the form ,NA,NA
"teeth(<gear_name>,<number_of_teeth>).",NA,NA
Assume all rigid connections between gears on the same rigid shaft are specified by facts of the form ,NA,NA
"same_shaft(<gear_name_1>,<gear_name_2>).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap5.html (17 of 22) [23/04/2002 17:38:46],NA
Assume that all meshed (teeth-to-teeth) connections between gears are specified by facts of the form ,NA,NA
"meshed(<gear_name_1>,<gear_name_2>).",NA,NA
(a) We want to reason about the rotational speed and direction of gears. Give a good format for such ,NA,NA
facts for each gear. ,NA,NA
"(b) Anytime two gears are rigidly attached to the same rigid shaft, their rotational speeds are the same. ",NA,NA
Write a Prolog rule that can infer the rotational speed of one such gear on a shaft from the known ,NA,NA
rotational speed of another such gear. Use the fact format from part (a). ,NA,NA
"(c) Anytime two gears are connected or ""meshed"" the product of the number of teeth and the rotational ",NA,NA
"speed for each gear is the same, except that one gear rotates in the opposite direction from the other. ",NA,NA
Write a Prolog rule that can infer the rotational speed of a gear from the rotational speed of a gear ,NA,NA
"meshed with it, assuming the number of teeth on both gears is known. Use the fact format from part (a). ",NA,NA
(d) Suppose gear g1 has a rotational speed of 5000 rpm in a clockwise direction. Suppose it is on the ,NA,NA
"same shaft as g2, g2 is meshed to g3, and g2 is meshed to g4. Suppose g1 has 100 teeth, g2 has 30 teeth, ",NA,NA
"g3 has 60 teeth, and g4 has 90 teeth. Give a Prolog query that will figure out the rotational speed and ",NA,NA
direction of gear g4 from a database of these facts. Then show the steps that the Prolog interpreter will ,NA,NA
take to answer that query. Note: you must write the facts with the correct order of arguments in order ,NA,NA
for your inference rules to apply properly to them. ,NA,NA
"(e) Explain how infinite loops could happen when reasoning about gears, if you weren't careful in ",NA,NA
specifying the facts. ,NA,NA
(f) Suppose for some arrangement of gears and specified gear speeds you find gear g8 has a speed of ,NA,NA
"1200 rpm by one chain of reasoning, and 800 rpm by another chain of reasoning. What does this mean ",NA,NA
for the gears? ,NA,NA
"5-10. (P) Define a predicate convert that does units conversion for length measurement; for instance, it ",NA,NA
converts a measurement in feet to meters. The convert predicate should take four arguments: a number ,NA,NA
"(an input), the units for that number (an input), the units to which you want to convert (an input), and the ",NA,NA
"result number (an output). Handle the following units: meters, decimeters, centimeters, millimeters, ",NA,NA
"decameters, kilometers, inches, feet, yards, and miles. Hint: don't write a separate rule for every pair of ",NA,NA
"possible units, but chain inferences. ",NA,NA
5-11. Consider representing maps of highway routes in Prolog. Suppose you don't have much memory ,NA,NA
"space, so representing squares of the map as a two-dimensional array is out of the question. Instead, you ",NA,NA
want to store just information about what towns are connected by which highways segments (assume ,NA,NA
"segments have names and numbers, not unique, like ""California 62""), and distances. Suppose highway ",NA,NA
"segments are in different counties, states, and countries, and we want to remember which. Suppose we ",NA,NA
also store the different maximum speed limits for different states and countries. Assume each route is in a ,NA,NA
single county (you can create imaginary towns on county lines to ensure this). Assume highway ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap5.html (18 of 22) [23/04/2002 17:38:46],NA
segments meet only at towns. ,NA,NA
(a) Give formats for the fact predicates you need. ,NA,NA
(b) Give a rule or rules for inferring the maximum speed limit on a road. ,NA,NA
"(c) Give a rule or rules for inferring a distance (not necessarily the shortest, that's hard) between two ",NA,NA
towns. Don't worry about getting into a infinite loop; assume the Prolog interpreter is smart enough not ,NA,NA
to visit the same town twice in a route (we'll explain how to do this in Chapter 10). ,NA,NA
"(d) Suppose there are R routes (connecting two towns each), C counties, S states, and K countries. How ",NA,NA
many facts do you save with the inference in part (b)? Make reasonable assumptions if necessary. ,NA,NA
(e) Suppose there are R routes (connecting two towns each) and T towns. Approximately how many ,NA,NA
facts do you save with the inference in part (c)? Perhaps consider different arrangements of towns. ,NA,NA
Make reasonable assumptions if necessary. ,NA,NA
5-12. (P) Define a completely multidirectional inference_distance of three arguments. Its first argument is ,NA,NA
a kind of the second argument. Its third argument is the number of linking a_kind_of facts that must be ,NA,NA
"followed to get from the first argument to the second. By ""completely multidirectional"" we mean able to ",NA,NA
"handle any pattern of bindings of the arguments. Assume there are only a_kind_of facts, no rules, and ",NA,NA
"the facts don't have any cycles, and there is only one route between any two things. (The inference ",NA,NA
"distance concept is important in psychology, because some psychologists believe that humans have ",NA,NA
semantic networks in their heads and that the speed of human reasoning is proportional to the inference ,NA,NA
distance.) ,NA,NA
"5-13. (E) Consider a Prolog definition written to implement a function, in other words written to be used ",NA,NA
"when all arguments but the last are bound (inputs), which binds its last argument to some unique value. ",NA,NA
"In abstract mathematical terms, what characteristics must the function have to be easily used ",NA,NA
"multidirectionally, that is with last argument bound and other arguments unbound? ",NA,NA
"5-14. (A,P) (a) Using a single call to append and no other predicates, implement the member predicate. ",NA,NA
(Hint: the fifth row of Figure 5-3 is closest to what you need.) ,NA,NA
"(b) Using a single call to append and no other predicates, implement the last predicate. ",NA,NA
"(c) Using just two calls to append and no other predicates, implement a deleteone predicate that ",NA,NA
removes a single occurrence of some item from a list. ,NA,NA
"(d) Using just two calls to append and no other predicates, implement a before predicate of three ",NA,NA
"arguments, that succeeds if its first two arguments are both members of its list third argument, and ",NA,NA
where the first argument item occurs before the second argument item. ,NA,NA
5-15. (E) Figure 5-3 is missing a row for the case in which all variables are unbound. Explain why for ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap5.html (19 of 22) [23/04/2002 17:38:46],NA
this case the predicate definition will not work properly. ,NA,NA
5-16. Consider the delete predicate defined in the chapter: ,NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- not(X=Y), delete(X,L,M).",NA,NA
(a) Suppose you rewrite it as ,NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- delete(X,L,M).",NA,NA
What happens when you query this predicate with second and third arguments bound and first ,NA,NA
argument unbound? ,NA,NA
(b) What happens if you change the second line to ,NA,NA
"delete(X,[X|L],L).",NA,NA
and query this predicate with first and second arguments bound and third argument unbound? ,NA,NA
5-17. (A) (a) Suppose that Prolog predicate mystery is queried with its first argument a bound (input) ,NA,NA
"list and its second argument unbound (an output). Describe what the predicate mystery does, in a ",NA,NA
sentence of 20 or less English words. (Hint: try it on sample lists.) ,NA,NA
"mystery([],[]).",NA,NA
"mystery([X],[X]).",NA,NA
"mystery([X,Y|L],[X,censored|M]) :- mystery(L,M).",NA,NA
(b) Most recursive list-processing definitions have only one basis condition. Why does the preceding ,NA,NA
definition need two? ,NA,NA
5-18. In the language Logo and other languages with ,NA,NA
turtle geometry,NA,NA
" primitives, there are special ",NA,NA
commands to control a plotting pen. The pen has a position (measured in millimeters in a coordinate ,NA,NA
system) and a direction it is pointing in the plane of the paper (measured in degrees). Two built-in ,NA,NA
predicates manipulate the pen: forward(X) which moves the pen forward a distance X in the direction it ,NA,NA
"is pointing, and right(X), which turns the pen around X degrees (without moving its location) so it points ",NA,NA
"in a new direction. This program draws spirals, increasing the length it moves forward each step: ",NA,NA
"spiral(Side,Angle,Increment) :- forward(Side), right(Angle), ",NA,NA
"Side2 is Side + Increment, spiral(Side2,Angle,Increment).",NA,NA
(a) Draw what the query ,NA,NA
?- unknown(4).,NA,NA
causes to be drawn. Assume the pen is pointing north at the start. Indicate the lengths of lines in your ,NA,NA
drawing. Here is the definition: ,NA,NA
unknown(1) :- right(90).,NA,NA
"unknown(N) :- Nm1 is N-1, unknown(Nm1), N2 is 5-N,",NA,NA
" forward(N2), unknown(Nm1).",NA,NA
(b) Draw what the query ,NA,NA
?- flake(3).,NA,NA
causes to be drawn. Again assume the pen is pointing north at the start. Here is the definition: ,NA,NA
flake(1) :- forward(1).,NA,NA
"flake(N) :- Nm1 is N-1, flake(Nm1), right(-60), flake(Nm1),",NA,NA
" right(120), flake(Nm1), right(-60), flake(Nm1).",NA,NA
Hint: this one is too complicated to figure out procedurally--reason about the declarative meaning of the ,NA,NA
rules. ,NA,NA
"5-19. (A) Consider use of the member predicate with both arguments bound, and with the second (list) ",NA,NA
argument N items long. ,NA,NA
(a) How many times is the rule invoked when the answer to the query is no? ,NA,NA
(b) Suppose the answer to the query is yes and suppose the item being searched for is equally likely to ,NA,NA
appear at any position in the list. How many times on the average will the rule be invoked now? ,NA,NA
"5-20. Consider our ""dejargonizing"" program. Each substitution of one set of words for another takes ",NA,NA
one line to define. Explain how to compress this set of substitutions so one line can handle many ,NA,NA
substitutions. (Hint: variables can be items in lists.) ,NA,NA
"5-21. (E) What is wrong with the following ""proof"" that all horses are the same color? ""One horse is ",NA,NA
"obviously the same color as itself. Suppose for some N, every set of N horses is the same color. Then ",NA,NA
"consider some horse Snowy, a white horse, for purposes of argument. Consider the set of N+1 items ",NA,NA
formed by including Snowy in an arbitrary set of N horses. Now if we take out some other horse than ,NA,NA
"Snowy from this set (call him Blacky), we have a set of N horses. By the induction assumption, these ",NA,NA
horses are all the same color. But Snowy is white. Therefore all the other horses in the original set must ,NA,NA
"have been white. So put Blacky back in and take out some other horse (besides Snowy, call him ",NA,NA
"Alabaster) to create a new set of N horses. This new set must also be all of the same color, so since it ",NA,NA
"includes Snowy, the color must be white. But Blacky is in the set too, and so must be white too. Hence ",NA,NA
"every set of N+1 horses must be white. Hence if any set of N horses is all the same color, any set of N+1 ",NA,NA
"horses is of the same color. Hence by recursive argument, all horses are the same color."" ",NA,NA
"5-22. (A,P) Write a modified transitivity rule (for let's say transitivity of a(X,Y)) that can't ever get into ",NA,NA
infinite loops when answering a query of the form ,NA,NA
"?- a(r,s).",NA,NA
Show your program working on some sample data that contains cycles with respect to the a predicate. ,NA,NA
"(A ""cycle"" means a closed loop in the semantic network.) Hint: use an extra list argument. ",NA,NA
5-23. (P) Create a Prolog database and query it appropriately to create poems of the following form: ,NA,NA
A A B C C B D D D D E E B ,NA,NA
Here each capital letter stands for a class of nonsense words that must rhyme together. B represents one-,NA,NA
"syllable words, and the other letters represent two-syllable words. In addition, the poem cannot have ",NA,NA
duplicate words. Here is an example poem: ,NA,NA
uga buga ru batta hatta nu fitty pitty witty ditty garra farra tu ,NA,NA
It will help to define a predicate different of two arguments that says whether two words are identical. ,NA,NA
"Present your resulting poem as the value of a single variable, a list of lists for which each list is a line of ",NA,NA
the poem. Type semicolons to see what similar poems you get. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap5.html (22 of 22) [23/04/2002 17:38:46],NA
Control structures for rule-based systems ,NA,NA
Rule-based systems for artificial intelligence (also called ,NA,NA
production systems,NA,NA
", but that sounds like an ",NA,NA
assembly line) can work quite differently from the usual (built-in) way that Prolog interpreters work. ,NA,NA
We'll now discuss some of these ways. The differences are in the ,NA,NA
control structure,NA,NA
 or ,NA,NA
conflict resolution ,NA,NA
or ,NA,NA
inference engine,NA,NA
", the way and order in which facts, rules, and parts of rules are used. Choices in the ",NA,NA
order for these things can enormously affect the success and efficiency of a rule-based system--Prolog ,NA,NA
interpreters aren't always best. ,NA,NA
Control structures are somewhat like the algorithms in other parts of computer science. Control ,NA,NA
"structures, however, are more general and less precise in their effects. As we said in Section 4.13, ",NA,NA
"artificial intelligence programs tend to consist of many small pieces of code, and the control structure ",NA,NA
usually serves as a coordinator or manager for all these pieces instead of trying to impose a sequence on ,NA,NA
them all. ,NA,NA
The control structure is critical for an important and practical class of rule-based systems. Called ,NA,NA
rule-,NA,NA
based expert systems,NA,NA
", these rule-based systems try to mimic the performance of human experts on ",NA,NA
"specialized tasks. Their rules are usually more like recommendations than definitions, often like the ",NA,NA
traffic lights example of Section 4.11. Rule-based expert systems typically need large numbers of rules ,NA,NA
about a problem area or ,NA,NA
domain,NA,NA
" in order to approach skilled human performance. Because of their size, ",NA,NA
"efficiency is important, and choice of control structure strongly affects efficiency. We'll frequently have ",NA,NA
"expert systems in mind in this and the next two chapters, if not explicitly. ",NA,NA
"Just like everything else in computer science, there's a tradeoff of generality and flexibility against speed ",NA,NA
with control structure ideas. The ideas we'll discuss in this chapter can be placed on an ,NA,NA
"flexibility/efficiency spectrum (see Figure 6-1). Those that are flexible, ""high-level"", and slow appear at ",NA,NA
"the top, while those that are inflexible, ""low-level"", and fast (",NA,NA
compiled control structures,NA,NA
) appear at the ,NA,NA
bottom. ,NA,NA
Backward-chaining control structures ,NA,NA
Many control structures impose a single sequential ordering on everything that happens. But sequential ,NA,NA
"control structures differ in the relative importance they assign to rule order, fact order, and query (",NA,NA
goal,NA,NA
) ,NA,NA
order. The usual Prolog-interpreter control structure described in Chapter 4 puts goal (query) order top ,NA,NA
"priority, and then treats rule and fact order of equal importance after that, using the database order as a ",NA,NA
way of assigning priorities to individual rules and facts. This is ,NA,NA
backward chaining,NA,NA
 or ,NA,NA
goal-directed ,NA,NA
reasoning,NA,NA
". It is told something to prove, and it tries to find a way, binding variables as necessary. If ",NA,NA
alternative conclusions are possible (as in the traffic lights example in which several actions are ,NA,NA
"considered until one is found), backwards chaining can try to prove the first, then try the second if the ",NA,NA
"first fails, and so on like an ""or"". Backward chaining is often a good control structure when there are ",NA,NA
many more facts than final conclusions (goals). ,NA,NA
"As an example, consider these rules, labeled with codes for easy reference: ",NA,NA
/* R1 */ goal1 :- fact1.,NA,NA
"/* R2 */ goal1 :- a, b.",NA,NA
/* R3 */ goal2(X) :- c(X).,NA,NA
/* R4 */ a :- not(d).,NA,NA
/* R5 */ b :- d.,NA,NA
/* R6 */ b :- e.,NA,NA
/* R7 */ c(2) :- not(e).,NA,NA
"/* R8 */ d :- fact2, fact3.",NA,NA
"/* R9 */ e :- fact2, fact4.",NA,NA
Suppose the goals in this rule-based system are ,NA,NA
goal1,NA,NA
 and ,NA,NA
goal2(X),NA,NA
", and suppose we consider them in ",NA,NA
"that order. In other words, it's like a query was: ",NA,NA
?- goal1; goal2(Z).,NA,NA
Suppose further that only facts ,NA,NA
fact2,NA,NA
 and ,NA,NA
fact3,NA,NA
" are true. R1 is tried first, but ",NA,NA
fact1,NA,NA
 isn't true so it fails. ,NA,NA
"Next R2 is tried, invoking R4 and then R8. R8 succeeds because ",NA,NA
fact2,NA,NA
 and ,NA,NA
fact3,NA,NA
 are both true. So the ,NA,NA
subgoal ,NA,NA
d,NA,NA
" succeeds, and therefore R4 (and ",NA,NA
a,NA,NA
) fails because of the meaning of ,NA,NA
not,NA,NA
. So finally ,NA,NA
goal2,NA,NA
 is ,NA,NA
"tried, which invokes R3. This invokes R7, then R9. The latter fails because ",NA,NA
fact4,NA,NA
 isn't true. So R7 ,NA,NA
"succeeds, hence R3 succeeds with ",NA,NA
X,NA,NA
"=2, and hence ",NA,NA
goal2(2),NA,NA
 succeeds. ,NA,NA
There are several useful enhancements of backward chaining. A simple trick that can often greatly ,NA,NA
improve efficiency is to ,NA,NA
cache,NA,NA
" or enter as facts some or all of the conclusions reached. For instance, once ",NA,NA
we prove conclusion ,NA,NA
b,NA,NA
" with the preceding rules, we could add a ",NA,NA
b,NA,NA
 fact to the database. We should put fact ,NA,NA
b,NA,NA
" in front of rules that can prove it, so a subsequent query will find it before the rules. The more times ",NA,NA
b ,NA,NA
is ,NA,NA
"queried later, the more effort this caching can save. The disadvantage is more facts to search through to ",NA,NA
answer questions. ,NA,NA
Conclusion caching is simple with Prolog: just use the ,NA,NA
asserta,NA,NA
" built-in (that is, you don't have to define it) ",NA,NA
"predicate of one argument, a fact to be asserted. This predicate ",NA,NA
asserta,NA,NA
 is like ,NA,NA
not,NA,NA
 in that the argument ,NA,NA
"must be a predicate expression; querying it always succeeds, but has the side effect of adding that ",NA,NA
"expression as a new fact to the database, in front of the facts with that same predicate name and rules with ",NA,NA
"that name on their left side. Like most of Prolog's built-in predicates, ",NA,NA
asserta,NA,NA
 always fails on ,NA,NA
backtracking: there's no second way you can assert a fact. Prolog also has two related built-in predicates: ,NA,NA
assertz,NA,NA
 which caches a fact ,NA,NA
after,NA,NA
" the last fact or rule in the database having the same predicate name, and ",NA,NA
retract,NA,NA
" which removes (or ""un-caches"") a fact from the database. ",NA,NA
"Another trick to improve efficiency of backward chaining is not to require a complete starting database, ",NA,NA
"but ask for facts as needed--that is, designate ",NA,NA
virtual facts,NA,NA
". For instance, if there's something wrong with a ",NA,NA
"car's electrical system, you could check for loose wiring. But that's a lot of work, and some wires are hard ",NA,NA
"to find. We shouldn't require checking wires before running a car program, only if more obvious ",NA,NA
problems like a dead battery have been ruled out. Backward chaining works well with virtual facts ,NA,NA
because it only queries facts immediately relevant to its conclusions. The control structure we discuss ,NA,NA
"next, forward chaining, does not have this advantage, but it has some others. ",NA,NA
Forward chaining ,NA,NA
Often rule-based systems work from just a few facts but are capable of reaching many possible ,NA,NA
"conclusions. Examples are ""sensory"" and ""diagnosis"" expert systems, like those that identify an object ",NA,NA
"from a description of what you see at a distance, or those that tell you what to do when your car breaks ",NA,NA
"down from a description of what isn't working. For these, it often makes more sense to start with the facts ",NA,NA
"and reason to goals (conclusions), what is known as ",NA,NA
forward chaining,NA,NA
 or ,NA,NA
data-directed computation,NA,NA
 or ,NA,NA
modus ponens,NA,NA
 reasoning. ,NA,NA
"As an example, take the rule ",NA,NA
"a :- b, c.",NA,NA
and suppose ,NA,NA
b,NA,NA
 and ,NA,NA
c,NA,NA
 are facts. Then we can conclude ,NA,NA
a,NA,NA
" is a fact, and add it to the facts we have. This is ",NA,NA
called ,NA,NA
modus ponens,NA,NA
" inference in logic. There's no query, no goals; we just use the facts we know to infer ",NA,NA
some new fact. (The built-in predicate ,NA,NA
asserta,NA,NA
 can help implement this too; see the next chapter.) ,NA,NA
"To use modus ponens as the basis of a control structure, take the facts in order. For each fact, find all ",NA,NA
rules whose right sides contain a predicate expression that can be matched to it. (We can index predicate ,NA,NA
"names mentioned on right sides to speed this up.) Now ""cross out"" the predicate expressions matched in ",NA,NA
"the rules; that is, create new rules like the old rules except without these expressions. But wherever a fact ",NA,NA
"matched the last expression on the right side of some rule, the left side of the rule has been proved a new ",NA,NA
"fact, after substituting in any bindings made on the right side; so cache that new fact in the database. The ",NA,NA
"last paragraph gave an example. For another, consider: ",NA,NA
"a(X,3) :- b(X).",NA,NA
Then if ,NA,NA
b(20),NA,NA
" is a fact, modus ponens would conclude ",NA,NA
"a(20,3)",NA,NA
 is a fact. ,NA,NA
"It matters where we put a new fact among the others, since the facts are pursued in order. Usually it's ",NA,NA
"good to put the new fact in front of those not yet considered, a ",NA,NA
most-recent-fact,NA,NA
 or ,NA,NA
focus-of-attention,NA,NA
 idea. ,NA,NA
So the fact just proved will be the next fact examined; the fact list then is much like a stack (last thing ,NA,NA
"""in"" is the first thing ""out""). This might be good if we want to reach some particular conclusion as fast as ",NA,NA
"possible. But, on the other hand, if we want to systematically find every conclusion possible from the ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (3 of 24) [23/04/2002 17:38:50],NA
"facts, we should put new conclusions at the end of the set of facts; the fact list is then like a queue (last ",NA,NA
"thing ""in"" is the last thing ""out""). ",NA,NA
Any ,NA,NA
not,NA,NA
s in rules require special handling. Since we want to follow the closed-world assumption for ,NA,NA
"forward chaining too (it's simplest), we want ",NA,NA
not,NA,NA
" to mean ""it can't be proved"". So forward chaining must ",NA,NA
first assume all ,NA,NA
not,NA,NA
"s to be false, prove all possible facts, and only then consider as true those ",NA,NA
not,NA,NA
s whose ,NA,NA
arguments are not now facts. Those ,NA,NA
not,NA,NA
s may then prove new facts with new consequences. (To avoid ,NA,NA
"such awkwardness, some artificial-intelligence systems let you state certain facts to be false, and we'll ",NA,NA
"discuss how to handle such ""unfacts"" in Chapter 14, but this creates its own complications.) ",NA,NA
Here's the formal algorithm for (pure) forward chaining: ,NA,NA
1. Mark all facts as unused. ,NA,NA
"2. Until no more unused facts remain, pick the first-listed one; call it F. ""Pursue"" it: ",NA,NA
(a) For each rule R that can match F with a predicate expression on its right ,NA,NA
"side, ignoring ",NA,NA
not,NA,NA
"s, and for each such match in the rule (there can be ",NA,NA
multiple match locations when variables are involved): ,NA,NA
(i) Create a new rule just like R except with the expression ,NA,NA
matching F removed. If variables had to be bound to make the ,NA,NA
"match, substitute these bindings for the bound variables in the ",NA,NA
rule. ,NA,NA
"(ii) If you've now removed the entire right side of rule R, ",NA,NA
you've proved a fact: the current left side. Enter that left side ,NA,NA
"into the list of facts, and mark it ""unused"". (The focus-of-",NA,NA
attention approach here puts the new fact in front of other ,NA,NA
unused facts.) Eliminate from further consideration all rules ,NA,NA
whose left sides are equivalent to (not just matchable to) the ,NA,NA
fact proved. ,NA,NA
"(iii) Otherwise, if there's still some right side remaining, put ",NA,NA
the new simplified rule in front of the old rule. Cross out the ,NA,NA
old rule if it is now redundant. It is redundant if the old rule ,NA,NA
"always succeeds whenever the new rule succeeds, which is ",NA,NA
true when no variables were bound to make the match. ,NA,NA
"(b) Mark F as ""used"". ",NA,NA
3. Create a new fact list consisting of every ,NA,NA
not,NA,NA
 expression mentioned in rules whose ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (4 of 24) [23/04/2002 17:38:50],NA
"argument does not match any used fact. Mark all these as ""unused"", and redo step 2. ",NA,NA
A forward chaining example ,NA,NA
Let's take an example of forward chaining with focus-of-attention handling of new facts. Consider the ,NA,NA
same rules used for backward chaining: ,NA,NA
/* R1 */ goal1 :- fact1.,NA,NA
"/* R2 */ goal1 :- a, b.",NA,NA
/* R3 */ goal2(X) :- c(X). ,NA,NA
/* R4 */ a :- not(d).,NA,NA
/* R5 */ b :- d.,NA,NA
/* R6 */ b :- e.,NA,NA
/* R7 */ c(2) :- not(e).,NA,NA
"/* R8 */ d :- fact2, fact3. ",NA,NA
"/* R9 */ e :- fact2, fact4.",NA,NA
"Suppose the rules are taken in the given order; and that as before, only ",NA,NA
fact2,NA,NA
 and ,NA,NA
fact3,NA,NA
" are true, in that ",NA,NA
order (see Figure 6-2). ,NA,NA
1. We start with ,NA,NA
fact2,NA,NA
", and find the matching predicate expressions R8 and R9. This gives ",NA,NA
the new rules ,NA,NA
/* R10 */ d :- fact3. ,NA,NA
/* R11 */ e :- fact4.,NA,NA
"Rules R8 and R9 are now redundant since no variables were bound, and R8 and R9 can be ",NA,NA
eliminated. ,NA,NA
"2. No new facts were discovered, so we pursue next ",NA,NA
fact3,NA,NA
. This matches an expression in ,NA,NA
"R10. So now R10 succeeds, and the new fact ",NA,NA
d,NA,NA
 is put in front of any remaining unused ,NA,NA
facts (though there aren't any now). R10 can be eliminated. ,NA,NA
3. We pursue fact ,NA,NA
d,NA,NA
", and find that rule R5 mentions it in its right side. (R4 mentions it too, ",NA,NA
but as ,NA,NA
not(d),NA,NA
", and we're saving ",NA,NA
not,NA,NA
s for last.) Matching R5 gives the new fact ,NA,NA
b,NA,NA
. Rules R5 ,NA,NA
and R6 can now be eliminated. ,NA,NA
4. Fact ,NA,NA
b,NA,NA
" matches in R2, giving ",NA,NA
/* R12 */ goal1 :- a.,NA,NA
and rule R2 can be eliminated. The current set of rules is: ,NA,NA
/* R1 */ goal1 :- fact1.,NA,NA
/* R3 */ goal2(X) :- c(X).,NA,NA
/* R4 */ a :- not(d).,NA,NA
/* R7 */ c(2) :- not(e).,NA,NA
/* R11 */ e :- fact4.,NA,NA
/* R12 */ goal1 :- a.,NA,NA
"5. We have no more facts to pursue. But we're not done yet, since R4 and R7 have ",NA,NA
not,NA,NA
s. ,NA,NA
6. Fact ,NA,NA
d,NA,NA
" is true, so rule R4 can't ever succeed. But fact ",NA,NA
e,NA,NA
 has not been proved. Hence add ,NA,NA
not(e),NA,NA
 to the list of facts. ,NA,NA
7. This matches the right side of R7. Hence ,NA,NA
c(2),NA,NA
 is a fact too. Eliminate R7. ,NA,NA
"8. This matches the only expression on the right side of R3, when ",NA,NA
X=2,NA,NA
", and hence ",NA,NA
goal2(2) ,NA,NA
"is a fact. We can't eliminate R3 now because we had to bind a variable to make the match, ",NA,NA
and we can still use R3 for other values of ,NA,NA
X,NA,NA
. ,NA,NA
9. That's everything we can conclude. ,NA,NA
Though Prolog interpreters don't ,NA,NA
automatically,NA,NA
" forward chain, it's not hard to teach them--see Section ",NA,NA
7.10. ,NA,NA
"This ""pure"" forward chaining is rarer in applications than backward chaining. There's a story about a huge ",NA,NA
"metal robot that came clanking into a bar one day. ""I'm a pure-forward-chaining robot, and I can do a ",NA,NA
complete analysis of the quality of any liquor-dispensing establishment with a single sample. Please mix a ,NA,NA
"martini for me, and pour it down the analysis chute in my chest."" The bartender did so, and said, ""That'll ",NA,NA
"be eleven dollars. Say, we don't get too many forward-chaining robots in here."" ""At your prices I'm not ",NA,NA
"surprised,"" replied the robot. ",NA,NA
Hybrid control structures ,NA,NA
Different control structure ideas can be combined in ,NA,NA
hybrid,NA,NA
 control structures. Hybrids of forward and ,NA,NA
"backward chaining, compromising on the advantages and disadvantages of both, are often used, The most ",NA,NA
common is the ,NA,NA
rule-cycle hybrid,NA,NA
 | REFERENCE 1| because it is easy to implement (see Section 7.9). .FS | ,NA,NA
REFERENCE 1| The rule-cycle hybrid is often confused with pure forward chaining. .FE ,NA,NA
"With the rule-cycle hybrid, rules are tried in order as with backward chaining, but each rule is used in a ",NA,NA
"forward chaining (modus ponens) way to assert new facts. The rule list is cycled through repeatedly, first ",NA,NA
ignoring any rules with ,NA,NA
not,NA,NA
s. If the conditions on the right side of some rule all match facts (that's ,NA,NA
facts,NA,NA
", ",NA,NA
"not just something provable), then the rule succeeds and its left side (with appropriate bindings) is added ",NA,NA
"to the database as a new fact. When no new rules succeed on a cycle through all of them, rules with ",NA,NA
not,NA,NA
s ,NA,NA
"are now considered; cycling resumes at the top of the rules, with the ",NA,NA
not,NA,NA
 expressions now succeeding if ,NA,NA
their arguments aren't now facts. Again we continue until no new rules succeed on a cycle. So with the ,NA,NA
"rule-cycle hybrid, rule order takes precedence over fact order, but it's different than with backward ",NA,NA
"chaining. Figure 6-3 summarizes the differences between forward chaining, backward chaining, and the ",NA,NA
rule-cycle hybrid. ,NA,NA
Here's a more formal algorithm. Warning: it will only work with the restriction that no ,NA,NA
not(p),NA,NA
 occurs in ,NA,NA
the right side of a rule before a rule having ,NA,NA
p,NA,NA
" as its left side, for any ",NA,NA
p,NA,NA
", but that's usually easy to satisfy. ",NA,NA
"Cycle through the rules repeatedly until no new facts are found on a cycle, ignoring rules ",NA,NA
with ,NA,NA
not,NA,NA
s. ,NA,NA
"For each cycle, consider the rules in order. ",NA,NA
"For each rule R, treat its right side as a query about the facts ",NA,NA
(without using any other rules via backward chaining). If R ,NA,NA
"succeeds, add its left side (with substitution of bindings made) ",NA,NA
as a fact at the front of the list of facts. And then eliminate ,NA,NA
from further consideration all rules whose left sides are ,NA,NA
equivalent to this new fact. ,NA,NA
Now repeat the previous step with ,NA,NA
all,NA,NA
" the original rules, taking also as true the ",NA,NA
not,NA,NA
s whose ,NA,NA
arguments are not facts. ,NA,NA
Take our standard example: ,NA,NA
/* R1 */ goal1 :- fact1.,NA,NA
"/* R2 */ goal1 :- a, b.",NA,NA
/* R3 */ goal2(X) :- c(X).,NA,NA
/* R4 */ a :- not(d).,NA,NA
/* R5 */ b :- d.,NA,NA
/* R6 */ b :- e.,NA,NA
/* R7 */ c(2) :- not(e).,NA,NA
"/* R8 */ d :- fact2, fact3.",NA,NA
"/* R9 */ e :- fact2, fact4.",NA,NA
With the rule-cycle hybrid when ,NA,NA
fact2,NA,NA
 and ,NA,NA
fact3,NA,NA
 are true (see Figure 6-4): ,NA,NA
"1. R1, R2, R3, R5 and R6 are tried (we skip R4 and R7 because they have ",NA,NA
not,NA,NA
s). None ,NA,NA
succeed because nothing on any right side matches a fact that is stated to be true. ,NA,NA
"2. R8 is tried, and it succeeds. Fact ",NA,NA
d,NA,NA
 is asserted. Eliminate R8. ,NA,NA
3. R9 fails. ,NA,NA
4. We return to the top of the rule list and start a new cycle. Rules R1 through R3 fail as ,NA,NA
"before, and R4 is ignored. ",NA,NA
5. But R5 now succeeds since ,NA,NA
d,NA,NA
 is a fact. Fact ,NA,NA
b,NA,NA
 is asserted. Eliminate R5 and R6. ,NA,NA
Now the rules are: ,NA,NA
/* R1 */ goal1 :- fact1.,NA,NA
"/* R2 */ goal1 :- a, b.",NA,NA
/* R3 */ goal2(X) :- c(X).,NA,NA
/* R4 */ a :- not(d).,NA,NA
/* R7 */ c(2) :- not(e).,NA,NA
"/* R9 */ e :- fact2, fact4.",NA,NA
6. R7 and R9 fail (R8 was eliminated). And all the remaining rules fail on the next cycle. ,NA,NA
"7. Possibilities are exhausted, so we must now include rules with ",NA,NA
not,NA,NA
"s. R1, R2, and R3 fail ",NA,NA
"as before, and R4 fails because ",NA,NA
d,NA,NA
 is a fact. ,NA,NA
"8. R5 and R6 were eliminated, and the ",NA,NA
not,NA,NA
 in R7 succeeds because ,NA,NA
e,NA,NA
 is not a fact. So ,NA,NA
c(2),NA,NA
 is ,NA,NA
a fact. Eliminate R7. ,NA,NA
"9. None of R8, R9, R1, and R2 succeed. But R3 succeeds, with ",NA,NA
X,NA,NA
"=2, and ",NA,NA
goal2(2),NA,NA
 must be a ,NA,NA
fact. We can't eliminate R3 because ,NA,NA
goal2(2),NA,NA
 is more specific than the left side of R3. But ,NA,NA
we're done now if we only want to reach one goal. ,NA,NA
A different hybrid of forward and backward chaining alternates (,NA,NA
time-shares,NA,NA
) between forward and ,NA,NA
"backward chaining steps. It picks a fact, and finds what rule right sides mention it; it does backward ",NA,NA
chaining in those right sides to try to establish the left side as a fact. Then it picks another fact and does ,NA,NA
"the same thing over again. This hybrid sometimes pays off when neither forward, backward, nor rule-",NA,NA
cycle hybrid chaining works well. ,NA,NA
Order variants ,NA,NA
"Query, fact, and rule ordering is important in backward, forward, and rule-cycle hybrid chaining, and ",NA,NA
control structures can apply many criteria to do it. ,NA,NA
"With backward chaining, predicate expressions in the query can be sorted by priority. In an ""and"", the ",NA,NA
expressions easiest to process or least likely to succeed can be done first. Sections 13.2 through 13.7 ,NA,NA
discuss these ideas at length. ,NA,NA
"With forward chaining, facts can be sorted by priority. The facts most useful (matchable in the right sides ",NA,NA
"of the most rules) can go first, to help reach interesting conclusions faster. Or the facts most powerful in ",NA,NA
reaching conclusions can go first (statistics on queries can be kept for this). ,NA,NA
Rule order is important to both forward and backward chaining. One common ordering is by ,NA,NA
specificity,NA,NA
. ,NA,NA
"Specificity doesn't mean how ""concrete"" the rules are, but whether conditions on the right side of rule 1 ",NA,NA
"are a subset of conditions on the right side of rule 2; or in other words, whether the success of rule 2 ",NA,NA
means success of rule 1. The specificity ordering puts rules for the most narrowly described situations (or ,NA,NA
exceptions,NA,NA
") first, then those for less narrow situations, then those still less narrow, and so on up to very ",NA,NA
broad ,NA,NA
default,NA,NA
" rules. (If the most broadest rules came first, the others would never get a chance to work.) ",NA,NA
"Since catching subset relationships between rule right sides requires some analysis, a variant is to put the ",NA,NA
longest,NA,NA
" rules first, but this doesn't work quite as well. ",NA,NA
Here's an example for rule-cycle-hybrid chaining in which all the rule left sides are goals: ,NA,NA
/* R1 */ u :- b.,NA,NA
/* R2 */ v :- c.,NA,NA
"/* R3 */ w :- b, c, d.",NA,NA
"/* R4 */ x :- d, e.",NA,NA
/* R5 */ y :- b.,NA,NA
"/* R6 */ z :- b, d.",NA,NA
"A rule-specificity ordering would insist that R3 be in front of R1, R2, R5, and R6, and insist that R6 be in ",NA,NA
front of R1 and R5. ,NA,NA
There are two problems with specificity ordering. The first is that there are often few such subset ,NA,NA
"relationships among rules, leaving undecided how to complete the ordering. The second is that the ",NA,NA
"narrowest rules apply rarely, meaning wasted work if they're first. Chapter 13 will study these issues. But ",NA,NA
usually a quick fix is available in the adding of extra ,NA,NA
not,NA,NA
" expressions to the broader rules, and putting ",NA,NA
"those rules first. For instance, for our last example it may be possible to rewrite R1 as ",NA,NA
"/* R1 */ u :- b, not(c), not(d).",NA,NA
and then it doesn't matter where it goes. ,NA,NA
"This is often what the original rules really meant, since we often forget the minor exceptions to rules--",NA,NA
"there are just too many. For example, with the rule ""if a car won't start and the radio won't play and the ",NA,NA
"lights don't light, then the battery is dead"", we don't rule out the chance that aliens from outer space have ",NA,NA
nullified all electric fields. ,NA,NA
Partitioned control structures ,NA,NA
"When there are a thousand or more rules as in major current expert systems, the rules can interrelate in ",NA,NA
"many ways, and a bug can be hard to trace. So just like large computer programs, it's a good idea to ",NA,NA
"divide rules into groups, modules, or partitions for which members of each group have minimal ",NA,NA
interactions with members of other groups. You can think of each group as a separate rule-based system ,NA,NA
that may occasionally decide to call on another for a separate analysis. An advantage is that the rule ,NA,NA
groups can be written and debugged mostly separately. This idea is called a ,NA,NA
partitioning,NA,NA
 or ,NA,NA
context-,NA,NA
limiting,NA,NA
 control structure. ,NA,NA
"Diagnosis expert systems provide good examples. For instance in diagnosis of a malfunctioning car, there ",NA,NA
are major systems of the car that don't interact much with one another. If electrical devices aren't ,NA,NA
"working, you can be pretty sure that the problem is in the electrical system; or if the car goes forward but ",NA,NA
"not backward, you can be pretty sure the problem is in the transmission. So you can put rules for ",NA,NA
"electrical problems in one partition, and rules for transmission problems in another, rules for the engine ",NA,NA
"and fuel system in another, rules for the car body in another, and so on. You'll need one other partition of ",NA,NA
"rules, a ""startup"" partition, to look at key evidence and decide which partition appears most relevant to a ",NA,NA
"problem. And partitions can choose to transfer control to another partition, if say none of their own rules ",NA,NA
succeed. ,NA,NA
Meta-rules ,NA,NA
A general approach can encompass all the control structure ideas so far: specification of control by a rule-,NA,NA
based system itself. ,NA,NA
Meta-rules,NA,NA
 are just rules whose domain of knowledge is the operation of another rule-,NA,NA
based system; they're a kind of ,NA,NA
heuristic,NA,NA
", a topic we'll investigate more thoroughly in Chapter 9. Rules ",NA,NA
"deciding to load partitions (Section 6.6) are one simple example of meta-rules, but they can do many ",NA,NA
other things. Remember that one goal for putting knowledge into computers was to make explicit the ,NA,NA
"complicated ""common-sense"" knowledge people have but don't realize they have. How to order rules and ",NA,NA
"use them is another kind of common-sense knowledge, also formalizable. Here are some example meta-",NA,NA
"rules for a backward-chaining-like rule-based system, to control selection of the next rule to try to satisfy ",NA,NA
instead of following the database order of rules: ,NA,NA
--Prefer the rule that handles the most serious issue. ,NA,NA
--Prefer the rule that was written by the most knowledgeable human. ,NA,NA
--Prefer the rule that is fastest to execute. ,NA,NA
--Prefer the rule that has been used successfully the most times. ,NA,NA
--Prefer the rule with the most things in common with the last rule successfully applied. ,NA,NA
"The big advantage of meta-rules is their flexibility and modifiability, which allows precise control of a ",NA,NA
rule-based system. ,NA,NA
Meta-rules can express things besides rule orderings and partition referrals. Prolog interpreters make the ,NA,NA
closed-world assumption,NA,NA
 or ,NA,NA
lack-of-knowledge inference,NA,NA
": if you can't prove something true, assume it ",NA,NA
false. This may be unfair for some predicates; a meta-rule could then override normal reasoning. For ,NA,NA
"instance, a meta-rule could say to use the closed-world assumption only when querying predicates from a ",NA,NA
"certain list, and to assume a failure means ",NA,NA
yes,NA,NA
 otherwise. ,NA,NA
Meta-rules seem to be important in human reasoning. People aren't generally systematic enough to use ,NA,NA
"any of the chaining methods successfully, but instead they rely on problem-specific meta-rules for ",NA,NA
"deciding what to do next. So to reason more naturally, meta-rules are critical. But figuring out just what ",NA,NA
meta-rules people do use is hard. ,NA,NA
Decision lattices ,NA,NA
"We'll now consider some lower-level control structure ideas: decision lattices, concurrency, and and-or-",NA,NA
"not lattices. In the terminology of computer science, these are ",NA,NA
compiled,NA,NA
 structures. But they're compiled ,NA,NA
"in a different sense than what programming-language ""compilers"" produce: they represent a simplifying ",NA,NA
first step before the traditional compiler operates. Some people don't consider these compiled structures ,NA,NA
"truly artificial intelligence, but they're so closely linked to artificial intelligence that we'd better explain ",NA,NA
them. ,NA,NA
"Choosing a good sequence for rules can be important and hard, as we discussed in Section 6.5. But ",NA,NA
computers can use storage structures besides sequences (see Appendix C). They can organize rules in a ,NA,NA
"hierarchy, what is called a ",NA,NA
decision lattice,NA,NA
 or ,NA,NA
discrimination net,NA,NA
. Decision lattices do a restricted but very ,NA,NA
"efficient kind of reasoning, a kind of classification. The idea is to always specify where to go next in the ",NA,NA
"computer based on question answers. In other words, a kind of ",NA,NA
finite-state machine,NA,NA
. (Sometimes they're ,NA,NA
called ,NA,NA
decision trees,NA,NA
", but technically they're lattices since branches that diverge can converge or ""grow ",NA,NA
"back together"" later. Any graph without cycles in which this convergence can happen is a lattice and not a ",NA,NA
tree; cycles wouldn't make much sense here because you'd be asking the same question twice.) ,NA,NA
"For instance, consider an expert system to diagnose malfunctions of small household appliances (see ",NA,NA
Figure 6-5). It is important first to distinguish problems within the appliance from problems outside the ,NA,NA
"appliance. A good way is to ask if the appliance works at all. If it doesn't, ask if it is plugged in. If it isn't, ",NA,NA
"that is the problem. If it is, ask if other electric devices nearby (lights, clocks, etc.) work. If they don't, the ",NA,NA
"problem sounds like a blown fuse. If other appliances definitely work, the problem must be internal to the ",NA,NA
"faulty appliance. If no such observations can be made (as when there are no electrical appliances nearby), ",NA,NA
try plugging the faulty appliance into another outlet to see if the problem reappears. ,NA,NA
"On the other hand, if the appliance partially works, then it matters what kind of appliance it is. That's ",NA,NA
"because interpretation of partial-failure clues is quite appliance-dependent, like smoke when the device ",NA,NA
"has a heating element. As another example, strange noises are more serious in a device with no moving ",NA,NA
parts than in a blender. So the next question for a partially-working appliance should classify it. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (11 of 24) [23/04/2002 17:38:50],NA
So decision lattices impose a classification hierarchy on the universe based on observations. They are ,NA,NA
"useful for simple expert systems, with several advantages: ",NA,NA
1. Implementation is easy: just use pointers (memory references). They can even be ,NA,NA
"implemented without a computer, as printed text with cross-references. ",NA,NA
2. They need not explicitly question a human being: they can examine buffer contents or ,NA,NA
"sensor readings. Then they can be fast, faster than the chaining methods, because no ",NA,NA
"matching, binding, or backtracking is needed. ",NA,NA
3. They can be designed to ask the absolutely minimal number of questions necessary to ,NA,NA
"establish conclusions, unlike chaining methods for which such optimization can be ",NA,NA
difficult. ,NA,NA
"But decision lattices have major disadvantages as a compiled or ""low-level"" control structure: ",NA,NA
1. They can't reason properly or efficiently for many applications because they don't easily ,NA,NA
permit variables or backtracking. ,NA,NA
"2. They are difficult to modify and debug, since later questions must assume certain results ",NA,NA
to earlier questions. ,NA,NA
3. They can't easily reuse query answers since they don't explicitly cache. ,NA,NA
"4. They may be hard to build, because at each point you try to determine the best question ",NA,NA
"to ask, something not so easy to judge. ",NA,NA
Decision lattices were around long before computers. Expert-system technology only made significant ,NA,NA
"progress when decision-lattice control structures were mostly abandoned, due to the limitations ",NA,NA
mentioned. ,NA,NA
Concurrency in control structures ,NA,NA
"If speed of a rule-based system is important (as in a real-time application), and multiple processors are ",NA,NA
"available, a control structure can use concurrency. Usually the processors must share and access the same ",NA,NA
"database of facts and rules for this to work well. For a Prolog-style rule-based system, four types of ",NA,NA
parallelism for concurrency are identified (see Figure 6-6): (1) ,NA,NA
partition parallelism,NA,NA
", (2) ",NA,NA
or parallelism,NA,NA
", ",NA,NA
(3) ,NA,NA
and parallelism,NA,NA
", and (4) ",NA,NA
variable-matching parallelism,NA,NA
. These parallelisms are useful with all three ,NA,NA
kinds of chaining. ,NA,NA
Partition parallelism means running different partitions of the rules simultaneously. Each partition can ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (12 of 24) [23/04/2002 17:38:50],NA
"reason separately, though they can explicitly pass conclusions to one another, or cache into a global ",NA,NA
"database. This is good if we've got groups of rules that don't interact much, each group relevant to a ",NA,NA
problem. ,NA,NA
"""And"" parallelism is parallelism among expressions ""and""ed on the right side of a rule or a query. Usually ",NA,NA
"it is only done for the predicate expressions that do not bind variables, the ""tests"" in the generate-and-test ",NA,NA
"concept (see Section 3.12). These tests can be done concurrently on separate processors; if any test fails, ",NA,NA
"the whole ""and"" should fail, and the other processors should be sent a message to stop work. Otherwise, ",NA,NA
"the ""and"" should succeed. ""And"" parallelism is probably not a good idea when some tests are much harder ",NA,NA
to satisfy than others; then the hard tests should go first (see Chapter 13). ,NA,NA
"""Or"" parallelism usually means parallelism between rules with the same left-side predicate name. It is ",NA,NA
good when there are many such rule groups. Or-parallel rules are sometimes called ,NA,NA
demons,NA,NA
 because ,NA,NA
"they're like little people each independently waiting for a particular set of conditions to be satisfied. ""Or"" ",NA,NA
parallelism can also mean parallel pursuit of facts in forward chaining. ,NA,NA
Variable-matching parallelism is parallelism in the argument matching done when matching two ,NA,NA
"predicate expressions to one another. It makes each match attempt faster, but it doesn't change the usual ",NA,NA
sequential examining of the database. It only pays off when you have a significant number of predicates ,NA,NA
with two or more arguments. ,NA,NA
"Concurrency can be simulated on a sequential machine. This gives a new class of control structures, the ",NA,NA
"sequential reductions of concurrent process descriptions. This idea is often associated with the ""agenda"" ",NA,NA
search methods in Chapter 10. ,NA,NA
"Parallelism is not just an efficiency trick, however. Parallelism is necessary to model many real-world ",NA,NA
phenomena. These phenomena are often addressed in ,NA,NA
object-oriented programming,NA,NA
", for which the world ",NA,NA
is divided into clusters of facts representing ,NA,NA
objects,NA,NA
", each with its own partitioned module of rules ",NA,NA
"governing its behavior. Object-oriented programming is especially useful for simulations. For instance, ",NA,NA
"objects (and their facts) can represent organisms in an ecosystem, and rule modules for each kind of ",NA,NA
organism can govern the behavior of each object. Another application is to modeling components of a ,NA,NA
"car, where each object represents a part of a car. We'll talk more about object-oriented programming in ",NA,NA
"Chapter 12. While it emphasizes rule-partition parallelism, it can also involve the other three kinds. For ",NA,NA
"instance in modeling organisms in an ecosystem, ""and"" and ""or"" parallelism can reflect the ability of ",NA,NA
organisms to do and think several things simultaneously. ,NA,NA
And-or-not lattices ,NA,NA
The extreme case of parallelism in rule-based systems is the ,NA,NA
and-or-not lattice,NA,NA
" representation of rules, in ",NA,NA
which each rule can be thought (or maybe actually is) a hardware logic gate incessantly computing a ,NA,NA
certain logical combination of input logic signals representing facts and intermediate conclusions. (It's ,NA,NA
sometimes incorrectly called an ,NA,NA
and-or tree,NA,NA
", but like in the decision lattice, the paths can recombine after ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (13 of 24) [23/04/2002 17:38:50],NA
"splitting, so it isn't a tree necessarily.) ""And""s in a rule become ""and"" gates, ""or""s become ""or"" gates, and ",NA,NA
"""not""s becomes inverter gates. ",NA,NA
"For instance, for the rules used previously: ",NA,NA
/* R1 */ goal1 :- fact1.,NA,NA
"/* R2 */ goal1 :- a, b.",NA,NA
/* R3 */ goal2(X) :- c(X).,NA,NA
/* R4 */ a :- not(d).,NA,NA
/* R5 */ b :- d.,NA,NA
/* R6 */ b :- e.,NA,NA
/* R7 */ c(2) :- not(e).,NA,NA
"/* R8 */ d :- fact2, fact3.",NA,NA
"/* R9 */ e :- fact2, fact4.",NA,NA
the and-or-not lattice is shown in Figure 6-7. Here we follow the usual conventions for gate shapes (see ,NA,NA
"Appendix A); facts are the far-left-side ""inputs"" and goals are the far-right-side ""outputs"" of this logic ",NA,NA
"network. Truth of a fact or conclusion is represented by a high or ""on"" voltage along a line, falsity by a ",NA,NA
"low or ""off"" voltage. The output (right-side) voltage of a gate is determined by the logic function of the ",NA,NA
"voltages representing input(s) on the left side; ""and"" gates determine a logical ""and"", ""or"" gates logical ",NA,NA
"""or"", and inverter gates logical ""not"". A given set of facts sets the input voltages for a group of initial ",NA,NA
"gates, which determine voltages of others, and so on, with everything proceeding in parallel. The and-or-",NA,NA
not lattice is a useful interpretation of rules and facts for the many applications in which order within ,NA,NA
"""and""s and ""or""s doesn't mean anything. It also provides a specification for an integrated-circuit chip that ",NA,NA
could do this very fast. ,NA,NA
This unordered interpretation of rules takes us to the opposite extreme of the classical Eckert-Mauchly | ,NA,NA
REFERENCE 2| model of the computer as a sequential processor. .FS | REFERENCE 2| Sometimes ,NA,NA
"called the Von Neumann model, but evidence now suggests that Von Neumann had little to do with it. ",NA,NA
.FE The main advantage of the and-or-not lattice is processing speed. Another advantage is the ,NA,NA
"partitionability into modules: we can identify subnetworks and their inputs and outputs, and then build ",NA,NA
them easily into large networks. We don't need to worry much about ,NA,NA
redundancies,NA,NA
", gates whose effect is ",NA,NA
also accomplished by other gates; they can't slow computation. But it is true we can't have contradictory ,NA,NA
gates or results will be meaningless. ,NA,NA
"Like decision lattices, and-or-not lattices do have the disadvantage that they can't handle variables well ",NA,NA
"(you'll notice the example has none). Gates can't directly ""bind"" variables, though we could indirectly ",NA,NA
"represent alternative bindings by having multi-position switches on each input to the logic network, ",NA,NA
switches that could connect the inputs to one of several lines representing the truths of different facts with ,NA,NA
"the same predicate name. Then binding means selecting a switch position, and trying possible bindings ",NA,NA
"means turning the switch and watching the conclusions reached. But this is awkward, and--especially ",NA,NA
"when there is more than one variable--can greatly increase the time to get an answer, a main reason for ",NA,NA
using and-or-not lattices in the first place. ,NA,NA
Randomness in control structures ,NA,NA
"A control structure need not be deterministic (that is, always work the same way on the same rules and ",NA,NA
facts). Human beings seem to have some randomness in their actions. So a control structure can make ,NA,NA
"some random choices, especially when alternatives seem of equal worth. For instance, maybe in backward ",NA,NA
"chaining when there are more than ten rules applicable to a situation, choose one at random. Randomness ",NA,NA
is most appropriate for rule-based systems trying to model skilled real-time performance by people. ,NA,NA
"Randomness can prevent infinite loops, because when you choose randomly you can't get stuck in a rut. ",NA,NA
Grammars for interpreting languages (*) ,NA,NA
Human and computer languages can be handled and processed with ,NA,NA
grammars,NA,NA
. Grammars are rule-based ,NA,NA
"systems different from those considered so far. For one thing, grammar rules don't deal with facts, but ",NA,NA
with strings of words or symbols in a particular order. All grammar rules are of a particular narrow form: ,NA,NA
a statement that one string of words can be substituted for another string of words. Though we didn't say ,NA,NA
"so, we saw an example of a grammar in Section 5.9: those substitution pairs, though disguised as facts. ",NA,NA
But grammars can also have ,NA,NA
nonterminal,NA,NA
" words, words that symbolize grammatical categories and are not ",NA,NA
"part of the language itself. For instance, the nonterminal ""noun"" can be substituted for the word ""man"" or ",NA,NA
"the word ""computer"". Nonterminals can also describe sequences of words, like identifying a ""noun ",NA,NA
"phrase"" as a determiner followed by an adjective followed by a noun. Linguists have lots of these ",NA,NA
categories. ,NA,NA
"Grammars are essential for getting computers to understand sentences in a language, because they make it ",NA,NA
"possible to determine the structure of a sentence. Used this way, grammars are analogous to the rule-based ",NA,NA
"systems in this chapter. The ""facts"" are the words of a sentence, and the goal is to change that sentence, by ",NA,NA
"substitutions, into the sentence consisting of the single nonterminal called ""sentence"". Such a process is ",NA,NA
"analogous to forward chaining, and is called ",NA,NA
bottom-up parsing,NA,NA
. It usually involves substituting shorter ,NA,NA
sequences of words for longer sequences of words. But you can also work in the opposite direction from ,NA,NA
"""sentence"" to a list of actual language words, analogously to backward chaining, and this is called ",NA,NA
top-,NA,NA
down parsing,NA,NA
". It usually involves substituting longer sequences of words for shorter sequences of words, ",NA,NA
"and so is likely to require more backtracking than bottom-up parsing, but less work per backtrack since ",NA,NA
shorter sequences are searched for. Figure 6-8 shows an example; upward arrows represent bottom-up ,NA,NA
"parsing, downward arrows top-down. ",NA,NA
Hybrids that compromise on the advantages and disadvantages of both bottom-up and top-down parsing ,NA,NA
are possible. Grammar rule order is important for efficiency: the most likely rules should be tried first. ,NA,NA
Parts of the sentence can be processed concurrently. Partitioning can be used to group information about ,NA,NA
related words and related parsing rules into modules. Meta-rules can be used for sophisticated control ,NA,NA
more like what people do. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (15 of 24) [23/04/2002 17:38:50],NA
Today most artificial-intelligence work in understanding sentences from human languages (or ,NA,NA
natural ,NA,NA
languages,NA,NA
) uses a variation on top-down parsing called ,NA,NA
augmented transition networks,NA,NA
 (ATNs). These are ,NA,NA
"a ""smarter"" kind of top-down parsing that attaches additional conditions to the parsing rules, so that only ",NA,NA
"the most ""reasonable"" rules that apply will be tried. They also use recursion in a complicated way similar ",NA,NA
to the one in Chapter 11. ,NA,NA
Keywords: ,NA,NA
rule-based systems ,NA,NA
control structure ,NA,NA
conflict resolution ,NA,NA
expert systems ,NA,NA
compiled control structures ,NA,NA
backward chaining ,NA,NA
goal ,NA,NA
virtual facts ,NA,NA
the asserta predicate ,NA,NA
the retract predicate ,NA,NA
forward chaining ,NA,NA
focus-of-attention feature ,NA,NA
rule-cycle hybrid control structure ,NA,NA
rule and fact priorities ,NA,NA
rule specificity ,NA,NA
partitioned control structures ,NA,NA
meta-rules ,NA,NA
decision trees ,NA,NA
partition parallelism ,NA,NA
"""or"" parallelism ",NA,NA
demons ,NA,NA
"""and"" parallelism ",NA,NA
variable-matching parallelism ,NA,NA
object-oriented programming ,NA,NA
and-or-not lattice ,NA,NA
grammar ,NA,NA
top-down parsing ,NA,NA
bottom-up parsing ,NA,NA
augmented transition networks (ATNs),NA,NA
Exercises ,NA,NA
6-1. (A) Here's a rule-based system: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (16 of 24) [23/04/2002 17:38:50],NA
"/* R1 */ k(X) :- j(X), b(X).",NA,NA
"/* R2 */ f(X) :- a(X), ",NA,NA
not(g(X)). ,NA,NA
"/* R3 */ a(X) :- b(X), i.",NA,NA
/* R4 */ d :- i.,NA,NA
"/* R5 */ d :- e(X), c.",NA,NA
"/* R6 */ g(X) :- h, a(X).",NA,NA
/* R7 */ g(X) :- l.,NA,NA
/* R8 */ b(X) :- c.,NA,NA
"Assume the goals are f(X), d, and k(X), in that order, and the facts are c",NA,NA
", ",NA,NA
l,NA,NA
", ",NA,NA
e(a),NA,NA
", and ",NA,NA
j(b),NA,NA
", in that order. ",NA,NA
Assume no extra caching. Assume we stop when a goal is proved. ,NA,NA
"(a) Suppose we use pure forward chaining. List the rule invocations, successes, and failures, in order as ",NA,NA
they occur. Use the rule numbers to indicate rules. ,NA,NA
"(b) Now list the rule invocations, successes, and failures for backward chaining, in order. ",NA,NA
(c) Does fact order affect which goal is proved first with forward chaining? Why? ,NA,NA
(d) Does fact order affect which goal is proved first with backward chaining here? Why? ,NA,NA
6-2. Consider this database: ,NA,NA
"top(X,Y,Z) :- bottom(Z,W,Y,X).",NA,NA
"bottom(A,B,7,D) :- data(A,0,B), data(A,D,1). ",NA,NA
"data(3,0,1).",NA,NA
"data(3,2,1).",NA,NA
List in order the facts that are proved by pure forward chaining using focus-of-attention placement ,NA,NA
of new facts. Don't stop until everything provable is proved. ,NA,NA
"6-3. Suppose we are doing pure forward chaining on a set of R rules, rules without semicolons ",NA,NA
"(""or""s), nots, arithmetic, and variables. Suppose these rules have L distinct predicate expressions ",NA,NA
"on the left sides, and S distinct predicate expressions, each occurring no more than M times, on the ",NA,NA
right sides. Suppose there are T total predicate expressions on right sides. Suppose there are F ,NA,NA
"facts, F>0. ",NA,NA
"(a) What is the maximum number of locations immediately matchable to facts (that is, without ",NA,NA
having to prove new facts) on rule right sides? ,NA,NA
(b) What is the maximum number of new facts that can be eventually found by forward chaining? ,NA,NA
(c) What would be the effect on your answer to part (a) of allowing one-argument variables in rules ,NA,NA
and facts? ,NA,NA
(d) What would be the effect on your answer to part (b) of allowing one-argument variables in rules ,NA,NA
and facts? (A conclusion with an unbound variable still counts as one new fact.) ,NA,NA
6-4. Consider the following Prolog database: ,NA,NA
a(X) :- b(X).,NA,NA
"b(X) :- c(X), d(X). ",NA,NA
"d(X) :- e, f(X).",NA,NA
c(X) :- g(X).,NA,NA
g(2).,NA,NA
f(5).,NA,NA
g(5).,NA,NA
e.,NA,NA
(a) What new facts are proved in order by the rule-cycle hybrid of forward and backward ,NA,NA
chaining? Continue until all possible facts are found. ,NA,NA
(b) What new facts are proved in order by the pure form of forward chaining with focus-,NA,NA
of-attention conflict resolution for facts? Continue until all possible facts are found. ,NA,NA
"6-5. (R,A) Consider the following rules and facts: ",NA,NA
"a :- v, t.",NA,NA
"a :- b, u, not(t). ",NA,NA
"m(X) :- n(X), b.",NA,NA
b :- c.,NA,NA
"t :- r, s.",NA,NA
"u :- v, r.",NA,NA
r.,NA,NA
v.,NA,NA
c.,NA,NA
n(12).,NA,NA
(a) Suppose we do pure forward chaining with focus-of-attention placement of new facts. Suppose ,NA,NA
we want all possible conclusions. List in order the new facts derived from the preceding. Remember ,NA,NA
we must save nots for last. ,NA,NA
"(b) Suppose we do rule-cycle hybrid chaining with focus-of-attention placement of new facts, saving ",NA,NA
"nots for last, and we want all possible conclusions. List in order the new facts derived. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (18 of 24) [23/04/2002 17:38:50],NA
(c) One problem with rule-cycle hybrid chaining is that it repeatedly checks the same rules again on ,NA,NA
each cycle. Describe a way to know when not to check a rule because of what happened on the last ,NA,NA
"cycle, besides the idea of deleting a rule without variables when it succeeds. (Hint: using this idea ",NA,NA
you only need check nine rules total for the preceding rules and facts.) ,NA,NA
6-6. (E) Consider a variant of the rule-cycle hybrid that only cycles through the rules once. How is ,NA,NA
this like an assembly line in a factory? ,NA,NA
"6-7. (A) Suppose we are doing rule-cycle hybrid chaining on R rules, rules without variables and ",NA,NA
"nots. Suppose there are L distinct predicate names on rule left sides, and S distinct predicate names ",NA,NA
"on rule right sides out of T total predicate names on right sides. Suppose there are F facts, F>0. ",NA,NA
What is the maximum number of cycles needed to prove everything that can be proved? ,NA,NA
"6-8. (A,H) Reasoning about rules and facts written in English instead of Prolog can be tricky, and ",NA,NA
you must be careful. Consider the following rule-based system for actions of a small reconnaissance ,NA,NA
"robot. Suppose the following facts are true, in this order: ",NA,NA
F1: There is an object with branches to the right of you. ,NA,NA
F2: This object is 2 feet tall. ,NA,NA
F3: This object occupies 20 cubic feet. ,NA,NA
F4: This object is stationary. ,NA,NA
F5: Another object is moving towards you. ,NA,NA
F6: You hear speech from that object. (Assume speech is not a loud noise.) ,NA,NA
"Assume all other facts mentioned in rules are false. Assume any new facts, when added, will be put ",NA,NA
"at the front of the list of facts. Assume the rule-based system can result in the following actions, in ",NA,NA
this order: ,NA,NA
A1: Turn around. ,NA,NA
A2: Stop and wait. ,NA,NA
A3: Turn towards something. ,NA,NA
A4: Move a short distance forward. ,NA,NA
A5: Turn 20 degrees right. ,NA,NA
A6: Move a long distance forward. ,NA,NA
Here are the rules: ,NA,NA
"R1: If you hear a loud noise in front of you, then turn around and move a long ",NA,NA
distance. ,NA,NA
"R2: If you want to hide, and there is a bush nearby, then turn towards the bush, and ",NA,NA
move a short distance. ,NA,NA
"R3: If you want to hide, and are beneath a bush, then stop and wait. ",NA,NA
"R4: If an object is moving towards you, and it is a person or vehicle, then hide. ",NA,NA
"R5: If an object is moving, and it is an animal, then stop and wait. ",NA,NA
"R6: If an object is an obstacle and you are moving, and the object is blocking your ",NA,NA
"path, then turn right 20 degrees, and move a short distance. ",NA,NA
"R7: Move forward a long distance. [notice no ""if"" part here] ",NA,NA
"R8: If an object has long branches, and the branches are moving, and it does not have ",NA,NA
"wheels, then it is an animal. ",NA,NA
"R9: If an object makes irregular noises, then it is an animal. ",NA,NA
"R10: If an object makes regular noises, and it is moving, it is a vehicle. ",NA,NA
"R11: If an object has wheels, then it is a vehicle. ",NA,NA
"R12: If an object is stationary, and occupies more than 1 cubic foot, it is an obstacle. ",NA,NA
"R13: If an obstacle has branches, and is less than 3 feet tall, it is a bush. ",NA,NA
"R14: If an obstacle has branches, and is more than 3 feet tall, it is a tree. ",NA,NA
"R15: If an obstacle has no branches, it is a rock. ",NA,NA
"R16: If an animal has four branches in two pairs, and one pair supports the animal, it ",NA,NA
is a person. ,NA,NA
"R17: If an animal speaks, it is a person. ",NA,NA
"(a) List in order the rule invocations, successes, and failures with backward chaining. Assume ",NA,NA
"conflict resolution based on the rule order given. Assume caching of proved facts, so once ",NA,NA
something is concluded it need never be figured out again. ,NA,NA
"(b) List in order the rules invoked with forward chaining, ignoring rule R7. Again, take rules in the ",NA,NA
"order given, ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (20 of 24) [23/04/2002 17:38:50],NA
(c) Give a different kind of conflict resolution that would work well for this rule-based system. ,NA,NA
6-9. (A) A rule-based system is monotonic if anything that can be concluded at one time can be ,NA,NA
"concluded at any later time. Consider a consistent (that is, non-self-contradictory) ""pure"" ",NA,NA
"backward-chaining rule-based system, one that doesn't use asserta or retract or any built-in ",NA,NA
predicates besides not. Such a system is necessarily monotonic. ,NA,NA
"(a) Suppose the system is partitioned into modules whose rules cannot ""see"" the rules of other ",NA,NA
modules until those modules are specifically loaded. Must the new scheme be monotonic? ,NA,NA
"(b) Suppose we cache intermediate and final conclusions reached by the system, using asserta. Must ",NA,NA
the new scheme be monotonic? ,NA,NA
(c) Suppose we add to right sides of rules in the system asserta predicate expressions with arbitrary ,NA,NA
arguments. Must the new scheme be monotonic? ,NA,NA
"6-10. (E) (a) Despite their similar names, decision lattices and and-or-not lattices are quite different ",NA,NA
things. List their major differences. ,NA,NA
(b) List their major similarities. ,NA,NA
6-11. Consider the following rule-based system for self-diagnosis and treatment of colds and flu: ,NA,NA
"A. To sleep, go to bedroom. ",NA,NA
"B. To drink fluids, go to kitchen. ",NA,NA
"C. To drink fluids, go to bathroom. ",NA,NA
"D. To take temperature, go to bathroom. ",NA,NA
"E. To take aspirin, go to bathroom. ",NA,NA
"F. To telephone, go to living room. ",NA,NA
"G. To telephone, go to kitchen. ",NA,NA
"H. If feel headache or nasal congestion, then feel sick. ",NA,NA
"I. If feel sick, then take temperature. ",NA,NA
"J. If have fever, then take aspirin. ",NA,NA
"K. If have fever, then call boss. ",NA,NA
"L. If have fever, then go to bed. ",NA,NA
"M. If have nasal congestion or fever, then drink fluids. ",NA,NA
(a) Order the rules in a good way. Show how backward chaining would work applied to the ,NA,NA
"circumstance when you wake up with a headache, nasal congestion, and a fever. (Use the letter in ",NA,NA
front of each rule to identify it.) ,NA,NA
"(b) Suggest a fundamentally different control structure than the preceding, one good for this ",NA,NA
"problem. (Find a general control structure that could work in many daily-living rule-based systems, ",NA,NA
not just this problem.) Show how it would work on the first eight rules applied to the same ,NA,NA
situation. ,NA,NA
"6-12. (R,A) Consider using a rule-based system as the brains of a ""smart house"", a house that ",NA,NA
automatically does a lot of things that people do for themselves in other houses. Assume the smart ,NA,NA
"house can control power to all the electrical sockets, so it can turn lights, heat and appliances on ",NA,NA
and off at programmed times. The smart house can also monitor many different kinds of sensors--,NA,NA
"for instance, light sensors to turn off outside lights during the daytime, infared sensors to detect ",NA,NA
"when people are in a room, audio sensors to detect unusual noises, and contact sensors to detect ",NA,NA
"window openings (as by a burglar). Sensors permit flexible, unprogrammed action, like sounding a ",NA,NA
"burglar alarm in the master bedroom only if someone is there, or turning off appliances when they ",NA,NA
seem to have been left on accidentally and no one is in the room anymore. Priorities could be ,NA,NA
"established, so routine activities won't be allowed when sensors say a fire is progress. Assume the ",NA,NA
rule-based system is invoked repeatedly to check for new conditions. ,NA,NA
"(a) Which is better for this problem, backward chaining or forward chaining? Why? ",NA,NA
"(b) Is caching a good idea? Why? If so, how would it work? ",NA,NA
"(c) Are virtual facts a good idea? Why? If so, how would it work? ",NA,NA
"(d) Is rule partitioning a good idea? Why? If so, how would it work? ",NA,NA
"(e) Are decision lattices a good idea? Why? If so, how would they work? ",NA,NA
"(f) Are and-or-not lattices implemented on integrated circuits a good idea? Why? If so, how would ",NA,NA
they work? ,NA,NA
6-13. On the popular fictitious television show ,NA,NA
The Citizenry's Courtroom,NA,NA
", Judge Wimpner hears ",NA,NA
small-claims cases and makes monetary awards of varying amounts to the plaintiff. But the award is ,NA,NA
"misleading because the plaintiff and defendant are also paid for their appearance on the program, as one ",NA,NA
will discover on reading the small print of a disclaimer flashed on the screen for a second during the ,NA,NA
closing credits. The plaintiff is given 25 dollars plus the amount of the award plus half of a pool. The ,NA,NA
defendant is given 25 dollars plus the other half of the pool. The pool is zero if the amount of the award is ,NA,NA
"500 dollars or more, otherwise the difference between 500 dollars and the amount of the award. ",NA,NA
(a) Suppose the award amount is represented in Prolog as a fact with predicate name ,NA,NA
award,NA,NA
 and one ,NA,NA
argument representing the amount of the award in dollars. Write three Prolog rules representing the stated ,NA,NA
"calculations necessary for the plaintiff's amount, the defendant's amount, and the pool amount. Don't ",NA,NA
simplify; represent exactly what was stated. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (22 of 24) [23/04/2002 17:38:50],NA
"(b) Now ""compile"" the three preceding rules into two rules for the plaintiff amount and the defendant ",NA,NA
amount. Refer to the award amount only once in each rule. ,NA,NA
(c) Discuss what is needed to do this compilation for any set of rules involving arithmetic. Will a few ,NA,NA
"simple tricks do it, or is a large rule-based expert system of its own necessary? ",NA,NA
(d) What are the disadvantages of this form of compilation? ,NA,NA
(e) Compare and contrast this kind of compilation with and-or-not lattices. ,NA,NA
6-14. (E) ,NA,NA
Occam's Razor,NA,NA
 is the principle that when several alternative explanations are possible for ,NA,NA
"something, you should pick the simplest one. Suppose we try to apply Occam's Razor to a rule-based ",NA,NA
system in which the left sides of rules represent explanations of phenomena. ,NA,NA
(a) Which of the terms in Figure 6-1 best describes Occam's Razor? ,NA,NA
(b) Why would it be very difficult to apply Occam's Razor to a practical problem? ,NA,NA
6-15. (E) Compare and contrast the control structures discussed in this chapter with control of activities ,NA,NA
(by directive) in bureaucracies. ,NA,NA
"6-16. (P) Write a Prolog program to drive a car. Assume the following sensor facts are known to you, as ",NA,NA
"""data"": ",NA,NA
S1: you are traveling below the speed limit ,NA,NA
S2: you are traveling at the speed limit ,NA,NA
S3: you are traveling above the speed limit ,NA,NA
S4: you are on a two-lane road ,NA,NA
S5: you are on a four-lane road ,NA,NA
S6: you see an intersection coming up ,NA,NA
S7: a car is less than 100 meters in front of you ,NA,NA
S8: the road changes from two-lane to four-lane shortly S9: ,NA,NA
the road will change from four-lane to two-lane shortly S10: ,NA,NA
the brake lights of the car in front of you are on S11: you ,NA,NA
are getting closer to the car in front of you ,NA,NA
S12: you are passing another car going in the same direction,NA,NA
Assume the only actions are ,NA,NA
A1: speed up ,NA,NA
A2: slow down,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap6.html (23 of 24) [23/04/2002 17:38:50],NA
A3: maintain speed,NA,NA
A4: pass a car in front of you (or keep passing one you're passing),NA,NA
Here are examples of what you want the program to do. (These are not good rules--they're too specific.) ,NA,NA
"S2,S4,S6: slow down (A2)",NA,NA
"S2,S5,S8,S10: slow down (A2)",NA,NA
"S1,S5,S11: pass (A4)",NA,NA
"S1,S5: speed up (A1)",NA,NA
"S3,S4,S7: slow down (A2)",NA,NA
Write a Prolog program that decides what to do for every possible combination of the sensor facts. (Since ,NA,NA
"there are 12 kinds, you must handle |2 sup 12|, or 4096 different situations). Assume your program is ",NA,NA
"called every second to decide what to do that second. Choose a good control structure, and discuss ",NA,NA
(justify) your ordering of rules. Try to drive safely. ,NA,NA
"6-17. (E) Sometimes the ideas of science fiction writers seem pretty wild, but sometimes the ideas that ",NA,NA
seem wild really aren't when you think about them a bit. ,NA,NA
(a) In ,NA,NA
Camp Concentration,NA,NA
" by Thomas Disch (1968), it's suggested that a disease that rearranges nerve ",NA,NA
"patterns in the human brain could cause people to become a lot smarter, more able to reason and make ",NA,NA
inferences. Why is this not reasonable based on the assumption that people reason using the methods of ,NA,NA
this chapter? Suggest a small change to ideas from this chapter that would permit this phenomenon. ,NA,NA
(b) In ,NA,NA
Brain Wave,NA,NA
" by Poul Anderson (l954), it's suggested that a small increase in speed of the nerve ",NA,NA
impulses in the human brain could lead to a much larger increase in the speed at which humans reason ,NA,NA
and make inferences. Why is this not reasonable based on the assumption that people reason using the ,NA,NA
methods of this chapter? Give a small change to ideas from this chapter that permit this phenomenon. ,NA,NA
Go to book index,NA,NA
Implementation of rule-based systems ,NA,NA
Let's examine how different control structures for rule-based systems can be implemented in Prolog. We'll ,NA,NA
"cover backward chaining, rule-cycle hybrid chaining, forward chaining, input and output routines, meta-rules, ",NA,NA
and decision lattices. This will mean a lot of details; the last section of this chapter brings together the key ,NA,NA
Prolog code. ,NA,NA
Implementing backward chaining ,NA,NA
"Though Prolog is designed for backward chaining, there are many details for an implementer of a backward-",NA,NA
"chaining rule-based system to worry about when using Prolog, especially when the rule-based system is large. ",NA,NA
The traffic lights program in Section 4.11 was simple because traffic laws are ,NA,NA
supposed,NA,NA
" to be simple, so even ",NA,NA
people unenlightened enough never to have taken an artificial intelligence course can understand them. Many ,NA,NA
"rule-based expert systems can't be so nice, like those that diagnose and fix hard problems. Such rule-based ",NA,NA
systems are often called ,NA,NA
expert systems,NA,NA
", because they automate the role of human experts. We'll introduce some ",NA,NA
general-purpose programming aids for expert systems in this chapter. ,NA,NA
"The goal of most expert systems is to reach a diagnosis, which we'll assume is obtained by typing the query ",NA,NA
?- diagnosis(X).,NA,NA
"So what is X? It should describe a situation. We could connect words with underscores as before, but there's an ",NA,NA
alternative: we can put single quotation marks (apostrophes) around a string of words to force treatment of it as a ,NA,NA
"unit. That is, a ",NA,NA
character string,NA,NA
. An advantage of character strings is that they can start with capital letters and ,NA,NA
"contain periods and commas, while words can't. ",NA,NA
Here are some example diagnosis rules for an expert system: ,NA,NA
"diagnosis('fuse blown') :- doesnt_work, all_lights_out.",NA,NA
diagnosis('fuse blown') :- noise(pop).,NA,NA
"diagnosis('break in cord') :- doesnt_work, cord_frayed.",NA,NA
Of course we must define those right-side predicates. ,NA,NA
Implementing virtual facts in caching ,NA,NA
"One problem is those rules require advance entry of facts (often, many facts) so that rule right sides can work ",NA,NA
"properly. As we mentioned in the last chapter, virtual facts (facts demanded only when needed) are a simple ",NA,NA
improvement. A good way to get them is to define a function predicate ,NA,NA
ask,NA,NA
 of two bound arguments. The first ,NA,NA
"argument is an input, a string containing question text to be typed out on the terminal, and the second argument ",NA,NA
"is an output, a variable to be bound to the question's answer that the user types. ",NA,NA
"ask(Q,A) :- write(Q), write('?'), read(A), nl.",NA,NA
Here ,NA,NA
write,NA,NA
", ",NA,NA
read,NA,NA
", and ",NA,NA
nl,NA,NA
 are Prolog predicates built-in in most implementations (see Appendix D); ,NA,NA
write,NA,NA
 prints ,NA,NA
"its argument on the terminal, ",NA,NA
read,NA,NA
 reads something typed by the user and binds that something to the variable ,NA,NA
that is the ,NA,NA
read,NA,NA
"'s argument, and ",NA,NA
nl,NA,NA
 sends a carriage return to the terminal. ,NA,NA
Now we never want to ask a user the same question twice; we should cache answers so we can reuse them. It's ,NA,NA
easy to add this feature to the ,NA,NA
ask,NA,NA
 predicate. We just use the ,NA,NA
asserta,NA,NA
" built-in predicate introduced in Section 6.1, ",NA,NA
"which takes a fact as argument and adds it to the Prolog database. Using it, conclusions can be added to the ",NA,NA
database as they are discovered. We can stick the ,NA,NA
asserta,NA,NA
 at the end of the definition of the ,NA,NA
ask,NA,NA
 predicate: ,NA,NA
"ask(Q,A) :- write(Q), write('?'), read(A), nl, asserta(ask(Q,A)).",NA,NA
"Then if the same question is asked again, the fact will be used to answer it instead of this rule. This works ",NA,NA
because facts put in the database with ,NA,NA
asserta,NA,NA
 are put in front of all other facts and rules with the same first ,NA,NA
predicate name. Here's an example of the use of ,NA,NA
ask,NA,NA
: ,NA,NA
"diagnosis('fuse blown') :- ask('Does the device work at all',no),",NA,NA
" ask(Are the lights in the house off',yes).",NA,NA
This says to diagnose that the fuse is blown if (1) the user answers ,NA,NA
no,NA,NA
 when asked whether the device works at ,NA,NA
"all, and (2) the user answers ",NA,NA
yes,NA,NA
 when asked whether all the lights in the house are off. ,NA,NA
"You should carefully phrase the questions to be issued by a rule-based system. In particular, avoid pronouns and ",NA,NA
"other indirect references to things, since rules and questions may be invoked in hard-to-predict orders. Generally, ",NA,NA
"though there are exceptions, phrase questions so a ",NA,NA
yes,NA,NA
" answer means unusual things are going on, while a ",NA,NA
no,NA,NA
 ,NA,NA
"means things are normal. For instance, after ""Are the lights in the house off?"", don't ask ""Is the fuse OK?"" but ""Is ",NA,NA
"the fuse blown?"". And be consistent in phrasing questions. After that question ""Are the lights in the house off?"", ",NA,NA
"ask ""Does the fuse look blown?"" in preference to than ""The fuse looks blown doesn't it?"", to maintain the same ",NA,NA
verb-noun-adjective order. ,NA,NA
Input coding ,NA,NA
"We could implement a big expert system this way, with diagnosis rules having ",NA,NA
ask,NA,NA
 predicates on their right ,NA,NA
sides. But this can require unnecessary code repetition. So two important coding tricks are used in large rule-,NA,NA
based systems: coding of input (answers) and coding of output (questions and diagnoses). ,NA,NA
Input coding groups user answers into categories. An important case is questions with only ,NA,NA
yes,NA,NA
 or ,NA,NA
no,NA,NA
 answers; ,NA,NA
expert systems often to rely on them for simplicity. We can define two new predicates ,NA,NA
affirmative,NA,NA
 and ,NA,NA
negative,NA,NA
", which say whether a word the user typed is a positive or a negative answer respectively: ",NA,NA
affirmative(yes).,NA,NA
affirmative(y).,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (2 of 36) [23/04/2002 17:38:55],NA
affirmative(ye).,NA,NA
affirmative(right). ,NA,NA
affirmative(ok).,NA,NA
affirmative(uhhuh). ,NA,NA
negative(no).,NA,NA
negative(n).,NA,NA
negative(not).,NA,NA
negative(never).,NA,NA
negative(impossible). ,NA,NA
negative(haha).,NA,NA
Then we can define a predicate ,NA,NA
askif,NA,NA
 of one input argument. It will be just like ,NA,NA
ask,NA,NA
 except it will have only one ,NA,NA
"argument, the question, and it will succeed if that question is answered affirmatively and fail if the question is ",NA,NA
"answered negatively. We can also fix it so that if an answer is neither positive nor negative (in other words, it is ",NA,NA
"unclear), we will complain and ask for another answer. ",NA,NA
"askif(Q) :- ask(Q,A), positive_answer(A).",NA,NA
positive_answer(A) :- affirmative(A).,NA,NA
"positive_answer(Qcode,A) :- not(negative(A)), not(affirmative(A)), ",NA,NA
"write('Please answer yes or no.'), read(A2),",NA,NA
" retract(asked(Qcode,A)), asserta(asked(Qcode,A2)),",NA,NA
 affirmative(A2).,NA,NA
We can also define: ,NA,NA
askifnot(Q) :- not(askif(Q)).,NA,NA
which saves some parentheses. ,NA,NA
Users may not always understand a question. We can let them type a ,NA,NA
?,NA,NA
" instead of an answer, give them some ",NA,NA
"explanatory text, and provide them another chance to answer: ",NA,NA
"ask(Q,A) :- asked(Q,A).",NA,NA
"ask(Q,A) :- not(asked(Q,A)), write(Q), write('? '), read(A2),",NA,NA
" ask2(Q,A2,A).",NA,NA
"ask2(Q,'?',A) :- explain(Q), ask(Q,A).",NA,NA
"ask2(Q,A,A) :- not(A='?'), nl, asserta(asked(Q,A)).",NA,NA
where ,NA,NA
explain,NA,NA
 facts store explanatory text. Minor humanizing touches such as these can be immensely ,NA,NA
"important to user satisfaction, while imposing little on the programmer. ",NA,NA
Output coding ,NA,NA
"Another useful trick is to code questions, so we need not repeat their text at each mention in the rules. Codes for ",NA,NA
"questions also make rules easier to read, and help prevent mistakes because it's easy to err in typing a long ",NA,NA
"string of text (and with caching, every slightly different question is asked and cached separately). For this we ",NA,NA
can use a predicate ,NA,NA
questioncode,NA,NA
" of two arguments, a code word and a text string for the corresponding ",NA,NA
question. Here's an example from appliance diagnosis: ,NA,NA
"diagnosis('fuse blown') :- askif(device_dead), askif(lights_out). ",NA,NA
diagnosis('fuse blown') :- askif(hear_pop).,NA,NA
"diagnosis('break in cord') :- askif(device_dead),",NA,NA
 askif(cord_frayed).,NA,NA
"questioncode(device_dead,'Does the device refuse to do anything').",NA,NA
"questioncode(lights_out,",NA,NA
 'Do all the lights in the house seem to be off').,NA,NA
"questioncode(hear_pop,'Did you hear a sound like a pop').",NA,NA
"questioncode(cord_frayed,",NA,NA
 'Does the outer covering of the cord appear to be coming apart').,NA,NA
"To handle this, we must redefine ",NA,NA
ask,NA,NA
: ,NA,NA
"ask(Qcode,A) :- asked(Qcode,A).",NA,NA
"ask(Qcode,A) :- not(asked(Qcode,A)), questioncode(Qcode,Q),",NA,NA
 ,NA,NA
"write(Q), write('? '), read(A2), ask2(Q,Qcode,A2,A).",NA,NA
"ask2(Q,Qcode,'?',A) :- explain(Qcode), ask(Qcode,A).",NA,NA
"ask2(Q,Qcode,A,A) :- not(A='?'), asserta(asked(Qcode,A)).",NA,NA
A further refinement is to handle a class of related questions together. We can do this by giving arguments to ,NA,NA
"output codes, as for instance using ",NA,NA
hear(X),NA,NA
 to represent a question about hearing a sound ,NA,NA
X,NA,NA
. Then to make the ,NA,NA
"query we need string concatenation, something unfortunately not available in most Prolog dialects. But there is ",NA,NA
a simple shortcut to concatenation by writing a ,NA,NA
questioncode,NA,NA
" rule instead of a fact, that types extra words ",NA,NA
before succeeding: ,NA,NA
"questioncode(hear(X),X) :- write('Did you hear a sound like a ').",NA,NA
So to ask if the user heard a pop sound you use: ,NA,NA
askif(hear(pop)).,NA,NA
which prints on the terminal as: ,NA,NA
Did you hear a sound like a pop ?,NA,NA
"Yet another coding trick is to code diagnoses. This isn't as useful as question coding, but helps when diagnoses ",NA,NA
are provable in many different ways. Diagnosis coding requires a new top-level predicate that users must query ,NA,NA
instead of ,NA,NA
diagnosis,NA,NA
", as: ",NA,NA
"coded_diagnosis(D) :- diagnosis(X), diagnosis_code(X,D).",NA,NA
"For instance, we could use: ",NA,NA
"diagnosis(fuse) :- ask('Does the device work at all',no),",NA,NA
" ask(Are the lights in the house off',yes).",NA,NA
"diagnosis_code(fuse,'Fuse blown').",NA,NA
Then we could get this behavior: ,NA,NA
?- coded_diagnosis(X).,NA,NA
Does the device work at all? no.,NA,NA
Are the lights in the house off? yes.,NA,NA
X=Fuse blown,NA,NA
Intermediate predicates ,NA,NA
"Building expert systems is straightforward when there are ten to a hundred rules, each with one to three ",NA,NA
"expressions on the right side. But it can get confusing when, as in a typical expert system today, there are ",NA,NA
thousands of rules averaging ten expressions per right side. It just gets too difficult to keep track of all the ,NA,NA
"symbols used, and to determine everything necessary for each rule. The solution is to frequently use intermediate ",NA,NA
"predicates, predicates that occur on both the left and right sides of rules. Intermediate predicates can represent ",NA,NA
important simplifying generalizations about groups of facts. Viewing expert-system predicates as a hierarchy ,NA,NA
"with diagnoses or final conclusions at the top and asked questions at the bottom, intermediate predicates are ",NA,NA
everything in between. Much of the intelligence and sophistication of expert systems can come from a good ,NA,NA
choice of intermediate predicates to reduce redundancy and simplify rules. ,NA,NA
A useful intermediate predicate with appliance diagnosis is ,NA,NA
power_problem,NA,NA
", a predicate that is true if the ",NA,NA
appliance is not getting any electricity for its innards. It's useful because appropriate diagnoses when it is true are ,NA,NA
quite different from those when it is false: a non-power problem must be in the device itself and can't be in the ,NA,NA
cord or external fuse. So ,NA,NA
power_problem,NA,NA
" can go into many rules, typically early in the right side of the rule to ",NA,NA
filter out inappropriate rule use. But ,NA,NA
power_problem,NA,NA
" clearly is an intermediate predicate, not a fact we can ",NA,NA
"establish from a single question, because it has many different symptoms. And some symptoms are very strong, ",NA,NA
"as when all the lights in the house went off when you have tried to turn on the device, or when the device ",NA,NA
stopped working when you moved its frayed cord slightly. ,NA,NA
"Generally speaking, intermediate predicates are needed for any important phenomena that aren't diagnoses. ",NA,NA
Here are some more ideas for intermediate predicates in appliance diagnosis: ,NA,NA
--whether the problem is mechanical; ,NA,NA
--whether the problem is in a heating element; ,NA,NA
--whether the appliance has had similar problems before; ,NA,NA
--whether you can improve things by adjusting the controls or buttons; ,NA,NA
--whether danger of electrocution is present; ,NA,NA
--whether anything unusual was done to the appliance lately (like being dropped or having liquids ,NA,NA
spilled on it); ,NA,NA
--how much troubleshooting expertise the user has (note that intermediate predicates can have ,NA,NA
arguments). ,NA,NA
Intermediate-predicate expressions won't be arguments to ,NA,NA
askif,NA,NA
"s, since they don't directly query a user. Caching ",NA,NA
"is a good idea with intermediate predicates, even more so than caching of query answers (as we did with the ",NA,NA
ask ,NA,NA
"predicate). A single intermediate-predicate fact can summarize many questions, and caching it saves having to ",NA,NA
"ask all those questions over again. Nevertheless, caching of intermediate-predicate conclusions should not ",NA,NA
"necessarily be automatic, as it only makes sense when a result might be reused. ",NA,NA
An example program ,NA,NA
Let's put together the ideas we've introduced in this chapter in a larger rule-based system for the diagnosis of ,NA,NA
"malfunctions in small household appliances. Figure 7-1 shows some of the terminology, and Figure 7-2 gives the ",NA,NA
"predicate hierarchy. We list rules in three groups: diagnosis (top-level) rules, intermediate predicate rules, and ",NA,NA
"question-decoding rules. To get a diagnosis from this program, query ",NA,NA
diagnosis(X),NA,NA
. Typing a semicolon will ,NA,NA
"then give you an alternative diagnosis, if any; and so on. So if several things are wrong with the appliance, the ",NA,NA
program will eventually find them all. ,NA,NA
/* Top-level diagnosis rules */ ,NA,NA
"diagnosis('fuse blown') :- power_problem, askif(lights_out).",NA,NA
"diagnosis('fuse blown') :- power_problem, askif(hear(pop)). ",NA,NA
"diagnosis('break in cord') :- power_problem, askif(cord_frayed).",NA,NA
"diagnosis('short in cord') :- diagnosis('fuse blown'),",NA,NA
 askif(cord_frayed).,NA,NA
"diagnosis('device not turned on') :- power_problem, ",NA,NA
"klutz_user, askif(has('an on-off switch or control')), ",NA,NA
askif(device_on).,NA,NA
"diagnosis('cord not in socket properly') :- power_problem,",NA,NA
" klutz_user, askif(just_plugged), askif(in_socket).",NA,NA
diagnosis('foreign matter caught on heating element') :-,NA,NA
" heating_element, not(power_problem), askif(smell_smoke).",NA,NA
diagnosis('appliance wet--dry it out and try again') :-,NA,NA
" power_problem, klutz_user, askif(liquids).",NA,NA
"diagnosis('controls adjusted improperly') :- klutz_user,",NA,NA
" askif(has('knobs, switches, or other controls')).",NA,NA
"diagnosis('kick it, then try it again') :- mechanical_problem.",NA,NA
diagnosis('throw it out and get a new one') :-,NA,NA
" not(power_problem), askif(hear('weird noise')).",NA,NA
diagnosis('throw it out and get a new one').,NA,NA
/* Definitions of intermediate predicates */ ,NA,NA
"power_problem :- askif(device_dead), askif(has(knobs)), ",NA,NA
askif(knobs_do_something).,NA,NA
"power_problem :- askif(device_dead), askif(smell_smoke). ",NA,NA
klutz_user :- askifnot(handyperson).,NA,NA
klutz_user :- askifnot(familiar_appliance).,NA,NA
"mechanical_problem :- askif(hear('weird noise')),",NA,NA
 askif(has('moving parts')).,NA,NA
heating_element :- askif(heats).,NA,NA
heating_element :- askif(powerful).,NA,NA
/* Question decoding */ ,NA,NA
"questioncode(device_dead,'Does the device refuse to do anything').",NA,NA
"questioncode(knobs_do_something,",NA,NA
 'Does changing the switch positions or turning ,NA,NA
the knobs change anything').,NA,NA
"questioncode(lights_out,",NA,NA
 'Do all the lights in the house seem to be off').,NA,NA
"questioncode(cord_frayed,",NA,NA
 'Does the outer covering of the cord appear to be coming apart'). ,NA,NA
"questioncode(handyperson,'Are you good at fixing things').",NA,NA
"questioncode(familiar_appliance,",NA,NA
 'Are you familiar with how this appliance works').,NA,NA
"questioncode(device_on,'Is the ON/OFF switch set to ON').",NA,NA
"questioncode(just_plugged,'Did you just plug the appliance in'). ",NA,NA
"questioncode(in_socket,'Is the cord firmly plugged into the socket'). ",NA,NA
"questioncode(smell_smoke,'Do you smell smoke').",NA,NA
"questioncode(liquids,",NA,NA
 'Have any liquids spilled on the appliance just now').,NA,NA
"questioncode(heats,'Does the appliance heat things').",NA,NA
"questioncode(powerful,'Does the appliance require a lot of power'). ",NA,NA
"questioncode(has(X),X) :- write('Does the appliance have').",NA,NA
"questioncode(hear(X),X) :- write('Did you hear a ').",NA,NA
Here we use variables inside question codes for questions about components and sounds heard. We also use a ,NA,NA
subdiagnosis,NA,NA
" ('fuse blown') as input to another diagnosis, a useful trick. ",NA,NA
Running the example program ,NA,NA
Here's an actual run of this program (which requires definitions of ,NA,NA
askif,NA,NA
 and other predicates given earlier in ,NA,NA
this chapter). Note the same diagnosis is repeated when there are different ways to prove it. ,NA,NA
?- diagnosis(X).,NA,NA
Does the device refuse to do anything? yes.,NA,NA
Do all the lights in the house seem to be off? no.,NA,NA
Does the appliance have knobs or switches? yes.,NA,NA
Does changing the switch positions or turning ,NA,NA
the knobs change anything? no.,NA,NA
Do you smell smoke? yes.,NA,NA
Does the appliance heat things? no.,NA,NA
Does the appliance require a lot of power? no. ,NA,NA
Did you hear a pop? yes.,NA,NA
X=Fuse ,NA,NA
blown; ,NA,NA
X=Fuse ,NA,NA
blown; ,NA,NA
X=Fuse ,NA,NA
blown; ,NA,NA
Are you good at fixing things? no.,NA,NA
Does the appliance have an on-off switch or control? yes. ,NA,NA
Is the ON/OFF switch set to ON? no.,NA,NA
X=Device not turned on;,NA,NA
Are you familiar with how this appliance works? no. ,NA,NA
X=Device not turned on; ,NA,NA
X=Device not turned on; ,NA,NA
X=Device not turned on; ,NA,NA
X=Device not turned on; ,NA,NA
X=Device not turned on;,NA,NA
Did you just plug the appliance in? yes.,NA,NA
Is the cord firmly plugged into the socket? no.,NA,NA
X=Cord not in socket properly; ,NA,NA
X=Cord not in socket properly; ,NA,NA
X=Cord not in socket properly; ,NA,NA
X=Cord not in socket properly; ,NA,NA
X=Cord not in socket properly; ,NA,NA
X=Cord not in socket properly;,NA,NA
Have any liquids spilled on the appliance just now? maybe. ,NA,NA
Please type yes or no. no.,NA,NA
X=Controls adjusted improperly;,NA,NA
X=Controls adjusted improperly;,NA,NA
Did you hear a weird noise? no.,NA,NA
X=Throw it out and get a new one;,NA,NA
no,NA,NA
?- halt.,NA,NA
Partitioned rule-based systems ,NA,NA
"Intermediate predicates group related rules together, but they are only a conceptual grouping, more a help to ",NA,NA
understanding and debugging programs. A stronger way of grouping is putting rules into partitions that can't ,NA,NA
"""see"" one another. This is easy to do with Prolog by putting rules in separate files and only loading the files you ",NA,NA
need into the database. Loading is done with the ,NA,NA
consult,NA,NA
" built-in predicate in Prolog, a predicate of one ",NA,NA
argument which is the name of the file to load. So if the rule ,NA,NA
"a :- b, c.",NA,NA
"is used for backward chaining, and we want whenever it succeeds for the file ""more"" to be loaded, we should ",NA,NA
rewrite it as ,NA,NA
"a :- b, c, consult(more).",NA,NA
"Like most built-in predicates, ",NA,NA
consult,NA,NA
 always fails on backtracking since there's only one way to load a file. ,NA,NA
"Often one partition is designated the ""starting"" partition, loaded automatically when the rule-based system ",NA,NA
begins. It then decides which other partitions to load and invoke. If a loaded partition later decides it's not ,NA,NA
"relevant (as when none of its rules fire), it can itself load another partition and start that one running. ",NA,NA
Implementing the rule-cycle hybrid ,NA,NA
"Prolog's features make backward chaining easy. But it's also a general-purpose programming language, and can ",NA,NA
implement quite different control structures. ,NA,NA
"First consider the rule-cycle hybrid of backward and forward chaining, easier to implement than pure forward ",NA,NA
"chaining and hence used in many simple expert systems. It can be done by writing each rule in a new form, a ",NA,NA
transformation of each backward chaining rule: ,NA,NA
"1. ""and"" a new ",NA,NA
asserta,NA,NA
" on the right end of the right side of the rule, whose argument is the left ",NA,NA
side of the rule; ,NA,NA
"2. ""and"" a new ",NA,NA
not,NA,NA
" on the left end of the right side of the rule, with the same argument; ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (9 of 36) [23/04/2002 17:38:55],NA
3. then replace the left side of the rule by ,NA,NA
r,NA,NA
 (first renaming any ,NA,NA
r,NA,NA
 predicates already in the rules). ,NA,NA
So these backward chaining rules: ,NA,NA
a :- b.,NA,NA
"c :- d, e, f.",NA,NA
become: ,NA,NA
"r :- not(a), b, asserta(a).",NA,NA
"r :- not(c), d, e, f, asserta(c).",NA,NA
And two sample rules from the appliance diagnosis program: ,NA,NA
"diagnosis('fuse blown') :- power_problem, askif(lights_out).",NA,NA
"power_problem :- askif(device_dead), askif(has(knobs)),",NA,NA
 askif(knobs_do_something).,NA,NA
become: ,NA,NA
"r :- not(diagnosis('fuse blown')), power_problem, askif(lights_out),",NA,NA
 ,NA,NA
asserta(diagnosis('fuse blown')).,NA,NA
"r :- not(power_problem), askif(device_dead), askif(has(knobs)),",NA,NA
" askif(knobs_do_something), asserta(power_problem).",NA,NA
(We'll discuss later how to convert automatically.) So we replace our old rules with new rules whose only effect ,NA,NA
"is caching of particular conclusions. Note that these new rules never call on other rules, even if there are ",NA,NA
"intermediate predicates, because ",NA,NA
r,NA,NA
 is the only left side (since we made sure the predicate ,NA,NA
r,NA,NA
 doesn't occur in the ,NA,NA
rule-based system). We'll assume for now that no predicate expressions in the original rules contain ,NA,NA
not,NA,NA
"s, since ",NA,NA
"they introduce complications. If we really need negatives, we can define fact predicates that stand for the ",NA,NA
opposite of other fact predicates. ,NA,NA
"Now we must cycle through the rules; that is, consider each rule in order, and go back to the first when we ",NA,NA
"finish the last. Within each pass, we can force the Prolog interpreter to repeatedly backtrack to a query of ",NA,NA
r,NA,NA
. A ,NA,NA
simple way is ,NA,NA
"?- r, 1=2.",NA,NA
Since the ,NA,NA
=,NA,NA
" can never be true, the interpreter will keep trying ",NA,NA
r,NA,NA
" rules, regardless of whether they succeed or fail. ",NA,NA
Eventually it will run out of all ,NA,NA
r,NA,NA
" rules and fail. Actually, there's a built-in Prolog predicate called ",NA,NA
fail,NA,NA
 that has ,NA,NA
exactly the same effect as ,NA,NA
1=2,NA,NA
", so we can say equivalently ",NA,NA
"?- r, fail.",NA,NA
"To give us a handle on this code, let's give it a name: ",NA,NA
"one_cycle :- r, fail.",NA,NA
"To get the Prolog interpreter to repeat indefinitely a cycle through the rules, we might think that we could do the ",NA,NA
same ,NA,NA
fail,NA,NA
" trick, like ",NA,NA
"hybrid :- one_cycle, fail.",NA,NA
But this won't work because ,NA,NA
one_cycle,NA,NA
 won't ever return to the ,NA,NA
top,NA,NA
 of the list of rules. And ,NA,NA
one_cycle,NA,NA
 itself ,NA,NA
"never succeeds, so the ",NA,NA
fail,NA,NA
 is useless. We could try ,NA,NA
"hybrid :- not(one_cycle), fail.",NA,NA
which answers the second objection but not the first: we need each call to ,NA,NA
one_cycle,NA,NA
 to be a fresh call. That ,NA,NA
suggests recursion: ,NA,NA
hybrid :- done.,NA,NA
"hybrid :- not(one_cycle), hybrid.",NA,NA
The ,NA,NA
done,NA,NA
 is a stopping condition that must be defined by the builder of the rule-based system. For diagnosis ,NA,NA
"expert systems, it could be defined as ",NA,NA
done :- diagnosis(X).,NA,NA
which says to stop whenever some diagnosis is proved. ,NA,NA
The preceding definition of ,NA,NA
hybrid,NA,NA
" only checks once per cycle whether it is done. To stop sooner, we could put ",NA,NA
the check inside ,NA,NA
one_cycle,NA,NA
 like this: ,NA,NA
hybrid :- done.,NA,NA
"hybrid :- not(one_cycle), hybrid.",NA,NA
"one_cycle :- r, done.",NA,NA
But this requires more calls to ,NA,NA
done,NA,NA
", not a good idea if ",NA,NA
done,NA,NA
 is a complicated calculation. ,NA,NA
Note: this approach can handle ,NA,NA
not,NA,NA
"s in rules, though differently from the algorithm in Section 6.4 since ",NA,NA
not,NA,NA
s ,NA,NA
"will be evaluated on every cycle. But as with the algorithm, any ",NA,NA
not,NA,NA
 must occur before any rule with the ,NA,NA
argument to the ,NA,NA
not,NA,NA
" as its left side, or we'll get wrong answers. ",NA,NA
Implementing pure forward chaining (*) ,NA,NA
Pure forward chaining requires yet another rule form. (See a Section 7.14 for how to rewrite rules automatically ,NA,NA
"in this form.) Since pure forward chaining repeatedly finds and ""crosses out"" expressions on the right sides of ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (11 of 36) [23/04/2002 17:38:55],NA
"rules, it would help to express rule right sides as lists, for then we can use our ",NA,NA
member,NA,NA
 and ,NA,NA
delete,NA,NA
 list-processing ,NA,NA
"predicates from Chapter 5. We can do this by making rules a kind of fact, say using a ",NA,NA
rule,NA,NA
 predicate name. The ,NA,NA
first argument to ,NA,NA
rule,NA,NA
" can be the left side of the original rule, and the second argument the list of predicate ",NA,NA
"expressions ""and""ed on the right side. So these rules ",NA,NA
a :- b.,NA,NA
"c :- d, e, f.",NA,NA
"g(X) :- h(X,Y), not(f(Y)).",NA,NA
become ,NA,NA
"rule(a,[b]).",NA,NA
"rule(c,[d,e,f]).",NA,NA
"rule(g(X),[h(X,Y),not(f(Y))]).",NA,NA
and the two sample rules from the appliance diagnosis program ,NA,NA
"diagnosis('fuse blown') :- power_problem, askif(lights_out).",NA,NA
"power_problem :- askif(device_dead), askif(has(knobs)),",NA,NA
 askif(knobs_do_something).,NA,NA
become ,NA,NA
"rule(diagnosis('fuse blown'),[power_problem,askif(lights_out)]).",NA,NA
"rule(power_problem,",NA,NA
" [askif(device_dead),askif(has(knobs)),askif(knobs_do_something)]).",NA,NA
"For now, we'll assume that the rules don't contain ",NA,NA
not,NA,NA
s. ,NA,NA
"We also must represent facts. Pure forward chaining requires that we identify all facts, distinguishing them from ",NA,NA
rules. We can do this by making each fact an argument to a predicate named ,NA,NA
fact,NA,NA
", of one argument. Then to bind ",NA,NA
F,NA,NA
" to every fact in turn, we query ",NA,NA
"?- fact(F), done.",NA,NA
which will backtrack repeatedly into ,NA,NA
fact,NA,NA
. For every fact ,NA,NA
F,NA,NA
", we must find the rules whose right sides can match ",NA,NA
"it, to derive new rules and possibly new facts. This suggests: ",NA,NA
"forward :- fact(F), not(pursuit(F)), done.",NA,NA
"Unfortunately, we can't really implement ""focus-of-attention"" forward chaining this way, since we can't insert ",NA,NA
"new facts just after the last fact we selected, only at the beginning (with ",NA,NA
asserta,NA,NA
) and end (with ,NA,NA
assertz,NA,NA
) of the ,NA,NA
"database. To prevent fact reuse, we can delete facts once pursued. But deleted facts are still important to us ",NA,NA
(obtaining facts is the whole point of forward chaining) so we'll copy them into ,NA,NA
usedfact,NA,NA
 facts before we delete ,NA,NA
them. The revised code: ,NA,NA
forward :- done.,NA,NA
"forward :- fact(F), not(pursuit(F)), assertz(usedfact(F)),",NA,NA
" retract(fact(F)), forward.",NA,NA
(Remember from Section 6.1 that ,NA,NA
retract,NA,NA
" removes a fact from the database.) Then when we're done, all the ",NA,NA
things we learned plus all the starting facts are in the database as arguments to the ,NA,NA
fact,NA,NA
 and ,NA,NA
usedfact,NA,NA
 predicates. ,NA,NA
The ,NA,NA
pursuit,NA,NA
 predicate can cycle through the rules like ,NA,NA
one_cycle,NA,NA
 did in the hybrid implementation: ,NA,NA
"pursuit(F) :- rule(L,R), rule_pursuit(F,L,R), fail.",NA,NA
For ,NA,NA
rule_pursuit,NA,NA
" we must search through the right side of a rule, deleting anything that matches the fact ",NA,NA
F,NA,NA
; we ,NA,NA
can use the ,NA,NA
member,NA,NA
 and ,NA,NA
delete,NA,NA
" predicates of Sections 5.5 and 5.6 respectively. As you may dimly recall, ",NA,NA
member,NA,NA
" checks whether an item is a member of a list, and ",NA,NA
delete,NA,NA
 removes all occurrences of an item from a list. ,NA,NA
We need them both because ,NA,NA
delete,NA,NA
" always succeeds, and we'd like to fail when a match doesn't occur in the list. ",NA,NA
So (Figure 7-3): ,NA,NA
forward :- done.,NA,NA
"forward :- fact(F), not(pursuit(F)), assertz(usedfact(F)),",NA,NA
" retract(fact(F)), forward.",NA,NA
"pursuit(F) :- rule(L,R), rule_pursuit(F,L,R), fail.",NA,NA
"rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew),",NA,NA
" new_rule(L,Rnew).",NA,NA
"new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).",NA,NA
"new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).",NA,NA
The two ,NA,NA
new_rule,NA,NA
" lines say that when you've deleted everything on the right side of a rule, the left side is a new ",NA,NA
"fact; otherwise just write a new, shorter and simpler rule. And here again are ",NA,NA
member,NA,NA
 and ,NA,NA
delete,NA,NA
: ,NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- not(X=Y), delete(X,L,M).",NA,NA
"As with the rule-cycle hybrid, you must define ",NA,NA
done,NA,NA
 appropriately. If you want to make sure that all possible ,NA,NA
"conclusions are reached, use ",NA,NA
done :- not(fact(X)).,NA,NA
which forces forward chaining to continue until there are no more ,NA,NA
fact,NA,NA
" facts, in which case everything learned ",NA,NA
(as well as the initial facts) is a ,NA,NA
usedfact,NA,NA
. (Note this rule violates our advice in Section 3.6 to avoid ,NA,NA
not,NA,NA
s whose ,NA,NA
variables aren't bound. Here we want to stop if there's any unexamined fact ,NA,NA
X,NA,NA
" remaining, a kind of existential ",NA,NA
"quantification, so it makes sense. A universally quantified negation is equivalent to an existentially quantified ",NA,NA
"unnegation; see Appendix A.) Alternatively, ",NA,NA
done,NA,NA
" can be defined to mean that one of a set of ""goal"" facts have ",NA,NA
been proved. ,NA,NA
The ,NA,NA
asserta,NA,NA
 in the first ,NA,NA
new_rule,NA,NA
 rule is important because it forces focus-of-attention handling of new facts. ,NA,NA
"That is, the last fact found will be the next fact pursued, like a stack data structure, because of the recursion. As ",NA,NA
"we pointed out in the last chapter, the focus-of-attention approach often reaches interesting conclusions fast. If ",NA,NA
we change ,NA,NA
asserta,NA,NA
 to ,NA,NA
assertz,NA,NA
", we get a queue instead of a stack, with new facts pursued only after old facts. ",NA,NA
"Amazingly, the program works just fine when rules contain variables. This is because the basis step (first line) ",NA,NA
in the ,NA,NA
member,NA,NA
" predicate definition can bind variables to succeed, and when it does those variables keep the ",NA,NA
"same bindings through the rest of the rule. If there is more than one matching of a fact to a rule, the program ",NA,NA
will find each by backtracking to ,NA,NA
member,NA,NA
". For instance, the rule ",NA,NA
"rule(a(X,Y),[b(X,Y),b(Y,X),b(X,X)]).",NA,NA
can match the fact ,NA,NA
"b(tom,dick)",NA,NA
" to either the first or second predicate expression on its right side, giving two ",NA,NA
new rules: ,NA,NA
"rule(a(tom,dick),[b(dick,tom),b(tom,tom)]).",NA,NA
"rule(a(dick,tom),[b(dick,tom),b(dick,dick)]).",NA,NA
"When forward chaining with the preceding program is slow, a simple change can often speed things up. That is ",NA,NA
"to delete the old rule when a new rule is formed. This speeds things up because the sum of the number of rules, ",NA,NA
the number of ,NA,NA
fact,NA,NA
"s, and the number of ",NA,NA
oldfact,NA,NA
"s stays constant instead of always increasing. To do this, we need ",NA,NA
only add a single expression to the ,NA,NA
rule_pursuit,NA,NA
 rule: ,NA,NA
"rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew),",NA,NA
" retract(rule(L,R)), new_rule(L,Rnew).",NA,NA
"We can only do this safely for rule-based systems representable as and-or-not lattices, where there are either no ",NA,NA
variables or only variables that can take a single binding. Otherwise deletion will throw away still-possibly-,NA,NA
"useful rules, but this may not bother us if the odds are small they're still useful. ",NA,NA
"Forward chaining with ""not""s (*) ",NA,NA
"As with hybrid chaining, we can avoid rules containing ",NA,NA
not,NA,NA
"s by substituting ""unfact"" predicate names ",NA,NA
representing the opposite of other predicate names. Or we can require that arguments to ,NA,NA
not,NA,NA
s never be ,NA,NA
matchable to anything appearing on the left side of a rule (DeMorgan's Laws can get the rules into this form; ,NA,NA
see Appendix A). Then we rewrite the top level of the program to handle ,NA,NA
not,NA,NA
s after it's done everything else: ,NA,NA
"full_forward :- forward, handle_nots.",NA,NA
"handle_nots :- rule(L,R), member(not(X),R), not(usedfact(X)),",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (14 of 36) [23/04/2002 17:38:55],NA
" not(fact(X)), delete(not(X),R2), new_rule(L,R2), handle_nots. ",NA,NA
handle_nots :- forward.,NA,NA
"This is not quite the algorithm in Section 6.2, but it's close. ",NA,NA
"General iteration with ""forall"" and ""doall"" (*) ",NA,NA
"The iteration method of the rule-cycle hybrid and forward chaining programs can be generalized. First, suppose ",NA,NA
we want to check whether some predicate expression ,NA,NA
Q,NA,NA
 succeeds for all possible variable values that satisfy ,NA,NA
some other predicate expression ,NA,NA
P,NA,NA
"; that is, we want to check ",NA,NA
universal quantification,NA,NA
 of ,NA,NA
Q,NA,NA
 with respect to ,NA,NA
P,NA,NA
. We ,NA,NA
can do this by requiring that there be no way for ,NA,NA
Q,NA,NA
 to fail when ,NA,NA
P,NA,NA
" has succeeded previously, taking into account ",NA,NA
any bindings. We can use the built-in ,NA,NA
call,NA,NA
" predicate of Prolog, which queries a predicate expression given as ",NA,NA
argument: ,NA,NA
"forall(P,Q) :- not(somefailure(P,Q)).",NA,NA
"somefailure(P,Q) :- call(P), not(call(Q)).",NA,NA
"As an example, assume this database: ",NA,NA
a(1).,NA,NA
a(2).,NA,NA
b(1).,NA,NA
b(2).,NA,NA
c(1).,NA,NA
c(2).,NA,NA
c(3).,NA,NA
"d(1,5). ",NA,NA
"d(5,1).",NA,NA
Here are some example queries and their results: ,NA,NA
"?- forall(a(X),b(X)).",NA,NA
yes ,NA,NA
"?- forall(b(X),c(X)).",NA,NA
yes ,NA,NA
"?- forall(c(X),b(X)).",NA,NA
no ,NA,NA
"?- forall(c(X),d(X,Y)).",NA,NA
no ,NA,NA
"?- forall(d(X,Y),d(Y,X)).",NA,NA
yes,NA,NA
"Similarly, we can define a predicate that repeatedly backtracks into predicate expression ",NA,NA
P,NA,NA
 until ,NA,NA
P,NA,NA
 fails: ,NA,NA
doall(P) :- not(alltried(P)). ,NA,NA
"alltried(P) :- call(P), fail.",NA,NA
Assume this database: ,NA,NA
a(1).,NA,NA
a(2).,NA,NA
a(3).,NA,NA
"u(X) :- a(X), write(X).",NA,NA
"v(X) :- u(X), Y is X*X, write(Y), nl.",NA,NA
Then here are two examples: ,NA,NA
?- doall(u(X)).,NA,NA
123 ,NA,NA
yes ,NA,NA
?- doall(v(X)).,NA,NA
1 ,NA,NA
4 ,NA,NA
9 ,NA,NA
yes,NA,NA
"(Remember, ",NA,NA
write,NA,NA
" prints its argument on the terminal, and ",NA,NA
nl,NA,NA
 prints a carriage return.) ,NA,NA
This ,NA,NA
doall,NA,NA
 is just what the forward chaining program accomplishes in the ,NA,NA
pursuit,NA,NA
 predicate. So we can rewrite ,NA,NA
the first four lines of the forward chaining program as ,NA,NA
forward :- done.,NA,NA
"forward :- fact(F), doall(pursuit(F)), assertz(usedfact(F)),",NA,NA
" retract(fact(F)), forward.",NA,NA
"pursuit(F) :- rule(L,R), rule_pursuit(F,L,R).",NA,NA
instead of ,NA,NA
forward :- done.,NA,NA
"forward :- fact(F), not(pursuit(F)), assertz(usedfact(F)),",NA,NA
" retract(fact(F)), forward.",NA,NA
"pursuit(F) :- rule(L,R), rule_pursuit(F,L,R), fail.",NA,NA
And in the rule-cycle hybrid ,NA,NA
hybrid :- done.,NA,NA
"hybrid :- doall(r), hybrid.",NA,NA
can be used instead of ,NA,NA
hybrid :- done.,NA,NA
"hybrid :- not(one_cycle), hybrid.",NA,NA
"one_cycle :- r, fail.",NA,NA
And the code for handling ,NA,NA
not,NA,NA
s in forward chaining given in Section 7.11 can be improved to ,NA,NA
"full_forward :- forward, doall(handle_not), forward.",NA,NA
"handle_not :- rule(L,R), member(not(X),R), not(usedfact(X)),",NA,NA
" not(fact(X)), delete(not(X),R2), new_rule(L,R2).",NA,NA
instead of ,NA,NA
"full_forward :- forward, handle_nots.",NA,NA
"handle_nots :- rule(L,R), member(not(X),R), not(usedfact(X)),",NA,NA
" not(fact(X)), delete(not(X),R2), new_rule(L,R2), handle_nots.",NA,NA
handle_nots :- forward.,NA,NA
The changes improve program readability. ,NA,NA
Input and output of forward chaining (*) ,NA,NA
Fact pursuit is only part of what we need for forward chaining. We must also handle input and output differently ,NA,NA
than with backward chaining. Backward chaining asked the user a question whenever an answer was relevant to ,NA,NA
some conclusion under study. This can mean that many irrelevant questions are asked before backward chaining ,NA,NA
"hits on the right conclusions to try to prove. Forward chaining, on the other hand, focuses on a set of facts. The ",NA,NA
facts must get into the database somehow to start things off. ,NA,NA
"Two approaches are possible. First, give a ",NA,NA
questionnaire,NA,NA
", a fixed set of questions to a user presented one at a ",NA,NA
"time, and code answers into facts. Fixed questionnaires are common in the early part presented one at a time of ",NA,NA
"medical diagnosis, when a doctor tries to get a broad picture of the health of a patient before moving on to ",NA,NA
"specifics. Second (especially if most possible facts don't have arguments), give a ",NA,NA
menu,NA,NA
", a set of questions ",NA,NA
"presented simultaneously to the user, and ask which questions should be answered ",NA,NA
yes,NA,NA
. For diagnosis ,NA,NA
"applications, the menu can contain common symptoms. Menus are good when there are lots of possible facts, ",NA,NA
few of which are simultaneously relevant to a case. ,NA,NA
Both are straightforward to implement in Prolog. Questionnaires can be done by a fixed sequence of calls to the ,NA,NA
askif,NA,NA
 predicate defined in Section 7.3. The answer to each question will cause the assertion of ,NA,NA
asked,NA,NA
 and ,NA,NA
fact ,NA,NA
facts. Menus can be implemented by an ,NA,NA
ask_which,NA,NA
 predicate | REFERENCE 1|: .FS | REFERENCE 1| It's ,NA,NA
interesting to compare this program to the forward-chaining program in Section 7.10: this represents more a Lisp ,NA,NA
"style of programming, with recursion through lists and no expectation of backtracking. The forward-chaining ",NA,NA
"program represents more a Prolog style of programming, with frequent backtracking and no lists. .FE ",NA,NA
"ask_which([A,B,C,D,E,F,G,H|L]) :-",NA,NA
"screen_ask_which([A,B,C,D,E,F,G,H],[A,B,C,D,E,F,G,H]), ",NA,NA
ask_which(L).,NA,NA
ask_which([]).,NA,NA
"ask_which(L) :- length(L,N), N<9, N>0, screen_ask_which(L,L).",NA,NA
"screen_ask_which([X|L],L2) :- length(L,N), length(L2,N2),",NA,NA
" N3 is N2 - N, write(N3), write(': '), questioncode(X,Q),",NA,NA
" write(Q), write('?'), nl, asserta(asked(X,no)), ",NA,NA
"screen_ask_which(L,L2).",NA,NA
"screen_ask_which([],L2) :-",NA,NA
" write('Give numbers of questions whose answer is yes.'), ",NA,NA
"read(AL), create_facts(AL,L2), nl.",NA,NA
"create_facts([N|L],L2) :- item(N,L2,I), assertz(fact(I)),",NA,NA
" retract(asked(I,no)), asserta(asked(I,yes)), create_facts(L,L2). ",NA,NA
"create_facts([N|L],L2) :- not(item(N,L2,I)), create_facts(L,L2). ",NA,NA
"create_facts([],L2).",NA,NA
"item(1,[X|L],X).",NA,NA
"item(N,[X|L],I) :- N > 1, N2 is N-1, item(N2,L,I).",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"length([],1).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2+1.",NA,NA
"Here's an example use, assuming the ",NA,NA
questioncode,NA,NA
 definitions for appliance diagnosis given earlier (Section ,NA,NA
7.6): ,NA,NA
?- ask_which ,NA,NA
"([device_dead,knobs_do_something,lights_out,cord_frayed, ",NA,NA
"handyperson,familiar_appliance,device_on,just_plugged,in_socket, ",NA,NA
"smell_smoke,liquids,heats,powerful,has(knobs),has('moving parts'), ",NA,NA
"has('knobs, switches, or other controls'), ",NA,NA
"hear(pop),hear('weird noise')]).",NA,NA
1: Does the device refuse to do anything?,NA,NA
2: Does changing the switch positions or turning ,NA,NA
the knobs change anything?,NA,NA
3: Do all the lights in the house seem to be off?,NA,NA
4: Does the outer covering of the cord appear to be ,NA,NA
coming apart?,NA,NA
5: Are you good at fixing things?,NA,NA
6: Are you familiar with how this appliance works?,NA,NA
7: Is the ON/OFF switch set to ON?,NA,NA
8: Did you just plug the appliance in?,NA,NA
"Give numbers of questions whose answer is yes.[3,4,5,7].",NA,NA
1: Is the cord firmly plugged into the socket? ,NA,NA
2: Do you smell smoke?,NA,NA
3: Have any liquids spilled on the appliance just now?,NA,NA
4: Does the appliance heat things?,NA,NA
5: Does the appliance require a lot of power?,NA,NA
6: Does the appliance have knobs?,NA,NA
7: Does the appliance have moving parts?,NA,NA
"8: Does the appliance have knobs, switches, or other controls? ",NA,NA
"Give numbers of questions whose answer is yes.[6,8].",NA,NA
1: Did you hear a pop?,NA,NA
2: Did you hear a weird noise?,NA,NA
Give numbers of questions whose answer is yes.[].,NA,NA
yes,NA,NA
"To verify that the correct facts were asserted, we can use Prolog's built-in ",NA,NA
listing,NA,NA
 predicate that takes one ,NA,NA
"argument, a predicate name, and prints out every fact and rule with that name: ",NA,NA
?- listing(fact).,NA,NA
fact(device_dead).,NA,NA
fact(lights_out).,NA,NA
fact(cord_frayed).,NA,NA
fact(handyperson).,NA,NA
fact(device_on).,NA,NA
fact(has(knobs)).,NA,NA
"fact(has('knobs, switches, or other controls')).",NA,NA
yes,NA,NA
Fact order is very important to the operation and hence the efficiency of forward chaining (see Figure 6-3). ,NA,NA
"Furthermore, if your definition of the ",NA,NA
done,NA,NA
 predicate is anything besides ,NA,NA
not(fact(X)),NA,NA
", an incorrect fact order ",NA,NA
may prevent all correct conclusions. So it is a good idea to order question presentation from most important to ,NA,NA
"least important, since facts are entered with ",NA,NA
assertz,NA,NA
". To allow some user control, the preceding program asserts ",NA,NA
"choices for each individual menu in user-supplied order. We set the menu size to eight questions in the program, ",NA,NA
but you can easily change it if you want to improve user control and your terminal screen is tall enough. ,NA,NA
"For most applications, you shouldn't put every possible fact into menus. You should put the things most ",NA,NA
"common in rules in a first set of menus, and then run forward chaining and see what conclusions you reach. If ",NA,NA
"no ""interesting"" conclusions are reached (interestingness could mean membership in a particular set), then ",NA,NA
present further menus to the user (perhaps about things mentioned on the right sides of the shortest remaining ,NA,NA
"rules), assert new facts, and run forward chaining again. You can repeat the cycle as many times as you like. ",NA,NA
This is a ,NA,NA
fact partitioning,NA,NA
" trick for rule-based systems, as opposed to the ",NA,NA
rule partitioning,NA,NA
 trick in Section 7.8. ,NA,NA
"For appliance repair for instance, the first menu could list key classificatory information, such as whether it has ",NA,NA
"a heating element, whether it has mechanical parts, whether it gets electricity from an outlet or from batteries, ",NA,NA
"and what part of the appliance is faulty. After forward chaining on these facts, further menus could obtain a ",NA,NA
detailed description of the malfunction. ,NA,NA
"Both menus and questionnaires should not ""jump around"" too much between topics as backward chaining often ",NA,NA
"does. People are easily confused by rapid shifts in subject, and asking related questions, even irrelevant ones, ",NA,NA
makes them feel more comfortable. Doctors know this. ,NA,NA
Ordering of output (conclusions) presentation is important too for forward chaining. Backward chaining just ,NA,NA
"establishes one conclusion at a time, but forward chaining may establish a whole lot of interesting conclusions ",NA,NA
"about some problem. In fact this is one of its advantages, that it can determine not one but multiple ",NA,NA
"simultaneous problems are causing observed symptoms. If these conclusions are numerous, it's good to sort ",NA,NA
them by a fixed priority ordering. ,NA,NA
Rule form conversions (*) ,NA,NA
"The rule forms needed for backward chaining, hybrid chaining, and forward chaining are all different. So it ",NA,NA
"would be nice to automatically convert rules from one form to another. That means treating rules as data, ",NA,NA
"something important in many different areas of artificial intelligence, and supported by most dialects of Prolog ",NA,NA
and Lisp. ,NA,NA
Prolog does this with the ,NA,NA
clause,NA,NA
 predicate in most dialects. This has two arguments representing a left and a ,NA,NA
right side of a rule. A query on ,NA,NA
clause,NA,NA
 succeeds if its arguments can match the left and right sides of a database ,NA,NA
"rule. (Remember, facts are rules without left sides.) So for instance ",NA,NA
"?- clause(a,R).",NA,NA
binds the variable ,NA,NA
R,NA,NA
 to the right side of the first rule it can find that has ,NA,NA
a,NA,NA
 as its left side. The arguments to ,NA,NA
clause,NA,NA
 can also be predicate expressions containing arguments themselves. So ,NA,NA
"?- clause(p(X),R).",NA,NA
will try to find a rule with a ,NA,NA
p,NA,NA
" predicate of one argument on its left side, and will bind that one argument (if any) ",NA,NA
to the value of ,NA,NA
X,NA,NA
", and ",NA,NA
R,NA,NA
 to the query representing the right side of that rule | REFERENCE 2|. .FS | ,NA,NA
"REFERENCE 2| Many Prolog dialects require that the predicate name in the first argument be bound, though ",NA,NA
"arguments to that predicate name may have variables. If you have a list of all predicate names, you can iterate ",NA,NA
over them to do this. .FE ,NA,NA
Facts are just rules with no left sides. And ,NA,NA
clause,NA,NA
" recognizes this, also matching facts in the database as well as ",NA,NA
"rules. Then its first argument is bound to the fact, and the right side is bound to the word ",NA,NA
true,NA,NA
". For example, if ",NA,NA
for the preceding query we have a fact ,NA,NA
p(a),NA,NA
" in our database, one answer will be ",NA,NA
X=a,NA,NA
 with ,NA,NA
R,NA,NA
 bound to ,NA,NA
true,NA,NA
. ,NA,NA
"To automatically convert a rule to forward chaining form, we can access it with ",NA,NA
clause,NA,NA
", then convert the right ",NA,NA
"side of the rule to a list. The second argument of the clause predicate is bound to a query, not a list, so we need a ",NA,NA
"list conversion operation. This is called ""univ"" and is symbolized in most Prolog dialects by the infix predicate ",NA,NA
"""",NA,NA
=..,NA,NA
""", for which the stuff on the left side is a predicate expression and the stuff on the right side is an equivalent ",NA,NA
list. So we can say ,NA,NA
"?- clause(L,R), R =.. Rlist.",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (20 of 36) [23/04/2002 17:38:55],NA
and ,NA,NA
Rlist,NA,NA
" is a list, as we need for forward chaining. Here's the full code for converting all rules in a Prolog ",NA,NA
database to forward-chaining form: ,NA,NA
"forward_convert :- clause(L,R), not(overhead_predicate(L)),",NA,NA
 ,NA,NA
"R =.. Rlist, new_rule(L,Rlist), fail.",NA,NA
"overhead_predicate(new_rule(X,Y)).",NA,NA
"overhead_predicate(rule(X,Y)).",NA,NA
overhead_predicate(fact(X)).,NA,NA
"new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).",NA,NA
"new_rule(L,R) :- not(R=[]), asserta(rule(L,R)). ",NA,NA
overhead_predicate(forward_convert).,NA,NA
overhead_predicate(overhead_predicate(X)).,NA,NA
If your Prolog dialect doesn't allow ,NA,NA
L,NA,NA
" to be unbound, you can use: ",NA,NA
"forward_convert(All_predicates) :- member(L,All_predicates),",NA,NA
 forward_convert2(L).,NA,NA
"forward_convert2(L) :- clause(L,R), R =.. Rlist, new_rule(L,Rlist), fail. ",NA,NA
"new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).",NA,NA
"new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).",NA,NA
and you must query ,NA,NA
forward_convert,NA,NA
 with a list of all the predicates you want to convert. ,NA,NA
But all this won't work in some Prolog dialects that treat commas and semicolons like infix operators. If the ,NA,NA
"preceding doesn't work for you, try: ",NA,NA
"forward_convert(Preds) :- member(Pred,Preds), forward_convert2(Pred). ",NA,NA
"forward_convert2(Pred) :- clause(Pred,R), remove_commas(R,R2),",NA,NA
" new_rule(Pred,R2), fail.",NA,NA
"remove_commas(true,[]).",NA,NA
"remove_commas(S,[Y|L]) :- S=..[Comma,Y,Z], remove_commas(Z,L).",NA,NA
"remove_commas(X,[X]) :- not(X=true), not(X=..[Comma,Y,Z]). ",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).",NA,NA
"new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).",NA,NA
We can apply the same approach to the hybrid control structure. We convert the right side of each backward-,NA,NA
"chaining rule to a list, insert a ",NA,NA
not,NA,NA
" expression at the front of this list, insert an ",NA,NA
asserta,NA,NA
 expression at the end of ,NA,NA
"the list, and replace the original left side with the single symbol ",NA,NA
r,NA,NA
. We then can use the ,NA,NA
=..,NA,NA
 operation in reverse ,NA,NA
"(the left side unbound and the right side bound), converting the list of right-side expressions to a query. We ",NA,NA
enter this new rule into the Prolog database using ,NA,NA
asserta,NA,NA
 with this new rule as argument. Here's the full code: ,NA,NA
"hybrid_convert :- clause(L,R), R =.. Rlist,",NA,NA
" add_last(asserta(L),Rlist,Rlist2),",NA,NA
" R2 =.. [not(L)|Rlist2], asserta(r :- R2), fail. ",NA,NA
"add_last(X,[],[X]).",NA,NA
"add_last(X,[Y|L],[Y|L2]) :- add_last(X,L,L2).",NA,NA
If your Prolog dialect doesn't allow ,NA,NA
L,NA,NA
" to be unbound, you can use: ",NA,NA
"hybrid_convert(All_predicates) :- member(L,All_predicates),",NA,NA
 ,NA,NA
hybrid_convert2(L).,NA,NA
"hybrid_convert2(L) :- clause(L,R), R =.. Rlist,",NA,NA
" add_last(asserta(L),Rlist,Rlist2),",NA,NA
" R2 =.. [not(L)|Rlist2], asserta(r :- R2), fail. ",NA,NA
"add_last(X,[],[X]).",NA,NA
"add_last(X,[Y|L],[Y|L2]) :- add_last(X,L,L2).",NA,NA
"and if none of that works in your Prolog dialect, you can try this alternative hybrid-chaining program which ",NA,NA
doesn't directly convert Prolog rules but interprets them as needed: ,NA,NA
hybrid(Leftsidelist) :- done.,NA,NA
"hybrid(Leftsidelist) :- not(one_cycle(Leftsidelist)), hybrid(Leftsidelist).",NA,NA
"one_cycle(Leftsidelist) :- member(P,Leftsidelist), clause(P,R), ",NA,NA
"remove_commas(R,R2), allfacts(R2), not(P), asserta(P), fail.",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"remove_commas(true,[]).",NA,NA
"remove_commas(S,[Y|L]) :- S=..[Comma,Y,Z], remove_commas(Z,L).",NA,NA
"remove_commas(X,[X]) :- not(X=true), not(X=..[Comma,Y,Z]).",NA,NA
allfacts([]).,NA,NA
"allfacts([Term|L]) :- clause(Term,true), allfacts(L).",NA,NA
Indexing of predicates (*) ,NA,NA
"Prolog interpreters automatically index predicate names appearing on the left sides of rules, to help in backward ",NA,NA
"chaining; that is, they keep lists of pointers to all rules with a particular predicate name, to speed finding them. ",NA,NA
"But this won't help our rule-cycle hybrid and forward chaining implementations, for which we must do our own ",NA,NA
indexing if we want efficiency. ,NA,NA
Let's take pure forward chaining as an example. Indexing could mean storing for each predicate name a list of ,NA,NA
which rule ,NA,NA
right,NA,NA
 sides it appears in. One way is to generalize the ,NA,NA
rule,NA,NA
 predicate of Section 7.10 to a ,NA,NA
rules ,NA,NA
predicate whose first argument is a predicate expression ,NA,NA
P,NA,NA
 and whose second argument is a list of pairs ,NA,NA
representing rules containing ,NA,NA
P,NA,NA
" on their right side. The first item of each pair is a rule left side, and the second ",NA,NA
item is a rule right side containing the specified predicate name. So the rules ,NA,NA
"a :- b, c.",NA,NA
"d :- c, e, f.",NA,NA
are written as ,NA,NA
"rules(b,[[a,[b,c]]]).",NA,NA
"rules(c,[[a,[b,c]],[d,[c,e,f]]]). ",NA,NA
"rules(e,[[d,[c,e,f]]]).",NA,NA
"rules(f,[[d,[c,e,f]]]).",NA,NA
and just changing ,NA,NA
pursuit,NA,NA
", the forward chaining program becomes: ",NA,NA
forward :- done.,NA,NA
"forward :- fact(F), doall(pursuit(F)), assertz(usedfact(F)), ",NA,NA
"retract(fact(F)), forward.",NA,NA
"pursuit(F) :- rules(F,Rlist), member([L,R],Rlist), rule_pursuit(F,L,R). ",NA,NA
"rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew), new_rule(L,Rnew). ",NA,NA
"new_rule(L,[]) :- not(fact(L)), asserta(fact(L)).",NA,NA
"new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).",NA,NA
"A rule with K expressions on its right side is repeated K times this way, so this indexing buys speed at the ",NA,NA
expense of space. The speed advantage comes from eliminating the ,NA,NA
member,NA,NA
 predicate in the earlier ,NA,NA
implementation; we have cached in advance the results of running ,NA,NA
member,NA,NA
. ,NA,NA
"Clever indexing techniques have been developed in both artificial intelligence and database research, and much ",NA,NA
further can be done along these lines. ,NA,NA
Implementing meta-rules (*) ,NA,NA
"Meta-rules are rules that treat rules as data, usually by choosing the one to use next (",NA,NA
conflict resolution,NA,NA
). ,NA,NA
Choosing means treating rules as data. So meta-rule implementation needs special rule formats like those for ,NA,NA
"hybrid and pure-forward chaining, and can exploit ",NA,NA
clause,NA,NA
 and ,NA,NA
=..,NA,NA
 for rule-form conversion. We can represent ,NA,NA
meta-rules as rules with a special ,NA,NA
prefer,NA,NA
 predicate name on their left sides. The ,NA,NA
prefer,NA,NA
 will take four arguments: ,NA,NA
"the left side of a rule 1, the right side of rule 1 (as a list), the left side of a rule 2, and the right side of rule 2 (as a ",NA,NA
"list). It should succeed when rule 1 is preferable (to execute next) to rule 2. (Of course, none of your regular rules ",NA,NA
can have a ,NA,NA
prefer,NA,NA
 predicate name for this to work.) Here's an example: ,NA,NA
"prefer(L1,R1,L2,R2) :- length(R1,Len1), length(R2,Len2), ",NA,NA
Len1 < Len2.,NA,NA
This says a rule with shorter right side should be preferred. Predicate ,NA,NA
length,NA,NA
" was defined in Section 5.5, and ",NA,NA
computes the number of items in a list: ,NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2 + 1.",NA,NA
Another example: ,NA,NA
"prefer(a(X),R1,a(Y),R2) :- member(b(Z),R1), not(member(b(W),R2)).",NA,NA
This says that if two rules both conclude something about one-argument predicate ,NA,NA
a,NA,NA
", one is preferred if it ",NA,NA
mentions one-argument predicate fact for the second) concluding about a one-argument predicate ,NA,NA
a,NA,NA
", whether ",NA,NA
their arguments are constants or variables. ,NA,NA
"Meta-rules are most useful when they refer, unlike these two examples, to the current state of reasoning rather ",NA,NA
"than the unvarying text of rules. As an example, consider this meta-rule to be used with pure forward chaining: ",NA,NA
"prefer(L1,R1,L2,R2) :- member(b,R1), not(member(b,R2)), fact(b).",NA,NA
This says to prefer a rule that mentions predicate expression ,NA,NA
b,NA,NA
" to one that doesn't, whenever ",NA,NA
b,NA,NA
 was proved a ,NA,NA
fact. A more useful meta-rule says to prefer the rule used most recently: ,NA,NA
"prefer(L1,R1,L2,R2) :- used(L1,R1,T1), used(L2,R2,T2), T1 > T2.",NA,NA
Here we assume ,NA,NA
used,NA,NA
" is a fact asserted after each successful rule application, stating the time a rule was used ",NA,NA
"(times can be increasing integers). Such meta-rules permit flexible control adjustable to the processing context, ",NA,NA
something general-purpose control structures can't do by themselves. ,NA,NA
Programmers can write these meta-rules at the same time they write the rules for an application. The set of meta-,NA,NA
rules can express a lattice of orderings (or ,NA,NA
partial ordering,NA,NA
") of rule preferences, but not necessarily a complete ",NA,NA
"ordering or sorting. So it's possible for neither of two rules to be preferred to the other, in which case we can pick ",NA,NA
one arbitrarily. ,NA,NA
"Meta-rules enhance general-purpose control structures, and aren't a control structure by themselves. This means ",NA,NA
"that meta-rule implementation is different for backward, hybrid, and forward chaining. With backward chaining, ",NA,NA
meta-rules pick a rule or fact (not necessarily the first in database order) to try to match to a predicate expression ,NA,NA
"in a query or rule right side. With hybrid chaining, meta-rules pick a rule from the entire set of rules to run next. ",NA,NA
"With pure forward chaining, meta-rules can both select a fact to try next and select a rule to try to match the fact ",NA,NA
"to. As an example, here's an implementation of meta-rules with hybrid chaining. ",NA,NA
metahybrid :- done.,NA,NA
"metahybrid :- pick_rule(R), call(R), metahybrid.",NA,NA
"pick_rule(R) :- clause(r,R), not(better_rule(R)).",NA,NA
"better_rule(R) :- clause(r,R2), prefer(r,R2,r,R).",NA,NA
This assumes rules are written in the standard hybrid form with ,NA,NA
r,NA,NA
 on the left side and the two extra things on the ,NA,NA
right side. Rules are repeatedly executed (using the ,NA,NA
call,NA,NA
" predicate, which executes a query as if it were typed in) ",NA,NA
until the ,NA,NA
done,NA,NA
 condition is satisfied. A rule is chosen to execute only if no other rules are preferred to it ,NA,NA
according to the meta-rules. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (24 of 36) [23/04/2002 17:38:55],NA
Implementing concurrency (*) ,NA,NA
Several Prolog dialects provide for concurrency of rules and expressions in rules. The emphasis is programmer's ,NA,NA
"tools to indicate good places to do concurrency rather than automatic choice. For instance, a special ""and"" ",NA,NA
"symbol, used in place of a comma, can specify ""and""-parallelism on the right side of a rule. These approaches to ",NA,NA
"concurrency are complicated and incompatible with each other, and we won't discuss them here. ",NA,NA
Decision lattices: a compilation of a rule-based system (*) ,NA,NA
Compilers and compilation are important concepts in computer science. Compilers take a program in an easy-to-,NA,NA
"read but slow-to-execute form and convert it to a more efficient, easier-to-interpret form. Compilation is often ",NA,NA
"rule-based itself, especially often-complicated ",NA,NA
code optimization,NA,NA
. But compilation techniques can also make ,NA,NA
artificial intelligence programs themselves more efficient. Since rule-based systems are further steps in power ,NA,NA
"beyond traditional higher-level languages like Pascal, Ada, PL/1, and Fortran, secondary compilations are ",NA,NA
usually done before the primary compilation to machine language. These secondary compilations convert rules to ,NA,NA
"the format of those languages: formats without references to backward, forward, or hybrid chaining, and with no ",NA,NA
"backtracking, no postponing of variable bindings, and no multiway designation of inputs and outputs to predicate ",NA,NA
expressions. The decision lattice representation of rules introduced in Section 6.8 is one such secondarily-,NA,NA
"compiled format. It starts at some node in a lattice, and depending on how a user answers a question, it those to ",NA,NA
some next node in the lattice. Each question represents another branch point. When it gets to a node that is a ,NA,NA
leaf,NA,NA
 ,NA,NA
"(a node from which it cannot go any further), it retrieves the conclusion associated with that node. ",NA,NA
"A decision lattice for a set of rules can be created systematically (albeit not algorithmically, since it involves ",NA,NA
"some subjective judgment) from rules without ""or""s on their right sides, by the following (similar to ""automatic ",NA,NA
"indexing"" methods): ",NA,NA
1. For every top-level or ,NA,NA
diagnosis,NA,NA
" rule, repeatedly substitute in the definitions for (right sides of) ",NA,NA
"all intermediate predicates on its right side, until no more remain. If there is more than one rule ",NA,NA
"proving an intermediate predicate, make multiple versions of the diagnosis rule, one for each ",NA,NA
possibility. (This is a useful compilation method even if you don't want a decision lattice; it's called ,NA,NA
rule collapsing,NA,NA
.) ,NA,NA
2. Examine the right sides of the new rules. Pick a predicate expression that appears unnegated in ,NA,NA
"some rules and negated in an approximately equal number (the more rules it appears in, the better, ",NA,NA
"and the more even the split, the better). Call this the partitioning predicate expression, and have the ",NA,NA
"first question to the user ask about it. Create branches from the starting node to new nodes, each ",NA,NA
corresponding to a possible answer to this question. Partition the rules into groups ,NA,NA
"corresponding to the answers, and associate each group with one new node (copies of rules not ",NA,NA
mentioning the predicate expression should be put into every group). Then remove all ,NA,NA
"occurrences of the expression and its negation from the rules. Now within each rule group, ",NA,NA
"separately apply this step recursively, choosing a predicate that partitions the remaining rules in the ",NA,NA
"group best, and taking its questioning next. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (25 of 36) [23/04/2002 17:38:55],NA
"An example will make this clearer. Suppose we have facts, ",NA,NA
a,NA,NA
", ",NA,NA
b,NA,NA
", ",NA,NA
c,NA,NA
", ",NA,NA
d,NA,NA
", and ",NA,NA
e,NA,NA
", and possible diagnoses (final ",NA,NA
conclusions) ,NA,NA
r,NA,NA
", ",NA,NA
s,NA,NA
", ",NA,NA
t,NA,NA
",",NA,NA
u,NA,NA
", and ",NA,NA
v,NA,NA
. Suppose these are the rules: ,NA,NA
"r :- a, d, not(e).",NA,NA
"s :- not(a), not(c), q. ",NA,NA
"t :- not(a), p.",NA,NA
"u :- a, d, e.",NA,NA
"u :- a, q.",NA,NA
"v :- not(a), not(b), c. ",NA,NA
"p :- b, c.",NA,NA
"p :- not(c), d.",NA,NA
q :- not(d).,NA,NA
"For the first step (preprocessing), we substitute in the intermediate predicates ",NA,NA
p,NA,NA
 and ,NA,NA
q,NA,NA
. (Intermediate predicates ,NA,NA
are just anything that occurs on both a left and a right side.) ,NA,NA
"r :- a, d, not(e).",NA,NA
"s :- not(a), not(c), not(d). ",NA,NA
"t :- not(a), b, c.",NA,NA
"t :- not(a), not(c), d.",NA,NA
"u :- a, d, e.",NA,NA
"u :- a, not(d).",NA,NA
"v :- not(a), not(b), c.",NA,NA
For the second step we first examine right sides of rules to find something mentioned in a lot of rules that ,NA,NA
partitions them evenly as possible. Expression ,NA,NA
a,NA,NA
" is the obvious choice, because it is the only expression ",NA,NA
occurring in every rule. So we partition on ,NA,NA
a,NA,NA
", deleting it from the rules, getting two rule sets: ",NA,NA
"r :- d, not(e).  /* Subdatabase for ""a"" true */ ",NA,NA
"u :- d, e.",NA,NA
u :- not(d).,NA,NA
"s :- not(c), not(d).  /* Subdatabase for ""not(a)"" true */ ",NA,NA
"t :- b, c.",NA,NA
"t :- not(c), d. ",NA,NA
"v :- not(b), c.",NA,NA
The first set will be used whenever the fact ,NA,NA
a,NA,NA
" is true, and the second set will be used whenever the fact ",NA,NA
a,NA,NA
 is false. ,NA,NA
In the first group ,NA,NA
d,NA,NA
" appears in all rules, so it can be the partitioning expression. Likewise, ",NA,NA
c,NA,NA
 can partition the ,NA,NA
second group. This gives four rule groups or ,NA,NA
subdatabases,NA,NA
: ,NA,NA
"r :- not(e).            /* The ""a, d"" rule subdatabase */ ",NA,NA
u :- e.,NA,NA
"u.                      /* The ""a, not(d)"" subdatabase */",NA,NA
"t :- b.                 /* The ""not(a), c"" subdatabase */ ",NA,NA
v :- not(b).,NA,NA
"s :- not(d).            /* The ""not(a), not(c)"" subdatabase */ ",NA,NA
t :- d.,NA,NA
"Three of the four groups are two-rule, for which one more partitioning gives a unique answer. The final decision ",NA,NA
lattice created by this analysis is shown in Figure 7-4. ,NA,NA
"Decision lattice compilations of rule-base systems can be easily written in any computer language, including ",NA,NA
"Prolog. Give code names to every node in the decision lattice, including the starting and ending nodes. Then ",NA,NA
define a ,NA,NA
successor,NA,NA
 predicate of two arguments that gives conditions for one node to be followed by another ,NA,NA
"node. For instance, for our previous example: ",NA,NA
"successor(n1,n2) :- askif(a). ",NA,NA
"successor(n1,n3) :- askifnot(a).",NA,NA
"successor(n2,n4) :- askif(d). ",NA,NA
"successor(n4,u) :- askif(e).",NA,NA
"successor(n4,r) :- askifnot(e). ",NA,NA
"successor(n2,u) :- askifnot(d).",NA,NA
"successor(n3,n5) :- askif(c). ",NA,NA
"successor(n5,t) :- askif(b).",NA,NA
"successor(n5,v) :- askifnot(b). ",NA,NA
"successor(n3,n6) :- askifnot(c). ",NA,NA
"successor(n6,t) :- askif(d).",NA,NA
"successor(n6,s) :- askifnot(d).",NA,NA
Then we query a new ,NA,NA
diagnosis,NA,NA
 predicate defined: ,NA,NA
"diagnosis(Node,Node) :- not(successor(Node,X)).",NA,NA
"diagnosis(D,Start) :- successor(Start,X), diagnosis(D,X).",NA,NA
For the preceding example we also need a way to query the facts: ,NA,NA
"questioncode(X,X) :- member(X,[a,b,c,d]), write('Is this correct: '). ",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
And here's what happens: ,NA,NA
"?- diagnosis(X,n1).",NA,NA
Is this correct: a? no. ,NA,NA
Is this correct: c? yes. ,NA,NA
Is this correct: b? no.,NA,NA
X=v; ,NA,NA
no,NA,NA
"This program is a simple example of ""search"" programs, which we'll study in much more detail in Chapters 9, ",NA,NA
"10, and 11. ",NA,NA
Summary of the code described in the chapter (*) ,NA,NA
"Warning: in using the following, make sure your own code does not redefine or even duplicate the definitions of ",NA,NA
"any predicates used, or you can be in serious trouble. ",NA,NA
"The following rules assist question-asking for backward, forward, and hybrid chaining. The ",NA,NA
ask,NA,NA
 predicate asks ,NA,NA
"the user a question, providing extra explanation if the user types a question mark, and returns the answer (after ",NA,NA
caching it). The ,NA,NA
questioncode,NA,NA
 and ,NA,NA
explain,NA,NA
 predicates must be provided by the programmer; the first decodes ,NA,NA
"questions, and the second provides additional explanation for particular questions when the user has trouble ",NA,NA
understanding. The ,NA,NA
askif,NA,NA
" predicate handles yes/no questions; it succeeds if the user answers positively, fails if ",NA,NA
"the user answers negatively, and requests another answer if the user answers anything else. Warning: do ",NA,NA
"abolish(asked,2))",NA,NA
" to erase memory before a new situation (problem), if you want to solve more than one ",NA,NA
situation. ,NA,NA
/* Tools for questioning the user */ ,NA,NA
"askif(Qcode) :- ask(Qcode,A), positive_answer(Qcode,A). ",NA,NA
askifnot(Qcode) :- not(askif(Qcode)).,NA,NA
"positive_answer(Qcode,A) :- affirmative(A).",NA,NA
"positive_answer(Qcode,A) :- not(negative(A)),",NA,NA
" not(affirmative(A)), write('Please answer yes or no.'), ",NA,NA
"read(A2), retract(asked(Qcode,A)),",NA,NA
" asserta(asked(Qcode,A2)), affirmative(A2).",NA,NA
"ask(Qcode,A) :- asked(Qcode,A).",NA,NA
"ask(Qcode,A) :- not(asked(Qcode,A)), questioncode(Qcode,Q),",NA,NA
" write(Q), write('? '), read(A2), ask2(Q,Qcode,A2,A).",NA,NA
"ask2(Q,Qcode,'?',A) :- explain(Qcode), ask(Qcode,A). ",NA,NA
"ask2(Q,Qcode,A,A) :- not(A='?'), asserta(asked(Qcode,A)).",NA,NA
affirmative(yes).,NA,NA
affirmative(y).,NA,NA
affirmative(ye).,NA,NA
affirmative(right). ,NA,NA
affirmative(ok).,NA,NA
affirmative(uhhuh).,NA,NA
negative(no).,NA,NA
negative(n).,NA,NA
negative(not).,NA,NA
negative(never).,NA,NA
negative(impossible). ,NA,NA
negative(haha).,NA,NA
"To do rule-cycle hybrid chaining, write the rules with ",NA,NA
r,NA,NA
" on their left sides, and an ",NA,NA
asserta,NA,NA
 of the original left ,NA,NA
side on the right end of the right side. No rules can contain ,NA,NA
not,NA,NA
. Then query ,NA,NA
hybrid,NA,NA
", using this program: ",NA,NA
/* Problem-independent rule-cycle hybrid chaining */ ,NA,NA
hybrid :- done.,NA,NA
"hybrid :- doall(r), hybrid.",NA,NA
doall(P) :- not(alltried(P)).,NA,NA
"alltried(P) :- call(P), fail.",NA,NA
"To do pure forward chaining, write the rules as facts with predicate name ",NA,NA
rule,NA,NA
", for which the first argument is a ",NA,NA
left side and the second argument is the corresponding right side. No rules can contain ,NA,NA
not,NA,NA
. Then query ,NA,NA
forward,NA,NA
", defined this way: ",NA,NA
/* Problem-independent forward chaining */ ,NA,NA
forward :- done.,NA,NA
"forward :- fact(F), doall(pursuit(F)), assertz(usedfact(F)), ",NA,NA
"retract(fact(F)), forward.",NA,NA
"pursuit(F) :- rule(L,R), rule_pursuit(F,L,R).",NA,NA
"rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew),",NA,NA
" new_rule(L,Rnew).",NA,NA
"new_rule(L,[]) :- not(fact(L)), asserta(fact(L)). ",NA,NA
"new_rule(L,R) :- not(R=[]), asserta(rule(L,R)).",NA,NA
doall(P) :- not(alltried(P)).,NA,NA
"alltried(P) :- call(P), fail.",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- not(X=Y), delete(X,L,M).",NA,NA
"When this program stops, the learned facts are left as assertions of ",NA,NA
fact,NA,NA
 and ,NA,NA
usedfact,NA,NA
 predicates. If you want to ,NA,NA
"make sure that all possible conclusions are reached, use this definition of ",NA,NA
done,NA,NA
: ,NA,NA
done :- not(fact(X)).,NA,NA
"If you want to speed up forward chaining, and your rule-based system can be represented as an and-or-not ",NA,NA
"lattice, you can rewrite the preceding ",NA,NA
rule_pursuit,NA,NA
 rule as: ,NA,NA
"rule_pursuit(F,L,R) :- member(F,R), delete(F,R,Rnew), retract(rule(L,R)),",NA,NA
 ,NA,NA
"new_rule(L,Rnew).",NA,NA
If you want to do forward chaining with predicate expressions having ,NA,NA
not,NA,NA
"s, first make sure the ",NA,NA
not,NA,NA
s all refer to ,NA,NA
fact predicates. Then execute ,NA,NA
full_forward,NA,NA
: ,NA,NA
"full_forward :- forward, doall(handle_not), forward.",NA,NA
"handle_not :- rule(L,R), member(not(X),R), not(usedfact(X)),",NA,NA
" not(fact(X)), delete(not(X),R2), new_rule(L,R2).",NA,NA
Meta-rules can enhance other control structures. They can be written as rules with predicate name ,NA,NA
prefer,NA,NA
", of ",NA,NA
"four arguments (the left and right sides of two rules, respectively) that give conditions under which the first rule ",NA,NA
"should be executed before the second rule. For meta-rules with hybrid chaining, execute the query ",NA,NA
metahybrid ,NA,NA
with this alternative code: ,NA,NA
/* Problem-independent rule-cycle hybrid chaining using meta-rules */ ,NA,NA
metahybrid :- done.,NA,NA
"metahybrid :- pick_rule(R), call(R), metahybrid.",NA,NA
"pick_rule(R) :- clause(r,R), not(better_rule(R)).",NA,NA
"better_rule(R) :- clause(r,R2), prefer(r,R2,r,R).",NA,NA
"To implement menus as a way of getting facts to do forward chaining, execute ",NA,NA
ask_which,NA,NA
 with argument the ,NA,NA
list of question codes for the facts you want to check. ,NA,NA
/* Menu generation for forward chaining */ ,NA,NA
"ask_which([A,B,C,D,E,F,G,H|L]) :-",NA,NA
" screen_ask_which([A,B,C,D,E,F,G,H],[A,B,C,D,E,F,G,H]),",NA,NA
 ask_which(L).,NA,NA
ask_which([]).,NA,NA
"ask_which(L) :- length(L,N), N<9, N>0, screen_ask_which(L,L).",NA,NA
"screen_ask_which([X|L],L2) :- length(L,N), length(L2,N2), ",NA,NA
"N3 is N2 - N, write(N3), write(': '), questioncode(X,Q), ",NA,NA
"write(Q), write('?'), nl, asserta(asked(X,no)),",NA,NA
" screen_ask_which(L,L2).",NA,NA
"screen_ask_which([],L2) :-",NA,NA
" write('Give numbers of questions whose answer is yes.'), ",NA,NA
"read(AL), create_facts(AL,L2), nl.",NA,NA
"create_facts([N|L],L2) :- item(N,L2,I), assertz(fact(I)),",NA,NA
" retract(asked(I,no)), asserta(asked(I,yes)), create_facts(L,L2). ",NA,NA
"create_facts([N|L],L2) :- not(item(N,L2,I)), create_facts(L,L2). ",NA,NA
"create_facts([],L2).",NA,NA
"item(1,[X|L],X).",NA,NA
"item(N,[X|L],I) :- N > 1, N2 is N-1, item(N2,L,I).",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"length([],1).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2+1.",NA,NA
"To implement a decision lattice, draw the lattice and label all the nodes with unique names. Write rules defining ",NA,NA
the branches with the ,NA,NA
successor,NA,NA
" predicate, for example ",NA,NA
"successor(n5,n9) :- askif(device_dead). ",NA,NA
"successor(n5,n15) :- askifnot(device_dead).",NA,NA
"which says that if you're at node n5, go to node n9 if the user responds positively to the ",NA,NA
device_dead,NA,NA
" question, ",NA,NA
otherwise go to node n15. Then to run the decision lattice call ,NA,NA
"diagnosis(D,<first-node>)",NA,NA
", which needs this ",NA,NA
definition: ,NA,NA
"diagnosis(D,Start) :- successor(Start,X), diagnosis(D,X).",NA,NA
"diagnosis(Node,Node) :- not(successor(Node,X)).",NA,NA
Keywords: ,NA,NA
diagnosis,NA,NA
character string,NA,NA
input coding,NA,NA
output coding,NA,NA
intermediate predicates,NA,NA
menu,NA,NA
.SH Exercises ,NA,NA
"7-1. (R,A,P) Improve the appliance-diagnosis program given in Section 7.6 so it can reach the following new ",NA,NA
diagnoses: ,NA,NA
"--the motor has burned out, for appliances that have motors; ",NA,NA
--something is blocking the mechanical operation (like something keeping the motor from ,NA,NA
"turning), for mechanical appliances; ",NA,NA
"--some internal wiring is broken (possible if appliance was dropped recently, or some other ",NA,NA
jarring occurred); ,NA,NA
Add new questions and perhaps intermediate predicates to handle these diagnoses. Show your new program ,NA,NA
working. ,NA,NA
"7-2. (A,P) Figure out a simple way to prevent repeated printing of the same diagnosis in the backward-chaining ",NA,NA
appliance program as in Section 7.7. Show your method working on the appliance program. ,NA,NA
"7-3. (E) (a) Medical records often reference very-high-level and very-low-level concepts only, no intermediate ",NA,NA
concepts. Is this typical of other expert-system application areas? ,NA,NA
(b) Suppose you must defend intermediate concepts in an expert system to your boss or representative of a ,NA,NA
"funding agency. They could claim that intermediate concepts don't add capabilities to an expert system, just ",NA,NA
"make its innards neater. Furthermore, intermediate concepts require extra design effort, and slow down ",NA,NA
operation by forcing reasoning to proceed by smaller steps. How would you reply in defense of intermediate ,NA,NA
predicates? ,NA,NA
"7-4. (P,H,G) Design a rule-based expert system to give debugging advice about Prolog programs. Use backward ",NA,NA
"chaining in the manner of the appliance example, asking questions of the user. There is a lot of room for ",NA,NA
"creativity in the choice of what the program knows about, but the program must help debug Prolog programs in ",NA,NA
some way. Be sure: ,NA,NA
1. Your program is a rule-based expert system: ,NA,NA
2. Your program contains at least 20 diagnosis rules (rules drawing a conclusion about what is ,NA,NA
"wrong with a Prolog program), 12 of which have more than one kind of evidence ""and""ed on their ",NA,NA
right side; ,NA,NA
"3. Your program uses at least three intermediate conclusions, conclusions that are neither ",NA,NA
equivalent to facts nor correspond to advice to the user; ,NA,NA
4. Your program can reach at least seven different conclusions depending on the user's answers to ,NA,NA
the questions; ,NA,NA
5. Three of the conclusions your program reaches appear on the left side of more than one rule ,NA,NA
"(that is, there must be multiple paths to three conclusions); ",NA,NA
"6. Your program uses at least three kinds of history information, like how long the user has been ",NA,NA
"programming Prolog, or whether parts of the user's program are already debugged; ",NA,NA
"7. The control structure of your program is not extensively ""hard-wired"" (for instance, there can't ",NA,NA
be a lot of branch specifications controlling where to go next); ,NA,NA
"8. As much as possible, all the variables and predicate names are semantically meaningful (that is, ",NA,NA
their function should be explained by their names; use numbers in your program only for ,NA,NA
(possibly) probabilities). ,NA,NA
Use of probabilities or certainty factors is not necessary. Think about good ways to present your conclusions to ,NA,NA
the user. ,NA,NA
7-5. (A) (For people who know something about probabilities.) Caching of facts in backward chaining is not ,NA,NA
always a good idea; it depends on the situation. Suppose we have rules for testing whether ,NA,NA
a(X),NA,NA
 is true for some ,NA,NA
X,NA,NA
", rules that require R units of time to execute on the average. Suppose to speed things up we cache K values of ",NA,NA
X,NA,NA
 for which the ,NA,NA
a,NA,NA
" predicate holds. That is, we place facts for those values in front of the rules that calculate ",NA,NA
a(X),NA,NA
 ,NA,NA
as previously. Then to answer a query on the ,NA,NA
a,NA,NA
" predicate, we first sequentially search through all these cached ",NA,NA
"facts, and use the rules only if we can't find a match in the cache. ",NA,NA
"(a) Suppose the probability is P that any one item in the cache matches an incoming query, and suppose the ",NA,NA
"cache items are all different and do not have variables, so if one item matches the query no other item will. ",NA,NA
Under what approximate conditions will using the cache be preferable to not using the cache? Assume that |K < ,NA,NA
"0.1 / P|, and assume that each cache access requires one unit of time. ",NA,NA
(b) Now assume the items of the cache are not all equally likely to be used. Often a ,NA,NA
Zipf's Law,NA,NA
 distribution ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (33 of 36) [23/04/2002 17:38:56],NA
"applies, for which the probability of the most common item is P, the probability of the second most common ",NA,NA
"item is P/2, the probability of the third most common item is P/3, and so on. Again assume cache items are ",NA,NA
mutually exclusive. Again assume that each cache access requires one unit of time. Under what approximate ,NA,NA
conditions is caching desirable now? Hint: the sum of |1 / I| from |I = 1| to |K| is approximately |log sub 2 ( K + ,NA,NA
1 )|. ,NA,NA
7-6. (P) Write a rule-based expert system to recommend cleaning methods for clothing. Obtain rules from a ,NA,NA
"human ""expert"" on the subject. Use hybrid chaining in implementation for simplicity. Ask the user to give a ",NA,NA
"single category that best describes the material they want to clean, and then ask additional questions as ",NA,NA
necessary to make its description more precise. Write at least twenty rules reaching at least ten different ,NA,NA
cleaning methods as conclusions. Use a lot of ,NA,NA
a_kind_of,NA,NA
 facts to classify the many kinds of clothing. You'll ,NA,NA
"need to worry about rule order, and default rules will help. ",NA,NA
7-7. The criteria for when to delete a rule in forward chaining were conservative: they miss other circumstances ,NA,NA
"under which it would be good to delete rules. Define those circumstances, and explain how we could efficiently ",NA,NA
check for them. ,NA,NA
"7-8. (H,P) Write a program to diagnose malfunctions of a car using forward chaining in the pure form. Write at ",NA,NA
least fifty rules and use at least ten intermediate predicates. Use a repair manual as your source of expertise. ,NA,NA
Concentrate on some particular subsystem of the car to do a better job. Use the menu approach to defining facts. ,NA,NA
"Provide for at least two invocations of forward chaining, and stop when one of a set of ",NA,NA
diagnosis,NA,NA
 facts is ,NA,NA
proved. ,NA,NA
"7-9. (H,P) Write a rule-based expert system to diagnose simple illnesses and medical problems (such as a ",NA,NA
"""primary care"" or ""family practice"" physician might handle). Use a medical reference book as your source of ",NA,NA
"knowledge. Your program should be able to reach 30 different diagnoses, at least seven in more than one way, ",NA,NA
using at least five intermediate predicates. Run your rules with both backward chaining and forward chaining ,NA,NA
"and compare performance. To do this, use the automatic conversion routines, or use the forward-chaining rule ",NA,NA
"form and write your own backward-chainer. For forward chaining, let the user pick symptoms from a series of ",NA,NA
"menus, and ask questions of the user directly for additional secondary facts. Show your rules working on ",NA,NA
sample situations. ,NA,NA
7-10. (P) Write a rule-based expert system to choose a good way to graphically display data. Suppose as input ,NA,NA
this program loads a file of ,NA,NA
data,NA,NA
" facts of one argument, a list representing properties of some object. Suppose the ",NA,NA
"output is a recommendation about whether to use bar graphs, pie graphs, two-dimensional plots, summary tables, ",NA,NA
"etc. for particular positions in the data list. For instance, a recommendation might be to plot all the first items of ",NA,NA
"data lists as an X coordinate against second items as a Y coordinate, and to draw a bar graph showing all the first ",NA,NA
items against third items. These graphing recommendations will need to pick subsidiary information about ,NA,NA
"ranges to be plotted, binning (what values get grouped together), approximate dimensions of the display, extra ",NA,NA
"lines, unusual values (",NA,NA
outliers,NA,NA
") that have been left out, etc. Generally you can find some graphical display for ",NA,NA
"every pair of data item positions, but only some of these will be interesting and worth recommending. ",NA,NA
"Interestingness can be defined in various ways, but should emphasize the unpredictability of the data: a nearly ",NA,NA
"straight line makes an uninteresting graph. It will be useful to define a number of processing predicates, ",NA,NA
including a ,NA,NA
column,NA,NA
" predicate that makes a list of all the data values in position K in the data list, and predicate ",NA,NA
that applies a standard statistical test (look one up in a statistics book) to see if the values in two such columns ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (34 of 36) [23/04/2002 17:38:56],NA
are associated or correlated. You may want to consult a book giving recommendations for graphical display. ,NA,NA
7-11. (A) The definitions of the ,NA,NA
forall,NA,NA
 and ,NA,NA
doall,NA,NA
 predicates both use the built-in Prolog predicate ,NA,NA
call,NA,NA
", which ",NA,NA
takes a predicate expression as argument and queries it. (This is useful because the argument can be a variable ,NA,NA
bound within a program.) Use ,NA,NA
call,NA,NA
 to implement the following: ,NA,NA
(a) ,NA,NA
"or(P,Q)",NA,NA
 which succeeds whenever querying either ,NA,NA
P,NA,NA
 or ,NA,NA
Q,NA,NA
 succeeds ,NA,NA
(b) ,NA,NA
"if(P,Q,R)",NA,NA
 which succeeds whenever ,NA,NA
P,NA,NA
 succeeds then ,NA,NA
Q,NA,NA
" succeeds, or if ",NA,NA
P,NA,NA
 fails then ,NA,NA
R,NA,NA
 succeeds ,NA,NA
(c) ,NA,NA
"case(P,N,L)",NA,NA
 which succeeds whenever predicate expression number ,NA,NA
N,NA,NA
 of list ,NA,NA
L,NA,NA
" succeeds, where ",NA,NA
N,NA,NA
 is bound ,NA,NA
by executing predicate expression ,NA,NA
P,NA,NA
 (that is ,NA,NA
N,NA,NA
 must be a variable in ,NA,NA
P,NA,NA
 that is bound by ,NA,NA
P,NA,NA
) ,NA,NA
"7-12. (H,P) Implement the other hybrid of backward and forward chaining mentioned in Section 6.4, the hybrid ",NA,NA
that alternates between forward and backward chaining. Show your program working on some sample rules and ,NA,NA
facts. ,NA,NA
7-13. (P) Implement meta-rules for pure forward chaining. Use a ,NA,NA
prefer,NA,NA
 predicate like the one used for rule-,NA,NA
cycle hybrid meta-rules. ,NA,NA
7-14. (P) Consider meta-rules with pure forward chaining (the implementation is considered in Exercise 7-13). ,NA,NA
Assume there are no variables in the rules. ,NA,NA
(a) Write a meta-rule to prevent the same conclusion from being reached twice. ,NA,NA
"(b) Write a meta-rule, and a little additional code to that written for Exercise 7-13, to prevent the same rule from ",NA,NA
being used twice in a row. ,NA,NA
7-15. Convert the appliance-diagnosis program to a decision lattice. Try to minimize the number of questions ,NA,NA
required to a user. ,NA,NA
"7-16. (H,P,G) Write a rule-based system that, given the syllables of an English sentence in phonemic ",NA,NA
"representation, figures out which syllables to stress. Such stress rules are relatively straightforward and can be ",NA,NA
"found in many linguistics books. You'll need list-processing techniques from Chapter 5, and you must worry ",NA,NA
about the order the stress rules are applied. ,NA,NA
7-17. (P) Write a program to give simple navigation commands to a mobile robot moving across a battlefield. ,NA,NA
"Assume the battlefield is divided into squares, designated by integer X and Y coordinates ranging from X=0 to ",NA,NA
X=50 and from Y=0 to Y=50; the robot is not allowed to leave this area. The robot starts at location somewhere ,NA,NA
"on the Y=0 line and it is trying to get to location (50,30). There are impassible bomb craters at (20,10), (10,25), ",NA,NA
"and (20,40), all circles of radius 2. There is an impassible ravine extending along the Y=30 line from X=10 to ",NA,NA
X=50. ,NA,NA
The robot begins moving at time 0. The rule-based system to control it should order one of only four actions: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (35 of 36) [23/04/2002 17:38:56],NA
"move one unit north, move one unit south, move one unit east, and move one unit west. Each move takes one ",NA,NA
unit of time. At time T=15 a bomb crater appears 4 units north of the robot; at T=25 a crater appears 3 units ,NA,NA
west; at T=30 a crater appears 3 units east; and at T=40 a crater appears 4 units east. ,NA,NA
"The robot should not be able to ""see"" craters and ravines until it is just at their edges. But suppose the robot ",NA,NA
"knows the coordinates of the goal location and its current coordinates at all times, so it always knows where it is. ",NA,NA
"Try to specify the robot's actions in general terms, that will work for any configuration of craters and ravines. ",NA,NA
Try your program out with the robot starting at various locations along Y=0. ,NA,NA
"7-18. (E) Like most rule-based expert systems, our appliance diagnosis system doesn't reason about causal ",NA,NA
"chains. In other words, it knows that a certain pattern of symptoms signal an underlying cause, but it doesn't ",NA,NA
know ,NA,NA
why,NA,NA
" the cause leads to the symptoms, the exact chains of cause and effect that explain each particular ",NA,NA
"symptom. For instance, it knows that when a device isn't working at all, there might be a short in the cord; but it ",NA,NA
"doesn't know the reason is that a short causes the resistance of a cord to be significantly lowered, causing a lot of ",NA,NA
"electricity to flow into the cord, causing a lot of electricity to flow through a fuse, causing the metal conductor in ",NA,NA
"the fuse to heat up, causing it to melt, causing the metal to flow, causing it to break the electrical connection, ",NA,NA
"causing no electricity to go to the appliance cord, causing the appliance to not work at all. For what kinds of ",NA,NA
appliances and diagnosis circumstances could this lack of causal-chain reasoning be a problem? (We should use ,NA,NA
a quite different rule-based system then.) In what sense can the appliance expert system of this chapter be seen as ,NA,NA
a simplification of a more general kind of expert system? ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap7.html (36 of 36) [23/04/2002 17:38:56],NA
Representing uncertainty in rule-based systems ,"Numbers are important in most areas of engineering and science. In artificial intelligence, one use of numbers is to quantify the 
 degree
  to which we are certain about something, so we can rank our deductions. This lets us model the world more realistically. 
 We'll show how these kinds of numbers can be easily added to rule-based systems in Prolog, and suggest ways--conservative, 
 middle-of-the-road, and liberal--to manipulate them.",NA
Probabilities in rules ,"Rules in rule-based systems have so far been absolute: when things are absolutely true on the right side of a rule, then the thing 
 on the left side is absolutely true. But in many real-world situations, inferences or even facts are to some degree uncertain or 
 probabilistic. This is particularly true when facts in a rule-based system represent evidence, and rules represent hunches 
 (hypotheses) explaining the evidence. Examples are the diagnosis rules for a car-repair expert system; many diagnoses can't be 
 certain unless the car is taken apart, but suggestive evidence can be found from the way the car behaves. 
  
 Mathematicians have for a long time used probabilities to model degrees of uncertainty in the world. A probability is the 
 fraction of the time we expect something will be true. Other numbers are used in artificial intelligence to represent uncertainty, 
 but probabilities came first, so we'll prefer them here. 
  
 As we mentioned in Section 2.10, we can add probabilities as an last argument to Prolog facts. So to say a battery in a 
 randomly picked car is dead 3% of the time, we can put the fact 
  
 battery(dead,0.03).
  
 in the Prolog database | REFERENCE 1|. .FS | REFERENCE 1| Some Prolog implementations don't allow real (decimal) 
 numbers. If yours doesn't, you can represent probabilities by the integer closest to a million times the probability. So 200,000 
 would represent a probability of 0.2. You'll also have to modify the formulas given later in this chapter so the math will work 
 right. Use 1,000,000 wherever 1 occurs in formulas, and divide all products by 1,000,000, and multiply all two-number 
 quotients by 1,000,000. Addition and subtraction don't have to be modified. 
  
 Also, many Prolog implementations that do handle decimal numbers require digits both before and after the decimal point, so 
 you have to say ""0.03"" instead of just "".03"". We'll do that in this book. .FE We can modify predicate expressions in rules 
 similarly. For instance, if 20% of the time when the car won't start it is true the battery is dead, we could write: 
  
 battery(dead,0.2) :- ignition(wont_start,1.0).
  
 We can write different rules for inference of the same fact from different sources of evidence, each with its own probability. So 
 if 50% of the time when the radio won't play the battery is dead: 
  
 battery(dead,0.5) :- radio(wont_play,1.0).
  
 So if we want to reason about whether the battery is dead, we should gather all relevant rules and facts. Then somehow we must 
 combine the probabilities from facts and successful rules to get a cumulative probability that the battery is dead. This we call the 
 or-combination
  issue with probabilities, since you can think of rules with the same left-side predicate name as an implicit ""or"". 
  
 A second issue is that rules can be for a different reason than facts. Consider the preceding rule for the likelihood the battery is 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap8.html (1 of 20) [23/04/2002 17:38:59]",NA
Some rules with probabilities ,"To show the flexibility of probabilities in rules, here are some examples. Suppose 6 times out of 10 when the car won't start, 
 the battery is dead. Then: 
  
 battery(dead,0.6) :- ignition(wont_start,1.0).
  
 The 0.6 here is a 
 conditional probability
 , a probability something happens supposing something else happens. But we could also 
 treat the right-side expression as something that couldn't possibly be uncertain, something that is either true or false. Then we 
 could write the rule with a probability only on the left side: 
  
 battery(dead,0.6) :- ignition(wont_start).
  
 Now suppose the car won't start, and we measure the battery voltage with a voltmeter. Suppose we're not skilled at using a 
 voltmeter. The following rule would apply: 
  
 battery(dead,P) :- voltmeter(battery_terminals,abnormal,P).
  
 This says that the battery is dead with the same probability that the voltmeter measurement is outside the normal range. Not 
 being skilled, we might not be measuring the voltage properly (the terminals might be reversed, or the range setting on the 
 voltmeter might be too low or too high, causing us to incorrectly read no voltage). So the uncertainty of the voltmeter 
 measurement is reflected in the conclusion. Note if 
 P
  is 1 (if we are completely sure of our voltmeter measurement) then 
 P
  is 1 
 for the battery being dead too. 
  
 Suppose we want to rewrite the preceding rule to ignore very weak evidence for the conclusion; this will help avoid 
 unnecessary computation on insignificant things. We can put in an arithmetic comparison: 
  
 battery(dead,P) :- voltmeter(battery_terminals,abnormal,P),
  
  P > 0.1.
  
 This says that if the voltmeter reading is outside the normal range with probability 
 P
 , and 
 P
  is more than 0.1, then the battery is 
 dead with that same probability 
 P
 . 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap8.html (2 of 20) [23/04/2002 17:38:59]",NA
Combining evidence assuming statistical independence ,"The last section shows that combining probabilities in rule-based systems is very important. Surprisingly, there is no fully 
 general mathematical approach to combining; the problem can be proved mathematically intractable. But we can give some 
 formulas that hold under particular assumptions, and most artificial-intelligence work follows this route. Alas, people make 
 frequent mistakes with probabilities, as shown by experiments, so it's a bad idea to look for guidance from the way people 
 reason. 
  
 The easiest assumption we could make is that the different forms of evidence are probabilistically independent. That is, 
 occurrence of one kind of evidence does not make another kind any more or less likely. This situation often happens when the 
 evidence comes by very different reasoning methods, and can't ""interact"". For instance, suppose we are writing an expert 
 system to give advice about stock-market investments. We might have two rules: 
  
 1. If a quarterly report on economic indicators today says that interest rates will go up this year, then the stock 
 market index will go down tomorrow with probability 0.7. 
  
 2. If the stock market index has gone up for three straight days, it will go down tomorrow with probability 0.4. 
  
 These two rules reflect quite different phenomena. So the success of the first rule won't make us believe the second is any more 
 likely to succeed on the same day, and vice versa. (Maybe there is a little bit of influence--a stock market going down a lot 
 might indirectly cause interest rates to go up--but the connection is pretty weak.) That's what we mean by statistical 
 independence. 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap8.html (3 of 20) [23/04/2002 17:38:59]",NA
"Prolog implementation of independence-assumption ""and-combination"" ","We can define a predicate that implements the preceding independence-assumption ""and-combination"" formula. It will take 
 two arguments: an input list of probabilities, and an output number for the combined probability. 
  
 indep_andcombine([P],P).",NA
"Prolog implementation of independence-assumption ""or-combination"" ","The remaining issue discussed in Section 8.1 was ""or-combination"" of probabilities. Independence-assumption ""or-
 combination"" can be defined analogously to independence-assumption ""and-combination"" but using the last formula in Section 
 8.3: 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap8.html (5 of 20) [23/04/2002 17:38:59]",NA
The conservative approach ,NA,NA
The liberal approach and others ,"There's also a 
 liberal
  approach: compute the maximum probability consistent with the evidence. This isn't as useful as the 
 ""conservative"" approach, but applies for ""and""s whenever one piece of evidence implies all the others, and applies for ""or""s 
 whenever pieces of evidence are disjoint (i.e., prove the same conclusion is ways that cannot hold simultaneously). Liberal 
 formulas can be derived from the conservative formulas by relating ""and"" and ""or"", as with the formula for two variables: 
  
 p ( A   ""or""   B ) = p ( A ) + p ( B ) - p ( A   ""and""   B)
  
 which can also be written 
  
 p ( A   ""and""   B ) = p ( A ) + p ( B ) - p ( A   ""or""   B)
  
 Since |p ( A )| and |p ( B )| are known, the maximum value of the first formula occurs when |p ( A ""and"" B)| has a minimum, 
 and the maximum of the second formula occurs when |p ( A ""or"" B)| has a minimum (note the important minus signs). These 
 needed minima are given the conservative formulas. So the liberal bound on two-argument ""or""s is 
  
 p ( A ) + p ( B ) - maxfunction ( p ( A ) + p ( B ) - 1 , 0 )
  
 = - maxfunction ( -1 , - p ( A ) - p ( B ) ) = minfunction ( 1 , p ( A ) + p ( B ) )
  
 and the liberal bound on ""and""s is",NA
Negation and probabilities ,NA,NA
An example: fixing televisions ,"Now we'll give an example of a simple rule-based expert system using probabilities, for diagnosis of malfunctioning 
 equipment. Unfortunately, most expert systems (like most artificial intelligence programs) must be big to do anything 
 worthwhile; otherwise, human beings could do the job fine without them. So to avoid burdening you with an example ten 
 pages long, we must pick something simple and not very useful. So here's an example of the few things wrong with a 
 television set that you can fix yourself (television sets use high voltages so most malfunctions should be treated by trained 
 service personnel.) 
  
 When a television set is working improperly, one of two things may be improperly adjusted: the controls (knobs and switches) 
 or the receiver (antenna or cable). So let's write an expert system to estimate probabilities of those two things. We'll assume 
 these probabilities need not be very accurate, but their relative sizes provide a rough guide to where things are wrong. 
  
 Consider why the knobs might be adjusted wrong on a television. If it is old and requires frequent adjustment, that could be a 
 reason. Similarly, if kids use your set, and they play with the knobs, that could be a reason too, as well as anything strange 
 you've done lately that required adjustment of the knobs (like taking a photograph of the television picture, requiring that the 
 brightness be turned up very high). Let's write the rules. If a set requires frequent readjusting, then it's quite reasonable that the 
 set is maladjusted today--let's say 50% sure: 
  
 maladjusted(0.5) :- askif(frequent_adjustments_needed).
  
 (The 
 askif
  predicate was defined in Section 7.3; it types out a question for the user, and checks if the response is positive or 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap8.html (10 of 20) [23/04/2002 17:38:59]",NA
Graphical representation of probabilities in rule-based systems ,"The logic-gate representation of an and-or-not lattice (see Section 6.10) is a useful graphical notation for simple rule-based 
 systems. It can be used for rules with probabilities too. Associate every ""andcombine"" and ""orcombine"" with a logic gate in the 
 representation. Indicate rule strengths next to their corresponding logic gates. For rules with only one expression on their right 
 side, use special triangle gates (
 attenuators
 ) with one input and one output. Then each line has an associated probability, 
 computed by proceeding from the inputs through the network, applying the proper formula at each gate. Figure 8-4 shows the 
 and-or-not lattice for the example of the last section.",NA
Getting probabilities from statistics ,"There's a more fundamental problem with probabilities than combining them, however: getting them in the first place. If 
 probabilities are markedly incorrect, reasoning based on them can't be trusted. But getting good probabilities is often the hardest 
 problem in building a rule-based system. Even when programmers can easily decide what the predicates should be, what things 
 rules should cover, and how rules should be structured, they often have trouble estimating probabilities because it's hard to tell 
 when an estimate is wrong. Two approaches are used: getting probabilities from statistics on data, and getting probabilities from 
 human ""experts"". 
  
 Since people reason poorly about uncertainty, the first approach seems preferable. Often we have a lot of routinely-collected 
 data about the phenomena in a rule-based system, as when our rule-based system further automates human capabilities already 
 partly automated. We can approximate needed probabilities by frequency ratios in the data. For instance, we can approximate 
 rule-strength probabilities by the ratio of the number of times the left side of a rule was satisfied to the number of times the right 
 side was satisfied. 
  
 As an example, consider the repair of airplanes. They are expensive, so an organization that owns many of them must keep 
 detailed repair and maintenance records to ensure quality work, to better allocate resources, and to track down trends in",NA
Probabilities derived from others ,"If a probability is important to our rule-based system, yet the associated standard error of approximation from data is large, we 
 may be able to better estimate the probability from other data. One way is Bayes's Rule. Letting |p ( A given B )| represent the 
 probability of event A happening when event B also happens, we can say: 
  
 p ( A   given   B ) = { p ( A   ""and""   B ) }   /   {  p ( B ) }
  
 But switching A and B in that equation: 
  
 p ( B   given   A ) = { p ( A   ""and""   B ) }   /   {  p ( A ) }
  
 We can solve the second equation for |p ( A ""and"" B )|, and substitute in the first equation, obtaining the usual form of Bayes's 
 Rule: 
  
 p ( A   given   B ) = { p ( B   given   A ) * p ( A ) }   /   { p ( B ) }
  
 This is a useful when we have a rule 
  
 a(P) :- b(P2), andcombine([P2,<strength>],P).
  
 and we want to know what number to put for 
 <strength>
 , the probability that 
 a
  is true given that 
 b
  is true. If we have enough 
 data to compute the reverse--the probability that 
 b
  is true given that 
 a
  is true--then Bayes's Rule can use that number, together 
 with estimates of the overall probabilities of 
 a
  and 
 b
 , to give what we need. This is an especially good idea when 
 a
 causes
 b
 , 
 because then the reverse probability that 
 b
  is true given that 
 a
  is true must be 1.0. For instance, a car absolutely will not start 
 when its battery is dead, so we can approximate the probability that the battery is dead when the car won't start by the ratio of: 
 the overall probability the battery is dead over the overall probability the car won't start.",NA
Subjective probabilities ,"Even with these tricks we may not have enough data (or perhaps good enough data) to approximate probabilities very well. 
 Then we must guess probabilities ourselves, or preferably, ask a human expert in the task or domain of the rule-based system. 
  
 This isn't always easy: experts may be hard to find, or their time may be expensive, or they may not understand or feel 
 comfortable with a rule formulation of their knowledge. But there may be no other choice. 
  
 As we've said, humans make many mistakes in probability estimation, as demonstrated by psychological experiments. One 
 simple way to make things easier is to let people quantify uncertainty on a different numeric scale than 0.0 to 1.0. For instance, 
 take 
 degrees of certainty
  on a scale 0 to 100, and divide by 100 to get the probability. Better yet, do a nonlinear transformation 
 of the probability scale, for instance with 
 odds
  defined as |p / ( 1 - p )|. Odds range from 0 to positive infinity, so a probability of 
 0.9 is odds of 9, a probability of 0.5 is odds of 1, and a probability of 0.1 is odds of 0.111. The logarithm of the odds is also 
 useful; it ""flattens out"" the curve more, and ranges from minus infinity to plus infinity. 
  
 Something that also helps people is speaking of uncertainty nonnumerically. For instance, let them use the terms ""certain"", 
 ""almost certain"", ""likely"", ""suggestive"", ""possible"", ""not likely"", and ""impossible"". Each term may map to a probability--say 
 1.00 for ""certain"", 0.99 for ""almost certain"", 0.8 for ""likely"", 0.5 for ""suggestive"", 0.2 for ""possible"", 0.05 for ""not likely"", and 
 0.0 for ""impossible"". If this isn't possible, perhaps different probabilities can be given for different contexts, so a ""possible car 
 problem"" would be a 0.2 probability, but a ""possible nuclear accident"" would be 0.001 probability.",NA
Maximum-entropy probabilities (*) ,"Bayes's Rule extends the utility of both statistics and subjective probability estimates. We can generalize this idea, to accept 
 arbitrary probabilities from the programmer--prior probabilities, conditional probabilities, and joint probabilities--and make 
 ""reasonable guess"" estimates of others, using some mathematics. 
  
 It can be shown mathematically that best guesses (based on certain postulates for guess desirability) are those that maximize 
 entropy, or minimize the 
 information content
 , of probability assignments. This is a mathematical optimization problem, in 
 which we want to maximize 
  
 sum from {i=1} to m left ( - p ( A sub i ) log ( p ( A sub i ) ) right )
  
 for some mutually exclusive set of probabilities |p ( A sub i )| that sum to 1, subject to given equality constraints in the form of 
 probabilities already known. Optimization problems like this can be attacked by many methods from operations research, and 
 computer packages are available. But they can take time since they usually iterate.",NA
Consistency (*) ,"Another problem with subjective probabilities (but also to a lesser extent with data-derived probabilities) is that they can be 
 inconsistent (logically impossible) in a nonobvious way. This often happens when both a priori (unconditional) and conditional 
 probabilities are specified by people. We should therefore run checks on user-given probabilities before entering them into a 
 rule-based system. 
  
 As an example, note from the definition of conditional probability that 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap8.html (15 of 20) [23/04/2002 17:38:59]",NA
Keywords: ,"probability 
  
 uncertainty 
  
 or-combination 
  
 and-combination 
  
 rule probability 
  
 conclusion probability 
  
 independence assumption 
  
 conservative assumption 
  
 liberal assumption 
  
 Bayes's rule 
  
 scale transformations 
  
 maximum-entropy estimates
  
 .SH Exercises 
  
 8-1. Assume: 
  
 1. The battery is defective with certainty 0.5 when a car won't start. 
  
 2. The battery is defective with certainty 0.8 when the radio is functioning and the radio won't play. 
  
 3. You are not sure if your radio is functioning--the probability is 0.9 that it is functioning. 
 4. This morning your car won't start and the radio won't play. 
  
 What is the cumulative probability that your battery is defective this morning? Combine evidence assuming independence of 
 probabilities. 
  
 8-2. Consider these rules (the arguments are all probabilities):",NA
Search ,"It's time for a change of pace. In this and the next two chapters, we'll cover a new class of artificial intelligence techniques. 
  
 These are good for reasoning about events in time and plans of action. Technically, ""search"" | REFERENCE 1|. .FS | 
 REFERENCE 1| Also called 
 heuristic search
 , but that's misleading because you don't need heuristics to do it, and anyway the 
 term ""heuristic"" is overused and much abused in artificial intelligence. .FE We'll need a new vocabulary to talk about search 
 problems--terms like ""state"", ""operator"", ""search strategy"", ""evaluation function"", and ""branching factor"". 
  
 Search problems appear in many application areas. Search relates to rule-based systems because they involve actions 
 occurring over time. In fact, search is an abstraction of the concept of a control structure. So we'll be looking at rule-based 
 systems in a new way.",NA
Changing worlds ,"So far the facts in Prolog databases have rarely changed. We added facts through caching in forward chaining, but those facts 
 were logically derivable from the other facts and rules all along. We rarely removed facts from a Prolog database--only in 
 implementing a few special programs. 
  
 But Prolog databases usually model a situation in the world, and the world can change. In fact, the result of running an 
 artificial intelligence program may be to recommend actions in the world, which are then taken, and then reflected in changes 
 to the facts true about the world. Often an artificial intelligence program is useless unless it does change something in the 
 world. For instance, an automobile diagnosis program is not much help unless you can actually fix a car by its 
  
 recommendations. 
  
 In many important applications, a problem can be solved only by a series of actions, not just one. Then the problem must 
 track the changing situation in the world. Changing the facts appropriately can be complicated for such problems, and we 
 need some new tricks.",NA
States ,"A situation in the world described by some facts is a 
 state
 . State is a fundamental concept in many areas of science and 
 engineering. For instance, in physics a state is a set of measurable physical parameters fully describing some part of the 
 universe; in simulation models of economics, a state is the set of values assigned to model parameters; and in computer 
 systems programming, a processing state is a set of values currently in registers, buffers, and stacks. So a state is a ""snapshot"" 
 of a process in time. 
  
 A state can be instantaneous or it can last for quite a while. In artificial intelligence (and computer science too) we only 
 concern ourselves with non-instantaneous states, but where state changes (
 branches
  or 
 transitions
 ) are instantaneous. That is, 
 state changes are 
 discrete
  and not 
 continuous
 . Loading a computer register is an example of a discrete state change. 
 Search
  is 
 the study of states and their transitions. 
  
 A state must include everything important about a situation in one bundle | REFERENCE 2|. .FS | REFERENCE 2| At least the 
 states in this book. To make things easier, we deliberately ignore a class of searches performed using and-or-not lattices, for 
 which states represent pieces of a problem. See other books under the topic of ""searching and-or trees"". .FE That means 
 everything necessary to reason about it--and in artificial intelligence, that usually means a list of facts. These may be a lot of 
 facts, and often we'll want to reason about many states, as when we try to figure how to achieve some desirable state. So two 
 tricks often simplify state descriptions. First, we can keep only the facts relevant to the very specific problem we're working",NA
Three examples ,"Let's consider some examples of search problems. First, consider the problem of getting by car from one intersection to 
 another in a city. There are different streets that you can take and different turns you can make. To complicate matters, some 
 streets are one-way, and some turns are illegal. Also, you will probably want a short route rather than just any route. 
  
 Considering this a search problem, a state s ithe position of a car in a city. We can represent this as the name of the 
 intersection, since intersections are the only places where decisions must be made, and therefore the only locations that 
 matter to reasoning. Solving a search problem means finding a series of states ending in some desired state, so the solution 
 will be a sequence of intersections a car will traverse in order. 
  
 As a second example of search, consider the problem of car repair. Even if you know what's wrong, repair is rarely as simple 
 as yanking the old part out and sticking the new part in. Usually you must unloosen fasteners (like screws and nuts) first, and 
 move other parts out of the way to get to the part you want. You may need to run some tests on the suspect part to see if it is 
 indeed faulty. Then you must reassemble the whole mess, doing the reverse of the previous steps in the reverse order--and 
 sometimes exact reversal is impossible, as when removing a cover is easy but refastening requires careful hole alignment. You 
 must also worry about the difficulty of various actions, if you want to get the job done efficiently; a sequence of actions that 
 take half as much effort as another is better. For this problem, states are situations of partial disassembly (or assembly) of the 
 car. 
  
 As a third example, consider the problem of smarter forward chaining for a rule-based expert system. Section 6.2 presented a 
 simple general-purpose approach to forward chaining, using simple ideas like putting facts in a priority list in the order we find 
 them (the focus-of-attention strategy). These ideas work for a wide class of applications. But for a specific application, a 
 specific conflict-resolution policy may be better. For instance, we can keep the facts sorted by priorities of human experts (the 
 experts' prestored hunches of relative importance), by our own analysis of the rules (like how many new conclusions a fact can 
 lead to), by statistics on past runs of the rule-based system, or by dynamic features of the reasoning (like whether a certain fact 
 has been proved yet). In general, intelligent forward chaining by intelligent fact sorting is a search problem with many options, 
 each representing a fact to pursue, each leading to a different set of facts to choose from next, and so on. So a state for this 
 problem is a set of unpursued (and perhaps also pursued) facts. 
  
 We'll use these examples subsequently in the chapter. They were picked to symbolize three important applications of search: 
 optimization problems, human and robot task planning, and expert systems.",NA
Operators ,"Our three examples involve many states. They can involve even more branches, ways directly from one state to another. It 
 helps to group branches into categories called 
 operators
 . Operators often correspond to verbs of English, the names of real-
 world actions. 
  
 Consider the three examples: 
  
 1. For finding routes in a city, the operators are possible actions at an intersection, since states correspond to 
 intersections. So the operators are ""go straight ahead"", ""turn right"", ""turn left"", ""turn into the first street to your 
 right"", ""turn into the second street to your right"", etc. 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (2 of 20) [23/04/2002 17:39:04]",NA
Search as graph traversal ,"The main reason for identifying states and operators is to let us plan in advance a solution to a search problem. By reasoning 
 hypothetically about operator sequences, we can avoid blundering about in the real world. Planning can also ensure that we 
 find the 
 best 
 solution to a problem, not just any solution. 
  
 For such advance planning, we can consider a search problem as a task of traversing a directed-graph data structure. Semantic 
 networks (see Section 2.7) are one kind of directed graph important in artificial intelligence, but there are several others too. 
 Graphs consist of nodes (small named circles) and directed edges (named arrows) connecting nodes; we can equate nodes 
 with states, the names on directed edges with operator names, and edges themselves with branches or operator applications. 
 In a search problem, we are given a 
 starting
  state and one or more finishing or 
 goal
  states. On the search graph this means 
 finding a path or traversal between a start node and one of a set of goal nodes. (Here we broaden the term ""goal"" beyond its 
 meaning for rule-based systems, in which a ""goal"" is a predicate expression we want to prove; in search, a ""goal"" is any 
 desired final state.) 
  
 Figure 9-1 shows an example route-planning problem. As we said, city-route planning is a search problem for which the 
 states are intersections (intersections are the only places where we must make choices). Then a search graph can be drawn as 
 in Figure 9-2. There is just one goal state. 
  
 Figures 9-3 and 9-4 show similar example search graphs for the auto repair and the smarter forward chaining problems. The 
 latter is interesting because we don't know the goal state in advance: we just keep searching until there are no more facts to 
 pursue, and that's a goal state. If we knew what a goal state was in advance, we wouldn't need to do any work. An important 
 class of search problems similarly defines goal states indirectly, in that they only can recognize one when they see one.",NA
The simplest search strategies: depth-first and breadth-first ,"There are many control structures for search; these 
 search strategies
  are summarized in Figure 9-5. The two simplest are 
 depth-first search and breadth-first search. 
  
 With depth-first search, the start state is chosen (
 visited
 ) to begin, then some 
 successor
  (a state that we can reach by a single 
 branch or state transition) of the start state, then some successor of 
 that 
 state, then some successor of that, and so on until we 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (3 of 20) [23/04/2002 17:39:04]",NA
Heuristics ,"Depth-first and breadth-first search are easy to implement but often inefficient for hard problems. A top concern of artificial 
 intelligence research has been finding better search strategies. Many of these better strategies are related to depth-first and 
 breadth-first search. Two common variants are search using heuristics and search using evaluation functions. 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (4 of 20) [23/04/2002 17:39:04]",NA
Evaluation functions ,"A big difficulty with heuristics is disagreements between them, situations for which two heuristics make contradictory 
 recommendations. If one heuristic is known to be better than the other, then it should have priority, but the two can seem 
 equally good. If such difficulties arise frequently, it's better to rate states numerically. A method for calculating such numbers 
 is called an evaluation function. By convention the values of evaluation functions are nonnegative numbers such that the 
 smaller the number, the better the associated state; and goal states have an evaluation function value of zero. Evaluation 
 functions can be in any form and can use any available information about a state; they can also use a description of the goal 
 states. (However, it's desirable that evaluation functions be ""smooth""; that is, if they're calculated using numbers, they 
 shouldn't ever jump abruptly in value when the numbers vary slightly.) 
  
 Some example evaluation functions: 
  
 --For city route planning, take the straight-line (""as the crow flies"") distance between an intersection and the 
 goal intersection (that is, prefer the successor state closest to the goal state along a straight line). 
  
 --For city route planning, take the straight-line distance to the goal plus one tenth of the number of streets 
 crossed by that straight line (this helps you avoid stop signs and traffic lights). 
  
 --For car repair, take the number of parts removed from the car plus the number of faulty parts in the car (this 
 will increase in the first half of the solution, but will decrease in the last half, and should be kept small 
 anyway). 
  
 --For smarter forward chaining, take the number of right-side expressions in rules minus the number of facts 
 (proved and given) in some state. (This isn't likely to approach zero, but it does guide search helpfully.) 
  
 Evaluation functions make possible two new search strategies, summarized on the third and fourth rows in Figure 9-5. The 
 evaluation-function variant of depth-first search is called 
 hill-climbing
  (or sometimes 
 discrete optimization
 ) search; the 
 evaluation-function variant of breadth-first search is called 
 best-first
  search. However, best-first usually has an additional 
 twist beyond breadth-first: the best-evaluation (lowest-evaluation) state of those 
 anywhere 
 in the search graph, of those 
 whose successors have not yet been found, is picked, not just a state at the same level as the last state. So best-first search 
 usually ""jumps around"" a lot in the search graph, always picking the minimum-evaluation state of all the unvisited states it 
 knows about. 
  
 To illustrate best-first search, take the search graph of Figure 9-6 and assume the evaluation function values shown as circled 
 numbers in Figure 9-7: S:12, A:7, B:8, C:8, D:6, E:4, F:7, H:4, I:5, J:2, G:0, and K:1. (Ignore the numbers in 
 squares 
 and the 
 numbers beside the arrows for now.) As before, assume S is the starting state and G is the only goal state. Best-first search 
 would start with S, and would find and evaluate its successors A, B, and C, to discover that A is the minimum-evaluation one. 
 So A is picked next, and its successors D and E evaluated. The states not yet examined to find successors (
 visited
 ) are D, E, B, 
 and C, with evaluation function values 6, 4, 8, and 8 respectively. E is the best, but it has no successors; D is the second best, 
 but it has no successors. 
  
 We've got a tie between the two remaining unexamined states, B and C. In such cases, heuristics can decide (and perhaps for 
 near-ties too). Assuming the vertical ordering heuristic used with the depth-first and breadth-first examples in Section 9.6, B 
 should be picked next. But it has no successors, so C must be picked. It has one successor, F. F has two successors, H and I, 
 with evaluation function values 4 and 5. The 4 is better, so H is better, and is picked next. H has successors J, G, and K with 
 evaluation function values 2, 0, and 1. But G is a goal state, so we can stop. In summary, best-first search examined the states 
 in the order S, A, E, D, B, C, F, H, G. That's different from both depth-first and breadth-first.",NA
Cost functions ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (6 of 20) [23/04/2002 17:39:04],NA
Optimal-path search ,"A search that must find the lowest-cost (
 optimal
 ) path to a goal state, instead of just any path, needs a different search strategy 
 from those so far considered. If we have a cost function but no good evaluation function and no good heuristics, we can use 
 branch-and-bound
  search (see Figure 9-5). It's like best-first search but using costs instead: it always finds successors of the 
 state whose path has lowest total cost from the start state. Such a strategy may ""jump around"" among states as best-first search 
 does, but it has a nice property: the first path to the goal that it finds is guaranteed to be the lowest-cost path to the goal. 
  
 If we have both cost and evaluation functions, we can use an 
 A* search
  strategy (that's pronounced ""A-star""). The idea is to 
 sum the cost and evaluation function value for a state to get a measure of overall worth, and use these numbers to select states 
 in a best-first search algorithm instead of just the evaluation function values. (This sum makes most sense when the cost 
 function and evaluation function are in the same units.) So A* search is sort of a hybrid of best-first (using an evaluation 
 function) and branch-and-bound search (using a cost function), incorporating information from both, and often giving better 
 performance than both. As with branch-and-bound search, a certain guarantee applies to a solution found by A* search: if the 
 evaluation function value for any state S is always no more than the subsequently found cost from S to the goal, then the first 
 path to the goal found by A* search is the lowest-cost path to a goal. But A* is often still a good search strategy even when the 
 guarantee doesn't hold. 
  
 Suppose we use the A* strategy instead of best-first on the search graph of Figure 9-7. Recall that the numbers in circles are 
 the evaluation function values of states. Suppose the costs for path segments are shown by the numbers next to the arrows: 4 
 for A to S, 1 for A to D, 2 for A to 3, 1 for S to B, 2 for S to C, 1 for C to F, 3 for F to H, 1 for F to I, 1 for H to J, 2 for H to 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (7 of 20) [23/04/2002 17:39:04]",NA
A route-finding example ,"To better illustrate the differences between search programs, we show results from a program for one of our three standard 
 examples, finding city routes. Figure 9-8 shows a portion Monterey, California, USA for which we stored street-intersection 
 coordinates. The problem was to go from the the point marked ""start"" to point marked ""goal"". The evaluation function was the 
 straight-line distance to the goal (computed from approximate coordinates of each intersection), and the cost function was the 
 distance along the route (computed by summing straight-line distances between successive intersections). Shown on the map 
 are the results of three search strategies: breadth-first, best-first, and A* search. As you can see, the paths are different: A* 
 finds the shortest path, breadth-first minimizes the number of intersections, and best-first tries to keep moving towards the 
 goal. (Though not shown on the map, depth-first search wanders around stupidly.)",NA
Special cases of search ,"Certain tricks sometimes make search problems easier. One trick often possible is reversing the search, working backward 
 from goal states to start states. For instance: 
  
 --for city route planning, find a path from the destination to the start; 
  
 --for car repair, solve the first half of the job by reasoning from the part P that must be fixed, deciding what 
 other part P2 needs to be removed to get to P, what other part P3 must be removed to get to P2, and so on. 
  
 This does require you to know beforehand all goal states, something not possible for the smarter forward chaining problem 
 and other important problems, in which finding a goal state is the whole point of the search (though backward chaining does 
 represent something like a reverse of forward chaining). If you know more than one goal state, you can either try reverse 
 search with each in turn, or make all the goal states the starting set of ""unexamined"" states for those strategies that use them. 
  
 Backward search generally requires different 
 reverse
  operators from the forward search operators. For instance in city route 
 planning, the reverse of a right-turn operator is a ""backward left-turn"" operator. So the solution to the backward search can be 
 different from the solution to the forward search even if the same heuristics, evaluation function, and/or cost function are used. 
 Fortunately in many search problems, the backward operators 
 are 
 identical to the forward operators, as in route planning on a 
 larger scale, planning of routes between cities. 
  
 Whenever backward search is good, an even better idea is parallel forward and backward search on the same problem--
 bidirectional search
 . Run both searches independently (either on two processors or time-sharing on a single processor), and 
 stop whenever they meet (or reach the same state). As illustration, compare the top and middle diagrams in Figure 9-9. 
 Bidirectional search often finds a solution much faster than either forward or backward search alone, because the number of 
 search states usually increases quickly as we move farther from the starting point, and with two searches we're searching half 
 as deep. But it does have a serious danger: if we use a poor search strategy for both searches, like best-first with a poor 
 evaluation function or, often, or depth-first search, the two searches may ""bypass"" one another instead of meeting in the 
 middle. 
  
 Another trick we can often use to make search easier is 
 decomposition
 , breaking the search problem into several simpler sub-
 searches, each of which can be solved independently. This usually means finding an intermediate state through which the 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (8 of 20) [23/04/2002 17:39:04]",NA
How hard is a search problem? ,"It helps to know the difficulty of a search problem before tackling it so you can allocate time and space resources. Sometimes 
 what seems an easy problem can be enormously difficult, or a problem very similar to a really difficult one can be easy. So 
 people try to estimate the number of states that need to be studied to solve a search problem. Two methods can do this: 
 bounding the size of the search space, and calculating the average 
 branching factor
  or 
 fanout
  of successive states. 
  
 The first method takes an upper bound on the number of states that need to be examined to solve a problem as the number of 
 possible states in the entire problem. This set of all possible states is called the 
 search space
 , and what's needed is the size of 
 the search space. (Don't confuse the term ""search space"" with the amount of memory needed to search: ""space"" is used 
 abstractly here, the way mathematicians use ""vector space"".) For some problems, the size of the search space is easy to see 
 from the description of the problem, as for city route planning in which it's the number of intersections in the city, something 
 we can count. For other problems, we can use what mathematicians call 
 combinatorial methods
 . For instance, for car repair we 
 can describe the condition of every part in the car as either in the car and faulty, in the car and OK, out of the car and faulty, or 
 out of the car and OK. So if there are 1000 parts in the car, the size of the search space is 4 to the 1000th power--a lot! That 
 means heuristics or an evaluation function are necessary to solve this problem, because we'll never succeed if we try operators 
 at random. 
  
 The size-of-the-search-space method of estimating search difficulty can't always estimate the size of the search space so easily, 
 as in smarter forward chaining when we can't tell in advance which or even how many facts we'll prove. Also, the method 
 calculates only an upper bound on difficulty. Alternatively, we can reason how the number of states increases with each level 
 of search, and figure how many levels deep we'll go. The number of successors (usually, previously unvisited successors) of a 
 state is called its 
 branching factor
 . (Caution: don't confuse the branching factor with the number of 
 operators 
 that can generate 
 successors, a smaller number.) If the branching factor doesn't differ much between states, we can speak of an 
 average 
 branching factor
  for the whole search problem. Then we can estimate the number of states at level K in the search graph as |B 
 sup K|, B the average branching factor. Notice that this exponential function gets large very fast as K increases--the so-called 
 combinatorial explosion
 . So if we can estimate the level of a goal (the number of states from the starting state to",NA
Backward chaining versus forward chaining (*) ,"Analysis of search-problem difficulty lets us quantify for the first time differences between the control structures discussed in 
 Chapter 6. Take for instance this rule-based system: 
  
 t :- a, b.
  
 t :- c.
  
 u :- not(a), c.
  
 u :- a, d.
  
 v :- b, e.
  
 And further assume the facts 
 a
 , 
 e
 , and 
 d
  only are true, and given in that order. 
  
 Backward chaining will try the first three rules, which fail, and then the fourth, which succeeds. Basic backward chaining 
 without caching involves eight total queries: top-level predicates 
 t
  and 
 u
 , 
 a
  (which succeeds), 
 b
  (which fails), 
 c
  (which fails), 
 a
  
 again (which succeeds), 
 a
  again, and finally 
 d
  (which succeeds). The time to do this is approximately proportional to the 
 number of queries made because each query requires an index lookup of nearly-equal time.",NA
Using probabilities in search (*) ,"Since probabilities are numbers, they can guide hill-climbing, best-first, branch-and-bound, and A* searches. For instance, 
 the probability that a state is on a path to a goal can be used as an evaluation function. Or in search during forward chaining, 
 facts can be ranked for selection by one million minus the reciprocal of their a priori probability, so unusual facts are 
 followed up first. In backward chaining using rules with uncertainty like those in Chapter 8, rules can be selected by the 
 reciprocal of their rule strength (the rule strengths being the probability of their conclusion under the most favorable 
 conditions.)",NA
Another example: visual edge-finding as search (*) ,"Computer vision is an important subarea of artificial intelligence. It's complicated, and its methods are often quite 
 specialized, since two-dimensional and three-dimensional information seems at first to be quite different from predicate. But 
 it also exploits many of the general-purpose techniques described in this book, including search. 
  
 One role search plays is in edge finding and edge following, as a kind of ""constructive"" search that actually builds something 
 as it performs a search. Most computer vision systems start from a digitized image, a two-dimensional array representing the 
 brightness of dots in a television picture. The picture is first ""cleaned up"" and ""smoothed out"" to make it easier to analyze, 
 using some mathematical tricks. Any remaining sharp contrasts between adjacent parts in the picture are important--contrasts 
 in brightness, color, and the ""grain"" or 
 texture
  of small adjacent regions. These contrasts can be used to make a line drawing (a 
 drawing consisting only of lines) of the picture, where lines correspond to boundaries of high contrast between regions of 
 mostly-homogeneous characteristics; the lines are called 
 edges
 . So a line drawing can be a kind of data compression of the 
 original picture. Line drawings provide a basis for most visual analysis techniques, techniques that try to figure out what the 
 picture is showing. 
  
 But edge-finding isn't as easy as it may seem. The problem is that for various reasons, things in the real world that you'd think 
 would make edges don't. Consider Figure 9-12. Different surfaces may coincidentally be the same brightness and color along 
 part of their edge, or an edge may lie in shadow, or glares and reflections may cover the edge, or the resolution of the picture 
 may be insufficient to pick up small details of edges. So usually only some edges and parts of edges in a picture can be 
 recognized, meaning line drawings with gaps. Human beings can easily fill in these gaps, because they have strong 
 expectations about what they will see and their vision automatically fills in details. But computers must be taught how. 
  
 A good first step is to quantify the ""edgeness"" of each dot in the picture. Several mathematical formulas can be used, but we'll 
 show here a simple one that only examines the brightness of its cell and its immediate neighbors. (Edges between regions of 
 different color can be found by looking at brightness of the picture viewed through colored filters.) Suppose we represent the 
 picture as a two-dimensional array |b ( i , j )| of numbers representing light intensities. Then the 
 magnitude of the gradient
  for 
 each dot is defined as: 
  
 g ( i , j )   =   sqrt { ( b ( i+1 , j ) - b ( i-1 , j ) ) sup 2 +
  
 ( b ( i , j+1 ) - b ( i , j-1 ) ) sup 2 }
  
 This is a measure of ""edgeness"" for every dot. The larger this number is, the more the brightnesses around some dot in the 
 picture differ among themselves. 
  
 Now we're ready to formulate edge finding as a search problem. A state can be represented as a two-dimensional bit array |e ( i 
 , j ) | (that is, an array of things with Boolean or true/false values) with an entry for every dot in the picture. A ""true"" means 
 that in the corresponding picture, the dot lies on an edge; in the starting state, every dot is marked ""false"". A branch between 
 states changes a single element from ""false"" to ""true"", meaning we've decided an edge is there. There's only one operator: mark 
 |e ( i , j )| as ""true"" for some i and some j. Figure 9-13 gives an example interpretation problem. The upper part shows an array 
 of edgeness measures |g ( i , j )|, and the lower part shows a reasonable assignment of edges |e ( i , j )| to the 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (12 of 20) [23/04/2002 17:39:04]",NA
Exercises ,"9-1. (E) Explain why none of the following are states as we define the term for search. 
  
 (a) All the important events that happen in an organization in one day. 
  
 (b) The current temperature of a room. 
  
 (c) The mental condition of a person's mind. 
  
 9-2. (A,E) Explain how using inheritance to find a value of the property of some object is a kind of search. 
  
 9-3. The search graphs in this chapter have all been 
 planar
 --that is, none of the branches crossed. Is this necessarily true of all 
 search graphs? 
  
 9-4. (a) Modify the description of the algorithm for pure forward chaining, given in Section 6.2, to work in a breadth-first 
 way. 
  
 (b) Explain how a breadth-first backward chaining might work. 
  
 9-5. Consider the problem of driving by car from one place in a city to another. Assume you do not know the way. Consider 
 this as a search problem with three operators: 
  
 A: travel to the next intersection and keep going straight, if legal 
 B: travel to the next intersection and turn right, if legal 
  
 C: travel to the next intersection and turn left, if legal 
  
 (a) Suppose you are driving a car without a map. Which control strategy is better, depth-first or breadth-first? Assume you 
 can use simple heuristics (like ""turn around if you're in the country"") to stay near the goal. 
  
 (b) Suppose you planned a route with a map, and the map was slightly wrong (for instance, a street is closed for repairs). 
 How could you prepare to better handle such occurrences? 
  
 9-6. Consider the complete search graph for some problem shown in Figure 9-14. Suppose state ""a"" is the starting state, and 
  
 http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap9.html (14 of 20) [23/04/2002 17:39:04]",NA
Implementing search ,NA,NA
We have postponed consideration of search implementation to this chapter to better focus on the quite different issues ,NA,NA
"involved. We will present programs for several kinds of search, working from a search problem described in an ",NA,NA
"abstract way. We'll also use search as a springboard to discuss some advanced features of Prolog, including set-",NA,NA
"collection and ""cut"" predicates, and more of the wild and wacky world of backtracking. ",NA,NA
Defining a simple search problem ,NA,NA
"First, we need a way to describe a search problem precisely. We ask the programmer to define the following ",NA,NA
"predicates, the last two optional depending on the desired search strategy: ",NA,NA
--,NA,NA
"successor(<old-state>,<desired new-state>)",NA,NA
: rules and facts defining this predicate give all possible ,NA,NA
"immediate branches or state transitions. It's a function predicate with its first argument an input, a state, ",NA,NA
"and second argument an output, a successor state. Both arguments are state descriptions. We emphasize ",NA,NA
that ,NA,NA
<new-state>,NA,NA
 must be an ,NA,NA
immediate,NA,NA
 successor. ,NA,NA
--,NA,NA
goalreached(<state>),NA,NA
: rules and facts defining this predicate give the stopping conditions for the ,NA,NA
"search. The argument is an input, a state. Multiple goal states are possible. ",NA,NA
--,NA,NA
"eval(<state>,<evaluation>)",NA,NA
: rules and facts defining this predicate give the evaluation function. This is ,NA,NA
"a function predicate taking an input state as first argument, and binding its second argument, an output, to ",NA,NA
an estimate of how close that state is to the nearest goal state. ,NA,NA
--,NA,NA
"cost(<state-list>,<cost>)",NA,NA
: rules and facts defining this predicate give the cost function. This is a ,NA,NA
"function predicate taking an input list of states as first argument, and binding its second argument, ",NA,NA
"an output, to some nonnegative number representing the sum of the costs along the path through ",NA,NA
those states. ,NA,NA
"Of these four, the first is generally the hardest: it must define all the operators, incorporating their necessary conditions ",NA,NA
and describing precisely how they modify a state-description list. (The ,NA,NA
successor,NA,NA
 definitions may also include ,NA,NA
"heuristics about operator use, though Section 10.11 will show a more general way to handle heuristics.) Successor ",NA,NA
"definitions turn a search problem into a rule-based system, so we can steal ideas from Chapter 7. ",NA,NA
"Then to actually start searching, we ask that you query something like ",NA,NA
"?- search(<starting-state>,<answer-state-list>).",NA,NA
"where the first argument is an input, the starting state (written in the format handled by the successor rules), and the ",NA,NA
"second argument is an output, the discovered sequence of states, usually in reverse order (that is, from the goal state ",NA,NA
back to the start state). ,NA,NA
"As an example of this Prolog-style definition of a search problem, let's return to the example of Figure 9-1, redrawn ",NA,NA
as Figure 10-1. This is a city route planning problem in which our starting location is ,NA,NA
a,NA,NA
 and our goal location is ,NA,NA
h,NA,NA
. ,NA,NA
States ,NA,NA
"are the labeled intersections, so to define ",NA,NA
successor,NA,NA
 we must write a fact for every pair of intersections that ,NA,NA
connect directly: ,NA,NA
"successor(a,b)",NA,NA
. ,NA,NA
"successor(a,d)",NA,NA
. ,NA,NA
"successor(b,c)",NA,NA
. ,NA,NA
"successor(b,a)",NA,NA
. ,NA,NA
"successor(b,d)",NA,NA
. ,NA,NA
"successor(c,b)",NA,NA
. ,NA,NA
"successor(d,a)",NA,NA
. ,NA,NA
"successor(d,e)",NA,NA
. ,NA,NA
"successor(d,g)",NA,NA
. ,NA,NA
"successor(e,d)",NA,NA
. ,NA,NA
"successor(e,f)",NA,NA
. ,NA,NA
"successor(e,g)",NA,NA
. ,NA,NA
"successor(f,e)",NA,NA
. ,NA,NA
"successor(g,d)",NA,NA
. ,NA,NA
"successor(g,e)",NA,NA
. ,NA,NA
"successor(h,g)",NA,NA
.,NA,NA
For the ,NA,NA
goalreached,NA,NA
 condition we need: ,NA,NA
goalreached(h).,NA,NA
"And to start the program out, we will query a particular search predicate, like ",NA,NA
"?- depthsearch(a,Path).",NA,NA
to do depth-first search from start state ,NA,NA
a,NA,NA
. (The search predicates we'll define in this chapter are ,NA,NA
depthsearch,NA,NA
", ",NA,NA
breadthsearch,NA,NA
" (breadth-first), ",NA,NA
bestsearch,NA,NA
" (best-first), and ",NA,NA
astarsearch,NA,NA
" (A* search).) When search is done, the ",NA,NA
variable ,NA,NA
Path,NA,NA
 is bound to the list of intersections (states) we must travel through. We can use evaluation and cost ,NA,NA
functions to improve search if we like. A good evaluation function for this problem would be the straight-line distance ,NA,NA
"to the goal (measuring on the map with a ruler), giving approximate distances for Figure 10-1 of: ",NA,NA
"eval(a,8)",NA,NA
. ,NA,NA
"eval(b,7)",NA,NA
. ,NA,NA
"eval(c,8)",NA,NA
. ,NA,NA
"eval(d,5)",NA,NA
. ,NA,NA
"eval(e,3)",NA,NA
. ,NA,NA
"eval(f,1)",NA,NA
. ,NA,NA
"eval(g,2)",NA,NA
. ,NA,NA
"eval(h,0)",NA,NA
.,NA,NA
The ,NA,NA
cost,NA,NA
" definition can be the actual distance along a road, which we can approximate from Figure 10-1 as ",NA,NA
"cost([X],0).",NA,NA
"cost([X,Y|L],E) :- piece_cost(X,Y,E2), cost([Y|L],E3), E is E2 + E3.",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (2 of 34) [23/04/2002 17:39:09],NA
"piece_cost(a,b,3).",NA,NA
"piece_cost(a,d,5).",NA,NA
"piece_cost(b,c,1).",NA,NA
"piece_cost(b,d,2).",NA,NA
"piece_cost(d,e,2).",NA,NA
"piece_cost(d,g,3).",NA,NA
"piece_cost(e,f,2).",NA,NA
"piece_cost(e,g,1).",NA,NA
"piece_cost(g,h,2).",NA,NA
"piece_cost(X,Y,C) :- piece_cost(Y,X,C).",NA,NA
A ,NA,NA
cost,NA,NA
 definition will often need recursion to handle paths of unknown length. ,NA,NA
Defining a search problem with fact-list states ,NA,NA
"Now let's try representing a different kind of search problem, one more typical. The previous example was easy ",NA,NA
"because states could be represented by letters. But often you can't name states in advance, as when you don't know ",NA,NA
"what states are possible, and you must describe them by lists of facts. ",NA,NA
Here's an example. This search concerns a very small part of car repair: putting nuts and washers onto bolts in the right ,NA,NA
"way. Suppose we have two bolts. In the starting state (the top picture in Figure 10-2), nut ",NA,NA
a,NA,NA
", washer ",NA,NA
b,NA,NA
", and nut ",NA,NA
c,NA,NA
 are on ,NA,NA
"the left bolt in that order, and nut ",NA,NA
d,NA,NA
", washer ",NA,NA
e,NA,NA
", and nut ",NA,NA
f,NA,NA
 are on the right bolt in that order. The goal is to get nut ,NA,NA
c,NA,NA
 on top ,NA,NA
of washer ,NA,NA
e,NA,NA
" (as for example in the bottom picture in Figure 10-2). To do this, we must work on one nut or washer at a ",NA,NA
"time. We can remove one from the top of the nuts and washers on a bolt, place one on the top of the nuts and washers ",NA,NA
"on a bolt, or just place one alone on the flat surface around the bolts. The bolts themselves can't be moved. The four ",NA,NA
nuts and two washers are the only parts available. ,NA,NA
The only facts that change during the search are those about what parts (nuts or washers) rest on what other parts. Let's ,NA,NA
use ,NA,NA
"on(<part-1>,<part-2>,<bolt>)",NA,NA
" facts for this, where ",NA,NA
<part-1>,NA,NA
 and ,NA,NA
<part-2>,NA,NA
" are codes for parts, and ",NA,NA
<part-1>,NA,NA
 is ,NA,NA
on the bolt named ,NA,NA
<bolt>,NA,NA
 directly above ,NA,NA
<part-2>,NA,NA
. To keep track of parts ,NA,NA
not,NA,NA
" on the bolts, we'll represent them with ",NA,NA
on ,NA,NA
"facts too, by ",NA,NA
"on(<part>,surface,none)",NA,NA
; parts can only rest on other parts when both are on bolts. To keep track of ,NA,NA
"empty bolts, we'll use two additional permanent facts, ",NA,NA
bolt(bolt1),NA,NA
 and ,NA,NA
bolt(bolt2),NA,NA
. So any state can be represented as a ,NA,NA
"list of eight predicate expressions, six specifying the location of each of six parts, and two giving the names of the ",NA,NA
"bolts. For instance, the starting state (the top picture in Figure 10-2) can be written ",NA,NA
"[on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1),on(d,e,bolt2)",NA,NA
",",NA,NA
 ,NA,NA
"on(e,f,bolt2),on(f,surface,bolt2),bolt(bolt1),bolt(bolt2)]",NA,NA
"In other words, like a Prolog database on its side. We could start a depth-first search by querying ",NA,NA
?- ,NA,NA
"depthsearch([on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1), ",NA,NA
"on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2),",NA,NA
" bolt(bolt1),bolt(bolt2)],Answerpath).",NA,NA
The example final state in Figure 10-2 can be written ,NA,NA
"[on(a,surface,none),on(b,surface,none),on(c,e,bolt2),",NA,NA
" on(d,surface,none),on(e,f,bolt2),on(f,surface,bolt2),",NA,NA
" bolt(bolt1),bolt(bolt2)]",NA,NA
But let's say we're not so fussy about where every part ends up. Let's say we only want part ,NA,NA
c,NA,NA
 to be on part ,NA,NA
e,NA,NA
. Then we ,NA,NA
can define the goal state by: ,NA,NA
"goalreached(S) :- member(on(c,e,bolt2),S).",NA,NA
"That is, we can stop in state ",NA,NA
S,NA,NA
 whenever the facts true for ,NA,NA
S,NA,NA
 include ,NA,NA
"on(c,e,bolt2)",NA,NA
. The ,NA,NA
member,NA,NA
 predicate was defined ,NA,NA
"in Section 5.5, and is true whenever some item is a member of some list: ",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
Successor rules like the preceding that work on fact lists usually just insert and delete facts from the list describing one ,NA,NA
"state to get the list describing another. Typically, they only insert and delete a few. So to specify the effect of an ",NA,NA
"operator, we need only list the fact ",NA,NA
changes,NA,NA
 made by an operator--everything else can be assumed constant. In ,NA,NA
"problems with complicated state descriptions, it may be hard to figure which facts stay the same, because of ""side ",NA,NA
"effects"". This is called the ",NA,NA
frame problem,NA,NA
 in artificial intelligence (not to be confused with the knowledge-partitioning ,NA,NA
"""frames"" we'll discuss in Chapter 12). ",NA,NA
"By referring to variables, just three successor rules are needed for the bolts problem, as shown in the following code. ",NA,NA
Their form is like the ,NA,NA
append,NA,NA
 and ,NA,NA
delete,NA,NA
 predicate definitions (Section 5.6). The first handles removing parts from ,NA,NA
"bolts, and the second handles placing parts on bolts. (The intermediate predicate ",NA,NA
cleartop,NA,NA
 simplifies the rules.) The ,NA,NA
first successor rule says that if in some state the part ,NA,NA
X,NA,NA
" (1) is on a bolt and (2) doesn't have another part on it, then a ",NA,NA
successor state is one in which ,NA,NA
X,NA,NA
" is removed from the bolt and placed on the surface. Furthermore, the rule says that ",NA,NA
we can get the successor state from the old state by removing the old fact about where part ,NA,NA
X,NA,NA
 was (with the ,NA,NA
delete ,NA,NA
"predicate), and adding a new fact that ",NA,NA
X,NA,NA
" is alone on the surface (with the stuff in brackets on the rule left side, the last ",NA,NA
thing done before the rule succeeds). The second successor rule says that if in some state the part ,NA,NA
X,NA,NA
 (1) doesn't have ,NA,NA
"another part on it, and (2) another part ",NA,NA
Z,NA,NA
" doesn't have anything on it either, and (3) ",NA,NA
Z,NA,NA
" is on a bolt, and (4) ",NA,NA
Z,NA,NA
 is different ,NA,NA
from ,NA,NA
X,NA,NA
", then a possible successor state has ",NA,NA
X,NA,NA
 placed on ,NA,NA
Z,NA,NA
. And we can get a description of the new state by removing ,NA,NA
the old location of ,NA,NA
X,NA,NA
" and adding the new location. The third successor rule says that if a bolt is empty in some state, ",NA,NA
then we can put on it any part with a clear top. ,NA,NA
"successor(S,[on(X,surface,none)|S2]) :- member(on(X,Y,B),S),",NA,NA
" not(B=none), cleartop(X,S), delete(on(X,Y,B),S,S2).",NA,NA
"successor(S,[on(X,Z,B2)|S2]) :- member(on(X,Y,B),S),",NA,NA
" cleartop(X,S), member(on(Z,W,B2),S), not(B2=none),",NA,NA
" cleartop(Z,S), not(X=Z), delete(on(X,Y,B),S,S2).",NA,NA
"successor(S,[on(X,surface,B2)|S2]) :- member(on(X,Y,B),S),",NA,NA
" cleartop(X,S), member(bolt(B2),S), not(member(on(Z,W,B2),S)),",NA,NA
" delete(on(X,Y,B),S,S2).",NA,NA
"cleartop(Part,State) :- not(member(on(X,Part,B),State)).",NA,NA
"delete(X,[X|L],L).",NA,NA
"delete(X,[X|L],L2) :- delete(X,L,L2).",NA,NA
"delete(X,[Y|L],[Y|L2]) :- not(X=Y), delete(X,L,L2).",NA,NA
"In the preceding, ",NA,NA
cleartop,NA,NA
 just checks that there's nothing resting on a part. The ,NA,NA
delete,NA,NA
 predicate comes from Section ,NA,NA
"5.6: it removes all occurrences of its first argument (an input) from the list that is its second argument (an input), ",NA,NA
binding the resulting list to the third argument (the output). ,NA,NA
Implementing depth-first search ,NA,NA
"Prolog interpreters work depth-first, so it isn't hard to implement a general depth-first search facility in Prolog. As with ",NA,NA
"the programs in Chapter 7, we'll divide code for a search into two files: a problem-dependent or ""problem-defining"" ",NA,NA
"file containing, ",NA,NA
successor,NA,NA
", ",NA,NA
goalreached,NA,NA
", ",NA,NA
eval,NA,NA
", and ",NA,NA
cost,NA,NA
" definitions discussed in Section 10.1, and a problem-",NA,NA
independent file containing search machinery. Here is the problem-independent depth-first-search file in its entirety | ,NA,NA
"REFERENCE 1|: .FS | REFERENCE 1| When using all the programs in this chapter, be careful not to redefine or ",NA,NA
"duplicate definitions of the predicate names used here, or you can get into serious trouble. That particularly applies to ",NA,NA
duplication of the classic list-predicate definitions ,NA,NA
member,NA,NA
", ",NA,NA
length,NA,NA
", and ",NA,NA
append,NA,NA
. .FE ,NA,NA
/* Problem-independent code for depth-first search */,NA,NA
"depthsearch(Start,Ans) :- depthsearch2(Start,[Start],Ans).",NA,NA
"depthsearch2(State,Statelist,Statelist) :- goalreached(State).",NA,NA
"depthsearch2(State,Statelist,Ans) :- successor(State,Newstate),",NA,NA
" not(member(Newstate,Statelist)),",NA,NA
" depthsearch2(Newstate,[Newstate|Statelist],Ans).",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
Predicate ,NA,NA
depthsearch,NA,NA
" is the top level. Its first argument is an input, bound to a description of the starting state, and its ",NA,NA
"second argument is the output, bound when search is done to the solution path in reverse order. The ",NA,NA
depthsearch,NA,NA
 rule ,NA,NA
just initializes a third argument (the middle one) for the predicate ,NA,NA
depthsearch2,NA,NA
. ,NA,NA
The recursive ,NA,NA
depthsearch2,NA,NA
 predicate does the real work of the program. Let's first show it declaratively; the next ,NA,NA
"section will explain it mostly procedurally. Its three arguments are the current state (an input), the path followed to this ",NA,NA
"state (an input), and the eventual path list found (an output). The first ",NA,NA
depthsearch2,NA,NA
 rule says that if the current state is ,NA,NA
"a goal state, bind the output (third argument) to the second argument, the list of states we went through to get here. ",NA,NA
"Otherwise, the second rule says to find some successor of the current state not previously encountered on the path here ",NA,NA
"(that is, avoid infinite loops), put this successor on the front of the path list, and recursively search for the goal from the ",NA,NA
new state. The ,NA,NA
member,NA,NA
 predicate is from the last section. ,NA,NA
The key to this program is the ,NA,NA
successor,NA,NA
 predicate expression in the second ,NA,NA
depthsearch2,NA,NA
 rule. Backing up in a search ,NA,NA
"problem means backtracking to that expression. Whenever a state has no successors, or all its successors have been ",NA,NA
"tried and found not to lead to a goal, the second ",NA,NA
depthsearch2,NA,NA
 rule fails. Since it's the ,NA,NA
last ,NA,NA
depthsearch2,NA,NA
" rule, the ",NA,NA
"program returns to where it was called--or it ""backs up"". If the call of ",NA,NA
depthsearch2,NA,NA
 was (as usually) a recursive one ,NA,NA
from the same second ,NA,NA
depthsearch2,NA,NA
" rule at the next highest level of recursion, backtracking goes to the ",NA,NA
not,NA,NA
 (which ,NA,NA
like all ,NA,NA
not,NA,NA
"s, can never succeed on backtracking), and then immediately to the ",NA,NA
successor,NA,NA
 predicate. If another successor ,NA,NA
can ,NA,NA
"be found for this earlier state, it is then taken. Otherwise, ",NA,NA
this ,NA,NA
"invocation of the rule also fails, and backing up and ",NA,NA
backtracking happens again. ,NA,NA
A depth-first example ,NA,NA
"Let's simulate the depth-first program on an example, to illustrate its procedural interpretation. The previous city-",NA,NA
"route example is a little too complicated for a good show, so let's try the following. Suppose in some city (see Figure ",NA,NA
10-3) that two-way streets connect intersection ,NA,NA
a,NA,NA
 with intersection ,NA,NA
b,NA,NA
", intersection ",NA,NA
b,NA,NA
 to intersection ,NA,NA
d,NA,NA
", and intersection ",NA,NA
d,NA,NA
 to intersection ,NA,NA
e,NA,NA
. Suppose also that one-way streets connect intersection ,NA,NA
b,NA,NA
 to intersection ,NA,NA
c,NA,NA
", and intersection ",NA,NA
a,NA,NA
 to ,NA,NA
intersection ,NA,NA
d,NA,NA
. Then the following ,NA,NA
successor,NA,NA
 facts hold; assume they're put in this order. ,NA,NA
"successor(a,b).",NA,NA
"successor(b,a).",NA,NA
"successor(b,c).",NA,NA
"successor(a,d).",NA,NA
"successor(b,d).",NA,NA
"successor(d,b).",NA,NA
"successor(d,e).",NA,NA
"successor(e,d).",NA,NA
Assume for this problem that the starting state is ,NA,NA
a,NA,NA
", and there is only one goal state ",NA,NA
e,NA,NA
. Then the problem-definition file ,NA,NA
must also include ,NA,NA
goalreached(e).,NA,NA
Now let's follow what happens when we query ,NA,NA
"?- depthsearch(a,Answer).",NA,NA
and the problem-independent file of the last section is loaded in addition to the previous problem-dependent ,NA,NA
specification. The action is summarized in Figure 10-4. ,NA,NA
1. The predicate ,NA,NA
depthsearch,NA,NA
 is called with its first argument bound to ,NA,NA
a,NA,NA
 and its second argument ,NA,NA
unbound. So predicate ,NA,NA
depthsearch2,NA,NA
 is called with first argument ,NA,NA
a,NA,NA
", second argument ",NA,NA
[a],NA,NA
", and ",NA,NA
third argument unbound. ,NA,NA
2. The goal is not reached in state ,NA,NA
a,NA,NA
", so the second rule for ",NA,NA
depthsearch2,NA,NA
 is tried. ,NA,NA
3. In the ,NA,NA
successor,NA,NA
" facts, the first successor of state ",NA,NA
a,NA,NA
 is ,NA,NA
b,NA,NA
", and ",NA,NA
b,NA,NA
 is not a member of the list of previous ,NA,NA
"states, ",NA,NA
[a],NA,NA
. So ,NA,NA
depthsearch2,NA,NA
 is recursively called with first argument ,NA,NA
b,NA,NA
", second argument ",NA,NA
"[b,a]",NA,NA
", and third ",NA,NA
argument unbound. ,NA,NA
4. For this second level of ,NA,NA
depthsearch2,NA,NA
" recursion, the state ",NA,NA
b,NA,NA
 is not a goal state; the first successor ,NA,NA
listed for ,NA,NA
b,NA,NA
 is ,NA,NA
c,NA,NA
", and ",NA,NA
c,NA,NA
" isn't in the list of previous states, ",NA,NA
"[b,a]",NA,NA
. So we recursively call ,NA,NA
depthsearch2,NA,NA
", now ",NA,NA
with first argument ,NA,NA
c,NA,NA
", second argument ",NA,NA
"[c,b,a]",NA,NA
", and third argument unbound. ",NA,NA
"5. For this third level of recursion, new state ",NA,NA
c,NA,NA
" is not a goal state nor does it have successors, so both ",NA,NA
rules for ,NA,NA
depthsearch2,NA,NA
" fail. We must backtrack, ""backing up"" to the previous state ",NA,NA
b,NA,NA
" at the second level, ",NA,NA
and hence to the recursive ,NA,NA
depthsearch2,NA,NA
 call in the last line of the last ,NA,NA
depthsearch2,NA,NA
 rule. ,NA,NA
6. The ,NA,NA
not,NA,NA
" fails on backtracking, as all ",NA,NA
not,NA,NA
"s do, so we backtrack further to the ",NA,NA
successor,NA,NA
 predicate in the ,NA,NA
second rule for ,NA,NA
depthsearch2,NA,NA
", which chooses successors. Backtracking to here means we want a ",NA,NA
different successor for state ,NA,NA
b,NA,NA
 than ,NA,NA
c,NA,NA
. And the only other successor of ,NA,NA
b,NA,NA
 is ,NA,NA
d,NA,NA
. So we resume forward ,NA,NA
progress through the second ,NA,NA
depthsearch2,NA,NA
 rule with Newstate bound to ,NA,NA
d,NA,NA
. This ,NA,NA
d,NA,NA
 is not in the list of ,NA,NA
previously visited states ,NA,NA
"[b,a]",NA,NA
", so we recursively call ",NA,NA
depthsearch2,NA,NA
 with first argument ,NA,NA
d,NA,NA
", second ",NA,NA
argument ,NA,NA
"[d,b,a]",NA,NA
 (,NA,NA
c,NA,NA
" was removed in backtracking), and third argument unbound. ",NA,NA
"7. For this new third-level call, the new state ",NA,NA
d,NA,NA
" is not a goal, so we find a successor of it. Its first-listed ",NA,NA
successor is ,NA,NA
b,NA,NA
", but ",NA,NA
b,NA,NA
 is a member of the list of previous states ,NA,NA
"[d,b,a]",NA,NA
", so we backtrack to find another ",NA,NA
successor. ,NA,NA
8. The only other successor fact for ,NA,NA
d,NA,NA
 mentions state ,NA,NA
e,NA,NA
. This isn't a member of ,NA,NA
"[d,b,a]",NA,NA
", so we recursively ",NA,NA
call ,NA,NA
depthsearch2,NA,NA
 with the ,NA,NA
e,NA,NA
" as first argument, ",NA,NA
"[e,d,b,a]",NA,NA
" as second argument, and an unbound variable ",NA,NA
(still) as third argument. ,NA,NA
"9. But for this fourth level of recursion, state ",NA,NA
e,NA,NA
" is a goal state, and the ",NA,NA
goalreached,NA,NA
 predicate succeeds. ,NA,NA
So the first rule for ,NA,NA
depthsearch2,NA,NA
" succeeds, binding the third argument ",NA,NA
Statelist,NA,NA
 (finally!) to the list of ,NA,NA
"states visited on the path here in reverse order, ",NA,NA
"[e,d,b,a]",NA,NA
. Now all other levels of ,NA,NA
depthsearch2,NA,NA
 ,NA,NA
recursion succeed because the recursive call was the last predicate expression in the rule (in other ,NA,NA
"words, we always did tail recursion). ",NA,NA
l0. So query variable ,NA,NA
Answer,NA,NA
 is bound to ,NA,NA
"[e,d,b,a]",NA,NA
. ,NA,NA
"Notice this is not the shortest solution to the problem, as is common with depth-first search. ",NA,NA
Implementing breadth-first search ,NA,NA
"We can write code for problem-independent breadth-first search, to load as an alternative to the depth-first ",NA,NA
problem-independent code. ,NA,NA
"Recall from the last chapter that breadth-first search finds states level-by-level (that is, by distance in number of ",NA,NA
"branches from the starting state). To do this, it must keep facts about all states found but whose successors haven't yet ",NA,NA
been found. Those states are an ,NA,NA
agenda,NA,NA
; each represents further work to do. One simple way to implement breadth-,NA,NA
"first search is to make the agenda a queue (see Appendix C), a data structure for which the first thing added is always ",NA,NA
"the first thing removed. We begin with a queue consisting of just the starting state, and anytime we find successors, we ",NA,NA
put them on the end of the queue. That way we are guaranteed to not try (find successors of) any states at level |N| ,NA,NA
until all states at level |N-1| have been tried. ,NA,NA
"We can implement agendas in Prolog, by facts with predicate name ",NA,NA
agenda,NA,NA
", one for each unexplored (successors-not-",NA,NA
"found) state. To get the effect of a queue, we can put new states at the end of the agenda by the built-in predicate ",NA,NA
assertz,NA,NA
" (introduced in Section 6.1), so the first fact will always be the one that has been on the agenda the longest, and ",NA,NA
the first we'll find when we query the agenda facts. Predicate ,NA,NA
agenda,NA,NA
" can have two arguments: a state, and the path ",NA,NA
"followed to reach it. As with depth-first search, the second argument is needed because (1) checking states against it ",NA,NA
"prevents some of the possible infinite loops, and (2) its value for the goal state is the answer to the search problem. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (7 of 34) [23/04/2002 17:39:09],NA
We also should keep ,NA,NA
oldagenda,NA,NA
" facts. These, with the same two arguments as ",NA,NA
agenda,NA,NA
" facts, can record ""exhausted"" ",NA,NA
"states, states for which we have found all successors. Checking against ",NA,NA
oldagenda,NA,NA
 facts before adding a new ,NA,NA
agenda ,NA,NA
fact prevents other infinite loops. This checking also ensures that any path we find to a state ,NA,NA
S,NA,NA
 has the fewest number ,NA,NA
of branches of any path to ,NA,NA
S,NA,NA
", because it was found first and breadth-first works level by level. ",NA,NA
"Here is the problem-independent breadth-first search code | REFERENCE 2|, whose predicate hierarchy is given in ",NA,NA
"Figure 10-5. (Those strange exclamation points """,NA,NA
!,NA,NA
""" will be explained in Section 10.7, and the ",NA,NA
bagof,NA,NA
 in Section 10.6.) ,NA,NA
".FS | REFERENCE 2| This won't work for some Prolog dialects, those that can't handle dynamic additions of new ",NA,NA
backtracking points with ,NA,NA
assertz,NA,NA
". For such implementations, we can get breadth-first search from the best-first search ",NA,NA
program ,NA,NA
bestsearch,NA,NA
" given later in this chapter, by including two extra lines with it: ",NA,NA
"eval(S,T) :- time(T), retract(time(T)), T2 is T+1, asserta(time(T2)). ",NA,NA
"eval(S,0) :- not(time(T)), asserta(time(1)).",NA,NA
 .FE ,NA,NA
/* Problem-independent breadth-first search */ ,NA,NA
"breadthsearch(Start,Ans) :- cleandatabase,",NA,NA
" asserta(agenda(Start,[Start])), ",NA,NA
"agenda(State,Oldstates),",NA,NA
 ,NA,NA
"find_successors(State,Oldstates,Newstate),",NA,NA
" goalreached(Newstate), agenda(Newstate,Ans),",NA,NA
" retract(agenda(Newstate,Ans)),",NA,NA
" asserta(oldagenda(Newstate,Ans)), measurework.",NA,NA
"find_successors(State,Oldstates,Newstate) :-",NA,NA
" successor(State,Newstate), not(State = Newstate), ",NA,NA
"not(agenda(Newstate,S)), not(oldagenda(Newstate,S)), ",NA,NA
"assertz(agenda(Newstate,[Newstate|Oldstates])).",NA,NA
"find_successors(State,Oldstates,Newstate) :- ",NA,NA
"retract(agenda(State,Oldstates)),",NA,NA
" asserta(oldagenda(State,Oldstates)), fail.",NA,NA
"cleandatabase :- abolish(oldagenda,2), abolish(agenda,2), !. ",NA,NA
"cleandatabase :- abolish(agenda,2), !. ",NA,NA
cleandatabase.,NA,NA
"measurework :- bagof([X,Y],agenda(X,Y),Aset), length(Aset,Len), ",NA,NA
"bagof([X2,Y2],oldagenda(X2,Y2),A2set), length(A2set,Len2), ",NA,NA
"write(Len), write(' incompletely examined state(s) and '), ",NA,NA
"write(Len2),write(' examined state(s).'),!.",NA,NA
"measurework :- bagof([X,Y],oldagenda(X,Y),Aset),",NA,NA
" length(Aset,Len), write('no incompletely examined states and '), ",NA,NA
"write(Len), write(' examined state(s).'),!.",NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2+1.",NA,NA
The predicate ,NA,NA
breadthsearch,NA,NA
 starts by removing any ,NA,NA
agenda,NA,NA
 and ,NA,NA
oldagenda,NA,NA
 facts remaining from previous searches. ,NA,NA
"It ""seeds"" or starts the agenda with a single item, the starting state. It then spends most of its time bouncing back and ",NA,NA
forth between the next three predicate expressions ,NA,NA
agenda,NA,NA
", ",NA,NA
find_successors,NA,NA
", and ",NA,NA
goalreached,NA,NA
. The ,NA,NA
agenda,NA,NA
 retrieves ,NA,NA
"an agenda state, ",NA,NA
find_successors,NA,NA
" finds a successor of it (as explained in a moment), and ",NA,NA
goalreached,NA,NA
 checks whether ,NA,NA
it's done. Most of the time it won't be. So most of the time it backtracks to the ,NA,NA
find_successors,NA,NA
 call to find another ,NA,NA
"successor, or if there aren't any more, it backtracks to the ",NA,NA
agenda,NA,NA
 call to pick the next state on the agenda. When a goal ,NA,NA
"state is found, it cleans up the agenda, and binds the answer variable (the second argument to ",NA,NA
breadthsearch,NA,NA
 as with ,NA,NA
depthsearch,NA,NA
") to the path used to get there. Finally, it prints the size of the agenda and the oldagenda to show how ",NA,NA
much work it did. ,NA,NA
The two ,NA,NA
find_successors,NA,NA
 rules are the key to the program. Function predicate ,NA,NA
find_successors,NA,NA
 has three arguments: ,NA,NA
"the current state (an input), the path there (an input), and a successor state (an output). The right side of the first ",NA,NA
find_successors,NA,NA
 rule calls first on the ,NA,NA
successor,NA,NA
" definition, just as in the depth-first search program. If a successor is ",NA,NA
"found, it is checked to be (1) not the current state, (2) not on the agenda, and (3) not on the oldagenda. Only if these ",NA,NA
tests succeed is the new successor added to the agenda. The first ,NA,NA
find_successors,NA,NA
 rule is repeatedly backtracked into to ,NA,NA
generate all the successors of a state; this backtracking is forced by the usually-failing ,NA,NA
goalreached,NA,NA
 expression in ,NA,NA
breadthsearch,NA,NA
. ,NA,NA
The second ,NA,NA
find_successors,NA,NA
" rule applies whenever the first fails, or whenever no further successors can be found for ",NA,NA
"a state. It removes the ""exhausted"" state from the agenda and adds it to the oldagenda. Then by a ",NA,NA
fail,NA,NA
", it forces the ",NA,NA
top-level predicate ,NA,NA
breadthsearch,NA,NA
" to pick a new state to find successors of. As we explained before, the next state ",NA,NA
picked will always be the oldest remaining agenda fact because of the ,NA,NA
assertz,NA,NA
. ,NA,NA
"If the agenda ever becomes empty (that is, there are no new states to be found), then the ",NA,NA
agenda,NA,NA
 in ,NA,NA
breadthsearch ,NA,NA
"fails, and then the ",NA,NA
asserta,NA,NA
" fails (there's never a new way to assert something), and then the ",NA,NA
cleandatabase,NA,NA
 fails (though ,NA,NA
we can't explain why this last for several pages yet). So the interpreter would type ,NA,NA
no,NA,NA
. ,NA,NA
"As an example, here is the result of running the breadth-first program on the bolts problem defined in Section 10.2. ",NA,NA
"Three solution paths were found, differing only in when part ",NA,NA
e,NA,NA
 is removed relative to the removals of parts ,NA,NA
a,NA,NA
 and ,NA,NA
b,NA,NA
. ,NA,NA
(Carriage returns have been added to improve readability.) ,NA,NA
"?- breadthsearch([on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
" on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)],Answer).",NA,NA
81 incompletely examined state(s) and 1 examined state(s).,NA,NA
Answer=,NA,NA
"[[on(c,e,bolt2),on(d,surface,none),on(b,surface,none),",NA,NA
" on(a,surface,none),on(e,f,bolt2),on(f,surface,bolt2)],",NA,NA
"[on(d,surface,none),on(b,surface,none),on(a,surface,none),",NA,NA
" on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)],",NA,NA
"[on(b,surface,none),on(a,surface,none),on(c,surface,bolt1),",NA,NA
" on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)],",NA,NA
"[on(a,surface,none),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
" on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)],",NA,NA
"[on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
" on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)]] ;",NA,NA
102 incompletely examined state(s) and 2 examined state(s).,NA,NA
Answer=,NA,NA
"[[on(c,e,bolt2),on(b,surface,none),on(d,surface,none),",NA,NA
 ,NA,NA
"on(a,surface,none),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(b,surface,none),on(d,surface,none),on(a,surface,none),",NA,NA
" on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(d,surface,none),on(a,surface,none),on(b,c,bolt1),",NA,NA
 ,NA,NA
"on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(a,surface,none),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
 ,NA,NA
"on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
" on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)]] ;",NA,NA
152 incompletely examined state(s) and 3 examined state(s).,NA,NA
Answer= ,NA,NA
"[[on(c,e,bolt2),on(b,surface,none),on(a,surface,none),",NA,NA
 ,NA,NA
"on(d,surface,none),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(b,surface,none),on(a,surface,none),on(d,surface,none),",NA,NA
" on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(a,surface,none),on(d,surface,none),on(b,c,bolt1),",NA,NA
 ,NA,NA
"on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(d,surface,none),on(a,b,bolt1),on(b,c,bolt1),",NA,NA
" on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
" on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)]] ",NA,NA
Collecting all items that satisfy a predicate expression ,NA,NA
A feature of the ,NA,NA
breadthsearch,NA,NA
 program we haven't explained is the ,NA,NA
bagof,NA,NA
 predicate in the ,NA,NA
measurework,NA,NA
 rules. This ,NA,NA
"predicate we used before in Chapter 8 to implement ""or-combination"", and it is built-in in most Prolog dialects ",NA,NA
(though easily defined in Prolog). It collects into a list all the values for some variable that satisfy a predicate ,NA,NA
"expression, much like the ",NA,NA
forall,NA,NA
 (defined in Section 7.12) in reverse. Predicate ,NA,NA
bagof,NA,NA
 takes three arguments: an input ,NA,NA
"variable, an input predicate expression containing that variable, and an output list to hold all possible bindings of that ",NA,NA
variable which satisfy that expression. (Some variants of ,NA,NA
bagof,NA,NA
 delete duplicates in the result.) ,NA,NA
Here's an example. Suppose we have this database: ,NA,NA
"boss_of(mary,tom). ",NA,NA
"boss_of(mary,dick). ",NA,NA
"boss_of(dick,harry).",NA,NA
"boss_of(dick,ann).",NA,NA
Suppose we want a list of all people that Mary is the boss of. We can type ,NA,NA
"?- bagof(X,boss_of(mary,X),L)",NA,NA
and the interpreter will type ,NA,NA
"L=[tom,dick]",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (10 of 34) [23/04/2002 17:39:09],NA
and ,NA,NA
X,NA,NA
 won't be printed because it's just a placeholder. ,NA,NA
"We can put, within the expression that is the second argument to ",NA,NA
bagof,NA,NA
", variables besides the one we are collecting; ",NA,NA
"the interpreter will try to bind them too. So if, for the preceding database, we type ",NA,NA
"?- bagof(X,boss_of(Y,X),L).",NA,NA
the interpreter will type ,NA,NA
"Y=mary, L=[tom,dick]",NA,NA
"for its first answer. If we then type a semicolon, it will type ",NA,NA
"Y=dick, L=[harry,ann]",NA,NA
for its second answer. ,NA,NA
The first argument to ,NA,NA
bagof,NA,NA
" can be a list. That is, we can search for a set of values satisfying a predicate instead of just ",NA,NA
"one value. For instance, we can query ",NA,NA
"?- bagof([X,Y],boss_of(X,Y),L).",NA,NA
and receive the answer ,NA,NA
"L=[[mary,tom],[mary,dick],[dick,harry],[dick,ann]]",NA,NA
This query form is used in the ,NA,NA
measurework,NA,NA
 rules in the ,NA,NA
breadthsearch,NA,NA
 program. ,NA,NA
The ,NA,NA
bagof,NA,NA
 predicate can be defined this way (provided you have no other predicate named ,NA,NA
zzz,NA,NA
 in your program): ,NA,NA
"bagof(X,P,L) :- asserta(zzz([])), fail.",NA,NA
"bagof(X,P,L) :- call(P), zzz(M), retract(zzz(M)),",NA,NA
" asserta(zzz([X|M)), fail.",NA,NA
"bagof(X,P,L) :- zzz(L), retract(zzz(L)).",NA,NA
The cut predicate ,NA,NA
"We still must explain those strange exclamation points (the """,NA,NA
!,NA,NA
""") in the ",NA,NA
breadthsearch,NA,NA
 program. These are a special ,NA,NA
built-in predicate of no arguments called the ,NA,NA
cut,NA,NA
", whose meaning is exclusively procedural. The cut always succeeds ",NA,NA
"when the interpreter first encounters it, but has a special side effect: it prevents backtracking to it by throwing away ",NA,NA
"the necessary bookkeeping information. This can improve the efficiency of Prolog programs, but it is also necessary to ",NA,NA
"make some programs work properly, those for which backtracking just doesn't make sense. ",NA,NA
"Usually the cut predicate expression is last in a rule, as in ",NA,NA
cleandatabase,NA,NA
 and the two ,NA,NA
measurework,NA,NA
 rules in the ,NA,NA
breadthsearch,NA,NA
" program. It can be paraphrased as: ""Don't ever backtrack into this rule. What's more, don't ever try ",NA,NA
"another rule to satisfy the goal that this rule tried to satisfy. That goal is dead. So fail it."" (Note that a cut has no ",NA,NA
effect ,NA,NA
"on the next call of the rule, even a call with the same arguments as before: the prohibition of backtracking just applies ",NA,NA
to the call in which the cut was encountered.) So a cut symbol forces behavior like that of a subprocedure in a ,NA,NA
"conventional programming language, in that once a subprocedure is done it can only be reentered by a different call--",NA,NA
"except that a Prolog ""subprocedure"" is all the rules with the same left-side predicate name, not just a single rule. So a ",NA,NA
"cut at the end of a rule means you want only one solution to the query of that rule. This often is true for ""existential ",NA,NA
"quantification"" queries in which we check existence of something of a certain type, and we don't care what. For ",NA,NA
"instance, the ",NA,NA
member,NA,NA
 predicate from Section 5.5 ,NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"is often used this way, when it is queried with both arguments bound. For instance: ",NA,NA
"?- member(b,[a,b,c,b,e,a,f).",NA,NA
Recursion will find the first ,NA,NA
b,NA,NA
 in the list and the interpreter will type ,NA,NA
yes,NA,NA
". If we were to type a semicolon, recursion ",NA,NA
would find the second occurrence of ,NA,NA
b,NA,NA
 and the interpreter would type ,NA,NA
yes,NA,NA
 again. But finding that second occurrence ,NA,NA
"doesn't make sense in most applications; the answer to the query must be the same, after all. A backtracking ",NA,NA
member,NA,NA
 ,NA,NA
"is useless in our depth-first and breadth-first search programs, where ",NA,NA
member,NA,NA
 is enclosed in a ,NA,NA
not,NA,NA
", since the Prolog ",NA,NA
interpreter doesn't backtrack into ,NA,NA
not,NA,NA
s. And backtracking into ,NA,NA
member,NA,NA
 is unnecessary whenever there can't be ,NA,NA
duplicates in a list. (But we do need a backtracking ,NA,NA
member,NA,NA
" in the bolts example of Section 10.2, to choose alternative ",NA,NA
parts to move by querying ,NA,NA
member,NA,NA
 with an unbound first argument.) A non-backtracking ,NA,NA
member,NA,NA
 can be obtained by ,NA,NA
just inserting a cut symbol in the backtracking ,NA,NA
member,NA,NA
: ,NA,NA
"singlemember(X,[X|L]) :- !.",NA,NA
"singlemember(X,[Y|L]) :- singlemember(X,L).",NA,NA
"We don't need a cut symbol at the end of the second rule, because when it fails no more possibilities remain. ",NA,NA
We don't actually need a cut symbol to define ,NA,NA
singlemember,NA,NA
", for we could say equivalently: ",NA,NA
"singlemember(X,[X|L]).",NA,NA
"singlemember(X,[Y|L]) :- not(X=Y), singlemember(X,L).",NA,NA
But this is slower because the extra expression ,NA,NA
not(X=Y),NA,NA
 must be tested on every recursion; the cut ,NA,NA
predicate expression is done at most once for any query. ,NA,NA
"A related use of the cut predicate is to do something only once instead of repeatedly. For instance, here's the predicate ",NA,NA
from Section 5.6 that deletes all occurrences of an item ,NA,NA
X,NA,NA
 from a list ,NA,NA
L,NA,NA
: ,NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- not(X=Y), delete(X,L,M).",NA,NA
Suppose we want a predicate that deletes only the first item ,NA,NA
X,NA,NA
 from list ,NA,NA
L,NA,NA
. We can remove the recursion in the second ,NA,NA
"rule, remove the ",NA,NA
not(X=Y),NA,NA
" in the third rule, and insert a cut symbol: ",NA,NA
"deleteone(X,[],[]).",NA,NA
"deleteone(X,[X|L],L) :-  !.",NA,NA
"deleteone(X,[Y|L],[Y|M]) :- deleteone(X,L,M).",NA,NA
"The cut symbol is important here, because if we just omit it like this: ",NA,NA
"deleteone(X,[],[]).",NA,NA
"deleteone(X,[X|L],L).",NA,NA
"deleteone(X,[Y|L],[Y|M]) :- deleteone(X,L,M).",NA,NA
then ,NA,NA
deleteone,NA,NA
" will give a correct first answer, but wrong subsequent answers on backtracking, just like the ",NA,NA
similar mistake-making ,NA,NA
delete,NA,NA
 discussed in Section 5.6. ,NA,NA
The cut predicate can also be used merely to improve efficiency. Recall the definition of the maximum of a list ,NA,NA
in Section 5.5: ,NA,NA
"max([X],X).",NA,NA
"max([X|L],X) :- max(L,M), X>M.",NA,NA
"max([X|L],M) :- max(L,M), not(X>M).",NA,NA
"When the first two rules fail, the computation of the maximum of a list is done twice: once in the second rule, and ",NA,NA
once in the third rule. This is wasteful. So we can define it: ,NA,NA
"max([X],X) :- !.",NA,NA
"max([X|L],M) :- max(L,M), not(X>M), !. ",NA,NA
"max([X|L],X).",NA,NA
Here we've changed the order of the last two rules and removed the redundant ,NA,NA
max,NA,NA
 call. The cuts guarantee that if ,NA,NA
we ever backtrack into ,NA,NA
max,NA,NA
", we won't start taking the third rule when the second rule was taken before, and thereby ",NA,NA
get wrong answers. ,NA,NA
"A cut predicate can be put in the middle of a rule. Then it means that backtracking is allowed to the right of it, but that ",NA,NA
"if the interpreter ever tries to backtrack to its left, both the rule and the goal that invoked it will fail unconditionally. ",NA,NA
"Nothing in life is free, so it's not surprising that the efficiency advantages of the cut predicate have the associated ",NA,NA
disadvantage of restricting multiway use (see Section 3.3) of predicate definitions. That's because the cut is a purely ,NA,NA
"procedural feature of Prolog, with no declarative meaning. But if you're sure you'll only query a definition with one ",NA,NA
"particular pattern of bindings, multiway use is not an issue, and cut predicates can be used freely to improve ",NA,NA
efficiency. ,NA,NA
Iteration with the cut predicate (*) ,NA,NA
The cut predicate provides a way to write iterative Prolog programs in a way more general than the ,NA,NA
forall,NA,NA
 and ,NA,NA
doall,NA,NA
 of ,NA,NA
Section 7.12 and ,NA,NA
bagof,NA,NA
" of Section 10.6. It gives a sometimes better way to repeat things than by backtracking, since ",NA,NA
"backtracking doe things in reverse order, and that can be confusing or even wrong. ",NA,NA
"To get a true ""do-until"", or in other words to repeatedly query some predicate expression Pred until some ",NA,NA
other predicate expression ,NA,NA
done,NA,NA
" holds, query predicate ",NA,NA
iterate,NA,NA
 with argument Pred: ,NA,NA
"iterate(Pred) :- repeat, iterate2(Pred), done. ",NA,NA
"iterate2(Pred) :- call(Pred), !. ",NA,NA
repeat.,NA,NA
repeat :- repeat.,NA,NA
Here ,NA,NA
repeat,NA,NA
" is a predicate that always succeeds, and what's more, always succeeds on backtracking (unlike ",NA,NA
1=1,NA,NA
 ,NA,NA
"which always succeeds once, but fails on backtracking because it can't succeed in a new way). The ",NA,NA
repeat,NA,NA
 is built-in ,NA,NA
"in many Prolog dialects, but it's easy to define as you see. ",NA,NA
Predicate ,NA,NA
iterate,NA,NA
 will hand the expression Pred to ,NA,NA
iterate2,NA,NA
 for execution using the ,NA,NA
call,NA,NA
 predicate explained in Section ,NA,NA
7.12. Then ,NA,NA
iterate,NA,NA
 checks the ,NA,NA
done,NA,NA
" condition, which usually fails. At this point, the cut in ",NA,NA
iterate,NA,NA
" is important, because ",NA,NA
it prevents backtracking into ,NA,NA
iterate2,NA,NA
 and Pred. So ,NA,NA
iterate2,NA,NA
" fails, and the interpreter returns to the ",NA,NA
repeat,NA,NA
. But ,NA,NA
repeat ,NA,NA
"always succeeds anew on backtracking (it just recurses once more as a new way to succeed), and so the interpreter ",NA,NA
returns to ,NA,NA
iterate2,NA,NA
", and Pred is executed again ",NA,NA
in the forward direction,NA,NA
. So the cut predicate forces the interpreter to ,NA,NA
execute Pred like within a loop in a conventional programming language: always forward. (Note that Pred can contain ,NA,NA
arguments.) ,NA,NA
One disadvantage of the preceding is that ,NA,NA
iterate,NA,NA
 can never fail. This would cause an infinite loop if ,NA,NA
done,NA,NA
 has a bug ,NA,NA
preventing it from ever succeeding. So we might distinguish ,NA,NA
donegood,NA,NA
 and ,NA,NA
donebad,NA,NA
" conditions, both user-defined, for ",NA,NA
when the iteration should stop with success and failure respectively: ,NA,NA
"iterate(Pred) :- repeatcond, iterate2(Pred), ",NA,NA
"donegood. iterate2(Pred) :- call(Pred), !.",NA,NA
repeatcond.,NA,NA
"repeatcond :- not(donebad), repeatcond.",NA,NA
"Another kind of iteration increases a counter at each iteration, like the ""FOR"" construct in Pascal and the ""DO"" ",NA,NA
construct in Fortran which iterate for K=1 to N: ,NA,NA
"foriterate(Pred,N) :- asserta(counter(0)), repeat, ",NA,NA
"counter(K), K2 is K+1, retract(counter(K)), ",NA,NA
"asserta(counter(K2)),",NA,NA
" iterate2(Pred), K=<N.",NA,NA
"iterate2(Pred) :- call(Pred), !.",NA,NA
repeat.,NA,NA
repeat :- repeat.,NA,NA
"To access the counter at any time inside the rules invoked by calling Pred, you query predicate ",NA,NA
counter,NA,NA
. ,NA,NA
Implementing best-first search (*) ,NA,NA
Now we can show our best-first search program. To use it you need (besides ,NA,NA
successor,NA,NA
 and ,NA,NA
goalreached,NA,NA
 definitions) a ,NA,NA
definition of a function predicate ,NA,NA
eval,NA,NA
" of two arguments. As we said in Section 10.1, the first argument to ",NA,NA
eval,NA,NA
 is an ,NA,NA
"input state, and its second is an output number, a nonnegative evaluation of that state. ",NA,NA
"The best-first program keeps an agenda of states like the breadth-first program, but each agenda fact has a third ",NA,NA
argument holding the evaluation function value for the state. (It makes sense to compute this when we find the state ,NA,NA
"and put it on the agenda, so we only do it once per state.) And when we select a state from an agenda with the ",NA,NA
pick_best_state,NA,NA
" predicate, we must take the state with the minimum evaluation function value, not just the first one on ",NA,NA
the agenda. Our best-first search program also has iteration in several places where the breadth-first search program ,NA,NA
"used recursion, so it's a more efficient program. Here's the best-first search program, whose predicate hierarchy ",NA,NA
appears in Figure 10-6: ,NA,NA
/* Problem-independent best-first search */ ,NA,NA
"bestsearch(Start,Goalpathlist) :- cleandatabase,",NA,NA
" add_state(Start,[]), repeatifagenda,",NA,NA
" pick_best_state(State,Pathlist),",NA,NA
" add_successors(State,Pathlist), agenda(State,Goalpathlist,E),",NA,NA
" retract(agenda(State,Goalpathlist,E)), measurework.",NA,NA
"pick_best_state(State,Pathlist) :-",NA,NA
" asserta(beststate(dummy,dummy,dummy)),",NA,NA
" agenda(S,SL,E), beststate(S2,SL2,E2), special_less_than(E,E2), ",NA,NA
"retract(beststate(S2,SL2,E2)), asserta(beststate(S,SL,E)), fail.",NA,NA
"pick_best_state(State,Pathlist) :- beststate(State,Pathlist,E),",NA,NA
" retract(beststate(State,Pathlist,E)), not(E=dummy), !.",NA,NA
"add_successors(State,Pathlist) :- goalreached(State), !. ",NA,NA
"add_successors(State,Pathlist) :- successor(State,Newstate),",NA,NA
" add_state(Newstate,Pathlist), fail.",NA,NA
"add_successors(State,Pathlist) :-",NA,NA
" retract(agenda(State,Pathlist,E)),",NA,NA
" asserta(usedstate(State)), fail.",NA,NA
"add_state(Newstate,Pathlist) :- not(usedstate(Newstate)), ",NA,NA
"not(agenda(Newstate,P,E)), eval(Newstate,Enew),",NA,NA
" asserta(agenda(Newstate,[Newstate|Pathlist],Enew)), !.",NA,NA
"add_state(Newstate,Pathlist) :- not(eval(Newstate,Enew)), ",NA,NA
"write('Warning: your evaluation function failed on state '), ",NA,NA
"write(Newstate), nl, !.",NA,NA
/* Utility functions ,NA,NA
*/ ,NA,NA
repeatifagenda.,NA,NA
"repeatifagenda :- agenda(X,Y,Z), repeatifagenda.",NA,NA
"special_less_than(X,dummy) :- !. ",NA,NA
"special_less_than(X,Y) :- X<Y.",NA,NA
"cleandatabase :- checkabolish(agenda,3), checkabolish(usedstate,1),",NA,NA
" checkabolish(beststate,1), checkabolish(counter,1).",NA,NA
"checkabolish(P,N) :- abolish(P,N), !. ",NA,NA
"checkabolish(P,N).",NA,NA
"measurework :- countup(agenda(X,Y,Z),NA), ",NA,NA
"countup(usedstate(S),NB), write(NA), write(' incompletely ",NA,NA
"examined state(s) and '),",NA,NA
" write(NB),write(' examined state(s)'), !.",NA,NA
"countup(P,N) :- asserta(counter(0)), call(P), counter(K),",NA,NA
 ,NA,NA
"retract(counter(K)), K2 is K+1, asserta(counter(K2)), fail. ",NA,NA
"countup(P,N) :- counter(N), retract(counter(N)), !.",NA,NA
The top-level ,NA,NA
bestsearch,NA,NA
 predicate iterates by repeatedly picking a state from the agenda. It initializes and cleans up ,NA,NA
around a kernel of commands repeatedly invoked. But the iteration is done differently from the ,NA,NA
breadthsearch ,NA,NA
"program, with the ",NA,NA
bestsearch,NA,NA
 bouncing among a ,NA,NA
repeatifagenda,NA,NA
" predicate on the left, the ",NA,NA
pick_best_state,NA,NA
" predicate, ",NA,NA
and an ,NA,NA
add_successors,NA,NA
 on the right. The ,NA,NA
repeatifagenda,NA,NA
 is an instance of the ,NA,NA
repeatcond,NA,NA
 discussed in the last ,NA,NA
section. ,NA,NA
The ,NA,NA
pick_best_state,NA,NA
 chooses the minimum-evaluation state by iterating over the agenda states; the cut predicate at the ,NA,NA
end of its definition ensures that it finds only one such state per call. The ,NA,NA
add_successors,NA,NA
 checks whether some state ,NA,NA
S ,NA,NA
"is a goal state (then succeeding), and otherwise adds all the acceptable successors of ",NA,NA
S,NA,NA
 to the agenda (then failing); the ,NA,NA
predicate ,NA,NA
add_state,NA,NA
 runs the necessary acceptance checks on a new state before adding it to the agenda. When ,NA,NA
add_successors,NA,NA
" finally succeeds, the path associated with its state argument must be the solution, so this is retrieved ",NA,NA
and bound to the answer ,NA,NA
Goalpathlist,NA,NA
. ,NA,NA
"As an example, let's use best-first search on the bolts problem of Section 10.2. We need an evaluation function. Our ",NA,NA
goal is to get part ,NA,NA
c,NA,NA
 on part ,NA,NA
e,NA,NA
", so we could take the sum of the number of parts on top of both ",NA,NA
c,NA,NA
 and ,NA,NA
e,NA,NA
". That is, we could ",NA,NA
"measure the degree of ""burial"" of each. But then many states have evaluation zero. Instead, let's try: ",NA,NA
"eval(S,0) :- goalreached(S).",NA,NA
"eval(S,N) :- burial(c,S,N1), burial(e,S,N2), N is N1+N2+1.",NA,NA
"burial(P,S,0) :- cleartop(P,S).",NA,NA
"burial(P,S,N) :- member(on(X,P,B),S), burial(X,S,N2), N is N2+1.",NA,NA
Running ,NA,NA
bestsearch,NA,NA
" on the same starting state as before, we get the third answer for breadth-first search: ",NA,NA
?- ,NA,NA
"bestsearch([on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
 ,NA,NA
"on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)],A). ",NA,NA
23 incompletely examined state(s) and 4 examined state(s) ,NA,NA
"A=[[on(c,e,bolt2),on(b,surface,none),on(a,surface,none),",NA,NA
" on(d,surface,none),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(b,surface,none),on(a,surface,none),on(d,surface,none),",NA,NA
 ,NA,NA
"on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(a,surface,none),on(d,surface,none),on(b,c,bolt1),",NA,NA
" on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(d,surface,none),on(a,b,bolt1),on(b,c,bolt1),",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (16 of 34) [23/04/2002 17:39:09],NA
 ,NA,NA
"on(c,surface,bolt1),on(e,f,bolt2),on(f,surface,bolt2)], ",NA,NA
"[on(a,b,bolt1),on(b,c,bolt1),on(c,surface,bolt1),",NA,NA
" on(d,e,bolt2),on(e,f,bolt2),on(f,surface,bolt2)]]",NA,NA
But look how many fewer states were found--27 (23+4) versus 82. That's more efficient search. ,NA,NA
Implementing A* search (*) ,NA,NA
"A* search is like best-first except we must add path cost to the evaluation function. So as we said, the user must ",NA,NA
define a ,NA,NA
cost,NA,NA
" function predicate with two arguments, an input path and an output holding the computed cost of that ",NA,NA
path. ,NA,NA
"Our A* program is intended to be forgiving. So it still works if you don't give it a lower-bound cost function, though ",NA,NA
you may need to type semicolons to get the right (lowest-cost) answer. Also without a lower-bound evaluation ,NA,NA
"function, the first path found to any state ",NA,NA
S,NA,NA
" may not be lowest-cost, so if we find a lower-cost path to ",NA,NA
S,NA,NA
" later, we ",NA,NA
must revise the path lists of everything on the agenda mentioning ,NA,NA
S,NA,NA
. ,NA,NA
Here's the program (whose predicate hierarchy is summarized in Figure 10-7): ,NA,NA
/* Problem-independent A* search code. */ ,NA,NA
"/* Note: ""cost"" must be nonnegative.  The ""eval"" should be a lower ",NA,NA
*/ /* bound on cost in order for the first answer found to be */ ,NA,NA
"/* guaranteed optimal, but the right answer will be reached */ ",NA,NA
/* eventually otherwise.  */,NA,NA
"astarsearch(Start,Goalpathlist) :- cleandatabase,",NA,NA
" add_state(Start,[]), repeatifagenda,",NA,NA
" pick_best_state(State,Pathlist),",NA,NA
" add_successors(State,Pathlist), ",NA,NA
"agenda(State,Goalpathlist,C,D), ",NA,NA
"retract(agenda(State,Goalpathlist,C,D)), measurework.",NA,NA
"pick_best_state(State,Pathlist) :-",NA,NA
" asserta(beststate(dummy,dummy,dummy)),",NA,NA
" agenda(S,SL,C,D), beststate(S2,SL2,D2), ",NA,NA
"special_less_than(D,D2), retract(beststate(S2,SL2,D2)), ",NA,NA
"asserta(beststate(S,SL,D)), fail.",NA,NA
"pick_best_state(State,Pathlist) :- ",NA,NA
"beststate(State,Pathlist,D),",NA,NA
 ,NA,NA
"retract(beststate(State,Pathlist,D)), not(D=dummy), !.",NA,NA
"add_successors(State,Pathlist) :- goalreached(State), !. ",NA,NA
"add_successors(State,Pathlist) :- ",NA,NA
"successor(State,Newstate),",NA,NA
" add_state(Newstate,Pathlist), ",NA,NA
fail.,NA,NA
"add_successors(State,Pathlist) :-",NA,NA
 ,NA,NA
"retract(agenda(State,Pathlist,C,D)),",NA,NA
" asserta(usedstate(State,C)), fail.",NA,NA
/* If you are sure that your evaluation function is always,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (17 of 34) [23/04/2002 17:39:09],NA
"/* a lower bound on the cost function, then you can delete the */ ",NA,NA
"/* first rule for ""agenda_check"" and the first rule for */ ",NA,NA
"/* ""usedstate_check"", and delete the entire definitions of */ /* ",NA,NA
"""fix_agenda"", ""replace_front"", and ""append"". */ ",NA,NA
"add_state(Newstate,Pathlist) :- cost([Newstate|Pathlist],Cnew), !,",NA,NA
" agenda_check(Newstate,Cnew), !,",NA,NA
" usedstate_check(Newstate,Pathlist,Cnew), !,",NA,NA
" eval(Newstate,Enew), D is Enew + Cnew,",NA,NA
" asserta(agenda(Newstate,[Newstate|Pathlist],Cnew,D)), !.",NA,NA
"add_state(Newstate,Pathlist) :-",NA,NA
" not(cost([Newstate|Pathlist],Cnew)),",NA,NA
" write('Warning: your cost function failed on path list '), ",NA,NA
"write(Pathlist), nl, !.",NA,NA
"add_state(Newstate,Pathlist) :- not(eval(Newstate,Enew)), ",NA,NA
"write('Warning: your evaluation function failed on state '), ",NA,NA
"write(Newstate), nl, !.",NA,NA
"agenda_check(S,C) :- agenda(S,P2,C2,D2), ",NA,NA
"C<C2,",NA,NA
" retract(agenda(S,P2,C2,D2)), !.",NA,NA
"agenda_check(S,C) :- agenda(S,P2,C2,D2), !, ",NA,NA
"fail. agenda_check(S,C).",NA,NA
"usedstate_check(S,P,C) :- usedstate(S,C2), C<C2,",NA,NA
" retract(usedstate(S,C2)), asserta(usedstate(S,C)), ",NA,NA
"!, fix_agenda(S,P,C,C2).",NA,NA
"usedstate_check(S,P,C) :- usedstate(S,C2), !, ",NA,NA
"fail. usedstate_check(S,P,C).",NA,NA
"fix_agenda(S,P,C,OldC) :- agenda(S2,P2,C2,D2), ",NA,NA
"replace_front(P,S,P2,Pnew), cost(Pnew,Cnew), ",NA,NA
"Dnew is D2+C-OldC, retract(agenda(S2,P2,C2,D2)), ",NA,NA
"asserta(agenda(S2,Pnew,Cnew,Dnew)), fail.",NA,NA
"replace_front(P,S,P2,Pnew) :- ",NA,NA
"append(P3,[S|P4],P2),",NA,NA
" append(P,[S|P4],Pnew), !.",NA,NA
/* Utility functions ,NA,NA
*/ ,NA,NA
repeatifagenda.,NA,NA
"repeatifagenda :- agenda(X,Y,Z,W), repeatifagenda.",NA,NA
"special_less_than(X,dummy) :- !. ",NA,NA
"special_less_than(X,Y) :- X<Y.",NA,NA
"cleandatabase :- checkabolish(agenda,4), checkabolish(usedstate,2),",NA,NA
 ,NA,NA
"checkabolish(beststate,1), checkabolish(counter,1).",NA,NA
"checkabolish(P,N) :- abolish(P,N), !. ",NA,NA
"checkabolish(P,N).",NA,NA
"measurework :- countup(agenda(X,Y,C,D),NA),",NA,NA
" countup(usedstate(S,C),NB), write(NA),",NA,NA
" write(' incompletely examined state(s) and '), ",NA,NA
"write(NB),write(' examined state(s).'), !.",NA,NA
"countup(P,N) :- asserta(counter(0)), call(P), counter(K),",NA,NA
 ,NA,NA
"retract(counter(K)), K2 is K+1, asserta(counter(K2)), fail. ",NA,NA
"countup(P,N) :- counter(N), retract(counter(N)), !.",NA,NA
"append([],L,L).",NA,NA
"append([I|L1],L2,[I|L3]) :- append(L1,L2,L3).",NA,NA
Implementing search with heuristics (*) ,NA,NA
Heuristics define a policy for choosing things from the agenda in search. So searching with heuristics can be ,NA,NA
implemented by redefining the ,NA,NA
pick_best_state,NA,NA
" in the best-first program, and leaving the rest of the program ",NA,NA
"unchanged. Specifically, it should pick the first state on the agenda for which no other state is preferred by heuristics: ",NA,NA
"pick_best_state(State,Pathlist) :-",NA,NA
" agenda(State,Pathlist,E), not(better_pick(State,Pathlist,E)), !.",NA,NA
"better_pick(X,Y,E) :- agenda(X2,Y2,E2), not(X=X2), prefer(X2,Y2,E2,X,Y,E).",NA,NA
"This same idea was used to implement meta-rules in Section 7.16, and a heuristic ",NA,NA
is ,NA,NA
"a kind of meta-rule, a rule ",NA,NA
guiding usage of ,NA,NA
successor,NA,NA
 rules. We'll broaden the concept of a heuristic here to allow use of evaluation functions in ,NA,NA
"its decision, to be fully general. ",NA,NA
Such ,NA,NA
extended heuristics,NA,NA
 can be defined with a ,NA,NA
prefer,NA,NA
 predicate of six arguments: two groups of three where the ,NA,NA
first group represents an agenda item preferred to an agenda item represented by the second group. Each group ,NA,NA
"represents the three arguments to agenda facts: state, path list, and evaluation-function value. (The last can be left ",NA,NA
unbound and ignored if numeric evaluation is hard.) So ,NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- E1 < E2.",NA,NA
"implements best-first search, and ",NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- length(Y1,L1), length(Y2,L2), L1 < L2. ",NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2+1.",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (19 of 34) [23/04/2002 17:39:09],NA
"implements breadth-first search, and ",NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- fail.",NA,NA
"(or equivalently, no ",NA,NA
prefer,NA,NA
 rule at all) implements depth-first search. (Then the first agenda item will always be ,NA,NA
"picked; it will always be the successor found most recently, thanks to the ",NA,NA
asserta,NA,NA
 in ,NA,NA
add_state,NA,NA
.) These ,NA,NA
prefer,NA,NA
 rules can ,NA,NA
"also refer to quite specific characteristics of a search problem, though then they can't be reused in other search ",NA,NA
"problems as much. For instance for the bolts problem, we want part ",NA,NA
c,NA,NA
 on part ,NA,NA
e,NA,NA
", so a heuristic would be to prefer a state ",NA,NA
in which the top of ,NA,NA
e,NA,NA
 is clear: ,NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- cleartop(e,X1), not(cleartop(e,X2)).",NA,NA
"We can have several extended heuristics for a problem, and they will be tried in the order given. For instance we can ",NA,NA
do a best-first search with a breadth-first criterion to break ties between states with the same evaluation-function value: ,NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- E1 < E2.",NA,NA
"prefer(X1,Y1,E,X2,Y2,E) :- length(Y1,L1), length(Y2,L2), L1 < L2.",NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2+1.",NA,NA
We could also combine breadth-first and best-first search in a different way: ,NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- Ep1 is E1+1, Ep1 < E2.",NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :-",NA,NA
" length(Y1,L1), length(Y2,L2), L1 < L2.",NA,NA
"This says to prefer states according to the evaluation function if they are more than one unit apart, but otherwise ",NA,NA
pick the state closest to the start. ,NA,NA
Sets of heuristics or extended heuristics can exhibit complex behavior; they can be an extensive rule-based system on ,NA,NA
their own. The most important heuristics (,NA,NA
prefer,NA,NA
" rules) should be first, then general-purpose heuristics, and finally ",NA,NA
"default heuristics. As rule-based system rules go, heuristics are powerful because they can be quite general: we can ",NA,NA
often reuse the same heuristic in many different problems. ,NA,NA
The preceding heuristics choose among states. Other heuristics choose among branches of (operators applied to) a ,NA,NA
"state, but these can often be transformed into the first kind by having them reference characteristics of the result of the ",NA,NA
desired branch. ,NA,NA
Compilation of search (*) ,NA,NA
Since a search problem can be seen as a rule-based system with ,NA,NA
successor,NA,NA
" rules, it isn't surprising that we can use ",NA,NA
"compilation techniques for rule-based systems to make search faster. We can exploit all the ""compiled forms"" in the ",NA,NA
"lower half of Figure 6-1, except virtual facts and decision lattices which require questioning (this is uncommon in ",NA,NA
search). ,NA,NA
"Caching is helpful and simple to apply. An agenda is one form of a cache, but we can extend an agenda to include ",NA,NA
"entries from previous related problems. So as we solve problems, we gradually build up a library of solutions, some to ",NA,NA
"full problems and some to subproblems, to make new problems easier. If this creates a large agenda, we can index or ",NA,NA
"hash items for fast lookup. If this is still too slow or requires too much storage, we can cache selectively, using as ",NA,NA
criterion the amount of work needed to compute the item and perhaps statistics on how often it was used in problems. ,NA,NA
"Caching criteria can also be suggested by the problem itself, as in route planning in a city for which it makes sense to ",NA,NA
cache routes between landmarks. ,NA,NA
"Partitioning or modularization is important in many areas of computer science, and search is no exception. Groups of ",NA,NA
"related operators can be put into partitions, each loaded as needed. File loads can be done by a ",NA,NA
consult,NA,NA
 last in a ,NA,NA
successor,NA,NA
 rule. Partitions are essential for a system with many ,NA,NA
successor,NA,NA
" rules, like a general-purpose car repair ",NA,NA
"system, for which quite different parts of the car require quite different repair techniques, so many operator have ",NA,NA
narrow applicability. ,NA,NA
Parallelism can increase the speed of successor rules too. All four types of parallelism discussed in Section 6.9 can be ,NA,NA
"used: partition parallelism, ""and"" parallelism, ""or"" parallelism and variable-matching parallelism. Actual concurrency ",NA,NA
in execution is essential for speed in real-time applications. Good examples are the lattices used for high-performance ,NA,NA
"speech-understanding systems, a kind of and-or-not lattice representing parallelism taken to the maximum extent. For ",NA,NA
"a fixed vocabulary of words, the lattice corresponds to every possible sequence in which sounds can occur to express ",NA,NA
"grammatical utterances using those words. Each node in the lattice represents a sound, and each branch represents a ",NA,NA
transition to a possible next sound. The speech to be understood is first broken into small varying-length segments ,NA,NA
representing homogeneous (constant-nature) intervals in the speech. A cost function is used that measures the ,NA,NA
"""distance"" any segment comes to some ""ideal"" sound. Speech recognition then becomes an optimal-path search ",NA,NA
"problem, in which we want to find a path through a lattice that minimizes the sum of the branch costs. Such ",NA,NA
precompiled search lattices have many other real-time applications. ,NA,NA
.SH Keywords: ,NA,NA
frame problem,NA,NA
agenda of states,NA,NA
the bagof predicate,NA,NA
the cut predicate,NA,NA
iteration,NA,NA
Exercises ,NA,NA
"10-1. (R,A,P) (a) Improve the depth-first search program to print out the answer path list in the forward (opposite) ",NA,NA
order. Print one state per line. ,NA,NA
(b) Suppose we want a search answer to include names of operators used at each step in the solution. Explain how you ,NA,NA
can do this by writing the problem-dependent files in a certain way without making any changes at all to the problem-,NA,NA
independent files. ,NA,NA
"(c) Suppose states are lists of facts in which the order of the facts doesn't matter--that is, states are described by sets ",NA,NA
of ,NA,NA
"facts, not lists. Modify the depth-first search program to prevent going to ""permutation"" states that have the same facts ",NA,NA
as an already-examined state but in a different order. ,NA,NA
10-2. (P) Country X and country Y are carefully negotiating an arms agreement. Each has missiles of varying ,NA,NA
"strengths, each strength summarized by a single number. Each step in the negotiation does one of two things: (1) ",NA,NA
"eliminates from both sides a single missile of the same numerical strength, or (2) eliminates from one side a missile of ",NA,NA
strength S and from the other side two missiles whose strength sums to S. Write a program that figures out a sequence ,NA,NA
"of such negotiation steps that will eliminate all the missiles entirely from one or both of the sides, but making sure in ",NA,NA
the process that no side ever has more than one more missile than the other. ,NA,NA
Use the depth-first program to do searching. Assume to start: ,NA,NA
"Country X: missile strengths 9, 11, 9, 3, 4, 5, 7, 18 ",NA,NA
"Country Y: missile strengths 12, 2, 16, 5, 7, 4, 20 ",NA,NA
Type semicolons to your program to get alternative solutions. ,NA,NA
Hints: use the ,NA,NA
member,NA,NA
 and ,NA,NA
delete,NA,NA
" predicates from Sections 5.5 and 5.6, and define a ",NA,NA
twomembers,NA,NA
 which says ,NA,NA
two things are different items from the same list. ,NA,NA
10-3. Suppose we modify the bolts problem in Section 10.2 a bit. Suppose we have the same operators and ,NA,NA
"starting state, but our goal is to get part ",NA,NA
b,NA,NA
 and part ,NA,NA
c,NA,NA
" on bolt 1, with ",NA,NA
c,NA,NA
 above ,NA,NA
b,NA,NA
 instead of vice versa. ,NA,NA
(a) Give the ,NA,NA
goalreached,NA,NA
 definition. ,NA,NA
(b) Give a corresponding ,NA,NA
eval,NA,NA
 definition. ,NA,NA
(c) What answer will breadth-first search find? ,NA,NA
"10-4. (P) We didn't show the bolts problem being solved with depth-first search, and there's a good reason: it takes ",NA,NA
"a long time to solve it, a thousand times more perhaps than breadth-first. ",NA,NA
(a) Study the program to see why it's taking so much time for such a simple problem. Insert additional code to print ,NA,NA
out what it's doing periodically. ,NA,NA
(b) One possible reason is the lack of unordered sets as opposed to lists in Prolog. Explain why this is a problem. Then ,NA,NA
explain how you would change the problem-independent code for depth-first search to eliminate this problem. Do so ,NA,NA
and see if efficiency improves. ,NA,NA
(c) Another suggestion is to use heuristics to control the depth-first search. But the implementation of heuristics given ,NA,NA
in Section 10.11 isn't very helpful. Why not? ,NA,NA
"(d) Explain how, in place of meta-rules or heuristics, additional successor rules can be written. Do this for the bolts ",NA,NA
program and analyze the improvement in performance. ,NA,NA
"10-5. (R,A,P) Load into the Prolog interpreter the breadth-first program given in Section 10.5 and the ",NA,NA
following additional code: ,NA,NA
"glassesdepth(Cap1,Cap2,Goal,Ans) :- checkretract(cap1(C1)),",NA,NA
" checkretract(cap2(C2)), checkretract(goalvolume(G)),",NA,NA
" checkassert(cap1(Cap1)), checkassert(cap2(Cap2)),",NA,NA
" checkassert(goalvolume(Goal)), !, depthsearch([0,0],Ans).",NA,NA
"glassesbreadth(Cap1,Cap2,Goal,Ans) :- checkretract(cap1(C1)), ",NA,NA
"checkretract(cap2(C2)), checkretract(goalvolume(G)),",NA,NA
" checkassert(cap1(Cap1)), checkassert(cap2(Cap2)),",NA,NA
" checkassert(goalvolume(Goal)), !, breadthsearch([0,0],Ans).",NA,NA
"goalreached([Goalvolume,V2]) :- goalvolume(Goalvolume). ",NA,NA
"goalreached([V1,Goalvolume]) :- goalvolume(Goalvolume).",NA,NA
"successor([V1,V2],[Vsum,0]) :- V2 > 0, Vsum is V1 + V2,",NA,NA
" cap1(Cap1), Vsum =< Cap1.",NA,NA
"successor([V1,V2],[0,Vsum]) :- V1 > 0, Vsum is V1 + V2,",NA,NA
" cap2(Cap2), Vsum =< Cap2.",NA,NA
"successor([V1,V2],[Cap1,Vdiff]) :- V2 > 0, V1 >= 0,",NA,NA
" cap1(Cap1), Vdiff is V2 - ( Cap1 - V1 ), Vdiff > ",NA,NA
0.,NA,NA
"successor([V1,V2],[Vdiff,Cap2]) :- V1 > 0, V2 >= 0,",NA,NA
" cap2(Cap2), Vdiff is V1 - ( Cap2 - V2 ), Vdiff > ",NA,NA
"0. successor([V1,V2],[Cap1,V2]) :- cap1(Cap1).",NA,NA
"successor([V1,V2],[V1,Cap2]) :- cap2(Cap2).",NA,NA
"successor([V1,V2],[0,V2]).",NA,NA
"successor([V1,V2],[V1,0]).",NA,NA
"checkassert(S) :- call(S), !. ",NA,NA
checkassert(S) :- asserta(S).,NA,NA
"checkretract(S) :- call(S), retract(S), ",NA,NA
fail. checkretract(S).,NA,NA
This code defines a famous puzzle known as the water-glass problem. You have two empty glasses of capacities C1 ,NA,NA
"and C2, a faucet to fill the glasses with water, and a drain. The glasses are not marked along the sides so you can't fill ",NA,NA
"them a specified partial amount. The goal is to get a certain fixed quantity of liquid. To do this you can fill the glasses, ",NA,NA
"empty the glasses, pour all of one glass into another, or fill one glass from the other. To run the program, type ",NA,NA
"?- glassesbreadth(<capacity-glass-1>,<capacity-glass-2>,<goal-",NA,NA
"amount>,<answer>).",NA,NA
"for which the first three arguments are inputs, numbers you must fill in, and the last is the output. ",NA,NA
(a) First study the situation in which you have two glasses of sizes 5 and 7. Call the predicate ,NA,NA
glassesbreadth,NA,NA
 with ,NA,NA
"goal amounts equal to 0, 1, 2, 3, 4, 5, 6, 7, and 8, and construct a diagram of all possible states and their connections. ",NA,NA
Type the semicolon to obtain all distinct solutions. Note that ,NA,NA
<answer>,NA,NA
" represents a stack (i.e., it's in reverse ",NA,NA
chronological order). Describe the overall pattern in the diagram. ,NA,NA
(b) Now use the depth-first program given in the chapter. Invoke it with ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (23 of 34) [23/04/2002 17:39:09],NA
?- glassesdepth,NA,NA
" (<capacity-glass-1>,<capacity-glass-2>,<goal-amount>,<answer>).",NA,NA
"Try it on all the situations considered previously, and draw its state diagram. Describe how the diagram is different ",NA,NA
"from that for breadth-first search. In particular, how does the depth-first state diagram relate to the breadth-first ",NA,NA
diagram? ,NA,NA
(c) Explain what each of the eight ,NA,NA
successor,NA,NA
 rules does. ,NA,NA
(d) Modify the preceding code defining the operators so that the solutions found will have the desired quantity in the ,NA,NA
"left glass (that is, the glass with the first-mentioned capacity). Test your code with the breadth-first search code. ",NA,NA
"10-6. (H,P) ",NA,NA
Beam search,NA,NA
" is a more efficient kind of breadth-first search, a sort of cross between breadth-first search ",NA,NA
"and best-first search. Rather than putting all the successors of a given state on the agenda, it only puts the K best ",NA,NA
successors according to the evaluation function. Modify the breadth-first search program to do beam search. ,NA,NA
"10-7. (A,P) Modify the A* search program to do a branch-and-bound search. ",NA,NA
"10-8. In the city-route planning example of Section 10.1, the last line of the cost function definition seems very ",NA,NA
dangerous: it would seem to define an infinite loop. Such definitions of commutativity for predicates always have such ,NA,NA
dangers. ,NA,NA
(a) What advantage is gained by having such a line in the definitions? ,NA,NA
(b) Why can the danger be ignored for this particular cost function definition used with the A* search program? ,NA,NA
(c) Suppose we are doing route planning in which the routes are highways and the nodes are cities. If you can go ,NA,NA
from city X to city Y along route R you can also go from Y to X backward along R. So state transitions would be ,NA,NA
"commutative, and we could write a single commutativity rule to state this, like the commutativity rule in the cost ",NA,NA
"function definition. Why wouldn't this be a good idea, when it generally is a good idea with costs? ",NA,NA
"10-9. (R,P) (a) Consider a housekeeping robot that must clean a two-room suite (Figure 10-8). It must vacuum the ",NA,NA
"floors, dust, and empty the trash baskets. Vacuuming the floor generates dust that goes into the trash basket of the ",NA,NA
"room it is in. Emptying the trash baskets in each room requires a trip to the trash chute. Dusting puts dust on the floor, ",NA,NA
requiring vacuuming. ,NA,NA
Assume the following energy costs: ,NA,NA
--10 units to vacuum a single room (assume the robot has a built-in vacuum); ,NA,NA
--6 units to dust a room (assume the robot has a built-in duster); ,NA,NA
--3 units to pick up a trash basket (assume the robot can hold more than one); ,NA,NA
--1 unit to put down a trash basket; ,NA,NA
--3 units to travel between the two offices; ,NA,NA
--8 units to travel between an office and the trash chute (assume there are doors to the trash chute ,NA,NA
from both rooms); ,NA,NA
--5 units to dispose of the contents of a trash basket down the trash chute. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (24 of 34) [23/04/2002 17:39:09],NA
Use the following reasonable preconditions for actions (and no others): ,NA,NA
--It doesn't make sense to vacuum or dust if the room isn't vacuumable or dusty respectively. ,NA,NA
--It doesn't make sense to dust if a room is vacuumable. ,NA,NA
--It doesn't make sense to pick up a trash basket if a room is vacuumable or dusty. ,NA,NA
--It doesn't make sense to put down something you just picked up. ,NA,NA
"For the starting state, assume the robot is at the trash chute. Assume that both rooms need dusting. Office 1 has trash in ",NA,NA
"its trash basket, but Office 2 doesn't; and the carpet in Office 1 does not need vacuuming, while the carpet in Office 2 ",NA,NA
"does. The goal is to get everything dusted, every carpet vacuumed, and every basket emptied. The robot must finish at ",NA,NA
either room but not at the trash chute. ,NA,NA
"Set this problem up for the A* search program for this chapter. Give appropriate definitions, including a good ",NA,NA
"evaluation function, one that gives a lower bound on the cost to a goal state. You may find you run out of space; if so, ",NA,NA
revise the program to eliminate unnecessary successors. Run the program and show your results. ,NA,NA
"Hints: make the first item in each state represent the last operator applied, or ""none"" for the starting state. Have the cost ",NA,NA
function use these to assign costs. You don't need ,NA,NA
append,NA,NA
 or ,NA,NA
=,NA,NA
 anywhere in your program; use the left sides of rules to ,NA,NA
get their effect. And in defining ,NA,NA
successor,NA,NA
", it may improve efficiency to rule out new states in which the facts are just ",NA,NA
permutations (ignoring the last-operator-applied item) of the facts in some other state already on the agenda or already ,NA,NA
"visited, as in Exercise 10-1(c). ",NA,NA
"10-10. (A,P) Combining chemicals to react and make new chemicals is a kind of search. Find a good way to ",NA,NA
represent states and successor functions for operations including these: ,NA,NA
"If we combine one mole of |Cl sub 2| and one mole of |H sub 2 O|, you get one mole of |H Cl O| and one ",NA,NA
mole of |H Cl|. ,NA,NA
"If you combine one mole of |Ca C O sub 3| with two moles of |H Cl|, you get one mole of |Ca Cl sub 2|, ",NA,NA
"one mole of |C O sub 2|, and one mole of |H sub 2 O|. ",NA,NA
"If you combine two moles of |H sub 2 O sub 2| and one mole of |Mn O sub 2|, you get two moles of ",NA,NA
"|H sub 2 O|, one mole of |O sub 2|, and one mole of |Mn O sub 2| (that is, manganese dioxide is only a ",NA,NA
catalyst). ,NA,NA
"If you combine one mole of |H sub 2| and one mole of |Cl sub 2|, you get two moles of |H Cl|. ",NA,NA
"If you combine four moles of |H Cl| with one mole of |Mn O sub 2|, you get one mole of |Mn Cl sub 2|, ",NA,NA
"two moles of |H sub 2 O|, and one mole of |Cl sub 2|. ",NA,NA
Hint: represent states by lists of lists. ,NA,NA
"(b) Write Prolog code, and try it with the depth-first program. Do the problem of making 1 mole of |Ca Cl sub 2| from ",NA,NA
"a starting state consisting of 2 moles of |Cl sub 2|, 1 mole of |Mn O sub 2|, 1 mole of |Ca C O sub 3|, and 2 moles of |H ",NA,NA
"sub 2 O sub 2|. That is, find a sequence of operations that could lead to a mole of |Ca Cl sub 2| being formed--not ",NA,NA
necessarily the only way it could be formed. Hint: use the ,NA,NA
member,NA,NA
" predicate of Section 5.5, and the ",NA,NA
delete,NA,NA
 predicate ,NA,NA
of Section 5.6 or the ,NA,NA
deleteone,NA,NA
 of Section 10.7. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (25 of 34) [23/04/2002 17:39:10],NA
"(c) Describe a cost function that would be meaningful for this kind of search problem, and describe a corresponding ",NA,NA
evaluation function. ,NA,NA
(d) The Prolog interpreter's conflict-resolution method (trying rules in the order they appear) is not good for ,NA,NA
"chemical-reaction rules. Explain why, and suggest (describe) a better conflict-resolution method from ideas in ",NA,NA
Chapter 6. ,NA,NA
10-11. Suppose you are doing a best-first search in a search space of N states. ,NA,NA
(a) Suppose only one state in the search space satisfies the condition for a goal state. What is the smallest maximum ,NA,NA
size of the agenda during the finding of this goal state? ,NA,NA
"(b) For the same situation as part (a), what is the largest maximum size of the agenda during the finding of the ",NA,NA
goal state? ,NA,NA
(c) Now suppose there is no goal state in the search space and we must search to confirm this. What is now the ,NA,NA
smallest maximum size of the agenda in this process of confirmation? ,NA,NA
"(d) For the situation in part (c), what is the largest maximum size of the agenda? ",NA,NA
10-12. (A) Suppose a search space can be represented as a complete (filled-in) and balanced binary tree of 31 states on ,NA,NA
four levels (not counting the starting state as a level). Suppose there is a single goal state that does lie in the search ,NA,NA
space. ,NA,NA
(a) Suppose we are doing a breadth-first search. What is the maximum possible size of the agenda? ,NA,NA
(b) Suppose we are doing a best-first search. What is the maximum possible size of the agenda? ,NA,NA
"10-13. When a search problem has a solution, breadth-first search, best-first search, and A* search cannot get into an ",NA,NA
infinite loop. So it's not strictly necessary to check for previously visited states--that just improves the efficiency of ,NA,NA
"search. There are also searches for which the added overhead of checking isn't worth it, and we'd like to define some ",NA,NA
criteria for recognizing such situations. ,NA,NA
"(a) Suppose for some search problem there are B successors of every state on the average, fraction P of which are ",NA,NA
previously visited (either on the agenda or the oldagenda) on the average. How many states can we expect in the ,NA,NA
search lattice up to and including level K for both visited-state pruning and no pruning at all? ,NA,NA
(b) Suppose on the average visited-state checking requires E units of time while all the other processing required of a ,NA,NA
state (finding it and adding it to the agenda) requires C units on the average. Give an inequality for deciding when ,NA,NA
visited-state checking pays off. ,NA,NA
(c) Now suppose that visited-state checking is not constant time but increases proportionately to the level in the search ,NA,NA
"lattice; let's say the dependency is AK, K the level. What now is the inequality for deciding whether visited-state ",NA,NA
checking pays off? ,NA,NA
10-14.(a) Consider the following program. Suppose it is only used when the first two arguments are bound (inputs) ,NA,NA
"and the third argument is unbound (an output). Could a cut predicate improve efficiency? If so, under what ",NA,NA
"circumstances, ",NA,NA
and where would you put it? Assume the rules are in a database in the order listed. ,NA,NA
"countup(I,[I|L],N) :- countup(I,L,N2), N is N2+1.",NA,NA
"countup(I,[X|L],N) :- countup(I,L,N), not(I=X).",NA,NA
"countup(I,[],0).",NA,NA
(b) Discuss why the cut predicate is often so tricky and hard to use. ,NA,NA
"10-15. (A,P) The Micro-Prolog dialect of Prolog has an interesting built-in feature: you can ask it to find and match ",NA,NA
"the Kth rule or fact that is able to match some query. Implement this feature in the ""standard"" Prolog of this book, ",NA,NA
using ,NA,NA
asserta,NA,NA
". Assume you are given a predicate expression P that is to be queried K times, and assume that P has no ",NA,NA
side effects so that it is OK to query the previous K-1 matches to it. ,NA,NA
"10-16. Yet another kind of iteration not yet considered occurs with the ""mapcar"" feature of Lisp and the vector-",NA,NA
processing features of APL. Something similar can be provided for every two-argument function predicate in Prolog. ,NA,NA
Suppose we have a function predicate ,NA,NA
"f(X,Y)",NA,NA
. We would want to define a new predicate ,NA,NA
"f_of_list(L,FL)",NA,NA
 such that ,NA,NA
FL ,NA,NA
is a list created by applying the ,NA,NA
f,NA,NA
 function to every element of the ,NA,NA
L,NA,NA
" list in turn. For example, suppose we had a ",NA,NA
defined predicate ,NA,NA
double,NA,NA
: ,NA,NA
"double(X,Y) :- Y is 2 * X.",NA,NA
then querying ,NA,NA
"?- double_of_list([1,3,4],L).",NA,NA
will result in ,NA,NA
"L=[2,6,8]",NA,NA
Write a Prolog definition of ,NA,NA
double_of_list,NA,NA
. Explain how the idea can be generalized to other predicates. ,NA,NA
10-17. Implement each of the following heuristics in the way described in Section 10.11 using a six-argument ,NA,NA
prefer ,NA,NA
predicate. Assume they are called on by something like the best-first search program ,NA,NA
bestsearch,NA,NA
. ,NA,NA
(a) Prefer a state whose fact-list description includes an predicate named ,NA,NA
zzxxy,NA,NA
 of one argument. ,NA,NA
"(b) Prefer the state about which the fewest facts are true, assuming states are represented as lists of facts true in them. ",NA,NA
(c) Prefer the state whose path list involves the fewest fact additions and deletions along its course. (Assume states are ,NA,NA
described as lists of facts true in them.) ,NA,NA
(d) Prefer any state to one that was a successor to the last state selected. ,NA,NA
"10-18. Redo Exercise 5-12, but this time have the third argument be the ",NA,NA
minimum,NA,NA
 distance between two things. ,NA,NA
Allow for the possibility of cycles in the facts and more than one route between things. ,NA,NA
"10-19. (E) Suppose we defined a search problem in Prolog, and we now want to try searching backward, as perhaps ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (27 of 34) [23/04/2002 17:39:10],NA
"when the forward search didn't work well. To make things easier, assume there is a single goal state known ",NA,NA
beforehand. ,NA,NA
(a) Give a simple way the definition of the cost function can be modified to provide a cost function for the new ,NA,NA
backward search. ,NA,NA
(b) Give a simple way the evaluation function can be modified to provide an evaluation function for the new problem ,NA,NA
of searching backward. ,NA,NA
(c) Describe in general terms how the successor predicate definitions must be modified. Note that some definitions ,NA,NA
"are easier to use backward than others, so explain which ones these are. ",NA,NA
10-20. (P) The program following | REFERENCE 3| plays the game of Reversi. .FS | REFERENCE 3| This and other ,NA,NA
"major programs in this book are available on tape from the publisher. .FE In this game, two players take turns placing ",NA,NA
pieces on a checkerboard; their pieces are indicated by the symbols ,NA,NA
X,NA,NA
 and ,NA,NA
O,NA,NA
. Players place pieces so as to surround ,NA,NA
"part of a row, column, or diagonal containing an unbroken string of the opponent's pieces; the pieces so surrounded are ",NA,NA
"""captured"" and become the opposite (surrounding player's) pieces. A player must always move so as to capture at least ",NA,NA
"one opposing piece; if a player can't move, they forfeit their turn. The game is over when neither player can move; then ",NA,NA
"the player with the most pieces on the board wins. Here's an example of the program output, in which first a human ",NA,NA
"player makes a move, and then the computer. ",NA,NA
8 X X X X X X X ,NA,NA
_ ,NA,NA
7 O O O O X O _ ,NA,NA
_ ,NA,NA
6 X O X X X O _ ,NA,NA
_ ,NA,NA
5 X O O X X O _ ,NA,NA
_ ,NA,NA
4 X O O O X O _ ,NA,NA
_ ,NA,NA
4 X O O X O O _ ,NA,NA
_ ,NA,NA
2 _ O O X X O _ ,NA,NA
_ ,NA,NA
1 _ _ O O X O _ ,NA,NA
_,NA,NA
 1 2 3 4 5 6 7 8 ,NA,NA
Give move:76.,NA,NA
8 X X X X X X X _ ,NA,NA
7 O O O O X X _ _ ,NA,NA
6 X O X X X X X _ ,NA,NA
5 X O O X X X _ _ ,NA,NA
4 X O O O X O _ _ ,NA,NA
3 X O O X O O _ _ ,NA,NA
2 _ O O X X O _ _ ,NA,NA
1 _ _ O O X O _ _,NA,NA
 1 2 3 4 5 6 7 8 ,NA,NA
Evaluation of move 12 is 2 ,NA,NA
Evaluation of move 74 is ,NA,NA
193 ,NA,NA
Evaluation of move 75 is ,NA,NA
191 ,NA,NA
Evaluation of move 86 is ,NA,NA
144 ,NA,NA
Evaluation of move 77 is ,NA,NA
178 ,NA,NA
Evaluation of move 87 is ,NA,NA
266 ,NA,NA
I make move 12,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (28 of 34) [23/04/2002 17:39:10],NA
"In the program, the board is stored as an 8-item list of 8-item lists, where a 0 element means a blank board position, a ",NA,NA
"1 element means a board position occupied by the human player, and a -1 element means a board position occupied by ",NA,NA
"the computer player. States are represented as 10-item lists: the player who last moved, the move they took, and the ",NA,NA
eight rows of the resulting board position. ,NA,NA
(a) The program shown following uses a simple evaluation function. Redefine ,NA,NA
pick_best_move,NA,NA
 so it uses nonnumeric ,NA,NA
"heuristics to select a move. That is, don't use any numbers for move selection except to look up board positions by row ",NA,NA
and column number. ,NA,NA
(b) Now change ,NA,NA
gamesearch,NA,NA
" so the computer can play against itself, using your heuristics for player 1 and its ",NA,NA
evaluation function for player -1. Make sure by your heuristics that player 1 wins--improve the heuristics as necessary. ,NA,NA
"Then use the heuristics for player -1, and the evaluation function for player 1, and further improve the heuristics ",NA,NA
as necessary so that player -1 wins. ,NA,NA
(c) Now change the ,NA,NA
pick_best_move,NA,NA
 rules for player -1 so it looks ahead ahead one move to anticipate what the other ,NA,NA
"player will do, and chooses the move leading to the best result assuming player 1 always makes the best choice ",NA,NA
available to them. Run this smarter player against the heuristics from part (b) used for player 1. Who wins? ,NA,NA
"(d) Probably player -1 won in part (c), but the comparison wasn't fair because player 1 doesn't look ahead. But they ",NA,NA
don't need to if they just have better heuristics. Demonstrate this. ,NA,NA
/* Top-level routines */ ,NA,NA
go :-,NA,NA
" write('This program plays the game of Reversi (X is you, O is ",NA,NA
"me).'),",NA,NA
" nl, start_state(SS), gamesearch(SS).",NA,NA
"start_state([-1,none,Z,Z,Z,[0,0,0,1,-1,0,0,0],[0,0,0,-",NA,NA
"1,1,0,0,0],Z,Z,Z])",NA,NA
 :- zero_row(Z).,NA,NA
"zero_row([0,0,0,0,0,0,0,0]).",NA,NA
"gamesearch(State) :- goalreached(State), print_win(State), !.",NA,NA
"gamesearch([-1,M|B]) :- not(get_move(B,1,S,NB)),",NA,NA
" write('You cannot move so I get another turn.'), nl, !, ",NA,NA
"gamesearch([1,M|B]).",NA,NA
"gamesearch([-1,OM|B]) :- print_board(B), write('Give move:'), ",NA,NA
"repeatread(Movecode), move_decode(Movecode,Move),",NA,NA
" get_move(B,1,Move,NB), !, gamesearch([1,Move|NB]).",NA,NA
"gamesearch([1,M|B]) :-  print_board(B),",NA,NA
" pick_best_move([1,M|B],Newstate),",NA,NA
" write_move(Newstate), !, ",NA,NA
gamesearch(Newstate).,NA,NA
"gamesearch([1,M|B]) :- not(get_move(B,-1,S,NB)),",NA,NA
" not(get_move(B,1,S,NB)), print_win([1,M|B]), ",NA,NA
!.,NA,NA
"gamesearch([1,M|B]) :- not(get_move(B,-1,S,NB)),",NA,NA
" write('I cannot move so you get another turn.'),",NA,NA
" nl, !, gamesearch([-1,M|B]).",NA,NA
"gamesearch(S) :- print_win(S), !.",NA,NA
/* Intermediate routines */ ,NA,NA
"pick_best_move(S,NS) :- asserta(ebest(none,1000000)), ",NA,NA
"successor(S,S2),",NA,NA
" eval(S2,E2), write_eval(S2,E2), ebest(S1,E1), ",NA,NA
"E2<E1,",NA,NA
" retract(ebest(S1,E1)), asserta(ebest(S2,E2)), fail.",NA,NA
"pick_best_move(S,NS) :- ebest(NS,E), retract(ebest(NS,E)).",NA,NA
"goalreached([X,Y|B]) :- not(somezero(B)).",NA,NA
"somezero(B) :- member(R,B), member(0,R).",NA,NA
"successor([OP,Lastmove|Oldboard],[P,M|Newboard]) ",NA,NA
":- opposite(OP,P), ",NA,NA
"get_move(Oldboard,P,M,Newboard).",NA,NA
"opposite(1,-1). ",NA,NA
"opposite(-1,1).",NA,NA
repeatread(M) :- read(M).,NA,NA
repeatread(M) :- write('Invalid move.  Try ,NA,NA
"again:'),",NA,NA
" nl, repeatread(M).",NA,NA
"move_decode(M,[X,Y]) :- X is M//10, Y is M mod 10.",NA,NA
/* Printing routines */ ,NA,NA
"write_move([P,[X,Y]|B]) :- Move is (10*X)+Y, write('I make move ",NA,NA
"'),",NA,NA
" write(Move), nl, !.",NA,NA
"write_eval([P,[X,Y]|B],E) :- write('Evaluation of move '), ",NA,NA
"Movecode is (10*X)+Y, write(Movecode), write(' is '), ",NA,NA
"write(E), nl, !.",NA,NA
"print_win([P,M|B]) :- print_board(B),",NA,NA
" countup(1,B,N1), countup(-1,B,N2), ",NA,NA
"print_win2(N1,N2).",NA,NA
"print_win2(N1,N2) :- N2<N1, write('Congratulations! You win.'), ",NA,NA
"nl. print_win2(N1,N2) :- N2>N1, write('Sorry--I win.'), nl.",NA,NA
"print_win2(N,N) :- write('The game is a draw.'), nl.",NA,NA
"countup(I,[],0) :- !.",NA,NA
"countup(I,[R|B],N) :- countrow(I,R,N2), countup(I,B,N3), N is N2+N3.",NA,NA
"countrow(I,[],0) :- !.",NA,NA
"countrow(I,[I|L],N) :- countrow(I,L,N2), N is N2+1, ",NA,NA
"!. countrow(I,[J|L],N) :- countrow(I,L,N).",NA,NA
"print_board(B) :- reverse(B,RB), print_board2(RB,8), !.",NA,NA
"print_board2([],N) :- write('  1 2 3 4 5 6 7 8'), nl.",NA,NA
"print_board2([Row|Board],N) :- write(N), print_row(Row), N2 is N-",NA,NA
"1,",NA,NA
" print_board2(Board,N2).",NA,NA
print_row([]) :- nl.,NA,NA
"print_row([I|Row]) :- decode(I,DI), write(' '), write(DI),",NA,NA
 print_row(Row).,NA,NA
"decode(0,'_'). ",NA,NA
"decode(1,'X'). ",NA,NA
decode(-,NA,NA
"1,'O').",NA,NA
/* Move generation */ ,NA,NA
"get_move(B,P,[X,Y],NB) :- get_move2(B,[X,Y],FR,BR,FI,BI),",NA,NA
" fix_key_row_half(P,FI,NFI), fix_key_row_half(P,BI,NBI),",NA,NA
" fix_rows(FR,X,P,NFR), fix_rows(BR,X,P,NBR),",NA,NA
" not(nochange(FI,NFI,BI,NBI,FR,NFR,BR,NBR)),",NA,NA
" reverse(NFI,RFI), reverse(NFR,RFR),",NA,NA
" append(RFI,[P|NBI],Row), append(RFR,[Row|NBR],NB).",NA,NA
"nochange(X,X,Y,Y,A,B,C,D) :- samefront(A,B), samefront(C,D).",NA,NA
"samefront([],[]) :- !. ",NA,NA
"samefront([X|L],[X|M])",NA,NA
.,NA,NA
"get_move2(B,M,FR,BR,FI,BI) :- get_move3(B,1,[],M,FR,BR,FI,BI).",NA,NA
"get_move3([R|B],Y,FR,[X,Y],FR,B,FI,BI) :- ",NA,NA
"get_move4(R,1,[],X,FI,BI). get_move3([R|B],Y,FR,M,FRF,BR,FI,BI) :-  ",NA,NA
"Y2 is Y+1,",NA,NA
" get_move3(B,Y2,[R|FR],M,FRF,BR,FI,BI).",NA,NA
"get_move4([0|R],X,FI,X,FI,R).",NA,NA
"get_move4([I|R],X,FI,XF,FIF,BI) :- X2 is ",NA,NA
"X+1,",NA,NA
" get_move4(R,X2,[I|FI],XF,FIF,BI).",NA,NA
/* Board update for a particular move */ ,NA,NA
"fix_key_row_half(P,R,NR) :- fix_key_row_half2(P,R,NR), !.",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (31 of 34) [23/04/2002 17:39:10],NA
"fix_key_row_half(P,R,R) :- !.",NA,NA
"fix_key_row_half2(P,[],[]) :- !, fail.",NA,NA
"fix_key_row_half2(P,[0|L],[0|L]) :- !, fail.",NA,NA
"fix_key_row_half2(P,[P|L],[P|L]) :- !.",NA,NA
"fix_key_row_half2(P,[OP|L],[P|L2]) :- ",NA,NA
"opposite(P,OP),",NA,NA
" fix_key_row_half2(P,L,L2).",NA,NA
"fix_rows([],X,P,[]) :- !.",NA,NA
"fix_rows([R],X,P,[R]) :- !.",NA,NA
"fix_rows(B,X,P,NB) :- Xm1 is X-1, Xp1 is X+1, opposite(P,OP),",NA,NA
" fix_rows2(B,OP,NB,Xm1,X,Xp1,VL,VM,VR), !.",NA,NA
"fix_rows2(B,OP,B,dead,dead,dead,VL,VM,VR).",NA,NA
"fix_rows2([],OP,[],XL,XM,XR,VL,VM,VR) :- ",NA,NA
"topfix(OP,VL),",NA,NA
" topfix(OP,VM), topfix(OP,VR).",NA,NA
"fix_rows2([R|B],OP,[NR|NB],XL,XM,XR,VL,VM,VR) :- ",NA,NA
"fix_rowL(R,OP,1,NR,XL,XM,XR,VL,VM,VR,NXL,NXM,NXR), ",NA,NA
"fix_rows2(B,OP,NB,NXL,NXM,NXR,VL,VM,VR).",NA,NA
"topfix(OP,OP) :- ",NA,NA
!. ,NA,NA
"topfix(OP,V).",NA,NA
"fix_rowL(R,OP,X,NR,dead,dead,XR,VL,VM,VR,dead,dead,NXR) :-",NA,NA
" fix_rowR(R,OP,X,NR,XR,VR,NXR).",NA,NA
"fix_rowL(R,OP,X,NR,dead,XM,XR,VL,VM,VR,dead,NXM,NXR) ",NA,NA
:-,NA,NA
" fix_rowM(R,OP,X,NR,XM,XR,VM,VR,NXM,NXR).",NA,NA
"fix_rowL(R,OP,X,NR,0,XM,XR,OP,VM,VR,dead,NXM,NXR) ",NA,NA
:-,NA,NA
" fix_rowM(R,OP,X,NR,XM,XR,VM,VR,NXM,NXR).",NA,NA
"fix_rowL([0|R],OP,X,[0|NR],X,XM,XR,OP,VM,VR,dead,NXM,NXR)",NA,NA
 :- ,NA,NA
"Xp1 is X+1, fix_rowM(R,OP,Xp1,NR,XM,XR,VM,VR,NXM,NXR). ",NA,NA
"fix_rowL([OP|R],OP,X,[VL|NR],X,XM,XR,VL,VM,VR,Xm1,NXM,NXR) :-",NA,NA
" Xp1 is X+1, Xm1 is X-1,",NA,NA
" fix_rowM(R,OP,Xp1,NR,XM,XR,VM,VR,NXM,NXR).",NA,NA
"fix_rowL([P|R],OP,X,[P|NR],X,XM,XR,P,VM,VR,dead,NXM,NXR) :- ",NA,NA
"Xp1 is X+1, opposite(OP,P),",NA,NA
" fix_rowM(R,OP,Xp1,NR,XM,XR,VM,VR,NXM,NXR).",NA,NA
"fix_rowL([I|R],OP,X,[I|NR],XL,XM,XR,VL,VM,VR,NXL,NXM,NXR) :- ",NA,NA
"Xp1 is X+1,",NA,NA
" fix_rowL(R,OP,Xp1,NR,XL,XM,XR,VL,VM,VR,NXL,NXM,NXR).",NA,NA
"fix_rowM(R,OP,X,NR,dead,XR,VM,VR,dead,NXR) ",NA,NA
:-,NA,NA
" fix_rowR(R,OP,X,NR,XR,VR,NXR).",NA,NA
"fix_rowM([0|R],OP,X,[0|NR],X,XR,OP,VR,dead,NXR) :-  Xp1 is X+1,",NA,NA
" fix_rowR(R,OP,Xp1,NR,XR,VR,NXR).",NA,NA
"fix_rowM([OP|R],OP,X,[VM|NR],X,XR,VM,VR,X,NXR) :-  Xp1 is X+1,",NA,NA
" fix_rowR(R,OP,Xp1,NR,XR,VR,NXR).",NA,NA
"fix_rowM([P|R],OP,X,[P|NR],X,XR,P,VR,dead,NXR) :-  Xp1 is X+1,",NA,NA
" opposite(OP,P), fix_rowR(R,OP,Xp1,NR,XR,VR,NXR).",NA,NA
"fix_rowM([I|R],OP,X,[I|NR],XM,XR,VM,VR,NVM,NXR) :-  Xp1 is X+1,",NA,NA
" fix_rowM(R,OP,Xp1,NR,XM,XR,VM,VR,NVM,NXR).",NA,NA
"fix_rowR(R,OP,X,R,dead,VR,dead).",NA,NA
"fix_rowR(R,OP,X,R,9,OP,dead).",NA,NA
"fix_rowR([0|R],OP,X,[0|R],X,OP,dead).",NA,NA
"fix_rowR([OP|R],OP,X,[VR|R],X,VR,Xp1) :- Xp1 is X+1. ",NA,NA
"fix_rowR([P|R],OP,X,[P|R],X,P,dead) :- ",NA,NA
"opposite(OP,P).",NA,NA
"fix_rowR([I|R],OP,X,[I|NR],XR,VR,NXR) :- Xp1 is ",NA,NA
"X+1,",NA,NA
" fix_rowR(R,OP,Xp1,NR,XR,VR,NXR).",NA,NA
/* Evaluation function */ ,NA,NA
"eval([P,[X,Y],A,B,C,D,E,F,G,H],Ev) :- ",NA,NA
"eval2s(A,B,Ev1),",NA,NA
" eval2s(H,G,Ev2), eval2m(C,Ev3), ",NA,NA
"eval2m(D,Ev4),",NA,NA
" eval2m(E,Ev5), eval2m(F,Ev6),",NA,NA
" Ev is -P*(Ev1+Ev2+Ev3+Ev4+Ev5+Ev6), !.",NA,NA
"eval2m([A,B,C,D,E,F,G,H],Ev) :-",NA,NA
 Ev2 is ((30*A)+(-15*B)+C+D+E+F+(-,NA,NA
"15*G)+(30*H)), sc(A,B,C1), sc(H,G,C2), Ev is ",NA,NA
"Ev2+C1+C2, !.",NA,NA
"sc(0,B,0).",NA,NA
"sc(A,0,0).",NA,NA
"sc(1,1,30).",NA,NA
"sc(1,-1,20).",NA,NA
"sc(-1,-1,-30). ",NA,NA
"sc(-1,1,-20).",NA,NA
"eval2s([A,B,C,D,E,F,G,H],[I,J,K,L,M,N,O,P],Ev) :-",NA,NA
 Ev2 is,NA,NA
" (200*A)+(-50*B)+(30*C)+(30*D)+(30*E)+(30*F)+(-50*G)+(200*H),",NA,NA
 ,NA,NA
Ev3 is,NA,NA
" -((50*I)+(100*J)+(15*K)+(15*L)+(15*M)+(15*N)+(100*O)+(50*P)),",NA,NA
" sc2(A,I,J,B,Ev4), sc2(H,G,O,P,Ev5), sc(C,K,Ev6), sc(D,L,Ev7),",NA,NA
" sc(E,M,Ev8), sc(F,N,Ev9),",NA,NA
" Ev is Ev2+Ev3+Ev4+Ev5+Ev6+Ev7+Ev8+Ev9, !.",NA,NA
"sc2(0,B,C,D,0).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (33 of 34) [23/04/2002 17:39:10],NA
"sc2(A,B,C,D,Ev) :- sc(A,B,E1), sc(A,C,E2), ",NA,NA
"sc(A,D,E3),",NA,NA
 Ev is 3*(E1+E2+E2+E3).,NA,NA
/* Utility functions */ ,NA,NA
"reverse(L,RL) :- reverse2(L,[],RL), !.",NA,NA
"reverse2([],L,L).",NA,NA
"reverse2([X|L],L2,RL) :- reverse2(L,[X|L2],RL).",NA,NA
"append([],L,L) :- !.",NA,NA
"append([X|L],L2,[X|L3]) :- append(L,L2,L3).",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap10.html (34 of 34) [23/04/2002 17:39:10],NA
Abstraction in search ,NA,NA
"When people solve without computers the search problems discussed in the last two chapters, they only ",NA,NA
"use the techniques so far described as a last resort. Instead, they try to reason about abstractions, what's ",NA,NA
known as ,NA,NA
hierarchical reasoning,NA,NA
. ,NA,NA
Abstraction is simplifying your model of the world so you can reason more easily about it. Intermediate ,NA,NA
"predicates for rule-based systems (see Section 7.5) are one form of abstraction, since they summarize a ",NA,NA
category of data and provide a handle on that summarization. Abstraction is essential in organizing and ,NA,NA
"managing large numbers of facts, as we will see in the next chapter. Abstraction is also a way to simplify ",NA,NA
"large search problems. Search abstraction works best when a problem is decomposable, and exploits the ",NA,NA
preconditions and postconditions of operators. ,NA,NA
Means-ends analysis ,NA,NA
The classic technique for solving search problems by abstraction is means-ends analysis. It applies to ,NA,NA
"those decomposable search problems (see Section 9.12) for which clear ""major operators"" or ",NA,NA
"""recommended operators"" on the solution path can be identified in advance. To specify the these ",NA,NA
"operators for specific situations, means-ends analysis needs something like a table. Usually these tables ",NA,NA
"refer to the difference between the current state and the goal state, and are thus called ",NA,NA
difference tables,NA,NA
. ,NA,NA
Difference tables describe operators in terms of their preconditions and postconditions (see Section 9.4). ,NA,NA
So they're akin to the ,NA,NA
successor,NA,NA
" definitions of Chapter 10, but with one big difference: difference tables ",NA,NA
only ,NA,NA
recommend ,NA,NA
"an operator appropriate to a state and a goal, with no concern if the operator can actually ",NA,NA
be applied to the state. Difference tables provide a way of decomposing a problem into three simpler ,NA,NA
subproblems: a subproblem of getting from the current state to a state in which we can apply the ,NA,NA
"recommended operator, a subproblem of applying the operator, and a subproblem of going from there to ",NA,NA
"the goal state. Formally, a search from state S to some goal state G is decomposed into: ",NA,NA
1. satisfying the preconditions (prerequisites) for some recommended operator O when ,NA,NA
"starting from S, by going to state S2; ",NA,NA
2. applying operator O to S2 to get to state S3 (by postconditions); ,NA,NA
3. going from S3 to the goal state G. ,NA,NA
"The first and third steps are search problems themselves, possibly requiring additional decompositions of ",NA,NA
their own by the difference table. So means-ends analysis is recursive search. Means-ends analysis is also ,NA,NA
hierarchical reasoning because we start with big wholes and gradually reason down to little details. The ,NA,NA
ends truly justify the means. ,NA,NA
Complete and correct specification in the difference table of preconditions and postconditions of ,NA,NA
"operators is essential for means-ends analysis. In particular, you must carefully distinguish preconditions ",NA,NA
from the looser conditions recommending operators. Both could be mixed together in the ,NA,NA
successor,NA,NA
 rules ,NA,NA
"of Chapter 10, but that won't work here. ",NA,NA
A simple example ,NA,NA
"Means-ends analysis is useful for many human ""planning"" activities. Here's a simple example of planning ",NA,NA
"for an office worker. Suppose we have a difference table of three rules (see Figure 11-1), written ",NA,NA
informally as: ,NA,NA
"If in your current state you are hungry, and in your goal state you are not hungry, then ",NA,NA
"either the ""visit_cafeteria"" or ""visit_vending_machine"" operator is recommended. ",NA,NA
"If in your current state you do not have change, and if in your goal state you have change, ",NA,NA
"then the ""visit_your_office"" operator or the ""visit_secretary"" operator is recommended. ",NA,NA
"If in your current state you do not know where something is, and in your goal state you do ",NA,NA
"know, then either the ""visit_your_office"", ""visit_secretary"", or ""visit_colleague"" operator is ",NA,NA
recommended. ,NA,NA
We need preconditions and postconditions for the preceding operators: ,NA,NA
Preconditions of visit_cafeteria: you know where the cafeteria is. ,NA,NA
Postconditions of visit_cafeteria: you are no longer hungry. ,NA,NA
Preconditions of visit_vending_machine: you know where the vending machine is and you ,NA,NA
have change. ,NA,NA
Postconditions of visit_vending_machine: you are no longer hungry. ,NA,NA
Preconditions of visit_your_office: none (we assume everyone knows where his or her ,NA,NA
office is). ,NA,NA
Postconditions of visit_your_office: you have change and you know where everything is ,NA,NA
"(since you can look it up in, say, the phone directory). ",NA,NA
Preconditions of visit_secretary: you know where the secretary is and the secretary is ,NA,NA
available. ,NA,NA
"Postconditions of visit_secretary: you have change, and you know where everything is. ",NA,NA
Preconditions of visit_colleague: none. ,NA,NA
Postconditions of visit_colleague: you know where everything is. ,NA,NA
"Since we will implement difference tables in Prolog, we'll follow the usual top-to-bottom and left-to-right ",NA,NA
"conventions about order of action. So we will try difference-table rules in the order listed, try operator ",NA,NA
"alternatives in the order listed, and try to satisfy preconditions and postconditions in the order listed. So ",NA,NA
the order of rows and columns in Figure 11-1 is significant. ,NA,NA
"Let's illustrate means-ends analysis for the situation in which you are hungry, you have no change, a ",NA,NA
"secretary is available, and you are new and don't know where anything is besides your own office; and ",NA,NA
your goal is any state in which you are not hungry. (Other things can be true of your final state besides ,NA,NA
"being not hungry, but hunger relief is what you insist on.) ",NA,NA
"1. The first rule succeeds, so you want to visit the cafeteria. ",NA,NA
"2. This has the precondition that you know where the cafeteria is, and since you don't, you ",NA,NA
must recursively call on means-ends analysis to find a way to change that discrepancy ,NA,NA
(difference). ,NA,NA
"3. Only the third rule can handle this kind of a difference between a state and a goal, so we ",NA,NA
"try to apply the first operator recommended, visit_your_office. (That is, you will look ",NA,NA
through the telephone directory to locate the cafeteria.) ,NA,NA
"4. There are no preconditions for visit_your_office (everybody knows where their office is), ",NA,NA
so it can be applied without further recursion. And the state after visit_your_office satisfies ,NA,NA
the preconditions of visit_cafeteria as you hoped--no postconditions will interfere. ,NA,NA
"5. The postcondition of visit_cafeteria is that you are no longer hungry, and the goal of the ",NA,NA
problem was to make this become true. So we're done. So the operator sequence found to ,NA,NA
solve the problem is visit_your_office and then visit_cafeteria. ,NA,NA
"To show the importance of difference-table order, suppose we switch the order of visit_cafeteria and ",NA,NA
"visit_vending_machine in the first rule, switch the order of visit_your_office and visit_secretary in the ",NA,NA
"second rule, put visit_colleague first in the third rule, and switch the second and third rules, so we have ",NA,NA
(see Figure 11-2): ,NA,NA
"If in your current state you are hungry and in your goal state you are not hungry, then either ",NA,NA
"the ""visit_vending_machine"" or ""visit_cafeteria"" operator is recommended. ",NA,NA
"If in your current state you do not know where something is, and in your goal state you do ",NA,NA
"know, then either the ""visit_colleague"", ""visit_your_office"", or ""visit_secretary"" operator is ",NA,NA
recommended. ,NA,NA
"If in your current state you do not have change and if in your goal state you have change, ",NA,NA
"then the ""visit_secretary"" operator or the ""visit_your_office"" operator is recommended. ",NA,NA
"Let's redo the problem in which you are hungry, you need change, a secretary is available, and you don't ",NA,NA
"know anything, and you want to get to a state in which you are no longer hungry. Means-ends analysis ",NA,NA
"finds a different, but equally valid, solution: ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap11.html (3 of 19) [23/04/2002 17:39:13],NA
"1. The first rule succeeds, so it is recommended that you first try to visit a vending ",NA,NA
machine. This has two preconditions: that you know where one is and you have change. ,NA,NA
2. We recursively call on means-ends analysis to satisfy these preconditions. The starting ,NA,NA
"state is the original starting state, and the new goal is any state in which you know where a ",NA,NA
vending machine is and you have change. ,NA,NA
"3. The first rule won't help this difference, but the second rule will, the one that ",NA,NA
recommends visiting a colleague (to ask where a vending machine is). This has no ,NA,NA
"preconditions, so you can directly apply it. ",NA,NA
"4. After applying the postconditions of visit_colleague, we must still get to a state in which ",NA,NA
"we have change; remember, visit_vending_machine had two preconditions. (All my ",NA,NA
colleagues are poor and never have any change--or so they tell me.) So we need a recursive ,NA,NA
"""postcondition search"" to accomplish this, from the state in which we are hungry, we need ",NA,NA
"change, a secretary is available, and we know everything. For this difference the third rule is ",NA,NA
"recommended, and the recommended operator is visit_secretary. ",NA,NA
5. This has two preconditions: that you know where the secretary is and that secretary is ,NA,NA
"available. Both conditions hold in the current state (the first condition since the beginning, ",NA,NA
and the second condition was just accomplished by visit_colleague). So we can directly ,NA,NA
apply visit_secretary. ,NA,NA
"6. Now taking into account the postconditions of visit_secretary, we're in a state in which ",NA,NA
"we are hungry, we have change, a secretary is available, and we know where everything is. ",NA,NA
"This satisfies all the conditions of the visit_vending_machine operator, so we apply it. ",NA,NA
"Examining its postconditions, we see we've reached a goal state. ",NA,NA
7. So the overall operator sequence is to visit your colleague to find out where a vending ,NA,NA
"machine is and where the secretary is, visit the secretary to get change, and then visit a ",NA,NA
vending machine. ,NA,NA
"This example didn't require backtracking, but you may need it when your first choice for a rule or ",NA,NA
"operator doesn't pan out, just as with depth-first search. A choice doesn't pan out when no way can be ",NA,NA
"found to satisfy the preconditions or to handle the postconditions. However, the more ""intelligent"" nature ",NA,NA
of means-ends analysis compared to the other search methods means that it backtracks a lot less than they ,NA,NA
do on nicely decomposable problems. ,NA,NA
This example of means-ends analysis is highly simplified. If we wanted to realistically model the way ,NA,NA
"people solve daily problems like the preceding, we would need a lot more operators, preconditions, and ",NA,NA
"postconditions. Nevertheless, many psychologists argue that something like means-ends analysis ",NA,NA
underlies much human activity. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap11.html (4 of 19) [23/04/2002 17:39:13],NA
Partial state description ,NA,NA
"In the preceding example, we described goal states by giving a few facts that must be true in them. For ",NA,NA
"instance, we said the overall goal was a state in which you are no longer hungry. This ",NA,NA
partial state ,NA,NA
description,NA,NA
" is very common with means-ends analysis, because it's hard to define a single ",NA,NA
goalreached ,NA,NA
predicate when each precondition decomposition has a different goal. ,NA,NA
"Since means-ends analysis is driven by differences between states, we must be careful to define this ",NA,NA
"difference for partial state descriptions. Basically, we can go through the list of facts describing the goal ",NA,NA
"G and ""cross out"" facts also true for current state S. Here's the definition: ",NA,NA
"difference([],S,[]).",NA,NA
"difference([P|G],S,G2) :- singlemember(P,S), !, difference(G,S,G2).",NA,NA
"difference([P|G],S,[P|G2]) :- difference(G,S,G2).",NA,NA
(Predicate ,NA,NA
singlemember,NA,NA
 was defined in Section 10.7 and checks only once whether an item is a member ,NA,NA
of a list; the ,NA,NA
!,NA,NA
 (cut symbol) was explained in Section 10.7 too.) Then we write difference-table rules to ,NA,NA
refer to these differences. ,NA,NA
So for instance: ,NA,NA
?-difference,NA,NA
" ([on(b,c),on(e,f),on(a,e)],[on(a,b),on(b,c),on(d,e),on(e,f)],D).",NA,NA
"D=[on(a,e)]",NA,NA
Implementation of means-ends analysis ,NA,NA
"With these details out of the way, implementation of means-ends analysis is straightforward. We ",NA,NA
represent the difference table with rules and/or facts defining ,NA,NA
"recommended(<difference>,<operator>)",NA,NA
where ,NA,NA
<difference>,NA,NA
 is some result (binding of the third argument) of the ,NA,NA
difference,NA,NA
 predicate defined in ,NA,NA
"the last section, and ",NA,NA
<operator>,NA,NA
" is the name of a recommended operator. Generally, each operator will ",NA,NA
have at least one ,NA,NA
recommended,NA,NA
 definition. ,NA,NA
"Preconditions are best expressed as two-argument facts. The first argument can be the operator, and the ",NA,NA
"second argument the list of associated preconditions, predicate expressions that must be present in a state ",NA,NA
description for the operator to be used in that state: ,NA,NA
"precondition(<operator>,[<predexpr1>,<predexpr2>,...]).",NA,NA
"But postconditions are tricky. An operator can not only make certain conditions true, but can make ",NA,NA
"certain other true conditions become false--otherwise, we couldn't undo anything. So we'll distinguish ",NA,NA
"two kinds of postconditions: predicate expressions added by an operator, and predicate expressions ",NA,NA
deleted. ,NA,NA
"addpostcondition(<operator>,[<predexpr1>,<predexpr2>...]). ",NA,NA
"deletepostcondition(<operator>,[<predexpr1>,<predexpr2>...]).",NA,NA
"By the way, operators can have arguments just as in Chapter 9, and these arguments can be referenced in ",NA,NA
the precondition and postcondition lists. ,NA,NA
That covers the format of the problem-dependent part of means-ends analysis; now for the problem-,NA,NA
independent part. We'll use ,NA,NA
double recursion,NA,NA
", which sounds like a horrible disease but just means a ",NA,NA
self-referencing program that self-references twice. Our top-level rule will be a recursive ,NA,NA
means_ends ,NA,NA
predicate of four arguments: ,NA,NA
State,NA,NA
", a complete list of facts true in the starting state (an input); ",NA,NA
Goal,NA,NA
", a list of those facts that must be true in the goal state, a partial description of the goal ",NA,NA
state (an input); ,NA,NA
Oplist,NA,NA
", the of operators that will get you from the start to the goal (an output); ",NA,NA
Goalstate,NA,NA
", the complete list of facts true in the goal state (an output). ",NA,NA
Here's the program: ,NA,NA
/* Problem-independent means-ends analysis */ ,NA,NA
"means_ends(State,Goal,[],State) :- difference(Goal,State,[]), !.",NA,NA
"means_ends(State,Goal,Oplist,Goalstate) :-",NA,NA
" difference(Goal,State,D),",NA,NA
" recommended(Dsub,Operator), subset(Dsub,D), ",NA,NA
"precondition(Operator,Prelist),",NA,NA
" means_ends(State,Prelist,Preoplist,Prestate), ",NA,NA
"deletepostcondition(Operator,Deletepostlist), ",NA,NA
"deleteitems(Deletepostlist,Prestate,Prestate2), ",NA,NA
"addpostcondition(Operator,Addpostlist),",NA,NA
" union(Addpostlist,Prestate2,Postlist),",NA,NA
" means_ends(Postlist,Goal,Postoplist,Goalstate), ",NA,NA
"append(Preoplist,[Operator|Postoplist],Oplist).",NA,NA
"This recursive program has a single basis step (the first line), which says we don't need any operators to ",NA,NA
solve a problem in which the starting state includes all the goal facts. The rest of the lines are a single ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap11.html (6 of 19) [23/04/2002 17:39:13],NA
"induction step, which you'll note has two recursive calls: the first for the preconditions, the second for the ",NA,NA
postconditions. The lines say to first compute the list of facts different between ,NA,NA
State,NA,NA
 and ,NA,NA
Goal,NA,NA
", and find a ",NA,NA
recommended operator for some subset of those facts. Look up the preconditions of the operator and ,NA,NA
recursively call ,NA,NA
means_ends,NA,NA
 to figure how to satisfy them. Then look up the deletion postconditions and ,NA,NA
delete them from the final state resulting from the precondition recursion; look up the addition ,NA,NA
"postconditions, and add them to that state. Now we have the state after application of the original ",NA,NA
recommended operator. So recursively call ,NA,NA
means_ends,NA,NA
 to figure how to get from here to the original ,NA,NA
goal. The final operator list for the whole problem is the appending together of the precondition-recursion ,NA,NA
"operator list, the recommended operator, and the postcondition-recursion operator list. ",NA,NA
The ,NA,NA
means_ends,NA,NA
 program requires five utility functions: ,NA,NA
singlemember,NA,NA
", ",NA,NA
subset,NA,NA
", ",NA,NA
append,NA,NA
", ",NA,NA
union,NA,NA
", and ",NA,NA
deleteitems,NA,NA
. The ,NA,NA
singlemember,NA,NA
" (defined in Section 10.7) checks whether an item is a member of a list, ",NA,NA
while preventing backtracking. The ,NA,NA
subset,NA,NA
 (defined in Section 5.7) says whether every item in its list first ,NA,NA
argument is also a member of its list second argument. The ,NA,NA
append,NA,NA
 (defined in Section 5.6) glues two ,NA,NA
lists together to create a new list. The ,NA,NA
union,NA,NA
 is like the ,NA,NA
append,NA,NA
 except it removes duplicates from the ,NA,NA
result. The ,NA,NA
deleteitems,NA,NA
" removes all members of one list from another list, and uses the ",NA,NA
delete,NA,NA
 predicate of ,NA,NA
"Section 5.6. To improve efficiency, cut symbols ",NA,NA
!,NA,NA
 appear in some of these definitions. ,NA,NA
/* Utility functions for means-ends analysis */,NA,NA
"singlemember(X,[X|L]) :- !.",NA,NA
"singlemember(X,[Y|L]) :- singlemember(X,L).",NA,NA
"subset([],L).",NA,NA
"subset([X|L],L2) :- singlemember(X,L2), subset(L,L2).",NA,NA
"append([],L,L).",NA,NA
"append([X|L],L2,[X|L3]) :- append(L,L2,L3).",NA,NA
"union([],L,L).",NA,NA
"union([X|L1],L2,L3) :- singlemember(X,L2), !, union(L1,L2,L3).",NA,NA
"union([X|L1],L2,[X|L3]) :- union(L1,L2,L3).",NA,NA
"deleteitems([],L,L).",NA,NA
"deleteitems([X|L],L2,L3) :- delete(X,L2,L4), deleteitems(L,L4,L3).",NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- !, delete(X,L,M).",NA,NA
"delete(X,[Y|L],[Y|M]) :- delete(X,L,M).",NA,NA
"To make the means-ends program more user-friendly, it's helpful to put in some error checking. This goes ",NA,NA
after the two original definitions of ,NA,NA
means_ends,NA,NA
. ,NA,NA
"means_ends(State,Goal,Oplist,Goalstate) :-",NA,NA
" not(difference(Goal,State,D)),",NA,NA
" write('Bug found: no difference defined between '), ",NA,NA
"write(Goal), write(' and '), write(State), nl, !, fail.",NA,NA
"means_ends(State,Goal,Oplist,Goalstate) :-",NA,NA
" difference(Goal,State,D), recommended(Dsub,Operator), ",NA,NA
"subset(Dsub,D), not(precondition(Operator,Prelist)), ",NA,NA
"write('Bug found: no preconditions given for operator '), ",NA,NA
"write(Operator), nl, !, fail.",NA,NA
"means_ends(State,Goal,Oplist,Goalstate) :-",NA,NA
" difference(Goal,State,D),",NA,NA
" recommended(Dsub,Operator), subset(Dsub,D),",NA,NA
" not(deletepostcondition(Operator,Deletepostlist)),",NA,NA
 write('Bug found: no deletepostconditions given for operator ,NA,NA
"'),",NA,NA
" write(Operator), nl, !, fail.",NA,NA
"means_ends(State,Goal,Oplist,Goalstate) :-",NA,NA
" difference(Goal,State,D),",NA,NA
" recommended(Dsub,Operator), subset(Dsub,D),",NA,NA
" not(addpostcondition(Operator,Addpostlist)),",NA,NA
" write('Bug found: no addpostconditions given for operator '), ",NA,NA
"write(Operator), nl, !, fail.",NA,NA
A harder example: flashlight repair ,NA,NA
"Car repair is often a decomposable search problem and thus appropriate for means-ends analysis, but it's ",NA,NA
"too complicated to use as an example here. So let's consider repair of a flashlight, the kind shown in ",NA,NA
"Figure 11-3. This flashlight has two batteries inside a case, attached to a light bulb. To reach the batteries ",NA,NA
"you must disassemble the case, and to reach the light bulb you must disassemble the top as well as ",NA,NA
disassembling the case. We'll use the following facts to describe states in flashlight repair (which mean ,NA,NA
what they suggest): ,NA,NA
defective(batteries). ,NA,NA
ok(batteries).,NA,NA
defective(light). ,NA,NA
ok(light).,NA,NA
open(case).,NA,NA
closed(case).,NA,NA
unbroken(case).,NA,NA
broken(case).,NA,NA
open(top).,NA,NA
closed(top).,NA,NA
inside(batteries). ,NA,NA
outside(batteries).,NA,NA
"We'll assume the following operators: replace_batteries, replace_light, disassemble_case, assemble_case, ",NA,NA
"disassemble_top, assemble_top, turn_over_case, and smash_case. ",NA,NA
Now let's apply our means-ends program to the flashlight-repair problem. First we need a difference table ,NA,NA
"(summarized in Figure 11-4), stating recommended operators with facts of the predicate name ",NA,NA
recommended,NA,NA
: ,NA,NA
"recommended([ok(batteries)],replace_batteries). ",NA,NA
"recommended([ok(light)],replace_light).",NA,NA
"recommended([open(case)],disassemble_case).",NA,NA
"recommended([open(case)],smash_case).",NA,NA
"recommended([open(top)],disassemble_top).",NA,NA
"recommended([open(top)],smash_case).",NA,NA
"recommended([closed(case)],assemble_case).",NA,NA
"recommended([closed(top)],assemble_top).",NA,NA
"recommended([outside(batteries)],turn_over_case).",NA,NA
"recommended([outside(batteries)],smash_case).",NA,NA
"As you may recall, the first argument to ",NA,NA
recommended,NA,NA
 is part of the difference of the goal from the ,NA,NA
"current state, and the second argument is the recommended operator. So the first argument is what we ",NA,NA
"want to become true, what isn't true in the starting state. So read the first fact as ""If you want to get the ",NA,NA
"batteries to be OK because they aren't now, try the replace_batteries operator."" All these ",NA,NA
"recommendations refer to single-fact desires, but that's only because it's hard to do two things at once ",NA,NA
with one action on a flashlight; other kinds of repair are different. ,NA,NA
The order of the ,NA,NA
recommended,NA,NA
" rules is important, because they'll be considered by the Prolog interpreter ",NA,NA
"in that order, and the first one applying to the given state and goal will be the first one used. So we've put ",NA,NA
"in front those for the most important operators, the ""replace_batteries"" and ""replace_light"" operators. ",NA,NA
"Several situations suggest the ""smash_case"" operator besides another operator, but we want to make ",NA,NA
"""smash_case"" a last resort, and hence put the line mentioning it after the line for the alternative. Now for ",NA,NA
the preconditions: ,NA,NA
"precondition(replace_batteries,",NA,NA
" [open(case),outside(batteries),unbroken(case)]). ",NA,NA
"precondition(replace_light,[open(top)]).",NA,NA
"precondition(disassemble_case,[closed(case)]).",NA,NA
"precondition(assemble_case,",NA,NA
" [open(case),closed(top),unbroken(case)]).",NA,NA
"precondition(disassemble_top,[open(case),closed(top)]).",NA,NA
"precondition(assemble_top,[open(top)]). ",NA,NA
"precondition(turn_over_case,[open(case)]). ",NA,NA
"precondition(smash_case,[]).",NA,NA
"Notice we don't need to list everything that must be true for an operator to be applied, only the major ",NA,NA
"conditions that imply everything else. For instance, the precondition for ""replace_light"" that the top be ",NA,NA
"open requires that the case be open first, but we will find this in looking up the preconditions to the ",NA,NA
disassemble_top operator anyway. So means-ends analysis lets us put preconditions in the places that ,NA,NA
make our programs clearest. ,NA,NA
Now for the postconditions. Often the facts deleted by postconditions (deletepostconditions) are just the ,NA,NA
"preconditions, and often the facts added by postconditions (addpostconditions) are just the opposites of all ",NA,NA
the deletepostconditions. So postconditions are often easy to write. But this isn't true when operators have ,NA,NA
"""side effects"", like the ""smash_case"" operator that does several things simultaneously--and that's one of ",NA,NA
the reasons it's not a very good operator. ,NA,NA
"deletepostcondition(replace_batteries,",NA,NA
" [outside(batteries),defective(batteries)]).",NA,NA
"deletepostcondition(replace_light,[defective(light)]).",NA,NA
"deletepostcondition(disassemble_case,[closed(case)]).",NA,NA
"deletepostcondition(assemble_case,[open(case)]).",NA,NA
"deletepostcondition(disassemble_top,[closed(top)]).",NA,NA
"deletepostcondition(assemble_top,[open(top)]).",NA,NA
"deletepostcondition(turn_over_case,[inside(batteries)]).",NA,NA
"deletepostcondition(smash_case,",NA,NA
" [unbroken(case),closed(case),closed(top),inside(batteries)]).",NA,NA
"addpostcondition(replace_batteries,",NA,NA
" [inside(batteries),ok(batteries)]).",NA,NA
"addpostcondition(replace_light,[ok(light)]).",NA,NA
"addpostcondition(disassemble_case,[open(case)]).",NA,NA
"addpostcondition(assemble_case,[closed(case)]).",NA,NA
"addpostcondition(disassemble_top,[open(top)]).",NA,NA
"addpostcondition(assemble_top,[closed(top)]).",NA,NA
"addpostcondition(turn_over_case,[outside(batteries)]).",NA,NA
"addpostcondition(smash_case,",NA,NA
" [broken(case),open(case),open(top),outside(batteries)]).",NA,NA
Note that even if some ,NA,NA
deletepostcondition,NA,NA
" facts are not true for a state, no harm is done--those facts will ",NA,NA
just be ignored--because the ,NA,NA
delete,NA,NA
 predicate and hence the ,NA,NA
deleteitems,NA,NA
" predicate always succeed, even ",NA,NA
when they don't delete anything. ,NA,NA
Running the flashlight program ,NA,NA
Let's run our flashlight and means-ends analysis code for the situation in which the batteries are defective ,NA,NA
and we want to get the flashlight working again. The correct solution is shown in Figure 11-5. Let's ,NA,NA
"assume the flashlight is assembled and unbroken when we start out, so the starting state is ",NA,NA
"[closed(case),closed(top),inside(batteries),defective(batteries),",NA,NA
" ok(light),unbroken(case)].",NA,NA
"The goal is any state in which these facts are true (i.e., this partial goal description holds): ",NA,NA
"[ok(batteries),closed(case),closed(top)].",NA,NA
"(A flashlight isn't much good unless it's put back together again, hence the last two conditions.) To do ",NA,NA
"means-ends analysis, we supply the preceding two lists as inputs (the first two arguments) to ",NA,NA
means_ends,NA,NA
", leaving the last two arguments unbound: ",NA,NA
"?- means_ends([closed(case),closed(top),inside(batteries),",NA,NA
" defective(batteries),ok(light),unbroken(case)],",NA,NA
" [ok(batteries),closed(case),closed(top)], Operators, Final_state).",NA,NA
What will happen is summarized in Figures 11-6 (an overview) and 11-7 (the details). The four ,NA,NA
arguments to ,NA,NA
means_ends,NA,NA
 (,NA,NA
"State, Goal, Oplist, and Goalstate",NA,NA
") are listed for each call, plus the local ",NA,NA
variable ,NA,NA
Operator,NA,NA
". The calls are drawn like the predicate hierarchies of Figures 10-5, 10-6, and 10-7. ",NA,NA
Oplist,NA,NA
 and ,NA,NA
Goalstate,NA,NA
" are the outputs bound as a result of reasoning, so the values shown for them are ",NA,NA
their final bindings. ,NA,NA
"In more detail, here's what Figure 11-7 recounts. Fasten your seat belts. ",NA,NA
1. The ,NA,NA
difference,NA,NA
 function is applied to the original goal and the starting state. The last two ,NA,NA
"facts in the goal cancel out, leaving only ",NA,NA
[ok(batteries)],NA,NA
". For this difference, ",NA,NA
"""replace_batteries"" is the recommended operator. The problem can then be recursively ",NA,NA
"divided into three parts: satisfying the preconditions of replace_batteries, applying it, and ",NA,NA
going from there to the original goal. ,NA,NA
"2. The three preconditions of replace_batteries are that case is open, the batteries are ",NA,NA
"outside the case, and the case is unbroken. So we recursively call the predicate ",NA,NA
means_ends,NA,NA
" with first argument the original starting state, and second argument (partial ",NA,NA
goal description) the precondition list ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap11.html (11 of 19) [23/04/2002 17:39:13],NA
"[open(case),outside(batteries),unbroken(case)].",NA,NA
3. The difference between this new goal and the original starting state is ,NA,NA
"[open(case),outside(batteries)].",NA,NA
"For this, either the ""disassemble_case"", ""smash_case"", or ""turn_over_case"" operators are ",NA,NA
"recommended. We always try the first recommendation first. That's disassemble_case, and ",NA,NA
its only precondition is that the case be closed. ,NA,NA
4. So we do a third level of recursive call with the same starting state and the goal ,NA,NA
[closed(case)].,NA,NA
But this is already true in the starting state. So the difference is ,NA,NA
[],NA,NA
", and no work must be done ",NA,NA
to solve this recursion. We succeed with the first ,NA,NA
means_ends,NA,NA
" rule (the basis step), setting ",NA,NA
the third argument (the operator list) to ,NA,NA
[],NA,NA
 and the fourth argument (the final state) to the ,NA,NA
starting state. Such trivial search problems are indicated in Figure 11-7 by the words ,NA,NA
"""nothing needed"". ",NA,NA
5. Now we return to the second level of recursion where we are trying to apply the ,NA,NA
"recommended ""disassemble_case"" operator. We just discovered that no work is needed to ",NA,NA
"satisfy preconditions, so we just figure out the consequences of disassemble_case. The ",NA,NA
facts to be deleted (the deletepostconditions) are ,NA,NA
[closed(case)],NA,NA
", and the facts to be added ",NA,NA
(the addpostconditions) are ,NA,NA
[open(case)],NA,NA
. So the state after applying disassemble_case (the ,NA,NA
Postlist,NA,NA
 variable) is ,NA,NA
"[open(case),closed(top),inside(batteries),defective(batteries)",NA,NA
",",NA,NA
" ok(light),unbroken(case)]",NA,NA
"6. Now we recurse (to the third level) to find how, from this new state, we can satisfy the ",NA,NA
second-level partial goal description ,NA,NA
"[open(case),outside(batteries),unbroken(case)].",NA,NA
The difference is ,NA,NA
[outside(batteries)].,NA,NA
"so now only one fact is now different. For this difference, two operators are recommended: ",NA,NA
"turn_over_case and smash_case, in that order. We try the first one first. ",NA,NA
7. Turn_over_case has precondition ,NA,NA
[open(case)].,NA,NA
which is already true. So the precondition recursion for turn_over_case succeeds trivially. ,NA,NA
"Using the deletepostconditions and addpostconditions, the new state after turn_over_case is ",NA,NA
"[outside(batteries),open(case),closed(top),",NA,NA
" defective(batteries),ok(light),unbroken(case)] ",NA,NA
We now compare this to the second-level goal of ,NA,NA
"[open(case),outside(batteries),unbroken(case)].",NA,NA
and the second-level goal is satisfied. So a postcondition recursion for turn_over_case ,NA,NA
succeeds trivially. The third level of ,NA,NA
means_ends,NA,NA
 recursion binds its third argument ,NA,NA
(answer operator list) to ,NA,NA
[turn_over_case],NA,NA
", and its fourth argument (final state) to the just-",NA,NA
mentioned state. ,NA,NA
"8. We return to the second level, and can complete its job with third argument (answer ",NA,NA
operator list) ,NA,NA
"[disassemble_case,turn_over_case].",NA,NA
so we can bind the fourth argument (final state) to the same state list as previously. ,NA,NA
"9. We finally return to the first level, where were have satisfied the preconditions of ",NA,NA
replace_batteries. We now figure out the result of replace_batteries. The ,NA,NA
deletepostcondition is ,NA,NA
"[outside(batteries),defective(batteries)].",NA,NA
and the addpostcondition is ,NA,NA
"[inside(batteries),ok(batteries)]",NA,NA
.,NA,NA
so the new state is ,NA,NA
"[inside(batteries),ok(batteries),open(case),",NA,NA
" closed(top),ok(light),unbroken(case)]",NA,NA
10. We now must determine how to go from this new state to the original (first-level) goal ,NA,NA
of ,NA,NA
"[ok(batteries),closed(case),closed(top)].",NA,NA
We recursively call ,NA,NA
means_ends,NA,NA
 to do this. The only difference is ,NA,NA
[closed(case)],NA,NA
", for ",NA,NA
which the recommended operator is assemble_case. The preconditions of assemble_case ,NA,NA
"are satisfied by the last-mentioned state, so we just work out the postconditions of the ",NA,NA
operator. This gives the new state ,NA,NA
"[closed(case),inside(batteries),ok(batteries),",NA,NA
" closed(top),ok(light),unbroken(case)]",NA,NA
"This state matches the goal, so no postcondition recursion is necessary at the second level. ",NA,NA
So the postcondition recursion for replace_batteries (the top level) finishes with third ,NA,NA
argument (operator list) being ,NA,NA
[assemble_case],NA,NA
 and fourth argument (new state) the ,NA,NA
preceding state. ,NA,NA
"11. To summarize, we have for the replace_batteries operator a precondition-satisfying ",NA,NA
operator list ,NA,NA
"[disassemble_case,turn_over_case]",NA,NA
 and a postcondition-handling operator ,NA,NA
list of ,NA,NA
[assemble_case],NA,NA
. So the complete operator list for this problem is ,NA,NA
"[disassemble_case,turn_over_case,replace_batteries,assemble_case]",NA,NA
.,NA,NA
"and the final state is what we just found, ",NA,NA
"[closed(case),inside(batteries),ok(batteries),",NA,NA
" closed(top),ok(light),unbroken(case)]",NA,NA
"You can see that means-ends analysis is a little tricky, but it all makes sense when you follow through the ",NA,NA
"steps carefully. Curiously, the operator sequence found seems ""obvious"" to people. This is another one of ",NA,NA
"those situations mentioned at the beginning of Chapter 2: things that seem obvious at first, but aren't so ",NA,NA
obvious when you study them. Getting computers to understand language and interpret pictures are also ,NA,NA
surprisingly difficult problems. ,NA,NA
It's interesting to see what happens if for step 3 we try smash_case instead of disassemble_case to get the ,NA,NA
"case open. The smash_case operator doesn't have any prerequisites, but it has the serious postcondition ",NA,NA
"(actually, addpostcondition) that the case is broken. None of the operators can replace a ",NA,NA
broken(case) ,NA,NA
fact by the ,NA,NA
unbroken(case),NA,NA
" we need for the goal state, so further progress is impossible. So if we ever ",NA,NA
"selected smash_case, we would fail and need to backtrack. ",NA,NA
Means-ends versus other search methods ,NA,NA
The flashlight example illustrates the advantages of means-ends analysis over the classical search ,NA,NA
methods of Chapters 9 and 10. Consider what those earlier methods would do on the same problem. They ,NA,NA
"would have considered every action possible in the starting state, then every next action, and so on until ",NA,NA
"they reached the goal. Such a search is basically ""local"" in not having an overall plan of attack, just ",NA,NA
"moving like an ant one step at a time. Heuristics, evaluation functions, and cost functions are just tools to ",NA,NA
make better local decisions about which operators are most likely to lead to the goal. ,NA,NA
"Means-ends analysis, on the other hand, reasons top-down from abstractions, gradually filling in details ",NA,NA
"of a solution. It's ""global"" since it always has an overall idea of what it's trying to do. It uses recursion to ",NA,NA
"decompose a problem in an intelligent way, a way more like how people solve problems. It does require ",NA,NA
that you identify explicit and complete preconditions and postconditions for each operator; when this is ,NA,NA
"impossible, means-ends won't work. ",NA,NA
Another advantage of means-ends analysis is its explainability. Search results in a list of operators to ,NA,NA
"apply in the real world. When this list is long, it's hard to understand and follow, leading to mistakes. But ",NA,NA
"if you can group (""chunk"") operators as means-ends analysis does, like saying that a sequence of four ",NA,NA
"operators accomplishes some single overall goal, then a long string is more comprehensible. We'll talk ",NA,NA
more about explanations in Chapter l5. ,NA,NA
Modeling real-word uncertainty (*) ,NA,NA
Means-ends analysis plans a solution to (operator sequence for) a search problem; actually using its ,NA,NA
solution in the real world is another thing altogether. Difficulties occur when assumptions on which the ,NA,NA
"plan is based are violated. For instance, you may assume the flashlight batteries are defective, but ",NA,NA
discover when you've replaced them that it really was the light that was defective. Or while you were ,NA,NA
"assembling the case, the batteries may fall out. With cases (pun intended) like this we don't need to start ",NA,NA
"over, but we can replan from the intermediate state; that is, do a new means-ends analysis with this ",NA,NA
"intermediate state as the starting state, and goal the same. Do this anytime you find inconsistency between ",NA,NA
the real-world state and the state anticipated by planning at some point. So even though means-ends ,NA,NA
"analysis is top-down reasoning from abstract goals, you can handle mistakes and imperfections in the ",NA,NA
world. ,NA,NA
Procedural nets (*) ,NA,NA
All the search methods in this and the last two chapters find a sequence of states or operators to solve a ,NA,NA
"problem, on the assumption you can do only one action at a time. But this may be false: you may have a ",NA,NA
"multiarm robot, or you may have several people to help you, or actions not requiring supervision can be ",NA,NA
"started simultaneously. As we discussed in Section 10.12, concurrency can speed up search. ",NA,NA
Concurrency in an operator sequence can be expressed with the ,NA,NA
PERT chart,NA,NA
", a kind of lattice often used in ",NA,NA
"operations research. Figure 11-8 gives an example, one way of replacing both the batteries and light in ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap11.html (15 of 19) [23/04/2002 17:39:13],NA
a flashlight. Each box represents an operator; an operator to the right of another must wait for the first to ,NA,NA
"finish, and vertically parallel operator sequences can be done concurrently. Much work in operations ",NA,NA
research has studied good ways to design and use such PERT charts efficiently. ,NA,NA
PERT charts are often used in artificial intelligence under the name of ,NA,NA
procedural nets,NA,NA
. The algorithms ,NA,NA
"used are similar to means-ends analysis but result in a procedural net, by noting multiple differences ",NA,NA
between a state and the goal that can be eliminated simultaneously by parallel activities. But a major ,NA,NA
headache with concurrency is possible conflict between simultaneous activities. The postconditions of ,NA,NA
"one concurrent operator might undo the preconditions for another, for instance, requiring that the ",NA,NA
operators be done in sequence instead of in parallel. So several different conflict-handling approaches ,NA,NA
"have been proposed for procedural nets. They're too complicated to explain in detail here, but involve ",NA,NA
intersection checks on preconditions and postconditions of operators appearing in parallel; when conflicts ,NA,NA
"are found, the operators are rearranged into a sequence. This may involve removing part or all of the ",NA,NA
"concurrency, or finding a new concurrency. A rule-based system can summarize such fixes. ",NA,NA
.SH Keywords: ,NA,NA
means-ends analysis,NA,NA
difference table,NA,NA
recursive decomposition,NA,NA
double recursion,NA,NA
hierarchical reasoning,NA,NA
abstraction,NA,NA
planning,NA,NA
partial state description,NA,NA
procedural net,NA,NA
Exercises ,NA,NA
11-1. (A) Newspapers often run ,NA,NA
household hints,NA,NA
 like: ,NA,NA
"To remove egg from plastic, use grapefruit juice. ",NA,NA
Wrap sandwiches in lettuce to keep them fresher. ,NA,NA
"To make a cauldron bubble faster, use some eye of newt. ",NA,NA
What part of means-ends analysis do these correspond to? ,NA,NA
"11-2. (E) As described, means-ends analysis decomposes a problem into three parts. Explain why a useful ",NA,NA
"variant might be to decompose a problem into five parts. Generally speaking, how could such a variant be ",NA,NA
implemented in Prolog? ,NA,NA
11-3. You are a character in a British murder mystery. You have endured enough of Sir Reginald Finch-,NA,NA
"Stratton. Not only is he an unbearable egotist, but his bad advice has caused you to lose your life savings ",NA,NA
"on unsound business ventures. Now you hear of his sordid liaison with your daughter, an affair that has ",NA,NA
left her a broken woman. Clearly the man deserves to die. ,NA,NA
(a) Set this up for the means-ends analysis program. Assume his room is next to yours and he keeps the ,NA,NA
"door locked. Assume the operators are to stab him with a knife, to pick up the knife, to hide the knife, to ",NA,NA
"go from a room to the corridor or vice versa, to knock on his door, and to wait until the corridor is empty. ",NA,NA
"Needless to say, you don't want to be caught in this foul deed, so you don't want anyone to see you or to ",NA,NA
"find the murder weapon. Assume in the starting state that you are in your room, there are people in the ",NA,NA
"corridor, you are not holding the murder weapon (knife), Sir Reginald is alive, Sir Reginald is in his ",NA,NA
"room, and the door is locked. ",NA,NA
(b) Trace through informally the operation of means-ends analysis on this problem. What is the final ,NA,NA
operator sequence found? ,NA,NA
"(c) Some of the things assumed in this problem are hard to know in advance, like whether there will be ",NA,NA
people in the corridor or not. How in general can means-ends analysis be modified to handle such ,NA,NA
randomness in facts? ,NA,NA
"11-4. (R,A,P) In many flashlights the top consists of three parts instead of the two assumed in this ",NA,NA
"chapter: a holder, a transparent plate, and a light bulb that screws into the holder underneath the plate. ",NA,NA
"Modify the flashlight repair program to handle flashlights with these three parts, in which only the light is ",NA,NA
ever defective. You'll need to define new operators ,NA,NA
remove_plate,NA,NA
 and ,NA,NA
replace_plate,NA,NA
; the plate must be ,NA,NA
"removed before the light can be removed, and the plate must be replaced before the top can be assembled. ",NA,NA
You'll also need some new predicates to include in states. ,NA,NA
Try it out on the same repair situation given in the chapter. ,NA,NA
11-5. (P) Consider using the flashlight repair program for the situation in which both the light and the ,NA,NA
batteries are defective. ,NA,NA
(a) What does the program in this chapter give as an answer operator list? (Use a computer if you have ,NA,NA
one.) ,NA,NA
(b) The order of the ,NA,NA
recommended,NA,NA
 rules can make a lot of difference. Suppose you move the second ,NA,NA
recommended,NA,NA
 rule (the one about replacing the light) to the end of the others. What answer do you get ,NA,NA
now? Why? ,NA,NA
(c) Suppose you instead move the first ,NA,NA
recommended,NA,NA
 rule (the one about replacing the batteries) to the ,NA,NA
end of the end of the others. What answer do you get now? Why? ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap11.html (17 of 19) [23/04/2002 17:39:13],NA
"11-6. (A,E) Auto repair manuals often suggest laying out the parts removed in order in a line on a flat ",NA,NA
"surface. Assuming that people do auto repair by something close to means-ends analysis, explain in ",NA,NA
artificial-intelligence and computer-science terms why this way of laying out is a good idea. ,NA,NA
"11-7. (A) So far, preconditions and postconditions have been lists of predicate expressions ""and""ed ",NA,NA
"together. This seems limiting. Suppose some operator has two alternative sets of preconditions, either of ",NA,NA
which can be satisfied to make the operator usable. Give an easy way to represent such situations when ,NA,NA
using the mean-ends analysis program in this chapter. ,NA,NA
11-8. (E) The means-ends analysis program of this chapter works in a depth-first way: it figures out how ,NA,NA
"to satisfy the preconditions of a recommended operator, possibly requiring more recursions, and then it ",NA,NA
"figures out how to go from the result of the operator to the goal, possibly requiring more recursions. So ",NA,NA
"it's depth-first in style, with a branching factor of 0, 1, or 2 at each node (each invocation of the ",NA,NA
means_ends,NA,NA
 predicate). But this is not strictly necessary. ,NA,NA
(a) Explain how a breadth-first means-ends analysis might work. ,NA,NA
(b) Why do you think we used the depth-first approach in this chapter? ,NA,NA
11-9. (E) Discuss the application of means-ends analysis to improve the user-friendliness of using ,NA,NA
networks of computers. Give an example. ,NA,NA
11-10. (E) Discuss the similarities and differences between means-ends analysis and the top-down ,NA,NA
parsing of strings of words as discussed at the end of Chapter 6. ,NA,NA
11-11. (H) Machines now exist to synthesize pieces of DNA (deoxyribonucleic acid) under ,NA,NA
microprocessor control. Chemical reactions take place in a single test tube. The following actions are ,NA,NA
possible: ,NA,NA
1. Add plastic beads to the test tube. ,NA,NA
"2. Add one of four similar ""bases"" to the tube (symbolized by A+X, C+X, G+X, and T+X). ",NA,NA
"3. Add a chemical that strips the X off bases (for instance, A+X becomes A) ",NA,NA
4. Add a chemical that binds the left ends of bases to beads. ,NA,NA
5. Neutralize the chemical that binds the left ends of bases to beads. ,NA,NA
6. Add a chemical that detaches the left ends of bases (or strings of bases) from beads. ,NA,NA
The following conditions apply: ,NA,NA
"1. The right end of a base will attach to the left end of another base, but only if there is no ",NA,NA
X on the right end of the first base. ,NA,NA
"2. If an X is removed from a base and the base is not used immediately, it will decompose ",NA,NA
into a different (useless) chemical. ,NA,NA
"For this problem, use means-ends analysis to find a plan to synthesize the chemical A+C+G (and only ",NA,NA
"that chemical, no other combinations). That is, accomplish both the operations ""attach C to right end of ",NA,NA
"A"" and ""attach G to right end of C"". ",NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap11.html (19 of 19) [23/04/2002 17:39:13],NA
Abstraction of facts ,NA,NA
Abstractions of search problems were considered in the last chapter. We'll now look at abstractions on ,NA,NA
groups of facts: ,NA,NA
frames,NA,NA
. Frames are invaluable when you've got lots of facts because they organize them. ,NA,NA
"We'll discuss the different kinds of frames, the components of frames, and new issues in inheritance with ",NA,NA
frames. ,NA,NA
Partitioning facts ,NA,NA
Frames--sometimes called ,NA,NA
classes,NA,NA
", sometimes ",NA,NA
prototypes,NA,NA
", and sometimes ",NA,NA
structured-object descriptions ,NA,NA
"(which doesn't necessarily mean ""objects"" with physical presence)--partition facts in an artificial-",NA,NA
intelligence system. Partitioning of large programs into subroutines and procedures is very familiar in ,NA,NA
computer science; Section 6.6 mentioned partitioning rules into groups related by topic. But we can also ,NA,NA
partition data (facts). The computer language Smalltalk exploits extensive fact partitioning. The usual way ,NA,NA
is to group together facts about the same thing (or ,NA,NA
object,NA,NA
). ,NA,NA
Prolog dialects usually already have built-in fact partitioning in their indexing together of the facts with ,NA,NA
the same predicate name. But frames usually work differently: they group facts with the same argument ,NA,NA
values. So these facts ,NA,NA
"a_kind_of(enterprise,carrier).",NA,NA
"a_kind_of(vinson,carrier).",NA,NA
"location(enterprise,san_diego).",NA,NA
"location(vinson,san_francisco).",NA,NA
"color(enterprise,gray).",NA,NA
"color(vinson,gray).",NA,NA
"east_of(vinson,enterprise)",NA,NA
"might make two frames (partitions): one of facts about the Enterprise (the first, third, fifth, and seventh ",NA,NA
"facts) and one of facts about the Vinson (the second, fourth, sixth, and seventh facts). With the built-in ",NA,NA
"Prolog indexing by predicate name, there would be four implicit partitions: the two ",NA,NA
a_kind_of,NA,NA
" facts, the ",NA,NA
two ,NA,NA
location,NA,NA
" facts, the two ",NA,NA
color,NA,NA
" facts, and the ",NA,NA
east_of,NA,NA
 fact. The first way seems more like how people ,NA,NA
organize facts in their heads. ,NA,NA
"Frames, like semantic networks, are intended for two-argument predicates. This includes the Chapter 2 ",NA,NA
"categories of relationship predicates (in which both arguments are objects), and property predicates (in ",NA,NA
"which the first argument is an object, the second argument a property of that object). (If you have more ",NA,NA
"than two arguments to your facts, you must convert them to relationships and properties somehow.) ",NA,NA
Relationship-predicate facts are generally stored only with the first-argument frame; then for the second-,NA,NA
"argument frame, a different ""reverse"" predicate name is used. For instance, for ",NA,NA
"a_kind_of(X,Y)",NA,NA
", ",NA,NA
"a_generalization_of(Y,X)",NA,NA
 is the reverse; for ,NA,NA
"part_of(X,Y)",NA,NA
", ",NA,NA
"contains(Y,X)",NA,NA
 is the reverse. ,NA,NA
Frames and slots ,NA,NA
A frame is more than a collection of facts; it is an abstraction in its own right. Often we feel that certain ,NA,NA
"facts are the only essential ones about some object, the ones giving descriptive ",NA,NA
completeness,NA,NA
. For ,NA,NA
"instance, for a ship the name, identification number, type of ship, nationality, tonnage, and location might ",NA,NA
be the important features. We should make sure we always put those facts in a frame for a ship. ,NA,NA
"There's a problem, however: we may want to describe sets of objects with a frame, not just a single object. ",NA,NA
"Why? We might want to generalize about certain groups or classes of objects, identifying properties each ",NA,NA
group shares. Then we can't always fill in all the essential facts in the frame since different objects may ,NA,NA
"have different facts true. For instance, a frame for American ships: each ship has a different identification ",NA,NA
"number, so we can't assert a single identification-number fact for the entire frame. ",NA,NA
But identification number is still a ,NA,NA
potential,NA,NA
 fact for the frame. The terminology is that frames have ,NA,NA
slots ,NA,NA
that can be ,NA,NA
unfilled,NA,NA
 or ,NA,NA
filled,NA,NA
"; filled slots represent facts. For instance, ships vary in location, so frames ",NA,NA
"for ""ship"" and ""carrier"" should leave the ""location"" slot unfilled; but the ""transport medium"" slot of ships ",NA,NA
"should always be filled with the word ""water"". Some slots are so important to fill that their frames don't ",NA,NA
make sense otherwise. Such slots are ,NA,NA
definitional,NA,NA
", part of the definition of the frame. For instance, the ",NA,NA
"""nationality"" slot of the frame for ""American ships"" must be filled in with the value ""American"", because ",NA,NA
that's what the frame is all about. Many pairs of frames having ,NA,NA
a_kind_of,NA,NA
" relationships have such slots, ",NA,NA
which came about when the more general frame was restricted in some slot to create the more specific ,NA,NA
frame. ,NA,NA
"Inference rules can fill unfilled slots, especially inheritance rules (Section 4.9). That is, to fill a slot in a ",NA,NA
"frame F, find a related frame F2, take the value for the same-named slot in F2 provided the slot inherits ",NA,NA
"across the relationship between F and F2. For example, if all carriers are gray, that color fact can be stored ",NA,NA
"with the ""carrier"" frame and inherited via ",NA,NA
a_kind_of,NA,NA
" to the frames for the carriers ""Enterprise"" and ",NA,NA
"""Vinson"". Inheritance can be overridden by putting explicit values into normally-unfilled slots, stating the ",NA,NA
"exceptions to general principles. For instance, the few carriers that are not gray can have an explicit color ",NA,NA
"value in their ""color"" slot. ",NA,NA
Slots qualifying other slots ,NA,NA
Slots may have more than a value attached to them: they can have information that explains or qualifies ,NA,NA
that value. Slots with numeric values can have associated information about the units of measurement and ,NA,NA
its accuracy. Slots with nonnumeric values can have a format (a formal description of what the values ,NA,NA
"look like). Slots representing real-world data can have an associated location, time, and observer. Slots ",NA,NA
"can have default or ""usual"" values. Slots may have associated sets of permissible values, given by a list if ",NA,NA
"the number of such values is finite, or by a range if values are numeric. Slots may also have sets of ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (2 of 19) [23/04/2002 17:39:16],NA
"""unusual"" values that should generate a warning if seen. ",NA,NA
"For instance, a slot for the current latitude of a ship can have as explanatory or qualifying information: ",NA,NA
--an indication that the format is a one-digit or two-digit number followed by the letter N or S; ,NA,NA
"--the units ""degrees""; ",NA,NA
--the time a ship was at that position; ,NA,NA
--who reported it; ,NA,NA
--a note that the number must be less than 91; ,NA,NA
--a note that it's unusual for the number to be more than 60; ,NA,NA
"--a default value that is the latitude of Norfolk (a good default for U. S. Navy ships, ",NA,NA
anyway). ,NA,NA
Such ,NA,NA
slot qualification,NA,NA
" information can be considered as slots itself, and we'll call them ",NA,NA
qualifying slots,NA,NA
. ,NA,NA
"They can inherit like regular slots. For instance, the restriction that the latitude be less than 91 holds for ",NA,NA
"anything on the surface of the earth, not just a ship, and so could inherit from the corresponding ",NA,NA
"information in a more general frame like ""vehicle_on_earth"" or ""physical_object_on_earth"". Notice that ",NA,NA
"qualifying slots generally inherit from a higher-generalization frame than do the slots they describe, when ",NA,NA
both inherit. ,NA,NA
Frames with components ,NA,NA
Frames can represent things with components. Often just listing component names is insufficiently ,NA,NA
"descriptive. Instead we should have a separate frame for each component, and ",NA,NA
part_of,NA,NA
 slots pointing ,NA,NA
to them. This has several advantages: ,NA,NA
--We can distinguish properties of components not shared by the whole (inheritance can ,NA,NA
always be used otherwise). ,NA,NA
"--We can describe relationships of the components to one another, like the relative location ",NA,NA
of parts of a physical object or the relative time of subevents of an action. Frames for which ,NA,NA
components can be put in a linear sequence are called ,NA,NA
scripts,NA,NA
. ,NA,NA
--We can indicate more easily how many times component frames occur in relation to the ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (3 of 19) [23/04/2002 17:39:16],NA
main frame (,NA,NA
cardinality,NA,NA
" information, which can be expressed as a qualifying slot). For ",NA,NA
"instance, a wheel is part of a car, and cars have four of them, each with their own ",NA,NA
"properties; and a sunroof is an optional part of a car, occurring either zero or one times in ",NA,NA
every car. ,NA,NA
"--We only need identify the most important, ""top-level"" components in our main frame. The ",NA,NA
"frames for these components can describe their subparts, and so on. ",NA,NA
Frames as forms: memos ,NA,NA
"Frames have many applications to management of paperwork, because frames are a lot like forms. For ",NA,NA
"instance, consider memos used for communication in organizations. Figure 12-1 shows some memo ",NA,NA
frames linked in an ,NA,NA
a_kind_of,NA,NA
" lattice. All memo frames have certain slots: author, intended readers ",NA,NA
"(addressees), date written, subject, type (formal or informal) and text. Often the first four are even written ",NA,NA
"on the paper to look like slots, with the symbols TO, FROM, DATE, and RE followed by colons. ",NA,NA
"The general memo frame has many (not necessarily exclusive) sub-frames, each linked by ",NA,NA
"a_kind_of(X,memo)",NA,NA
" facts. Examples are a frame for all the memos written by Ann, a frame for all the ",NA,NA
"memos received by Ann, and a frame for all memos about the budget. These last two have, among others, ",NA,NA
a sub-frame of their own: all memos received by Ann about the budget. And this might happen to have ,NA,NA
"another sub-frame, for a specific memo Ann got on this subject the other day. Of course, there are many ",NA,NA
"other memo sub-frames. Just considering sub-frames restricting the values in the ""subject"" slot, there are ",NA,NA
"""policy"" memos, ""announcement"" memos, and ""personal"" memos. Considering sub-frames restricting the ",NA,NA
"""date"" slot, there are memos of critical and short-term importance, memos of immediate but long-term ",NA,NA
"importance, and memos of only long-term importance. Finally, note that the ""memo"" frame itself is a sub-",NA,NA
"frame of a ""business form"" frame. ",NA,NA
"Since memo components appear in sequence down a page, their frames are scripts. But organizations do ",NA,NA
"differ in these orders, so the component sequence is inherited from frames specific to each organization. ",NA,NA
"The author, addressee, and text slots shown are special to memos because they must be filled in for every ",NA,NA
specific memo ,NA,NA
instance,NA,NA
" (that is, real-world memo), though not for every memo frame (which can ",NA,NA
"represent classes of memos), with new slots added at various levels in the lattice of memo frames. This is ",NA,NA
"a special type of ""cardinality"" information for those slots, which can be expressed in qualifying slots. ",NA,NA
Slot inheritance ,NA,NA
"All memos have a text slot, but this isn't filled in unless we're talking about a specific real-world memo; ",NA,NA
"every memo's text is different, obviously. But you must agree that since the general ""memo"" frame has a ",NA,NA
"""text"" slot, the ""memos to Ann"" frame must have a ""text"" slot too. This is inheritance, but of a ",NA,NA
fundamentally different sort than any in this book so far: it's inheritance of the mere ,NA,NA
concept,NA,NA
" of a slot, and ",NA,NA
not the value in a slot. We'll call this ,NA,NA
slot inheritance,NA,NA
", and the regular kind ",NA,NA
value inheritance,NA,NA
". In one sense, ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (4 of 19) [23/04/2002 17:39:16],NA
slot inheritance is more limited than value inheritance in that it usually only works with the ,NA,NA
a_kind_of ,NA,NA
"relationship. That is, situations when some frame F has a slot S, then anything that is ""a kind of"" F also ",NA,NA
"has slot S. But in another sense, slot inheritance is more general than value inheritance because it applies ",NA,NA
"higher up in frame hierarchies, to slots that don't yet have values filled in. ",NA,NA
Usually slot inheritance tells us most of the slots that must be in a sub-frame given the slots in a frame. ,NA,NA
"But some slots may be unique to the sub-frame. For instance, carrier ships have airplanes, whereas ships ",NA,NA
"in general don't. So slots referring to airplanes, like those indicating number and types, are unique to the ",NA,NA
"""carrier"" frame. But slots in a frame can't ""disappear"" in a sub-frame. ",NA,NA
Part-kind inheritance ,NA,NA
Besides value and slot inheritance there is a third fundamental kind of inheritance: part-kind inheritance. ,NA,NA
It occurs in the interaction between ,NA,NA
a_kind_of,NA,NA
 and ,NA,NA
part_of,NA,NA
 (see the example in Figure 12-2). A ship has ,NA,NA
"decks, a hull, and a propulsion system. So the ships Enterprise and Vinson have those things. But the ",NA,NA
Enterprise's hull is ,NA,NA
different,NA,NA
 from the Vinson's hull. It may have different properties: it may be damaged ,NA,NA
while the Vinson's hull or the hull of ships in general isn't. Some kind of inheritance is happening from ,NA,NA
"the ""hull"" frame, but it's not inheritance of values or slots because ""hull"" isn't either a value or slot but a ",NA,NA
frame itself. We'll call this ,NA,NA
part-kind inheritance,NA,NA
". Formally, it's the inheritance of a component FC of ",NA,NA
"some frame F of which frame FK is ""a kind of""; the inherited frame becomes a component of FK, ",NA,NA
inheriting slots and values from both FK and FC. Part-kind inheritance means you don't need to define ,NA,NA
every frame in advance for which you want to assert slot values: some frames must exist because others ,NA,NA
"exist. Part-kind inheritance is often signaled in English by possessives, like ""Enterprise's"" in the phrase ",NA,NA
"""the Enterprise's hull"". ",NA,NA
Extensions versus intensions ,NA,NA
Philosophers make an important distinction between abstract concepts (what they call ,NA,NA
intensions,NA,NA
 or ,NA,NA
meanings,NA,NA
 of concepts) and real-world things that frames correspond to (what they call ,NA,NA
extensions,NA,NA
). (Don't ,NA,NA
"confuse this first word with the more common but differently-spelled one ""intention"".) For instance, the ",NA,NA
"intension of ""carrier"" is an abstract specification of what it means for something to be a carrier. One ",NA,NA
"extension of ""carrier"" is the set of all currently existing carriers, another the set of all carriers that existed ",NA,NA
"a year ago, another the set of all carriers ever built, and another the set of all carriers that will exist ten ",NA,NA
"years from now (the ""world"" of the extension may be hypothetical). ",NA,NA
"Extensions and intensions generally require separate frames, linked by ""extension"" and ""intension"" ",NA,NA
"pointers to one another, because the slots can be filled differently. For instance, it's technically incorrect to ",NA,NA
"say that the Enterprise is at 14N42W, only that the extension of the Enterprise for the current instant of ",NA,NA
"time has a location value of 14N42W. So only extensions of things can have a location. In general, ",NA,NA
extensions can have statistics while intensions cannot. So if you want to fill a slot with something that's ,NA,NA
"usually true or true on the average, you need an extension frame. For instance, if you want to say ""most ",NA,NA
"tankers are Liberian"", you're making a statement about the nationality statistics of some extension of the ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (5 of 19) [23/04/2002 17:39:16],NA
"abstract concept of ""tankers"". ",NA,NA
Properties of extensions usually inherit from their intensions: an abstract concept constrains the examples ,NA,NA
"of it. For instance, the fact that ships float on water by definition (i.e., as a property of their intension) ",NA,NA
"means that existing ships (i.e., an extension) float on water. But statistical properties of extensions rarely ",NA,NA
"inherit in any direction. For instance, the average length of a memo in some organization isn't likely to be ",NA,NA
the average length of a policy memo in that organization. Weak inferences are sometimes possible ,NA,NA
"between sets and their subsets, if the condition of statistical independence holds; sampling theory from ",NA,NA
statistics can help us recognize such situations. ,NA,NA
Procedural attachment ,NA,NA
"Inferences rules (or inference procedures) can be values in slots. Usually they appear in qualifying slots, ",NA,NA
and represent a way to fill the value in the main slot from other accessible values. This is ,NA,NA
procedural ,NA,NA
attachment,NA,NA
", and the procedures are sometimes called ",NA,NA
if-needed rules,NA,NA
. Rules can inherit just like other slot ,NA,NA
"values, so we can specify a rule for many frames with a single value entry. ",NA,NA
Extensive or exclusive use of procedural attachment in an artificial-intelligence system leads to a whole ,NA,NA
"new style of programming, ",NA,NA
object-oriented programming,NA,NA
". We mentioned it back in Section 6.9, as one ",NA,NA
interpretation of parallelism in rule-based systems. Object-oriented programming is especially useful for ,NA,NA
writing simulations. The simulation is divided into ,NA,NA
objects,NA,NA
", each with its own frame and rules running ",NA,NA
independently. This is a sort of opposite to the ,NA,NA
procedure-oriented programming,NA,NA
 using Prolog that is ,NA,NA
"emphasized in this book, for which procedures (rules) call on data. With object-oriented programming, ",NA,NA
"data (in frames) calls on procedures. As such, object-oriented programming requires a whole different ",NA,NA
"mindset or programming philosophy than procedure-oriented programming, and it's hard to intermingle it ",NA,NA
"with the other things we discuss in this book. If you're interested, take a look at the Smalltalk literature. ",NA,NA
Frames in Prolog ,NA,NA
"Frames are best implemented in Prolog with software modules where each module has its own local facts, ",NA,NA
"rules, and indexing scheme. Unfortunately, only some of the currently available Prolog dialects provide ",NA,NA
"true modules. But some of the meaning of frames can be captured by identifying them with files, making ",NA,NA
each frame a separate file. ,NA,NA
Filled slots in a frame can just be facts in the file with the usual predicate names. Unfilled slots can be ,NA,NA
represented by facts of the form ,NA,NA
"slot(<object>,<slot-name>).",NA,NA
assuming ,NA,NA
slot,NA,NA
 is not a slot name itself. This special predicate can inherit by slot inheritance from that ,NA,NA
object is a kind of. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (6 of 19) [23/04/2002 17:39:16],NA
"Qualifying information (like units, bounds, and measurement accuracy) can be specified as special ",NA,NA
"property facts where the predicate name is the name of the qualifying slot, the first argument is name of ",NA,NA
"the slot qualified, and the second argument is the value in the qualifying slot. For instance: ",NA,NA
"units(length,meters).",NA,NA
Ordering between parts can be modeled by additional relationship facts besides those designating the parts ,NA,NA
themselves. For instance: ,NA,NA
"beneath(engine_room,flight_deck,carrier).",NA,NA
which says that the engine room part of a carrier is beneath the flight deck part. ,NA,NA
Example of a frame lattice ,NA,NA
Here are some interrelated frames about cars; Figure 12-3 shows their relationships. To make inference ,NA,NA
"rules simpler, we use triples to represent slot values instead of the usual two-argument predicates. The ",NA,NA
syntax is ,NA,NA
"value(<object>,<slot>,<value>)",NA,NA
 which means that the ,NA,NA
<slot>,NA,NA
 of the ,NA,NA
<object>,NA,NA
 has the ,NA,NA
<value>,NA,NA
. ,NA,NA
Physical-object frame,NA,NA
: ,NA,NA
"slot(physical_object,weight). ",NA,NA
"slot(physical_object,name). ",NA,NA
"slot(physical_object,use).",NA,NA
"units(physical_object,weight,kilograms).",NA,NA
Vehicle frame,NA,NA
: ,NA,NA
"value(vehicle,a_kind_of,physical_object). ",NA,NA
"value(vehicle,use,transportation).",NA,NA
"value(vehicle,has_a_part,propulsion_system).",NA,NA
"slot(vehicle,owner).",NA,NA
"slot(vehicle,dealers).",NA,NA
"slot(vehicle,year).",NA,NA
"slot(vehicle,age).",NA,NA
"slot(vehicle,propulsion_method).",NA,NA
"units(vehicle,age,years). ",NA,NA
"units(vehicle,year,years).",NA,NA
Car frame,NA,NA
: ,NA,NA
"value(car,a_kind_of,vehicle).",NA,NA
"value(car,propulsion_method,internal_combustion_engine). ",NA,NA
"value(car,has_a_part,electrical_system).",NA,NA
"value(car,extension,cars_on_road).",NA,NA
"slot(car,make). ",NA,NA
"slot(car,model)",NA,NA
.,NA,NA
"possible_values(car,make,",NA,NA
 ,NA,NA
"[gm,ford,chrysler,amc,vw,toyota,nissan,bmw]).",NA,NA
Electrical-system frame,NA,NA
: ,NA,NA
"value(electrical_system,part_of,car).",NA,NA
"value(electrical_system,has_a_part,battery). ",NA,NA
"value(electrical_system,has_a_part,starter).",NA,NA
VW-Rabbit frame,NA,NA
: ,NA,NA
"value(vw_rabbit,a_kind_of,car). ",NA,NA
"value(vw_rabbit,make,vw).",NA,NA
"value(vw_rabbit,model,rabbit).",NA,NA
Cars-on-the-road-now frame,NA,NA
: ,NA,NA
"value(cars_on_road,intension,car).",NA,NA
"statistic(cars_on_road,mean,age,6.4).",NA,NA
Joe's-VW-Rabbit frame,NA,NA
: ,NA,NA
"value(joes_rabbit,a_kind_of,vw_rabbit).",NA,NA
"value(joes_rabbit,extension,joes_rabbit_now). ",NA,NA
"value(joes_rabbit,owner,joe).",NA,NA
"value(joes_rabbit,year,1976).",NA,NA
Joe's-VW-Rabbit-now frame,NA,NA
: ,NA,NA
"value(joes_rabbit_now,subset,cars_on_road). ",NA,NA
"value(joes_rabbit_now,intension,joes_rabbit).",NA,NA
"statistic(joes_rabbit_now,size,none,1).",NA,NA
Joe's-VW-Rabbit-battery frame,NA,NA
: ,NA,NA
"value(joes_rabbits_battery,extension,joes_rabbits_battery_now). ",NA,NA
"value(joes_rabbits_battery,part_of,joes_rabbit).",NA,NA
Joe's-VW-Rabbit-battery-now frame,NA,NA
: ,NA,NA
"value(joes_rabbits_battery_now,intension,joes_rabbits_battery). ",NA,NA
"value(joes_rabbits_battery_now,contained_in,joes_rabbit_now). ",NA,NA
"value(joes_rabbits_battery_now,status,dead).",NA,NA
Now for some inference rules applying to these frames. We first define a single general-purpose value-,NA,NA
"inheritance rule, that can do inheritance for arbitrary predicate names. This makes inheritance ",NA,NA
implementation a lot simpler since we don't have to write a separate rule for each predicate that inherits. ,NA,NA
"Technically, we've implemented something close to a ",NA,NA
second-order logic,NA,NA
", something that reasons about ",NA,NA
"predicate names as well as arguments, as we'll explain more in Chapter 14. ",NA,NA
"has_value(Object,Slot,V) :- value(Object,Slot,V), !. ",NA,NA
"has_value(Object,Slot,V) :- inherits(Slot,Relation),",NA,NA
" value(Object,Relation,Superconcept),",NA,NA
" has_value(Superconcept,Slot,V).",NA,NA
"inherits(S,a_kind_of) :-",NA,NA
" member(S,[use,",NA,NA
" propulsion_method,dealers,year,age,make,model]).",NA,NA
"inherits(S,part_of) :-",NA,NA
 ,NA,NA
"member(S,[owner,dealers,year,age,make,model]).",NA,NA
Slot inheritance must be defined separately: ,NA,NA
"has_slot(Object,Slot) :- slot(Object,Slot), !.",NA,NA
"has_slot(Object,Slot) :- value(Object,a_kind_of,Superconcept), ",NA,NA
"has_slot(Superconcept,Slot).",NA,NA
"Qualifying slot values also inherit downward. For instance, units of a slot: ",NA,NA
"has_units(Object,Slot,U) :- units(Object,Slot,U), !.",NA,NA
"has_units(Object,Slot,U) :- ",NA,NA
"value(Object,a_kind_of,Superconcept), ",NA,NA
"has_units(Superconcept,Slot,U).",NA,NA
"Here's a rule that says to get a slot value of an extension, get the corresponding slot value (possibly ",NA,NA
inherited) in the intension. ,NA,NA
"has_value(Extension,Slot,V) :- ",NA,NA
"value(Extension,intension,I),",NA,NA
" has_value(I,Slot,V).",NA,NA
"has_slot(Object,Slot) :- value(Object,intension,I), has_slot(I,Slot).",NA,NA
"As we said, statistics can sometimes inherit from one extension to another, if an ""independence"" condition ",NA,NA
holds: ,NA,NA
"statistic(Extension,Statname,Slot,Value) :- ",NA,NA
"has_value(Extension,subset,Bigextension), ",NA,NA
"independent(Extension,Bigextension),",NA,NA
" statistic(Extension,Statname,Slot,Value).",NA,NA
And the subset relationship holds between two extensions whenever their intensions have an ,NA,NA
a_kind_of ,NA,NA
relationship: ,NA,NA
"has_value(Extension,subset,Bigextension) :-",NA,NA
" value(Extension,intension,I), ",NA,NA
"has_value(I,a_kind_of,BigI), ",NA,NA
"value(BigI,extension,Bigextension).",NA,NA
"Also, some redundant slots may have their values defined in terms of other slot values. The ",NA,NA
has_a_part ,NA,NA
relationship is just the opposite of the ,NA,NA
part_of,NA,NA
 relationship: ,NA,NA
"value(X,has_a_part,Y) :- value(Y,part_of,X). ",NA,NA
"value(X,part_of,Y) :- value(Y,has_a_part,X).",NA,NA
And the age slot value can be defined from the year slot value: ,NA,NA
"value(Object,age,A) :- value(Object,year,Y), current_year(Y2),",NA,NA
 A is Y2 - Y.,NA,NA
current_year(1987).,NA,NA
Here are some sample queries run with the preceding facts and rules: ,NA,NA
"?- has_value(joes_rabbit_now,use,U).",NA,NA
U=transportation,NA,NA
"?- has_value(joes_rabbits_battery_now,age,A).",NA,NA
A=11,NA,NA
"?- has_slot(joes_rabbit_now,name).",NA,NA
yes,NA,NA
"?- has_value(joes_rabbit_now,subset,X).",NA,NA
X=cars_on_road,NA,NA
Expectations from slots ,NA,NA
An important applications of frames is to modeling and reconstruction of stereotypical situations in the ,NA,NA
"world from incomplete knowledge. Empty slots in a frame have ""expectations"" about what should fill ",NA,NA
"them: from inheritance, from qualifying-slot information (possible values and permissible values), and ",NA,NA
"from extension statistics. Consider purchasing of equipment for a bureaucratic organization, which ",NA,NA
usually involves many steps and many details; if we know some of the details (slot values) of the ,NA,NA
"purchase, then other details (slot values) are often obvious. For instance, an arriving order was probably ",NA,NA
ordered six to three weeks ago; orders from accounting-supplies companies are for the Accounting ,NA,NA
department; orders that come by express mail are probably for management and should be delivered ,NA,NA
immediately. ,NA,NA
Frames for natural language understanding (*) ,NA,NA
"People must exploit expectations to understand natural languages, because speakers and writers try to ",NA,NA
avoid wordiness. So it's not surprising that frames are very helpful for natural-language understanding by ,NA,NA
"computers, for the ",NA,NA
semantics,NA,NA
 or meaning-assignment subarea (as opposed to the ,NA,NA
syntax,NA,NA
 or parsing subarea ,NA,NA
"we discussed in Section 6.12). That is, with a good frame representation we can efficiently capture the ",NA,NA
"meaning of some natural-language sentences, so as to answer questions about it. ",NA,NA
"Usually the goal in interpretation of a sentence or sentences is to get a set of interrelated frames, in which ",NA,NA
"each frame represents a verb or noun and its associated modifiers. Verbs and nouns are frames, and ",NA,NA
modifiers are slots or have something to do with slots. So for instance the sentence ,NA,NA
"""Yesterday we sent headquarters by express mail the budget memo that Tom drew up for ",NA,NA
"Ann on 6/12"". ",NA,NA
"can be represented by three frames as in Figure 12-4: an instance or sub-frame of a ""sending"" frame, an ",NA,NA
"instance of a ""memo"" frame (like those in Figure 12-1), and an instance of a ""drawing-up"" frame. These ",NA,NA
three are linked by the uses of their names as slot values. Some implications of the sentence are also filled ,NA,NA
"in; for instance, the person a memo is drawn up for is assumed an addressee of the memo. Note that if we ",NA,NA
"know more about the sending, drawing up, or the memo itself from other sentences, we could fill in ",NA,NA
additional slots in the frames without necessarily requiring more frames. ,NA,NA
"Filling in frames the right way to capture the meaning of a sentence can involve search. To be sure, the ",NA,NA
parse of the sentence (see Section 6.12) helps us considerably by identifying the grammatical categories ,NA,NA
"of each word. But there are many ambiguities that can't be resolved by a parse. For instance, compare the ",NA,NA
previous sentence to: ,NA,NA
"""Yesterday we sent several times by 4 P.M. the budget memo that Tom drew up for practice ",NA,NA
"on the plane"". ",NA,NA
"Here we have ""several times"" instead of ""headquarters"", ""by 4 P.M."" instead of ""by express mail"", ""for ",NA,NA
"practice"" instead of ""for Ann"", and ""on the plane"" instead of ""on 6/12"". In all cases we've substituted ",NA,NA
"something similar grammatically. But the functions of the substitutions are different: ""several times"" ",NA,NA
"describes the style of the sending, not the place we sent to; ""by 4 P.M."" is a time limit, not how we sent; ",NA,NA
"""for practice"" is a purpose, not a beneficiary; and ""on the plane"" is a location, not a time. We must figure ",NA,NA
"these things out making guesses about words, drawing from their possible meanings, and checking the ",NA,NA
resulting interpretation of the whole sentence for reasonableness. ,NA,NA
Multiple inheritance (*) ,NA,NA
"We haven't discussed how to handle ""multiple inheritance"" paths for some slot of a frame. For instance, a ",NA,NA
policy memo from your boss is simultaneously a memo from your boss and a policy memo. Things are ,NA,NA
"fine if only one path provides an inheritance for a slot, or if the paths all agree on some value. But if ",NA,NA
"different paths give different values for a slot, we must do something. If we can assign priorities to paths, ",NA,NA
we can take the value from the one with highest priority. Or we can compromise or find a middle ground ,NA,NA
between different values. Or we can decide certain values are wrong. The next section presents an ,NA,NA
example application. ,NA,NA
A multiple inheritance example: custom operating systems (*) ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (12 of 19) [23/04/2002 17:39:16],NA
"Frames are valuable in managing large software systems. As an example, take the operating system of a ",NA,NA
"computer, the top-level program that runs other programs on your orders. Operating systems are ",NA,NA
"standardized for an average computer user, with not too many things you can adjust. Users would prefer ",NA,NA
operating systems more custom-fitted to their needs. ,NA,NA
One way is by a hierarchy of user models. Think of each user model as a frame holding information about ,NA,NA
"defaults peculiar to a user or class of users, defaults about how they need or prefer to use particular ",NA,NA
programs and facilities. Some possible slots are: ,NA,NA
--default terminal setting parameters; ,NA,NA
--storage and time allocations (different programs and facilities have quite different ,NA,NA
requirements); ,NA,NA
--the project for which this computer time should be charged; ,NA,NA
"--default non-file parameters of the program or facility itself (like for a printer, whether ",NA,NA
output is double-spaced); ,NA,NA
--protection information for any input and output files (to prevent reading nonmeaningful ,NA,NA
files or overwriting valuable files); ,NA,NA
--additional character strings (extensions) to be automatically added to the names of input ,NA,NA
"and output files (like ""pro"" for all Prolog programs); ",NA,NA
--interrupt-condition handling (like what to do on arithmetic overflow); ,NA,NA
--common misspellings (so they can be recognized); ,NA,NA
--common bugs (so they can be caught before damage is done); ,NA,NA
--pointers to documentation; ,NA,NA
"--names of default editors, document handlers, and programming languages (so the user can ",NA,NA
"just type short words like ""edit"" and the operating system will know what they mean). ",NA,NA
The interesting thing about this application is the three independent inheritance hierarchies (see Figure ,NA,NA
"12-5). First, there's a hierarchy of user classes: frames for Tom, frames for people in Tom's project group ",NA,NA
"above that, and frames for everybody using the operating system above that. This hierarchy may be a ",NA,NA
"lattice, because Tom may belong to more than one project group, each with different associated projects. ",NA,NA
"Second, there's a hierarchy on programs and facilities of the operating system: a frame for Tom using the ",NA,NA
"Prolog interpreter, and a frame above that for Tom using any programming language, and a frame above ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (13 of 19) [23/04/2002 17:39:16],NA
"that for Tom doing anything under the operating system. This hierarchy could be a lattice too, since for ",NA,NA
"example a Prolog interpreter is both a Prolog-related facility and an interpreter. Third, there's a hierarchy ",NA,NA
on time: Tom's use of the Prolog interpreter today is below a frame for Tom's use of the Prolog interpreter ,NA,NA
anytime. ,NA,NA
So there are at least three independent dimensions of frame generalization for the frame representing Tom ,NA,NA
"using the Prolog interpreter today, the bottom frame in Figure 12-5. We can represent them by a three-",NA,NA
dimensional lattice (which Figure 12-5 tries to suggest) in which the first (user-class) dimension runs ,NA,NA
"northwest, the second (facility-class) dimension runs northeast, and the third (time) dimension runs ",NA,NA
"straight north. Though each of the three hierarchies here is a linear sequence, they form a lattice when put ",NA,NA
"together, since there are many routes between the top frame and the bottom frame. ",NA,NA
The big problem is thus multiple inheritance: there are three different directions to reason. This doesn't ,NA,NA
"affect slot inheritance for which nothing conflicts, but it is a serious problem for value inheritance. One ",NA,NA
approach is to give the ,NA,NA
a_kind_of,NA,NA
" link for each hierarchy a different name, like ",NA,NA
a_kind_of_1,NA,NA
", ",NA,NA
a_kind_of_2,NA,NA
", and ",NA,NA
a_kind_of_3,NA,NA
". Then for every slot, designate one of these as preferred for inheritance, ",NA,NA
and store this in a qualifying slot of the original slot. For instance: ,NA,NA
"--inherit a value for the ""sponsoring projects"" slot via the user-class hierarchy, since ",NA,NA
projects are composed of people; ,NA,NA
--inherit terminal settings from the program and facility class hierarchy; ,NA,NA
"--inherit program storage allocation from the time hierarchy, the typical allocation in the ",NA,NA
past. ,NA,NA
This designated-predicate idea runs into trouble when a user wants to override defaults obtained by ,NA,NA
"inheritance. For instance, suppose user Tom wants to override default terminal settings for the Prolog ",NA,NA
"interpreter, obtained from traveling up the program-class hierarchy to ""Tom on languages today"", and ",NA,NA
"suppose Tom wants this override for all time (that is, Prolog programs might benefit from consistently ",NA,NA
unconventional settings). So he should place the overriding settings in the frame above him in the time ,NA,NA
"dimension (""Tom on Prolog anytime"") representing all his uses of the Prolog interpreter for all time. But ",NA,NA
now we must prevent inheritance along the program dimension. A fix is to store for each slot a sequence ,NA,NA
of inheritance predicates that should be tried to find the value of the slot--for this example perhaps the ,NA,NA
"sequence of the time dimension, the program dimension, and the user-class dimension. Each slot can have ",NA,NA
"an associated sequence, and this can inherit. ",NA,NA
"This approach to inheritance is general, but sometimes unwieldy. For particular slots we may be able to ",NA,NA
"do something simpler. For instance, we may be absolutely certain that values won't conflict because of the ",NA,NA
"way we've built the frames hierarchy. Or for slots with numeric values, we can apply a numeric function ",NA,NA
"to the values inherited along different dimensions to get a ""compromise"" number. For example, for a ",NA,NA
"storage allocation slot, we could take the maximum of the storage allocation values found along the three ",NA,NA
"dimensions, because each dimension represents a different requirement that must be met. For the time ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (14 of 19) [23/04/2002 17:39:16],NA
allocation slot (the amount of time given to a running program before asking the user if they wanted to ,NA,NA
"continue), we could take the average of values, since each number is just a rough guess about an intuitive ",NA,NA
"parameter. This idea of a compromise value applies to nonnumeric slots too. For example, if Tom's ",NA,NA
"project group insists on putting its name at the end of every file created by that group, while a Prolog ",NA,NA
"compiler insists on putting ""procomp"" at the end of the name of every file compiled from Prolog code, ",NA,NA
"you can compromise by putting first the project name, then ""procomp"". Such specialized multiple-",NA,NA
"inheritance strategies (not to be confused with ""conflict-resolution"" strategies for rule-based systems) can ",NA,NA
"be flagged by a special ""multiple-inheritance method"" qualifying slot. And this slot can inherit too. ",NA,NA
.SH Keywords: ,NA,NA
object-based ,NA,NA
representation ,NA,NA
frame ,NA,NA
class ,NA,NA
slot ,NA,NA
filling a slot ,NA,NA
definitional slots ,NA,NA
qualifying slots ,NA,NA
script ,NA,NA
value inheritance ,NA,NA
slot inheritance ,NA,NA
part-kind inheritance ,NA,NA
intension ,NA,NA
extension ,NA,NA
procedural attachment ,NA,NA
semantics ,NA,NA
multiple inheritance ,NA,NA
frame lattice,NA,NA
Exercises ,NA,NA
"12-1. Consider a frame representing any class meeting at any university (that is, a generalized class hour). ",NA,NA
(a) Give four example slots that are always filled with values and what those filled values are. ,NA,NA
(b) Give a superconcept frame (a frame that this frame is a kind of) and a subconcept frame (a frame that ,NA,NA
is a kind of this frame). ,NA,NA
(c) Give a slot that inherits from your superconcept frame and one that does not. ,NA,NA
(d) Describe a script associated with a class meeting frame. ,NA,NA
12-2. (E) People dealing with bureaucracies are constantly filling in the same information on forms over ,NA,NA
"and over again. Discuss the use of inheritance to lighten this burden. In particular, explain how ",NA,NA
inheritance could have a concrete physical meaning. ,NA,NA
"12-3. (R,A) Consider a frame representing any purchase order (a form ordering the buying of something). ",NA,NA
(a) Give an example of value inheritance from a value in this frame to a value in some other frame. ,NA,NA
"(b) Consider the ""units"" slot associated with some slot S in the purchase order frame (so if S is the cost ",NA,NA
"slot, units would be ""dollars""). Suppose S inherits its value from the same slot S of some other frame P2. ",NA,NA
"What does this tell you about from where the ""units"" slot inherits? ",NA,NA
12-4. (A) Different slots in a frame system require different qualifying slots to accompany them. But ,NA,NA
"every time we use a slot with a particular name, we want it to have the same qualifying slots, and the ",NA,NA
same values in those qualifying slots that have values filled in. We can't always just inherit this ,NA,NA
information from a higher (more general ,NA,NA
a_kind_of,NA,NA
") frame because, say, two different uses of a ""length"" ",NA,NA
"slot might be in frames having no common ancestor having a ""length"" slot. (This is especially a problem ",NA,NA
when different people are building different frames for a big system.) Suggest an elegant way to handle ,NA,NA
this sort of problem. ,NA,NA
"12-5. (R,A) Every computer has a manufacturer's name and an ID number. Every computer has a CPU as ",NA,NA
"a component. Consider the frame representing any computer sold by Floodge Manufacturing, Inc. ",NA,NA
(a) Give an example of downward value inheritance from this frame. ,NA,NA
(b) Give an example of downward slot inheritance from this frame. ,NA,NA
(c) Give an example of downward part-kind inheritance involving this frame. ,NA,NA
"12-6. Contrast the intension and extension of the concept ""memo"". ",NA,NA
12-7. Draw a semantic network representing the following facts. Represent property values by nodes ,NA,NA
"too (though this isn't always a good idea). Represent what these mean, not what they literally say. ",NA,NA
Wrenches are tools. ,NA,NA
Hammers are tools. ,NA,NA
Tools have handles. ,NA,NA
The handle of a hammer is hard. ,NA,NA
Wrenches are hard. ,NA,NA
Most hammers have a steel handle. ,NA,NA
Wrenches are 10 inches long on the average. ,NA,NA
"12-8. Names of frames often correspond to nouns. For instance, a ship frame corresponds to the meaning ",NA,NA
"of the English word ""ship"". ",NA,NA
"(a) What, in frame terminology, does an adjective modifying the noun name of a frame often ",NA,NA
"correspond to? For instance, the adjectives ""big"", ""American"", and ""merchant"" in the description ""big ",NA,NA
"American merchant ships"". ",NA,NA
"(b) What, in frame terminology, does a preposition in a prepositional phrase modifying the name of a ",NA,NA
"frame often correspond to? For instance, the prepositions ""in"" and ""at"" in the description ""ships in ",NA,NA
"the Mediterranean at noon yesterday"". ",NA,NA
12-9. (A) Consider the following example of reasoning by modus ponens: ,NA,NA
Given: Military organizations are widely dispersed geographically. ,NA,NA
Given: The Navy is a military organization. ,NA,NA
Hence the Navy is widely dispersed geographically. ,NA,NA
That conclusion makes sense. But consider: ,NA,NA
Given: Navy organizations are widely dispersed geographically. ,NA,NA
Given: The Naval Postgraduate School is a Navy organization. ,NA,NA
Hence The Naval Postgraduate School is widely dispersed geographically. ,NA,NA
"That is an incorrect inference assuming the ""Given""s are true. Discuss why the two situations are ",NA,NA
"different. (To get full credit, you must show depth of understanding, not just cite a superficial difference.) ",NA,NA
12-10. Represent the meaning of the following letter with a group of interlinked frames. ,NA,NA
"Dear Fly-by-Nite Software, ",NA,NA
"I tried your product ""Amazing Artificial Intelligence Software"" and it doesn't work. I tried ",NA,NA
"Example 5 shown in the manual, and it crashed on an attempt to divide by zero. I next tried ",NA,NA
"Example 7, and the lineprinter printed 100,000 line feeds. Then when I exited your ",NA,NA
"program, I found it had destroyed all my files. I want my money back. ",NA,NA
"Sincerely, ",NA,NA
Irate Programmer ,NA,NA
12-11. Some slots are easier to handle with multiple inheritance than others. ,NA,NA
(a) Consider associated with a nonnumeric slot a qualifying slot that lists all the conceivable values that ,NA,NA
first slot could have. Formulate a multiple inheritance policy for this qualifying slot. ,NA,NA
(b) Consider associated with a numeric slot a qualifying slot that lists the maximum and minimum ,NA,NA
conceivable values for that first slot. Formulate a multiple inheritance policy for this qualifying ,NA,NA
slot. ,NA,NA
"12-12. For the user-model hierarchy example, formulate conflict-handling methods for multiple ",NA,NA
inheritance of the following. ,NA,NA
(a) The directory to which output files go. ,NA,NA
(b) A bit indicating whether the user should be warned before the operating system executes a command ,NA,NA
whose side effect is to destroy a file. ,NA,NA
"(c) The ""CPU intensity"" of usage, defined as the expected ratio of CPU time to login-connection time. ",NA,NA
12-13. (A) Suppose that for our user model frames example we have qualifying slots describing how to ,NA,NA
resolve multiple inheritance on other slots. These qualifying slots could have qualifying slots themselves ,NA,NA
"explaining how to resolve their own multiple inheritance problems, and these could have qualifying slots ",NA,NA
"themselves, and so on. Why shouldn't we worry about an infinite loop? ",NA,NA
12-14. (E) Chapter 7 considered the building of an expert system for appliance repair. Suppose instead of ,NA,NA
"one general expert system we would like a set of expert systems, one for each kind of appliance. Many ",NA,NA
"rules are common to different appliances, but some rules must be deleted, some added and some modified ",NA,NA
in going from one appliance to another. Discuss how it might be useful to define an appliance's rules as a ,NA,NA
"frame and do inheritance. What slots would be necessary and useful in the frames, and how would you fill ",NA,NA
in their values? ,NA,NA
12-15. (E) Discuss the use of a frames hierarchy to represent a contract negotiation between management ,NA,NA
and labor. Each frame will represent a particular offer or proposal. Some of these can be grouped together. ,NA,NA
State what slots can be useful for these frames. Provide a good representation of negotiation so that later ,NA,NA
analysis can more easily pick out patterns in the style of negotiation such as flexibility. ,NA,NA
"12-16. (H,E) Reasoning by analogy is a fundamentally different kind of reasoning than any so far ",NA,NA
"considered in this book. It has similarities to inheritance, but it's really something else entirely: it involves ",NA,NA
four things instead of two. It's easiest to understand in terms of frames and slots. Suppose you want to ,NA,NA
"know about the slots or slot values in some frame D. You could find frames A, B, and C such that the ",NA,NA
"relationship of A to B is very similar to the relationship of C to D, the frame of interest. For instance, A ",NA,NA
"might be a frame representing the circulatory system of the human body, and B a frame representing the ",NA,NA
medical emergency of a heart attack; then C might represent the cooling system of a car and D the serious ,NA,NA
"malfunction of complete coolant blockage. Using the analogy, we might be able to infer that the ""number ",NA,NA
"of previous attacks"" in frame B should correspond to a slot ""number of previous blockages"" in frame D. ",NA,NA
"Furthermore, the value in the ""immediate treatment"" slot of frame B of ""inject anticoagulants into the ",NA,NA
"system"" could have an analogy in a slot ""immediate treatment"" of frame D of ""add anti-corrosives"". Give ",NA,NA
a general strategy for finding such analogous slots and analogous slot values in reasoning-by-analogy ,NA,NA
situations. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap12.html (19 of 19) [23/04/2002 17:39:16],NA
Problems with many constraints ,NA,NA
Some problems have lots of conditions or ,NA,NA
constraints,NA,NA
" that must be satisfied. When expressed as Prolog queries, ",NA,NA
"these problems appear as many predicate expressions ""and""ed together. Processing these queries can be awfully ",NA,NA
slow if we don't do it right. ,NA,NA
Special techniques are often used for such many-constraint problems. We'll talk about three such ideas in this ,NA,NA
"chapter: rearranging queries to make them easier to solve, smarter (""dependency-based"") backtracking, and relaxation ",NA,NA
(reasoning about possibility lists). ,NA,NA
Two examples ,NA,NA
Two good examples of many-constraint applications are automatic scheduling and computer vision. ,NA,NA
"Suppose we want to schedule a class to meet five times a week. Assume meeting times must be on the hour, from 9 ",NA,NA
"A.M. to 4 P.M., and on weekdays. Suppose we have ten students, each of which is taking other already-scheduled ",NA,NA
"classes, and we can't have our class meet when any of those meets. Furthermore, suppose we don't want our class to ",NA,NA
"meet two successive hours on any day, and we don't want our class to meet more than two hours total on any day. ",NA,NA
"Figure 13-1 gives an example situation and an example solution; ""occupied"" represents times that aren't available ",NA,NA
"because of the other commitments of the ten students, and ""class"" represents a solution time proposed for our class. ",NA,NA
(Blank spaces are available times we don't need to use.) ,NA,NA
This problem can be stated as a query finding values of five variables ,NA,NA
T1,NA,NA
", ",NA,NA
T2,NA,NA
", ",NA,NA
T3,NA,NA
", ",NA,NA
T4,NA,NA
", and ",NA,NA
T5,NA,NA
", each value of which is a ",NA,NA
two-item list ,NA,NA
"[<day>,<hour>]",NA,NA
", so ",NA,NA
"[tuesday,3]",NA,NA
 means a meeting on Tuesday at 3 P.M. Suppose meeting times of other ,NA,NA
classes are represented as ,NA,NA
"occupied([<day>,<hour>])",NA,NA
 facts. Then the following query would solve our problem: ,NA,NA
"?- classtime(T1), classtime(T2), classtime(T3),",NA,NA
" classtime(T4), classtime(T5),",NA,NA
" not(occupied(T1)), not(occupied(T2)), not(occupied(T3)), ",NA,NA
"not(occupied(T4)), not(occupied(T5)),",NA,NA
" not(two_consecutive_hours([T1,T2,T3,T4,T5]),",NA,NA
" not(three_classes_same_day([T1,T2,T3,T4,T5]).",NA,NA
For this we need the following definitions: ,NA,NA
"classtime([Day,Hour]) :-",NA,NA
" member(Day,[monday,tuesday,wednesday,thursday,friday]), ",NA,NA
"member(Hour,[9,10,11,12,1,2,3,4]).",NA,NA
two_consecutive_hours(TL) :- ,NA,NA
"member([Day,Hour1],TL),",NA,NA
" member([Day,Hour2],TL), H2 ",NA,NA
"is Hour1+1, H2=Hour2.",NA,NA
"three_classes_same_day(TL) :- member([Day,Hour1],TL),",NA,NA
" member([Day,Hour2],TL), member([Day,Hour3],TL),",NA,NA
" not(Hour1=Hour2), not(Hour1=Hour3), not(Hour2=Hour3).",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
Here we use the backtracking version of the ,NA,NA
member,NA,NA
 predicate to both generate class times and to select class times ,NA,NA
from a list. ,NA,NA
Computer vision often involves applying many constraints to interpret some picture. Preliminary visual processing (for ,NA,NA
"example, the techniques of Section 9.16) groups parts of a picture into regions based on similarities of brightness, ",NA,NA
"color, and texture. The remaining problem is to decide what each region of the picture represents. For this, variables ",NA,NA
"correspond to regions, and values of the variables correspond to labels (from a finite label set) for the identity of each ",NA,NA
"region. Additional constraints (conditions) affect which regions can border others, or be above others, or be inside ",NA,NA
others. ,NA,NA
Consider the aerial photograph shown in Figure 13-2. Assume regions can be labeled either ,NA,NA
grass,NA,NA
", ",NA,NA
water,NA,NA
", ",NA,NA
pavement,NA,NA
", ",NA,NA
house,NA,NA
", or ",NA,NA
vehicle,NA,NA
. Let's give some reasonable constraints about relationships of regions in an aerial photo. ,NA,NA
--a region cannot border or be inside a region with the same label (else we couldn't see the boundary ,NA,NA
line); ,NA,NA
--houses and vehicles cannot be next to or surrounded by water regions (we assume no water is deep ,NA,NA
enough for boats in this part of the world); ,NA,NA
"--vehicles must be next to or surrounded by pavement, but pavement cannot be inside them; --",NA,NA
vehicles cannot be inside houses; ,NA,NA
--grass cannot be inside vehicles or houses; ,NA,NA
--pavement cannot be completely inside another region (pavement nearly always connects to other ,NA,NA
pavement); ,NA,NA
"--only houses, vehicles, and pavement are regular (straight-edged) regions; ",NA,NA
--only grass and water are irregular regions; ,NA,NA
"--on a scale of 1 inch = 20 feet, vehicles cannot exceed an area of one quarter of a square inch. ",NA,NA
"These constraints might be violated, but aren't likely to be--remember, artificial intelligence programs don't try to be ",NA,NA
"perfect, just ""intelligent"". We'll often know when they are violated, by being unable to find a solution. Then we can ",NA,NA
"remove the most questionable constraint and try again, and then the second most questionable, and so on until we do ",NA,NA
find a solution. ,NA,NA
"Examining the photo in Figure 13-2, we see five regions; we've written names on them for convenience. R5 is the only ",NA,NA
"region not ""large"" by the definition. Regions R3 and R5 are the only regions that are definitely regular; regions R1 and ",NA,NA
R2 are definitely irregular; but R3 is hard to classify so we won't state that it is either regular or irregular. R1 borders ,NA,NA
"R2, and R2 borders R4; R3 is inside R2, and R5 is inside R4. So the photo interpretation problem can be described in a ",NA,NA
query this way: ,NA,NA
"?- label(R1), label(R2), label(R3), label(R4), label(R5),",NA,NA
" borders(R1,R2), borders(R2,R4), inside(R3,R2), inside(R5,R4),",NA,NA
" large(R1), large(R2), large(R3), large(R4),",NA,NA
" regular(R3), regular(R5), irregular(R2), irregular(R1).",NA,NA
with the following definitions: ,NA,NA
label(grass).,NA,NA
label(water).,NA,NA
label(pavement). ,NA,NA
label(house).,NA,NA
label(vehicle).,NA,NA
"borders(A1,A2) :- not(A1=A2), not(water_constraint(A1,A2)),",NA,NA
" not(vehicle_constraint(A1,A2)).",NA,NA
"inside(A1,A2) :- not(A1=A2), not(water_constraint(A1,A2)), ",NA,NA
"not(vehicle_constraint2(A1,A2)),",NA,NA
" not(grass_constraint(A1,A2)), not(A1=pavement).",NA,NA
"water_constraint(water,house). ",NA,NA
"water_constraint(water,vehicle).",NA,NA
"water_constraint(house,water). ",NA,NA
"water_constraint(vehicle,water).",NA,NA
"vehicle_constraint(A1,vehicle) ",NA,NA
:- ,NA,NA
not(A1=pavement). ,NA,NA
"vehicle_constraint(vehicle,A2) ",NA,NA
:- ,NA,NA
not(A2=pavement). ,NA,NA
"vehicle_constraint2(A1,vehicle).",NA,NA
"vehicle_constraint2(vehicle,A2) :- not(A2=pavement).",NA,NA
"grass_constraint(grass,house). ",NA,NA
"grass_constraint(grass,vehicle).",NA,NA
large(A) :- not(A=vehicle).,NA,NA
regular(house).,NA,NA
regular(vehicle). ,NA,NA
regular(pavement),NA,NA
.,NA,NA
irregular(grass),NA,NA
. ,NA,NA
irregular(water),NA,NA
.,NA,NA
Here ,NA,NA
water_constraint,NA,NA
", ",NA,NA
vehicle_constraint,NA,NA
", and ",NA,NA
grass_constraint,NA,NA
 predicates specify permissible combinations ,NA,NA
of adjacent regions. ,NA,NA
Rearranging long queries without local variables ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (3 of 36) [23/04/2002 17:39:22],NA
"Before processing a long query, we can often rearrange it into a more efficient form. It's usually best in an ""and"" to put ",NA,NA
first the predicate expressions hardest to satisfy. We can use probabilities to explain why. Take the query ,NA,NA
"?- a, b, c.",NA,NA
and suppose ,NA,NA
a,NA,NA
" is true with probability 0.9, ",NA,NA
b,NA,NA
" with probability 0.5, and ",NA,NA
c,NA,NA
" with probability 0.8. First, assume these ",NA,NA
probabilities are independent of each other. Then the preceding query has a probability of success of |0.9 * 0.5 * 0.8 = ,NA,NA
"0.36|, and a probability of failure of |0.64|. So it will more often fail than succeed. When it does fail, we would like to ",NA,NA
"know as soon as possible. With the order as given, 0.1 of the time we will recognize a failure from evaluating just the ",NA,NA
a,NA,NA
", and |0.9 * 0.5 = 0.45| from evaluating both ",NA,NA
a,NA,NA
 and ,NA,NA
b,NA,NA
. That's a total of 0.55. But if we rearrange the query as ,NA,NA
"?- b, c, a.",NA,NA
"then 0.5 of the time we will know a failure from examining the first predicate expression, and |0.5 * 0.2 = 0.1| from ",NA,NA
"examining the first two. That's a total of 0.6. So we're finding the failure earlier, meaning a little less work for us. ",NA,NA
"In general: if we have a bunch of predicate expressions ""and""ed together, we should order them by ",NA,NA
increasing ,NA,NA
"probability of success. That way, if the whole thing is going to fail, we find out as soon as possible. This also applies to ",NA,NA
all rules without local variables. For instance: ,NA,NA
"f(X) :- b(X), c(X), a(X).",NA,NA
If for a random ,NA,NA
X,NA,NA
", ",NA,NA
b,NA,NA
" succeeds with probability 0.5, ",NA,NA
c,NA,NA
" with probability 0.8, and ",NA,NA
a,NA,NA
" with probability 0.5, and these ",NA,NA
"probabilities are all independent of each other, then this is the best arrangement of the right side of the rule for all ",NA,NA
queries of ,NA,NA
f,NA,NA
" with a bound argument, as for example ",NA,NA
?- f(foo).,NA,NA
"There is a corresponding idea for ""or""s (rules ""or""ed together). Consider: ",NA,NA
r :- a.,NA,NA
r :- b.,NA,NA
r :- c.,NA,NA
"Here we should try the rule most likely to succeed first, because if it succeeds then we're done. And we should try ",NA,NA
second the rule second-most-likely to succeed. The same applies to the rules ,NA,NA
r(X) :- a(X).,NA,NA
r(X) :- b(X).,NA,NA
r(X) :- c(X).,NA,NA
provided ,NA,NA
r,NA,NA
 is only queried with ,NA,NA
X,NA,NA
" bound. So we should order ""or""s by ",NA,NA
decreasing,NA,NA
" probability of success, just ",NA,NA
"the opposite of ""and""s. ",NA,NA
Some mathematics ,NA,NA
We can give general mathematical formulas for this rearrangement problem. They apply to any queries or rules without ,NA,NA
"local variables, without ""side effect"" predicates like ",NA,NA
asserta,NA,NA
 and ,NA,NA
consult,NA,NA
", and for which the success probabilities of ",NA,NA
expressions are independent. ,NA,NA
"First, suppose we have some expressions ""and""ed together, where each has a probability of success |p sub i| and an ",NA,NA
"execution cost |c sub i| (measured in arbitrary nonnegative units, perhaps time, perhaps the number of database queries ",NA,NA
made). Number the expressions from left to right. Consider two adjacent ones |i| and |i+1|. Interchanging them will ,NA,NA
improve computation cost if ,NA,NA
c sub i   +   p sub i c sub i+1   >   c sub i+1   +   p sub i+1 c sub i ,NA,NA
Manipulating the inequality we get: ,NA,NA
( 1 - p sub i+1 ) c sub i   >   ( 1 - p sub i ) c sub i+1 ,NA,NA
or: ,NA,NA
( 1 - p sub i ) / c sub i   <   ( 1 - p sub i+1 ) / c sub i+1 ,NA,NA
"In other words, we can use the ratio of probability of failure to the execution cost as a sorting criterion for adjacent ",NA,NA
expressions. Since repeated interchanges of adjacent expresssions are sufficient to sort a list (this is how the famous ,NA,NA
"""bubble sort"" sorting algorithm works), we should sort the expressions by this criterion to get the best order in an ",NA,NA
"""and"". ",NA,NA
"A similar formula applies to ""or""s. We should interchange adjacent expressions |i| and |i+1| in an ""or"" if ",NA,NA
c sub i + ( 1 - p sub i ) c sub i+1   >   c sub i+1,NA,NA
 +   ( 1 - p sub i+1 ) c sub i ,NA,NA
or: ,NA,NA
p sub i / c sub i   <   p sub i+1 / c sub i+1 ,NA,NA
Here's an example. Take the query ,NA,NA
"?- a, b.",NA,NA
where ,NA,NA
a,NA,NA
" has probability 0.6 of success, and ",NA,NA
b,NA,NA
" has probability 0.8. If it costs the same amount of time to query either, ",NA,NA
a ,NA,NA
"should be first. We can see this with the ""and"" formula because ",NA,NA
"( 1 - 0.6 ) / 1   >   ( 1 - 0.8 ) / 1   ,     ""or""     0.4 > 0.2 ",NA,NA
But suppose (without changing its probability) that ,NA,NA
a,NA,NA
 is defined as ,NA,NA
"a :- c, d.",NA,NA
where ,NA,NA
c,NA,NA
 and ,NA,NA
d,NA,NA
 are only expressible as facts. Now it requires more work to find the truth of ,NA,NA
a,NA,NA
: a query of ,NA,NA
a,NA,NA
", followed ",NA,NA
by queries of ,NA,NA
c,NA,NA
 and ,NA,NA
d,NA,NA
". If each query costs about the same, that's three times as much work. So now ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (5 of 36) [23/04/2002 17:39:22],NA
"(1 - 0.6 ) / 3   <   ( 1 - 0.8 ) / 1   ,     ""since""     0.1333   ""<""   ",NA,NA
0.2 ,NA,NA
and ,NA,NA
b,NA,NA
 is better to put first in the original query. ,NA,NA
Rearranging queries with local variables ,NA,NA
Local variables cause problems for the preceding reasoning. Consider: ,NA,NA
"?- a(X), b(X).",NA,NA
Here ,NA,NA
X,NA,NA
" is local to the query, and will be bound in ",NA,NA
a,NA,NA
"; in queries like these, ",NA,NA
a,NA,NA
 isn't expected to fail. But if we try ,NA,NA
to rearrange the query to ,NA,NA
"?- b(X), a(X).",NA,NA
Now ,NA,NA
b,NA,NA
 is the predicate that binds ,NA,NA
X,NA,NA
", and it becomes unlikely to fail. So predicate expressions that bind local variables ",NA,NA
to values must be analyzed specially. ,NA,NA
"For certain expressions we can ignore this problem, those that require bound variable values. Consider: ",NA,NA
"?- a(X), b(Y), X>Y.",NA,NA
"?- a(X), Y is X*X.",NA,NA
"?- a(X), square(X,Y).",NA,NA
where ,NA,NA
square,NA,NA
 in the last query is defined by ,NA,NA
"square(X,Y) :- Y is X*X.",NA,NA
"In each of these queries, putting last predicate expression first will cause an error message about trying to refer to an ",NA,NA
unbound variable. Things are almost as bad with ,NA,NA
"?- a(X), b(Y), not(c(X,Y)).",NA,NA
"which, while not giving an error message, gives completely different answers when the last expression is put first (see ",NA,NA
a similar use in the ,NA,NA
done,NA,NA
 predicate for forward chaining in Chapter 7): ,NA,NA
"?- not(c(X,Y)), a(X), b(Y).",NA,NA
The first predicate expression here asks whether there are any two-argument ,NA,NA
c,NA,NA
" facts, and doesn't connect its ",NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 to ,NA,NA
those in the ,NA,NA
a,NA,NA
 and ,NA,NA
b,NA,NA
 predicates. ,NA,NA
But assuming we ,NA,NA
can,NA,NA
" move expressions to a front binding position, which one should we put there? Consider ",NA,NA
"?- a(X), b(X).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (6 of 36) [23/04/2002 17:39:22],NA
Suppose there are only a finite number of ,NA,NA
X,NA,NA
" values satisfying this query, say 5. Suppose predicate ",NA,NA
a,NA,NA
 is satisfied by 20 ,NA,NA
values of ,NA,NA
X,NA,NA
", and predicate ",NA,NA
b,NA,NA
 by 100 values. If we put first ,NA,NA
a,NA,NA
", then 5 of its 20 solutions will subsequently satisfy ",NA,NA
b,NA,NA
. But ,NA,NA
if we put first ,NA,NA
b,NA,NA
", then 5 of its 100 solutions will subsequently satisfy ",NA,NA
a,NA,NA
. So if ,NA,NA
X,NA,NA
" values occur in a random way, we'll ",NA,NA
need more backtracking to answer the query the second way than the first. The amount of backtracking is the important ,NA,NA
"criterion, because probabilities and costs don't apply here. Probabilities aren't relevant because we don't usually expect ",NA,NA
"a variable-binding predicate to fail, and costs aren't relevant because binding a variable doesn't cost much. ",NA,NA
"To summarize: when you have several predicate expressions in an ""and"" that could bind a variable were they moved to ",NA,NA
"the left in a query, move the one with the fewest possible bindings. Then sort the remaining expressions by increasing ",NA,NA
"probability of success, as before. ",NA,NA
Rearranging queries based on dependencies ,NA,NA
"Besides the preceding criteria, we should also use ",NA,NA
dependencies,NA,NA
 as criteria for rearranging queries. A dependency holds ,NA,NA
"between two predicate expressions if they share a variable. Generally speaking, you should try to maximize the number ",NA,NA
"of dependencies between adjacent expressions in an ""and"", while staying consistent with the previous criteria. This is ",NA,NA
"because when two adjacent expressions don't have variables in common, the variable bindings in the first are irrelevant ",NA,NA
"to the success or failure of the second, and backtracking may be wasting its time going to the second when a failure is ",NA,NA
due to the first. ,NA,NA
"For example, consider ",NA,NA
"?- a(X), b(Y), c(X), e(X,Y), d(X), f(Y), g(Y).",NA,NA
Here the ,NA,NA
b,NA,NA
 expression has no dependency on the ,NA,NA
a,NA,NA
" expression, the ",NA,NA
c,NA,NA
 none on the ,NA,NA
b,NA,NA
", and the ",NA,NA
f,NA,NA
 none on the ,NA,NA
d,NA,NA
", though the ",NA,NA
other adjacent expressions do have dependencies. A better rearrangement would be (assuming that this has about the ,NA,NA
same average overall cost due to expression probabilities and costs) ,NA,NA
"?- a(X), c(X), d(X), b(Y), e(X,Y), f(Y), g(Y).",NA,NA
"where there is only one non-dependency between adjacent expressions, between ",NA,NA
d,NA,NA
 and ,NA,NA
b,NA,NA
. Now when ,NA,NA
g,NA,NA
 ,NA,NA
"fails, backtracking only needs to go back three expressions, whereas before it needed to go back five. ",NA,NA
Summary of guidelines for optimal query arrangements ,NA,NA
We can summarize what we have concluded about query and rule rearrangement by the following guidelines. ,NA,NA
(They're like heuristics because they can be wrong.) ,NA,NA
"1. For an ""and"" that does not bind local variables, sort the predicate expressions by decreasing values of ",NA,NA
the ratio of the failure probability for the expression to its execution cost. ,NA,NA
"2. For an ""or"" or for rules with the same left side (an implicit ""or""), sort them by decreasing values of the ",NA,NA
ratio of the success probability for the rule to its execution cost. ,NA,NA
"3. For an ""and"" that binds local variables, choose to make binding for each variable the predicate ",NA,NA
"expression that mentions it, among those that can bind it, both legally and without changing the ",NA,NA
"predicate meaning, and that has the fewest database matches when queried alone. Then rearrange the rest ",NA,NA
of the ,NA,NA
expressions by guidelines 1 and 3 while freezing the position of these binding expressions. ,NA,NA
"4. Maximize the number of dependencies between adjacent expressions in an ""and"", as long as you ",NA,NA
"don't violate the binding choices made according to guideline 3, or significantly violate the probability-",NA,NA
cost ratio ordering in guideline 1. ,NA,NA
Let's apply these guidelines to the scheduling example of Section 13.1. It originally looked like this: ,NA,NA
"classtime(T1), classtime(T2), classtime(T3),",NA,NA
" classtime(T4), classtime(T5),",NA,NA
" not(occupied(T1)), not(occupied(T2)), ",NA,NA
"not(occupied(T3)), not(occupied(T4)), not(occupied(T5)),",NA,NA
" not(two_consecutive_hours([T1,T2,T3,T4,T5]),",NA,NA
" not(three_classes_same_day([T1,T2,T3,T4,T5]).",NA,NA
For guideline 3 the question is which expressions should bind variables ,NA,NA
T1,NA,NA
", ",NA,NA
T2,NA,NA
", ",NA,NA
T3,NA,NA
", ",NA,NA
T4,NA,NA
", and ",NA,NA
T5,NA,NA
. But every expression ,NA,NA
besides the ,NA,NA
classtime,NA,NA
 ones has a ,NA,NA
not,NA,NA
" in front of it, so this is the only arrangement that will satisfy the conditions of ",NA,NA
guideline 3. ,NA,NA
"To better satisfy guideline 4, we can move the ",NA,NA
not,NA,NA
 expressions to immediately after the expressions binding them. ,NA,NA
"classtime(T1), not(occupied(T1)), ",NA,NA
"classtime(T2), not(occupied(T2)), ",NA,NA
"classtime(T3), not(occupied(T3)), ",NA,NA
"classtime(T4), not(occupied(T4)), ",NA,NA
"classtime(T5), not(occupied(T5)), ",NA,NA
"not(two_consecutive_hours([T1,T2,T3,T4,T5]), ",NA,NA
"not(three_classes_same_day([T1,T2,T3,T4,T5]).",NA,NA
It's hard to guess success probabilities here--this varies enormously with the number of ,NA,NA
occupied,NA,NA
 facts we have--so ,NA,NA
we just use computation cost to order by guideline 1. So we should keep the last two expressions last because they ,NA,NA
"both involve computation (calls to rule definitions), and the other ",NA,NA
not,NA,NA
" expressions don't. Similarly, ",NA,NA
two_consecutive_hours ,NA,NA
should precede ,NA,NA
three_classes_same_day,NA,NA
 because the first has three expressions in its ,NA,NA
"definition, the second six. ",NA,NA
Rearrangement and improvement of the photo interpretation query ,NA,NA
The photo interpretation query of Section 13.1 requires more care to rearrange. Here it is: ,NA,NA
"?- label(R1), label(R2), label(R3), label(R4), label(R5), ",NA,NA
"borders(R1,R2), borders(R2,R4), inside(R3,R2), inside(R5,R4) ",NA,NA
"large(R1), large(R2), large(R3), large(R4),",NA,NA
" regular(R3), regular(R5), irregular(R2), irregular(R1).",NA,NA
All five variables (,NA,NA
R1,NA,NA
", ",NA,NA
R2,NA,NA
", ",NA,NA
R3,NA,NA
", ",NA,NA
R4,NA,NA
", and ",NA,NA
R5,NA,NA
) are bound locally in this query. So apply guideline 3 to decide which ,NA,NA
expressions to put first. The definitions of ,NA,NA
borders,NA,NA
", ",NA,NA
inside,NA,NA
", and ",NA,NA
large,NA,NA
 all have ,NA,NA
not,NA,NA
s containing variables that would ,NA,NA
become unbound if those expressions were put first in the query. So the only expressions that can bind variables ,NA,NA
are those for ,NA,NA
label,NA,NA
", ",NA,NA
regular,NA,NA
", and ",NA,NA
irregular,NA,NA
". Among them, ",NA,NA
irregular,NA,NA
 is best by guideline 3 because it has only two ,NA,NA
"argument possibilities, ",NA,NA
regular,NA,NA
" is second best with three possibilities, and ",NA,NA
label,NA,NA
 is third with five (see Figure 13-,NA,NA
3). That suggests this rearrangement: ,NA,NA
"?- irregular(R2), irregular(R1), regular(R3), regular(R5),",NA,NA
" label(R1), label(R2), label(R3), label(R4), label(R5),",NA,NA
" borders(R1,R2), borders(R2,R4), inside(R3,R2), inside(R5,R4)",NA,NA
" large(R1), large(R2), large(R3), large(R4).",NA,NA
But now ,NA,NA
label,NA,NA
 can never fail for ,NA,NA
R2,NA,NA
", ",NA,NA
R1,NA,NA
", ",NA,NA
R3,NA,NA
", and ",NA,NA
R5,NA,NA
 (see Figure 13-3); any value bound in the first line will satisfy the ,NA,NA
label,NA,NA
 predicate. So we can eliminate four predicate expressions to give the equivalent shorter query: ,NA,NA
"?- irregular(R2), irregular(R1), regular(R3), regular(R5),",NA,NA
" label(R4), borders(R1,R2), borders(R2,R4), inside(R3,R2),",NA,NA
" inside(R5,R4) large(R1), large(R2), large(R3), large(R4).",NA,NA
(We must still keep ,NA,NA
label(R4),NA,NA
 because there's no ,NA,NA
regular,NA,NA
 or ,NA,NA
irregular,NA,NA
 fact to bind ,NA,NA
R4,NA,NA
.) ,NA,NA
So now the first line does all the variable binding. Let's now apply guideline 1 (the probability-to-cost ratio ordering) ,NA,NA
"to the rest of the query, as suggested in the discussion of guideline 3. To simplify analysis, we'll assume all labels are ",NA,NA
"equally likely, and we'll measure processing cost by the number of queries needed. Predicate ",NA,NA
large,NA,NA
 (see Figure 13-3) ,NA,NA
succeeds except if its argument is ,NA,NA
vehicle,NA,NA
", so it then succeeds with probability 0.8; it requires two query lookups. This ",NA,NA
means a guideline-1 ratio of |( 1 - 0.8 ) / 2 = 0.1|. Predicates ,NA,NA
borders,NA,NA
 and ,NA,NA
inside,NA,NA
" require more complicated analysis, ",NA,NA
however. Here again are their definitions: ,NA,NA
"borders(A1,A2) :- not(A1=A2), not(water_constraint(A1,A2)),",NA,NA
" not(vehicle_constraint(A1,A2)).",NA,NA
"inside(A1,A2) :- not(A1=A2), not(water_constraint(A1,A2)),",NA,NA
" not(vehicle_constraint2(A1,A2)), not(grass_constraint(A1,A2)),",NA,NA
 not(A1=pavement).,NA,NA
"Counting both left and right sides of rules, ",NA,NA
borders,NA,NA
" requires four query lookups for its four expressions, and ",NA,NA
inside ,NA,NA
requires six. (We'll ignore the added complication of lowered cost due to incomplete rule processing for some rule ,NA,NA
"failures.) From Figure 13-4, we can estimate the probability of success of ",NA,NA
borders,NA,NA
" as |12 / 25 = 0.48|, and the ",NA,NA
probability of success of ,NA,NA
inside,NA,NA
 as |7 / 25 = 0.28|. Then the ratios needed for guideline 1 are |( 1 - 0.48 ) / 4 = 0.13| for ,NA,NA
borders,NA,NA
 and |( 1 - 0.28 ) / 6 = 0.18| for ,NA,NA
inside,NA,NA
". By these rough numbers, ",NA,NA
inside,NA,NA
" expressions should come first, then ",NA,NA
borders,NA,NA
" expressions, and then ",NA,NA
large,NA,NA
 expressions. So the query should be rearranged to: ,NA,NA
"?- irregular(R2), irregular(R1), regular(R3), regular(R5),",NA,NA
" label(R4), inside(R3,R2), inside(R5,R4), borders(R1,R2),",NA,NA
" borders(R2,R4), large(R1), large(R2), large(R3), large(R4).",NA,NA
"Studying Figure 13-3, we see that ",NA,NA
large,NA,NA
 succeeds whenever ,NA,NA
irregular,NA,NA
 succeeds. So we can eliminate the ,NA,NA
large(R1),NA,NA
 ,NA,NA
and ,NA,NA
large(R2),NA,NA
 to get an equivalent query: ,NA,NA
"?- irregular(R2), irregular(R1), regular(R3), regular(R5),",NA,NA
" label(R4), inside(R3,R2), inside(R5,R4), borders(R1,R2),",NA,NA
" borders(R2,R4), large(R3), large(R4).",NA,NA
"Now we can apply guideline 4, trying to group expressions mentioning the same variable together. One way is to ",NA,NA
move the ,NA,NA
inside,NA,NA
", ",NA,NA
borders,NA,NA
", and ",NA,NA
large,NA,NA
" expressions back into the first line, preserving their order at the expense of the ",NA,NA
order of the first line (since guideline 1 order is more important than guideline 3 order): ,NA,NA
"?- irregular(R2), regular(R3), inside(R3,R2), ",NA,NA
"regular(R5), label(R4), inside(R5,R4),",NA,NA
" irregular(R1), borders(R1,R2), ",NA,NA
"borders(R2,R4), large(R4), large(R3).",NA,NA
Here we've had to move ,NA,NA
irregular(R1),NA,NA
" considerably to the right, but that's the only expression moved significantly ",NA,NA
right. ,NA,NA
"So now we've probably got a much faster query. We emphasize ""probably"", since we had to make a number of ",NA,NA
"simplifying assumptions about probabilities and costs. (If these assumptions seemed too much, we can always do ",NA,NA
a more careful analysis using conditional probabilities and more subcases.) ,NA,NA
Dependency-based backtracking ,NA,NA
Our second technique for handling long queries is ,NA,NA
dependency-based backtracking,NA,NA
. Consider the query: ,NA,NA
"?- a(X), b(X,Y), c(Z), d(X,Z), e(X).",NA,NA
"Suppose the probability of any predicate expression succeeding is 0.1, and that these probabilities are independent of ",NA,NA
the success or failure of other expressions. On the average we'll need to generate 10 ,NA,NA
X,NA,NA
 values before we find one that ,NA,NA
"works, 10 ",NA,NA
Y,NA,NA
" values, and 10 ",NA,NA
Z,NA,NA
 values. But for each ,NA,NA
X,NA,NA
 value we must try about 10 ,NA,NA
Y,NA,NA
" values, for about 100 ",NA,NA
Y,NA,NA
 values in ,NA,NA
all; and for each ,NA,NA
Y,NA,NA
 value we must try about 10 ,NA,NA
Z,NA,NA
" values, for about 1000 about ",NA,NA
Z,NA,NA
 values in all. So there will be a lot ,NA,NA
of backtracking to answer this query with Prolog's standard backward-chaining control structure. ,NA,NA
An alternative is ,NA,NA
nonchronological,NA,NA
 or ,NA,NA
dependency-based,NA,NA
" backtracking. That is, backing up to the expression that did ",NA,NA
"the last variable binding that could have affected the failure, and finding a new binding there. That's not necessarily ",NA,NA
"the previous expression, so dependency-based backtracking is ""smarter"" backtracking, backtracking that notices and ",NA,NA
takes obvious shortcuts. Dependencies (indications of which expressions have common variables) help this ,NA,NA
"considerably, so that's why they're in the name of the technique. ",NA,NA
"Let's apply dependency-based backtracking to the previous query. First, we need to tabulate the predicate expressions ",NA,NA
"in the query that bind, and what expressions have dependencies on what other expressions; see Figure 13-5. Assume ",NA,NA
as a database for this query: ,NA,NA
a(1).,NA,NA
a(2).,NA,NA
a(3).,NA,NA
"b(A,B) :- B is 3*A. ",NA,NA
c(4).,NA,NA
c(1).,NA,NA
"d(A,B) :- A>B.",NA,NA
e(3).,NA,NA
Then what happens in executing the query with dependency-based backtracking is shown in Figure 13-6. Notice ,NA,NA
"that it's identical to regular Prolog backtracking except at three places, after steps 7, 14, and 16: ",NA,NA
"--After step 7, we backtrack from the third predicate expression directly to the first, since variable ",NA,NA
X ,NA,NA
"must be responsible for the earlier failure of the fourth expression, and variable ",NA,NA
Y,NA,NA
 has nothing to do with ,NA,NA
that failure. ,NA,NA
"--After step 14, we backtrack from the last expression directly to the first, since variable ",NA,NA
X,NA,NA
 is the only ,NA,NA
"possible cause of the failure, and the first expression binds it. ",NA,NA
"--After step 16, we skip over the third expression in moving back to the right, since it didn't fail and it ",NA,NA
doesn't include any variables whose values were changed since the last time it was visited. ,NA,NA
So the effect of dependency-based backtracking is to save us 6 actions (right and left movements) out of 24 total. ,NA,NA
"That's not much, but other queries show more dramatic savings. ",NA,NA
Here's an algorithm for dependency-based backtracking: ,NA,NA
"1. Mark every predicate expression in the query as ""active"". Set P to the leftmost predicate in the query. ",NA,NA
"2. Execute repeatedly until you reach the right end of the query, or backtrack off the left end: ",NA,NA
"(a) Execute expression P, and mark it as ""inactive"". ",NA,NA
"(b) If P succeeds and does not bind variables, set P to the next expression to the right that ",NA,NA
"is marked ""active"". ",NA,NA
"(c) If P succeeds and binds variables, mark as ""active"" all other query expressions to the ",NA,NA
right containing those variables if (1) they are not so marked already and (2) the values are ,NA,NA
different from the previous values of those variables. Set P to the next expression to the ,NA,NA
"right that is marked ""active"". ",NA,NA
"(d) If P fails, mark as ""active"" all the expressions to the left of P that bind variables ",NA,NA
"mentioned in P. Set P to the first expression to the left that is currently marked ""active"" ",NA,NA
"(which is not necessarily one just marked, for it may have been marked previously). ",NA,NA
There are further improvements on dependency-based backtracking that we don't have space for here. The theory ,NA,NA
"is quite elegant, and this is an active area of research, also called ",NA,NA
truth maintenance,NA,NA
. ,NA,NA
Reasoning about possibilities ,NA,NA
There's a third way to efficiently handle long queries. The idea is to abandon considering variable bindings one at ,NA,NA
"a time, and to reason about possibilities for each variable. Consider the query of the last section: ",NA,NA
"?- a(X), b(X,Y), c(Z), d(X,Z), e(X).",NA,NA
Suppose there are only a finite number of ways to satisfy each predicate expression. We could figure out all the ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (11 of 36) [23/04/2002 17:39:23],NA
possible values for ,NA,NA
X,NA,NA
 that satisfy ,NA,NA
a(X),NA,NA
", and then check which of them also satisfy e(X). Then for each remaining choice ",NA,NA
we could check which could satisfy ,NA,NA
"b(X,Y)",NA,NA
", crossing out ones that can't. Then we could figure out the possible values ",NA,NA
of ,NA,NA
Z,NA,NA
 that satisfy ,NA,NA
c(Z),NA,NA
", and which of those ",NA,NA
Z,NA,NA
 values for which there is a corresponding ,NA,NA
X,NA,NA
 value remaining that can ,NA,NA
satisfy ,NA,NA
"d(X,Z)",NA,NA
". Sherlock Holmes might put the approach this way: when you have eliminated the impossible, whatever ",NA,NA
"remains, however improbable, must include the truth. ",NA,NA
Why reason about possibilities for variables? So we don't need to work as hard to answer the query. Early elimination ,NA,NA
of impossible values for variables reduces fruitless backtracking. Sometimes we can even reduce possibilities to one ,NA,NA
"for each variable, and we don't need to do any further work. The idea is called ",NA,NA
relaxation,NA,NA
--a technical term that has ,NA,NA
nothing to do with vacations on beaches. Artificial intelligence uses in particular ,NA,NA
discrete relaxation,NA,NA
", relaxation ",NA,NA
involving variables with finitely-long possibility lists. ,NA,NA
Using relaxation for the photo interpretation example ,NA,NA
"We'll present an algorithm for relaxation in the next section. It's a little complicated. To work our way up to it, let's see ",NA,NA
"how we can reason about possibility lists for the photo interpretation problem of Section 13.1, the one with the query: ",NA,NA
"?- label(R1), label(R2), label(R3), label(R4), label(R5),",NA,NA
" borders(R1,R2), borders(R2,R4), inside(R3,R2), inside(R5,R4),",NA,NA
" large(R1), large(R2), large(R3), large(R4), regular(R3),",NA,NA
" regular(R5), irregular(R2), irregular(R1).",NA,NA
"To get possibility lists for each variable, we must extract the single-variable expressions referring to each variable: ",NA,NA
variable ,NA,NA
"R1: label(R1), large(R1), ",NA,NA
irregular(R1). ,NA,NA
variable ,NA,NA
"R2: label(R2), ",NA,NA
"large(R2), irregular(R2).",NA,NA
variable ,NA,NA
"R3: label(R3), large(R3), ",NA,NA
regular(R3). ,NA,NA
variable ,NA,NA
"R4: label(R4), ",NA,NA
large(R4).,NA,NA
variable ,NA,NA
"R5: label(R5), regular(R5).",NA,NA
"Reexamining Figure 13-3, we can see what values (labels) are consistent with the expressions. The possible labels are ",NA,NA
"grass, water, pavement, house, and vehicle. The ",NA,NA
large,NA,NA
 predicate rules out the vehicle label. The ,NA,NA
regular,NA,NA
 predicate ,NA,NA
"specifies house, vehicle, or pavement, and ",NA,NA
irregular,NA,NA
 specifies grass or water. So the initial possibility lists are: ,NA,NA
variable ,NA,NA
R1: grass ,NA,NA
or,NA,NA
 water ,NA,NA
variable ,NA,NA
R2: grass ,NA,NA
or,NA,NA
 water ,NA,NA
variable ,NA,NA
R3: house ,NA,NA
or pavement ,NA,NA
variable ,NA,NA
R4: house ,NA,NA
or,NA,NA
 pavement or grass or ,NA,NA
water ,NA,NA
variable ,NA,NA
R5: house ,NA,NA
or,NA,NA
 vehicle or pavement,NA,NA
"Now let's eliminate or ""cross out"" possibilities using the remaining multivariable predicate expressions (constraints) of ",NA,NA
the original query: ,NA,NA
"borders(R1,R2), borders(R2,R4), inside(R3,R2), inside(R5,R4)",NA,NA
"We can pick a variable and a possibility, and check if the possibility works. Suppose we pick ",NA,NA
R1,NA,NA
 and ,NA,NA
grass,NA,NA
. The ,NA,NA
"borders(R1,R2)",NA,NA
 mentions ,NA,NA
R1,NA,NA
", so we see if some ",NA,NA
R2,NA,NA
 value will work with ,NA,NA
R1=grass,NA,NA
"--that is, whether there's some ",NA,NA
"label that could border grass. Yes, ",NA,NA
R2=water,NA,NA
 works. Check the definition of ,NA,NA
borders,NA,NA
: ,NA,NA
"borders(A1,A2) :- not(A1=A2), not(water_constraint(A1,A2)),",NA,NA
" not(vehicle_constraint(A1,A2)).",NA,NA
For ,NA,NA
A1=grass,NA,NA
 and ,NA,NA
A2=water,NA,NA
", ",NA,NA
A1,NA,NA
 is not equal to ,NA,NA
A2,NA,NA
. The ,NA,NA
water_constraint,NA,NA
 only applies when one label is a house or ,NA,NA
"vehicle, as you can see from its definition: ",NA,NA
"water_constraint(water,house).",NA,NA
"water_constraint(water,vehicle).",NA,NA
"water_constraint(house,water).",NA,NA
"water_constraint(vehicle,water).",NA,NA
And ,NA,NA
vehicle_constraint,NA,NA
 only applies when ,NA,NA
A1,NA,NA
 or ,NA,NA
A2,NA,NA
 is a vehicle: ,NA,NA
"vehicle_constraint(A1,vehicle) :- not(A1=pavement).",NA,NA
"vehicle_constraint(vehicle,A2) :- not(A2=pavement).",NA,NA
So ,NA,NA
R1=grass,NA,NA
 will work for at least one value of ,NA,NA
R2,NA,NA
", which is all we need to keep us from crossing it out. ",NA,NA
"But if we examine a different variable and value, things can be different. Suppose we pick the ",NA,NA
R2,NA,NA
 variable and ,NA,NA
water,NA,NA
. ,NA,NA
The ,NA,NA
"inside(R3,R2)",NA,NA
 constraint mentions ,NA,NA
R2,NA,NA
. But there's no way to label ,NA,NA
R3,NA,NA
 to satisfy the second expression on the ,NA,NA
right side of the ,NA,NA
inside,NA,NA
 definition. Here's that definition: ,NA,NA
"inside(A1,A2) :- not(A1=A2), not(water_constraint(A1,A2)),",NA,NA
" not(vehicle_constraint2(A1,A2)), not(grass_constraint(A1,A2)),",NA,NA
 not(A1=pavement).,NA,NA
The only possibilities for ,NA,NA
R3,NA,NA
" from the single-variable constraints are house and vehicle, and water_constraint succeeds ",NA,NA
for both. Hence the ,NA,NA
not,NA,NA
" fails, and ",NA,NA
inside,NA,NA
 fails too because this is the only rule for ,NA,NA
inside,NA,NA
". In other words, a vehicle or ",NA,NA
"house can't be inside water, a reasonable assumption for most pictures, though you can probably imagine a few ",NA,NA
exceptions. So ,NA,NA
R2,NA,NA
" cannot be water. The only remaining possibility is grass, so ",NA,NA
R2,NA,NA
 must be grass. ,NA,NA
"Once we've eliminated possibilities for a variable, we can often eliminate possibilities for a variable appearing in ",NA,NA
constraints with it. Consider variable ,NA,NA
R1,NA,NA
 which we didn't have any success with originally. Now it's no longer possible ,NA,NA
that ,NA,NA
R1,NA,NA
" is grass, because then ",NA,NA
R1,NA,NA
 would be the same as ,NA,NA
R2,NA,NA
", and the first condition in the ",NA,NA
borders,NA,NA
 definition prohibits ,NA,NA
that. It says two adjacent regions can't have the same label since we couldn't then see the boundary. There's only one ,NA,NA
remaining label for ,NA,NA
R1,NA,NA
", ",NA,NA
water,NA,NA
", so ",NA,NA
R1,NA,NA
 must be that. ,NA,NA
Our possibility lists are now: ,NA,NA
variable ,NA,NA
R1,NA,NA
: ,NA,NA
water ,NA,NA
variable ,NA,NA
R2,NA,NA
: ,NA,NA
grass ,NA,NA
variable ,NA,NA
R3,NA,NA
: ,NA,NA
house,NA,NA
 or ,NA,NA
pavement ,NA,NA
variable ,NA,NA
R4,NA,NA
: ,NA,NA
house,NA,NA
 or ,NA,NA
pavement,NA,NA
 or ,NA,NA
grass,NA,NA
 or ,NA,NA
water ,NA,NA
variable ,NA,NA
R5,NA,NA
: ,NA,NA
house,NA,NA
 or ,NA,NA
vehicle,NA,NA
 or ,NA,NA
pavement,NA,NA
Now consider ,NA,NA
R3,NA,NA
. It can't be pavement because ,NA,NA
R3,NA,NA
 is inside ,NA,NA
R2,NA,NA
", and the last condition in the definition of ",NA,NA
inside,NA,NA
 says ,NA,NA
"that the thing inside can't be pavement. That is, pavement must connect to other pavement--a reasonable, though ",NA,NA
"sometimes false, assumption. So ",NA,NA
R3,NA,NA
 must be a house. ,NA,NA
Consider ,NA,NA
R4,NA,NA
. It can't be grass because it borders ,NA,NA
R2,NA,NA
", and ",NA,NA
R2,NA,NA
 is already grass. It can't be water because water can't ,NA,NA
contain (as ,NA,NA
R5,NA,NA
) a house or a vehicle by ,NA,NA
water_constraint,NA,NA
", and water can't contain pavement by the last condition in ",NA,NA
the ,NA,NA
inside,NA,NA
 definition. That leaves house or pavement for ,NA,NA
R4,NA,NA
. ,NA,NA
Now consider ,NA,NA
R5,NA,NA
. It can't be pavement because pavement can't be contained in anything. So it must be a house ,NA,NA
or vehicle. ,NA,NA
Now consider ,NA,NA
R4,NA,NA
 again. Suppose it's a house. Then ,NA,NA
R5,NA,NA
 can't be a house too because that would make two adjacent ,NA,NA
regions with the same label. But ,NA,NA
R5,NA,NA
" couldn't be a vehicle either, because a vehicle can't be inside a house by the ",NA,NA
vehicle_constraint2,NA,NA
 definition. So ,NA,NA
R4,NA,NA
" can't be a house, and must be pavement. ",NA,NA
"No further eliminations can be done, so the final possibility lists are: ",NA,NA
variable ,NA,NA
R1,NA,NA
: ,NA,NA
water ,NA,NA
variable ,NA,NA
R2,NA,NA
: ,NA,NA
grass ,NA,NA
variable ,NA,NA
R3,NA,NA
: ,NA,NA
house ,NA,NA
variable ,NA,NA
R4,NA,NA
: ,NA,NA
pavement ,NA,NA
variable ,NA,NA
R5,NA,NA
: ,NA,NA
house,NA,NA
 or ,NA,NA
vehicle,NA,NA
Quantifying the effect (*) ,NA,NA
"To show the savings in considering possibility lists instead of individual values, let's use some numbers. Suppose there ",NA,NA
are |n sub Y| possibilities for a variable ,NA,NA
Y,NA,NA
 . Suppose the expression ,NA,NA
"d(X,Y)",NA,NA
 is satisfied by fraction p of all possible ,NA,NA
XY ,NA,NA
pairs. If we can assume satisfaction pairs for d are randomly distributed over all ,NA,NA
XY,NA,NA
" pairs, then the probability that ",NA,NA
some ,NA,NA
X,NA,NA
 value r has at least one corresponding ,NA,NA
Y,NA,NA
 that satisfies d can be approximated by the binomial series: ,NA,NA
1 - ( 1 - p ) sup { n sub Y }  =    { n sub Y } p   - ,NA,NA
{ n sub Y } ( { n sub Y }  - 1 ) p sup 2 / 2   + ,NA,NA
{ n sub Y } ( { n sub Y } - 1 ) ( { n sub Y }  - 2 ) p sup 3 / 6   -   . . .,NA,NA
And the expected number of such matched ,NA,NA
X,NA,NA
 values in the |n sub X| values for ,NA,NA
X,NA,NA
 will be just |n sub X| times this. ,NA,NA
"Figure 13-7 shows the probability computed for sample values of p and n. When p is small (as a rule of thumb, ",NA,NA
"whenever p < 0.2) we can approximate the binomial distribution by the Poisson distribution, and the probability is ",NA,NA
1 - e sup { - n sub Y p },NA,NA
And the expected number of ,NA,NA
X,NA,NA
" values remaining from |n sub X| originally, after examining predicate ",NA,NA
"d(X,Y)",NA,NA
 which has ,NA,NA
probability of success p and |n sub Y| values of ,NA,NA
Y,NA,NA
 that can match it is ,NA,NA
n sub X ( 1 - e sup { - n sub Y p } ),NA,NA
"The smaller this number, the better is reasoning about possibilities first before working Prolog-style. ",NA,NA
"If several constraints mention a variable, each can independently eliminate possibilities, further reducing their number. ",NA,NA
Consider this query: ,NA,NA
"?- a(R), b(S), c(T), d(R,S), e(S,T).",NA,NA
Suppose there are 10 ways to satisfy predicate ,NA,NA
a,NA,NA
", 20 ways to satisfy ",NA,NA
b,NA,NA
", and 50 ways to satisfy ",NA,NA
c,NA,NA
. Suppose further that ,NA,NA
the probability is 0.1 that a random pair of values satisfy ,NA,NA
d,NA,NA
", and 0.01 that a random pair of values will satisfy ",NA,NA
e,NA,NA
", and ",NA,NA
that probabilities are all independent. Then: ,NA,NA
--From Figure 13-7 and our formula we can expect |10 * 0.88 = 8.8| possibilities for ,NA,NA
R,NA,NA
 that satisfy ,NA,NA
d,NA,NA
", on ",NA,NA
the average. ,NA,NA
--And we can expect |50 * 0.39 = 19.5| possibilities for ,NA,NA
T,NA,NA
 that satisfy ,NA,NA
e,NA,NA
", on the average. ",NA,NA
--,NA,NA
S,NA,NA
 occurs in both the two-argument predicates ,NA,NA
d,NA,NA
 and ,NA,NA
e,NA,NA
. For the occurrence in ,NA,NA
d,NA,NA
 we can expect |20 * (1 - e ,NA,NA
sup {-8.8 * 0.1} ) = 11.7| possibilities remaining. ,NA,NA
--The predicate ,NA,NA
e,NA,NA
 can only remove further ,NA,NA
S,NA,NA
 possibilities of these. If satisfaction of ,NA,NA
e,NA,NA
 is probabilistically ,NA,NA
independent of satisfaction of ,NA,NA
d,NA,NA
", for instance, we expect |11.7 * (1 - e sup {-19.5 * 0.01} ) = 2.1| ",NA,NA
possibilities remaining for ,NA,NA
S,NA,NA
. That's a lot better than the initial 20. ,NA,NA
Formalization of pure relaxation ,NA,NA
Here's an algorithm for the simplest kind of relaxation method for answering many-constraint queries: ,NA,NA
pure,NA,NA
 relaxation. ,NA,NA
Note for efficiency in this algorithm that it's important to index all variable names appearing in constraint expressions. ,NA,NA
1. Create possibility lists for each variable using all single-variable query predicate expressions. (Single-,NA,NA
"argument expressions with a variable argument are single-variable, but others like ",NA,NA
"p(X,a,X)",NA,NA
 can be too.) ,NA,NA
"In Prolog, ",NA,NA
bagof,NA,NA
 will help do this. ,NA,NA
"2. Mark each variable in the original query as ""active"". ",NA,NA
"3. Do the following step repeatedly until no more ""active"" variables remain. ",NA,NA
"(a) Choose some ""active"" variable A. (Heuristics may help choose, like ""focus-of-",NA,NA
"attention"" heuristics.) For each current possible value V for A: ",NA,NA
For each constraint C mentioning variable A: ,NA,NA
"Check to see if when variable A has value V, constraint C can ",NA,NA
be satisfied some way (binding other variables of C as ,NA,NA
"necessary). If not, remove V from the possibility list for A; ",NA,NA
otherwise do nothing. Throw away previous bindings for other ,NA,NA
constraints when considering each new constraint (this makes ,NA,NA
"the relaxation ""pure""). ",NA,NA
"(b) Mark variable A as ""inactive"", and mark as ""active"" all variables (i) mentioned in ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (15 of 36) [23/04/2002 17:39:23],NA
"constraints with A, and (ii) marked ""inactive"", and (iii) having more than one possibility ",NA,NA
remaining. Eliminate any constraints for which all the variables have unique values now. ,NA,NA
"4. If there is now a unique possibility for each variable, stop and give those values as the query ",NA,NA
"answer. Otherwise, run the Prolog interpreter on the original query, drawing values from the ",NA,NA
possibility lists. ,NA,NA
"We emphasize that for every constraint we consider, we ignore bindings of its variables made when those variables ",NA,NA
"occurred in other constraints. This ""pure"" relaxation idea may seem wasteful, but if we didn't do it we would just be ",NA,NA
"doing Prolog-style backward chaining in disguise. But compromises between the two approaches are possible, like the ",NA,NA
double relaxation,NA,NA
 we'll show later. ,NA,NA
One nice thing about this relaxation algorithm is its good potential for concurrency. We can work in parallel on ,NA,NA
"different constraints, different values, or even different variables. ",NA,NA
Another relaxation example: cryptarithmetic ,NA,NA
No artificial intelligence book would be complete without an analysis of a good puzzle problem. Analysis of ,NA,NA
"""brain-teaser"" puzzles stimulated much of the early development of the field. ",NA,NA
A classic application of relaxation is to puzzles in which numbers are represented by letters (,NA,NA
cryptarithmetic,NA,NA
). Here ,NA,NA
"the variables are the letters and the possibility lists are numbers those letters can be (often, the possibilities are ",NA,NA
restricted to single digits). Constraints come from arithmetic relationships between the digits. Here's a famous ,NA,NA
"example, where every letter stands for a different digit, and every occurrence of a letter is the same digit. ",NA,NA
 S E N D ,NA,NA
+ M O R E ,NA,NA
______________________ ,NA,NA
M O N E Y,NA,NA
"Note that's the letter ""O"", not the number zero. To make the problem easier, suppose we are told that E=5. ",NA,NA
(Otherwise we can't solve it completely with pure relaxation.) ,NA,NA
"So from the single-variable constraints, initial possibility lists for this problem are: ",NA,NA
"M: [1,2,3,4,5,6,7,8,9] ",NA,NA
"S: [1,2,3,4,5,6,7,8,9] ",NA,NA
"O: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
E: [5] ,NA,NA
"N: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
"R: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
"D: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
"Y: [0,1,2,3,4,5,6,7,8,9]",NA,NA
Each letter represents a variable for this problem. Note M and S cannot be 0 because they are the first digits in ,NA,NA
"numbers, and numbers don't start with 0. On the other hand, we can't cross out the 5's yet because we need to use ",NA,NA
a multi-variable constraint for them. ,NA,NA
But there are also some important additional variables buried in the problem: the carries from each column. We'll label ,NA,NA
"these C1, C10, and C100, representing the carries out of the 1's column, the 10's column, and the 100's column ",NA,NA
respectively. Their possibilities for two-number addition are: ,NA,NA
"C1: [0,1]",NA,NA
"C10: [0,1]",NA,NA
"C100: [0,1]",NA,NA
"Here are the constraints on the variables. The first four come from the rules of column addition, and the last says that ",NA,NA
digit assignments must be unique. While these constraints could also be satisfied for integers greater than 10 or real ,NA,NA
"numbers, the initial possibility lists will prevent such happenings. ",NA,NA
Con1: D + E = Y + (10 * C1) ,NA,NA
Con2: N + R + C1 = E + (10 * C10) ,NA,NA
Con3: E + O + C10 = N + (10 * C100) ,NA,NA
Con4: S + M + C100 = O + (10 * M) ,NA,NA
"Con5: all_different_numbers(S,E,N,D,M,O,R,Y) ",NA,NA
Since E=5 we can substitute that value into the constraints to simplify them: ,NA,NA
Con1: D + 5 = Y + (10 * C1) ,NA,NA
Con2: N + R + C1 = 5 + (10 * C10) ,NA,NA
Con3: 5 + O + C10 = N + (10 * C100) ,NA,NA
Con4: S + M + C100 = O + (10 * M) ,NA,NA
"Con5: all_different_numbers(S,5,N,D,M,O,R,Y) ",NA,NA
"That covers step 1 of the relaxation algorithm, so we proceed to step 2 and mark every letter and carry as ""active"". ",NA,NA
"Now we start step 3, the big step. We will follow a ""leftmost-first"" heuristic that says to choose to work on the active ",NA,NA
variable representing the digit or carry farthest left in the sum display. ,NA,NA
1. We can pick either M or C1000 as the first variable according to our heuristic; suppose we pick M. ,NA,NA
"Only constraints Con4 and Con5 mention M. And the only value of M satisfying Con4 is 1, since 0 is ",NA,NA
"not on M's original possibility list, and a value for M of 2 or greater would make the right side of Con4 ",NA,NA
"at least 20, and there's no combination of S and C100 drawn from their possibility lists whose sum plus 2 ",NA,NA
(for M=2) could equal or surpass 20. We mark M inactive. ,NA,NA
"2. Using our ""leftmost active"" choice heuristic, we pick S next. It's only mentioned in Con4 and ",NA,NA
"Con5. The only way to satisfy Con4 is if S is 8 or 9, because M is 1 and the right side is at least 10. ",NA,NA
Con5 doesn't further eliminate possibilities for S. We mark S inactive. ,NA,NA
"3. We pick O next. It's mentioned in Con3, Con4, and Con5. We can't do anything with Con3, but by ",NA,NA
"Con4 we see O must be 0 or 1 since M=1 and S is either 8 or 9. But turning now to Con5, O cannot be 1 ",NA,NA
(with M already 1). So O=0. We mark S active and O inactive. ,NA,NA
"4. We pick S next. We can't conclude anything about it, so we mark it inactive. (Nothing is marked active ",NA,NA
because we didn't rule out any possibilities.) ,NA,NA
"5. We pick C100 next. It's mentioned in Con3 and Con4. It must be 0, since |5 + 0 + C10 < 7|. We mark S ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (17 of 36) [23/04/2002 17:39:23],NA
"active, and C100 inactive. ",NA,NA
"6. We pick S next. Now by Con4 it must be 9, since |9 + 1 + 0 = 0 + ( 10 * 1 )|. S is marked inactive. ",NA,NA
Current possibility lists and activity markings are: ,NA,NA
M: [1] (inactive) ,NA,NA
S: [9] ,NA,NA
(inactive) ,NA,NA
O: [0] ,NA,NA
(inactive) ,NA,NA
E: [5] ,NA,NA
(inactive) ,NA,NA
"N: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
(active) ,NA,NA
"R: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
(active) ,NA,NA
"D: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
(active) ,NA,NA
"Y: [0,1,2,3,4,5,6,7,8,9] ",NA,NA
(active) ,NA,NA
"C1: [0,1] ",NA,NA
(active) ,NA,NA
"C10: [0,1] ",NA,NA
(active) ,NA,NA
C100: [0] ,NA,NA
(inactive),NA,NA
And the sum looks like: ,NA,NA
 9 5 N D ,NA,NA
+ 1 0 R 5 ,NA,NA
______________ ,NA,NA
1 0 N 5 Y,NA,NA
And the constraints are: ,NA,NA
Con1: D + 5 = Y + (10 * C1) ,NA,NA
Con2: N + R + C1 = 5 + (10 * C10) ,NA,NA
Con3: 5 + C10 = N ,NA,NA
Con4: 10 = 10 ,NA,NA
"Con5: all_different_numbers(9,5,N,D,1,0,R,Y) ",NA,NA
We can just ignore Con4 from now on because it no longer has variables. ,NA,NA
"7. Pick N next. It's mentioned in Con2, Con3, and Con5. Con2 doesn't help, but Con3 says N ",NA,NA
"must be 5 or 6. And then Con5 says N can't be 5 since E is already, so N=6. Mark N inactive. ",NA,NA
8. Pick C10. It's mentioned in Con2 and Con3. But for Con3 it must be 1 since N=6. Mark C10 ,NA,NA
inactive. ,NA,NA
"9. Pick R. It's mentioned in Con2 and Con5. In Con2, |6 + R + C1 = 5 + ( 10 * 1 )|, so R is 8 or 9. ",NA,NA
"But by Con5, R cannot be 9 because S is already 9. So R=8. Mark R inactive. ",NA,NA
"10. Pick C1. It's mentioned in Con1 and Con2. By Con2, it must be 1. Mark C1 inactive. ",NA,NA
"11. Pick D. It's mentioned in Con1 and Con5. By Con1, |D + 5 = Y + ( 10 * 1 )|. This means |D = Y ",NA,NA
+ ,NA,NA
"5|, so D can only be 5, 6, 7, 8, or 9. But by Con5, the values 5, 6, 8, and 9 are ruled out because ",NA,NA
variables already have those values. So D=7. Mark D inactive. ,NA,NA
"12. Pick Y. By Con1, it must be 2. Mark Y inactive. Now every variable is marked inactive, so we ",NA,NA
can stop. ,NA,NA
The final solution is: ,NA,NA
"M=1, S=9, O=0, E=5, N=6, R=8, D=7, Y=2, C1=1, C10=1, C100=0",NA,NA
 9 5 6 7 ,NA,NA
+ 1 0 8 5 ,NA,NA
__________________,NA,NA
 1 0 6 5 2,NA,NA
"Notice relaxation is much like iterative methods for solving mathematical equations: ""convergence"" or progress ",NA,NA
"towards the solution may be slow at times, but things speed up as the solution approaches. ",NA,NA
Implementation of pure relaxation (*) ,NA,NA
We can implement relaxation as we implemented the chaining programs (Chapter 7) and search programs ,NA,NA
(Chapter 10): with a problem-independent file and a problem-dependent file. The last part must specify the ,NA,NA
constraints. In it we'll use the following definitions (as either facts or rules): ,NA,NA
"choices(<variable_name>,<possible_value>)--states initial possibilities for ",NA,NA
"<variable_name>, incorporating all the single-variable constraints ",NA,NA
"constraint(<type>,<argument_list>)--states multivariable constraints, classifying by type and ",NA,NA
arguments ,NA,NA
"satisfiable(<type>,<argument_list>,<bindings_found>)--determines whether a multi-variable ",NA,NA
constraint of a given type is actually satisfiable by some set of variable bindings ,NA,NA
"To circumvent the Prolog interpreter's usual binding of variables, ""variable names"" here must actually be ",NA,NA
"constants (written in lower case). Note that because constraints have a type argument, all constraints of the ",NA,NA
same type can be checked by a single satisfiable predicate definition. Another reason for having both constraint ,NA,NA
and satisfiable is that relaxation can notice common variables between constraints without having to test ,NA,NA
constraints. ,NA,NA
"Here's an example problem-dependent file, the definitions for the photo interpretation problem considered ",NA,NA
earlier. Much of the code remains the same as before. ,NA,NA
"choices(R,CL) :- member(R,[r1,r2,r3,r4,r5]),",NA,NA
" bagof(C,choice(R,C),CL).",NA,NA
"choice(R,grass) :- irregular(R).",NA,NA
"choice(R,water) :- irregular(R).",NA,NA
"choice(R,pavement) :- regular(R).",NA,NA
"choice(R,house) :- regular(R).",NA,NA
"choice(R,vehicle) :- regular(R), not(large(R)).",NA,NA
"choice(R,L) :- not(regular(R)), not(irregular(R)), label(L).",NA,NA
label(grass).,NA,NA
label(water).,NA,NA
label(pavement). ,NA,NA
label(house).,NA,NA
label(vehicle).,NA,NA
large(r1),NA,NA
. ,NA,NA
large(r2),NA,NA
. ,NA,NA
large(r3),NA,NA
. ,NA,NA
large(r4),NA,NA
.,NA,NA
regular(r3). ,NA,NA
regular(r5).,NA,NA
irregular(r2). ,NA,NA
irregular(r1).,NA,NA
"constraint(borders,[r1,r2]). ",NA,NA
"constraint(borders,[r2,r4]). ",NA,NA
"constraint(inside,[r3,r2]). ",NA,NA
"constraint(inside,[r5,r4]).",NA,NA
"satisfiable(borders,Args,[A1,A2]) :- some_bindings(Args,[A1,A2]), ",NA,NA
"not(A1=A2), not(water_constraint(A1,A2)),",NA,NA
" not(vehicle_constraint(A1,A2)).",NA,NA
"satisfiable(inside,Args,[A1,A2]) :- some_bindings(Args,[A1,A2]), ",NA,NA
"not(A1=A2), not(water_constraint(A1,A2)),",NA,NA
" not(vehicle_constraint2(A1,A2)),",NA,NA
" not(grass_constraint(A1,A2)), not(A1=pavement).",NA,NA
"water_constraint(water,house). ",NA,NA
"water_constraint(water,vehicle).",NA,NA
"water_constraint(house,water). ",NA,NA
"water_constraint(vehicle,water).",NA,NA
"vehicle_constraint(A1,vehicle) :- not(A1=pavement).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (20 of 36) [23/04/2002 17:39:23],NA
"vehicle_constraint(vehicle,A2) :- ",NA,NA
"not(A2=pavement). vehicle_constraint2(A1,vehicle).",NA,NA
"vehicle_constraint2(vehicle,A2) :- not(A2=pavement).",NA,NA
"grass_constraint(grass,house). ",NA,NA
"grass_constraint(grass,vehicle)",NA,NA
.,NA,NA
The problem-independent code translates the algorithm given in Section 13.12. Figure 13-8 gives the predicate ,NA,NA
hierarchy. The top-level predicate is relax of no arguments. It firsts converts all choices definitions into ,NA,NA
"possibility lists. It then repeatedly chooses an active variable, until no more such variables exist. For that ",NA,NA
"variable, it retrieves the possibility list and checks each possibility in turn, making a list of those possibilities ",NA,NA
"that are satisfiable, using the bagof predicate defined in Section 10.6. If any previous possibilities are now ",NA,NA
"impossible (meaning that the possibility list is shortened), it marks all variables in constraints with this one as ",NA,NA
"active, and makes this variable inactive. If only one possibility remains for the variable, then (predicate ",NA,NA
"check_unique) that value is substituted into the constraints. Any constraints no longer having variables in them, ",NA,NA
"just constants, are removed. ",NA,NA
"Checking of possibilities is done by possible_value and constraint_violation. The first generates possibilities, and ",NA,NA
the second substitutes them into the constraints and calls satisfiable to check for satisfiability. Only constraints ,NA,NA
containing the variable under study are substituted into. Note it's important we check constraint violation and ,NA,NA
"not constraint satisfaction; as soon as we find a constraint that can't be satisfied, we can stop and cross out a ",NA,NA
possibility. ,NA,NA
Here's the program for pure relaxation: ,NA,NA
/* Top-level routines */ ,NA,NA
"relax :- setup, relax2.",NA,NA
relax :- listing(choice_list).,NA,NA
"relax2 :- repeatactive, choice_list(O,CL), active(O),",NA,NA
" retract(active(O)), not(one_possibility(CL)),",NA,NA
" write('Studying variable '), write(O), nl,",NA,NA
" bagof(V,possible_value(O,CL,V),NCL), not(CL=NCL),",NA,NA
" retract(choice_list(O,CL)), asserta(choice_list(O,NCL)), ",NA,NA
"write('Possibilities for '), write(O), write(' reduced to '), ",NA,NA
"write(NCL), nl, update_activity(O), check_unique(O,NCL), fail.",NA,NA
/* Creation of the initial possibility lists */ ,NA,NA
"setup :- abolish(choice_list,2), fail.",NA,NA
"setup :- choices(O,VL), ",NA,NA
"assertz(choice_list(O,VL)),",NA,NA
" assertz(active(O)), ",NA,NA
fail.,NA,NA
setup.,NA,NA
/* Analysis of a particular variable value */ ,NA,NA
"possible_value(O,CL,V) :- member(V,CL),",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (21 of 36) [23/04/2002 17:39:23],NA
" not(constraint_violation(V,O)).",NA,NA
"constraint_violation(V,O) :- constraint(Type,Args), ",NA,NA
"member(O,Args), substitute(O,V,Args,Args2), ",NA,NA
"not(satisfiable(Type,Args2,Newargs)).",NA,NA
"update_activity(O) :- constraint(T,A), member(O,A),",NA,NA
" member(O2,A), not(O2=O), choice_list(O2,L), not(active(O2)), ",NA,NA
"not(one_possibility(L)), asserta(active(O2)), fail.",NA,NA
update_activity(O).,NA,NA
"check_unique(O,[V]) :- constraint(Type,Args), member(O,Args),",NA,NA
" substitute(O,V,Args,Args2), retract(constraint(Type,Args)),",NA,NA
" some_var(Args2), asserta(constraint(Type,Args2)), fail. ",NA,NA
"check_unique(O,L).",NA,NA
/* Utility routines */ ,NA,NA
"some_var([X|L]) :- choice_list(X,CL), !. ",NA,NA
some_var([X|L]) :- some_var(L).,NA,NA
one_possibility([ZZZ]).,NA,NA
repeatactive.,NA,NA
"repeatactive :- active(X), repeatactive.",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"substitute(X,Y,[],[]).",NA,NA
"substitute(X,Y,[X|L],[Y|L2]) :- substitute(X,Y,L,L2), !.",NA,NA
"substitute(X,Y,[Z|L],[Z|L2]) :- substitute(X,Y,L,L2).",NA,NA
"/* Note--the following is not necessary to run the program, but */ ",NA,NA
"/* is provided as an aid to user definition of ""satisfiable"" */ ",NA,NA
"some_bindings([],[]).",NA,NA
"some_bindings([Arg|Args],[Substarg|Substargs]) ",NA,NA
":- choice_list(Arg,CL), !, member(Substarg,CL), ",NA,NA
"substitute(Arg,Substarg,Args,Args2),",NA,NA
" some_bindings(Args2,Substargs).",NA,NA
"some_bindings([Arg|Args],[Arg|Substargs]) ",NA,NA
:-,NA,NA
" some_bindings(Args,Substargs).",NA,NA
Here's the program working on our photo interpretation problem: ,NA,NA
?- relax.,NA,NA
Studying variable r1 ,NA,NA
Studying variable r2 ,NA,NA
Possibilities for r2 reduced to [grass] ,NA,NA
Studying variable r3 ,NA,NA
Possibilities for r3 reduced to [house] ,NA,NA
Studying variable r4 ,NA,NA
Possibilities for r4 reduced to [pavement] ,NA,NA
Studying variable r5 ,NA,NA
Possibilities for r5 reduced to ,NA,NA
"[house,vehicle] Studying variable r1 ",NA,NA
Possibilities for r1 reduced to [water],NA,NA
"choice_list(r1,[water]).",NA,NA
"choice_list(r5,[house,vehicle]). ",NA,NA
"choice_list(r4,[pavement]).",NA,NA
"choice_list(r3,[house]).",NA,NA
"choice_list(r2,[grass]).",NA,NA
yes,NA,NA
Running a cryptarithmetic relaxation (*) ,NA,NA
"Here's a similar problem-dependent file defining the ""send more money"" cryptarithmetic problem: ",NA,NA
"choices(D,[0,1,2,3,4,5,6,7,8,9]) :- member(D,[n,d,r,o,y]). ",NA,NA
"choices(D,[1,2,3,4,5,6,7,8,9]) :- member(D,[s,m]). ",NA,NA
"choices(e,[5]).",NA,NA
"choices(C,[0,1]) :- member(C,[c1,c10,c100]).",NA,NA
"constraint(sum,[s,m,c100,o,m]).",NA,NA
"constraint(sum,[e,o,c10,n,c100]).",NA,NA
"constraint(sum,[n,r,c1,e,c10]).",NA,NA
"constraint(sum,[d,e,0,y,c1]).",NA,NA
"constraint(unique,[s,e,n,d,m,o,r,y]).",NA,NA
"satisfiable(sum,L,[D1,D2,Carryin,Sum,Carryout]) ",NA,NA
:- ,NA,NA
"some_bindings(L,[D1,D2,Carryin,Sum,Carryout]), S ",NA,NA
"is D1 + D2 + Carryin,",NA,NA
" S2 is Sum + (Carryout * 10), S=S2.",NA,NA
"satisfiable(unique,L,VL) :- ",NA,NA
"not(duplication(L)),",NA,NA
 ,NA,NA
"unique_values(L,VL,[]).",NA,NA
"duplication([X|L]) :-  member(X,L), !.",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (23 of 36) [23/04/2002 17:39:23],NA
duplication([X|L]) :- duplication(L).,NA,NA
"unique_values([],[],KL).",NA,NA
"unique_values([O|L],[V|L2],KL) :- choice_list(O,VL), !, ",NA,NA
"unique_values(L,L2,KL), member(V,VL), not(member(V,L2)), ",NA,NA
"not(member(V,KL)).",NA,NA
"unique_values([K|L],[K|L2],KL) :- ",NA,NA
"unique_values(L,L2,[K|KL]),",NA,NA
" not(member(K,L2)).",NA,NA
"The satisfiable rule with sum as first argument checks column-sum constraints, and the satisfiable rule with ",NA,NA
unique checks unique-assignment constraints. ,NA,NA
Here's a run. We've inserted extra blank lines for readability. Notice that the order of considering variables ,NA,NA
"is different than for the problem analysis of Section 13.13, so possibility eliminations come in a different ",NA,NA
order. ,NA,NA
?- relax.,NA,NA
Studying variable n ,NA,NA
Possibilities for n reduced to ,NA,NA
"[0,1,2,3,4,6,7,8,9] Studying variable d ",NA,NA
Possibilities for d reduced to ,NA,NA
"[0,1,2,3,4,6,7,8,9] Studying variable r ",NA,NA
Possibilities for r reduced to ,NA,NA
"[0,1,2,3,4,6,7,8,9] Studying variable o ",NA,NA
"Possibilities for o reduced to [0,1] ",NA,NA
Studying variable y ,NA,NA
"Possibilities for y reduced to [1,2,3,4,6,7,8,9] ",NA,NA
Studying variable s ,NA,NA
"Possibilities for s reduced to [8,9] ",NA,NA
Studying variable m ,NA,NA
Possibilities for m reduced to [1] ,NA,NA
Studying variable c1 ,NA,NA
Studying variable c10 ,NA,NA
Studying variable c100 ,NA,NA
Possibilities for c100 reduced to [0],NA,NA
Studying variable s ,NA,NA
Possibilities for s reduced to [9] ,NA,NA
Studying variable y ,NA,NA
"Possibilities for y reduced to [2,3,4,6,7,8] ",NA,NA
Studying variable o ,NA,NA
Possibilities for o reduced to [0] ,NA,NA
Studying variable r ,NA,NA
"Possibilities for r reduced to [2,3,4,6,7,8] ",NA,NA
Studying variable d ,NA,NA
"Possibilities for d reduced to [2,3,7,8] ",NA,NA
Studying variable n ,NA,NA
Possibilities for n reduced to [6],NA,NA
Studying variable c1 ,NA,NA
Possibilities for c1 reduced to [1] ,NA,NA
Studying variable c10 ,NA,NA
Possibilities for c10 reduced to [1],NA,NA
Studying variable d ,NA,NA
"Possibilities for d reduced to [7,8] ",NA,NA
Studying variable r ,NA,NA
Possibilities for r reduced to [8] ,NA,NA
Studying variable y ,NA,NA
"Possibilities for y reduced to [2,3] ",NA,NA
Studying variable d ,NA,NA
Possibilities for d reduced to [7] ,NA,NA
Studying variable y ,NA,NA
Possibilities for y reduced to [2],NA,NA
"choice_list(y,[2]).",NA,NA
"choice_list(d,[7]).",NA,NA
"choice_list(r,[8]).",NA,NA
"choice_list(c10,[1]).",NA,NA
"choice_list(c1,[1]). ",NA,NA
"choice_list(n,[6]).",NA,NA
"choice_list(o,[0]).",NA,NA
"choice_list(s,[9]).",NA,NA
"choice_list(c100,[0]). ",NA,NA
"choice_list(m,[1]).",NA,NA
"choice_list(e,[5]).",NA,NA
Implementing double relaxation (*) ,NA,NA
"But pure relaxation can't solve the ""send more money"" problem unless we're told E=5 in advance. A better ",NA,NA
relaxation program could consider pairs of constraints together when it stops making progress analyzing ,NA,NA
"single constraints. That is, a program could use the same bindings for variables common to two constraints. ",NA,NA
"This ""double relaxation"" will be slower than pure relaxation, since there are more pairs than singles and it's ",NA,NA
"doing more work with each pair, so it should only be used as a last resort. Only when both methods fail should ",NA,NA
relaxation stop. ,NA,NA
/* Top-level routines ,NA,NA
*/ ,NA,NA
"relax :- setup, relax2.",NA,NA
relax2 :- single_pred_relax.,NA,NA
relax2 :- done.,NA,NA
relax2 :- double_pred_relax.,NA,NA
"relax2 :- active(X), relax2.",NA,NA
"relax2 :- not(active(X)), listing(choice_list).",NA,NA
"done :- not(possibilities_remain), listing(choice_list).",NA,NA
possibilities_remain :- ,NA,NA
"choice_list(O,CL),",NA,NA
 ,NA,NA
not(one_possibility(CL)).,NA,NA
single_pred_relax :- write('Single predicate relaxation ,NA,NA
"begun.'), nl, repeatactive, choice_list(O,CL), active(O),",NA,NA
" retract(active(O)), not(one_possibility(CL)),",NA,NA
" write('Studying variable '), write(O), nl,",NA,NA
" bagof(V,possible_value(O,CL,V),NCL), not(CL=NCL),",NA,NA
" new_possibilities(O,CL,NCL), fail.",NA,NA
double_pred_relax :- write('Double predicate relaxation ,NA,NA
"begun.'), nl, choice_list(O,CL), not(one_possibility(CL)),",NA,NA
" write('Studying variable '), write(O), nl,",NA,NA
" bagof(V,possible_value2(O,CL,V), NCL),",NA,NA
" not(CL=NCL), new_possibilities(O,CL,NCL), fail.",NA,NA
"new_possibilities(O,CL,NCL) :- retract(choice_list(O,CL)), ",NA,NA
"asserta(choice_list(O,NCL)), write('Possibilities for '), ",NA,NA
"write(O), write(' reduced to '), write(NCL), nl,",NA,NA
" update_activity(O), check_unique(O,NCL).",NA,NA
/* Creation of the initial possibility lists ,NA,NA
"*/ setup :- abolish(choice_list,2), fail.",NA,NA
"setup :- choices(O,VL), ",NA,NA
"assertz(choice_list(O,VL)),",NA,NA
" assertz(active(O)), ",NA,NA
fail.,NA,NA
setup.,NA,NA
/* Single-relaxation analysis of a particular value for a particular variable ,NA,NA
"*/ possible_value(O,CL,V) :- member(V,CL),",NA,NA
" not(constraint_violation(V,O)).",NA,NA
"constraint_violation(V,O) :- ",NA,NA
"constraint(Type,Args), member(O,Args), ",NA,NA
"substitute(O,V,Args,Args2),",NA,NA
" not(satisfiable(Type,Args2,Newargs)).",NA,NA
"update_activity(O) :- constraint(T,A), member(O,A), ",NA,NA
"member(O2,A),",NA,NA
" not(O2=O), choice_list(O2,L), not(active(O2)),",NA,NA
" not(one_possibility(L)), asserta(active(O2)), fail. ",NA,NA
update_activity(O).,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (26 of 36) [23/04/2002 17:39:23],NA
"check_unique(O,[V]) :- constraint(Type,Args), member(O,Args),",NA,NA
" substitute(O,V,Args,Args2), retract(constraint(Type,Args)),",NA,NA
" some_var(Args2), asserta(constraint(Type,Args2)), fail. ",NA,NA
"check_unique(O,L).",NA,NA
"some_var([X|L]) :- choice_list(X,CL), !. ",NA,NA
some_var([X|L]) :- some_var(L).,NA,NA
one_possibility([ZZZ]).,NA,NA
/* Double-relaxation analysis of a particular value ,NA,NA
*/ /* for a particular variable */ ,NA,NA
"possible_value2(O,CL,V) :- member(V,CL),",NA,NA
" bagof([T,A],constraint(T,A),ConL),",NA,NA
" not(constraint_violation2(V,O,ConL)).",NA,NA
"constraint_violation2(V,O,ConL) :-",NA,NA
" twoconstraints(ConL,Type,Args,Type2,Args2),",NA,NA
" member(O,Args), argsoverlap(Args,Args2),",NA,NA
" substitute(O,V,Args,XArgs),",NA,NA
" substitute(O,V,Args2,XArgs2),",NA,NA
 ,NA,NA
"not(double_satisfiable(Type,XArgs,Type2,XArgs2)).",NA,NA
"double_satisfiable(Type,Args,Type2,Args2) :- ",NA,NA
"constraint_preference(Type2,Type),",NA,NA
" !, ",NA,NA
"double_satisfiable(Type2,Args2,Type,Args).",NA,NA
"double_satisfiable(Type,Args,Type2,Args2) ",NA,NA
":- satisfiable(Type,Args,Newargs),",NA,NA
" bind(Args,Newargs,Args2,Result),",NA,NA
" satisfiable(Type2,Result,Newargs2).",NA,NA
"twoconstraints([[T,A]|ConL],T,A,T2,A2) :- member([T2,A2],ConL). ",NA,NA
"twoconstraints([[T,A]|ConL],T1,A1,T2,A2) :-",NA,NA
" twoconstraints(ConL,T1,A1,T2,A2).",NA,NA
"argsoverlap(L1,L2) :- member(X,L1), ",NA,NA
"member(X,L2),",NA,NA
" choice_list(X,CL), !.",NA,NA
"bind([],[],A2,A2).",NA,NA
"bind([V|A],[V|NA],A2,R) :- bind(A,NA,A2,R), !.",NA,NA
"bind([O|A],[V|NA],A2,R) :- ",NA,NA
"substitute(O,V,A2,NA2),",NA,NA
" bind(A,NA,NA2,R), !.",NA,NA
/* Utility functions */ ,NA,NA
repeatactive.,NA,NA
"repeatactive :- active(X), repeatactive.",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"substitute(X,Y,[],[]).",NA,NA
"substitute(X,Y,[X|L],[Y|L2]) :- substitute(X,Y,L,L2), !.",NA,NA
"substitute(X,Y,[Z|L],[Z|L2]) :- substitute(X,Y,L,L2).",NA,NA
"some_bindings([],[]).",NA,NA
"some_bindings([Arg|Args],[Substarg|Substargs]) ",NA,NA
":- choice_list(Arg,CL), !, member(Substarg,CL), ",NA,NA
"substitute(Arg,Substarg,Args,Args2),",NA,NA
" some_bindings(Args2,Substargs).",NA,NA
"some_bindings([Arg|Args],[Arg|Substargs]) ",NA,NA
:-,NA,NA
" some_bindings(Args,Substargs).",NA,NA
"And here's the script of a run on the ""send more money"" problem, using the problem-dependent file of the ",NA,NA
"last section, without E=5, and plus one additional fact which says sum constraints should be used before ",NA,NA
unique constraints (since sum requires less computation to check): ,NA,NA
"constraint_preference(sum,unique).",NA,NA
Extra blank lines were inserted in the following printout to make it easier to read. ,NA,NA
?- relax.,NA,NA
Single predicate relaxation begun.,NA,NA
Studying variable e ,NA,NA
Studying variable n ,NA,NA
Studying variable d ,NA,NA
Studying variable o ,NA,NA
"Possibilities for o reduced to [0,1] ",NA,NA
Studying variable r ,NA,NA
Studying variable y ,NA,NA
Studying variable s ,NA,NA
"Possibilities for s reduced to [8,9] ",NA,NA
Studying variable m ,NA,NA
Possibilities for m reduced to [1] ,NA,NA
Studying variable c1 ,NA,NA
Studying variable c10,NA,NA
Studying variable c100,NA,NA
Studying variable s ,NA,NA
Studying variable o ,NA,NA
Possibilities for o reduced to [0] ,NA,NA
Studying variable e ,NA,NA
Possibilities for e reduced to ,NA,NA
"[2,3,4,5,6,7,8,9] Studying variable n ",NA,NA
Possibilities for n reduced to ,NA,NA
"[2,3,4,5,6,7,8,9] Studying variable d ",NA,NA
Possibilities for d reduced to ,NA,NA
"[2,3,4,5,6,7,8,9] Studying variable r ",NA,NA
Possibilities for r reduced to ,NA,NA
"[2,3,4,5,6,7,8,9] Studying variable y ",NA,NA
Possibilities for y reduced to ,NA,NA
"[2,3,4,5,6,7,8,9] Studying variable c1 ",NA,NA
Studying variable c10 ,NA,NA
Studying variable c100 ,NA,NA
Possibilities for c100 reduced to [0],NA,NA
Studying variable r ,NA,NA
Studying variable d ,NA,NA
Studying variable n ,NA,NA
Studying variable e ,NA,NA
Studying variable s ,NA,NA
Possibilities for s reduced to [9] ,NA,NA
Studying variable c10 ,NA,NA
Studying variable y ,NA,NA
Possibilities for y reduced to ,NA,NA
"[2,3,4,5,6,7,8] Studying variable r ",NA,NA
Possibilities for r reduced to ,NA,NA
"[2,3,4,5,6,7,8] Studying variable d ",NA,NA
Possibilities for d reduced to ,NA,NA
"[2,3,4,5,6,7,8] Studying variable n ",NA,NA
Possibilities for n reduced to ,NA,NA
"[2,3,4,5,6,7,8] Studying variable e ",NA,NA
Possibilities for e reduced to ,NA,NA
"[2,3,4,5,6,7,8] Studying variable c1 ",NA,NA
Studying variable c10,NA,NA
Studying ,NA,NA
variable ,NA,NA
n ,NA,NA
Studying ,NA,NA
variable ,NA,NA
d ,NA,NA
Studying ,NA,NA
variable ,NA,NA
r ,NA,NA
Studying ,NA,NA
variable ,NA,NA
y ,NA,NA
Double ,NA,NA
predicate ,NA,NA
relaxation ,NA,NA
begun.,NA,NA
Studying variable e ,NA,NA
Possibilities for e reduced to ,NA,NA
"[2,3,4,5,6,7] Studying variable n ",NA,NA
Possibilities for n reduced to ,NA,NA
"[3,4,5,6,7,8]",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (29 of 36) [23/04/2002 17:39:23],NA
Studying variable d ,NA,NA
Studying variable r ,NA,NA
Studying variable y ,NA,NA
Studying variable c1 ,NA,NA
Studying variable c10 ,NA,NA
Possibilities for c10 reduced to [1],NA,NA
Single predicate relaxation begun.,NA,NA
Studying variable n ,NA,NA
Studying variable e ,NA,NA
Studying variable d ,NA,NA
Studying variable r ,NA,NA
Possibilities for r reduced to ,NA,NA
"[3,4,5,6,7,8] Studying variable y ",NA,NA
Studying variable c1 ,NA,NA
Studying variable n ,NA,NA
Studying variable e ,NA,NA
Studying variable d,NA,NA
Double predicate relaxation begun.,NA,NA
Studying variable r ,NA,NA
Possibilities for r reduced to [8] ,NA,NA
Studying variable n ,NA,NA
"Possibilities for n reduced to [4,5,6,7] ",NA,NA
Studying variable e ,NA,NA
"Possibilities for e reduced to [3,4,5,6] ",NA,NA
Studying variable d ,NA,NA
"Possibilities for d reduced to [2,3,4,7] ",NA,NA
Studying variable y ,NA,NA
"Possibilities for y reduced to [2,3,5,6,7] ",NA,NA
Studying variable c1 ,NA,NA
Possibilities for c1 reduced to [1],NA,NA
Single predicate relaxation begun.,NA,NA
Studying variable y ,NA,NA
"Possibilities for y reduced to [2,3] ",NA,NA
Studying variable d ,NA,NA
Possibilities for d reduced to [7] ,NA,NA
Studying variable e ,NA,NA
"Possibilities for e reduced to [5,6] ",NA,NA
Studying variable n ,NA,NA
Possibilities for n reduced to [6] ,NA,NA
Studying variable e ,NA,NA
Possibilities for e reduced to [5] ,NA,NA
Studying variable y ,NA,NA
Possibilities for y reduced to [2],NA,NA
"choice_list(y,[2]).",NA,NA
"choice_list(e,[5]).",NA,NA
"choice_list(n,[6]).",NA,NA
"choice_list(d,[7]).",NA,NA
"choice_list(c1,[1]). ",NA,NA
"choice_list(r,[8]).",NA,NA
"choice_list(c10,[1]). ",NA,NA
"choice_list(s,[9]).",NA,NA
"choice_list(c100,[0]). ",NA,NA
"choice_list(o,[0]).",NA,NA
"choice_list(m,[1]).",NA,NA
yes,NA,NA
.SH Keywords: ,NA,NA
constraint,NA,NA
label,NA,NA
dependency,NA,NA
dependency-based backtracking,NA,NA
possibility list,NA,NA
relaxation,NA,NA
active variable,NA,NA
Exercises ,NA,NA
13-1. (A) Suppose in an expert system written in Prolog we have the following rules for proving that some person X ,NA,NA
is an ,NA,NA
a,NA,NA
: ,NA,NA
"a(X) :- b(X), c(X).",NA,NA
a(X) :- d(X).,NA,NA
a(X) :- e(X).,NA,NA
Suppose: ,NA,NA
b ,NA,NA
is ,NA,NA
true ,NA,NA
with ,NA,NA
probability ,NA,NA
0.8; ,NA,NA
c ,NA,NA
is ,NA,NA
true ,NA,NA
with ,NA,NA
probability ,NA,NA
0.7; ,NA,NA
d ,NA,NA
is ,NA,NA
true ,NA,NA
with ,NA,NA
probability ,NA,NA
0.1; ,NA,NA
e ,NA,NA
is ,NA,NA
true ,NA,NA
with ,NA,NA
probability ,NA,NA
0.6; ,NA,NA
"b, c, d, and e are probabilistically independent of one another. ",NA,NA
"Rearrange the three rules, and perhaps the expressions in the first rule, to give the fastest (most efficient) execution of ",NA,NA
the query ,NA,NA
?- a(george).,NA,NA
13-2. Rearrange the query given in Figure 13-6 for most efficient execution using the suggested rearrangement ,NA,NA
guidelines. How does regular Prolog interpretation of the rearranged query compare with dependency-based ,NA,NA
backtracking on the original query? ,NA,NA
"13-3. (E) For some queries it is better to rearrange the query than to do dependency-based backtracking, but for other ",NA,NA
queries dependency-based backtracking will always result in fewer backtracks than any rearrangement of the query. ,NA,NA
Explain why the following exemplifies the latter situation: ,NA,NA
"?- a(X), b(Y), c(Z), d(X,Y), e(X,Z), f(Y,Z).",NA,NA
13-4. (A) Suppose we are doing relaxation for picture interpretation. It would be nice if we can determine unique ,NA,NA
variable assignments when done; that would be strong evidence that we found the correct interpretation of the ,NA,NA
picture. ,NA,NA
But what can we conclude if we get instead: ,NA,NA
(a) No possible final interpretations? ,NA,NA
(b) Two possible final interpretations? ,NA,NA
(c) One million possible final interpretations? ,NA,NA
13-5. (E) Discuss why relaxation might have more application to artistic creation than any of the other control ,NA,NA
structures we have discussed in this book. ,NA,NA
"13-6. (R,A) Budget General Hospital must schedule meals for its patients. Budget tries to save its patients money, so ",NA,NA
"its food is cheap and tastes terrible, and there are only three meals offered: ",NA,NA
Meal m1: gruel ,NA,NA
Meal m2: dehydrated eggs ,NA,NA
Meal m3: leftovers from nearby restaurants ,NA,NA
"Assist the hospital by scheduling six meals for a patient. The six meals are breakfast, lunch, and dinner on each of the ",NA,NA
two days. The following constraints apply: ,NA,NA
"C1. Breakfast on the first day must be Meal m1, since the patient will still be queasy from ",NA,NA
their operation. ,NA,NA
C2. No two meals in succession may be the same--you don't want the patients to realize how cheap you ,NA,NA
are. ,NA,NA
"C3. Meal m3 is the most expensive, so it must only occur once. (It requires a trip to a restaurant.) ",NA,NA
C4. Every meal on the second day must have a higher number than the meal at the corresponding time ,NA,NA
"on the first day. For instance, lunch on the first day could be Meal 1 and lunch on the second day Meal ",NA,NA
m2. ,NA,NA
(This is because patients are harder to fool as they recover.) ,NA,NA
"Find a meal plan for the six meals using pure relaxation. After obtaining initial possibility lists, check the possibilities ",NA,NA
"for breakfast on the second day, and proceed from there. Write out each step of your solution, giving constraints used ",NA,NA
and how they were used. ,NA,NA
13-7. (E) Develop a relaxation approach to analyzing pictures like Figure 13-9. This picture was produced by a camera ,NA,NA
mounted on a robot moving around outdoors. The picture only indicates line boundaries between visual regions of ,NA,NA
"abruptly different brightness. Assume all the lines represent sharp boundaries, and the camera was focussed far away ",NA,NA
so that everything seen was more than 30 feet away. Assume the camera was oriented so that horizontal is one third of ,NA,NA
the way down from the top of the picture. ,NA,NA
"(a) Define ten permissible labels for regions based on their shapes, the ten most reasonable ones you can think of. ",NA,NA
(b) List impossible relationships between regions based on these labels (what regions cannot be next to a particular ,NA,NA
"region, etc.) Use ",NA,NA
above,NA,NA
", ",NA,NA
left-of,NA,NA
", and ",NA,NA
inside,NA,NA
" for relationships, and any others you think useful. Treat combinations that ",NA,NA
are possible only rarely as impossible; don't worry about minor exceptions. ,NA,NA
(c) Use your constraints to assign as narrow an interpretation as possible to the picture. ,NA,NA
13-8. Relaxation can be used to solve an immensely important problem of large organizations: interpretation of ,NA,NA
"acronyms. The full names of many organizations are so long that it's impossible to avoid abbreviating them, yet no one ",NA,NA
can keep track of all these acronyms. Sophisticated computer programs are maybe necessary. ,NA,NA
"Suppose for each letter of the alphabet we have a list of words that the letter could represent, in the context of names of ",NA,NA
government organizations. Suppose: ,NA,NA
"N can be national, naval, new, name ",NA,NA
"S can be school, staff, science ",NA,NA
"C can be center, committee, computer, crazy ",NA,NA
Here are the constraints: ,NA,NA
"C1: a word at the right end of an acronym must be a noun. The nouns are ""name"", ""science"", ""school"", ",NA,NA
"""staff"", ""center"", ""committee"", and ""computer"". ",NA,NA
"C2: a word anywhere else must be an adjective. The adjectives are ""national"", ""naval"", ""new"", ""science"", ",NA,NA
"""computer"", and ""crazy"". ",NA,NA
C3: the same word cannot occur twice in an acronym. ,NA,NA
"C4: ""national"" and ""naval"" cannot be in the same acronym with ""crazy"" (no one ever admits something ",NA,NA
"national or naval is crazy, even when it is). ",NA,NA
"C5: ""staff"" cannot be in the same acronym with ""naval"", ""national"", or ""name"". ",NA,NA
"C6: ""new"" cannot be in the same acronym with ""science"". ",NA,NA
"Interpret the acronym ""NCSS"" using these constraints. ",NA,NA
(a) Use relaxation to reduce the possibilities as much as you can. Write out each step. Then write out the possible ,NA,NA
interpretations remaining. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (33 of 36) [23/04/2002 17:39:23],NA
"(b) Suppose we assign probabilities to every word possibility, representing how likely they are to occur in an acronym. ",NA,NA
"So ""national"" might be 0.5 and ""new"" might be 0.02 (rarely is anything new in government organizations). Describe a ",NA,NA
"good way to combine these probabilities to choose the ""best"" one of several interpretations of some acronym, ""best"" ",NA,NA
according to a single derived number (give or refer to a formula). ,NA,NA
13-9. (H) Try to interpret Figure 13-10 (label the regions) using constraint propagation. You won't be able to find a ,NA,NA
"unique interpretation, but do as much as you can. Initial region labels are as follows: ",NA,NA
"The five small regions are either airplanes or ships; anything else is either water, marsh, land, or a cloud. ",NA,NA
You have the following constraints: ,NA,NA
"C1. Airplane regions are the only ones that can be within cloud regions, but airplane regions can be ",NA,NA
within any region. ,NA,NA
C2. Ship regions can only be within water regions. ,NA,NA
C3. Two small regions touching one another must be ships. ,NA,NA
"C4. A ""T"" vertex (where three line segments meet, and two of them form an angle of approximately ",NA,NA
180 degrees) not involving a ship or airplane means either ,NA,NA
"(a) that the region with the 180 degree angle is a cloud, or ",NA,NA
(b) the region with the 180 degree angle is land and the other two regions are water and ,NA,NA
marsh. ,NA,NA
C5. Every marsh region must have such a T vertex somewhere on its ,NA,NA
border. C6. Water regions cannot border water regions. ,NA,NA
C7. Marsh regions cannot border marsh regions. ,NA,NA
C8. Land regions cannot border land regions. ,NA,NA
C9. The outer (border) region is not a cloud. ,NA,NA
Give every step in your relaxation. ,NA,NA
13-10.(a) Suppose in relaxation there are ten variables with initially eight possible labels each. Suppose there is a ,NA,NA
unique solution. What is the size of the search space? ,NA,NA
"(b) Suppose each step that chooses a variable eliminates half the possibilities for that variable, on the average. What ",NA,NA
is approximately the average number of steps to reach the unique solution? ,NA,NA
"13-11. Consider a picture as a graph. Regions border edges, and there are vertices where edges meet. Suppose you do ",NA,NA
"relaxation to interpret the picture, and constraints specify what labels adjacent regions can have. Suppose you draw ",NA,NA
"another graph for which the vertices represent variables in the relaxation, with connections between vertices ",NA,NA
representing that the two variables both occur together in at least one constraint. What is the relationship of this new ,NA,NA
graph to the original picture graph? ,NA,NA
13-12. (E) Suppose we are certain that there is one and only one solution to a relaxation problem. Suppose when we ,NA,NA
"run this relaxation problem with all the constraints we can think of, we get several hundred possible interpretations. ",NA,NA
"Suppose we can also formulate some ""reasonable restrictions"", restrictions usually but not always true (their ",NA,NA
"probability being close to 1). Then we can try to get a solution by taking (assuming) some of the ""reasonable ",NA,NA
"restrictions"" as ",NA,NA
"constraints, and seeing if we get a unique solution to the relaxation. But we want to assume as few restrictions as ",NA,NA
"possible, and we prefer to assume those that are most certain. Explain how finding a unique solution to a relaxation ",NA,NA
"problem by assuming ""reasonable restrictions"" can be considered a search problem. Describe its characteristics, ",NA,NA
and recommend an appropriate search strategy. ,NA,NA
"13-13. (R,A,P) Consider the query: ",NA,NA
"?- n(X), n(Y), n(Z), X>Y, not(f(X,X)), g(X,Y,Z).",NA,NA
Suppose the database is: ,NA,NA
n(1),NA,NA
. ,NA,NA
n(2),NA,NA
. ,NA,NA
n(3),NA,NA
. ,NA,NA
n(4),NA,NA
. ,NA,NA
n(5),NA,NA
.,NA,NA
"f(2,2)",NA,NA
. ,NA,NA
"f(2,4)",NA,NA
. ,NA,NA
"f(3,1)",NA,NA
.,NA,NA
"g(1,3,2)",NA,NA
. ,NA,NA
"g(2,3,3)",NA,NA
. ,NA,NA
"g(3,3,4)",NA,NA
. ,NA,NA
"g(4,3,5)",NA,NA
.,NA,NA
(a) How many times does this query backtrack to get its first answer? Count each right-to-left movement from ,NA,NA
predicate expression to predicate expression as one backtrack. ,NA,NA
(b) Rearrange the query in a form that leads to the fewest backtracks. How many times does it backtrack now? Show ,NA,NA
the query you used. ,NA,NA
(c) Suggest a way to do dependency-based backtracking to answer the original query. Simulate it without the computer. ,NA,NA
How many times do you backtrack now? ,NA,NA
(d) Now answer the original query by doing relaxation without the computer. Assume the standard form of relaxation ,NA,NA
"that tries to satisfy each multivariable constraint separately, throwing away previously found bindings. Write out your ",NA,NA
steps. ,NA,NA
13-14. (A) The demonstration of the pure relaxation program on the cryptarithmetic problem takes a considerable ,NA,NA
"amount of time on the first few variables, then speeds up considerably. If instead of specifying E=5 we say that E ",NA,NA
"is either 0 or 5, the program runs faster and reaches a solution faster. ",NA,NA
(a) What accounts for this paradox? ,NA,NA
(b) Suggest code that can be eliminated from the definition of this cryptarithmetic problem to significantly lessen or ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (35 of 36) [23/04/2002 17:39:23],NA
eliminate the paradoxical behavior. ,NA,NA
(c) The code that you eliminated in part (b) must have been there for a reason. What was it? ,NA,NA
13-15. (P) Suppose you have an eight-digit number whose digits are all different. Suppose that when you multiply ,NA,NA
"this number by its rightmost (least) digit, you get a nine-digit number whose digits are all the leftmost (highest) digit ",NA,NA
of the original number. Suppose further that the second-highest digit of the original number is 2. Set this problem up ,NA,NA
in a problem-dependent file to run with the pure relaxation program. Run it and see what you get. ,NA,NA
"13-16. (H,P) Generalize the ""double relaxation"" program to ""N-relaxation"". In other words, take three constraints ",NA,NA
"together if you don't get anywhere with two constraints together, and four constraints together if you don't get ",NA,NA
"anywhere with three, and so on up to the total number of constraints. This will require recursion. The program should ",NA,NA
degrade to standard Prolog querying in the worst case. Try your program on the cryptarithmetic problem CROSS + ,NA,NA
ROADS = DANGER. ,NA,NA
"13-17. (H,P) Besides double relaxation, there is an alternative improvement on pure relaxation: keep possibility lists ",NA,NA
"for pairs, triples, etc. of variables instead of single variables. So you can solve harder problems this way than with pure ",NA,NA
"relaxation, but you need more possibility lists. Write a ""pair-relaxation program"" that reasons about pairs of values this ",NA,NA
way. ,NA,NA
"13-18. (A) We can see relaxation as a search problem with a single operator: picking a variable and a value, and ",NA,NA
trying to verify that value is still possible. ,NA,NA
"(a) What is the search space for this problem? Remember, a state for a search problem must include everything ",NA,NA
about the problem in one bundle. ,NA,NA
"(b) Which search strategy, of those mentioned in Chapter 9, is most like that used by the algorithm? ",NA,NA
(c) Is this search decomposable about intermediate states into simpler subproblems? ,NA,NA
(d) How does the branching factor change as search proceeds? ,NA,NA
(e) Give an upper bound on the size of the search space. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap13.html (36 of 36) [23/04/2002 17:39:23],NA
A more general logic programming ,NA,NA
Prolog is a language for ,NA,NA
logic programming,NA,NA
". That is, it's a programming language that looks and works ",NA,NA
"somewhat like formal logic. To be efficient and easy to use, Prolog omits some important features of ",NA,NA
"formal logic. We'll discuss now these omissions, and present a more general and powerful--but slower--",NA,NA
approach to logic programming. This approach is called ,NA,NA
resolution,NA,NA
", and it emphasizes declarative ",NA,NA
(instead of procedural) meanings of logical formulas. ,NA,NA
Logical limitations of Prolog ,NA,NA
Prolog can do many things. But it has four fundamental logical weaknesses: ,NA,NA
"1. Prolog doesn't allow ""or""d (disjunctive) facts or conclusions--that is, statements that one ",NA,NA
"of several things is true, but you don't know which. For instance, if a light does not come on ",NA,NA
"when we turn on its switch, we can conclude that either the bulb is burned out or the power ",NA,NA
is off or the light is disconnected. ,NA,NA
"2. Prolog doesn't allow ""not"" (negative) facts or conclusions--that is, direct statements that ",NA,NA
"something is false. For instance, if a light does not come on when we turn on its switch, ",NA,NA
but another light in the same room comes on when we turn on ,NA,NA
its,NA,NA
" switch, we can conclude ",NA,NA
that it is false that there is a power failure. ,NA,NA
"3. Prolog doesn't allow most facts or conclusions having existential quantification--that is, ",NA,NA
"statements that there exists some value of a variable, though we don't know what, such that ",NA,NA
a predicate expression containing it is true. (Prolog does have a limited form of existential ,NA,NA
"quantification for local variables in rules, as discussed in Section 4.1.) For instance, if we ",NA,NA
"know that something is wrong with an appliance, then there exists a component X of the ",NA,NA
appliance such that X has a fault in it. ,NA,NA
4. Prolog doesn't directly allow ,NA,NA
second-order logic,NA,NA
", predicate names as variables--that is, ",NA,NA
statements about P where P stands for any predicate name. We can get something close ,NA,NA
with the trick of the ,NA,NA
inherits,NA,NA
" predicate in the car frame hierarchy of Section 12.11, the idea ",NA,NA
of rewriting facts to include extra predicate-name arguments. You can also approach ,NA,NA
second-order logic using the built-in ,NA,NA
clause,NA,NA
 predicate discussed in Section 7.13. So this ,NA,NA
"weakness of Prolog is less serious than the others, and we won't say anything further about ",NA,NA
it in this chapter. ,NA,NA
"Notice that these are logical issues, not efficiency issues. Chapter 6 discussed how Prolog isn't an ",NA,NA
efficient control structure for reasoning about some problems. But these four points are deeper and more ,NA,NA
serious weaknesses: they represent things Prolog can't do at all even working slowly. ,NA,NA
The logical (declarative) meaning of Prolog rules and facts ,NA,NA
"To better understand Prolog's limitations and how to get around them, let's examine more carefully what ",NA,NA
Prolog rules and facts mean. ,NA,NA
"Chapter 4 explained how rules and facts all go into a Prolog database of true statements. Alternatively, a ",NA,NA
"Prolog database can be seen as a single logical statement representing the conjunction (""and""ing) of the ",NA,NA
statements of each rule and fact. We'll now show how the declarative or logical meaning (not the same as ,NA,NA
the procedural meaning) of any Prolog database can be expressed entirely as a set of statements using ,NA,NA
"only ""or""s and ""not""s. ",NA,NA
"To do this we must first remove the """,NA,NA
:-,NA,NA
""" symbol from rules, because that is not a logic symbol. In Section ",NA,NA
"4.1 we said to think of it as a backward arrow or backward implication. In logic, an implication (or, ",NA,NA
"strictly speaking, a ",NA,NA
material,NA,NA
" implication) is equivalent to an ""or"" (a disjunction, symbolized in Prolog by ",NA,NA
"""",NA,NA
;,NA,NA
""") of the pointed-to side of the arrow with the negation of the other side of the arrow. So the rule ",NA,NA
a :- b.,NA,NA
is equivalent in logical (declarative) meaning to ,NA,NA
a; not(b).,NA,NA
"which reads as ""a or not b"". Figure 14-1 shows the truth table for the two forms, to better convince you. ",NA,NA
An immediate generalization comes from taking predicate ,NA,NA
b,NA,NA
" to be an ""and"" (conjunction) itself. For ",NA,NA
instance ,NA,NA
"a :-  c, d, e.",NA,NA
is equivalent to ,NA,NA
"a; not(c,d,e).",NA,NA
which by DeMorgan's Law is the same as: ,NA,NA
a; not(c); not(d); not(e).,NA,NA
"So we can express the logical equivalent of any Prolog rule by ""or""ing the left side with the ",NA,NA
not,NA,NA
s of each ,NA,NA
"expression that is ""and""ed on the original right side. This is called the ",NA,NA
clause form,NA,NA
 of the rule. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (2 of 15) [23/04/2002 17:39:26],NA
But logical equivalence is not complete equivalence of meaning because it only covers the declarative ,NA,NA
"meaning of rules. Prolog rules also have the ""procedural"" interpretation of ""If you believe that these ",NA,NA
"things hold, then believe that this thing holds"". So rules involve a causation, a moving from a cause (a ",NA,NA
belief in several things) to an effect (a belief in something else); and the effect comes after the cause in ,NA,NA
"time. Causations imply a direction of reasoning, while an ""or"" doesn't necessarily. For instance, ",NA,NA
a :- b.,NA,NA
models a causation from ,NA,NA
b,NA,NA
 to ,NA,NA
a,NA,NA
. But its logical equivalent in clause form ,NA,NA
a; not(b).,NA,NA
can also be used from ,NA,NA
a,NA,NA
 to ,NA,NA
b,NA,NA
: if we are told ,NA,NA
a,NA,NA
" is false, then ",NA,NA
b,NA,NA
" must be false too so the ""or"" will be true. ",NA,NA
That's the ,NA,NA
contrapositive,NA,NA
" direction of reasoning, and Prolog rules can't be used that way even though it's ",NA,NA
logically valid | REFERENCE 1|. .FS | REFERENCE 1| Don't confuse the backward reasoning of the ,NA,NA
"contrapositive with backward chaining. Backward chaining reasons about the left side of some rule, ",NA,NA
whereas contrapositive reasoning reasons about the ,NA,NA
opposite,NA,NA
 of the left side. .FE ,NA,NA
But clause form has advantages too. The second limitation on reasoning of Prolog interpreters mentioned ,NA,NA
in Section 14.1 concerned ,NA,NA
not,NA,NA
"s: they mean ""impossible to prove"", not ""proved false"". But when we write ",NA,NA
things in clause form we can interpret ,NA,NA
not,NA,NA
"s more precisely, to reach new conclusions not otherwise ",NA,NA
"possible. For instance, in the previous contrapositive reasoning example, when ",NA,NA
a,NA,NA
" is false, ",NA,NA
b,NA,NA
 is proved ,NA,NA
"false, not just proved to be impossible to succeed. So clause form can provide ""true nots"". But there is an ",NA,NA
associated danger: when the Prolog rule itself has a ,NA,NA
not,NA,NA
", we must make sure that we can interpret it as ",NA,NA
"provably false in the real world. Otherwise, the clause form only covers part of its meaning. ",NA,NA
Extending Prolog rules ,NA,NA
"Using the preceding clause-form conversion for Prolog rules lets us give meaning to new kinds of rules, ",NA,NA
"rules not legal in Prolog. For instance this ""pseudo-Prolog"" ",NA,NA
(a; b) :- c.,NA,NA
which means that either of ,NA,NA
a,NA,NA
 or ,NA,NA
b,NA,NA
 is true whenever ,NA,NA
c,NA,NA
" is true, becomes in clause form ",NA,NA
a; b; not(c).,NA,NA
And this pseudo-Prolog ,NA,NA
not(a) :- b.,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (3 of 15) [23/04/2002 17:39:26],NA
which means ,NA,NA
a,NA,NA
 is false whenever ,NA,NA
b,NA,NA
" is true, becomes ",NA,NA
not(a); not(b).,NA,NA
"Notice that the first clause-form formula has two unnegated expressions, and the second has no ",NA,NA
"unnegated expressions. In general, any Prolog rule without ",NA,NA
not,NA,NA
s becomes a clause form having one and ,NA,NA
"only one unnegated expression, what's called a ",NA,NA
Horn clause,NA,NA
. ,NA,NA
"Clause form for a rule can require more than one ""or""ed formula. As a more complicated example, ",NA,NA
consider this pseudo-Prolog ,NA,NA
"(a; (b, c)) :- d, not(e). ",NA,NA
which has the logical equivalent ,NA,NA
"a; (b, c); not(d); e.",NA,NA
"To get rid of the ""and"", we can use the distributive law for ""and"" over ""or"". This gives two separate ",NA,NA
statements (,NA,NA
clauses,NA,NA
"), each of which must be true: ",NA,NA
a; b; not(d); e.,NA,NA
a; c; not(d); e.,NA,NA
And that's the clause form for the original rule. ,NA,NA
"Rewriting rules in clause form answers some puzzling questions of why rules sometimes seem ""and""ed ",NA,NA
"together and other times ""or""ed together. Suppose we have two rules ",NA,NA
a :- b.,NA,NA
a :- c.,NA,NA
The logical equivalent form is ,NA,NA
"(a; not(b)), (a; not(c)). ",NA,NA
or: ,NA,NA
"a; (not(b), not(c)).",NA,NA
"using the distributive law of ""and"" over ""or"". This can be rewritten as a single rule ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (4 of 15) [23/04/2002 17:39:26],NA
a :- (b;c).,NA,NA
"using DeMorgan's Law. So an ""and"" in the one sense--the ""and"" of the logical truth of separate rules--is ",NA,NA
"an ""or"" in another--the ""or"" of the right sides of rules with the same left side. ",NA,NA
More about clause form ,NA,NA
"So a clause is an ""or"" of a bunch of things, each of which is either a single predicate expression or the ",NA,NA
not ,NA,NA
"of one. As usual, expressions can have arguments. For instance, this ""santa clause"": ",NA,NA
santa(joe); santa(tom); not(santa(bill)).,NA,NA
Any statement we can express in first-order logic has a logical equivalent in a set of clauses. Why is this ,NA,NA
"important? Because there's a simple yet powerful inference method that can be applied to clauses, ",NA,NA
resolution,NA,NA
. It can be proved that ,NA,NA
any,NA,NA
 inference that logically follows from a set of statements can be ,NA,NA
found by using resolution on the clause forms of those statements. So resolution is more powerful than ,NA,NA
Prolog-style backward chaining. ,NA,NA
"But to use resolution, everything must be in clause form. We've already illustrated a procedure for ",NA,NA
"translating ""pseudo-Prolog"" with ""or""s, ""not""s, and arbitrarily complex formulas on the left sides of rules: ",NA,NA
just rewrite in ,NA,NA
disjunctive normal form,NA,NA
" as an ""or"" of ""and""s, using the laws of logic. That covers the first ",NA,NA
two limitations of Prolog cited in Section 14.1. But what about existential quantifiers? They can get ,NA,NA
complicated. ,NA,NA
The simplest case for existential quantifiers is when we want to assert there exists some variable value ,NA,NA
such that a predicate expression mentioning that variable is true. Then we can substitute a constant for the ,NA,NA
"variable, provided that constant can't be confused with an actual value of the variable, like a nonsense ",NA,NA
"word. For instance, if we want to say that there exists an X such that ",NA,NA
p(X),NA,NA
" is true, then we can could assert ",NA,NA
fact ,NA,NA
p(zzxxy),NA,NA
 provided that ,NA,NA
zzxxy,NA,NA
 is not a symbol for any of the actual values for X. We can then use this ,NA,NA
fact ,NA,NA
p(zzxxy),NA,NA
" in chains of reasoning, just remembering that this value doesn't really mean anything. ",NA,NA
But now suppose we want to say that for every Y there exists X such that ,NA,NA
"p(X,Y)",NA,NA
 holds. Now we can't just ,NA,NA
"substitute a constant for X because X may depend on Y: that is, X is a function of Y. This function is a ",NA,NA
Skolem function,NA,NA
. We need one whenever we are trying to represent in clause form a statement containing ,NA,NA
both existential and universal quantification. Standard techniques exist for situations needing Skolem ,NA,NA
"functions, but they are too complicated to discuss here. See books on ""theorem proving"" if you're ",NA,NA
interested. ,NA,NA
Resolution ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (5 of 15) [23/04/2002 17:39:26],NA
"Resolution is an inference technique that takes two clauses as input, and produces a clause as output. The ",NA,NA
"output clause, the ",NA,NA
resolvent,NA,NA
", represents a true statement consistent with the input clauses, the result of ",NA,NA
resolving,NA,NA
" them. In other words, the resolvent is one conclusion we can draw. If the resolvent is a fact, ",NA,NA
"then we've proved a fact. If the resolvent is the clause consisting of no expressions, the ",NA,NA
null clause,NA,NA
", we've ",NA,NA
proved a contradiction. Resolution is particularly efficient for proof by contradiction: we assume the ,NA,NA
"opposite of some statement we wish to prove, and see if we can prove the null clause from it. ",NA,NA
"Resolution requires pairs of opposites in the two input clauses. That is, one input clause must contain a ",NA,NA
predicate expression--call it P--for which ,NA,NA
not(Q),NA,NA
 occurs in the other input clause and where P can match ,NA,NA
"Q by binding variables as necessary. (Formally, P matches Q if the expression ",NA,NA
P=Q,NA,NA
 can succeed.) Then ,NA,NA
"the resolvent of the two input clauses is the ""or"" of everything besides P and ",NA,NA
not(Q),NA,NA
" in the two clauses, ",NA,NA
eliminating any duplicate expressions. We say that the P and the ,NA,NA
not(Q),NA,NA
" ""cancel"". For instance, if the ",NA,NA
input clauses are ,NA,NA
a; b; not(c); d.,NA,NA
e; not(b); a; f.,NA,NA
then the resolvent (output) clause is ,NA,NA
a; not(c); d; e; f.,NA,NA
where we eliminated the opposites ,NA,NA
b,NA,NA
 and ,NA,NA
not(b),NA,NA
 and a duplicate ,NA,NA
a,NA,NA
 fact. ,NA,NA
Inference by resolution becomes most useful when we do several resolutions in succession. Here's an ,NA,NA
"example. Let's use Horn clauses (clauses with one and only one unnegated expression), because we ",NA,NA
"already know how Prolog interpreters handle them, and let's avoid variables. Suppose we have these ",NA,NA
rules and facts: ,NA,NA
"a :- b, c.",NA,NA
c :- d.,NA,NA
b.,NA,NA
d.,NA,NA
"Rewriting in clause form, we get these Horn clauses: ",NA,NA
a; not(b); not(c).,NA,NA
c; not(d).,NA,NA
b.,NA,NA
d.,NA,NA
(Prolog facts are identical in clause form.) Now suppose we want to prove ,NA,NA
a,NA,NA
 (see Figure 14-2): ,NA,NA
"1. To do proof by contradiction, we add ",NA,NA
not(a),NA,NA
 to the other four clauses in our database of ,NA,NA
true statements. ,NA,NA
2. Resolving ,NA,NA
not(a),NA,NA
" with the first of the four original statements, the ",NA,NA
a,NA,NA
 and ,NA,NA
not(a) ,NA,NA
"expressions cancel, and the resolvent is ",NA,NA
not(b); not(c),NA,NA
. We can add that new clause to the ,NA,NA
others. ,NA,NA
"3. Resolving this new clause with the third of the original clauses, the ",NA,NA
b,NA,NA
 and ,NA,NA
not(b),NA,NA
" cancel, ",NA,NA
and the resolvent is just ,NA,NA
not(c),NA,NA
. ,NA,NA
"4. Resolving this in turn with a second of the original four clauses, we cancel the ",NA,NA
c,NA,NA
 and ,NA,NA
not(c),NA,NA
", giving as resolvent ",NA,NA
not(d),NA,NA
. ,NA,NA
"5. Finally we resolve this with the last of the original four clauses, and ",NA,NA
d,NA,NA
 and ,NA,NA
not(d),NA,NA
" cancel, ",NA,NA
leaving us with a null clause. ,NA,NA
6. Therefore we can prove anything if we assume that ,NA,NA
a,NA,NA
 is false. So ,NA,NA
a,NA,NA
 must be true. (This ,NA,NA
"assumes that the original set of rules and facts was not self-contradictory, something we ",NA,NA
could verify by doing all possible resolutions among them.) ,NA,NA
There is a one-to-one correspondence of the steps in the previous ,NA,NA
resolution proof,NA,NA
 and the steps that ,NA,NA
Prolog interpreters follow in backward chaining. To prove ,NA,NA
a,NA,NA
", they would: ",NA,NA
1. Take ,NA,NA
a,NA,NA
 as the goal (query). ,NA,NA
2. Find a rule for ,NA,NA
a,NA,NA
: the first rule. This says to prove ,NA,NA
b,NA,NA
", then ",NA,NA
c,NA,NA
. ,NA,NA
3. But ,NA,NA
b,NA,NA
 is a fact (the first fact). ,NA,NA
4. To prove ,NA,NA
c,NA,NA
", use the second rule, which says to prove ",NA,NA
d,NA,NA
. ,NA,NA
5. But ,NA,NA
d,NA,NA
 is a fact (the second fact). ,NA,NA
6. Therefore ,NA,NA
c,NA,NA
 is true and ,NA,NA
a,NA,NA
 is true. ,NA,NA
"In general, resolution can do anything backward chaining can do, but not the other way around. ",NA,NA
"Resolution is a more general and flexible form of inference, because it can resolve clauses in many ",NA,NA
different orders; backward chaining is more rigid. And every new resolvent clause can be used many ,NA,NA
"ways in new resolutions, so resolution possibilities keep increasing--it's a ",NA,NA
monotonic,NA,NA
 search process. ,NA,NA
Resolution with variables ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (7 of 15) [23/04/2002 17:39:26],NA
"When predicates have variable arguments, resolution becomes a little more complicated: we still look for ",NA,NA
"a pair of opposites, but Prolog-style binding of the variables can be done to make the canceling ",NA,NA
"expressions ""match"". As with Prolog, bindings made to variables apply to any other occurrences of the ",NA,NA
"variables within their original clauses, so if a ",NA,NA
p(X),NA,NA
 in the first input clause matches a ,NA,NA
p(4),NA,NA
 in the second ,NA,NA
"input clause, any other ",NA,NA
X,NA,NA
 in the first clause becomes a 4. Variables can also be bound to other variables. ,NA,NA
Important note: it's essential that each input clause have different variable names before resolving. ,NA,NA
Here's an example of resolution with variables. Suppose the two clauses are ,NA,NA
"a(3); b(Y); not(c(Z,Y)).",NA,NA
"not(a(W)); b(dog); c(W,cat).",NA,NA
The ,NA,NA
a,NA,NA
 expressions can cancel with ,NA,NA
W,NA,NA
" bound to 3, giving: ",NA,NA
"b(Y); not(c(Z,Y)); b(dog); c(3,cat).",NA,NA
The ,NA,NA
b(dog),NA,NA
 is redundant with ,NA,NA
b(Y),NA,NA
", so we can improve this clause to: ",NA,NA
"b(Y); not(c(Z,Y)); c(3,cat).",NA,NA
But we could resolve the original two clauses another way. The ,NA,NA
c,NA,NA
" expressions could cancel, with ",NA,NA
Z,NA,NA
 being ,NA,NA
bound to ,NA,NA
W,NA,NA
 and with ,NA,NA
Y,NA,NA
 being bound to ,NA,NA
cat,NA,NA
", giving: ",NA,NA
a(3); b(cat); not(a(W)); b(dog).,NA,NA
"This is a completely different resolvent, representing a different conclusion possible from the two ",NA,NA
clauses. Notice that we can't eliminate anything here; ,NA,NA
b(cat),NA,NA
 and ,NA,NA
b(dog),NA,NA
" aren't redundant, nor are ",NA,NA
a(3) ,NA,NA
and ,NA,NA
not(a(W)),NA,NA
. ,NA,NA
Note that bindings are transitive: if ,NA,NA
A,NA,NA
" is bound to 9, and ",NA,NA
B,NA,NA
 is bound to ,NA,NA
A,NA,NA
", then ",NA,NA
B,NA,NA
 is bound to 9 too. So ,NA,NA
several reasoning steps may be necessary to determine a variable binding. ,NA,NA
Three important applications of resolution ,NA,NA
Resolution is a powerful inference technique that can supplant other inference techniques. Three ,NA,NA
"important special cases of resolution are summarized in Figure 14-3: backward chaining, forward ",NA,NA
"chaining, and rule collapsing. To use resolution for backward chaining as in Section 14.5, one starting ",NA,NA
clause is always the negation (opposite) of something to be proved. To use resolution for forward ,NA,NA
"chaining, one input clause for every resolution is always a fact. Rule collapsing is a way to make rules ",NA,NA
"more efficient, not a control structure itself: it takes two rules, one whose left side is on the other's right ",NA,NA
"side, and combines them into a single new rule; this is equivalent to resolving the rules' clauses. ",NA,NA
Procedure collapsing is important to compilers for programming languages. ,NA,NA
Resolution search strategies ,NA,NA
Reasoning by resolution means performing a series of resolution operations. This often means more ,NA,NA
"things to choose from than conflict resolution in rule-based systems, because you must pick pairs of ",NA,NA
"clauses to resolve, and typically there are many. Facts are clauses too, as are the resolvents (results) from ",NA,NA
past resolutions. So resolution-based reasoning is a kind of search with a high branching factor. This ,NA,NA
"means a breadth-first resolution strategy (resolving every pair of original clauses, then every new clause ",NA,NA
"with either an original clause or a new clause, and so on) is very slow. In principle, a breadth-first ",NA,NA
resolution control structure can prove anything that is a logical consequence of particular facts and rules; ,NA,NA
but that's no good if it takes a hundred years to do so. ,NA,NA
Often we know what we want to prove. Then we can use a ,NA,NA
set-of-support,NA,NA
" strategy, which we used without ",NA,NA
"saying so in the example of Section 14.5. The idea is to assume the opposite of what we want to prove, ",NA,NA
and resolve it repeatedly with other clauses until we reach the null clause. If no possible resolutions ,NA,NA
"remain at some point (when no other clause has an opposite that can ""cancel""), back up to the last ",NA,NA
"previous resulting clause for which there were alternative resolutions, and take an alternative. This is ",NA,NA
basically a depth-first resolution strategy starting from the negation of the proof objective. ,NA,NA
"If we don't have any one thing in particular we want to prove, but we prefer to prove facts, then a ",NA,NA
unit-,NA,NA
preference,NA,NA
" resolution strategy may be good. The idea is to do first all resolutions involving facts, both ",NA,NA
"positive and negative. If there aren't any facts, then perhaps prefer resolutions involving two-argument ",NA,NA
"clauses, and so on. This strategy tends to keep resolvent clauses short, which often means we discover ",NA,NA
new facts fast. ,NA,NA
"If our clauses all represent rules, we may want to do the rule ",NA,NA
collapsing,NA,NA
 mentioned in the last section. A ,NA,NA
"breadth-first resolution strategy could work for this, since there's no designated objective or facts to work ",NA,NA
"from. For efficiency, we might try instead best-first search with the evaluation function the total number ",NA,NA
"of expressions in the input clauses, which tends to discourage less useful resolutions. In any event, we ",NA,NA
"should arbitrarily stop the search at some point, since there can be enormous numbers of possible ",NA,NA
"resolutions, and we don't want to try them all. ",NA,NA
Domain-dependent heuristics can help considerably when reasoning with resolution. Heuristics can ,NA,NA
enhance any of the search strategies mentioned. ,NA,NA
Implementing resolution without variables (*) ,NA,NA
Resolution without variables is simple to implement in Prolog. Represent the clauses as list arguments to ,NA,NA
clause,NA,NA
" facts, so for instance ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (9 of 15) [23/04/2002 17:39:26],NA
a; not(b); not(c); d.,NA,NA
is represented as ,NA,NA
"clause([a,not(b),not(c),d]).",NA,NA
"Notice lists require commas, so the comma here actually means ""or"". Then query the predicate ",NA,NA
go,NA,NA
. ,NA,NA
Everything new proved will be printed out. Here's the program: ,NA,NA
/* Resolution without variables */ ,NA,NA
"go :- resolution(C1,C2,Cnew), !, write(Cnew), nl, ",NA,NA
"not(Cnew=[]), go.",NA,NA
"resolution(C1,C2,Cnew) :- clause(C1), clause(C2), not(C1=C2), ",NA,NA
"matched_items(C1,C2,C1item,C2item), delete(C1item,C1,C1d), ",NA,NA
"delete(C2item,C2,C2d), union(C1d,C2d,Cnew), not(clause(Cnew)), ",NA,NA
"not(tautology(Cnew)), not(some_superset(Cnew)),",NA,NA
 asserta(clause(Cnew)).,NA,NA
"matched_items(C1,C2,C1item,not(C1item)) :- member(C1item,C1), ",NA,NA
"member(not(C1item),C2).",NA,NA
"matched_items(C1,C2,not(C2item),C2item) :- ",NA,NA
"member(not(C2item),C1), member(C2item,C2).",NA,NA
"some_superset(C) :- clause(C2), subset(C2,C).",NA,NA
"tautology(C) :- member(X,C), member(not(X),C).",NA,NA
"Notice that we check new clauses to make sure they're neither previously found, nor tautologies (always-",NA,NA
"true statements), nor immediately derivable from other clauses by removal of items; only then do we ",NA,NA
assert a new clause. The assertion uses ,NA,NA
asserta,NA,NA
", so a depth-first strategy much like set-of-support will be ",NA,NA
used. ,NA,NA
This requires the ,NA,NA
member,NA,NA
", ",NA,NA
delete,NA,NA
", and ",NA,NA
subset,NA,NA
" predicate definitions from Sections 5.5, 5.6, and 5.7 ",NA,NA
"respectively, plus the ",NA,NA
union,NA,NA
 predicate from Section 11.4 (which is closely related to the ,NA,NA
append,NA,NA
 of ,NA,NA
Section 5.6). Using ,NA,NA
union,NA,NA
 instead of ,NA,NA
append,NA,NA
 prevents repeated expressions in the resolvent. ,NA,NA
/* Utility functions for resolution */,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (10 of 15) [23/04/2002 17:39:26],NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- member(X,L).",NA,NA
"union([],L,L).",NA,NA
"union([X|L],L2,L3) :- member(X,L2), !, union(L,L2,L3). ",NA,NA
"union([X|L],L2,[X|L3]) :- union(L,L2,L3).",NA,NA
"delete(X,[],[]).",NA,NA
"delete(X,[X|L],M) :- !, delete(X,L,M). ",NA,NA
"delete(X,[Y|L],[Y|M]) :- delete(X,L,M).",NA,NA
"subset([],L).",NA,NA
"subset([X|L1],L2) :- member(X,L2), subset(L1,L2).",NA,NA
"For a demonstration, suppose we have these clauses: ",NA,NA
"clause([a,not(b),not(c)]). ",NA,NA
clause([b]).,NA,NA
"clause([d,not(a)]). ",NA,NA
"clause([c,e,f]).",NA,NA
Here's what happens when we run the program: ,NA,NA
?- go.,NA,NA
"[a,not(c)] ",NA,NA
"[not(c),d] ",NA,NA
"[d,e,f] ",NA,NA
"[a,e,f]",NA,NA
no,NA,NA
"Unfortunately, implementing resolution with variables in Prolog is very tricky. The problem is in ",NA,NA
"handling redundancies, the ",NA,NA
tautology,NA,NA
 and ,NA,NA
subset,NA,NA
" predicates of the program, for which Prolog's normal ",NA,NA
variable-binding must be subverted. Such full resolution inferencers can be written more easily in more ,NA,NA
flexible programming languages like Lisp. ,NA,NA
.SH Keywords: ,NA,NA
logic programming ,NA,NA
disjunctive fact ,NA,NA
negative fact ,NA,NA
existential quantifier ,NA,NA
second-order logic ,NA,NA
clause form ,NA,NA
Horn clause ,NA,NA
Skolem function ,NA,NA
resolution ,NA,NA
breadth-first resolution strategy ,NA,NA
set-of-support resolution strategy ,NA,NA
unit-preference resolution strategy,NA,NA
Exercises ,NA,NA
14-1. (A) Resolve all possible ways and list bindings: ,NA,NA
"state(3,A,X); possible(X,X,A).",NA,NA
"not(possible(5,Y,Z)); state(3,6,Y).",NA,NA
"14-2. (R,A) Suppose you are working for a research organization. Suppose you can get travel money if ",NA,NA
"your department chairman approves and your sponsor approves. Alternatively, you can get travel money ",NA,NA
"if your department chairman approves, the boss over him or her approves, and there are discretionary ",NA,NA
department funds available. ,NA,NA
(a) Represent the preceding as two Prolog rules. (Hint: use one-letter predicate names because you'll have ,NA,NA
to write them many times in this problem.) ,NA,NA
(b) Represent the two rules in clause form. ,NA,NA
(c) Suppose that these are the only two ways that you can get travel money. Therefore if you do get travel ,NA,NA
"money, certain things must have been true. Write this implication in ""pseudo-Prolog"" as a rule with the ",NA,NA
"symbol """,NA,NA
:-,NA,NA
""", but with ""and""s, ""or""s, and ""not""s on its left side. Your rule must cover ",NA,NA
all ,NA,NA
the implications of ,NA,NA
having travel money. ,NA,NA
(d) Convert this pseudo-Prolog rule to clause form. (Hint: clause form here is three clauses.) ,NA,NA
(e) Suppose you can get travel money. What new clauses logically follow from this? (Make sure there are ,NA,NA
no unnecessary extra expressions in the clauses.) ,NA,NA
(f) Suppose you can't get travel money. What new clauses logically follow from this? (Make sure there ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (12 of 15) [23/04/2002 17:39:26],NA
are no unnecessary extra expressions in the clauses.) ,NA,NA
14-3. (a) Represent the following in clause form: ,NA,NA
C1: Block A is on the table. ,NA,NA
C2: Block B is on block A. ,NA,NA
C3: Block C is on block A. ,NA,NA
C4: Block D is on block C. ,NA,NA
C5: Block A is blue. ,NA,NA
C6: Block B is blue. ,NA,NA
C7: Block C is red. ,NA,NA
C8: Block D is green. ,NA,NA
C9: A block is above another block X if it is on that block or else if it is on a block which ,NA,NA
is above X. ,NA,NA
"(b) Prove by resolution that block D is above a blue block. Give numbers of statements you resolve, and ",NA,NA
label your resolvents. ,NA,NA
14-4. Suppose we're told to resolve the clauses ,NA,NA
a; b.,NA,NA
not(a); not(b).,NA,NA
"Can we simultaneously cancel out both matched pairs, getting the null clause as resolvent? Why or why ",NA,NA
not? ,NA,NA
"14-5. (R,A) By the definition of resolution given in this chapter, if we resolve the clauses ",NA,NA
a; b.,NA,NA
not(a); c.,NA,NA
we get ,NA,NA
b; c.,NA,NA
But this doesn't seem to make sense if we show what's happening in a Venn diagram (See Figure 14-4). ,NA,NA
"Here the region marked with lines running from southwest to northeast represents the first clause, and the ",NA,NA
region marked with lines running southeast to northwest represents the second clause. Any pair of clauses ,NA,NA
"that are each individually true can be considered to be ""and""ed together. But the region that has both ",NA,NA
markings (the cross-hatched region) does not correspond to the preceding resolvent clause. What's ,NA,NA
wrong? ,NA,NA
14-6. (E) Suppose we have these Prolog rules: ,NA,NA
"a :- b, c.",NA,NA
"a :- not(b), d.",NA,NA
Suppose that ,NA,NA
not,NA,NA
" can also be interpreted as a ""real"" not, one that insists that negative evidence is present. ",NA,NA
(a) Write the two rules in clause form. ,NA,NA
"(b) Now resolve the two clauses from part (a), and write a new Prolog rule without ",NA,NA
not,NA,NA
s equivalent to the ,NA,NA
resolvent clause. ,NA,NA
(c) Explain how the idea of the preceding could be generalized to a useful trick to improve rule-based ,NA,NA
"expert systems, one that applies to rules of any length. Explain (i) how you pick appropriate (good) pairs ",NA,NA
"of rules, (ii) how you can avoid converting to clause form, and (iii) under what circumstances you can ",NA,NA
delete the original rules. ,NA,NA
14-7. Prolog interpreters are Horn-clause theorem-proving systems. But consider the following fallacy. ,NA,NA
(a) Represent in clause form this pseudo-Prolog: ,NA,NA
"(weekend(T); holiday(T)) :- empty(spanagel421,T).",NA,NA
"which means that if Spanagel 421 is empty, it must either be a weekend or a holiday. ",NA,NA
"(b) Convert this into an equivalent Prolog rule with only one expression, ",NA,NA
holiday(T),NA,NA
", on its left side. ",NA,NA
(c) Show that the original rule and the rule for part (b) have equivalent truth value by showing their truth ,NA,NA
tables. ,NA,NA
(d) Part (b) is a legal Prolog rule because it has only one predicate expression on its left side. So it seems ,NA,NA
we can always implement a non-Horn clause in Prolog. What's wrong with this argument? ,NA,NA
14-8. (E) Suppose we wish Prolog interpreters to use mathematical induction proof techniques ,NA,NA
"automatically. Discuss what is wrong with just adding an induction rule to all Prolog programs, saying in ",NA,NA
essence ,NA,NA
"""p(X) is true if p(1) is true and if for N>1, p(N) implies p(N+1).""",NA,NA
14-9. (A) Consider proving things by resolution as a search problem with one operator: resolve two ,NA,NA
clauses to get a new clause. Each state can be described as a set of clauses given or proved. Suppose you ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (14 of 15) [23/04/2002 17:39:26],NA
have N clauses to begin. ,NA,NA
(a) What is an upper bound on the initial branching factor? ,NA,NA
(b) What is an upper bound on the branching factor after K resolutions have been done? ,NA,NA
14-10. (P) The resolution program can be made more efficient. ,NA,NA
"(a) Improve it so it doesn't examine every pair of clauses, but only pairs in which the first clause precedes ",NA,NA
the second in the database. ,NA,NA
(b) Improve it to remove any clause that ,NA,NA
becomes ,NA,NA
"redundant, in that the expressions of the last clause ",NA,NA
discovered are a subset of the expressions of that clause. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap14.html (15 of 15) [23/04/2002 17:39:26],NA
Testing and debugging of artificial intelligence programs ,NA,NA
"Artificial intelligence programs tend to be big, complicated programs. (If not in this book, in practical applications.) ",NA,NA
So preparing for good testing and debugging is especially important. Standard software engineering techniques for ,NA,NA
"managing large programs (modularity, top-down decomposition, good naming, separate testing of components, and ",NA,NA
"so on) help, but certain other less common techniques are particularly important to artificial intelligence. These are ",NA,NA
summarized in Figure 15-1. ,NA,NA
The gold standard ,NA,NA
"Artificial intelligence programs try to show intelligent behavior. But as we said in Chapter 1, ""intelligence"" is a ",NA,NA
"vague word. So it's often hard to see whether an artificial-intelligence program is working properly. Of course, there ",NA,NA
"are obvious mistakes, like a car repair program that concludes your engine is destroyed when the problem is a flat ",NA,NA
tire. But the less obvious mistakes are more dangerous. ,NA,NA
What is usually done is to define an absolute or ,NA,NA
gold,NA,NA
 standard of behavior against which an artificial-intelligence ,NA,NA
"program can be measured. Often (as for expert systems) a program tries to automate things done by certain humans, ",NA,NA
"so we can just ask these humans whether the program is doing things right. For instance, for auto repair, there are ",NA,NA
"master mechanics; for medical diagnosis, there are doctors that are authorities in their subfield; for scheduling, there ",NA,NA
"are people that schedule all the time, like some secretaries; for finding routes in a city, there are experienced taxi ",NA,NA
"drivers; for solving puzzles, there are expert puzzlers; and for mellowing out, there are California residents. ",NA,NA
"Sometimes there is no single human expert, but different people are expert on different pieces of a problem and we ",NA,NA
"can pool their expertise, as often case with knowledge of how to best accomplish things in a bureaucracy. ",NA,NA
"Unfortunately humans often hate computers, particularly when they are being replaced by computers without ",NA,NA
"compensating rewards, so we must be extremely careful to make the comparison of computer with human behavior a ",NA,NA
fair one. It's important to give the humans and the computers the same problems to work on (perhaps not telling the ,NA,NA
"humans that they will be compared to computers and not telling the computers that they will be compared to humans, ",NA,NA
though computers tend be more broad-minded). Then we compare results and mark any discrepancy as wrong. If our ,NA,NA
"graders don't know themselves which results were by computers and which by humans, only some supervisors then ",NA,NA
we have a ,NA,NA
double-blind,NA,NA
" test, a good form of testing often used in medical research. ",NA,NA
Cases ,NA,NA
"Once a gold standard is established, it is important to test an artificial intelligence system many ways, or against ",NA,NA
many situations. These situations are called ,NA,NA
cases,NA,NA
 or ,NA,NA
test cases,NA,NA
; a set of cases used for testing is called a ,NA,NA
corpus,NA,NA
. The ,NA,NA
"more complicated the program, the more cases we should run. It is important to test a representative spectrum of ",NA,NA
"cases. It is desirable to have at least one test case for each major program behavior, for each significant combination ",NA,NA
"of inputs, and for each significant kind of output. Since this isn't always possible, judgment is required to reach a ",NA,NA
compromise. ,NA,NA
Focusing on bugs ,NA,NA
"Testing performance on a set of cases creates two categories: cases for which the standard and the program agree, ",NA,NA
and cases for which they disagree. The second category is the more interesting one. We can examine these program ,NA,NA
"""failures"", and try to identify characteristics that distinguish them from ""successes"". ",NA,NA
"Several tools can help. A very important one is trace information, the record of reasoning done about a case. Rules ",NA,NA
that appear often in failure cases are suspect. Search problems provide partial traces in their operator-sequence ,NA,NA
"output. But expert systems usually just give a single answer, and can be considerably enhanced with a trace of what ",NA,NA
rules gave the answer. ,NA,NA
"Other useful information is provided by a confusion matrix, something especially helpful with rule-based systems. It ",NA,NA
"summarizes not only when the program went wrong, but how it went wrong. An example is given in Figure 15-2. ",NA,NA
Program results were grouped into categories and cross-tabulated with the gold standard. Rows represent gold-,NA,NA
standard categories and columns represent program-result categories. The entry in row i and column j is the number ,NA,NA
of times the program gave an answer in category j when the standard gave an answer in category i. (We assume that ,NA,NA
"one of these diagnoses is a default, so the program always reaches one of these four diagnoses.) So a confusion matrix ",NA,NA
"shows which categories tend to be confused with which other categories, and suggests where rule ",NA,NA
"improvements are needed. For instance according to Figure 15-2, the ""electrical short"" problem is the most frequently ",NA,NA
"misdiagnosed (only 29 out of 55 cases were correctly recognized), suggesting that more rules for electrical shorts or ",NA,NA
"rules with less restrictive conditions are needed. On the other hand, ""fuel blockage"" is the diagnosis made most ",NA,NA
"frequently misapplied (only 25 out of 45 fuel blockage diagnoses were correct), suggesting that more and stronger ",NA,NA
conditions in its rules are necessary to filter out mistakes. ,NA,NA
Exploiting pairs of similar cases ,NA,NA
Pairs of very similar cases are helpful in testing and debugging of artificial-intelligence programs. They can localize ,NA,NA
problems and provide generalizations. ,NA,NA
"A particularly interesting case pair is when the standard and the program disagree on one case, but agree on a very ",NA,NA
"similar case. In other words, whenever failing cases are ",NA,NA
near misses,NA,NA
 to success. Then the reason for the failure must ,NA,NA
"lie in the small difference in characteristics of the two cases, which helps focus on the source of the bug. For ",NA,NA
"example, suppose we have in a rule-based system: ",NA,NA
"a :- b, c.",NA,NA
Now suppose we test (among others) two cases: case X in which facts ,NA,NA
b,NA,NA
 and ,NA,NA
c,NA,NA
" are true, and case Y in which ",NA,NA
b,NA,NA
", ",NA,NA
c,NA,NA
", and ",NA,NA
d,NA,NA
 are true. Suppose X is a near miss for conclusion ,NA,NA
a,NA,NA
", in that the program (or specifically, this rule) concludes that ",NA,NA
a ,NA,NA
is ,NA,NA
true while the gold standard says that ,NA,NA
a,NA,NA
 is false. The program will also conclude that ,NA,NA
a,NA,NA
" holds in case Y, and assume ",NA,NA
furthermore that the standard agrees. Since facts ,NA,NA
b,NA,NA
 and ,NA,NA
c,NA,NA
" are present in both X and Y, we can guess that the ",NA,NA
d ,NA,NA
fact ,NA,NA
"makes the difference. There are other explanations, but that seems the simplest. So to get a better rule-based system, ",NA,NA
we should rewrite the rule as ,NA,NA
"a :- b, c, d.",NA,NA
"In other words, we figured the original rule was too general, so we fixed it to apply to only one of the two original ",NA,NA
cases. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (2 of 14) [23/04/2002 17:39:29],NA
"Pairs of similar cases can also suggest rule generalizations, a kind of ",NA,NA
learning,NA,NA
. Suppose we have in a rule-based ,NA,NA
system: ,NA,NA
"a :- b, c, d.",NA,NA
"Suppose case Y is as before, with ",NA,NA
b,NA,NA
", ",NA,NA
c,NA,NA
", and ",NA,NA
d,NA,NA
 true. Suppose in case Z that ,NA,NA
b,NA,NA
 and ,NA,NA
d,NA,NA
 are true but ,NA,NA
c,NA,NA
 is false. Suppose the ,NA,NA
gold standard says that Y and Z are both correct cases for conclusion ,NA,NA
a,NA,NA
. Then we can guess that the ,NA,NA
c,NA,NA
" doesn't matter, ",NA,NA
suggesting the rule: ,NA,NA
"a :- b, d.",NA,NA
"This is a riskier change than the previous ""near-miss"" one, because we are generalizing a rule to apply to more cases. ",NA,NA
But it's often reasonable. ,NA,NA
"When the preceding generalization is too strong, we can make weaker changes too. For the appliance application of ",NA,NA
"Chapter 7, we might have written a rule: ",NA,NA
"diagnosis('short in cord') :- askif(device_dead), askif(cord_frayed).",NA,NA
"Suppose we are now told that when there is a frayed cord and the lights just went out, a ""short in cord"" diagnosis ",NA,NA
should also be made. This might suggest ,NA,NA
diagnosis('short in cord') :- askif(cord_frayed).,NA,NA
"But that's not a smart idea, because a frayed cord is only a weak symptom and can also suggest a break in the cord ",NA,NA
"(that is, a nonconducting cord). Instead, we should use a concept covering both dead devices and the lights going ",NA,NA
out: a fuse being blown. That suggests: ,NA,NA
"diagnosis('short in cord') :- diagnosis('fuse blown'), askif(cord_frayed).",NA,NA
Figure 15-3 tabulates some inferences of this sort. Current research is extending these ideas to build rule-based ,NA,NA
"systems automatically from examples and nonexamples (that is, descriptions of situations that are definitely not ",NA,NA
examples of particular concepts)) defining appropriate behavior. This is part of the subfield of ,NA,NA
automatic ,NA,NA
programming,NA,NA
 within artificial intelligence. The issues are hard--just think how hard it is for you yourself to write a ,NA,NA
program. ,NA,NA
Composite results ,NA,NA
"If running an artificial intelligence program gives a result with components, then evaluating the difference between ",NA,NA
"the program and the gold standard is a little more complicated. If the pieces of the result are independent, then the ",NA,NA
"program and standard can be compared separately for each piece, as for a relaxation application in which the result is ",NA,NA
"separate possibility lists for variables. If pieces of the result are linked in a data structure, then structures must be ",NA,NA
"matched to establish corresponding components before comparison, as for a search application in which we must ",NA,NA
"match program operators with the gold standard operators in corresponding order. In either case, only the pieces that ",NA,NA
do not match need be studied further. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (3 of 14) [23/04/2002 17:39:29],NA
Here's an example. Suppose for some search problem the gold standard finds the operator sequence ,NA,NA
"[a,b,c,d,e,f,g,h]",NA,NA
while the program result is ,NA,NA
"[a,b,r,s,d,c,e,f,h]",NA,NA
Three things seem to be different in the program result: additional operators ,NA,NA
r,NA,NA
 and ,NA,NA
s,NA,NA
 have been inserted after action ,NA,NA
b,NA,NA
", operators ",NA,NA
c,NA,NA
 and ,NA,NA
d,NA,NA
" have been interchanged, and operator ",NA,NA
g,NA,NA
 has been omitted. We can thus focus our attention on ,NA,NA
the parts of the search program that affect those things. So we should check the conditions controlling selection of ,NA,NA
r ,NA,NA
and ,NA,NA
s,NA,NA
" to see why they were erroneously fulfilled, and check the conditions on ",NA,NA
g,NA,NA
 to see why it was erroneously ,NA,NA
omitted; the switch of ,NA,NA
c,NA,NA
 and ,NA,NA
d,NA,NA
 suggests a mistake in the priority of those two operators. ,NA,NA
Numbers in comparisons ,NA,NA
"Numbers--probabilities, evaluation functions, and cost functions--complicate comparisons of a program and a gold ",NA,NA
"standard. There are three ways to handle them. First, we can use the numbers to pick a ""best"" program result, and ",NA,NA
"compare this to the gold standard. For a diagnosis expert system that assigns probabilities to diagnoses, we can take ",NA,NA
"the diagnosis with the highest probability; for a search program that finds paths to a goal, we can take the lowest-cost ",NA,NA
"path. Second, we can treat the numbered items as a composite structure as discussed in the last section. For an expert ",NA,NA
system that concludes that diagnoses ,NA,NA
a,NA,NA
", ",NA,NA
b,NA,NA
", ",NA,NA
c,NA,NA
", and ",NA,NA
d,NA,NA
" are probable with probabilities 0.9, 0.7, 0.6, and 0.3 respectively, ",NA,NA
"while a gold standard rates them 0.8, 0.5, 0.6, and 0.2 respectively, we can focus the debugging ",NA,NA
b,NA,NA
 and ,NA,NA
c ,NA,NA
because their ,NA,NA
"numbers are out of order. Third, we can do statistical analyses; for instance, we can take the sum of the square of the ",NA,NA
deviations of the program-result numbers from the gold-standard numbers to measure closeness of the program and ,NA,NA
the standard. We can then quantify any proposed program improvement by this criterion. So it can be used as an ,NA,NA
"evaluation function in a ""search"" for a better program. ",NA,NA
Preventive measures ,NA,NA
"By current estimates an ounce of prevention is worth 1.07 pounds of fixes, so it's important that an artificial-",NA,NA
intelligence programming environment provide software tools to help programmers avoid mistakes in the first place. ,NA,NA
"One big help is predefined expectations about the format of code, as forms or frames in the style of Chapter 12. For ",NA,NA
"rule-based expert systems we can use rule frames, to capture the frequently strong structural similarities between ",NA,NA
"different rules. For instance, rules in a car-repair diagnosis system usually go like this: ",NA,NA
(1) localize the problem in a part of the car; ,NA,NA
(2) ask about easily observable symptoms; ,NA,NA
"(3) if necessary, ask about symptoms that take a little work to establish (like opening up an object); ",NA,NA
"(4) if necessary, ask about experimental actions that need to be done to confirm the diagnosis. ",NA,NA
For example: ,NA,NA
diagnosis('Dead battery') :-,NA,NA
" electrical_problem, lights_dead, not(battery_corroded), battery_voltage_low.",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (4 of 14) [23/04/2002 17:39:29],NA
"A programmer writing a new car-diagnosis rule can be provided with this list of four things as a guide, or warned ",NA,NA
"when departing from this format. Or to be more ambitious, a system could automatically find analogous rules to a ",NA,NA
new rule a programmer wants to write. Inheritance on a hierarchy of rule-class frames is helpful for this. ,NA,NA
Supporting intuitive debugging ,NA,NA
A gold standard of performance for an artificial intelligence program can be hard to get and costly to use. Early in ,NA,NA
"debugging, a more intuitive approach to performance analysis using ",NA,NA
explanation,NA,NA
" facilities is better, and this is ",NA,NA
common in artificial-intelligence development software like expert systems ,NA,NA
packages,NA,NA
 and ,NA,NA
shells,NA,NA
. After running a ,NA,NA
"program, these facilities can report on what your program did, how it reached a particular conclusion, or why it ",NA,NA
considered a particular line of reasoning and not another. Such explanations can be helpful even when the system is ,NA,NA
"fully debugged; they help people understand the system better, use it more effectively, and have more confidence in ",NA,NA
its results. ,NA,NA
The commonest explanation capabilities are for: ,NA,NA
"""How"" questions: questions as to how the program reached a particular final or intermediate ",NA,NA
"conclusion. When the reasoning is simple, a printout of every step will suffice--just the trace ",NA,NA
"information mentioned in Section 15.3. But when reasoning is complicated, this is too much ",NA,NA
"information. For instance, Prolog trace utilities (see Appendix D.12) generally print out information ",NA,NA
"not only on calling a rule and succeeding with it, but on failing and on backtracking to it. (Try tracing ",NA,NA
"the appliance diagnosis program in Section 7.6 or the flashlight diagnosis problem in Section 11.5, if ",NA,NA
"you have tracing facilities in your Prolog dialect, to see the hundreds of reasoning steps done.) So ",NA,NA
partial summary of trace information is usually provided in artificial-intelligence environments and ,NA,NA
"packages. For instance, a ""how"" explanation can list just the ""top-level"" predicates used to reach a ",NA,NA
"conclusion, and then provide the programmer additional details on demand. ",NA,NA
"""How not"" questions: questions as to why something was ",NA,NA
not ,NA,NA
concluded. These arise when ,NA,NA
"expectations are violated, and there are two very different situations. First, reasoning found the ",NA,NA
"conclusion false; then the trace information answers the question. Second, no try was made to prove the ",NA,NA
conclusion; then the program control structure must be studied to determine why different lines of ,NA,NA
"reasoning were pursued instead. For instance, the only rules that could have established the conclusion ",NA,NA
may occur beyond the point where processing went in a sequence of rules. ,NA,NA
"""Why ask"" questions: questions as to what purpose a question to the user serves. These are only ",NA,NA
"appropriate in expert systems that question a user to get data, like the appliance repair program in ",NA,NA
Chapter 7 with its ,NA,NA
ask,NA,NA
" predicate. Instead of answering a question, a user might reply ""Why ask that?"" ",NA,NA
and get a description of a higher-level issue the question will help resolve or a description of what the ,NA,NA
"program is working on. As with ""how"" questions, summarization helps. That is, a user doesn't usually ",NA,NA
want just the issue (rule left side) immediately responsible for the question but the higher-level issues ,NA,NA
too. ,NA,NA
"""Why better"" questions: questions as to why one alternative was judged better than another, when ",NA,NA
"alternatives are ranked by numbers (probabilities, evaluation functions, or cost functions). These are ",NA,NA
hard to answer because they depend on mathematical formulas as well as logical reasoning. One ,NA,NA
"approach is to take the trace record (""how"" information) from two comparable conclusions, eliminate ",NA,NA
"everything identical, and try to find one-to-one correspondences between the remaining ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (5 of 14) [23/04/2002 17:39:29],NA
subconclusions. Explanation can focus on the relative desirability of corresponding subconclusions. ,NA,NA
The hope in providing such information to programmers and users is to permit them to use their own intuitions on ,NA,NA
"cases, comparing their reasoning with what the program did. Often artificial intelligence programs try to formalize ",NA,NA
"human intuition, especially expert systems, so an error by a program can ""leap out"" at the human studying its results. ",NA,NA
Evaluating cooperativeness ,NA,NA
Right answers are not the only criterion we have for evaluating an artificial-intelligence program. We may also care ,NA,NA
"how friendly or cooperative it is, especially if it requires a lot of human interaction. Tools such as questionnaires for ",NA,NA
measuring this are common in organizations that do considerable software development. Some issues to consider: ,NA,NA
--Is the output comprehensible? ,NA,NA
--Does the program use specialized jargon? ,NA,NA
--Can the program paraphrase its questions to the user? ,NA,NA
--Can the program explain its reasoning well? ,NA,NA
--Does the program catch obvious user mistakes? ,NA,NA
--Does the program guess well what the user meant in a mistake? -,NA,NA
-Does the program take what the user says too literally? ,NA,NA
On problems unsuitable for artificial intelligence ,NA,NA
The performance of a program may still be unsatisfactory after a long period of testing and debugging. Despite all ,NA,NA
"the clever things that artificial intelligence techniques can do, they can't solve everything. Sometimes it is hard to ",NA,NA
know in advance whether a problem is suitable. But some guidelines can be given. ,NA,NA
"First, a problem suitable for artificial intelligence techniques must be sufficiently well-defined to have clear criteria ",NA,NA
"for success and failure, just as for any other technical method. Otherwise, you can't tell when it's working, and you ",NA,NA
"can't easily test and debug it. For instance, an expert system could create works of art, but it would be hard to ",NA,NA
"evaluate--there's a lot of disagreement between art ""experts"". ",NA,NA
"Second, the desired program behavior must be sufficiently stable to permit cost-effective testing and debugging. For ",NA,NA
"instance, an expert system to recommend stock-market investments would be hard to build because investment ",NA,NA
"opportunities are constantly changing (""buy low, sell high"" is too general to be useful). ",NA,NA
"Third, it must be possible to use the program routinely. This is obvious but often overlooked. For instance, most ",NA,NA
"military ""battle management"" systems are a bad idea because it is too hard to keep them correctly and quickly ",NA,NA
"informed of everything that is happening in a battle (especially with communications equipment itself under attack), ",NA,NA
though prototype implementations for artificially constructed scenarios might seem to work well. ,NA,NA
"Fourth, an artificial intelligence system must not be reductionist in a dangerous way. As we mentioned in Chapter 1, ",NA,NA
reductionism is the extent to which an artificial intelligence program fails to capture subtleties of human behavior it is ,NA,NA
"trying to imitate. A highly reductionist program may be safe when its users thoroughly understand its limitations, but ",NA,NA
"can be very dangerous otherwise. For instance, a significantly reductionist battle management system could order ",NA,NA
"troops to fire on themselves, or be vulnerable to sabotage in surprising ways. ",NA,NA
"Fifth, artificial intelligence techniques should generally not be used when processing time, storage space, or ",NA,NA
calculation accuracy is critical. The techniques and programs are complicated and often probabilistic or heuristic. A ,NA,NA
"working artificial-intelligence program can often be optimized or compiled to run faster, take up less space, or make ",NA,NA
"more accurate conclusions, but the main idea of artificial intelligence is to provide ""intelligence"" in computers first, ",NA,NA
"efficiency later. So for instance a ""robot warplane"", an autonomous military aircraft controlled by real-time artificial-",NA,NA
"intelligence software, is not likely to work fast enough because things happen too fast in a battle, a large computer ",NA,NA
"imposes a weight penalty on the aircraft, and high accuracy in maneuvers is essential. ",NA,NA
"Sixth, an artificial intelligence program must be sufficiently complicated, but not too complicated, so that artificial ",NA,NA
"intelligence techniques do better than competing approaches. For instance, in spite of Chapter 11, it's a poor idea to ",NA,NA
write a search program to fix flashlights because people can figure it out themselves. But an expert system to replace ,NA,NA
"all doctors isn't reasonable, because there are millions of diseases and millions of symptoms, and just the rule ",NA,NA
"management and indexing problem for such a huge expert system would be mammoth. And, in the United States ",NA,NA
"anyway, a flawed system could be sued for malpractice. ",NA,NA
You must study carefully these criteria before writing an artificial-intelligence program. The criteria are on the ,NA,NA
borderline between the technical and the nontechnical. Should this discourage a programmer from worrying about ,NA,NA
"them? No, not at all. Too often technical people ignore such issues when technical insights about them could be ",NA,NA
invaluable. Insights about artificial intelligence are particularly important today because so few people understand ,NA,NA
"the field--it's hard to learn, as we said in Chapter 1. But as a new area of research compared to other fields of ",NA,NA
"engineering, artificial intelligence has exciting promises for the future, promises generating considerable ",NA,NA
enthusiasm. Now that you have read this book you can help fulfill them. Use your knowledge wisely. ,NA,NA
.SH Keywords: ,NA,NA
case,NA,NA
gold standard,NA,NA
trace information,NA,NA
confusion matrix,NA,NA
near miss,NA,NA
automatic programming,NA,NA
explanation facilities,NA,NA
reductionist,NA,NA
Exercises ,NA,NA
15-1. (A) Give a better gold standard for auto repair than an opinion of an expert mechanic. ,NA,NA
15-2. Suppose we have a backward-chaining rule-based diagnosis system written as Prolog rules. How could we ,NA,NA
modify the rules to automatically provide a trace of rules used along with every diagnosis? ,NA,NA
15-3. (A) Suppose we have a rule-based system like the appliance diagnosis program in Chapter 7 for which the order ,NA,NA
of the rules makes a considerable difference in what conclusion is reached first. Suppose for some diagnosis rule-,NA,NA
"based system, we have the diagnosis rules for two diagnoses in the wrong order. How could a confusion matrix clue ",NA,NA
us that this is the case? ,NA,NA
15-4. Suppose you wanted to construct a rule-based system automatically from examples and nonexamples of its ,NA,NA
"desired behavior, using the ideas of Figure 15-3. The criteria in the Figure only refer to rules. How would you get an ",NA,NA
initial set of rules to work on? ,NA,NA
15-5. Rule R1 is redundant with respect to rule R2 if any conclusion proved by R1 can also be proved by R2 in the ,NA,NA
same circumstances. ,NA,NA
(a) Explain how R1 can have a different left side than R2 even when it is redundant with respect to R2. ,NA,NA
(b) Give a criterion for the redundancy of R1 with respect to R2 that does not require execution of the rules. ,NA,NA
"15-6. (R,A,E) Discuss the overall suitability of artificial intelligence techniques as the ",NA,NA
major ,NA,NA
component in the ,NA,NA
following. ,NA,NA
(a) An automatic car that will accelerate and steer on highways without human assistance. ,NA,NA
(b) A generator of new cooking recipes. ,NA,NA
"(c) A ""seduction advisor"" expert system that advises you how to succeed with members of the opposite sex. ",NA,NA
(d) A system to coordinate defense from nuclear missiles. ,NA,NA
"15-7. (H,P,G) Write a program to automatically build (""learn"") a rule-based system from examples and near misses ",NA,NA
(nonexamples) of left-side predicates. Consider only predicate expressions without variables. Use Figure 15-3 as a ,NA,NA
"guide, and break your problem into the following components: ",NA,NA
"(1) a ""comparer"" that takes two inputs, a set of rules (a list of lists) and a description of some situation ",NA,NA
that is either an example or a near miss (a list of facts). It must compute the differences between the ,NA,NA
"situation and the closest rule, the rule that matches the most facts of the situation. For that rule, it should ",NA,NA
list differences of four kinds: (a) additions (things that must be added to the rule to match a fact of the ,NA,NA
"situation), (b) deletions (things that must be removed from the rule because they have no counterpart in ",NA,NA
"the situation), (c) bindings (variables in a rule that can be matched to a constant argument of the same-",NA,NA
"named predicate in the situation), and (d) substitutions (constant arguments in a rule that can be matched ",NA,NA
to a different constant argument of the same-named predicate in the situation). ,NA,NA
"(2) An ""example handler"" that takes the same two inputs as the comparer. It hands these two ",NA,NA
"arguments immediately to the comparer, obtaining the list of differences of the situation from one ",NA,NA
"particular rule. It then modifies the rule appropriately, or creates a new rule, to cover the situation. ",NA,NA
"This done, the new generalized rule may cover anything handled by another rule, and the other rule ",NA,NA
"can be eliminated. The example handler then returns the new set of rules as its result, together with a ",NA,NA
"""gripe amount"" indicating how happy it was with the rule modifications it made. If more than one ",NA,NA
"modified set of rules seems equally reasonable, the example handler should permit backtracking into ",NA,NA
it. ,NA,NA
"(3) A ""near miss handler"" analogous to the example handler. It should call the comparer, get back a set ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (8 of 14) [23/04/2002 17:39:29],NA
"of differences between a near miss situation and a rule, and modify (specialize) the rule appropriately ",NA,NA
so it won't apply to the situation. It should check that its changes don't cause contradictions among the ,NA,NA
"rules. Like the example handler, it should return a new set of rules with a ""gripe amount"", and should ",NA,NA
give further answers (if any seem good) on backtracking. ,NA,NA
"(4) A ""top-level searcher"" that supplies examples and near misses to the rest of the system, searching ",NA,NA
"over all possible permutations in the order of supplying them. There's a good cost function in the ""gripe ",NA,NA
"amounts"" returned by the example and near miss handlers, and there's a good evaluation function in the ",NA,NA
"number of rules plus the number of constants in rules. (Fewer rules means better generalization, and ",NA,NA
fewer constants mean more generality in rule application). This should use the A* program of Chapter ,NA,NA
"10, defining the successor function to call the example handler or near miss handler depending on ",NA,NA
whether the next situation chosen is marked as an example or a near miss. ,NA,NA
Try learning rules for some simple diagnosis expert system. ,NA,NA
Miscellaneous exercises covering the entire book ,NA,NA
"M-1. (A) Backtracking is important in some very different areas of artificial intelligence. For each of the following, ",NA,NA
"say ""yes"" or ""no"" as to whether backtracking is usually necessary to implement them. (All these might use ",NA,NA
"backtracking in Prolog implementations, but which need backtracking no matter what language they are implemented ",NA,NA
"in?) By ""backtracking"" we mean returning to a processing state from which the current processing state is reachable. ",NA,NA
(a) backward chaining ,NA,NA
(b) forward chaining ,NA,NA
(c) best-first search ,NA,NA
(d) answering long queries efficiently by exploiting dependencies ,NA,NA
(e) slot inheritance ,NA,NA
(f) resolution among members of a set of clauses without variables ,NA,NA
M-2. Lattices (directed graphs without cycles) are important in many different ways in artificial intelligence. They're ,NA,NA
"important not only as a data structure inside the computer, but as a way of explaining what the computer is doing. ",NA,NA
Explain in 40 words or less what they are useful for in each of the following areas. ,NA,NA
(a) search ,NA,NA
(b) frames ,NA,NA
"(c) compiled rule-based systems, in a way different from uncompiled rule-based systems ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (9 of 14) [23/04/2002 17:39:29],NA
(d) resolution theorem-proving ,NA,NA
"M-3. (R,A) Give the letter for the best match to each item in the first list from the choices in the second list. Each ",NA,NA
item should be matched to one and only one item. (Hint: doublecheck your answers by re-solving from bottom to ,NA,NA
"top, and then by matching the second list to the first list.) ",NA,NA
Horn clause ,NA,NA
generate-and-test ,NA,NA
constraint ,NA,NA
forward chaining ,NA,NA
default ,NA,NA
depth-first control structure ,NA,NA
intension ,NA,NA
difference table ,NA,NA
near miss ,NA,NA
Skolem function ,NA,NA
caching ,NA,NA
dependency ,NA,NA
multiple inheritance ,NA,NA
decision lattice ,NA,NA
Bayes's Rule ,NA,NA
heuristic ,NA,NA
hierarchical reasoning ,NA,NA
agenda,NA,NA
a. a way of reusing results ,NA,NA
b. a weak general-purpose rule or fact ,NA,NA
c. contradictory reasoning is a danger ,NA,NA
d. a theorem ,NA,NA
e. example: prefer investigating further the last thing discovered ,NA,NA
"f. ""or"" with ""not"" in front of every expression but one ",NA,NA
g. a fast implementation of rule-based systems ,NA,NA
h. recommends an operator ,NA,NA
i. example: the Prolog query ,NA,NA
"?- a(X), b(X), c(X).",NA,NA
j. used for existential quantifiers ,NA,NA
k. lists candidates ,NA,NA
l. a description of means-ends analysis ,NA,NA
m. a predicate expression ,NA,NA
n. valuable in debugging all artificial intelligence systems o. ,NA,NA
reasoning about implications of facts ,NA,NA
p. the abstract meaning of something ,NA,NA
q. requires a stack ,NA,NA
r. when two predicate expressions have some of the same variables,NA,NA
"M-4. (R,A) Consider an expert system built to advise Americans which income tax forms and schedules to fill out. ",NA,NA
"There are different ways satisfying the laws, and some are better for the taxpayer than others. (It matters how much a ",NA,NA
taxpayer earns and how much of their income is of a certain type. The taxpayer wants the possibility that costs the ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (10 of 14) [23/04/2002 17:39:29],NA
"least money.) Using answers to some simple questions, an expert system could make recommendations without ",NA,NA
having to ask for a complete financial history. But its conclusions will be necessarily imperfect without such ,NA,NA
complete information. ,NA,NA
(a) Which of the following techniques is most appropriate for this problem? Explain why. ,NA,NA
1. and-or-not lattice ,NA,NA
2. dependency-based backtracking ,NA,NA
3. confusion-matrix conflict-resolution ,NA,NA
4. breadth-first resolution strategy ,NA,NA
(b) Which of the following techniques is ,NA,NA
least,NA,NA
 useful for this problem? Explain why not. ,NA,NA
1. virtual facts ,NA,NA
2. inference ,NA,NA
3. depth-first control structure ,NA,NA
4. concurrency ,NA,NA
(c) Which of the following Prolog features is ,NA,NA
least,NA,NA
 useful in implementing an expert system in Prolog for this ,NA,NA
problem? Explain. ,NA,NA
(a) ,NA,NA
asserta,NA,NA
 or ,NA,NA
assertz ,NA,NA
(b) ,NA,NA
repeat ,NA,NA
(c) ,NA,NA
write ,NA,NA
(d) ,NA,NA
>,NA,NA
 [greater-than sign] ,NA,NA
M-5. (A) Consider the problem of foot placement for a 6-legged robot. Suppose the robot has a vision system that ,NA,NA
studies the ground in terms of squares one square meter in area. For each such square the vision system (which you ,NA,NA
don't need to consider) decides whether that square is a good one to place a leg on. Suppose only 20 percent of the ,NA,NA
"squares are suitable on the average, and suppose the robot can only extend its legs a certain distance forward. ",NA,NA
"Suppose the vision system only examines squares within a rectangle centered in front of the robot, extending from ",NA,NA
"the front of the robot to ten meters ahead, and ten meters off to the left, and ten meters off to the right. Consider the ",NA,NA
"problem of how to use that information to plan a good sequence of foot placements to the centers of squares, ",NA,NA
keeping the robot moving ahead in an approximately straight line. The robot is not in a hurry but it doesn't want to ,NA,NA
ever back up. ,NA,NA
(a) Explain which of these search strategies is best for this problem and why. ,NA,NA
1. best-first search ,NA,NA
2. weight-first search ,NA,NA
3. breadth-first search ,NA,NA
4. branch-and-bound search ,NA,NA
(b) Which of the following are also helpful in step planning? Explain why. ,NA,NA
1. means-ends analysis ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (11 of 14) [23/04/2002 17:39:29],NA
2. caching ,NA,NA
3. both generate-and-test and caching ,NA,NA
(c) Which of the following Prolog features is ,NA,NA
least,NA,NA
 useful for implementing this step-planning (not the vision ,NA,NA
system) in Prolog? Explain why. ,NA,NA
1. ,NA,NA
is ,NA,NA
2. ,NA,NA
assertz,NA,NA
 (as opposed to ,NA,NA
asserta,NA,NA
) ,NA,NA
3. ,NA,NA
cut,NA,NA
 (!) ,NA,NA
4. ,NA,NA
repeat,NA,NA
M-6. Many artificial intelligence applications require representation of causation. Suppose we use the Prolog ,NA,NA
predicate ,NA,NA
"causes(X,Y)",NA,NA
", where ",NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 are names of events such that event ,NA,NA
X,NA,NA
 causes event ,NA,NA
Y,NA,NA
 to happen. ,NA,NA
X,NA,NA
 is ,NA,NA
assumed to be sufficient for ,NA,NA
Y,NA,NA
 to happen (so that any time ,NA,NA
X,NA,NA
 happens ,NA,NA
Y,NA,NA
" must necessarily happen too), but ",NA,NA
X,NA,NA
 is not ,NA,NA
necessary for ,NA,NA
Y,NA,NA
 to happen (,NA,NA
Y,NA,NA
 may have other causes). ,NA,NA
(a) Is ,NA,NA
causes,NA,NA
 transitive? Explain. ,NA,NA
(b) Does ,NA,NA
causes,NA,NA
 inherit with respect to ,NA,NA
part_of,NA,NA
"? If so, in which direction? Explain. ",NA,NA
"(c) Consider an alternative representation of causation in Prolog as a rule with the """,NA,NA
:-,NA,NA
""" symbol. For example: ",NA,NA
event(lights_come_on) :- event(turn_wall_switch_to_on).,NA,NA
or better yet: ,NA,NA
"event(lights_come_on) :- event(turn_wall_switch_to_on),",NA,NA
" not(bulbs_burned_out), not(wiring_defective), not(switch_broken).",NA,NA
But give a major disadvantage of representing causation this way as a rule instead of with ,NA,NA
"causes(X,Y)",NA,NA
 facts. (Give a ,NA,NA
"""deep"" problem; don't consider efficiency.) ",NA,NA
"M-7. (E) The conjunctions ""and"" and ""or"" are very important in artificial intelligence. Consider the conjunction ",NA,NA
"""but"". ",NA,NA
"(a) Suppose we let experts building an expert system use the word ""but"" in writing rules. How should we translate it ",NA,NA
into something a programming language like Prolog can handle? Be sure your answer covers most of the usual ,NA,NA
"meaning of ""but"". ",NA,NA
(b) Vocabulary variety makes computer output more comfortable for humans. Discuss when a computer could use ,NA,NA
"""but"" in natural language output from a program. In particular, consider a query-answering program. Compare with ",NA,NA
your answer to part (a). ,NA,NA
"(c) Would a ""but"" feature, in addition to ""and"" and ""or"", be useful in a logic programming language like Prolog? ",NA,NA
M-8. (E) Discuss the possible application of artificial intelligence techniques to the following two problems: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (12 of 14) [23/04/2002 17:39:29],NA
(a) You are in a submarine and have various sensors. You want to guess the identity of all moving ,NA,NA
objects up to the limits of your sensor range. ,NA,NA
"(b) You are positioning army units for a possible battle. You have various kinds of personnel, and ",NA,NA
various kinds of weapons. You want to position units and equipment in a way that gives you the most ,NA,NA
tactical advantage. ,NA,NA
"For each problem, discuss which of the following specific techniques apply: ",NA,NA
"automatic backtracking, generate-and-test, inheritance, defaults, rule-based systems, backward ",NA,NA
"chaining, forward chaining, fixed-order conflict resolution, focus-of-attention conflict resolution, ",NA,NA
"probabilities, depth-first search, breadth-first search, best-first search, A* search, means-ends analysis, ",NA,NA
"frames, relaxation, dependency-based backtracking, resolution ",NA,NA
"M-9. (H,E) Consider the problem of building an automatic ""commercial censor"" system that will determine when a ",NA,NA
"television is receiving a commercial, and will turn off the audio and video until the commercial is finished. (This ",NA,NA
would be nice when videotaping.) 95% accuracy within two seconds after a commercial starts or ends is desired. In ,NA,NA
"addition to the frequency analyzer and the low-level vision processor mentioned, assume you have a fast computer ",NA,NA
with one million bytes of random-access memory and ten million bytes of disk storage. Conduct experiments ,NA,NA
(involving observation of at least 200 commercials) with a real television to help answer the following questions. An ,NA,NA
adequate answer to this problem will be 2000 words total. ,NA,NA
(a) Categorize clues available from processing of the audio signal. Assume frequency-spectrum calculation ,NA,NA
"hardware (technically, a discrete Fourier transform processor) is available. ",NA,NA
(b) Categorize clues available from processing of the video signal. Assume a low-level vision processor (that groups ,NA,NA
"homogeneous two-dimensional regions of a single picture, and calculates their average brightness and color, but ",NA,NA
slowly). ,NA,NA
(c) Categorize clues available from correlation of the results of parts (a) and (b) with an accurate clock connected to ,NA,NA
the system. ,NA,NA
(d) Describe a good control structure (or control structures) for an artificial intelligence system to do this job. Be ,NA,NA
"sure to include whether backward, forward, or hybrid chaining is desirable; and whether depth-first, breadth-first, ",NA,NA
"best-first, or A* searching is desirable. ",NA,NA
(e) Suggest good uncertainty combination methods for such an artificial intelligence system. Are numbers a good ,NA,NA
"idea? In particular, suppose each clue from parts (a), (b), and (c) is summarized by a single probability: how would ",NA,NA
you combine these three? ,NA,NA
"(f) Where might learning techniques help to automatically improve system performance with time? In particular, ",NA,NA
discuss how learning from examples can be done. Describe exactly what is learned: how it would be represented in ,NA,NA
"the computer, how it would be modified upon new data, and so on. Remember, artificial intelligence methods are ",NA,NA
"mostly nonnumeric, so your learning must be mostly nonnumeric. ",NA,NA
"(g) Describe how you would fairly validate the 95% accuracy claim. When would you run the system, how long, and ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (13 of 14) [23/04/2002 17:39:29],NA
how many times? Run some simple (not necessarily thorough) tests on a real television of some of the ideas you've ,NA,NA
developed previously. Explain how you could also use these testing procedures in debugging. ,NA,NA
"Some hints: often students are too superficial in their answers to essay questions like these, so err on the side of ",NA,NA
writing too much rather than writing too little. Don't give definitions of terms and other things that are easy to look ,NA,NA
up. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/chap15.html (14 of 14) [23/04/2002 17:39:29],NA
Appendix A: Basics of logic ,NA,NA
Logic is the study of things that are either true or false and never anything in between. Such things are ,NA,NA
called ,NA,NA
propositions,NA,NA
 or ,NA,NA
statements,NA,NA
. Propositions can be combined to form more complex propositions ,NA,NA
"using ""and"", ""or"", and ""not"". The ""and"" of some propositions is true if each is true; the ""or"" of some ",NA,NA
"propositions is true if one or more are true; and the ""not"" of a proposition is true if the proposition is ",NA,NA
"false. Otherwise, the result is false. Figure A-1 summarizes these three operations for simple cases; ",NA,NA
together they define the ,NA,NA
propositional calculus,NA,NA
. ,NA,NA
"Other operations can be built from these three. For instance, logical implication: A implies B if whenever ",NA,NA
"A is true, B is true too. It's usually interpreted to mean (see discussion in Section 14.2) that this can only ",NA,NA
"be false when A is true and B is false, so an equivalent proposition is ""B or not A"". ",NA,NA
"The ""and"", ""or"", and ""not"" operations obey some of the same laws as arithmetic operations. Order in an ",NA,NA
"""and"" or ""or"" doesn't matter, and you can do the operations in pieces, so ""and"" and ""or"" are commutative ",NA,NA
"and associative. ""And"" is distributive with respect to ""or"", and vice versa: ",NA,NA
A and (B or C) equals (A and B) or (A and C) ,NA,NA
A or (B and C) equals (A or B) and (A or C) ,NA,NA
"This means that we can always ""factor out"" repeated propositions, or ""factor in"" a single proposition, and ",NA,NA
"have an equivalent form. You can do this more than once for complex proposition, as for instance ",NA,NA
(A and B) or (C and D) equals ((A and B) or C) and ((A and B) or D) ,NA,NA
equals (A or C) and (B or C) and (A or D) and (B or D) ,NA,NA
A ,NA,NA
literal,NA,NA
" is either a simple proposition (no ""and""s, ""or""s, or ""not""s in its description) or the ""not"" of a ",NA,NA
"single simple proposition. Then by repeated application of the distributive law, you can always convert ",NA,NA
"any complex proposition to an ""or"", each item of which is an ""and"" of literals; this is ",NA,NA
disjunctive normal ,NA,NA
form,NA,NA
", and it looks like this: ",NA,NA
(A and B and...) or (C and D and ...) or (E and F and ...) or ... ,NA,NA
"By repeated application of distributivity in just the opposite way, you can always get an ""and"" each item ",NA,NA
"of which is an ""or"" of literals. This is ",NA,NA
conjunctive normal form,NA,NA
", and it looks like this: ",NA,NA
(A or B or ...) and (C or D or ...) and (E or F or ...) and ... ,NA,NA
"where A, B, C, etc. are literals. Conjunctive normal form is easier to use in Prolog, and is especially ",NA,NA
"important for the resolution methods in Chapter 14 of this book. In putting expressions into normal form, ",NA,NA
these simplifications help: ,NA,NA
A and A equals A ,NA,NA
A or A equals A ,NA,NA
A and (not A) equals false ,NA,NA
A or (not A) equals true ,NA,NA
A and true equals A ,NA,NA
A and false equals false ,NA,NA
A or true equals true ,NA,NA
A or false equals A ,NA,NA
(not true) equals false ,NA,NA
(not false) equals true ,NA,NA
Here are four important examples: ,NA,NA
A and (not(A) or B) equals (A and not(A)) or (A and B) equals A and B ,NA,NA
A and (A or B) equals (A or false) and (A or B) equals A or (false and B) equals A ,NA,NA
A or (not(A) and B) equals (A or not(A)) and (A or B) equals A or B ,NA,NA
A or (A and B) equals (A and true) or (A and B) equals A and (true or B) equals A ,NA,NA
"Distributivity does not hold for ""not""s with respect to ""and""s and ""or""s. But two related formulas hold ",NA,NA
(DeMorgan's Laws): ,NA,NA
not(A and B) equals (not A) or (not B) ,NA,NA
not(A or B) equals (not A) and (not B) ,NA,NA
And ,NA,NA
not(not(A)) equals A ,NA,NA
"hence two important relationships between ""and"" and ""or"": ",NA,NA
not(not A and not B) equals not(not A) or not(not B) equals A or B ,NA,NA
not(not A or not B) equals not(not A) and not(not B) equals A and B ,NA,NA
"""And""s, ""or""s, and ""not""s can be represented graphically with the standard gate symbols used in hardware ",NA,NA
design (see Figure A-2). Such a ,NA,NA
logic gate,NA,NA
 display can help you see patterns you wouldn't see otherwise. ,NA,NA
"The left sides of the gates in the figure represent inputs (operands), and the right sides outputs (operation ",NA,NA
"results). In such designs, it is usually assumed that lines crossing do not connect unless a there is a black ",NA,NA
dot at the crossing. Venn diagrams are another useful graphic representation; see Section 8.3. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/aa.html (2 of 3) [23/04/2002 17:39:30],NA
So far we have only ,NA,NA
propositional logic,NA,NA
 or the ,NA,NA
propositional calculus,NA,NA
. If we let propositions have ,NA,NA
"variables, we get a more powerful kind of logic called ",NA,NA
predicate logic,NA,NA
 or the ,NA,NA
predicate calculus,NA,NA
. We ,NA,NA
"extensively illustrate predicate logic by example in this book, so we won't say much here, but it is ",NA,NA
important to explain the key feature of ,NA,NA
quantification,NA,NA
. If some predicate expression is true for any value ,NA,NA
"of an included variable X, then that the expression is ",NA,NA
universally quantified,NA,NA
 with respect to X. Another ,NA,NA
way of saying it is that the expression holds for every X. If an expression is true for some (but not ,NA,NA
"necessarily all) values of an included variable X, then it is ",NA,NA
existentially quantified,NA,NA
 with respect to X. ,NA,NA
Alternatively we can say that there exists an X such that the expression is true. ,NA,NA
"Universal quantification has more practical applications than existential quantification, so we will refer to ",NA,NA
"it more. Some additional laws of logic cover universal and existential quantification, but only two are ",NA,NA
particularly important in this book: ,NA,NA
"the ""not"" of something existentially quantified is equivalent to the universal quantification ",NA,NA
of the negation of that something; ,NA,NA
"the ""not"" of something universally quantified is equivalent to the existential quantification ",NA,NA
of the negation of that something; ,NA,NA
"As an example, suppose an appliance works properly. Then you can say that there does not exist a ",NA,NA
component X of the appliance such that X is faulty. But that is equivalent to saying that for every ,NA,NA
"component X of the appliance, that component is not faulty. ",NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/aa.html (3 of 3) [23/04/2002 17:39:30],NA
Appendix B: Basics of recursion ,NA,NA
Recursion is a valuable computer programming technique. It's a way to get a computer to do something ,NA,NA
"over and over again. Recursion is tricky to understand at first, but once you get comfortable with it, it's ",NA,NA
easier and safer to program with recursion than with iterative techniques. We especially emphasize ,NA,NA
recursion in this book because Prolog has a natural affinity for it. ,NA,NA
"Recursion is a named piece of a program referring to itself. Why do this? Typically, to describe a task or ",NA,NA
"job in the simplest possible way. A good way to explain a complicated job is to break it into components, ",NA,NA
"and that's simplest when those components are the same sort of job. For this to work, we need to ",NA,NA
"guarantee two things: first, that the new jobs are simpler than the old (for otherwise we wouldn't ",NA,NA
"progress); and second, that by decomposition we'll eventually reach ""easy"" jobs that we can solve quickly ",NA,NA
without further decomposition. The easy jobs are called the ,NA,NA
basis,NA,NA
" of a recursion, and the decomposition ",NA,NA
into similar subjobs is called the ,NA,NA
induction,NA,NA
 of a recursion. (Recursion is closely related to a mathematical ,NA,NA
proof technique called ,NA,NA
mathematical induction,NA,NA
", and that's where the terms come from.) ",NA,NA
"Here's an example (see Figure B-1). Suppose we have employee salaries in our computer, and we want to ",NA,NA
add 1000 to every one of them. Consider the easiest possible case (basis case) first. That's when there's ,NA,NA
"only one salary, so we just add 1000 to it and store it. But suppose we have 732 salaries. One way to ",NA,NA
"decompose the job (shown in the top diagram in Figure B-1) would be to add 1000 to the first salary, then ",NA,NA
"establish a new job to add 1000 to the other 731 numbers. That new job isn't much simpler, but 731 ",NA,NA
is,NA,NA
 less ,NA,NA
than 732 so it is simpler. There are other ways to decompose the job too. For instance (as shown in the ,NA,NA
"bottom diagram in Figure B-1), we can divide the job into equal halves: subjobs of adding 1000 to the ",NA,NA
first 366 items and adding 1000 to the last 366 items. Each subjob is the same sort of job as the original. ,NA,NA
Note that successful recursion just requires that the new jobs be smaller than the original job; it doesn't ,NA,NA
matter how many new jobs there are. ,NA,NA
"A recursion can have more than one basis step. For the previous example, a second basis step could ",NA,NA
"handle two-item lists, so we wouldn't have to always decompose jobs to single-item lists eventually. In ",NA,NA
"Prolog, basis conditions can be either facts (see Chapter 2) or rules (see Chapter 4), but induction ",NA,NA
conditions are always rules. Note that the first of the two decomposition methods in the last paragraph ,NA,NA
"(binary decomposition in which one part is size 1) is the most common kind of recursive decomposition, ",NA,NA
because it's easy to implement despite the apparent inefficiency of its extreme uneveness of ,NA,NA
decomposition. ,NA,NA
"If you are having trouble understanding recursion, you should study some simple recursive programs and ",NA,NA
try to apply their form to new situations. The simplest form of recursion is ,NA,NA
tail recursion,NA,NA
", in which there is ",NA,NA
"only one induction (recursion) case, an extreme uneven decomposition, and its recursive call occurs last in ",NA,NA
the program. The first of the two ways to update 732 salaries is a natural application for tail recursion. ,NA,NA
"Tail recursion is the commonest form of recursion, and has the advantage that it is easy to ",NA,NA
"convert to iteration: the recursive call is like a branch or ""goto"" at the end of a loop. Recursive programs ",NA,NA
"tend to be a little slower than their equivalent iterative counterparts, so that is one reason to convert them ",NA,NA
"(though the recursive versions tend to be easier to understand). However, any recursion with more than ",NA,NA
"one recursive (self-) reference is hard to convert to iteration, like the second (even-split) way of updating ",NA,NA
"732 salaries, or the means-ends analysis program in Chapter 11. ",NA,NA
"Recursion can define functions (in the mathematical sense) as well as subroutines. For instance, suppose ",NA,NA
the job is to compute the sum of 732 employee salaries (see Figure B-2). The basis case is when there is ,NA,NA
"only one number, and the sum is that number. The induction case is when there are N numbers, N > 1; ",NA,NA
let's use tail recursion for it. That means we recursively decompose this problem into a job to find the ,NA,NA
"sum of all but the first of numbers, and add to first number this total. So each level of recursion returns a ",NA,NA
value to the next highest level. ,NA,NA
Chapters 4 and 5 introduce recursive programs in Prolog. One word of advice: students often have ,NA,NA
trouble with recursion because they worry too much about what the program is does during execution. ,NA,NA
"You can usually follow the first recursive call, and maybe the second, but after that it gets confusing ",NA,NA
"because it's hard to see where to ""go back to"" when one recursive call concludes. Human brains just ",NA,NA
aren't as well equipped as computers for this sort of reasoning. So stick to the ,NA,NA
declarative,NA,NA
 or ,NA,NA
logical-truth ,NA,NA
"description of recursion used in this Appendix. Then if your recursive program doesn't work right, use ",NA,NA
the following checklist: ,NA,NA
1. Do the cases meant to be handled by basis conditions work right? ,NA,NA
2. Do the basis conditions cover ,NA,NA
all,NA,NA
 the easy cases that might occur through recursive ,NA,NA
decomposition? ,NA,NA
3. Does the recursive decomposition really decompose the problem into ,NA,NA
simpler ,NA,NA
subproblems? (How many doesn't matter.) ,NA,NA
"4. If the recursive program has arguments, are the arguments in the recursive calls ",NA,NA
correctly different from the arguments at the top of the program? ,NA,NA
Usually one of these things will be at fault if a recursive program is not working. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ab.html (2 of 2) [23/04/2002 17:39:31],NA
Appendix C: Basics of data structures ,NA,NA
Data structures are ways of storing things inside a computer. The efficiency of an artificial intelligence ,NA,NA
program can be affected a good deal by the choices made for its data structures. We summarize the main ,NA,NA
kinds in Figure C-1. The many books on this subject provide further information. ,NA,NA
Basic data structures are ways of storing small single items of data. Programming languages typically ,NA,NA
provide as basic data structures (or ,NA,NA
data types,NA,NA
") integers, real numbers (in floating point notation), ",NA,NA
"characters(alphanumeric), and bits (things that can be either true or false). Some programming languages ",NA,NA
also have pointers (actual memory addresses). ,NA,NA
The simplest of composite data structures is the ,NA,NA
array,NA,NA
. It's just a group of data items stored in successive ,NA,NA
locations in computer memory. The data items can be any of the aforementioned basic types. So we can ,NA,NA
speak of an ,NA,NA
integer array,NA,NA
", a ",NA,NA
real array,NA,NA
 or a ,NA,NA
character array,NA,NA
; the last is usually called a ,NA,NA
string,NA,NA
. To find the ,NA,NA
data item in the Kth position in a plain (,NA,NA
one-dimensional,NA,NA
") array, you give the ",NA,NA
index,NA,NA
 K. For a ,NA,NA
two-,NA,NA
dimensional,NA,NA
" array, you give two numbers, a ",NA,NA
row,NA,NA
 and ,NA,NA
column,NA,NA
 for a data item. Use of an array requires the ,NA,NA
start of the array and the length of each dimension. ,NA,NA
But arrays are a poor data structure when you must frequently change the data. The ,NA,NA
linked lists,NA,NA
", often ",NA,NA
called just ,NA,NA
lists,NA,NA
", are better. Linked lists store sequences of data items like arrays do, but the items do not ",NA,NA
have to be in successive locations in computer memory; each is paired with a pointer giving the memory ,NA,NA
"location of the next data item in sequence, with the last data item in the list having a special pointer called ",NA,NA
nil,NA,NA
". So a list can be scattered around in computer memory, provided you keep item-pointer pairs together ",NA,NA
and store the location of the first data item. Linked lists need more space to store data items than an array ,NA,NA
"would, but allow more flexibility in the use of computer memory. Lists are more common in artificial-",NA,NA
"intelligence programming than arrays, and in fact the programming language Lisp is built entirely around ",NA,NA
lists: lists even represent programs in Lisp. ,NA,NA
Several common data structures are special cases of arrays and lists. If you only insert and delete items at ,NA,NA
"the very end of an array or list, then you have a ",NA,NA
stack,NA,NA
 data structure. Stacks are essential for managing ,NA,NA
"procedure calls and recursion in programming languages, though their operation is usually hidden from ",NA,NA
the user; such stacks contain pointers to memory locations of program pieces. If you only delete items at ,NA,NA
"the very front of an array or list, and only insert items at the very end, then you have a ",NA,NA
queue,NA,NA
 data ,NA,NA
"structure. Queues are used when you want to be ""fair"" to data items and want the data item that has been ",NA,NA
"in the array or list the longest to be the first removed. So queues are first in, first out. Analogously stacks ",NA,NA
"are last in, first out. ",NA,NA
Arrays and lists order their items. An unordered set can be stored as an array or list in some random ,NA,NA
"order, but there is an alternative. If data items can take on one of N data values--as for instance, data ",NA,NA
"items for ages of employees in years, which must be positive integers less than 100--then we can ",NA,NA
represent sets as an N-element ,NA,NA
bit array,NA,NA
" (an array whose data items are bits) where a ""true"" in location K ",NA,NA
of the array means that the Kth possible is present in the set. Bit arrays can make set operations like ,NA,NA
"intersection run very fast, and many computers have bit-handling instructions to speed things even more. ",NA,NA
"Data structures can arrange data in more complicated ways too. For instance, consider as data items the ",NA,NA
"names of procedures, and suppose we want to represent how those procedures call one another in a ",NA,NA
nonrecursive program in which every procedure is called only once (e.g. Figure 7-3). A procedure can ,NA,NA
"call several others, and each of those can call several others, and so on. This sort of branching data ",NA,NA
structure is called a ,NA,NA
tree,NA,NA
. ,NA,NA
Binary trees,NA,NA
 are those for which every data item has one branch entering and ,NA,NA
either two or zero branches leaving; they're the most common kind of tree. A tree is usually stored in ,NA,NA
"computer memory as an array of subarrays, each subarray holding a data value and pointers to records of ",NA,NA
other data items that are linked from it. Trees are useful whenever there are hierarchies or taxonomies in ,NA,NA
"the data. Trees can also be built as an index to sequential data, when you want to be able to find things ",NA,NA
fast (,NA,NA
search trees,NA,NA
). Trees can be implemented in a list-processing language like Lisp by embedding lists ,NA,NA
within lists; the same thing can be done in Prolog. ,NA,NA
"If the branches of a tree can join together, then technically you don't have a tree but a ",NA,NA
lattice,NA,NA
. Lattices and ,NA,NA
"trees can be implemented the same way, and they are often confused. Lattices occur often in computer ",NA,NA
"science. For instance, if the same procedure is used in several different places in a program, the hierarchy ",NA,NA
"of procedures can be represented as a lattice. In general, lattices arise whenever you have partial ",NA,NA
"information about ordering of things, but not complete ordering information. ",NA,NA
If your data structure has loops so that you can return to some data item by following a sequence of ,NA,NA
"pointers from it, then technically you have a ",NA,NA
directed graph,NA,NA
", often just called a ",NA,NA
graph,NA,NA
. Graphs are good at ,NA,NA
"modeling arbitrary connections between things. You can implement graphs like trees, as arrays of ",NA,NA
subarrays containing pointers to other records. Another way is to extend a bit array to a ,NA,NA
bit matrix,NA,NA
: for N ,NA,NA
"possible data items, create on N by N matrix of bits so that the entry in row I and column J of this matrix ",NA,NA
is true if and only if there is a connection from data entry in row I to data item J in the graph. Some ,NA,NA
"graphs require that you store data for each connection, not just for each data item, and for these graphs ",NA,NA
you can use a matrix but store data other than bits in it. Matrix array implementations are good whenever ,NA,NA
there are many connections between relatively few data items. ,NA,NA
Still more complex data structures can be made by combining the aforementioned ones in various ways. ,NA,NA
"Data items can themselves be data structures; for instance, data items representing English words can be ",NA,NA
"character arrays. Lists can be items of lists themselves, and such ",NA,NA
embedded lists,NA,NA
 are used extensively in ,NA,NA
"the language Lisp. If you want to represent a graph in Lisp, you can use a list of lists where each sublist ",NA,NA
contains a data item value followed by a list of pointers. And all the standard list processing of Lisp can ,NA,NA
be done analogously in Prolog. (But a word of warning: Lisp uses parentheses to denote lists while ,NA,NA
Prolog uses brackets.) ,NA,NA
Recursion (see Appendix B) is useful for manipulating all these data structures. Lists and arrays suggest ,NA,NA
"tail recursion in the form of a single basis case followed by a single induction case, where the basis case ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ac.html (2 of 3) [23/04/2002 17:39:32],NA
"concerns a single-item array or list, and the induction case decomposes the problem by eliminating a ",NA,NA
"single item from the list or array. Trees, lattices, graphs, and embedded data structures require more ",NA,NA
complicated forms of recursion involving either multiple induction cases or multiple recursive ,NA,NA
procedures. Data structures books provide classic recursive algorithms for all these things and they ,NA,NA
should be consulted for most simple needs instead of your trying to write programs yourself. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ac.html (3 of 3) [23/04/2002 17:39:32],NA
Appendix D: Summary of the Prolog dialect used in ,NA,NA
this book ,NA,NA
"The Prolog examples in this book use a subset of the ""core Prolog"" or ""standard Prolog"" originally ",NA,NA
developed in several implementations at Edinburgh University and covered in W.F. Clocksin and C.S. ,NA,NA
"Mellish, ",NA,NA
Programming in Prolog,NA,NA
", second edition, Springer-Verlag, 1984. Substantially similar dialects are ",NA,NA
"provided for many computers, and include Quintus Prolog, Logicware MPROLOG, DEC-10 Prolog, and ",NA,NA
C-Prolog. (Programs in this book were tested in Edinburgh C-Prolog on a DEC VAX-780.) Borland ,NA,NA
"International Turbo Prolog is close to this standard, but doesn't support treating rules as data (Section D.8) ",NA,NA
and has some other differences. Micro-Prolog has major differences; see Appendix E. For compatibility ,NA,NA
"with these dialects and easy comprehension by the reader, the Prolog subset of this book omits many ",NA,NA
"common and useful features, including other arithmetic operations, input and output, structures (as ",NA,NA
"opposed to embedded lists), functors, modules, and many debugging tools; see the Prolog books in ",NA,NA
Appendix F for information about these. ,NA,NA
This Appendix is summarized in Figure D-1. ,NA,NA
D.1 Managing facts and rules ,NA,NA
We assume Prolog programs (consisting of rules and facts) are written outside of the Prolog interpreter. ,NA,NA
You use your favorite editor to create a text file containing them. Then you start up the Prolog interpreter ,NA,NA
(how to do this is implementation-dependent) and load in the files you want by querying ,NA,NA
consult,NA,NA
", whose ",NA,NA
"one argument is the name of the editor-created file you want to load. If you have several files to load, do ",NA,NA
consult,NA,NA
 several times. ,NA,NA
"To list all the facts and rules in the Prolog database, query ",NA,NA
listing,NA,NA
 with no arguments. To list only the facts ,NA,NA
"and rules with a particular predicate name, query with that name. ",NA,NA
"To add a fact or rule to the Prolog database from within the interpreter, query ",NA,NA
asserta,NA,NA
 or ,NA,NA
assertz,NA,NA
. Built-in ,NA,NA
predicate ,NA,NA
asserta,NA,NA
" adds the new fact at the front of the database, and ",NA,NA
assertz,NA,NA
 adds it to the end. To ,NA,NA
"remove a fact from the Prolog database, query ",NA,NA
retract,NA,NA
 with that fact an argument. To remove all the ,NA,NA
"facts and rules with a particular predicate name, query ",NA,NA
abolish,NA,NA
", whose first argument is the predicate ",NA,NA
name and whose second is the number of arguments the first-argument predicate has. All four of these ,NA,NA
"predicates fail on backtracking, so the only way to undo an ",NA,NA
asserta,NA,NA
 or ,NA,NA
assertz,NA,NA
 is a ,NA,NA
retract,NA,NA
. ,NA,NA
"D.2 The format of facts, rules and queries ",NA,NA
"Facts, rules, and queries are all built of the same thing: predicate expressions. An expression consists of a ",NA,NA
predicate name (starting with a lower-case letter) optionally followed by one or more arguments separated ,NA,NA
by commas and enclosed in parentheses. Arguments that are constants must be numbers or start with a ,NA,NA
"lower-case letter, and arguments that are variables must start with a capital letter. Facts are just predicate ",NA,NA
"expressions followed by a period (""",NA,NA
.,NA,NA
"""). ",NA,NA
"Queries are things you type after the Prolog interpreter types """,NA,NA
?- ,NA,NA
""" on your terminal; query mode is the ",NA,NA
"interpreter's normal mode. A query is a single predicate expression, or several expressions linked with ",NA,NA
"commas or semicolons, concluded by a period and carriage return. Commas mean ""and"" and semicolons ",NA,NA
"mean ""or"". You can also specify that the opposite of something be true with the ",NA,NA
not,NA,NA
 predicate of one ,NA,NA
argument; its argument is the predicate expression you want to fail | REFERENCE 1|. .FS | REFERENCE ,NA,NA
1| The ,NA,NA
not,NA,NA
" is denoted with prefix ""/+"" in Quintus Prolog, and it won't work with inside unbound variables ",NA,NA
in Turbo Prolog. .FE ,NA,NA
"If you type a semicolon after the interpreter types an answer to a query, the interpreter will go back to ",NA,NA
work and try to find another answer to the query. You can keep typing semicolons as long as there are ,NA,NA
"more answers. If the interpreter can't find an answer, it will type ",NA,NA
no,NA,NA
. ,NA,NA
"Rules consist of a predicate expression followed by a space, the symbol """,NA,NA
:-,NA,NA
""", another space, a query, and a ",NA,NA
period. The stuff before the ,NA,NA
:-,NA,NA
 is the ,NA,NA
left side,NA,NA
 and the stuff after is the ,NA,NA
right side,NA,NA
". Rules can be read as ""if ",NA,NA
"the right side is true then the left side is true"". ",NA,NA
D.3. Program layout ,NA,NA
Spaces and carriage returns can be inserted at many places in Prolog programs without changing the ,NA,NA
"meaning. However, it's conventional not to put them in normal predicate expressions (except within ",NA,NA
"strings). A space is generally put after every ""and""-comma and ""or""-semicolon in a query or rule, as well ",NA,NA
as before and after the rule symbol ,NA,NA
:-,NA,NA
 and the arithmetic-assignment ,NA,NA
is,NA,NA
. ,NA,NA
Another convention of Prolog programming is to leave blank lines in programs between rules and facts ,NA,NA
beginning with different predicate names; this makes it easier to see which lines go together. ,NA,NA
"Comments are preceded with a """,NA,NA
/*,NA,NA
""" and followed by a """,NA,NA
*/,NA,NA
""". ",NA,NA
D.4. Lists ,NA,NA
"Arguments to predicate expressions can be lists. Lists are indicated by the brackets """,NA,NA
[,NA,NA
""" and """,NA,NA
],NA,NA
"""; commas ",NA,NA
(not to be confused with the commas between predicate arguments) separate the list items. The list of no ,NA,NA
"items """,NA,NA
[],NA,NA
""" is called the empty list. Lists of any length can be represented by variables, or they can be ",NA,NA
referred to by the notation ,NA,NA
[<front_items>|<sublist>],NA,NA
. Here ,NA,NA
<front_items>,NA,NA
" represents an item, or several ",NA,NA
"items separated by commas, at the front (left end) of a list, and ",NA,NA
<sublist>,NA,NA
 is a variable representing the ,NA,NA
arbitrarily-long rest of the list. Items within a list can be variables too. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ad.html (2 of 5) [23/04/2002 17:39:33],NA
D.5. Numbers ,NA,NA
"Arguments to predicate expressions can be numbers. (Some dialects accept only integers, and some others ",NA,NA
only accept decimals with digits before and after the decimal point.) Prolog handles numbers with infix ,NA,NA
"notation, to make things easier to read. (Predicate expressions are prefix notation; that is, the predicate ",NA,NA
name comes first.) The infix comparison predicates are ,NA,NA
=,NA,NA
" (equals), ",NA,NA
>,NA,NA
" (greater than), ",NA,NA
<,NA,NA
" (less than), ",NA,NA
=<,NA,NA
 (less ,NA,NA
"than or equal to), and ",NA,NA
>=,NA,NA
 (greater than or equal to). Any variables used in these comparisons must be ,NA,NA
bound to values. ,NA,NA
Arithmetic assignment is handled by the ,NA,NA
is,NA,NA
 infix symbol | REFERENCE 2|. .FS | REFERENCE 2| Not ,NA,NA
available in Turbo Prolog: ,NA,NA
=,NA,NA
 is dual-purpose. .FE To the left of the ,NA,NA
is,NA,NA
 and separated by a space must be the ,NA,NA
name of a variable; to the right and separated by a space must be an arithmetic expression of constants ,NA,NA
"and/or bound variables. The arithmetic expression is evaluated, and its value bound to the left-side ",NA,NA
"variable. The arithmetic expression must be in infix form, using the standard infix arithmetic symbols ",NA,NA
+,NA,NA
",",NA,NA
-,NA,NA
", ",NA,NA
*,NA,NA
", and ",NA,NA
/,NA,NA
; parentheses can group terms. ,NA,NA
D.6. Output and input ,NA,NA
To write something on the terminal screen use the ,NA,NA
write,NA,NA
 predicate of one argument. The argument can be ,NA,NA
"a word, list, number, string, bound variable (for which it prints the current binding), or even unbound ",NA,NA
variable (for which it prints the current internal code of the variable name). To get a carriage return on the ,NA,NA
"terminal, query the ",NA,NA
nl,NA,NA
" (that stands for ""new line"") predicate of no arguments. The predicate ",NA,NA
read,NA,NA
 of one ,NA,NA
"argument, a variable, reads in what the user types on the terminal keyboard and binds the variable to it. ",NA,NA
"What the user types must end with a period, just like everything else in Prolog. ",NA,NA
D.7. Strings ,NA,NA
"Character strings are denoted by single-quotation marks or apostrophes (""",NA,NA
',NA,NA
""") around some characters and ",NA,NA
"punctuation marks. Strings can contain capital letters, commas, periods, and other punctuation marks in ",NA,NA
"any order, so they're less restricted than predicate names, variable names, and constants. ",NA,NA
D.8. Treating rules and facts as data | REFERENCE ,NA,NA
3| ,NA,NA
.FS | REFERENCE 3| Not supported in Turbo Prolog. .FE The predicate ,NA,NA
clause,NA,NA
 matches its first argument ,NA,NA
"to the left side and its second argument to the right side of a rule or fact in the database (if a fact, its ",NA,NA
"second argument is set to the empty query which always succeeds, ""true"") | REFERENCE 4|. .FS | ",NA,NA
REFERENCE 4| Some Prolog dialects won't accept a ,NA,NA
clause,NA,NA
 expression unless the left-side predicate ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ad.html (3 of 5) [23/04/2002 17:39:33],NA
"name is filled in. But you can get the same effect by iterating over the list of all predicate names, trying ",NA,NA
"each one for the left side. .FE The infix ""univ"" operation represented by the symbol """,NA,NA
=..,NA,NA
""" converts queries ",NA,NA
"into lists and vice versa; the left side of this symbol is the query, and the right side the list. If the left side ",NA,NA
"is bound it is converted into its equivalent list, and if the right side is bound it is converted into its ",NA,NA
"equivalent query. Related to this, the ",NA,NA
call,NA,NA
 predicate of one argument takes a query and executes it as if it ,NA,NA
were typed on the terminal. ,NA,NA
D.9. Miscellaneous predicates ,NA,NA
The ,NA,NA
fail,NA,NA
" predicate of no arguments provides a predicate expression that always fails, forcing backtracking. ",NA,NA
"The ""true"" predicate always succeeds. The cut predicate (symbolized by ""!"") of no arguments forces ",NA,NA
throwing away of certain backtracking information; see Section 10.7 for a detailed discussion. The ,NA,NA
var ,NA,NA
predicate of one argument succeeds if its argument is unbound. The ,NA,NA
number,NA,NA
 predicate of one argument ,NA,NA
succeeds if its argument is a number. The ,NA,NA
halt,NA,NA
 predicate of no arguments stops the Prolog interpreter and ,NA,NA
returns you to the operating system; it's the recommended way to finish a session. ,NA,NA
D.10. Definable predicates ,NA,NA
"Besides the preceding built-in predicates, some predicates defined in this book in terms of others are built-",NA,NA
in in many Prolog dialects. The ,NA,NA
forall,NA,NA
 predicate of two arguments (Section 7.12) checks whether universal ,NA,NA
"quantification holds for some predicate expression; specifically, it checks whether every set of variable ",NA,NA
bindings that satisfies its first-argument predicate also satisfies its second-argument predicate expression. ,NA,NA
The ,NA,NA
doall,NA,NA
 predicate of one argument (Section 7.12) repeatedly calls its argument predicate expression ,NA,NA
until that argument fails. The ,NA,NA
repeat,NA,NA
" predicate (Section 10.8) of no arguments always succeeds, and ",NA,NA
always succeeds afresh on backtracking. The ,NA,NA
bagof,NA,NA
 predicate | REFERENCE 5| .FS | REFERENCE 5| ,NA,NA
Called ,NA,NA
findall,NA,NA
 in Clocksin and Mellish. .FE of three arguments (Section 10.6) collects into a list all values ,NA,NA
"to which a variable can be bound to satisfy a predicate expression. The first argument is the variable, the ",NA,NA
"second is the expression (somewhere inside which must be the variable), and the third argument is the list ",NA,NA
"of all possible values, the result of the computation. ",NA,NA
D.11. Debugging ,NA,NA
"Since the activities of Prolog interpreters can be complicated, good debugging facilities are essential. ",NA,NA
These facilities differ considerably between dialects. But ,NA,NA
trace,NA,NA
", ",NA,NA
spy,NA,NA
", and ",NA,NA
leash,NA,NA
 features are common. ,NA,NA
These are built-in Prolog predicates that are queried to cause certain side effects. Predicate ,NA,NA
trace,NA,NA
 is a ,NA,NA
predicate of no arguments that makes the Prolog interpreter print a running account of everything it is ,NA,NA
doing; ,NA,NA
notrace,NA,NA
 undoes it. Predicate ,NA,NA
spy,NA,NA
" is a predicate of one argument, a predicate name, that makes the ",NA,NA
Prolog interpreter print everything happening with that predicate; ,NA,NA
nospy,NA,NA
 with that same argument undoes ,NA,NA
"it. To spy on several predicates, do several ",NA,NA
spy,NA,NA
 commands. The ,NA,NA
trace,NA,NA
 and ,NA,NA
spy,NA,NA
" printouts report calls, ",NA,NA
"successes, failures, and backtracks involving predicate expressions with a given predicate name. The ",NA,NA
leash(on),NA,NA
 predicate expression tells the interpreter to stop and pause after every printout line generated by ,NA,NA
a ,NA,NA
trace,NA,NA
 or ,NA,NA
spy,NA,NA
; ,NA,NA
leash(off),NA,NA
 undoes it. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ad.html (5 of 5) [23/04/2002 17:39:33],NA
Appendix E: Using this book with Micro-Prolog ,NA,NA
Micro-Prolog is a dialect of Prolog designed to run in a small amount of memory on small computers. It ,NA,NA
"looks considerably different, but its execution (semantics) is very similar. Micro-Prolog is designed ",NA,NA
"primarily for non-programmers, people who aren't computer experts. So it is less elegant than standard ",NA,NA
"Prolog, and doesn't have some of the advanced features, but it's easier to learn to use. ",NA,NA
"In Micro-Prolog, querying is not the default mode, so you must indicate a query by a ""?"" on the front of ",NA,NA
"the line. You must use parentheses to group things, a lot like the language Lisp. You must surround the ",NA,NA
query with parentheses. The predicate name goes inside the parentheses used in standard Prolog to group ,NA,NA
"arguments, and spaces are used instead of commas to separate the arguments and the predicate name from ",NA,NA
the first argument. So the standard Prolog query ,NA,NA
"?- a, b(X), c(X,Y).",NA,NA
becomes in Micro-Prolog ,NA,NA
? ((a) (b X) (c X Y)),NA,NA
Note a period is not used. ,NA,NA
"The symbol table is limited in Micro-Prolog, so variable names can only be X, Y, Z, X1, Y1, Z1, X2, Y2, ",NA,NA
"Z2, and so on. Micro-Prolog will not print out variable bindings unless you force it with the equivalent of ",NA,NA
the standard-Prolog ,NA,NA
write,NA,NA
", the ""P"" predicate. So to print out X and Y for the preceding query you must ",NA,NA
say ,NA,NA
? ((a) (b X) (c X Y) (P X) (P Y)),NA,NA
"Predicate names in Micro-Prolog can be capitalized or uncapitalized, just as long as they aren't a possible ",NA,NA
variable name. (Built-in predicates are usually all capitals.) ,NA,NA
Rules in Micro-Prolog look just like queries without the question mark. But the first predicate is ,NA,NA
"interpreted as the left side (""then"" part), and the other predicates as the right side (""if"" part). So the ",NA,NA
standard-Prolog rule ,NA,NA
"a(X) :- b(X), c(X,3), d(Y,X).",NA,NA
becomes in Micro-Prolog ,NA,NA
((a X) (b X) (c X 3) (d Y X)),NA,NA
Figure E-1 gives a table of approximate equivalents between standard Prolog and Micro-Prolog. Micro-,NA,NA
Prolog manuals provide further information. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ae.html (2 of 2) [23/04/2002 17:39:33],NA
Appendix F: For further reading ,NA,NA
We list a few books and articles recommended for additional reading on the topics of this book. We've ,NA,NA
grouped related entries together. ,NA,NA
General artificial intelligence:,NA,NA
"Winston, P. H., ",NA,NA
Artificial Intelligence,NA,NA
". second edition. Reading, Mass.: Addison-Wesley, ",NA,NA
1984. Useful for basic understanding of artificial intelligence. ,NA,NA
"Charniak, E. and McDermott, D., ",NA,NA
Introduction to Artificial Intelligence,NA,NA
". Reading, Mass.: ",NA,NA
"Addison-Wesley, 1985. A well-balanced, reasonably detailed treatment of the field at a ",NA,NA
more advanced level than ours. Also a good source for further information. Uses examples ,NA,NA
in Lisp. ,NA,NA
"Gevarter, W. B., ",NA,NA
Intelligent Machines: An Introductory Perspective of Artificial ,NA,NA
Intelligence,NA,NA
" and Robotics. Englewood Cliffs, N. J.: Prentice-Hall, Inc., 1985. A short ",NA,NA
summary of the key ideas in artificial intelligence. ,NA,NA
"Reitman, W., (ed.), ",NA,NA
Artificial Intelligence Applications for Business,NA,NA
". Norwood, N. J.: ",NA,NA
"Ablex, 1984. An interesting collection of articles surveying of the major commercial ",NA,NA
applications of artificial intelligence. ,NA,NA
"Feigenbaum, E., and McCorduck, P., ",NA,NA
The Fifth Generation: Artificial Intelligence and ,NA,NA
Japan's Computer Challenge,NA,NA
" to the World. Reading, Mass.: Addison-Wesley, 1983. A non-",NA,NA
"technical, general-audience book arguing for the critical importance of artificial ",NA,NA
intelligence in the world's future. Controversial but interesting reading. ,NA,NA
The language Prolog:,NA,NA
"Clocksin, W. and Mellish, C., ",NA,NA
Programming in Prolog,NA,NA
". second edition. Berlin, B.R.D.: ",NA,NA
"Springer-Verlag, 1984. A well-written introduction to Prolog as a programming language, ",NA,NA
including features not covered in our book. Uses a dialect containing ours. ,NA,NA
"Sterling, L. and Shapiro, E., ",NA,NA
The Art of Prolog,NA,NA
". Cambridge, Mass.: MIT Press, 1986. A ",NA,NA
more detailed introduction to Prolog. ,NA,NA
"Bratko, I., ",NA,NA
Prolog Programming for Artificial Intelligence,NA,NA
". Reading, Mass.: Addison-",NA,NA
"Wesley, 1986. Despite its title, mostly a programming language textbook in the manner of ",NA,NA
Clocksin and Mellish. But it has additional chapters on implementing search in Prolog ,NA,NA
"(Chapters 11, 12, 13, and 15) corresponding to much of our Chapters 9 and 10, a chapter ",NA,NA
"(Chapter 14) on expert systems covering parts of our Chapters 7 and 8, and some material ",NA,NA
on resolution (Section 16.3) corresponding to the program in our Chapter 14. ,NA,NA
"Ennals, R., ",NA,NA
Artificial Intelligence: Applications to Logical Reasoning and Historical ,NA,NA
"Research. New York: Wiley, 1985. A good non-threatening introduction to Prolog for ",NA,NA
students without strong computer science backgrounds. Helpful for people finding the ,NA,NA
early chapters of our book tough going. ,NA,NA
"Clark, K., and McCabe, F., ",NA,NA
Micro-Prolog: Programming in Logic,NA,NA
". Englewood Cliffs, N. ",NA,NA
"J.: Prentice-Hall International, 1984. An introduction to the Micro-Prolog dialect. ",NA,NA
"Cohen, J., ""Describing Prolog by Its Interpretation and Compilation, ",NA,NA
Communications of ,NA,NA
"the ACM, 28",NA,NA
", 12 (December 1985), 1311-1324. A good survey of Prolog from a ",NA,NA
programmer's point of view. ,NA,NA
Subareas of artificial intelligence:,NA,NA
"Waterman, D., ",NA,NA
A Guide to Expert Systems,NA,NA
". Reading, Mass.: Addison-Wesley, 1986. A ",NA,NA
"good introduction to expert systems, though not very technical. Extensive bibliography. ",NA,NA
"Hayes-Roth, F., Lenat, D., and Waterman, D., (eds.), ",NA,NA
Building Expert Systems,NA,NA
". Reading, ",NA,NA
"Mass.: Addison-Wesley, 1983. A more detailed consideration of issues in building expert ",NA,NA
systems. ,NA,NA
"Winograd, T., ",NA,NA
"Language As a Cognitive Process, Volume I: Syntax",NA,NA
". Reading, Mass.: ",NA,NA
"Addison-Wesley, 1983. Overview of the grammar (syntax) side of the natural language ",NA,NA
subarea. ,NA,NA
"Schank, R. and Abelson, R., ",NA,NA
"Scripts, Plans, Goals, and Understanding",NA,NA
". Hillsdale, N.J.: ",NA,NA
"Lawrence Erlbaum, 1977. An integrated discussion of natural-language semantics, frames, ",NA,NA
and planning. Quite readable. ,NA,NA
"Special Section on Architectures for Knowledge-Based Systems, ",NA,NA
Communications of the ,NA,NA
"ACM, 28",NA,NA
", 9 (September 1985), 902-941. Contains three good overview articles on frames, ",NA,NA
"rule-based systems, and logic programming. ",NA,NA
"Ballard, D. and Brown, C., ",NA,NA
Computer Vision,NA,NA
". Englewood Cliffs, N.J.: Prentice-Hall, 1982. ",NA,NA
An overview of the vision subarea of artificial intelligence. ,NA,NA
"Wos, L., Overbeek, R., Lusk, E., and Boyle, J., ",NA,NA
Automated Reasoning: Introduction and ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/af.html (2 of 4) [23/04/2002 17:39:34],NA
Applications,NA,NA
". Englewood Cliffs, N. J., Prentice-Hall, 1984. Discusses use of a general-",NA,NA
purpose theorem prover (based on extensions of resolution) for making inferences for ,NA,NA
"interesting problems. A friendly book with lots of interesting examples, but its theorem-",NA,NA
prover is more powerful than Prolog and so programming it is different. ,NA,NA
"Maier, D., ""Databases in the Fifth Generation Project: Is Prolog a Database Language?"", in ",NA,NA
New Directions for Database Systems,NA,NA
", Ariav, G. and Clifford, J., eds. Norwood, N.J.: ",NA,NA
"Ablex, 1986, 18-34. Good survey of the considerations necessary to make Prolog efficient ",NA,NA
with large databases of facts and rules. ,NA,NA
"Fishman, D., ""The DBMS--Expert-System Connection"", in ",NA,NA
New Directions for Database ,NA,NA
Systems,NA,NA
", Ariav, G. and Clifford, J., eds. Norwood, N.J.: Ablex, 1986, 87-101. Explains ",NA,NA
how database design considerations are important for expert systems. ,NA,NA
"Michalski, R., Carbonell, J., and Mitchell, T., eds., ",NA,NA
Machine Learning: An Artificial ,NA,NA
Intelligence Approach,NA,NA
". Palo Alto, Ca.: Tioga, 1983. Collection of articles summarizing the ",NA,NA
learning subarea. ,NA,NA
"Goldberg, A., and Robson, D., ",NA,NA
Smalltalk-80: The Language and Its Implementation,NA,NA
. ,NA,NA
"Reading, Mass.: Addison-Wesley, 1983. An overview of the object-oriented programming ",NA,NA
language Smalltalk. ,NA,NA
"Winston, P., and Horn, B., ",NA,NA
Lisp,NA,NA
", second edition. Reading, Mass.: Addison-Wesley, 1984. A ",NA,NA
sequel to Winston's ,NA,NA
Artificial Intelligence,NA,NA
 which shows how to write some interesting ,NA,NA
artificial intelligence programs in Lisp. It illustrates well how Lisp programming is ,NA,NA
different from Prolog programming. ,NA,NA
General background:,NA,NA
"Mendelson, E., ",NA,NA
Introduction to Mathematical Logic,NA,NA
". Princeton, N.J.: Van Nostrand, 1964. ",NA,NA
Just one of many good textbooks on logic from a mathematical perspective. ,NA,NA
"Tenenbaum, A., and Augenstein, M., ",NA,NA
Data Structures Using Pascal,NA,NA
". Englewood Cliffs, ",NA,NA
"N.J.: Prentice-Hall, 1981. Good coverage of the basics of data structures and recursion. ",NA,NA
"Zwass, V., ",NA,NA
Introduction to Computer Science,NA,NA
". New York: Barnes and Noble, 1981. Basic ",NA,NA
survey of the fundamentals of computer science necessary for understanding artificial ,NA,NA
intelligence. ,NA,NA
"Wulf, W., Shaw, M., Hilfinger, P., and Flon, L., ",NA,NA
Fundamental Structures of Computer ,NA,NA
Science,NA,NA
". Reading, Mass.: Addison-Wesley, 1981. A more advanced presentation than the ",NA,NA
"preceding. Good coverage of data structures, recursion, and implementation of traditional ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/af.html (3 of 4) [23/04/2002 17:39:34],NA
programming languages. ,NA,NA
"Kolman, B. and Busby, R., ",NA,NA
Introductory Discrete Structures with Applications,NA,NA
. Englewood ,NA,NA
"Cliffs, N.J.: Prentice-Hall, 1987. Survey of the mathematical fundamentals necessary for ",NA,NA
artificial intelligence. ,NA,NA
"Longley-Cook, L., ",NA,NA
Statistical Problems and How To Solve Them,NA,NA
. New York: Barnes and ,NA,NA
"Noble, 1970. Just one of many good introductions to statistics and probability. This one is ",NA,NA
quite friendly. ,NA,NA
"Lindsay, P. and Norman, D., ",NA,NA
Human Information Processing,NA,NA
". New York: Academic Press, ",NA,NA
1972. Well-written introduction to the tie-ins between artificial intelligence and research in ,NA,NA
human cognitive psychology. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/af.html (4 of 4) [23/04/2002 17:39:34],NA
Appendix G: Answers to selected exercises ,NA,NA
"(Exercises with answers were marked with an ""A"".) ",NA,NA
2-1. The ,NA,NA
color,NA,NA
" fact is better, because colors are less based on judgment and context than sizes are. We can ",NA,NA
"define colors by frequency ranges of light waves, but there are no absolute standards of size: a ""big"" ship is a ",NA,NA
"lot bigger than a ""big"" molecule. So if you want to refer to sizes in an artificial intelligence program, you ",NA,NA
probably should use something more precise. ,NA,NA
"2-2. Answer (ii). For format (i) the predicate names are just as general as the argument names, meaning many ",NA,NA
separate predicate names are necessary. And there's no internal indication with format (i) that these are supposed ,NA,NA
"to be memo facts. But format (iii) is too general--any fact can be written this way--and the predicate ""fact"" isn't ",NA,NA
"informative. Also, (ii) is typical of the predicates used in the chapter. ",NA,NA
"2-5. The speaker is forgetting that arithmetic operations are functions, and the function result must be an ",NA,NA
explicit argument in predicate expressions. So one-argument operations become two-argument predicate ,NA,NA
"expressions, and two-argument operations become three-argument expressions. Other than that, the speaker's ",NA,NA
"argument is pretty much correct: logic is part of mathematics, and Prolog is closely related to logic. ",NA,NA
2-6. Write each ,NA,NA
ship,NA,NA
" fact as five two-argument subfacts, each with first argument the original first argument of ",NA,NA
the ,NA,NA
ship,NA,NA
" fact. (That is, use the ship name as a ",NA,NA
key,NA,NA
.) The second argument will be: ,NA,NA
--ship location for predicate name ,NA,NA
location,NA,NA
; ,NA,NA
--time at location for predicate name ,NA,NA
time,NA,NA
; ,NA,NA
--date at location for predicate name ,NA,NA
date,NA,NA
; ,NA,NA
--ship color for predicate name ,NA,NA
color,NA,NA
; ,NA,NA
--ship commander for predicate name ,NA,NA
commander,NA,NA
. ,NA,NA
So for instance ,NA,NA
"ship(enterprise,15n35e,1200,160285,gray,j_kirk).",NA,NA
becomes ,NA,NA
"location(enterprise,15n35e).",NA,NA
"time(enterprise,1200).",NA,NA
"date(enterprise,160285).",NA,NA
"color(enterprise,gray).",NA,NA
"commander(enterprise,j_kirk).",NA,NA
"2-7. You might want to reason about a hypothetical situation, a situation not currently true. Advance reasoning ",NA,NA
"might help you plan what to do if the situation occurs, saving you time then and letting you figure the best thing ",NA,NA
to do. Reasoning about hypothetical situations is also useful for debugging programs. For such reasoning to ,NA,NA
"work, the set of hypothetical facts must be consistent: they can't be false in the sense of being self-contradictory. ",NA,NA
3-1. (a) Use DeMorgan's Law: ,NA,NA
"?- not(a), not(b).",NA,NA
(b) Use DeMorgan's Law and rearrange: ,NA,NA
"?- (a;b), (not(a);not(b)).",NA,NA
3-2.(a) ,NA,NA
--What job bosses the boss of a CS professor? ,NA,NA
--What person is Rowe's boss? ,NA,NA
--Who is the incumbent dean of either IP or IPS? (querier probably doesn't know which is the ,NA,NA
proper abbreviation) ,NA,NA
--What person either has the provost or the IPS dean as a boss? ,NA,NA
--What job other than Shrady's is bossed by the superintendent? ,NA,NA
"(b) First answers found, in order: ",NA,NA
X=cschairman,NA,NA
Y=dean_ips ,NA,NA
X=csprofessor,NA,NA
Y=cschairman,NA,NA
Z=lum ,NA,NA
X=marshall ,NA,NA
J=cschairman,NA,NA
P=lum ,NA,NA
P=director_milops ,NA,NA
3-5. (a) NM (every possible pair). ,NA,NA
(b) N (N-1 for each new choice of ,NA,NA
X,NA,NA
", and then one for the final query failure). ",NA,NA
(c) NM (the two parts of the query are independent). ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (2 of 36) [23/04/2002 17:39:40],NA
(d) The minimum of M and N. ,NA,NA
(e) N--it's just like part (b). ,NA,NA
(f) 0. The arguments to ,NA,NA
p,NA,NA
 facts may be totally different from the arguments to ,NA,NA
q,NA,NA
 facts. ,NA,NA
"3-6. (a) ""Joe"" is a constant in the queries, and ""someone"" is a variable. Every time a new Prolog query is asked, ",NA,NA
"the variable bindings from the previous query are thrown away, and so this only affects the ""someone"" query. ",NA,NA
The mistake or ,NA,NA
fallacy,NA,NA
", is in assuming such bindings persist. ",NA,NA
(b) Assuming that a student gets a single grade on a single test: ,NA,NA
"?- grade(P,1,G), not(grade(P,1,a)).",NA,NA
"(c) No, this isn't correct. Different people may have taken the two tests: some students may have dropped the ",NA,NA
"course and others may have added the course in between. So the meaning of ""class"" may have changed. ",NA,NA
3-9.(a) ,NA,NA
"X=a, Y=d, Z=e",NA,NA
. The first three ,NA,NA
r,NA,NA
 facts all eventually fail when used to match ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 in the first ,NA,NA
predicate expression in the query. ,NA,NA
X=a,NA,NA
 with ,NA,NA
Y=b,NA,NA
" fails in the third query expression, ",NA,NA
X=a,NA,NA
 with ,NA,NA
Y=c,NA,NA
 fails in the ,NA,NA
"fourth query expression, and ",NA,NA
X=b,NA,NA
 with ,NA,NA
Y=a,NA,NA
 fails in the second query expression. ,NA,NA
(b) Four times: for ,NA,NA
Y=b,NA,NA
 and ,NA,NA
Z=c,NA,NA
", ",NA,NA
Y=b,NA,NA
 and ,NA,NA
Z=d,NA,NA
", ",NA,NA
Y=c,NA,NA
 and ,NA,NA
Z=d,NA,NA
", and ",NA,NA
Y=c,NA,NA
 and ,NA,NA
Z=c,NA,NA
. Notice that even though the ,NA,NA
"matching for the second predicate expression can't affect the success of the third expression, the Prolog ",NA,NA
"interpreter will always backtrack there from the third because it's the immediately previous expression--that is, ",NA,NA
the interpreter always backtracks ,NA,NA
chronologically,NA,NA
. ,NA,NA
4-2. (a) Make the left side a fact. ,NA,NA
(b) Delete the rule entirely--it never does any good. ,NA,NA
"4-5. No, not if ",NA,NA
a,NA,NA
 is queried with an unbound argument and there is some ,NA,NA
c,NA,NA
" fact in the database, say ",NA,NA
c(3),NA,NA
. Then ,NA,NA
the one-rule form binds ,NA,NA
X,NA,NA
 to 3 in ,NA,NA
a,NA,NA
", but the two-rule form can't. But when ",NA,NA
a,NA,NA
" is queried with a bound argument, ",NA,NA
the two forms give the same answers. ,NA,NA
"4-6. (a) Two different meanings of the word ""mayor"" are being confused: the job description and the person ",NA,NA
currently occupying that office. These meanings can't be equated. We'll discuss this distinction more in ,NA,NA
Chapter 12. ,NA,NA
"(b) The phrase ""a movie star"" acts like a noun, whereas ""a little stupid"" acts like an adjective. So ""Clint is a ",NA,NA
"movie star"" must be represented by an ",NA,NA
a_kind_of,NA,NA
" relationship predicate, whereas ""John is a little stupid"" must ",NA,NA
be represented by a property predicate. ,NA,NA
"4-7. (a) A definition with two things ""and""ed together on the right side. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (3 of 36) [23/04/2002 17:39:40],NA
"(b) Two different facts about a department chairman (notice they do not define ""chairman"", just give ",NA,NA
properties of one). ,NA,NA
"(c) Here the ""and"" is more like an ""or"". So you could write two rules with the same left side (representing ""a ",NA,NA
"way to put out a fire"") and different right sides for the different methods. Alternatively but less directly, you ",NA,NA
"could write two facts asserting two different ""fire methods"". ",NA,NA
(d) Two ,NA,NA
a_kind_of,NA,NA
 facts. ,NA,NA
"(e) This is an unusual situation in English, an ",NA,NA
idiom,NA,NA
 in which the words don't mean what they literally say. Here ,NA,NA
"Tom and Dick are not only friends, but implied friends of one another. So two interrelated facts are being ",NA,NA
"asserted, or just a disguised relationship-predicate fact. ",NA,NA
"4-10.(a) upward only. If some of Set have Property, then those same items will be present in a set including ",NA,NA
Set. ,NA,NA
(b) No basis conditions are needed because facts will provide them. The induction step looks like this: ,NA,NA
"some(Set,Property) :- contains(Set,Set2), some(Set2,Property).",NA,NA
"(c) downward only. If all of Set have Property, then all the items of any subset of Set have the same property. ",NA,NA
"(d) neither way. ""Most"" is a statistical generalization about a set, and there's never any guarantee that a ",NA,NA
statistical generalization about one set applies to a related set. (A subset might just happen to contain atypical ,NA,NA
items.) ,NA,NA
"4-11. (a) Yes, something inside something else inside a third thing is inside the third thing. ",NA,NA
"(b) Yes, it in inherits downward in one sense. If A is in front of B, and B contains C, then A is in front of C. ",NA,NA
"However, downward inheritance doesn't work the other way: if A is in front of B and B is inside C, then A is ",NA,NA
"not necessarily in front of C because C could contain A too: let A=battery, B=motor, and C=entire car. ",NA,NA
(c) To better talk to people (as when giving them advice) because people understand nonnumeric descriptions ,NA,NA
"better. And if people were given coordinates to locate things, they would need to do a lot of measurements ",NA,NA
"from reference points, which is bothersome. Furthermore, it's tricky to compute object relationships from ",NA,NA
"Cartesian coordinates describing object shapes; a lot of mathematics is necessary, especially when it won't do ",NA,NA
to just store the center of irregularly shaped objects. So it would be awkward for the computer to store ,NA,NA
coordinates internally and convert them to physical relationships to talk to people. ,NA,NA
"On the other hand, Cartesian coordinates are more precise descriptors than relationship predicates: you can ",NA,NA
"compute more accurate spatial relationships, ways to reach parts, etc. Cartesian coordinates might take less ",NA,NA
memory space than relationship information since you wouldn't have to represent information about an object ,NA,NA
"more than once; for N objects in a car there are |N * ( N - 1 )| relationships between any two, though ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (4 of 36) [23/04/2002 17:39:40],NA
inheritance could cut that down. And there are lots of ways to compress numbers to make storing them even ,NA,NA
"more efficient, like keeping relative coordinates of parts. It's not true that relationship predicates are more car-",NA,NA
"independent (that is, the same description could apply to many different cars) than Cartesian coordinates, since ",NA,NA
"coordinates could have associated tolerance intervals to make them more fuzzy. But ""user-friendliness"" is the ",NA,NA
chief disadvantage of Cartesian coordinates. ,NA,NA
4-13. (a) The point of this part of the problem is to note the varied forms the same predicate can take. Only ,NA,NA
two predicates are needed: the ,NA,NA
part_of,NA,NA
" of Section 2.6, and a ",NA,NA
contains,NA,NA
 predicate that says that some of an ,NA,NA
"object is a particular material (if you wanted to be fancy, you could have an additional predicate indicating ",NA,NA
that ,NA,NA
all,NA,NA
" of an object is of a certain material, but that's not necessary for the questions in part (d)). Note the ",NA,NA
"statements refer to an Acme hotplate, so somehow you should say this. ",NA,NA
"part_of(acme_hotplate_cord,acme_hotplate).",NA,NA
"part_of(acme_hotplate_body,acme_hotplate).",NA,NA
"part_of(acme_hotplate_heating_element,acme_hotplate_body). ",NA,NA
"part_of(acme_hotplate_cover,acme_hotplate_body).",NA,NA
"part_of(acme_hotplate_knob,acme_hotplate_cover).",NA,NA
"part_of(acme_hotplate_wire,acme_hotplate_cord).",NA,NA
"part_of(acme_hotplate_insulater,acme_hotplate_cord).",NA,NA
"contains(acme_hotplate_heating_element,metal).",NA,NA
"contains(acme_hotplate_knob,plastic). ",NA,NA
"contains(acme_hotplate_wire,metal).",NA,NA
"contains(acme_hotplate_insulater,fiber).",NA,NA
(b) ,NA,NA
"?- contains(X,metal).",NA,NA
X=acme_hotplate_heating_element; ,NA,NA
X=acme_hotplate_wire; ,NA,NA
no.,NA,NA
"?- part_of(X,acme_hotplate_body). ",NA,NA
X=acme_hotplate_heating_element; ,NA,NA
X=acme_hotplate_cover; ,NA,NA
no.,NA,NA
(c) ,NA,NA
"part(X,Y) :- part_of(X,Y).",NA,NA
"part(X,Y) :- part_of(X,Z), part(Z,Y).",NA,NA
"contains(X,M) :- part_of(Y,X), contains(Y,M).",NA,NA
If you use a predicate for things entirely composed of a particular material--call it ,NA,NA
all_contains,NA,NA
--then you need ,NA,NA
one more rule: ,NA,NA
"contains(X,M) :- all_contains(X,M).",NA,NA
(d) The difficulty in the second question is that any ,NA,NA
not,NA,NA
 must refer to a bound variable. The apparent context is ,NA,NA
parts of the Acme hotplate. So first define: ,NA,NA
"thing(X) :- part_of(X,Y).",NA,NA
"thing(X) :- not(part_of(X,Y)), part_of(Y,X).",NA,NA
"That is, a ""thing"" is anything mentioned in ",NA,NA
part_of,NA,NA
 facts. Here are the results for all three questions: ,NA,NA
"?- contains(X,plastic). ",NA,NA
X=acme_hotplate_knob; ,NA,NA
X=acme_hotplate; ,NA,NA
X=acme_hotplate_body; ,NA,NA
X=acme_hotplate_cover; ,NA,NA
no.,NA,NA
"?- thing(X), not(contains(X,fiber)).",NA,NA
X=acme_hotplate_body; ,NA,NA
X=acme_hotplate_heating_element; ,NA,NA
X=acme_hotplate_cover; ,NA,NA
X=acme_hotplate_knob; ,NA,NA
X=acme_hotplate_wire; ,NA,NA
no.,NA,NA
"?- contains(X,metal), contains(X,fiber).",NA,NA
X=acme_hotplate; ,NA,NA
X=acme_hotplate; ,NA,NA
X=acme_hotplate_cord; ,NA,NA
no.,NA,NA
5-1. Note no ,NA,NA
is,NA,NA
 or ,NA,NA
=,NA,NA
 is needed. ,NA,NA
"max(X,Y,Z,X) :- not(Y>X), not(Z>X). ",NA,NA
"max(X,Y,Z,Y) :- not(X>Y), not(Z>Y). ",NA,NA
"max(X,Y,Z,Z) :- not(X>Z), not(Y>Z).",NA,NA
5-2. Write as facts instead of variables. Easy fact representation is a big advantage of Prolog over languages ,NA,NA
like Pascal. ,NA,NA
"translate(1,integer_overflow).",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (6 of 36) [23/04/2002 17:39:40],NA
"translate(2,division_by_zero).",NA,NA
"translate(3,unknown_identifier).",NA,NA
"In general, ",NA,NA
is,NA,NA
 and ,NA,NA
=,NA,NA
 should rarely be used for anything other than arithmetic and an occasional local variable. ,NA,NA
"Instead, use the automatic facilities of Prolog for checking and binding values. ",NA,NA
"5-8.(a) With rules for inferring both starts and ends from the other, we must be careful to avoid infinite loops. ",NA,NA
We can do this by defining new predicates ,NA,NA
inferred_end,NA,NA
 and ,NA,NA
inferred_start,NA,NA
. ,NA,NA
"inferred_end(E,T) :- end(E,T).",NA,NA
"inferred_end(E,T) :- start(E,Tstart), duration(E,Dur),",NA,NA
 ,NA,NA
T is Tstart + Dur.,NA,NA
"inferred_start(E,T) :- start(E,T).",NA,NA
"inferred_start(E,T) :- end(E,Tend), duration(E,Dur), T is Tend - Dur. ",NA,NA
(b) ,NA,NA
The second event must be completely over before the first event starts or else ,NA,NA
after,NA,NA
 is not a proper term to use ,NA,NA
in English. ,NA,NA
"after(E1,E2) :- inferred_end(E2,E2end), inferred_start(E1,E1start),",NA,NA
 ,NA,NA
E1start > E2end.,NA,NA
(c) The usual English meaning of ,NA,NA
during,NA,NA
 is that an event occurred entirely inside the duration of the other. ,NA,NA
"during(E1,E2) :- inferred_start(E1,E1start), inferred_start(E2,E2start), ",NA,NA
"inferred_end(E1,E1end), inferred_end(E2,E2end),",NA,NA
" E1start > E2start, E1end < E2end.",NA,NA
"(d) The rules should come after all the facts, so facts will always be preferred to answer queries. The order of ",NA,NA
the rules among themselves doesn't matter except for the two ,NA,NA
inferred_start,NA,NA
 and ,NA,NA
inferred_end,NA,NA
" rules, because ",NA,NA
order of rules having the same predicate name is the only thing the Prolog interpreter considers--it indexes facts ,NA,NA
and rules with the same predicate name. ,NA,NA
5-9.(a) ,NA,NA
"speed(<gear_number>,<speed_in_rpm>)",NA,NA
". Positive speeds can be clockwise, negative ",NA,NA
counterclockwise. ,NA,NA
(b) ,NA,NA
"speed(G,S) :- same_shaft(G,G2), speed(G2,S). ",NA,NA
(c) ,NA,NA
"speed(G,S) :- meshed(G,G2), teeth(G,TG), teeth(G2,TG2), speed(G2,S2),",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (7 of 36) [23/04/2002 17:39:40],NA
 S is 0 - ( S2 * TG2 / TG ).,NA,NA
(d) Use the following database: ,NA,NA
"speed(g1,5000).",NA,NA
"same_shaft(g2,g1).",NA,NA
"meshed(g3,g2).",NA,NA
"meshed(g4,g2).",NA,NA
"teeth(g1,100).",NA,NA
"teeth(g2,30).",NA,NA
"teeth(g3,60).",NA,NA
"teeth(g4,90).",NA,NA
"speed(G,S) :- same_shaft(G,G2), speed(G2,S).",NA,NA
"speed(G,S) :- meshed(G,G2), teeth(G,TG), teeth(G2,TG2), speed(G2,S2),",NA,NA
 S is 0 - ( S2 * TG2 / TG ).,NA,NA
and issue this query: ,NA,NA
"?- speed(g4,S).",NA,NA
The one ,NA,NA
speed,NA,NA
" fact doesn't apply, so the first ",NA,NA
speed,NA,NA
 rule is tried. But there is no ,NA,NA
same_shaft,NA,NA
 fact with ,NA,NA
g4,NA,NA
 as ,NA,NA
"first argument, so the rule fails. Now the second ",NA,NA
speed,NA,NA
 rule is tried. Gear g2 can be matched to ,NA,NA
g2,NA,NA
", with ",NA,NA
TG=90,NA,NA
 and ,NA,NA
TG2=30,NA,NA
. Then we must find the speed of ,NA,NA
G2=g2,NA,NA
". No fact applies, but we can use the first ",NA,NA
speed ,NA,NA
rule: ,NA,NA
g2,NA,NA
 is the first argument to a ,NA,NA
same_shaft,NA,NA
 fact having ,NA,NA
g1,NA,NA
" as second argument, so its speed is the speed of ",NA,NA
g1,NA,NA
. And a fact says the speed of ,NA,NA
g1,NA,NA
" is 5000. So the speed of g2 is 5000, and we can do the calculation in the ",NA,NA
"second ""speed"" rule as ",NA,NA
S = 0 - ( 5000 * 30 / 90 ) = -1667 rpm,NA,NA
and the variable ,NA,NA
S,NA,NA
 in the original query is bound to that number. ,NA,NA
"(e) You could get infinite loops if you had extra redundant facts, like if you had both ",NA,NA
"meshed(g2,g1)",NA,NA
 and ,NA,NA
"meshed(g1,g2)",NA,NA
. You could also get infinite loops if you had more than one inference rule of either the ,NA,NA
"previous types, as for instance if you had ",NA,NA
"speed(G,S) :- same_shaft(G,G2), speed(G2,S).",NA,NA
"speed(G,S) :- same_shaft(G2,G), speed(G2,S).",NA,NA
"Generally speaking, gears are intended to transmit power in one particular direction, so you only need one ",NA,NA
rule. You can encode that direction in the ,NA,NA
meshed,NA,NA
 facts. ,NA,NA
(f) The gears wouldn't turn or would self-destruct; such a contradiction of rotation speeds is an impossibility. ,NA,NA
5-14. (a) ,NA,NA
"member(X,L) :- append(L2,[X|L3],L). ",NA,NA
(b) ,NA,NA
"last(X,L) :- append(L2,[X],L). ",NA,NA
(c) ,NA,NA
"deleteone(I,L,DL) :- append(L1,[I|L2],L), append(L1,L2,DL). ",NA,NA
(d) ,NA,NA
"before(X,Y,L) :- append(L2,[X|L3],L), append(L4,[Y|L5],L3).",NA,NA
"5-17. (a) It replaces every other word in a list with the word ""censored"", binding the result to the second ",NA,NA
argument. The rule (third line) just says if you can find an ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
" at the front of your list first argument, ",NA,NA
change the ,NA,NA
Y,NA,NA
" to the word ""censored"" after recursively doing the same on the rest of the list. ",NA,NA
That's a declarative analysis. A procedural understanding comes from figuring out what happens with simple ,NA,NA
example lists: ,NA,NA
"?- mystery([],Z).",NA,NA
Z=[] ,NA,NA
"?- mystery([a],Z).",NA,NA
Z=[a] ,NA,NA
"?- mystery([a,b],Z).",NA,NA
"Z=[a,censored] ",NA,NA
"For the last example, the third rule applies for the first time. So ",NA,NA
X,NA,NA
 is matched to ,NA,NA
a,NA,NA
", ",NA,NA
Y,NA,NA
 is matched to ,NA,NA
b,NA,NA
", and ",NA,NA
L,NA,NA
 is ,NA,NA
matched to ,NA,NA
[],NA,NA
", the empty list. The rule involves a recursive call with first argument ",NA,NA
L,NA,NA
", but ",NA,NA
L,NA,NA
" is the empty list, ",NA,NA
"it's the same situation as the first example preceding, and ",NA,NA
M,NA,NA
 is bound to the empty list too. So the rule says to ,NA,NA
take ,NA,NA
M,NA,NA
 and ,NA,NA
X,NA,NA
" and the word ""censored"" and assemble them into the result, the list whose first two items are ",NA,NA
X ,NA,NA
"and ""censored"", and whose remainder is ",NA,NA
M,NA,NA
. But ,NA,NA
M,NA,NA
" is empty, so the result is ",NA,NA
"[a,censored]",NA,NA
. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (9 of 36) [23/04/2002 17:39:40],NA
"Now consider the next hardest case, an example list with three items: ",NA,NA
"?- mystery([a,b,c],Z).",NA,NA
The third rule must be again used. It matches ,NA,NA
X,NA,NA
 to ,NA,NA
a,NA,NA
", ",NA,NA
Y,NA,NA
 to ,NA,NA
b,NA,NA
", and ",NA,NA
L,NA,NA
 to ,NA,NA
[c],NA,NA
", the list containing only ",NA,NA
c,NA,NA
. The rule ,NA,NA
says to do a recursion with ,NA,NA
[c],NA,NA
" the first argument. But to solve that the second rule will do, so ",NA,NA
M,NA,NA
 is bound to ,NA,NA
[c],NA,NA
. So the answer is assembled from ,NA,NA
X,NA,NA
", the word ""censored"", and that ",NA,NA
M,NA,NA
", and the result for ",NA,NA
Z,NA,NA
 is ,NA,NA
"[a,censored,c]",NA,NA
. ,NA,NA
Now consider an example list with four items: ,NA,NA
"?- mystery([a,b,c,d],L).",NA,NA
"In the third rule, ",NA,NA
X,NA,NA
 is matched to ,NA,NA
a,NA,NA
", ",NA,NA
Y,NA,NA
 is matched to ,NA,NA
b,NA,NA
", and ",NA,NA
"[c,d]",NA,NA
 is matched to ,NA,NA
L,NA,NA
. The recursion applies mystery ,NA,NA
to the two-item list ,NA,NA
"[c,d]",NA,NA
", which by analogy to the preceding two-item example gives ",NA,NA
"[c,censored]",NA,NA
. So we ,NA,NA
assembled the answer from ,NA,NA
X,NA,NA
", the word ""censored"", and the list ",NA,NA
"[c,censored]",NA,NA
", and the result for ",NA,NA
Z,NA,NA
 is ,NA,NA
"[a,censored,c,censored]",NA,NA
. So it looks like the program changes every alternate word in a list to the word ,NA,NA
"""censored"". ",NA,NA
"(b) One for even-length lists, one for odd-length. The rule lops off two items from the list on each recursion, so ",NA,NA
you can get into two different final situations. ,NA,NA
"5-19. (a) |N + 1| times, once for every item in the list plus once for the empty list; all these invocations will ",NA,NA
fail. ,NA,NA
"(b) |( N - 1 ) / 2|. There are 0 calls if the item is first in the list, one call if the item is second in the list, two ",NA,NA
"calls if the item is third in the list, and so on. These terms form an arithmetic series. The average value of an ",NA,NA
"arithmetic series is the average of the first and last numbers, in this case 0 and N - 1. ",NA,NA
"5-22. Use a list to keep arguments previously used, and just check to make sure a new value found is not in the ",NA,NA
"list. At every recursion, add the new argument to the list. So: ",NA,NA
"a3(X,Y) :- a2(X,Y,[]).",NA,NA
"a2(X,Y,L) :- a(X,Y).",NA,NA
"a2(X,Y,L) :- not(member(X,L)), a(X,Z), a2(Z,Y,[X|L]).",NA,NA
"member(X,[X|L]).",NA,NA
"member(X,[Y|L]) :- not(X=Y), member(X,L).",NA,NA
Then you query ,NA,NA
a3,NA,NA
" to compute relationships by transitivity. For instance, suppose you have the database: ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (10 of 36) [23/04/2002 17:39:40],NA
"a(r,s).",NA,NA
"a(s,t).",NA,NA
"a(t,r).",NA,NA
"(For instance, predicate ",NA,NA
a,NA,NA
" might mean ""equals"" or ""is near"".) Then the query ",NA,NA
"?- a(r,t).",NA,NA
"will succeed as it should, as will ",NA,NA
"?- a(r,r).",NA,NA
But the query ,NA,NA
"?- a(r,u).",NA,NA
will fail as it should. ,NA,NA
6-1.(a) Forward chaining means reasoning from facts to goals. The first fact is ,NA,NA
c,NA,NA
", and it is mentioned in rules ",NA,NA
"R5 and R8, so expressions in those rules are matched in that order. The right side of R8 is eliminated, so ",NA,NA
b(X) ,NA,NA
"is made a new fact. (X isn't bound, but that's OK.) The ""b(X)"" goes at the front of the facts, so we now can ",NA,NA
"match expressions in rules R1 and R3, but neither of those rules is eliminated yet. ",NA,NA
So we pick the next fact ,NA,NA
l,NA,NA
". This matches the right side in R7, and ",NA,NA
g(X),NA,NA
 is made a new fact at the front of the fact ,NA,NA
list. This in turn matches an expression in R2. We next pick fact ,NA,NA
e(a),NA,NA
 and this matches an expression in R5 only. ,NA,NA
So since ,NA,NA
c,NA,NA
" was already matched, R5 succeeds, and the fact ",NA,NA
d,NA,NA
 is asserted. But ,NA,NA
d,NA,NA
" is a goal, so we stop. ",NA,NA
(b) Now we reason from goals to facts. The ,NA,NA
f(X),NA,NA
" is the first goal (hypothesis), invoking R2, and we must prove ",NA,NA
a(X),NA,NA
". This in turn invokes R3, which invokes R8. R8 succeeds because ",NA,NA
c,NA,NA
 is a fact. But ,NA,NA
i,NA,NA
 is not a fact (nor are ,NA,NA
"there any rules for it), so R3 fails. R3 is the only rule for proving ",NA,NA
a(X),NA,NA
", so R2 fails too. ",NA,NA
"So we try the next goal, ",NA,NA
d,NA,NA
". R4 is the first applicable rule, and as before, ",NA,NA
i,NA,NA
" is not a fact nor provable, so R4 fails. ",NA,NA
We thus invoke R5 to prove ,NA,NA
d,NA,NA
. The fact ,NA,NA
e(a),NA,NA
 matches ,NA,NA
e(X),NA,NA
", and ",NA,NA
c,NA,NA
" is a fact, so ",NA,NA
d,NA,NA
 is proved. ,NA,NA
"(c) Yes, because if ",NA,NA
c,NA,NA
 and ,NA,NA
j(b),NA,NA
 come before ,NA,NA
e(a),NA,NA
" in the initial facts, the alternative goal ",NA,NA
k(b),NA,NA
 will be proved first ,NA,NA
instead. ,NA,NA
"(d) No, fact order doesn't affect backward chaining unless there are facts with the same predicate name, which ",NA,NA
"isn't true here. (If some of the facts had the same predicate name, different variables might be bound in the final ",NA,NA
"goal, a problem that doesn't arise unless goals have variables.) ",NA,NA
6-5. (a) ,NA,NA
u,NA,NA
", ",NA,NA
b,NA,NA
", ",NA,NA
m(12),NA,NA
", ",NA,NA
a,NA,NA
. Steps in order: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (11 of 36) [23/04/2002 17:39:40],NA
1. Fact ,NA,NA
r,NA,NA
 creates new rules ,NA,NA
t :- s.,NA,NA
 and ,NA,NA
u :- v.,NA,NA
2. Fact ,NA,NA
v,NA,NA
 creates the new rule ,NA,NA
a :- t,NA,NA
"., and proves the fact ",NA,NA
u,NA,NA
 . ,NA,NA
3. Fact ,NA,NA
u,NA,NA
 creates the new rule ,NA,NA
"a :- b, not(t).",NA,NA
4. Fact ,NA,NA
c,NA,NA
 proves the fact ,NA,NA
b,NA,NA
. ,NA,NA
5. Fact ,NA,NA
b,NA,NA
 creates the new rules ,NA,NA
a :- not(t).,NA,NA
 and ,NA,NA
m(X) :- n(X).,NA,NA
6. Fact ,NA,NA
n(12),NA,NA
 proves ,NA,NA
m(12),NA,NA
. ,NA,NA
7. Fact ,NA,NA
m(12),NA,NA
 proves nothing. ,NA,NA
"8. No facts remain unexplored, so we examine the rule with the ",NA,NA
not,NA,NA
. Since ,NA,NA
t,NA,NA
" is not a fact, the ",NA,NA
not ,NA,NA
"succeeds, and this proves ",NA,NA
a,NA,NA
. ,NA,NA
9. Fact ,NA,NA
a,NA,NA
 proves nothing. ,NA,NA
(b) ,NA,NA
b,NA,NA
", ",NA,NA
u,NA,NA
", ",NA,NA
m(12),NA,NA
", ",NA,NA
a,NA,NA
. Fact order doesn't matter here since all facts have different predicate names. Steps in order: ,NA,NA
1. The first three rules fail because all mention at least one thing that doesn't match a fact. ,NA,NA
2. The fourth rule succeeds since ,NA,NA
c,NA,NA
" is a fact, so the new fact ",NA,NA
b,NA,NA
 is asserted. The rule is deleted. ,NA,NA
3. The fifth rule fails. ,NA,NA
4. The sixth and last rule succeeds because ,NA,NA
v,NA,NA
 and ,NA,NA
r,NA,NA
 are both facts. So new fact ,NA,NA
u,NA,NA
 is asserted. The ,NA,NA
rule is deleted. ,NA,NA
5. The first two rules again fail. ,NA,NA
6. The third rule succeeds because ,NA,NA
n(12),NA,NA
 and ,NA,NA
b,NA,NA
 are now facts. New fact ,NA,NA
m(12),NA,NA
 is asserted. This ,NA,NA
rule is not deleted because it contains a variable on its left side. ,NA,NA
7. No further rules succeed. ,NA,NA
8. Now the ,NA,NA
not,NA,NA
"s are considered. In the second rule, ",NA,NA
t,NA,NA
" is not a fact, so ",NA,NA
not(t),NA,NA
" succeeds, as well as ",NA,NA
b,NA,NA
 ,NA,NA
and ,NA,NA
a,NA,NA
. So fact ,NA,NA
a,NA,NA
 is asserted. ,NA,NA
9. No further rules succeed. ,NA,NA
"(c) Index the predicate names on right sides of rules, and index ",NA,NA
not,NA,NA
's. Then you need only check rules that ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (12 of 36) [23/04/2002 17:39:40],NA
"contain predicate names of facts proved on the last cycle, and you can find ",NA,NA
not,NA,NA
s fast. Also you can also delete ,NA,NA
rules that succeed whose left sides do not contain variables. ,NA,NA
6-7. The minimum of L and S. Each cycle must prove something to keep things going. There are only L ,NA,NA
"different things provable, so L is an upper bound. But each cycle must match also at least one new predicate ",NA,NA
"name on a rule right side so that a new rule can succeed. So if there are S right-side names, S is an upper ",NA,NA
bound too. ,NA,NA
6-8.(a) Backward chaining means reasoning from hypotheses to facts. Here the hypotheses are actions the ,NA,NA
"robot may take, which we must consider in the order given. Hence the first hypothesis we examine is ""turn ",NA,NA
"around"", and the rule order is: ",NA,NA
"R1 fails, turn-around hypothesis fails, try stop-and-wait hypothesis, R3, R4, R16, R8 fails (no ",NA,NA
"moving branches visible), R9 succeeds (so second object is an animal), R16 fails (four branches ",NA,NA
"not present), R17 succeeds (so second object is a person), R4 succeeds, R3 fails (because robot ",NA,NA
"isn't ""beneath"" anything), R5 succeeds (the only other way to achieve the stop-and-wait ",NA,NA
"hypothesis, and it succeeds because we've already proved the second object is an animal). ",NA,NA
"You could also put R10 and R11 before first invocation of R16, if you interpreted ""person or vehicle"" in rule ",NA,NA
R4 as a single concept. ,NA,NA
"(b) Now we take the facts, in order, and reason about what other facts they imply: ",NA,NA
"--Fact F1 matches expressions in rules R13, R14, and R16. ",NA,NA
--Fact F2 matches expressions in rule R13. ,NA,NA
--Fact F3 matches expressions in rule R12. ,NA,NA
"--Fact F4 matches expressions in rule R12, and that rule is completely satisfied. Hence the first ",NA,NA
"object is an obstacle, and call that fact F4.1. ",NA,NA
"--Fact F4.1 matches expressions in rules R6, R13, R14, and R15. Now R13 is completely ",NA,NA
"satisfied. Hence the object to the right is a bush, and call this fact F4.2. ",NA,NA
--Fact F4.2 matches expressions in rules R2 and R3. ,NA,NA
--Fact F5 matches expressions in rules R4 and R5. ,NA,NA
"--Fact F6 matches expressions in rules R9 and R17, and R9 is satisfied. Hence the second object is ",NA,NA
"an animal, and call that fact F6.1. ",NA,NA
"--Fact F6.1 matches expressions in R16 and R17, and R17 is completely satisfied. Hence the ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (13 of 36) [23/04/2002 17:39:40],NA
"second object is a person, and call that fact F6.2. ",NA,NA
"--Fact F6.2 matches expressions in rule R4, and that rule is completely satisfied. Hence we must ",NA,NA
"hide, and call that fact F6.3. ",NA,NA
"--Fact F6.3 matches expressions in rule R2, and that rule is completely satisfied. Hence we turn ",NA,NA
towards the bush and move a short distance. ,NA,NA
"(c) The backwards chaining used a fixed-rule-priority conflict resolution, and forward chaining used a fixed-",NA,NA
fact-priority (with focus-of-attention) in addition to fixed-rule-priority. An alternative for forward chaining ,NA,NA
"would be to add new facts at the end of the facts, while we still fetch from the front as with a queue. This ",NA,NA
would be good when we want to infer everything possible from a set of facts. An alternative for backward ,NA,NA
"chaining would be a ""biggest-rule-first"" strategy in which the rule with the most conditions in its ""if"" part is ",NA,NA
tried first. Concurrency and partitioning ideas could work for both forward and backward control structures. ,NA,NA
"We could also use a ""most-related-rule"" criterion, if we define ""relatedness"" for any rule pair. ",NA,NA
"6-9. (a) No, since a conclusion may depend on the absence of some fact. That fact may no longer be absent ",NA,NA
when a file is loaded in later. ,NA,NA
"(b) Yes, because caching just makes things already found easier to verify. Provability of conclusions is not ",NA,NA
"affected, just efficiency. ",NA,NA
"(c) No, since new facts could be asserted that are unreachable by backward chaining. So a conclusion that ",NA,NA
depends on the absence of something might suddenly go from being true to being false. ,NA,NA
"6-12. (a) Forward chaining sounds better, since the system only need reason about sensor readings that ",NA,NA
"changed from its last analysis (assuming we cache the conclusions from the last analysis), and changes to ",NA,NA
sensor readings will be relatively rare. And probably a lot of different goals (conclusions) can be reached. ,NA,NA
"(b) It's true that forward chaining caches automatically, so extra caching would seem unnecessary. But the best ",NA,NA
way to use this rule-based system is to run it repeatedly every second or so. Then conclusions learned during the ,NA,NA
last second could be useful in reasoning during this second--especially conclusions based on things that don't ,NA,NA
"change often--so caching the previous conclusions could be useful. Also, caching could mean storing (in the ",NA,NA
rule-based system database) facts about the condition of sensors instead of directing the computer to look at its ,NA,NA
input/output ports to find those values. This also will be good because many sensors will infrequently change ,NA,NA
with time. ,NA,NA
"(c) Virtual facts don't make sense with forward chaining. If you suggested backward chaining in part (a), ",NA,NA
"virtual facts might make sense if you interpret them as ""queries"" to sensor input/output ports. If you interpret ",NA,NA
"them as queries to the user, they don't make sense because that would be an big imposition on the user. ",NA,NA
"(d) Yes, since there are clear categories of rules that don't interact much. For instance, the rules for handling ",NA,NA
"burglars might not be in the database all the time, but only loaded when there is good evidence that a burglar is ",NA,NA
"present. Rules for fires and other emergencies are similar. However, the rules for ",NA,NA
recognizing,NA,NA
 potential burglar ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (14 of 36) [23/04/2002 17:39:40],NA
"and fire situations, that decide to load the detail-analyzing code, must be kept in main memory at all times. ",NA,NA
"(e) This is a closer judgment than the other parts of this question, but decision lattices are probably not a good ",NA,NA
"idea. In the first place, you don't want to use them in a way so that you actually ask a human questions--that ",NA,NA
"would be an imposition. But the decision lattice could ""ask"" questions of the sensors to get their readings. The ",NA,NA
main difficulty is in building the decision lattice in the first place. There will be many different situations to ,NA,NA
"handle, and it's hard to figure out what questions distinguish situations well, especially when houses are all ",NA,NA
different and you don't know what situations you'll get into; and it's the very rare emergency situations that are ,NA,NA
"most critical to program properly. Furthermore, decision lattices are hard to modify, and hard to partition into ",NA,NA
"modules. So for the advantages of a decision lattice, it would seem better to go with an and-or-not lattice, for ",NA,NA
which the translation from rules to lattice is much easier. ,NA,NA
(f) Yes. Improved speed in inferencing is an obvious advantage over noncompiled forms. And-or-not lattices ,NA,NA
"have the advantage of being easy to partition if the original rule-based system was easy to partition, like this ",NA,NA
"one; partitioning a decision lattice is much harder, and since this application can easily be complex, inability to ",NA,NA
"partition into modules is a serious disadvantage. And-or-not lattices are easier to modify than decision lattices, ",NA,NA
since they correspond closely to rules. And-or-not lattices could also standardize certain commonly-made ,NA,NA
"inferences, so these could be mass-produced and a smaller, more house-specific computer could handle the rest ",NA,NA
"of the reasoning. For instance, the conditions for suspecting a burglar and loading burglar-analysis rules are ",NA,NA
pretty much standard for all houses and with all burglars: check for unusual noises and for windows and doors ,NA,NA
"being forced open, especially at night and when the house is not occupied. As another example, equipment ",NA,NA
requiring complicated continuous monitoring like an aquarium could be monitored according to a special and-,NA,NA
"or-not lattice supplied by the aquarium manufacturer, and only reports of major problems passed on to the ",NA,NA
"central processor. It's true that and-or-not lattices have trouble handling variables, but this rule-based system ",NA,NA
doesn't much need them: use no-argument predicates to represent sensor values and value ranges. ,NA,NA
7-1. Here's one way: ,NA,NA
"diagnosis('Fuse blown') :- power_problem, askif(lights_out).",NA,NA
"diagnosis('Fuse blown') :- power_problem, askif(hear(pop)).",NA,NA
"diagnosis('Break in cord') :- power_problem, askif(cord_frayed).",NA,NA
"diagnosis('Short in cord') :- diagnosis('fuse blown'),",NA,NA
 askif(cord_frayed).,NA,NA
"diagnosis('Device not turned on') :- power_problem, klutz_user,",NA,NA
" askif(has('an on-off switch or control')), askifnot(device_on).",NA,NA
"diagnosis('Cord not in socket properly') :- power_problem,",NA,NA
" klutz_user, askif(just_plugged), askifnot(in_socket).",NA,NA
diagnosis('Internal break in the wiring') :-,NA,NA
" power_problem, jarring.",NA,NA
diagnosis('Foreign matter caught on heating element') :-,NA,NA
" heating_element, not(power_problem), askif(smell_smoke).",NA,NA
diagnosis('Appliance wet--dry it out and try again') :-,NA,NA
" power_problem, klutz_user, askif(liquids).",NA,NA
"diagnosis('Controls adjusted improperly') :- klutz_user,",NA,NA
 askif(has('knobs or switches')).,NA,NA
"diagnosis('Motor burned out') :- askif(smell_smoke),",NA,NA
 mechanical_problem.,NA,NA
diagnosis('Something blocking the mechanical operation') :-,NA,NA
 mechanical_problem.,NA,NA
"diagnosis('Kick it, then try it again') :- mechanical_problem. ",NA,NA
diagnosis('Throw it out and get a new one').,NA,NA
power_problem :- askif(device_dead).,NA,NA
"power_problem :- askif(has('knobs or switches')),",NA,NA
 askifnot(knobs_do_something).,NA,NA
"power_problem :- askif(smell_smoke), not(heating_element).",NA,NA
klutz_user :- askifnot(handyperson).,NA,NA
klutz_user :- askifnot(familiar_appliance).,NA,NA
"mechanical_problem :- askif(hear('weird noise')),",NA,NA
 askif(has('moving parts')).,NA,NA
heating_element :- askif(heats). ,NA,NA
heating_element :- askif(powerful).,NA,NA
jarring :- askif(dropped). ,NA,NA
jarring :- askif(jarred).,NA,NA
"questioncode(device_dead,'Does the device refuse to do anything').",NA,NA
"questioncode(knobs_do_something,'Does changing the switch",NA,NA
 positions or turning the knobs change anything').,NA,NA
"questioncode(lights_out,",NA,NA
 'Do all the lights in the house seem to be off').,NA,NA
"questioncode(code_frayed,",NA,NA
 'Does the outer covering of the cord appear to be coming apart'). ,NA,NA
"questioncode(handyperson,'Are you good at fixing things').",NA,NA
"questioncode(familiar_appliance,",NA,NA
 'Are you familiar with how this appliance works').,NA,NA
"questioncode(device_on,'Is the ON/OFF switch set to ON').",NA,NA
"questioncode(just_plugged,'Did you just plug the appliance in'). ",NA,NA
"questioncode(in_socket,'Is the cord firmly plugged into the socket'). ",NA,NA
"questioncode(smell_smoke,'Do you smell smoke').",NA,NA
"questioncode(liquids,",NA,NA
 'Have any liquids spilled on the appliance just now').,NA,NA
"questioncode(heats,'Does the appliance heat things').",NA,NA
"questioncode(powerful,'Does the appliance require a lot of power'). ",NA,NA
"questioncode(has(X),X) :- write('Does the appliance have ').",NA,NA
"questioncode(hear(X),X) :- write('Did you hear a ').",NA,NA
"questioncode(dropped,'Has the appliance been dropped recently').",NA,NA
"questioncode(jarred,'Has the appliance been violently jarred recently').",NA,NA
7-2. Use the same idea of ,NA,NA
coded_diagnosis,NA,NA
 at the end of Section 7.4. Query instead of ,NA,NA
diagnosis,NA,NA
: ,NA,NA
"better_diagnosis(D) :- diagnosis(D), not(found(D)), asserta(found(D)). ",NA,NA
Now ,NA,NA
"if the user types a semicolon after a diagnosis, the program will backtrack through the ",NA,NA
asserta,NA,NA
 and ,NA,NA
found ,NA,NA
to try ,NA,NA
"to find another, but if D gets rebound to any previous value, the ",NA,NA
not,NA,NA
 will fail and the interpreter returns to ,NA,NA
"""diagnosis"". This also works for any order of diagnosis rules; rules for the same diagnosis need not be together. ",NA,NA
"7-5. (a) One unit of time is needed if the first cached item matches the query, two units of time if the second ",NA,NA
"matches the query, three units of time if the third, and so on. Since we were told the probabilities are mutually ",NA,NA
"exclusive, the probability that no item in the cache matches the query is |1 - KP|. Then the condition for the ",NA,NA
problem is ,NA,NA
P + 2P + 3P + ... + KP + ( 1 - KP ) ( R + K )    <   R ,NA,NA
"The left side of the inequality contains an arithmetic series, so we can substitute its formula and get ",NA,NA
P K ( K + 1 ) / 2   +   ( 1 - KP ) K   <    KPR ,NA,NA
or ,NA,NA
( K + 1 ) / 2   +   ( 1 / P )   -   K   < R,NA,NA
( 2 + P - PK ) / 2P   <   R ,NA,NA
"Since |KP < .1|, it's also true that |P < .1|, so we can approximate the inequality by just ",NA,NA
PR > 1 ,NA,NA
"(b) Analysis is similar, but the sum over the cache items has a different formula: ",NA,NA
P + ( 2 * P / 2 ) + ( 3 * P / 3 ) + ... ( K * P / K )   =   KP ,NA,NA
so the criterion becomes ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (17 of 36) [23/04/2002 17:39:40],NA
KP + ( R + K ) ( 1 - P log sub 2 ( K + 1 ) )   <   R,NA,NA
or ,NA,NA
K ( P + 1 )   <   P ( R + K ) log sub 2 ( K + 1 ),NA,NA
"If |PK < .1| then because |P < PK| we know P is negligible compared to 1, so we can approximate this by ",NA,NA
1    <   P ( ( R / K ) + 1 ) log sub 2 ( K + 1 ),NA,NA
7-11. (a) ,NA,NA
"or(P,Q) :- call(P).",NA,NA
"or(P,Q) :- call(Q).",NA,NA
(b) ,NA,NA
"if(P,Q,R) :- call(P), call(Q).",NA,NA
"if(P,Q,R) :- not(call(P)), call(R).",NA,NA
(c) ,NA,NA
"case(P,N,L) :- call(P), item(N,L,I), call(I).",NA,NA
"item(1,[X|L],X).",NA,NA
"item(N,[X|L],I) :- N>1, N2 is N-1, item(N2,L,I).",NA,NA
8-3.(a) So ,NA,NA
<prob1>,NA,NA
" is |200 / 500 = 0.4|, and ",NA,NA
<prob2>,NA,NA
 is |800 / 1600 = 0.5|. The 1200 flat tires are irrelevant. ,NA,NA
"(b) The ratio 70/101 is approximately 0.69, and this is closest to 0.7, the independence-assumption ",NA,NA
"combination (obtained from |1 - ( 1 - 0.4 ) ( 1 - 0.5 )|). Conservative assumption gives |""maxfunction"" ( 0.4 , ",NA,NA
"0.5 ) = 0.5|, and liberal gives |0.4 + 0.5 = 0.9|. ",NA,NA
"8-4.(a) conservative, since the function is the maximum of the two arguments. ",NA,NA
(b) liberal. It can't be conservative since the values in the table are better than the previous table. It can't be ,NA,NA
"independence-assumption because the combination of two ""probably""s is a ""definitely"", something impossible ",NA,NA
"with the independence formula (that is, the independence formula can't give a 1.0 unless one of its inputs is ",NA,NA
1.0). The arithmetic (see part (c)) is consistent with liberal combination too. ,NA,NA
"(c) Let |x| be the probability of ""probably not"", |y| the probability of ""probably"". Then the table and the liberal-",NA,NA
"combination formula say that |x + x = y| and |minfunction ( x + y , 1.0 ) = 1.0 |. So |2x = y| and |minfunction ( ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (18 of 36) [23/04/2002 17:39:40],NA
"3x , 1.0 ) = 1.0 |. Hence |x > 0.3333| from the last equation. But |y| must be less than 1.0 (""probably"" should be ",NA,NA
"less certain than ""definitely"") so |2x < 1.0| and |x < 0.5|. So |x| can be anything between 0.3333 and 0.5, and |y| ",NA,NA
must be correspondingly between 0.6667 and 1.0. (Notice that an infinity of possible answers doesn't mean ,NA,NA
any,NA,NA
 ,NA,NA
answer is right.) ,NA,NA
"8-5. No. There is no problem with either backward chaining, forward chaining, or any hybrid. Facts must ",NA,NA
"always have probability values filled in (or else be certain, implying a probability of 1.0), so any rules ",NA,NA
combining those probabilities will work no matter how they're used. ,NA,NA
8-6.(a) You must be careful to count separately the length of the list and the number of probabilities greater ,NA,NA
than 0.5. One way to do it: ,NA,NA
"orcombine(PL,P) :- numbigprobs(PL,Nbig), length(PL,N), P is Nbig / N.",NA,NA
"numbigprobs([],0).",NA,NA
"numbigprobs([P|PL],N) :- numbigprobs(PL,N), P < 0.5.",NA,NA
"numbigprobs([P|PL],N) :- numbigprobs(PL,N2), P >= 0.5, N is N2 + 1.",NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2 + 1.",NA,NA
Another way is to define a ,NA,NA
censor,NA,NA
 predicate that removes probabilities from a list that are less than 0.5: ,NA,NA
"orcombine(PL,P) :- length(PL,N), censor(PL,CPL), length(CPL,Nbig),",NA,NA
 P is Nbig / N.,NA,NA
"length([],0).",NA,NA
"length([X|L],N) :- length(L,N2), N is N2 + 1.",NA,NA
"censor([],[]).",NA,NA
"censor([P|PL],[P|PL2]) :- censor(PL,PL2), P >= 0.5.",NA,NA
"censor([P|PL],PL2) :- censor(PL,PL2), P < 0.5.",NA,NA
(b) Some answers: ,NA,NA
--There are abrupt changes in the total probability when probabilities vary slightly from 0.5. It ,NA,NA
"doesn't seem reasonable that any evidence combination method have such abrupt ""jumps"" as ",NA,NA
probabilities vary slightly. ,NA,NA
--The number 0.5 is arbitrary--there's no good reason for it. ,NA,NA
"--The total probability with this method can be less than the ""conservative"" combination value; ",NA,NA
"for example, ",NA,NA
"[0.4,0.4]",NA,NA
" has 0 total with the method, 0.4 with the ""conservative"" method. But the ",NA,NA
"conservative method gives the smallest logically reasonable value, so this method isn't always ",NA,NA
reasonable. ,NA,NA
--This method is inaccurate when few probabilities are combined. If there's only one probability in ,NA,NA
"the list presented for combination, then the cumulative probability is either 0 or 1, totally ignoring ",NA,NA
the probability of that one item. ,NA,NA
"--This method can't handle ""cascades"" very easily. That is, if the result of this method is an input ",NA,NA
"to a combination in another rule, we've lost the important information about the number of ",NA,NA
"probabilities contributing to the first result, which should greatly affect how much it should be ",NA,NA
counted for in the second combination. ,NA,NA
"8-9. (a) Newspapers and television report unusual and striking events, so you don't hear about the many more ",NA,NA
people that spent their money on the lottery and didn't win anything. ,NA,NA
"(b) In this example, successes in the lottery are broadcast much more strongly than failures, causing ",NA,NA
"overestimation of the probability of success. This ""biased sampling"" problem is a chief difficulty in building ",NA,NA
rule-based systems from data: you must be careful there aren't reasons why certain data is overreported or ,NA,NA
"underreported. For instance, embarassment might make people underestimate the frequency with which they ",NA,NA
forget to plug appliances in. ,NA,NA
"9-2. For inheritance, the goal condition is to find some other target object that has the property value you want, ",NA,NA
"and has an inheriting link, like ",NA,NA
a_kind_of,NA,NA
", to a given object. Looking for such a target object is a search starting ",NA,NA
"from the given object. There can be several inheriting links for an object, each representing an alternative ",NA,NA
"direction to explore, and these represent branches. And one choice affects later choices. ",NA,NA
9-10. Just subtract K from the values of the old evaluation function to get a new evaluation function which is ,NA,NA
guaranteed to be a lower bound. Then you can use A* search with the optimality guarantee. ,NA,NA
9-11.(a) See Figure G-1. ,NA,NA
(b) Choose the state (among those so far discovered at some point in the problem) that has lowest evaluation ,NA,NA
"function value. State sequence: a, d, c, b, f, e, g, h. ",NA,NA
"(c) Add the cost to reach a state to the evaluation function. Costs to states: a: 0, b: 2, c: 5, d: 9, e: 7, f: 11, g: 7, h: ",NA,NA
"11. Sum of cost and evaluation function: a: 10, b: 10, c: 12, d: 14, e: 13, f: 15, g: 16, h: 25. State sequence: a, b, ",NA,NA
"c, e, d, f, g, h. ",NA,NA
9-13. (a) All ,NA,NA
"[<left-bank>,<right-bank>]",NA,NA
", where ",NA,NA
<left-bank>,NA,NA
 and ,NA,NA
<right-bank>,NA,NA
 are lists together containing ,NA,NA
"the symbols man, lion, fox, goose, corn, and boat. And ",NA,NA
<left-bank>,NA,NA
" is things on the left side of the river, ",NA,NA
<right-bank>,NA,NA
 things on the right. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (20 of 36) [23/04/2002 17:39:40],NA
(b) The start is ,NA,NA
"[[man,lion,fox,goose,corn,boat],[]]",NA,NA
 and goal is ,NA,NA
"[[],[man,lion,fox,goose,corn,boat]]",NA,NA
. ,NA,NA
"(c) Man and boat; man, lion, and boat; man, fox, and boat; man, goose, and boat; man, corn, and boat; man, ",NA,NA
"fox, corn, and boat; or man, goose, corn, and boat move from one side of the river to the other. ",NA,NA
"(d) The starting state has only one successor, ",NA,NA
"[[lion,goose],[man,fox,corn,boat]]",NA,NA
", which has three successors ",NA,NA
of its own (besides the starting state): ,NA,NA
"[[man,lion,goose,boat],[fox,corn]].",NA,NA
"[[man,lion,fox,goose,boat],[corn]].",NA,NA
"[[man,lion,goose,corn,boat],[fox]].",NA,NA
(e) |( 1 + 3 ) / 2 = 2| ,NA,NA
"(f) Each thing can be in one of two places, and there are five things (the man must always be with the boat), ",NA,NA
hence |2 sup 5 = 32|. ,NA,NA
"(g) No, subparts interact. ",NA,NA
9-15.(a) The set of all possible coating patterns. ,NA,NA
"(b) No, there are many different states (coating patterns) that satisfy the goal conditions, and no easy way to find ",NA,NA
"them. (If you knew any of them, you wouldn't need to search.) So backward search isn't possible, and hence ",NA,NA
"bidirectional search isn't either. (Notice that despite similarities, this problem is quite different from city-route ",NA,NA
"planning: the goal is a configuration of coatings, not a location.) ",NA,NA
"(c) It always decreases. Every branch involves coating a grid cell, thus removing it from the pool of coatable ",NA,NA
"cells. As you proceed, previously-coatable cells may become uncoatable because they would connect coated ",NA,NA
"regions that shouldn't be connected, so the branching factor may decrease by more than one per level, but it ",NA,NA
will always decrease. ,NA,NA
"(d) Many heuristics are possible, including: ",NA,NA
"--Prefer to coat cells adjacent to the last cell you coated (a ""focus of attention"" heuristic). -",NA,NA
-Prefer to coat cells that lie on a straight line between points you want to connect. ,NA,NA
"--As soon as a desired connection is made between two points, prefer not to coat any cells ",NA,NA
within five cells of either of those points. ,NA,NA
"--Prefer to coat cells that continue a straight line (e.g., coat [X,Y] if [X-1,Y] and [X-2,Y] are ",NA,NA
both coated). ,NA,NA
10-1.(a) Change the definition of ,NA,NA
depthsearch,NA,NA
 to read ,NA,NA
"depthsearch(Start,Ans) :- depthsearch2(Start,[Start],Ans),",NA,NA
 print_reverse(Ans).,NA,NA
and include the definition ,NA,NA
print_reverse([]) :- !.,NA,NA
"print_reverse([X|L]) :- print_reverse(L), write(X), nl.",NA,NA
"(b) Add to the front of all state lists the name of the last operator used to reach that state (or ""none"" for the ",NA,NA
"starting state). (This assumes that states are represented by lists, as in most applications.) Then modify all ",NA,NA
successor,NA,NA
", ",NA,NA
goalreached,NA,NA
", ",NA,NA
eval,NA,NA
", and ",NA,NA
cost,NA,NA
 predicate definitions to ignore the first term of the input state ,NA,NA
"description, and modify all ",NA,NA
successor,NA,NA
 predicate definitions to set the first item of the output successor state to ,NA,NA
an operator name appropriate to the purpose of each such rule or fact. ,NA,NA
(c) Replace the ,NA,NA
member,NA,NA
 in ,NA,NA
"not(member(Newstate,Statelist))",NA,NA
 by ,NA,NA
permutedmember,NA,NA
", defined as: ",NA,NA
"permutedmember(L1,L2) :- subset(L1,L2), subset(L2,L1), !.",NA,NA
"subset([],[]) :- !.",NA,NA
"subset([X|L1],L2) :- member(X,L2), !, subset(L1,L2).",NA,NA
where ,NA,NA
member,NA,NA
 is defined as before. ,NA,NA
10-5. Refer to states as a pair of numbers representing fluid quantities in the size-5 and size-7 glasses ,NA,NA
"respectively. So [3,4] means 3 units in the size-5 glass and 4 units in the size-7 glass. ",NA,NA
"(a) The states form a circle (excluding [5,7] which is only reachable when the goal amount is 5 or 7). Two ",NA,NA
"solutions are always found for goal amounts 1, 2, 3, 4, and 6, one from going around the circle clockwise and ",NA,NA
"one counterclockwise, both stopping at the first state satisfying the goal condition. (To see this behavior, it's ",NA,NA
important to avoid duplicating the same state at different places in the search graph.) ,NA,NA
"(b) The breadth-first state graph is augmented by extra links to the states [5,0], [0,7], and [5,7]. Links to the first ",NA,NA
"occur from states [5,X] and [X,0] for certain X, to the second from [X,7] and [0,X] for certain other X, and to ",NA,NA
"the third from [X,7] and [5,X] for certain other X. On such transitions, the search ""starts over"" in the opposite ",NA,NA
"direction around the circle (so if movement was clockwise before the transition, afterwards it is ",NA,NA
"counterclockwise). Only one such transition can occur in a solution path, except when the goal amount is 5 or 7. ",NA,NA
"(c) The eight rules make four pairs, for which the first rule of each pair refers principally to the first glass, the ",NA,NA
"second rule to the second glass. The first pair empties one glass into another, the second pair fills one glass ",NA,NA
"from another, the third pair fills a glass from the faucet, and the fourth pair empties a glass into the drain. ",NA,NA
(d) Delete the second ,NA,NA
goal_reached,NA,NA
 fact. ,NA,NA
10-7. Branch-and-bound search is just an A* search in which the evaluation function is always zero. So just to ,NA,NA
use the definition ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (22 of 36) [23/04/2002 17:39:40],NA
"eval(S,0).",NA,NA
with the A* program. That will work fine if the problem-independent file is always loaded before the problem-,NA,NA
"dependent file. But if you can't be sure, you can remove the ",NA,NA
eval,NA,NA
 predicate from the ,NA,NA
add_state,NA,NA
 predicate ,NA,NA
definition: ,NA,NA
"add_state(Newstate,Pathlist) :- not(agenda(Newstate,P,C)),",NA,NA
" not(oldagenda(Newstate,P2,C2)), cost([Newstate|Pathlist],Cnew), ",NA,NA
"asserta(agenda(Newstate,[Newstate|Pathlist],Cnew)).",NA,NA
"10-10. (a) Represent states as a list of pairs, where the first element of each pair is the name of a chemical and ",NA,NA
the second element is its amount in moles. Define ,NA,NA
increase,NA,NA
 and ,NA,NA
remove,NA,NA
 predicates that change the amount of a ,NA,NA
"chemical in a state list. (Write ""remove"" to fail when it can't find the specified chemical in the state, so you ",NA,NA
don't need a ,NA,NA
member,NA,NA
 predicate.) ,NA,NA
"go(Ans) :- search([[cl2,2],[mno2,1],[caco3,1],[h2o2,2]],Ans).",NA,NA
"goalreached(S) :- member([cacl2,N],S), N >= 1.",NA,NA
"successor(S,[[C,Nsum]|S3]) :- remove(C,N1,S,S2),",NA,NA
" remove(C,N2,S2,S3), Nsum is N1 + N2.",NA,NA
"successor(S,S6) :- remove(cl2,Ncl2,S,S2), remove(h2o,Nh2o,S2,S3), ",NA,NA
"N is Ncl2 - Nh2o, N >= 0, increase(cl2,N,S3,S4),",NA,NA
" increase(hclo,Nh2o,S4,S5), increase(hcl,Nh2o,S5,S6).",NA,NA
"successor(S,S6) :- remove(cl2,Ncl2,S,S2),",NA,NA
" remove(h2o,Nh2o,S2,S3), N is Nh2o - Ncl2, N >= 0, ",NA,NA
"increase(h2o,N,S3,S4), increase(hclo,Ncl2,S4,S5), ",NA,NA
"increase(hcl,Ncl2,S5,S6).",NA,NA
"successor(S,S4) :- remove(h2o2,N,S,S2), member([mno2,X],S2), ",NA,NA
"HalfN is N / 2, increase(h2o,N,S2,S3),",NA,NA
" increase(o2,HalfN,S3,S4).",NA,NA
"successor(S,S6) :- remove(caco3,Ncaco3,S,S2),",NA,NA
" remove(hcl,Nhcl,S2,S3), HalfNhcl is Nhcl/2, Ncaco3 >= HalfNhcl, ",NA,NA
"increase(cacl2,HalfNhcl,S3,S4), increase(co2,HalfNhcl,S4,S5), ",NA,NA
"increase(h2o,HalfNhcl,S5,S6).",NA,NA
"successor(S,S6) :- remove(caco3,Ncaco3,S,S2),",NA,NA
" remove(hcl,Nhcl,S2,S3), HalfNhcl is Nhcl/2, Ncaco3 < HalfNhcl, ",NA,NA
"increase(cacl2,Ncaco3,S3,S4), increase(co2,Ncaco3,S4,S5), ",NA,NA
"increase(h2o,Ncaco3,S5,S6).",NA,NA
"successor(S,S5) :- remove(h2,Nh2,S,S2), remove(cl2,Ncl2,S2,S3), ",NA,NA
"Nh2 >= Ncl2, N is Nh2-Ncl2, increase(h2,N,S3,S4),",NA,NA
" TwiceNcl2 is 2*Ncl2, increase(hcl,TwiceNcl2,S4,S5).",NA,NA
"successor(S,S5) :- remove(h2,Nh2,S,S2), remove(cl2,Ncl2,S2,S3), ",NA,NA
"Nh2 < Ncl2, N is Ncl2-Nh2, increase(cl2,N,S3,S4),",NA,NA
" TwiceNh2 is 2*Nh2, increase(hcl,TwiceNh2,S4,S5).",NA,NA
"successor(S,S7) :- remove(hcl,Nhcl,S,S2),",NA,NA
" remove(mno2,Nmno2,S2,S3), QuarterNhcl is Nhcl/4,",NA,NA
" QuarterNhcl >= Nmno2, N is QuarterNhcl - Nmno2,",NA,NA
" increase(hcl,N,S3,S4), TwiceNmno2 is 2*Nmno2,",NA,NA
" increase(mncl2,Nmno2,S4,S5), increase(h2o,TwiceNmno2,S5,S6), ",NA,NA
"increase(cl2,Nmno2,S6,S7).",NA,NA
"successor(S,S7) :- remove(hcl,Nhcl,S,S2),",NA,NA
" remove(mno2,Nmno2,S2,S3), QuarterNhcl is Nhcl/4,",NA,NA
" QuarterNhcl < Nmno2, N is Nmno2 - QuarterNhcl,",NA,NA
" increase(mno2,N,S3,S4), HalfNhcl is Nhcl/2,",NA,NA
" increase(mncl2,QuarterNhcl,S4,S5),",NA,NA
" increase(h2o,HalfNhcl,S5,S6), increase(cl2,Nmno2,S6,S7).",NA,NA
"increase(Chemical,Amount,S,[[Chemical,Newamount]|NewS]) :- ",NA,NA
"failing_delete([Chemical,Oldamount],S,NewS),",NA,NA
" Newamount is Oldamount + Amount, !.",NA,NA
"increase(Chemical,Amount,S,[[Chemical,Amount]|S]).",NA,NA
"remove(Chemical,Amount,S,NewS) :-",NA,NA
" failing_delete([Chemical,Amount],S,NewS).",NA,NA
"failing_delete(X,[X|L],L) :- !.",NA,NA
"failing_delete(X,[Y|L],[Y|L2]) :- failing_delete(X,L,L2).",NA,NA
(b) ,NA,NA
?- go(Answer).,NA,NA
"(11) 11 Call: successor([[cl2,2],[mno2,1],[caco3,1],[h2o2,2]],_8) ",NA,NA
"(11) 11 Back to: successor([[cl2,2],[mno2,1],[caco3,1],[h2o2,2]],_8) ",NA,NA
"(11) 11 Back to: successor([[cl2,2],[mno2,1],[caco3,1],[h2o2,2]],_8) ",NA,NA
"(11) 11 Back to: successor([[cl2,2],[mno2,1],[caco3,1],[h2o2,2]],_8) ",NA,NA
"(11) 11 Exit: successor([[cl2,2],[mno2,1],[caco3,1],[h2o2,2]],",NA,NA
 ,NA,NA
"[[o2,1],[h2o,2],[cl2,2],[mno2,1],[caco3,1]]) ",NA,NA
(63) 19 Call:,NA,NA
" successor([[o2,1],[h2o,2],[cl2,2],[mno2,1],[caco3,1]],_67) ",NA,NA
(63) 19 Back to:,NA,NA
" successor([[o2,1],[h2o,2],[cl2,2],[mno2,1],[caco3,1]],_67) ",NA,NA
(63) 19 Exit:,NA,NA
" successor([[o2,1],[h2o,2],[cl2,2],[mno2,1],[caco3,1]],",NA,NA
" [[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],[caco3,1]])",NA,NA
(112) 28 Call:,NA,NA
" successor([[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],[caco3,1]],_123) ",NA,NA
(112) 28 Back to:,NA,NA
" successor([[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],[caco3,1]],_123) ",NA,NA
(112) 28 Back to:,NA,NA
" successor([[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],[caco3,1]],_123) ",NA,NA
(112) 28 Back to:,NA,NA
" successor([[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],[caco3,1]],_123) ",NA,NA
(112) 28 Back to:,NA,NA
" successor([[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],[caco3,1]],_123) ",NA,NA
(112) 28 Exit:,NA,NA
" successor([[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],",NA,NA
" [caco3,1]],[[h2o,1],[co2,1],[cacl2,1],[hclo,2],[cl2,0],[o2,1],[mno2,1]])",NA,NA
"Answer=[[[h2o,1],[co2,1],[cacl2,1],[hclo,2],[cl2,0],[o2,1],[mno2,1]], ",NA,NA
"[[hcl,2],[hclo,2],[cl2,0],[o2,1],[mno2,1],[caco3,1]],",NA,NA
" [[o2,1],[h2o,2],[cl2,2],[mno2,1],[caco3,1]],",NA,NA
" [[cl2,2],[mno2,1],[caco3,1],[h2o2,2]]] ",NA,NA
yes,NA,NA
"(c) Cost could be the monetary cost of the chemicals needed for all the reactions so far, and the evaluation ",NA,NA
function could be the average cost of a chemical times the number of chemicals not yet in the reaction vessel ,NA,NA
"but desired in the goal state. Or cost could be the danger of doing a sequence of reactions, and the evaluation ",NA,NA
function an estimate of the remaining danger based on the goal state. ,NA,NA
"(d) In the real world, all possible chemical reactions occur simultaneously. To model this for our rules, all that ",NA,NA
"apply should work in parallel somehow. A little of each reaction could be done, time-sharing between reactions ",NA,NA
"cyclically. (To be more precise, reactions should proceed at different speeds determined by ",NA,NA
equilibrium ,NA,NA
constants,NA,NA
" for each reaction, which can be modeled by ""biased"" time-sharing.). ",NA,NA
"10-12. (a) 16 states, if the goal state is on the final (leaf) level. ",NA,NA
"(b) 16 as well. With best-first search, the agenda can contain states at many levels. But if it does contain states at ",NA,NA
levels other than level 4 (the leaf level) then we could substitute in the successors of those states to get a bigger ,NA,NA
"possible agenda. Therefore the largest agenda must contain only level 4 (leaf states), and there are 16 of those. ",NA,NA
10-15. This is what the ,NA,NA
foriterate,NA,NA
" predicate definition does, so just query: ",NA,NA
"call(P,K) :- foriterate(call(P),K).",NA,NA
So just use the two-argument version of ,NA,NA
call,NA,NA
 instead of the usual one-argument form. If for instance you ,NA,NA
wanted to print out the third value of ,NA,NA
X,NA,NA
 to which the expression ,NA,NA
a(X),NA,NA
" can be matched, you would query: ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (25 of 36) [23/04/2002 17:39:40],NA
"?- call(a(X),3), write(X).",NA,NA
11-1. These correspond to the ,NA,NA
recommended,NA,NA
 definitions. And rules for such household hints should go in ,NA,NA
front of default ,NA,NA
recommended,NA,NA
 rules for the same situations. ,NA,NA
11-4. You need new predicates to describe the condition of the plate--let's say ,NA,NA
on,NA,NA
 and ,NA,NA
off,NA,NA
 with argument ,NA,NA
"""plate"". A starting state for the testing can be ",NA,NA
"[closed(case),closed(top),inside(batteries),defective(batteries),",NA,NA
" defective(light),unbroken(case),on(plate)] ",NA,NA
with the goal ,NA,NA
"[ok(batteries),ok(light),closed(case),closed(top)] ",NA,NA
Define new operators ,NA,NA
remove_plate,NA,NA
 and ,NA,NA
replace_plate,NA,NA
 this way: ,NA,NA
"recommended([off(plate)],remove_plate). ",NA,NA
"recommended([on(plate)],replace_plate).",NA,NA
"precondition(remove_plate,[open(top),on(plate)]). ",NA,NA
"precondition(replace_plate,[open(top),off(plate)]).",NA,NA
"deletepostcondition(remove_plate,[on(plate)]). ",NA,NA
"deletepostcondition(replace_plate,[off(plate)]).",NA,NA
"addpostcondition(remove_plate,[off(plate)]).",NA,NA
"addpostcondition(replace_plate,[on(plate)]).",NA,NA
"To relate the new predicates and operators to the code written before, modify the preconditions of ",NA,NA
replace_light,NA,NA
 and ,NA,NA
assemble_top,NA,NA
: ,NA,NA
"precondition(replace_light,[off(plate),open(top)]).",NA,NA
"precondition(assemble_top,[on(plate),open(top)]).",NA,NA
"11-6. Means-ends analysis is recursive, and recursion requires a stack when implemented in a computer. Laying ",NA,NA
"out the parts in the order you remove them from the car is like keeping a stack, so you can ""pop"" them--that is, ",NA,NA
put them back into the car--in the reverse of the order they came out. It's not fair to say the parts are ,NA,NA
"preconditions to operators, however; they're just props used in achieving preconditions, and the real ",NA,NA
preconditions are abstract notions. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (26 of 36) [23/04/2002 17:39:40],NA
11-7. Just write two different ,NA,NA
precondition,NA,NA
" facts, one for each set of preconditions. Put the set you think more ",NA,NA
"likely to succeed first. If it can't be satisfied, backtracking will take the second set of preconditions. Nothing ",NA,NA
we've said requires a unique ,NA,NA
precondition,NA,NA
 rule for each operator. ,NA,NA
"12-3.(a) A value inherited must be for a slot that's filled in for the ""purchase order"" frame. Unfortunately, the ",NA,NA
"frame is quite abstract, so most of the slots that you could imagine for it wouldn't have values (though those ",NA,NA
slots themselves will inherit downward via slot inheritance). One answer would be a ,NA,NA
purpose,NA,NA
 slot in a ,NA,NA
"purchase order, always filled in with the value ""purchasing_something"". Another answer would be a ",NA,NA
where_obtained,NA,NA
" slot always filled with value ""stockroom"", meaning you can get blank purchase orders from ",NA,NA
the stockroom. ,NA,NA
(b) It inherits from P2 too. (That doesn't necessarily mean that P2 has its units slot filled in--P2 could be ,NA,NA
"inheriting that value itself. But that's still ""inheritance from P2"".) ",NA,NA
12-4. Use frames to represent slots themselves. Have the name of each possible slot be the name of a slot-,NA,NA
"defining frame, in which we have a special slot named ",NA,NA
value,NA,NA
 to hold the value. Each slot-defining frame can ,NA,NA
"have a slot for each qualifying slot of the original slot, with values filled in as appropriate. Every time you ",NA,NA
"refer to the slot name, you can just inherit information from its slot-defining frame. ",NA,NA
"12-5. (a) The value ""Floodge Manufacturing Inc."" in the manufacturer's name slot, since it must be filled in ",NA,NA
similarly in any subtype of computer made by Floodge. ,NA,NA
(b) The slot ,NA,NA
ID-number,NA,NA
", since every computer must have an ID number, but each computer has a different ",NA,NA
value for it. ,NA,NA
(c) Every Floodge computer has a CPU. So every personal computer made by Floodge also has a CPU. The ,NA,NA
"CPU of a personal computer made by Floodge is an example of a part-kind inheritance, inference of a new ",NA,NA
"frame. This new frame is different from the CPU frame for all Floodge computers, because for instance ",NA,NA
personal computers have slower CPUs. ,NA,NA
12-9. The relationship of the Navy to military-organizations is ,NA,NA
a_kind_of,NA,NA
", whereas the relationship of NPS to ",NA,NA
the Navy is more like ,NA,NA
part_of,NA,NA
". Or you could say the Navy and military organizations are intensions, while NPS ",NA,NA
is more like an extension. ,NA,NA
12-13. The problem of multiple inheritance for qualifying slots should be simpler than the original multiple ,NA,NA
"inheritance problem, since they usually have few different values. So you can just assign priorities of ",NA,NA
"inheritance direction as suggested for the user models example. In other words, any ""qualifying-qualifying"" ",NA,NA
"slot for inheritance method will be filled with the same value, this direction-priority method. ",NA,NA
"13-1. We have two orderings to deal with: the order of the three rules, and the order of the two terms in the first ",NA,NA
"rule. The second order involves an ""and"" and these should be ordered with the thing most likely to fail first. So ",NA,NA
c(X),NA,NA
 should come before ,NA,NA
b(X),NA,NA
 since 0.7 is less than 0.8. Since we're told that all the probabilities are ,NA,NA
"independent, the probability of that first rule succeeding is just the independence-assumption ""andcombine"" of ",NA,NA
"0.7 and 0.8, or 0.56. This 0.56 is greater than 0.1, but less than 0.6. So since we should put the rules with ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (27 of 36) [23/04/2002 17:39:40],NA
"greatest probability of success first, we should put the ",NA,NA
e,NA,NA
" rule first, then the rule with ",NA,NA
b,NA,NA
 and ,NA,NA
c,NA,NA
", and then the rule ",NA,NA
with ,NA,NA
d,NA,NA
. ,NA,NA
"13-4.(a) There's a mistake or bug somewhere, because the existence of the picture implies there must be some ",NA,NA
"possible interpretation of it. Maybe our constraints are unreasonable, or maybe the characteristics of the regions ",NA,NA
of the picture were described incorrectly. ,NA,NA
"(b) This suggests an optical illusion, a situation for which the human eye could see two possible ",NA,NA
"interpretations. Optical illusions can arise at random, particularly with pictures of geometrical figures and ",NA,NA
pictures in which objects have lined up in unusual ways. ,NA,NA
(c) This suggests not enough constraints or too-weak constraints to solve the problem. That's not necessarily the ,NA,NA
"programmer's fault, many real-world pictures can give this behavior, like those with few sharp boundaries. ",NA,NA
"13-6. We must first create possibility lists, using the three meal types given and any single-variable ",NA,NA
constraints. The first constraint is the only single-variable one. So we have the following possibilities (using ,NA,NA
"""m1"" for meal 1, ""B1"" for breakfast on day one, ""L2"" for lunch on day two, etc.) ",NA,NA
B1: [m1],NA,NA
"L1: [m1,m2,m3]",NA,NA
"D1: [m1,m2,m3]",NA,NA
"B2: [m1,m2,m3]",NA,NA
"L2: [m1,m2,m3]",NA,NA
"D2: [m1,m2,m3]",NA,NA
Now we do the multivariable part of relaxation starting with the B2 variable. (The instructions also suggest ,NA,NA
"that we start with B2 in the first step, but that doesn't make the difference to the result that it does for this ",NA,NA
"step.) We retrieve the possible values of a variable, and check which of them satisfy constraints C2, C3, and ",NA,NA
C4. Here is one way: ,NA,NA
1. Pick variable B2. Possibility m1 is impossible by constraint 4. ,NA,NA
2. Pick variable L2 by the focus-of-attention heuristic. Then m1 is impossible by constraint 4. ,NA,NA
3. Pick L1 by the same heuristic. It cannot be m1 by constraint 2. And it can't be m3 be ,NA,NA
constraint 4. So it must be m2. Possibility lists are now: ,NA,NA
B1: [m1],NA,NA
L1: [m2],NA,NA
"D1: [m1,m2,m3]",NA,NA
"B2: [m2,m3]",NA,NA
"L2: [m2,m3]",NA,NA
"D2: [m1,m2,m3]",NA,NA
4. Pick variable L2. Then m2 can be eliminated by constraint 4 so the only remaining possibility ,NA,NA
is m3. ,NA,NA
5. Pick B2. It cannot be m3 by constraint 3 so it must be m2. ,NA,NA
"6. Pick D1. It cannot be m2 by constraint 2, and it cannot be m3 by constraint 3 so it must be ",NA,NA
m1. ,NA,NA
"7. Pick D2. It cannot be m3 by constraint 3, and it cannot be m1 be constraint 1,so it must be ",NA,NA
m2. ,NA,NA
"The final possibilities have been reduced to one for each variable, as follows: B1=m1, L1=m2, D1=m1, ",NA,NA
"B2=m2, L2=m3, D2=m2. ",NA,NA
"13-13. (a) 162 times, to get the answer ",NA,NA
"X=4, Y=3, Z=5",NA,NA
: ,NA,NA
1. 3 backtracks from ,NA,NA
n(Y),NA,NA
 to ,NA,NA
n(X),NA,NA
", since four ",NA,NA
X,NA,NA
 values must be tried. ,NA,NA
2. 17 backtracks from ,NA,NA
n(Z),NA,NA
 to ,NA,NA
n(Y),NA,NA
", |( 3 * 5 ) + 3 - 1|. (The five values for ",NA,NA
Y,NA,NA
 must be cycled ,NA,NA
"through three times, then the third value succeeds.) ",NA,NA
3. 89 backtracks from ,NA,NA
X>Y,NA,NA
 to ,NA,NA
n(Z),NA,NA
", |( 17 * 5 ) + 5 -1|. (Similar reasoning to the preceding.) ",NA,NA
4. 29 backtracks from the last predicate expression ,NA,NA
"g(X,Y,Z)",NA,NA
 to ,NA,NA
"not(f(X,X))",NA,NA
", | ( 6 * 5 ) - 1 |. (Six ",NA,NA
"(X,Y) pairs are tried: (2,1), (3,1), (3,2), (4,1), (4,2), and (4,3).) ",NA,NA
5. 24 backtracks from ,NA,NA
"not(f(X,X))",NA,NA
 to ,NA,NA
X>Y,NA,NA
", |29 - 5|. (The same as the previous answer except for ",NA,NA
the ,NA,NA
X=2,NA,NA
 and ,NA,NA
Y=1,NA,NA
 case ruled out.) ,NA,NA
(b) The ,NA,NA
g,NA,NA
" predicate is the hardest to satisfy, and the > comparison is next hardest, so write the query as ",NA,NA
"g(X,Y,Z), X>Y, not(f(X,X)), n(X), n(Y), n(Z).",NA,NA
This will backtrack a mere three times: all three from the ,NA,NA
X>Y,NA,NA
 to ,NA,NA
"g(X,Y,Z)",NA,NA
. The same answer is found. ,NA,NA
"(c) 39 times. First figure out where to backtrack to. For predicate expression P, backtrack to the last predicate ",NA,NA
"expression previous to P that binds a variable in P, or the immediately previous expression if no expression ",NA,NA
binds a variable in P. ,NA,NA
--,NA,NA
n(Y),NA,NA
 should backtrack to ,NA,NA
n(X),NA,NA
--,NA,NA
n(Z),NA,NA
 should backtrack to ,NA,NA
n(Y),NA,NA
--,NA,NA
X>Y,NA,NA
 should backtrack to ,NA,NA
n(Y),NA,NA
--,NA,NA
"not(f(X,X))",NA,NA
 should backtrack to ,NA,NA
n(X),http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (29 of 36) [23/04/2002 17:39:40],NA
--,NA,NA
"g(X,Y,Z)",NA,NA
 should backtrack to ,NA,NA
n(Z) ,NA,NA
Let's now simulate dependency-based backtracking: ,NA,NA
1. We match ,NA,NA
X=1,NA,NA
", ",NA,NA
Y=1,NA,NA
", and ",NA,NA
Z=1,NA,NA
. ,NA,NA
2. ,NA,NA
X>Y,NA,NA
 fails; we go back to ,NA,NA
n(Y),NA,NA
. (1 backtrack) ,NA,NA
3. We pick ,NA,NA
Y=2,NA,NA
", then return to ",NA,NA
X>Y,NA,NA
", which fails again. Back to ",NA,NA
n(Y),NA,NA
. (1 backtrack) 4. ,NA,NA
We pick ,NA,NA
Y=3,NA,NA
", then return to ",NA,NA
X>Y,NA,NA
", which fails again. Back to ",NA,NA
n(Y),NA,NA
. (1 backtrack) 5. ,NA,NA
This repeats until ,NA,NA
Y=5,NA,NA
", whereon we fail ",NA,NA
n(Y),NA,NA
. We return to ,NA,NA
n(X),NA,NA
 and pick ,NA,NA
X=2,NA,NA
. (3 ,NA,NA
backtracks) ,NA,NA
6. We now pick ,NA,NA
Y=1,NA,NA
", and ",NA,NA
X>Y,NA,NA
 succeeds. ,NA,NA
7. But ,NA,NA
"f(X,X)",NA,NA
" succeeds, so ",NA,NA
"not(f(X,X))",NA,NA
" fails, so we backtrack to ",NA,NA
n(X),NA,NA
. (1 backtrack) ,NA,NA
8. We now take ,NA,NA
X=3,NA,NA
. We skip ,NA,NA
n(Y),NA,NA
 and ,NA,NA
n(Z),NA,NA
 since they could not have caused the last failure. 9. ,NA,NA
X>Y,NA,NA
" holds, as does ",NA,NA
"not(f(X,X))",NA,NA
. But ,NA,NA
"g(X,Y,Z)",NA,NA
" fails, so we backtrack to ",NA,NA
n(Z),NA,NA
. (1 backtrack) 10. ,NA,NA
Z=2,NA,NA
" is chosen, we return to ",NA,NA
"g(X,Y,Z)",NA,NA
", but that doesn't work either. We return to ",NA,NA
n(Z),NA,NA
. (1 ,NA,NA
backtrack) ,NA,NA
11. We alternate repeatedly between ,NA,NA
n(Z),NA,NA
 and ,NA,NA
"g(X,Y,Z)",NA,NA
 until ,NA,NA
n(Z),NA,NA
" fails, whereupon we return to ",NA,NA
n(Y),NA,NA
. (4 backtracks) ,NA,NA
12. We pick ,NA,NA
Y=2,NA,NA
", ",NA,NA
Z=1,NA,NA
. ,NA,NA
X>Y,NA,NA
" succeeds, but ",NA,NA
"g(X,Y,Z)",NA,NA
 fails. Return to ,NA,NA
n(Z),NA,NA
. (1 backtrack) 13. None ,NA,NA
of the other values for ,NA,NA
Z,NA,NA
 will make ,NA,NA
"g(X,Y,Z)",NA,NA
 succeed. Fail ,NA,NA
n(Z),NA,NA
. (5 backtracks) 14. We pick ,NA,NA
Y=3,NA,NA
. ,NA,NA
X>Y,NA,NA
 fails. Similarly for ,NA,NA
Y=4,NA,NA
 and ,NA,NA
Y=5,NA,NA
. So ,NA,NA
n(Y),NA,NA
 fails. (4 backtracks) ,NA,NA
15. We pick ,NA,NA
X=4,NA,NA
", ",NA,NA
Y=1,NA,NA
", ",NA,NA
Z=1,NA,NA
. ,NA,NA
X>Y,NA,NA
 and ,NA,NA
"not(f(X,X))",NA,NA
" succeed, but ",NA,NA
"g(X,Y,Z)",NA,NA
 fails. (1 backtrack) 16. ,NA,NA
Z=2,NA,NA
 is tried and fails ,NA,NA
"g(X,Y,Z)",NA,NA
", followed by ",NA,NA
Z=3,NA,NA
", ",NA,NA
Z=4,NA,NA
", ",NA,NA
Z=5,NA,NA
. So ,NA,NA
n(Z),NA,NA
 fails. (5 backtracks) 17. ,NA,NA
Y=2,NA,NA
 is tried and fails ,NA,NA
"g(X,Y,Z)",NA,NA
 after all ,NA,NA
Z,NA,NA
 are tried. (6 backtracks) ,NA,NA
18. ,NA,NA
Y=3,NA,NA
 is tried. ,NA,NA
Z=1,NA,NA
", ",NA,NA
Z=2,NA,NA
", ",NA,NA
Z=3,NA,NA
", and ",NA,NA
Z=4,NA,NA
 are tried and fail; ,NA,NA
Z=5,NA,NA
 succeeds. (4 backtracks) ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (30 of 36) [23/04/2002 17:39:40],NA
(d) First create possibility lists for ,NA,NA
X,NA,NA
", ",NA,NA
Y,NA,NA
", and ",NA,NA
Z,NA,NA
", using the ",NA,NA
n,NA,NA
 and ,NA,NA
f,NA,NA
 predicate expressions: ,NA,NA
"X: [1,3,4,5]",NA,NA
"Y: [1,2,3,4,5]",NA,NA
"Z: [1,2,3,4,5]",NA,NA
The only multivariable constraints are ,NA,NA
X>Y,NA,NA
 and ,NA,NA
"g(X,Y,Z)",NA,NA
. ,NA,NA
1. Pick variable ,NA,NA
X,NA,NA
 first since it has the fewest possibilities. ,NA,NA
X=1,NA,NA
 is not possible with ,NA,NA
X>Y,NA,NA
. And ,NA,NA
X=5,NA,NA
 is not possible with ,NA,NA
"g(X,Y,Z)",NA,NA
. So ,NA,NA
X=3,NA,NA
 or ,NA,NA
X=4,NA,NA
 only. (Note it's not fair to say that ,NA,NA
X,NA,NA
 cannot ,NA,NA
"be 3 now because that could only be shown by considering the two constraints together, ",NA,NA
X>Y ,NA,NA
and ,NA,NA
"g(X,Y,Z)",NA,NA
. Pure relaxation throws away bindings from one constraint when considering ,NA,NA
another constraint.) ,NA,NA
2. Pick variable ,NA,NA
Y,NA,NA
. ,NA,NA
Y=3,NA,NA
 is the only way to satisfy constraint ,NA,NA
"g(X,Y,Z)",NA,NA
. ,NA,NA
3. Return to variable ,NA,NA
X,NA,NA
. Now by ,NA,NA
X>Y,NA,NA
", ",NA,NA
X,NA,NA
" cannot be 3, so it must be 4. ",NA,NA
4. Go to variable ,NA,NA
Z,NA,NA
", the only remaining variable with multiple possibilities. It must be 5 by ",NA,NA
"g(X,Y,Z)",NA,NA
. ,NA,NA
13-14. (a) Whenever a unique value is chosen for a variable the ,NA,NA
unique_values,NA,NA
 predicate can exploit that new ,NA,NA
value. So ,NA,NA
unique_values,NA,NA
" becomes harder to satisfy, and it must do more backtracking. This slows the program ",NA,NA
"down. When we start with two values for e, things aren't slowed down until o is found to be 0, at which point ",NA,NA
"there are fewer other unassigned variables to worry about, so the slowdown is less dramatic. ",NA,NA
(b) Delete the definition of ,NA,NA
unique_values,NA,NA
", and delete its call from the definition of the ",NA,NA
satisfiable,NA,NA
 predicate. It ,NA,NA
isn't necessary. ,NA,NA
(c) The predicate ,NA,NA
duplication,NA,NA
" catches most of the bad assignments of variables to values, but ",NA,NA
unique_values ,NA,NA
catches a few cases that ,NA,NA
duplication,NA,NA
" misses. For instance, if each of variables A, B, and C have possibilities of 4 ",NA,NA
"or 5, and each variable has a distinct value, there's no way that the conditions can be met; ",NA,NA
unique_values ,NA,NA
will ,NA,NA
catch this. ,NA,NA
"13-18.(a) A state is any set of possibility lists for the variables, where possibility lists are subsets of the original ",NA,NA
"possibility lists in the starting state, plus a list of which variables are ""active"". It can be represented as a list of ",NA,NA
lists. ,NA,NA
"(b) Depth-first search. It keeps moving ahead, never returning to a previous state. There's no point in returning ",NA,NA
"to a previous state because you keep learning useful things as you proceed, things that can potentially help in ",NA,NA
future study. ,NA,NA
"(c) No, because you can't predict what intermediate states you'll get into. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (31 of 36) [23/04/2002 17:39:40],NA
(d) The branching factor always stays the same or decreases by 1. A state transition means either elimination ,NA,NA
of a single possibility for a variable or no elimination. ,NA,NA
"(e) If the sum of the number of possibilities on all initial possibility lists is N, then there are |2 sup N| ",NA,NA
possibility list configurations obtainable by crossing out 0 to N possibilities. But we haven't included the active ,NA,NA
"variables. There are |2 sup V| configurations of these for each possibility-list configuration, so the total number ",NA,NA
"of states is the product of these two numbers, or |2 sup {N + V}|. (Some of those states have zero possibilities ",NA,NA
"for some variables, but such states are possible when the input has errors.) ",NA,NA
14-1. ,NA,NA
X,NA,NA
" binds to 5, and ",NA,NA
Y,NA,NA
 binds to ,NA,NA
X,NA,NA
", so ",NA,NA
Y,NA,NA
 is bound to 5 too. So the ,NA,NA
possible,NA,NA
"s cancel, giving as resolvent ",NA,NA
"state(3,A,5); state(3,6,5).",NA,NA
"But the second predicate expression is covered by the first, so we can rewrite this as ",NA,NA
"state(3,A,5).",NA,NA
That is the only resolution possible. ,NA,NA
14-2. (a) Suppose: ,NA,NA
t,NA,NA
 represents your having travel money; ,NA,NA
d,NA,NA
 represents your department chairman approval; ,NA,NA
s,NA,NA
 represents sponsor approval; ,NA,NA
b,NA,NA
 represents the boss of your department chairman approving; ,NA,NA
f,NA,NA
 ,NA,NA
represents discretionary funds being available. ,NA,NA
Then we can write the initial rules as ,NA,NA
"t :- d, s.",NA,NA
"t :- d, b, f.",NA,NA
(b) ,NA,NA
t; not(d); not(s).,NA,NA
t; not(d); not(b); not(f).,NA,NA
(c) ,NA,NA
"(d,s);(d,b,f) :- t.",NA,NA
or equivalently: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (32 of 36) [23/04/2002 17:39:40],NA
"d,(s;(b,f)) :- t.",NA,NA
(d) The second preceding can be translated to ,NA,NA
"(d, (s;(b,f))); not(t).",NA,NA
"Using the distributive law of ""or"" over ""and"": ",NA,NA
"(d; not(t)), (s; (b,f); not(t)).",NA,NA
d; not(t).,NA,NA
"s; (b,f); not(t).",NA,NA
"The first of those two is a clause, but we still need to use the distributive law of ""or"" over ""and"" on the second. ",NA,NA
"Finally, we have these three clauses: ",NA,NA
d; not(t).,NA,NA
s; b; not(t).,NA,NA
s; f; not(t).,NA,NA
(e) Just resolve the fact ,NA,NA
t,NA,NA
" with the clauses in part (d), giving: ",NA,NA
d.,NA,NA
s; b.,NA,NA
s; f.,NA,NA
"Since we did all possible resolutions involving all given information, those are all the clauses derivable. ",NA,NA
(f) Just resolve the clause ,NA,NA
not(t),NA,NA
" with the clauses in part (b), giving: ",NA,NA
not(d); not(s).,NA,NA
not(d); not(b); not(f).,NA,NA
14-5. Resolvent clauses are only guaranteed to ,NA,NA
include,NA,NA
" the truth, not give a precise specification of the truth as ",NA,NA
"the ""and"" of the two resolvents would. The statement ""b or c"" does include all the cross-hatched region in the ",NA,NA
"figure, the ""and"" of the input clauses, which is all that is required. ",NA,NA
14-9. (a) The number of possible pairs of clauses or |N ( N - 1 ) / 2|. (Note that resolution is a commutative ,NA,NA
"operation, hence the division by 2.) ",NA,NA
"(b) Each successful resolution increases by one the number of clauses, so after K resolutions there will |N + K| ",NA,NA
"clauses and |( N + K ) ( N + K - 1 ) / 2| pairs. K of these pairs will have already been used, so an upper bound on ",NA,NA
the branching factor is |(( N + K ) ( N + K - 1 ) / 2 ) - K |. ,NA,NA
"15-1. The real test is not the opinion of any human being, but whether the car works correctly when the ",NA,NA
supposed problem is fixed. So the gold standard is the minimum change necessary to get the car working right ,NA,NA
"again. (It's the ""minimum"" because you can always get any faulty car working again by simply replacing every ",NA,NA
part with a nonfaulty part.) ,NA,NA
"15-3. In the confusion matrix, examine the cell pairs symmetric about the diagonal running northwest-southeast ",NA,NA
(but not including the cells of the diagonal itself.) Look for any pair where (1) one number is much larger than ,NA,NA
"the other, and (2) the cell with the larger number is in a row corresponding to diagnosis rules that precede the ",NA,NA
rules that correspond to the row for the other diagnosis; such a pair suggests the order of the rows should be ,NA,NA
"reversed. This clue is further strengthened if the other cells in the same two rows and two columns are small, ",NA,NA
except for the diagonal terms. ,NA,NA
15-6. (a) Not a good idea by the third and fourth overall criteria of Section 15.10. ,NA,NA
"(b) Not a good idea by the first, second and sixth criteria. ",NA,NA
(c) Not a good idea by the second and third criteria. ,NA,NA
"(d) Not a good idea by the third, fourth, and fifth criteria. ",NA,NA
"M-1. (a) Yes, backtracking on failure is the whole point. ",NA,NA
"(b) No, the whole point of forward chaining is to keep moving forward from facts to new conclusions. ",NA,NA
"Choosing new facts and new rules is better done by iteration, not backtracking. ",NA,NA
"(c) No, since you store things on an agenda and just pick the best thing on the agenda at each point, a form of ",NA,NA
iteration. The agenda item selected might be something in a far away and/or deeper part of the search lattice ,NA,NA
"than the last agenda item, so you're not necessarily ""going back"" to anything. ",NA,NA
"(d) Yes, dependency-based backtracking is included in this. ",NA,NA
"(e) Yes, because you might have several directions (links) you could follow to find a value for some slot. If ",NA,NA
"one path doesn't pan out, you should backtrack and try another. ",NA,NA
"(f) No, because it's just an example of forward chaining. ",NA,NA
M-3. Horn Clause: f. (the definition) ,NA,NA
generate-and-test: i. (variable ,NA,NA
X,NA,NA
" is generated, then tested) ",NA,NA
constraint: m. (equivalent terminology) ,NA,NA
forward chaining: o. (that's the whole idea) ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (34 of 36) [23/04/2002 17:39:40],NA
default: b. (the definition) ,NA,NA
depth-first control structure: q. (essential even for those depth-first activities that aren't searches) ,NA,NA
intension: p. (the definition) ,NA,NA
difference table: h. (the main purpose) ,NA,NA
near miss: n. ,NA,NA
Skolem Function: j. ,NA,NA
caching: a. (the definition) ,NA,NA
dependency: r. (the definition for predicate expressions in the same query) ,NA,NA
multiple inheritance: c. (the chief difficulty) ,NA,NA
decision lattice: g. ,NA,NA
Bayes' Rule: d. (it can be proved from probability theory) ,NA,NA
heuristic: e. (a famous example) ,NA,NA
hierarchical reasoning: l. (hierarchy is in the levels of recursion) ,NA,NA
agenda: k. (the definition) ,NA,NA
"M-4.(a) 1, and-or-not lattice. This sounds like a pretty straightforward application for expert systems; few ",NA,NA
"variables will be needed. So the lattice will be feasible, and will be a simple (and reasonably efficient) ",NA,NA
implementation method. You could build the lattice with logic gates on a VLSI chip that could be put into a ,NA,NA
small hand-held device. Dependency-based backtracking is probably too fancy a technique for this problem; ,NA,NA
"you must wait for the user to answer questions, so the extra speed of dependency-based backtracking will ",NA,NA
usually be wasted. You shouldn't need to backtrack anyway since this sounds good for forward chaining; there ,NA,NA
"are few facts (the problem mentions ""simple questions""), and probably low ""fanout"" from facts (multiple ",NA,NA
references to the same fact in different rules should be rare). A breadth-first resolution strategy is a very slow ,NA,NA
"method of reasoning only appropriate when you want to be sure to reach every valid conclusion, including ",NA,NA
"conclusions with ""or""s; here we only want a single conclusion about which tax form to use. Finally, there's no ",NA,NA
"such thing as ""confusion-matrix conflict resolution""; conflict resolution is how you decide what to do next in a ",NA,NA
"rule-based system, and confusion matrices are statistical summaries useful in analyzing experiments with ",NA,NA
system performance. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (35 of 36) [23/04/2002 17:39:40],NA
"(b) 4, concurrency. You can only ask questions one at a time, and there's probably low fanout of facts to rules, ",NA,NA
so there isn't much opportunity for concurrency. (Things are quite different for expert systems with real-time ,NA,NA
"inputs, like the ""smart house"" in Exercise 6-12.) Virtual facts would be essential if you used backward ",NA,NA
"chaining--you don't want to ask the same question twice. Inference is a general term for all reasoning, and this ",NA,NA
"system must reason. A depth-first control structure is good for many expert systems including this one, ",NA,NA
"regardless of whether they do backward, forward, or hybrid chaining, because it's easy to implement. ",NA,NA
"(c) 2, ",NA,NA
repeat,NA,NA
". There's not much reason to repeat anything here; after all, an and-or-not lattice sound good, and ",NA,NA
that can't accommodate iteration very well. The ,NA,NA
asserta,NA,NA
 or ,NA,NA
assertz,NA,NA
 would be necessary for virtual facts. The ,NA,NA
write,NA,NA
 would be necessary to ask questions of the user. The ,NA,NA
>,NA,NA
 could be used in making the needed monetary-,NA,NA
amount comparisons. ,NA,NA
"M-5. (a) 1, best-first search. Deviation from a straight line is a good (and necessary) evaluation function; we ",NA,NA
"clearly don't want to lurch a lot, or we couldn't walk very fast. But there's no obvious cost function; speed is ",NA,NA
"not important, according to the problem statement. And there's no such thing as ""weight-first search"". ",NA,NA
"(b) 2, caching only. Caching is helpful for reexamining the same ground as robot moves forward. Means-ends ",NA,NA
"analysis isn't helpful because there's only one operator, foot placement. So all the tricks that means-ends ",NA,NA
"analysis uses to select operators based on logical conditions don't have anything to work with. Furthermore, the ",NA,NA
"problem is quantitative: it depends on numeric things like the coordinates of a square, the positions of the other ",NA,NA
"legs, the center of gravity of the robot, the direction of motion of the robot, and so on. Means-ends analysis is ",NA,NA
intended for non-quantitative problems. ,NA,NA
"(c) 2, ",NA,NA
assertz,NA,NA
". No reason to use queues here, about the only reason to ever use an ",NA,NA
assertz,NA,NA
. The ,NA,NA
is,NA,NA
 is always ,NA,NA
"useful with numeric calculations, and the cut and ",NA,NA
repeat,NA,NA
" predicates could help make search efficient, just as ",NA,NA
they did for the best-first program in Section 10.9. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/ag.html (36 of 36) [23/04/2002 17:39:40],NA
ADVICE TO THE INSTRUCTOR ,NA,NA
"If artificial intelligence is a hard subject to learn, it's an even harder subject to teach. Intellectually, it's one ",NA,NA
"of the most difficult areas of computer science, with many complicated ideas to understand. It requires a ",NA,NA
"good deal of background. It's very rigorous in some subareas, and sloppy in others. It's not like any other ",NA,NA
"subject, so students have few analogies on which to draw. Instead, they see and hear distorted media ",NA,NA
reports about it that encourage unreasonable expectations. So instructors of artificial intelligence courses ,NA,NA
have their hands full. ,NA,NA
"But on the other hand, if you can successfully teach an artificial intelligence course in the style and at the ",NA,NA
"level of this book, you've really accomplished something. The students will almost certainly learn a lot. ",NA,NA
"And much of what they'll learn is quite practical, and much of it will tie in with important concepts ",NA,NA
they've learned in other courses. So don't be easily discouraged. ,NA,NA
Evaluating Student Progress ,NA,NA
One major difficulty in teaching artificial intelligence is in planning the test questions and homework ,NA,NA
exercises. Many instructors have told me how conventional tests just don't seem to work for artificial ,NA,NA
intelligence courses. The interesting questions that really test if students know anything require more than ,NA,NA
"an hour to do, and multi-hour tests are hard to arrange and unfair to students who just can't show ",NA,NA
"creativity under the pressure of a test. Substantial homework assignments seem the only alternative, and ",NA,NA
"in fact, most of the questions in this book are intended as homework questions. So don't be afraid to give ",NA,NA
lots of homework if you have the capability to grade it. ,NA,NA
Homework has a potentially big disadvantage: the possibility of collaboration or copying of answers ,NA,NA
"between students. You'll just have to judge how worrisome this is for your institution. At MIT in 1973, in ",NA,NA
"my first course in this subject, Patrick Winston deliberately encouraged students to work together on the ",NA,NA
"all-day take-home exams, claiming that grades in the course weren't that important. At Stanford in 1981, ",NA,NA
"when I assisted with the first course, we didn't issue any policy on the homework, and trusted the student's ",NA,NA
"adherence to the Honor Code, which a few students flagrantly violated. At the Naval Postgraduate School, ",NA,NA
"where I grade all papers myself, I make a special effort to compare papers on the first homework ",NA,NA
"assignment, and warn students whose papers seem to be significantly more similar than could be due to ",NA,NA
pure chance. But I can't say that my experience has been typical. ,NA,NA
"Still, you have to give some tests. Currently, in my 11-week quarter course (introductory artificial ",NA,NA
intelligence) I give a 50-minute midterm (with about four questions) and a 110-minute final exam ,NA,NA
"(without about seven questions). The easier exercises in the book, especially those involving following of ",NA,NA
"algorithms, are generally my test questions. I also give three or four homework assignments, evenly ",NA,NA
"spaced through the quarter. Currently, I get an average of about 70% correct on the homework and tests. I ",NA,NA
"recommend open-book tests because there are many terms used in the field, and the material is so hard ",NA,NA
anyway for students. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (1 of 88) [23/04/2002 17:40:03],NA
About Good Exercises and Test Questions ,NA,NA
I suppose some of you are thinking that it surely must be possible to construct some easier test questions--,NA,NA
maybe multiple choice?--than those in this book. I'll argue that it's very difficult to do this and remain fair ,NA,NA
"to the content of AI, because the subject concerns thinking, and you need students to think on a test to ",NA,NA
verify that they see how computers could do it. Let's examine some question types that are not in my ,NA,NA
book. ,NA,NA
Q1. Define resolution. ,NA,NA
That just requires memory regurgitation; there's no assurance that correct answer means the student ,NA,NA
understands what resolution requires or what it's good for. This sort of bad question is the too-frequent ,NA,NA
resort of lazy professors. ,NA,NA
"Q2. Which of these is a control structure: Bayes' Rule, caching, unification, or forward chaining? ",NA,NA
"Again, mostly memory regurgitation is needed. And it's too easy a question; if students are really so ",NA,NA
"confused that they haven't realized that forward chaining is a control structure, then either standards were ",NA,NA
"too low, the course was really awful, or the students shouldn't be in college. Why not instead kill several ",NA,NA
"birds with one stone, and ask them a more complicated question about forward chaining that they won't ",NA,NA
"make any progress on unless they know it's a control structure, like ""Can there be a breadth-first forward ",NA,NA
"chaining?"" ",NA,NA
"Q3. Implement in a computer program the idea expressed on page 76, paragraph 3, line 5. ",NA,NA
"Learning computer science means doing some programming, but not necessarily a lot, and not necessarily ",NA,NA
"in every course. Though my book uses Prolog, there aren't many programming exercises for the reason ",NA,NA
that such exercises can require unexpected amounts of student time and effort. I think there are better and ,NA,NA
"faster ways for students to learn the material, ways that do not involve programming, just in the same way ",NA,NA
there are better ways to learn physics than trying to duplicate every famous experiment in the lab. And ,NA,NA
"also, programming exercises easy for the professor to write like the one above are rarely the most ",NA,NA
valuable programming experiences for students. ,NA,NA
Q4. Discuss the difference between breadth-first search and best-first search. ,NA,NA
"Broad essay questions can be trouble to grade because they give the student a lot of room to pontificate, ",NA,NA
and it can be hard to compare student performances when different students cover different points. And ,NA,NA
"it's not clear what level of analysis is an adequate answer to the question, so you'll frequently have ",NA,NA
students in your office grumbling if you give questions like this. ,NA,NA
"Q5. Prove that if A implies B or C, and B implies A, then C is true. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (2 of 88) [23/04/2002 17:40:03],NA
"Leave proofs for math classes; mathematics instructors know better how to teach proof rigor, and have ",NA,NA
more reason to teach it. And there's more than enough material to teach in artificial intelligence that other ,NA,NA
courses don't teach. ,NA,NA
Q6. Suzy Seashell is preparing a Honorary Dinner and needs to select a wine. Her choices are Chateau ,NA,NA
"Aulde-Tenni-Chue, Rotgutter Dranow, and Cheap Yellow. Her expert system has rules as follows: ... ",NA,NA
"OK, I confess I have a few silly questions in my book, to get back at certain peeves. But if there are too ",NA,NA
"many such questions, students lose track of what the course is for, and eventually lose their motivation. A ",NA,NA
diet of desserts is not good for the health. ,NA,NA
Demonstrations ,NA,NA
"If at all possible, try to use an actual computer during class to show off the programs of the book and ",NA,NA
other similar programs. It will make some things much clearer for the students. This is particularly ,NA,NA
"valuable at the beginning of the course, but it works well for some of the later programs in the book too; ",NA,NA
"I'd recommend doing a demonstration once every eight classroom hours. To make this easier, Prentice-",NA,NA
Hall is selling tapes and diskettes containing the major programs in the book; see your representative. ,NA,NA
Devices for projecting computer-terminal screens on a lecture-hall screen are an invaluable for computer ,NA,NA
"science courses, if you haven't tried them before. ",NA,NA
A Sample Syllabus ,NA,NA
"Following is my syllabus for when I gave a quarter course ""Artificial Intelligence"" based on this book, as ",NA,NA
"the only text, in Summer Quarter 1987. Our quarter was 11 weeks long, and the course met four times a ",NA,NA
week for 50-minute lecture/recitations (with zero lab hours allocated). Thirty students per quarter has ,NA,NA
"been my average enrollment, and I grade all homework and tests myself. ",NA,NA
"I have also used other parts of the book in an advanced course, ""Expert Systems"". I usually use Chapters 7 ",NA,NA
"and 10, plus an expert-systems book. Careful coverage of those two chapters could almost fill a quarter ",NA,NA
"by itself, since many issues in Prolog programming as well as expert systems are raised by those chapters. ",NA,NA
########################################### ,NA,NA
"CS3310, Artificial Intelligence ",NA,NA
Summer 1987 ,NA,NA
Profs. Rowe (Spanagel 528B) and McGhee (Spanagel 512) ,NA,NA
"Official office hours for Prof. Rowe: Mondays, Wednesdays, and Thursdays 9-10 and 11-12. No official ",NA,NA
hours for Prof. McGhee; see him anytime. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (3 of 88) [23/04/2002 17:40:03],NA
Grading: 75 points on each of four Homework assignments; 100 points Midterm Exam (open-book); 175 ,NA,NA
points Final Exam (open-book). ,NA,NA
"Both sections of this course will cover the same material, and they will have the same homework and ",NA,NA
tests. ,NA,NA
"The listed prerequisite for this course is a course in logic, such as Mathematics 2025 or 0125 at this ",NA,NA
"school, but this isn't too important. But it is important to have taken at least one college-level ",NA,NA
"programming course, hopefully two. A data structures course helps considerably, as do software ",NA,NA
engineering courses. ,NA,NA
This course will require at least one hour of independent study outside of class every day (six days a ,NA,NA
"week). The homework and tests will be difficult, with expected class averages around 70%. Questions ",NA,NA
"will emphasize thinking more than memorization, and will often involve applying what you know to new ",NA,NA
applications. This is definitely a graduate-level course. ,NA,NA
"The textbook is a set of class notes. For additional reading (not required) see Winston, Artificial ",NA,NA
"Intelligence, second edition (Addison-Wesley, 1984), or the other books listed in the bibliography in the ",NA,NA
notes (Appendix F). ,NA,NA
"For the last six terms of this course, 36 A grades were given, 38 A-, 65 B+, 53 B, 22 B-, 3 C+, and 4 C ",NA,NA
grades. ,NA,NA
Schedule (do not hand in the practice problems): ,NA,NA
By 7/9: read chapters 1 and 2 of the notes; do for practice problems 2-2 and 2-6 ,NA,NA
By 7/15: read chapter 3 (look over Appendix A if you need to review logic); do for practice problem 3-9 ,NA,NA
By 7/22: read chapter 4; do for practice problem 4-11 ,NA,NA
Homework #1 due Thursday 7/23 ,NA,NA
By 7/29: read chapter 5 (look over Appendices B and C to review recursion and data structures); do for ,NA,NA
practice problems 5-2 and 5-14 ,NA,NA
"By 8/5: read chapter 6, sections 6.1-6.6 and 6.8 only; do for practice problem 6-5 ",NA,NA
Homework #2 due Monday 8/10 ,NA,NA
"By 8/11: read chapter 7, sections 7.1-7.9 only; do for practice problem 7-2 ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (4 of 88) [23/04/2002 17:40:03],NA
Midterm exam Thursday 8/13 (covering chapters 1-7) ,NA,NA
"By 8/19: read chapter 8, sections 8.1-8.10 only; do for practice problem 8-3 ",NA,NA
By 8/25: read chapter 9 except for sections 9.14-9.16; do for practice problem 9-11 ,NA,NA
"By 8/31: read chapter 10, sections 10.1-10.4, 10.6, and 10.7 only; do for practice problem 10-3 ",NA,NA
Homework #3 due Tuesday 9/1 ,NA,NA
"By 9/7: read chapter 11, sections 11.1-11.7 only; do for practice problem 11-6 ",NA,NA
By 9/10: read chapter 12; do for practice problem 12-5 ,NA,NA
By 9/15: read chapter 15 ,NA,NA
Homework #4 due Wednesday 9/16 ,NA,NA
"Final exam Monday, 9/21, 0800, Sp-421 ",NA,NA
################################################# Alternative Syllabi ,NA,NA
"Despite the statements of the Preface (which are designed to encourage people not to skip chapters), ",NA,NA
"flexibility is possible in which chapters are taught. But please try not to skip Chapter 15, which is ",NA,NA
important. ,NA,NA
More and more Prolog courses are being offered at schools. If a Prolog course is required or common for ,NA,NA
"your students, there is still more than enough material in this book for an AI course. Certainly, you can go ",NA,NA
"more quickly through the first five chapters of this book. However, definitely do not skip those chapters ",NA,NA
"entirely, because they contain many important AI ideas not usually covered in Prolog texts. ",NA,NA
"Some of you may prefer a more formal approach based on logic, perhaps because you teach in a ",NA,NA
mathematics department or come from a more theoretical background. Then you can take Chapter 14 ,NA,NA
"early, perhaps right after Chapter 3; Chapter 14 has been designed so it makes minimal references to the ",NA,NA
"rest of the book. You may want to skip the more pragmatic parts of the book, like Chapters 7 and 10. ",NA,NA
"However, if you want to take a formal approach, consider the following argument. Students can't be ",NA,NA
motivated to learn the syntax and manipulations of logic unless they can see what it is used for in ,NA,NA
practical applications. My approach of emphasizing the semantics of predicate expression from the very ,NA,NA
"beginning, bringing up formal details slowly and only as absolutely necessary, tends I believe to motivate ",NA,NA
students more. ,NA,NA
Some of you would prefer to spend some time on the specifics of some subarea of AI; natural language ,NA,NA
seems to be the most commonly mentioned subarea. My book does try to stick with subarea-independent ,NA,NA
"concepts, but actually, there is a lot of natural language material in my book, mixed in with others things ",NA,NA
"as per my integrated approach; note especially sections 2.8, 4.4, 5.9, 6.12, and 12.13. You may want to ",NA,NA
"supplement this with additional material. But before you do, consider the following. Linguistics is an ",NA,NA
"important field of scientific study, but claims of important practical benefits for it have never panned out. ",NA,NA
"There seems little need to have computers communicate with us in English any more, what with major ",NA,NA
"recent advances in graphics, positional input devices, and menu-driven systems. Words take a long time ",NA,NA
"to type, and many people can't type including many who are illiterate, so it's unfair to emphasize words in ",NA,NA
using computers; an emphasis on words may just be a relic of the overly verbal education most computer ,NA,NA
"researchers receive. There is still some need to process written text by computer, but the increasing ",NA,NA
computerization of every aspect of human life is making it progressively unimportant. Emphasizing ,NA,NA
"language in an AI course also means teaching science instead of engineering, and I don't think this is what ",NA,NA
students need in a university: there are too many science courses already. ,NA,NA
Some reviewers of the manuscript complained about various omissions and placements of Prolog features ,NA,NA
"in the book. Please understand I'm not trying to teach Prolog; many books available can do that, and it ",NA,NA
"really requires a full quarter of instruction. Instead, I'm trying to use Prolog to illustrate AI concepts, and ",NA,NA
I'm very concerned about introducing too much too fast. Some specific issues: ,NA,NA
"--The anonymous variable (""_"") is omitted because I believe it encourages poor programming. Intelligent ",NA,NA
"naming of variables is an important part of programming (see section 2.4), an students shouldn't be ",NA,NA
"allowed to avoid or ""cop out"" on it. ",NA,NA
"--It's a lot easier to explain the ""not"" construct by pretending it's a predicate that takes a predicate ",NA,NA
"expression as input, though this isn't the way it's implemented in many Prologs. Explaining it any other ",NA,NA
way would needlessly complicate the early chapters of the book. ,NA,NA
"--I ignore ways of entering facts directly into the Prolog interpreter's database (like ""data-entry mode""), ",NA,NA
for a philosophical reason: I think students need to have emphasized the distinction between knowledge ,NA,NA
"(facts and rules) and control structures. If you muddy this distinction, students can get very confused. It's ",NA,NA
also a distinction important historically in AI. ,NA,NA
"--The cut predicate is terribly confusing for students, and it's much abused in programming (I was amazed ",NA,NA
"to see a recent Prolog text demonstrate expert systems with a cut symbol at the end of every rule, ",NA,NA
"horrendous programming style), so I postpone it to a place where its complexities are an appropriate ",NA,NA
"match to the material, in Chapter 10. I fervently hope you'll resist the temptation to introduce it earlier to ",NA,NA
"your students, because there's plenty of more important things in AI to confuse them. However, some of ",NA,NA
"the software accompanying this book contains cuts for efficiency, when the versions in the book don't ",NA,NA
have cuts. ,NA,NA
"--I do not use complex structures very much in this book (that is, embedded predicate expressions). I hope ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (6 of 88) [23/04/2002 17:40:03],NA
"you won't either, because it is important for an AI course to maintain some compatibility with Lisp. ",NA,NA
"Embedded lists can do everything that complex structures can, and in a way more analogous to Lisp, so ",NA,NA
"I've used them instead in this book (for instance, in the search path lists of Chapter 10). Nearly all ",NA,NA
students who continue on to study AI will learn Lisp. ,NA,NA
--I haven't been afraid to give some things that don't work in Turbo Prolog. Turbo has generated a lot of ,NA,NA
"initial interest based on its price, but it's unclear how popular it will be in the long run. Its compiler-based ",NA,NA
"approach means quite different processing from interpreted Prologs, and it has a number of important ",NA,NA
"incompatibilities with Clocksin and Mellish Prolog, despite claims of its source, most notably in the ",NA,NA
"""funarg"" problem and other issues in the persistence of variable bindings. Several important and ",NA,NA
"interesting programs like forall and doall in Chapter 7 won't work in Turbo, but I feel they're important ",NA,NA
enough (and relate directly to counterparts in Lisp) that students should see them. Cheaper and simpler ,NA,NA
"dialects of Prolog are desirable, but they shouldn't leave out key features. ",NA,NA
.PA ,NA,NA
ADDITIONAL PROBLEMS ,NA,NA
Note: answers to these questions are at the back of this Manual. ,NA,NA
I-1. (for Chapter 3) Consider the Prolog database: ,NA,NA
"a(X) :- b(X,Y), b(Y,Z). b(1,3). b(2,2). b(4,2). ",NA,NA
(a) What will a Prolog interpreter answer to the query: ,NA,NA
?- a(2). ,NA,NA
(b) List all the possible answers that a Prolog interpreter could find to the following query to this database ,NA,NA
"(not including ""no""), if you kept typing semicolons: ",NA,NA
"?- a(Q), not(b(Q,Q)). ",NA,NA
"(c) How many times total does the Prolog interpreter backtrack from b(Y,Z) to b(X,Y) in the rule, when ",NA,NA
"you keep typing semicolons, before it answers ""no"" to the query of part (b)? ",NA,NA
I-2 (for Chapter 3). Consider the query: ,NA,NA
"?- link(A,B), link(B,C). ",NA,NA
"Suppose there are four ""link"" facts in the Prolog database. Assume no duplicate facts. Assume the two ",NA,NA
arguments are never identical within a fact. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (7 of 88) [23/04/2002 17:40:03],NA
(a) What is the maximum number of answers a Prolog interpreter will find for the this query? ,NA,NA
(b) What is the maximum number of times a Prolog interpreter will backtrack from the second predicate ,NA,NA
expression to the first predicate expression before answering? ,NA,NA
I-3. (for Chapter 3) Why do these two Prolog queries always give the same set of answers? ,NA,NA
"?- (a;not(c)), b, c. ?- a, b, c. ",NA,NA
"I-4 (for Chapter 3). (a) Sometimes unbound variables inside ""not""s work OK. Consider this query: ",NA,NA
"?- bosses(R,S), bosses(T,R), not(bosses(S,U)). ",NA,NA
with the database ,NA,NA
"bosses(poindexter,north). bosses(reagan,poindexter). bosses(north,hall). ",NA,NA
What is the first answer the Prolog interpreter will find to the query? (Hint: draw a semantic network.) ,NA,NA
"(b) For the query and database of part (b), how many times will Prolog backtrack from the second ",NA,NA
predicate expression to the first in getting the first answer? ,NA,NA
I-5. (for Chapter 3) Suppose a Prolog query has 26 answers total (obtained by typing semicolons). ,NA,NA
"Suppose this query is the ""and"" of some predicate expressions, with no ""or""s (semicolons) or ""not""s. ",NA,NA
(a) Suppose you give the Prolog interpreter a new query just like the old except with another predicate ,NA,NA
"expression ""and""ed on the right end. Suppose this new expression doesn't contain any ""new"" variables, ",NA,NA
variables not occurring in the old query. Suppose this augmented query has 26 answers too. Must they be ,NA,NA
the same answers? Why? ,NA,NA
"(b) For the same situation as (a), suppose we measure the CPU (processing) time to get all possible ",NA,NA
"answers, measuring up until the interpreter types ""no"". Will the new query take more time than the ",NA,NA
"original query, less time, or sometimes more and sometimes less depending on the query? Why? (c) ",NA,NA
Repeat question (b) but assume the new query has 7 answers total (with the original query still having ,NA,NA
26). Why? ,NA,NA
"(d) Repeat question (c) but assume the new predicate expression was ""and""ed on the left end of the query, ",NA,NA
not the right. (Still assume 7 answers total.) ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (8 of 88) [23/04/2002 17:40:03],NA
I-6. (for Chapter 4) (a) Which of the following (pick only one) is a Prolog rule for downward ,NA,NA
"inheritance of ""owns"" with respect to the part-of relationship? (""owns(P,T)"" means P owns thing T.) ",NA,NA
"part_of(P,T) :- owns(P,Q), part_of(Q,T). part_of(P,T) :- owns(U,T), part_of(U,P). part_of(P,T) :- ",NA,NA
"part_of(T,Q), owns(P,T). owns(P,T) :- part_of(Q,P), owns(Q,T). owns(P,T) :- part_of(U,T), owns(U,P). ",NA,NA
"owns(P,T) :- owns(P,Q), owns(Q,T). ",NA,NA
(b) Suppose the U.S. Navy owns the Enterprise. Hence the U.S. Government owns the Enterprise; does ,NA,NA
"that follow from the inheritance rule you selected above? If so, what do the variables match? If not, why ",NA,NA
not? ,NA,NA
"I-7. (for Chapter 4) Suppose predicate ""necessary(X,Y)"" means that a specific single action X must occur ",NA,NA
before specific single action Y can occur. ,NA,NA
"(a) Is predicate ""necessary"" transitive? ",NA,NA
"(b) Consider the predicate ""before9(X)"" which is true if specific single action X occurred before 9AM on ",NA,NA
"February 10, 1986. Does ""before"" inherit with respect to ""necessary"" in any way? If so, describe how. ",NA,NA
"(Hint: ""necessary"" can be used backwards.) ",NA,NA
"I-8. (for Chapter 5) This ""delete"" predicate takes three arguments: an item, a list, and a list. It says that the ",NA,NA
result of deleting all occurrences of the item from the first list gives the second list. ,NA,NA
"delete(X,[],[]). delete(X,[X|L],L2) :- delete(X,L,L2). delete(X,[Y|L],[Y|L2]) :- delete(X,L,L2), not(X=Y). ",NA,NA
Consider the query: ,NA,NA
"?- delete(X,[a,b,c],[a,c]). ",NA,NA
"(a) What is the first recursive call of ""delete""? Identify the arguments of the call. ",NA,NA
(b) What answer does the original query (the one printed above) give? (Hint: think what the definition ,NA,NA
means.) ,NA,NA
"I-9. (for Chapter 5). Define a predicate ""pair(L,PL)"" which takes a list of even length as first argument, ",NA,NA
"pairs the adjacent items in the list, and binds that result to its second argument. So for instance: ?- ",NA,NA
"pair([a,b,c,d,e,f],P). P=[[a,b],[c,d],[e,f]] ",NA,NA
Show your program working. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (9 of 88) [23/04/2002 17:40:03],NA
"I-10. (for Chapter 10) Define a predicate ""intersection(S1,S2,I)"" which says that set I is the intersection of ",NA,NA
"sets S1 and S2, where all three sets are expressed as lists. (That is, items in I are all the items that occur ",NA,NA
"within both S1 and S2.) You can use any of the definitions of chapter 5 to make the definition simpler, but ",NA,NA
"don't use the ""var"" predicate. Show your program works correctly for two cases: (1) for S1 and S2 bound, ",NA,NA
"I unbound; (2) for S1 and S2 unbound, I bound. (Remember, things Prolog prints out that start with an ",NA,NA
"underscore symbol (""_"") are Prolog-invented variable names.) ",NA,NA
"I-11. (for Chapter 5) In 20 words or less, give the declarative meaning of program ""f"". ",NA,NA
"f(L,M) :- g(L,[],L2). g([],L,L). g([X|L],L2,L3) :- g(L,[X|L2],L3). ",NA,NA
I-12. (for Chapter 6) Consider the rule: ,NA,NA
"bottom(S) :- bosses(R,S), not(bosses(S,U)). ",NA,NA
with the facts: ,NA,NA
"bosses(poindexter,north). bosses(reagan,poindexter). bosses(north,hall). ",NA,NA
"Do pure forward chaining. Give every new rule the algorithm creates, and give every new fact it proves, ",NA,NA
until it runs out of things to do. Use focus-of-attention placement of new facts. ,NA,NA
I-13. (for Chapter 6) Consider this database of rules and facts: ,NA,NA
"a(X) :- b(X), c(X). c(Longvariable) :- f(Longvariable). c(2) :- not(e(Z)). b(Y) :- c(Y), not(d(Y)). e(5). f(3). ",NA,NA
"(a) What rule rewritings are done and what facts are proved, in order, by pure forward chaining with the ",NA,NA
"focus-of-attention approach? Assume you want all possible facts. Remember, save ""not""s for last. (b) ",NA,NA
"What facts are proved, in order, by rule-cycle hybrid chaining with the focus-of-attention approach? Also ",NA,NA
give the cycle number on which the fact was proved. Assume you want all possible facts. ,NA,NA
"Remember, save ""not""s for last. ",NA,NA
I-14 (for Chapter 6). Consider the following rules for diagnosis of childhood illnesses: ,NA,NA
"R1: If there's a rash and but not a high fever, suspect chicken pox. R2: If there's a rash, a cold symptom, ",NA,NA
"and a mild fever, suspect German measles. R3: If there's a rash, a cold symptom, and a high fever, suspect ",NA,NA
"measles. R4: If there's a mild fever and sore throat, suspect mumps. R5: If there's a medium fever and sore ",NA,NA
"throat, suspect scarlet fever. R6: If there's a cold symptom and any fever, suspect a cold. R7: A high fever ",NA,NA
is over 102. R8: A medium fever is over 100.5 to 102. R9: A mild fever is 99 to 100.5. R10: Sneezing is a ,NA,NA
cold symptom. R11: Headache is a cold symptom. R12: Sore throat is a cold symptom. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (10 of 88) [23/04/2002 17:40:03],NA
(a) Write the above as twelve Prolog rules. Use variables where appropriate. (Hint: they are appropriate ,NA,NA
somewhere.) ,NA,NA
"(b) Suppose we do backwards chaining on these rules with the goals taken in order to be measles, scarlet ",NA,NA
"fever, chicken pox, mumps, German measles, cold. Suppose the facts in order are a sore throat, a ",NA,NA
"temperature of 101, a desire to go to the circus, and a rash. Suppose we continue until everything provable ",NA,NA
"is proved. What conclusions are reached (including intermediate ones), in order? ",NA,NA
"(c) Suppose we do pure forward chaining with the same specifications as part (b), using focus-of-attention ",NA,NA
placement of new facts. Suppose we continue until everything provable is proved. What conclusions ,NA,NA
"(including intermediate) are reached, in order? ",NA,NA
(d) Suppose we do rule-cycle hybrid chaining with the same specifications as part (b). Suppose we ,NA,NA
"continue until everything provable is proved. What conclusions (including intermediate) are reached, in ",NA,NA
order? ,NA,NA
"(e) What is the advantage of taking the disease conclusions in the order given in part (b)? That is, why ",NA,NA
that order and not some other? ,NA,NA
"(f) Would a decision lattice be a good way to compile a set of medical-diagnosis rules like these, a set say ",NA,NA
of about 1000 rules for common problems? Why? ,NA,NA
"(g) Would ""and"" parallelism implemented with multiple processors be a good idea with a set of medical-",NA,NA
"diagnosis rules like these, assuming the same 1000 common-problem rules as part (f)? Why? Think of ",NA,NA
how the rule-based would actually be used. ,NA,NA
"I-15. (for Chapter 6) Suppose you have two processors that access the same Prolog database, both of ",NA,NA
which can run Prolog independently. Describe all the useful possible concurrencies (including full details ,NA,NA
of what should be run in parallel with what) in the following code: ,NA,NA
"p(X) :- q(X), r(X,Y), s(X), t(Y). p(X) :- u(X). ",NA,NA
when used with the following query: ,NA,NA
?- p(Q). ,NA,NA
"In particular, explain carefully how maximal and-parallelism could be done. ",NA,NA
"I-16. (for Chapter 6) Suppose a grammar is written in the manner of section 5.9, as substitutions of lists of ",NA,NA
"words for other lists of words. Substitutions are not ""coupled"", so two substitutions might make sense ",NA,NA
"individually, but not when used together, at two different places in the same sentence. How could a ",NA,NA
"Prolog implementation apply ""semantic"" criteria to rule out such nonmeaningful combinations? Give ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (11 of 88) [23/04/2002 17:40:03],NA
implementation details. ,NA,NA
"I-17. (for Chapter 6) (a) Which control structure is a decision lattice most similar to, backward chaining ",NA,NA
or forward chaining? Explain. ,NA,NA
"(b) Which control structure is an and-or-not lattice most similar to, backward chaining or forward ",NA,NA
chaining? Explain. ,NA,NA
I-18. (for Chapter 7) Study Exercise 7-5 and its answer. ,NA,NA
"(a) Now suppose the original code we have for testing whether a(X) is true is in the form of M rules, each ",NA,NA
"requiring computation cost of 2H/M. Suppose the rules are tried sequentially until one succeeds, just like ",NA,NA
cached facts. Suppose each has a mutually exclusive probability Q of success. Redo part (a) of the ,NA,NA
original problem to get a new formula for when using a cache will be preferable. ,NA,NA
"(b) Now suppose the rules are not equally costly, but are arranged from least costly to most costly. ",NA,NA
Suppose further the costs increase linearly so that the Ith rule costs about 4HI/M*M. Redo part (a) of ,NA,NA
problem 7-5. ,NA,NA
"I-19. (for Chapter 7) The appliance program (via the ""ask"" code) caches the answers to all questions it ",NA,NA
"asks the user. Would any additional caching (besides that of final answers, which could prevent repeated ",NA,NA
printing of the same diagnosis) significantly improve the program? ,NA,NA
I-20. (for Chapter 7) Explain how forward chaining must be modified to handle rules with arithmetic ,NA,NA
"computations, where the computations are used only to compute numbers for the left sides of the rules. ",NA,NA
"I-21. (for Chapter 7) (for interpreted Prologs only) The language Lisp has a ""prog"" construct, whereby a ",NA,NA
"list of statements are executed in order. Define the equivalent for Prolog. That is, define a predicate ",NA,NA
"""prog"" of one argument, a list of predicate expressions, that calls every one of the expressions in order, ",NA,NA
ignoring whether any expression succeeds or fails. It also should not permit backtracking from expression ,NA,NA
"to expression if something after the ""prog"" fails. Hint: you can't backtrack into a ""not"". ",NA,NA
I-22. (for Chapter 7) Construct a rule-based system that models an elevator that you have access to. ,NA,NA
Conduct experiments to find out what the elevator does in particular situations. Then test your program in ,NA,NA
those same situations to confirm the same behavior. Use as program input information about which ,NA,NA
"buttons were pushed when, where the other elevator is, whether someone is standing in the door, etc. Let ",NA,NA
"the program output be a statement about elevator behavior, either (1) it goes to a particular floor, or (2) its ",NA,NA
"doors open or close, or (3) it stops, or (4) its alarm bell rings, etc. ",NA,NA
I-23. (for Chapter 7) Find a misleading advertisement for an expert-system software product. Point out ,NA,NA
"what is misleading. Beyond the hype, what do you each is really selling, in the terminology of this ",NA,NA
chapter? ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (12 of 88) [23/04/2002 17:40:03],NA
I-24. (for Chapter 8) Suppose you're writing an expert system to detect Russian submarines. ,NA,NA
"--Suppose an expert tells you that if there are Russian manuevers in the area, the probability is 0.5 that ",NA,NA
any submarine waveform you detect will be a Russian submarine. ,NA,NA
"--Suppose the expert also says that if you see a type Z37 waveform, it's a Russian submarine with ",NA,NA
probability 0.8. ,NA,NA
"(a) Now suppose an expert says that if (i) there are Russian manuevers in the area, and (ii) you think with ",NA,NA
"probability 0.5 that you see a Z37 waveform (that is, you're only half sure that the waveform you see go ",NA,NA
"by on the screen was a Z37), then the probability it's a Russian submarine is 0.7. What evidence ",NA,NA
"combination method is the expert using: independence-assumption, conservative, liberal, or neither? ",NA,NA
Show your math. ,NA,NA
(b) Suppose instead for the same situation as (a) the expert says the probability it is a Russian submarine ,NA,NA
"is 1.0. What evidence combination method is the expert using: independence-assumption, conservative, ",NA,NA
"liberal, or neither? Show your math. ",NA,NA
I-25 (for Chapter 8). Consider: ,NA,NA
"c :- a, b. c :- not(a), not(b). d :- a, not(b). e :- not(a), b. ",NA,NA
(a) Suppose now all the above predicate expressions are given probabilities. Suppose further that the ,NA,NA
second rule has a rule strength of 0.8 and the third rule has a rule strength of 0.5. Write the modified rules ,NA,NA
containing probabilities. ,NA,NA
(b) Suppose b has probability 0.4. Suppose we combine probabilities (including those for rule strengths) ,NA,NA
"with the independence assumption. Conduct computer experiments to graph c, d, and e as a function of ",NA,NA
"the probability of a. Use the representative a-probability values 0.0, 0.2, 0.4, 0.6, 0.8, and 1.0. ",NA,NA
(c) Suppose b has probability 0.9. Suppose we combine probabilities (including those for rule strengths) ,NA,NA
"with the independence assumption. Conduct computer experiments to graph c, d, and e as a function of ",NA,NA
"the probability of a. Use the representative a-probability values 0.0, 0.2, 0.4, 0.6, 0.8, and 1.0. ",NA,NA
(d) Suppose b has probability 0.4. Suppose we combine probabilities (including those for rule strengths) ,NA,NA
"with the conservative assumption. Conduct computer experiments to graph c, d, and e as a function of the ",NA,NA
"probability of a. Use the representative a-probability values 0.0, 0.2, 0.4, 0.6, 0.8, and 1.0. ",NA,NA
(e) Suppose b has probability 0.9. Suppose we combine probabilities (including those for rule strengths) ,NA,NA
"with the conservative assumption. Conduct computer experiments to graph c, d, and e as a function of the ",NA,NA
"probability of a. Use the representative a-probability values 0.0, 0.2, 0.4, 0.6, 0.8, and 1.0. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (13 of 88) [23/04/2002 17:40:03],NA
(f) What major disadvantage of the conservative formulas is shown by the graphs for parts (d) and (e)? ,NA,NA
"Note that being equal to zero a lot is not a disadvantage per se, because maybe the combination value ",NA,NA
really is zero. ,NA,NA
"I-26. (for Chapter 9) Suppose in a search you are in a state ""a"" and you can go to states ""b"", ""c"", and ""d"". ",NA,NA
"Suppose ""a"" has evaluation 9, ""b"" 14, ""c"" 11, and ""d"" 15. Suppose the cost from ""a"" to ""b"" is 10, from ""a"" ",NA,NA
"to ""c"" 20, from ""a"" to ""d"" 12, from ""b"" to ""c"" 15, and from ""b"" to ""d"" 8. ",NA,NA
"(a) What state do you go to next from ""a"" in a best-first search? ",NA,NA
"(b) What state do you go to next from ""a"" in an A* search? ",NA,NA
"(c) What state do you go to next from ""a"" in a depth-first search with the heuristic that states are preferred ",NA,NA
in alphabetical order? ,NA,NA
I-27 (for Chapter 9). Consider as search the problem of using inheritance to find a value of a property for ,NA,NA
some object (Problem 9-2 and its answer may help). ,NA,NA
(a) Would bidirectional search (in general) be a good idea? ,NA,NA
(b) In which direction(s) would you expect the branching factors to be less? ,NA,NA
"(c) Give a domain-independent heuristic--that is, one that potentially applies to any inheritance situation, ",NA,NA
and doesn't reference features of the objects over which the inheritance occurs. ,NA,NA
"(d) Give a domain-dependent heuristic, one that depends on features of the objects over which inheritance ",NA,NA
occurs. ,NA,NA
(e) Is the search (in general) decomposable? Why? ,NA,NA
"(f) Is the search (in general) monotonic for the operators ""follow a_kind_of link"", ""follow part_of link"", ",NA,NA
etc.? Why? ,NA,NA
"I-28. (for Chapter 10) Implement forward chaining as a search problem. Assume there are ""rule"" and ",NA,NA
"""fact"" facts defining the initial rules and facts. Give starting, ""successor"", and ""eval"" definitions. Assume ",NA,NA
"no ""not""s or other built-in predicates are used in the rules. ",NA,NA
I-29. (for Chapter 10) Implement bidirectional best-first search by modifying the best-first program of the ,NA,NA
"chapter. Alternate between forward and backward steps, where each step finds all the successors of a ",NA,NA
"state. Assume you have also a backwards evaluation function, ""backeval"", and well as the usual ""eval"". ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (14 of 88) [23/04/2002 17:40:03],NA
"I-30. (for Chapter 11) Means-ends analysis can also involve numbers. To do this, the means-ends program ",NA,NA
"can be modified to call on a user-defined predicate ""transform"" after the postconditions have been applied, ",NA,NA
"but before the second recursive call. This ""transform"" has three arguments: an input operator name, an ",NA,NA
"input state, and an output state representing the result state after necessary arithmetic ",NA,NA
calculations and adjustments have been done. For instance: ,NA,NA
"transform(smash_case,L,[value(0)|L2]) :- singlemember(value(X),L), delete(value(X),L,L2). ",NA,NA
"says that the ""smash_case"" operator changes the value of the flashlight from X cents to 0 cents; this would ",NA,NA
"be in addition to all the preconditions, deletepostconditions, and addpostconditions shown in chapter 11. ",NA,NA
"(The ""singlemember"" is a version of ""member"" that doesn't backtrack, which is already included in the ",NA,NA
"means-ends program file.) To call on ""transform"", substitute for the ""union"" line in the means_ends ",NA,NA
definition the following: ,NA,NA
"union(Addpostlist,Prestate2,Postlist2), transform(Operator,Postlist2,Postlist), ",NA,NA
"Suppose you want to fight a fire in a compartment on board a ship, using means-ends analysis. Suppose ",NA,NA
you have three operators: ,NA,NA
"""hose"": apply water from a hose to the fire for 10 seconds; ""drain"": open the drain; ""wait"": wait for the ",NA,NA
water to drain. ,NA,NA
Suppose states can be described by a lists of the facts: ,NA,NA
"--fire(X): the fire is of degree X, where X is an integer, and larger X means a worse fire --open: the drain ",NA,NA
is open --closed: the drain is closed --flooded: the compartment is flooded --dry: the compartment is not ,NA,NA
flooded ,NA,NA
And suppose these have as preconditions and postconditions (and nothing else is a precondition or ,NA,NA
postcondition): ,NA,NA
"--hose: you can't hose if the compartment is flooded, and you can't hose if the drain isn't open; each ",NA,NA
"""hose"" operation reduces the degree of the fire by 2, and floods the compartment. ",NA,NA
"--drain: you can do this anytime, and the drain stays open once opened. ",NA,NA
"--wait: you can do this anytime; if the compartment is flooded, it becomes unflooded; and the fire degree ",NA,NA
increases by 1 if it's not zero. ,NA,NA
"Assume in your starting state that the fire is degree 3, the drain is closed, and the compartment is ",NA,NA
dry. Your goal is a dry compartment with the fire out. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (15 of 88) [23/04/2002 17:40:03],NA
I-31. (for Chapter 11) Study problem 10-9. You are to program a computer in Prolog to solve the problem ,NA,NA
"described, but using means-ends analysis (from Chapter 11) rather than A* search. Try to order the ",NA,NA
"operator recommendations, preconditions, and postconditions in a reasonable way. Show your program ",NA,NA
working. ,NA,NA
To simplify the problem: ,NA,NA
--change the goal state to be one in which the robot must be in office 1. ,NA,NA
--assume the robot can carry more than one basket at a time. ,NA,NA
--assume it doesn't make sense to pick up a basket that isn't full. ,NA,NA
--assume it doesn't make sense to put down a basket that is full. ,NA,NA
"--assume that if the robot is holding something, it carries it wherever it goes; ",NA,NA
--don't reason about the last action taken in the recommended facts or the precondition facts. ,NA,NA
--don't worry about the costs; don't worry if your answer seems a little stupid in doing some unnecessary ,NA,NA
things. ,NA,NA
The choice of operators is important. Probably you'll need separate operators for picking up a trash ,NA,NA
"basket, putting down the basket, carrying a basket somewhere, and disposing of the basket down the ",NA,NA
"chute. Also distinguish carrying the basket from just going between rooms without carrying anything, ",NA,NA
"because the two have different side effects. However, it would be poor programming to have two separate ",NA,NA
"operators (and facts) for going from office 1 to the chute, and from the chute to office 1--except in Turbo ",NA,NA
"Prolog, where you won't be able to use variables with operators (with some exceptions), and you'll have to ",NA,NA
write out each possible action as a separate fact. ,NA,NA
"You don't need any rules for recommendations, preconditions, and postconditions: you should be able to ",NA,NA
"define them with just facts. The order of these facts makes a lot of difference. Also, the order of terms ",NA,NA
within the lists makes some difference too. Here's an example of an operator definition: the preconditions ,NA,NA
"for carrying the basket that belongs in room X to place Y are that the robot is holding that basket, the ",NA,NA
"robot is in room Z, and the basket is also in room Z. Then the deletepostconditions are that the basket is in ",NA,NA
room Z and the robot is in room Z. And the addpostconditions are that the basket is in room Y and the ,NA,NA
"robot is in room Y. (The requirement that Y be different from Z can be enforced by the ""recommended"" ",NA,NA
facts.) ,NA,NA
"Since you can't write ""negative preconditions"" for the means-ends program, you'll need to define some ",NA,NA
"""negative predicates"" like ""vacuumed"" and ""emptybasket"" that can be used in preconditions. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (16 of 88) [23/04/2002 17:40:03],NA
"Warning: be very careful you don't write your own definitions of the predicates difference, append, union, ",NA,NA
"subset, deleteitems, and delete. Otherwise, your program will take forever to run, because of the ",NA,NA
unnecessary extra backtracking choices. ,NA,NA
"You'll need some debugging facilities, because the program you'll write will do some complicated things. ",NA,NA
"It's particularly helpful to watch the calls to the ""means_ends"" predicate, because that tells you the identity ",NA,NA
of the overall goal the program is working on. One good way to debug is to check whether the arguments ,NA,NA
to means_ends make sense. Check for duplicate facts; these suggest mistakes in the ,NA,NA
deletepostconditions. Check for contradictory facts; these suggest mistakes in either the addpostconditions ,NA,NA
"or deletepostconditions. Check for missing facts (for instance, if there are no facts at all about the ",NA,NA
dustiness of room 1); these suggest mistakes in the addpostconditions. When you've found a problem in ,NA,NA
"the trace, try to find where it first occurs; the action then applied must have faulty definitions. ",NA,NA
Another bug you may see is running out of stack space because of an infinite loop. Often this is due to the ,NA,NA
operator-defining facts being out of order. Other times it may be due to a recommendation or precondition ,NA,NA
failure of an operator. ,NA,NA
"I-32. (for Chapter 11) Modify the means-ends program to allow for ""negative preconditions"", things that ",NA,NA
must be false before an operator can be applied. These can mean simpler state descriptions. Implement ,NA,NA
"them by facts in the preconditions with ""not"" in front of them, like saying ""not(open(case))"" instead of ",NA,NA
"""closed(case)"". ",NA,NA
I-33. (for Chapter 13) Solve the following Prolog query by relaxation: ,NA,NA
"?- a(X,Y), a(Y,Z), a(X,Z), a(Z,Y). ",NA,NA
given the database: ,NA,NA
"a(1,4). a(2,4). a(1,5). a(3,3). a(3,6). a(5,4). ",NA,NA
I-34. (for Chapter 13) The scheduling program in section 13.1 is still very slow because duplicates aren't ,NA,NA
caught early enough. Modify the program to fix this. ,NA,NA
"I-35. (for Miscellaneous problems) (a) Which of the following is true (that is, most false) about writing ",NA,NA
artificial intelligence applications? ,NA,NA
(i) Programs consist of many small pieces. (ii) Programmers implement algorithms. (iii) Programs use ,NA,NA
symbols more than numbers. (iv) Programmers spend much time debugging. ,NA,NA
"(b) Which of the following is true (that is, most false) about Prolog? ",NA,NA
"(i) It emphasizes ""how"" instead of ""what"". ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (17 of 88) [23/04/2002 17:40:03],NA
"(ii) It's usually interpreted, not compiled. ",NA,NA
(iii) It's often good for combinatorial problems. ,NA,NA
(iv) It's a relatively new language and can be developed further. ,NA,NA
I-36. (for Miscellaneous problems) Linked lists are important in many ways in artificial intelligence. Give ,NA,NA
an important use of linked lists for each of the following. ,NA,NA
(a) relaxation ,NA,NA
(b) rule-based expert systems with probabilities ,NA,NA
"(c) breadth-first search, besides the state representation ",NA,NA
(d) automatic backtracking ,NA,NA
I-37. (for Miscellaneous problems) Which of the following techniques (not necessarily just one) can get ,NA,NA
"into an infinite loop on some practical problems having solutions? For each answer ""yes"", explain how in ",NA,NA
a few words. (Assume there are no infinite processing loops in any problem-dependent code.) ,NA,NA
(a) depth-first search with heuristics and a finite branching factor ,NA,NA
(b) A* search with an always-positive cost function and a finite branching factor ,NA,NA
(c) means-ends analysis ,NA,NA
(d) rule-cycle hybrid chaining on rules without arguments ,NA,NA
"(e) inheritance of a property with respect to ""part_of"", for a finite set of facts ",NA,NA
"(f) inheritance of a property with respect to ""is_another_name_for"", for a finite set of facts ",NA,NA
(g) proving something by resolution on clauses without arguments ,NA,NA
I-38. (for Miscellaneous problems) Consider the data-flow diagram on the next page. The circles are data ,NA,NA
"objects, and the rectangles are processes operating on the data objects. ",NA,NA
.PA .PA ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (18 of 88) [23/04/2002 17:40:03],NA
(a) Represent the entire diagram as a set of Prolog facts in the form ,NA,NA
"c(<input-object>,<process>,<output-object>). ",NA,NA
"where ""c"" stands for ""connection"". Some processes take two inputs; represent these with two facts. ",NA,NA
"(Remember, ""<"" and "">"" are not Prolog symbols, but a way to describe something.) (b) ",NA,NA
"Suppose that for some objects and some processes, we have additional facts of the form ",NA,NA
defective(<object>). faulty(<process>). ,NA,NA
An object is defective if it is the output of a process that is faulty. An object is also defective if it is the ,NA,NA
output of a process for which at least one input is defective. Write these as two Prolog inference rules that ,NA,NA
"use the ""c"" facts. (""Defective"" and ""faulty"" don't necessarily mean all the time; that is, the object or ",NA,NA
process could be correct part of the time. But you don't need to use probabilities in your rules.) ,NA,NA
"(c) Suppose process p is faulty; that is, we have the fact ",NA,NA
faulty(p). ,NA,NA
"Explain how a Prolog interpreter would prove that object d is defective, using the facts from part (a) and ",NA,NA
"the rules from part (b), and no additional rules. Give each step that the interpreter would take, including ",NA,NA
every variable binding. And give the starting query. ,NA,NA
(d) Write the rules of part (b) in clause form. ,NA,NA
"(e) Prove by resolution that if object f is not defective, then object c is not defective either. Use the clauses ",NA,NA
from (d) and the facts from (a). (Warning: don't ever resolve clauses with variables in common; rename ,NA,NA
the variables first.) ,NA,NA
(f) Suppose that in some data-flow diagram (not necessarily that in parts (a)-(e)) the objects X and Y are ,NA,NA
defective. Consider the problem of determining whether defective object X could explain defective object ,NA,NA
"Y; that is, whether there's some path from X to Y. This can be considered a search problem in which the ",NA,NA
"states are objects, the starting state is X, and the goal state is Y. If the branching factor is the same in both ",NA,NA
"directions, would bidirectional search be a good idea? Why? ",NA,NA
(g) Assume we are searching left-to-right with the diagram considered in parts (a) through (e). Assume ,NA,NA
"we want to find a connection between an X and Y picked randomly, with a pick of any object in the ",NA,NA
diagram equally likely. What is the average branching factor for states (including state f)? ,NA,NA
"(h) Suppose we want a Prolog program to do this search. To use the search programs in the book, we must ",NA,NA
"define a ""successor"" predicate of two arguments, an input state and an immediate successor output state. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (19 of 88) [23/04/2002 17:40:03],NA
"Write its Prolog definition, using the ""c"" predicate of part (a). ",NA,NA
"(i) Now suppose we want to find all the defective objects and faulty processes, given a partial set of ",NA,NA
"""defective"" and ""faulty"" facts and the inference rules of part (b). Explain how relaxation could do this. ",NA,NA
What would be the variables? What would be the values? What would be the constraints? ,NA,NA
(j) Suppose we know many facts about the processes (rectangles) in a data-flow diagram; then frames ,NA,NA
could represent processes. Consider the superframe (generalization frame) representing all occurrences of ,NA,NA
"the ""q"" process in a data-flow diagram. Give examples (one each) of value and slot inheritance from this ",NA,NA
frame to a more specialized frame. ,NA,NA
"(k) Frames could represent sections of a data-flow diagram; these would be ""part_of"" superframes. For ",NA,NA
"instance, the example diagram for part (a) could be considered one big process with ""a"" as input and ""f"" ",NA,NA
as output. This leads to hierarchical data-flow diagrams. Suppose for some process in a diagram there was ,NA,NA
"an multiple-inheritance conflict between the ""core-memory-required"" value inherited from this ""part_of"" ",NA,NA
"superframe and the ""core-memory-required"" value inherited from the generalization superframe of part ",NA,NA
(j). How would you resolve the conflict in a general and efficient way? ,NA,NA
(l) Explain how to get a helpful lower-bound evaluation function for the search problem described in part ,NA,NA
"(d), one that will work for any X and Y on any diagram. Assume the diagram is described by Prolog facts ",NA,NA
"like those in part (a). To make your evaluation function work, you can store extra facts with each node of ",NA,NA
the diagram (but you can't select the facts based on knowledge of X and Y--the same facts must be used ,NA,NA
for every X and Y). Your evaluation function shouldn't actually solve the problem because then it would ,NA,NA
"be a solution method, not an evaluation function. ",NA,NA
.PA ,NA,NA
ANSWERS TO MORE TEXT PROBLEMS ,NA,NA
"(This, and Appendix G in the book, cover the answers to nearly all the problems. The only exceptions are ",NA,NA
the problems that require very long answers.) ,NA,NA
2-3. See the next page. ,NA,NA
2-4. One way: ,NA,NA
"circle(c1). circle(c2). circle(c3). circle(c4). big(c1). small(c2). small(c3). small(c4). inside_of(c2,c1). ",NA,NA
"right_of(c3,c1). above(c4,c3). touching(c1,c3). touching(c3,c4). same_center(c2,c1). ",NA,NA
"Note it's important to specify the type of c1, c2, c3, and c4 as circles, and important to specify ""touching"" ",NA,NA
"relationships in addition to ""right_of"" relationships. Additional redundant facts could also be included ",NA,NA
beyond the preceding. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (20 of 88) [23/04/2002 17:40:03],NA
.PA .PA ,NA,NA
"2-8. Facts about the crime and the nature of the crime, how it was committed, and what objects were ",NA,NA
involved in it. These things don't require any common arguments except perhaps a specific code ,NA,NA
"distinguishing the specific crime. Reports from witnesses can also include this code, but they will also all ",NA,NA
"require two additional arguments: the name of the witness, and the time the specific observation was ",NA,NA
"made. It's important to record the time, because the same action may occur more than once, and it's ",NA,NA
"important to record the name of the witnesses because some witnesses lie, and their reports cannot be ",NA,NA
"taken as facts. (By ""time"" we mean a unique identification for every unique time, so this may require a ",NA,NA
"date as well as hours, minutes and seconds.) ",NA,NA
"2-9. Both can be expressed with type predicates, with predicate name ""mayor"". But ""Clint"" is a man's ",NA,NA
"name and must represent a specific entity; ""someone"" is an English pronoun that can stand for any person. ",NA,NA
"In fact, ""someone"" doesn't mean anything here because any ""mayor"" is a person. So ""someone"" is like a ",NA,NA
"placeholder or ""variable"", to which a word can later be assigned. In particular, it's like an existentially ",NA,NA
"quantified variable (see Appendix A). In Prolog, existentially quantified facts like that cannot be ",NA,NA
represented directly. ,NA,NA
"2-10. In the first sentence, ""boss"" indicates a relationship-predicate fact about two people; ""boss"" is like ",NA,NA
"the predicate name. In the second sentence, it represents an action of ordering people around, and could ",NA,NA
"be either a predicate name or an argument. (A ""boss"" does not necessarily ""boss"" people around, and not ",NA,NA
"only ""bosses"" boss people around.) In the third sentence it refers to a symbol in English used to represent ",NA,NA
"a word, so it's a statement about the symbols in a language; the word would be represented as an ",NA,NA
"argument, not a predicate name. In the fourth sentence it refers to an abstract concept of being a boss, ",NA,NA
something related to but distinct from the bossing relationship in the first sentence; and the concept would ,NA,NA
"be an argument, not a predicate. These four meanings are so different it would be poor judgment to use ",NA,NA
"the same word for any of them in a computer representation, in line with the suggestion #3 in section 2.4 ",NA,NA
to avoid names with multiple meanings. ,NA,NA
"2-11. (a) It's more ""natural"", more like how people talk. So syntax errors are less likely than with ",NA,NA
predicates. ,NA,NA
"(b) There are many different ways of expressing things in English, and you must handle all of them. ",NA,NA
"(c) English is a lot more ambiguous than predicates. The word ""is"" is used in many different ways, as well ",NA,NA
"as many other words like ""the"" and ""at"". So to make such an approach work, systems have to restrict the ",NA,NA
English input from the user. These restrictions are usually hard to remember and easy to get confused ,NA,NA
about. ,NA,NA
"3-3. The answers to query 2 are a subset or the same as the answers to query 1. Query 2 just ""filters out"" ",NA,NA
some of the answers to Query 1 by its additional predicates. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (21 of 88) [23/04/2002 17:40:03],NA
"3-4. ""The"" signals a reference to something used before, unlike ""a"" and ""an""; ""the memo"" refers to the ",NA,NA
"previous ""a memo"", and ""the meeting"" to the previous ""a meeting"". So it's like the way variables are ",NA,NA
"handled in a query, the ""generate-and-test"" approach: ""the"" corresponds to a bound variable, and ""a"" to an ",NA,NA
unbound variable. ,NA,NA
3-7. (a) ,NA,NA
"married(jason,phoebe). married(phoebe,jason). married(perry,stacey). married(stacey,perry). ",NA,NA
"married(eulalie,lane). married(lane,eulalie). loves(phoebe,perry). loves(zack,phoebe). loves(lane,phoebe). ",NA,NA
"loves(jason,eulalie). ",NA,NA
"(b) Jason and Phoebe only, the only A and B values found below: ",NA,NA
"?- married(A,B), loves(A,C), loves(B,D), not(loves(A,B)), not(loves(B,A)). A=jason B=phoebe C=eulalie ",NA,NA
D=perry ; ,NA,NA
A=phoebe B=jason C=perry D=eulalie ; ,NA,NA
no ,NA,NA
"(c) The jealous people are Phoebe, Zack, Lane, Jason, and Stacey. They are the possible A values in the ",NA,NA
following: ,NA,NA
"?- (loves(A,B); married(A,B)), loves(C,B). ",NA,NA
A=phoebe B=perry C=phoebe ; ,NA,NA
A=zack B=phoebe C=zack ; ,NA,NA
A=zack B=phoebe C=lane ; ,NA,NA
A=lane B=phoebe C=zack ; ,NA,NA
A=lane B=phoebe C=lane ,NA,NA
A=jason B=eulalie C=jason ; ,NA,NA
A=jason B=phoebe C=zack ; ,NA,NA
A=jason B=phoebe C=lane ; ,NA,NA
A=stacey B=perry C=phoebe ; ,NA,NA
A=lane B=eulalie C=jason ; ,NA,NA
no ,NA,NA
"3-8.(a) The query asks for ""a"" facts whose arguments match those of ""b"" facts. So there are two answers: ",NA,NA
"X=3 and Y=2, and X=4 and Y=4. ",NA,NA
(b) This query imposes an additional restriction on the solutions to part (a); X=4 and Y=4 is the only ,NA,NA
possibility that satisfies the additional predicate expression. ,NA,NA
"3-10.(a) Twice: once for X=a and Y=b, and once for X=b and Y=b. The binding X=c and Y=d succeeds. ",NA,NA
"(b) Three times: once for X=a, Y=b, and Z=b; once for X=b, Y=b, and Z=b; and once for X=c, Y=d, ",NA,NA
and Z=a. ,NA,NA
(c) None--Prolog interpreters don't backtrack to the last query predicate unless a semicolon is typed. ,NA,NA
(d) Once: for the last binding X=c and Y=d. Then the binding X=c and Y=a is found and it succeeds. ,NA,NA
"(e) Once: for the last binding X=c, Y=d, and Z=a. ",NA,NA
3-11. One way: ,NA,NA
"subdepartment(<department>,<subdepartment>). project(<project-name>,<project-code>, <starting-",NA,NA
"date>,<completion-date>,<subdepartments>). employee(<employee-name>,<ss-number>,<birth-date>, ",NA,NA
"<home-address>,<office>,<job-skills>). employee_project_match(<ss-number>,<project-code>). ",NA,NA
"Note that since usually a project has only one subdepartment, we might as well make that attribute an ",NA,NA
"argument in the ""project"" facts; but since the number of employees in a project could vary widely, the ",NA,NA
"association of employees to projects should be handled by separate ""employee_project_match"" facts in ",NA,NA
which both the same employee and the same project can be mentioned multiple times. Note that job skills ,NA,NA
"can go in the ""employee"" facts since they can efficiently be stored by a bit array, giving a fixed record ",NA,NA
length for all employees. ,NA,NA
3-12. (a) The computer took the question too literally; it should have realized that what the person really ,NA,NA
"wanted to know was the name of that commander and his rank, not whether it had the capability of ",NA,NA
finding out those things. So a natural language front end must have expectations about what it will be ,NA,NA
"called upon to do, and it must live up to those expectations rather than answering a question literally. (b) ",NA,NA
"Again the computer is taking the user's questions too literally, but now the bug is more subtle because ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (23 of 88) [23/04/2002 17:40:03],NA
the answers given are correct for sailboats and other small ships that don't have recorded locations and ,NA,NA
"commanders. In order to answer the question, the computer discovered that the Pequod does not exist, and ",NA,NA
then it concluded that there are never any commanders for ships that do not exist. But that first conclusion ,NA,NA
"is much more interesting than the second, so the computer should have given it instead. That feature of ",NA,NA
"computer behavior is called being ""cooperative"". ",NA,NA
"4-1. For one thing, the "":-"" has a procedural meaning, not just a declarative one like logical implication. ",NA,NA
"For another, the "":-"" also includes a causal relation between the thing implying and the thing implied. A ",NA,NA
"logical implication has no such causal meaning, and can in fact be equally well used in a backwards or ",NA,NA
"""contrapositive"" way, whereby if A implies B, then not(B) implies not(A). Chapter 14 discusses this ",NA,NA
more. ,NA,NA
4-3. One way: ,NA,NA
"father(X,Y) :- child(X,M,Y,S). ",NA,NA
"mother(X,Y) :- child(F,X,Y,S). ",NA,NA
"son(X,Y) :- child(Y,M,X,male). son(X,Y) :- child(F,Y,X,male). ",NA,NA
"grandfather(X,Y) :- father(X,Z), parent(Z,Y). parent(X,Y) :- father(X,Y). parent(X,Y) :- mother(X,Y). ",NA,NA
"sister(X,Y) :- child(F,M,X,female), child(F,M,Y,S), not(same(X,Y)). same(X,X). ",NA,NA
"uncle(X,Y) :- parent(P,Y), brother(X,P). uncle(X,Y) :- parent(P,Y), sister(Z,P), married(Z,X). ",NA,NA
"brother(X,Y) :- child(F,M,X,male), child(F,M,Y,S), not(same(X,Y)). married(X,Y) :- child(X,Y,C,S). ",NA,NA
"married(X,Y) :- child(Y,X,C,S). ",NA,NA
"ancestor(X,Y) :- parent(X,Y). ancestor(X,Y) :- parent(X,Z), ancestor(Z,Y). ",NA,NA
"halfsister(X,Y) :- child(F,M,X,female), parent(P,X), parent(P,Y), not(sister(X,Y)), not(same(X,Y)). ",NA,NA
4-4. Code: ,NA,NA
"on(b,a). on(c,b). on(d,c). on(f,e). on(g,f). on(i,h). left(a,e). left(e,h). above(X,Y) :- on(X,Y). above(X,Y) :- ",NA,NA
"on(X,Z), above(Z,Y). stackleft(X,Y) :- left(X,Y). stackleft(X,Y) :- left(X,W), above(Y,W). stackleft(X,Y) ",NA,NA
":- left(Z,Y), above(Z,X). stackleft(X,Y) :- left(Z,W), above(Z,X), above(Y,W). ",NA,NA
Run: ,NA,NA
"?- on(X,b). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (24 of 88) [23/04/2002 17:40:03],NA
X=c ; ,NA,NA
"no ?- on(a,X). ",NA,NA
"no ?- on(X,Y). ",NA,NA
X=b Y=a ; ,NA,NA
X=c Y=b ; ,NA,NA
X=d Y=c ; ,NA,NA
X=f Y=e ; ,NA,NA
X=g Y=f ; ,NA,NA
X=i Y=h ; ,NA,NA
"no ?- on(X,Y),left(Y,Z). ",NA,NA
X=b Y=a Z=e ; ,NA,NA
X=f Y=e Z=h ; ,NA,NA
"no ?- above(X,Y). ",NA,NA
X=b Y=a ; ,NA,NA
X=c Y=b ; ,NA,NA
X=d Y=c ; ,NA,NA
X=f Y=e ; ,NA,NA
X=g Y=f ; ,NA,NA
X=i Y=h ; ,NA,NA
X=c Y=a ; ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (25 of 88) [23/04/2002 17:40:03],NA
X=d Y=b ; ,NA,NA
X=d Y=a ; ,NA,NA
X=g Y=e ; ,NA,NA
"no ?- above(X,f); (left(Y,Z),above(X,Y),above(f,Z)). ",NA,NA
X=g Y=_5 Z=_6 ; ,NA,NA
X=b Y=a Z=e ; ,NA,NA
X=c Y=a Z=e ; ,NA,NA
X=d Y=a Z=e ; ,NA,NA
"no ?- above(X,Y), not(left(X,Z)). ",NA,NA
X=b Y=a Z=_6 ; ,NA,NA
X=c Y=b Z=_6 ; ,NA,NA
X=d Y=c Z=_6 ; ,NA,NA
X=f Y=e Z=_6 ; ,NA,NA
X=g Y=f Z=_6 ; ,NA,NA
X=i Y=h Z=_6 ; ,NA,NA
X=c Y=a Z=_6 ; ,NA,NA
X=d Y=b Z=_6 ; ,NA,NA
X=d Y=a Z=_6 ; ,NA,NA
X=g Y=e Z=_6 ; ,NA,NA
no ,NA,NA
"4-8. X=3, Y=3. X=1 and Y=2 can't match either of the ""b"" facts or the ""b"" rule. X=3 and Y=5 can't match ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (26 of 88) [23/04/2002 17:40:03],NA
"the ""b"" facts, and matching the ""b"" rule would require that ""b(2,5)"" be provable, and it isn't. So the ""a"" ",NA,NA
rule must be used if there is to be any answer to the query. R=1 and S=3 won't work because there isn't ,NA,NA
"any ""b(2,1)"" fact; R=2 and S=3 won't work because there isn't any ""b(2,2)"" fact. So the ""b"" rule must be ",NA,NA
"used to get an R and an S. But on its right side, T can be bound to 3 and match the two ""b"" facts. So ",NA,NA
"""b(3,3) is proved, and hence ""a(3,3)"" is proved. ",NA,NA
"4-9. For the relationship ""part_of"", the properties ""author"", ""language_written_in"", and ",NA,NA
"""source_institution"" inherit downwards (that is, from the program to the subprogram); the property ",NA,NA
"""has_bugs"" inherits upwards. For the relationship ""a_kind_of"", the properties ""has_applications_to"", ",NA,NA
"""requires_128K_machine"", and ""Company_X_sells_a_program_of_this type"" inherit upwards (from more ",NA,NA
specific program to more general program). ,NA,NA
4-12. (a) Upwards. Properties involving existential quantification usually inherit upwards. ,NA,NA
(b) Neither direction. Statistical properties usually don't inherit either way. ,NA,NA
(c) Downwards. Properties involving universal quantification usually inherit downwards. ,NA,NA
(d) Downwards. Another universal quantification. ,NA,NA
4-14. (a) 0--it could be a fact. (Or maybe 1 if you read the question as meaning the second transitivity rule ,NA,NA
must be used once.) ,NA,NA
"(b) Twenty-nine, when the objects all form a single chain. Note that the number of connections in a chain ",NA,NA
"of number N items is N-1, and we can leap the final gap with a fact instead of a rule--so that's N-2 uses of ",NA,NA
the second transitivity rule. ,NA,NA
(c) A balanced binary tree of height 4. ,NA,NA
"(d) 3, the height of the tree minus one, (since we can leap the last gap with a fact). ",NA,NA
"(e) Once, since the only recursion necessary is done by the transitive predicate ""a_kind_of"" and not in the ",NA,NA
inheritance rule itself. ,NA,NA
4-15.(a) Note that Tom's Rabbit bears the same relationship to all Rabbits as all Rabbits do to all VWs: ,NA,NA
"the first thing is a kind of the second thing. Similarly, an alternator bears the same relationship to an ",NA,NA
electrical system as an electrical system does to a VW: the first thing is part of the second thing. Note also ,NA,NA
that three English phrases represent single concepts and thus can each map to a single word in Prolog: ,NA,NA
"VW Rabbit, Tom's car, and Dick's car; we use the underscore character (_) in the Prolog words in these ",NA,NA
situations. So we get (noting that no characters may be capitalized): ,NA,NA
"a_kind_of(vw_rabbit,vw). a_kind_of(toms_car,vw_rabbit). a_kind_of(dicks_car,vw_rabbit). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (27 of 88) [23/04/2002 17:40:03],NA
"part_of(electrical_system,vw). part_of(alternator,electrical_system). defective(alternator). ",NA,NA
The last fact does not need to be qualified as to the kind of car since we're only talking about VW's here. ,NA,NA
"To use artificial intelligence terminology, VWs are the universe of discourse. You also might want to ",NA,NA
"include facts of ownership, and the statement that the alternator is on the VW, though you don't need them ",NA,NA
for parts (b) and (c): ,NA,NA
"owns(tom,vw_rabbit). owns(dick,vw_rabbit). on(alternator,vw). ",NA,NA
Note that our predicates are quite general--this is the usual way that artificial intelligence knowledge ,NA,NA
"representation is done. The specific things mentioned like VW Rabbits, Tom's car, and electrical systems ",NA,NA
"should be arguments to predicates, not the names of predicates. Then we don't have to write a lot of ",NA,NA
different inferences rules for all our predicate names. So all the following would be poor knowledge ,NA,NA
representation: ,NA,NA
vw(vw_rabbit). vw_rabbit(tom). vw_part_of(electrical_system). has_electrical_system(vw). ,NA,NA
alternator_defective(vw). ,NA,NA
Also note that nothing is asserted about VWs being cars or VW Rabbits being cars--only that Tom has a ,NA,NA
car and Dick has a car. ,NA,NA
(b) You need to say that a_kind_of and part_of are transitive: ,NA,NA
"a_kind_of(A,C) :- a_kind_of(A,B), a_kind_of(B,C). part_of(D,F) :- part_of(D,E), part_of(E,F). ",NA,NA
"and also the defectiveness inherits with respect to them. That is, that something is defective if it is a ",NA,NA
"member of a class of things that are defective, or if any part of it is defective: ",NA,NA
"defective(G) :- a_kind_of(G,H), defective(H). defective(I) :- part_of(J,I), defective(J). ",NA,NA
"Note the reversed order of arguments in the second rule--defectiveness inherits upwards for part_of, and ",NA,NA
downwards for a_kind_of. ,NA,NA
"Alternatively, you could use the on(alternator,vw) information with this rule: ",NA,NA
"part_of(K,L) :- on(K,L) ",NA,NA
"and eliminate the second rule above. But this is controversial--something could be ""on"" a car, like a ski ",NA,NA
"rack, and not be part of the car. ",NA,NA
"(c) The goal is to prove defective(dicks_car). By the fourth rule above, it is sufficient to show the some ",NA,NA
part of Dick's car is defective. Using the part_of transitivity rule (the second rule above) with ,NA,NA
"D=alternator, E=vw, F=electrical_system, or the last rule above, we see that the alternator is part of the ",NA,NA
"VW. Since all alternators are defective, it follows all VWs are defective. Now using the first rule with ",NA,NA
"A=dicks_car, B=vw, C=vw_rabbit, we see that Dick's car is a VW. Hence by the third rule, Dick's car is ",NA,NA
defective. ,NA,NA
4-16. One Prolog database: ,NA,NA
"limit(15) :- near_railroad, railroad_view_blocked, not(railroad_warning). railroad_warning :- ",NA,NA
railroad_gates. railroad_warning :- railroad_signal. railroad_warning :- flagman. limit(15) :- ,NA,NA
"near_intersection, intersection_view_blocked, not(right_of_way). right_of_way :- cross_street_yield. ",NA,NA
"right_of_way :- cross_street_stop. limit(15) :- in_alley. limit(X) :- sign(limit,X), X<25. limit(25) :- ",NA,NA
"sign(school), children_danger. children_danger :- children_present. children_danger :- unfenced-",NA,NA
"schoolyard. limit(X) :- sign(limit,X), X<56. limit(25) :- district(residential). limit(55). ",NA,NA
First database: ,NA,NA
"sign(limit,55). district(residential). ",NA,NA
Second database: ,NA,NA
"sign(school). children_present. sign(limit,55). district(residential). ",NA,NA
Third database: ,NA,NA
"sign(limit,35). in_alley. sign(school). children_present. sign(limit,55). district(residential). ",NA,NA
With the first situation: ,NA,NA
?- limit(X). ,NA,NA
X=55 ,NA,NA
yes ,NA,NA
With the second situation: ,NA,NA
?- limit(X). ,NA,NA
X=25 ,NA,NA
yes ,NA,NA
With the third situation: ,NA,NA
?- limit(X). ,NA,NA
X=15 ,NA,NA
yes ,NA,NA
"4-17. Legal definitions are much more flexible, because they deal with generally much more abstract ",NA,NA
notions. It's not a weakness of either legal definitions or Prolog it's just that they deal with different ,NA,NA
"things. It probably wouldn't be a good idea to make legal definitions more precise, because then they ",NA,NA
couldn't be applied to all the cases they need to be applied to. It probably wouldn't be a good idea to make ,NA,NA
Prolog less precise because precision is why people use computers in the first place. ,NA,NA
"4-18. Often the terms discussed are not clearly defined, and mean different things to different people. So ",NA,NA
people are mapping the same sentences into different internal representations. And because such terms are ,NA,NA
"often abstract, it's hard for people to understand the different meanings that each is assigning. ",NA,NA
4-19. (a) A piece of the rock. ,NA,NA
(b) Chemical decomposition of the rock into silicon and oxygen molecules. ,NA,NA
"4-20. This is the famous ""barber"" paradox of Bertrand Russell. (a) saves(X,God) :- not(saves(X,X)). ",NA,NA
"(b) The rule becomes: saves(God,God) :- not(saves(God,God)). ",NA,NA
"(c) No, the proper conclusion is that the original rule is faulty. Just because we can write something with ",NA,NA
Prolog notation doesn't make it true. ,NA,NA
5-3. ,NA,NA
"better_divide(X,Y,Q) :- not(var(X)), not(var(Y)), not(var(Q)), not(Y=0), Z is X / Y, Z=Q. ",NA,NA
"better_divide(X,Y,Q) :- not(var(X)), not(var(Y)), var(Q), not(Y=0), Q is X / Y. better_divide(X,Y,Q) :- ",NA,NA
"not(var(X)), var(Y), not(var(Q)), Y is Q * X. better_divide(X,Y,Q) :- var(X), not(var(Y)), not(var(Q)), X ",NA,NA
is Q * Y. ,NA,NA
"5-4. Use ""better_add"" and: ",NA,NA
"tax(G,D,R,T) :- better_add(D,N,G), better_multiply(N,R,T). tax(G,D,R,T) :- better_multiply(N,R,T), ",NA,NA
"better_add(D,N,G). better_multiply(X,Y,S) :- not(var(X)), not(var(Y)), not(var(S)), Z is X * Y, Z=S. ",NA,NA
"better_multiply(X,Y,S) :- not(var(X)), not(var(Y)), var(S), S is X * Y. better_multiply(X,Y,S) :- ",NA,NA
"not(var(X)), var(Y), not(var(S)), not(X=0), Y is S / X. better_multiply(X,Y,S) :- var(X), not(var(Y)), ",NA,NA
"not(var(S)), not(Y=0), X is S / Y. ",NA,NA
"Notice no ""var"" predicate expressions are needed in the ""tax"" rules; if more than one argument to ""tax"" is ",NA,NA
"unbound, both ""better_add"" and ""better_multiply"" will fail. ",NA,NA
5-5. ,NA,NA
"square(X,Y) :- not(var(X)), not(var(Y)), Z is X*X, Z=Y. square(X,Y) :- not(var(X)), var(Y), Y is X*X. ",NA,NA
"square(X,Y) :- var(X), not(var(Y)), square_bisection(X,Y,0,Y). square(X,Y) :- var(X), var(Y), ",NA,NA
"generate_pair(X,Y). ",NA,NA
"square_bisection(X,Y,Lo,Hi) :- X is (Lo+Hi)/2.0, square(X,S), close(S,Y). square_bisection(X,Y,Lo,Hi) :- ",NA,NA
"Midpoint is (Lo+Hi)/2.0, square(Midpoint,S), S<Y, square_bisection(X,Y,Midpoint,Hi). ",NA,NA
"square_bisection(X,Y,Lo,Hi) :- Midpoint is (Lo+Hi)/2.0, square(Midpoint,S), S>=Y, ",NA,NA
"square_bisection(X,Y,Lo,Midpoint). ",NA,NA
"close(X,Y) :- D is X-Y, D > -0.001, D < 0.001. ",NA,NA
"generate_pair(1,1). generate_pair(X,Y) :- generate_pair(A,B), X is A+1, Y is (A+1)*(A+1). ",NA,NA
"5-6. (a) Use the four lines defining ""better_add"", but change the name to ""integer_better_add"" and add ",NA,NA
one additional line: ,NA,NA
"integer_better_add(X,Y,S) :- var(X), var(Y), not(var(S)), integer_in_range(X,1,S), Y is S - X. ",NA,NA
"where ""integer_in_range"" is defined as in the chapter. ",NA,NA
"(b) Let S be the characteristic sum for the magic square, and let the letters of the alphabet starting with A ",NA,NA
represent the cells in the magic square in row-major order. Then: ,NA,NA
"magic_square(S,A,B,C,D,E,F,G,H,I) :- add_3(A,B,C,S), add_3(A,D,G,S), add_3(D,E,F,S), ",NA,NA
"add_3(B,E,H,S), add_3(G,H,I,S), add_3(C,F,I,S), add_3(A,E,I,S), add_3(C,E,G,S). add_3(X,Y,Z,S) :- ",NA,NA
"integer_better_add(X,W,S), integer_better_add(Y,Z,W). ",NA,NA
Note that the order of the expressions in the first rule is very important to the efficiency. ,NA,NA
"5-7. (a) X=3, Y=2. Notice the query contains three terms ""and""ed together. The first two predicate-a ",NA,NA
facts fail to satisfy the second condition in the query because c(0) is a fact. The third a fact fails because ,NA,NA
"of the d condition. So we must use the rule for a. The first condition matches with P=3 and Q=1, but the ",NA,NA
"second condition fails. So P=2 and Q=1 is tried and a(3,2) succeeds. The ""not"" condition and the d(3,2) ",NA,NA
"succeed so the whole query succeeds, and X=3 and Y= 2. ",NA,NA
"(b) X=2, Y=3. Obtained by the next possible match for b(P,Q), that of P=1 and Q=2. This succeeds with ",NA,NA
the other two query terms similarly. ,NA,NA
"5-9.(a) speed(<gear_number>,<speed_in_rpm>). Positive speeds can be clockwise, negative ",NA,NA
counterclockwise. ,NA,NA
"(b) speed(G,S) :- same_shaft(G,G2), speed(G2,S). ",NA,NA
"(c) speed(G,S) :- meshed(G,G2), teeth(G,TG), teeth(G2,TG2), speed(G2,S2), S is 0 - ( S2 * TG2 / TG ). ",NA,NA
(d) Use the following database: ,NA,NA
"speed(g1,5000). same_shaft(g2,g1). meshed(g3,g2). meshed(g4,g2). teeth(g1,100). teeth(g2,30). ",NA,NA
"teeth(g3,60). teeth(g4,90). speed(G,S) :- same_shaft(G,G2), speed(G2,S). speed(G,S) :- meshed(G,G2), ",NA,NA
"teeth(G,TG), teeth(G2,TG2), speed(G2,S2), S is 0 - ( S2 * TG2 / TG ). ",NA,NA
and issue this query: ,NA,NA
"?- speed(g4,S). ",NA,NA
"The one speed fact doesn't apply, so the first speed rule is tried. But there is no same_shaft fact with g4 as ",NA,NA
"first argument, so the rule fails. Now the second speed rule is tried. G2 can be matched to g2, with TG=90 ",NA,NA
"and TG2=30. Then we must find the speed of G2=g2. No fact applies, but we can use the first speed rule: ",NA,NA
"g2 is the first argument to a same_shaft fact having g1 as second argument, so its speed is the speed of g1. ",NA,NA
"And a fact says the speed of g1 is 5000. So the speed of g2 is 5000, and we can perform the calculation in ",NA,NA
the second speed rule as ,NA,NA
S = 0 - ( 5000 * 30 / 90 ) = -1667 rpm ,NA,NA
and the variable S in the original query is bound to that number. ,NA,NA
"(e) You could get infinite loops if you had extra redundant facts, like if you had both meshed(g2,g1) and ",NA,NA
"meshed(g1,g2). You could also get infinite loops if you had more than one inference rule of each of the ",NA,NA
"two above types, as if you had both ",NA,NA
"speed(G,S) :- same_shaft(G,G2), speed(G2,S). speed(G,S) :- same_shaft(G2,G), speed(G2,S). ",NA,NA
(f) The gears wouldn't turn--such a contradiction of rotation speeds is an impossibility. ,NA,NA
"5-10. It's easiest to just convert everything to meters, since you must worry about infinite loops otherwise. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (32 of 88) [23/04/2002 17:40:03],NA
"convert(M1,U1,M2,U2) :- conversion_factor(meters,U1,F1), conversion_factor(meters,U2,F2), M2 is ",NA,NA
M1*F2/F1. ,NA,NA
"conversion_factor(meters,meters,1). conversion_factor(meters,decimeters,10). ",NA,NA
"conversion_factor(meters,centimeters,100). conversion_factor(meters,millimeters,1000). ",NA,NA
"conversion_factor(meters,decameters,0.1). conversion_factor(meters,kilometers,0.001). ",NA,NA
"conversion_factor(meters,inches,39.37). conversion_factor(meters,feet,3.281). ",NA,NA
"conversion_factor(meters,yards,1.094). conversion_factor(meters,miles,0.0006214). ",NA,NA
"?- convert(2,feet,X,meters). ",NA,NA
X=0.609571 ,NA,NA
"yes ?- convert(2,feet,X,inches). ",NA,NA
X=23.9988 ,NA,NA
"yes ?- convert(20,kilometers,X,miles). ",NA,NA
X=12.428 ,NA,NA
"yes ?- convert(42.1,yards,X,decameters). ",NA,NA
X=3.84826 ,NA,NA
yes ,NA,NA
5-11.(a) ,NA,NA
"route(Town1,Town2,Routename,County,Distance), stateof(County,State), countryof(State,Country), ",NA,NA
"limit(State,Limit), limit(Country,Limit). ",NA,NA
(b) ,NA,NA
"limit(R,L) :- route(T1,T2,R,C,D), stateof(C,S),limit(S,L). limit(R,L) :- route(T1,T2,R,C,D), ",NA,NA
"stateof(C,S),countryof(S,K), limit(K,L). ",NA,NA
(c) ,NA,NA
"distance(T1,T2,D) :- route(T1,T2,R,C,D). distance(T1,T2,D) :- route(T1,T3,R,C,D3), ",NA,NA
"distance(T3,T2,D4), D is D3+D4. ",NA,NA
(d) r+c facts ,NA,NA
"(e) infinity, (if routes car contain same town many times). Otherwise, between 0 and t*t - t - r. ",NA,NA
Alternative: assign county to town ,NA,NA
"(a) route(Town1,Town2,Routename,Dist), countyof(Town,County), stateof(County,State), ",NA,NA
"countryof(State,Country), limit(CountyorState,Limit) ",NA,NA
"(b) limit(R,L) :- route(T1,T2,R,D), countyof(T1,C), countyof(T2,C), stateof(C,S), limit2(S,L). limit2(S,L) ",NA,NA
":- limit(S,L). limit2(S,L) :- countryof(S,K),limit(K,L). ",NA,NA
"(c) distance(T1,T2,D) :- route(Tl,T2,R,D). distance(T1,T2,D) :- route(T2,T1,R,D). distance(T1,T2,D) :- ",NA,NA
"route(T1,T3,R13,D13), distance(T3,T2,D32), D is D13 + D32. ",NA,NA
5-12. Use: ,NA,NA
"inference_distance(X,X,0). inference_distance(X,Y,N) :- a_kind_of(X,Z), inference_distance(Z,Y,N2), ",NA,NA
"better_add(N2,1,N). ",NA,NA
"where ""better_add"" is defined in the chapter. For a demonstration, assume we have these facts in our ",NA,NA
database: ,NA,NA
"a_kind_of(a,c). a_kind_of(b,c). a_kind_of(c,d). a_kind_of(c,e). ",NA,NA
"Here is a demonstration, showing the testing of all eight cases. (It's important to test all of them, because ",NA,NA
even a simple Prolog program can surprise you.) ,NA,NA
"?- inference_distance(a,c,1). ",NA,NA
"yes ?- inference_distance(a,c,N). ",NA,NA
N=1 ; ,NA,NA
"no ?- inference_distance(a,Y,2). ",NA,NA
Y=d ; ,NA,NA
Y=e ; ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (34 of 88) [23/04/2002 17:40:03],NA
"no ?- inference_distance(X,d,2). ",NA,NA
X=a ; ,NA,NA
X=b ; ,NA,NA
no ,NA,NA
"?- inference_distance(X,Y,2). ",NA,NA
X=a Y=d ; ,NA,NA
X=a Y=e ; ,NA,NA
X=b Y=d ; ,NA,NA
X=b Y=e ; ,NA,NA
"no ?- inference_distance(X,c,N). ",NA,NA
X=c ,NA,NA
N=0 ,NA,NA
; ,NA,NA
X=a ,NA,NA
N=1 ,NA,NA
; ,NA,NA
X=b ,NA,NA
N=1 ,NA,NA
; ,NA,NA
"no ?-inference_distance(a,Y,N). ",NA,NA
Y=a ,NA,NA
N=0 ,NA,NA
; ,NA,NA
Y=c ,NA,NA
N=1 ,NA,NA
; ,NA,NA
Y=d ,NA,NA
N=2 ,NA,NA
; ,NA,NA
Y=e ,NA,NA
N=2 ,NA,NA
; ,NA,NA
"no ?- inference_distance(X,Y,N). ",NA,NA
X=_0 Y=_0 N=0 ; ,NA,NA
X=a Y=c N=1 ; ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (35 of 88) [23/04/2002 17:40:03],NA
X=a Y=d N=2 ; ,NA,NA
X=a Y=e N=2 ; ,NA,NA
X=b Y=c N=1 ; ,NA,NA
X=b Y=d N=2 ; ,NA,NA
X=b Y=e N=2 ; ,NA,NA
X=c Y=d N=1 ; ,NA,NA
X=c Y=e N=1 ; ,NA,NA
no ,NA,NA
"5-13. The function cannot be a strong homomorphism. That is, it cannot map a lot different situations ",NA,NA
"onto a small set of values. If so, odds are it is difficult, or perhaps even impossible, to fill in other ",NA,NA
arguments given the value of the last argument and perhaps a few others. Notice that much of arithmetic ,NA,NA
involves strong homomorphisms: there are many ways to add numbers to get the same sum or the same ,NA,NA
"product. So it is understandable that the Prolog ""is"" usually used with arithmetic isn't reversible. ",NA,NA
"5-15. There are two different ways the Prolog interpreter can recurse in in this situation, on lists of ",NA,NA
increasing size for its first argument and on lists of increasing size for its second argument. It can only ,NA,NA
recurse one way at a time. So it picks the second way and only generates appending situations where the ,NA,NA
first argument is the empty list. ,NA,NA
"5-16. (a) It finds an item, if any, that it can delete from the second-argument list to create the third-",NA,NA
argument list. ,NA,NA
(b) It will delete only the first occurrence of the first argument from the second-argument list. ,NA,NA
"5-17. (a) It replaces every other word in a list with the word ""censored"", binding the result to the second ",NA,NA
"argument. The rule (third line) just says if you can find an X and Y at the front of your list first argument, ",NA,NA
"change the Y to the word ""censored"" after recursively doing the same on the rest of the list. ",NA,NA
The easiest way to see this is figure out what happens with simple example lists: ?- ,NA,NA
"mystery([],Z). Z=[] ?- mystery([a],Z). Z=[a] ?- mystery([a,b],Z). Z=[a,censored] ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (36 of 88) [23/04/2002 17:40:03],NA
"For the last example the third rule applies for the first time. So X is matched to a, Y is matched to b, and ",NA,NA
"L is matched to [], the empty list. The rule involves a recursive call with first argument L, but L is the ",NA,NA
"empty list, it's the same situation as the first example above, and M is bound to the empty list too. So the ",NA,NA
"rule says to take M and X and the word ""censored"" and assemble them into the result, the list whose first ",NA,NA
"two items are X and ""censored"", and whose remainder is M. But M is empty, so the result is [a,censored]. ",NA,NA
"Now consider the next hardest case, an example list with three items: ",NA,NA
"?- mystery([a,b,c],Z). ",NA,NA
"The third rule must be again used. It matches X to a, Y to b, and L to [c], the list containing only c. The ",NA,NA
"rule says to do a recursion with [c] the first argument. But to solve that the second rule will do, so M is ",NA,NA
"bound to [c]. So the answer is assembled from X, the word ""censored"", and that M, and the result for Z is ",NA,NA
"[a,censored,c]. ",NA,NA
Now consider an example list with four items: ,NA,NA
"?- mystery([a,b,c,d],L). ",NA,NA
"In the third rule, X is matched to a, Y is matched to b, and [c,d] is matched to L. The recursion applies ",NA,NA
"mystery to the two-item list [c,d], which by analogy to the above two-item example gives [c,censored]. So ",NA,NA
"we assembled the answer from X, the word ""censored"", and the list [c,censored], and the result for Z is ",NA,NA
"[a,censored,c,censored]. So it looks like the program changes every alternate word in a list to the word ",NA,NA
"""censored"". ",NA,NA
"(b) One for even-length lists, one for odd-length. The rule lops off two items from the list on each ",NA,NA
"recursion, so you can get into two different final situations. ",NA,NA
5-18. See the next page. ,NA,NA
.PA .PA ,NA,NA
"5-19. (a) N + 1 times, once for every item in the list plus once for the empty list; all these invocations will ",NA,NA
fail. ,NA,NA
"(b) (N-1)/2. There are 0 calls if the item is first in the list, one call if the item is second in the list, two ",NA,NA
"calls if the item is third in the list, and so on. These terms form an arithmetic series. The average value ",NA,NA
"of an arithmetic series is the average of the first and last numbers, in this case 0 and N - 1. ",NA,NA
5-20. Write substitution rules with variables instead of substitution facts. The right sides of the rules can ,NA,NA
"require that the variable bindings be drawn from lists of appropriate words, using the ""member"" predicate. ",NA,NA
For example: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (37 of 88) [23/04/2002 17:40:03],NA
"substitution([X,transition],[X,change]) :- ",NA,NA
"member(X,[will,must,should,can,might,perhaps,always,never]). ",NA,NA
5-21. The basis condition is wrong. The predicate only makes sense when you can compare horses in a ,NA,NA
"set. For that, you need a basis step concerning at least two horses. But obviously two horses aren't ",NA,NA
"necessarily the same color. Moral: even though basis conditions are usually simple, don't slight them in ",NA,NA
writing recursive programs: they can have some subtle bugs. ,NA,NA
"5-22. Use a list to keep arguments previously used, and just check to make sure a new value found is not ",NA,NA
"in the list. At every recursion, add the new argument to the list. So: ",NA,NA
"a3(X,Y) :- a2(X,Y,[]). a2(X,Y,L) :- a(X,Y). a2(X,Y,L) :- not(member(X,L)), a(X,Z), a2(Z,Y,[X|L]). ",NA,NA
"member(X,[X|L]). member(X,[Y|L]) :- not(X=Y), member(X,L). ",NA,NA
"Then you query a3 to compute relationships by transitivity. For instance, suppose you have the database: ",NA,NA
"a(r,s). a(s,t). a(t,r). ",NA,NA
"(For instance, predicate ""a"" might mean ""equals"" or ""is near"".) Then the query ",NA,NA
"?- a(r,t). ",NA,NA
"will succeed as it should, as will ",NA,NA
"?- a(r,r). ",NA,NA
But the query ,NA,NA
"?- a(r,u). ",NA,NA
will fail as it should. ,NA,NA
5-23. First define: ,NA,NA
"alldifferent([]). alldifferent([X|L]) :- not(member(X,L)), alldifferent(L). ",NA,NA
"Then define rhymes by facts with a list argument, for instance: ",NA,NA
"rhymes([ooga,booga,dooga,googa]). rhymes([itty,mitty,litty,sitty,ritty]). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (38 of 88) [23/04/2002 17:40:03],NA
"rhymes([drallak,pallak,thrallak,chrallak]). rhymes([morade,brocade,hodade,volade]). ",NA,NA
"rhymes([fufu,rufu,nufu,pufu]). onerhymes([bo,go,toe,joe,moe]). ",NA,NA
"To pick combinations of two or three rhyming words, we need: ",NA,NA
"rhymes2(X,Y) :- rhymes(L), member(X,L), member(Y,L), alldifferent([X,Y]). rhymes2(X,Y,Z) :- ",NA,NA
"rhymes(L), member(X,L), member(Y,L), member(Z,L), alldifferent([X,Y,Z]). onerhymes2(X,Y,Z) :- ",NA,NA
"onerhymes(L), member(X,L), member(Y,L), member(Z,L), alldifferent([X,Y,Z]). ",NA,NA
Finally we must define a predicate that puts the poem together: ,NA,NA
"poem([[A1,A2,B1],[C1,C2,B2],[D1,D2],[D3,D4],[E1,E2,B3]]) :- rhymes2(D1,D2), rhymes2(D3,D4), ",NA,NA
"alldifferent([D1,D2,D3,D4]), onerhymes2(B1,B2,B3), rhymes2(A1,A2), ",NA,NA
"alldifferent([A1,A2,D1,D2,D3,D4]), rhymes2(C1,C2), alldifferent([C1,C2,A1,A2,D1,D2,D3,D4]), ",NA,NA
"rhymes2(E1,E2), alldifferent([E1,E2,C1,C2,A1,A2,D1,D2,D3,D4]). ",NA,NA
Then to write a poem we just query ,NA,NA
?- poem(P). ,NA,NA
"6-2. The first fact data(3,0,1) can match the first predicate on the right side of the second rule, with A=3 ",NA,NA
"and B=1, giving a new rule: ",NA,NA
"bottom(3,1,7,D) :- data(3,D,1). ",NA,NA
"But the same fact can also match this new rule too with D=0. So we can prove the fact bottom(3,1,7,0). ",NA,NA
"We have exhausted the first fact, so we now consider this new fact. It can match the right side of the ""top"" ",NA,NA
"rule, so a new fact top(0,7,3) is proved. We now consider the only remaining fact, data(3,2,1), the second ",NA,NA
"of the original two facts. This can match the original ""bottom"" rule, giving: ",NA,NA
"bottom(A,B,7,2) :- data(A,0,B). ",NA,NA
"But data(3,2,1) can also match the first-listed rule above, giving a new fact bottom(3,1,7,2). This then ",NA,NA
"matches the right side of the ""top"" rule giving the final new fact top(2,7,3). ",NA,NA
"6-3.(a) M*min(F,S) matchings. The number of facts bounds the number of predicate names involved, but ",NA,NA
"so does S, so we must take the minimum. ",NA,NA
(b) L facts. Even if F=1 there exist rule-based systems for which every conclusion can be reached. ,NA,NA
"(c) T matchings. If the right side predicates all have the same predicate name, they could all match a ",NA,NA
single fact. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (39 of 88) [23/04/2002 17:40:03],NA
"(d) If all predicates are single-argument, each of the L distinct right sides could be bound in F+T-1 ways, ",NA,NA
"if all F facts and T right-side expressions have the same predicate name, and there are T-1 distinct ",NA,NA
"constants on right sides, giving L*(F+T-1) maximum conclusions. ",NA,NA
"6-4.(a) d(5), c(2), c(5), b(5), a(5). You cycle through the rules in order. The third rule succeeds first, then ",NA,NA
the fourth rule (which can be used in two different ways). Returning to the top of the list of rules on the ,NA,NA
"second cycle, the second rule can now succeed. Then on the third cycle the first rule can succeed. ",NA,NA
"(b) c(2), c(5), d(5), b(5), a(5). The first fact is g(2) which can match the right side of the last rule, so c(2) ",NA,NA
is proved. This implies the new rule b(2) :- d(2). The second fact is f(5) which can match part of the third ,NA,NA
"rule right side, giving d(5) :- e. The third fact is g(5) which can match the last rule, so c(5) is proved. This ",NA,NA
"implies the new rule b(5) :- d(5) analogous to the earlier offspring of this rule. The last fact is e, which can ",NA,NA
be used to proved d(5) from our previously derived d rule. This new fact d(5) can match the right side of ,NA,NA
"another derived rule, proving b(5). This matches the right side of the first rule, proving a(5). ",NA,NA
6-6. The facts true at some point in hybrid chaining are like the object being worked on an assembly ,NA,NA
line. New facts represent new parts or new connections made to the objects on the assembly line. As the ,NA,NA
"rules proceed a major conclusion is ""built up"" like an object assembly. Some rules may not succeed in ",NA,NA
"producing new facts, and they are like optional equipment on the assembly line that is only used for ",NA,NA
production of certain kinds of objects. ,NA,NA
6-10. (a) In decision lattices a single best path is taken through the lattice based on questions asked at ,NA,NA
each node. In the and-or-not all possible paths are explored in parallel (often by electronic signals). So ,NA,NA
"decision lattices require user interaction, while and-or-not lattices don't. Decision lattices require a lot of ",NA,NA
"work to construct from Prolog rules, while and-or-not lattices are a simple translation of what Prolog rules ",NA,NA
"mean. Decision lattices can represent nearly any rule-base system, whereas and-or-not lattices can only ",NA,NA
represent rule-base systems with no or limited variables. Decision lattices are good when you want to save ,NA,NA
"space because their implementation is very simple, whereas and-or-not are good when you want to save ",NA,NA
"time, and especially good when you have access to special-purpose hardware. ",NA,NA
"(b) Both represent ""compilation"" of rule-base systems, more efficient but harder to understand and modify ",NA,NA
than Prolog rules describing the same rule-base system. ,NA,NA
"6-11.(a) One solution: assign a fixed rule order of H, I, J, M, K, L, D, C, E, F, B, G, A. Then with ",NA,NA
"backwards chaining, rules would be invoked in order H, I, D, J, E, M, D, K, F, L, A. Note you don't ",NA,NA
actually have to do any work to satisfy C and E here. ,NA,NA
"(b) Forwards chaining and rule-cycle hybrid chaining would also work well. Another example: use a ""use-",NA,NA
"same-room-if-possible"" meta-rule as the basis of a control structure. That is, prefer to apply rules the ",NA,NA
"mention the current room (and if there are still two rules that apply, chooses the first one in rule order). ",NA,NA
"Then the above rules would be invoked in order H, I, D, J, E, M, D, K, F, L, A (same order as the ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (40 of 88) [23/04/2002 17:40:03],NA
"preceding, but rules could be listed in any order). ",NA,NA
"6-13. (a) plaintiff_money(M) :- award(A), pool(P), M is A+25+(P/2). defendant_money(M) :- award(A), ",NA,NA
"pool(P), M is 25+(P/2). pool(0) :- award(A), A>=500. pool(P) :- award(A), A<500, P is 500-A. ",NA,NA
"(b) plaintiff_money(M) :- award(A), A>=500, M is A+25. defendant_money(25) :- award(A), A>=500. ",NA,NA
"plaintiff_money(M) :- award(A), A<500, M is 275+(A/2). defendant_money(M) :- award(A), A<500, M ",NA,NA
is 275-(A/2). ,NA,NA
"(c) Yes, a large rule-based system is needed to apply laws of mathematics to simplify the arithmetic ",NA,NA
"expressions created by the substitution process, simply because there are so many laws of mathematics. ",NA,NA
"So-called ""symbolic algebra"" systems can do this, and they're generally big, complex programs. ",NA,NA
"(d) You lose the ability to name parts of the computation, so it's harder to debug and modify such ",NA,NA
"programs. Also, the mathematical expressions tend to get more complicated (though it didn't happen ",NA,NA
"above), and it's harder to see what's happening. ",NA,NA
"(e) This is for compiling arithmetic, not logic. It doesn't map to hardware so easily. It does handle variable ",NA,NA
bindings. ,NA,NA
"6-14. (a) It's a meta-rule, a rule controlling the selection of other rules. ",NA,NA
"(b) ""Simplest"" is very hard to define. It can't just mean the rules with the fewest predicates on their right ",NA,NA
"sides, because the complexity of those predicates matters even more. You can't just assign overall ",NA,NA
"""complexity numbers"" to those predicates either, because the complexity is a function of the context in ",NA,NA
which the predicates occur and the way they relate to each other as much as in the predicates themselves. ,NA,NA
"Also, there's another problem: the simplest explanation of something is often the most general ",NA,NA
"explanation, and such explanations aren't very useful. ",NA,NA
"6-15. Bureaucracies are less deterministic: if orders are given, they may not be followed, or may be ",NA,NA
"misunderstood and misapplied when followed. Still, there are analogies. Policies, regulations, and orders ",NA,NA
are formulated to constrain the activities of subordinates in certain desirable ways. So they can eliminate ,NA,NA
"the possibility of applying certain action methods or rules (like meta-rules), or they can set the priority of ",NA,NA
consideration of action methods or rules (like rule-ordering criteria). ,NA,NA
6-16. Good names are important in any programming. So we'll define: ,NA,NA
"""above_limit""=S1, ""at_limit""=S2, ""below_limit""=S3, ""two_lane""=S4, ""four_lane""=S5, ""intersection""=S6, ",NA,NA
"""car_close""=S7, ""2_to_4""=S8, ""4_to_2""=S9, ""brake_lights""=S10, ""closing""=S11, ""passing""=S12; and ",NA,NA
"""speed_up""=A1, ""slow_down""=A2, ""maintain_speed""=A3, ""pass""=A4. Conditions for slowing down are ",NA,NA
"most critical, so their rules should go first. One possible set of rules: ",NA,NA
"action(slow_down) :- danger. action(slow_down) :- above_limit. danger :- car_close, brake_lights. danger ",NA,NA
":- 4_to_2. danger :- intersection. danger :- confused. action(speed_up) :- not(danger), below_limit. ",NA,NA
"action(pass) :- passing. action(pass) :- not(4_to_2), not(intersection), car_close, closing. ",NA,NA
"action(maintain_speed). confused :- 2_to_4, 4_to_2. confused :- above_limit, below_limit. confused :- ",NA,NA
"above_limit, at_limit. confused :- at_limit, below_limit. ",NA,NA
"Many more rules defining ""confused"" can be added; they're error checkers. You query these rules by: ",NA,NA
?- action(X). ,NA,NA
much like the traffic-lights program of Chapter 4. ,NA,NA
6-17. (a) Random changes to a system that always does completely thorough reasoning with a set of goals ,NA,NA
"or facts just changes the order of that reasoning, not the set of conclusions reached. But if we assume ",NA,NA
people do incomplete reasoning much of the time--that is they don't follow their reasoning chains very ,NA,NA
far--then random rearrangement might make certain conclusions possible that weren't reasonable before. ,NA,NA
"In fact, there's much evidence that people do have such limitations, tending to get lost in complicated ",NA,NA
"reasoning chains. Of course, such random rearrangements could also make other inferences that used to ",NA,NA
be easy become harder. ,NA,NA
"(b) Again, if a system always does complete reasoning on a set of facts or a set of goals, a speedup of a ",NA,NA
factor of K in the reasoning for all the steps in a chain means a speedup of K for the entire chain. But if ,NA,NA
"we assume that people don't do complete reasoning, and in fact tend to get increasingly confused the ",NA,NA
"longer the reasoning goes on (which is documented by experiments), then the faster the reasoning steps ",NA,NA
occur the more humans can reason. This might permit all sorts of new conclusions that human beings ,NA,NA
"couldn't make before, and give effects far more than proportionate to the speedup. ",NA,NA
"7-3.(a) Yes, it's often typical; for instance, many auto repair books speak only in terms of symptoms and ",NA,NA
"fixes. One reason is that people often have trouble thinking up the appropriate intermediate predicates, ",NA,NA
because they're often abstract and they're not strictly necessary. This presents a problem in building expert ,NA,NA
"systems, because they can't be efficient unless intermediate predicates are defined. ",NA,NA
"(b) Intermediate predicates are a form of abstraction, and abstraction makes software easier to build, ",NA,NA
"easier to understand, and more reliable. While abstraction does have a cost overhead in design, and also ",NA,NA
"perhaps an overhead in implementation too, good software engineering practice has long emphasized its ",NA,NA
importance and necessity. ,NA,NA
7-4. [Too long to give here] ,NA,NA
7-6. [Too long to give here] ,NA,NA
7-7. Deletion can be done whenever all ways of using a rule have been exhausted. That occurs when ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (42 of 88) [23/04/2002 17:40:03],NA
either: ,NA,NA
--the exact left side of the rule is now a fact; ,NA,NA
"--there exists another rule with the exact same left side, whose right side predicate expressions are exactly ",NA,NA
a subset of those of this rule; ,NA,NA
"--the rule was created from another rule by matching a predicate expression without binding variables, or ",NA,NA
only binding variables that did not occur on the left side of the rule; ,NA,NA
"--the rule contains a ""not"" whose argument is now a fact; ",NA,NA
--the rule right side includes a predicate name that does not occur in a fact or in the left side of any other ,NA,NA
current rule; ,NA,NA
"--the rule right side contains a predicate expression with at least one variable, with a predicate that only ",NA,NA
"appears in facts, and every possible binding of the variable(s) has been used to generate a new rule; --",NA,NA
"some rule-based systems may have rules in partitions such that if no facts of a particular type are present, ",NA,NA
then the rules of that partition are useless; ,NA,NA
"--some rule-based systems may have rules in ""levels"" such that once all the initial facts have been ",NA,NA
"considered, all the bottom-level rules that refer only to facts can be eliminated. 7-8. [Too long to give ",NA,NA
here] ,NA,NA
7-9. [Too long to give here] ,NA,NA
7-10. [Too long to give here] ,NA,NA
7-12. [Too long to give here] ,NA,NA
"7-13. Just change the first term on the right side of the ""pursuit"" rule to ""pick_rule(L,R)"", defined ",NA,NA
analogously to the hybrid version: ,NA,NA
"pick_rule(L,R) :- rule(L,R), not(better_rule(L,R)). better_rule(L,R) :- rule(L2,R2), prefer(L2,R2,L,R). ",NA,NA
"7-14. (a) Each ""prefer"" rule represents conditions for ruling out a rule. So just write another one: ",NA,NA
"prefer(L,R,L2,R2) :- proved(L2), not(proved(L)). proved(F) :- fact(F). proved(F) :- usedfact(F). ",NA,NA
(b) Use the meta-rule: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (43 of 88) [23/04/2002 17:40:03],NA
"prefer(L,R,L2,R2) :- not(last_used(L,R)), last_used(L2,R2). ",NA,NA
"where we modify ""pick_rule"" as follows: ",NA,NA
"pick_rule(L,R) :- rule(L,R), not(better_rule(L,R)), checkretract(last_used(L2,R2)), ",NA,NA
"asserta(last_used(L,R)). ",NA,NA
"where ""checkretract"" is defined as ",NA,NA
"checkretract(F) :- call(F), retract(F). checkretract(F) :- not(call(F)). ",NA,NA
"7-15. To make this simpler, let askif(device_dead) = a, askif(lights_out) = b, askif(smell_smoke) = c, ",NA,NA
"askif(heats) = d, askif(has('knobs or switches')) = e, askif(knobs_do_something) = f, askif(powerful) = g, ",NA,NA
"askif(hear(pop)) = h, askif(cord_frayed) = i, askif(handyperson) = j, askif(familiar_appliance) = k, ",NA,NA
"askif(device_on) = l, askif(has('an on-off switch or control')) = m. ",NA,NA
"Then after substitution of intermediate predicates, and elimination of redundant rules (two rules for cord ",NA,NA
"breaks), 18 rules remain: ",NA,NA
"diagnosis('Fuse blown') :- a, b. diagnosis('Fuse blown') :- e, not(f), b. diagnosis('Fuse blown') :- c, not(d), ",NA,NA
"b. diagnosis('Fuse blown') :- c, not(g), b. diagnosis('Fuse blown') :- a, h. diagnosis('Fuse blown') :- e, ",NA,NA
"not(f), h. diagnosis('Fuse blown') :- c, not(d), h. diagnosis('Fuse blown') :- c, not(g), h. diagnosis('Break in ",NA,NA
"cord') :- a, i. diagnosis('Break in cord') :- e, not(f), i. diagnosis('Break in cord') :- c, not(d), i. ",NA,NA
"diagnosis('Break in cord') :- c, not(g), i. diagnosis('Device not turned on') :- a, not(j), m, not(l). ",NA,NA
"diagnosis('Device not turned on') :- a, not(k), m, not(l). diagnosis('Device not turned on') :- e, not(f), ",NA,NA
"not(j), m, not(l). diagnosis('Device not turned on') :- e, not(f), not(k), m, not(l). diagnosis('Device not ",NA,NA
"turned on') :- c, not(d), not(j), m, not(l). diagnosis('Device not turned on') :- c, not(g), not(j), m, not(l). ",NA,NA
"diagnosis('Device not turned on') :- c, not(d), not(k), m, not(l). diagnosis('Device not turned on') :- c, ",NA,NA
"not(g), not(k), m, not(l). ",NA,NA
"From counting the occurrences of terms on right sides, we have the following statistics (assuming, as was ",NA,NA
"stated, omission of a fact in a rule means it must be false if it occurs true in other rules, and means it must ",NA,NA
be true if it occurs false in other rules): ,NA,NA
"(predicate,count-of-occurrences, count-of-negation-occurrences): a,5,15 b,4,16 c,10,10 d,15,5 e,5,15 ",NA,NA
"f,15,5 g,15,5 h,4,16 i,4,16 j,16,4 k,16,4 l,12,8 m,8,12 ",NA,NA
"Predicate c seem be the most even split, so we'll pick it for the first question in the decision lattice. A ",NA,NA
"""yes"" answer to question c means that one of these rules applies: ",NA,NA
"diagnosis('Fuse blown') :- c, not(d), b. diagnosis('Fuse blown') :- c, not(g), b. diagnosis('Fuse blown') :- c, ",NA,NA
"not(d), h. diagnosis('Fuse blown') :- c, not(g), h. diagnosis('Break in cord') :- c, not(d), i. diagnosis('Break ",NA,NA
"in cord') :- c, not(g), i. diagnosis('Device not turned on') :- c, not(d), not(j), m, not(l). diagnosis('Device ",NA,NA
"not turned on') :- c, not(g), not(j), m, not(l). diagnosis('Device not turned on') :- c, not(d), not(k), m, not(l). ",NA,NA
"diagnosis('Device not turned on') :- c, not(g), not(k), m, not(l). ",NA,NA
"Here predicate expressions m, not(l), not(j), and not(k) are separately sufficient to distinguish the not-",NA,NA
"turned-on conclusion. Further questions can be asked to validate it. Otherwise, if predicate expression i is ",NA,NA
"true, further questions can be asked to validate a break in the cord. Otherwise, we can try to validate a ",NA,NA
blown fuse. ,NA,NA
Now suppose c is false. Then the applicable rules are: ,NA,NA
"diagnosis('Fuse blown') :- a, b. diagnosis('Fuse blown') :- e, not(f), b. diagnosis('Fuse blown') :- a, h. ",NA,NA
"diagnosis('Fuse blown') :- e, not(f), h. diagnosis('Break in cord') :- a, i. diagnosis('Break in cord') :- e, ",NA,NA
"not(f), i. diagnosis('Device not turned on') :- a, not(j), m, not(l). diagnosis('Device not turned on') :- a, ",NA,NA
"not(k), m, not(l). diagnosis('Device not turned on') :- e, not(f), not(j), m, not(l). diagnosis('Device not ",NA,NA
"turned on') :- e, not(f), not(k), m, not(l). ",NA,NA
"Again predicate expressions m, not(l), not(j), and not(k) are sufficient to distinguish the not-turned-on ",NA,NA
"condition, and expression i for the break-in-cord condition. ",NA,NA
The final decision lattice can be described this way: ,NA,NA
"1. Ask if the user smells smoke. If yes, go to step 2; else go to step 3. ",NA,NA
"2. Ask if the device has an on-off switch or control. If yes, go to step 4; else go to step 5. ",NA,NA
"3. Ask if the device has an on-off switch or control. If yes, go to step 8; else stop. ",NA,NA
"4. Verify if the user is either not good at fixing things or is not familiar with the appliance, and if the ",NA,NA
"device is not turned on; if so, that's the problem. Otherwise, stop. ",NA,NA
"5. Ask if the cord is frayed. If so, go to step 6; else go to step 7. ",NA,NA
"6. Verify that either the device does not heat or does not take a lot of power; if so, it's a break in the ",NA,NA
"cord. Otherwise, stop. ",NA,NA
"7. Verify that (1) either the device heats or takes a lot of power, and (2) the lights are out in the house or ",NA,NA
"the user heard a pop sound; if both are true, it's a blown fuse. Otherwise, stop. ",NA,NA
"8. Verify that (1) either the device seems dead, or the device has knobs and switches and they don't do ",NA,NA
anything; (2) the user is either not good at fixing things or is not familiar with the appliance; and (3) the ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (45 of 88) [23/04/2002 17:40:03],NA
"device is not turned on. If all are true, the last is the problem. Otherwise, stop. ",NA,NA
"9. Ask if the cord is frayed. If so, go to step 10; else go to step 11. ",NA,NA
"10. Verify that either (1) the device is dead, or (2) the device has knobs or switches and they don't do ",NA,NA
"anything; if so, there's a break in the cord. Otherwise, stop. ",NA,NA
"11. Verify that (1) either the lights are out or the user heard a pop sound, and (2) either the device is ",NA,NA
"dead or the device has knobs or switches that don't work; if both are true, it's a blown fuse. Otherwise, ",NA,NA
stop. ,NA,NA
7-16. [Too long to give here] ,NA,NA
"7-17. One way to do it, among many ways, with sample data built in (Chapter 10 will develop a better ",NA,NA
way to write similar state-changing programs): ,NA,NA
"robot :- repeat, move, goal_reached. goal_reached :- position(30,50). move :- position(X,Y), ",NA,NA
"stepoptions(DX,DY), X2 is X + DX, Y2 is Y + DY, trymove(X2,Y2), retractblocks(DX,DY), !. ",NA,NA
"stepoptions(1,0) :- position(X,Y), X < 30, not(verticalblock). stepoptions(0,1) :- not(horizontalblock). ",NA,NA
"stepoptions(-1,0) :- verticalblock. stepoptions(-1,0) :- not(verticalblock), asserta(verticalblock), ",NA,NA
"write([verticalblock,asserted]). stepoptions(0,-1) :- horizontalblock. stepoptions(0,-1) :- ",NA,NA
"not(horizontalblock),asserta(horizontalblock), write([horizontalblock,asserted]). trymove(X,Y) :- ",NA,NA
"newcraters, not(cratered(X,Y)), not(ravined(X,Y)), withinarea(X,Y), retract(position(X2,Y2)), ",NA,NA
"asserta(position(X,Y)), time(T), T2 is T + 1, asserta(time(T2)), retract(time(T)), write([x,X,y,Y,t,T2]),nl. ",NA,NA
"retractblocks(0,1) :- verticalblock, retract(verticalblock), write([verticalblock,retracted]). ",NA,NA
"retractblocks(-1,0) :- horizontalblock, retract(horizontalblock), write([horizontalblock,retracted]). ",NA,NA
"retractblocks(DX,DY). cratered(X,Y) :- crater(X2,Y2), withintwo(X,X2,Y,Y2), write('We are on the edge ",NA,NA
"of a crater.'), nl. withintwo(X,X2,Y,Y2) :- deviation(X,X2,DX), DX < 2, deviation(Y,Y2,DY), DY < 2. ",NA,NA
"deviation(A,B,D) :- D is A - B, D >= 0. deviation(A,B,D) :- D is B - A, D >= 0. newcraters :- time(45), ",NA,NA
"position(X,Y), X2 is X - 3, asserta(crater(X2,Y)). newcraters :- time(73), position(X,Y), X2 is X + 4, ",NA,NA
"asserta(crater(X2,Y)). newcraters. ravined(X,Y) :- Y = 30, X > 9, write('We are on the edge of a ravine.'), ",NA,NA
"nl. withinarea(X,Y) :- X > -1, X < 51, Y > -1, Y < 51. position(25,0). time(0). crater(20,10). crater(10,25). ",NA,NA
"crater(20,40). ",NA,NA
7-18. Causal chain reasoning is only desirable when greater flexibility of reasoning is needed. For ,NA,NA
"instance, when many diseases share common symptoms, and it's hard to give a specific conjunction of ",NA,NA
symptoms for each. The appliance program is a simplification in which only major symptom-to-cause ,NA,NA
"paths are recorded--that is, summary is done of many causal links. So clearly a better program could ",NA,NA
reason at a finer level of detail. ,NA,NA
8-1. The probability the battery is defective from the second rule is 0.9*0.8 = 0.72. Doing an orcombine ,NA,NA
"with the number from the first rule, we get 1 - 0.5*0.28 = 0.86. ",NA,NA
"8-2. The first rule gives the probability of ""a"" as 0.6, and the second as 0.8. We must ""orcombine"" these ",NA,NA
"two numbers to get a cumulative probability, since they are two pieces of evidence confirming the same ",NA,NA
thing. ,NA,NA
(a) 1 - (1-0.6)(1-0.8) = 1 - 0.08 = 0.92 ,NA,NA
"(b) max(0.6,0.8) = 0.80 ",NA,NA
"(c) min(1,0.6+0.8) = min(1,1.4) = 1.00 8-7. (a) PR (product of the probability and the number of things it ",NA,NA
can apply to) ,NA,NA
"(b) Among the R/D rules for a diagnosis, the probabilities of failure are independent too. So the total ",NA,NA
probability that all R/D rules fail is (1-P) to the R/D power. Hence the probability of that the diagnosis ,NA,NA
succeeds (it just takes one rule) is 1-(1 - P) to the R/D. That is the inverse of the probability that none of ,NA,NA
the rules proving a diagnosis will succeed. So the average number of diagnoses that succeed is D(1-(1-P) ,NA,NA
to the R/D. ,NA,NA
"8-8. The simplest way is to consider only direct positive evidence for some prediction (that is, no ""cross ",NA,NA
"terms""). ",NA,NA
"predict(W,P) :- bagof(X,total_predict(W,X),XL), orcombine(XL,P). total_predict(W,P) :- ",NA,NA
"bagof(X,previous_predict(W,X),XL), orcombine(XL,P). total_predict(W,P) :- ",NA,NA
"bagof(X,current_predict(W,X),XL), orcombine(XL,P). current_predict(W,0.7) :- current_west_view(W). ",NA,NA
"current_predict(W,0.5) :- current_east_view(W). current_predict(cloudy,0.9) :- raining(X). ",NA,NA
"previous_predict(W,0.3) :- weatherman_prediction(W). previous_predict(W,0.1) :- grandma_memory, ",NA,NA
"grandma_prediction(W). previous_predict(W,0.8) :- secretary_has_radio, not(secretary_out_to_lunch), ",NA,NA
radio_prediction(W). ,NA,NA
"Then to use these rules, just query: ",NA,NA
"?- predict(W,P). ",NA,NA
"type semicolons, and the probabilities obtained tell you how likely each kind of sky is. For instance, if ",NA,NA
you have the facts ,NA,NA
current_west_view(cloudy). current_east_view(sunny). weatherman_prediction(partly_cloudy). ,NA,NA
secretary_has_radio. radio_prediction(sunny). ,NA,NA
then you get: ,NA,NA
"?- predict(W,P). W=cloudy, P=0.7; W=partly_cloudy, P=0.3; W=sunny, P=0.9; ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (47 of 88) [23/04/2002 17:40:03],NA
"8-10. (a) The problem arises because students are not typical adults, but are exceptions to a usually-true ",NA,NA
rule. So just as with the traffic lights program we can write an exception rule and modify the old rule ,NA,NA
"accordingly, as for instance: ",NA,NA
"employed(X,P) :- student(X,P2), P2>0.1, P is 1.05-P2. employed(X,P) :- adult(X,P2), student(X,P3), ",NA,NA
"P3=<0.1, P is P2 * 0.9. ",NA,NA
We can also do much the same thing with just one rule: ,NA,NA
"employed(XP) :- adult(X,P2), student(X,P3), P is P2*(1-P3)*0.9. ",NA,NA
but then we have to commit ourselves to a theory of how the two probabilities interact. ,NA,NA
(b) The conservative assumption applied to Joe gives 0.9 + 0.95 - 1 = 0.85. Not much less than the ,NA,NA
independence-assumption value of 0.855. ,NA,NA
"(c) The problem is that rule-strength probabilities is not quite the same as additional conjuncts in a rule, ",NA,NA
for purposes of probability combination. So this is different than a rule that says X is employed if X is an ,NA,NA
"adult and X pays property taxes, where each of those two things has an associated probability. A true ",NA,NA
"combination for rule strength the value might be 0, because the evidence of the incoming conclusion ",NA,NA
"probability could be arbitrarily diluted in reaching the second conclusion. (Actually, it's never possible to ",NA,NA
"exactly get 0, but 0 is a lower bound.) ",NA,NA
One general way to handle situations like this is to extend evidence-combination to use more than just ,NA,NA
"probabilities as inputs. Probability rules could return not just a probability, but a list of predicates that ",NA,NA
"succeeded in getting the probability. Then a rule like ""employed"" above can check whether it is ",NA,NA
"particularly sensitive to anything in the list (by checking prestored sensitivity-pair facts), and fail if so; ",NA,NA
"special-case rules for ""employed"" could then do a different calculation. Another approach is to use Bayes' ",NA,NA
"Rule to estimate probabilities: store certain probabilities of two things happening simultaneously, and ",NA,NA
reason from those. ,NA,NA
"8-11. (a) ""Happy"" and ""unhappy"" are not true opposites in English--a person could have neither word ",NA,NA
"apply to them, so the two words don't describe possible emotional states. Notice that this is different from ",NA,NA
"the words ""done"" and ""undone"" which do represent true opposites. So you sometimes have to be careful ",NA,NA
analyzing English words. ,NA,NA
(b) It is dangerous when building rule-based expert systems with probabilities when the probability of X ,NA,NA
"(e.g. ""happy"") plus the probability of not(X) (e.g. ""unhappy"") isn't 1.0. Then there's a three-valued logical ",NA,NA
"situation here: yes, no or neither. So you couldn't get one from the other by subtracting the other from 1. ",NA,NA
"Instead we must reason separately about each of the two rules, writing separate rules about the value of ",NA,NA
each. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (48 of 88) [23/04/2002 17:40:03],NA
8-12. [Too long to give] ,NA,NA
"9-1. (a) A state must be a snapshot of a single time, not several times. ",NA,NA
(b) Temperature varies continuously--there can be no abrupt changes in temperature. (But a physicist ,NA,NA
might call this a physical state.) ,NA,NA
"(c) It's too complicated to describe as just a list of facts. Also, it seems to involve continuous-valued, not ",NA,NA
"discrete, phenomena. ",NA,NA
"9-3. No. For example, this set of branches: ",NA,NA
"branch from ""a"" to ""b"" branch from ""a"" to ""c"" branch from ""b"" to ""d"" branch from ""b"" to ""e"" branch from ",NA,NA
"""c"" to ""d"" branch from ""c"" to ""e"" branch from ""d"" to ""f"" branch from ""e"" to ""f"" ",NA,NA
"9-4. (a) A simple way is to abandon the focus-of-attention approach, and put new facts at the end of facts. ",NA,NA
In our implementation of breadth-first search in the next chapter we'll use this same trick. ,NA,NA
(b) A breadth-first approach might be to check all rules whose left sides match query predicates to see if ,NA,NA
their right sides are all facts: then check all rules whose left sides match the terms of all the previous right ,NA,NA
sides are all facts and so on. In other words something that sounds suspiciously like the rule-cycle hybrid. ,NA,NA
"The only difference is that rules are being invoked top-down, so an unsuccessful rule need not be tried ",NA,NA
"over and over again. Actually, such an invocation scheme would be a good way to organize hybrid ",NA,NA
chaining to make it more efficient. ,NA,NA
"9-5.(a) depth-first, since it would be awkward and silly to constantly return to previous nodes in real time. ",NA,NA
This is a good example of the difference between computer environments and the real world: it's easy to ,NA,NA
"return to previous nodes on a computer, but hard in the real world. Note of course you shouldn't use plain ",NA,NA
"depth-first search while driving, but you should use heuristics like those of part (i) to avoid getting too far ",NA,NA
away from the goal. ,NA,NA
"(b) plan routes from several other places to the goal, places just off the route ",NA,NA
"9-6.(a) state b (sequence is a, e, s, b). Costs and evaluation function values are irrelevant. ",NA,NA
"(b) state r (sequence is a, b, o, r). Costs are irrelevant. ",NA,NA
"9-7. (a) Vertical height on the page can be measured with numbers, but you can also use ""above(X,Y)"" to ",NA,NA
"represent relationships on the page, to the same effect. ",NA,NA
(b) Heuristics are binary: they either must apply or not apply. So to every possible permutation of success ,NA,NA
"or failure of heuristics, assign a number. Store these numbers in a big table, and just look them up as an ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (49 of 88) [23/04/2002 17:40:03],NA
"evaluation function. This evaluation is discrete and not continuous as a better one might be, but it's ",NA,NA
perfectly acceptable; you may be able to fit a curve to the numbers to get a continuous evaluation ,NA,NA
"function. Note you must rank permutations of success/failure for all the heuristics, not just rank the ",NA,NA
"heuristics, because a branch choice is usually determined by several heuristics working together. It also ",NA,NA
won't work in general to assign weights to heuristics and sum up the weights for the heuristics that apply ,NA,NA
"to a state, because there are many ways to get the same sum. ",NA,NA
(c) The mapping can often be done if you know all the possible states that occur in a problem. Then you ,NA,NA
"can just write very specific heuristics that say if state X occurs then do operator Y, where this ",NA,NA
recommendation of Y is consistent with the evaluation function. But if you don't know all the possible ,NA,NA
"states or if there are an infinity of them, you can't do this mapping. For instance, you can do this mapping ",NA,NA
"for route planning in a city, because there are a finite number of intersections in a city and they're the only ",NA,NA
points at which choices can be made; but you can't for route planning through a forest because there are ,NA,NA
an infinite number of choices you can make about your route. ,NA,NA
9-9. (a) branch-and-bound search ,NA,NA
(b) best-first search ,NA,NA
(c) breadth-first search ,NA,NA
9-12.(a) Here are some: ,NA,NA
--Prefer the branch that moves terminals only to their proper floor. --Prefer branches that move two ,NA,NA
terminals instead of one. --Prefer branches that move terminals to adjacent floors (but that may not be a ,NA,NA
"good heuristic, since it may cause you to move terminals twice). ",NA,NA
(b) One way is to count the number of terminals on wrong floors and divide by two (two is the maximum ,NA,NA
number of terminals that can be moved in any one step). But this doesn't take into account that terminals ,NA,NA
"two floors away are going to cost 1.2 times more, so a better evaluation function (that is still a lower ",NA,NA
bound) would be to sum up over all terminals .5 for each terminal that is one floor away from its correct ,NA,NA
"floor, and .6 for each terminal that is two floors away from its correct floor. (Note that an ""evaluation ",NA,NA
"function"" is a function definition, not a number.) ",NA,NA
"(c) Yes, branching factors are similar in both directions. This is because the operators are all reversible (if ",NA,NA
"you take the elevator and some terminals somewhere, you can always take them back). Note you could ",NA,NA
"use A* in both directions with bidirectional search, so A* is not incompatible with bidirectional (and note ",NA,NA
this would mean fewer node expansions than A* just one-way). It's true there are three goal states (the ,NA,NA
"elevator can be in three possible places), but that just means you shouldn't search as deep going ",NA,NA
"backwards as going forwards, not that bidirectional search won't work. ",NA,NA
(d) There are F different floors on which to place a single terminal. There are T terminals to place. So for ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (50 of 88) [23/04/2002 17:40:03],NA
"T=1, there are F states; for T=2, F*F states; and for F=3, F*F*F states. There are also F places to put the ",NA,NA
"elevator. So in general the number of different states is F multiplied by itself T+1 times, or F to the T+1 ",NA,NA
"power. However, you could argue that all the terminals destined for a single floor are indistinguishable. ",NA,NA
"This would reduce the preceding number since then some of the states considered would be identical, ",NA,NA
"but figuring out exactly how many involves some difficult mathematics, so the above upper bound (or ",NA,NA
something close) is sufficient for this answer. ,NA,NA
(e) Finding a good way to represent the state was very important for this problem. A good way is to code ,NA,NA
"the terminals with digits representing what floor they belong on, and bring together all the terminals on ",NA,NA
"one floor into a list. So states can be represented as [First,Second,Third,Elevator] where the first three ",NA,NA
"terms are lists containing the numbers 1, 2, and 3 an indefinite number of times, and Elevator is the ",NA,NA
"number of the floor the elevator is on. Then the starting state is [[2,3,3],[1],[2],1], which has evaluation ",NA,NA
"2.5 with the first-mentioned evaluation function, and cost 0 for a total of 2.5. Notice that your state ",NA,NA
representation must indicate the position of each terminal individually because a state description should ,NA,NA
"contain all the information necessary to uniquely specify a state. So it wouldn't do, say, to only indicate ",NA,NA
"for each floor how many terminals are there, because some of the terminals there might be destined for ",NA,NA
"different floors, and your plan to move them would be different than with other combinations of the same ",NA,NA
number of terminals on that floor. ,NA,NA
From the starting state we can go to one of eight states (using again the first-mentioned evaluation ,NA,NA
function): ,NA,NA
"[[3,3],[1,2],[2],2] -- evaluation 2.0, cost 1, total 3.0 [[3,3],[1],[2,2],3] -- evaluation 2.5, cost 1.2, total ",NA,NA
"3.7 [[2,3],[1,3],[2],2] -- evaluation 2.5, cost 1, total 3.5 [[2,3],[1],[2,3],3] -- evaluation 2.0, cost 1.2, ",NA,NA
"total 3.2 [[2],[1,3,3],[2],2] -- evaluation 2.5, cost 1, total 3.5 [[2],[1],[2,3,3],3] -- evaluation 1.5, cost ",NA,NA
"1.2, total 2.7 [[3],[1,2,3],[2],2] -- evaluation 2.0, cost 1, total 3.0 [[3],[1],[2,2,3],3] -- evaluation 2.0, ",NA,NA
"cost 1.2, total 3.2 ",NA,NA
"The sixth state is the lowest-cost, so we choose it for expansion. It leads to six new states ",NA,NA
"(remember, there's no point writing down states we found earlier): ",NA,NA
"[[2,2],[1],[3,3],1] -- evaluation 1.5, cost 2.4, total 3.9 [[2],[1,2],[3,3],2] -- evaluation 1.0, cost 2.2, total ",NA,NA
"3.2 [[2,3],[1],[2,3],1] -- evaluation 2.0, cost 2.4, total 4.4 [[2],[1,3],[2,3],2] -- evaluation 2.0, cost 2.2, ",NA,NA
"total 4.2 [[2,2,3],[1],[3],1] -- evaluation 2.0, cost 2.4, total 4.4 [[2],[1,2,3],[3],2] -- evaluation 1.5, cost ",NA,NA
"2.2, total 3.7 ",NA,NA
All these totals are larger than than the 3.0 figure found for the first and seventh nodes of the first ,NA,NA
"expansion. By heuristic, choose the first of these two. This expands to: ",NA,NA
"[[1,3,3],[2],[2],1] -- evaluation 1.5, cost 2, total 3.5 [[3,3],[2],[1,2],3] -- evaluation 2.0, cost 2, total 4.0 ",NA,NA
"[[3,3],[1],[2,2],3] -- evaluation 2.5, cost 2, total 4.5 [[1,2,3,3],[],[2],1] -- evaluation 2.0, cost 2, total 4.0 ",NA,NA
"[[3,3],[],[1,2,2],3] -- evaluation 2.5, cost 2, total 4.5 ",NA,NA
If we choose to use the other evaluation function mentioned in part (b) -- counting 0.5 for each terminal ,NA,NA
"one floor away from its correct floor, and 0.6 for each terminal two floors away from its correct floor -- ",NA,NA
"we get slightly different evaluations. For the first expansion, the states are respectively evaluated to 2.2 ",NA,NA
"(total 3.2), 2.7 (total 3.9), 2.6 (total 3.6), 2.1 (total 3.3), 2.5 (total 3.5), 1.5 (total 2.7), 2.1 (total 3.1), and ",NA,NA
"2.1 (total 3.3). So the sixth state is again chosen for expansion, and its possibilities evaluate to 1.5 (total ",NA,NA
"3.9), 1.0 (total 3.2), 2.1 (total 4.5), 2.0 (total 4.2), 2.1 (total 4.5), and 1.5 (total 3.7). Again, all these totals ",NA,NA
"are more than a node in the first expansion, but this time it's the seventh node in the first expansion. So we ",NA,NA
"expand that seventh node, getting these new states: ",NA,NA
"[[1,3],[2,3],[2],1] -- evaluation 1.6, cost 2, total 3.6 [[3],[2,3],[1,2],3] -- evaluation 2.2, cost 2, total 4.2 ",NA,NA
"[[2,3],[1,3],[2],1] -- evaluation 2.6, cost 2, total 4.6 [[3],[1,3],[2,2],3] -- evaluation 2.6, cost 2, total 4.6 ",NA,NA
"[[3,3],[1,2],[2],1] -- evaluation 2.2, cost 2, total 4.2 [[3],[1,2],[2,3],3] -- evaluation 1.6, cost 2, total 3.6 ",NA,NA
"[[1,2,3],[3],[2],1] -- evaluation 2.1, cost 2, total 4.1 [[3],[3],[1,2,2],3] -- evaluation 2.7, cost 2, total 4.7 ",NA,NA
"[[1,3,3],[2],[2],1] -- evaluation 1.7, cost 2, total 3.7 [[3],[2],[1,2,3],3] -- evaluation 1.7, cost 2, total 3.7 ",NA,NA
"[[3],[1],[2,2,3],3] -- evaluation 2.1, cost 2, total 4.1 ",NA,NA
9-14. Jigsaw puzzles: ,NA,NA
"(a) all possible ""partially completed puzzles"", partitions of a set of puzzle pieces into physically connected ",NA,NA
groups ,NA,NA
(b) trying to attach one side of one piece to one side of another piece ,NA,NA
(c) a state where each piece is in its own physically-connected partition ,NA,NA
(d) a state where all pieces are in one physically-connected partition ,NA,NA
"(e) usually. If pieces have distinct colors and textures, you can group pieces by color or texture and solve ",NA,NA
"subpuzzles for each color, then connect the subpuzzles. ",NA,NA
"(f) no, because two pieces you could compare previously might get connected instead to other pieces, and ",NA,NA
no longer be available ,NA,NA
(g) one solution ,NA,NA
"(h) depends on the puzzle, but typically 4n*4n, n the number of puzzle pieces ",NA,NA
"(i) it decreases to zero, at a progressively slower rate, because the number of sites to connect pieces ",NA,NA
decreases with each piece connection ,NA,NA
Symbolic integration: ,NA,NA
(a) all conceivable algebraic expressions and their integrals ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (52 of 88) [23/04/2002 17:40:03],NA
"(b) rules of integration, as are given in tables ",NA,NA
(c) some particular expression with an integral ,NA,NA
(d) any equivalent expression without any integrals ,NA,NA
(e) yes--an integral of a sum (or difference) is the sum (or difference) of the integrals. ,NA,NA
"(f) no, rules require very specific forms, and use of one rule may make another no longer possible (g) ",NA,NA
usually the best (simplest) form is desired ,NA,NA
(h) depends on the problem ,NA,NA
"(i) varies with the problem, but will increase if the size of the expression increases. No obvious tendencies ",NA,NA
over time. ,NA,NA
"9-16.(a) (iv), A* search--we have both partial costs (the number of machine instructions of a partial ",NA,NA
allocation) and a lower-bound evaluation function (the number of variable mentions unassigned). (b) (ii). ,NA,NA
"The first is an evaluation function, and the third is a control strategy. The fourth is something you do ",NA,NA
"automatically in any kind of allocation search (it's part of the definition of the word ""allocation"" and ",NA,NA
"hence part of the definition of the operator), and what you'd do anyway can't be a heuristic. ",NA,NA
"(c) (i), always decreases, since each assignment rules out using that variable mention in future states. And ",NA,NA
nothing ever increases the choices available at some point. ,NA,NA
9-17.(a) All theorems of the given postulate-and-assumption form. ,NA,NA
"(b) If there are K statements, there are K!/(K-2)!2! = K(K-1)/2 ways of taking a pair. Each step will add ",NA,NA
"one more statement. Assuming we start with N postulates, the branching factor for the step S will have an ",NA,NA
"upper bound of (N+S-1)(N+S-2)/2, or approximately (N+S) squared over 2. ",NA,NA
(c) One answer: Try to combine the simplest statements that have symbols in common. ,NA,NA
(d) One answer: the number of common symbols between the closest existing statement and the goal ,NA,NA
statement. Larger value means closer to goal. ,NA,NA
"(e) Yes, theorem-proving is standard example of monotonicity. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (53 of 88) [23/04/2002 17:40:03],NA
"(f) No, no obvious subparts. ",NA,NA
"(g) Heuristics, because it's very hard to quantify closeness to the goal. ",NA,NA
"(i) No, because A* requires a lower bound on the number of steps to the goal, not an approximation. ",NA,NA
(j) If we had a good evaluation function. ,NA,NA
"(k) Yes, if branching factor seems reasonable in backwards direction (but it will be if we assume all steps ",NA,NA
"involve combination with an original statement, which is true most of the time). ",NA,NA
9-18. (a) Suppose we have N data points with K study variables. Then a state for this problem can be ,NA,NA
expressed as a list of N data points where the first K study variables are the same as the K study variables ,NA,NA
in the starting state but where there may be additional study variables reflecting operations performed; ,NA,NA
plus the same target variable for all states. The set of all such states is the search space. (The size of the ,NA,NA
"search space is infinite, because there are an infinite number of combinations and operations you can ",NA,NA
"perform--you can keep squaring a number forever.) Remember, a state must include everything relevant ",NA,NA
"to describe a ""snapshot"" of activity in the course of a problem, so you must include all the data points in a ",NA,NA
"single state, and define operators to apply to every data point together (i.e., vector operations). ",NA,NA
"(b) The operators are just the operations described, as for instance squaring all the values for some study ",NA,NA
"variable to get a new study variable, or taking the corresponding product of two study variables to get a ",NA,NA
new study variable. ,NA,NA
(c) The branching factor for any state is infinite because you could use an infinite number of constants in ,NA,NA
the first of the three described classes of operators. ,NA,NA
(d) The initial state has two successors: ,NA,NA
"data_point([1,2,1],1). data_point([2,0,4],16). data_point([3,1,9],81). ",NA,NA
"data_point([1,2,4],1). data_point([2,0,0],16). data_point([3,1,1],81). ",NA,NA
And the first of these has three successors: ,NA,NA
"data_point([1,2,1,1],1). data_point([2,0,4,4],16). data_point([3,1,9,9],81). ",NA,NA
"data_point([1,2,1,4],1). data_point([2,0,4,0],16). data_point([3,1,9,1],81). ",NA,NA
"data_point([1,2,1,1],1). data_point([2,0,4,16],16). data_point([3,1,9,81],81). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (54 of 88) [23/04/2002 17:40:03],NA
You may not want to count the first state though--it's pointless. The second of the original successors also ,NA,NA
has three successors: ,NA,NA
"data_point([1,2,4,1],1). data_point([2,0,0,4],16). data_point([3,1,1,9],81). ",NA,NA
"data_point([1,2,4,4],1). data_point([2,0,0,0],16). data_point([3,1,1,1],81). ",NA,NA
"data_point([1,2,4,16],1). data_point([2,0,0,0],16). data_point([3,1,1,1],81). ",NA,NA
"And you may not want to count the second state here because it doesn't make much sense, nor the first ",NA,NA
state here because it duplicates (except for a switch of the third and fourth study variables) the second ,NA,NA
state of the previous group of three. ,NA,NA
"(e) Statisticians have a number of such criteria. One simple one is that the ""least squares"" deviation, the ",NA,NA
average square over all data points of the difference between the target variable value and its ,NA,NA
"corresponding value for the closest study variable, is less than some small fixed number. ",NA,NA
"(f) The least squares deviation calculation given in part (e) is a natural evaluation function, since squares ",NA,NA
are always nonnegative and the value does go to zero when the goal is exactly reached. ,NA,NA
"(g) It's tricky to find something nonnumeric for choosing branches, because the data itself is numeric. One ",NA,NA
way is to look at the operators: say prefer any operator that involves two variables to any operator that ,NA,NA
involves only one variable. Another heuristic is to prefer using new study variables not so far used. ,NA,NA
"(h) Probably not, because we can't do backwards search easily. For one thing, it's hard to get forwards and ",NA,NA
"backwards search to meet in the middle--the branching factor is so larger. For another thing, we'll have to ",NA,NA
"reason somewhat differently backwards, since we don't know what the goal states will be exactly, just a ",NA,NA
criterion for checking states to see whether they are goals. We could try to reason forwards from a starting ,NA,NA
state whose study variables are all but one of the forwards-search study variables plus the original target ,NA,NA
"variable, setting the new target variable to be the remaining one of the original study variables. That ",NA,NA
"would be a kind of backwards searching, and if we found a solution this way we could ""reverse"" the ",NA,NA
"operators to get a corresponding forwards solution path--it's tricky, but possible. But there would be S ",NA,NA
"ways to do this if there were S original study variables, so it'll be considerably harder searching this way--",NA,NA
it won't be worth it if S is large. ,NA,NA
"(i) Not really, because there's no obvious cost function here--we're concerned about the end result, not the ",NA,NA
difficulty in getting there. ,NA,NA
"(j) The square root operator requires that all its values be nonnegative, and the logarithm operator requires ",NA,NA
"that all its values be strictly positive. In addition, the quotient operator requires that none of the values of ",NA,NA
"the second variable be zero. Other than these small restrictions, operators can be used any time for this ",NA,NA
problem. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (55 of 88) [23/04/2002 17:40:03],NA
"(k) No, we have no way to pick nice intermediate goals. ",NA,NA
(l) Statisticians probably make use of strong analogies to related problems involving some of the same ,NA,NA
"variables. So they ""look up"" a few related formulae and test them out sequentially, and usually one of ",NA,NA
"them works pretty well. Occasionally they may have to tinker with the formula as a kind of searching, but ",NA,NA
this is rare because most phenomena that statisticians attack have been quite thoroughly studied already. ,NA,NA
You could call this approach a rule-based one. What statisticians do also can often be described as ,NA,NA
"""generate and test"" (section 3.12). (They also seem to use means-ends analysis, a technique we'll explain ",NA,NA
in Chapter 11.) ,NA,NA
9-19.(a) You must think ahead to what your opponent would do if you made a particular move. Each ,NA,NA
"move possibility for you has a set of subsequent, and usually different, move possibilities for them. And ",NA,NA
"each of these has a set of replies by you, and so on. ",NA,NA
(b) The decisions made on alternate moves (yours and your opponent's) are made according to different ,NA,NA
"criteria: you're trying to win when you're selecting a move, and they're trying to win when they're ",NA,NA
"selecting a move. In terms of the evaluation function, it's like theirs is the negative of yours. ",NA,NA
10-2. Here are the necessary definitions: ,NA,NA
"testdepth(L) :- depthsearch([[9,11,9,3,4,5,7,18],[12,16,4,7,2,20,5]],L). goalreached([[],[]]). ",NA,NA
"successor([LX,LY],[LX2,LY2]) :- member(X,LX), member(X,LY), deleteone(X,LX,LX2), ",NA,NA
"deleteone(X,LY,LY2). successor([LX,LY],[LX2,LY2]) :- successor2([LX,LY],[LX2,LY2]). ",NA,NA
"successor([LX,LY],[LX2,LY2]) :- successor2([LY,LX],[LY2,LX2]). successor2([LX,LY],[LX2,LY2]) :- ",NA,NA
"twomembers([X1,X2],LX), Y is X1 + X2, member(Y,LY), deleteone(X1,LX,LX3), ",NA,NA
"deleteone(X2,LX3,LX2), deleteone(Y,LY,LY2), length_ok(LX2,LY2). length_ok(L1,L2) :- ",NA,NA
"length(L1,E1), length(L2,E2), E1 + 2 > E2. twomembers([X,Y],[X|L]) :- member(Y,L). ",NA,NA
"twomembers([X,Y],[Z|L]) :- twomembers([X,Y],L). deleteone(X,[X|L],L) :- !. deleteone(X,[Y|L],[Y|L2]) ",NA,NA
":- deleteone(X,L,L2). /* Note the member predicate is defined in depth-first search file */ ",NA,NA
"Here's the program in action, using the depth-first search program. ",NA,NA
?- testdepth(L). ,NA,NA
"L=[[[],[]],[[18],[16,2]],[[9,3,18],[12,16,2]], [[9,11,9,3,18],[12,16,2,20]],[[9,11,9,3,7,18], ",NA,NA
"[12,16,7,2,20]],[[9,11,9,3,5,7,18],[12,16,7,2,20,5]], [[9,11,9,3,4,5,7,18],[12,16,4,7,2,20,5]]] ; ",NA,NA
"L=[[[],[]],[[9,3],[12]],[[9,3,18],[12,16,2]],[[9,11,9,3,18], [12,16,2,20]],[[9,11,9,3,7,18],[12,16,7,2,20]], ",NA,NA
"[[9,11,9,3,5,7,18],[12,16,7,2,20,5]],[[9,11,9,3,4,5,7,18], [12,16,4,7,2,20,5]]] ; ",NA,NA
"L=[[[],[]],[[18],[16,2]],[[11,9,18],[16,2,20]], [[9,11,9,3,18],[12,16,2,20]],[[9,11,9,3,7,18], ",NA,NA
"[12,16,7,2,20]],[[9,11,9,3,5,7,18],[12,16,7,2,20,5]], [[9,11,9,3,4,5,7,18],[12,16,4,7,2,20,5]]] ; ",NA,NA
"L=[[[],[]],[[11,9],[20]],[[11,9,18],[16,2,20]], [[9,11,9,3,18],[12,16,2,20]],[[9,11,9,3,7,18], ",NA,NA
"[12,16,7,2,20]],[[9,11,9,3,5,7,18],[12,16,7,2,20,5]], [[9,11,9,3,4,5,7,18],[12,16,4,7,2,20,5]]] ",NA,NA
10-3. (a) ,NA,NA
"goalreached(S) :- member(on(c,b,bolt1),S). ",NA,NA
(b) One helpful one is ,NA,NA
"eval(S,N) :- burial(b,N2), burial(c,N3), right_bolts(N4), right_relationship(N5), N is N2+N3+N4+N5. ",NA,NA
"right_bolts(0) :- on(b,X,bolt1), on(c,Y,bolt1). right_bolts(1) :- on(b,X,bolt1), right_bolts(1) :- ",NA,NA
"on(c,Y,bolt1), right_bolts(2). right_relationship(0) :- on(c,b,bolt1). right_relationship(1). ",NA,NA
(c) The shortest (and hence the breadth-first) solution is to remove all three parts from the first bolt (part ,NA,NA
"""a"" can go anywhere but the other two parts must go on the surface, not on ""bolt2""), and then put part ""b"" ",NA,NA
"followed by part ""c"" on ""bolt1"". ",NA,NA
10-4. (a) This problem suffers from a common weakness of depth-first search problems: it picks a bad ,NA,NA
initial line of reasoning and gets so lost in pursuing the implications of this bad reasoning that it takes ,NA,NA
nearly forever to get around to undoing it. Things are further exacerbated by the problem mentioned in ,NA,NA
part (b). ,NA,NA
(b) This program can't recognize that two descriptions of the same state are identical unless the facts ,NA,NA
describing that state occur in exactly the same order in both. So what we need is a more sophisticated ,NA,NA
"equality check call it ""set_equality"", that checks that every member of one list is a member of another list ",NA,NA
"and vice versa. We can then replace the ""member"" definition with a ""set_member"" that uses this ",NA,NA
"""set_equality"" instead. We can define the latter using the ""subset"" predicate of Chapter 5: ",NA,NA
"set_equality(L1,L2) :- subset(L1,L2), subset(L2,L1). subset([],L). subset([X|L],L2) :- ",NA,NA
"singlemember(X,L2), subset(L,L2). singlemember(X,[X|L]) :- !. singlemember(X,[Y|L]) :- ",NA,NA
"singlemember(X,L). ",NA,NA
then set_member looks like this: ,NA,NA
"set_member(X,[Y|L]) :- set_equality(X,Y). set_member(X,[Y|L]) :- set_member(X,L). ",NA,NA
"and we just change the ""member"" in the definition of ""depthsearch2"" to ""set_member"". ",NA,NA
(c) The heuristic implementation given in this chapter refers only to ordering of rules. We only have two ,NA,NA
"rules for this problem, so there's just two choices for ordering them. The real problem not addressed is ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (57 of 88) [23/04/2002 17:40:03],NA
how to order the different ways of binding arguments to those rules. ,NA,NA
(d) One heuristic would be to prefer operators that affect parts mentioned in the goalreached condition. To ,NA,NA
"do this we could add four additional rules, two corresponding to each of the original successor rules, that ",NA,NA
"apply to the more specific cases involving the ""goal"" parts c and e, and place these rules before their more ",NA,NA
general counterparts: ,NA,NA
"successor(S,[on(c,surface,none)|S2]) :- member(on(c,Y,B),S), not(B=none), cleartop(c,S), ",NA,NA
"delete(on(c,Y,B),S,S2). successor(S,[on(e,surface,none)|S2]) :- member(on(e,Y,B),S), not(B=none), ",NA,NA
"cleartop(e,S), delete(on(e,Y,B),S,S2). successor(S,[on(X,surface,none)|S2]) :- member(on(X,Y,B),S), ",NA,NA
"not(B=none), cleartop(X,S), delete(on(X,Y,B),S,S2). successor(S,[on(c,Z,B2)|S2]) :- ",NA,NA
"member(on(c,Y,B),S), cleartop(c,S), member(on(Z,W,B2),S, not(B2=none), cleartop(Z,S), not(c=Z), ",NA,NA
"delete(on(c,Y,B),S,S2). successor(S,[on(e,Z,B2)|S2]) :- member(on(e,Y,B),S), cleartop(e,S), ",NA,NA
"member(on(Z,W,B2),S), not(B2=none), cleartop(Z,S), not(e=Z), delete(on(e,Y,B),S,S2). ",NA,NA
"successor(S,[on(X,Z,B2)|S2]) :- member(on(X,Y,B),S), cleartop(X,S), member(on(Z,W,B2),S), ",NA,NA
"not(B2=none), cleartop(Z,S), not(X=Z), delete(on(X,Y,B),S,S2). ",NA,NA
10-6. [too long to give] ,NA,NA
"10-8. (a) This cuts in half the number of facts that need to be represented with the ""piece_cost"" predicate ",NA,NA
"name, since you only have to represent the costs in one direction along a piece of a route. ",NA,NA
(b) An infinite loop could occur in cases where piece_cost would fail when there are no facts that would ,NA,NA
match a query on it. But in the searches that use costs--branch-and-bound and A* search--a successor fact ,NA,NA
must already exist for two intersections before a cost for going between those intersections is found. So it ,NA,NA
would be easy to check to avoid infinite loops for this case: just make sure that every successor fact has a ,NA,NA
corresponding cost fact on the same pair of arguments. You could also get infinite loops if you backtrack ,NA,NA
"into the cost function, but notice that our A* search program (the only program given in the chapter ",NA,NA
"having costs) has a cut symbol after the call to ""cost"" to prevent exactly this. ",NA,NA
"(c) With the successor facts, there's no such previous checking as was mentioned in part (b). In fact ",NA,NA
"finding all the possible successors of a state is essential to all search strategies, and such a commutative ",NA,NA
rule would cause you to get stuck on finding successors of the starting state forever. So you'd never get ,NA,NA
anywhere. ,NA,NA
10-9. Here's one way: ,NA,NA
"robot(A) :- search([none,at(chute),dusty(o1),dusty(o2), fullbasket(o1),vacuumable(o2)],A). ",NA,NA
"goalreached([O,at(X)]) :- not(X=chute). ",NA,NA
"eval([],0). eval([X|L],N) :- piece_eval(X,N2), eval(L,N3), N is N2+N3. piece_eval(dusty(X),6). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (58 of 88) [23/04/2002 17:40:03],NA
"piece_eval(vacuumable(X),10). piece_eval(fullbasket(X),24). piece_eval(holdingbasketfrom(X),1). ",NA,NA
"piece_eval(P,0). ",NA,NA
"cost([],0). cost([[O|S]|L],C) :- piece_cost(O,C2), cost(L,C3), C is C2+C3. piece_cost(none,0). ",NA,NA
"piece_cost(vacuum,10). piece_cost(dust,6). piece_cost(pickup,3). piece_cost(dispose,5). ",NA,NA
"piece_cost(putdown,1). piece_cost(go(chute,Y),8). piece_cost(go(X,chute),8). piece_cost(go(X,Y),3). ",NA,NA
"successor([O|S],[vacuum,fullbasket(X)|S3]) :- member(at(X),S), not(member(dusty(X),S)), ",NA,NA
"failing_delete(vacuumable(X),S,S2), delete(fullbasket(X),S2,S3). ",NA,NA
"successor([O|S],[dust,vacuumable(X)|S3]) :- member(at(X),S), failing_delete(dusty(X),S,S2), ",NA,NA
"delete(vacuumable(X),S2,S3). successor([O|S],[pickup,holdingbasketfrom(X)|S]) :- member(at(X),S), ",NA,NA
"not(member(holdingbasketfrom(X),S)), not(member(vacuumable(X),S)), not(member(dusty(X),S)), ",NA,NA
"member(fullbasket(X),S). successor([O|S],[dispose|S2]) :- member(at(chute),S), ",NA,NA
"member(holdingbasketfrom(X),S), failing_delete(fullbasket(X),S,S2). successor([O|S],[putdown|S2]) :- ",NA,NA
"member(at(X),S), not(member(fullbasket(X),S)), failing_delete(holdingbasketfrom(X),S,S2). ",NA,NA
"successor([O|S],[go(X,Y),at(Y)|S2]) :- failing_delete(at(X),S,S2), member(Y,[chute,o1,o2]), not(X=Y). ",NA,NA
"member(X,[X|L]). member(X,[Y|L]) :- member(X,L). ",NA,NA
"delete(X,[],[]). delete(X,[X|L],L) :- !. delete(X,[Y|L],[Y|M]) :- delete(X,L,M). ",NA,NA
"failing_delete(X,[X|L],L) :- !. failing_delete(X,[Y|L],[Y|M]) :- failing_delete(X,L,M). ",NA,NA
Here's this program running with the A* program: ,NA,NA
"?- robot(A). 73 incompletely examined states and 255 examined states A=[[putdown,at(o2)], ",NA,NA
"[go(o1,o2),at(o2),holdingbasketfrom(o2)], [putdown,at(o1),holdingbasketfrom(o2)], ",NA,NA
"[go(chute,o1),at(o1),holdingbasketfrom(o2), holdingbasketfrom(o1)], ",NA,NA
"[dispose,at(chute),holdingbasketfrom(o2), holdingbasketfrom(o1)], ",NA,NA
"[go(o2,chute),at(chute),holdingbasketfrom(o2), fullbasket(o2),holdingbasketfrom(o1)], ",NA,NA
"[pickup,holdingbasketfrom(o2),fullbasket(o2),at(o2), holdingbasketfrom(o1)], ",NA,NA
"[vacuum,fullbasket(o2),at(o2),holdingbasketfrom(o1)], ",NA,NA
"[dust,vacuumable(o2),at(o2),holdingbasketfrom(o1)], ",NA,NA
"[go(chute,o2),at(o2),holdingbasketfrom(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[dispose,at(chute),holdingbasketfrom(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[go(o1,chute),at(chute),holdingbasketfrom(o1), fullbasket(o1),dusty(o2),vacuumable(o2)], ",NA,NA
"[pickup,holdingbasketfrom(o1),fullbasket(o1),at(o1), dusty(o2),vacuumable(o2)], ",NA,NA
"[vacuum,fullbasket(o1),at(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[dust,vacuumable(o1),at(o1),dusty(o2),fullbasket(o1), vacuumable(o2)], ",NA,NA
"[go(chute,o1),at(o1),dusty(o1),dusty(o2), fullbasket(o1),vacuumable(o2)], ",NA,NA
"[none,at(chute),dusty(o1),dusty(o2),fullbasket(o1), vacuumable(o2)]] ; ",NA,NA
"73 incompletely examined states and 257 examined states A=[[putdown,at(o1)], ",NA,NA
"[go(o2,o1),at(o1),holdingbasketfrom(o1)], [putdown,at(o2),holdingbasketfrom(o1)], ",NA,NA
"[go(chute,o2),at(o2),holdingbasketfrom(o2), holdingbasketfrom(o1)], ",NA,NA
"[dispose,at(chute),holdingbasketfrom(o2), holdingbasketfrom(o1)], ",NA,NA
"[go(o2,chute),at(chute),holdingbasketfrom(o2), fullbasket(o2),holdingbasketfrom(o1)], ",NA,NA
"[pickup,holdingbasketfrom(o2),fullbasket(o2),at(o2), holdingbasketfrom(o1)], ",NA,NA
"[vacuum,fullbasket(o2),at(o2),holdingbasketfrom(o1)], ",NA,NA
"[dust,vacuumable(o2),at(o2),holdingbasketfrom(o1)], ",NA,NA
"[go(chute,o2),at(o2),holdingbasketfrom(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[dispose,at(chute),holdingbasketfrom(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[go(o1,chute),at(chute),holdingbasketfrom(o1), fullbasket(o1),dusty(o2),vacuumable(o2)], ",NA,NA
"[pickup,holdingbasketfrom(o1),fullbasket(o1),at(o1), dusty(o2),vacuumable(o2)], ",NA,NA
"[vacuum,fullbasket(o1),at(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[dust,vacuumable(o1),at(o1),dusty(o2),fullbasket(o1), vacuumable(o2)], ",NA,NA
"[go(chute,o1),at(o1),dusty(o1),dusty(o2), fullbasket(o1),vacuumable(o2)], ",NA,NA
"[none,at(chute),dusty(o1),dusty(o2),fullbasket(o1), vacuumable(o2)]] ; ",NA,NA
"71 incompletely examined states and 333 examined states A=[[putdown,at(o1)], ",NA,NA
"[go(chute,o1),at(o1),holdingbasketfrom(o1)], [dispose,at(chute),holdingbasketfrom(o1)], ",NA,NA
"[go(o1,chute),at(chute),holdingbasketfrom(o1), fullbasket(o1)], ",NA,NA
"[pickup,holdingbasketfrom(o1),fullbasket(o1),at(o1)], [vacuum,fullbasket(o1),at(o1)], ",NA,NA
"[dust,vacuumable(o1),at(o1),fullbasket(o1)], [go(o2,o1),at(o1),dusty(o1),fullbasket(o1)], ",NA,NA
"[putdown,at(o2),dusty(o1),fullbasket(o1)], [go(chute,o2),at(o2),holdingbasketfrom(o2),dusty(o1), ",NA,NA
"fullbasket(o1)], [dispose,at(chute),holdingbasketfrom(o2),dusty(o1), fullbasket(o1)], ",NA,NA
"[go(o2,chute),at(chute),holdingbasketfrom(o2), fullbasket(o2),dusty(o1),fullbasket(o1)], ",NA,NA
"[pickup,holdingbasketfrom(o2),fullbasket(o2),at(o2), dusty(o1),fullbasket(o1)], ",NA,NA
"[vacuum,fullbasket(o2),at(o2),dusty(o1), fullbasket(o1)], ",NA,NA
"[dust,vacuumable(o2),at(o2),dusty(o1),fullbasket(o1)], [go(chute,o2),at(o2),dusty(o1),dusty(o2), ",NA,NA
"fullbasket(o1),vacuumable(o2)], [none,at(chute),dusty(o1),dusty(o2),fullbasket(o1), vacuumable(o2)]] ; ",NA,NA
"71 incompletely examined states and 336 examined states A=[[putdown,at(o2)], ",NA,NA
"[go(chute,o2),at(o2),holdingbasketfrom(o2)], [dispose,at(chute),holdingbasketfrom(o2)], ",NA,NA
"[go(o2,chute),at(chute),holdingbasketfrom(o2), fullbasket(o2)], ",NA,NA
"[pickup,holdingbasketfrom(o2),fullbasket(o2),at(o2)], [vacuum,fullbasket(o2),at(o2)], ",NA,NA
"[dust,vacuumable(o2),at(o2)], [go(o1,o2),at(o2),dusty(o2),vacuumable(o2)], ",NA,NA
"[putdown,at(o1),dusty(o2),vacuumable(o2)], [go(chute,o1),at(o1),holdingbasketfrom(o1),dusty(o2), ",NA,NA
"vacuumable(o2)], [dispose,at(chute),holdingbasketfrom(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[go(o1,chute),at(chute),holdingbasketfrom(o1), fullbasket(o1),dusty(o2),vacuumable(o2)], ",NA,NA
"[pickup,holdingbasketfrom(o1),fullbasket(o1),at(o1), dusty(o2),vacuumable(o2)], ",NA,NA
"[vacuum,fullbasket(o1),at(o1),dusty(o2), vacuumable(o2)], ",NA,NA
"[dust,vacuumable(o1),at(o1),dusty(o2),fullbasket(o1), vacuumable(o2)], ",NA,NA
"[go(chute,o1),at(o1),dusty(o1),dusty(o2), fullbasket(o1),vacuumable(o2)], ",NA,NA
"[none,at(chute),dusty(o1),dusty(o2),fullbasket(o1), vacuumable(o2)]] ; ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (60 of 88) [23/04/2002 17:40:03],NA
no ,NA,NA
"This program run in one dialect took 336K of heap storage, 5K of global stack, and 22K of local stack, ",NA,NA
and took 154 seconds to reach an answer. ,NA,NA
"10-11.(a) 1, if the states form a chain ",NA,NA
"(b) N-1, for a one-level state tree ",NA,NA
"(c) 1, as before ",NA,NA
"(d) N-1, as before ",NA,NA
10-13. (a) Here B is the branching factor and K is the level number. As explained in Chapter 9. The ,NA,NA
number of states in such a search lattice up through and including the level K states is ((B to the K+1 )-B) ,NA,NA
"/ (B-1). If fraction P of these B states are visited, then the new branching factor is B(1-P), leading to a ",NA,NA
total number of states ((B to the K+1) ((1-P) to the K+1) - B(1-P)) / (B(1-P)-1). ,NA,NA
(b) The ratio of the old to new number of states (the two formulae of the last section) is approximately ,NA,NA
(B(1-P)-1) / ((1-P) to the K+1 - (1-P)B to the -K) (B-1) for either K or B large. This ratio will be greater ,NA,NA
"than or equal to 1, and we want to ensure that it is more than the ratio of costs for the visited-state ",NA,NA
"checking, (E+C)/C = 1+(E/C). ",NA,NA
"(c) Now the second ratio is 1+(AK/C) for level K. So since the first ratio does not depend on level, there ",NA,NA
will now be some threshold level K at which visited state checking no longer pays off. So to decide ,NA,NA
"whether to use it, you have to guess in advance how far the nearest goal state is from the startingstate. ",NA,NA
"10-14. (a) No, the ""not"" term in the second rule fulfills the function of a ""cut"" in the first rule, and the ",NA,NA
second and third rules will never apply to the same situation. ,NA,NA
"(b) It doesn't have a logical meaning like the rest of Prolog--it has a procedural meaning, i.e. it's a ",NA,NA
"programming trick. Also, it can have effects far beyond its immediate vicinity, since it prevents ",NA,NA
backtracking in any rule with the same left side as the one we're in. ,NA,NA
10-16. ,NA,NA
"f_of_list([],[]). f_of_list([X|L],[FX|FL]) :- call(f(X,FX)), f_of_list(L,FL). ",NA,NA
10-17.(a) ,NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- member(zzxxy(A),X1), not(member(zzxxy(A),X2)). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (61 of 88) [23/04/2002 17:40:03],NA
"(b) Use the ""length"" definition of Chapter 5 and: ",NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- length(X1,L1), length(X2,L2), L1<L2. ",NA,NA
"(c) Sum up the number of changes in each path list, and compare: ",NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- numchanges(Y1,L1), numchanges(Y2,L2), L1<L2. numchanges([S],0) :- ",NA,NA
"!. numchanges([S1,S2|SL],N) :- numchanges2(S1,S2,N2), numchanges2(S2,S1,N3), ",NA,NA
"numchanges([S2|SL],N4), N is N2+N3+N4. numchanges2([],L,0) :- !. numchanges2([S|L1],L2,N) :- ",NA,NA
"not(member(S,L2)), numchanges2(L1,L2,N2), N is N2+1, !. numchanges2([S|L1],L2,N) :- ",NA,NA
"not(member(S,L2)), numchanges2(L1,L2,N). ",NA,NA
"(d) The last state to find successors of is not one of the six arguments to ""prefer"" so we must first figure it ",NA,NA
out. A way that will usually work is to look at the first item on the agenda (which must have been the last ,NA,NA
"successor found), and find the second-to-last state in its path list. This will only be incorrect when the last ",NA,NA
state chosen had no successors. ,NA,NA
"prefer(X1,Y1,E1,X2,Y2,E2) :- recent(X2), not(recent(X1)). recent(S) :- ",NA,NA
"first_agenda_item(X,[S2,S3|SL],E), successor(S3,S). first_agenda_item(X,Y,E) :- agenda(X,Y,E), !. 10-",NA,NA
"18. Breadth-first search is the tool to use, because it always finds minimum-distance paths. So use the ",NA,NA
"problem-independent breadth-first code from the chapter, and define: ",NA,NA
"inference_distance(X,Y,N) :- setup_goal(Y), breadthsearch(X,Anslist), length(Anslist,N). setup_goal(G) :- ",NA,NA
"retract(goal(X)), !, asserta(goal(G)). setup_goal(G) :- asserta(goal(G)). successor(X,Y) :- a_kind_of(X,Y). ",NA,NA
"goalreached(X) :- goal(X). length([],0). length([X|L],N) :- length(L). ",NA,NA
10-19. (a) The state list supplied to the cost function will be in reverse order for the backwards search. So ,NA,NA
you must reverse this list of states before calling upon the old cost function in order to get the new cost ,NA,NA
function. ,NA,NA
(b) Just take the negative old evaluation function. ,NA,NA
(c) You basically want to reverse the arguments to each successor definition. This is easy when the ,NA,NA
successor definition is a fact or a rule without arithmetic or side effects. If a successor rule has arithmetic ,NA,NA
you will have to figure out a reverse arithmetic formula to do the calculation in the opposite direction ,NA,NA
(something not always possible). If there are side effects like assertions or retractions or file loads or cut ,NA,NA
symbols. The successor rule must pretty well be rewritten because there is usually no obvious way to ,NA,NA
convert it to the backwards form. ,NA,NA
"10-20.(a) Change pick_best_move so that it calls upon a two-argument ""prefer"" predicate, in the manner ",NA,NA
of section 10.11: ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (62 of 88) [23/04/2002 17:40:03],NA
"pick_best_move(S,NS) :- bagof(X,successor(S,X),XL), member(NS,XL), not(better_pick_than(NS,XL)). ",NA,NA
"better_pick_than(S,L) :- member(S2,L), not(S=S2), prefer(S2,S). ",NA,NA
"(b) Just the beginning of the program needs to be changed, so ""get_move"" is called to generate moves for ",NA,NA
both players: ,NA,NA
"gamesearch(State) :- goalreached(State), print_win(State), !. gamesearch([-1,M|B]) :- ",NA,NA
"not(get_move(B,1,S,NB)), write('Player X cannot move so Player O gets another turn.'), nl, ",NA,NA
"!,gamesearch([1,M|B]). gamesearch([P,M|B]) :- print_board(B), pick_best_move([P,M|B],Newstate), ",NA,NA
"write_move(Newstate), !, gamesearch(Newstate). gamesearch([1,M|B]) :- not(get_move(B,-1,S,NB)), ",NA,NA
"not(get_move(B,1,S,NB)), print_win([1,M|B]), !. gamesearch([1,M|B]) :- not(get_move(B,-1,S,NB)), ",NA,NA
"write('Player O cannot move so Player X gets another turn.'), nl, !, gamesearch([-1,M|B]). gamesearch(S) ",NA,NA
":- print_win(S), !. write_move([P,[X,Y]|B]) :- Move is (10*X)+Y, write('Player '), decode(P,C), write(C), ",NA,NA
"write(' makes move '), write(Move), nl, !. ",NA,NA
(c) Redefine pick_best_move for one player: ,NA,NA
"pick_best_move([-1|S],NS) :- asserta(ebest(none,1000000)), successor([-1|S],S2), one_ply_eval(S2,E2), ",NA,NA
"write_eval(S2,E2), ebest(S1,E1), E2<E1, retract(ebest(S1,E1)), asserta(ebest(S2,E2)), fail. ",NA,NA
"pick_best_move([-1|S],NS) :- ebest(NS,E), retract(ebest(NS,E)). one_ply_eval(S,E) :- ",NA,NA
"asserta(e2best(1000000,0)), successor(S,S2), eval(S2,E2), e2best(E1,N), min2(E1,E2,E3), ",NA,NA
"retract(e2best(E1,N)), N2 is N+1, asserta(e2best(E3,N2)), fail. one_ply_eval(S,E) :- e2best(NE,N), E is ",NA,NA
"(60.0/(N+1.0))-NE, retract(e2best(NE,N)), !. ",NA,NA
(d) There are many ways to do this. ,NA,NA
11-2. You might decompose a problem into five parts when two equally important operators seem ,NA,NA
suggested for a problem. Two operators that you must do in a particular order. Then the five subproblems ,NA,NA
are: l) satisfy the conditions of the first 2) apply the first operator 3) satisfy the preconditions of the ,NA,NA
second operator from there 4) apply the second operator 5) go from this state to the goal state. An ,NA,NA
example would be the state where both the batteries and the light are defective and you have to replace ,NA,NA
"both, and the replace_batteries and replace_light are equally important. To implement this in Prolog you ",NA,NA
"just create another table, ""doublerecommended"" that gives conditions for these operator pairs to apply. ",NA,NA
Then you write a third means_ends rule that comes between the two previous rules that checks the ,NA,NA
"""doublerecommended"" rules before trying the regular ""recommended"" rules, recursing as necessary. This ",NA,NA
"way if no ""doublerecommended"" rules apply to a situation, the ""recommended"" rules will be used instead. ",NA,NA
11-3. (a) The operators are something like: ,NA,NA
If in the current state Sir Reginald is alive and in the goal state he is dead then the recommended operator ,NA,NA
"is to stab him with a knife. If you need to get a knife, then the pick up knife operator is recommended. If ",NA,NA
"you need to put down the knife and hide it, then the hide knife operator is recommended. If your goal ",NA,NA
"involves being in a different room than you're at now, then the go operator is recommended. If you need ",NA,NA
to go to some other room and that door is locked then the knock operator is recommended. ,NA,NA
And the informal preconditions and postconditions are: ,NA,NA
preconditions of stabbing with a knife: the person you want to stab is alive and you are in the room with ,NA,NA
them. Postconditions of stabbing with a knife: the person you want to stab is dead. Preconditions of ,NA,NA
"picking up a knife: you do not have a knife, and you are in the room with a knife. Postconditions of ",NA,NA
picking up a knife: you have a knife. Preconditions of hiding the knife: you have the knife. Postconditions ,NA,NA
"of hiding the knife: you do not have the knife, and the knife is hidden. Preconditions of going from one ",NA,NA
"room to another: that you are at the first room, and that there is no locked door in between. Postconditions ",NA,NA
of going from one room to another: you are at the second room. Preconditions of knocking on the door: ,NA,NA
the door is locked. Postconditions of knocking on the door: the door is unlocked. Preconditions of ,NA,NA
waiting: there are people in the corridor. Postconditions of waiting: there is no one in the corridor. ,NA,NA
"(b) The final operator sequence is to wait, pick up the knife, knock on his door, go in when he opens it, ",NA,NA
"stab him, then return to your room and hide the knife. ",NA,NA
"(c) You could figure out a set of plans instead of just one plan, one for each eventuality. Then in actually ",NA,NA
"executing the plan, you follow one along until there is discrepancy between what facts are true and what ",NA,NA
facts the plan assumes. Then you transfer to another plan that does not have this discrepancy. ,NA,NA
"11-5. (a) The answer found is to disassemble the case, turn over the case, replace the batteries, ",NA,NA
"disassemble the top, replace the light, assemble the top, and assemble the case. ",NA,NA
"(b) Reassembling the case is given a higher priority than replacing the light, so after replacing the ",NA,NA
batteries the case is reassembled even though it needs to be disassembled to replace the light. So two ,NA,NA
actions are inserted unnecessarily in the operator lists. ,NA,NA
"(c) Now fixing the light is given the highest priority and fixing the batteries is given lowest priority, lower ",NA,NA
even than assembling the case. So fixing the light is done first and two unnecessary actions are inserted in ,NA,NA
"the operator sequence similar to the ones in part (b). The operator sequence is to disassemble the case, ",NA,NA
"disassemble the top, replace the light, reassemble the top, assemble the case, disassemble the case, turn ",NA,NA
"over the case, replace the batteries, and assemble the case. ",NA,NA
11-8. (a) A breadth-first approach would be to find the preconditions for a given operator then figure out ,NA,NA
the operator most relevant to finding those preconditions. But instead of now figuring out the ,NA,NA
preconditions for this new operator we instead turn our attention to the postconditions of the original ,NA,NA
operator. While we can't figure out exactly what this state will be (because deeper level of recursions that ,NA,NA
"we haven't looked at yet may add some ""extra side effect"" facts), we can be sure that everything ",NA,NA
mentioned in postconditions for the original operator must hold in the state resulting from it. So on that ,NA,NA
"basis we can recursively figure out a recommended operator to get to the goal from there, which implies ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (64 of 88) [23/04/2002 17:40:03],NA
certain postconditions and preconditions of its own. Now we go back to the precondition recursion of the ,NA,NA
"original operator and figure out how to satisfy its preconditions, then how to satisfy its postconditions. So ",NA,NA
"we gradually build up a list of operators, one level at a time. But as we do we may have to redo some later ",NA,NA
sections of the operator list as assumptions that they made about their states turn out to be violated by ,NA,NA
earlier states. So you may have to jump around a bit. ,NA,NA
"(b) As you can see, this approach is much more awkward than depth-first search and involves an added ",NA,NA
complication in the necessity to redo work that was done previously on occasion. The control structure of ,NA,NA
"depth-first search is better suited to the way computers work, and while it does have the disadvantage of ",NA,NA
"possibly getting into infinite loops if the rules aren't written properly, this seems unlikely. Depth-first ",NA,NA
"search may also require considerable backtracking, but this application doesn't seem like one where this ",NA,NA
"would happen. Mean-ends analysis is a more ""intelligent"" kind of search, one that is deliberately set up in ",NA,NA
"an intelligent way. So that the best choice is made first and as often as possible, and backtracking is ",NA,NA
unnecessary most of the time. ,NA,NA
11-9. Mean-ends analysis is search with recursive decomposition based on prerequisites and ,NA,NA
"postconditions of ""key"" actions. A table is used to define these key actions for all start-goal pairs in the ",NA,NA
"problem domain. So whatever application you found to answer this problem, it must involve: (1) ",NA,NA
"recursive decomposition, not just one level of decomposition; (2) prerequisites and postconditions used to ",NA,NA
determine the decomposition and each level. And also it must involve (3) operating systems and (4) user-,NA,NA
friendliness as stated in the problem. ,NA,NA
"You can use means-ends analysis to let the user to specify high-level goals (like ""Run me off a copy of ",NA,NA
"file p375, wherever it is"") without requiring him to worry about the steps needed or the many ",NA,NA
"prerequisites. For this example command, for instance, you could first check to see if the file was in any ",NA,NA
"directory on the current computer. If not, you log in on the next most likely computer (which requires that ",NA,NA
"the computer be up), giving password, and check to see if it's there, and so on until you find it on some ",NA,NA
"computer that is up. Then you log out of the remote computer, and enter the network file transfer program ",NA,NA
to get the file to the local computer. This may involve figuring out file formats for the remote file and the ,NA,NA
"computer you're on, which may involve looking up information in online directories or manuals. Also, ",NA,NA
"you may not find what you're looking for in the first place in the manual that you look, and you may have ",NA,NA
"to follow up on cross-references. Now you want to print, so you first check to see if the text of the file has ",NA,NA
"formatting commands, in which case you send the file to an appropriate formatter. In any event, you then ",NA,NA
"check to find a printer that is working, and if so, send the file, now in printable form, to that printer. ",NA,NA
"What's happening is that certain goals involve certain subgoals (not all of which you know in advance), ",NA,NA
"which in turn involve other subgoals (which you also may not know in advance), so this is a good ",NA,NA
situation for recursive decomposition as you proceed. ,NA,NA
"You can also use means-ends analysis to navigate over complicated computer networks, much in the ",NA,NA
"manner of the route-finding example in Chapter 9. To do this, you would have to consider certain ",NA,NA
"computers as high-level goals that you were trying to reach, and then plan how to reach them, and plan ",NA,NA
what to do after you reach them. An important example of such a high-level goal computer is a gateway ,NA,NA
"to another network; you could plan to get to that computer, plan to log on and get through to the other ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (65 of 88) [23/04/2002 17:40:03],NA
"network, then plan to get to where you're going on the other network. But if there aren't any such ",NA,NA
"""bottleneck"" computers you should probably just do a depth-first or breadth-first search. ",NA,NA
"11-10. Both involve finding a string of words that solve some problem, in the first case an operator ",NA,NA
sequence to accomplish some goal in the second case a sentence in some language. But for means-ends ,NA,NA
"analysis, the objective is to discover this string, whereas in parsing the string is already known and you ",NA,NA
"want to find the route to it. Both essentially involve substitution of strings of words for other words, ",NA,NA
though means-ends analysis is not so obvious about it. Both usually imply depth-first control structure ,NA,NA
because it's easy to use. But means-ends analysis makes its decision about what to do next based on its ,NA,NA
"analysis of preconditions and postconditions, whereas top-down parsing must rely on heuristics for ",NA,NA
efficiency because there are too many alternative word sequences for one to accurately speak of ,NA,NA
preconditions and postconditions. ,NA,NA
11-11. [too complicated to give] ,NA,NA
"12-1.(a) Some possibilities: purpose (filled in with ""education""), scheduled (filled in with ""yes""), ",NA,NA
"sponsoring-institution (filled in with ""university"") ",NA,NA
"(b) Superconcept possibilities: class meeting at any university, meeting of any sort at this school. ",NA,NA
"Subconcept possibilities: class meeting for CS3310, class meeting today. ",NA,NA
"(c) script inherits from class meeting at any university, and latitude-longitude position inherits from class ",NA,NA
"meeting at this school; location, professor, and course number do not inherit from either. ",NA,NA
(d) the classroom-lecture script ,NA,NA
"12-2. People could carry little credit cards containing all answers to questions they are commonly asked, ",NA,NA
"like name, social security number, address, birth date, employer, etc. Then inheritance could have the ",NA,NA
"physical meaning of ""look it up on the card and print it on the form"". There could be different levels of ",NA,NA
"inheritance: for instance, in filling out a government form, an employee could provide three credit cards: ",NA,NA
"one themselves, one for their department, and one for their organization, all providing different default ",NA,NA
values. ,NA,NA
"12-6. The intension includes definitional information like that it's a form of business communication, it's ",NA,NA
"written in paper with words, and it's usually a formal document. The extension includes the information ",NA,NA
that memos are common in big organizations and that memos are increasingly being replaced by ,NA,NA
computer message systems. ,NA,NA
12-7. See the next page. ,NA,NA
"12-8. (a) A value in some slot. Usually the slot is definitional, since adjectives usually help specify ",NA,NA
something. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (66 of 88) [23/04/2002 17:40:03],NA
"(b) The name of a slot. For instance, ""of"" often signifies a ""part_of"" relationship; ""for"" signals a purpose ",NA,NA
"property; ""to"" signals a destination property or relationship; and ""at"" signals a directional relationship ",NA,NA
either in space or in time. ,NA,NA
12-10. Note it's important to give unique names to frames (frames are like global variables). It's also ,NA,NA
"important not to use the general English words for instances of a concept; for instance, the frame ",NA,NA
"describing the particular letter should be called something like ""letter1"" and not just ""letter"". Also note the ",NA,NA
"experiences reported in the letter occurred in a specific order, and that order must be shown somehow. ",NA,NA
One solution: ,NA,NA
frame-name: letter sender: addressees: subject: reason: ,NA,NA
frame-name: letter1 a_kind_of: letter sender: Irate-Programmer addressees: [Fly-by-Nite-Software] ,NA,NA
subject: refund reason: false-claims1 ,NA,NA
frame-name: false-claims1 a_kind_of: contract-violation plaintiff: Irate-Programmer defendant: Fly-,NA,NA
"by-Nite-software summary-report: letter1 violations: [bug1,bug2,bug3] ",NA,NA
frame-name: bug product: seller: observer: description: ,NA,NA
frame-name: bug1 a_kind_of: bug a_kind_of: numerical-error product: 'Amazing Artificial Intelligence ,NA,NA
Software' seller: Fly-by-Nite-software observer: Irate-Programmer before: bug2 after: none description: ,NA,NA
'attempt to divide by zero' ,NA,NA
frame-name: bug2 a_kind_of: bug a_kind_of: lineprinter-output product: Amazing Artificial Intelligence ,NA,NA
Software seller: Fly-by-Nite-software observer: Irate-Programmer before: bug3 after: bug1 description: ,NA,NA
"'100,000 linefeeds on lineprinter' ",NA,NA
frame-name: bug3 a_kind_of: bug a_kind_of: file-system-side-effect product: Amazing Artificial ,NA,NA
Intelligence Software seller: Fly-by-Nite-software observer: Irate-Programmer before: none after: bug2 ,NA,NA
description: 'all user files destroyed' ,NA,NA
"12-11. (a) Intersect the lists inherited. (An empty intersection would mean a contradictory database, so we ",NA,NA
don't have to worry about it.) ,NA,NA
"(b) Intersect the ranges inherited, analogous to (a). ",NA,NA
"12-12. (a) This suggests a priority ranking on the three dimensions, since the user dimension is assumed ",NA,NA
"to have precedence on this issue with most operating systems. Under some circumstances, we might want ",NA,NA
"to leave all the slots empty above our frame in the user hierarchy, in which case the time hierarchy might ",NA,NA
"have the next priority since users are creatures of habit. And if these frames are blank in this slot too, we ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (67 of 88) [23/04/2002 17:40:03],NA
can defer to the program and facility hierarchy. ,NA,NA
"(b) Such a warning is very serious business, so any reason at all to give this warning should be heeded. In ",NA,NA
"other words, use the ""or"" of the Boolean values inherited along the three dimensions. ",NA,NA
"(c) This parameter is just a guide in allocating resources for the operating system, so just some reasonable ",NA,NA
estimate is sufficient. That suggests taking the average of the three fractions inherited. ,NA,NA
"12-14. Rules can be grouped into modules, and each appliance can be characterized by the set of modules ",NA,NA
"that it requires, defining a frame. Thus generalizations over similar appliances (e.g., ""drill"" and ""kitchen ",NA,NA
"appliance"") can be characterized by some common set of module frames required by each appliance in the ",NA,NA
"class. Each such frame could be an instance of a multiple-instance slot with the name ""rule-module"", ",NA,NA
"similar to ""part_of"". Such module frames will need to also include specifications of when to invoke other ",NA,NA
"frames. They can also include slots for core required, expected execution time, predicate names referred ",NA,NA
"to, a list of facts assumed by all rules in the frame, and an indication of whether backward, forward, or ",NA,NA
hybrid chaining is best for their rules. ,NA,NA
12-15. [many answers possible] ,NA,NA
"12-16. The general idea is to characterize the two mappings and then compose them (that is, use the ",NA,NA
results of one mapping as input to the other). The mappings you need to characterize are from A to B and ,NA,NA
from A to C. To characterize a mapping you must analyze what is different between the two frames in ,NA,NA
"slots and slot values. For this problem, we are especially interested in what new slots are present in the ",NA,NA
"second and are not in the first, and what slot values are filled in in the second frame that are not filled in in ",NA,NA
"the first frame. So we make up a list of such differences from frame A to frame B, a list of differences ",NA,NA
"from frame A between frame C and combine them, eliminating duplicates and finding compromise values ",NA,NA
for any contradictions. Artificial-intelligence researchers have done some interesting work on this ,NA,NA
problem. ,NA,NA
13-2. Rearrangement of the original query will give a much better execution time than dependency-based ,NA,NA
"backtracking could. To rearrange, first consider which predicates can bind variables. Predicate b cannot ",NA,NA
bind Y and predicate d cannot bind either X or Z. But the other predicates can be freely moved left in the ,NA,NA
query. Clearly best among these is predicate e which can match only a single value. It makes predicate a ,NA,NA
"unnecessary, so we can just put e first and c second. So the only remaining question is the order of the ",NA,NA
"final two predicates, b and d. Rule 1 isn't really relevant because we don't know probabilities of success, ",NA,NA
but using Rule 4 we should put d before b. So the value of Z can be tested right away after the binding of ,NA,NA
Z. So the best rearrangement of the query is ,NA,NA
"?- e(X), c(Z), d(X,Z), b(X,Y). ",NA,NA
13-3. The dependencies among predicates in this query form a cycle. There's no way a cycle can be turned ,NA,NA
into a sequence without eliminating at least one of the dependencies in that original cycle. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (68 of 88) [23/04/2002 17:40:03],NA
"13-5. Usually the artist (whether verbal, visual, or whatever) has a general idea which they try to ",NA,NA
implement in an aesthetic manner. This means making choices about what to do in parts of the whole ,NA,NA
based on the relationship based on those parts to other parts--in other words constraints. As choices are ,NA,NA
made further limitations are imposed on later choices so relaxation methods might help. ,NA,NA
"13-7.(a) examples: sky, cloud, grass, vehicle, road, water, water-vehicle, pier, path, building ",NA,NA
(b) Examples: none of these labels can be the same for adjacent regions. Sky and cloud must be above ,NA,NA
"grass, road, water, path, and building. Vehicle must be in or touching road or path, and water-vehicle ",NA,NA
"must be in or touching water. Vehicle cannot be in sky, cloud, or grass; water-vehicle cannot be in sky, ",NA,NA
"cloud, grass, or building. Pier must be touching water, and must also be touching either grass, path, or ",NA,NA
"road. Water cannot be in sky, cloud, vehicle, road, water-vehicle, pier, path, or building. Grass cannot be ",NA,NA
"in sky, cloud, vehicle, road, water, pier, path, or building. ",NA,NA
(c) [answer depends on the constraints chosen in (b)] ,NA,NA
"13-8. The variables are the letters of the acronym; call them N, C, SA, and SB. C1 and C2 are the single-",NA,NA
"variable constraints, so we apply them first, to get the possibilities: N:[national,naval,new], ",NA,NA
"C:[computer,crazy], SA:[science], SB:[science,school,staff]. Starting with N, ""new"" is impossible by C6. ",NA,NA
"For C, ""crazy"" is impossible. For SB, ""science"" is impossible by C3, and ""staff"" is impossible by C5. ",NA,NA
"That's all we can do. Final possibilities for the acronym: ""national computer science school"" or ""naval ",NA,NA
"computer science school"". ",NA,NA
13-9. One way (some steps can be interchanged in the following): ,NA,NA
(1) The three small touching objects must be ships by C3. ,NA,NA
(2) The region surrounding them must be water by C2. ,NA,NA
"(3) The ""border"" region surrounding the entire picture cannot be water by C6, it can't be a cloud by C9, so ",NA,NA
it's land or marsh. ,NA,NA
"(4) The small region below the ships is land, marsh, or cloud by C6. But it can't be marsh by C5, so it's ",NA,NA
land or cloud. ,NA,NA
"(5) The middle region is land, marsh, or cloud by C6. But it can only be land or cloud by C4 applied to ",NA,NA
the upper-right T vertex. ,NA,NA
"(6) The big upper left region is land, marsh, or cloud by C6. But it can only be land or cloud by C4. ",NA,NA
(7) The middle region cannot be land any more because marsh has been ruled out for the upper-left ,NA,NA
"region, using C4 part (b). So it must be a cloud. ",NA,NA
(8) That means that the semi-small region upper middle of the picture must be cloud by C4 part (b). ,NA,NA
"(9) The medium-size region left and below the middle region is land, marsh, or cloud by C6. But it can't ",NA,NA
"be marsh by C4 (since then it would violate both parts of C4), so it's land or cloud. But it can't be land, ",NA,NA
since then either the border region or the big upper left region would need to be water to satisfy C4 part ,NA,NA
"(b) on the left side, and both those labels are impossible. So it must be cloud. ",NA,NA
(10) Hence the small region inside the last-considered region is an airplane. ,NA,NA
(11) Hence the lower left region must be a cloud too by C4 part (b) applied at the left of the two T ,NA,NA
vertices. ,NA,NA
(12) The small region in the upper left must be an airplane by C2. ,NA,NA
"13-10. (a) 8 multiplied ten times, or 8 to the 10th power = 2 to the 30th power, or about one billion. ",NA,NA
"(b) Each propagation cuts the size of the search space (number of possible combinations) in half, so 30 ",NA,NA
steps are needed on the average. ,NA,NA
"13-11. It's like the ""dual"" of the original picture graph, as they say in graph theory. Regions become ",NA,NA
"vertices, vertices become regions, and edges become edges (though with a different meaning). ",NA,NA
13-12. The objective is to find some set of weak constraints that when assumed give a unique solution to ,NA,NA
"the problem. For this search problem, the states are subsets of the set of all weak constraints. Goal states ",NA,NA
"are the states whose constraints, plus the original ""strong"" constraints, give one and only one ",NA,NA
interpretation to the problem. An evaluation function is the number of solutions possible with the full set ,NA,NA
of constraints. A cost function in the total probability that a set of weak constraints hold simultaneously. ,NA,NA
"Computing it may be a little tricky, though; it's a form of ""and""-combination, so we can use the ",NA,NA
conservative independence or liberal assumption from Chapter 8. But a more general approach would be ,NA,NA
to divide the weak constraints into classes where each class is relatively independent in probability from ,NA,NA
"every other class, then use the conservative assumption to combine probabilities within each class, and ",NA,NA
the independence-assumption combination to combine those. Search with both an evaluation and cost ,NA,NA
function suggests the A* search strategy. The evaluation function is not a lower bound on the cost ,NA,NA
"function, so we can't be sure the first solution we find is the optimal solution, but that's all right because ",NA,NA
we are more concerned about getting a reasonable solution than an optimal solution. ,NA,NA
13-15. You can reuse much of the code in the cryptarithmetic example. The last eight lines of that file can ,NA,NA
"be copied directly, the lines concerning satisfiability of the uniqueness condition. The other ""satisfiable"" ",NA,NA
"rule can look very similar to that for ""sum"": ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (70 of 88) [23/04/2002 17:40:03],NA
"satisfiable(product,L,[D1,D2,Carryin,Digit,Carryout]) :- ",NA,NA
"some_bindings(L,[D1,D2,Carryin,Digit,Carryout]), P is (D1*D2)+Carryin, P2 is Digit + (Carryout*10), ",NA,NA
"P=P2. satisfiable(unique,L,VL) :- unique_values(L,VL,[]). ",NA,NA
"There are eight distinct digits in the problem so let's call them a, c, d, e, f, g, and h. We'll call the carries ",NA,NA
"c1, c2, and so on. The the choices are: ",NA,NA
"choices(D,[0,1,2,3,4,5,6,7,8,9]) :- member(D,[c,d,e,f,g]). choices(D,[1,2,3,4,5,6,7,8,9]) :- ",NA,NA
"member(D,[a,h]). choices(C,[0,1,2,3,4,5,6,7,8]) :- member(C,[c1,c2,c3,c4,c5,c6,c7]). ",NA,NA
And the constraints can be written: ,NA,NA
"constraint(product,[h,h,0,a,c1]). constraint(product,[g,h,c1,a,c2]). constraint(product,[f,h,c2,a,c3]). ",NA,NA
"constraint(product,[e,h,c3,a,c4]). constraint(product,[d,h,c4,a,c5]). constraint(product,[c,h,c5,a,c6]). ",NA,NA
"constraint(product,[2,h,c6,a,c7]). constraint(product,[a,h,c7,a,a]). constraint(unique,[a,c,d,e,f,g,h]). ",NA,NA
The solution found is 12345679 * 9 = 111111111. ,NA,NA
13-16. [too hard to give] ,NA,NA
13-17. [too hard to give] ,NA,NA
14-3.(a) ,NA,NA
"(1) on(a,table). (2) on(b,a). (3) on(c,a). (4) on(d,c). (5) color(a,blue). (6) color(b,blue). (7) color(c,red). (8) ",NA,NA
"color(d,green). (9) above(X,Y); not(on(X,Y)). (10) above(X,Y); not(on(X,Z)); not(above(Z,Y)). (b) The ",NA,NA
"goal is ""above(d,Y), color(Y,blue)""; we use proof by contradiction. ",NA,NA
(11) Assume the negation of the goal: ,NA,NA
"not(above(d,Y)); not(color(Y,blue)). ",NA,NA
"(12) Resolve 11 with 10, taking X=d and Y=Y, giving ",NA,NA
"not(on(d,Z)); not(above(Z,Y)); not(color(Y,blue). ",NA,NA
"(13) Resolve 12 with 9, taking X=Z and Y=Y, giving ",NA,NA
"not(on(Z,Y)); not(on(d,Z)); not(color(Y,blue)). ",NA,NA
"(14) Resolve 13 with 4, taking c=Z, giving ",NA,NA
"not(on(c,Y)); not(color(Y,blue)). ",NA,NA
"(15) Resolve 14 with 5, taking Y=a, giving ",NA,NA
"not(on(c,a)). ",NA,NA
"(16) Resolve 15 with 3, giving the null clause. ",NA,NA
"14-4. No, resolution can only cross out one thing at a time. To see this, suppose we match just the ""a"" and ",NA,NA
"""not(a)"". Then we get as a resolvent ""b; not(b)."" which is always true (a ""tautology""), the exact opposite ",NA,NA
of the null clause. A tautology is useless because it always is true; it doesn't need to be derived. ,NA,NA
14-6. (a) ,NA,NA
a; not(b); not(c). a; b; not(d). ,NA,NA
"(b) a :- c, d. ",NA,NA
"(c) Given two rules with the same left side, and some term that occurs in unnegated form in one rule and ",NA,NA
"negated form in the other, you can write a new rule with that same left side, whose right side consists of ",NA,NA
"all the terms on both right sides, eliminating duplicates. If furthermore some P and not(P) occur on the ",NA,NA
"new right side, then the left side is a fact. ",NA,NA
"Before making this new rule a part of the database, we should check that it is not implied by any other ",NA,NA
"single rule. Generally speaking, it's not a good idea to delete the old rules when this new rule is added to ",NA,NA
the database because it won't often be better than the old rules. (It's likely it has as many or more terms ,NA,NA
than the old rules.) ,NA,NA
"14-7. (a) weekend(T); holiday(T); not(empty(spanagel421,T)). ",NA,NA
"(b) holiday(T) :- not(weekend(T)), empty(spanagel421,T). ",NA,NA
"(c) (holiday(T),weekend(T),empty(spanagel421,T),full expression): (true,true,true,true) ",NA,NA
"(true,true,false,true) (true,false,true,true) (true,false,false,true) (false,true,true,true) (false,true,false,true) ",NA,NA
"(false,false,true,false) (false,false,false,true) ",NA,NA
"(d) The original weekend(T) term was unnegated, so the negated form in the new rule must be a ""real"" or ",NA,NA
"""true"" not--something impossible to ensure in standard Prolog. In other words, the new rule will succeed ",NA,NA
in more situations than the first rule. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (72 of 88) [23/04/2002 17:40:03],NA
14-8. It requires a more sophisticated kind of reasoning than Prolog is capable of without considerable ,NA,NA
"additional support. We could prove that p(7) is true when p(6) is true using Prolog, but we can't prove that ",NA,NA
"p(N+1) is true for some arbitrary N when p(N) is true, because adding the fact ""p(N)"" to the database ",NA,NA
"would mean N+1 could match N too (query variables are local to a query, and database variables are local ",NA,NA
"to the database rule or fact). The axiom also requires reasoning about a hypothetical situation, something ",NA,NA
"Prolog can't do directly (though creating ""possible worlds"" in search processes can come close to this). ",NA,NA
"These are ""second-order-logic"" and ""existential quantification"" issues, but they're in a different form from ",NA,NA
that discussed in Section 14.1. A number of resolution-reasoning systems do allow you to add similar ,NA,NA
axioms to your clauses and reason about them. ,NA,NA
"14-10. (a) Change the first line of ""resolution"" to: ",NA,NA
"resolution(C1,C2,Cnew) :- twoclauses(C1,C2), ",NA,NA
"And use a ""bagof"" to collect all clauses, and then the ""append"": ",NA,NA
"twoclauses(C1,C2) :- bagof(C,clause(C),CL), append(L1,[C1|L2],CL), append(L3,[C2|L4],L2). ",NA,NA
"append([],L,L). append([X|L],L2,[X|L3]) :- append(L,L2,L3). ",NA,NA
"(b) Add ""fix_subsets(Cnew)"" just before the ""asserta(clause(Cnew))"" in ""resolution"", defined as: ",NA,NA
"fix_subsets(C) :- not(fix_subsets2(C)). fix_subsets2(C) :- clause(C2), subset(C,C2), retract(clause(C)), ",NA,NA
fail. ,NA,NA
"15-2. Add an extra argument to all Prolog rules to hold the trace list, and assemble this list using the ",NA,NA
"""append"" predicate (section 5.6) as rules succeed. For instance, if an original rule named ""r5"" was ",NA,NA
"a(X) :- b(X,Y), c(X). ",NA,NA
then change it to ,NA,NA
"a(X,T) :- b(X,Y,T1), c(X,T2), append([r5|T1],T2,T). ",NA,NA
"And add another argument ""fact"" to all facts. ",NA,NA
15-4. Pick an arbitrary example case for each conclusion you want the rule-based system to make. Then ,NA,NA
"for each case, write a rule whose left side is desired conclusion and whose right side is the conjunction of ",NA,NA
"all facts true for that case. For instance, if diagnosis ""a"" should be made when facts ""b"", ""c"", and ""e"" are ",NA,NA
"true and ""d"" is false, write a rule ",NA,NA
"a :- b, c, not(d), e. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (73 of 88) [23/04/2002 17:40:03],NA
"15-5. (a) R1 could have the same predicate name on its left side as R2, but R1 could have filled in (that is ",NA,NA
assigned to constants) one or more arguments that are variables in R2. ,NA,NA
(b) First we need a definition: a predicate expression P covers a predicate expression Q if either a Prolog ,NA,NA
"query on P can match a database fact Q, or if Q and P can be written respectively as ""not(R)"" and ""not(S)"" ",NA,NA
and S covers R. We can then say that rule R1 is redundant with respect to rule R2 if (1) every predicate ,NA,NA
"expression on the right side of R2 covers an expression on the right side of R1, and (2) the left side of R2 ",NA,NA
covers the left side of R1. (The right side of R2 may include additional terms not on the right side of R1.) ,NA,NA
15-7. [too complicated to give] ,NA,NA
M-2. (a) Search can always be thought of as a problem of traversing a lattice. ,NA,NA
"(b) Frames form lattices based on ""a_kind_of"" and ""part_of"" links. ",NA,NA
"(c) Decision lattices and and-or-not lattices are important compilation tricks. Also, the partitions created ",NA,NA
when partitioning a rule-based system could form a lattice. ,NA,NA
"(d) Resolution is a kind of search, and so can be viewed as lattice traversal where each node is a set true ",NA,NA
"clauses at some point. But also a lattice can model the dependencies between clauses, where each node is ",NA,NA
"a single clause: if a clause X is proved by resolving clauses Y and Z, then you can draw arrows from Y to ",NA,NA
X and from Z to X. ,NA,NA
"M-6.(a) Yes, if A causes B, and B causes C, then A causes C (though C may have other causes too). (b) In ",NA,NA
"two cases. But if A causes B, and C is part of B, then A causes C. And if A causes B, and B is part of C, ",NA,NA
"you could argue that A is one of the causes of C, and consistent with our definition of ""A causes C"". ",NA,NA
"But if A causes B, and A is part of C or C is a part of A, it doesn't make sense that C could cause B. ",NA,NA
"(c) One thing is that you can't reason backwards with rules; they're a ""one-way"" (unidirectional) way of ",NA,NA
"reasoning, whereas often it's useful to reason from effects to causes as well as from causes to effects (as in ",NA,NA
expert systems for diagnosis of problems). So writing causes as two-argument facts ,NA,NA
"causation(<cause>,<effect>). ",NA,NA
"would be more flexible. Also, the Prolog "":-"" symbol just reflects one aspect of causation, and it doesn't ",NA,NA
"represent well the notion that events have times, and the time of the effect cannot be before the time of the ",NA,NA
cause. ,NA,NA
"M-7.(a) ""But"" is like an ""and"" or two assertions (that is, two separate assertions) but where the second ",NA,NA
"assertion violates the usual consequences of the first assertion. Typically, the statement ""x but y"" means ",NA,NA
"that x and y are facts, yet there's a rule with probabilities (or a rule could be written) that says something ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (74 of 88) [23/04/2002 17:40:03],NA
"like ""yo(P) :- x."", where ""yo"" means the opposite of ""y"", or ""yo"" implies the opposite of ""y"" by a chain of ",NA,NA
forward-chaining inferences. ,NA,NA
"(b) ""But"" would be useful in summarizing facts, when certain facts don't make an analogy that usually ",NA,NA
"holds. For instance, the facts ",NA,NA
"a(1,4). a(1,3) a(1,2). a(7,4). a(7,3). ",NA,NA
"could be summarized as ""Predicate a holds for 1 and 7 as first argument, with 2, 3, and 4 as second ",NA,NA
"argument, but not for (7,2)."" ""But"" would also be useful in describing exceptions to general rules, for ",NA,NA
"instance, ""the 'flying-ability' predicate usually inherits with value ""yes"" for birds, but not for penguins, ",NA,NA
"when it is overridden."" ",NA,NA
"(c) No, because it's too much a natural-language (""discourse"") signal used to facilitate communication, ",NA,NA
"and it doesn't have much logical meaning beyond an ""and"". ",NA,NA
M-8(a). Sounds like a classic application for a rule-based system with forwards chaining. Probabilities are ,NA,NA
essential since evidence is weak. Frames for different kinds of objects and their behavior might help ,NA,NA
"organize facts. Blackboards could help if a lot of hypotheses are generated, as well as focus-of-attention ",NA,NA
"conflict resolution. Generate-and-test could be used to explain sensor readings based on observations, but ",NA,NA
"it makes more sense to use it to write rules than to execute them, which doesn't really count. Inheritance ",NA,NA
might apply if you have hierarchies of object classes. The other techniques listed aren't very helpful for ,NA,NA
this problem. ,NA,NA
"(b) Sounds like a classic search problem. It's a search that tries to optimize something, but apparently no ",NA,NA
"path costs are involved, so best-first search is the only applicable search strategy from the choices given. ",NA,NA
"You could use generate-and-test to guess good solutions and verify them, desirable if you have a good ",NA,NA
generator provided by an expert in the domain of the problem. If you have a lot of constraints (like ,NA,NA
"protecting certain positions sufficiently), relaxation would be helpful. Frames for your resources ",NA,NA
"(personnel and weapons) could summarize their properties, and you could have hierarchies of them. ",NA,NA
Inheritance and defaults might be helpful on these hierarchies. The A* algorithm could be used if you ,NA,NA
took into account costs of steps necessary to achieve a configuration. A rule-based system with either ,NA,NA
"forwards or backwards chaining might suggest good approaches, but wouldn't guarantee optimality of a ",NA,NA
configuration. ,NA,NA
M-9. [too complicated to give] ,NA,NA
.PA ,NA,NA
ANSWERS TO THE ADDITIONAL PROBLEMS IN THIS MANUAL ,NA,NA
"I-1. (a) ""yes"", since X, Y, and Z can be bound to 2 ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (75 of 88) [23/04/2002 17:40:03],NA
"(b) ""Q=4"". For this X=4, Y=2, and Z=2. ",NA,NA
"(c) Three times, once for every fact that can match the first predicate expression in the rule, b(X,Y). This ",NA,NA
"makes sense because the interpreter can only answer ""no"" when it's tried every ""b"" fact. ",NA,NA
I-2. (a) The maximum number of answers occurs when there are the maximum number of ways to link the ,NA,NA
two predicate expressions. This occurs when there are the minimum number of B values. There can't be ,NA,NA
"only one B value, since then there could only be one fact that could satisfy the query, the fact with both ",NA,NA
"arguments identical. So there must be two possible B values; call them ""a"" and ""b"". ",NA,NA
"For the maximum number of query answers, we shouldn't have anything besides a and b as a first ",NA,NA
"argument in a fact, for otherwise those facts couldn't match any queries. So the first argument to every ",NA,NA
fact must be either a or b. ,NA,NA
This gives as the solution the facts involving the only four possible pairs of the two values: ,NA,NA
"link(a,a). link(a,b). link(b,a). link(b,b). ",NA,NA
For this there are eight answers: ,NA,NA
"A=a, B=a, C=a; A=a, B=a, C=b; A=a, B=b, C=a; A=a, B=b, C=b; A=b, B=a, C=a; A=b, B=a, C=b; ",NA,NA
"A=b, B=b, C=a; A=b, B=b, C=b; ",NA,NA
"(b) If the only answer to the query is ""no"", four matchings for the first predicate expression will be tried. ",NA,NA
"That means three backtracks to get the four answers, plus one more backtrack to fail the first predicate ",NA,NA
expression and fall off the left end of the query. ,NA,NA
"I-3. (a;not(c)),b,c = (a,b,c);(not(c),b,c) = a,b using the distributive law and then recognizing an ""or"" of E ",NA,NA
with a contradiction must be E. ,NA,NA
"I-4. (a) R=north, S=hall, T=poindexter ",NA,NA
"(b) 2 times, because it eventually uses the third fact to match the first predicate expression. ",NA,NA
"I-5.(a) yes, the extra extra just has the potential to rule out previous answers, and can't add new answers ",NA,NA
"(b) always more time, since all the same work as before is being done before the new expression is ",NA,NA
reached ,NA,NA
"(c) yes, for the same reason; the 26-7=19 new failures are all due to the new expression ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (76 of 88) [23/04/2002 17:40:03],NA
"(d) now sometimes more and sometimes less, because the new expression could decrease time by quickly ",NA,NA
rule out cases that took a lot of work to rule out previously ,NA,NA
I-6.(a) The fourth rule. ,NA,NA
"(b) Yes: Q=usnavy, T=enterprise, P=usgovernment. ",NA,NA
"I-7. (a) Yes, in the sense that if A is necessary for B, and B is necessary for C, then A is necessary for C: ",NA,NA
"necessary(A,C) :- necessary(A,B), necessary(B,C). ",NA,NA
"It doesn't make sense to call this either ""upwards"" or ""downwards"", since events can't be more general ",NA,NA
"than other events. Maybe call this ""sideways"" transitivity. ",NA,NA
"(b) Yes, if the ""before9"" property holds for event B, and A is necessary for B to have occurred, then the ",NA,NA
before9 property holds for event A: ,NA,NA
"before9(X) :- necessary(X,Y), before9(Y). ",NA,NA
"But it doesn't work reasoning in the other direction. Note that even though we wrote the ""before9(X)"" ",NA,NA
"predicate expression with one argument, you can think of it as equivalent to a predicate ",NA,NA
"""before(X,9amfeb101986)"" in the more conventional property-predicate form. ",NA,NA
"I-8.(a) delete(a,[b,c],[a,c]); this call fails. ",NA,NA
(b) X=b ,NA,NA
"I-9. For instance, we want to convert the list ",NA,NA
"[a,b,c,d,e,f] ",NA,NA
to the list ,NA,NA
"[[a,b],[c,d],[e,f]] ",NA,NA
"We can write the first list as [a,b|L] and the second as [[a,b]|PL]. And there's the additional condition that ",NA,NA
PL is the pairing of list L. Hence: ,NA,NA
"pair([],[]). pair([X,Y|L],[[X,Y]|PL]) :- pair(L,PL). ",NA,NA
"I-10. intersection([],S2,[]). intersection([X|S1],S2,[X|I]) :- member(X,S2), intersection(S1,S2,I). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (77 of 88) [23/04/2002 17:40:03],NA
"intersection([X|S1],S2,I) :- intersection(S1,S2,I). member(X,[X|L]). member(X,[Y|L]) :- member(X,L). I-",NA,NA
11. It says the reverse of its list first argument is its second argument. Items are transferred one by one ,NA,NA
"from the first argument to the second (initially empty) second argument, so the second argument, at the ",NA,NA
"bottom level of recursion, ends up in reverse order like a stack. Then at this bottom level of recursion, the ",NA,NA
"basis step binds the third argument to the current state of the second, making permanent so to speak the ",NA,NA
binding; this is then the answer. Note the program does the same thing when the first argument is bound ,NA,NA
and second unbound as when the second argument is bound and first unbound; when both arguments are ,NA,NA
"bound, it verifies that one list is the reverse of the other. ",NA,NA
"I-12. Each of the three facts can in turn match the first predicate expression on the right side of the rule, ",NA,NA
giving: ,NA,NA
"bottom(north) :- not(bosses(north,U)). bottom(poindexter) :- not(bosses(poindexter,U)). bottom(hall) :- ",NA,NA
"not(bosses(hall,U)). ",NA,NA
"There are no more facts, so we must handle ""not""s. Only the one in the last rule above succeeds, giving ",NA,NA
"the fact ""bottom(hall)"". That's all we can prove. ",NA,NA
"I-13.(a) Fact e(5) doesn't match anything. But f(3) matches the right side of the second rule, so c(3) is a ",NA,NA
fact. Fact c(3) gives the new rules (in order): ,NA,NA
a(3) :- b(3). b(3) :- not(d(3)). ,NA,NA
And nothing further can be concluded. So we handle nots. The first one not(e(Z)) fails because e(5) is a ,NA,NA
"fact, but not(d(3)) succeeds. Hence b(3) succeeds, and then a(3) succeeds. If rules are never deleted, the ",NA,NA
remaining rule ,NA,NA
"b(Y) :- c(Y), not(d(Y)). ",NA,NA
can lead to another rule ,NA,NA
b(Y) :- c(Y). ,NA,NA
"but this doesn't lead to anything. Overall order of new facts: c(3), b(3), a(3). ",NA,NA
"(b) On the first cycle, the first rule fails, but the second succeeds and proves the fact c(3). The third and ",NA,NA
"fourth rules can't be used yet, and the second cycle doesn't accomplish anything. So now we consider nots ",NA,NA
"for a third cycle. There aren't any in the first two rules, and the not in the third rule fails, but the fourth ",NA,NA
rule now succeeds and proves b(3). And then on the fourth cycle a(3) is proved. That's all. Overall order ,NA,NA
"of new facts is the same as part (a): c(3), b(3), a(3). ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (78 of 88) [23/04/2002 17:40:03],NA
I-14.(a) ,NA,NA
"diagnosis(chicken_pox) :- rash, not(fever(high)). diagnosis(german_measles) :- rash, cold_symptom, ",NA,NA
"fever(mild). diagnosis(measles) :- rash, cold_symptom, fever(high). diagnosis(mumps) :- fever(mild), ",NA,NA
"sore_throat. diagnosis(scarlet_fever) :- fever(medium), sore_throat. diagnosis(cold) :- cold_symptom, ",NA,NA
"fever(X). fever(high) :- temperature(T), T>102. fever(medium) :- temperature(T), T>100.5, T=<102. ",NA,NA
"fever(mild) :- temperature(T), T>99, T=<100.5. cold_symptom :- sneezing. cold_symptom :- headache. ",NA,NA
cold_symptom :- sore_throat. ,NA,NA
"(b) That is, we query ",NA,NA
diagnosis(X). ,NA,NA
"with the above rules and the four specified facts, and keep typing semicolons until we find all answers. ",NA,NA
"However, we are told to take the diseases in a different order than the above, so it's like we rearrange the ",NA,NA
rules before querying to ,NA,NA
"diagnosis(measles) :- rash, cold_symptom, fever(high). diagnosis(scarlet_fever) :- fever(medium), ",NA,NA
"sore_throat. diagnosis(chicken_pox) :- rash, not(fever(high)). diagnosis(mumps) :- fever(mild), ",NA,NA
"sore_throat. diagnosis(german_measles) :- rash, cold_symptom, fever(mild). diagnosis(cold) :- ",NA,NA
"cold_symptom, fever(X). fever(high) :- temperature(T), T>102. fever(medium) :- temperature(T), ",NA,NA
"T>100.5, T=<102. fever(mild) :- temperature(T), T>99, T=<100.5. cold_symptom :- sneezing. ",NA,NA
cold_symptom :- headache. cold_symptom :- sore_throat. ,NA,NA
Then the measles diagnosis fails (but establishes the cold_symptom conclusion); scarlet fever succeeds ,NA,NA
(after first establishing the fever(medium) conclusion); chicken pox succeeds; mumps fails; German ,NA,NA
measles fails; and cold succeeds. ,NA,NA
"(c) The sore throat fact matches predicate expressions in the scarlet_fever and last cold_symptom rules, ",NA,NA
"and the new fact cold_symptom is proved. This last is now pursued, and it matches expressions in the ",NA,NA
"measles and german_measles rules. Next temperature(101) is pursued, giving fact fever(medium). This ",NA,NA
fact causes first the scarlet_fever diagnosis and then the cold diagnosis to be proved. ,NA,NA
"The desire to go to the circus doesn't match anything in the rules, but the rash fact does match expressions ",NA,NA
"in the measles, chicken pox, and German measles rules. We've run out of facts, so we not handle nots. In ",NA,NA
"this case, there is a single not expression in the chicken pox rule, and its argument is false, so the ",NA,NA
"expression can be removed, proving the chicken pox diagnosis. Nothing further can be proved. ",NA,NA
"(d) On the first cycle only the fever(medium) and cold_symptom facts are proved. On the second cycle, ",NA,NA
"the diagnoses of scarlet fever and cold are proved. The third cycle doesn't prove anything, so nots are then ",NA,NA
handled. On the fourth cycle the chicken pox diagnosis succeeds. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (79 of 88) [23/04/2002 17:40:03],NA
"(e) The diseases are considered in order of severity, so the first diagnosis reached is the one you should be ",NA,NA
most concerned about. That's helpful to know when using the program. ,NA,NA
"(f) Yes, asking questions of a user is important in this system, and decision lattices are good for question-",NA,NA
"asking applications. In fact, some ""home medicine"" books are organized like decision lattices. Decision ",NA,NA
"lattices are particularly good for small computers, and a medical system like this could have a market on ",NA,NA
"home computers. The variable can be easily removed by using predicates like ""high_fever"" and including ",NA,NA
"ranges in temperature questions, as ""Is the fever 99 to 100.5 degrees?"" ",NA,NA
"While just what questions to ask first in the lattice are not immediately obvious, techniques exist to find ",NA,NA
"them by While just what questions to ask first in the lattice are not immediately obvious, techniques exist ",NA,NA
to find them by focussing on the predicates appearing most often in rules. Just looking at the 12 rules in ,NA,NA
"this problem, a good first question would be whether there's a rash, since three diagnoses mention it and ",NA,NA
"three don't; the next question could be about temperature, because that helps a lot to distinguish among ",NA,NA
the diseases; then one more question will establish the most serious possible disease. ,NA,NA
"Decision lattices implicitly represent the answers to previous questions from their location in the tree, so ",NA,NA
inability to cache is not usually a major obstacle. Inability to backtrack doesn't seem important in this ,NA,NA
application. ,NA,NA
(g) No. Clearly medical rules like these must ask questions of a user since their main application is for ,NA,NA
"non-medical users (doctors have memorized these basic things), and medical facts require judgement by ",NA,NA
an observer. Computation speed is unimportant when you're asking questions and must wait for the user ,NA,NA
"to answer. Also, you can't ask a user two questions simultaneously, and nearly all predicate expressions in ",NA,NA
a rule will require a question of the user. And speed of the rule-based system isn't important: medical ,NA,NA
"actions rarely require action within seconds, whereas a well-implemented 1000-rule system should be able ",NA,NA
"to complete its job in at most a second. So if you want a compiled form, the decision lattice sounds much ",NA,NA
better. ,NA,NA
"I-15. Or-parallelism is possible between q and u to begin; if u succeeds in binding its argument, q can be ",NA,NA
"terminated. Otherwise, if q succeeds in finding an X, wait until u has failed, and then proceed to query r to ",NA,NA
"bind Y, and simultaneously check s with and-parallelism. If either process fails, terminate both processes ",NA,NA
"and backtrack to q to get another X. If r succeeds and s has either succeed or not finished, start verifying ",NA,NA
"condition t on the same processor that bound Y. If s fails, kill both processes and start q again; if t fails, ",NA,NA
"use the processor that tried to verify it to run r again. If both s and t succeed, the query succeeds. ",NA,NA
"I-16. Have ""impermissible"" facts that say what combinations don't go together. Then when parsing or ",NA,NA
"generating a sentence, keep a record via ""asserta"" of what substitutions were made, and compare to this. ",NA,NA
"I-17.(a) forward chaining, since it starts from facts and works to a conclusion; it doesn't try to ""confirm"" ",NA,NA
anything ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (80 of 88) [23/04/2002 17:40:03],NA
"(b) forward chaining too, since signals coming in represent facts, which then are propagated through gates ",NA,NA
to conclusion lines ,NA,NA
I-18. Both these questions just involve redefinition of the expected cost R of the rules. ,NA,NA
(a) R=MQH + 2(1-MQ)H. So caching is desirable if P(2-MQ)H>1. (b) R=Q*4H/M*M + Q*2*4H/M*M ,NA,NA
+ Q*3*4H/M*M + ... + (1-MQ)*4H/M or R=(2H/M)[Q+2-MQ]. ,NA,NA
I-19. The intermediate predicates (plus one diagnosis) are the only things that might be useful to cache. ,NA,NA
"But so little computation is needed for any of them that caching would be useless--after all, it takes a lot ",NA,NA
more microseconds for a user to type answers to queries than for Prolog to explore all the nooks and ,NA,NA
"crannies of this code. Notice there isn't any list processing in the program, a major time-waster in many ",NA,NA
Prolog programs. ,NA,NA
"I-20. Any arithmetic computations cannot be ""matched"" for, but should still be kept in the rule, having ",NA,NA
their variables substituted for as the variables become bound. Whenever all but arithmetic-computation ,NA,NA
"expressions have been matched for on the right side of some rule, the computations should be performed, ",NA,NA
and the left side made a fact with the appropriate numerical bindings. ,NA,NA
"I-21. Note the double ""not"" prevents backtracking. prog([]). prog([P|L]) :- not(negcall(P)), prog(L). ",NA,NA
negcall(P) :- not(poscall(P)). poscall(P) :- call(P). poscall(P). ,NA,NA
I-22. [specific to your elevator] ,NA,NA
I-23. [it depends on your advertisement] ,NA,NA
I-24. The rules look like: ,NA,NA
"russian(0.5) :- russian_maneuvers. russian(P) :- waveform(z37,P2), andcombine([0.8,P2],P). ",NA,NA
And we're told we have the facts ,NA,NA
"russian_maneuvers. waveform(z37,0.5). ",NA,NA
"The independence assumption would give an and-combination of 0.8*0.5 = 0.4 in the second rule, and the ",NA,NA
or-combination of this with 0.5 would be 1-((1-0.5)(1-0.4)) = 0.7. That's the answer in part (a). ,NA,NA
"The conservative assumption would give max(0.8+0.5-1,0) = 0.3 in the second rule, and the or-",NA,NA
"combination of this with 0.5 is max(0.3,0.5) = 0.5. That's not the answer in part (b), but you didn't need to ",NA,NA
"compute it anyway, because 1.0 is more than 0.7, and conservative combination always gives the smallest ",NA,NA
possible values. ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (81 of 88) [23/04/2002 17:40:03],NA
"The liberal assumption would give min(0.8,0.5) = 0.5 in the second rule, and the or-combination of this ",NA,NA
"with 0.5 is min(0.5+0.5,1) = 1.0. That's the answer in part (b). ",NA,NA
I-25. (a) ,NA,NA
"c(P) :- bagof(P,c2(P),PL), orcombine(PL,P). c2(P) :- a(P1), b(P2), andcombine([P1,P2],P). c2(P) :- a(P1), ",NA,NA
"b(P2), NP1 is 1-P1, NP2 is 1-P2, andcombine([NP1,NP2,0.8],P). d(P) :- a(P1), b(P2), NP2 is 1-P2, ",NA,NA
"andcombine([P1,NP2,0.5],P). e(P) :- a(P1), b(P2), NP1 is 1-P1, andcombine([NP1,P2],P). ",NA,NA
"And define ""andcombine"" and ""orcombine"" differently for parts (b) and (c) from parts (d) and (e). ",NA,NA
"For parts (b)-(e), it helps to define: ",NA,NA
"test(Pb) :- checkretract(b(X)), asserta(b(Pb)), spectrum(L), test2(L). test2([]). test2([Pa|L]) :- ",NA,NA
"checkretract(a(Y)), asserta(a(Pa)), b(Pb), c(Pc), d(Pd), e(Pe), write([Pa,Pb,Pc,Pd,Pe]), nl, ",NA,NA
test2(L). ,NA,NA
"spectrum([0.0,0.2,0.4,0.6,0.8,1.0]). checkretract(P) :- call(P), retract(P). checkretract(P) :- not(call(P)). ",NA,NA
which automatically generates the results needed in a list form shown below. The Figures on the next ,NA,NA
page show parts (b)-(e). ,NA,NA
(b) ,NA,NA
"?- test(0.4). [0,0.4,0.48,0,0.4] [0.2,0.4,0.433279,0.0599999,0.32] [0.4,0.4,0.401919,0.12,0.24] ",NA,NA
"[0.6,0.4,0.38592,0.18,0.16] [0.8,0.4,0.38528,0.24,0.08] [1,0.4,0.4,0.3,0] ",NA,NA
(c) ,NA,NA
"?- test(0.9). [0,0.9,0.0800002,0,0.9] [0.2,0.9,0.23248,0.01,0.719999] ",NA,NA
"[0.4,0.9,0.39072,0.0200001,0.539999] [0.6,0.9,0.554719,0.0300001,0.36] ",NA,NA
"[0.8,0.9,0.724479,0.0400001,0.18] [1,0.9,0.9,0.0500002,0] ",NA,NA
.PA .PA ,NA,NA
"(d) Now ""andcombine"" and ""orcombine"" are changed to refer to conservative combination. ",NA,NA
"?- test(0.4). [0,0.4,0.4,0,0.4] [0.2,0.4,0.199999,0,0.2] [0.4,0.4,0,0,0] [0.6,0.4,0,0,0] [0.8,0.4,0.2,0,0] ",NA,NA
"[1,0.4,0.4,0.0999999,0] ",NA,NA
"(e) ?- test(0.9). [0,0.9,0,0,0.9] [0.2,0.9,0.0999995,0,0.699999] [0.4,0.9,0.299999,0,0.5] [0.6,0.9,0.5,0,0.3] ",NA,NA
"[0.8,0.9,0.699999,0,0.0999999] [1,0.9,0.9,0,0] ",NA,NA
"(f) The curves show sharp corners, which doesn't seem too reasonable for an evidence combination ",NA,NA
"method. It's not fair to cite being close to zero as a disadvantage of the conservative method, because ",NA,NA
maybe the true probabilities really are close to zero; strong correlations are not unusual between terms in ,NA,NA
"expert systems, and then the conservative formula may best describe things. ",NA,NA
I-26. (a) c ,NA,NA
(b) b ,NA,NA
(c) b ,NA,NA
"I-27. (a) Probably not, because you don't know what your goal states are in advance; they're just any state ",NA,NA
"(object) that has a filled-in value for the property you're interested in. (Note ""bidirectional"" for search ",NA,NA
"doesn't mean downwards and upwards inheritance, but start to goals and goals to start.) ",NA,NA
(b) Upwards reasoning to general or bigger concepts from specific or smaller concepts would have a ,NA,NA
"smaller branching factor, since there are fewer general and bigger concepts. As for start to goals reasoning ",NA,NA
"vs. goals to start reasoning, assuming you could do them both, you can't reach any conclusion about ",NA,NA
which is better because goals could be either above or below the start on the inheritance hierarchy. (c) ,NA,NA
One example: don't look for an inheritance path that is more than three links long. ,NA,NA
"(d) One example: in inheriting properties of parts of a car, try a_kind_of links before part_of links. ",NA,NA
"(e) No, because there are no obvious intermediate states where paths converge. ",NA,NA
"(f) No, because if an earlier state had a ""part_of"" link departing from it, that doesn't mean every later state ",NA,NA
on a path does. ,NA,NA
I-28. ,NA,NA
"start(Ans) :- bagof(F,fact(F),FL), bagof(R,rule(A,B),RL), search([FL,[],RL],Ans). ",NA,NA
"successor([[F|FL],UFL,RL],[NFL,[F|UFL],RL2]) :- pursue(F,RL,RL2,NFL). pursue(F,[],[],F) :- !. ",NA,NA
"pursue(F,[[Rleft,Rright]|RL],[[Rleft,Rright]|NRL],NFL) :- not(member(F,R)), !, pursue(F,RL,NRL,NFL). ",NA,NA
"pursue(F,[Rleft,Rright]|RL],NRL,[Rleft|NRL]) :- delete(F,R,[]), pursue(F,RL,NRL,NFL). ",NA,NA
"pursue(F,[Rleft,Rright]|RL],NRL,[[Rleft,NRright]|NRL]) :- delete(F,Rright,NRright), ",NA,NA
"pursue(F,RL,NRL,NFL). eval([A,B],N) :- length(A,N1), length(B,N2), N is N1+N2. I-29. [too long to ",NA,NA
give] ,NA,NA
I-30. ,NA,NA
"go(Ops) :- means_ends([fire(3),closed,dry], [fire(0),dry],Ops,Finalstate). recommended([fire(X)],hose). ",NA,NA
"recommended([open],drain). recommended([dry],wait). precondition(hose,[dry,open]). ",NA,NA
"precondition(drain,[closed]). precondition(wait,[]). deletepostcondition(hose,[dry]). ",NA,NA
"addpostcondition(hose,[flooded]). deletepostcondition(drain,[closed]). addpostcondition(drain,[open]). ",NA,NA
"deletepostcondition(wait,[flooded]). addpostcondition(wait,[dry]). transform(hose,L,[fire(0)|L2]) :- ",NA,NA
"singlemember(fire(1),L), delete(fire(1),L,L2). transform(hose,L,[fire(Y)|L2]) :- singlemember(fire(X),L), ",NA,NA
"X>1, delete(fire(X),L,L2), Y is X-2. transform(wait,L,L) :- singlemember(fire(0),L). ",NA,NA
"transform(wait,L,[fire(Y)|L2]) :- singlemember(fire(X),L), X>0, delete(fire(X),L,L2), Y is X+1. ",NA,NA
"transform(drain,L,L). ",NA,NA
I-31. One way: ,NA,NA
"/* The robot housekeeper problem by means-ends analysis */ test(A,B) :- ",NA,NA
"means_ends([lastact(none),robot(chute),basket(1,1), basket(2,2),dusty(1),dusty(2),trashy(1),untrashy(2), ",NA,NA
"notholding(1),notholding(2),vacuumed(1),vacuumable(2)], [robot(1),dusted(1),dusted(2),vacuumed(1), ",NA,NA
"vacuumed(2),basket(1,1),basket(2,2),untrashy(1), untrashy(2),notholding(1),notholding(2)],A,B). ",NA,NA
"recommended([dusted(X)],dust(X)). recommended([vacuumed(X)],vacuum(X)). ",NA,NA
"recommended([untrashy(X)],dispose(X)). recommended([holdingbasket(X)],pickup(X)). ",NA,NA
"recommended([notholding(X)],putdown(X)). recommended([basket(X,Y)],carry(X,Y)). ",NA,NA
"recommended([robot(X)],go(X)). ",NA,NA
"precondition(dust(X),[robot(X),dusty(X)]). ",NA,NA
"precondition(vacuum(X),[robot(X),vacuumable(X),dusted(X)]). ",NA,NA
"precondition(dispose(X),[robot(chute),trashy(X), ",NA,NA
"holdingbasket(X),basket(X,chute),dusted(X),vacuumed(X)]). ",NA,NA
"precondition(pickup(X),[basket(X,Y),robot(Y),trashy(X), notholding(X)]). ",NA,NA
"precondition(putdown(X),[basket(X,X),robot(X), holdingbasket(X),untrashy(X)]). ",NA,NA
"precondition(carry(X,Y),[basket(X,Z),robot(Z), holdingbasket(X)]). ",NA,NA
"precondition(go(X),[notholding(1),notholding(2)]). ",NA,NA
"deletepostcondition(dust(X),[dusty(X),vacuumed(X), lastact(A)]). ",NA,NA
"deletepostcondition(vacuum(X),[vacuumable(X),untrashy(X), lastact(A)]). ",NA,NA
"deletepostcondition(dispose(X),[trashy(X),lastact(A)]). ",NA,NA
"deletepostcondition(pickup(X),[notholding(X),lastact(A)]). ",NA,NA
"deletepostcondition(putdown(X),[holdingbasket(X), lastact(A)]). ",NA,NA
"deletepostcondition(carry(X,Y),[basket(X,Z),robot(Z), lastact(A)]). ",NA,NA
"deletepostcondition(go(X),[robot(Y),lastact(A)]). ",NA,NA
"addpostcondition(dust(X),[dusted(X),vacuumable(X), lastact(dust(X))]). ",NA,NA
"addpostcondition(vacuum(X),[vacuumed(X),trashy(X), lastact(vacuum(X))]). ",NA,NA
"addpostcondition(dispose(X),[untrashy(X), lastact(dispose(X))]). ",NA,NA
"addpostcondition(pickup(X),[holdingbasket(X), lastact(pickup(X))]). ",NA,NA
"addpostcondition(putdown(X),[notholding(X), lastact(putdown(X))]). ",NA,NA
"addpostcondition(carry(X,Y),[robot(Y),basket(X,Y), lastact(carry(X,Y))]). ",NA,NA
"addpostcondition(go(X),[robot(X),lastact(go(X))]). ",NA,NA
Here is it running: ,NA,NA
"?- test(A,B). A=[go(1),dust(1),go(2),dust(2),go(1),vacuum(1),go(2), ",NA,NA
"vacuum(2),go(1),pickup(1),carry(1,chute),dispose(1), ",NA,NA
"carry(1,1),putdown(1),go(2),pickup(2),carry(2,chute), dispose(2),carry(2,2),putdown(2),go(1)] ",NA,NA
"B=[robot(1),lastact(go(1)),notholding(2),basket(2,2), untrashy(2),notholding(1),basket(1,1),untrashy(1), ",NA,NA
"vacuumed(2),vacuumed(1),dusted(2),dusted(1)] ",NA,NA
"In one version of Prolog, this program used 45K of heap storage, 31K of global stack, and 41K of local ",NA,NA
"stack, and took 3.9 seconds. That's a lot better than the A* version of the same program in Exercise 10-9, ",NA,NA
but the above answer isn't optimal. ,NA,NA
"I-32. This means that goal descriptions will also need to contain ""not"" expressions. So we must add one ",NA,NA
"more rule to the definition of the ""difference"" predicate: ",NA,NA
"difference([],S,[]). difference([not(P)|G],S,G2) :- not(singlemember(P,S)), !, difference(G,S,G2). ",NA,NA
"difference([P|G],S,G2) :- singlemember(P,S), !, difference(G,S,G2). difference([P|G],S,[P|G2]) :- ",NA,NA
"difference(G,S,G2). ",NA,NA
"(In some Prolog dialects you must write ""not P"" above rather than ""not(P)"".) You'll also probably want to ",NA,NA
"modify the ""recommended"" rules to exploit these ""not"" terms. ",NA,NA
"I-33. There are no single-variable constraints. Picking variable X first, the first and third expressions both ",NA,NA
"give the possibility list [1,2,3,5]. Picking variable Y next, value 4 is possible by the first expression, but ",NA,NA
not by the second; value 5 is possible by both; value 3 is possible by both; value 6 is possible by the first ,NA,NA
"but not the second; hence the list [3,5]. Picking variable Z next, 3 satisfies all expressions; 6 fails the third ",NA,NA
"expression; 4 fails the fourth expression. So Z must be 3. Returning to X, it must be 3 by the third ",NA,NA
expression. And Y must be 3 by the second expression. ,NA,NA
I-34. Just subdivide the duplication-checking in the query into checking for each of ten pairs. Move the ,NA,NA
pair checking to right after the pairs values are bound: ,NA,NA
"test([T1,T2,T3,T4,T5]) :- classtime(T1), not(occupied(T1)), classtime(T2), not(occupied(T2)), ",NA,NA
"not(T1=T2), classtime(T3), not(occupied(T3)), not(T3=T1), not(T3=T2), classtime(T4), ",NA,NA
"not(occupied(T4)), not(T4=T1), not(T4=T2), not(T4=T3), classtime(T5), not(occupied(T5)), not(T5=T1), ",NA,NA
"not(T5=T2), not(T5=T3), not(T5=T4), not(two_consecutive_hours([T1,T2,T3,T4,T5])), ",NA,NA
"not(three_classes_same_day([T1,T2,T3,T4,T5])). ",NA,NA
I-35. (a) (ii) ,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (85 of 88) [23/04/2002 17:40:03],NA
(b) (i) ,NA,NA
I-36.(a) possibility lists ,NA,NA
(b) lists of probabilities for combination ,NA,NA
(c) the search agenda or the paths found to states ,NA,NA
(d) the places to backtrack to or the pointers to the database for each previous predicate expression I-,NA,NA
"37.(a) yes, if the operator definitions can create a cycle of branches; this is a common problem of depth-",NA,NA
first ,NA,NA
"(b) no, costs would have to keep increasing for any cycle until they were more than the solution path (c) ",NA,NA
"yes, subtle ordering problems can create loops (remember the means-ends discussed in the book is depth-",NA,NA
first) ,NA,NA
"(d) no, each cycle must cross something out or the cycling stops, and there are a finite number of things to ",NA,NA
cross out ,NA,NA
"(e) no, there can't be cycles involving ""part_of"" because if X is part of Y, then Y can't be part of X, or else ",NA,NA
"the ""part_of"" concept wouldn't be useful (or else there's a user mistake) ",NA,NA
"(f) yes, since ""is_another_name_for"" can make cycles ",NA,NA
"(g) no, since repeated actions or duplicate clauses are not allowed by any sensible resolution strategy I-",NA,NA
38.(a) ,NA,NA
"c(a,p,b). c(a,q,c). c(b,q,e). c(b,r,d). c(c,r,d). c(d,r,f). c(e,r,f). ",NA,NA
"(b) defective(O2) :- c(O1,P,O2), faulty(P). defective(O2) :- c(O1,P,O2), defective(O1). ",NA,NA
(c) The query is ,NA,NA
?- defective(d). ,NA,NA
"We can try the first rule, but it fails since process ""r"" isn't faulty. We can try the second rule, binding ",NA,NA
"O2=d, O1=b, and P=r. Then the new query is ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (86 of 88) [23/04/2002 17:40:03],NA
?- defective(b). ,NA,NA
"And this can match the first rule with O2=b, O1=a, and P=p, since we know that p is faulty. So the b ",NA,NA
"query succeeds, and hence the ""d"" query succeeds. ",NA,NA
"(d) defective(O2); not(c(O1,P,O2)); not(faulty(P)). defective(O2); not(c(O1,P,O2)); not(defective(O1)). ",NA,NA
"(e) Obviously we have to reason backward from f through r through d through r again to c. The ""faulty"" ",NA,NA
clause obviously can't help since the given and the conclusion are both about defective objects. So we just ,NA,NA
use the second clause in part (d) twice. Resolve it first with the fact not(defective(f)) to get ,NA,NA
"not(c(O1,P,f)); not(defective(O1)). ",NA,NA
"Resolve this with the fact c(d,r,f) to get ",NA,NA
not(defective(d)). ,NA,NA
as is obvious from the diagram. Now resolve this fact with again the second clause in part (d): ,NA,NA
"not(c(O1,P,d)); not(defective(O1)). ",NA,NA
"And resolve that with the fact c(c,r,d) to get ",NA,NA
not(defective(c)). ,NA,NA
"(f) Yes if we use something other than depth-first and if we suspect that X and Y are connected, since the ",NA,NA
"goal state is known and is unique, and the branching factor is similar in both directions. But if it's more ",NA,NA
"likely that X and Y aren't connected, then the bidirectional search could require significantly more work ",NA,NA
than a unidirectional search. ,NA,NA
"(g) (2+2+1+1+1) / 6 = 7/6 (h) successor(X,NX) :- c(X,P,NX). ",NA,NA
(i) Designate a variable for each object and each process (the letters in the diagram for part (a)). The ,NA,NA
"values for object variables are ""defective"" and ""nondefective""; the values for process variables are ",NA,NA
"""faulty"" and ""nonfaulty"". The constraints are the connection facts for part (a) and the rules for part (b). ",NA,NA
"But there's a subtle point: the rules can be used backwards as well as forwards, so there should really be ",NA,NA
four Prolog-style rules total. ,NA,NA
"(j) Slot inheritance examples: input, output, number of inputs, number of outputs, process name, process ",NA,NA
"type. Value inheritance examples: number of inputs, number of outputs, process name, process type. ",http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (87 of 88) [23/04/2002 17:40:03],NA
"(k) Inherit the value from the ""a_kind_of"" superframe. The ""a_kind_of"" relationship is usually more ",NA,NA
"fundamental, and in this case the ""part_of"" superframe can include a lot of irrelevant processes. ",NA,NA
(l) Some possibilities: ,NA,NA
--Draw the data-flow diagram and assign Cartesian coordinates to the objects; the evaluation function is ,NA,NA
the straight-line distance between states in the diagram. ,NA,NA
--Designate all no-input objects as level 0; then assign level numbers to every other object in the diagram ,NA,NA
"as in breadth-first search. If there are two or more level numbers for a state, pick the smallest. Then the ",NA,NA
evaluation function is the difference between level numbers of start and goal. ,NA,NA
"--Group objects into modules, and create a graph indicating which modules connect directly to which ",NA,NA
other modules. Let M be the maximum number of nodes in a module. Then an evaluation function is M ,NA,NA
times the number of links from the module containing X to the module containing Y. ,NA,NA
"--Let the evaluation function be 1 for objects that are not defective, 0 for objects that are. This is a weak ",NA,NA
"help, but it does qualify as an evaluation function. ",NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/im.html (88 of 88) [23/04/2002 17:40:03],NA
"Errata for Neil Rowe, Artificial Intelligence Through Prolog ",NA,NA
"February 24, 1989 ",NA,NA
"Please send any other errata you find to the author at code CS/Rp, Naval Postgraduate School, Monterey CA ",NA,NA
93943; or send email to rowe@cs.nps.navy.mil. ,NA,NA
(* = Prentice-Hall not yet informed) ,NA,NA
Errata for book itself: ,NA,NA
"Page xvi, end of last sentence: change ""nps-cs.arpa"" to ""cs.nps.navy.mil"". ",NA,NA
"Page 12, second paragraph of section 2.7: change ""circle"" to ""oval"" everywhere it occurs. ",NA,NA
"Page 13, 5th line from bottom: replace ""Here 'to be' is used"" with ""Here forms of the verb ""to be"" are used"" ",NA,NA
"Page 31, figure 3-3: arrow missing from ""X = tom, Y = dick"" to ""Z = harry"" ",NA,NA
"Page 44, 19th line: change ""part_of"" to ""a_kind_of"" so the whole line should read ""color_enterprise(C) :- ",NA,NA
"a_kind_of(enterprise,X), color(X,C)."" ",NA,NA
"Page 77, first line: change ""1"" (numeral one) to ""0"" (numeral zero). ",NA,NA
"Page 87, section 5.7, sixth line: change the second right bracket to a right parenthesis, so it reads: ",NA,NA
"subset([X|L1],L2) :- member(X,L2), subset(L1,L2).",NA,NA
"Page 103, seventh and sixth lines from the end of section 6.2: change ""old"" to ""new"", and change ""new"" to ""old"" in ",NA,NA
"the sentence ""It is redundant if the old rule always succeeds whenever the new rule succeeds."" ",NA,NA
"Page 105, figure 6-2, step 7, end of line: replace ""c."" with ""c(2)."" (note the period must remain on the end) (*) Page ",NA,NA
"107, Figure 6-4: ""R6"" column should read top to bottom in order: ""fails, -, -, -, -"" rather than ""fails, fails, fails, fails, -",NA,NA
""". ",NA,NA
"Page 129, 7th line from bottom: insert an apostrophe just before ""Are"" ",NA,NA
"Page 132, 3rd line, fourth word: ""emdry"" should be just ""dry"" ",NA,NA
"(*) Page 140, insert before 9th line sentence beginning ""When forward chaining..."" : ""This program does not delete ",NA,NA
"redundant rules like the algorithm in section 6.2."" ",NA,NA
"(*) Page 149, indented material starting ""forward :- done."": replace all but the first three lines, by the following: ",NA,NA
"pursuit(F) :- rules(F,Rlist), append(RlistF,[[L,R]|RlistB],Rlist),",http://www.cs.nps.navy.mil/people/faculty/rowe/book/errata.html (1 of 3) [23/04/2002 17:40:04],NA
" rule_pursuit(F,L,R,RlistF,RlistB).",NA,NA
"rule_pursuit(F,L,R,RlistF,RlistB) :- member(F,R), delete(F,R,Rnew), ",NA,NA
"retract(rules(F,Oldrules)), append(RlistF,RlistB,NewRlist), ",NA,NA
"new_rule(F,L,Rnew,NewRlist).",NA,NA
"new_rule(F,L,[],Rlist) :- asserta(rules(F,Rlist)), not(fact(L)), ",NA,NA
asserta(fact(L)).,NA,NA
"new_rule(F,L,R,Rlist) :- not(empty_list(R)), asserta(rules(F,[[L,R]|Rlist])). ",NA,NA
empty_list([]).,NA,NA
"append([],L,L).",NA,NA
"append([X|L],L2,[X|L3]) :- append(L,L2,L3).",NA,NA
"Page 188, 6th line from bottom: ""battery"" should be ""lottery"" ",NA,NA
"Page 196, Figure 9-3: the ""remove screws"" in the lower left should be ""remove cables"" ",NA,NA
"(*) Page 203, 19th line from bottom: change ""certain"" to ""restricted"" ",NA,NA
"Page 203, 11th line from bottom: change ""A to S"" to ""S to A"" ",NA,NA
"Page 203, 11th line from bottom: change ""3"" in ""A to 3"" to ""A to E"" ",NA,NA
"Page 221, second of the three groups of three indented lines: in all three cases the period must occur after the right ",NA,NA
"parentheses, not before it; in the hyphen in ""data-point"" should be an underscore symbol. ",NA,NA
"(*) Page 265, Figure 11-1, 5th column of table: delete ""?"" after ""visit"" ",NA,NA
"Page 277, Figure 11-7, ""Level 2"" box on left, sixth line: delete right bracket on the end, just after the comma Page ",NA,NA
"289, Figure 12-1: the ""frame_name: memos to Ann"" box should have a separate line with an arrow on it going to the ",NA,NA
"box labeled ""frame_name: memo"", and this arrow cannot be combined with the one from frame_name: budget ",NA,NA
"memos"" to ""frame_name: memo"", which must have its own line with an arrow on it. ",NA,NA
"Page 321, line 14: insert ""P and"" before ""all the expressions to the left"". ",NA,NA
"Page 362, Figure 14-4: the small upper center triangle-like region that is cross-hatched should not be; it should be ",NA,NA
"just have lines crossing it northwest to southeast, like the region to the left of it. ",NA,NA
"Page 363, problem 14-8: in fourth line, put parentheses around X and 1; in sixth line, put parentheses around N. In ",NA,NA
"all cases, no space after the ""p"". ",NA,NA
"Page 383, 12th line from the bottom: delete ""the"" from ""an included variable X, then that the expression"". ",NA,NA
"Page 388, item 6, second line: delete ""unbound"" (so same word won't occur twice in succession) ",NA,NA
"Page 390, sixth line from the bottom: change """,NA,NA
lattice,NA,NA
 or ,NA,NA
directed acycylic graph,NA,NA
""" to """,NA,NA
directed acyclic graph,NA,NA
 and ,NA,NA
usually also a ,NA,NA
lattice,NA,NA
""". ",NA,NA
"Page 407, problem 2-6, 10th line: ",NA,NA
ship,NA,NA
 should be ,NA,NA
ship_info ,NA,NA
"Page 409, fifth line: the ""4-5"" is on the wrong line: it should be on the left side of the sixth line in front of the word ",NA,NA
"""No"". The rest of the fifth line is correct, however; the ""(b)"" should be the first thing on the line. ",NA,NA
"Page 409, problem 4-7, part (e), second line: change ""Dick"" to ""Sue"" ",NA,NA
"Page 415, 10th line of text from bottom: ""L"" should be ""Z"", so the line should read ""?- mystery([a,b,c,d],Z)."" now. ",NA,NA
"Page 416, problem 5-22, 6th line: change ""not(member(X,L),L)"" to ""not(member(X,L))"". ",NA,NA
"Page 417, problem 6-1(a), 6th and 7th line from top: change the sentence ""This in turn matches an expression in ",NA,NA
"R2."" to ""This doesn't match anything (R2 is being ignored)."" ",NA,NA
"Page 417, problem 6-5(b), item ""1"": replace by: ""1. The first and third rules fail because they mention at least one ",NA,NA
"thing that doesn't match a fact, and the second rule is skipped."" ",NA,NA
"Page 418, problem 6-5(b), item ""5"": replace by: ""5. The first rule again fails, and the second rule is again skipped."" ",NA,NA
Errata for Instructors' Manual ,NA,NA
"Page 22: Add another arrow from ""C"" circle to the left side of the left most ""R"" box. ",NA,NA
"Page 26: The ""part_of"" arrows are backwards. ",NA,NA
"Page 96, line 3: delete duplicate ""extra"" ",NA,NA
"Page 96, line 9: change ""rule"" to ""ruling"" ",NA,NA
"Page 103: The point at (.3, .8) should be at (.2, .8). ",NA,NA
Page 110: This figure is for Problem 12-7. ,NA,NA
Go to book index,http://www.cs.nps.navy.mil/people/faculty/rowe/book/errata.html (3 of 3) [23/04/2002 17:40:04],NA
