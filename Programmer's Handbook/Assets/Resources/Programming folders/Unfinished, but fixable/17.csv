Larger Text,Smaller Text,Symbol
"Bradley Kjell, Central Connecticut State University",NA,NA
"Revised Draft, June 2002",NA,NA
T,NA,NA
his is a course in assembly language ,NA,NA
programming of the MIPS processor. It ,NA,NA
emphasizes the topics needed for study of ,NA,NA
computer architecture,NA,NA
:,NA,NA
" bits, bit patterns, ",NA,NA
"operations on bit patterns, and how bit patterns ",NA,NA
represent instructions and data. This course is ,NA,NA
equivalent to a semester-long junior college or ,NA,NA
"university course (except, perhaps, for the ",NA,NA
emphasis on bit patterns). ,NA,NA
The only equipment you need for this course is a ,NA,NA
PC. The only software you need is the SPIM ,NA,NA
"simulator of the MIPS R2000 processor, and a ",NA,NA
text editor. The simulator is available by free ,NA,NA
download (see appendix A). Example programs ,NA,NA
are presented using an MS Windows operating ,NA,NA
"system. However, you can use any platform that ",NA,NA
runs SPIM. (There are many). ,NA,NA
A,NA,NA
ssembly Language is normally taken the ,NA,NA
semester after a course in a high level ,NA,NA
programming language (such as Java or C). This ,NA,NA
"course assumes that you have this background, ",NA,NA
although no specific programming language is ,NA,NA
required. ,NA,NA
Read the pages of this course ,NA,NA
actively,NA,NA
. Think ,NA,NA
about and answer the question at the bottom of ,NA,NA
each page. (This style of tutorial is called ,NA,NA
programmed learning,NA,NA
. It is very effective for ,NA,NA
technical material). Most questions call for just a ,NA,NA
little thought. Some call for pencil and paper. ,NA,NA
Keep a pencil and a scrap of paper next to your ,NA,NA
keyboard. Each chapter is about 15 pages long. ,NA,NA
Spend several minutes per page. You can read ,NA,NA
each chapter in about 30 minutes. ,NA,NA
Works best with IE 5.0 at 800 by 600 ,NA,NA
Part 1: Prelude to Assembly Language,NA,NA
A,NA,NA
ssembly language,NA,NA
:,NA,NA
" what it is, why it is studied, and where it is used. ",G,NA
Chapter 1,NA,NA
 — Computer Architecture and Assembly Language. ,G,NA
Chapter 2,NA,NA
 — Analog and Binary Signals. ,G,NA
Chapter 3,NA,NA
 — Bits and Bit Patterns. ,http://chortle.ccsu.edu/AssemblyTutorial/tutorialContents.html (1 of 4) [7/8/2545 18:08:56],NA
Chapter 4,NA,NA
 — Computer Organization. ,NA,NA
Part 2: Data Representation,NA,NA
D,NA,NA
ata,:,NA
 characters and integers. The ,NA,NA
binary addition algorithm,NA,NA
. ,G,NA
Chapter 5,NA,NA
 — Characters. ,G,NA
Chapter 6,NA,NA
 — Number Representation ,G,NA
Chapter 7,NA,NA
 — Binary and Hex Representation.   ,NA,NA
Flash Cards ,G,NA
Chapter 8,NA,NA
 — Binary Addition and Two's Complement Representation. ,NA,NA
Part 3: Running SPIM; Bitwise Logic,NA,NA
R,NA,NA
unning SPIM. MIPS programming. Bitwise logic operations. ,G,NA
Chapter   9,NA,NA
 — A Simple SPIM Program. ,G,NA
Chapter 10,NA,NA
 — MIPS Programming Model ,G,NA
Chapter 11,NA,NA
 — Bitwise Logic with Immediate Operands ,G,NA
Chapter 12,NA,NA
 — Shift Instructions and Logic Instructions ,NA,NA
Part 4: Integer Arithmetic and Memory Access,NA,NA
I,NA,NA
nteger arithmetic. Moving data to and from memory. ,G,NA
Chapter 13,NA,NA
 — Integer Addition and Subtract Instructions ,G,NA
Chapter 14,NA,NA
" — Integer Multiplication, Division, and Arithmetic Shift ",G,NA
Chapter 15,NA,NA
 — Memory Access,:,NA
 Loading and Storing Registers ,G,NA
Chapter 16,NA,NA
 — More Memory Access: Bytes and Halfwords ,NA,NA
"Part 5: Branches, Decisions, and Loops",NA,NA
P,NA,NA
rogram flow,:,NA
" branch, jump, and set instructions; loops, and decisions. ",G,NA
Chapter 17,NA,NA
 — Jump and Branch Instructions ,http://chortle.ccsu.edu/AssemblyTutorial/tutorialContents.html (2 of 4) [7/8/2545 18:08:56],NA
Chapter 18,NA,NA
 — Set Instructions and more Branch Instructions ,G,NA
Chapter 19,NA,NA
 — Structured Programming ,G,NA
Chapter 20,NA,NA
 — Loop and Branch Examples ,NA,NA
Part 6: Extended Assembly Language,NA,NA
T,NA,NA
he assembler extends bare machine language. Registers have mnemonic names. ,NA,NA
Pseudoinstructions ,NA,NA
extend the bare hardware. ,G,NA
Chapter 21,NA,NA
 — Pseudoinstructions and the Pseudocomputer ,G,NA
Chapter 22,NA,NA
 — The SPIM Trap Handler ,G,NA
Chapter 23,NA,NA
 — Instructions for Bitwise Logic and Math ,G,NA
Chapter 24,NA,NA
" — Branch Instructions, Set Instructions, and Indexed Addressing",NA,NA
Part 7: The Stack and Subroutine Linkage,G,NA
Chapter 25 ,NA,NA
— The Run-time Stack ,G,NA
Chapter 26,NA,NA
 — Simple Subroutine Linkage ,G,NA
Chapter 27 ,NA,NA
— Stack-based Calling Convention ,G,NA
Chapter 28 ,NA,NA
"— Frame-based Calling Convention, Variables, and Recursion ",NA,NA
Part 8: Floating Point Data,G,NA
Chapter 29 ,NA,NA
— Binary Fractions ,G,NA
Chapter 30 ,NA,NA
— IEEE 754 Floating Point ,G,NA
Chapter 31,NA,NA
 — Floating Point Arithmetic on MIPS ,G,NA
Chapter 32 ,NA,NA
— Floating Point Comparison Instructions ,NA,NA
Part 9: Data Structures in Assembly Language.,G,NA
Chapter 33,NA,NA
 — Future Work. ,G,NA
Chapter 34,NA,NA
 — Future Work. ,G,NA
Chapter 35,NA,NA
 — Future Work. ,G,NA
Chapter 36,NA,NA
 — Future Work. ,http://chortle.ccsu.edu/AssemblyTutorial/tutorialContents.html (3 of 4) [7/8/2545 18:08:56],NA
Appendices,G,NA
Appendix A,NA,NA
 — Downloading and Installing SPIM ,G,NA
Appendix B,NA,NA
 — Register Use Chart ,G,NA
Appendix C,NA,NA
 — MIPS Assembly Instructions ,G,NA
Appendix D,NA,NA
 — MIPS Machine Language Format ,G,NA
Appendix E ,NA,NA
— Binary Addition Calculator (Java applet) ,G,NA
Appendix F ,NA,NA
— ASCII Chart ,G,NA
Appendix G ,NA,NA
— SPIM Trap Handler Services ,NA,NA
Index,G,NA
Index,NA,NA
 Main Tutorial Menu ,http://chortle.ccsu.edu/AssemblyTutorial/tutorialContents.html (4 of 4) [7/8/2545 18:08:56],NA
CHAPTER 1 — INTRODUCTION,NA,NA
This is a tutorial in assembly language for the MIPS R2000 processor chip using the SPIM ,NA,NA
simulator. Assembly language is used to write programs in terms of the basic operations of a ,NA,NA
processor. The ,NA,NA
architecture,NA,NA
 of a computer is a logical description of its components and its ,NA,NA
"basic operations. In ""pure"" assembly language the architecture of the processor chip is ",NA,NA
clearly visible: one assembly language statement corresponds to one basic operation of the ,NA,NA
processor. With assembly language the programmer is clearly aware of the processor that ,NA,NA
will run the program. ,NA,NA
"""Pure"" assembly language is rare. Usually, for programmer convenience, assembly ",NA,NA
language is ,NA,NA
extended,NA,NA
 with statements that correspond to several basic machine operations. ,NA,NA
"MIPS assembly language does this, but the processor chip is still visible. Programs in high ",NA,NA
level languages such as C or Pascal are (mostly) independent of the processor they run on. ,NA,NA
The processor is not visible in the language. This chapter starts out a tour of assembly ,NA,NA
language. ,NA,NA
Chapter Topics:,G,NA
The Basic Computer Cycle.,G,NA
Machine Instructions.,G,NA
Machine Language.,G,NA
Assembly Language.,G,NA
Language Translation.,G,NA
Emulation.,G,NA
Object Modules and Load Modules. ,G,NA
Separate Assembly.,NA,NA
QUESTION 1:,NA,NA
Do all processor chips have the same architecture? ,NA,NA
Do all processor chips have the same architecture? ,NA,NA
A good answer might be: ,NA,NA
"No. Each family of processor chip (MIPS, PIC, SPARC, Alpha, Motorola, Intel, et al.) has ",NA,NA
its own architecture. ,NA,NA
Different Processor Architectures,NA,NA
The ,NA,NA
architecture,NA,NA
 of a computer is a description of its ,NA,NA
components and its operations. ,NA,NA
Each processor family has its own architecture. ,NA,NA
Assembly language is a programming view of the ,NA,NA
architecture of a processor. So each type of processor ,NA,NA
has its own assembly language. ,NA,NA
"When you study an assembly language, you study the ",NA,NA
architecture of a particular processor. The study of any ,NA,NA
assembly language increases your professional ,NA,NA
understanding of computers These notes are about the ,NA,NA
"MIPS processor, which is a nice processor to study. The ",NA,NA
concepts in MIPS assembly are universal. ,NA,NA
These notes discuss assembly language from a computer science perspective. They ,NA,NA
explain what is going on in a computer system at the ,NA,NA
assembly language level,NA,NA
. This is a ,NA,NA
"view that is above the electronic view of computer architecture, but is below the operating ",NA,NA
systems view of the computer system. Computer scientists understand computers at many ,NA,NA
levels. They understand how the many levels are built one on top of another. Each of these ,NA,NA
levels corresponds to one or more courses in a computer science degree program. ,NA,NA
QUESTION 2:,NA,NA
(Rhetorical) Does your understanding of computers depend on which ,NA,NA
assembly language you study? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_2.html [7/8/2545 18:09:16],NA
A good answer might be: ,NA,NA
"No. Probably a well-designed modern assembly language is best, but any one is OK. ",NA,NA
Fundamentals,NA,NA
The MIPS architecture is modern and well-designed. MIPS chips were designed from the ,NA,NA
ground up in 1985. The design includes the best ideas of computer architecture. ,NA,NA
"An assembly language program describes exactly what the hardware should do, step by ",NA,NA
"step, in terms of the basic operations of the computer. In a high level programming ",NA,NA
language like C or Java a programmer is mostly unaware of computer architecture. The ,NA,NA
same source program can run (after compiling) on any processor family. ,NA,NA
These notes are about fundamental assembly-level computer architecture. To do this ,NA,NA
"effectively, it is necessary (in my view) to acutally learn the assembly language and details of ",NA,NA
"a particular processor, and to write programs for it. This is somewhat like those ",NA,NA
experiments you did in high school chemistry. Their goal was to teach you the fundamentals ,NA,NA
"of chemistry, not to teach you how to make test tubes full of colorful water. But without the ",NA,NA
"colorful experiments your understanding of chemistry might remain abstract and vague, and ",NA,NA
would soon be forgotten. ,NA,NA
QUESTION 3:,NA,NA
At the time of this writing (Spring 2001) tens of thousands of dot.com ,NA,NA
workers have been laid off. ,NA,NA
1.  How many of them were making car payments on a Jaguar? ,NA,NA
2.  How many of them knew assembly language?,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_3.html [7/8/2545 18:09:25],NA
A good answer might be:,NA,NA
1.  How ,NA,NA
payments ,NA,NA
on a ,NA,NA
Jaguar? ,H,NA
Must Sell! Make Offer! ,NA,NA
many of ,NA,NA
them were ,NA,NA
making ,NA,NA
car ,NA,NA
Many of them.,NA,NA
2.  How many of them knew assembly language? ,H,NA
Few of them.,NA,NA
Employment is still strong for computer scientists. It is weak for technicial workers. The ,NA,NA
used car lots of Silicon Valley are full of repossessed Jaguars (according to a recent ,NA,NA
news story). ,NA,NA
Basic Machine Cycle,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_4.html (1 of 2) [7/8/2545 18:09:41],NA
Most processors endlessly repeat three basic steps. Each ,NA,NA
machine ,NA,NA
cycle,NA,NA
 results in the execution of one ,NA,NA
machine instruction,NA,NA
. A modern ,NA,NA
processor performs millions of machine cycles per second. ,NA,NA
A ,NA,NA
machine instruction,NA,NA
 is a pattern of bits that corresponds to a ,NA,NA
"fundamental operation of the processor, such as adding two 32-bit ",NA,NA
"integers together, or testing if a value is zero. The details of the ",NA,NA
machine cycle differ between processor families. The machine cycle ,NA,NA
of most processor chips looks like the following: ,NA,NA
Fetch the Instruction.,NA,NA
 The ,NA,NA
program counter,NA,NA
 (PC) is part of the ,NA,NA
processor. It holds the address of the instruction. The machine ,NA,NA
instruction is fetched from memory. ,NA,NA
Increment the Program Counter.,NA,NA
 The program counter now ,NA,NA
holds the address of the next instruction. ,NA,NA
Execute the Instruction.,NA,NA
 The operations specified by the current machine ,NA,NA
instruction are performed. ,NA,NA
QUESTION 4:,NA,NA
In what order are machine instructions executed by the basic machine cycle? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_4.html (2 of 2) [7/8/2545 18:09:41],NA
In what order are machine instructions executed by the basic machine cycle? ,NA,NA
A good answer might be: ,NA,NA
Sequential order. ,NA,NA
Machine Instructions,NA,NA
Instructions are normally executed in sequential order. Program loops and branches require ,NA,NA
"machine instructions that alter the normal sequence. Operations like ""add two integers"" and ",NA,NA
"""compute bit-wise or"" are operations that a processor does in one machine cycle. ",NA,NA
A machine instruction is a pattern of bits that directs the processor to perform one machine ,NA,NA
operation. Here is the machine instruction that directs the MIPS processor to add two 32-bit ,NA,NA
registers together (a register is a part of the processor that can hold a bit pattern). ,NA,NA
0000 0001 0010 1011 1000 0000 0010 0000,NA,NA
The instruction is 32 bits long. Each bit is 0 or 1. When bit patterns are displayed in a book ,NA,NA
"they are usually shown in groups of four (as here). Of course, the spaces are a convention ",NA,NA
of printing and don't really exist as part of the bit pattern. ,NA,NA
"Some of the bits in the instruction specify the operation (adding two registers), other bits ",NA,NA
specify which two registers to add. A few more bits say were to put the result. ,NA,NA
QUESTION 5:,NA,NA
Inspect the instruction. Is it clear what the bits of the instruction mean? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_5.html [7/8/2545 18:09:47],NA
Is it clear what the bits mean? ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
Assembly Language Statement,NA,NA
The layout of a machine instruction is part of the architecture of a processor chip. Without ,NA,NA
"knowing the layout you can't tell what the instruction is. Even if you know the layout, it is ",NA,NA
"hard to remember what the patterns mean and hard to write machine instructions ""by hand"". ",NA,NA
A statement in pure assembly language corresponds to one machine instruction. Assembly ,NA,NA
language is much easier to write than machine code. Here is the previous machine ,NA,NA
instruction and the assembly language that it corresponds to: ,NA,NA
machine instruction                             assembly statement ,NA,NA
"0000 0001 0010 1011 1000 0000 0010 0000         add $t0,$t1,$t3",NA,NA
The instruction means: add the integers in registers T1 and T2 and put the result in register ,NA,NA
T0. To create the machine instruction from the assembly language statement a translation ,NA,NA
program called an ,NA,NA
assembler,NA,NA
 is used. ,NA,NA
Humans find assembly language easier to use than machine language for many reasons. ,G,NA
It is hard for humans to keep track of those ones and zeros.,G,NA
By using symbols programmers gain flexibility in describing the computation. ,G,NA
Assembly language is a compact notation.,NA,NA
Enhanced,NA,NA
 assembly language includes additional convenience features. It has instructions ,NA,NA
(called ,NA,NA
pseudoinstructions,NA,NA
) that correspond to several machine instructions. Often a ,NA,NA
macroprocessor,NA,NA
 is used to add even more features. ,NA,NA
QUESTION 6:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_6.html (1 of 2) [7/8/2545 18:09:49],NA
"Once you know assembly language, is it hard to write an assembly language ",NA,NA
statement? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_6.html (2 of 2) [7/8/2545 18:09:49],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Program Translation,NA,NA
The assembly language statement says the same thing as the machine language ,NA,NA
"instruction, but must be translated before it can be used. An assembly language ",NA,NA
program ,NA,NA
"consists of assembly language statements, statements that define data, and some ",NA,NA
additional information that helps in the translation. Here is a fragment of an assembly ,NA,NA
language program and its translation into bit patterns. ,NA,NA
machine instructions                             assembly statements,NA,NA
"0011 0100 0000 0001 0000 0000 0000 1001          ori  $1, $0, 9 ",NA,NA
"0000 0000 0100 0001 0000 0000 0001 1000          mult $2, $1 ",NA,NA
0000 0000 0000 0000 0100 0000 0001 0010          mflo $8 0011 ,NA,NA
"0100 0000 0001 0000 0000 0000 1001          ori  $1, $0, 5 0000 ",NA,NA
"0000 0100 0000 0000 0000 0100 1000          div  $8, $1",NA,NA
"Years ago, to run a program written in FORTRAN you used a compiler to translate the ",NA,NA
program into assembly language. Then you used an assembler to translate the assembly ,NA,NA
"language into machine language. Finally, you loaded the machine language into the ",NA,NA
computer's memory and executed your program. ,NA,NA
Modern compilers usually translate a source program directly into machine language which ,NA,NA
is contained in a file called an ,NA,NA
object module,NA,NA
 (more on this later). But for now let us think ,NA,NA
about translating FORTRAN into assembly language. ,NA,NA
"FORTRAN is a high level language. It is intended to run on all types of computers, ",NA,NA
regardless of architecture. FORTRAN statements can be written without knowing the ,NA,NA
"architecture of the computer, and can be run on any computer (after translation). ",NA,NA
QUESTION 7:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_7.html (1 of 2) [7/8/2545 18:09:59],NA
"Do you think that languages such as COBOL, C, and Pascal are translated ",NA,NA
like FORTRAN? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_7.html (2 of 2) [7/8/2545 18:09:59],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Several Translations,NA,NA
All programming languages other than machine language must be translated before they ,NA,NA
"can be executed. A high level language is independent of architecture, but it requires a ",NA,NA
"specific translator (compiler) for each architecture. The more modern the language, the ",NA,NA
more distant the source code is from the machine language. FORTRAN is old and is closer ,NA,NA
to machine language than most languages. Here is a statement in FORTRAN: ,NA,NA
result = 6*alpha+beta,NA,NA
Here is a translation of that statement into MIPS assembly language: ,NA,NA
"lw $t0,alpha            # copy alpha to register T0 ",NA,NA
"lw $t1,beta             # copy beta  to register T1 ",NA,NA
"mul $t2,$t0,6           # multiply T0 times 6; result in T2 ",NA,NA
"add $t2,$t2,$t1         # add T2 and T1; result in T2 sw  ",NA,NA
"$t2,result          # copy answer to result",NA,NA
Here is a translation of that statement into Digital Equipment Corporation VAX assembly ,NA,NA
language: ,NA,NA
"MULL3   #6,ALPHA,R5 ",NA,NA
"ADDL3   R5,BETA,RESULT",NA,NA
QUESTION 8:,NA,NA
Is the architecture of the VAX similar to that of MIPS? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_8.html [7/8/2545 18:10:24],NA
A good answer might be: ,NA,NA
No. The two machines are very different. ,NA,NA
Machine Language,NA,NA
"There is not just one language called ""assembly language."" Each assembly language is for ",NA,NA
one type of processor only. MIPS assembly language is only for MIPS processors. The VAX ,NA,NA
assembly language is only for VAX processors. There is a different assembly language for ,NA,NA
"IBM mainframe computers, and others for Intel-based PCs. ",NA,NA
Assembly language describes computations ,NA,NA
in terms of the hardware ,NA,NA
of a particular ,NA,NA
processor. A high level computer programming language (ideally) describes computations ,NA,NA
in ,NA,NA
terms of the problem being solved ,NA,NA
". Since there are many types problems, there are many ",NA,NA
"high level languages, each designed for particular types of problems. For example, object-",NA,NA
"oriented languages, describe computations in terms of the objects of the problem and ",NA,NA
operations with them. ,NA,NA
It is much easier to program a computer in a high level language than in assembly ,NA,NA
"language, especially when the programming language matches the problem. There will ",NA,NA
never be a universal programming language since no one language is best for all problems. ,NA,NA
QUESTION 9:,NA,NA
(Hard thought question:) What type of problem is assembly language best ,NA,NA
suited for? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_9.html [7/8/2545 18:10:26],NA
(Hard thought question:) What type of problem is assembly language best suited for? ,NA,NA
A good answer might be: ,NA,NA
Problems that involve the very computer the program is running on. ,NA,NA
Main Storage,NA,NA
Assembly language ,NA,NA
does,NA,NA
 match the problem when the problem is the operation of the ,NA,NA
"computer system. Assembly language is used for operating systems, compilers, ",NA,NA
"communications, low-level graphics, and other programs where the architecture of the ",NA,NA
processor must be visible. Often with these program the crucial parts are written in ,NA,NA
assembly and the rest in a high level language (usually C). The most common use of ,NA,NA
assembly language is in programming ,NA,NA
embedded systems,NA,NA
. Here a processor chip is an ,NA,NA
"integral part of a machine built for a specific purpose. Examples are microwave ovens, VHS ",NA,NA
"players, automobile fuel systems, and game consoles. MIPS chips are commonly used in ",NA,NA
these (and for this reason more MIPS chips are sold each year than any other processor). ,NA,NA
Now let us move on to the memory of a ,NA,NA
computer system. Eight bits make up a ,NA,NA
byte,NA,NA
. A ,NA,NA
bit,NA,NA
 is a single on/off value. Early ,NA,NA
computers had rows of toggle switches ,NA,NA
which were used to set the values of bits ,NA,NA
in main memory. You could ,NA,NA
program these computers by entering ,NA,NA
the bits of each machine instruction. A ,NA,NA
light above each switch showed ,NA,NA
whether it was on or off. Modern ,NA,NA
computers have more convenient ,NA,NA
methods for moving bit patterns into ,NA,NA
memory. ,NA,NA
A Beautiful Computer,NA,NA
The bytes that make up the machine instructions of a program are stored in ,NA,NA
main memory ,NA,NA
and fetched into the processor as needed. Data is also kept in main memory. Keeping both ,NA,NA
data and instructions in main memory is one of the characteristics of a ,NA,NA
Von Neumann ,NA,NA
"machine, the name for the basic design of most modern computers. ",NA,NA
"In the MIPS, as in most computers, each byte of main memory has an address. An address ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_10.html (1 of 2) [7/8/2545 18:10:48],NA
is a integer that uniquely identifies the byte. The addresses run from 0 up to about four ,NA,NA
"billion. However, on the MIPS, user programs and data (such as you will write) are restricted ",NA,NA
to the first two billion addresses. ,NA,NA
QUESTION 10:,NA,NA
It it necessary to install four billion bytes of RAM on a MIPS computer? (Hint: ,NA,NA
the address range of a MIPS is the same as that of a Pentium). ,NA,NA
A good answer might be: ,NA,NA
"No. Both processors have the same range of logical addresses, but there need not be ",NA,NA
actual RAM behind each address. ,NA,NA
Architecture vs. Implementation,NA,NA
The ,NA,NA
architecture,NA,NA
 of a computer is a logical description of its conponents and its basic ,NA,NA
operations. ,NA,NA
The MIPS family of computers all have the same assembly-level architecture. This means ,NA,NA
that all MIPS machines can be programmed using the same assembly language. The actual ,NA,NA
electronics that implement the architecture may differ greatly between versions of the chip. ,NA,NA
"This is analogous to ""car architecture"". Two Jaguars may appear the same to a driver (same ",NA,NA
"styling, same user controls, same operation) but have different components under the hood. ",NA,NA
"The architecture is the same, but the implementation (and performance) is different. Keep ",NA,NA
this in mind as you visit the car lots in Silicon Valley. ,NA,NA
The architecture of a MIPS is different from the architecture of a Pentium. Both are ,NA,NA
"VonNeumann machines, so they look the same in general, but the details of operation are ",NA,NA
"completely different. They have different machine languages, and hence different assembly ",NA,NA
languages. ,NA,NA
QUESTION 11:,NA,NA
(Hard Thought Question:) Must a machine language program be run on an ,NA,NA
"actual processor chip (i.e., on hardware)? Hint: Think about Java. ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_11.html [7/8/2545 18:10:53],NA
A good answer might be: ,NA,NA
No. Sometimes machine instructions (such as Java .class files) are ,NA,NA
interpreted,NA,NA
 by ,NA,NA
software. ,NA,NA
Emulation,NA,NA
"Apple computers can run Microsoft Windows "".exe"" files ",NA,NA
done in electronics. They can be done with software. A program ,NA,NA
that implements a processor's architecture is the logical ,NA,NA
equivalent of an implementation in silicon. Such a program is ,NA,NA
called an ,NA,NA
emulator,NA,NA
. Any computer can run an emulator of any ,NA,NA
"kind of computer. Of course, somebody has to write the emulator, ",NA,NA
and that is difficult. ,NA,NA
The basic flow chart of an emulator program is the machine cycle ,NA,NA
of the emulated processor. But now the steps are implemented in ,NA,NA
(executable files) intended for Intel computers even though these ,NA,NA
This course uses an emulator for the MIPS architecture. Using an emulator has many ,NA,NA
advantages over using the actual hardware. The biggest advantage is that the architecture ,NA,NA
described in these notes will exactly match the architecture implemented by the emulator. ,NA,NA
You can download exactly what you need to use to follow these notes. The emulator runs ,NA,NA
"on most common desktop computers; PC, Mac, or ...   MIPS. ",NA,NA
QUESTION 12:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_12.html (1 of 2) [7/8/2545 18:10:55],NA
Is it possible to run an emulator for a MIPS processor on an actual hardware ,NA,NA
MIPS processor? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_12.html (2 of 2) [7/8/2545 18:10:55],NA
A good answer might be:,NA,NA
Of course. Say that the emulator is written in C. Compile the emulator and run it on a ,NA,NA
MIPS computer. Now the program running on the MIPS is a MIPS emulator. This is a ,NA,NA
very computer-science-like notion. ,NA,NA
Separate Translation,NA,NA
An emulator running on the processor it is emulating is often used for debugging. Working ,NA,NA
with an emulator is usually more convenient than dealing with the hard silicon of the actual ,NA,NA
hardware. ,NA,NA
"A true computer nut (a ""hacker"", in the correct sense) will wonder if an emulator of (say) an ",NA,NA
Apple can run on an emulator of (say) an Intel machine that is running on a MIPS machine. ,NA,NA
"Yes, as long as the various emulators exist. ",NA,NA
For very many years (in computer years) assembly language was used for serious ,NA,NA
enterprise-wide programming for one reason: separate source files could be individually ,NA,NA
"assembled, and later combined (linked) into the full executable. Each source file was ",NA,NA
assembled into an object module. This is called ,NA,NA
separate assembly,NA,NA
 (or ,NA,NA
separate ,NA,NA
translation,NA,NA
). ,NA,NA
An ,NA,NA
object module,NA,NA
 is a file that contains a machine language program that is not quite ready ,NA,NA
to run. It may not be ready to run for several reasons: the source code might not be ,NA,NA
"completely translated (since more information is needed), memory locations for code and ",NA,NA
"data might not be assigned, and more code is needed before the program is complete. An ",NA,NA
assembler creates an object module for each source file of assembly language. ,NA,NA
QUESTION 13:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_13.html (1 of 2) [7/8/2545 18:11:07],NA
(Software Engineering Question:) Why translate many individual source ,NA,NA
"files? Why not have one, big, complete program that translates into a ",NA,NA
"complete, ready-to-run executable? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_13.html (2 of 2) [7/8/2545 18:11:07],NA
A good answer might be:,NA,NA
Enterprise-wide programs are hundreds of thousands of lines long and take hundreds of ,NA,NA
programmers and support staff. It just would not work if they were all working on one big ,NA,NA
monster source program. ,NA,NA
Load Modules,NA,NA
In assembly language the pieces of a big application program can be written as separate ,NA,NA
"source files, and assembled into separate object modules. The separate object modules ",NA,NA
can then be combined by a linker into a ,NA,NA
load module,NA,NA
", an executable file. ",NA,NA
This is how all modern software of any appreciable size is written. The object modules do ,NA,NA
not need to be created from assembly language source. A compiler creates object modules ,NA,NA
"that look the same as those from the assembler. In the picture, object module 1 might be ",NA,NA
"from an assembly program, object module 2 might be from a FORTRAN program, and ",NA,NA
object module 3 might be from a COBOL program. ,NA,NA
"For many years, the only common languages that supported separate translation were ",NA,NA
"Assembly, FORTRAN, and COBOL. For many years, the only common languages used in ",NA,NA
"production were Assembly, FORTRAN, and COBOL. BASIC did not support separate ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-01/ass01_14.html (1 of 2) [7/8/2545 18:11:27],NA
compilation; BASIC was never used for writting big applications. Pascal did not support ,NA,NA
separate compilation; Pascal was never used for writting big applications. C supported ,NA,NA
separate compilation; C is now the dominant language for writting applications. ,NA,NA
QUESTION 14:,NA,NA
C compilers come with libraries of useful functions. The ,NA,NA
standard math ,NA,NA
library ,NA,NA
contains functions like ,NA,NA
sin,NA,NA
", ",NA,NA
cos,NA,NA
", and ",NA,NA
rand,NA,NA
. What do you suppose a ,NA,NA
software library is? ,NA,NA
A good answer might be: ,NA,NA
A library is a collection of object modules which can be linked to the object module of ,NA,NA
your program. ,NA,NA
End of the Chapter,NA,NA
You may wish to review the following terms. Click on the hypertext phrase to link to the the ,NA,NA
"lesson where the term was discussed. To return to this list, use the ""back arrow"" on your ",NA,NA
web browser. ,G,NA
Computer architecture ,G,NA
The basic ,NA,NA
"machine cycle,",NA,NA
 and machine instructions. ,G,NA
Assembly language ,G,NA
Pseudoinstructions.,G,NA
Program translation ,G,NA
Main Memory.,G,NA
Uses,NA,NA
 of assembly language ,G,NA
Emulation,NA,NA
 of a processor. ,G,NA
Object modules,NA,NA
 and separate assembly. ,G,NA
Load modules,NA,NA
CHAPTER 2 — Analog and Binary ,NA,NA
Signals,NA,NA
Note: ,NA,NA
This is a copy of chapter 2 of the on-line java tutorial located ,NA,NA
at ,NA,NA
http://chortle.ccsu.edu,NA,NA
". If some of this is new, you might benefit ",NA,NA
from reading the first four chapters of that tutorial. ,NA,NA
"Everyone knows that computers are ""digital"" and that they use ",NA,NA
"""binary"" numbers. You probably have some idea of what these ",NA,NA
terms mean. But we need to be clear about their precise meaning ,NA,NA
and to be clear about why computers ,NA,NA
are,NA,NA
 digital. ,NA,NA
Chapter Topics:,G,NA
Binary signals. ,G,NA
Analog signals. ,G,NA
Advantages of Binary. ,G,NA
Bits. ,G,NA
Noisy signals. ,NA,NA
Study these topics carefully if you want to know what is really going on with computers. ,NA,NA
QUESTION 1:,NA,NA
"Why is a digital wristwatch called ""digital?"" ",NA,NA
A good answer might be: ,NA,NA
"Because it shows time using definite digits, rather than positions of hands that have to ",NA,NA
"be measured. (It would be less correct to say ""because it has a computer inside."") ",NA,NA
Binary,NA,NA
Binary,NA,NA
" means ""two states."" The two states are sometimes called ""1"" and ""0"", or called ""true"" ",NA,NA
"and ""false"", or called ""on"" and ""off"", (or other names.) The essential characteristic is that a ",NA,NA
single binary device can be in just one of two possible states. ,NA,NA
A ,NA,NA
bit,NA,NA
" is a single ""on/off"" value. ",NA,NA
"A good example is a toggle switch, such as a light switch. You can turn it ""on"" or ""off"" but ",NA,NA
not (in normal operation) anything else. A light switch holds one bit of information. ,NA,NA
"A light dimmer is not a binary device: it has many positions between ""off"" and ""fully on"". If ",NA,NA
"you want a light dimmer in to be set to 25%, you must carefully adjust it. ",NA,NA
QUESTION 2:,NA,NA
Which of the following is a binary device: ,G,NA
The ignition switch of an automobile. ,G,NA
The hour hand of a clock.,G,NA
A button on a hand calculator. ,G,NA
The volume control on a stereo.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_2.html [7/8/2545 18:12:03],NA
A good answer might be:,G,NA
The ignition switch of an automobile.  ,NA,NA
No ,G,NA
The hour hand of a clock.  ,NA,NA
No ,G,NA
A button on a hand calculator.  ,NA,NA
Yes ,G,NA
The volume control on a stereo.  ,NA,NA
No,NA,NA
Why Computers use Binary,NA,NA
The ignition switch of an automobile is ,NA,NA
discrete,NA,NA
—it has definite states—but there are ,NA,NA
These characteristics of binary were realized by ,NA,NA
"Claude Shannon, a mathematician at Bell ",NA,NA
1.  Simple; easy to build.,NA,NA
2.  Unambiguous signals (hence noise ,NA,NA
3.  Flawless copies can be made. ,NA,NA
4.  Anything that can be represented ,NA,NA
immunity).,NA,NA
with some sort of pattern can be represented with patterns of bits.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_3.html (1 of 2) [7/8/2545 18:12:28],NA
QUESTION 3:,NA,NA
Which is easier to build: ,G,NA
An on/off switch. ,G,NA
A light dimmer.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_3.html (2 of 2) [7/8/2545 18:12:28],NA
A good answer might be: ,G,NA
An on/off switch.,NA,NA
Advantages of Binary 1: Simple; easy to ,NA,NA
build,NA,NA
An on/off switch is simple and ,NA,NA
an on/off switch and must be ,NA,NA
carefully assembled. An ,NA,NA
accurate dimmer (where 25% ,NA,NA
means ,NA,NA
exactly,NA,NA
 25%) is even ,NA,NA
harder to build. ,NA,NA
The same is true for the tiny devices inside of a silicon chip. On/off switches are relatively ,NA,NA
easy to build. An on/off switch ,NA,NA
moves two pieces of metal ,NA,NA
QUESTION 4:,NA,NA
Which of the following methods for producing books is simple and easy? ,G,NA
Each book is individually made by scratching marks onto tablets of wet ,NA,NA
clay.,G,NA
Each book is individually made by copying the characters onto paper with pen and ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_4.html (1 of 2) [7/8/2545 18:12:34],NA
ink.,G,NA
Many copies of the book are made by carving flat wooden blocks with the text then ,NA,NA
printing the text on paper.,G,NA
Many copies of the book are made by setting movable type and printing the text on ,NA,NA
paper.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_4.html (2 of 2) [7/8/2545 18:12:34],NA
A good answer might be: ,G,NA
Setting type.,NA,NA
Advantages of Binary 2: Unambiguous ,NA,NA
Signals,NA,NA
Carving a block of wood into a book page requires high technical and artistic skill. The task ,NA,NA
is complex and labor intensive. A small mistake might ruin the whole block. The ,NA,NA
Renaissance woodcarvers were as skilled as woodcarvers ever have been. ,NA,NA
Setting type is comparatively easy. Little artistic or technical skill is needed. Individual ,NA,NA
pieces of type are just dropped into place. The method is robust and reliable; mistakes can ,NA,NA
be corrected. The type can be reused many times. ,NA,NA
It is a paradox that advances in technology often lead to simple methods. Woodcarving is ,NA,NA
complex; setting type is easy. The computer revolution (ca. 1950—) is often compared to ,NA,NA
the Gutenberg revolution (ca. 1450—). ,NA,NA
Review the advantages of binary: ,NA,NA
1.  Simple; easy to build.,NA,NA
2.  Unambiguous signals (hence noise immunity).,NA,NA
3.  Flawless copies can be made.,NA,NA
4.  Anything that can be represented with patterns can be represented with ,NA,NA
patterns of bits.,NA,NA
QUESTION 5:,NA,NA
"Which is easier to do: (a) determine exactly how bright a light is, or (b) ",NA,NA
decide if it is on or off? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_5.html [7/8/2545 18:12:39],NA
A good answer might be: ,NA,NA
On or Off. ,NA,NA
Old North Bit,NA,NA
Unambigous Signals:,NA,NA
" Consider Paul Revere, ",NA,NA
waiting for news of the attack of the British troops. ,NA,NA
He is expecting to see a signal lantern in the tower ,NA,NA
of Old North Church telling him how the British are ,NA,NA
attacking: ,NA,NA
"1.32456 if by land, 1.71922 if by sea. ",NA,NA
The signal shines out! ...and Paul Revere's famous ,NA,NA
ride is delayed for several hours as he tries to figure ,NA,NA
out just how bright that signal is. ,NA,NA
Lack of ambiguity is a tremendous advantage. The ,NA,NA
signal that Paul Revere was actually waiting for that ,NA,NA
night in 1775 was: ,NA,NA
"One (lantern) if by land, and two (lanterns) if by ",NA,NA
sea. ,NA,NA
...an easily interpreted signal. All Paul Revere had to do was count. Such signals are called ,NA,NA
discrete,NA,NA
 because they have a fixed number of definite states. Sometimes the word ,NA,NA
digital ,NA,NA
is used to mean the same thing. ,NA,NA
QUESTION 6:,NA,NA
"Why can a Chinese abacus be regarded as a ""digital computer."" ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_6.html [7/8/2545 18:12:44],NA
A good answer might be:,NA,NA
The computation is done by moving beads into definite positions. A bead is either placed ,NA,NA
"where it counts as part of a number, or it is placed where it does not count. This ""all or ",NA,NA
"nothing"" operation means that an abacus is a discrete device. ",NA,NA
An Analog Signal,NA,NA
An ,NA,NA
analog signal,NA,NA
 may continuously change in value. Its values can be anything within a ,NA,NA
"range of values, and its exact value at any time is important. The graph below represents an ",NA,NA
audio signal. The exact value at each time is part of the information it contains. For ,NA,NA
"example, the value at time ""T2"" must be measured exactly. ",NA,NA
Now say that you are observing the voltage of a wire. It has been agreed that any voltage ,NA,NA
below a ,NA,NA
threshold,NA,NA
" will be counted as an ""off"" signal, and that any value above the threshold ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_7.html (1 of 2) [7/8/2545 18:12:50],NA
"will be counted as an ""on"" signal. ",NA,NA
QUESTION 7:,NA,NA
"At time ""T2"", is the signal ""on"" or ""off""? ",NA,NA
A good answer might be: ,NA,NA
"ON. The analog signal (continuously changing voltage signal) moves up and down, but ",NA,NA
"at time ""T2"" it is clear that it is above the threshold. Exact measurement is not needed. ",NA,NA
Binary Signal,NA,NA
"Analog signals continuously change in value. By using a threshold, analog signals can ",NA,NA
"represent binary data (""on/off"" data). It is easy and fast (for electronics, as well as for ",NA,NA
humans) to determine if a voltage is above or below a threshold. The figure shows a signal ,NA,NA
"that transmits ""off"" then ""on"". (The signal is examined at times T1 and T2.) ",NA,NA
QUESTION 8:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_8.html (1 of 2) [7/8/2545 18:12:58],NA
"Is is clear that the signal is ""off"" at time T1 and ""on"" at time T2? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_8.html (2 of 2) [7/8/2545 18:12:58],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Imperfect Transmission,NA,NA
"The ""ons"" and ""offs"" of previous signal are clear. ",NA,NA
end of the wire. ,NA,NA
"Even though the signal is noisy (at the analog level), the binary values are transmitted ",NA,NA
perfectly. ,NA,NA
But what if the signal is sent down a long wire and ,NA,NA
someone nearby turns on a vacuum ,NA,NA
cleaner? The graph shows the signal at the other ,NA,NA
You (and the electronics) can still tell that at time ,NA,NA
"T1 the signal represents ""off"" and that at time T2 the signal represents ""on"" The receiving ",NA,NA
end just needs to get the binary values. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_9.html (1 of 2) [7/8/2545 18:13:06],NA
"Since only the ""on"" ""off"" information matters, the analog noise is irrelevant, and the original ",NA,NA
signal is received perfectly (so far as the binary information goes.) ,NA,NA
QUESTION 9:,NA,NA
"If the signal were regarded as an analog signal, and exact values were ",NA,NA
"important, would some information present in the first signal (before the ",NA,NA
noise) have been lost? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_9.html (2 of 2) [7/8/2545 18:13:06],NA
A good answer might be: ,NA,NA
"Yes—if the signals represented a singer's voice, the noisy signal would sound, er.. ",NA,NA
"well... noisy. After just one copy, information has been lost. ",NA,NA
Advantages of Binary 3: Flawless copies ,NA,NA
can be made.,NA,NA
Review the advantages of binary: ,NA,NA
1.  Simple; easy to build.,NA,NA
2.  Unambiguous signals (hence noise immunity).,NA,NA
3.  Flawless copies can be made.,NA,NA
4.  Anything that can be represented with some sort of pattern can be ,NA,NA
represented with patterns of bits.,NA,NA
Flawless copies can be made:,NA,NA
 The receiving end of the signal is only interested in the ,NA,NA
binary values. All it has to do it check if the signal is above or below the threshold. This can ,NA,NA
"be done perfectly (as long as the noise is not too great.) For example, here is the noisy ",NA,NA
"signal with the ""on""/""off"" values recovered from it: ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_10.html (1 of 2) [7/8/2545 18:13:13],NA
The original signal has been recovered flawlessly. This process can occur as many times as ,NA,NA
"needed with a perfect copy made each time. This is essential in a computer system, where ",NA,NA
"bit patterns (patterns of one and zero, or on and off) are copied back and forth between the ",NA,NA
processor and memory millions of times a second. The copies have to be perfect. ,NA,NA
QUESTION 10:,NA,NA
"Something might be wrong here. Is the signal is ""on"" or ""off"" at the time ""x""? ",NA,NA
"This is not easy to tell. What is worse, a different amount of noise changes ",NA,NA
the answer. What can be done about this problem? (Hint: must the value of ,NA,NA
the signal be known at all times?) ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_10.html (2 of 2) [7/8/2545 18:13:13],NA
A good answer might be: ,NA,NA
"The system is built so that the signal is tested only at particular times, and that changes ",NA,NA
in the signal occur between these times. ,NA,NA
Clocks,NA,NA
"Digital systems are built so that the ""on"" ""off"" (binary) value is only tested at certain times, ",NA,NA
"giving the wire (or transistor, or...) a chance to change its state between these times. This is ",NA,NA
"why computer systems have a ""clock"" — to keep all these times synchronized. So faster ",NA,NA
"clocks mean wires can be tested more times per second, and the whole system runs faster. ",NA,NA
Processor chips (and the computers that contain them) are often described in terms of their ,NA,NA
clock speed. Clock speed is measured in ,NA,NA
Hertz,NA,NA
", where one Hertz is one clock tick per ",NA,NA
second. The symbol ,NA,NA
MHz,NA,NA
 means ,NA,NA
mega Hertz,NA,NA
", a million clock ticks per second. ",NA,NA
A 700 MHz Pentium processor checks binary values 700 million times in each second. In ,NA,NA
between these times values are allowed to change and settle down. The faster a processor ,NA,NA
"chip is, the more times per second values can be tested, and the more decisions per second ",NA,NA
can be made. ,NA,NA
QUESTION 11:,NA,NA
"Which is faster, a 400 MHz Pentium processor or a 800 MHz Pentium ",NA,NA
processor? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_11.html [7/8/2545 18:13:16],NA
A good answer might be:,NA,NA
"The 800 MHz processor, since it checks values 800 million times per second (twice as ",NA,NA
many as the 400 MHz processor). ,NA,NA
"(However, if the processors are different types there are other factors besides clock ",NA,NA
speed that determine how much each processor can do in a second.) ,NA,NA
Advantages of Binary Representation 4: ,NA,NA
Representing Anything,NA,NA
Recall that last advantage of binary: ,G,NA
Anything that can be represented with patterns can be represented with patterns of bits.,NA,NA
Since data of all kinds is stored in computer memory (main and secondary) using the same ,NA,NA
"electronic methods, this means that endless perfect copies can be made of any type of data ",NA,NA
or program. ,NA,NA
This idea is that any system of symbols can be translated into bit patterns. An example is ,NA,NA
how English characters are represented as eight-bit patterns. The agreeement about what ,NA,NA
patterns represent what characters is called ASCII. The hardware and the software of a ,NA,NA
"computer system (usually) follow this agreement when the data is ""text"". (You will learn more ",NA,NA
about this later). Other types of data (non-character data) are represented using other ,NA,NA
methods. ,NA,NA
QUESTION 12:,NA,NA
Can charaters from alphabets other than English be represented? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_12.html [7/8/2545 18:13:20],NA
A good answer might be: ,NA,NA
Of course. Any type of symbol at all can be assigned a binary pattern to represent it. ,NA,NA
More on Representing Anything in Binary,NA,NA
"Japanese and Chinese characters, also, have been translated into bit patterns, and ",NA,NA
computers can manipulate those symbols just as easily as ASCII. Unicode is an agreement ,NA,NA
created by an international committee on how to represent characters using 16 bits. Here ,NA,NA
are 16 bits 111110011111110 and here is the character it represents in Unicode: ,NA,NA
Say that the international committee decides to represent a new Chinese character. How ,NA,NA
can they do this? Easy: they find a bit pattern not yet used to represent any symbol and ,NA,NA
assign the new character to that pattern. ,NA,NA
The correspondence between human language symbols and bit patterns is arbitrary. All you ,NA,NA
have to do is be sure that you are using enough bits so that all the symbols of the language ,NA,NA
have a unique bit pattern to represent them. ,NA,NA
QUESTION 13:,NA,NA
Can printed music be represented using binary? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_13.html [7/8/2545 18:13:25],NA
A good answer might be: ,NA,NA
"Sure — any symbols can. There are ""music processor"" programs for printed music that ",NA,NA
work like word processor programs for printed text. ,NA,NA
Symbols and Patterns,NA,NA
Recall that last advantage of binary: ,G,NA
Anything that can be represented with patterns can be represented with patterns of bits.,NA,NA
What about representing things other than the written characters of a language? This is a ,NA,NA
"deep topic, and entire books have been written on it. Here is a very sloppy discussion: Pick ",NA,NA
some subject. Use English sentences to describe it. Represent those sentences in ASCII ,NA,NA
(characters encoded as byte patterns.) Now the subject is represented in binary. If ,NA,NA
"something can be represented in English, then it can be represented in binary. ",NA,NA
"Notice that this says nothing about ""meaning"" or ""understanding."" Printed books don't ",NA,NA
understand their own contents. A digital version of the book (say on CD ROM) doesn't ,NA,NA
"understand the book, either. It mearly holds the information, waiting for a human mind to do ",NA,NA
the understanding. However the book has been represented as bit patterns. ,NA,NA
Nobody said that binary representations are easy to use. Some representation methods are ,NA,NA
"very useful for computers (for instance, using binary patterns to represent numbers), others ",NA,NA
are nearly usless. Much of the work that computer scientists do is figuring out how to ,NA,NA
"represent things using binary in ways that are useful. For example, much work has been ",NA,NA
done in the last ten years in figuring out how best to represent image and audio data. ,NA,NA
Important Point: ,NA,NA
All that computer memory (and other parts) holds is bit patterns. What those bit ,NA,NA
patterns represent depends on how they are used. ,NA,NA
QUESTION 14:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_14.html (1 of 2) [7/8/2545 18:13:32],NA
"Sometimes people say, ""All that a computer can handle is numbers. It ",NA,NA
"doesn't understand anything else."" Do you think that this is correct? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_14.html (2 of 2) [7/8/2545 18:13:32],NA
A good answer might be:,NA,NA
"No. Any type of symbolic data can be represented using binary, not just numbers. At the ",NA,NA
"electronic level, everything is a binary pattern (which some people call a ""number""), so ",NA,NA
the statement is sort-of correct. ,NA,NA
End of this chapter.,NA,NA
You may wish to review the following terms. Click on the hypertext phrase to go the page ,NA,NA
where the term was discussed. ,G,NA
"What ""binary"" means.",G,NA
"What a ""bit"" is.",G,NA
The advantages ,NA,NA
of using binary in a computer. ,G,NA
"What ""analog"" means.",G,NA
How thresholds are used.,G,NA
The master clock of a computer.,G,NA
Memory contents as bit patterns.,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-02/ass02_15.html [7/8/2545 18:13:36],NA
CHAPTER 3 — BITS and BIT PATTERNS,NA,NA
Computers represent data and instructions with patterns of bits. You must become familiar ,NA,NA
with bit patterns! This chapter will help you. It discusses the fundamentals of bit patterns. ,NA,NA
Chapter Topics:,G,NA
Patterns of bits.,G,NA
The number of patterns that can be formed for N bits. ,G,NA
How to systematically list all the patterns for N bits. ,G,NA
Multiplying powers of two.,G,NA
"Bytes, kilobytes, megabytes, and gigabytes.",G,NA
Names for four-bit patterns.,G,NA
Hexadecimal names for bit patterns.,G,NA
Octal names for bit patterns.,NA,NA
"In most computer documentation, 8 contiguous bits are called a ",NA,NA
byte,NA,NA
". A bit holds a zero or a one, possibly representing the on/off ",NA,NA
condition of a switch. ,NA,NA
QUESTION 1:,NA,NA
How many patterns can be formed with a single bit? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_1.html [7/8/2545 18:13:40],NA
How many patterns can be formed with a single bit? ,NA,NA
A good answer might be: ,NA,NA
"Two • 0 and 1 (or ""off"" and ""on"", or ""false"" and ""true"", or ...) ",NA,NA
Patterns of Bits,NA,NA
A bit can be 0 or 1. With one bit there are ,NA,NA
two possible patterns. How many patterns ,NA,NA
can be formed with two bits? Here is a ,NA,NA
complete list: ,NA,NA
 0 0,NA,NA
 0 1,NA,NA
 1 0,NA,NA
 1 1,NA,NA
Looks like 4 patterns. ,NA,NA
QUESTION 2:,NA,NA
Is the pattern ,NA,NA
0 1,NA,NA
 different from the pattern ,NA,NA
1 0,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_2.html [7/8/2545 18:13:44],NA
A good answer might be: ,NA,NA
Yes • the position of a bit matters. ,NA,NA
How Many Patterns with Three Bits?,NA,NA
How many patterns can be formed with three bits? Let's list them: ,NA,NA
 0 0 0,NA,NA
 0 0 1,NA,NA
 0 1 0,NA,NA
 0 1 1,NA,NA
 1 0 0,NA,NA
 1 0 1,NA,NA
 1 1 0,NA,NA
 1 1 1,NA,NA
Looks like 8 patterns.,NA,NA
QUESTION 3:,NA,NA
Is the number of patterns that can be formed with N bits greater than the ,NA,NA
number of bits? ,NA,NA
Is the number of patterns that can be formed with N bits greater than the number of bits? ,NA,NA
A good answer might be: ,NA,NA
Yes • much greater. This simple fact is of fundamental importance to computer science. ,NA,NA
Listing Patterns Systematically,NA,NA
There is a standard method for listing all of the patterns that can be formed with a given ,NA,NA
"number of bits. First, list all of the patterns with one bit. ",NA,NA
0 ,NA,NA
1,NA,NA
When you increase the number of bits by one (from one to two) make two copies of the first ,NA,NA
list: ,NA,NA
0 ,NA,NA
1,NA,NA
0 ,NA,NA
1,NA,NA
"Within each copy, each row is unique. Now, make unique each row in the combined list. Put ",NA,NA
"""0"" in front of each line of the first copy, and put ""1"" in front of each line of the second copy: ",NA,NA
0 0 ,NA,NA
0 1,NA,NA
1 0 ,NA,NA
1 1,NA,NA
Now each line is unique and you have a complete list of the possible patterns. The number ,NA,NA
of unique patterns with 2 bits is double that with 1 bit. ,NA,NA
"For additional bits, repeat the trick for each new bit. With three bits, make two copies of the ",NA,NA
"two bit list, put ""0"" in front of the lines of the first copy and ""1"" in front of the lines of the ",NA,NA
second copy. Now you have a list containing all possible patterns of three bits. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_4.html (1 of 2) [7/8/2545 18:13:53],NA
QUESTION 4:,NA,NA
How many patterns can be formed from three bits? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_4.html (2 of 2) [7/8/2545 18:13:53],NA
A good answer might be: ,NA,NA
8 patterns can be formed from three bits. ,NA,NA
How Many Patterns?,NA,NA
The three bit list has 8 lines (patterns). Two copies of it gives you 16 lines. Each line is ,NA,NA
"made unique by prefixing the first copy with ""0"" and the second copy with ""1"". The table ",NA,NA
"(below) shows the number of patterns for 1, 2, 3 and 4 bits. ",NA,NA
Number of Bits ,NA,NA
Number of Patterns,NA,NA
Number of Patterns ,NA,NA
as power of two,NA,NA
1,NA,NA
2,NA,NA
2,1,NA
2,NA,NA
4,NA,NA
2,2,NA
3,NA,NA
8,NA,NA
2,3,NA
4,NA,NA
16,NA,NA
2,4,NA
How many patterns with 5 bits? Make two copies of the 4-bit patterns (16 patterns per ,NA,NA
"copy). Make the patterns unique by prefixing ""0"" to the first 16 patterns and ""1"" to the ",NA,NA
second 16. You now have 16×2 = 2,5,NA
 unique patterns. This demonstrates the following: ,NA,NA
Number of possible patterns of N bits = 2,N,NA
"Memorize this fact. Better yet, make lists of patterns (as above) and play around until you ",NA,NA
understand. Do this now. It is a very useful formula. If you allow yourself to get muddled on ,NA,NA
"it, you will waste much time in this and future courses. ",NA,NA
"How many patterns can be formed with 10 bits? Plugging into the formula, ",NA,NA
2,10,NA
 = 1024.,NA,NA
This number occurs often in computer science. 1024 bytes is called a ,NA,NA
kilobyte,NA,NA
", abbreviated ",NA,NA
K,NA,NA
"and pronounced ""Kay"". ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_5.html (1 of 2) [7/8/2545 18:13:59],NA
QUESTION 5:,NA,NA
"In the past, some computers used 16 bits to form memory addresses. ",NA,NA
"Assuming no special tricks (which such limited machines often used), how ",NA,NA
many bytes maximum could be held in main storage? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_5.html (2 of 2) [7/8/2545 18:13:59],NA
A good answer might be: ,NA,NA
64K bytes:     2,16,NA
 = 2,(6 + 10),NA
 = 2,6,NA
 × 2,10,NA
 = 64K ,NA,NA
More About Patterns,NA,NA
Many calculations involving bit patterns ,NA,NA
use the following familiar fact of ,NA,NA
"arithmetic. (Although the fact is familiar, ",NA,NA
confusion is even more familiar. Be sure ,NA,NA
you know this factoid.) ,NA,NA
 2,(N+M),NA
 = 2,N,NA
 × 2,M,NA
It is not too much work to extend the ,NA,NA
"table, as shown at left. You can always ",NA,NA
"make this table from scratch, but ",NA,NA
memorizing a few key values does not ,NA,NA
hurt. ,NA,NA
The numbers of patterns that can be ,NA,NA
formed with 10 or more bits are usually ,NA,NA
expressed in terms of kilobytes (= 2,10,NA
) or ,NA,NA
megabytes (= 2,20,NA
"). For example, how ",NA,NA
many patterns can be formed from 24 ,NA,NA
bits? ,NA,NA
Number ,NA,NA
of Bits ,NA,NA
Number ,NA,NA
of Patterns,NA,NA
Number of Patterns ,NA,NA
as power of two,NA,NA
1,NA,NA
2,NA,NA
2,1,NA
2,NA,NA
4,NA,NA
2,2,NA
3,NA,NA
8,NA,NA
2,3,NA
4,NA,NA
16,NA,NA
2,4,NA
5,NA,NA
32,NA,NA
2,5,NA
6,NA,NA
64,NA,NA
2,6,NA
7,NA,NA
128,NA,NA
2,7,NA
8,NA,NA
256,NA,NA
2,8,NA
9,NA,NA
512,NA,NA
2,9,NA
10,NA,NA
1024,NA,NA
2,10,NA
2,24,NA
 = 2,4,NA
 × 2,20,NA
 = 16 Meg,NA,NA
The power of two (24) splits into a small part (2,4,NA
) and a part that has a name (2,20,NA
 = Meg). ,NA,NA
This is a useful trick you can use to amaze your friends and impress employers. ,NA,NA
Some audio cards use 12 bits to represent the sound level at an instant in time (12 bits per ,NA,NA
sample). How many signal levels are represented? ,NA,NA
2,12,NA
 = 2,2,NA
 × 2,10,NA
 = 4K levels ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_6.html (1 of 2) [7/8/2545 18:14:03],NA
QUESTION 6:,NA,NA
You have a choice between a graphics card that uses 6 bits to represent ,NA,NA
"colors, or one that uses 8 bits to represent colors. The 8 bit board is ",NA,NA
somewhat more expensive than the 6 bit board. Which should you choose? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_6.html (2 of 2) [7/8/2545 18:14:03],NA
A good answer might be: ,NA,NA
"The 8 bit board, since it can represent many more colors. Assume that each bit pattern ",NA,NA
"represents a color. With 6 bits, the board could only have 2",6,NA
" = 64 colors; with 8 bits, it ",NA,NA
could have 2,8,NA
" = 256 colors, a considerable improvement. ",NA,NA
Pattern Names,NA,NA
Consider the following pattern: ,NA,NA
0010100010101010,NA,NA
It is not easy to work with. It is convenient to break bit ,NA,NA
patterns into 4-bit groups (called ,NA,NA
nibbles,NA,NA
): ,NA,NA
0010 1000 1010 1010,NA,NA
There are 16 (= 2,4,NA
 ) possible patterns in a nibble; each ,NA,NA
"pattern has a name, as seen in the table. ",NA,NA
"You might be tempted to call those 4-bit patterns ""binary ",NA,NA
"numbers"". ",NA,NA
Resist that temptation.,NA,NA
 The bit patterns in ,NA,NA
computer main memory are used for very many ,NA,NA
purposes; representing integers is just one of them. The ,NA,NA
"fundamental concept is ""bit patterns"". Don't confuse this ",NA,NA
"concept with one of its many uses: ""representing ",NA,NA
"numbers"". ",NA,NA
Hexadecimal Names,NA,NA
nibble,NA,NA
pattern ,NA,NA
name,NA,NA
nibble,NA,NA
pattern ,NA,NA
name,NA,NA
0000,NA,NA
0,NA,NA
1000,NA,NA
8,NA,NA
0001,NA,NA
1,NA,NA
1001,NA,NA
9,NA,NA
0010,NA,NA
2,NA,NA
1010,NA,NA
A,NA,NA
0011,NA,NA
3,NA,NA
1011,NA,NA
B,NA,NA
0100,NA,NA
4,NA,NA
1100,NA,NA
C,NA,NA
0101,NA,NA
5,NA,NA
1101,NA,NA
D,NA,NA
0110,NA,NA
6,NA,NA
1110,NA,NA
E,NA,NA
0111,NA,NA
7,NA,NA
1111,NA,NA
F,NA,NA
The above bit pattern can be written using the pattern names: ,NA,NA
0010 1000 1010 1100  = 28AC,NA,NA
Bits are grouped into nibbles starting at the right. Then each nibble is named. This method ,NA,NA
of giving names to patterns is called ,NA,NA
hexadecimal,NA,NA
. ,NA,NA
QUESTION 7:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_7.html (1 of 2) [7/8/2545 18:14:08],NA
What is the name of the pattern: ,NA,NA
1011 0110,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_7.html (2 of 2) [7/8/2545 18:14:08],NA
What is the name of the pattern: ,NA,NA
1011 0110,NA,NA
A good answer might be: ,NA,NA
B6 ,NA,NA
More Hex Practice ,(Not as done at Mugworts),NA
If there are not enough bits at the left to form a complete ,NA,NA
"group of four, add zero bits ",NA,NA
to the left,NA,NA
", (but be sure that it is ",NA,NA
clear by context how many bits you are describing). For ,NA,NA
example: ,NA,NA
1010000010000010     = ,NA,NA
1010 0000 1000 0010  =  A082,NA,NA
Another example: ,NA,NA
10100110101111      = ,NA,NA
10 1001 1010 1111   = ,NA,NA
0010 1001 1010 1111 = 29AF,NA,NA
Usually '0x' is placed at the front of a pattern name to show ,NA,NA
that it is a hexadecimal pattern name: ,NA,NA
Hexadecimal Names,NA,NA
nibble pattern,NA,NA
name,NA,NA
nibble pattern,NA,NA
name,NA,NA
0000,NA,NA
0,NA,NA
1000,NA,NA
8,NA,NA
0001,NA,NA
1,NA,NA
1001,NA,NA
9,NA,NA
0010,NA,NA
2,NA,NA
1010,NA,NA
A,NA,NA
0011,NA,NA
3,NA,NA
1011,NA,NA
B,NA,NA
0100,NA,NA
4,NA,NA
1100,NA,NA
C,NA,NA
0101,NA,NA
5,NA,NA
1101,NA,NA
D,NA,NA
0110,NA,NA
6,NA,NA
1110,NA,NA
E,NA,NA
0111,NA,NA
7,NA,NA
1111,NA,NA
F,NA,NA
0x0010  =  0000 0000 0001 0000 ,NA,NA
0xFACE  =  1111 1010 1100 1110,NA,NA
Please understand that ,NA,NA
hexadecimal pattern names are used by humans for talking about ,NA,NA
bit patterns. ,NA,NA
Inside the computer there are only bits and their patterns. Hexadecimal is used ,NA,NA
in books and documents (outside the computer) to describe these bit patterns. ,NA,NA
QUESTION 8:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_8.html (1 of 2) [7/8/2545 18:14:14],NA
What is the hexadecimal pattern name of the following bit pattern: ,NA,NA
01101010,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_8.html (2 of 2) [7/8/2545 18:14:14],NA
A good answer might be:,NA,NA
 01101010 = 0110 1010 = 6A,NA,NA
Zeros On the Left,NA,NA
Sometimes documentation describes bit patterns in ,NA,NA
groups of three. Three-bit groups are named using the ,NA,NA
first eight pattern names of hexadecimal. This method ,NA,NA
is called ,NA,NA
octal notation ,NA,NA
. A bit pattern can be named ,NA,NA
"using hexadecimal names, octal names, or many other ",NA,NA
notations. ,NA,NA
01101010 = 01 101 010 =  152 (octal) ,NA,NA
01101010 = 0110 1010  = 0x6A (hex),NA,NA
Octal Names,NA,NA
nibble pattern,NA,NA
name,NA,NA
nibble pattern,NA,NA
name,NA,NA
000,NA,NA
0,NA,NA
100,NA,NA
4,NA,NA
001,NA,NA
1,NA,NA
101,NA,NA
5,NA,NA
010,NA,NA
2,NA,NA
110,NA,NA
6,NA,NA
011,NA,NA
3,NA,NA
111,NA,NA
7,NA,NA
Octal is awkward to use with 8-bit bytes. Bytes don't evenly split into octal pattern names. ,NA,NA
"But you should know about it. Historically, some computer documentation used octal pattern ",NA,NA
"names. Also, in several programming languages (C and Java among them) octal notation is ",NA,NA
signaled by a leading zero: ,NA,NA
0152    (octal)    = 001 101 010 ,NA,NA
0x152   (hex)      = 0001 0101 0010 ,NA,NA
152     (decimal)  = 1001 1000 ,NA,NA
I have lost an unfortunate number of hours in total despair over disfunctional programs that ,NA,NA
"could not possibly be wrong, only to discover a constant buried deep in the code that started ",NA,NA
"with a ""0"" when it should not have. ",NA,NA
Adding zeros to the left of a pattern creates a new pattern. The new pattern has its own ,NA,NA
"name. 0x0 = 0000 is a different pattern than 0x00 = 0000 0000. Sadly, people are not ",NA,NA
"consistent about this, and depending on context, both patterns might be called ""0x0"". ",NA,NA
"When the number of bits is not a multiple of four it is conventional to add zero bits to the left, ",NA,NA
and then to name the pattern as usual. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_9.html (1 of 2) [7/8/2545 18:14:22],NA
QUESTION 9:,NA,NA
What is the hexadecimal pattern name of the following bit pattern: ,NA,NA
10 1101 0101,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_9.html (2 of 2) [7/8/2545 18:14:22],NA
A good answer might be: ,NA,NA
0x2D5 ,NA,NA
End of the Chapter,NA,NA
"If you are a bit muddled, you may wish to review some of the following. Click on a topic to ",NA,NA
go the the lesson where the term was discussed. Otherwise go out and get a nibble to eat. ,G,NA
Byte ,G,NA
Listing bit patterns ,G,NA
Number of patterns with N bits ,G,NA
kilobyte ,G,NA
Multiplying powers ,G,NA
Nibble Names ,G,NA
Hexadecimal ,G,NA
Octal,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-03/ass03_10.html [7/8/2545 18:14:26],NA
CHAPTER 4 — COMPUTER SYSTEMS,NA,NA
"This chapter discusses how computer systems are organized, with special attention paid to ",NA,NA
"main memory. Most of this you probably know already, but look it over anyway. ",G,NA
Components of a Computer System ,G,NA
Device Controllers ,G,NA
Main Memory ,G,NA
Addresses ,G,NA
Virtual Memory ,G,NA
Cache Memory ,G,NA
Contents of Memory,NA,NA
QUESTION 1:,NA,NA
Does a computer system based upon one type of processor chip (say MIPS) ,NA,NA
look about the same as a system based upon another type of chip (say ,NA,NA
Pentium)? ,NA,NA
A good answer might be: ,NA,NA
Yes. The main components are about the same and work about the same way. ,NA,NA
Computer System Components,NA,NA
The diagram is a general view of how desktop and workstation computers are organized. ,NA,NA
"Different systems have different details, but in general all computers consist of components ",NA,NA
"(processor, memory, controllers, video) connected together with a ",NA,NA
bus,NA,NA
". Physically, a ",NA,NA
bus ,NA,NA
"consists of many parallel wires, usually printed (in copper) on the main circuit board of the ",NA,NA
"computer. Data signals, clock signals, and control signals are sent on the bus back and forth ",NA,NA
between components. A particular type of bus follows a carefully written standard that ,NA,NA
describes the signals that are carried on the wires and what the signals mean. The PCI ,NA,NA
standard (for example) describes the PCI bus used on most current PCs. ,NA,NA
"The processor continuously exectues the machine cycle, executing machine instructions ",NA,NA
"one by one. Most instructions are for an arithmetical, a logical, or a control operation. A ",NA,NA
"machine operation often involves access to main storage or involves an i/o controller. If so, ",NA,NA
"the machine operation puts data and control signals on the bus, and (may) wait for data and ",NA,NA
control signals to return. Some machine operations take place entierly inside the processor ,NA,NA
(the bus is not involved). These operations are very fast. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_2.html (1 of 2) [7/8/2545 18:14:48],NA
QUESTION 2:,NA,NA
Do you think that the various components can put signals and data on the ,NA,NA
bus at any arbitrary time? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_2.html (2 of 2) [7/8/2545 18:14:48],NA
A good answer might be: ,NA,NA
No. The various devices must cooperate somehow so their data and signals don't get ,NA,NA
mixed. ,NA,NA
Input/output Controllers,NA,NA
The way devices connected to a bus cooperate is another facet of a bus standard. ,NA,NA
Input/output controllers,NA,NA
" receive input and output requests from the central processor, and ",NA,NA
then send device-specific control signals to the device they control. They also manage the ,NA,NA
data flow to and from the device. This frees the central processor from involvment with the ,NA,NA
details of controlling each device. I/O controllers are needed only for those I/O devices that ,NA,NA
are part of the system. ,NA,NA
Often the I/O controllers are part of the electronics on the main circuit board (the ,NA,NA
mother ,NA,NA
board,NA,NA
) of the computer. Sometimes an uncommon device requires its own controller which ,NA,NA
must be plugged into a connector (an expansion slot) on the mother board. ,NA,NA
QUESTION 3:,NA,NA
(Review:) Is there a difference between the memory used to hold programs ,NA,NA
and the memory used to hold data? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_3.html [7/8/2545 18:14:56],NA
A good answer might be: ,NA,NA
No. Potentially any byte of main memory can hold part of a program or part of some ,NA,NA
data. ,NA,NA
Main Memory,NA,NA
"In practice, data and instructions are often placed in different sections of memory, but this is ",NA,NA
"a matter of software organization, not a hardware requirement. Also, most computers have ",NA,NA
"special sections of memory that permanently hold programs (firmware stored in ROM), and ",NA,NA
other sections that are permanently used for special purposes. ,NA,NA
Main memory (also called ,NA,NA
main storage,NA,NA
", or just ",NA,NA
memory,NA,NA
) holds the bit patterns of machine ,NA,NA
instruction and the bit patterns of data. Memory chips and the electronics that controls them ,NA,NA
are concerned only with saving bit patterns and returning them when requested. No ,NA,NA
distinction is made between bit patterns that are intended as instructions and bit patterns ,NA,NA
that are intended as data. The amount of memory on a system is often described in terms ,NA,NA
of: ,NA,NA
Kilobyte:,NA,NA
2,10,NA
 = 1024 bytes. ,NA,NA
Megabyte:,NA,NA
 2,20,NA
 = 1024 Kilobytes ,NA,NA
Gigabyte:,NA,NA
 2,30,NA
 = 1024 Megabytes ,NA,NA
Terabyte:,NA,NA
 2,40,NA
 = 1024 Gigabytes ,NA,NA
Main memory these days (Summer 2001) ranges in capacity from 32 Meg to 512 Meg. Hard ,NA,NA
disks and other secondary storage devices are ten or hundreds of Gig. Backup storage ,NA,NA
comes in sizes as large as several terabytes. ,NA,NA
QUESTION 4:,NA,NA
What is (on most computers) the smallest addressable unit of memory? ,NA,NA
A good answer might be: ,NA,NA
A byte. ,NA,NA
Addresses ,NA,NA
Each byte of main storage has an ,NA,NA
address,NA,NA
". Most modern processors use 32-bit addresses, ",NA,NA
so there are 2,32,NA
 possible addresses. Think of main storage as if it were an array: ,NA,NA
byte[0x00000000 ... 0xFFFFFFFF] mainStorage;,NA,NA
A main storage address is an index into ,NA,NA
memory. A 32-bit address is the address of ,NA,NA
a single byte. Thirty-two wires of the bus ,NA,NA
contain an address (there many more bus ,NA,NA
wires for timing and control). ,NA,NA
Sometimes people talk about addresses like ,NA,NA
"0x2000, which looks like a pattern of just 16 ",NA,NA
bits. But this is just an abbreviation for the ,NA,NA
full 32-bit address. The actual address is ,NA,NA
0x00002000. ,NA,NA
"Older MIPS processsors, the R2000 ",NA,NA
"(designed in 1985) and the R3000, use 32-bit ",NA,NA
addresses. Recent MIPS processors ,NA,NA
(from 1991 to present) use 64-bit addresses. ,NA,NA
Processor chips from Intel will have 64-bit ,NA,NA
addresses in the near future. ,NA,NA
The assembly language of this course is for ,NA,NA
"the MIPS 3000 chip, so we will use 32-bit ",NA,NA
addresses. The assembly language of the ,NA,NA
recent MIPS chips is similar. For embedded ,NA,NA
"systems programming, 32-bit addresses is ",NA,NA
"often more than enough, so the 32-bit chips ",NA,NA
are still used. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_5.html (1 of 2) [7/8/2545 18:15:37],NA
QUESTION 5:,NA,NA
What is the hexadecimal name for the 32-bit pattern that consists of all 1 ,NA,NA
bits? (Hint: look at the picture.) ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_5.html (2 of 2) [7/8/2545 18:15:37],NA
What is the hexadecimal name for the 32-bit pattern that consists of all 1 bits? ,NA,NA
A good answer might be: ,NA,NA
0xFFFFFFFF ,NA,NA
Virtual Memory,NA,NA
The MIPS ,NA,NA
R3000 has an ,NA,NA
address ,NA,NA
space of 2,32,NA
bytes. A ,NA,NA
Gigabyte = ,NA,NA
2,30,NA
", so it has 4 ",NA,NA
gigabytes of ,NA,NA
address ,NA,NA
"space. Ideally, ",NA,NA
all of these ,NA,NA
memory ,NA,NA
locations ,NA,NA
would be ,NA,NA
implemented ,NA,NA
using memory ,NA,NA
chips (usually ,NA,NA
called RAM). ,NA,NA
RAM costs ,NA,NA
about $2 per ,NA,NA
megabyte. ,NA,NA
Installing the maximum amount of memory as RAM would cost 2,12,NA
 × $2 = $8192. This might ,NA,NA
be more than you want to spend. Hard disk storage costs much less per megabyte. A 20 ,NA,NA
"gigabyte hard disk costs about $90 (summer, 2001). ",NA,NA
"On modern computers, the full address space is present no matter how much RAM has ",NA,NA
been installed. This is done by keeping some parts of the full address space on disk and ,NA,NA
"some parts in RAM. The RAM, the hard disk, some special electronics, and the operating ",NA,NA
system work together to provide the full 32 bit address space. To a user or an applications ,NA,NA
programmer it looks as if there are all 2,32,NA
 bytes of main memory. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_6.html (1 of 2) [7/8/2545 18:15:44],NA
This method of providing the full address space by using a combination of RAM memory ,NA,NA
and the hard disk is called ,NA,NA
virtual memory,NA,NA
. The word ,NA,NA
virtual,NA,NA
" means ""appearing to exist, but ",NA,NA
"not really there."" Some computer geeks have a virtual social life. ",NA,NA
QUESTION 6:,NA,NA
Which is faster: RAM memory access or hard disk access? ,NA,NA
Which is faster: physical memory access or the hard disk access? ,NA,NA
A good answer might be: ,NA,NA
Physical memory access. ,NA,NA
Cache Memory ,NA,NA
"Disk access is very slow compared to RAM access. Potentially, using a combination of real ",NA,NA
memory and the hard disk to implement the address space could greatly slow down ,NA,NA
"program execution. However, with clever electronics and a good operating system, using ",NA,NA
virtual memory is only slightly slower than physical memory. ,NA,NA
Computer systems also have ,NA,NA
cache memory,NA,NA
. Cache memory is very fast RAM that is ,NA,NA
inside (or close to) the processor. It duplicates the addresses and contents of the areas of ,NA,NA
main storage that are heavily used. The processor does not have to use the system bus to ,NA,NA
get or store data in cache memory. Access to cache memory is much faster than to normal ,NA,NA
main memory. ,NA,NA
"Like virtual memory, cache memory is invisible to most programs. It is an electronic detail ",NA,NA
below the level of abstraction provided by assembly language. Hardware keeps cache up to ,NA,NA
date and in synch with main storage. Your programs are unaware that there is cache ,NA,NA
"memory and virtual memory. They just see ""main memory"". Application programs don't ",NA,NA
"contain instructions that say ""store this in cache memory"", or say ""get this from virutal ",NA,NA
"memory"". They only reference main memory its contents. The hardware makes sure that the ",NA,NA
"program gets or stores the correct byte, no matter where it really is. ",NA,NA
QUESTION 7:,NA,NA
"Since memory is looks like an array of bytes, is it necessary for each item of ",NA,NA
data in memory to be one byte long? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_7.html [7/8/2545 18:16:06],NA
A good answer might be: ,NA,NA
No. Most data and instructions are several bytes long and occupy several consecutive ,NA,NA
memory addresses. ,NA,NA
Contents of Memory ,NA,NA
"The electronics of the memory system knows nothing about instructions, numbers, ",NA,NA
"characters, or other data. The memory system merely stores bit patterns. The idea that ",NA,NA
"some of these patterns are integers, some are characters, and some are instructions (and ",NA,NA
"so on) is contained in the program you write, not in the electronics. Good programs are ",NA,NA
"written to keep the various uses of memory in separate sections, but that is a programming ",NA,NA
"convention, not a requirement of electronics. ",NA,NA
Any byte in main storage can contain any 8-bit pattern. No byte of main storage ,NA,NA
can contain anything but an 8-bit pattern. There is nothing in the memory system ,NA,NA
of a computer that says what a pattern represents. ,NA,NA
QUESTION 8:,NA,NA
"When first turned on, many computer systems test their RAM by writing ",NA,NA
various patterns to various locations and then reading the patterns back. Do ,NA,NA
you think this is a good test? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_8.html [7/8/2545 18:16:20],NA
A good answer might be: ,NA,NA
"It is a good test. The job of memory is to hold bit patterns, and to return them when ",NA,NA
"requested, and that is what is tested. ",NA,NA
End of the Chapter ,NA,NA
You have reached the end this chapter. Test your memory by clicking on a topic to jump to ,NA,NA
"the page where it is discussed. Remember to click on the ""back arrow"" button to get back to ",NA,NA
this page. ,G,NA
The ,NA,NA
components,NA,NA
 of a computer system. ,G,NA
Device controllers.,G,NA
"Kilobytes,",NA,NA
" Megabytes, and Gigabytes ",G,NA
Memory addresses ,G,NA
Virtual memory.,G,NA
Cache memory,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-04/ass04_9.html [7/8/2545 18:16:37],NA
Chapter 5 — REPRESENTING ,NA,NA
CHARACTERS WITH BIT PATTERNS ,NA,NA
Patterns of bits represent many types of things. This chapter shows how bit patterns are ,NA,NA
used to represent characters. ,G,NA
ASCII ,G,NA
Control characters.,G,NA
Teletype Machines.,G,NA
.asciiz and null terminated strings. ,G,NA
Disk files.,G,NA
Text files.,G,NA
Binary files.,G,NA
Executable files.,NA,NA
QUESTION 1:,NA,NA
What else (besides characters and integers) can be represented with bit ,NA,NA
patterns? ,NA,NA
A good answer might be: ,NA,NA
Machine instructions. (Many answers are correct; anything symbolic can be rep,d,NA
 with bit ,NA,NA
"patterns: graphics, music, floating point numbers, internet locations, video, ...) ",NA,NA
Representing Characters,NA,NA
A groups of 8 bits is a byte. Typically one character is represented with one byte. The ,NA,NA
agreement by the American Standards Committee on what pattern represents what ,NA,NA
"character is called ASCII. (There are several ways to pronounce ""ASCII"". Frequently it is ",NA,NA
"pronounced ""ásk-ee""). Most microcomputers and many mainframes follow this standard. ",NA,NA
When a printer built to print ASCII receives the ASCII ,NA,NA
"pattern for ""A"" (along with some control signals), it prints an ",NA,NA
"character. For example, the pattern 0x00 (ie. 0000 0000) is ",NA,NA
the NUL character. NUL is often used as a marker in ,NA,NA
"collections of data. The pattern 0x0A is the LF, linefeed ",NA,NA
QUESTION 2:,NA,NA
Could a computer terminal be a mechanical device??? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_2.html [7/8/2545 18:17:03],NA
A good answer might be: ,NA,NA
Yes. The better ones smelled of fresh machine oil and chattered pleasantly as they ,NA,NA
worked. ,NA,NA
Teletype Machines,NA,NA
Teletype machines were used from 1910 ,NA,NA
until 1980 (?) to send and receive ,NA,NA
characters over telegraph lines. They ,NA,NA
were made of electrical and mechanical ,NA,NA
parts. They printed characters on a ,NA,NA
roll of paper. Various mechanical ,NA,NA
actions of the machine were requested ,NA,NA
from a distance by sending ,NA,NA
control ,NA,NA
characters,NA,NA
 over the line. A common ,NA,NA
"control sequence was ""carriage return"" ",NA,NA
"followed by ""linefeed"". ",NA,NA
In the early days of small computers ,NA,NA
(1972-1982) teletypes were often the ,NA,NA
sole means of input and output to the ,NA,NA
computer. These tty (teletype) machines ,NA,NA
printed with fixed-size characters ,NA,NA
(like their electric typewritter ,NA,NA
cousins). The tag used in HTML for fixed-size (non-proportional) ,NA,NA
"font is <tt> -- which stands for ""TeleType"". This paragraph is set ",NA,NA
inside <tt> ... </tt> tags. ,NA,NA
Some models of tty's could be used off-line (not connected to anything). The user could ,NA,NA
slowly and carefully type a message (or program) and have it recorded as holes punched on ,NA,NA
a paper tape. The device on the left of the machine in the photo is the paper tape ,NA,NA
"reader/puncher. Once the paper tape was correct, the tty was put on-line and the paper tape ",NA,NA
"was quickly read in. In those days, paper tape was ",NA,NA
mass storage,NA,NA
. ,NA,NA
The web pages of the North American Communications Museum ,NA,NA
Off-site link,NA,NA
 have more ,NA,NA
information on teletypes. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_3.html (1 of 2) [7/8/2545 18:19:43],NA
QUESTION 3:,NA,NA
Can the bit patterns that are used to represent characters represent other ,NA,NA
things in other contexts? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_3.html (2 of 2) [7/8/2545 18:19:43],NA
Can the patterns that are used to represent characters represent other things in other ,NA,NA
contexts? ,NA,NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
ASCII Chart ,NA,NA
Hex   Char,NA,NA
Hex   Char,NA,NA
Hex   Char,NA,NA
Hex   Char,NA,NA
00   nul,NA,NA
20   sp ,NA,NA
40   @ ,NA,NA
60   ` ,NA,NA
01   soh,NA,NA
21   ! ,NA,NA
41   A ,NA,NA
61   a ,NA,NA
02   stx,NA,NA
"22   "" ",NA,NA
42   B ,NA,NA
62   b ,NA,NA
. . . ,NA,NA
. . . ,NA,NA
. . . ,NA,NA
. . . ,NA,NA
0A   lf ,NA,NA
2A   * ,NA,NA
4A   J ,NA,NA
6A   j ,NA,NA
. . . ,NA,NA
. . . ,NA,NA
. . . ,NA,NA
. . . ,NA,NA
1E   rs ,NA,NA
3E   > ,NA,NA
5E   ^ ,NA,NA
7E   ~ ,NA,NA
1F   us ,NA,NA
3F   ? ,NA,NA
5F   _ ,NA,NA
7F   del ,NA,NA
The chart shows some patterns ,NA,NA
used in ASCII to represent ,NA,NA
characters. The first printable ,NA,NA
character is SP (space) and ,NA,NA
corresponds to the bit pattern 0010 ,NA,NA
0000. ,NA,NA
"Space is a character, just like any ",NA,NA
other. Although not visible in the ,NA,NA
"shortened chart, the upper case ",NA,NA
alphabetical characters appear in ,NA,NA
"order A,B,C, ..., X, Y, Z with no ",NA,NA
gaps. There is a gap between ,NA,NA
upper case and lower case letters. ,NA,NA
The lowercase characters also ,NA,NA
"appear in order a,b,c,...x, y, z. ",NA,NA
The last pattern is 0x7F which is 0111 1111. corresponding to the DEL (delete) character. ,NA,NA
"For a complete list of ASCII representations, see the appendix. ",NA,NA
QUESTION 4:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_4.html (1 of 2) [7/8/2545 18:19:53],NA
"How many of the total number of 8-bit patterns correspond to a character, ",NA,NA
(including control characters)? (Hint: look at the pattern for DEL). ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_4.html (2 of 2) [7/8/2545 18:19:53],NA
A good answer might be: ,NA,NA
"50 Percent, 128 out of 256 ",NA,NA
ASCII Sequences,NA,NA
The chart for ASCII shows all possible 7-bit patterns. There are twice as many 8-bit ,NA,NA
patterns. Some computer makers use the additional patterns to represent various things. ,NA,NA
"Old MS Windows PCs, for example, used these extra patterns to represent symbols and ",NA,NA
graphics characters. Some printers will not work with these additional patterns. ,NA,NA
Part of what an assembler does is to assemble the ASCII bit patterns that you have asked ,NA,NA
to be placed in memory. Here is a section of an assembly language program: ,NA,NA
" .asciiz      ""ABC abc""",NA,NA
Here are the bit patterns that the assembler will produce in the object module: ,NA,NA
 41 42 43 20 61 62 63 00,NA,NA
The .asciiz part of the source code asked the assembler to assemble the characters ,NA,NA
"between the quote marks into ASCII bit patterns. The first character, ""A"", corresponds to the ",NA,NA
"bit pattern 0x41. The second character, ""B"", corresponds to the bit pattern 0x42. The fourth ",NA,NA
"character, "" "" (space), corresponds to the bit pattern 0x20. The final bit pattern 0x00 (NUL) is ",NA,NA
used by the assembler to show the end of the string of characters. ,NA,NA
QUESTION 5:,NA,NA
What will be the assembled patterns for this assembly code: ,NA,NA
".asciiz   ""A B""",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_5.html [7/8/2545 18:19:55],NA
A good answer might be: ,NA,NA
41 20 42 00,NA,NA
Files,NA,NA
Disk files consist of blocks of bytes holding bit patterns. Usually the patterns are recorded ,NA,NA
on magnetic media such as hard disks or tape. Although the actual physical arrangement ,NA,NA
"varies, you can think of a file as a contiguous block of bytes. The ""DIR"" command of DOS ",NA,NA
lists the number of bytes in each file (along with other information). ,NA,NA
"Ignoring implementation details (which vary from one operating system to the next), a file is ",NA,NA
a sequence of bytes on magnetic media. What can each byte contain? A byte on a magnetic ,NA,NA
disk can hold one of 2,8,NA
" (256) possible patterns, the same as a byte in main storage. ",NA,NA
Reading a byte from disk into a byte of main storage copies the pattern from one byte to ,NA,NA
another. ,NA,NA
"(Actually, for efficiency, disk reads and writes are always done in blocks of 128 bytes or ",NA,NA
more at a time). ,NA,NA
"So files, as main memory, contain bit patterns. What the bit patterns of a file represent ",NA,NA
"depends on how they are used. For example, often a file contains bytes that represent ",NA,NA
characters according to the ASCII convention. Such a file is called a ,NA,NA
text file,NA,NA
", or sometimes ",NA,NA
an ,NA,NA
ASCII file,NA,NA
. What makes the file a text file is the knowledge about how the file was ,NA,NA
created and how it is to be used. ,NA,NA
QUESTION 6:,NA,NA
"You (acting as an ""English Language Application"") find a battered old book in ",NA,NA
a stall outside a bookshop. You open the book to a random page and see: ,NA,NA
"Cum Luna caelo fulget, et auream Pompam sereno pandit in ambitu Ignes ",NA,NA
"coruscantes, voluptas Mira trahit, retinetque visus. ",NA,NA
Is this book suitable for you (in your role as an English application)? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_6.html [7/8/2545 18:19:59],NA
A good answer might be: ,NA,NA
No. The individual letters are the same as used in your expected context (English) but in ,NA,NA
the book their context is different. ,NA,NA
Text Files ,NA,NA
A computer application (program) is the context for the bit patterns of its input and output ,NA,NA
"files. Although there are some standard contexts (such as for text files), many applications ",NA,NA
use a context that is their own. If you could somehow inspect the surface of a disk and see ,NA,NA
"the bit patterns stored in a particular file, you would not know what they represented without ",NA,NA
additional knowledge. ,NA,NA
"Often people talk of ""text files"" and ""MS Word files"" and ""executable files"" as if these were ",NA,NA
"completely different things. But these are just sloppy, shorthand phrases. For example, ",NA,NA
"when one says ""text file"" one really means: ",NA,NA
Text File:,NA,NA
 A file containing a sequence of bytes. Each byte holds a bit pattern ,NA,NA
which represents a printable character or one of several allowed control characters ,NA,NA
(using the ASCII encoding scheme). Not all control characters are allowed. The file ,NA,NA
can be used with a text editor and can be sent to a hardware device that expects ,NA,NA
ASCII character codes. ,NA,NA
Files containing bytes that encode printable characters according to the ASCII convention ,NA,NA
have about half of the possible patterns. Computer monitors and printers behave correctly ,NA,NA
"with the ASCII patterns, but often can't deal with the other patterns. ",NA,NA
QUESTION 7:,NA,NA
(DON'T do this with an important file:) In Notepad (or other text editor) open ,NA,NA
an EXE file (such as a compiled C program). What happens? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_7.html [7/8/2545 18:20:04],NA
In Notepad open an EXE file (such as a compiled C program). What happens? ,NA,NA
A good answer might be: ,NA,NA
There many bit patterns the monitor can't handle; the display is messed up. ,NA,NA
Executable Files ,NA,NA
"For extra fun, try sending an EXE file to a printer. Make sure you can stop the printer if you ",NA,NA
need to. Sometimes it will print endless sheets of paper covered with gibberish. When one ,NA,NA
"says ""executable file"" one really means: ",NA,NA
Executable File:,NA,NA
 A file containing a sequence of bytes. Each byte holds a bit ,NA,NA
pattern that represents part of a machine instruction for a particular processor. The ,NA,NA
operating system can load (copy) an executable file into main storage and can then ,NA,NA
execute the program. ,NA,NA
A byte in an executable file can contain any possible 8-bit pattern. A file like this often is ,NA,NA
called a ,NA,NA
Binary File,NA,NA
. This is misleading vocabulary. All files represent their information as ,NA,NA
"binary patterns. When one says ""MS Word file"" one really means: ",NA,NA
Word File:,NA,NA
 A file containing a sequence of bytes holding bit patterns created by ,NA,NA
"the MS Word program, which are understood only by that program (and a few ",NA,NA
others). ,NA,NA
"There is nothing special about the various ""types"" of files. Each is a sequence of bytes. ",NA,NA
Each byte holds a bit pattern. A byte can hold one of 256 possible patterns (although some ,NA,NA
file types allow only 128 or fewer of these patterns). When longer bit patterns are needed ,NA,NA
they are held in several contiguous bytes. ,NA,NA
QUESTION 8:,NA,NA
Say that you want to compress a text file with a file compression utility like ,NA,NA
WinZip,NA,NA
. About what percent compression can you expect? (Hint: if you have ,NA,NA
"been paying attention, you can figure out this answer). ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_8.html [7/8/2545 18:20:10],NA
A good answer might be: ,NA,NA
50% ,NA,NA
Binary File,NA,NA
The bytes of a text file hold 128 out of the 256 possible 8-bit patterns. Each byte is used for ,NA,NA
half of its information carrying capacity. So a text file holds about half the information that it ,NA,NA
could. A compression utility makes (nearly) maximum use of the bytes and will compress a ,NA,NA
text file to about 50% of its original size. ,NA,NA
All files are sequences of bytes containing binary patterns (bit patterns). But people often ,NA,NA
say ,NA,NA
binary file,NA,NA
 when they mean: ,NA,NA
Binary File,NA,NA
 (colloquial),NA,NA
:,NA,NA
 a file in which a byte might contain any of the possible ,NA,NA
256 patterns (in contrast to a ,NA,NA
text file,NA,NA
 in which a byte may only contain one of the ,NA,NA
"128 ASCII patterns, or fewer). ",NA,NA
"An EXE file is a binary file, as is a Word file, as is an Excel file, ... , as are all files except ",NA,NA
"text files. People are often not careful, and sometimes say ""binary file"" when they really ",NA,NA
"mean ""executable file"". The phrase ""binary file"" became common amoung MS/DOS users ",NA,NA
because DOS file utilities made a distinction between text files and all others. ,NA,NA
Using the wrong type of file with an application can cause chaos. Don't send an executable ,NA,NA
"file to a printer, or open an MS Word file with a text editor. Some applications are written to ",NA,NA
deal with several types of files. MS Word can recognize text files and files from other word ,NA,NA
processors. ,NA,NA
QUESTION 9:,NA,NA
Why are word processor files not text files? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_9.html [7/8/2545 18:20:18],NA
A good answer might be:,NA,NA
"More things are represented than just the characters of ASCII: fonts, how to format, ",NA,NA
"graphics, etc. All these things are represented with bit patterns. Different word ",NA,NA
processors use different bit patterns to indicate these things. ,NA,NA
End of the Chapter,NA,NA
You have reached the end this chapter. You may wish to review the following. Click on a ,NA,NA
"subject that interests you to go to where it was discussed. To return here, click on the ""back ",NA,NA
"arrow"" button of your teletypewritter. ",G,NA
ASCII ,G,NA
Teletype machines.,G,NA
ASCII chart.,G,NA
.asciiz,NA,NA
 assembly language. ,G,NA
Text files.,G,NA
Executable files.,G,NA
Binary files.,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-05/ass05_10.html [7/8/2545 18:20:27],NA
Chapter 6 — Number Representation ,NA,NA
Patterns of bits can represent many different things. Anything that can be represented with ,NA,NA
any kind of symbols can be represented with bit patterns. This chapter shows how bit ,NA,NA
patterns are used to represent integers. ,G,NA
Numbers and representations of numbers. ,G,NA
Positional representation of integers. ,G,NA
Decimal representation.,G,NA
Binary representation.,G,NA
Converting representations.,NA,NA
QUESTION 1:,NA,NA
What is your favorite number? ,NA,NA
A good answer might be: ,NA,NA
VII ,NA,NA
What is a Number?,NA,NA
"In ordinary English, the word ""number"" has two different meanings (at least). One meaning ",NA,NA
"is the concept, the other meaning is how the concept is represented. For example, think ",NA,NA
about ,NA,NA
"""the number of eggs in an egg carton"" ",NA,NA
You know the number I mean. Now write it down on paper. ,NA,NA
QUESTION 2:,NA,NA
How many eggs in a carton of eggs? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_2.html [7/8/2545 18:20:37],NA
A good answer might be:,NA,NA
Representations,NA,NA
What you wrote is a ,NA,NA
representation,NA,NA
 of the number. Here is one representation: ,NA,NA
XII ,NA,NA
This may not be the representation you used for your number. Here is another ,NA,NA
representation for that same number: ,NA,NA
///// ///// // ,NA,NA
Perhaps you used this representation: ,NA,NA
12 ,NA,NA
or this: ,NA,NA
twelve ,NA,NA
or this: ,NA,NA
1100,2,NA
QUESTION 3:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_3.html (1 of 2) [7/8/2545 18:20:53],NA
Are ,NA,NA
"XII, ///// ///// //,",NA,NA
 and ,NA,NA
12,NA,NA
 different numbers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_3.html (2 of 2) [7/8/2545 18:20:53],NA
A good answer might be: ,NA,NA
"No, but the question is vague. ",NA,NA
Representations,NA,NA
To be precise you would say that ,NA,NA
"XII, ///// ///// //,",NA,NA
 and ,NA,NA
12,NA,NA
 are different ways to ,NA,NA
represent,NA,NA
 the ,NA,NA
same number. ,NA,NA
There are many ways to represent that number. The number is always the same number. ,NA,NA
"But a variety of ink marks (or pencil marks, or chalk smudges, or characters on a computer ",NA,NA
"monitor) can represent it. In normal conversation and in writing ""number"" often means ",NA,NA
the ,NA,NA
representation of a number.,NA,NA
" For example, you might call. . . ",NA,NA
12,NA,NA
". . . a ""number"". It would be tedious to call it ""an instance of the representation of the ",NA,NA
"number using Arabic digits with the decimal system."" But that is what it is. ",NA,NA
Computer Science is concerned with using patterns of bits to represent things. It is ,NA,NA
"important to be clear about the difference between the thing, and a representation of the ",NA,NA
"thing. For example, there are many ways to represent an integer using bit patterns in a ",NA,NA
computer. The integer is conceptual. The bit pattern held in a memory location is only a ,NA,NA
representation. ,NA,NA
QUESTION 4:,NA,NA
Is XII even or odd? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_4.html [7/8/2545 18:21:16],NA
Is XII even or odd? ,NA,NA
A good answer might be: ,NA,NA
Even. The representation does not change the properties the number (although it often ,NA,NA
makes it easier to determine those properties). ,NA,NA
Positional Notation ,NA,NA
The decimal system is a ,NA,NA
positional notation,NA,NA
 for representing numbers. This means that the ,NA,NA
representation consists of a string of digits. The position of each digit in the string is ,NA,NA
significant. Think of each position as a numbered slot where a digit can go. ,NA,NA
___,4,NA
 ___,3,NA
 ___,2,NA
 ___,1,NA
 ___,0,NA
"Positional notation has many advantages. It is compact: ""78"" is shorter than ""LXXIIX"". ",NA,NA
Computation is easy. ,NA,NA
LXXIIX,NA,NA
 times ,NA,NA
XLIIV,NA,NA
 is hard to do using only the Roman system. ,NA,NA
QUESTION 5:,NA,NA
Is XLMCIIV a legitimate Roman-system representation of an integer? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_5.html [7/8/2545 18:21:20],NA
A good answer might be: ,NA,NA
Yuck! ,NA,NA
Decimal Notation ,NA,NA
The Roman numeral above is not a correct representation of an integer. But it takes some ,NA,NA
inspection to decide this. Decimal positional representation is clearly better. ,NA,NA
You already know how decimal notation works (and probably would be happy to skip this ,NA,NA
topic). ,NA,NA
324 means:  3 × 100  +  2 × 10  +  4 × 1 ,NA,NA
which is:   3 × 10,2,NA
  +  2 × 10,1,NA
 +  4 × 10,0,NA
Remember that: ,NA,NA
B,0,NA
"   =  1,  no matter what number B is.",NA,NA
Rules for Positional Notation. ,NA,NA
1.  The base B is (usually) a positive integer.,NA,NA
"2.  There are B ""digits"" representing zero up to (B minus one).",NA,NA
"3.  Positions correspond to integer powers of B, starting with power zero, and increasing ",NA,NA
right to left.,NA,NA
4.  The digit placed at a position shows how many times that power of B is included in the ,NA,NA
number.,NA,NA
QUESTION 6:,NA,NA
Fill in the blanks: ,NA,NA
7305 = 7 ×  10,---,NA
  +  3 × 10,---,NA
  +  0 ×  10,---,NA
  +  5 ×  10,"---
  
  
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_6.html [7/8/2545 18:21:28]",NA
A good answer might be: ,NA,NA
7305 = 7 ×  10,NA,NA
3,NA,NA
  +  3 × 10,NA,NA
2,NA,NA
  +  0 × 10,NA,NA
1,NA,NA
  +  5 ×  10,NA,NA
0,NA,NA
Decimal Notation ,NA,NA
For base 10 representation (often called ,NA,NA
decimal representation,NA,NA
"), the rules of positional notation ",NA,NA
are: ,NA,NA
1.  The base is 10.,NA,NA
"2.  There are 10 ""digits"", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 .",NA,NA
"3.  Positions correspond to integer powers of 10, starting with power 0 at the rightmost digit, and ",NA,NA
increasing right to left.,NA,NA
4.  The digit placed at a position shows how many times that power of 10 is included in the number.,NA,NA
A compact way of writing this is: ,NA,NA
Any integer can serve as the base for a positional representation system. Five can serve as a base. ,NA,NA
QUESTION 7:,NA,NA
Here are the rules for positional notation. Fill in the blanks to work with base five: ,NA,NA
1.  The base is _______. ,NA,NA
"2.  There are _________ ""digits"": ____, ____, ____, ____, ____ . ",NA,NA
"3.  Positions correspond to integer powers of ____, starting with power ____ at the rightmost ",NA,NA
"digit, and increasing right to left. ",NA,NA
4.  The digit placed at a position shows how many times that power of ____is included in the ,NA,NA
number.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_7.html [7/8/2545 18:21:31],NA
A good answer might be:,NA,NA
1.  The base is ,NA,NA
five,NA,NA
. ,NA,NA
2.  There are ,NA,NA
five,NA,NA
" ""digits"": ",NA,NA
0,NA,NA
",",NA,NA
1,NA,NA
", ",NA,NA
2,NA,NA
", ",NA,NA
3,NA,NA
", ",NA,NA
4,NA,NA
 . ,NA,NA
3.  Positions correspond to integer powers of ,NA,NA
five,NA,NA
", starting with power ",NA,NA
0,NA,NA
 at the rightmost ,NA,NA
"digit, and increasing right to left. ",NA,NA
4.  The digit placed at a position shows how many times that power of ,NA,NA
five,NA,NA
 is included in ,NA,NA
the number.,NA,NA
Base Five Notation,NA,NA
"The number ""five"" in base five is represented by ""10"" That is: ",NA,NA
1,NA,NA
 × (five),1,NA
 + ,NA,NA
0,NA,NA
 × (five),0,NA
"The base in any positional representation is written as ""10"" (assuming that the usual ",NA,NA
"symbols 0, 1, ... are used). Here is a number represented in base five: 421. It means: ",NA,NA
421 = ,NA,NA
4,NA,NA
 × five,2,NA
  +  ,NA,NA
2,NA,NA
 × five,1,NA
 + ,NA,NA
1,NA,NA
 × five,0,NA
"Remember, the symbol ""5"" can not be used in the base five system. Actually, the above ",NA,NA
"sum should be written as follows. (This looks just like base ten, but remember, here ""10"" is ",NA,NA
"""five"".) ",NA,NA
421 = 4 × 10,2,NA
 + 2 × 10,1,NA
 + 1 × 10,0,NA
QUESTION 8:,NA,NA
Fill in the table. ,NA,NA
Base five ,NA,NA
Representation,NA,NA
0,NA,NA
Base ten ,NA,NA
Representation,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_8.html (1 of 2) [7/8/2545 18:21:35],NA
1,NA,NA
2,NA,NA
3,NA,NA
4,NA,NA
10,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_8.html (2 of 2) [7/8/2545 18:21:35],NA
A good answer might be:,NA,NA
Base five ,NA,NA
Representation,NA,NA
0,NA,NA
1,NA,NA
2,NA,NA
3,NA,NA
4,NA,NA
10,NA,NA
Base ten ,NA,NA
Representation,NA,NA
0,NA,NA
1,NA,NA
2,NA,NA
3,NA,NA
4,NA,NA
5,NA,NA
Changing Representations ,NA,NA
You may wish to change the representation of a number from base 5 notation into base 10 ,NA,NA
notation. Do this by symbol replacement. Change the base 5 symbols into the base 10 ,NA,NA
symbol equivalents. Then do the arithmetic. ,NA,NA
421,5,NA
 =   ,NA,NA
4 × 10,52,NA
 + 2 × 10,51,NA
 + 1 × 10,50,NA
the number rep,d,NA
 in base 10   =   ,NA,NA
4 × 5,102,NA
 + 2 × 5,101,NA
 + 1 × 5,100,NA
the number rep,d,NA
 in base 10   =   ,NA,NA
4 × 25 + 2 × 5 + 1 × 1,NA,NA
the number rep,d,NA
 in base 10   =   ,NA,NA
100 + 10 + 1 = 111,10,NA
"The above process is often called ""converting a number from base 5 to base 10"". But in ",NA,NA
"fact, the ",NA,NA
number,NA,NA
" is not being converted, its ",NA,NA
representation,NA,NA
 is being converted. The ,NA,NA
"characters ""421 (base five)"" and ""111 (base ten)"" represent the ",NA,NA
same number,NA,NA
. ,NA,NA
QUESTION 9:,NA,NA
Change the representation of 102,5,NA
 from base five to base ten. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_9.html (2 of 2) [7/8/2545 18:21:42],NA
Change the representation of 102,5,NA
 from base five to base ten. ,NA,NA
A good answer might be: ,NA,NA
102,5,NA
   =   1 × 5,102,NA
 + 0 × 5,101,NA
 + 2 × 5,100,NA
   =   25,10,NA
 + 2,10,NA
   =   27,10,NA
Base Seven ,NA,NA
Here is another example: 326,7,NA
. This means: ,NA,NA
3×seven,2,NA
 + 2×seven,1,NA
 + 6×seven,0,NA
"To write the number in decimal, write the powers of seven in decimal and perform the ",NA,NA
arithmetic: ,NA,NA
3 ×  7,102,NA
 + 2 × 7,101,NA
 + 6 × 7,100,NA
3 × 49,10,NA
  + 2 × 7,10,NA
 + 6 × 1 ,NA,NA
147,10,NA
 + 14,10,NA
 + 6,10,NA
    =    167,10,NA
.,NA,NA
QUESTION 10: ,NA,NA
Can 682,7,NA
 be rewritten in base ten notation? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_10.html [7/8/2545 18:21:49],NA
A good answer might be: ,NA,NA
No. It is a meaningless representation because the digit 8 can not be used with base ,NA,NA
seven. ,NA,NA
Secret Numbers,NA,NA
The symbols chosen for digits need not be the usual symbols. Here is a system for base ,NA,NA
four: ,NA,NA
zero  == @     one == !     two == #      three == $,NA,NA
Here is a number written in that system:     ,NA,NA
!$@#,NA,NA
 !$@# == !×(!@),$,NA
 + $×(!@),#,NA
 + @×(!@),!,NA
 + #×(!@),@,NA
The base in this system is written ,NA,NA
!@,NA,NA
 which uses the digits of the system to mean one times ,NA,NA
the first power of the base plus zero times the zero,th,NA
 power of the base. ,NA,NA
"This example illustrates that positional notation can be used without the usual digits 0, 1, 2, ",NA,NA
"..., 9. If the base is B, then B digit-like symbols are needed. ",NA,NA
QUESTION 11:,NA,NA
(Frequent Midterm Question: ) What is the base ten representation of the ,NA,NA
number? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_11.html [7/8/2545 18:21:53],NA
A good answer might be: ,NA,NA
!$@# = ! × (!@),$,NA
 + $ × (!@),#,NA
 + @ × (!@),!,NA
 + # × (!@),@,NA
= ,NA,NA
1 × 4,3,NA
+ ,NA,NA
3 × 4,2,NA
+ ,NA,NA
0 × 4,1,NA
+ ,NA,NA
2 × 4,0,NA
= ,NA,NA
1 × 64,NA,NA
+ ,NA,NA
3 × 16 ,NA,NA
+ ,NA,NA
0 × 4 ,NA,NA
+ ,NA,NA
2 × 1 ,NA,NA
= ,NA,NA
64,NA,NA
+ ,NA,NA
48 ,NA,NA
+ ,NA,NA
0 ,NA,NA
+ ,NA,NA
2 ,NA,NA
= ,NA,NA
114,NA,NA
Bit Patterns,NA,NA
"Bit patterns ... 10110110110 ... are sloppily called ""binary numbers"" even when they ",NA,NA
represent other things (such as characters or machine instructions). But soon we shall use ,NA,NA
bit patterns to represent numbers. ,NA,NA
Consider base two. ,NA,NA
QUESTION 12:,NA,NA
Fill in the blanks in the rules for binary positional notation: ,NA,NA
1.  The base is _______. ,NA,NA
"2.  There are _______ ""digits"": ____, ____. ",NA,NA
"3.  Positions correspond to integer powers of ____, starting with power ____ at the ",NA,NA
"rightmost digit, and increasing right to left. ",NA,NA
4.  The digit placed at a position shows how many times that power of ____is included ,NA,NA
in the number.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_12.html [7/8/2545 18:22:00],NA
A good answer might be:,NA,NA
1.  The base is ,NA,NA
2,NA,NA
. ,NA,NA
2.  There are ,NA,NA
2,NA,NA
" ""digits"": ",NA,NA
0,NA,NA
", ",NA,NA
1,NA,NA
. ,NA,NA
3.  Positions correspond to integer powers of ,NA,NA
two,NA,NA
", starting with power ",NA,NA
0,NA,NA
 at the rightmost ,NA,NA
"digit, and increasing right to left. ",NA,NA
4.  The digit placed at a position shows how many times that power of ,NA,NA
two,NA,NA
 is included in ,NA,NA
the number.,NA,NA
Representing Numbers using Base Two ,NA,NA
"From the rules for positional notation there are two digits. Usually ""0"" and ""1"" are chosen. In ",NA,NA
"this system the base, two, will be written ""10"", the first power of two plus zero times the ",NA,NA
zero,th,NA
 power of two. Each place in a representation stands for a power of two. Often this is ,NA,NA
called the ,NA,NA
binary,NA,NA
 system. Here is an example: ,NA,NA
1011 = 1 × (10),11,NA
 + 0 × (10),10,NA
 + 1 × (10),1,NA
 + 1 × (10),0,NA
= ,NA,NA
1 × 2,3,NA
+ ,NA,NA
0 × 2,2,NA
+ ,NA,NA
1 × 2,1,NA
+ ,NA,NA
1 × 2,0,NA
= ,NA,NA
1 × 8 ,NA,NA
+ ,NA,NA
0 × 4 ,NA,NA
+ ,NA,NA
1 × 2 ,NA,NA
+ ,NA,NA
1 × 1 ,NA,NA
= ,NA,NA
8 ,NA,NA
+ ,NA,NA
0 ,NA,NA
+ ,NA,NA
2 ,NA,NA
+ ,NA,NA
1 ,NA,NA
= ,NA,NA
11,NA,NA
"The first line above is written entirely in base two, and shows what the string ""1011"" means ",NA,NA
with positional notation. Both base its powers are written in base two. The next line writes ,NA,NA
"the base and its powers using decimal notation (this is what is usually done, even though it ",NA,NA
mixes notation). The remaining lines finish converting the base into decimal. ,NA,NA
QUESTION 13:,NA,NA
What is 0110 (binary representation) in base ten? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_13.html [7/8/2545 18:22:25],NA
A good answer might be:,NA,NA
0110 = 0 × 2,3,NA
  + 1 × 2,2,NA
 + 1 × 2,1,NA
 + 0 × 2,0,NA
 = 0 + 4 + 2 + 0,NA,NA
 = 6,NA,NA
Powers of Two,NA,NA
"In a binary representation a particular power of two is either included in the sum or not, ",NA,NA
"since the digits are either ""1"" or ""0"". In converting representations, it is convenient to have a ",NA,NA
table. ,NA,NA
Power of 2,NA,NA
10,NA,NA
9,NA,NA
8 ,NA,NA
7,NA,NA
6,NA,NA
5,NA,NA
4,NA,NA
3 ,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
Decimal,NA,NA
1024,NA,NA
512,NA,NA
256 ,NA,NA
128,NA,NA
64,NA,NA
32,NA,NA
16,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1 ,NA,NA
Include?,NA,NA
Here is an 8-bit pattern: 0110 1001. If it represents a number (using binary positional ,NA,NA
"notation), convert the notation to decimal by including the powers of two matching a ""1"" bit. ",NA,NA
QUESTION 14:,NA,NA
"Copy 1s from the bit pattern to the last row of the table, starting at the right. ",NA,NA
Compute the sum of the corresponding decimal numbers. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_14.html [7/8/2545 18:22:53],NA
Here is an 8-bit pattern: 0110 1001. ,NA,NA
A good answer might be:,NA,NA
Power of 2,NA,NA
10,NA,NA
9,NA,NA
8 ,NA,NA
7,NA,NA
6,NA,NA
5,NA,NA
4,NA,NA
3 ,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
Decimal,NA,NA
1024,NA,NA
512,NA,NA
256 ,NA,NA
128,NA,NA
64,NA,NA
32,NA,NA
16,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1 ,NA,NA
Include?,NA,NA
1 ,NA,NA
1 ,NA,NA
1 ,NA,NA
1 ,NA,NA
Sum = 128 + 64 + 8 + 1 = 201,10,NA
End of the Chapter,NA,NA
You have reached the end this chapter. You are now in a position to review the following ,NA,NA
subjects. ,G,NA
Number vs. its ,NA,NA
representation ,G,NA
Positional ,NA,NA
number representation ,G,NA
Decimal ,NA,NA
number representation ,G,NA
Changing bases,NA,NA
 of a representation ,G,NA
Binary,NA,NA
 number representation ,G,NA
Power of two ,NA,NA
table.,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-06/ass06_15.html [7/8/2545 18:22:55],NA
Chapter 7 — Binary and Hex Integer ,NA,NA
Representation ,NA,NA
Patterns of bits can represent many different things. Anything that can be represented with ,NA,NA
any kind of symbols can be represented with bit patterns. This chapter shows how bit ,NA,NA
patterns are used to represent integers. ,G,NA
Left and right shifts.,G,NA
Unsigned binary representation.,G,NA
Familiar binary integers.,G,NA
Hexadecimal representation.,G,NA
Equivalence of hexadecimal representation and bit pattern names. ,G,NA
Converting representations from hexadecimal to binary.,G,NA
Converting representations from decimal to any base.,NA,NA
QUESTION 1:,NA,NA
A particular number is represented by 1010 (binary representation). What is ,NA,NA
the number represented in base ten? ,NA,NA
A good answer might be:,NA,NA
1010 = 1 × 2,3,NA
  + 0 × 2,2,NA
 + 1 × 2,1,NA
 + 0 × 2,0,NA
 = 8 + 0 + 2 + 0,NA,NA
 = 10,NA,NA
1010 = 10,NA,NA
10,NA,NA
"It is convenient to remember the above fact. If you know it, then it takes just a moment to ",NA,NA
recognize 1001 = 9,10,NA
", 1011 = 11",10,NA
", and others. To convert larger binary representations to ",NA,NA
"decimal representation, use a table. You can create this table from scratch. ",NA,NA
Power of ,NA,NA
2,NA,NA
10,NA,NA
9,NA,NA
8 ,NA,NA
7,NA,NA
6,NA,NA
5,NA,NA
4,NA,NA
3 ,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
Decimal,NA,NA
1024,NA,NA
512,NA,NA
256 ,NA,NA
128,NA,NA
64,NA,NA
32,NA,NA
16,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1 ,NA,NA
Include?,NA,NA
1 ,0,NA
1 ,0,NA
1 ,0,NA
1 ,0,NA
Now think of the bits of the binary representation as turning on or off the numbers to include ,NA,NA
"in the sum. For example, with ",NA,NA
1010 1010,NA,NA
" the various powers are turned on, as above. ",NA,NA
QUESTION 2:,NA,NA
A particular number is represented by 1010 1010 (binary representation). ,NA,NA
What is the number represented in base ten? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_2.html [7/8/2545 18:23:07],NA
Power of ,NA,NA
2,NA,NA
10,NA,NA
9,NA,NA
8 ,NA,NA
7,NA,NA
6,NA,NA
5,NA,NA
4,NA,NA
3 ,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
Decimal,NA,NA
1024,NA,NA
512,NA,NA
256 ,NA,NA
128,NA,NA
64,NA,NA
32,NA,NA
16,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1 ,NA,NA
Include?,NA,NA
1 ,0,NA
1 ,0,NA
1 ,0,NA
1 ,0,NA
A good answer might be: ,NA,NA
"Adding up the ""turned on"" powers of two gives: ",NA,NA
   128 + 32 + 8 + 2 = 170,NA,NA
10,NA,NA
Favorite Binary Numbers,NA,NA
Here is a list of positive integers represented in both 8-bit binary and decimal. You will ,NA,NA
"encounter these patterns frequently. For now, only positive integers are being represented. ",NA,NA
Negative integers come later. ,NA,NA
Binary,NA,NA
Decimal,NA,NA
Notes,NA,NA
0000 0000,NA,NA
0,NA,NA
0000 0001,NA,NA
1,NA,NA
 2,0,NA
 = 1 = 2,1,NA
 - 1,NA,NA
0000 0011,NA,NA
3,NA,NA
 2,1,NA
 + 2,0,NA
 = 3 = 2,2,NA
 - 1 ,NA,NA
0000 0100,NA,NA
4,NA,NA
 2,2,NA
0000 0111,NA,NA
7,NA,NA
 2,2,NA
 + 2,1,NA
 + 2,0,NA
 = 2,3,NA
 - 1 ,NA,NA
0000 1000,NA,NA
8,NA,NA
 2,3,NA
0000 1111,NA,NA
15,NA,NA
 2,4,NA
 - 1 ,NA,NA
0001 0000,NA,NA
16,NA,NA
 2,4,NA
0001 1111,NA,NA
31,NA,NA
 2,5,NA
 - 1 ,NA,NA
0010 0000,NA,NA
32,NA,NA
 2,5,NA
0111 1111,NA,NA
?,NA,NA
 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_3.html (1 of 2) [7/8/2545 18:23:16],NA
Look at the table and see if you can discover a useful pattern. ,NA,NA
QUESTION 3:,NA,NA
An important number was left out of the table. What do you suppose is the ,NA,NA
decimal equivalent of 0111 1111 ? ,NA,NA
1000 0000,NA,NA
128,NA,NA
 2,"7
  
  
  
  
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_3.html (2 of 2) [7/8/2545 18:23:16]",NA
A good answer might be: ,NA,NA
"You may have noticed that 0111 1111 is one less than 1000 0000, which is 128. So ",NA,NA
0111 1111 represents of 127,10,NA
. ,NA,NA
Further Famous Bit Patterns,NA,NA
"Say that a number is represented with all ones right to left and then all zeros, like this: 0111 ",NA,NA
"1111. To find the decimal equivalent, turn on the next highest bit and turn off all others and ",NA,NA
"subtract one, like this: 1000 0000 - 1. Now look up the decimal value corresponding to the ",NA,NA
"single ""on"" bit: 1000 0000 - 1 = 128 -1 = 127. ",NA,NA
Here is another table of bit patterns (regarded as representing positive integers) and their ,NA,NA
decimal equivalent. See if you can notice something interesting. ,NA,NA
 Binary        Decimal       Notes,NA,NA
---------       -------      ------,NA,NA
0000 0001          1 ,NA,NA
0000 0010          2          1 × 2 ,NA,NA
0000 0100          4          2 × 2 ,NA,NA
0000 1000          8          4 × 2,NA,NA
0000 0011          3 ,NA,NA
0000 0110          6          3 × 2 ,NA,NA
0000 1100         12          6 × 2 ,NA,NA
0001 1000         24         12 × 2,NA,NA
0000 0111          7 ,NA,NA
0000 1110         14          7 × 2 ,NA,NA
0001 1100         28         14 × 2 ,NA,NA
0011 1000         56         28 × 2,NA,NA
QUESTION 4: ,NA,NA
The bit pattern 0011 0010 represents 50,10,NA
. What bit pattern represents ,NA,NA
100,10,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_4.html [7/8/2545 18:23:24],NA
A good answer might be: ,NA,NA
0011 0010  =  50,10,NA
    ;  so 0110 0100  =  100,10,NA
Left Shift,NA,NA
Useful Fact:,NA,NA
 If the number ,NA,NA
N,NA,NA
 is represented by a bit pattern ,NA,NA
X,NA,NA
", then ",NA,NA
X0,NA,NA
 represents ,NA,NA
2N,NA,NA
. ,NA,NA
If ,NA,NA
00110010 ,NA,NA
represents 50,10,NA
" , then ",NA,NA
001100100 ,NA,NA
represents 100,10,NA
. Often you keep the same ,NA,NA
number of bits in the shifted pattern like this: ,NA,NA
01100100,NA,NA
 represents 100,10,NA
. ,NA,NA
"This is called ""shifting left"" by one bit. It is often used in hardware to multiply by two. If you ",NA,NA
must keep the same number of bits (as is usually true for computer hardware) then make ,NA,NA
"sure that no ""1"" bits are lost on the left. ",NA,NA
QUESTION 5:,NA,NA
"With 8 bits, there are 2",8,NA
 patterns. What is the largest positive integer that can ,NA,NA
be represented in 8 bits using base two? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_5.html [7/8/2545 18:23:33],NA
A good answer might be: ,NA,NA
2,8,NA
 - 1  =  256 - 1  =  255.  One of the 256 patterns (0000 0000) is used for zero. ,NA,NA
Largest Positive Integer in N Bits,NA,NA
The representation scheme we are looking at is called ,NA,NA
unsigned binary,NA,NA
 because no ,NA,NA
"negative numbers are represented. Often when people say ""binary number"" this is what ",NA,NA
they mean. Here are some of its characteristics: ,NA,NA
"1.  With N bits and base two representation, the integers 0, 1, 2, ... , 2",N,NA
 - 1 can be ,NA,NA
represented. ,H,NA
"So, for instance, with 8 bits, the integers 0, 1, ..., 2",8,NA
 - 1 can be represented. This is ,NA,NA
0 ... 255. ,NA,NA
"2.  With N bits, zero is represented by 0....0....0 (all 0's). ",NA,NA
3.  (2,N,NA
 - 1) is represented by 1....1....1 (all 1's). ,NA,NA
These facts are ,NA,NA
NOT always true,NA,NA
 for other representation schemes! Know what scheme is ,NA,NA
used before you decide what a pattern represents. ,NA,NA
QUESTION 6:,NA,NA
"Without doing any calculation, which of the following is the decimal ",NA,NA
equivalent of 1111 1111 1111? ,G,NA
2048 ,G,NA
4095 ,G,NA
16384 ,G,NA
18432,NA,NA
Look at fact 3 in the list and think a bit.,NA,NA
"Hint: Actually, you should think about a bit.",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_6.html (1 of 2) [7/8/2545 18:23:39],NA
A good answer might be: ,NA,NA
4095,NA,NA
Hopefully you did something clever: you realized that the represented number is 2,N,NA
 - 1 ,NA,NA
which must be an odd number. ,NA,NA
(,NA,NA
 2,N,NA
 means 2 × 2 × 2 ... × 2 it must be even. So 2,N,NA
 - 1 ,NA,NA
must be odd. ,NA,NA
) ,NA,NA
So you picked the only odd number in the list. Or else you ignored the question. ,NA,NA
Base 16 Representation,NA,NA
Rules for Positional Notation. ,NA,NA
1.  The base B is (usually) a positive integer. ,NA,NA
"2.  There are B ""digits"" representing zero up to (B minus one). ",NA,NA
"3.  Positions correspond to integer powers of B, starting with power zero, and increasing ",NA,NA
right to left. ,NA,NA
4.  The digit placed at a position shows how many times that power of B is included in the ,NA,NA
number. ,NA,NA
Rule 1 says any positive integer can be used as a base. Let's use sixteen as a base. Rule 2 ,NA,NA
says we need sixteen symbols to use as digits. Here is the usual choice: ,NA,NA
0,NA,NA
1,NA,NA
2,NA,NA
3,NA,NA
4,NA,NA
5,NA,NA
6,NA,NA
7,NA,NA
8,NA,NA
9,NA,NA
A,NA,NA
B,NA,NA
C,NA,NA
D,NA,NA
E,NA,NA
F,NA,NA
zero one,NA,NA
two,NA,NA
three four,NA,NA
five,NA,NA
six,NA,NA
seven eight nine ten,NA,NA
eleven twelve thirteen forteen fifteen,NA,NA
"Since there are only ten of the usual digits, letters are used for the remaining six hex ",NA,NA
"""digits"". ",NA,NA
Base sixteen representation is called the ,NA,NA
Hexadecimal,NA,NA
" system, sometimes further ",NA,NA
shortened to ,NA,NA
Hex,NA,NA
. ,NA,NA
QUESTION 7:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_7.html (1 of 2) [7/8/2545 18:23:44],NA
Fill in the blanks with BASE SIXTEEN digits ,NA,NA
31A (base sixteen)   = ,NA,NA
 ____ × sixteen,2,NA
 +____ × sixteen,1,NA
 +  ____ × sixteen,"0
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_7.html (2 of 2) [7/8/2545 18:23:44]",NA
A good answer might be: ,NA,NA
31A (base sixteen)   = ,NA,NA
3,NA,NA
 × sixteen,2,NA
 + ,NA,NA
1,NA,NA
 × sixteen,1,NA
 + ,NA,NA
A,NA,NA
 × sixteen,0,NA
Converting a Rep,NA,NA
n,NA,NA
 to Decimal Rep,NA,NA
n,NA,NA
"As usual, to represent the number using base ten, write the base and ""digits"" in base ten, ",NA,NA
and then do the arithmetic: ,NA,NA
31A (base sixteen) = 3 × sixteen,2,NA
 + 1 × sixteen,1,NA
 + A × sixteen,0,NA
 = 3 × 16,2,NA
 + 1 × 16,1,NA
 +  10 × 16,0,NA
 = 3 × 256 + 1 × 16 +  10 × 1  =  794,10,NA
You don't have to remember powers of 16 to do this conversion. All you need is powers of ,NA,NA
"2. For example, 16",2,NA
   =   2,4,NA
 ×2,4,NA
   =   2,8,NA
   =   256. ,NA,NA
As another example:   16,3,NA
   =   2,4,NA
 ×2,4,NA
 ×2,4,NA
   =   2,12,NA
   =   2,2,NA
 ×2,10,NA
   =   4K ,NA,NA
QUESTION 8:,NA,NA
More practice:   What integer is represented by 1B2 (base sixteen) ? ,NA,NA
1B2 = ____  × sixteen,2,NA
 + ____ × sixteen,1,NA
 +  ____ × sixteen,0,NA
1B2 = ____,10,NA
 × 16,2,NA
 + ____,10,NA
 × 16,1,NA
 +  ____,10,NA
 × 16,0,NA
1B2 = ____,10,NA
 × ____,10,NA
 + ____,10,NA
 × ____,10,NA
 +  ____,10,NA
 × ____,10,NA
1B2 = ____,"10
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_8.html [7/8/2545 18:23:48]",NA
A good answer might be:,NA,NA
1B2 =  1 × sixteen,2,NA
 + B × sixteen,1,NA
 +  2 × sixteen,0,NA
1B2 =  1,10,NA
 × 16,2,NA
 + 11,10,NA
 × 16,1,NA
 + 2,10,NA
 × 16,0,NA
1B2 =  1,10,NA
 × 256,10,NA
 + 11,10,NA
 × 16,10,NA
 + 2,10,NA
 ×1,10,NA
1B2 =  256,10,NA
 + 176,10,NA
 + 2,10,NA
1B2 =  434,10,NA
Shifting by one Place ,NA,NA
You probably know how in base ten to multiply a number by 10: add a zero to the end. So ,NA,NA
83 × 1,NA,NA
0,NA,NA
   =   83,NA,NA
0,NA,NA
. This works because: ,NA,NA
83       =     8 × 10,1,NA
 + 3 × 10,0,NA
83  × 10 =  ,NA,NA
(,NA,NA
  8 × 10,1,NA
 + 3 × 10,0,NA
),NA,NA
 × 10,NA,NA
 =     8 × 10,2,NA
 + 3 × 10,1,NA
 =     830,NA,NA
"The same trick works in any base: if a number is represented by (say) XYZ in base B, then ",NA,NA
XYZ0 represents that number times B. ,NA,NA
QUESTION 9:,NA,NA
What is sixteen times 8B3 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_9.html [7/8/2545 18:24:07],NA
What is sixteen times 8B3 ? ,NA,NA
A good answer might be: ,NA,NA
8B30 ,NA,NA
Shifting by one Place in Base Sixteen ,NA,NA
Adding a 0 to the end of an integer written in base sixteen multiplies the integer by sixteen. ,NA,NA
To multiply an integer by sixteen,N,NA
", add N zeros on the right: ",NA,NA
8B3 × 10,3,NA
 = 8B3000      (Here 10 means sixteen.),NA,NA
Erasing a digit on the right divides an integer by sixteen (integer division). So 8B3 div ,NA,NA
sixteen   =   8B (with a remainder of 3). ,NA,NA
QUESTION 10:,NA,NA
A (base 16)   =   ________ (base 10)   =   ________ (base 2) ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_10.html [7/8/2545 18:24:15],NA
A good answer might be: ,NA,NA
A (base 16)   =   10 (base 10)   =   1010 (base 2) ,NA,NA
Rep,NA,NA
n,NA,NA
" in Base Sixteen, Ten, and Two ",NA,NA
Here is a chart that shows integers zero through fifteen and their positional representation ,NA,NA
"using base sixteen, ten, and two. For example, 0110",2,NA
   =   2,2,NA
 + 2,1,NA
   =   6,ten,NA
   =   6,sixteen,NA
Rep,n,NA
 in ,NA,NA
base sixteen,NA,NA
Rep,n,NA
 in ,NA,NA
base ten,NA,NA
Rep,n,NA
 in ,NA,NA
base two,NA,NA
Rep,n,NA
 in ,NA,NA
base sixteen,NA,NA
Rep,n,NA
 in ,NA,NA
base ten,NA,NA
Rep,n,NA
 in ,NA,NA
base two,NA,NA
0,NA,NA
0,NA,NA
0000,NA,NA
8,NA,NA
8,NA,NA
1000,NA,NA
1,NA,NA
1,NA,NA
0001,NA,NA
9,NA,NA
9,NA,NA
1001,NA,NA
2,NA,NA
2,NA,NA
0010,NA,NA
A,NA,NA
10,NA,NA
1010,NA,NA
3,NA,NA
3,NA,NA
0011,NA,NA
B,NA,NA
11,NA,NA
1011,NA,NA
4,NA,NA
4,NA,NA
0100,NA,NA
C,NA,NA
12,NA,NA
1100,NA,NA
5,NA,NA
5,NA,NA
0101,NA,NA
D,NA,NA
13,NA,NA
1101,NA,NA
6,NA,NA
6,NA,NA
0110,NA,NA
E,NA,NA
14,NA,NA
1110,NA,NA
7,NA,NA
7,NA,NA
0111,NA,NA
F,NA,NA
15,NA,NA
1111,NA,NA
QUESTION 11:,NA,NA
"What is the name of this pattern of four bits, using the pattern naming ",NA,NA
scheme: 1010 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_11.html [7/8/2545 18:24:33],NA
What is the name of this 4-bit pattern: 1010 ? ,NA,NA
A good answer might be: ,NA,NA
A • this is the name of the pattern the four bits make. ,NA,NA
Base 16 Rep,NA,NA
n,NA,NA
 and 4-bit Pattern Names ,NA,NA
The name of the pattern 1010 is the same as the hex digit that corresponds to the number ,NA,NA
represented by 1010,2,NA
. ,NA,NA
"When a 4-bit pattern is regarded as a number in (unsigned) base two, that number in hex is ",NA,NA
the same as the bit pattern name. ,NA,NA
Base Sixteen Digits:,NA,NA
When describing Bit Patterns:,NA,NA
Hex digits in Binary,"0  is a digit, 
  
  representing  
 zero. 
  
 .
  
 .
  
 .
  
 A  is a digit, 
  
  representing   
 ten. 
  
 .
  
 .
  
 .
  
 F  is a digit, 
  
  representing   
 fifteen. 
  
  
  
 0  is the name 
  
  of the pattern 
  
  0000 
  
 .
  
 .
  
 .
  
 A  is the name 
  
  of the pattern 
  
  1010 
  
 .
  
 .
  
 .
  
 F  is the name 
  
  of the pattern 
  
  1111
  
  
  
 0  in 4-bit 
  
  
  binary is 
  
  
  0000 
  
 .
  
 .
  
 .
  
 A  in 4-bit 
  
  
  binary is 
  
  
  1010 
  
 .
  
 .
  
 .
  
 F  in 4-bit 
  
  binary is 
  
  1111",NA
The name of a 4-bit pattern (regarded as an abstract pattern) is the same as the ,NA,NA
hexadecimal digit whose representation in binary is that 4-bit pattern. This is not accidental. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_12.html (1 of 2) [7/8/2545 18:24:36],NA
QUESTION 12:,NA,NA
Here is an integer represented in base two: 1011. What is the representation ,NA,NA
in base two of the number times sixteen? ,NA,NA
Hint: remember that trick with appending zeros. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_12.html (2 of 2) [7/8/2545 18:24:36],NA
A good answer might be: ,NA,NA
1011 0000. Appending four zeros multiplies the number being represented by 2,4,NA
. ,NA,NA
Converting Hex Rep,NA,NA
n,NA,NA
 into Binary Rep,NA,NA
n,NA,NA
It is easy to convert between base sixteen and base two rep,n,NA
: ,G,NA
(In base two) Shifting left by four bits is equivalent to multiplication by sixteen.,G,NA
(In base hex) Shifting left by one digit is equivalent to multiplication by sixteen. To see ,NA,NA
"how this works, look at this integer represented in base two and in base sixteen: ",NA,NA
base ,NA,NA
two           base sixteen ,NA,NA
1010        =      A ,NA,NA
Now multiply each by sixteen: ,NA,NA
base two           base sixteen ,NA,NA
1010 0000   =      A0,NA,NA
"Groups of four bits (starting from the right) match powers of sixteen, so each group of four ",NA,NA
bits matchs a digit of the hexadecimal rep,n,NA
. Let us rewrite the integer C6D in binary: ,NA,NA
C6D  =    C × sixteen,2,NA
 +    6 × sixteen,1,NA
  +    D × sixteen,0,NA
 =    C × (2,4,NA
),2,NA
    +    6 × (2,4,NA
),1,NA
      +    D × (2,4,NA
),0,NA
 = 1100 × (2,4,NA
),2,NA
    + 0110 × (2,4,NA
),1,NA
      + 1101 × (2,4,NA
),0,NA
 = 1100 ×  2,8,NA
      + 0110 ×  2,4,NA
        + 1101 × 1  ,NA,NA
"Using the idea that each multiplication by two is equivalent to appending a zero to the right, ",NA,NA
this is: ,NA,NA
 = 1100 0000 0000  + 0110 0000         + 1101  ,NA,NA
C6D  = 1100 0110 1101,NA,NA
"Each digit of hex can be converted into a 4-bit binary number, each place of a hex number ",NA,NA
stands for a power of 2,4,NA
. It stands for a number of 4-bit left shifts. So you can convert a ,NA,NA
hexadecimal representation of a number into an unsigned binary represenation directly by ,NA,NA
replacing each hex digit with its 4-bit binary equivalent. For example: ,NA,NA
 1    A    4    4    D      (Hex    Rep,n,NA
) ,NA,NA
0001 1010 0100 0100 1101      (Binary Rep,n,NA
) ,NA,NA
QUESTION 13:,NA,NA
What is the name of the binary pattern   0001 1010 0100 0100 1101 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_13.html (2 of 2) [7/8/2545 18:24:51],NA
A good answer might be: ,NA,NA
1A44D ,NA,NA
Pattern Name and Number Rep,NA,NA
n,NA,NA
The pattern name of a bit pattern is the same as the base sixteen representation of the ,NA,NA
number that the bit pattern represents in base two. ,NA,NA
Converting between base 16 representation and base 2 representation is easy because 16 ,NA,NA
"is a power of 2. Another base where this is true is base 8 (octal), since 8 is 2",3,NA
". In base 8, the ",NA,NA
"digits are 0, 1, 2, 3, 4, 5, 6, 7. The binary equivalents of the digits are 000, 001, 010, 011, ",NA,NA
"100, 101, 110, 111. ",NA,NA
"Each place in a base 8 number corresponds to a left shift of 3 places, in the bit pattern of its ",NA,NA
binary rep,n,NA
. ,NA,NA
"Be careful: in some computer languages (Java and C, for instance) a number written with a ",NA,NA
"leading zero signifies octal. So 0644 means base eight, and 644 means base ten, and ",NA,NA
0x644 means base sixteen. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_14.html (1 of 2) [7/8/2545 18:25:05],NA
QUESTION 14:,NA,NA
What is the binary equivalent of 4733 octal? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_14.html (2 of 2) [7/8/2545 18:25:05],NA
A good answer might be: ,NA,NA
100 111 011 011,NA,NA
Converting between Representations,NA,NA
"With effort, you could directly translate between octal and hex notation. But it is much easier ",NA,NA
to use binary as an intermediate: ,NA,NA
octal  <——> binary  <——> hexadecimal,NA,NA
You can convert a representation of a number in base B directly to a representation in base ,NA,NA
Y. But it is usually more convenient (for paper and pencil calculations) to use decimal or ,NA,NA
binary as an intermediate: ,NA,NA
Base B  <——> Decimal  <——> Base Y,NA,NA
Base B  <——> Binary   <———> Base Y,NA,NA
QUESTION 15:,NA,NA
Change the representation of this number from hexadecimal to octal (base ,NA,NA
8): ,NA,NA
0x1A4,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_15.html [7/8/2545 18:25:11],NA
A good answer might be:,NA,NA
 binary    ,NA,NA
 hex      groups of four ,NA,NA
0x1A4  =  0001 1010 0100 =,NA,NA
 binary          octal,NA,NA
 ungrouped       groups of three,NA,NA
000110100100  =  000 110 100 100   =  0644,eight,NA
"Remember to group bits starting from the right. If the left group is one or two bits short, ",NA,NA
add zero bits on the left as needed. ,NA,NA
Decimal to base B ,NA,NA
You know how to convert from Base B to Decimal. Now for ,NA,NA
converting from Decimal to base B. The algorithm converts ,NA,NA
number,NA,NA
 from base 10 representation to base B ,NA,NA
respresentation. ,NA,NA
div,NA,NA
 means integer division and ,NA,NA
mod,NA,NA
 means modulo. ,NA,NA
number ,NA,NA
div B,NA,NA
 is the number of times B goes into number. ,NA,NA
number mod ,NA,NA
B,NA,NA
 is the left-over amount. For example 15 div 6 = 2 and 15 ,NA,NA
mod 6 = 3. ,NA,NA
Here is an example: convert 54,10,NA
 to hex representation. The ,NA,NA
base is 16. The first execution of the loop body calculates ,NA,NA
digit[0],NA,NA
 the right-most digit of the hex number. ,NA,NA
Algorithm: Convert a number ,NA,NA
from base 10 to base B rep,"n
  
  
 place  = 0; 
  
 number = number to be converted
  
 while (number > 0 ) 
  
 {
  
  digit[place] = number mod B ;  
 number       = number div B ; 
 place        = place + 1 ; 
  
 }",NA
QUESTION 16:,NA,NA
What is digit[ 0 ] = 54 mod 16 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_16.html (1 of 2) [8/8/2545 13:14:04],NA
What is number = 54 div 16 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_16.html (2 of 2) [8/8/2545 13:14:04],NA
A good answer might be: ,NA,NA
Since 54 = 16 × 3 with a remainder of 6: ,NA,NA
"digit[ 0 ] = 54 mod 16 = 6, ",NA,NA
number = 54 div 16 = 3 ,NA,NA
Hex Digits from Right to Left ,NA,NA
The first execution of the loop body calculates the digit for ,NA,NA
"place 0, the rightmost digit. Notice what has happened: the ",NA,NA
first execution says that: ,NA,NA
54,10,NA
   =   3 × 16,1,NA
 + 6 × 16,0,NA
The first execution of the loop body calculates the digit for ,NA,NA
"place 0, the rightmost digit. The next execution yields the digit ",NA,NA
for place 1. This calculates digit[1] = 6 mod 16 = 6 and ,NA,NA
"number = 3 div 16 = 0. After this the algorithm is done, and ",NA,NA
the result is 54,10,NA
   =   0x36 ,NA,NA
Algorithm: Convert a number ,NA,NA
from base 10 to base B rep,"n
  
  
 place  = 0; 
  
 number = number to be converted
  
 while (number > 0 ) 
  
 {
  
  digit[place] = number mod B ;  
 number       = number div B ; 
 place        = place + 1 ; 
  
 }",NA
If you are enthused about this (could happen) you might wish to use mathematical induction ,NA,NA
to prove that the algorithm is correct. A normal person would just prefer another example. ,NA,NA
QUESTION 17:,NA,NA
Convert 247,10,NA
 to hexadecimal. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_17.html [8/8/2545 13:14:10],NA
A good answer might be:,NA,NA
number = 247 ,NA,NA
247 div 16 = 15 r 7    so  digit[ 0 ] = 7,NA,NA
number =  15,NA,NA
 15 div 16 =  0 r 15   so  digit[ 1 ] = F ,NA,NA
" (""15"" is in base 10, ",NA,NA
" ""F"" is the hex digit)",NA,NA
Result: 247,10,NA
 = 0xF7,NA,NA
Another Conversion,NA,NA
Checking the result: 0xF7  =  F × sixteen + 7 × 1  =  15 × 16 + 7  =  240 + 7 = 247,10,NA
The algorithm can be described as: ,NA,NA
Divide the number by the base. The remainder is the ,NA,NA
digit. The quotient becomes the number. Repeat.,NA,NA
 The digits come out right to left. ,NA,NA
Here is another base conversion. Find pencil and paper and try it. ,NA,NA
QUESTION 18:,NA,NA
Convert 1033,10,NA
 to hex. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_18.html [8/8/2545 13:16:17],NA
A good answer might be:,NA,NA
0x904 ,NA,NA
1033 div 16 = 64 r 9;  digit[0] = 9,NA,NA
 64 div 16 =  4 r 0;  digit[1] = 0,NA,NA
 4 div 16 =  0 r 4;  digit[2] = 4,NA,NA
Decimal to base 5,NA,NA
The conversion algorithm works to convert a decimal representation of a number to any ,NA,NA
base. Here is a conversion of 1033,10,NA
 to base 5: ,NA,NA
 ___206___  r 3,NA,NA
 5 | 1033,NA,NA
 ____41___  r 1,NA,NA
 5 |  206,NA,NA
 _____8___  r 1,NA,NA
 5 |   41,NA,NA
 _____1___  r 3,NA,NA
 5 |    8,NA,NA
 _____0___  r 1,NA,NA
 5 |    1   ,NA,NA
So ,NA,NA
1033,NA,NA
10,NA,NA
 = 13113,NA,NA
5,NA,NA
 (the first digit produced is the rightmost). Checking the results: ,NA,NA
13113,5,NA
  = 1 × 5,4,NA
   + 3 × 5,3,NA
   + 1 × 5,2,NA
  + 1 × 5,1,NA
 + 3 × 5,0,NA
 ,NA,NA
= 1 × 625 + 3 × 125 + 1 × 25  + 1 × 5   + 3,NA,NA
 = 625     + 375     + 25      + 5       + 3,NA,NA
 = 1033,10,NA
QUESTION 19:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_19.html (1 of 2) [8/8/2545 13:16:32],NA
Convert 100,10,NA
 to base 3. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_19.html (2 of 2) [8/8/2545 13:16:32],NA
A good answer might be:,NA,NA
100,10,NA
 = ,NA,NA
100 div 3 = 33 r 1; ,NA,NA
 33 div 3 = 11 r 0; ,NA,NA
 11 div 3 =  3 r 2;,NA,NA
 3 div 3 =  1 r 0;  ,NA,NA
 1 div 3 =  0 r 1,NA,NA
So 100,10,NA
 = 10201,3,NA
. ,NA,NA
Converting Base 3 to base 7,NA,NA
Checking the answer: ,NA,NA
10201,3,NA
 = 1 × 3,4,NA
 + 0 × 3,3,NA
 + 2 × 3,2,NA
  + 0 × 3,1,NA
 + 1 × 3,0,NA
 ,NA,NA
= 1 × 81 + 0 × 27 + 2 × 9 + 0 × 3 + 1,NA,NA
 = 81 + 18 + 1 = 100,NA,NA
"To convert from a representation in base three to a representation in base seven, use base ",NA,NA
ten as an intermediate: ,NA,NA
____,3,NA
   ———>    ____,10,NA
   ———>   ____,7,NA
QUESTION 20:,NA,NA
What is the base 7 representation of 10201,3,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_20.html [8/8/2545 13:16:54],NA
A good answer might be:,NA,NA
100 div 7 = 14 r 2; ,NA,NA
 14 div 7 =  2 r 0; ,NA,NA
 2 div 7 =  0 r 2;,NA,NA
So 10201,3,NA
 = 100,10,NA
 = 202,7,NA
End of the Chapter,NA,NA
You have reached the end this chapter. You may wish to base your study on a review the ,NA,NA
following. Click on a subject that interests you to go to where it was discussed. To get back ,NA,NA
"here, click on the ""back arrow"" button of your browser. ",G,NA
Familiar binary integers.,G,NA
Shifting left ,NA,NA
a binary pattern. ,G,NA
Unsigned binary representation.,G,NA
Hexadecimal representation.,G,NA
Shifting left ,NA,NA
a hexadecimal pattern. ,G,NA
Equivalence of hexadecimal strings,NA,NA
 and bit pattern names ,G,NA
"Converting representations,",NA,NA
 between base 16 and base 2. ,G,NA
Converting a decimal,NA,NA
 representation to any base. ,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-07/ass07_21.html [8/8/2545 13:17:07],NA
Chapter 8 — BINARY ADDITION and ,NA,NA
TWO's COMPLEMENT,NA,NA
Digital computers use bit patterns to represent many types of objects. Various operations ,NA,NA
can be performed on objects. Computers perform operations on bit patterns. With a good ,NA,NA
"representation scheme, bit patterns represent objects and bit pattern manipulations ",NA,NA
represent operations on objects. ,NA,NA
"An important example of this is the Binary Addition Algorithm, where two bit patterns ",NA,NA
representing two integers are manipulated to create a third pattern which represents the ,NA,NA
sum of the integers. ,G,NA
Single-bit Binary Addition Table.,G,NA
Binary Addition Algorithm.,G,NA
Addition in Hexadecimal Representation.,G,NA
Overflow ,G,NA
Sign-magnitude Representation.,G,NA
Two's complement Representation.,G,NA
How to negate an integer in Two's Complement Representation. ,G,NA
The two's compement sign bit.,G,NA
Overflow detection in unsigned binary.,G,NA
Overflow detection in two's complement binary.,NA,NA
QUESTION 1:,NA,NA
Compute the following. Give the answer in binary notation. ,G,NA
0 + 0 = ? ,G,NA
0 + 1 = ? ,G,NA
1 + 0 = ? ,G,NA
1 + 1 = ?,NA,NA
A good answer might be:,NA,NA
In binary: ,G,NA
0 + 0 = 0 ,G,NA
0 + 1 = 1 ,G,NA
1 + 0 = 1 ,G,NA
1 + 1 = 10,NA,NA
The Binary Addition Algorithm,NA,NA
Here is an important algorithm. All computer scientists and computer engineers know it. It is ,NA,NA
a bit-pattern manipulation procedure that is built into the hardware of (nearly) all computers. ,NA,NA
It is called the ,NA,NA
binary addition algorithm,NA,NA
. ,NA,NA
Let us start by adding 1-bit integers. The operation is performed on three operands (three ,NA,NA
input values). Arrange the bits into a column. The bit at the top of the column is called the ,NA,NA
"""carry into the column"". ",NA,NA
To add two 1-bit,NA,NA
 (representations of) ,NA,NA
integers:,NA,NA
 Count the number of ones in a column and ,NA,NA
write the result in binary. The right bit of the result is placed under the column of bits. The ,NA,NA
"left bit is called the ""carry out of the column"". The following table shows the outcomes with ",NA,NA
all possible operands. ,NA,NA
Binary Addition Table,"the carry into the column 
   
  
  
  
  |
  
   
  
  
  
  | 
  
  1      1      1      1      0      0      0      0  <---  1      
 0      1      0      1      0      1      0   
  
  1      1      0      0      1      1      0      0   
  
  ---    ---    ---    ---    ---    ---    ---    --- 
  
  11     10     10     01     10     01     01     00 
  
   
  
  ^
  
   
  
  
  |
  
   
  the carry out of the column 
  
   
  
   
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_2.html (1 of 2) [7/8/2545 18:26:17]",NA
QUESTION 2:,NA,NA
Perform the following additions: ,NA,NA
 1              0             1,NA,NA
 0              1             1,NA,NA
 1              0             0,NA,NA
---            ---           ---,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_2.html (2 of 2) [7/8/2545 18:26:17],NA
A good answer might be:,NA,NA
 1              0             1,NA,NA
 0              1             1,NA,NA
 1              0             0,NA,NA
---            ---           ---,NA,NA
10             01            10,NA,NA
N-bit Binary Addition Algorithm,NA,NA
Adding a column of bits is as easy as counting. It is also easy to do electronically. When you ,NA,NA
take a course in digital logic you will probably build a circuit to do it. ,NA,NA
"Now let us look at the full, n-bit, binary addition algorithm. The algorithm takes two ",NA,NA
operands,NA,NA
 and produces one result. An operand is the data that an algorithm operates on. ,NA,NA
To add two N-bit,NA,NA
 (representations of) ,NA,NA
integers:,NA,NA
" Proceed from right-to-left, column-by-",NA,NA
"column, until you reach the leftmost column. For each column, perform 1-bit addition. Write ",NA,NA
the carry-out of each column above the column to its left. The bit is the left column's carry-,NA,NA
in. ,"0        10       110       0110 
  
 0110      0110      0110      0110       0110 
  
 0111  ==> 0111  ==> 0111  ==> 0111  ==>  
 0111----      ----      ----      ----       ----
  
  
  
  1        01       101       1101",NA
QUESTION 3:,NA,NA
Confirm that this addition is correct. (1) Check that the binary addition ,NA,NA
"algorithm was performed correctly, then (2) translate the operands into ",NA,NA
"decimal, and then (3) perform the addition in decimal. ",NA,NA
0110   =   _____,"10
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_3.html (1 of 2) [7/8/2545 18:26:23]",NA
0111   =   _____,10,NA
----       -----,NA,NA
1101   =   _____,"10
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_3.html (2 of 2) [7/8/2545 18:26:23]",NA
A good answer might be:,NA,NA
0110   =  6,10,NA
0111   =  7,10,NA
----     ---,NA,NA
1101   = 13,10,NA
A Longer Example ,NA,NA
Here is another example: ,"0           10
  
  0110 1110    0110 1110    0110 1110 + 
 0001 0111    0001 0111    0001 0111 ---
 ------    ---------    ---------
  
   
  1           01
  
  111 110     1111 110    01111 110 
 0110 1110    0110 1110    0110 1110 
 0001 0111    0001 0111    0001 0111 
 ---------    ---------    ---------
  
   
  00 0101     000 0101    1000 0101
  
  110        1 110       11 110
  
  0110 1110    0110 1110    0110 1110 
 0001 0111    0001 0111    0001 0111 
 ---------    ---------    ---------
  
  
  101         0101       0 0101
  
 The carry out of the left column in the final sum 
 can be discarded, in this case. But in general you 
 must be careful with it. See the following pages.",NA
Check the answer by converting to decimal representation and doing the addition in that ,NA,NA
"base (the same numbers are being added, but now represented in a different way, so the ",NA,NA
sum is the same.) ,NA,NA
 01111 110,NA,NA
 0110 1110  =  110,10,NA
 + 0001 0111  =   23,10,NA
 ---------    -----,NA,NA
 1000 0101  =  133,10,NA
QUESTION 4:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_4.html (1 of 2) [7/8/2545 18:26:32],NA
Do the following: ,NA,NA
 10  ,NA,NA
 + 01  ,NA,NA
 ----,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_4.html (2 of 2) [7/8/2545 18:26:32],NA
A good answer might be:,NA,NA
00 ,NA,NA
 10  ,NA,NA
 + 01  ,NA,NA
 ----,NA,NA
11,NA,NA
This is another case where the answer fits into the same number of bits as the numbers ,NA,NA
to add. ,NA,NA
"Details, Details",NA,NA
Here are some details: ,NA,NA
"1.  Usually the operands and the result have a fixed number of bits (usually 8, 16, 32, or ",NA,NA
64). These are the sizes that processors use to represent integers. ,NA,NA
"2.  If the bits in the leftmost columns of the sum are zero, include them in the answer to ",NA,NA
keep the result the same bit-length as the operands.,NA,NA
"3.  Compute the carry-out of the leftmost column, but don't write it as part of the answer ",NA,NA
(because there is no room.),NA,NA
4.  When the bit patterns are regarded as representing positive integers (,NA,NA
unsigned binary ,NA,NA
representation,NA,NA
"), a carry-out of  1  from the leftmost column means the sum does not fit ",NA,NA
into the fixed number of bits. This is called ,NA,NA
Overflow,NA,NA
.,NA,NA
5.  When the bit patterns are regarded as representing positive and negative integers (as ,NA,NA
"described in the last pages of this chapter), then a carry-out of  1  from the leftmost ",NA,NA
column is not necessarily overflow.,NA,NA
QUESTION 5:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_5.html (1 of 2) [7/8/2545 18:26:37],NA
A particular processor chips (say the MIPS R2000) has registers of size 32 ,NA,NA
bits. How many bits does this processor typically use each time binary ,NA,NA
addition is performed? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_5.html (2 of 2) [7/8/2545 18:26:37],NA
A good answer might be: ,NA,NA
32 bits. ,NA,NA
Hex Addition,NA,NA
Here is a problem with 4 bits: ,NA,NA
1,NA,NA
111,NA,NA
 0111,NA,NA
 1001,NA,NA
 ----,NA,NA
 0000 ,NA,NA
Overflow,NA,NA
 was detected.,NA,NA
"Two four-bit numbers are added, but the sum does not fit in four bits. If we were using five ",NA,NA
"bits the sum would be 1 0000. But with four bits there is no room for the significant ""1"". ",NA,NA
"Because the carry out from the most significant column of the sum (the left column) is ""1"", ",NA,NA
the 4-bit result is not valid. ,NA,NA
The electronic circuits of a computer can easily detect overflow by checking if the carry-out ,NA,NA
of the leftmost column is a zero or a one. A program might branch to an error handling ,NA,NA
routine when overflow is detected. ,NA,NA
QUESTION 6:,NA,NA
"Add these numbers, represented in eight bits: ",NA,NA
0010 1100 ,NA,NA
0101 0101,NA,NA
--------- ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_6.html [7/8/2545 18:26:41],NA
A good answer might be:,NA,NA
0 1111 100,NA,NA
 0010 1100,NA,NA
 0101 0101,NA,NA
 ---------,NA,NA
 1000 0001,NA,NA
(No overflow),NA,NA
More Practice,NA,NA
"Practice performing this algorithm mechanically, like a computer. Detect overflow by looking ",NA,NA
at the carry-out of the leftmost column. You don't need to convert the representation to ,NA,NA
decimal. ,NA,NA
QUESTION 7:,NA,NA
"Add these numbers, represented in eight bits: ",NA,NA
0110 1100 ,NA,NA
1001 1111,NA,NA
--------- ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_7.html [7/8/2545 18:26:48],NA
A good answer might be:,NA,NA
1 1111 100 ,NA,NA
 0110 1100,NA,NA
 1001 1111,NA,NA
 ---------,NA,NA
 0000 1011,NA,NA
(overflow detected) ,NA,NA
Hex Addition,NA,NA
Sometimes you need to add two numbers represented in hexadecimal. Usually it is easiest ,NA,NA
to convert to binary representation to do the addition. Then convert back to hexadecimal. ,NA,NA
Remember that converting representations from hexadecimal to binary is easily done by ,NA,NA
using the equivalence of hex digits and bit pattern names. ,NA,NA
QUESTION 8:,NA,NA
Perform the following addition: ,NA,NA
 0F4A,NA,NA
 420B,NA,NA
 ----,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_8.html [7/8/2545 18:26:53],NA
A good answer might be:,NA,NA
 1 11      1  1,NA,NA
 0F4A ,NA,NA
¡,NA,NA
 0000 1111 0100 1010,NA,NA
 420B ,NA,NA
¡,NA,NA
 0100 0010 0000 1011,NA,NA
 ----    --------------------,NA,NA
 0101 0001 0101 0101  ,NA,NA
¡,NA,NA
 0x5155,NA,NA
Additional Addition Practice,NA,NA
The carry out of zero from the left column in the binary addition indicates that the sum can ,NA,NA
be contained in that number of bits ,NA,NA
Sometimes a hex addition problem is easy enough to do without converting to binary: ,NA,NA
 014A,NA,NA
 4203,NA,NA
 ----,NA,NA
 434D,NA,NA
It may be helpful to use your digits (fingers) in doing this: to add A+3 extend three fingers ,NA,NA
"and count ""A... B... C... D"". ",NA,NA
QUESTION 9:,NA,NA
Compute the following sum using 8 bits. Is there overflow? ,NA,NA
 1101 0010,NA,NA
 0110 1101,NA,NA
 ---------,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_9.html [7/8/2545 18:27:06],NA
A good answer might be: ,NA,NA
0011 1111 ,NA,NA
1,NA,NA
1,NA,NA
 1101 0010    210,10,NA
 0110 1101    109,10,NA
 ---------    ---,NA,NA
 0011 1111     63,10,NA
The carry bit of ,NA,NA
1,NA,NA
 indicates ,NA,NA
overflow,NA,NA
. ,NA,NA
Yet More Addition Practice,NA,NA
The ,NA,NA
correct application ,NA,NA
"of the ""Binary Addition Algorithm"" sometimes gives ",NA,NA
incorrect results ,NA,NA
(because of overflow). With paper-and-pencil arithmetic overflow is not a problem because ,NA,NA
you can use as many columns as needed. ,NA,NA
Detecting Overflow with Unsigned Binary,NA,NA
"When the ""Binary Addition Algorithm"" is used with unsigned binary ",NA,NA
"integer representation, the result is CORRECT only if ",NA,NA
the CARRY OUT ,NA,NA
of the high order column is ZERO. ,NA,NA
"But digital computers use fixed bit-lengths for integers, so overflow is possible. For instance ",NA,NA
"the MIPS 3000 processor can represent integers in 8, 16, or 32 bits. When 8-bit operands ",NA,NA
are added overflow is certainly possible. Later MIPS processors include a 64-bit integer data ,NA,NA
"type, but even so, overflow is possible. ",NA,NA
QUESTION 10:,NA,NA
Compute the following sum using 8 bits: ,NA,NA
 0000 0001,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_10.html (1 of 2) [7/8/2545 18:27:50],NA
 1111 1111,NA,NA
 ---------,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_10.html (2 of 2) [7/8/2545 18:27:50],NA
A good answer might be: ,NA,NA
1,NA,NA
1111 111,NA,NA
 0000 0001     1,10,NA
 1111 1111   255,10,NA
 ---------  -----,NA,NA
 0000 0000    00,10,NA
The carry bit of ,NA,NA
1,NA,NA
 out of the high order column (leftmost) indicates an ,NA,NA
overflow,NA,NA
. ,NA,NA
Negative Integers,NA,NA
Unsigned binary,NA,NA
 representation can not be used to represent negative numbers. With paper ,NA,NA
"and pencil numbers, a number is made negative by putting a negative sign in front of it: 17",10,NA
negated = -17,10,NA
. You might hope to do the same with binary: ,NA,NA
0001 1000    negated =   -0001 1000  ???,NA,NA
"Unfortunately, you can't put a negative sign in front of a bit pattern in computer memory. ",NA,NA
Memory holds only patterns of 0's and 1's. Somehow negative integers must be represented ,NA,NA
using bit patterns. But this is certainly possible. Remember those advantages of binary? ,NA,NA
1.  Easy to build.,NA,NA
2.  Unambiguous signals (hence noise immunity).,NA,NA
3.  Can be copied flawlessly.,NA,NA
4.  ,NA,NA
Anything that can be represented with patterns can be represented with patterns ,NA,NA
of bits.,NA,NA
If we can represent negative integers with paper and pencil (thus using patterns) we ,NA,NA
certainly can represent negative integers with patterns of bits. ,NA,NA
QUESTION 11:,NA,NA
Let us say that you need to represent an equal number of positive and ,NA,NA
negative integers in eight bits. How many negative numbers can ,NA,NA
represented? How many positive numbers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_11.html (1 of 2) [7/8/2545 18:27:55],NA
"Just for fun, can you think of a way to do this? Get out some scratch paper and scratch ",NA,NA
for a while with eight-bit patterns. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_11.html (2 of 2) [7/8/2545 18:27:55],NA
A good answer might be: ,NA,NA
"Since there are 256 possible bit patterns with 8 bits, there could be 128 positive and 128 ",NA,NA
negative integers. ,NA,NA
"You may have thought of the sign-magnitude method, discussed below. ",NA,NA
Sign-Magnitude Rep,NA,NA
n,NA,NA
There are many schemes for representing negative integers with patterns of bits. One ,NA,NA
scheme is ,NA,NA
sign-magnitude,NA,NA
". It uses one bit (usually leftmost) to indicate the sign. ""0"" ",NA,NA
"indicates a positive integer, and ""1"" indicates a negative integer. The rest of the bits are ",NA,NA
used for the magnitude of the number. So -24,10,NA
 is represented as: ,NA,NA
1,NA,NA
001 1000,NA,NA
"The sign ""1"" means negative ",NA,NA
The magnitude is 24 (in 7-bit binary),NA,NA
QUESTION 12:,NA,NA
"With 8-bit sign-magnitude representation, what positive integers can be ",NA,NA
represented and what negative integers can be represented? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_12.html [7/8/2545 18:28:02],NA
A good answer might be:,NA,NA
-127,NA,NA
10,NA,NA
 ... 0 ... +127,NA,NA
10,NA,NA
Problems with Sign-Magnitude,NA,NA
"One of the eight bits is used for the sign, which leaves seven bits for the magnitude. The ",NA,NA
"magnitude uses 7-bit unsigned binary, which can represent 0",10,NA
 (as 000 0000) up to 127,10,NA
"(as 111 1111). The eighth bit makes these positive or negative, resulting in   ",NA,NA
-127,NA,NA
10,NA,NA
", ... -0, 0, ",NA,NA
... 127,NA,NA
10,NA,NA
. ,NA,NA
"One pattern corresponds to ""minus zero"", 1000 0000. Another corresponds to ""plus zero"", ",NA,NA
0000 0000. ,NA,NA
There are several problems with sign-manitude. It works well for representing positive and ,NA,NA
negative integers (although the two zeros are bothersome). But it does not work well in ,NA,NA
computation. A good representation method (for integers or for anything) must not only be ,NA,NA
"able to represent the objects of interest, but must support operations on those objects. ",NA,NA
"This is what is wrong with Roman Numerals: they can represent any integer you want, but ",NA,NA
"they are very, very poor when used in computation. ",NA,NA
QUESTION 13:,NA,NA
"Can the ""binary addition algorithm"" be used with sign-magnitude rep",n,NA
? Try ,NA,NA
adding +16 with -24: ,NA,NA
0001 0000     16 ,NA,NA
1001 1000    -24,NA,NA
---------    ---,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_13.html [7/8/2545 18:28:05],NA
A good answer might be:,NA,NA
 1 ,NA,NA
0001 0000     16,10,NA
1001 1000    -24,10,NA
---------    ----,NA,NA
1010 1000    -40,10,NA
 (wrong!),NA,NA
Patterns that Add Up to Zero,NA,NA
"The ""binary addition algorithm"" does NOT work with sign-magnitude. There are algorithms ",NA,NA
"that do work with sign-magnitude, and some early computers were built to use them. (And ",NA,NA
other computers were built using other not-ready-for-prime-time algorithms). It took several ,NA,NA
years of experience for computer science to decide that a better way had to be found. ,NA,NA
There is a better way. Recall a question and its answer from several pages ago: ,NA,NA
 11111 111,NA,NA
 0000 0001  =   1,10,NA
 1111 1111  =   ,NA,NA
?,NA,NA
 ---------      -----,NA,NA
 0000 0000  =   0,10,NA
QUESTION 14:,NA,NA
A number added to one results in a zero. What could that number be? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_14.html [7/8/2545 18:28:08],NA
A good answer might be: ,NA,NA
Might be minus one. ,NA,NA
Patterns that Add to Zero,NA,NA
Minus one added to plus one gives zero. So if a particular bit pattern results in the pattern ,NA,NA
"that represents zero when added to one, it can represent minus one. ",NA,NA
 11111 111,NA,NA
 0000 0001  =   1,10,NA
 1111 1111  =   ,NA,NA
-1,NA,NA
 ---------      -----,NA,NA
 0000 0000  =   0,10,NA
"There is a carry out of one from the high order column, but that is fine ",NA,NA
in this situation,NA,NA
. The ,NA,NA
"""binary addition algorithm"" correctly applied gives the correct result in the eight bits. Look at ",NA,NA
another interesting case: ,NA,NA
 11111 11,NA,NA
 0000 1110  =   14,10,NA
 1111 0010  =   ,NA,NA
?,NA,NA
 ---------      -----,NA,NA
 0000 0000  =   0,10,NA
QUESTION 15: ,NA,NA
A number added to 14,10,NA
  results in a zero. What could that number be? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_15.html [7/8/2545 18:28:42],NA
A good answer might be:,NA,NA
Might be -14. ,NA,NA
Negative Fourteen,NA,NA
"The pattern ""1111 0010"" might be a good choice for ""negative fourteen"".   In the picture, the ",NA,NA
"only good choice for ""Mystery Number"" is negative fourteen. ",NA,NA
For every bit pattern of N bits there is a corresponding bit pattern of N bits which produces an ,NA,NA
N-bit zero when the two patterns are used as operands for the binary addition algorithm. Each ,NA,NA
pattern can be thought of as representing the negative of the number that is represented by ,NA,NA
the other pattern. ,NA,NA
QUESTION 16: ,NA,NA
Find the 8-bit pattern that gives eight zero-bits when added to the bit pattern ,NA,NA
for 6,10,NA
". (Hint: start at the right column, figure out what the ? has to be in each ",NA,NA
"column, and work your way left.) ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_16.html (1 of 2) [8/8/2545 13:24:58],NA
 0000 0110  =  6,10,NA
 ???? ????  = -6,10,NA
 ---------    ----,NA,NA
 0000 0000     0,"10
  
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_16.html (2 of 2) [8/8/2545 13:24:58]",NA
A good answer might be:,NA,NA
 11111 11,NA,NA
 0000 0110  =   6,10,NA
 1111 1010  =  -6,10,NA
 ---------    ----,NA,NA
 0000 0000      0,10,NA
Two's Complement,NA,NA
This representation scheme is called ,NA,NA
two's complement,NA,NA
. It is one of many ways to ,NA,NA
represent negative integers with bit patterns. But it is now the nearly universal way of doing ,NA,NA
this. Integers are represented in a fixed number of bits. Both positive and negative integers ,NA,NA
can be represented. When the pattern that represents a positive integer is added to the ,NA,NA
"pattern that represents the negative of that integer (using the ""binary addition algorithm""), ",NA,NA
the result is zero. The carry out of the left column is discarded. ,NA,NA
"Here is how to figure out which bit-pattern gives zero when added (using the ""binary ",NA,NA
"addition algorithm"") to a another pattern. ",NA,NA
How to Construct the Negative of an Integer in Two's Complement:,NA,NA
Start with an N-bit rep,n,NA
 of an integer. To calculate the N-bit rep,n,NA
 of the negative integer: ,NA,NA
"1.  Reflect each bit of the bit pattern (change 0 to 1, and 1 to 0). ",NA,NA
2.  Add one.,NA,NA
An example: ,NA,NA
The positive integer: 0000 0001   ( one ) ,NA,NA
Reflect each bit:     1111 1110 ,NA,NA
Add one:              1111 1111   ( minus one ),http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_17.html (1 of 2) [8/8/2545 13:25:04],NA
QUESTION 17:,NA,NA
Fill in the blanks: ,NA,NA
The positive integer: 0000 0110     ( 6,10,NA
 ),NA,NA
Reflect each bit:     ____ ____ ,NA,NA
Add one:              ____ ____     ( -6,10,NA
 ),http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_17.html (2 of 2) [8/8/2545 13:25:04],NA
A good answer might be: ,NA,NA
The positive integer: 0000 0110     ( 6,10,NA
 ) ,NA,NA
Reflect each bit:     1111 1001 ,NA,NA
Add one:              1111 1010     ( -6,10,NA
 ),NA,NA
Negative Six Again,NA,NA
This resulted in the same rep,n,NA
 for minus six as we figured out before. Here is what is going ,NA,NA
on: When each bit of a pattern is reflected then the two patterns added together make all ,NA,NA
1's. This works for all patterns: ,NA,NA
 0110 1010   pattern,NA,NA
 1001 0101   pattern reflected,NA,NA
 ---------,NA,NA
 1111 1111   all columns filled,NA,NA
Adding one to this pattern creates a pattern of all zero's: ,NA,NA
 11111 111    row of carry bits,NA,NA
 1111 1111   all columns filled,NA,NA
 0000 0001   one,NA,NA
 ---------,NA,NA
 0000 0000,NA,NA
"But instead, the one is added to the ""pattern reflected."" ",NA,NA
pattern +  pattern reflected               = all ones ,NA,NA
pattern +  pattern reflected + one         = all zeros ,NA,NA
pattern + (pattern reflected + one )       = all zeros ,NA,NA
pattern + (two's complement of pattern)    = all zeros,NA,NA
Don't be too upset if the above is confusing. Mostly all you need is to get used to this stuff. ,NA,NA
"Of course, this takes practice. ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_18.html (1 of 2) [8/8/2545 13:25:23],NA
QUESTION 18:,NA,NA
What is the two's complement of 0100 0111? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_18.html (2 of 2) [8/8/2545 13:25:23],NA
A good answer might be:,NA,NA
0100 0111   reflect  ,NA,NA
¡,NA,NA
  1011 1000     add one   ,NA,NA
¡,NA,NA
    1011 1001 ,NA,NA
It is always a good idea to check your results: ,NA,NA
 11111 111,NA,NA
 0100 0111,NA,NA
 + 1011 1001,NA,NA
 ---------,NA,NA
 0000 0000,NA,NA
Two's Complement Integers,NA,NA
What is the two's complement of zero? ,NA,NA
 zero =  0000 0000,NA,NA
 reflect =  1111 1111,NA,NA
 add one =  0000 0000,NA,NA
Using the algorithm with the rep,n,NA
 for zero results in the rep,n,NA
 for zero. This is good. Usually ,NA,NA
"""minus zero"" is regarded as the same thing as ""zero"". Recall that with the sign-magnitude ",NA,NA
"method of representing integers there where both ""plus"" and ""minus"" zero. ",NA,NA
What integers can be represented in 8-bit two's complement? Two's complement represents ,NA,NA
"both positive and negative integers. So one way to answer this question is to start with zero, ",NA,NA
"check that it can be represented, then check one, then check minus one, then check two, ",NA,NA
then check minus two ... Let's skip most of those steps and check 127,10,NA
: ,NA,NA
 127 =  0111 1111            check:   0111 1111 ,NA,NA
reflect =  1000 0000                     1000 0001 add ,NA,NA
one =  1000 0001                     ---------,NA,NA
 0000 0000,NA,NA
 -127 =  1000 0001,NA,NA
Now try 128,10,NA
: ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_19.html (1 of 2) [8/8/2545 13:25:30],NA
QUESTION 19:,NA,NA
 128  =  1000 0000,NA,NA
 reflect  =  ____ ____,NA,NA
 add one  =  ____ ____,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_19.html (2 of 2) [8/8/2545 13:25:30],NA
A good answer might be:,NA,NA
 128 ,NA,NA
 ,NA,NA
= ,NA,NA
 ,NA,NA
1000 ,NA,NA
0000,NA,NA
 reflect ,NA,NA
 ,NA,NA
= ,NA,NA
 ,NA,NA
0111 ,NA,NA
1111,NA,NA
 add one  =  1000 0000   ??????,NA,NA
Range of Integers with 2's Complement,NA,NA
This is not good. A non-zero integer and its negative can't ,NA,NA
both be represented by the same pattern. So +128 can not ,NA,NA
be rep,d,NA
 in eight bits. The maximum positive integer that can ,NA,NA
be rep,d,NA
 in eight bits is 127,10,NA
. The negative integers ,NA,NA
 -1 .. -127,10,NA
  also can be represented. ,NA,NA
What number is represented by 1000 0000? Add the rep,n,NA
 of ,NA,NA
127,10,NA
 to it: ,NA,NA
Range of N Bit 2's Complement,"-2
 (n-1)
   ... 0 ... 2
 (n-1)
  - 1
  
  
 eg n= 8
  
 -2
 (8-1)
  = -128  ... 0 ... 2
 (8-1)
  - 1 = 127",NA
 1000 0000    = ?,NA,NA
 0111 1111    = 127,10,NA
 ---------      ,NA,NA
 1111 1111    =  -1,10,NA
A good choice for ? is -128,10,NA
. Therefore 1000 0000 represents -128,10,NA
. Eight bits can ,NA,NA
represent the numbers  -128,10,NA
 ... 0 ... +127,10,NA
. ,NA,NA
QUESTION 20:,NA,NA
How many integers are there in the range  -128,10,NA
 ... 0 ... +127,10,NA
. ,NA,NA
How bit patterns can be formed with 8 bits? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_20.html [8/8/2545 13:25:37],NA
A good answer might be: ,NA,NA
256 ,NA,NA
256 ,NA,NA
Every pattern of the 256 patterns has been assigned an integer to represent. ,NA,NA
"The ""Sign Bit""",NA,NA
The algorithm that creates the rep,n,NA
 of the negative an integer works with both positive and ,NA,NA
negative integers. Start with ,NA,NA
N,NA,NA
 and complement it (make its negative): you get ,NA,NA
-N,NA,NA
. Now ,NA,NA
complement ,NA,NA
-N,NA,NA
 and you get the original ,NA,NA
N,NA,NA
. ,NA,NA
0110 1101     ,NA,NA
¡,NA,NA
  1001 0010     add one ,NA,NA
¡,NA,NA
  1001 0011,NA,NA
1001 0011     reflect ,NA,NA
¡,NA,NA
  0110 1100     add one ,NA,NA
¡,NA,NA
  0110 1101,NA,NA
With N-bit two's comp rep,n,NA
", the high order bit is ""0"" for positive integers and ""1"" for negative ",NA,NA
integers. This is a fortunate result. The high order bit is sometimes called the ,NA,NA
sign bit,NA,NA
. But it ,NA,NA
is not really a sign (it does not play a separate role from the other bits). It takes part in the ,NA,NA
"""binary addition algorithm"" just as any bit. ",NA,NA
QUESTION 21:,NA,NA
Does the following ,NA,NA
four-bit,NA,NA
 two's complement represent a negative or a ,NA,NA
positive integer? ,NA,NA
 1001,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_21.html [8/8/2545 13:25:48],NA
A good answer might be: ,NA,NA
negative,NA,NA
The Sign of the Four Bits,NA,NA
Be Certain of this:,NA,NA
 it is by happy coincidence that the high order bit of a two's comp. ,NA,NA
"integer is 0 for positive and 1 for negative. But, to create the two's comp. rep",n,NA
 of the ,NA,NA
"negative of a number you must ""reflect, add one"". Changing the sign bit by itself will not ",NA,NA
work. ,NA,NA
To convert N bits of two's complement representation into decimal representation: ,NA,NA
"1.  If the integer is negative, complement it to get a positive integer. ",NA,NA
2.  Convert (positive) integer to decimal (as usual).,NA,NA
"3.  If the integer was originally negative, put ""-"" in front of the decimal.",NA,NA
The number rep,d,NA
" by 1001 is negative (since the ""sign bit"" is one), so complement: ",NA,NA
 1001 ,NA,NA
¡,NA,NA
  0110 + 1 ,NA,NA
¡,NA,NA
  0111,NA,NA
Convert the result to decimal:  0111 = 7,10,NA
.  Add a negative sign:   -7,10,NA
.  So (in 4-bit two's ,NA,NA
comp. rep,n,NA
) 1001 represents -7,10,NA
. ,NA,NA
QUESTION 22:,NA,NA
What is the decimal rep,n,NA
 of this 8-bit two's complement integer: 1001 1111 ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_22.html [8/8/2545 13:26:05],NA
A good answer might be:,NA,NA
 1001 1111    reflect ,NA,NA
¡,NA,NA
   0110 0000    add one ,NA,NA
¡,NA,NA
  0110 0001 ,NA,NA
convert to decimal   ,NA,NA
¡,NA,NA
  2,6,NA
 +2,5,NA
 + 1  =  97,10,NA
 put sign in front    ,NA,NA
¡,NA,NA
  -97,10,NA
Overflow Detection in 2's Complement,NA,NA
"The ""binary addition algorithm"" can be applied to any pair of bit patterns. The adder ",NA,NA
electonics inside the microprocessor performs this operation with any two bit patterns you ,NA,NA
send it. You send it bit patterns. It does its job. It is up to you (as the writter of the program) ,NA,NA
to be sure that the operation makes sense. ,NA,NA
Overflow is detected in a different way for each representation. In the following exhibit the ,NA,NA
"""binary addition algorithm"" is applied to two bit patterns. Then the results are looked at as ",NA,NA
unsigned binary and then as two's complement: ,NA,NA
Algorithm applied to ,NA,NA
bit patterns ,NA,NA
interpretation of the patterns as ,NA,NA
unsigned binary,NA,NA
interpretation of the patterns as 2's ,NA,NA
complement,"1111   11
  
  0111 0011 
  
  1101 0001 
  
  --------- 
  
  0100 0100 
  
  
  
  115
 10
  
  209
 10
  
  ---- 
  
  68
 10 
  
 (incorrect)
  
  
  
  115
 10
  
  -47
 10
  
  ----
  
  68
 10 
  
 (correct)",NA
"The ""binary addition algorithm"" was performed on the operands. The result is either correct ",NA,NA
or incorrect depending on how the bit patterns are interpreted. If the bit patterns are ,NA,NA
"regarded as unsigned binary integers, then overflow happened. If the bit patterns are ",NA,NA
"regarded as two's comp integers, then the result is correct. ",NA,NA
Detecting two's complement overflow,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_23.html (1 of 2) [8/8/2545 13:26:35],NA
"When the ""binary addition algorithm"" is used with operands in two's ",NA,NA
"complement representation, the result is correct if ",NA,NA
the carry INTO,NA,NA
 the ,NA,NA
high order column is the same as ,NA,NA
the carry OUT OF,NA,NA
 the high order ,NA,NA
column. The carry bits can both be zero or both be one. ,NA,NA
QUESTION 23:,NA,NA
"Which case applies to the 2's comp result, above: ",G,NA
(correct result:  ) The carry into the left column is the SAME as the carry ,NA,NA
out.,G,NA
(incorrect result:) The carry into the left column is DIFFERENT from the carry out.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_23.html (2 of 2) [8/8/2545 13:26:35],NA
A good answer might be: ,G,NA
(correct result:) The carry into the left column is the SAME as the carry out.,NA,NA
Carry In = Carry Out,NA,NA
With two's comp rep,n,NA
 the result of addition is correct if the carry into the high order column ,NA,NA
is the same as the carry out of the high order column. The carry can be one or zero. ,NA,NA
"Overflow is detected by comparing two bits, an easy thing to do with electronics. Here are ",NA,NA
some more examples: ,NA,NA
No Overflow,NA,NA
No Overflow ,NA,NA
Overflow,NA,NA
Overflow ,"11111 111
  
  0011 1111  ( 63
 10
 ) 
 1101 0101  (-43
 10
 ) 
 --------- 
  
  0001 0100  ( 20
 10
 )
  
  
  
 00000 011
  
  1100 0001  ( -63
 10
 ) 
 0010 1011  (  43
 10
 ) 
 --------- 
  
  1110 1100  ( -20
 10
 )
  
  
  
 01111 100
  
  0011 1111  (  63
 10
 ) 
 0110 0100  ( 100
 10
 ) 
 --------- 
  
  1010 0011  ( -93
 10
 )
  
  
  
 10000 000
  
  1100 0001  ( -63
 10
 ) 
 1001 1100  (-100
 10
 ) 
 --------- 
  
  0101 1101  (  93
 10
 )",NA
QUESTION 24:,NA,NA
"Perform the ""binary addition algorithm"" on the following 8-bit two's ",NA,NA
complement numbers. Is the result correct or not? ,NA,NA
 1011 1101,NA,NA
 1110 0101,NA,NA
 ---------,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_24.html [8/8/2545 13:26:37],NA
A good answer might be:,NA,NA
The result is correct. ,NA,NA
11111 1 1,NA,NA
 1011 1101,NA,NA
 1110 0101,NA,NA
 ---------,NA,NA
 1010 0010,NA,NA
Subtraction in Two's Complement,NA,NA
Since the carry into the high order column is the same as the carry out of the high order ,NA,NA
"column, the result is correct. We didn't even need to figure out what decimal numbers the ",NA,NA
patterns represented. Looking at the situation in detail it turns out that everything is correct: ,NA,NA
11111 1 1,NA,NA
 1011 1101  (-67,10,NA
),NA,NA
 1110 0101  (-27,10,NA
),NA,NA
 ---------,NA,NA
 1010 0010  (-94,10,NA
),NA,NA
"The ""binary addition algorithm"" is used for subtraction and addition. To subtract two ",NA,NA
"numbers represented in two's complement, negate the number to be subtracted and then ",NA,NA
add. Overflow is detected as usual. ,NA,NA
QUESTION 25:,NA,NA
Subtract     0001 1011    from     0011 0001.   Is the result correct or not? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_25.html [8/8/2545 13:26:47],NA
A good answer might be: ,NA,NA
0001 0110 (correct) ,NA,NA
Multipurpose Algorithm,NA,NA
"The number to be subtracted is negated by the usual means (reflect the bits, add one): ",NA,NA
0001 1011 ,NA,NA
¡,NA,NA
  1110 0101,NA,NA
"Then the ""binary addition algorithm"" is used: ",NA,NA
11100 001,NA,NA
 0011 0001    =  49,10,NA
 1110 0101    = -27,10,NA
 ---------     -----,NA,NA
 0001 0110       22,10,NA
"Since the carry into the most significant column is the same as the carry out of that column, ",NA,NA
"the result is correct. We are getting quite a bit of use out of the ""binary addition algorithm"". It ",NA,NA
is used to: ,G,NA
Add integers represented in unsigned binary.,G,NA
Add integers represented in two's complement binary. ,G,NA
Subtract integers represented in two's complement binary.,NA,NA
It can't be used to subtract integers represented in unsigned binary. But if subtraction is ,NA,NA
"being performed all the data should be using two's complement representation, or ",NA,NA
somebody made a mistake. In the programming language Java all integers (int and long) ,NA,NA
are represented using two's complement. ,NA,NA
QUESTION 26:,NA,NA
Subtract 0101 1001 from 0010 0101 Is the result correct or not? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_26.html [8/8/2545 13:26:53],NA
A good answer might be: ,NA,NA
1100 1100 (correct) ,NA,NA
More Practice Subtraction ,NA,NA
"The number to be subtracted is negated by the usual means (reflect the bits, add one): ",NA,NA
0101 1100 ,NA,NA
¡,NA,NA
  1010 0111,NA,NA
"Then the ""binary addition algorithm"" is used: ",NA,NA
00100 111 ,NA,NA
 0010 0101   =  37,10,NA
 1010 0111   = -89,10,NA
 ---------    -----,NA,NA
 1100 1100     -52,10,NA
Since the carry into the most significant column is the same as the carry out of that column ,NA,NA
"the result is correct. The answer came out negative, but that is fine. ",NA,NA
"You must practice the ""binary addition algorithm"" until you are sick of it. Or you can change ",NA,NA
your major to Art History (and leave the high paying jobs to the rest of us). Here is another ,NA,NA
problem: ,NA,NA
QUESTION 27:,NA,NA
Subtract 0101 1001 from 1110 0101.     Is the result correct or not? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_27.html [8/8/2545 13:26:59],NA
A good answer might be: ,NA,NA
1000 1100       (correct) ,NA,NA
No! Not More Practice Subtraction!,NA,NA
"The number to be subtracted is negated by the usual means, as in the previous problem. ",NA,NA
"Then the ""binary addition algorithm"" is used: ",NA,NA
11100 111 ,NA,NA
 1110 0101   = -27,10,NA
 1010 0111   = -89,10,NA
 ---------    -----,NA,NA
 1000 1100    -116,10,NA
Since the carry into the most significant column is the same as the carry out of that column ,NA,NA
"the result is correct. The answer came out negative, but that is fine. ",NA,NA
A computer does several million of these operations per second. Surely you can do another ,NA,NA
one? How about if I give you two whole seconds? ,NA,NA
QUESTION 28:,NA,NA
Subtract    0111 1000     from    1011 0000.     Is the result correct or not? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_28.html [8/8/2545 13:27:12],NA
A good answer might be: ,NA,NA
0011 1000     (incorrect) ,NA,NA
End of the Chapter,NA,NA
The integer to be subtracted is complemented: ,NA,NA
0111 1000 ,NA,NA
¡,NA,NA
 1000 0111 + 1 ,NA,NA
¡,NA,NA
 1000 1000,NA,NA
...then added to the other: ,NA,NA
10000 000 ,NA,NA
 1011 0000  = - 80,10,NA
 1000 1000  = -120,10,NA
 ---------    -----,NA,NA
 0011 1000     +56,10,NA
 !??!!,NA,NA
Since the carry into the most significant column is ,NA,NA
NOT,NA,NA
" the same as the carry out, the result ",NA,NA
is not correct. ,NA,NA
You have reached the end this chapter. You may wish to review the following unless your ,NA,NA
brain has overflowed. Click on a subject that interests you to go to where it was discussed. ,NA,NA
"To get back here, click on the ""back arrow"" button of your browser. ",G,NA
The binary addition algorithm ,G,NA
Details,NA,NA
 of the binary addition algorithm. ,G,NA
Hexadecimal addition.,G,NA
Overflow,NA,NA
 in unsigned binary addition. ,G,NA
Sign-magnitude,NA,NA
 representation ,G,NA
Two's complement,NA,NA
 representation ,G,NA
The sign bit,NA,NA
 with two's complement representation. ,G,NA
Overflow,NA,NA
 in two's complement addition. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-08/ass08_29.html (1 of 2) [8/8/2545 13:27:45],NA
CHAPTER 9 --- First SPIM Program,NA,NA
This chapter discusses how to run the SPIM simulator. A small MIPS program is used as an ,NA,NA
example. ,NA,NA
Chapter Topics:,G,NA
Starting SPIM ,G,NA
The SPIM user interface ,G,NA
Writing an assembly source program ,G,NA
Assembling and loading a program ,G,NA
Running a program,NA,NA
This chapter goes through the steps of running a program on SPIM (the MIPS simulator). ,NA,NA
Details will be discussed in later chapters. ,NA,NA
QUESTION 1:,NA,NA
(Review) What is a ,NA,NA
register,NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
A ,NA,NA
register,NA,NA
 is a part of the processor that holds a bit pattern. Processors have many ,NA,NA
registers. ,NA,NA
Starting SPIM,NA,NA
MIPS R2000 processors have 32 ,NA,NA
"general purpose registers, each ",NA,NA
holding 32 bits. ,NA,NA
The first example SPIM program ,NA,NA
puts bit patterns representing ,NA,NA
integers into two registers. Then it ,NA,NA
adds the two patterns together. ,NA,NA
The screen shots for this ,NA,NA
example are from a ,NA,NA
MS Win ME ,NA,NA
"system, but any Windows OS will ",NA,NA
be similar. Unix and Linux should ,NA,NA
be close. ,NA,NA
"To start SPIM click on its icon, ",NA,NA
reached (on my system) by first ,NA,NA
clicking on the start button. ,NA,NA
If you have not installed SPIM see the appendix. ,NA,NA
QUESTION 2:,NA,NA
How else can SPIM be started? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_2.html [7/8/2545 18:29:11],NA
A good answer might be:,NA,NA
"You could use the Run command from the Start menu, or type ",NA,NA
pcSpim,NA,NA
 in a DOS window if ,NA,NA
pcSpim.exe,NA,NA
 is in the current directory. ,NA,NA
Opening Window,NA,NA
On ,NA,NA
into four ,NA,NA
parts: ,NA,NA
1. ,NA,NA
windows ,NA,NA
"machines, ",NA,NA
the ,NA,NA
Text,NA,NA
 is the name for machine language bit patterns intended for eventual execution. The word ,NA,NA
"""program"" is often ambiguous, so ""text"" is used. ""Text"" is a machine language program waiting ",NA,NA
to become part of an executing process. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_3.html (1 of 2) [7/8/2545 18:29:17],NA
"Character output from the simulated computer is in the SPIM console window, shown as an ",NA,NA
icon in the picture. ,NA,NA
QUESTION 3: ,NA,NA
Is there a difference between messages from ,NA,NA
the simulator,NA,NA
 and messages ,NA,NA
from ,NA,NA
the simulated computer,NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
Yes.,NA,NA
Writing an Assembly Program,NA,NA
Messages from the ,NA,NA
simulated computer,NA,NA
 appear in the console window when an assembly ,NA,NA
program that is running (in simulation) writes to the (simulated) monitor. If a real MIPS ,NA,NA
computer were running you would see the same messages on a real monitor. ,NA,NA
Messages from the ,NA,NA
simulator,NA,NA
 are anything the simulator needs to write to the user of the ,NA,NA
"simulator. These are error messages, prompts, and reports. ",NA,NA
Now that the simulator is running you need to assemble and load a program. Depending on ,NA,NA
"the settings of the simulator, there already may be some machine instructions in simulated ",NA,NA
memory. This code assists in running your program. If you start the simulator from the ,NA,NA
"Simulator menu this code will run, but it will be caught in an infinite loop. To stop it, click on ",NA,NA
Simulator; Break. ,NA,NA
A ,NA,NA
source file,NA,NA
 (in assembly language or in any high level language) is the text file containing ,NA,NA
programming language statements created (usually) by a human programmer. An editor like ,NA,NA
Notepad,NA,NA
" will work. You will probably want to use a better editor, but as a common ground I'll ",NA,NA
use ,NA,NA
Notepad,NA,NA
. (I like ,NA,NA
Code-Genie,NA,NA
" by DolfySoft, http://www.code-genie.com, but any text ",NA,NA
editor will be fine). Use whatever editor you use for Java (or for your usual programming ,NA,NA
language). ,NA,NA
QUESTION 4:,NA,NA
(Review) What type of files does ,NA,NA
Notepad,NA,NA
 create? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_4.html [7/8/2545 18:29:26],NA
A good answer might be: ,NA,NA
Text files---files of bytes that can be interpreted as ASCII characters. ,NA,NA
Two plus Three,NA,NA
"Word processors usually create ""binary"" files and so are not suitable for creating source ",NA,NA
"files. They can be forced to output a text file, but a real programming editor is much nicer. ",NA,NA
With your program (text) editor create a file called ,NA,NA
addup.asm,NA,NA
. (With most text editors and ,NA,NA
Web browsers you can ,NA,NA
copy,NA,NA
 the following code from the Web page and then ,NA,NA
paste,NA,NA
 into the ,NA,NA
editor). ,NA,NA
## Program to add two plus three ,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori     $8,$0,0x2       # put two's comp. two into register 8 ori     ",NA,NA
"$9,$0,0x3       # put two's comp. three into register 9 addu    ",NA,NA
"$10,$8,$9       # add register 8 and 9, put result in 10",NA,NA
## End of file,NA,NA
"The first ""#"" of the first line is in column one. The character ""#"" starts a comment; everything ",NA,NA
"on the line from ""#"" to the right is ignored. Sometimes I use two in a row for emphasis, but ",NA,NA
only one is needed. ,NA,NA
Each of the three lines following ,NA,NA
main:,NA,NA
 corresponds to one machine instruction. ,NA,NA
QUESTION 5:,NA,NA
(Review: ) What is a ,NA,NA
machine instruction,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_5.html [7/8/2545 18:29:32],NA
A good answer might be: ,NA,NA
A ,NA,NA
machine instruction,NA,NA
 is a pattern of bits that asks for one machine operation to be ,NA,NA
executed. ,NA,NA
Setting up SPIM,NA,NA
Each MIPS machine instruction is 32 bits (four bytes) long. The three lines after ,NA,NA
main:,NA,NA
 call ,NA,NA
for three machine instructions. The remaining lines consist of information for the assembler ,NA,NA
and comments (for the human). ,NA,NA
"For this first program some SPIM options must be set. In the menu bar, click on Simulator ",NA,NA
then Settings to get the settings dialog. Select the following options: ,"ON
  
 Save window positions
  
  
 ON 
  
  
 General registers in hexadecimal
  
  
  
  
 OFF 
  
  
 Floating point registers in 
 hexadecimal
  
  
  
 ON 
  
  
 Bare machine
  
  
  
 OFF 
  
  
 Allow pseudo instructions
  
  
  
 OFF 
  
  
 Load trap file
  
  
  
 ON 
  
  
 Delayed Branches
  
  
  
 ON 
  
  
 Delayed Load
  
  
  
 ON 
  
  
 Mapped I/O
  
  
  
 OFF 
  
  
 Quiet",NA
These settings simulate a bare machine with no user conveniences. Later we will include ,NA,NA
the conveniences. ,NA,NA
QUESTION 6:,NA,NA
(Thought Question) Do most actual computers start up as a bare machine? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_6.html [7/8/2545 18:29:58],NA
(Thought Question) Do most actual computers start up as a ,NA,NA
Bare machine,NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
Loading the Source File,NA,NA
Usually there is ,NA,NA
(permanent machine code in EEPROM) in a ,NA,NA
special section ,NA,NA
some ,NA,NA
firmware,NA,NA
of the address space. This starts running on ,NA,NA
power-up and loads an operating system. ,NA,NA
"SPIM can simulate some basic firmware, but ",NA,NA
we have turned off that option. ,NA,NA
Load the program into the SPIM simulator by clicking File then Open. Click on the name ,NA,NA
(,NA,NA
addup.asm,NA,NA
) of your source file. You may have to navigate through your directories using ,NA,NA
the file dialog box. ,NA,NA
If there are mistakes in ,NA,NA
addup.asm,NA,NA
", SPIM's message display panel shows the error ",NA,NA
"messages. Use your editor to correct the mistakes, save the file then re-open the file in ",NA,NA
SPIM. ,NA,NA
QUESTION 7:,NA,NA
Can the text editor and SPIM both be open at the same time? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_7.html [7/8/2545 18:30:22],NA
A good answer might be: ,NA,NA
"Sure. You can correct errors with the text editor, save the file to the disk, and then re-",NA,NA
load it into SPIM. ,NA,NA
Assembling the Program,NA,NA
Loading the source file into SPIM does two things: (1) The file is assembled into machine ,NA,NA
"instructions, and (2) the instructions are loaded into SPIM's memory. The ",NA,NA
text display,NA,NA
 shows ,NA,NA
the result. ,NA,NA
The text display is the second window from the top. You should see some of the sorce file in ,NA,NA
it and the machine instructions they assembled into. The leftmost column are addresses in ,NA,NA
simulated memory. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_8.html (1 of 2) [7/8/2545 18:30:37],NA
QUESTION 8:,NA,NA
Inspect the text display (your own or the above picture). ,NA,NA
1.  What machine instruction (bit pattern) did your first instruction (,NA,NA
ori ,NA,NA
"$8,$0,0x2",NA,NA
) assemble into?,NA,NA
2.  At what address in memory was it loaded?,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_8.html (2 of 2) [7/8/2545 18:30:37],NA
A good answer might be:,NA,NA
1.  What machine instruction (bit pattern) did your first instruction assemble into? ,H,NA
0x34080002 ,NA,NA
2.  At what address in memory was it loaded? ,H,NA
0x00400000,NA,NA
Setting the PC,NA,NA
The ,NA,NA
program counter,NA,NA
 is part of the processor that contains the address of (the first byte of) the ,NA,NA
current machine instruction. In the ,NA,NA
register display,NA,NA
 (top window) you see that it is initialized ,NA,NA
"to zero. This must be changed to 0x00400000 , the address of our first instruction. To do ",NA,NA
"this, select (click on) Simulator; Set Value in the menu bar. ",NA,NA
"In the set value dialog, type ",NA,NA
PC,NA,NA
 in the top text box and ,NA,NA
0x00400000,NA,NA
 in the bottom text box. ,NA,NA
Click on OK and the PC (in the register display) should change. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_9.html (1 of 2) [7/8/2545 18:30:43],NA
QUESTION 9:,NA,NA
"A user types ""400000"" into the value box, and clicks OK. The PC changes to ",NA,NA
00061a80. What happened? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_9.html (2 of 2) [7/8/2545 18:30:43],NA
"A user types ""400000"" into the value box, clicks OK, and sees the PC change to 00061a80. ",NA,NA
What Happened? ,NA,NA
A good answer might be: ,NA,NA
"Without a leading ""0x"" the characters ""400000"" are taken to be an integer expressed in ",NA,NA
decimal. ,NA,NA
Running the Program,NA,NA
"Push F10 to execute one instruction. The first instruction executes, loading register R8 with a 2 ",NA,NA
(see the register display). The PC advances to the next instruction 0x00400004 and the ,NA,NA
message display window shows the instruction that just executed. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_10.html (1 of 2) [7/8/2545 18:31:02],NA
Push F10 two more times to execute the remaining instructions. Each instruction is 32 bits (four ,NA,NA
"bytes) long, so the PC changes by four each time. After the third instruction, R8 will have the ",NA,NA
sum of two plus three. ,NA,NA
QUESTION 10:,NA,NA
What is the sum of 0x0000002 and 0x0000003   ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_10.html (2 of 2) [7/8/2545 18:31:02],NA
What is the sum of 0x0000002 and 0x0000003   ? ,NA,NA
A good answer might be: ,NA,NA
0x0000005 ,NA,NA
Program's Results,NA,NA
The bit patterns for these small integers are easy to figure out. You may have to use the slider ,NA,NA
on the register display to see register ten. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_11.html (1 of 2) [7/8/2545 18:31:23],NA
"If you push F10 again, the PC will point at a word in memory that contains bits not intended to ",NA,NA
be a machine instruction. However the simulator will try to execute those bits. A real processor ,NA,NA
"would ""crash"" at this point. (This is sometimes called ""falling off the end of a program""). The ",NA,NA
simulator prints an error message in the bottom panel. ,NA,NA
QUESTION 11:,NA,NA
What happens in real computers when the end of a program is reached? ,NA,NA
A good answer might be: ,NA,NA
The program returns control to the operating system. ,NA,NA
Explanation of the Program,NA,NA
There are various ways for a program executing on a real machine to return control to the ,NA,NA
"operating system. But we have no OS, so for now we will single step instructions. Hopefully ",NA,NA
you are wondering how the program works. Here it is again: ,NA,NA
## Program to add two plus three ,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori     $8,$0,0x2       # put two's comp. two into register 8 ori     ",NA,NA
"$9,$0,0x3       # put two's comp. three into register 9 addu    ",NA,NA
"$10,$8,$9       # add register 8 and 9, put result in 10",NA,NA
## End of file,NA,NA
## Program to add two plus three,NA,NA
 is a comment. It is ignored by the assembler and results ,NA,NA
in no machine instructions. ,NA,NA
.text,NA,NA
 is a ,NA,NA
directive,NA,NA
. A directive is a statement that tells the assembler something about what ,NA,NA
"the programmer wants, but does not itself result in any machine instructions. This directive ",NA,NA
"tells the assembler that the following lines are "".text"" -- source code for the program. ",NA,NA
.globl main,NA,NA
 is another directive. It says that the identifier ,NA,NA
main,NA,NA
 will be used outside of this ,NA,NA
"source file (that is, used ""globally"") as the label of a particular location in main memory. ",NA,NA
QUESTION 12:,NA,NA
(Memory test) Where was the first machine instruction placed in memory? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_12.html [7/8/2545 18:31:28],NA
(Memory test) Where was the first machine instruction placed in memory? ,NA,NA
A good answer might be: ,NA,NA
0x00400000 ,NA,NA
Explanation Continued,NA,NA
The blank line is ignored. Next comes ,NA,NA
main:,NA,NA
 This defines a ,NA,NA
symbolic address,NA,NA
 (sometimes ,NA,NA
called a ,NA,NA
statement label,NA,NA
). A symbolic address is a symbol (an identifier) that is the source ,NA,NA
"code name for a location in memory. In this program, ",NA,NA
main,NA,NA
 stands for the address of the first ,NA,NA
machine instruction (which turns out to be 0x00400000). Using a symbolic address is much ,NA,NA
"easier than using a numerical address. With a symbolic address, the programmer refers to ",NA,NA
memory locations by name and lets the assembler figure out the numerical address. ,NA,NA
## Program to add two plus three ,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori     $8,$0,0x2       # put two's comp. two into register 8 ori     ",NA,NA
"$9,$0,0x3       # put two's comp. three into register 9 addu    ",NA,NA
"$10,$8,$9       # add register 8 and 9, put result in 10",NA,NA
## End of file,NA,NA
The symbol ,NA,NA
main,NA,NA
 is global. This means that several source files are able to use ,NA,NA
main,NA,NA
 to ,NA,NA
refer to the same main storage address. ,NA,NA
QUESTION 13:,NA,NA
(Test your intuition: ) Is it likely that several sections of a software system ,NA,NA
need to refer to each other? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_13.html [7/8/2545 18:31:31],NA
Is it likely that several sections of a software system need to refer to each other?,NA,NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Loading Register Eight,NA,NA
Yes. All software consists of interconnected modules. A connection is made when one ,NA,NA
module refers to an address in another. ,NA,NA
The next line: ,NA,NA
"ori $8,$0,0x2 ",NA,NA
translates into a 32-bit machine instruction. The machine ,NA,NA
"instruction, upon execution, puts a 32-bit two's complement positive two into register eight ",NA,NA
(details later). ,NA,NA
## Program to add two plus three ,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori     $8,$0,0x2       # put two's comp. two into register 8 ori     ",NA,NA
"$9,$0,0x3       # put two's comp. three into register 9 addu    ",NA,NA
"$10,$8,$9       # add register 8 and 9, put result in 10",NA,NA
## End of file,NA,NA
The instruction after that translates into a machine instruction that (upon execution) puts a ,NA,NA
three into register nine. The final instruction translates into a machine instruction that (upon ,NA,NA
execution) adds register eight to register nine and puts the 32-bit result into register ten. ,NA,NA
QUESTION 14:,NA,NA
What algorithm do you suppose is used for the 32-bit addition? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_14.html [7/8/2545 18:31:35],NA
What algorithm do you suppose is used for the 32-bit addition? ,NA,NA
A good answer might be: ,NA,NA
The Binary Addition Algorithm (of Chapter 8) ,NA,NA
Run Time,NA,NA
It is awkward to keep saying ,NA,NA
"""the instruction, after it is assembled and loaded into main ",NA,NA
"memory, upon execution does ....""",NA,NA
     Instead one says ,NA,NA
"""at ",NA,NA
run time,NA,NA
" the instruction does ...""",NA,NA
. ,NA,NA
" For example, ",NA,NA
"At run time, the instruction ",NA,NA
"ori $8,$0,0x2 ",NA,NA
loads register eight with a two. ,NA,NA
"Even sloppier is, ",NA,NA
"""the instruction ",NA,NA
"ori $8,$0,0x2 ",NA,NA
"loads register eight with a two."" ",NA,NA
It is vital that you understand that this phrase is a short way of saying the longer phrase. In ,NA,NA
"a computer it is the bit patterns of machine instructions that cause things to happen, and ",NA,NA
things happen only at run time. ,NA,NA
Sometimes one talks about ,NA,NA
assembly time,NA,NA
", the phase where the assembler is creating bit ",NA,NA
patterns out of the source file. ,NA,NA
QUESTION 15:,NA,NA
(Review) In a typical computer system (not a simulated one) where does the ,NA,NA
assembler place the bit patterns it creates? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_15.html [7/8/2545 18:31:36],NA
(Review) In a typical computer system (not a simulated one) where does the assembler ,NA,NA
place the bit patterns it creates? ,NA,NA
A good answer might be: ,NA,NA
"In an object module, stored as a disk file. ",NA,NA
End of Chapter,NA,NA
With the SPIM simulator the object module step is skipped. The assembler puts the bit ,NA,NA
"patterns directly into (simulated) main memory. To end SPIM, click on File; exit in the menu ",NA,NA
bar. ,NA,NA
You have reached the end of this chapter. You may wish to review the following. Click on a ,NA,NA
blue subject that interests you to go to where it was discussed. ,G,NA
The SPIM ,NA,NA
user interface.,G,NA
Starting SPIM ,G,NA
Source files ,G,NA
Settings dialog ,G,NA
Loading,NA,NA
 the source file. ,G,NA
The two ,NA,NA
things that SPIM does,NA,NA
 to a loaded file. ,G,NA
Setting the ,NA,NA
program counter ,G,NA
Single stepping,NA,NA
 SPIM ,G,NA
Assembly language ,NA,NA
directive ,G,NA
Symbolic address ,G,NA
Run time,NA,NA
Click here,NA,NA
     Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-09/ass09_16.html [8/8/2545 13:32:43],NA
CHAPTER 10 --- A MIPS Programming ,NA,NA
Model,NA,NA
This chapter presents a ,NA,NA
programming model,NA,NA
 for the MIPS processor. A programming model ,NA,NA
is an abstract view of a processor that is appropriate for programming but omits details that ,NA,NA
are not needed for that task. It is the view of the machine a programmer uses when ,NA,NA
programming. ,NA,NA
Chapter Topics:,G,NA
Basic MIPS Programming model.,G,NA
Memory ,G,NA
Registers ,G,NA
Machine cycle ,G,NA
Control flow,NA,NA
QUESTION 1:,NA,NA
"As you drive your car down the highway, do you think much about the ",NA,NA
ignition coil? ,NA,NA
A good answer might be:,NA,NA
"No•you use an abstract ""drivers view"" of the car which is appropriate for driving but ",NA,NA
omits unnecessary details. Of course you don't ,NA,NA
always,NA,NA
 use that model. If it starts raining ,NA,NA
and your car starts sputtering you might start thinking about the coil. ,NA,NA
Memory Model,NA,NA
MIPS computer systems nearly always ,NA,NA
DATA:,NA,NA
MIPS memory is an array of 2,32,NA
bytes. Each byte has a 32-bit ,NA,NA
address. Each byte can hold an 8-,NA,NA
"bit pattern, one of the 256 possible ",NA,NA
8-bit patterns. The addresses of ,NA,NA
MIPS main memory range from ,NA,NA
0x00000000 to 0xFFFFFFFF. ,NA,NA
However user programs and data are restricted to the first 2,31,NA
 bytes. ,NA,NA
OPERATIONS:,G,NA
Load:,NA,NA
 a bit pattern starting at a designated address in memory is copied into a register ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_2.html (1 of 2) [7/8/2545 18:31:46],NA
inside the processor.,G,NA
Store:,NA,NA
 a bit pattern is copied from a processor register to memory at a designated ,NA,NA
address.,NA,NA
"Bit patterns are copied to/from memory and the processor in groups of one, two, four, or ",NA,NA
eight contiguous bytes. Only the address of the first byte of memory is specified. ,NA,NA
QUESTION 2:,G,NA
Does a ,NA,NA
load,NA,NA
 operation change the bit pattern in memory? ,G,NA
Does a ,NA,NA
store,NA,NA
 operation change the bit pattern in memory?,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_2.html (2 of 2) [7/8/2545 18:31:46],NA
A good answer might be: ,G,NA
Does a ,NA,NA
load,NA,NA
 operation change the bit pattern in memory? ,NA,NA
NO ,G,NA
Does a ,NA,NA
store,NA,NA
 operation change the bit pattern in memory? ,NA,NA
YES,NA,NA
Memory Layout,NA,NA
Load and store operations copy the bit pattern from the source into the destination. The ,NA,NA
"source (register or memory) does not change. Of course, the pattern at the destination is ",NA,NA
replaced by the pattern at the source. ,NA,NA
"However, it is convenient for programmers and ",NA,NA
upper half of the address space ,NA,NA
The parts of address space accessible to a user ,NA,NA
program are divided as follows: ,NA,NA
Text Segment:,NA,NA
 This holds the machine ,NA,NA
language of the user program (the ,NA,NA
text,NA,NA
). ,NA,NA
Data Segment:,NA,NA
 This holds the data that the program operates on. Part of the data is ,NA,NA
static,NA,NA
. This is data that is allocated by the assembler and whose size never ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_3.html (1 of 2) [7/8/2545 18:31:52],NA
malloc(),NA,NA
 and ,NA,NA
free(),NA,NA
. ,NA,NA
Stack Segment:,NA,NA
 At the top of user address space is the stack. With high level ,NA,NA
"languages, local variables and parameters are pushed and popped on the ",NA,NA
stack as procedures are activated and deactivated. ,NA,NA
QUESTION 3:,NA,NA
"(Thought Question) As the program runs, the data segment grows upward ",NA,NA
(as dynamic variables are allocated) and the stack grows downward (as ,NA,NA
procedures get called). Is this sensible? (Hint: how much user memory is left ,NA,NA
when the two segments meet?) ,NA,NA
"As the program runs, the data segment grows upward (as dynamic variables are allocated) ",NA,NA
and the stack grows downward (as procedures get called). Is this sensible? ,NA,NA
A good answer might be: ,NA,NA
"Yes. Rather than allocate a fixed amount of memory for each, this arrangement means ",NA,NA
"each can grow into available memory. When the two meet, there is no memory left. ",NA,NA
Registers,NA,NA
"Often several bytes in a row (contiguous bytes) are used, so there is terminology for how ",NA,NA
many bytes are used. Each manufacturer has their own idea of what to call groupings larger ,NA,NA
than a byte. The following is used for MIPS chips. ,G,NA
byte,NA,NA
 — eight bits.,G,NA
word,NA,NA
" — four bytes, 32 bits.",G,NA
double word,NA,NA
" — eight bytes, 64 bits.",NA,NA
A block of contiguous memory is referred to by the address of its first byte (ie. the byte with ,NA,NA
"the lowest address.) Most MIPS instructions involve a fixed number of bytes (for example, ) ",NA,NA
Often you need a number of bits other than one of the standard amounts. Use the next ,NA,NA
"largest standard amount, and remember to be careful. Attempting to use the very minimum ",NA,NA
number of bits is more complicated than it is worth and is a rich source of errors in assembly ,NA,NA
language programming. ,NA,NA
A ,NA,NA
register,NA,NA
" is a part of the processor that can hold a bit pattern. On the MIPS, a register ",NA,NA
"holds 32 bits. There are many registers in the processor, but only some of them are visible ",NA,NA
in assembly language. The others are used by the processor in carrying out its operations. ,G,NA
A ,NA,NA
load,NA,NA
 operation copies a bit pattern from memory into a register. ,G,NA
A ,NA,NA
store,NA,NA
 operation copies a bit pattern from a register into memory.,NA,NA
The registers that are visible in assembly language are called ,NA,NA
general purpose,NA,NA
 registers ,NA,NA
and ,NA,NA
floating point,NA,NA
 registers. There are 32 32-bit general purpose registers. In assembly ,NA,NA
"language, these registers are named ",NA,NA
"$0, $1, $2, ... , $31",NA,NA
. There are 16 floating point ,NA,NA
registers. They will be discussed later. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_4.html (1 of 2) [7/8/2545 18:31:56],NA
One of the general purpose registers is hard-wired to always contain the value 0x00000000 ,NA,NA
(all zero bits). ,NA,NA
QUESTION 4:,NA,NA
Which register ,NA,NA
"$0, $1, $2, ... , $31",NA,NA
 do you suppose always contains all zero ,NA,NA
bits? ,NA,NA
A good answer might be:,NA,NA
$0 ,NA,NA
The bit pattern 0x00000000 occurs so frequently in machine language that register $0 is ,NA,NA
"wired to permanently hold it. That bit pattern represents the integer zero, a very common ",NA,NA
integer. It also represents a ,NA,NA
null,NA,NA
", which is used to mark the end of character strings and ",NA,NA
some data structures. ,NA,NA
Registers and the ALU,NA,NA
The ,NA,NA
arithmetic/logic ,NA,NA
unit (ALU),NA,NA
 of a ,NA,NA
processor performs ,NA,NA
integer arithmetic and ,NA,NA
logical operations. For ,NA,NA
"example, one of its ",NA,NA
operations is to add two ,NA,NA
32-bit integers. An ,NA,NA
integer used as input to ,NA,NA
an operation is called an ,NA,NA
operand,NA,NA
. One operand ,NA,NA
for the ALU is always ,NA,NA
contained in a register. ,NA,NA
The other may be in a ,NA,NA
register or may be part of ,NA,NA
the machine ,NA,NA
instruction. The result of ,NA,NA
the operation is put into a ,NA,NA
general purpose ,NA,NA
register. ,NA,NA
Machine instructions ,NA,NA
that use the ALU specify ,NA,NA
four things: ,NA,NA
1.  The operation to ,NA,NA
perform.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_5.html (1 of 2) [7/8/2545 18:32:06],NA
2.  The the first operand (often in a ,NA,NA
register). ,NA,NA
3.  The second operand (often in a register). ,NA,NA
4.  The register that receives the result.,NA,NA
The picture shows a 32-bit addition operation. The operands are register $8 and register $9. ,NA,NA
The result in put in register $10. Here is how that instruction is written as assembly ,NA,NA
language: ,NA,NA
"addu    $10,$8,$9 ",NA,NA
QUESTION 5:,NA,NA
"Here is another instruction that involves the ALU, written as assembly ",NA,NA
language: ,NA,NA
"subu    $25,$16,$17 ",NA,NA
Identify the following: ,NA,NA
1.  The operation: ________________ ,NA,NA
2.  The location of one operand: ________________ 3.  ,NA,NA
The location of the other operand: ________________ 4.  ,NA,NA
The destination of the result: ________________ ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_5.html (2 of 2) [7/8/2545 18:32:06],NA
A good answer might be:,NA,NA
1.  The operation: ,NA,NA
subtraction of two 32-bit integers ,NA,NA
2.  The location of one operand: ,NA,NA
register $16 ,NA,NA
3.  The location of the other operand: ,NA,NA
register $17 ,NA,NA
4.  The destination of the result: register $25,NA,NA
At run time: Register $25 <-- (Register $16) - (Register $17) ,NA,NA
Machine Code,NA,NA
On some processors (such as the VAX) the ALU can operate directly on data contained in ,NA,NA
"main memory. However, this requires extra data paths and control logic and slows down ",NA,NA
"execution. On the MIPS, operands for the ALU and the destination for the result are inside ",NA,NA
the chip (usually registers). ,NA,NA
Here is the assembly language for the add instruction: ,NA,NA
"addu    $10,$8,$9 ",NA,NA
Here is the machine code it translates into: ,NA,NA
0x01095021 ,NA,NA
Here is that as a bit pattern: ,NA,NA
0000 0001 0000 1001 0101 0000 0010 0001,NA,NA
Here is the bit pattern arranged into different groups (as given in the MIPS documentation). ,NA,NA
Under each group is what the pattern means as a machine instruction. (A group of bits that ,NA,NA
is part of a larger bit pattern is often called a ,NA,NA
field,NA,NA
). Each field of a machine instruction has a ,NA,NA
specific function. ,NA,NA
 0    1    0    9    5    0    2    1     -- machine instruction in hex ,NA,NA
0000 00,NA,NA
01 000,NA,NA
0 1001,NA,NA
 0101 0,NA,NA
000 00,NA,NA
10 0001,NA,NA
    -- machine instruction in bits ,NA,NA
000000,NA,NA
01000,NA,NA
01001,NA,NA
01010,NA,NA
00000,NA,NA
100001,NA,NA
      -- fields of the instructuion,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_6.html (1 of 2) [7/8/2545 18:32:09],NA
opcode oprnd oprnd dest  ----- 2ndary      -- meaning of the fields,NA,NA
ALUop   $8    $9   $10           addu,NA,NA
Inspect the groups until you see how the instruction specifies the four things: (1) the ,NA,NA
"operation, (2) operand 1, (3) operand 2, (4) result destination. The 12 bits that specify the ",NA,NA
addu,NA,NA
 operation are in two groups at the start and end of the instruction. The first group is ,NA,NA
called the ,NA,NA
opcode,NA,NA
 and the second group is called the ,NA,NA
secondary opcode,NA,NA
. The register ,NA,NA
numbers are readable as binary integers. Some bits of the instruction are left as zero. You ,NA,NA
have to look at MIPS documentation to figure all this out. ,NA,NA
QUESTION 6:,NA,NA
"Here is the machine instruction again, but the pattern that specifies the ",NA,NA
destination is blank. Fill it in so the destination is register $11. ,NA,NA
000000 01000  01001 ,NA,NA
_ _ _ _ _,NA,NA
 00000 100001 ,NA,NA
addu    $8    $9    ,NA,NA
$11,NA,NA
             addu,NA,NA
 op1   op2    ,NA,NA
dest,NA,NA
A good answer might be: ,NA,NA
000000 01000  01001 ,NA,NA
0 1 0 1 1,NA,NA
 00000 100001 ,NA,NA
addu    $8    $9    ,NA,NA
$11,NA,NA
             addu,NA,NA
 op1   op2    ,NA,NA
dest,NA,NA
Register Use Conventions,NA,NA
Congratulations! (if ,NA,NA
you correctly ,NA,NA
answered the ,NA,NA
question). You have ,NA,NA
just done some ,NA,NA
machine language ,NA,NA
programming. Who ,NA,NA
needs that old ,NA,NA
"assembler, anyway? ",NA,NA
General purpose ,NA,NA
registers,NA,NA
 are those ,NA,NA
that assembly ,NA,NA
language programs ,NA,NA
work with (other than ,NA,NA
floating point ,NA,NA
registers). The ,NA,NA
general purpose ,NA,NA
registers are ,NA,NA
numbered $0 through ,NA,NA
"$31. However, by ",NA,NA
convention (and ,NA,NA
sometimes by ,NA,NA
hardware) different ,NA,NA
registers are used for ,NA,NA
different purposes. ,NA,NA
Register ,NA,NA
Number,NA,NA
Mnemonic ,NA,NA
Name,NA,NA
Conventional Use,NA,NA
$0,NA,NA
zero,NA,NA
Permanently 0,NA,NA
$1,NA,NA
$at,NA,NA
Assembler Temporary (reserved),NA,NA
"$2, $3",NA,NA
"$v0, $v1",NA,NA
Value returned by a subroutine,NA,NA
$4-$7,NA,NA
$a0-$a3,NA,NA
Arguments to a subroutine,NA,NA
$8-$15,NA,NA
$t0-$t7,NA,NA
Temporary ,NA,NA
(not preserved across a function call),NA,NA
$16-$23,NA,NA
$s0-$s7,NA,NA
Saved registers ,NA,NA
(preserved across a function call),NA,NA
"$24, $25",NA,NA
"$t8, $t9",NA,NA
Temporary,NA,NA
"$26, $27",NA,NA
"$k0, $k1",NA,NA
Kernel (reserved for OS),NA,NA
$28,NA,NA
$gp,NA,NA
Global Pointer,NA,NA
$29,NA,NA
$sp,NA,NA
Stack Pointer,NA,NA
$30,NA,NA
$fp,NA,NA
Frame Pointer,NA,NA
$31,NA,NA
$ra,NA,NA
Return Address ,NA,NA
(Automatically used in some instructions),NA,NA
In addition to a ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_7.html (1 of 2) [7/8/2545 18:32:16],NA
"number $0 • $31, registers have a mnemonic name (a name that reminds you of its use). ",NA,NA
For example register $0 has the mnemonic name ,NA,NA
zero,NA,NA
. The table shows the 32 registers ,NA,NA
and their conventional use. ,NA,NA
Registers $0 and $31 are the only two that behave differently from the others. Register $0 is ,NA,NA
permanently wired to contain zero bits. Register $31 is automatically used by some ,NA,NA
subroutine linkage instructions to hold the return address. ,NA,NA
"If this looks totally cryptic, don't worry. Don't try to memorize this. You will get used to what ",NA,NA
you need to know after writting a few programs. ,NA,NA
QUESTION 7:,NA,NA
A program has just calculated an important value which is contained in ,NA,NA
register $8. The program now calls a function to print out the value. What ,NA,NA
might be in $8 upon return? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_7.html (2 of 2) [7/8/2545 18:32:16],NA
A program has just calculated an important value which is contained in register $8. The ,NA,NA
program now calls a function to print out the value. What might be in $8 upon return? ,NA,NA
A good answer might be: ,NA,NA
"The register will contain an unpredictable value, since $8 is also $t0 a non-preserved ",NA,NA
temporary. ,NA,NA
Model Machine Cycle,NA,NA
Of course as long as an executing program makes no function ,NA,NA
calls the values in the temporary registers are safe. ,NA,NA
The MIPS assembly programming model includes a machine ,NA,NA
cycle (repeated here from chapter one). The MIPS endlessly ,NA,NA
cycles through three basic steps. Each cycle executes one ,NA,NA
machine instruction. Everything the processor does is done by a ,NA,NA
"sequence of machine operations. So, also, everything any ",NA,NA
program does is ultimately done by machine operations. ,NA,NA
Fetch the next Instruction.,NA,NA
 The program counter contains ,NA,NA
the address of the next machine instruction. The instruction ,NA,NA
is fetched from memory. ,NA,NA
Increment the PC.,NA,NA
 The address in the program counter is ,NA,NA
incremented by four. ,NA,NA
Execute the Instruction.,NA,NA
 The machine operation specified by the instruction is ,NA,NA
performed. ,NA,NA
QUESTION 8:,NA,NA
Why is the program counter (PC) incremented by four each time? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_8.html [7/8/2545 18:32:37],NA
A good answer might be: ,NA,NA
Each MIPS instruction is 32 bits (four bytes) long. The PC is incremented to point at the next ,NA,NA
instruction. ,NA,NA
Sequential Execution,NA,NA
"MIPS machine instructions are all 32 bits wide (4 bytes). Normally, instructions are executed one ",NA,NA
"after another in the same sequence that they have been placed in memory, starting with the lowest ",NA,NA
address and going up. The execution sequence can be changed with a ,NA,NA
branch,NA,NA
 or a ,NA,NA
jump,NA,NA
 machine ,NA,NA
instruction. ,NA,NA
"Here, for example, is the program from the previous chapter. The three machine instructions have ",NA,NA
"been placed at locations 0x00400000, 0x00400004, and 0x00400008, and are executed in that order. ",NA,NA
QUESTION 9:,NA,NA
"After the instruction at 0x00400008 has executed, what happens? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_9.html [7/8/2545 18:32:44],NA
"After the instruction at 0x00400008 has executed, what happens? ",NA,NA
A good answer might be: ,NA,NA
The processor fetches the 32-bit pattern (whatever it is) at address 0x0040000C and ,NA,NA
tries to execute it as an instruction. ,NA,NA
Control,NA,NA
A bit pattern that is fetched as an instruction is interpretted as an instruction. The bits ,NA,NA
determine what is done in the next machine cycle. If the pattern makes no sense as an ,NA,NA
instruction then normal control flow is interrupted. If it can be interpretted as an instruction ,NA,NA
"then it will be executed, whatever it does. ",NA,NA
The ,NA,NA
control point,NA,NA
 of an executing program is the position of the instruction being executed. ,NA,NA
When an instructiion is being executed (in the third step of the machine cycle) the program ,NA,NA
counter holds the address of the instruction after the control point. ,NA,NA
Normally the control point moves sequentially through the machine instructions. On the ,NA,NA
MIPS this means it normally moves through memory in steps of four bytes (32 bits) at a ,NA,NA
"time. Usually ""control point"" is shortened to ""control"" and the phrase ",NA,NA
flow of control,NA,NA
 means ,NA,NA
how control moves through memory. ,NA,NA
"If control flow leads to an address in memory, then the four bytes starting at that address ",NA,NA
are fetched as a machine instruction. The processor has no other way to tell instructions ,NA,NA
from data. It is common for the control point of a buggy program to enter a section of data. ,NA,NA
This sometimes leads to mystifying results. ,NA,NA
"By software convention, data and instructions are placed in different sections of memory. ",NA,NA
(This helps prevent mystifying results). But this is not a requirement of the architecture. ,NA,NA
QUESTION 10:,NA,NA
Most computer systems start running an operating systems when power is ,NA,NA
"applied. When an application program runs, the operating system passes ",NA,NA
control to the application. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_10.html (1 of 2) [7/8/2545 18:32:48],NA
What must the application do when it is finished running? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_10.html (2 of 2) [7/8/2545 18:32:48],NA
What must the application do when it is finished running? ,NA,NA
A good answer might be: ,NA,NA
Pass control back to the operating system. ,NA,NA
Multitasking,NA,NA
"With DOS, programs were passed control, ran until completion, then passed control back to ",NA,NA
"DOS. So only one application ran at a time. Worse, an application that messed up might ",NA,NA
never return control to DOS and the whole system would freeze. ,NA,NA
"Modern computer systems (1960 and later for mainframes, from 1978 for microcomputers, ",NA,NA
from about 1995 for Windows PCs) include features that can interrupt the control flow of an ,NA,NA
"executing program. After the flow is interrupted, the operating system can give control to ",NA,NA
another application. It this is done many times a second the computer system appears to be ,NA,NA
simultaneously executing several applications. This trick is called ,NA,NA
multitasking,NA,NA
. ,NA,NA
The MIPS chip has very good support for multitasking. But this is an advanced topic not ,NA,NA
included in our basic programming model. ,NA,NA
QUESTION 11:,NA,NA
Do human brains do multitasking? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_11.html [7/8/2545 18:33:03],NA
Are you smarter than DOS? ,NA,NA
A good answer might be: ,NA,NA
Human brains work (mostly) in parallel. Multitasking gives the ,NA,NA
appearance,NA,NA
 of parallel ,NA,NA
processing. Brains and some computers actually do it. ,NA,NA
Model Summary ,NA,NA
Here is a summary of the basic MIPS programming model. Click ,NA,NA
on the hyperlinks for more details. ,NA,NA
Machine Instructions:,NA,NA
Machine instructions,NA,NA
 are thirty-two bits ,NA,NA
"wide. Bit patterns specify the operation, the operands, and the ",NA,NA
"destination for the result. Basic operations are arithmetic, logic, ",NA,NA
"memory access, and control branches. ",NA,NA
Machine Cycle:,NA,NA
 The ,NA,NA
machine cycle,NA,NA
 is illustrated at right. ,NA,NA
Execution proceeds sequentially one instruction at a time. The ,NA,NA
control point,NA,NA
 indicates the instruction about to execute. ALU ,NA,NA
operations never directly access memory. ,NA,NA
Registers:,NA,NA
" Thirty-two 32-bit wide general purpose registers, ",NA,NA
which have various ,NA,NA
conventional uses.,NA,NA
 Register $0 is hard-wired ,NA,NA
to 32 zero-bits. ,NA,NA
Memory:,NA,NA
" Thirty-two bit address space, but only the lower half (most of it anyway) is for user ",NA,NA
programs. User memory is further divided ,NA,NA
(by software convention),NA,NA
 into ,NA,NA
text,NA,NA
", ",NA,NA
data,NA,NA
", and ",NA,NA
stack,NA,NA
segments. ,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-10/ass10_12.html [7/8/2545 18:33:05],NA
CHAPTER 11 — Immediate Operands and ,NA,NA
Bitwise Logic,NA,NA
Some machine instructions contain data as part of the instruction. This data is an ,NA,NA
immediate ,NA,NA
operand.,NA,NA
 The ,NA,NA
ori,NA,NA
 instruction used in the previous chapter contains an immediate operand. ,NA,NA
"In a bitwise logic operation two bit patterns are ""lined up"" and then an operation such as OR ",NA,NA
or AND is performed between pairs of bits. This chpater discusses several such operations ,NA,NA
and them discusses some of the MIPS ,NA,NA
addition,NA,NA
 operations. ,NA,NA
Chapter Topics:,G,NA
Immediate Operands.,G,NA
Bitwise Logic.,G,NA
"Bitwise OR, AND, and XOR ",G,NA
Format of Machine Instructions.,G,NA
Zero Extension of a Bit Pattern.,G,NA
OR Immediate with $0 as a Load Instruction.,NA,NA
QUESTION 1:,NA,NA
Could a 32-bit MIPS instruction hold a 16-bit two's complement integer? ,NA,NA
A good answer might be: ,Yes.,NA
Immediate Operand,"A machine instruction can use some of its bits as one of the operands for 
  
 address         machine code      assembly code
  
 ——————————      ——————————        ————————————
 0x00400000      0x34080002        ori $8,$0,0x2
  
  ----
  
   
 OR Operation on Bits
  
  
  first operand 
  
 0
  
 0
  
 1
  
 1
  
  second operand 0
  
 1
  
 0
  
 1
  
 __
  
 __
  
 __
  
 __
  
  result 
  
 0
  
 1
  
 1
  
 1
  
   
  
 a machine operation. This is called an 
 immediate operand
 . For example, 
 here is one of the instructions from the previous example program: 
  
  
 The last 16 bits (four nibbles) of the machine instruction contain the operand 0x0002. (The assembly 
 language instruction can just say ""0x2""). The machine instruction tells the ALU to perform a 
 bitwise OR 
 between the contents of register $0 and the immediate operand 0x0002. The result is put in register $8. 
  
 A 
 bitwise
  operation is where a logical operation is performed on the bits of each column of the operands. 
 Here is the bitwise OR between two 8-bit patterns: 
  
 0110 1100    operand 
  
 0101 0110    operand
  
 ---------
  
 0111 1110    result",NA
QUESTION 2:,"G
 What bit pattern is contained in register $0 ? 
 G
 How many bits are there per MIPS instruction?
  
  
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_2.html [7/8/2545 18:33:29]",NA
A good answer might be:,G,NA
What bit pattern is contained in register $0 ? ,H,NA
All zero bits ,G,NA
How many bits are there per MIPS instruction? ,H,NA
32 bits,NA,NA
Zero Extension,NA,NA
Here is the instruction we are looking at: ,NA,NA
address         machine code      assembly code,NA,NA
——————————      ——————————        ————————————,NA,NA
"0x00400000      0x34080002        ori $8,$0,0x2",NA,NA
 ----,NA,NA
Sixteen bits of immediate operand ,NA,NA
0000 0000 0000 0010,NA,NA
 are to be bitwise ORed with thirty-,NA,NA
"two bits of register zero, ",NA,NA
0000 0000 0000 0000 0000 0000 0000 0000,NA,NA
. This would not ,NA,NA
"ordinarily be possible. However, MIPS ",NA,NA
zero extends,NA,NA
 the sixteen-bit operand so the ,NA,NA
operands are the same length. Sometimes this is called ,NA,NA
padding with zeros,NA,NA
 on the left. ,NA,NA
 zero extension,NA,NA
---- ---- ---- ----,NA,NA
0000 0000 0000 0000,NA,NA
 0000 0000 0000 0010,NA,NA
   -- zero extended immediate operand ,NA,NA
0000 0000 0000 0000 0000 0000 0000 0000,NA,NA
   -- data in register $0,NA,NA
---------------------------------------,NA,NA
0000 0000 0000 0000 0000 0000 0000 0010,NA,NA
"   -- result, put in register $8",NA,NA
An OR operation is done in each column. The 32-bit result is placed in register $8. ,NA,NA
QUESTION 3:,NA,NA
How are the immediate operand 0x2 and the final contents of $8 related? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_3.html [7/8/2545 18:33:30],NA
How are the immediate operand 0x2 and the final contents of $8 related? ,NA,NA
A good answer might be: ,NA,NA
The 16-bit 0x2 immediate operand has been zero-extended and copied into register $8. ,NA,NA
OR Immediate Instruction,NA,NA
"Because the OR operation was done with the zeros in register $0, the result was a copy of ",NA,NA
the zero-extended immediate operand. Copying a bit pattern into a register is usually called ,NA,NA
loading,NA,NA
 the register. Register $8 was ,NA,NA
loaded,NA,NA
 with a 32-bit pattern. The pattern could ,NA,NA
"represent a postive two. If so, register $8 was loaded with postive two. Here is a description ",NA,NA
of the ,NA,NA
ori,NA,NA
 instruction when used to load a register: ,NA,NA
"ori  d,$0,const    # register d <-- ",NA,NA
const,NA,NA
.,NA,NA
 #                ,NA,NA
const,NA,NA
" is a 16-bit pattern, so ",NA,NA
#                0x0000 ... ,NA,NA
const,NA,NA
 ... 0xFFFF,NA,NA
If ,NA,NA
const,NA,NA
" represents an integer, then 0 <= ",NA,NA
const,NA,NA
 <= 65535. The three operands of the ,NA,NA
"assembly instruction d, $0, and ",NA,NA
const,NA,NA
 must appear in that order. Here is a description of ,NA,NA
the ,NA,NA
ori,NA,NA
 instruction used as a bitwise OR instruction: ,NA,NA
"ori  d,s,const     # register d <-- bitwise OR of ",NA,NA
const,NA,NA
 ,NA,NA
#                with the contents of register $s ,NA,NA
#                ,NA,NA
const,NA,NA
" is a 16-bit pattern, so #                ",NA,NA
0x0000 ... ,NA,NA
const,NA,NA
 ... 0xFFFF,NA,NA
"The three operands of the instruction must appear in the correct order, and ",NA,NA
const,NA,NA
 must be ,NA,NA
within the specified range. If the immediate operand in a source instruction is less than ,NA,NA
sixteen bits (such as 0x2) the assembler expands it to sixteen. If it is more than sixteen bits ,NA,NA
the assebler writes an error message. ,NA,NA
QUESTION 4:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_4.html (1 of 2) [7/8/2545 18:33:32],NA
Is the following instruction correct? ,NA,NA
"ori  $0,$9,0x32",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_4.html (2 of 2) [7/8/2545 18:33:32],NA
A good answer might be: ,NA,NA
"ori  $0,$9,0x32 ",NA,NA
Incorrect. It says to put the result into register $0 (which is always zero and can't be ,NA,NA
loaded with anything else). ,NA,NA
OR Immediate used with Non-zero ,NA,NA
Operands ,NA,NA
The assembler part of the SPIM simulator does not write an error message for the above ,NA,NA
mistaken instruction. But the instruction does not change register zero when executed. ,NA,NA
Here is a tiny program that bitwise ORs two patterns. First one pattern is loaded into register ,NA,NA
"$8, then the register is ORed with an immediate operand. The result goes into register $10. ",NA,NA
## Program to bitwise OR two patterns ,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8,$0,0x0FA5       # put first pattern into register $8",NA,NA
" ori     $10,$8,0x368F       # or ($8) with second pattern.  Result to $10.",NA,NA
## End of file,NA,NA
"We'll assemble and run the program in a bit. You can do this now, if you want (remember ",NA,NA
"you can use copy-and-paste from this page to your text editor). First, let us predict the ",NA,NA
result. ,NA,NA
QUESTION 5:,NA,NA
"Here are the two patterns, written both in bit patterns and in hex. Perform the ",NA,NA
"bitwise OR operation. (Do it with the bits, then re-write the answer in hex). ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_5.html (1 of 2) [7/8/2545 18:33:34],NA
0000 ,NA,NA
1111 ,NA,NA
1010 ,NA,NA
01010FA5 ,NA,NA
0011 ,NA,NA
0110 ,NA,NA
1000 ,NA,NA
1111368F,NA,NA
---- ---- ---- --------,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_5.html (2 of 2) [7/8/2545 18:33:34],NA
A good answer might be:,NA,NA
0000 ,NA,NA
1111 ,NA,NA
1010 ,NA,NA
01010FA5 ,NA,NA
0011 ,NA,NA
0110 ,NA,NA
1000 ,NA,NA
1111368F,NA,NA
---- ,NA,NA
---- ,NA,NA
---- ,NA,NA
--------,NA,NA
0011 1111 1010 11113FAF,NA,NA
Running the Program ,NA,NA
To run the ,NA,NA
2.  Start ,NA,NA
3.  Load ,NA,NA
a ,NA,NA
source ,NA,NA
file.,NA,NA
SPIM.,NA,NA
the source ,NA,NA
The picture shows the result of running the program. The result in $10 is what was ,NA,NA
expected. The source code is at the right of each line in the code window (not seen in the ,NA,NA
cropped window of the picture). The version of the code in the middle column gives the bit ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_6.html (1 of 2) [7/8/2545 18:33:39],NA
patterns in decimal. ,NA,NA
QUESTION 6:,NA,NA
Here is the complete line for the first instruction from the source window: ,NA,NA
"[0x00400000]    0x34080fa5    ori  $8, $0, 4005       ori  $8,$0,0x0FA5",NA,NA
Look at the 32-bit machine instruction. Do you see the immediate operand in it? ,NA,NA
A good answer might be: ,NA,NA
[0x00400000]    0x3408,NA,NA
0fa5,NA,NA
"      ori  $8, $0, 4005     ori  $8,$0,0x",NA,NA
0FA5 ,NA,NA
Yes. How could you miss? The last 16 bits are the immediate operand. ,NA,NA
ORI Machine Code,NA,NA
Below is the machine code for the instruction. In the third line the bits have been grouped ,NA,NA
according to their functional meaning. Documentation for the MIPS shows this grouping for ,NA,NA
each instruction. It is not something you can determine by inspection. ,NA,NA
Look this over to get an idea of how it works. The right six bits of the instruction are the ,NA,NA
opcode,NA,NA
", the bit pattern that specifies the machine operation. The next group of five bits ",NA,NA
specifies the operand register. The group of five after that specifies the destination register. ,NA,NA
The remaining bits are the immediate operand. ,NA,NA
 3    4    0    8    0    f    a    5     -- machine instruction in hex ,NA,NA
0011 01,NA,NA
00 000,NA,NA
0 1000,NA,NA
 0000 1111 1010 0101,NA,NA
    -- machine instruction in bits ,NA,NA
001101,NA,NA
  00000,NA,NA
 01000,NA,NA
 0000 1111 1010 0101,NA,NA
    -- fields of the instructuion ,NA,NA
opcode  oper  dest  immediate operand      -- meaning of the fields,NA,NA
 -and  reg.,NA,NA
 reg.   ,NA,NA
ori     $0      $8     0    f    a    5,NA,NA
QUESTION 7:,NA,NA
Here is the ,NA,NA
ori,NA,NA
" instruction again, but the patterns that specify the operand ",NA,NA
"register, the destination register, and the immediate operand are blank. Fill in ",NA,NA
"the blanks so the operand register is $10, the destination register is $9, and ",NA,NA
the immediate operand is 0xAFF0 ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_7.html (1 of 2) [7/8/2545 18:33:42],NA
001101 ,NA,NA
_ _ _ _ _   _ _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _ ,NA,NA
ori     $10          $9         a         f        f        0 ,NA,NA
 operand        dest           immediate operand,NA,NA
 reg.           reg.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_7.html (2 of 2) [7/8/2545 18:33:42],NA
A good answer might be:,NA,NA
 0 1 0 1 0  0 1 0 0 1  1 0 1 0  1 1 1 1  1 1 1 1  0 0 0 0 ,NA,NA
001101 ,NA,NA
_ _ _ _ _  _ _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _,NA,NA
ori     $10          $9         a         f        f        0 ,NA,NA
 operand      dest           immediate operand,NA,NA
 reg.         reg.,NA,NA
Machine Instructions Compared,NA,NA
Here again is the ,NA,NA
ori,NA,NA
 machine instruction: ,NA,NA
 3    4    0    8    0    f    a    5     -- machine instruction in hex ,NA,NA
001101,NA,NA
  00000,NA,NA
 01000,NA,NA
 0000 1111 1010 0101,NA,NA
    -- fields of the instructuion ,NA,NA
opcode  oper  dest  immediate operand      -- meaning of the fields,NA,NA
 -and  reg.,NA,NA
 reg.   ,NA,NA
ori     $0      $8     0    f    a    5,NA,NA
The layout of this machine instruction is different from the ,NA,NA
addu,NA,NA
 instruction we looked at in ,NA,NA
chapter 10: ,NA,NA
 0    1    0    9    5    0    2    1    -- machine instruction in hex ,NA,NA
000000,NA,NA
01000,NA,NA
01001,NA,NA
01010,NA,NA
00000,NA,NA
100001,NA,NA
      -- fields of the instructuion ,NA,NA
opcode oprnd oprnd dest  ----- 2ndary      -- meaning of the fields ,NA,NA
ALUop   $8    $9   $10           addu,NA,NA
Both instructions are 32 bits wide (as are all MIPS R2000/R3000 instructions). The first six ,NA,NA
"bits is the opcode, which calls for an ALU operation. The ",NA,NA
addu,NA,NA
 instruction further specifiies ,NA,NA
"the operation in the last six bits, the ",NA,NA
secondary opcode.,NA,NA
 The ,NA,NA
addu,NA,NA
 instruction does not ,NA,NA
have an immediate operand. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_8.html (1 of 2) [7/8/2545 18:33:46],NA
QUESTION 8:,NA,NA
Do the ,NA,NA
fields,NA,NA
 of two different machine instructions necessarily have the same ,NA,NA
size and same meaning? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_8.html (2 of 2) [7/8/2545 18:33:46],NA
Do the ,NA,NA
fields,NA,NA
 of two different machine instructions necessarily have the same size and same ,NA,NA
meaning? ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
Uses of Bitwise Logic ,NA,NA
The first six bits of the instruction (the opcode) specify the machine operation. (Sometimes ,NA,NA
the secondary opcode is needed as well). The opcode also specifies the fields of the rest of ,NA,NA
the instruction and their meaning. A human needs to look at documentation to firgure this ,NA,NA
out. The MIPS chip is hardwired to do it. ,NA,NA
Recall (from the second chapter) the fourth advantage of binary: ,NA,NA
1.  ,NA,NA
Simple; easy to build.,NA,NA
2.  ,NA,NA
Unambiguous signals (hence noise immunity).,NA,NA
3.  ,NA,NA
Flawless copies can be made.,NA,NA
4.  Anything that can be represented with some sort of pattern can be ,NA,NA
represented with patterns of bits.,NA,NA
Most computers have built-in integer arithmetic operations and often built-in floating point ,NA,NA
operations. But computers are used for much more than numbers! Bit patterns are used to ,NA,NA
represent very many things. Bitwise logic is needed when computing with bit patterns in all ,NA,NA
their various uses. ,NA,NA
"For example, a document created with a word processor has font and formatting information ",NA,NA
embedded within it. The information is encoded with bit patterns in ways specific to each ,NA,NA
word processor family. A word processor program must use bitwise operations to process ,NA,NA
these codes. ,NA,NA
QUESTION 9:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_9.html (1 of 2) [7/8/2545 18:33:50],NA
What type of program reads in strings of symbols encoded in ascii and ,NA,NA
outputs bit patterns that encode data and operations? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_9.html (2 of 2) [7/8/2545 18:33:50],NA
A good answer might be: ,NA,NA
An assembler. ,NA,NA
Handy AND Immediate Instruction,NA,NA
An assembler uses bit manipulation to put together (to ,NA,NA
and will use its bitwise operators. But they ultimately ,NA,NA
become the processor's bitwise operations. ,NA,NA
The ,NA,NA
andi,NA,NA
 instruction does a bitwise AND of two 32-bit ,"AND Operation on Bits
  
  
  first operand 
  
 0
  
 0
  
 1
  
 1
  
  second operand 0
  
 1
  
 0
  
 1
  
 __
  
 __
  
 __
  
 __
  
  result 
  
 0
  
 0
  
 0
  
 1",NA
"""assemble) the bit patterns of each machine instruction. ",NA,NA
This is a typical assignment in a systems programming ,NA,NA
"course. Of course, you will likely write your assembler in C ",NA,NA
patterns. At run time the 16-bit immediate operand is ,NA,NA
padded on the left with zero bits to make it a 32-bit operand. ,NA,NA
"andi d,s,const     # register d <-- bitwise AND of immediate operand ",NA,NA
const,NA,NA
 ,NA,NA
#                and the contents of register $s.,NA,NA
 #                ,NA,NA
const,NA,NA
" is a 16-bit pattern, so",NA,NA
 #                0x0000 ... ,NA,NA
const,NA,NA
 ... 0xFFFF,NA,NA
"The three operands of the instruction must appear in the correct order, and ",NA,NA
const,NA,NA
 must be ,NA,NA
within the specified range. If the immediate operand in a source instruction is less than ,NA,NA
sixteen bits (such as 0x2) the assembler expands it to sixteen. If it is more than sixteen bits ,NA,NA
the assebler writes an error message. ,NA,NA
QUESTION 10:,NA,NA
Is the following instruction correct? What does it do? ,NA,NA
"andi $8,$0,0xFFFF",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_10.html [7/8/2545 18:34:10],NA
Is the following instruction correct? What does it do? ,NA,NA
"andi $8,$0,0xFFFF",NA,NA
A good answer might be:,NA,NA
"It is correct, but not very sensible. It ANDs the contents of the zero register (all zeros) ",NA,NA
"with the immediate operand and puts the result in register $8. Of course, the result is all ",NA,NA
"zeros, regardless of the immediate operand. ",NA,NA
Exclusive Or Immediate,NA,NA
Filling a register with all zero bits is called ,NA,NA
clearing,NA,NA
 the ,NA,NA
"register. Clearing a register is common, but the above ",NA,NA
instruction is not the best way to do it. ,NA,NA
An ,NA,NA
exclusive OR,NA,NA
 is nearly the same as the more common ,NA,NA
OR (the ,NA,NA
inclusive OR,NA,NA
) except that the result is zero when ,NA,NA
both operands are one. ,"XOR Operation on Bits
  
  
  first operand 
  
 0
  
 0
  
 1
  
 1
  
  second operand 0
  
 1
  
 0
  
 1
  
 __
  
 __
  
 __
  
 __
  
  result 
  
 0
  
 1
  
 1
  
 0",NA
Here is a description of the assembly language instruction. The machine language for the ,NA,NA
instruction looks much the same as the ,NA,NA
ori,NA,NA
 and the ,NA,NA
andi,NA,NA
 instruction. ,NA,NA
"xori d,s,const     # register d <-- bitwise XOR of immediate operand ",NA,NA
const,NA,NA
 ,NA,NA
#                and the contents of register $s.,NA,NA
 #                ,NA,NA
const,NA,NA
" is a 16-bit pattern, so",NA,NA
 #                0x0000 ... ,NA,NA
const,NA,NA
 ... 0xFFFF,NA,NA
"The three operands of the instruction must appear in the correct order, and ",NA,NA
const,NA,NA
 must be ,NA,NA
within the specified range. If the immediate operand in a source instruction is less than ,NA,NA
sixteen bits (such as 0x2) the assembler expands it to sixteen. If it is more than sixteen bits ,NA,NA
the assebler writes an error message. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_11.html (1 of 2) [7/8/2545 18:34:15],NA
QUESTION 11:,NA,NA
"Here are the two patterns, written both in bit patterns and in hex. Perform the ",NA,NA
"bitwise XOR operation. (Do it with the bits, then re-write the answer in hex). ",NA,NA
0000 ,NA,NA
1111 ,NA,NA
1010 ,NA,NA
01010FA5 ,NA,NA
0011 ,NA,NA
0110 ,NA,NA
1000 ,NA,NA
1111368F,NA,NA
---- ---- ---- --------,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_11.html (2 of 2) [7/8/2545 18:34:15],NA
A good answer might be:,"0000 
 1111 
 1010 
 01010FA5 
  
 0011 
 0110 
 1000 
 1111368F
  
 ---- 
 ---- 
 ---- 
 --------
  
 0011 1001 0010 1010392A",NA
Example Program ,"Here is a program that does all three bitwise operations between the same two patterns. The register is 
 different in each case. 
  
 ## Program to bitwise OR, AND, and XOR two patterns 
  
  .text
  
  .globl  main
  
 main:
  
  ori     $15, $0,0x0FA5       # put bit pattern register into $15 
 ori      $8,$15,0x368F       # OR with second pattern
  
  andi     $9,$15,0x368F       # AND with second pattern xori    
 $10,$15,0x368F       # XOR with second pattern
  
 ## End of file 
  
 Running it in SPIM (pushing F10 four times) results in the following:",NA
QUESTION 12:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_12.html (1 of 2) [7/8/2545 18:34:26],NA
What is the exclusive-OR of a bit pattern with itself? ,NA,NA
A good answer might be: ,NA,NA
The result is all zero-bits. ,NA,NA
End of the Chapter ,NA,NA
"Because the two operand are the same, the only two XOR operations involved are 0 XOR 0 ",NA,NA
= 0 and 1 XOR 1 = 0. ,NA,NA
You have reached the end of this chapter. It's only logical that you wish to review. Click on a ,NA,NA
blue subject that interests you to immediately go to where it was discussed. To get back ,NA,NA
"here, click on the ""back arrow"" button of your browser. ",G,NA
Immediate Operands.,G,NA
Bitwise Logic.,G,NA
ORI,NA,NA
 instruction. ,G,NA
Machine code,NA,NA
 or the ORI instruction ,G,NA
ANDI,NA,NA
 instruction ,G,NA
XORI,NA,NA
 instruction. ,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/ass11_13.html [7/8/2545 18:34:31],NA
CHAPTER 12 — Shift Instructions and ,NA,NA
Logic Instructions,NA,NA
Chapter Topics:,G,NA
Logical shift instructions (sll and srl).,G,NA
No-op as a shift instruction.,G,NA
"Register-to-register bitwise logic instructions (or, and, xor, and nor). ",G,NA
NOT as a NOR operation.,G,NA
MOVE as an OR operation.,G,NA
Example program: instruction assembly.,NA,NA
QUESTION 1:,NA,NA
(Review:) If a bit pattern that represents an integer (say 0110 0001) is shifted ,NA,NA
left by one bit (say 1100 0010) what does the new bit pattern represent? ,NA,NA
(Review:) If a bit pattern that represents an integer N (say 0011 0001) is shifted left by one ,NA,NA
bit (say 0110 0010) what does the new bit pattern represent? ,NA,NA
A good answer might be: ,NA,NA
"2N, twice the original integer. 0011 0001 = 49",10,NA
. 0110 0010 = 98,10,NA
. (But you need to ,NA,NA
worry about what happens with the high-order bit if you shift too much).,NA,NA
Shift Left Logical,NA,NA
A ,NA,NA
logical left shift,NA,NA
 of one ,NA,NA
position moves each bit to ,NA,NA
the left by one. The low-,NA,NA
order bit gets a zero (in all ,NA,NA
cases) and the high-order ,NA,NA
bit is discarded. ,NA,NA
Shifting by two positions is ,NA,NA
the same as performing a ,NA,NA
one-position shift two ,NA,NA
times. Shifting by zero ,NA,NA
positions leaves the pattern ,NA,NA
unchanged. Shifting an N-,NA,NA
bit pattern left logical by N ,NA,NA
or more makes all N bits ,NA,NA
zero. ,NA,NA
MIPS performs the operation on a 32-bit register and puts the result in a 32-bit register. ,NA,NA
"sll  d,s,shft      # $d <-- logical left shift of $s by shft positions,",NA,NA
 #           where  0 <= shft < 32,NA,NA
The ALU (arithmetic/logic unit) which does the operation pays no attention to what the bits ,NA,NA
"mean. If the bits represent an unsigned integer, then a left shift is equivalent to multiplying ",NA,NA
the integer by two. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_2.html (1 of 2) [7/8/2545 18:34:47],NA
QUESTION 2:,NA,NA
Here is an 8-bit pattern. Shift it left (logical) by two. Write the hex for the new ,NA,NA
pattern ,NA,NA
0x6F     0110 1111     <-- before,NA,NA
 <-- after,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_2.html (2 of 2) [7/8/2545 18:34:47],NA
A good answer might be: ,NA,NA
0x6F     0110 1111     <-- before ,NA,NA
0xBC     1011 1100     <-- after,NA,NA
Shifty Program,NA,NA
"This program does the shift you just performed by hand. It does it with 32-bit patterns, but ",NA,NA
for the right-most eight bits the result is the same. ,NA,NA
## shiftTwo.asm ,NA,NA
## ,NA,NA
## Program to logical shift left a pattern,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8, $0, 0x6F       # put bit pattern register into $8",NA,NA
" sll      $9, $8, 2          # shift left logical by two",NA,NA
## End of file,NA,NA
Running the program does this: ,NA,NA
QUESTION 3:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_3.html (1 of 2) [7/8/2545 18:35:04],NA
Do you think it would be OK to shift the contents of register $8 and put the ,NA,NA
result back in register $8 : ,NA,NA
" ori      $8, $0, 0x6F       # put bit pattern register into $8",NA,NA
 sll      ,NA,NA
"$8, $8,",NA,NA
 2          # shift left logical by two,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_3.html (2 of 2) [7/8/2545 18:35:04],NA
" ori      $8, $0, 0x6F       # put bit pattern register into $8",NA,NA
 sll      ,NA,NA
"$8, $8,",NA,NA
 2          # shift left logical by two,NA,NA
A good answer might be: ,NA,NA
"Yes, this is OK. ",NA,NA
Shifting in Place,NA,NA
When an ALU operation is performed: (1) data is copied from the register(s) into the ALU. ,NA,NA
"Then (2), the ALU does the operation. Next (3) the result is written to the designated result ",NA,NA
register. The result register can be an operand register without a problem because the ,NA,NA
operand data was transfered to the ALU in step (1). ,NA,NA
Sending the result back to the source register is called ,NA,NA
shifting in place,NA,NA
. This phrase is ,NA,NA
misleading because actually the shift is done in the ALU and the register gets a copy. Here ,NA,NA
is the machine instruction corresponding to the ,NA,NA
sll,NA,NA
 in the program: ,NA,NA
 0    0    0    8    4    8    8    0    -- machine instruction in hex ,NA,NA
0000 00,NA,NA
00 000,NA,NA
0 1000,NA,NA
 0100 1,NA,NA
000 10,NA,NA
00 0000,NA,NA
    -- machine instruction in bits ,NA,NA
000000,NA,NA
00000,NA,NA
01000,NA,NA
01000,NA,NA
00010,NA,NA
000000,NA,NA
    -- fields of the instructuion ,NA,NA
opcode ----- source dest   shft  2ndary    -- meaning of the fields ,NA,NA
ALUop          $8    $8     2    sll,NA,NA
The ,NA,NA
sll,NA,NA
 operation is signified by the 6-bit zero at the beginning of the instruction and the 6-,NA,NA
"bit zero at the end. The remaining fields give the source register ($8 in this case), the ",NA,NA
"destination register ($8 in this case), and the amount of positions to shift (2). ",NA,NA
QUESTION 4:,NA,NA
Study the above instruction. Write the instruction for ,NA,NA
shift-left-logical the ,NA,NA
pattern in $0 by zero positions and leave the result in $0,NA,NA
: ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_4.html (1 of 2) [7/8/2545 18:35:07],NA
"sll      $0, $0, 0          # fun machine instruction ",NA,NA
Hint: on the midterm I expect you to write the 32-bit pattern for this instruction without ,NA,NA
hesitation! Memorize it now! ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_4.html (2 of 2) [7/8/2545 18:35:07],NA
Not too hard to memorize zero. ,NA,NA
A good answer might be:,NA,NA
 0    0    0    0    0    0    0    0    -- machine instruction in hex ,NA,NA
0000 00,NA,NA
00 000,NA,NA
0 0000,NA,NA
 0000 0,NA,NA
000 00,NA,NA
00 0000,NA,NA
    -- machine instruction in bits ,NA,NA
000000,NA,NA
00000,NA,NA
00000,NA,NA
00000,NA,NA
00000,NA,NA
000000,NA,NA
    -- fields of the instructuion ,NA,NA
opcode -----  $0    $0       0   2ndary    -- meaning of the fields ,NA,NA
sll         source  dest  shft   sll,NA,NA
No-Op,NA,NA
Register $0 always contains a 32-bit zero (have you heard this before?) so shifting it left by ,NA,NA
zero positions and attempting to put the result back in $0 does nothing. Any instruction that ,NA,NA
"attempts to alter $0 does nothing, but this instruction is the preferred way of doing nothing. ",NA,NA
A machine instruction that does nothing is called (in official computer science jargon) a ,NA,NA
no-,NA,NA
op,NA,NA
. The ,NA,NA
no operation,NA,NA
" instruction is surprisingly useful, especially for MIPS. ",NA,NA
QUESTION 5:,NA,NA
What do you call a human who does nothing? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_5.html [7/8/2545 18:35:16],NA
A good answer might be: ,NA,NA
shiftless ,NA,NA
Logical Shift Right,NA,NA
MIPS also has a ,NA,NA
logical ,NA,NA
right shift,NA,NA
 instruction. It ,NA,NA
moves bit to the right by a ,NA,NA
number of positions less ,NA,NA
than 32. The high-order bit ,NA,NA
gets zeros and the low-,NA,NA
order bits are discarded. ,NA,NA
If the bit pattern is ,NA,NA
regarded as an unsigned ,NA,NA
"integer, or a positive two's ",NA,NA
"comp. integer, then a right ",NA,NA
shift of one bit position ,NA,NA
performs an integer divide ,NA,NA
by two. A right shift by N positions performs an integer divide by 2,N,NA
. ,NA,NA
"The ""trick"" of dividing an integer by shifting should not be used in place of the MIPS ",NA,NA
"arithmetic divide instruction (which will be covered in a few chapters). If you mean ""divide"" ",NA,NA
"that is what you should write. But the trick is often used in hardware, and sometimes pops ",NA,NA
"up in odd software uses, so you should know about it. ",NA,NA
"srl  d,s,shft      # $d <-- logical right shift of $s by shft positions.",NA,NA
 ,NA,NA
"#           shft is a 4-bit integer, 0 <= shft < 32",NA,NA
QUESTION 6:,NA,NA
(Trick Question:) What is the net result if a bit pattern is logical left shifted 2 ,NA,NA
positions and the logical right shifted 2 positions? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_6.html [7/8/2545 18:35:28],NA
(Trick Question:) What is the net result if a bit pattern is logical left shifted 2 positions then ,NA,NA
logical right shifted 2 positions? ,NA,NA
A good answer might be: ,NA,NA
The two bits on the right and left of the pattern are guaranteed to be zero; the middle ,NA,NA
bits are not changed. ,NA,NA
OR Instruction,NA,NA
MIPS has many instructions that use two registers as operands and puts the result in a ,NA,NA
"register. All the action takes place inside the processor: the data comes from registers, the ",NA,NA
"ALU performs the operation, and the result is written to a register. All this can be done ",NA,NA
quickly. ,NA,NA
"The assembly language must specify four things: (1) the operation, (2) the first operand ",NA,NA
"register, (3) the second operand register, and (4) the destination register. Of course, the ",NA,NA
machine language must encode the same four things in bit patterns. ,NA,NA
Here is the register to register OR instruction: ,NA,NA
"or  d,s,t        # $d <-- bitwise OR between $s with $t.",NA,NA
Recall that the result of OR is zero only when both operand bits are zero. ,NA,NA
QUESTION 7:,NA,NA
What is the bitwise OR of the following? ,NA,NA
FEED ,NA,NA
BECA,NA,NA
----,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_7.html [7/8/2545 18:35:29],NA
A good answer might be:,NA,NA
FEED      1111 1110 1110 1101 ,NA,NA
BECA      1011 1110 1100 1010,NA,NA
----      ---- ---- ---- ----,NA,NA
FEEF      1111 1110 1110 1111,NA,NA
"It is usually easiest to translate into bits, do the OR, then translate back to hex. ",NA,NA
AND Instruction,NA,NA
MIPS has a register-to-register AND instruction: ,NA,NA
"and  d,s,t        # $d <-- bitwise AND between $s with $t.",NA,NA
Recall that the result of AND is one only when both operand bits are one. ,NA,NA
QUESTION 8:,NA,NA
What is the bitwise AND of the following? ,NA,NA
FEED ,NA,NA
BECA,NA,NA
----,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_8.html [7/8/2545 18:35:33],NA
A good answer might be:,NA,NA
FEED      1111 1110 1110 1101 ,NA,NA
BECA      1011 1110 1100 1010,NA,NA
----      ---- ---- ---- ----,NA,NA
BEC8      1011 1110 1100 1000,NA,NA
XOR Instruction,NA,NA
You will not be surprised to find that there is a register-to-register XOR instruction: ,NA,NA
"xor  d,s,t        # $d <-- bitwise XOR between $s with $t.",NA,NA
Recall that the result of XOR is one when only one operand bit is one. ,NA,NA
QUESTION 9:,NA,NA
What is the bitwise XOR of the following? ,NA,NA
FEED ,NA,NA
BECA,NA,NA
----,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_9.html [7/8/2545 18:35:39],NA
A good answer might be:,NA,NA
FEED      1111 1110 1110 1101 ,NA,NA
BECA      1011 1110 1100 1010,NA,NA
----      ---- ---- ---- ----,NA,NA
4027      0100 0000 0010 0111,NA,NA
NOR Instruction,NA,NA
There is a register-to--register bitwise NOR instruction. ,NA,NA
There is no immediate operand NOR instruction. NOR is ,NA,NA
"equivalent to performing the OR operation, then ",NA,NA
complementing the bits (change 0 to 1 and 1 to 0). Here is ,NA,NA
the assembly language for it: ,NA,NA
"nor  d,s,t    # $d <-- bitwise NOR ",NA,NA
 # between $s with $t.,"NOR Operation on Bits
  
  
  first operand 
  
 0
  
 0
  
 1
  
 1
  
  second operand 0
  
 1
  
 0
  
 1
  
 __
  
 __
  
 __
  
 __
  
  result 
  
 1
  
 0
  
 0
  
 0",NA
QUESTION 10:,NA,NA
What is the bitwise NOR of the following? ,NA,NA
FEED ,NA,NA
BECA,NA,NA
----,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_10.html [7/8/2545 18:35:48],NA
A good answer might be:,NA,NA
FEED      1111 1110 1110 1101 ,NA,NA
BECA      1011 1110 1100 1010,NA,NA
----      ---- ---- ---- ----,NA,NA
0110      0000 0001 0001 0000,NA,NA
Summary,NA,NA
The table shows the register-to-register bitwise logic operations. Register ,NA,NA
d,NA,NA
 is the ,NA,NA
destination (where the result goes); the other two registers ,NA,NA
s,NA,NA
 and ,NA,NA
t,NA,NA
 contain the operands. ,NA,NA
AND ,NA,NA
OR ,NA,NA
XOR,NA,NA
NOR,NA,NA
"and d,s,t ",NA,NA
"or d,s,t",NA,NA
"xor d,s,t",NA,NA
"nor d,s,t",NA,NA
$d <— $s and $t $d <— $s or $t $d <— $s xor $t $d <— $s nor $t ,NA,NA
Here is a summary of the operations: ,NA,NA
operand ,NA,NA
0,NA,NA
0,NA,NA
1,NA,NA
1,NA,NA
operand ,NA,NA
0,NA,NA
1,NA,NA
0,NA,NA
1,NA,NA
AND ,NA,NA
0,NA,NA
0,NA,NA
0,NA,NA
1,NA,NA
OR ,NA,NA
0,NA,NA
1,NA,NA
1,NA,NA
1,NA,NA
XOR ,NA,NA
0,NA,NA
1,NA,NA
1,NA,NA
0,NA,NA
NOR ,NA,NA
1,NA,NA
0,NA,NA
0,NA,NA
0,NA,NA
QUESTION 11:,NA,NA
Fill in the following: ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_11.html (1 of 2) [7/8/2545 18:35:59],NA
0 NOR 0 = ____  NOT 0 = ____ ,NA,NA
1 NOR 0 = ____  NOT 1 = ____,NA,NA
Now answer the question: NOT X  =  X ____ ____ ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_11.html (2 of 2) [7/8/2545 18:35:59],NA
A good answer might be: ,NA,NA
0 NOR 0 = ,NA,NA
1,NA,NA
  NOT 0 = ,NA,NA
1 ,NA,NA
1 NOR 0 = ,NA,NA
0,NA,NA
  NOT 1 = ,NA,NA
0 ,NA,NA
Now: NOT X  =  X ,NA,NA
NOR0,NA,NA
NOT as NOR with $0,NA,NA
The NOT operation is done by using the NOR instruction with ,NA,NA
$0 as one of the operands: ,NA,NA
"nor  d,s,$0        # $d <-- bitwise NOT of $s.","NOT Operation on Bits
  
  
  first operand 
  
 0
  
 1
  
  result 
  
 __
  
 __
  
 1
  
 0",NA
QUESTION 12:,NA,NA
Say that register $8 contains a bit pattern. OR is performed between it and ,NA,NA
register $0. Register $9 is to be the destination. What is the effect? ,NA,NA
"or  d,s,$0",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_12.html [7/8/2545 18:36:05],NA
A good answer might be: ,NA,NA
The bit pattern in $s is moved to $d ($s is unchanged). ,NA,NA
"or  d,s,$0        # $d <-- contents of $s.",NA,NA
MOVE as OR with Zero,NA,NA
Copying the pattern in a source register to a destination register is called a ,NA,NA
move,NA,NA
" operation, ",NA,NA
even though the source register does not change. ,NA,NA
"or  d,s,$0        # $d <-- contents of $s.",NA,NA
QUESTION 13:,NA,NA
(Review:) How can a particular bit pattern be loaded into a register? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_13.html [7/8/2545 18:36:11],NA
How can a particular bit pattern be loaded into a register? ,NA,NA
A good answer might be: ,NA,NA
With an ,NA,NA
ori,NA,NA
 instruction. ,NA,NA
Example Program,NA,NA
Here are the fields of the ,NA,NA
ori,NA,NA
" instruction. The numbers in the first row are bit positions, ",NA,NA
numbered from the low-order bit on the right. The opcode of the instruction is 0xD. The ,NA,NA
source register is ,NA,NA
s,NA,NA
", the destination register is ",NA,NA
d,NA,NA
", and the immediate operand is ",NA,NA
const,NA,NA
. ,NA,NA
31....26 25...21 20...16 15...................0,NA,NA
0xD,NA,NA
s,NA,NA
d,NA,NA
unsigned const,NA,NA
Our example program will assemble the machine code that corresponds to the assembly ,NA,NA
language instruction: ,NA,NA
"ori  $8,$9,0x004A",NA,NA
The instruction will be assembled in register $25. The program uses bitwise and shift ,NA,NA
operations. Let us say that this example is part of a larger program. It is wise to initialize $25 ,NA,NA
to contain all zeros (this is called ,NA,NA
clearing,NA,NA
 the register). ,NA,NA
QUESTION 14:,NA,NA
What assembly language instruction clears register $25 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_14.html [7/8/2545 18:36:22],NA
What assembly language instruction clears register $25 ? ,NA,NA
A good answer might be: ,NA,NA
"or  $25,$0,$0        # $d <-- $0 ",NA,NA
"(There are others that work, but this is the clearest). ",NA,NA
Target Instruction,NA,NA
The program starts with: ,NA,NA
"or  $25,$0,$0        # clear $25",NA,NA
Now the correct bit patterns are placed into the fields of the instruction. The instruction we ,NA,NA
are assembling is: ,NA,NA
"ori  $8,$9,0x004A",NA,NA
QUESTION 15:,NA,NA
Fill in the third row with the bit patterns. Use hexadecimal (assume that the ,NA,NA
bit patterns are truncated on the left to make them the right size). ,NA,NA
"ori     $8,$9,0x004A",NA,NA
31....26 25...21 20...16 15...................0,NA,NA
0xD,NA,NA
s,NA,NA
d,NA,NA
unsigned const,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_15.html [7/8/2545 18:36:55],NA
A good answer might be:,NA,NA
"ori     $8,$9,0x004A",NA,NA
31....26 25...21 20...16 15...................0,NA,NA
0xD,NA,NA
s,NA,NA
d,NA,NA
unsigned const,NA,NA
0xD,NA,NA
0x9,NA,NA
0x8,NA,NA
0x004A,NA,NA
Individual Field Values,NA,NA
There are four fields in the instruction. We know the bit pattern that goes into each field. Let ,NA,NA
"us put those patterns in registers $11, $12, $13, and $14. The program (so far) looks like: ",NA,NA
"or    $25,$0,$0        # clear $25 ",NA,NA
"ori   $11,$0,________  # opcode ",NA,NA
"ori   $12,$0,________  # operand $s ",NA,NA
"ori   $13,$0,________  # dest. $d ",NA,NA
"ori   $14,$0,________  # immediate operand",NA,NA
QUESTION 16:,NA,NA
Fill in the field values ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_16.html [8/8/2545 13:35:40],NA
A good answer might be: ,NA,NA
See below ,NA,NA
Shifting the Opcode,NA,NA
The ,NA,NA
ori,NA,NA
 puts its immediate operand in the low order bits (the right-most bits) of its ,NA,NA
"destination register. So now, with the following code, the registers have the correct patterns ",NA,NA
but the patterns are not in the correct fields. ,NA,NA
"or    $25,$0,$0        # clear $25 ",NA,NA
"ori   $11,$0,0xD       # opcode ",NA,NA
"ori   $12,$0,0x9       # operand $s ",NA,NA
"ori   $13,$0,0x8       # dest. $d ",NA,NA
"ori   $14,$0,0x004A    # immediate operand",NA,NA
"Register $11 contains the opcode in its right-most bits, like this: ",NA,NA
31....26 25...21 20...16,NA,NA
15...................0,NA,NA
000000 00000,NA,NA
00000 0000 0000 0000 1101,NA,NA
"However, the opcode is required to be in the high-order six bits, 26 through 31. A ",NA,NA
sll,NA,NA
 will ,NA,NA
shift the contents of $11 into the correct position. ,NA,NA
QUESTION 17:,NA,NA
Fill in the amount by which to shift. (Hint: determine which bit should be the ,NA,NA
new left-most bit. Count the number of bits between its old and new ,NA,NA
position). ,NA,NA
"sll   $11,$11,_____    # left shift $11 by ______ places",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_17.html [8/8/2545 13:36:17],NA
A good answer might be: ,NA,NA
"sll   $11,$11,26    # left shift $11 by 26 places",NA,NA
Program So Far,NA,NA
Arithmetic gives us the same answer. Bit position 5 contains the right-most bit of the six-bit ,NA,NA
"opcode. It must be shifted into position 31, and 31-5 = 26. ",NA,NA
Here is a run of the program so far. The source code is seen at the right in the window. ,NA,NA
Great! Now we have the correct bit pattern placed in the correct 6-bit field. Only one problem: ,NA,NA
it's in the wrong register. The instruction is supposed to be in register $25. ,NA,NA
QUESTION 18:,NA,NA
Think of an assembly instruction that will put the opcode into register $25. ,NA,NA
Here is a start: ,NA,NA
"or   $25,$___,$___    # move opcode into target register",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_18.html [8/8/2545 13:36:52],NA
A good answer might be: ,NA,NA
"or   $25,$25,$11    # move opcode into target register ",NA,NA
Alternative: ,NA,NA
"or   $25,$11,$0     # move opcode into target register",NA,NA
Source Register,NA,NA
Now move the bit pattern for the source register $9 into the correct field. Register $12 ,NA,NA
"contains the pattern in its right-most bits, like in the left table. The pattern should be in bits ",NA,NA
25...21 of register $25 as at right. ,"31....26 25...21 20...16
  
  
  
  
   
  
 15...................0
  
  
 0000 0000 0000 1001
  
   
  
 000000
  
  
  
 00000
  
  
  
 00000
  
  
  
  
  
  
 ori     $8,$9,0x004A
  
   
  
 31....26 25...21 20...16 15...................0
  
  
  
  
  
  
    
  
 0xD
  
  
  
 s
  
  
  
 d
  
  
  
 unsigned const
  
  
  
 0xD
  
  
  
 0x9
  
  
  
 0x8
  
  
  
 0x004A",NA
The same method can be used for this as for the opcode. There is a slight problem: the ,NA,NA
opcode already in $25 must not be erased. ,NA,NA
QUESTION 19:,NA,NA
Fill in the next part of the program ,NA,NA
"sll   $12,$12,_____      # left shift s by _____ places ",NA,NA
"or    $25,_____,_____    # move s into target register",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_19.html [8/8/2545 13:37:29],NA
A good answer might be: ,NA,NA
"sll   $12,$12,21      # left shift s by 21 places or    ",NA,NA
"$25,$25,$12     # move s into target register",NA,NA
ORing in a Field,NA,NA
The low-order bit of the pattern for $s is in bit position 0 (of register $12). It must be moved to ,NA,NA
"position 21 of the instruction. Next, the ",NA,NA
or,NA,NA
 copies it into the instruction being assembled. ,NA,NA
The ,NA,NA
or,NA,NA
 works like this: ,NA,NA
31....26 25...21 20...16 15.............................0,NA,NA
Register $12 (before) 000000 01001,NA,NA
00000,NA,NA
0000 0000 0000 0000,NA,NA
Register $25 (before) 001101 00000,NA,NA
00000,NA,NA
0000 0000 0000 0000,NA,NA
Register $25 (after) ,NA,NA
001101 01001,NA,NA
00000,NA,NA
0000 0000 0000 0000,NA,NA
QUESTION 20:,NA,NA
Would this instruction have worked as well? ,NA,NA
or    ,NA,NA
"$25,$0,$12     # move s into target register",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_20.html [8/8/2545 13:37:31],NA
Would this instruction have worked as well? ,NA,NA
"or    $25,$0,$12     # move s into target register",NA,NA
A good answer might be: ,NA,NA
"No---the 32-bit result ($0 OR $12) is moved into $25, destroying the opcode already ",NA,NA
there. ,NA,NA
$25 ,NA,NA
<--,NA,NA
" ($0  OR $12)     or  $25,$0,$12    # wrong ",NA,NA
$25 ,NA,NA
<--,NA,NA
" ($25 OR $12)     or  $25,$25,$12   # right",NA,NA
Destination Register and Const,NA,NA
The same method is used with the bit pattern that ,NA,NA
"in register #13, and it is in the correct field. It needs to ",NA,NA
be copied into $25 The complete program follows. ,NA,NA
The comments on each line have been improved. ,NA,NA
Comments should describe the work done in solving ,NA,NA
"ori     $8,$9,0x004A",NA,NA
31....26 25...21 20...16 15...................0,NA,NA
opcode ,NA,NA
s ,NA,NA
d ,NA,NA
unsigned const ,NA,NA
0xD ,NA,NA
0x9 ,NA,NA
0x8 ,NA,NA
0x004A ,NA,NA
designates the destination register. The ,NA,NA
const,NA,NA
 part is ,NA,NA
the problem. They should ,NA,NA
not,NA,NA
" describe the instruction. Of course, when these notes explain ",NA,NA
"an instruction the comment will often do the same. But that is a poor style, in general. ",NA,NA
"The following can be copied into the clipboard and pasted into your program editor, then ",NA,NA
saved to a file and run with SPIM. ,NA,NA
"## Program to assemble the instruction ori     $8,$9,0x004A ",NA,NA
##,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
"or    $25,$0,$0        # clear $25 ",NA,NA
"ori   $11,$0,0xD       # opcode ",NA,NA
"ori   $12,$0,0x9       # operand $s ",NA,NA
"ori   $13,$0,0x8       # dest. $d ",NA,NA
"ori   $14,$0,0x004A    # immediate operand",NA,NA
"sll   $11,$11,26       # shift opcode into position ",NA,NA
"or    $25,$25,$11      # or it into the instruction",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_21.html (1 of 2) [8/8/2545 13:37:39],NA
"sll   $12,$12,21       # shift operand $s into position ",NA,NA
"or    $25,$25,$12      # or it into the instruction",NA,NA
"sll   $13,$13,16       # shift dest $d into position ",NA,NA
"or    $25,$25,$13      # or it into the instruction",NA,NA
"or    $25,$25,$14      # or const into the instruction",NA,NA
## end of file,NA,NA
QUESTION 21:,NA,NA
Would it be possible to ,NA,NA
dis-assemble,NA,NA
 the instruction in $25? ,NA,NA
Would it be possible to ,NA,NA
dis-assemble,NA,NA
 the instruction in $25? ,NA,NA
A good answer might be: ,NA,NA
Sure. Bit logic operations can take appart the various fields and put them in different ,NA,NA
registers. ,NA,NA
A Run of the Program,NA,NA
Disassembly sounds like a really great programming assignment. But now let's run the ,NA,NA
assembler program: ,NA,NA
"The machine instruction in register $25 is correct, as expected. It would be nice to save the ",NA,NA
"instruction to memory at this point, but you don't know how to do this yet. ",NA,NA
QUESTION 22:,NA,NA
Could this program be written using fewer registers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/ass12_22.html [8/8/2545 13:38:01],NA
Could this program be written using fewer registers? ,NA,NA
A good answer might be: ,NA,NA
Yes. You only need two. Sounds like another programming exercise. ,NA,NA
End of Chapter,NA,NA
You have reached the end of this chapter. You may wish to shift into review mode. Click on ,NA,NA
"a blue subject that interests you to go to where it was discussed. To get back here, click on ",NA,NA
"the ""back arrow"" button of your browser. ",G,NA
Logical ,NA,NA
shift left.,G,NA
No-operation instruction,NA,NA
 as a logical left shift. ,G,NA
Logical ,NA,NA
shift right.,G,NA
or ,NA,NA
register-to-register instruction ,G,NA
and,NA,NA
 register-to-register instruction ,G,NA
xor,NA,NA
 register-to-register instruction ,G,NA
nor,NA,NA
 register-to-registerinstruction ,G,NA
not ,NA,NA
operation ,G,NA
move,NA,NA
 operation ,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,NA,NA
CHAPTER 13 — Add and Subtract ,NA,NA
Instructions,NA,NA
This chapter discusses the MIPS instructions for performing 32-bit integer addition and ,NA,NA
subtraction. Some topics of integer representation with bit patterns are reviewed. ,NA,NA
Chapter Topics:,G,NA
Overflow in unsigned binary and two's complement (review). ,G,NA
The ,NA,NA
add,NA,NA
 and ,NA,NA
addu,NA,NA
 instructions. ,G,NA
Sign extention ,G,NA
The ,NA,NA
addi,NA,NA
 and ,NA,NA
addiu,NA,NA
 instructions.,G,NA
The ,NA,NA
sub,NA,NA
 and ,NA,NA
subu,NA,NA
 instructions.,G,NA
Using ,NA,NA
addi,NA,NA
 to load a register with a negative integer.,NA,NA
QUESTION 1:,NA,NA
Say that a processor has a full set of bit manipulation instructions. Can it do ,NA,NA
arithmetic with these instructions? ,NA,NA
A good answer might be: ,NA,NA
Yes. (And it can do floating point arithmetic as well). ,NA,NA
Arithmetic as Bit Manipulation,NA,NA
"Integers are represented with bit patterns, so integer operations are bit manipulation ",NA,NA
"operations. Some very small, very fast processors provide no data manipulation instructions ",NA,NA
other than bit pattern manipulation. Adding two integers is done by implementing the Binary ,NA,NA
Addition Algorithm (see chapter 8) with these bit instructions. ,NA,NA
"Luckily, MIPS has instructions that perform integer arithmetic. The normal size of an integer ",NA,NA
is 32 bits (the same as the size of a register). Longer or shorter integer artihmetic is done ,NA,NA
using bit manipulation instructions in combination with 32-bit arithmetic instructions. ,NA,NA
QUESTION 2:,NA,NA
The MIPS ,NA,NA
addu,NA,NA
 instruction performs the Binary Addition Algorithm on two 32-,NA,NA
bit patterns. What integer representation method can be used with it? ,G,NA
Unsigned Binary?,G,NA
Two's Complement? ,G,NA
Both?,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_2.html [7/8/2545 18:37:14],NA
A good answer might be: ,G,NA
Both,NA,NA
Binary Addition Algorithm,NA,NA
The Binary Addition Algorithm works for both methods of integer representation. The same ,NA,NA
MIPS instruction (,NA,NA
addu,NA,NA
") is used for both. However, the overflow condition is different for ",NA,NA
each representation. ,NA,NA
Binary Addition Algorithm: detecting overflow,NA,NA
Unsigned Binary,NA,NA
The result is correct if ,NA,NA
the carry out ,NA,NA
of the high order column is zero. ,NA,NA
Two's Complement,NA,NA
The result is correct if ,NA,NA
the carry into ,NA,NA
the high order column is the same ,NA,NA
as ,NA,NA
the carry out of,NA,NA
 the high order ,NA,NA
column. The carry bits can both be ,NA,NA
zero or both be one. ,NA,NA
QUESTION 3:,NA,NA
Use the Binary Addition Algorithm on these 8-bit patterns: ,"1010 1011 
 0101 
 0101------
 ---",NA
Does overflow happen for: ,G,NA
Unsigned Binary?,G,NA
Two's Complement?,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_3.html [7/8/2545 18:37:21],NA
A good answer might be:,"11111 111 
 1010 1011 
 0101 0101 -
 --------
  
  0000 0000",NA
Does overflow happen for: ,G,NA
Unsigned Binary?   ,NA,NA
Overflow,NA,NA
 -- The carry out is one.,G,NA
Two's Complement?  ,NA,NA
In Range,NA,NA
 -- The carry in is the same as the carry ,NA,NA
out.,NA,NA
The ,NA,NA
addu,NA,NA
 Instruction,NA,NA
The ,NA,NA
addu,NA,NA
 instruction performs the Binary Addition Algorithm on the contents of two 32-bit ,NA,NA
registers and places the result in the destination register. The destination register can be the ,NA,NA
same as one of the source registers. The ,NA,NA
addu,NA,NA
 instruction mechanically grinds through the ,NA,NA
"Binary Addition Algorithm, producting a 32-bit result from two 32-bit operands. Overflow is ",NA,NA
"ignored (that is what the ""u"" at then end of the mnemonic means). ",NA,NA
"addu  d,s,t        # $d <-- s + t.  no overflow trap",NA,NA
"There is another instruction, ",NA,NA
add,NA,NA
", which causes a ",NA,NA
trap,NA,NA
 when two's complement overflow is ,NA,NA
"detected. Other than that, it is the same as ",NA,NA
addu,NA,NA
. A ,NA,NA
trap,NA,NA
 is an interruption in the normal ,NA,NA
machine cycle. Typically on a computer system a trap results in sending control back to the ,NA,NA
operating system. ,NA,NA
"add   d,s,t        # $d <-- s + t.  with overflow trap",NA,NA
Most assembly programmers deal with overflow by making sure that the operands won't ,NA,NA
cause it. Usually the ,NA,NA
addu,NA,NA
 instruction is used. Until you know how to handle a trap that is the ,NA,NA
approach we will take. ,NA,NA
QUESTION 4:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_4.html (1 of 2) [7/8/2545 18:37:30],NA
What is the range of integers that can be rep,d,NA
 with 32-bit two's complement? -,NA,NA
2,----,NA
 to +2,----,NA
" - 1. (Pick an exponent for each ""2""). ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_4.html (2 of 2) [7/8/2545 18:37:30],NA
A good answer might be: ,NA,NA
What is the range of integers that can be rep,d,NA
 with 32-bit two's complement? -2,31,NA
 to ,NA,NA
+2,31,NA
 - 1. ,NA,NA
(There are 2,32,NA
" bit patterns. Half of them are for negative integers, and the remaining are ",NA,NA
for the positive integers and zero). ,NA,NA
Example Program,NA,NA
Here is the previous addition problem extended to 32 bits. ,NA,NA
carry  --> 0000 0000 0000 0000 0000 0001 1111 111,NA,NA
 0000 0000 0000 0000 0000 0000 1010 1011         000000AB ,NA,NA
0000 0000 0000 0000 0000 0000 0101 0101         00000055 --,NA,NA
-------------------------------------         --------,NA,NA
 0000 0000 0000 0000 0000 0001 0000 0000         00000100,NA,NA
What was unsigned overflow with 8-bit unsigned arithmetic is within range for 32-bit ,NA,NA
arithmetic (both unsigned and two's comp.) ,NA,NA
## AddSome.asm ,NA,NA
## ,NA,NA
## Program to demonstrate addition,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8, $0, 0xAB       # put 0x000000AB into $8 ",NA,NA
"ori      $9, $0, 0x55       # put 0x00000055 into $9 ",NA,NA
"addu     $10,$9, $8         # $10 <-- sum",NA,NA
## End of file,NA,NA
QUESTION 5:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_5.html (1 of 2) [7/8/2545 18:37:41],NA
Are registers $9 and $8 changed by the ,NA,NA
addu,NA,NA
 instruction in this program? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_5.html (2 of 2) [7/8/2545 18:37:41],NA
A good answer might be: ,NA,NA
"No. Operand registers are not changed, unless one is also the destination register. ",NA,NA
Run of the Program,NA,NA
Here is a run of the program. The results are as expected. Notice that the decimal interpretation of the ,NA,NA
bit patterns is listed in one version of the source code. ,NA,NA
"To express integers in decimal notation omit the leading ""0x"". ","ori      $8, $0, 171       # put 171 into $8
  
  ori      $9, $0,  85       # put  85 into $9
  
  addu     $10,$9,  $8       # $10 <-- sum",NA
"Of course, the same bit patterns are loaded into the registers. The assembler accepts both notations ",NA,NA
for integers. ,NA,NA
QUESTION 6:,NA,NA
(Review:) Can ,NA,NA
"ori $d,$0,const",NA,NA
 be used with a negative integer for ,NA,NA
const,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_6.html [7/8/2545 18:38:03],NA
Can ,NA,NA
"ori $d,$0,const",NA,NA
 be used with a negative integer for ,NA,NA
const,NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
const,NA,NA
 is a 16-bit immediate operand that is zero-extended to a 32-bit integer when it ,NA,NA
is copied to $d. So it can't be negative. ,NA,NA
Negating a Two's Comp. Integer,NA,NA
"There will be much better ways to do this coming up, but for now say that the problem is to ",NA,NA
add +146 with -82. Loading a register with +146 is easy. But how can we load the -82? ,NA,NA
Recall that a two's comp. integer is made negative by reflecting the bits then adding one. ,NA,NA
QUESTION 7:,NA,NA
Say that register $8 has been loaded with +82: ,NA,NA
"ori $8,$0,82",NA,NA
 What ,NA,NA
instructions (that have been discussed so far in these notes) can do the ,NA,NA
following: ,G,NA
Reflect the bits in $8 ,G,NA
Add one to $8,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_7.html [7/8/2545 18:38:07],NA
A good answer might be:,G,NA
Reflect the bits in $8: ,NA,NA
" nor $8,$8,$0 ",G,NA
Add one to $8: ,NA,NA
" ori $9,$0,1 ",NA,NA
" addu $8,$8,$9",NA,NA
Example Program,NA,NA
Here is a program that does that. There are much better ways to load a register with a ,NA,NA
"negative integer. However, this is a nice example of bit manipulation. ",NA,NA
## handMadeNeg.asm ,NA,NA
## ,NA,NA
## Program to demonstrate two's complement negative ,NA,NA
##,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $7, $0, 146        # put +146 into $7 ",NA,NA
"ori      $8, $0,  82        # put 82 into $8 nor      ",NA,NA
"$8, $8,  $0        # reflect",NA,NA
" ori      $9, $0,   1        # ",NA,NA
" addu     $8, $8,  $9        # add 1: $8 = -82 ",NA,NA
"addu    $10, $7,  $8        # (+146) + (-82)",NA,NA
## End of file,NA,NA
QUESTION 8:,NA,NA
146-82 = ____ ?       in hex = _____ ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_8.html [7/8/2545 18:38:26],NA
A good answer might be: ,NA,NA
146-82 = 64       in hex = 0x40 ,NA,NA
Sign Extension,NA,NA
A run of the ,NA,NA
program produces ,NA,NA
one was first loaded into another register. It would be nice if there were ,NA,NA
"an ""add one"" instruction. Many processors have such an instruction. ",NA,NA
"MIPS has an ""add immediate"" instruction, ",NA,NA
"addiu d,s,const",NA,NA
. ,NA,NA
The immediate operand of this instruction is 16 bits (as are all MIPS ,NA,NA
"immediate operands). However, when extended to a 32-bit operand by ",NA,NA
the ALU it is ,NA,NA
sign extended,NA,NA
: The value of the left-most bit of the ,NA,NA
immediate operand (bit 15) is copied to all bits to the left (into the high-,NA,NA
order bits). So if the 16-bit immediate operand is a 16-bit two's ,NA,NA
result. ,NA,NA
QUESTION 9:,NA,NA
Here is a 16-bit two's complement negative one: ,NA,NA
FF FF  = 1111 1111 1111 1111,NA,NA
Sign-extend it to 32 bits: ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_9.html (1 of 2) [7/8/2545 18:38:43],NA
__ __ __ __  =  ???? ???? ???? ???? ???? ???? ???? ????,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_9.html (2 of 2) [7/8/2545 18:38:43],NA
A good answer might be: ,NA,NA
A 16-bit two's complement negative one: ,NA,NA
FF FF  = 1111 1111 1111 1111 ,NA,NA
Sign-extended: ,NA,NA
FF FF FF FF  =  1111 1111 1111 1111 1111 1111 1111 1111 ,NA,NA
The sign-extended version is a 32-bit negative one. ,NA,NA
The Fond ,NA,NA
addiu,NA,NA
 Instruction,NA,NA
The MIPS ,NA,NA
addiu,NA,NA
" instruction includes a 16-bit immediate operand. When the ALU uses it, the ",NA,NA
immediate operand is sign-extended to 32 bits. If two's comp. overflow occurs it is ignored. ,NA,NA
"addiu   d,s,const        # $d <-- s + const. ",NA,NA
 # Const is 16-bit two's comp. sign-extended to 32 bits ,NA,NA
# when the addition is done. No overflow trap.,NA,NA
There is also an add immediate instruction that does trap overflow. We won't use it: ,NA,NA
"addi    d,s,const        # $d <-- s + const. ",NA,NA
 # Const is 16-bit two's comp. sign-extended to 32 bits ,NA,NA
# when the addition is done. Overflow trap.,NA,NA
QUESTION 10:,NA,NA
"Here is the previous program, that added +146 with -82. Rewrite it using the ",NA,NA
addiu,NA,NA
 instruction. Put the result in $10. ,NA,NA
" ori      $7, $0, 146        # put +146 into $7",NA,NA
" ori      $8, $0,  82        # put 82 into $8",NA,NA
" nor      $8, $8,  $0        # reflect",NA,NA
" ori      $9, $9,   1        # ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_10.html (1 of 2) [7/8/2545 18:38:45],NA
" addu     $8, $8,  $9        # add 1: $8 = -82",NA,NA
" addu    $10, $7,  $8        # (+146) + (-82)",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_10.html (2 of 2) [7/8/2545 18:38:45],NA
A good answer might be:,NA,NA
" ori      $7, $0, 146        # put +146 into $7",NA,NA
" addiu    $10,$7,-82         # add -82 ",NA,NA
The program is much shorter. ,NA,NA
The ,NA,NA
subu,NA,NA
 Instruction,NA,NA
MIPS has two integer subtraction instructions: ,NA,NA
"subu   d,s,t        # $d <-- s - t . No overflow trap. # ",NA,NA
This is equivalent to $d <-- s + (-t) # ,NA,NA
where (-t) is reflect-add-one of t.,NA,NA
"sub    d,s,t        # $d <-- s - t . Trap overflow! # ",NA,NA
This is equivalent to $d <-- s + (-t) # ,NA,NA
where (-t) is reflect-add-one of t.,NA,NA
QUESTION 11:,NA,NA
When ,NA,NA
"ori $d,$0,const",NA,NA
" is used to load $d, ",NA,NA
const,NA,NA
 is 16-bit unsigned binary. Say ,NA,NA
that you want to load $8 with a negative 86. Will the following work? ,NA,NA
"addiu    $8,$0,-86  # $8 <-- -86 ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_11.html [7/8/2545 18:38:57],NA
"addiu    $8,$0,-86 ",NA,NA
A good answer might be: ,NA,NA
Yes. The immediate operand -86 is ,NA,NA
sign,NA,NA
-extended to 32 bits then added to a 32-bit zero. ,NA,NA
The sum (-86) is loaded into $8. ,NA,NA
The Absent Subtract Immediate,NA,NA
You would expect that since there are ,NA,NA
"add, addu, addi, addiu",NA,NA
 and since there are ,NA,NA
"sub, subu ",NA,NA
that there would be subtract immediate instructions. But there are not. The add immediate ,NA,NA
"instruction is used. To subtract 201 from register $10 using an immediate operand, do this: ",NA,NA
"addiu    $8,$10,-201    #  $8 <-- $10 - 201 ",NA,NA
Say that we want to compute ,NA,NA
5 × x - 74,NA,NA
 where the value ,NA,NA
x,NA,NA
 is in register $8. MIPS has an ,NA,NA
"integer multiply instruction, but let us say that we don't want to use it. How can ",NA,NA
5 × x,NA,NA
 be ,NA,NA
done using the instructions you have seen so far? ,NA,NA
QUESTION 12:,NA,NA
How could you compute ,NA,NA
4 × $8 + $8 ,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_12.html [7/8/2545 18:39:05],NA
How could you compute ,NA,NA
4× $8 + $8 ,NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
"Multiply $8 by four by shifting left two positions, then add it the original $8 ",NA,NA
Example Program,NA,NA
"Here is the program. Unfortunately, there are a few blanks. This would be a good time to ",NA,NA
use that scratch pad and pencil next to your keyboard. ,NA,NA
## slowMult.asm ,NA,NA
## ,NA,NA
## Program to calculate 5 × x - 74 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
##  $8   x ,NA,NA
##  $9   result,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8, $0, 12           # put x into $8",NA,NA
" sll      $___, $___,  ___     # $___ <-- 4x addu     ",NA,NA
"$___, $___, $___     # $___ = 5x addiu    ",NA,NA
"$___, $___,-74       # $___ = 5x - 74",NA,NA
## End of file,NA,NA
QUESTION 13:,NA,NA
Fill in the blanks to finish the program. The final result should be in register ,NA,NA
$9. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_13.html [7/8/2545 18:39:06],NA
A good answer might be: ,NA,NA
The complete program is below. ,NA,NA
Filled Blanks,NA,NA
## slowMult.asm ,NA,NA
## ,NA,NA
## Program to calculate 5×x - 74 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
##  $8   x ,NA,NA
##  $9   result,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8, $0, 12        # put x into $8 ",NA,NA
"sll      $9, $8,  2        # $9 <-- 4x",NA,NA
" addu     $9, $9, $8        # $9 = 5x",NA,NA
" addiu    $9, $9,-74        # $9 = 5x - 74",NA,NA
## End of file,NA,NA
QUESTION 14:,NA,NA
Could the program be written to use just one register? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_14.html [7/8/2545 18:39:12],NA
A good answer might be: ,NA,NA
"No, because the original value x is used several times and needs to be in a register. ",NA,NA
End of Chapter,NA,NA
(The program could be written with on register if you could use main memory to store ,NA,NA
x,NA,NA
. But ,NA,NA
"these notes have not told you how, yet). ",NA,NA
You have reached the end of this chapter. Click on a blue subject that interests you to go to ,NA,NA
"where it was discussed. To get back here, click on the ""back arrow"" button of your browser. ",G,NA
Overflow,NA,NA
 in unsigned and two's comp. ,G,NA
The ,NA,NA
addu,NA,NA
 and add instructions. ,G,NA
Decimal constants,NA,NA
 in assembly language. ,G,NA
Sign extension,NA,NA
 of a two's comp. integer. ,G,NA
The ,NA,NA
addiu ,NA,NA
and addi instructions. ,G,NA
The ,NA,NA
subu,NA,NA
 and sub instructions ,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-13/ass13_15.html [7/8/2545 18:39:25],NA
CHAPTER 14 --- Integer Multiplication ,NA,NA
Instructions,NA,NA
This chapter discusses the MIPS instructions for performing 32-bit integer multiplication. ,NA,NA
Some topics of integer representation with bit patterns are reviewed. ,NA,NA
Chapter Topics:,G,NA
Integer multiplication and division. ,G,NA
The ,NA,NA
hi,NA,NA
 and ,NA,NA
lo,NA,NA
 registers.,G,NA
The ,NA,NA
mult,NA,NA
 and ,NA,NA
multu,NA,NA
 instructions.,G,NA
The ,NA,NA
div,NA,NA
 and ,NA,NA
divu,NA,NA
 instructions. ,G,NA
The ,NA,NA
mfhi,NA,NA
 and ,NA,NA
mflo,NA,NA
 instructions. ,G,NA
Arithmetic shift right.,G,NA
The ,NA,NA
sra,NA,NA
 Instruction.,NA,NA
QUESTION 1:,NA,NA
Multiply 99,10,NA
 times 99,10,NA
: _________. How many decimal places does each ,NA,NA
operand (99) take: ________. How many decimal places does the result ,NA,NA
take: ________. ,NA,NA
A good answer might be: ,NA,NA
Multiply 99,10,NA
 times 99,10,NA
: ,NA,NA
9801,NA,NA
. How many decimal places does each operand (99) take: ,NA,NA
2,NA,NA
. How many decimal places does the result take: ,NA,NA
2,NA,NA
. ,NA,NA
Twice the Number of Places,NA,NA
The product of two N-place decimal integers may need 2N places. This is also true for ,NA,NA
"numbers expressed in any base. In particular, the product of two integers expressed with N-",NA,NA
bit binary may need 2N bits for the product. Here two 8-bit unsigned integers are multiplied ,NA,NA
"(using the usual paper-and-pencil multiplication algorithm, but with binary arithmetic): ",NA,NA
 10110111        B7        183,10,NA
 10100010        A2        162,10,NA
 --------        --        ---,NA,NA
 00000000,NA,NA
 10110111.,NA,NA
 00000000..,NA,NA
 00000000...,NA,NA
 00000000....,NA,NA
 10110111.....,NA,NA
 00000000......,NA,NA
 10110111.......,NA,NA
 ---------------      ----      -----,NA,NA
 111001111001110      73CE      29646,10,NA
The two 8-bit operands result in a 15-bit product. ,NA,NA
QUESTION 2:,NA,NA
Is a 32-bit general register likely to hold the result of multiplying two other 32-,NA,NA
bit registers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_2.html [7/8/2545 18:40:09],NA
A good answer might be: ,NA,NA
"No. In general, 64 bits are needed. ",NA,NA
MIPS Multiply Unit,NA,NA
The multiply unit of MIPS contains two 32-bit registers: ,NA,NA
hi,NA,NA
 and ,NA,NA
lo,NA,NA
. These are not general ,NA,NA
"purpose registers. When two 32-bit operands are multiplied, ",NA,NA
hi,NA,NA
 and ,NA,NA
lo,NA,NA
 hold the 64 bits of the ,NA,NA
result. Bits 32 through 63 are in ,NA,NA
hi,NA,NA
 and bits 0 through 31 are in ,NA,NA
lo,NA,NA
. ,NA,NA
Here are the instructions that do this. The operands are contained in general-purpose ,NA,NA
registers. ,NA,NA
"mult    s,t        # hilo <-- $s * $t.  two's comp operands",NA,NA
"multu   s,t        # hilo <-- $s * $t.  unsigned operands",NA,NA
"Integer multiplication is slightly different for signed and unsigned operands, so there are two ",NA,NA
instructions. Integer multiply will never cause a trap. ,NA,NA
QUESTION 3:,NA,NA
Two small integers are multiplied. Where is the result? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_3.html [7/8/2545 18:40:15],NA
A good answer might be: ,NA,NA
If the result is small enough it will be contained in ,NA,NA
lo,NA,NA
", and ",NA,NA
hi,NA,NA
 will contain all zeros. ,NA,NA
The ,NA,NA
mfhi,NA,NA
 and ,NA,NA
mflo,NA,NA
 Instructions,NA,NA
We will mostly write programs that keep the result under 32 bits in length. There are two ,NA,NA
instructions that move the result of a multiply into a general purpose register: ,NA,NA
mfhi    d        #  d <-- hi.  Move From Hi,NA,NA
mflo    d        #  d <-- lo.  Move From Lo,NA,NA
Rule:,NA,NA
 Do no use a multiply or a divide instruction within two instructions after ,NA,NA
mflo,NA,NA
 or ,NA,NA
mfhi,NA,NA
. ,NA,NA
"The reason for this involves the way the MIPS pipeline works, and is a future topic. On the ",NA,NA
SPIM simulator this rule does not matter. ,NA,NA
QUESTION 4:,NA,NA
How small are the the operands of ,NA,NA
multu,NA,NA
 if the result fits in ,NA,NA
lo,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_4.html [7/8/2545 18:40:18],NA
How small are the the operands of ,NA,NA
multu,NA,NA
 if the result fits in ,NA,NA
lo,NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
"The operands must fit into 16 bits, or must be less than 2",16,NA
 - 1 = 64K - 1. ,NA,NA
Example Program,NA,NA
Let us write a program that evaluates the same formula as the previous example: ,NA,NA
5 × x - 74 ,NA,NA
where the value ,NA,NA
x,NA,NA
 is in register $8. Assume that ,NA,NA
x,NA,NA
 is two's complement. Here is the ,NA,NA
program: ,NA,NA
## newMult.asm ,NA,NA
## ,NA,NA
## Program to calculate 5 × x - 74 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
##  $8   x ,NA,NA
##  $9   result,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8,   $0, 12         # put x into $8",NA,NA
" ori      $___, $0,  5         # put 5 into $___ ",NA,NA
"mult     $___, $___           #  ___ <-- 5x",NA,NA
 mflo     $___                 # $___ = 5x,NA,NA
" addiu    $___, $___,-74       # $___ = 5x - 74",NA,NA
## End of file,NA,NA
QUESTION 5:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_5.html [7/8/2545 18:40:23],NA
A good answer might be: ,NA,NA
The answer is below. ,NA,NA
Completed Program,NA,NA
## newMult.asm ,NA,NA
## ,NA,NA
## Program to calculate 5 × x - 74 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
##  $8   x ,NA,NA
##  $9   result,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8, $0, 12       # put x into $8 ",NA,NA
"ori      $9, $0,  5       # put 5 into $9 ",NA,NA
"mult     $9, $8           # lo <-- 5x",NA,NA
 mflo     $9               # $9 = 5x,NA,NA
" addiu    $9, $9,-74       # $9 = 5x - 74",NA,NA
## End of file,NA,NA
QUESTION 6:,NA,NA
"What does the """,NA,NA
u,NA,NA
""" mean in each of the following instructions: ",G,NA
addu,NA,NA
 ____________________ ,G,NA
multu,NA,NA
____________________ ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_6.html [7/8/2545 18:40:30],NA
A good answer might be: ,G,NA
addu,NA,NA
Do not trap on overflow. ,G,NA
multu,NA,NA
Operands are unsigned.,NA,NA
A Run of the Program,NA,NA
The ,NA,NA
mult,NA,NA
 assumes two's complement operands. Here is a run of the program: ,NA,NA
The result is as expected. 5 × 12 - 74 = -14 = 0xFFFFFFF2. The result 5 × 12 = 60,ten,NA
 = ,NA,NA
0x3C remains in ,NA,NA
lo,NA,NA
. ,NA,NA
QUESTION 7:,NA,NA
Use integer division (in base ten) to calculate the quotient and remainder of: ,G,NA
99 / 2   = _______ R ______ ,G,NA
99 / 50 = _______ R ______ ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_7.html [7/8/2545 18:40:44],NA
A good answer might be: ,G,NA
99 / 2   = 48 R 1 ,G,NA
99 / 50 = 1 R 49 ,NA,NA
The ,NA,NA
div,NA,NA
 and the ,NA,NA
divu,NA,NA
 Instructions,NA,NA
"With N-place integer division there are two results, an N-place quotient and an N-place ",NA,NA
remainder. With 32-bit operands there will be (in general) two 32-bit results. MIPS uses the ,NA,NA
hi,NA,NA
 and ,NA,NA
lo,NA,NA
 registers for the results: ,NA,NA
"Here are the MIPS instructions for integer divide. The ""u"" means operands and results are in ",NA,NA
unsigned binary. ,NA,NA
"div    s,t        #  lo <-- s div t",NA,NA
 #  hi <-- s mod t,NA,NA
 #  two's complement,NA,NA
"divu   s,t        #  lo <-- s div t",NA,NA
 #  hi <-- s mod t,NA,NA
 #  unsigned,NA,NA
QUESTION 8:,NA,NA
(Review:) What instruction would be used to move the quotient into register ,NA,NA
$8? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_8.html [7/8/2545 18:40:48],NA
A good answer might be: ,NA,NA
mflo $8 ,NA,NA
The instructions ,NA,NA
mflo,NA,NA
 and ,NA,NA
mfhi,NA,NA
 are used to get the results of an integer divide. ,NA,NA
Example Program,NA,NA
For this example say that we wish to calculate ,NA,NA
(y + x) / (y - x),NA,NA
. The argument ,NA,NA
x,NA,NA
 is in $8; ,NA,NA
y,NA,NA
 is ,NA,NA
in $9. The quotient is to be placed in $10 and the remainder in $11. Assume two's ,NA,NA
"complement integers. Here is the program. Sadly, it has some holes: ",NA,NA
## divEg.asm ,NA,NA
## ,NA,NA
## Program to calculate (y + x) / (y - x) ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
##  $8   x ,NA,NA
##  $9   y ,NA,NA
##  $10  x/y ,NA,NA
##  $11  x%y,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ___      $8,   $0,  8         # put x into $8",NA,NA
" ___      $9,   $0, 36         # put y into $9",NA,NA
" addu     $10,  $__, $__       # $10  <-- (y+x) ",NA,NA
"subu     $11,  $__, $__       # $11  <-- (y-x) div      ",NA,NA
"$__,  $__            # hilo <-- (y+x)/(y-x) ____     ",NA,NA
$10                  # $10  <-- quotient ____     $11                  ,NA,NA
# $11  <-- remainder,NA,NA
## End of file,NA,NA
QUESTION 9:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_9.html (1 of 2) [7/8/2545 18:40:50],NA
Fill in the holes. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_9.html (2 of 2) [7/8/2545 18:40:50],NA
A good answer might be: ,NA,NA
See Below ,NA,NA
Filled Holes,NA,NA
Here is the complete program: ,NA,NA
## divEg.asm ,NA,NA
## ,NA,NA
## Program to calculate (y + x) / (y - x) ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
##  $8   x ,NA,NA
##  $9   y ,NA,NA
##  $10  x/y ,NA,NA
##  $11  x%y,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" ori      $8,   $0,  8         # put x into $8",NA,NA
" ori      $9,   $0, 36         # put y into $9",NA,NA
" addu     $10,  $9, $8         # $10  <-- (y+x) ",NA,NA
"subu     $11,  $9, $8         # $11  <-- (y-x) div      ",NA,NA
"$10,  $11            # hilo <-- (y+x)/(y-x) mflo     ",NA,NA
$10                  # $10  <-- quotient mfhi     $11                  ,NA,NA
# $11  <-- remainder,NA,NA
## End of file,NA,NA
QUESTION 10:,NA,NA
(36+8) / (36-8) = _____ R _____,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_10.html [7/8/2545 18:40:55],NA
A good answer might be: ,NA,NA
"(36+8) / (36-8) = 1 R 16, or 0x1 R 0x10",NA,NA
A Run of the Program,NA,NA
Here is an example run of the program: ,NA,NA
"As usual, a stunning success. ",NA,NA
QUESTION 11:,NA,NA
Here is the 16-bit two's complement rep,n,NA
 for -16. ,NA,NA
1111 1111 1111 0000,NA,NA
Perform a logical shift right by two positions. Is the resulting pattern the correct rep,n,NA
 for -,NA,NA
16/4? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_11.html [7/8/2545 18:40:59],NA
A good answer might be: ,1111 1111 1111 0000  ---> 0011 1111 1111 1100,NA
Is the resulting pattern the correct rep,n,NA
 for -16/4? ,NA,NA
No.,NA,NA
" The result represents a large positive number, ",NA,NA
not -4 ,NA,NA
Shift Right Arithmetic,NA,NA
The problem is that a shift right logical moves zeros into the high order bit. This is correct in some ,NA,NA
"situations, but not for dividing two's complement negative integers. An ",NA,NA
arithmetic,NA,NA
 right shift replicates ,NA,NA
the sign bit as needed to fill bit positions: ,NA,NA
QUESTION 12:,NA,NA
Is there a need for an ,NA,NA
arithmetic shift left,NA,NA
 instruction? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_12.html [7/8/2545 18:41:07],NA
Is there a need for an ,NA,NA
arithmetic shift left,NA,NA
 instruction? ,NA,NA
A good answer might be: ,NA,NA
"No. A logical shift left moves zeros into the low-order bit, which is correct for both signed ",NA,NA
and unsigned integers. ,NA,NA
The ,NA,NA
sra,NA,NA
 Instruction,NA,NA
Here is the MIPS instruction that performs an arithmetic shift right: ,NA,NA
"sra    d,s,shft   #  $d <-- s shifted right",NA,NA
 #  shft bit positions.,NA,NA
 #  0 =< shft < 31,NA,NA
Sometimes you need to divide by two. This instruction is faster and more convenient than ,NA,NA
the ,NA,NA
div,NA,NA
 instruction. ,NA,NA
QUESTION 13:,NA,NA
Does the ,NA,NA
sra,NA,NA
 instruction give the correct results for ,NA,NA
unsigned,NA,NA
 integers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_13.html [7/8/2545 18:41:10],NA
Does the ,NA,NA
sra,NA,NA
 instruction work correctly for ,NA,NA
unsigned,NA,NA
 integers? ,NA,NA
A good answer might be: ,NA,NA
"No. For unsigned integers the ""sign bit"" should not be replicated. ",NA,NA
End of Chapter,NA,NA
You have reached the end of this chapter. Click on a blue subject that has your undivided ,NA,NA
"attention to go to where it was discussed. To get back here, click on the ""back arrow"" button ",NA,NA
of your browser. ,G,NA
The number of places resulting from an ,NA,NA
integer multiplication. ,G,NA
The number of places resulting from an ,NA,NA
integer division. ,G,NA
The ,NA,NA
hi ,NA,NA
and lo,NA,NA
 registers. ,G,NA
The ,NA,NA
mult and multu,NA,NA
 instructions. ,G,NA
The ,NA,NA
mfhi and mflo,NA,NA
 instructions. ,G,NA
The ,NA,NA
div and divu,NA,NA
 instructions. ,G,NA
Arithmetic,NA,NA
 shift right. ,G,NA
The ,NA,NA
sra,NA,NA
 instruction. ,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-14/ass14_14.html [7/8/2545 18:41:12],NA
CHAPTER 15 — Memory Access ,NA,NA
Instructions,NA,NA
"This chapter discusses how to get data from memory into registers, and how to write data to ",NA,NA
memory from registers. Addresses are calculated at run time by adding an ,NA,NA
offset,NA,NA
 (part of the ,NA,NA
machine instruction) to an address held in a ,NA,NA
base register,NA,NA
. ,NA,NA
Chapter Topics:,G,NA
Load and store.,G,NA
Data alignment.,G,NA
Byte order (little endian and big endian). ,G,NA
The ,NA,NA
lw,NA,NA
and,NA,NA
sw,NA,NA
instructions.,G,NA
The load delay slot.,G,NA
Base registers and address calculation.,G,NA
The ,NA,NA
lui,NA,NA
 instruction. ,G,NA
Symbolic addresses.,NA,NA
QUESTION 1:,NA,NA
(Review:) What is the name of the operation that copies data from main ,NA,NA
memory into a register? ,NA,NA
A good answer might be: ,NA,NA
A register is ,NA,NA
loaded,NA,NA
 from memory. ,NA,NA
Load and Store,NA,NA
All arithmetic and logic operations on MIPS use data in registers. To operate on data in ,NA,NA
"main memory, the data must first be put into a register. A ",NA,NA
load,NA,NA
 operation copies data from ,NA,NA
main memory into a register. A ,NA,NA
store,NA,NA
 operation copies data from a register into main ,NA,NA
memory . ,NA,NA
When a word (4-bytes) is loaded or stored the memory address must be a multiple of four. ,NA,NA
This is called an alignment restriction. Addresses that are a multiple of four are called ,NA,NA
word ,NA,NA
aligned,NA,NA
. This restriction makes the hardware simpler and faster. ,NA,NA
The MIPS instruction that load a word into a register is the ,NA,NA
lw,NA,NA
 instruction. The store word ,NA,NA
instruction is ,NA,NA
sw,NA,NA
. Each must specify a register and a memory address (details in a few ,NA,NA
pages). ,NA,NA
QUESTION 2:,NA,NA
Which of the following addresses are word aligned? ,G,NA
0x000AE430 ,G,NA
0x00014432 ,G,NA
0x000B0737 ,G,NA
0x0E0D8844,NA,NA
Hint: how can you multiply by four in binary? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_2.html [7/8/2545 18:41:19],NA
A good answer might be:,NA,NA
How can you multiply by four in binary? ,NA,NA
By shifting left 2 positions.,NA,NA
 So if the rightmost ,NA,NA
"two (or more) bit positions are zero, the integer is a multiple of four. ",G,NA
0x000AE430   ,NA,NA
Yes. ,G,NA
0x00014432   ,NA,NA
No. ,G,NA
0x000B0737   ,NA,NA
No. ,G,NA
0x0E0D8844   ,NA,NA
Yes.,NA,NA
Big Endian and Little Endian,NA,NA
The ,NA,NA
lowest address,NA,NA
" is used for the address of a block of contiguous bytes. For example, ",NA,NA
the address of a four-byte word is the lowest address of the four bytes. ,NA,NA
Another issue is how a 32-bit pattern is held in a word of memory. There are 32 bits in the ,NA,NA
"word and 32 bits in the pattern, but a choice has to be made about which byte of memory ",NA,NA
gets what part of the pattern. There are two ways that computers can do this: ,NA,NA
Big Endian Byte Order:,NA,NA
" The most significant byte (the ""big end"") of the data is ",NA,NA
placed at the lowest addressed byte. The rest of the word is placed in order in ,NA,NA
the next three bytes in address space. ,NA,NA
Little Endian Byte Order:,NA,NA
" The least significant byte (the ""little end"") of the ",NA,NA
data is placed at the lowest addressed byte. The rest of the word is placed in ,NA,NA
order in the next three bytes in address space. ,NA,NA
"In these definitions, the 32-bit word is regarded as a 32-bit unsigned integer. The ""most ",NA,NA
"significant"" byte is the one for the largest powers of two: 2",31,NA
", ..., 2",24,NA
". The ""least significant"" ",NA,NA
byte is the one for the smallest powers of two: 2,7,NA
", ..., 2",0,NA
. ,NA,NA
"For example, say that the 32-bit word 0x12345678 is at address 0x00400000. The most ",NA,NA
significant byte is 0x12; the least significant is 0x68. Here are the two byte orders: ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_3.html (1 of 2) [7/8/2545 18:41:25],NA
Within a ,NA,NA
byte,NA,NA
 the order of the bits is always the same (no matter how the bytes themselves ,NA,NA
are arranged). ,NA,NA
QUESTION 3:,NA,NA
Write the bit pattern that is contained in the byte (above) that contains 0x12. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_3.html (2 of 2) [7/8/2545 18:41:25],NA
Write the bit pattern that is contained in the byte (above) that contains 0x12. ,NA,NA
A good answer might be: ,NA,NA
0001 0010 ,NA,NA
"Within a byte, position 7 is the most signficant bit, usually printed as the left-most bit. So ",NA,NA
a byte that contains 0x12 looks the same for both byte orderings. ,NA,NA
Byte Order of MIPS and SPIM,NA,NA
The MIPS processor chip can be set up in hardware to use either byte ordering. A computer ,NA,NA
system designer makes whatever choice best fits the rest of the computer system. SPIM ,NA,NA
simulator uses the byte ordering of the computer it is running on. ,G,NA
Intel 80x86: little-endian. ,G,NA
Macintosh: big-endian.,NA,NA
The examples in these notes were done on a Windows/Intel computer. If you are using a ,NA,NA
Macintosh there will be occasional differences. ,NA,NA
QUESTION 4:,NA,NA
"In programs that deal with data in word-sized chunks or bigger, is the byte ",NA,NA
ordering visible? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_4.html [7/8/2545 18:41:54],NA
"In programs that deal with data in word-sized chunks or bigger, is the byte ordering visible? ",NA,NA
A good answer might be:,NA,NA
No. If a word is loaded from memory the electronics puts the bytes into the register in ,NA,NA
the correct order. If a word is stored to memory the bytes are written to memory in the ,NA,NA
"correct order. It makes no difference which order is the ""correct"" order. ",NA,NA
MIPS Addresses,NA,NA
The MIPS instruction that load a word into a register is the ,NA,NA
lw,NA,NA
 instruction. The store word ,NA,NA
instruction is ,NA,NA
sw,NA,NA
. Each must specify a register and a memory address. A MIPS instruction is ,NA,NA
32 bits (always). A MIPS memory address is 32 bits (always). How can a load or store ,NA,NA
instruction refer to an address that is the same size as itself? ,NA,NA
Any instruction that refers to memory uses a ,NA,NA
base register,NA,NA
. The base register contains a 32-,NA,NA
bit address. The instruction contains an ,NA,NA
offset,NA,NA
", a 16-bit signed integer. The sum of the ",NA,NA
address in the base register with the (sign-extended) offset forms the memory address. ,NA,NA
Here is the load word instruction: ,NA,NA
"lw   t,off(b)       # $t <-- Word from memory address b+off # ",NA,NA
b is a register. off is 16-bit two's complement.,NA,NA
QUESTION 5:,NA,NA
Load the word at address 0x00400060 into register $8. Register $10 ,NA,NA
contains 0x00400000. Write the ,NA,NA
lw,NA,NA
 instruction in assembly language: ,NA,NA
"lw $8, _____(   )",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_5.html [7/8/2545 18:41:57],NA
A good answer might be:,NA,NA
0x00400060 --- address of data ,NA,NA
0x00400000 --- address in $10 ,NA,NA
$8         --- destination register,NA,NA
The instruction is: ,NA,NA
"lw $8,0x60($10)",NA,NA
Machine Instruction for Load Word,NA,NA
Here is the machine code version of the instruction. It specifies the ,NA,NA
base register,NA,NA
", the ",NA,NA
destination register,NA,NA
", and the ",NA,NA
offset,NA,NA
. It does not directly contain the memory address. ,NA,NA
100011,NA,NA
  01010,NA,NA
 01000,NA,NA
 0000 0000 0110 0000,NA,NA
 -- fields of the instruction ,NA,NA
opcode  base  dest        offset        -- meaning of the fields ,NA,NA
lw      $10   $8     0    0    6    0,NA,NA
Here is how this instruction is executed: ,NA,NA
1.  The 32-bit address in $10 is fetched.   ,NA,NA
0x00400000 ,NA,NA
2.  The offset is sign-extended to 32 bits.   ,NA,NA
0x00000060 ,NA,NA
3.  The memory address is the 32-bit sum of the above.   ,NA,NA
0x00400060 ,NA,NA
4.  The word at that address is fetched from memory.   ,NA,NA
get 4 bytes starting at 0x00400060 ,NA,NA
5.  After a one machine cycle delay the word is loaded into $8.   ,NA,NA
$8 ,NA,NA
<--,NA,NA
The 4 bytes. ,NA,NA
There is a one machine cycle delay before the data from memory is available. This is the ,NA,NA
load delay slot,NA,NA
. But the processor keeps executing instructions. The instruction after a ,NA,NA
lw ,NA,NA
instruction should not use the data that is being loaded. Sometimes the instruction after the ,NA,NA
lw,NA,NA
 is a no-operation instruction. ,NA,NA
QUESTION 6:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_6.html (1 of 2) [7/8/2545 18:42:35],NA
Conditions are as follows and memory is as at ,NA,NA
right. Write the instruction that puts the value ,NA,NA
0x00000004 into register $12. ,G,NA
Register $12 contains ,NA,NA
0xFFFFFFFF ,G,NA
Register $13 contains ,NA,NA
0x00040000,NA,NA
"lw $_____ , _____($      )",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_6.html (2 of 2) [7/8/2545 18:42:35],NA
A good answer might be: ,NA,NA
"lw $12, 0x10($13) ",NA,NA
The original contents of $12 are irrelevant; they are replaced with the 32 bits from ,NA,NA
memory (memory remains unchanged). ,NA,NA
Store Word Instruction,NA,NA
"The store word instruction, ",NA,NA
sw,NA,NA
" contains the same specifications as the load word instruction, ",NA,NA
but now the word of data is copied to memory. The register is not changed. ,NA,NA
"sw   t,off(b)       # Word at memory address (b+off) <-- $t ",NA,NA
 # b is a register. off is 16-bit two's complement.,NA,NA
As with the ,NA,NA
lw,NA,NA
" instruction, the memory address must be word aligned (a multiple of four). ",NA,NA
QUESTION 7:,NA,NA
Conditions are as follows and memory is as at ,NA,NA
right. Write the instruction that puts the word ,NA,NA
$0xFFFFFFFF into register memory location ,NA,NA
0x0004000C. ,G,NA
Register $12 contains ,NA,NA
0xFFFFFFFF ,G,NA
Register $13 contains ,NA,NA
0x00040014,NA,NA
"sw $_____ , _____($      )",NA,NA
Hint: it is OK to specify the 16-bit offset as a ,NA,NA
signed decimal integer. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_7.html [7/8/2545 18:42:37],NA
A good answer might be: ,NA,NA
"sw $12 , 0xFFF8($13)",NA,NA
    or    ,NA,NA
"sw $12 , -8($13)",NA,NA
Setting up the Base Register,NA,NA
The first instruction of the answer expresses minus eight ,NA,NA
assembler translates both assembler instructions into exactly ,NA,NA
the same machine instruction. ,NA,NA
"With the assistance of a 32-bit base register, a 32-bit ",NA,NA
lw,NA,NA
 or ,NA,NA
sw,NA,NA
 instruction can reference ,NA,NA
memory But how does the base address get into the base register? This is where the ,NA,NA
lui,NA,NA
using 16-bit two's complement. This is the bit pattern that is ,NA,NA
actually contained in the machine instruction. This is ,NA,NA
awkward to read and to calculate. The second instruction ,NA,NA
uses signed decimal notation to specify minus eight. The ,NA,NA
(,NA,NA
l,NA,NA
oad ,NA,NA
u,NA,NA
pper ,NA,NA
i,NA,NA
mmediate) instruction is useful. It copies the 16-,NA,NA
bit immediate operand of the machine instruction to the ,NA,NA
upper two bytes,NA,NA
 of the designated ,NA,NA
register. ,NA,NA
"lui  t,const  # upper two bytes of $t <-- two byte const ",NA,NA
 # lower two bytes of $t <-- 0x0000,NA,NA
"Sometimes this is all that you need. For example, say that memory is as in the picture, and ",NA,NA
that you want to load the word at 0x00040010 into $12. The ,NA,NA
lui,NA,NA
 instruction can set up the ,NA,NA
base register: ,NA,NA
"lui $13, 0x________ ",NA,NA
"lw  $12, 10($13)",NA,NA
QUESTION 8:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_8.html (1 of 2) [7/8/2545 18:42:42],NA
Complete the ,NA,NA
lui,NA,NA
 instruction. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_8.html (2 of 2) [7/8/2545 18:42:42],NA
A good answer might be: ,NA,NA
"lui $13, 0x0004 ",NA,NA
"lw  $12, 10($13) ",NA,NA
After the ,NA,NA
lui,NA,NA
 instruction $13 contains 0x,NA,NA
0004,NA,NA
0000 ,NA,NA
Filling in the bottom Half,NA,NA
By using the ,NA,NA
lui,NA,NA
 instruction the base register can be loaded ,NA,NA
with multiples of 0x00010000. But often you want a more ,NA,NA
specific address in the base register. Use the ,NA,NA
ori,NA,NA
 instruction ,NA,NA
to fill the bottom 16 bits. ,NA,NA
"Also, ",NA,NA
addiu,NA,NA
 can be used to do the same thing. Be careful ,NA,NA
NOT to use ,NA,NA
addi,NA,NA
", because it does sign extension of its 16-bit ",NA,NA
immediate operand. This can cause problems. ,NA,NA
Say that memory is as at right. The ,NA,NA
lw,NA,NA
 instruction (below) will ,NA,NA
load the word at 0x0060500C into $12. ,NA,NA
"lui $13, 0x________ ",NA,NA
"ori $13, 0x________ ",NA,NA
"lw  $12, 0xC($13)",NA,NA
QUESTION 9:,NA,NA
Complete the instruction sequence. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_9.html [7/8/2545 18:42:51],NA
A good answer might be:,NA,NA
"lui $13, 0x0060 ",NA,NA
"ori $13, 0x5000 ",NA,NA
"lw  $12, 0xC($13)",NA,NA
Alternate Sequence,NA,NA
Other sequences of instructions also will work: Because the ,NA,NA
"""upper half"" of an address is 16 bits and the offset of the ",NA,NA
lw ,NA,NA
"instruction is 16 bits, the two in combination can address any ",NA,NA
byte of memory. ,NA,NA
The problem was to load $12 with the word at address ,NA,NA
0x0060500C. Here is another way to do it: Split the address ,NA,NA
into halves: 0x0060 and 0x500C. Load the top half into $13 ,NA,NA
and use the bottom half as the offset. ,NA,NA
"lui $13, 0x0060 ",NA,NA
"lw  $12, 0x500C($13)",NA,NA
An array of ,NA,NA
int,NA,NA
 in C is implemented as a sequence of words in successive word-aligned ,NA,NA
"memory locations. For example, the diagram shows a possible run-time implementation of: ",NA,NA
"int data[] = {0, 1, 2, 3, 4, 5};",NA,NA
QUESTION 10:,NA,NA
What is the most sensible address to have in the base register for ,NA,NA
processing this array? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_10.html [7/8/2545 18:42:54],NA
A good answer might be:,NA,NA
"The address of data[0]: 0x00605000. In fact, in ANSI C, the identifier for an array (in this ",NA,NA
case ,NA,NA
data,NA,NA
) stands for the address of its first element. At run time this address will likely be ,NA,NA
in a base register. ,NA,NA
Example Program,NA,NA
You may be thinking that there has got to be an easier way to load a register from memory. ,NA,NA
"At the machine language level there is not. However, the assembler has features that make ",NA,NA
it much easier to write ,NA,NA
lw,NA,NA
 and ,NA,NA
sw,NA,NA
 instructions. These are discussed in a later chapter. ,NA,NA
Example Program.,NA,NA
 Evaluate the polynomial ,NA,NA
5x,NA,NA
2,NA,NA
 -12x + 97,NA,NA
 for a value ,NA,NA
x,NA,NA
 in memory. Store ,NA,NA
the result at location ,NA,NA
poly,NA,NA
 in memory. ,NA,NA
QUESTION 11:,NA,NA
How many ,NA,NA
lw,NA,NA
 instructions will be needed? ,NA,NA
How many ,NA,NA
sw,NA,NA
 instructions will be needed? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_11.html [7/8/2545 18:43:01],NA
A good answer might be: ,NA,NA
How many ,NA,NA
lw,NA,NA
 instructions will be needed?     ,NA,NA
One,NA,NA
", near the start of the program to load ",NA,NA
x,NA,NA
 into a register. ,NA,NA
How many ,NA,NA
sw,NA,NA
 instructions will be needed?     ,NA,NA
One,NA,NA
", near the end of the program to save ",NA,NA
the result in ,NA,NA
poly,NA,NA
. ,NA,NA
Symbolic Address,NA,NA
"In the description of this problem, memory locations were called ",NA,NA
x,NA,NA
 and ,NA,NA
poly,NA,NA
". Of course, at ",NA,NA
"run time, addresses are 32-bit integers. But at assembly language time it is convenient to ",NA,NA
use names for memory locations. These names are called ,NA,NA
symbolic addresses,NA,NA
. One of the ,NA,NA
most important features of an assembler is support for symbolic addresses. In the following ,NA,NA
example we will ignore some of this support in favor of explaining how the hardware ,NA,NA
instructions work. Here is a start on the program: ,NA,NA
## poly.asm ,NA,NA
## ,NA,NA
## evaluate  5x^2 -12x + 97 ,NA,NA
##,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
 . . . . many instructions,NA,NA
 .data ,NA,NA
x:      .word   17             # base register points here ,NA,NA
poly:   .word   0,NA,NA
## End of file,NA,NA
The assembler directive ,NA,NA
.data,NA,NA
" means: """,NA,NA
here is the start of the data section of memory,NA,NA
""". The ",NA,NA
assembler directive ,NA,NA
.word,NA,NA
" means: """,NA,NA
put a 32-bit two's complement integer here,NA,NA
""". ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_12.html (1 of 2) [7/8/2545 18:43:20],NA
QUESTION 12:,NA,NA
The assembler in SPIM automatically assembles the .data section starting at ,NA,NA
address 0x10000000. ,NA,NA
1.  What address corresponds to the symbolic address ,NA,NA
x,NA,NA
? 2.  ,NA,NA
What address corresponds to the symbolic address ,NA,NA
poly,NA,NA
?,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_12.html (2 of 2) [7/8/2545 18:43:20],NA
A good answer might be: ,NA,NA
The assembler in SPIM automatically assembles code starting at address 0x10000000. ,NA,NA
1.  What address corresponds to the symbolic address ,NA,NA
x,NA,NA
?           ,NA,NA
0x10000000 ,NA,NA
2.  What address corresponds to the symbolic address ,NA,NA
poly,NA,NA
?     ,NA,NA
0x10000004 ,NA,NA
Here is what this part of the SPIM simulation looks like: ,NA,NA
More Code,NA,NA
Here is an important addition to the program. Decide on the registers you need and what ,NA,NA
they are used for. Then write down your decisions! This is crucial for getting things correct. ,NA,NA
## poly.asm ,NA,NA
## ,NA,NA
## evaluate  5x^2 -12x + 97 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
"## $10 base register, address of x ",NA,NA
## $11 x ,NA,NA
## $12 value of the polynomial ,NA,NA
## $13 temporary,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" lui   $10,______     #  Init base register",NA,NA
" lw    $11,0($_____)  #  Load x",NA,NA
" ori   $12,$0,_____   #  Initialize the accumulator",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_13.html (1 of 2) [7/8/2545 18:43:31],NA
" #  during the ""load delay slot""",NA,NA
 . . .  many instructions,NA,NA
" sw    $12,___($___)  #  Store result in poly",NA,NA
 .data ,NA,NA
x:      .word   17           # base register points here ,NA,NA
poly:   .word   0 ,NA,NA
## End of file,NA,NA
A register where a value is built up after several calculations is called an ,NA,NA
accumulator,NA,NA
. ,NA,NA
"(Some old processors have a single, special register that is used for this purpose. But MIPS ",NA,NA
has many general purpose registers for this). ,NA,NA
Remember that data loaded from memory is not available to the instruction following the ,NA,NA
load. The instruction after a ,NA,NA
lw,NA,NA
", in the ""load delay slot"", should not try to use the loaded ",NA,NA
data. ,NA,NA
QUESTION 13:,NA,NA
Fill in the blanks. Look at the previous answer to help with the ,NA,NA
lui,NA,NA
 instruction. ,NA,NA
Use it to load the upper half of the base register with the upper half of the first ,NA,NA
data address. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_13.html (2 of 2) [7/8/2545 18:43:31],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Second Term,NA,NA
Now fill in the blanks so that the second term is evaluated and added to the accumulator. ,NA,NA
## poly.asm ,NA,NA
## ,NA,NA
## evaluate  5x^2 -12x + 97 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
"## $10 base register, address of x ",NA,NA
## $11 x ,NA,NA
## $12 value of the polynomial ,NA,NA
## $13 temporary,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
" lw    $11,0($10)     #  Load x",NA,NA
" ori   $12,$0,97      #  Initialize the accumulator",NA,NA
" #  during the ""load delay slot""",NA,NA
" ori   $13,$0,12      #  evaluate second term",NA,NA
" mult  $__,$__        #  12x",NA,NA
 ____  $13            #  assume 32 bit result,NA,NA
" subu  $__,$__,$__    #  accumulator = -12x +97",NA,NA
 ....   instructions,NA,NA
" sw    $12,4($10)     #  Store result in poly",NA,NA
 .data ,NA,NA
x:      .word   17           # base register points here ,NA,NA
poly:   .word   0,NA,NA
## End of file,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_14.html (1 of 2) [7/8/2545 18:43:38],NA
QUESTION 14:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_14.html (2 of 2) [7/8/2545 18:43:38],NA
A good answer might be: ,NA,NA
"All blanks filled, as below: ",NA,NA
Third Term,NA,NA
At this point all we need to do is square ,NA,NA
x,NA,NA
", multiply by five, and add the result to the ",NA,NA
accumulator. After squaring ,NA,NA
x,NA,NA
" we don't need its value anymore, so ",NA,NA
x^2,NA,NA
 can be put back into ,NA,NA
register $11. ,NA,NA
## poly.asm ,NA,NA
## ,NA,NA
## evaluate  5x^2 -12x + 97 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
"## $10 base register, address of x ",NA,NA
## $11 x ,NA,NA
## $12 value of the polynomial ,NA,NA
## $13 temporary,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
" lw    $11,0($10)     #  Load x",NA,NA
" ori   $12,$0,97      #  Initialize the accumulator",NA,NA
" #  during the ""load delay slot""",NA,NA
" ori   $13,$0,12      #  evaluate second term",NA,NA
" mult  $11,$13        #  12x",NA,NA
 mflo  $13            #  assume 32 bit result,NA,NA
" subu  $12,$12,$13    #  accumulator = -12x +97",NA,NA
 #  evaluate third term,NA,NA
" mult  $__,$__        #  x^2",NA,NA
 mflo  $__            #  assume 32 bit result,NA,NA
 . . . . instructions,NA,NA
" sw    $12,4($10)     #  Store result in poly",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_15.html (1 of 2) [7/8/2545 18:43:46],NA
 .data ,NA,NA
x:      .word   17           #  base register points here ,NA,NA
poly:   .word   0,NA,NA
## End of file,NA,NA
QUESTION 15:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_15.html (2 of 2) [7/8/2545 18:43:46],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
More of the Third Term,NA,NA
Here is the rest of the program: ,NA,NA
## poly.asm -- complete program ,NA,NA
## ,NA,NA
## evaluate  5x^2 -12x + 97 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
"## $10 base register, address of x ",NA,NA
## $11 x ,NA,NA
## $12 value of the polynomial ,NA,NA
## $13 temporary,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
" lw    $11,0($10)     #  Load x",NA,NA
" ori   $12,$0,97      #  Initialize the accumulator",NA,NA
" #  during the ""load delay slot""",NA,NA
" ori   $13,$0,12      #  evaluate second term",NA,NA
" mult  $11,$13        #  12x",NA,NA
 mflo  $13            #  assume 32 bit result,NA,NA
" subu  $12,$12,$13    #  accumulator = -12x +97",NA,NA
 #  evaluate third term,NA,NA
" mult  $11,$11        #  x^2",NA,NA
 mflo  $11            #  assume 32 bit result,NA,NA
" ori   $13,$0,___     #  5",NA,NA
" mult  $___,$___      #  5x^2",NA,NA
 mflo  $13            #,NA,NA
" addu  $12,$___,$___  #  accumulator = 5x^2-12x+97",NA,NA
" sw    $12,4($10)     #  Store result in poly",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_16.html (1 of 2) [8/8/2545 13:40:11],NA
 .data ,NA,NA
x:      .word   17 ,NA,NA
poly:   .word   0,NA,NA
## End of file,NA,NA
"Happily, after filling in the blanks, the program is finished. ",NA,NA
QUESTION 16:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_16.html (2 of 2) [8/8/2545 13:40:11],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Complete Program,NA,NA
Here is the complete program. You may wish to copy it to the clipboard and paste it into ,NA,NA
your text editor. Now you can save it to a file and run it with SPIM. ,NA,NA
## poly.asm -- complete program ,NA,NA
## ,NA,NA
## evaluate  5x^2 -12x + 97 ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
"## $10 base register, address of x ",NA,NA
## $11 x ,NA,NA
## $12 value of the polynomial ,NA,NA
## $13 temporary,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
" lw    $11,0($10)     #  Load x",NA,NA
" ori   $12,$0,97      #  Initialize the accumulator",NA,NA
" #  during the ""load delay slot""",NA,NA
" ori   $13,$0,12      #  evaluate second term",NA,NA
" mult  $11,$13        #  12x",NA,NA
 mflo  $13            #  assume 32 bit result,NA,NA
" subu  $12,$12,$13    #  accumulator = -12x +97",NA,NA
 #  evaluate third term,NA,NA
" mult  $11,$11        #  x^2",NA,NA
 mflo  $11            #  assume 32 bit result,NA,NA
" ori   $13,$0,5       #  5",NA,NA
" mult  $11,$13        #  5x^2",NA,NA
 mflo  $13            #,NA,NA
" addu  $12,$12,$13    #  accumulator = 5x^2-12x+97",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_17.html (1 of 2) [8/8/2545 13:40:36],NA
" sw    $12,4($10)     #  Store result in poly",NA,NA
 .data ,NA,NA
x:      .word   17 ,NA,NA
poly:   .word   0 ,NA,NA
## End of file,NA,NA
"Of course, the program should be tested with a careful selection of values for ",NA,NA
x,NA,NA
. A ,NA,NA
production quality program would document the upper and lower bounds for ,NA,NA
x,NA,NA
. ,NA,NA
QUESTION 17:,NA,NA
Suggest three values for ,NA,NA
x,NA,NA
 for use in testing. ,NA,NA
Suggest three values for ,NA,NA
x,NA,NA
 for use in testing. ,NA,NA
A good answer might be: ,NA,NA
"0, 1, -1. Of course you don't stop there, but running with these three values often reveals ",NA,NA
problems. ,NA,NA
A Run of the Program,NA,NA
Here is a run of the program with ,NA,NA
x,NA,NA
" = -1. The result, 0x72 = 114",10,NA
" is correct. As always, running is ",NA,NA
done by single-stepping (pushing F10). The PC is initialized to 0x00400000. ,NA,NA
Create a source file and play around with the program. Put some bugs into the program and see what ,NA,NA
they do. Experimentally determine the range allowed for ,NA,NA
x,NA,NA
. ,NA,NA
QUESTION 18: ,NA,NA
How can you solve for the allowed range of ,NA,NA
x,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_18.html [8/8/2545 13:41:12],NA
How can you solve for the allowed range of ,NA,NA
x,NA,NA
? (Don't actually do this unless you want to). ,NA,NA
A good answer might be: ,NA,NA
"The result, ",NA,NA
poly,NA,NA
" must fit into 32 bits, two's complement. So -2",31,NA
 <= 5x^2 -12x + 97 <= ,NA,NA
2,31,NA
 - 1. Further algebraic fussing gives the range of ,NA,NA
x,NA,NA
. (See the exercises). ,NA,NA
End of Chapter,NA,NA
You have reached the end of this chapter. Click on a blue subject to go to where it was ,NA,NA
"discussed. To get back here, click on the ""back arrow"" button of your browser. ",G,NA
word alignment ,G,NA
Byte order:,NA,NA
 little endian and big endian ,G,NA
MIPS and SPIM,NA,NA
 byte order ,G,NA
address calculation ,G,NA
lw,NA,NA
 instruction ,G,NA
Operation,NA,NA
 of the lw instruction ,G,NA
load delay slot ,G,NA
sw,NA,NA
 instruction ,G,NA
lui,NA,NA
 instruction ,G,NA
symbolic address ,G,NA
.word directive ,G,NA
.data directive ,G,NA
register use table ,G,NA
accumulator,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_19.html [8/8/2545 13:41:27],NA
CHAPTER 16 — More Memory Access,NA,NA
This chapter discusses some more instructions that load registers (from memory) and that ,NA,NA
store registers (to memory). These instructions are used less frequently than ,NA,NA
lw,NA,NA
 and ,NA,NA
sw,NA,NA
. ,NA,NA
Chapter Topics:,G,NA
Load byte and store byte:,NA,NA
lb,NA,NA
", ",NA,NA
lbu,NA,NA
", ",NA,NA
and,NA,NA
sb ,G,NA
Load halfword and store halfword:,NA,NA
lh,NA,NA
", ",NA,NA
lhu,NA,NA
", ",NA,NA
and,NA,NA
sh ,G,NA
Arithmetic with less than 32 bits.,NA,NA
QUESTION 1:,NA,NA
(Review:) What is the smallest addressable unit of main memory? ,NA,NA
A good answer might be: ,NA,NA
A byte ,NA,NA
Loading a Single Byte,NA,NA
There are two instructions that load a byte from a memory address. The address is ,NA,NA
calculated at run time by adding an offset to a base register (just as with the load word and ,NA,NA
store word instructions). The instructions differ in how the 8-bit byte is put into the 32-bit ,NA,NA
register. ,NA,NA
"lb   t,off(b)  # $t <-- Sign-extended byte ",NA,NA
 # from memory address b+off,NA,NA
 # b is a base register. ,NA,NA
 # off is 16-bit two's complement.,NA,NA
The ,NA,NA
lb,NA,NA
 instruction copies bit 7 of the byte to bits 8-31 of the register (all bits to the right of bit ,NA,NA
7). Use this instruction when the byte is regarded as an 8-bit signed integer in the range -,NA,NA
128...+127 and you want it to become a 32-bit integer in the same range. ,NA,NA
"lbu   t,off(b) # $t <-- Zero-extended byte  ",NA,NA
# from memory address b+off # ,NA,NA
b is a base register. ,NA,NA
 # off is 16-bit two's complement.,NA,NA
The ,NA,NA
lbu,NA,NA
 instruction fills the bits to the right of bit 7 with zeros. Use this instruction when the ,NA,NA
byte is regarded as a ascii character or 8-bit unsigned integer. ,NA,NA
QUESTION 2:,G,NA
Memory at 0x10000007 contains the byte 0xA4 ,G,NA
Register $8 contains 0x10000000,NA,NA
What is put in register $10 when the following instruction is executed: ,NA,NA
"lb    10,7($8)",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_2.html (1 of 2) [7/8/2545 18:44:07],NA
A good answer might be: ,NA,NA
0xFFFFFFA4,NA,NA
     Bit 7 of 0xA4 is one; ,NA,NA
lb,NA,NA
 extends that bit to the high order three bits of ,NA,NA
$10. ,NA,NA
Storing a Single Byte,NA,NA
Loading and storing bytes is used for processing text and for low-level systems programs ,NA,NA
"(such as assemblers and operating systems). Graphics programs, also, make frequent use ",NA,NA
of these operations. Both operations could be done using ,NA,NA
lw,NA,NA
 and ,NA,NA
sw,NA,NA
 along with bit ,NA,NA
"manipulation instructions, but it is convenient and fast to have byte length load and store. ",NA,NA
There is a single instruction for storing a byte: ,NA,NA
"sb    t,off(b)   # The byte at off+b <-- low-order ",NA,NA
# byte from register $t.,NA,NA
 # b is a base register. ,NA,NA
 # off is 16-bit two's complement.,NA,NA
"There is no need for two ""store byte"" instructions. Whatever is in the low-order (right) byte of ",NA,NA
"the register is copied to memory. The other bytes of the register are ignored. Of course, the ",NA,NA
register does not change. ,NA,NA
QUESTION 3:,G,NA
Memory at 0x10000519 contains the byte 0x44 ,G,NA
Register $8 contains 0x10000400 ,G,NA
Register $10 contains 0xFA034183,NA,NA
"Write the instruction that replaces the ""0x44"" in memory with ""0x83"". ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_3.html [7/8/2545 18:44:10],NA
A good answer might be: ,NA,NA
"sb    10,0x119($8)",NA,NA
All Addresses Great and Small,NA,NA
There are no alignment requirements for the three instructions: ,NA,NA
lb,NA,NA
", ",NA,NA
lbu,NA,NA
", and ",NA,NA
sb,NA,NA
. Any byte in ,NA,NA
memory that is acceptable for program data can be used. This is fortunate since character ,NA,NA
strings are usually stored in successive bytes. (Remember that there are areas of MIPS ,NA,NA
main memory reserved for special uses). ,NA,NA
Byte load and store instructions are often used for input and output with media that must be ,NA,NA
used on many systems. Often the data written to magnetic tape by one government agency ,NA,NA
"is used by other agencies using different computers. To make the data transportable, the ",NA,NA
"format of the data is described byte by byte. The format must be followed, regardless of the ",NA,NA
byte order of the computers writing or reading the data. ,NA,NA
QUESTION 4:,NA,NA
Say that the format of a tape record requires big-endian integers. Complete ,NA,NA
the following instructions so that the integer in register $9 is written to the ,NA,NA
"four bytes starting at address 0x10000000 (the tape i/o buffer, let us ",NA,NA
pretend). Put the most significant byte at the starting address. ,NA,NA
"lui  $8,0x1000      # $8 is base register ",NA,NA
"sb   $9,____($8)    # least significant byte ",NA,NA
"srl  $9,$9,_____    # move next byte to low order ",NA,NA
"sb   $9,____($8)    # bits 8-15 ",NA,NA
"srl  $9,$9,_____    # move next byte to low order ",NA,NA
"sb   $9,____($8)    # bits 16-23 ",NA,NA
"srl  $9,$9,_____    # move next byte to low order ",NA,NA
"sb   $9,____($8)    # most significant byte",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_4.html [7/8/2545 18:44:13],NA
A good answer might be:,NA,NA
"lui  $8,0x1000      # $8 is base register ",NA,NA
"sb   $9,3($8)       # least significant byte ",NA,NA
"srl  $9,$9,8        # move next byte to low order ",NA,NA
"sb   $9,2($8)       # bits 8-15 ",NA,NA
"srl  $9,$9,8        # move next byte to low order ",NA,NA
"sb   $9,1($8)       # bits 16-23 ",NA,NA
"srl  $9,$9,8        # move next byte to low order ",NA,NA
"sb   $9,0($8)       # most significant byte",NA,NA
Tape Writer,NA,NA
The least significant byte of the register is written to memory first (because it is already ,NA,NA
where the ,NA,NA
sb,NA,NA
 instruction needs it). Then the remaining bytes of $9 are shifted into the right-,NA,NA
most byte one by one and written to memory. Here is a complete version of the program: ,NA,NA
## endian.asm ,NA,NA
## ,NA,NA
## copy $9 to memory in big-endian order ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## $8  --- first byte of the tape block ,NA,NA
## $9  --- 4-byte integer,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" lui  $9,0x1234      # put data in $9",NA,NA
" ori  $9,0x5678      #",NA,NA
" lui  $8,0x1000      # $8 is base register",NA,NA
" sb   $9,3($8)       # least significant byte",NA,NA
" srl  $9,$9,8        # move next byte to low order ",NA,NA
"sb   $9,2($8)       # bits 8-15 ",NA,NA
" srl  $9,$9,8        # move next byte to low order ",NA,NA
"sb   $9,1($8)       # bits 16-23 ",NA,NA
" srl  $9,$9,8        # move next byte to low order ",NA,NA
"sb   $9,0($8)       # most significant byte",NA,NA
 .data ,NA,NA
tape:                     # base register points here,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_5.html (1 of 2) [7/8/2545 18:44:20],NA
 .space 1024         # tape buffer (1K bytes),NA,NA
## End of file,NA,NA
The ,NA,NA
.space,NA,NA
" directive reserves bytes in memory, in this case 1024",10,NA
 bytes. Pretend this is the ,NA,NA
buffer from which a tape record will be written. The example program uses just the first four ,NA,NA
bytes. ,NA,NA
QUESTION 5:,NA,NA
What is the ,NA,NA
symbolic address,NA,NA
 of the first byte of the ,NA,NA
.data,NA,NA
 section? What main ,NA,NA
storage address will it have at run time? ,NA,NA
A good answer might be: ,NA,NA
What is the ,NA,NA
symbolic address,NA,NA
 of the first byte of the ,NA,NA
.data,NA,NA
 section?     ,NA,NA
tape,NA,NA
     What main ,NA,NA
storage address will it have at run time?     ,NA,NA
0x10000000 ,NA,NA
The main storage address for the first byte of the data section is 0x10000000 by default ,NA,NA
(of the SPIM assembler). There is nothing in the program that says this. ,NA,NA
A Run of the Program,NA,NA
The SPIM display shows data in groups of 4-byte words with the most significant byte on the ,NA,NA
"left. This makes the data readable by humans. Within each group of four, the byte with the ",NA,NA
lowest address is on the right. Here is how SPIM looks after the first byte of the register has ,NA,NA
been stored to the buffer: ,NA,NA
"The byte is where it should be in memory, although you have to look at the display carefully ",NA,NA
to see this. ,NA,NA
QUESTION 6:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_6.html (1 of 2) [7/8/2545 18:44:47],NA
Which byte of $9 should go into address $0x10000000? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_6.html (2 of 2) [7/8/2545 18:44:47],NA
Which byte of $9 should go into address $0x10000000? ,NA,NA
A good answer might be: ,NA,NA
"0x12 --- the ""big end"" goes into the first address for big-endian byte order. ",NA,NA
"Eventually, after a few more right shifts, it gets there. ",NA,NA
Loading Halfwords,NA,NA
A MIPS ,NA,NA
halfword,NA,NA
" is two bytes. This, also, is a frequently used length of data. An ANSI C ",NA,NA
"short integer is usually two bytes. So, MIPS has load halfword and store halfword ",NA,NA
instructions. There are two load halfword instructions. One extends the sign bit of the ,NA,NA
halfword in memory into the upper two bytes of the register. The other extends with zeros. ,NA,NA
"lh   t,off(b)   # $t <-- Sign-extended halfword  # ",NA,NA
starting at memory address b+off.  # b ,NA,NA
is a base register. ,NA,NA
 # off is 16-bit two's complement.,NA,NA
"lhu  t,off(b)   # $t <-- zero-extended halfword  ",NA,NA
# starting at memory address b+off.  # ,NA,NA
b is a base register. ,NA,NA
 # off is 16-bit two's complement.,NA,NA
Halfword addresses must be ,NA,NA
halfword aligned,NA,NA
. Attempting to load a halfword from an ,NA,NA
unaligned address will cause a trap. ,NA,NA
QUESTION 7:,NA,NA
How can you tell if an address is halfword aligned? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_7.html [7/8/2545 18:44:49],NA
A good answer might be: ,NA,NA
It is divisible by two. Addresses divisible by two have a zero in the low-order bit. ,NA,NA
Storing Halfwords,NA,NA
Only one store halfword instruction is needed. The low-order two bytes of the designated ,NA,NA
"register are copied to memory, no matter what the upper two bytes are. Of course, the ",NA,NA
register in not changed when its data is copied to memory. ,NA,NA
"sh    t,off(b)    # Halfword at off+b <-- low-order ",NA,NA
 ,NA,NA
# two bytes from $t.,NA,NA
 # b is a base register. ,NA,NA
 # off is 16-bit two's complement.,NA,NA
MIPS instructions behave the same no matter how data has been loaded into a register. For ,NA,NA
"example, an ",NA,NA
addu,NA,NA
 instruction does a full 32-bit addition even if one of the operand registers ,NA,NA
was loaded with ,NA,NA
lh,NA,NA
 (or ,NA,NA
lb,NA,NA
). ,NA,NA
QUESTION 8:,NA,NA
Perform these two addition problems: ,NA,NA
 1010 1110         0000 0000 0000 0000 0000 0000 1010 1110 ,NA,NA
1100 0110         0000 0000 0000 0000 0000 0000 1100 0110 ,NA,NA
---------         ---------------------------------------,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_8.html [7/8/2545 18:44:53],NA
A good answer might be:,NA,NA
1   1 11                                       1    1 11 ,NA,NA
 1010 1110         0000 0000 0000 0000 0000 0000 1010 1110 ,NA,NA
1100 0110         0000 0000 0000 0000 0000 0000 1100 0110 ,NA,NA
---------         ---------------------------------------,NA,NA
 1111 0100         0000 0000 0000 0000 0000 0001 1111 0100,NA,NA
All Arithmetic is 32-bits,NA,NA
MIPS has no instructions for byte arithmetic nor for halfword arithmetic. For a single ,NA,NA
"operation (such as above), the results in the low-order bytes are the same. The carry out of ",NA,NA
the high-order bit (of the byte or halfword) is part of the 32-bit result. Further operations may ,NA,NA
increasingly involve high-order bits. The result after several operations will be a correct ,NA,NA
"result, but may not fit into the original size of the operands. ",NA,NA
QUESTION 9:,NA,NA
Now add a third operand to the previous sum: ,NA,NA
 1111 0100         0000 0000 0000 0000 0000 0001 1111 0100 ,NA,NA
1010 1100         0000 0000 0000 0000 0000 0000 1010 1100 ,NA,NA
---------         ---------------------------------------,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_9.html [7/8/2545 18:44:56],NA
A good answer might be:,NA,NA
11111 1                                       11 1111 1 ,NA,NA
 1111 0100         0000 0000 0000 0000 0000 0001 1111 0100 ,NA,NA
1010 1100         0000 0000 0000 0000 0000 0000 1010 1100 --,NA,NA
-------         ---------------------------------------,NA,NA
 1010 0000         0000 0000 0000 0000 0000 0010 1010 0000 ,NA,NA
It would not be correct to store the low order byte of the above result and claim that it is ,NA,NA
the sum of the three operands. ,NA,NA
Low-order Result not always Correct,NA,NA
A further problem is that in general the result in the low order byte is not the same as would ,NA,NA
"result from several true 8-bit arithmetic operations. For example, divide the above results by ",NA,NA
four (by shifting right twice). The low-order bytes are different. ,NA,NA
"These are problems that compiler writers face. For example, ANSI C short int variables ",NA,NA
should behave the same way on all computers. But 16-bit math does not behave the same ,NA,NA
"way on all computer architectures! To make MIPS follow the standard, several extra ",NA,NA
machine operations must be inserted between each arithmetic operation. On MIPS (and ,NA,NA
other computers) 16-bit arithmetic is much slower than 32-bit arithmetic. ,NA,NA
Naive programmers sometimes use short ints with the expectation that their program will ,NA,NA
"run faster. Depending on the hardware and the compiler, the opposite might be true! ",NA,NA
QUESTION 10:,NA,NA
Crytography programs often treat characters as 8-bit integers and transform ,NA,NA
them with arithmetic operations. Suppose a cryptography program is written ,NA,NA
"in C for a Windows system. When compiled on a Macintosh system it runs, ",NA,NA
but produces different results! You have been given the job of making the Mac version ,NA,NA
work identically to the Windows version. What must you do? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_10.html [7/8/2545 18:44:57],NA
A good answer might be:,NA,NA
Probably the problem is with differences in small integer arithmetic between the two ,NA,NA
systems. You will have to carefully look at variable declarations in the program and will ,NA,NA
"have to study the arithmetic. To make the Mac version identical to the Windows version, ",NA,NA
you may have to write parts of it in assembly. ,NA,NA
End of the Chapter,NA,NA
You have reached the end of this chapter. Click on a blue subject to go to where it was ,NA,NA
"discussed. To get back here, click on the ""back arrow"" button of your browser. ",G,NA
Loading a byte,NA,NA
 into a register. ,G,NA
Storing a byte,NA,NA
 from a register. ,G,NA
The ,NA,NA
.space,NA,NA
 assembler directive. ,G,NA
How SPIM displays the ,NA,NA
data section. ,G,NA
Loading a halfword,NA,NA
 into a register. ,G,NA
Storing a halfword,NA,NA
 from a register. ,G,NA
Byte and halfword ,NA,NA
arithmetic.,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-16/ass16_11.html [7/8/2545 18:45:01],NA
CHAPTER 17 — Jump and Branch ,NA,NA
Instructions,NA,NA
Much of the power of computers (and all machines) is their ability to repeat actions and their ,NA,NA
ability to alter their operation depending on data. Modern programming languages express ,NA,NA
these abilities using syntactic structures. Repeated action (iteration) is done with a ,NA,NA
while ,NA,NA
structure. Altered operation (alteration) is done with an ,NA,NA
if-then-else,NA,NA
 structure. ,NA,NA
Assembly language does not have these control structures. It must build these structures ,NA,NA
out of machine-level instructions. ,NA,NA
Conditional branch instructions,NA,NA
 and ,NA,NA
jump,NA,NA
 instructions are ,NA,NA
used to implement both iteration and branching. ,NA,NA
Chapter Topics:,G,NA
Jump Instruction: ,H,NA
j,NA,NA
 instruction (jump) ,G,NA
Conditional Branch Instructions (two register): ,H,NA
beq,NA,NA
 instruction (branch equal) ,H,NA
bne,NA,NA
 instruction (branch not equal),NA,NA
QUESTION 1:,NA,NA
Do machine instructions in MIPS memory have addresses? ,NA,NA
A good answer might be: ,NA,NA
Yes. All bytes of main memory have addresses. ,NA,NA
Review of the Machine Cycle,NA,NA
Each machine cycle executes one machine instruction. At the top of ,NA,NA
When a ,NA,NA
jump,NA,NA
 instruction is executed it puts a new address into the ,NA,NA
PC. Now the instruction that is fetched at the top of the next machine ,NA,NA
cycle is the instruction at the new address. Instead of executing the ,NA,NA
"next instruction in sequence, the processor ""jumps"" to an instruction ",NA,NA
somewhere else in memory. Execution now continues sequentially ,NA,NA
from the new address. ,NA,NA
"However, it takes some time for the PC to change. Before it changes, the next sequential ",NA,NA
instruction has already been fetched ,NA,NA
"the machine cycle, the ",NA,NA
PC,NA,NA
 (program counter) contains the address of ,NA,NA
an instruction to fetch from memory. The instruction is fetched into the ,NA,NA
processor and is prepared for execution. In the middle of the machine ,NA,NA
The reason for this delay is that MIPS is ,NA,NA
pipelined.,NA,NA
 The processor holds a queue of ,NA,NA
"instructions being prepared for execution (a ""pipe""). The instruction after a jump instruction ",NA,NA
is already in the pipe when the jump is being executed. (The SPIM simulator allows you to ,NA,NA
"turn this feature off, but this is not an option with actual R2000 hardware). ",NA,NA
The instruction that follows the jump instruction in memory (in the branch delay slot) will be ,NA,NA
executed. The instruction that executes after it is the instruction at the new address. Often ,NA,NA
the branch delay slot is filled with a no-op instruction. ,NA,NA
QUESTION 2:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_2.html (1 of 2) [7/8/2545 18:45:10],NA
(Review:) What does a no-op instruction do? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_2.html (2 of 2) [7/8/2545 18:45:10],NA
A good answer might be: ,NA,NA
A no-op instruction is any instruction that has no effect. A common no-op instruction is ,NA,NA
"sll $0,$0,0",NA,NA
. ,NA,NA
Altering the PC,NA,NA
"Here is a sequence of instructions shown in outline. Once started, ",NA,NA
the four instructions execute in an unending loop. The last ,NA,NA
"instruction, a no-op, fills the branch delay slot to give the PC time to ",NA,NA
change. ,NA,NA
Address,NA,NA
Instruction,NA,NA
PC after executing ,NA,NA
this instruction,NA,NA
...............,NA,NA
...........,NA,NA
00400000,NA,NA
00400000,NA,NA
load,NA,NA
00400004,NA,NA
00400004,NA,NA
add ,NA,NA
00400008,NA,NA
00400008,NA,NA
jump 0x400000,NA,NA
0040000C,NA,NA
0040000C,NA,NA
no-op,NA,NA
00400000,NA,NA
Inspect the sequence of addresses in the PC. A loop structure has ,NA,NA
been created with the jump instruction. Notice that the effect of the ,NA,NA
jump instruction (loading ,NA,NA
0x400000,NA,NA
 into the PC) is not seen until ,NA,NA
after the branch delay slot. ,NA,NA
QUESTION 3:,NA,NA
(Review:) How many bits are in a MIPS memory address? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_3.html [7/8/2545 18:45:43],NA
A good answer might be: ,NA,NA
32. The same size as a MIPS instruction. ,NA,NA
The Jump Instruction,NA,NA
How does a 32-bit instruction specify a 32-bit ,NA,NA
address? Some of the instruction's bits must be ,NA,NA
used for the op-code. Here is the assembly ,NA,NA
language version of the jump instruction. ,"j    target     # after a delay of one machine cycle, 
 # PC  <-- address of target",NA
Here is the machine language form of the ,NA,NA
instruction: ,"6              26 
  
 000010
  00000000000000000000000000    -- fields of the instructuion
  
 opcode         target                -- meaning of the fields",NA
There is room in the instruction for a 26-bit address. The 26-bit target address field is ,NA,NA
transformed into a 32-bit address. Instructions always start on an address that is a multiple of ,NA,NA
four (they are word-aligned). So the low order two bits of a 32-bit instruction address are ,NA,NA
"always ""00"". Shifting the 26-bit target left two places results in a 28-bit word-aligned address. ",NA,NA
Now four bits are concatenated to the high-order end of the 28-bit address to form a 32-bit ,NA,NA
address. These four bits are copied from the top four bits of the PC. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_4.html (1 of 2) [7/8/2545 18:46:10],NA
QUESTION 4:,NA,NA
"While this is going on, what instruction's address is in the PC? ",NA,NA
A good answer might be: ,NA,NA
The PC contains the address that follows the address of the jump instruction. ,NA,NA
Most Jumps (and Branches) are Local,NA,NA
Most jumps and branches are to a nearby address. The jump address and the address of ,NA,NA
the instruction following the jump instruction are likely to have the same high-order four bits. ,NA,NA
"Of course, a compiler or assembly language programmer must be careful to ensure that this ",NA,NA
is so. ,NA,NA
"A jump instruction can't jump to anywhere in the full 32-bit address space, but must jump to ",NA,NA
somewhere within the following range of addresses: ,NA,NA
wxyz 0000 0000 0000 0000 0000 0000 0000 ,NA,NA
...,NA,NA
wxyz 1111 1111 1111 1111 1111 1111 1100,NA,NA
"Here, ",NA,NA
wxyz,NA,NA
 represents the high-order four bits of the PC. Almost always the jump ,NA,NA
instruction and the jump address are both within this range. ,NA,NA
All these details may look terrible to you at this point. Don't worry: (1) its not as bad as it ,NA,NA
"looks, and (2) usually the assembler does all the work. (But for now, ",NA,NA
you,NA,NA
 get to do the work). ,NA,NA
QUESTION 5:,NA,NA
Here is a great idea! Why not implement the jump instruction without using ,NA,NA
an op-code? Build the processor so that when execution encounters a 32-bit ,NA,NA
address it automatically jumps to that address. ,NA,NA
Will this scheme work? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_5.html [7/8/2545 18:47:30],NA
A good answer might be:,NA,NA
"No. Addresses are 32-bit patterns, machine instructions are 32-bit patterns, and many ",NA,NA
data are 32-bit patterns. There is no way to tell them apart. Here is an example. Look at ,NA,NA
"this bit pattern: 0x00000000 Is this the address of the first byte of memory, or the ",NA,NA
sll ,NA,NA
"$0,$0,0",NA,NA
 instruction? ,NA,NA
Jump Practice,NA,NA
"The following program illustrates the jump instruction. For simplicity, all instructions other ",NA,NA
than the jump instruction are no-ops. The jump instruction jumps to the first instruction of the ,NA,NA
program. The very last instruction fills the delay slot. ,NA,NA
Address,NA,NA
Machine Instruction,NA,NA
Assembly Instruction,NA,NA
00400000,NA,NA
0000 0000 0000 0000 0000 0000 0000 0000,NA,NA
"sll $0,$0,0",NA,NA
00400004,NA,NA
0000 0000 0000 0000 0000 0000 0000 0000,NA,NA
"sll $0,$0,0",NA,NA
00400008,NA,NA
0000 0000 0000 0000 0000 0000 0000 0000,NA,NA
"sll $0,$0,0",NA,NA
0040000C,NA,NA
0000 0000 0000 0000 0000 0000 0000 0000,NA,NA
"sll $0,$0,0",NA,NA
00400010,NA,NA
000010 ,NA,NA
00 0001 0000 0000 0000 0000 0000,NA,NA
j firstInstruction,NA,NA
00400014,NA,NA
0000 0000 0000 0000 0000 0000 0000 0000,NA,NA
"sll $0,$0,0",NA,NA
The left-most six bits of the ,NA,NA
j,NA,NA
 machine instruction are the opcode. You need to decide if the ,NA,NA
next 26 bits are correct. ,NA,NA
QUESTION 6:,NA,NA
1. Write the full 32-bit jump address: ,NA,NA
0x00400000,NA,NA
______________________________,NA,NA
2. Write the ,NA,NA
26-bit field,NA,NA
 of the jump ,NA,NA
instruction:,NA,NA
 _________________________,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_6.html (1 of 2) [7/8/2545 18:48:13],NA
3. Shift ,NA,NA
it,NA,NA
 left two positions: ,NA,NA
4. What are the high-order four bits of the ,NA,NA
PC?,NA,NA
5. Copy (4) to the left of (3): ,NA,NA
6. Is (5) the same as (1)?,NA,NA
 ___________________________ ,NA,NA
____ ,NA,NA
____,NA,NA
___________________________ ,NA,NA
_____,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_6.html (2 of 2) [7/8/2545 18:48:13],NA
A good answer might be:,NA,NA
1. Write the full 32-bit jump address: ,NA,NA
0x00400000,NA,NA
0000 0000 0100 0000 0000 0000 0000 0000,NA,NA
2. Write the 26-bit field of the jump instruction:,NA,NA
 00 0001 0000 0000 0000 0000 0000,NA,NA
3. Shift it left two positions: ,NA,NA
0000 0100 0000 0000 0000 0000 0000,NA,NA
4. What are the high-order four bits of the PC?,NA,NA
 0000,NA,NA
5. Copy (4) to the left of (3): ,NA,NA
6. Is (5) the same as (1)?,NA,NA
0000,NA,NA
0000 0100 0000 0000 0000 0000 0000 ,NA,NA
Yes,NA,NA
Symbolic Address,NA,NA
"With some trickery, a 26-bit field can specify a 32-bit address. But it is a nuisance to figure ",NA,NA
"out! If you were doing machine language programming, that is what you would have to do. ",NA,NA
But the assembler does the work for you. Here is a tiny program: ,NA,NA
## jump.asm ,NA,NA
##,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" sll    $0,$0,0",NA,NA
" sll    $0,$0,0",NA,NA
" sll    $0,$0,0",NA,NA
" sll    $0,$0,0",NA,NA
 j      main,NA,NA
" addiu $8,$8,1 ",NA,NA
## End of file,NA,NA
It is similar to the previous example. The symbolic address ,NA,NA
main,NA,NA
 stands for the address of ,NA,NA
the first instruction. The instruction   ,NA,NA
j main,NA,NA
   tells the assembler to assemble a machine ,NA,NA
instruction with the proper 26-bit field. ,NA,NA
The branch delay slot is filled with an instruction that increments register $8. SPIM initializes ,NA,NA
all registers to zero when it starts. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_7.html (1 of 2) [7/8/2545 18:48:31],NA
QUESTION 7:,NA,NA
"After the loop has executed five times, what value will be in register $8? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_7.html (2 of 2) [7/8/2545 18:48:31],NA
A good answer might be: ,NA,NA
"Five. Each time the loop executes, the instruction in the branch delay slot increments $8. ",NA,NA
Assembled Program,NA,NA
"Here is a SPIM view of the program. When you run it, remember to set the value of the PC to ",NA,NA
0x400000. To see the branch delay it should be enabled in the options menu. ,NA,NA
The assembler constructed the same machine language jump instruction as we did by hand. ,NA,NA
(Compare with two pages back). Using a symbolic address is certainly easier. ,NA,NA
QUESTION 8:,NA,NA
Is the jump instruction what we need to construct a ,NA,NA
while,NA,NA
 loop? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_8.html [7/8/2545 18:48:49],NA
A good answer might be: ,NA,NA
No. You can build unending loops (infinite loops) with it. Additional instructions are ,NA,NA
needed for ,NA,NA
while,NA,NA
 loops and for ,NA,NA
if-then-else,NA,NA
 structures. ,NA,NA
Conditional Branches,NA,NA
A ,NA,NA
conditional branch,NA,NA
 instruction branches to a new address only if a certain condition is ,NA,NA
true. Usually the condition is about the values in registers. Here is the ,NA,NA
beq,NA,NA
 (branch on equal) ,NA,NA
instruction: ,NA,NA
"beq  u,v,addr   # if register $u == register $v",NA,NA
 #     PC  <-- addr,NA,NA
 #     after a delay of one machine cycle.,NA,NA
 # else,NA,NA
 #     no effect.,NA,NA
"The bit patterns in two registers are compared. If the bit patterns are the same, the PC is ",NA,NA
changed to the branch address. There is a branch delay following the instruction (just as for ,NA,NA
a jump instruction). ,NA,NA
QUESTION 9:,NA,NA
Will a 32-bit address fit inside the 32-bit   ,NA,NA
beq,NA,NA
   instruction? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_9.html [7/8/2545 18:48:53],NA
A good answer might be: ,NA,NA
No. Same problem as with the ,NA,NA
j,NA,NA
 instruction. ,NA,NA
Ifs and Whiles,NA,NA
More trickery is used to create a 32-bit branch address out of ,NA,NA
the smaller sized field of the machine instruction. But let's skip ,NA,NA
that for now. ,NA,NA
Branch instructions (including the ,NA,NA
beq,NA,NA
 instruction) are used to ,NA,NA
implement both loops and branches. At right is a flowchart ,NA,NA
showing an optional branch. Here is the assembly for it: ,NA,NA
 ...                # load values into $8 and $9 ,NA,NA
" beq  $8,$9,cont    # branch if equal",NA,NA
 nop                # branch delay slot,NA,NA
 ...                # conditionally,NA,NA
 ...                # executed,NA,NA
 ...                # statements ,NA,NA
"cont:   add   $10,$10,$11  # always executed",NA,NA
QUESTION 10:,NA,NA
Must the contents of the registers in this example be numeric? ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
beq,NA,NA
 tests if the same 32-bit pattern is in each register. The pattern can represent ,NA,NA
anything. ,NA,NA
Branch on Not Equal,NA,NA
Here is the ,NA,NA
bne,NA,NA
 (branch on not equal) instruction: ,NA,NA
"bne  u,v,addr   # if register $u =!= register $v #     ",NA,NA
PC  <-- addr,NA,NA
 #     after a delay of one machine cycle.,NA,NA
 # else,NA,NA
 #     no effect.,NA,NA
QUESTION 11:,NA,NA
Can a branch instruction implement a two-way decision (an ,NA,NA
if-then-else,NA,NA
)? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_11.html [7/8/2545 18:49:18],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Two-way Decision,NA,NA
A two-way decision (alternation) is written in ,NA,NA
assembly language using both a conditional branch ,NA,NA
and a jump instruction: ,NA,NA
 ...                # load values into ,NA,NA
 # $8 and $9 ,NA,NA
" beq  $8,$9,equal   # branch if equal",NA,NA
 ,NA,NA
nop                # branch delay slot,NA,NA
 ...                #  ,NA,NA
 ...                #  false branch,NA,NA
 ...                #  ,NA,NA
 j    cont,NA,NA
 nop ,NA,NA
equal:  ...                #,NA,NA
 ...                #  true branch,NA,NA
 ...                # ,NA,NA
"cont:   add   $10,$10,$11  # always executed",NA,NA
"Of course, any of the conditional branch instructions may be used. If you want the ""true"" ",NA,NA
"branch to come first and the ""false"" branch to come second (as in an ",NA,NA
if-then-else,NA,NA
 of Java or ,NA,NA
C) you may have to pick a different branch instruction. ,NA,NA
QUESTION 12:,NA,NA
In an ,NA,NA
if-then-else,NA,NA
 structure the two branches of control always come together ,NA,NA
at the first statement outside of the structure. Is this necessarily so in ,NA,NA
assembly language? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_12.html [7/8/2545 18:49:20],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Absolute Value,NA,NA
You can build a real rats-nest of code with assembly language. ,NA,NA
Avoid this by imitating the structures of a high level language. Draw ,NA,NA
a flowchart of the program or to rough it out in C or Java before ,NA,NA
coding. Put comments in the assembly source program before you ,NA,NA
add code to show how the code and the flowchart correspond. ,NA,NA
The flowchart at right shows a program to calculate the absolute ,NA,NA
"value of the integer at symbolic address ""A"". Here is a start on a ",NA,NA
program that follows that logic: ,NA,NA
## absVal.asm ,NA,NA
## ,NA,NA
## Calculate the absolute value of A,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
# Get A,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
 ,NA,NA
"lw    $8,___($10)    #  Load A",NA,NA
" ___   $0,$0,0        #  no-op",NA,NA
# Is A Negative?,NA,NA
# Store -A,NA,NA
done: ,NA,NA
 .data ,NA,NA
A:    .word   -1,NA,NA
## End of file,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_13.html (1 of 2) [7/8/2545 18:49:37],NA
"Assume that ""A"" will be the word starting at address 0x10000000. The ",NA,NA
lui,NA,NA
 instruction points ,NA,NA
the base register $10 at that address. ,NA,NA
QUESTION 13:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
The program below has the blanks filled. ,NA,NA
Shifting the Sign Bit,NA,NA
"To determine if ""A"" is negative, check if its sign bit is one. To do this, logically shift the sign ",NA,NA
"bit into bit position 0 of a register. The register will be zero if ""A"" is positive. ",NA,NA
## absVal.asm ,NA,NA
## ,NA,NA
## Calculate the absolute value of A,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
# Get A,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
" lw    $8,",NA,NA
0,NA,NA
($10)      #  Load A ,NA,NA
sll,NA,NA
"   $0,$0,0        #  no-op",NA,NA
# Is A negative?,NA,NA
" srl   $9,$8,_____       #  Shift sign bit to position 0 ",NA,NA
"beq   $___,$_____,done  #  sign bit == zero, done ",NA,NA
"sll   $0,$0,0",NA,NA
# Store -A,NA,NA
done: ,NA,NA
 .data ,NA,NA
A:    .word   -1,NA,NA
## End of file,NA,NA
The branch delay slot is filled with a no-op. ,NA,NA
QUESTION 14:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_14.html (1 of 2) [7/8/2545 18:49:48],NA
Fill the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_14.html (2 of 2) [7/8/2545 18:49:48],NA
A good answer might be: ,NA,NA
"The blanks are filled, below. ",NA,NA
Store -A,NA,NA
The sign bit is shifted right 31 bit positions. This puts it in the low-order bit of the destination ,NA,NA
"register ($9 in this case). To test if $9 is zero, use branch-on-equal with register $0 (which is ",NA,NA
always zero). ,NA,NA
## absVal.asm ,NA,NA
## ,NA,NA
## Calculate the absolute value of A,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
# Get A,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
" lw    $8,0($10)      #  Load A",NA,NA
" sll   $0,$0,0        #  no-op",NA,NA
# Is A negative?,NA,NA
" srl   $9,$8,",NA,NA
31,NA,NA
       #  Shift sign bit to position 0 ,NA,NA
beq   $,NA,NA
0,NA,NA
",$",NA,NA
9,NA,NA
",done     #  sign bit == zero, done sll   ",NA,NA
"$0,$0,0",NA,NA
# Store -A,NA,NA
" sub   $8,$___,$8     #  negate A",NA,NA
" sw    $8,___($___)   #  save it",NA,NA
"done:   sll   $0,$0,0",NA,NA
 .data ,NA,NA
A:    .word   -1,NA,NA
## End of file,NA,NA
"Now calculate -A and store it back into word ""A"". The instruction at ",NA,NA
done,NA,NA
 is a no-op. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_15.html (1 of 2) [7/8/2545 18:49:53],NA
QUESTION 15:,NA,NA
Fill the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_15.html (2 of 2) [7/8/2545 18:49:53],NA
A good answer might be: ,NA,NA
The complete program is given below ,NA,NA
Complete Program,NA,NA
"Here is the complete program, suitable for copying to a text file and running with SPIM. ",NA,NA
## absVal.asm ,NA,NA
## ,NA,NA
## Calculate the absolute value of A ,NA,NA
## ,NA,NA
## Registers: ,NA,NA
"##   $8  --- A, two's comp. integer ",NA,NA
##   $9  --- sign bit of A ,NA,NA
##   $10 --- base register for .data section,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
# Get A,NA,NA
" lui   $10,0x1000     #  Init base register",NA,NA
" lw    $8,0($10)      #  Load A",NA,NA
" sll   $0,$0,0",NA,NA
# Is A Negative?,NA,NA
" srl   $9,$8,31       #  Shift sign bit to position 0 ",NA,NA
"beq   $0,$9,done     #  sign bit == zero, done sll   ",NA,NA
"$0,$0,0",NA,NA
# Store -A,NA,NA
" sub   $8,$0,$8       #  negate A",NA,NA
" sw    $8,0($10)      #  save it",NA,NA
"done:   sll   $0,$0,0        #  target of the branch",NA,NA
 .data ,NA,NA
A:      .word   -1,NA,NA
## End of File,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_16.html (1 of 2) [8/8/2545 13:44:07],NA
QUESTION 16:,NA,NA
"Would the program work if ""A"" were unsigned binary? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_16.html (2 of 2) [8/8/2545 13:44:07],NA
A good answer might be: ,NA,NA
No. ,NA,NA
End of the Chapter,NA,NA
You have reached the end of this chapter. Click on a blue subject to go to where it was ,NA,NA
"discussed, unless you're absolutely sure you know it. To get back here, click on the ""back ",NA,NA
"arrow"" button of your browser. ",G,NA
The ,NA,NA
branch delay slot,NA,NA
 of MIPS. ,G,NA
How ,NA,NA
changing the PC,NA,NA
 implements a branch. ,G,NA
The ,NA,NA
jump instruction.,G,NA
The ,NA,NA
range of addresses,NA,NA
 to which a jump can go. ,G,NA
Symbolic addresses.,G,NA
The ,NA,NA
branch on equal,NA,NA
 instruction. ,G,NA
The ,NA,NA
branch on not equal,NA,NA
 instruction. ,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-17/ass17_17.html [8/8/2545 13:45:11],NA
CHAPTER 18 — Set Instructions,NA,NA
This chapter describes two additional branch instructions and two conditional ,NA,NA
set ,NA,NA
instructions. Set instructions set a register to 1 or 0 depending on whether a condition is true ,NA,NA
or false. ,NA,NA
Chapter Topics:,G,NA
More Conditional Branch Instructions (one operand register): ,NA,NA
bltz,NA,NA
 instruction (branch on less than zero) ,NA,NA
bgez,NA,NA
 instruction (branch on greater or equal to zero) ,G,NA
Conditional Set Instructions ,NA,NA
slt ,NA,NA
instruction (set on less than) ,NA,NA
sltu,NA,NA
 instruction (set on less than unsigned) ,NA,NA
These new instructions add convenience in implementing loops and branches within ,NA,NA
programs. ,NA,NA
QUESTION 1:,NA,NA
Are relational operators like   ,NA,NA
">, <, >=,",NA,NA
   and   ,NA,NA
<=,NA,NA
   useful in a programming ,NA,NA
language? ,NA,NA
A good answer might be: ,NA,NA
Of course. ,NA,NA
"Branch on Less than Zero, ",NA,NA
Branch on Greater than Zero ,NA,NA
MIPS has several ways to implement relational operators. Here are two more branch ,NA,NA
instructions. These instructions compare the contents of a register to zero. The register's ,NA,NA
contents is assumed to represent an integer with two's complement. ,NA,NA
"bltz   s,label        #  Branch if the two's comp. integer ",NA,NA
#  in register s is < 0,NA,NA
 #  There is a one instruction delay slot.,NA,NA
"bgez   s,label        #  Branch if the two's comp. integer ",NA,NA
#  in register s is >= 0,NA,NA
 #  There is a one instruction delay slot.,NA,NA
The first instruction branches if the integer is strictly less than zero. The other branches if ,NA,NA
the integer is greater than or equal to zero. ,NA,NA
Both of these instructions are followed by a branch delay slot. This means that the ,NA,NA
"instruction in that slot will always execute, and the branch (if it happens) will not happen ",NA,NA
until after that instruction executes. ,NA,NA
QUESTION 2:,NA,NA
Rewrite the following C (or Java) if-statement without using the not (the !). ,NA,NA
if ( !( a < 0 ) ) { ... },NA,NA
if ( a _____ 0  ) { ... },http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_2.html [7/8/2545 18:52:34],NA
A good answer might be: ,NA,NA
if ( !( a < 0 ) ) { ... } ,NA,NA
if ( a >= 0  ) { ... } ,NA,NA
The two operators   ,NA,NA
<,NA,NA
   and   ,NA,NA
>=,NA,NA
   cover all possible integer values. ,NA,NA
Set on Less Than,NA,NA
The ,NA,NA
set,NA,NA
" instructions are used to implement relational operators. However, they do not in ",NA,NA
themselves alter the flow of control. They set a register to 1 or 0 to show the relation ,NA,NA
between two values. The ,NA,NA
slt,NA,NA
 instruction is used with two's complement integers: ,NA,NA
 #  $s and $t contain   ,NA,NA
 #  two's comp. integers,NA,NA
 # ,NA,NA
"slt   d,s,t        #  if ( $s < $t )",NA,NA
 #    d <-- 1,NA,NA
 #  else,NA,NA
 #    d <-- 0,NA,NA
The ,NA,NA
sltu,NA,NA
 instruction is used with unsigned integers: ,NA,NA
 #  $s and $t contain   ,NA,NA
 #  unsigned integers,NA,NA
 # ,NA,NA
"sltu  d,s,t        #  if ( $s < $t )",NA,NA
 #    d <-- 1,NA,NA
 #  else,NA,NA
 #    d <-- 0,NA,NA
QUESTION 3:,NA,NA
Could these instructions be used with character data? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_3.html [7/8/2545 18:52:35],NA
A good answer might be: ,NA,NA
"Yes. If the characters to be compared are loaded in the low-order byte of two registers, ",NA,NA
"and the rest of the bits are zero, either instruction could be used. ",NA,NA
Set on Less Than Immediate,NA,NA
The other two set instructions compare an operand register with an immediate value in the ,NA,NA
instruction. There is a version for two's complement: ,NA,NA
 #  $s and imm contain   ,NA,NA
 #  two's comp. integers,NA,NA
 # ,NA,NA
"slti  d,s,imm      #  if ( $s < imm )",NA,NA
 #    d <-- 1,NA,NA
 #  else,NA,NA
 #    d <-- 0,NA,NA
And a version for unsigned integers: ,NA,NA
 #  $s and imm contain   ,NA,NA
 #  unsigned integers,NA,NA
 # ,NA,NA
"sltiu  d,s,imm     #  if ( $s < imm )",NA,NA
 #    d <-- 1,NA,NA
 #  else,NA,NA
 #    d <-- 0,NA,NA
"In both, the immediate field of the machine instruction is 16 bits wide. ",NA,NA
QUESTION 4:,NA,NA
How is the 16-bit immediate field extended to 32 bits for the comparison? By ,NA,NA
sign extention or by zero extension? ,G,NA
slti: ,G,NA
sltiu:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_4.html (1 of 2) [7/8/2545 18:52:47],NA
A good answer might be: ,G,NA
slti:,NA,NA
 by sign extension. ,G,NA
sltiu:,NA,NA
 by zero extension.,NA,NA
Temperature Range Tester ,NA,NA
Say that you are writing a control program for a robot spray painter. The allowed ,NA,NA
QUESTION 5:,NA,NA
Sketch a flow chart for this program. ,NA,NA
"range, register $3 is set to 1, otherwise to 0. ",NA,NA
temperature range for the paint is 30 degrees to 55 degrees Celsius. The driver ,NA,NA
program for the temperature sensor puts the temperature in register $2. Your ,NA,NA
program will test if the unsigned integer in register $2 is in range. If in ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_5.html [7/8/2545 18:53:21],NA
A good answer might be: ,NA,NA
With assembly language it is essential to make a plan before coding. ,NA,NA
Start on the Program,NA,NA
The flowchart for the program is at right. The trick of setting a flag to a default value in ,NA,NA
advance of the test is common. Here is an outline of the program: ,NA,NA
## tempRange.asm ,NA,NA
## ,NA,NA
## Check that   30 <= temp <= 55 ,NA,NA
"## Set flag to 1 if in range, to 0 if out of range ",NA,NA
## ,NA,NA
## Registers: ,NA,NA
## $2 --- temperature ,NA,NA
## $3 --- in/out range indicator flag ,NA,NA
## $8 --- scratch,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
# Set range indicator to 1 ,NA,NA
"main:   ori     $3,$0,1         #  set to 1",NA,NA
# Test  30 <= temp <= 55,NA,NA
" sltiu   $8,$2,_____     #  $8=1 if temp <= 55 ",NA,NA
"beq     $8,$_____,_____ #  0? out of range sll     ",NA,NA
"$0,$0,0         #  delay",NA,NA
 . . . .                  #  more instructions ,NA,NA
# Out of Range: set range indicator to 0 ,NA,NA
out:,NA,NA
 . . . .                  #  set to 0 ,NA,NA
"cont:  sll     $0,$0,0         #  target for the jump ",NA,NA
## End of file,NA,NA
The range test is in two parts. The first part (in this program) tests if temp is less than or ,NA,NA
"equal to 55. However, the machine instruction is ""set on less than"". If temp is out of range a ",NA,NA
branch is taken to ,NA,NA
out,NA,NA
. The branch is followed by a no-op for the branch delay. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_6.html (1 of 2) [7/8/2545 18:53:48],NA
QUESTION 6:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_6.html (2 of 2) [7/8/2545 18:53:48],NA
A good answer might be: ,NA,NA
See Below ,NA,NA
More Blanks ,NA,NA
"The immediate operand used in the set instruction is changed to 56 to implement ""less than ",NA,NA
"or equal"". Notice that the assembly language uses decimal numbers for temperatures. This ",NA,NA
is fine. The assembler translates the decimal representation of the source file into the ,NA,NA
correct bit pattern for the machine instruction. ,NA,NA
The next part of the program tests if ,NA,NA
temp,NA,NA
 is less than 30. Be careful with the branch ,NA,NA
instruction so that it branches for the correct condition. ,NA,NA
## tempRange.asm ,NA,NA
## ,NA,NA
## Check that   30 <= temp <= 55 ,NA,NA
"## Set flag to 1 if in range, to 0 if out of range ",NA,NA
## ,NA,NA
## Registers: ,NA,NA
## $2 --- temperature ,NA,NA
## $3 --- in/out range indicator flag ,NA,NA
## $8 --- scratch,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
# Set range indicator to 1 ,NA,NA
"main:   ori     $3,$0,1         #  set to 1",NA,NA
# Test  30 <= temp <= 55,NA,NA
" sltiu   $8,$2,",NA,NA
56,NA,NA
        #  $8=1 if temp <= 55 ,NA,NA
"beq     $8,",NA,NA
"$0,out",NA,NA
       #  0? out of range sll     ,NA,NA
"$0,$0,0         #  delay",NA,NA
" sltiu   $8,$2,_____     #  $8=1 if  temp < 30",NA,NA
" beq     $8,$0,_____     #  0? in range",NA,NA
" sll     $0,$0,0         #  delay",NA,NA
# Out of Range: set range indicator to 0,NA,NA
out:,NA,NA
" ori     $3,____,____    #  set to 0",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_7.html (1 of 2) [7/8/2545 18:53:55],NA
"cont:   sll     $0,$0,0         #  target for the jump",NA,NA
## End of file,NA,NA
QUESTION 7:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
The completed program follows. ,NA,NA
Complete Program,NA,NA
"Here is the complete program, suitable to copy to a file and to run with SPIM. When you run ",NA,NA
"it, set the PC to 0x400000 (as usual) and also use the set value menu to set R2 to a ",NA,NA
temperature. Run the program with different temperatures and check that $3 is set correctly. ,NA,NA
## tempRange.asm ,NA,NA
## ,NA,NA
## Check that   30 <= temp <= 55 ,NA,NA
"## Set flag to 1 if in range, to 0 if out of range ",NA,NA
##,NA,NA
## Registers: ,NA,NA
## $2 --- temperature ,NA,NA
## $3 --- in/out range indicator flag ,NA,NA
## $8 --- scratch,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
# Set range indicator to 1 ,NA,NA
"main:   ori     $3,$0,1         #  set to 1",NA,NA
# Test  30 <= temp <= 55,NA,NA
" sltiu   $8,$2,",NA,NA
56,NA,NA
        #  $8=1 if temp <= 55 ,NA,NA
"beq     $8,",NA,NA
"$0,out",NA,NA
       #  0? out of range sll     ,NA,NA
"$0,$0,0         #  delay",NA,NA
" sltiu   $8,$2,",NA,NA
30,NA,NA
        #  $8=1 if  temp < 30,NA,NA
" beq     $8,$0,",NA,NA
cont,NA,NA
      #  0? in range,NA,NA
" sll     $0,$0,0         #  delay",NA,NA
# Out of Range: set range indicator to 0 ,NA,NA
out:    ,NA,NA
"ori     $3,$0,0",NA,NA
         #  clear to 0,NA,NA
"cont:   sll     $0,$0,0         #  target for the jump ",NA,NA
## End of file,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_8.html (1 of 2) [7/8/2545 18:53:58],NA
QUESTION 8:,NA,NA
Could the no-op instructions ( the ,NA,NA
sll,NA,NA
) be removed without affecting the ,NA,NA
program? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_8.html (2 of 2) [7/8/2545 18:53:58],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Delay Slot Bug,NA,NA
The program can be made slightly shorter by removing the no-op instruction filling the ,NA,NA
first ,NA,NA
delay slot.,NA,NA
 The instruction following it (the ,NA,NA
sltiu,NA,NA
") will always execute, sometimes uselessly, ",NA,NA
but never will do damage. ,NA,NA
# Set range indicator to 1,NA,NA
" ori     $3,$0,1         #  set to 1",NA,NA
# Test  30 <= temp <= 55,NA,NA
" sltiu   $8,$2,56        #  $8=1 if temp <= 55",NA,NA
" beq     $8,$0,out       #  0? out of range ",NA,NA
"sll     $0,$0,0",NA,NA
         #  delay,NA,NA
" sltiu   $8,$2,30        #  $8=1 if  temp < 30",NA,NA
" beq     $8,$0,cont      #  0? in range ",NA,NA
"sll     $0,$0,0",NA,NA
         #  delay,NA,NA
# Out of Range: set range indicator to 0 ,NA,NA
out:,NA,NA
" ori     $3,$0,0         #  clear to 0",NA,NA
"cont:   sll     $0,$0,0         #  target for the jump ",NA,NA
## End of file,NA,NA
The ,NA,NA
second no-op,NA,NA
", however, is essential. If it is missing, the next instruction, the ",NA,NA
ori,NA,NA
 sets the ,NA,NA
"flag to zero regardless of the branch instruction. This is a common bug, and can be very ",NA,NA
frustrating because ,NA,NA
sometimes,NA,NA
 the result is correct. ,NA,NA
QUESTION 9:,NA,NA
(Review:) What other type of instruction is followed by a delay slot? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_9.html [7/8/2545 18:54:19],NA
A good answer might be: ,NA,NA
Load instructions. ,NA,NA
Counting Loop,NA,NA
A common program loop is controlled by an integer that counts up ,NA,NA
from a initial value to an upper limit. Such a loop is called a ,NA,NA
counting loop,NA,NA
. The integer is called a ,NA,NA
loop control variable,NA,NA
. Loops ,NA,NA
"are implemented with the conditional branch, jump, and conditional ",NA,NA
set instructions. ,NA,NA
A loop has three parts that must be correct: ,NA,NA
1.  The counter must be initialized.,NA,NA
2.  The test must end the loop on the correct count. ,NA,NA
3.  The counter must be increased.,NA,NA
It is easy to get these wrong in a high-level programming language. ,NA,NA
It is remarkably easy to get them wrong in assembly language. ,NA,NA
Usually you want a ,NA,NA
top-driven,NA,NA
" loop such as the one at right, where ",NA,NA
the test is performed at the top before control enters the loop body. ,NA,NA
"Be clear about the loop you want before you program it, because ",NA,NA
assembly language allows any sort of weird loop. ,NA,NA
QUESTION 10:,NA,NA
Is the following loop (in C) correct in all three parts? It is intended to execute ,NA,NA
10 times starting at zero. ,NA,NA
int j;,NA,NA
j = 0; ,NA,NA
while ( j < 10 ) ,NA,NA
{,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_10.html (1 of 2) [7/8/2545 18:54:24],NA
},NA,NA
 . . .,NA,NA
 j++ ;,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_10.html (2 of 2) [7/8/2545 18:54:24],NA
int j;,NA,NA
j = 0; ,NA,NA
while ( j < 10 ) ,NA,NA
{,NA,NA
 . . .,NA,NA
},NA,NA
 j++ ;,NA,NA
A good answer might be: ,NA,NA
"The loop is correct. (Although j changes to 10 at the bottom of the last iteration, this is ",NA,NA
the normal way for loops to work). ,NA,NA
Assembly Language Loop,NA,NA
"Here is an assembly version of the counting loop, without the branch ",NA,NA
delay slots filled: ,NA,NA
# ,NA,NA
#  branch delay slots not filled ,NA,NA
# ,NA,NA
"init:   ori    $8,$0,0        # count = 0 ",NA,NA
"test:   sltiu  $9,$8,10       # count < 10",NA,NA
" beq    $9,$0,endLp",NA,NA
 . . .                 # do stuff,NA,NA
" addiu  $8,$8,1        # count++ ;",NA,NA
 j      test ,NA,NA
"endLp:  sll    $0,$0,0        # branch target",NA,NA
QUESTION 11:,NA,NA
Find and fill in the branch delay slots. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_11.html (2 of 2) [7/8/2545 18:54:38],NA
A good answer might be: ,NA,NA
See Below. ,NA,NA
Complete Loop,NA,NA
Here is the loop with the branch delay slots filled. One could be clever and eliminate the last ,NA,NA
"no-op, but let's not. ",NA,NA
# ,NA,NA
#  branch delay slots  filled ,NA,NA
# ,NA,NA
init: ,NA,NA
" ori    $8,$0,0        # count = 0",NA,NA
"test:   sltiu  $9,$8,10       # count < 10",NA,NA
" beq    $9,$0,endLp    # end loop if count >= 10 ",NA,NA
"sll    $0,$0,0        # delay",NA,NA
 # do stuff,NA,NA
" addiu  $8,$8,1        # count++ ;",NA,NA
 j      test ,NA,NA
"sll    $0,$0,0        # delay",NA,NA
"endLp:  sll    $0,$0,0        # branch target",NA,NA
The no-op at ,NA,NA
endLp,NA,NA
 is not filling a branch delay slot. It is there for convenience in running ,NA,NA
the program with SPIM. ,NA,NA
"With a few assembly language directives, the code is ready to run. Step through the code ",NA,NA
and watch $8 (count) increase from 0 to 0xA. ,NA,NA
QUESTION 12:,NA,NA
Examine the program. How could you modify it to compute the sum of the ,NA,NA
integers 0 through 9? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_12.html [7/8/2545 18:54:43],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Summing Program,NA,NA
The loop is already correct for the problem. Don't change it. Computing the sum is done by ,NA,NA
adding just two statements: ,NA,NA
## ,NA,NA
##  Sum of integers 0 .. 9 ,NA,NA
## ,NA,NA
## Registers: ,NA,NA
##  $8  --- loop control ,NA,NA
##  $9  --- scratch ,NA,NA
## $10  --- sum,NA,NA
init:   ,NA,NA
"ori    $10,$0,0       # sum = 0",NA,NA
" ori    $8,$0,0        # count = 0 ",NA,NA
"test:   sltiu  $9,$8,10       # count < 10",NA,NA
" beq    $9,$0,endLp    # end loop if count >= 10",NA,NA
" sll    $0,$0,0        # delay",NA,NA
"addu   $10,$10,$8     # sum += count",NA,NA
" addiu  $8,$8,1        # count++ ;",NA,NA
 j      test,NA,NA
" sll    $0,$0,0        # delay",NA,NA
"endLp:  sll    $0,$0,0        # jump target",NA,NA
QUESTION 13:,NA,NA
Of all the ,NA,NA
sll,NA,NA
"s in the program, which one is the most dangerous to remove? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_13.html [7/8/2545 18:54:47],NA
A good answer might be: ,NA,NA
The first one. ,NA,NA
End of Chapter ,NA,NA
You have reached the end of this chapter. Click on a blue subject to go to where it was ,NA,NA
"discussed, To get back here, click on the ""back arrow"" button of your browser. ",G,NA
The ,NA,NA
bltz and bgez,NA,NA
 instructions. ,G,NA
The ,NA,NA
slt and sltu,NA,NA
 instructions. ,G,NA
The ,NA,NA
stli and sltiu,NA,NA
 instructions. ,G,NA
Counting loops.,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-18/ass18_14.html [7/8/2545 18:54:54],NA
CHAPTER 19 — Structured Programming,NA,NA
This chapter discusses two topics of universal interest in computer science: What machine ,NA,NA
"instructions are needed in a processor, and How to build programs that work. The SPIM ",NA,NA
instructions you have looked at so far are more than enough for a processor. The ,NA,NA
structured ,NA,NA
programming,NA,NA
 approach is used to build reliable programs. ,NA,NA
Chapter Topics:,G,NA
Computing power.,G,NA
The minimum set of machine instructions.,G,NA
Throughput ,G,NA
Complex instructions sets vs. Reduced instruction sets. ,G,NA
Structured programming.,G,NA
The minimum set of control structures.,NA,NA
"Much of the chapter is about the following question, which, oddly, often remains ",NA,NA
unanswered in introductory courses. ,NA,NA
QUESTION 1:,NA,NA
"Are Java, C, and C++ structured languages? ",NA,NA
A good answer might be: ,NA,NA
"Yes, all modern high level programming languages are structured because they include ",NA,NA
if-then-else,NA,NA
 and ,NA,NA
while,NA,NA
 structures (and other structures). ,NA,NA
Computing Power,NA,NA
"So far, these chapters have covered several kinds of instructions: ",G,NA
Bit-wise logic instructions.,G,NA
Integer arithmetic instructions.,G,NA
Memory access instructions.,G,NA
Instructions that conditionally alter the program flow.,NA,NA
You might wonder how many instructions a processor must have in order to be as powerful ,NA,NA
as another. The answer is: the above set of instructions is more than enough. But the idea ,NA,NA
"of computer ""power"" is somewhat vague. Sometimes it means ""speed"" and sometimes it ",NA,NA
"means ""what can be computed"" and usually it means a fuzzy combination of both. Let us ",NA,NA
use the following definition: ,NA,NA
Computing Power:,NA,NA
 Two processors have the same computing power if they ,NA,NA
can run the same programs (after translation into each processor's machine ,NA,NA
language) and produce the same results ,NA,NA
"For example, say that two processors have the same power. Then if one processor can run ",NA,NA
"a particular program, then the other one must be able to run it, and both processors must ",NA,NA
produce the same result. This must be true for all programs (after appropriate compilation ,NA,NA
into native machine language). ,NA,NA
"Sometimes the result a program produces depends on the compiler. For example, different ",NA,NA
"compilers for ""C"" use different number of bits for the data type ",NA,NA
int,NA,NA
. But that is an effect of the ,NA,NA
"compiler, not of the processor. All that matters for processor ""power"" is that it is possible to ",NA,NA
translate identical programs into machine language appropriate for each processor and that ,NA,NA
these machine language programs produce the same result on each processor. ,NA,NA
Processor speed is left out of the definition. It is helpful to regard computing power and ,NA,NA
processor speed as separate aspects. Memory and peripherals (such as graphics boards) ,NA,NA
are also left out. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_2.html (1 of 2) [8/8/2545 10:52:29],NA
QUESTION 2:,NA,NA
Can a program that uses 64-bit integers run on a processor that has 32-bit ,NA,NA
words? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_2.html (2 of 2) [8/8/2545 10:52:29],NA
A good answer might be:,NA,NA
Yes. Integers of any size can be used on a processor no matter what the word size. This ,NA,NA
is done by using both the integer arithmetic instructions of the processor (if any) and bit ,NA,NA
manipulation instructions. ,NA,NA
Equal Power Processors,NA,NA
For example: 16-bit Intel microprocessors could run programs that used 64-bit integer ,NA,NA
arithmetic. This was done by compiling 64-bit operations into several 16-bit machine ,NA,NA
operations. ,NA,NA
As a more modern example: Pentium-1 and Pentium-4 processors can run the same ,NA,NA
programs. One (the P-4) has a faster machine cycle than the other. And one (the P-4) has ,NA,NA
"more machine instructions than the other. If you had a C program that computed something, ",NA,NA
"both processors could run it, and whatever it computed would come out the same on both ",NA,NA
(assuming appropriate settings of the compilers). The run time would be far longer on the P-,NA,NA
"1 than on the P-4, but run time is not part of the definition. ",NA,NA
QUESTION 3:,NA,NA
In 1952 the SWAC digital computer was programmed to find perfect ,NA,NA
numbers (integer numbers whose integer divisors sum up to the number). ,NA,NA
After hours of computation it found the perfect number 2281). ,NA,NA
Will a modern Pentium processor find the same perfect numbers as the SWAC? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_3.html [8/8/2545 10:52:41],NA
A good answer might be: ,NA,NA
Of course. My 1.7 GHz processor finds 2281 almost immediately. ,NA,NA
Minimum Instruction Set,NA,NA
"But, in the definition of processor power, my very fast processor is no more powerful than ",NA,NA
the SWAC. ,NA,NA
"Processors must control their peripheral devices, and send and receive information from ",NA,NA
"them. They do this by writing and reading bit patterns on the system bus, and by reading ",NA,NA
and writing pre-assigned memory addresses. So a processor that can read and write ,NA,NA
"memory can also control hard disks and graphics boards. Special ""multimedia"" instructions ",NA,NA
"do not add extra power. Of course, they do add some convenience. ",NA,NA
What machine instructions must a processor absolutely have? ,NA,NA
Important Fact:,NA,NA
 All processors that support the fundamental machine ,NA,NA
"instructions of bit manipulation, conditional branching, and memory access ",NA,NA
have the same computing power. All processors have these instructions (and ,NA,NA
more). All processors are equivalent in computing power (in the sense of the ,NA,NA
previous definition). ,NA,NA
"Arithmetic (both integer and floating point) can be done with bit manipulation instruction, so ",NA,NA
arithmetic instructions are not fundamental (but are almost always included in a processor). ,NA,NA
Above a certain minimum set of instructions adding new instructions does not add to the ,NA,NA
"computing power of a processor. (To learn more about this topic, take a course in ",NA,NA
Foundations of Computation,NA,NA
 or in ,NA,NA
Mathematical Logic,NA,NA
). ,NA,NA
QUESTION 4:,NA,NA
(Thought question:) Why do most processors have many more instructions ,NA,NA
than the minimum set needed for full computing power? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_4.html [8/8/2545 10:53:00],NA
A good answer might be: ,NA,NA
For convenience and throughput. ,NA,NA
Convenience and Throughput,NA,NA
Convenience is important. You likely have been frustrated trying to find the right MIPS ,NA,NA
instructions to use in your programs. Sometimes it feels like fitting square pegs into round ,NA,NA
"holes. How much more convenient to have a wide selection of pegs, even if they don't add ",NA,NA
computing power! ,NA,NA
Convenience is not just or human programmers. Compilers and other systems software ,NA,NA
"create machine programs out of machine instructions. They are easier to write, and less ",NA,NA
buggy when there is a rich set of instructions. ,NA,NA
Throughput,NA,NA
 is how much computing a processor (or full computer system) can perform in a ,NA,NA
unit of time. Say that a processor can perform 50 million instructions in one second. The ,NA,NA
"more computing each instruction does, the greater the throughput. So most processors have ",NA,NA
instructions that do much more than the bare minimum. ,NA,NA
QUESTION 5:,NA,NA
Which of the following improvements increase the throughput of a computer ,NA,NA
system? ,G,NA
Faster machine cycle (500 MHz to 1000 MHz).,G,NA
More bits on the system bus (32 bits to 64 bits).,G,NA
More main memory (128 Meg to 512 Meg).,G,NA
Larger hard disk (20 Gig to 40 Gig).,G,NA
Faster data transfer rate of hard disk (40 MBps to 80 MBps). ,G,NA
"Bigger monitor (17"" to 21"").",G,NA
"Many, big, complex machine instructions.",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_5.html [8/8/2545 10:53:02],NA
A good answer might be:,G,NA
Faster machine cycle (500 MHz to 1000 MHz). ,H,NA
Yes. More instructions done per second.,G,NA
More bits on the system bus (32 bits to 64 bits). ,H,NA
Yes. More data moved per transfer operation.,G,NA
More main memory (128 Meg to 512 Meg). ,H,NA
Yes. Data can be kept in fast main memory rather than slow disk ,NA,NA
memory.,G,NA
Larger hard disk (20 Gig to 40 Gig). ,H,NA
"No,",NA,NA
 assuming that all data and software fit on the smaller size. ,G,NA
Faster data transfer rate of hard disk (40 MBps to 80 MBps). ,H,NA
Yes. Processor spends less time waiting for data.,G,NA
"Bigger monitor (17"" to 21""). ",H,NA
No. ,G,NA
"Many, complex machine instructions. ",H,NA
"Maybe, maybe not.",NA,NA
CISC vs RISC,NA,NA
A ,NA,NA
CISC,NA,NA
" (Complex Instruction Set Computer) processor has many instructions, some of them ",NA,NA
complex instructions that do a lot per machine cycle. The Intel processors are CISC. A ,NA,NA
RISC,NA,NA
 ,NA,NA
"(Reduced Instruction Set Computer) processor has few instructions, most of them simple. It ",NA,NA
may take several instructions to do the equivalent of a CISC instruction. The MIPS ,NA,NA
processors are RISC. ,NA,NA
"If everything else were the same, CISC would have greater throughput. A larger silicon chip ",NA,NA
is needed for the many complex instructions. Data must be moved through greater ,NA,NA
"distances, and that takes more time. This slows down the clock cycle. The instructions ",NA,NA
themselves take more time to execute (usually more than several RISC instructions). Fine ,NA,NA
tuning the chip for speed is difficult when there are many instruction types. The simple ,NA,NA
instructions are compromised by the complex ones. But the simple instructions are the most ,NA,NA
frequently executed! ,NA,NA
"Worse, it is hard for a compiler to make use of complex instructions. They frequently compile ",NA,NA
programs into machine programs that use only simple instructions. The MMX (multi-media ,NA,NA
extension) instructions added to recent Pentium chips are not used by any compiler. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_6.html (1 of 2) [8/8/2545 10:53:14],NA
"The idea of RISC is that it is better to have a small, sleek, fast instruction set than to have a ",NA,NA
"big collection of poorly coordinated, ungainly, complex instructions. ",NA,NA
For the last decade or so RISC chips have been ahead of CISC chips. But a modern CISC ,NA,NA
chip has greater throughput than an older RISC chip. Consumer and office computers use ,NA,NA
CISC chips to be compatible with existing Windows software. High-end workstations and ,NA,NA
recently designed systems (such as embedded systems) typically use RISC. ,NA,NA
QUESTION 6:,NA,NA
Recall the fable of ,NA,NA
The Tortise and the Hare,NA,NA
. Which processor chip is the ,NA,NA
tortise? Which is the hare? ,NA,NA
A good answer might be: ,NA,NA
Which processor chip is the tortise? ,NA,NA
CISC,NA,NA
. Which is the hare? ,NA,NA
RISC,NA,NA
. Right now the hare ,NA,NA
is ahead. ,NA,NA
Bug-free Software,NA,NA
Examine (for a moment) the following program excerpt. (Trick question:) Is it correct? ,NA,NA
"start:   ori   $8,$0,4      # $8 = 4",NA,NA
" ori   $9,$0,12     # $9 = 12",NA,NA
" addu  $10,$8,$9    # $10 = 12+4 = 16 ",NA,NA
"sll   $10,$10,2    # $10 = 16*4 = 64",NA,NA
"Ordinarily, you would say ""yes"", assuming that the comments are correct. But this assumes ",NA,NA
that execution starts at ,NA,NA
start,NA,NA
. What if execution started at the ,NA,NA
addu,NA,NA
 instruction? Registers $8 ,NA,NA
and $9 would probably contain different numbers. That could happen if the following were ,NA,NA
somewhere in the program: ,NA,NA
 ori ,NA,NA
 ,NA,NA
 ,NA,NA
"$8,$0,99 ",NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
# ,NA,NA
$8 ,NA,NA
= ,NA,NA
99,NA,NA
 ori ,NA,NA
 ,NA,NA
 ,NA,NA
"$9,$0,43 ",NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
# ,NA,NA
$9 ,NA,NA
= ,NA,NA
43,NA,NA
 j     start+8      # jump to the second statement after start,NA,NA
start,NA,NA
 is a symbolic address that stands for the first instruction's run time address. ,NA,NA
start+8 ,NA,NA
stands for the address 8 bytes away. The jump instruction transfers control to that address. ,NA,NA
QUESTION 7:,NA,NA
Is there a way to ,NA,NA
prevent,NA,NA
 distant statements from jumping into the middle of ,NA,NA
a block? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_7.html [8/8/2545 10:53:48],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Bug-free Blocks,NA,NA
Bugs can happen when control jumps into the middle of a block of ,NA,NA
"code. If the block was written to execute from start to finish, the ",NA,NA
starting statements need to execute. ,NA,NA
"Don't jump into blocks,",NA,NA
 or bugs ,NA,NA
will happen. ,NA,NA
This is one of the ideas of ,NA,NA
structured programming,NA,NA
. A block of ,NA,NA
code is a list of instructions that has one ,NA,NA
entry point,NA,NA
 (where ,NA,NA
execution starts) and one ,NA,NA
exit point,NA,NA
 (where execution leaves the ,NA,NA
block). The entry point has well defined ,NA,NA
entry conditions,NA,NA
. The exit ,NA,NA
point has well defined ,NA,NA
exit conditions,NA,NA
. ,NA,NA
"For the block to execute correctly, execution must start at the entry point, and the entry ",NA,NA
"conditions must be met. When execution leaves the block, the exit conditions are true (if the ",NA,NA
block itself is bug free). ,NA,NA
QUESTION 8:,NA,NA
What if the block is ,NA,NA
not,NA,NA
 bug free? Where will you find the bug? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_8.html [8/8/2545 10:54:02],NA
A good answer might be: ,NA,NA
In the block. ,NA,NA
Structure Rule One: Code Block,NA,NA
"If the entry conditions are correct, but the exit conditions are wrong, the ",NA,NA
bug must be in the block. This is not true if execution is allowed to jump ,NA,NA
into a block. The bug might be anywhere in the program. Debugging ,NA,NA
under these conditions is much harder. ,NA,NA
Rule 1 of Structured Programming:,NA,NA
 A code block is structured. ,NA,NA
"In flow charting terms, a box with a single entry point and single ",NA,NA
exit point is structured. ,NA,NA
"This may look obvious, but that is the idea. Structured programming is ",NA,NA
a means of making it clear if a program is correct. ,NA,NA
In assembly language there is no syntax for showing program blocks. You think about them ,NA,NA
"when you design the program, and when you draw a flowchart. But in coding you just follow ",NA,NA
your design. ,NA,NA
QUESTION 9:,NA,NA
How is a code block implemented in assembly language? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_9.html [8/8/2545 10:54:04],NA
A good answer might be: ,NA,NA
By writing statements intended to execute ins sequence and not jumping into the middle ,NA,NA
of them. ,NA,NA
Implementing Rule One,NA,NA
Statements automatically execute in sequence. There is no language support for enforcing ,NA,NA
the single entry/single exit idea. A programmer must consciously follow the rule. ,NA,NA
It might look as though the rule could be followed by only jumping to labeled statements. But ,NA,NA
"a statement in the middle of an intended block can have a label, as in the following: ",NA,NA
"start:   ori   $8,$0,4      # $8 = 4",NA,NA
" ori   $9,$0,12     # $9 = 12 ",NA,NA
"midblk:  addu  $10,$8,$9    # $10 = 12+4 = 16",NA,NA
" sll   $10,$10,2    # $10 = 16*4 = 64",NA,NA
 ....,NA,NA
 ori ,NA,NA
 ,NA,NA
 ,NA,NA
"$8,$0,99 ",NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
# ,NA,NA
$8 ,NA,NA
= ,NA,NA
99,NA,NA
 ori ,NA,NA
 ,NA,NA
 ,NA,NA
"$9,$0,43 ",NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
 ,NA,NA
# ,NA,NA
$9 ,NA,NA
= ,NA,NA
43,NA,NA
 j     midblk       # jump to the second statement after start,NA,NA
QUESTION 10:,NA,NA
"Is there a syntax for defining code blocks in high-level languages like Pascal, ",NA,NA
"C, or Java? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_10.html [8/8/2545 10:54:11],NA
"Is there a syntax for defining code blocks in high-level languages like Pascal, C, or Java? ",NA,NA
A good answer might be: ,NA,NA
Yes: in Pascal ,NA,NA
begin end,NA,NA
 delimit a block. In C and Java ,NA,NA
 { } ,NA,NA
 delimit a ,NA,NA
block. ,NA,NA
Sequence ,NA,NA
"Pascal, C, and Java are structured languages. A block ",NA,NA
of statements in those languages has one entry point ,NA,NA
and one exit point. ,NA,NA
What about two blocks in a row? Say that the exit ,NA,NA
conditions of block 1 are the correct entry conditions ,NA,NA
for block 2. Then the two blocks can follow in ,NA,NA
sequence. ,NA,NA
The set of two blocks can be regarded as a one big ,NA,NA
"block. If the entry conditions for block 1 are correct, ",NA,NA
"then the exit conditions for block 1 are correct, then ",NA,NA
"the entry conditions for block 2 are correct, then ",NA,NA
(finally) the exit condtions for block 2 are correct. ,NA,NA
QUESTION 11:,NA,NA
Look at the big block (in dotted lines). If the big block entry conditions are ,NA,NA
"correct, what do you know about the big block exit conditions? ",NA,NA
A good answer might be: ,NA,NA
"If the big block entry conditions are correct, then the big block exit conditions are correct. ",NA,NA
Structure Rule Two: Sequence,NA,NA
Any sequence of blocks is correct if the exit and entry conditions ,NA,NA
"match up. Execution enters each block at the block's entry point, ",NA,NA
and leaves through the block's exit point. The whole sequence can ,NA,NA
"be regarded as a single block, with an entry point and an exit ",NA,NA
point. ,NA,NA
Rule 2 of Structured Programming:,NA,NA
 Two or more code ,NA,NA
blocks in sequence are structured. ,NA,NA
The assembly language implementation of this rule is the same ,NA,NA
as rule one: a programmer must consciously follow the rule. This ,NA,NA
means that there must be no jumps elsewhere in the code to ,NA,NA
points inside the blocks. ,NA,NA
QUESTION 12:,NA,NA
Are ,NA,NA
if-then-else,NA,NA
 structures possible in assembly language? ,NA,NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Structure Rule Three: Alternation,NA,NA
If-then-else,NA,NA
 is sometimes called ,NA,NA
alternation,NA,NA
 (because there are alternative ,NA,NA
"choices). In structured programming, ",NA,NA
each choice is a code block. If alternation is ,NA,NA
"arranged as in the flowchart at right, then ",NA,NA
there is one entry point (at the top) and one ,NA,NA
exit point (at the bottom). The structure ,NA,NA
should be coded so that if the entry ,NA,NA
"conditions are satsified, then the exit ",NA,NA
conditions are fulfilled (just like a code ,NA,NA
block). ,NA,NA
Rule 3 of Structured ,NA,NA
Programming:,NA,NA
 The alternation of ,NA,NA
two code blocks is structured. ,NA,NA
An example of an entry condition for an ,NA,NA
alternation structure is: ,NA,NA
register $8 ,NA,NA
contains a signed integer,NA,NA
. The exit ,NA,NA
condition might be: ,NA,NA
register $8 contains ,NA,NA
the absolute value of the signed integer,NA,NA
. ,NA,NA
The branch structure is used to fulfill the ,NA,NA
exit condition. ,NA,NA
QUESTION 13:,NA,NA
Can the condition tested for the alternation be complicated? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_13.html [8/8/2545 10:55:09],NA
A good answer might be: ,NA,NA
Sure. It might involve many assembly statements ,NA,NA
Implementing Alternation,NA,NA
There is no explicit support for alternation in assembly language. The programmer must do ,NA,NA
"it in pieces, as in the following: ",NA,NA
 ...                #   ,NA,NA
" beq  $8,$9,else    # branch if equal",NA,NA
 nop                # branch delay slot,NA,NA
 ...                #  ,NA,NA
 ...                #   false branch,NA,NA
 ...                #  ,NA,NA
 j    cont,NA,NA
 nop ,NA,NA
else:   ...                #,NA,NA
 ...                #   true branch,NA,NA
 ...                # ,NA,NA
"endif:  add   $10,$10,$11  # always executed",NA,NA
"This is just an example, not the only way alternation is done. The true branch can come ",NA,NA
"first, if that is more convenient. Conceptually, the branch chosen depends on the outcome ",NA,NA
"of a true/false condition. In implementation, the condition might involve several branch and ",NA,NA
other instructions. ,NA,NA
QUESTION 14:,NA,NA
Is an ,NA,NA
if-endif,NA,NA
 (single alternative) structure structured? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_14.html [8/8/2545 10:55:11],NA
A good answer might be: ,NA,NA
Yes. It is regarded as if-then-else with an empty else-branch. ,NA,NA
Structure Rule Four: Iteration,NA,NA
If ,NA,NA
iteration,NA,NA
 (,NA,NA
while-loop,NA,NA
") is arranged as at right, ",NA,NA
it also has one entry point and one exit point. ,NA,NA
"With careful coding, the entry point has ",NA,NA
conditions that must be satisfied and the exit ,NA,NA
point has conditions that will be fulfilled. There ,NA,NA
are no jumps into the structure from external ,NA,NA
points of the code. ,NA,NA
Rule 4 of Structured Programming: ,NA,NA
The iteration of a code block is ,NA,NA
structured. ,NA,NA
"As with the other structures, an iteration ",NA,NA
structure must be built out of assembly ,NA,NA
language pieces. There are various ways to ,NA,NA
implement iteration. The following is typical ,NA,NA
"while:  bltz   $8,endWh",NA,NA
 . . .,NA,NA
 j      while,NA,NA
" sll    $0,$0,0",NA,NA
"endWh:  sll    $0,$0,0",NA,NA
The particular instructions that make up the test depend on circumstances. ,NA,NA
QUESTION 15:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_15.html (1 of 2) [8/8/2545 10:55:24],NA
"In a structured language (such as Pascal, C, or Java) can an alternation ",NA,NA
structure be put inside an iterations structure? (can the body of a while-loop ,NA,NA
contain an if-then-else?) ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_15.html (2 of 2) [8/8/2545 10:55:24],NA
A good answer might be: ,NA,NA
Of course ,NA,NA
Looks like a Code Block,NA,NA
In all of the structures so far: there has been an entry point at the top and an exit point at the ,NA,NA
bottom. There are no jumps into or out of the structure. The entry point has entry conditions that ,NA,NA
"are expected to be satisfied for the code to work, and exit conditions that are fulfilled if they are. ",NA,NA
Each of the structures can be considered to be a code block. ,NA,NA
"It is OK for a structure to have jumps within it (in assembly language, this is how some structures ",NA,NA
"are implemented). From outside each of the above structures, the structure looks like a code ",NA,NA
block. ,NA,NA
QUESTION 16:,NA,NA
Could a code block acting as a loop body be replaced by an alternation structure? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_16.html [8/8/2545 10:55:34],NA
A good answer might be: ,NA,NA
Yes ,NA,NA
Structure Rule Five: Nesting Structures,NA,NA
"In flowcharting terms, where ever there is a code block, it can be expanded into any of the ",NA,NA
"structures. Or, going the other direction, if there is a portion of the flowchart that has a single ",NA,NA
"entry point and a single exit point, it can be summarized as a single code block. ",NA,NA
Rule 5 of Structured Programming:,NA,NA
 A structure (of any size) that has a single ,NA,NA
entry point and a single exit point is equivalent to a code block. ,NA,NA
"For example, say that you are designing a program to go through a list of signed integers ",NA,NA
calculating the absolute value of each one. You might (1) first regard the program as one ,NA,NA
"block, then (2) sketch in the iteration required, and finally (3) put in the details of the loop ",NA,NA
body. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_17.html (1 of 2) [8/8/2545 10:55:56],NA
"Or, you might go the other way. Once the absolute value code is working, you can regard it ",NA,NA
as a single code block to be used as a component of a larger program. ,NA,NA
QUESTION 17:,NA,NA
(Thought question:) Would it be a good idea to implement a complicated ,NA,NA
code block as a subroutine (as a function)? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_17.html (2 of 2) [8/8/2545 10:55:56],NA
A good answer might be: ,NA,NA
Yes. We will do this in a later chapter. ,NA,NA
Computational Power of Structured ,NA,NA
Programming,NA,NA
"You might think that these rules are OK for ensuring stable code, but that they are too ",NA,NA
restrictive. Something must be lost. But nothing is lost. Böhm and Jacopini proved that any ,NA,NA
program can be written in a structured style. No computing power is lost by restricting ,NA,NA
control flow to the forms of structured programming. ,NA,NA
"The other control structures you know from other languages, such as case statements, ",NA,NA
do-,NA,NA
until,NA,NA
", ",NA,NA
do-while,NA,NA
", and ",NA,NA
for,NA,NA
 are not needed. They are sometimes convenient. They are usually ,NA,NA
included as part of structured programming. In assembly language they add little ,NA,NA
convenience (since you have to implement them yourself). I recommend using only the ,NA,NA
structures listed in this chapter. ,NA,NA
Any program you need to write in assembly can be written in a structured style. You should ,NA,NA
think about a problem and the means of solving it in exactly the way you would using a high-,NA,NA
"level, structured language. Once you have the solution designed, the implementation ",NA,NA
"becomes mere ""coding"". Coding is the near-mechanical translation of a design into code. ",NA,NA
"Solution design and coding should not occur simultaneously (in an ideal world, where all ",NA,NA
"projects are on time, and dot-coms never fail). ",NA,NA
QUESTION 18:,NA,NA
(Thought question:) Can a structured assembly program sometimes be ,NA,NA
speeded up by using non-structured control? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_18.html [8/8/2545 10:56:02],NA
A good answer might be: ,NA,NA
"Yes. But you should write the structured version first. Keep it around, so that when the ",NA,NA
speedy version turns out to be buggy you have something that works. ,NA,NA
End of Chapter,NA,NA
"You have reached the end of this chapter. Click on a blue subject to make a smooth, ",NA,NA
"structured transition to where it was discussed. To return here, click on the ""back arrow"" ",NA,NA
button of your browser. ,G,NA
The ,NA,NA
computing power,NA,NA
 of a processor. ,G,NA
The ,NA,NA
minimum set,NA,NA
 of instructions needed for full computing power. ,G,NA
The ,NA,NA
throughput,NA,NA
 of a computer. ,G,NA
CISC and RISC ,G,NA
Rule 1,NA,NA
 of structured programming ,G,NA
Rule 2,NA,NA
 of structured programming ,G,NA
Rule 3,NA,NA
 of structured programming ,G,NA
Rule 4,NA,NA
 of structured programming ,G,NA
Rule 5,NA,NA
 of structured programming ,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-19/ass19_19.html [8/8/2545 10:56:14],NA
CHAPTER 20 — Loop and Branch ,NA,NA
Examples,NA,NA
This chapter contains two example programs that illustrate loops and branches. It also ,NA,NA
discusses how character strings and integer arrays are represented in assembly language. ,NA,NA
Chapter Topics:,G,NA
Null terminated character strings. ,G,NA
String length program. ,G,NA
Integer arrays.,G,NA
Array summing program.,NA,NA
QUESTION 1:,NA,NA
A character ,NA,NA
string,NA,NA
 is a sequence of bytes containing ascii patterns. What is at ,NA,NA
the end of a ,NA,NA
null-terminated,NA,NA
 string? ,NA,NA
What is at the end of a ,NA,NA
null-terminated,NA,NA
 string? ,NA,NA
A good answer might be: ,NA,NA
A zero byte (also called a null byte). ,NA,NA
Null-terminated String,NA,NA
"A null terminated string is a sequence of ASCII characters, one to a byte, with the last byte zero (null). ",NA,NA
"Null terminated strings are common in C and C++. In the following picture, the blank bytes are filled ",NA,NA
"with ASCII space ( 0x20). The last byte is filled with 0x00, represented with a slash. ",NA,NA
Here is how this string is declared in assembly language: ,".data 
  
 str:    .asciiz ""Time is the ghost of space.""",NA
Here is what it looks like in the data display of SPIM running on a Windows PC. The bytes are in ,NA,NA
ascending sequence beginning with 'I' (at address 0x10000000). However the display is aimed at ,NA,NA
displaying 32-bit little-endian integers. Every group of four bytes is displayed from right to left. The 'e' ,NA,NA
"is at address 0x10000003. Space is 0x20, shown in red as '_'. The null byte is at address ",NA,NA
0x1000001B ,NA,NA
QUESTION 2:,NA,NA
Why (do you suppose) null was picked as the byte to put at the end of a string? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_2.html [8/8/2545 9:22:12],NA
A good answer might be:,NA,NA
Null bytes (bytes containing 0x0) occur often in memory. A string that was accidentally ,NA,NA
"not terminated would run on for longer than intended, but usually would soon encounter ",NA,NA
a null. ,NA,NA
String Length,NA,NA
The length of a null-terminated string is defined as the number of characters it contains not ,NA,NA
counting the null. To calculate this start the count at one with the first character. Increment ,NA,NA
the count for each successive non-null byte. ,NA,NA
The flow chart shows this procedure. It describes the algorithm in general terms. Assembly ,NA,NA
language details are left to the coding stage. Here is an outline of the program: ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_3.html (1 of 2) [8/8/2545 9:22:16],NA
## strlen.asm,NA,NA
loop:,NA,NA
# finish ,NA,NA
"done:   sll   $0,$0,0",NA,NA
"string: .asciiz  ""Time is the ghost of space."" ## End of file",NA,NA
 .data,NA,NA
 j    loop,NA,NA
## ,NA,NA
## Count the charaters in a string ,NA,NA
## ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_3.html (2 of 2) [8/8/2545 9:22:16],NA
A good answer might be:,NA,NA
"You would like length( string1 ) + length( string2 ) = length( concat( string1, string2) ). If ",NA,NA
"the two nulls of string1 and string2 were counted this would be false, because the ",NA,NA
contatenation has only one null (at the end). ,NA,NA
Program continued,NA,NA
"There are several ways to do what the second box of the chart calls for: ""point at the first ",NA,NA
"character"". In a few chapters doing this will be much easier. But, for now, remember that the ",NA,NA
data section starts at the address 0x10000000. The top halfword of this is 0x1000. This is ,NA,NA
loaded into the top halfword of the base register with ,NA,NA
lui,NA,NA
## strlen.asm ,NA,NA
## ,NA,NA
## Count the charaters in a string ,NA,NA
## ,NA,NA
## Registers: ,NA,NA
## $8 --- count ,NA,NA
## ,NA,NA
$9 --- pointer to the char ,NA,NA
## $10 --- the char (in low order byte),NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
# Initialize ,NA,NA
"main:    ori      $8,$0,0        #  count = 0 ",NA,NA
"lui      $9,0x1000      #  point at first char",NA,NA
# while not ch==null do ,NA,NA
"loop:    lbu   $10,____($9)     # get the char",NA,NA
" _____   $10,$0,done    # exit loop if char == null",NA,NA
 j       loop ,NA,NA
# finish ,NA,NA
"done:   sll   $0,$0,0           # target for branch",NA,NA
 .data ,NA,NA
"string: .asciiz  ""Time is the ghost of space."" ",NA,NA
## End of file,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_4.html (1 of 2) [8/8/2545 9:22:31],NA
QUESTION 4:,NA,NA
A few more statements have been added to get and test the current ,NA,NA
character. Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_4.html (2 of 2) [8/8/2545 9:22:31],NA
A good answer might be: ,NA,NA
The answer is below. ,NA,NA
Loop Body,NA,NA
The address of the byte in the ,NA,NA
lbu,NA,NA
 instruction is computed by displacement + $9. Since the ,NA,NA
"base, $9, has the address of (points at) the character, the diplacement is zero. The ",NA,NA
lbu ,NA,NA
loads the character into the low-order byte of $10. The upper three bytes are zero. The ,NA,NA
beq ,NA,NA
"instruction tests if the entire register is zero, but, of course, that also tests if the low-order ",NA,NA
byte is zero. ,NA,NA
## strlen.asm ,NA,NA
## ,NA,NA
## Count the charaters in a string ,NA,NA
## ,NA,NA
## Registers: ,NA,NA
## $8 --- count ,NA,NA
## $9 --- pointer to the char ,NA,NA
## $10 --- the char (in low order byte),NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
# Initialize ,NA,NA
"main:    ori      $8,$0,0        #  count = 0",NA,NA
" lui      $9,0x1000      #  point at first char",NA,NA
# while not ch==null do ,NA,NA
"loop:    lbu   $10,",NA,NA
0,NA,NA
($9)        # get the char,NA,NA
beq ,NA,NA
"  $10,$0,done      # exit loop if char == null",NA,NA
" addiu    ___,___,___   # count++",NA,NA
" addiu    ___,___,___   # point at the next char",NA,NA
 j       loop ,NA,NA
# finish ,NA,NA
"done:   sll   $0,$0,0           # target for branch",NA,NA
 .data ,NA,NA
"string: .asciiz  ""Time is the ghost of space.""",NA,NA
## End of file,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_5.html (1 of 2) [8/8/2545 9:22:41],NA
"Next, the program must increment the count, then move the base register (the character ",NA,NA
pointer) to the next byte of the string. ,NA,NA
QUESTION 5:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
The complete program is below. ,NA,NA
Complete Program,NA,NA
"The base register is ""moved"" through the string by increasing the address by one for each ",NA,NA
"byte. This is also called ""moving a pointer"". ",NA,NA
This program has an important concept on every line. Using these concepts is how you ,NA,NA
program! Play with the program so that these concepts become 0x10,nd,NA
 nature! ,NA,NA
## strlen.asm ,NA,NA
## ,NA,NA
## Count the charaters in a string ,NA,NA
## ,NA,NA
## Registers: ,NA,NA
## $8 --- count ,NA,NA
## $9 --- pointer to the char ,NA,NA
## $10 --- the char (in low order byte),NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
# Initialize ,NA,NA
"main:    ori      $8,$0,0        #  count = 0",NA,NA
" lui      $9,0x1000      #  point at first char",NA,NA
# while not ch==null do ,NA,NA
"loop:    lbu      $10,0($9)      # get the char",NA,NA
" beq      $10,$0,done    # exit loop if char == null ",NA,NA
addiu    ,NA,NA
"$8,$8,1",NA,NA
        # count++,NA,NA
 addiu    ,NA,NA
"$9,$9,1",NA,NA
        # point at the next char j        ,NA,NA
loop,NA,NA
# finish ,NA,NA
"done:    sll      $0,$0,0        # target for branch",NA,NA
 .data ,NA,NA
"string:  .asciiz  ""Time is the ghost of space."" ",NA,NA
## End of file,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_6.html (1 of 2) [8/8/2545 9:22:43],NA
The program is very close to the C standard library function ,NA,NA
int strlen(char*),NA,NA
". As it is written, ",NA,NA
"the program has its own data, and it is not invoked by another function. We will do both of ",NA,NA
those things in a few chapters. ,NA,NA
QUESTION 6:,NA,NA
Does the program work correctly if the string is the null string (the string of ,NA,NA
length zero that consists of just a null byte)? ,NA,NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Integer Array,NA,NA
An array of integers is a sequence of integers in successive words of memory. Usually the ,NA,NA
number of integers of the array is kept in a separate location in memory. ,NA,NA
In assembly language an array of integers is declared using the directive ,NA,NA
.word,NA,NA
 followed by ,NA,NA
a list of comma separated integers. ,NA,NA
 .data ,NA,NA
size:   .word  17 ,NA,NA
"array:  .word  12, -1, 8, 0, 6, 85, -74, 23, 99, -30, 30, 95, 4, 7, 10, 28, 14",NA,NA
The ,NA,NA
.word,NA,NA
 directive puts the data in word aligned locations. ,NA,NA
QUESTION 7:,NA,NA
"Why can't an array end with a null word, like with strings? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_7.html [8/8/2545 9:22:50],NA
A good answer might be: ,NA,NA
"Because a null word, 0x00000000, is a legitimate (and common) integer. ",NA,NA
Example Program: sum of an array,NA,NA
Sometimes programmers try to end an array with a pattern that they think will never occur in ,NA,NA
"the data, like 0x10000000. This is an invitation for bugs. The pattern might truely never ",NA,NA
"occur in correct data, but faulty data is common, and your program should deal with it ",NA,NA
gracefully. ,NA,NA
The next example program uses an array of integer. The length of the array is given. The ,NA,NA
program calculates three sums: ,G,NA
The sum of all integers.,G,NA
The sum of the positive integers. ,G,NA
The sum of the negative integers.,NA,NA
"You have probably seen this example before, done in Java or C. ",NA,NA
QUESTION 8:,NA,NA
Sketch out the flowchart for the program (or write it in pseudo code). ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_8.html [8/8/2545 9:22:55],NA
A good answer might be: ,NA,NA
See Below ,NA,NA
Flowchart,NA,NA
The flow chart could work for any language. ,NA,NA
Specific assembly language details are left out. ,NA,NA
The chart is a structured flowchart. It is nice to ,NA,NA
have a structured design before coding in an ,NA,NA
unstructured language like assembly. Here is ,NA,NA
an outline of the program: ,NA,NA
## addIntArray.asm ,NA,NA
## ,NA,NA
"## Sum all integers, the positive integers, ",NA,NA
## and the negative integers in an array.,NA,NA
## Registers: ,NA,NA
## $8 --- count ,NA,NA
## $9 --- pointer to the array entry ,NA,NA
## $10 -- current array entry ,NA,NA
## $11 -- sum of all integers ,NA,NA
## $12 -- sum of negative integers ,NA,NA
## $13 -- sum of positive integers ,NA,NA
## $14 -- pos. or neg. flag ,NA,NA
## $15 -- SIZE of the array,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
# Initialize ,NA,NA
"main:    ori      $____,$0,0       #  count = 0",NA,NA
" ori      $____,$0,0       #  sum = 0",NA,NA
" ori      $____,$0,0       #  neg = 0",NA,NA
" ori      $____,$0,0       #  pos = 0",NA,NA
# while  count < SIZE do ,NA,NA
loop: ,NA,NA
 j        loop,NA,NA
" sll      $0,$0,0        #  branch delay",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_9.html (1 of 2) [8/8/2545 9:23:11],NA
 .data ,NA,NA
size:   .word  17 ,NA,NA
"array:  .word  12, -1, 8, 0, 6, 85, -74, 23, 99, -30, 30, 95, 4, 7, 10, 28, 14",NA,NA
## End of file,NA,NA
"SPIM initializes registers to zero, but it is good practice to explicitly zero accumulators. ",NA,NA
QUESTION 9:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
See below ,NA,NA
Loading the Array Size,NA,NA
"Next, load the size of the array into register $15. The size is the first word of the data ",NA,NA
section. Recall that the data section starts at the address 0x10000000. Load the top half of ,NA,NA
that address into the base register. ,NA,NA
## Registers: ,NA,NA
## $8 --- count                       $12 -- sum of negative integers ## $9 ,NA,NA
--- pointer to the array entry  $13 -- sum of positive integers ## $10 ,NA,NA
-- current array entry         $14 -- pos. or neg. flag ,NA,NA
## $11 -- sum of all integers         $15 -- SIZE of the array,NA,NA
## Initialize ,NA,NA
main:    ori      ,NA,NA
$8,NA,NA
",$0,0        #  count = 0",NA,NA
 ori      ,NA,NA
$11,NA,NA
",$0,0       #  sum = 0",NA,NA
 ori      ,NA,NA
$12,NA,NA
",$0,0       #  neg = 0",NA,NA
 ori      ,NA,NA
$13,NA,NA
",$0,0       #  pos = 0",NA,NA
" ____     $9,0x1000     #  point at SIZE",NA,NA
" ____     $15,0($9)     #  get SIZE",NA,NA
" addiu    $9,$9,____    #  point to first entry",NA,NA
# while  count < SIZE do ,NA,NA
loop: ,NA,NA
 j        loop,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
 .data ,NA,NA
size:   .word  17 ,NA,NA
"array:  .word  12, -1, 8, 0, 6, 85, -74, 23, 99, -30, 30, 95, 4, 7, 10, 28, 14",NA,NA
"Next, load SIZE into register $15. Finally, point the base register at the first word of the ",NA,NA
array. ,NA,NA
QUESTION 10:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_10.html (1 of 2) [8/8/2545 9:23:22],NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_10.html (2 of 2) [8/8/2545 9:23:22],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Building the Loop,NA,NA
"Perhaps you added one to the base register, rather than four. The base register $9 needs to ",NA,NA
"be increased by the size of a full word, four. Now work on getting the loop correct. The ",NA,NA
beq ,NA,NA
instruction branches out of the loop if the count has reached the array size. ,NA,NA
## Registers: ,NA,NA
## $8 --- count                       $12 -- sum of negative integers ## $9 ,NA,NA
--- pointer to the array entry  $13 -- sum of positive integers ## $10 ,NA,NA
-- current array entry         $14 -- pos. or neg. flag ,NA,NA
## $11 -- sum of all integers         $15 -- SIZE of the array,NA,NA
"main:    ori      $8,$0,0        #  count = 0",NA,NA
 ori      ,NA,NA
"$11,$0,0       #  sum = 0",NA,NA
" ori      $12,$0,0       #  neg = 0",NA,NA
" ori      $13,$0,0       #  pos = 0 ",NA,NA
lui,NA,NA
"      $9,0x1000      #  point at SIZE",NA,NA
lw,NA,NA
"       $15,0($9)      #  get SIZE",NA,NA
" addiu    $9,$9,",NA,NA
4,NA,NA
        #  point to first entry,NA,NA
# while  count < SIZE do ,NA,NA
"loop:    beq      $____,$____,done ",NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
" addiu    $8,$8,____     # count++",NA,NA
" addiu    $9,$9,____     # point at next entry j        ",NA,NA
loop,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"done:    sll      $0,$0,0        #  target for branch",NA,NA
 .data ,NA,NA
size:   .word  17 ,NA,NA
"array:  .word  12, -1, 8, 0, 6, 85, -74, 23, 99, -30, 30, 95, 4, 7, 10, 28, 14",NA,NA
"At the bottom of the loop, the count is incremented and the base register is move to the next ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_11.html (1 of 2) [8/8/2545 9:23:27],NA
array entry. ,NA,NA
QUESTION 11:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Add Entry to Sum,NA,NA
The count is increased by one. The pointer is increased by four. Next get the current array ,NA,NA
element and add it to the sum of all integers. ,NA,NA
## Registers: ,NA,NA
## $8 --- count                       $12 -- sum of negative integers ## $9 ,NA,NA
--- pointer to the array entry  $13 -- sum of positive integers ## $10 ,NA,NA
-- current array entry         $14 -- pos. or neg. flag ,NA,NA
## $11 -- sum of all integers         $15 -- SIZE of the array,NA,NA
"main:    ori      $8,$0,0        #  count = 0 ori      ",NA,NA
"$11,$0,0       #  sum = 0",NA,NA
" ori      $12,$0,0       #  neg = 0",NA,NA
" ori      $13,$0,0       #  pos = 0",NA,NA
" lui      $9,0x1000      #  point at SIZE",NA,NA
" lw       $15,0($9)      #  get SIZE",NA,NA
" addiu    $9,$9,4        #  point to first entry",NA,NA
# while  count < SIZE do ,NA,NA
loop:    beq      ,NA,NA
"$8,$15,",NA,NA
done ,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"# get entry, add to sum",NA,NA
" lw       $10,____($____) #  get entry",NA,NA
" sll      $0,$0,0        #  load delay",NA,NA
" addu     $11,$____,$____ #  add to sum",NA,NA
" addiu    $8,$8,",NA,NA
1,NA,NA
        # count++,NA,NA
" addiu    $9,$9,",NA,NA
4,NA,NA
        # point at next entry ,NA,NA
j        loop,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"done:    sll      $0,$0,0        #  target for branch",NA,NA
 .data,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_12.html (1 of 2) [8/8/2545 9:23:42],NA
size:   .word  17 ,NA,NA
"array:  .word  12, -1, 8, 0, 6, 85, -74, 23, 99, -30, 30, 95, 4, 7, 10, 28, 14",NA,NA
QUESTION 12:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Is the Entry Negative?,NA,NA
"Next, set a flag (register $14) if the array entry is negative. Branch to the symbolic address ",NA,NA
neg,NA,NA
 if it is. ,NA,NA
## Registers: ,NA,NA
## $8 --- count                       $12 -- sum of negative integers ## $9 ,NA,NA
--- pointer to the array entry  $13 -- sum of positive integers ## $10 ,NA,NA
-- current array entry         $14 -- pos. or neg. flag ,NA,NA
## $11 -- sum of all integers         $15 -- SIZE of the array,NA,NA
# while  count < SIZE do ,NA,NA
"loop:    beq      $8,$15,done ",NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"# get entry, add to sum",NA,NA
" lw       $10,",NA,NA
0($9),NA,NA
      #  get entry,NA,NA
" sll      $0,$0,0        #  load delay",NA,NA
" addu     $11,",NA,NA
"$11,$10",NA,NA
    #  add to sum,NA,NA
#  test neg. or pos.,NA,NA
" slti     $14,$10,_____  #  set flag if entry is neg ",NA,NA
"bne      $___,$___,neg  #  branch if negative sll      ",NA,NA
"$0,$0,0        #  branch delay",NA,NA
neg:,NA,NA
" addiu    $8,$8,1        # count++",NA,NA
" addiu    $9,$9,4        # point at next entry ",NA,NA
j        loop,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"done:    sll      $0,$0,0        #  target for branch",NA,NA
 .data ,NA,NA
size:   .word  17 ,NA,NA
"array:  .word  12, -1, 8, 0, 6, 85, -74, 23, 99, -30, 30, 95, 4, 7, 10, 28, 14",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_13.html (1 of 2) [8/8/2545 9:23:56],NA
QUESTION 13:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_13.html (2 of 2) [8/8/2545 9:23:56],NA
A good answer might be: ,NA,NA
See below ,NA,NA
True and False Branches,NA,NA
"Next implement the two branches; one adds to the sum of negatives, the other adds to the ",NA,NA
sum of positives. Check that you don't have the branches confused. ,NA,NA
## Registers: ,NA,NA
## $8 --- count                       $12 -- sum of negative integers ## $9 ,NA,NA
--- pointer to the array entry  $13 -- sum of positive integers ## $10 ,NA,NA
-- current array entry         $14 -- pos. or neg. flag ,NA,NA
## $11 -- sum of all integers         $15 -- SIZE of the array,NA,NA
# while  count < SIZE do ,NA,NA
"loop:    beq      $8,$15,done ",NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"# get entry, add to sum",NA,NA
" lw       $10,0($9)      #  get entry",NA,NA
" sll      $0,$0,0        #  load delay",NA,NA
" addu     $11,$11,$10    #  add to sum",NA,NA
#  test neg. or pos.,NA,NA
" slti     $14,$10,",NA,NA
0,NA,NA
      #  set flag if entry is neg ,NA,NA
bne      ,NA,NA
"$14,$0",NA,NA
",neg     #  branch if negative",NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
" ____     $13,$13,$10    #  positive: add to PLUS ",NA,NA
j        _______,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"neg:     ____     $12,$12,$10    #  negative: add to NEG ",NA,NA
"ifend:   addiu    $8,$8,1        #  count++",NA,NA
" addiu    $9,$9,4        #  point at next entry",NA,NA
 j        loop,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
"done:    sll      $0,$0,0        #  target for branch",NA,NA
 .data ,NA,NA
size:   .word  17,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_14.html (1 of 2) [8/8/2545 9:24:03],NA
"array:  .word  12, -1, 8, 0, 6, 85, -74, 23, 99, -30, 30, 95, 4, 7, 10, 28, 14",NA,NA
QUESTION 14:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Complete Program,NA,NA
Here is the complete program suitable for ,NA,NA
running. The data in the array has been ,NA,NA
simplified to make testing easier. Study how the ,NA,NA
code matches the flow chart. ,NA,NA
## addIntArray.asm ,NA,NA
## ,NA,NA
"## Sum all integers, the positive integers, ",NA,NA
## and the negative integers in an array.,NA,NA
## Registers: ,NA,NA
## $8 --- count ,NA,NA
## $9 --- pointer to the array entry ,NA,NA
## $10 -- current array entry ,NA,NA
## $11 -- sum of all integers ,NA,NA
## $12 -- sum of negative integers ,NA,NA
## $13 -- sum of positive integers ,NA,NA
## $14 -- pos. or neg. flag ,NA,NA
## $15 -- length of the array,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
# Initialize ,NA,NA
"main:    ori      $8,$0,0        #  count = 0",NA,NA
" ori      $11,$0,0       #  sum = 0",NA,NA
 ,NA,NA
"ori      $12,$0,0       #  neg = 0",NA,NA
 ori      ,NA,NA
"$13,$0,0       #  pos = 0",NA,NA
" lui      $9,0x1000      #  point at SIZE",NA,NA
" lw       $15,0($9)      #  get SIZE",NA,NA
" addiu    $9,$9,4        #  point to first entry",NA,NA
# while  count < SIZE do ,NA,NA
"loop:    beq      $8,$15,done ",NA,NA
" sll      $0,$0,0        #  branch delay",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_15.html (1 of 2) [8/8/2545 9:24:09],NA
"# get entry, add to sum",NA,NA
" lw       $10,0($9)      #  get entry",NA,NA
" sll      $0,$0,0        #  load delay",NA,NA
" addu     $11,$11,$10    #  add to sum",NA,NA
#  test neg. or pos.,NA,NA
" slti     $14,$10,0x0    #  set $14 if entry is neg bne      ",NA,NA
"$14,$0,neg     #  branch if negative",NA,NA
" sll      $0,$0,0        #  branch delay ",NA,NA
addu,NA,NA
"     $13,$13,$10    #  positive: add to PLUS j        ",NA,NA
ifend,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
neg:     ,NA,NA
addu,NA,NA
"     $12,$12,$10    #  negative: add to NEG",NA,NA
"ifend:   addiu    $8,$8,1        # count++",NA,NA
" addiu    $9,$9,4        # point at next entry ",NA,NA
j        loop,NA,NA
" sll      $0,$0,0        #  branch delay",NA,NA
# finish ,NA,NA
"done:    sll      $0,$0,0        # target for branch",NA,NA
 .data ,NA,NA
size:   .word  4 ,NA,NA
"array:  .word  1, 2, -2, -1",NA,NA
## End of file,NA,NA
QUESTION 15:,NA,NA
Could the code be rearranged to make better use of the delay slots? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_15.html (2 of 2) [8/8/2545 9:24:09],NA
A good answer might be: ,NA,NA
Yes. You might try this as an exercise. ,NA,NA
Running the Program,NA,NA
You can run the ,NA,NA
tedious. On the ,NA,NA
version of SPIM for ,NA,NA
windows you can do ,NA,NA
the following to start ,NA,NA
the program and run ,NA,NA
it to completion: ,NA,NA
1.  Initialize the PC ,NA,NA
(as usual).,NA,NA
program by ,NA,NA
initializing the PC (to ,NA,NA
0x00400000) and ,NA,NA
This procedure is not very elegant. Set a breakpoint at the last instruction if you want. Or set ,NA,NA
"a breakpoint at the top of the loop so that the loop body executes once per ""Continue"". ",NA,NA
"If you click ""Go"" in the menu, the simulator tries to start with some code that is not there and ",NA,NA
"halts. ""Bare Machine"" is set in the options menu, so the extra code is not there. Keep things ",NA,NA
"this way for now, unless you want to experiment. ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_16.html (1 of 2) [8/8/2545 9:24:12],NA
QUESTION 16:,NA,NA
Is a single run of the program enough to be certain that it is correct? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_16.html (2 of 2) [8/8/2545 9:24:12],NA
A good answer might be: ,NA,NA
Even a simple program like this might have some bugs that only careful testing can ,NA,NA
uncover. ,NA,NA
End of Chapter,NA,NA
You have reached the end of this chapter. Click on a blue subject to go to where it was ,NA,NA
"discussed. To get back here, click on the ""back arrow"" button of your browser. ",G,NA
Null-terminated strings.,G,NA
String length.,G,NA
The ,NA,NA
Initializing a base register.,G,NA
Moving a base register,NA,NA
 through a string. ,G,NA
Implementing an ,NA,NA
integer array,NA,NA
 in assembly. ,G,NA
Moving a base register,NA,NA
 through an array of integers. ,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-20/ass20_17.html [8/8/2545 9:24:26],NA
CHAPTER 21 — Pseudoinstructions,NA,NA
"On the MIPS, the assembler creates a view of the processor a level above raw machine ",NA,NA
code. It implements an abstract machine that has a much richer instruction set than the ,NA,NA
MIPS hardware. ,NA,NA
Chapter Topics:,G,NA
Register mnemonic names.,G,NA
Pseudoinstructions and the pseudocomputer. ,G,NA
move,NA,NA
   pseudoinstruction.,G,NA
li,NA,NA
   pseudoinstruction.,G,NA
la,NA,NA
   pseudoinstruction.,G,NA
lw,NA,NA
   pseudoinstruction.,G,NA
sw,NA,NA
   pseudoinstruction.,G,NA
nop,NA,NA
   pseudoinstruction.,NA,NA
The previous chapters of these notes did not use these extended features of the asembler ,NA,NA
so that the actual machine could be seen. This chapter makes greater use of the extended ,NA,NA
assembler features. ,NA,NA
QUESTION 1:,NA,NA
(Review:) What is a ,NA,NA
general purpose register,NA,NA
? ,NA,NA
A good answer might be:,NA,NA
A general purpose register is a register that is visible to assembly language. The ,NA,NA
floating ,NA,NA
point resgisters,NA,NA
", although visible to assembly language, are not regarded as general ",NA,NA
purpose registers. (A register is an electronic device that holds bit patterns.) ,NA,NA
Register Mnemonics,NA,NA
"Although the registers are called ""general purpose"", it is conventional in software for each ",NA,NA
register to be used for a specific purpose. The ,NA,NA
extended assembler,NA,NA
 uses mnemonic names ,NA,NA
for registers that groups them according to use. The following table shows this. Registers $8 ,NA,NA
through $15 are conventionally used to hold temporary values. The mnemonic name for ,NA,NA
these registers is $t0 through $t7. ,NA,NA
Register ,NA,NA
Number,NA,NA
Mnemonic ,NA,NA
Name,NA,NA
Conventional ,NA,NA
Use,NA,NA
Register ,NA,NA
Number,NA,NA
Mnemonic ,NA,NA
Name,NA,NA
Conventional ,NA,NA
Use,NA,NA
$0,NA,NA
zero,NA,NA
Permanently 0,NA,NA
"$24, $25",NA,NA
"$t8, $t9",NA,NA
Temporary,NA,NA
$1,NA,NA
$at,NA,NA
Assembler ,NA,NA
Temporary,NA,NA
"$26, $27",NA,NA
"$k0, $k1",NA,NA
Kernel,NA,NA
"$2, $3",NA,NA
"$v0, $v1",NA,NA
Value returned by ,NA,NA
a subroutine,NA,NA
$28,NA,NA
$gp,NA,NA
Global Pointer,NA,NA
$4-$7,NA,NA
$a0-$a3,NA,NA
Arguments to a ,NA,NA
subroutine,NA,NA
$29,NA,NA
$sp,NA,NA
Stack Pointer,NA,NA
$8-$15,NA,NA
$t0-$t7,NA,NA
Temporary,NA,NA
$30,NA,NA
$fp,NA,NA
Frame Pointer,NA,NA
$16-$23,NA,NA
$s0-$s7,NA,NA
Saved registers,NA,NA
$31,NA,NA
$ra,NA,NA
Return Address,NA,NA
As far as ,NA,NA
hardware,NA,NA
" is concerned, the only registers $0 and $31 are different from the rest ",NA,NA
($0 is always full of zeros and $31 is automatically used by some subroutine linkage ,NA,NA
instructions to hold the return address). The remaining registers are electronically identical. ,NA,NA
It is ,NA,NA
software convention,NA,NA
 to use different sets of registers for different purpose. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_2.html (1 of 2) [8/8/2545 10:58:13],NA
QUESTION 2:,NA,NA
Have new hardware registers been added to the processor with the use of ,NA,NA
register mnemonic names? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_2.html (2 of 2) [8/8/2545 10:58:13],NA
A good answer might be: ,NA,NA
No--register mnemonic names are a feature implemented by the assembler. ,NA,NA
Extended Assembler,NA,NA
The assembler software is written so that (if you ask for it) mnemonic register names can be ,NA,NA
used in place of hardware register numbers. The assembler replaces register mnemonics with ,NA,NA
"register numbers. Of course, the assembly instruction is ultimately translated into machine ",NA,NA
code. ,NA,NA
SPIM implements many features that are not provided by MIPS hardware. When it does this it is ,NA,NA
an ,NA,NA
extended assembler,NA,NA
. The extended assembler accepts source code that uses extentions to ,NA,NA
basic assembly language. The extentions in the source code are replaced with basic assembly ,NA,NA
"language, and then translated into machine code. ",NA,NA
"By using the extended assembler the programmer may program in a more convenient language, ",NA,NA
but the underlying hardware remains unchanged. Of course ,NA,NA
high-level,NA,NA
 languages such as C go ,NA,NA
even further: rather than merely extending the assembly language of the machine a completely ,NA,NA
new programming language is supported by the underlying hardware. ,NA,NA
QUESTION 3:,NA,NA
The programs in the previous chapters used registers $8 through $15. What are ,NA,NA
the mnemonic names for these registers? See the ,NA,NA
register table.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_3.html [8/8/2545 10:58:22],NA
A good answer might be: ,NA,NA
$8 through $15 ,NA,NA
==,NA,NA
 $t0 through $t7 ,NA,NA
Registers for Temporary Values,NA,NA
"Most assembly programs, like most higher-level language programs, are collections of ",NA,NA
subroutines. Subroutines use ,NA,NA
local variables,NA,NA
 that are not visible outside the subroutine. The ,NA,NA
temporary,NA,NA
" registers $t0-$t7,$t8, and $t9 and the ",NA,NA
saved,NA,NA
 registers $s0-$s7 are used for local ,NA,NA
variables (or for the same idea in assembly language). ,NA,NA
When you program a subroutine you assume that the temporary registers and saved are ,NA,NA
"yours to use however you want. However, by software convention, the temporary registers ",NA,NA
may change across a subroutine call. The saved registers don't changed across a ,NA,NA
subroutine call. ,NA,NA
" ori  $t0,$0,32    # load 32 into temp register",NA,NA
" ori  $s0,$0,13    # load 13 into saved register",NA,NA
 jal  subrout      # subroutine call,NA,NA
" sll  $0,$0,0      # delay slot",NA,NA
"back:   addu $s0,$s0,$t0  # return from sub; # ",NA,NA
temp regs may have changed. # ,NA,NA
saved regs have not changed.,NA,NA
The statement at ,NA,NA
back,NA,NA
 is in error. The temporary register ,NA,NA
t0,NA,NA
 may have been changed by the ,NA,NA
subroutine ,NA,NA
subrout,NA,NA
. ,NA,NA
QUESTION 4:,NA,NA
Could the ,NA,NA
main,NA,NA
 program be considered a subroutine? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_4.html [8/8/2545 10:58:24],NA
A good answer might be: ,NA,NA
Yes---to the operating system ,NA,NA
main,NA,NA
 is a subroutine. ,NA,NA
Other Registers,NA,NA
"The registers are grouped into those used as variables and arguments in subroutines ($0, ",NA,NA
"$v0-$v1, $a0-$a3, $t0-$t9, $s0-$s7), and those used for other purposes. Subroutines are ",NA,NA
discussed in a future chapter. The other uses are discussed as the topic arises. ,NA,NA
The core of an operating system is the ,NA,NA
kernel,NA,NA
. The kernel contains those routines that are ,NA,NA
the most fundamental to the OS. The rest of the OS is mostly implemented in terms of the ,NA,NA
"functions provided by the kernel. Two registers, $k0 and $k1, are reserved for the kernel. ",NA,NA
Applications programs (and most OS subroutines) should not touch them. ,NA,NA
"Of course, SPIM does not come with an OS. It loads a tiny monitor, if requested. But don't ",NA,NA
use $k0 and $k1. ,NA,NA
"The registers $gp, $sp, and $fp are base registers for access to various parts of memory. ",NA,NA
QUESTION 5:,NA,NA
What does the following assembly language instruction do? ,NA,NA
"addu $t5,zero,$t7",NA,NA
It ,NA,NA
________,NA,NA
 the contents of register ,NA,NA
________,NA,NA
 into register ,NA,NA
________,NA,NA
.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_5.html [8/8/2545 10:58:26],NA
A good answer might be: ,NA,NA
What does the following assembly language instruction do? ,NA,NA
"addu $t5,zero,$t7 ",NA,NA
It ,NA,NA
copies,NA,NA
 the contents of register ,NA,NA
$7,NA,NA
 into register ,NA,NA
$5,NA,NA
.,NA,NA
Pseudoinstructions,NA,NA
The ,NA,NA
addu,NA,NA
" instruction, used as above, copies a bit pattern from the source register into the ",NA,NA
destination register. This operation is usually called a ,NA,NA
move,NA,NA
" operation, although the source ",NA,NA
register does not change. It is often convenient to move a value from one general purpose ,NA,NA
register to another. ,NA,NA
"It is awkward to say ""add"" when you mean ""move"". You might wish that there was a ",NA,NA
"mnemonic for ""move"". In fact, the ",NA,NA
extended assembler,NA,NA
", allows you to use the mnemonic ",NA,NA
move,NA,NA
" instead of ""addu"". This mnemonic does not correspond to a new machine instruction. ",NA,NA
It is a ,NA,NA
pseudoinstruction,NA,NA
 that the assembler translates into the appropriate basic assembly ,NA,NA
instruction. ,NA,NA
A ,NA,NA
pseudoinstruction,NA,NA
 is an instruction used in assembly language that the extended ,NA,NA
assembler replaces with one or several basic assembly instructions. The extended ,NA,NA
assembler has many more pseudoinstructions than the hardware has opcodes. ,NA,NA
"move d,s        #  copy the contents of ",NA,NA
 #  the source register s,NA,NA
 #  to the destination register d,NA,NA
 #  (pseudoinstruction),NA,NA
QUESTION 6:,NA,NA
(Review:) What is in register $t5 after the following instruction: ,NA,NA
"ori $t5,$0,74",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_6.html [8/8/2545 10:58:36],NA
A good answer might be: ,NA,NA
"ori $t5,$0,74",NA,NA
 puts the two's complement representation of 74,10,NA
 into register $t5. ,NA,NA
Load Immediate,NA,NA
The ,NA,NA
ori,NA,NA
" instruction, used as above, copies a bit pattern from the instruction into the ",NA,NA
destination register. This operation is usually called a ,NA,NA
load immediate,NA,NA
 operation---it loads a ,NA,NA
register with a value that is immediately available (without going to memory). ,NA,NA
"You might wish that you could a mnemonic for ""load immediate"". With the extended ",NA,NA
"assembler, you can. Use the ",NA,NA
li,NA,NA
 mnemonic. This is a pseudoinstruction that the assembler ,NA,NA
translates into the appropriate basic assembly instruction. ,NA,NA
"li   d,value        #  load register $d with the  ",NA,NA
#  positive or negative integer #  ,NA,NA
"""value""",NA,NA
QUESTION 7:,NA,NA
Translate the following ,NA,NA
pseudoinstruction,NA,NA
 into the corresponding basic ,NA,NA
assembly instruction (use mnemonic register names): ,NA,NA
"li $v0,12 ",NA,NA
== ,NA,NA
"ori ____,____,____",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_7.html [8/8/2545 10:58:43],NA
A good answer might be: ,NA,NA
"li $v0,12 ",NA,NA
== ,NA,NA
"ori $v0,zero,12",NA,NA
Several Translations,NA,NA
The ,NA,NA
load immediate,NA,NA
 pseudoinstruction is useful for loading a register with an integer value. ,NA,NA
Here is another example: ,NA,NA
"li  $t2,-153",NA,NA
This puts the two's complement representation of -156,10,NA
" into register $t2. However, this can ",NA,NA
not be done with   ,NA,NA
ori,NA,NA
 because the immediate field of that instruction must be a 16-bit ,NA,NA
unsigned integer. The immediate operand is ,NA,NA
zero-extended,NA,NA
 into the 32 bits of the ,NA,NA
destination register. Because the immediate value of the ,NA,NA
li,NA,NA
" is negative, a different translation ",NA,NA
is used: ,NA,NA
"li $v2,-153",NA,NA
==,NA,NA
"addiu $v2,$0,-153",NA,NA
(Remember that ,NA,NA
addiu,NA,NA
 does a two's complement addition with its operands. The ,NA,NA
u,NA,NA
 means ,NA,NA
that overflow does not cause a trap). The extended assembler translates ,NA,NA
li,NA,NA
 into different ,NA,NA
"basic instructions, depending on the immediate value. ",NA,NA
QUESTION 8:,NA,NA
"Can either basic instruction, ",NA,NA
ori,NA,NA
 or ,NA,NA
addiu,NA,NA
 use an immediate value greater ,NA,NA
than 16 bits? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_8.html [8/8/2545 10:58:48],NA
A good answer might be: ,NA,NA
No. The machine instruction has a 16-bit field for the immediate value. ,NA,NA
Two Basic Instructions,NA,NA
Machine instructions have fixed-sized fields. Immediate operands are always 16 bits. ,NA,NA
"However, two machine instructions can be used to load a 32-bit register with the top half ",NA,NA
and bottom half of a 32-bit integer: ,NA,NA
"li $v2,0x12345678",NA,NA
==,NA,NA
"lui $v2,0x1234",NA,NA
"ori $v2,$v2,0x5678",NA,NA
"In this situation, ",NA,NA
li,NA,NA
 translates into two basic instructions. The first loads the top half of $v2; ,NA,NA
"the second ors-in the bottom half. Of course, the same is done for any integer (positive or ",NA,NA
"negative) that requires seventeen to thirty-two bits. So, from the extended assembly ",NA,NA
language programmer's point of view there is a very useful instruction: ,NA,NA
The extended assembler automatically translates this pseudoinstruction into the most ,NA,NA
efficient sequence of actual instructions. ,NA,NA
QUESTION 9:,NA,NA
Translate the following ,NA,NA
pseudoinstruction,NA,NA
 into the corresponding basic ,NA,NA
assembly instruction:   ,NA,NA
"li $t7,0xFF001234",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_9.html [8/8/2545 10:58:53],NA
A good answer might be: ,NA,NA
"li $t7,0xFF001234",NA,NA
==,NA,NA
"lui $t7,0xFF00 ",NA,NA
"ori $t7,$t7,0x1234 ",NA,NA
The immediate operand of the pseudoinstruction is the representation of a negative ,NA,NA
"integer (notice that the ""sign bit"" is set). You don't have to use hex with ",NA,NA
li,NA,NA
. The ,NA,NA
programmer could have written: ,NA,NA
"li $t7,-16772555",NA,NA
. ,NA,NA
Example Program,NA,NA
Here is a tiny example program using load immediate. There will be more realistic examples ,NA,NA
in pages to come. ,NA,NA
## liEg.asm ,NA,NA
##,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" li    $t0,43        #  first alue",NA,NA
" li    $t1,-96       #  second value",NA,NA
" li    $t7,-16772555 #  third",NA,NA
" addu  $t0,$t0,$t1   #  add the values ",NA,NA
"addu  $t0,$t0,$t7",NA,NA
## end of liEg.asm,NA,NA
"You might wish to run the program with SPIM, mostly to see how the three ",NA,NA
li,NA,NA
 instructions ,NA,NA
"translate into different basic instructions. To run it in SPIM, first look in the settings menu ",NA,NA
"and check ""allow pseudo instructions"" and remove the check from ""bare machine"". ",NA,NA
QUESTION 10:,NA,NA
What is a ,NA,NA
symbolic address,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_10.html [8/8/2545 10:59:01],NA
A good answer might be: ,NA,NA
A symbolic address is the name used in source code for a location in memory. ,NA,NA
Unknown Addresses,NA,NA
 A symbolic address does more than just ,NA,NA
"memory a particular datum or instruction ends up at, ",NA,NA
even if this is not known in advance.,NA,NA
 ,NA,NA
"Often a program is built using several object modules, library modules, and assembler source ",NA,NA
files. (See Chapter One on separate assembly.) The various modules refer to locations in ,NA,NA
each other using symbolic addresses. The actual addresses are determined by system ,NA,NA
software when all the modules are linked together ,NA,NA
a name a memory location. It stands for whatever location in ,NA,NA
and loaded into memory. It is very hard (and not necessary) for a programmer to know what ,NA,NA
addresses various items will eventually have. ,NA,NA
"The assembler enables a programmer to refer to an address by a symbol, even when the ",NA,NA
address will not be known until much later in the process of building an executable. The ,NA,NA
assembler and subsequent systems software (linker and loader) keep track of the symbolic ,NA,NA
"address until the address it represents is finally determined. At run time, everything is ",NA,NA
resolved. A machine language program and data are loaded and executed. ,NA,NA
QUESTION 11:,NA,NA
"(Review:) In the picture, what data is in the word starting at address ",NA,NA
0x1000000C? ,NA,NA
________,NA,NA
 What is the address of the word containing ,NA,NA
0x00000002? ,NA,NA
________,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_11.html [8/8/2545 10:59:11],NA
A good answer might be: ,NA,NA
(Review:) The picture is a run-time snapshot of memory while some program is running. ,NA,NA
What data is in the word starting at address 0x1000000C? ,NA,NA
0x00000003,NA,NA
 What is the ,NA,NA
address of the word containing 0x00000002? ,NA,NA
0x10000008,NA,NA
Address and Contents of an Address,NA,NA
The contents of a word of memory may be any 32-bit ,NA,NA
pattern. The address of a word of memory is also a 32-bit ,NA,NA
pattern. Both types of data fit into a 32-bit register. ,NA,NA
Sometimes you want the contents of memory word to be ,NA,NA
"loaded into a register. For example, you may wish to load ",NA,NA
the value 0x00000002. This is done with the ,NA,NA
lw,NA,NA
 instruction. ,NA,NA
Sometimes you want to load the run-time address of a word in ,NA,NA
"memory. For example, you may wish to load the address ",NA,NA
0x10000008. The past chapters have done this when setting ,NA,NA
up a base register. This was done with code similar to the ,NA,NA
following: ,NA,NA
main:                        #  Load memory address: ,NA,NA
"lui   $10,0x1000",NA,NA
     #  top half ,NA,NA
"ori   $10,$10,0x0008",NA,NA
 #  bottom half,NA,NA
" lw    $11,0($10)     #  Load contents of memory at the address",NA,NA
 . . . ,NA,NA
 .data ,NA,NA
val0:   .word   0 ,NA,NA
val1:   .word   1 ,NA,NA
"val2:   .word   2           # base register points at ""2"" ",NA,NA
val3:   .word   3 ,NA,NA
val4:   .word   4 ,NA,NA
val5:   .word   5 ,NA,NA
QUESTION 12:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_12.html (1 of 2) [8/8/2545 10:59:16],NA
Is there a problem with this code? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_12.html (2 of 2) [8/8/2545 10:59:16],NA
A good answer might be: ,NA,NA
Yes: the programmer must know the address in advance. ,NA,NA
Load Address Pseudoinstruction,NA,NA
It is not always possible to know the address in advance. But systems software and ,NA,NA
symbolic addresses make this unnecessary. The way this feature is accessed in assembly ,NA,NA
language is by using the ,NA,NA
la,NA,NA
 mnemonic. This mnemonic does not correspond to a single ,NA,NA
machine instruction. It is a ,NA,NA
pseudoinstruction,NA,NA
 that the assembler translates into to several ,NA,NA
machine instructions. ,NA,NA
"la   d,exp          #  load register $d with the address ",NA,NA
"#  described by the expression ""exp"" #  ",NA,NA
"""exp"" is often a symbolic address",NA,NA
"In this pseudoinstruction, ",NA,NA
exp,NA,NA
 is an expression that evaluates to a memory address. There ,NA,NA
are several possible forms for ,NA,NA
exp,NA,NA
. Often it is a symbolic address. The ,NA,NA
la,NA,NA
 pseudoinstruction ,NA,NA
translates into different machine code instructions depending on ,NA,NA
exp,NA,NA
. ,NA,NA
QUESTION 13:,NA,NA
Does the ,NA,NA
la,NA,NA
 instruction access memory? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_13.html [8/8/2545 10:59:31],NA
A good answer might be: ,NA,NA
"No. At run time, the one or few machine instructions it translates into ensure that the ",NA,NA
designated register is loaded with the required address. ,NA,NA
LA Example,NA,NA
Here is the previous example code done using ,NA,NA
la,NA,NA
:,NA,NA
main:                        #  Load memory address: ,NA,NA
"la    $10,val2",NA,NA
       #  complete 32-bit address into $10,NA,NA
" lw    $11,0($10)     #  Load contents of memory at the address",NA,NA
 . . . ,NA,NA
 .data ,NA,NA
val0:   .word   0 ,NA,NA
val1:   .word   1 ,NA,NA
val2:   .word   2 ,NA,NA
val3:   .word   3 ,NA,NA
val4:   .word   4 ,NA,NA
"val5:   .word   5                # base register points at ""5"" ",NA,NA
QUESTION 14:,NA,NA
This ,NA,NA
la,NA,NA
 instruction translates into two machine instructions. What two ,NA,NA
instructions does it translate into? (Answer with two instructions mnemonics.) ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_14.html [8/8/2545 10:59:33],NA
A good answer might be: ,NA,NA
This ,NA,NA
la,NA,NA
 translates into a ,NA,NA
lui,NA,NA
 followed by a ,NA,NA
ori,NA,NA
 (just as we previously did by hand). ,NA,NA
SPIM Example,NA,NA
Here is a SPIM example using ,NA,NA
la,NA,NA
". To run it in SPIM, first look in the settings menu and ",NA,NA
"check ""allow pseudo instructions"" and remove the check from ""bare machine"". ",NA,NA
## addEm.asm ,NA,NA
## program to add two integers,NA,NA
##,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" la    $t0,val2     #  complete 32-bit address into $t0 ",NA,NA
"lw    $t1,0($t0)   #  load first value, 2",NA,NA
" lw    $t2,4($t0)   #  load second value, 3",NA,NA
" addu  $t1,$t1,$t2  #  calc. sum",NA,NA
 .data ,NA,NA
val0:   .word   0 ,NA,NA
val1:   .word   1 ,NA,NA
val2:   .word   2 ,NA,NA
val3:   .word   3 ,NA,NA
val4:   .word   4 ,NA,NA
val5:   .word   5 ,NA,NA
## end of addEm.asm,NA,NA
Execute the program by pushing F10 for each machine instruction. ,NA,NA
QUESTION 15:,NA,NA
How many times will F10 be pushed? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_15.html [8/8/2545 10:59:38],NA
A good answer might be: ,Five: twice for the two instructions the,NA
la,is translated into.,NA
SPIM Run,"Here is a run of the program. The SPIM listing shows the two machine instructions that the assembler used for 
 the",NA
la,"pseudoinstruction. The assembler uses different machine instructions in different contexts. 
  
  
  
 Look carefully at the two instructions that SPIM used for",NA
la,. They use register $1 as the base register.,NA
QUESTION 16:,"In the 
 register table.
  what is the mnemonic name for register $1? 
  
  
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_16.html [8/8/2545 10:59:50]",NA
A good answer might be: ,NA,NA
$at,NA,NA
", the ",NA,NA
assembler temporary,NA,NA
 register. ,NA,NA
Assembler Temporary Register,NA,NA
The ,NA,NA
assembler temporary register,NA,NA
 is reserved for the assembler to use in translating ,NA,NA
pseudoinstructions. Often a pseudoinstruction is implemented as a short sequence of ,NA,NA
machine instructions that use ,NA,NA
$at,NA,NA
. Here is how ,NA,NA
la,NA,NA
 was translated in the example: ,NA,NA
"la $t0,val5  <==>  lui $1,4097",NA,NA
" ori $8,$1,8",NA,NA
Sometimes a pseudoinstruction has the same mnemonic as the non-extended assembler ,NA,NA
"instruction. For example, ",NA,NA
lw,NA,NA
 (load word) is a (non-extended) assembler instruction. As an ,NA,NA
"assembler instruction, it is used like this: ",NA,NA
"lw    $t1,8($t0)   #  load the word at address $t0+8",NA,NA
"The assembler instruction designates the address with a displacement (eight, in this case) ",NA,NA
"to add to a base register ($t0, in this case). This corresponds exactly to one machine ",NA,NA
"instruction. There is no other form for the non-extended assembler instruction. However, ",NA,NA
"with the extended assembler, the following  ",NA,NA
psuedo,NA,NA
instruction can be used: ,NA,NA
"lw    $t1,exp    #  load value at  address exp",NA,NA
QUESTION 17:,NA,NA
The ,NA,NA
assembler instruction,NA,NA
lw,NA,NA
 uses a base register. When the ,NA,NA
pseudoinstruction,NA,NA
lw,NA,NA
" is translated, what base register is used? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_17.html [8/8/2545 10:59:58],NA
A good answer might be: ,NA,NA
"The assembler temporary register, $at which is also $1. ",NA,NA
Load Word PseudoInstruction,NA,NA
Here is a possible translation the pseudoinstruction ,NA,NA
lw,NA,NA
. ,NA,NA
The extended assembler and its pseudoinstructions makes it look like you are programming ,NA,NA
a ,NA,NA
"lw $t0,data  <==>  lui $1,0x1000",NA,NA
" lw $8,4($1)",NA,NA
Say that the symbol ,NA,NA
data,NA,NA
 stands for the address ,NA,NA
0x10000004 ,NA,NA
psuedo,NA,NA
computer---a computer system that is richer in features and more convenient to ,NA,NA
"program than the actual hardware. (Often this is called a ""virtual computer""; but to avoid ",NA,NA
confusion I'll say that pseudoinstructions run on the pseudocomputer.) This idea of ,NA,NA
implementing a virtual machine on top of another machine (which may also be virtual) is ,NA,NA
very important in computer science. ,NA,NA
The pseudocomputer built ontop of the hardware is a consistent ,NA,NA
layer of abstraction,NA,NA
. When ,NA,NA
you write programs using the extended assembler and its pseudoinstructions you think in ,NA,NA
terms of the pseudocomputer and its capabilities. You can pretend that the pseudocomputer ,NA,NA
will directly execute your prograjm. ,NA,NA
One of the most useful instructions of the pseudocomputer is the ,NA,NA
lw,NA,NA
 p-instruction. It copies ,NA,NA
a word of data from memory into a register seemingly in one step: ,NA,NA
"lw    d,exp      #  (",NA,NA
pseudoinstruction,NA,NA
) Load register $d  #  ,NA,NA
with the value at address exp.  exp can be any #  ,NA,NA
of several expression types that evaluate to  #  an ,NA,NA
address,NA,NA
QUESTION 18:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_18.html (1 of 2) [8/8/2545 11:00:01],NA
Should the ,NA,NA
lw,NA,NA
 p-instruction be followed by a load delay slot? (Hint: look at its ,NA,NA
translation.) ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_18.html (2 of 2) [8/8/2545 11:00:01],NA
A good answer might be: ,NA,NA
"Yes. The second instruction in its translation is a non-extended load instruction, which ",NA,NA
requires a delay of one instruction before the loaded value can be used. ,NA,NA
Store Word (pseudoinstruction) ,NA,NA
The ,NA,NA
nop,NA,NA
 pseudoinstruction translates into ,NA,NA
"sll $0,$0,0",NA,NA
", the ""no operation"" instruction we have ",NA,NA
been using all along. ,NA,NA
nop              #  (,NA,NA
pseudoinstruction,NA,NA
) no operation,NA,NA
 #  do nothing for one machine cycle.,NA,NA
The ,NA,NA
sw,NA,NA
 mnemonic is another that is used both by an unextended assembler instruction and ,NA,NA
a pseudoinstruction. With it the pseudocomputer can store a register to memory with one ,NA,NA
instruction. ,NA,NA
"sw    d,exp      #  (",NA,NA
pseudoinstruction,NA,NA
) Store register $d  #  ,NA,NA
into the word at address exp.  exp can be any #  ,NA,NA
of several expression types that evaluate to  #  an ,NA,NA
address,NA,NA
"Of course, this is implemented as several non-extended instructions. ",NA,NA
QUESTION 19:,NA,NA
Play Pseudocomputer: translate the ,NA,NA
sw,NA,NA
 instruction into non-extended ,NA,NA
instructions: ,NA,NA
"sw   $t0,someWord      ==       lui  _____,0x1000",NA,NA
" sw   _____,12( ____ )",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_19.html [8/8/2545 11:00:06],NA
A good answer might be: ,NA,NA
"sw   $t0,someWord      ==       lui  $1,0x1000",NA,NA
" sw   $8,12( $1 ) ",NA,NA
It would be OK to say $t0 for $8 and $at for $1. ,NA,NA
Example Program,NA,NA
Here is an example of programming the pseudocomputer using the ,NA,NA
lw,NA,NA
 and ,NA,NA
sw,NA,NA
 instructions. ,NA,NA
The ,NA,NA
nop,NA,NA
 (no-operation) instructions are used to follow the rule that a ,NA,NA
mult,NA,NA
 instruction should ,NA,NA
not be started until two instructions after a ,NA,NA
mflo,NA,NA
 or ,NA,NA
mfhi,NA,NA
 instruction. ,NA,NA
## pseudoPoly.asm ,NA,NA
## evaluate the polynomial ax,2,NA
 +bx + c ,NA,NA
##,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" lw   $t3,x          # get x",NA,NA
" lw   $t0,a          # get a",NA,NA
" lw   $t1,bb         # get bb",NA,NA
" lw   $t2,c          # get c",NA,NA
" mult $t3,$t3        # x",2,NA
 mflo $t4            # $t4 = x,2,NA
 nop,NA,NA
 nop,NA,NA
" mult $t4,$t0        # low  = ax",2,NA
 mflo $t4            # $t4  = ax,2,NA
 nop,NA,NA
 nop,NA,NA
" mult $t1,$t3        # low  = bx",NA,NA
 mflo $t5            # $t5  = bx,NA,NA
" addu $t5,$t4,$t5    # $t5  = ax",2,NA
 + bx,NA,NA
" addu $t5,$t5,$t2    # $t5 = ax",2,NA
 + bx + c,NA,NA
" sw   $t5,value      # value = polynomial",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_20.html (1 of 2) [8/8/2545 11:00:11],NA
 .data ,NA,NA
x:      .word   4 ,NA,NA
value:  .word   1 ,NA,NA
a:      .word  20 ,NA,NA
bb:     .word  -2 ,NA,NA
c:      .word   5,NA,NA
## end of pseudoPoly.asm,NA,NA
"This is a straightforward evaluation of the polynomial. By using Horner's method, and by ",NA,NA
"cleverly filling some of the no-ops with instructions, the program could be greatly improved. ",NA,NA
QUESTION 20:,NA,NA
What big assumption was made in writing this program? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_20.html (2 of 2) [8/8/2545 11:00:11],NA
A good answer might be: ,NA,NA
The program assumes that all calculations fit into 32 bits. ,NA,NA
End of Chapter,NA,NA
You have reached the end of this chapter. Click on a blue subject to go to where it was ,NA,NA
"discussed. To get back here, click on the ""back arrow"" button of your browser. ",G,NA
Mnemonic register names.,G,NA
The ,NA,NA
assembler temporary,NA,NA
 register. ,G,NA
The ,NA,NA
kernel,NA,NA
 of an operating system. ,G,NA
Systems software and ,NA,NA
symbolic addresses. ,G,NA
Pseudoinstructions,NA,NA
 and the pseudocomputer. ,G,NA
The ,NA,NA
move,NA,NA
 pseudoinstruction.,G,NA
The ,NA,NA
la ,NA,NA
pseudoinstruction.,G,NA
lw,NA,NA
 pseudoinstruction.,G,NA
sw,NA,NA
 pseudoinstruction.,G,NA
nop,NA,NA
 pseudoinstruction.,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-21/ass21_21.html [8/8/2545 11:00:17],NA
CHAPTER 22 — SPIM Trap Handler,NA,NA
"Up until now, the example programs run on SPIM simulating a ""bare machine""--a computer ",NA,NA
with no machine code in it but your own. Most computer systems run under the direction of ,NA,NA
an operating system. Application programs use the services of the operating system to do ,NA,NA
input and output and other system tasks. ,NA,NA
This chapter discusses the SPIM trap handler--a very small set of services that is a great ,NA,NA
help in writing assembly programs. ,NA,NA
Chapter Topics:,G,NA
The,NA,NA
syscall,NA,NA
instruction. ,G,NA
SPIM trap handler.,G,NA
Trap handler services: ,H,NA
halt program ,H,NA
print string ,H,NA
read string ,H,NA
print integer ,H,NA
read integer ,G,NA
Hello World,NA,NA
 example. ,G,NA
Library Fine,NA,NA
 example.,NA,NA
QUESTION 1:,NA,NA
In an actual (hardware) bare machine do you suppose that it is easy to write ,NA,NA
a character to the terminal? ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
syscall,NA,NA
"In even the simplest computer, putting a character on the screen involves many instructions ",NA,NA
and a detailed knowledge of the video card. Let's leave this topic until later (perhaps years ,NA,NA
"later). SPIM includes a ""trap handler"" that simulates a tiny operating system that can do ",NA,NA
input and output to a console. ,NA,NA
Assembly language programs request operating system services using the ,NA,NA
syscall ,NA,NA
"instruction. (There is, unfortunately, no Ebert instruction). The ",NA,NA
syscall,NA,NA
 instruction (at run ,NA,NA
"time) transfers control to the operating system, which then performs the requested service. ",NA,NA
Then control (usually) returns to the program. (This description leaves out many details). ,NA,NA
syscall           # invoke the operating system,NA,NA
"Different OSes use this instruction in different ways. For SPIM, it is used like this: ",NA,NA
"li      $v0,code  # ""code"" is the number of an OS service.",NA,NA
.......           # Put parameters for the service in ,NA,NA
".......           # registers $a0, $a1 or $f12 (as appropriate). ",NA,NA
syscall           # Invoke the operating system.,NA,NA
 # Return value (if any) is in $v0 or $f0 ,NA,NA
 # ,NA,NA
"Different services use different registers, and not all return values. ",NA,NA
QUESTION 2:,NA,NA
Is ,NA,NA
syscall,NA,NA
 a ,NA,NA
pseudoinstruction,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_2.html [8/8/2545 9:33:59],NA
A good answer might be: ,NA,NA
No. It is a 32-bit machine instruction. ,NA,NA
Trap Handler Services,NA,NA
Here are the services of the SPIM trap handler. Details about how to use them are in the ,NA,NA
following pages. The ,NA,NA
print,NA,NA
 services write characters to the simulated monitor of SPIM. The ,NA,NA
read,NA,NA
 services read characters from the keyboard and (for numeric reads) convert them into ,NA,NA
the appropriate type. ,NA,NA
Service,NA,NA
Code,NA,NA
Arguments,NA,NA
Returned Value,NA,NA
print integer,NA,NA
1,NA,NA
$a0 ,NA,NA
==,NA,NA
 integer,NA,NA
print float ,NA,NA
2,NA,NA
$f12 ,NA,NA
==,NA,NA
 float ,NA,NA
print double ,NA,NA
3,NA,NA
"($f12, $f13) ",NA,NA
==,NA,NA
 double ,NA,NA
print string ,NA,NA
4,NA,NA
$a0 ,NA,NA
==,NA,NA
 address of string,NA,NA
read integer,NA,NA
5,NA,NA
$v0 ,NA,NA
<--,NA,NA
 integer,NA,NA
read float ,NA,NA
6,NA,NA
$f0 ,NA,NA
<--,NA,NA
 float,NA,NA
read double ,NA,NA
7,NA,NA
"($f0, $f1) ",NA,NA
<--,NA,NA
 double,NA,NA
read string ,NA,NA
8,NA,NA
$a0 ,NA,NA
==,NA,NA
 buffer address ,NA,NA
$a1 ,NA,NA
==,NA,NA
 buffer length,NA,NA
allocate memory ,NA,NA
9,NA,NA
$a0 ,NA,NA
==,NA,NA
 number of bytes,NA,NA
$v0 ,NA,NA
<--,NA,NA
 address,NA,NA
exit ,NA,NA
10,NA,NA
The ,NA,NA
exit,NA,NA
 service stops the program. (Until now we have been single stepping or crashing ,NA,NA
into the bytes beyond the end of the program). ,NA,NA
QUESTION 3:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_3.html (1 of 2) [8/8/2545 9:34:16],NA
What does the ,NA,NA
exit,NA,NA
 service of a real operating system do? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_3.html (2 of 2) [8/8/2545 9:34:16],NA
A good answer might be: ,NA,NA
Control returns to the OS and does not return to the program. The OS then goes about ,NA,NA
"its own tasks, possibly starting another user program. ",NA,NA
Print String,NA,NA
The ,NA,NA
print string,NA,NA
 SPIM trap handler service prints a ,NA,NA
null terminated,NA,NA
 string to the simulated ,NA,NA
monitor. The address of the string is loaded into register $a0. Typically the string is in the ,NA,NA
data section of memory. ,NA,NA
"li      $v0,4       # code 4 == print string ",NA,NA
"la      $a0,string  # $a0 == address of the string ",NA,NA
syscall             # Invoke the operating system. . ,NA,NA
. .,NA,NA
 .data ,NA,NA
"string: .asciiz      ""Hello SPIM!\n""",NA,NA
The service sends bytes to the simulated monitor starting with the byte pointed to by $a0 ,NA,NA
"until it hits the null byte. It does not check that the bytes are ascii, you will print garbage if ",NA,NA
you point $a0 at the wrong location. ,NA,NA
"If you want to advance to a new line, use the newline character '\n' inside or at the end of ",NA,NA
the string. ,NA,NA
QUESTION 4:,NA,NA
Can the print string service be used to print out 32-bit integers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_4.html [8/8/2545 9:34:18],NA
A good answer might be: ,NA,NA
"No, not directly. Integers must be converted to characters before they are printed. ",NA,NA
The Traditional Example,NA,NA
You are now ready to see the program you probably expected to see in Chapter One. The ,NA,NA
"following program prints the string, then calls the ",NA,NA
exit,NA,NA
 service. ,NA,NA
# hello.asm ,NA,NA
#,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
" li      $v0,4       # code 4 == print string",NA,NA
" la      $a0,string  # $a0 == address of the string",NA,NA
 syscall             # Invoke the operating system.,NA,NA
" li      $v0,10      # code 10 == exit",NA,NA
 syscall             # Return to OS.,NA,NA
 .data ,NA,NA
"string: .asciiz      ""Hello SPIM!\n"" ",NA,NA
# end of file,NA,NA
"The string is printed to the monitor window of the simulator. The program is complete, and ",NA,NA
can be copied into a source file and run as is. But see the next page first. ,NA,NA
QUESTION 5:,NA,NA
"On a real (hardware) computer, what is the trap handler? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_5.html [8/8/2545 9:34:30],NA
A good answer might be: ,NA,NA
It is a machine language program in memory (possibly in ROM). ,NA,NA
Starting SPIM,NA,NA
"On SPIM, the trap ",NA,NA
"disk, or (in the good old ",NA,NA
days) might be entered ,NA,NA
into memory by hand. ,NA,NA
To use the trap handler with SPIM ask for it in the Simulator Settings panel. Set the options ,NA,NA
"""Allow pseudoinstructions"" and ",NA,NA
handler is also a program ,NA,NA
that is optionally loaded ,NA,NA
into SPIM memory. On a ,NA,NA
Now to assemble and load your program go to File Open and select the source file (just as ,NA,NA
we have been doing). Your program is loaded along with some initialization code. The ,NA,NA
"initialization code starts at address 0x00400000, the address that has until now been where ",NA,NA
your programs started. ,NA,NA
To run the program click on Simulator Go and then OK in the pop-up panel. ,NA,NA
QUESTION 6:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_6.html (1 of 2) [8/8/2545 9:34:39],NA
Can you single step starting at address 0x00400000 as before? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_6.html (2 of 2) [8/8/2545 9:34:39],NA
A good answer might be: ,NA,NA
"Yes, but since much of the code is not from your program single stepping is less ",NA,NA
interesting. ,NA,NA
Example Output,NA,NA
"Here is SPIM with the example ""hello.asm"" program. The simulated console is in the ",NA,NA
"background, and the only code you can see is the initialization code. If (in your actual SPIM ",NA,NA
window) you scroll down the data window you will see the ascii codes for the string. ,NA,NA
QUESTION 7:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_7.html (1 of 2) [8/8/2545 9:36:53],NA
"What happens if the program were slightly modified, as follows: ",NA,NA
main:,NA,NA
" li      $v0,4       # code 4 == print string",NA,NA
" la      $a0,string  # $a0 == address of the string ",NA,NA
"addiu   $a0,1       # add one to the address",NA,NA
 syscall             # Invoke the operating system.,NA,NA
 . . .,NA,NA
 .data ,NA,NA
"string: .asciiz      ""Hello SPIM!\n""",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_7.html (2 of 2) [8/8/2545 9:36:53],NA
A good answer might be: ,NA,NA
"The program prints ""ello SPIM!"" ",NA,NA
"Read Integer, Print Integer",NA,NA
The ,NA,NA
read integer,NA,NA
 service reads an entire line of input from your keyboard---all the ,NA,NA
characters you type up to the ,NA,NA
newline,NA,NA
 character. These characters are expected to be ,NA,NA
"ASCII digits '0', '1', .., '9' with an optional leading '-' or '+'. The characters are converted into ",NA,NA
"a 32-bit two's complement representation of the integer, returned in $v0. ",NA,NA
"li      $v0,5     # code 5 == read integer ",NA,NA
syscall           # Invoke the operating system.,NA,NA
 # $v0 <-- two's comp. int.,NA,NA
The ,NA,NA
print integer,NA,NA
 service prints the integer represented by the 32 bits in $a0 to the SPIM ,NA,NA
"terminal. Of course, there are many ways that the integer can be placed in $a0, not just ",NA,NA
lw,NA,NA
. ,NA,NA
"li      $v0,1     # code 1 == print integer ",NA,NA
"lw      $a0,int   # $a0 == the integer ",NA,NA
syscall           # Invoke the operating system.,NA,NA
QUESTION 8:,NA,NA
The ,NA,NA
print integer,NA,NA
 prints an integer on the simulated monitor. But what must it ,NA,NA
do before printing? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_8.html [8/8/2545 9:37:36],NA
A good answer might be: ,NA,NA
The integer in $a0 is first converted from 32-bit two's complement representation into ,NA,NA
ascii characters. ,NA,NA
Example Program,NA,NA
"The example program reads in an integer, presumed to be a number of ounces, then writes ",NA,NA
out the equivalent number of pounds and ounces. ,NA,NA
# ounces.asm ,NA,NA
# ,NA,NA
# Convert ounces to pounds and ounces.,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
"main:   li      $v0,4       # print prompt",NA,NA
" la      $a0,prompt  #",NA,NA
 syscall,NA,NA
" li      $v0,5       # read in ounces",NA,NA
 syscall,NA,NA
" li      $t1,16      # 16 oz. per pound",NA,NA
" divu    $v0,$t1     # lo = pound; hi = oz.",NA,NA
 mflo    $a0,NA,NA
" li      $v0,1       # print",NA,NA
 syscall             # pounds,NA,NA
" li      $v0,4       # print ""pounds""",NA,NA
" la      $a0,pout",NA,NA
 syscall,NA,NA
 mfhi    $a0         # print,NA,NA
" li      $v0,1       # ounces",NA,NA
 syscall             # ,NA,NA
" li      $v0,4       # print",NA,NA
" la      $a0,ozout   # ""ounces""",NA,NA
 syscall,NA,NA
" li      $v0,10      # exit",NA,NA
 syscall,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_9.html (1 of 2) [8/8/2545 9:37:41],NA
 .data ,NA,NA
"prompt: .asciiz ""Enter ounces: "" ",NA,NA
"pout:   .asciiz "" Pounds\n"" ",NA,NA
"ozout:  .asciiz "" Ounces\n"" ",NA,NA
# end of file,NA,NA
"As is often the case, input and output dominate the program. The actual calculation is hard ",NA,NA
to find. ,NA,NA
QUESTION 9:,NA,NA
"The program prints ""Pounds"" and ""Ounces"" on separate lines. Change the ",NA,NA
program so that they are printed on one line. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_9.html (2 of 2) [8/8/2545 9:37:41],NA
A good answer might be: ,NA,NA
"Remove the ""\n"" from "" Ounces\n"". ",NA,NA
Read String,NA,NA
The trap handler can also read in a string from the keyboard. ,NA,NA
"li      $v0,8       # code 8 == read string ",NA,NA
"lw      $a0,buffer  # $a0 == address of buffer ",NA,NA
"li      $a1,16      # $a1 == buffer length ",NA,NA
syscall             # Invoke the operating system.,NA,NA
 . . . .,NA,NA
 .data ,NA,NA
buffer: .space 16   # reserve 16 bytes,NA,NA
Look at these details when you need them:,NA,NA
 Usually $a1 contains the length (in bytes) of ,NA,NA
the input buffer. Up to ($a1)-1 characters are read from the keyboard and placed in ,NA,NA
buffer ,NA,NA
as a ,NA,NA
null terminated,NA,NA
" string. The user ends the string by hitting ""enter"". The ""enter"" ",NA,NA
character appears at the end of the string as '\n' (0x0a) unless the string is ($a1)-1 ,NA,NA
"characters long. No matter what, there is a null at the end of the string. ",NA,NA
QUESTION 10:,NA,NA
Is the string that is read in immediately suitable for output using the ,NA,NA
print ,NA,NA
string,NA,NA
 service? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_10.html [8/8/2545 9:37:46],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
A Fine Example,NA,NA
"Sometimes you will have to remove the null at the end of the input string, perhaps because ",NA,NA
"it is intended to be part of a larger string. Other times, as in the following example, you can ",NA,NA
use two ,NA,NA
print string,NA,NA
 operations. ,NA,NA
"The example program asks the user to enter a name followed by comma and ""enter"". Then ",NA,NA
the program writes out a personalized letter using the name. The body of the letter is printed ,NA,NA
using only one ,NA,NA
syscall,NA,NA
. The personalized greeting is printed first in a separate ,NA,NA
syscall ,NA,NA
because it is null terminated. ,NA,NA
# overdue.asm,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
 # get patron name,NA,NA
" li      $v0,4           # print prompt",NA,NA
" la      $a0,prompt      #",NA,NA
 syscall,NA,NA
" li      $v0,8           # code 8 == read string",NA,NA
" la      $a0,name        # $a0 == address of buffer li      ",NA,NA
"$a1,24          # $a1 == buffer length",NA,NA
 syscall                 # Invoke the operating system.,NA,NA
 # print the letter,NA,NA
" li      $v0,4           # print greeting",NA,NA
" la      $a0,letter      #",NA,NA
 syscall,NA,NA
" li      $v0,4           # print body",NA,NA
" la      $a0,body        #",NA,NA
 syscall,NA,NA
" li      $v0,10      # exit",NA,NA
 syscall,NA,NA
 .data,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_11.html (1 of 2) [8/8/2545 9:37:56],NA
"prompt: .asciiz ""enter name, followed by comma-enter: "" ",NA,NA
"letter: .ascii ""\n\nDear "" ",NA,NA
name:   .space 24,NA,NA
"body:   .ascii ""\nYour library books are way\n""",NA,NA
" .ascii ""overdue.  Please return them\n""",NA,NA
" .ascii ""before we give your name\n""",NA,NA
" .ascii ""to the enforcement squad.\n\n""",NA,NA
# end of file,NA,NA
It is somewhat crude to make the user enter a comma at the end of the name. It would be ,NA,NA
nicer to have the program detect the end of the name and automatically put a comma after ,NA,NA
it. The program would be much longer. ,NA,NA
QUESTION 11:,NA,NA
"Is ""backspace"" a character? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_11.html (2 of 2) [8/8/2545 9:37:56],NA
A good answer might be: ,NA,NA
Yes --- it is ascii code 0x08 ,NA,NA
No Line-buffer Correction,NA,NA
The user might make a mistake in entering the name and try to correct it by hitting the ,NA,NA
"""backspace"" key to erase the mistake. But this does not work. The ascii value of the key ",NA,NA
0x08 is included in the string just as any character value. Odd byte values show up (in ,NA,NA
SPIM) as a small black rectangle. ,NA,NA
"Most operating system user interfaces allow the user to edit a string (with BS, DEL, arrow ",NA,NA
and other keys) before it is sent to an application program. (This is sometimes called ,NA,NA
"""cooked"" input mode). But the SPIM service does not do this. Characters are sent as they ",NA,NA
"were typed. (This is called ""raw"" input mode). ",NA,NA
"You could, of course, write your program so that it looks at the raw characters and corrects ",NA,NA
"the input string. This is a messy task, and often skipped, but should not be. ",NA,NA
QUESTION 12:,NA,NA
"In a famous computer blunder, a radiation therapy device was controlled by ",NA,NA
"an assembly program that did not used cooked input, and did not bother to ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_12.html (1 of 2) [8/8/2545 9:38:07],NA
check for valid input. What do you think happened? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_12.html (2 of 2) [8/8/2545 9:38:07],NA
A good answer might be: ,NA,NA
"Instead of the input, the patients were cooked. ",NA,NA
End of the Chapter,NA,NA
You have reached the end of this chapter. Click on a blue subject to go to where it was ,NA,NA
"discussed. To get back here, click on the ""back arrow"" button of your browser. ",G,NA
syscall instruction ,G,NA
Trap handler services ,G,NA
print string ,G,NA
Using the trap handler with SPIM ,G,NA
read integer ,G,NA
read string,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-22/ass22_13.html [8/8/2545 9:38:14],NA
CHAPTER 23 — Logic and Math ,NA,NA
Pseudoinstructions,NA,NA
This chapter further discusses pseudoinstuctions. When you write a program using ,NA,NA
pseudoinstructions,NA,NA
 it looks to you as if the computer has a rich set of convenient machine ,NA,NA
"instructions. In fact, these convenient instructions are each implemented by using basic ",NA,NA
instructions. The extended assembler replaces each pseudoinstruction with one or several ,NA,NA
basic instructions. The basic instructions are then translated into machine code. ,NA,NA
Chapter Topics:,G,NA
Bitwise logic: ,H,NA
not,NA,NA
 pseudoinstruction.,G,NA
Integer Arithmetic: ,H,NA
addu,NA,NA
   pseudoinstruction.,H,NA
subu,NA,NA
   pseudoinstruction.,H,NA
negu,NA,NA
   pseudoinstruction.,H,NA
mul,NA,NA
   pseudoinstruction.,H,NA
div,NA,NA
   pseudoinstruction.,H,NA
divu,NA,NA
   pseudoinstruction.,H,NA
remu,NA,NA
   pseudoinstruction.,G,NA
Rotate Instructions: ,H,NA
rol,NA,NA
 rotate left pseudoinstruction. ,H,NA
ror,NA,NA
 rotate right pseudoinstruction.,NA,NA
QUESTION 1:,NA,NA
What is the bit-wise ,NA,NA
not,NA,NA
 of this pattern: 0011 1001 ,NA,NA
A good answer might be:,NA,NA
NOT( 0011 1001 ) == 1100 0110,NA,NA
not,NA,NA
 Pseudoinstruction.,NA,NA
The ,NA,NA
not,NA,NA
 pseudoinstruction changes each bit in a register. ,NA,NA
Each 1 is changed to a 0 and each 0 is changed to a 1. ,NOR Operation on Bits,NA
"not   d,s  # load register d with the ",NA,NA
 #  bitwise not of register s,NA,NA
 # (pseudoinstruction),"first operand 
  
 0
  
 0
  
 1
  
 1
  
 second operand 
  
 0
  
 1
  
 0
  
 1",NA
This is a pseudoinstruction. The assembler translates it into ,NA,NA
"a single basic assembly instruction, a ",NA,NA
nor,NA,NA
 instruction. The ,NA,NA
nor operation is given in the table. The ,NA,NA
nor,NA,NA
 of two bits is ,NA,NA
equivalent to applying ,NA,NA
not,NA,NA
 to the ,NA,NA
or,NA,NA
 of the bits. The ,NA,NA
nor ,NA,NA
instruction uses two registers as operands and writes the ,NA,NA
result to a third register: ,"OR 
  
 --
  
 --
  
 --
  
 --
  
 0
  
 1
  
 1
  
 1
  
 not OR 
  
 1
  
 0
  
 0
  
 0",NA
"nor  d,s,t  # $d <-- bitwise NOR $s with $t.",NA,NA
Look at the first two columns of the table where the first operand is zero. The ,NA,NA
nor,NA,NA
 of the two ,NA,NA
operands is the ,NA,NA
not,NA,NA
 of the second operand. ,NA,NA
QUESTION 2:,NA,NA
How does the extended assembler translate: ,NA,NA
"not $s1,$t5 ",NA,NA
into: ,NA,NA
"nor _____, _____, _____ ","hint
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_2.html [8/8/2545 10:45:29]",NA
A good answer might be: ,NA,NA
"not $s1,$t5 ",NA,NA
    =     ,NA,NA
"nor $s1, $t5, $0 ",NA,NA
The order of the two operand registers could be reversed. ,NA,NA
Implicit Immediate Operand,NA,NA
Some pseudoinstructions translate into different basic instructions depending on the type of ,NA,NA
operands used with it. A pseudoinstruction used with an immediate operand translates into ,NA,NA
different basic instructions than one used with all register operands. ,NA,NA
Sometimes a mnemonic (,NA,NA
"""or"" for example",NA,NA
) is used for a basic instruction and for a ,NA,NA
pseudoinstruction. For example: ,NA,NA
"or $s0,$s1,0x00ff   ==> ori $s0,$s1,0x00ff",NA,NA
"Here, the extended assembler notices the immediate operand and translates the instruction ",NA,NA
into an ,NA,NA
ori,NA,NA
" instruction. The resulting machine code is a 32-bit or immediate. However, the ",NA,NA
following is a basic instruction: ,NA,NA
"or $s0,$s1,$t1 ",NA,NA
This assembly instruction is not changed. The resulting machine code is a 32-bit and ,NA,NA
instruction. ,NA,NA
The mmenomic ,NA,NA
and,NA,NA
 is similar. It might call for the basic instruction ,NA,NA
and,NA,NA
", or the basic ",NA,NA
instruction ,NA,NA
andi,NA,NA
", or other basic instructions depending on the operands. ",NA,NA
QUESTION 3:,NA,NA
Is there both a basic add instruction and an add immediate instruction? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_3.html [8/8/2545 10:45:37],NA
A good answer might be: ,NA,NA
yes ,NA,NA
Arithmetic Pseudoinstructions ,NA,NA
With ,NA,NA
the non-extended assembler there is an  ,NA,NA
"addu d,s,t",NA,NA
"  instruction where d, s, and t are ",NA,NA
"registers, and an  ",NA,NA
"addiu d,s,im",NA,NA
  instruction where im is an immediate operand. ,NA,NA
With the extended assembler the  ,NA,NA
"addu d,s,x",NA,NA
  instruction translates into different basic ,NA,NA
instructions depending on ,NA,NA
x,NA,NA
. ,NA,NA
x,NA,NA
" can be a register, a 16-bit immediate operand, or a larger ",NA,NA
immediate operand. ,NA,NA
Examine the following instruction (for the extended assembler): ,NA,NA
"addu $t0,$s0,40000 ",NA,NA
"The decimal value 40000 is too large for 16 bits, so the instruction cannot be translated into ",NA,NA
an ,NA,NA
addiu,NA,NA
 instruction. Two instructions must be used to add $s0 to 40000,10,NA
 and to place the ,NA,NA
result in $t0. ,NA,NA
QUESTION 4: ,NA,NA
Fill in the blanks: ,NA,NA
"addu $s1,$s0,40000  == ",NA,NA
"li   _____,40000    # use pseudoinstruction ",NA,NA
li ,NA,NA
"addu $s1,$s0,_____  # perform 32-bit addition","hint
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_4.html [8/8/2545 10:45:39]",NA
A good answer might be: ,NA,NA
"addu $s1,$s0,40000  == ",NA,NA
"li   $at,40000    # use pseudoinstruction ",NA,NA
li ,NA,NA
"addu $s1,$s0,$at  # perform 32-bit addition",NA,NA
Subtraction,NA,NA
The ,NA,NA
li,NA,NA
 in the above is itself a pseudoinstruction. It will be further translated into a basic ,NA,NA
instruction. ,NA,NA
There is also (with the extended assembler) a  ,NA,NA
"subu d,s,x",NA,NA
  instruction where the last operand ,NA,NA
"can be a register, a 16-bit immediate, or a 32-bit immediate. This instruction translates into ",NA,NA
the pseudoinstruction  ,NA,NA
"addu d,s,-x",NA,NA
  (which is then translated into basic instructions). ,NA,NA
The  ,NA,NA
"negu d,s",NA,NA
  pseudoinstruction calculates the two's complement negation of register $s ,NA,NA
and puts it in register $d. ,NA,NA
QUESTION 5:,NA,NA
Fill in the blanks: ,NA,NA
"negu $v2,$s3  ==  sub  ____,$0,____",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_5.html [8/8/2545 10:45:46],NA
A good answer might be: ,NA,NA
"negu $v2,$s3  ==  sub  $v2,$0,$s3",NA,NA
Multiplication,NA,NA
The ,NA,NA
mult,NA,NA
 and the ,NA,NA
multu,NA,NA
 instructions (which you have seen before) put the result into MIPS ,NA,NA
registers ,NA,NA
hi,NA,NA
 and ,NA,NA
lo,NA,NA
. The results may be moved out of these registers using ,NA,NA
mfhi,NA,NA
 and ,NA,NA
mflo,NA,NA
. ,NA,NA
The three operand pseudoinstruction  ,NA,NA
"mul d,s,t",NA,NA
  uses those basic instructions. It is used ,NA,NA
when the product of registers $s and $t is a value that fits into the 32 bits of ,NA,NA
lo,NA,NA
. ,NA,NA
QUESTION 6:,NA,NA
Finish the translation: ,NA,NA
"mul $v2,$s3,$t0  ==  multu  ____, ____",NA,NA
 mflo   ____ ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_6.html [8/8/2545 10:45:48],NA
A good answer might be: ,NA,NA
"mul $v2,$s3,$t0  ==  multu  $s3,$t0",NA,NA
 mflo   $v2,NA,NA
mul Pseudoinstruction,NA,NA
The ,NA,NA
mul,NA,NA
 pseudoinstruction makes it look as if MIPS has a 32-bit multiply instruction that ,NA,NA
places its 32-bit result in a register without checking for overflow: ,NA,NA
"mul  d,s,t # multiply $s by $t. put the",NA,NA
 # result in $d,NA,NA
 # (pseudoinstruction),NA,NA
There is no overflow checking. The bits of ,NA,NA
hi,NA,NA
 are not examined nor saved. There are several ,NA,NA
other pseudoinstructions that examine ,NA,NA
hi,NA,NA
 and perform various actions on overflow. For now ,NA,NA
we won't use them. ,NA,NA
A similar instruction exists for division. The basic instructions  ,NA,NA
"div s,t",NA,NA
  and  ,NA,NA
"divu s,t",NA,NA
  put their ,NA,NA
results in MIPS registers ,NA,NA
hi,NA,NA
 and ,NA,NA
lo,NA,NA
. The 32-bit quotient goes in ,NA,NA
lo,NA,NA
 and the 32-bit remainder ,NA,NA
goes in ,NA,NA
hi,NA,NA
". To move the quotient into a register, ",NA,NA
mflo,NA,NA
 is used. ,NA,NA
QUESTION 7:,NA,NA
"Finish the translation. The operand registers are s and t, the destination ",NA,NA
register is d. ,NA,NA
"div d,s,t  ==  div   ____, ____",NA,NA
 mflo  ____ ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_7.html [8/8/2545 10:45:50],NA
A good answer might be: ,NA,NA
"div d,s,t  ==  div  s,t",NA,NA
 mflo d ,NA,NA
div and divu Pseudoinstruction,NA,NA
The SPIM extended assembler includes these instructions: ,NA,NA
"div  d,s,t # divide $s by $t. Put the",NA,NA
 # quotient in $d. Operands are,NA,NA
 # two's complement.,NA,NA
 # (pseudoinstruction),NA,NA
and ,NA,NA
"divu d,s,t # divide $s by $t. Put the",NA,NA
 # quotient in $d. Operands are,NA,NA
 # unsigned.,NA,NA
 # (pseudoinstruction),NA,NA
Neither instruction checks for overflow. Other pseudoinstructions (not discussed here) do ,NA,NA
check for overflow. ,NA,NA
QUESTION 8:,NA,NA
Is the remainder of an integer division sometimes useful? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_8.html [8/8/2545 10:45:52],NA
A good answer might be: ,NA,NA
Of course. ,NA,NA
remu (Pseudoinstruction),NA,NA
"After a 32-bit integer division, the quotient is in the lo register and the remainder is in the hi ",NA,NA
register. The following pseudoinstruction uses several basic instructions to compute the ,NA,NA
remainder: ,NA,NA
"remu d,s,t # divide $s by $t. Put the",NA,NA
 # remainder in $d. Operands are,NA,NA
 # unsigned.,NA,NA
 # (pseudoinstruction),NA,NA
Another useful pseudoinstruction creates the negative of a two's complement integer: ,NA,NA
"negu d,s   # d <-- -s",NA,NA
 # (pseudoinstruction),NA,NA
There is a pseudoinstruction for creating the absolute value of an integer: ,NA,NA
"abs d,s    # d <-- |s|",NA,NA
 # (pseudoinstruction),NA,NA
QUESTION 9:,NA,NA
"What total amount is given to a waiter if the bill is $25, the tax rate is 8%, and ",NA,NA
the tip is 15% ? (Use integer math). ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_9.html [8/8/2545 10:46:04],NA
"What total amount is given to a waiter if the bill is $25, the tax rate is 8%, and the tip is 15% ",NA,NA
? (Use integer math). ,NA,NA
A good answer might be: ,NA,NA
total = 25 + (25*(8+15))/100 = 25 + (25*23)/100 = 25 + 575/100 = 30 ,NA,NA
"If the waiter grumbles about getting $30 instead of $31, just explain that in integer math ",NA,NA
575/100 = 5. ,NA,NA
Example Program,NA,NA
"Write a program that calculates the total amount given the amount for the meal, plus 8% ",NA,NA
"tax, plus 15% tip. The meal amount is input from the user. The tax and tip rates are fixed. ",NA,NA
Here is a run of the program: ,NA,NA
Enter food cost: 25,NA,NA
 Tax plus top:  5,NA,NA
 Total cost: 30,NA,NA
## rest.asm ,NA,NA
## ,NA,NA
## Total restaurant bill calculator ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
## $s0 tip+tax ,NA,NA
## $s1 tip rate ,NA,NA
## $s2 tax rate ,NA,NA
## $s3 meal cost ,NA,NA
## $a0 tax+tip dollars,NA,NA
 .globl  main,NA,NA
 # Get meal cost ,NA,NA
"main:   li      $v0,4       # print a prompt (code 4 put in $v0)",NA,NA
" la      $a0,prompt  # address of prompt put in $a0",NA,NA
 syscall,NA,NA
" li      $v0,5       # input an integer  (code 5 put in $v0)",NA,NA
 syscall             # 32-bit result returned in $v0,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_10.html (1 of 2) [8/8/2545 10:46:07],NA
" move    $s3,$v0     # save it in $s3 ",NA,NA
 . . . . .,NA,NA
 .data ,NA,NA
tip:    .word   15          # tip rate in percent ,NA,NA
tax:    .word    8          # tax rate in percent,NA,NA
"prompt: .asciiz ""Enter food cost: "" ",NA,NA
"head1 : .asciiz ""   Tax plus tip: "" ",NA,NA
"head2 : .asciiz ""     Total cost: "" ",NA,NA
# end of file,NA,NA
The only information needed from the user is the cost of the food. This is prompted for and ,NA,NA
then read in (as text) and converted (by part of the trap handler) into a 32-bit two's ,NA,NA
complement integer. The SPIM trap handler expects the service code to be in register $v0. ,NA,NA
Arguments are passed into and returned from the services using various other registers. ,NA,NA
See ,NA,NA
Appendix G,NA,NA
. ,NA,NA
QUESTION 10:,NA,NA
"With your mental highlighter, mark the mnemonics ",NA,NA
in the code fragment which are ,NA,NA
pseudoinstructions,NA,NA
. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_10.html (2 of 2) [8/8/2545 10:46:07],NA
A good answer might be: ,NA,NA
See Below. ,NA,NA
Calculation Section,NA,NA
"After reading the food cost, the program can do the calculations. It is convenient to do them ",NA,NA
all at once and then to print out the results. ,NA,NA
## rest.asm ,NA,NA
## ,NA,NA
## Total restaurant bill calculator ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
## $s0 tip+tax ,NA,NA
## $s1 tip rate ,NA,NA
## $s2 tax rate ,NA,NA
## $s3 meal cost ,NA,NA
## $a0 tax+tip dollars,NA,NA
 .globl  main,NA,NA
 # Get meal cost,NA,NA
main: ,NA,NA
" $v0,4       # print a prompt (code 4 put in $v0)",NA,NA
 syscall,NA,NA
" $a0,prompt  # address of prompt put in $a0",NA,NA
" $v0,5       # input an integer  (code 5 put in $v0)",NA,NA
 syscall             # 32-bit result returned in $v0,NA,NA
" $s3,$v0     # save it in $s3",NA,NA
 # Calculations,NA,NA
" lw      $s1,_____        # get tip rate",NA,NA
" lw      $s2,_____        # get tax rate",NA,NA
" addu    $s3,$s1,$s2      # total rate",NA,NA
" _____   $s4,$s0,$s3      # 100*(tax + tip)",NA,NA
" _____    $s4,$s4,100     # tax + tip  ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_11.html (1 of 2) [8/8/2545 10:46:15],NA
" _____  $s5,$s0,$s4       # total bill",NA,NA
 . . . . .,NA,NA
 .data ,NA,NA
tip:    .word   15          # tip rate in percent ,NA,NA
tax:    .word    8          # tax rate in percent,NA,NA
"prompt: .asciiz ""Enter food cost: "" ",NA,NA
"head1 : .asciiz ""   Tax plus tip: "" ",NA,NA
"head2 : .asciiz ""     Total cost: "" ",NA,NA
# end of file,NA,NA
QUESTION 11:,NA,NA
Fill in the blanks to complete the calculation section. ,NA,NA
A good answer might be:,NA,NA
 # Calculations,NA,NA
" lw      $s1,",NA,NA
tip,NA,NA
          # get tip rate,NA,NA
" lw      $s2,",NA,NA
tax,NA,NA
          # get tax rate,NA,NA
" addu    $s3,$s1,$s2      # total rate ",NA,NA
mul,NA,NA
"     $s4,$s0,$s3      # 100*(tax + tip) ",NA,NA
div,NA,NA
"     $s4,$s4,100      # tax + tip ",NA,NA
addu,NA,NA
"    $s5,$s0,$s4      # total bill",NA,NA
Writting out the Results,NA,NA
The final section of the program writes the results to the monitor. ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
##    $s0 meal cost ,NA,NA
##    $s1 tip rate ,NA,NA
##    $s2 tax rate ,NA,NA
##    $s3 total rate ,NA,NA
##    $s4 tax+tip dollars ,NA,NA
##    $s5 total bill,NA,NA
 # Output,NA,NA
" ____    $v0,4            # print string",NA,NA
" ____    $a0,head1        # ""tax plus tip""",NA,NA
 syscall,NA,NA
" ____    $a0,$s4          # get tax+tip",NA,NA
" li      $v0,1            # print integer",NA,NA
 syscall                  # ,NA,NA
" ____    $v0,4            # print string",NA,NA
" ____    $a0,head2        # ""total cost""",NA,NA
 syscall,NA,NA
" ____    $a0,$s5          # get total",NA,NA
" ____    $v0,1            # print integer",NA,NA
 syscall                  # ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_12.html (1 of 2) [8/8/2545 10:46:24],NA
" li      $v0,10           # exit",NA,NA
 syscall,NA,NA
 .data ,NA,NA
tip:    .word   15               # tip rate in percent ,NA,NA
tax:    .word    8               # tax rate in percent,NA,NA
"prompt: .asciiz ""Enter food cost: "" ",NA,NA
"head1 : .asciiz ""   Tax plus tip: "" ",NA,NA
"head2 : .asciiz ""\n     Total cost: """,NA,NA
QUESTION 12:,NA,NA
Fill in the blanks to complete the program ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Complete Program,NA,NA
## rest.asm ,NA,NA
## ,NA,NA
## Total restaurant bill calculator ,NA,NA
## ,NA,NA
## Register Use: ,NA,NA
## ,NA,NA
##    $s0 meal cost ,NA,NA
##    $s1 tip rate ,NA,NA
##    $s2 tax rate ,NA,NA
##    $s3 total rate ,NA,NA
##    $s4 tax+tip dollars ,NA,NA
##    $s5 total bill,NA,NA
 .globl  main,NA,NA
 # Get meal cost ,NA,NA
"main:   li      $v0,4            # print prompt",NA,NA
" la      $a0,prompt   ",NA,NA
 syscall,NA,NA
" li      $v0,5            # input meal cost",NA,NA
 syscall,NA,NA
" move    $s0,$v0          # save it in $s0",NA,NA
 # Calculations,NA,NA
" lw      $s1,tip          # get tip rate",NA,NA
" lw      $s2,tax          # get tax rate",NA,NA
" addu    $s3,$s1,$s2      # total rate",NA,NA
" mul     $s4,$s0,$s3      # 100*(tax + tip)",NA,NA
" div     $s4,$s4,100      # tax + tip  ",NA,NA
" addu    $s5,$s0,$s4      # total bill",NA,NA
 # Output,NA,NA
" li      $v0,4            # print string",NA,NA
" la      $a0,head1        # ""tax plus tip""",NA,NA
 syscall,NA,NA
" move    $a0,$s4          # get tax+tip",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_13.html (1 of 2) [8/8/2545 10:46:58],NA
" li      $v0,1            # print integer",NA,NA
 syscall                  # ,NA,NA
" li      $v0,4            # print string",NA,NA
" la      $a0,head2        # ""total cost""",NA,NA
 syscall,NA,NA
" move    $a0,$s5          # get total",NA,NA
" li      $v0,1            # print integer",NA,NA
 syscall                  # ,NA,NA
" li      $v0,10           # exit",NA,NA
 syscall,NA,NA
 .data ,NA,NA
tip:    .word   15               # tip rate in percent ,NA,NA
tax:    .word    8               # tax rate in percent,NA,NA
"prompt: .asciiz ""Enter food cost: "" ",NA,NA
"head1 : .asciiz ""   Tax plus tip: "" ",NA,NA
"head2 : .asciiz ""\n     Total cost: "" ",NA,NA
# end of file,NA,NA
The program is complete and can be copied into your program editor for running and play. ,NA,NA
Remember to indicate in the SPIM settings to allow pseudoinstructions and to load the trap ,NA,NA
file. ,NA,NA
QUESTION 13:,NA,NA
What is the bit pattern in register $t1 after the following: ,NA,NA
"li   $t0,0x12345678 ",NA,NA
"sll  $t1,$t0,8",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_13.html (2 of 2) [8/8/2545 10:46:58],NA
What is the bit pattern in register $t1 after the following: ,NA,NA
"li   $t0,0x12345678 ",NA,NA
"sll  $t1,$t0,8",NA,NA
A good answer might be: ,NA,NA
Register $t1 will contain 0x34567800 ,NA,NA
Bit Pattern Rotation,NA,NA
"With a shift left instruction, the ",NA,NA
bits at the left end of the the ,NA,NA
"register ""fall off"". The bits shifted ",NA,NA
into the right end are always ,NA,NA
zero bits. ,NA,NA
"With a rotate left instruction, the ",NA,NA
bits at the left end of the the ,NA,NA
register are fed into the right end ,NA,NA
of the register. The 32-bit ,NA,NA
register always contains the ,NA,NA
same 32-bit values it started ,NA,NA
"with, but they are rotated into ",NA,NA
new positions. ,NA,NA
"In the illustration, after rotating ",NA,NA
left one bit the bit pattern ,NA,NA
changes from ,NA,NA
10100111,NA,NA
 to ,NA,NA
01001111,NA,NA
. An additional left ,NA,NA
rotate changes the pattern to ,NA,NA
10011110,NA,NA
. ,NA,NA
"Of course, registers have 32 bits, not the eight bits shown in the illustration. ",NA,NA
"A rotate right instruction, Works about the same, except that bit values in the register are ",NA,NA
moved right. Bits at the right end of the register are fed back into the left end of the register. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_14.html (1 of 2) [8/8/2545 10:47:38],NA
QUESTION 14:,NA,NA
Rotate right the following bit pattern by ,NA,NA
two,NA,NA
 bit positions: ,NA,NA
11001100,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_14.html (2 of 2) [8/8/2545 10:47:38],NA
Rotate right the following bit pattern by ,NA,NA
two,NA,NA
 bit positions: ,NA,NA
11001100,NA,NA
A good answer might be: ,NA,NA
00110011,NA,NA
Rotate Instructions,NA,NA
The rotate instructions are both pseudoinstructions. Each one takes four basic instructions ,NA,NA
"to implement. The shift amount is given in a register, the third operand of the instruction. ",NA,NA
"rol d,s,t    # d <-- s rotated left by t",NA,NA
 # (pseudoinstruction),NA,NA
"ror d,s,t    # d <-- s  rotated right by t",NA,NA
 # (pseudoinstruction),NA,NA
QUESTION 15:,NA,NA
Would a ,NA,NA
ror,NA,NA
" instruction ordinarily be used for arithmetic? For example, ",NA,NA
would... ,NA,NA
"li  $t2,2 ",NA,NA
"ror $t0,$t1,$t2",NA,NA
...be a good way to divide $t1 by four? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_15.html [8/8/2545 10:47:47],NA
"li  $t2,2 ",NA,NA
"ror $t0,$t1,$t2",NA,NA
A good answer might be: ,NA,NA
"No, because a rotate instruction is likely to rotate some low-order one bits into high ",NA,NA
"order positions, which would greatly affect the result. ",NA,NA
End of Chapter,NA,NA
"You have reached the end of this chapter. Unless your head is rotating, click on a blue ",NA,NA
"subject to go to where it was discussed. To get back here, click on the ""back arrow"" button ",NA,NA
of your browser. ,G,NA
not,NA,NA
 pseudoinstruction ,G,NA
Implicit,NA,NA
 immediate operands ,G,NA
addu,NA,NA
 pseudoinstruction ,G,NA
subu,NA,NA
 pseudoinstruction ,G,NA
mul,NA,NA
 pseudoinstruction ,G,NA
div,NA,NA
 pseudoinstruction ,G,NA
remu,NA,NA
 pseudoinstruction ,G,NA
negu,NA,NA
 pseudoinstruction ,G,NA
abs,NA,NA
 pseudoinstruction ,G,NA
Bit rotation.,G,NA
Rotate,NA,NA
 pseudoinstructions. ,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-23/ass23_16.html [8/8/2545 10:47:58],NA
CHAPTER 24— Branch and Comparison ,NA,NA
Pseudoinstructions,NA,NA
The MIPS hardware has several instructions for branching and looping. These fundamental ,NA,NA
instructions are used in to create many pseudoinstructions that give added flexibility. ,NA,NA
Chapter Topics:,G,NA
Branch instructions ,G,NA
Immediate operands in branch instructions ,G,NA
Set instructions ,G,NA
Indexed Addressing ,G,NA
Byte arrays ,G,NA
Integer arrays,NA,NA
QUESTION 1:,NA,NA
(Review:) What is an conditional branch? ,NA,NA
A good answer might be: ,NA,NA
An conditional branch tests a condition then changes the PC if the condition is true (for ,NA,NA
"example, the instruction ",NA,NA
beq label,NA,NA
). ,NA,NA
Branch Equal to Zero,NA,NA
The extended assembler implements several conditional branch instructions beyond the ,NA,NA
basic ones. For example: ,NA,NA
"beqz    rs,label          # branch to label if register rs==0",NA,NA
"The hardware does not have a machine instruction for this operation. It does, however, ",NA,NA
have a zero register and the ,NA,NA
beq,NA,NA
 instruction (branch equal). ,NA,NA
QUESTION 2:,NA,NA
Fill in the blanks so the branch is taken if $rs is zero. ,NA,NA
"______    rs,________,label          # branch to label if register rs==0",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_2.html [8/8/2545 11:04:04],NA
A good answer might be: ,NA,NA
beq,NA,NA
"    rs,",NA,NA
$0,NA,NA
",label          # branch to label if register rs==0",NA,NA
Unconditional Branch Instruction,NA,NA
The pseudocomputer has an ,NA,NA
unconditional branch,NA,NA
 instruction that always causes a ,NA,NA
branch. The mnemonic for the instruction is ,NA,NA
b,NA,NA
: ,NA,NA
b     label    # branch to label ,NA,NA
This instruction behaves like the jump instruction: it unconditionally loads the PC with the ,NA,NA
address specified by ,NA,NA
label,NA,NA
". Unlike the jump instruction, the branch target ",NA,NA
label,NA,NA
 must be ,NA,NA
"relatively close to the branch instruction, as is true with all branch instructions. The 32-bit ",NA,NA
address is computed using a 16 bit offset in the instruction and the current value of the PC. ,NA,NA
QUESTION 3:,NA,NA
The extended assembler implements the ,NA,NA
b,NA,NA
 instruction using the ,NA,NA
beq ,NA,NA
instruction. Fill in the blanks to show what it does: ,NA,NA
"b  label         == beq  _____,_____,offset",NA,NA
Offset is the 16-bit offset that is added to the PC to calculate ,NA,NA
label,NA,NA
 (if possible). ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_3.html [8/8/2545 11:04:11],NA
A good answer might be: ,NA,NA
"b  label         == beq  $0,$0,offset",NA,NA
Table of Branch Instructions,NA,NA
Here is a table of some branch instructions. There are other branch instrucions concerned ,NA,NA
with subroutine linkage. Some instructions assume 32-bit two's complement data; others ,NA,NA
assume 32-bit unsigned data. Some instructions don't assume any data format. ,NA,NA
The first operand ,NA,NA
s,NA,NA
 must be a register. The second operand ,NA,NA
t,NA,NA
 may be a register or a ,NA,NA
immediate operand (the extended assembler will generate the correct basic instructions ,NA,NA
depending on which you choose). ,NA,NA
Mnemonic,NA,NA
Operands,NA,NA
Description,NA,NA
signed or ,NA,NA
unsigned?,NA,NA
b,NA,NA
label,NA,NA
branch,NA,NA
beq,NA,NA
"s,t,label",NA,NA
branch if s==t,NA,NA
beqz,NA,NA
"s,label",NA,NA
branch if s==0,NA,NA
bge,NA,NA
"s,t,label",NA,NA
branch if s>=t,NA,NA
signed ,NA,NA
bgeu,NA,NA
"s,t,label",NA,NA
branch if s>=t,NA,NA
unsigned ,NA,NA
bgez,NA,NA
"s,label",NA,NA
branch if s>=0,NA,NA
signed ,NA,NA
bgt,NA,NA
"s,t,label",NA,NA
branch if s>t,NA,NA
signed ,NA,NA
bgtu,NA,NA
"s,t,label",NA,NA
branch if s>t,NA,NA
unsigned ,NA,NA
bgtz,NA,NA
"s,label",NA,NA
branch if s>0,NA,NA
signed ,NA,NA
ble,NA,NA
"s,t,label",NA,NA
branch if s<=t,NA,NA
signed ,NA,NA
bleu,NA,NA
"s,t,label",NA,NA
branch if s<=t,NA,NA
unsigned ,NA,NA
blez,NA,NA
"s,label",NA,NA
branch if s<=0,NA,NA
signed ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_4.html (1 of 2) [8/8/2545 11:04:23],NA
blt,NA,NA
"s,t,label",NA,NA
branch if s<t,NA,NA
signed ,NA,NA
bltu,NA,NA
"s,t,label",NA,NA
branch if s<t,NA,NA
unsigned ,NA,NA
bltz,NA,NA
"s,label",NA,NA
branch if s<0,NA,NA
signed ,NA,NA
bne,NA,NA
"s,t,label",NA,NA
branch if s=/=t,NA,NA
bnez,NA,NA
"s,label",NA,NA
branch if s=/=0,NA,NA
"Some of the pseudoinstructions use the assembler temporary register ($at, or register $1) in ",NA,NA
the one or two basic instructions they are expanded to. ,NA,NA
QUESTION 4:,NA,NA
What format of data is assumed for the ,NA,NA
bne,NA,NA
 (branch not equal) instruction? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_4.html (2 of 2) [8/8/2545 11:04:23],NA
A good answer might be: ,NA,NA
No assumptions are necessary. It tests if two bit patterns are identical. ,NA,NA
Natural If-Else Structure,NA,NA
When you use only the basic branching instructions sometimes you have to implement an if-,NA,NA
else structure with the false branch immediately following the conditional branch. This is not ,NA,NA
how high level programming languages do it and this sometimes is awkward. Here is a ,NA,NA
program fragment that is to add the value in register $t0 to register $t2 (if $t0 is even) and to ,NA,NA
$t1 (if $t0 is odd): ,NA,NA
" lw    $t0,val          # $t0 has the value",NA,NA
" andi  $t8,$t0,1        # one's place is zero or one",NA,NA
" ____  $t8,odd          # if even",NA,NA
" addu  $t2,$t0,$t0      #     add to even sum",NA,NA
 b     ,NA,NA
endif ,NA,NA
odd:                           # else,NA,NA
" addu  $t1,$t0,$t0      #     add to odd sum ",NA,NA
endif:,NA,NA
The unconditional branch instruction is used at the bottom of the true branch of the if-else. ,NA,NA
QUESTION 5:,NA,NA
Fill in the blank by choosing the correct branch instruction. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_5.html [8/8/2545 11:04:25],NA
A good answer might be:,NA,NA
" lw    $t0,val          # $t0 has the value",NA,NA
" andi  $t8,$t0,1        # one's place is zero or one ",NA,NA
bnez,NA,NA
"  $t8,odd          # if even",NA,NA
" addu  $t2,$t0,$t0      #     add to even sum",NA,NA
 b     endif ,NA,NA
odd:                           # else,NA,NA
" addu  $t1,$t0,$t0      #     add to odd sum ",NA,NA
endif:,NA,NA
Immediate Operand in Branch,NA,NA
"If a branch instruction has a second operand, it can be an immediate operand or a register. ",NA,NA
"For example, from the table: ",NA,NA
bge,NA,NA
"s,t,label",NA,NA
branch if s>=t,NA,NA
signed ,NA,NA
Here are examples: ,NA,NA
"bge    $t1,$t2,spot     # if ( $t1 >= $t2 ) goto spot ",NA,NA
"bge    $t1,23,spot      # if ( $t1 >= 23  ) goto spot ",NA,NA
"bge    $t1,-98,here     # if ( $t1 >= -98 ) goto here ",NA,NA
"bge    12,$t1,oops      # WRONG: first op must be a register ",NA,NA
"bge    $t1,value,there  # WRONG: second op can't be a symbolic address",NA,NA
Sometimes the mnemonic corresponds to a basic instrucion (for example ,NA,NA
beq,NA,NA
). However if ,NA,NA
the second operand is an immediate operand then the result is a pseudoinstruction. ,NA,NA
QUESTION 6:,NA,NA
Is the following instruction correct? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_6.html (1 of 2) [8/8/2545 11:04:31],NA
"bge     $t1,-67,spot     # if ( $t1 >= -67 ) goto spot",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_6.html (2 of 2) [8/8/2545 11:04:31],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Example Program,NA,NA
Let us write a program that reads integers from the user and adds up those integers x that ,NA,NA
are in the range ,NA,NA
-32 <= x <= +32,NA,NA
 and discards the rest. The user signals the end by ,NA,NA
entering -999 (which is not added to the sum). Here is the basic outline: ,NA,NA
main: ,NA,NA
" li    $v1,0            # zero the sum ",NA,NA
loop:,NA,NA
 . . . .,NA,NA
" li    $v0,5            # read the integer",NA,NA
 syscall                # into $v0,NA,NA
____,NA,NA
"  $v0,",NA,NA
____,NA,NA
"9,done   # while ( $v0 =/= -999 )",NA,NA
 # ,NA,NA
____,NA,NA
"  $v0,",NA,NA
____,NA,NA
",out     # less than -32",NA,NA
____,NA,NA
"  $v0,",NA,NA
____,NA,NA
",out     # greather than 32",NA,NA
" addu  $v1,$v1,$v0      # if in range add           ",NA,NA
 # else skip ,NA,NA
out:    b     loop ,NA,NA
done:   . . . .,NA,NA
QUESTION 7:,NA,NA
Fill in the blanks ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_7.html [8/8/2545 11:04:44],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Blanks Filled,NA,NA
The outline is completed below. Detecting the end of input (by testing for a sentinel value) is ,NA,NA
usually regarded as poor style. ,NA,NA
main: ,NA,NA
" li    $v1,0            # zero the sum ",NA,NA
loop:,NA,NA
 . . . .,NA,NA
" li    $v0,5            # read the integer",NA,NA
 syscall                # into $v0,NA,NA
beq,NA,NA
"    $v0,",NA,NA
-999,NA,NA
",done   # while ( $v0 =/= -999 )",NA,NA
 # ,NA,NA
blt,NA,NA
"    $v0,",NA,NA
-32 ,NA,NA
",out        # less than -32 ",NA,NA
bgt,NA,NA
"    $v0,",NA,NA
32 ,NA,NA
",out         # greather than 32",NA,NA
" addu  $v1,$v1,$v0          # if in range add           ",NA,NA
 # else skip ,NA,NA
out:    b     loop ,NA,NA
done:   . . . .,NA,NA
QUESTION 8:,NA,NA
(Memory Test: ) What do ,NA,NA
set,NA,NA
 instructions do on MIPS? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_8.html [8/8/2545 11:04:47],NA
A good answer might be: ,NA,NA
Set instructions set a register to 1 or clear it to 0 to show the outcome of a comparison ,NA,NA
between two values. ,NA,NA
Set on Less Than,NA,NA
Here (for review) is the ,NA,NA
slt,NA,NA
 from chapter 18: ,NA,NA
 #  $s and $t contain   ,NA,NA
 #  two's comp. integers,NA,NA
 # ,NA,NA
"slt   d,s,t        #  if ( $s < $t )",NA,NA
 #    d <-- 1,NA,NA
 #  else,NA,NA
 #    d <-- 0,NA,NA
"However, now that we are using the extended assembler, the operand ",NA,NA
t,NA,NA
 can be an ,NA,NA
immediate operand. ,NA,NA
QUESTION 9:,NA,NA
Is the following correct? ,NA,NA
"slt   $t5,$v0,87        #  if ( $v0 < 87 ) $t5 <-- 1",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_9.html [8/8/2545 11:04:52],NA
A good answer might be: ,NA,NA
Yes ,NA,NA
Table of Set Instructions,NA,NA
Here is a table of set instructions. Most of ,NA,NA
them are pseudoinstructions. The ,NA,NA
t ,NA,NA
operand can be an immediate operand. ,NA,NA
The ,NA,NA
Imm,NA,NA
 operand must be an immediate ,NA,NA
operand. ,NA,NA
The extended assembler outputs the ,NA,NA
correct basic instructions depending on ,NA,NA
the mnemonic and the operands. ,NA,NA
Sometimes there are several ways in ,NA,NA
which the same basic instructions can be ,NA,NA
specified. ,NA,NA
Some of the instructions are intended for ,NA,NA
"integers expressed in unsigned binary, ",NA,NA
other instructions are for integers in two's ,NA,NA
"complement, and for others it makes no ",NA,NA
difference. ,NA,NA
Mnemonic,NA,NA
Operands,NA,NA
Description,NA,NA
signed or ,NA,NA
unsigned?,NA,NA
seq,NA,NA
"d,s,t",NA,NA
set d if s==t,NA,NA
sge,NA,NA
"d,s,t",NA,NA
set d if s>=t,NA,NA
signed ,NA,NA
sgeu,NA,NA
"d,s,t",NA,NA
set d if s>=t,NA,NA
unsigned ,NA,NA
sgt,NA,NA
"d,s,t",NA,NA
set d if s> t,NA,NA
signed ,NA,NA
sgtu,NA,NA
"d,s,t",NA,NA
set d if s> t,NA,NA
unsigned ,NA,NA
sle,NA,NA
"d,s,t",NA,NA
set d if s<=t,NA,NA
signed ,NA,NA
sleu,NA,NA
"d,s,t",NA,NA
set d if s<=t,NA,NA
unsigned ,NA,NA
slt,NA,NA
"d,s,t",NA,NA
set d if s< t,NA,NA
signed ,NA,NA
slti,NA,NA
"d,s,Imm",NA,NA
set d if s< Imm,NA,NA
signed ,NA,NA
sltu,NA,NA
"d,s,t",NA,NA
set d if s< t,NA,NA
unsigned ,NA,NA
sltiu,NA,NA
"d,s,Imm",NA,NA
set d if s< Imm,NA,NA
unsigned ,NA,NA
sne,NA,NA
"d,s,t",NA,NA
set d if s< t,NA,NA
QUESTION 10:,NA,NA
Do you think that the following two pseudoinstructions translate into the ,NA,NA
same basic instructions? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_10.html (1 of 2) [8/8/2545 11:05:04],NA
"sltu $t4,$v0,45 ",NA,NA
and ,NA,NA
"sltui $t4,$v0,45 ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_10.html (2 of 2) [8/8/2545 11:05:04],NA
"sltu $t4,$v0,45 ",NA,NA
and ,NA,NA
"sltui $t4,$v0,45 ",NA,NA
A good answer might be: ,NA,NA
Yes. The first translates into the second. ,NA,NA
Indexed Addressing,NA,NA
"In addition to implementing new instructions, the extended assembler implements a new ",NA,NA
addressing mode. This is ,NA,NA
indexed addressing,NA,NA
", a mode of addressing very useful for ",NA,NA
arrays. Here is an example: ,NA,NA
" li    $t1,2                 # index 2",NA,NA
" lb    $v0,data($t1)         # $v0 = data[$t1] ",NA,NA
. . . ,NA,NA
"data: .byte  6,34,12,-32, 90      # index zero is first",NA,NA
Think of the words beginning at ,NA,NA
data,NA,NA
 as an array of five bytes. Then the ,NA,NA
lw,NA,NA
 instruction loads ,NA,NA
the element of the array at index 2 (the byte that contains 12) into ,NA,NA
$v0,NA,NA
. ,NA,NA
The extended assembler does this the same way we have done in in past programs: basic ,NA,NA
instructions are used to add the index value in ,NA,NA
$t1,NA,NA
 to the address symbolized by ,NA,NA
data,NA,NA
. Here ,NA,NA
is what the assembler generates for the above code: ,NA,NA
" ori   $t1,$0,2           # index 2",NA,NA
" lui   $at,4097           # $at register gets address ""data"" ",NA,NA
"addu  $at,$at,$t1        # add index to $at",NA,NA
" lb    $v0,0($at)         # $v0 = data[$t1]",NA,NA
 . . . ,NA,NA
"data: .byte  6,34,12,-32, 90 ",NA,NA
The assembler generates code that uses register ,NA,NA
$at,NA,NA
 to calculate the address of the correct ,NA,NA
"byte. Then, using that address, the byte is loaded into ",NA,NA
$v0,NA,NA
. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_11.html (1 of 2) [8/8/2545 11:05:20],NA
QUESTION 11:,NA,NA
When does the actual address calculation take place? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_11.html (2 of 2) [8/8/2545 11:05:20],NA
A good answer might be: ,NA,NA
When the code that the assembler generates is actually executing. ,NA,NA
Four Levels,NA,NA
"This is a very ""Computer Science""-like idea. It takes some careful thought to see what is ",NA,NA
going on. Here is a table: ,NA,NA
What the programmer ,NA,NA
writes,NA,NA
What the extended ,NA,NA
assembler translates it ,NA,NA
into,NA,NA
What the basic ,NA,NA
assembler does,NA,NA
What happens at ,NA,NA
run time,"li    $t1,2 
  
 lb    $v0,data($t1) 
  
  
  
 ori   $t1,$0,2 
  
 lui   $at,4097 
  
 addu  $at,$at,$t1 
  
 lb    $v0,0($at)",NA
(4097 is the upper half of ,NA,NA
the address of data.) ,NA,NA
The basic ,NA,NA
assembly language ,NA,NA
is translated into ,NA,NA
machine code. ,"34090002 
  
 3c011001 
  
 00290821 
  
 80220000",NA
The first three ,NA,NA
machine ,NA,NA
instructions ,NA,NA
"execute, placing ",NA,NA
the address of the ,NA,NA
third byte of the ,NA,NA
array into register ,NA,NA
$1. The fourth ,NA,NA
machine ,NA,NA
instruction load ,NA,NA
the byte at that ,NA,NA
address into ,NA,NA
register $2 ($v0). ,NA,NA
QUESTION 12:,NA,NA
"At what index do ""C"" and Java arrays begin? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_12.html [8/8/2545 11:05:34],NA
A good answer might be: ,NA,NA
Index zero ,NA,NA
Indexes start at Zero,NA,NA
Experience has shown that indexing arrays starting at zero works best. The first element of ,NA,NA
an array is at a displacement of zero from the beginning of the array. To move through an ,NA,NA
array start the index at zero and increment it by the element size to move to the next ,NA,NA
element. ,NA,NA
Here is a program fragment that adds up all the bytes in the array: ,NA,NA
" li    $v1,0              # zero the sum",NA,NA
" li    $t1,0              # init index to 0",NA,NA
" li    $t2,0              # init loop counter ",NA,NA
"for:    beq   $t2,5,endfor       # for ( i=0; i < 5 ;i++ )",NA,NA
" lb    $v0,data($t1)",NA,NA
" addu  $v1,$v0,$v0        #     sum = sum+data[i]",NA,NA
" addi  $t1,$t1,1          #     increment index",NA,NA
" addi  $t2,$t2,1          #     increment counter",NA,NA
 b     for,NA,NA
endfor: ,NA,NA
 . . . ,NA,NA
"data: .byte  6,34,12,-32, 90 ",NA,NA
QUESTION 13:,NA,NA
"When indexed addressing is used with an array of 32-bit integers, by how ",NA,NA
much should the index be incremented to move to the next array element? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_13.html [8/8/2545 11:05:53],NA
A good answer might be: ,NA,NA
By four. ,NA,NA
Integer Array,NA,NA
"Here is nearly the same program as before, except that now the program adds up the ",NA,NA
integers in an array of full words (32 bits). The logic is the same as before. ,NA,NA
 .globl  main ,NA,NA
main: ,NA,NA
" li    $v1,0              # zero the sum",NA,NA
" li    $t1,_____          # init index to ???",NA,NA
" li    $t2,0              # init loop counter ",NA,NA
"for:    beq   $t2,5,endfor       # for ( i=0; i < 5 ;i++ )",NA,NA
" l___  $v0,array($t1)",NA,NA
" addu  $v1,$v0,$v0        #     sum = sum+array[i]",NA,NA
" addi  $t1,$t1,_____      #     increment index",NA,NA
" addi  $t2,$t2,_____      #     increment counter",NA,NA
 b     for ,NA,NA
endfor:,NA,NA
" li    $v0,10             # exit",NA,NA
 syscall   ,NA,NA
 .data ,NA,NA
"array:  .word  1,2,3,-5,1",NA,NA
QUESTION 14:,NA,NA
Just fill in the blanks and you have a working program! ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_14.html [8/8/2545 11:06:19],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Complete Program,NA,NA
"Here is a complete program. It is not too distant from what a ""C"" for loop might be compiled ",NA,NA
into. If you copy it to a file and run it with SPIM make sure that pseudoinstrucions are ,NA,NA
allowed and that delayed load and delayed branches are turned off. ,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" li    $v1,0              # zero the sum",NA,NA
" li    $t1,0              # init index to 0",NA,NA
" li    $t2,0              # init loop counter ",NA,NA
"for:    beq   $t2,5,endfor       # for ( i=0; i < 5 ;i++ )",NA,NA
" lw    $v0,array($t1)",NA,NA
" addu  $v1,$v0,$v0        #     sum = sum+array[i]",NA,NA
" addi  $t1,$t1,4          #     increment index",NA,NA
" addi  $t2,$t2,1          #     increment counter",NA,NA
 b     for,NA,NA
endfor:,NA,NA
" li    $v0,10             # exit",NA,NA
 syscall   ,NA,NA
 .data ,NA,NA
"array: .word  1,2,3,-5,1",NA,NA
QUESTION 15:,NA,NA
Some languages (like Pascal) allow the first index of an array to be any ,NA,NA
integer. Can such a language be compiled for MIPS? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_15.html [8/8/2545 11:06:25],NA
A good answer might be: ,NA,NA
Of course. The compiler might not use the indexed addressing mode of the extended ,NA,NA
"assembler, however. ",NA,NA
End of Chapter,NA,NA
You have reached the end this chapter. You may wish to review the following. Click on a ,NA,NA
subject that interests you to go to where it was discussed. ,G,NA
Unconditional branch.,G,NA
Table of branch instructions ,G,NA
Immediate operands in branch instructions ,G,NA
Set instructions ,G,NA
Indexed addressing ,G,NA
How indexed addressing is implemented.,G,NA
Array indexing,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-24/ass24_16.html [8/8/2545 11:06:34],NA
CHAPTER 25 — The Run-time Stack,NA,NA
This chapter discusses the run-time stack and the stack pointer register ,NA,NA
$sp,NA,NA
. ,NA,NA
Chapter Topics:,G,NA
Stacks,G,NA
The stack pointer register ,NA,NA
$sp ,G,NA
Push and Pop stack operations. ,G,NA
The MIPS runtime stack.,G,NA
Compiler use of stacks.,G,NA
String reversal example.,NA,NA
QUESTION 1:,NA,NA
Say that you ,NA,NA
plates. Which one do you normally get? ,NA,NA
need to get a ,NA,NA
plate from a ,NA,NA
stack of dinner ,NA,NA
A good answer might be: ,NA,NA
The top plate. ,NA,NA
Stack,NA,NA
A ,NA,NA
stack,NA,NA
 is a way of organizing ,NA,NA
stack is visualized as behaving like a stack of dinner plates. Data are added and removed ,NA,NA
from the stack data structure in a way analogous to placing ,NA,NA
data in memory. Data items are ,NA,NA
visualized as behaving like a ,NA,NA
stack of physical items. Often a ,NA,NA
plates on the stack of plates and removing them. ,NA,NA
Normally with a stack of dinner plates all operations take place at the top of the stack. If you ,NA,NA
"need a plate, you take the one at the top of the stack. If you add a plate to the stack, you ",NA,NA
place it on top of the stack. ,NA,NA
QUESTION 2:,NA,NA
Which plate of a stack was the last one added that was added? Which plate ,NA,NA
will be the first one removed? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_2.html [8/8/2545 11:12:00],NA
A good answer might be: ,NA,NA
The plate at the top of the stack was the last one added. It will also be the first one ,NA,NA
removed. ,NA,NA
Upsidedown MIPS Stack,NA,NA
"Stack-like behavior is sometimes called ""LIFO"" for ",NA,NA
Last In First Out. ,NA,NA
Our stacks are stacks of 32-bit words. In a course ,NA,NA
"on data structures, stacks are used for all types of ",NA,NA
"data. But for these chapters, stacks contain only 32-",NA,NA
bit MIPS full words. ,NA,NA
The picture shows a stack of MIPS full words. The ,NA,NA
stack pointer register,NA,NA
$sp,NA,NA
 by convention points at ,NA,NA
the top item of the stack. The stack pointer is ,NA,NA
register ,NA,NA
$29,NA,NA
 by software convention. The mnemonic ,NA,NA
register name ,NA,NA
$sp,NA,NA
 is used by the extended ,NA,NA
assembler. ,NA,NA
"In the usual way of drawing memory the stack is upside down. In the picture, the top item of ",NA,NA
the stack is 81. The bottom of the stack contains the integer -92. ,NA,NA
Before the operating system starts your program it ensures that there is a range of memory ,NA,NA
for a stack and puts a suitable address into ,NA,NA
$sp,NA,NA
. ,NA,NA
QUESTION 3:,NA,NA
"If an item of data (say the value 103) is added to the stack, where will it go? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_3.html [8/8/2545 11:12:15],NA
A good answer might be: ,NA,NA
After the 81. The 103 is now the top of the stack. ,NA,NA
Push,NA,NA
"By software convention, ",NA,NA
$sp,NA,NA
 always points to ,NA,NA
push,NA,NA
 operation. ,NA,NA
To ,NA,NA
push,NA,NA
" an item onto a stack, first ",NA,NA
subtract,NA,NA
" 4 from the stack pointer, then store the item ",NA,NA
at the address in the stack pointer. ,NA,NA
"the top of the stack. Also by convention, the ",NA,NA
stack grows downward (in terms of memory ,NA,NA
"addresses). So, for our stack of 4-byte (full ",NA,NA
"word) data, adding an item means ",NA,NA
subtracing four from ,NA,NA
$sp,NA,NA
 and storing the item ,NA,NA
in that address. This operation is called a ,NA,NA
 # PUSH the item in $t0 ,NA,NA
"sub $sp,$sp,4      # point to place for new item ",NA,NA
"sw  $t0,($sp)      # store $t0 as the new top",NA,NA
QUESTION 4:,NA,NA
"In the new stack (above) if one item is removed, which will it be? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_4.html [8/8/2545 11:12:23],NA
A good answer might be: ,NA,NA
103 ,NA,NA
Pop,NA,NA
Removing an item from a stack is called a ,NA,NA
pop,NA,NA
 operation. In the real-world analogy an ,NA,NA
item is actually removed: a dish is physically ,NA,NA
"moved from the stack. In a software stack, ",NA,NA
"""removal"" of an item means it is copied to ",NA,NA
another location and the stack pointer is ,NA,NA
adjusted. ,NA,NA
The picture shows a pop operation. The data ,NA,NA
is first copied from the top of stack to the new ,NA,NA
location and then the stack pointer is ,NA,NA
increased by four. ,NA,NA
To ,NA,NA
pop,NA,NA
" the top item from a stack, copy ",NA,NA
"the item pointed at by the stack pointer, ",NA,NA
then ,NA,NA
add,NA,NA
 4 from the stack pointer. ,NA,NA
Here is what that looks like in code. Say that we want the value to be popped into ,NA,NA
$t0,NA,NA
: ,NA,NA
 # POP the item into $t0 ,NA,NA
"lw  $t0,($sp)      # copy top item to $t0 ",NA,NA
"add $sp,$sp,4      # point item beneath old top",NA,NA
QUESTION 5:,NA,NA
"When a software stack is popped, does the popped item remain in memory? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_5.html [8/8/2545 11:12:37],NA
A good answer might be: ,NA,NA
"Yes. The data is copied to a new location, but the old location is not changed. However, ",NA,NA
"since the stack pointer is moved, ""logically"" the data is no longer on the stack. ",NA,NA
Example,NA,NA
The stack is often used to hold temporary values when there are not enough registers. This ,NA,NA
is common in the code that a compiler outputs for evaluating arithmetic expressions. Here is ,NA,NA
an example of this. The program evaluates the expression ,NA,NA
ab - 12a + 18b - 7,NA,NA
. Pretend that ,NA,NA
only ,NA,NA
$t0,NA,NA
 and ,NA,NA
$t1,NA,NA
" are available, and that the stack pointer ",NA,NA
$sp,NA,NA
 has been initialized properly by ,NA,NA
an operating system. ,NA,NA
Here is the start of the program: ,NA,NA
# Evaluate the expression ab - 12a + 18b - 7,NA,NA
main: ,NA,NA
" lw      $t0,a          # get a",NA,NA
" lw      $t1,bb         # get b",NA,NA
" mul     $t0,$t0,$t1    # a*b",NA,NA
" sub     $sp,$sp,_____  # push a*b onto stack",NA,NA
" sw      $t0,______",NA,NA
 . . . . .,NA,NA
 .data ,NA,NA
a:      2 ,NA,NA
bb:     3,NA,NA
QUESTION 6:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_6.html [8/8/2545 11:12:52],NA
A good answer might be: ,NA,NA
See below: ,NA,NA
Program Continued,NA,NA
Terms of the expression are pushed onto the stack as they are evaluated. Then the sum is ,NA,NA
initialized to -7 and the terms on the stack are popped and added to the sum. ,NA,NA
# Evaluate the expression ab - 12a + 18b - 7,NA,NA
 .globl  main,NA,NA
" lw      $t0,a          # get a",NA,NA
" lw      $t1,bb         # get b",NA,NA
" mul     $t0,$t0,$t1    # a*b",NA,NA
" sub     $sp,$sp,4      # push a*b onto stack ",NA,NA
"sw      $t0,($sp)",NA,NA
" lw      $t0,a          # get a",NA,NA
" li      $t1,-12        # ",NA,NA
" mul     $t0,$t0,$t1    # -12a",NA,NA
" sub     $sp,$sp,4      # push -12a onto stack ",NA,NA
"sw      $t0,($sp)",NA,NA
" lw      $t0,bb         # get b",NA,NA
" li      $t1,18         # ",NA,NA
" mul     $t0,$t0,$t1    # 18b",NA,NA
" sub     $sp,$sp,4      # push 18b onto stack ",NA,NA
"sw      $t0,($sp)",NA,NA
" li      $t1,-7         # init sum to -7",NA,NA
" lw      $t0,_____      # pop 18b",NA,NA
" add     $sp,$sp,______",NA,NA
" add     $t1,$t1,$t0    # 18b -7",NA,NA
 . . . .,NA,NA
QUESTION 7:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_7.html (1 of 2) [8/8/2545 11:13:02],NA
Fill in the blanks to pop the ,NA,NA
18b,NA,NA
 term. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_7.html (2 of 2) [8/8/2545 11:13:02],NA
A good answer might be: ,NA,NA
See below ,NA,NA
Finished Program,NA,NA
Here is the finished program. It is not how you would write a practical program to evaluate ,NA,NA
the arithmetic expression. But it is similar to a section of a larger program (with many ,NA,NA
registers in use) that needs to do that and only has a few registers available. ,NA,NA
# Evaluate the expression ab - 12a + 18b - 7 # ,NA,NA
SPIM settings: allow pseudo; load trap file; #                ,NA,NA
no delayed branch; no delayed load,NA,NA
 .globl  main,NA,NA
main: ,NA,NA
" lw      $t0,a          # get a",NA,NA
" lw      $t1,bb         # get b",NA,NA
" mul     $t0,$t0,$t1    # a*b",NA,NA
" sub     $sp,$sp,4      # push a*b onto stack ",NA,NA
"sw      $t0,($sp)",NA,NA
" lw      $t0,a          # get a",NA,NA
" li      $t1,-12        # ",NA,NA
" mul     $t0,$t0,$t1    # -12a",NA,NA
" sub     $sp,$sp,4      # push -12a onto stack ",NA,NA
"sw      $t0,($sp)",NA,NA
" lw      $t0,bb         # get b",NA,NA
" li      $t1,18         # ",NA,NA
" mul     $t0,$t0,$t1    # 18b",NA,NA
" sub     $sp,$sp,4      # push 18b onto stack ",NA,NA
"sw      $t0,($sp)",NA,NA
" li      $t1,-7         # init sum to -7",NA,NA
" lw      $t0,($sp)      # pop 18b",NA,NA
" add     $sp,$sp,4",NA,NA
" add     $t1,$t1,$t0    # 18b -7",NA,NA
" lw      $t0,($sp)      # pop -12a",NA,NA
" add     $sp,$sp,4",NA,NA
" add     $t1,$t1,$t0    # -12a + 18b -7",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_8.html (1 of 2) [8/8/2545 11:13:24],NA
" lw      $t0,($sp)      # pop ab",NA,NA
" add     $sp,$sp,4",NA,NA
" add     $t1,$t1,$t0    # ab - 12a + 18b -7",NA,NA
"done:   li      $v0,1          # print sum",NA,NA
" move    $a0,$t1",NA,NA
 syscall,NA,NA
" li      $v0,10         # exit",NA,NA
 syscall   ,NA,NA
 .data ,NA,NA
a:      .word  0 ,NA,NA
bb:     .word  10,NA,NA
QUESTION 8:,NA,NA
(Thought Question:) Is it possible to run out of memory if too many things are ,NA,NA
pushed onto the stack? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_8.html (2 of 2) [8/8/2545 11:13:24],NA
A good answer might be:,NA,NA
Yes. ,NA,NA
Run-time Stack,NA,NA
"There is a finite amount of memory, even in the best ",NA,NA
segment and the stack segment. This is 1.8 Gigabytes of ,NA,NA
space. ,NA,NA
When the program is started the stack pointer (,NA,NA
$sp,NA,NA
") is initialized to 0x7FFFFFFF. As the program runs, ",NA,NA
the stack grows downward into the available space. The data segment grows upward as the program runs. ,NA,NA
"Of course, in a dynamic program, the segments grow and shrink. If the combined size of the segments ",NA,NA
exceeds the available space their boundaries will meet somewhere in the middle of the range. When this ,NA,NA
happens there is no memory left. ,NA,NA
computer systems. So it is possible to push more words ,NA,NA
than there are words of memory. Usually this would be the ,NA,NA
result of an infinite loop because when a program is first ,NA,NA
entered the operating system gives it space for a very large ,NA,NA
stack. ,NA,NA
The picture shows how a typical operating system arranges ,NA,NA
memory when a program starts. There are four gigabytes of ,NA,NA
(virtual) memory available in total. The section of memory ,NA,NA
from 0x10000000 to 0x7FFFFFFF is available for the data ,NA,NA
Another (inferior) way of arranging memory might be to ,NA,NA
have half the space 0x10000000 to 0x7FFFFFFF allocated to the stack and half the space allocated to ,NA,NA
"data. But now the stack could grow too large for its allocated space, even if there was a tiny data segment ",NA,NA
that used little of its space. ,NA,NA
QUESTION 9:,NA,NA
Which segment is for the machine instructions? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_9.html [8/8/2545 11:15:48],NA
A good answer might be: ,NA,NA
The text segment. ,NA,NA
Reversing a String,NA,NA
"""Text"" is traditionally what a segment of machine instructions is called. It becomes a ",NA,NA
"""process"" when it starts executing. (This is analogous to the phrase ""text of a play"" and ",NA,NA
"""performance of a play""). ",NA,NA
Almost all text books that describe stacks use this example program: the user enters a ,NA,NA
string. The program reverses the string and writes it out. To understand how the program ,NA,NA
"works inspect the following diagram. The string ""Hello"" is pushed onto the stack, character ",NA,NA
by character. Then the characters are popped from the stack back into the original string ,NA,NA
buffer. This reverses the order of the characters. ,NA,NA
We will always push and pop full words (four bytes). Each character on the stack will be ,NA,NA
contained in the low order byte of a fullword. ,NA,NA
QUESTION 10:,NA,NA
(Review: ) What does the following instruction do? ,NA,NA
"lb $t0,string",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_10.html [8/8/2545 11:15:57],NA
"lbu $t0,string",NA,NA
A good answer might be: ,NA,NA
It loads one byte (located at ,NA,NA
string,NA,NA
) into the low order byte of register ,NA,NA
$t0,NA,NA
. The other ,NA,NA
bytes are filled with zero. ,NA,NA
Outline,NA,NA
Here is the outline of the program. The comments are for the major sections of the program. ,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main: ,NA,NA
 # ________________________,NA,NA
 # ________________________,NA,NA
 # ________________________,NA,NA
 # ________________________,NA,NA
 .data ,NA,NA
str:    .space  128                 # character buffer ,NA,NA
"Not much of an outline. Luckily, here are some phrases you can use to fill in the blanks: ",NA,NA
print the reversed string,NA,NA
", ",NA,NA
push each character onto the stack,NA,NA
", ",NA,NA
input the string into a buffer,NA,NA
", ",NA,NA
and ,NA,NA
pop chars from stack back into the buffer,NA,NA
. ,NA,NA
QUESTION 11:,NA,NA
Fill the blanks with the correct phrases. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_11.html [8/8/2545 11:16:04],NA
A good answer might be:,NA,NA
main: ,NA,NA
 # input the string,NA,NA
 # push each character onto the stack,NA,NA
 # pop chars from stack back into the buffer,NA,NA
 # print the reversed string,NA,NA
First Section,NA,NA
Here is the first secion of the program filled in. It merely reads in a line from the terminal in ,NA,NA
the usual way. There is no user prompt. ,NA,NA
# Reverse and output a user-supplied string ,NA,NA
# ,NA,NA
# $t0 --- character pushed or popped ,NA,NA
# $t1 --- index into string buffer str,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:   #input the string,NA,NA
" li      $v0,8          # service code",NA,NA
" la      $a0,str        # address of buffer",NA,NA
 ,NA,NA
"li      $a1,128        # buffer length ",NA,NA
 syscall       ,NA,NA
 # initialize the stack:        ,NA,NA
 ,NA,NA
"li      $t0,_____      # push a null",NA,NA
" ____    $sp,$sp,4      # onto the stack",NA,NA
" sw      $t0,(___)      # to signal its bottom",NA,NA
" li      $t1,0          # index of first char in str buffer",NA,NA
 # push each character onto the stack,NA,NA
 # pop chars from stack back into the buffer,NA,NA
 # print the reversed string,NA,NA
 .data,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_12.html (1 of 2) [8/8/2545 11:16:12],NA
str:    .space  128            # character buffer ,NA,NA
Next the stack is initialized. Null is pushed onto the stack. Later on the stack will be popped ,NA,NA
until this null is encountered. ,NA,NA
QUESTION 12:,NA,NA
Fill in the blanks of the program. ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Pushing Characters,NA,NA
# Reverse and output a user-supplied string ,NA,NA
# ,NA,NA
# $t0 --- character pushed or popped ,NA,NA
# $t1 --- index into string buffer str,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:   #input the string,NA,NA
" li      $v0,8          # service code",NA,NA
" la      $a0,str        # address of buffer ",NA,NA
"li      $a1,128        # buffer length  ",NA,NA
syscall,NA,NA
" li      $t0,0          # push a null ",NA,NA
" sub     $sp,$sp,4      # onto the stack",NA,NA
" sw      $t0,($sp)      # to signal its bottom",NA,NA
" li      $t1,0          # index of first char in str buffer",NA,NA
 # push each character onto the stack ,NA,NA
pushl:,NA,NA
" lbu     $t0,str($t1)   # get current char into",NA,NA
 # a full word,NA,NA
" ____    $t0,stend      # null byte: end of string",NA,NA
" sub     $sp,$sp,4      # push the full word",NA,NA
" ___     $t0,($sp)      # holding the char",NA,NA
" add     $t1,1          # inc the index",NA,NA
 j       _____          # loop ,NA,NA
stend: ,NA,NA
 . . . . .,NA,NA
 # pop chars from stack back into the buffer,NA,NA
 # print the reversed string,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_13.html (1 of 2) [8/8/2545 11:16:29],NA
 .data ,NA,NA
str:    .space  128            # character buffer ,NA,NA
"In the next stage, characters from the character buffer are pushed one by one onto the ",NA,NA
stack. The first instruction (at ,NA,NA
pushl:,NA,NA
) uses indexed addressing to load the current character ,NA,NA
from the buffer (,NA,NA
str:,NA,NA
) into the least significant byte of ,NA,NA
$t0,NA,NA
. ,NA,NA
"Next, the current character is tested. If it is null (zero) then control branches out of the loop. ",NA,NA
Otherwise the character is pushed onto the stack. Then the process is repeated. ,NA,NA
QUESTION 13:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_13.html (2 of 2) [8/8/2545 11:16:29],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Popping Characters,NA,NA
 . . . . .,NA,NA
 # push each character onto the stack ,NA,NA
pushl:,NA,NA
" lbu     $t0,str($t1)   # get current char into",NA,NA
 # a full word,NA,NA
" beqz    $t0,stend      # null byte: end of string",NA,NA
" sub     $sp,$sp,4      # push the full word",NA,NA
" sw      $t0,($sp)      # holding the char",NA,NA
" add     $t1,1          # inc the index",NA,NA
 j       pushl          # loop,NA,NA
 # pop chars from stack back into the buffer ,NA,NA
"stend:  li      $t1,0          # index of first byte of str buffer ",NA,NA
popl:,NA,NA
" ____    $t0,($sp)      # pop a char off the stack",NA,NA
" ____    $sp,$sp,4",NA,NA
" beqz    $t0,done       # null means empty stack",NA,NA
" ____    $t0,str($t1)   # store at string[$t1]",NA,NA
" add     $t1,1          # inc the index",NA,NA
 j       popl           # loop,NA,NA
 # print the reversed string,NA,NA
 . . . . . ,NA,NA
 .data ,NA,NA
str:    .space  128            # character buffer ,NA,NA
"When the null byte of the null-terminated input string is encountered, the first loop exits and ",NA,NA
the next loop begins. This next loop pops characters (contained in full words) off of the stack ,NA,NA
until the null at the bottom of the stack is encountered. Each character popped off the stack ,NA,NA
"is placed into the string buffer, overwriting the character originally there. ",NA,NA
The null at the end of the input string is not overwritten. It will remain there as part of the null-,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_14.html (1 of 2) [8/8/2545 11:16:36],NA
terminated result string. ,NA,NA
QUESTION 14:,NA,NA
You know the drill: fill in those blanks. ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Final Phase,NA,NA
 . . . . .,NA,NA
 # pop chars from stack back into the buffer ,NA,NA
"stend:  li      $t1,0          # index of first byte of str buffer ",NA,NA
popl:,NA,NA
" lw     $t0,($sp)      # pop a char off the stack",NA,NA
" add     $sp,$sp,4",NA,NA
" beqz    $t0,done       # null means empty stack",NA,NA
" sb      $t0,str($t1)   # store at string[$t1]",NA,NA
" add     $t1,1          # inc the index",NA,NA
 j       popl           # loop,NA,NA
 # print the reversed string ,NA,NA
"done:   li      $v0,4          # service code ",NA,NA
" la      $a1,str        # address of string",NA,NA
 syscall,NA,NA
" li      $v0,10         # exit",NA,NA
 syscall   ,NA,NA
 .data ,NA,NA
str:    .space  128            # character buffer ,NA,NA
The last phase of the program prints out the result string. There is nothing new here. If you ,NA,NA
"want to see the complete program, copy and past the several above sections into a text file. ",NA,NA
QUESTION 15:,NA,NA
Would it be easier to do this program with arrays? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-25/ass25_15.html [8/8/2545 11:16:59],NA
A good answer might be: ,NA,NA
Probably not. You would need two arrays. You would need to know the size of the input ,NA,NA
string before you begin copying from the input array to the output array. ,NA,NA
End of the Chapter,NA,NA
You have reached the end this chapter. You may wish to review the following. Click on a ,NA,NA
subject that interests you to go to where it was discussed. ,G,NA
Concept of stack.,G,NA
LIFO data structure.,G,NA
Stack pointer register and upsidedown MIPS stack.,G,NA
Push ,G,NA
Pop ,G,NA
Run-ime stack ,G,NA
Text segment of MIPS memory.,NA,NA
CHAPTER 26 — Simple Subroutine ,NA,NA
Linkage,NA,NA
All high level languages have the concept of a ,NA,NA
subroutine,NA,NA
 (sometimes called ,NA,NA
module,NA,NA
", ",NA,NA
procedure,NA,NA
", ",NA,NA
function,NA,NA
", or ",NA,NA
method,NA,NA
). A subroutine is a logical division of the code that may be ,NA,NA
regarded as a self-contained operation. A subroutine may be executed several times with ,NA,NA
different data as the program that contains it runs. ,NA,NA
This chapter looks at a simple implementation in assembly language of this idea. The simple ,NA,NA
implementation is not adequate for the full power of subroutines (as implemented in high ,NA,NA
"level languages), but is a good starting point. It corresponds to the type of subroutines ",NA,NA
"implemented in early languages such as FORTRAN, BASIC, and COBOL. ",NA,NA
Chapter Topics:,G,NA
Subroutine call.,G,NA
Caller and Callee routines.,G,NA
jal,NA,NA
and ,NA,NA
jr,NA,NA
instructions ,G,NA
The ,NA,NA
$ra,NA,NA
register. ,G,NA
The simple linkage calling convention.,G,NA
Register use in subroutines,NA,NA
QUESTION 1:,NA,NA
"In an assembly program, if you wish to unconditionally transfer control from ",NA,NA
"one address to another, what instruction can you use? ",NA,NA
A good answer might be: ,NA,NA
The ,NA,NA
j,NA,NA
 (jump) or the ,NA,NA
b,NA,NA
 (branch) instruction. ,NA,NA
Callers and Callees,NA,NA
At right is a sketch of what you can do now. If the main ,NA,NA
The subroutine cannot be called from several locations in ,NA,NA
the ,NA,NA
main,NA,NA
 program because it must always return to the ,NA,NA
same location. ,NA,NA
A subroutine ,NA,NA
call,NA,NA
 is when a main routine (or other routine) passes control to a subroutine. The ,NA,NA
main routine in this context is said to be the CALLER and the subroutine is said to be the ,NA,NA
CALLEE. A ,NA,NA
return,NA,NA
 from a subroutine is when a subroutine passes control back to its CALLER. ,NA,NA
"With modern software, when the CALLEE finishes execution it nearly always returns control ",NA,NA
to its CALLER. ,NA,NA
QUESTION 2:,NA,NA
"With modern software, during its execution might a CALLEE pass control to ",NA,NA
a subroutine other than its CALLER? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_2.html [8/8/2545 11:26:14],NA
A good answer might be: ,NA,NA
Yes. Subroutines typically call other subroutines which call other subroutines.... and so ,NA,NA
on. ,NA,NA
Many Calls but One Return,NA,NA
The problem is illustrated at right. The ,NA,NA
main ,NA,NA
routine is written to call a useful subroutine ,NA,NA
sub,NA,NA
 at ,NA,NA
several locations in the code. But ,NA,NA
sub,NA,NA
 is written to ,NA,NA
return to only one location. Usually this will not ,NA,NA
work. ,NA,NA
"In the past, before the concept was completely ",NA,NA
"understood, hardware support for subroutines was ",NA,NA
missing. Various nasty tricks were used to ,NA,NA
implement the idea. ,NA,NA
What is needed is a method that send the ,NA,NA
return ,NA,NA
address,NA,NA
 to the subroutine. When the subroutine ,NA,NA
"finishes, it passes control to that return address. ",NA,NA
"Of course, passing control to a return address ",NA,NA
means to load the PC (program counter) with the ,NA,NA
return address. The next instruction fetch of the ,NA,NA
machine cycle will get the instruction from that ,NA,NA
address. ,NA,NA
QUESTION 3:,NA,NA
(Hardware Design Question: ) How should the return address be passed to ,NA,NA
"the subroutine? (i) By placing in in main memory somewhere, or (ii) By ",NA,NA
placing it in a register designated for this purpose. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_3.html [8/8/2545 11:26:30],NA
A good answer might be: ,NA,NA
(ii) By placing it in a register designated for this purpose. ,NA,NA
jal,NA,NA
 Instruction,NA,NA
The register that is used for linkage is register ,NA,NA
$31,NA,NA
", which is called ",NA,NA
$ra,NA,NA
 by ,NA,NA
for now). ,NA,NA
The ,NA,NA
jal,NA,NA
 instruction does the following (during the execute phase of the ,NA,NA
machine cycle): ,NA,NA
Tricky:,NA,NA
 the middle step of the machine cycle has already incremented ,NA,NA
jal sub:  $ra <• PC+4  # $ra ,NA,NA
<• address 8 bytes away from the jal ,NA,NA
 PC <• sub   # load the ,NA,NA
PC with the entry point,NA,NA
the extended assembler. It holds the ,NA,NA
return address,NA,NA
 for a subroutine. ,NA,NA
The instruction that puts the return address into ,NA,NA
$ra,NA,NA
 is (usually) the ,NA,NA
jal ,NA,NA
instruction. ,NA,NA
"The correct return address is ""address of the ",NA,NA
jal,NA,NA
" plus four"". This is because: (i) returning ",NA,NA
"from the subroutine to the jal instruction would be a disaster (since it would execute again, ",NA,NA
"sending control back to the subroutine), and (ii) the instruction following the ",NA,NA
jal,NA,NA
 in the branch ,NA,NA
delay slot. ,NA,NA
QUESTION 4:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_4.html (1 of 2) [8/8/2545 11:26:59],NA
What instruction is usually placed in the branch delay slot? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_4.html (2 of 2) [8/8/2545 11:26:59],NA
A good answer might be: ,NA,NA
Usually the branch delay slot is filled with a ,NA,NA
nop,NA,NA
 instruction. This does nothing. ,NA,NA
Example ,NA,NA
jal,NA,NA
 Instruction,NA,NA
It would not be a disaster to return to an ,NA,NA
instruction that does nothing. It is a slight ,NA,NA
optimization to return to the instruction after it. ,NA,NA
But sometimes clever programmers or clever ,NA,NA
compilers put something unexpected in the ,NA,NA
"branch delay slot, so it is best not to pass ",NA,NA
control to it. ,NA,NA
The diagram shows the execution of a ,NA,NA
jal ,NA,NA
instruction. The ,NA,NA
jal,NA,NA
 is at address ,NA,NA
0x00400014,NA,NA
. ,NA,NA
The return address is ,NA,NA
0x0040001C,NA,NA
 which is the ,NA,NA
address of the ,NA,NA
jal,NA,NA
 plus eight. (The ,NA,NA
addu ,NA,NA
instruction is just there as an example of what ,NA,NA
might be at the return address). ,NA,NA
Here is how the ,NA,NA
jal,NA,NA
 instruction works in general: ,NA,NA
jal sub:  $ra <• PC+4  # $ra <• address 8 bytes away from the jal ,NA,NA
 PC <• sub   # load the PC with the entry point,NA,NA
Here is how it works in this example. The entry point of ,NA,NA
sub:,NA,NA
 is ,NA,NA
0x00400100,NA,NA
 # when the jal is loaded the PC has 0x00400014,NA,NA
 # next (in the machine cycle) the PC is increased,NA,NA
 # to 0x00400018 ,NA,NA
jal sub:  $ra <• PC+4  # $ra <• 0x0040018+4 ,NA,NA
 PC <• sub   # load the PC with 0x00400100,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_5.html (1 of 2) [8/8/2545 11:27:07],NA
QUESTION 5:,NA,NA
"In the subroutine, the return address is in ",NA,NA
$ra,NA,NA
. Can an ordinary jump ,NA,NA
instruction be used to return to the caller? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_5.html (2 of 2) [8/8/2545 11:27:07],NA
A good answer might be: ,NA,NA
No. An ordinary jump instruction has its one jump target encoded as an unchanging part ,NA,NA
of the instruction. (like ,NA,NA
j someSpot,NA,NA
). ,NA,NA
The ,NA,NA
jr,NA,NA
 Instruction,NA,NA
The ,NA,NA
jr,NA,NA
 instruction is used to return to the callee. ,NA,NA
It copies the contents of ,NA,NA
$ra,NA,NA
 into the PC: ,NA,NA
jr  $ra      # PC <• $ra ,NA,NA
"To make the instruction more general, it can be ",NA,NA
"used with any register, not just ",NA,NA
$ra,NA,NA
. Like all jump ,NA,NA
"and branch instructions, the ",NA,NA
jr,NA,NA
 instruction is ,NA,NA
followed by a branch delay. ,NA,NA
The diagram shows the subroutine returning to ,NA,NA
the return address following the subroutine call. ,NA,NA
QUESTION 6:,NA,NA
Do we now have a mechanism that enables us to call the same subroutine ,NA,NA
from many points in a program? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_6.html [8/8/2545 11:27:16],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Calling Convention,NA,NA
The diagram shows the subroutine ,NA,NA
sub,NA,NA
 being called ,NA,NA
QUESTION 7:,NA,NA
What registers is the subroutine ,NA,NA
sub,NA,NA
 free to change? ,NA,NA
convention says how those support features are used. ,NA,NA
"There is more to a calling convention than how to pass control, as the next question shows: ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_7.html [8/8/2545 11:27:40],NA
A good answer might be: ,NA,NA
I don't know. ,NA,NA
Register Use,NA,NA
"To answer the question, you would have to look at the code for ",NA,NA
main,NA,NA
 and determine which ,NA,NA
"registers could not be altered. Worse, you would have to look at the context surrounding ",NA,NA
each call to ,NA,NA
sub,NA,NA
. One of the goals of subroutines is to create a module that is independent of ,NA,NA
"the rest of the code. So far, that is not what we have achieved. ",NA,NA
Another issue is how data is passed into and out of the subroutine. Often data is in ,NA,NA
"registers, and the results are in registers. Which registers? ",NA,NA
By agreement between programmers (not by hardware) registers have been assigned ,NA,NA
different roles with subroutine linkage: ,G,NA
$t0 - $t9,NA,NA
 — The subroutine is free to change these registers.,G,NA
$s0 - $t7,NA,NA
 — The subroutine must not change these registers.,G,NA
$a0 - $a3,NA,NA
 — These registers contain arguments for the subroutine. The subroutine can ,NA,NA
change them.,G,NA
$v0 - $v1,NA,NA
 — These registers contain values returned from the subroutine.,NA,NA
QUESTION 8:,NA,NA
Is the following code fragment correct? ,NA,NA
" add    $t0,$s5,$s3   # calculate an important sum jal    ",NA,NA
somesub       # call some subroutine,NA,NA
" mul    $s4,$t0,$v1   # multiply the sum by the result",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_8.html [8/8/2545 11:28:06],NA
A good answer might be: ,NA,NA
No. The value in ,NA,NA
$t0,NA,NA
 might have been changed by ,NA,NA
somesub,NA,NA
", since ",NA,NA
$t0,NA,NA
 (according to ,NA,NA
convention) is a register that a subroutine is free to use. ,NA,NA
 add    ,NA,NA
$t0,NA,NA
",$s5,$s3   # calculate an important sum",NA,NA
 jal    somesub       # call some subroutine,NA,NA
" mul    $s4,",NA,NA
$t0,NA,NA
",$v1   # multiply the sum by the result",NA,NA
Simple Linkage,NA,NA
Let us agree on a calling convention. The convention is named ,NA,NA
Simple Linkage,NA,NA
. (This is not ,NA,NA
the actual convention used by most MIPS software). Most of the rules of this convention you ,NA,NA
have already seen: ,NA,NA
1.  A subroutine is called using ,NA,NA
jal,NA,NA
.,NA,NA
2.  A subroutine will NOT call another subroutine.,NA,NA
3.  The subroutine returns to its caller using ,NA,NA
jr $ra,NA,NA
.,NA,NA
4.  Register use is as follows: ,H,NA
$t0 - $t9,NA,NA
 — The subroutine is free to change these registers.,H,NA
$s0 - $t7,NA,NA
 — The subroutine must not change these registers. ,H,NA
$a0 - ,NA,NA
$a3,NA,NA
 — These registers contain arguments for the subroutine. The ,NA,NA
subroutine can change them.,H,NA
$v0 - $v1,NA,NA
 — These registers contain values returned from the ,NA,NA
subroutine.,NA,NA
QUESTION 9:,NA,NA
(Thought Question: ) Rule number 2 is new. Why must not a subroutine call ,NA,NA
another subroutine? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_9.html [8/8/2545 11:28:41],NA
A good answer might be: ,NA,NA
Because there is noplace to put the return address. The register ,NA,NA
$ra,NA,NA
 is already in use. ,NA,NA
Pictoral Summary ,NA,NA
The picture shows ,NA,NA
main,NA,NA
 linking to ,NA,NA
mySub,NA,NA
". Two arguments are passed, in ",NA,NA
$a0,NA,NA
 and ,NA,NA
#a1,NA,NA
. ,NA,NA
The subroutine reads the arguments from those registers but should not change them. ,NA,NA
There are some obvious limitations in the ,NA,NA
Simple Linkage Convention,NA,NA
. They will be ,NA,NA
corrected in a complicated calling convention that is discussed in the next chapter. ,NA,NA
"Ideally, the caller and the callee should communicate only through arguments and return ",NA,NA
values. Both should be written without using any of the symbolic addresses in the other. ,NA,NA
QUESTION 10:,NA,NA
Should a code module know about the inner workings of another module? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_10.html [8/8/2545 11:29:03],NA
A good answer might be: ,NA,NA
No. In assembly language this means routines should not use each other's symbolic ,NA,NA
addresses. ,NA,NA
Example Program,NA,NA
Let us write a program that uses the ,NA,NA
Simple Linkage,NA,NA
 convention. The program is to read ,NA,NA
three integers from the user and compute the sum. The outline of the program is: ,NA,NA
# read first integer ,NA,NA
# read second integer ,NA,NA
# read third integer ,NA,NA
# compute the sum ,NA,NA
# write out the result,NA,NA
"Of course, the user will enter integers as characters from the keyboard. The program uses ",NA,NA
the trap handler service number five to read the characters and convert it to a full word. ,NA,NA
QUESTION 11:,NA,NA
Examine the outline for the program. What do you think would be a useful ,NA,NA
subroutine? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_11.html [8/8/2545 11:29:08],NA
A good answer might be: ,NA,NA
It would be useful to have a ,NA,NA
read integer,NA,NA
 subroutine. ,NA,NA
Prompt and Read Integer,NA,NA
The subroutine prompts the user for an integer and read it in. Here is a start on the ,NA,NA
subroutine: ,NA,NA
# pread -- prompt for and read an integer ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $ra -- return address ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    $v0 -- the integer,NA,NA
pread: ,NA,NA
" la    $a0,prompt        # print string",NA,NA
" li    $v0,4             # service 4",NA,NA
 syscall,NA,NA
" li    $v0,5             # read int",NA,NA
 syscall                 # service 5,NA,NA
 ____  ____              # return,NA,NA
 .data ,NA,NA
prompt:,NA,NA
" .asciiz ""Enter an integer""",NA,NA
QUESTION 12:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_12.html [8/8/2545 11:29:22],NA
A good answer might be:,NA,NA
# pread -- prompt for and read an integer ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $ra -- return address ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    $v0 -- the integer,NA,NA
pread: ,NA,NA
" la    $a0,prompt        # print string",NA,NA
" li    $v0,4             # service 4",NA,NA
 syscall,NA,NA
" li    $v0,5             # read int",NA,NA
 syscall                 # service 5,NA,NA
 jr    $ra               # return,NA,NA
 .data ,NA,NA
prompt:,NA,NA
" .asciiz ""Enter an integer: """,NA,NA
Main Program,NA,NA
Assume that the subroutine is correct. Now write the main program. ,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
 jal     _____            # read first integer ,NA,NA
"move    $s0,$v0          # save it in $s0 jal     ",NA,NA
_____            # read second integer move    ,NA,NA
"$s1,$v0          # save it in $s1 jal     _____            ",NA,NA
"# read third integer move    $s2,$v0          ",NA,NA
# save it in $s2,NA,NA
" addu    $s0,$s0,$s1      # compute the sum",NA,NA
" addu    $a0,$s0,$s2",NA,NA
" li      $v0,1            # print the sum",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_13.html (1 of 2) [8/8/2545 11:29:33],NA
 syscall,NA,NA
" li      $v0,10           # exit",NA,NA
 syscall,NA,NA
QUESTION 13:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be:,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
 jal     pread            # read first integer,NA,NA
" move    $s0,$v0          # save it in $s0",NA,NA
 jal     pread            # read second integer,NA,NA
" move    $s1,$v0          # save it in $s1",NA,NA
 jal     pread            # read third integer,NA,NA
" move    $s2,$v0          # save it in $s2",NA,NA
" addu    $s0,$s0,$s1      # compute the sum",NA,NA
" addu    $a0,$s0,$s2",NA,NA
" li      $v0,1            # print the sum",NA,NA
 syscall,NA,NA
" li      $v0,10           # exit",NA,NA
 syscall,NA,NA
Global Symbols,NA,NA
"Recall that modules (for us, subroutines) should not know about each other's symbolic ",NA,NA
addresses. It would violate the idea of modularity for ,NA,NA
main,NA,NA
 to do something to ,NA,NA
pread,NA,NA
's ,NA,NA
prompt,NA,NA
", for example. ",NA,NA
"But some symbolic addresses need to be used between modules. For example, ",NA,NA
pread,NA,NA
 is a ,NA,NA
"symbolic address, and ",NA,NA
main,NA,NA
 must know about it and use it in the ,NA,NA
jal,NA,NA
 instruction. ,NA,NA
A symbol that a subroutine makes visible to other subroutines is a ,NA,NA
global,NA,NA
 symbol. Global ,NA,NA
symbols usually label entry points used when other routines pass control (call) a subroutine. ,NA,NA
Symbols that are not global are called ,NA,NA
local,NA,NA
 symbols. In MIPS assembly and in SPIM global ,NA,NA
a symbol is made global by placing it in a list of symbols following the ,NA,NA
.globl,NA,NA
 directive: ,NA,NA
 .globl  main,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_14.html (1 of 2) [8/8/2545 11:29:38],NA
QUESTION 14:,NA,NA
What global symbols are in the subroutine ,NA,NA
pread,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_14.html (2 of 2) [8/8/2545 11:29:38],NA
A good answer might be: ,NA,NA
The entry point for the subroutine: ,NA,NA
pread,NA,NA
. ,NA,NA
Complete Program,NA,NA
Here is the complete example program. The global symbols have been correctly declared. ,NA,NA
Study how each module uses the directives ,NA,NA
.text,NA,NA
 and ,NA,NA
.data,NA,NA
 to describe its sections. ,NA,NA
# addthree.asm --- read in three integers and print their sum ,NA,NA
# ,NA,NA
"# This program uses simple linkage.  In SPIM, allow pseudoinstructions, ",NA,NA
"# disable delayed branches and disable delayed load, load trap file.",NA,NA
# ,NA,NA
#,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
 jal     pread            # read first integer ,NA,NA
"move    $s0,$v0          # save it in $s0 jal     ",NA,NA
pread            # read second integer move    ,NA,NA
"$s1,$v0          # save it in $s1 jal     pread            ",NA,NA
"# read third integer move    $s2,$v0          ",NA,NA
# save it in $s2,NA,NA
" addu    $s0,$s0,$s1      # compute the sum",NA,NA
" addu    $a0,$s0,$s2",NA,NA
" li      $v0,1            # print the sum",NA,NA
 syscall,NA,NA
" li      $v0,10           # exit",NA,NA
 syscall,NA,NA
# pread -- prompt for and read an integer ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $ra -- return address ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    $v0 -- the integer,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_15.html (1 of 2) [8/8/2545 11:29:40],NA
 .text,NA,NA
 .globl  pread ,NA,NA
pread: ,NA,NA
" la    $a0,prompt        # print string",NA,NA
" li    $v0,4             # service 4",NA,NA
 syscall,NA,NA
" li    $v0,5             # read int",NA,NA
 syscall                 # service 5,NA,NA
 jr    $ra               # return,NA,NA
 .data ,NA,NA
prompt:,NA,NA
" .asciiz ""Enter an integer: """,NA,NA
QUESTION 15:,NA,NA
Could ,NA,NA
pread,NA,NA
 be used as-is in other programs? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-26/ass26_15.html (2 of 2) [8/8/2545 11:29:40],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
End of Chapter,NA,NA
You have reached the end this chapter. You may wish to review the following. Click on a ,NA,NA
subject that interests you to go to where it was discussed. ,G,NA
Collars and Collies.,G,NA
jal,NA,NA
 instruction and the return address. ,G,NA
jr,NA,NA
 instruction.,G,NA
Calling conventions.,G,NA
Simple linkage calling convention.,NA,NA
CHAPTER 27 — Stack-based Calling ,NA,NA
Convention,NA,NA
The Simple Linkage convention of the previous chapter lacked some features of high level ,NA,NA
languages. Some of these features are added in the Stack-based subroutine linkage ,NA,NA
explained in this chapter. ,NA,NA
Chapter Topics:,G,NA
Saving registers on the stack.,G,NA
The Stack-based Calling Convention.,G,NA
The prolog and epilog of the called subroutine.,G,NA
The call and return of the caller.,G,NA
Nested subroutine calls and the chain of activation. ,G,NA
History of linkage conventions.,G,NA
Example program: converting user input to upper case.,NA,NA
QUESTION 1:,NA,NA
"In the Simple Linkage convention of the previous chapter, can a subroutine ",NA,NA
call another subroutine? ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
Pushing the Return Address,NA,NA
To return to the caller a subroutine must have the ,NA,NA
correct address in ,NA,NA
$ra,NA,NA
 when the ,NA,NA
jr,NA,NA
 instruction is ,NA,NA
performed. But this address does not have to ,NA,NA
remain in ,NA,NA
$ra,NA,NA
 for all the time the subroutine is ,NA,NA
running. It works fine to save the value of ,NA,NA
$ra,NA,NA
 and ,NA,NA
then restore it when needed. ,NA,NA
The picture shows ,NA,NA
main,NA,NA
 calling ,NA,NA
subA,NA,NA
" (step 1), ",NA,NA
which calls ,NA,NA
subB,NA,NA
" (step 2), which calls ",NA,NA
subC,NA,NA
 (step ,NA,NA
3). Just before each call the current contents of ,NA,NA
$ra ,NA,NA
are pushed on the stack. Just before each return ,NA,NA
(using ,NA,NA
jr $ra,NA,NA
) that value is popped back into ,NA,NA
$ra,NA,NA
. ,NA,NA
"For this to work, each subroutine must return to its ",NA,NA
caller with the stack in the same state as when the ,NA,NA
caller did the ,NA,NA
jal,NA,NA
 instruction. ,NA,NA
"For example, ",NA,NA
main,NA,NA
 pushes its return address (,NA,NA
$ra,NA,NA
) ,NA,NA
onto the stack and calls ,NA,NA
subA,NA,NA
. When ,NA,NA
main,NA,NA
 gets ,NA,NA
"control again, the stack should have that return ",NA,NA
address on the top of the stack. ,NA,NA
When ,NA,NA
main,NA,NA
 starts execution it has been called like a ,NA,NA
subroutine by the operating system. As far as the ,NA,NA
"OS is concerned, ",NA,NA
main,NA,NA
 is a subroutine. So it has a ,NA,NA
return address (in ,NA,NA
$ra,NA,NA
) to use when in finished ,NA,NA
execution (and returns control to the OS). ,NA,NA
"As another example, consider ",NA,NA
subB,NA,NA
. When it starts ,NA,NA
execution the top of the stack is ,NA,NA
subA,NA,NA
's return ,NA,NA
address (,NA,NA
$ra,NA,NA
 for returning to ,NA,NA
main,NA,NA
). When ,NA,NA
subB,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_2.html (1 of 2) [8/8/2545 11:32:18],NA
calls ,NA,NA
subC,NA,NA
", ",NA,NA
subB,NA,NA
 pushes its return address on the ,NA,NA
stack (,NA,NA
$ra,NA,NA
 for returning to ,NA,NA
subA,NA,NA
). Later on it pops ,NA,NA
this address when it returns to ,NA,NA
subA,NA,NA
. ,NA,NA
The push and pop operations are done in the usual way. There are no explicit push and pop ,NA,NA
operations as the diagram might imply. But some processors have explicit push and pop ,NA,NA
machine instructions. ,NA,NA
QUESTION 2:,NA,NA
Why does not ,NA,NA
subC,NA,NA
 push its return address on the stack? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_2.html (2 of 2) [8/8/2545 11:32:18],NA
A good answer might be: ,NA,NA
"Because it calls no subroutine, ",NA,NA
$ra,NA,NA
" will not be changed, so it does not have to be saved ",NA,NA
on the stack. ,NA,NA
Register Problem,NA,NA
"In the Simple Linkage convention, registers ",NA,NA
$s0•$s7,NA,NA
 could not be altered in a subroutine. ,NA,NA
This is a problem when subroutines call subroutines. Say that ,NA,NA
main,NA,NA
 calls ,NA,NA
subA,NA,NA
 and that ,NA,NA
subA,NA,NA
 calls ,NA,NA
subB,NA,NA
. ,NA,NA
subA,NA,NA
 can't save any values in ,NA,NA
$s0•$s7,NA,NA
 (because it is not allowed to alter ,NA,NA
them). But any values is saved in ,NA,NA
$t0•$s9,NA,NA
 might be clobbered by ,NA,NA
subB,NA,NA
 (because ,NA,NA
subB,NA,NA
 is ,NA,NA
"allowed to alter them). In effect, ",NA,NA
subA,NA,NA
 can't use any registers! Not good. ,NA,NA
The solution is to allow a subroutine to use ,NA,NA
$s0•$s7,NA,NA
". However, it must return them to their ",NA,NA
initial state when the subroutine returns to its caller. ,NA,NA
QUESTION 3:,NA,NA
If a subroutine is to restore ,NA,NA
$s0•$s7,NA,NA
" to their initial state, it must save the initial ",NA,NA
values somewhere. Where do you think those values are saved? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_3.html [8/8/2545 11:32:30],NA
A good answer might be: ,NA,NA
On the stack. ,NA,NA
Pushing and Popping Registers,NA,NA
"Here is a rule: if a subroutine alters any of the ""S"" registers, it must first push their values on ",NA,NA
the stack. Just before returning to the caller it must pop values from the stack into the proper ,NA,NA
"registers. Of course, you have to be careful to do things in the correct order. ",NA,NA
Here is an example program fragment. Subroutine ,NA,NA
subC,NA,NA
 calls ,NA,NA
subD,NA,NA
 which will use two of the ,NA,NA
"""S"" registers. ",NA,NA
subC:,NA,NA
 . . . .,NA,NA
" sub    $sp,$sp,4    # push $ra",NA,NA
" sw     $ra,($sp)",NA,NA
 jal    subD         # call subD,NA,NA
 . . . .,NA,NA
# subD expects to use $s0 and $s1 ,NA,NA
subD: ,NA,NA
" sub    $sp,$sp,4    # push $s0",NA,NA
" sw     $s0,($sp)",NA,NA
" sub    $sp,$sp,4    # push $s1",NA,NA
" sw     $s1,($sp)",NA,NA
 . . . .             # statements using $s0 and $s1,NA,NA
" lw     $___,($sp)   # pop _____",NA,NA
" add    $sp,$sp,4",NA,NA
" lw     $___,($sp)   # pop _____",NA,NA
" add    $sp,$sp,4",NA,NA
 jr     $ra          # return to subC        ,NA,NA
QUESTION 4:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_4.html (1 of 2) [8/8/2545 11:32:41],NA
Fill in the blanks so that ,NA,NA
subC,NA,NA
" sees its ""S"" registers when it regains control. ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_4.html (2 of 2) [8/8/2545 11:32:41],NA
A good answer might be:,NA,NA
subC:,NA,NA
 . . . .,NA,NA
" sub    $sp,$sp,4    # push $ra",NA,NA
" sw     $ra,($sp)",NA,NA
 jal    subD         # call subD,NA,NA
 . . . .,NA,NA
# subD expects to use $s0 and $s1 ,NA,NA
subD: ,NA,NA
" sub    $sp,$sp,4    # push $s0",NA,NA
" sw     $s0,($sp)",NA,NA
" sub    $sp,$sp,4    # push $s1",NA,NA
" sw     $s1,($sp)",NA,NA
 . . . .             # statements using $s0 and $s1,NA,NA
" lw     $s1,($sp)   # pop s1",NA,NA
" add    $sp,$sp,4",NA,NA
" lw     $s0,($sp)   # pop s0",NA,NA
" add    $sp,$sp,4",NA,NA
 jr     $ra                # return to subC        ,NA,NA
Notice that the registers are popped in the oppostite order that they were pushed. ,NA,NA
Stack-based Calling Convention,NA,NA
The Simple Linkage Convention is easily extended into a ,NA,NA
Stack-based Calling Convention,NA,NA
. ,NA,NA
This is not an official convention. However it is what you or a group of programmers might ,NA,NA
agree to use because it is not very complicated and does nearly everything you need. If you ,NA,NA
"want to link assembly language routines to ""C"" or ""C++"" you need to use the full, official, ",NA,NA
linkage rules. Here are our simpler rules: ,NA,NA
Calling a Subroutine (done by the caller): ,NA,NA
1.  The caller pushes onto the stack any registers ,NA,NA
$t0-$t9,NA,NA
 that ,NA,NA
contain values that must be saved. The subroutine is free to ,NA,NA
change those registers.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_5.html (1 of 2) [8/8/2545 11:32:51],NA
2.  The caller puts argument values into ,NA,NA
$a0-$a3,NA,NA
. ,NA,NA
3.  Call the subroutine using ,NA,NA
jal,NA,NA
.,NA,NA
Subroutine Prolog (at the start of the subroutine): ,NA,NA
"1.  If this subroutine calls other subroutines, push ",NA,NA
$ra,NA,NA
 on the ,NA,NA
stack.,NA,NA
2.  Push onto the stack any registers ,NA,NA
$s0-$s7,NA,NA
 that the subroutine ,NA,NA
may alter. ,NA,NA
Subroutine Body: ,NA,NA
"1.  The subroutine may alter any ""T"" or ""A"" register or any ""S"" ",NA,NA
register that it saved in the prolog.,NA,NA
"2.  If the subroutine calls another subroutine, then it does so by ",NA,NA
following these rules.,NA,NA
Subroutine Epilog (at the end of the subroutine): ,NA,NA
1.  Return values are put in ,NA,NA
$v0-$v1 ,NA,NA
2.  Pop from the stack (in reverse order) any registers ,NA,NA
$s0-,NA,NA
$s7 ,NA,NA
that it previously pushed.,NA,NA
"3.  If it was pushed in the prolog, pop ",NA,NA
$ra,NA,NA
 from the stack. ,NA,NA
4.  Return to the caller using ,NA,NA
jr $ra,NA,NA
.,NA,NA
Return from a Subroutine (done by the caller): ,NA,NA
1.  The caller pops from the stack (in reverse order) any registers ,NA,NA
$t0-$t9,NA,NA
 that it previously pushed.,NA,NA
QUESTION 5:,NA,NA
"Why do you think there are both ""T"" and ""S"" registers? Why not just have ""S"" ",NA,NA
registers and make it a rule that a subroutine must save each one it uses? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_5.html (2 of 2) [8/8/2545 11:32:51],NA
A good answer might be: ,NA,NA
This is an optimization for speed. Many subroutines neeed to use only a few registers. ,NA,NA
"They can use the ""T"" registers without the added expense of saving and restoring them. ",NA,NA
Diagram ,NA,NA
Those rules are somewhat complicated. Here is a picture. It ,NA,NA
$ra,NA,NA
". Push any ""S"" register the subroutine will alter. ",NA,NA
Body:,NA,NA
" Normal code, except it must ",NA,NA
"follow these conventions if it calls another subroutine. ""T"" and ""A"" registers can be used ",NA,NA
"freely, as can any ""S"" registers that were saved in the prolog. ",NA,NA
Epilog:,NA,NA
 Put return values in ,NA,NA
"""V"" registers. Pop any ""S"" registers. Pop ",NA,NA
$ra,NA,NA
 if it was pushed in the prolog. ,NA,NA
jr $ra ,NA,NA
back to ,NA,NA
the caller. ,NA,NA
shows the four sections of subroutine linkage. The basic tasks ,NA,NA
of each section are: ,NA,NA
Subroutine Call:,NA,NA
" Push any ""T"" registers that values that ",NA,NA
"are needed. Put arguments in ""A"" registers. ",NA,NA
jal,NA,NA
 to the ,NA,NA
subroutine. ,NA,NA
Prolog:,NA,NA
" If this subroutine calls other subroutines, push ",NA,NA
Return:,NA,NA
" Pop any ""T"" registers. ",NA,NA
QUESTION 6:,NA,NA
Is there any limit in these rules about how many levels deep subroutine calls ,NA,NA
may be? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_6.html [8/8/2545 11:33:08],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Nested Subroutine Calls,NA,NA
The (somewhat silly) diagram at right shows the main routine linking to ,NA,NA
"one whose data is at the top of the stack (subroutine C, in our upside-",NA,NA
down stack). ,NA,NA
"As each subroutine returns to its caller, its section of data is popped ",NA,NA
from the stack. ,NA,NA
"A subroutine does not ""know"" anything about the stack other than its ",NA,NA
"section. It pushes its data onto the stack, and later on pops exactly ",NA,NA
that data back into registers. It does not look at any other data in the ,NA,NA
stack. It does not even know how deep the stack is. ,NA,NA
QUESTION 7:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_7.html (1 of 2) [8/8/2545 11:33:11],NA
"After subroutine B returns control to subroutine A, might subroutine A call ",NA,NA
another subroutine (say subroutine X)? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_7.html (2 of 2) [8/8/2545 11:33:11],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Linear Activation Chain,NA,NA
"A particular subroutine (say ""A"") may call several other subroutines in succession (say ""B"", ",NA,NA
"then ""X"", then ""Y"", then ""Z""). But at any moment, it will have only one subroutine linked to it ",NA,NA
in the chain of activation. The calls in most modern programming languages follow this ,NA,NA
"stack-based behavior. The currently executing subroutine (procedure, method, function, ",NA,NA
"module, ...) is at the end of a linear chain of activations that link back to the operating ",NA,NA
"system that first started ""main"". ",NA,NA
"When a subroutine reaches its end, it returns to its caller, and the chain is shortened. Its ",NA,NA
"caller might call another subroutine, and the chain is lengthened again. ",NA,NA
"As a program made up of many subroutines executes, the activation chain grows up and ",NA,NA
down like a yo-yo. Ultimately the chain is of length zero when the main routine returns ,NA,NA
control to the operating system. ,NA,NA
QUESTION 8:,NA,NA
Does your brain feel like a yo-yo? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_8.html [8/8/2545 11:33:17],NA
A good answer might be: ,NA,NA
Uhh.. ,NA,NA
Programming Language History,NA,NA
"Well,... this is not easy stuff. As proof of that statement, look to computer history. It took ",NA,NA
several decades before modern high level languages were established. The first one of any ,NA,NA
"importance was Algol, created about 1960. Algol established stack-based subroutine linking. ",NA,NA
But Algol never quite caught on. Pascal (created about 1974) was a milestone. It became ,NA,NA
highly popular and used this stack-based idea of subroutines (which it called procedures ,NA,NA
"and functions). Programming languages can be classified as ""Before Pascal"" and ""After ",NA,NA
"Pascal."" ",NA,NA
But let us return to the MIPS processor (created in the year 10 AP). ,NA,NA
QUESTION 9:,NA,NA
Is the MIPS instruction set (its machine instructions) optimized for subroutine ,NA,NA
call and return? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_9.html [8/8/2545 11:33:19],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Example Program,NA,NA
Some ,NA,NA
"computers, such ",NA,NA
and return machine instructions. But experimentally these add little to performance. The ,NA,NA
general ,NA,NA
as the Digital ,NA,NA
Equipment ,NA,NA
Corporation ,NA,NA
"(DEC) Vax, have ",NA,NA
specialized call ,NA,NA
purpose ,NA,NA
instructions of a reduced instruction set proved to be faster. ,NA,NA
Here is an example program: the program is to read in lines of text from the user. Lower ,NA,NA
case characters from each line are converted to upper case. The user quits the program by ,NA,NA
entering a single character 'Q' at the start of a line. ,NA,NA
QUESTION 10:,NA,NA
How can character 'a' be converted to character 'A'? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_10.html [8/8/2545 11:33:56],NA
A good answer might be: ,NA,NA
'a' - ('a' - 'A') == 'A',NA,NA
", or, ",NA,NA
'a' - 32 == 'A',NA,NA
. Subtracting 32 from a lower case character ,NA,NA
results in the corresponding upper case character (in ASCII). ,NA,NA
Complete Program Design,NA,NA
Here is the complete design of the program. Glance over it to get the general idea. Its ,NA,NA
individual routines are explaind in the following pages. The design calls for more ,NA,NA
"subroutines than usual, because the purpose is to show subroutine linkage. ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_11.html (1 of 2) [8/8/2545 11:34:20],NA
A subroutine starts with a pill-shaped box that shows the name of the subroutine. A box with ,NA,NA
"double vertical lines for its sides (like ""doLines:"" in main) designates a subroutine call. The ",NA,NA
"program starts execution with ""main"". ",NA,NA
QUESTION 11:,NA,NA
"At the maximum, how many levels deep is subroutine nesting in this ",NA,NA
program? ,NA,NA
A good answer might be: ,NA,NA
Four levels deep: ,NA,NA
main,NA,NA
 calls ,NA,NA
doLines,NA,NA
 which calls ,NA,NA
convert,NA,NA
 which calls ,NA,NA
conCh,NA,NA
. ,NA,NA
main,NA,NA
 Subroutine,NA,NA
An advantage of modular programming is that each subroutine can be displayed and ,NA,NA
explained independently of the others. At right is the design of ,NA,NA
main,NA,NA
. Below is the code for it. ,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 ??????                   # what goes here?,NA,NA
" la      $a0,mainPr       # prompt the user ",NA,NA
"li      $v0,4            # service 4",NA,NA
 syscall,NA,NA
 jal     doLines          # process lines of input,NA,NA
 ??????                   # what goes here?,NA,NA
 jr      $ra              # return to OS ,NA,NA
 .data ,NA,NA
"mainPr:  .ascii  ""Type each line of text followed by ENTER.\n""",NA,NA
" .asciiz ""Type Q at the start of a line to finish.\n""",NA,NA
QUESTION 12:,NA,NA
According to the ,NA,NA
Stack-based Calling convention,NA,NA
 does ,NA,NA
main,NA,NA
 need to push ,NA,NA
and later pop the return address? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_12.html [8/8/2545 11:34:25],NA
A good answer might be:,NA,NA
"Yes, because ",NA,NA
main,NA,NA
 calls a subroutine. The completed code for ,NA,NA
main,NA,NA
 is below. ,NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
" sub     $sp,$sp,4        # push the return address",NA,NA
" sw      $ra,($sp)",NA,NA
" la      $a0,mainPr       # prompt the user",NA,NA
" li      $v0,4            # service 4",NA,NA
 syscall,NA,NA
 jal     doLines          # process lines of input,NA,NA
" lw      $ra,($sp)        # pop return address",NA,NA
" add     $sp,$sp,4",NA,NA
 jr      $ra              # return to OS ,NA,NA
 .data ,NA,NA
"mainPr:  .ascii  ""Type each line of text followed by ENTER.\n""",NA,NA
 ,NA,NA
".asciiz ""Type Q at the start of a line to finish.\n""",NA,NA
Subroutine ,NA,NA
doLines,NA,NA
The ,NA,NA
main,NA,NA
 routine calls ,NA,NA
doLines,NA,NA
. At right is the design for that routine. Below is its ,NA,NA
(incomplete) code. ,NA,NA
# doLines -- read in and process each line of user input ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- address of the prompt text ,NA,NA
#    $ra -- return address ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    no return values,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_13.html (1 of 2) [8/8/2545 11:34:36],NA
 .text,NA,NA
 .globl  doLines ,NA,NA
doLines: ,NA,NA
" sub     $sp,$sp,4        # push the return address",NA,NA
" sw      $ra,($sp)",NA,NA
loop:                             # get a line,NA,NA
" la      $a0,________     # argument: address of buffer ",NA,NA
"li      $a1,____         # argument: length of buffer jal     ",NA,NA
_______          # get line from user,NA,NA
" la      $a0,line         # if ""Q""",NA,NA
 jal     testEnd          # return to caller,NA,NA
" beqz    $v0,endloop          ",NA,NA
 # convert to capitals,NA,NA
" la      $a0,________     # argument: address of buffer ",NA,NA
"la      $a1,____         # argument: length of buffer jal     ",NA,NA
_______          # convert,NA,NA
" la      $a0,outline      # print out the result ",NA,NA
"li      $v0,4",NA,NA
 syscall,NA,NA
 b       loop             # continue with next line,NA,NA
endloop: ,NA,NA
" lw      $ra,($sp)        # pop return address ",NA,NA
"add     $sp,$sp,4         ",NA,NA
 jr      $ra              # return to caller ,NA,NA
 .data ,NA,NA
"outline: .ascii  "":""              # padding so output lines up with input ",NA,NA
line:    .space  132              # input buffer,NA,NA
QUESTION 13:,NA,NA
No time like the present to fill in those blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_13.html (2 of 2) [8/8/2545 11:34:36],NA
A good answer might be:,NA,NA
"The relevant section is filled in, below. ",NA,NA
loop:                             # get a line,NA,NA
" la      $a0,line         # argument: address of buffer",NA,NA
" li      $a1,132          # argument: length of buffer",NA,NA
 jal     getline          # get line from user,NA,NA
" la      $a0,line         # if ""Q""",NA,NA
 jal     testEnd          # return to caller,NA,NA
" beqz    $v0,endloop          ",NA,NA
 # convert to capitals,NA,NA
" la      $a0,line         # argument: address of buffer",NA,NA
" li      $a1,132          # argument: length of buffer",NA,NA
 jal     convert          # convert,NA,NA
Subroutine ,NA,NA
convert,NA,NA
The first subroutine that ,NA,NA
doLines,NA,NA
" calls, ",NA,NA
getLine,NA,NA
", is easy enough. Let us look at the more ",NA,NA
interesting ,NA,NA
convert,NA,NA
. ,NA,NA
convert,NA,NA
 calls ,NA,NA
conChar,NA,NA
 for each character in the buffer. Since it calls a ,NA,NA
"subroutine, it can't use a ""T"" register to hold the character pointer. But it must return the ""S"" ",NA,NA
registers to its caller in exactly the same state it got them! ,NA,NA
"This is the situation that calls for pushing an ""S"" register on the stack, using it in the ",NA,NA
"subroutine body, and then popping it from the stack before returning to the caller. ",NA,NA
# convert -- convert a line to all capitals ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- address of input buffer ,NA,NA
#    $a1 -- length of input buffer ,NA,NA
# ,NA,NA
# register use: ,NA,NA
#    ,NA,NA
$s0 -- pointer into character buffer ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    no return values,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_14.html (1 of 2) [8/8/2545 11:34:47],NA
 .text,NA,NA
 .globl  convert ,NA,NA
convert: ,NA,NA
" sub     $sp,$sp,4        # push the return address",NA,NA
" sw      $ra,($sp)",NA,NA
 #    ,NA,NA
What should be done HERE??,NA,NA
 # for ( p=buffer; *p!=0; p++ ) ,NA,NA
"move    $s0,$a0          # p=buffer",NA,NA
"cloop:   lbu     $a0,(",NA,NA
$s0,NA,NA
)        # get a char from the string,NA,NA
" beqz    $a0,endC         # exit if null byte",NA,NA
 # argument a0: char to convert ,NA,NA
jal     conChar,NA,NA
          # convert character,NA,NA
" sb      $v0,(",NA,NA
$s0,NA,NA
)        # put converted char into string                 ,NA,NA
 addu    ,NA,NA
$s0,NA,NA
",",NA,NA
$s0,NA,NA
",1        # p++",NA,NA
 b       cloop         ,NA,NA
endC: ,NA,NA
 #    ,NA,NA
And hat should be done HERE??,NA,NA
 lw      ,NA,NA
"$ra,($sp)        # pop return address add     ",NA,NA
"$sp,$sp,4         ",NA,NA
 jr      $ra              # return to caller ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Complete Convert,NA,NA
convert,NA,NA
 uses ,NA,NA
$s0,NA,NA
 as a character pointer because ,NA,NA
$a0,NA,NA
 might be changed by ,NA,NA
conChar,NA,NA
. You ,NA,NA
might think that it would be a good idea to look inside ,NA,NA
conChar,NA,NA
" to see if, in fact, it actually ",NA,NA
changes ,NA,NA
$a0,NA,NA
. But this is a violation of modularity. It is much better to have a calling ,NA,NA
"convention, and to follow it, than to make modules interdependant. ",NA,NA
"For example, ",NA,NA
conChar,NA,NA
 doesn't actually alter ,NA,NA
$a0,NA,NA
". At least not now, but later on, ",NA,NA
conChar ,NA,NA
might be changed. Then we (or some unfortuante coder that got the job) would have to look ,NA,NA
everywhere ,NA,NA
conChar,NA,NA
 was used to see what assumptions were made. ,NA,NA
# convert -- convert a line to all capitals ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- address of input buffer ,NA,NA
#    $a1 -- length of input buffer ,NA,NA
# ,NA,NA
# register use: ,NA,NA
#    ,NA,NA
$s0 -- pointer into character buffer ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    no return values,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_15.html (1 of 2) [8/8/2545 11:35:04],NA
 .text,NA,NA
 .globl  convert ,NA,NA
convert: ,NA,NA
" sub     $sp,$sp,4        # push the return address",NA,NA
" sw      $ra,($sp) ",NA,NA
"sub     $sp,$sp,4        # push $s0",NA,NA
" sw      $s0,($sp)",NA,NA
 # for ( p=buffer; *p!=0; p++ ) ,NA,NA
"move    $s0,$a0          # p=buffer",NA,NA
"cloop:   lbu     $a0,($s0)        # get a char from the string",NA,NA
" beqz    $a0,endC         # exit if null byte",NA,NA
 # argument a0: char to convert,NA,NA
 jal     conChar          # convert character,NA,NA
" sb      $v0,($s0)        # put converted char into string                 ",NA,NA
" addu    $s0,$s0,1        # p++",NA,NA
 b       cloop         ,NA,NA
endC: ,NA,NA
"lw      $s0,($sp)        # pop $s0 ",NA,NA
" add     $sp,$sp,4",NA,NA
" lw      $ra,($sp)        # pop return address",NA,NA
" add     $sp,$sp,4         ",NA,NA
 jr      $ra              # return to caller ,NA,NA
A good answer might be: ,NA,NA
No. ,NA,NA
Complete Capitalize Program,NA,NA
Here is the complete program. It would be useful to copy it to a file and to run it with SPIM. ,NA,NA
# capitalize.asm --- convert user input to capitals and discard punctuation ,NA,NA
# ,NA,NA
"# This program uses stack-based linkage.  SPIM Settings: allow pseudoinstructions, ",NA,NA
"# disable delayed branches and disable delayed load, load trap file.",NA,NA
#,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" sub     $sp,$sp,4        # push the return address",NA,NA
" sw      $ra,($sp)",NA,NA
" la      $a0,mainPr       # prompt the user",NA,NA
" li      $v0,4            # service 4",NA,NA
 syscall,NA,NA
 jal     doLines          # process lines of input,NA,NA
" lw      $ra,($sp)        # pop return address",NA,NA
" add     $sp,$sp,4",NA,NA
 jr      $ra              # return to OS ,NA,NA
 .data ,NA,NA
"mainPr:  .ascii  ""Type each line of text followed by ENTER.\n""",NA,NA
 ,NA,NA
".asciiz ""Type Q at the start of a line to finish.\n""",NA,NA
# doLines -- read in and process each line of user input ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- address of the prompt text ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    no return values,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_16.html (1 of 5) [8/8/2545 11:35:08],NA
 .text,NA,NA
 .globl  doLines ,NA,NA
doLines: ,NA,NA
" sub     $sp,$sp,4        # push the return address",NA,NA
" sw      $ra,($sp)",NA,NA
loop:                             # get a line,NA,NA
" la      $a0,line         # argument: address of buffer ",NA,NA
"li      $a1,132          # argument: length of buffer jal     ",NA,NA
getLine          # get line from user,NA,NA
" la      $a0,line         # if ""Q""",NA,NA
 jal     testEnd          # return to caller,NA,NA
" beqz    $v0,endloop          ",NA,NA
 # convert to capitals,NA,NA
" la      $a0,line         # argument: address of buffer ",NA,NA
"la      $a1,132          # argument: length of buffer ",NA,NA
jal     convert,NA,NA
" la      $a0,outline      # print out the result",NA,NA
" li      $v0,4",NA,NA
 syscall,NA,NA
 b       loop             # continue with next line,NA,NA
endloop: ,NA,NA
" lw      $ra,($sp)        # pop return address ",NA,NA
"add     $sp,$sp,4         ",NA,NA
 jr      $ra              # return to caller ,NA,NA
 .data ,NA,NA
"outline: .ascii  "":""              # padding so output lines up with input ",NA,NA
line:    .space  132              # input buffer,NA,NA
# getLine -- read in a line of user input ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- address of input buffer ,NA,NA
#    $a1 -- length of buffer ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    no return values,NA,NA
 .text,NA,NA
 .globl  getLine ,NA,NA
getLine: ,NA,NA
" move    $t0,$a0          # save buffer address          ",NA,NA
" la      $a0,prompt       # prompt the user",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_16.html (2 of 5) [8/8/2545 11:35:08],NA
" li      $v0,4            # service 4",NA,NA
 syscall,NA,NA
" move    $a0,$t0          # restore buffer address",NA,NA
" li      $v0,8            # service 8",NA,NA
 syscall                  # read in a line to the buffer,NA,NA
 jr      $ra              # return to caller ,NA,NA
 .data ,NA,NA
prompt:,NA,NA
" .asciiz "">""",NA,NA
# testEnd -- check if a line is 'Q' ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- address of input buffer ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
"#    $v0 -- 0 if line is equal to Q, 1 if not",NA,NA
 .text,NA,NA
 .globl  testEnd ,NA,NA
testEnd: ,NA,NA
" li      $v0,1            # assume not equal",NA,NA
" lbu     $t0,0($a0)       # get first char of line",NA,NA
" li      $t1,'Q'          # get 'Q'",NA,NA
" bne     $t0,$t1,endT     # if not equal, end the test",NA,NA
" lbu     $t0,1($a0)       # get second char of line",NA,NA
" li      $t1,'\n'         # it should be CR",NA,NA
" bne     $t0,$t1,endT     # if not equal, end the test",NA,NA
" li      $v0,0            # 'Q' has been found",NA,NA
endT: ,NA,NA
 jr      $ra              # return to caller        ,NA,NA
# convert -- convert a line to all capitals ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- address of input buffer ,NA,NA
#    $a1 -- length of input buffer ,NA,NA
# ,NA,NA
# register use: ,NA,NA
#    $s0 -- pointer into character buffer ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    no return values,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_16.html (3 of 5) [8/8/2545 11:35:08],NA
 .text,NA,NA
 .globl  convert ,NA,NA
convert: ,NA,NA
" sub     $sp,$sp,4        # push the return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        # push $s0",NA,NA
" sw      $s0,($sp)",NA,NA
 # for ( p=buffer; *p!=0; p++ ),NA,NA
" move    $s0,$a0          # p=buffer",NA,NA
"cloop:   lbu     $a0,($s0)        # get a char from the string",NA,NA
" beqz    $a0,endC         # exit if null byte",NA,NA
 # argument a0: char to convert,NA,NA
 jal     conChar          # convert character,NA,NA
" sb      $v0,($s0)        # put converted char into string                 ",NA,NA
 ,NA,NA
"addu    $s0,$s0,1        # p++",NA,NA
 b       cloop         ,NA,NA
endC: ,NA,NA
" lw      $s0,($sp)        # pop $s0 ",NA,NA
" add     $sp,$sp,4                                     ",NA,NA
"lw      $ra,($sp)        # pop return address ",NA,NA
"add     $sp,$sp,4         ",NA,NA
 jr      $ra              # return to caller ,NA,NA
# conChar -- convert a character to a capital ,NA,NA
# ,NA,NA
# on entry: ,NA,NA
#    $a0 -- character ,NA,NA
# ,NA,NA
# on exit: ,NA,NA
#    $v0 -- converted character,NA,NA
 .text,NA,NA
 .globl  convert ,NA,NA
conChar: ,NA,NA
" move    $v0,$a0          # assume no change",NA,NA
 # is ch in 'a' .. 'z' /,NA,NA
" li      $t0,'a'          # ch < 'a' ?",NA,NA
" blt     $a0,$t0,outc    ",NA,NA
" li      $t0,'z'          # 'z' < ch ?",NA,NA
" blt     $t0,$a0,outc                     ",NA,NA
" sub     $v0,$a0,32       # convert to upper case",NA,NA
outc:    jr      $ra              # return to caller ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_16.html (4 of 5) [8/8/2545 11:35:08],NA
QUESTION 16:,NA,NA
In which subroutine is the buffer for the input characters? Is a copy of those ,NA,NA
characters made when other subroutines operate on them? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_16.html (5 of 5) [8/8/2545 11:35:08],NA
A good answer might be: ,NA,NA
The string buffer ,NA,NA
line,NA,NA
 is defined in ,NA,NA
doLines,NA,NA
. No copy is made of the characters in the ,NA,NA
"buffer. However, other subroutines have access to the buffer since its address is passed ",NA,NA
as an argument (in ,NA,NA
$a0,NA,NA
") to them. This technique is very common in ""C"" although, of ",NA,NA
"course, the syntax for doing it is different. ",NA,NA
End of the Chapter,NA,NA
You have reached the end this chapter. You may wish to review the following. Click on a ,NA,NA
subject that interests you to go to where it was discussed. ,G,NA
Pushing and popping the return address. ,G,NA
Pushing and popping registers.,G,NA
Stack-based Calling Convention.,G,NA
The prolog and epilog of a subroutine. ,G,NA
Activation of a subroutine.,G,NA
Activation chain.,G,NA
Algol and Pascal,NA,NA
 Go to Table of Contents,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-27/ass27_17.html [8/8/2545 11:35:13],NA
CHAPTER 28 — Frame-based Calling ,NA,NA
"Convention, Variables, and Recursion",NA,NA
This chapter builds further on the stack-based calling convention to create a frame-based ,NA,NA
calling convention. A ,NA,NA
stack frame,NA,NA
 is the section of the run-time stack that holds the data of ,NA,NA
a subroutine. ,NA,NA
Chapter Topics:,G,NA
Stack frames and the frame pointer.,G,NA
Local variables.,G,NA
Simplified Frame-based Calling Convention. ,G,NA
Compiler optimizations.,G,NA
Recursion.,G,NA
"Storage classes: static, automatic, dynamic. ",G,NA
Entry points.,NA,NA
QUESTION 1:,NA,NA
(Thought Question:) What is a ,NA,NA
local variable,NA,NA
 in a higher level language? ,NA,NA
A good answer might be: ,NA,NA
A ,NA,NA
local variable,NA,NA
 is a software entity that holds values for a subroutine while the ,NA,NA
subroutine is active. ,NA,NA
Implementation of Local Variables,NA,NA
In a high-level language a ,NA,NA
local variable,NA,NA
 is implemented as a location on the part of the run-,NA,NA
time stack the subroutine is using. Each activation of a subroutine pushes new data on the ,NA,NA
stack. The section of the stack for each activation is called a ,NA,NA
stack frame,NA,NA
 or an ,NA,NA
activation ,NA,NA
record.,NA,NA
 The ,NA,NA
frame pointer,NA,NA
 holds the address of the stack frame for a subroutine. ,NA,NA
The format of a stack frame used by MIPS language processors is complicated. There are ,NA,NA
many situations that must be handled and many optimizations. It takes a compiler to do it ,NA,NA
correctly. These notes describe a much simplified stack frame. ,NA,NA
The important part is to understand what a local variable is: a location on the run-time stack. ,NA,NA
"This is an important idea in Computer Science, one you will run into repeatedly as you study ",NA,NA
advanced topics. ,NA,NA
QUESTION 2:,NA,NA
In a high-level language are there variables that are not local? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_2.html [8/8/2545 11:37:38],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Picture of a Stack Frame,NA,NA
"Programming languages have global variables. Also, an inner program block can use ",NA,NA
variables (that are not its local variables) which are defined in a containing block. Let ,NA,NA
"us skip these messy details and implement local variables, only. The details may be ",NA,NA
convered in a course on compilers or in a course on programming languages. ,NA,NA
The picture shows what a stack frame looks like when a subroutine is active (in our ,NA,NA
"simplified format). As always (for us), each item on the stack is four bytes long. ",NA,NA
"As previously, the caller saves those ""T"" registers that contain values it needs, and the callee ",NA,NA
"(the subroutine) saves those ""S"" registers it will change. But now room is pushed onto the ",NA,NA
stack for (in the example) four local variables ,NA,NA
"a, b, i",NA,NA
 and ,NA,NA
j,NA,NA
. ,NA,NA
"While the subroutine is active, the frame pointer, register $30, points to the top of the stack. ",NA,NA
QUESTION 3:,NA,NA
Write the instruction that loads register ,NA,NA
$t5,NA,NA
 with the value held in the variable ,NA,NA
a,NA,NA
: ,NA,NA
"lw $t5,____( ____ )",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_3.html [8/8/2545 11:38:00],NA
A good answer might be: ,NA,NA
"lw $t5,12( $fp )",NA,NA
Frame Pointer,NA,NA
Register ,NA,NA
$30,NA,NA
" is reserved, by software convention, for use as a ",NA,NA
frame pointer,NA,NA
. In the ,NA,NA
extended assembler it has the mnemonic name . When a subroutine starts running the ,NA,NA
frame pointer and the stack pointer contain the same address. But the stack (and the stack ,NA,NA
pointer) may be involved in arithmetic expression evaluation. To make things easy for ,NA,NA
compilers (and for human assembly programmers) it is convenient to have a frame pointer ,NA,NA
that does not change its value while a subroutine is active. ,NA,NA
"When a routine calls a subroutine, the routine's frame pointer is pushed onto the stack along ",NA,NA
with the other caller-saved registers. Now the subroutine sets the frame pointer to the ,NA,NA
address of its stack frame. ,NA,NA
QUESTION 4:,NA,NA
"When a subroutine first starts executing, is the address in the frame pointer ",NA,NA
equal to the address of the top of the stack? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_4.html [8/8/2545 11:38:07],NA
A good answer might be: ,NA,NA
"Yes. However, the stack may grow as the subroutine executes. But the frame pointer for ",NA,NA
the subroutine does not change. The stack pointer (,NA,NA
$sp,NA,NA
) is always equal to the top of ,NA,NA
stack. ,NA,NA
Sample Code ,NA,NA
Imagine that the following statement is part of the subroutine whose stack frame is at ,NA,NA
right: ,NA,NA
a = b + i + j;,NA,NA
This is how a compiler might implement that statement: ,NA,NA
"lw    $t0,8($fp)     # get b ",NA,NA
"lw    $t1,4($fp)     # get i ",NA,NA
"lw    $t2,0($fp)     # get j ",NA,NA
"addu  $t3,$t0,$t1    # b + i ",NA,NA
"addu  $t3,$t3,$t2    # b + i + j ",NA,NA
"sw    $t3,12($fp)    # a = ",NA,NA
QUESTION 5:,NA,NA
Play compiler: translate the following statement into assembly language: ,NA,NA
a = a + 1;,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_5.html [8/8/2545 11:38:29],NA
a = a + 1;,NA,NA
A good answer might be:,NA,NA
"lw      $t0,12($fp)    # get a ",NA,NA
"addiu   $t0,$t0,1      # a + 1 ",NA,NA
"sw      $t0,12($fp)    # a = ",NA,NA
Our Frame-based Calling Convention,NA,NA
"A real-world calling convention allows variables other than integers, array variables, ",NA,NA
"parameters of various sorts, parameters on the stack, and other situations. Our rules are ",NA,NA
simpler: ,NA,NA
Calling a Subroutine (done by the caller): ,NA,NA
1.  The caller pushes any registers ,NA,NA
$t0-$t9,NA,NA
 that contain values ,NA,NA
that must be saved. Push the registers in numerical order. ,NA,NA
2.  Put argument values into ,NA,NA
$a0-$a3,NA,NA
.,NA,NA
3.  Call the subroutine using ,NA,NA
jal,NA,NA
.,NA,NA
Subroutine Prolog (at the start of the subroutine): ,NA,NA
1.  Push ,NA,NA
$ra,NA,NA
.,NA,NA
2.  Push the caller's frame pointer ,NA,NA
$fp,NA,NA
.,NA,NA
3.  Push any of the registers ,NA,NA
$s0-$s7,NA,NA
 that the subroutine might ,NA,NA
alter. ,NA,NA
4.  Initialize the frame pointer: ,NA,NA
$fp = $sp - space_for_variables,NA,NA
. ,NA,NA
"The ""space for variables"" is four times the number of local ",NA,NA
"variables. (Remember that using ""-"" grows the stack).",NA,NA
5.  Initialize the stack pointer: ,NA,NA
$sp = $fp.,NA,NA
Subroutine Body: ,NA,NA
1.  At this point the stack looks like the picture at right.,NA,NA
"2.  The subroutine may alter any ""T"" or ""A"" register or any ""S"" ",NA,NA
register that it saved in the prolog.,NA,NA
3.  The subroutine refers to local variables as ,NA,NA
disp($fp) ,NA,NA
. ,NA,NA
4.  The subroutine may push and pop values on the stack using ,NA,NA
$sp,NA,NA
.,NA,NA
"5.  If the subroutine calls another subroutine, then it does so by ",NA,NA
following these rules.,NA,NA
Subroutine Epilog (at the end of the subroutine): ,NA,NA
1.  Put return values in ,NA,NA
$v0-$v1 ,NA,NA
2.  ,NA,NA
$sp = $fp + space_for_variables,NA,NA
. ,NA,NA
3.  Pop any registers ,NA,NA
$s0-$s7,NA,NA
 that were previously saved in the ,NA,NA
frame.,NA,NA
4.  Pop the caller's frame pointer into ,NA,NA
$fp,NA,NA
. ,NA,NA
5.  Pop ,NA,NA
$ra,NA,NA
. ,NA,NA
6.  Return to the caller using ,NA,NA
jr $ra,NA,NA
.,NA,NA
Return from a Subroutine (done by the caller): ,NA,NA
1.  Pop any registers ,NA,NA
$t0-$t9,NA,NA
 that the caller previously pushed.,NA,NA
QUESTION 6:,NA,NA
"When the caller gets control back, are its frame pointer and stack pointer the ",NA,NA
same as when it called the subroutine? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_6.html (2 of 2) [8/8/2545 11:38:40],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Diagram ,NA,NA
Those rules are nasty. In broad outline it works the same way as the previous chapter's ,NA,NA
stack-based calling convention. ,NA,NA
Here is a picture. It shows the four sections of subroutine linkage. The basic tasks of each ,NA,NA
section are: ,NA,NA
Subroutine Call:,NA,NA
" Push any ""T"" registers that values that are needed. Put ",NA,NA
"arguments in ""A"" registers. ",NA,NA
jal,NA,NA
 to the subroutine. ,NA,NA
Prolog:,NA,NA
 Push ,NA,NA
$ra,NA,NA
", and caller's ",NA,NA
$fp,NA,NA
". Push any ""S"" register the subroutine will alter. ",NA,NA
Initialize subroutine's ,NA,NA
$fp,NA,NA
 and ,NA,NA
$sp,NA,NA
. ,NA,NA
Body:,NA,NA
" Normal code, except it must follow these conventions if it calls another ",NA,NA
"subroutine. ""T"" and ""A"" registers can be used freely, as can any ""S"" registers that ",NA,NA
were saved in the prolog. Variables are accessed using ,NA,NA
disp($fp),NA,NA
. ,NA,NA
Epilog:,NA,NA
" Put return values in ""V"" registers. Reset ",NA,NA
$sp,NA,NA
". Pop any ""S"" registers. Pop ",NA,NA
the caller's ,NA,NA
$fp,NA,NA
 and ,NA,NA
$ra,NA,NA
. ,NA,NA
jr $ra,NA,NA
 back to the caller. ,NA,NA
Return:,NA,NA
" Pop any previously pushed ""T"" registers. ",NA,NA
QUESTION 7:,NA,NA
Is there a limit to how many variables a subroutine may have? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_7.html [8/8/2545 11:39:06],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Example Program,NA,NA
The number of registers of MIPS (or other processor) does not limit the number of variables ,NA,NA
that subroutines can have. As many variables as you want can be allocated on the stack. ,NA,NA
Here is an example program. ,NA,NA
main() ,NA,NA
{,NA,NA
 int a;,NA,NA
 a = mysub( 6 );,NA,NA
 print( a ); ,NA,NA
},NA,NA
int mysub( int arg ) ,NA,NA
{,NA,NA
" int b,c;",NA,NA
 b = arg*2;,NA,NA
 c = b + 7;,NA,NA
 return c;  ,NA,NA
},NA,NA
"To the operating system, ",NA,NA
main(),NA,NA
 is a subroutine. When it first gets control it must follow the ,NA,NA
"rules under ""subroutine prolog"". ",NA,NA
QUESTION 8:,NA,NA
How much space on the stack is needed for ,NA,NA
main(),NA,NA
's variable? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_8.html [8/8/2545 11:39:21],NA
A good answer might be: ,NA,NA
Four bytes. ,NA,NA
main(),NA,NA
Here is the code for ,NA,NA
main(),NA,NA
", with some blanks. The rules for the subroutine prolog are ",NA,NA
copied from above. ,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
#    int a; ,NA,NA
#    a = mysub( 6 ); ,NA,NA
#    print( a ); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
" sw      $fp,($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" sub     ___,____,____    #   4. $fp = $sp - space_for_variables",NA,NA
" _____  $sp,$fp           #   5. $sp = $fp",NA,NA
 # subroutine call,NA,NA
 . . . .,NA,NA
 # return from subroutine   ,NA,NA
 . . . .     ,NA,NA
 jr      $ra              # return to OS ,NA,NA
QUESTION 9:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_9.html (1 of 2) [8/8/2545 11:39:23],NA
Fill in the blanks as the comments suggest. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_9.html (2 of 2) [8/8/2545 11:39:23],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Subroutine Call,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
#    int a; ,NA,NA
#    a = mysub( 6 ); ,NA,NA
#    print( a );,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer sw      ",NA,NA
"$fp,($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" sub     $fp,$sp,4        #   4. $fp = $sp - space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # subroutine call,NA,NA
 #   1. No T registers to push,NA,NA
" li      $a0,___          #   2. Put argument into $a0",NA,NA
 jal     _______          #   3. Jump and link to subroutine,NA,NA
 # return from subroutine   ,NA,NA
 . . . .     ,NA,NA
 jr      $ra              # return to OS ,NA,NA
QUESTION 10:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_10.html (1 of 2) [8/8/2545 11:39:25],NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_10.html (2 of 2) [8/8/2545 11:39:25],NA
A good answer might be:,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
#    int a; ,NA,NA
#    a = mysub( 6 ); ,NA,NA
#    print( a ); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
" sw      $ra,($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" addiu   $fp,$sp,4        #   4. $fp = $sp + space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # subroutine call,NA,NA
 #   1. No T registers to push,NA,NA
" li      $a0,6            #   2. Put argument into $a0",NA,NA
 jal     mysub            #   3. Jump and link to subroutine,NA,NA
 # return from subroutine   ,NA,NA
 . . . .     ,NA,NA
 jr      $ra              # return to OS ,NA,NA
Prolog for ,NA,NA
mysub(),NA,NA
"Of course, ",NA,NA
mysub,NA,NA
" starts with a subroutine prolog. There are two variables, so space is ",NA,NA
assigned to them on the stack. ,NA,NA
#  int mysub( int arg ) ,NA,NA
#  { ,NA,NA
"#    int b,c;                     // b: 0($fp) ",NA,NA
#                                 // c: 4($fp),http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_11.html (1 of 2) [8/8/2545 11:39:38],NA
#    b = arg*2; ,NA,NA
#    c = b + 7; ,NA,NA
# ,NA,NA
#    return c; ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  ______ ,NA,NA
______:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
" sw      $fp,($sp)",NA,NA
" ____    ___,___,___      #   3. Push register $s1",NA,NA
" ____    ___,_____",NA,NA
" sub    $fp,$sp,____     #   4. $fp = $sp - space_for_variables",NA,NA
" move   $sp,$fp          #   5. $sp = $fp",NA,NA
 . . . .     ,NA,NA
 jr      $ra              # return to caller ,NA,NA
The subroutine could be written without using ,NA,NA
$s1,NA,NA
. It is used to show how linkage works. ,NA,NA
QUESTION 11:,NA,NA
Fill in those blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_11.html (2 of 2) [8/8/2545 11:39:38],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Using Variables,NA,NA
The subroutine uses two variables so there is eight bytes of space on the stack frame for ,NA,NA
them. ,NA,NA
#  int mysub( int arg ) ,NA,NA
#  { ,NA,NA
"#    int b,c;                     // b: 0($fp) ",NA,NA
#                                 // c: 4($fp) ,NA,NA
#    b = arg*2; ,NA,NA
#    c = b + 7; ,NA,NA
# ,NA,NA
#    return c; ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  mysub ,NA,NA
mysub:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
" sw      $fp,($sp)",NA,NA
" sub     $sp,$sp,4        #   3. Push register $s1",NA,NA
" sw      $s1,($sp)",NA,NA
" sub     $fp,$sp,8        #   4. $fp = $sp - space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # body of subroutine     ,NA,NA
" mul     $s1,$a0,2        # arg*2",NA,NA
" sw      $s1,___(___)     # b = ""   """,NA,NA
" lw      $t0,___(___)     # get b",NA,NA
" add     $t0,$t0,___      # b+7",NA,NA
" sw      $t0,___(___)     # c = ""  """,NA,NA
 . . . . .,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_12.html (1 of 2) [8/8/2545 11:40:09],NA
 jr      $ra              # return to caller ,NA,NA
"The program is not very efficient, as written. There is no need to store and then load ",NA,NA
b,NA,NA
. A ,NA,NA
"non-optimizing compiler might do just that, however. ",NA,NA
QUESTION 12:,NA,NA
Fill in the blanks. Assume that ,NA,NA
b,NA,NA
 is at displacement ,NA,NA
0,NA,NA
 and that ,NA,NA
c,NA,NA
 is at ,NA,NA
displacement ,NA,NA
4,NA,NA
. ,NA,NA
A good answer might be: ,NA,NA
See Below ,NA,NA
Subroutine Epilog,NA,NA
The epilog of a subroutine is the part that prepares the values that are returned to the caller ,NA,NA
and restores the registers and stack to where they were when the caller made the call. ,NA,NA
#  int mysub( int arg ) ,NA,NA
#  { ,NA,NA
"#    int b,c;                     // b: 0($fp) ",NA,NA
#                                 // c: 4($fp) ,NA,NA
#    b = arg*2; ,NA,NA
#    c = b + 7; ,NA,NA
# ,NA,NA
#    return c; ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  mysub ,NA,NA
mysub:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   3. Push register $s1",NA,NA
" sw      $s1,($sp)",NA,NA
" addiu   $fp,$sp,8        #   4. $fp = $sp + space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # body of subroutine     ,NA,NA
" mul     $s1,$a0,2        #     arg*2",NA,NA
" sw      $s1,0($fp)       # b = ""   """,NA,NA
" lw      $t0,0($fp)       # get b",NA,NA
" add     $t0,$t0,7        #      b+7",NA,NA
" sw      $t0,4($fp)       # c = ""  """,NA,NA
 # epilog,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_13.html (1 of 2) [8/8/2545 11:40:22],NA
" lw      $v0,___(___)     #   1. Put return value in $v0",NA,NA
" add     $sp,$fp,____     #   2. $sp = $fp +space_for_variables ",NA,NA
"lw      $s1,(____)       #   3. Pop register $s1",NA,NA
" add     ___,___,___      #   ",NA,NA
" lw      $fp,(____)       #   4. Pop $fp",NA,NA
" add     ___,___,___      #   ",NA,NA
" lw      $ra,(____)       #   5. Pop $ra",NA,NA
" add     ___,___,___      #   ",NA,NA
 jr      $ra              #   6. return to caller ,NA,NA
QUESTION 13:,NA,NA
Those blanks need filling. ,NA,NA
A good answer might be: ,NA,NA
See Below. ,NA,NA
Complete ,NA,NA
mysub(),NA,NA
#  int mysub( int arg ) ,NA,NA
#  { ,NA,NA
"#    int b,c;                     // b: 0($fp) ",NA,NA
#                                 // c: 4($fp) ,NA,NA
#    b = arg*2; ,NA,NA
#    c = b + 7; ,NA,NA
# ,NA,NA
#    return c; ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  mysub ,NA,NA
mysub:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
 sw      ,NA,NA
"$fp,($sp)",NA,NA
" sub     $sp,$sp,4        #   3. Push register $s1",NA,NA
" sw      $s1,($sp)",NA,NA
" sub     $fp,$sp,8        #   4. $fp = $sp - space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # body of subroutine     ,NA,NA
" mul     $s1,$a0,2        #     arg*2",NA,NA
" sw      $s1,0($fp)       # b = ""   """,NA,NA
" lw      $t0,0($fp)       # get b",NA,NA
" add     $t0,$t0,7        #     b+7",NA,NA
" sw      $t0,4($fp)       # c = ""  """,NA,NA
 # epilog,NA,NA
" lw      $v0,4($fp)       #   1. Put return value in $v0         add     ",NA,NA
"$sp,$fp,8        #   2. $sp = $fp + space_for_variables lw      ",NA,NA
"$s1,($sp)        #   3. Pop register $s1",NA,NA
" add     $sp,$sp,4        #          ",NA,NA
" lw      $fp,($sp)        #   4. Pop $fp",NA,NA
" add     $sp,$sp,4        #           ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_14.html (1 of 2) [8/8/2545 11:40:33],NA
" lw      $ra,($sp)        #   5. Pop $ra",NA,NA
" add     $sp,$sp,4        #            ",NA,NA
 jr      $ra              #   6. return to caller ,NA,NA
QUESTION 14:,NA,NA
What must the caller do when control returns to it? ,NA,NA
A good answer might be: ,NA,NA
"The caller must restore any ""T"" registers it saved. ",NA,NA
Back to ,NA,NA
main(),NA,NA
"In this example, ",NA,NA
main(),NA,NA
" did not save any ""T"" registers. There is nothing to do for the return ",NA,NA
"from the subroutine, other than use the value that was returned in ",NA,NA
$v0,NA,NA
. ,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
#    int a;                      // a: 0($fp) ,NA,NA
#    a = mysub( 6 ); ,NA,NA
#    print( a ); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
 sw      ,NA,NA
"$fp,($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" sub     $fp,$sp,4        #   4. $fp = $sp - space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # subroutine call,NA,NA
 #   1. No T registers to push,NA,NA
" li      $a0,6            #   2. Put argument into $a0",NA,NA
 jal     mysub            #   3. Jump and link to subroutine,NA,NA
 # return from subroutine ,NA,NA
 #   1. No T registers to restore,NA,NA
" sw     $v0,__(___)       # a = mysub( 6 )",NA,NA
 # print a,NA,NA
" lw     $a0,__(___)       # load a into $a0 li     ",NA,NA
"$v0,1             # print integer service ",NA,NA
syscall,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_15.html (1 of 2) [8/8/2545 11:40:39],NA
 # epilog,NA,NA
 #   1. No return value         ,NA,NA
" add     $sp,$fp,4        #   2. $sp = $fp + space_for_variables       ",NA,NA
 #   3. No S registers to pop      ,NA,NA
" lw      $fp,($sp)        #   4. Pop $fp",NA,NA
" add     $sp,$sp,4        #           ",NA,NA
" lw      $ra,($sp)        #   5. Pop $ra",NA,NA
" add     $sp,$sp,4        #                                    ",NA,NA
 jr      $ra              # return to OS ,NA,NA
QUESTION 15:,NA,NA
Fill in the blanks. ,NA,NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Complete ,NA,NA
main(),NA,NA
Here is the complete ,NA,NA
main(),NA,NA
 routine. Nearly all of the code is concerned with subroutine ,NA,NA
linkage. This is typical. Optimizing compilers produce much more efficient code than this. ,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
#    int a;                      // a: 0($fp) ,NA,NA
#    a = mysub( 6 ); ,NA,NA
#    print( a ); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
 sw      ,NA,NA
"$fp,($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" sub     $fp,$sp,4        #   4. $fp = $sp - space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # subroutine call,NA,NA
 #   1. No T registers to push,NA,NA
" li      $a0,6            #   2. Put argument into $a0",NA,NA
 jal     mysub            #   3. Jump and link to subroutine,NA,NA
 # return from subroutine ,NA,NA
 #   1. No T registers to restore,NA,NA
" sw     $v0,0($fp)        # a = mysub( 6 )",NA,NA
 # print a,NA,NA
" lw     $a0,0($fp)        # load a into $a0 li     ",NA,NA
"$v0,1             # print integer service ",NA,NA
syscall                                  ,NA,NA
 # epilog,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_16.html (1 of 2) [8/8/2545 11:40:51],NA
 #   1. No return value         ,NA,NA
" add     $sp,$fp,4        #   2. $sp = $fp + space_for_variables       ",NA,NA
 #   3. No S registers to pop      ,NA,NA
" lw      $fp,($sp)        #   4. Pop $fp",NA,NA
" add     $sp,$sp,4        #           ",NA,NA
" lw      $ra,($sp)        #   5. Pop $ra",NA,NA
" add     $sp,$sp,4        #                                    ",NA,NA
 jr      $ra              # return to OS ,NA,NA
"If you wish to run the program, copy and paste ",NA,NA
main(),NA,NA
 and ,NA,NA
mysub(),NA,NA
 into one file. ,NA,NA
QUESTION 16:,NA,NA
Rewrite the following code so that it does the same thing as the original but ,NA,NA
without using a variable. ,NA,NA
 main(),NA,NA
 {,NA,NA
 int a;   ,NA,NA
 a = mysub( 6 );,NA,NA
 print( a );,NA,NA
 },http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_16.html (2 of 2) [8/8/2545 11:40:51],NA
A good answer might be:,NA,NA
Optimizing compilers sometimes examine the source code and rewrite it into something ,NA,NA
"more efficient, such as: ",NA,NA
 main(),NA,NA
 {,NA,NA
 print(  mysub( 6 ) );,NA,NA
 },NA,NA
Example Program: Factorial( N ),NA,NA
The next example program prompts the user for an ,NA,NA
"integer, reads in the integer, and prints the factorial. The ",NA,NA
SPIM console window is at right. The pseudo-code for ,NA,NA
the program is: ,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
"#    int a, b;                      // a: 0($fp),  b: 4($fp) ",NA,NA
"#    write(""enter an int:"") ",NA,NA
#    read( a ); ,NA,NA
#    b = fact( a ); ,NA,NA
"#    write(""factorial is:"") ",NA,NA
#    print( b ); ,NA,NA
#  },NA,NA
#  int fact( int n ) ,NA,NA
#  { ,NA,NA
#    if ( n<=1) ,NA,NA
#      return 1; ,NA,NA
#    else ,NA,NA
#      return n*fact(n-1); ,NA,NA
#  },NA,NA
QUESTION 17:,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_17.html (1 of 2) [8/8/2545 11:41:00],NA
You have very likely seen the factorial function before (and are very likely ,NA,NA
sick of it!) But just in case: ,NA,NA
What is the factorial of 5? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_17.html (2 of 2) [8/8/2545 11:41:00],NA
A good answer might be:,NA,NA
fact(5) == 5*fact(4),NA,NA
 == 5*( 4*fact(3) ) ,NA,NA
 == 5*( 4*( 3*fact(2)) ),NA,NA
 == 5*( 4*( 3*(2*fact(1))) ) ,NA,NA
 == 5*( 4*( 3*(2*1)) ) ,NA,NA
 == 5*4*3*2*1 ,NA,NA
 == 120,NA,NA
Activation Chain,NA,NA
If the subroutine ,NA,NA
fact(),NA,NA
 is called with an argument greater ,NA,NA
"than one, it calls itself, ",NA,NA
fact(),NA,NA
", with a new argument. This ",NA,NA
works because the data needed for the first activation ,NA,NA
of,NA,NA
fact(),NA,NA
 is pushed onto the stack. When that activation gets ,NA,NA
control again that data is popped from the stack. Often this ,NA,NA
process is illustrated as at right. ,NA,NA
Each bead on the activation chain represents an activation ,NA,NA
of a subroutine. The label on a downward arc is the ,NA,NA
argument to the subroutine. The label on an upward ard is ,NA,NA
the returned value. ,NA,NA
Each beads on the activation chain corresponds to one stack ,NA,NA
frame. The picture of the stack shows what it looks like when ,NA,NA
the activation ,NA,NA
fact(1),NA,NA
 is running. ,NA,NA
QUESTION 18:,NA,NA
A downward arc corresponds to a _______ of one stack frame. An upward ,NA,NA
arc corresponds to a _______ of one stack frame. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_18.html [8/8/2545 11:41:24],NA
A good answer might be: ,NA,NA
A downward arc corresponds to a ,NA,NA
push,NA,NA
 of one stack frame. An upward arc corresponds ,NA,NA
to a ,NA,NA
pop,NA,NA
 of one stack frame. ,NA,NA
Prolog of ,NA,NA
main(),NA,NA
Here is the main routine's pseudocode and prolog. Notice that there are two variables. ,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
"#    int a, b;                      // a: 0($fp),  b: 4($fp) ",NA,NA
"#    write(""enter an int:"") ",NA,NA
#    read( a ); ,NA,NA
#    b = fact( a ); ,NA,NA
"#    write(""factorial is:"") ",NA,NA
#    print( b ); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
 sw      $,NA,NA
__,NA,NA
",($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
 sw      $,NA,NA
__,NA,NA
",($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" sub     $fp,$sp",NA,NA
",_____",NA,NA
    #   4. $fp = $sp - space_for_variables,NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
QUESTION 19:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_19.html [8/8/2545 11:42:18],NA
A good answer might be:,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
"#    int a, b;                      // a: 0($fp),  b: 4($fp) ",NA,NA
"#    write(""enter an int:"") ",NA,NA
#    read( a ); ,NA,NA
#    b = fact( a ); ,NA,NA
"#    write(""factorial is:"") ",NA,NA
#    print( b ); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
 sw      $,NA,NA
ra,NA,NA
",($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
 ,NA,NA
sw      $,NA,NA
fp,NA,NA
",($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" sub     $fp,$sp,",NA,NA
8,NA,NA
        #   4. $fp = $sp - space_for_variables,NA,NA
 ,NA,NA
"move    $sp,$fp          #   5. $sp = $fp",NA,NA
Guts of ,NA,NA
main(),NA,NA
The next part of ,NA,NA
main(),NA,NA
 is straightforward. The SPIM trap services for writing a string and ,NA,NA
reading an integer are used. The integer is returned in ,NA,NA
$v0,NA,NA
. It is saved in the variable ,NA,NA
a,NA,NA
 (on ,NA,NA
the stack). ,NA,NA
" # write(""enter an int:"")",NA,NA
" li     $v0,4             #   print string service la     ",NA,NA
"$a0,prompt1       #   address of prompt ",NA,NA
syscall,NA,NA
 # read( a ),NA,NA
" li     $v0,5             #   read integer service ",NA,NA
syscall                  #   $v0 gets the integer sw     ,NA,NA
"$v0,0($fp)        #   save in variable a",NA,NA
Next the code implements ,NA,NA
b = fact( a ),NA,NA
. This is done by following the protocol for a ,NA,NA
"subroutine call, then storing the returned value into the variable ",NA,NA
b,NA,NA
: ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_20.html (1 of 2) [8/8/2545 11:42:26],NA
 # subroutine call: b = fact( a ),NA,NA
 #   1. No T registers to push,NA,NA
" lw      $a0,",NA,NA
_____,NA,NA
($fp)   #   2. Put argument into $a0,NA,NA
 jal     ,NA,NA
_____,NA,NA
            #   3. Jump and link to subroutine,NA,NA
 # return from subroutine ,NA,NA
 #   1. No T registers to restore,NA,NA
" sw     $v0,",NA,NA
_____,NA,NA
($fp)    # b = fact( a ),NA,NA
QUESTION 20:,NA,NA
Fill in the blanks. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_20.html (2 of 2) [8/8/2545 11:42:26],NA
A good answer might be:,NA,NA
 # subroutine call: b = fact( a ),NA,NA
 #   1. No T registers to push,NA,NA
" lw      $a0,",NA,NA
0,NA,NA
($fp)       #   2. Put argument into $a0,NA,NA
 jal     ,NA,NA
fact,NA,NA
             #   3. Jump and link to subroutine,NA,NA
 # return from subroutine ,NA,NA
 #   1. No T registers to restore,NA,NA
" sw     $v0,",NA,NA
4,NA,NA
($fp)        # b = fact( a ),NA,NA
More ,NA,NA
main(),NA,NA
Next ,NA,NA
main(),NA,NA
 does some utterly routine things: ,NA,NA
 # print( b ),NA,NA
" lw     $a0,4($fp)        # load a into $a0 li     ",NA,NA
"$v0,1             # print integer service ",NA,NA
syscall                                  ,NA,NA
 # end the print line,NA,NA
" li     $v0,4             #   print string service ",NA,NA
"la     $a0,lf            #   address of line feed ",NA,NA
syscall,NA,NA
"Finally, ",NA,NA
main(),NA,NA
 ends with a subroutine epilog. The data for the prompts is not stored on the ,NA,NA
stack. ,NA,NA
 # epilog,NA,NA
 #   1. No return value         ,NA,NA
" add     $sp,$fp,8        #   2. $sp = $fp + space_for_variables       ",NA,NA
 #   3. No S registers to pop      ,NA,NA
" lw      $fp,($sp)        #   4. Pop $fp",NA,NA
" add     $sp,$sp,4        #           ",NA,NA
" lw      $ra,($sp)        #   5. Pop $ra",NA,NA
" add     $sp,$sp,4        #                                    ",NA,NA
 jr      $ra              # return to OS ,NA,NA
 .data,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_21.html (1 of 2) [8/8/2545 11:42:33],NA
"prompt1: .asciiz ""enter an int:"" ",NA,NA
"prompt2: .asciiz ""factorial is:"" ",NA,NA
"lf:      .asciiz ""\n""",NA,NA
QUESTION 21:,NA,NA
How do the variables ,NA,NA
a,NA,NA
 and ,NA,NA
b,NA,NA
 differ from the data ,NA,NA
prompt1,NA,NA
 and ,NA,NA
prompt2,NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
a,NA,NA
 and ,NA,NA
b,NA,NA
: (1) Storage for them exists only while the subroutine is active (while it has not ,NA,NA
"yet returned control to its caller). (2) When it exists, the storage is on the run-time stack. ",NA,NA
prompt1,NA,NA
 and ,NA,NA
prompt2,NA,NA
: (1) Storage for them exists while the program is in main storage. ,NA,NA
(2) Storage is in the data section of memory. ,NA,NA
Storage Classes,NA,NA
There are three places in memory where data may ,NA,NA
be placed: in the data section (declared with ,NA,NA
.data,NA,NA
 in ,NA,NA
"assembly language), on the run-time stack, and on ",NA,NA
the heap. ,NA,NA
A subroutine other than ,NA,NA
main(),NA,NA
 can have data in the ,NA,NA
.data,NA,NA
" section. In high-level programming languages, ",NA,NA
"such as ""C"", this type of storage is called ",NA,NA
static,NA,NA
. ,NA,NA
Variables whose storage is allocated on the run-time ,NA,NA
stack are (sometimes) called ,NA,NA
automatic,NA,NA
 variables. ,NA,NA
"This is because their storage is ""automatically"" ",NA,NA
pushed and popped as a subroutine is entered and ,NA,NA
"exited. Usually the word ""variable"" means ",NA,NA
"""automatic variable"". ",NA,NA
A variable whose memory is located in the heap is ,NA,NA
called a ,NA,NA
dynamic variable,NA,NA
. These notes only briefly ,NA,NA
deal with the heap. The heap is where memory for ,NA,NA
objects is found (using the ,NA,NA
new,NA,NA
 operation in Java or ,NA,NA
"C++). In ""C"" dynamic memory is allocated using the ",NA,NA
malloc,NA,NA
 operation (or similar). ,NA,NA
The ,NA,NA
heap,NA,NA
 is on top of the data segment. As dynamic variables are created it grows upward ,NA,NA
(towards the stack) ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_22.html (1 of 2) [8/8/2545 11:42:41],NA
QUESTION 22:,NA,NA
(Review:) What happens if the stack and heap get larger and larger? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_22.html (2 of 2) [8/8/2545 11:42:41],NA
A good answer might be: ,NA,NA
"If the combined size of the the stack, the data, and the heap is less than the total ",NA,NA
"available memory, then there is no problem. ",NA,NA
Complete ,NA,NA
main(),NA,NA
Back the the example program (you were probably hoping that I'd forget). Here is the ,NA,NA
complete ,NA,NA
main(),NA,NA
. There is nothing new in it; its listed here so you can see all the parts in ,NA,NA
place. ,NA,NA
#  main() ,NA,NA
#  { ,NA,NA
"#    int a, b;                      // a: 0($fp),  b: 4($fp) ",NA,NA
"#    write(""enter an int:"") ",NA,NA
#    read( a ); ,NA,NA
#    b = fact( a ); ,NA,NA
"#    write(""factorial is:"") ",NA,NA
#    print( b ); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  main ,NA,NA
main:,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
 sw      ,NA,NA
"$fp,($sp)",NA,NA
 #   3. No S registers to push,NA,NA
" sub     $fp,$sp,8        #   4. $fp = $sp - space_for_variables",NA,NA
" move    $sp,$fp          #   5. $sp = $fp",NA,NA
" # write(""enter an int:"")",NA,NA
" li     $v0,4             #   print string service la     ",NA,NA
"$a0,prompt1       #   address of prompt ",NA,NA
syscall,NA,NA
 # read( a ),NA,NA
" li     $v0,5             #   read integer service ",NA,NA
syscall                  #   $v0 gets the integer sw     ,NA,NA
"$v0,0($fp)        #   save in variable a",NA,NA
 # subroutine call,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_23.html (1 of 2) [8/8/2545 11:42:52],NA
 #   1. No T registers to push,NA,NA
" lw      $a0,0($fp)       #   2. Put argument into $a0",NA,NA
 jal     fact             #   3. Jump and link to subroutine,NA,NA
 # return from subroutine ,NA,NA
 #   1. No T registers to restore,NA,NA
" sw     $v0,4($fp)        # b = fact( a )",NA,NA
" # write(""factorial is:"")",NA,NA
" li     $v0,4             #   print string service",NA,NA
" la     $a0,prompt2       #   address of prompt",NA,NA
 syscall,NA,NA
 # print( b ),NA,NA
" lw     $a0,4($fp)        # load a into $a0",NA,NA
" li     $v0,1             # print integer service",NA,NA
 syscall                                  ,NA,NA
 # end the print line,NA,NA
" li     $v0,4             #   print string service",NA,NA
" la     $a0,lf            #   address of line feed",NA,NA
 syscall,NA,NA
 # epilog,NA,NA
 #   1. No return value         ,NA,NA
" add     $sp,$fp,8        #   2. $sp = $fp + space_for_variables       ",NA,NA
 #   3. No S registers to pop      ,NA,NA
" lw      $fp,($sp)        #   4. Pop $fp",NA,NA
" add     $sp,$sp,4        #           ",NA,NA
" lw      $ra,($sp)        #   5. Pop $ra",NA,NA
" add     $sp,$sp,4        #                                    ",NA,NA
 jr      $ra              # return to OS ,NA,NA
 .data ,NA,NA
"prompt1: .asciiz ""enter an int:"" ",NA,NA
"prompt2: .asciiz ""factorial is:"" ",NA,NA
"lf:      .asciiz ""\n""",NA,NA
QUESTION 23:,NA,NA
What subroutine does ,NA,NA
main(),NA,NA
 call? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_23.html (2 of 2) [8/8/2545 11:42:52],NA
A good answer might be: ,NA,NA
fact,NA,NA
Entry Point,NA,NA
The first address in this subroutine is called ,NA,NA
fact,NA,NA
". Of course, ",NA,NA
fact,NA,NA
 will correspond to a main ,NA,NA
"storage address at run-time. The exact address is determined by the assembler, the linker, ",NA,NA
and the loader. ,NA,NA
#  int fact( int n ) ,NA,NA
#  { ,NA,NA
#    if ( n<=1) ,NA,NA
#      return 1; ,NA,NA
#    else ,NA,NA
#      return n*fact(n-1); ,NA,NA
#  },NA,NA
fact:,NA,NA
 .text,NA,NA
 .globl  fact,NA,NA
 # prolog        ,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
" sw      $fp,($sp)",NA,NA
" sub     $sp,$sp,4        #   3. Push register $s1",NA,NA
" sw      $s1,($sp)",NA,NA
" sub     $fp,$sp,0        #   4. $fp = $sp - space_for_variables (==0) ",NA,NA
"move    $sp,$fp          #   5. $sp = $fp",NA,NA
 . . . . . .,NA,NA
 # body of subroutine,NA,NA
epilog:                           # epilog,NA,NA
 #   1. Return value is already in $v0        ,NA,NA
" add     $sp,$fp,0        #   2. $sp = $fp + space_for_variables (==0)",NA,NA
" lw      $s1,($sp)        #   3. Pop register $s1",NA,NA
" add     $sp,$sp,4        #          ",NA,NA
" lw      $fp,($sp)        #   4. Pop $fp",NA,NA
" add     $sp,$sp,4        #           ",NA,NA
" lw      $ra,($sp)        #   5. Pop $ra",NA,NA
" add     $sp,$sp,4        #            ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_24.html (1 of 2) [8/8/2545 11:43:01],NA
 jr      $ra              #   6. return to caller ,NA,NA
The symbol ,NA,NA
fact,NA,NA
" is a global symbol (also called an external symbol) so that the assembler, ",NA,NA
"linker, and loader can use that symbol to refer to the same place in memory. ",NA,NA
A location such as ,NA,NA
fact,NA,NA
 that is a target of a subroutine call is called an ,NA,NA
entry point,NA,NA
. ,NA,NA
"Sometimes a subroutine has several entry points, one for each of several related functions. ",NA,NA
QUESTION 24:,NA,NA
(Thought Question:) Does a global symbol ,NA,NA
always,NA,NA
 correspond to an entry ,NA,NA
point? ,NA,NA
A good answer might be: ,NA,NA
No. Sometimes a global symbol is used to label data that several modules may refer to. ,NA,NA
Body of ,NA,NA
fact(),NA,NA
Here is part of the body of the subroutine: ,NA,NA
#  int fact( int n ) ,NA,NA
#  { ,NA,NA
#    if ( n<=1) ,NA,NA
#      return 1; ,NA,NA
#    else ,NA,NA
#      return n*fact(n-1); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  fact ,NA,NA
fact:,NA,NA
 # prolog        ,NA,NA
 . . . . . .,NA,NA
 # body of subroutine,NA,NA
" move    $s1,$a0          # save argument in $s1 ",NA,NA
"li      $t1,1            # get a 1",NA,NA
" bgt     $s1,$t1,recurse  # if ( n<=1)",NA,NA
" li      $v0,1            #   return 1",NA,NA
 b      ,NA,NA
________,NA,NA
recurse:                          # else,NA,NA
 #   return n*fact(n-1);,NA,NA
 . . . . . . ,NA,NA
epilog:                           # epilog,NA,NA
 #   1. Return value is already in $v0        ,NA,NA
 . . . . . .,NA,NA
 jr      $ra              #,NA,NA
The argument in ,NA,NA
$a0,NA,NA
 is saved in register ,NA,NA
$s1,NA,NA
 because later on ,NA,NA
$a0,NA,NA
 may be altered. (Since ,NA,NA
this subroutine uses ,NA,NA
$s1,NA,NA
 the contents of ,NA,NA
$s1,NA,NA
 is saved on the stack in the prolog). ,NA,NA
The ,NA,NA
if,NA,NA
 statement checks if the argument (in ,NA,NA
$a0,NA,NA
") is 1 or less. If so, it loads register ",NA,NA
$v0,NA,NA
 with ,NA,NA
"the value to return to the caller, one. Otherwise, the other branch is taken. ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_25.html (1 of 2) [8/8/2545 11:43:29],NA
QUESTION 25:,NA,NA
Fill in the blank. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_25.html (2 of 2) [8/8/2545 11:43:29],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
More ,NA,NA
fact(),NA,NA
#  int fact( int n ) ,NA,NA
#  { ,NA,NA
#    if ( n<=1) ,NA,NA
#      return 1; ,NA,NA
#    else ,NA,NA
#      return n*fact(n-1); ,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  fact ,NA,NA
fact:,NA,NA
 # prolog        ,NA,NA
 . . . . . .,NA,NA
 # body of subroutine,NA,NA
" move    $s1,$a0          # save argument in $s1 ",NA,NA
"li      $t1,1            # get a 1",NA,NA
" bgt     $s1,$t1,recurse  # if ( n<=1)",NA,NA
" li      $v0,1            #   return 1",NA,NA
 b       ,NA,NA
epilog,NA,NA
recurse:                          # else,NA,NA
 #   return n*fact(,NA,NA
n-1,NA,NA
);,NA,NA
 sub     ,NA,NA
$a0,NA,NA
",$s1,1        #     argument0 = ",NA,NA
n-1,NA,NA
 # subroutine call,NA,NA
 #   1. No T registers to push,NA,NA
 #   2. Argument is in ,NA,NA
$a0,NA,NA
 jal     fact             #   3. Jump and link to subroutine,NA,NA
 mul     $,NA,NA
___,NA,NA
",$",NA,NA
___,NA,NA
",$",NA,NA
___,NA,NA
   # n*fact(n-1),NA,NA
epilog:                           # epilog,NA,NA
 #   1. Return value is already in $v0        ,NA,NA
 . . . . . .,NA,NA
 jr      $ra              #,NA,NA
The alternate branch of the ,NA,NA
if,NA,NA
 statement has the job of calculating ,NA,NA
n*fact(n-1),NA,NA
. It does this ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_26.html (1 of 2) [8/8/2545 11:43:32],NA
by first calculating the argument ,NA,NA
n-1,NA,NA
. ,NA,NA
Then it calls the subroutine ,NA,NA
fact(),NA,NA
 in the normal way. It does not hurt for ,NA,NA
fact(),NA,NA
 to call ,NA,NA
fact() ,NA,NA
because each activation has its own data on the stack. ,NA,NA
On return from the (inner) call to ,NA,NA
fact(),NA,NA
", register ",NA,NA
$v0,NA,NA
" has the returned value, and register ",NA,NA
$s1 ,NA,NA
has the argument ,NA,NA
n,NA,NA
. Now the return value from the current activation must be placed in ,NA,NA
$v0 ,NA,NA
to be returned to the caller. ,NA,NA
QUESTION 26:,NA,NA
Fill in the blanks. (Hint: study the last paragraph). ,NA,NA
A good answer might be: ,NA,NA
See Below. ,NA,NA
Recursive Call,NA,NA
 . . . . . .,NA,NA
recurse:                          # else,NA,NA
 #   return n*fact(n-1);,NA,NA
" sub     $a0,$s1,1        #     argument0 = n-1",NA,NA
 # subroutine call,NA,NA
 #   1. No T registers to push,NA,NA
 #   2. Argument is in $a0 ,NA,NA
 jal     fact             #   3. Jump and link to subroutine,NA,NA
 mul     $,NA,NA
v0,NA,NA
",$",NA,NA
v0,NA,NA
",$",NA,NA
s1,NA,NA
      # n*fact(n-1),NA,NA
epilog:                           # epilog,NA,NA
 #   1. Return value is already in $v0        ,NA,NA
 . . . . . .,NA,NA
 jr      $ra              #,NA,NA
Recursion has been implemented using: (1) the normal machine operations of sequential ,NA,NA
"execution, testing, and branching, and (2) the run-time stack. ",NA,NA
This is (yet another) example of a new level of abstraction being build upon a foundation ,NA,NA
level. Have I mentioned that this is one of the most stunningly important ideas of Computer ,NA,NA
Science? ,NA,NA
QUESTION 27:,NA,NA
The programming language FORTRAN IV did not have support for recursion. ,NA,NA
Was it possible to write a recursive program in FORTRAN IV? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_27.html [8/8/2545 11:44:03],NA
A good answer might be:,NA,NA
"Yes. FORTRAN had sequential execution, testing, and branching, as do all languages. ",NA,NA
To write a recursive program the programmer had to create and manage a run time ,NA,NA
"stack, just as in assembly language. Modern high level languages do this automatically. ",NA,NA
Complete ,NA,NA
fact(),NA,NA
Here is the complete code for ,NA,NA
fact(),NA,NA
: ,NA,NA
#  int fact( int n ) ,NA,NA
#  { ,NA,NA
#    if ( n<=1) ,NA,NA
#      return 1; ,NA,NA
#    else ,NA,NA
#      return n*fact(n-1);,NA,NA
#  },NA,NA
 .text,NA,NA
 .globl  fact,NA,NA
 # prolog        ,NA,NA
fact:,NA,NA
" sub     $sp,$sp,4        #   1. Push return address",NA,NA
" sw      $ra,($sp)",NA,NA
" sub     $sp,$sp,4        #   2. Push caller's frame pointer",NA,NA
" sw      $fp,($sp)",NA,NA
" sub     $sp,$sp,4        #   3. Push register $s1",NA,NA
" sw      $s1,($sp)",NA,NA
" sub     $fp,$sp,0        #   4. $fp = $sp - space_for_variables (==0) ",NA,NA
"move    $sp,$fp          #   5. $sp = $fp",NA,NA
 # body of subroutine,NA,NA
" move    $s1,$a0          # save argument in $s1 ",NA,NA
"li      $t1,1            # get a 1",NA,NA
" bgt     $s1,$t1,recurse  # if ( n<=1)",NA,NA
" li      $v0,1            #   return 1",NA,NA
 b       epilog    ,NA,NA
recurse:                          # else,NA,NA
 #  return n*fact(n-1),NA,NA
" sub     $a0,$s1,1        #     n-1",NA,NA
 # subroutine call,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-28/ass28_28.html (1 of 2) [8/8/2545 11:44:17],NA
 #   1. No T registers to push,NA,NA
 #   2. Argument is in $a0 ,NA,NA
 jal     fact             #   3. Jump and link to subroutine,NA,NA
" mul     $v0,$v0,$s1      # n*fact(n-1)",NA,NA
epilog:                           # epilog,NA,NA
 #   1. Return value is already in $v0        ,NA,NA
" add     $sp,$fp,0        #   2. $sp = $fp + space_for_variables (==0)",NA,NA
 ,NA,NA
"lw      $s1,($sp)        #   3. Pop register $s1",NA,NA
" add     $sp,$sp,4        #          ",NA,NA
" lw      $fp,($sp)        #   4. Pop $fp",NA,NA
" add     $sp,$sp,4        #           ",NA,NA
" lw      $ra,($sp)        #   5. Pop $ra",NA,NA
" add     $sp,$sp,4        #            ",NA,NA
 jr      $ra              #   6. return to caller ,NA,NA
QUESTION 28:,NA,NA
Is a different subroutine linkage convention followed for recursive ,NA,NA
subroutines than for non-recursive subroutines? ,NA,NA
A good answer might be: ,NA,NA
No. The same convention is followed by both. There is nothing special about a recursive ,NA,NA
subroutine except that it calls itself. ,NA,NA
End of the Chapter,NA,NA
You have reached the end this chapter. You may wish to review the following. Click on a ,NA,NA
subject that interests you to go to where it was discussed. ,G,NA
Local variables and stack frames.,G,NA
Picture of a stack frame.,G,NA
Reason for having a frame pointer.,G,NA
How local variables are used in assembly language. ,G,NA
Our frame-based calling convention.,G,NA
"Storage classes: automatic, static, dynamic.",G,NA
Entry point.,G,NA
Recursion,NA,NA
CHAPTER 29 — Binary Fractions,NA,NA
"Up until now all of the arithmetic we have done on the MIPS has been with integers, both ",NA,NA
signed (two's complement) and unsigned. This chapter starts the discussion of how floating ,NA,NA
point arithmetic is done on the MIPS. ,NA,NA
Chapter Topics:,G,NA
Positional notation with fractions.,G,NA
Converting fractions between base two and base ten.,G,NA
Fixed point representation.,G,NA
Limited precision of binary fractions (fixed point and floating point). ,G,NA
"How ""one tenth"" cannot be expressed in binary.",G,NA
Dangerous program loops.,NA,NA
QUESTION 1:,NA,NA
Is is possible to represent a ,NA,NA
negative,NA,NA
 integer with a ,NA,NA
positive,NA,NA
 number of bits? ,NA,NA
A good answer might be: ,NA,NA
Of course. Bit patterns can represent anything symbolic. ,NA,NA
Bit Patterns,NA,NA
The question is silly. There is nothing mysterious about representing signed numbers with ,NA,NA
bit patterns. Here is another silly question: ,NA,NA
Is it possible to represent a ,NA,NA
fraction,NA,NA
 with ,NA,NA
a whole number of bits?,NA,NA
Of course. It is just a matter of mapping fractions to the bit patterns that represent them. ,NA,NA
There are several systematic ways in which this can be done. This chapter discusses some ,NA,NA
of them. ,NA,NA
QUESTION 2:,NA,NA
In the decimal fraction 12.6 what power of 10 is associated with: ,G,NA
The digit 1? ,G,NA
The digit 2? ,G,NA
The digit 6?,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_2.html [8/8/2545 11:45:18],NA
A good answer might be: ,NA,NA
In the decimal fraction 12.6 what power of 10 is associated with: ,G,NA
The digit 1? ,NA,NA
10,"1 
  
 G",NA
The digit 2? ,NA,NA
10,"0 
  
 G",NA
The digit 6? ,NA,NA
10,-1,NA
Positional Notation,NA,NA
This is just ,NA,NA
base 10 positional notation,NA,NA
 which you know about already. The ,NA,NA
decimal point ,NA,NA
is put between the 10,0,NA
 position and the 10,-1,NA
 position: ,"3
  
 5
  
 7",NA
.,"2
  
 8
  
 4
  
 3×10
 2
 +
  
 5×10
 1
 +
  
 7×10
 0
 +",NA
.,"2×10
 -1
 +
  
 8×10
 -2
 +
  
 4×10
 -3",NA
QUESTION 3:,NA,NA
Express ,NA,NA
3/10 + 1/100,NA,NA
 using positional notation. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_3.html [8/8/2545 11:45:25],NA
A good answer might be: ,NA,NA
0.301 ,NA,NA
"When a particular power of ten is not needed, the digit '0' is used for that position. ",NA,NA
Base Two Positional Notation,NA,NA
Positional notation can also be used with a base other than ten. Here is a number written ,NA,NA
using base two: ,"1
  
 0
  
 0",NA
.,"1
  
 0
  
 1
  
 1×2
 2
 +
  
 0×2
 1
 +
  
 0×2
 0
 +",NA
.,"1×2
 -1
 +
  
 0×2
 -2
 +
  
 1×2
 -3",NA
Now the ',NA,NA
.,NA,NA
' is called a ,NA,NA
binary point,NA,NA
". In general, the '",NA,NA
.,NA,NA
' is called a ,NA,NA
radix point,NA,NA
. ,NA,NA
QUESTION 4: ,NA,NA
What is 1×2,NA,NA
-1,NA,NA
 ?,NA,NA
 (Express the answer in base ten notation). ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_4.html [8/8/2545 11:45:34],NA
A good answer might be: ,NA,NA
1×2,NA,NA
-1,NA,NA
 = 1/(2,NA,NA
1,NA,NA
) = 1/2 = 0.5,NA,NA
Base Two to Base Ten,NA,NA
Recall that ,NA,NA
X,NA,NA
-n,NA,NA
 means ,NA,NA
1/X,NA,NA
n,NA,NA
". So, ",NA,NA
2,NA,NA
-2,NA,NA
 = 1/4,NA,NA
 and ,NA,NA
2,NA,NA
-3,NA,NA
 = 1/8,NA,NA
. ,NA,NA
"To convert an expression in base two notation to base ten notation, just do the arithmetic ",NA,NA
that the expression calls for: ,"1
  
 0
  
 0",NA
.,"1
  
 0
  
 1
  
 1×2
 2
  +
  
 0×2
 1
  +
  
 0×2
 0
  +",NA
.,"1×2
 -1
  +
  
 0×2
 -2
  +
  
 1×2
 -3
  
 1×4 +
  
 0×2 +
  
 0×1+",NA
.,"1×0.5 
 +
  
 0×0.25 +
  
 1×0.125
  
 4 +
  
 0 +
  
 0 +",NA
.,"0.5 +
  
 0 +
  
 0.125
  
 4",NA
.,625,NA
"As you work, keep track of what parts of the expression are in base two and what parts are ",NA,NA
"in base ten. In the above, the first row is entierly in base two, the bottom row is entierly in ",NA,NA
"base ten, and the middle rows are mixed. ",NA,NA
QUESTION 5: ,NA,NA
Write ,NA,NA
0.11,NA,NA
2,NA,NA
 as a base 10 expression. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_5.html [8/8/2545 11:45:45],NA
A good answer might be: ,NA,NA
0.11,NA,NA
2,NA,NA
 = 0×1 + 1×(0.5) + 1×(0.25) = 0.75,NA,NA
Include or Exclude?,NA,NA
"In a binary representation a particular power of two is either included in the sum or not, ",NA,NA
"since the digits are either ""1"" or ""0"". A ""1"" bit in a position means to include the ",NA,NA
"corresponding power of two in the sum. In converting representations, it is convenient to ",NA,NA
have a table. ,NA,NA
Power of 2,NA,NA
3,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
.,NA,NA
-2,NA,NA
-3,NA,NA
-4,NA,NA
-5,NA,NA
Decimal,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1,NA,NA
.,NA,NA
0.5 ,NA,NA
0.25,NA,NA
0.125,NA,NA
0.0625,NA,NA
Include?,NA,NA
. ,NA,NA
QUESTION 6: ,NA,NA
What is 100.01,2,NA
 expressed in decimal? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_6.html [8/8/2545 11:45:56],NA
A good answer might be:,NA,NA
Power of 2,NA,NA
3,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
.,NA,NA
-2,NA,NA
-3,NA,NA
-4,NA,NA
-5,NA,NA
Decimal,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1,NA,NA
.,NA,NA
0.5 ,NA,NA
0.25,NA,NA
0.125,NA,NA
0.0625,NA,NA
Include?,NA,NA
1 ,NA,NA
0 ,NA,NA
0 ,NA,NA
. ,NA,NA
0 ,NA,NA
1 ,NA,NA
= 4.25,NA,NA
Fixed Point Notation,NA,NA
With paper-and-pencil arithmetic you can use as many digits or bits as are needed. But ,NA,NA
"computers (usually) use a fixed number of bits for a particular data type. For example, MIPS ",NA,NA
integers are 32 bits. Can a fixed number of bits be used to express fractions? ,NA,NA
"Yes. Let us look briefly at an older method, not much used anymore. In the past, some ",NA,NA
electronic calculators and some computers used ,NA,NA
fixed point,NA,NA
 notation for expressing ,NA,NA
fractional number. This is when a number is expressed in a number of bits (say eight) and ,NA,NA
"the binary point is assumed be be fixed between two of them. For example, let us say that ",NA,NA
fixed point numbers use eight bits and that the binary point is fixed between the middle two ,NA,NA
"bits, like in the table. Now to interpret an eight-bit expression, just copy the bits to the table. ",NA,NA
QUESTION 7:,NA,NA
"In this scheme, what does the bit pattern ",NA,NA
01101001 ,NA,NA
represent in decimal? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_7.html [8/8/2545 11:46:16],NA
A good answer might be:,NA,NA
Power of 2,NA,NA
3,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
.,NA,NA
-2,NA,NA
-3,NA,NA
-4,NA,NA
-5,NA,NA
Decimal,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1,NA,NA
.,NA,NA
0.5 ,NA,NA
0.25,NA,NA
0.125,NA,NA
0.0625,NA,NA
Include?,NA,NA
0 ,NA,NA
1 ,NA,NA
1 ,NA,NA
0 ,NA,NA
. ,NA,NA
1 ,NA,NA
0 ,NA,NA
0 ,NA,NA
1 ,NA,NA
= 4 + 2 + 0.5 +0.0625 = 6.5625,NA,NA
Adding fixed point Expressions,NA,NA
Here is another number: ,NA,NA
00010100,NA,NA
 represents decimal ,NA,NA
1.25,NA,NA
. Here is the familiar ,NA,NA
binary ,NA,NA
addition algorithm,NA,NA
" performed with the two bit patterns, and the usual decimal addition ",NA,NA
performed with their decimal equivalent. ,NA,NA
fixed point,NA,NA
as decimal,NA,NA
01101001,NA,NA
6.5625,NA,NA
00010100,NA,NA
1.2500,NA,NA
—————,NA,NA
—————,NA,NA
01111101,NA,NA
7.8125,NA,NA
QUESTION 8:,NA,NA
"Of course, the question is, does the sum of the fixed point expressions ",NA,NA
(01111101) represent the sum of the decimal expressions (7.8125)? ,NA,NA
Power of 2,NA,NA
3,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
.,NA,NA
-2,NA,NA
-3,NA,NA
-4,NA,NA
-5,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_8.html (1 of 2) [8/8/2545 11:46:28],NA
Decimal,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1,NA,NA
.,NA,NA
0.5 ,NA,NA
0.25,NA,NA
0.125,NA,NA
0.0625,NA,NA
Include?,NA,NA
0 ,NA,NA
1 ,NA,NA
1 ,NA,NA
1 ,NA,NA
. ,NA,NA
1 ,NA,NA
1 ,NA,NA
0 ,NA,NA
1 ,NA,NA
You can satisfy your burning curiosity by adding up the included decimals in the table. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_8.html (2 of 2) [8/8/2545 11:46:28],NA
A good answer might be:,NA,NA
Power of 2,NA,NA
3,NA,NA
2,NA,NA
1,NA,NA
0,NA,NA
.,NA,NA
-2,NA,NA
-3,NA,NA
-4,NA,NA
-5,NA,NA
Decimal,NA,NA
8 ,NA,NA
4,NA,NA
2,NA,NA
1,NA,NA
.,NA,NA
0.5 ,NA,NA
0.25,NA,NA
0.125,NA,NA
0.0625,NA,NA
Include?,NA,NA
0 ,NA,NA
1 ,NA,NA
1 ,NA,NA
1 ,NA,NA
. ,NA,NA
1 ,NA,NA
1 ,NA,NA
0 ,NA,NA
1 ,NA,NA
= 4 + 2 + 1 + 0.5 + 0.25 + 0.0625 = 7.8125,NA,NA
Binary Addition Algorithm Works!,NA,NA
The binary addition algorithm works for our eight-bit fixed point notation! In early computers ,NA,NA
and calculators this enabled the same circuits to be used for integer arithmetic and for fixed ,NA,NA
point arithmetic. The two's complement method of representing a negative number also ,NA,NA
works with fixed point. This looks very promising. ,NA,NA
"However, fixed point is not as useful as ",NA,NA
floating point,NA,NA
 representation which has replaced it. ,NA,NA
Floating point will be discussed in the next chapter. ,NA,NA
QUESTION 9:,NA,NA
How many different values is it possible to represent using our 8-bit fixed ,NA,NA
point representation? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_9.html [8/8/2545 11:46:30],NA
A good answer might be: ,NA,NA
2,NA,NA
8,NA,NA
 = 256,NA,NA
Limited Precision,NA,NA
This is an easy question. If ,NA,NA
N,NA,NA
" bits are used, then only ",NA,NA
2,NA,NA
N,NA,NA
" things can be represented, no ",NA,NA
matter what type of things they are. Eight bits can represent 256 positive integers (unsigned ,NA,NA
"binary), 256 positive and negative integers (two' complement), 256 fractional numbers (our ",NA,NA
"fixed point method), and so on. Here is a number line showing the 256 values that can be ",NA,NA
represented with this fixed notation: ,NA,NA
The smallest value is zero (,NA,NA
00000000,NA,NA
); the largest value is 7.9375 (,NA,NA
11111111,NA,NA
). The smallest ,NA,NA
non-zero value is 0.0625. Every represented value is a multiple of 0.0625. Another way to ,NA,NA
think of fixed point notation is that the eight bits represent an integer from 0 to 255. The ,NA,NA
integer is a multiplier of the value 0.0625. ,NA,NA
The important point:,NA,NA
 The point of all this is that on the number line from zero to eight not ,NA,NA
all real numbers can be represented. This is called a limit in ,NA,NA
precision,NA,NA
. Floating point ,NA,NA
representation has the same problem. ,NA,NA
QUESTION 10:,NA,NA
(Calculus Review: ) How many ,NA,NA
real numbers,NA,NA
 lie between 0.0 and 0.0625? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_10.html [8/8/2545 11:46:45],NA
(Calculus Review: ) How many ,NA,NA
real numbers,NA,NA
 lie between 0.0 and 0.0625? ,NA,NA
A good answer might be: ,NA,NA
An infinite number. ,NA,NA
Shifting Left One Bit,NA,NA
The limited precision of fixed point (and floating point) expressions is a problem in ,NA,NA
programming. Even with 64-bit double precision floating point (such as Java data type ,NA,NA
double,NA,NA
) precision is limited. Only ,NA,NA
2,NA,NA
64,NA,NA
" numbers can be represented. This may seem like a lot, ",NA,NA
but between any two represented numbers there are an infinite number of real numbers that ,NA,NA
are not represented! ,NA,NA
QUESTION 11:,NA,NA
How many digits does the value pi have? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_11.html [8/8/2545 11:46:55],NA
A good answer might be: ,NA,NA
An infinite number of digits (or bits). ,NA,NA
More about Positional Notation,NA,NA
Let us return to paper-and-pencil positional notation. Here is a binary expression: ,NA,NA
0001.0100 = 1.25,10,NA
"Here is the same pattern, shifted left by one bit: ",NA,NA
0010.1000 = 2.50,10,NA
QUESTION 12:,NA,NA
What does shifting left by one bit do? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_12.html [8/8/2545 11:47:07],NA
What does shifting left by one bit do? ,NA,NA
A good answer might be: ,NA,NA
"Multiplies by two. This is the same as with unsigned integers. Also, shifting one bit right ",NA,NA
is equivalent to division by two. ,NA,NA
Converting Representation from Decimal ,NA,NA
to Binary,NA,NA
Often you need to convert a decimal expression like ,NA,NA
"7.625 into a binary expression. To do this, first convert ",NA,NA
the whole number (32 in this case) to binary (111 in this ,NA,NA
"case), append a binary point, and convert the decimal ",NA,NA
fraction to binary. ,NA,NA
To convert a decimal fraction to Base 2: ,NA,NA
Repeatedly multiply the decimal fraction by two. ,NA,NA
"After each multiplication, copy the bit (0 or 1) that ",NA,NA
moves into the one's place (the place just left of the ,NA,NA
"radix point) to the right of the binary fraction, then ",NA,NA
erase it from the decimal. Stop when the decimal ,NA,NA
"fraction is zero. (Note: if this never happens, stop ",NA,NA
when you have the number of places you want.) ,NA,NA
For our example: 7.625 is 111.101,2,NA
. In this case the ,NA,NA
conversion stopped when the decimal fraction changed ,NA,NA
to zero. This may not always happen. ,NA,NA
Decimal,NA,NA
Binary so far,NA,NA
Start,NA,NA
0.625,NA,NA
0.,NA,NA
×2,NA,NA
1,NA,NA
.250,NA,NA
0.,NA,NA
1,NA,NA
.250,NA,NA
0.1,NA,NA
×2,NA,NA
0,NA,NA
.500,NA,NA
0.1,NA,NA
0,NA,NA
.500,NA,NA
0.10,NA,NA
×2,NA,NA
1,NA,NA
.000,NA,NA
0.10,NA,NA
1,NA,NA
Result,NA,NA
.000,NA,NA
0.101,NA,NA
QUESTION 13:,NA,NA
(Thought Question: ) Why will no other digit but 0 or 1 move into the one's ,NA,NA
place? (Hint: consider the biggest possible decimal fraction). ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_13.html [8/8/2545 11:47:15],NA
A good answer might be:,NA,NA
You might fear that a '2' or higher digit might move into the one's place. Try this: multiply ,NA,NA
the biggest decimal fraction 0.99999... by two. This yields 1.99999... Even with this ,NA,NA
fraction a '1' moves into the one's place. ,NA,NA
Practice,NA,NA
Here is an table set up to convert 0.75 to binary. ,NA,NA
Decimal,NA,NA
Binary so far,NA,NA
Start ,NA,NA
0.750 ,NA,NA
0. ,NA,NA
×2,NA,NA
0. ,NA,NA
0. ,NA,NA
×2,NA,NA
0. ,NA,NA
Result ,NA,NA
0. ,NA,NA
QUESTION 14:,NA,NA
Perform the conversion. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_14.html [8/8/2545 11:47:18],NA
A good answer might be:,NA,NA
Decimal,NA,NA
Binary so far,NA,NA
Start ,NA,NA
0.750 ,NA,NA
0. ,NA,NA
×2,NA,NA
1.50 ,NA,NA
0.1 ,NA,NA
.50 ,NA,NA
0.1 ,NA,NA
×2,NA,NA
1.00 ,NA,NA
0.11 ,NA,NA
Result ,NA,NA
0.11 ,NA,NA
So ,NA,NA
0.75,NA,NA
10,NA,NA
 = 0.11,NA,NA
2,NA,NA
. ,NA,NA
"To check this, go in the other direction: ",NA,NA
0.11,NA,NA
2,NA,NA
 = 2,NA,NA
-1,NA,NA
 + ,NA,NA
2,NA,NA
-2,NA,NA
 = 0.5 + 0.25 = 0.75,NA,NA
Non-terminating Result,NA,NA
Here is the algorithm used to convert ,NA,NA
0.1,NA,NA
10,NA,NA
 to binary. ,NA,NA
"The algorithm does not end. After it has started up, ",NA,NA
the same pattern ,NA,NA
"0.2, 0.4, 0.8, 1.6, 0.6, 1.2, 0.2 ",NA,NA
repeats endlessly. The pattern ,NA,NA
0011,NA,NA
 is appended to ,NA,NA
the growing binary fraction for each repitition. ,NA,NA
Unexpected Fact:,NA,NA
" The value ""one tenth"" cannot be ",NA,NA
represented precisely using a binary fraction. ,NA,NA
This is true in the base two positional notation used ,NA,NA
"here, and also in floating point representation used in ",NA,NA
programming languages. This is sometimes an ,NA,NA
important consideration when high accuracy is ,NA,NA
needed. ,NA,NA
Decimal,NA,NA
Binary so far,NA,NA
Start ,NA,NA
0.1 ,NA,NA
0. ,NA,NA
×2,NA,NA
0.2,NA,NA
0.0 ,NA,NA
×2,NA,NA
0.4 ,NA,NA
0.00 ,NA,NA
×2,NA,NA
0.8 ,NA,NA
0.000 ,NA,NA
×2,NA,NA
1.6 ,NA,NA
0.0001 ,NA,NA
.6 ,NA,NA
0.0001 ,NA,NA
×2 ,NA,NA
1.2 ,NA,NA
0.00011 ,NA,NA
0.2,NA,NA
0.00011 ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_15.html (1 of 2) [8/8/2545 11:47:21],NA
×2,NA,NA
0.4 ,NA,NA
0.000110 ,NA,NA
×2,NA,NA
0.8 ,NA,NA
0.0001100 ,NA,NA
×2,NA,NA
1.6 ,NA,NA
0.00011001 ,NA,NA
.6 ,NA,NA
0.00011001 ,NA,NA
×2,NA,NA
1.2 ,NA,NA
0.000110011 ,NA,NA
0.2 ,NA,NA
0.000110011 ,NA,NA
×2,NA,NA
0.4 ,NA,NA
0.0001100110 ,NA,NA
×2,NA,NA
0.8 ,NA,NA
0.00011001100 ,NA,NA
Result ,NA,NA
0.00011001100... ,NA,NA
QUESTION 15:,NA,NA
"Can ""one third"" be represented accurately in decimal? ",NA,NA
"Can ""one third"" be represented accurately in decimal? ",NA,NA
A good answer might be: ,NA,NA
No. Its representation continues indefinitely: 0.3333333.... ,NA,NA
"The problem with ""one tenth"" is not a special flaw of binary. All bases have fractions that ",NA,NA
cannot be represented accurately. ,NA,NA
Dangerous Code,NA,NA
Here is a program fragment in Java. (It could also be in C or C++). Is there something you ,NA,NA
should worry about in it? ,NA,NA
float x;,NA,NA
for ( x = 0.0; x != 10.0; x += 0.1 ) ,NA,NA
{,NA,NA
" System.out.println(""Crimsom and Clover""); }",NA,NA
QUESTION 16:,NA,NA
"How many times will ""Crimsom and Clover"" be printed? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_16.html [8/8/2545 11:47:26],NA
A good answer might be: ,NA,NA
Over and over. ,NA,NA
Hidden Infinite Loop,NA,NA
"In base 10 arithmetic, 0.1 is added to ",NA,NA
x,NA,NA
 100 times until ,NA,NA
x,NA,NA
 reaches exactly 100.0. But the ,NA,NA
arithmetic is actually done in base two floating point which does not represent 0.1 exactly. ,NA,NA
The variable ,NA,NA
x,NA,NA
 may miss hitting 100.0 and the program will loop indefinitely. ,NA,NA
float x;,NA,NA
for ( x = 0.0; x != 10.0; x += 0.1 ) ,NA,NA
{,NA,NA
" System.out.println(""Crimsom and Clover""); }",NA,NA
"Smart compilers look out for this problem, and may fix it, so this loop might actually work as ",NA,NA
intended. But is not wise to use it. ,NA,NA
QUESTION 17:,NA,NA
Fix the code. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_17.html [8/8/2545 11:47:34],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Count with Integers,NA,NA
"If the purpose of the program fragment is to loop 100 times, then a counting loop using an ",NA,NA
integer variable should be used. Here is the best fix: ,NA,NA
int x;,NA,NA
for ( x = 0; x < 100; x++ ) ,NA,NA
{,NA,NA
" System.out.println(""Crimsom and Clover""); }",NA,NA
"(It is conventional to write a counting loop this way, even though testing for an ""exact hit"" ",NA,NA
with ,NA,NA
x == 99,NA,NA
 is logically equivalent.) Here is a poor solution: ,NA,NA
float x;,NA,NA
for ( x = 0.0; x < 10.0; x += 0.1 ) ,NA,NA
{,NA,NA
" System.out.println(""Crimsom and Clover""); }",NA,NA
"This will probably work as intended, but there is a risk it will loop 101 times. ",NA,NA
QUESTION 18:,NA,NA
"Say that you need 100 values, 0.0, 0.1, up to 9.9? Can an integer-controlled ",NA,NA
counting loop be used? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_18.html [8/8/2545 11:47:36],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Calculate Each Float,NA,NA
Use the for-loop structure to correctly and safely count. Calculate a new value of the floating ,NA,NA
point variable each time. ,NA,NA
double x; ,NA,NA
int    j;,NA,NA
for ( j = 0; j < 100; j++ ) ,NA,NA
{,NA,NA
 x = j/10.0;,NA,NA
 // do something with x ,NA,NA
},NA,NA
"Almost always, floating point work should be done with double precision, as above. An even ",NA,NA
more accurate version of the loop is: ,NA,NA
double x; ,NA,NA
int    j;,NA,NA
for ( j = 0; j < 160; j++ ) ,NA,NA
{,NA,NA
 x = j/16.0;,NA,NA
 // do something with x ,NA,NA
},NA,NA
This is better because (1/16) is accurately represented in binary. ,NA,NA
QUESTION 19:,NA,NA
Is floating point representation (as used in computers) the same as base two ,NA,NA
radix notation (as discussed in this chapter)? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_19.html (1 of 2) [8/8/2545 11:47:53],NA
A good answer might be:,NA,NA
"No. They are related, but floating point is more sophisticated. The next chapter ",NA,NA
discusses it. ,NA,NA
End of the Chapter,NA,NA
"You have reached the end this chapter. If you are still afloat, you may wish to review the ",NA,NA
following. Click on a subject that interests you to go to where it was discussed. To get back ,NA,NA
"here, click on the ""back arrow"" button of your browser. ",G,NA
Base two positional notation.,G,NA
Converting base 2 to base 10.,G,NA
Fixed point notation.,G,NA
"Binary addition algorithm, with fixed point ",G,NA
Limited precision of fixed point,NA,NA
 (and floating point). ,G,NA
Shifting left.,G,NA
Converting base 10 to base 2 ,G,NA
0.1 in binary ,G,NA
Dangerous counting loops,NA,NA
 Back to the main menu. ,NA,NA
You have reached the end of the chapter. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-29/ass29_20.html [8/8/2545 11:48:39],NA
CHAPTER 30 — IEEE 754 Floating Point,NA,NA
This chapter is about the ,NA,NA
IEEE 754 floating point standard.,NA,NA
 This is a standard for floating ,NA,NA
point numbers used in nearly all computers and programming languages since 1985. Jave ,NA,NA
floating point (on its virtual processor) and MIPS floating point (on real hardware) conform to ,NA,NA
this standard. ,NA,NA
Chapter Topics:,G,NA
Why use floating point?,G,NA
History of floating point?,G,NA
Scientific notation ,G,NA
Precision of floating point ,G,NA
IEEE 754 floating point standard ,G,NA
Converting to floating point notation,NA,NA
QUESTION 1:,NA,NA
(Review: ) Is it absolutely essential that a processor support floating point ,NA,NA
data? ,NA,NA
A good answer might be: ,NA,NA
No. All a processor needs for data are basic bit-manipulating instructions. Everything ,NA,NA
else can be built up from them. ,NA,NA
Why Floating Point?,NA,NA
Floating point representation makes numerical computation much easier. You could write all ,NA,NA
"your programs using integers or fixed-point representations, but this is tedious and error-",NA,NA
"prone. For example, you could use integers and program with the ""understanding"" that the ",NA,NA
integer in each variable is 100 times bigger than the number it represents. As long as you ,NA,NA
"are consistent, every thing works. ",NA,NA
This is actually the same as using fixed point notation. In fixed point binary notation each ,NA,NA
"variable holds an integer that is, say 64 times bigger than the number it represents. (This is ",NA,NA
what our fixed point method of the previous chapter did). ,NA,NA
But it is very hard to stay consistent. The programmer must remember where the decimal ,NA,NA
"(or binary) point ""really is"" in each number. Sometimes one program needs to deal with ",NA,NA
several different ranges of numbers. Consider a program must deal with both the ,NA,NA
measurements that describe the dimensions on a silicon chip (say 0.000000010 to ,NA,NA
0.000010000 meters) and also the clock speeds it uses (say 500000000.0 to 2000000000.) ,NA,NA
It is hard to find a single non-floating point method that can represent both ranges. ,NA,NA
"Notice that in writing those numbers (0.000000010, 0.000010000, 500000000.0, ",NA,NA
2000000000.) I was able to put the decimal point where it was needed in each number. ,NA,NA
QUESTION 2:,NA,NA
(Take a guess: ) When the decimal point moves to where it is needed in an ,NA,NA
"expression, the decimal point is said to ____________. ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_2.html [8/8/2545 12:54:43],NA
A good answer might be: ,NA,NA
Float. ,NA,NA
Floating Point,NA,NA
The essential idea of floating point representation is that there a fixed number of bits is used ,NA,NA
"(usually 32 or 64) and that the binary point ""floats"" to where it is needed in the expression. ",NA,NA
Of course there is no actual binary point; some of the bits are used to say where the binary ,NA,NA
point is considered to lie. ,NA,NA
Floating point expressions can represent numbers that are very small and very large. When ,NA,NA
"a floating point calculation is performed, the binary point floats to the correct position in the ",NA,NA
result. The programmer does not need to explicitly keep track of it. ,NA,NA
QUESTION 3:,NA,NA
Is floating point a very modern or a very old idea? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_3.html [8/8/2545 12:54:50],NA
A good answer might be: ,NA,NA
Old. ,NA,NA
Early Floating Point,NA,NA
The first digital computer (Konrad Zuse's Z1 built in 1938) was also the first computer to use ,NA,NA
floating point representation. Early computers were built to do engineering and scientific ,NA,NA
calculation so it is no surprise that the invention of floating point happened at the same time. ,NA,NA
"In later years it was realized that computers are very useful things, and not just for ",NA,NA
calculation. Often floating point was not supported. ,NA,NA
Many early minicomputers and microprocessors did not directly support floating point in ,NA,NA
"hardware. For example, Intel processor chips before the 80486 did not directly support ",NA,NA
"floating point. A floating point operation in a program (written in C, say) was compiled into a ",NA,NA
sequence of bit-manipulation instructions that did the required operations. ,NA,NA
"MIPS processors are very strong on floating point, and have supported the IEEE standard ",NA,NA
from their (and its) beginning. MIPS are for high-end engineering and graphics workstations ,NA,NA
and are famous for their fast floating point. ,NA,NA
QUESTION 4:,NA,NA
(Not very hard thought question: ) Do you imagine that in (say) 1975 that the ,NA,NA
floating point methods used on IBM mainframes was the same as on DEC ,NA,NA
minicomputers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_4.html [8/8/2545 12:55:02],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Floating Point Compatibility,NA,NA
"Up until 1985 each hardware manufacturer had its own type of floating point. Worse, ",NA,NA
different machines from the same manufacturer might have different types of floating point! ,NA,NA
"And when floating point was not supported in the hardware, the different compilers ",NA,NA
emulated different floating point types. ,NA,NA
The situation was awful. Consider a magnetic tape full of data written by an IBM mainframe. ,NA,NA
Now the tape must be read by a DEC minicomputer. Assume that the bits on the tape can ,NA,NA
be read in correctly. But DEC used different type of floating point than IBM interpretting thos ,NA,NA
"bits is hard! This problem was very common, and with ""legacy data"" is still common. NASA ",NA,NA
(the USA National Aeronautical and Space Administration) has warehouses full of tapes ,NA,NA
from various space missions written in many different formats. ,NA,NA
QUESTION 5:,NA,NA
"Should the same numerical calculation, performed on two different ",NA,NA
"computers, give the same result on each? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_5.html [8/8/2545 12:55:09],NA
A good answer might be: ,NA,NA
Yes. But before a floating point standard this was sometimes not true. ,NA,NA
Scientific Notation,NA,NA
To address this problem the IEEE (Institute of Electrical and Electronics Engineers) created ,NA,NA
"a standard for floating point. This is the IEEE 754 standard, released in 1985 after many ",NA,NA
years of development. All hardware and software since then follow this standard (many ,NA,NA
processors also support older standards as well). ,NA,NA
The idea of floating point comes from ,NA,NA
scientific notation,NA,NA
 for numbers. You have probably ,NA,NA
seen this before (and may already be shuddering). Here is a number in scientific notation: ,NA,NA
1.38502 × 10,03,NA
---+---     |,NA,NA
 |        +-- exponent,NA,NA
 |,NA,NA
 +--- mantissa   ,NA,NA
The mantissa is always has a decimal point after the first digit. The above expression ,NA,NA
means: ,NA,NA
1.38502 × 10,03,NA
 = 1385.02,NA,NA
"The decimal point ""floats"" to where it belongs. In effect, the mantissa gives the number and ",NA,NA
the exponent says where the decimal point should go. ,NA,NA
QUESTION 6:,NA,NA
Write the following in scientific notation: ,NA,NA
243.92,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_6.html [8/8/2545 12:55:11],NA
A good answer might be: ,NA,NA
243.92 = 2.4392 × 10,NA,NA
02,NA,NA
Negative Exponents,NA,NA
The exponent shows by what power of ,NA,NA
10,NA,NA
" to multiply the mantissa by, or (the same thing) ",NA,NA
how far to float the decimal point. ,NA,NA
10,NA,NA
+n,NA,NA
  means shift the decimal point ,NA,NA
n,NA,NA
 places ,NA,NA
right,NA,NA
. ,NA,NA
10,NA,NA
-n ,NA,NA
means shift the decimal point ,NA,NA
n,NA,NA
 places ,NA,NA
left,NA,NA
. ,NA,NA
1.82371,NA,NA
× ,NA,NA
10,1,NA
=,NA,NA
1.82371,NA,NA
× ,NA,NA
10,NA,NA
=,NA,NA
18.2371,NA,NA
(shift right 1 ,NA,NA
place),NA,NA
1.82371,NA,NA
× ,NA,NA
10,-1,NA
=,NA,NA
1.82371,NA,NA
× ,NA,NA
.1,NA,NA
=,NA,NA
.182371,NA,NA
(shift left 1 ,NA,NA
place),NA,NA
1.82371,NA,NA
× ,NA,NA
10,2,NA
=,NA,NA
1.82371,NA,NA
× ,NA,NA
100,NA,NA
=,NA,NA
182.371,NA,NA
(shift right 2 ,NA,NA
places),NA,NA
1.82371,NA,NA
× ,NA,NA
10,-2,NA
=,NA,NA
1.82371,NA,NA
× ,NA,NA
.01,NA,NA
=,NA,NA
.0182371,NA,NA
(shift left 2 ,NA,NA
places),NA,NA
QUESTION 7:,NA,NA
Write ,NA,NA
0.000456,NA,NA
 in scientific notation. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_7.html [8/8/2545 12:55:17],NA
A good answer might be: ,NA,NA
0.000456 = 4.56 × 10,NA,NA
-4 ,NA,NA
"There must be only one digit to the left of the decimal place, so an answer like ",NA,NA
45.6 × 10,NA,NA
-,NA,NA
5,NA,NA
 is not in the correct format. ,NA,NA
Negative Values,NA,NA
The notation for a negative number has a negative sign in front of the first digit: ,NA,NA
-1.38502 × 10,03,NA
 = -(1.38502 × 10,03,NA
) = -1385.02,NA,NA
The notation for a small negative number has two negative signs: one to negate the entire ,NA,NA
number and one (in the exponent) to shift the decimal point left: ,NA,NA
-1.38502 × 10,-5,NA
 = -(1.38502 × 10,-3,NA
) = -0.0000138502,NA,NA
QUESTION 8:,NA,NA
Match the numbers in column I with the scientific notation in column II. ,NA,NA
I,NA,NA
click the button,NA,NA
II,NA,NA
2.034 ,matches,NA
(a)  -2.034 × 10,0,NA
-2.034 ,matches,NA
(b)  2.034 × 10,2,NA
203.4 ,matches,NA
(c)  2.034 × 10,0,NA
.002034 ,matches,NA
(d)  -2.034 × 10,"1
  
  
  
  
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_8.html (1 of 2) [8/8/2545 12:55:23]",NA
-20.34 ,matches,NA
(e)  -2.034 × 10,-2,NA
-.02034 ,matches,NA
(f)  2.034 × 10,"-3
  
  
  
  
 http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_8.html (2 of 2) [8/8/2545 12:55:23]",NA
A good answer might be: ,NA,NA
Click! ,NA,NA
e,NA,NA
"Writing the cross × and the superscript exponent is tedious, and not suitable for programs. A ",NA,NA
slighltly altered notation is used in computer programs and in input and output text: ,NA,NA
 1.38502 × 10,+03,NA
 =  1.38502e+03,NA,NA
 1.38502 × 10,-03,NA
 =  1.38502e-03,NA,NA
-1.38502 × 10,+03,NA
 = -1.38502e+03,NA,NA
-1.38502 × 10,-03,NA
 = -1.38502e-03,NA,NA
"Caution: For SPIM, only a small ""e"" is allowed in floating point constants. (Some software ",NA,NA
"systems, such as Java, allow both upper and lower case e's). ",NA,NA
QUESTION 9:,NA,NA
How many digits are in each of the above expressions? How many digits are ,NA,NA
in the mantissa? How many in the exponent? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_9.html [8/8/2545 12:55:38],NA
A good answer might be: ,NA,NA
How many digits are in each of the above expressions? 8 How many digits are in the ,NA,NA
mantissa? 6 How many in the exponent? 2 ,NA,NA
Fixed Number of Digits,NA,NA
This is getting close to the idea of floating point. Each expression has eight digits. Two of ,NA,NA
"the digits are used to ""float"" the decimal point. The remaining six show the digits of the ",NA,NA
number. ,NA,NA
The number of digits in the mantissa is called the ,NA,NA
precision,NA,NA
 of the floating point number. ,NA,NA
When we start talking about binary floating point the precision will be the number of bits in ,NA,NA
the mantissa. With a 32-bit single-precision floating point value the mantissa represents 24 ,NA,NA
"bits, so single precsion floats have 24 bits of precision. ",NA,NA
Caution:,NA,NA
 sometimes in casual speach people say that single precision values have 32 bits ,NA,NA
"of precision, but this is not actually correct. ",NA,NA
Another Caution:,NA,NA
 the mantissa uses 23 bits to represent its 24 bits of precision. This trick ,NA,NA
will be discussed shortly. ,NA,NA
QUESTION 10:,NA,NA
How many possible mantissas can be represented in single precision? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_10.html [8/8/2545 12:55:44],NA
How many possible mantissas can be represented in single precision? ,NA,NA
A good answer might be: ,NA,NA
A mantissa has 23 bits so there are ,NA,NA
2,23,NA
 patterns possible. ,NA,NA
IEEE 754 Floating Point,NA,NA
An IEEE 754 single-precision floating point value is 32 bits long. The bits are divided into fixed-,NA,NA
sized fields as follows: ,NA,NA
Bits 0 through 22 are for the mantissa; bits 23 through 30 are for the exponent; and bit 31 is the ,NA,NA
sign bit. The mantissa and exponent fields work like the similar parts in scientific notation ,NA,NA
(details follow). The sign bit gives the sign of the entire expression: a 0 bit means positive and a ,NA,NA
1 bit means negative. ,NA,NA
QUESTION 11:,NA,NA
You have seen the MIPS instruction ,NA,NA
bltz,NA,NA
 which branches if the 32-bit integer in a ,NA,NA
register is less than zero (negative). It does this by looking at bit 31 of the two's ,NA,NA
complement integer and branching if it is set. ,NA,NA
Does this instruction work with single precision values? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_11.html [8/8/2545 12:56:12],NA
A good answer might be: ,NA,NA
Yes. The sign bit of 32-bit integers and of 32-bit floats is set (to one) when the value is ,NA,NA
negative and clear (to zero) when the value is positive or zero. ,NA,NA
More on Ms. Mantissa,NA,NA
The mantissa represents a number in 24-bit base two positional notation that looks like this: ,NA,NA
1.xxxxxxxxxxxxxxxxxxxxxxx     (x = 0 or 1; there are 23 x's),NA,NA
Very tricky:,NA,NA
 The mantissa represents the 23-bit binary fraction part of a 24-bit number that ,NA,NA
"starts with a ""1"". The 2",0,NA
 place (the one's place) is presumed to contain a 1 and ,NA,NA
is not ,NA,NA
present in the mantissa.,NA,NA
 This trick gives us 24 bits of precision with only 23 bits. ,NA,NA
"For example, the binary number ",NA,NA
1.,NA,NA
11110000101101101010001,NA,NA
 is represented as ,NA,NA
11110000101101101010001,NA,NA
QUESTION 12:,NA,NA
If you had a daughter would you name her Mantissa? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_12.html [8/8/2545 12:56:23],NA
A good answer might be: ,NA,NA
What a sweet name! ,NA,NA
How the Mantissa Works,NA,NA
"Since leading zeros of a binary number can be dropped, it is safe to not actually include the ",NA,NA
"first 1. There will always be one, so there is no need to show it. The exponent is adusted so ",NA,NA
that the most significant 1 is in the one's place of the mantissa. For example: say that you ,NA,NA
wish to represent ,NA,NA
00011.00101101,NA,NA
 as a float. ,G,NA
Drop the leading zeros: ,NA,NA
11.00101101,NA,NA
 with a leading one.,G,NA
Shift the binary point so that the leading one is in the one's place: ,NA,NA
1.100101101 × 2,NA,NA
1,NA,NA
(the ,NA,NA
exponent shows the shift) ,G,NA
Drop the leading one: ,NA,NA
100101101 × 2,NA,NA
1 ,G,NA
Add zero bits so that there are 23 bits in total: ,NA,NA
10010110100000000000000 × 2,NA,NA
1 ,G,NA
The mantissa is: ,NA,NA
10010110100000000000000,NA,NA
QUESTION 13:,NA,NA
Is the mantissa always zero or positive? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_13.html [8/8/2545 12:56:52],NA
A good answer might be: ,NA,NA
Yes. (The sign bit is not part of the mantissa). ,NA,NA
Practice,NA,NA
You must be eager to try this yourself!! Here is an opportunity. The number 7.46875,10,NA
written in base two positional notation is 00111.01111 (the leading zeros are not needed). ,NA,NA
What is the mantissa of this number? ,NA,NA
Represent this number:,00111.01111,NA
Drop the leading zeros:,?,NA
Shift the binary point:,?,NA
Drop the leading one:,?,NA
Right-pad with zero:,?,NA
The Mantissa is:,?,NA
QUESTION 14:,NA,NA
What part of the single precision float represents the shifted binary point? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_14.html [8/8/2545 12:56:54],NA
A good answer might be: ,NA,NA
The exponent. ,NA,NA
The Exponent,NA,NA
"The eight bits 23 through 30 contain the exponent. The exponent is an integer, but may be ",NA,NA
"negative, zero, or positive. You might guess that an 8-bit two's complement integer would work ",NA,NA
"perfectly for this, but a different type of notation is used. ",NA,NA
The exponent is expressed using a ,NA,NA
biased integer,NA,NA
. This is an ,NA,NA
unsigned,NA,NA
 binary integer that has ,NA,NA
+127,NA,NA
 added to it. ,G,NA
A biased exponent of ,NA,NA
+127,NA,NA
 represents the actual exponent 0. ,G,NA
A biased exponent of ,NA,NA
+128,NA,NA
 represents the actual exponent 1. ,G,NA
A biased exponent of ,NA,NA
+121,NA,NA
 represents the actual exponent -1.,NA,NA
Exceptions:,NA,NA
 (1) the biased exponent of ,NA,NA
0,NA,NA
 is used when the entire float is zero. (2) the biased ,NA,NA
exponent of ,NA,NA
255,NA,NA
 is used to signal various problems such as division by zero. ,NA,NA
QUESTION 15:,NA,NA
What is the mantissa when the entire float is zero? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_15.html [8/8/2545 12:56:57],NA
What is the mantissa when the entire float is zero? ,NA,NA
A good answer might be: ,NA,NA
Zero. ,NA,NA
Exponent Practice,NA,NA
Of course the sign bit is zero when the number is zero. A ,NA,NA
floating point zero,NA,NA
 consists of 32 ,NA,NA
zero bits. The MIPS instructions that test for integer zero can test for floating point zero. ,NA,NA
actual exponent,NA,NA
biased exponent,NA,NA
eight bit exponent,NA,NA
0 ,"? 
  
  
  
  
  ?",NA
10 ,?,NA
-10 ,?,NA
127 ,?,NA
-127 ,?,NA
QUESTION 16:,NA,NA
How is the exponent -127 represented? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_16.html [8/8/2545 12:57:08],NA
A good answer might be: ,NA,NA
"It is not represented. (Remember, the biased exponent 0000 0000 is used for the value ",NA,NA
zero). ,NA,NA
Float Formula,NA,NA
"Here is a formula that summarizes the past several pages. In it, ",NA,NA
s,NA,NA
" is the sign bit (0 or 1), ",NA,NA
M,NA,NA
 is ,NA,NA
the mantissa (.000...000 to .1111...111) and ,NA,NA
E,NA,NA
 is the exponent (-126 to +127). ,"value = (-1)
 s
  × 1.M × 2
 E-127",NA
"To convert a paper-and-pencil number into IEEE floating point, fill in each piece of the picture. ",NA,NA
Let us represent 1.0 to float. ,NA,NA
QUESTION 17:,G,NA
What is the sign bit of 1.0?,G,NA
"What is the mantissa of 1.0? (Hint: remember the assumed ""1."" preceding ",NA,NA
the mantissa) ,G,NA
What is the actual exponent of 1.0?,G,NA
What is the biased of 1.0? (Hint: add the actual exponent to 127),http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_17.html [8/8/2545 12:57:13],NA
A good answer might be:,G,NA
What is the sign bit of 1.0? 0 (for positive) ,G,NA
What is the mantissa of 1.0? 000 0000 0000 0000 0000 0000 ,G,NA
What is the actual exponent of 1.0? 0 ,G,NA
What is the biased of 1.0? 127,10,NA
   =   0111 1111,2,NA
1.0,NA,NA
Fitting each of these pieces into their proper fields gives us the full 32 bits: ,NA,NA
If the bit pattern is written in hexadecimal it is ,NA,NA
0x3F800000,NA,NA
". To check that this is correct, use ",NA,NA
"SPIM. Write a program that declares a floating point 1.0, then run SPIM. ","## Program to represent 1.0
  
  .text
  
  .globl  main 
  
 main:
  
  .data 
  
 val:    .float    1.0 
  
 ## End of file",NA
QUESTION 18:,NA,NA
"When you load this program in SPIM, where will the 1.0 be? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_18.html [8/8/2545 12:57:38],NA
A good answer might be: ,The,NA
0x3F800000,will be in the DATA section in the 32 bits starting at address 0x10010000.,NA
SPIM Data,"Of course, to the memory system a 32-bit floating point value is just another 32 bit pattern. Here is (part) of 
 SPIM's display showing this:",NA
QUESTION 19:,(Review: ) Can -0.1 be represented precisely as a 32-bit float?,NA
A good answer might be: ,NA,NA
No. Remember from the last chapter that ,NA,NA
0.1,NA,NA
 can't be represented precisely in binary. ,NA,NA
Using floating point representation does not change anything. It does not matter that the ,NA,NA
number is negative. ,NA,NA
-0.1,NA,NA
But let us proceed to see how ,NA,NA
-0.1,NA,NA
 is (imprecisely) represented. ,G,NA
The sign bit of -0.1 is 1 (for negative).,G,NA
The binary fraction for 0.1 (from the previous chapter is) ,NA,NA
0.0001100110011001100110011001100...,G,NA
The mantissa of 0.1 is: ,H,NA
Shift the leading bit into the one's place: ,NA,NA
1.100110011001100110011001100...,H,NA
"The shift was 4 places left, for an exponent of -4 ",H,NA
Drop bit in the one's place: ,NA,NA
.100110011001100110011001100...,H,NA
Retain 23 bits: ,NA,NA
100 1100 1100 1100 1100 1100 ,G,NA
The actual exponent is -4 ,G,NA
The biased exponent is ,NA,NA
127-4 = 123 = 0111 1011,NA,NA
QUESTION 20:,NA,NA
Here are the bits written out: ,NA,NA
+- exponent,NA,NA
Mantissa,NA,NA
1,NA,NA
0 1 1 1 1 0 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0,NA,NA
Write out the bit pattern as hexadecimal. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-30/ass30_20.html [8/8/2545 12:58:23],NA
A good answer might be:,NA,NA
+- exponent,NA,NA
Mantissa,NA,NA
1,NA,NA
0 1 1 1 1 0 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0,NA,NA
B,NA,NA
D,NA,NA
C,NA,NA
C,NA,NA
C,NA,NA
C,NA,NA
C,NA,NA
C,NA,NA
End of the Chapter,NA,NA
"On SPIM, a constant of -0.1 is represented as 0xBDCCCCCD because the value is rounded ",NA,NA
"up one bit to form the ""D"" at the end. ",NA,NA
You have reached the end this chapter. You may wish to review the following. Point your ,NA,NA
mouse to a subject that interests you to go to where it was discussed. ,G,NA
The advantages of floating point. ,G,NA
History of floating point.,G,NA
Scientific notation for numbers.,G,NA
Precision of a floation point number. ,G,NA
IEEE 754 Floating Point Standard ,G,NA
The mantissa.,G,NA
The exponent.,G,NA
Floating point zero.,G,NA
Formula for floating point.,NA,NA
CHAPTER 31 — Floating Point Arithmetic ,NA,NA
on MIPS,NA,NA
"The MIPS chips use the IEEE 754 floating point standard, both the 32 bit and the 64 bit ",NA,NA
versions. However these notes cover only the 32 bit instructions. The 64 bit versions are ,NA,NA
similar. ,NA,NA
Chapter Topics:,G,NA
Floating point registers.,G,NA
Loading and storing floating point registers. ,G,NA
Single and (some) double precision arithmetic. ,G,NA
Data movement instructions.,G,NA
Reading and writing floating point.,NA,NA
QUESTION 1:,NA,NA
The 64 bit (double precision) floating point numbers are better than 32 bit ,NA,NA
(single precision). But how are they better? ,G,NA
Increased Precison?,G,NA
Greater Range of values convered? ,G,NA
Both?,NA,NA
A good answer might be: ,NA,NA
Both. Double precision numbers have more bits for the exponent (so the range of values ,NA,NA
is increased) and more bits in the mantissa (so the precision is increased). ,NA,NA
MIPS Floating Point,NA,NA
Floating point on MIPS was originally done in a separate chip called ,NA,NA
coprocessor 1,NA,NA
 (also ,NA,NA
called the FPA for Floating Point Accelerator). Modern MIPS chips include floating point ,NA,NA
operations on the main processor chip. But the instructions sometimes act as if there were ,NA,NA
still a separate chip. ,NA,NA
MIPS instructions use the IEEE 754 standard. MIPS has 32 single precision (32 bit) floating ,NA,NA
point registers. ,G,NA
The registers are named $f0 – $f31 ,G,NA
"$f0 is not special (it can hold any bit pattern, not just zero).",G,NA
"Single precision floating point load, store, arithmetic, and other instructions work with ",NA,NA
these registers.,NA,NA
QUESTION 2:,NA,NA
"(Memory Test: ) Why is $f0 not hard-wired to floating point zero, like register ",NA,NA
$0 is hard-wired to integer zero? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_2.html [8/8/2545 12:59:49],NA
A good answer might be: ,NA,NA
"Because floating point zero has the same representation as integer zero, 32 zero-bits. ",NA,NA
Double Precision,NA,NA
"MIPS also has hardware for double precision (64 bit) floating point operations. For this, it ",NA,NA
"uses pairs of single precision registers to hold operands. There are 16 pairs, named $f0, ",NA,NA
"$f2, — $f30. Only the even numbered register is specified in a double precision instruction; ",NA,NA
the odd numbered register of the pair is included automatically. ,NA,NA
"Some MIPS processors allow only even-numbered registers ($f0, $f2,...) for single precision ",NA,NA
instructions. However SPIM allows all 32 registers in single precision instructions. These ,NA,NA
notes follow that usage. ,NA,NA
QUESTION 3:,NA,NA
"Remember the load delay, where it takes an extra machine cycle after a load ",NA,NA
instruction before integer data reaches a general purpose register? Do you ,NA,NA
think there is a load delay for floating point load operations? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_3.html [8/8/2545 12:59:52],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Single Precision Load,NA,NA
Actual hardware has a delay between a load instruction and the time when the data reaches ,NA,NA
"the register. In SPIM there is an option that disables the load delay. For this chapter, set this ",NA,NA
option. (Floating point is tricky enough already). ,NA,NA
Loading a single precision value is done with a pseudoinstruction: ,NA,NA
"l.s   fd,addr     --- load register fd from addr",NA,NA
This instruction loads 32 bits of data from address ,NA,NA
addr,NA,NA
 into floating point register ,NA,NA
$fd ,NA,NA
(where ,NA,NA
d,NA,NA
" is 0, 1, 2, ..., 15). Whatever 32 bits are located at ",NA,NA
addr,NA,NA
 are copied into ,NA,NA
$fd,NA,NA
. If the ,NA,NA
"data makes no sense as a floating point value, that is OK for this instruction. Later on the ",NA,NA
"mistake will be caught, when floating point operations are attempted. ",NA,NA
QUESTION 4:,NA,NA
Every one of the 2,32,NA
 patterns that 32 bits can form is a legal two's ,NA,NA
complement integer. ,NA,NA
Are some of there patterns not legal as a floating point value? Hint: think about the ,NA,NA
exponent and a zero mantissa. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_4.html [8/8/2545 13:00:11],NA
A good answer might be: ,NA,NA
It is not legal to have a non-zero exponent with a matissa that is zero. There are other ,NA,NA
nonsense combinations that are also illegal. ,NA,NA
Single Precision Store,NA,NA
Sometimes the floating point registers are used as temporary registers for integer data. For ,NA,NA
"example, rather than storing a temporary value to memory, you can copy it to an unused ",NA,NA
"floating point register. This is OK, as long as you don't try to do math with them. ",NA,NA
The single precision store pseudoinstruction is similar: ,NA,NA
"s.s   fd,addr     --- store register fd to addr",NA,NA
Whatever 32 bits are in ,NA,NA
fd,NA,NA
 are copied to ,NA,NA
addr,NA,NA
In both of these pseudoinstructions the address ,NA,NA
addr,NA,NA
" can be an ordinary symbolic address, ",NA,NA
"or an indexed address. (As of this writing, these notes have not covered indexed ",NA,NA
addresses). ,NA,NA
QUESTION 5:,NA,NA
Why would you want to copy a temporary integer value to a floating point ,NA,NA
register? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_5.html [8/8/2545 13:00:28],NA
A good answer might be: ,NA,NA
To free up a general purpose register for some other use. ,NA,NA
Floating Point Load Immediate,NA,NA
There is a floating point ,NA,NA
load immediate,NA,NA
 instruction. This instruction allows you to load a ,NA,NA
register with a constant value using only one line of assembly language. At the machine ,NA,NA
code level it corresponds to several machine instructions. ,NA,NA
"li.s   fd,val     # (pseudoinstruction)",NA,NA
 # load register $fd with val,NA,NA
Here is a code snippet showing this: ,NA,NA
" li.s    $f1,1.0             # $f1 = constant 1.0 ",NA,NA
"li.s    $f2,2.0             # $f2 = constant 2.0 ",NA,NA
"li.s    $f10,1.0e-5         # $f10 = 0.00001",NA,NA
QUESTION 6:,NA,NA
Could first instruction be written ,NA,NA
"li.s $f1,1",NA,NA
# ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_6.html [8/8/2545 13:00:30],NA
A good answer might be: ,NA,NA
No. The decimal point is needed in the constant (at least for SPIM). ,NA,NA
Example Program,NA,NA
Here is a program that exchanges (swaps) the floating point values at ,NA,NA
valA,NA,NA
 and ,NA,NA
valB,NA,NA
. ,NA,NA
Notice how the two floating point values are written. The first in the ordinary style; the ,NA,NA
second in scientific notation. ,NA,NA
## swap.asm ,NA,NA
## ,NA,NA
## Exchange the values in valA and valB,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" l.s     $f0,valA        # $f0  <-- valA",NA,NA
" l.s     $f1,valB        # $f1  <-- valB",NA,NA
" s.s     $f0,valB        # $f0  --> valB",NA,NA
" s.s     $f1,valA        # $f1  --> valA",NA,NA
" li      $v0,10          # code 10 == exit",NA,NA
 syscall                 # Return to OS.,NA,NA
 .data ,NA,NA
valA:   .float  8.32            # 32 bit floating point value ,NA,NA
valB:   .float  -0.6234e4       # 32 bit floating point value,NA,NA
 # small 'e' only ,NA,NA
## End of file,NA,NA
QUESTION 7:,NA,NA
Could this program have been written using general purpose registers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_7.html [8/8/2545 13:00:42],NA
A good answer might be: ,NA,NA
Yes. The floating point registers in this program were used only as a temporary holding ,NA,NA
space. ,NA,NA
Full-Word Aligned,NA,NA
For both single precision load and store instructions the memory address must be full-word ,NA,NA
alligned. It must be a multiple of four. Ordinarily this is not a problem. The assembler takes ,NA,NA
care of this. ,NA,NA
QUESTION 8:,NA,NA
Do you think that the SPIM system calls that print integers can be used for ,NA,NA
floating point values? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_8.html [8/8/2545 13:00:58],NA
A good answer might be: ,NA,NA
No. They expect a different type of representation. ,NA,NA
Floating Point System Calls,NA,NA
Here is the complete list of SPIM services. The floating point services expect the data to be ,NA,NA
in floating point format. Notice that the calls for double use an even-odd pair of registers. ,NA,NA
Service,NA,NA
Code,NA,NA
Arguments,NA,NA
Returned Value,NA,NA
print integer,NA,NA
1,NA,NA
$a0 ,NA,NA
==,NA,NA
 integer,NA,NA
print float ,NA,NA
2,NA,NA
$f12 ,NA,NA
==,NA,NA
 float ,NA,NA
print double ,NA,NA
3,NA,NA
"($f12, $f13) ",NA,NA
==,NA,NA
 double ,NA,NA
print string ,NA,NA
4,NA,NA
$a0 ,NA,NA
==,NA,NA
 address of string,NA,NA
read integer,NA,NA
5,NA,NA
$v0 ,NA,NA
<--,NA,NA
 integer,NA,NA
read float ,NA,NA
6,NA,NA
$f0 ,NA,NA
<--,NA,NA
 float,NA,NA
read double ,NA,NA
7,NA,NA
"($f0, $f1) ",NA,NA
<--,NA,NA
 double,NA,NA
read string ,NA,NA
8,NA,NA
$a0 ,NA,NA
==,NA,NA
 buffer address ,NA,NA
$a1 ,NA,NA
==,NA,NA
 buffer length,NA,NA
allocate memory ,NA,NA
9,NA,NA
$a0 ,NA,NA
==,NA,NA
 number of bytes,NA,NA
$v0 ,NA,NA
<--,NA,NA
 address,NA,NA
exit ,NA,NA
10,NA,NA
QUESTION 9:,NA,NA
(Review: ) Into what register do you put the service code before executing a ,NA,NA
syscall,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_9.html [8/8/2545 13:01:31],NA
A good answer might be: ,NA,NA
Register ,NA,NA
$v0,NA,NA
Mistake,NA,NA
"Depending on the service, you may have to place arguments in other registers as well. The ",NA,NA
following example program prints out a floating point value. It first does this correctly (using ,NA,NA
system call 2). Then does it incorrectly uses the integer print service (system call 1). Of ,NA,NA
"course, the 32 bits of the floating point value can be interpretted as an integer, so system ",NA,NA
call 2 innocently does what we asked it to do. ,NA,NA
## print.asm ,NA,NA
## ,NA,NA
"## Print out a 32 bit pattern, first as a float, ",NA,NA
## then as an integer.,NA,NA
 .text,NA,NA
 .globl  main,NA,NA
main:,NA,NA
" l.s     $f12,val        # get the float argument ",NA,NA
"li      $v0,2           # code 2 == print float ",NA,NA
syscall                 # (correct),NA,NA
" li      $v0,4           # print",NA,NA
" la      $a0,lfeed       # line separator",NA,NA
 syscall,NA,NA
" lw      $a0,val         # use the float as a int",NA,NA
" li      $v0,1           # code 2 == print int",NA,NA
 syscall                 # (mistake),NA,NA
" li      $v0,10          # code 10 == exit",NA,NA
 syscall                 # Return to OS.,NA,NA
 .data ,NA,NA
val :   .float  -8.32           # negative value ,NA,NA
"lfeed:  .asciiz ""\n"" ",NA,NA
## End of file,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_10.html (1 of 2) [8/8/2545 13:01:37],NA
QUESTION 10:,NA,NA
Will the assembler catch this error? Will the program bomb when it runs? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_10.html (2 of 2) [8/8/2545 13:01:37],NA
A good answer might be: ,NA,NA
"The assembler will not catch this mistake, and the program will run fine. ",NA,NA
No Type Checking,NA,NA
"This type of mistake often happens when programming in ""C"" where type checking is weak. ",NA,NA
Sometimes the wrong type can be passed to a function (such as ,NA,NA
printf,NA,NA
) and odd things ,NA,NA
happen. Here is the output of the program: ,NA,NA
Compilers that keep track of the data types of values and that make sure that the correct ,NA,NA
types are used as arguments do ,NA,NA
strong type checking,NA,NA
. Java is strongly typed. In assembly ,NA,NA
language type checking is largely absent. ,NA,NA
QUESTION 11:,NA,NA
The first line of output shows the 32 bits interpretted as a single precision ,NA,NA
floating point value. Is this output correct? (Hint: look at the program on the ,NA,NA
previous page). ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_11.html [8/8/2545 13:01:42],NA
A good answer might be: ,NA,NA
Maybe Not. The source file for the program specified the constant ,NA,NA
-8.32,NA,NA
 but the program ,NA,NA
printed ,NA,NA
-8.319999694824218700,NA,NA
Precision of Single Precision Floats,NA,NA
There are two things wrong: (1) the value ,NA,NA
-8.32,NA,NA
" can not be represented exactly in binary, ",NA,NA
and (2) SPIM prints out way too many digits. ,NA,NA
Single precision floats have (recall) only 24 bits of precision. This is the equivalent of 7 to 8 ,NA,NA
decimal digits. SPIM prints out many more digits than are actually represented. This is ,NA,NA
incorrect. SPIM should have printed ,NA,NA
-8.319999,NA,NA
 to the window. ,NA,NA
The 7 or 8 decimal digits of precision is much worse than most electronic calculators. It is ,NA,NA
usually unwise to use single precision floating point in programs. (But these chapters use it ,NA,NA
"since the goal is to explain concepts, not to write production grade programs). Double ",NA,NA
precision has 15 or 16 decimal places of precision. ,NA,NA
QUESTION 12:,NA,NA
How many decimal places of precision does Java's primitive type ,NA,NA
float,NA,NA
 have? ,NA,NA
How many decimal places of precision does C's data type ,NA,NA
float,NA,NA
 have? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_12.html [8/8/2545 13:01:44],NA
A good answer might be:,NA,NA
"The answer is the same for both: 7 or 8 places, same as MIPS. All three use the same ",NA,NA
IEEE standard for single precision float. (But be careful: some C compilers allow you to ,NA,NA
"specify how many bits of precision you want for various data types. Also, C implemented ",NA,NA
on a weird machine might be non-standard). ,NA,NA
Single Precision Arithmetic,NA,NA
Here are some single precision arithmetic instructions. All of ,NA,NA
The first instruction computes the absolute value (makes a ,NA,NA
positive value) of the value in register ,NA,NA
$fs,NA,NA
If the data in an operand register is illegal or an illegal operation ,NA,NA
is performed (such as divide by zero) an exception is raised. The ,NA,NA
IEEE 752 standard describes what is done in these situations. ,NA,NA
Instruction,NA,NA
"abs.s fd,fs",NA,NA
"add.s fd,fs,ft",NA,NA
"sub.s fd,fs,ft",NA,NA
"mul.s fd,fs,ft",NA,NA
"div.s fd,fs,ft",NA,NA
"neg.s fd,fs",NA,NA
Operation,NA,NA
$fd = |$fs|,NA,NA
$fd = $fs + $ft,NA,NA
$fd = $fs - $ft,NA,NA
$fd = $fs * $ft,NA,NA
$fd = $fs / $ft,NA,NA
$fd = -$fs,NA,NA
these correspond to a single machine instruction. The double ,NA,NA
"precision version of these instructions has a ""d"" in place of the ",NA,NA
"""s"". So ",NA,NA
add.s,NA,NA
 becomes ,NA,NA
add.d,NA,NA
 and corresponds to the machine ,NA,NA
code that adds double precision. ,NA,NA
QUESTION 13:,NA,NA
(Thought Question: ) How does the ,NA,NA
abs.s,NA,NA
 instruction alter the 32-bit pattern of ,NA,NA
the float? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_13.html [8/8/2545 13:01:47],NA
A good answer might be: ,NA,NA
"It clears (makes zero) the sign bit, bit 31. All the other bits stay the same. ",NA,NA
Data Movement,NA,NA
And the ,NA,NA
neg.s,NA,NA
 instruction toggles the sign bit. Here are three data movement instructions: ,NA,NA
Instruction,NA,NA
"mov.s fd, fs",NA,NA
"mtc1 rs, fd",NA,NA
"mfc1 rd, fs",NA,NA
Operation,NA,NA
copy 32 bits from float register $fs to float register $fd,NA,NA
move to coprocessor 1 copy 32 bits from general register $rs to float register $fd. No ,NA,NA
data conversion is done.,NA,NA
move from coprocessor 1 copy 32 bits from float register $fs to general register $rd. ,NA,NA
No data conversion is done.,NA,NA
These instructions merely copy bit patterns between registers. The pattern is not altered. ,NA,NA
With the ,NA,NA
mftc1,NA,NA
" instruction, the IEEE formatted float in a floating point register is copied as is ",NA,NA
to a general purpose register. So a complicated calculation with integers can use float ,NA,NA
registers for intermediate results. And a complicated calculation with floats can use general ,NA,NA
purpose resisters the same way. ,NA,NA
QUESTION 14:,NA,NA
Can an arithmetic instruction use both floating point and general purpose ,NA,NA
registers? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_14.html [8/8/2545 13:01:49],NA
A good answer might be: ,NA,NA
No. ,NA,NA
Example Program,NA,NA
The example program computes the value of ,NA,NA
ax,NA,NA
2,NA,NA
 + bx + c,NA,NA
. It starts by asking the user for ,NA,NA
x,NA,NA
: ,NA,NA
 .text,NA,NA
 .globl main,NA,NA
main:   # read input,NA,NA
" la      $a0,prompt          # prompt user for x ",NA,NA
"li      $v0,4               # print string",NA,NA
 syscall,NA,NA
" li      $v0,6               # read single",NA,NA
 syscall                     # $f0 <-- x,NA,NA
 # evaluate the quadratic,NA,NA
 . . . . .,NA,NA
 .data,NA,NA
 . . . . .,NA,NA
"prompt: .asciiz ""Enter x: """,NA,NA
After the ,NA,NA
syscall,NA,NA
 the user's value is in ,NA,NA
$v0,NA,NA
. The next section of the program does the ,NA,NA
calculation. ,NA,NA
QUESTION 15:,NA,NA
Should ,NA,NA
a,NA,NA
", ",NA,NA
b,NA,NA
", and ",NA,NA
c,NA,NA
 be integer constants or floating point constants? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_15.html [8/8/2545 13:01:53],NA
A good answer might be: ,NA,NA
Floating point constants ,NA,NA
Evaluation,NA,NA
Here is the part of the code that evaluates the polynomial. Remember that ,NA,NA
x,NA,NA
 is in ,NA,NA
$f0,NA,NA
. ,NA,NA
 . . . . . ,NA,NA
 # evaluate the quadratic,NA,NA
" l.s     $f2,a               # sum = a",NA,NA
" mul.s   $f2,$f2,$f0         # sum = ax",NA,NA
" l.s     $f4,bb              # get b",NA,NA
" add.s   $f2,$f2,$f4         # sum = ax + b",NA,NA
" mul.s   $f2,$f2,$f0         # sum = (ax+b)x = ax^2 +bx ",NA,NA
"l.s     $f4,c               # get c",NA,NA
" add.s   $f2,$f2,$f4         # sum = ax^2 + bx + c",NA,NA
 . . . . . .,NA,NA
 .data ,NA,NA
a:      .float  1.0 ,NA,NA
bb:     .float  1.0 ,NA,NA
c:      .float  1.0,NA,NA
"The assembler objected to the symbolic address ""b"" (because there is a mnemonic ",NA,NA
"instruction ""b"" for branch) so I used ""bb"" instead. ",NA,NA
The polynomial is evaluated from left to right. First ,NA,NA
ax + b,NA,NA
 is calculated. Then that is ,NA,NA
multiplied by ,NA,NA
x,NA,NA
 and ,NA,NA
c,NA,NA
" is added in, giving ",NA,NA
axx + bx + c,NA,NA
. ,NA,NA
The value ,NA,NA
x,NA,NA
2,NA,NA
 is not explicitly calculated. This way of calculating a polynomial is called ,NA,NA
Horner's Method,NA,NA
. It is useful to have in your bag of tricks. ,NA,NA
QUESTION 16:,NA,NA
Why (do you suppose) are the constants ,NA,NA
a,NA,NA
", ",NA,NA
b,NA,NA
", and ",NA,NA
c,NA,NA
 set to ,NA,NA
1.0,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_16.html [8/8/2545 13:01:58],NA
A good answer might be: ,NA,NA
To make debugging easy. ,NA,NA
Printing Out the Result,NA,NA
Here is the final section of the code. ,NA,NA
 . . . . . ,NA,NA
 # print the result,NA,NA
" mov.s   $f12,$f2            # $f12 = argument ",NA,NA
"li      $v0,2               # print single",NA,NA
 syscall,NA,NA
" la      $a0,newl            # new line",NA,NA
" li      $v0,4               # print string",NA,NA
 syscall,NA,NA
" li      $v0,10              # code 10 == exit",NA,NA
 syscall                     # Return to OS.,NA,NA
 .data,NA,NA
 . . . . .,NA,NA
"blank:  .asciiz "" "" ",NA,NA
"newl:   .asciiz ""\n""",NA,NA
 . . . . .,NA,NA
There is nothing new in this code. ,NA,NA
QUESTION 17: ,NA,NA
If ,NA,NA
x = 0.1,NA,NA
 what is ,NA,NA
ax,NA,NA
2,NA,NA
 + bx + c,NA,NA
 when ,NA,NA
a = b = c = 1,NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_17.html [8/8/2545 13:02:01],NA
A good answer might be: ,NA,NA
0.01 + 0.1 + 1.0 = 1.11,NA,NA
", you would hope. ",NA,NA
Complete Program,NA,NA
"Again, the SPIM simulator outputs too many digits. But recall, 0.1 can't be represented ",NA,NA
"exactly, so that may be part of the problem. ",NA,NA
"Here is the complete program, suitable for you to copy into a text editor and to play with: ",NA,NA
## float1.asm -- compute ax^2 + bx + c for user-input x ,NA,NA
 .text,NA,NA
 .globl main,NA,NA
main:   # read input,NA,NA
" la      $a0,prompt          # prompt user for x ",NA,NA
"li      $v0,4               # print string",NA,NA
 syscall,NA,NA
" li      $v0,6               # read single",NA,NA
 syscall                     # $f0 <-- x,NA,NA
 # evaluate the quadratic,NA,NA
" l.s     $f2,a               # sum = a",NA,NA
" mul.s   $f2,$f2,$f0         # sum = ax",NA,NA
" l.s     $f4,bb              # get b",NA,NA
" add.s   $f2,$f2,$f4         # sum = ax + b",NA,NA
" mul.s   $f2,$f2,$f0         # sum = (ax+b)x = ax^2 +bx ",NA,NA
"l.s     $f4,c               # get c",NA,NA
" add.s   $f2,$f2,$f4         # sum = ax^2 + bx + c",NA,NA
 # print the result,NA,NA
" mov.s   $f12,$f2            # $f12 = argument",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_18.html (1 of 2) [8/8/2545 13:02:11],NA
" li      $v0,2               # print single",NA,NA
 syscall,NA,NA
" la      $a0,newl            # new line",NA,NA
" li      $v0,4               # print string",NA,NA
 syscall,NA,NA
 jr      $ra                 # return to OS,NA,NA
## ,NA,NA
##  Data Segment ,NA,NA
##,NA,NA
 .data ,NA,NA
a:      .float  1.0 ,NA,NA
bb:     .float  1.0 ,NA,NA
c:      .float  1.0,NA,NA
"prompt: .asciiz ""Enter x: "" ",NA,NA
"blank:  .asciiz "" "" ",NA,NA
"newl:   .asciiz ""\n""",NA,NA
## end of file ,NA,NA
QUESTION 18:,NA,NA
Had enough? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-31/ass31_18.html (2 of 2) [8/8/2545 13:02:11],NA
A good answer might be: ,NA,NA
Precisely. ,NA,NA
End of Chapter,NA,NA
You have reached the end this chapter. You may wish to review the following. Click on a ,NA,NA
subject that interests you to go to where it was discussed. ,G,NA
Coprocessor 1 ,G,NA
Load delay with floating point ,G,NA
Floating point registers ,G,NA
Floating point load instruction ,G,NA
Floating point store instruction ,G,NA
Full word alignment ,G,NA
Input and output of floating point (in SPIM) ,G,NA
Decimal precision of floating point ,G,NA
Arithmetic instructions ,G,NA
Data movement instructions ,G,NA
Horner's method,NA,NA
CHAPTER 32 — Floating Point ,NA,NA
Comparison Instructions,NA,NA
"The MIPS FPA chip (now, usually part of the processor chip) has a condition bit that is set ",NA,NA
to ,NA,NA
0,NA,NA
 or ,NA,NA
1,NA,NA
 to indicate if a condition is false or true. Serval FPA instructions affect this bit and ,NA,NA
several CPU instructions test this bit. ,NA,NA
Chapter Topics:,G,NA
Comparison instructions: ,NA,NA
c.eq.s,NA,NA
", ",NA,NA
c.lt.s,NA,NA
", ",NA,NA
c.le.s ,G,NA
Branch instructions: ,NA,NA
bc1f,NA,NA
", ",NA,NA
bc1t ,G,NA
The Condition bit ,G,NA
Newton's method,NA,NA
QUESTION 1:,NA,NA
Are the FPA (floating point accelerator) and coprocessor 1 the same? ,NA,NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
FPA Chip,NA,NA
"In the early days of MIPS, floating point was ",NA,NA
were used to bridge the gap between the two chips (such as the two move instructions ,NA,NA
mtc1 ,NA,NA
and ,NA,NA
mfc1,NA,NA
 we have already seen). Although ,NA,NA
done on a separate chip. Special instructions ,NA,NA
"these days there is usually just one processor chip, some of the instructions act as if the ",NA,NA
chips were separate. ,NA,NA
QUESTION 2:,NA,NA
(Thought Question: ) Do you think that testing if two floating point values are ,NA,NA
equal is a common thing to do? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_2.html [8/8/2545 13:03:15],NA
A good answer might be: ,NA,NA
Maybe. ,NA,NA
Comparison Instructions,NA,NA
Testing if two floating point numbers are exactly equal is sometimes NOT a good idea. ,NA,NA
Floating point calculations are not exact. Sometimes values are not equal even though ,NA,NA
"mathematically they should be. It is best to use ""less than"" or ""less than or equal"" instead of ",NA,NA
testing for exact equality. Here are some MIPS comparison instructions: ,NA,NA
Instruction,NA,NA
"c.eq.s fs, ft",NA,NA
"c.lt.s fs, ft",NA,NA
"c.le.s fs, ft",NA,NA
Operation,NA,NA
set condition bit if ,NA,NA
$fs == $ft,NA,NA
set condition bit if ,NA,NA
$fs < $ft,NA,NA
set condition bit if ,NA,NA
$fs <= $ft,NA,NA
The condition bit is set (made equal to one) if the condition is true. Otherwise the condition ,NA,NA
bit is cleared (made equal to zero). There are more comparison operations than these. But ,NA,NA
for these notes use just these three. The others involve the various IEEE 754 codes for ,NA,NA
exceptional results. ,NA,NA
QUESTION 3:,NA,NA
"There is no ""greater than"" instruction! What can we do? ",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_3.html [8/8/2545 13:03:19],NA
A good answer might be: ,NA,NA
"Use ""less than"" with the operations reversed. ",NA,NA
Branch Instructions,NA,NA
The floating point branch instructions inspect the condition bit in the coprocessor. The ,NA,NA
bc1t ,NA,NA
instruction takes the branch if the bit is true (==1). The ,NA,NA
bc1t,NA,NA
 instruction takes the branch if ,NA,NA
the bit is false (==0). These are the only two floating point branch instructions. ,NA,NA
Instruction,NA,NA
bc1t label,NA,NA
bc1f label,NA,NA
Operation,NA,NA
branch to   ,NA,NA
label,NA,NA
  if the coprocessor 1 condition bit is true,NA,NA
branch to   ,NA,NA
label,NA,NA
  if the coprocessor 1 condition bit is false,NA,NA
The branch instructions have a one instruction branch delay. A real machine has a ,NA,NA
nop ,NA,NA
instruction after each branch instruction (automatically put there by the assembler or by the ,NA,NA
"compiler). For this chapter, let us not bother with this. When running the programs with ",NA,NA
"SPIM, disable branch delays. ",NA,NA
QUESTION 4:,NA,NA
Where does execution of the ,NA,NA
bc1t,NA,NA
 instruction take place? In the FPU or the ,NA,NA
CPU? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_4.html [8/8/2545 13:03:35],NA
A good answer might be: ,NA,NA
"The CPU. Although the instruction tests a bit in the FPU, it affects the program counter ",NA,NA
of the CPU and takes place in the CPU. ,NA,NA
Example,NA,NA
"The example program looks at two floating point values, A and B, and writes a message ",NA,NA
saying which one is smallest. First the program loads the two values ,NA,NA
A,NA,NA
 and ,NA,NA
B,NA,NA
 into registers: ,NA,NA
main:   # get the values into registers,NA,NA
" l.s     $f0,A",NA,NA
" l.s     $f2,B",NA,NA
 . . . . ,NA,NA
A:      .float  4.830 ,NA,NA
B:      .float  1.012,NA,NA
 . . . . ,NA,NA
Then the code tests if ,NA,NA
A<B,NA,NA
", or ",NA,NA
B<A,NA,NA
". If neither of these is true, then it must be that ",NA,NA
B==A,NA,NA
. ,NA,NA
 . . . .,NA,NA
" c.lt.s  $f0,$f2          # is A < B?",NA,NA
 bc1t    printA           # yes -- print A,NA,NA
" c.lt.s  $f2,$f0          # is B < A?",NA,NA
 bc1t    printB           # yes -- print B,NA,NA
" la      $a0,EQmsg        # otherwise",NA,NA
" li      $v0,4            # they are equal",NA,NA
 . . . . ,NA,NA
QUESTION 5:,NA,NA
The three outcomes can be detected by other conditionals. Here is another ,NA,NA
arrangement of the code: ,NA,NA
" c._____.s  $f0,$f2       # is A = B?",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_5.html (1 of 2) [8/8/2545 13:03:40],NA
 bc1t    printEQ          # yes -- print equal,NA,NA
" c._____.s  $f2,$f0       # is B < A?",NA,NA
 bc1t    printB           # yes -- print B,NA,NA
 bc1t    printA           # otherwise A < B,NA,NA
Fill in the blanks. You may wish to consult the list of floating point ,NA,NA
comparison ,NA,NA
instructions.,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_5.html (2 of 2) [8/8/2545 13:03:40],NA
A good answer might be:,NA,NA
" c.eq.s  $f0,$f2          # is A = B?",NA,NA
 bc1t    printEQ          # yes -- print equal,NA,NA
" c.lt.s  $f2,$f0          # is B < A?",NA,NA
 bc1t    printB           # yes -- print B,NA,NA
 bc1t    printA           # otherwise A < B,NA,NA
The Complete Program,NA,NA
Here is the complete program. There is nothing new in the remainder of the code. ,NA,NA
## min.asm --- determine the min of two floats ,NA,NA
##,NA,NA
 .text,NA,NA
 .globl main,NA,NA
main:   # get the values into registers,NA,NA
" l.s     $f0,A",NA,NA
" l.s     $f2,B",NA,NA
" c.lt.s  $f0,$f2          # is A < B?",NA,NA
 bc1t    printA           # yes -- print A,NA,NA
" c.lt.s  $f2,$f0          # is B < A?",NA,NA
 bc1t    printB           # yes -- print B,NA,NA
" la      $a0,EQmsg        # otherwise",NA,NA
" li      $v0,4            # they are equal",NA,NA
 syscall,NA,NA
" mov.s   $f12,$f0         # print one of them ",NA,NA
b       prtnum,NA,NA
"printA: la      $a0,Amsg         # message for A ",NA,NA
"li      $v0,4",NA,NA
 syscall,NA,NA
" mov.s   $f12,$f0         # print A",NA,NA
 b       prtnum,NA,NA
"printB: la      $a0,Bmsg         # message for A ",NA,NA
"li      $v0,4",NA,NA
 syscall,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_6.html (1 of 2) [8/8/2545 13:03:46],NA
" mov.s   $f12,$f2         # print A",NA,NA
"prtnum: li      $v0,2            # print single",NA,NA
 syscall,NA,NA
" la      $a0,newl",NA,NA
" li      $v0,4            # print new line",NA,NA
 syscall,NA,NA
 jr      $ra              # return to OS,NA,NA
 .data,NA,NA
A:      .float  4.830 ,NA,NA
B:      .float  1.012 ,NA,NA
"Amsg:   .asciiz ""A is smallest: "" ",NA,NA
"Bmsg:   .asciiz ""B is smallest: "" ",NA,NA
"EQmsg:  .asciiz ""They are equal: "" ",NA,NA
"newl:   .asciiz ""\n""",NA,NA
QUESTION 6:,NA,NA
Do you think that the condition bit (of the FPU) holds its value until it is ,NA,NA
altered by another comparision instruction? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_6.html (2 of 2) [8/8/2545 13:03:46],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Condition Bit Holds its Value,NA,NA
The condition bit is like a one bit register that continues to hold the result of a comparison ,NA,NA
until another one is made. The following code ensures that register ,NA,NA
$f12,NA,NA
 has the minimum ,NA,NA
of ,NA,NA
$f0,NA,NA
 or ,NA,NA
$f2,NA,NA
". If they are equal, then ",NA,NA
$f12,NA,NA
 gets the value of both. ,NA,NA
"main:   l.s     $f0,A            # get the values ",NA,NA
" l.s     $f2,B            # into registers",NA,NA
" c.lt.s  $f0,$f2          # is A < B?",NA,NA
" mov.s   $f0,$f12         # move A to $f12",NA,NA
 # (condition bit holds its value),NA,NA
 bc1t    common           # otherwise,NA,NA
" mov.s   $f2,$f12         # move B to $f12 ",NA,NA
common:,NA,NA
The above code is contrived; it would be better to reverse the third and fourth statements. ,NA,NA
"However, sometimes it is very useful to hold the condition bit's value for several instructions ",NA,NA
before using it. ,NA,NA
QUESTION 7:,NA,NA
(Review: ) should ,NA,NA
c.eq.s,NA,NA
 be used to implement a while loop? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_7.html [8/8/2545 13:04:44],NA
A good answer might be: ,NA,NA
"No, not usually. With the inherent inaccuracy of floating point this risks creating a non-",NA,NA
terminating loop. This next example shows a while loop. ,NA,NA
Newton's Method,NA,NA
Newton's method,NA,NA
 is a common way to compute the square root of a number. Say that ,NA,NA
n,NA,NA
 is ,NA,NA
the number and that ,NA,NA
x,NA,NA
 is an approximation to the square root of ,NA,NA
n,NA,NA
. Then: ,NA,NA
x' =(1/2)(x + n/x),NA,NA
x',NA,NA
 is an even better approximation to the square root. The reasons for this are buried in your ,NA,NA
"calculus book (which you, perhaps, have buried in the darkest corner of your basement). ",NA,NA
"But, to make the formula plausible, look what happens if the approximation ",NA,NA
x,NA,NA
 happens to be ,NA,NA
exactly the square root: ,NA,NA
x' = (1/2)(x + n/x) = (1/2)( n,0.5,NA
 + n/n,0.5,NA
 ),NA,NA
 = (1/2)(n,0.5,NA
 + n,0.5,NA
) = n,0.5,NA
If ,NA,NA
x,NA,NA
" gets the exact value, it stays fixed at that value. ",NA,NA
QUESTION 8:,NA,NA
Try it. Say that ,NA,NA
n == 4,NA,NA
 and that our first appoximation to the square root is ,NA,NA
x ,NA,NA
== 1,NA,NA
. Use the formula to get the next approximation: ,NA,NA
x' =(1/2)(1 + 4/1),http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_8.html [8/8/2545 13:04:46],NA
A good answer might be: ,NA,NA
x = 2.5,NA,NA
", a better approximation ",NA,NA
Start of the Program,NA,NA
Now using ,NA,NA
x = 2.5,NA,NA
 in the formula yields: ,NA,NA
x' = (1/2)(2.5 + 4/2.5) = (1/2)(2.5 + 1.6) = (1/2)(4.1) = 2.05,NA,NA
The program will repeatedly use the formula to calculate increasingly accurate ,NA,NA
appoximations to the square root. Here is the start of the program: ,NA,NA
## newton.asm -- compute sqrt(n) ,NA,NA
"## given an approximation x to sqrt(n), ",NA,NA
## an improved approximation is:,NA,NA
## x' = (1/2)(x + n/x),NA,NA
## $f0  ---  n ,NA,NA
## $f1  ---  1.0 ,NA,NA
## $f2  ---  2.0 ,NA,NA
## $f3  ---  x  : current approx.,NA,NA
## $f4  ---  x' : next approx.,NA,NA
## $f8  ---  temp ,NA,NA
## $f10 ---  small value,NA,NA
 .text,NA,NA
 .globl main,NA,NA
main: ,NA,NA
" l.s     $f0,n               # get n",NA,NA
" li.s    $f1,1.0             # constant 1.0",NA,NA
" li.s    $f2,2.0             # constant 2.0",NA,NA
" li.s    $f3,1.0             # x == first approx.",NA,NA
 ,NA,NA
"li.s    $f10,1.0e-5         # accuracy limit loop:",NA,NA
The program will be written so that it stops looping when no further improvement is possible. ,NA,NA
We can't expect to get the answer exactly correct. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_9.html (1 of 2) [8/8/2545 13:04:48],NA
QUESTION 9:,NA,NA
(Memory test: ) How many decimal places of precision can be expected with ,NA,NA
floating point? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_9.html (2 of 2) [8/8/2545 13:04:48],NA
A good answer might be: ,NA,NA
"Six or seven. To be safe, count on no better than six digits of accuracy. This program ",NA,NA
uses five place accuracy. ,NA,NA
Apply the Formula,NA,NA
The value in ,NA,NA
f10,NA,NA
 is used to test if the five digits of accuracy have been reached. We will do ,NA,NA
this in a moment. Here is the part of the program that uses the formula: ,NA,NA
## x' = (1/2)(x + n/x),NA,NA
## $f0  ---  n ,NA,NA
## $f1  ---  1.0 ,NA,NA
## $f2  ---  2.0 ,NA,NA
## $f3  ---  x  : current approx.,NA,NA
## $f4  ---  x' : next approx.,NA,NA
## $f8  ---  temp ,NA,NA
## $f10 ---  small value,NA,NA
loop:,NA,NA
" ___.s   $f4,$f0             #  x' = n",NA,NA
" ___.s   $f4,$f4,$f3         #  x' = n/x",NA,NA
" ___.s   $f4,$f3,$f4         #  x' = x + n/x",NA,NA
" ___.s   $f3,$f4,$f2         #  x = (1/2)(x + n/x)",NA,NA
QUESTION 10:,NA,NA
But part of each menemonic is missing! Fill them in. You may wish to look at ,NA,NA
floating point ,NA,NA
operations. ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_10.html [8/8/2545 13:04:52],NA
A good answer might be: ,NA,NA
See below. ,NA,NA
Ending the Loop,NA,NA
## x' = (1/2)(x + n/x),NA,NA
## $f0  ---  n ,NA,NA
## $f1  ---  1.0 ,NA,NA
## $f2  ---  2.0 ,NA,NA
## $f3  ---  x  : current approx.,NA,NA
## $f4  ---  x' : next approx.,NA,NA
## $f8  ---  temp ,NA,NA
## $f10 ---  small value,NA,NA
loop: ,NA,NA
" mov.s   $f4,$f0             #  x' = n",NA,NA
" div.s   $f4,$f4,$f3         #  x' = n/x",NA,NA
" add.s   $f4,$f3,$f4         #  x' = x + n/x",NA,NA
" div.s   $f3,$f4,$f2         #  x = (1/2)(x + n/x)",NA,NA
 # test if loop should end,NA,NA
After calculting a new approximation it is time to see if the loop should end. This is more ,NA,NA
work than the actual calculation. We can't test if we have the ,NA,NA
exact,NA,NA
" answer yet, because that ",NA,NA
may never happen. Instead let us test if the current ,NA,NA
x,NA,NA
 is close to the square root of ,NA,NA
n,NA,NA
QUESTION 11: ,NA,NA
Say that ,NA,NA
x,NA,NA
 is very close to ,NA,NA
n,NA,NA
0.5,NA,NA
. What do you think will be the value of ,NA,NA
n/(x*x),NA,NA
? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_11.html [8/8/2545 13:04:55],NA
Say that ,NA,NA
x,NA,NA
 is very close to ,NA,NA
n,NA,NA
0.5,NA,NA
. What do you think will be the value of ,NA,NA
n/(x*x),NA,NA
? ,NA,NA
A good answer might be: ,NA,NA
It should be very close to ,NA,NA
1.0,NA,NA
Ending Test,NA,NA
"But, due to the lack of precision with single precision, the best we can hope for is to ",NA,NA
calculate an ,NA,NA
x,NA,NA
 such that: ,NA,NA
0.999999 < n/x*x < 1.00001,NA,NA
The left and the right bound in the above have 6 decimal digits of precision. If 1.00000 is ,NA,NA
subtracted from this value the result is: ,NA,NA
-0.000001 < n/x*x - 1 < 0.00001,NA,NA
"To be safe, terminate the loop when: ",NA,NA
|n/x*x - 1|< 0.00001,NA,NA
... where ,NA,NA
|x|,NA,NA
 means the absolute value of ,NA,NA
x,NA,NA
. ,NA,NA
QUESTION 12:,NA,NA
Is there a floating point absolute value instruction? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_12.html [8/8/2545 13:04:57],NA
A good answer might be: ,NA,NA
Yes. ,NA,NA
Code for Ending Test,NA,NA
Here is the code for ending the loop when ,NA,NA
|n/x*x - 1|< 0.00001,NA,NA
. ,NA,NA
## $f0  ---  n ,NA,NA
## $f1  ---  1.0 ,NA,NA
## $f2  ---  2.0 ,NA,NA
## $f3  ---  x  : current approx.,NA,NA
## $f4  ---  x' : next approx.,NA,NA
## $f8  ---  temp ,NA,NA
## $f10 ---  small value,NA,NA
" mul.s   $f8,$f3,$f3         # x^2",NA,NA
" div.s   $f8,$f0,$f8         # n/x^2",NA,NA
" sub.s   $f8,$f8,$f1         # n/x^2 - 1.0",NA,NA
" abs.s   $f8,$f8             # |n/x^2 - 1.0|",NA,NA
" c.lt.s  $f8,$f10            # |x^2 - n| < small ?",NA,NA
 bc1t    done                # yes: done,NA,NA
 j       loop,NA,NA
done:,NA,NA
QUESTION 13:,NA,NA
Is this program commercial quality code? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_13.html [8/8/2545 13:05:04],NA
A good answer might be: ,NA,NA
Nowhere close. Numerical analysis is tricky. You should use a square root method from ,NA,NA
a package of mathematical subroutines if you really need one. ,NA,NA
Complete Program,NA,NA
But it is good enough for a demonstration on the SPIM simulator. Here is the complete ,NA,NA
"program. Copy it to your editor, save it to a file, and play with it in SPIM. ",NA,NA
## newton.asm -- compute sqrt(n) ,NA,NA
"## given an approximation x to sqrt(n), ",NA,NA
## an improved approximation is: ,NA,NA
## x' = (1/2)(x + n/x),NA,NA
## $f0  ---  n ,NA,NA
## $f1  ---  1.0 ,NA,NA
## $f2  ---  2.0 ,NA,NA
## $f3  ---  x  : current approx.,NA,NA
## $f4  ---  x' : next approx.,NA,NA
## $f8  ---  temp,NA,NA
 .text,NA,NA
 .globl main ,NA,NA
main: ,NA,NA
" l.s     $f0,n               # get n",NA,NA
" li.s    $f1,1.0             # constant 1.0",NA,NA
" li.s    $f2,2.0             # constant 2.0",NA,NA
" li.s    $f3,1.0             # x == first approx. li.s    ",NA,NA
"$f10,1.0e-5         # five figure accuracy",NA,NA
loop: ,NA,NA
" mov.s   $f4,$f0             # x' = n",NA,NA
" div.s   $f4,$f4,$f3         # x' = n/x",NA,NA
" add.s   $f4,$f3,$f4         # x' = x + n/x",NA,NA
" div.s   $f3,$f4,$f2         # x    = (1/2)(x + n/x)",NA,NA
" mul.s   $f8,$f3,$f3         # x^2",http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_14.html (1 of 2) [8/8/2545 13:05:11],NA
" div.s   $f8,$f0,$f8         # n/x^2",NA,NA
" sub.s   $f8,$f8,$f1         # n/x^2 - 1.0",NA,NA
" abs.s   $f8,$f8             # |n/x^2 - 1.0|",NA,NA
" c.lt.s  $f8,$f10            # |x^2 - n| < small ?",NA,NA
 bc1t    done                # yes: done,NA,NA
 j       loop                # next approximation,NA,NA
done:,NA,NA
" mov.s   $f12,$f3            # print the result ",NA,NA
"li      $v0,2",NA,NA
 syscall,NA,NA
 jr      $ra                 # return to OS,NA,NA
## ,NA,NA
##  Data Segment ,NA,NA
##,NA,NA
 .data ,NA,NA
n:      .float  3.0,NA,NA
## end of file,NA,NA
QUESTION 14:,NA,NA
What result do you expect if this program calculated the square root of ,NA,NA
4.000000e+6 ? ,http://chortle.ccsu.edu/AssemblyTutorial/Chapter-32/ass32_14.html (2 of 2) [8/8/2545 13:05:11],NA
What result do you expect if this program calculated the square root of 4.000000e+6 ? ,NA,NA
A good answer might be: ,NA,NA
You should expect 2.0000e+3 or so: five places of precision. ,NA,NA
End of the Chapter,NA,NA
"In fact, SPIM prints out a 25 digit answer. Most of the digits are meaningless. ",NA,NA
You have reached the end this chapter. You may wish to root among the following topics. ,NA,NA
Click on a subject that interests you to go to where it was discussed. ,G,NA
The floating point accelerator chip. ,G,NA
Floating point comparison instructions. ,G,NA
Floating point branch instructions.,G,NA
The condition bit.,G,NA
Newton's method.,NA,NA
