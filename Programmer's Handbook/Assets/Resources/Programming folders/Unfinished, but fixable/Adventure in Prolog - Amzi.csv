Larger Text,Smaller Text,Symbol
Adventure in Prolog,"9 Data Structures
  
 Contents
  
 Preface",NA
Contents ,"Preface
  
 Getting Started
  
 Where to Find a Prolog
  
 Preface
  
 Getting Started
  
 Where to Find a Prolog
  
 Exercises
  
 Jumping In
  
 Logic Programming
  
 10 Unification
  
 Jargon
  
 1 Getting Started
  
 Facts
  
 Jumping In
  
 Exercises
  
 Facts
  
 11 Lists
  
 Logic Programming
  
 Nani Search
  
 Jargon
  
 Using the List Utilities
  
 Exercises
  
 Simple Queries
  
 2 Facts
  
 Exercises
  
 Simple Queries
  
 Nani Search
  
 12 Operators
  
 How Queries Work
  
 Exercises
  
 Exercises
  
 Exercises
  
 Compound Queries
  
 3 Simple Queries
  
 13 Cut
  
 Compound Queries
  
 Built-in Predicates
  
 How Queries Work
  
 Using the Cut
  
 Exercises
  
 Exercises
  
 Rules
  
 4 Compound Queries
  
 Exercises
  
 Rules
  
 14 Control Structures
  
 How Rules Work
  
 Built-in Predicates
  
 Using Rules
  
 Recursive Control Loop
  
 Exercises
  
 Exercises
  
 Tail Recursion
  
 Arithmetic
  
 5 Rules
  
 Exercises
  
 Arithmetic
  
 How Rules Work
  
 15 Natural Language
  
 Exercises
  
 Using Rules
  
 Managing Data
  
 Exercises
  
 Difference Lists
  
 Natural Language Front 
  
 Managing Data
  
 Exercises
  
 6 Arithmetic
  
 End
  
 Exercises
  
 Definite Clause Grammar
  
 Recursion
  
 Reading Sentences
  
 Recursion
  
 Exercises
  
 7 Managing Data
  
 How Recursion Works
  
 http://www.amzi.com/AdventureInProlog/advfrtop.htm (1 of 2)11/3/2006 7:01:37 PM",NA
Adventure in Prolog,NA,NA
Contents ,NA,NA
Preface ,NA,NA
9 Data Structures ,NA,NA
Exercises ,NA,NA
Where to Find a Prolog ,NA,NA
10 Unification ,NA,NA
1 Getting Started ,NA,NA
Exercises ,NA,NA
Jumping In ,NA,NA
Logic Programming ,NA,NA
11 Lists ,NA,NA
Jargon ,NA,NA
Using the List Utilities ,NA,NA
Exercises ,NA,NA
2 Facts ,NA,NA
Nani Search ,NA,NA
12 Operators ,NA,NA
Exercises ,NA,NA
Exercises,NA,NA
3 Simple Queries ,NA,NA
13 Cut ,NA,NA
How Queries Work ,NA,NA
Using the Cut ,NA,NA
Exercises ,NA,NA
Exercises,NA,NA
4 Compound Queries ,NA,NA
14 Control Structures ,NA,NA
Built-in Predicates ,NA,NA
Recursive Control Loop ,NA,NA
Exercises ,NA,NA
Tail Recursion ,NA,NA
Exercises ,NA,NA
5 Rules ,NA,NA
How Rules Work ,NA,NA
15 Natural Language ,NA,NA
Using Rules ,NA,NA
Difference Lists ,NA,NA
Exercises ,NA,NA
Natural Language Front End ,NA,NA
Definite Clause Grammar ,NA,NA
Reading Sentences,NA,NA
6 Arithmetic ,NA,NA
Exercises,NA,NA
7 Managing Data ,NA,NA
Exercises,NA,NA
8 Recursion ,NA,NA
How Recursion Works ,NA,NA
Pragmatics ,NA,NA
Exercises,NA,NA
Exercises,NA,NA
Appendix ,NA,NA
Nani Search ,NA,NA
Family ,NA,NA
Custord ,NA,NA
Birds,NA,NA
Index ,NA,NA
Published by: ,NA,NA
Amzi! inc. ,NA,NA
5861 Greentree Road ,NA,NA
"Lebanon, OH 45036 U.S.A. ",NA,NA
phone +1-513-425-8050 ,NA,NA
fax +1-513-425-8025 ,NA,NA
e-mail ,NA,NA
info@amzi.com,NA,NA
web ,NA,NA
www.amzi.com,NA,NA
"Copyright ©1990,1996-1997, 2004 by Amzi! inc. All Rights Reserved. ",NA,NA
"This document (""Work"") is protected by copyright laws and international copyright treaties, as well as ",NA,NA
other intellectual property laws and treaties. You may use and distribute digital copies of this Work ,NA,NA
"provided each copy of the Work is a true and complete copy, including all copyright and trademark ",NA,NA
"notices, and each copy is accompanied by a copy of this notice. You may not distribute printed copies of ",NA,NA
this Work. You may not distribute copies of this Work for profit either on a standalone basis or included ,NA,NA
as part of your own product or work without written permission from Amzi! You may not charge any ,NA,NA
"fees, including ones for media or download. You may not include this Work as part of your own works. ",NA,NA
"You may not rename, edit or create any derivative works from this Work. Contact Amzi! for additional ",NA,NA
licensing arrangements. ,NA,NA
"Amzi! is a registered trademark and Logic Server, Active Prolog Tutor, Adventure in Prolog and the ",NA,NA
flying squirrel logo are trademarks of Amzi! inc. ,NA,NA
Last Updated: March 2004 ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",NA,NA
Preface,NA,NA
I was working for an aerospace company in the 1970s when someone got a copy of the original ,NA,NA
"Adventure game (a simulated world the player explores, at that time purely text-based, with natural ",NA,NA
"language) and installed it on our mainframe computer. For the next month my lunch hours, evenings and ",NA,NA
"weekends, as well as normal work hours, were consumed with fighting the fierce green dragon and ",NA,NA
"escaping from the twisty little passages. Finally, with a few hints about the plover's egg and dynamite, I ",NA,NA
had proudly earned all the points in the game. ,NA,NA
My elation turned to terror as I realized it was time for my performance review. My boss was a stern ,NA,NA
"man, who was more comfortable with machines than with people. He opened up a large computer ",NA,NA
printout containing a log of the hours each of his programmers spent on the mainframe computer. He ,NA,NA
said he noticed that recently I had been working evenings and weekends and that he admired that type of ,NA,NA
dedication in his employees. He gave me the maximum raise and told me to keep up the good work. ,NA,NA
"Ever since I've had a warm spot in my heart for adventure games. Years later, when I got my first home ",NA,NA
"computer, I immediately started to write my own adventure game in 'C'. First came the tools, a simple ",NA,NA
dynamic database to keep track of the game state and pattern matching functions to search that database. ,NA,NA
Then came a natural language parser for the front end. Functions implemented the various rules of the ,NA,NA
game. ,NA,NA
At around the same time I joined the Boston Computer Society and attended a lecture of the newly ,NA,NA
formed Artificial Intelligence group. The lecture was about Prolog. I was amazed--here was a language ,NA,NA
that included all of the tools needed for building adventure games and more. ,NA,NA
"It had a much richer dynamic database and more powerful pattern matcher than the one I had written, ",NA,NA
"plus its syntax was rules, which are much more natural for coding the specification of the game. It had a ",NA,NA
"built-in search engine and, to top it all off, had tools for natural language processing. ",NA,NA
I learned Prolog from the classic Clocksin and Mellish text and started writing adventure games anew. ,NA,NA
"I went on to use Prolog for a number of expert system applications at my then current job, including a ",NA,NA
mainframe database performance tuning system and installation expert. This got others interested in the ,NA,NA
language and I began teaching it as well. ,NA,NA
While the applications we were using Prolog for were serious and performed a key role in improving ,http://www.amzi.com/AdventureInProlog/apreface.htm (1 of 2)11/3/2006 7:04:32 PM,NA
"technical support for the growing company, I still found the adventure game to be an excellent showcase ",NA,NA
for teaching the language. ,NA,NA
"This book is the result of that work. It takes a pragmatic, rather than theoretical, approach to the ",NA,NA
language and is designed for programmers interested in adding this powerful language to their bag of ,NA,NA
tools. ,NA,NA
I offer my thanks to Will Crowther and Don Woods for writing the first (and in my opinion still the best) ,NA,NA
adventure game and to the Boston Computer Society for testing the ideas in the book. Thanks also to Ray ,NA,NA
"Reeves, who speaks fluent Prolog, and Nancy Wilson, who speaks fluent English, for their careful ",NA,NA
reading of the text. ,NA,NA
Dennis Merritt ,NA,NA
"Stow, Massachusetts, April 1996 ",NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/apreface.htm (2 of 2)11/3/2006 7:04:32 PM,NA
Where to Find a Prolog,NA,NA
Amzi! offers both free and commercial Prolog development tools. This tutorial text refers to the Amzi!® ,NA,NA
"Eclipse IDE. Amzi! runs under all forms of Windows, and many forms of Unix including Linux and ",NA,NA
Solaris. You can download a copy from our web site:,NA,NA
www.amzi.com,NA,NA
You can find other freely available Prolog tools for Windows and other plat-forms in the Prolog FAQ ,NA,NA
and on various Prolog and AI repositories. Our web site contains up-to-date pointers to these sites. ,NA,NA
You will also find numerous articles on our web site about:,G,NA
"Learning and using Prolog, ",G,NA
"Building expert systems, agents and intelligent components in Prolog, ",G,NA
"Embedding Prolog modules in C/C++, Java, Delphi, Visual Basic and other applications, ",G,NA
"Using intelligent components on the Internet, and ",G,NA
Many other topics,NA,NA
Our web site also contains pointers to:,G,NA
"Books, ",G,NA
"Prolog source code repositories, ",G,NA
"Papers and FAQs, ",G,NA
"Other Prolog, AI and expert systems sites, and ",G,NA
Newsgroups.,NA,NA
We invite you to visit!,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/aprolog.htm11/3/2006 7:04:57 PM,NA
1,NA,NA
Getting Started,"Prolog stands for PROgramming in LOGic. It was developed from a foundation of logical theorem proving and originally used 
 for research in natural language processing. Although its popularity has sprung up mainly in the artificial intelligence (AI) 
 community, where it has been used for applications such as expert systems, natural language, and intelligent databases, it is also 
 useful for more conventional types of applications. It allows for more rapid development and prototyping than most languages 
 because it is semantically close to the logical specification of a program. As such, it approaches the ideal of executable program 
 specifications. 
  
 Programming in Prolog is significantly different from conventional procedural programming and requires a readjustment in the 
 way one thinks about programming. Logical relationships are asserted, and Prolog is used to determine whether or not certain 
 statements are true, and if true, what variable bindings make them true. This leads to a very declarative style of programming.
  
 In fact, the term program does not accurately describe a Prolog collection of executable facts, rules and logical relationships, so 
 you will often see term 
 logicbase
  used in this book as well.
  
 While Prolog is a fascinating language from a purely theoretical viewpoint, this book will stress Prolog as a practical tool for 
 application development. 
  
 Much of the book will be built around the writing of a short adventure game. The adventure game is a good example since it 
 contains mundane programming constructs, symbolic reasoning, natural language, data, and logic. 
  
 Through exercises you will also build a simple expert system, an intelligent genealogical logicbase, and a mundane 
 customer order entry application. 
  
 You should create a source file for the game, and enter the examples from the book as you go. You should also create source 
 files for the other three programs covered in the exercises. Sample source code for each of the programs is included in the 
 appendix. 
  
 The adventure game is called Nani Search. Your persona as the adventurer is that of a three year old girl. The lost treasure with 
 magical powers is your nani (security blanket). The terrifying obstacle between you and success is a dark room. It is getting late 
 and you're tired, but you can't go to sleep without your nani. Your mission is to find the nani. 
  
 Nani Search is composed of 
  
 G
 A read and execute command loop 
  
 G
 A natural language input parser 
  
 G
 Dynamic facts/data describing the current environment 
  
 G
 Commands that manipulate the environment 
  
 G
 Puzzles that must be solved 
  
 You control the game by using simple English commands (at the angle bracket (>) prompt) expressing the action you wish to 
 take. You can go to other rooms, look at your surroundings, look in things, take things, drop things, eat things, inventory the 
 things you have, and turn things on and off.",NA
Jumping In ,"As with any language, the best way to learn Prolog is to use it. This book is designed to be used with a Prolog listener, and will 
 guide you through the building of four applications. 
  
 G
 Adventure game 
  
 G
 Intelligent genealogical logicbase 
  
 G
 Expert system 
  
 G
 Customer order entry business application 
  
 The adventure game will be covered in detail in the main body of the text, and the others you will build yourself based on the 
 exercises at the end of each chapter. 
  
 There will be two types of example code throughout the book. One is code, meant to be entered in a source file, and the other is 
 interactions with the listener. The listener interactions are distinguished by the presence of the question mark and dash (?-) 
 listener prompt. 
  
 Here is a two-line program, meant to help you learn the mechanics of the editor and your listener. 
  
 mortal(X) :- person(X). 
  
 person(socrates).
  
 In the Amzi! Eclipse IDE, first create a project for your source files. Select File | New | Project on the main menu, then click on 
 'Prolog' and 'Project', and enter the name of your project, 'adventure'. Next, create a new source file. Select File | New | File, and 
 enter the name of your file, 'mortal.pro'. Enter the pro-gram in the edit window, paying careful attention to upper and lowercase 
 letters and punctuation. Then select File | Save from the menu.
  
 Next, start the Prolog listener by selecting Run | Run As | Interpreted Project. Loading the source code in the Listener is called 
 consulting. You should see a message indicating that your source file, 'mortal.pro', was consulted. This message is followed by 
 the typical listener prompt.
  
 http://www.amzi.com/AdventureInProlog/a1start.htm (3 of 7)11/3/2006 7:05:02 PM",NA
Logic Programming ,"Let's look at the simple example in more detail. In classical logic we might say ""All people are mortal,"" or, rephrased for Prolog, 
 ""For all X, X is mortal if X is a person."" 
  
 mortal(X) :- person(X).
  
 Similarly, we can assert the simple fact that Socrates is a person. 
  
 person(socrates).
  
 http://www.amzi.com/AdventureInProlog/a1start.htm (4 of 7)11/3/2006 7:05:02 PM",NA
Jargon ,"With any field of knowledge, the critical concepts of the field are embedded in the definitions of its technical terms. Prolog is 
 no exception. When you understand terms such as 
 predicate
 , 
 clause
 , 
 backtracking
 , and 
 unification
  you will have a good 
 grasp of Prolog. This section defines the terms used to describe Prolog programs, such as predicate and clause. Execution-
 related terms, such as backtracking and unification will be introduced as needed throughout the rest of the text. 
  
 Prolog jargon is a mixture of programming terms, database terms, and logic terms. You have probably heard most of the terms 
 before, but in Prolog they don't necessarily mean what you think they mean. 
  
 In Prolog the normally clear distinction between data and procedure becomes blurred. This is evident in the vocabulary of 
 Prolog. Almost every concept in Prolog can be referred to by synonymous terms. One of the terms has a procedural flavor, and 
 the other a data flavor. 
  
 We can illustrate this at the highest level. A Prolog 
 program
  is a Prolog 
 logicbase
 . As we introduce the vocabulary of Prolog, 
 synonyms (from Prolog or other computer science areas) for a term will follow in parentheses. For example, at the highest level 
 we have a Prolog program (logicbase). 
  
 The Prolog program is composed of 
 predicates
  (procedures, record types, relations). Each is defined by its name and a number 
 called 
 arity
 . The arity is the fixed number of 
 arguments
  (attributes, fields) the predicate has. Two predicates with the same 
 name and different arity are considered to be different predicates. 
  
 http://www.amzi.com/AdventureInProlog/a1start.htm (6 of 7)11/3/2006 7:05:02 PM",NA
2,NA,NA
Facts,NA,NA
"This chapter describes the basic Prolog facts. They are the simplest form of Prolog predicates, and are ",NA,NA
similar to records in a relational database. As we will see in the next chapter they can be queried like ,NA,NA
database records. ,NA,NA
The syntax for a fact is ,NA,NA
"pred(arg1, arg2, ...  argN).",NA,NA
where ,NA,NA
pred ,NA,NA
The name of the predicate ,NA,NA
"arg1, ...",NA,NA
The arguments ,NA,NA
N ,NA,NA
The arity ,NA,NA
. ,NA,NA
The syntactic end of all Prolog clauses ,NA,NA
A predicate of arity 0 is simply ,NA,NA
pred.,NA,NA
The arguments can be any legal Prolog ,NA,NA
term,NA,NA
. The basic Prolog terms are ,NA,NA
integer ,NA,NA
A positive or negative number whose absolute value is less than some implementation-specific ,NA,NA
power of 2 ,NA,NA
atom ,NA,NA
A text constant beginning with a lowercase letter ,NA,NA
variable ,NA,NA
Begins with an uppercase letter or underscore (_) ,NA,NA
structure ,NA,NA
"Complex terms, which will be covered in chapter 9 ",NA,NA
"Various Prolog implementations enhance this basic list with other data types, such as floating point ",NA,NA
"numbers, or strings. ",NA,NA
The Prolog character set is made up of ,G,NA
"Uppercase letters, A-Z ",G,NA
"Lowercase letters, a-z ",G,NA
"Digits, 0-9 ",G,NA
"Symbols, + - * / \ ^ , . ~ : . ? @ # $ & ",NA,NA
Integers are made from digits. Other numerical types are allowed in some Prolog implementations. ,NA,NA
"Atoms are usually made from letters and digits with the first character being a lowercase letter, such as ",NA,NA
hello ,NA,NA
twoWordsTogethe,NA,NA
r ,NA,NA
x14,NA,NA
"For readability, the underscore (_), but not the hyphen (-), can be used as a separator in longer names. So ",NA,NA
the following are legal. ,NA,NA
a_long_atom_nam,NA,NA
e ,NA,NA
z_23,NA,NA
The following are not legal atoms. ,NA,NA
no-embedded-hyphens ,NA,NA
123nodigitsatbeginnin,NA,NA
g ,NA,NA
_nounderscorefirst ,NA,NA
Nocapsfirst,NA,NA
Use single quotes to make any character combination a legal atom as follows. ,NA,NA
'this-hyphen-is-ok' ,NA,NA
'UpperCase' ,NA,NA
'embedded blanks',NA,NA
"Do not use double quotes ("""") to build atoms. This is a special syntax that causes the character string to ",NA,NA
be treated as a list of ASCII character codes. ,NA,NA
"Atoms can also be legally made from symbols, as follows. ",NA,NA
--> ,NA,NA
++,NA,NA
"Variables are similar to atoms, but are distinguished by beginning with either an uppercase letter or the ",NA,NA
underscore (_). ,NA,NA
X ,NA,NA
Input_List ,NA,NA
_4th_argument ,NA,NA
Z56,NA,NA
"Using these building blocks, we can start to code facts. The predicate name follows the rules for atoms. ",NA,NA
The arguments can be any Prolog terms. ,NA,NA
"Facts are often used to store the data a program is using. For example, a business application might have ",NA,NA
customer/3. ,NA,NA
"customer('John Jones', boston, good_credit). ",NA,NA
"customer('Sally Smith', chicago, good_credit).",NA,NA
The single quotes are needed around the names because they begin with uppercase letters and because ,NA,NA
they have embedded blanks. ,NA,NA
Another example is a windowing system that uses facts to store data about the various windows. In this ,NA,NA
example the arguments give the window name and coordinates of the upper left and lower right corners. ,NA,NA
"window(main, 2, 2, 20, 72).",NA,NA
"window(errors, 15, 40, 20, 78).",NA,NA
A medical diagnostic expert system might have disease/2. ,NA,NA
"disease(plague, infectious).",NA,NA
"A Prolog listener provides the means for dynamically recording facts and rules in the logicbase, as well ",NA,NA
as the means to ,NA,NA
query,NA,NA
 (call) them. The logicbase is updated by 'consult'ing or 'reconsult'ing program ,NA,NA
"source. Predicates can also be typed directly into the listener, but they are not saved between sessions. ",http://www.amzi.com/AdventureInProlog/a2facts.htm (3 of 8)11/3/2006 7:05:05 PM,NA
Nani Search ,NA,NA
We will now begin to develop Nani Search by defining the basic facts that are meaningful for the game. ,NA,NA
These include ,G,NA
The rooms and their connections ,G,NA
The things and their locations ,G,NA
The properties of various things ,G,NA
Where the player is at the beginning of the game ,NA,NA
Figure 2.1. The rooms of Nani Search ,NA,NA
"Open a new source file and save it as 'myadven.pro', or whatever name you feel is appropriate. You will ",NA,NA
make your changes to the program in that source file. (A completed version of nanisrch.pro is in the ,NA,NA
"Prolog samples directory, samples/prolog/misc_one_file.) ",NA,NA
"First we define the rooms with the predicate room/1, which has five clauses, all of which are facts. They ",NA,NA
are based on the game map in figure 2.1. ,NA,NA
room(kitchen).,NA,NA
room(office).,NA,NA
room(hall).,NA,NA
room('dining room').,NA,NA
room(cellar).,NA,NA
We define the locations of things with a two-argument predicate location/2. The first argument will ,NA,NA
"mean the thing and the second will mean its location. To begin with, we will add the following things. ",NA,NA
"location(desk, office).",NA,NA
"location(apple, kitchen).",NA,NA
"location(flashlight, desk).",NA,NA
"location('washing machine', cellar). ",NA,NA
"location(nani, 'washing machine'). ",NA,NA
"location(broccoli, kitchen).",NA,NA
"location(crackers, kitchen).",NA,NA
"location(computer, office).",NA,NA
"The symbols we have chosen, such as kitchen and desk have meaning to us, but none to Prolog. The ",NA,NA
relationship between the arguments should also accurately reflect our meaning. ,NA,NA
"For example, the meaning we attach to location/2 is ""The first argument is located in the second ",NA,NA
"argument."" Fortunately Prolog considers location(sink, kitchen) and location(kitchen, sink) to be ",NA,NA
"different. Therefore, as long as we are consistent in our use of arguments, we can accurately represent ",NA,NA
our meaning and avoid the potentially ambiguous interpretation of the kitchen being in the sink. ,NA,NA
"We are not as lucky when we try to represent the connections between rooms. Let's start, however, with ",NA,NA
"door/2, which will contain facts such as ",NA,NA
"door(office, hall).",NA,NA
"We would like this to mean ""There is a connection from the office to the hall, or from the hall to the ",NA,NA
"office."" ",NA,NA
"Unfortunately, Prolog considers door(office, hall) to be different from door(hall, office). If we want to ",NA,NA
"accurately represent a two-way connection, we would have to define door/2 twice for each connection. ",NA,NA
"door(office, hall). ",NA,NA
"door(hall, office).",NA,NA
"The strictness about order serves our purpose well for location, but it creates this problem for ",NA,NA
"connections between rooms. If the office is connected to the hall, then we would like the reverse to be ",NA,NA
true as well. ,NA,NA
"For now, we will just add one-way doors to the program; we will address the symmetry problem again in ",NA,NA
the next chapter and resolve it in chapter 5. ,NA,NA
"door(office, hall).",NA,NA
"door(kitchen, office).",NA,NA
"door(hall, 'dining room').",NA,NA
"door(kitchen, cellar).",NA,NA
"door('dining room', kitchen).",NA,NA
Here are some other facts about properties of things the game player might try to eat. ,NA,NA
edible(apple).,NA,NA
edible(crackers).,NA,NA
tastes_yucky(broccoli).,NA,NA
"Finally we define the initial status of the flashlight, and the player's location at the beginning of the ",NA,NA
game. ,NA,NA
turned_off(flashlight).,NA,NA
here(kitchen).,NA,NA
We have now seen how to use basic facts to represent data in a Prolog program. ,NA,NA
Exercises ,NA,NA
During the course of completing the exercises you will develop three Prolog applications in addition to ,NA,NA
Nani Search. The exercises from each chapter will build on the work of previous chapters. Suggested ,NA,NA
"solutions to the exercises are contained in the Prolog source files listed in the appendix, and are also ",NA,NA
included in samples/prolog/misc_one_file. The files are ,NA,NA
gene ,NA,NA
A genealogical intelligent logicbase ,NA,NA
custord ,NA,NA
A customer order entry application ,NA,NA
birds ,NA,NA
An expert system that identifies birds ,NA,NA
"Not all applications will be covered in each chapter. For example, the expert system requires an ",NA,NA
understanding of rules and will not be started until the end of chapter 5. ,NA,NA
Genealogical Logicbase,NA,NA
1- First create a source file for the genealogical logicbase application. Start by adding a few members of ,NA,NA
"your family tree. It is important to be accurate, since we will be exploring family relationships. Your ",NA,NA
own knowledge of who your relatives are will verify the correctness of your Prolog programs. ,NA,NA
"Start by recording the gender of the individuals. Use two separate predicates, male/1 and female/1. For ",NA,NA
example,NA,NA
male(dennis).,http://www.amzi.com/AdventureInProlog/a2facts.htm (6 of 8)11/3/2006 7:05:05 PM,NA
male(michael).,NA,NA
female(diana).,NA,NA
"Remember, if you want to include uppercase characters or embedded blanks you must enclose the name ",NA,NA
in single (not double) quotes. For example ,NA,NA
male('Ghenghis Khan').,NA,NA
2- Enter a two-argument predicate that records the parent-child relationship. One argument represents ,NA,NA
"the parent, and the other the child. It doesn't matter in which order you enter the arguments, as long as ",NA,NA
"you are consistent. Often Prolog programmers adopt the convention that parent(A,B) is interpreted ""A is ",NA,NA
"the parent of B"". For example ",NA,NA
"parent(dennis, michael).",NA,NA
"parent(dennis, diana).",NA,NA
Customer Order Entry ,NA,NA
3- Create a source file for the customer order entry program. We will begin it with three record types ,NA,NA
(predicates). The first is customer/3 where the three arguments are ,NA,NA
arg1 ,NA,NA
arg2 ,NA,NA
arg3 ,NA,NA
Customer name ,NA,NA
City ,NA,NA
"Credit rating (aaa, bbb, etc) ",NA,NA
Add as many customers as you see fit. ,NA,NA
4- Next add clauses that define the items that are for sale. It should also have three arguments ,NA,NA
arg1 ,NA,NA
arg2 ,NA,NA
arg3 ,NA,NA
Item identification number ,NA,NA
Item name ,NA,NA
"The reorder point for inventory (when at or below this level, reorder) ",NA,NA
5- Next add an inventory record for each item. It has two arguments. ,http://www.amzi.com/AdventureInProlog/a2facts.htm (7 of 8)11/3/2006 7:05:05 PM,NA
arg1 ,NA,NA
arg2 ,NA,NA
Item identification number (same as in the item record) ,NA,NA
Amount in stock ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a2facts.htm (8 of 8)11/3/2006 7:05:05 PM,NA
3,NA,NA
Simple Queries,NA,NA
"Now that we have some facts in our Prolog program, we can consult the program in the listener and ",NA,NA
"query, or call, the facts. This chapter, and the next, will assume the Prolog program contains only facts. ",NA,NA
Queries against programs with rules will be covered in a later chapter. ,NA,NA
Prolog queries work by pattern matching. The query pattern is called a ,NA,NA
goal,NA,NA
. If there is a fact that ,NA,NA
"matches the goal, then the query succeeds and the listener responds with 'yes.' If there is no matching ",NA,NA
"fact, then the query fails and the listener responds with 'no.' ",NA,NA
Prolog's pattern matching is called ,NA,NA
unification,NA,NA
". In the case where the logicbase contains only facts, ",NA,NA
unification succeeds if the following three conditions hold. ,G,NA
The predicate named in the goal and logicbase are the same. ,G,NA
Both predicates have the same arity. ,G,NA
All of the arguments are the same. ,NA,NA
"Before proceeding, review figure 3.1, which has a listing of the program so far. ",NA,NA
"The first query we will look at asks if the office is a room in the game. To pose this, we would enter that ",NA,NA
goal followed by a period at the listener prompt. ,NA,NA
?- room(office).,NA,NA
yes,NA,NA
"Prolog will respond with a 'yes' if a match was found. If we wanted to know if the attic was a room, we ",NA,NA
would enter that goal. ,NA,NA
?- room(attic).,NA,NA
no,http://www.amzi.com/AdventureInProlog/a3simple.htm (1 of 10)11/3/2006 7:05:10 PM,NA
room(kitchen).,NA,NA
room(office).,NA,NA
room(hall).,NA,NA
room('dining room'). ,NA,NA
room(cellar).,NA,NA
"door(office, hall).",NA,NA
"door(kitchen, office).",NA,NA
"door(hall, 'dining room').",NA,NA
"door(kitchen, cellar).",NA,NA
"door('dining room', kitchen).",NA,NA
"location(desk, office).",NA,NA
"location(apple, kitchen).",NA,NA
"location(flashlight, desk).",NA,NA
"location('washing machine', cellar).",NA,NA
"location(nani, 'washing machine'). ",NA,NA
"location(broccoli, kitchen).",NA,NA
"location(crackers, kitchen).",NA,NA
"location(computer, office).",NA,NA
edible(apple).,NA,NA
edible(crackers).,NA,NA
tastes_yucky(broccoli).,NA,NA
here(kitchen).,NA,NA
Figure 3.1. The listing of Nani Search entered at this point ,NA,NA
"Prolog will respond with a 'no' if no match was found. Likewise, we can ask about the locations of ",NA,NA
things. ,NA,NA
"?- location(apple, kitchen).",NA,NA
yes,NA,NA
"?- location(kitchen, apple).",NA,NA
no,NA,NA
"Prolog responds to our location query patterns in a manner that makes sense to us. That is, the kitchen is ",NA,NA
not located in the apple. ,http://www.amzi.com/AdventureInProlog/a3simple.htm (2 of 10)11/3/2006 7:05:10 PM,NA
"However, here is the problem with the one-way doors, which we still haven't fixed. It is mentioned again ",NA,NA
to stress the importance of the order of the arguments. ,NA,NA
"?- door(office, hall). ",NA,NA
yes,NA,NA
"?- door(hall, office). ",NA,NA
no,NA,NA
Goals can be generalized by the use of Prolog variables. They do not behave like the variables in other ,NA,NA
"languages, and are better called logical variables (although Prolog does not precisely correspond to ",NA,NA
logic). The logical variables replace one or more of the arguments in the goal. ,NA,NA
"Logical variables add a new dimension to unification. As before, the predicate names and arity must be ",NA,NA
"the same for unification to succeed. However, when the corresponding arguments are compared, a ",NA,NA
variable will successfully match any term. ,NA,NA
"After successful unification, the logical variable takes on the value of the term it was matched with. This ",NA,NA
is called ,NA,NA
binding,NA,NA
 the variable. When a goal with a variable successfully unifies with a fact in the ,NA,NA
"logicbase, Prolog returns the value of the newly bound variable. ",NA,NA
"Since there may be more than one value a variable can be bound to and still satisfy the goal, Prolog ",NA,NA
provides the means for you to ask for alternate values. After an answer you can enter a semicolon (;). It ,NA,NA
causes Prolog to look for alternative bindings for the variables. Entering anything else at the prompt ,NA,NA
ends the query. ,NA,NA
"For example, we can use a logical variable to find all of the rooms. ",NA,NA
?- room(X).,NA,NA
X = kitchen ; ,NA,NA
X = office ; ,NA,NA
X = hall ; ,NA,NA
X = 'dining room' ; ,NA,NA
X = cellar ; ,NA,NA
no,NA,NA
The last 'no' means there are no more answers. ,NA,NA
"Here's how to find all the things in the kitchen. (Remember, variables begin with uppercase letters.) ",NA,NA
"?- location(Thing, kitchen).",http://www.amzi.com/AdventureInProlog/a3simple.htm (3 of 10)11/3/2006 7:05:10 PM,NA
Thing = apple ; ,NA,NA
Thing = broccoli ; ,NA,NA
Thing = crackers ; ,NA,NA
no,NA,NA
We can use two variables to see everything in every place. ,NA,NA
"?- location(Thing, Place).",NA,NA
Thing = desk ,NA,NA
Place = office ;,NA,NA
Thing = apple ,NA,NA
Place = kitchen ;,NA,NA
Thing = flashlight ,NA,NA
Place = desk ;,NA,NA
... ,NA,NA
no,NA,NA
Other applications might have the following queries. ,NA,NA
"What customers live in Boston, and what is their credit rating? ",NA,NA
"?- customer(X, boston, Y).",NA,NA
What is the title of chapter 2? ,NA,NA
"?- chapter(2,Title).",NA,NA
What are the coordinates of window main? ,NA,NA
"?- window(main,Row1,Col1,Row2,Col2).",NA,NA
How Queries Work ,NA,NA
"When Prolog tries to satisfy a goal about a predicate, such as location/2, it searches through the clauses ",NA,NA
"defining location/2. When it finds a match for its variables, it marks the particular clause that was used ",NA,NA
"to satisfy the goal. Then, if the user asks for more answers, it resumes its search of the clauses at that ",NA,NA
place marker. ,http://www.amzi.com/AdventureInProlog/a3simple.htm (4 of 10)11/3/2006 7:05:10 PM,NA
"Referring to the list of clauses in figure 3.1, let's look closer at this process with the query location(X, ",NA,NA
"kitchen). First, unification is attempted between the query pattern and the first clause of location/2. ",NA,NA
Pattern                           Clause #1 ,NA,NA
"location(X, kitchen)              location(desk, office) ",NA,NA
"This unification fails. The predicate names are the same, the number of arguments is the same, but the ",NA,NA
"second argument in the pattern, kitchen, is different from the second argument in the clause, office. ",NA,NA
"Next, unification is attempted between the pattern and the second clause of location/2. ",NA,NA
Pattern                           Clause #2 ,NA,NA
"location(X, kitchen)              location(apple, kitchen) ",NA,NA
"This unification succeeds. The predicate names, arity (number of arguments), and second arguments are ",NA,NA
the same. The first arguments can be made the same if the variable X in the pattern takes the value ,NA,NA
'apple.' ,NA,NA
"Now that unification succeeds, the Prolog listener reports its success, and the binding of the variable X. ",NA,NA
"?- location(X, kitchen).",NA,NA
X = apple,NA,NA
"If the user presses a key other than the semicolon (;) at this point, the listener responds with 'yes' ",NA,NA
indicating the query ended successfully. ,NA,NA
"If the user presses the semicolon (;) key, the listener looks for other solutions. First it unbinds the ",NA,NA
variable X. Next it resumes the search using the clause following the one that had just satisfied the ,NA,NA
query. This is called ,NA,NA
backtracking,NA,NA
. In the example that would be the third clause. ,NA,NA
Pattern                           Clause #3 ,NA,NA
"location(X, kitchen)              location(flashlight, desk) ",NA,NA
"This fails, and the search continues. Eventually the sixth clause succeeds. ",NA,NA
Pattern                           Clause #6 ,NA,NA
"location(X, kitchen)              location(broccoli, kitchen) ",http://www.amzi.com/AdventureInProlog/a3simple.htm (5 of 10)11/3/2006 7:05:10 PM,NA
"As a result, the variable X is now rebound to broccoli, and the listener responds ",NA,NA
X = broccoli ;,NA,NA
"Again, entering a semicolon (;) causes X to be unbound and the search to continue with the seventh ",NA,NA
"clause, which also succeeds. ",NA,NA
X = crackers ;,NA,NA
"As before, entering anything except a semicolon (;) causes the listener to respond 'yes,' indicating ",NA,NA
"success. A semicolon (;) causes the unbinding of X and the search to continue. But now, there are no ",NA,NA
"more clauses that successfully unify with the pattern, so the listener responds with 'no' indicating the ",NA,NA
final attempt has failed. ,NA,NA
no ,NA,NA
The best way to understand Prolog execution is to trace its execution in the debugger. But first it is ,NA,NA
necessary to have a deeper understanding of goals. ,NA,NA
A Prolog goal has four ,NA,NA
ports,NA,NA
" representing the flow of control through the goal: call, exit, redo, and fail. ",NA,NA
"First the goal is called. If successful it is exited. If not it fails. If the goal is retried, by entering a ",NA,NA
semicolon (;) the redo port is entered. Figure 3.2 shows the goal and its ports.,NA,NA
Figure 3.2. The ports of a Prolog goal ,NA,NA
The behaviors at each port are ,NA,NA
call ,NA,NA
exit,NA,NA
redo ,NA,NA
fail ,NA,NA
Begins searching for clauses that unify with the goal ,NA,NA
"Indicates the goal is satisfied, sets a place marker at the clause and binds the variables ",NA,NA
appropriately ,NA,NA
"Retries the goal, unbinds the variables and resumes search at the place marker ",http://www.amzi.com/AdventureInProlog/a3simple.htm (6 of 10)11/3/2006 7:05:10 PM,NA
Indicates no more clauses match the goal ,NA,NA
Prolog debuggers use these ports to describe the state of a query. Figure 3.3 shows a trace of the location ,NA,NA
"(X, kitchen) query. Study it carefully because it is the key to your understanding of Prolog. The number ",NA,NA
in parentheses indicates the current clause.,NA,NA
"?- location(X, kitchen).",NA,NA
"CALL: - location(X, kitchen) ",NA,NA
"EXIT:(2) location(apple, kitchen) X ",NA,NA
= apple ; ,NA,NA
"REDO: location(X, kitchen) ",NA,NA
"EXIT:(6) location(broccoli, kitchen) ",NA,NA
X = broccoli ; ,NA,NA
"REDO: location(X, kitchen) ",NA,NA
"EXIT:(7) location(crackers, kitchen) ",NA,NA
X = crackers ; ,NA,NA
"FAIL - location(X, kitchen)",NA,NA
 no,NA,NA
"Figure 3.3. Prolog trace of location(X, kitchen) ",NA,NA
"Because the trace information presented in this book is designed to teach Prolog rather than debug it, the ",NA,NA
format is a little different from that used in the actual debugger. Run the Amzi! Source Code Debugger ,NA,NA
on these queries to see how they work for real.,NA,NA
"To start the Amzi! Debugger, highlight your project name or edit a source file in your project, then ",NA,NA
select Run | Debug As | Interpreted Project from the main menu.,NA,NA
You will see a separate perspective with multiple views that contain trace information. Enter the query ,NA,NA
"'location(X, kitchen)' in the Debug Listener view. You will see the trace start in the debugger view. ",NA,NA
Use the 'Step Over' button in the debugger to creep from port to port. When output appears in the listener ,NA,NA
"view, enter semicolons (;) to continue the search. See the help files for more details on the debugger.",NA,NA
Unification between goals and facts is actually more general than has been presented. Variables can also ,NA,NA
occur in the facts of the Prolog logicbase as well. ,NA,NA
"For example, the following fact could be added to the Prolog program. It might mean everyone sleeps. ",NA,NA
sleeps(X).,http://www.amzi.com/AdventureInProlog/a3simple.htm (7 of 10)11/3/2006 7:05:10 PM,NA
"You can add it directly in the listener, to experiment with, like this. ",NA,NA
?- assert(sleeps(X)).,NA,NA
yes,NA,NA
Queries against a logicbase with this fact give the following results. ,NA,NA
?- sleeps(jane).,NA,NA
yes,NA,NA
?- sleeps(tom).,NA,NA
yes,NA,NA
Notice that the listener does not return the variable bindings of 'X=jane' and 'X=tom.' While they are ,NA,NA
"surely bound that way, the listener only lists variables mentioned in the query, not those used in the ",NA,NA
program. ,NA,NA
Prolog can also bind variables to variables. ,NA,NA
?- sleeps(Z).,NA,NA
Z = H116,NA,NA
?- sleeps(X).,NA,NA
X = H247,NA,NA
"When two unbound variables match, they are both bound, but not to a value! They are bound together, so ",NA,NA
"that if either one takes a value, the other takes the same value. This is usually implemented by binding ",NA,NA
"both variables to a common internal variable. In the first query above, both Z in the query and X in the ",NA,NA
fact are bound to internal variable 'H116.' In this way Prolog remembers they have the same value. If ,NA,NA
"either one is bound to a value later on, both automatically bind to that value. This feature of Prolog ",NA,NA
"distinguishes it from other languages and, as we will discover later, gives Prolog much of its power. ",NA,NA
"The two queries above are the same, even though one uses the same character X that is used in the fact ",NA,NA
sleeps(X). The variable in the fact is considered different from the one in the query. ,NA,NA
Exercises ,NA,NA
The exercise sections will often contain nonsense Prolog questions. These are queries against a ,NA,NA
meaningless logicbase to strengthen your understanding of Prolog without the benefit of meaningful ,NA,NA
semantics. You are to predict the answers to the query and then try them in Prolog to see if you are ,NA,NA
"correct. If you are not, trace the queries to better understand them. ",NA,NA
Nonsense Prolog,NA,NA
1- Consider the following Prolog logicbase ,NA,NA
easy(1),NA,NA
. ,NA,NA
easy(2),NA,NA
. ,NA,NA
easy(3),NA,NA
.,NA,NA
"gizmo(a,1)",NA,NA
. ,NA,NA
"gizmo(b,3)",NA,NA
. ,NA,NA
"gizmo(a,2)",NA,NA
. ,NA,NA
"gizmo(d,5)",NA,NA
. ,NA,NA
"gizmo(c,3)",NA,NA
. ,NA,NA
"gizmo(a,3)",NA,NA
. ,NA,NA
"gizmo(c,4)",NA,NA
.,NA,NA
"and predict the answers to the queries below, including all alternatives when the semicolon (;) is entered ",NA,NA
after an answer. ,NA,NA
?- easy(2). ,NA,NA
?- easy(X).,NA,NA
?- ,NA,NA
"gizmo(a,X). ",NA,NA
?- ,NA,NA
"gizmo(X,3). ",NA,NA
?- ,NA,NA
"gizmo(d,Y). ",NA,NA
?- ,NA,NA
"gizmo(X,X).",NA,NA
"2- Consider this logicbase, ",NA,NA
"harder(a,1)",NA,NA
. ,NA,NA
"harder(c,X)",NA,NA
. ,NA,NA
"harder(b,4)",NA,NA
. ,NA,NA
"harder(d,2)",NA,NA
.,NA,NA
and predict the answers to these queries. ,NA,NA
?- ,NA,NA
"harder(a,X). ",NA,NA
?- ,NA,NA
"harder(c,X). ",NA,NA
?- ,NA,NA
"harder(X,1). ",NA,NA
?- ,NA,NA
"harder(X,4).",http://www.amzi.com/AdventureInProlog/a3simple.htm (9 of 10)11/3/2006 7:05:10 PM,NA
Adventure Game,NA,NA
3- Enter the listener and reproduce some of the example queries you have seen against location/2. List or ,NA,NA
print location/2 for reference if you need it. Remember to respond with a semicolon (;) for multiple ,NA,NA
answers. Trace the query. ,NA,NA
Genealogical Logicbase,NA,NA
4- Pose queries against the genealogical logicbase that: ,G,NA
"Confirm a parent relationship such as parent(dennis, diana) ",G,NA
"Find someone's parent such as parent(X, diana) ",G,NA
"Find someone's children such as parent(dennis, X) ",G,NA
"List all parent-children such as parent(X,Y) ",NA,NA
"5- If parent/2 seems to be working, you can add additional family members to get a larger logicbase. ",NA,NA
Remember to include the corresponding male/1 or female/1 predicate for each individual added. ,NA,NA
Customer Order Entry,NA,NA
6- Pose queries against the customer order entry logicbase that ,G,NA
find customers in a given city ,G,NA
find customers with a given credit rating ,G,NA
confirm a given customer's credit rating ,G,NA
find the customers in a given city with a given credit rating ,G,NA
find the reorder quantity for a given item ,G,NA
find the item number for a given item name ,G,NA
find the inventory level for a given item number ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a3simple.htm (10 of 10)11/3/2006 7:05:10 PM,NA
4,NA,NA
Compound Queries,"Simple goals can be combined to form compound queries. For example, we might want to know if there is anything good 
 to eat in the kitchen. In Prolog we might ask 
  
 ?- location(X, kitchen), edible(X).
  
 Whereas a simple query had a single goal, the compound query has a conjunction of goals. The comma separating the 
 goals is read as ""and."" 
  
 Logically (declaratively) the example means ""Is there an X such that X is located in the kitchen and X is edible?"" If the 
 same variable name appears more than once in a query, it must have the same value in all places it appears. The query in 
 the above example will only succeed if there is a single value of X that can satisfy both goals. 
  
 However, the variable name has no significance to any other query, or clause in the logicbase. If X appears in other queries 
 or clauses, that query or clause gets its own copy of the variable. We say the 
 scope
  of a logical variable is a query. 
  
 Trying the sample query we get 
  
 ?- location(X, kitchen), edible(X).
  
 X = apple ;
  
 X = crackers ;
  
 no
  
 The 'broccoli' does not show up as an answer because we did not include it in the edible/1 predicate. 
  
 This logical query can also be interpreted procedurally, using an understanding of Prolog's execution strategy. The 
 procedural interpretation is: ""First find an X located in the kitchen, and then test to see if it is edible. If it is not, go back 
 and find another X in the kitchen and test it. Repeat until successful, or until there are no more Xs in the kitchen."" 
  
 To understand the execution of a compound query, think of the goals as being arranged from left to right. Also think of a 
 separate table which is kept for the current variable bindings. The flow of control moves back and forth through the goals 
 as Prolog attempts to find variable bindings that satisfy the query. 
  
 Each goal can be entered from either the left or the right, and can be left from either the left or the right. These are the ports 
 of the goal as seen in the last chapter. 
  
 A compound query begins by calling the first goal on the left. If it succeeds, the next goal is called with the variable 
 bindings as set from the previous goal. If the query finishes via the exit port of the rightmost goal, it succeeds, and the 
 listener prints the values in the variable table. 
  
 http://www.amzi.com/AdventureInProlog/a4comqry.htm (1 of 9)11/3/2006 7:05:16 PM",NA
Built-in Predicates ,http://www.amzi.com/AdventureInProlog/a4comqry.htm (4 of 9)11/3/2006 7:05:16 PM,NA
Exercises ,"Nonsense Prolog
  
 1- Consider the following Prolog logicbase. 
  
 easy(1)
 . 
  
 easy(2)
 . 
  
 easy(3)
 .
  
 gizmo(a,1)
 . 
  
 gizmo(b,3)
 . 
  
 gizmo(a,2)
 . 
  
 gizmo(d,5)
 . 
  
 gizmo(c,3)
 . 
  
 gizmo(a,3)
 . 
  
 gizmo(c,4)
 .
  
 harder(a,1)
 . 
  
 harder(c,X)
 . 
  
 harder(b,4)
 . 
  
 harder(d,2)
 .
  
 Predict the results of the following queries. Then try them and trace them to see if you were correct. 
  
 ?- 
 gizmo(a,X),easy(X). 
  
 ?- 
 gizmo(c,X),easy(X). 
  
 ?- 
 gizmo(d,Z),easy(Z).
  
 ?- easy(Y),gizmo(X,Y).",NA
5,NA,NA
Rules,NA,NA
"We said earlier a predicate is defined by clauses, which may be facts or rules. A rule is no more than a ",NA,NA
stored query. Its syntax is ,NA,NA
head :- body.,NA,NA
where ,NA,NA
head ,NA,NA
:- ,NA,NA
body ,NA,NA
a predicate definition (just like a fact) the ,NA,NA
neck,NA,NA
" symbol, sometimes read as ""if"" one ",NA,NA
or more goals (a query) ,NA,NA
"For example, the compound query that finds out where the good things to eat are can be stored as a rule ",NA,NA
with the predicate name where_food/2. ,NA,NA
"where_food(X,Y) :- ",NA,NA
" location(X,Y),",NA,NA
 edible(X).,NA,NA
"It states ""There is something X to eat in room Y if X is located in Y, and X is edible."" ",NA,NA
"We can now use the new rule directly in a query to find things to eat in a room. As before, the semicolon ",NA,NA
(;) after an answer is used to find all the answers. ,NA,NA
"?- where_food(X, kitchen).",NA,NA
X = apple ; ,NA,NA
X = crackers ; ,NA,NA
no,http://www.amzi.com/AdventureInProlog/a5rules.htm (1 of 14)11/3/2006 7:05:20 PM,NA
"?- where_food(Thing, 'dining room'). ",NA,NA
no,NA,NA
Or it can check on specific things. ,NA,NA
"?- where_food(apple, kitchen). ",NA,NA
yes,NA,NA
Or it can tell us everything. ,NA,NA
"?- where_food(Thing, Room).",NA,NA
Thing = apple ,NA,NA
Room = kitchen ,NA,NA
;,NA,NA
Thing ,NA,NA
= ,NA,NA
crackers ,NA,NA
Room = kitchen ,NA,NA
; ,NA,NA
no,NA,NA
"Just as we had multiple facts defining a predicate, we can have multiple rules for a predicate. For ",NA,NA
"example, we might want to have the broccoli included in where_food/2. (Prolog doesn't have an opinion ",NA,NA
on whether or not broccoli is legitimate food. It just matches patterns.) To do this we add another ,NA,NA
where_food/2 clause for things that 'taste_yucky.' ,NA,NA
"where_food(X,Y) :-",NA,NA
" location(X,Y),",NA,NA
 edible(X).,NA,NA
"where_food(X,Y) :-",NA,NA
" location(X,Y),",NA,NA
 tastes_yucky(X).,NA,NA
Now the broccoli shows up when we use the semicolon (;) to ask for everything. ,NA,NA
"?- where_food(X, kitchen).",NA,NA
X = apple ; ,NA,NA
X = crackers ; ,NA,NA
X = broccoli ; ,NA,NA
no,NA,NA
"Until this point, when we have seen Prolog try to satisfy goals by searching the clauses of a predicate, all ",NA,NA
of the clauses have been facts. ,NA,NA
How Rules Work ,http://www.amzi.com/AdventureInProlog/a5rules.htm (2 of 14)11/3/2006 7:05:20 PM,NA
"With rules, Prolog unifies the goal pattern with the head of the clause. If unification succeeds, then ",NA,NA
Prolog initiates a new query using the goals in the body of the clause. ,NA,NA
"Rules, in effect, give us multiple levels of queries. The first level is composed of the original goals. The ",NA,NA
next level is a new query composed of goals found in the body of a clause from the first level. ,NA,NA
"Each level can create even deeper levels. Theoretically, this could continue forever. In practice it can ",NA,NA
continue until the listener runs out of space. ,NA,NA
Figure 5.1 shows the control flow after the head of a rule has been matched. Notice how backtracking ,NA,NA
from the third goal of the first level now goes into the second level. ,NA,NA
Figure 5.1. Control flow with rules ,NA,NA
"In this example, the middle goal on the first level succeeds or fails if its body succeeds or fails. When ",NA,NA
"entered from the right (redo) the goal reenters its body query from the right (redo). When the query fails, ",NA,NA
"the next clause of the first-level goal is tried, and if the next clause is also a rule, the process is repeated ",NA,NA
with the second clause's body. ,NA,NA
"As always with Prolog, these relationships become clearer by studying a trace. Figure 5.2 contains the ",NA,NA
annotated trace of the where_food/2 query. Notice the appearance of a two-part number. The first part of ,NA,NA
"the number indicates the query level. The second part indicates the number of the goal within the query, ",NA,NA
as before. The parenthetical number is the clause number. For example ,NA,NA
"2-1 EXIT (7) location(crackers, kitchen)",NA,NA
"means the exit occurred at the second level, first goal using clause number seven. ",http://www.amzi.com/AdventureInProlog/a5rules.htm (3 of 14)11/3/2006 7:05:20 PM,NA
The query is ,NA,NA
"?- where_food(X, kitchen).",NA,NA
First the clauses of where_food/2 are searched.,NA,NA
"1-1 CALL where_food(X, kitchen)",NA,NA
"The pattern matches the head of the first clause, and while it is not at a port, the trace could inform us ",NA,NA
of the clause it is working on.,NA,NA
"1-1 try (1) where_food(X, kitchen)",NA,NA
"The body of the first clause is then set up as a query, and the trace continues.",NA,NA
" 2-1 CALL location(X, kitchen)",NA,NA
From this point the trace proceeds exactly as it did for the compound query in the previous chapter.,NA,NA
" 2-1 EXIT (2) location(apple, kitchen) ",NA,NA
2-2 CALL edible(apple),NA,NA
 2-2 EXIT (1) edible(apple),NA,NA
"Since the body has succeeded, the goal from the previous (first) level succeeds.",NA,NA
"1-1 EXIT (1) where_food(apple, kitchen)",NA,NA
 X = apple ;,NA,NA
"Backtracking goes from the first-level goal, into the second level, proceeding as before.",NA,NA
"1-1 REDO where_food(X, kitchen)",NA,NA
 2-2 REDO edible(apple),NA,NA
 2-2 FAIL edible(apple),NA,NA
" 2-1 REDO location(X, kitchen)",NA,NA
" 2-1 EXIT (6) location(broccoli, kitchen) ",NA,NA
2-2 CALL edible(broccoli),NA,NA
 2-2 FAIL edible(broccoli),NA,NA
" 2-1 REDO location(X, kitchen)",NA,NA
" 2-1 EXIT (7) location(crackers, kitchen) ",NA,NA
2-2 CALL edible(crackers),NA,NA
 2-2 EXIT (2) edible(crackers),http://www.amzi.com/AdventureInProlog/a5rules.htm (4 of 14)11/3/2006 7:05:20 PM,NA
"1-1 EXIT (1) where_food(crackers, kitchen)",NA,NA
 ,NA,NA
X = crackers ;,NA,NA
"Now any attempt to backtrack into the query will result in no more answers, and the query will fail.",NA,NA
 2-2 REDO edible(crackers),NA,NA
 2-2 FAIL edible(crackers),NA,NA
" 2-1 REDO location(X, kitchen)",NA,NA
" 2-1 FAIL location(X, kitchen)",NA,NA
This causes the listener to look for other clauses whose heads match the query pattern. In our ,NA,NA
"example, the second clause of where_food/2 also matches the query pattern.",NA,NA
"1-1 REDO where_food(X, kitchen)",NA,NA
"Again, although traces usually don't tell us so, it is building a query from the body of the second ",NA,NA
clause.,NA,NA
"1-1 try (2) where_food(X, kitchen)",NA,NA
"Now the second query proceeds as normal, finding the broccoli, which tastes_yucky.",NA,NA
" 2-1 CALL location(X, kitchen)",NA,NA
" 2-1 EXIT (2) location(apple, kitchen)",NA,NA
 2-,NA,NA
2 CALL tastes_yucky(apple),NA,NA
 2-2 FAIL tastes_yucky(apple),NA,NA
" 2-1 REDO location(X, kitchen)",NA,NA
" 2-1 EXIT (6) location(broccoli, kitchen)",NA,NA
 2-2 CALL tastes_yucky(broccoli),NA,NA
 2-2 EXIT (1) tastes_yucky(broccoli) ,NA,NA
"1-1 EXIT (2) where_food(broccoli, kitchen)",NA,NA
 X = broccoli ;,NA,NA
"Backtracking brings us to the ultimate no, as there are no more where_food/2 clauses to try.",NA,NA
 2-2 REDO tastes_yucky(broccoli),NA,NA
 2-2 FAIL tastes_yucky(broccoli),NA,NA
" 2-1 REDO location(X,kitchen)",NA,NA
" 2-1 EXIT (7) location(crackers, kitchen) ",NA,NA
2-2 CALL tastes_yucky(crackers),NA,NA
 2-2 FAIL tastes_yucky(crackers),NA,NA
" 2-2 REDO location(X, kitchen)",http://www.amzi.com/AdventureInProlog/a5rules.htm (5 of 14)11/3/2006 7:05:20 PM,NA
" 2-2 FAIL location(X, kitchen) ",NA,NA
"1-1 REDO where_food(X, kitchen) ",NA,NA
"1-1 FAIL where_food(X, kitchen)",NA,NA
 no,NA,NA
Figure 5.2. Trace of a query with rules ,NA,NA
It is important to understand the relationship between the first-level and second-level variables in this ,NA,NA
"query. These are independent variables, that is, the X in the query is not the same as the X that shows up ",NA,NA
"in the body of the where_food/2 clauses, values for both happen to be equal due to unification. ",NA,NA
"To better understand the relationship, we will slowly step through the process of transferring control. ",NA,NA
Subscripts identify the variable levels. ,NA,NA
The goal in the query is ,NA,NA
"?- where_food(X1, kitchen)",NA,NA
The head of the first clause is ,NA,NA
"where_food(X2, Y2)",NA,NA
Remember the 'sleeps' example in chapter 3 where a query with a variable was unified with a fact with a ,NA,NA
variable? Both variables were set to be equal to each other. This is exactly what happens here. This might ,NA,NA
be implemented by setting both variables to a common internal variable. If either one takes on a new ,NA,NA
"value, both take on a new value. ",NA,NA
"So, after unification between the goal and the head, the variable bindings are ",NA,NA
X1 = _01,NA,NA
X2 = _01,NA,NA
Y2 = kitchen,NA,NA
"The second-level query is built from the body of the clause, using these bindings. ",NA,NA
"location(_01, kitchen), edible(_01).",NA,NA
"When internal variable _01 takes on a value, such as 'apple,' both X's then take on the same value. This ",NA,NA
is fundamentally different from the assignment statements that set variable values in most computer ,NA,NA
languages. ,NA,NA
Using Rules ,NA,NA
"Using rules, we can solve the problem of the one-way doors. We can define a new two-way predicate ",NA,NA
"with two clauses, called connect/2. ",NA,NA
"connect(X,Y) :- door(X,Y). ",NA,NA
"connect(X,Y) :- door(Y,X).",NA,NA
"It says ""Room X is connected to a room Y if there is a door from X to Y, or if there is a door from Y to ",NA,NA
"X."" Note the implied 'or' between clauses. Now connect/2 behaves the way we would like. ",NA,NA
"?- connect(kitchen, office). ",NA,NA
yes,NA,NA
"?- connect(office, kitchen). ",NA,NA
yes,NA,NA
We can list all the connections (which is twice the number of doors) with a general query. ,NA,NA
"?- connect(X,Y). ",NA,NA
X = office ,NA,NA
Y = hall ;,NA,NA
X = kitchen ,NA,NA
Y = office ; ,NA,NA
...,NA,NA
X = hall ,NA,NA
Y = office ;,NA,NA
X = office ,NA,NA
Y = kitchen ; ,NA,NA
...,NA,NA
With our current understanding of rules and built-in predicates we can now add more rules to Nani ,NA,NA
"Search. We will start with look/0, which will tell the game player where he or she is, what things are in ",NA,NA
"the room, and which rooms are adjacent. ",NA,NA
"To begin with, we will write list_things/1, which lists the things in a room. It uses the technique ",NA,NA
developed at the end of chapter 4 to loop through all the pertinent facts. ,NA,NA
list_things(Place) :- ,http://www.amzi.com/AdventureInProlog/a5rules.htm (7 of 14)11/3/2006 7:05:20 PM,NA
" location(X, Place),",NA,NA
" tab(2),",NA,NA
" write(X),",NA,NA
" nl,",NA,NA
 fail.,NA,NA
We use it like this. ,NA,NA
?- list_things(kitchen).,NA,NA
 apple,NA,NA
 broccoli,NA,NA
 crackers ,NA,NA
no,NA,NA
"There is one small problem with list_things/1. It gives us the list, but it always fails. This is all right if ",NA,NA
"we call it by itself, but we won't be able to use it in conjunction with other rules that follow it (to the ",NA,NA
right as illustrated in our diagrams). We can fix this problem by adding a second list_things/1 clause ,NA,NA
which always succeeds. ,NA,NA
list_things(Place) :-,NA,NA
" location(X, Place),",NA,NA
" tab(2),",NA,NA
" write(X),",NA,NA
" nl,",NA,NA
 fail.,NA,NA
list_things(AnyPlace).,NA,NA
Now when the first clause fails (because there are no more location/2s to try) the second list_things/1 ,NA,NA
"clause will be tried. Since its argument is a variable it will successfully match with anything, causing ",NA,NA
list_things/1 to always succeed and leave through the 'exit' port. ,NA,NA
"As with the second clause of list_things/1, it is often the case that we do not care what the value of a ",NA,NA
"variable is, it is simply a place marker. For these situations there is a special variable called the ",NA,NA
anonymous variable,NA,NA
", represented as an underscore (_). For example ",NA,NA
list_things(_).,NA,NA
"Next we will write list_connections/1, which lists connecting rooms. Since rules can refer to other rules, ",NA,NA
"as well as to facts, we can write list_connections/1 just like list_things/1 by using the connection/2 rule. ",NA,NA
list_connections(Place) :-,NA,NA
" connect(Place, X),",http://www.amzi.com/AdventureInProlog/a5rules.htm (8 of 14)11/3/2006 7:05:20 PM,NA
" tab(2),",NA,NA
" write(X),",NA,NA
" nl,",NA,NA
 fail.,NA,NA
list_connections(_).,NA,NA
Trying it gives us ,NA,NA
?- list_connections(hall).,NA,NA
 dining room,NA,NA
 office ,NA,NA
yes,NA,NA
Now we are ready to write look/0. The single fact here(kitchen) tells us where we are in the game. (In ,NA,NA
chapter 7 we will see how to move about the game by dynamically changing here/1.) We can use it with ,NA,NA
the two list predicates to write the full look/0. ,NA,NA
look :-,NA,NA
" here(Place),",NA,NA
" write('You are in the '), write(Place), nl, ",NA,NA
"write('You can see:'), nl,",NA,NA
" list_things(Place),",NA,NA
" write('You can go to:'), nl,",NA,NA
 list_connections(Place).,NA,NA
"Given we are in the kitchen, this is how it works. ",NA,NA
?- look.,NA,NA
You are in the kitchen ,NA,NA
You can see:,NA,NA
 apple,NA,NA
 broccoli,NA,NA
 crackers ,NA,NA
You can go to:,NA,NA
 office,NA,NA
 cellar,NA,NA
 dining room ,NA,NA
yes,NA,NA
"We now have an understanding of the fundamentals of Prolog, and it is worth summarizing what we ",NA,NA
have learned so far. We have seen the following about rules in Prolog. ,http://www.amzi.com/AdventureInProlog/a5rules.htm (9 of 14)11/3/2006 7:05:20 PM,NA
A Prolog program is a logicbase of interrelated facts and rules. ,G,NA
"The rules communicate with each other through unification, Prolog's built-in pattern matcher. ",G,NA
The rules communicate with the user through built-in predicates such as write/1. ,G,NA
The rules can be queried (called) individually from the listener. ,NA,NA
We have seen the following about Prolog's control flow. ,G,NA
The execution behavior of the rules is controlled by Prolog's built-in backtracking search ,NA,NA
mechanism. ,G,NA
We can force backtracking with the built-in predicate fail. ,G,NA
We can force success of a predicate by adding a final clause with dummy variables as arguments ,NA,NA
and no body. ,NA,NA
We now understand the following aspects of Prolog programming. ,G,NA
"Facts in the logicbase (locations, doors, etc.) replace conventional data definition. ",G,NA
The backtracking search (list_things/1) replaces the coding of many looping constructs. ,G,NA
Passing of control through pattern matching (connect/2) replaces conditional test and branch ,NA,NA
structures. ,G,NA
"The rules can be tested individually, encouraging modular program development. ",G,NA
Rules that call rules encourage the programming practices of procedure abstraction and data ,NA,NA
"abstraction. (For example, look/0 doesn't know how list_things/1 works, or how the location data ",NA,NA
is stored.) ,NA,NA
"With this level of understanding, we can make a lot of progress on the exercise applications. Take some ",NA,NA
time to work with the programs to consolidate your understanding before moving on to the following ,NA,NA
chapters. ,NA,NA
Exercises ,NA,NA
Nonsense Prolog,NA,NA
1- Consider the following Prolog logicbase. ,NA,NA
"a(a1,1).",NA,NA
"a(A,2).",NA,NA
"a(a3,N). ",NA,NA
"b(1,b1).",NA,NA
"b(2,B).",NA,NA
"b(N,b3).",NA,NA
"c(X,Y) :- a(X,N), b(N,Y).",NA,NA
"d(X,Y) :- a(X,N), b(Y,N).",NA,NA
"d(X,Y) :- a(N,X), b(N,Y).",NA,NA
"Predict the answers to the following queries, then check them with Prolog, tracing. ",NA,NA
"?- a(X,2).",NA,NA
"?- b(X,kalamazoo).",NA,NA
"?- c(X,b3).",NA,NA
"?- c(X,Y).",NA,NA
"?- d(X,Y).",NA,NA
Adventure Game ,NA,NA
"2- Experiment with the various rules that were developed during this chapter, tracing them all. 3- Write ",NA,NA
"look_in/1 for Nani Search. It should list the things located in its argument. For example, look_in (desk) ",NA,NA
should list the contents of the desk. ,NA,NA
Genealogical Logicbase ,NA,NA
4- Build rules for the various family relationships that were developed as queries in the last chapter. For ,NA,NA
example ,NA,NA
"mother(M,C):-",NA,NA
" parent(M,C),",NA,NA
 female(M).,NA,NA
5- Build a rule for siblings. You will probably find your rule lists an individual as his/her own sibling. ,NA,NA
Use trace to figure out why. ,NA,NA
6- We can fix the problem of individuals being their own siblings by using the built-in predicate that ,NA,NA
"succeeds if two values are unequal, and fails if they are the same. The predicate is \=(X,Y). Jumping ",NA,NA
"ahead a bit (to operator definitions in chapter 12), we can also write it in the form X \= Y. ",NA,NA
"7- Use the sibling predicate to define additional rules for brothers, sisters, uncles, aunts, and cousins. ",NA,NA
"8- If we want to represent marriages in the family logicbase, we run into the two-way door problem we ",http://www.amzi.com/AdventureInProlog/a5rules.htm (11 of 14)11/3/2006 7:05:20 PM,NA
"encountered in Nani Search. Unlike parent/2, which has two arguments with distinct meanings, ",NA,NA
married/2 can have the arguments reversed without changing the meaning. ,NA,NA
"Using the Nani Search door/2 predicate as an example, add some basic family data with a spouse/2 ",NA,NA
predicate. Then write the predicate married/2 using connect/2 as a model. ,NA,NA
9- Use the new married predicate to add rules for uncles and aunts that get uncles and aunts by marriage ,NA,NA
"as well as by blood. You should have two rules for each of these relationships, one for the blood case and ",NA,NA
one for the marriage case. Use trace to follow their behavior. ,NA,NA
"10- Explore other relationships, such as those between in-laws. ",NA,NA
11- Write a predicate for grandparent/2. Use it to find both a grandparent and a grandchild. ,NA,NA
"grandparent(someone, X).",NA,NA
"grandparent(X, someone).",NA,NA
"Trace its behavior for both uses. Depending on how you wrote it, one use will require many more steps ",NA,NA
"than the other. Write two predicates, one called grandparent/2 and one called grandchild/2. Order the ",NA,NA
goals in each so that they are efficient for their intended uses. ,NA,NA
Customer Order Entry,NA,NA
12- Write a rule item_quantity/2 that is used to find the inventory level of a named item. This shields the ,NA,NA
user of this predicate from having to deal with the item numbers. ,NA,NA
13- Write a rule that produces an inventory report using the item_quantity/2 predicate. It should display ,NA,NA
the name of the item and the quantity on hand. It should also always succeed. It will be similar to ,NA,NA
list_things/2. ,NA,NA
14- Write a rule which defines a good customer. You might want to identify different cases of a good ,NA,NA
customer. ,NA,NA
Expert Systems,NA,NA
"Expert systems are often called rule-based systems. The rules are ""rules of thumb"" used by experts to ",NA,NA
solve certain problems. The expert system includes an ,NA,NA
inference engine,NA,NA
", which knows how to use the ",NA,NA
rules. ,NA,NA
There are many kinds of inference engines and knowledge representation techniques that are used in ,NA,NA
"expert systems. Prolog is an excellent language for building any kind of expert system. However, certain ",http://www.amzi.com/AdventureInProlog/a5rules.htm (12 of 14)11/3/2006 7:05:20 PM,NA
types of expert systems can be built directly using Prolog's native rules. These systems are called ,NA,NA
structured selection,NA,NA
 systems. ,NA,NA
The code listing for 'birds' in the appendix contains a sample system that can be used to identify birds. ,NA,NA
"You will be asked to build a similar system in the exercises. It can identify anything, from animals to ",NA,NA
cars to diseases. ,NA,NA
"15- Decide what kind of expert system you would like to build, and add a few initial identification rules. ",NA,NA
"For example, a system to identify house pets might have these rules. ",NA,NA
"pet(dog):- size(medium), noise(woof).",NA,NA
"pet(cat):- size(medium), noise(meow). ",NA,NA
"pet(mouse):- size(small), ",NA,NA
noise(squeak).,NA,NA
"16- For now, we can use these rules by putting the known facts in the logicbase. For example, if we add ",NA,NA
size(medium) and noise(meow) and then pose the query pet(X) we will find X=cat. ,NA,NA
"Many Prologs allow clauses to be entered directly at the listener prompt, which makes using this expert ",NA,NA
system a little easier. The presence of the neck symbol (:-) signals to the listener that the input is a clause ,NA,NA
"to be added. So to add facts directly to the listener workspace, they must be made into rules, as follows. ",NA,NA
?- size(medium) :- true. ,NA,NA
recorded,NA,NA
?- noise(meow) :- true. ,NA,NA
recorded,NA,NA
"Jumping ahead, you can also use assert/1 like this ",NA,NA
?- assert(size(medium)).,NA,NA
yes ,NA,NA
?- assert(noise(meow)).,NA,NA
yes,NA,NA
"These examples use the predicates in the general form attribute(value). In this simple example, the pet ",NA,NA
attribute is deduced. The size and noise attributes must be given. ,NA,NA
17- Improve the expert system by having it ask for the attribute/values it can't deduce. We do this by ,NA,NA
first adding the rules ,NA,NA
"size(X):- ask(size, X). ",NA,NA
"noise(X):- ask(noise, X).",NA,NA
"For now, ask/2 will simply check with the user to see if an attribute/value pair is true or false. It will use ",NA,NA
the built-in predicate read/1 which reads a Prolog term (ending in a period of course). ,NA,NA
"ask(Attr, Val):-",NA,NA
" write(Attr),tab(1),write(Val),",NA,NA
" tab(1),write('(yes/no)'),write(?), ",NA,NA
"read(X),",NA,NA
 X = yes.,NA,NA
"The last goal, X = yes, attempts to unify X and yes. If yes was read, then it succeeds, otherwise, it fails. ",NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a5rules.htm (14 of 14)11/3/2006 7:05:20 PM,NA
6,NA,NA
Arithmetic,NA,NA
Prolog must be able to handle arithmetic in order to be a useful general purpose programming language. ,NA,NA
"However, arithmetic does not fit nicely into the logical scheme of things. ",NA,NA
"That is, the concept of evaluating an arithmetic expression is in contrast to the straight pattern matching ",NA,NA
"we have seen so far. For this reason, Prolog provides the built-in predicate 'is' that evaluates arithmetic ",NA,NA
"expressions. Its syntax calls for the use of operators, which will be described in more detail in chapter ",NA,NA
12. ,NA,NA
X is <arithmetic expression>,NA,NA
The variable X is set to the value of the arithmetic expression. On backtracking it is unassigned. ,NA,NA
The arithmetic expression looks like an arithmetic expression in any other programming language. ,NA,NA
Here is how to use Prolog as a calculator. ,NA,NA
?- X is 2 + 2.,NA,NA
X = 4,NA,NA
?- X is 3 * 4 + 2.,NA,NA
X = 14,NA,NA
Parentheses clarify precedence. ,NA,NA
?- X is 3 * (4 + 2).,NA,NA
X = 18,NA,NA
?- X is (8 / 4) / 2.,NA,NA
X = 1,NA,NA
"In addition to 'is,' Prolog provides a number of operators that compare two numbers. These include ",NA,NA
"'greater than', 'less than', 'greater or equal than', and 'less or equal than.' They behave more logically, and ",NA,NA
succeed or fail according to whether the comparison is true or false. Notice the order of the symbols in ,NA,NA
the greater or equal than and less than or equal operators. They are specifically constructed not to look ,NA,NA
"like an arrow, so that you can use arrow symbols in your programs without confusion. ",NA,NA
X > Y ,NA,NA
X < Y ,NA,NA
X >= Y ,NA,NA
X =< Y,NA,NA
Here are a few examples of their use. ,NA,NA
?- 4 > 3. ,NA,NA
yes,NA,NA
?- 4 < 3. ,NA,NA
no,NA,NA
"?- X is 2 + 2, X > 3. ",NA,NA
X = 4,NA,NA
"?- X is 2 + 2, 3 >= X. ",NA,NA
no,NA,NA
?- 3+4 > ,NA,NA
3*2. ,NA,NA
yes,NA,NA
They can be used in rules as well. Here are two example predicates. One converts centigrade ,NA,NA
"temperatures to Fahrenheit, the other checks if a temperature is below freezing. ",NA,NA
"c_to_f(C,F) :-",NA,NA
 F is C * 9 / 5 + 32.,NA,NA
freezing(F) :-,NA,NA
 F =< 32.,NA,NA
Here are some examples of their use. ,NA,NA
"?- c_to_f(100,X). ",NA,NA
X = 212 ,NA,NA
yes,NA,NA
?- freezing(15).,NA,NA
yes,NA,NA
?- freezing(45).,NA,NA
no,NA,NA
Exercises ,NA,NA
Customer Order Entry,NA,NA
1- Write a predicate valid_order/3 that checks whether a customer order is valid. The arguments should ,NA,NA
"be customer, item, and quantity. The predicate should succeed only if the customer is a valid customer ",NA,NA
"with a good credit rating, the item is in stock, and the quantity ordered is less than the quantity in stock. ",NA,NA
2- Write a reorder/1 predicate which checks inventory levels in the inventory record against the reorder ,NA,NA
quantity in the item record. It should write a message indicating whether or not it's time to reorder. ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a6arith.htm (3 of 3)11/3/2006 7:05:23 PM,NA
7,NA,NA
Managing Data,NA,NA
"We have seen that a Prolog program is a logicbase of predicates, and so far we have entered clauses for ",NA,NA
those predicates directly in our programs. Prolog also allows us to manipulate the logicbase directly and ,NA,NA
provides built-in predicates to perform this function. The main ones are ,NA,NA
asserta(X) ,NA,NA
"Adds the clause X as the first clause for its predicate. Like the other I/O predicates, it always fails ",NA,NA
on backtracking and does not undo its work. ,NA,NA
assertz(X) ,NA,NA
"Same as asserta/1, only it adds the clause X as the last clause for its predicate. ",NA,NA
retract(X) ,NA,NA
"Removes the clause X from the logicbase, again with a permanent effect that is not undone on ",NA,NA
backtracking. ,NA,NA
The ability to manipulate the logicbase is obviously an important feature for Nani Search. With it we can ,NA,NA
"dynamically change the location of the player, as well as the stuff that has been picked up and moved. ",NA,NA
"We will first develop goto/1, which moves the player from one room to another. It will be developed ",NA,NA
"from the top down, in contrast to look/0 which was developed from the bottom up. ",NA,NA
"When the player enters the command goto, we first check if they can go to the place and if so move ",NA,NA
"them so they can look around the new place. Starting from this description of goto/1, we can write the ",NA,NA
main predicate. ,NA,NA
goto(Place):- ,NA,NA
" can_go(Place),",NA,NA
" move(Place),",NA,NA
 look.,NA,NA
Next we fill in the details. We can go to a room if it connects to where we are. ,NA,NA
can_go(Place):- ,NA,NA
" here(X),",NA,NA
" connect(X, Place).",NA,NA
We can test can_go/1 immediately (assuming we are in the kitchen). ,NA,NA
?- can_go(office). ,NA,NA
yes,NA,NA
?- can_go(hall). ,NA,NA
no,NA,NA
"Now, can_go/1 succeeds and fails as we want it to, but it would be nice if it gave us a message when it ",NA,NA
"failed. By adding a second clause, which is tried if the first one fails, we can cause can_go/1 to write an ",NA,NA
error message. Since we want can_go/1 to fail in this situation we also need to add a fail to the second ,NA,NA
clause. ,NA,NA
can_go(Place):-,NA,NA
" here(X),",NA,NA
" connect(X, Place).",NA,NA
can_go(Place):-,NA,NA
" write('You can''t get there from here.'), nl, ",NA,NA
fail.,NA,NA
This version of can_go/1 behaves as we want. ,NA,NA
?- can_go(hall).,NA,NA
You can't get there from here.,NA,NA
no,NA,NA
"Next we develop move/1, which does the work of dynamically updating the logicbase to reflect the new ",NA,NA
location of the player. It retracts the old clause for here/1 and replaces it with a new one. This way there ,NA,NA
will always be only one here/1 clause representing the current place. Because goto/1 calls can_go/1 ,NA,NA
"before move/1, the new here/1 will always be a legal place in the game. ",NA,NA
move(Place):-,NA,NA
" retract(here(X)),",NA,NA
 asserta(here(Place)).,NA,NA
"We can now use goto/1 to explore the game environment. The output it generates is from look/0, which ",NA,NA
we developed in chapter 5. ,NA,NA
?- goto(office).,http://www.amzi.com/AdventureInProlog/a7manage.htm (2 of 6)11/3/2006 7:05:29 PM,NA
You are in the office ,NA,NA
You can see:,NA,NA
 desk,NA,NA
 computer ,NA,NA
You can go to:,NA,NA
 hall,NA,NA
 kitchen ,NA,NA
yes,NA,NA
?- goto(hall).,NA,NA
You are in the hall ,NA,NA
You can see: ,NA,NA
You can go to:,NA,NA
 dining room,NA,NA
 office ,NA,NA
yes,NA,NA
?- goto(kitchen).,NA,NA
You can't get there from here.,NA,NA
no,NA,NA
We will also need 'asserta' and 'retract' to implement 'take' and 'put' commands in the game. ,NA,NA
"Here is take/1. For it we will define a new predicate, have/1, which has one clause for each thing the ",NA,NA
"game player has. Initially, have/1 is not defined because the player is not carrying anything. ",NA,NA
take(X):- ,NA,NA
" can_take(X),",NA,NA
 take_object(X).,NA,NA
can_take/1 is analogous to can_go/1. ,NA,NA
can_take(Thing) :-,NA,NA
" here(Place),",NA,NA
" location(Thing, Place).",NA,NA
can_take(Thing) :-,NA,NA
" write('There is no '), write(Thing), ",NA,NA
"write(' here.'),",NA,NA
" nl, fail.",NA,NA
"take_object/1 is analogous to move/1. It retracts a location/2 clause and asserts a have/1 clause, ",NA,NA
reflecting the movement of the object from the place to the player. ,NA,NA
take_object(X):- ,NA,NA
" retract(location(X,_)),",NA,NA
" asserta(have(X)),",NA,NA
" write('taken'), nl.",NA,NA
"As we have seen, the variables in a clause are local to that clause. There are no global variables in ",NA,NA
"Prolog, as there are in many other languages. The Prolog logicbase serves that purpose. It allows all ",NA,NA
"clauses to share information on a wider basis, replacing the need for global variables. 'asserts' and ",NA,NA
'retracts' are the tools used to manipulate this global data. ,NA,NA
"As with any programming language, global data can be a powerful concept, easily overused. They ",NA,NA
"should be used with care, since they hide the communication of information between clauses. The same ",NA,NA
code will behave differently if the global data is changed. This can lead to hard-to-find bugs. ,NA,NA
Eliminating global data and the 'assert' and 'retract' capabilities of Prolog is a goal of many logic ,NA,NA
"programmers. It is possible to write Prolog programs without dynamically modifying the logicbase, thus ",NA,NA
eliminating the problem of global variables. This is done by carrying the information as arguments to the ,NA,NA
"predicates. In the case of an adventure game, the complete state of the game could be represented as ",NA,NA
"predicate arguments, with each command called with the current state and returning a new modified ",NA,NA
state. This approach will be discussed in more detail in chapter 14. ,NA,NA
Although the database-like approach presented here may not be the purest method from a logical ,NA,NA
"standpoint, it does allow for a very natural representation of this game application. ",NA,NA
Various Prologs provide varying degrees of richness in the area of logicbase manipulation. The built-in ,NA,NA
"versions are usually unaffected by backtracking. That is, like the other I/O predicates, they perform their ",NA,NA
function when called and do nothing when entered from the redo port. ,NA,NA
Sometimes it is desirable to have a predicate retract its assertions when the redo port is entered. It is easy ,NA,NA
to write versions of 'assert' and 'retract' that undo their work on backtracking. ,NA,NA
backtracking_assert(X):- ,NA,NA
 asserta(X).,NA,NA
backtracking_assert(X):-,NA,NA
" retract(X),fail.",NA,NA
"The first time through, the first clause is executed. If a later goal fails, backtracking will cause the ",NA,NA
"second clause to be tried. It will undo the work of the first and fail, thus giving the desired effect. ",NA,NA
Exercises ,NA,NA
Adventure Game,NA,NA
1- Write put/1 which retracts a have/1 clause and asserts a location/2 clause in the current room. ,NA,NA
2- Write inventory/0 which lists the have/1 things. ,NA,NA
"3- Use goto/1, take/1, put/1, look/0, and inventory/0 to move about and examine the game environment ",NA,NA
so far. ,NA,NA
4- Write the predicates turn_on/1 and turn_off/1 for Nani Search. They will be used to turn the flashlight ,NA,NA
on or off. ,NA,NA
5- Add an open/closed status for each of the doors. Write open and closepredicates that do the obvious. ,NA,NA
Fix can_go/1 to check whether a door is open and write the appropriate error message if its not. ,NA,NA
Customer Order Entry,NA,NA
"6- In the order entry application, write a predicate update_inventory/2 that takes an item name and ",NA,NA
"quantity as input. Have it retract the old inventory amount, perform the necessary arithmetic and assert ",NA,NA
the new inventory amount. ,NA,NA
"NOTE: retract(inventory(item_id,Q)) binds Q to the old value, thus alleviating the need for a separate ",NA,NA
goal to get the old value of the inventory. ,NA,NA
7- We can now use the various predicates developed for the customer order entry system to write a ,NA,NA
predicate that prompts the user for order information and generates the order. The predicate can be ,NA,NA
simply order/0. ,NA,NA
"order/0 should first prompt the user for the customer name, the item name and the quantity. For example ",NA,NA
"write('Enter customer name:'),read(C),",NA,NA
"It should then use the rules for good_customer and valid_order to verify that this is a valid order. If so, it ",NA,NA
"should assert a new type of record, order/3, which records the order information. It can then ",NA,NA
update_inventory and check whether its time to reorder. ,NA,NA
"The customer order entry application has been designed from the bottom up, since that is the way the ",NA,NA
material has been presented for learning. The order predicate should suggest that Prolog is an excellent ,NA,NA
tool for top-down development as well. ,NA,NA
"One could start with the concept that processing an order means reading the date, checking the order, ",http://www.amzi.com/AdventureInProlog/a7manage.htm (5 of 6)11/3/2006 7:05:29 PM,NA
"updating inventory, and reordering if necessary. The necessary details of implementing these predicates ",NA,NA
could be left for later. ,NA,NA
Expert System,NA,NA
8- The expert system currently asks for the same information over and over again. We can use the ,NA,NA
logicbase to remember the answers to questions so that ask/2 doesn't re-ask something. ,NA,NA
"When ask/2 gets a yes or no answer to a question about an attribute-value pair, assert a fact in the form ",NA,NA
"known(Attribute, Value, YesNo).",NA,NA
"Add a first clause to ask/2 that checks whether the answer is already known and, if so, succeeds. Add a ",NA,NA
"second clause that checks if the answer is known to be false and, if so, fails. ",NA,NA
"The third clause makes sure the answer is not already known, and then asks the user as before. To do ",NA,NA
"this, the built-in predicate not/1 is used. It fails if its argument succeeds. ",NA,NA
"not (known(Attr, Val, Answer))",NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a7manage.htm (6 of 6)11/3/2006 7:05:29 PM,NA
8,NA,NA
Recursion,NA,NA
"Recursion in any language is the ability for a unit of code to call itself, repeatedly, if necessary. ",NA,NA
Recursion is often a very powerful and convenient way of representing certain programming constructs. ,NA,NA
"In Prolog, recursion occurs when a predicate contains a goal that refers to itself. ",NA,NA
"As we have seen in earlier chapters, every time a rule is called, Prolog uses the body of the rule to create ",NA,NA
"a new query with new variables. Since the query is a new copy each time, it makes no difference whether ",NA,NA
a rule calls another rule or itself. ,NA,NA
"A recursive definition (in any language, not just Prolog) always has at least two parts, a boundary ",NA,NA
condition and a recursive case. ,NA,NA
The boundary condition defines a simple case that we know to be true. The recursive case simplifies the ,NA,NA
"problem by first removing a layer of complexity, and then calling itself. At each level, the boundary ",NA,NA
"condition is checked. If it is reached the recursion ends. If not, the recursion continues. ",NA,NA
We will illustrate recursion by writing a predicate that can detect things which are nested within other ,NA,NA
things. ,NA,NA
"Currently our location/2 predicate tells us the flashlight is in the desk and the desk is in the office, but it ",NA,NA
does not indicate that the flashlight is in the office. ,NA,NA
"?- location(flashlight, office).",NA,NA
no,NA,NA
"Using recursion, we will write a new predicate, is_contained_in/2, which will dig through layers of ",NA,NA
"nested things, so that it will answer 'yes' if asked if the flashlight is in the office. ",NA,NA
"To make the problem more interesting, we will first add some more nested items to the game. We will ",NA,NA
"continue to use the location predicate to put things in the desk, which in turn can have other things inside ",NA,NA
them. ,http://www.amzi.com/AdventureInProlog/a8recurs.htm (1 of 8)11/3/2006 7:05:35 PM,NA
"location(envelope, desk). ",NA,NA
"location(stamp, envelope).",NA,NA
"location(key, envelope).",NA,NA
"To list all of things in the office, we would first have to list those things that are directly in the office, ",NA,NA
"like the desk. We would then list the things in the desk, and the things inside the things in the desk. ",NA,NA
"If we generalize a room into being just another thing, we can state a two-part rule which can be used to ",NA,NA
deduce whether something is contained in (nested in) something else. ,G,NA
"A thing, T1, is contained in another thing, T2, if T1 is directly located in T2. (This is the boundary ",NA,NA
condition.) ,G,NA
"A thing, T1, is contained in another thing, T2, if some intermediate thing, X, is located in T2 and ",NA,NA
T1 is contained in X. (This is where we simplify and recurse.) ,NA,NA
We will now express this in Prolog. The first rule translates into Prolog in a straightforward manner. ,NA,NA
"is_contained_in(T1,T2) :- ",NA,NA
" location(T1,T2).",NA,NA
The recursive rule is also straightforward. Notice that it refers to itself. ,NA,NA
"is_contained_in(T1,T2) :-",NA,NA
" location(X,T2),",NA,NA
" is_contained_in(T1,X).",NA,NA
Now we are ready to try it. ,NA,NA
"?- is_contained_in(X, office).",NA,NA
X = desk ; ,NA,NA
X = computer ; ,NA,NA
X = flashlight ; ,NA,NA
X = envelope ; ,NA,NA
X = stamp ; ,NA,NA
X = key ; ,NA,NA
no,NA,NA
"?- is_contained_in(envelope, office). ",NA,NA
yes,NA,NA
"?- is_contained_in(apple, office).",http://www.amzi.com/AdventureInProlog/a8recurs.htm (2 of 8)11/3/2006 7:05:35 PM,NA
no,NA,NA
How Recursion Works ,NA,NA
"As in all calls to rules, the variables in a rule are unique, or scoped, to the rule. In the recursive case, this ",NA,NA
"means each call to the rule, at each level, has its own unique set of variables. So the values of X, T1, and ",NA,NA
T2 at the first level of recursion are different from those at the second level. ,NA,NA
"However, unification between a goal and the head of a clause forces a relationship between the variables ",NA,NA
"of different levels. Using subscripts to distinguish the variables, and internal Prolog variables, we can ",NA,NA
trace the relationships for a couple of levels of recursion. ,NA,NA
"First, the query goal is ",NA,NA
"?- is_contained_in(XQ, office).",NA,NA
The clause with variables for the first level of recursion is ,NA,NA
"is_contained_in(T11, T21) :-",NA,NA
" location(X1, T21),",NA,NA
" is_contained_in(T11, X1).",NA,NA
"When the query is unified with the head of the clause, the variables become bound. The bindings are ",NA,NA
XQ = _01 ,NA,NA
T11 = _01 ,NA,NA
T21 = office ,NA,NA
X1 = _02,NA,NA
"Note particularly that XQ in the query becomes bound to T11 in the clause, so when a value of _01 is ",NA,NA
"found, both variables are found. ",NA,NA
"With these bindings, the clause can be rewritten as ",NA,NA
"is_contained_in(_01, office) :-",NA,NA
" location(_02, office),",NA,NA
" is_contained_in(_01, _02).",NA,NA
"When the location/2 goal is satisfied, with _02 = desk, the recursive call becomes ",NA,NA
"is_contained_in(_01, desk)",http://www.amzi.com/AdventureInProlog/a8recurs.htm (3 of 8)11/3/2006 7:05:35 PM,NA
"That goal unifies with the head of a new copy of the clause, at the next level of the recursion. After that ",NA,NA
unification the variables are ,NA,NA
XQ = _01        T11 = _01       T12 = _01,NA,NA
 T21 = office    T22 = desk,NA,NA
 X1 = desk       X2 = _03,NA,NA
"When the recursion finds a solution, such as 'envelope,' all of the T1s and X0 immediately take on that ",NA,NA
value. Figure 8.1 contains a full annotated trace of the query.,NA,NA
The query is ,NA,NA
"?- is_contained_in(X, office).",NA,NA
"Each level of the recursion will have its own unique variables, but as in all calls to rules, the variables ",NA,NA
at a called level will be bound in some relationship to the variables at the calling level. In the ,NA,NA
"following trace, we will use Prolog internal variables, so we can see which variables are bound ",NA,NA
"together and which are not. The items directly in the office are found easily, as the variable _0 is ",NA,NA
bound to X in the query and T1 in the rule.,NA,NA
"1-1 CALL is_contained_in(_0, office) ",NA,NA
"1-1 try (1) is_contained_in(_0, office)",NA,NA
 ,NA,NA
"2-1 CALL location(_0, office) ",NA,NA
" 2-1 EXIT location(desk, office) ",NA,NA
"1-1 EXIT is_contained_in(desk, office) ",NA,NA
 X = desk ;,NA,NA
" 2-1 REDO location(_0, office) ",NA,NA
" 2-1 EXIT location(computer, office) 1-1 ",NA,NA
"EXIT is_contained_in(computer, office) ",NA,NA
 X = computer ;,NA,NA
" 2-1 REDO location(_0,office) ",NA,NA
" 2-1 FAIL location(_0,office) ",NA,NA
"When there are no more location(X, office) clauses, the first clause of is_contained_in/2 fails, and the ",NA,NA
second clause is tried. Notice that the call to location does not have its first argument bound to the ,NA,NA
"same variable. It was X in the rule, and it gets a new internal value, _4. T1 stays bound to _0.",NA,NA
"1-1 REDO is_contained_in(_0, office) 1-",NA,NA
"1 try (2) is_contained_in(_0, office)",NA,NA
 ,NA,NA
"2-1 CALL location(_4, office) ",NA,NA
" 2-1 EXIT location(desk, office) ",http://www.amzi.com/AdventureInProlog/a8recurs.htm (4 of 8)11/3/2006 7:05:35 PM,NA
"When it initiates a new call to is_contained_in/2, it behaves exactly as if we had performed the query ",NA,NA
"is_contained_in(X, desk) at the listener prompt. It is, in effect, a completely new copy of ",NA,NA
"is_contained_in/2. This call will find all of the things in the desk, just as the first level found all things ",NA,NA
in the office.,NA,NA
" 2-2 CALL is_contained_in(_0, desk) ",NA,NA
" 2-2 try (1) is_contained_in(_0, desk) 3-",NA,NA
"1 CALL location(_0, desk) ",NA,NA
" 3-1 EXIT location(flashlight, desk) ",NA,NA
"Having found the flashlight at the second-level is_contained_in/2, the answer propagates back up to ",NA,NA
the first level copy of is_contained_in/2.,NA,NA
" 2-2 EXIT is_contained_in(flashlight, desk) ",NA,NA
"1-1 EXIT is_contained_in(flashlight, office) ",NA,NA
 X = flashlight ;,NA,NA
"Similarly, it finds the envelope at the second level of recursion.",NA,NA
" 3-1 REDO location(_0, desk) ",NA,NA
" 3-1 EXIT location(envelope, desk) ",NA,NA
 2-,NA,NA
"2 EXIT is_contained_in(envelope, desk) 1-1 ",NA,NA
"EXIT is_contained_in(envelope, office) ",NA,NA
 X = envelope ;,NA,NA
"Having exhausted the things located in the desk, it next begins to look for things within things located ",NA,NA
in the desk.,NA,NA
" 3-1 REDO location(_0, desk) ",NA,NA
" 3-1 FAIL location(_0, desk) ",NA,NA
" 2-2 REDO is_contained_in(_0, desk) ",NA,NA
" 2-2 try (2) is_contained_in(_0, desk) 3-",NA,NA
"1 CALL location(_7, desk) ",NA,NA
" 3-1 EXIT location(flashlight, desk) ",NA,NA
"First, is there something in the flashlight? Both clauses of is_contained_in/2 fail because there is ",NA,NA
nothing located in the flashlight.,NA,NA
" 3-2 CALL is_contained_in(_0, flashlight)  ",NA,NA
"4-1 CALL location(_0, flashlight)  4-1 ",NA,NA
"FAIL location(_0, flashlight) ",http://www.amzi.com/AdventureInProlog/a8recurs.htm (5 of 8)11/3/2006 7:05:35 PM,NA
" 3-2 REDO is_contained_in(_0, flashlight)  ",NA,NA
"3-2 try (2) is_contained_in(_0, flashlight)",NA,NA
 ,NA,NA
"4-1 CALL location(_11, flashlight) ",NA,NA
 4-1 FAIL ,NA,NA
"location(_11, flashlight)  3-2 FAIL ",NA,NA
"is_contained_in(_0, flashlight)",NA,NA
"Next, it tries to find things in the envelope and comes up with the stamp.",NA,NA
" 3-1 REDO location(_7, desk) ",NA,NA
" 3-1 EXIT location(envelope, desk) ",NA,NA
" 3-2 CALL is_contained_in(_0, envelope) ",NA,NA
" 4-1 CALL location(_0, envelope) ",NA,NA
" 4-1 EXIT location(stamp, envelope) ",NA,NA
" 3-2 EXIT is_contained_in(stamp, envelope) ",NA,NA
" 2-2 EXIT is_contained_in(stamp, desk) ",NA,NA
"1-1 EXIT is_contained_in(stamp, office) ",NA,NA
 X = stamp ;,NA,NA
And then the key.,NA,NA
" 4-1 REDO location(_0,envelope) ",NA,NA
" 4-1 EXIT location(key, envelope) ",NA,NA
" 3-2 EXIT is_contained_in(key, envelope) ",NA,NA
 ,NA,NA
"2-2 EXIT is_contained_in(key, desk) ",NA,NA
"1-1 EXIT is_contained_in(key, office) ",NA,NA
 X = key ;,NA,NA
And then it fails its way back to the beginning.,NA,NA
" 3-2 REDO is_contained_in(_0, envelope)  ",NA,NA
"3-2 try (2) is_contained_in(_0, envelope)",NA,NA
" 4-1 CALL location(_11, envelope) ",NA,NA
 ,NA,NA
"4-1 EXIT location(stamp, envelope) ",NA,NA
 4-2 ,NA,NA
"CALL is_contained_in(_0, stamp) ",NA,NA
 ,NA,NA
"5-1 CALL location(_0, stamp) ",NA,NA
 5-1 ,NA,NA
"FAIL location(_0, stamp) ",NA,NA
 4-2 REDO ,NA,NA
"is_contained_in(_0, stamp) ",NA,NA
 4-2 try(2) ,NA,NA
"is_contained_in(_0, stamp)",NA,NA
 5-1 CALL ,NA,NA
"location(_14, stamp) ",NA,NA
 5-1 FAIL ,NA,NA
"location(_14, stamp) ",NA,NA
 4-1 REDO ,NA,NA
"location(_11, envelope) ",NA,NA
 4-1 EXIT ,NA,NA
"location(key, envelope) ",http://www.amzi.com/AdventureInProlog/a8recurs.htm (6 of 8)11/3/2006 7:05:35 PM,NA
" 4-2 CALL is_contained_in(_0, key) ",NA,NA
" 4-2 try (1) is_contained_in(_0, key)",NA,NA
" 5-1 CALL location(_0, key) ",NA,NA
" 5-1 FAIL location(_0, key) ",NA,NA
" 4-2 REDO is_contained_in(_0, key) ",NA,NA
" 4-2 try (2) is_contained_in(_0, key)",NA,NA
" 5-1 CALL location(_14, key) ",NA,NA
" 5-1 FAIL location(_14, key) ",NA,NA
 4-1 ,NA,NA
"REDO location(_7, desk) ",NA,NA
" 4-1 FAIL location(_7, desk) ",NA,NA
" 3-1 REDO location(_4, office) ",NA,NA
" 3-1 EXIT location(computer, office)  3-2 ",NA,NA
"CALL is_contained_in(_0, computer) ",NA,NA
 ,NA,NA
"4-1 CALL location(_0, computer) ",NA,NA
 4-1 ,NA,NA
"FAIL location(_0, computer)  3-2 REDO ",NA,NA
"is_contained_in(_0, computer) ",NA,NA
 4-1 ,NA,NA
"CALL location(_7, computer) ",NA,NA
 4-1 ,NA,NA
"FAIL location(_7, computer)  3-1 REDO ",NA,NA
"location(_4, office) ",NA,NA
" 3-1 FAIL location(_4, office) ",NA,NA
 no,NA,NA
Figure 8.1. Trace of a recursive query ,NA,NA
"When writing a recursive predicate, it is essential to ensure that the boundary condition is checked at ",NA,NA
"each level . Otherwise, the program might recurse forever. ",NA,NA
"The simplest way to do this is by always defining the boundary condition first, ensuring that it is always ",NA,NA
tried first and that the recursive case is only tried if the boundary condition fails. ,NA,NA
Pragmatics ,NA,NA
"We now come to some of the pragmatics of Prolog programming. First consider that the goal location(X, ",NA,NA
"Y) will be satisfied by every clause of location/2. On the other hand, the goals location(X, office) or ",NA,NA
"location(envelope, X) will be satisfied by fewer clauses. ",NA,NA
"Let's look again at the second rule for is_contained_in/2, and an equally valid alternate coding. ",NA,NA
"is_contained_in(T1,T2):-",NA,NA
" location(X,T2),",NA,NA
" is_contained_in(T1,X).",NA,NA
"is_contained_in(T1,T2):-",NA,NA
" location(T1,X),",NA,NA
" is_contained_in(X,T2).",NA,NA
"Both will give correct answers, but the performance of each will depend on the query. The query ",NA,NA
"is_contained_in(X, office) will execute faster with the first version. That is because T2 is bound, making ",NA,NA
"the search for location(X, T2) easier than if both variables were unbound. Similarly, the second version ",NA,NA
"is faster for queries such as is_contained_in(key, X). ",NA,NA
Exercises ,NA,NA
Adventure Game,NA,NA
1- Trace the two versions of is_contained_in/2 presented at the end of the chapter to understand the ,NA,NA
performance differences between them. ,NA,NA
"2- Currently, the can_take/1 predicate only allows the player to take things which are directly located in a ",NA,NA
room. Modify it so it uses the recursive is_contained_in/2 so that a player can take anything in a room. ,NA,NA
Genealogical Logicbase,NA,NA
3- Use recursion to write an ancestor/2 predicate. Then trace it to understand its behavior. It is possible ,NA,NA
to write endless loops with recursive predicates. The trace facility will help you debug ancestor/2 if it is ,NA,NA
not working correctly. ,NA,NA
4- Use ancestor/2 for finding all of a person's ancestors and all of a person's descendants. Based on your ,NA,NA
"experience with grandparent/2 and grandchild/2, write a descendant/2 predicate optimized for ",NA,NA
"descendants, as opposed to ancestor/2, which is optimized for ancestors. ",NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a8recurs.htm (8 of 8)11/3/2006 7:05:35 PM,NA
9,NA,NA
Data Structures,NA,NA
"So far we have worked with facts, queries, and rules that use simple data structures. The arguments to ",NA,NA
"our predicates have all been atoms or integers, the basic building blocks of Prolog. Examples of atoms ",NA,NA
we've used are ,NA,NA
"office, apple, flashlight, nani",NA,NA
These primitive data types can be combined to form arbitrarily complex data types called structures. A ,NA,NA
structure is composed of a functor and a fixed number of arguments. Its form is just like that of the goals ,NA,NA
"and facts we've seen already (for good reason, we'll discover). ",NA,NA
"functor(arg1,arg2,...)",NA,NA
"Each of the structure's arguments can be either a primitive data type or another structure. For example, ",NA,NA
"the things in the game are currently represented using atoms, such as 'desk' or 'apple,' but we can use ",NA,NA
structures to create a richer representation of these things. The following structures describe the object ,NA,NA
"and its color, size, and weight. ",NA,NA
"object(candle, red, small, 1).",NA,NA
"object(apple, red, small, 1).",NA,NA
"object(apple, green, small, 1).",NA,NA
"object(table, blue, big, 50).",NA,NA
"These structures could be used directly in the second argument of location/2, but for experimentation we ",NA,NA
"will instead create a new predicate, location_s/2. Note that even though the structures describing the ",NA,NA
"objects in the game are complex, they still take up only one argument in location_s/2. ",NA,NA
"location_s(object(candle, red, small, 1), kitchen).",NA,NA
"location_s(object(apple, red, small, 1), kitchen).",NA,NA
"location_s(object(apple, green, small, 1), kitchen).",NA,NA
"location_s(object(table, blue, big, 50), kitchen).",NA,NA
"Prolog variables are typeless, and can be bound as easily to structures as to atoms. In fact, an atom is just ",NA,NA
a simple structure with a functor and no arguments. So we can ask ,NA,NA
"?- location_s(X, kitchen).",NA,NA
"X = object(candle, red, small, 1) ; ",NA,NA
"X = object(apple, red, small, 1) ; X ",NA,NA
"= object(apple, green, small, 1) ; X ",NA,NA
"= object(table, blue, big, 50) ; no",NA,NA
We can also pick apart the structure with variables. We can now find all the red things in the kitchen. ,NA,NA
"?- location_s(object(X, red, S, W), kitchen). ",NA,NA
X = candle ,NA,NA
S = small ,NA,NA
W = 1 ;,NA,NA
X = apple ,NA,NA
S = small ,NA,NA
W = 1 ; ,NA,NA
no,NA,NA
"If we didn't care about the size and weight we could replace the size, S, and weight, W, variables with ",NA,NA
the anonymous variable (_). ,NA,NA
"?- location_s(object(X, red, _, _), kitchen). ",NA,NA
X = candle ; ,NA,NA
X = apple ; ,NA,NA
no,NA,NA
"We can use these structures to add more realism to the game. For example, we can modify our ",NA,NA
"can_take/1 predicate, developed in chapter 7, so that we can only take small objects. ",NA,NA
can_take_s(Thing) :-,NA,NA
" here(Room),",NA,NA
" location_s(object(Thing, _, small,_), ",NA,NA
Room).,NA,NA
We can also change the error messages to reflect the two reasons why a thing cannot be taken. To ensure ,NA,NA
"that backtracking does not cause both errors to be displayed, we will construct each clause so its message ",NA,NA
"is displayed only when its unique conditions are met. To do this, the built-in predicate not/1 is used. Its ",NA,NA
"argument is a goal, and it succeeds if its argument fails, and fails if its argument succeeds. For example ",http://www.amzi.com/AdventureInProlog/a9struct.htm (2 of 5)11/3/2006 7:05:41 PM,NA
?- not( room(office) ). ,NA,NA
no,NA,NA
"?- not( location(cabbage, 'living room') ) ",NA,NA
yes,NA,NA
"Note that semantically, not in Prolog means the goal cannot be successfully solved with current ",NA,NA
"logicbase of facts and rules. Here is how we use not/1 in our new version, can_take_s/1. ",NA,NA
can_take_s(Thing) :-< ,NA,NA
" here(Room),",NA,NA
" location_s(object(Thing, _, small, _), Room).",NA,NA
can_take_s(Thing) :-,NA,NA
" here(Room),",NA,NA
" location_s(object(Thing, _, big, _), Room), ",NA,NA
"write('The '), write(Thing), ",NA,NA
" write(' is too big to carry.'), nl,",NA,NA
 fail.,NA,NA
can_take_s(Thing) :-,NA,NA
" here(Room),",NA,NA
" not (location_s(object(Thing, _, _, _), Room)),",NA,NA
" write('There is no '), write(Thing), write(' here.'), nl, ",NA,NA
fail.,NA,NA
"We can now try it, assuming we are in the kitchen. ",NA,NA
?- can_take_s(candle). ,NA,NA
yes,NA,NA
?- can_take_s(table).,NA,NA
The table is too big to carry.,NA,NA
no,NA,NA
?- can_take_s(desk). ,NA,NA
There is no desk here.,NA,NA
no,NA,NA
The list_things/1 predicate can be modified to give a description of the things in a room. ,NA,NA
list_things_s(Place) :- ,NA,NA
" location_s(object(Thing, Color, Size, Weight),Place), ",NA,NA
"write('A '),write(Size),tab(1),",NA,NA
" write(Color),tab(1),",NA,NA
" write(Thing), write(', weighing '), ",NA,NA
"write(Weight), write(' pounds'), nl, ",NA,NA
fail.,NA,NA
list_things_s(_).,NA,NA
Requesting it now gives a more detailed list. ,NA,NA
?- list_things_s(kitchen).,NA,NA
"A small red candle, weighing 1 pounds ",NA,NA
"A small red apple, weighing 1 pounds A ",NA,NA
"small green apple, weighing 1 pounds A ",NA,NA
"big blue table, weighing 50 pounds yes",NA,NA
"If you are bothered by the grammatically incorrect '1 pounds', you can fix it by adding another rule to ",NA,NA
"write the weight, which would replace the direct 'writes' now used. ",NA,NA
write_weight(1) :-,NA,NA
 write('1 pound').,NA,NA
write_weight(W) :-,NA,NA
" W > 1,",NA,NA
" write(W), write(' pounds').",NA,NA
Testing it shows it works as desired. ,NA,NA
?- write_weight(4). ,NA,NA
4 pounds ,NA,NA
yes,NA,NA
?- write_weight(1). ,NA,NA
1 pound ,NA,NA
yes\,NA,NA
"Notice that we did not need to put a test, such as 'W = 1,' in the first clause. By putting the 1 directly in ",NA,NA
the argument at the head of the clause we ensure that that clause will only be fired when the query goal ,NA,NA
is write_weight(1). All other queries will go to the second clause because the goal pattern will fail to ,NA,NA
unify with the head of the first clause. ,NA,NA
"It is important, however, to put the test 'W > 1' in the second rule. Otherwise both rules would work for a ",NA,NA
"weight of 1. The first time the predicate was called would not be a problem, but on backtracking we ",NA,NA
would get two answers if we had not included the test. ,http://www.amzi.com/AdventureInProlog/a9struct.htm (4 of 5)11/3/2006 7:05:41 PM,NA
"Structures can be arbitrarily complex, so if we wanted to get fancy about things in the game we could ",NA,NA
"keep their dimensions (length, width, height) instead of their size as part of their description. ",NA,NA
"object(desk, brown, dimension(6,3,3), 90). ",NA,NA
We can also use embedded structures for clarity. ,NA,NA
"object(desk, color(brown), size(large), weight(90)) ",NA,NA
A query using these structures is more readable. ,NA,NA
"location_s(object(X, _, size(large), _), office).",NA,NA
Notice that the position of the arguments is important. The place-holding anonymous variables are ,NA,NA
essential for getting the correct results. ,NA,NA
Exercises ,NA,NA
Adventure Game ,NA,NA
"1- Incorporate the new location into the game. Note that due to data and procedure abstraction, we need ",NA,NA
"only change the low level predicates that deal directly with location. The higher level predicates, such as ",NA,NA
look/0 and take/1 are unaffected by the change. ,NA,NA
Customer Order Entry ,NA,NA
"2- Use structures to enhance the customer order entry application. For example, include a structure for ",NA,NA
each customers address. ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a9struct.htm (5 of 5)11/3/2006 7:05:41 PM,NA
10,NA,NA
Unification,NA,NA
"One of Prolog's most powerful features is its built-in pattern-matching algorithm, unification. For all of the ",NA,NA
"examples we have seen so far, unification has been relatively simple. We will now examine unification more ",NA,NA
closely. ,NA,NA
"The full definition of unification is similar to the one given in chapter 3, with the addition of a recursive definition to ",NA,NA
handle data structures. This following table summarizes the unification process. ,NA,NA
variable ,NA,NA
& ,NA,NA
any term ,NA,NA
primitive ,NA,NA
& ,NA,NA
primitive ,NA,NA
structure ,NA,NA
& ,NA,NA
structure ,NA,NA
The variable will unify with and is bound to ,NA,NA
"any term, including another variable. ",NA,NA
Two primitive terms (atoms or integers) ,NA,NA
unify only if they are identical. ,NA,NA
Two structures unify if they have the same ,NA,NA
functor and arity and if each pair of ,NA,NA
corresponding arguments unify. ,NA,NA
"In order to experiment with unification we will introduce the built-in predicate =/2, which succeeds if its two ",NA,NA
arguments unify and fails if they do not. It can be written in operator syntax as follows. ,NA,NA
arg1 = arg2,NA,NA
which is equivalent to ,NA,NA
"=(arg1, arg2)",NA,NA
"WARNING: The equal sign (=) does not cause assignment as in most programming languages, nor does it cause ",NA,NA
"arithmetic evaluation. It causes Prolog unification. (Despite this warning, if you are like most mortal programmers, ",NA,NA
you will be tripped up by this difference more than once.) ,NA,NA
Unification between two sides of an equal sign (=) is exactly the same as the unification that occurs when Prolog ,NA,NA
"tries to match goals with the heads of clauses. On backtracking, the variable bindings are undone, just as they are ",NA,NA
when Prolog backtracks through clauses. ,http://www.amzi.com/AdventureInProlog/a10unif.htm (1 of 5)11/3/2006 7:05:45 PM,NA
"The simplest form of unification occurs between two structures with no variables. In this case, either they are ",NA,NA
"identical and unification succeeds, or they are not, and unification fails. ",NA,NA
?- a = a. ,NA,NA
yes,NA,NA
?- a = b. ,NA,NA
no,NA,NA
"?- location(apple, kitchen) = ",NA,NA
"location(apple, kitchen).",NA,NA
yes,NA,NA
"?- location(apple, kitchen) = ",NA,NA
"location(pear, kitchen).",NA,NA
no,NA,NA
"?- a(b,c(d,e(f,g))) = a(b,c(d,e(f,g))). ",NA,NA
yes,NA,NA
"?- a(b,c(d,e(f,g))) = a(b,c(d,e(g,f))). ",NA,NA
no,NA,NA
Another simple form of unification occurs between a variable and a primitive. The variable takes on a value that ,NA,NA
causes unification to succeed. ,NA,NA
?- X = a. ,NA,NA
X = a ,NA,NA
?- 4 = Y. ,NA,NA
Y = 4 ,NA,NA
"?- location(apple, kitchen) = location(apple, X). ",NA,NA
X = kitchen ,NA,NA
In other cases multiple variables are simultaneously bound to values. ,NA,NA
"?- location(X,Y) = location(apple, kitchen).",NA,NA
X = apple ,NA,NA
Y = kitchen ,NA,NA
"?- location(apple, X) = location(Y, kitchen). ",NA,NA
X = kitchen ,NA,NA
Y = apple ,NA,NA
Variables can also unify with each other. Each instance of a variable has a unique internal Prolog value. When two ,http://www.amzi.com/AdventureInProlog/a10unif.htm (2 of 5)11/3/2006 7:05:45 PM,NA
"variables are unified to each other, Prolog notes that they must have the same value. In the following example, it is ",NA,NA
"assumed Prolog uses '_nn,' where 'n' is a digit, to represent unbound variables. ",NA,NA
?- X = Y. ,NA,NA
X = _01 ,NA,NA
Y = _01 ,NA,NA
"?- location(X, kitchen) = location(Y, kitchen). ",NA,NA
X = _01 ,NA,NA
Y = _01 ,NA,NA
Prolog remembers the fact that the variables are bound together and will reflect this if either is later bound. ,NA,NA
"?- X = Y, Y = hello. ",NA,NA
X = hello ,NA,NA
Y = hello ,NA,NA
"?- X = Y, a(Z) = a(Y), X = hello. ",NA,NA
X = hello ,NA,NA
Y = hello ,NA,NA
Z = hello ,NA,NA
The last example is critical to a good understanding of Prolog and illustrates a major difference between unification ,NA,NA
with Prolog variables and assignment with variables found in most other languages. Note carefully the behavior of ,NA,NA
the following queries. ,NA,NA
"?- X = Y, Y = 3, write(X).",NA,NA
3 ,NA,NA
X = 3 ,NA,NA
Y = 3 ,NA,NA
"?- X = Y, tastes_yucky(X), write(Y).",NA,NA
broccoli ,NA,NA
X = broccoli ,NA,NA
Y = broccoli ,NA,NA
"When two structures with variables are unified with each other, the variables take on values that make the two ",NA,NA
structures identical. Note that a structure bound to a variable can itself contain variables. ,NA,NA
"?- X = a(b,c). ",NA,NA
"X = a(b,c) ",NA,NA
"?- a(b,X) = a(b,c(d,e)). ",NA,NA
"X = c(d,e) ",NA,NA
"?- a(b,X) = a(b,c(Y,e)). ",NA,NA
"X = c(_01,e)",http://www.amzi.com/AdventureInProlog/a10unif.htm (3 of 5)11/3/2006 7:05:45 PM,NA
Y = _01 ,NA,NA
"Even in these more complex examples, the relationships between variables are remembered and updated as new ",NA,NA
variable bindings occur. ,NA,NA
"?- a(b,X) = a(b,c(Y,e)), Y = hello. ",NA,NA
"X = c(hello, e) ",NA,NA
Y = hello,NA,NA
"?- food(X,Y) = Z, write(Z), nl, tastes_yucky(X), edible(Y), write(Z).",NA,NA
"food(_01,_02) ",NA,NA
"food(broccoli, apple) ",NA,NA
X = broccoli ,NA,NA
Y = apple ,NA,NA
"Z = food(broccoli, apple) ",NA,NA
"If a new value assigned to a variable in later goals conflicts with the pattern set earlier, the goal fails. ",NA,NA
"?- a(b,X) = a(b,c(Y,e)), X = hello. ",NA,NA
no,NA,NA
"The second goal failed since there is no value of Y that will allow hello to unify with c(Y,e). The following will ",NA,NA
succeed. ,NA,NA
"?- a(b,X) = a(b,c(Y,e)), X = c(hello, e). ",NA,NA
"X = c(hello, e) ",NA,NA
Y = hello ,NA,NA
"If there is no possible value the variable can take on, then unification fails. ",NA,NA
"?- a(X) = a(b,c). ",NA,NA
no,NA,NA
"?- a(b,c,d) = a(X,X,d). ",NA,NA
no,NA,NA
"The last example failed because the pattern asks that the first two arguments be the same, and they aren't. ",NA,NA
"?- a(c,X,X) = a(Y,Y,b). ",NA,NA
no,NA,NA
Did you understand why this example fails? Matching the first argument binds Y to c. The second argument causes ,NA,NA
"X and Y to have the same value, in this case c. The third argument asks that X bind to b, but it is already bound to c. ",NA,NA
No value of X and Y will allow these two structures to unify. ,http://www.amzi.com/AdventureInProlog/a10unif.htm (4 of 5)11/3/2006 7:05:45 PM,NA
"The anonymous variable (_) is a wild variable, and does not bind to values. Multiple occurrences of it do not imply ",NA,NA
equal values. ,NA,NA
"?- a(c,X,X) = a(_,_,b).",NA,NA
X = b ,NA,NA
"Unification occurs explicitly when the equal (=) built-in predicate is used, and implicitly when Prolog searches for ",NA,NA
the head of a clause that matches a goal pattern. ,NA,NA
Exercises ,NA,NA
Nonsense Prolog,NA,NA
Predict the results of these unification queries. ,NA,NA
"?- a(b,c) = a(X,Y).",NA,NA
"?- a(X,c(d,X)) = a(2,c(d,Y)).",NA,NA
"?- a(X,Y) = a(b(c,Y),Z).",NA,NA
"?- tree(left, root, Right) = tree(left, root, tree(a, b, tree(c, d, e))).","Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved
  
 http://www.amzi.com/AdventureInProlog/a10unif.htm (5 of 5)11/3/2006 7:05:45 PM",NA
11,NA,NA
Lists,NA,NA
Lists are powerful data structures for holding and manipulating groups of things. ,NA,NA
"In Prolog, a list is simply a collection of terms. The terms can be any Prolog data types, including ",NA,NA
"structures and other lists. Syntactically, a list is denoted by square brackets with the terms separated by ",NA,NA
"commas. For example, a list of things in the kitchen is represented as ",NA,NA
" [apple, broccoli, refrigerator]",NA,NA
This gives us an alternative way of representing the locations of things. Rather than having separate ,NA,NA
"location predicates for each thing, we can have one location predicate per container, with a list of things ",NA,NA
in the container. ,NA,NA
"loc_list([apple, broccoli, crackers], kitchen).",NA,NA
"loc_list([desk, computer], office).",NA,NA
"loc_list([flashlight, envelope], desk).",NA,NA
"loc_list([stamp, key], envelope).",NA,NA
"loc_list(['washing machine'], cellar).",NA,NA
"loc_list([nani], 'washing machine').",NA,NA
"There is a special list, called the empty list, which is represented by a set of empty brackets ([]). It is also ",NA,NA
referred to as ,NA,NA
nil,NA,NA
. It can describe the lack of contents of a place or thing. ,NA,NA
"loc_list([], hall)",NA,NA
Unification works on lists just as it works on other data structures. With what we now know about lists ,NA,NA
we can ask ,NA,NA
"?- loc_list(X, kitchen).",NA,NA
"X = [apple, broccoli, crackers] ",NA,NA
"?- [_,X,_] = [apples, broccoli, crackers].",NA,NA
X = broccoli ,NA,NA
"This last example is an impractical method of getting at list elements, since the patterns won't unify ",NA,NA
unless both lists have the same number of elements. ,NA,NA
"For lists to be useful, there must be easy ways to access, add, and delete list elements. Moreover, we ",NA,NA
"should not have to concern ourselves about the number of list items, or their order. ",NA,NA
Two Prolog features enable us to accomplish this easy access. One is a special notation that allows ,NA,NA
"reference to the first element of a list and the list of remaining elements, and the other is recursion. ",NA,NA
"These two features allow us to write list utility predicates, such as member/2, which finds members of a ",NA,NA
"list, and append/3, which joins two lists together. List predicates all follow a similar strategy--try ",NA,NA
"something with the first element of a list, then recursively repeat the process on the rest of the list. ",NA,NA
"First, the special notation for list structures. ",NA,NA
 [X | Y],NA,NA
"When this structure is unified with a list, X is bound to the first element of the list, called the ",NA,NA
head,NA,NA
. Y is ,NA,NA
"bound to the list of remaining elements, called the ",NA,NA
tail,NA,NA
. ,NA,NA
We will now look at some examples of unification using lists. The following example successfully ,NA,NA
unifies because the two structures are syntactically equivalent. Note that the tail is a list. ,NA,NA
"?- [a|[b,c,d]] = [a,b,c,d].",NA,NA
yes,NA,NA
This next example fails because of misuse of the bar (|) symbol. What follows the bar must be a single ,NA,NA
"term, which for all practical purposes must be a list. The example incorrectly has three terms after the ",NA,NA
bar. ,NA,NA
"?- [a|b,c,d] = [a,b,c,d].",NA,NA
no,NA,NA
Here are some more examples. ,NA,NA
"?- [H|T] = [apple, broccoli, refrigerator].",NA,NA
H = apple,NA,NA
"T = [broccoli, refrigerator] ",NA,NA
"?- [H|T] = [a, b, c, d, e].",NA,NA
H = a ,NA,NA
"T = [b, c, d, e] ",NA,NA
"?- [H|T] = [apples, bananas].",NA,NA
H = apples ,NA,NA
T = [bananas] ,NA,NA
"In the previous and following examples, the tail is a list with one element. ",NA,NA
"?- [H|T] = [a, [b,c,d]].",NA,NA
H = a ,NA,NA
"T = [[b, c, d]] ",NA,NA
"In the next case, the tail is the empty list. ",NA,NA
?- [H|T] = [apples]. ,NA,NA
H = apples ,NA,NA
T = [] ,NA,NA
The empty list does not unify with the standard list syntax because it has no head. ,NA,NA
?- [H|T] = []. ,NA,NA
no,NA,NA
"NOTE: This last failure is important, because it is often used to test for the boundary condition in a ",NA,NA
"recursive routine. That is, as long as there are elements in the list, a unification with the [X|Y] pattern ",NA,NA
"will succeed. When there are no elements in the list, that unification fails, indicating that the boundary ",NA,NA
condition applies. ,NA,NA
"We can specify more than just the first element before the bar (|). In fact, the only rule is that what ",NA,NA
follows it should be a list. ,NA,NA
"?- [One, Two | T] = [apple, sprouts, fridge, milk].",NA,NA
One = apple ,NA,NA
Two = sprouts ,NA,NA
"T = [fridge, milk] ",NA,NA
Notice in the next examples how each of the variables is bound to a structure that shows the ,NA,NA
relationships between the variables. The internal variable numbers indicate how the variables are related. ,NA,NA
"In the first example Z, the tail of the right-hand list, is unified with [Y|T]. In the second example T, the ",NA,NA
"tail of the left-hand list is unified with [Z]. In both cases, Prolog looks for the most general way to relate ",NA,NA
or bind the variables. ,NA,NA
"?- [X,Y|T] = [a|Z].",NA,NA
X = a ,NA,NA
Y = _01 ,NA,NA
T = _03 ,NA,NA
Z = [_01 | _03] ,NA,NA
"?- [H|T] = [apple, Z]. ",NA,NA
H = apple ,NA,NA
T = [_01] ,NA,NA
Z = _01 ,NA,NA
"Study these last two examples carefully, because list unification is critical in building list utility ",NA,NA
predicates. ,NA,NA
"A list can be thought of as a head and a tail list, whose head is the second element and whose tail is a list ",NA,NA
"whose head is the third element, and so on. ",NA,NA
"?- [a|[b|[c|[d|[]]]]] = [a,b,c,d]. ",NA,NA
yes,NA,NA
"We have said a list is a special kind of structure. In a sense it is, but in another sense it is just like any ",NA,NA
other Prolog term. The last example gives us some insight into the true nature of the list. It is really an ,NA,NA
ordinary two-argument predicate. The first argument is the head and the second is the tail. If we called it ,NA,NA
"dot/2, then the list [a,b,c,d] would be ",NA,NA
"dot(a,dot(b,dot(c,dot(d,[]))))",NA,NA
"In fact, the predicate does exist, at least conceptually, and it is called dot, but it is represented by a ",NA,NA
period (.) instead of dot. ,NA,NA
"To see the dot notation, we use the built-in predicate display/1, which is similar to write/1, except it ",NA,NA
always uses the dot syntax for lists when it writes to the console. ,NA,NA
"?- X = [a,b,c,d], write(X), nl, display(X), nl.",NA,NA
" [a,b,c,d] ",NA,NA
".(a,.(b,.(c,.d(,[]))))",NA,NA
"?- X = [Head|Tail], write(X), nl, display(X), nl. ",NA,NA
"[_01, _02] ",NA,NA
".(_01,_02)",http://www.amzi.com/AdventureInProlog/a11lists.htm (4 of 14)11/3/2006 7:05:48 PM,NA
"?- X = [a,b,[c,d],e], write(X), nl, display(X), nl.",NA,NA
" [a,b,[c,d],e] ",NA,NA
".(a,.(b,.(.(c,.(d,[])),.(e,[]))))",NA,NA
From these examples it should be clear why there is a different syntax for lists. The easier syntax makes ,NA,NA
"for easier reading, but sometimes obscures the behavior of the predicate. It helps to keep this ""real"" ",NA,NA
structure of lists in mind when working with predicates that manipulate lists. ,NA,NA
This structure of lists is well-suited for the writing of recursive routines. The first one we will look at is ,NA,NA
"member/2, which determines whether or not a term is a member of a list. ",NA,NA
"As with most recursive predicates, we will start with the boundary condition, or the simple case. An ",NA,NA
element is a member of a list if it is the head of the list. ,NA,NA
"member(H,[H|T]).",NA,NA
This clause also illustrates how a fact with variable arguments acts as a rule. ,NA,NA
The second clause of member/2 is the recursive rule. It says an element is a member of a list if it is a ,NA,NA
member of the tail of the list. ,NA,NA
"member(X,[H|T]) :- member(X,T).",NA,NA
The full predicate is ,NA,NA
"member(H,[H|T]).",NA,NA
"member(X,[H|T]) :- member(X,T).",NA,NA
Note that both clauses of member/2 expect a list as the second argument. Since T in [H|T] in the second ,NA,NA
"clause is itself a list, the recursive call to member/2 works. ",NA,NA
"?- member(apple, [apple, broccoli, crackers]). ",NA,NA
yes,NA,NA
"?- member(broccoli, [apple, broccoli, crackers]). ",NA,NA
yes,NA,NA
"?- member(banana, [apple, broccoli, crackers]). ",NA,NA
no,NA,NA
Figure 11.1 has a full annotated trace of member/2. ,http://www.amzi.com/AdventureInProlog/a11lists.htm (5 of 14)11/3/2006 7:05:48 PM,NA
The query is ,NA,NA
"?- member(b, [a,b,c]).",NA,NA
"1-1 CALL member(b,[a,b,c]) ",NA,NA
"The goal pattern fails to unify with the head of the first clause of member/2, because the pattern in the ",NA,NA
head of the first clause calls for the head of the list and first argument to be identical. The goal pattern ,NA,NA
can unify with the head of the second clause.,NA,NA
"1-1 try (2) member(b,[a,b,c]) ",NA,NA
The second clause recursively calls another copy of member/2.,NA,NA
" 2-1 CALL member(b,[b,c]) ",NA,NA
It succeeds because the call pattern unifies with the head of the first clause.,NA,NA
" 2-1 EXIT (1) member(b,[b,c]) ",NA,NA
The success ripples back to the outer level.,NA,NA
"1-1 EXIT (2) member(b,[a,b,c]) ",NA,NA
 yes,NA,NA
Figure 11.1. Trace of member/2 ,NA,NA
"As with many Prolog predicates, member/2 can be used in multiple ways. If the first argument is a ",NA,NA
"variable, member/2 will, on backtracking, generate all of the terms in a given list. ",NA,NA
"?- member(X, [apple, broccoli, crackers]).",NA,NA
X = apple ; ,NA,NA
X = broccoli ; ,NA,NA
X = crackers ; ,NA,NA
no,NA,NA
We will now trace this use of member/2 using the internal variables. Remember that each level has its ,NA,NA
"own unique variables, but that they are tied together based on the unification patterns between the goal ",http://www.amzi.com/AdventureInProlog/a11lists.htm (6 of 14)11/3/2006 7:05:48 PM,NA
at one level and the head of the clause on the next level. ,NA,NA
In this case the pattern is simple in the recursive clause of member. The head of the clause unifies X with ,NA,NA
"the first argument of the original goal, represented by _0 in the following trace. The body has a call to ",NA,NA
"member/2 in which the first argument is also X, therefore causing the next level to unify with the same ",NA,NA
_0. ,NA,NA
Figure 11.2 has the trace. ,NA,NA
The query is ,NA,NA
"?- member(X,[a,b,c]).",NA,NA
"The goal succeeds by unification with the head of the first clause, if X = a.",NA,NA
"1-1 CALL member(_0,[a,b,c]) ",NA,NA
"1-1 EXIT (1) member(a,[a,b,c]) ",NA,NA
 X = a ;,NA,NA
Backtracking unbinds the variable and the second clause is tried.,NA,NA
"1-1 REDO member(_0,[a,b,c]) ",NA,NA
"1-1 try (2) member(_0,[a,b,c])",NA,NA
"It succeeds on the second level, just as on the first level.",NA,NA
" 2-1 CALL member(_0,[b,c]) ",NA,NA
" 2-1 EXIT (1) member(b,[b,c]) ",NA,NA
"1-1 EXIT  member(b,[a,b,c]) ",NA,NA
 X = b ;,NA,NA
"Backtracking continues onto the third level, with similar results.",NA,NA
" 2-1 REDO member(_0,[b,c]) ",NA,NA
" 2-1 try (2) member(_0,[b,c])",NA,NA
" 3-1 CALL member(_0,[c]) ",NA,NA
 ,NA,NA
"3-1 EXIT (1) member(c,[c]) ",NA,NA
 2-1 ,NA,NA
"EXIT (2) member(c,[b,c]) 1-1 EXIT ",NA,NA
"(2) member(c,[a,b,c]) ",NA,NA
 X = c ;,http://www.amzi.com/AdventureInProlog/a11lists.htm (7 of 14)11/3/2006 7:05:48 PM,NA
Further backtracking causes an attempt to find a member of the empty list. The empty list does not ,NA,NA
"unify with either of the list patterns in the member/2 clauses, so the query fails back to the beginning.",NA,NA
" 3-1 REDO member(_0,[c]) ",NA,NA
" 3-1 try (2) member(_0,[c])",NA,NA
" 4-1 CALL member(_0,[])",NA,NA
" 4-1 FAIL member(_0,[])",NA,NA
" 3-1 FAIL member(_0,[c])",NA,NA
" 2-1 FAIL member(_0,[b,c]) ",NA,NA
"1-1 FAIL member(_0,[a,b,c])",NA,NA
 no,NA,NA
Figure 11.2. Trace of member/2 generating elements of a list ,NA,NA
Another very useful list predicate builds lists from other lists or alternatively splits lists into separate ,NA,NA
pieces. This predicate is usually called append/3. In this predicate the second argument is appended to ,NA,NA
the first argument to yield the third argument. For example ,NA,NA
"?- append([a,b,c],[d,e,f],X). ",NA,NA
"X = [a,b,c,d,e,f]",NA,NA
"It is a little more difficult to follow, since the basic strategy of working from the head of the list does not ",NA,NA
fit nicely with the problem of adding something to the end of a list. append/3 solves this problem by ,NA,NA
reducing the first list recursively. ,NA,NA
"The boundary condition states that if a list X is appended to the empty list, the resulting list is also X. ",NA,NA
"append([],X,X).",NA,NA
"The recursive condition states that if list X is appended to list [H|T1], then the head of the new list is also ",NA,NA
"H, and the tail of the new list is the result of appending X to the tail of the first list. ",NA,NA
"append([H|T1],X,[H|T2]) :-",NA,NA
" append(T1,X,T2).",NA,NA
The full predicate is ,NA,NA
"append([],X,X).",NA,NA
"append([H|T1],X,[H|T2]) :-",NA,NA
" append(T1,X,T2).",http://www.amzi.com/AdventureInProlog/a11lists.htm (8 of 14)11/3/2006 7:05:48 PM,NA
"Real Prolog magic is at work here, which the trace alone does not reveal. At each level, new variable ",NA,NA
"bindings are built, that are unified with the variables of the previous level. Specifically, the third ",NA,NA
argument in the recursive call to append/3 is the tail of the third argument in the head of the clause. ,NA,NA
These variable relationships are included at each step in the annotated trace shown in Figure 11.3. ,NA,NA
The query is ,NA,NA
"?- append([a,b,c],[d,e,f],X).",NA,NA
"1-1 CALL append([a,b,c],[d,e,f],_0)",NA,NA
 X = _0,NA,NA
" 2-1 CALL append([b,c],[d,e,f],_5)",NA,NA
 _0 = [a|_5],NA,NA
" 3-1 CALL append([c],[d,e,f],_9)",NA,NA
 _5 = [b|_9],NA,NA
" 4-1 CALL append([],[d,e,f],_14)",NA,NA
 _9 = [c|_14],NA,NA
"By making all the substitutions of the variable relationships, we can see that at this point X is bound ",NA,NA
as follows (thinking in terms of the dot notation for lists might make append/3 easier to understand).,NA,NA
X = [a|[b|[c|_14]]],NA,NA
"We are about to hit the boundary condition, as the first argument has been reduced to the empty list. ",NA,NA
"Unifying with the first clause of append/3 will bind _14 to a value, namely [d,e,f], thus giving us the ",NA,NA
"desired result for X, as well as all the other intermediate variables. Notice the bound third arguments ",NA,NA
"at each level, and compare them to the variables in the call ports above.",NA,NA
" 4-1 EXIT (1) append([],[d,e,f],[d,e,f])",NA,NA
" 3-1 EXIT (2) append([c],[d,e,f],[c,d,e,f])",NA,NA
 2-1 ,NA,NA
"EXIT (2) append([b,c],[d,e,f],[b,c,d,e,f]) 1-1 EXIT ",NA,NA
"(2)append([a,b,c],[d,e,f],[a,b,c,d,e,f])",NA,NA
 X = ,NA,NA
"[a,b,c,d,e,f] ",NA,NA
Figure 11.3. Trace of append/3 ,NA,NA
"Like member/2, append/3 can also be used in other ways, for example, to break lists apart as follows. ",NA,NA
"?- append(X,Y,[a,b,c]).",http://www.amzi.com/AdventureInProlog/a11lists.htm (9 of 14)11/3/2006 7:05:48 PM,NA
X = [] ,NA,NA
"Y = [a,b,c] ;",NA,NA
X = [a] ,NA,NA
"Y = [b,c] ;",NA,NA
"X = [a,b] ",NA,NA
Y = [c] ;,NA,NA
"X = [a,b,c] ",NA,NA
Y = [] ; ,NA,NA
no,NA,NA
Using the List Utilities ,NA,NA
"Now that we have tools for manipulating lists, we can use them. For example, if we choose to use ",NA,NA
"loc_list/2 instead of location/2 for storing things, we can write a new location/2 that behaves exactly like ",NA,NA
"the old one, except that it computes the answer rather than looking it up. This illustrates the sometimes ",NA,NA
"fuzzy line between data and procedure. The rest of the program cannot tell how location/2 gets its results, ",NA,NA
"whether as data or by computation. In either case it behaves the same, even on backtracking. ",NA,NA
"location(X,Y):- ",NA,NA
" loc_list(List, Y),",NA,NA
" member(X, List).",NA,NA
"In the game, it will be necessary to add things to the loc_lists whenever something is put down in a room. ",NA,NA
"We can write add_thing/3 which uses append/3. If we call it with NewThing and Container, it will ",NA,NA
provide us with the NewList. ,NA,NA
"add_thing(NewThing, Container, NewList):-  ",NA,NA
"loc_list(OldList, Container),",NA,NA
" append([NewThing],OldList, NewList).",NA,NA
Testing it gives ,NA,NA
"?- add_thing(plum, kitchen, X).",NA,NA
"X = [plum, apple, broccoli, crackers]",NA,NA
"However, this is a case where the same effect can be achieved through unification and the [Head|Tail] ",NA,NA
list notation. ,NA,NA
"add_thing2(NewThing, Container, NewList):- ",http://www.amzi.com/AdventureInProlog/a11lists.htm (10 of 14)11/3/2006 7:05:48 PM,NA
" loc_list(OldList, Container),",NA,NA
 NewList = [NewThing | OldList].,NA,NA
It works the same as the other one. ,NA,NA
"?- add_thing2(plum, kitchen, X).",NA,NA
"X = [plum, apple, broccoli, crackers]",NA,NA
"We can simplify it one step further by removing the explicit unification, and using the implicit ",NA,NA
"unification that occurs at the head of a clause, which is the preferred form for this type of predicate. ",NA,NA
"add_thing3(NewTh, Container,[NewTh|OldList]) :- ",NA,NA
"loc_list(OldList, Container).",NA,NA
It also works the same. ,NA,NA
"?- add_thing3(plum, kitchen, X).",NA,NA
"X = [plum, apple, broccoli, crackers]",NA,NA
"In practice, we might write put_thing/2 directly without using the separate add_thing/3 predicate to build ",NA,NA
a new list for us. ,NA,NA
"put_thing(Thing,Place) :-",NA,NA
" retract(loc_list(List, Place)),",NA,NA
" asserta(loc_list([Thing|List],Place)).",NA,NA
"Whether you use multiple logicbase entries or lists for situations, such as we have with locations of ",NA,NA
"things, is largely a matter of style. Your experience will lead you to one or the other in different ",NA,NA
situations. Sometimes backtracking over multiple predicates is a more natural solution to a problem and ,NA,NA
sometimes recursively dealing with a list is more natural. ,NA,NA
You might find that some parts of a particular application fit better with multiple facts in the logicbase ,NA,NA
and other parts fit better with lists. In these cases it is useful to know how to go from one format to the ,NA,NA
other. ,NA,NA
Going from a list to multiple facts is simple. You write a recursive routine that continually asserts the ,NA,NA
head of the list. In this example we create individual facts in the predicate stuff/1. ,NA,NA
break_out([]).,NA,NA
break_out([Head | Tail]):-,NA,NA
" assertz(stuff(Head)),",NA,NA
 break_out(Tail).,http://www.amzi.com/AdventureInProlog/a11lists.htm (11 of 14)11/3/2006 7:05:48 PM,NA
Here's how it works. ,NA,NA
"?- break_out([pencil, cookie, snow]). ",NA,NA
yes,NA,NA
?- stuff(X). ,NA,NA
X = pencil ; ,NA,NA
X = cookie ; ,NA,NA
X = snow ; ,NA,NA
no,NA,NA
Transforming multiple facts into a list is more difficult. For this reason most Prologs provide built-in ,NA,NA
predicates that do the job. The most common one is findall/3. The arguments are ,NA,NA
arg1 ,NA,NA
arg2 ,NA,NA
arg3 ,NA,NA
A pattern for the terms in the resulting list ,NA,NA
A goal pattern ,NA,NA
The resulting list ,NA,NA
findall/3 automatically does a full backtracking search of the goal pattern and stores each result in the ,NA,NA
list. It can recover our stuff/1 back into a list. ,NA,NA
"?- findall(X, stuff(X), L). ",NA,NA
"L = [pencil, cookie, snow]",NA,NA
Fancier patterns are available. This is how to get a list of all the rooms connecting to the kitchen. ,NA,NA
"?- findall(X, connect(kitchen, X), L). ",NA,NA
"L = [office, cellar, 'dining room']",NA,NA
The pattern in the first argument can be even fancier and the second argument can be a conjunction of ,NA,NA
"goals. Parentheses are used to group the conjunction of goals in the second argument, thus avoiding the ",NA,NA
potential ambiguity. Here findall/3 builds a list of structures that locates the edible things. ,NA,NA
"?- findall(foodat(X,Y), (location(X,Y) , edible(X)), L). ",NA,NA
"L = [foodat(apple, kitchen), foodat(crackers, kitchen)]",NA,NA
Exercises ,http://www.amzi.com/AdventureInProlog/a11lists.htm (12 of 14)11/3/2006 7:05:48 PM,NA
List Utilities,NA,NA
1- Write list utilities that perform the following functions. ,G,NA
Remove a given element from a list ,G,NA
Find the element after a given element ,G,NA
Split a list into two lists at a given element (Hint - append/3 is close.) ,G,NA
Get the last element of a list ,G,NA
"Count the elements in a list (Hint - the length of the empty list is 0, the length a non-empty list is 1 ",NA,NA
+ the length of its tail.) ,NA,NA
"2- Because write/1 only takes a single argument, multiple 'writes' are necessary for writing a mixed ",NA,NA
string of text and variables. Write a list utility respond/1 which takes as its single argument a list of ,NA,NA
terms to be written. This can be used in the game to communicate with the player. For example ,NA,NA
"respond(['You can''t get to the', Room, 'from here'])",NA,NA
"3- Lists with a variable tail are called open lists. They have some interesting properties. For example, ",NA,NA
member/2 can be used to add items to an open list. Experiment with and trace the following queries. ,NA,NA
"?- member(a,X).",NA,NA
"?- member(b, [a,b,c|X]).",NA,NA
"?- member(d, [a,b,c|X]).",NA,NA
"?- OpenL = [a,b,c|X], member(d, OpenL), write(OpenL).",NA,NA
Nonsense Prolog,NA,NA
4- Predict the results of the following queries. ,NA,NA
"?- [a,b,c,d] = [H|T].",NA,NA
"?- [a,[b,c,d]] = [H|T].",NA,NA
?- [] = [H|T].,NA,NA
?- [a] = [H|T].,NA,NA
"?- [apple,3,X,'What?'] = [A,B|Z].",NA,NA
"?- [[a,b,c],[d,e,f],[g,h,i]] = [H|T]. ?- ",NA,NA
"[a(X,c(d,Y)), b(2,3), c(d,Y)] = [H|T].",NA,NA
Genealogical Logicbase,NA,NA
5- Consider the following Prolog program ,NA,NA
"parent(p1,p2)",NA,NA
. ,NA,NA
"parent(p2,p3)",NA,NA
. ,NA,NA
"parent(p3,p4)",NA,NA
. ,NA,NA
"parent(p4,p5)",NA,NA
.,NA,NA
"ancestor(A,D,[A]) :- parent(A,D). ",NA,NA
"ancestor(A,D,[X|Z]) :-",NA,NA
" parent(X,D),",NA,NA
" ancestor(A,X,Z).",NA,NA
6- What is the purpose of the third argument to ancestor? ,NA,NA
7- Predict the response to the following queries. Check by tracing in Prolog. ,NA,NA
?- ,NA,NA
"ancestor(a2,a3,X). ",NA,NA
?- ,NA,NA
"ancestor(a1,a5,X). ",NA,NA
?- ,NA,NA
"ancestor(a5,a1,X). ",NA,NA
"?- ancestor(X,a5,Z).",NA,NA
Expert System,NA,NA
8- Lists provide a convenient way to provide a simple menu capability to our expert system. We can ,NA,NA
replace the 'ask' predicate with menuask/3 where appropriate. menuask/3 will ask the player to select an ,NA,NA
item from a menu. The format is ,NA,NA
"menuask(Attribute, Value, List_of_Choices).",NA,NA
For example ,NA,NA
"size(X):- menuask(size, X, [large, medium, small]).",NA,NA
"This requires two intermediate predicates, menu_display/2 and menu_select/2. The first writes each ",NA,NA
choice on a separate line preceded by a unique number. The second uses a number entered by the user to ,NA,NA
"return the ""nth"" element of the list. ",NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",NA,NA
12,NA,NA
Operators,NA,NA
We have seen that the form of a Prolog data structure is ,NA,NA
"functor(arg1,arg2,...,argN).",NA,NA
"This is the ONLY data structure in Prolog. However, Prolog allows for other ways to syntactically ",NA,NA
represent the same data structure. These other representations are sometimes called syntactic sugaring. ,NA,NA
The equivalence between list syntax and the dot (.) functor is one example. Operator syntax is another. ,NA,NA
Chapter 6 introduced arithmetic operators. In this chapter we will equate them to the standard Prolog ,NA,NA
"data structures, and learn how to define any functor to be an operator. ",NA,NA
"Each arithmetic operator is an ordinary Prolog functor, such as -/2, +/2, and -/1. The display/1 predicate ",NA,NA
can be used to see the standard syntax. ,NA,NA
?- display(2 + 2).,NA,NA
"+(2,2)",NA,NA
?- display(3 * 4 + 6).,NA,NA
"+(*(3,4),6)",NA,NA
?- display(3 * (4 + 6)).,NA,NA
"*(3,+(4,6))",NA,NA
"You can define any functor to be an operator, in which case the Prolog listener will be able to read the ",NA,NA
"structure in a different format. For example, if location/2 was an operator we could write ",NA,NA
apple location kitchen.,NA,NA
instead of ,NA,NA
"location(apple, kitchen).",http://www.amzi.com/AdventureInProlog/a12oper.htm (1 of 8)11/3/2006 7:05:52 PM,NA
NOTE: The fact that location is an operator is of NO significance to Prolog's pattern matching. It simply ,NA,NA
means there is an alternative way of writing the same term. ,NA,NA
Operators are of three types. ,NA,NA
infix ,NA,NA
Example: 3 + 4 ,NA,NA
prefix ,NA,NA
Example: -7 ,NA,NA
postfix ,NA,NA
Example: 8 factorial ,NA,NA
They have a number representing precedence which runs from 1 to 1200. When a term with multiple ,NA,NA
"operators is converted to pure syntax, the operators with higher precedences are converted first. A high ",NA,NA
precedence is indicated by a low number. ,NA,NA
"Operators are defined with the built-in predicate op/3, whose three arguments are precedence, ",NA,NA
"associativity, and the operator name. ",NA,NA
Associativity in the second argument is represented by a pattern that defines the type of operator. The ,NA,NA
first example we will see is the definition of an infix operator which uses the associativity pattern 'xfx.' ,NA,NA
The 'f' indicates the position of the operator in respect to its arguments. We will see other patterns as we ,NA,NA
proceed. ,NA,NA
"For our current purposes, we will again rework the location/2 predicate and rename it is_in/2 to go with ",NA,NA
"its new look, and we will represent rooms in the structure room/1. ",NA,NA
"is_in(apple, room(kitchen)).",NA,NA
We will now make is_in/2 an infix operator of arbitrary precedence 35. ,NA,NA
"?- op(35,xfx,is_in).",NA,NA
Now we can ask ,NA,NA
?- apple is_in X.,NA,NA
X = room(kitchen),NA,NA
or ,http://www.amzi.com/AdventureInProlog/a12oper.htm (2 of 8)11/3/2006 7:05:52 PM,NA
?- X is_in room(kitchen). ,NA,NA
X = apple,NA,NA
We can add facts to the program in operator syntax. ,NA,NA
banana is_in room(kitchen).,NA,NA
To verify that Prolog treats both syntaxes the same we can attempt to unify them. ,NA,NA
"?- is_in(banana, room(kitchen)) = banana is_in room(kitchen). ",NA,NA
yes,NA,NA
And we can use display/1 to look at the new syntax. ,NA,NA
?- display(banana is_in room(kitchen)). ,NA,NA
"is_in(banana, room(kitchen))",NA,NA
Let's now make room/1 a prefix operator. Note that in this case the associativity pattern fx is used to ,NA,NA
indicate the functor comes before the argument. Also we chose a precedence (33) higher (higher ,NA,NA
precedence has lower number) than that used for is_in (35) in order to nest the room structure inside the ,NA,NA
is_in structure. ,NA,NA
"?- op(33,fx,room).",NA,NA
Now room/1 is displayed in operator syntax. ,NA,NA
?- room kitchen = room(kitchen). ,NA,NA
yes,NA,NA
?- apple is_in X. ,NA,NA
X = room kitchen\,NA,NA
The operator syntax can be used to add facts to the program. ,NA,NA
pear is_in room kitchen.,NA,NA
"?- is_in(pear, room(kitchen)) = pear is_in room kitchen. ",NA,NA
yes,NA,NA
?- display(pear is_in room kitchen). ,NA,NA
"is_in(pear, room(kitchen))",http://www.amzi.com/AdventureInProlog/a12oper.htm (3 of 8)11/3/2006 7:05:52 PM,NA
CAUTION: If you mix up the precedence (easy to do) you will get strange bugs. If room/1 had a lower ,NA,NA
"precedence (higher number) than is_in/2, then the structure would be ",NA,NA
"room(is_in(apple, kitchen))",NA,NA
"Not only doesn't this capture the information as intended, it also will not unify the way we want. ",NA,NA
"For completeness, an example of a candidate for a postfix operator would be turned_on. Again note that ",NA,NA
the 'xf' pattern says that the functor comes after the argument. ,NA,NA
"?- op(33,xf,turned_on).",NA,NA
We can now say ,NA,NA
flashlight turned_on.,NA,NA
and ,NA,NA
?- turned_on(flashlight) = flashlight turned_on.,NA,NA
yes,NA,NA
Operators are useful for making more readable data structures in a program and for making quick and ,NA,NA
easy user interfaces. ,NA,NA
"In our command-driven Nani Search, we use a simple natural language front end, which will be ",NA,NA
described in the last chapter. We could have alternatively made the commands operators so that ,NA,NA
goto(kitchen) ,NA,NA
becomes goto kitchen. ,NA,NA
turn_on(flashlight) ,NA,NA
becomes turn_on flashlight. ,NA,NA
take(apple) ,NA,NA
becomes take apple. ,NA,NA
"It's not natural language, but it's a lot better than parentheses and commas. ",NA,NA
We have seen how the precedence of operators affects their translation into structures. When operators ,NA,NA
"are of equal precedence, the Prolog reader must decide whether to work from left to right, or right to left. ",NA,NA
This is the difference between right and left associativity. ,NA,NA
"An operator can also be non-associative, which means an error is generated if you try to string two ",NA,NA
together. ,NA,NA
The same pattern used for precedence is used for associativity with the additional character y. The ,NA,NA
options are ,NA,NA
Infix: ,NA,NA
xfx non-associative ,NA,NA
xfy right to left ,NA,NA
yfx left to right ,NA,NA
Prefix ,NA,NA
fx non-associative ,NA,NA
fy left to right ,NA,NA
Postfix: ,NA,NA
xf non-associative ,NA,NA
yf right to left ,NA,NA
The is_in/2 predicate is currently non-associative so this gets an error. ,NA,NA
key is_in desk is_in office.,NA,NA
"To represent nesting, we would want this to be evaluated from right to left. ",NA,NA
"?- op(35,xfy,is_in).",NA,NA
yes,NA,NA
?- display(key is_in desk is_in office).,NA,NA
"is_in(key, is_in(desk, office))",NA,NA
If we set it left to right the arguments would be different. ,NA,NA
"?- op(35,yfx,is_in).",NA,NA
yes,NA,NA
?- display(key is_in desk is_in office).,NA,NA
"is_in(is_in(key, desk), office)",NA,NA
We can override operator associativity and precedence with parentheses. Thus we can get our left to ,NA,NA
right is_in to behave right to left like so. ,NA,NA
?- display(key is_in (desk is_in office)).,NA,NA
"is_in(key, is_in(desk, office))",NA,NA
Many built-in predicates are actually defined as infix operators. That means that rather than following ,NA,NA
"the standard predicate(arg1,arg2) format, the predicate can appear between the arguments as ",NA,NA
arg1 predicate arg2.,NA,NA
"The arithmetic operators we have seen already illustrate this. For example +, -, *, and / are used as you ",NA,NA
"would expect. However, it is important to understand that these arithmetic structures are just structures ",NA,NA
"like any others, and do not imply arithmetic evaluation. 3 + 4 is not the same as 7 any more than plus ",NA,NA
"(3,4) is or likes(3,4). It is just +(3,4). ",NA,NA
"Only special built-in predicates, like is/2, actually perform an arithmetic evaluation of an arithmetic ",NA,NA
"expression. As we have seen, is/2 causes the right side to be evaluated and the left side is unified with ",NA,NA
the evaluated result. ,NA,NA
"This is in contrast to the unification (=) predicate, which just unifies terms without evaluating them. ",NA,NA
?- X is 3 + 4. ,NA,NA
X = 7,NA,NA
?- X = 3 + 4. ,NA,NA
X = 3 + 4,NA,NA
?- 10 is 5 * 2. ,NA,NA
yes,NA,NA
?- 10 = 5 * 2. ,NA,NA
no,NA,NA
Arithmetic expressions can be as arbitrarily complex as other structures. ,NA,NA
?- X is 3 * 4 + (6 / 2). ,NA,NA
X = 15,NA,NA
Even if they are not evaluated. ,NA,NA
?- X = 3 * 4 + (6 / 2). ,NA,NA
X = 3 * 4 + (6 / 2),NA,NA
The operator predicates can also be written in standard notation. ,NA,NA
"?- X is +(*(3,4) , /(6,2)). ",NA,NA
X = 15,http://www.amzi.com/AdventureInProlog/a12oper.htm (6 of 8)11/3/2006 7:05:52 PM,NA
"?- 3 * 4 + (6 / 2) = +(*(3,4),/(6,2)).",NA,NA
yes ,NA,NA
To underscore that these arithmetic operators are really ordinary predicates with no special meaning ,NA,NA
"unless being evaluated by is/2, consider ",NA,NA
"?- X = 3 * 4 + likes(john, 6/2).",NA,NA
"X = 3 * 4 + likes(john, 6/2).",NA,NA
"?- X is 3 * 4 + likes(john, 6/2).",NA,NA
error ,NA,NA
We have seen that Prolog programs are composed of clauses. These clauses are simply Prolog data ,NA,NA
structures written with operator syntax. The functor is the neck (:-) which is defined as an infix operator. ,NA,NA
There are two arguments. ,NA,NA
":-(Head, Body).",NA,NA
"The body is a data structure with the functor 'and' represented by a comma (,). The body looks like ",NA,NA
",(goal1, ,(goal2,,goal3)) ",NA,NA
"Note the ambiguous use of the comma (,) as a conjunctive operator and as a separator of arguments in a ",NA,NA
Prolog structure. This can cause confusion in Prolog programs that manipulate Prolog clauses. It might ,NA,NA
have been clearer if an ampersand (&) was used instead of a comma for separating goals. Then the above ,NA,NA
pattern would be ,NA,NA
"&(goal1, &(goal2, & goal3)) ",NA,NA
and the following would be equivalent. ,NA,NA
head :- goal1 & goal2 & goal3.,NA,NA
":-(head, &(goal1, &(goal2, & goal3))).",NA,NA
"But that is not how it was done, so the two forms are ",NA,NA
"head :- goal1 , goal2 , goal3.",NA,NA
":-(head, ,(goal1, ,(goal2, , goal3))). ",NA,NA
Every other comma has a different meaning. ,NA,NA
The arithmetic operators are often used by Prolog programmers to syntactically join related terms. For ,NA,NA
"example, the write/1 predicate takes only one argument, but operators give an easy way around this ",NA,NA
restriction. ,NA,NA
"?- X = one, Y = two, write(X-Y).",NA,NA
one - two ,NA,NA
"The slash (/) can be used the same way. In addition, some Prologs define the colon (:) as an operator just ",NA,NA
"for this purpose. It can improve readability by removing some parentheses. For example, the complex ",NA,NA
structures for defining things in the game can be syntactically represented with the colon as well. ,NA,NA
"object(apple, size:small, color:red, weight:1). ",NA,NA
A query looking for small things would be expressed ,NA,NA
"?- object(X, size:small, color:C, weight:W).",NA,NA
X = apple ,NA,NA
C = red ,NA,NA
W = 1 ,NA,NA
"The pattern matching is the same as always, but instead of size(small) we use the pattern size:small, ",NA,NA
"which is really :(size,small). ",NA,NA
Exercises ,NA,NA
Adventure Game ,NA,NA
1- Define all of the Nani Search commands as operators so the current version of the game can be played ,NA,NA
without parentheses or commas. ,NA,NA
Genealogical Logicbase ,NA,NA
2- Define the various relationships in the genealogical logicbase as operators. ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a12oper.htm (8 of 8)11/3/2006 7:05:52 PM,NA
13,NA,NA
Cut,NA,NA
"Up to this point, we have worked with Prolog's backtracking execution behavior. We have seen how to ",NA,NA
use that behavior to write compact predicates. ,NA,NA
Sometimes it is desirable to selectively turn off backtracking. Prolog provides a predicate that performs ,NA,NA
this function. It is called the ,NA,NA
cut,NA,NA
", represented by an exclamation point (!). ",NA,NA
"The cut effectively tells Prolog to freeze all the decisions made so far in this predicate. That is, if ",NA,NA
"required to backtrack, it will automatically fail without trying other alternatives. ",NA,NA
We will first examine the effects of the cut and then look at some practical reasons to use it. ,NA,NA
Figure 13.1. The effect of the cut on flow of control ,NA,NA
"When the cut is encountered, it re-routes backtracking, as shown in figure 13.1. It short-circuits ",NA,NA
"backtracking in the goals to its left on its level, and in the level above, which contained the cut. That is, ",NA,NA
both the parent goal (middle goal of top level) and the goals of the particular rule being executed ,NA,NA
(second level) are affected by the cut. The effect is undone if a new route is taken into the parent goal. ,NA,NA
Contrast figure 13.1 with figure 5.1. ,NA,NA
"We will write some simple predicates that illustrate the behavior of the cut, first adding some data to ",http://www.amzi.com/AdventureInProlog/a13cut.htm (1 of 6)11/3/2006 7:05:55 PM,NA
backtrack over. ,NA,NA
data(one).,NA,NA
data(two).,NA,NA
data(three).,NA,NA
Here is the first test case. It has no cut and will be used for comparison purposes. ,NA,NA
cut_test_a(X) :-,NA,NA
 data(X).,NA,NA
cut_test_a('last clause').,NA,NA
"This is the control case, which exhibits the normal behavior. ",NA,NA
"?- cut_test_a(X), write(X), nl, fail.",NA,NA
one ,NA,NA
two ,NA,NA
three ,NA,NA
last clause ,NA,NA
no,NA,NA
"Next, we put a cut at the end of the first clause. ",NA,NA
cut_test_b(X) :-,NA,NA
" data(X),",NA,NA
 !.,NA,NA
cut_test_b('last clause').,NA,NA
"Note that it stops backtracking through both the data/1 subgoal (left), and the cut_test_b parent (above). ",NA,NA
"?- cut_test_b(X), write(X), nl, fail. ",NA,NA
one ,NA,NA
no,NA,NA
Next we put a cut in the middle of two subgoals. ,NA,NA
"cut_test_c(X,Y) :-",NA,NA
" data(X),",NA,NA
" !,",NA,NA
 data(Y).,NA,NA
cut_test_c('last clause').,NA,NA
Note that the cut inhibits backtracking in the parent cut_test_c and in the goals to the left of (before) the ,NA,NA
cut (first data/1). The second data/1 to the right of (after) the cut is still free to backtrack. ,NA,NA
"?- cut_test_c(X,Y), write(X-Y), nl, fail.",NA,NA
one - one ,NA,NA
one - two ,NA,NA
one - three ,NA,NA
no,NA,NA
Performance is the main reason to use the cut. This separates the logical purists from the pragmatists. ,NA,NA
Various arguments can also be made as to its effect on code readability and maintainability. It is often ,NA,NA
called the 'goto' of logic programming. ,NA,NA
"You will most often use the cut when you know that at a certain point in a given predicate, Prolog has ",NA,NA
"either found the only answer, or if it hasn't, there is no answer. In this case you insert a cut in the ",NA,NA
predicate at that point. ,NA,NA
"Similarly, you will use it when you want to force a predicate to fail in a certain situation, and you don't ",NA,NA
want it to look any further. ,NA,NA
Using the Cut ,NA,NA
We will now introduce to the game the little puzzles that make adventure games fun to play. We will put ,NA,NA
"them in a predicate called puzzle/1. The argument to puzzle/1 will be one of the game commands, and ",NA,NA
"puzzle/1 will determine whether or not there are special constraints on that command, reacting ",NA,NA
accordingly. ,NA,NA
We will see examples of both uses of the cut in the puzzle/1 predicate. The behavior we want is ,G,NA
"If there is a puzzle, and the constraints are met, quietly succeed. ",G,NA
"If there is a puzzle, and the constraints are not met, noisily fail. ",G,NA
If ,NA,NA
"there is no puzzle, quietly succeed. ",NA,NA
"The puzzle in Nani Search is that in order to get to the cellar, the game player needs to both have the ",NA,NA
flashlight and turn it on. If these criteria are met we know there is no need to ever backtrack through ,NA,NA
puzzle/1 looking for other clauses to try. For this reason we include the cut. ,NA,NA
puzzle(goto(cellar)):-,NA,NA
" have(flashlight),",NA,NA
" turned_on(flashlight),",NA,NA
 !.,http://www.amzi.com/AdventureInProlog/a13cut.htm (3 of 6)11/3/2006 7:05:55 PM,NA
"If the puzzle constraints are not met, then let the player know there is a special problem. In this case we ",NA,NA
"also want to force the calling predicate to fail, and we don't want it to succeed by moving to other ",NA,NA
"clauses of puzzle/1. Therefore we use the cut to stop backtracking, and we follow it with fail. ",NA,NA
puzzle(goto(cellar)):-,NA,NA
" write('It''s dark and you are afraid of the dark.'), ",NA,NA
"!, fail.",NA,NA
The final clause is a catchall for those commands that have no special puzzles associated with them. ,NA,NA
They will always succeed in a call to puzzle/1. ,NA,NA
puzzle(_).,NA,NA
"For logical purity, it is always possible to rewrite the predicates without the cut. This is done with the ",NA,NA
"built-in predicate not/1. Some claim this provides for clearer code, but often the explicit and liberal use ",NA,NA
"of 'not' clutters up the code, rather than clarifying it. ",NA,NA
"When using the cut, the order of the rules becomes important. Our second clause for puzzle/1 safely ",NA,NA
"prints an error message, because we know the only way to get there is by the first clause failing before it ",NA,NA
reached the cut. ,NA,NA
"The third clause is completely general, because we know the earlier clauses have caught the special ",NA,NA
cases. ,NA,NA
"If the cuts were removed from the clauses, the second two clauses would have to be rewritten. ",NA,NA
puzzle(goto(cellar)):-,NA,NA
" not(have(flashlight)),",NA,NA
" not(turned_on(flashlight)),",NA,NA
" write('Scared of dark message'),",NA,NA
 fail.,NA,NA
puzzle(X):-,NA,NA
 not(X = goto(cellar)).,NA,NA
In this case the order of the clauses would not matter. ,NA,NA
"It is interesting to note that not/1 is defined using the cut. It also uses call/1, another built-in predicate ",NA,NA
that calls a predicate. ,NA,NA
"not(X) :- call(X), !, fail. ",NA,NA
not(X).,http://www.amzi.com/AdventureInProlog/a13cut.htm (4 of 6)11/3/2006 7:05:55 PM,NA
In the next chapter we will see how to add a command loop to the game. Until then we can test the ,NA,NA
puzzle predicate by including a call to it in each individual command. For example ,NA,NA
goto(Place) :- ,NA,NA
" puzzle(goto(Place)),",NA,NA
" can_go(Place),",NA,NA
" move(Place),",NA,NA
 look.,NA,NA
"Assuming the player is in the kitchen, an attempt to go to the cellar will fail. ",NA,NA
?- goto(cellar).,NA,NA
It's dark and you are afraid of the dark.,NA,NA
no,NA,NA
?- goto(office).,NA,NA
You are in the office...,NA,NA
"Then if the player takes the flashlight, turns it on, and return to the kitchen, all goes well. ",NA,NA
?- goto(cellar).,NA,NA
You are in the cellar... ,NA,NA
Exercises ,NA,NA
Adventure Game,NA,NA
1- Test the puzzle/1 predicate by setting up various game situations and seeing how it responds. When ,NA,NA
testing predicates with cuts you should always use the semicolon (;) after each answer to make sure it ,NA,NA
behaves correctly on backtracking. In our case puzzle/1 should always give one response and fail on ,NA,NA
backtracking. ,NA,NA
2- Add your own puzzles for different situations and commands. ,NA,NA
Expert System,NA,NA
3- Modify the ask and menuask predicates to use cut to replace the use of not. ,NA,NA
Customer Order Entry,NA,NA
4- Modify the good_customer rules to use cut to prevent the search of other cases once we know one has ,NA,NA
been found. ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a13cut.htm (6 of 6)11/3/2006 7:05:55 PM,NA
14,NA,NA
Control Structures,NA,NA
We have examined the manner in which Prolog interprets goals and have also seen examples of how to ,NA,NA
manipulate Prolog's execution behavior. ,NA,NA
In this chapter we will further explore the control structures you can implement in Prolog and draw ,NA,NA
parallels between them and the control structures found in more conventional programming languages. ,NA,NA
You have already used the combination of fail and write/1 to generate lists of things for the game. This ,NA,NA
control structure is similar to 'do while' found in most languages. ,NA,NA
We will now introduce another built-in predicate that allows us to capitalize on failure. It is repeat/0. It ,NA,NA
"always succeeds the first time it is called, and it always succeeds on backtracking. In other words, you ",NA,NA
can not backtrack through a repeat/0. It always restarts forward execution.< ,NA,NA
Figure 14.1. Flow of control in the repeat/0 built-in predicate ,NA,NA
A clause body with a repeat/0 followed by fail/0 will go back and forth forever. This is one way to write ,NA,NA
an endless loop in Prolog. ,NA,NA
A repeat/0 followed by some intermediate goals followed by a test condition will loop until the test ,NA,NA
condition is satisfied. It is equivalent to a 'do until' in other languages. This is exactly the behavior we ,NA,NA
want for the highest command loop in Nani Search. ,NA,NA
Our first version of command_loop/0 will simply read commands and echo them until end is entered. ,NA,NA
The built-in predicate read/1 reads a Prolog term from the console. The term must be followed by a ,NA,NA
period. ,http://www.amzi.com/AdventureInProlog/a14cntrl.htm (1 of 11)11/3/2006 7:06:01 PM,NA
command_loop:- ,NA,NA
" repeat,",NA,NA
" write('Enter command (end to exit): '), ",NA,NA
"read(X),",NA,NA
" write(X), nl,",NA,NA
 X = end.,NA,NA
The last goal will fail unless end is entered. The repeat/0 always succeeds on backtracking and causes ,NA,NA
the intermediate goals to be re-executed. ,NA,NA
We can execute it by entering this query. ,NA,NA
?- command_loop.,NA,NA
"Now that the control structure is in place, we can have it execute the command, rather than just repeat it. ",NA,NA
"We will write a new predicate called do/1, which executes only the commands we allow. Many other ",NA,NA
languages have 'do case' control structures that perform this kind of function. Multiple clauses in a ,NA,NA
Prolog predicate behave similarly to a 'do case.' ,NA,NA
"Here is do/1. Notice that it allows us to define synonyms for commands, that is, the player can enter ",NA,NA
either goto(X) or go(X) to cause the goto/1 predicate to be executed. ,NA,NA
"do(goto(X)):-goto(X),!.",NA,NA
"do(go(X)):-goto(X),!.",NA,NA
"do(inventory):-inventory,!. ",NA,NA
"do(look):-look,!.",NA,NA
"NOTE: The cut serves two purposes. First, it says once we have found a 'do' clause to execute, don't ",NA,NA
"bother looking for anymore. Second, it prevents the backtracking initiated at the end of command_loop ",NA,NA
from entering the other command predicates. ,NA,NA
"Here are some more do/1's. If do(end) did not always succeed, we would never get to the' X = end' test ",NA,NA
and would fail forever. The last do/1 allows us to tell the user there was something wrong with the ,NA,NA
command. ,NA,NA
"do(take(X)) :- take(X), !. ",NA,NA
do(end).,NA,NA
do(_) :-,NA,NA
 write('Invalid command').,http://www.amzi.com/AdventureInProlog/a14cntrl.htm (2 of 11)11/3/2006 7:06:01 PM,NA
We can now rewrite command_loop/0 to use the new do/1 and incorporate puzzle/1 in the command ,NA,NA
"loop. We will also replace the old simple test for end with a new predicate, end_condition/1, that will ",NA,NA
determine if the game is over. ,NA,NA
command_loop:- ,NA,NA
" write('Welcome to Nani Search'), nl, ",NA,NA
"repeat,",NA,NA
" write('>nani> '),",NA,NA
" read(X),",NA,NA
" puzzle(X),",NA,NA
" do(X), nl,",NA,NA
 end_condition(X).,NA,NA
Two conditions might end the game. The first is if the player types 'end.' The second is if the player has ,NA,NA
successfully taken the Nani. ,NA,NA
end_condition(end).,NA,NA
end_condition(_) :-,NA,NA
" have(nani),",NA,NA
 write('Congratulations').,NA,NA
The game can now be played from the top. ,NA,NA
?- command_loop.,NA,NA
Welcome to ...,NA,NA
Recursive Control Loop ,NA,NA
"As hinted at in chapter 7, the purity of logic programming is undermined by the asserts and retracts of ",NA,NA
"the logicbase. Just like global data in any language, predicates that are dynamically asserted and ",NA,NA
"retracted can make for unpredictable code. That is, code in one part of the system that uses a dynamic ",NA,NA
predicate is affected by code in an entirely different part that changes that dynamic predicate. ,NA,NA
"For example, puzzle(goto(cellar)) succeeds or fails based on the existence of turned_on(flashlight) ",NA,NA
which is asserted by the turn_on/1 predicate. A bug in turn_on/1 will cause puzzle/1 to behave ,NA,NA
incorrectly. ,NA,NA
"The entire game can be reconstructed using arguments and no global data. To do this, it helps to think of ",NA,NA
the game as a sequence of state transformations. ,NA,NA
"In the current implementation, the state of the game is defined by the dynamic predicates location/2, ",http://www.amzi.com/AdventureInProlog/a14cntrl.htm (3 of 11)11/3/2006 7:06:01 PM,NA
"here/1, have/1, and turned_on/1 or turned_off/1 for the flashlight. These predicates define an initial state ",NA,NA
"which is dynamically changed, using assert and retract, as the player moves through the game toward the ",NA,NA
"winning state, which is defined by the existence of have(nani). ",NA,NA
"We can get the same effect by defining a complex structure to hold the state, implementing game ",NA,NA
"commands that access that state as an argument, rather than from dynamic facts in the logicbase. ",NA,NA
"Because logical variables cannot have their values changed by assignment, the commands must take two ",NA,NA
arguments representing the old state and the new state. The repeat-fail control structure will not let us ,NA,NA
"repeatedly change the state in this manner, so we need to write a recursive control structure that ",NA,NA
recursively sends the new state to itself. The boundary condition is reaching the ending state of the game. ,NA,NA
"This control structure is shown in figure 14.1, which contains an abbreviated version of Nani Search. ",NA,NA
"The state is represented by a list of structures holding different types of state information, as seen in ",NA,NA
initial_state/1. The various commands in this type of game need to access and manipulate that state ,NA,NA
"structure. Rather than require each predicate that accesses the state to understand its complex structure, ",NA,NA
"the utility predicates get_state/3, add_state/4, and del_state/4 are written to access it. This way any ",NA,NA
program changes to the state structure only require changes to the utility predicates. ,NA,NA
"This style of Prolog programming is logically purer, and lends itself to certain types of applications. It ",NA,NA
"also avoids the difficulties often associated with global data. On the other hand, it requires more ",NA,NA
"complexity in dealing with state information in arguments, and the multiple lists and recursive routines ",NA,NA
can be confusing to debug. You will have to decide which approach to use for each application you ,NA,NA
write. ,NA,NA
/*      a nonassertive version of nani search */,NA,NA
nani :-,NA,NA
" write('Welcome to Nani Search'), ",NA,NA
"nl,",NA,NA
" initial_state(State),",NA,NA
 control_loop(State).,NA,NA
control_loop(State) :-,NA,NA
 end_condition(State).,NA,NA
control_loop(State) :-,NA,NA
" repeat,",NA,NA
" write('> '),",NA,NA
" read(X),",NA,NA
" constraint(State, X),",NA,NA
" do(State, NewState, X),",http://www.amzi.com/AdventureInProlog/a14cntrl.htm (4 of 11)11/3/2006 7:06:01 PM,NA
 control_loop(NewState).,NA,NA
/* initial dynamic state */,NA,NA
initial_state([ ,NA,NA
"here(kitchen), ",NA,NA
"have([]), ",NA,NA
location([,NA,NA
" kitchen/apple,",NA,NA
" kitchen/broccoli,",NA,NA
" office/desk,",NA,NA
" office/flashlight,",NA,NA
" cellar/nani ]), ",NA,NA
status([,NA,NA
" flashlight/off,",NA,NA
 game/on]) ]).,NA,NA
/* static state */,NA,NA
"rooms([office, kitchen, cellar]).",NA,NA
"doors([office/kitchen, cellar/kitchen]).",NA,NA
"connect(X,Y) :-",NA,NA
" doors(DoorList),",NA,NA
" member(X/Y, DoorList).",NA,NA
"connect(X,Y) :-",NA,NA
" doors(DoorList),",NA,NA
" member(Y/X, DoorList).",NA,NA
/* list utilities */,NA,NA
"member(X,[X|Y]).",NA,NA
"member(X,[Y|Z]) :- member(X,Z).",NA,NA
"delete(X, [], []).",NA,NA
"delete(X, [X|T], T).",NA,NA
"delete(X, [H|T], [H|Z]) :- delete(X, T, Z).",NA,NA
/* state manipulation utilities */,NA,NA
"get_state(State, here, X) :-",NA,NA
" member(here(X), State).",NA,NA
"get_state(State, have, X) :-",NA,NA
" member(have(Haves), State),",NA,NA
" member(X, Haves).",NA,NA
"get_state(State, location, Loc/X) :- ",NA,NA
"member(location(Locs), State),",NA,NA
" member(Loc/X, Locs).",NA,NA
"get_state(State, status, Thing/Stat) :- ",NA,NA
"member(status(Stats), State),",NA,NA
" member(Thing/Stat, Stats).",NA,NA
"del_state(OldState, [location(NewLocs) | Temp], location, Loc/X):- ",NA,NA
"delete(location(Locs), OldState, Temp),",NA,NA
" delete(Loc/X, Locs, NewLocs).",NA,NA
"add_state(OldState, [here(X)|Temp], here, X) :- ",NA,NA
"delete(here(_), OldState, Temp).",NA,NA
"add_state(OldState, [have([X|Haves])|Temp], have, X) :- ",NA,NA
"delete(have(Haves), OldState, Temp).",NA,NA
"add_state(OldState, [status([Thing/Stat|TempStats])|Temp], ",NA,NA
"status, Thing/Stat) :-",NA,NA
" delete(status(Stats), OldState, Temp),",NA,NA
" delete(Thing/_, Stats, TempStats).",NA,NA
/* end condition */,NA,NA
end_condition(State) :-,NA,NA
" get_state(State, have, nani),",NA,NA
 write('You win').,NA,NA
end_condition(State) :-,NA,NA
" get_state(State, status, game/off), ",NA,NA
write('quitter').,NA,NA
/* constraints and puzzles together */,NA,NA
"constraint(State, goto(cellar)) :-",NA,NA
" !, can_go_cellar(State).",NA,NA
"constraint(State, goto(X)) :-",NA,NA
" !, can_go(State, X).",NA,NA
"constraint(State, take(X)) :-",NA,NA
" !, can_take(State, X).",NA,NA
"constraint(State, turn_on(X)) :-",NA,NA
" !, can_turn_on(State, X).",NA,NA
"constraint(_, _).",NA,NA
"can_go(State,X) :-",NA,NA
" get_state(State, here, H),",NA,NA
" connect(X,H).",NA,NA
"can_go(_, X) :-",NA,NA
" write('You can''t get there from here'), ",NA,NA
"nl, fail.",NA,NA
can_go_cellar(State) :-,NA,NA
" can_go(State, cellar),",NA,NA
" !, cellar_puzzle(State).",NA,NA
cellar_puzzle(State) :-,NA,NA
" get_state(State, have, flashlight),",NA,NA
" get_state(State, status, flashlight/on).",NA,NA
cellar_puzzle(_) :-,NA,NA
" write('It''s dark in the cellar'), ",NA,NA
"nl, fail.",NA,NA
"can_take(State, X) :-",NA,NA
" get_state(State, here, H),",NA,NA
" get_state(State, location, H/X).",NA,NA
"can_take(State, X) :-",NA,NA
" write('it is not here'),",NA,NA
" nl, fail.",NA,NA
"can_turn_on(State, X) :-",NA,NA
" get_state(State, have, X).",NA,NA
"can_turn_on(_, X) :-",NA,NA
" write('You don''t have it'),",NA,NA
" nl, fail.",NA,NA
/* commands */ ,NA,NA
"do(Old, New, goto(X)) :- goto(Old, New, X), !.",NA,NA
"do(Old, New, take(X)) :- take(Old, New, X), !.",NA,NA
"do(Old, New, turn_on(X)) :- turn_on(Old, New, X), !. ",NA,NA
"do(State, State, look) :- look(State), !.",NA,NA
"do(Old, New, quit) :- quit(Old, New).",NA,NA
"do(State, State, _) :-",NA,NA
" write('illegal command'), nl.",NA,NA
look(State) :-,NA,NA
" get_state(State, here, H),",NA,NA
" write('You are in '), write(H),",NA,NA
" nl,",NA,NA
" list_things(State, H), nl.",NA,NA
"list_things(State, H) :-",NA,NA
" get_state(State, location, H/X), ",NA,NA
"tab(2), write(X),",NA,NA
 fail.,NA,NA
"list_things(_, _).",NA,NA
"goto(Old, New, X) :-",NA,NA
" add_state(Old, New, here, X),",NA,NA
 look(New).,NA,NA
"take(Old, New, X) :-",NA,NA
" get_state(Old, here, H),",NA,NA
" del_state(Old, Temp, location, H/X), ",NA,NA
"add_state(Temp, New, have, X).",NA,NA
"turn_on(Old, New, X) :-",NA,NA
" add_state(Old, New, status, X/on).",NA,NA
"quit(Old, New) :-",NA,NA
" add_state(Old, New, status, game/off).",NA,NA
Figure 14.1. Nani Search without a dynamic facts ,NA,NA
There could be serious performance problems with this approach to the game. Prolog uses a stack to ,NA,NA
"keep track of the levels of predicate calls. In the case of a recursive predicate, the stack grows at each ",NA,NA
"recursive call. In this example, with its complex arguments, the stack could easily be consumed in a ",NA,NA
shortperiod of time by the recursive control structure. ,NA,NA
"Fortunately, there is a performance feature built into Prolog that makes this example program, and ones ",NA,NA
"similar to it, behave efficiently. ",NA,NA
Tail Recursion,NA,NA
"There are actually two kinds of recursive routines. In a true recursive routine, each level must wait for ",NA,NA
the information from the lower levels in order to return an answer. This means that Prolog must build a ,NA,NA
stack with a new entry for each level. ,http://www.amzi.com/AdventureInProlog/a14cntrl.htm (8 of 11)11/3/2006 7:06:01 PM,NA
"This is in contrast to iteration, which is more common in conventional languages. Each pass through the ",NA,NA
iteration updates the variables and there is no need for building a stack. ,NA,NA
There is a type of recursion called ,NA,NA
tail recursion,NA,NA
" that, while written recursively, behaves iteratively. In ",NA,NA
"general, if the recursive call is the last call, and there are no computations based on the information from ",NA,NA
"the lower levels, then a good Prolog can implement the predicate iteratively, without growing the stack. ",NA,NA
One classic example of tail recursion is the factorial predicate. First we'll write it using normal recursion. ,NA,NA
"Note that the variable FF, which is returned from the lower level, is used in the top level. ",NA,NA
"factorial_1(1,1).",NA,NA
"factorial_1(N,F):-",NA,NA
" N > 1,",NA,NA
" NN is N - 1,",NA,NA
" factorial_1(NN,FF),",NA,NA
 F is N * FF.,NA,NA
It works as expected. ,NA,NA
"?- factorial_1(5,X). ",NA,NA
X = 120,NA,NA
"By introducing a new second argument to keep track of the result so far, we can rewrite factorial/3 tail-",NA,NA
recursively. The new argument is initially set to 1. Each recursive call builds on the second argument. ,NA,NA
"When the boundary condition is reached, the third argument is bound to the second argument. ",NA,NA
"factorial_2(1,F,F).",NA,NA
"factorial_2(N,T,F):-",NA,NA
" N > 1,",NA,NA
" TT is N * T,",NA,NA
" NN is N - 1,",NA,NA
" factorial_2(NN,TT,F).",NA,NA
"It gives the same results as the previous version, but because the recursive call is the last call in the ",NA,NA
"second clause, its arguments are not needed at each level. ",NA,NA
"?- factorial_2(5,1,X). ",NA,NA
X = 120,NA,NA
Another classic example of tail recursion is the predicate to reverse a list. The straightforward definition ,NA,NA
of 'reverse' would be ,NA,NA
"naive_reverse([],[]).",NA,NA
"naive_reverse([H|T],Rev):-",NA,NA
" naive_reverse(T,TR),",NA,NA
" append(TR,[H],Rev).",NA,NA
The inefficiency of this definition is a feature taken advantage of in Prolog benchmarks. It is called the ,NA,NA
naive reverse,NA,NA
", and published performance statistics often list the time required to reverse a list of a ",NA,NA
certain size. ,NA,NA
"The result of the recursive call to naive_reverse/2 is used in the last goal, so it is not tail recursive, but it ",NA,NA
gives the right answers. ,NA,NA
"?- naive_reverse([ants, mice, zebras], X). ",NA,NA
"X = [zebras, mice, ants]",NA,NA
By again introducing a new second argument which will accumulate the partial answer through levels of ,NA,NA
"recursion, we can rewrite 'reverse.' It turns out that the partial answer is already reversed when it reaches ",NA,NA
the boundary condition. ,NA,NA
"reverse([], Rev, Rev).",NA,NA
"reverse([H|T], Temp, Rev) :-",NA,NA
" reverse(T, [H|Temp], Rev).",NA,NA
We can now try the second reverse. ,NA,NA
"?- reverse([ants, mice, zebras], [], X). ",NA,NA
"X = [zebras, mice, ants]",NA,NA
Exercises ,NA,NA
1- Trace both versions of reverse to understand the performance differences. ,NA,NA
2- Write a tail recursive predicate that will compute the sum of the numbers between two given ,NA,NA
numbers. Trace its behavior to see if it is tail recursive. ,NA,NA
Adventure Game,NA,NA
3- Add the remaining command predicates to do/1 so the game can be fully played. ,NA,NA
4- Add the concept of time to the game by putting a counter in the command loop. Use an out-of-time ,http://www.amzi.com/AdventureInProlog/a14cntrl.htm (10 of 11)11/3/2006 7:06:01 PM,NA
"condition as one way to end the game. Also add a 'wait' command, which just waits for one time ",NA,NA
increment. ,NA,NA
5- Add other individuals or creatures that move automatically through the game rooms. Each cycle of ,NA,NA
the command loop will update their locations based on whatever algorithm you choose. ,NA,NA
Customer Order Entry,NA,NA
6- Write a command loop for the order entry inventory system. Write a variation on menuask/3 that will ,NA,NA
"present the user with a menu of choices, one of which is to exit the system. Use this in the command ",NA,NA
"loop instead of just prompting for a command. Have each command prompt for the required input, if ",NA,NA
any. ,NA,NA
Expert System,NA,NA
7- Make a new version of the expert system that maintains the 'known' information in arguments rather ,NA,NA
than in the logicbase. ,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",http://www.amzi.com/AdventureInProlog/a14cntrl.htm (11 of 11)11/3/2006 7:06:01 PM,NA
15,NA,NA
Natural Language,NA,NA
Prolog is especially well-suited for developing natural language systems. In this chapter we will create ,NA,NA
an English front end for Nani Search. ,NA,NA
"But before moving to Nani Search, we will develop a natural language parser for a simple subset of ",NA,NA
"English. Once that is understood, we will use the same technology for Nani Search. ",NA,NA
The simple subset of English will include sentences such as ,G,NA
The dog ate the bone. ,G,NA
The big brown mouse chases a lazy cat. ,NA,NA
This grammar can be described with the following grammar rules. (The first rule says a sentence is made ,NA,NA
"up of a noun phrase followed by a verb phrase. The last rule says an adjective is either 'big', or 'brown', or ",NA,NA
'lazy.' The '|' means 'or.') ,NA,NA
sentence : ,NA,NA
"nounphrase, verbphrase. ",NA,NA
nounphrase : ,NA,NA
"determiner, nounexpression. ",NA,NA
nounphrase : ,NA,NA
nounexpression. ,NA,NA
nounexpression : ,NA,NA
noun. ,NA,NA
nounexpression : ,NA,NA
"adjective, nounexpression. ",NA,NA
verbphrase : ,NA,NA
"verb, nounphrase. ",NA,NA
determiner : ,NA,NA
the | a. ,NA,NA
noun : ,NA,NA
dog | bone | mouse | cat. ,NA,NA
verb : ,NA,NA
ate | chases. ,NA,NA
adjective : ,NA,NA
big | brown | lazy. ,NA,NA
"To begin with, we will simply determine if a sentence is a legal sentence. In other words, we will write a ",NA,NA
"predicate sentence/1, which will determine if its argument is a sentence. ",NA,NA
The sentence will be represented as a list of words. Our two examples are ,NA,NA
"[the,dog,ate,the,bone]",NA,NA
"[the,big,brown,mouse,chases,a,lazy,cat]",NA,NA
There are two basic strategies for solving a parsing problem like this. The first is a generate-and-test ,NA,NA
"strategy, where the list to be parsed is split in different ways, with the splittings tested to see if they are ",NA,NA
components of a legal sentence. We have already seen that we can use append/3 to generate the ,NA,NA
"splittings of a list. With this approach, the top-level rule would be ",NA,NA
sentence(L) :-,NA,NA
" append(NP, VP, L),",NA,NA
" nounphrase(NP),",NA,NA
 verbphrase(VP).,NA,NA
"The append/3 predicate will generate possible values for the variables NP and VP, by splitting the ",NA,NA
original list L. The next two goals test each of the portions of the list to see if they are grammatically ,NA,NA
"correct. If not, backtracking into append/3 causes another possible splitting to be generated. ",NA,NA
"The clauses for nounphrase/1 and verbphrase/1 are similar to sentence/1, and call further predicates that ",NA,NA
"deal with smaller units of a sentence, until the word definitions are met, such as ",NA,NA
verb([ate]).,NA,NA
verb([chases]).,NA,NA
noun([mouse]).,NA,NA
noun([dog]).,NA,NA
Difference Lists ,NA,NA
"The above strategy, however, is extremely slow because of the constant generation and testing of trial ",NA,NA
"solutions that do not work. Furthermore, the generating and testing is happening at multiple levels. ",NA,NA
The more efficient strategy is to skip the generation step and pass the entire list to the lower level ,NA,NA
"predicates, which in turn will take the grammatical portion of the sentence they are looking for from the ",NA,NA
front of the list and return the remainder of the list. ,NA,NA
"To do this, we use a structure called a ",NA,NA
difference list,NA,NA
".It is two related lists, in which the first list is the ",NA,NA
"full list and the second list is the remainder. The two lists can be two arguments in a predicate, but they ",NA,NA
"are more readable if represented as a single argument with the minus sign (-) operator, like X-Y. ",NA,NA
Here then is the first grammar rule using difference lists. A list S is a sentence if we can extract a ,NA,NA
"nounphrase from the beginning of it, with a remainder list of S1, and if we can extract a verb phrase ",NA,NA
from S1 with the empty list as the remainder. ,NA,NA
sentence(S) :-,NA,NA
" nounphrase(S-S1),",NA,NA
 verbphrase(S1-[]).,NA,NA
"Before filling in nounphrase/1 and verbphrase/1, we will jump to the lowest level predicates that define ",NA,NA
the actual words. They too must be difference lists. They are simple. If the head of the first list is the ,NA,NA
"word, the remainder list is simply the tail. ",NA,NA
noun([dog|X]-X).,NA,NA
noun([cat|X]-X).,NA,NA
noun([mouse|X]-X).,NA,NA
verb([ate|X]-X).,NA,NA
verb([chases|X]-X).,NA,NA
adjective([big|X]-X). ,NA,NA
adjective([brown|X]-X). ,NA,NA
adjective([lazy|X]-X).,NA,NA
determiner([the|X]-X). ,NA,NA
determiner([a|X]-X).,NA,NA
Testing shows how the difference lists work. ,NA,NA
"?- noun([dog,ate,the,bone]-X). ",NA,NA
"X = [ate,the,bone] ",NA,NA
"?- verb([dog,ate,the,bone]-X). ",NA,NA
no,NA,NA
Continuing with the new grammar rules we have ,http://www.amzi.com/AdventureInProlog/a15nlang.htm (3 of 13)11/3/2006 7:06:07 PM,NA
nounphrase(NP-X):-,NA,NA
" determiner(NP-S1),",NA,NA
 nounexpression(S1-X).,NA,NA
nounphrase(NP-X):-,NA,NA
 nounexpression(NP-X).,NA,NA
nounexpression(NE-X):-,NA,NA
 noun(NE-X).,NA,NA
nounexpression(NE-X):-,NA,NA
" adjective(NE-S1),",NA,NA
 nounexpression(S1-X).,NA,NA
verbphrase(VP-X):-,NA,NA
" verb(VP-S1),",NA,NA
 nounphrase(S1-X).,NA,NA
NOTE: The recursive call in the definition of nounexpression/1. It allows sentences to have any number ,NA,NA
of adjectives before a noun. ,NA,NA
These rules can now be used to test sentences. ,NA,NA
"?- sentence([the,lazy,mouse,ate,a,dog]). ",NA,NA
yes,NA,NA
"?- sentence([the,dog,ate]). ",NA,NA
no,NA,NA
"?- sentence([a,big,brown,cat,chases,a,lazy,brown,dog]). ",NA,NA
yes,NA,NA
"?- sentence([the,cat,jumps,the,mouse]). ",NA,NA
no,NA,NA
Figure 15.1 contains a trace of the sentence/1 predicate for a simple sentence. ,http://www.amzi.com/AdventureInProlog/a15nlang.htm (4 of 13)11/3/2006 7:06:07 PM,NA
The query is ,NA,NA
"?- sentence([dog,chases,cat]).",NA,NA
"1-1 CALL sentence([dog,chases,cat])",NA,NA
" 2-1 CALL nounphrase([dog,chases,cat]-_0)",NA,NA
" 3-1 CALL determiner([dog,chases,cat]-_0)",NA,NA
" 3-1 FAIL determiner([dog,chases,cat]-_0)",NA,NA
 2-1 ,NA,NA
"REDO nounphrase([dog,chases,cat]-_0)",NA,NA
" 3-1 CALL nounexpression([dog,chases,cat]- _0)",NA,NA
" 4-1 CALL noun([dog,chases,cat]-_0)",NA,NA
" 4-1 EXIT noun([dog,chases,cat]-  ",NA,NA
" [chases,cat])",NA,NA
Notice how the binding of the variable representing the remainder list has been deferred until the ,NA,NA
"lowest level is called. Each level unifies its remainder with the level before it, so when the vocabulary ",NA,NA
"level is reached, the binding of the remainder to the tail of the list is propagated back up through the ",NA,NA
nested calls. ,NA,NA
" 3-1 EXIT nounexpression([dog,chases,cat]-",NA,NA
" [chases,cat])",NA,NA
" 2-1 EXIT nounphrase([dog,chases,cat]-",NA,NA
" [chases,cat])",NA,NA
"Now that we have the noun phrase, we can see if the remainder is a verb phrase.",NA,NA
" 2-2 CALL verbphrase([chases,cat]-[]) ",NA,NA
"3-1 CALL verb([chases,cat]-_4) 3-1 ",NA,NA
"EXIT verb([chases,cat]-[cat])",NA,NA
"Finding the verb was easy, now for the final noun phrase.",NA,NA
 3-2 CALL nounphrase([cat]-[]),NA,NA
 4-1 CALL determiner([cat]-[]),NA,NA
 4-1 FAIL determiner([cat]-[]) 3-2 ,NA,NA
REDO nounphrase([cat]-[]),NA,NA
 4-1 CALL nounexpression([cat]-[]),NA,NA
 5-1 CALL noun([cat]-[]),NA,NA
 5-1 EXIT noun([cat]-[]),NA,NA
 4-1 EXIT nounexpression([cat]-[]) ,NA,NA
3-2 EXIT nounphrase([cat]-[]),NA,NA
" 2-2 EXIT verbphrase([chases,cat]-[])",http://www.amzi.com/AdventureInProlog/a15nlang.htm (5 of 13)11/3/2006 7:06:07 PM,NA
"1-1 EXIT sentence([dog,chases,cat])",NA,NA
 yes,NA,NA
Figure 15.1. Trace of sentence/1 ,NA,NA
Natural Language Front End,NA,NA
We will now use this sentence-parsing technique to build a simple English language front end for Nani ,NA,NA
Search. ,NA,NA
For the time being we will make two assumptions. The first is that we can get the user's input sentence ,NA,NA
"in list form. The second is that we can represent our commands in list form. For example, we can ",NA,NA
"express goto(office) as [goto, office], and look as [look]. ",NA,NA
"With these assumptions, the task of our natural language front end is to translate a user's natural sentence ",NA,NA
"list into an acceptable command list. For example, we would want to translate [go,to,the,office] into ",NA,NA
"[goto, office]. ",NA,NA
"We will write a high-level predicate, called command/2, that performs this translation. Its format will be ",NA,NA
"command(OutputList, InputList).",NA,NA
"The simplest commands are the ones that are made up of a verb with no object, such as look, ",NA,NA
"list_possessions, and end. We can define this situation as follows. ",NA,NA
"command([V], InList):- verb(V, InList-[]).",NA,NA
"We will define verbs as in the earlier example, only this time we will include an extra argument, which ",NA,NA
identifies the command for use in building the output list. We can also allow as many different ways of ,NA,NA
expressing a command as we feel like as in the two ways to say 'look' and the three ways to say 'end.' ,NA,NA
"verb(look, [look|X]-X).",NA,NA
"verb(look, [look,around|X]-X).",NA,NA
"verb(list_possessions, [inventory|X]-X).",NA,NA
"verb(end, [end|X]-X).",NA,NA
"verb(end, [quit|X]-X).",NA,NA
"verb(end, [good,bye|X]-X).",NA,NA
We can now test what we've got. ,NA,NA
"?- command(X,[look]). ",NA,NA
X = [look],NA,NA
"?- command(X,[look,around]). ",NA,NA
X = [look],NA,NA
"?- command(X,[inventory]). ",NA,NA
X = [list_possessions],NA,NA
"?- command(X,[good,bye]). ",NA,NA
X = [end],NA,NA
We now move to the more complicated case of a command composed of a verb and an object. Using the ,NA,NA
"grammatical constructs we saw in the beginning of this chapter, we could easily construct this grammar. ",NA,NA
"However, we would like to have our interface recognize the semantics of the sentence as well as the ",NA,NA
formal grammar. ,NA,NA
"For example, we would like to make sure that 'goto' verbs have a place as an object, and that the other ",NA,NA
verbs have a thing as an object. We can include this knowledge in our natural language routine with ,NA,NA
another argument. ,NA,NA
Here is how the extra argument is used to ensure the object type required by the verb matches the object ,NA,NA
type of the noun. ,NA,NA
"command([V,O], InList) :-",NA,NA
" verb(Object_Type, V, InList-S1),",NA,NA
" object(Object_Type, O, S1-[]).",NA,NA
Here is how we specify the new verbs. ,NA,NA
"verb(place, goto, [go,to|X]-X). ",NA,NA
"verb(place, goto, [go|X]-X).",NA,NA
"verb(place, goto, [move,to|X]-X).",NA,NA
"We can even recognize the case where the 'goto' verb was implied, that is if the user just typed in a room ",NA,NA
name without a preceding verb. In this case the list and its remainder are the same. The existing room/1 ,NA,NA
predicate is used to check if the list element is a room except when the room name is made up of two ,NA,NA
words. ,NA,NA
"The rule states ""If we are looking for a verb at the beginning of a list, and the list begins with a room, ",NA,NA
then assume a 'goto' verb was found and return the full list for processing as the object of the 'goto' ,NA,NA
"verb."" ",NA,NA
"verb(place, goto, [X|Y]-[X|Y]):- room(X).",NA,NA
"verb(place, goto, [dining,room|Y]-[dining,room|Y]).",NA,NA
Some of the verbs for things are ,NA,NA
"verb(thing, take, [take|X]-X).",NA,NA
"verb(thing, drop, [drop|X]-X).",NA,NA
"verb(thing, drop, [put|X]-X).",NA,NA
"verb(thing, turn_on, [turn,on|X]-X).",NA,NA
"Optionally, an 'object' may be preceded by a determiner. Here are the two rules for 'object,' which cover ",NA,NA
both cases. ,NA,NA
"object(Type, N, S1-S3) :-",NA,NA
" det(S1-S2),",NA,NA
" noun(Type, N, S2-S3).",NA,NA
"object(Type, N, S1-S2) :-",NA,NA
" noun(Type, N, S1-S2).",NA,NA
"Since we are just going to throw the determiner away, we don't need to carry extra arguments. ",NA,NA
det([the|X]- X). ,NA,NA
det([a|X]-X). ,NA,NA
det([an|X]-X).,NA,NA
"We define nouns like verbs, but use their occurrence in the game to define most of them. Only those ",NA,NA
names that are made up of two or more words require special treatment. Nouns of place are defined in ,NA,NA
the game as rooms. ,NA,NA
"noun(place, R, [R|X]-X):- room(R).",NA,NA
"noun(place, 'dining room', [dining,room|X]-X).",NA,NA
"Things are distinguished by appearing in a 'location' or 'have' predicate. Again, we make exceptions for ",NA,NA
cases where the thing name has two words. ,NA,NA
"noun(thing, T, [T|X]-X):- location(T,_).",NA,NA
"noun(thing, T, [T|X]-X):- have(T).",NA,NA
"noun(thing, 'washing machine', [washing,machine|X]-X).",NA,NA
"We can build into the grammar an awareness of the current game situation, and have the parser respond ",NA,NA
"accordingly. For example, we might provide a command that allows the player to turn the room lights on ",NA,NA
or off. This command might be turn_on(light) as opposed to turn_on(flashlight). If the user types in 'turn ,NA,NA
on the light' we would like to determine which light was meant. ,NA,NA
"We can assume the room light was always meant, unless the player has the flashlight. In that case we ",NA,NA
will assume the flashlight was meant. ,NA,NA
"noun(thing, flashlight, [light|X], X):- have(flashlight). ",NA,NA
"noun(thing, light, [light|X], X).",NA,NA
We can now try it out. ,NA,NA
"?- command(X,[go,to,the,office]). ",NA,NA
"X = [goto, office]",NA,NA
"?- command(X,[go,dining,room]). ",NA,NA
"X = [goto, 'dining room']",NA,NA
"?- command(X,[kitchen]). ",NA,NA
"X = [goto, kitchen]",NA,NA
"?- command(X,[take,the,apple]). ",NA,NA
"X = [take, apple]",NA,NA
"?- command(X,[turn,on,the,light]). ",NA,NA
"X = [turn_on, light]",NA,NA
"?- asserta(have(flashlight)), command(X,[turn,on,the,light]). ",NA,NA
"X = [turn_on, flashlight]",NA,NA
It should fail in the following situations that don't conform to our grammar or semantics. ,NA,NA
"?- command(X,[go,to,the,desk]). ",NA,NA
no,NA,NA
"?- command(X,[go,attic]). ",NA,NA
no,NA,NA
"?- command(X,[drop,an,office]). ",NA,NA
no,NA,NA
Definite Clause Grammar ,http://www.amzi.com/AdventureInProlog/a15nlang.htm (9 of 13)11/3/2006 7:06:07 PM,NA
"The use of difference lists for parsing is so common in Prolog, that most Prologs contain additional ",NA,NA
syntactic sugaring that simplifies the syntax by hiding the difference lists from view. This syntax is ,NA,NA
called ,NA,NA
Definite Clause Grammar,NA,NA
" (DCG), and looks like normal Prolog, only the neck symbol (:-) is ",NA,NA
replaced with an arrow (-->). The DCG representation is parsed and translated to normal Prolog with ,NA,NA
difference lists. ,NA,NA
"Using DCG, the 'sentence' predicate developed earlier would be phrased ",NA,NA
"sentence --> nounphrase, verbphrase.",NA,NA
"This would be translated into normal Prolog, with difference lists, but represented as separate arguments ",NA,NA
rather than as single arguments separated by a minus (-) as we implemented them. The above example ,NA,NA
would be translated into the following equivalent Prolog. ,NA,NA
"sentence(S1, S2):-",NA,NA
" nounphrase(S1, S3),",NA,NA
" verbphrase(S3, S2).",NA,NA
"Thus, if we define 'sentence' using DCG we still must call it with two arguments, even though the ",NA,NA
arguments were not explicitly stated in the DCG representation. ,NA,NA
"?- sentence([dog,chases,cat], []).",NA,NA
The DCG vocabulary is represented by simple lists. ,NA,NA
noun --> [dog].,NA,NA
verb --> [chases].,NA,NA
These are translated into Prolog as difference lists. ,NA,NA
"noun([dog|X], X).",NA,NA
"verb([chases|X], X).",NA,NA
"As with the natural language front end for Nani Search, we often want to mix pure Prolog with the ",NA,NA
grammar and include extra arguments to carry semantic information. The arguments are simply added as ,NA,NA
normal arguments and the pure Prolog is enclosed in curly brackets ({}) to prevent the DCG parser from ,NA,NA
translating it. Some of the complex rules in our game grammar would then be ,NA,NA
"command([V,O]) --> ",NA,NA
" verb(Object_Type, V), ",NA,NA
" object(Object_Type, O).",http://www.amzi.com/AdventureInProlog/a15nlang.htm (10 of 13)11/3/2006 7:06:07 PM,NA
"verb(place, goto) --> [go, to]. ",NA,NA
"verb(thing, take) --> [take].",NA,NA
"object(Type, N) --> det, noun(Type, N). ",NA,NA
"object(Type, N) --> noun(Type, N).",NA,NA
det --> [the]. ,NA,NA
det --> [a].,NA,NA
"noun(place,X) --> [X], {room(X)}.",NA,NA
"noun(place,'dining room') --> [dining, room]. ",NA,NA
"noun(thing,X) --> [X], {location(X,_)}.",NA,NA
"Because the DCG automatically takes off the first argument, we cannot examine it and send it along as ",NA,NA
we did in testing for a 'goto' verb when only the room name was given in the command. We can ,NA,NA
recognize this case with an additional 'command' clause. ,NA,NA
"command([goto, Place]) --> noun(place, Place).",NA,NA
Reading Sentences ,NA,NA
Now for the missing pieces. We must include a predicate that reads a normal sentence from the user and ,NA,NA
puts it into a list. Figure 15.2 contains a program to perform the task. It is composed of two parts. The ,NA,NA
"first part reads a line of ASCII characters from the user, using the built-in predicate get0/1, which reads ",NA,NA
"a single ASCII character. The line is assumed terminated by an ASCII 13, which is a carriage return. ",NA,NA
"The second part uses DCG to parse the list of characters into a list of words, using another built-in ",NA,NA
"predicate name/2, which converts a list of ASCII characters into an atom. ",NA,NA
% read a line of words from the user,NA,NA
read_list(L) :-,NA,NA
" write('> '),",NA,NA
" read_line(CL),",NA,NA
" wordlist(L,CL,[]), !.",NA,NA
read_line(L) :-,NA,NA
" get0(C),",NA,NA
" buildlist(C,L).",NA,NA
"buildlist(13,[]) :- !. ",NA,NA
"buildlist(C,[C|X]) :-",NA,NA
" get0(C2),",http://www.amzi.com/AdventureInProlog/a15nlang.htm (11 of 13)11/3/2006 7:06:07 PM,NA
" buildlist(C2,X).",NA,NA
"wordlist([X|Y]) --> word(X), whitespace, wordlist(Y). ",NA,NA
"wordlist([X]) --> whitespace, wordlist(X).",NA,NA
wordlist([X]) --> word(X).,NA,NA
"wordlist([X]) --> word(X), whitespace.",NA,NA
"word(W) --> charlist(X), {name(W,X)}.",NA,NA
"charlist([X|Y]) --> chr(X), charlist(Y).",NA,NA
charlist([X]) --> chr(X).,NA,NA
"chr(X) --> [X],{X>=48}.",NA,NA
"whitespace --> whsp, whitespace.",NA,NA
whitespace --> whsp.,NA,NA
"whsp --> [X], {X<48}.",NA,NA
Figure 15.2. Program to read input sentences ,NA,NA
"The other missing piece converts a command in the format [goto,office] to a normal-looking command ",NA,NA
"goto(office). This is done with a standard built-in predicate called 'univ', which is represented by an ",NA,NA
equal sign and two periods (=..). It translates a predicate and its arguments into a list whose first element ,NA,NA
"is the predicate name and whose remaining elements are the arguments. It works in reverse as well, ",NA,NA
which is how we will want to use it. For example ,NA,NA
"?- pred(arg1,arg2) =..  X.",NA,NA
"X = [pred, arg1, arg2] ",NA,NA
?- pred =..  X.,NA,NA
X = [pred] ,NA,NA
"?- X =..  [pred,arg1,arg1].",NA,NA
"X = pred(arg1, arg2) ",NA,NA
?- X =..  [pred].,NA,NA
X = pred ,NA,NA
"We can now use these two predicates, along with command/2 to write get_command/1, which reads a ",NA,NA
sentence from the user and returns a command to command_loop/0. ,NA,NA
get_command(C) :-,NA,NA
" read_list(L),",NA,NA
" command(CL,L),",NA,NA
" C =..  CL, !.",NA,NA
get_command(_) :-,NA,NA
" write('I don''t understand'), nl, fail.",NA,NA
We have now gone from writing the simple facts in the early chapters to a full adventure game with a ,NA,NA
"natural language front end. You have also written an expert system, an intelligent genealogical logicbase ",NA,NA
and a standard business application. Use these as a basis for continued learning by experimentation. ,NA,NA
Exercises ,NA,NA
Adventure Game,NA,NA
1- Expand the natural language capabilities to handle all of the commands of Nani Search. ,NA,NA
"2- Expand the natural language front end to allow for compound sentences, such as ""go to the kitchen ",NA,NA
"and take the apple,"" or ""take the apple and the broccoli."" ",NA,NA
3- Expand the natural language to allow for pronouns. To do this the 'noun' predicate must save the last ,NA,NA
noun and its type. When the word 'it' is encountered pick up that last noun. Then 'take the apple' ,NA,NA
followed by 'eat it' will work. (You will probably have to go directly to the difference list notation to ,NA,NA
"make sentences such as ""turn it on"" work.) ",NA,NA
Genealogical Logicbase,NA,NA
"4- Build a natural language query system that responds to queries such as ""Who are dennis' children?"" ",NA,NA
"and ""How many nephews does jay have?"" Assuming you write a predicate get_query/1 that returns a ",NA,NA
"Prolog query, you can call the Prolog query with the call/1 built-in predicate. For example, ",NA,NA
main_loop :-,NA,NA
" repeat,",NA,NA
 ,NA,NA
"get_query(X),",NA,NA
" call(X),",NA,NA
 X = end.,NA,NA
"Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved",NA,NA
Appendix,NA,NA
This appendix contains sample versions of the four programs described in the book. These are the adventure game ,NA,NA
"(Nani Search), the intelligent genealogical logicbase (Family), the customer order entry system (Custord), and the ",NA,NA
expert system (Birds). ,NA,NA
Nani Search ,NA,NA
% NANI SEARCH - A sample adventure game,NA,NA
% Copyright (C) 1990-1995 Amzi! inc. ,NA,NA
% All rights reserved,NA,NA
% Nani Search is designed to illustrate Prolog programming.  It ,NA,NA
% is an implementation of the principle example used in ,NA,NA
% this tutorial.,NA,NA
main:- nani_search.       % main entry point,NA,NA
nani_search:-,NA,NA
" init_dynamic_facts,     % predicates which are not compiled",NA,NA
" write('NANI SEARCH - A Sample Adventure Game'),nl,",NA,NA
" write('Copyright (C) Amzi! inc. 1990-1995'),nl,",NA,NA
" write('No rights reserved, use it as you wish'),nl,",NA,NA
" nl,",NA,NA
" write('Nani Search is designed to illustrate Prolog programming.'),nl, ",NA,NA
"write('As such, it might be the simplest adventure game.  The game'),nl, ",NA,NA
"write('is the primary example used in this tutorial.'),nl,",NA,NA
" write('Full source is included as well.'),nl,",NA,NA
" nl,",NA,NA
" write('Your persona as the adventurer is that of a three year'),nl, ",NA,NA
"write('old.  The Nani is your security blanket.  It is getting'),nl, ",NA,NA
"write('late and you''re tired, but you can''t go to sleep'),nl,",NA,NA
" write('without your Nani.  Your mission is to find the Nani.'),nl, nl,",NA,NA
" write('You control the game by using simple English commands'),nl, ",NA,NA
"write('expressing the action you wish to take.  You can go to'),nl, ",NA,NA
"write('other rooms, look at your surroundings, look in things'),nl, ",NA,NA
"write('take things, drop things, eat things, inventory the'),nl,",http://www.amzi.com/AdventureInProlog/appendix.htm (1 of 27)11/3/2006 7:06:15 PM,NA
" write('things you have, and turn things on and off.'),nl, nl,",NA,NA
" write('Hit any key to continue.'),get0(_),",NA,NA
" write('Type ""help"" if you need more help on mechanics.'),nl, ",NA,NA
"write('Type ""hint"" if you want a big hint.'),nl,",NA,NA
" write('Type ""quit"" if you give up.'),nl,",NA,NA
" nl,",NA,NA
" write('Enjoy the hunt.'),nl,",NA,NA
" look,                   % give a look before starting the game ",NA,NA
command_loop.,NA,NA
% command_loop - repeats until either the nani is found or the ,NA,NA
%     player types quit,NA,NA
command_loop:-,NA,NA
" repeat,",NA,NA
" get_command(X),",NA,NA
" do(X),",NA,NA
 (nanifound; X == quit).,NA,NA
% do - matches the input command with the predicate which carries out ,NA,NA
%     the command.  More general approaches which might work in the %     ,NA,NA
listener are not supported in the compiler.  This approach %     also ,NA,NA
gives tighter control over the allowable commands.,NA,NA
"%     The cuts prevent the forced failure at the end of ""command_loop"" ",NA,NA
%     from backtracking into the command predicates.,NA,NA
"do(goto(X)):-goto(X),!.",NA,NA
"do(nshelp):-nshelp,!.",NA,NA
"do(hint):-hint,!.",NA,NA
"do(inventory):-inventory,!.",NA,NA
"do(take(X)):-take(X),!.",NA,NA
"do(drop(X)):-drop(X),!.",NA,NA
"do(eat(X)):-eat(X),!.",NA,NA
"do(look):-look,!.",NA,NA
"do(turn_on(X)):-turn_on(X),!. ",NA,NA
"do(turn_off(X)):-turn_off(X),!.",NA,NA
"do(look_in(X)):-look_in(X),!. ",NA,NA
"do(quit):-quit,!.",NA,NA
% These are the predicates which control exit from the game.  If % ,NA,NA
"the player has taken the nani, then the call to ""have(nani)"" will % ",NA,NA
succeed and the command_loop will complete.  Otherwise it fails % ,NA,NA
and command_loop will repeat.,http://www.amzi.com/AdventureInProlog/appendix.htm (2 of 27)11/3/2006 7:06:15 PM,NA
nanifound:-,NA,NA
" have(nani),        ",NA,NA
" write('Congratulations, you saved the Nani.'),nl, ",NA,NA
"write('Now you can rest secure.'),nl,nl.",NA,NA
quit:-,NA,NA
" write('Giving up?  It''s going to be a scary night'),nl, ",NA,NA
"write('and when you get the Nani it''s not going'),nl, ",NA,NA
"write('to smell right.'),nl,nl.",NA,NA
% The help command,NA,NA
nshelp:-,NA,NA
" write('Use simple English sentences to enter commands.'),nl,",NA,NA
" write('The commands can cause you to:'),nl,",NA,NA
" nl,",NA,NA
" write('   go to a room          (ex. go to the office)'),nl,",NA,NA
" write('   look around           (ex. look)'),nl,",NA,NA
" write('   look in something     (ex. look in the desk)'),nl,",NA,NA
" write('   take something        (ex. take the apple)'),nl,",NA,NA
" write('   drop something        (ex. drop the apple)'),nl,",NA,NA
" write('   eat something         (ex. eat the apple)'),nl,",NA,NA
" write('   turn something on     (ex. turn on the light)'),nl, ",NA,NA
"write('   inventory your things (ex. inventory)'),nl,",NA,NA
" nl,",NA,NA
" write('The examples are verbose, terser commands and synonyms'),nl, ",NA,NA
"write('are usually accepted.'),nl,nl,",NA,NA
" write('Hit any key to continue.'),nl,",NA,NA
" get0(_),",NA,NA
 look.,NA,NA
hint:-,NA,NA
" write('You need to get to the cellar, and you can''t unless'),nl, ",NA,NA
"write('you get some light.  You can''t turn on the cellar'),nl, ",NA,NA
"write('light, but there is a flash light in the desk in the'),nl, ",NA,NA
"write('office you might use.'),nl,nl,",NA,NA
 look.,NA,NA
"% Initial facts describing the world.  Rooms and doors do not change, ",NA,NA
% so they are compiled.,NA,NA
room(office).,NA,NA
room(kitchen).,NA,NA
room('dining room'). ,NA,NA
room(hall).,NA,NA
room(cellar).,http://www.amzi.com/AdventureInProlog/appendix.htm (3 of 27)11/3/2006 7:06:15 PM,NA
"door(office,hall).",NA,NA
"door(hall,'dining room').",NA,NA
"door('dining room',kitchen). ",NA,NA
"door(kitchen,cellar).",NA,NA
"door(kitchen,office).",NA,NA
"connect(X,Y):-",NA,NA
" door(X,Y).",NA,NA
"connect(X,Y):-",NA,NA
" door(Y,X).",NA,NA
"% These facts are all subject to change during the game, so rather ",NA,NA
"% than being compiled, they are ""asserted"" to the listener at % ",NA,NA
"run time.  This predicate is called when ""nanisrch"" starts up.",NA,NA
init_dynamic_facts:-,NA,NA
" assertz(location(desk,office)),",NA,NA
" assertz(location(apple,kitchen)),",NA,NA
" assertz(location(flashlight,desk)),",NA,NA
" assertz(location('washing machine',cellar)), ",NA,NA
"assertz(location(nani,'washing machine')), ",NA,NA
"assertz(location(table,kitchen)),",NA,NA
" assertz(location(crackers,desk)),",NA,NA
" assertz(location(broccoli,kitchen)),",NA,NA
" assertz(here(kitchen)),",NA,NA
 assertz(turned_off(flashlight)).,NA,NA
furniture(desk).,NA,NA
furniture('washing machine'). ,NA,NA
furniture(table).,NA,NA
edible(apple).,NA,NA
edible(crackers).,NA,NA
tastes_yuchy(broccoli).,NA,NA
%%%%%%%% COMMANDS %%%%%%%%%%%%%%%%%%%%%%%%%%,NA,NA
% goto moves the player from room to room.,NA,NA
goto(Room):-,NA,NA
" can_go(Room),                 % check for legal move",NA,NA
" puzzle(goto(Room)),           % check for special conditions ",NA,NA
"moveto(Room),                 % go there and tell the player ",NA,NA
look.,NA,NA
goto(_):- look.,NA,NA
can_go(Room):-                  % if there is a connection it  ,NA,NA
"here(Here),                   % is a legal move.",NA,NA
" connect(Here,Room),!.",NA,NA
can_go(Room):-,NA,NA
" respond(['You can''t get to ',Room,' from here']),fail.",NA,NA
moveto(Room):-                  % update the logicbase with the ,NA,NA
"retract(here(_)),             % new room",NA,NA
 asserta(here(Room)).,NA,NA
"% look lists the things in a room, and the connections",NA,NA
look:-,NA,NA
" here(Here),",NA,NA
" respond(['You are in the ',Here]),",NA,NA
" write('You can see the following things:'),nl, ",NA,NA
"list_things(Here),",NA,NA
" write('You can go to the following rooms:'),nl, ",NA,NA
list_connections(Here).,NA,NA
list_things(Place):-,NA,NA
" location(X,Place),",NA,NA
" tab(2),write(X),nl,",NA,NA
 fail.,NA,NA
list_things(_).,NA,NA
list_connections(Place):-,NA,NA
" connect(Place,X),",NA,NA
" tab(2),write(X),nl,",NA,NA
 fail.,NA,NA
list_connections(_).,NA,NA
% look_in allows the player to look inside a thing which might ,NA,NA
% contain other things,NA,NA
look_in(Thing):-,NA,NA
" location(_,Thing),               % make sure there's at least one ",NA,NA
"write('The '),write(Thing),write(' contains:'),nl,",NA,NA
 list_things(Thing).,NA,NA
look_in(Thing):-,NA,NA
" respond(['There is nothing in the ',Thing]).",NA,NA
% take allows the player to take something.  As long as the thing is % ,NA,NA
"contained in the room it can be taken, even if the adventurer hasn't % ",NA,NA
looked in the the container which contains it.  Also the thing % must ,NA,NA
not be furniture.,NA,NA
take(Thing):-,NA,NA
" is_here(Thing),",NA,NA
" is_takable(Thing),",NA,NA
" move(Thing,have),",NA,NA
" respond(['You now have the ',Thing]).",NA,NA
is_here(Thing):-,NA,NA
" here(Here),",NA,NA
" contains(Thing,Here),!.          % don't backtrack ",NA,NA
is_here(Thing):-,NA,NA
" respond(['There is no ',Thing,' here']),",NA,NA
 fail.,NA,NA
"contains(Thing,Here):-             % recursive definition to find ",NA,NA
"location(Thing,Here).            % things contained in things etc.",NA,NA
"contains(Thing,Here):-",NA,NA
" location(Thing,X),",NA,NA
" contains(X,Here).",NA,NA
is_takable(Thing):-                % you can't take the furniture ,NA,NA
"furniture(Thing),",NA,NA
" respond(['You can''t pick up a ',Thing]),",NA,NA
" !,fail.",NA,NA
"is_takable(_).                     % not furniture, ok to take",NA,NA
"move(Thing,have):-",NA,NA
" retract(location(Thing,_)),      % take it from its old place ",NA,NA
asserta(have(Thing)).            % and add to your possessions,NA,NA
% drop - allows the player to transfer a possession to a room,NA,NA
drop(Thing):-,NA,NA
" have(Thing),                     % you must have the thing to drop it ",NA,NA
"here(Here),                      % where are we",NA,NA
" retract(have(Thing)),",NA,NA
" asserta(location(Thing,Here)).",NA,NA
drop(Thing):-,NA,NA
" respond(['You don''t have the ',Thing]).",NA,NA
"% eat, because every adventure game lets you eat stuff.",NA,NA
eat(Thing):-,NA,NA
" have(Thing),",NA,NA
 eat2(Thing).,NA,NA
eat(Thing):-,NA,NA
" respond(['You don''t have the ',Thing]).",http://www.amzi.com/AdventureInProlog/appendix.htm (6 of 27)11/3/2006 7:06:15 PM,NA
eat2(Thing):-,NA,NA
" edible(Thing),",NA,NA
" retract(have(Thing)),",NA,NA
" respond(['That ',Thing,' was good']).",NA,NA
eat2(Thing):-,NA,NA
" tastes_yuchy(Thing),",NA,NA
" respond(['Three year olds don''t eat ',Thing]).",NA,NA
eat2(Thing):-,NA,NA
" respond(['You can''t eat a ',Thing]).",NA,NA
% inventory list your possesions,NA,NA
inventory:-,NA,NA
" have(X),                         % make sure you have at least one thing ",NA,NA
"write('You have: '),nl,",NA,NA
 list_possessions.,NA,NA
inventory:-,NA,NA
" write('You have nothing'),nl.",NA,NA
list_possessions:-,NA,NA
" have(X),",NA,NA
" tab(2),write(X),nl,",NA,NA
 fail.,NA,NA
list_possessions.,NA,NA
% turn_on recognizes two cases.  If the player tries to simply turn ,NA,NA
"% on the light, it is assumed this is the room light, and the % ",NA,NA
appropriate error message is issued.  Otherwise turn_on has to % ,NA,NA
refer to an object which is turned_off.,NA,NA
turn_on(light):-,NA,NA
 respond(['You can''t reach the switch and there''s nothing to stand on']).,NA,NA
turn_on(Thing):-,NA,NA
" have(Thing),",NA,NA
 turn_on2(Thing).,NA,NA
turn_on(Thing):-,NA,NA
" respond(['You don''t have the ',Thing]).",NA,NA
turn_on2(Thing):-,NA,NA
" turned_on(Thing),",NA,NA
" respond([Thing,' is already on']).",NA,NA
turn_on2(Thing):-,NA,NA
" turned_off(Thing),",NA,NA
" retract(turned_off(Thing)),",NA,NA
" asserta(turned_on(Thing)),",NA,NA
" respond([Thing,' turned on']).",NA,NA
turn_on2(Thing):-,NA,NA
" respond(['You can''t turn a ',Thing,' on']).",NA,NA
% turn_off - I didn't feel like implementing turn_off,NA,NA
turn_off(Thing):-,NA,NA
 respond(['I lied about being able to turn things off']).,NA,NA
% The only special puzzle in Nani Search has to do with going to the ,NA,NA
% cellar.  Puzzle is only called from goto for this reason.  Other % ,NA,NA
puzzles pertaining to other commands could easily be added.,NA,NA
puzzle(goto(cellar)):-,NA,NA
" have(flashlight),",NA,NA
" turned_on(flashlight),!.",NA,NA
puzzle(goto(cellar)):-,NA,NA
" write('You can''t go to the cellar because it''s dark in the'),nl, ",NA,NA
"write('cellar, and you''re afraid of the dark.'),nl,",NA,NA
" !,fail.",NA,NA
puzzle(_).,NA,NA
% respond simplifies writing a mixture of literals and variables,NA,NA
respond([]):-,NA,NA
" write('.'),nl,nl.",NA,NA
respond([H|T]):-,NA,NA
" write(H),",NA,NA
 respond(T).,NA,NA
% Simple English command listener.  It does some semantic checking % ,NA,NA
and allows for various synonyms.  Within a restricted subset of % ,NA,NA
"English, a command can be phrased many ways.  Also non grammatical % ",NA,NA
"constructs are understood, for example just giving a room name % is ",NA,NA
interpreted as the command to goto that room.,NA,NA
% Some interpretation is based on the situation.  Notice that when % ,NA,NA
the player says turn on the light it is ambiguous.  It could mean % ,NA,NA
the room light (which can't be turned on in the game) or the % flash ,NA,NA
light.  If the player has the flash light it is interpreted % as ,NA,NA
"flash light, otherwise it is interpreted as room light.",NA,NA
get_command(C):-,NA,NA
" readlist(L),        % reads a sentence and puts [it,in,list,form] ",NA,NA
"command(X,L,[]),    % call the grammar for command",NA,NA
" C =.. X,!.          % make the command list a structure ",NA,NA
get_command(_):-,NA,NA
" respond(['I don''t understand, try again or type help']),fail.",http://www.amzi.com/AdventureInProlog/appendix.htm (8 of 27)11/3/2006 7:06:15 PM,NA
% The grammar doesn't have to be real English.  There are two % ,NA,NA
"types of commands in Nani Search, those with and without a % ",NA,NA
single argument.  A special case is also made for the command % ,NA,NA
goto which can be activated by simply giving a room name.,NA,NA
"command([Pred,Arg]) --> verb(Type,Pred),nounphrase(Type,Arg). ",NA,NA
"command([Pred]) --> verb(intran,Pred).",NA,NA
"command([goto,Arg]) --> noun(go_place,Arg).",NA,NA
"% Recognize three types of verbs.  Each verb corresponds to a command, ",NA,NA
% but there are many synonyms allowed.  For example the command ,NA,NA
"% turn_on will be triggered by either ""turn on"" or ""switch on"".",NA,NA
"verb(go_place,goto) --> go_verb.",NA,NA
"verb(thing,V) --> tran_verb(V). ",NA,NA
"verb(intran,V) --> intran_verb(V).",NA,NA
go_verb --> [go].,NA,NA
"go_verb --> [go,to]. ",NA,NA
go_verb --> [g].,NA,NA
tran_verb(take) --> [take].,NA,NA
"tran_verb(take) --> [pick,up].",NA,NA
tran_verb(drop) --> [drop].,NA,NA
tran_verb(drop) --> [put].,NA,NA
"tran_verb(drop) --> [put,down].",NA,NA
tran_verb(eat) --> [eat].,NA,NA
"tran_verb(turn_on) --> [turn,on]. ",NA,NA
"tran_verb(turn_on) --> [switch,on]. ",NA,NA
"tran_verb(turn_off) --> [turn,off].",NA,NA
"tran_verb(look_in) --> [look,in]. ",NA,NA
tran_verb(look_in) --> [look].,NA,NA
tran_verb(look_in) --> [open].,NA,NA
intran_verb(inventory) --> [inventory]. ,NA,NA
intran_verb(inventory) --> [i].,NA,NA
intran_verb(look) --> [look].,NA,NA
"intran_verb(look) --> [look,around]. ",NA,NA
intran_verb(look) --> [l].,NA,NA
intran_verb(quit) --> [quit].,NA,NA
intran_verb(quit) --> [exit].,NA,NA
intran_verb(quit) --> [end].,NA,NA
intran_verb(quit) --> [bye].,NA,NA
intran_verb(nshelp) --> [help].,NA,NA
intran_verb(hint) --> [hint].,NA,NA
% a noun phrase is just a noun with an optional determiner in front.,NA,NA
"nounphrase(Type,Noun) --> det,noun(Type,Noun). ",NA,NA
"nounphrase(Type,Noun) --> noun(Type,Noun).",NA,NA
det --> [the]. ,NA,NA
det --> [a].,NA,NA
"% Nouns are defined as rooms, or things located somewhere.  We define ",NA,NA
% special cases for those things represented in Nani Search by two % ,NA,NA
words.  We can't expect the user to type the name in quotes.,NA,NA
"noun(go_place,R) --> [R], {room(R)}.",NA,NA
"noun(go_place,'dining room') --> [dining,room].",NA,NA
"noun(thing,T) --> [T], {location(T,_)}.",NA,NA
"noun(thing,T) --> [T], {have(T)}.",NA,NA
"noun(thing,flashlight) --> [flash,light].",NA,NA
"noun(thing,'washing machine') --> [washing,machine].",NA,NA
"noun(thing,'dirty clothes') --> [dirty,clothes].",NA,NA
"% If the player has just typed light, it can be interpreted three ways.",NA,NA
"% If a room name is before it, it must be a room light.  If the ",NA,NA
"% player has the flash light, assume it means the flash light.  Otherwise ",NA,NA
% assume it is the room light.,NA,NA
"noun(thing,light) --> [X,light], {room(X)}.",NA,NA
"noun(thing,flashlight) --> [light], {have(flashlight)}. ",NA,NA
"noun(thing,light) --> [light].",NA,NA
"% readlist - read a list of words, based on a Clocksin & Mellish ",NA,NA
% example.,NA,NA
readlist(L):-,NA,NA
" write('> '),",NA,NA
 read_word_list(L).,NA,NA
read_word_list([W|Ws]) :-,NA,NA
" get0(C),",NA,NA
" readword(C, W, C1),       % Read word starting with C, C1 is first new ",NA,NA
"restsent(C1, Ws), !.      % character - use it to get rest of sentence",NA,NA
"restsent(C,[]) :- lastword(C), !. % Nothing left if hit last-word marker ",NA,NA
"restsent(C,[W1|Ws]) :-",NA,NA
" readword(C,W1,C1),        % Else read next word and rest of sentence ",NA,NA
"restsent(C1,Ws).",NA,NA
"readword(C,W,C1) :-         % Some words are single characters",NA,NA
" single_char(C),           % i.e. punctuation ",NA,NA
"!, ",NA,NA
" name(W, [C]),             % get as an atom ",NA,NA
get0(C1).,NA,NA
"readword(C, W, C1) :-",NA,NA
" is_num(C),                % if we have a number --",NA,NA
" !,",NA,NA
" number_word(C, W, C1, _). % convert it to a genuine number ",NA,NA
"readword(C,W,C2) :-         % otherwise if character does not ",NA,NA
"in_word(C, NewC),         % delineate end of word - keep ",NA,NA
"get0(C1),                 % accumulating them until ",NA,NA
" restword(C1,Cs,C2),       % we have all the word      ",NA,NA
"name(W, [NewC|Cs]).       % then make it an atom ",NA,NA
"readword(C,W,C2) :-         % otherwise",NA,NA
" get0(C1),       ",NA,NA
" readword(C1,W,C2).        % start a new word",NA,NA
"restword(C, [NewC|Cs], C2) :-",NA,NA
" in_word(C, NewC),",NA,NA
" get0(C1),",NA,NA
" restword(C1, Cs, C2). ",NA,NA
"restword(C, [], C).",NA,NA
"single_char(`,).",NA,NA
single_char(`;).,NA,NA
single_char(`:).single_char(`?). ,NA,NA
single_char(`!).,NA,NA
single_char(`.).,NA,NA
"in_word(C, C) :- C >= `a, C =< `z.",NA,NA
"in_word(C, L) :- C >= `A, C =< `Z, L is C + 32. ",NA,NA
"in_word(`',`').",NA,NA
"in_word(`-,`-).",NA,NA
% Have character C (known integer) - keep reading integers and build ,NA,NA
"% up the number until we hit a non-integer. Return this in C1, % and ",NA,NA
return the computed number in W.,NA,NA
"number_word(C, W, C1, Pow10) :- ",NA,NA
" is_num(C),",NA,NA
" !,",NA,NA
" get0(C2),",NA,NA
" number_word(C2, W1, C1, P10),",NA,NA
" Pow10 is P10 * 10,",NA,NA
 W is integer(((C - `0) * Pow10) + W1).,NA,NA
"number_word(C, 0, C, 0.1).",NA,NA
is_num(C) :-,NA,NA
" C =< `9,",NA,NA
 C >= `0.,NA,NA
% These symbols delineate end of sentence,NA,NA
lastword(10).   % end if new line entered ,NA,NA
lastword(`.). ,NA,NA
lastword(`!). ,NA,NA
lastword(`?).,NA,NA
Family ,NA,NA
% GENE.PRO - genealogical relationships ,NA,NA
% ,NA,NA
% Copyright (c) 1987-1995 Amzi! inc.,NA,NA
% All rights reserved ,NA,NA
% ,NA,NA
% A Prolog database of relations derived from basic information about ,NA,NA
% individuals.  The relations ships can all be read as 'relationship % ,NA,NA
"of', so for example, parent(P,C) means P is parent of C.",NA,NA
% ,NA,NA
"% When there is a performance trade-of in the implementation of a rule, % ",NA,NA
it is assumed that in general the second argument of a relation will % ,NA,NA
"most likely be bound.  See for example full_sibling/2, which will % have a ",NA,NA
"smaller search for full_sibling(X,joe), than full_sibling(joe,X).",NA,NA
% ,NA,NA
% This code is used as an example of an embedded Prolog application. ,NA,NA
% One is a C++ application and the other Visual Basic.,NA,NA
% ,NA,NA
"% To use this code from Prolog, consult it in the listener and use the % ",NA,NA
following predicates: ,NA,NA
% ,NA,NA
"% open(F) - opens a file of family relationships, ex. open('england.fam'). ",NA,NA
"%    open/1 just does a consult, so you can use consult instead.",NA,NA
% close - retracts all the persons currently defined ,NA,NA
% save(F) - saves the persons in the named file ,NA,NA
"% add_person(Name, Mother, Father, Gender, Spouse) - adds a person %     ",NA,NA
"fact with the specified attributes, checking semantics as it does % ",NA,NA
"Relationship(P1, P2) - any relationship query, such as child(X,Y).",NA,NA
"% relation(R, P1, P2) - can be used to find the relationship between ",NA,NA
%     individuals as well as pose relationship queries. ,NA,NA
"parent(P,C) :-",NA,NA
" (mother(P,C) ; father(P,C)).",NA,NA
"child(C,P) :- parent(P,C).",NA,NA
"son(C,P) :- parent(P,C), male(C).",NA,NA
"daughter(C,P) :- parent(P,C), female(C).",NA,NA
"wife(W,P) :-",NA,NA
" spouse(W,P),",NA,NA
 female(W).,NA,NA
"husband(H,P) :-",NA,NA
" spouse(H,P),",NA,NA
 male(H).,NA,NA
"ancestor(A,P) :-",NA,NA
" parent(A,P).",NA,NA
"ancestor(A,P) :-",NA,NA
" parent(X,P),",NA,NA
" ancestor(A,X).",NA,NA
"descendent(D,P) :-",NA,NA
" parent(P,D).",NA,NA
"descendent(D,P) :-",NA,NA
" parent(P,X),",NA,NA
" descendent(D,X).",NA,NA
"full_sibling(S1, S2) :-",NA,NA
" mother(M,S2),",NA,NA
" mother(M,S1),",NA,NA
" S1 \= S2,",NA,NA
" father(F,S1),",NA,NA
" father(F,S2).",NA,NA
"half_sibling(S1, S2) :-",NA,NA
" mother(M,S2),",NA,NA
" mother(M,S1),",NA,NA
" S1 \= S2,",NA,NA
" father(F1,S1),",NA,NA
" father(F2,S2),",NA,NA
 F1 \= F2.,NA,NA
"half_sibling(S1, S2) :-",NA,NA
" father(F,S2),",NA,NA
" father(F,S1),",NA,NA
" S1 \= S2,",NA,NA
" mother(M1,S1),",http://www.amzi.com/AdventureInProlog/appendix.htm (13 of 27)11/3/2006 7:06:15 PM,NA
" mother(M2,S2),",NA,NA
 M1 \= M2.,NA,NA
"sibling(S1, S2) :-",NA,NA
" full_sibling(S1,S2).",NA,NA
"sibling(S1, S2) :-",NA,NA
" half_sibling(S1,S2).",NA,NA
"sister(S,P) :-",NA,NA
" sibling(S,P),",NA,NA
 female(S).,NA,NA
"brother(B,P) :-",NA,NA
" sibling(B,P),",NA,NA
 male(B).,NA,NA
"step_sibling(S1, S2) :-",NA,NA
" parent(P2, S2),",NA,NA
" spouse(M2, P2),",NA,NA
" parent(M2, S1),",NA,NA
" not(parent(M2,S2)),",NA,NA
" not(half_sibling(S1,S2)).",NA,NA
"uncle(U,X) :-",NA,NA
" parent(P,X),",NA,NA
" brother(U,P).",NA,NA
"aunt(A,X) :-",NA,NA
" parent(P,X),",NA,NA
" sister(A,P).",NA,NA
"step_parent(P2,C) :-",NA,NA
" parent(P,C),",NA,NA
" spouse(P2,P),",NA,NA
" not(parent(P2,C)).",NA,NA
"step_mother(M,C) :- step_parent(M,C), female(M).",NA,NA
"step_father(F,C) :- step_parent(F,C), male(F).",NA,NA
"step_child(C2,P) :- step_parent(P,C2).",NA,NA
"step_daughter(D,P) :- step_child(D,P), female(D).",NA,NA
"step_son(S,P) :- step_child(S,P), male(S).",NA,NA
"nephew(N,X) :-",http://www.amzi.com/AdventureInProlog/appendix.htm (14 of 27)11/3/2006 7:06:15 PM,NA
" sibling(S,X),",NA,NA
" parent(S,N),",NA,NA
 male(N).,NA,NA
"niece(N,X) :-",NA,NA
" sibling(S,X),",NA,NA
" parent(S,N),",NA,NA
 female(N).,NA,NA
"cousin(X,Y) :-",NA,NA
" parent(P,Y),",NA,NA
" sibling(S,P),",NA,NA
" parent(S,X).",NA,NA
"grandmother(GM,X) :-",NA,NA
" parent(P,X),",NA,NA
" mother(GM,P).",NA,NA
"grandfather(GF,X) :-",NA,NA
" parent(P,X),",NA,NA
" father(GF,P).",NA,NA
"grandparent(GP,X) :-",NA,NA
" parent(P,X),  parent(GP,P).",NA,NA
"grandson(GS,X) :-",NA,NA
" grandchild(GS,X),",NA,NA
 male(GS).,NA,NA
"granddaughter(GD,X) :-",NA,NA
" grandchild(GD,X),",NA,NA
 female(GD).,NA,NA
"grandchild(GC,X) :-",NA,NA
" parent(X,C),",NA,NA
" parent(C,GC).",NA,NA
%----------------------------------------------------------------------,NA,NA
% relation/3 - used to find relationships between individuals ,NA,NA
%,NA,NA
"relations([parent, wife, husband, ancestor, descendent, full_sibling, ",NA,NA
"half_sibling, sibling, sister, brother, step_sibling, uncle, aunt, ",NA,NA
"mother, father, child, son, daughter, step_parent,",NA,NA
" step_child, step_mother, step_father, step_son, step_daughter, ",NA,NA
"nephew, niece, cousin, grandmother, grandfather, grandparent, ",NA,NA
"grandson, granddaughter, grandchild]).",http://www.amzi.com/AdventureInProlog/appendix.htm (15 of 27)11/3/2006 7:06:15 PM,NA
"relation(R, X, Y) :-",NA,NA
" relations(Rs),",NA,NA
" member(R,Rs),",NA,NA
" Q =.. [R,X,Y],",NA,NA
 call(Q).,NA,NA
%----------------------------------------------------------------------,NA,NA
% person object ,NA,NA
% ,NA,NA
% These predicates define the interface to a person.  All of the % ,NA,NA
"genealogical rules are based on these predicates, which are ",NA,NA
% based on the basic representation of a person.  These are the ,NA,NA
% only rules which need to be changed if the representation of ,NA,NA
% a person is changed.,NA,NA
% ,NA,NA
% The current representation is flat database relations of the form: ,NA,NA
"%   person(Name, Gender, Mother, Father, Spouse).",NA,NA
%,NA,NA
"add(Name,Gender,Mother,Father,Spouse) :-",NA,NA
" assert(person(Name,Gender,Mother,Father,Spouse)).",NA,NA
"add(Name,_,_,_,_) :-",NA,NA
" delete(Name),",NA,NA
 fail.,NA,NA
open(FileName) :-,NA,NA
 consult(FileName).,NA,NA
close :-,NA,NA
" retractall(person(_,_,_,_,_)).",NA,NA
save(FileName) :-,NA,NA
" tell(FileName),",NA,NA
" listing(person),",NA,NA
 told.,NA,NA
delete(X) :-,NA,NA
" retract(person(X,_,_,_,_)).",NA,NA
person(X) :-,NA,NA
" person(X,_,_,_,_).",NA,NA
male(X) :-,NA,NA
" person(X,male,_,_,_).",http://www.amzi.com/AdventureInProlog/appendix.htm (16 of 27)11/3/2006 7:06:15 PM,NA
female(Y) :-,NA,NA
" person(Y,female,_,_,_).",NA,NA
"mother(M,C) :-",NA,NA
" person(C,_,M,_,_).",NA,NA
"father(F,C) :-",NA,NA
" person(C,_,_,F,_).",NA,NA
"spouse(S,P) :-",NA,NA
" person(P,_,_,_,S),",NA,NA
 S \= single.,NA,NA
%----------------------------------------------------------------------,NA,NA
% Semantic Integrity Checks on Update ,NA,NA
%,NA,NA
"add_person(Name,Gender,Mother,Father,Spouse) :- ",NA,NA
"retractall(message(_)),",NA,NA
" dup_check(Name),",NA,NA
" add(Name,Gender,Mother,Father,Spouse),",NA,NA
" ancestor_check(Name),",NA,NA
" mother_check(Name, Gender, Mother),",NA,NA
" father_check(Name, Gender, Father),",NA,NA
" spouse_check(Name, Spouse).",NA,NA
dup_check(Name) :-,NA,NA
" person(Name),",NA,NA
" assert(message($Person is already in database$)), ",NA,NA
"!, fail.",NA,NA
dup_check(_).,NA,NA
ancestor_check(Name) :-,NA,NA
" ancestor(Name,Name),",NA,NA
" assert(message($Person is their own ancestor/descendent$)), ",NA,NA
"!, fail.",NA,NA
ancestor_check(_).,NA,NA
"mother_check(_, _, Mother) :- not(person(Mother)), !.",NA,NA
"mother_check(_, _, Mother) :-",NA,NA
" male(Mother),",NA,NA
" assert(message($Person's mother is a man$)), ",NA,NA
"!, fail.",NA,NA
"mother_check(Name, male, _) :-",NA,NA
" mother(Name, X),",NA,NA
" assert(message($Person, a male, is someone's mother$)), ",NA,NA
"!, fail.",http://www.amzi.com/AdventureInProlog/appendix.htm (17 of 27)11/3/2006 7:06:15 PM,NA
"mother_check(_,_,_).",NA,NA
"father_check(_, _, Father) :- not(person(Father)), !.",NA,NA
"father_check(_, _, Father) :-",NA,NA
" female(Father),",NA,NA
" assert(message($Person's father is a man$)), ",NA,NA
"!, fail.",NA,NA
"father_check(Name, female, _) :-",NA,NA
" father(Name, X),",NA,NA
" assert(message($Person, a female, is someone's father$)), ",NA,NA
"!, fail.",NA,NA
"father_check(_,_,_).",NA,NA
"spouse_check(Name, Spouse) :-",NA,NA
" spouse(Name, X),",NA,NA
" X \= Spouse,",NA,NA
" assert(message($Person is already someone else's spouse$)), ",NA,NA
"!, fail.",NA,NA
"spouse_check(Name, Spouse) :-",NA,NA
" blood_relative(Name, Spouse),",NA,NA
" assert(message($Person is a blood relative of spouse$)), ",NA,NA
"!, fail.",NA,NA
"spouse_check(_,_).",NA,NA
"blood_relative(X,Y) :- (ancestor(X,Y); ancestor(Y,X)). ",NA,NA
"blood_relative(X,Y) :- sibling(X,Y).",NA,NA
"blood_relative(X,Y) :- cousin(X,Y).",NA,NA
"blood_relative(X,Y) :- (uncle(X,Y); uncle(Y,X)).",NA,NA
"blood_relative(X,Y) :- (aunt(X,Y); aunt(Y,X)).",NA,NA
Custord ,NA,NA
% CUSTORD ,NA,NA
% Copyright (c) 1990-1995 Amzi! inc. ,NA,NA
% All rights reserved,NA,NA
% This is a sample Prolog program which implements a portion ,NA,NA
% of a customer order inventory application.  It is not intended to % ,NA,NA
"be complete, and only illustrates the concept of writing a database % ",NA,NA
application in Prolog.,NA,NA
% This example extends the concept of an intelligent database to include ,NA,NA
% a full database application.  It is really a rule based approach to % ,NA,NA
transaction processing.  In fact a large percentage of the procedural % ,NA,NA
code normally written in database applications has to do with ,NA,NA
% enforcing semantic integrity rules involving multiple records.,NA,NA
% The distinction between data and process is thoroughly blurred.  Both ,NA,NA
% reside together in the same logicbase.,NA,NA
% There is pure data as it might be defined in a relational database % ,NA,NA
"(customer, item, inventory, order); there are rules which really % ",NA,NA
represent data views (item_quant); there are rules which add ,NA,NA
"% intelligence to the logicbase (good_customer, valid_order); and there ",NA,NA
"% are rules which are processes (order, report_inventory). ",NA,NA
main :- order.,NA,NA
"% customer(Name, Town, Credit-rating).",NA,NA
"customer(dennis, winchester, xxx).",NA,NA
"customer(dave, lexington, aaa).",NA,NA
"customer(ron, lexington, bbb). ",NA,NA
"customer(julie, winchester, aaa). ",NA,NA
"customer(jawaid, cambridge, aaa). ",NA,NA
"customer(tom, newton, ccc).",NA,NA
"% item(Number, Name, Reorder-quantity).",NA,NA
"item(p1,thing,10).",NA,NA
"item(p2,stuff,10).",NA,NA
"item(p3,article,10). ",NA,NA
"item(p4,object,10).",NA,NA
"item(p5,substance,10). ",NA,NA
"item(p6,piece,10).",NA,NA
"item(p7,matter,10).",NA,NA
"% inventory(Number, Quantity).",NA,NA
"inventory(p1,10). ",NA,NA
"inventory(p2,10). ",NA,NA
"inventory(p3,10). ",NA,NA
"inventory(p4,78). ",NA,NA
"inventory(p5,23). ",NA,NA
"inventory(p6,14). ",NA,NA
"inventory(p7,8).",NA,NA
% item-inv view or join,NA,NA
"item_quant(Item, Quantity):-",NA,NA
" item(Partno, Item, _),",NA,NA
" inventory(Partno, Quantity).",NA,NA
% reorder if inventory below reorder point,NA,NA
reorder(Item):-,NA,NA
" item(Partno, Item, Reorder_point), ",NA,NA
"inventory(Partno, Quantity),",NA,NA
" Quantity < Reorder_point,",NA,NA
" write('Time to reorder '),",NA,NA
" write(Item), nl.",NA,NA
reorder(Item):-,NA,NA
" write('Inventory level ok for '), ",NA,NA
"write(Item), nl.",NA,NA
% a good customer has a credit rating of aaa ,NA,NA
% or lives in winchester ,NA,NA
% or has ordered something,NA,NA
good_customer(Cust):-,NA,NA
" customer(Cust, _, aaa).",NA,NA
good_customer(Cust):-,NA,NA
" customer(Cust, winchester, _).",NA,NA
good_customer(Cust):-,NA,NA
" order(Cust, _, _).",NA,NA
% process order,NA,NA
order:-,NA,NA
" write('Customer: '),",NA,NA
" read(Customer),",NA,NA
" write('Item: '),",NA,NA
" read(Item),",NA,NA
" write('Quantity: '),",NA,NA
" read(Quantity),",NA,NA
" valid_order(Customer,Item,Quantity), ",NA,NA
"asserta(order(Customer,Item,Quantity)), ",NA,NA
"update_inventory(Item,Quantity),",NA,NA
 reorder(Item).,NA,NA
% an order is valid if ,NA,NA
% it doesn't go below zero inventory and ,NA,NA
% the customer is a good customer,NA,NA
"valid_order(C, I, Q):-",NA,NA
" item(Partno, I, _),",NA,NA
" inventory(Partno, Onhand),",NA,NA
" Q =< Onhand,",NA,NA
 good_customer(C).,NA,NA
"valid_order(C, I, Q):-",http://www.amzi.com/AdventureInProlog/appendix.htm (20 of 27)11/3/2006 7:06:15 PM,NA
" write('Bad order'),",NA,NA
" nl,",NA,NA
 fail.,NA,NA
% update the inventory,NA,NA
"update_inventory(I,Q):-",NA,NA
" item(Pn, I, _),",NA,NA
" inventory(Pn, Amount),",NA,NA
" NewQ is Amount - Q,",NA,NA
" retract(inventory(Pn, Amount)),",NA,NA
" asserta(inventory(Pn, NewQ)).",NA,NA
% inventory report,NA,NA
report_inventory:-,NA,NA
" item_quant(I, Q),",NA,NA
" write(I), tab(1),",NA,NA
" write(Q), nl,",NA,NA
 fail.,NA,NA
report_inventory:-true. ,NA,NA
Birds ,NA,NA
% BIRDS,NA,NA
% Copyright (c) 1990-1995 Amzi! inc. ,NA,NA
% All rights reserved,NA,NA
% This is a sample of a classification expert system for identification ,NA,NA
"% of certain kinds of birds. The rules are rough excerpts from ""Birds of ",NA,NA
"% North America"" by Robbins, Bruum, Zim, and Singer.",NA,NA
% This type of expert system can easily use Prolog's built in inferencing ,NA,NA
"% system. While trying to satisfy the goal ""bird"" it tries to satisfy % ",NA,NA
"various subgoals, some of which will ask for information from the % user.",NA,NA
% The information is all stored as attribute-value pairs. The attribute ,NA,NA
"% is represented as a predicate, and the value as the argument to the % ",NA,NA
"predicate. For example, the attribute-value pair ""color-brown"" is % ",NA,NA
"stored ""color(brown)"".",NA,NA
"% ""identify"" is the high level goal that starts the program. The % ",NA,NA
"predicate ""known/3"" is used to remember answers to questions, so it % ",NA,NA
is cleared at the beginning of the run.,http://www.amzi.com/AdventureInProlog/appendix.htm (21 of 27)11/3/2006 7:06:15 PM,NA
% The rules of identification are the bulk of the code. They break up ,NA,NA
% the problem into identifying orders and families before identifying ,NA,NA
% the actual birds.,NA,NA
% The end of the code lists those attribute-value pairs which need ,NA,NA
"% to be asked for, and defines the predicate ""ask"" and ""menuask"" % ",NA,NA
"which are used to get information from the user, and remember it.",NA,NA
main :- identify.,NA,NA
identify:-,NA,NA
" retractall(known(_,_,_)),         % clear stored information ",NA,NA
"bird(X),",NA,NA
" write('The bird is a '),write(X),nl.",NA,NA
identify:-,NA,NA
" write('I can''t identify that bird'),nl.",NA,NA
order(tubenose):-,NA,NA
" nostrils(external_tubular),",NA,NA
" live(at_sea),",NA,NA
 bill(hooked).,NA,NA
order(waterfowl):-,NA,NA
" feet(webbed),",NA,NA
 bill(flat).,NA,NA
order(falconiforms):-,NA,NA
" eats(meat),",NA,NA
" feet(curved_talons),",NA,NA
 bill(sharp_hooked).,NA,NA
order(passerformes):-,NA,NA
 feet(one_long_backward_toe).,NA,NA
family(albatross):-,NA,NA
" order(tubenose),",NA,NA
" size(large),",NA,NA
 wings(long_narrow).,NA,NA
family(swan):-,NA,NA
" order(waterfowl),",NA,NA
" neck(long),",NA,NA
" color(white),",NA,NA
 flight(ponderous).,NA,NA
family(goose):-,NA,NA
" order(waterfowl),",NA,NA
" size(plump),",NA,NA
 flight(powerful).,NA,NA
family(duck):-,NA,NA
" order(waterfowl),",NA,NA
" feed(on_water_surface),",NA,NA
 flight(agile).,NA,NA
family(vulture):-,NA,NA
" order(falconiforms),",NA,NA
" feed(scavange),",NA,NA
 wings(broad).,NA,NA
family(falcon):-,NA,NA
" order(falconiforms),",NA,NA
" wings(long_pointed),",NA,NA
" head(large),",NA,NA
 tail(narrow_at_tip).,NA,NA
family(flycatcher):-,NA,NA
" order(passerformes),",NA,NA
" bill(flat),",NA,NA
 eats(flying_insects).,NA,NA
family(swallow):-,NA,NA
" order(passerformes),",NA,NA
" wings(long_pointed),",NA,NA
" tail(forked),",NA,NA
 bill(short).,NA,NA
bird(laysan_albatross):-,NA,NA
" family(albatross),",NA,NA
 color(white).,NA,NA
bird(black_footed_albatross):-,NA,NA
" family(albatross),",NA,NA
 color(dark).,NA,NA
bird(fulmar):-,NA,NA
" order(tubenose),",NA,NA
" size(medium),",NA,NA
 flight(flap_glide).,NA,NA
bird(whistling_swan):-,NA,NA
" family(swan),",NA,NA
 voice(muffled_musical_whistle).,NA,NA
bird(trumpeter_swan):-,NA,NA
" family(swan),",NA,NA
 voice(loud_trumpeting).,NA,NA
bird(canada_goose):-,NA,NA
" family(goose),",NA,NA
" season(winter),                % rules can be further broken down ",NA,NA
"country(united_states),        % to include regions and migration ",NA,NA
"head(black),                   % patterns",NA,NA
 cheek(white).,NA,NA
bird(canada_goose):-,NA,NA
" family(goose),",NA,NA
" season(summer),",NA,NA
" country(canada),",NA,NA
" head(black), ",NA,NA
 cheek(white).,NA,NA
bird(snow_goose):-,NA,NA
" family(goose),",NA,NA
 color(white).,NA,NA
bird(mallard):-,NA,NA
" family(duck),                  % different rules for male ",NA,NA
"voice(quack),",NA,NA
 head(green).,NA,NA
bird(mallard):-,NA,NA
" family(duck),                  % and female ",NA,NA
"voice(quack),",NA,NA
 color(mottled_brown).,NA,NA
bird(pintail):-,NA,NA
" family(duck),",NA,NA
 voice(short_whistle).,NA,NA
bird(turkey_vulture):-,NA,NA
" family(vulture),",NA,NA
 flight_profile(v_shaped).,NA,NA
bird(california_condor):-,NA,NA
" family(vulture),",NA,NA
 flight_profile(flat).,NA,NA
bird(sparrow_hawk):-,NA,NA
" family(falcon),",NA,NA
 eats(insects).,NA,NA
bird(peregrine_falcon):-,NA,NA
" family(falcon),",NA,NA
 eats(birds).,NA,NA
bird(great_crested_flycatcher):-,NA,NA
" family(flycatcher),",NA,NA
 tail(long_rusty).,NA,NA
bird(ash_throated_flycatcher):-,NA,NA
" family(flycatcher),",NA,NA
 throat(white).,NA,NA
bird(barn_swallow):-,NA,NA
" family(swallow),",NA,NA
 tail(forked).,NA,NA
bird(cliff_swallow):-,NA,NA
" family(swallow),",NA,NA
 tail(square).,NA,NA
bird(purple_martin):-,NA,NA
" family(swallow),",NA,NA
 color(dark).,NA,NA
country(united_states):- region(new_england). ,NA,NA
country(united_states):- region(south_east).,NA,NA
country(united_states):- region(mid_west). ,NA,NA
country(united_states):- region(south_west).,NA,NA
country(united_states):- region(north_west). ,NA,NA
country(united_states):- region(mid_atlantic).,NA,NA
country(canada):- province(ontario). ,NA,NA
country(canada):- province(quebec).,NA,NA
country(canada):- province(etc).,NA,NA
region(new_england):-,NA,NA
" state(X),",NA,NA
" member(X, [massachusetts, vermont, etc]).",NA,NA
region(south_east):-,NA,NA
" state(X),",NA,NA
" member(X, [florida, mississippi, etc]).",NA,NA
region(canada):-,NA,NA
" province(X),",NA,NA
" member(X, [ontario,quebec,etc]).",NA,NA
"nostrils(X):- ask(nostrils,X).",NA,NA
"live(X):- ask(live,X).",NA,NA
"bill(X):- ask(bill,X).",NA,NA
"size(X):- menuask(size,X,[large,plump,medium,small]).",NA,NA
"eats(X):- ask(eats,X).",NA,NA
"feet(X):- ask(feet,X).",NA,NA
"wings(X):- ask(wings,X).",NA,NA
"neck(X):- ask(neck,X).",NA,NA
"color(X):- ask(color,X).",NA,NA
"flight(X):- menuask(flight,X,[ponderous,powerful,agile,flap_glide,other]). ",NA,NA
"feed(X):- ask(feed,X).",NA,NA
"head(X):- ask(head,X).",NA,NA
"tail(X):- menuask(tail,X,[narrow_at_tip,forked,long_rusty,square,other]). ",NA,NA
"voice(X):- ask(voice,X).",NA,NA
"season(X):- menuask(season,X,[winter,summer]).",NA,NA
"cheek(X):- ask(cheek,X).",NA,NA
"flight_profile(X):- menuask(flight_profile,X,[flat,v_shaped,other]).",NA,NA
"throat(X):- ask(throat,X).",NA,NA
"state(X):- menuask(state,X,[massachusetts,vermont,florida,mississippi,etc]). ",NA,NA
"province(X):- menuask(province,X,[ontario,quebec,etc]).",NA,NA
"% ""ask"" is responsible for getting information from the user, and remembering ",NA,NA
% the users response. If it doesn't already know the answer to a question % ,NA,NA
it will ask the user. It then asserts the answer. It recognizes two ,NA,NA
"% cases of knowledge: 1) the attribute-value is known to be true, ",NA,NA
% 2) the attribute-value is known to be false.,NA,NA
% This means an attribute might have multiple values. A third test to ,NA,NA
% see if the attribute has another value could be used to enforce,NA,NA
% single valued attributes. (This test is commented out below),NA,NA
% For this system the menuask is used for attributes which are single ,NA,NA
% valued,NA,NA
"% ""ask"" only deals with simple yes or no answers. a ""yes"" is the only ",NA,NA
"% yes value. any other response is considered a ""no"".",NA,NA
"ask(Attribute,Value):-",NA,NA
" known(yes,Attribute,Value),       % succeed if we know its true ",NA,NA
!.                                % and dont look any further ,NA,NA
"ask(Attribute,Value):-",NA,NA
" known(_,Attribute,Value),         % fail if we know its false !, ",NA,NA
fail.,NA,NA
"ask(Attribute,_):-",NA,NA
" known(yes,Attribute,_),           % fail if we know its some other value. ",NA,NA
"!, fail.                          % the cut in clause #1 ensures that if",NA,NA
 % we get here the value is wrong.,NA,NA
"ask(A,V):-",NA,NA
" write(A:V),                       % if we get here, we need to ask.",NA,NA
" write('? (yes or no): '),",NA,NA
" read(Y),                          % get the answer",NA,NA
" asserta(known(Y,A,V)),            % remember it so we dont ask again.",NA,NA
 Y = yes.                          % succeed or fail based on answer.,NA,NA
"% ""menuask"" is like ask, only it gives the user a menu to to choose ",NA,NA
% from rather than a yes on no answer. In this case there is no % ,NA,NA
"need to check for a negative since ""menuask"" ensures there will % be ",NA,NA
some positive answer.,NA,NA
"menuask(Attribute,Value,_):-",NA,NA
" known(yes,Attribute,Value),       % succeed if we know ",NA,NA
!.,NA,NA
"menuask(Attribute,_,_):-",NA,NA
" known(yes,Attribute,_),           % fail if its some other value ",NA,NA
"!, fail.",NA,NA
"menuask(Attribute,AskValue,Menu):-",NA,NA
" nl,write('What is the value for '),write(Attribute),write('?'),nl, ",NA,NA
"display_menu(Menu),",NA,NA
" write('Enter the number of choice> '),",NA,NA
" read(Num),nl,",NA,NA
" pick_menu(Num,AnswerValue,Menu),",NA,NA
" asserta(known(yes,Attribute,AnswerValue)),",NA,NA
 AskValue = AnswerValue.           % succeed or fail based on answer,http://www.amzi.com/AdventureInProlog/appendix.htm (26 of 27)11/3/2006 7:06:15 PM,NA
display_menu(Menu):-,NA,NA
" disp_menu(1,Menu), !.             % make sure we fail on backtracking",NA,NA
"disp_menu(_,[]).",NA,NA
"disp_menu(N,[Item | Rest]):-        % recursively write the head of ",NA,NA
"write(N),write(' : '),write(Item),nl, % the list and disp_menu the tail ",NA,NA
"NN is N + 1,",NA,NA
" disp_menu(NN,Rest).",NA,NA
"pick_menu(N,Val,Menu):-",NA,NA
" integer(N),                       % make sure they gave a number ",NA,NA
"pic_menu(1,N,Val,Menu), !.        % start at one",NA,NA
" pick_menu(Val,Val,_).             % if they didn't enter a number, use",NA,NA
 % what they entered as the value,NA,NA
"pic_menu(_,_,none_of_the_above,[]). % if we've exhausted the list ",NA,NA
"pic_menu(N,N, Item, [Item|_]).      % the counter matches the number ",NA,NA
"pic_menu(Ctr,N, Val, [_|Rest]):-",NA,NA
" NextCtr is Ctr + 1,               % try the next one",NA,NA
" pic_menu(NextCtr, N, Val, Rest).","Copyright ©1990,1996-97, 2004 Amzi! inc. All Rights Reserved
  
 http://www.amzi.com/AdventureInProlog/appendix.htm (27 of 27)11/3/2006 7:06:15 PM",NA
Adventure in Prolog,NA,NA
Contents,NA,NA
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z,NA,NA
=/2,NA,NA
 Unification,NA,NA
 Lists ,NA,NA
"=/2, affect on backtracking",NA,NA
A,NA,NA
add_thing/3 ,NA,NA
add_thing2/3 ,NA,NA
Anonymous variables,NA,NA
 Unification,NA,NA
 Data Structures,NA,NA
 Rules: Using Rules ,NA,NA
append/3 ,NA,NA
"append/3, example trace of ",NA,NA
Arguments ,NA,NA
"Arithmetic, affect on backtracking ",NA,NA
"Arithmetic, expressions ",NA,NA
"Arithmetic, operators ",NA,NA
Arity ,NA,NA
"assert/1, and backtracking ",NA,NA
asserta/1 ,NA,NA
assertz/1 ,NA,NA
Associativity ,NA,NA
"Associativity, overriding",http://www.amzi.com/AdventureInProlog/advidx.htm (1 of 9)11/3/2006 7:06:23 PM,NA
Atoms ,NA,NA
"Atoms, syntax of",NA,NA
B,NA,NA
Backtracking,NA,NA
 Control Structures,NA,NA
 Compound Queries ,NA,NA
"Backtracking, and repeat/0 ",NA,NA
"Backtracking, cut ",NA,NA
"Backtracking, versus recursion ",NA,NA
Boundary condition ,NA,NA
"Boundary, condition ",NA,NA
break_out/1 ,NA,NA
Built-in predicates ,NA,NA
"Built-in predicates, as operators ",NA,NA
"Built-in predicates, example trace of",NA,NA
C,NA,NA
can_go/1 ,NA,NA
can_take_s/1 ,NA,NA
Character set ,NA,NA
Clauses,NA,NA
 Rules,NA,NA
 Getting Started: Jargon ,NA,NA
"Clauses, number ",NA,NA
command_loop/0 ,NA,NA
Compound queries ,NA,NA
"Compound query, example trace of ",NA,NA
Conjunction ,NA,NA
connect/2 ,NA,NA
consult/1 ,NA,NA
Cut,NA,NA
 Cut,http://www.amzi.com/AdventureInProlog/advidx.htm (2 of 9)11/3/2006 7:06:23 PM,NA
 Cut: Using the Cut ,NA,NA
"Cut, and fail/0 ",NA,NA
"Cut, examples of ",NA,NA
"Cut, performance considerations",NA,NA
D,NA,NA
DCG (Definite Clause Grammar) ,NA,NA
Difference lists ,NA,NA
"Difference lists, example trace of ",NA,NA
display/1,NA,NA
 Lists,NA,NA
 Operators ,NA,NA
do/1 ,NA,NA
door/2,NA,NA
 Compound Queries,NA,NA
 Facts: Nani Search ,NA,NA
dot/2,NA,NA
E,NA,NA
edible/1,NA,NA
 Compound Queries,NA,NA
 Facts: Nani Search,NA,NA
F,NA,NA
Facts,NA,NA
 Facts,NA,NA
 Getting Started: Jargon,NA,NA
 Facts: Nani Search ,NA,NA
fail/0 ,NA,NA
"fail/0, affect on backtracking ",NA,NA
"fail/0, and cut",http://www.amzi.com/AdventureInProlog/advidx.htm (3 of 9)11/3/2006 7:06:23 PM,NA
findall/3 ,NA,NA
Functors ,NA,NA
"Functors,as operators",NA,NA
G,NA,NA
Goals ,NA,NA
"Goals, combining ",NA,NA
"Goals, ports of ",NA,NA
"Goals, variables in ",NA,NA
goto/1,NA,NA
 Managing Data,NA,NA
 Cut: Using the Cut ,NA,NA
Grammar,NA,NA
I,NA,NA
I/O predicates ,NA,NA
"I/O predicates, affect on backtracking ",NA,NA
Integers ,NA,NA
is/2,NA,NA
 Operators,NA,NA
 Arithmetic ,NA,NA
is_contained_in/2,NA,NA
 Recursion,NA,NA
 Recursion: How Recursion Works ,NA,NA
is_in/2,NA,NA
L,NA,NA
list_things/1 ,NA,NA
list_things_s/1 ,NA,NA
Lists ,NA,NA
"Lists, and recursion",http://www.amzi.com/AdventureInProlog/advidx.htm (4 of 9)11/3/2006 7:06:23 PM,NA
"Lists, character ",NA,NA
"Lists, converting to facts ",NA,NA
"Lists, difference ",NA,NA
"Lists, dot notation ",NA,NA
"Lists, empty ",NA,NA
"Lists, head ",NA,NA
"Lists, syntax ",NA,NA
"Lists, tail ",NA,NA
loc_list/2 ,NA,NA
location/2,NA,NA
 Compound Queries: Built-in Predicates ,NA,NA
Simple Queries,NA,NA
 Compound Queries,NA,NA
 Recursion,NA,NA
 Simple Queries: How Queries Work,NA,NA
 Facts: Nani Search,NA,NA
 Lists: Using the List Utilities ,NA,NA
location_s/2 ,NA,NA
Logical variables ,NA,NA
look/0 ,NA,NA
Loops ,NA,NA
"Loops, endless ",NA,NA
"Loops, recursive",NA,NA
M,NA,NA
member/2 ,NA,NA
"member/2, example trace of ",NA,NA
mortal/1,NA,NA
 Getting Started: Jumping In,NA,NA
 Getting Started: Logic Programming ,NA,NA
mortal_report,NA,NA
N,http://www.amzi.com/AdventureInProlog/advidx.htm (5 of 9)11/3/2006 7:06:23 PM,NA
naive_reverse/2 ,NA,NA
Nani Search game ,NA,NA
"Nani Search game, example run of ",NA,NA
"Nani Search game, generally ",NA,NA
Natural language ,NA,NA
Neck symbol ,NA,NA
nl/0 ,NA,NA
"not/0, instead of ",NA,NA
not/1,NA,NA
 Data Structures,NA,NA
 Cut: Using the Cut,NA,NA
O,NA,NA
object/4 ,NA,NA
op/3 ,NA,NA
Operators,NA,NA
 Operators,NA,NA
 Arithmetic ,NA,NA
"Operators, associativity ",NA,NA
"Operators, infix ",NA,NA
"Operators, nonassociative ",NA,NA
"Operators, postfix ",NA,NA
"Operators, precedence ",NA,NA
"Operators, prefix",NA,NA
P,NA,NA
person/1,NA,NA
 Getting Started: Jumping In,NA,NA
 Getting Started: Logic Programming ,NA,NA
Ports ,NA,NA
"Ports, redo ",NA,NA
Precedence ,NA,NA
"Precedence, overriding",http://www.amzi.com/AdventureInProlog/advidx.htm (6 of 9)11/3/2006 7:06:23 PM,NA
"Precedence, problems with ",NA,NA
Predicates,NA,NA
 Getting Started,NA,NA
 Getting Started: Jargon ,NA,NA
"Predicates, arity ",NA,NA
"Predicates, arity of 0 ",NA,NA
"Predicates, built-in ",NA,NA
"Predicates, name of ",NA,NA
Prolog ,NA,NA
Prolog data vs. procedure ,NA,NA
Prolog listener,NA,NA
 Facts,NA,NA
 Getting Started: Jumping In ,NA,NA
"Prolog, flow of control",NA,NA
 Control Structures,NA,NA
 Rules: Using Rules ,NA,NA
"Prolog, origins of",NA,NA
Q,NA,NA
Queries ,NA,NA
"Queries, compound ",NA,NA
"Queries, simple examples of",NA,NA
R,NA,NA
Recursion ,NA,NA
"Recursion, example, trace of ",NA,NA
"Recursion, performance considerations",NA,NA
 Recursion: Pragmatics,NA,NA
 Control Structures: Recursive Control Loop ,NA,NA
"Recursion, versus backtracking ",NA,NA
Recursive case ,NA,NA
repeat/0 ,NA,NA
retract/1 ,NA,NA
room/1,http://www.amzi.com/AdventureInProlog/advidx.htm (7 of 9)11/3/2006 7:06:23 PM,NA
 Simple Queries,NA,NA
 Facts: Nani Search ,NA,NA
Rules,NA,NA
 Rules,NA,NA
 Getting Started: Jargon ,NA,NA
"Rules, example, trace of ",NA,NA
"Rules, multiple ",NA,NA
"Rules, unification",NA,NA
S,NA,NA
sleeps/1 ,NA,NA
Source code loading ,NA,NA
Structures ,NA,NA
"Structures, complex ",NA,NA
"Structures, unification",NA,NA
T,NA,NA
tab/1 ,NA,NA
take/1 ,NA,NA
take_object/1 ,NA,NA
tastes_yucky/1 ,NA,NA
Terms,NA,NA
U,NA,NA
unbound variables ,NA,NA
Unification,NA,NA
 Unification,NA,NA
 Simple Queries,NA,NA
 Simple Queries: How Queries Work ,NA,NA
"Unification, during recursion",http://www.amzi.com/AdventureInProlog/advidx.htm (8 of 9)11/3/2006 7:06:23 PM,NA
"Unification, explicit ",NA,NA
"Unification, implicit ",NA,NA
"Unification, lists ",NA,NA
"Unification, operators ",NA,NA
"Unification, rules ",NA,NA
"Unification, structures",NA,NA
 Unification,NA,NA
 Data Structures,NA,NA
V,NA,NA
Variables ,NA,NA
"Variables, anonymous ",NA,NA
"Variables, binding ",NA,NA
"Variables, global ",NA,NA
"Variables, global, eliminating ",NA,NA
"Variables, in goals ",NA,NA
"Variables, scope",NA,NA
 Managing Data,NA,NA
 Recursion: How Recursion Works ,NA,NA
"Variables, syntax of ",NA,NA
"Variables, unbound",NA,NA
W,NA,NA
where_food/2,NA,NA
 Rules,NA,NA
 Rules: How Rules Work,NA,NA
write/1,http://www.amzi.com/AdventureInProlog/advidx.htm (9 of 9)11/3/2006 7:06:23 PM,NA
