Larger Text,Smaller Text,Symbol
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos ,NA,NA
and ,NA,NA
Kristina Striegnitz,"Learning Prolog Now!
  
  
  
  
 G
 Table of Contents 
  
 G
 1 Facts, Rules, and Queries 
  
 G
 2 Matching and Proof Search 
  
 G
 3 Recursion 
  
 G
 4 Lists 
  
 G
 5 Arithmetic 
  
 G
 6 More Lists 
  
 G
 7 Definite Clause Grammars 
  
 G
 8 More Definite Clause Grammars 
  
 G
 9 A Closer Look at Terms 
  
 G
 10 Cuts and Negation 
  
 G
 11 Database Manipulation and Collecting Solutions 
 G
 12 Working With Files
  
  
 Â© 2006, Patrick Blackburn, Johan Bos, Kristina Striegnitz",NA
- Up -,NA,NA
Next >>,NA,NA
Table of Contents,G,NA
Table of Contents ,G,NA
"1 Facts, Rules, and Queries ",H,NA
1.1 Some simple examples ,I,NA
1.1.1 Knowledge Base 1 ,I,NA
1.1.2 Knowledge Base 2 ,I,NA
1.1.3 Knowledge Base 3 ,I,NA
1.1.4 Knowledge Base 4 ,I,NA
1.1.5 Knowledge Base 5 ,H,NA
1.2 Prolog Syntax ,I,NA
1.2.1 Atoms ,I,NA
1.2.2 Numbers ,I,NA
1.2.3 Variables ,I,NA
1.2.4 Complex terms ,H,NA
1.3 Exercises ,H,NA
1.4 Practical Session 1 ,G,NA
2 Matching and Proof Search ,H,NA
2.1 Matching ,I,NA
2.1.1 Examples ,I,NA
2.1.2 The occurs check ,I,NA
2.1.3 Programming with matching ,H,NA
2.2 Proof Search ,H,NA
2.3 Exercises ,H,NA
2.4 Practical Session 2 ,G,NA
3 Recursion ,H,NA
3.1 Recursive definitions ,I,NA
3.1.1 Example 1: Eating ,I,NA
3.1.2 Example 2: Descendant ,I,NA
3.1.3 Example 3: Successor ,I,NA
3.1.4 Example 3: Addition ,H,NA
"3.2 Clause ordering, goal ordering, and termination ",H,NA
3.3 Exercises,NA,NA
3.4 Practical Session 3 ,G,NA
4 Lists ,H,NA
4.1 Lists ,H,NA
4.2 Member ,H,NA
4.3 Recursing down lists ,H,NA
4.4 Exercises ,H,NA
4.5 Practical Session 4 ,G,NA
5 Arithmetic ,H,NA
5.1 Arithmetic in Prolog ,H,NA
5.2 A closer look ,H,NA
5.3 Arithmetic and lists ,H,NA
5.4 Comparing integers ,H,NA
5.5 Exercises ,H,NA
5.6 Practical Session 5 ,G,NA
6 More Lists ,H,NA
6.1 Append ,I,NA
6.1.1 Defining append ,I,NA
6.1.2 Using append ,H,NA
6.2 Reversing a list ,I,NA
6.2.1 Naive reverse using append ,I,NA
6.2.2 Reverse using an accumulator ,H,NA
6.3 Exercises ,H,NA
6.4 Practical Session 6 ,G,NA
7 Definite Clause Grammars ,H,NA
7.1 Context free grammars ,I,NA
7.1.1 CFG recognition using append ,I,NA
7.1.2 CFG recognition using difference lists ,H,NA
7.2 Definite clause grammars ,I,NA
7.2.1 A first example ,I,NA
7.2.2 Adding recursive rules ,I,NA
7.2.3 A DCG for a simple formal language ,H,NA
7.3 Exercises ,H,NA
7.4 Practical Session 7 ,G,NA
8 More Definite Clause Grammars ,H,NA
8.1 Extra arguments ,I,NA
8.1.1 Context free grammars with features ,I,NA
8.1.2 Building parse trees ,I,NA
8.1.3 Beyond context free languages,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/toc.html (2 of 4)11/3/2006 7:25:24 PM,NA
8.2 Extra goals ,I,NA
8.2.1 Separating rules and lexicon ,H,NA
8.3 ,NA,NA
Concluding remarks ,H,NA
8.4 Exercises ,H,NA
8.5 Practical Session 8 ,G,NA
9 A Closer Look at Terms ,H,NA
9.1 Comparing terms ,H,NA
9.2 Terms with a special notation ,I,NA
9.2.1 Arithmetic terms ,I,NA
9.2.2 Lists as terms ,H,NA
9.3 Examining Terms ,I,NA
9.3.1 Types of Terms ,I,NA
9.3.2 The Structure of Terms ,H,NA
9.4 Operators ,I,NA
9.4.1 Properties of operators ,I,NA
9.4.2 Defining operators ,H,NA
9.5 Exercises ,H,NA
9.6 Practical Session ,G,NA
10 Cuts and Negation ,H,NA
10.1 The cut ,H,NA
10.2 If-then-else ,H,NA
10.3 Negation as failure ,H,NA
10.4 Exercises ,H,NA
10.5 Practical Session 10 ,G,NA
11 Database Manipulation and Collecting Solutions ,H,NA
11.1 Database manipulation ,H,NA
11.2 Collecting solutions ,I,NA
11.2.1 ,NA,NA
findall/3 ,I,NA
11.2.2 ,NA,NA
bagof/3 ,I,NA
11.2.3 ,NA,NA
setof/3 ,H,NA
11.3 Exercises ,H,NA
11.4 Practical Session 11 ,G,NA
12 Working With Files ,H,NA
12.1 Splitting Programs Over Files ,I,NA
12.1.1 Reading in Programs ,I,NA
12.1.2 Modules ,I,NA
12.1.3 Libraries ,H,NA
12.2 Writing To and Reading From Files,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/toc.html (3 of 4)11/3/2006 7:25:24 PM,NA
12.3 Practical Session ,I,NA
12.3.1 Step 1 ,I,NA
12.3.2 Step 2 ,I,NA
12.3.3 Step 3 ,I,NA
12.3.4 Step 4 ,I,NA
12.3.5 Step 5 ,I,NA
12.3.6 Step 6,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
"1 Facts, Rules, and Queries",NA,NA
This introductory lecture has two main goals: ,NA,NA
1.  To give some simple examples of Prolog programs. This will introduce us to the three ,NA,NA
"basic constructs in Prolog: facts, rules, and queries. It will also introduce us to a number ",NA,NA
"of other themes, like the role of logic in Prolog, and the idea of performing matching ",NA,NA
with the aid of variables.,NA,NA
"2.  To begin the systematic study of Prolog by defining terms, atoms, variables and other ",NA,NA
syntactic concepts. ,G,NA
1.1 Some simple examples ,H,NA
1.1.1 Knowledge Base 1 ,H,NA
1.1.2 Knowledge Base 2 ,H,NA
1.1.3 Knowledge Base 3 ,H,NA
1.1.4 Knowledge Base 4 ,H,NA
1.1.5 Knowledge Base 5,G,NA
1.2 Prolog Syntax ,H,NA
1.2.1 Atoms ,H,NA
1.2.2 Numbers ,H,NA
1.2.3 Variables ,H,NA
1.2.4 Complex terms,G,NA
1.3 Exercises,G,NA
1.4 Practical Session 1,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.1 Some simple examples,NA,NA
"There are only three basic constructs in Prolog: facts, rules, and queries. A collection of facts ",NA,NA
and rules is called a knowledge base (or a database) and Prolog programming is all about ,NA,NA
"writing knowledge bases. That is, Prolog programs simply are knowledge bases, collections of ",NA,NA
facts and rules which describe some collection of relationships that we find interesting. So how ,NA,NA
"do we use a Prolog program? By posing queries. That is, by asking questions about the ",NA,NA
information stored in the knowledge base. Now this probably sounds rather strange. It's ,NA,NA
"certainly not obvious that it has much to do with programming at all -- after all, isn't ",NA,NA
"programming all about telling the computer what to do? But as we shall see, the Prolog way of ",NA,NA
"programming makes a lot of sense, at least for certain kinds of applications (computational ",NA,NA
linguistics being one of the most important examples). But instead of saying more about Prolog ,NA,NA
"in general terms, let's jump right in and start writing some simple knowledge bases; this is not ",NA,NA
"just the best way of learning Prolog, it's the only way ... ",G,NA
1.1.1 Knowledge Base 1,G,NA
1.1.2 Knowledge Base 2,G,NA
1.1.3 Knowledge Base 3,G,NA
1.1.4 Knowledge Base 4,G,NA
1.1.5 Knowledge Base 5,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.1.1 Knowledge Base 1,NA,NA
Knowledge Base 1 (KB1) is simply a collection of facts. Facts are used to state things that are ,NA,NA
"unconditionally true of the domain of interest. For example, we can state that Mia, Jody, and ",NA,NA
"Yolanda are women, and that Jody plays air guitar, using the following four facts:",NA,NA
woman(mia). ,NA,NA
woman(jody). ,NA,NA
woman(yolanda). ,NA,NA
playsAirGuitar(jody).,NA,NA
This collection of facts is KB1. It is our first example of a Prolog program. Note that the names ,NA,NA
mia,NA,NA
", ",NA,NA
jody,NA,NA
", and ",NA,NA
yolanda,NA,NA
", and the properties ",NA,NA
woman,NA,NA
 and ,NA,NA
playsAirGuitar,NA,NA
", have been written so ",NA,NA
that the first letter is in lower-case. This is important; we will see why a little later.,NA,NA
"How can we use KB1? By posing queries. That is, by asking questions about the information ",NA,NA
KB1 contains. Here are some examples. We can ask Prolog whether Mia is a woman by posing ,NA,NA
the query:,NA,NA
?- woman(mia).,NA,NA
Prolog will answer,NA,NA
yes,NA,NA
"for the obvious reason that this is one of the facts explicitly recorded in KB1. Incidentally, we ",NA,NA
don't type in the ,NA,NA
?-,NA,NA
". This symbol (or something like it, depending on the implementation of ",NA,NA
Prolog you are using) is the prompt symbol that the Prolog interpreter displays when it is ,NA,NA
waiting to evaluate a query. We just type in the actual query (for example ,NA,NA
woman(mia),NA,NA
) ,NA,NA
followed by ,NA,NA
.,NA,NA
 (a full stop).,NA,NA
"Similarly, we can ask whether Jody plays air guitar by posing the following query:",NA,NA
?- playsAirGuitar(jody).,NA,NA
"Prolog will again answer ``yes'', because this is one of the facts in KB1. However, suppose we ",NA,NA
ask whether Mia plays air guitar:,NA,NA
?- playsAirGuitar(mia).,NA,NA
We will get the answer ,NA,NA
no,NA,NA
"Why? Well, first of all, this is not a fact in KB1. Moreover, KB1 is extremely simple, and ",NA,NA
contains no other information (such as the rules we will learn about shortly) which might help ,NA,NA
"Prolog try to infer (that is, deduce whether Mia plays air guitar. So Prolog correctly concludes ",NA,NA
that ,NA,NA
playsAirGuitar(mia),NA,NA
 does not follow from KB1.,NA,NA
Here are two important examples. Suppose we pose the query:,NA,NA
?- playsAirGuitar(vincent).,NA,NA
"Again Prolog answers ``no''. Why? Well, this query is about a person (Vincent) that it has no ",NA,NA
"information about, so it concludes that ",NA,NA
playsAirGuitar(vincent),NA,NA
 cannot be deduced from the ,NA,NA
information in KB1.,NA,NA
"Similarly, suppose we pose the query:",NA,NA
?- tatooed(jody).,NA,NA
"Again Prolog will answer ``no''. Why? Well, this query is about a property (being tatooed) that ",NA,NA
"it has no information about, so once again it concludes that the query cannot be deduced from ",NA,NA
the information in KB1.,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.1.2 Knowledge Base 2,NA,NA
"Here is KB2, our second knowledge base:",NA,NA
listensToMusic(mia). ,NA,NA
happy(yolanda). ,NA,NA
playsAirGuitar(mia)  :- listensToMusic(mia). ,NA,NA
playsAirGuitar(yolanda) :- listensToMusic(yolanda). ,NA,NA
listensToMusic(yolanda):- happy(yolanda).,NA,NA
"KB2 contains two facts, ",NA,NA
listensToMusic(mia),NA,NA
 and ,NA,NA
happy(yolanda),NA,NA
. The last three items are ,NA,NA
rules.,NA,NA
"Rules state information that is conditionally true of the domain of interest. For example, the ",NA,NA
"first rule says that Mia plays air guitar if she listens to music, and the last rule says that ",NA,NA
"Yolanda listens to music if she if happy. More generally, the ",NA,NA
:-,NA,NA
" should be read as ``if'', or ``is ",NA,NA
implied by''. The part on the left hand side of the ,NA,NA
:-,NA,NA
" is called the head of the rule, the part on ",NA,NA
"the right hand side is called the body. So in general rules say: if the body of the rule is true, ",NA,NA
then the head of the rule is true too. And now for the key point: if a knowledge base contains ,NA,NA
a rule ,NA,NA
"head :- body,",NA,NA
 and Prolog knows that ,NA,NA
body,NA,NA
 follows from the information in the knowledge ,NA,NA
"base, then Prolog can infer ",NA,NA
head.,NA,NA
This fundamental deduction step is what logicians call modus ponens.,NA,NA
Let's consider an example. We will ask Prolog whether Mia plays air guitar:,NA,NA
?- playsAirGuitar(mia).,NA,NA
"Prolog will respond ``yes''. Why? Well, although ",NA,NA
playsAirGuitar(mia),NA,NA
 is not a fact ,NA,NA
"explicitly recorded in KB2, KB2 does contain the rule",NA,NA
playsAirGuitar(mia) :- listensToMusic(mia).,NA,NA
"Moreover, KB2 also contains the fact ",NA,NA
listensToMusic(mia),NA,NA
. Hence Prolog can use modus ,NA,NA
ponens to deduce that ,NA,NA
playsAirGuitar(mia),NA,NA
.,NA,NA
Our next example shows that Prolog can chain together uses of modus ponens. Suppose we ,NA,NA
ask:,NA,NA
?- playsAirGuitar(yolanda).,NA,NA
"Prolog would respond ``yes''. Why? Well, using the fact ",NA,NA
happy(yolanda),NA,NA
 and the rule,NA,NA
"listensToMusic(yolanda):- happy(yolanda), ",NA,NA
Prolog can deduce the new fact ,NA,NA
listensToMusic(yolanda),NA,NA
. This new fact is not explicitly ,NA,NA
recorded in the knowledge base --- it is only implicitly present (it is inferred knowledge). ,NA,NA
"Nonetheless, Prolog can then use it just like an explicitly recorded fact. Thus, together with ",NA,NA
the rule,NA,NA
playsAirGuitar(yolanda) :- listensToMusic(yolanda) ,NA,NA
it can deduce that ,NA,NA
playsAirGuitar(yolanda),NA,NA
", which is what we asked it. Summing up: any fact ",NA,NA
produced by an application of modus ponens can be used as input to further rules. By chaining ,NA,NA
"together applications of modus ponens in this way, Prolog is able to retrieve ",NA,NA
information that logically follows from the rules and facts recorded in the knowledge base.,NA,NA
The facts and rules contained in a knowledge base are called clauses. Thus KB2 contains five ,NA,NA
"clauses, namely three rules and two facts. Another way of looking at KB2 is to say that it ",NA,NA
consists of three predicates (or procedures). The three predicates are:,NA,NA
listensToMusic ,NA,NA
happy ,NA,NA
playsAirGuitar,NA,NA
The ,NA,NA
happy,NA,NA
 predicate is defined using a single clause (a fact). The ,NA,NA
listensToMusic,NA,NA
 and ,NA,NA
playsAirGuitar,NA,NA
" predicates are each defined using two clauses (in both cases, two rules). It is a ",NA,NA
"good idea to think about Prolog programs in terms of the predicates they contain. In essence, ",NA,NA
"the predicates are the concepts we find important, and the various clauses we write down ",NA,NA
concerning them are our attempts to pin down what they mean and how they are inter-related.,NA,NA
"One final remark. We can view a fact as a rule with an empty body. That is, we can think of ",NA,NA
"facts as ``conditionals that do not have any antecedent conditions'', or ``degenerate rules''.",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node4.html (2 of 3)11/3/2006 7:25:55 PM,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node4.html (3 of 3)11/3/2006 7:25:55 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.1.3 Knowledge Base 3,NA,NA
"KB3, our third knowledge base, consists of five clauses:",NA,NA
happy(vincent). ,NA,NA
listensToMusic(butch). ,NA,NA
playsAirGuitar(vincent):- ,NA,NA
" listensToMusic(vincent),   ",NA,NA
 happy(vincent). ,NA,NA
playsAirGuitar(butch):- ,NA,NA
 happy(butch). ,NA,NA
playsAirGuitar(butch):- ,NA,NA
 listensToMusic(butch).,NA,NA
"There are two facts, namely ",NA,NA
happy(vincent),NA,NA
 and ,NA,NA
listensToMusic(butch),NA,NA
", and three rules. ",NA,NA
KB3 defines the same three predicates as KB2 (namely ,NA,NA
happy,NA,NA
", ",NA,NA
listensToMusic,NA,NA
", and ",NA,NA
playsAirGuitar,NA,NA
") but it defines them differently. In particular, the three rules that define the ",NA,NA
playsAirGuitar,NA,NA
" predicate introduce some new ideas. First, note that the rule",NA,NA
playsAirGuitar(vincent):- ,NA,NA
" listensToMusic(vincent),   ",NA,NA
 happy(vincent).,NA,NA
"has two items in its body, or (to use the standard terminology) two goals. What does this rule ",NA,NA
mean? The important thing to note is the comma ,NA,NA
",",NA,NA
 that separates the goal ,NA,NA
listensToMusic ,NA,NA
(vincent),NA,NA
 and the goal ,NA,NA
happy(vincent),NA,NA
 in the rule's body. This is the way logical conjunction is ,NA,NA
"expressed in Prolog (that is, the comma means and). So this rule says: ``Vincent plays air ",NA,NA
guitar if he listens to music and he is happy''.,NA,NA
"Thus, if we posed the query",NA,NA
?- playsAirGuitar(vincent).,NA,NA
Prolog would answer ``no''. This is because while KB3 contains ,NA,NA
happy(vincent),NA,NA
", it does not ",NA,NA
explicitly contain the information ,NA,NA
listensToMusic(vincent),NA,NA
", and this fact cannot be deduced ",NA,NA
either. So KB3 only fulfils one of the two preconditions needed to establish ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node5.html (1 of 3)11/3/2006 7:26:01 PM,NA
playsAirGuitar(vincent),NA,NA
", and our query fails.",NA,NA
"Incidentally, the spacing used in this rule is irrelevant. For example, we could have written it as",NA,NA
"playsAirGuitar(vincent):- happy(vincent),listensToMusic (vincent). ",NA,NA
and it would have meant exactly the same thing. Prolog offers us a lot of freedom in the way ,NA,NA
"we set out knowledge bases, and we can take advantage of this to keep our code readable.",NA,NA
"Next, note that KB3 contains two rules with exactly the same head, namely:",NA,NA
playsAirGuitar(butch):- ,NA,NA
 happy(butch). ,NA,NA
playsAirGuitar(butch):- ,NA,NA
 listensToMusic(butch).,NA,NA
"This is a way of stating that Butch plays air guitar if either he listens to music, or if he is ",NA,NA
"happy. That is, listing multiple rules with the same head is a way of expressing logical ",NA,NA
"disjunction (that is, it is a way of saying or). So if we posed the query",NA,NA
?- playsAirGuitar(butch).,NA,NA
Prolog would answer ``yes''. For although the first of these rules will not help (KB3 does not ,NA,NA
allow Prolog to conclude that ,NA,NA
happy(butch),NA,NA
"), KB3 does contain ",NA,NA
listensToMusic(butch) ,NA,NA
and this ,NA,NA
means Prolog can apply modus ponens using the rule,NA,NA
playsAirGuitar(butch):- ,NA,NA
 listensToMusic(butch).,NA,NA
to conclude that ,NA,NA
playsAirGuitar(butch),NA,NA
.,NA,NA
There is another way of expressing disjunction in Prolog. We could replace the pair of rules ,NA,NA
given above by the single rule,NA,NA
playsAirGuitar(butch):- ,NA,NA
 happy(butch); ,NA,NA
 listensToMusic(butch). ,NA,NA
"That is, the semicolon ",NA,NA
;,NA,NA
" is the Prolog symbol for or, so this single rule means exactly the same ",NA,NA
"thing as the previous pair of rules. But Prolog programmers usually write multiple rules, as ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node5.html (2 of 3)11/3/2006 7:26:01 PM,NA
extensive use of semicolon can make Prolog code hard to read.,NA,NA
"It should now be clear that Prolog has something do with logic: after all, the ",NA,NA
:-,NA,NA
 means ,NA,NA
"implication, the ",NA,NA
",",NA,NA
" means conjunction, and the ",NA,NA
;,NA,NA
 means disjunction. (What about negation? That ,NA,NA
"is a whole other story. We'll be discussing it later in the course.) Moreover, we have seen that a ",NA,NA
standard logical proof rule (modus ponens) plays an important role in Prolog ,NA,NA
programming. And in fact ``Prolog'' is short for ``Programming in logic''.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.1.4 Knowledge Base 4,NA,NA
"Here is KB4, our fourth knowledge base:",NA,NA
woman(mia). ,NA,NA
woman(jody). ,NA,NA
woman(yolanda). ,NA,NA
"loves(vincent,mia). ",NA,NA
"loves(marcellus,mia). ",NA,NA
"loves(pumpkin,honey_bunny). ",NA,NA
"loves(honey_bunny,pumpkin).",NA,NA
"Now, this is a pretty boring knowledge base. There are no rules, only a collection of facts. Ok, ",NA,NA
we are seeing a relation that has two names as arguments for the first time (namely the ,NA,NA
loves,NA,NA
 ,NA,NA
"relation), but, let's face it, that's a rather predictable idea.",NA,NA
"No, the novelty this time lies not in the knowledge base, it lies in the queries we are going to ",NA,NA
"pose. In particular, for the first time we're going to make use of variables. Here's an example:",NA,NA
?- woman(X).,NA,NA
The ,NA,NA
X,NA,NA
" is a variable (in fact, any word beginning with an upper-case letter is a Prolog variable, ",NA,NA
which is why we had to be careful to use lower-case initial letters in our earlier examples). ,NA,NA
"Now a variable isn't a name, rather it's a ``placeholder'' for information. That is, this query ",NA,NA
essentially asks Prolog: tell me which of the individuals you know about is a woman.,NA,NA
"Prolog answers this query by working its way through KB4, from top to bottom, trying to match ",NA,NA
(or unify) the expression ,NA,NA
woman(X),NA,NA
 with the information KB4 contains. Now the first item in the ,NA,NA
knowledge base is ,NA,NA
woman(mia),NA,NA
". So, Prolog matches ",NA,NA
X,NA,NA
 to ,NA,NA
mia,NA,NA
", thus making the query agree ",NA,NA
"perfectly with this first item. (Incidentally, there's a lot of different terminology for this process: ",NA,NA
we can also say that Prolog instantiates ,NA,NA
X,NA,NA
 to ,NA,NA
mia,NA,NA
", or that it binds ",NA,NA
X,NA,NA
 to ,NA,NA
mia,NA,NA
.) Prolog then reports ,NA,NA
back to us as follows:,NA,NA
X = mia,NA,NA
"That is, it not only says that there is information about at least one woman in KB4, it actually ",NA,NA
"tells us who she is. It didn't just say ``yes'', it actually gave us the variable binding, or ",NA,NA
instantiation that led to success.,NA,NA
But that's not the end of the story. The whole point of variables --- and not just in Prolog ,NA,NA
either --- is that they can ``stand for'' or ``match with'' different things. And there is ,NA,NA
information about other women in the knowledge base. We can access this information by ,NA,NA
typing the following simple query,NA,NA
?-  ;,NA,NA
Remember that ,NA,NA
;,NA,NA
" means or, so this query means: are there any more women? So Prolog ",NA,NA
begins working through the knowledge base again (it remembers where it got up to last time ,NA,NA
and starts from there) and sees that if it matches ,NA,NA
X,NA,NA
 with ,NA,NA
jody,NA,NA
", then the query agrees perfectly ",NA,NA
with the second entry in the knowledge base. So it responds:,NA,NA
X = jody,NA,NA
"It's telling us that there is information about a second woman in KB4, and (once again) it ",NA,NA
"actually gives us the value that led to success. And of course, if we press ",NA,NA
;,NA,NA
" a second time, ",NA,NA
Prolog returns the answer,NA,NA
X = yolanda,NA,NA
But what happens if we press ,NA,NA
;,NA,NA
 a third time? Prolog responds ``no''. No other matches are ,NA,NA
possible. There are no other facts starting with the symbol ,NA,NA
woman,NA,NA
. The last four entries in the ,NA,NA
knowledge base concern the ,NA,NA
love,NA,NA
" relation, and there is no way that such entries can match a ",NA,NA
query of the form of the form ,NA,NA
woman(x),NA,NA
.,NA,NA
"Let's try a more complicated query, namely",NA,NA
" loves(marcellus,X),woman(X).",NA,NA
"Now, remember that ",NA,NA
",",NA,NA
" means and, so this query says: is there any individual ",NA,NA
X,NA,NA
 such that ,NA,NA
Marcellus loves ,NA,NA
X,NA,NA
 and ,NA,NA
X,NA,NA
 is a woman? If you look at the knowledge base you'll see that there is: ,NA,NA
"Mia is a woman (fact 1) and Marcellus loves Mia (fact 5). And in fact, Prolog is capable of ",NA,NA
"working this out. That is, it can search through the knowledge base and work out that if it ",NA,NA
matches ,NA,NA
X,NA,NA
" with Mia, then both conjuncts of the query are satisfied (we'll learn in later lectures ",NA,NA
exactly how Prolog does this). So Prolog returns the answer,NA,NA
X = mia,NA,NA
This business of matching variables to information in the knowledge base is the heart of ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node6.html (2 of 3)11/3/2006 7:26:10 PM,NA
"Prolog. For sure, Prolog has many other interesting aspects --- but when you get right down to ",NA,NA
"it, it's Prolog's ability to perform matching and return the values of the variable binding to us ",NA,NA
that is crucial.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
1.1.5 Knowledge Base 5,NA,NA
"Well, we've introduced variables, but so far we've only used them in queries. In fact, variables ",NA,NA
"not only can be used in knowledge bases, it's only when we start to do so that we can write ",NA,NA
"truly interesting programs. Here's a simple example, the knowledge base KB5:",NA,NA
"loves(vincent,mia). ",NA,NA
"loves(marcellus,mia). ",NA,NA
"loves(pumpkin,honey_bunny). ",NA,NA
"loves(honey_bunny,pumpkin). ",NA,NA
"jealous(X,Y) :- loves(X,Z),loves(Y,Z).",NA,NA
KB5 contains four facts about the ,NA,NA
loves,NA,NA
" relation and one rule. (Incidentally, the blank line ",NA,NA
between the facts and the rule has no meaning: it's simply there to increase the readability. As ,NA,NA
"we said earlier, Prolog gives us a great deal of freedom in the way we format knowledge ",NA,NA
bases.) But this rule is by far the most interesting one we have seen so far: it contains three ,NA,NA
variables (note that ,NA,NA
X,NA,NA
", ",NA,NA
Y,NA,NA
", and ",NA,NA
Z,NA,NA
 are all upper-case letters). What does it say?,NA,NA
"In effect, it is defining a concept of jealousy. It says that an individual ",NA,NA
X,NA,NA
 will be jealous of an ,NA,NA
individual ,NA,NA
Y,NA,NA
 if there is some individual ,NA,NA
Z,NA,NA
 that ,NA,NA
X,NA,NA
" loves, and ",NA,NA
Y,NA,NA
 loves that same individual ,NA,NA
Z,NA,NA
 too. ,NA,NA
"(Ok, so jealously isn't as straightforward as this in the real world ...) The key thing to note is ",NA,NA
that this is a general statement: it is not stated in terms of ,NA,NA
mia,NA,NA
", or ",NA,NA
pumpkin,NA,NA
", or anyone in ",NA,NA
particular --- it's a conditional statement about everybody in our little world.,NA,NA
Suppose we pose the query:,NA,NA
"?- jealous(marcellus,W).",NA,NA
This query asks: can you find an individual ,NA,NA
W,NA,NA
 such that Marcellus is jealous of ,NA,NA
W,NA,NA
? Vincent is ,NA,NA
"such an individual. If you check the definition of jealousy, you'll see that Marcellus must be ",NA,NA
"jealous of Vincent, because they both love the same woman, namely Mia. So Prolog will return ",NA,NA
the value,NA,NA
W = vincent,NA,NA
"Now some questions for you, First, are there any other jealous people in KB5? Furthermore, ",NA,NA
suppose we wanted Prolog to tell us about all the jealous people: what query would we pose? ,NA,NA
Do any of the answers surprise you? Do any seem silly?,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.2 Prolog Syntax,NA,NA
"Now that we've got some idea of what Prolog does, it's time to go back to the beginning and ",NA,NA
work through the details more carefully. Let's start by asking a very basic question: we've ,NA,NA
seen all kinds of expressions (for example ,NA,NA
jody,NA,NA
", ",NA,NA
playsAirGuitar(mia),NA,NA
", and ",NA,NA
X,NA,NA
) in our Prolog ,NA,NA
"programs, but these have just been examples. Exactly what are facts, rules, and queries built ",NA,NA
out of?,NA,NA
"The answer is terms, and there are four kinds of terms in Prolog: atoms, numbers, variables, ",NA,NA
and complex terms (or structures). Atoms and numbers are lumped together under the ,NA,NA
"heading constants, and constants and variables together make up the simple terms of Prolog.",NA,NA
"Let's take a closer look. To make things crystal clear, let's first get clear about the basic ",NA,NA
characters (or symbols) at our disposal. The upper-case letters are ,NA,NA
A,NA,NA
", ",NA,NA
B,NA,NA
", ..., ",NA,NA
Z,NA,NA
; the lower-case ,NA,NA
letters are ,NA,NA
a,NA,NA
", ",NA,NA
b,NA,NA
", ..., ",NA,NA
z,NA,NA
; the digits are ,NA,NA
1,NA,NA
", ",NA,NA
2,NA,NA
", ..., ",NA,NA
9,NA,NA
; and the special characters are ,NA,NA
+,NA,NA
", ",NA,NA
-,NA,NA
", ",NA,NA
*,NA,NA
", ",NA,NA
/,NA,NA
", ",NA,NA
<,NA,NA
", ",NA,NA
>,NA,NA
", ",NA,NA
=,NA,NA
", ",NA,NA
:,NA,NA
", ",NA,NA
.,NA,NA
", ",NA,NA
&,NA,NA
", ",NA,NA
~,NA,NA
", and ",NA,NA
_,NA,NA
. The ,NA,NA
_,NA,NA
" character is called underscore. The blank space is also a character, but a ",NA,NA
"rather unusual one, being invisible. A string is an unbroken sequence of characters.",G,NA
1.2.1 Atoms,G,NA
1.2.2 Numbers,G,NA
1.2.3 Variables,G,NA
1.2.4 Complex terms,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.2.1 Atoms,NA,NA
An atom is either:,NA,NA
"1.  A string of characters made up of upper-case letters, lower-case letters, digits, and the ",NA,NA
"underscore character, that begins with a lower-case letter. For example: ",NA,NA
butch,NA,NA
", ",NA,NA
big_kahuna_burger,NA,NA
", and ",NA,NA
m_monroe2.,NA,NA
2.  An arbitrary sequence of character enclosed in single quotes. For example ',NA,NA
Vincent,NA,NA
"', ",NA,NA
',NA,NA
The Gimp,NA,NA
"', '",NA,NA
Five_Dollar_Shake,NA,NA
"', '",NA,NA
&^%&#@$ &*,NA,NA
"', and ''. The character between the ",NA,NA
single quotes is called the atom name. Note that we are allowed to use spaces in such ,NA,NA
"atoms --- in fact, a common reason for using single quotes is so we can do precisely ",NA,NA
that.,NA,NA
3.  A string of special characters. For example: ,NA,NA
@=,NA,NA
 and ,NA,NA
====>,NA,NA
 and ,NA,NA
;,NA,NA
 and ,NA,NA
:-,NA,NA
 are all atoms. ,NA,NA
"As we have seen, some of these atoms, such as ",NA,NA
;,NA,NA
 and ,NA,NA
:-,NA,NA
 have a pre-defined meaning.,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.2.2 Numbers,NA,NA
Real numbers aren't particularly important in typical Prolog applications. So although most ,NA,NA
"Prolog implementations do support floating point numbers or floats (that is, representations of ",NA,NA
real numbers such as 1657.3087 or ) we are not going to discuss them in this course.,NA,NA
"But integers (that is: ... -2, -1, 0, 1, 2, 3, ...) are useful for such tasks as counting the ",NA,NA
"elements of a list, and we'll discuss how to manipulate them in a later lecture. Their Prolog ",NA,NA
syntax is the obvious one: ,NA,NA
23,NA,NA
", ",NA,NA
1001,NA,NA
", ",NA,NA
0,NA,NA
", ",NA,NA
-365,NA,NA
", and so on.",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.2.3 Variables,NA,NA
"A variable is a string of upper-case letters, lower-case letters, digits and underscore characters ",NA,NA
"that starts either with an upper-case letter or with underscore. For example, ",NA,NA
X,NA,NA
", ",NA,NA
Y,NA,NA
", ",NA,NA
Variable,NA,NA
", ",NA,NA
_tag,NA,NA
", ",NA,NA
X_526,NA,NA
", and ",NA,NA
List,NA,NA
", ",NA,NA
List24,NA,NA
", ",NA,NA
_head,NA,NA
", ",NA,NA
Tail,NA,NA
", ",NA,NA
_input,NA,NA
 and ,NA,NA
Output,NA,NA
 are all Prolog variables.,NA,NA
The variable ,NA,NA
_,NA,NA
" (that is, a single underscore character) is rather special. It's called the ",NA,NA
"anonymous variable, and we discuss it in a later lecture.",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node11.html11/3/2006 7:26:34 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
1.2.4 Complex terms,NA,NA
"Constants, numbers, and variables are the building blocks: now we need to know how to fit ",NA,NA
them together to make complex terms. Recall that complex terms are often called structures.,NA,NA
Complex terms are build out of a functor followed by a sequence of arguments. The ,NA,NA
"arguments are put in ordinary brackets, separated by commas, and placed after the functor. ",NA,NA
"The functor must be an atom. That is, variables cannot be used as functors. On the other ",NA,NA
"hand, arguments can be any kind of term.",NA,NA
"Now, we've already seen lots of examples of complex terms when we looked at KB1 -- KB5. ",NA,NA
"For example, ",NA,NA
playsAirGuitar(jody),NA,NA
 is a complex term: its functor is ,NA,NA
playsAirGuitar ,NA,NA
and its ,NA,NA
argument is ,NA,NA
jody,NA,NA
. Other examples are ,NA,NA
"loves(vincent,mia)",NA,NA
" and, to give an example containing ",NA,NA
"a variable, ",NA,NA
"jealous(marcellus,W)",NA,NA
.,NA,NA
"But note that the definition allows far more complex terms than this. In fact, it allows us to to ",NA,NA
"keep nesting complex terms inside complex terms indefinitely (that is, it is a recursive ",NA,NA
definition). For example,NA,NA
"hide(X,father(father(father(butch))))",NA,NA
is a perfectly ok complex term. Its functor is ,NA,NA
hide,NA,NA
", and it has two arguments: the variable ",NA,NA
X,NA,NA
", ",NA,NA
and the complex term ,NA,NA
father(father(father(butch))),NA,NA
. This complex term has ,NA,NA
father,NA,NA
 as its ,NA,NA
"functor, and another complex term, namely ",NA,NA
father(father(butch)),NA,NA
", as its sole argument. And ",NA,NA
"the argument of this complex term, namely ",NA,NA
father(butch),NA,NA
", is also complex. But then the ",NA,NA
"nesting ``bottoms out'', for the argument here is the constant ",NA,NA
butch,NA,NA
.,NA,NA
"As we shall see, such nested (or recursively structured) terms enable us to represent many ",NA,NA
problems naturally. In fact the interplay between recursive term structure and variable ,NA,NA
matching is the source of much of Prolog's power.,NA,NA
"The number of arguments that a complex term has is called its arity. For instance, ",NA,NA
woman ,NA,NA
(mia),NA,NA
" is a complex term with arity 1, while ",NA,NA
"loves(vincent,mia)",NA,NA
 is a complex term with arity 2.,NA,NA
Arity is important to Prolog. Prolog would be quite happy for us to define two predicates with ,NA,NA
"the same functor but with a different number of arguments. For example, we are free to ",NA,NA
define a knowledge base that defines a two place predicate ,NA,NA
love,NA,NA
 (this might contain such ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node12.html (1 of 2)11/3/2006 7:26:43 PM,NA
facts as ,NA,NA
"love(vincent,mia)",NA,NA
"), and also a three place ",NA,NA
love,NA,NA
 predicate (which might contain such ,NA,NA
facts as ,NA,NA
"love(vincent,marcellus,mia)",NA,NA
"). However, if we did this, Prolog would treat the two place ",NA,NA
love,NA,NA
 and the three place ,NA,NA
love,NA,NA
 as completely different predicates.,NA,NA
"When we need to talk about predicates and how we intend to use them (for example, in ",NA,NA
documentation) it is usual to use a suffix ,NA,NA
/,NA,NA
 followed by a number to indicate the predicate's ,NA,NA
"arity. To return to KB2, instead of saying that it defines predicates",NA,NA
listensToMusic ,NA,NA
happy ,NA,NA
playsAirGuitar,NA,NA
we should really say that it defines predicates,NA,NA
listensToMusic/1 ,NA,NA
happy/1 ,NA,NA
playsAirGuitar/1,NA,NA
And Prolog can't get confused about a knowledge base containing the two different love ,NA,NA
"predicates, for it regards the ",NA,NA
love/2,NA,NA
 predicate and the ,NA,NA
love/3,NA,NA
 predicate as completely ,NA,NA
distinct.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
1.3 Exercises,NA,NA
Exercise 1.1,NA,NA
"Which of the following sequences of characters are atoms, which are variables, ",NA,NA
and which are neither? ,NA,NA
1.  ,NA,NA
vINCENT ,NA,NA
2.  ,NA,NA
Footmassage ,NA,NA
3.  ,NA,NA
variable23 ,NA,NA
4.  ,NA,NA
Variable2000 ,NA,NA
5.  ,NA,NA
big_kahuna_burger ,NA,NA
6.  ,NA,NA
'big kahuna burger' ,NA,NA
7.  ,NA,NA
big kahuna burger ,NA,NA
8.  ,NA,NA
'Jules' ,NA,NA
9.  ,NA,NA
_Jules ,NA,NA
10.  ,NA,NA
'_Jules',NA,NA
Exercise 1.2,NA,NA
"Which of the following sequences of characters are atoms, which are variables, ",NA,NA
"which are complex terms, and which are not terms at all? Give the functor and ",NA,NA
arity of each complex term. ,NA,NA
1.  ,NA,NA
"loves(Vincent,mia) ",NA,NA
2.  ,NA,NA
"'loves(Vincent,mia)' ",NA,NA
3.  ,NA,NA
Butch(boxer) ,NA,NA
4.  ,NA,NA
boxer(Butch) ,NA,NA
5.  ,NA,NA
"and(big(burger),kahuna(burger)) ",NA,NA
6.  ,NA,NA
"and(big(X),kahuna(X)) ",NA,NA
7.  ,NA,NA
"_and(big(X),kahuna(X)) ",NA,NA
8.  ,NA,NA
(Butch kills Vincent) ,NA,NA
9.  ,NA,NA
kills(Butch Vincent) ,NA,NA
10.  ,NA,NA
"kills(Butch,Vincent",NA,NA
Exercise 1.3,NA,NA
"How many facts, rules, clauses, and predicates are there in the following ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node13.html (1 of 3)11/3/2006 7:26:53 PM,NA
"knowledge base? What are the heads of the rules, and what are the goals they ",NA,NA
contain? ,NA,NA
woman(vincent). ,NA,NA
woman(mia). ,NA,NA
man(jules). ,NA,NA
person(X) :- man(X); woman(X). ,NA,NA
"loves(X,Y) :- knows(Y,X). ",NA,NA
"father(Y,Z) :- man(Y), son(Z,Y). ",NA,NA
"father(Y,Z) :- man(Y), daughter(Z,Y).",NA,NA
Exercise 1.4,NA,NA
Represent the following in Prolog: ,NA,NA
1.  Butch is a killer.,NA,NA
2.  Mia and Marcellus are married.,NA,NA
3.  Zed is dead.,NA,NA
4.  Marcellus kills everyone who gives Mia a footmassage. ,NA,NA
5.  Mia loves everyone who is a good dancer.,NA,NA
6.  Jules eats anything that is nutritious or tasty.,NA,NA
Exercise 1.5,NA,NA
Suppose we are working with the following knowledge base: ,NA,NA
wizard(ron). ,NA,NA
hasWand(harry). ,NA,NA
quidditchPlayer(harry). ,NA,NA
"wizard(X) :- hasBroom(X),hasWand(X). ",NA,NA
hasBroom(X) :- quidditchPlayer(X).,NA,NA
How does Prolog respond to the following queries? ,NA,NA
1.  ,NA,NA
wizard(ron).,NA,NA
2.  ,NA,NA
witch(ron).,NA,NA
3.  ,NA,NA
wizard(hermione). ,NA,NA
4.  ,NA,NA
witch(hermione). ,NA,NA
5.  ,NA,NA
wizard(harry).,NA,NA
6.  ,NA,NA
wizard(Y).,NA,NA
7.  ,NA,NA
witch(Y).,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
1.4 Practical Session 1,NA,NA
Don't be fooled by the fact that the descriptions of the practical sessions are much shorter ,NA,NA
than the text you have just read --- the practical part of the course is definitely the most ,NA,NA
"important. Yes, you need to read the text and do the exercises, but that's not enough to ",NA,NA
become a Prolog programmer. To really master the language you need to sit down in front of ,NA,NA
a computer and play with Prolog --- a lot!,NA,NA
The goal of the first practical session is for you to become familiar with the basics of how to ,NA,NA
"create and run simple Prolog programs. Now, because there are many different ",NA,NA
"implementations of Prolog, and many different operating systems you can run them under, we ",NA,NA
"can't be too specific here. Rather, what we'll do is describe in very general terms what is ",NA,NA
"involved in running Prolog, list the practical skills you will need to master, and make some ",NA,NA
suggestions for things to do.,NA,NA
The simplest way to run a Prolog program is as follows. You have a file with your Prolog ,NA,NA
"program in it (for example, you may have a file ",NA,NA
kb2.pl,NA,NA
 which contains the knowledge base ,NA,NA
"KB2). You then start Prolog running. Prolog will display its prompt, something like",NA,NA
?-,NA,NA
which indicates that it is ready to accept a query.,NA,NA
"Now, at this stage, Prolog knows absolutely nothing about KB2 (or indeed anything else). To ",NA,NA
"see this, type in the command ",NA,NA
listing,NA,NA
", followed by a full stop, and hit return. That is, type",NA,NA
?- listing.,NA,NA
and press the return key.,NA,NA
"Now, the ",NA,NA
listing,NA,NA
 command is a special in-built Prolog predicate that instructs Prolog to display ,NA,NA
the contents of the current knowledge base. But we haven't yet told Prolog about any ,NA,NA
"knowledge bases, so it will just say",NA,NA
yes,NA,NA
This is a correct answer: as yet Prolog knows nothing --- so it correctly displays all this nothing ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node14.html (1 of 4)11/3/2006 7:27:04 PM,NA
and says ,NA,NA
yes,NA,NA
". Actually, with more sophisticated Prolog implementations you may get a little ",NA,NA
"more (for example, the names of libraries that have been loaded) but, one way or another, ",NA,NA
you will receive what is essentially an ``I know nothing about any knowledge bases!'' answer.,NA,NA
So let's tell Prolog about KB2. Assuming you've stored KB2 in the file ,NA,NA
kb2.pl,NA,NA
", and that this file ",NA,NA
"is in the same directory where you're running Prolog, all you have to type is",NA,NA
?- [kb2].,NA,NA
This tells Prolog to consult the file ,NA,NA
kb2.pl,NA,NA
", and load the contents as its new knowledge base. ",NA,NA
Assuming that the ,NA,NA
kb2.pl,NA,NA
" contains no typos, Prolog will read it in, maybe print out a message ",NA,NA
saying that it is consulting the file ,NA,NA
kb2.pl,NA,NA
", and then answer:",NA,NA
yes,NA,NA
"Incidentally, it is quite common to store Prolog code in files with a ",NA,NA
.pl,NA,NA
 suffix. It's a useful ,NA,NA
indication of what the file contains (namely Prolog code) and with many Prolog ,NA,NA
implementations you don't actually have to type in the ,NA,NA
.pl,NA,NA
 suffix when you consult a file.,NA,NA
"Ok, so Prolog should now know about all the KB2 predicates. And we can check whether it ",NA,NA
does by using the ,NA,NA
listing,NA,NA
 command again:,NA,NA
?- listing.,NA,NA
"If you do this, Prolog will list (something like) the following on the screen:",NA,NA
listensToMusic(mia). ,NA,NA
happy(yolanda). ,NA,NA
playsAirGuitar(mia)  :- ,NA,NA
 listensToMusic(mia). ,NA,NA
playsAirGuitar(yolanda) :- ,NA,NA
 listensToMusic(yolanda). ,NA,NA
listensToMusic(yolanda):- ,NA,NA
 happy(yolanda). ,NA,NA
yes,NA,NA
"That is, it will list the facts and rules that make up KB2, and then say ",NA,NA
yes,NA,NA
". Once again, you ",NA,NA
"may get a little more than this, such as the locations of various libraries that have been loaded.",NA,NA
"Incidentally, ",NA,NA
listing,NA,NA
" can be used in other ways. For example, typing",NA,NA
?- listing(playsAirGuitar).,NA,NA
simply lists all the information in the knowledge base about the ,NA,NA
playsAirGuitar,NA,NA
 predicate. So in ,NA,NA
this case Prolog will display,NA,NA
playsAirGuitar(mia)  :- ,NA,NA
 listensToMusic(mia). ,NA,NA
playsAirGuitar(yolanda) :- ,NA,NA
 listensToMusic(yolanda). ,NA,NA
yes,NA,NA
"Well --- now you're ready to go. KB2 is loaded and Prolog is running, so you can (and should!) ",NA,NA
start making exactly the sort of inquiries we discussed in the text ...,NA,NA
"But let's back up a little, and summarize a few of the practical skills you will need to master to ",NA,NA
get this far:,G,NA
"You will need to know some basic facts about the operating system you are using, such as ",NA,NA
"the directory structure it uses. After all, you will need to know how to save the files ",NA,NA
containing programs where you want them.,G,NA
"You will need to know how to use some sort of text editor, in order to write and modify ",NA,NA
"programs. Some Prolog implementations come with in-built text editors, but if you ",NA,NA
already know a text editor (such as Emacs) it is probably a better idea to use this to ,NA,NA
write your Prolog code.,G,NA
You may want to take example Prolog programs from the internet. So make sure you ,NA,NA
"know how to use a browser to find what you want, and to store the code where you ",NA,NA
want it.,G,NA
"Make sure you know how to start Prolog, and consult files from it.",NA,NA
"The sooner you pick up these skills, the better. With them out of the way (which shouldn't ",NA,NA
take long) you can start concentrating on mastering Prolog (which will take a lot longer).,NA,NA
"But assuming you have mastered these skills, what next? Quite simply, play with Prolog! ",NA,NA
"Consult the various knowledge bases discussed today, and check that the queries discussed ",NA,NA
"really do work the way we said they did. In particular, take a look at KB5 and make sure you ",NA,NA
understand why you get those peculiar ``jealousy'' relations. Try posing new queries. ,NA,NA
Experiment with the ,NA,NA
listing,NA,NA
 predicate (it's a useful tool). Type in the knowledge base used in ,NA,NA
"Exercise 5, and check whether your answers are correct. Best of all, think of some simple ",NA,NA
"domain that interests you, and create a brand-new knowledge base from scratch ...",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
2 Matching and Proof Search,NA,NA
Today's lecture has two main goals: ,NA,NA
"1.  To discuss the idea of matching in Prolog, and to explain how Prolog matching differs ",NA,NA
"from standard unification. Along the way, we'll introduce ",NA,NA
=,NA,NA
", the built-in Prolog predicate ",NA,NA
for matching. ,NA,NA
2.  To explain the search strategy Prolog uses when it tries to prove something.,G,NA
2.1 Matching ,H,NA
2.1.1 Examples ,H,NA
2.1.2 The occurs check ,H,NA
2.1.3 Programming with matching,G,NA
2.2 Proof Search,G,NA
2.3 Exercises,G,NA
2.4 Practical Session 2,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
2.1 Matching,NA,NA
"When working with knowledge base KB4 in the previous chapter, we introduced the term ",NA,NA
"matching. We said, e.g. that Prolog matches ",NA,NA
woman(X),NA,NA
 with ,NA,NA
woman(mia),NA,NA
", thereby ",NA,NA
instantiating the variable ,NA,NA
X,NA,NA
 to ,NA,NA
mia,NA,NA
. We will now have a close look at what matching means.,NA,NA
Recall that there are three types of term: ,NA,NA
1.  Constants. These can either be atoms (such as ,NA,NA
vincent,NA,NA
) or numbers (such as ,NA,NA
24,NA,NA
). 2.  ,NA,NA
Variables.,NA,NA
3.  Complex terms. These have the form: ,NA,NA
"functor(term_1,...,term_n)",NA,NA
.,NA,NA
We are now going to define when two terms match. The basic idea is this: ,NA,NA
"Two terms match, if they are equal or if they contain variables that can be",NA,NA
instantiated in such a way that the resulting terms are equal.,NA,NA
That means that the terms ,NA,NA
mia,NA,NA
 and ,NA,NA
mia,NA,NA
" match, because they are the same atom. Similarly, ",NA,NA
the terms ,NA,NA
42,NA,NA
 and ,NA,NA
42,NA,NA
" match, because they are the same number, the terms ",NA,NA
X,NA,NA
 and ,NA,NA
X,NA,NA
" match, ",NA,NA
"because they are the same variable, and the terms ",NA,NA
woman(mia),NA,NA
 and ,NA,NA
woman(mia),NA,NA
" match, ",NA,NA
because they are the same complex term. The terms ,NA,NA
woman(mia),NA,NA
 and ,NA,NA
woman(vincent),NA,NA
", ",NA,NA
"however, do not match, as they are not the same (and neither of them contains a variable ",NA,NA
that could be instantiated to make them the same).,NA,NA
"Now, what about the terms ",NA,NA
mia,NA,NA
 and ,NA,NA
X,NA,NA
"? They are not the same. However, the variable ",NA,NA
X,NA,NA
 can ,NA,NA
be instantiated to ,NA,NA
mia,NA,NA
" which makes them equal. So, by the second part of the above ",NA,NA
"definition, ",NA,NA
mia,NA,NA
 and ,NA,NA
X,NA,NA
" match. Similarly, the terms ",NA,NA
woman(X),NA,NA
 and ,NA,NA
woman(mia),NA,NA
" match, because ",NA,NA
they can be made equal by instantiating ,NA,NA
X,NA,NA
 to ,NA,NA
mia,NA,NA
. How about ,NA,NA
"loves(vincent,X) ",NA,NA
and ,NA,NA
"loves(X,mia)",NA,NA
? It is impossible to find an instantiation of ,NA,NA
X,NA,NA
" that makes the two terms equal, and ",NA,NA
therefore they don't match. Do you see why? Instantiating ,NA,NA
X,NA,NA
 to ,NA,NA
vincent,NA,NA
 would give us the ,NA,NA
terms ,NA,NA
"loves(vincent,vincent)",NA,NA
 and ,NA,NA
"loves(vincent,mia)",NA,NA
", which are obviously not equal. However, ",NA,NA
instantiating ,NA,NA
X,NA,NA
" to mia, would yield the terms ",NA,NA
"loves(vincent, mia)",NA,NA
 and ,NA,NA
"loves(mia,mia)",NA,NA
", which ",NA,NA
aren't equal either.,NA,NA
"Usually, we are not only interested in the fact that two terms match, but we also want to know ",NA,NA
in what way the variables have to be instantiated to make them equal. And Prolog gives us ,NA,NA
"this information. In fact, when Prolog matches two terms it performs all the necessary ",NA,NA
"instantiations, so that the terms really are equal afterwards. This functionality together with ",NA,NA
"the fact that we are allowed to build complex terms (that is, recursively structured terms) ",NA,NA
makes matching a quite powerful mechanism. And as we said in the previous chapter: ,NA,NA
matching is one of the fundamental ideas in Prolog.,NA,NA
"Here's a more precise definition for matching which not only tells us when two terms match, ",NA,NA
but one which also tells us what we have to do to the variables to make the terms equal. ,NA,NA
1.  If ,NA,NA
term1,NA,NA
 and ,NA,NA
term2,NA,NA
" are constants, then ",NA,NA
term1,NA,NA
 and ,NA,NA
term2,NA,NA
 match if and only if they ,NA,NA
"are the same atom, or the same number.",NA,NA
2.  If ,NA,NA
term1,NA,NA
 is a variable and ,NA,NA
term2,NA,NA
" is any type of term, then ",NA,NA
term1,NA,NA
 and ,NA,NA
term2,NA,NA
" match, ",NA,NA
and ,NA,NA
term1,NA,NA
 is instantiated to ,NA,NA
term2,NA,NA
". Similarly, if ",NA,NA
term2,NA,NA
 is a variable and ,NA,NA
term1,NA,NA
 is any ,NA,NA
"type of term, then ",NA,NA
term1,NA,NA
 and ,NA,NA
term2,NA,NA
" match, and ",NA,NA
term2,NA,NA
 is instantiated to ,NA,NA
term1,NA,NA
. (So ,NA,NA
"if they are both variables, they're both instantiated to each other, and we say that they ",NA,NA
share values.) ,NA,NA
3.  If ,NA,NA
term1,NA,NA
 and ,NA,NA
term2,NA,NA
" are complex terms, then they match if and only if: ",NA,NA
a.  They have the same functor and arity.,NA,NA
b.  All their corresponding arguments match ,NA,NA
c.  and the variable instantiations are compatible. (I.e. it is not possible to instantiate ,NA,NA
variable ,NA,NA
X,NA,NA
 to ,NA,NA
mia,NA,NA
", when matching one pair of arguments, and to then instantiate ",NA,NA
X,NA,NA
 ,NA,NA
to ,NA,NA
vincent,NA,NA
", when matching another pair of arguments.)",NA,NA
4.  Two terms match if and only if it follows from the previous three clauses that they ,NA,NA
match.,NA,NA
Note the form of this definition. The first clause tells us when two constants match. The second ,NA,NA
"term clause tells us when two terms, one of which is a variable, match: such terms will always ",NA,NA
"match (variables match with anything). Just as importantly, this clause also tells what ",NA,NA
"instantiations we have to perform to make the two terms the same. Finally, the third clause ",NA,NA
tells us when two complex terms match.,NA,NA
The fourth clause is also very important: it tells us that the first three clauses completely ,NA,NA
"define when two terms match. If two terms can't be shown to match using Clauses 1-3, then ",NA,NA
"they don't match. For example, ",NA,NA
batman,NA,NA
 does not match with ,NA,NA
daughter(ink),NA,NA
. Why not? ,NA,NA
"Well, the first term is a constant, the second is a complex term. But none of the first three ",NA,NA
"clauses tell us how to match two such terms, hence (by clause 4) they don't match.",G,NA
2.1.1 Examples,NA,NA
2.1.2 The occurs check,G,NA
2.1.3 Programming with matching,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
2.1.1 Examples,NA,NA
We'll now look at lots of examples to make this definition clear. In these examples we'll make ,NA,NA
"use of an important built-in Prolog predicate, the ",NA,NA
=/2,NA,NA
 predicate (recall that the ,NA,NA
/2,NA,NA
 at the end ,NA,NA
is to indicate that this predicate takes two arguments).,NA,NA
"Quite simply, the ",NA,NA
=/2,NA,NA
" predicate tests whether its two arguments match. For example, if we ",NA,NA
pose the query ,NA,NA
"=(mia,mia).",NA,NA
"Prolog will respond `yes', and if we pose the query ",NA,NA
"=(mia,vincent).",NA,NA
Prolog will respond `no'.,NA,NA
"But we usually wouldn't pose these queries in quite this way. Let's face it, the notation ",NA,NA
"=(mia, ",NA,NA
mia),NA,NA
" is rather unnatural. It would be much nicer if we could use infix notation (that is, put the ",NA,NA
=,NA,NA
 functor between its arguments) and write things like: ,NA,NA
mia = mia .,NA,NA
"And in fact, Prolog lets us do this. So in the examples that follow we'll use the (much nicer) ",NA,NA
infix notation.,NA,NA
Let's return to this example: ,NA,NA
mia = mia. ,NA,NA
yes,NA,NA
Why does Prolog say `yes'? This may seem like a silly question: surely it's obvious that the ,NA,NA
"terms match! That's true, but how does this follow from the definition given above? It is very ",NA,NA
important that you learn to think systematically about matching (it is utterly fundamental to ,NA,NA
"Prolog), and `thinking systematically' means relating the examples to the definition of ",NA,NA
matching given above. So let's think this example through.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node17.html (1 of 5)11/3/2006 7:27:31 PM,NA
"The definition has three clauses. Clause 2 is for when one argument is a variable, and clause 3 ",NA,NA
"is for when both arguments are complex terms, so these are no use here. However clause 1 is ",NA,NA
relevant to our example. This tells us that two constants unify if and only if they are are exactly ,NA,NA
the same object. As ,NA,NA
mia,NA,NA
 and ,NA,NA
mia,NA,NA
" are the same atom, matching succeeds.",NA,NA
A similar argument explains the following responses: ,NA,NA
2 = 2. ,NA,NA
yes ,NA,NA
mia = vincent. ,NA,NA
no,NA,NA
"Once again, clause 1 is relevant here (after all, ",NA,NA
2,NA,NA
", ",NA,NA
mia,NA,NA
", and ",NA,NA
vincent,NA,NA
 are all constants). And as ,NA,NA
2,NA,NA
 is the same number as ,NA,NA
2,NA,NA
", and as ",NA,NA
mia,NA,NA
 is not the same atom as ,NA,NA
vincent,NA,NA
", Prolog responds ",NA,NA
`yes' to the first query and `no' to the second.,NA,NA
However clause 1 does hold one small surprise for us. Consider the following query: ,NA,NA
'mia' = mia. ,NA,NA
yes,NA,NA
"What's going here? Why do these two terms match? Well, as far as Prolog is concerned, ",NA,NA
'mia',NA,NA
 ,NA,NA
and ,NA,NA
mia,NA,NA
" are the same atom. In fact, for Prolog, any atom of the form ",NA,NA
'symbols',NA,NA
 is considered ,NA,NA
the same entity as the atom of the form ,NA,NA
symbols,NA,NA
. This can be a useful feature in certain kinds ,NA,NA
"of programs, so don't forget it.",NA,NA
"On the other hand, to the the query ",NA,NA
'2' = 2.,NA,NA
"Prolog will respond `no'. And if you think about the definitions given in Lecture 1, you will see ",NA,NA
"that this has to be the way things work. After all, ",NA,NA
2,NA,NA
" is a number, but ",NA,NA
'2',NA,NA
 is an atom. They ,NA,NA
simply cannot be the same.,NA,NA
Let's try an example with a variable: ,NA,NA
mia = X. ,NA,NA
X = mia ,NA,NA
yes,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node17.html (2 of 5)11/3/2006 7:27:31 PM,NA
"Again, this in an easy example: clearly the variable ",NA,NA
X,NA,NA
 can be matched with the constant ,NA,NA
mia,NA,NA
", ",NA,NA
"and Prolog does so, and tells us that it has made this matching. Fine, but how does this follow ",NA,NA
from our definition?,NA,NA
The relevant clause here is clause 2. This tells us what happens when at least one of the ,NA,NA
arguments is a variable. In our example it is the second term which is the variable. The ,NA,NA
"definition tells us unification is possible, and also says that the variable is instantiated to the ",NA,NA
"first argument, namely ",NA,NA
mia,NA,NA
". And this, of course, is exactly what Prolog does.",NA,NA
Now for an important example: what happens with the following query? ,NA,NA
X = Y.,NA,NA
"Well, depending on your Prolog implementation, you may just get back the output ",NA,NA
X = Y. ,NA,NA
yes,NA,NA
"Prolog is simply agreeing that the two terms unify (after all, variables unify with anything, so ",NA,NA
"certainly with each other) and making a note that from now on, ",NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 denote the same ,NA,NA
"object. That is, if ever ",NA,NA
X,NA,NA
" is instantiated, ",NA,NA
Y,NA,NA
" will be instantiated too, and to the same thing.",NA,NA
"On the other hand, you may get the following output: ",NA,NA
X = _5071 ,NA,NA
Y = _5071,NA,NA
"Here, both arguments are variables. What does this mean?",NA,NA
"Well, the first thing to realize is that the symbol ",NA,NA
_5071,NA,NA
 is a variable (recall from Lecture 1 that ,NA,NA
strings of letters and numbers that start with a ,NA,NA
_,NA,NA
 are variables). Now look at clause 2 of the ,NA,NA
"definition. This tells us that when two variables are matched, they share values. So what Prolog ",NA,NA
is doing here is to create a new variable (namely ,NA,NA
_5071,NA,NA
" ) and saying that, from now on, both ",NA,NA
X,NA,NA
 ,NA,NA
and ,NA,NA
Y,NA,NA
" share the value of this variable. That is, in effect, Prolog is creating a common variable ",NA,NA
"name for the two original variables. Incidentally, there's nothing magic about the number ",NA,NA
5071,NA,NA
". Prolog just needs to generate a brand new variable name, and using numbers is a handy ",NA,NA
way to do this. It might just as well generate ,NA,NA
_5075,NA,NA
", or ",NA,NA
_6189,NA,NA
", or whatever.",NA,NA
Here is another example involving only atoms and variables. How do you think will Prolog ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node17.html (3 of 5)11/3/2006 7:27:31 PM,NA
respond? ,NA,NA
"X = mia, X = vincent.",NA,NA
"Prolog will respond 'no'. This query involves two goals, ",NA,NA
X = mia,NA,NA
 and ,NA,NA
X = vincent,NA,NA
. Taken ,NA,NA
"seperately, Prolog would succeed for both of them, instantiating ",NA,NA
X,NA,NA
 to ,NA,NA
mia,NA,NA
 in the first case and ,NA,NA
to ,NA,NA
vincent,NA,NA
 in the second. And that's exactly the problem here: once Prolog has worked through ,NA,NA
"the first query, ",NA,NA
X,NA,NA
" is instantiated, and therefore equal, to ",NA,NA
mia,NA,NA
", so that that it doesn't match with ",NA,NA
vincent,NA,NA
 anymore and the second goal fails.,NA,NA
"Now, let's look at an example involving complex terms: ",NA,NA
"kill(shoot(gun),Y) = kill(X,stab(knife)). ",NA,NA
X = shoot(gun) ,NA,NA
Y = stab(knife) ,NA,NA
yes,NA,NA
Clearly the two complex terms match if the stated variable instantiations are carried out. But ,NA,NA
"how does this follow from the definition? Well, first of all, Clause 3 has to be used here ",NA,NA
because we are trying to match two complex terms. So the first thing we need to do is check ,NA,NA
that both complex terms have the same functor (that is: they use the same atom as the ,NA,NA
functor name and have the same number of arguments). And they do. Clause 3 also tells us ,NA,NA
that we have to match the corresponding arguments in each complex term. So do the first ,NA,NA
"arguments, ",NA,NA
shoot(gun),NA,NA
 and ,NA,NA
X,NA,NA
", match? By Clause 2, yes, and we instantiate ",NA,NA
X,NA,NA
 to ,NA,NA
shoot (gun),NA,NA
. ,NA,NA
"So do the second arguments, ",NA,NA
Y,NA,NA
 and ,NA,NA
stab(knife),NA,NA
", match? Again by Clause 2, yes, and we ",NA,NA
instantiate ,NA,NA
Y,NA,NA
 to ,NA,NA
kill(stab),NA,NA
.,NA,NA
Here's another example with complex terms: ,NA,NA
"kill(shoot(gun), stab(knife)) = kill(X,stab(Y)). ",NA,NA
X = shoot(gun) ,NA,NA
Y = knife ,NA,NA
yes,NA,NA
It should be clear that the two terms match if these instantiations are carried out. But can you ,NA,NA
"explain, step by step, how this relates to the definition?",NA,NA
Here is a last example: ,NA,NA
"loves(X,X) = loves(marcellus,mia).",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node17.html (4 of 5)11/3/2006 7:27:31 PM,NA
"Do these terms match? No, they don't. They are both complex terms and have the same ",NA,NA
"functor and arity. So, up to there it's ok. But then, Clause 3 of the definition says that all ",NA,NA
corresponding arguments have to match and that the variable instantiations have to be ,NA,NA
"compatible, and that is not the case here. Matching the first arguments would instantiate ",NA,NA
X ,NA,NA
with ,NA,NA
marcellus,NA,NA
 and matching the second arguments would instantiate ,NA,NA
X,NA,NA
 with ,NA,NA
mia,NA,NA
.,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
2.1.2 The occurs check,NA,NA
"Instead of saying that Prolog matches terms, you'll find that many books say that Prolog ",NA,NA
"unifies terms. This is very common terminology, and we will often use it ourselves. But while it ",NA,NA
"does not really matter whether you call what Prolog does `unification' or `matching', there is ",NA,NA
one thing you do need to know: Prolog does not use a standard unification algorithm when it ,NA,NA
"performs unification/matching. Instead, it takes a shortcut. You need to know about this ",NA,NA
shortcut.,NA,NA
Consider the following query: ,NA,NA
father(X) = X.,NA,NA
Do you think these terms match or not? ,NA,NA
"A standard unification algorithm would say: No, they don't. Do you see why? Pick any term and ",NA,NA
instantiate ,NA,NA
X,NA,NA
" to the term you picked. For example, if you instantiate ",NA,NA
X,NA,NA
 to ,NA,NA
father(father (butch)),NA,NA
", ",NA,NA
the left hand side becomes ,NA,NA
father(father(father(butch))),NA,NA
", and the right hand side becomes ",NA,NA
father(father(butch)),NA,NA
". Obviously these don't match. Moreover, it makes no difference what you ",NA,NA
instantiate ,NA,NA
X,NA,NA
" to. No matter what you choose, the two terms cannot possibly be made the ",NA,NA
"same, for the term on the left will always be one symbol longer than the term on the right (the ",NA,NA
functor ,NA,NA
father,NA,NA
 on the left will always give it that one extra level). The two terms simply don't ,NA,NA
match.,NA,NA
"But now, let's see what Prolog would answer to the above query. With old Prolog ",NA,NA
implementations you would get a message like: ,NA,NA
Not enough memory to complete query!,NA,NA
and a long string of symbols like: ,NA,NA
X = father(father(father(father(father(father(father(father ,NA,NA
(father(father(father(father(father(father(father(father (father ,NA,NA
(father(father(father(father(father(father(father(father (father ,NA,NA
(father(father(father(father(father(father(father(father (father ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node18.html (1 of 3)11/3/2006 7:27:36 PM,NA
(father(father(father(father(father(father(father(father (father,NA,NA
"Prolog is desperately trying to match these terms, but it won't succeed. That strange variable ",NA,NA
X,NA,NA
", which occurs as an argument to a functor on the left hand side, and on its own on the right ",NA,NA
"hand side, makes matching impossible.",NA,NA
"To be fair, what Prolog is trying to do here is reasonably intelligent. Intuitively, the only way ",NA,NA
the two terms could be made to match would be if ,NA,NA
X,NA,NA
 was instantiated to `a term containing an ,NA,NA
infinitely long string of ,NA,NA
father,NA,NA
" functors', so that the effect of the extra ",NA,NA
father,NA,NA
 functor on the left ,NA,NA
hand side was canceled out. But terms are finite entities. There is no such thing as a `term ,NA,NA
containing an infinitely long string of ,NA,NA
father,NA,NA
 functors'. Prolog's search for a suitable term is ,NA,NA
"doomed to failure, and it learns this the hard way when it runs out of memory.",NA,NA
"Now, current Prolog implementations have found a way of coping with this problem. Try to ",NA,NA
pose the query ,NA,NA
father(X) = X,NA,NA
 to SICStus Prolor or SWI. The answer will be something like: ,NA,NA
X = father(father(father(father(father(father(...)))))))))),NA,NA
The dots are indicating that there is an infinite nesting of ,NA,NA
father,NA,NA
" functors. So, newer versions of ",NA,NA
Prolog can detect cycles in terms without running our of memory and have a finite internal ,NA,NA
representation of such infinite terms.,NA,NA
"Still, a standard unification algorithm works differently. If we gave such an algorithm the same ",NA,NA
"example, it would look at it and tell us that the two terms don't unify. How does it do this? By ",NA,NA
carrying out the occurs check. Standard unification algorithms always peek inside the structure ,NA,NA
"of the terms they are asked to unify, looking for strange variables (like the X in our example) ",NA,NA
that would cause problems. ,NA,NA
"To put it another way, standard unification algorithms are pessimistic. They first look for ",NA,NA
strange variables (using the occurs check) and only when they are sure that the two terms are ,NA,NA
`safe' do they go ahead and try and match them. So a standard unification algorithm will never ,NA,NA
get locked into a situation where it is endlessly trying to match two unmatchable terms.,NA,NA
"Prolog, on the other hand, is optimistic. It assumes that you are not going to give it anything ",NA,NA
"dangerous. So it does not make an occurs check. As soon as you give it two terms, it charges ",NA,NA
full steam ahead and tries to match them.,NA,NA
"As Prolog is a programming language, this is an intelligent strategy. Matching is one of the ",NA,NA
"fundamental processes that makes Prolog work, so it needs to be carried out as fast as ",NA,NA
possible. Carrying out an occurs check every time matching was called for would slow it down ,NA,NA
"considerably. Pessimism is safe, but optimism is a lot faster!",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node18.html (2 of 3)11/3/2006 7:27:36 PM,NA
"Prolog can only run into problems if you, the programmer, ask it to do something impossible ",NA,NA
like unify ,NA,NA
X,NA,NA
 with ,NA,NA
father(X),NA,NA
. And it is unlikely you will ever ask it to anything like that when ,NA,NA
writing a real program.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
2.1.3 Programming with matching,NA,NA
"As we've said, matching is a fundamental operation in Prolog. It plays a key role in Prolog ",NA,NA
"proof search (as we shall soon learn), and this alone makes it vital. However, as you get to ",NA,NA
"know Prolog better, it will become clear that matching is interesting and important in its own ",NA,NA
"right. Indeed, sometimes you can write useful programs simply by using complex terms to ",NA,NA
define interesting concepts. Matching can then be used to pull out the information you want.,NA,NA
"Here's a simple example of this, due to Ivan Bratko. The following two line knowledge base ",NA,NA
"defines two predicates, namely ",NA,NA
vertical/2,NA,NA
 and ,NA,NA
horizontal/2,NA,NA
", which specify what it means for ",NA,NA
a line to be vertical or horizontal respectively. ,NA,NA
"vertical(line(point(X,Y),point(X,Z))). ",NA,NA
"horizontal(line(point(X,Y),point(Z,Y))). ",NA,NA
"Now, at first glance this knowledge base may seem too simple to be interesting: it contains ",NA,NA
"just two facts, and no rules. But wait a minute: the two facts are expressed using complex ",NA,NA
"terms which again have complex terms as arguments. If you look closely, you see that there ",NA,NA
"are three levels of nesting terms into terms. Moreover, the deepest level arguments are all ",NA,NA
"variables, so the concepts are being defined in a general way. Maybe its not quite as simple as ",NA,NA
it seems. Let's take a closer look.,NA,NA
"Right down at the bottom level, we have a complex term with functor ",NA,NA
point,NA,NA
 and two ,NA,NA
arguments. Its two arguments are intended to be instantiated to numbers: ,NA,NA
"point(X,Y) ",NA,NA
"represents the Cartesian coordinates of a point. That is, the ",NA,NA
X,NA,NA
 indicates the horizontal distance ,NA,NA
"the point is from some fixed point, while the ",NA,NA
Y,NA,NA
 indicates the vertical distance from that same ,NA,NA
fixed point.,NA,NA
"Now, once we've specified two distinct points, we've specified a line, namely the line between ",NA,NA
"them. In effect, the two complex terms representing points are bundled toghether as the two ",NA,NA
arguments of another complex term with the functor ,NA,NA
line,NA,NA
". So, we represent a line by a complex ",NA,NA
term which has two arguments which are complex terms as well and represent points. We're ,NA,NA
using Prolog's ability to build complex terms to work our way up a hierarchy of concepts.,NA,NA
To be vertical or to be horizontal are properties of lines. The predicates ,NA,NA
vertical,NA,NA
 and ,NA,NA
horizontal,NA,NA
 therefore both take one argument which represents a line. The definition of ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node19.html (1 of 3)11/3/2006 7:27:41 PM,NA
vertical/1,NA,NA
 simply says: a line that goes between two points that have the same x-,NA,NA
coordinate is vertical. Note how we capture the effect of `the same x-coordinate' in Prolog: we ,NA,NA
simply make use of the same variable ,NA,NA
X,NA,NA
 as the first argument of the two complex terms ,NA,NA
representing the points.,NA,NA
"Similarly, the definition of ",NA,NA
horizontal/1,NA,NA
 simply says: a line that goes between two points that ,NA,NA
"have the same y-coordinate is horizontal. To capture the effect of `the same y-coordinate', ",NA,NA
we use the same variable ,NA,NA
Y,NA,NA
 as the second argument of the two complex terms representing ,NA,NA
the points.,NA,NA
What can we do with this knowledge base? Let's look at some examples: ,NA,NA
"vertical(line(point(1,1),point(1,3))). yes ",NA,NA
This should be clear: the query matches with the definition of ,NA,NA
vertical/1,NA,NA
 in our little ,NA,NA
"knowledge base (and in particular, the representations of the two points have the same first ",NA,NA
argument) so Prolog says `yes'. Similarly we have: ,NA,NA
"vertical(line(point(1,1),point(3,2))). no ",NA,NA
This query does not match the definition of ,NA,NA
vertical/1,NA,NA
 (the representations of the two ,NA,NA
points have different first arguments) so Prolog says `no'.,NA,NA
But we can ask more general questions: ,NA,NA
"horizontal(line(point(1,1),point(2,Y))). ",NA,NA
Y = 1 ; ,NA,NA
no,NA,NA
"Here our query is: if we want a horizontal line between a point at (1,1), and point whose x-",NA,NA
"coordinate is 2, what should the y-coordinate of that second point be? Prolog correctly tells us ",NA,NA
that the y-coordinate should be 2. If we then ask Prolog for a second possibility (note the ,NA,NA
;,NA,NA
) it ,NA,NA
tells us that no other possibilities exist.,NA,NA
Now consider the following: ,NA,NA
"horizontal(line(point(2,3),P)). ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node19.html (2 of 3)11/3/2006 7:27:41 PM,NA
"P = point(_1972,3) ; ",NA,NA
no,NA,NA
"This query is: if we want a horizontal line between a point at (2,3), and some other point, what ",NA,NA
other points are permissible? The answer is: any point whose y-coordinate is 3. Note that the ,NA,NA
_1972,NA,NA
" in the first argument of the answer is a variable, which is Prolog's way of telling us that ",NA,NA
any x-coordinate at all will do.,NA,NA
"A general remark: the answer to our last query, ",NA,NA
"point(_1972,3)",NA,NA
", is structured. That is, the ",NA,NA
"answer is a complex term, representing a sophisticated concept (namely `any point whose y-",NA,NA
coordinate is 3'). This structure was built using matching and nothing else: no logical inferences ,NA,NA
"(and in particular, no uses of modus ponens) were used to produce it. Building structure by ",NA,NA
"matching turns out to be a powerful idea in Prolog programming, far more powerful than this ",NA,NA
"rather simple example might suggest. Moreover, when a program is written that makes heavy ",NA,NA
"use of matching, it is likely to be extremely efficient. We will study a beautiful example in a ",NA,NA
"later lecture when we discuss difference lists, which are used to implement Prolog built-in ",NA,NA
grammar system Definite Clause Grammars (DCGs).,NA,NA
This style of programming is particularly useful in applications where the important concepts ,NA,NA
"have a natural hierarchical structure (as they did in the simple knowledge base above), for we ",NA,NA
"can then use complex terms to represent this structure, and matching to access it. This way of ",NA,NA
"working plays an important role in computational linguistics, because information about ",NA,NA
language has a natural hierarchical structure (think of the way we divide sentences into noun ,NA,NA
"phrases and verb phrases, and noun phrases into determiners and nouns, and so on).",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
2.2 Proof Search,NA,NA
"Now that we know about matching, we are in a position to learn how Prolog actually searches ",NA,NA
"a knowledge base to see if a query is satisfied. That is, we are now able to learn about proof ",NA,NA
search. We will introduce the basic ideas involved by working through a simple example.,NA,NA
Suppose we are working with the following knowledge base ,NA,NA
f(a). ,NA,NA
f(b). ,NA,NA
g(a). ,NA,NA
g(b). ,NA,NA
h(b). ,NA,NA
"k(X) :- f(X),g(X),h(X).",NA,NA
Suppose we then pose the query ,NA,NA
k(X).,NA,NA
"You will probably see that there is only one answer to this query, namely ",NA,NA
k(b),NA,NA
", but how ",NA,NA
exactly does Prolog work this out? Let's see.,NA,NA
"Prolog reads the knowledge base, and tries to match ",NA,NA
k(X),NA,NA
" with either a fact, or the head of a ",NA,NA
"rule. It searches the knowledge base top to bottom, and carries out the matching, if it can, at ",NA,NA
the first place possible. Here there is only one possibility: it must match ,NA,NA
k(X),NA,NA
 to the head of ,NA,NA
the rule ,NA,NA
"k(X) :- f(X),g(X),h(X)",NA,NA
.,NA,NA
"When Prolog matches the variable in a query to a variable in a fact or rule, it generates a ",NA,NA
brand new variable to represent that the variables are now sharing. So the original query now ,NA,NA
reads: ,NA,NA
k(_G348),NA,NA
and Prolog knows that ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node20.html (1 of 7)11/3/2006 7:27:48 PM,NA
"k(_G348) :- f(_G348),g(_G348),h(_G348).",NA,NA
So what do we now have? The query says: `I want to find an individual that has property ,NA,NA
k,NA,NA
'. ,NA,NA
"The rule says,`an individual has property ",NA,NA
k,NA,NA
 if it has properties ,NA,NA
f,NA,NA
", ",NA,NA
g,NA,NA
", and ",NA,NA
h,NA,NA
'. So if Prolog can find ,NA,NA
an individual with properties ,NA,NA
f,NA,NA
", ",NA,NA
g,NA,NA
", and ",NA,NA
h,NA,NA
", it will have satisfied the original query. So Prolog ",NA,NA
replaces the original query with the following list of goals: ,NA,NA
"f(_G348),g(_G348),h(_G348).",NA,NA
We will represent this graphically as ,NA,NA
"That is, our original goal is to prove ",NA,NA
k(X),NA,NA
. When matching it with the head of the rule in the ,NA,NA
knowledge base ,NA,NA
X,NA,NA
 and the internal variable ,NA,NA
_G348,NA,NA
 are made equal and we are left with the ,NA,NA
goals ,NA,NA
"f(_G348),g(_G348),h(_G348).",NA,NA
"Now, whenever it has a list of goals, Prolog tries to satisfy them one by one, working through ",NA,NA
the list in a left to right direction. The leftmost goal is ,NA,NA
f(_G348),NA,NA
", which reads: `I want an ",NA,NA
individual with property ,NA,NA
f,NA,NA
'. Can this goal be satisfied? Prolog tries to do so by searching through ,NA,NA
the knowledge base from top to bottom. The first thing it finds that matches this goal is the ,NA,NA
fact ,NA,NA
f(a),NA,NA
. This satisfies the goal ,NA,NA
f(_G348),NA,NA
 and we are left with two more goals to go. When ,NA,NA
matching ,NA,NA
f(_G348),NA,NA
 to ,NA,NA
f(a),NA,NA
", ",NA,NA
X,NA,NA
 is instantiated to ,NA,NA
a,NA,NA
. This applies to all occurrences of ,NA,NA
X ,NA,NA
in the list of ,NA,NA
"goals. So, the list of remaining goals is: ",NA,NA
"g(a),h(a)",NA,NA
and our graphical representation of the proof search looks like this:,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node20.html (2 of 7)11/3/2006 7:27:48 PM,NA
The fact ,NA,NA
g(a),NA,NA
" is in the knowledge base. So the next goal we have to prove is satisfied too, ",NA,NA
and the goal list is now ,NA,NA
h(a) ,NA,NA
and the graphical representation,NA,NA
But there is no way to satisfy this goal. The only information ,NA,NA
h,NA,NA
 we have in the knowledge base ,NA,NA
is ,NA,NA
h(b),NA,NA
 and this won't match ,NA,NA
h(a),NA,NA
. ,NA,NA
So Prolog decides it has made a mistake and checks whether at some point there was another ,NA,NA
possibility for matching a goal with a fact or the head of a rule in the knowledge base. It does ,NA,NA
this by going back up the path in the graphical representation that it was coming down on. ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node20.html (3 of 7)11/3/2006 7:27:48 PM,NA
There is nothing else in the knowledge base that matches with ,NA,NA
g(a),NA,NA
", but there is another ",NA,NA
possibility for matching ,NA,NA
f(_G348),NA,NA
. Points in the search where there are several alternatives for ,NA,NA
matching a goal against the knowledge base are called choice points. Prolog keeps track of ,NA,NA
"choice points and the choices that it has made there, so that if it makes a wrong choice, it can ",NA,NA
go back to the choice point and try something else. This is called ,NA,NA
backtracking,NA,NA
.,NA,NA
"So, Prolog backtracks to the last choice point, where the list of goals was: ",NA,NA
"f(_G348),g(_G348),h(_G348).",NA,NA
"Prolog has to redo all this. Prolog tries to resatisfy the first goal, by searching further in the ",NA,NA
knowledge base. It sees that it can match the first goal with information in the knowledge ,NA,NA
base by matching ,NA,NA
f(_G348),NA,NA
 with ,NA,NA
f(b),NA,NA
. This satisfies the goal ,NA,NA
f(_G348),NA,NA
 and instantiates ,NA,NA
X ,NA,NA
to ,NA,NA
b,NA,NA
", ",NA,NA
so that the remaining goal list is ,NA,NA
"g(b),h(b).",NA,NA
But ,NA,NA
g(b),NA,NA
" is a fact in the knowledge base, so this is satisfied too, leaving the goal list: ",NA,NA
h(b).,NA,NA
"And this fact too is in the knowledge base, so this goal is also satisfied. Important: Prolog now ",NA,NA
has an empty list of goals. This means that it has proved everything it had to to establish the ,NA,NA
"original goal, namely ",NA,NA
k(X),NA,NA
". So this query is satisfiable, and moreover, Prolog has also ",NA,NA
"discovered what it has to do to satisfy it, namely instantiate ",NA,NA
X,NA,NA
 to ,NA,NA
b,NA,NA
.,NA,NA
Representing these last steps graphically gives us,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node20.html (4 of 7)11/3/2006 7:27:48 PM,NA
It is interesting to consider what happens if we then ask for another solution by typing: ,NA,NA
;,NA,NA
"This forces Prolog to backtrack to the last choice point, to try and find another possibility. ",NA,NA
"However, there is no other choice point, as there are no other possibilities for matching ",NA,NA
h(b),NA,NA
", ",NA,NA
g(b),NA,NA
", ",NA,NA
f(_G348),NA,NA
", or ",NA,NA
k(X),NA,NA
 with clauses in the knowledge base. So at this point Prolog would ,NA,NA
"correctly have said `no'. Of course, if there had been other rules involving ",NA,NA
k,NA,NA
", Prolog would ",NA,NA
"have gone off and tried to use them in exactly the way we have described: that is, by ",NA,NA
"searching top to bottom in the knowledge base, left to right in goal lists, and backtracking to ",NA,NA
the previous choice point whenever it fails.,NA,NA
"Now, look at the graphical representation that we built while searching for proofs of ",NA,NA
k(X),NA,NA
. It is ,NA,NA
a tree structure. The nodes of the tree say which are the goals that have to be satisfied at a ,NA,NA
certain point during the search and at the edges we keep track of the variable instantiations ,NA,NA
that are made when the current goal (i.e. the first one in the list of goals) is match to a fact or ,NA,NA
the head of a rule in the knowledge base. Such trees are called search trees and they are a ,NA,NA
nice way of visualizing the steps that are taken in searching for a proof of some query. Leave ,NA,NA
"nodes which still contain unsatisfied goals are point where Prolog failed, because it made a ",NA,NA
"wrong decision somewhere along the path. Leave nodes with an empty goal list, correspond to ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node20.html (5 of 7)11/3/2006 7:27:48 PM,NA
a possible solution. The information on the edges along the path from the root node to that ,NA,NA
leave tell you what are the variable instantiations with which the query is satisfied.,NA,NA
Let's have a look at another example. Suppose that we are working with the following ,NA,NA
knowledge base: ,NA,NA
"loves(vincent,mia). ",NA,NA
"loves(marcellus,mia). ",NA,NA
"jealous(X,Y) :- loves(X,Z),loves(Y,Z).",NA,NA
"Now, we pose the query ",NA,NA
"jealous(X,Y).",NA,NA
The search tree for this query looks like this:,NA,NA
There is only one possibility of matching ,NA,NA
"jealous(X,Y)",NA,NA
 against the knowledge base. That is by ,NA,NA
using the rule ,NA,NA
"jealous(X,Y) :- loves(X,Z),loves(Y,Z).",NA,NA
The new goals that have to be satisfied are then ,NA,NA
"loves(_G100,_G101),loves(_G102,_G101) ","http://www.coli.uni-
 saarland.de/~kris/learn-prolog-now/html/node20.html (6 of 7)11/3/2006 7:27:48 PM",NA
"Now, we have to match ",NA,NA
"loves(_G100,_G101)",NA,NA
 against the knowledge base. There are two ways ,NA,NA
of how this can be done: it can either be matched with the first fact or with the second fact. ,NA,NA
This is why the path branches at this point. In both cases the goal ,NA,NA
"loves(_G102,mia) ",NA,NA
"is left, ",NA,NA
"which also has two possibilities of how it can be satisfied, namely the same ones as above. ",NA,NA
"So, we have four leave nodes with an empty goal list, which means that there are four ways ",NA,NA
for satisfying the query. The variable instantiation for each of them can be read off the path ,NA,NA
from the root to the leaf node. They are ,NA,NA
1.  ,NA,NA
X = \_158 = vincent,NA,NA
 and ,NA,NA
Y = \_178 = vincent ,NA,NA
2.  ,NA,NA
X = \_158 = ,NA,NA
vincent,NA,NA
 and ,NA,NA
Y = \_178 = marcellus ,NA,NA
3.  ,NA,NA
X = \_158 = marcellus,NA,NA
 and ,NA,NA
Y ,NA,NA
= \_178 = vincent ,NA,NA
4.  ,NA,NA
X = \_158 = marcellus,NA,NA
 and ,NA,NA
Y = \_178 = ,NA,NA
marcellus,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
2.3 Exercises,NA,NA
Exercise 2.1,NA,NA
"Which of the following pairs of terms match? Where relevant, give the variable ",NA,NA
instantiations that lead to successful matching. ,NA,NA
1.  ,NA,NA
bread = bread ,NA,NA
2.  ,NA,NA
'Bread' = bread ,NA,NA
3.  ,NA,NA
'bread' = bread ,NA,NA
4.  ,NA,NA
Bread = bread ,NA,NA
5.  ,NA,NA
bread = sausage ,NA,NA
6.  ,NA,NA
food(bread) = bread ,NA,NA
7.  ,NA,NA
food(bread) = X ,NA,NA
8.  ,NA,NA
food(X) = food(bread) ,NA,NA
9.  ,NA,NA
"food(bread,X) = food(Y,sausage) ",NA,NA
10.  ,NA,NA
"food(bread,X,beer) = food(Y,sausage,X) ",NA,NA
11.  ,NA,NA
"food(bread,X,beer) = food(Y,kahuna_burger) ",NA,NA
12.  ,NA,NA
food(X) = X ,NA,NA
13.  ,NA,NA
"meal(food(bread),drink(beer)) = meal(X,Y) ",NA,NA
14.  ,NA,NA
"meal(food(bread),X) = meal(X,drink(beer))",NA,NA
Exercise 2.2,NA,NA
We are working with the following knowledge base: ,NA,NA
house_elf(dobby). ,NA,NA
witch(hermione). ,NA,NA
witch('McGonagall'). ,NA,NA
witch(rita_skeeter). ,NA,NA
magic(X):-house_elf(X). ,NA,NA
magic(X):-wizard(X). ,NA,NA
magic(X):-witch(X).,NA,NA
"Which of the following queries are satisfied? Where relevant, give all the variable ",NA,NA
instantiations that lead to success. ,NA,NA
1.  ,NA,NA
?- magic(house_elf).,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node21.html (1 of 3)11/3/2006 7:27:54 PM,NA
2.  ,NA,NA
?- wizard(harry).,NA,NA
3.  ,NA,NA
?- magic(wizard).,NA,NA
4.  ,NA,NA
?- magic('McGonagall'). ,NA,NA
5.  ,NA,NA
?- magic(Hermione).,NA,NA
Draw the search tree for the fifth query ,NA,NA
magic(Hermione),NA,NA
.,NA,NA
Exercise 2.3,NA,NA
Here is a tiny lexicon and mini grammar with only one rule which defines a ,NA,NA
"sentence as consisting of five words: an article, a noun, a verb, and again an ",NA,NA
article and a noun. ,NA,NA
"word(article,a). ",NA,NA
"word(article,every). ",NA,NA
"word(noun,criminal). ",NA,NA
"word(noun,'big kahuna burger'). ",NA,NA
"word(verb,eats). ",NA,NA
"word(verb,likes). ",NA,NA
"sentence(Word1,Word2,Word3,Word4,Word5) :-  ",NA,NA
"word(article,Word1), ",NA,NA
" word(noun,Word2), ",NA,NA
" word(verb,Word3), ",NA,NA
" word(article,Word4), ",NA,NA
" word(noun,Word5).",NA,NA
What query do you have to pose in order to find out which sentences the ,NA,NA
grammar can generate? List all sentences that this grammar can generate in the ,NA,NA
order Prolog will generate them. Make sure that you understand why Prolog ,NA,NA
generates them in this order. ,NA,NA
Exercise 2.4,NA,NA
Here are six English words:,NA,NA
"abalone, abandon, anagram, connect, elegant, enhance.",NA,NA
They are to be arranged in a crossword puzzle like fashion in the grid given ,NA,NA
below. ,NA,NA
The following knowledge base represents a lexicon containing these words. ,NA,NA
"word(abalone,a,b,a,l,o,n,e). ",NA,NA
"word(abandon,a,b,a,n,d,o,n). ",NA,NA
"word(enhance,e,n,h,a,n,c,e). ",NA,NA
"word(anagram,a,n,a,g,r,a,m). ",NA,NA
"word(connect,c,o,n,n,e,c,t). ",NA,NA
"word(elegant,e,l,e,g,a,n,t).",NA,NA
Write a predicate ,NA,NA
crosswd/6,NA,NA
" that tells us how to fill the grid, i.e. the first three ",NA,NA
arguments should be the vertical words from left to right and the following three ,NA,NA
arguments the horizontal words from top to bottom.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
2.4 Practical Session 2,NA,NA
"By this stage, you should have had your first taste of running Prolog programs. The purpose of ",NA,NA
the second practical session is to suggest two sets of keyboard exercises which will help you ,NA,NA
"get familiar with the way Prolog works. The first set has to do with matching , the second with ",NA,NA
proof search.,NA,NA
"First of all, start up your Prolog interpreter. That is, get a screen displaying the usual `I'm ",NA,NA
"ready to start' prompt, which probably looks something like: ",NA,NA
?-,NA,NA
"Now verify your answers to Exercise 1.1, the matching examples. You don't need to consult ",NA,NA
"any knowledge bases, simply ask Prolog directly whether it is possible to unify the terms by ",NA,NA
using the built-in ,NA,NA
=/2,NA,NA
" predicate. For example, to test whether ",NA,NA
"food(bread,X)",NA,NA
 and ,NA,NA
"food(Y, ",NA,NA
sausage),NA,NA
" unify, just type in ",NA,NA
"food(bread,X) = food(Y,sausage).",NA,NA
and hit return.,NA,NA
You should also look at what happens when Prolog gets locked into an attempt to match ,NA,NA
"terms that can't be matched because it doesn't carry out an occurs check. For example, see ",NA,NA
what happens when you give it the following query: ,NA,NA
"g(X,Y) = Y.",NA,NA
Ah yes! This is the perfect time to make sure you know how to abort a program that is ,NA,NA
running wild!,NA,NA
"Well, once you've figured that out, it's time to move onto something new. There is another ",NA,NA
"important built-in Prolog predicate for answering queries about matching, namely ",NA,NA
\=/2,NA,NA
 (that ,NA,NA
is: a 2-place predicate ,NA,NA
\=,NA,NA
"). Roughly speaking, this works in the opposite way to the ",NA,NA
=/2 ,NA,NA
"predicate: it succeeds when its two arguments do not unify. For example, the terms ",NA,NA
a,NA,NA
 and ,NA,NA
b ,NA,NA
"do not unify, which explains the following dialogue: ",NA,NA
a \= b ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node22.html (1 of 4)11/3/2006 7:28:01 PM,NA
yes,NA,NA
Make sure you understand the way ,NA,NA
\=/2,NA,NA
 predicate works by trying it out on (at least) the ,NA,NA
"following examples. But do this actively, not passively. That is, after you type in an example, ",NA,NA
"pause, and try to work out for yourself what Prolog is going to respond. Only then hit return to ",NA,NA
see if you are right. ,NA,NA
1.  ,NA,NA
a \= a ,NA,NA
2.  ,NA,NA
'a' \= a ,NA,NA
3.  ,NA,NA
A \= a ,NA,NA
4.  ,NA,NA
f(a) \= a ,NA,NA
5.  ,NA,NA
f(a) \= A ,NA,NA
6.  ,NA,NA
f(A) \= f(a) ,NA,NA
7.  ,NA,NA
"g(a,B,c) \= g(A,b,C) ",NA,NA
8.  ,NA,NA
"g(a,b,c) \= g(A,C) ",NA,NA
9.  ,NA,NA
f(X) \= X,NA,NA
Thus the ,NA,NA
\=/2,NA,NA
 predicate is (essentially) the negation of the ,NA,NA
=/2,NA,NA
 predicate: a query involving ,NA,NA
one of these predicates will be satisfied when the corresponding query involving the other is ,NA,NA
"not, and vice versa (this is the first example we have seen of a Prolog mechanism for handling ",NA,NA
"negation). But note that word `essentially'. Things don't work out quite that way, as you will ",NA,NA
realise if you think about the trickier examples you've just tried out...,NA,NA
It's time to move on and introduce one of the most helpful tools in Prolog: ,NA,NA
trace,NA,NA
. This is an ,NA,NA
built-in Prolog predicate that changes the way Prolog runs: it forces Prolog to evaluate queries ,NA,NA
"one step at a time, indicating what it is doing at each step. Prolog waits for you to press return ",NA,NA
"before it moves to the next step, so that you can see exactly what is going on. It was really ",NA,NA
"designed to be used as a debugging tool, but it's also really helpful when you're learning ",NA,NA
Prolog: stepping through programs using ,NA,NA
trace,NA,NA
 is an excellent way of learning how Prolog proof ,NA,NA
search works.,NA,NA
"Let's look at an example. In the lecture, we looked at the proof search involved when we ",NA,NA
made the query ,NA,NA
k(X),NA,NA
 to the following knowledge base: ,NA,NA
f(a). ,NA,NA
f(b). ,NA,NA
g(a). ,NA,NA
g(b). ,NA,NA
h(b). ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node22.html (2 of 4)11/3/2006 7:28:01 PM,NA
"k(X) :- f(X),g(X),h(X).",NA,NA
Suppose this knowledge base is in a file ,NA,NA
proof.pl,NA,NA
. We first consult it: ,NA,NA
1 ?- [proof]. ,NA,NA
"% proof compiled 0.00 sec, 1,524 bytes ",NA,NA
yes,NA,NA
We then type `trace.' and hit return: ,NA,NA
2 ?- trace. ,NA,NA
Yes,NA,NA
"Prolog is now in trace mode, and will evaluate all queries step by step. For example, if we ",NA,NA
pose the query ,NA,NA
k(X),NA,NA
", and then hit return every time Prolog comes back with a ",NA,NA
?,NA,NA
", we obtain ",NA,NA
(something like) the following: ,NA,NA
[trace] 2 ?- k(X). ,NA,NA
 Call: ,NA,NA
(6) ,NA,NA
k(_G348) ,NA,NA
?   ,NA,NA
 Call: ,NA,NA
(7) ,NA,NA
f(_G348) ,NA,NA
?   ,NA,NA
 Exit: (7) f(a) ?   ,NA,NA
 Call: (7) g(a) ?   ,NA,NA
 Exit: (7) g(a) ?   ,NA,NA
 Call: (7) h(a) ?   ,NA,NA
 Fail: (7) h(a) ?   ,NA,NA
 Fail: (7) g(a) ?   ,NA,NA
 Redo: (7) f(_G348) ?   ,NA,NA
 Exit: (7) f(b) ?   ,NA,NA
 Call: (7) g(b) ?   ,NA,NA
 Exit: (7) g(b) ?   ,NA,NA
 Call: (7) h(b) ?   ,NA,NA
 Exit: (7) h(b) ?   ,NA,NA
 Exit: (6) k(b) ?   ,NA,NA
X = b ,NA,NA
Yes,NA,NA
"Study this carefully. That is, try doing the same thing yourself, and try to relate this output to ",NA,NA
"the discussion of the example in the text. To get you started, we'll remark that the third line is ",NA,NA
where the variable in the query is (wrongly) instantiated to ,NA,NA
a,NA,NA
", and that the line marked ",NA,NA
redo ,NA,NA
is ,NA,NA
"when Prolog realizes it's taken the wrong path, and backtracks to instantiate the variable to ",NA,NA
b,NA,NA
.,NA,NA
"While learning Prolog, use trace, and use it heavily. It's a great way to learn. ",NA,NA
Oh yes: you also need to know how to turn trace off. Simply type `notrace.' and hit return: ,NA,NA
notrace.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node22.html (4 of 4)11/3/2006 7:28:01 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
3 Recursion,NA,NA
This lecture has two main goals: ,NA,NA
1.  To introduce recursive definitions in Prolog.,NA,NA
2.  To show that there can be mismatches between the declarative meaning of a Prolog ,NA,NA
"program, and its procedural meaning. ",G,NA
3.1 Recursive definitions ,H,NA
3.1.1 Example 1: Eating ,H,NA
3.1.2 Example 2: Descendant ,H,NA
3.1.3 Example 3: Successor ,H,NA
3.1.4 Example 3: Addition,G,NA
"3.2 Clause ordering, goal ordering, and termination",G,NA
3.3 Exercises,G,NA
3.4 Practical Session 3,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
3.1 Recursive definitions ,NA,NA
"Predicates can be defined recursively. Roughly speaking, a predicate is recursively defined if ",NA,NA
one or more rules in its definition refers to itself.,G,NA
3.1.1 Example 1: Eating ,G,NA
3.1.2 Example 2: Descendant ,G,NA
3.1.3 Example 3: Successor ,G,NA
3.1.4 Example 3: Addition,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
3.1.1 Example 1: Eating,NA,NA
Consider the following knowledge base: ,NA,NA
"is_digesting(X,Y) :- just_ate(X,Y). is_digesting(X,Y) :- ",NA,NA
" just_ate(X,Z), ",NA,NA
" is_digesting(Z,Y). ",NA,NA
"just_ate(mosquito,blood(john)). ",NA,NA
"just_ate(frog,mosquito). ",NA,NA
"just_ate(stork,frog).",NA,NA
At first glance this seems pretty ordinary: it's just a knowledge base containing two facts and ,NA,NA
two rules. But the definition of the ,NA,NA
is_digesting/2,NA,NA
 predicate is recursive. Note that ,NA,NA
is_digesting,NA,NA
 is ,NA,NA
"(at least partially) defined in terms of itself, for the ",NA,NA
is_digesting,NA,NA
 functor occurs on both the left ,NA,NA
"and right hand sides of the second rule. Crucially, however, there is an `escape' from this ",NA,NA
circularity. This is provided by the ,NA,NA
just_ate,NA,NA
" predicate, which occurs in both the first and second ",NA,NA
"rules. (Significantly, the right hand side of the first rule makes no mention of ",NA,NA
is_digesting,NA,NA
.) Let's ,NA,NA
now consider both the declarative and procedural ,NA,NA
meanings of this rule.,NA,NA
The word declarative is used to talk about the logical meaning of Prolog knowledge bases. That ,NA,NA
"is, the declarative meaning of a Prolog knowledge base is simply `what it says', or `what it ",NA,NA
"means, if we read it as a collection of logical statements'. And the declarative meaning of this ",NA,NA
"recursive definition is fairly straightforward. The first clause (the `escape' clause, the one that ",NA,NA
"is not recursive, or as we shall usually call it, the base clause), simply says that: if ",NA,NA
X,NA,NA
 has just ,NA,NA
eaten ,NA,NA
Y,NA,NA
", then ",NA,NA
X,NA,NA
 is now digesting ,NA,NA
Y,NA,NA
. This is obviously a sensible definition.,NA,NA
"So what about the second clause, the recursive clause? This says that: if ",NA,NA
X,NA,NA
 has just eaten ,NA,NA
Z ,NA,NA
and ,NA,NA
Z,NA,NA
 is digesting ,NA,NA
Y,NA,NA
", then ",NA,NA
X,NA,NA
 is digesting ,NA,NA
Y,NA,NA
", too. Again, this is obviously a sensible definition.",NA,NA
"So now we know what this recursive definition says, but what happens when we pose a query ",NA,NA
"that actually needs to use this definition? That is, what does this definition actually do? To use ",NA,NA
"the normal Prolog terminology, what is its procedural meaning?",NA,NA
This is also reasonably straightforward. The base rule is like all the earlier rules we've seen. ,NA,NA
"That is, if we ask whether ",NA,NA
X,NA,NA
 is digesting ,NA,NA
Y,NA,NA
", Prolog can use this rule to ask instead the ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node25.html (1 of 4)11/3/2006 7:28:31 PM,NA
question: has ,NA,NA
X,NA,NA
 just eaten ,NA,NA
Y,NA,NA
?,NA,NA
What about the recursive clause? This gives Prolog another strategy for determining whether ,NA,NA
X,NA,NA
 is digesting ,NA,NA
Y,NA,NA
: it can try to find some ,NA,NA
Z,NA,NA
 such that ,NA,NA
X,NA,NA
 has just eaten ,NA,NA
Z,NA,NA
", and ",NA,NA
Z,NA,NA
 is digesting ,NA,NA
Y,NA,NA
. ,NA,NA
"That is, this rule lets Prolog break the task apart into two subtasks. Hopefully, doing so will ",NA,NA
eventually lead to simple problems which can be solved by simply looking up the answers in ,NA,NA
the knowledge base. The following picture sums up the situation:,NA,NA
Let's see how this works. If we pose the query: ,NA,NA
"?- is_digesting(stork,mosquito). ",NA,NA
"then Prolog goes to work as follows. First, it tries to make use of the first rule listed ",NA,NA
concerning ,NA,NA
is_digesting,NA,NA
"; that is, the base rule. This tells it that ",NA,NA
X,NA,NA
 is digesting ,NA,NA
Y,NA,NA
 if ,NA,NA
X,NA,NA
 just ate ,NA,NA
Y,NA,NA
", ",NA,NA
By unifying ,NA,NA
X,NA,NA
 with ,NA,NA
stork,NA,NA
 and ,NA,NA
Y,NA,NA
 with ,NA,NA
mosquito,NA,NA
 it obtains the following goal: ,NA,NA
"just_ate(stork,mosquito). ",NA,NA
"But the knowledge base doesn't contain the information that the stork just ate the mosquito, ",NA,NA
so this attempt fails. So Prolog next tries to make use of the second rule. By unifying ,NA,NA
X,NA,NA
 with ,NA,NA
stork,NA,NA
 and ,NA,NA
Y,NA,NA
 with ,NA,NA
mosquito,NA,NA
 it obtains the following goals: ,NA,NA
"just_ate(stork,Z), ",NA,NA
"is_digesting(Z,mosquito).",NA,NA
"That is, to show ",NA,NA
"is_digesting(stork,mosquitp)}",NA,NA
", Prolog needs to find a value for ",NA,NA
Z ,NA,NA
"such that, ",NA,NA
"firstly, ",NA,NA
"just_ate(stork,Z).",NA,NA
"and secondly, ",NA,NA
"is_digesting(Z,mosquito).",NA,NA
And there is such a value for ,NA,NA
Z,NA,NA
", namely ",NA,NA
frog,NA,NA
. It is immediate that ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node25.html (2 of 4)11/3/2006 7:28:31 PM,NA
"just_ate(stork,frog).",NA,NA
"will succeed, for this fact is listed in the knowledge base. And deducing ",NA,NA
"is_digesting(frog,mosquito).",NA,NA
"is almost as simple, for the first clause of ",NA,NA
is_digesting/2,NA,NA
 reduces this goal to deducing ,NA,NA
"just_ate(frog,mosquito).",NA,NA
and this is a fact listed in the knowledge base.,NA,NA
"Well, that's our first example of a recursive rule definition. We're going to learn a lot more ",NA,NA
"about them in the next few weeks, but one very practical remark should be made right away. ",NA,NA
"Hopefully it's clear that when you write a recursive predicate, it should always have at least ",NA,NA
"two clauses: a base clause (the clause that stops the recursion at some point), and one that ",NA,NA
"contains the recursion. If you don't do this, Prolog can spiral off into an unending sequence of ",NA,NA
"useless computations. For example, here's an extremely simple example of a recursive rule ",NA,NA
definition: ,NA,NA
p :- p.,NA,NA
That's it. Nothing else. It's beautiful in its simplicity. And from a declarative perspective it's an ,NA,NA
"extremely sensible (if rather boring) definition: it says `if property p holds, then property p ",NA,NA
holds'. You can't argue with that.,NA,NA
"But from a procedural perspective, this is a wildly dangerous rule. In fact, we have here the ",NA,NA
"ultimate in dangerous recursive rules: exactly the same thing on both sides, and no base ",NA,NA
clause to let us escape. For consider what happens when we pose the following query: ,NA,NA
?- p.,NA,NA
Prolog asks itself: how do I prove ,NA,NA
p,NA,NA
"? And it realizes, `Hey, I've got a rule for that! To prove ",NA,NA
p ,NA,NA
I just need to prove ,NA,NA
p,NA,NA
!'. So it asks itself (again): how do I prove ,NA,NA
p,NA,NA
"? And it realizes, `Hey, I've ",NA,NA
got a rule for that! To prove ,NA,NA
p,NA,NA
 I just need to prove ,NA,NA
p,NA,NA
!'. So it asks itself (yet again): how do I ,NA,NA
prove ,NA,NA
p,NA,NA
"? And it realizes, `Hey, I've got a rule for that! To prove ",NA,NA
p,NA,NA
 I just need to prove ,NA,NA
p,NA,NA
!'' So ,NA,NA
then it asks itself (for the fourth time): how do I prove ,NA,NA
p,NA,NA
? And it realizes that...,NA,NA
"If you make this query, Prolog won't answer you: it will head off, looping desperately away in ",NA,NA
"an unending search. That is, it won't terminate, and you'll have to interrupt it. Of course, if you ",NA,NA
use ,NA,NA
trace,NA,NA
", you can step through one step at a time, until you get sick of watching Prolog ",NA,NA
loop.,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
3.1.2 Example 2: Descendant,NA,NA
"Now that we know something about what recursion in Prolog involves, it is time to ask why it ",NA,NA
"is so important. Actually, this is a question that can be answered on a number of levels, but for ",NA,NA
"now, let's keep things fairly practical. So: when it comes to writing useful Prolog programs, are ",NA,NA
"recursive definitions really so important? And if so, why?",NA,NA
Let's consider an example. Suppose we have a knowledge base recording facts about the child ,NA,NA
relation: ,NA,NA
"child(charlotte,caroline). ",NA,NA
"child(caroline,laura).",NA,NA
"That is, Caroline is a child of Charlotte, and Laura is a child of Caroline. Now suppose we ",NA,NA
"wished to define the descendant relation; that is, the relation of being a child of, or a child of ",NA,NA
"a child of, or a child of a child of a child of, or.... Here's a first attempt to do this. We could ",NA,NA
add the following two non-recursive rules to the knowledge base: ,NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"descend(X,Y) :- child(X,Z), ",NA,NA
" child(Z,Y).",NA,NA
"Now, fairly obviously these definitions work up to a point, but they are clearly extremely ",NA,NA
limited: they only define the concept of descendant-of for two generations or less. That's ok ,NA,NA
"for the above knowledge base, but suppose we get some more information about the child-of ",NA,NA
relation and we expand our list of child-of facts to this: ,NA,NA
"child(martha,charlotte). ",NA,NA
"child(charlotte,caroline). ",NA,NA
"child(caroline,laura). ",NA,NA
"child(laura,rose).",NA,NA
"Now our two rules are inadequate. For example, if we pose the queries ",NA,NA
"?- descend(martha,laura).",NA,NA
or ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node26.html (1 of 6)11/3/2006 7:28:39 PM,NA
"?- descend(charlotte,rose).",NA,NA
"we get the answer `No!', which is not what we want. Sure, we could `fix' this by adding the ",NA,NA
following two rules: ,NA,NA
"descend(X,Y) :- child(X,Z_1), ",NA,NA
" child(Z_1,Z_2), ",NA,NA
" child(Z_2,Y). ",NA,NA
"descend(X,Y) :- child(X,Z_1), ",NA,NA
" child(Z_1,Z_2), ",NA,NA
" child(Z_2,Z_3), ",NA,NA
" child(Z_3,Y).",NA,NA
"But, let's face it, this is clumsy and hard to read. Moreover, if we add further child-of facts, we ",NA,NA
"could easily find ourselves having to add more and more rules as our list of child-of facts grow, ",NA,NA
rules like: ,NA,NA
"descend(X,Y) :- child(X,Z_1),  child(Z_1,Z_2),  ",NA,NA
"child(Z_2,Z_3), ",NA,NA
 . ,NA,NA
 . ,NA,NA
" child(Z_17,Z_18). ",NA,NA
" child(Z_18,Z_19). ",NA,NA
" child(Z_19,Y).",NA,NA
 . ,NA,NA
This is not a particularly pleasant (or sensible) way to go!,NA,NA
But we don't need to do this at all. We can avoid having to use ever longer rules entirely. The ,NA,NA
following recursive rule fixes everything exactly the way we want: ,NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"descend(X,Y) :- child(X,Z), ",NA,NA
" descend(Z,Y).",NA,NA
What does this say? The declarative meaning of the base clause is: if ,NA,NA
Y,NA,NA
 is a child of ,NA,NA
X,NA,NA
", then ",NA,NA
Y ,NA,NA
is a descendant of ,NA,NA
X,NA,NA
. Obviously sensible.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node26.html (2 of 6)11/3/2006 7:28:39 PM,NA
So what about the recursive clause? It's declarative meaning is: if ,NA,NA
Z,NA,NA
 is a child of ,NA,NA
X,NA,NA
", and ",NA,NA
Y,NA,NA
 is a ,NA,NA
descendant of ,NA,NA
Z,NA,NA
", then ",NA,NA
Y,NA,NA
 is a descendant of ,NA,NA
X,NA,NA
". Again, this is obviously true.",NA,NA
"So let's now look at the procedural meaning of this recursive predicate, by stepping through ",NA,NA
an example. What happens when we pose the query: ,NA,NA
"descend(martha,laura)",NA,NA
Prolog first tries the first rule. The variable ,NA,NA
X,NA,NA
 in the head of the rule is unified with ,NA,NA
martha ,NA,NA
and ,NA,NA
Y,NA,NA
 with laura and the next goal Prolog tries to prove is ,NA,NA
"child(martha,laura)",NA,NA
"This attempt fails, however, since the knowledge base neither contains the fact ",NA,NA
child ,NA,NA
"(martha,laura)",NA,NA
 nor any rules that would allow to infer it. So Prolog backtracks and looks for ,NA,NA
an alternative way of proving ,NA,NA
"descend(martha,laura)",NA,NA
. It finds the second rule in the ,NA,NA
knowledge base and now has the following subgoals: ,NA,NA
"child(martha,_633), ",NA,NA
"descend(_633,laura).",NA,NA
Prolog takes the first subgoal and tries to match it onto something in the knowledge base. It ,NA,NA
finds the fact ,NA,NA
"child(martha,charlotte)",NA,NA
 and the Variable ,NA,NA
_633,NA,NA
 gets instantiated to ,NA,NA
charlotte,NA,NA
. ,NA,NA
"Now that the first subgoal is satisfied, Prolog moves to the second subgoal. It has to prove ",NA,NA
"descend(charlotte,laura)",NA,NA
This is the recursive call of the predicate ,NA,NA
descend/2,NA,NA
". As before, Prolog starts with the first ",NA,NA
"rule, but fails, because the goal ",NA,NA
"child(charlotte,laura)",NA,NA
"cannot be proved. Backtracking, Prolog finds that there is a second possibility to be checked ",NA,NA
for ,NA,NA
"descend(charlotte,laura)",NA,NA
", viz. the second rule, which again gives Prolog two new subgoals: ",NA,NA
"child(charlotte,_1785), ",NA,NA
"descend(_1785,laura).",NA,NA
The first subgoal can be unified with the fact ,NA,NA
"child(charlotte,caroline)",NA,NA
 of the ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node26.html (3 of 6)11/3/2006 7:28:39 PM,NA
"knowledge base, so that the variable ",NA,NA
_1785,NA,NA
 is instantiated with ,NA,NA
caroline,NA,NA
. Next Prolog tries to ,NA,NA
prove ,NA,NA
"descend(caroline,laura).",NA,NA
This is the second recursive call of predicate ,NA,NA
descend/2,NA,NA
". As before, it tries the first rule first, ",NA,NA
obtaining the following new goal: ,NA,NA
"child(caroline,laura)",NA,NA
"This time Prolog succeeds, since ",NA,NA
"child(caroline,laura)",NA,NA
 is a fact in the database. Prolog has ,NA,NA
found a proof for the goal ,NA,NA
"descend(caroline,laura)",NA,NA
 (the second recursive call). But this means ,NA,NA
that ,NA,NA
"child(charlotte,laura)",NA,NA
" (the first recursive call) is also true, which means that our original ",NA,NA
query ,NA,NA
"descend(martha,laura)",NA,NA
 is true as well.,NA,NA
Here is the search tree for the query ,NA,NA
"descend(martha,laura)",NA,NA
. Make sure that you understand ,NA,NA
how it relates to the discussion in the text; i.e. how Prolog traverses this search tree when ,NA,NA
trying to prove this query.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node26.html (4 of 6)11/3/2006 7:28:39 PM,NA
It should be obvious from this example that no matter how many generations of children we ,NA,NA
"add, we will always be able to work out the descendant relation. That is, the recursive ",NA,NA
"definition is both general and compact: it contains all the information in the previous rules, and ",NA,NA
"much more besides. In particular, the previous lists of non-recursive rules only defined the ",NA,NA
descendant concept up to some fixed number of generations: we would need to write down ,NA,NA
"infinitely many non-recursive rules if we wanted to capture this concept fully, and of course ",NA,NA
"that's impossible. But, in effect, that's what the recursive rule does for us: it bundles up all this ",NA,NA
information into just three lines of code. ,NA,NA
Recursive rules are really important. They enable to pack an enormous amount of information ,NA,NA
into a compact form and to define predicates in a natural way. Most of the work you will do as ,NA,NA
a Prolog programmer will involve writing recursive rules.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node26.html (6 of 6)11/3/2006 7:28:39 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
3.1.3 Example 3: Successor,NA,NA
In the previous lectures we remarked that building structure through matching is a key idea in ,NA,NA
"Prolog programming. Now that we know about recursion, we can give more interesting ",NA,NA
illustrations of this.,NA,NA
"Nowadays, when human beings write numerals, they usually use decimal notation (0, 1, 2, 3, ",NA,NA
"4, 5, 6, 7, 8, 9, 10, 11, 12, and so on) but as you probably know, there are many other ",NA,NA
"notations. For example, because computer hardware is generally based on digital circuits, ",NA,NA
"computers usually use binary notation to represent numerals (0, 1, 10, 11, 100, 101, 110, 111, ",NA,NA
"1000, and so on), for the 0 can be implemented as as switch being off, the 1 as a switch being ",NA,NA
"on. Other cultures use different systems. For example, the ancient Babylonians used a base 64 ",NA,NA
"system, while the ancient Romans used a rather ad-hoc system (I, II, III, IV, V, VI, VII, VIII, ",NA,NA
"IX, X). This last example shows that notational issues can be important. If you don't believe ",NA,NA
"this, try figuring out a systematic way of doing long-division in Roman notation. As you'll ",NA,NA
"discover, it's a frustrating task. In fact, the Romans had a group of professionals (analogs of ",NA,NA
modern accountants) who specialized in this.,NA,NA
"Well, here's yet another way of writing numerals, which is sometimes used in mathematical ",NA,NA
"logic. It makes use of just four symbols: 0, succ, and the left and right brackets. This style of ",NA,NA
numeral is defined by the following inductive definition: ,NA,NA
1.  0 is a numeral. ,NA,NA
"2.  If X is a numeral, then so is succ(X).",NA,NA
"As is probably clear, succ can be read as short for successor. That is, succ(X) represents the ",NA,NA
number obtained by adding one to the number represented by X. So this is a very simple ,NA,NA
"notation: it simply says that 0 is a numeral, and that all other numerals are built by stacking ",NA,NA
"succ symbols in front. (In fact, it's used in mathematical logic because of this simplicity. ",NA,NA
"Although it wouldn't be pleasant to do household accounts in this notation, it is a very easy ",NA,NA
"notation to prove things about.) Now, by this stage it should be clear that we can turn this ",NA,NA
definition into a Prolog program. The following knowledge base does this: ,NA,NA
numeral(0). ,NA,NA
numeral(succ(X)) :- numeral(X).,NA,NA
So if we pose queries like ,NA,NA
numeral(succ(succ(succ(0)))).,NA,NA
we get the answer `yes'. But we can do some more interesting things. Consider what happens ,NA,NA
when we pose the following query: ,NA,NA
numeral(X).,NA,NA
"That is, we're saying `Ok, show me some numerals'. Then we can have the following dialogue ",NA,NA
with Prolog: ,NA,NA
X = 0 ; ,NA,NA
X = succ(0) ; ,NA,NA
X = succ(succ(0)) ; ,NA,NA
X = succ(succ(succ(0))) ; ,NA,NA
X = succ(succ(succ(succ(0)))) ; ,NA,NA
X = succ(succ(succ(succ(succ(0))))) ; ,NA,NA
X = succ(succ(succ(succ(succ(succ(0)))))) ; ,NA,NA
X = succ(succ(succ(succ(succ(succ(succ(0))))))) ; ,NA,NA
X = succ(succ(succ(succ(succ(succ(succ(succ(0)))))))) ; X = ,NA,NA
succ(succ(succ(succ(succ(succ(succ(succ(succ ,NA,NA
(0))))))))) ; ,NA,NA
X = succ(succ(succ(succ(succ(succ(succ(succ(succ(succ (0)))))))))) ,NA,NA
yes,NA,NA
"Yes, Prolog is counting: but what's really important is how it's doing this. Quite simply, it's ",NA,NA
"backtracking through the recursive definition, and actually building numerals using matching. ",NA,NA
"This is an instructive example, and it is important that you understand it. The best way to do ",NA,NA
"so is to sit down and try it out, with ",NA,NA
trace,NA,NA
 turned on.,NA,NA
"Building and binding. Recursion, matching, and proof search. These are ideas that lie at the ",NA,NA
heart of Prolog programming. Whenever we have to generate or analyze recursively structured ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node27.html (2 of 3)11/3/2006 7:28:45 PM,NA
objects (such as these numerals) the interplay of these ideas makes Prolog a powerful tool. ,NA,NA
"For example, in the next lecture we introduce lists, an extremely important recursive data ",NA,NA
"structure, and we will see that Prolog is a natural list processing language. Many applications ",NA,NA
(computational linguistics is a prime example) make heavy use of recursively structured ,NA,NA
"objects, such as trees and feature structures. So it's not particularly surprising that Prolog has ",NA,NA
proved useful in such applications.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
3.1.4 Example 3: Addition,NA,NA
"As a final example, let's see whether we can use the representation of numerals that we ",NA,NA
introduced in the previous section for doing simple arithmetic. Let's try to define addition. That ,NA,NA
"is, we want to define a predicate ",NA,NA
add/3,NA,NA
 which when given two numerals as the first and ,NA,NA
second argument returns the result of adding them up as its third argument. E.g. ,NA,NA
"?- add(succ(succ(0)),succ(succ(0)),succ(succ(succ(succ (0))))). ",NA,NA
yes ,NA,NA
"?- add(succ(succ(0)),succ(0),Y). ",NA,NA
Y = succ(succ(succ(0))),NA,NA
There are two things which are important to notice: ,NA,NA
1.  Whenever the first argument is ,NA,NA
0,NA,NA
", the third argument has to be the same as the second ",NA,NA
argument: ,NA,NA
"?- add(0,succ(succ(0)),Y). ",NA,NA
Y = succ(succ(0)) ,NA,NA
"?- add(0,0,Y). ",NA,NA
Y = 0,NA,NA
This is the case that we want to use for the base clause.,NA,NA
2.  Assume that we want to add the two numerals ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 (e.g. ,NA,NA
succ(succ(succ(0))) ,NA,NA
and ,NA,NA
succ(succ(0)),NA,NA
) and that ,NA,NA
X,NA,NA
 is not ,NA,NA
0,NA,NA
". Now, if ",NA,NA
X',NA,NA
 is the numeral that has one ,NA,NA
succ,NA,NA
 functor ,NA,NA
less than ,NA,NA
X,NA,NA
 (i.e. ,NA,NA
succ(succ(0)),NA,NA
 in our example) and if we know the result -- let's call it ,NA,NA
Z,NA,NA
 -,NA,NA
- of adding ,NA,NA
X',NA,NA
 and ,NA,NA
Y,NA,NA
 (namely ,NA,NA
succ(succ(succ(succ(0)))),NA,NA
"), then it is very easy to compute ",NA,NA
the result of adding ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
: we just have to add one ,NA,NA
succ,NA,NA
-functor to ,NA,NA
Z,NA,NA
. This is what we ,NA,NA
want to express with the recursive clause.,NA,NA
Here is the predicate definition that expresses exactly what we just said: ,NA,NA
"add(0,Y,Y). ",NA,NA
"add(succ(X),Y,succ(Z)) :- ",NA,NA
" add(X,Y,Z).",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node28.html (1 of 3)11/3/2006 7:28:52 PM,NA
"So, what happens, if we give Prolog this predicate definition and then ask: ",NA,NA
"add(succ(succ(succ(0))), succ(succ(0)), R)",NA,NA
Let's go through the way Prolog processes this query step by step. The trace and the search ,NA,NA
tree are given below.,NA,NA
The first argument is not ,NA,NA
0,NA,NA
 which means that only the second clause for ,NA,NA
add,NA,NA
 matches. This ,NA,NA
leads to a recursive call of ,NA,NA
add,NA,NA
. The outermost ,NA,NA
succ,NA,NA
 functor is stripped off the first argument ,NA,NA
"of the original query, and the result becomes the first argument of the recursive query. The ",NA,NA
"second argument is just passed on to the recursive query, and the third argument of the ",NA,NA
"recursive query is a variable, the internal variable ",NA,NA
_G648,NA,NA
 in the trace given below. ,NA,NA
_G648,NA,NA
 is not ,NA,NA
"instantiated, yet. However, it is related to ",NA,NA
R,NA,NA
 (which is the variable that we had as third ,NA,NA
"argument in the original query), because ",NA,NA
R,NA,NA
 was instantiated to ,NA,NA
succ(_G648),NA,NA
", when the query ",NA,NA
was matched to the head of the second clause. But that means that ,NA,NA
R,NA,NA
 is not a ,NA,NA
"completely uninstantiated variable anymore. It is now a complex term, that has a ",NA,NA
(uninstantiated) variable as its argument.,NA,NA
The next two steps are essentially the same. With every step the first argument becomes one ,NA,NA
level smaller. The trace and the search tree show this nicely. At the same time one ,NA,NA
succ ,NA,NA
functor is added to ,NA,NA
R,NA,NA
" with every step, but always leaving the argument of the innermost ",NA,NA
variable uninstantiated. After the first recursive call ,NA,NA
R,NA,NA
 is ,NA,NA
succ(_G648),NA,NA
", in the second recursive ",NA,NA
call ,NA,NA
_G648,NA,NA
 is instantiated with ,NA,NA
succ(_G650),NA,NA
", so that ",NA,NA
R,NA,NA
 is ,NA,NA
succ(succ(_G650),NA,NA
", in the third recursive ",NA,NA
call ,NA,NA
_G650,NA,NA
 is instantiated with ,NA,NA
succ(_G652),NA,NA
 and ,NA,NA
R,NA,NA
 therefore becomes ,NA,NA
succ(succ(succ(_G652))),NA,NA
. ,NA,NA
The search tree shows this step by step instantiation.,NA,NA
At some point all ,NA,NA
succ,NA,NA
 functors have been stripped off the first argument and we have ,NA,NA
"reached the base clause. Here, the third argument is equated with the second argument, so ",NA,NA
"that ""the hole"" in the complex term ",NA,NA
R,NA,NA
 is finally filled. ,NA,NA
This is a trace for the query ,NA,NA
"add(succ(succ(succ(0))), succ(succ(0)), R)",NA,NA
: ,NA,NA
"Call: (6) add(succ(succ(succ(0))), succ(succ(0)), R) ",NA,NA
"Call: (7) add(succ(succ(0)), succ(succ(0)), _G648) ",NA,NA
"Call: (8) add(succ(0), succ(succ(0)), _G650) ",NA,NA
"Call: (9) add(0, succ(succ(0)), _G652) ",NA,NA
"Exit: (9) add(0, succ(succ(0)), succ(succ(0))) ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node28.html (2 of 3)11/3/2006 7:28:52 PM,NA
"Exit: (8) add(succ(0), succ(succ(0)), succ(succ(succ(0)))) Exit: (7) ",NA,NA
"add(succ(succ(0)), succ(succ(0)), succ(succ(succ (succ(0))))) ",NA,NA
"Exit: (6) add(succ(succ(succ(0))), succ(succ(0)), succ(succ (succ(succ(succ(0))))))",NA,NA
And here is the search tree for this query:,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node28.html (3 of 3)11/3/2006 7:28:52 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
"3.2 Clause ordering, goal ordering, and termination",NA,NA
Prolog was the first reasonably successful attempt to make a logic programming language. ,NA,NA
Underlying logic programming is a simple (and seductive) vision: the task of the programmer is ,NA,NA
simply to describe problems. The programmer should write down (in the language of logic) a ,NA,NA
"declarative specification (that is: a knowledge base), which describes the situation of interest. ",NA,NA
"The programmer shouldn't have to tell the computer what to do. To get information, he or she ",NA,NA
simply asks the questions. It's up to the logic programming system to figure out how to get the ,NA,NA
answer.,NA,NA
"Well, that's the idea, and it should be clear that Prolog has taken some interesting steps in this ",NA,NA
"direction. But Prolog is not, repeat not, a full logic programming language. If you only think ",NA,NA
"about the declarative meaning of a Prolog program, you are in for a very tough time. As we ",NA,NA
"learned in the previous lecture, Prolog has a very specific way of working out the answer to ",NA,NA
"queries: it searches the knowledge base from top to bottom, clauses from left to right, and ",NA,NA
uses backtracking to recover from bad choices. These procedural aspects have an important ,NA,NA
influence on what actually happens when you make a query. We have already seen a dramatic ,NA,NA
example of a mismatch between procedural and declarative meaning of a knowledge base ,NA,NA
(remember the ,NA,NA
p:- p,NA,NA
" program?), and as we shall now see, it is easy to define knowledge bases ",NA,NA
"with the same declarative meaning, but very different procedural meanings.",NA,NA
Recall our earlier descendant program (let's call it ,NA,NA
descend1.pl,NA,NA
): ,NA,NA
"child(martha,charlotte). ",NA,NA
"child(charlotte,caroline). ",NA,NA
"child(caroline,laura). ",NA,NA
"child(laura,rose). ",NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"descend(X,Y) :- child(X,Z), ",NA,NA
" descend(Z,Y).",NA,NA
"We'll make two changes to it, and call the result ",NA,NA
descend2.pl,NA,NA
: ,NA,NA
"child(martha,charlotte). ",NA,NA
"child(charlotte,caroline). ",NA,NA
"child(caroline,laura). ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node29.html (1 of 3)11/3/2006 7:28:57 PM,NA
"child(laura,rose). ",NA,NA
"descend(X,Y) :- descend(Z,Y), ",NA,NA
" child(X,Z).           ",NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"From a declarative perspective, what we have done is very simple: we have merely reversed ",NA,NA
"the order of the two rules, and reversed the order of the two goals in the recursive clause. So, ",NA,NA
"viewed as a purely logical definition, nothing has changed. We have not changed the ",NA,NA
declarative meaning of the program.,NA,NA
"But the procedural meaning has changed dramatically. For example, if you pose the query ",NA,NA
"descend(martha,rose).",NA,NA
"you will get an error message (`out of local stack', or something similar). Prolog is looping. ",NA,NA
"Why? Well, to satisfy the query ",NA,NA
"descend(martha,rose).",NA,NA
 Prolog uses the first rule. This means ,NA,NA
that its next goal will be to satisfy the query ,NA,NA
"descend(W1,rose) ",NA,NA
for some new variable ,NA,NA
W1,NA,NA
". But to satisfy this new goal, Prolog again has to use the first rule, ",NA,NA
and this means that its next goal is going to be ,NA,NA
"descend(W2,rose) ",NA,NA
for some new variable ,NA,NA
W2,NA,NA
". And of course, this in turn means that its next goal is going to be ",NA,NA
"descend(W3,rose)",NA,NA
 and then ,NA,NA
"descend(W4,rose)",NA,NA
", and so on. ",NA,NA
"In short, ",NA,NA
descend1.pl,NA,NA
 and ,NA,NA
descend2.pl,NA,NA
 are Prolog knowledge bases with the same declarative ,NA,NA
meaning but different procedural meanings: from a purely logical perspective they are ,NA,NA
"identical, but they behave very differently.",NA,NA
Let's look at another example. Recall out earlier successor program (let's call it ,NA,NA
numeral1.,NA,NA
pl,NA,NA
): ,NA,NA
numeral(0). ,NA,NA
numeral(succ(X)) :- numeral(X).,NA,NA
"Let's simply swap the order of the two clauses, and call the result ",NA,NA
numeral2.pl,NA,NA
: ,NA,NA
numeral(succ(X)) :- numeral(X). ,NA,NA
numeral(0).,NA,NA
"Clearly the declarative, or logical, content of this program is exactly the same as the earlier ",NA,NA
version. But what about its behavior?,NA,NA
"Ok, if we pose a query about specific numerals, ",NA,NA
numeral2.pl,NA,NA
 will terminate with the answer we ,NA,NA
"expect. For example, if we ask: ",NA,NA
numeral(succ(succ(succ(0)))).,NA,NA
"we will get the answer `yes'. But if we try to generate numerals, that is, if we give it the query ",NA,NA
numeral(X).,NA,NA
"the program won't halt. Make sure you understand why not. Once again, we have two ",NA,NA
knowledge bases with the same declarative meaning but different procedural meanings.,NA,NA
"Because the declarative and procedural meanings of a Prolog program can differ, when writing ",NA,NA
Prolog programs you need to bear both aspects in mind. Often you can get the overall idea ,NA,NA
"(`the big picture') of how to write the program by thinking declaratively, that is, by thinking ",NA,NA
simply in terms of describing the problem accurately. But then you need to think about how ,NA,NA
Prolog will actually evaluate queries. Are the rule orderings sensible? How will the program ,NA,NA
actually run? Learning to flip back and forth between procedural and declarative questions is an ,NA,NA
important part of learning to program in Prolog.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
3.3 Exercises,NA,NA
Exercise 3.1,NA,NA
"Do you know these wooden Russian dolls, where smaller ones are contained in ",NA,NA
bigger ones? Here is schematic picture of such dolls. ,NA,NA
"First, write a knowledge base using the predicate ",NA,NA
directlyIn/2,NA,NA
 which encodes ,NA,NA
"which doll is directly contained in which other doll. Then, define a (recursive) ",NA,NA
predicate ,NA,NA
in/2,NA,NA
", that tells us which doll is (directly or indirectly) contained in which ",NA,NA
other doll. E.g. the query ,NA,NA
"in(katarina,natasha)",NA,NA
" should evaluate to true, while ",NA,NA
"in(olga, katarina)",NA,NA
 should fail.,NA,NA
Exercise 3.2,NA,NA
Define a predicate ,NA,NA
greater_than/2,NA,NA
 that takes two numerals in the notation that we ,NA,NA
"introduced in this lecture (i.e. 0, succ(0), succ(succ(0)) ...) as arguments and ",NA,NA
decides whether the first one is greater than the second one. E.g: ,NA,NA
"?- greater_than(succ(succ(succ(0))),succ(0)). ",NA,NA
yes ,NA,NA
"?- greater_than(succ(succ(0)),succ(succ(succ(0)))). ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node30.html (1 of 3)11/3/2006 7:29:08 PM,NA
no,NA,NA
Exercise 3.3,NA,NA
Binary trees are trees where all internal nodes have exactly two childres. The ,NA,NA
smalles binary trees consist of only one leaf node. We will represent leaf nodes as ,NA,NA
leaf(Label),NA,NA
". For instance, ",NA,NA
leaf(3),NA,NA
 and ,NA,NA
leaf(7),NA,NA
" are leaf nodes, and therefore small ",NA,NA
binary trees. Given two binary trees ,NA,NA
B1,NA,NA
 and ,NA,NA
B2,NA,NA
 we can combine them into one ,NA,NA
binary tree using the predicate ,NA,NA
tree,NA,NA
: ,NA,NA
"tree(B1,B2)",NA,NA
". So, from the leaves ",NA,NA
leaf(1),NA,NA
 and ,NA,NA
leaf(2),NA,NA
 we can build the binary tree ,NA,NA
tree(leaf ,NA,NA
"(1), leaf(2))",NA,NA
. And from the binary trees ,NA,NA
"tree(leaf(1), leaf(2))",NA,NA
 and ,NA,NA
leaf(4),NA,NA
 we can ,NA,NA
build the binary tree ,NA,NA
"tree(tree(leaf(1), leaf ",NA,NA
"(2)), leaf(4))",NA,NA
. ,NA,NA
"Now, define a predicate ",NA,NA
swap/2,NA,NA
", which produces a mirror image of the binary ",NA,NA
tree that is its first argument. For example: ,NA,NA
"?- swap(tree(tree(leaf(1), leaf(2)), leaf(4)),T). T = tree(leaf(4), ",NA,NA
"tree(leaf(2), leaf(1))). ",NA,NA
yes,NA,NA
Exercise 3.4,NA,NA
"In the lecture, we saw the predicate ",NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"descend(X,Y) :- child(X,Z), ",NA,NA
" descend(Z,Y).",NA,NA
Could we have formulated this predicate as follows? ,NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"descend(X,Y) :- descend(X,Z), ",NA,NA
" descend(Z,Y).",NA,NA
Compare the declarative and the procedural meaning of this predicate definition.,NA,NA
Hint: What happens when you ask the query ,NA,NA
"descend(rose,martha)",NA,NA
?,NA,NA
Exercise 3.5,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node30.html (2 of 3)11/3/2006 7:29:08 PM,NA
We have the following knowledge base: ,NA,NA
"directTrain(forbach,saarbruecken). ",NA,NA
"directTrain(freyming,forbach). ",NA,NA
"directTrain(fahlquemont,stAvold). ",NA,NA
"directTrain(stAvold,forbach). ",NA,NA
"directTrain(saarbruecken,dudweiler). ",NA,NA
"directTrain(metz,fahlquemont). ",NA,NA
"directTrain(nancy,metz).",NA,NA
"That is, this knowledge base holds facts about towns it is possible to travel ",NA,NA
"between by taking a direct train. But of course, we can travel further by ",NA,NA
`chaining together' direct train journeys. Write a recursive predicate ,NA,NA
travelBetween/2,NA,NA
 that tells us when we can travel by train between two ,NA,NA
"towns. For example, when given the query ",NA,NA
"travelBetween(nancy,saarbruecken).",NA,NA
it should reply `yes'.,NA,NA
"It is, furthermore, plausible to assume that whenever it is possible to take a direct ",NA,NA
"train from A to B, it is also possible to take a direct train from B to A. Can you ",NA,NA
encode this in Prolog? You program should e.g. answer `yes' to the following ,NA,NA
query: ,NA,NA
"travelBetween(saarbruecken,nancy).",NA,NA
Do you see any problems you program may run into?,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
3.4 Practical Session 3,NA,NA
"By now, you should feel more at home with writing and runnning basic Prolog programs. The ",NA,NA
"purpose of Practical Session 3 is twofold. First we suggest a series of keyboard exercises, ",NA,NA
involving ,NA,NA
trace,NA,NA
", which will help you get familiar with recursive definitions in Prolog. We then ",NA,NA
give a number of programming problems for you to solve.,NA,NA
"First the keyboard exercises. As recursive programming is so fundamental to Prolog, it is ",NA,NA
"important that you have a firm grasp of what it involves. In particular, it is important that you ",NA,NA
"understand the process of variable instantiation when recursive definitions are used, and that ",NA,NA
"you understand why both the order of the clauses in a recursive definition, and the order of ",NA,NA
"goals in rules, can make the difference between a knowledge base that is useful and one that ",NA,NA
does not work at all. So: ,NA,NA
1.  Load ,NA,NA
descend1.pl,NA,NA
", turn on ",NA,NA
trace,NA,NA
", and pose the query ",NA,NA
"descend(martha,laura)",NA,NA
. ,NA,NA
"This is the query that was discussed in the notes. Step through the trace, and relate ",NA,NA
what you see on the screen to the discussion in the text. ,NA,NA
2.  Still with ,NA,NA
trace,NA,NA
" on, pose the query ",NA,NA
"descend(martha,rose)",NA,NA
 and count how many steps it ,NA,NA
"takes Prolog to work out the answer (that is, how many times do you have to hit the ",NA,NA
return key). Now turn ,NA,NA
trace,NA,NA
 off and pose the query ,NA,NA
"descend(X,Y)",NA,NA
. How many answers ,NA,NA
are there? ,NA,NA
3.  Load ,NA,NA
descend2.pl,NA,NA
". This, remember, is the variant of ",NA,NA
descend1.pl,NA,NA
 in which the order of ,NA,NA
"both clauses is switched, and in addition, the order of the two goals in the recursive ",NA,NA
"goals is switched too. Because of this, even for such simple queries as ",NA,NA
"descend(martha,laura)",NA,NA
", Prolog will not terminate. Step through an example, using ",NA,NA
trace,NA,NA
", ",NA,NA
to confirm this. ,NA,NA
4.  But wait! There are two more variants of ,NA,NA
descend1.pl,NA,NA
 that we have not considered. ,NA,NA
"For a start, we could have written the recursive clause as follows: ",NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"descend(X,Y) :- descend(Z,Y), ",NA,NA
" child(X,Z).",NA,NA
Let us call this variant ,NA,NA
descend3.pl,NA,NA
. And one further possibility remains: we could ,NA,NA
have written the recursive definition as follows: ,NA,NA
"descend(X,Y) :- child(X,Z), ",NA,NA
" descend(Z,Y). ",NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
Let us call this variant ,NA,NA
descend4.pl,NA,NA
.,NA,NA
Create (or download from the internet) the files ,NA,NA
descend3.pl,NA,NA
 and ,NA,NA
descend4.pl,NA,NA
. ,NA,NA
How do they compare to ,NA,NA
descend1.pl,NA,NA
 and ,NA,NA
descend2.pl,NA,NA
? Can they handle the query ,NA,NA
"descend(martha,rose)",NA,NA
? Can they handle queries involving variables? How many steps do ,NA,NA
they need to find an answer? Are they slower or faster than ,NA,NA
descend1. pl,NA,NA
?,NA,NA
Draw the search trees for ,NA,NA
descend2.pl,NA,NA
", ",NA,NA
descend3.pl,NA,NA
 and ,NA,NA
descend4.pl,NA,NA
 (the one for ,NA,NA
descend1.pl,NA,NA
 was given in the text) and compare them. Make sure you understand why ,NA,NA
the programs behave the way they do.,NA,NA
"5.  Finally, load the file ",NA,NA
numeral1.pl,NA,NA
. Turn on ,NA,NA
trace,NA,NA
", and make sure that you understand ",NA,NA
how Prolog handles both specific queries (such as ,NA,NA
numeral(succ(succ (0))),NA,NA
) and ,NA,NA
queries involving variables (such as ,NA,NA
numeral(X),NA,NA
).,NA,NA
"Now for some programming. We are now at the end of the third session, which means we have ",NA,NA
"covered about a quarter of the material we are going to. Moreover, the material we have ",NA,NA
"covered so far is the basis for everything that follows, so it is vital that you understand it ",NA,NA
properly. And the only way to really get to grips with Prolog is to write programs (lots of ,NA,NA
"them!), run them, fix them when they don't work, and then write some more. Learning a ",NA,NA
programming language is a lot like learning a foreign language: you have to get out there and ,NA,NA
actually use it if you want to make genuine progress.,NA,NA
So here are some exercises for you to try your hand on. ,NA,NA
1.  Imagine that the following knowledge base describes a maze. The facts determine which ,NA,NA
"points are connected, i.e., from which point you can get to which other point in one ",NA,NA
"step. Furthermore, imagine that all paths are one-way streets, so that you can only walk ",NA,NA
"them in one direction. So, you can get from point 1 to point 2, but not the other way ",NA,NA
round. ,NA,NA
"connected(1,2). ",NA,NA
"connected(3,4). ",NA,NA
"connected(5,6). ",NA,NA
"connected(7,8). ",NA,NA
"connected(9,10). ",NA,NA
"connected(12,13). ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node31.html (2 of 4)11/3/2006 7:29:14 PM,NA
"connected(13,14). ",NA,NA
"connected(15,16). ",NA,NA
"connected(17,18). ",NA,NA
"connected(19,20). ",NA,NA
"connected(4,1). ",NA,NA
"connected(6,3). ",NA,NA
"connected(4,7). ",NA,NA
"connected(6,11). ",NA,NA
"connected(14,9). ",NA,NA
"connected(11,15). ",NA,NA
"connected(16,12). ",NA,NA
"connected(14,17). ",NA,NA
"connected(16,19).",NA,NA
Write a predicate ,NA,NA
path/2,NA,NA
 that tells you from which point in the maze you can get to ,NA,NA
which other point when chaining together connections given in the above knowledge ,NA,NA
base. Can you get from point 5 to point 10? Which other point can you get to when ,NA,NA
starting in point 1? And which points can be reached from point 13?,NA,NA
2.  We are given the following knowledge base of travel information: ,NA,NA
"byCar(auckland,hamilton). ",NA,NA
"byCar(hamilton,raglan). ",NA,NA
"byCar(valmont,saarbruecken). ",NA,NA
"byCar(valmont,metz). ",NA,NA
"byTrain(metz,frankfurt). ",NA,NA
"byTrain(saarbruecken,frankfurt). ",NA,NA
"byTrain(metz,paris). ",NA,NA
"byTrain(saarbruecken,paris). ",NA,NA
"byPlane(frankfurt,bangkok). ",NA,NA
"byPlane(frankfurt,singapore). ",NA,NA
"byPlane(paris,losAngeles). ",NA,NA
"byPlane(bangkok,auckland). ",NA,NA
"byPlane(losAngeles,auckland).",NA,NA
Write a predicate ,NA,NA
travel/2,NA,NA
 which determines whether it is possible to travel from one ,NA,NA
"place to another by `chaining together' car, train, and plane journeys. For example, your ",NA,NA
program should answer `yes' to the query ,NA,NA
"travel(valmont,raglan)",NA,NA
.,NA,NA
"3.  So, by using ",NA,NA
travel/2,NA,NA
" to query the above database, you can find out that it is possible ",NA,NA
"to go from Vamont to Raglan. In case you are planning a travel, that's already very good ",NA,NA
"information, but what you would then really want to know is how exactly to get from ",NA,NA
Valmont to Raglan. Write a predicate ,NA,NA
travel/3,NA,NA
 which tells you how to travel from one ,NA,NA
"place to another. The program should, e.g., answer `yes' to the query ",NA,NA
travel ,NA,NA
"(valmont,paris,go(valmont,metz,go(metz,paris)))",NA,NA
 and ,NA,NA
X = go ,NA,NA
"(valmont,metz,go(metz,paris,go(paris,losAngeles)))",NA,NA
 to the query ,NA,NA
"travel(valmont,losAngeles,X)",NA,NA
.,NA,NA
4.  Extend the predicate ,NA,NA
travel/3,NA,NA
 so that it not only tells you via which other cities you ,NA,NA
"have to go to get from one place to another, but also how, i.e. by car, train, or plane, ",NA,NA
you get from one city to the next.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
4 Lists ,NA,NA
This lecture has two main goals: ,NA,NA
"1.  To introduce lists, an important recursive data structure widely used in computational ",NA,NA
linguistics.,NA,NA
"2.  To define member, a fundamental Prolog tool for manipulating lists, and to introduce ",NA,NA
the idea of recursing down lists. ,G,NA
4.1 Lists ,G,NA
4.2 Member ,G,NA
4.3 Recursing down lists ,G,NA
4.4 Exercises ,G,NA
4.5 Practical Session 4,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
4.1 Lists,NA,NA
"As its name suggests, a list is just a plain old list of items. Slightly more precisely, it is a finite ",NA,NA
sequence of elements. Here are some examples of lists in Prolog: ,NA,NA
"[mia, vincent, jules, yolanda] ",NA,NA
"[mia, robber(honey_bunny), X, 2, mia] ",NA,NA
[] ,NA,NA
"[mia, [vincent, jules], [butch, girlfriend(butch)]] ",NA,NA
"[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]]",NA,NA
We can learn some important things from these examples. ,NA,NA
1.  We can specify lists in Prolog by enclosing the elements of the list in square brackets ,NA,NA
"(that is, the symbols ",NA,NA
[,NA,NA
 and ,NA,NA
],NA,NA
"). The elements are separated by commas. For example, ",NA,NA
our first example ,NA,NA
"[mia, vincent, jules, yolanda]",NA,NA
" is a list with four elements, namely ",NA,NA
mia,NA,NA
", ",NA,NA
vincent,NA,NA
", ",NA,NA
jules,NA,NA
", and ",NA,NA
yolanda,NA,NA
". The length of a list is the number of elements it has, so our ",NA,NA
first example is a list of length four.,NA,NA
"2.  From our second example, ",NA,NA
"[mia,robber(honey_bunny),X,2,mia]",NA,NA
", we learn that all sorts of ",NA,NA
Prolog objects can be elements of a list. The first element of this list is ,NA,NA
mia,NA,NA
", an atom; ",NA,NA
the second element is ,NA,NA
robber(honey_bunny),NA,NA
", a complex term; the third element is ",NA,NA
X,NA,NA
", a ",NA,NA
variable; the fourth element is ,NA,NA
2,NA,NA
", a number. Moreover, we also learn that the same ",NA,NA
"item may occur more than once in the same list: for example, the fifth element of this ",NA,NA
list is ,NA,NA
mia,NA,NA
", which is same as the first element.",NA,NA
"3.  The third example shows that there is a very special list, the empty list. The empty list ",NA,NA
(as its name suggests) is the list that contains no elements. What is the length of the ,NA,NA
"empty list? Zero, of course (for the length of a list is the number of members it ",NA,NA
"contains, and the empty list contains nothing).",NA,NA
4.  The fourth example teaches us something extremely important: lists can contain other ,NA,NA
"lists as elements. For example, the second element of ",NA,NA
"[mia, [vincent, jules], [butch,girlfriend(butch)]",NA,NA
is the list ,NA,NA
"[vincent,jules]",NA,NA
", and the third element is ",NA,NA
"[butch,girlfriend",NA,NA
(butch)]],NA,NA
". In short, lists are examples of recursive data structures: lists can be made out ",NA,NA
of lists. What is the length of the fourth list? The answer is: three. If you thought it was ,NA,NA
"five (or indeed, anything else) you're not thinking about lists in the right way. The ",NA,NA
elements of the list are the things between the outermost square brackets separated by ,NA,NA
commas. So this list contains three elements: the first element is ,NA,NA
mia,NA,NA
", the second ",NA,NA
element is ,NA,NA
"[vincent, jules]",NA,NA
", and the third element is ",NA,NA
"[butch, girlfriend (butch)]",NA,NA
.,NA,NA
5.  The last example mixes all these ideas together. We have here a list which contains the ,NA,NA
"empty list (in fact, it contains it twice), the complex term ",NA,NA
dead(zed),NA,NA
", two copies of the ",NA,NA
list ,NA,NA
"[2, [b, chopper]]",NA,NA
", and the variable ",NA,NA
Z,NA,NA
. Note that the third (and the last) elements are ,NA,NA
lists which themselves contain lists (namely ,NA,NA
"[b, chopper]",NA,NA
).,NA,NA
Now for a very important point. Any non-empty list can be thought of as consisting of two ,NA,NA
parts: the head and the tail. The head is simply the first item in the list; the tail is everything ,NA,NA
"else. Or more precisely, the tail is the list that remains when we take the first element away, i.",NA,NA
"e. the tail of a list is always a list again. For example, the head of ",NA,NA
" [mia, vincent, jules, yolanda]",NA,NA
is ,NA,NA
mia,NA,NA
 and the tail is ,NA,NA
" [vincent, jules, yolanda]",NA,NA
". Similarly, the head of ",NA,NA
"[[], dead(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]]",NA,NA
is ,NA,NA
[],NA,NA
", and the tail is ",NA,NA
"[dead(zed), [2,[b,chopper]],[],Z,[2,[b, chopper]]]",NA,NA
. And what are the head and ,NA,NA
the tail of the list ,NA,NA
[dead(zed)],NA,NA
"? Well, the head is the first element of the list, which is ",NA,NA
dead(zed),NA,NA
", ",NA,NA
"and the tail is the list that remains if we take the head away, which, in this case, is the empty ",NA,NA
list ,NA,NA
[],NA,NA
.,NA,NA
"Note that only non-empty lists have heads and tails. That is, the empty list contains no ",NA,NA
"internal structure. For Prolog, the empty list ",NA,NA
[],NA,NA
" is a special, particularly simple, list. ",NA,NA
Prolog has a special inbuilt operator ,NA,NA
|,NA,NA
 which can be used to decompose a list into its head and ,NA,NA
tail. It is very important to get to know how to use ,NA,NA
|,NA,NA
", for it is a key tool for writing Prolog list ",NA,NA
manipulation programs. ,NA,NA
The most obvious use of ,NA,NA
|,NA,NA
 is to extract information from lists. We do this by using ,NA,NA
|,NA,NA
 together ,NA,NA
"with matching. For example, to get hold of the head and tail of ",NA,NA
"[mia,vincent,jules, yolanda]",NA,NA
 we ,NA,NA
can pose the following query: ,NA,NA
"?- [Head| Tail] = [mia, vincent, jules, yolanda]. ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node33.html (2 of 5)11/3/2006 7:29:30 PM,NA
Head = mia ,NA,NA
"Tail = [vincent,jules,yolanda] ",NA,NA
yes ,NA,NA
"That is, the head of the list has become bound to ",NA,NA
Head,NA,NA
 and the tail of the list has become ,NA,NA
bound to ,NA,NA
Tail,NA,NA
. Note that there is nothing special about ,NA,NA
Head,NA,NA
 and ,NA,NA
Tail,NA,NA
", they are simply ",NA,NA
variables. We could just as well have posed the query: ,NA,NA
"?- [X|Y] = [mia, vincent, jules, yolanda]. ",NA,NA
X = mia ,NA,NA
"Y = [vincent,jules,yolanda] ",NA,NA
yes,NA,NA
"As we mentioned above, only non-empty lists have heads and tails. If we try to use ",NA,NA
|,NA,NA
 to pull ,NA,NA
[],NA,NA
 ,NA,NA
"apart, Prolog will fail: ",NA,NA
?- [X|Y] = []. ,NA,NA
no,NA,NA
"That is, Prolog treats ",NA,NA
[],NA,NA
 as a special list. This observation is very important. We'll see why ,NA,NA
later.,NA,NA
Let's look at some other examples. We can extract the head and tail of the following list just ,NA,NA
as we saw above: ,NA,NA
"?- [X|Y] = [[], dead(zed), [2, [b, chopper]], [], Z]. ",NA,NA
X = [] ,NA,NA
"Y = [dead(zed),[2,[b,chopper]],[],_7800] Z = _7800 ",NA,NA
yes,NA,NA
That is: the head of the list is bound to ,NA,NA
X,NA,NA
", the tail is bound to ",NA,NA
Y,NA,NA
. (We also get the information ,NA,NA
that Prolog has bound ,NA,NA
Z,NA,NA
 to the internal variable ,NA,NA
_7800,NA,NA
.),NA,NA
But we can can do a lot more with ,NA,NA
|,NA,NA
"; it really is a very flexible tool. For example, suppose we ",NA,NA
"wanted to know what the first two elements of the list were, and also the remainder of the list ",NA,NA
after the second element. Then we'd pose the following query: ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node33.html (3 of 5)11/3/2006 7:29:30 PM,NA
"?- [X,Y | W] = [[], dead(zed), [2, [b, chopper]], [], Z]. ",NA,NA
X = [] ,NA,NA
Y = dead(zed) ,NA,NA
"W = [[2,[b,chopper]],[],_8327] ",NA,NA
Z = _8327 ,NA,NA
yes,NA,NA
That is: the head of the list is bound to ,NA,NA
X,NA,NA
", the second element is bound to ",NA,NA
Y,NA,NA
", and the ",NA,NA
remainder of the list after the second element is bound to ,NA,NA
W,NA,NA
. ,NA,NA
W,NA,NA
 is the list that remains when ,NA,NA
"we take away the first two elements. So, ",NA,NA
|,NA,NA
 can not only be used to split a list into its head and ,NA,NA
"its tail, but we can in fact use it to split a list at any point. Left of the ",NA,NA
|,NA,NA
", we just have to ",NA,NA
"enumerate how many elements we want to take away from the beginning of the list, and right ",NA,NA
of the ,NA,NA
|,NA,NA
" we will then get what remains of the list. In this example, we also get the information ",NA,NA
that Prolog has bound ,NA,NA
Z,NA,NA
 to the internal variable ,NA,NA
_8327,NA,NA
.,NA,NA
This is a good time to introduce the anonymous variable. Suppose we were interested in ,NA,NA
getting hold of the second and fourth elements of the list: ,NA,NA
"[[], dead(zed), [2, [b, chopper]], [], Z].",NA,NA
"Now, we could find out like this: ",NA,NA
"?- [X1,X2,X3,X4 | Tail] = [[], dead ",NA,NA
"(zed), [2, [b, chopper]], [], Z]. ",NA,NA
X1 = [] ,NA,NA
X2 = dead(zed) ,NA,NA
"X3 = [2,[b,chopper]] ",NA,NA
X4 = [] ,NA,NA
Tail = [_8910] ,NA,NA
Z = _8910 ,NA,NA
yes,NA,NA
"OK, we have got the information we wanted: the values we are interested in are bound to the ",NA,NA
variables ,NA,NA
X2,NA,NA
 and ,NA,NA
X4,NA,NA
. But we've got a lot of other information too (namely the values bound to ,NA,NA
X1,NA,NA
", ",NA,NA
X3,NA,NA
 and ,NA,NA
Tail,NA,NA
"). And perhaps we're not interested in all this other stuff. If so, it's a bit silly ",NA,NA
having to explicitly introduce variables ,NA,NA
X1,NA,NA
", ",NA,NA
X3,NA,NA
 and ,NA,NA
Tail,NA,NA
" to deal with it. And in fact, there is a ",NA,NA
simpler way to obtain only the information we want: we can pose the following query instead: ,NA,NA
"?- [_,X,_,Y|_] = [[], dead(zed), [2, [b, chopper]], [], Z]. ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node33.html (4 of 5)11/3/2006 7:29:30 PM,NA
X = dead(zed) ,NA,NA
Y = [] ,NA,NA
Z = _9593 ,NA,NA
yes,NA,NA
The ,NA,NA
_,NA,NA
" symbol (that is, underscore) is the anonymous variable. We use it when we need to use a ",NA,NA
"variable, but we're not interested in what Prolog instantiates it to. As you can see in the above ",NA,NA
"example, Prolog didn't bother telling us what ",NA,NA
_,NA,NA
" was bound to. Moreover, note that each ",NA,NA
occurrence of ,NA,NA
_,NA,NA
 is independent: each is bound to something different. This couldn't happen with ,NA,NA
"an ordinary variable of course, but then the anonymous variable isn't meant to be ordinary. It's ",NA,NA
"simply a way of telling Prolog to bind something to a given position, completely independently ",NA,NA
of any other bindings.,NA,NA
Let's look at one last example. The third element of our working example is a list (namely ,NA,NA
"[2, ",NA,NA
"[b, chopper]]",NA,NA
"). Suppose we wanted to extract the tail of this internal list, and that we are not ",NA,NA
interested in any other information. How could we do this? As follows: ,NA,NA
"?- [_,_,[_|X]|_] = ",NA,NA
" [[], dead ",NA,NA
"(zed), [2, [b, chopper]], [], Z, [2, [b, chopper]]]. ",NA,NA
"X = [[b,chopper]] ",NA,NA
Z = _10087 ,NA,NA
yes,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
4.2 Member,NA,NA
It's time to look at our first example of a Prolog program for manipulating lists. One of the ,NA,NA
most basic things we would like to know is whether something is an element of a list or not. ,NA,NA
"So let's write a program that, when given as inputs an arbitrary object X and a list L, tells us ",NA,NA
"whether or not X belongs to L. The program that does this is usually called member, and it is ",NA,NA
the simplest example of a Prolog program that exploits the recursive structure of lists. Here it ,NA,NA
is: ,NA,NA
"member(X,[X|T]). ",NA,NA
"member(X,[H|T]) :- member(X,T).",NA,NA
That's all there is to it: one fact (namely ,NA,NA
"member(X,[X|T])",NA,NA
) and one rule (namely ,NA,NA
member ,NA,NA
"(X,[H|T]) :- member(X,T)",NA,NA
"). But note that the rule is recursive (after all, the functor ",NA,NA
member,NA,NA
 ,NA,NA
occurs in both the rule's head and tail) and it is this that explains why such a short program is ,NA,NA
all that is required. Let's take a closer look.,NA,NA
"We'll start by reading the program declaratively. And read this way, it is obviously sensible. ",NA,NA
The first clause (the fact) simply says: an object ,NA,NA
X,NA,NA
 is a member of a list if it is the head of that ,NA,NA
list. Note that we used the inbuilt ,NA,NA
|,NA,NA
 operator to state this (simple but important) principle about ,NA,NA
lists.,NA,NA
"What about the second clause, the recursive rule? This says: an object ",NA,NA
X,NA,NA
 is member of a list if ,NA,NA
"it is a member of the tail of the list. Again, note that we used the ",NA,NA
|,NA,NA
 operator to state this ,NA,NA
principle.,NA,NA
"Now, clearly this definition makes good declarative sense. But does this program actually do ",NA,NA
"what it is supposed to do? That is, will it really tell us whether an object ",NA,NA
X,NA,NA
 belongs to a list ,NA,NA
L,NA,NA
? ,NA,NA
"And if so, how exactly does it do this? To answer such questions, we need to think about its ",NA,NA
procedural meaning. Let's work our way through a few examples.,NA,NA
Suppose we posed the following query: ,NA,NA
"?- member(yolanda,[yolanda,trudy,vincent,jules]).",NA,NA
Prolog will immediately answer `Yes'. Why? Because it can unify ,NA,NA
yolanda,NA,NA
 with both ,NA,NA
occurrences of ,NA,NA
X,NA,NA
 in the first clause (the fact) in the definition of ,NA,NA
member/2,NA,NA
", so it succeeds ",NA,NA
immediately.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node34.html (1 of 4)11/3/2006 7:29:47 PM,NA
Now consider the following query: ,NA,NA
"?- member(vincent,[yolanda,trudy,vincent,jules]).",NA,NA
Now the first rule won't help (,NA,NA
vincent,NA,NA
 and ,NA,NA
yolanda,NA,NA
 are distinct atoms) so Prolog goes to the ,NA,NA
"second clause, the recursive rule. This gives Prolog a new goal: it now has to see if ",NA,NA
"member(vincent,[trudy,vincent,jules]).",NA,NA
"Now, once again the first clause won't help, so Prolog goes (again) to the recursive rule. This ",NA,NA
"gives it a new goal, namely ",NA,NA
"member(vincent,[vincent,jules]).",NA,NA
"This time, the first clause does help, and the query succeeds.",NA,NA
"So far so good, but we need to ask an important question. What happens when we pose a ",NA,NA
"query that fails? For example, what happens if we pose the query ",NA,NA
"member(zed,[yolanda,trudy,vincent,jules]).",NA,NA
"Now, this should obviously fail (after all, ",NA,NA
zed,NA,NA
 is not on the list). So how does Prolog handle ,NA,NA
"this? In particular, how can we be sure that Prolog really will stop, and say no, instead going ",NA,NA
into an endless recursive loop?,NA,NA
"Let's think this through systematically. Once again, the first clause cannot help, so Prolog uses ",NA,NA
"the recursive rule, which gives it a new goal ",NA,NA
"member(zed,[trudy,vincent,jules]).",NA,NA
"Again, the first clause doesn't help, so Prolog reuses the recursive rule and tries to show that ",NA,NA
"member(zed,[vincent,jules]).",NA,NA
"Similarly, the first rule doesn't help, so Prolog reuses the second rule yet again and tries the ",NA,NA
goal ,NA,NA
"member(zed,[jules]).",NA,NA
"Again the first clause doesn't help, so Prolog uses the second rule, which gives it the goal ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node34.html (2 of 4)11/3/2006 7:29:47 PM,NA
"member(zed,[])",NA,NA
And this is where things get interesting. Obviously the first clause can't help here. But note: ,NA,NA
the recursive rule can't do anything more either. Why not? Simple: the recursive rule relies on ,NA,NA
"splitting the list into a head and a tail, but as we have already seen, the empty list can't be split ",NA,NA
"up in this way. So the recursive rule cannot be applied either, and Prolog stops searching for ",NA,NA
"more solutions and announces `No'. That is, it tells us that ",NA,NA
zed,NA,NA
" does not belong to the list, ",NA,NA
"which is, of course, what it ought to do.",NA,NA
We could summarize the ,NA,NA
member/2,NA,NA
" predicate as follows. It is a recursive predicate, which ",NA,NA
systematically searches down the length of the list for the required item. It does this by ,NA,NA
"stepwise breaking down the list into smaller lists, and looking at the first item of each smaller ",NA,NA
"list. This mechanism that drives this search is recursion, and the reason that this recursion is ",NA,NA
"safe (that is, the reason it does not go on forever) is that at the end of the line Prolog has to ",NA,NA
"ask a question about the empty list. The empty list cannot be broken down into smaller parts, ",NA,NA
and this allows a way out of the recursion.,NA,NA
"Well, we've now seen why ",NA,NA
member/2,NA,NA
" works, but in fact it's far more useful than the previous ",NA,NA
example might suggest. Up till now we've only been using it to answer yes/no questions. But ,NA,NA
"we can also pose questions containing variables. For example, we can have the following ",NA,NA
dialog with Prolog: ,NA,NA
"member(X,[yolanda,trudy,vincent,jules]). ",NA,NA
X = yolanda ; ,NA,NA
X = trudy ; ,NA,NA
X = vincent ; ,NA,NA
X = jules ; ,NA,NA
no,NA,NA
"That is, Prolog has told us what every member of a list is. This is a very common use of ",NA,NA
member/2,NA,NA
". In effect, by using the variable we are saying to Prolog: `Quick! Give me some ",NA,NA
"element of the list!'. In many applications we need to be able to extract members of a list, and ",NA,NA
this is the way it is typically done.,NA,NA
One final remark. The way we defined ,NA,NA
member/2,NA,NA
" above is certainly correct, but in one ",NA,NA
respect it is a little messy.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node34.html (3 of 4)11/3/2006 7:29:47 PM,NA
Think about it. The first clause is there to deal with the head of the list. But although the tail is ,NA,NA
"irrelevant to the first clause, we named the tail using the variable ",NA,NA
T,NA,NA
". Similarly, the recursive rule ",NA,NA
"is there to deal with the tail of the list. But although the head is irrelevant here, we named it ",NA,NA
using the variable ,NA,NA
H,NA,NA
. These unnecessary variable names are distracting: it's better to write ,NA,NA
"predicates in a way that focuses attention on what is really important in each clause, and the ",NA,NA
"anonymous variable gives us a nice way of doing this. That is, we can rewrite ",NA,NA
member/2 ,NA,NA
as ,NA,NA
follows: ,NA,NA
"member(X,[X|_]). ",NA,NA
"member(X,[_|T]) :- member(X,T).",NA,NA
"This version is exactly the same, both declaratively and procedurally. But it's just that little bit ",NA,NA
"clearer: when you read it, you are forced to concentrate on what is essential. ",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
4.3 Recursing down lists,NA,NA
"Member works by recursively working down a list, doing something to the head, and then ",NA,NA
"recursively doing the same thing to the tail. Recursing down a list (or indeed, several lists) in ",NA,NA
"this way is extremely common in Prolog: so common, in fact, that it is important that you ",NA,NA
really master the idea. So let's look at another example of the technique at work.,NA,NA
"When working with lists, we often want to compare one list with another, or to copy bits of ",NA,NA
"one list into another, or to translate the contents of one list into another, or something similar. ",NA,NA
Here's an example. Let's suppose we need a predicate ,NA,NA
a2b/2,NA,NA
 that takes two lists as ,NA,NA
"arguments, and succeeds if the first argument is a list of ",NA,NA
a,NA,NA
"s, and the second argument is a list ",NA,NA
of ,NA,NA
b,NA,NA
"s of exactly the same length. For example, if we pose the following query ",NA,NA
"a2b([a,a,a,a],[b,b,b,b]).",NA,NA
"we want Prolog to say `yes'. On the other hand, if we pose the query ",NA,NA
"a2b([a,a,a,a],[b,b,b]).",NA,NA
or the query ,NA,NA
"a2b([a,c,a,a],[b,b,5,4]).",NA,NA
we want Prolog to say `no'.,NA,NA
"When faced with such tasks, often the best way to set about solving them is to start by ",NA,NA
"thinking about the simplest possible case. Now, when working with lists, `thinking about the ",NA,NA
"simplest case' often means `thinking about the empty list', and it certainly means this here. ",NA,NA
After all: what is the shortest possible list of ,NA,NA
a,NA,NA
"s? Why, the empty list: it contains no ",NA,NA
a,NA,NA
s at all! ,NA,NA
And what is the shortest possible list of ,NA,NA
b,NA,NA
"s? Again, the empty list: no ",NA,NA
b,NA,NA
s whatsoever in that! ,NA,NA
So the most basic information our definition needs to contain is ,NA,NA
"a2b([],[]).",NA,NA
This records the obvious fact that the empty list contains exactly as many ,NA,NA
a,NA,NA
s as ,NA,NA
b,NA,NA
s. But ,NA,NA
"although obvious, this fact turns out to play a very important role in our program, as we shall ",NA,NA
see.,NA,NA
"So far so good: but how do we proceed? Here's the idea: for longer lists, think recursively. So: ",NA,NA
when should ,NA,NA
a2b/2,NA,NA
 decide that two non-empty lists are a list of ,NA,NA
a,NA,NA
s and a list of ,NA,NA
b,NA,NA
s of exactly ,NA,NA
the same length? Simple: when the head of the first list is an ,NA,NA
a,NA,NA
", and the head of the second list ",NA,NA
is a ,NA,NA
b,NA,NA
", and ",NA,NA
a2b/2,NA,NA
 decides that the two tails are lists of ,NA,NA
a,NA,NA
s and ,NA,NA
b,NA,NA
s of exactly the same length! ,NA,NA
This immediately gives us the following rule: ,NA,NA
"a2b([a|Ta],[b|Tb]) :- a2b(Ta,Tb).",NA,NA
This says: the ,NA,NA
a2b/2,NA,NA
 predicate should succeed if its first argument is a list with head ,NA,NA
a,NA,NA
", its ",NA,NA
second argument is a list with head ,NA,NA
b,NA,NA
", and ",NA,NA
a2b/2,NA,NA
 succeeds on the two tails.,NA,NA
"Now, this definition make good sense declaratively. It is a simple and natural recursive ",NA,NA
"predicate, the base clause dealing with the empty list, the recursive clause dealing with non-",NA,NA
"empty lists. But how does it work in practice? That is, what is its procedural meaning? For ",NA,NA
"example, if we pose the query ",NA,NA
"a2b([a,a,a],[b,b,b]).",NA,NA
"Prolog will say `yes', which is what we want, by why exactly does this happen?",NA,NA
"Let's work the example through. In this query, neither list is empty, so the fact does not help. ",NA,NA
"Thus Prolog goes on to try the recursive rule. Now, the query does match the rule (after all, ",NA,NA
the head of the first list is ,NA,NA
a,NA,NA
 and the head of the second in ,NA,NA
b,NA,NA
") so Prolog now has a new goal, ",NA,NA
namely ,NA,NA
"a2b([a,a],[b,b]).",NA,NA
"Once again, the fact does not help with this, but the recursive rule can be used again, leading ",NA,NA
to the following goal: ,NA,NA
"a2b([a],[b]).",NA,NA
"Yet again the fact does not help, but the recursive rule does, so we get the following goal: ",NA,NA
"a2b([],[]).",NA,NA
"At last we can use the fact: this tells us that, yes, we really do have two lists here that contain ",NA,NA
exactly the same number of ,NA,NA
a,NA,NA
s and ,NA,NA
b,NA,NA
"s (namely, none at all). And because this goal succeeds, ",NA,NA
this means that the goal ,NA,NA
"a2b([a],[b]).",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node35.html (2 of 4)11/3/2006 7:29:52 PM,NA
succeeds too. This in turn means that the goal ,NA,NA
"a2b([a,a],[b,b]).",NA,NA
"succeeds, and thus that the original goal ",NA,NA
"a2b([a,a,a],[b,b,b]).",NA,NA
is satisfied.,NA,NA
We could summarize this process as follows. Prolog started with two lists. It peeled the head ,NA,NA
"off each of them, and checked that they were an ",NA,NA
a,NA,NA
 and a ,NA,NA
b,NA,NA
 as required. It then recursively ,NA,NA
"analyzed the tails of both lists. That is, it worked down both tails simultaneously, checking that ",NA,NA
at each stage the tails were headed by an ,NA,NA
a,NA,NA
 and a ,NA,NA
b,NA,NA
. Why did the process stop? Because at ,NA,NA
each recursive step we had to work with shorter lists (namely the tails of the lists examined at ,NA,NA
"the previous step) and eventually we ended up with empty lists. At this point, our rather trivial ",NA,NA
"looking fact was able to play a vital role: it said `yes!'. This halted the recursion, and ensured ",NA,NA
that the original query succeeded.,NA,NA
"It's is also important to think about what happens with queries that fail. For example, if we ",NA,NA
pose the query ,NA,NA
"a2b([a,a,a,a],[b,b,b]).",NA,NA
Prolog will correctly say `no'. Why? because after carrying out the `peel off the head and ,NA,NA
"recursively examine the tail' process three times, it will be left with the query ",NA,NA
"a2b([a],[]).",NA,NA
But this goal cannot be satisfied. And if we pose the query ,NA,NA
"a2b([a,c,a,a],[b,b,5,4]).",NA,NA
"after carrying out the `peel off the head and recursively examine the tail' process once, Prolog ",NA,NA
will have the goal ,NA,NA
"a2b([c,a,a],[b,5,4]).",NA,NA
"and again, this cannot be satisfied.",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node35.html (3 of 4)11/3/2006 7:29:52 PM,NA
"Well, that's how ",NA,NA
a2b/2,NA,NA
" works in simple cases, but we haven't exhausted its possibilities yet. As ",NA,NA
"always with Prolog, it's a good idea to investigate what happens when variables as used as ",NA,NA
input. And with ,NA,NA
a2b/2,NA,NA
" something interesting happens: it acts as a translator, translating lists of ",NA,NA
a,NA,NA
s to lists of ,NA,NA
b,NA,NA
"s, and vice versa. For example the query ",NA,NA
"a2b([a,a,a,a],X).",NA,NA
yields the response ,NA,NA
"X = [b,b,b,b].",NA,NA
"That is, the list of ",NA,NA
a,NA,NA
s has been translated to a list of ,NA,NA
b,NA,NA
"s. Similarly, by using a variable in the ",NA,NA
"first argument position, we can use it to translate lists of ",NA,NA
b,NA,NA
s to lists of ,NA,NA
a,NA,NA
s: ,NA,NA
"a2b(X,[b,b,b,b]). ",NA,NA
"X = [a,a,a,a]",NA,NA
"And of course, we can use variables in both argument positions: ",NA,NA
"a2b(X,Y).",NA,NA
Can you work out what happens in this case?,NA,NA
To sum up: ,NA,NA
a2b/2,NA,NA
 is an extremely simple example of a program that works by recursing its way ,NA,NA
down a pair of lists. But don't be fooled by its simplicity: the kind of programming it illustrates ,NA,NA
"is fundamental to Prolog. Both its declarative form (a base clause dealing with the empty list, a ",NA,NA
recursive clause dealing with non-empty lists) and the procedural idea it trades on (do ,NA,NA
"something to the heads, and then recursively do the same thing to the tails) come up again ",NA,NA
"and again in Prolog programming. In fact, in the course of your Prolog career, you'll find that ",NA,NA
you'll write what is essentially the ,NA,NA
a2b/2,NA,NA
" predicate, or a more complex variant of it, many times ",NA,NA
over in many different guises.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
4.4 Exercises,NA,NA
Exercise 4.1,NA,NA
How does Prolog respond to the following queries? ,NA,NA
1.  ,NA,NA
"[a,b,c,d] = [a,[b,c,d]]. ",NA,NA
2.  ,NA,NA
"[a,b,c,d] = [a|[b,c,d]]. ",NA,NA
3.  ,NA,NA
"[a,b,c,d] = [a,b,[c,d]]. ",NA,NA
4.  ,NA,NA
"[a,b,c,d] = [a,b|[c,d]]. ",NA,NA
5.  ,NA,NA
"[a,b,c,d] = [a,b,c,[d]]. ",NA,NA
6.  ,NA,NA
"[a,b,c,d] = [a,b,c|[d]]. ",NA,NA
7.  ,NA,NA
"[a,b,c,d] = [a,b,c,d,[]]. ",NA,NA
8.  ,NA,NA
"[a,b,c,d] = [a,b,c,d|[]]. ",NA,NA
9.  ,NA,NA
[] = _.,NA,NA
10.  ,NA,NA
[] = [_].,NA,NA
11.  ,NA,NA
[] = [_|[]].,NA,NA
Exercise 4.2,NA,NA
Suppose we are given a knowledge base with the following facts: ,NA,NA
"tran(eins,one). ",NA,NA
"tran(zwei,two). ",NA,NA
"tran(drei,three). ",NA,NA
"tran(vier,four). ",NA,NA
"tran(fuenf,five). ",NA,NA
"tran(sechs,six). ",NA,NA
"tran(sieben,seven). ",NA,NA
"tran(acht,eight). ",NA,NA
"tran(neun,nine).",NA,NA
Write a predicate ,NA,NA
"listtran(G,E)",NA,NA
 which translates a list of German number words ,NA,NA
to the corresponding list of English number words. For example: ,NA,NA
"listtran([eins,neun,zwei],X).",NA,NA
should give: ,NA,NA
"X = [one,nine,two].",NA,NA
"Your program should also work in the other direction. For example, if you give it ",NA,NA
the query ,NA,NA
"listtran(X,[one,seven,six,two]).",NA,NA
it should return: ,NA,NA
"X = [eins,sieben,sechs,zwei].",NA,NA
"Hint: to answer this question, first ask yourself `How do I translate the empty list ",NA,NA
"of number words?'. That's the base case. For non-empty lists, first translate the ",NA,NA
"head of the list, then use recursion to translate the tail.",NA,NA
Exercise 4.3 ,NA,NA
Write a predicate ,NA,NA
"twice(In,Out)",NA,NA
" whose left argument is a list, and whose right ",NA,NA
argument is a list consisting of every element in the left list written twice. For ,NA,NA
"example, the query ",NA,NA
"twice([a,4,buggle],X).",NA,NA
should return ,NA,NA
"X = [a,a,4,4,buggle,buggle]).",NA,NA
And the query ,NA,NA
"twice([1,2,1,1],X).",NA,NA
should return ,NA,NA
"X = [1,1,2,2,1,1,1,1].",NA,NA
"Hint: to answer this question, first ask yourself `What should happen when the ",NA,NA
"first argument is the empty list?'. That's the base case. For non-empty lists, think ",NA,NA
"about what you should do with the head, and use recursion to handle the tail.",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node36.html (2 of 3)11/3/2006 7:29:59 PM,NA
Exercise 4.4,NA,NA
Draw the search trees for the following three queries: ,NA,NA
"?- member(a,[c,b,a,y]). ",NA,NA
"?- member(x,[a,b,c]). ",NA,NA
"?- member(X,[a,b,c]).",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
4.5 Practical Session 4,NA,NA
The purpose of Practical Session 4 is to help you get familiar with the idea of recursing down ,NA,NA
"lists. We first suggest some traces for you to carry out, and then some programming exercises.",NA,NA
"First, systematically carry out a number of traces on ",NA,NA
a2b/2,NA,NA
 to make sure you fully understand ,NA,NA
how it works. In particular: ,NA,NA
"1.  Trace some examples, not involving variables, that succeed. E.g., trace the query ",NA,NA
a2b ,NA,NA
"([a,a,a,a],[b,b,b,b])",NA,NA
 and relate the output to the discussion in the text.,NA,NA
2.  Trace some simple examples that fail. Try examples involving lists of different lengths ,NA,NA
(such as ,NA,NA
"a2b([a,a,a,a],[b,b,b])",NA,NA
) and examples involving symbols other than ,NA,NA
a ,NA,NA
and ,NA,NA
b,NA,NA
 ,NA,NA
(such as ,NA,NA
"a2b([a,c,a,a],[b,b,5,4])",NA,NA
). ,NA,NA
"3.  Trace some examples involving variables. For example, try tracing ",NA,NA
"a2b([a,a,a,a], ",NA,NA
X),NA,NA
 ,NA,NA
and ,NA,NA
"a2b(X,[b,b,b,b])",NA,NA
.,NA,NA
4.  Make sure you understand what happens when both arguments in the query are ,NA,NA
"variables. For example, carry out a trace on the query ",NA,NA
"a2b(X,Y)",NA,NA
.,NA,NA
5.  Carry out a series of similar traces involving ,NA,NA
member,NA,NA
". That is, carry out traces involving ",NA,NA
simple queries that succeed (such as ,NA,NA
"member(a,[1,2,a,b])",NA,NA
"), simple queries that fail (such ",NA,NA
as ,NA,NA
"member(z,[1,2,a,b])",NA,NA
"), and queries involving variables (such as ",NA,NA
"member (X,[1,2,a,b])",NA,NA
). In ,NA,NA
"all cases, make sure that you understand why the recursion halts.",NA,NA
"Having done this, try the following. ",NA,NA
1.  Write a 3-place predicate ,NA,NA
combine1,NA,NA
 which takes three lists as arguments and combines ,NA,NA
the elements of the first two lists into the third as follows: ,NA,NA
"?- combine1([a,b,c],[1,2,3],X). ",NA,NA
"X = [a,1,b,2,c,3] ",NA,NA
"?- combine1([foo,bar,yip,yup],[glub,glab,glib,glob], Result). ",NA,NA
"Result = [foo,glub,bar,glab,yip,glib,yup,glob]",NA,NA
2.  Now write a 3-place predicate ,NA,NA
combine2,NA,NA
 which takes three lists as arguments and ,NA,NA
combines the elements of the first two lists into the third as follows: ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node37.html (1 of 3)11/3/2006 7:30:04 PM,NA
"?- combine2([a,b,c],[1,2,3],X). ",NA,NA
"X = [[a,1],[b,2],[c,3]] ",NA,NA
"?- combine2([foo,bar,yip,yup],[glub,glab,glib,glob], Result). ",NA,NA
"Result = [[foo,glub],[bar,glab],[yip,glib],[yup,glob]]",NA,NA
"3.  Finally, write a 3-place predicate ",NA,NA
combine3,NA,NA
 which takes three lists as arguments and ,NA,NA
combines the elements of the first two lists into the third as follows: ,NA,NA
"?- combine3([a,b,c],[1,2,3],X). ",NA,NA
"X = [join(a,1),join(b,2),join(c,3)] ",NA,NA
"?- combine3([foo,bar,yip,yup],[glub,glab,glib,glob],R). ",NA,NA
"R = [join(foo,glub),join(bar,glab),join(yip,glib),join (yup,glob)]",NA,NA
All three programs are pretty much the same as ,NA,NA
a2b/2,NA,NA
 (though of course they manipulate ,NA,NA
"three lists, not two). That is, all three can be written by recursing down the lists, doing ",NA,NA
"something to the heads, and then recursively doing the same thing to the tails. Indeed, once ",NA,NA
you have written ,NA,NA
combine1,NA,NA
", you just need to change the `something' you do to the heads to ",NA,NA
get ,NA,NA
combine2,NA,NA
 and ,NA,NA
combine3,NA,NA
.,NA,NA
"Now, you should have a pretty good idea of what the basic pattern of predicates for ",NA,NA
processing lists looks like. Here are a couple of list processing exercises that are a bit more ,NA,NA
"interesting. Hint: you can of course use predicates that we defined earlier, like e.g. ",NA,NA
member/2 ,NA,NA
in your predicate definition.,NA,NA
1.  Write a predicate mysubset/2 that takes two lists (of constants) as arguments and ,NA,NA
"checks, whether the first list is a subset of the second.",NA,NA
"2.  Write a predicate mysuperset/2 that takes two lists as arguments and checks, whether ",NA,NA
the first list is a superset of the second.,NA,NA
<< Prev,NA,NA
- Up -,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node37.html (2 of 3)11/3/2006 7:30:04 PM,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node37.html (3 of 3)11/3/2006 7:30:04 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
5 Arithmetic ,NA,NA
This lecture has two main goals: ,NA,NA
"1.  To introduce Prolog's inbuilt abilities for performing arithmetic, and ",NA,NA
"2.  To apply them to simple list processing problems, using accumulators.",G,NA
5.1 Arithmetic in Prolog ,G,NA
5.2 A closer look ,G,NA
5.3 Arithmetic and lists ,G,NA
5.4 Comparing integers ,G,NA
5.5 Exercises ,G,NA
5.6 Practical Session 5,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
5.1 Arithmetic in Prolog,NA,NA
"Prolog provides a number of basic arithmetic tools for manipulating integers (that is, numbers ",NA,NA
"of the form ...-3, -2, -1, 0, 1, 2, 3, 4...). Most Prolog implementation also provide tools for ",NA,NA
handling real numbers (or floating point numbers) such as 1.53 or ,NA,NA
", but we're not ",NA,NA
"going to discuss these, for they are not particularly useful for the symbolic processing tasks ",NA,NA
"discussed in this course. Integers, on the other hand, are useful for various tasks (such as ",NA,NA
"finding the length of a list), so it is important to understand how to work with them. We'll start ",NA,NA
"by looking at how Prolog handles the four basic operations of addition, multiplication, ",NA,NA
"subtraction, and division. ",NA,NA
Arithmetic examples,NA,NA
Prolog Notation,NA,NA
8 is 6+2.,NA,NA
12 is 6*2.,NA,NA
4 is 6-2.,NA,NA
-2 is 6-8.,NA,NA
3 is 6/2.,NA,NA
3 is 7/2.,NA,NA
1 is the remainder when 7 is divided by 2,NA,NA
" 1 is mod(7,2).",NA,NA
"(Note that as we are working with integers, division gives us back an integer answer. Thus ",NA,NA
" gives 3 as an answer, leaving a reminder of 1.)",NA,NA
Posing the following queries yields the following responses: ,NA,NA
?- 8 is 6+2. ,NA,NA
yes ,NA,NA
?- 12 is 6*2. ,NA,NA
yes ,NA,NA
?- -2 is 6-8. ,NA,NA
yes ,NA,NA
?- 3 is 6/2. ,NA,NA
yes ,NA,NA
"?- 1 is mod(7,2). ",NA,NA
yes,NA,NA
"More importantly, we can work out the answers to arithmetic questions by using variables. For ",NA,NA
example: ,NA,NA
?- X is 6+2. ,NA,NA
X = 8 ,NA,NA
?- X is 6*2. ,NA,NA
X = 12 ,NA,NA
"?- R is mod(7,2). ",NA,NA
R = 1 ,NA,NA
"Moreover, we can use arithmetic operations when we define predicates. Here's a simple ",NA,NA
example. Let's define a predicate ,NA,NA
add_3_and_double,NA,NA
2/ whose arguments are both integers. ,NA,NA
"This predicate takes its first argument, adds three to it, doubles the result, and returns the ",NA,NA
number obtained as the second argument. We define this predicate as follows: ,NA,NA
"add_3_and_double(X,Y) :- Y is (X+3)*2.",NA,NA
"And indeed, this works: ",NA,NA
"?- add_3_and_double(1,X). ",NA,NA
X = 8 ,NA,NA
"?- add_3_and_double(2,X). ",NA,NA
X = 10 ,NA,NA
One other thing. Prolog understands the usual conventions we use for disambiguating ,NA,NA
"arithmetical expressions. For example, when we write ",NA,NA
 we mean ,NA,NA
 and not ,NA,NA
", and Prolog knows this convention: ",NA,NA
?- X is 3+2*4. ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node39.html (2 of 3)11/3/2006 7:30:18 PM,NA
X = 11 ,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
5.2 A closer look,NA,NA
"That's the basics, but we need to know more. The most important to grasp is this: +, *, -, ",NA,NA
and ,NA,NA
mod,NA,NA
" do not carry out any arithmetic. In fact, expressions such as ",NA,NA
3+2,NA,NA
", ",NA,NA
3-2,NA,NA
 and ,NA,NA
3*2,NA,NA
 are ,NA,NA
simply terms. The functors of these terms are ,NA,NA
+,NA,NA
", ",NA,NA
-,NA,NA
 and ,NA,NA
*,NA,NA
" respectively, and the arguments are ",NA,NA
3,NA,NA
 ,NA,NA
and ,NA,NA
2,NA,NA
. Apart from the fact that the functors go between their arguments (instead of in front of ,NA,NA
"them) these are ordinary Prolog terms, and unless we do something special, Prolog will not ",NA,NA
"actually do any arithmetic. In particular, if we pose the query ",NA,NA
?- X = 3+2,NA,NA
we don't get back the answer ,NA,NA
X=5,NA,NA
. Instead we get back ,NA,NA
X = 3+2 ,NA,NA
yes,NA,NA
"That is, Prolog has simply bound the variable ",NA,NA
X,NA,NA
 to the complex term ,NA,NA
3+2,NA,NA
. It has not carried ,NA,NA
"out any arithmetic. It has simply done what it usually does: performed unification Similarly, if ",NA,NA
we pose the query ,NA,NA
?- 3+2*5 = X,NA,NA
we get the response ,NA,NA
X = 3+2*5 ,NA,NA
yes,NA,NA
"Again, Prolog has simply bound the variable ",NA,NA
X,NA,NA
 to the complex term ,NA,NA
3+2*5,NA,NA
. It did not evaluate ,NA,NA
this expression to 13. To force Prolog to actually evaluate arithmetic expressions we have to ,NA,NA
use ,NA,NA
is,NA,NA
"just as we did in our in our earlier examples. In fact, ",NA,NA
is,NA,NA
 does something very special: it sends a ,NA,NA
signal to Prolog that says `Hey! Don't treat this expression as an ordinary complex term! Call ,NA,NA
up your inbuilt arithmetic capabilities and carry out the calculations!',http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node40.html (1 of 3)11/3/2006 7:30:25 PM,NA
"In short, ",NA,NA
is,NA,NA
 forces Prolog to act in an unusual way. Normally Prolog is quite happy just ,NA,NA
"unifying variables to structures: that's its job, after all. Arithmetic is something extra that has ",NA,NA
"been bolted on to the basic Prolog engine because it is useful. Unsurprisingly, there are some ",NA,NA
"restrictions on this extra ability, and we need to know what they are.",NA,NA
"For a start, the arithmetic expressions to be evaluated must be on the right hand side of ",NA,NA
is,NA,NA
. ,NA,NA
In our earlier examples we carefully posed the query ,NA,NA
?- X is 6+2. ,NA,NA
X = 8 ,NA,NA
which is the right way to do it. If instead we had asked ,NA,NA
6+2 is X.,NA,NA
we would have got an error message saying ,NA,NA
instantiation_error,NA,NA
", or something similar.",NA,NA
"Moreover, although we are free to use variables on the right hand side of ",NA,NA
is,NA,NA
", when we actually ",NA,NA
"carry out evaluation, the variable must already have been instantiated to an integer. If the ",NA,NA
"variable is uninstantiated, or if it is instantiated to something other than an integer, we will get ",NA,NA
some sort of ,NA,NA
instantiation_error,NA,NA
 message. And this makes perfect sense. Arithmetic isn't ,NA,NA
performed using Prolog usual unification and knowledge base search mechanisms: it's done by ,NA,NA
calling up a special `black box' which knows about integer arithmetic. If we hand the black box ,NA,NA
"the wrong kind of data, naturally its going to complain.",NA,NA
Here's an example. Recall our `add 3 and double it' predicate. ,NA,NA
"add_3_and_double(X,Y) :- Y is (X+3)*2.",NA,NA
"When we described this predicate, we carefully said that it added 3 to its first argument, ",NA,NA
"doubled the result, and returned the answer in its second argument. For example, ",NA,NA
"add_3_and_double(3,X)",NA,NA
 returns ,NA,NA
X = 12,NA,NA
. We didn't say anything about using this predicate ,NA,NA
"in the reverse direction. For example, we might hope that posing the query ",NA,NA
"add_3_and_double(X,12).",NA,NA
would return the answer ,NA,NA
X=3,NA,NA
. But it doesn't! Instead we get the ,NA,NA
instantiation_error ,NA,NA
"message. Why? Well, when we pose the query this way round, we are asking Prolog to ",NA,NA
evaluate ,NA,NA
12 is (X+3)*2,NA,NA
", which it can't do as ",NA,NA
X,NA,NA
 is not instantiated.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node40.html (2 of 3)11/3/2006 7:30:25 PM,NA
"Two final remarks. As we've already mentioned, for Prolog ",NA,NA
3 + 2,NA,NA
" is just a term. In fact, for ",NA,NA
"Prolog, it really is the term +(3,2). The expression ",NA,NA
3 + 2,NA,NA
 is just a user-friendly notation that's ,NA,NA
"nicer for us to use. This means that if you really want to, you can give Prolog queries like ",NA,NA
"X is +(3,2)",NA,NA
and Prolog will correctly reply ,NA,NA
X = 5,NA,NA
"Actually, you can even given Prolog the query ",NA,NA
"is(X,+(3,2))",NA,NA
and Prolog will respond ,NA,NA
X = 5,NA,NA
"This is because, for Prolog, the expression ",NA,NA
"X is +(3,2)",NA,NA
 is the term ,NA,NA
"is(X,+(3,2))",NA,NA
. The expression ,NA,NA
X ,NA,NA
"is +(3,2)",NA,NA
" is just user friendly notation. Underneath, as always, Prolog is just working away with ",NA,NA
terms.,NA,NA
"Summing up, arithmetic in Prolog is easy to use. Pretty much all you have to remember is to ",NA,NA
use ,NA,NA
is,NA,NA
" to force evaluation, that stuff to be evaluated must goes to the right of ",NA,NA
is,NA,NA
", and to take ",NA,NA
care that any variables are correctly instantiated. But there is a deeper lesson that is worth ,NA,NA
reflecting on. By `bolting on' the extra capability to do arithmetic we have further widened the ,NA,NA
distance between the procedural and declarative interpretation of Prolog processing.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
5.3 Arithmetic and lists,NA,NA
Probably the most important use of arithmetic in this course is to tell us useful facts about ,NA,NA
"data-structures, such as lists. For example, it can be useful to know how long a list is. We'll ",NA,NA
give some examples of using lists together with arithmetic capabilities.,NA,NA
How long is a list? Here's a recursive definition. ,NA,NA
1.  The empty list has length zero.,NA,NA
"2.  A non-empty list has length 1 + len(T), where len(T) is the length of its tail.",NA,NA
This definition is practically a Prolog program already. Here's the code we need: ,NA,NA
"len([],0). ",NA,NA
"len([_|T],N) :- len(T,X), N is X+1.",NA,NA
This predicate works in the expected way. For example: ,NA,NA
"?- len([a,b,c,d,e,[a,b],g],X). ",NA,NA
X = 7 ,NA,NA
"Now, this is quite a good program: it's easy to understand and efficient. But there is another ",NA,NA
"method of finding the length of a list. We'll now look at this alternative, because it introduces ",NA,NA
"the idea of accumulators, a standard Prolog technique we will be seeing lots more of.",NA,NA
"If you're used to other programming languages, you're probably used to the idea of using ",NA,NA
variables to hold intermediate results. An accumulator is the Prolog analog of this idea.,NA,NA
Here's how to use an accumulator to calculate the length of a list. We shall define a predicate ,NA,NA
accLen,NA,NA
3/ which takes the following arguments. ,NA,NA
"accLen(List,Acc,Length)",NA,NA
Here ,NA,NA
List,NA,NA
" is the list whose length we want to find, and ",NA,NA
Length,NA,NA
 is its length (an integer). What ,NA,NA
about ,NA,NA
Acc,NA,NA
? This is a variable we will use to keep track of intermediate values for length (so it ,NA,NA
"will also be an integer). Here's what we do. When we call this predicate, we are going to ",NA,NA
give ,NA,NA
Acc,NA,NA
 an initial value of ,NA,NA
0,NA,NA
". We then recursively work our way down the list, adding ",NA,NA
1,NA,NA
 to ,NA,NA
Acc,NA,NA
 ,NA,NA
"each time we find a head element, until we reach the empty list. When we do reach the ",NA,NA
"empty set, ",NA,NA
Acc,NA,NA
 will contain the length of the list. Here's the code: ,NA,NA
"accLen([_|T],A,L) :-  Anew is A+1, accLen(T,Anew,L). accLen([],A,A).",NA,NA
"The base case of the definition, unifies the second and third arguments. Why? There are ",NA,NA
"actually two reasons. The first is because when we reach the end of the list, the accumulator ",NA,NA
(the second variable) contains the length of the list. So we give this value (via unification) to ,NA,NA
the length variable (the third variable). The second is that this trivial unification gives a nice ,NA,NA
way of stopping the recursion when we reach the empty list. Here's an example trace: ,NA,NA
"?- accLen([a,b,c],0,L). ",NA,NA
" Call: (6) accLen([a, b, c], 0, _G449) ?    Call: (7) _G518 is 0+1 ?   ",NA,NA
 Exit: (7) 1 is 0+1 ?   ,NA,NA
" Call: (7) accLen([b, c], 1, _G449) ?    Call: (8) _G521 is ",NA,NA
1+1 ?   ,NA,NA
 Exit: (8) 2 is 1+1 ?   ,NA,NA
" Call: (8) accLen([c], 2, _G449) ?   ",NA,NA
 Call: (9) _G524 is 2+1 ?   ,NA,NA
 Exit: (9) 3 is 2+1 ?   ,NA,NA
" Call: (9) accLen([], 3, _G449) ?   ",NA,NA
" Exit: (9) accLen([], 3, 3) ?   ",NA,NA
" Exit: (8) accLen([c], 2, 3) ?   ",NA,NA
" Exit: (7) accLen([b, c], 1, 3) ?   ",NA,NA
" Exit: (6) accLen([a, b, c], 0, 3) ? ",NA,NA
"As a final step, we'll define a predicate which calls ",NA,NA
accLen,NA,NA
" for us, and gives it the initial value of ",NA,NA
0: ,NA,NA
"leng(List,Length) :- accLen(List,0,Length).",NA,NA
So now we can pose queries like this: ,NA,NA
"leng([a,b,c,d,e,[a,b],g],X).",NA,NA
Accumulators are extremely common in Prolog programs. (We'll see another accumulator ,NA,NA
based program later in this lecture. And many more in the rest of the course.) But why is this? ,NA,NA
In what way is ,NA,NA
accLen,NA,NA
 better than ,NA,NA
len,NA,NA
"? After all, it looks more difficult. The answer is that ",NA,NA
accLen,NA,NA
 is tail recursive while ,NA,NA
len,NA,NA
 is not. In tail recursive programs the result is all calculated ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node41.html (2 of 3)11/3/2006 7:30:30 PM,NA
once we reached the bottom of the recursion and just has to be passed up. In recursive ,NA,NA
programs which are not tail recursive there are goals in one level of recursion which have to ,NA,NA
wait for the answer of a lower level of recursion before they can be evaluated. To understand ,NA,NA
"this, compare the traces for the queries ",NA,NA
"accLen([a,b,c],0,L)",NA,NA
 (see above) and ,NA,NA
"len([a, b,c],0,L)",NA,NA
 ,NA,NA
(given below). In the first case the result is built while going into the recursion -- once the ,NA,NA
bottom is reached at ,NA,NA
"accLen([],3,_G449)",NA,NA
 the result is there and only has to be passed up. In the ,NA,NA
second case the result is built while coming out of the recursion -- the result of ,NA,NA
"len([b,c], ",NA,NA
_G481),NA,NA
", for instance, is only computed after the recursive call of ",NA,NA
len,NA,NA
 has been completed and ,NA,NA
the result of ,NA,NA
"len([c], _G489)",NA,NA
 is known. ,NA,NA
"?- len([a,b,c],L). ",NA,NA
" Call: (6) len([a, b, c], _G418) ?   ",NA,NA
" Call: (7) len([b, c], _G481) ?   ",NA,NA
" Call: (8) len([c], _G486) ?   ",NA,NA
" Call: (9) len([], _G489) ?   ",NA,NA
" Exit: (9) len([], 0) ?   ",NA,NA
 Call: (9) _G486 is 0+1 ?   ,NA,NA
 Exit: (9) 1 is 0+1 ?   ,NA,NA
" Exit: (8) len([c], 1) ?   ",NA,NA
 Call: (8) _G481 is 1+1 ?   ,NA,NA
 Exit: (8) 2 is 1+1 ?   ,NA,NA
" Exit: (7) len([b, c], 2) ?   ",NA,NA
 Call: (7) _G418 is 2+1 ?   ,NA,NA
 Exit: (7) 3 is 2+1 ?   ,NA,NA
" Exit: (6) len([a, b, c], 3) ? ",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
5.4 Comparing integers,NA,NA
"Some Prolog arithmetic predicates actually do carry out arithmetic all by themselves (that is, ",NA,NA
without the assistance of ,NA,NA
is,NA,NA
). These are the operators that compare integers. ,NA,NA
Arithmetic examples Prolog Notation,NA,NA
X < Y.,NA,NA
X =< Y.,NA,NA
X =:= Y.,NA,NA
X =\= Y.,NA,NA
X >= Y,NA,NA
X > Y,NA,NA
These operators have the obvious meaning: ,NA,NA
2 < 4. ,NA,NA
yes ,NA,NA
2 =< 4. ,NA,NA
yes ,NA,NA
4 =< 4. ,NA,NA
yes ,NA,NA
4=:=4. ,NA,NA
yes ,NA,NA
4=\=5. ,NA,NA
yes ,NA,NA
4=\=4. ,NA,NA
no ,NA,NA
4 >= 4. ,NA,NA
yes ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node42.html (1 of 4)11/3/2006 7:30:36 PM,NA
4 > 2. ,NA,NA
yes,NA,NA
"Moreover, they force both their right-hand and left-hand arguments to be evaluated: ",NA,NA
2 < 4+1. ,NA,NA
yes ,NA,NA
2+1 < 4. ,NA,NA
yes ,NA,NA
2+1 < 3+2. ,NA,NA
yes,NA,NA
Note that ,NA,NA
=:=,NA,NA
 really is different from ,NA,NA
=,NA,NA
", as the following examples show: ",NA,NA
4=4. ,NA,NA
yes ,NA,NA
2+2 =4. ,NA,NA
no ,NA,NA
2+2 =:= 4. ,NA,NA
yes,NA,NA
"That is, ",NA,NA
=,NA,NA
 tries to unify its arguments; it does not force arithmetic evaluation. That's ,NA,NA
=:=,NA,NA
's job.,NA,NA
"Whenever we use these operators, we have to take care that any variables are instantiated. ",NA,NA
"For example, all the following queries lead to instantiation errors. ",NA,NA
X < 3. ,NA,NA
3 < Y. ,NA,NA
X =:= X.,NA,NA
"Moreover, variables have to be instantiated to integers. The query ",NA,NA
"X = 3, X < 4.",NA,NA
succeeds. But the query ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node42.html (2 of 4)11/3/2006 7:30:36 PM,NA
"X = b, X < 4.",NA,NA
fails.,NA,NA
"OK, let's now look at an example which puts Prolog's abilities to compare numbers to work. ",NA,NA
We're going to define a predicate which takes takes a list of non-negative integers as its first ,NA,NA
"argument, and returns the maximum integer in the list as its last argument. Again, we'll use ",NA,NA
"an accumulator. As we work our way down the list, the accumulator will keep track of the ",NA,NA
"highest integer found so far. If we find a higher value, the accumulator will be updated to this ",NA,NA
"new value. When we call the program, we set accumulator to an initial value of 0. Here's the ",NA,NA
code. Note that there are two recursive clauses: ,NA,NA
"accMax([H|T],A,Max) :- ",NA,NA
" H > A, ",NA,NA
" accMax(T,H,Max). ",NA,NA
"accMax([H|T],A,Max) :- ",NA,NA
" H =< A, ",NA,NA
" accMax(T,A,Max). ",NA,NA
"accMax([],A,A).",NA,NA
"The first clause tests if the head of the list is larger than the largest value found so far. If it is, ",NA,NA
"we set the accumulator to this new value, and then recursively work through the tail of the ",NA,NA
list. The second clause applies when the head is less than or equal to the accumulator; in this ,NA,NA
"case we recursively work through the tail of the list using the old accumulator value. Finally, ",NA,NA
the base clause unifies the second and third arguments; it gives the highest value we found ,NA,NA
while going through the list to the last argument. Here's how it works: ,NA,NA
"accMax([1,0,5,4],0,_5810) ",NA,NA
"accMax([0,5,4],1,_5810) ",NA,NA
"accMax([5,4],1,_5810) ",NA,NA
"accMax([4],5,_5810) ",NA,NA
"accMax([],5,_5810) ",NA,NA
"accMax([],5,5) ",NA,NA
"Again, it's nice to define a predicate which calls this, and initializes the accumulator. But wait: ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node42.html (3 of 4)11/3/2006 7:30:36 PM,NA
"what should we initialize the accumulator too? If you say 0, this means you are assuming that ",NA,NA
all the numbers in the list are positive. But suppose we give a list of negative integers as input. ,NA,NA
Then we would have ,NA,NA
"accMax([-11,-2,-7,-4,-12],0,Max). ",NA,NA
Max = 0 ,NA,NA
yes,NA,NA
This is not what we want: the biggest number on the list is -2. Our use of 0 as the initial value ,NA,NA
"of the accumulator has ruined everything, because it's bigger than any number on the list.",NA,NA
"There's an easy way around this: since our input list will always be a list of integers, simply ",NA,NA
initialize the accumulator to the head of the list. That way we guarantee that the accumulator ,NA,NA
is initialized to a number on the list. The following predicate does this for us: ,NA,NA
"max(List,Max) :- ",NA,NA
" List = [H|_], ",NA,NA
" accMax(List,H,Max).",NA,NA
So we can simply say: ,NA,NA
"max([1,2,46,53,0],X). ",NA,NA
X = 53 ,NA,NA
yes,NA,NA
And furthermore we have: ,NA,NA
"max([-11,-2,-7,-4,-12],X). ",NA,NA
X = -2 ,NA,NA
yes,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
5.5 Exercises,NA,NA
Exercise 5.1,NA,NA
How does Prolog respond to the following queries? ,NA,NA
1.  ,NA,NA
X = 3*4.,NA,NA
2.  ,NA,NA
X is 3*4.,NA,NA
3.  ,NA,NA
4 is X.,NA,NA
4.  ,NA,NA
X = Y.,NA,NA
5.  ,NA,NA
3 is 1+2.,NA,NA
6.  ,NA,NA
"3 is +(1,2).",NA,NA
7.  ,NA,NA
3 is X+2.,NA,NA
8.  ,NA,NA
X is 1+2.,NA,NA
9.  ,NA,NA
1+2 is 1+2.,NA,NA
10.  ,NA,NA
"is(X,+(1,2)).",NA,NA
11.  ,NA,NA
"3+2 = +(3,2).",NA,NA
12.  ,NA,NA
"*(7,5) = 7*5.",NA,NA
13.  ,NA,NA
"*(7,+(3,2)) = 7*(3+2). ",NA,NA
14.  ,NA,NA
"*(7,(3+2)) = 7*(3+2).",NA,NA
15.  ,NA,NA
"*(7,(3+2)) = 7*(+(3,2)).",NA,NA
Exercise 5.2,NA,NA
1.  Define a 2-place predicate increment that holds only when its second ,NA,NA
"argument is an integer one larger than its first argument. For example, ",NA,NA
"increment(4,5)",NA,NA
" should hold, but ",NA,NA
"increment(4,6)",NA,NA
 should not.,NA,NA
2.  Define a 3-place predicate sum that holds only when its third argument is ,NA,NA
"the sum of the first two arguments. For example, ",NA,NA
"sum(4,5,9)",NA,NA
" should hold, ",NA,NA
but ,NA,NA
"sum(4,6,12)",NA,NA
should not.,NA,NA
Exercise 5.3,NA,NA
Write a predicate ,NA,NA
addone,NA,NA
"2/ whose first argument is a list of integers, and whose ",NA,NA
second argument is the list of integers obtained by adding 1 to each integer in ,NA,NA
"the first list. For example, the query ",NA,NA
" addone([1,2,7,2],X).",NA,NA
should give ,NA,NA
" X = [2,3,8,3].",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
5.6 Practical Session 5,NA,NA
The purpose of Practical Session 5 is to help you get familiar with Prolog's arithmetic ,NA,NA
"capabilities, and to give you some further practice in list manipulation. To this end, we suggest ",NA,NA
the following programming exercises: ,NA,NA
1.  In the text we discussed the 3-place predicate ,NA,NA
accMax,NA,NA
 which which returned the ,NA,NA
"maximum of a list of integers. By changing the code slightly, turn this into a 3-place ",NA,NA
predicate ,NA,NA
accMin,NA,NA
 which returns the minimum of a list of integers. ,NA,NA
"2.  In mathematics, an n-dimensional vector is a list of numbers of length n. For example, ",NA,NA
"[2,5,12]",NA,NA
" is a 3-dimensional vector, and ",NA,NA
"[45,27,3,-4,6]",NA,NA
 is a 5-dimensional vector. ,NA,NA
"One of the basic operations on vectors is scalar multiplication. In this operation, every ",NA,NA
"element of a vector is multiplied by some number. For example, if we scalar multiply the ",NA,NA
3-dimensional vector ,NA,NA
"[2,7,4]",NA,NA
 by ,NA,NA
3,NA,NA
 the result is the 3-dimensional vector ,NA,NA
"[6,21,12]",NA,NA
. ,NA,NA
Write a 3-place predicate ,NA,NA
scalarMult,NA,NA
" whose first argument is an integer, whose second ",NA,NA
"argument is a list of integers, and whose third argument is the result of scalar ",NA,NA
"multiplying the second argument by the first. For example, the query ",NA,NA
"scalarMult(3,[2,7,4],Result).",NA,NA
should yield ,NA,NA
"Result = [6,21,12]",NA,NA
3.  Another fundamental operation on vectors is the dot product. This operation combines ,NA,NA
two vectors of the same dimension and yields a number as a result. The operation is ,NA,NA
"carried out as follows: the corresponding elements of the two vectors are multiplied, and ",NA,NA
"the results added. For example, the dot product of ",NA,NA
"[2,5,6]",NA,NA
 and ,NA,NA
"[3,4,1]",NA,NA
 is ,NA,NA
6+20 +6,NA,NA
", that is, ",NA,NA
32,NA,NA
. Write a 3-place predicate ,NA,NA
dot,NA,NA
" whose first argument is a list of integers, whose ",NA,NA
"second argument is a list of integers of the same length as the first, and whose third ",NA,NA
"argument is the dot product of the first argument with the second. For example, the ",NA,NA
query ,NA,NA
"dot([2,5,6],[3,4,1],Result).",NA,NA
should yield ,NA,NA
Result = 32,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
6 More Lists,NA,NA
This lecture has two main goals: ,NA,NA
"1.  To define append, a predicate for concatenating two lists, and illustrate what can be ",NA,NA
done with it.,NA,NA
"2.  To discuss two ways of reversing a list: a naive method using append, and a more ",NA,NA
efficient method using accumulators.,G,NA
6.1 Append ,H,NA
6.1.1 Defining append ,H,NA
6.1.2 Using append,G,NA
6.2 Reversing a list ,H,NA
6.2.1 Naive reverse using append ,H,NA
6.2.2 Reverse using an accumulator,G,NA
6.3 Exercises,G,NA
6.4 Practical Session 6,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
6.1 Append ,NA,NA
We shall define an important predicate ,NA,NA
append/3,NA,NA
 whose arguments are all lists. Viewed ,NA,NA
"declaratively, ",NA,NA
"append(L1,L2,L3)",NA,NA
 will hold when the list ,NA,NA
L3,NA,NA
 is the result of concatenating the ,NA,NA
lists ,NA,NA
L1,NA,NA
 and ,NA,NA
L2,NA,NA
" together (`concatenating' means `joining the lists together, end to end'). ",NA,NA
"For example, if we pose the query ",NA,NA
"?- append([a,b,c],[1,2,3],[a,b,c,1,2,3]).",NA,NA
or the query ,NA,NA
"?- append([a,[foo,gibble],c],[1,2,[[],b]], ",NA,NA
 ,NA,NA
"[a,[foo,gibble],c,1,2,[1,2,[[],b]]).",NA,NA
"we will get the response `yes'. On the other hand, if we pose the query ",NA,NA
"?- append([a,b,c],[1,2,3],[a,b,c,1,2]).",NA,NA
or the query ,NA,NA
"?- append([a,b,c],[1,2,3],[1,2,3,a,b,c]).",NA,NA
we will get the answer `no'. ,NA,NA
"From a procedural perspective, the most obvious use of ",NA,NA
append,NA,NA
 is to concatenate two lists ,NA,NA
together. We can do this simply by using a variable as the third argument: the query ,NA,NA
?- ,NA,NA
"append([a,b,c],[1,2,3],L3).",NA,NA
yields the response ,NA,NA
"L3 = [a,b,c,1,2,3] ",NA,NA
yes,NA,NA
But (as we shall soon see) we can also use ,NA,NA
append,NA,NA
" to split up a list. In fact, ",NA,NA
append,NA,NA
 is a real ,NA,NA
"workhorse. There's lots we can do with it, and studying it is a good way to gain a better ",NA,NA
understanding of list processing in Prolog.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node46.html (1 of 2)11/3/2006 7:31:04 PM,NA
6.1.1 Defining append,G,NA
6.1.2 Using append,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
6.1.1 Defining append,NA,NA
Here's how ,NA,NA
append/3,NA,NA
 is defined: ,NA,NA
"append([],L,L). ",NA,NA
"append([H|T],L2,[H|L3]) :- append(T,L2,L3).",NA,NA
This is a recursive definition. The base case simply says that appending the empty list to any ,NA,NA
"list whatsoever yields that same list, which is obviously true.",NA,NA
But what about the recursive step? This says that when we concatenate a non-empty list ,NA,NA
[H| ,NA,NA
T],NA,NA
 with a list ,NA,NA
L2,NA,NA
", we end up with the list whose head is ",NA,NA
H,NA,NA
 and whose tail is the result of ,NA,NA
concatenating ,NA,NA
T,NA,NA
 with ,NA,NA
L2,NA,NA
. It may be useful to think about this definition pictorially: ,NA,NA
But what is the procedural meaning of this definition? What actually goes on when we use ,NA,NA
append,NA,NA
 to glue two lists together? Let's take a detailed look at what happens when we pose ,NA,NA
the query ,NA,NA
"append([a,b,c],[1,2,3],X)",NA,NA
.,NA,NA
"When we pose this query, Prolog will match this query to the head of the recursive rule, ",NA,NA
generating a new internal variable (say ,NA,NA
_G518,NA,NA
) in the process. If we carried out a trace on ,NA,NA
"what happens next, we would get something like the following: ",NA,NA
"append([a, b, c], [1, 2, 3], _G518) ",NA,NA
"append([b, c], [1, 2, 3], _G587) ",NA,NA
"append([c], [1, 2, 3], _G590) ",NA,NA
"append([], [1, 2, 3], _G593) ",NA,NA
"append([], [1, 2, 3], [1, 2, 3]) ",NA,NA
"append([c], [1, 2, 3], [c, 1, 2, 3]) ",NA,NA
"append([b, c], [1, 2, 3], [b, c, 1, 2, 3]) ",NA,NA
"append([a, b, c], [1, 2, 3], [a, b, c, 1, 2, 3]) ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node47.html (1 of 4)11/3/2006 7:31:10 PM,NA
"X = [a, b, c, 1, 2, 3] ",NA,NA
yes,NA,NA
The basic pattern should be clear: in the first four lines we see that Prolog recurses its way ,NA,NA
down the list in its first argument until it can apply the base case of the recursive definition. ,NA,NA
"Then, as the next four lines show, it then stepwise `fills in' the result. How is this `filling in' ",NA,NA
process carried out? By successively instantiating the variables ,NA,NA
_G593,NA,NA
", ",NA,NA
_G590,NA,NA
", ",NA,NA
_G587,NA,NA
", and ",NA,NA
_G518,NA,NA
". But while it's important to grasp this basic pattern, it doesn't tell us all we need to know ",NA,NA
about the way ,NA,NA
append,NA,NA
" works, so let's dig deeper. Here is the search tree for the query ",NA,NA
"append([a,b,c],[1,2,3],X)",NA,NA
" and then we'll work carefully through the steps in the trace, making a ",NA,NA
"careful note of what our goals are, and what the variables are instantiated to. Try to relate this ",NA,NA
to the search tree. ,NA,NA
1.  Goal 1: ,NA,NA
"append([a,b,c],[1,2,3],_G518)",NA,NA
. Prolog matches this to the head of the recursive ,NA,NA
"rule (that is, ",NA,NA
"append([H|T],L2,[H|L3])",NA,NA
). Thus ,NA,NA
_G518,NA,NA
 is matched to ,NA,NA
[a| L3],NA,NA
", and Prolog has ",NA,NA
the new goal ,NA,NA
"append([b,c],[1,2,3],L3)",NA,NA
. It generates a new variable ,NA,NA
_G587,NA,NA
 for ,NA,NA
L3,NA,NA
", thus we ",NA,NA
have that ,NA,NA
_G518 = [a|_G587],NA,NA
. ,NA,NA
2.  Goal 2: ,NA,NA
"append([b,c],[1,2,3],_G587)",NA,NA
". Prolog matches this to the head of the recursive rule, ",NA,NA
thus ,NA,NA
_G587,NA,NA
 is matched to ,NA,NA
[b|L3],NA,NA
", and Prolog has the new goal ",NA,NA
"append ([c],[1,2,3],L3)",NA,NA
. It ,NA,NA
generates the internal variable ,NA,NA
_G590,NA,NA
 for ,NA,NA
L3,NA,NA
", thus we have ",NA,NA
that ,NA,NA
_G587 = [b|_G590],NA,NA
.,NA,NA
3.  Goal 3: ,NA,NA
"append([c],[1,2,3],_G590",NA,NA
"). Prolog matches this to the head of the recursive rule, ",NA,NA
thus ,NA,NA
_G590,NA,NA
 is matched to ,NA,NA
[c|L3],NA,NA
", and Prolog has the new goal ",NA,NA
"append ([],[1,2,3],L3)",NA,NA
. It ,NA,NA
generates the internal variable ,NA,NA
_G593,NA,NA
 for ,NA,NA
L3,NA,NA
", thus we have that ",NA,NA
_G590 = [c|_G593],NA,NA
.,NA,NA
4.  Goal 4: ,NA,NA
"append([],[1,2,3],_G593",NA,NA
"). At last: Prolog can use the base clause (that is, ",NA,NA
"append([],L,L)",NA,NA
"). And in the four successive matching steps, Prolog will obtain answers ",NA,NA
"to Goal 4, Goal 3, Goal 2, and Goal 1. Here's how. ",NA,NA
5.  Answer to Goal 4: ,NA,NA
"append([],[1,2,3],[1,2,3])",NA,NA
. This is because when we match Goal 4 ,NA,NA
"(that is, ",NA,NA
"append([],[1,2,3],_G593)",NA,NA
" to the base clause, ",NA,NA
_G593,NA,NA
 is matched to ,NA,NA
"[1,2,3]",NA,NA
. ,NA,NA
6.  Answer to Goal 3: ,NA,NA
"append([c],[1,2,3],[c,1,2,3])",NA,NA
. Why? Because Goal 3 is ,NA,NA
"append([c],[1,2,3],_G590])",NA,NA
", and ",NA,NA
_G590 = [c|_G593],NA,NA
", and we have just matched ",NA,NA
_G593,NA,NA
 ,NA,NA
to ,NA,NA
"[1,2,3]",NA,NA
. So ,NA,NA
_G590,NA,NA
 is matched to ,NA,NA
"[c,1,2,3]",NA,NA
.,NA,NA
7.  Answer to Goal 2: ,NA,NA
"append([b,c],[1,2,3],[b,c,1,2,3])",NA,NA
. Why? Because Goal 2 is ,NA,NA
"append([b,c],[1,2,3],_G587])",NA,NA
", and ",NA,NA
_G587 = [b|_G590],NA,NA
", and we have just matched ",NA,NA
_G590,NA,NA
 to ,NA,NA
"[c,1,2,3]",NA,NA
. So ,NA,NA
_G587,NA,NA
 is matched to ,NA,NA
"[b,c,1,2,3]",NA,NA
.,NA,NA
8.  Answer to Goal 1: ,NA,NA
"append([a,b,c],[1,2,3],[b,c,1,2,3])",NA,NA
. Why? Because Goal 2 is ,NA,NA
"append([a,b,c],[1,2,3],_G518])",NA,NA
", ",NA,NA
_G518 = [a|_G587],NA,NA
", and we have just matched ",NA,NA
_G587,NA,NA
 to ,NA,NA
"[b,c,1,2,3]",NA,NA
. So ,NA,NA
_G518,NA,NA
 is matched to ,NA,NA
"[a,b,c,1,2,3]",NA,NA
.,NA,NA
9.  Thus Prolog now knows how to instantiate ,NA,NA
X,NA,NA
", the original query variable. It tells us that ",NA,NA
"X = [a,b,c,1,2,3]",NA,NA
", which is what we want.",NA,NA
"Work through this example carefully, and make sure you fully understand the pattern of ",NA,NA
"variable instantiations, namely: ",NA,NA
_G518 = [a|_G587] ,NA,NA
 = [a|[b|_G590]] ,NA,NA
 = [a|[b|[c|_G593]]],NA,NA
"For a start, this type of pattern lies at the heart of the way ",NA,NA
append,NA,NA
" works. Moreover, it ",NA,NA
"illustrates a more general theme: the use of matching to build structure. In a nutshell, the ",NA,NA
recursive calls to append build up this nested pattern of variables which code up the required ,NA,NA
answer. When Prolog finally instantiates the innermost variable ,NA,NA
_G593,NA,NA
 to ,NA,NA
"[1, 2, 3]",NA,NA
", the answer ",NA,NA
"crystallizes out, like a snowflake forming around a grain of dust. But it is matching, not magic, ",NA,NA
that produces the result. ,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node47.html (3 of 4)11/3/2006 7:31:10 PM,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node47.html (4 of 4)11/3/2006 7:31:10 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
6.1.2 Using append,NA,NA
Now that we understand how ,NA,NA
append,NA,NA
" works, let's see how we can put it to work.",NA,NA
One important use of ,NA,NA
append,NA,NA
 is to split up a list into two consecutive lists. For example: ,NA,NA
"append(X,Y,[a,b,c,d]). ",NA,NA
X = [] ,NA,NA
"Y = [a,b,c,d] ; ",NA,NA
X = [a] ,NA,NA
"Y = [b,c,d] ; ",NA,NA
"X = [a,b] ",NA,NA
"Y = [c,d] ; ",NA,NA
"X = [a,b,c] ",NA,NA
Y = [d] ; ,NA,NA
"X = [a,b,c,d] ",NA,NA
Y = [] ; ,NA,NA
no,NA,NA
"That is, we give the list we want to split up (here",NA,NA
"[a,b,c,d]",NA,NA
) to ,NA,NA
append,NA,NA
" as the third argument, ",NA,NA
and we use variables for the first two arguments. Prolog then searches for ways of ,NA,NA
"instantiating the variables to two lists that concatenate to give the third argument, thus ",NA,NA
"splitting up the list in two. Moreover, as this example shows, by backtracking, Prolog can find ",NA,NA
all possible ways of splitting up a list into two consecutive lists.,NA,NA
This ability means it is easy to define some useful predicates with ,NA,NA
append,NA,NA
. Let's consider some ,NA,NA
"examples. First, we can define a program which finds prefixes of lists. For example, the ",NA,NA
prefixes of ,NA,NA
"[a,b,c,d]",NA,NA
 are ,NA,NA
[],NA,NA
", ",NA,NA
[a],NA,NA
", ",NA,NA
"[a,b]",NA,NA
", ",NA,NA
"[a,b,c]",NA,NA
", and ",NA,NA
"[a,b,c,d]",NA,NA
. With the help of ,NA,NA
append,NA,NA
 it is ,NA,NA
straightforward to define a program ,NA,NA
prefix/2,NA,NA
", whose arguments are both lists, such that ",NA,NA
"prefix(P,L)",NA,NA
 will hold when ,NA,NA
P,NA,NA
 is a prefix of ,NA,NA
L,NA,NA
. Here's how: ,NA,NA
"prefix(P,L) :- append(P,_,L).",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node48.html (1 of 3)11/3/2006 7:31:16 PM,NA
This says that list ,NA,NA
P,NA,NA
 is a prefix of list ,NA,NA
L,NA,NA
 when there is some list such that ,NA,NA
L,NA,NA
 is the result of ,NA,NA
concatenating ,NA,NA
P,NA,NA
 with that list. (We use the anonymous variable since we don't care what that ,NA,NA
other list is: we only care that there some such list or other.) This predicate successfully finds ,NA,NA
"prefixes of lists, and moreover, via backtracking, finds them all: ",NA,NA
"prefix(X,[a,b,c,d]). ",NA,NA
X = [] ; ,NA,NA
X = [a] ; ,NA,NA
"X = [a,b] ; ",NA,NA
"X = [a,b,c] ; ",NA,NA
"X = [a,b,c,d] ; ",NA,NA
no,NA,NA
"In a similar fashion, we can define a program which finds suffixes of lists. For example, the ",NA,NA
suffixes of ,NA,NA
"[a,b,c,d]",NA,NA
 are ,NA,NA
[],NA,NA
", ",NA,NA
[d],NA,NA
", ",NA,NA
"[c,d]",NA,NA
", ",NA,NA
"[b,c,d]",NA,NA
", and ",NA,NA
"[a,b,c,d]",NA,NA
". Again, using ",NA,NA
append,NA,NA
 it is easy to ,NA,NA
define ,NA,NA
suffix/2,NA,NA
", a predicate whose arguments are both lists, such that ",NA,NA
"suffix(S,L)",NA,NA
 will hold ,NA,NA
when ,NA,NA
S,NA,NA
 is a suffix of ,NA,NA
L,NA,NA
: ,NA,NA
"suffix(S,L) :- append(_,S,L).",NA,NA
"That is, list ",NA,NA
S,NA,NA
 is a suffix of list ,NA,NA
L,NA,NA
 if there is some list such that ,NA,NA
L,NA,NA
 is the result of concatenating ,NA,NA
that list with ,NA,NA
S,NA,NA
". This predicate successfully finds suffixes of lists, and moreover, via ",NA,NA
"backtracking, finds them all: ",NA,NA
"suffix(X,[a,b,c,d]). ",NA,NA
"X = [a,b,c,d] ; ",NA,NA
"X = [b,c,d] ; ",NA,NA
"X = [c,d] ; ",NA,NA
X = [d] ; ,NA,NA
X = [] ; ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node48.html (2 of 3)11/3/2006 7:31:16 PM,NA
no,NA,NA
Make sure you understand why the results come out in this order.,NA,NA
And now it's very easy to define a program that finds sublists of lists. The sublists of ,NA,NA
"[a,b,c, d]",NA,NA
 ,NA,NA
are ,NA,NA
[],NA,NA
", ",NA,NA
[a],NA,NA
", ",NA,NA
[b],NA,NA
", ",NA,NA
[c],NA,NA
", ",NA,NA
[d],NA,NA
", ",NA,NA
"[a,b]",NA,NA
", ",NA,NA
"[b,c]",NA,NA
", ",NA,NA
"[c,d]",NA,NA
", ",NA,NA
"[d,e]",NA,NA
", ",NA,NA
"[a,b,c]",NA,NA
", ",NA,NA
"[b,c,d]",NA,NA
", and ",NA,NA
"[a,b,c,d]",NA,NA
". Now, a little thought ",NA,NA
reveals that the sublists of a list L are simply the prefixes of suffixes of L. Think about it ,NA,NA
pictorially: ,NA,NA
"And of course, we have both the predicates we need to pin this ideas down: we simply define ",NA,NA
"sublist(SubL,L) :- suffix(S,L),prefix(SubL,S).",NA,NA
"That is, ",NA,NA
SubL,NA,NA
 is a sublist of ,NA,NA
L,NA,NA
 if there is some suffix ,NA,NA
S,NA,NA
 of ,NA,NA
L,NA,NA
 of which ,NA,NA
SubL,NA,NA
 is a prefix. This ,NA,NA
program doesn't explicitly use ,NA,NA
append,NA,NA
", but of course, under the surface, that's what's doing ",NA,NA
"the work for us, as both ",NA,NA
prefix,NA,NA
 and ,NA,NA
suffix,NA,NA
 are defined using ,NA,NA
append,NA,NA
.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
6.2 Reversing a list,NA,NA
"Append is a useful predicate, and it is important to know how to use it. But it is just as ",NA,NA
"important to know that it can be a source of inefficiency, and that you probably don't want to ",NA,NA
use it all the time.,NA,NA
Why is ,NA,NA
append,NA,NA
" a source of inefficiency? If you think about the way it works, you'll notice a ",NA,NA
weakness: ,NA,NA
append,NA,NA
" doesn't join two lists in one simple action. Rather, it needs to work its way ",NA,NA
"down its first argument until it finds the end of the list, and only then can it carry out the ",NA,NA
concatenation.,NA,NA
"Now, often this causes no problems. For example, if we have two lists and we just want to ",NA,NA
"concatenate them, it's probably not too bad. Sure, Prolog will need to work down the length of ",NA,NA
"the first list, but if the list is not too long, that's probably not too high a price to pay for the ",NA,NA
ease of working with ,NA,NA
append,NA,NA
.,NA,NA
But matters may be very different if the first two arguments are given as variables. As we've ,NA,NA
"just seen, it can be very useful to give ",NA,NA
append,NA,NA
" variables in its first two arguments, for this lets ",NA,NA
Prolog search for ways of splitting up the lists. But there is a price to pay: a lot of search is ,NA,NA
"going on, and this can lead to very inefficient programs.",NA,NA
"To illustrate this, we shall examine the problem of reversing a list. That is, we will examine the ",NA,NA
problem of defining a predicate which takes a list (say ,NA,NA
"[a,b,c,d]",NA,NA
) as input and returns a list ,NA,NA
containing the same elements in the reverse order (here ,NA,NA
"[d,c,b,a]",NA,NA
).,NA,NA
"Now, a ",NA,NA
reverse,NA,NA
 predicate is a useful predicate to have around. As you will have realized by ,NA,NA
"now, lists in Prolog are far easier to access from the front than from the back. For example, to ",NA,NA
pull out the head of a list ,NA,NA
L,NA,NA
", all we have to do is perform the unification ",NA,NA
[H|_] = L,NA,NA
; this results in ,NA,NA
H,NA,NA
 being instantiated to the head of ,NA,NA
L,NA,NA
. But pulling out the last element of an arbitrary list is ,NA,NA
"harder: we can't do it simply using unification. On the other hand, if we had a predicate which ",NA,NA
"reversed lists, we could first reverse the input list, and then pull out the head of the reversed ",NA,NA
"list, as this would give us the last element of the original list. So a ",NA,NA
reverse ,NA,NA
"predicate could be a useful tool. However, as we may have to reverse large lists, we would like ",NA,NA
this tool to be efficient. So we need to think about the problem carefully.,NA,NA
"And that's what we're going to do now. We will define two reverse predicates: a naive one, ",NA,NA
defined with the help of ,NA,NA
append,NA,NA
", and a more efficient (and indeed, more natural) one defined ",NA,NA
using accumulators.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node49.html (1 of 2)11/3/2006 7:31:21 PM,NA
6.2.1 Naive reverse using append,G,NA
6.2.2 Reverse using an accumulator,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
6.2.1 Naive reverse using append,NA,NA
Here's a recursive definition of what is involved in reversing a list: ,NA,NA
"1.  If we reverse the empty list, we obtain the empty list.",NA,NA
2.  If we reverse the list ,NA,NA
[H|T],NA,NA
", we end up with the list obtained by reversing ",NA,NA
T,NA,NA
 and ,NA,NA
concatenating with ,NA,NA
[H],NA,NA
.,NA,NA
"To see that the recursive clause is correct, consider the list ",NA,NA
"[a,b,c,d]",NA,NA
. If we reverse the tail of ,NA,NA
this list we obtain ,NA,NA
"[d,c,b]",NA,NA
. Concatenating this with ,NA,NA
[a],NA,NA
 yields ,NA,NA
"[d,c,b,a]",NA,NA
", which is the reverse of ",NA,NA
"[a,b,c,d]",NA,NA
.,NA,NA
With the help of ,NA,NA
append,NA,NA
 it is easy to turn this recursive definition into Prolog: ,NA,NA
"naiverev([],[]). ",NA,NA
"naiverev([H|T],R) :- naiverev(T,RevT),append(RevT,[H],R).",NA,NA
"Now, this definition is correct, but it is does an awful lot of work. It is very instructive to look at ",NA,NA
a trace of this program. This shows that the program is spending a lot of time carrying out ,NA,NA
"appends. This shouldn't be too surprising: after, all, we are calling ",NA,NA
append,NA,NA
 recursively. The ,NA,NA
"result is very inefficient (if you run a trace, you will find that it takes about 90 steps to reverse ",NA,NA
an eight element list) and hard to understand (the predicate spends most of it time in the ,NA,NA
recursive calls to ,NA,NA
append,NA,NA
", making it very hard to see what is going on).",NA,NA
"Not nice. And as we shall now see, there is a better way.",NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
6.2.2 Reverse using an accumulator,NA,NA
The better way is to use an accumulator. The underlying idea is simple and natural. Our ,NA,NA
"accumulator will be a list, and when we start it will be empty. Suppose we want to reverse ",NA,NA
"[a, ",NA,NA
"b,c,d]",NA,NA
". At the start, our accumulator will be ",NA,NA
[],NA,NA
. So we simply take the head of the list we are ,NA,NA
trying to reverse and add it as the head of the accumulator. We then carry on processing the ,NA,NA
"tail, thus we are faced with the task of reversing ",NA,NA
"[b,c,d]",NA,NA
", and our accumulator is ",NA,NA
[a],NA,NA
. ,NA,NA
Again we take the head of the list we are trying to reverse and add it as the head of the ,NA,NA
"accumulator (thus our new accumulator is [b,a]) and carry on trying to reverse ",NA,NA
"[c,d]",NA,NA
. Again we ,NA,NA
"use the same idea, so we get a new accumulator ",NA,NA
"[c,b,a]",NA,NA
", and try to reverse ",NA,NA
[d],NA,NA
. Needless to ,NA,NA
"say, the next step yields an accumulator ",NA,NA
"[d,c,b,a]",NA,NA
 and the new goal of trying to reverse ,NA,NA
[],NA,NA
. This ,NA,NA
is where the process stops: and our accumulator contains the reversed list we want. To ,NA,NA
"summarize: the idea is simply to work our way through the list we want to reverse, and push ",NA,NA
"each element in turn onto the head of the accumulator, like this: ",NA,NA
"List: [a,b,c,d]  Accumulator: [] ",NA,NA
"List: [b,c,d]    Accumulator: [a] ",NA,NA
"List: [c,d]      Accumulator: [b,a] List: [d]        ",NA,NA
"Accumulator: [c,b,a] List: []         Accumulator: [d,c,b,a]",NA,NA
This will be efficient because we simply blast our way through the list once: we don't have to ,NA,NA
waste time carrying out concatenation or other irrelevant work.,NA,NA
It's also easy to put this idea in Prolog. Here's the accumulator code: ,NA,NA
"accRev([H|T],A,R) :- accRev(T,[H|A],R). accRev([],A,A).",NA,NA
This is classic accumulator code: it follows the same pattern as the arithmetic examples we ,NA,NA
examined in the previous lecture. The recursive clause is responsible for chopping of the head ,NA,NA
"of the input list, and pushing it onto the accumulator. The base case halts the program, and ",NA,NA
copies the accumulator to the final argument.,NA,NA
"As is usual with accumulator code, it's a good idea to write a predicate which carries out the ",NA,NA
required initialization of the accumulator for us: ,NA,NA
"rev(L,R) :- accRev(L,[],R).",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node51.html (1 of 2)11/3/2006 7:31:34 PM,NA
"Again, it is instructive to run some traces on this program and compare it with ",NA,NA
naiverev,NA,NA
. ,NA,NA
"The accumulator based version is clearly better. For example, it takes about 20 steps to reverse ",NA,NA
"an eight element list, as opposed to 90 for the naive version. Moreover, the trace is far easier ",NA,NA
to follow. The idea underlying the accumulator based version is simpler and more natural than ,NA,NA
the recursive calls to ,NA,NA
append,NA,NA
. ,NA,NA
"Summing up, ",NA,NA
append,NA,NA
" is a useful program, and you certainly should not be scared of using it. ",NA,NA
"However you also need to be aware that it is a source of inefficiency, so when you use it, ask ",NA,NA
yourself whether there is a better way. And often there are. The use of accumulators is often ,NA,NA
"better, and (as the ",NA,NA
reverse,NA,NA
 example show) accumulators can be a natural way of handling list ,NA,NA
"processing tasks. Moreover, as we shall learn later in the course, there are more ",NA,NA
sophisticated ways of thinking about lists (namely by viewing them as difference lists) which ,NA,NA
can also lead to dramatic improvements in performance.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
6.3 Exercises,NA,NA
Exercise 6.1,NA,NA
Let's call a list doubled if it is made of two consecutive blocks of elements that are ,NA,NA
"exactly the same. For example, ",NA,NA
"[a,b,c,a,b,c]",NA,NA
 is doubled (it's made up of ,NA,NA
"[a,b,c]",NA,NA
followed by ,NA,NA
"[a,b,c]",NA,NA
) and so is ,NA,NA
"[foo,gubble,foo,gubble]",NA,NA
". On the other hand, ",NA,NA
"[foo,gubble,foo]",NA,NA
 is not doubled. Write a predicate ,NA,NA
doubled (List),NA,NA
 which succeeds ,NA,NA
when ,NA,NA
List,NA,NA
 is a doubled list.,NA,NA
Exercise 6.2,NA,NA
A palindrome is a word or phrase that spells the same forwards and backwards. ,NA,NA
"For example, `rotator', `eve', and `nurses run' are all palindromes. Write a ",NA,NA
predicate ,NA,NA
palindrome(List),NA,NA
", which checks whether ",NA,NA
List,NA,NA
 is a palindrome. For ,NA,NA
"example, to the queries ",NA,NA
"?- palindrome([r,o,t,a,t,o,r]).",NA,NA
and ,NA,NA
"?- palindrome([n,u,r,s,e,s,r,u,n]).",NA,NA
"Prolog should respond `yes', but to the query ",NA,NA
"?- palindrome([n,o,t,h,i,s]).",NA,NA
Prolog should respond `no'.,NA,NA
Exercise 6.3,NA,NA
1.  Write a predicate ,NA,NA
"second(X,List)",NA,NA
 which checks whether ,NA,NA
X,NA,NA
 is the second ,NA,NA
element of ,NA,NA
List,NA,NA
.,NA,NA
2.  Write a predicate ,NA,NA
"swap12(List1,List2)",NA,NA
 which checks whether ,NA,NA
List1 ,NA,NA
is ,NA,NA
identical to ,NA,NA
List2,NA,NA
", except that the first two elements are exchanged. 3.  Write ",NA,NA
a predicate ,NA,NA
"final(X,List)",NA,NA
 which checks whether ,NA,NA
X,NA,NA
 is the last ,NA,NA
element of ,NA,NA
List,NA,NA
.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node52.html (1 of 3)11/3/2006 7:31:40 PM,NA
4.  Write a predicate ,NA,NA
"toptail(InList,Outlist)",NA,NA
 which says `no' if ,NA,NA
inlist,NA,NA
 is a list ,NA,NA
"containing fewer than 2 elements, and which deletes the first and the last ",NA,NA
elements of ,NA,NA
Inlist,NA,NA
 and returns the result as ,NA,NA
Outlist,NA,NA
", when ",NA,NA
Inlist,NA,NA
 is a list ,NA,NA
containing at least 2 elements. For example: ,NA,NA
" toptail([a],T). ",NA,NA
 no ,NA,NA
" toptail([a,b],T). ",NA,NA
 T=[] ,NA,NA
" toptail([a,b,c],T). ",NA,NA
 T=[b] ,NA,NA
Hint: here's where ,NA,NA
append,NA,NA
 comes in useful.,NA,NA
5.  Write a predicate ,NA,NA
"swapfl(List1,List2)",NA,NA
 which checks whether ,NA,NA
List1 ,NA,NA
is ,NA,NA
identical to ,NA,NA
List2,NA,NA
", except that the first and last elements are ",NA,NA
exchanged. Hint: here's where ,NA,NA
append,NA,NA
 comes in useful again.,NA,NA
Exercise 6.4,NA,NA
"And here is an exercise for those of you who, like me, like logic puzzles. ",NA,NA
There is a street with three neighboring houses that all have a different color. ,NA,NA
"They are red, blue, and green. People of different nationalities live in the different ",NA,NA
houses and they all have a different pet. Here are some more facts about them: ,G,NA
The Englishman lives in the red house.,G,NA
The jaguar is the pet of the Spanish family.,G,NA
The Japanese lives to the right of the snail keeper. ,G,NA
The snail keeper lives to the left of the blue house.,NA,NA
Who keeps the zebra?,NA,NA
Define a predicate ,NA,NA
zebra/1,NA,NA
 that tells you the nationality of the owner of the ,NA,NA
zebra.,NA,NA
Hint: Think of a representation for the houses and the street. Code the four ,NA,NA
constraints in Prolog. ,NA,NA
member,NA,NA
 and ,NA,NA
sublist,NA,NA
 might be useful predicates. ,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
6.4 Practical Session 6,NA,NA
The purpose of Practical Session 6 is to help you get more experience with list manipulation. ,NA,NA
"We first suggest some traces for you to carry out, and then some programming exercises.",NA,NA
The following traces will help you get to grips with the predicates discussed in the text: ,NA,NA
1.  Carry out traces of ,NA,NA
append,NA,NA
" with the first two arguments instantiated, and the third ",NA,NA
"argument uninstantiated. For example, ",NA,NA
"append([a,b,c],[[],[2,3],b],X)",NA,NA
 Make sure the basic ,NA,NA
pattern is clear.,NA,NA
"2.  Next, carry out traces on ",NA,NA
append,NA,NA
" as used to split up a list, that is, with the first two ",NA,NA
"arguments given as variables, and the last argument instantiated. For example, ",NA,NA
append ,NA,NA
"(L,R,[foo,wee,blup]).",NA,NA
3.  Carry out some traces on ,NA,NA
prefix,NA,NA
 and ,NA,NA
suffix,NA,NA
. Why does ,NA,NA
prefix,NA,NA
 find shorter lists ,NA,NA
"first, ",NA,NA
and ,NA,NA
suffix,NA,NA
 longer lists first?,NA,NA
4.  Carry out some traces on ,NA,NA
sublist,NA,NA
". As we said in the text, via backtracking this predicate ",NA,NA
"generates all possible sublists, but as you'll see, it generates several sublists more than ",NA,NA
once. Do you understand why?,NA,NA
5.  Carry out traces on both ,NA,NA
naiverev,NA,NA
 and ,NA,NA
rev,NA,NA
", and compare their behavior.",NA,NA
Now for some programming work: ,NA,NA
1.  It is possible to write a one line definition of the ,NA,NA
member,NA,NA
 predicate by making use of ,NA,NA
append,NA,NA
. Do so. How does this new version of ,NA,NA
member,NA,NA
 compare in efficiency with the ,NA,NA
standard one?,NA,NA
2.  Write a predicate ,NA,NA
"set(InList,OutList)",NA,NA
" which takes as input an arbitrary list, and returns ",NA,NA
"a list in which each element of the input list appears only once. For example, the query ",NA,NA
"set([2,2,foo,1,foo, [],[]],X). ",NA,NA
should yield the result ,NA,NA
"X = [2,foo,1,[]].",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node53.html (1 of 2)11/3/2006 7:31:47 PM,NA
Hint: use the ,NA,NA
member,NA,NA
 predicate to test for repetitions of items you have already found. ,NA,NA
3.  We `flatten' a list by removing all the square brackets around any lists it contains as ,NA,NA
"elements, and around any lists that its elements contain as element, and so on for all ",NA,NA
"nested lists. For example, when we flatten the list ",NA,NA
"[a,b,[c,d],[[1,2]],foo]",NA,NA
we get the list ,NA,NA
"[a,b,c,d,1,2,foo]",NA,NA
and when we flatten the list ,NA,NA
"[a,b,[[[[[[[c,d]]]]]]],[[1,2]],foo,[]]",NA,NA
we also get ,NA,NA
"[a,b,c,d,1,2,foo].",NA,NA
Write a predicate ,NA,NA
"flatten(List,Flat)",NA,NA
 that holds when the first argument ,NA,NA
List ,NA,NA
flattens to the ,NA,NA
second argument ,NA,NA
Flat,NA,NA
. This exercise can be done without making use of ,NA,NA
append,NA,NA
.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node53.html (2 of 2)11/3/2006 7:31:47 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
7 Definite Clause Grammars,NA,NA
This lecture has two main goals: ,NA,NA
1.  To introduce context free grammars (CFGs) and some related concepts.,NA,NA
"2.  To introduce definite clause grammars (DCGs), an in-built Prolog mechanism for ",NA,NA
working with context free grammars (and other kinds of grammar too).,G,NA
7.1 Context free grammars ,H,NA
7.1.1 CFG recognition using append ,H,NA
7.1.2 CFG recognition using difference lists,G,NA
7.2 Definite clause grammars ,H,NA
7.2.1 A first example ,H,NA
7.2.2 Adding recursive rules ,H,NA
7.2.3 A DCG for a simple formal language,G,NA
7.3 Exercises,G,NA
7.4 Practical Session 7,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
7.1 Context free grammars,NA,NA
"Prolog has been used for many purposes, but its inventor, Alain Colmerauer, was a ",NA,NA
"computational linguist, and computational linguistics remains a classic application for the ",NA,NA
"language. Moreover, Prolog offers a number of tools which make life easier for computational ",NA,NA
"linguists, and today we are going to start learning about one of the most useful of these: ",NA,NA
"Definite Clauses Grammars, or DCGs as they are usually called. ",NA,NA
"DCGs are a special notation for defining grammars. So, before we go any further, we'd better ",NA,NA
learn what a grammar is. We shall do so by discussing context free grammars (or CFGs). The ,NA,NA
"basic idea of context free grammars is simple to understand, but don't be fooled into thinking ",NA,NA
that CFGs are toys. They're not. While CFGs aren't powerful enough to cope with the syntactic ,NA,NA
"structure of all natural languages (that is, the kind of languages that human beings use), they ",NA,NA
"can certainly handle most aspects of the syntax of many natural languages (for example, ",NA,NA
"English, German, and French) in a reasonably natural way.",NA,NA
"So what is a context free grammar? In essence, a finite collection of rules which tell us that ",NA,NA
"certain sentences are grammatical (that is, syntactically correct) and what their grammatical ",NA,NA
structure actually is. Here's a simple context free grammar for a small fragment of English: ,NA,NA
s -> np vp,NA,NA
np -> det n,NA,NA
vp -> v np,NA,NA
vp -> v,NA,NA
det ->,NA,NA
 a,NA,NA
det ->,NA,NA
 the,NA,NA
n ->,NA,NA
 woman,NA,NA
n ->,NA,NA
 man,NA,NA
v ->,NA,NA
 shoots,NA,NA
"What are the ingredients of this little grammar? Well, first note that it contains three types of ",NA,NA
symbol. There's ,NA,NA
->,NA,NA
", which is used to define the rules. Then there are the symbols written like ",NA,NA
this: ,NA,NA
s,NA,NA
", ",NA,NA
np,NA,NA
", ",NA,NA
vp,NA,NA
", ",NA,NA
det,NA,NA
", ",NA,NA
n,NA,NA
", ",NA,NA
v,NA,NA
. These symbols are called non-terminal symbols; we'll soon learn why. ,NA,NA
Each of these symbols has a traditional meaning in linguistics: ,NA,NA
s,NA,NA
" is short for sentence, ",NA,NA
np ,NA,NA
is ,NA,NA
"short for noun phrase, ",NA,NA
vp,NA,NA
" is short for verb phrase, and ",NA,NA
det,NA,NA
" is short for determiner. That is, ",NA,NA
each of these symbols is shorthand for a grammatical category. Finally there are the symbols ,NA,NA
"in italics: a, the, woman, man, and shoots. A computer scientist would probably call these ",NA,NA
"terminal symbols (or: the alphabet), and linguists would probably call them lexical items. We'll ",NA,NA
"use these terms occasionally, but often we'll make life easy for ourselves and just call them ",NA,NA
words.,NA,NA
"Now, this grammar contains nine rules. A context free rule consists of a single non-terminal ",NA,NA
"symbol, followed by ",NA,NA
->,NA,NA
", followed by a finite sequence made up of terminal and/or non-terminal ",NA,NA
"symbols. All nine items listed above have this form, so they are all legitimate context free rules. ",NA,NA
What do these rules mean? They tell us how different grammatical categories can be built up. ,NA,NA
Read ,NA,NA
->,NA,NA
" as can consist of, or can be built out of. For example, the first rule tells us that a ",NA,NA
sentence can consist of a noun phrase followed by a verb phrase. The third rule tells us that a ,NA,NA
"verb phrase can consist of a verb followed by a noun phrase, while the fourth rule tells us that ",NA,NA
there is another way to build a verb phrase: simply use a verb. The last five rules tell us that a ,NA,NA
"and the are determiners, that man and woman are nouns, and that shoots is a verb.",NA,NA
"Now, consider the string of words a woman shoots a man. Is this grammatical according to ",NA,NA
"our little grammar? And if it is, what structure does it have? The following tree answers both ",NA,NA
questions: ,NA,NA
Right at the top we have a node marked ,NA,NA
s,NA,NA
". This node has two daughters, one marked ",NA,NA
np,NA,NA
", and ",NA,NA
one marked ,NA,NA
vp,NA,NA
". Note that this part of the diagram agrees with the first rule of the grammar, ",NA,NA
which says that an ,NA,NA
s,NA,NA
 can be built out of an ,NA,NA
np,NA,NA
 and a ,NA,NA
vp,NA,NA
. (A linguist would say that this part of ,NA,NA
"the tree is licensed by the first rule.) In fact, as you can see, every part of the tree is licensed ",NA,NA
"by one of our rules. For example, the two nodes marked ",NA,NA
np,NA,NA
 are licensed by the rule that says ,NA,NA
that an ,NA,NA
np,NA,NA
 can consist of a ,NA,NA
det,NA,NA
 followed by an ,NA,NA
n,NA,NA
". And, right at the bottom of the diagram, all ",NA,NA
"the words in a woman shoots a man are licensed by a rule. Incidentally, note that the terminal ",NA,NA
symbols only decorate the nodes right at the bottom of the tree (the terminal nodes) while ,NA,NA
non-terminal symbols only decorate nodes that are higher up in the tree (the non-terminal ,NA,NA
nodes).,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node55.html (2 of 4)11/3/2006 7:32:04 PM,NA
"Such a tree is called a parse tree, and it gives us two sorts of information: information about ",NA,NA
"strings and information about structure. This is an important distinction to grasp, so let's have ",NA,NA
"a closer look, and learn some important terminology while we are doing so.",NA,NA
"First, if we are given a string of words, and a grammar, and it turns out that we can build a ",NA,NA
"parse tree like the one above (that is, a tree that has ",NA,NA
s,NA,NA
" at the top node, and every node in the ",NA,NA
"tree is licensed by the grammar, and the string of words we were given is listed in the correct ",NA,NA
order along the terminal nodes) then we say that the string is grammatical (according to the ,NA,NA
"given grammar). For example, the string a woman shoots a man is grammatical according to ",NA,NA
"our little grammar (and indeed, any reasonable grammar of English would classify it as ",NA,NA
"grammatical). On the other hand, if there isn't any such tree, the string is ungrammatical ",NA,NA
"(according to the given grammar). For example, the string woman a woman man a shoots is ",NA,NA
ungrammatical according to our little grammar (and any reasonable grammar of English would ,NA,NA
classify it as ungrammatical). The language generated by a grammar consists of all the strings ,NA,NA
"that the grammar classifies as grammatical. For example, a woman shoots a man also belongs ",NA,NA
"to the language generated by our little grammar, and so does a man shoots the woman. A ",NA,NA
context free recognizer is a program which correctly tells us whether or not a string belongs to ,NA,NA
"the language generated by a context free grammar. To put it another way, a recognizer is a ",NA,NA
program that correctly classifies strings as grammatical or ungrammatical (relative to some ,NA,NA
grammar). ,NA,NA
"But often, in both linguistics and computer science, we are not merely interested in whether a ",NA,NA
"string is grammatical or not, we want to know why it is grammatical. More precisely, we often ",NA,NA
"want to know what its structure is, and this is exactly the information a parse tree gives us. ",NA,NA
"For example, the above parse tree shows us how the words in a woman shoots a man fit ",NA,NA
"together, piece by piece, to form the sentence. This kind of information would be important if ",NA,NA
we were using this sentence in some application and needed to say what it actually meant ,NA,NA
"(that is, if we wanted to do semantics). A context free parser is a program which correctly ",NA,NA
decides whether a string belongs to the language generated by a context free grammar and ,NA,NA
"also tells us hat its structure is. That is, whereas a recognizer merely says `Yes, grammatical' ",NA,NA
"or `No, ungrammatical' to each string, a parser actually builds the associated parse tree and ",NA,NA
gives it to us.,NA,NA
"It remains to explain one final concept, namely what a context free language is. (Don't get ",NA,NA
"confused: we've told you what a context free grammar is, but not what a context free ",NA,NA
"language is.) Quite simply, a context free language is a language that can be generated by a ",NA,NA
"context free grammar. Some languages are context free, and some are not. For example, it ",NA,NA
"seems plausible that English is a context free language. That is, it is probably possible to write ",NA,NA
a context free grammar that generates all (and only) the sentences that native speakers find ,NA,NA
"acceptable. On the other hand, some dialects of Swiss-German are not context free. It can be ",NA,NA
proved mathematically that no context free grammar can generate all (and only) the ,NA,NA
sentences that native speakers find acceptable. So if you wanted to write a grammar for such ,NA,NA
"dialects, you would have to employ additional grammatical mechanisms, not merely context ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node55.html (3 of 4)11/3/2006 7:32:04 PM,NA
free rules.,G,NA
7.1.1 CFG recognition using append,G,NA
7.1.2 CFG recognition using difference lists,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
7.1.1 CFG recognition using append,NA,NA
"That's the theory, but how do we work with context free grammars in Prolog? To make things ",NA,NA
concrete: suppose we are given a context free grammar. How can we write a recognizer for it? ,NA,NA
And how can we write a parser for it? This week we'll look at the first question in detail. We'll ,NA,NA
"first show how (rather naive) recognizers can be written in Prolog, and then show how more ",NA,NA
sophisticated recognizers can be written with the help of difference lists. This discussion will ,NA,NA
"lead us to definite clause grammars, Prolog's inbuilt grammar tool. Next week we'll look at ",NA,NA
"definite clause grammars in more detail, and learn (among other things) how to use them to ",NA,NA
define parsers.,NA,NA
"So: given a context free grammar, how do we define a recognizer in Prolog? In fact, Prolog ",NA,NA
offers a very direct answer to this question: we can simply write down Prolog clauses that ,NA,NA
"correspond, in an obvious way, to the grammar rules. That is, we can simply `turn the ",NA,NA
grammar into Prolog'.,NA,NA
"Here's a simple (though as we shall learn, inefficient) way of doing this. We shall use lists to ",NA,NA
"represent strings. For example, the string a woman shoots a man will be represented by the list ",NA,NA
 ,NA,NA
"[a,woman,shoots,a,man]",NA,NA
". Now, we have already said that the ",NA,NA
->,NA,NA
 symbol used in context free ,NA,NA
"grammars means can consist of, or can be built out of, and this idea is easily modeled using ",NA,NA
"lists. For example, the rule ",NA,NA
s -> np vp,NA,NA
 can be thought of as saying: a list of words is an ,NA,NA
s,NA,NA
 list if it ,NA,NA
is the result of concatenating an ,NA,NA
np,NA,NA
 list with a ,NA,NA
vp,NA,NA
 list. As we know how to concatenate lists in ,NA,NA
Prolog (we can use ,NA,NA
append,NA,NA
"), it should be easy to turn these kinds of rules into Prolog. And ",NA,NA
what about the rules that tell us about individual words? Even easier: we can simply view ,NA,NA
n ->,NA,NA
 ,NA,NA
woman as saying that the list ,NA,NA
[woman],NA,NA
 is an ,NA,NA
n,NA,NA
 list.,NA,NA
"If we turn these ideas into Prolog, this is what we get: ",NA,NA
"s(Z) :- np(X), vp(Y), append(X,Y,Z). ",NA,NA
"np(Z) :- det(X), n(Y), append(X,Y,Z). ",NA,NA
"vp(Z) :-  v(X), np(Y), append(X,Y,Z). ",NA,NA
vp(Z) :-  v(Z). ,NA,NA
det([the]). ,NA,NA
det([a]). ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node56.html (1 of 4)11/3/2006 7:32:09 PM,NA
n([woman]). ,NA,NA
n([man]). ,NA,NA
v([shoots]).,NA,NA
The correspondence between the CFG rules and the Prolog should be clear. And to use this ,NA,NA
"program as a recognizer, we simply pose the obvious queries. For example: ",NA,NA
"s([a,woman,shoots,a,man]). ",NA,NA
yes,NA,NA
"In fact, because this is a simple declarative Prolog program, we can do more than this: we can ",NA,NA
"also generate all the sentences this grammar produces. In fact, our little grammar generates ",NA,NA
20 sentences. Here are the first five: ,NA,NA
s(X). ,NA,NA
"X = [the,woman,shoots,the,woman] ; ",NA,NA
"X = [the,woman,shoots,the,man] ; ",NA,NA
"X = [the,woman,shoots,a,woman] ; ",NA,NA
"X = [the,woman,shoots,a,man] ; ",NA,NA
"X = [the,woman,shoots]",NA,NA
"Moreover, we're not restricted to posing questions about sentences: we can ask about other ",NA,NA
grammatical categories. For example: ,NA,NA
"np([a,woman]). ",NA,NA
yes,NA,NA
And we can generate noun phrases with the following query. ,NA,NA
np(X).,NA,NA
"Now this is rather nice. We have a simple, easy to understand program which corresponds ",NA,NA
"with our CFG in an obvious way. Moreover, if we added more rules to our CFG, it would be ",NA,NA
easy to alter the program to cope with the new rules.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node56.html (2 of 4)11/3/2006 7:32:09 PM,NA
But there is a problem: the program doesn't use the input sentence to guide the search. Make ,NA,NA
a trace for the query ,NA,NA
"s([a,man,shoots])",NA,NA
 and you will see that the program ``guesses'' noun ,NA,NA
phrases and verb phrases and then afterwards checks whether these can be combined to form ,NA,NA
the sentence ,NA,NA
"[a,man,shoots]",NA,NA
. Prolog will find that ,NA,NA
"[the,woman]",NA,NA
 is a noun phrase and ,NA,NA
"[shoots,the,woman]",NA,NA
 a verb phrase and then it will check whether concatenating these two lists ,NA,NA
happens to yield ,NA,NA
"[a,man,shoots]",NA,NA
", which of course fails. So, Prolog starts to backtrack and the ",NA,NA
next thing it will try is whether concatenating the noun phrase ,NA,NA
"[the, woman]",NA,NA
 and the verb ,NA,NA
phrase ,NA,NA
"[shoots,the,man]",NA,NA
 happens to yield ,NA,NA
"[a,man,shoots]",NA,NA
. It will go on like this until it finally ,NA,NA
produces the noun phrase ,NA,NA
"[the,man]",NA,NA
 and the verb phrase ,NA,NA
[shoots],NA,NA
". The problem obviously is, ",NA,NA
that the goals ,NA,NA
np(X),NA,NA
 and ,NA,NA
vp(Y),NA,NA
 are called with uninstantiated variables as arguments.,NA,NA
"So, how about changing the rules in such a way that ",NA,NA
append,NA,NA
 becomes the first goal: ,NA,NA
"s(Z) :- append(X,Y,Z), np(X), vp(Y). ",NA,NA
"np(Z) :- append(X,Y,Z), det(X), n(Y). ",NA,NA
"vp(Z) :-  append(X,Y,Z), v(X), np(Y). ",NA,NA
vp(Z) :-  v(Z). ,NA,NA
det([the]). ,NA,NA
det([a]). ,NA,NA
n([woman]). ,NA,NA
n([man]). ,NA,NA
v([shoots]).,NA,NA
"Now, we first use append to split up the input list. This instantiates the varibales ",NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
", so ",NA,NA
"that the other goals are all called with instantiated arguments. However, the program is still not ",NA,NA
perfect: it uses ,NA,NA
append,NA,NA
" a lot and, even worse, it uses ",NA,NA
append,NA,NA
 with uninstantiated variables in ,NA,NA
the first two arguments. We saw in the previous chapter that that is a source of inefficiency. ,NA,NA
"And indeed, the performance of this recognizer is very bad. It is revealing to trace through ",NA,NA
what actually happens when this program analyses a sentence such as a woman shoots a man. ,NA,NA
"As you will see, relatively few of the steps are devoted to the real task of recognizing the ",NA,NA
sentences: most are devoted to using ,NA,NA
append,NA,NA
 to decompose lists. This isn't much of a problem ,NA,NA
"for our little grammar, but it certainly would be if we were working with a more realistic ",NA,NA
grammar capable of generating a large number of sentences. We need to do something about ,NA,NA
this.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node56.html (3 of 4)11/3/2006 7:32:09 PM,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
7.1.2 CFG recognition using difference lists,NA,NA
A more efficient implementation can be obtained by making use of difference lists. This is a ,NA,NA
"sophisticated (and, once you've understood it, beautiful) Prolog technique that can be used for ",NA,NA
a variety of purposes. We won't discuss the idea of difference lists in any depth: we'll simply ,NA,NA
show how they can be used to rewrite our recognizer more efficiently.,NA,NA
The key idea underlying difference lists is to represent the information about grammatical ,NA,NA
"categories not as a single list, but as the difference between two lists. For example, instead of ",NA,NA
representing a woman shoots a man as ,NA,NA
"[a,woman,shoots,a,man]",NA,NA
 we might represent it as the ,NA,NA
pair of lists ,NA,NA
"[a,woman,shoots,a,man] []. ",NA,NA
"Think of the first list as what needs to be consumed (or if you prefer: the input list), and the ",NA,NA
second list as what we should leave behind (or: the output list). Viewed from this (rather ,NA,NA
procedural) perspective the difference list ,NA,NA
"[a,woman,shoots,a,man] []. ",NA,NA
represents the sentence a woman shoots a man because it says: If I consume all the symbols ,NA,NA
"on the left, and leave behind the symbols on the right, I have the sentence I am interested in. ",NA,NA
That is: the sentence we are interested in is the difference between the contents of these two ,NA,NA
lists.,NA,NA
"Difference representations are not unique. In fact, we could represent a woman shoots a man ",NA,NA
"in infinitely many ways. For example, we could also represent it as ",NA,NA
"[a,woman,shoots,a,man,ploggle,woggle]  [ploggle,woggle].",NA,NA
"Again the point is: if we consume all the symbols on the left, and leave behind the symbols on ",NA,NA
"the right, we have the sentence we are interested in.",NA,NA
That's all we need to know about difference lists to rewrite our recognizer. If we bear the idea ,NA,NA
"of `consuming something, and leaving something behind' in mind', we obtain the following ",NA,NA
recognizer: ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node57.html (1 of 3)11/3/2006 7:32:16 PM,NA
"s(X,Z) :- np(X,Y), vp(Y,Z). ",NA,NA
"np(X,Z) :- det(X,Y), n(Y,Z). ",NA,NA
"vp(X,Z) :-  v(X,Y), np(Y,Z). ",NA,NA
"vp(X,Z) :-  v(X,Z). ",NA,NA
"det([the|W],W). ",NA,NA
"det([a|W],W). ",NA,NA
"n([woman|W],W). ",NA,NA
"n([man|W],W). ",NA,NA
"v([shoots|W],W).",NA,NA
The ,NA,NA
s,NA,NA
 rule says: I know that the pair of lists ,NA,NA
X,NA,NA
 and ,NA,NA
Z,NA,NA
 represents a sentence if (1) I can consume ,NA,NA
X,NA,NA
 and leave behind a ,NA,NA
Y,NA,NA
", and the pair ",NA,NA
  X,NA,NA
 and ,NA,NA
Y,NA,NA
" represents a noun phrase, and (2) I can then go ",NA,NA
on to consume ,NA,NA
Y,NA,NA
" leaving Z behind, and the pair ",NA,NA
YZ,NA,NA
 represents a verb phrase.,NA,NA
The idea underlying the way we handle the words is similar. The code ,NA,NA
"n([man|W],W).",NA,NA
means we are handling man as the difference between ,NA,NA
[man|W],NA,NA
 and ,NA,NA
W,NA,NA
". Intuitively, the ",NA,NA
difference between what I consume and what I leave behind is precisely the word ,NA,NA
man,NA,NA
.,NA,NA
"Now, at first this is probably harder to grasp than our previous recognizer. But we have gained ",NA,NA
something important: we haven't used ,NA,NA
append,NA,NA
". In the difference list based recognizer, they ",NA,NA
"simply aren't needed, and as we shall see, this makes a big difference.",NA,NA
How do we use such grammars? Here's how to recognize sentences: ,NA,NA
"s([a,woman,shoots,a,man],[]). ",NA,NA
yes,NA,NA
This asks whether we can get an ,NA,NA
s,NA,NA
 by consuming the symbols in ,NA,NA
"[a,woman,shoots,a, man]",NA,NA
", ",NA,NA
leaving nothing behind.,NA,NA
"Similarly, to generate all the sentences in the grammar, we ask ",NA,NA
"s(X,[]).",NA,NA
This asks: what values can you give to ,NA,NA
X,NA,NA
", such that we get an ",NA,NA
s,NA,NA
 by consuming the symbols in ,NA,NA
X,NA,NA
", leaving nothing behind?",NA,NA
"The queries for other grammatical categories also work the same way. For example, to find ",NA,NA
out if a woman is a noun phrase we ask: ,NA,NA
"np([a,woman],[]).",NA,NA
And we generate all the noun phrases in the grammar as follows: ,NA,NA
"np(X,[]).",NA,NA
You should trace what happens when this program analyses a sentence such as a woman ,NA,NA
"shoots a man. As you will see, it is a lot more efficient than our ",NA,NA
append,NA,NA
 based program. ,NA,NA
"Moreover, as no use is made of ",NA,NA
append,NA,NA
", the trace is a lot easier to grasp. So we have made a ",NA,NA
big step forward. ,NA,NA
"On the other hand, it has to be admitted that the second recognizer is not as easy to ",NA,NA
"understand, at least at first, and it's a pain having to keep track of all those difference list ",NA,NA
variables. If only it were possible to have a recognizer as simple as the first and as efficient as ,NA,NA
"the second. And in fact, it is possible: this is where DCGs come in.",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
7.2 Definite clause grammars ,NA,NA
"So, what are DCGs? Quite simply, a nice notation for writing grammars that hides the ",NA,NA
underlying difference list variables. Let's look at three examples. ,G,NA
7.2.1 A first example ,G,NA
7.2.2 Adding recursive rules ,G,NA
7.2.3 A DCG for a simple formal language,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
7.2.1 A first example,NA,NA
"As our first example, here's our little grammar written as a DCG: ",NA,NA
"s --> np,vp. ",NA,NA
"np --> det,n. ",NA,NA
"vp --> v,np. ",NA,NA
vp --> v. ,NA,NA
det --> [the]. ,NA,NA
det --> [a]. ,NA,NA
n --> [woman]. ,NA,NA
n --> [man]. ,NA,NA
v --> [shoots].,NA,NA
The link with the original context free grammar should be utterly clear: this is definitely the ,NA,NA
"most user friendly notation we have used yet. But how do we use this DCG? In fact, we use it ",NA,NA
"in exactly the same way as we used our difference list recognizer. For example, to find out ",NA,NA
"whether a woman shoots a man is a sentence, we pose the query: ",NA,NA
"s([a,woman,shoots,a,man],[]).",NA,NA
"That is, just as in the difference list recognizer, we ask whether we can get an ",NA,NA
s,NA,NA
 by consuming ,NA,NA
the symbols in ,NA,NA
"[a,woman,shoots,a,man]",NA,NA
", leaving nothing behind.",NA,NA
"Similarly, to generate all the sentences in the grammar, we pose the query: ",NA,NA
"s(X,[]).",NA,NA
This asks what values we can give to ,NA,NA
X,NA,NA
", such that we get an ",NA,NA
s,NA,NA
 by consuming the symbols in ,NA,NA
X,NA,NA
", ",NA,NA
leaving nothing behind.,NA,NA
"Moreover, the queries for other grammatical categories also work the same way. For example, ",NA,NA
to find out if a woman is a noun phrase we pose the query: ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node59.html (1 of 3)11/3/2006 7:32:29 PM,NA
"np([a,woman],[]).",NA,NA
And we generate all the noun phrases in the grammar as follows: ,NA,NA
"np(X,[]).",NA,NA
"What's going on? Quite simply, this DCG is our difference list recognizer! That is, DCG notation ",NA,NA
is essentially syntactic sugar: user friendly notation that lets us write grammars in a natural ,NA,NA
way. But Prolog translates this notation into the kinds of difference lists discussed before. So ,NA,NA
"we have the best of both worlds: a nice simple notation for working with, and the efficiency of ",NA,NA
difference lists.,NA,NA
There is an easy way to actually see what Prolog translates DCG rules into. Suppose you are ,NA,NA
"working with this DCG (that is, Prolog has already consulted the rules). Then if you pose the ",NA,NA
query: ,NA,NA
listing(s),NA,NA
you will get the response ,NA,NA
"s(A,B) :- ",NA,NA
" np(A,C), ",NA,NA
" vp(C,B).",NA,NA
This is what Prolog has translated ,NA,NA
"s --> np,vp",NA,NA
 into. Note that (apart from the choice of ,NA,NA
variables) this is exactly the difference list rule we used in our second recognizer.,NA,NA
"Similarly, if you pose the query ",NA,NA
listing(np),NA,NA
you will get ,NA,NA
"np(A,B) :- ",NA,NA
" det(A,C), ",NA,NA
" n(C,B).",NA,NA
This is what Prolog has translated ,NA,NA
"np --> det,n",NA,NA
 into. Again (apart from the choice of ,NA,NA
variables) this is the difference list rule we used in our second recognizer.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node59.html (2 of 3)11/3/2006 7:32:29 PM,NA
"To get a complete listing of the translations of all the rules, simply type ",NA,NA
listing.,NA,NA
There is one thing you may observe. Some Prolog implementations translate rules such as ,NA,NA
det --> [the].,NA,NA
not into ,NA,NA
"det([the|W],W).",NA,NA
"which was the form we used in our difference list recognizer, but into ",NA,NA
"det(A,B) :- ",NA,NA
" 'C'(A,the,B).",NA,NA
"Although the notation is different, the idea is the same. Basically, this says you can get a ",NA,NA
B ,NA,NA
from an ,NA,NA
A,NA,NA
 by consuming a ,NA,NA
the,NA,NA
. Note that ,NA,NA
'C',NA,NA
 is an atom. ,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
7.2.2 Adding recursive rules,NA,NA
Our original context free grammar generated only 20 sentences. However it is easy to write ,NA,NA
context free grammars that generate infinitely many sentences: we need simply use recursive ,NA,NA
rules. Here's an example. Let's add the following rules to our little grammar: ,NA,NA
s -> s conj s,NA,NA
conj ->,NA,NA
 and,NA,NA
conj ->,NA,NA
 or,NA,NA
conj ->,NA,NA
 but,NA,NA
"This rule allows us to join as many sentences together as we like using the words and, but ",NA,NA
and or. So this grammar classifies sentences such as The woman shoots the man or the man ,NA,NA
shoots the woman as grammatical.,NA,NA
"It is easy to turn this grammar into DCG rules. In fact, we just need to add the rules ",NA,NA
"s --> s,conj,s. ",NA,NA
conj --> [and]. ,NA,NA
conj --> [or]. ,NA,NA
conj --> [but].,NA,NA
But what does Prolog do with a DCG like this? Let's have a look.,NA,NA
"First, let's add the rules at the beginning of the knowledge base before the rule ",NA,NA
"s --> np, vp",NA,NA
. ,NA,NA
What happens if we then pose the query ,NA,NA
"s([a,woman,shoots],[])",NA,NA
? Prolog gets into an infinte ,NA,NA
loop.,NA,NA
Can you see why? The point is this. Prolog translates DCG rules into ordinary Prolog rules. If ,NA,NA
we place the recursive rule ,NA,NA
"s --> s,conj,s",NA,NA
 in the knowledge base before the non-recursive rule ,NA,NA
"s --> np,vp",NA,NA
" then the knowledge base will contain the following two Prolog rules, in this order: ",NA,NA
"s(A, B) :- ",NA,NA
" s(A, C), ",NA,NA
" conj(C, D), ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node60.html (1 of 3)11/3/2006 7:32:35 PM,NA
" s(D, B). ",NA,NA
"s(A, B) :- ",NA,NA
" np(A, C), ",NA,NA
" vp(C, B).",NA,NA
"Now, from a declarative perspective this is fine, but from a procedural perspective this is fatal. ",NA,NA
"When it tries to use the first rule, Prolog immediately encounters the goal ",NA,NA
"s(A,C)",NA,NA
", which it then ",NA,NA
"tries to satisfy using the first rule, whereupon it immediately encounters the goal ",NA,NA
"s (A, C)",NA,NA
", which ",NA,NA
"it then tries to satisfy using the first rule, whereupon it immediately ",NA,NA
encounters the goal ,NA,NA
"s(A, C)",NA,NA
"... In short, it goes into infinite loop and does no useful work.",NA,NA
"Second, let's add the recursive rule ",NA,NA
"s --> s,conj,s",NA,NA
" at the end of the knowledge base, so that ",NA,NA
"Prolog always ecounters the translation of the non-recursive rule first. What happens now, ",NA,NA
when we pose the query ,NA,NA
"s([a,woman,shoots],[])",NA,NA
"? Well, Prolog seems to be able to handle it and ",NA,NA
gives an anwer. But what happens when we pose the query ,NA,NA
"s([woman, shoot],[])",NA,NA
", i.e. an ",NA,NA
ungrammatical sentence that is not accepted by our grammar? Prolog again gets into an ,NA,NA
"infinite loop. Since, it is impossible to recognize ",NA,NA
"[woman,shoot]",NA,NA
 as a sentence consisting of a ,NA,NA
"noun phrase and a verb phrase, Prolog tries to analyse it with the rule ",NA,NA
"s --> s,conj,s",NA,NA
 and ends up ,NA,NA
in the same loop as before.,NA,NA
"Notice, that we are having the same problems that we had when we were changing the order ",NA,NA
of the rules and goals in the definition of ,NA,NA
descend,NA,NA
" in the chapter on recursion. In that case, ",NA,NA
the trick was to change the goals of the recursive rule so that the recursive goal was not the ,NA,NA
"first one in the body of the rule. In the case of our recursive DCG, however, this is not a ",NA,NA
possible solution. Since the order of the goals determines the order of the words in the ,NA,NA
"sentence, we cannot change it just like that. It does make a difference, for example, whether ",NA,NA
our grammar accepts the woman shoots the man and the man shoots the woman (,NA,NA
"s --> s, ",NA,NA
"conj,s",NA,NA
) or whether it accepts and the woman shoots the man the man shoots the woman (,NA,NA
s --> ,NA,NA
"conj,s,s",NA,NA
).,NA,NA
"So, by just reordering clauses or goals, we won't solve the problem. The only possible solution ",NA,NA
is to introduce a new nonterminal symbol. We could for example use the category ,NA,NA
simple_s ,NA,NA
for ,NA,NA
sentences without embedded sentences. Our grammar would then look like this: ,NA,NA
s --> simple_s. ,NA,NA
s --> simple_s conj s. ,NA,NA
"simple_s --> np,vp. ",NA,NA
"np --> det,n. ",NA,NA
"vp --> v,np. ",NA,NA
vp --> v. ,NA,NA
det --> [the]. ,NA,NA
det --> [a]. ,NA,NA
n --> [woman]. ,NA,NA
n --> [man]. ,NA,NA
v --> [shoots]. ,NA,NA
conj --> [and]. ,NA,NA
conj --> [or]. ,NA,NA
conj --> [but].,NA,NA
Make sure that you understand why Prolog doesn't get into infinite loops with this grammar as ,NA,NA
it did with the previous version.,NA,NA
"The moral is: DCGs aren't magic. They are a nice notation, but you can't always expect just to ",NA,NA
`write down the grammar as a DCG' and have it work. DCG rules are really ordinary Prolog ,NA,NA
"rules in disguise, and this means that you must pay attention to what your Prolog interpreter ",NA,NA
does with them.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
7.2.3 A DCG for a simple formal language,NA,NA
"As our last example, we shall define a DCG for the formal language ",NA,NA
. What is this ,NA,NA
language? And what is a formal language anyway?,NA,NA
A formal language is simply a set of strings. The term `formal language' is intended to ,NA,NA
contrast with the term `natural language': whereas natural languages are languages that ,NA,NA
"human beings actually use, fomal languages are mathematical objects that computer ",NA,NA
"scientists, logicians, and mathematicians define and study for various purpose.",NA,NA
A simple example of a formal language is ,NA,NA
. There are only two `words' in this language: ,NA,NA
the symbol a and the symbol b. The language ,NA,NA
 consist of all strings made up from these ,NA,NA
two symbols that have the following form: the string must consist of an unbroken block of as of ,NA,NA
"length n, followed by an unbroken block of bs of length n, and nothing else. So the strings ab, ",NA,NA
"aabb, aaabbb and aaaabbbb all belong to ",NA,NA
. (Note that the empty string belongs to ,NA,NA
"too: after all, the empty string consists of a block of as of length zero followed by a block of bs ",NA,NA
"of length zero.) On the other hand, aaabb and aaabbba do not belong to ",NA,NA
.,NA,NA
"Now, it is easy to write a context free grammar that generates this language: ",NA,NA
s -> ,NA,NA
s -> l s r,NA,NA
l -> a ,NA,NA
r -> b,NA,NA
The first rule says that an s can be realized as nothing at all. The second rule says that an s ,NA,NA
"can be made up of an l (for left) element, followed by an s, followed by an r (for right) ",NA,NA
element. The last two rules say that l elements and r elements can be realized as as and bs ,NA,NA
respectively. It should be clear that this grammar really does generate all and only the ,NA,NA
elements of ,NA,NA
", including the empty string.",NA,NA
"Moreover, it is trivial to turn this grammar into DCG. We can do so as follows: ",NA,NA
s --> []. ,NA,NA
"s --> l,s,r. ",NA,NA
l --> [a]. ,NA,NA
r --> [b].,NA,NA
"And this DCG works exactly as we would hope. For example, to the query ",NA,NA
"s([a,a,a,b,b,b],[]).",NA,NA
"we get the answer `yes', while to the query ",NA,NA
"s([a,a,a,b,b,b,b],[]).",NA,NA
we get the answer `no'. And the query ,NA,NA
"s(X,[]).",NA,NA
"enumerates the strings in the language, starting from ",NA,NA
[],NA,NA
. ,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
7.3 Exercises,NA,NA
Exercise 7.1,NA,NA
Suppose we are working with the following DCG: ,NA,NA
"s --> foo,bar,wiggle. ",NA,NA
foo --> [choo]. ,NA,NA
"foo --> foo,foo. ",NA,NA
"bar --> mar,zar. ",NA,NA
"mar --> me,my. ",NA,NA
me --> [i]. ,NA,NA
my --> [am]. ,NA,NA
"zar --> blar,car. ",NA,NA
blar --> [a]. ,NA,NA
car --> [train]. ,NA,NA
wiggle --> [toot]. ,NA,NA
"wiggle --> wiggle,wiggle.",NA,NA
Write down the ordinary Prolog rules that correspond to these DCG rules. What ,NA,NA
are the first three responses that Prolog gives to the query ,NA,NA
"s(X,[])",NA,NA
?,NA,NA
Exercise 7.2,NA,NA
The formal language ,NA,NA
 consists of all the strings in ,NA,NA
 except the empty ,NA,NA
string. Write a DCG that generates this language.,NA,NA
Exercise 7.3,NA,NA
Let ,NA,NA
 be the formal language which contains all strings of the following form: ,NA,NA
an unbroken block of as of length n followed by an unbroken block of bs of ,NA,NA
"length 2n, and nothing else. For example, abb, aabbbb, and aaabbbbbb belong to ",NA,NA
", and so does the empty string. Write a DCG that generates this language. ",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node62.html (2 of 2)11/3/2006 7:32:48 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
7.4 Practical Session 7,NA,NA
"The purpose of Practical Session 7 is to help you get familiar with the DCGs, difference lists, ",NA,NA
"and the relation between them, and to give you some experience in writing basic DCGs. As you ",NA,NA
"will learn next week, there is more to DCGs than the ideas just discussed. Nonetheless, what ",NA,NA
"you have learned so far is certainly the core, and it is important that you are comfortable with ",NA,NA
the basic ideas before moving on.,NA,NA
First some keyboard exercises: ,NA,NA
"1.  First, type in or download the simple ",NA,NA
append,NA,NA
" based recognizer discussed in the text, and ",NA,NA
"then run some traces. As you will see, we were not exaggerating when we said that the ",NA,NA
performance of the ,NA,NA
append,NA,NA
 based grammar was very poor. Even for such simple ,NA,NA
"sentences as The woman shot a man you will see that the trace is very long, and very ",NA,NA
difficult to follow.,NA,NA
"2.  Next, type in or download our second recognizer, the one based on difference lists, and ",NA,NA
"run more traces. As you will see, there is a dramatic gain in efficiency. Moreover, even if ",NA,NA
"you find the idea of difference lists a bit hard to follow, you will see that the traces are ",NA,NA
"very simple to understand, especially when compared with the monsters produced by ",NA,NA
the ,NA,NA
append,NA,NA
 based implementation!,NA,NA
"3.  Next, type in or download the DCG discussed in the text. Type ",NA,NA
listing,NA,NA
 so that you can see ,NA,NA
what Prolog translates the rules to. How does your system translate rules of the form ,NA,NA
Det --> [the],NA,NA
"? That is, does it translate them to rules like ",NA,NA
"det([the|X],X)",NA,NA
", or does is make ",NA,NA
use of rules containing the ,NA,NA
'C',NA,NA
predicate?,NA,NA
"4.  Now run some traces. Apart from variable names, the traces you observe here should ",NA,NA
be very similar to the traces you observed when running the difference list recognizer. ,NA,NA
"In fact, you will only observe any real differences if your version of Prolog uses a ",NA,NA
'C' ,NA,NA
based translation.,NA,NA
And now it's time to write some DCGs: ,NA,NA
1.  The formal language aEven is very simple: it consists of all strings containing an even ,NA,NA
"number of as, and nothing else. Note that the empty string  belongs to aEven. Write a ",NA,NA
DCG that generates aEven.,NA,NA
2.  The formal language ,NA,NA
 consists of all strings of the following form: an ,NA,NA
unbroken block of as followed by an unbroken block of bs followed by an unbroken ,NA,NA
"block of cs followed by an unbroken block of ds, such that the a and d blocks are ",NA,NA
"exactly the same length, and the c and d blocks are also exactly the same length and ",NA,NA
"furthermore consist of an even number of cs and ds respectively. For example, , ",NA,NA
"abbccd, and aaabbbbccccddd all belong to ",NA,NA
. Write a DCG that generates this ,NA,NA
language.,NA,NA
"3.  The language that logicians call `propositional logic over the propositional symbols p, q, ",NA,NA
and r' can be defined by the following context free grammar: ,NA,NA
prop -> p,NA,NA
prop -> q,NA,NA
prop -> r,NA,NA
prop -> prop,NA,NA
prop ->(prop  prop),NA,NA
prop ->(prop  prop) ,NA,NA
prop ->(prop ,NA,NA
 prop),NA,NA
"Write a DCG that generates this language. Actually, because we don't know about ",NA,NA
"Prolog operators yet, you will have to make a few rather clumsy looking compromises. ",NA,NA
"For example, instead of getting it to recognize ",NA,NA
(p ,NA,NA
 q),NA,NA
you will have to get it recognize things like ,NA,NA
"[not, '(', p, implies, q, ')']",NA,NA
"instead. But we will learn later how to make the output nicer, so write the DCG that ",NA,NA
"accepts a clumsy looking version of this language. Use or for , and and for .",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
8 More Definite Clause Grammars,NA,NA
This lecture has two main goals: ,NA,NA
1.  To examine two important capabilities offered by DCG notation: extra arguments and ,NA,NA
extra tests.,NA,NA
2.  To discuss the status and limitations of DCGs.,G,NA
8.1 Extra arguments ,H,NA
8.1.1 Context free grammars with features ,H,NA
8.1.2 Building parse trees ,H,NA
8.1.3 Beyond context free languages,G,NA
8.2 Extra goals ,H,NA
8.2.1 Separating rules and lexicon,G,NA
8.3 Concluding remarks,G,NA
8.4 Exercises,G,NA
8.5 Practical Session 8,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
8.1 Extra arguments,NA,NA
In the previous lecture we only scratched the surface of DCG notation: it actually offers a lot ,NA,NA
"more than we've seen so far. For a start, DCGs allow us to specify extra arguments. Extra ",NA,NA
arguments can be used for many purposes; we'll examine three. ,G,NA
8.1.1 Context free grammars with features,G,NA
8.1.2 Building parse trees,G,NA
8.1.3 Beyond context free languages,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
8.1.1 Context free grammars with features,NA,NA
"As a first example, let's see how extra arguments can be used to add features to context-free ",NA,NA
grammars.,NA,NA
Here's the DCG we worked with last week: ,NA,NA
"s --> np,vp. ",NA,NA
"np --> det,n. ",NA,NA
"vp --> v,np. ",NA,NA
vp --> v. ,NA,NA
det --> [the]. ,NA,NA
det --> [a]. ,NA,NA
n --> [woman]. ,NA,NA
n --> [man]. ,NA,NA
v --> [shoots].,NA,NA
"Suppose we wanted to deal with sentences like ``She shoots him'', and ``He shoots her''. ",NA,NA
"What should we do? Well, obviously we should add rules saying that ``he'', ``she'', ``him'', ",NA,NA
and ``her'' are pronouns: ,NA,NA
pro --> [he]. ,NA,NA
pro --> [she]. ,NA,NA
pro --> [him]. ,NA,NA
pro --> [her].,NA,NA
"Furthermore, we should add a rule saying that noun phrases can be pronouns: ",NA,NA
np--> pro.,NA,NA
"Up to a point, this new DCG works. For example: ",NA,NA
"s([she,shoots,him],[]). ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node66.html (1 of 7)11/3/2006 7:33:17 PM,NA
yes,NA,NA
But there's an obvious problem. The DCG will also accept a lot of sentences that are clearly ,NA,NA
"wrong, such as ``A woman shoots she'', ``Her shoots a man'', and ``Her shoots she'': ",NA,NA
"s([a,woman,shoots,she],[]). ",NA,NA
yes ,NA,NA
"s([her,shoots,a,man],[]). ",NA,NA
yes ,NA,NA
"s([her,shoots,she],[]). ",NA,NA
yes,NA,NA
"That is, the grammar doesn't know that ``she'' and ``he'' are subject pronouns and cannot be ",NA,NA
used in object position; thus ``A woman shoots she'' is bad because it violates this basic fact ,NA,NA
"about English. Moreover, the grammar doesn't know that ``her'' and ``him'' are object ",NA,NA
pronouns and cannot be used in subject position; thus ``Her shoots a man'' is bad because it ,NA,NA
"violates this constraint. As for ``Her shoots she'', this manages to get both matters wrong at ",NA,NA
once.,NA,NA
"Now, it's pretty obvious what we have to do to put this right: we need to extend the DCG with ",NA,NA
information about which pronouns can occur in subject position and which in object position. ,NA,NA
The interesting question: how exactly are we to do this? First let's look at a naive way of ,NA,NA
"correcting this, namely adding new rules: ",NA,NA
"s --> np_subject,vp. ",NA,NA
"np_subject --> det,n. ",NA,NA
"np_object  --> det,n. ",NA,NA
np_subject --> pro_subject. ,NA,NA
np_object  --> pro_object. ,NA,NA
"vp --> v,np_object. ",NA,NA
vp --> v. ,NA,NA
det --> [the]. ,NA,NA
det --> [a]. ,NA,NA
n --> [woman]. ,NA,NA
n --> [man]. ,NA,NA
pro_subject --> [he]. ,NA,NA
pro_subject --> [she]. ,NA,NA
pro_object --> [him]. ,NA,NA
pro_object --> [her]. ,NA,NA
v --> [shoots].,NA,NA
"Now this solution ``works''. For example, ",NA,NA
"?- s([her,shoots,she],[]). ",NA,NA
no,NA,NA
But neither computer scientists nor linguists would consider this a good solution. The trouble ,NA,NA
"is, a small addition to the lexicon has led to quite a big change in the DCG. Let's face it: ",NA,NA
``she'' and ``her'' (and ``he'' and ``him'') are the same in a lot of respects. But to deal with ,NA,NA
"the property in which they differ (namely, in which position in the sentence they can occur) ",NA,NA
"we've had to make big changes to the grammar: in particular, we've doubled the number of ",NA,NA
"noun phrase rules. If we had to make further changes (for example, to cope with plural noun ",NA,NA
phrases) things would get even worse. What we really need is a more delicate programming ,NA,NA
mechanism that allows us to cope with such facts without being forced to add rules all the ,NA,NA
time. And here's where the extra arguments come into play. Look at the following grammar: ,NA,NA
"s --> np(subject),vp. ",NA,NA
"np(_) --> det,n. ",NA,NA
np(X) --> pro(X). ,NA,NA
"vp --> v,np(object). ",NA,NA
vp --> v. ,NA,NA
det --> [the]. ,NA,NA
det --> [a]. ,NA,NA
n --> [woman]. ,NA,NA
n --> [man]. ,NA,NA
pro(subject) --> [he]. ,NA,NA
pro(subject) --> [she]. ,NA,NA
pro(object) --> [him]. ,NA,NA
pro(object) --> [her]. ,NA,NA
v --> [shoots].,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node66.html (3 of 7)11/3/2006 7:33:17 PM,NA
The key thing to note is that this new grammar contains no new rules. It is exactly the same ,NA,NA
"as the first grammar that we wrote above, except that the symbol ",NA,NA
np,NA,NA
 is associated with a new ,NA,NA
"argument, either ",NA,NA
(subject),NA,NA
", ",NA,NA
(object),NA,NA
", ",NA,NA
(_),NA,NA
 and ,NA,NA
 (X),NA,NA
. A linguist would say that we've added a ,NA,NA
"feature to distinguish various kinds of noun phrase. In particular, note the four rules for the ",NA,NA
pronouns. Here we've used the extra argument to state which pronouns can occur in subject ,NA,NA
"position, and which occur in object position. Thus these rules are the most ",NA,NA
"fundamental, for they give us the basic facts about how these pronouns can be used.",NA,NA
"So what do the other rules do? Well, intuitively, the rule ",NA,NA
np(X) --> pro(X).,NA,NA
uses the extra argument (the variable ,NA,NA
X,NA,NA
) to pass these basic facts about pronouns up to noun ,NA,NA
phrases built out of them: because the variable ,NA,NA
X,NA,NA
 is used as the extra argument for both the ,NA,NA
"np and the pronoun, Prolog unification will guarantee that they will be given the same value. ",NA,NA
"In particular, if the pronoun we use is ``she'' (in which case ",NA,NA
X=subject,NA,NA
"), then the np wil, ",NA,NA
through its extra argument (,NA,NA
X=subject,NA,NA
"), also be marked as being a subject np. On the other ",NA,NA
"hand, if the pronoun we use is ``her'' (in which case ",NA,NA
X=object,NA,NA
"), then the extra argument np ",NA,NA
will be marked ,NA,NA
X=object,NA,NA
" too. And this, of course, is exactly the behaviour we want.",NA,NA
"On the other hand, although noun phrases built using the rule ",NA,NA
"np(_) --> det,n.",NA,NA
"also have an extra argument, we've used the anonymous variable as its value. Essentially this ",NA,NA
"means can be either, which is correct, for expressions built using this rule (such as ``the man'' ",NA,NA
and ``a woman'') can be used in both subject and object position. ,NA,NA
Now consider the rule ,NA,NA
"vp --> v,np(object).",NA,NA
This says that to apply this rule we need to use an noun phrase whose extra argument unifies ,NA,NA
with ,NA,NA
object,NA,NA
. This can be either noun phrases built from object pronouns or noun phrases such ,NA,NA
as ``the man'' and ``a woman'' which have the anonymous variable as the value of the extra ,NA,NA
"argument. Crucially, pronouns marked has having ",NA,NA
 subject,NA,NA
 as the value of the extra argument ,NA,NA
can't be used here: the atoms ,NA,NA
object,NA,NA
 and ,NA,NA
subject,NA,NA
 don't unify. Note that the rule ,NA,NA
"s --> np(subject),vp.",NA,NA
works in an analogous fashion to prevent noun phrases made of object pronouns from ending ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node66.html (4 of 7)11/3/2006 7:33:17 PM,NA
up in subject position.,NA,NA
This works. You can check it out by posing the query: ,NA,NA
"?- s(X,[]). ",NA,NA
"As you step through the responses, you'll see that only acceptable English is generated.",NA,NA
"But while the intuitive explanation just given is correct, what's really going on? The key thing ",NA,NA
"to remember is that DCG rules are really are just a convenient abbreviation. For example, the ",NA,NA
rule ,NA,NA
"s --> np,vp.",NA,NA
is really syntactic sugar for ,NA,NA
"s(A,B) :- ",NA,NA
" np(A,C), ",NA,NA
" vp(C,B).",NA,NA
"That is, as we learned in the previous lecture, the DCG notation is a way of hiding the two ",NA,NA
"arguments responsible for the difference list representation, so that we don't have to think ",NA,NA
"about them. We work with the nice user friendly notation, and Prolog translates it into the ",NA,NA
clauses just given.,NA,NA
"Ok, so we obviously need to ask what ",NA,NA
"s --> np(subject),vp.",NA,NA
translates into. Here's the answer: ,NA,NA
"s(A,B) :- ",NA,NA
" np(subject,A,C), ",NA,NA
" vp(C,B).",NA,NA
"As should now be clear, the name ``extra argument'' is a good one: as this translation makes ",NA,NA
"clear, the ",NA,NA
(subject),NA,NA
 symbol really is just one more argument in an ordinary Prolog rule! ,NA,NA
"Similarly, our noun phrase DCG rules translate into ",NA,NA
"np(A,B,C) :- ",NA,NA
" det(B,D), ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node66.html (5 of 7)11/3/2006 7:33:17 PM,NA
" n(D,C). ",NA,NA
"np(A,B,C) :- ",NA,NA
" pro(A,B,C).",NA,NA
"Note that both rules have three arguments. The first, ",NA,NA
A,NA,NA
", is the extra argument, and the last ",NA,NA
"two are the ordinary, hidden DCG arguments (the two hidden arguments are always the last ",NA,NA
two arguments).,NA,NA
"Incidentally, how do you think we would use the grammar to list the grammatical noun ",NA,NA
"phrases? Well, if we had been working with the DCG rule ",NA,NA
"np --> det,n",NA,NA
" (that is, a rule with no ",NA,NA
extra arguments) we would have made the query ,NA,NA
"np(NP,[]).",NA,NA
So it's not too surprising that we need to pose the query ,NA,NA
"np(X,NP,[]).",NA,NA
when working with our new DCG. Here's what the response would be. ,NA,NA
X = _2625 ,NA,NA
"NP = [the,woman] ; ",NA,NA
X = _2625 ,NA,NA
"NP = [the,man] ; ",NA,NA
X = _2625 ,NA,NA
"NP = [a,woman] ; ",NA,NA
X = _2625 ,NA,NA
"NP = [a,man] ; ",NA,NA
X = subject ,NA,NA
NP = [he] ; ,NA,NA
X = subject ,NA,NA
NP = [she] ; ,NA,NA
X = object ,NA,NA
NP = [him] ; ,NA,NA
X = object ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node66.html (6 of 7)11/3/2006 7:33:17 PM,NA
NP = [her] ; ,NA,NA
no,NA,NA
One final remark: don't be misled by this simplicity of our example. Extra arguments can be ,NA,NA
used to cope with some complex syntactic problems. DCGs are no longer the state-of-art ,NA,NA
"grammar development tools they once were, but they're not toys either. Once you know about ",NA,NA
"writing DCGs with extra arguments, you can write some fairly sophisticated grammars.",NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
8.1.2 Building parse trees,NA,NA
"So far, the programs we have discussed have been able to recognize grammatical structure ",NA,NA
"(that is, they could correctly answer ``yes'' or ``no'' when asked whether the input was a ",NA,NA
"sentence, a noun phrase, and so on) and to generate grammatical output. This is pleasant, but ",NA,NA
"we would also like to be able to parse. That is, we would like our programs not only to tell us ",NA,NA
"which sentences are grammatical, but also to give us an analysis of their structure. In ",NA,NA
"particular, we would like to see the trees the grammar assigns to sentences.",NA,NA
"Well, using only standard Prolog tool we can't actually draw nice pictures of trees, but we can ",NA,NA
"build data structures which describe trees in a clear way. For example, corresponding to the ",NA,NA
tree ,NA,NA
we could have the following term: ,NA,NA
"s(np(det(a),n(woman)),vp(v(shoots))).",NA,NA
"Sure: it doesn't look as nice, but all the information in the picture is there. And, with the aid of ",NA,NA
"a decent graphics package, it would be easy to turn this term into a picture.",NA,NA
"But how do we get DCGs to build such terms? Actually, it's pretty easy. After all, in effect a ",NA,NA
DCG has to work out what the tree structure is when recognizing a sentence. So we just need ,NA,NA
to find a way of keeping track of the structure that the DCG finds. We do this by adding extra ,NA,NA
arguments. Here's how: ,NA,NA
"s(s(NP,VP)) --> np(NP),vp(VP). ",NA,NA
"np(np(DET,N)) --> det(DET),n(N). ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node67.html (1 of 4)11/3/2006 7:33:23 PM,NA
"vp(vp(V,NP)) --> v(V),np(NP). ",NA,NA
vp(vp(V))    --> v(V). ,NA,NA
det(det(the)) --> [the]. ,NA,NA
det(det(a))   --> [a]. ,NA,NA
n(n(woman)) --> [woman]. ,NA,NA
n(n(man))   --> [man]. ,NA,NA
v(v(shoots)) --> [shoots].,NA,NA
What's going on here? Essentially we are building the parse trees for the syntactic categories ,NA,NA
on the left-hand side of the rules out of the parse trees for the syntactic categories on the ,NA,NA
right-hand side of the rules. Consider the rule ,NA,NA
"vp(vp(V,NP)) --> v(V),np(NP)",NA,NA
. When we make a ,NA,NA
"query using this DCG, the ",NA,NA
V,NA,NA
 in ,NA,NA
v(V),NA,NA
 and the ,NA,NA
NP,NA,NA
 in ,NA,NA
np(NP),NA,NA
 will be instantiated to terms ,NA,NA
"representing parse trees. For example, perhaps ",NA,NA
V,NA,NA
 will be instantiated to ,NA,NA
v(shoots),NA,NA
and ,NA,NA
NP,NA,NA
 will be instantiated to ,NA,NA
"np(det(a),n(woman)).",NA,NA
What is the term corresponding to a vp made out of these two structures? Obviously it should ,NA,NA
be this: ,NA,NA
"vp(v(shoots),np(det(a),n(woman))).",NA,NA
And this is precisely what the extra argument ,NA,NA
"vp(V,NP)",NA,NA
 in the rule ,NA,NA
"vp(vp(V,NP)) -->v ",NA,NA
"(V),np(NP)",NA,NA
 gives us: it forms a term whose functor is ,NA,NA
vp,NA,NA
", and whose first and second ",NA,NA
arguments are the values of ,NA,NA
V,NA,NA
 and ,NA,NA
NP,NA,NA
 respectively. To put it informally: it plugs the ,NA,NA
V,NA,NA
 and the ,NA,NA
NP,NA,NA
 terms together under a ,NA,NA
vp,NA,NA
 functor.,NA,NA
To parse the sentence ``A woman shoots'' we pose the query: ,NA,NA
"s(T,[a,woman,shoots],[]).",NA,NA
"That is, we ask for the extra argument ",NA,NA
T,NA,NA
 to be instantiated to a parse tree for the sentence. ,NA,NA
And we get: ,NA,NA
"T = s(np(det(a),n(woman)),vp(v(shoots))) ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node67.html (2 of 4)11/3/2006 7:33:23 PM,NA
yes,NA,NA
"Furthermore, we can generate all parse trees by making the following query: ",NA,NA
"s(T,S,[]).",NA,NA
The first three responses are: ,NA,NA
"T = s(np(det(the),n(woman)),vp(v(shoots),np(det(the),n (woman)))) ",NA,NA
"S = [the,woman,shoots,the,woman] ; ",NA,NA
"T = s(np(det(the),n(woman)),vp(v(shoots),np(det(the),n (man)))) ",NA,NA
"S = [the,woman,shoots,the,man] ; ",NA,NA
"T = s(np(det(the),n(woman)),vp(v(shoots),np(det(a),n (woman)))) ",NA,NA
"S = [the,woman,shoots,a,woman] ",NA,NA
This code should be studied closely: it's a classic example of building structure using ,NA,NA
unification. ,NA,NA
Extra arguments can also be used to build semantic representations. We did not say anything ,NA,NA
"about what the words in our little DCG mean. In fact, nowadays a lot is known about the ",NA,NA
"semantics of natural languages, and it is surprisingly easy to build semantic representations ",NA,NA
which partially capture the meaning of sentences or entire discourses. Such representations are ,NA,NA
"usually expressions of some formal language (for example first-order logic, discourse ",NA,NA
"representation structures, or a database query language) and they are usually built up ",NA,NA
"compositionally. That is, the meaning of each word is expressed in the formal language; this ",NA,NA
"meaning is given as an extra argument in the DCG entries for the individual words. Then, for ",NA,NA
"each rule in the grammar, an extra argument shows how to combine the meaning of the two ",NA,NA
"subcomponents. For example, to the rule ",NA,NA
"s --> np, vp",NA,NA
 we would add an extra argument stating ,NA,NA
how to combine the ,NA,NA
np,NA,NA
 meaning and the ,NA,NA
vp,NA,NA
 meaning to form the ,NA,NA
s,NA,NA
 meaning. Although ,NA,NA
"somewhat more complex, the semantic construction process is quite like the way we built up ",NA,NA
the parse tree for the sentence from the parse tree of its subparts.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node67.html (3 of 4)11/3/2006 7:33:23 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
8.1.3 Beyond context free languages,NA,NA
In the previous lecture we introduced DCGs as a useful Prolog tool for representing and ,NA,NA
"working with context free grammars. Now, this is certainly a good way of thinking about DCGs, ",NA,NA
but it's not the whole story. For the fact of the matter is: DCGs can deal with a lot more than ,NA,NA
"just context free languages. The extra arguments we have been discussing (and indeed, the ",NA,NA
extra tests we shall introduce shortly) give us the tools for coping with any computable ,NA,NA
language whatsoever. We shall illustrate this by presenting a simple DCG for the formal ,NA,NA
language ,NA,NA
. %%-\{\epsilon\}/.,NA,NA
The formal language ,NA,NA
 %%-\{\epsilon\}/ consists of all non-null strings made up of ,NA,NA
a,NA,NA
"s, ",NA,NA
b,NA,NA
"s, and ",NA,NA
c,NA,NA
s which consist of an unbroken block of ,NA,NA
a,NA,NA
"s, followed by an unbroken block of ",NA,NA
b,NA,NA
"s, ",NA,NA
followed by an unbroken block of ,NA,NA
c,NA,NA
"s, all three blocks having the same length. For example, ",NA,NA
abc,NA,NA
", and ",NA,NA
aabbcc,NA,NA
 and ,NA,NA
aaabbbccc,NA,NA
 all belong to ,NA,NA
". %%-\{\epsilon\}/. Furthermore, ",NA,NA
belongs to ,NA,NA
.,NA,NA
"The interesting thing about this language is that it is not context free. Try whatever you like, ",NA,NA
you will not succeed in writing a context free grammar that generates precisely these strings. ,NA,NA
"Proving this would take us too far afield, but the proof is not particularly difficult, and you can ",NA,NA
find it in many books on formal language theory.,NA,NA
"On the other hand, as we shall now see, it is very easy to write a DCG that generates this ",NA,NA
"language. Just as we did in the previous lecture, we shall represent strings as lists; for ",NA,NA
"example, the string ",NA,NA
abc,NA,NA
 will be represented using the list ,NA,NA
"[a,b,c]",NA,NA
". Given this convention, ",NA,NA
here's the DCG we need: ,NA,NA
"s(Count) --> ablock(Count),bblock(Count),cblock(Count). ",NA,NA
ablock(0) --> []. ,NA,NA
"ablock(succ(Count)) --> [a],ablock(Count). ",NA,NA
bblock(0) --> []. ,NA,NA
"bblock(succ(Count)) --> [b],bblock(Count). ",NA,NA
cblock(0) --> []. ,NA,NA
"cblock(succ(Count)) --> [c],cblock(Count).",NA,NA
The idea underlying this DCG is fairly simple: we use an extra argument to keep track of the ,NA,NA
length of the blocks. The ,NA,NA
s,NA,NA
 rule simply says that we want a block of ,NA,NA
a,NA,NA
s followed by a block of ,NA,NA
b,NA,NA
s followed by block of ,NA,NA
c,NA,NA
"s, and all three blocks are to have the same length, namely ",NA,NA
Count,NA,NA
.,NA,NA
But what should the values of ,NA,NA
Count,NA,NA
 be? The obvious answer is: ,NA,NA
1,NA,NA
", ",NA,NA
2,NA,NA
", ",NA,NA
3,NA,NA
", ",NA,NA
4,NA,NA
",..., and so on. But as ",NA,NA
"yet we don't know how to mix DCGs and arithmetic, so this isn't very helpful. Fortunately ",NA,NA
there's an easier (and more elegant) way. Represent the number 0 by ,NA,NA
0,NA,NA
", the number 1 by ",NA,NA
succ(0),NA,NA
", the number 2 by ",NA,NA
succ(succ(0)),NA,NA
", the number 3 by ",NA,NA
succ(succ(succ(0))),NA,NA
",..., and so on, ",NA,NA
just as we did it in Chapter 3. (You can read ,NA,NA
succ,NA,NA
 as ``successor of''.) Using this simple ,NA,NA
notation we can ``count using matching''.,NA,NA
"This is precisely what the above DCG does, and it works very neatly. For example, suppose we ",NA,NA
pose the following query: ,NA,NA
"s(Count,L,[]).",NA,NA
which asks Prolog to generate the lists ,NA,NA
L,NA,NA
" of symbols that belong to this language, and to give ",NA,NA
the value of ,NA,NA
Count,NA,NA
 needed to produce each item. Then the first three responses are: ,NA,NA
Count = 0 ,NA,NA
L = [] ; ,NA,NA
Count = succ(0) ,NA,NA
"L = [a, b, c] ; ",NA,NA
Count = succ(succ(0)) ,NA,NA
"L = [a, a, b, b, c, c] ; ",NA,NA
Count = succ(succ(succ(0))) ,NA,NA
"L = [a, a, a, b, b, b, c, c, c]",NA,NA
The value of ,NA,NA
Count,NA,NA
 clearly corresponds to the length of the blocks.,NA,NA
So: DCGs are not just a tool for working with context free grammars. They are strictly more ,NA,NA
"powerful than that, and (as we've just seen) part of the extra power comes from the use of ",NA,NA
extra arguments.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
8.2 Extra goals,NA,NA
Any DCG rule is really syntactic sugar for an ordinary Prolog rule. So it's not really too ,NA,NA
"surprising that we're allowed to make use of extra arguments. Similarly, it shouldn't come as ",NA,NA
too much of a surprise that we can also add calls to any Prolog predicate whatsoever to the ,NA,NA
right hand side of a DCG rule. ,NA,NA
"The DCG of the previous section can, for example, be adapted to work with Prolog numbers ",NA,NA
instead of the successor representation of numbers by using calls to Prolog's built-in arithmetic ,NA,NA
functionality to add up how many ,NA,NA
a,NA,NA
"s, ",NA,NA
b,NA,NA
"s, and ",NA,NA
c,NA,NA
s have already been generated. Here is the ,NA,NA
code: ,NA,NA
"s --> ablock(Count),bblock(Count),cblock(Count). ",NA,NA
ablock(0) --> []. ,NA,NA
"ablock(NewCount) --> [a],ablock ",NA,NA
"(Count), {NewCount is Count + 1}. ",NA,NA
bblock(0) --> []. ,NA,NA
"bblock(NewCount) --> [b],bblock ",NA,NA
"(Count), {NewCount is Count + 1}. ",NA,NA
cblock(0) --> []. ,NA,NA
"cblock(NewCount) --> [c],cblock ",NA,NA
"(Count), {NewCount is Count + 1}.",NA,NA
"These extra goals can be written anywhere on the right side of a DCG rule, but must stand ",NA,NA
between curly brackets. When Prolog encounters such curly brackets while translating a DCG ,NA,NA
"into its internal representation, it just takes the extra goals specified between the curly ",NA,NA
"brackets over into the translation. So, the second rule for the non-terminal ",NA,NA
ablock,NA,NA
 above ,NA,NA
would be translated as follows: ,NA,NA
"ablock(NewCount,A,B) :- ",NA,NA
" 'C'(A, a, C), ",NA,NA
" ablock(Count, C, B), ",NA,NA
 NewCount is Count + 1. ,NA,NA
"This possibility of adding arbitrary Prolog goals to the right hand side of DCG rules, makes ",NA,NA
"DCGs very very powerful (in fact, we can do anything that we can do in Prolog) and is not ",NA,NA
"used much. There is, however, one interesting application for extra goals in computational ",NA,NA
"linguistics; namely that with the help of extra goals, we can seperate the rules of a grammar ",NA,NA
from lexical information.,G,NA
8.2.1 Separating rules and lexicon,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
8.2.1 Separating rules and lexicon,NA,NA
By ``separating rules and lexicon'' we mean that we want to eliminate all mentioning of ,NA,NA
individual words in our DCGs and instead record all the information about individual words ,NA,NA
"separately in a lexicon. <!- To see what is meant by this, let's return to our basic grammar, ",NA,NA
namely: ,NA,NA
"np - - > det,n. ",NA,NA
"vp - - > v,np. ",NA,NA
vp - - > v. ,NA,NA
det - - > [the]. ,NA,NA
det - - > [a]. ,NA,NA
n - - > [woman]. ,NA,NA
n - - > [man]. ,NA,NA
v - - > [shoots]. ,NA,NA
"We are going to separate the rules form the lexicon. That is, we are going to write a DCG that ",NA,NA
"generates exactly the same language, but in which no rule mentions any individual word. All ",NA,NA
the information about individual words will be recorded separately. -->,NA,NA
Here is an example of a (very simple) lexicon. Lexical entries are encoded by using a predicate ,NA,NA
lex/2,NA,NA
" whose first argument is a word, and whose second argument is a syntactic category. ",NA,NA
"lex(the,det). ",NA,NA
"lex(a,det). ",NA,NA
"lex(woman,n). ",NA,NA
"lex(man,n). ",NA,NA
"lex(shoots,v).",NA,NA
And here is a simple grammar that could go with this lexicon. Note that it is very similar to our ,NA,NA
"basic DCG of the previous chapter. In fact, both grammars generate exactly the same ",NA,NA
"language. The only rules that have changed are those, that mentioned specific words, i.e. the ",NA,NA
det,NA,NA
", ",NA,NA
n,NA,NA
", and ",NA,NA
v,NA,NA
 rules. ,NA,NA
"det --> [Word],{lex(Word,det)}. ",NA,NA
"n --> [Word],{lex(Word,n)}. ",NA,NA
"v --> [Word],{lex(Word,v)}.",NA,NA
Consider the new ,NA,NA
det,NA,NA
 rule. This rule part says ``a ,NA,NA
det,NA,NA
 can consist of a list containing a single ,NA,NA
element ,NA,NA
Word,NA,NA
'' (note that ,NA,NA
Word,NA,NA
 is a variable). Then the extra test adds the crucial stipulation: ,NA,NA
``so long as ,NA,NA
Word,NA,NA
 matches with something that is listed in the lexicon as a determiner''. With ,NA,NA
"our present lexicon, this means that ",NA,NA
Word,NA,NA
 must be matched either with the word ``a'' or ,NA,NA
``the''. So this single rule replaces the two previous DCG rules for ,NA,NA
det,NA,NA
.,NA,NA
"This explains the ``how'' of separating rules from lexicon, but it doesn't explain the ``why''. ",NA,NA
Is it really so important? Is this new way of writing DCGs really that much better?,NA,NA
"The answer is an unequivocal ``yes''! It's much better, and for at least two reasons.",NA,NA
The first reason is theoretical. Arguably rules should not mention specific lexical items. The ,NA,NA
"purpose of rules is to list general syntactic facts, such as the fact that sentence can be made ",NA,NA
up of a noun phrase followed by a verb phrase. The rules for ,NA,NA
s,NA,NA
", ",NA,NA
np,NA,NA
", and ",NA,NA
vp,NA,NA
 describe such ,NA,NA
"general syntactic facts, but the old rules for ",NA,NA
det,NA,NA
", ",NA,NA
n,NA,NA
", and ",NA,NA
v,NA,NA
" don't. Instead, the old rules simply ",NA,NA
"list particular facts: that ``a'' is a determiner, that ``the'' is a determiner, and so on. From ",NA,NA
theoretical perspective it is much neater to have a single rule that says ``anything is a ,NA,NA
"determiner (or a noun, or a verb,...) if it is listed as such in the lexicon''. And this, of course, is ",NA,NA
precisely what our new DCG rules say.,NA,NA
The second reason is more practical. One of the key lessons computational linguists have ,NA,NA
"learnt over the last twenty or so years is that the lexicon is by far the most interesting, ",NA,NA
"important (and expensive!) repository of linguistic knowledge. Bluntly, if you want to get to ",NA,NA
"grips with natural language from a computational perspective, you need to know a lot of ",NA,NA
"words, and you need to know a lot about them.",NA,NA
"Now, our little lexicon, with its simple two-place ",NA,NA
lex,NA,NA
" entries, is a toy. But a real lexicon is (most ",NA,NA
emphatically!) not. A real lexicon is likely to be very large (it may contain hundreds of ,NA,NA
"thousands, or even millions, of words) and moreover, the information associated with each ",NA,NA
word is likely to be very rich. Our ,NA,NA
lex,NA,NA
" entries give only the syntactical category of each word, ",NA,NA
"but a real lexicon will give much more, such as information about its phonological, ",NA,NA
"morphological, semantic, and pragmatic properties.",NA,NA
"Because real lexicons are big and complex, from a software engineering perspective it is best ",NA,NA
"to write simple grammars that have a simple, well-defined way, of pulling out the information ",NA,NA
"they need from vast lexicons. That is, grammar should be thought of as separate entities ",NA,NA
which can access the information contained in lexicons. We can then use specialized ,NA,NA
mechanisms for efficiently storing the lexicon and retrieving data from it. ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node70.html (2 of 3)11/3/2006 7:33:42 PM,NA
"Our new DCG rules, though simple, illustrate the basic idea. The new rules really do just list ",NA,NA
"general syntactic facts, and the extra tests act as an interface to our (admittedly simple) ",NA,NA
"lexicon that lets the rules find exactly the information they need. Furthermore, we now take ",NA,NA
advantage of Prolog's first argument indexing which makes looking up a word in the lexicon ,NA,NA
more efficient. First argument indexing is a technique for making Prolog's knowledge base ,NA,NA
access more efficient. If in the query the first argument is instantiated it allows Prolog to ignore ,NA,NA
"all clauses, where the first argument's functor and arity is different. This means that we can get ",NA,NA
all the possible categories of e.g. ,NA,NA
man,NA,NA
 immediately without having to even look at the lexicon ,NA,NA
entries for all the other hundreds or thousands of words that we might have in our lexicon.,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node70.html (3 of 3)11/3/2006 7:33:42 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
8.3 Concluding remarks,NA,NA
We now have a fairly useful picture of what DCGs are and what they can do for us. To ,NA,NA
"conclude, let's think about them from a somewhat higher level, from both a formal and a ",NA,NA
linguistic perspective.,NA,NA
"First the formal remarks. For the most part, we have presented DCGs as a simple tool for ",NA,NA
encoding context free grammars (or context free grammars enriched with features such as ,NA,NA
subject and object). But DCGs go beyond this. We saw that it was possible to write a DCG that ,NA,NA
"generated a non context free language. In fact, any program whatsoever can be written in ",NA,NA
"DCG notation. That is, DCGs are full-fledged programming language in their own right (they are ",NA,NA
"Turing-complete, to use the proper terminology). And although DCGs are usually ",NA,NA
"associated with linguistic applications, they can be useful for other purposes.",NA,NA
"So how good are DCGs from a linguistic perspective? Well, mixed. At one stage (in the early ",NA,NA
1980s) they were pretty much state of the art. They made it possible to code complex ,NA,NA
"grammars in a clear way, and to explore the interplay of syntactic and semantic ideas. ",NA,NA
Certainly any history of parsing in computational linguistics would give DCGs an honorable ,NA,NA
mention.,NA,NA
"Nonetheless, DCGs have drawbacks. For a start, their tendency to loop when the goal ordering ",NA,NA
is wrong (we saw an example in the last lecture when we added a rule for conjunctions) is ,NA,NA
annoying; we don't want to think about such issues when writing serious grammars. ,NA,NA
"Furthermore, while the ability to add extra arguments is useful, if we need to use lots of them ",NA,NA
(and for big grammars we will) it is a rather clumsy mechanism.,NA,NA
"It is important to notice, however, that these problems come up because of the way Prolog ",NA,NA
interprets DCG rules. They are not inherent to the DCG notation. Any of you who have done a ,NA,NA
course on parsing algorithms probably know that all top-down parsers loop on left-cursive ,NA,NA
"grammars. So, it is not surprising that Prolog, which interprets DCGs in a top-down fashion, ",NA,NA
loops on the left-recursive grammar rule ,NA,NA
s --> s conj s,NA,NA
. If we used a different strategy to ,NA,NA
"interpret DCGs, a bottom-up strategy e.g., we would not run into the same problem. Similarly, ",NA,NA
"if we didn't use Prolog's built in interpretation of DCGs, we could use the extra arguments for a ",NA,NA
"more sophisticated specification of feature structures, that would facilitate the use of large ",NA,NA
feature structures.,NA,NA
"DCGs as we saw them in this chapter, a nice notation for context free grammars enhanced ",NA,NA
"with some features that comes with a free parser/recognizer, are probably best viewed as a ",NA,NA
"convenient tool for testing new grammatical ideas, or for implementing reasonably complex ",NA,NA
"grammars for particular applications. DCGs are not perfect, but they are very useful. Even if ",NA,NA
"you have never programmed before, simply using what you have learned so far you are ready ",NA,NA
to start experimenting with reasonably sophisticated grammar writing. With a conventional ,NA,NA
programming language (such as C++ or Java) it simply wouldn't be possible to reach this stage ,NA,NA
"so soon. Things would be easier in functional languages (such as LISP, SML, or Haskell), but ",NA,NA
"even so, it is doubtful whether beginners could do so much so early.",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
8.4 Exercises,NA,NA
Exercise 8.1,NA,NA
Here's our basic DCG. ,NA,NA
"s --> np,vp. ",NA,NA
"np --> det,n. ",NA,NA
"vp --> v,np. ",NA,NA
vp --> v. ,NA,NA
det --> [the]. ,NA,NA
det --> [a]. ,NA,NA
n --> [woman]. ,NA,NA
n --> [man]. ,NA,NA
v --> [shoots].,NA,NA
Suppose we add the noun ``men'' (which is plural) and the verb ``shoot''. Then ,NA,NA
"we would want a DCG which says that ``The men shoot'' is ok, `The man shoots'' ",NA,NA
"is ok, ``The men shoots'' is not ok, and ``The man shoot'' is not ok. Change the ",NA,NA
DCG so that it correctly handles these sentences. Use an extra argument to cope ,NA,NA
with the singular/plural distinction.,NA,NA
Exercise 8.2,NA,NA
Translate the following DCG rule into the form Prolog uses: ,NA,NA
"kanga(V,R,Q) --> roo(V,R),jumps(Q,Q),{marsupial(V, R,Q)}.",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node72.html (1 of 2)11/3/2006 7:33:54 PM,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node72.html (2 of 2)11/3/2006 7:33:54 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
8.5 Practical Session 8,NA,NA
The purpose of Practical Session 8 is to help you get familiar with DCGs that make use of ,NA,NA
additional arguments and tests.,NA,NA
First some keyboard exercises: ,NA,NA
1.  Trace some examples using the DCG which uses extra arguments to handle the subject/ ,NA,NA
"object distinct, the DCG which produces parses, and the DCG which uses extra tests to ",NA,NA
separate lexicon and rules. Make sure you fully understand the way all three DCGs work. ,NA,NA
2.  Carry out traces on the DCG for ,NA,NA
" that was given in the text (that is, the DCG that ",NA,NA
gave the ,NA,NA
Count,NA,NA
 variable the values ,NA,NA
0,NA,NA
", ",NA,NA
succ(0),NA,NA
", ",NA,NA
succ(succ(0)),NA,NA
", and so on). Try ",NA,NA
cases ,NA,NA
where the three blocks of ,NA,NA
a,NA,NA
"s, ",NA,NA
b,NA,NA
"s, and ",NA,NA
c,NA,NA
s are indeed of the same length as well as ,NA,NA
queries ,NA,NA
where this is not the case. ,NA,NA
Now for some programming. We suggest two exercises. ,NA,NA
"1.  First, bring together all the things we have learned about DCGs for English into one ",NA,NA
"DCG. In particular, today we say how to use extra arguments to deal with the subject/ ",NA,NA
"object distinction, and in the exercises you were asked to use additional arguments to ",NA,NA
"deal with the singular/plural distinction. Write a DCG which handles both. Moreover, ",NA,NA
"write the DCG in such a way that it will produce parse trees, and makes use of a ",NA,NA
separate lexicon.,NA,NA
"2.  Once you have done this, extend the DCG so that noun phrases can be modified by ",NA,NA
"adjectives and simple prepositional phrases (that is, it should be able to handle noun ",NA,NA
phrases such as ``the small frightened woman on the table'' or ``the big fat cow under ,NA,NA
"the shower''). Then, further extend it so that the distinction between first, second, and ",NA,NA
third person pronouns is correctly handled (both in subject and object form).,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
9 A Closer Look at Terms,NA,NA
This lecture has three main goals: ,NA,NA
1.  To introduce the ,NA,NA
==,NA,NA
 predicate.,NA,NA
2.  To take a closer look at term structure. ,NA,NA
3.  To introduce operators.,G,NA
9.1 Comparing terms,G,NA
9.2 Terms with a special notation ,H,NA
9.2.1 Arithmetic terms ,H,NA
9.2.2 Lists as terms,G,NA
9.3 Examining Terms ,H,NA
9.3.1 Types of Terms ,H,NA
9.3.2 The Structure of Terms,G,NA
9.4 Operators ,H,NA
9.4.1 Properties of operators ,H,NA
9.4.2 Defining operators,G,NA
9.5 Exercises,G,NA
9.6 Practical Session,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.1 Comparing terms,NA,NA
"Prolog contains an important predicate for comparing terms, namely ",NA,NA
==,NA,NA
. This tests whether ,NA,NA
"two terms are identical. It does not instantiate variables, thus it is not the same as the ",NA,NA
unification predicate ,NA,NA
=,NA,NA
.,NA,NA
Let's look at some examples: ,NA,NA
?= a == a. ,NA,NA
yes ,NA,NA
?- a == b. ,NA,NA
no ,NA,NA
?- a == 'a'. ,NA,NA
yes,NA,NA
"These answers Prolog gives here should be obvious, though pay attention to the last one. It ",NA,NA
"tells us that, as far as Prolog is concerned, ",NA,NA
a,NA,NA
 and ,NA,NA
'a',NA,NA
 are literally the same object.,NA,NA
"Now let's look at examples involving variables, and explicitly compare ",NA,NA
==,NA,NA
 with the unification ,NA,NA
predicate ,NA,NA
=,NA,NA
. ,NA,NA
?- X==Y. ,NA,NA
no ,NA,NA
?- X=Y. ,NA,NA
X ,NA,NA
= ,NA,NA
_2808 ,NA,NA
Y ,NA,NA
= ,NA,NA
_2808 ,NA,NA
yes,NA,NA
"In these queries, ",NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 are uninstantiated variables; we haven't given them any value. Thus ,NA,NA
the first answer is correct: ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
" are not identical objects, so the ",NA,NA
==,NA,NA
 test fails. On the other ,NA,NA
"hand, the use of ",NA,NA
=,NA,NA
" succeeds, for ",NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 can be unified.,NA,NA
Let's now look at queries involving instantiated variables: ,NA,NA
"?- a=X, a==X. ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node75.html (1 of 3)11/3/2006 7:34:17 PM,NA
X = a ,NA,NA
yes,NA,NA
"The first conjunct, ",NA,NA
a=X,NA,NA
", binds ",NA,NA
X,NA,NA
 to ,NA,NA
a,NA,NA
. Thus when ,NA,NA
a==X,NA,NA
" is evaluated, the left-hand side and ",NA,NA
"right-hand sides are exactly the same Prolog object, and ",NA,NA
a==X,NA,NA
 succeeds.,NA,NA
A similar thing happens in the following query: ,NA,NA
"?- X=Y, X==Y. ",NA,NA
X ,NA,NA
= ,NA,NA
_4500 ,NA,NA
Y ,NA,NA
= ,NA,NA
_4500 ,NA,NA
yes,NA,NA
The conjunct ,NA,NA
X=Y,NA,NA
 first unifies the variables ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
. Thus when the second conjunct ,NA,NA
X==Y,NA,NA
 is ,NA,NA
"evaluated, the two variables are exactly the same Prolog object, and the second conjunct ",NA,NA
succeeds as well.,NA,NA
It should now be clear that ,NA,NA
=,NA,NA
 and ,NA,NA
==,NA,NA
" are very different, nonetheless there is an important ",NA,NA
relation between them. Namely this: ,NA,NA
==,NA,NA
 can be viewed as a stronger test for equality between ,NA,NA
terms than ,NA,NA
=,NA,NA
". That is, if ",NA,NA
term1,NA,NA
 and ,NA,NA
term,NA,NA
" are Prolog terms, and the query ",NA,NA
term1 == term2 ,NA,NA
"succeeds, then the query ",NA,NA
term1 = term2,NA,NA
 will succeed too.,NA,NA
Another predicate worth knowing about is ,NA,NA
\==,NA,NA
. This predicate is defined so that it succeeds ,NA,NA
precisely in those case where ,NA,NA
==,NA,NA
" fails. That is, it succeeds whenever two terms are not ",NA,NA
"identical, and fails otherwise. For example: ",NA,NA
?- a \== a. ,NA,NA
no ,NA,NA
a \== b. ,NA,NA
yes ,NA,NA
a \== 'a'. ,NA,NA
no,NA,NA
These should be clear; they are simply the opposite of the answers we got above when we ,NA,NA
used ,NA,NA
==,NA,NA
. Now consider: ,NA,NA
?- X\==a. ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node75.html (2 of 3)11/3/2006 7:34:17 PM,NA
X = _3719 ,NA,NA
yes,NA,NA
"Why this response? Well, we know from above that the query ",NA,NA
X==a,NA,NA
 fails (recall the way ,NA,NA
== ,NA,NA
treats uninstantiated variables). Thus ,NA,NA
X\==a,NA,NA
" should succeed, and it does.",NA,NA
Similarly: ,NA,NA
?- X\==Y. ,NA,NA
X ,NA,NA
= ,NA,NA
_798 ,NA,NA
Y ,NA,NA
= ,NA,NA
_799 ,NA,NA
yes,NA,NA
"Again, we know from above that the query ",NA,NA
X==Y,NA,NA
" fails, thus ",NA,NA
X\==Y,NA,NA
 succeeds,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.2 Terms with a special notation,NA,NA
"Sometimes terms look different to us, but Prolog regards them as identical. For example, when ",NA,NA
we compare ,NA,NA
a,NA,NA
 and ,NA,NA
'a',NA,NA
", we see two distinct strings of symbols, but Prolog treats them as ",NA,NA
identical. And in fact there are many other cases where Prolog regards two strings as being ,NA,NA
exactly the same term. Why? Because it makes programming more pleasant. Sometimes the ,NA,NA
"notation Prolog likes isn't as natural, as the notation we would like. So it is nice to be able to to ",NA,NA
"write programs in the notation we like, and to let Prolog run them in the notation it finds ",NA,NA
natural.,G,NA
9.2.1 Arithmetic terms,G,NA
9.2.2 Lists as terms,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.2.1 Arithmetic terms,NA,NA
The arithmetic predicates introduced earlier are a good example of this. As was mentioned in ,NA,NA
Chapter 5,NA,NA
", /, ",NA,NA
-,NA,NA
", ",NA,NA
*,NA,NA
", and ",NA,NA
\,NA,NA
" are functors, and arithmetic expressions such as ",NA,NA
  2+3,NA,NA
 are terms. ,NA,NA
And this is not an analogy. Apart from the fact that we can evaluate them with the help of ,NA,NA
is,NA,NA
", ",NA,NA
for Prolog strings of symbols such as ,NA,NA
2+3,NA,NA
 really are ,NA,NA
identical,NA,NA
 with ordinary complex terms: ,NA,NA
"?- 2+3 == +(2,3). ",NA,NA
yes ,NA,NA
"?- +(2,3) == 2+3. ",NA,NA
yes ,NA,NA
"?- 2-3 == -(2,3). ",NA,NA
yes ,NA,NA
"?- *(2,3) == 2*3. ",NA,NA
yes ,NA,NA
"?- 2*(7+2) == *(2,+(7,2)). ",NA,NA
yes,NA,NA
"In short, the familiar arithmetic notation is there for our convenience. Prolog doesn't regard it ",NA,NA
as different from the usual term notation.,NA,NA
Similar remarks to the arithmetic comparison predicates ,NA,NA
<,NA,NA
", ",NA,NA
=<,NA,NA
", ",NA,NA
=:=,NA,NA
", ",NA,NA
=\=,NA,NA
", ",NA,NA
>,NA,NA
 and ,NA,NA
>=,NA,NA
: ,NA,NA
"?- (2 < 3) == <(2,3). ",NA,NA
yes ,NA,NA
"?- (2 =< 3) == =<(2,3). ",NA,NA
yes ,NA,NA
"?- (2 =:= 3) == =:=(2,3). ",NA,NA
yes ,NA,NA
"?- (2 =\= 3) == =\=(2,3). ",NA,NA
yes ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node77.html (1 of 3)11/3/2006 7:34:28 PM,NA
"?- (2 > 3) == >(2,3). ",NA,NA
yes ,NA,NA
"?- (2 >= 3) == >=(2,3). ",NA,NA
yes,NA,NA
Two remarks. First these example show why it's nice to have the user friendly notation (would ,NA,NA
you want to have to work with expressions like ,NA,NA
"=:=(2,3)",NA,NA
"?). Second, note that we enclosed the ",NA,NA
"left hand argument in brackets. For example, we didn't ask ",NA,NA
"2 =:= 3 == =:=(2,3).",NA,NA
we asked ,NA,NA
"(2 =:= 3) == =:=(2,3).",NA,NA
"Why? Well, Prolog finds the query ",NA,NA
"2 =:= 3 == =:=(2,3)",NA,NA
 confusing (and can you blame it?). It's not ,NA,NA
sure whether to bracket the expressions as ,NA,NA
"(2 =:= 3) == =:=(2,3)",NA,NA
" (which is what we want), or ",NA,NA
2 ,NA,NA
"=:= (3 == =:=(2,3))",NA,NA
. So we need to indicate the grouping explicitly.,NA,NA
"One final remark. We have now introduced three rather similar looking symbols, namely ",NA,NA
=,NA,NA
", ",NA,NA
==,NA,NA
", ",NA,NA
and ,NA,NA
=:=,NA,NA
" (and indeed, there's also ",NA,NA
\=,NA,NA
", ",NA,NA
\==,NA,NA
", and ",NA,NA
=\=,NA,NA
). Here's a summary: ,NA,NA
= ,NA,NA
The unification predicate.,NA,NA
\=,NA,NA
"Succeeds if it can unify its arguments, fails otherwise. ",NA,NA
The negation of the unification predicate.,NA,NA
==,NA,NA
Succeeds if ,NA,NA
=,NA,NA
" fails, and vice-versa. ",NA,NA
The identity predicate.,NA,NA
"Succeeds if its arguments are identical, fails otherwise.",NA,NA
\==,NA,NA
 The negation of the identity predicate.,NA,NA
Succeeds if ,NA,NA
==,NA,NA
" fails, and vice-versa.",NA,NA
=:=,NA,NA
 The arithmetic equality predicate.,NA,NA
Succeeds if its arguments evaluate to the same integer.,NA,NA
=\=,NA,NA
 The arithmetic inequality predicate.,NA,NA
Succeeds if its arguments evaluate to different integers.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node77.html (2 of 3)11/3/2006 7:34:28 PM,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
9.2.2 Lists as terms,NA,NA
"Lists are another good example where Prolog works with one internal representation, and ",NA,NA
gives us another more user friendly notation to work with. Let's start with a quick look at the ,NA,NA
"user friendly notation (that is, the use of the square bracket ",NA,NA
[,NA,NA
 and ,NA,NA
],NA,NA
"). In fact, because Prolog ",NA,NA
also offers the ,NA,NA
|,NA,NA
" constructor, there are are many ways of writing the same list, even at the ",NA,NA
user friendly level: ,NA,NA
"?- [a,b,c,d] == [a |[b,c,d]]. ",NA,NA
yes ,NA,NA
"?- [a,b,c,d] == [a,b |[c,d]]. ",NA,NA
yes ,NA,NA
"?- [a,b,c,d] == [a,b,c |[d]]. ",NA,NA
yes ,NA,NA
"?- [a,b,c,d] == [a,b,c,d |[]]. ",NA,NA
yes,NA,NA
"But how does Prolog view lists? In fact, Prolog sees lists as terms which are built out of two ",NA,NA
"special terms, namely ",NA,NA
[],NA,NA
", which represents the empty list, and ",NA,NA
.,NA,NA
", a functor of arity 2 which is ",NA,NA
used to build non-empty list (the terms ,NA,NA
[],NA,NA
 and ,NA,NA
.,NA,NA
 are called list constructors).,NA,NA
"Here's how these constructors are used to build lists. Needless to say, the definition is ",NA,NA
recursive: ,G,NA
The empty list is the term ,NA,NA
[],NA,NA
. The empty list has length 0.,G,NA
A non-empty list is any term of the form ,NA,NA
".(term,list)",NA,NA
", where ",NA,NA
term,NA,NA
 can be any Prolog ,NA,NA
"term, and ",NA,NA
list,NA,NA
 is any list. If ,NA,NA
list,NA,NA
" has length , then ",NA,NA
".(term,list)",NA,NA
 has length ,NA,NA
.,NA,NA
"?- .(a,[]) == [a]. ",NA,NA
yes ,NA,NA
"?- .(f(d,e),[]) == [f(d,e)]. ",NA,NA
yes ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node78.html (1 of 3)11/3/2006 7:34:33 PM,NA
"?- .(a,.(b,[])) == [a,b]. ",NA,NA
yes ,NA,NA
"?- .(a,.(b,.(f(d,e),[]))) == [a,b,f(d,e)]. yes ",NA,NA
"?- .(.(a,[]),[]) == [[a]]. ",NA,NA
yes ,NA,NA
"?- .(.(.(a,[]),[]),[]) == [[[a]]]. ",NA,NA
yes ,NA,NA
"?- .(.(a,.(b,[])),[]) == [[a,b]]. ",NA,NA
yes ,NA,NA
"?- .(.(a,.(b,[])),.(c,[])) == [[a,b],c]. yes ",NA,NA
"?- .(.(a,[]),.(b,.(c,[]))) == [[a],b,c]. yes ",NA,NA
"?- .(.(a,[]),.(.(b,.(c,[])),[])) == [[a],[b,c]]. yes",NA,NA
"Again, it is clear that Prolog's internal notation for lists is not as user friendly as the use of the ",NA,NA
"square bracket notation. But actually, it's not as bad as it seems at first sight. It is very similar ",NA,NA
to the ,NA,NA
|,NA,NA
" notation. It represents a list in two parts: its first element or head, and a list ",NA,NA
representing the rest of the list. The trick is to read these terms as trees. The internal nodes of ,NA,NA
this tree are labeled with ,NA,NA
.,NA,NA
 and all have two daughter nodes. The subtree under the left ,NA,NA
daughter is representing the first element of the list and the subtree under the right daughter ,NA,NA
"the rest of the list. So, the tree representation of ",NA,NA
".(a,.(.(b,.(c,[])),.(d,[])))",NA,NA
", i.e. ",NA,NA
"[a, [b,c], d]",NA,NA
", looks like this: ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node78.html (2 of 3)11/3/2006 7:34:33 PM,NA
One final remark. Prolog is very polite. Not only are you free to talk to it in your own user ,NA,NA
"friendly notation, it will reply in the same way. ",NA,NA
"?- .(f(d,e),[]) = Y. ",NA,NA
"Y = [f(d,e)] ",NA,NA
yes ,NA,NA
"?- .(a,.(b,[])) = X, Z= .(.(c,[]),[]), W = [1,2,X,Z]. ",NA,NA
"X = [a,b] ",NA,NA
Z = [[c]] ,NA,NA
"W = [1,2,[a,b],[[c]]] ",NA,NA
yes,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.3 Examining Terms,NA,NA
"In this section, we will learn about a couple of built-in predicates that let us examine terms ",NA,NA
"more closely. First, we will look at predicates that test whether their arguments are terms of a ",NA,NA
"certain type, whether they are, for instance, an atom or a number. Then, we will see predicates ",NA,NA
that tell us something about the structure of complex terms.,G,NA
9.3.1 Types of Terms,G,NA
9.3.2 The Structure of Terms,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.3.1 Types of Terms,NA,NA
Remember what we said about terms in Prolog in the very first lecture. We saw that there are ,NA,NA
"different kinds of terms, namely variables, atoms, numbers and complex terms and what they ",NA,NA
"look like. Furthermore, we said that atoms and numbers are grouped together under the name ",NA,NA
constants and constants and variables constitute the simple terms. The following picture ,NA,NA
summarizes this: ,NA,NA
"Sometimes it is useful to know of which type a given term is. You might, for instance, want to ",NA,NA
"write a predicate that has to deal with different kinds of terms, but has to treat them in ",NA,NA
different ways. Prolog provides a couple of built-in predicates that test whether a given term is ,NA,NA
of a certain type. Here they are: ,NA,NA
atom/1,NA,NA
Tests whether the argument is an atom.,NA,NA
integer/1,NA,NA
" Tests whether the argument is an integer, such as ",NA,NA
4,NA,NA
", ",NA,NA
10,NA,NA
", or ",NA,NA
-6,NA,NA
.,NA,NA
float/1,NA,NA
"Tests whether the argument is a floating point number, such as ",NA,NA
1.3,NA,NA
 or ,NA,NA
5.0,NA,NA
.,NA,NA
number/1,NA,NA
"Tests whether the argument is a number, i.e. an integer or a float",NA,NA
atomic/1,NA,NA
Tests whether the argument is a constant.,NA,NA
var/1,NA,NA
Tests whether the argument is uninstantiated.,NA,NA
nonvar/1,NA,NA
Tests whether the argument is instantiated.,NA,NA
"So, let's see how they behave. ",NA,NA
?- atom(a). ,NA,NA
yes ,NA,NA
?- atom(7). ,NA,NA
no ,NA,NA
"?- atom(loves(vincent,mia)). ",NA,NA
no,NA,NA
These three examples for the behavior of ,NA,NA
atom/1,NA,NA
 is pretty much what one would expect of a ,NA,NA
"predicate for testing whether a term is an atom. But what happens, when we call ",NA,NA
atom/1 ,NA,NA
with ,NA,NA
a variable as argument? ,NA,NA
?- atom(X). ,NA,NA
no,NA,NA
"This makes sense, since an uninstantiated variable is not an atom. If we, however, instantiate ",NA,NA
X,NA,NA
 with an atom first and then ask ,NA,NA
atom(X),NA,NA
", Prolog answers `yes'. ",NA,NA
"?- X = a, atom(X). ",NA,NA
X = a ,NA,NA
yes,NA,NA
But it is important that the instantiation is done before the test: ,NA,NA
"?- atom(X), X = a. ",NA,NA
no,NA,NA
number/1,NA,NA
", ",NA,NA
integer/1,NA,NA
", and ",NA,NA
float/1,NA,NA
 behave analogously. Try it!,NA,NA
atomic/1,NA,NA
" tests whether a given term is a constant, i.e. whether it is either an atom or a ",NA,NA
number. So ,NA,NA
atomic/1,NA,NA
 will evaluate to true whenever either ,NA,NA
atom/1,NA,NA
 or ,NA,NA
number/1,NA,NA
 evaluate to ,NA,NA
true and it fails when both of them fail. ,NA,NA
?- atomic(mia). ,NA,NA
yes ,NA,NA
?- atomic(8). ,NA,NA
yes ,NA,NA
"?- atomic(loves(vincent,mia)). ",NA,NA
no ,NA,NA
?- atomic(X) ,NA,NA
no,NA,NA
Finally there are two predicates to test whether the argument is an uninstantiated or ,NA,NA
instantiated variable. So: ,NA,NA
?- var(X) ,NA,NA
yes ,NA,NA
"?- var(loves(vincent,mia)). ",NA,NA
no ,NA,NA
"?- nonvar(loves(vincent,mia)). ",NA,NA
yes ,NA,NA
?- nonvar(X). ,NA,NA
no,NA,NA
"Note that a complex term which contains uninstantiated variables, is of course not an ",NA,NA
uninstantiated variable itself (but a complex term). Therefore: ,NA,NA
"?- var(loves(_,mia)). ",NA,NA
no ,NA,NA
"?- nonvar(loves(_,mia)). ",NA,NA
yes,NA,NA
"And again, when the variable ",NA,NA
X,NA,NA
 gets instantiated ,NA,NA
var(X),NA,NA
 and ,NA,NA
nonvar(X),NA,NA
 behave differently ,NA,NA
depending on whether they are called before or after the instantiation. ,NA,NA
"?- X = a, var(X). ",NA,NA
no ,NA,NA
"?- var(X), X = a. ",NA,NA
X = a ,NA,NA
yes,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
9.3.2 The Structure of Terms,NA,NA
"Given a complex term of which you don't know what it looks like, what kind of information ",NA,NA
"would be interesting to get? Probably, what's the functor, what's the arity and what do the ",NA,NA
arguments look like. Prolog provides built-in predicates that answer these questions. The first ,NA,NA
two are answered by the predicate ,NA,NA
functor/3,NA,NA
. Given a complex term ,NA,NA
functor/3,NA,NA
 will tell us what ,NA,NA
the functor and the arity of this term are. ,NA,NA
"?- functor(f(a,b),F,A). ",NA,NA
A = 2 ,NA,NA
F = f ,NA,NA
yes ,NA,NA
"?- functor(a,F,A). ",NA,NA
A = 0 ,NA,NA
F = a ,NA,NA
yes ,NA,NA
"?- functor([a,b,c],X,Y). ",NA,NA
X = '.' ,NA,NA
Y = 2 ,NA,NA
yes,NA,NA
"So, we can use the predicate ",NA,NA
functor,NA,NA
" to find out the functor and the arity of a term, but we can ",NA,NA
"also use it to construct terms, by specifying the second and third argument and leaving the ",NA,NA
first undetermined. The query ,NA,NA
"?- functor(T,f,8).",NA,NA
"for example, returns the following answer: ",NA,NA
T = f ,NA,NA
"(_G286, _G287, _G288, _G289, _G290, _G291, _G292, _G293) yes",NA,NA
"Note, that either the first argument or the second and third argument have to be instantiated. ",NA,NA
"So, Prolog would answer with an error message to the query ",NA,NA
"functor(T,f,N)",NA,NA
. If you think about ,NA,NA
"what the query means, Prolog is reacting in a sensible way. The query is asking Prolog to ",NA,NA
construct a complex term without telling it how many arguments to provide and that is ,NA,NA
something Prolog can just not do.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node81.html (1 of 4)11/3/2006 7:34:53 PM,NA
"In the previous section, we saw built-in predicates for testing whether something is an atom, a ",NA,NA
"number, a constant, or a variable. So, to make the list complete, we were actually missing a ",NA,NA
"predicate for testing whether something is a complex term. Now, we can define such a ",NA,NA
predicate by making use of the predicate ,NA,NA
functor,NA,NA
. All we have to do is to check that the term is ,NA,NA
"instantiated and that it has arguments, i.e. that its arity is greater than zero. Here is the ",NA,NA
predicate definition. ,NA,NA
complexterm(X) :- ,NA,NA
" nonvar(X), ",NA,NA
" functor(X,_,A), ",NA,NA
 A > 0.,NA,NA
In addition to the predicate ,NA,NA
functor,NA,NA
 there is the predicate ,NA,NA
arg/3,NA,NA
 which tells us about ,NA,NA
arguments of complex terms. It takes a number N and a complex term T and returns the Nth ,NA,NA
argument of T in its third argument. It can be used to access the value of an argument ,NA,NA
"?- arg(2,loves(vincent,mia),X). ",NA,NA
X = mia ,NA,NA
yes,NA,NA
or to instantiate an argument. ,NA,NA
"?- arg(2,loves(vincent,X),mia). ",NA,NA
X = mia ,NA,NA
yes,NA,NA
"Trying to access an argument which doesn't exist, of course fails. ",NA,NA
"?- arg(2,happy(yolanda),X). ",NA,NA
no,NA,NA
The third useful built-in predicate for analyzing term structure is ,NA,NA
'=..'/2,NA,NA
. It takes a complex term ,NA,NA
and returns a list that contains the functor as first element and then all the arguments. ,NA,NA
"So, when asked the query ",NA,NA
"'=..'(loves(vincent,mia),X)",NA,NA
 Prolog will answer ,NA,NA
"X = [loves,vincent,mia]",NA,NA
. This predicate is also called univ and can be used as an infix operator. ,NA,NA
Here are a couple of examples. ,NA,NA
"?- cause(vincent,dead(zed)) =.. X. ",NA,NA
"X = [cause, vincent, dead(zed)] ",NA,NA
Yes ,NA,NA
"?- X =.. [a,b(c),d]. ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node81.html (2 of 4)11/3/2006 7:34:53 PM,NA
"X = a(b(c), d) ",NA,NA
Yes ,NA,NA
"?- footmassage(Y,mia) =.. X. ",NA,NA
Y = _G303 ,NA,NA
"X = [footmassage, _G303, mia] ",NA,NA
Yes,NA,NA
Univ (,NA,NA
'=..',NA,NA
) is always useful when something has to be done to all arguments of a complex ,NA,NA
"term. Since it returns the arguments as a list, normal list processing strategies can be used to ",NA,NA
"traverse the arguments. As an example, let's define a predicate called ",NA,NA
copy_term,NA,NA
 which makes ,NA,NA
a copy of a term replacing variables that occur in the original term by new variables in the ,NA,NA
copy. The copy of ,NA,NA
dead(zed),NA,NA
 should be ,NA,NA
dead(zed),NA,NA
", for instance. And the copy of ",NA,NA
"jeallou(marcellus,X)",NA,NA
 should be ,NA,NA
"jeallous(marcellus,_G235)",NA,NA
; i.e. the variable ,NA,NA
X,NA,NA
 in the original term ,NA,NA
has been replaces by some new variable.,NA,NA
"So, the predicate ",NA,NA
copy_term,NA,NA
 has two arguments. It takes any Prolog term in the first ,NA,NA
argument and returns a copy of this Prolog term in the second argument. In case the input ,NA,NA
"argument is an atom or a number, the copying is simple: the same term should be returned. ",NA,NA
"copy_term(X,X) :- atomic(X).",NA,NA
"In case the input term is a variable, the copy should be a new variable. ",NA,NA
"copy_term(X,_) :- var(X).",NA,NA
With these two clauses we have defined how to copy simple terms. What about complex ,NA,NA
"terms? Well, ",NA,NA
copy_term,NA,NA
 should return a complex term with the same functor and arity and all ,NA,NA
arguments of this new complex term should be copies of the corresponding arguments in the ,NA,NA
"input term. That means, we have to look at all arguments of the input term and copy them ",NA,NA
with recursive calls to ,NA,NA
copy_term,NA,NA
. Here is the Prolog code for this third clause: ,NA,NA
"copy_term(X,Y) :- ",NA,NA
" nonvar(X), ",NA,NA
" functor(X,F,A), ",NA,NA
" A > 0, ",NA,NA
" functor(Y,F,A), ",NA,NA
" X =.. [F|ArgsX], ",NA,NA
" Y =.. [F|ArgsY], ",NA,NA
" copy_terms_in_list(ArgsX,ArgsY).",NA,NA
"copy_terms_in_list([],[]). ",NA,NA
"copy_terms_in_list([HIn|TIn],[HOut|TOut]) :- ",NA,NA
" copy_term(HIn,Hout), ",NA,NA
" copy_terms_in_list(TIn,TOut). ",NA,NA
"So, we first check whether the input term is a complex term: it is not a variable and its arity is ",NA,NA
"greater than 0. We then request that the copy should have the same functor and arity. Finally, ",NA,NA
"we have to copy all arguments of the input term. To do so, we use univ to collect the ",NA,NA
arguments into a list and then use a simple list processing predicate ,NA,NA
copy_terms_in_list ,NA,NA
to one ,NA,NA
by one copy the elements of this list.,NA,NA
Here is the whole code for ,NA,NA
copy_term,NA,NA
: ,NA,NA
"copy_term(X,_) :- var(X). ",NA,NA
"copy_term(X,X) :- atomic(X). ",NA,NA
"copy_term(X,Y) :- ",NA,NA
" nonvar(X), ",NA,NA
" functor(X,F,A), ",NA,NA
" functor(Y,F,A), ",NA,NA
" A > 0, ",NA,NA
" X =.. [F|ArgsX], ",NA,NA
" Y =.. [F|ArgsY], ",NA,NA
" copy_terms_in_list(ArgsX,ArgsY). ",NA,NA
"copy_terms_in_list([],[]). ",NA,NA
"copy_terms_in_list([HIn|TIn],[HOut|TOut]) :-  ",NA,NA
"copy_term(HIn,Hout), ",NA,NA
" copy_terms_in_list(TIn,TOut). ",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.4 Operators,G,NA
9.4.1 Properties of operators ,G,NA
9.4.2 Defining operators,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.4.1 Properties of operators,NA,NA
"By now, we have seen several times already that, in certain cases, Prolog let's us use a more ",NA,NA
user friendly notation than what it will use as its internal representation. The notation for ,NA,NA
"arithmetic operators was an example. Internally, Prolog will use ",NA,NA
"is(11,+(2,*(3,3)))",NA,NA
", but we can ",NA,NA
write ,NA,NA
11 is 2 + 3 * 3,NA,NA
. Such functors that can be written in between their arguments are called ,NA,NA
infix operators. Other infix operators in Prolog are for example ,NA,NA
:-,NA,NA
", ",NA,NA
-->,NA,NA
", ",NA,NA
;,NA,NA
", ",NA,NA
"','",NA,NA
", ",NA,NA
=,NA,NA
", ",NA,NA
=..,NA,NA
", ",NA,NA
==,NA,NA
 and so ,NA,NA
"on. Infix operators are called infix operators, because they are written between their ",NA,NA
"arguments. There are also prefix operators that are written before their argument, and postfix ",NA,NA
operators which are written after their argument. ,NA,NA
?-,NA,NA
" for example is a prefix operator, and so is ",NA,NA
the one-place ,NA,NA
-,NA,NA
 which is used to represent negative numbers as in ,NA,NA
1 is 3 + -2,NA,NA
. ,NA,NA
"When we learned about arithmetic in Prolog, we saw that Prolog knows about the conventions ",NA,NA
"for disambiguating arithmetic expressions. So, when we write ",NA,NA
2 + 3 * 3,NA,NA
" for example, Prolog ",NA,NA
knows that we mean ,NA,NA
2 + (3 * 3),NA,NA
 and not ,NA,NA
(2 + 3) * 3,NA,NA
. But how does Prolog know this? Every ,NA,NA
operator has a certain precedence. The precedence of ,NA,NA
+,NA,NA
 is greater than the precedence of ,NA,NA
*,NA,NA
. ,NA,NA
That's why ,NA,NA
+,NA,NA
 is taken to be the main functor of the expression ,NA,NA
2 + 3 * 3,NA,NA
. (Note that Prolog's ,NA,NA
internal representation ,NA,NA
"+(2,*(3,3))",NA,NA
" is not ambiguous.) Similarly, the precedence of ",NA,NA
is,NA,NA
 is higher ,NA,NA
than the precedence of ,NA,NA
+,NA,NA
", so that ",NA,NA
11 is 2 + 3 * 3,NA,NA
 is interpreted as ,NA,NA
"is(11, +(2,*(3,3)))",NA,NA
 and not as ,NA,NA
"+(is(11,2),*(3,3))",NA,NA
" (which wouldn't make any sense, by the way). In Prolog precedence is ",NA,NA
"expressed by numbers. The higher this number, the greater the precedence. ",NA,NA
But what happens when there are several operators with the same precedence in one ,NA,NA
expression? We said that above that Prolog finds the query ,NA,NA
"2 =:= 3 == =:=(2,3) ",NA,NA
"confusing, because it doesn't know how to bracket the expression (is it ",NA,NA
"=:=(2,==(3,=:= (2,3)))",NA,NA
 or ,NA,NA
is it ,NA,NA
"==(=:=(2,3),=:=(2,3))",NA,NA
?). The reason for why Prolog is not able to decide which is the correct ,NA,NA
bracketing is of course that ,NA,NA
==,NA,NA
 and ,NA,NA
=:=,NA,NA
 have the same precedence.,NA,NA
"What about the following query, though? ",NA,NA
?- X is 2 + 3 + 4.,NA,NA
"Does Prolog find it confusing? No, Prolog correctly answers ",NA,NA
X = 9,NA,NA
". So, which bracketing did ",NA,NA
Prolog choose: ,NA,NA
"is(X,+(2,+(3,4)))",NA,NA
 or ,NA,NA
"is(X,+(+(2,3),4))",NA,NA
? It chose the second one as can be tested ,NA,NA
with the following queries. ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node83.html (1 of 2)11/3/2006 7:35:04 PM,NA
"?- 2 + 3 + 4 = +(2,+(3,4)). ",NA,NA
No ,NA,NA
"?- 2 + 3 + 4 = +(+(2,3),4). ",NA,NA
Yes,NA,NA
Prolog uses information about the associativity of ,NA,NA
+,NA,NA
 here to disambiguate the expressions. ,NA,NA
+,NA,NA
 is ,NA,NA
"left associative, which means that the expression to the right of ",NA,NA
+,NA,NA
 must have a lower ,NA,NA
precedence than ,NA,NA
+,NA,NA
" itself, whereas the expression on the left may have the same precedence as ",NA,NA
+,NA,NA
". The precedence of an expression is simply the precedence of its main operator or 0, if it is ",NA,NA
enclosed in brackets. The main operator of ,NA,NA
3 + 4,NA,NA
 is ,NA,NA
+,NA,NA
", so that interpreting ",NA,NA
2 + 3 + 4,NA,NA
 as ,NA,NA
"+(2,+(3,4))",NA,NA
 would mean that the expression to the right of the first ,NA,NA
+,NA,NA
 has the same precedence ,NA,NA
as ,NA,NA
+,NA,NA
" itself, which is illegal. It has to be lower.",NA,NA
The operators ,NA,NA
==,NA,NA
", ",NA,NA
=:=,NA,NA
", and ",NA,NA
is,NA,NA
 are defined to be non-associative which means that both of their ,NA,NA
"arguments must have a lower precedence. Therefore, ",NA,NA
"2 =:= 3 == =:=(2,3)",NA,NA
" is illegal, since no ",NA,NA
"matter how you bracket it, you'll get a conflict: ",NA,NA
2 =:= 3,NA,NA
 has the same precedence as ,NA,NA
==,NA,NA
", and ",NA,NA
3 ,NA,NA
"== =:=(2,3)",NA,NA
 has the same precedence as ,NA,NA
=:=,NA,NA
.,NA,NA
"The type of an operator (infix, prefix, or postfix), its precedence, and its associativity are the ",NA,NA
"three things that Prolog needs to know to be able to translate the user friendly, but potentially ",NA,NA
ambiguous operator notation into Prolog's internal representation.,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
9.4.2 Defining operators,NA,NA
"In addition to providing a user friendly operator notation for certain functors, Prolog also let's ",NA,NA
you define your own operators. So you could for example define a postfix operator ,NA,NA
is_dead ,NA,NA
and ,NA,NA
then Prolog would allow you to write ,NA,NA
zed is_dead,NA,NA
 as a fact in your database instead of ,NA,NA
is_dead(zed),NA,NA
.,NA,NA
Operator definitions in Prolog look like this: ,NA,NA
:- op(,NA,NA
Precedence,NA,NA
", ",NA,NA
Type,NA,NA
", ",NA,NA
Name,NA,NA
).,NA,NA
Precedence is a number between 0 and 1200. The precedence of ,NA,NA
=,NA,NA
", for instance, is 700, the ",NA,NA
precedence of ,NA,NA
+,NA,NA
" is 500, and the precedence of ",NA,NA
*,NA,NA
 400. Type is an atom specifying the type and ,NA,NA
associativity of the operator. In the case of ,NA,NA
+,NA,NA
 this atom is ,NA,NA
yfx,NA,NA
", which says that ",NA,NA
+,NA,NA
 is an infix ,NA,NA
operator ,NA,NA
f,NA,NA
 represents the operator and ,NA,NA
x,NA,NA
 and ,NA,NA
y,NA,NA
" the arguments. Furthermore, ",NA,NA
x,NA,NA
 stands for an ,NA,NA
argument which has a precedence which is lower than the precedence of ,NA,NA
+,NA,NA
 and ,NA,NA
y,NA,NA
 stands for an ,NA,NA
argument which has a precedence which lower or equal to the precedence of ,NA,NA
+,NA,NA
. There are the ,NA,NA
following possibilities for what Type may look like: ,NA,NA
infix,NA,NA
xfx,NA,NA
", ",NA,NA
xfy,NA,NA
", ",NA,NA
yfx,NA,NA
prefix,NA,NA
 fx,NA,NA
", ",NA,NA
fy,NA,NA
suffix,NA,NA
 xf,NA,NA
", ",NA,NA
yf,NA,NA
"So, your operator definition for ",NA,NA
is_dead,NA,NA
 could look as follows: ,NA,NA
":- op(500, xf, is_dead).",NA,NA
Here are the definitions for some of the built-in operators. You can see that operators with the ,NA,NA
same properties can be specified in one statement by giving a list of their names instead of a ,NA,NA
single name as third argument of ,NA,NA
op,NA,NA
. ,NA,NA
":- op( 1200, xfx, [ :-, --> ]).",NA,NA
":- op( 1200,  fx, [ :-, ?- ]).",NA,NA
":- op( 1100, xfy, [ ; ]).",NA,NA
":- op( 1000, xfy, [ ',' ]).",NA,NA
":- op(  700, xfx, [ =, is, =.., ==, \==, ",NA,NA
" =:=, =\=, <, >, =<, >= ]).",NA,NA
":- op(  500, yfx, [ +, -]).",NA,NA
":- op(  500,  fx, [ +, - ]).",NA,NA
":- op(  300, xfx, [ mod ]).",NA,NA
":- op(  200, xfy, [ ^ ]).",NA,NA
"One final thing to note is, that operator definitions don't specify the meaning of an operator, ",NA,NA
but only describe how it can be used syntactically. An operator definition doesn't say anything ,NA,NA
about when a query involving this operator will evaluate to true. It is only a definition ,NA,NA
"extending the syntax of Prolog. So, if the operator ",NA,NA
is_dead,NA,NA
 is defined as above and you ask the ,NA,NA
query ,NA,NA
zed is_dead,NA,NA
", Prolog won't complain about illegal syntax (as it would without this ",NA,NA
"definition), but it will try to prove the goal ",NA,NA
is_dead(zed),NA,NA
", which is Prolog's internal ",NA,NA
representation of ,NA,NA
zed is_dead,NA,NA
. And this is what operator definitions do. They just tell Prolog how ,NA,NA
"to translate a user friendly notation into real Prolog notation. So, what would be Prolog's ",NA,NA
answer to the query ,NA,NA
zed is_dead,NA,NA
? It would be ,NA,NA
no,NA,NA
", because Prolog would try to prove ",NA,NA
is_dead(zed),NA,NA
", but not find any matching clause in the database. Unless, of course, your ",NA,NA
"database would look like this, for instance: ",NA,NA
":- op(500, xf, is_dead). ",NA,NA
"kill(marsellus,zed). ",NA,NA
"is_dead(X) :- kill(_,X).",NA,NA
"In this case, Prolog would answer ",NA,NA
yes,NA,NA
 to the query ,NA,NA
zed is_dead,NA,NA
.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
9.5 Exercises,NA,NA
Exercise 9.1,NA,NA
"Which of the following queries succeed, and which fail? ",NA,NA
?- 12 is 2*6 ,NA,NA
?- 14 =\= 2*6 ,NA,NA
?- 14 = 2*7 ,NA,NA
?- 14 == 2*7 ,NA,NA
?- 14 \== 2*7 ,NA,NA
?- 14 =:= 2*7 ,NA,NA
"?- [1,2,3|[d,e]] == [1,2,3,d,e] ?- 2+3 == 3+2 ",NA,NA
?- 2+3 =:= 3+2 ,NA,NA
?- 7-2 =\= 9-2 ,NA,NA
?- p == 'p' ,NA,NA
?- p =\= 'p' ,NA,NA
?- vincent == VAR ,NA,NA
"?- vincent=VAR,VAR==vincent ",NA,NA
Exercise 9.2,NA,NA
How does Prolog respond to the following queries? ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node85.html (1 of 3)11/3/2006 7:35:18 PM,NA
"?- .(a,.(b,.(c,[]))) = [a,b,c] ",NA,NA
"?- .(a,.(b,.(c,[]))) = [a,b|[c]] ",NA,NA
"?- .(.(a,[]),.(.(b,[]),.(.(c,[]),[]))) = X ",NA,NA
"?- .(a,.(b,.(.(c,[]),[]))) = [a,b|[c]]",NA,NA
Exercise 9.3,NA,NA
Write a two-place predicate ,NA,NA
"termtype(+Term,?Type)",NA,NA
 that takes a term and gives ,NA,NA
"back the type(s) of that term (atom, number, constant, variable etc.). The types ",NA,NA
"should be given back in the order of their generality. The predicate should, e.g., ",NA,NA
behave in the following way. ,NA,NA
"?- termtype(Vincent,variable). ",NA,NA
yes ,NA,NA
"?- termtype(mia,X). ",NA,NA
X = atom ; ,NA,NA
X = constant ; ,NA,NA
X = simple_term ; ,NA,NA
X = term ; ,NA,NA
no ,NA,NA
"?- termtype(dead(zed),X). ",NA,NA
X = complex_term ; ,NA,NA
X = term ; ,NA,NA
no,NA,NA
Exercise 9.4,NA,NA
Write a program that defines the predicate ,NA,NA
groundterm(+Term),NA,NA
 which tests ,NA,NA
whether ,NA,NA
Term,NA,NA
 is a ground term. Ground terms are terms that don't contain ,NA,NA
variables. Here are examples of how the predicate should behave: ,NA,NA
?- groundterm(X). ,NA,NA
no ,NA,NA
"?- groundterm(french(bic_mac,le_bic_mac)). ",NA,NA
yes ,NA,NA
"?- groundterm(french(whopper,X)). ",NA,NA
no,NA,NA
Exercise 9.5,NA,NA
Assume that we have the following operator definitions. ,NA,NA
":- op(300, xfx, [are, is_a]). ",NA,NA
":- op(300, fx, likes). ",NA,NA
":- op(200, xfy, and). ",NA,NA
":- op(100, fy, famous).",NA,NA
Which of the following is a wellformed term? What is the main operator? Give the ,NA,NA
bracketing. ,NA,NA
?- X is_a witch. ,NA,NA
?- harry and ron and hermione are friends. ?- harry is_a ,NA,NA
wizard and likes quidditch. ,NA,NA
?- dumbledore is_a famous famous wizard.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
9.6 Practical Session,NA,NA
"In this practical session, we want to introduce some built-in predicates for printing terms onto ",NA,NA
the screen. The first predicate we want to look at is ,NA,NA
display/1,NA,NA
", which takes a term and prints it ",NA,NA
onto the screen. ,NA,NA
"?- display(loves(vincent,mia)). ",NA,NA
"loves(vincent, mia) ",NA,NA
Yes ,NA,NA
?- display('jules eats a big kahuna burger'). ,NA,NA
jules eats a big kahuna burger ,NA,NA
Yes,NA,NA
"More strictly speaking, ",NA,NA
display,NA,NA
 prints Prolog's internal representation of terms. ,NA,NA
?- display(2+3+4). ,NA,NA
"+(+(2, 3), 4) ",NA,NA
Yes,NA,NA
"In fact, this property of ",NA,NA
display,NA,NA
 makes it a very useful tool for learning how operators work in ,NA,NA
"Prolog. So, before going on to learn more about how to write things onto the screen, try the ",NA,NA
following queries. Make sure you understand why Prolog answers the way it does. ,NA,NA
"?- display([a,b,c]). ",NA,NA
?- display(3 is 4 + 5 / 3). ,NA,NA
?- display(3 is (4 + 5) / 3). ,NA,NA
"?- display((a:-b,c,d)). ",NA,NA
"?- display(a:-b,c,d).",NA,NA
"So, display is nice to look at the internal representation of terms in operator notation, but ",NA,NA
usually we would probably prefer to print the user friendly notation instead. Especially when ,NA,NA
"printing lists, it would be much nicer to get ",NA,NA
"[a,b,c]",NA,NA
", instead of ",NA,NA
".(a.(b.(c,[])))",NA,NA
. This is what the ,NA,NA
built-in predicate ,NA,NA
write/1,NA,NA
 does. It takes a term and prints it to the screen in the user friendly ,NA,NA
notation. ,NA,NA
?- write(2+3+4). ,NA,NA
2+3+4 ,NA,NA
Yes ,NA,NA
"?- write(+(2,3)). ",NA,NA
2+3 ,NA,NA
Yes ,NA,NA
"?- write([a,b,c]). ",NA,NA
"[a, b, c] ",NA,NA
Yes ,NA,NA
"?- write(.(a,.(b,[]))). ",NA,NA
"[a, b] ",NA,NA
Yes,NA,NA
"And here is what happens, when the term that is to be written contains variables. ",NA,NA
?- write(X). ,NA,NA
_G204 ,NA,NA
X = _G204 ,NA,NA
yes ,NA,NA
"?- X = a, write(X). ",NA,NA
a ,NA,NA
X = a ,NA,NA
Yes,NA,NA
The following example shows what happens when you put two write commands one after the ,NA,NA
other. ,NA,NA
"?- write(a),write(b). ",NA,NA
ab ,NA,NA
Yes,NA,NA
Prolog just executes one after the other without putting any space in between the output of ,NA,NA
"the different write commands. Of course, you can tell Prolog to print spaces by telling it to ",NA,NA
write the term ,NA,NA
' ',NA,NA
. ,NA,NA
"?- write(a),write(' '),write(b). ",NA,NA
a b ,NA,NA
Yes,NA,NA
"And if you want more than one space, for example five blanks, you can tell Prolog to write ",NA,NA
'     ,NA,NA
',NA,NA
. ,NA,NA
"?- write(a),write('     '),write(b). a     b ",NA,NA
Yes,NA,NA
Another way of printing spaces is by using the predicate ,NA,NA
tab/1,NA,NA
. ,NA,NA
tab,NA,NA
 takes a number as ,NA,NA
argument and then prints as many spaces as specified by that number. ,NA,NA
"?- write(a),tab(5),write(b). ",NA,NA
a     b ,NA,NA
Yes,NA,NA
Another predicate useful for formatting is ,NA,NA
nl,NA,NA
. ,NA,NA
nl,NA,NA
 tells Prolog to make a linebreak and to go on ,NA,NA
printing on the next line. ,NA,NA
"?- write(a),nl,write(b). ",NA,NA
a ,NA,NA
b ,NA,NA
Yes,NA,NA
"Here is an exercise, where you can apply what you just learned.",NA,NA
"In the last lecture, we saw how extra arguments in DCGs can be used to build a parse tree. ",NA,NA
"For example, to the query ",NA,NA
"s(T,[a,man,shoots,a,woman],[])",NA,NA
 Prolog would answer ,NA,NA
s(np ,NA,NA
"(det(a),n(man)),vp(v(shoots),np(det(a),n(woman))))",NA,NA
. This is a representation of the parse tree. ,NA,NA
"It is not a very readable representation, though. Wouldn't it be nicer if Prolog printed ",NA,NA
something like ,NA,NA
s( ,NA,NA
 np( ,NA,NA
 det(a) ,NA,NA
 n(man)) ,NA,NA
 vp( ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node86.html (3 of 4)11/3/2006 7:35:24 PM,NA
 v(shoots) ,NA,NA
 np( ,NA,NA
 det(a) ,NA,NA
 n(woman)))),NA,NA
for example?,NA,NA
Write a predicate ,NA,NA
pptree/1,NA,NA
" that takes a complex term representing a tree, such as ",NA,NA
s(np ,NA,NA
"(det(a),n(man)),vp(v(shoots),np(det(a),n(woman))))",NA,NA
", as its argument and prints a nice and ",NA,NA
readable output for this tree.,NA,NA
"Finally, here is an exercise to practice writing operator definitions.",NA,NA
In the practical session of ,NA,NA
Chapter 7,NA,NA
", you were asked to write a DCG generating propositional ",NA,NA
logic formulas. The input you had to use was a bit awkward though. The formula ,NA,NA
 had ,NA,NA
to be represented as ,NA,NA
"[not, '(', p, implies, q, ')']",NA,NA
". Now, that you know about operators, you can do ",NA,NA
something a lot nicer. Write the operator definitions for the operators ,NA,NA
not,NA,NA
", ",NA,NA
and,NA,NA
", ",NA,NA
or,NA,NA
", ",NA,NA
implies,NA,NA
", so ",NA,NA
that Prolog accepts (and correctly brackets) propositional logic formulas. For example: ,NA,NA
?- display(not(p implies q)). ,NA,NA
"not(implies(p,q)). ",NA,NA
Yes ,NA,NA
?- display(not p implies q). ,NA,NA
"implies(not(p),q) ",NA,NA
Yes,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node86.html (4 of 4)11/3/2006 7:35:24 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
10 Cuts and Negation ,NA,NA
This lecture has two main goals: ,NA,NA
1.  To explain how to control Prolog's backtracking behavior with the help of the cut ,NA,NA
predicate.,NA,NA
"2.  To explain how cut can be packaged into more structured forms, notably negation as ",NA,NA
failure.,G,NA
10.1 The cut ,G,NA
10.2 If-then-else ,G,NA
10.3 Negation as failure ,G,NA
10.4 Exercises ,G,NA
10.5 Practical Session 10,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
10.1 The cut,NA,NA
Automatic backtracking is one of the most characteristic features of Prolog. But backtracking can ,NA,NA
lead to inefficiency. Sometimes Prolog can waste time exploring possibilities that lead nowhere. ,NA,NA
"It would be pleasant to have some control over this aspect of its behaviour, but so far we have ",NA,NA
"only seen two (rather crude) ways of doing this: changing the order of rules, and changing the ",NA,NA
order of conjuncts in the body of rules. But there is another way. There is an inbuilt Prolog ,NA,NA
predicate ,NA,NA
!,NA,NA
", called cut, which offers a more direct way of exercising control over the way Prolog ",NA,NA
looks for solutions.,NA,NA
"What exactly is cut, and what does it do? It's simply a special atom that we can use when ",NA,NA
"writing clauses. For example, ",NA,NA
"p(X) :- b(X),c(X),!,d(X),e(X).",NA,NA
"is a perfectly good Prolog rule. As for what cut does, first of all, it is a goal that always ",NA,NA
"succeeds. Second, and more importantly, it has a side effect. Suppose that some goal makes ",NA,NA
use of this clause (we call this goal the parent goal). Then the cut commits Prolog to any ,NA,NA
choices that were made since the parent goal was unified with the left hand side of the rule ,NA,NA
"(including, importantly, the choice of using that particular clause). Let's look at an example to ",NA,NA
see what this means.,NA,NA
Let's first consider the following piece of cut-free code: ,NA,NA
p(X) :- a(X). ,NA,NA
"p(X) :- b(X),c(X),d(X),e(X). ",NA,NA
p(X) :- f(X). ,NA,NA
a(1). ,NA,NA
b(1). ,NA,NA
c(1). ,NA,NA
b(2). ,NA,NA
c(2). ,NA,NA
d(2). ,NA,NA
e(2). ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node88.html (1 of 9)11/3/2006 7:35:37 PM,NA
f(3).,NA,NA
If we pose the query ,NA,NA
p(X),NA,NA
 we will get the following responses: ,NA,NA
X = 1 ; ,NA,NA
X = 2 ; ,NA,NA
X = 3 ; ,NA,NA
no ,NA,NA
"Here is the search tree that explains how Prolog finds these three solutions. Note, that it has to ",NA,NA
"backtrack once, namely when it enteres the second clause for ",NA,NA
p/1,NA,NA
 and decides to match the first ,NA,NA
goal with ,NA,NA
b(1),NA,NA
 instead of ,NA,NA
b(2),NA,NA
.,NA,NA
But now supppose we insert a cut in the second clause: ,NA,NA
"p(X) :- b(X),c(X),!,d(X),e(X).",NA,NA
If we now pose the query ,NA,NA
p(X),NA,NA
 we will get the following responses: ,NA,NA
X ,NA,NA
= 1 ; ,NA,NA
no,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node88.html (2 of 9)11/3/2006 7:35:37 PM,NA
What's going on here? Lets consider.,NA,NA
1.  ,NA,NA
p(X),NA,NA
" is first matched with the first rule, so we get a new goal ",NA,NA
a(X),NA,NA
. By instantiating ,NA,NA
X,NA,NA
 to ,NA,NA
1,NA,NA
", ",NA,NA
Prolog matches ,NA,NA
a(X),NA,NA
 with the fact ,NA,NA
a(1),NA,NA
" and we have found a solution. So far, this is exactly ",NA,NA
what happened in the first version of the program. ,NA,NA
2.  We then go on and look for a second solution. ,NA,NA
p(X),NA,NA
" is matched with the second rule, so we ",NA,NA
get the new goals ,NA,NA
"b(X),c(X),!,d(X),e(X)",NA,NA
. By instantiating ,NA,NA
X,NA,NA
 to ,NA,NA
1,NA,NA
", Prolog matches ",NA,NA
b(X),NA,NA
 with ,NA,NA
the fact ,NA,NA
b(1),NA,NA
", so we now have the goals ",NA,NA
"c(1),!,d(1),e(1)",NA,NA
. But ,NA,NA
c (1),NA,NA
 is in the database so this ,NA,NA
simplifies to ,NA,NA
"!,d(1),e(1)",NA,NA
. ,NA,NA
3.  Now for the big change. The ,NA,NA
!,NA,NA
 goal succeeds (as it always does) and commits us to all the ,NA,NA
"choices we have made so far. In particular, we are committed to having ",NA,NA
X = 1,NA,NA
", and we are ",NA,NA
also committed to using the second rule. ,NA,NA
4.  But ,NA,NA
d(1),NA,NA
 fails. And there's no way we can resatisfy the goal ,NA,NA
p(X),NA,NA
". Sure, if we were ",NA,NA
allowed to try the value ,NA,NA
X=2,NA,NA
 we could use the second rule to generate a solution (that's ,NA,NA
what happened in the original version of the program). But we can't do this: the cut has ,NA,NA
"committed us to the choice X=1. And sure, if we were allowed to try the third rule, we ",NA,NA
could generate the solution ,NA,NA
X=3,NA,NA
. But we can't do this: the cut has committed us to using ,NA,NA
the second rule. ,NA,NA
Looking at the search tree this means that search stops when the goal ,NA,NA
d(1),NA,NA
 cannot be shown as ,NA,NA
going up the tree doesn't lead us to any node where an alternative choice is available. The red ,NA,NA
nodes in the tree are all blocked for backtracking because of the cut.,NA,NA
One point is worth emphasizing: the cut only commits us to choices made since the parent goal ,NA,NA
"was unified with the left hand side of the clause containing the cut. For example, in a rule of the ",NA,NA
form ,NA,NA
"q :- p1,...,pn,!,r1,...,rm",NA,NA
"once we reach the the cut, it commits us to using this particular clause for ",NA,NA
q,NA,NA
 and it commits us ,NA,NA
to the choices made when evalauting ,NA,NA
"p1,...,pn",NA,NA
". However, we are free to backtrack among the ",NA,NA
"r1,...,rm",NA,NA
 and we are also free to backtrack among alternatives for choices that were made ,NA,NA
before reaching the goal ,NA,NA
q,NA,NA
. Concrete examples will make this clear.,NA,NA
First consider the following cut-free program: ,NA,NA
"s(X,Y) :- q(X,Y). ",NA,NA
"s(0,0). ",NA,NA
"q(X,Y) :- i(X),j(Y). ",NA,NA
i(1). ,NA,NA
i(2). ,NA,NA
j(1). ,NA,NA
j(2). ,NA,NA
j(3).,NA,NA
Here's how it behaves: ,NA,NA
"?- s(X,Y). ",NA,NA
X = 1 ,NA,NA
Y = 1 ; ,NA,NA
X = 1 ,NA,NA
Y = 2 ; ,NA,NA
X = 1 ,NA,NA
Y = 3 ; ,NA,NA
X = 2 ,NA,NA
Y = 1 ; ,NA,NA
X = 2 ,NA,NA
Y = 2 ; ,NA,NA
X = 2 ,NA,NA
Y = 3 ; ,NA,NA
X = 0 ,NA,NA
Y = 0; ,NA,NA
no,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node88.html (4 of 9)11/3/2006 7:35:37 PM,NA
Suppose we add a cut to the clause defining ,NA,NA
q/2,NA,NA
: ,NA,NA
"q(X,Y) :- i(X),!,j(Y).",NA,NA
Now the program behaves as follows: ,NA,NA
"?- s(X,Y). ",NA,NA
X = 1 ,NA,NA
Y = 1 ; ,NA,NA
X = 1 ,NA,NA
Y = 2 ; ,NA,NA
X = 1 ,NA,NA
Y = 3 ; ,NA,NA
X = 0 ,NA,NA
Y = 0; ,NA,NA
no,NA,NA
Let's see why.,NA,NA
1.  ,NA,NA
"s(X,Y)",NA,NA
" is first matched with the first rule, which gives us a new goal ",NA,NA
"q(X,Y)",NA,NA
.,NA,NA
2.  ,NA,NA
"q(X,Y)",NA,NA
" is then matched with the third rule, so we get the new goals ",NA,NA
"i(X),!,j(Y)",NA,NA
. By ,NA,NA
instantiating ,NA,NA
X,NA,NA
 to ,NA,NA
1,NA,NA
", Prolog matches ",NA,NA
i(X),NA,NA
 with the fact ,NA,NA
i(1),NA,NA
. This leaves us with the ,NA,NA
goal ,NA,NA
"!,j(Y)",NA,NA
". The cut, of course, succeeds, and commits us to the choices so far made. 3.  But what ",NA,NA
are these choices? These: that ,NA,NA
X = 1,NA,NA
", and that we are using this clause. But ",NA,NA
note: we ,NA,NA
have not yet chosen a value for ,NA,NA
Y,NA,NA
. ,NA,NA
"4.  Prolog then goes on, and by instantiating ",NA,NA
Y,NA,NA
 to ,NA,NA
1,NA,NA
", Prolog matches ",NA,NA
j(Y),NA,NA
 with the fact ,NA,NA
j ,NA,NA
(1),NA,NA
. So we have found a solution.,NA,NA
5.  But we can find more. Prolog is free to try another value for ,NA,NA
Y,NA,NA
. So it backtracks and sets ,NA,NA
Y,NA,NA
 ,NA,NA
to ,NA,NA
2,NA,NA
", thus finding a second solution. And in fact it can find another solution: on ",NA,NA
"backtracking again, it sets ",NA,NA
Y,NA,NA
 to ,NA,NA
3,NA,NA
", thus finding a third solution. ",NA,NA
6.  But those are all alternatives for ,NA,NA
j(X),NA,NA
". Backtracking to the left of the cut is not allowed, so ",NA,NA
it can't reset ,NA,NA
X,NA,NA
 to ,NA,NA
2,NA,NA
", so it won't find the next three solutions that the cut-free program ",NA,NA
found. Backtracking over goals that were reached before ,NA,NA
"q(X,Y)",NA,NA
" is allowed however, so ",NA,NA
that Prolog will find the second clause for ,NA,NA
s/2,NA,NA
.,NA,NA
"Looking at it in terms of the search tree, this means that all nodes above the cut up to the one ",NA,NA
containing the goal that led to the selection of the clause containing the cut are blocked.,NA,NA
"Well, we now know what cut is. But how do we use it in practice, and why is it so useful? As a ",NA,NA
"first example, let's define a (cut-free) predicate ",NA,NA
max/3,NA,NA
 which takes integers as arguments and ,NA,NA
"succeeds if the third argument is the maximum of the first two. For example, the queries ",NA,NA
"max(2,3,3)",NA,NA
and ,NA,NA
"max(3,2,3)",NA,NA
and ,NA,NA
"max(3,3,3)",NA,NA
"should succeed, and the queries ",NA,NA
"max(2,3,2)",NA,NA
and ,NA,NA
"max(2,3,5)",NA,NA
"should fail. And of course, we also want the program to work when the third argument is a ",NA,NA
"variable. That is, we want the program to be able to find the maximum of the first two ",NA,NA
arguments for us: ,NA,NA
"?- max(2,3,Max). ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node88.html (6 of 9)11/3/2006 7:35:37 PM,NA
Max = 3 ,NA,NA
Yes ,NA,NA
"?- max(2,1,Max). ",NA,NA
Max = 2 ,NA,NA
Yes ,NA,NA
"Now, it is easy to write a program that does this. Here's a first attempt: ",NA,NA
"max(X,Y,Y) :- X =< Y. ",NA,NA
"max(X,Y,X) :- X>Y.",NA,NA
"This is a perfectly correct program, and we might be tempted simply to stop here. But we ",NA,NA
shouldn't: it's not good enough. What's the problem? There is a potential inefficiency. Suppose ,NA,NA
"this definition is used as part of a larger program, and somewhere along the way ",NA,NA
"max(3,4,Y) ",NA,NA
is ,NA,NA
called. The program will correctly set ,NA,NA
Y=4,NA,NA
. But now consider what happens if at some stage ,NA,NA
backtracking is forced. The program will try to resatisfy ,NA,NA
"max(3,4,Y)",NA,NA
 using the second clause. And ,NA,NA
"of course, this is completely pointless: the maximum of ",NA,NA
3,NA,NA
 and ,NA,NA
4,NA,NA
 is ,NA,NA
4,NA,NA
 and that's that. There is no ,NA,NA
second solution to find. To put it another way: the two clauses in the above program are ,NA,NA
"mutually exclusive: if the first succeeds, the second must fail and vice versa. So attempting to ",NA,NA
resatisfy this clause is a complete waste of time.,NA,NA
"With the help of cut, this is easy to fix. We need to insist that Prolog should never try both ",NA,NA
"clauses, and the following code does this: ",NA,NA
"max(X,Y,Y) :- X =< Y,!. ",NA,NA
"max(X,Y,X) :- X>Y. ",NA,NA
Note how this works. Prolog will reach the cut if ,NA,NA
"max(X,Y,Y)",NA,NA
 is called and ,NA,NA
X =< Y,NA,NA
 succeeds. In ,NA,NA
"this case, the second argument is the maximum, and that's that, and the cut commits us to this ",NA,NA
"choice. On the other hand, if ",NA,NA
X =< Y,NA,NA
" fails, then Prolog goes onto the second clause instead. ",NA,NA
Note that this cut does not change the meaning of the program. Our new code gives exactly the ,NA,NA
"same answers as the old one, it's just a bit more efficient. In fact, the program is exactly the ",NA,NA
"same as the previous version, except for the cut, and this is a pretty good sign that the cut is a ",NA,NA
"sensible one. Cuts like this, which don't change the meaning of a program, have a special name: ",NA,NA
they're called green cuts.,NA,NA
But there is another kind of cut: cuts which do change the meaning of a program. These are ,NA,NA
"called red cuts, and are usually best avoided. Here's an example of a red cut. Yet another way ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node88.html (7 of 9)11/3/2006 7:35:37 PM,NA
to write the ,NA,NA
max,NA,NA
 predicate is as follows: ,NA,NA
"max(X,Y,Y) :- X =< Y,!. ",NA,NA
"max(X,Y,X).",NA,NA
This is the same as our earlier green cut ,NA,NA
max,NA,NA
", except that we have got rid of the ",NA,NA
>,NA,NA
 test in the ,NA,NA
second clause. This is bad sign: it suggests that we're changing the underyling logic of the ,NA,NA
program. And indeed we are: this program `works' by relying on cut. How good is it?,NA,NA
"Well, for some kinds of query it's fine. In particular, it answers correctly when we pose queries ",NA,NA
in which the third argument is a variable. For example: ,NA,NA
"?- max(100,101,X). ",NA,NA
X = 101 ,NA,NA
Yes ,NA,NA
and ,NA,NA
"?- max(3,2,X). ",NA,NA
X = 3 ,NA,NA
Yes ,NA,NA
"Nonetheless, it's not the same as the green cut program: the meaning of ",NA,NA
max,NA,NA
 has changed. ,NA,NA
"Consider what happens when all three arguments are instantiated. For example, consider the ",NA,NA
query ,NA,NA
"max(2,3,2).",NA,NA
"Obviously this query should fail. But in the red cut version, it will succeed! Why? Well, this query ",NA,NA
"simply won't match the head of the first clause, so Prolog goes straight to the second clause. ",NA,NA
"And the query will match with the second clause, and (trivially) the query succeeds! Oops! ",NA,NA
Getting rid of that ,NA,NA
>,NA,NA
 test wasn't quite so smart after all...,NA,NA
This program is a classic red cut. It does not truly define the ,NA,NA
max,NA,NA
" predicate, rather it changes ",NA,NA
it's meaning and only gets things right for certain types of queries.,NA,NA
"A sensible way of using cut is to try and get a good, clear, cut free program working, and only ",NA,NA
"then try to improve its efficiency using cuts. It's not always possible to work this way, but it's a ",NA,NA
good ideal to aim for. ,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
10.2 If-then-else,NA,NA
Although our second try in using a cut in the ,NA,NA
max,NA,NA
 predicate to make it more efficient went ,NA,NA
"wrong, the argument that we used when placing the cut in the first clause and then deleting ",NA,NA
the test ,NA,NA
X>Y,NA,NA
 from the second clause seems sensible: if we have already tested whether ,NA,NA
X,NA,NA
 is ,NA,NA
smaller or equal to ,NA,NA
Y,NA,NA
" and we have found out that it is not, we don't have to test whether ",NA,NA
X,NA,NA
 is ,NA,NA
greater than ,NA,NA
Y,NA,NA
 as well (we already know this).,NA,NA
There is a built-in predicate construction in Prolog which allows you to express exactly such ,NA,NA
"conditions: the if-then-else construct. In Prolog, if A then B else C is written as ",NA,NA
( A -> B ; C),NA,NA
. To ,NA,NA
Prolog this means: try ,NA,NA
A,NA,NA
". If you can prove it, go on to prove ",NA,NA
B,NA,NA
 and ignore ,NA,NA
C,NA,NA
. If ,NA,NA
A,NA,NA
" fails, however, ",NA,NA
go on to prove ,NA,NA
C,NA,NA
 ignoring ,NA,NA
B,NA,NA
. The ,NA,NA
max,NA,NA
 predicate using the if-then-else construct looks as ,NA,NA
follows: ,NA,NA
"max(X,Y,Z) :- ",NA,NA
 (  X =< Y ,NA,NA
 -> Z = Y ,NA,NA
 ;  Z = X   ,NA,NA
 ).,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
10.3 Negation as failure,NA,NA
One of Prolog's most useful features is the simple way it lets us state generalizations. To say ,NA,NA
that Vincent enjoys burgers we just write: ,NA,NA
"enjoys(vincent,X) :- burger(X).",NA,NA
"But in real life rules have exceptions. Perhaps Vincent doesn't like Big Kahuna burgers. That is, ",NA,NA
"perhaps the correct rule is really: Vincent enjoys burgers, except Big Kahuna burgers. Fine. But ",NA,NA
how do we state this in Prolog?,NA,NA
"As a first step, let's introduce another built in predicate ",NA,NA
fail/0,NA,NA
". As its name suggests, ",NA,NA
fail ,NA,NA
is a ,NA,NA
special symbol that will immediately fail when Prolog encounters it as a goal. That may not ,NA,NA
"sound too useful, but remember: when Prolog fails, it tries to backtrack. Thus ",NA,NA
fail,NA,NA
 can be ,NA,NA
"viewed as an instruction to force backtracking. And when used in combination with cut, which ",NA,NA
"blocks backtracking, ",NA,NA
fail,NA,NA
" enables us to write some interesting programs, and in particular, it lets ",NA,NA
us define exceptions to general rules.,NA,NA
Consider the following code: ,NA,NA
"enjoys(vincent,X) :- big_kahuna_burger(X),!,fail. enjoys(vincent,X) :- ",NA,NA
burger(X). ,NA,NA
burger(X) :- big_mac(X). ,NA,NA
burger(X) :- big_kahuna_burger(X). ,NA,NA
burger(X) :- whopper(X). ,NA,NA
big_mac(a). ,NA,NA
big_kahuna_burger(b). ,NA,NA
big_mac(c). ,NA,NA
whopper(d).,NA,NA
The first two lines describe Vincent's preferences. The last six lines describe a world containing ,NA,NA
"four burgers, ",NA,NA
a,NA,NA
", ",NA,NA
b,NA,NA
", ",NA,NA
c,NA,NA
", and ",NA,NA
d,NA,NA
. We're also given information about what kinds of burgers they are. ,NA,NA
"Given that the first two lines really do describe Vincent's preferences (that is, that he likes all ",NA,NA
burgers except Big Kahuna burgers) then he should enjoy burgers ,NA,NA
a,NA,NA
", ",NA,NA
c,NA,NA
 and ,NA,NA
d,NA,NA
", but not ",NA,NA
b,NA,NA
. ,NA,NA
"And indeed, this is what happens: ",NA,NA
"?- enjoys(vincent,a). ",NA,NA
yes ,NA,NA
"?- enjoys(vincent,b). ",NA,NA
no ,NA,NA
"?- enjoys(vincent,c). ",NA,NA
yes ,NA,NA
"?- enjoys(vincent,d). ",NA,NA
yes,NA,NA
How does this work? The key is the combination of ,NA,NA
!,NA,NA
 and ,NA,NA
fail,NA,NA
 in the first line (this even has a ,NA,NA
name: its called the cut-fail combination). When we pose the query ,NA,NA
"enjoys(vincent,b)",NA,NA
", the first ",NA,NA
"rule applies, and we reach the cut. This commits us to the choices we have made, and in ",NA,NA
"particular, blocks access to the second rule. But then we hit ",NA,NA
fail,NA,NA
. This tries to force ,NA,NA
"backtracking, but the cut blocks it, and so our query fails.",NA,NA
"This is interesting, but it's not ideal. For a start, note that the ordering of the rules is crucial: if ",NA,NA
"we reverse the first two lines, we don't get the behavior we want. Similarly, the cut is crucial: if ",NA,NA
"we remove it, the program doesn't behave in the same way (so this is a red cut). In short, ",NA,NA
we've got two mutually dependent clauses that make intrinsic use of the procedural aspects of ,NA,NA
"Prolog. Something useful is clearly going on here, but it would be better if we could extract the ",NA,NA
useful part and package it in a more robust way.,NA,NA
And we can. The crucial observation is that the first clause is essentially a way of saying that ,NA,NA
"Vincent does not enjoy X if X is a Big Kahuna burger. That is, the cut-fail combination seems to ",NA,NA
"be offering us some form of negation. And indeed, this is the crucial generalization: the cut-fail ",NA,NA
combination lets us define a form of negation called negation as failure. Here's how: ,NA,NA
"neg(Goal) :- Goal,!,fail. ",NA,NA
neg(Goal).,NA,NA
"For any Prolog goal, ",NA,NA
neg(Goal),NA,NA
 will succeed precisely if ,NA,NA
Goal,NA,NA
 does not succeed.,NA,NA
Using our new ,NA,NA
neg,NA,NA
" predicate, we can describe Vincent's preferences in a much clearer way: ",NA,NA
"enjoys(vincent,X) :- burger(X), neg(big_kahuna_burger(X)).",NA,NA
"That is, Vincent enjoys X if X is a burger and X is not a Big Kahuna burger. This is quite close ",NA,NA
"to our original statement: Vincent enjoys burgers, except Big Kahuna burgers.",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node90.html (2 of 5)11/3/2006 7:35:48 PM,NA
"Negation as failure is an important tool. Not only does it offer useful expressivity (notably, the ",NA,NA
ability to describe exceptions) it also offers it in a relatively safe form. By working with ,NA,NA
negation as failure (instead of with the lower level cut-fail combination) we have a better ,NA,NA
"chance of avoiding the programming errors that often accompany the use of red cuts. In fact, ",NA,NA
"negation as failure is so useful, that it comes built in Standard Prolog, we don't have to define ",NA,NA
it at all. In Standard Prolog the operator ,NA,NA
\+,NA,NA
" means negation as failure, so we could define ",NA,NA
Vincent's preferences as follows: ,NA,NA
"enjoys(vincent,X) :- burger(X), \+ big_kahuna_burger(X).",NA,NA
"Nonetheless, a couple of words of warning are in order: don't make the mistake of thinking ",NA,NA
that negation as failure works just like logical negation. It doesn't. Consider again our burger ,NA,NA
world:,NA,NA
burger(X) :- big_mac(X). ,NA,NA
burger(X) :- big_kahuna_burger(X). burger(X) :- ,NA,NA
whopper(X). ,NA,NA
big_mac(c). ,NA,NA
big_kahuna_burger(b). ,NA,NA
big_mac(c). ,NA,NA
whopper(d).,NA,NA
If we pose the query ,NA,NA
"enjoys(vincent,X)",NA,NA
 we get the correct sequence of responses: ,NA,NA
X = a ; ,NA,NA
X = c ; ,NA,NA
X = d ; ,NA,NA
no,NA,NA
But now suppose we rewrite the first line as follows: ,NA,NA
"enjoys(vincent,X) :- \+ big_kahuna_burger(X), burger(X).",NA,NA
"Note that from a declarative point of view, this should make no difference: after all, burger(x) ",NA,NA
and not big kahuna burger(x) is logically equivalent to not big kahuna burger(x) and burger ,NA,NA
"(x). That is, no matter what the variable x denotes, it impossible for one of these expressions ",NA,NA
"to be true, and the other expression to be false. Nonetheless, here's what happens when we ",NA,NA
pose the same query: ,NA,NA
"enjoys(vincent,X) ",NA,NA
no,NA,NA
"What's going on? Well, in the modified database, the first thing that Prolog has to check is ",NA,NA
whether ,NA,NA
\+ big_kahuna_burger(X),NA,NA
" holds, which means that it must check whether ",NA,NA
big_kahuna_burger(X),NA,NA
" fails. But this succeeds. After all, the database contains the information ",NA,NA
big_kahuna_burger(b),NA,NA
. So the query ,NA,NA
\+ big_kahuna_burger(X),NA,NA
" fails, and hence the original query ",NA,NA
"does too. In a nutshell, the crucial difference between the two programs is that in the original ",NA,NA
version (the one that works right) we use ,NA,NA
\+,NA,NA
 only after we have instantiated the variable ,NA,NA
X,NA,NA
. In ,NA,NA
the new version (which goes wrong) we use ,NA,NA
\+,NA,NA
 before we have done this. The difference is ,NA,NA
crucial.,NA,NA
"Summing up, we have seen that negation as failure is not logical negation, and that it has a ",NA,NA
"procedural dimension that must be mastered. Nonetheless, it is an important programming ",NA,NA
construct: it is generally a better idea to try use negation as failure than to write code ,NA,NA
"containing heavy use of red cuts. Nonetheless, ``generally'' does not mean ``always''. There ",NA,NA
are times when it is better to use red cuts.,NA,NA
"For example, suppose that we need to write code to capture the following condition: p holds if ",NA,NA
"a and b hold, or if a does not hold and c holds too. This can be captured with the help of ",NA,NA
negation as failure very directly: ,NA,NA
"p :- a,b. ",NA,NA
"p :- \+ a, c.",NA,NA
But suppose that ,NA,NA
a,NA,NA
" is a very complicated goal, a goal that takes a lot of time to compute. ",NA,NA
Programming it this way means we may have to compute ,NA,NA
a,NA,NA
" twice, and this may mean that we ",NA,NA
"have unacceptably slow performance. If so, it would be better to use the following program: ",NA,NA
"p :- a,!,b. ",NA,NA
p :- c.,NA,NA
Note that this is a red cut: removing it changes the meaning of the program. Do you see why?,NA,NA
"When all's said and done, there are no universal guidelines that will cover all the situations you ",NA,NA
are likely to run across. Programming is as much an art as a science: that's what makes it so ,NA,NA
interesting. You need to know as much as possible about the language you are working with ,NA,NA
"(whether it's Prolog, Java, Perl, or whatever) understand the problem you are trying to ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node90.html (4 of 5)11/3/2006 7:35:48 PM,NA
"solve, and know what counts as an acceptable solution. And then: go ahead and try your best!",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
10.4 Exercises ,NA,NA
Exercise 10.1 ,NA,NA
Suppose we have the following database: ,NA,NA
p(1). ,NA,NA
p(2) :- !. ,NA,NA
p(3).,NA,NA
Write all of Prolog's answers to the following queries: ,NA,NA
?- p(X). ,NA,NA
"?- p(X),p(Y). ",NA,NA
"?- p(X),!,p(Y).",NA,NA
Exercise 10.2 ,NA,NA
"First, explain what the following program does: ",NA,NA
"class(Number,positive) :- Number > 0. ",NA,NA
"class(0,zero). ",NA,NA
"class(Number, negative) :- Number < 0.",NA,NA
"Second, improve it by adding green cuts.",NA,NA
Exercise 10.3 ,NA,NA
"Without using cut, write a predicate ",NA,NA
split/3,NA,NA
 that splits a list of integers into ,NA,NA
"two lists: one containing the positive ones (and zero), the other containing the ",NA,NA
negative ones. For example: ,NA,NA
" split([3,4,-5,-1,0,4,-9],P,N)",NA,NA
should return: ,NA,NA
" P = [3,4,0,4] ",NA,NA
" N = [-5,-1,-9].",NA,NA
"Then improve this program, without changing its meaning, with the help of cut.",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
10.5 Practical Session 10,NA,NA
The purpose of Practical Session 10 is to help you get familiar with cuts and negation as ,NA,NA
failure.,NA,NA
First some keyboard exercises: ,NA,NA
"1.  First of all, try out all three versions of the ",NA,NA
max/3,NA,NA
 predicate defined in the text: the cut-,NA,NA
"free version, the green cut version, and the red cut version. As usual, ``try out'' means ",NA,NA
"``run traces on'', and you should make sure that you trace queries in which all three ",NA,NA
"arguments are instantiated to integers, and queries where the third argument is given as ",NA,NA
a variable.,NA,NA
"2.  OK, time for a burger. Try out all the methods discussed in the text for coping with ",NA,NA
"Vincent's preferences. That is, try out the program that uses a cut-fail combination, the ",NA,NA
"program that uses negation as failure correctly, and also the program that gets it wrong ",NA,NA
by using negation in the wrong place.,NA,NA
Now for some programming: ,NA,NA
1.  Define a predicate ,NA,NA
nu/2,NA,NA
" (""not unifiable"") which takes two terms as arguments and ",NA,NA
succeeds if the two terms do not unify. For example: ,NA,NA
" nu(foo,foo). ",NA,NA
 no ,NA,NA
" nu (foo,blob). ",NA,NA
 yes ,NA,NA
" nu(foo,X). ",NA,NA
 no,NA,NA
You should define this predicate in three different ways: ,NA,NA
a.  First (and easiest) write it with the help of ,NA,NA
=,NA,NA
 and ,NA,NA
\+,NA,NA
.,NA,NA
b.  Second write it with the help of ,NA,NA
=,NA,NA
", but don't use ",NA,NA
\+,NA,NA
.,NA,NA
"c.  Third, write it using a cut-fail combination. Don't use = and don't use \+.",NA,NA
2.  Define a predicate ,NA,NA
"unifiable(List1,Term,List2)",NA,NA
 where ,NA,NA
List2,NA,NA
 is the list of all ,NA,NA
members of ,NA,NA
List1,NA,NA
 that match ,NA,NA
Term ,NA,NA
", but are not instantiated by the matching. For ",NA,NA
"example, ",NA,NA
" unifiable([X,b,t(Y)],t(a),List]",NA,NA
should yield ,NA,NA
" List = [X,t(Y)].",NA,NA
Note that ,NA,NA
X,NA,NA
 and ,NA,NA
Y,NA,NA
 are still not instantiated. So the tricky part is: how do we check that ,NA,NA
they match with ,NA,NA
t(a),NA,NA
 without instantiating them? (Hint: consider using the test ,NA,NA
\ + (term1 ,NA,NA
= term2),NA,NA
. Why? Think about it. You might also like to think about the test ,NA,NA
\+(\+ (term1 = ,NA,NA
term2)),NA,NA
.),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
11 Database Manipulation and Collecting ,NA,NA
Solutions,NA,NA
This lecture has two main goals: ,NA,NA
1.  To discuss database manipulation in Prolog.,NA,NA
2.  To discuss inbuilt predicates that let us collect all solutions to a problem into a single list.,G,NA
11.1 Database manipulation,G,NA
11.2 Collecting solutions ,H,NA
11.2.1 ,NA,NA
findall/3 ,H,NA
11.2.2 ,NA,NA
bagof/3 ,H,NA
11.2.3 ,NA,NA
setof/3,G,NA
11.3 Exercises,G,NA
11.4 Practical Session 11,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
11.1 Database manipulation ,NA,NA
"Prolog has four database manipulation commands: assert, retract, asserta, and assertz. Let's ",NA,NA
see how these are used. Suppose we start with an empty database. So if we give the ,NA,NA
command: ,NA,NA
listing.,NA,NA
we simply get a yes; the listing (of course) is empty. ,NA,NA
Suppose we now give this command: ,NA,NA
assert(happy(mia)).,NA,NA
It succeeds (,NA,NA
assert,NA,NA
 commands always succeed). But what is important is not that it ,NA,NA
"succeeds, but the side-effect it has on the database. If we now give the command: ",NA,NA
listing.,NA,NA
we get the listing: ,NA,NA
happy(mia).,NA,NA
"That is, the database is no longer empty: it now contains the fact we asserted. ",NA,NA
Suppose we then made four more assert commands: ,NA,NA
assert(happy(vincent)). ,NA,NA
yes ,NA,NA
assert(happy(marcellus)). ,NA,NA
yes ,NA,NA
assert(happy(butch)). ,NA,NA
yes ,NA,NA
assert(happy(vincent)). ,NA,NA
yes,NA,NA
Suppose we then ask for a listing: ,NA,NA
listing. ,NA,NA
happy(mia). ,NA,NA
happy(vincent). ,NA,NA
happy(marcellus). ,NA,NA
happy(butch). ,NA,NA
happy(vincent). ,NA,NA
yes,NA,NA
All the facts we asserted are now in the knowledge base. Note that ,NA,NA
happy(vincent),NA,NA
 is in the ,NA,NA
"knowledge base twice. As we asserted it twice, this seems sensible.",NA,NA
"So far, we have only asserted facts into the database, but we can assert new rules as well. ",NA,NA
"Suppose we want to assert the rule that everyone who is happy is naive. That is, suppose we ",NA,NA
want to assert that: ,NA,NA
naive(X) :- happy(X).,NA,NA
We can do this as follows: ,NA,NA
assert( (naive(X) :- happy(X)) ). ,NA,NA
Note the syntax of this command: the rule we are asserting is enclosed in a pair of brackets. If ,NA,NA
we now ask for a listing we get: ,NA,NA
happy(mia). ,NA,NA
happy(vincent). ,NA,NA
happy(marcellus). ,NA,NA
happy(butch). ,NA,NA
happy(vincent). ,NA,NA
naive(A) :- ,NA,NA
 happy(A).,NA,NA
"Now that we know how to assert new information into the database, we need to know how to ",NA,NA
remove things form the database when we no longer need them. There is an inverse predicate ,NA,NA
to ,NA,NA
assert,NA,NA
", namely ",NA,NA
retract,NA,NA
". For example, if we go straight on and give the command: ",NA,NA
retract(happy(marcellus)).,NA,NA
and then list the database we get: ,NA,NA
happy(mia). ,NA,NA
happy(vincent). ,NA,NA
happy(butch). ,NA,NA
happy(vincent). ,NA,NA
naive(A) :- ,NA,NA
 happy(A).,NA,NA
"That is, the fact ",NA,NA
happy(marcellus),NA,NA
" has been removed. Suppose we go on further, and say ",NA,NA
retract(happy(vincent)).,NA,NA
and then ask for a listing. We get: ,NA,NA
happy(mia). ,NA,NA
happy(butch). ,NA,NA
happy(vincent). ,NA,NA
naive(A) :- ,NA,NA
 happy(A).,NA,NA
Note that the first occurrence of ,NA,NA
happy(vincent),NA,NA
 (and only the first occurrence) was ,NA,NA
removed.,NA,NA
To remove all of our assertions we can use a variable: ,NA,NA
retract(happy(X)). ,NA,NA
X = mia ; ,NA,NA
X = butch ; ,NA,NA
X = vincent ; ,NA,NA
no,NA,NA
A listing reveals that the database is now empty: ,NA,NA
listing. ,NA,NA
yes,NA,NA
"If we want more control over where the asserted material is placed, there are two variants of ",NA,NA
"assert, namely: ",NA,NA
1.  assertz. Places asserted material at the end of the database. 2.  ,NA,NA
asserta. Places asserted material at the beginning of the database.,NA,NA
"For example, suppose we start with an empty database, and then we give the following ",NA,NA
command: ,NA,NA
"assert( p(b) ), assertz( p(c) ), asserta( p (a) ). ",NA,NA
Then a listing reveals that we now have the following database: ,NA,NA
p(a). ,NA,NA
p(b). ,NA,NA
p(c). ,NA,NA
yes,NA,NA
Database manipulation is a useful technique. It is especially useful for storing the results to ,NA,NA
"computations, so that if we need to ask the same question in future, we don't need to redo ",NA,NA
"the work: we just look up the asserted fact. This technique is called `memoization', or ",NA,NA
`caching'.,NA,NA
Here's a simple example. We create an addition table for adding digits by using database ,NA,NA
manipulation. ,NA,NA
additiontable(A) :- ,NA,NA
" member(B,A), ",NA,NA
" member(C,A), ",NA,NA
" D is B+C, ",NA,NA
" assert(sum(B,C,D)), ",NA,NA
 fail.,NA,NA
(Here ,NA,NA
member/2,NA,NA
 is the standard membership predicate which tests for membership in a list.),NA,NA
"What does this program do? It takes a list of numbers A, uses ",NA,NA
member,NA,NA
 to select two numbers ,NA,NA
"B and C of this list, and then adds B and C together calling the result D. Now for the important ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node94.html (4 of 6)11/3/2006 7:36:18 PM,NA
"bit. It then asserts the fact that it has discovered (namely that D is the sum of A and B), and ",NA,NA
then fails. Why do we want it to fail? Because we want to force backtracking! Because it has ,NA,NA
"failed, Prolog will backtrack to ",NA,NA
"member(C,A)",NA,NA
" and choose a new value for C, add this new C to B ",NA,NA
"two create a new D, and then assert this new fact. it will then fail again. This repeated failure ",NA,NA
will force Prolog to find all values for ,NA,NA
"member(B,A)",NA,NA
 and ,NA,NA
"member(C,A)",NA,NA
", and add together and ",NA,NA
assert all possible combinations.,NA,NA
"For example, when we give Prolog the command ",NA,NA
"additiontable([0,1,2,3,4,5,6,7,8,9])",NA,NA
"It will come back and say No. But it's not this response that interests us, its the side-effect on ",NA,NA
the database that's important. If we now ask for a listing we see that the database now ,NA,NA
contains ,NA,NA
"sum(0,0,0). ",NA,NA
"sum(0,1,1). ",NA,NA
"sum(0,2,2). ",NA,NA
"sum(0,3,3). ",NA,NA
"sum(0,4,4). ",NA,NA
"sum(0,5,5). ",NA,NA
"sum(0,6,6). ",NA,NA
"sum(0,7,7). ",NA,NA
"sum(0,8,8). ",NA,NA
"sum(0,9,9). ",NA,NA
"sum(1,0,1). ",NA,NA
"sum(1,1,2). ",NA,NA
"sum(1,2,3). ",NA,NA
"sum(1,3,4). ",NA,NA
"sum(1,4,5). ",NA,NA
"sum(1,5,6). ",NA,NA
"sum(1,6,7). ",NA,NA
"sum(1,7,8). ",NA,NA
"sum(1,8,9). ",NA,NA
"sum(1,9,10). ",NA,NA
 . ,NA,NA
 . ,NA,NA
 . ,NA,NA
 . ,NA,NA
 .,NA,NA
"Question: how do we remove all these new facts when we no longer want them? After all, if ",NA,NA
we simply give the command ,NA,NA
"retract(sum(X,Y,Z)).",NA,NA
Prolog is going to go through all 100 facts and ask us whether we want to remove them! But ,NA,NA
there's a much simpler way. Use the command ,NA,NA
"retract(sum(_,_,_)),fail.",NA,NA
"Again, the purpose of the ",NA,NA
fail,NA,NA
 is to force backtracking. Prolog removes the first fact about ,NA,NA
sum,NA,NA
 ,NA,NA
"in the database, and then fails. So it backtracks and removes the next fact about sum. So it ",NA,NA
"backtracks again, removes the third, and so on. Eventually (after it has removed all 100 items) ",NA,NA
"it will fail completely, and say No. But we're not interested in what Prolog says, we're interested ",NA,NA
in what it does. All we care about is that the database now contains no facts about ,NA,NA
sum,NA,NA
.,NA,NA
"To conclude our discussion of database manipulation, a word of warning. Although it can be a ",NA,NA
"useful technique, database manipulation can lead to dirty, hard to understand, code. If you use ",NA,NA
"it heavily in a program with lots of backtracking, understanding what is going on can be a ",NA,NA
"nightmare. It is a non-declarative, non logical, feature of Prolog that should be used cautiously.",NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node94.html (6 of 6)11/3/2006 7:36:18 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
11.2 Collecting solutions,NA,NA
"There may be many solutions to a query. For example, suppose we are working with the ",NA,NA
database ,NA,NA
"child(martha,charlotte). ",NA,NA
"child(charlotte,caroline). ",NA,NA
"child(caroline,laura). ",NA,NA
"child(laura,rose). ",NA,NA
"descend(X,Y) :- child(X,Y). ",NA,NA
"descend(X,Y) :- child(X,Z), ",NA,NA
" descend(Z,Y).",NA,NA
Then if we pose the query ,NA,NA
"descend(martha,X).",NA,NA
there are four solutions (namely ,NA,NA
X=charlotte,NA,NA
", ",NA,NA
X=caroline,NA,NA
", ",NA,NA
X=laura,NA,NA
", and ",NA,NA
X=rose,NA,NA
).,NA,NA
However Prolog generates these solutions one by one. Sometimes we would like to have all ,NA,NA
"the solutions to a query, and we would like them handed to us in a neat, usable, form. Prolog ",NA,NA
"has three built-in predicates that do this: findall, bagof, and setof. Basically these predicates ",NA,NA
"collect all the solutions to a query and put them in a list, but there are important differences ",NA,NA
"between them, as we shall see.",G,NA
11.2.1 ,NA,NA
findall/3,G,NA
11.2.2 ,NA,NA
bagof/3,G,NA
11.2.3 ,NA,NA
setof/3,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
11.2.1 ,NA,NA
findall/3,NA,NA
The query ,NA,NA
"findall(Object,Goal,List).",NA,NA
produces a list ,NA,NA
List,NA,NA
 of all the objects ,NA,NA
Object,NA,NA
 that satisfy the goal ,NA,NA
Goal,NA,NA
. Often ,NA,NA
Object,NA,NA
 is simply ,NA,NA
"a variable, in which case the query can be read as: Give me a list containing all the ",NA,NA
instantiations of ,NA,NA
Object,NA,NA
 which satisfy ,NA,NA
Goal,NA,NA
. ,NA,NA
"Here's an example. Suppose we're working with the above database (that is, with the ",NA,NA
information about ,NA,NA
child,NA,NA
 and the definition of ,NA,NA
descend,NA,NA
). Then if we pose the query ,NA,NA
"findall(X,descend(martha,X),Z).",NA,NA
we are asking for a list ,NA,NA
Z,NA,NA
 containing all the values of ,NA,NA
X,NA,NA
 that satisfy ,NA,NA
"descend(martha,X)",NA,NA
. ,NA,NA
Prolog will respond ,NA,NA
X = _7489 ,NA,NA
"Z = [charlotte,caroline,laura,rose] ",NA,NA
But ,NA,NA
Object,NA,NA
" doesn't have to be a variable, it may just contain a variable that is in ",NA,NA
Goal,NA,NA
. For ,NA,NA
"example, we might decide that we want to build a new predicate ",NA,NA
fromMartha/1,NA,NA
 that is true ,NA,NA
only of descendants of Martha. We could do this with the query: ,NA,NA
"findall(fromMartha(X),descend(martha,X),Z).",NA,NA
"That is, we are asking for a list ",NA,NA
Z,NA,NA
 containing all the values of ,NA,NA
fromMartha(X),NA,NA
 that satisfy the ,NA,NA
goal ,NA,NA
"descend(martha,X)",NA,NA
. Prolog will respond ,NA,NA
X = _7616 ,NA,NA
"Z = [fromMartha(charlotte),fromMartha(caroline), ",NA,NA
 ,NA,NA
"fromMartha(laura),fromMartha(rose)] ",NA,NA
"Now, what happens, if we ask the following query? ",NA,NA
"findall(X,descend(mary,X),Z).",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node96.html (1 of 2)11/3/2006 7:36:28 PM,NA
There are no solutions for the goal ,NA,NA
"descend(mary,X)",NA,NA
 in the knowledge base. So ,NA,NA
findall ,NA,NA
returns ,NA,NA
an empty list.,NA,NA
Note that the first two arguments of ,NA,NA
findall,NA,NA
 typically have (at least) one variable in common. ,NA,NA
When using ,NA,NA
findall,NA,NA
", we normally want to know what solutions Prolog finds for certain variables ",NA,NA
"in the goal, and we tell Prolog which variables in Goal we are interested in by building them ",NA,NA
into the first argument of ,NA,NA
findall,NA,NA
.,NA,NA
"You might encounter situations, however, where ",NA,NA
findall,NA,NA
 does useful work although the first two ,NA,NA
"arguments don't share any variables. For example, if you are not interested in who exactly is a ",NA,NA
"descendant of Martha, but only in how many descendants Martha has, you can use the follwing ",NA,NA
query to find out: ,NA,NA
"?- findall(Y,descend(martha,X),Z), length(Z,N).",NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
11.2.2 ,NA,NA
bagof/3,NA,NA
The ,NA,NA
findall/3,NA,NA
" predicate is useful, but in certain respects it is rather crude. For example, ",NA,NA
suppose we pose the query ,NA,NA
"findall(Child,descend(Mother,Child),List).",NA,NA
We get the response ,NA,NA
Child = _6947 ,NA,NA
Mother = _6951 ,NA,NA
"List = [charlotte,caroline,laura,rose,caroline,laura,rose, laura,rose,rose] ",NA,NA
"Now, this is correct, but sometimes it would be useful if we had a separate list for each of the ",NA,NA
different instantiations of ,NA,NA
Mother,NA,NA
.,NA,NA
This is what ,NA,NA
bagof,NA,NA
 lets us do. If we pose the query ,NA,NA
"bagof(Child,descend(Mother,Child),List).",NA,NA
we get the response ,NA,NA
Child = _7736 ,NA,NA
Mother = caroline ,NA,NA
"List = [laura,rose] ; ",NA,NA
Child = _7736 ,NA,NA
Mother = charlotte ,NA,NA
"List = [caroline,laura,rose] ; ",NA,NA
Child = _7736 ,NA,NA
Mother = laura ,NA,NA
List = [rose] ; ,NA,NA
Child = _7736 ,NA,NA
Mother = martha ,NA,NA
"List = [charlotte,caroline,laura,rose] ; ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node97.html (1 of 3)11/3/2006 7:36:37 PM,NA
no,NA,NA
"That is, ",NA,NA
bagof,NA,NA
 is more finegrained than ,NA,NA
findall,NA,NA
", it gives us the opportunity to extract the ",NA,NA
"information we want in a more structured way. Moreover, ",NA,NA
bagof,NA,NA
 can also do the same job as ,NA,NA
findall,NA,NA
", with the help of a special piece of syntax. If we pose the query ",NA,NA
"bagof(Child,Mother ^ descend(Mother,Child),List).",NA,NA
This says: give me a list of all the values of ,NA,NA
Child,NA,NA
 such that ,NA,NA
"descend(Mother,Child)",NA,NA
", and put ",NA,NA
"the result in a list, but don't worry about generating a separate list for each value of ",NA,NA
Mother,NA,NA
. ,NA,NA
So posing this query yields: ,NA,NA
Child = _7870 ,NA,NA
Mother = _7874 ,NA,NA
"List = [charlotte,caroline,laura,rose,caroline,laura,rose, laura,rose,rose]",NA,NA
Note that this is exactly the response that ,NA,NA
findall,NA,NA
" would have given us. Still, if this is the ",NA,NA
kind of query you want to make (and it often is) it's simpler to use ,NA,NA
findall,NA,NA
", because then ",NA,NA
you don't have to bother explicitly write down the conditions using ,NA,NA
^,NA,NA
.,NA,NA
"Further, there is one important difference between ",NA,NA
findall,NA,NA
 and ,NA,NA
bagof,NA,NA
", and that is that ",NA,NA
bagof,NA,NA
 ,NA,NA
"fails if the goal that's specified in its second argument is not satisfied (remember, that ",NA,NA
findall,NA,NA
 ,NA,NA
returns the empty list in such a case). So the query ,NA,NA
"bagof(X,descend(mary,X), Z)",NA,NA
 yields ,NA,NA
no,NA,NA
.,NA,NA
One final remark. Consider again the query ,NA,NA
"bagof(Child,descend(Mother,Child),List).",NA,NA
"As we saw above, this has four solutions. But, once again, Prolog generates them one by one. ",NA,NA
Wouldn't it be nice if we could collect them all into one list?,NA,NA
"And, of course, we can. The simplest way is to use ",NA,NA
findall,NA,NA
. The query ,NA,NA
"findall(List,bagof(Child,descend(Mother,Child),List),Z).",NA,NA
collects all of ,NA,NA
bagof,NA,NA
's responses into one list: ,NA,NA
List = _8293 ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node97.html (2 of 3)11/3/2006 7:36:37 PM,NA
Child = _8297 ,NA,NA
Mother = _8301 ,NA,NA
"Z = [[laura,rose],[caroline,laura,rose],[rose], ",NA,NA
 ,NA,NA
"[charlotte,caroline,laura,rose]] ",NA,NA
Another way to do it is with ,NA,NA
bagof,NA,NA
: ,NA,NA
"bagof(List,Child ^ Mother ^ bagof(Child,descend(Mother, Child),List),Z). ",NA,NA
List = _2648 ,NA,NA
Child = _2652 ,NA,NA
Mother = _2655 ,NA,NA
"Z = [[laura,rose],[caroline,laura,rose],[rose], ",NA,NA
 ,NA,NA
"[charlotte,caroline,laura,rose]]",NA,NA
"Now, this may not be the sort of thing you need to do very often, but it does show the ",NA,NA
flexibility and power offered by these predicates.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node97.html (3 of 3)11/3/2006 7:36:37 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
11.2.3 ,NA,NA
setof/3,NA,NA
The ,NA,NA
setof/3,NA,NA
 predicate is basically the same as ,NA,NA
bagof,NA,NA
", but with one useful difference: the lists it ",NA,NA
"contains are ordered and contain no redundancies (that is, each item appears in the list only ",NA,NA
once).,NA,NA
"For example, suppose we have the following database ",NA,NA
"age(harry,13). ",NA,NA
"age(draco,14). ",NA,NA
"age(ron,13). ",NA,NA
"age(hermione,13). ",NA,NA
"age(dumbledore,60). ",NA,NA
"age(hagrid,30).",NA,NA
Now suppose we want a list of everyone whose age is recorded in the database. We can do ,NA,NA
this with the query: ,NA,NA
"findall(X,age(X,Y),Out). ",NA,NA
X ,NA,NA
= ,NA,NA
_8443 ,NA,NA
Y ,NA,NA
= ,NA,NA
_8448 ,NA,NA
"Out = [harry,draco,ron,hermione,dumbledore,hagrid]",NA,NA
But maybe we would like the list to be ordered. We can achieve this with the following query: ,NA,NA
"setof(X,Y ^ age(X,Y),Out).",NA,NA
"(Note that, just like with",NA,NA
bagof,NA,NA
", we have to tell ",NA,NA
setof,NA,NA
 not to generate separate lists for each ,NA,NA
value of ,NA,NA
Y,NA,NA
", and again we do this with the ",NA,NA
^,NA,NA
 symbol.),NA,NA
This query yields: ,NA,NA
X ,NA,NA
= ,NA,NA
_8711 ,NA,NA
Y ,NA,NA
= ,NA,NA
_8715 ,NA,NA
"Out = [draco,dumbledore,hagrid,harry,hermione,ron]",NA,NA
Note that the list is alphabetically ordered.,NA,NA
Now suppose we are interested in collecting together all the ages which are recorded in the ,NA,NA
"database. Of course, we can do this with the following query: ",NA,NA
"findall(Y,age(X,Y),Out). ",NA,NA
Y ,NA,NA
= ,NA,NA
_8847 ,NA,NA
X ,NA,NA
= ,NA,NA
_8851 ,NA,NA
"Out = [13,14,13,13,60,30] ",NA,NA
But this output is rather messy. It is unordered and contains repetitions. By using ,NA,NA
setof,NA,NA
 we ,NA,NA
get the same information in a nicer form: ,NA,NA
"setof(Y,X ^ age(X,Y),Out). ",NA,NA
Y ,NA,NA
= ,NA,NA
_8981 ,NA,NA
X ,NA,NA
= ,NA,NA
_8985 ,NA,NA
"Out = [13,14,30,60] ",NA,NA
"Between them, these three predicates offer us a lot of flexibility. For many purposes, all we ",NA,NA
need is ,NA,NA
findall,NA,NA
". But if we need more, ",NA,NA
bagof,NA,NA
 and ,NA,NA
setof,NA,NA
 are there waiting to help us out.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
11.3 Exercises,NA,NA
Exercise 11.1,NA,NA
Suppose we start with an empty database. We then give the command: ,NA,NA
"assert(q(a,b)), assertz(q(1,2)), asserta(q(foo, blug)).",NA,NA
What does the database now contain? ,NA,NA
We then give the command: ,NA,NA
"retract(q(1,2)), assertz( (p(X) :-  h(X)) ).",NA,NA
What does the database now contain? ,NA,NA
We then give the command: ,NA,NA
"retract(q(_,_)),fail.",NA,NA
What does the database now contain? ,NA,NA
Exercise 11.2,NA,NA
Suppose we have the following database: ,NA,NA
"q(blob,blug). ",NA,NA
"q(blob,blag). ",NA,NA
"q(blob,blig). ",NA,NA
"q(blaf,blag). ",NA,NA
"q(dang,dong). ",NA,NA
"q(dang,blug). ",NA,NA
"q(flab,blob).",NA,NA
What is Prolog's response to the queries: ,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node99.html (1 of 3)11/3/2006 7:36:48 PM,NA
"1.  findall(X,q(blob,X),List). ",NA,NA
"2.  findall(X,q(X,blug),List). ",NA,NA
"3.  findall(X,q(X,Y),List).",NA,NA
"4.  bagof(X,q(X,Y),List).",NA,NA
"5.  setof(X,Y ^ q(X,Y),List).",NA,NA
Exercise 11.3,NA,NA
Write a predicate ,NA,NA
sigma/2,NA,NA
 that takes an integer ,NA,NA
 and calculates the sum of ,NA,NA
all intergers from 1 to . E.g. ,NA,NA
"?- sigma(3,X). ",NA,NA
X = 6 ,NA,NA
yes ,NA,NA
"?- sigma(5,X). ",NA,NA
X = 15 ,NA,NA
yes,NA,NA
Write the predicate such that results are stored in the database (of course there ,NA,NA
should always be no more than one result entry in the database for each value) ,NA,NA
"and reused whenever possible. So, for example: ",NA,NA
"?- sigma(2,X). ",NA,NA
X = 3 ,NA,NA
yes ,NA,NA
?- listing. ,NA,NA
"sigmares(2,3).",NA,NA
When we then ask the query ,NA,NA
"?- sigma(3,X).",NA,NA
"Prolog will not calculate everything new, but will get the result for ",NA,NA
"sigma(2,3) ",NA,NA
from the database and only add 3 to that. Prolog will answer: ,NA,NA
X = 6 ,NA,NA
yes ,NA,NA
?- listing. ,NA,NA
"sigmares(2,3). ",NA,NA
"sigmares(3,6).",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
11.4 Practical Session 11,NA,NA
Here are some programming exercises: ,NA,NA
"1.  Sets can be thought of as lists that don't contain any repeated elements. For example, ",NA,NA
"[a,4,6]",NA,NA
" is a set, but ",NA,NA
"[a,4,6,a]",NA,NA
 is not (as it contains two occurrences of ,NA,NA
a),NA,NA
. Write a Prolog ,NA,NA
program ,NA,NA
subset/2,NA,NA
 that is satisfied when the first argument is a subset of the second ,NA,NA
"argument (that is, when every element of the first argument is a member of the second ",NA,NA
argument). For example: ,NA,NA
"subset([a,b],[a,b,c]) ",NA,NA
yes ,NA,NA
"subset([c,b],[a,b,c]) ",NA,NA
yes ,NA,NA
"subset([],[a,b,c]) ",NA,NA
yes.,NA,NA
Your program should be capable of generating all subsets of an input set by ,NA,NA
"bactracking. For example, if you give it as input ",NA,NA
"subset(X,[a,b,c])",NA,NA
it should succesively generate all eight subsets of ,NA,NA
"[a,b,c]",NA,NA
.,NA,NA
2.  Using the ,NA,NA
subset,NA,NA
" predicate you have just written, and ",NA,NA
findall,NA,NA
", write a predicate ",NA,NA
powerset/2,NA,NA
" that takes a set as its first argument, and returns the powerset of this set as ",NA,NA
the second argument. (The powerset of a set is the set of all its subsets.) For example: ,NA,NA
"powerset([a,b,c],P)",NA,NA
should return ,NA,NA
"P = [[],[a],[b],[c],[a,b],[a,c],[b,c],[a,b,c]]",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node100.html (1 of 2)11/3/2006 7:36:54 PM,NA
"it doesn't matter if the sets are returned in some other order. For example, ",NA,NA
"P = [[a],[b],[c],[a,b,c],[],[a,b],[a,c],[b,c]]",NA,NA
is fine too.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
12 Working With Files,NA,NA
This lecture is concerned with different aspect of file handling. We will see ,NA,NA
1.  how predicate definitions can be spread across different files ,NA,NA
2.  how to write results to files and how to read input from files,G,NA
12.1 Splitting Programs Over Files ,H,NA
12.1.1 Reading in Programs ,H,NA
12.1.2 Modules ,H,NA
12.1.3 Libraries,G,NA
12.2 Writing To and Reading From Files,G,NA
12.3 Practical Session ,H,NA
12.3.1 Step 1 ,H,NA
12.3.2 Step 2 ,H,NA
12.3.3 Step 3 ,H,NA
12.3.4 Step 4 ,H,NA
12.3.5 Step 5 ,H,NA
12.3.6 Step 6,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
12.1 Splitting Programs Over Files,NA,NA
"By now, you have seen and you had to write lots of programs that use the predicates ",NA,NA
append ,NA,NA
and ,NA,NA
member,NA,NA
. What you probably did each time you needed one of them was to go back to the ,NA,NA
"definition and copy it over into the file where you wanted to use it. And maybe, after having ",NA,NA
"done that a couple of times, you started thinking that it was actually quite annoying that you ",NA,NA
had to copy the same predicate definitions over and over again and that it would be a lot nicer ,NA,NA
if you could define them somewhere once and for all and then just access that definition ,NA,NA
"whenever you needed it. Well, that sounds like a pretty sensible thing to ask for and, of course, ",NA,NA
Prolog offers you ways of doing it.,G,NA
12.1.1 Reading in Programs,G,NA
12.1.2 Modules,G,NA
12.1.3 Libraries,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
- Up -,NA,NA
Next >>,NA,NA
12.1.1 Reading in Programs,NA,NA
"In fact, you already know a way of telling Prolog to read in predicate definitions that are ",NA,NA
stored in a file. Right! ,NA,NA
[,NA,NA
FileName1,NA,NA
",",NA,NA
FileName2,NA,NA
].,NA,NA
 You have been using queries of that form all ,NA,NA
the time to tell Prolog to consult files. By putting ,NA,NA
:- [,NA,NA
FileName1,NA,NA
",",NA,NA
FileName2,NA,NA
].,NA,NA
"at the top of a file, you can tell Prolog to consult the files in the square brackets before ",NA,NA
reading in the rest of the file.,NA,NA
"So, suppose that you keep all predicate definitions that have to do with basic list processing, ",NA,NA
such as ,NA,NA
append,NA,NA
", ",NA,NA
member,NA,NA
", ",NA,NA
reverse,NA,NA
" etc., in a file called ",NA,NA
listpredicates.pl,NA,NA
. If you want to use ,NA,NA
"them, you just put ",NA,NA
:- [listpredicates].,NA,NA
at the top of the file you want to use them in. Prolog will consult ,NA,NA
listpredicates,NA,NA
", when ",NA,NA
"reading in that file, so that all predicate definitions in ",NA,NA
listpredicates,NA,NA
 become available.,NA,NA
On encountering something of the form ,NA,NA
":- [file,anotherfile]",NA,NA
", Prolog just goes ahead and consults ",NA,NA
"the files without checking whether the file really needs to be consulted. If, for example, the ",NA,NA
"predicate definitions provided by one of the files are already available, because it already was ",NA,NA
"consulted once, Prolog still consults it again, overwriting the definitions in the database. The ",NA,NA
inbuilt predicate ,NA,NA
ensure_loaded/1,NA,NA
 behaves a bit more clever in this case and it is what you ,NA,NA
should usually use to load predicate definitions given in some other file into your program. ,NA,NA
ensure_loaded,NA,NA
 basically works as follows: On encountering the following directive ,NA,NA
:- ensure_loaded([listpredicates]).,NA,NA
Prolog checks whether the file ,NA,NA
listpredicates.pl,NA,NA
" has already been loaded. If not, Prolog loads it. ",NA,NA
"If it already is loaded in, Prolog checks whether it has changed since last loading it and if that ",NA,NA
"is the case, Prolog loads it, if not, it doesn't do anything and goes on processing the program.",NA,NA
- Up -,NA,NA
Next >>,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node103.html (1 of 2)11/3/2006 7:37:23 PM,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
12.1.2 Modules,NA,NA
"Now, imagine that you are writing a program that needs two predicates, let's say ",NA,NA
pred1/2 ,NA,NA
and ,NA,NA
pred2/2,NA,NA
. You have a definition for ,NA,NA
pred1,NA,NA
 in the file ,NA,NA
preds1.pl,NA,NA
 and a definition of ,NA,NA
pred2,NA,NA
 in the ,NA,NA
file ,NA,NA
preds2.pl,NA,NA
". No problem, you think, I'll just load them into my program by putting ",NA,NA
":- [preds1, preds2].",NA,NA
"at the top of the file. Unfortunately, there seem to be problems this time. You get a message ",NA,NA
that looks something like the following: ,NA,NA
{consulting /a/troll/export/home/MP/kris/preds1.pl...} ,NA,NA
{/a/troll/export/home/MP/kris/preds1.,NA,NA
"pl consulted, 10 msec 296 bytes} ",NA,NA
{consulting /a/troll/export/home/MP/kris/preds2.pl...} The procedure ,NA,NA
helperpred/2 is being redefined. ,NA,NA
 Old file: /a/troll/export/home/MP/kris/preds1.pl  New file: ,NA,NA
/a/troll/export/home/MP/kris/preds2.pl Do you really want to redefine ,NA,NA
"it? (y, n, p, or ?) ",NA,NA
"So what has happened? Well, it looks as if both files ",NA,NA
preds1.pl,NA,NA
 and ,NA,NA
preds2.pl,NA,NA
 are defining the ,NA,NA
predicate ,NA,NA
helperpred,NA,NA
". And what's worse, you can't be sure that the predicate is defined in the ",NA,NA
"same way in both files. So, you can't just say ""yes, override"", since ",NA,NA
pred1 ,NA,NA
depends on the ,NA,NA
definition of ,NA,NA
helperpred,NA,NA
 given in file ,NA,NA
preds1.pl,NA,NA
 and ,NA,NA
pred2,NA,NA
 depends on the definition given in file ,NA,NA
preds2.pl,NA,NA
". Furthermore, note that you are not really interested in the definition of ",NA,NA
helperpred,NA,NA
 ,NA,NA
"at all. You don't want to use it. The predicates that you are interested in, that you want to use ",NA,NA
are ,NA,NA
pred1,NA,NA
 and ,NA,NA
pred2,NA,NA
. They need definitions of ,NA,NA
helperpred,NA,NA
", but the rest of your program doesn't.",NA,NA
A solution to this problem is to turn ,NA,NA
preds1.pl,NA,NA
 and ,NA,NA
preds2.pl,NA,NA
 into modules. Here is what this ,NA,NA
means and how it works:,NA,NA
Modules essentially allow you to hide predicate definitions. You are allowed to decide which ,NA,NA
"predicates should be public, i.e. callable from other parts of the program, and which ",NA,NA
"predicates should be private, i.e. callable only from within the module. You will not be able to ",NA,NA
"call private predicates from outside the module in which they are defined, but there will also ",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node104.html (1 of 3)11/3/2006 7:37:28 PM,NA
be no conflicts if two modules internally define the same predicate. In our example. ,NA,NA
helperpred,NA,NA
" is a good candidate for becoming a private predicate, since it is only used as a ",NA,NA
helper predicate in the definition of ,NA,NA
pred1,NA,NA
 and ,NA,NA
pred2,NA,NA
.,NA,NA
You can turn a file into a module by putting a module declaration at the top of that file. ,NA,NA
Module declarations are of the form ,NA,NA
:- module(,NA,NA
ModuleName,NA,NA
",",NA,NA
List_of_Predicates_to_be_Exported,NA,NA
) ,NA,NA
"They specify the name of the module and the list of public predicates. That is, the list of ",NA,NA
predicates that one wants to export. These will be the only predicates that are accessible from ,NA,NA
outside the module. ,NA,NA
"So, by putting ",NA,NA
":- module(preds1,[pred1/2]).",NA,NA
at the top of file ,NA,NA
preds1.pl,NA,NA
 you can define the module ,NA,NA
preds1,NA,NA
 which exports the predicate ,NA,NA
pred1/2,NA,NA
". And similarly, you can define the module ",NA,NA
preds2,NA,NA
 exporting the predicate ,NA,NA
pred2/2 ,NA,NA
by ,NA,NA
putting ,NA,NA
":- module(preds2,[pred2/3]).",NA,NA
at the top of file ,NA,NA
preds2.pl,NA,NA
. ,NA,NA
helperpred,NA,NA
 is now hidden in the modules ,NA,NA
preds1,NA,NA
 and ,NA,NA
preds2,NA,NA
", ",NA,NA
so that there is no clash when loading both modules at the same time.,NA,NA
Modules can be loaded with the inbuilt predicate ,NA,NA
use_module/1,NA,NA
. Putting ,NA,NA
:- use_module ,NA,NA
(preds1).,NA,NA
 at the top of a file will import all predicates that were defined as public by the ,NA,NA
"module. That means, all public predicates will be accessible.",NA,NA
"If you don't need all public predicates of a module, but only some of them, you can use the ",NA,NA
two-place version of ,NA,NA
use_module,NA,NA
", which takes the list of predicates that you want to import as ",NA,NA
"its second argument. So, by putting ",NA,NA
":- use_module(preds1,[pred1/2]), ",NA,NA
" use_module(preds2,[pred2/3]).",NA,NA
"at the top of your file, you will be able to use ",NA,NA
pred1,NA,NA
 and ,NA,NA
pred2,NA,NA
". Of course, you can only ",NA,NA
import predicates that are also exported by the relevant module.,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node104.html (2 of 3)11/3/2006 7:37:28 PM,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
12.1.3 Libraries,NA,NA
Many of the very common predicates are actually predefined in most Prolog implementations in ,NA,NA
"one way or another. If you have been using SWI Prolog, for example, you will probably have ",NA,NA
noticed that things like ,NA,NA
append,NA,NA
 and ,NA,NA
member,NA,NA
" are built in. That's a specialty of SWI, however. ",NA,NA
"Other Prolog implementations, like Sicstus for example, don't have them built in. But they ",NA,NA
usually come with a set of ,NA,NA
libraries,NA,NA
", i.e. modules defining common predicates. These libraries ",NA,NA
can be loaded using the normal commands for importing modules. When specifying the name ,NA,NA
"of the library that you want to use, you have to tell Prolog that this module is a library, so that ",NA,NA
"Prolog knows where to look for it (namely, not in the directory where your other code is, but at ",NA,NA
the place where Prolog keeps its libraries). Putting ,NA,NA
:- use_module(library(lists)).,NA,NA
"at the top of your file, for instance, tells Prolog to load a library called ",NA,NA
lists,NA,NA
". In Sicstus, this ",NA,NA
library provides basic list processing predicates.,NA,NA
"So, libraries can be pretty useful and they can safe you a lot of work. Note, however, that the ",NA,NA
way libraries are organized and the inventory of predicates provided by libraries are by no ,NA,NA
"means standardized across different Prolog implementations. In fact, the library systems may ",NA,NA
"differ quite a bit. So, if you want your program to run with different Prolog implementations, it ",NA,NA
might be easier and faster to define your own library modules (using the techniques that we ,NA,NA
saw in the last section) than to try to work around all the incompatibilities between the library ,NA,NA
systems of different Prolog implementations.,NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
12.2 Writing To and Reading From Files,NA,NA
"Now, that we have learned how to load programs from different files, we want to look at ",NA,NA
writing results to files and reading in input from files in this section.,NA,NA
"Before we can do any reading of or writing to the file, we have to open it and associate a ",NA,NA
stream,NA,NA
 with it. You can think of streams as connections to files. Streams have names that look ,NA,NA
"like this, for instance: ",NA,NA
'$stream'(183368),NA,NA
". You need these names, when specifying which ",NA,NA
"stream to write to or read from. Luckily, you never really have to worry about the exact names ",NA,NA
of streams. Prolog assigns them these names and you usually just bind them to a variable and ,NA,NA
then pass this variable around. We'll see an example soon.,NA,NA
The inbuilt predicate ,NA,NA
open/3,NA,NA
 opens a file and connects it to a stream. ,NA,NA
open(+,NA,NA
FileName,NA,NA
",+",NA,NA
Mode,NA,NA
",-",NA,NA
Stream,NA,NA
),NA,NA
The first argument of ,NA,NA
open,NA,NA
" is the name of the file, and in the last argument, Prolog returns ",NA,NA
the name that it assigns to the stream. Mode is one of ,NA,NA
read,NA,NA
", ",NA,NA
write,NA,NA
", ",NA,NA
append,NA,NA
. ,NA,NA
read,NA,NA
 means that ,NA,NA
"the file is opened for reading, and ",NA,NA
write,NA,NA
 and ,NA,NA
append,NA,NA
 both open the file for writing. In both ,NA,NA
"cases, the file is created, if it doesn't exist, yet. If it does exist, however, ",NA,NA
write,NA,NA
 will cause the ,NA,NA
"file to be overwritten, while ",NA,NA
append,NA,NA
 appends everything at the end of the file.,NA,NA
"When you are finished with the file, you should close it again. That is done with the following ",NA,NA
"predicate, where Stream is the name of a Stream as assigned by Prolog. ",NA,NA
close(,NA,NA
Stream,NA,NA
),NA,NA
"So, programs that are writing to or reading from files will typically have the following ",NA,NA
structure: ,NA,NA
"open(myfile,write,Stream), ",NA,NA
... ,NA,NA
do something,NA,NA
 ... ,NA,NA
"close(Stream), ",NA,NA
The predicates for actually writing things to a stream are almost the same as the ones we saw ,NA,NA
in ,NA,NA
Chapter 9,NA,NA
 for writing to the screen. We have ,NA,NA
write,NA,NA
", ",NA,NA
tab,NA,NA
", and ",NA,NA
nl,NA,NA
. The only thing that's ,NA,NA
different is that we always give the stream that we want to write to as the first argument.,NA,NA
"Here is a piece of code that opens a file for writing, writes something to it, and closes it again. ",NA,NA
"?- open(hogwarts,write,OS), ",NA,NA
" tab(OS,7),write(OS,gryffindor),nl(OS), ",NA,NA
" write(OS,hufflepuff),tab(OS,5),write(OS,ravenclaw),nl (OS), ",NA,NA
" tab(OS,7),write(OS,slytherin), ",NA,NA
 close(OS).,NA,NA
The file ,NA,NA
hogwarts,NA,NA
 should afterwards look like this: ,NA,NA
 gryffindor ,NA,NA
hufflepuff     ravenclaw ,NA,NA
 slytherin,NA,NA
"Finally, there is a two-place predicate for reading in terms from a stream. ",NA,NA
read,NA,NA
 always looks ,NA,NA
for the next term on the stream and reads it in. ,NA,NA
read(+,NA,NA
Stream,NA,NA
",+",NA,NA
Term,NA,NA
),NA,NA
The inbuilt predicate ,NA,NA
at_end_of_stream,NA,NA
 checks whether the end of a stream has been ,NA,NA
reached. ,NA,NA
at_end_of_stream(Stream),NA,NA
" will evaluate to true, when the end of the stream ",NA,NA
Stream,NA,NA
 ,NA,NA
"is reached, i.e. when all terms in the corresponding file have been read.",NA,NA
"Note, that ",NA,NA
read,NA,NA
" only reads in Prolog terms. If you want to read in arbitrary input, things ",NA,NA
become a bit more ugly. You have to read it character by character. The predicate that you ,NA,NA
need is ,NA,NA
"get0(+Stream,-Char)",NA,NA
. It reads the next character from the stream ,NA,NA
+Stream,NA,NA
. ,NA,NA
Char,NA,NA
 is the integer code of the character. That means that ,NA,NA
get0,NA,NA
" returns 97, if the next ",NA,NA
"character is a, for instance.",NA,NA
"Usually, we are not interested in these integer codes, but in the characters or rather the atoms ",NA,NA
"that are made up of a list of characters. Well, you can use the predicate ",NA,NA
atom_chars/2,NA,NA
 to ,NA,NA
convert a list of integers into the corresponding atom. The first argument of ,NA,NA
atom_chars/2 ,NA,NA
is ,NA,NA
the atom and the second the list of integers. For example: ,NA,NA
"?- atom_chars(W,[113,117,105,100,100,105,116,99,104]). W = quidditch",http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node106.html (2 of 3)11/3/2006 7:37:38 PM,NA
Here is the code for reading in a word from a stream. It reads in a character and then checks ,NA,NA
"whether this character is a blank, a carriage return or the end of the stream. In any of these ",NA,NA
"cases a complete word has been read, otherwise the next character is read. ",NA,NA
"readWord(InStream,W) :- ",NA,NA
" get0(InStream,Char), ",NA,NA
" checkCharAndReadRest(Char,Chars,InStream),  ",NA,NA
"atom_chars(W,Chars). ",NA,NA
"checkCharAndReadRest(10,[],_) :- !.  % Return ",NA,NA
"checkCharAndReadRest(32,[],_) :- !.  % Space ",NA,NA
"checkCharAndReadRest(-1,[],_) :- !.  % End of Stream ",NA,NA
"checkCharAndReadRest(end_of_file,[],_) :- !. ",NA,NA
"checkCharAndReadRest(Char,[Char|Chars],InStream) :-  ",NA,NA
"get0(InStream,NextChar), ",NA,NA
" checkCharAndReadRest(NextChar,Chars,InStream).",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Next >>,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz,NA,NA
Version 1.2.5 (20030212),NA,NA
<< Prev,NA,NA
- Up -,NA,NA
12.3 Practical Session,NA,NA
"In this practical session, we want to combine what we learned today with some bits and pieces ",NA,NA
that we met earlier in the course. The goal is to write a program for running a DCG grammar ,NA,NA
"on a testsuite, so that the performance of the grammar can be checked. A testsuite is a file ",NA,NA
"that contains lots of possible inputs for a program, in our case a file that contains lots of lists ",NA,NA
"representing grammatical or ungrammatical sentences, such as ",NA,NA
"[the,woman,shoots, ",NA,NA
"the,cow,under,the,shower]",NA,NA
 or ,NA,NA
"[him,shoots,woman]",NA,NA
". The test program should take this file, run ",NA,NA
the grammar on each of the sentences and store the results in another file. We can then look ,NA,NA
at the output file to check whether the grammar answered everywhere the way it should. ,NA,NA
"When developing grammars, testsuites like this are extremely useful to make sure that the ",NA,NA
changes we make to the grammar don't have any unwanted effects.,NA,NA
12.3.1 Step 1,NA,NA
Take the DCG that you built in the practical session of ,NA,NA
Chapter 8,NA,NA
" and turn it into a module, ",NA,NA
exporting the predicate ,NA,NA
s/3,NA,NA
", i.e. the predicate that lets you parse sentences and returns the ",NA,NA
parse tree in its first argument.,NA,NA
12.3.2 Step 2,NA,NA
In the practical session of ,NA,NA
Chapter 9,NA,NA
", you had to write a program for pretty printing parse ",NA,NA
trees onto the screen. Turn that into a module as well.,NA,NA
12.3.3 Step 3,NA,NA
"Now, modify the program, so that it prints the tree not to the screen but to a given stream. ",NA,NA
That means that the predicate ,NA,NA
pptree,NA,NA
 should now be a two-place predicate taking the Prolog ,NA,NA
representation of a parse tree and a stream as arguments.,NA,NA
12.3.4 Step 4,NA,NA
Import both modules into a file and define a two-place predicate ,NA,NA
test,NA,NA
 which takes a list ,NA,NA
representing a sentence (such as ,NA,NA
"[a,woman,shoots]",NA,NA
"), parses it and writes the result to the file ",NA,NA
specified by the second argument of ,NA,NA
test,NA,NA
. Check that everything is working as it should.,NA,NA
12.3.5 Step 5,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node107.html (1 of 3)11/3/2006 7:37:45 PM,NA
"Finally, modify ",NA,NA
test/2,NA,NA
", so that it takes a filename instead of a sentence as its first argument ",NA,NA
"and then reads in the sentences given in the file one by one, parses them and writes the ",NA,NA
"sentence as well as the parsing result into the output file. If, e.g, your input file looked like ",NA,NA
this: ,NA,NA
"[the,cow,under,the,table,shoots]. ",NA,NA
"[a,dead,woman,likes,he]. ",NA,NA
the output file should look similar to this: ,NA,NA
"[the, cow, under, the, table, shoots] ",NA,NA
 s( ,NA,NA
 np( ,NA,NA
 det(the) ,NA,NA
 nbar( ,NA,NA
 n(cow)) ,NA,NA
 pp( ,NA,NA
 prep(under) ,NA,NA
 np( ,NA,NA
 det(the) ,NA,NA
 nbar( ,NA,NA
 n(table))))) ,NA,NA
 vp( ,NA,NA
 v(shoots))) ,NA,NA
"[a, dead, woman, likes, he] ",NA,NA
no,NA,NA
12.3.6 Step 6,NA,NA
"Now, if you are in for some real Prolog hacking, try to write a module that reads in sentences ",NA,NA
"terminated by a full stop or a line break from a file, so that you can give your testsuite as ",NA,NA
the cow under the table shoots . ,NA,NA
a dead woman likes he .,http://www.coli.uni-saarland.de/~kris/learn-prolog-now/html/node107.html (2 of 3)11/3/2006 7:37:45 PM,NA
instead of ,NA,NA
"[the,cow,under,the,table,shoots]. ",NA,NA
"[a,dead,woman,likes,he]. ",NA,NA
<< Prev,NA,NA
- Up -,NA,NA
Patrick Blackburn,NA,NA
", ",NA,NA
Johan Bos,NA,NA
 and ,NA,NA
Kristina Striegnitz ,NA,NA
Version 1.2.5 (20030212),NA,NA
