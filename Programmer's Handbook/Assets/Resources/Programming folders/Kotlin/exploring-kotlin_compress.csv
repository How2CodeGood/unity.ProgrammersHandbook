Larger Text,Smaller Text,Symbol
Exploring Kotlin,NA,NA
"Syntax, features & capabilites",NA,NA
Hani M K,"This book is for sale at
  http://leanpub.com/exploring-kotlin
  
 This version was published on 2019-11-30
  
  
 This is a
  Leanpub
  book. Leanpub empowers authors and publishers with the Lean 
 Publishing process.
  Lean Publishing
  is the act of publishing an in-progress ebook using 
 lightweight tools and many iterations to get reader feedback, pivot until you have the 
 right book and build traction once you do.
  
 © 2019 Hani M K",NA
Tweet This Book!,"Please help Hani M K by spreading the word about this book on
  Twitter
 !
  
 The suggested tweet for this book is: 
  
 Exploring #Kotlin Book Less than 100 pages covering Kotlin syntax and features in 
 straight and to the point explanation. @hmkcode 
  
 The suggested hashtag for this book is
  #kotlin
 .
  
 Find out what other people are saying about the book by clicking on this link to 
 search for this hashtag on Twitter: 
  
 #kotlin",NA
Contents,"CHAPTER 1 | Getting Started
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.1 |
  Tools
  . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.2 |
  Kotlin Basic Syntax
  . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . .
  
 CHAPTER 2 | Classes and Inheritance 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 2.1 |
  Class 
 Anatomy 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 2.2
  | Class 
 Inheritance
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 CHAPTER 3 | Packages & Visibility Modifiers
  . . . . . . . . . . . . . . . . . . . . . . 3.1 |
  
 Packages
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2 |
  Visibility Modifiers
  . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 CHAPTER 4 | Properties & Fields
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 4.1 |
  Class 
 Properties
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 4.2 |
  Compile-Time Constants
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 4.3 |
  Late-Initialization 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . .
  
 CHAPTER 5 | Abstract Classes and Interface
  . . . . . . . . . . . . . . . . . . . . . . 5.1 |
  Abstract 
 Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.2 |
  Interface
  . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . .
  
 CHAPTER 6 | Nested Class, Inner Class, Local Class & Anonymous Class
  . . . . 
  
 6.1 |
  Nested Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 6.2 |
  Inner Class
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 6.3 |
  Local Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . 
  
 6.4 |
  Anonymous Class 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . .
  
 CHAPTER 7 | Data Classe, Enum Class, Sealed Class, Inline Class
  . . . . . . . . 7.1 |
  
 Data Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7.2 |
  Enum Class
  . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . 7.3 |
  Sealed Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . 7.4 |
  Inline Class
  experimental
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 CHAPTER 8 | Object Expression and Declarations & Companion objects
  . . . . 
 8.1 |
  Object Expression
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.2 |
  Object 
 Declarations
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3 |
  Companion Objects
  . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 CHAPTER 9 | Delegation & Property Delegation
  . . . . . . . . . . . . . . . . . . . . 9.1 |
  
 Delegation
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.2 |
  Delegated Properties
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.3 |
  Standard Delegates
  . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . .
  
 1
  
  
 1 
  
 2
  
 9 
  
 9 
  
 12
  
 17 
 17 
 17
  
 2
 0 
 20 
 21 
 21
  
 2
 4 
 24 
 24
  
 2
 6 
 26 
 26 
 27 
 28
  
 2
 9 
 29 
 30 
 32 
 32
  
 3
 4 
 34 
 35 
 35
  
 37 
 37 
 38 
 40",NA
CHAPTER 1 | Getting Started,"• This chapter will cover the basic syntax of Kotlin and will introduce some of the 
  
 tools used for coding in Kotlin.",NA
1.1 | Tools,"• There are many tools that will help you start coding in Kotlin.
  
 • Tools listed below shall cover the needs for most Kotlin learners to start coding 
  
 in Kotlin.
  
 • Based on your goal from learning Kotlin, you may use one or more of these tools.• 
 In this book we will mainly be using Kotlin online playground.",NA
Kotlin playground,"•
  Kotlin Playground
 1
 is an online sandbox to explore Kotlin.• The 
 playground is the easiest way to start exploring Kotlin.
  
 1 
 fun
  main
 () {
  
 2 
 println(
 ""Hello, world!!!""
 )
  
 3 
 }",NA
IntelliJ IDEA,"• IntelliJ IDEA is the preferred IDE for developing projects in Kotlin.
  
 • Kotlin is bundled with IntelliJ IDEA. It has all what you need to start coding in 
  
 Kotlin.
  
 • You can download the free
  Community Edition
 2
  
 • You can follow the steps in this tutorial from Kotlin official site
  Getting Started 
  
 with IntelliJ IDEA
 3",NA
Android studio,"• Android Studio fully supports Kotlin.
  
 • You can create a new project with Kotlin-first support, add Kotlin files to existing 
  
 project with Java files or converting existing Java to Kotlin.
  
 1
 https://play.kotlinlang.org
  
 2
 http://www.jetbrains.com/idea/download/index.html 
  
 3
 https://kotlinlang.org/docs/tutorials/getting-started.html",NA
1.2 | Kotlin Basic Syntax,main(),NA
 function,"• The starting point for running Kotlin app is
  main()
  function.
  
 1 
 fun
  main
 () {
  
 2 
 println(
 ""Hello world!""
 )
  
 3 
 }
  
 val",NA
 &,var,NA
 variables,"• Read-only variables should be defined with
  val
  
 • Variables that can be updated or changed is defined as
  var
  
 • Variables must either have a type annotation or be initialized
  
 1 
 val
  w: Int =
  0
  // immediate assignment
  
 2 
 val
  x =
  6
  // type `Int` is inferred ""no type provided""
  
 3 
 val
  y: Int
  // Type is required ""no initial value""
  
 4 
 y =
  7
  // deferred assignment ""Type of y defined before""
  
 5 
 val
  z =
  3
  // this is OK
  
 6
  
 7 
 z = z +
  1
  // This is an error ""Val cannot be reassigned""
  
 8
  
 9 
 var
  counter =
  0
  // this variable can be updated
  
 10 
  
 counter++;",NA
Comments,"• Comments can be added in Kotlin as following
  
 1 
 // single line comment
  
 2
  
 3 
 /* Multi-line
  
 4 
 comments */",NA
String templates,• String template is a neat way to build a dynamic string.,NA
Functions,"fun
  
 • Functions is a block of reusable code that is used to perform an action and may
  
 return result.
  
 • Functions are declared using
  fun
  keyword.
  
 • Functions may take variables or even other functions as parameters.
  
 1 
 fun
  multiply
 (a: Int, b: Int): Int{
  
 2 
 return
  a * b
  
 3 
 }
  
 • Function with expression body and inferred return type can be written as:
  
 1 
 fun
  multiply
 (a: Int, b: Int) = a * b
  
 • Function parameters can have default values.
  
 1 
 fun
  multiply
 (a: Int=
 2
 , b: Int=
 4
 ) = a * b
  
 • Function with no return value use
  Unit
  as return type which can be also omitted.",NA
 &,when,NA
 Control Flow,"•
  if
  and
  when
  are used to control the flow of the program. They are used to select
  
 which code will be executed based on some conditions.
  
 1 
 // if a is even return true
  
 2 
 fun
  isEven
 (a:Int): Boolean{
  
 3 
 if
 (a %
  2
  ==
  0
 )
  return true else return false
  
 4 
 }
  
 •
  if
  can be written as an expression
  
 1 
 // if as expression i.e. returns result
  
 2 
 fun
  isEven
 (a:Int) = 
  
 if
 (a %
  2
  ==
  0
 )
  true else false
  
 •
  Even simpler version of the function above is possible
  
 1
  
 fun
  isEven
 (a:Int) =
  
 (a %
  2
  ==
  0
 )
  
 •
  when
  tries sequentially to match its argument against all branches.
  
 • if
  when
  is used as an expression,
  else
  branch is mandatory unless exhaustiveness
  
 of possible cases is guaranteed as in the case of
  enum class
  and
  sealed class
 .
  
 1 
 fun
  check
 (a:Int){
  
 2 
 when
 (a%
 2
 ){
  
 3 
  
 0
  -> println(
 ""Even""
 ) 
  
 // i.e. if(a%2 == 0)
  
 4 
  
 else
  -> println(
 ""Odd""
 )
  
 5 
 }
  
 6 
 }
  
 null",NA
 saftey using,"?
  
 • Object type should be marked with
  ?
  if its reference is nullable i.e. can possibily
  
 receive
  null
  value.",NA
 type checks and,as,NA
 type casting,"•
  is
  operator is used to check if an object is an instance of a certain type.
  
 •
  is
  will automatically cast checked object into the type being checked.
  
 1 
 val
  str:Any =
  """"
  // str of type Any initialized with String
  
 2
  
 3 
 if
 (str
  is
  String)
  // true
  
 4 
 println(str.length)
  // str is cast to type String
  
 -
  as
  operator is used to explicitly cast an object into a specific type.
  
 1 
 val
  str:Any =
  """"
  
 2 
 println((str
  as
  String).length)
  // str is cast from Any to String
  
 for",NA
 &,while,NA
 loop,"•
  for
  loop is used to iterates over any iterable object e.g. collection, sequence,
  
 range, …
  
 1 
 val
  collection = listOf(
 1
 ,
 2
 ,
 3
 ,
 4
 )
  
 2
  
 3 
 for
 (e
  in
  collection)
  
 4 
 println(e)
  
 • To loop over a range of numbers we can use range operator e.g.
  1..9",NA
Class and classes types,"• A class is the basic building block of object-oriented language.
  
 • A class represents an entity that has properties and can do some action.•
  
 class
  keyword is used to declare a class.
  
 • A class is used to create instances or objects of the class type.
  
 1 
 //minimum valid calss 
  
 2 
 class
  SomeClass
  
 • A class can have its own properties, or “variables”, and functions.
  
 1 
 class
  SomeClass
 (
 val
  id:Int){
  // class with primary constructor 
 2 
  
 var
  
 name:String =
  """" 
  
 // parameter 
  
 3
  
 4
  
 }
  
 function doSomething(){ println(
 ""doing something!""
 )}
  // function
  
 5
  
 • To create an instance, call class name with its primary constructor parameters.
  
 1 
 val
  someClass = SomeClass(
 3
 )
  // create instance of class SomeClass 
 2 
 someClass.doSomething()
  // call class method.
  
 • There are many other types of classes in Kotlin such as
  abstract class
 ,
  inline 
  
 class
 ,
  
 sealed class
 , …etc.",NA
Collections,"• Collection is a container for objects of similar type.
  
 • There are three basic types of collections namely,
  List
 ,
  Set
  and
  Map",NA
Basic types,"• In Kotlin, everything is an object that has functions and properties.
  
 • Some types such numbers, characters and boolean can be presented as primitive
  
 at runtime.
  
 Numbers
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 Type 
  
 Byte 
  
 Short 
  
 Int 
  
 Long 
  
 Float 
  
 Double
  
 Size(bits) 
  
 8 
  
 16 
  
 32 
  
 64 
  
 32 
  
 64
  
 val
  x =
  1
  // Type inferred as Int 
  
 val
  y =
  5000000000
  // Type inferred as Long 
 val
  z =
  1L
  
 // Explicit type Long 
  
 val
  b: Byte =
  1
  
 5
  
 6 
 val
  PI =
  3.14
  // Type inferred as Double
  
 7 
 val
  exp =
  2.7182818284
  // Double
  
 8 
 val
  expFloat =
  2.7182818284f
  // Float, actual value is 2.7182817
  
 Character
  
 • A character is defined using
  Char
 .
  
 • Character value is single quoted e.g.
  'A'
 .",NA
CHAPTER 2 | Classes and Inheritance,NA,NA
2.1 | Class Anatomy,"• Class is the basic building block of object-oriented programming languages.• A Class 
 is a representation of an entity that may have properties and can do 
  
 actions.
  
 • Classes define the blueprint for creating objects.",NA
Declaring a class,"•
  class
  keyword is used to declare a new class.
  
 1 
 class
  SomeClass
 {
  /* class memebers */
  }
  
 • Curly brackets
  {}
  can be omitted if the class has no body.
  
 1 
 class
  SomeClass",NA
Class members,"• Class can contain:
  
 - Constructors declared with
  constructor
  
 - Properties declared with
  val
  and
  var
  
 - Functions declared with
  fun
  
 - Nested & inner classes
  more in chapter 6…
  
 - Object declaration and companion objects declared using
  object",NA
Constructor,"• A class can have zero or more constructors.
  
 • Constructors can be declared in the class header or body using
  constructor 
  
 keyword.
  
 • Constructors can have zero or more parameters with optional default values.
  
 • A constructor declared in the class header is called
  primary
  constructor.• A 
 class can have one
  primary
  constructor.",NA
Creating class instance,"• Once a class is declared, instances can be created by calling class name followed
  
 by brackets
  ()
  containing values for constructor parameters if any.
  
 1 
 class
  SomeClass
 (id:Int)
  // declare a class
  
 2
  
 3 
 val
  someClass:SomeClass = SomeClass(
 3
 )
  // create instance",NA
Class properties,"• A class can have variables defined within its body called properties.
  
 • Properties are define using
  val
  or
  var
  keywords.
  
 •
  More about properties in chapter 4
  
 1 
 class
  SomeClass
 (id:Int) {
  
 2 
 val
  id:Int = id
  
 3 
 }
  
 • Properties can be defined in
  primary
  constructor by marking its parameters with
  
 val
  or
  var
  keywords.",NA
Class functions,"• A class can define functions within its body too.
  
 • Functions are declared using
  fun
  keywords.
  
 • Functions can have parameters with optional default values.
  
 •
  More about functions in chapter 12
 .
  
 init Block
  
 • initializing blocks are used to execute some code during instance initialization.
  
 •
  init
  keyword is used to declare initialization block.
  
 • Initialization blocks are executed in the order they appear in the class body.
  
 1 
 class
  SomeClass
 {
  
 2 
 init{ println(
 ""Class in initializing...""
 )}
  
 3
  
 4 
 val
  property1 =
  ""1st property""
 .also(
 ::
 println)
  
 5 
 init{ println(
 ""2nd init...""
 )}
  
 6 
 val
  property2 =
  ""2nd property""
 .also(
 ::
 println)
  
 7
  
 8
  
 }
  
 override fun
  toString
 () =
  ""Class is created!""
  
 9
  
 10
  
 11 
  
 fun
  main
 () {
  
 12 
  
 println(SomeClass())
  
 13 
  
 }
  
 Output:
  
 1 
 Class in initializing...
  
 2 
 1st property
  
 3 
 2nd init...
  
 4 
 2nd property
  
 5 
 Class is created!
  
 • If a class is created using secondary constructor, then delegation to the primary
  
 constructor is executed before all init blocks i.e.
  this
  will be called first.",NA
Constructor parameters vs. class properties,"• Variables defined in the constructors are called constructor parameters.
  
 • Variables declared within class body are called properties.
  
 • Parameters can be used to initialized class properties.
  
 1 
 class
  SomeClass
 (id:Int) {
  // id is a parameter
  
 2 
 val
  id:Int = id
  // id is class property
  
 3 
 }
  
 • Properties can be declared and initialized in the
  primary
  constructor by marking
  
 constructor parameters with
  val
  and
  var
  
 1 
 class
  SomeClass
 (
 var
  id:Int =
  0
 )",NA
2.2 | Class Inheritance,"• A class can inherit from another class or be inherited by other classes.
  
 • A class we are inheriting from is called superclass while the inheriting class is
  
 called subclass.
  
 • By inheriting from a superclass, subclasses can reuse superclass
  open
  members
  
 or
  override
  them.
  
 • By default all classes in Kotlin are subtypes of supertype
  Any
 .",NA
 for inheritance,"• A class should be marked as
  open
  to allow other classes to inherit its members.
  
 1 
 open class
  ParentClass",NA
Extending a Class,"• A class can inherit or extend other class by using
  :
 .
  
 • The superclass should be marked as
  open
  
 1 
 class
  ChildClass
  : ParentClass()",NA
Initializing superclass,"• Superclass should be initialized by subclass.
  
 • If the subclass has a
  primary
  constructor, then superclass will be initialized in
  
 class header.
  
 1 
 open class
  ParentClass
 (
 open val
  id:Int)
  
 2 
 class
  ChildClass
 (id:Int) : ParentClass(id)
  
 • If a subclass has NO
  primary
  constructor, then each
  secondary
  constructors
  
 should directly or indirectly call
  super
  which initialize superclass constructor.
  
 1 
 open class
  ParentClass
 (
 open val
  id:Int)
  
 2 
 class
  ChildClass
  : ParentClass{
  
 3
  
 4 
 constructor
 (id:Int):
 super
 (id)
  
 5
  
 6
  
 }
  
 // super is called by delegating to other constructor
  
 7
  
 constructor
 (id:Int, name:String):
 this
 (id)
  
 8
  
 override",NA
 functions,"• A subclass can call superclass functions marked as
  open
 .
  
 • A subclass can also
  override
  functions superclass functions marked as
  open
 .
  
 • By overriding we mean using the exact name and signature of a superclass open
  
 function to declare a function in a subclass.
  
 • Functions marked with
  override
  are
  open
  by default unless marked as
  final
  
 • Functions in superclass with NO
  open
  modifier can’t be overridden or even
  
 declared in subclasses.
  
 •
  private
  functions can’t be declared as
  open
 .",NA
 properties,"•
  open
  properties of a superclass can be overridden in a subclass using
  override
 .
  
 •
  val
  properties can be overridden with
  var
  but not the other way around.
  
 •
  private
  properties can’t be declared as
  open
 .
  
 1 
 open class
  ParentClass
 {
  
 2 
 open val
  name:String =
  ""ParentClass""
  
 3 
 }
  
 4 
 class
  ChildClass
  : ParentClass(){
  
 5 
 override var
  name:String =
  ""ChildClass""
  
 6 
 }
  
 • Concise syntax
  
 1 
 open class
  ParentClass
 (
 open val
  name:String =
  ""ParentClass""
 )
  
 2 
 class
  ChildClass
 (
 override var
  name:String =
  ""ChildClass""
 ) : ParentClass(name)",NA
Initializing order,"• Initialization of superclass is done before the initialization of subclass.
  
 • Initialization of superclass properties are also done before subclass properties.
  
 • Parameter evaluation of a superclass preceding all initializations.
  
 •
  init
  block and properties initialization are executed in the order they appear in
  
 the code.",NA
Accessing superclass members,"• Subclasses can access its superclass non-private properties and functions using
  
 super
  keyword.
  
 1 
 open class
  ParentClass
 (
 open val
  name:String){
  
 2 
 open fun
  doSomething
 () {
  
 3 
  
 println(
 ""ParentClass.doSomething""
 )
  
 4 
  
 println(
 ""ParentClass.name= ""
 +
 this
 .name)
  
 5 
 }
  
 6 
 }
  
 7 
 class
  ChildClass
 (name:String) : ParentClass(
 ""Parent""
 ){
  
 8 
  
 override val
  name = name+
 "" ""
 +
 super
 .name
  
 9
  
 10
  
 }
  
 override fun
  doSomething
 () {
  
 11
  
 super
 .doSomething()
  
 12
  
 println(
 ""ChildClass.doSomething with""
 )
  
 13
  
 println(
 ""ChildClass.name= ""
 +
 this
 .name)
  
 14
  
 }
  
 15
  
 16
  
 17 
  
 fun
  main
 () {",NA
CHAPTER 3 | Packages & ,NA,NA
Visibility Modifiers,NA,NA
3.1 | Packages,"• Kotlin source files may be organized into packages using
  package
  keyword.• 
 Packages help avoiding naming collision.
  
 • Content of a source file declared with a
  package
  are part of that package.• Package 
 name will be part of the source file content e.g. functions and classes 
  
 full name.
  
 1 
 package
  com.hmkcode
  
 2
  
 3 
 fun
  doSomething
 () {
  /*...*/
  }
  // com.hmkcode.doSomething
  
 4 
 class
  SomeClass
  {
  /*...*/
  }
  // com.hmkcode.SomeClass
  
 • A package should be imported if its content is used in another source file.
  
 1 
 package
  com.kotlin
  
 2
  
 3 
 import
  com.hmkcode.*
  
 • Source files without package declaration are part of the default package that has 
  
 no name.",NA
3.2 | Visibility Modifiers,"• Visibility modifiers control the accessibility of classes, objects, interfaces, con-
  
 structors, functions and properties.
  
 • Kotlin has four visibility modifiers:
  private
 ,
  protected
 ,
  internal
  and
  public
 .•
  public
  
 is the default modifiers.",NA
Top-level,"• Classes, functions, properties, …etc. declared directly inside a package are 
  
 called 
 top-level.
  
 • Top level classes, functions, properties,…etc. marked as
  
 -
  
 public
  are visible everywhere.
  
 -
  private
  are visible within the source file they declared in.-
  
 internal
  are visible in the same module.
  
 -
  protected
  not available for top-level declarations.",NA
Class members,"• Class members such as functions, properties and constructs marked as:
  
 -
  public
  are visible everywhere.
  
 -
  private
  are visible within the class.
  
 -
  internal
  are visible within the module.
  
 -
  protected
  are visible within the class and subclasses.
  
 1 
 package
  com.kotlin
  
 2
  
 3 
 open class
  SomeClass
 {
  
 4 
 private val
  name:String =
  ""SomeName""
  
 5 
 protected val
  id:Int =
  2
  
 6
  
 7
  
 }
  
 internal open fun
  doSomething
 (){
  
 8
  
 println(
 ""name = $name""
 )
  
 9
  
 }
  
 10
  
 11
  
 12 
  
 class
  SubClass
  : SomeClass(){
  
 13 
  
 override fun
  doSomething
 (){
  
 14 
  
 // println(""name = $name"") ""name"" is private -> not visible
  
 15 
  
 println(
 ""id = $id""
 )
  // ""id"" is protected -> visible in subclass
  
 16 
  
 }",NA
CHAPTER 4 | Properties & Fields,NA,NA
4.1 | Class Properties,"•
  val
  and
  var
  variables declared within a class are called class properties.
  
 1 
 class
  SomeClass
 {
  
 2 
 var name
 :
 String
  =
  """"
  
 3 
 }
  
 • Property can be access by its name
  
 1 
 SomeClass
 ().
 name",NA
Getters and Setters,"• Kotlin, automatically generates accessors for properties with default implemen-
  
 tation.
  
 •
  var
  properties have
  get()
  &
  set()
  accessors while
  val
  properties have
  get()
  
 acceesor only.
  
 • Within the implementation of the
  get()
  &
  set()
 , you can refer to the property
  
 using backing field
  field
  keyword.
  
 1 
 class
  SomeClass
 {
  
 2
  
 3
  
 }
  
 var name
 :
 String
  =
  """"
  
 // ""field"" is a backing field refer to name
  
 4
  
 get
 () =
  field
  
 5
  
 set
 (
 value
 ) {
  
 6
  
 field
  =
  value
  
 7
  
 }
  
 8
  
 • You can override default implementation of
  get()
  &
  set()
  
 • Notice that,
  set()
  is NOT called on initialization of property.",NA
4.2 | Compile-Time Constants,"• Kotlin allows the declaration of compile time constants using
  const
  modifier.
  
 • Compile time constants have
  primitive
  values known at compile time.
  
 • A constant is allowed to be declared as a top-level, a member of object declara-
  
 tion or companion object.
  
 • Constants should be initialized.
  
 • No custom getter is allowed.
  
 1 
 const
  val VERSION
 :
  Int
  = 2",NA
4.3 | Late-Initialization,"• Properties and variables should be intialized with a value or
  null
  for nullable type.
  
 1 
 class
  SomeClass
 {
  
 2 
 var
  name:String =
  ""SomeName""
  // property initialized
  
 3 
 var
  id:Int? =
  null 
  
 // nullable property intialized with null
  
 4 
 override fun
  toString
 ():String{
  
 5 
  
 return
  ""SomeClass name=$name""
  
 6 
 }
  
 7 
 }",NA
CHAPTER 5 | Abstract Classes and ,NA,NA
Interface,NA,NA
5.1 | Abstract Class,"• Abstract class is declared with
  abstract class
  keywords.
  
 • A class should be declared as
  abstract
 , if it has abstract members.
  
 • Abstract members are unimplemented functions or properties.
  
 •
  abstract
  class can have both abstract and concrete members.
  
 • Any non-abstract class inheriting an
  abstract
  class must implement abstract 
  
 members.
  
 • A class can only extend one abstract class.
  
 • Abstract classes cannot be instantiated.
  
 • Abstract classes are
  open
  by default.
  
 1 
 abstract class
  AbstractClass
  {
  
 2 
 abstract val
  name:String 
  
 // abstract property
  
 3
  
 4 
 val
  id:Int =
  9
  
 5 
  
 get
 () = field
  
 6
  
 7 
 abstract fun
  doSomething
 ()
  // abstract function
  
 8
  
 9
  
 }
  
 fun
  doSomethingElse
 (){ println(
 ""AbstractClass.doSomethingElse()""
 )}
  
 10
  
 11
  
 12 
  
 class
  SomeClass
 (
 override val
  name:String) : AbstractClass() {
  
 13 
  
 override fun
  doSomething
 () { println(
 ""ChildClass.doSomething()""
 ) }
  
 14 
  
 }",NA
5.2 | Interface,"• • Interfaces are declared with
  interface
  keywords.
  
 • Similar to abstract classes, interfaces can contain abstract and non-abstract 
  
 members.
  
 • All unimplemented members are abstract by default i.e. no need to mark mem-
  
 bers as
  abstract
 .
  
 • A class in Kotlin can implement more than one interface.
  
 • Properties in the interface can NOT have backing fields, so they can NOT maintain 
  
 state. In other words, you don’t have access to
  field
 .",NA
Multiple implementation inheritance,"• Since a class can inherit from multiple interface, we may inherit more than one
  
 implemented
  function of the same name.
  
 • To resolve this conflict, the inheriting class must override this method.
  
 • Inherited implemented functions can be accessed using qualified
  super<...>
 .
  
 1 
 interface
  A
  {
  
 2 
 fun
  doSomething
 (){ println(
 ""A.doSomething()""
 )}
  
 3 
 }
  
 4
  
 5 
 interface
  B
 {
  
 6 
 fun
  doSomething
 (){ println(
 ""B.doSomething()""
 )}
  
 7 
 }
  
 8
  
 9 
 class
  SomeClass
 () : A, B {
  
 10 
  
 override fun
  doSomething
 () {
  
 11 
  
 super
 <A>.doSomething()
  
 12 
  
 super
 <B>.doSomething()
  
 13 
  
 println(
 ""SomeClass.doSomething()""
 )
  
 14 
  
 }
  
 15 
  
 }",NA
"CHAPTER 6 | Nested Class, Inner Class,",NA,NA
Local Class & Anonymous Class,NA,NA
6.1 | Nested Class,"• A class can be nested within another class.
  
 • Nested class can also be defined within abstract classes and interfaces.
  
 1 
 class
  SomeClass
  {
  
 2 
 class
  NestedClass
 {
  
 3 
  
 fun
  doNestedThing
 () {println(
 ""SomeClass.NestedClass.doNestedThing()""
 )}
  
 4 
 }
  
 5 
 }
  
 6 
 interface
  SomeInterface
  {
  
 7 
 class
  NestedClass
 {
  
 8 
  
 fun
  doNestedThing
 () {
  
 9 
  
 println(
 ""SomeInterface.NestedClass.doNestedThing()""
 )
  
 10 
  
 }
  
 11 
  
 }
  
 12 
  
 }
  
 • A nested class can be instantiated as following:
  
 1 
 fun
  main
 () {
  
 2 
 SomeClass.Nested().doNestedThing()
  
 3 
 SomeInterface.Nested().doNestedThing()
  
 4 
 }",NA
6.2 | Inner Class,"• Inner class is nested class marked with
  inner
 .
  
 • Inner classes can access member of outer class instances.",NA
6.3 | Local Class,"• Local class is an inner class defined within a function or constructor scope.
  
 1 
 class
  SomeClass
  {
  
 2 
 val
  name:String =
  ""SomeClass""
  
 3
  
 4 
 constructor
 (){
  
 5
  
 6 
  
 class
  InnerClass
 {
  
 7 
  
 fun
  doInnerThing
 () { println(
 ""$name.constructor""
 ) }
  
 8 
  
 }
  
 9 
  
 InnerClass().doInnerThing()
  
 10 
  
 }
  
 11 
  
 fun
  doSomething
 (){",NA
6.4 | Anonymous Class,"• Abstract classes and interfaces are not instantiable by themselves.
  
 • Abstract classes and interfaces are usually extended to create a reusable imple-
  
 mentation i.e. classes.
  
 • Anonymous inner classes can be used to create an implementation of an abstract
  
 classes or interfaces.
  
 • Anonymous inner class instances can be created using
  object
  expressions.
  
 1 
 interface
  EventHandler
 {
  
 2 
 fun
  handle
 ()
  
 3 
 }
  
 4
  
 5 
 class
  EventListener
  {
  
 6 
 fun
  listen
 (eventHandler: EventHandler){
  
 7 
 eventHandler.handle()
  
 8 
 }
  
 9 
 }
  
 10
  
 11 
  
 fun
  main
 () {
  
 12 
  
 EventListener().listen(
 object
  :
  EventHandler
  {
  
 13 
  
 override fun
  handle
 (){
  
 14 
  
 println(
 ""Handling event...""
 )
  
 15 
  
 }
  
 16 
  
 })
  
 17 
  
 }",NA
"CHAPTER 7 | Data Classe, Enum Class,",NA,NA
"Sealed Class, Inline Class",NA,NA
7.1 | Data Class,"• Data classes are mainly created to hold data.
  
 • Usually such kind of classes are called model class, POJO in Java, or value object.
  
 •
  data
  keyword is used to mark a class as a data class.
  
 1 
 data class
  DataClass
 (
 val
  id:Int,
  val
  name: String)
  
 • Data class should have at least one parameter in the primary constructor.
  
 • Parameters in the primary constructor need to be marked as
  val
  or
  var
  
 •
  abstract
 ,
  open
 ,
  sealed
  &
  inner
  keyword are not allowed with
  data class
 .
  
 • Data classes can inherit from other classes.
  
 • Compiler will auto implement
  toString()
 ,
  equals()
 ,
  hasCode()
 ,
  copy()
  &
  componentN()
  
 toString()
  
 •
  toString()
  function is auto generated for data classes.
  
 • Parameters inside the primary constructor is used in the generated
  toString()
  
 function.
  
 1 
 data class
  DataClass
 (
 val
  id:Int =
  0
 ,
  val
  name: String =
  ""SomeName""
 )
  
 2
  
 3 
 fun
  main
 () {
  
 4 
 println(DataClass())
  
 5 
 println(DataClass(
 1
 ))
  
 6 
 println(DataClass(
 1
 ,
  ""AnotherName""
 ))
  
 7 
 }
  
 Output:
  
 1 
 DataClass(id=
 0
 , name=SomeName)
  
 2 
 DataClass(id=
 1
 , name=SomeName)
  
 3 
 DataClass(id=
 1
 , name=AnotherName)",NA
copy(),"•
  copy()
  generate a copy of an existing object with ability to change some of its
  
 properties.",NA
7.2 | Enum Class,"• Enum classes are used to define a set of named
  type-safe
  constants.
  
 • Each constant is an instance of the enum class.
  
 • Enum classes can be declared using
  enum
  keyword.
  
 1 
 enum class
  Color
  {
  
 2 
  
 RED, YELLOW, BLUE
  
 3 
 }
  
 1 
 val
  color:Color = Color.BLUE
  
 • Enum classes can have properties, functions and implement interfaces.
  
 1 
 interface
  Painter
 {
  
 2 
 fun
  paint
 ()
  
 3 
 }
  
 4 
 enum class
  Color
 (
 val
  hex:String) : Painter {
  
 5 
 RED(
 ""#FF0000""
 ),
  
 6 
 YELLOW(
 ""#FFFF00""
 ),
  
 7 
 BLUE(
 ""#0000FF""
 );
  
 8
  
 9
  
 }
  
 override fun
  paint
 (){ println(
 ""painting...""
 )}
  
 10
  
 • Enum constants can have properties and functions defined within anonymous
  
 classes.",NA
Using,values(),NA
 &,"valuesOf()
  
 • You can use
  values()
  to get the list of enum constants.
  
 • To get an enum constant by its name use
  valueOf()
  
 1 
 enum class
  Color
 (
 val
  hex:String) {
  
 2 
 RED(
 ""#FF0000""
 ){
  
 3 
  
 override fun
  paint
 () { println(
 ""painting RED...""
 )}
  
 4 
 },
  
 5 
 YELLOW(
 ""#FFFF00""
 ){
  
 6 
  
 override fun
  paint
 () { println(
 ""painting YELLOW...""
 )}
  
 7 
 },
  
 8 
 BLUE(
 ""#0000FF""
 ){
  
 9 
  
 override fun
  paint
 () { println(
 ""painting BLUE...""
 )}
  
 10 
  
 };
  
 11
  
 12
  
 }
  
 abstract fun
  paint
 ()
  
 13
  
 14
  
 15 
  
 fun
  main
 () {
  
 16 
  
 Color.values().forEach(Color
 ::
 paint)
  
 17 
  
 println(Color.valueOf(
 ""RED""
 ))
  
 18 
  
 }",NA
Generic way,enumValues<T>(),NA
 &,"enumValueOf<T>()
  
 •
  enumValues<T>()
  is a generic verion of
  values()
  
 •
  enumValueOf<T>()
  is a generic verion of
  valueOf()
 .",NA
 &,"name
  
 • Enum classes have two default properties
  ordinal
  &
  name
 •
  
 name
  returns constant name.
  
 •
  ordinal
  returns constant position.
  
 1 
 fun
  main
 () {
  
 2 
 enumValues<Color>().forEach {
  
 3 
 println(
 ""position: ""
 +it.ordinal +
 "" - name: ""
 +it.name)
  
 4 
 }
  
 5 
 }",NA
7.3 | Sealed Class,"• A sealed class can be used to define an exclusive set of classes extending this
  
 sealed class.
  
 • In other words, having a limited set of classes extending the sealed class.• The 
 limitation can be ensured by defining the set of classes in the same file where 
  
 the 
 sealed class is declared.
  
 • Sealed class is declared using
  sealed
  keyword.
  
 • A sealed class is abstract and can have abstract members.
  
 1 
 // in the same file
  
 2 
 sealed class
  SealedClass
  
 3 
 data class
  SomeClass
 : Expr()
  
 4 
 object
  someObject
  : Expr()",NA
Enum Class vs. Sealed Class,"• Enum class has a set of constant objects which are instances of the enum class.• 
 Sealed class has a set of subclasses which can be used to generate multiple instances.",NA
7.4 | Inline Class,NA,NA
 experimental,"• Inline class creates a wrapper around other type without runtime overhead.• 
 Inline class is declared using
  inline
  keyword.
  
 • Inline class must have a single property in the primary constructor.",NA
CHAPTER 8 | Object Expression and,NA,NA
Declarations & Companion objects,NA,NA
8.1 | Object Expression,"• Object expression allow creating an object without declaring a class or subclass.
  
 1 
 fun
  main
 () {
  
 2
  
 3 
 val
  obj =
  object
  {
  
 4 
  
 val
  id:Int =
  0
  
 5 
  
 val
  name:String =
  ""ObjectName""
  
 6 
 }
  
 7
  
 8
  
 }
  
 println(obj.name)
  
 9
  
 • Also, it can be used to create an object of anonymous class.
  
 1 
 interface
  A
  {
  fun
  call
 () }
  
 2
  
 3 
 fun
  main
 () {
  
 4
  
 5 
 val
  obj =
  object
  :
  A
  {
  
 6 
  
 val
  id:Int =
  0
  
 7 
  
 val
  name:String =
  ""ObjectName""
  
 8
  
 9
  
 }
  
 override fun
  call
 (){
  
 10
  
 println(
 ""calling...""
 )
  
 11
  
 }
  
 12
  
 }
  
 13
  
 obj.call()
  
 14
  
 • Object created using object expression can be used in local and private declara-
  
 tions.
  
 • The actual type of anonymous object will be declared supertype or
  Any
  if used as
  
 return type of
  public
  function or
  public
  property.
  
 • Object expressions can access variables from the outer enclosing scope.",NA
8.2 | Object Declarations,"• Object declarations enable us to declare a
  named
  object without declaring a
  
 class.
  
 • This is useful to declare singletons.
  
 •
  object
  to declare object keyword can be used just like
  var
  and
  val
  do for variables
  
 declare.
  
 • Declared object is singleton so it cannot be local.
  
 1 
 object
  obj
  {
  
 2 
 fun
  call
 (){
  
 3 
 println(
 ""calling""
 )
  
 4 
 }
  
 5 
 }
  
 6
  
 7 
 fun
  main
 () {
  
 8 
 obj.call()
  
 9 
 }",NA
8.3 | Companion Objects,"•
  companion
  keyword can be used for object declaration inside a class.
  
 • Members of the companion object can be called using class name.",NA
CHAPTER 9 | Delegation & Property,NA,NA
Delegation,NA,NA
9.1 | Delegation,"• Usually, inheritance is a common solution to code reusability. Extending class
  
 implementation will allow subclasses to reuse implemented functions and prop-
  
 erties.
  
 • Delegation design pattern, provides an alternative solution to inheritance using
  
 object composition.
  
 • In Kotlin a class can delegate the implementation of an interface to
  specified
  
 object
  instead of explicitly implementing the abstract members.
  
 • Kotlin provides support for this pattern by generating all interface members that
  
 delegate to the
  specified object
 .
  
 • To better understand the idea let us assume that we have two display
  
 modes for an application, dark mode
  DarkMode
  and light mode
  LightMode
 .
  
 Each mode is implementing an interface
  Mode
 .
  
 • Now, if we want to build a
  custom
  dark mode that inherits some func-
  
 tionalities from the
  original
  dark mode, we can simply extend
  DarkMode
  
 and then override members that need to be customized.
  
 • However, if we need to do the same thing for the light mode, we will end
  
 up creating two new custom modes or subclasses.
  
 • To avoid extending many classes, delegation can come into rescue.
  
 • Instead of using inheritance to solve this problem we can use delegation
  
 pattern to achieve the same goal in a cleaner way using composition.
  
 • We will create one custom mode class
  MyCustomMode
  that implements
  Mode
  
 interface but delegates the implementation of the abstract members to
  
 an object which is also a of type
  Mode
 .
  
 • The delegate object is passed to
  MyCustomMode
  as a parameter.
  
 • Kotlin provides a keyword
  by
  to define a delegate.
  
 1 
 interface
  Mode
 {
  
 2 
 val color
 :
 String
  
 3 
 fun
  display
 ()
  
 4 
 }
  
 5
  
 6 
 class
  DarkMode
 (
 override val color
 :
 String
 ) :
  Mode
 {
  
 7 
 override fun
  display
 (){
  
 8 
  
 println
 (
 ""Dark Mode...""
 +
 color
 )
  
 9 
 }
  
 10 
  
 }",NA
 interface memeber,"• Delegating class can
  override
  abstract members of the interface which is already 
  
 implemented in the delegate object.
  
 • Note that delegate object does not have access to the overridden members in 
  
 the delegating class.
  
 1 
 fun
  main
 () {
  
 2 
 val darkMode
  =
  DarkMode
 (
 ""BLACK""
 )
  
 3 
 val lightMode
  =
  LightMode
 (
 ""WHITE""
 )
  
 4
  
 5 
 val myCustomMode
  =
  MyCustomMode
 (
 lightMode
 )
  
 6 
 myCustomMode
 .
 display
 ()
  // Light Mode...WHITE
  
 7
  
 8
  
 }
  
 println
 (
 myCustomMode
 .
 color
 )
  // CUSTOM_COLOR
  
 9",NA
9.2 | Delegated Properties,"• Kotlin supports delegated properties which delegate some common actions 
  
 executed upon getting or setting properties values.
  
 • Some common use cases include computing property value upon first access, 
  
 observing property change and storing properties in a map.
  
 •
  by
  keyword is used for property delegation.
  
 • The
  delegate
  has to provide
  getValue()
  function for
  val
  &
  var
  properties and 
  
 setValue()
  function for
  var
  properties.
  
 •
  getValue()
  will be called every time a property value is retrieved, while
  setValue() 
  
 will be called every time the property value is set.
  
 •
  getValue(thisRef:Any?, 
  
 property:KProperty<*>): 
  
 T
 , takes two parameters. First 
  
 one is
  this
  object which contains the property we are reading. The second 
  
 parameter is a metadata about the property such as property name. The function 
  
 returns object of the property type.
  
 •
  setValue(thisRef: 
  
 Any?, 
  
 property: 
  
 KProperty<*>, 
  
 value: 
  
 String)
  takes three 
  
 parameters. The the first two are similar to the
  getValue()
  parameters. The third 
  
 parameter is the valued assigned to the property.",NA
9.3 | Standard Delegates,NA,NA
Lazy,"•
  lazy()
  is a function that takes a lambda and return a delegate which is an instance
  
 of
  Lazy<T>
 .
  
 •
  lazy()
  is used to implement lazy property, the first call to
  get()
  execute the
  
 lambda passed to
  lazy()
  function and store the value.
  
 • Subsequent calls to
  get()
  returned the stored value.
  
 1 
 fun
  main
 () {
  
 2 
 println
 (
 lazyProperty
 )
  
 3 
 println
 (
 lazyProperty
 )
  
 4 
 }
  
 5
  
 6 
 val lazyProperty
 :
  String by lazy
  {
  
 7 
 println
 (
 ""first call""
 )
  
 8 
 ""I am Lazy!""
  
 9 
 }
  
 Output:
  
 1 
 first call
  
 2 
 I am Lazy!
  
 3 
 I am Lazy!",NA
Observable,"•
  Delegates.observable()
  takes two parameters: initial value and handler.
  
 • The handler is called every time the property is set.
  
 • The handler has three parameters: the property, old value and new value.
  
 1 
 import
  kotlin.properties.Delegates
  
 2 
 fun
  main
 () {
  
 3 
 SomeClass
 ().
 observableProperty
  =
  ""bar""
  
 4 
 }
  
 5
  
 6 
 class
  SomeClass
 {
  
 7 
 var observableProperty
 :
  String by Delegates
 .
 observable
 (
 ""foo""
 ) {
  
 8 
  
 prop
 ,
  old
 ,
  new
  ->
  println
 (
 ""old value: $old -> new value: $new""
 )
  
 9 
 }
  
 10 
  
 }
  
 Output:",NA
Storing properties in a map,"• A property can delegate to a
  Map
 .
  
 • Delegated properties takes their values from this map.
  
 • for
  var
  property use
  MutableMap
  
 1 
 fun
  main
 () {
  
 2 
 val someClass
  =
  SomeClass
 (
 mapOf
 (
 ""name""
  to
  ""Marko""
 ,
  ""id""
  to
  1 ))
  
 3 
 println
 (
 someClass
 .
 name
 )
  // print Marko
  
 4 
 }
  
 5
  
 6 
 class
  SomeClass
 (
 val map
 :
  Map
 <
 String
 ,
  Any
 ?>){
  
 7 
 val id
 :
  Int 
  
 by map
  
 8 
 val name
 :
  String by map
  
 9 
 }",NA
CHAPTER 10 | Extensions,"• Inheritance allow us to extend a given class with new functions and properties
  
 in new subclasses.
  
 • Kotlin, however, provides a different extension mechanism which enables us
  
 to extend the original class with new functions and properties without using
  
 inheritance.
  
 • So, classes that we have or don’t have access to their source code can be
  
 extended with extension functions and properties.
  
 • Functions and properties added using extension are accessible in the same way
  
 as if they were members of the original class.",NA
10.1 | Extension Functions,"• To add an extension function to a given class, we add the class name before the
  
 function.
  
 • For example, below we are adding a new function
  print()
  to
  String
  class.
  
 1 
 fun String
 .
 print
 (){
  
 2 
 println
 (
 this
 )
  
 3 
 }
  
 • Now, this
  print()
  function is available to any string object.
  
 1 
  
 ""Hello, world!!!""
 .
 print
 ()
  
 - Extension functions of a superclass will be available to subclasses.
  
 1 
  
 open
  class
  Parent
  
 2 
 class
  Child
  :
  Parent
 ()
  
 3
  
 4 
 fun Parent
 .
 print
 () {
  println
 (
 ""Parent""
 ) }
  
 5
  
 6 
 fun
  main
 () {
  
 7 
 Child
 ().
 print
 ()
  // print Parent
  
 8 
 }
  
 - Extension functions are dispatched statically, that means the static type of the
  
 receiver object is used to call the function not the type evaluated at runtime.
  
 • Below,
  obj
  type is
  Parent
 , so
  Parent.print()
  will be called.",NA
10.2 | Extension Properties,"• Properties can also be added to a class using extension.
  
 • Extension properties must have accessors or be abstract.
  
 • Extension properties do not have backing field. So, the property cannot hold a
  
 value.
  
 1 
 class
  Class
 {
  
 2 
 var _id
 :
 Int
  = 0
  
 3 
 }
  
 4
  
 5 
 var Class
 .
 id
 :
 Int
  
 6 
  
 get
 () =
  _id
  
 7 
  
 set
 (
 value
 ) {
  _id
  =
  value
  }
  
 8
  
 9 
 fun
  main
 () {
  
 10 
  
 val clazz
  =
  Class
 ()
  
 11 
  
 clazz
 .
 id
  = 5
  
 12 
  
 print
 (
 clazz
 .
 id
 )
  
 13 
  
 }",NA
10.3 | More about Extension,"• Companion object can also have its own extension function and properties.
  
 • Extensions should be imported if declared outside the calling package.
  
 • Extensions can be declared inside a class for other classes. Qualified
  this
  can be
  
 used to resolve naming conflict if exist.
  
 • Extensions declared as a member inside a class can be overridden in subclass if
  
 marked as
  open
  
 • Extensions cannot access
  private
  members of its receiver.",NA
CHAPTER 11 | Generics,NA,NA
11.1 | Generic Classes,"• Kotlin classes can take generic type parameters.
  
 • The actual type of this parameter can be specified when an instance is created.
  
 1 
 class
  Container
 <T>(
 val
  t: T){
  /* ... */
  }
  
 • To create an instance of classes with generic type, we need to provide the type
  
 of generic parameter.
  
 • If the type can be inferred we may omit the parameterization
  <T>
 .
  
 1 
 val
  container = Container<SomeClass>(SomeClass())
  
 2
  
 3 
 val
  otherContainer = Container(SomeClass())
  // type is inferred
  
 in",NA
 and,"out
  
 • We know that assigning an object of a certain type to a reference of its supertype
  
 is allowed.
  
 1 
 interface
  Shape
  
 2 
 class
  Circle
  : Shape
  
 3 
 class
  Rectangle
  : Shape
  
 4
  
 5 
 val
  shape: Shape = Circle()
  // this is OK
  
 • However, assigning a class with generic parameter of a subtype to a reference
  
 with generic parameter of a supertype is not allowed.
  
 1 
 // this is NOT OK
  
 2 
 val
  contShape:Container<Shape> = Container<Circle>(Circle())
  
 • To resolve this issue Kotlin introduced
  declaration-site variance
 .
  
 • Simply we annotate the generic type parameter
  T
  with
  out
  modifier.
  
 • However, the class with the
  <out T>
  can’t have a member that consume
  T
 , for
  
 example a member method cannot take T as parameter.
  
 • Members of class
  Container<out T>
  can only return
  T
 .",NA
11.2 | Generic Functions,"• Functions can take generic type parameters and also return generic type.
  
 1 
 interface
  Shape
  
 2 
 class
  Circle
  : Shape
  
 3 
 class
  Rectangle
  : Shape
  
 4
  
 5 
 fun
  <
 T
 : Shape> generic(t:T): T{
  
 6 
 return
  t
  
 7 
 }
  
 8
  
 9 
 fun
  main
 () {
  
 10 
  
 generic(Circle())
  
 11 
  
 }",NA
11.3 | Generic Constraints,"• Generic type can berestricted by generic constraints.
  
 • An upper bound can be specified on generic type so that only subtypes can be
  
 used for generic type.
  
 • The upper bound is specified inside the angle brackets as following.
  
 1 
 fun
  <
 T
 : Shape> generic(t:T){ }
  
 • If more than one upper bound is needed we can use
  where
  clause.
  
 1 
 fun
  <
 T
 > generic(t:T): T
  where
  
 2 
  
 T: Shape,
  
 3 
  
 T: Any?
  
 4 
 {
  return
  t }",NA
CHAPTER 12 | Functions and Lambdas,NA,NA
12.1 | Functions Basics,"•
  fun
  keyword is used to declare a function.
  
 1 
 fun
  foo
 (){
  
 2 
 println(
 ""foo is called...""
 )
  
 3 
 }
  
 • A declared function is called by its name.
  
 • Functions declared within a class are called using dot notation.
  
 1
  
 fun
  main
 () {
  
 // dot notation
  
 2
  
 foo()
  
 3
  
 SomeClass().doSomething()
  
 4
  
 }
  
 5
  
 6 
 class
  SomeClass
 {
  
 7 
  
 fun
  doSomething
 (){
  
 8 
  
 println(
 ""doing something...""
 )
  
 9 
 }
  
 10 
  
 }",NA
Function parameters,"• Functions can have parameters.
  
 • Parameters’ types should be declared explicitly.
  
 1 
 fun
  sum
 (a: Int, b: Int) { println(a+b) }
  
 • Parameters can have default values.
  
 • Parameters with default values can be omitted when calling the function or
  
 overridden with new values.
  
 • Default values should be omitted when overriding the function.",NA
Variable number of arguments,"vararg
  
 • A function can have a variable number of arguments using
  vararg
 .
  
 • Only one parameter can be marked as
  vararg
 .
  
 •
  vararg
  is normally the last function parameter. If not, then other parameters
  
 should be passed as named argument.
  
 •
  vararg
  arguments can be passed one-by-one, or as an array with
  spread
  operator
  
 *
 .",NA
Single-expression functions,"• Function returning single expression can omit curly braces
  {}
  and define the body 
  
 after
  =
 .
  
 • Return type can be omitted too.
  
 1 
 fun
  sum
 (x: Int, y:Int): Int = x + y",NA
Return type,"• A function return type is
  Unit
  if it does not return useful value.
  
 • Function returning
  Unit
  can optionally omit the return type.
  
 • Kotlin does not infer return types for functions with block bodies.
  
 • So, unless returning
  Unit
 , all function with block bodies shold always sepcify in 
  
 the return type.
  
 infix",NA
 Function,"• Member functions and extension functions with a single parameter that is NOT 
  
 varage
  and has no default value can be makred as
  infix
 .
  
 • Function marked with
  infix
  keyword can be called using infix notation.
  
 • Infix notation all calling a function without dot or parentheses.
  
 •
  this
  should be used explicitly when infix function is called within current object.",NA
Function Scope,"• Function in Kotlin can be declared as a top level in a file which requires no class.
  
 • Member functions & extension functions are called on their receiver only.
  
 • Local functions are nested function.
  
 1 
 fun
  topLevel
 () { println(
 ""Top level...""
 )}
  
 2
  
 3 
 class
  SomeClass
  {
  
 4 
  
 fun
  member
 () {
  
 5 
  
 print(
 ""Member calls ""
 )
  
 6 
  
 topLevel()
  
 7
  
 8 
  
 fun
  local
 (){",NA
| Tail Recursive Functions,"• A recursive function is a function calling itself.
  
 • Tail recursive is special case of recursion where the last action of a function is a
  
 call to itself.
  
 • Tail recursive function are avoiding the risk of stack overflow.
  
 • A Recursive function marked as
  tailrec
  and meeting the conditions of tail
  
 recursive function is converted by the compiler into an optimized loop-based
  
 version.
  
 1 
 fun
  main
 () {
  
 2 
 println(sum(
 5
 ))
  
 3 
 }
  
 4
  
 5 
 // sum(N) sums first N integers e.g. sum(3) = 1 + 2 + 3
  
 6 
 tailrec fun
  sum
 (x:Int, total:Int =
  0
 ):Int
  
 7 
 =
  if
 (x ==
  0
 ) total
  else
  sum(x-
 1
 , total+x)",NA
12.2 | Function Types & Higher-Order Functions,"• In Kotlin, functions can be stored in variables, passed as arguments to another
  
 function and returned from other functions.
  
 • The question now is, how to declare the type of the variable storing a function?",NA
Function types,"• Function types is way to define the type of a function using its parameters and
  
 return type.",NA
Higher-order functions,"• Higher-order functions can take functions as parameters or return a function.• The 
 type of the parameter accepting the function or the return type is declared 
  
 using
  
 function type
 .
  
 • The
  compare
  function below takes two variable and a function as parameters.",NA
Instantiating a function type,"1
  
 • Similar to class type, function type can be instantiated.
  
 • There are serval ways to create an instance of a function type.• For 
 example to pass an instance of function type
  (Int, 
  
 Int)
  
 ->
  
 compare()
  function “declared above”, we can use the follwoing ways:- 
 Lambda
  {a, b -> a > b}
  
 Boolean
  to
  
 compare(
 2
 ,
 3
 , {a, b -> a > b})
  
 - Anonymous function
  fun(a:Int, b:Int):Boolean = a > b
  
 1 
 compare(
 2
 ,
 3
 ,
  fun
 (a:Int, b:Int):Boolean{
  return
  a > b})
  
 - Callable reference
  ::gt
  
 1 
 fun
  gt
 (a: Int, b: Int): Boolean = a > b
  
 2 
 compare(
 2
 ,
 3
 ,
  ::
 gt)
  
 - Instance of a class implementing a function type
  
 1 
 class
  GreaterThan
 : (Int, Int) -> Boolean {
  
 2 
  
 override operator fun
  invoke
 (a: Int, b:Int) = a > b
  
 3 
 }
  
 4
  
 5 
 compare(
 2
 ,
 3
 , GreaterThan())",NA
Calling an instance of a function type,"• Instance of function type can be invoked using
  invoke(a, b, ...)
  function.
  
 • Or directly passing the parameter
  (a, b, ...)
  
 • For receiver type, the receiver should be the first argument.",NA
12.3 | Lambdas,"• Lambda is a literal function which means it is not declared but passed as an
  
 expression.
  
 • Lambda expression is always surrounded by curly braces
  {...}
  
 • Parameters types are optional.
  
 • Lambda’s body goes after the arrow
  ->
 .
  
 1 
 val
  sum: (Int, Int) -> Int = {a:Int, b:Int -> a + b}
  
 • Which can be written without parameter types.
  
 1 
 val
  sum: (Int, Int) -> Int = {a,b -> a + b}
  
 • Equivalent function
  
 1 
 fun
  sum
 (a:Int , b:Int) = a + b
  //equivalent function",NA
Trailing Lambda,"• If lambda is passed as the last parameter of a function, then lambda can be
  
 placed outside the function parentheses, this is know as
  trailing lambda
 .
  
 1 
 fun
  compare
 (a:Int, b:Int, f: (Int, Int) -> Boolean): Boolean{
  
 2 
 return
  f(a,b)
  
 3 
 }
  
 • Normal way",NA
Lambda with single paramete,"• Lambda with single parameter can be written in a shorter way. Omit the single
  
 parameter, the arrow
  ->
  and use
  it
  as a reference to the single paramter.
  
 1 
 fun
  isEven
 (a:Int, f: (Int) -> Boolean):Boolean{
  
 2 
 return
  f(a)
  
 3 
 }
  
 • Normal way
  
 1 
 isEven(4){ a -> a % 2 == 0}
  
 • Using
  it
  
 1 
 isEven(4){ it % 2 == 0}",NA
Lambda qualified return,"• Lambda returns from the enclosing function.
  
 • By default, the last expression of a lambda is implicitly returned.
  
 • Explicit return should be qualified
  return@label
  
 1 
 //implicit return
  
 2 
 isEven(
 4
 ){ it %
  2
  ==
  0
 }
  
 3
  
 4 
 //explicit return
  
 5 
 isEven(
 4
 ){
  return
 @isEven (it %
  2
  ==
  0
 )}",NA
Unused parameter,"_
  
 • If the function type takes unused parameter, we can replace them with
  _",NA
Destructuring in Lambdas,"• Lambda parameter with appropriate
  componentN
  function can be destructed using
  
 destructuring declaration.
  
 1 
 data class
  SomeClass
 (
 val
  id:String,
  val
  name:String)
  
 2
  
 3 
 fun
  print
 (c: SomeClass, f: (SomeClass) -> String){
  
 4 
 println(f(c))
  
 5 
 }
  
 6
  
 7 
 fun
  main
 () {
  
 8 
 print(SomeClass(
 ""2""
 ,
 ""John""
 ), { c ->
  ""id: ${c.id} - name: ${c.name}""
 })
  
 9
  
 10 
  
 // using destructuring declaration
  
 11 
  
 print(SomeClass(
 ""2""
 ,
 ""John""
 ), { (id, name) ->
  ""id: $id - name: $name""
 })
  
 12
  
 13 
  
 }
  
 Output:
  
 1 
 id
 : 2 -
  name
 :
  John
  
 2 
 id
 : 2 -
  name
 :
  John",NA
Anonymous functions,"• Anonymous function is a regular function without a name.
  
 1 
 fun
 (x: Int, y: Int): Int = x + y",NA
12.4 | Inline Functions,"• Using Lambda in higher-order functions give us abstraction but introduce run-
  
 time overhead.
  
 • inlining a function using
  inline
  keyword, eliminate runtime overhead imposed by
  
 higher-order functions.
  
 • For example, the function below is a non-inlined higher-order function.",NA
Enforcing,"noinline
  
 • If a function is marked as
  inline
 , we still can enforce no-inlining of a lambda
  
 function using
  noinline",NA
|,reified,NA
 &,"inline
  
 • Generic type T is not accessible in the body of a generic function because it’s
  
 only available at compile time but erased at runtime.
  
 • If you create an
  inline
  function with a
  reified
  T though, the type of T can be
  
 accessed even at runtime.
  
 1 
 class
  Class
  
 2
  
 3 
 inline fun
  <
 reified
  T> chekcType(p: Any): Boolean {
  
 4 
 return
  (p
  is
  T)
  
 5 
 }
  
 6
  
 7 
 fun
  main
 () {
  
 8 
 println(chekcType<Class>(Class()))
  // true
  
 9 
 }",NA
CHAPTER 13 | Collections & Sequences,"• Collection is a data structure that contains a number of objects of the same type.• 
 Object in a collection is called an element or item.
  
 • Kotlin Standard Library provides comprehensive set of tools for managing 
  
 collections.
  
 • Kotlin Standard Library offers generic interfaces, classes,
  
 and functions for creating, populating, and managing collections of any type.",NA
13.1 | Collection,"•
  Collection<T>
  is an interface representing a supertype in collection hierarchy.•
  
 Collection<T>
  is a read-only collection interface.
  
 •
  List
  &
  Set
  are subtypes of
  Collection<T>
 .",NA
| Collection Types,"•
  List
  
 - Ordered elements by indices
  
 - Elements can occur more than once.
  
 •
  Set
  
  
 - Collection of unique elements.
  
  
 - Order is not important
  
 •
  Map
  
  
 - A set of key-value pairs.
  
 - Key is unique and map to one value.
  
 - Values can be duplicates.
  
 -
  Map
  is NOT subtype of
  Collection<T>",NA
Read-only vs. Mutable Collection,"• Each type of collection has
  read-only
  and
  mutable
  version.•
  
 read-only
  for accessing collection elements.
  
 •
  mutable
  for reading and modifying collection elements.",NA
Creating Collection,"• A collection can be created by instantiating an implementation of collection such 
  
 as
  ArrayList
 ,
  HashSet
 ,
  HashMap
 , …
  
 • A more convenient way is using Kotlin STD functions
  listOf<T>
 ,
  SetOf<T>
 ,
  mapOf<K,V>
 , 
  
 mutableListOf<T>
 ,
  mutableSetOf<T>
  and
  mutableMap<K,V>
 .
  
 • There are also functions for creating empty collections:
  emptyList()
 ,
 emptySet() 
  
 and
  
 emptyMap()
 .",NA
Copying,"• Collection copying functions, such as
  toList()
 ,
  toMutableList()
 ,
  toSet()
 .",NA
13.2 | Iterations,"• Iterators are used to sequentially traverse elements of collections.
  
 •
  Iterable<T>
  interface defines functions for iterating elements.
  
 •
  Collection<T>
  and its sub-types such as
  List
  and
  Set
  are inheriting from
  Iterable<T>
  
 • Iterators can be obtained by calling
  iterator()
  function.
  
 • Obtained iterator is pointing to first element in the collection.
  
 •
  next()
  function retrieve current element and move pointer to next.
  
 1 
 fun
  main
 () {
  
 2 
 val
  list = listOf(
 1
 ,
 2
 ,
 3
 )
  
 3 
 val
  map = mapOf(
 1
  to
  ""one""
 ,
  2
  to
  ""two""
 )
  
 4
  
 5 
 val
  listIterator = list.iterator()
  
 6 
 val
  mapIterator = map.iterator()
  
 7
  
 8 
 while
 (listIterator.hasNext())
  
 9 
  
 println(listIterator.next())
  
 10
  
 11
  
 }
  
 while
 (mapIterator.hasNext())
  
 12
  
 println(mapIterator.next().value)
  
 13
  
 Output:",NA
13.3 | Sequences,"• Sequences are another type of elements container.
  
 • Sequences works like iterable but with different processing approach.
  
 1 
 val
  numbersSequence = sequenceOf(
 1
 ,
 2
 ,
 3
 ,
 4
 )
  
 • The first difference between iterables and sequences is that iterables are exe-
  
 cuted eagerly, they complete and return results.
  
 • In contrast, sequences are executed lazily i.e. actual calling to operations
  
 happens only when the result is requested.",NA
Creating a Sequence,"• Using
  sequenceOf()",NA
13.4 | Collection Operations,"• Kotlin provides built-in functions to perform operations on collections.
  
 • These operations may include filtering a collection, transforming collection content 
 into different types, sorting, grouping or simply retrieving a single element.
  
 • Some of the common operations are explained next.",NA
Retrieving Single Elements,"•
  elementAt()
  function retrieves an element at specific position from
  List
  and
  Set
 .•
  get()
  
 and
  []
  operators can also be used to access
  List
  elements at specific 
  
 position.
  
 •
  Map
  elements are retrieved by key using
  get(key)
 ,
  [key]
  or
  getValue(key)
  which 
  
 unlike 
 first two will throw exception if key not found.
  
 •
  getOrElse()
  can be used with
  List
  and
  Map
  where value of non-existent elemement 
  
 is returned from lambda.",NA
Retrieving collection parts,"• Parts of a collection can be retrieved using element indices or size of wanted
  
 parts.
  
 •
  slice()
  function returns a list of elements with given indices.
  
 •
  slice()
  throws an exception if an index is out of bound.
  
 1 
 val
  list = listOf(
 1
 ,
 5
 ,
 3
 ,
 4
 ,
 2
 )
  
 2 
 println(list.slice(
 0.
 .
 2
 ))
  // [1, 5, 3]
  
 3 
 println(list.slice(setOf(
 0
 ,
 2
 )))
  //[1,3]
  
 •
  List
  provides
  subList(s,e)
  function to retrieve parts by indices.
  
 1 
 val
  list = listOf(
 1
 ,
 5
 ,
 3
 ,
 4
 ,
 2
 )
  
 2 
 println(numbers.subList(
 0
 ,
  2
 ))
  // [1, 5]
  
 •
  take(n)
  returns
  n
  elements starting from the first one.
  
 •
  takeLast(n)
  returns the last
  n
  elements.
  
 •
  drop(n)
  returns all except first
  n
  elements.
  
 •
  dropLast(n)
  returns all elements except last
  n
  elements
  
 1 
 val
  list = listOf(
 1
 ,
 5
 ,
 3
 ,
 4
 ,
 2
 )
  
 2 
 println(list.take(
 2
 ))
  // [1, 5]
  
 3 
 println(list.dropLast(
 2
 ))
  // [1, 5, 3]
  
 • Taking and dropping elements can also be specified by predicates.
  
 •
  takeWhile()
  keeps taking elements from the beginning of a collection until the
  
 predicate is
  false
 .
  
 •
  takeLastWhile()
  keeps taking elements from the end of a collection until the
  
 predicate is
  false
 .
  
 •
  dropWhile()
  keeps dropping elements from the beginning of a collection until the
  
 predicate is
  false
  
 •
  dropLastWhile()
  keeps drop elements from the end of the collection until the
  
 predicate is
  false",NA
Checking existence,"•
  contains()
  function checks if a collection include an element.
  
 •
  in
  operator works like
  contains()
  
 • To test the existence of more than one elements use
  containsAll()
  
 •
  isEmpty()
  and
  isNotEmpty()
  are used to check if the collection has any element.",NA
Filtering,"•
  filter()
  is the most used function for filtering a collection.
  
 •
  filter()
  takes a lambda as a filtering condition “predicate” and returns collection
  
 matching the condition.
  
 • Since
  filter()
  takes a lambda of a single parameter we can implicitly reference
  
 it using
  it
  which is a reference to the element.
  
 1
  
 val
  list = listOf(
 1
 ,
 2
 ,
 3
 ,
 4
 )
  
 >
  2
  }
  
 2
  
 val
  filtered = list.filter{ it
  
 3
  
 println(filtered)
  // [3, 4]
  
 •
  filterNot()
  is used to return the elements not matching the predicate.
  
 1
  
 val
  list = listOf(
 1
 ,
 2
 ,
 3
 ,
 4
 )
  
 >
  2
  }
  
 2
  
 val
  filtered = list.filterNot{ it
  
 3
  
 println(filtered)
  // [1, 2]
  
 •
  filterIndexed()
  gives you access to element index.
  
 1 
 val
  list = listOf(
 1
 ,
 2
 ,
 3
 ,
 4
 )
  
 2 
 val
  filtered = list.filterIndexed{ index, value -> index >
  1
  && value <
  4
 }
  
 3 
 println(filtered)
  // [3]",NA
Partitioning,"• Filters only return matching or not matching elements. But what if we want to
  
 return both?!
  
 •
  partition()
  is a way to partition a collection of elements into two separate
  
 collections.
  
 • The return type is
  Pair
  of
  List
  one for matching elements and one for not
  
 matching ones.",NA
Testing predicates,"• Sometimes we want to test if one, all or no elements in a collection matching a
  
 given predicate.
  
 • To test such cases, Kotlin provides
  any()
 ,
  none()
  and
  all()
  functions.
  
 •
  any()
  function returns true if at least one element matches the predicate.
  
 •
  none()
  function returns true if all elements are NOT matching the predicate.
  
 •
  all()
  function returns true if all elements are matching the predicate.
  
 1 
 fun
  main
 () {
  
 2 
  
 val
  list = listOf(
 1
 ,
 2
 ,
 3
 ,
 4
 )
  
 3 
  
 println(list.any{ it 
  
 >
  4
  })
  // false
  
 4 
 println(list.none{ it 
  
 >
  4
  })
  // true
  
 5 
 println(list.all{ it 
  
 >
  4
  })
  // false
  
 6 
 }
  
 plus",NA
 and,minus,NA
 Operators,"• A handy way to add or remove an element or collection of elements from a
  
 collection is by using
  +
  and
  -
  operators.
  
 • However, the result of adding or subtracting elements is a new
  read-only
  
 collection.
  
 • The second operand can be a single element or a collection.
  
 • When second operand is a collection, all occurrences of matching elements are
  
 removed.
  
 1 
 val
  list = listOf(
 1
 ,
 5
 ,
 3
 ,
 4
 ,
 3
 )
  
 2
  
 3 
 list +
  2
  // [1, 5, 3, 4, 3, 2] 2 added
  
 4 
 list -
  3
  // [1, 5, 4, 3] one ""3"" removed
  
 5 
 list - listOf(
 3
 )
  // [1, 5, 4] all ""3""s removed",NA
Mapping,"• Mapping takes elements of an existing collection, transforms them and produce
  
 a new collection.
  
 • The transformation is defined using lambda function.
  
 •
  map()
  takes a lambda that uses element as single parameter to apply mapping.
  
 •
  mapIndexed()
  takes a lambda with element value and index passed as parameters.",NA
Zipping,"• Zipping takes elements with the same position from two collections and build a
  
 pair out of them.
  
 • The result of zipping is a list of elements of type
  Pair
 .
  
 •
  zip()
  can be called as
  infix
  function.
  
 1 
 val
  num = listOf(
 1
 ,
 2
 ,
 3
 ,
 4
 )
  
 2 
 val
  str = listOf(
 ""one""
 ,
  ""two""
 ,
  ""three""
 )
  
 3
  
 4 
 num.zip(str)
  // [(1, one), (2, two), (3, three)]
  
 5 
 num zip str
  // [(1, one), (2, two), (3, three)]
  
 •
  zip()
  can take a lambda that take two elements as parameters. The result in this
  
 case is a list of the returned type.
  
 1 
 num.zip(str){ n, s -> s.toUpperCase()+
 "":""
 +n}
  // [ONE:1, TWO:2, THREE:3]
  
 • Unzipping is also allowed for a list of
  Pair
 s.
  
 •
  unzip()
  returns two lists from the original list.",NA
Association,"• Association is a way to build a map from a collection and associated values.•
  
 associateWith()
  creates
  Map
  where the collection elements are the keys.
  
 •
  associateBy()
  creates
  Map
  where the collection elements are the values.
  
 •
  associate()
  allowing creating a Map where keys and values can be produced from 
  
 the collection.
  
 1 
 val
  list = listOf(
 ""one""
 ,
  ""two""
 ,
  ""three""
 ,
  ""four""
 )
  
 2 
 println(list.associateWith { it.first().toUpperCase() })
  
 3 
 println(list.associateBy { it.first().toUpperCase() })
  
 4 
 println(list.associate{n-> Pair(n.toUpperCase(), n)})
  
 Output:
  
 1 
 {one=O, two=T, three=T, four=F}
  
 2 
 {O=one, T=three, F=four}
  
 3 
 {ONE=one, TWO=two, THREE=three, FOUR=four}",NA
Flattening,"• Flattening takes a collection of collections and return a single list of elements.•
  
 flatten()
  function extracts elements from nested collections into a single list.
  
 1 
 val
  sets = listOf(setOf(
 1
 ,
  2
 ), setOf(
 3
 ,
  4
 ), setOf(
 1
 ))
  
 2 
 println(sets.flatten())
  // [1, 2, 3, 4, 1]
  
 • To map elements of nested collection before flattening use
  flatMap()
  
 1
  
 println(sets.flatMap{s -> s.map{ it *
  2
  }})
  
 // [2, 4, 6, 8, 2]",NA
Grouping,"• Grouping return a map of grouped elements.
  
 • Keys are the lambda results while values are the matching list of elements.•
  
 groupBy()
  function takes a lambda that is applied on each element.
  
 • The result of the lambda is a key.
  
 • Elements returning the same key are grouped together.
  
 •
  groupBy()
  function can take a second lambda parameter that transform elements 
  
 values.",NA
Ordering,"Comparable
 ,
  Comparator
  and
  compareBy()
  
 • Collection element should implement
  Comparable
  interface to define ordering
  
 logic.
  
 • Most built-in types are implementing
  Comparable
 .
  
 • User defined class should implement
  Comparable
  to define a natural order.",NA
Aggregation,"• Aggregate operations return a single value from a collection.
  
 • Some common operations are
  sum()
 ,
  min()
 ,
  max()
 ,
  average()
 ,
  count()
  
 1 
 val
  list = listOf(
 1
 ,
  5
 ,
  3
 ,
  4
 ,
  2
 )
  
 2
  
 3 
 println(
 ""Sum: ${list.sum()}""
 )
  // Sum: 15
  
 4 
 println(
 ""Count: ${list.count()}""
 )
  // Count: 5
  
 5 
 println(
 ""Max: ${list.max()}""
 )
  // Max: 5
  
 6 
 println(
 ""Average: ${list.average()}""
 )
  // Average: 3.0
  
 Fold & reduce
  
 •
  fold()
  and
  reduce()
  are generic aggregation functions that can be used to define
  
 a custom aggregate operation.
  
 • Both functions take a lambda as an operation. The operation takes two argu-
  
 ments, accumulated value and current element.
  
 •
  fold()
  works like
  reduce()
  except that
  fold(n)
  takes an initial value.",NA
Write Operations,"• Mutable collection can be changed by adding, removing and updating elements.
  
 Adding elements
  
 •
  add()
  add an element to
  List
  or
  Set",NA
CHAPTER 14 | Coroutines,"• Coroutines are light-weight threads that enable you to write asynchronous code
  
 in a sequential style.
  
 • Kotlin Coroutines is not part of the standard library.
  
 •
  kotlinx-coroutines-core
  should be added as a dependency to your project.",NA
14.1 | Blocking vs. non-Blocking,"• A blocking call to a function will block the parent thread until the function is
  
 complete.
  
 1 
 fun
  main
 (){
  
 2 
 runForever()
  // this function blocks the thread forever!
  
 3 
 println(
 ""Hello!""
 )
  // not reachable line!
  
 4 
 }
  
 5
  
 6 
 fun
  runForever
 (){
  
 7 
 while
  (
 true
 ){ }
  
 8 
 }
  
 • On the other hand, calling a non-block function on a thread does not necessarily
  
 block that thread. It can be delegated to another thread in case of heavy oper-
  
 ation or it can suspend its execution when e.g. waiting for a result. Suspension
  
 will free the thread for other function.
  
 1 
 fun
  main
 (){
  
 2
  
 3 
 thread {
  
 4 
  
 runForever()
  // running on different thread so main is not blocked
  
 5 
 }
  
 6
  
 7
  
 }
  
 println(
 ""Hello!""
 )
  // ""Hello!"" will be printed!
  
 8
  
 9
  
 10 
  
 fun
  runForever
 (){
  
 11 
  
 while
  (
 true
 ){ }
  
 12 
  
 }",NA
14.2 | Coroutine Basics,"• Coroutines are light-weight threads running in a context
  CoroutineContext
  of
  
 some
  Coroutine Scope
 .",NA
Coroutine scope,"•
  Coroutine Scope
  specifies the lifetime of the coroutines.
  
 •
  Coroutine Scope
  is used to start a coroutine.
  
 •
  GlobalScope
  is a coroutine scope which runs on the whole application lifetime.",NA
Coroutine builders,"•
  Coroutine builders
  are functions used to run coroutines.
  
 •
  launch()
 ,
  async()
  &
  runBlocking
  are coroutine builder provided by Kotlin.
  
 •
  launch()
  function returns an object of type
  Job
  that can be used to cancel the
  
 running coroutine.
  
 1 
 import
  kotlinx.coroutines.*
  
 2
  
 3 
 fun
  main
 (){
  
 4 
 val
  job = GlobalScope.launch { 
  
 // GlobalScope
  
 5 
  
 runForever()
  // blocking funcion
  
 6 
  
 println(
 ""Me Too!""
 ) 
  
 // will NOT be printed
  
 7 
 }
  
 8
  
 9
  
 println(
 ""Hello!""
 )
  
 // will be printed
  
 10
  
 11 
  
 }
  
 12
  
 13 
  
 fun
  runForever
 (){
  
 14 
  
 while
  (
 true
 ){ }
  
 15 
  
 }",NA
Suspending Function,"• Suspending functions are regular functions marked with
  suspend
 .
  
 • Suspending functions may suspend the execution of the current coroutine but
  
 does not necessary block the thread.
  
 • Suspending functions do NOT have special return types.
  
 • Suspending functions should be called only from a coroutine or another suspend
  
 function.",NA
CoroutineDispatcher,"• Coroutine context include a coroutine dispatcher.
  
 • Coroutine dispatcher specifies the thread or threads used by a coroutine for its
  
 execution.
  
 • Dispatcher can be explicitly specified by an optional parameter of type
  CoroutineContext
  
 passed to coroutine builder such as
  launch()
  and
  async()
  
 • Kotlin provides standard implementation for
  CoroutineDispatcher
  
 -
  Dispatchers.Default
 : is the default dispatcher is used by coroutine builders if
  
 no dispatcher is specified. Also, default dispatcher is the appropriate choice for
  
 heavy operations that consume CPU resources.
  
 -
  Dispatchers.IO
  is used for IO intensive blocking operations.
  
 -
  Dispatchers.Main
  is used to run a coroutine on the main thread.
  
 1 
 import
  kotlinx.coroutines.*
  
 2 
 fun
  main
 () = runBlocking{
  // this: CoroutineScop
  
 3
  
 4 
 val
  job = launch {Dispatchers.Default 
  
 // launch a coroutine
  
 5 
  
 runForever()
  // when suspends, anther coroutine will run
  
 6 
 }
  
 7 
 launch {Dispatchers.Main 
  
 // launch another coroutine in Main thread
  
 8 
  
 println(
 ""Me Too!""
 )",NA
