Larger Text,Smaller Text,Symbol
Kotlin Corou+nes by Tutorials,"By Filip Babić and Nishant Srivastava
  
 Copyright ©2019 Razeware LLC.",NA
No+ce of Rights,"All rights reserved. No part of this book or corresponding materials (such as text, 
 images, or source code) may be reproduced or distributed by any means without 
 prior written permission of the copyright owner.",NA
No+ce of Liability,"This book and all corresponding materials (such as source code) are provided on an “as 
 is” basis, without warranty of any kind, express of implied, including but not limited to the 
 warranties of merchantability, fitness for a particular purpose, and noninfringement. In 
 no event shall the authors or copyright holders be liable for any claim, damages or other 
 liability, whether in action of contract, tort or otherwise, arising from, out of or in 
 connection with the software or the use of other dealing in the software.",NA
Trademarks,"All trademarks and registered trademarks appearing in this book are the property of 
 their own respective owners.
  
  
 raywenderlich.com
  
 2",NA
Dedica+ons,"""To my friends and family. And mostly to my loved one. Thank you 
 for being patient and understanding, when I couldn’t grab a cup of 
 coffee or tea and catch up. Huge thanks to everyone who’s 
 supported me throughout the entire process, with positive and 
 motivational encouragement. This wouldn’t have gone as nearly as 
 smooth without you.""
  
 — 
 Filip Babić
  
 ""I would like to thank the many people who have made this book 
 possible. To my father, who gave me the desire to be a curious soul 
 and learn more. To my mom, who has supported me all along 
 whenever I have had doubts about my own 
  
 capabilities as a writer. To my friends, Saachi Chawla and Kirti 
 Dohrey, who have always believed in me during my ups and 
 downs. To people who have directly or indirectly been my mentor 
 and helped me through understanding technology at a deeper level 
 whenever I found myself stuck. And lastly, to the team at 
 raywenderlich.com, my co-author, editors and 
  
 everyone involved in making this book a reality.""
  
 — 
 Nishant Srivastava
  
  
  
 raywenderlich.com
  
 3",NA
About the Authors,"Nishant Srivastava
  is an author on this book. Nishant is a 
  
 Sr.Android Engineer at Soundbrenner in Berlin, Germany and an 
 open source enthusiast who spends his time doodling when not 
 hacking on Android. He is a caffeine-dependent life-form and can be 
 found either talking about android libraries or advocating that coffee 
 is the elixir of life at community gatherings. He has been part of two 
 startups in the past (Founding Team Member at 
  
 OmniLabs, Inc. and one of the first employees at Silverpush) with 
 experience in Android SDK Engineering and Audio Digital Signal 
 Processing(DSP) on Android. While working at his past company 
 (Silverpush), he developed the company’s patented UAB (Unique 
 Audio Beacon) Technology.
  
  
 Filip Babić
  is an author of this book. He is an experienced Android 
 developer from Croatia, working at the Five Agency, building world-
 known applications, such as the RosettaStone language-learning 
 application and AccuWeather, the globally known weather reporting 
 app. Previously he worked at COBE d.o.o., a German-owned mobile 
 agency, which is partners with the biggest German 
  
 media company. He's enthusiastic about the Android ecosystem, 
 focusing extensively on applying Kotlin to Android applications, and 
 building scalable, testable and user-friendly applications. Passionately 
 building up good spirit in local development groups in Croatia, focusing 
 on lectures, education, and engagement of new, aspiring developers in 
 the Croatian IT community. But also pursuing global conferences, 
 meetups, and IT fests. Altruistic when it comes to consulting and 
 mentoring, trying to give help to 
  
 everyone, whenever possible, motivated by the ideology that the 
 Android ecosystem we live in is only as good as we make it.
  
  
 raywenderlich.com
  
 4",NA
About the Editors,"Eric Crawford
  is a technical editor of this book. Eric is a Senior 
 Software Developer at John Deere, where he bounces between iOS and 
 Android development. Before coming to Deere he did freelance mobile 
 development and serverside web development utilizing Java. In his free 
 time he likes to dabble into other platforms like IOT and cloud 
 computing.
  
 Kevin Moore
  is a technical editor for the book. He has been 
 developing Android apps for over 9 years and at many companies. 
  
 He's written several articles at www.raywenderlich.com and created 
 the ""Programming in Kotlin"" video series. He enjoys creating apps for 
 fun and teaching others how to write Android apps.In addition to 
 programming, he loves playing Volleyball and 
  
 running the sound system at church.
  
  
 Massimo Carli
  is the final pass editor of this book. Massimo has been 
 working with Java since 1995 when he co-founded the first Italian 
 magazine about this technology (http://www.mokabyte.it). After many 
 years creating Java desktop and enterprise application, he started to 
 work in the mobile world. In 2001 he wrote his first book about J2ME. 
 After many J2ME and Blackberry applications, he 
  
 then started to work with Android in 2008. The same year he wrote the 
 first Italian book about Android; best seller on Amazon.it. That was the 
 first of a series of 8 books. he worked at Yahoo and 
  
 Facebook and he's actually Engineering Tech Lead at Lloyds. He's a 
 musical theatre lover and a supporter of the soccer team S.P.A.L.",NA
About the Ar+st,"who creates illustrations, game art and a lot of other art or design 
  
 work for the tutorials and books on raywenderlich.com. When she’s 
  
 not making art, she loves hiking, a good glass of wine and",NA
Table of Contents: Overview,NA,NA
What You Need,NA,NA
..............................................................................,NA,NA
13,NA,NA
Book License,NA,NA
...................................................................................,NA,NA
14,NA,NA
Book Source Code & Forums,NA,NA
......................................................,NA,NA
15,NA,NA
Book Updates,NA,NA
..................................................................................,NA,NA
17,NA,NA
About the Cover,NA,NA
.............................................................................,NA,NA
18,NA,NA
IntroducLon,NA,NA
.....................................................................................,NA,NA
19,NA,NA
Sec+on I: Introduc+on to ,NA,NA
Corou+nes,NA,NA
.........................,NA,NA
21,NA,NA
Chapter 1: What Is Asynchronous Programming?,NA,NA
.......,NA,NA
23,NA,NA
Chapter 2: SeSng Up Your Build Environments,NA,NA
..........,NA,NA
39,NA,NA
Chapter 3: GeSng Started with CorouLnes,NA,NA
.................,NA,NA
52,NA,NA
Chapter 4: Suspending FuncLons,NA,NA
....................................,NA,NA
65,NA,NA
Chapter 5: Async/Await,NA,NA
.....................................................,NA,NA
83,NA,NA
Chapter 6: CorouLne Context,NA,NA
.......................................,NA,NA
104,NA,NA
Chapter 7: CorouLne Contexts & Dispatchers,NA,NA
..........,NA,NA
110,NA,NA
Chapter 8: ExcepLon Handling,NA,NA
......................................,NA,NA
120,NA,NA
Chapter 9: Manage CancellaLon,NA,NA
...................................,NA,NA
132,NA,NA
Sec+on II: Channels & ,NA,NA
Flows,NA,NA
......................................,NA,NA
143,NA,NA
Chapter 10: Building Sequences & Iterators with ,NA,NA
Yield,NA,NA
.....................................................................................,NA,NA
144,NA,NA
Chapter 11: Channels,NA,NA
......................................................,NA,NA
159,NA,NA
Chapter 12: Broadcast Channels,NA,NA
...................................,NA,NA
190,NA,NA
Chapter 13: Producer & Actors ......................................,NA,NA
205,"raywenderlich.com
  
 6",NA
Chapter 14: Beginning with CorouLnes Flow,NA,NA
............,NA,NA
222 ,NA,NA
235 ,NA,NA
246,NA,NA
Chapter 15: TesLng CorouLnes,NA,NA
.....................................,NA,NA
Sec+on III: Corou+nes & ,NA,NA
Android,NA,NA
.............................,NA,NA
Chapter 16: Android Concurrency Before ,NA,NA
CorouLnes .......................................................................... 247,NA,NA
Chapter 17: CorouLnes on Android - Part 1 .............. 286,NA,NA
Chapter 18: CorouLnes on Android - Part 2 .............. 309,NA,NA
Conclusion ..................................................................................... 332,"raywenderlich.com 
  
 7",NA
Table of Contents: Extended,NA,NA
What You Need,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
1,NA,NA
3,NA,NA
Book License,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
1,NA,NA
4,NA,NA
Book Source Code & Forums,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
1,NA,NA
5,NA,NA
Book Updates,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
1,NA,NA
7,NA,NA
About the Cover,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
1,NA,NA
8,NA,NA
IntroducLon,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
1,NA,NA
9,"About Kotlin
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 19
  
 About CorouLnes
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 19
  
 How to read this book
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 20",NA
Sec+on I: Introduc+on to Corou+nes,NA,NA
. . . . . . . . . . . . ,NA,NA
2,NA,NA
1,NA,NA
Chapter 1: What Is Asynchronous Programming?,NA,NA
. . . . . . . . . ,NA,NA
2,NA,NA
3,"Providing feedback
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 23
  
 Why mulLthreading?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 25
  
 InteracLng with the UI thread from the background
  
 . . . . . . . . . . . . . . 
  
 26
  
 Handling work compleLon using callbacks
  
 . . . . . . . . . . . . . . . . . . . . . . 
  
 30
  
 IndentaLon hell
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 31
  
 Using reacLve extensions for background work
  
 . . . . . . . . . . . . . . . . . . 
  
 32
  
 Diving deeper into the complexity of Rx
  
 . . . . . . . . . . . . . . . . . . . . . . . . 
  
 34
  
 A blast from the past
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 35
  
 Explaining corouLnes: The inner works
  
 . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 35
  
 VariaLons through history
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 36
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 37
  
 Where to go from here?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 38",NA
Chapter 2: SeSng Up Your Build Environments,NA,NA
. . . . . . . . . . ,NA,NA
3,NA,NA
9,"Choosing the build environments
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 39
  
 Installing the IntelliJ IDEA
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 40
  
  
 raywenderlich.com
  
 8",NA
Chapter 3: GeSng Started with CorouLnes . . . . . . . . . . . . . . 52,"ExecuLng rouLnes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
  
 Launching a corouLne . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
  
 Building corouLnes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
  
 Explaining jobs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
  
 Canceling Jobs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
  
 Digging deeper into corouLnes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
  
 PosLng to the UI thread . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
  
 Key points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
  
 Where to go from here? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64",NA
Chapter 4: Suspending FuncLons . . . . . . . . . . . . . . . . . . . . . . . 65,"Suspending vs. non-suspending 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
  
 ElaboraLng conLnuaLons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
  
 CreaLng your own suspendable API . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
  
 Key points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
  
 Where to go from here? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82",NA
Chapter 5: Async/Await . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83,"The async/await padern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
  
 Learning from the past . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
  
 Using async/await . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
  
 Deferring values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
  
 Combining mulLple deferred values . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
  
 Being cooperaLve and structured . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
  
 Key points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
  
 Where to go from here? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103",NA
Chapter 6: CorouLne Context . . . . . . . . . . . . . . . . . . . . . . . . 104,"raywenderlich.com 
  
 9",NA
Chapter 7: CorouLne Contexts & Dispatchers,NA,NA
. . . . . . . . . . ,NA,NA
110,"Work scheduling
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 110
  
 CorouLne dispatcher types
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 114
  
 Using dispatchers
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 116
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 119",NA
Chapter 8: ExcepLon Handling,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
120,"ExcepLon propagaLon
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 120
  
 Handling excepLons
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 121
  
 Callback wrapping
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 128
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 131
  
 Where to go from here?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 131",NA
Chapter 9: Manage CancellaLon,NA,NA
. . . . . . . . . . . . . . . . . . . . . . ,NA,NA
132,"Cancelling a corouLne
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 132
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 141
  
 Where to go from here?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 142",NA
Sec+on II: Channels & ,NA,NA
Flows,NA,NA
. . . . . . . . . . . . . . . . . . . ,NA,NA
14,NA,NA
3,NA,NA
Chapter 10: Building Sequences & Iterators with Yield,NA,NA
. . . ,NA,NA
144,"GeSng started with sequences
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 144
  
 Enter: Sequence
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 147
  
 Generators and Sequences
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 150
  
 SequenceScope is here to stay
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 152
  
 Yield and YieldAll at your service
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 153
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 157
  
 Where to go from here?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 158",NA
Chapter 11: Channels,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
159,"GeSng started with channels
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 160
  
  
 raywenderlich.com
  
 10",NA
Chapter 12: Broadcast Channels . . . . . . . . . . . . . . . . . . . . . . 190,"GeSng started with broadcast channels . . . . . . . . . . . . . . . . . . . . . . . 191
  
 ConflatedBroadcast channel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
  
 ReacLveX vs. BroadcastChannel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
  
 Key points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
  
 Where to go from here? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204",NA
Chapter 13: Producer & Actors ,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . 205,"Producing and consuming data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
  
 Producer-consumer problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
  
 AcLng upon data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
  
 Key points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
  
 Where to go from here? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221",NA
Chapter 14: Beginning with CorouLnes Flow ,NA,NA
. . . . . . . . . . . 222,"Streams of data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
  
 LimitaLons of streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
  
 A new approach to streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
  
 Flow Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
  
 Key Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232",NA
Chapter 15: TesLng CorouLnes . . . . . . . . . . . . . . . . . . . . . . . 235,"GeSng started . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
  
 WriLng tests for CorouLnes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
  
 SeSng up the test environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
  
 Summing it up 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
  
 raywenderlich.com 
  
 11",NA
Sec+on III: Corou+nes & ,NA,NA
Android,NA,NA
. . . . . . . . . . . . . . . ,NA,NA
24,NA,NA
6,NA,NA
Chapter 16: Android Concurrency Before CorouLnes,NA,NA
. . . . ,NA,NA
247,"GeSng started
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 248
  
 Does Android need corouLnes?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 250
  
 CorouLnes
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 280
  
 Introducing Anko
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 282
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 283
  
 Where to go from here?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 285",NA
Chapter 17: CorouLnes on Android - Part 1,NA,NA
. . . . . . . . . . . . ,NA,NA
286,"GeSng started
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 287
  
 What’s in the context?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 291
  
 ConverLng exisLng API call to use corouLnes
  
 . . . . . . . . . . . . . . . . . . 
  
 298
  
 CorouLnes and Android lifecycle
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 301
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 308
  
 Where to go from here?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 308",NA
Chapter 18: CorouLnes on Android - Part 2,NA,NA
. . . . . . . . . . . . ,NA,NA
309,"GeSng started
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 310
  
 Debugging corouLnes
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 312
  
 ExcepLon handling
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 315
  
 Don’t forget tesLng
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 320
  
 Anko: Simplified corouLnes
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 327
  
 Key points
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 330",NA
Conclusion,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
332,"raywenderlich.com
  
 12",NA
W,"To follow along with this book, you'll need the following:
  
 •
  IntelliJ IDEA Community Edition 2019.1.x
 : Available at https:// 
  
 www.jetbrains.com/idea/. This is the environment in which you'll develop most of 
 the sample code in this book.
  
 •
  Jave SE Development Kit 8.
 : Most of the code in this book will be run on the Java 
 Virtual Machine or JVM, for which you need a Java Development Kit or JDK. The JDK can 
 be downloaded from Oracle at http://www.oracle.com/technetwork/java/ 
 javase/downloads/index.html.
  
 •
  Android Studio 3.x.
 : For the examples about Android described in Section 3, you 
  
 can use the IDE available at https://developer.android.com/studio/.
  
 If you haven't installed the latest versions of IntelliJ IDEA Community Edition and JDK 8, 
 be sure to do that before continuing with the book. Chapter 2: ""Setting Up Your Build 
 Environments"" will show you how to get started with IntelliJ IDEA to run Kotlin 
 coroutines code on the JVM.
  
  
 raywenderlich.com
  
 13",NA
L,NA,NA
Book License,"By purchasing 
 Kotlin Coroutines by Tutorials
 , you have the following license:
  
 • You are allowed to use and/or modify the source code in 
 Kotlin Coroutines by 
  
 Tutorials
  in as many apps as you want, with no attribution required.
  
 • You are allowed to use and/or modify all art, images and designs that are included in 
 Kotlin Coroutines by Tutorials
  in as many apps as you want, but must include this 
 attribution line somewhere inside your app: “Artwork/images/designs: from 
 Kotlin 
 Coroutines by Tutorials
 , available at www.raywenderlich.com.”
  
 • The source code included in 
 Kotlin Coroutines by Tutorials
  is for your personal use only. 
 You are NOT allowed to distribute or sell the source code in 
 Kotlin Coroutines by 
 Tutorials
  without prior authorization.",NA
B,NA,NA
Book Source Code & ,NA,NA
If you bought the digital edi+on,"The digital edition of this book comes with the source code for the starter and 
 completed projects for each chapter. These resources are included with the digital 
 edition you downloaded from 
 store.raywenderlich.com
 .",NA
If you bought the print version,"You can get the source code for the print edition of the book here:
  
 https://store.raywenderlich.com/products/kotlin-coroutines-by-tutorials-source-
 code",NA
Forums,"We’ve also set up an official forum for the book at 
 forums.raywenderlich.com
 . This is a 
 great place to ask questions about the book or to submit any errors you may find.",NA
Digital book edi+ons,"We have a digital edition of this book available in both ePUB and PDF, which can be 
 handy if you want a soft copy to take with you, or you want to quickly search for a 
 specific term within the book.
  
 Buying the digital edition version of the book also has a few extra benefits: free updates 
 each time we update the book, access to older versions of the book, and you can 
 download the digital editions from anywhere, at anytime.
  
  
 raywenderlich.com
  
 15",NA
B,NA,NA
Book Updates,"Since you’ve purchased the digital edition version of this book, you get free access to any 
 updates we may make to the book!
  
 The best way to get update notifications is to sign up for our monthly newsletter. This 
 includes a list of the tutorials that came out on raywenderlich.com that month, any 
 important news like book updates or new books, and a list of our favorite iOS 
 development links for that month. You can sign up here:
  
 •
  www.raywenderlich.com/newsletter",NA
A,NA,NA
About the Cover,"It would be difficult to think of an animal that cooperates more effectively and 
 asynchronously with others of its kind than a bee. Beyond that, bees famously work 
 with their environment to keep entire natural ecosystems and man-made industries 
 thriving. Their community and industry has been well documented and celebrated 
 throughout time, with references by philosopher Aristotle, economic theorist Karl Marx 
 and even comedian Jerry Seinfeld.
  
 Like the coroutines explored in this book, the various 16,000 known species of bees live 
 harmoniously in their intricate colonies — an elegant network of productivity and 
 execution of duties.
  
 Developers can easily take great insight from the bee, working to architect code in an 
 asynchronous way in which each part plays a critical role to contribute to the overall 
 success of the project at hand.",NA
I,NA,NA
Introduc+on,"Coroutines with Kotlin represents one of the most interesting and fasinating challenges 
 in the software engineering world. It’s an opportunity to implement complex concurrent 
 tasks in an elegant and performant way. Reading this book will give you the opportunity 
 to learn the basic concepts about multithreading and how concurrent programming can 
 be simplified using Kotlin and Coroutines.",NA
About Kotlin,"Kotlin is a general purpose, open source, statically typed “pragmatic” programming 
 language for the JVM that combines object-oriented and functional programming 
 features. It originated at JetBrains, the company that drives IntelliJ IDEA, and has been 
 open source since 2012.",NA
About Corou+nes,"Asynchronous programming is often tedious and error-prone. The extensive usage of 
 callbacks makes the code hard to read, debug and test. Coroutines define a different 
 paradigm which introduces the concept of suspending functions. Coroutines
  
  
 raywenderlich.com
  
 19",NA
How to read this book,"This book contains four sections.
  
 The first section is an introduction to multithreading and concurrent programming with 
 Kotlin. It explains how you can execute asynchronous tasks using the Kotlin language, 
 what problems you may face and how coroutines can be a valid solution. You'll be 
 introduced to the fundamental concepts of suspending functions, coroutine context and 
 dispatching. You'll also learn how to manage exception and how to handle errors with 
 coroutines.
  
 The second section explains, in detail and with several examples, how to use very 
 important API based on coroutine technology. You'll learn how to create sequences and 
 iterators. Using channels, you'll learn how different coroutines can communicate and 
 exchange data in thread safe way. Finally you'll learn all the details about coroutine flow 
 which are a fundamental part of the last version.
  
 In the first two sections, you learned everything about coroutines. If you need some 
 specific knowledge about how to use them in the Android environment, this is the 
 section for you. You’ll create a complete Android application and you’ll see how to use 
 coroutines in order to create a very responsive application.
  
 Kotlin can be used on JVM but also in other enviroments; this is called 
  
 multiplatform. In this forth section you'll learn how to use coroutine with other 
 languages like Java.
  
 The best way to learn about Kotlin Coroutines is to roll up your sleeves and start 
 coding. Enjoy the book!
  
  
 raywenderlich.com
  
 20",NA
Sec+on I: Introduc+on to ,NA,NA
Corou+nes,"In the first chapter, you’ll learn about the problems related to multithreading and how 
 coroutines can be an elegant solution. After setting up your development environment in 
 IntelliJ or Android Studio, you’ll start writing your first coroutine to understand what 
 suspending functions are and how to define them. You’ll finish this section learning how 
 to use 
 async
  and 
 await
  functions for efficient use of resources.
  
 •
  Chapter 1: What Is Asynchronous Programming?
 : In this very first chapter, you’ll 
 learn what asynchronous programming means and why a modern developer should 
 understand it. You’ll see the basics of multithreading like queue and shared memory, 
 and you’ll understand how to solve the ""Indentation Hell Problem.""
  
 •
  Chapter 2: Setting Up Your Build Environments
 : Learning through example is one 
 of the most efficient ways to gain more skills. To do this, you need to set up your build 
 environment and learn how to load the starting projects with IntelliJ or Android 
 Studio. This chapter describes all you need to start writing your code.
  
 •
  Chapter 3: Getting Started with Coroutines
 : This is the chapter where you’ll learn 
 the main concepts about coroutines like builders, scope and context. You’ll see for the 
 first time the Job object and learn how to manage dependencies between coroutines. 
 You’ll understand and write code to manage one of the most important features of 
 asynchronous tasks: cancellations.
  
 •
  Chapter 4: Suspending Functions
 : To understand how to use coroutines, you need to 
 learn what a suspending function is and how to implement it. In this chapter, you’ll 
 learn all you need to create and use your suspending functions. You’ll also learn how 
 to change your existing functions to use them in a coroutine.
  
 •
  Chapter 5: Async/Await
 : In multithreading and asynchronous development in Java, 
 you often use Runnable, Callable and Future. With coroutines, you can use Deferred 
 instead. These are objects that you can manage using the async/await functions. In 
 this chapter, you’ll write code to understand when and how to use this pattern most 
 effectively.
  
  
 raywenderlich.com
  
 21",NA
1 ,NA,NA
Programming?,NA,NA
Chapter 1: What Is ,NA,NA
Asynchronous ,"The 
 UI (user interface)
  is a fundamental part of almost every application. It’s what 
 users see and interact with in order to do their tasks. More often than not, 
  
 applications do 
 complex work
 , such as talking to external services or processing data 
 from a database. Then, when the work is done, they show a 
 result
 , mostly in some form 
 of a message.
  
 The UI must be 
 responsive
 . If the work at hand takes a lot of time to complete, it’s 
 necessary to provide 
 feedback
  to the user so that they don’t feel like the application has 
 frozen, that they didn’t click a button properly — or perhaps that a feature doesn’t work 
 at all.
  
 In this chapter, you’ll learn how to provide useful information to users about what’s 
 happening in the application and what different mechanisms exist for working with 
 multiple tasks. You’ll see what problems arise while trying to do complex and long-
 running synchronous operations and how asynchronous programming comes to the 
 rescue.
  
 You’ll start off by analyzing the flow of a function that deals with data processing and 
 provides feedback to the user.",NA
Providing feedback,"Suppose you have an application that needs to upload content to a network. When the 
 user selects the Upload button, loading bars or spinners appear to indicate that 
 something is ongoing and the application hasn’t stopped working. This information is 
 crucial for a good user experience since no one likes unresponsive applications.
  
  
 raywenderlich.com
  
 23",NA
Blocking calls,"Chapter 1: What Is Asynchronous Programming?
  
 A 
 blocking call
  is essentially a function that only returns when it has completed. In the 
 example above, 
 showLoadingSpinner()
  prevents the upload of an image because it keeps 
 the 
 main thread
  of execution busy until it returns. But when it returns (because 
 running
  
 becomes 
 false
 ), the spinner stops rotating.
  
 So how can you solve this problem and animate the spinner even while the 
 upload 
 function is executing?
  
 Simply put, you need additional threads on which to execute your long-running 
 tasks.
  
 The 
 main thread
  is also known as the 
 UI thread
 , because it’s responsible for rendering 
 everything on the screen, and this should be 
 the only thing it does
 . This means that it 
 should manage the rotation of the spinner but not the upload of the image — that has 
 nothing to do with the UI. But if the 
 main thread
  cannot do this because that isn’t its 
 job, what can execute the upload task? Well, quite simply, you need 
 a new thread
  on 
 which to execute your long-running tasks!
  
 Computers nowadays are far more advanced than they were 10 or 15 years ago. Back in 
 the day computers could only have one thread of execution making them freeze up  if 
 you tried to do multiple things at once. But because of technological 
  
 advancements, your applications support a mechanism known as 
 multi-threading
 . 
  
 It’s the art of having multiple threads, where each can process a piece of work, 
 collectively finishing the needed tasks.",NA
Why mul+threading?,"There’s always been a hardware limit on how fast computers could be — that’s not 
 really about to change. Moreover, the number of operations a single processor in a 
 computer can complete is reaching the law of diminishing returns.
  
 Because of that, technology has steered in the direction of increasing the number of 
 cores each processor has, and the number of threads each core can have running 
 concurrently
 . This way, you could logically divide any number of tasks between 
 different threads, and the cores could prioritize their work by organizing them. And, by 
 doing so, multithreading has drastically improved how computer systems optimize 
 work and the speed of execution.
  
  
 raywenderlich.com
  
 25",NA
Comparing the main and worker threads,"The 
 main thread
 , or the 
 UI thread
 , is the thread responsible for managing the UI. 
  
 Every application can only have one main thread in order to avoid a classical problem 
 called 
 deadlock
 . This can happen when many threads access the same resources — in 
 this case, UI components — in a different order. The other threads, which are not 
 responsible for rendering the UI, are called 
 worker threads
  or 
 background threads
 . 
 The ability to allow the execution of multiple threads of control is called 
 multithreading
 , and the set of techniques used to control their collaboration and 
 synchronization, is called 
 concurrency
 .
  
 Given this, you can rethink how 
 uploadImage()
  should work. 
  
 showLoadingSpinner()
  starts a new thread that is responsible for the rotation of the 
 spinner image, which interacts with the main thread just to notify a refresh in the UI. 
 Starting a new thread, the function is now a 
 non-blocking call
  and can return 
 immediately, allowing the image upload to start its own worker thread. When 
 completed, this background thread will notify the main thread to hide the spinner.
  
 Once the program launches a background thread, it can either forget about it or 
 expect some result. You will see how background threads process the result, and 
 communicate with the main thread, in the following section.",NA
Interac+ng with the UI thread from ,NA,NA
the background,"The upload image example demonstrates how important managing threads is. The 
 thread responsible for rotating the spinner image needs to communicate with the 
 main thread in order to refresh the UI at each frame. The worker thread is 
  
 responsible for the actual upload and needs to communicate with the UI thread which 
 handles the animation when it completes in order to stop it, and to hide the spinner. 
 All of this must happen without any type of blocks. Knowing how threads 
 communicate
  is key to achieving the full potential of concurrency.
  
  
 raywenderlich.com
  
 26",NA
Sharing data,"Chapter 1: What Is Asynchronous Programming?
  
 In order to communicate, different threads need to share data. For instance, the thread 
 responsible for the rotation of the spinner image needs to notify the main thread that a 
 new image is ready to be displayed. Sharing data is not simple, and it needs some sort of 
 synchronization, which is one of the main benefits of well written concurrency code.
  
 What happens, for instance, if the main thread receives a notification that a new image 
 is available and, before displaying it, the image is replaced? In this case, the application 
 would skip a frame and a 
 race condition
  would happen. You then need some sort of a 
 thread safe
  data structure. This means that the data structure should work correctly 
 even if accessed by multiple threads at the same time.
  
 Accessing the same data from multiple threads, maintaining the correct behavior 
 and good performance, is the real challenge of 
 concurrent programming
 .
  
 There are special cases, however. What if the data is only accessed and never updated? 
 In this case, multiple threads can read the same data without any race condition, and 
 your data structure is referred to as 
 immutable
 . Immutable objects are always thread 
 safe.
  
 As a practical example, take a coffee machine in an office. If two people shared it, and it 
 wasn’t thread safe, they could easily make bad coffee or spill it and make a mess. As 
 one person started making a mocha latte and another wanted a black coffee, they 
 would ultimately ruin the machine — or worse, the coffee.
  
  
  
 raywenderlich.com
  
 27",NA
Queues,"Threads usually communicate using 
 queues
 , and they can act on them as 
 producers 
 or 
 consumers
 . A producer is a thread that puts information into the queue, and the 
 consumer is the one that reads and uses them. You can think of a queue as a list in which 
 producers append data to the end, and then consumers read data from the top, following 
 a logic called FIFO (First In First Out). Threads usually put data into the queue as objects 
 called 
 messages
 , which encapsulate the information to share.
  
 A queue is not just a 
 container
 , but it also provides synchronization in order to allow a 
 thread to consume a message only if it is available. Otherwise, it waits if the message is 
 not available. If the queue is a 
 blocking queue
 , the consumer can block and wait for a 
 new message — or just retry later.
  
 The same can happen for the producer if the queue is full. Queues are thread safe, so it is 
 possible to have multiple producers and multiple consumers.
  
 A great real-life example of queues are fast food lines.
  
 Imagine having three lines at a fast food restaurant. The first line has no customers, so 
 the person working the line is blocked until someone arrives. The second has 
 customers, so the line is slowly getting smaller as the worker serves customers. 
 However, the last line is full of customers, but there’s no one to serve them; this, in turn, 
 blocks the line until help arrives.
  
  
  
 raywenderlich.com
  
 28",NA
Pipelines,"If you think about pipes or faucets and how they work, it’s a fairly simple concept. 
  
 When you release the pressure by turning the valve, you’re actually 
 requesting 
 water. 
 On the other side of that request, there’s a system that 
 regulates the flow
  of water. As 
 soon as you make a request, it is blocked until the water comes running — just like a 
 blocking call.
  
 The same process is used for 
 pipelines
  or 
 pipes
  in programming. There’s a pipe that 
 allows 
 streams of data
  to flow, and there are 
 listeners
 . The data is usually a stream of 
 bytes, which the listeners parse into something more meaningful.
  
 As an example, you can also think about factory lines. Just like in a factory line, if there’s 
 too much product, the line has to stop until you process everything. That is, if there’s 
 too 
 much
  data that you haven’t yet processed, the pipeline is blocked until you consume 
 some of the data and make room for more to flow. And, alternatively, if there’s not enough 
 product, the person processing it sits and waits until something comes up.
  
 In other words, if there’s 
 not enough
  data to flow — the pipe is empty — you’re 
 blocked until some data emerges. Because you’re either trying to send data to an 
 overflowed stream, or trying to get data from an empty stream, the mechanism 
 doesn’t know how to react but to block until the conditions are met.
  
  
  
 raywenderlich.com
  
 29",NA
Handling work comple+on using callbacks,"Out of all the asynchronous programming mechanisms, 
 callbacks
  are the most often 
 used. This consists of the creation of objects that encapsulate code that somebody else can 
 execute later, like when a specific task completes . This approach can also be used in real 
 life when you ask somebody to push a button when they have completed some task you 
 have assigned to them. When using 
 callbacks
 , the button is 
  
 analogous to code for them to execute; the person executing the task is a 
 non-blocking 
 function
 .
  
 How can you put some code into an object to pass around? One way is by using 
 interfaces
 . You can create the interface in this way:
  
 interface
 OnUploadCallback
  { 
  
 }
  
 fun
 onUploadCompleted
 ()
  
  
 With this, you are passing an implementation of the interface to the function that is 
 executing the long-running task. At completion, this function will invoke 
  
 onUploadCompleted()
  on the object. The function doesn’t know what that 
  
 implementations does, and it’s not supposed to know.
  
 In modern programming languages like Kotlin, which support functional 
  
 programming features, you can do the same with a 
 lambda
  expression. In the 
 previous example, you could pass the lambda to the upload function as a callback. 
  
 The lambda would then contain the code to execute when the upload task 
 completes:
  
 fun
 uploadImage
 (image: Image)
  { 
  
  
  showLoadingSpinner() 
  
  
  uploadService.upload(image) { hideLoadingSpinner() } }
  
 Looking back at the very first snippet, not much has changed. You still show a loading 
 spinner, call 
 upload()
  and hide the spinner when the upload is done. The core difference, 
 though, is that you’re not calling 
 hideLoadingSpinner()
  right after the upload. That function 
 is now part of the 
 lambda block
 , passed as a parameter to 
 upload()
 , which will be 
 executed at completion. Doing so, you can call the wrapped
  
  
 raywenderlich.com
  
 30",NA
Indenta+on hell,"Callbacks are simpler than building your own mechanisms for thread 
  
 communication. Their syntax is also fairly readable, when it comes to simple functions. 
 However, it’s often the case that you have 
 multiple function calls
 , which need to be 
 connected or combined
  somehow, mapping the results into more complex objects.
  
 In these cases, the code becomes extremely difficult to write, maintain and reason 
 about. Since you can’t return a value from a callback, but have to pass it down the 
 lambda block itself, you have to 
 nest callbacks
 . It’s similar to nesting 
 forEach
  or 
 map
  
 statements on collections, where each operation has its own ambda parameter.
  
 When nesting callbacks, or lambdas, you get a large number of braces ’
 {}
 ’, each forming a 
 local scope
 . This, in turn, creates a structure called 
 indentation hell
  — or 
 callback hell
  
 (when it’s specific to callbacks). A good example would be the fetching, resizing and 
 uploading images:
  
 fun
 uploadImage
 (imagePath: String)
  { 
  
  
 showLoadingSpinner() 
  
  
  loadImage(imagePath) { image -> 
  
  
  resizeImage(image) { resizedImage -> 
  
  
  
 uploadImage(resizedImage) { 
  
     
  hideLoadingSpinner() 
  
   
  } 
  
  
  } 
  
  
  } 
  
 }
  
  
  
 raywenderlich.com
  
 31",NA
Using reac+ve extensions for ,NA,NA
background work,"The most significant issue of a callback-based approach is passing the data from one 
 function to another. This results in 
 nested callbacks
 , which are tough to read and 
 maintain.
  
 If you think about the queues and pipes, they operate with 
 streams
  of data, wherein you 
 can 
 listen
  to the data as long as you need. Reactive extensions, or Rx, are built upon the 
 idea of having asynchronous operations wrapped up in streams of events.
  
 Rx incorporates the 
 observer pattern
  into helpful constructs. Furthermore, there are a 
 large number of 
 operators
  that extend the behavior of 
 observable streams
 , allowing 
 for clean and expressive data processing. You can 
 subscribe
  to a 
 stream of events
 , 
 map, filter, reduce and combine the events in numerous ways, as well as handle errors 
 in the entire 
 chain of operations
 , using a 
 single
  lambda function.
  
  
 raywenderlich.com
  
 32",NA
Diving deeper into the complexity of Rx,"Since this book isn’t about Rx, you’ll only have a narrow overview of its positive and 
 negative features. As seen before, Rx makes asynchronous programming clean and 
 readable. Further, in addition to the operators that allow for data processing, Rx is a 
 powerful mechanism. Moreover, the error handling concept of streams adds extra safety 
 to applications.
  
 But Rx is not perfect. It has problems like any other framework, or paradigm, some of 
 which are showing up in the programming community lately.
  
 To start, there is the learning curve. When you start learning Rx, you have to learn a 
 number of additional concepts, such as the 
 observer pattern
  and 
 streams
 . You will also 
 find that Rx is not just a framework; it brings a completely new paradigm called 
 reactive 
 programming
 . Because of this, it’s very hard to start working with Rx. But it’s even 
 harder to grasp the finesse of using its operators. The amount of 
 operators
 , types of 
 thread scheduling
 , and the combinations between the two, creates so many options that 
 it’s nearly impossible to know the full extent of Rx.
  
 Another problematic issue with using Rx is the 
 hype
 . Over the years, people have 
 moved towards Rx as a silver bullet for asynchronous operations.
  
 This eventually led to such programming being Rx-driven, introducing even more 
 complexity to existing applications. Finding workarounds and using numerous design 
 patterns, just to make Rx work, introduced new layers of unwanted 
  
 complexity. Because of this, in Android, the Rx community has been debating if 
 programmers should represent things like network requests as streams of data versus 
 just a single event that they could handle using callbacks or something even simpler.
  
 The same debate transitions to navigation events, as an example. Should 
  
 programmers represent clicks as streams of events, too? The community opinion is very 
 divided on this topic.
  
 So, with all this in mind, is there a better or simpler way to deal with asynchronicity? 
 Oddly enough, there’s a concept dating back decades, which has recently become a hot 
 topic.
  
  
 raywenderlich.com
  
 34",NA
A blast from the past,"This is a book about 
 coroutines
 . They’re a mechanism dating back to the 1960’s, 
 depicting a unique way of handling asynchronous programming. The concept 
 revolves around the use of 
 suspension points
 , 
 suspendable functions
  and 
 continuations
  as first-class citizens in a language.
  
 They’re a bit abstract, so it’s better to show an example:
  
 fun
 fetchUser
 (userId: String)
  { 
  
 val
  user = userService.getUser(userId) 
 // 1
  
  
  print(
 ""Fetching user""
 ) 
 // 2
  
  
  print(user.name) 
 // 3
  
  
  print(
 ""Fetched user""
 ) 
 // 4 
  
 }
  
 Using the above code snippet, and revisiting what you learned about blocking calls, you’d 
 say that the execution order was 
 1, 2, 3
  and 
 4
 . If you carefully look at the code, you realize 
 that this is not the only possible logical sequence. For instance, the order between 
 1
  and 
 2
  
 is not important, nor is the order between 
 3
  and 
 4
 . What is important is that the user data 
 is fetched before it is displayed; 
 1
  must happen before 
 3
 . You can also delay the fetching of 
 the user data to a convenient time before the user data is actually displayed. Managing 
 these issues in a transparent way is the black magic of 
 coroutines
 !
  
 They’re a part-thread, part-callback mechanism, which use the system’s power of 
 scheduling and suspending work. This way, you can immediately return a result from a 
 call 
 without
  using callbacks, threads or streams. Think of it this way, once you start a 
 coroutine, or call a suspendable function, it gets nicely wrapped up and prepared like a 
 taco. But, until you want to eat the taco, the code inside might not get 
  
 executed.",NA
Explaining corou+nes: The inner works,"It’s not really black magic — only a smart way of using low-level processing. 
 getUser()
  is 
 marked as a 
 suspendable function
 , meaning the system prepares the call in the 
 background, and you get an unfinished, wrapped taco. But it might not execute the 
 function yet. The system moves it to a 
 thread pool
 , where it waits for further 
 commands. Once you’re ready to eat the taco and you request the result, the program 
 can block until you get a ready-to-go snack, or suspend and wait for it within the 
 coroutine.
  
  
 raywenderlich.com
  
 35",NA
Varia+ons through history,"As mentioned, coroutines are a dated but powerful concept. Throughout the years, 
 several programming languages have evolved their versions of the implementation. 
  
 For example, in languages like Python and Smalltalk, coroutines are first-class 
 citizens, and can be used without an external library.
  
 A 
 generator
  in Python would look like this:
  
 def
 coroutine
 ()
 : 
  
  
 whileTrue
 : 
  
  
  
  value = 
 yield
  
  
  
  print(’Received a value:’, value)
  
 This code defines a function, which loops forever, listening and printing any 
 arguments you send to it. The concept of an infinite loop, which listens for data is 
 called a generator. The keyword 
 yield
  is what triggers the generator, receiving the
  
  
 raywenderlich.com
  
 36",NA
Key points,"•
  Multithreading
  allows you to run multiple tasks in parallel.
  
 •
  Asynchronous programming
  is a common pattern for thread communication.
  
 • There are different 
 mechanisms
  for sharing data between threads, some of which 
  
 are queues and pipelines.
  
 • Most mechanisms rely on a 
 push-pull
  tactic, blocking threads when there is too 
  
 much, or not enough data, to process
  
 •
  Callbacks
  are a complex, hard-to-maintain and cognitive-load-heavy mechanism.
  
 • It’s easy to reach 
 callback hell
  when doing complex operations using callbacks.
  
 •
  Reactive extensions
  provide clean solutions for data transformation, 
  
 combination and error handling.
  
  
 raywenderlich.com
  
 37",NA
Where to go from here?,"Well that was a 
 really brief
  overview of the history and theory behind asynchronous 
 programming and coroutines.
  
 If you’re excited about seeing some code and Kotlin’s coroutines, in the next section of the 
 book you’ll learn about 
 suspendable functions
  and 
 suspension points
 . Moreover, you’ll 
 see how coroutines are created in Kotlin, using 
 coroutine builders
 . 
  
 Next, you’ll build asynchronous calls, which return some data with the 
 async 
 function, 
 and see how you await the result. And, finally, you’ll learn about 
 jobs
  and their children, 
 in coroutines.
  
 You’ll cover the entire base API for Kotlin Coroutines, learn how to wrap 
  
 asynchronous calls into async blocks, how to combine multiple operations and how to 
 build Jobs which have multiple layers of coroutines.
  
 But before that, you have to set up your build environment, so let’s get going!
  
  
 raywenderlich.com
  
 38",NA
2 ,NA,NA
Build ,NA,NA
Environments,NA,NA
Chapter 2: SeWng Up Your ,"To start learning about coroutines and suspending functions, you need a place to 
 work. Throughout this book, you will utilize IntelliJ IDEA or Android Studio, which will 
 serve as workstations for all the projects and challenges of this book.
  
 Android Studio is based off of IntelliJ IDEA, so both tools will look and function 
 similarly. Once you set up a good part of the first environment, the second one 
 should be easier to do.",NA
Choosing the build environments,"IntelliJ IDEA is great when you have pure Kotlin or Java projects, but it also supports a 
 variety of plugins to those projects, like the Spring framework. Android Studio, on the 
 other hand, is the prime tool used for building Android applications, and it’s crucial for 
 the last section of this book.
  
 Since both of these tools require a Java Virtual Machine (JVM) environment, you’ll 
 have to set that up first.",NA
Configuring the Java development kit,"When writing Kotlin, you’re dependent upon the JVM and its build tools, unless you’re 
 using Kotlin/Native. This means that you have to set up the Java development Kit (JDK).
  
  
 raywenderlich.com
  
 39",NA
Installing the IntelliJ IDEA,"To work with most of the projects in this book, you’ll use IntelliJ. It’s a powerful tool 
 built by Jetbrains, and it helps with productivity using features such as smart 
 autocomplete, code and project templates, and much more.
  
  
 raywenderlich.com
  
 40",NA
Building the Android environment,"Later on in the book, you’ll work on an Android project to see how coroutines can be 
 implemented in a multi-threaded environment like Android. To do this, you first need 
 Android Studio. Android Studio is an IDE built by Jetbrains, as well.
  
 It also contains many helpful features, like autocomplete and various templates. 
 However, the main benefit is the end-to-end Android build system, powered by 
 Gradle.
  
  
 raywenderlich.com
  
 45",NA
Star+ng a new project,"You can start a new project.
  
 • Select 
 Next
  on the first step.
  
 • On the second step, where you choose the target API level, pick API 21.
  
 • Click 
 Next
 , again.
  
 • Finally, select the 
 Empty Activity
  option.
  
 • Press 
 Next
  one final time, followed by a 
 Finish
 .
  
 This should set you up with an empty Android project. You’ll find out about the 
 settings for each Android project later on in the Android section of the book.
  
 If the build system finishes without any errors, it means you have successfully 
 configured Android Studio, and you’ll be able to work on the Android section of the 
 book. Don’t worry about the time it takes for the project to build; the build system is 
 doing a lot of work, so it may take a few minutes.",NA
Impor+ng a project,"One of the things you’ll be doing in this book is importing projects. This means that 
 you’re taking in an already-built project and adding it to your workspace. After adding 
 it, the IDE builds it and connects any modules that should be connected in order for the 
 project to work.
  
 For example, if you’re importing a Gradle project, the build environment will connect the 
 scripts and load all the dependencies that you need. You’ll do this in the 
  
 following chapters, so let’s walk through an example project import.
  
 Note
 : This is just an example of what it would look like to import a project. You 
 don’t actually have this project available yet; it’s in the next chapter. You don’t 
 have to follow the steps yourself, but do remember to go back to this in case you 
 forget how to import projects in the future.
  
  
  
 raywenderlich.com
  
 47",NA
Key points,"Chapter 2: Setting Up Your Build Environments
  
 • The 
 Build environments
  that you’ll use for the book require 
 Java
 .
  
 •
  IntelliJ IDEA
  is the most popular JVM development environment, and it is 
  
 developed by Jetbrains.
  
 • IntelliJ is powered by the IntelliJ platform, enabling features such as 
  
 autocomplete
 , 
 templates
 , 
 pre-baked projects
  and many more.
  
 • For Android projects, you’ll use 
 Android Studio
 , also developed by Jetbrains.
  
 • Android Studio uses the 
 Gradle
  build system, fully integrated into every project.
  
 •
  Importing project
  connects all the gears that need to run fluently for you to 
  
 work.",NA
Where to go from here?,"Now that you have environments set up, you can finally work on projects and write 
 some Kotlin and coroutines code. Some of the chapters in the book might come with 
 starter projects, which are already set up, so you don’t have to do any extra work. Some 
 might require you to complete a challenge. Without further ado, time to start writing 
 practical code!
  
  
 raywenderlich.com
  
 51",NA
3 ,NA,NA
with ,NA,NA
Corou+nes,NA,NA
Chapter 3: GeWng Started ,"So you’ve heard a lot about working with asynchronous or concurrent programming. It’s 
 time for you to learn a bit more about coroutines and how they work in the background 
 (pun intended).
  
 In this chapter, you will:
  
 • Learn about 
 routines
  and how a program controls its execution flow.
  
 • Learn about suspendable functions and suspension points in code.
  
 •
  Launch
  your first Kotlin coroutine, creating 
 jobs
  in the background.
  
 • Practice what you’ve learned by creating a few typical tasks, including posting to 
  
 the 
 UI thread
 .
  
 Let’s get started with 
 routines
 !",NA
Execu+ng rou+nes,"Every time you start a process — launching an application, for instance — your 
 computer creates something called a 
 main routine
 . This is the core part of every 
 program because it’s where you set up and run all the other components in your code. 
 As in the most basic learning samples, you often have a 
 main
  function, which prints 
 Hello World
 . That main function is the entry point of your program and is part of the 
 main routine.
  
  
 raywenderlich.com
  
 52",NA
Launching a corou+ne,"To follow the code in this chapter, import this chapter's starter project, using IntelliJ, and 
 selecting 
 Import Project
 , and navigating to the 
 getting-started-with-
  
 coroutines/projects/starter
  folder, selecting the 
 getting_started_with_coroutines 
 project.
  
 When the project opens, locate and open 
 Main.kt
 . There, you will find the following 
 code:
  
 fun
 main
 ()
  { 
  
  
  (
 1..10000
 ).forEach { 
  
  
  GlobalScope.launch { 
  
     
 val
  threadName = Thread.currentThread().name 
  
  
  
 println(
 ""
 $it
  printed on thread 
 ${threadName}
 ""
 ) 
  
  } 
  
  
  } 
  
  
  Thread.sleep(
 1000
 ) 
  
 }
  
 Since launching your first coroutine is not 
 that
  fascinating, you’ll launch your first ten 
 thousand coroutines! Now, launching ten thousand threads is a bit tedious for a computer, 
 and most programs would get an 
 OutOfMemoryException
 . But since coroutines are 
 extremely lightweight, you’re able to launch a large number of them, without any 
 performance impact. If you run the program, you should see a lot of text, each line saying 
 which number it is printing and on which thread.
  
  
 raywenderlich.com
  
 53",NA
Building corou+nes,"You’ve heard the term 
 launching coroutines
  quite a few times now. In truth, you first 
 have to use a 
 coroutine builder
 . The Coroutines library has several coroutine builder 
 functions for you to use to start a new coroutine. In the previous example, you used 
 launch()
  with the following signature:
  
 publicfun
  CoroutineScope.
 launch
 ( 
  
  
  context: CoroutineContext = EmptyCoroutineContext, 
  
  start: 
 CoroutineStart = CoroutineStart.DEFAULT, 
  
  block: suspend 
 CoroutineScope.()
  -> 
 Unit 
  
 ): Job
  
 As you can see, 
 launch()
  has a few arguments that you can pass in: a 
  
 CoroutineContext
 , a 
 CoroutineStart
  and a lambda function, which defines what’s going to 
 happen when you launch the coroutine. The first two are optional.
  
 A 
 CoroutineContext
  is a persistent dataset of contextual information about the current 
 coroutine. This can contain objects like the 
 Job
  and 
 Dispatcher
  of the coroutine, both of 
 which you will touch on later. Since you haven’t specified 
  
 anything in the snippet above, it will use the 
 EmptyCoroutineContext
 , which points to 
 whatever context the specified 
 CoroutineScope
  uses. You can create custom contexts if 
 you’d like, but for the most part, the existing ones are sufficient.
  
  
 raywenderlich.com
  
 54",NA
Scoping corou+nes,"As you’ve learned, coroutines can be launched in parallel with the main execution of a 
 program. However, this doesn’t mean that if the main program finishes, or stops, the 
 coroutines will do the same. Or at least it didn’t in the first few versions of the API. This 
 behavior leads to subtle bugs in which applications would execute tasks even if you closed 
 the application.
  
 To mitigate these cases, the Coroutines API team created the 
 CoroutineScope
 . Each scope 
 instance knows which context it’s related to, and each scope has its own lifecycle. If the 
 lifecycle for your selected scope ends, while it’s trying to run 
  
 coroutines, all the work, even if in progress, will stop. This is why, if you try running the 
 snippet without 
 Thread.sleep
 , there may not be any output or there may be only some.
  
 Since you have to call 
 launch()
  on a 
 CoroutineScope
 , there are two ways of doing this. You 
 can use the 
 GlobalScope
 , as you did so far, not caring about where exactly the coroutine is 
 launched. Or you can implement the 
 CoroutineScope
  interface, and provide an instance of 
 the 
 CoroutineContext
  in which you’ll run coroutines. The former is easier, and it’s a great 
 option when you don’t care about coroutine results, posting to the UI thread or about the 
 job completion. The latter is crucial if you want
  
  
 raywenderlich.com
  
 55",NA
Explaining jobs,"If you’ve noticed, most things in coroutines refer to a 
 job
 , which you create and run. A 
 Job
  
 is also what 
 launch()
   returns. But what is a 
 Job
  and what can you do with it?
  
 When you 
 launch
  a coroutine, you basically ask the system to execute the code you pass 
 in, using a lambda expression. That code is not executed immediately, but it is, instead, 
 inserted into a queue.
  
 A 
 Job
  is basically 
 a handle
  to the coroutine in the queue. It only has a few fields and 
 functions, but it provides a lot of extensibility. For instance, it’s possible to introduce a 
 dependency relation between different 
 Job
  instances using 
 join()
 . If 
 Job
  A invokes 
 join()
  on 
 Job
  B, it means that the former won’t be executed until the latter has come to completion. 
 It is also possible to set up a 
 parent-child
  relation between 
 Job
  instances using specific 
 coroutine builders
 . A 
 Job
  cannot complete if all its children haven’t completed. A 
 Job
  
 must complete in order for its parent to complete.
  
 The 
 Job
  abstraction makes this possible through the definition of 
 states
 , whose 
 transitions follow the workflow described by the diagram on the next page:
  
  
 raywenderlich.com
  
 56",NA
Canceling Jobs,"When you launch a coroutine and you create a 
 Job
 , many things can happen. An exception 
 can occur, or you might need to cancel the 
 Job
  because of some new conditions in the 
 application. Consider, for instance, a list of images that you download from the network. 
 Every time you need to display an image in a list item, you start a coroutine for the 
 download. This download might fail because there’s no connection, and you have to 
 handle the related exception. Or the download might be canceled because the user scrolls 
 the list and the image goes out of the screen before it’s available. It’s very important to 
 understand how you can manage these use cases when using coroutines.
  
  
 raywenderlich.com
  
 57",NA
Digging deeper into corou+nes,"So far you’ve launched a large amount of coroutines, and you’ve seen how you can create 
 multiple coroutine jobs. But there are other things you can do when launching a 
 coroutine. For example, if you have some work that you have to first delay for a period of 
 time, before running, you can do so with 
 delay()
 . Open up 
 Main.kt
  again, and replace the 
 code with the following snippet:
  
 fun
 main
 ()
  { 
  
  
  GlobalScope.launch { 
  
  
  println(
 ""Hello coroutine!""
 ) 
  
  
  delay(
 500
 ) 
  
  
  println(
 ""Right back at ya!""
 ) 
  
  
  } 
  
  
  Thread.sleep(
 1000
 ) 
  
 }
  
  
  
 raywenderlich.com
  
 58",NA
Dependent Jobs in ac+on,"So far, you’ve learned that, every time you launch a coroutine, you can get a 
 Job 
 reference. You can also create dependencies between different 
 Job
 s — but how? Just 
 replace the previous code with this:
  
 fun
 main
 ()
  { 
  
  
 val
  job1 = GlobalScope.launch(start = CoroutineStart.LAZY) { 
  
  
  
 delay(
 200
 ) 
  
   
  println(
 ""Pong""
 ) 
  
   
  delay(
 200
 ) 
  
  
  } 
  
  
  GlobalScope.launch { 
  
  
  delay(
 200
 ) 
  
  
  println(
 ""Ping""
 ) 
  
  
  job1.join() 
  
  
  println(
 ""Ping""
 ) 
  
  
  delay(
 200
 ) 
  
  
  } 
  
  
  Thread.sleep(
 1000
 ) 
  
 }
  
 Going through the code above:
  
 • You first launch a coroutine that contains some delays and prints the 
 Pong
  word, 
  
 saving the created 
 Job
  into the 
 job1
  reference.
  
 • Then, you launch a second coroutine that contains a couple of 
 println
 s but also 
  
 invokes the 
 join
  function on 
 job1
 .
  
 What is the expected output? If you follow the code, you would expect to see 
 Pong 
 and 
 then 
 Ping
  twice, but this is not the case. As you can see, you used the 
  
 CoroutineStart.LAZY
  value as 
 CoroutineStart
 , and this means that the related code is going 
 to be executed only when you actually need it.
  
 This happens when the second coroutine invokes the 
 join
  function on 
 job1
 . This is why 
 the result of the previous code is 
 Ping
 , then 
 Pong
  and, finally, 
 Ping
  again.
  
  
 raywenderlich.com
  
 59",NA
Managing Job hierarchy,"In the previous code, you created a dependency between different 
 Job
  instances, but this 
 is not the kind of relation you can refer to as a parent-child relation. Again, replace the 
 previous code with the following. You can use 
 with()
  in order to avoid the repetition of the 
 GlobalScope
  receiver:
  
 fun
 main
 ()
  { 
  
  
  with(GlobalScope) { 
  
    
 val
  parentJob = launch { 
  
    
  delay(
 200
 ) 
  
    
  println(
 ""I’m the parent""
 ) 
  
    
  delay(
 200
 ) 
  
  
  } 
  
  
  launch(context = parentJob) { 
  
    
  delay(
 200
 ) 
  
    
  println(
 ""I’m a child""
 ) 
  
    
  delay(
 200
 ) 
  
  
  } 
  
    
 if
  (parentJob.children.iterator().hasNext()) { 
  
    
  println(
 ""The Job has children 
 ${parentJob.children}
 ""
 ) 
  
  } 
 else
  { 
  
    
  println(
 ""The Job has NO children""
 ) 
  
  
  } 
  
  
  Thread.sleep(
 1000
 ) 
  
  
  } 
  
 }
  
 Going through the above code, in turn:
  
 • Here, you launch a coroutine and assign its 
 Job
  to the 
 parentJob
  reference.
  
 • Then, you launch another coroutine using the previous 
 Job
  as the 
  
 CoroutineContext
 . This is possible because  the 
 Job
  abstraction implements 
 CoroutineContext
 . Under the hood, the 
 CoroutineContext
  you pass here is 
 merged
  
 with the one from the currently active 
 CoroutineScope
  - 
  
 EmptyCoroutineContext
 .
  
 If you run the code above, you can see how the 
 parentJob
  has 
 children
 . If you run the same 
 code, removing the context for the second coroutine builder, you can see that the parent-
 child relationship is not established and the children are not present.
  
  
 raywenderlich.com
  
 60",NA
Using standard func+ons with corou+nes,"Another thing you can do with coroutines is build retry-logic mechanisms. Using 
 repeat()
  
 from the standard library, paired up with 
 delay()
  you learned above, you can create code 
 that attempts to run work in delayed periods of time. Once again, replace the 
 Main.kt
  
 code with the next snippet:
  
 fun
 main
 ()
  { 
  
 var
  isDoorOpen = 
 false
  
  println(
 ""Unlocking the door... please wait.\n""
 )  GlobalScope.launch { 
  
  delay(
 3000
 ) 
  
  isDoorOpen = 
 true
  
  } 
  
  GlobalScope.launch { 
  
  repeat(
 4
 ) { 
  
  
  println(
 ""Trying to open the door...\n""
 ) 
  
  delay(
 800
 ) 
  
   
 if
  (isDoorOpen) { 
  
     
  println(
 ""Opened the door!\n""
 ) 
  
  
  } 
 else
  { 
  
     
  println(
 ""The door is still locked\n""
 ) 
  
  } 
  
  } 
  
  } 
  
  
  Thread.sleep(
 5000
 ) 
  
 }
  
 Try running the code. You should see that someone’s trying to open the door a few times 
 before ultimately succeeding. So using 
 delay()
 , and 
 repeat()
  from Kotlin’s standard library, 
 you managed to build a mechanism that tries to run some code multiple times, before you 
 meet a time or logic condition. You can use the same flow to build networking back-off 
 and retry logic. And once you learn how to return values from coroutines later in this 
 book, you’ll see how powerful this can be.
  
  
 raywenderlich.com
  
 61",NA
Pos+ng to the UI thread,"From what you’ve seen so far, coroutines are all about simplicity, with a large part of 
 their functionality built into the language itself. Posting to the UI thread isn’t 
 complicated; it comes down to starting a new coroutine with a 
 UI dispatcher
  as its 
 threading context.
  
 Since we’re talking about applications with a visible user interface, you can post to the 
 main thread in 
 Android
 , 
 Swing
  and 
 JavaFx
  applications. You can do it using 
 Dispatchers.Main
  as the context in the following way:
  
 GlobalScope.launch(Dispatchers.Main) { ... }
  
 You need to be careful, though, because this is not enough. You need to set one of the 
 following dependencies:
  
 implementation ’org.jetbrains.kotlinx:kotlinx-coroutines-android:...’ 
  
 implementation ’org.jetbrains.kotlinx:kotlinx-coroutines-swing:...’ 
  
 implementation ’org.jetbrains.kotlinx:kotlinx-coroutines-javafx:...’
  
 Otherwise, you’ll get an exception like this:
  
 Exception in thread ""DefaultDispatcher-worker-3"" 
  
 java.lang.IllegalStateException: Module with the Main dispatcher is missing. Add dependency 
 providing the Main dispatcher, e.g. 
  
 ’kotlinx-coroutines-android’
  
 You can try this behavior with a simple Swing example. First, you need to add this 
 dependency to the 
 build.gradle
 :
  
 ""implementation ’org.jetbrains.kotlinx:kotlinx-coroutines-swing: 
 $kotlin_coroutines_version""
  
 Then, you can replace 
 main()
  with this:
  
 fun
 main
 ()
  { 
  
  
  GlobalScope.launch { 
  
    
 val
  bgThreadName = Thread.currentThread().name 
  
  println(
 ""I’m 
 Job 1 in thread 
 $bgThreadName
 ""
 ) 
  
  delay(
 200
 ) 
  
  
  GlobalScope.launch(Dispatchers.Main) { 
  
      
 val
  uiThreadName = Thread.currentThread().name 
   
  
  println(
 ""I’m Job 2 in thread 
 $uiThreadName
 ""
 )
  
  
  
 raywenderlich.com
  
 62",NA
Key points,"• You can build coroutines using 
 coroutine builders
 .
  
 • The main coroutine builder is the 
 launch
  function.
  
 • Whenever you launch a coroutine, you get a 
 Job
  object back.
  
 •
  Jobs
  can be canceled or combined together using the 
 join
  function.
  
 • You can nest jobs and cancel them all at once.
  
 • Try to make your code 
 cooperative
  — check for the state of the job when doing 
  
 computational work.
  
 • Coroutines need a 
 scope
  they’ll run in.
  
 • Posting to the UI thread in advanced applications is as easy as passing in the 
  
 Dispatchers.Main
  instance as the context.
  
 • Coroutines can be postponed, using the 
 delay
  function.
  
  
 raywenderlich.com
  
 63",NA
Where to go from here?,"You’re ready to launch as many coroutine jobs as you want! But this is only a small 
 piece of the Kotlin coroutine API. So far, you’ve only launched 
 Job
 s, pieces of work that 
 you need to finish. The real power of suspending code is being able to return values 
 asynchronously, without any callbacks or additional mechanisms.
  
 In the next chapter, you’ll learn a bit more about the fundamentals of coroutines and how 
 code is suspended in programs. You’ll learn about the execution of programs, how the 
 computer passes directions to functions and how the program knows where to go back 
 once a suspended function returns.
  
 So let’s not leave you in suspense!
  
  
 raywenderlich.com
  
 64",NA
4,NA,NA
Chapter 4: Suspending ,"So far, you’ve learned a lot about coroutines. You’ve seen how to launch coroutines and 
 deliver asynchronous work without any overhead from thread allocations or memory 
 leaks. However, the base foundation of coroutines is the ability to suspend code, control 
 its flow at will, and return values from synchronous and asynchronous operations with 
 the same kind of syntax and sequential code structure.
  
 In this chapter, you’ll learn more about how suspendable functions work from within. 
 You will see how you can convert existing code, which relies on callbacks, to 
 suspendable functions, which are called in the same way as regular, blocking, functions. 
 Throughout it all, you will learn what the most important piece of the coroutines puzzle 
 is.",NA
Suspending vs. non-suspending,"Up until now, you’ve learned that coroutines rely on the concept of 
 suspending code
  
 and 
 suspending functions
 . Suspended code is based on the same concepts as regular 
 code, except the system has the ability to 
 pause
  its execution and continue it later on. 
 But when you’re using two functions, a suspendable and a regular one, the calls seem 
 pretty much the same.
  
 If you go a step further and duplicate a function you use, but add the 
 suspend 
 modifier 
 keyword at the start, you could call both of the functions with the same parameters. You’d 
 have to wrap the suspendable function in a 
 launch
  block, because the Kotlin coroutines 
 API is built like that, but the actual function call doesn’t change.
  
  
 raywenderlich.com
  
 65",NA
Analyzing a regular func+on,"To follow the code in this chapter, import this chapter's starter project, using IntelliJ, and 
 selecting 
 Import Project
 , and navigating to the 
 suspending-functions/ 
 projects/starter
  folder, selecting the 
 suspending_functions
  project.
  
 If you open up 
 Main.kt
 , in the starter project, you’ll notice a small 
 main
  function. 
  
 It’s calling a simple, regular, non-suspendable function, which doesn’t rely on callbacks 
 or coroutines. There will be four different variants of this function. This variant is the 
 most rudimentary, so let’s analyze it first:
  
 fun
 getUserStandard
 (userId: String)
 : User { 
  
  
 Thread.sleep(
 1000
 ) 
  
 }
  
 return
  User(userId, 
 ""Filip""
 ) 
  
  
 The function takes in one parameter: the 
 userId
 . It puts the current thread to sleep for a 
 second, to mimic a long running operation. After that, it returns a 
 User
 . In reality, the 
 function is simple, and there are no hidden mechanisms at work here. 
  
 Analyze the bytecode generated by pressing 
 Tools ▸ Kotlin ▸ Show Kotlin Byteco
 de. 
 After that you should see th
 e Kotlin Byteco
 de window opened, and by pressing th
 e 
 Decompi
 le button, you can see the generated code, which should look 
  
 something like th
 is
  
 @NotNull 
  
 publicstaticfinal
  User 
 getUserStandard
 (@NotNull String userId) 
 { 
  
  
  Intrinsics.checkParameterIsNotNull(userId, 
 ""userId""
 ); 
  
  
  Thread.sleep(
 1000L
 ); 
  
  
 returnnew
  User(userId, 
 ""Filip""
 ); 
  
 }
  
 After inspecting it, you can see that it doesn’t differentiate much from the actual 
 code. It’s completely straightforward and does what the code says it does.
  
  
 raywenderlich.com
  
 66",NA
Implemen+ng the func+on with callbacks,"A better solution to this problem would be having a function, which takes in a 
 callback as a parameter. This callback would serve as a means of notifying the 
 program about the user value being ready for use. Furthermore, it would create a 
 separate thread of execution, to offload the main thread.
  
 To do this, replace the 
 getUserStandard()
  with the following code:
  
 fun
 getUserFromNetworkCallback
 ( 
  
  
 userId: String, 
  
  
  onUserReady: (User)
  -> 
 Unit
 ) { 
  
  thread { 
  
  
  Thread.sleep(
 1000
 ) 
  
    
 val
  user = User(userId, 
 ""Filip""
 ) 
  
  
 onUserReady(user) 
  
  
  } 
  
  
  println(
 ""end""
 ) 
  
 }
  
 Update the 
 main
  function to the following:
  
 fun
 main
 ()
  { 
  
  
  getUserFromNetworkCallback(
 ""101""
 ) { user -> 
  
  println(user) 
  
  
  } 
  
  
  println(
 ""main end""
 ) 
  
 }
  
 Run the bytecode analyzer again, and you should see the following output:
  
 publicstaticfinalvoid
 getUserFromNetworkCallback
 ( @NotNull 
 final
  String 
 userId, 
  
 @NotNull 
 final
  Function1 onUserReady)
  {
  
  
  
 raywenderlich.com
  
 67",NA
Handling happy and unhappy paths,"When programming, you usually have something called a 
 happy path
 . It’s the course of 
 action your program takes, when everything goes smoothly. Opposite of that, you have an 
 unhappy path
 , which is when things go wrong. In the example above, if things went 
 wrong, you wouldn’t have any way of handling that case from within the callback. You’d 
 either have to wrap the entire function call in a 
 try/catch 
 block, or catch exceptions from 
 within the 
 thread
  function. The former is a bit ugly, as you’d really want to have all 
 possible paths handled at the same place. The latter isn’t much better either, as all you can 
 pass to the callback is a value, so you’d have to either pass a nullable value, or an empty 
 object, and go from that.
  
 To make this functionality available and a bit more clean, programmers define the 
 callback as a two-parameter lambda, with the first being the value, if there is any, and 
 the second being the error, if it occurred. The signature of the function, and its 
 callback, would be next, so replace the code in 
 Main.kt
 :
  
 fun
 getUserFromNetworkCallback
 ( 
  
  
  userId: String, 
  
  
  onUserResponse: (User?, Throwable?)
  -> 
 Unit
 ) { 
  
  thread { 
  
 try
  { 
  
  Thread.sleep(
 1000
 ) 
  
  
 val
  user = User(userId, 
 ""Filip""
 ) 
  
   
  onUserResponse(user, 
 null
 ) 
  
  
  } 
 catch
  (error: Throwable) { 
  
   
  onUserResponse(
 null
 , error) 
  
  
  } 
  
  
  } 
  
 }
  
  
  
 raywenderlich.com
  
 69",NA
Analyzing a suspendable func+on,"The caveats found in the examples with callbacks are things which can be remedied 
 with the use of coroutines. Revise the changes you need to make to the example above, 
 to improve it even further:
  
 • Remove the callback and implement the example with coroutines.
  
 • Provide efficient error handling.
  
 • Remove the new 
 Thread
  allocation overhead.
  
 To surpass all these obstacles, you’ll learn another function from the Coroutines API — 
 suspendCoroutine()
 . This function allows you to manually create a coroutine and handle its 
 control state and flow. Unlike the 
 launch
  block, which just defined a way in which a 
 coroutine was built, but took care of everything behind the scenes.
  
 But, before we venture into 
 suspendCoroutine()
 , analyze what happens when you just add 
 the 
 suspend
  modifier to any existing function. Add another function to the 
 Main.kt
  file, 
 with the following signature:
  
 suspend 
 fun
 getUserSuspend
 (userId: String)
 : User { 
  
  delay(
 1000
 ) 
  
 }
  
 return
  User(userId, 
 ""Filip""
 ) 
  
  
 This function is very similar to the first example, except you added the 
 suspend 
 modifier, 
 and you don’t sleep the thread but call 
 delay()
  - a suspendable function which suspends 
 coroutines for a given amount of time. Given these changes, you’re probably thinking 
 the difference in bytecode cannot be that big, right?
  
  
 raywenderlich.com
  
 71",NA
Changing code to suspendable,"Another question is when should you migrate existing code to suspendable functions and 
 coroutines? This is a relatively biased question, but there are still some objective 
 guidelines you can follow, to determine if you’re better off with coroutines or standard 
 mechanisms.
  
  
 raywenderlich.com
  
 74",NA
Elabora+ng con+nua+ons,"Having 
 first-class
  continuations is the key concept which differentiates a standard 
 function, from a suspendable one. But 
 what
  is a continuation after all? Every time a 
 program calls a function, it is added on to the program’s 
 call-stack
 . This is a stack of all 
 the functions, in the order they were called, which are currently held in memory, and 
 haven’t finished yet. Continuations manipulate this execution flow, and in turn help 
 handle the call-stack.
  
 You’ve already learned that a 
 Continuation
  is in fact a callback, but implemented at a very 
 low system level. A more precise explanation would be that it’s an abstract wrapper 
 around the program’s 
 control state
 . It holds means to control how and when the 
 program will execute further, and what its result will be — an exception or a value.
  
 Once a function finishes, the program takes it off the stack, and proceeds with the next 
 function. The trick is how the system knows where to return, after each of the functions 
 are executed. This information is held within the aforementioned 
 Continuation
 . Each 
 continuation holds a little information about the 
 context
  in which the function was 
 called. Like the local variables, the parameters the function got passed, the thread it was 
 called in, and so on. By using that information, the system can simply rely on the 
 continuation, to tell it where it needs to be, when a function ends.
  
 Try and see what the lifecycle of functions, and a 
 Continuation
  is, from the function call, to a 
 finish.",NA
Living in the stack,"When a program first starts, its call-stack has only one entry — the initial function, 
 usually called 
 main()
 . This is because within it, no other functions have been called yet. 
 The initial function is important, because when the program reaches its end, it calls back 
 to the continuation of 
 main()
 , which completes the program, and notifies the system to 
 release it from memory.
  
  
 raywenderlich.com
  
 76",NA
Handling the con+nua+on,"In the last version of 
 getUser()
 , you used 
 suspendCoroutine()
  from the 
  
 Coroutines API. It’s a top level function which allows you to create coroutines, just like 
 launch()
 , but specifically for returning values, rather than launching work. Another 
 distinct thing about 
 suspendCoroutine()
  is that it takes in a lambda as an argument, which 
 is of the type 
 block: (Continuation<T>) -> Unit
 . What this means is, that you can handle a 
 Continuation
  as a first-class citizen, calling functions on the object as you please. This 
 allows for manual 
 control-state
  and 
 control-flow
  manipulation.
  
 The functions available on 
 Continuation
 s are 
 resume()
 , 
 resumeWith()
  and 
 resumeWithException()
 . You also have access to the 
 CoroutineContext
 , by calling the 
 continuation.context
 , but you’ll learn about contexts later on in ""Chapter 6: Coroutine 
 Context.”
  
  
 raywenderlich.com
  
 78",NA
Crea+ng your own suspendable API,"One of the things we mentioned Jetbrains had in mind for the Coroutines API was 
 extensibility. You’ve seen how you can turn your own functions into suspendable ones, 
 but another thing you can do is create an API-like set of utilities which hide the thread 
 and context switching ceremony.
  
 We’ve prepared some examples for you in 
 Api.kt
 . Open it up, and you should see a few 
 functions ready, but let’s go over them one by one.
  
 The first one is a convenience method, which uses 
 suspendCoroutine()
 , and the 
 Result
 ’s 
 runCatching()
  to try and process a value for you.
  
 suspend 
 fun
 <T : Any>
 getValue
 (provider: ()
  -> T): T = 
  
  suspendCoroutine { continuation -> 
  
  
  continuation.resumeWith(Result.runCatching { provider() })  }
  
 If you were to call this function somewhere in your code, it would look something like 
 this:
  
 GlobalScope.launch { 
  
 val
  user = getValue { getUserFromNetwork(
 ""101""
 ) } 
  
  
  println(user) 
  
 }
  
 This allows you to abstract away all of the functions which try to fetch some data, through 
 the network, file-reading or database lookups and push them to the 
  
 background thread, allowing the main thread to only worry about rendering the data, and 
 the rest of the code about fetching it.
  
  
 raywenderlich.com
  
 80",NA
Key points,"Chapter 4: Suspending Functions
  
 • Having 
 callbacks
  as a means of notifying result values can be pretty ugly and 
  
 cognitive-heavy
 .
  
 • Coroutines and 
 suspendable functions
  remove the need for callbacks and 
  
 excessive 
 thread allocation
 .
  
 • What separates a regular function from a suspendable one is the 
 first-class 
  
 continuation
  support, which the Coroutine API uses internally.
  
 • Continuations are already present in the system, and are used to handle 
 function 
 lifecycle
  — returning the values, jumping to statements in code, and updating the 
 call-stack.
  
 • You can think of continuations as 
 low-level callbacks
 , which the system calls to 
  
 when it needs to navigate through the call-stack.
  
 • Continuations always persist a batch of information about the 
 context
  in which 
  
 the function is called — the parameters passed, call site and the return type.
  
 • There are three main ways in which the continuation can 
 resolve
  - in a happy path, 
 returning a value
  the function is expected to return, 
 throwing an exception
  in case 
 something goes bad, and 
 blocking infinitely
  because of flawed business logic.
  
 • Utilizing the 
 suspend
  modifier, and functions like 
 launch()
  and 
  
 suspendCoroutine()
 , you can create your own API, which abstracts away the 
 threading used for executing code.",NA
Where to go from here?,"In this chapter you’ve learned 
 a lot
  about the foundation of coroutines. Through an 
 extensive overview of differences between suspendable and non-suspendable functions 
 you’ve seen how suspendable functions utilize 
 Continuation
 s to navigate around and 
 return values as results.
  
 The next chapter, Chapter 5, ""Async/Await,"" relies heavily on the usage of functions 
 which leverage continuations and suspendable functions to their favor, to return values 
 from code which may or may not be asynchronous and long-running. So read on to learn 
 more about how you can process values from functions which used to require a ton of 
 callbacks!
  
  
 raywenderlich.com
  
 82",NA
5,NA,NA
Chapter 5: Async/Await,"So far you’ve seen how coroutines and suspendable functions can be used to bridge 
 threads and execute asynchronous work that doesn’t add much overhead to your 
 program. You also saw how you can migrate from callback-based APIs to ones that are 
 coroutine-based, which has the signature of a regular function returning the value you 
 need when called. These functions were actually blocking but could have been 
 asynchronous.
  
 In this chapter, you’ll see how you can build similar mechanisms which aren’t blocking 
 and can work asynchronously and in parallel. They can also return values, as if you’re 
 calling a standard function. Sounds too good to be true? Well you’ll see how all of this 
 functionality is actually an old concept, so let’s get going!",NA
The async/await paaern,"One of the biggest problems in computing is being able to return values from 
 asynchronous functions. Even more so, if you’re calling a function that creates a different 
 thread to run in, you 
 can’t
  return a value to the outer function. This is a program 
 restriction because the system doesn’t know when to return, and has a hard time bridging 
 between threads. But there is a way to achieve this behavior with the 
 async/await
  
 pattern.
  
 It’s a very simple idea: Build a 
 wrapper around the value
  you need, then call a function 
 that provides the value and passes it to the wrapper. Once it’s ready, you can request it. 
 This goes all the way back to 
 queues
 , as the wrapper may as well be a simple class that 
 holds a queue of the capacity of one item. Once you request the value, you suspend the 
 function you requested it in, until the data shows up. This
  
  
 raywenderlich.com
  
 83",NA
Learning from the past,"Sometimes, it’s best to take a long, hard look at the past to see what you can learn and 
 maybe use to achieve your goals. When coroutines were designed, the team writing 
 the API did just that. That isn’t surprising, given that the concept of coroutines is 
 decades old. More specifically, they looked to the 
 future
  and 
 promise 
 patterns. Each 
 of the patterns has a specific syntax and way of dealing with asynchronously provided 
 values. Let’s see what they’re really about.",NA
Promising values,"A 
 promise
  construct is just what the names states — a promise of a value, which might 
 or might not be there at all. The value is promised to surface at some point in time for 
 you to consume it but, in reality, sometimes things break. This is why the promise also 
 allows you to handle any errors that happen along the way.
  
 Promises work by taking a function call and storing it in a construct. That alone doesn’t do 
 much, but the key to a promise is that you can chain them indefinitely. Once you create 
 your first one, you can chain the next promise call, which will take the input from the 
 previous one. So, if your first promise returns a 
 String
 , you can use that value in the next 
 call — to turn it into an 
 Int
 , for example. Then, in the third call, you’d get an 
 Int
 , and so on.
  
 Promises rely on two function calls: 
 then
  and 
 catch
 . 
 then()
  takes in the currently 
 promised value, and allows you to either map it to something else, or just consume it. 
 catch()
  is the fallback function, catching any errors that happen along the way, and 
 allowing you to act upon it. However, there has to be at least one 
 catch() 
 clause. A 
 standard promise chain would look like this:
  
 database 
  
  
  .findOne({ 
 email
 : request.email }) 
  
  
  .then(
 user
  => { 
  
    
 if
  (!user) { 
  
     
 // the user doesn't exist 
  
     
 return
  service.registerUser(request.data) 
  
  } 
 else
  { 
  
     
 returnnull
  
  
  
 raywenderlich.com
  
 84",NA
Thinking about the future,"Futures
  sound a lot like promises, and they behave similarly. When you create futures, 
 you’re not promising that a value will be there somewhere along the line, since 
 promises are easy to break. You explicitly say that this value 
 will
  exist, or you have to 
 face some consequences. In promises, it’s easy to break things: just miss a return call, 
 and your entire chain won’t have anything to consume, in turn freezing the entire 
 function call.
  
 In futures, you have to declare a function that has a return statement; otherwise, you get a 
 compile-time error. Additionally, once you create a future, you can check its status at any 
 point in time, using 
 isDone()
 . If 
 isDone()
  returns 
 true
 , you’re ready to use your value.
  
 Once you’re ready to use the value, all you have to do is call 
 get()
  to get it. The internal 
 part of futures is really fun to analyze. Futures use something called an 
 executor
  to run 
 their tasks. They handle the threading and execution of the tasks in each of the futures 
 you create, and you can achieve things like parallelism, using 
 thread pools
 . You’ll learn 
 more about 
 executors
 , 
 scheduling
  and thread pools in _""Chapter 7: Context Switch & 
 Dispatching""_.
  
 Since Java-based APIs don’t have the concept of 
 suspending
 , every call you make on a 
 Future
  will be blocking. As such, calling 
 get()
  right away might in turn block off your main 
 thread for a long time. Let’s see how futures work and what they look like:
  
 privatestatic
  ExecutorService executor =  
 Executors.newSingleThreadExecutor(); 
  
 publicstatic
  Future<Integer> 
 parse
 (String input)
  { 
  
 return
  
 executor.submit(() -> { 
  
   
  Thread.sleep(
 1000
 ) 
  
     
 return
  Integer.parseInt(input); 
  
  
  }); 
  
 }
  
 This snippet of code will create an executor, which uses a 
 new
  thread to do its 
 business. If you call 
 parse()
 , with a 
 String
 , it will return a future, which, when 
 executed, will wait for a second, and then it will return the 
 Integer
  value of the 
 String
 . 
 To call this code you’d have to do the following:
  
 publicstaticvoid
 main
 (String...args)
  {  Future<Integer> 
 parser = parse(
 ""310""
 ); 
  
 while
 (!parser.isDone()) { 
  
  
 // waiting to parse
  
  
  
 raywenderlich.com
  
 86",NA
Differen+a+ng approaches,"The key characteristic that distinguishes promises from async/awaits is that promises 
 rely on chains of function calls, sort of like the 
 builder pattern
 , but ultimately 
 promises are a series of callbacks. Using promises is very similar to 
 reactive 
 extensions
 , which operate on streams of values. You could, for example, chain 
 transforming operators or delay the data being processed.
  
 This code will look very structured at first, but, if you need to have multiple flows or 
 logical paths, you’ll end up having 
 staircases
  of 
 nested
  promises. For this reason, 
 promises can be tedious and ugly to work with. Newer versions of Javascript allow you 
 to use the 
 async
  and 
 await
  keywords, which work as promises at a lower level, but hide 
 that boilerplate away from you.
  
 Futures and async/await, however, rely on having a single value primed for usage, 
 burying it down underneath various design patterns and constructs. This also allows 
 you to use their results as values so that you can write sequential code that doesn’t use 
 callbacks but suspends the code waiting for their values. They are both fantastic
  
  
 raywenderlich.com
  
 87",NA
Using async/await,"To follow the code in this chapter, import this chapter's starter project, using IntelliJ, and 
 selecting 
 Import Project
 , and navigating to the 
 async-await/projects/starter 
 folder, 
 selecting the 
 async_await
  project.
  
 Right about now, you’re probably wondering how the async/await pattern works in the 
 Kotlin Coroutines API. Very close to the 
 future pattern
 , async in Kotlin returns a 
 Deferred<T>
 . Just like you would have a 
 Future<T>
 , the deferred value just wraps a 
 potential object you can use. Once you’re ready to receive the object, you have to await for 
 it, effectively requesting the data, which might or might not be there. If the data is already 
 provided and delivered, the call will turn into a simple 
 get()
 ; otherwise, you’re code will 
 have to suspend and wait for the data to come to the wrapper.
  
 Quite simply, it’s as if you’re creating a 
 BlockingQueue
  instance, with the capacity for a 
 single value. And, at any point in time, you can attempt to get the value or suspend the 
 code while waiting for it. The key difference is that you’re not actually blocking threads, 
 but are instead suspending code. It’s time for you to see how it’s all done backstage using 
 coroutines.
  
 The pattern is called 
 async/await
  for a reason — because the full implementation 
 requires two function calls — 
 async()
 , to prepare and wrap the values, and 
 await()
 , to 
 request the value for use. Let’s see what’s in the signature of both of these functions, 
 before you jump into using this approach.
  
  
 raywenderlich.com
  
 88",NA
Deferring values,"Every 
 async()
  block returns a 
 Deferred<T>
 . It’s the core mechanism that drives that piece of 
 the Coroutines API, and it’s very important to understand how it works.
  
 When you call 
 async()
 , the function returns a 
 Deferred
 . It does so by creating a 
 DeferredCoroutine
  or a 
 LazyDeferredCoroutine
 . Such coroutines have a generic inference and 
 also implement the 
 Continuation<T>
  interface, allowing the 
  
 interception of execution flow, and passing the values all the way up to the call site, just 
 like with 
 suspendCoroutine()
 . This is similar to how the 
 future pattern
  works, which 
 you’ve seen before.
  
 Once the coroutine is created, unless its 
 CoroutineStart
  is 
 CoroutineStart.LAZY
 , it will 
 launch immediately. The code will start to execute in the thread that you declared with 
 the 
 context
  parameter using 
 Dispatchers
 . Once the code finishes executing and produces a 
 value, it will be stored internally. If, at any point in time, you call 
 await()
 , it will be a 
 suspended call, which will create a new continuation and execution flow, waiting until 
 the value is ready for use. If it isn’t ready, the function will have to wait. If the value is 
 already provided, you’ll get it 
 immediately
 .
  
 You can also check the status of a deferred value, since it also implements the 
 Job 
 interface. You can check flags like 
 isActive
  and 
 isCompleted
  to find out about its current 
 lifecycle state. You also have a few nifty functions, which you can use to receive a value or 
 an exception if the 
 Job
  was canceled. These functions are 
  
 getCompleted()
 , which returns the value — or an exception if the deferred value was 
 canceled — and the 
 getCompletionExceptionOrNull()
 , which returns the 
 CancellationException
  
 or null, if the 
 Job
  was not canceled. Using those functions, you can also check the details 
 around the completed state of the deferred value.
  
  
 raywenderlich.com
  
 92",NA
Combining mul+ple deferred values,"Being able to create deferred values, which are built in the background but could be 
 accessed on the main thread in one function call, is an amazing thing. But the real power 
 of async is being able to combine two or more deferred values into a single function call. 
 Let’s see how to do so.
  
 So far, you’ve worked with an example that mocked a network request, but it’s time to 
 expand on that example. You might have noticed 
 users.txt
  in the project. It’s a file 
 containing 13,000 lines of text. Most lines contain the information required to build 
 User
 s 
 — an id, a name and a last name. Some of the lines are empty, some don’t have all three 
 items, and some are just plain gibberish. The idea behind this is to read the entire file, 
 parse and split each line ,and create users out of them. After that, you’ll use the list of 
 users and the user you got from the mocked network call to see if that user is stored in the 
 file.
  
 Having this will allow you to see how two deferred values can be primed and used in a 
 single function call. Now, navigate back to 
 AsyncAwait.kt
 . Once there, add the following 
 code to the file:
  
 privatefun
 readUsersFromFile
 (filePath: String)
  =  GlobalScope.async { 
  
  
  println(
 ""Reading the file of users""
 ) 
  
  
  delay(
 1000
 ) 
  
  File(filePath) 
  
  
  .readLines() 
  
  
  .asSequence() 
  
  
  .filter { it.isNotEmpty() } 
  
  
  .map { 
  
  
  
 valdata
  = it.split(
 "" ""
 ) 
 // [id, name, lastName]
  
  
 if
  (
 data
 .size == 
 3
 ) 
 dataelse
  emptyList()  } 
  
  .filter { 
  
  it.isNotEmpty() 
  
  } 
  
  .map {
  
  
  
 raywenderlich.com
  
 93",NA
Being coopera+ve and structured,"The above examples of code  are pretty well built, and they serve the purpose of 
 explaining how you can prime multiple values in parallel and pass them to functions once 
 they are ready. On the other hand, the problem is if something goes wrong or the async 
 block isn’t built properly, you’re going to block a thread and potentially freeze the entire 
 system. For example, if your async block contains a 
 while
  loop, and the condition doesn’t 
 have a 
 break strategy
 , your function will never return the value. Moreover, if you build 
 functions that do heavy operations and take a lot of time to finish, you should be able to 
 cancel them at any point in their execution. Otherwise, you risk canceling their parent 
 Job
 , 
 but not the job itself. Then you’ll end up with code that is still running and using up 
 resources, even though its 
 Job
  has been canceled.
  
 This is why your code should always be 
 cooperative
 .
  
 Some time after releasing coroutines, 
 Jetbrains
  began to see various kinds of usage and 
 libraries being built around them. 
 Jetbrains
  then released an article clarifying some 
 details, explaining how the initial examples and ideas people had about coroutines 
 weren’t 100% correct. Take an expanded example of the function you used above:
  
 private
  suspend 
 fun
 getUserByIdFromNetwork
 (userId: Int)
  = GlobalScope.async { 
  
  
  println(
 ""Retrieving user from network""
 ) 
  
  
  delay(
 3000
 ) 
  
  
  println(
 ""Still in the coroutine""
 ) 
  
  
  User(userId, 
 ""Filip""
 , 
 ""Babic""
 ) 
 // we simulate the network call 
 }
  
 If you call this function, this simple snippet will return a 
 User
  after three seconds. Since 
 it’s a suspend function, you need to wrap it in a coroutine builder, like so:
  
 fun
 main
 ()
  { 
  
  
  GlobalScope.launch { 
  
   
 val
  deferredUser = getUserByIdFromNetwork(
 130
 ) 
  
  
  println(deferredUser.await()) 
  
  
  } 
  
 }
  
  
  
 raywenderlich.com
  
 96",NA
Key points,"• The 
 async/await
  pattern is founded upon the idea of 
 futures
  and 
 promises
 , with 
  
 a slight twist in the execution of the pattern.
  
 •
  Promises
  rely on callbacks and chained function calls to consume the value in a 
 stream-like syntax, which tends to be clunky and unreadable when you have a lot of 
 business logic.
  
  
 raywenderlich.com
  
 101",NA
Where to go from here?,"Since this is the last chapter in the first section, you should be pretty proud of yourself! 
 You’ve learned a huge chunk of the Coroutines API. At this point, you’re ready to 
 migrate from callback-based code to coroutine-powered functions. You should be able 
 to write code that runs multiple functions in parallel, ultimately combining their result 
 in one function call.
  
 There’s still a few hidden gems within the core Coroutines API, which we haven’t covered, 
 but you should be able to look it up yourself and understand what’s going on as a result of 
 things you’ve learned so far. You can look up the 
 withContext 
 function, which is very 
 similar to 
 async
  and 
 await
 , but serves to immediately suspend the code and await for the 
 value from a coroutine-powered lambda call. It’s very useful if you don’t want to call 
 async
  
 and 
 await
  all the time, but want to do it in a cleaner way.
  
 In the next sections of the book, you’ll dive deeper into the rest of the Coroutines API. 
 More specifically, coroutine-powered 
 sequences
 , stream-like mechanisms called 
 channels
  and the comparison of coroutines and 
 RxKotlin
 . You’ll also see how coroutines 
 can be leveraged in Android, to offload the main thread from heavy, long-running work, 
 and to bridge the background threads with the main thread easily. So keep reading on!
  
  
 raywenderlich.com
  
 103",NA
6,NA,NA
Chapter 6: Corou+ne ,"You're getting pretty handy with coroutines, aren't ya? :] In the first section of this book 
 you've seen how you can start coroutines, bridge between threads in coroutines to return 
 values, create your own APIs and much more. In the second section, you'll focus on the 
 internal coroutine concepts. And the most important is the 
  
 CoroutineContext
 . Even though it's at the core of every coroutine, you'll see that it's fairly 
 simple after you take a look at its implementation and usage.",NA
Contextualizing corou+nes,"Each coroutine is tied to a 
 CoroutineContext
 . The context is a wrapper around a set of 
 CoroutineContext.Element
 s, each of which describes a vital part that builds up and forms a",NA
Using Corou+neContext,"To follow the code in this chapter, import this chapter's starter project using IntelliJ by 
 selecting 
 Import Project
 . Then navigate to the 
 coroutine-context/projects/ starter
  
 folder, selecting the 
 coroutine-context
  project.
  
 Even though you haven't gone too deep into it, you've already used 
  
 CoroutineContext
  extensively. Every time you've created a coroutine, from a 
 CoroutineScope
 , you've passed in the scope's 
 CoroutineContext
  to the builders. 
  
 Take the following snippet for an example:
  
 GlobalScope.launch { 
  
  
  println(
 ""In a coroutine""
 ) 
  
 }
  
 You don't see it, but there's work done around the 
 CoroutineContext
  for this simple snippet 
 of code. Once again, if you look at the definiton of the 
 launch
 , this is what you can see:
  
 publicfun
  CoroutineScope.
 launch
 ( 
  
  context: CoroutineContext = EmptyCoroutineContext,  start: CoroutineStart = 
 CoroutineStart.DEFAULT,  block: suspend CoroutineScope.()
  -> 
 Unit 
  
 ): Job
  
 You can see that the default context is the 
 EmptyCoroutineContext
 . This basically means it's 
 going to use the most default behavior - no special lifecycle, no exception
  
  
 raywenderlich.com
  
 105",NA
Combining different contexts,"Another interesting aspect to coroutine contexts is the ability to compose them and 
 combine their functionality. Using the 
 +
 /
 plus
  operator, you can create a new 
 CoroutineContext
  from the combination of the two. Since you know each coroutine is 
 composed of several objects, like the continuation interceptor for the flow, exception 
 handler for errors and a job for lifecycle, there has to be a way to create a new coroutine 
 with all these pieces of the puzzle. And this is where summing contexts comes in handy. 
 You can do it as simply as this:
  
 fun
 main
 ()
  { 
  
 val
  defaultDispatcher = Dispatchers.Default 
  
  
 val
  coroutineErrorHandler = CoroutineExceptionHandler { context, error -> 
  
   
  println(
 ""Problems with Coroutine: 
 ${error}
 ""
 ) 
 // we just print the error here
  
  
  } 
  
 val
  emptyParentJob = Job() 
  
 val
  combinedContext = defaultDispatcher + 
 coroutineErrorHandler + emptyParentJob 
  
  GlobalScope.launch(context = combinedContext) {  
 println(Thread.currentThread().name) 
  
  } 
  
  
  Thread.sleep(
 50
 ) 
  
 }
  
 The code above is an example of how to create a context from both the 
 Dispatchers.Default
  and the error handler. As such, you can add more
  
  
 raywenderlich.com
  
 106",NA
Providing contexts,"When it comes to software, you usually want to build it in a way that abstracts away the 
 communication between layers. With threading, it’s useful to abstract the way you 
 switch between different threads. You can abstract this by attaching a 
 thread provider
 , 
 providing both main and background threads. It’s no different with coroutines! Since 
 the threading mechanism is abstracted with 
 CoroutineContext 
 objects, and their 
 respective 
 CoroutineDispatcher
  instances, you can build a provider that you’d use to 
 delegate which context should be used every time you build coroutines. Usually, these 
 providers have a declared interface, which gives you the 
 main
  and 
 background
  threads 
 or schedulers, since that’s what’s important in applications with user interfaces.
  
 Let’s see how you’d build such a provider.",NA
Building the ContextProvider,"You’ve already learned which 
 CoroutineContext
  objects exist and what their behavior is. 
 To build the provider, you first have to define an interface, which provides a generic 
 context, which you’ll run the expensive operations on. Note that this Provider interface 
 is not part of Coroutines but will help us abstract out the main and background contexts. 
 The interface would look like this:
  
 interface
 CoroutineContextProvider
  { 
  
 }
  
 fun
 context
 ()
 : CoroutineContext 
  
  
  
  
 raywenderlich.com
  
 107",NA
Key points,"Chapter 6: Coroutine Context
  
 • All the information for coroutines is contained in a 
 CoroutineContext
  and its 
  
 CoroutineContext.Element
 s.
  
 • There are three main coroutine context elements: the 
 Job
 , which defines the lifecycle 
 and can be cancelled, a 
 CoroutineExceptionHandler
 , which takes care of errors, and the 
 ContinuationInterceptor
 , which handles function execution flow and threading.
  
 • Each of the coroutine context elements implements 
 CoroutineContext
 .
  
 •
  ContinuationInterceptor
 s, which take care of the input/output of threading. 
  
 The 
 main and background threads are provided through the 
 Dispatchers
 .
  
 • You can combine different 
 CoroutineContext
 s and their 
 Element
 s by using the 
 +
 / 
  
 plus
  
 operator, effectively summing their elements.
  
 • A good practice is to build a 
 CoroutineContext
  provider, so you don’t depend on 
  
 explicit contexts.
  
 • With the 
 CoroutineContextProvider
  you can abstract away complex contexts, 
  
 like 
 custom error handling, coroutine lifecycles or threading mechanisms.
  
  
 raywenderlich.com
  
 109",NA
7 ,NA,NA
Contexts & ,NA,NA
Dispatchers,NA,NA
Chapter 7: Corou+ne ,"Right about now, you’ve amassed a good amount of knowledge about coroutines, 
 suspendable functions and the Kotlin’s Coroutines API. But you haven’t learned much 
 about how you can deal with threading, and which threading solutions exist within the 
 API itself. However, you did learn what the 
 CoroutineContext
  is, and what it's used for. 
 Having the ability to combine multiple 
 CoroutineContext
 s, and different context types, 
 to produce powerful coroutine mechanisms makes 
  
 coroutines really extensible and versatile.
  
 In fact, the 
 CoroutineContext
  is a fundamental part of something called 
 context switching
 , 
 and the process of 
 dispatching
 , which in turn revolves around threading.",NA
Work scheduling,"Organizing work at a system level is the bread and butter of all things related to multi-
 threading and parallel computing. Back in the day, when systems had a single core 
 processor and could only utilize a single thread, it was extremely important to write 
 optimized organizing algorithms so that the system didn’t freeze up and so that actions 
 didn’t take forever to complete.
  
 The process of figuring out the order, severity and resource usage for units of work the 
 system needs to complete is called 
 scheduling
 . Just like with a regular schedule, which 
 holds all your meetings and chores, it serves to best organize which event should 
 happen before others. It also deals with where the work lives in memory and when it 
 starts or ends — the lifecycle and how it behaves when things break.
  
  
 raywenderlich.com
  
 110",NA
Swimming in a pool of threads,"A 
 thread pool
  is a number of threads 
 pooled
  together and distributed between work 
 events that the system receives in its queue. Today’s hardware supports doing multiple 
 things at the same time and effectively handling quite a few times the amount of work 
 than before due to multiple cores. Combining that with the fact that coroutines can be 
 completed one piece at a time, instead of running the entire operation, it can make 
 coroutines extremely performant. This allows you to run several coroutines at once and 
 schedule threads in such a way that each of the threads does a bit of work on each of the 
 coroutines until all of the work is done, while all of the threads are constantly being 
 reassigned.
  
 Internally, this is where thread pools kick in. You can tell a thread pool to complete five 
 coroutines, like the example above. The thread pool will then assign threads to each of 
 the coroutines, effectively switching them out if needed and suspending coroutines if 
 some work that’s higher priority comes up — like an important system call that is 
 triggered from outside of your application. Once the thread is free again, it returns to the 
 thread pool, and the system once again decides if there’s work to be done or if it should 
 hold on and wait for more work events.
  
 It's also important to know how the system handles the state of each of the threads.
  
  
 raywenderlich.com
  
 111",NA
Context switching,"In the Coroutines API, you don’t have to  worry about creating your own threads or 
 thread pools, or about scheduling how multiple coroutines are executed, and their 
 lifecycle. The Coroutines API has a specific way of communicating all of this information 
 — via 
 ContinuationInterceptor
 s, which you provide through 
  
 Dispatchers
 , which you'll learn about later in this chapter.
  
 To fully understand how these 
 Dispatchers
  work, it's important to understand the 
 underlying pattern of communication of the process and thread state, which the system 
 prepares for you. This pattern is called. 
 context switching
 . However, the definition 
 varies from single to multi-tasking systems. But we'll focus on multi-tasking in this 
 chapter.
  
 Essentially, when the system switches the context, it means that it's moving from one task 
 to another, saving the state of the previous task, so it can be resumed later on. This 
 sounds familiar? It's very similar to what the 
 Continuation
  does, internally, when it comes 
 to suspension points in a suspendable function. Well, this is also why all the dispatchers 
 actually implement 
 ContinuationInterceptor
 , because through the process of intercepting 
 Continuation
 s, and their execution flow, can the system suspend and resume - 
 switch the 
 context
 , of the current task, or function, at hand.
  
 But pausing and resuming tasks is not everything, the system should also be able to 
 switch between the threads in a single task. When you think about it, these two concepts 
 stand toe-to-toe in Kotlin Coroutines.
  
 If you need to do something in the background, and then switch to the main thread, 
 posting a value or some result of an operation, you ultimately create another coroutine, 
 push it to the main thread, and then switch to that coroutine from within. 
  
 This is basically 
 context switching
 , with the addition that it switched between 
 threads. So it's no coincidence that the most important part of every coroutine is 
 called the 
 CoroutineContext
 .
  
 Now that you understand a bit how the system can handle coroutines' context 
 switching, it's time to move onto 
 dispatching
 ! :]
  
  
 raywenderlich.com
  
 112",NA
Explaining Con+nua+onInterceptors,"Even though this chapter mentions 
 ContinuationInterceptor
 s, it may still be a bit unclear on 
 how they work. If you remember from the diagram of what happens with functions in the 
 call stack and when suspendable functions are called:
  
  
 Call stack with Continuation
  
 When you had multiple functions in the stack, and multiple continuations, you 
 learned that you can return all the way down to the main 
 Continuation
 , by 
 propagating the value, or an exception, back down the stack.
  
 ContinuationInterceptor
 s work with that function execution and threading. Every time you 
 launch a coroutine, or call a suspend function with a 
 Dispatcher
 , you give the interceptor 
 the ability to pause and resume the continuation of the coroutine - the execution flow. It 
 can intercept value propagation at one point, and redirect it to another coroutine or task.
  
 Because of that, if you create one coroutine using 
 Dispatchers.Default
  to get some value, 
 and then within it, you launch a new coroutine with 
 Dispatchers.Main 
 to push it on the 
 main thread, you'll effectively intercept the first coroutine's execution, 
 continue
  on with 
 the second coroutine passing in the context and values so you can do some work on the 
 main thread, and then you finish both coroutines when you're done. If anything goes 
 wrong in the second coroutine, the interceptor will propagate the exception all the way 
 up, to the parent coroutine, cancelling both coroutines.
  
  
 raywenderlich.com
  
 113",NA
Corou+ne dispatcher types,"Kotlin provides a concise way of communicating threading options in coroutines using 
 Dispatchers
 . They are a 
 CoroutineContext.Element
  implementation, forming one part of 
 the puzzle that handles how coroutines behave when executed. 
  
 In general computing, a dispatcher is a module that gives control of the CPU to whichever 
 process the scheduling mechanism selected for execution. So a scheduler decides which 
 process
  is next in line for a bit of CPU power, but it passes the process down to a 
 dispatcher to allow the process to use up the actual resources. Together, these two 
 modules or mechanisms control processes in an operating system.
  
 A similar thing happens with 
 CoroutineDispatcher
 s. They decide how coroutines use up 
 available resources by delegating threads or thread pools to them. Once you attach a 
 certain dispatcher to a coroutine, it is assigned to a thread or thread pool the dispatcher 
 knows about.
  
 Since they deal with threads, dispatchers in coroutines can be 
 confined
  and 
  
 unconfined
 . Confined dispatchers always rely on predefined system contexts — like the 
 Dispatchers.Main
 . No matter how many times you use the 
 Main
  dispatcher, it will always 
 make the coroutine work on the main thread. Unconfined dispatchers, on the other hand, 
 don’t have a specific context they operate in, nor do they follow any strict rules. They 
 either create new threads to run coroutines in or push the work to the thread in which the 
 code was called, making them 
 unpredictable
 .
  
  
 raywenderlich.com
  
 114",NA
Default dispatcher,"The default dispatcher’s name pretty much gives it away. It’s used in the foundation of 
 coroutines and is used whenever you don’t specify a dispatcher. It’s convenient to use 
 because it’s backed by a worker thread pool, and the number of tasks the 
 Default
  
 dispatcher can process is always equal to the number of cores the system has, and is at 
 least two. Because the entire threading mechanism and the thread pool is pre-built, you 
 can rely on it for your day-to-day work related to coroutines and operations you want to 
 off-load from the main thread.",NA
IO dispatcher,"Again, the name says a lot. Whenever you’re trying to process something with input and 
 output, like uploading or decrypting/encrypting files, you can use this dispatcher to make 
 things easier for you. That being said, it’s bound to the JVM, so if you’re using 
 Kotlin/JavaScript or Kotlin/Native projects, you won’t be able to use it.",NA
Main dispatcher,"This dispatcher is tied to systems that have some form of 
 user interface
 , such as Android 
 or visual Java applications. And as mentioned, it dispatches work to the thread that 
 handles UI objects. You cannot use this without a UI, and if you try to call 
 Dispatchers.Main
  
 in a project that doesn’t use 
 Swing
 , 
 JavaFX
  or isn’t an Android app, your code will crash.
  
  
 raywenderlich.com
  
 115",NA
Using dispatchers,"Now that you know which dispatchers are out there, it’s time to learn how to utilize them. 
 Import this chapter's starter project, using IntelliJ, and selecting 
 Import Project
 , and 
 navigating to the 
 context-switch-and-dispatching/projects/starter 
 folder, selecting 
 the 
 context-switch-and-dispatching
  project. Let’s say you had the following code:
  
 GlobalScope.launch { 
  
  
  println(
 ""This is a coroutine""
 ) 
  
 }
  
 You can’t tell anything about the threading or scheduling, which happens behind the 
 scenes. Let’s review the 
 launch
  function’s signature:
  
 publicfun
  CoroutineScope.
 launch
 ( 
  
  
  context: CoroutineContext = EmptyCoroutineContext, 
  
  start: 
 CoroutineStart = CoroutineStart.DEFAULT, 
  
  block: suspend 
 CoroutineScope.()
  -> 
 Unit 
  
 ): Job
  
 The first part is important, here. It uses 
 EmptyCoroutineContext
  by default, unless you 
 specify a different one. You’ve learned that the 
 context
  defines how the coroutine is 
 started and where, how it handles errors, and what its lifecycle is. An 
 EmptyCoroutineContext
  doesn’t have any error-handling defined, it has no parent context, 
 it uses the default lifecycle management, and it doesn’t have a 
  
 CoroutineInterceptor
 , so it uses 
 Dispatchers.Default
 .
  
 From what you’ve learned about the dispatchers, this means the coroutine will use a 
 predefined pool of threads to do its work. If you want to use any other dispatcher, simply 
 pass it in to replace the 
 EmptyCoroutineContext
  default argument. Once you do that, the 
 dispatcher will be used as the context of the coroutine, and it will dictate 
 all-things-
 threading
 .
  
  
 raywenderlich.com
  
 116",NA
Crea+ng a work stealing Executor,"With the standard Coroutines API, you also have the ability to create new threads or 
 thread pools for coroutines. This is done by creating a new 
 Executor
 . Executors are 
 objects that execute given tasks. They are usually tied with 
 Runnable
 s, since they wrap 
 the task in a runnable, which needs executing. Creating a work-stealing executors for 
 example means that it will use all available resources at its disposal, in order to achieve a 
 certain level of parallelism, which you can define. To use the work-stealing-executor, you 
 have to do the following:
  
 fun
 main
 ()
  { 
  
 val
  executorDispatcher = Executors 
  
  
 .newWorkStealingPool() 
  
  
  .asCoroutineDispatcher() 
  
  GlobalScope.launch(context = executorDispatcher) {  
 println(Thread.currentThread().name) 
  
  } 
  
  
  Thread.sleep(
 50
 ) 
  
 }
  
 If you run this code, it will print out something similar to this:
  
 ForkJoinPool
 -
 1
 -worker-
 9
  
 The executor uses all available resources here, like the 
 ForkJoinPool
  thread pool, to finish 
 your task. Once it’s done with the task, it can re-allocate the taken resources to the rest of 
 the application. If you were to pass that executor the parallelism level of 
 four
 , and you 
 used the executor in many coroutines, it would distribute resources to achieve four 
 parallel executions as long as there’s work to be distributed.
  
 If you want to check out this final example in the final project, import this chapter's final 
 project, using IntelliJ, and selecting 
 Import Project
 , and navigating to the 
 context-
 switch-and-dispatching/projects/final
  folder, selecting the 
 context-switch-and-
 dispatching
  project.
  
  
 raywenderlich.com
  
 118",NA
Key points,"Chapter 7: Coroutine Contexts & Dispatchers
  
 • One of the most important concepts in computing, when using execution 
  
 algorithms, is 
 scheduling
  and 
 context switching
 .
  
 • Scheduling takes care of resource management by coordinating 
 threading
  and the 
  
 lifecycle
  of processes.
  
 • To communicate thread and process states in computing and task execution, the 
  
 system uses 
 context switching
  and 
 dispatching
 .
  
 • Context switching helps the system store thread and process state, so that it can 
  
 switch between tasks
  which need execution.
  
 • Dispatching handles which tasks get resources at which point in time.
  
 •
  ContinuationInterceptor
 s, which take care of the input/output of threading, and the 
 main and background threads are provided through the 
 Dispatchers 
 class.
  
 • Dispatchers can be 
 confined
  and 
 unconfined
 , where being confined or not relates 
  
 to using a fixed threading system.
  
 • There are four main dispatchers: 
 Default
 , 
 IO
 , 
 Main
  and 
 Unconfined
 .
  
 • Using the 
 Executors
  class you can create new thread pools to use for your 
  
 coroutine work.
  
  
 raywenderlich.com
  
 119",NA
8,NA,NA
Chapter 8: Excep+on ,"Exception and error handling is an integral part of asynchronous programming. 
 Imagine that you initiate an asynchronous operation, it runs through without any 
 error and finishes with the result. That’s an ideal case. What if an error occurred 
 during the execution? As with any unhandled exception, the application would 
 normally crash. You may set yourself up for failure if you assume that any 
 asynchronous operation is going to run through successfully without any error.
  
 Before you can understand error and exception handling during coroutine execution, it is 
 important that you have an understanding of how these errors and exceptions are 
 propagated through the process.",NA
Excep+on propaga+on,NA,NA
Handling excep+ons,"Exception handling is pretty straightforward in coroutines. If the code throws an 
 exception, the environment will automatically propagate it and you don’t have to do 
 anything. Coroutines make asynchronous code look synchronous, similar to the expected 
 way of handling synchronous code — i.e., try-catch applies to coroutines, too.
  
 Here is a simple example that creates new coroutines in 
 GlobalScope
  and throws 
 exceptions from different coroutine builders:
  
 fun
 main
 ()
  = runBlocking { 
  
 val
  asyncJob = GlobalScope.launch { 
  
  
  println(
 ""1. Exception created via launch coroutine""
 ) 
  
 // Will be printed to the console by 
  
 // Thread.defaultUncaughtExceptionHandler 
 throw
  
 IndexOutOfBoundsException() 
  
  } 
  
  asyncJob.join() 
  
  println(
 ""2. Joined failed job""
 ) 
  
 val
  deferred = GlobalScope.async { 
  
  
  println(
 ""3. Exception created via async coroutine""
 ) 
  
 // Nothing is printed, relying on user to call await 
 throw
  
 ArithmeticException() 
  
  } 
  
  
 try
  { 
  
   
  deferred.await() 
  
   
  println(
 ""4. Unreachable, this statement is never executed""
 ) 
  
  } 
 catch
  (e: 
 Exception) { 
  
   
  println(
 ""5. Caught 
 ${e.javaClass.simpleName}
 ""
 ) 
  
  
  } 
  
 }
  
 Output:
  
 1. Exception created via launch coroutine 
  
 Exception 
 in
  thread 
 ""DefaultDispatcher-worker-1"" 
 java.lang.IndexOutOfBoundsException 
  
  
  - - - 
  
 2. Joined failed job 
  
 3. Exception created via async coroutine 
  
 5. Caught ArithmeticException
  
  
  
 raywenderlich.com
  
 121",NA
Corou+neExcep+onHandler,"Similar to using Java’s 
 Thread.defaultUncaughtExceptionHandler
 , which returns a 
 handler for uncaught thread exceptions, coroutines offer an optional and generic 
 catch
  
 block to handle uncaught exceptions called 
 CoroutineExceptionHandler
 .
  
 Note
 : On Android, 
 uncaughtExceptionPreHandler
  is the global coroutine 
 exception handler.
  
 Normally, uncaught exceptions can only result from coroutines created using 
 launch 
 coroutine builder. A coroutine that was created using 
 async
 always
  catches all its 
 exceptions and represents them in the resulting 
 Deferred
  object.
  
  
 raywenderlich.com
  
 122",NA
Try-Catch to the rescue,"When it comes to handling exceptions for a specific coroutine, you can use a 
 try-
 catch
  block to catch exceptions and handle them like you would do in normal 
 synchronous programming with Kotlin.
  
 There is the catch though. Coroutines created with 
 async
  coroutine builder can typically 
 “swallow” exceptions if you’re not careful. If an exception is thrown during an async 
 block, the exception is not actually thrown immediately. Instead, it will be thrown at the 
 time you call 
 await
  on the 
 Deferred
  object that is returned. This behavior, if not taken 
 into account, can lead to situations where no exceptions are ever tracked, but deferring 
 exception handling until a later time can also be a desired behavior depending on the use 
 case at hand.
  
 Here is an example to demonstrate the same:
  
 fun
 main
 ()
  { 
  
  
  runBlocking { 
  
   
 // Set this to ’true’ to call await on the deferred variable 
   
 val
  
 callAwaitOnDeferred = 
 true
  
 val
  deferred = GlobalScope.async { 
  
  
 // This statement will be printed with or without 
  
 // a call to 
 await()
  
  println(
 ""Throwing exception from async""
 ) 
  
  
 throw
  ArithmeticException(
 ""Something Crashed""
 )
  
  
  
 raywenderlich.com
  
 125",NA
Handling mul+ple child corou+ne excep+ons,"Having just a single coroutine is an ideal use case. In practice, you may have multiple 
 coroutines with other child coroutines running under them. What happens if those child 
 coroutines throw exceptions? This is where all this might become tricky. In this case, the 
 general rule is “the first exception wins.” If you set a 
  
 CoroutineExceptionHandler
 , it will manage only the first exception suppressing all the 
 others.
  
 Here is an example to demonstrate this:
  
 fun
 main
 ()
  = runBlocking { 
  
 // Global Exception Handler 
  
 val
  handler = CoroutineExceptionHandler { _, exception -> 
  
  println(
 ""Caught 
 $exception
  with suppressed ""
  + 
  
  
  
 raywenderlich.com
  
 126",NA
Callback wrapping,"Handling asynchronous code execution usually involves implementing some sort of 
 callback mechanism. For example, with an asynchronous network call, you probably 
 want to have 
 onSuccess
  and 
 onFailure
  callbacks so that you can handle the two cases 
 appropriately.
  
  
 raywenderlich.com
  
 128",NA
Key points,"Chapter 8: Exception Handling
  
 • If an exception is thrown during an asynchronous block, it is not actually thrown 
 immediately. Instead, it will be thrown at the time you call await on the 
 Deferred 
 object that is returned.
  
 • To ignore any exceptions, launch the parent coroutine with the 
 async
  function; 
 however, if required to handle, the exception uses a 
 try-catch
  block on the 
 await() 
 call 
 on the 
 Deferred
  object returned from 
 async
  coroutine builder.
  
 • When using 
 launch
  builder the exception will be stored in a 
 Job
  object. To retrieve 
  
 it, you can use the 
 invokeOnCompletion
  helper function.
  
 • Add a 
 CoroutineExceptionHandler
  to the parent coroutine context to catch 
  
 unhandled exceptions and handle them.
  
 •
  CoroutineExceptionHandler
  is invoked only on exceptions that are not expected to be 
 handled by the user; registering it in an 
 async
  coroutine builder or the like has no 
 effect.
  
 • When multiple children of a coroutine throw an exception, the general rule is 
 the 
  
 first exception wins
 .
  
 • Coroutines provide a way to wrap callbacks to hide the complexity of the 
 asynchronous code handling away from the caller via a 
 suspendCoroutine 
 suspending function, which is included in the coroutine library.",NA
Where to go from here?,"Exception handling is a crucial step in working with asynchronous programming. If the 
 basics are not clear, it makes the process of programming and dealing with various 
 asynchronous tasks pretty complex. Thankfully, when it comes to coroutines, you are now 
 well versed with the concepts and implementations.
  
 Next up, you will explore cancelling coroutines, so as to be able to stop them from 
 executing when required.
  
  
 raywenderlich.com
  
 131",NA
9 ,NA,NA
Cancella+on,NA,NA
Chapter 9: Manage ,"When you initiate multiple asynchronous operations that are dependent on each 
 other, the possibilities of one failing, then leading to others also failing, increases. This 
 means that the result is not going to end as you expected. Coroutines address this 
 problem and provide mechanisms to handle this and many other cases.
  
 This chapter will dive deeper into the concepts and mechanics of cancellation in 
 coroutines.",NA
Cancelling a corou+ne,"As with any multi-threading concept, the lifecycle of a coroutine can become a problem. 
 You need to stop any potentially long-running background tasks when it is in an 
 inconsistent state in order to prevent memory leaks or crashes. To resolve this, 
 coroutines provide a simple cancelling mechanism.",NA
Job object,"As you’ve seen in Chapter 3: “Getting Started with Coroutines,” when you launch a new 
 routine using the 
 launch
  coroutine builder, you get a 
 Job
  object as the return value. This 
 Job
  object represents the running coroutine, which you can cancel at any point by calling 
 the 
 cancel
  function.
  
 This is interesting because with Kotlin coroutines, you have the ability to specify a 
 parent job as a context for multiple coroutines, and calling 
 cancel
  on the parent 
 coroutine will result in all coroutines being canceled.
  
  
 raywenderlich.com
  
 132",NA
Cancel,"In a long-running application, you might need fine-grained control on your 
 background coroutines. For example, a task that launched a coroutine might have 
 finished, and now its result is no longer needed; consequently, its operation can be 
 canceled. This is where the 
 cancel
  method comes in.
  
 In order to cancel a coroutine, you simply need to call the 
 cancel
  method on the Job object 
 that was returned from the coroutine builder. Calling the 
 cancel
  function on a 
 Job
 , or on a 
 Deferred
  instance, will stop the inner computation on a coroutine if the handling of the 
 isActive
  flag is properly implemented.
  
 Coroutine cancelation is 
 cooperative
 . This means that the suspending function has to 
 cooperate in order to support cancelling. In practice, the suspending function has to 
 periodically test the 
 isActive
  property, which is set to 
 false
  when the coroutine is 
 canceled. This applies to your suspending functions, too. All suspending functions 
 provided by the Kotlin coroutine library support cancelation already.
  
 Note
 : 
 isActive
  is checked between child coroutine suspension points by the 
 standard library, so you only have to check 
 isActive
  in your own long-running 
 computations.
  
  
  
 raywenderlich.com
  
 133",NA
Cancella+onExcep+on,"Coroutines internally use 
 CancellationException
  instances for cancellation, which are 
 then ignored by all handlers. They are typically thrown by cancellable suspending 
 functions if the Job of the coroutine is canceled while it is suspending. It indicates normal 
 cancellation of a coroutine.
  
 Note
 : 
 CancellationException
  is not printed to the console/log by the default 
 uncaught exception handler.
  
 When you cancel a coroutine using the 
 cancel
  function on its 
 Job
  object without a 
 cause, it terminates but it does not cancel its parent. Cancelling without cause is a 
 mechanism for a parent to cancel its children without canceling itself.
  
 The following piece of code shows an example of 
 CancellationException
  handling 
 when child jobs are canceled, which is pretty straightforward:
  
 fun
 main
 ()
  = runBlocking { 
  
  
 val
  handler = CoroutineExceptionHandler { _, exception -> 
   
  
 println(
 ""Caught original 
 $exception
 ""
 ) 
  
  
  } 
  
  
 val
  parentJob = GlobalScope.launch(handler) { 
  
     
 val
  childJob = launch { 
  
       
 // Sub-child job
  
     
  launch { 
  
         
 // Sub-child job
  
        
  launch { 
  
         
 throw
  IOException() 
  
        
  } 
  
     
  } 
  
   
  } 
  
    
 try
  { 
  
    
  childJob.join() 
  
  
  } 
 catch
  (e: CancellationException) { 
  
    
  println(
 ""Rethrowing CancellationException""
  + 
  
  
    
 "" with original cause""
 ) 
  
      
 throw
  e 
  
  
  } 
  
  
  } 
  
  
  parentJob.join() 
  
 }
  
  
  
 raywenderlich.com
  
 135",NA
"Join, CancelAndJoin and CancelChildren","The Kotlin standard library provides a couple of convenience functions for handling 
 coroutine completion and cancellation.
  
 1. When using coroutines, you will most likely be interested in the result of a completed 
 job. To know about the completion of the coroutine, the 
 join
  function is available, 
 which suspends the coroutine execution until the canceled job is complete:
  
 fun
 main
 ()
  = runBlocking { 
  
  
 val
  job = launch { 
  
    
  println(
 ""Crunching numbers [Beep.Boop.Beep]...""
 ) 
  
  
  
  delay(
 500
 L) 
  
  
  } 
  
  
 // waits for job’s completion
  
  
  job.join() 
  
  
  println(
 ""main: Now I can quit.""
 ) }
  
  
 Note
 : You can find the executable version of the above snippet of code in the 
 starter project in the file called 
 JoinCoroutineExample.kt
 .
  
 Output:
  
 Crunching numbers [Beep.Boop.Beep]... main: Now I 
 can quit.
  
  
  
 raywenderlich.com
  
 136",NA
Timeout,"Long-running coroutines are sometimes required to terminate after a set time has 
 passed. While you can manually track the reference to the corresponding 
 Job
  and 
 launch a separate coroutine to 
 cancel
  the tracked one after a delay, the coroutines 
 library provides a convenience function called 
 withTimeout
 .
  
 Take a look at the following example:
  
 fun
 main
 ()
  = runBlocking { 
  
  
  withTimeout(
 1500
 L) { 
  
  
  repeat(
 1000
 ) { i -> 
  
   
  println(
 ""
 $i
 . Crunching numbers [Beep.Boop.Beep]...""
 ) 
  
  
  
 delay(
 500
 L) 
  
  
  } 
  
  
  } 
  
 }
  
  
 Note
 : You can find the executable version of the above snippet of code in the 
 starter project in the file called 
 WithTimeoutExample.kt
 .
  
  
  
 raywenderlich.com
  
 139",NA
Key points,"• When the parent coroutine is canceled, all of its children are recursively canceled, 
  
 too.
  
 •
  CancellationException
  is not printed to the console/log by the default uncaught 
  
 exception handler.
  
 • Using the 
 withTimeout
  function, you can terminate a long-running coroutine 
  
 after a set time has elapsed.
  
  
 raywenderlich.com
  
 141",NA
Where to go from here?,"Being able to cancel an ongoing task is almost always required. The cycle of starting a 
 coroutine and canceling it when an exception is thrown or when the business logic 
 demands it is part of some of the common patterns in programming. Coroutines in 
 Kotlin were built keeping that in mind since the very beginning.
  
 Next up, you will explore how to efficiently process collections involving more than one 
 processing step using coroutines.
  
  
 raywenderlich.com
  
 142",NA
Sec+on II: Channels & Flows,"Coroutines provide you a set of suspending functions and coroutine builders for the most 
 common use cases. In order to use them, you need to know some more details on how 
 they work under the hood. In this section, you'll explore channels, Coroutine Flow and 
 testing your coroutines.
  
 •
  Chapter 10: Building Sequences & Iterators with Yield
 : Sequences are one of the 
 most interesting features of Kotlin because they allow generating values lazily. When 
 you implement a sequence you use the yield function which is a suspending function. In 
 this chapter, you’ll learn how to create sequences and how the yield function can be 
 used to optimize performance.
  
 •
  Chapter 11: Channels
 : Although experimental, channels are a very important API 
 you can use with coroutines. In this chapter, you’ll create examples to understand 
 what a channel is and how to act as a producer or consumer for it synchronously 
 and asynchronously. You’ll understand how to use multiple channels in the case of 
 multiple senders and receivers. You’ll finally compare channels with Java’s 
 BlockingQueue.
  
 •
  Chapter 12: Broadcast Channels
 : In this chapter, you’ll write many examples to 
 experiment with using channels with multiple receivers and emitted items need to be 
 shared by all of them.
  
 •
  Chapter 13: Producer & Actors
 : In this chapter, you’ll learn how coroutines can help 
 implement a producer/consumer pattern using different types of producers and 
 consumers. Another approach to running tasks in the background is to use the actors 
 model. In the second part of this chapter, you’ll learn what an Actor is and how you can 
 use it with coroutines.
  
 •
  Chapter 14: Beginning with Coroutine Flow
 : In this chapter, you'll learn what 
  
 Coroutine Flow is and how to use them in your project.
  
 •
  Chapter 15: Testing Coroutines
 : Testing is a fundamental part of the 
  
 development process and coroutines are not different. In this chapter, you'll learn 
 how to test coroutines using the main testing frameworks.
  
  
 raywenderlich.com
  
 143",NA
10,NA,NA
Chapter 10: Building ,NA,NA
Sequences & Iterators with ,"Functional programming is one of the coolest concepts you can use in Kotlin. In this 
 chapter, you’ll see how you can use coroutines with sequences and iterators in order to 
 manage theoretically infinite collections of data.",NA
GeWng started with sequences,"Kotlin provides many ways to manage collections of data with a well-defined 
 Collections
  API together with many functional operators at your disposal.
  
 However, Collections themselves are not the most efficient. There are many cases in 
 which they lead to lower performance and can cause bottlenecks when executing 
 multiple operations on multiple items. That is mostly because all the functional",NA
Enter: Sequence,"To overcome such performance bottleneck issues, Kotlin came up with another data 
 structure called 
 Sequence
 , which handles the collection of items in a lazy evaluated 
 manner. The items processed in a sequence are not evaluated until you access them. 
 They are great at representing collection wherein the size isn’t known in advance, like 
 reading lines from a file.
  
 Sequence is based on a basic rule: It allows you to do multiple intermediate 
 operations on a collection of elements but enforces the requirement of having a 
 terminal operation to actually get the result from the sequence. As a result, it is 
 possible for a Sequence to process collections of infinite size elements.
  
  
 raywenderlich.com
  
 147",NA
Generators and Sequences,"Sequence & Yield
  
 Using Coroutines with Sequence, it is possible to implement 
 Generators
 . Generators are a 
 special kind of function that can return values and then can be resumed when they’re 
 called again. Think about lazy, infinite streams of values, like the Fibonacci sequence.
  
 Note
 : You can also find Generator functions in other languages such as 
 Python and Javascript where they exist with the yield keyword.
  
 Owing to the lazy-evaluated behavior of Sequence and the suspend-resume from 
 using Coroutines, creating a Generator function is quite easy.
  
 To understand how that can be achieved, take a look at the below code snippet about 
 generating an infinite sequence of Fibonacci numbers:
  
 fun
 main
 ()
  { 
  
 // 1 
  
 val
  sequence = generatorFib().take(
 8
 ) 
  
 // 2
  
  sequence.forEach { 
  
  
  println(
 ""
 $it
 ""
 )
  
  
  
 raywenderlich.com
  
 150",NA
SequenceScope is here to stay,"When working with Coroutines, you need to define a scope within which the 
 coroutines or suspension functions will work. 
 SequenceScope
  is defined for the 
 same reason, for yielding values of a Sequence or an Iterator using suspending 
 functions or coroutines.
  
  
 raywenderlich.com
  
 152",NA
Yield and YieldAll at your service,"Using the 
 yield()
  function, there are various ways by which a generator function can be 
 written to handle infinite collections of data.
  
 When considering a Sequence that generates a single value, simply using the 
 yield()
  
 function suffices the use case. It suspends the sequence when encountered and resumes 
 back for the next iteration and so on.
  
  
 raywenderlich.com
  
 153",NA
Key points,"1.
  Collection
  are eagerly evaluated; i.e., all items are operated upon completely 
  
 before passing the result to the next operator.
  
 2.
  Sequence
  handles the collection of items in a lazy-evaluated manner; i.e., the 
  
 items in it are not evaluated until you access them.
  
 3.
  Sequences
  are great at representing collection where the size isn’t known in 
  
 advance, like reading lines from a file.
  
  
 raywenderlich.com
  
 157",NA
Where to go from here?,"Working with an infinite collection of items is pretty cool, but what is even more 
 interesting is understanding how Coroutines work with Context and Dispatcher. You 
 will be learning about those in the next chapter.
  
  
 raywenderlich.com
  
 158",NA
11,NA,NA
Chapter 11: Channels,"From the previous chapters, you already learned how to deal with sending a request for 
 receiving a single value. This approach works perfectly when you just need to get a 
 value once and show it to the user, e.g., fetching a user profile or downloading an image. 
 In this chapter, you will learn how to send and receive 
 streams
  of values.
  
 Streams are convenient when you need to continuously get updates of data or handle a 
 potentially infinite sequence of items. Kotlin isn’t the first one to offer a solution to these 
 problems. 
 Observable
  from 
 ReactiveX
  and 
 Queue
  from 
 Java
  solve them as well. How 
 Channels
  compare with 
 Observable
  and 
 Queue
 , as well as their benefits and disadvantages, 
 will be covered further in this book.",NA
GeWng started with channels,"Channels are conceptually similar to reactive streams. It is a simple abstraction that you 
 can use to transfer a stream of values between coroutines. Consider a source that sends 
 content to a destination that receives it; i.e., elements are sent into the channel by 
 producer coroutines and are received by consumer coroutines. 
  
 Essentially, channels are like blocking queues that send and operate on data 
 asynchronously.
  
  
 Channel
  
 A fundamental property — and an important concept to understand — of a channel is its 
 capacity
 , which defines the maximum number of elements that a channel can contain in a 
 buffer. Suppose you have a channel with capacity 
 N
 . A producer can send values into the 
 channel but, when the channel reaches its N capacity, the producer suspends until a 
 consumer starts to read data from the same channel. You can think of the capacity like the 
 size of the buffer for a specific channel; it’s a way to optimize performances in the case 
 producing and consuming are operations, which take different amounts of time.
  
 You can change the default capacity of a channel by passing it as an argument to its 
 factory method. Take a look at the following method signature:
  
 publicfun
 <E>
 Channel
 (capacity: Int = RENDEZVOUS)
 : Channel<E>
  
 You will notice that the default capacity is set to 
 RENDEZVOUS
 , which corresponds to 
 0
  
 as per the source code:
  
 public
  const 
 val
  RENDEZVOUS = 
 0
  
  
  
 raywenderlich.com
  
 160",NA
Understanding closed channels,"In order to understand the state of the channel, you can use two handy properties: 
 isClosedForReceive
  and 
 isClosedForSend
 .
  
 When you close a channel from the sender, like in the previous example, you implicitly 
 put its 
 isClosedForSend
  property to 
 true
 , which means that you can’t send new data. It’s 
 important to understand that this doesn’t imply that 
  
 isClosedForReceive
  is also 
 true
 . This is because there should still be some data in the 
 channel. When the receiver consumes all the data, then the 
  
 isClosedForReceive
  is also set to 
 true
 . Because of this, you can consume the data using the 
 following code:
  
 while
  (!kotlinChannel.isClosedForReceive) { 
  
 val
  fruit = 
 kotlinChannel.receive() 
  
  
  println(fruit) 
  
 }
  
 Here, you’re receiving data until the 
 isClosedForReceive
  property is 
 true
 . Sadly, if you run 
 this example, you might still get an exception on the 
 close
  function. Why? Unfortunately, 
 channel APIs are unstable and, in this case, there’s a race condition on the update of the 
 isClosedForReceive
  property. In order to fix this, you could add a simple 
 delay
 , which gives 
 time to the channel for the update, but this is not deterministic and sometimes it won’t 
 work:
  
 while
  (!kotlinChannel.isClosedForReceive) { 
  
 val
  fruit = 
 kotlinChannel.receive() 
  
  
  delay(
 10
 ) 
  
  
  println(fruit) 
  
 }
  
  
  
 raywenderlich.com
  
 165",NA
Pipelines,"Chapter 11: Channels
  
 With channels, you always have a producer and a consumer. Sometimes, a consumer 
 receives the data from a channel, applies some transformations and becomes the 
 producer of a new channel. When a consumer of a channel becomes the producer of 
 another channel, you create a 
 Pipelines
 . The source channel might be infinite and the 
 pipeline might contain different steps.
  
  
 Pipeline
  
 Check out an example in which you generate a list of items that are red fruits. You will 
 make use of multiple channels connected as a pipeline to get the final result:
  
 dataclass
 Fruit
 (
 overrideval
  name: String, 
 overrideval
  color: String) : Item 
  
 dataclass
 Vegetable
 (
 overrideval
  name: String, 
 overrideval 
 color: String) : Item 
  
 @ExperimentalCoroutinesApi 
  
 fun
 main
 ()
  { 
  
 // ------------ Helper Methods ------------
  
 fun
 isFruit
 (item: Item)
 : 
 Boolean
  = item 
 is
  Fruit 
  
 fun
 isRed
 (item: Item)
 : 
 Boolean
  = (item.color == 
 ""Red""
 ) 
  
 // ------------ Pipeline ------------
  
 // 1 
  
 fun
 produceItems
 ()
  = GlobalScope.produce { 
  
   
 val
  itemsArray = ArrayList<Item>() 
  
  
  itemsArray.add(Fruit(
 ""Apple""
 , 
 ""Red""
 )) 
  
  
  itemsArray.add(Vegetable(
 ""Zucchini""
 , 
 ""Green""
 )) 
  
  
 itemsArray.add(Fruit(
 ""Grapes""
 , 
 ""Green""
 )) 
  
  
  itemsArray.add(Vegetable(
 ""Radishes""
 , 
 ""Red""
 )) 
  
  
 itemsArray.add(Fruit(
 ""Banana""
 , 
 ""Yellow""
 )) 
  
  
  itemsArray.add(Fruit(
 ""Cherries""
 , 
 ""Red""
 )) 
  
  
  itemsArray.add(Vegetable(
 ""Broccoli ""
 , 
 ""Green""
 ))
  
  
  
 raywenderlich.com
  
 167",NA
Fan out,"In the previous example, you created a pipeline as a sequence of channels, each one with 
 a single producer and a single consumer. Coroutines were consuming the data from a 
 channel and testing if that data satisfied certain conditions. In the case of success, the 
 items were put into the new channel; otherwise, they were discarded.
  
 Sometimes, the scenario is a little bit more complicated and you’d like to send each item 
 to a different coroutine depending on a specific condition. You need some kind of 
 demultiplexer
 , which, in the context of channels, is a use case called 
 Fan-out
 .
  
  
 raywenderlich.com
  
 170",NA
Fan in,"In the previous example, you created a coroutine that was able to demultiplex the 
 items into different channels based on certain criteria. That was a way to simulate the 
 case in which you have one producer and many consumers.
  
 A different case happens when you have multiple producers and one consumer: This is 
 called 
 Fan-in
 , and it’s a simpler situation compared to the previous.
  
  
 Fan-in
  
  
 raywenderlich.com
  
 175",NA
Buffered channel,"As you might have noticed above, the channel examples demonstrated previously used a 
 default value for the capacity, called RENDEZVOUS. These kinds of channels are called 
 unbuffered channels
  because the producer produces only if there’s a consumer ready 
 to consume.
  
 However, this behavior can be overcome easily by specifying the buffer capacity of the 
 channel as a parameter in the factory method. In this way, your channel won’t suspend 
 on a send operation when there is a free space in the buffer. You can create buffered 
 channels that will allow senders to send multiple elements before 
  
 suspending:
  
 // Channel of capacity 2 
  
 val
  kotlinBufferedChannel = Channel<String>(
 2
 ) 
  
  
  
 raywenderlich.com
  
 178",NA
Comparing send and offer,"In the previous examples, you sent values into a channel using the 
 send
  function. 
 Depending on the channel’s capacity, 
 send
  is a function that can suspend. This is 
 happening when the channel’s buffer is full or, in case of RENDEZVOUS, when there’s 
 not receiver ready to consume.
  
 In the case in which you don’t want to suspend, the 
 Channel
  abstraction provides the 
 offer(element: E)
  function whose signature is:
  
 abstractfun
 offer
 (element: E)
 : 
 Boolean
  
 Since this method is not a suspending function, it doesn’t need to be XXX into a coroutine. 
 If there’s enough capacity, the item goes into the channel and it returns 
 true
 . If there’s not 
 enough capacity, the function does nothing and returns 
 false
 . In both cases, it doesn’t 
 suspend.
  
 You can try it with the following code:
  
 fun
 main
 ()
  { 
  
 val
  fruitArray = arrayOf(
 ""Apple""
 , 
 ""Banana""
 , 
 ""Pear""
 , 
 ""Grapes""
 , 
 ""Strawberry""
 ) 
  
 val
  kotlinChannel = Channel<String>() 
  
  runBlocking { 
  
  launch { 
  
   
 for
  (fruit 
 in
  fruitArray) { 
  
      
 val
  wasSent = kotlinChannel.offer(fruit) 
   
    
 if
  (wasSent) { 
  
       
  println(
 ""Sent: 
 $fruit
 ""
 ) 
  
     
  } 
 else
  { 
  
       
  println(
 ""
 $fruit
  wasn’t sent""
 ) 
  
     
  } 
  
  
  }
  
  
  
 raywenderlich.com
  
 180",NA
Comparing receive and poll,"In the previous section, you’ve seen that a producer can use 
 offer
  as a not 
  
 suspending version of the 
 send
  function. What about the consumer? In this case, the 
 version of 
 receive
  without suspending is the 
 poll
  function whose signature is:
  
 abstractfun
 poll
 ()
 : E?
  
 Since this method is not a suspending function, there is no need to invoke it inside a 
 coroutine. It retrieves and removes the element from the channel and returns 
 null
  if the 
 channel is empty. If the channel was closed for 
 receive
 , it throws the close cause exception:
  
 fun
 main
 ()
  { 
  
 val
  fruitArray = arrayOf(
 ""Apple""
 , 
 ""Banana""
 , 
 ""Pear""
 , 
 ""Grapes""
 , 
 ""Strawberry""
 ) 
  
 val
  kotlinChannel = Channel<String>() 
  
  runBlocking { 
  
  launch { 
  
   
 for
  (fruit 
 in
  fruitArray) { 
  
     
 if
  (fruit == 
 ""Pear""
 ) { 
  
     
 break
  
    
  } 
  
    
  kotlinChannel.send(fruit) 
  
    
  println(
 ""Sent: 
 $fruit
 ""
 ) 
  
  } 
  
  } 
  
  launch { 
  
  repeat(fruitArray.size) { 
  
    
 val
  fruit = kotlinChannel.poll() 
   
  
 if
  (fruit != 
 null
 ) { 
  
     
  println(
 ""Received: 
 $fruit
 ""
 ) 
  
  
  } 
 else
  
 { 
  
     
  println(
 ""Channel is empty""
 ) 
   
  } 
  
  
  delay(
 500
 ) 
  
  } 
  
   
  println(
 ""Done!""
 ) 
  
  
  } 
  
  
  } 
  
 }
  
  
  
 raywenderlich.com
  
 182",NA
Error handling,"As you have seen in the previous examples, exceptions play an important role in the way 
 you can use a channel. It’s crucial to understand what the main exceptions are and what 
 you should do when they happen. You have to consider two main use cases, depending on 
 if you’re on the producer side or on the consumer side of the channel.
  
 You’ve already seen that, when you consume all elements from a closed channel, its 
 isClosedForReceive
  property returns 
 true
 . If you consume the channel using a 
 for 
 loop, 
 everything works in a transparent way. If you attempt to consume a new value, you get a 
 ClosedReceiveChannelException
 .
  
 When this happens, the channel is considered a 
 failed channel
 . A failed channel re-
 throws the original 
 close
  clause exception on received attempts.
  
  
 raywenderlich.com
  
 183",NA
Comparing Channels to Java Queues,"As mentioned, Java offers a similar solution for handling streams, called 
 Queue<E>
 , 
 which is an interface and has several implementations. Take a look at an 
  
 implementation of the 
 BlockingQueue<E>
  interface, as it supports a similar behavior as 
 Channel
  of waiting until a queue has space before inserting an element.
  
 publicclass
 BlockingQueueExample
  { 
  
 publicstaticvoid
 main
 (String[] args)
  { 
  
  BlockingQueue<String> queue = 
 new
  LinkedBlockingQueue<>(); 
  
  System.out.println(
 ""Beginning:""
 ); 
  
  
 try
  { 
  
  
  System.out.println(
 ""Let’s put in basket: Apple""
 ); 
  
  
 queue.put(
 ""Apple""
 ); 
  
  
  System.out.println(
 ""Let’s put in basket: Banana""
 ); 
  
  
 queue.put(
 ""Banana""
 ); 
  
  } 
 catch
  (InterruptedException e) { 
  
  
  e.printStackTrace(); 
  
  } 
  
  
  
 raywenderlich.com
  
 186",NA
Key points,"Chapter 11: Channels
  
 1.
  Channels
  provide the functionality for sending and receiving 
 streams
  of values.
  
 2. 
  
 Channel
  implements both 
 SendChannel
  and 
 ReceiveChannel
  interfaces; 
  
 therefore, it could be used for sending and receiving streams of values.
  
 3. A 
 Channel
  can be closed. When that happens, you can’t send or receive an 
  
 element from it.
  
 4. The 
 send()
  method either adds the value to a channel or 
 suspends
  the coroutine 
  
 until there is space in the channel.
  
 5. The 
 receive()
  method returns a value from a channel if it is available, or it 
  
 suspends the coroutine until some value is available otherwise.
  
 6. The 
 offer()
  method can be used as an alternative to 
 send()
 . Unlike the 
 send() 
 method, 
 offer()
  doesn’t suspend the coroutine, it returns 
 false
  instead. It returns 
 true
  in case of 
 a successful operation.
  
 7. 
  
 poll()
  similarly to 
 offer()
  doesn’t suspend the running, but returns 
 null
  if a 
  
 channel is empty.
  
 8. Java 
 BlockingQueue
  has a similar to Kotlin 
 Channel
  behavior, the main difference is that 
 the current thread gets blocked if the operation of inserting or retrieving is 
 unavailable at the moment.
  
  
 raywenderlich.com
  
 189",NA
12,NA,NA
Chapter 12: Broadcast ,"A channel is all about transferring a stream of values. It is quite common to put a stream 
 of items in the channel and then have receivers consume the items as they are emitted. 
 It works when an item is sent in a basic channel and when emitted it is consumed by a 
 receiver. Other receivers do not get the same item; instead, they wait for another item to 
 consume from the channel.
  
 Often times, you will encounter use cases in which you would like all the receivers to 
 consume the same value. This is where a 
 broadcast channel
  comes into the picture. 
  
 This and much more related to broadcast channels are covered in this chapter.",NA
GeWng started with broadcast channels,"With the 
 channel
 , if you have many receivers waiting to receive items from the channel, 
 the emitted item will be consumed by the first receiver and all other receivers will not 
 get the item individually. In fact, in such a scenario wherein there are more than one 
 receivers, there is the possibility of a 
 race condition
 .
  
 Take a look at this code snippet:
  
 fun
 main
 ()
  { 
  
 // 1 
  
 val
  fruitArray = arrayOf(
 ""Apple""
 , 
 ""Banana""
 , 
 ""Pear""
 , 
 ""Grapes""
 , 
  
 ""Strawberry""
 ) 
  
 // 2 
  
 val
  kotlinChannel = Channel<String>() 
  
 // 3
  
  runBlocking { 
  
   
 // 4 Producer
  
  
  GlobalScope.launch { 
  
   
 // Send data in channel
  
   
  kotlinChannel.send(fruitArray[
 0
 ])  } 
  
  
 // 5 Consumers
  
  GlobalScope.launch { 
  
  
  kotlinChannel.consumeEach { value -> 
  
   
  println(
 ""Consumer 1: 
 $value
 ""
 ) 
  
  
  } 
  
  } 
  
  GlobalScope.launch { 
  
  
  kotlinChannel.consumeEach { value -> 
  
   
  println(
 ""Consumer 2: 
 $value
 ""
 ) 
  
  
  } 
  
  } 
  
 // 6
  
  println(
 ""Press a key to exit...""
 )  readLine() 
  
    
 // 7
  
  
  kotlinChannel.close() 
  
  
  } 
  
 }
  
  
  
 raywenderlich.com
  
 191",NA
ConflatedBroadcast channel,"Like a 
 BroadcastChannel
 , 
 ConflatedBroadcastChannel
  enables many subscribed receivers 
 to consume items sent in the channel but it differs in one aspect: a 
 ConflatedBroadcastChannel
  only emits the most recently sent item while the older items are 
 lost. Also, any future subscribers to this channel will receive the item that was most 
 recently emitted.
  
  
 raywenderlich.com
  
 196",NA
Reac+veX vs. BroadcastChannel,"Reactive programming uses a similar kind of approach to handle streams of data as the 
 Kotlin coroutine channel. Like channels, reactive programming has 
 observables 
 with 
 data sources that emit items and should be observed. Then you also have the 
 observer
 , 
 which is basically a consumer of items emitted by the observables. To track the flow of 
 data, observers subscribe to observables, which emit data items and those are then 
 consumed by observers. There can be many observers observing an 
  
 observable.
  
 Notice that the data flow here is unidirectional. Observables emit data items and 
 observers consume the emitted data.
  
 Note
 : Reactive programming is a complete topic in itself on which a book can be 
 written. You will be focusing on the reactive approach as it resembles the 
 behavior of a broadcast channel.
  
 To implement this approach in various languages, there are corresponding libraries. For 
 JVM-based languages, you have RxJava, which simplifies and enables the reactive 
 programming approach when writing code for the Java platform.
  
 To add RxJava to your projects, you simply need to add the dependency in your 
 build.gradle file with:
  
 implementation 
 ""io.reactivex.rxjava2:rxjava:2.2.6""
  
  
 Note
 : As of this writing, RxJava is at version 2.2.6.
  
  
  
 raywenderlich.com
  
 199",NA
Key points,"Chapter 12: Broadcast Channels
  
 • With 
 channels
 , if you have many receivers waiting to receive items from the 
 channel, the emitted item will be consumed by the first receiver and all other 
 receivers will not get the item individually.
  
 •
  BroadcastChannel
  enables many subscribed receivers to consume all items sent 
  
 in the channel.
  
 •
  ConflatedBroadcastChannel
  enables many subscribed receivers to consume the 
  
 most recently sent item provided the receiver consumes items slower.
  
 •
  Subject
  from RxJava is the dual of the 
 BroadcastChannel
  in behavior.
  
 •
  BehaviorSubject
  from RxJava is the dual of 
 ConflatedBroadcastChannel
  in 
  
 behavior.",NA
Where to go from here?,"Kotlin channels introduce a very simplified approach to handling a stream of data with 
 well set-up constructs to enable better and faster development. This is not all the 
 information about channels because there are operators, which enable various 
 operations on the consumption of results. You will read about those in detail in the next 
 chapter.
  
  
 raywenderlich.com
  
 204",NA
13,NA,NA
Chapter 13: Producer & ,"Multi-processing communication is one of the most enticing challenges you can face when 
 developing multi-threaded software. Multi-threading technologies have been around for 
 years and there are a few solutions that are industry standard. In this chapter, you’ll be 
 learning about two of those solutions, which can be really useful in your future 
 applications.",NA
Producing and consuming data,"The first is the 
 producer-consumer
  problem, which describes a two-process 
 communication standard. One process produces data, places it in a queue, while the 
 other picks items off of the queue, one by one, and consumes it. Hence the name. A",NA
Producer-consumer problem,"Just like with pipelines, producers face the same challenge. As previously mentioned, a full 
 or an empty queue could cause loss of information, thread blocking or 
  
 exceptions. On the other hand, creating producers with coroutines is much easier and 
 avoids these problems. Let’s see how you’d create a basic producer using the Coroutines 
 API.",NA
Crea+ng a producer,"If you haven’t already, open up the starter project for this chapter with the name 
 produce_actor
 . Then, open 
 Produce.kt
  in the 
 producer
  package in the project. 
 Finally, to create a producer, call 
 produce()
 , on a 
 CoroutineScope
 , in 
 main()
 , like so:
  
 val
  producer = GlobalScope.produce<
 Int
 >(capacity = 
 10
 ) {}
  
  
  
 raywenderlich.com
  
 206",NA
Producing values,"The producer has to produce some values. Since the return type of 
 produce()
  is a 
 ReceiveChannel
 , you can’t use it for sending values. You have to do it within the lambda 
 you pass as parameter. The simplest way would be using a loop. Change the code in 
 main()
 , in 
 Produce.kt
 , to this:
  
 val
  producer = GlobalScope.produce(capacity = 
 10
 ) { 
  
 while
  
 (isActive) { 
  
     
 if
  (!isClosedForSend) { 
  
       
 val
  number = Random.nextInt(
 0
 , 
 20
 ) 
  
       
 if
  (offer(number)) { 
  
        
  println(
 ""
 $number
  sent""
 ) 
  
     
  } 
 else
  { 
  
        
  println(
 ""
 $number
  discarded""
 ) 
  
     
  } 
  
   
  } 
  
  
  } 
  
 }
  
 In this simple example, you run a loop that produces numbers from within a 
 coroutine. Since you do it in a coroutine, this is not really a blocking call, as the 
 program can finish, without having to wait for the 
 infinite
  loop to stop.
  
 Here, you’re calling 
 offer()
 , which attempts to queue a new element, if there’s room for 
 the element, otherwise the element is going to be discarded. This function has a 
 Boolean
  
 return type, which is 
 true
  in the former case and 
 false
  in the latter.
  
  
 raywenderlich.com
  
 207",NA
Consuming the values,"The produce function conveniently returns a 
 ReceiveChannel
 . This means you can iterate 
 through the values, transform or filter them, or run an infinite loop, reading the values.
  
 Let's start off with the most basic example: a 
 while
  loop. Add this code to the end of 
 main
  
 function:
  
 while
  (!producer.isClosedForReceive) { 
 val
  number = 
 producer.poll() 
  
  
 if
  (number != 
 null
 ) { 
  
   
  println(
 ""
 $number
  received""
 ) 
  
  
  } 
  
 }
  
 If you build and run the application, you’ll see output like this:
  
 12 sent 
  
 18 sent 
  
 19 sent 
  
 12 sent 
  
 17 sent 
  
 6 sent 
  
 9 sent 
  
 9 sent 
  
 1 sent 
  
 5 sent 
  
 12 received 
  
 3 sent 
  
 18 received 
  
 . . .
  
 In the previous code you’re invoking 
 poll()
  on the producer until its 
  
 isClosedForReceive
  has a 
 false
  value. This is happening if the channel has been closed on 
 the producer side invoking the 
 close
  method and all the values have been consumed. 
 Because you use the 
 poll
  method you have to check for nullability.
  
  
 raywenderlich.com
  
 210",NA
Ac+ng upon data,"The 
 actor model
  is a bit different from what you’ve seen so far and it exists as a 
 possible solution for a very common problem: 
 sharing data in a multithreading 
 environment
 . When you create an instance of an object, you know you can interact 
 with it using the operations it exposes: its 
 interface
 . Most of the objects also have some 
 state
 , which can change after interacting with other objects. Everything is simple if all 
 the objects collaborate on the same thread. In a multithreading 
  
 environment you have to introduce complexity in the code in order to make all the 
 classes 
 type safe
 . When multiple threads access shared data you know you can have 
 problems like data race conditions. Locks, implicit or not, are a possible solution but are 
 usually difficult to manage and test.
  
  
 Actors interact using messages
  
  
 raywenderlich.com
  
 212",NA
Handling actors properly,"Having many actors at your disposal, being limited only by memory, is both a great thing 
 and a challenge. The true challenge comes when you have to clean up old actors. If you 
 hold a reference to your actor children, in each of the actors, you’d end up with a large 
 reference tree. And you couldn’t clean up actors as you go, since they hold references to 
 new, fresh actors, as well.
  
 You could create threads, in which you create new actors, so you don’t hold an 
 implicit reference to the parent, but then again, threads are even more expensive.
  
 Kotlin Coroutines have a more efficient way to create actors, which avoids lots of 
 strong references and thread allocations. Let's see how to do so.",NA
Building actors using corou+nes,"Note
 : The Jetbrains team is currently working on both the Flow API, and 
 complex actors
 . They haven't yet decided what to do with the current Actor API, 
 and as such it's been marked as obsolete. However, the API still works, so it's 
 worth checking it out.
  
  
  
 raywenderlich.com
  
 213",NA
Delega+ng actor workload,"The actor model, however, relies on delegating excess work to others. So, for 
 example, if you’re building a robot-powered-storage system, where everything is 
 organized by robots, you have to find a way to optimize the workload.
  
 If a certain robot has too much to carry around, it can pass some of its work on to a 
 different robot. And if that second robot has too much work, it can pass it to a third one, 
 and so forth.
  
  
 See how this would look in code. Select everything in 
 Actor.kt
 , and replace with the 
 following code:
  
 fun
 main
 ()
  { 
  
 val
  items = listOf( 
  
  
  Package(
 1
 , 
 ""coffee""
 ), 
  
  
  Package(
 2
 , 
 ""chair""
 ), 
  
  
  Package(
 3
 , 
 ""sugar""
 ), 
  
  
  Package(
 4
 , 
 ""t-shirts""
 ), 
  
  
  Package(
 5
 , 
 ""pillowcases""
 ), 
  
  
  Package(
 6
 , 
 ""cellphones""
 ), 
  
  
  Package(
 7
 , 
 ""skateboard""
 ), 
  
  
  Package(
 8
 , 
 ""cactus plants""
 ), 
  
  Package(
 9
 , 
 ""lamps""
 ), 
  
  
  Package(
 10
 , 
 ""ice cream""
 ), 
  
  
  Package(
 11
 , 
 ""rubber duckies""
 ), 
  
  
 Package(
 12
 , 
 ""blankets""
 ), 
  
  
  Package(
 13
 , 
 ""glass""
 ) 
  
  ) 
  
 val
  initialRobot = WarehouseRobot(
 1
 , items)
  
  
  
 raywenderlich.com
  
 216",NA
Ac+ng in parallel,"Right now, the packages are mostly ordered, with a few exceptions to the rule. This means 
 that, usually, once the first robot finishes its work, the helper robot starts on its packages. 
 However, you’re building recursion-like work, which doesn’t suffer from the 
 StackOverflowException
  or 
 OutOfMemory
  exception, since the actors get cleaned up one by 
 one.
  
 To make them run in parallel, simply change the order of 
 processItems()
 , with the check 
 for creating a new actor. The order should be like this:
  
 fun
 organizeItems
 ()
  { 
  
  
  ... 
  
 if
  (leftoverItems.isNotEmpty()) { 
  
  
  GlobalScope.launch { 
  
   
 val
  helperRobot = WarehouseRobot(id.inc(), leftoverItems) 
  
  
  helperRobot.organizeItems() 
  
  } 
  
  } 
  
  processItems(itemsToProcess) 
  
  ... 
  
 }
  
  
  
 raywenderlich.com
  
 219",NA
Key points,"•
  Produce-consumer
  pattern and the 
 actor model
  are tried and tested mechanisms 
  
 for multi-threading.
  
 • Producer-consumer relationships are 
 one-to-many
 , where you can consume the 
  
 events from multiple places.
  
 • The 
 actor model
  is a way to share data in a multithread environment using a 
  
 dedicated queue.
  
 • The 
 actor model
  allows you to offload large amounts of work to many smaller 
  
 constructs.
  
  
 raywenderlich.com
  
 220",NA
Where to go from here?,"You now know how to build effective communication mechanisms, using 
 produce() 
 and 
 actor()
 . You’ve got everything you need to connect multiple threads, or to fan out a large 
 workload. In the next few chapters, you’ll see how to build a different kind of 
 mechanism of communication like broadcasting. You’ll also see how channels’ data can 
 be transformed and combined.
  
 So let’s 
 channel
  this positive energy and head over to the next chapter!
  
  
 raywenderlich.com
  
 221",NA
14 ,NA,NA
with Corou+nes Flow,NA,NA
Chapter 14: Beginning ,"Coroutines are amazing when it comes to bridging the synchronous and 
  
 asynchronous worlds, to return values and communicate between threads. Most of the 
 time that's what you want and need, but sometimes, computer systems require you to 
 consume multiple values over a period of time.
  
 And there are two different ways you can do this - using 
 sequences
  and 
 streams
 . 
 However there are certain limitations to both approaches. You've already learned 
 about sequences, but they force you to block the calling thread when you're 
 observing values. So let's see what streams have to offer, and how they behave in 
 code.",NA
Streams of data,"One of the key similarities between sequences and streams is that both constructs can 
 generate an infinite amount of elements. Sequences usually do this by defining an 
 operation which you run behind the scenes to build a value.
  
 This is also the key difference between streams and sequences, as you usually build 
 streams using a function or their constructor. You then have an 
 interface
  between the 
 provider of values and a consumer, exposing a different part of the interface to each 
 side.
  
  
 raywenderlich.com
  
 222",NA
Hot streams,"Chapter 14: Beginning with Coroutines Flow
  
 Hot streams behave just like TV channels, or radio stations. They keep sending events, 
 and emitting their data, even though no one may be listening or watching the show. It's 
 why they are called 
 hot
 . As they don't care if there are any observers, they will keep on 
 working and computing no matter what, from the moment you create them, until they 
 close.
  
 This is really good when you want values computed in the background fast, 
  
 preparing them for multiple observers you already have waiting. But if you're going to be 
 adding observers after the fact, then you could lose the data a hot stream might emit 
 between the computation and the observers starting to listen to events.
  
 Additionally, if the producer of values is hot, it can keep on producing values, even 
 though there are no consumers. This effectively wastes resources, and you have to 
 manually close the stream if you stop using it.
  
 If you were to use coroutines to build such hot streams, you'd use the 
 Channel API
 . 
 They are hot by default and also support coroutines, making them a bit less leak-prone. 
 But even if you used 
 structured concurrency
  and coroutines within the 
 Channel
 s, you 
 could potentially leak some resources until the 
 CoroutineScope 
 cancels.
  
 This is why the idea of having a cold stream is important.",NA
Cold streams,"It makes sense that, if hot streams are computed right away, and work even without any 
 observers, 
 cold
  streams do the opposite. They are like the 
 builder pattern
 , where you 
 define a set of behaviors for a construct, upfront, and only when you call a 
 finalizing
  
 function, does it become live and active.
  
 Given that, cold streams are like a social event. You can prepare everything upfront, 
 think of each specific detail you have to fulfill and organize, and only when you're 
 certain that people are coming, does the event happen. Following the analogy, cold 
 streams won't produce or send values, until they have an active 
 Observer
 , to whom they 
 can emit the events.
  
 This is much better, because if there are no observers, there is no need to execute a 
 potentailly heavy operation to produce a value. But if there is at least one observer, then 
 you will compute the value and pass it down the stream, to any amount of consumers.
  
  
 raywenderlich.com
  
 224",NA
Limita+ons of streams,"In every-day programming, there are certain limitations to the way things should 
 operate for optimal use. You don't want to waste resources, freeze the UI, lose data 
 and so on. Some of these concepts apply to streams, as well. These limitations revolve 
 around the same problem - the speed of producing and consuming the values.
  
 If your producer is sending out too many values, and the consumer cannot process them 
 fast enough, then you're bound to lose some data. To effectively process the values, you 
 have to apply 
 backpresure
 . This is the technical term for eliminating the bottleneck in 
 the producer-consumer pair.
  
 When the producer queue fills up, and the consumer can't process the values fast enough, 
 you become bottlenecked from the consumer side. If however, the consumer is eating the 
 values too fast, and it keeps waiting for more to be produced, you're bottlenecked on the 
 producer side. Either way, one side has to halt - 
 block
 , until the pair is balanced again.",NA
Suppor+ng backpressure,"As you've learned, if one side of the producer-consumer pair is too fast or too slow in its 
 job, you will lose data, or end up blocking the non-bottlenecked side. Unless you add 
 backpressure support.
  
 Backpressure can be achieved in different ways, such as using buffered underlying 
 streams with a fixed capacity. This is the easiest solution, but also the most error prone, 
 because you can easily use up a lot of computer memory, or even overflow the buffer. 
 This, again, will cause a bottleneck, and you'll lose data. You could have the capacitiy of 
 unlimited
 , but then you risk overflowing the memory.
  
 Another way is to build a synchronization mechanism, where you'd pause and resume 
 threads as bottlenecks occur, but this may be even worse, as you could be freezing 
 threads for a long time, which is a waste of resources in the end. This is why it's important 
 to 
 avoid blocking threads
 , when building streams with backpressure. 
  
 Because of this design requirement, the 
 Flow API
  is a fresh new take on streams.
  
  
 raywenderlich.com
  
 225",NA
A new approach to streams,"Having the best of both worlds, the 
 Flow API
  supports cold, asynchronously-built streams 
 of values, where the thread communication and backpressure support is implemented 
 through the use of coroutines. When you think about it, it's the perfect combination.
  
 Having coroutines at its foundation allows for 
 backpressure-by-design
 . If your 
 producer is overflowing the consumer, then you can 
 suspend the producer
 , until you 
 free up the queue of events you need to process. On the other hand, if your consumer is 
 really fast, and you need to slow it down - introduce a delay, or a debounce period, all 
 you have to do is apply the same logic - suspend the consumer, until it meets your 
 conditions.
  
 The other happy coincidence of coroutines is the 
 built-in context switching
 . By 
 abstracting away threading and dispatching, through the use of 
 CoroutineContext
 s, you can 
 easily switch the consumption of events from one thread to another, by passing in a 
 different 
 CoroutineContext
  from a 
 Dispatchers
 . And it's performant, because you don't have 
 to worry about thread allocation, since coroutines use predefined thread pools.
  
 This seems a bit too good to be true, right? It feels as if the API will be very 
 complicated, because it has to handle all those details a regular stream cannot 
 intrinsically implement.
  
 Well that's where the fun kicks in. Weirdly enough, Flow works based on only two 
 interfaces - the 
 Flow
  and the 
 FlowCollector
 . For the sake of comparison, if you're coming 
 from a reactive-driven world, the 
 Flow
  would be like an 
 Observable
 , whereas the 
 FlowCollector
  would be something similar to an 
 Observer
  - a 
 subscriber to events
 .
  
 Let's examine how they work.",NA
Building Flows,"To create a 
 Flow
 , just like with standard coroutines, you have to use a 
 builder
 . But first 
 open up 
 Main.kt
 , in the 
 starter project
 , which you can find by navigating to the 
 project files, the 
 starter
  folder, and opening the 
  
 beginning_with_coroutines_flow
  folder.
  
  
 raywenderlich.com
  
 226",NA
Collec+ng and transforming values,"Once you build a 
 Flow
 , you can do many things with the stream, before the values 
 reach the 
 FlowCollector
 . Just like with Rx, or with collections in Kotlin, you can 
 transform the values using operators like 
 map()
 , 
 flatMap()
 , 
 reduce()
  and much more. 
 Additionally, you can use operators like 
 debounce()
 , 
 delayFlow()
  and 
 delayEach()
  to apply 
 backpressure or delays manually for each item, or the entire 
 Flow
 .
  
 Take the following snippet for example:
  
 GlobalScope.launch { 
  
  
  flowOfStrings 
  
  
  .map { it.split(
 "" ""
 ) } 
  
  
  .map { it.last() } 
  
  
  .delayEach(
 100
 ) 
  
  
  .collect { value -> 
  
   
  
  println(value) 
  
  
  } 
  
 }
  
 If you replace the previous way of consuming the 
 Flow
 , and run 
 main()
  again, you'll now 
 see the values are mapped back to the actual numbers, after the 
 String
  is split. 
  
 Furthermore, you print each value with a small delay, ultimately suspending the 
 Flow
  
 until the consumer is ready.
  
 Note
 : All of the operators above are marked with 
 suspend
 , so you have to call 
 them from within a coroutine or another suspending function. This keeps the API 
 uniform, as 
 Flow
 s are built upon coroutines.",NA
Switching the context,"Another thing you can do with 
 Flow
  events, is switch the context in which you'll 
 consume them. To do that, you have to call 
 flowOn(context: CoroutineContext)
 , just like 
 this:
  
 GlobalScope.launch { 
  
  
  flowOfStrings 
  
  
  .map { it.split(
 "" ""
 ) } 
  
  
  .map { it.last() } 
  
  
  .flowOn(Dispatchers.IO) 
  
  
  .delayEach(
 100
 ) 
  
  
  .flowOn(Dispatchers.Default)
  
  
  
 raywenderlich.com
  
 228",NA
Flow Constraints,"Since 
 Flow
  is really easy to use as-is, there have to be some constraints in order to keep 
 people from abusing or breaking the API. There are two main things which each 
 Flow
  
 should adhere to, and each use case should enforce - 
 preserving the context 
 and 
 being 
 transparent with exceptions
 .
  
  
 raywenderlich.com
  
 229",NA
Preserving the Flow context,"As mentioned above, you have to be clean when using 
 CoroutineContext
 s with the Flow 
 API. The producing and consuming contexts have to be the same. This effectively means 
 that you cannot have concurrent value production, because the 
 Flow
  itself is 
 not thread 
 safe
 , and doesn't allow for such emmisions.
  
 So if you try to run the following snippet:
  
 val
  flowOfStrings = flow { 
  
 for
  (number 
 in
 0..100
 ) { 
  
  
  GlobalScope.launch { 
  
   
  emit(
 ""Emitting: 
 $number
 ""
 ) 
  
  
  } 
  
  
  } 
  
 } 
  
 GlobalScope.launch { 
  
  
  flowOfStrings.collect() 
  
 }
  
 You will receive an exception, saying you can't change the 
 Flow
  concurrently.
  
 If you want coroutines to be synchronized, and have the ability to concurrently produce 
 values in the 
 Flow
 , you can use 
 channelFlow()
  instead, and 
 offer()
  or 
 send()
  to emit the 
 values to the 
 FlowCollector
 . Changing the code to the following snippet will work:
  
 val
  flowOfStrings = channelFlow { 
  
 for
  (number 
 in
 0..100
 ) { 
  
  
  withContext(Dispatchers.IO) { 
  
   
  offer(
 ""Emitting: 
 $number
 ""
 ) 
  
  
  } 
  
  
  } 
  
 } 
  
 GlobalScope.launch { 
  
  
  flowOfStrings.collect() 
  
 }
  
 If not, then you should create the 
 Flow
  values in a non-concurrent way, and then use 
 flowOn()
 , to switch the 
 Flow
  to any 
 CoroutineContext
  you want, if you want to avoid using 
 channelFlow()
 .
  
 Additionally, the 
 Flow
 's 
 CoroutineContext
  cannot be bound to a 
 Job
 , and as such you 
 shouldn't combine any 
 Job
 s with the context you're trying to switch the 
 Flow
  to.
  
  
 raywenderlich.com
  
 230",NA
Being transparent with excep+ons,"When dealing with exceptions in coroutines, it's relatively easy to bury them down. For 
 example, by using 
 async()
 , you could effectively receive an exception, but if you never call 
 await()
 , you're not going to throw it for the coroutines to catch. 
  
 Additionally, if you add a 
 CoroutineExceptionHandler
 , when exceptions occur in 
 coroutines they get propagated to it, ending the coroutine.
  
 This is why 
 Flow
  exposes a convenient function which behaves similar to 
 flowOn()
 . 
  
 You can use 
 catch()
 , providing a lambda which will catch any exception you produce in 
 the stream and any of its previous operators. Examine the snippet below:
  
 flowOfStrings 
  
  .map { it.split(
 "" ""
 ) } 
  
  .map { it[
 1
 ] } 
  
  .
 catch
  { it.printStackTrace() } 
  
  .flowOn(Dispatchers.Default) 
  
  .collect { println(it) }
  
 Instead of mapping to 
 it.last()
 , you're using indices. In case you receive an empty string, 
 this will cause an 
 IndexOutOfBoundsException
 . But because you're calling 
 catch()
 , after 
 map()
 , if an exception occurs, you'll catch it, and print its stack trace. This way, you'll be 
 able to handle any exceptions from the original stream and the operators alike.
  
 Change the way you build 
 Flow
 , to this:
  
 val
  flowOfStrings = flow { 
  
  
  emit(
 """"
 ) 
  
  
 for
  (number 
 in
 0..100
 ) { 
  
   
  emit(
 ""Emitting: 
 $number
 ""
 ) 
  
  
  } 
  
 }
  
 You will now cause an exception to be thrown, but you'll see that the program doesn't 
 crash. This is because 
 catch()
  will stop the exception from throwing all the way up to 
 cause your app to crash.
  
  
 raywenderlich.com
  
 231",NA
Key Points,"• Sometimes you need to build more than one value asynchronously, this is usually 
  
 done with 
 sequences
  or 
 streams
 .
  
 •
  Sequences
  are 
 lazy and cold
 , but blocking when you need to consume events. It's 
  
 better to use and suspend coroutines instead.
  
 • If you build 
 streams
  using 
 Channel
 s, then you have coroutine support and 
  
 suspendability, but they are 
 hot
  by default.
  
  
 raywenderlich.com
  
 232",NA
15,NA,NA
Chapter 15: Tes+ng ,"When a new concept enters the programming world, most people want to know how to 
 test the new concept, and if the new concept changes the way you test the rest of your 
 code. Testing asynchronous  code to make sure it runs and functions correction is a good 
 thing. Naturally, people started asking how do you test coroutines, when it's such a 
 different
  mechanism, compared to what used to be used in the JVM world.
  
 The process of testing code is usually tied with writing 
 Unit and Integration tests
 . 
  
 This is code which you can run fast, debug, and use to confirm that a piece of software 
 you've written is still working properly after you apply some changes to the code. Or 
 rather that it doesn't work, because you've changed it, and now you should update the 
 tests to reflect all the remaining cases.
  
 Unit tests run a single 
 unit of code
 , which should be as small as possible - like a small 
 function's 
 input and output
 . Integration tests, however, include a more, well, 
 integrated",NA
GeWng started,"To start with writing tests, you have to have a piece of code that you will test out! 
  
 Open up this chapter's folder, named 
 testing-coroutines
  and find the 
 starter 
 project. 
 Import the project, and you can explore the code and the project structure.
  
 First, within the 
 contextProvider
  folder, you have the 
 CoroutineContextProvider
 , and its 
 implementation. This is a vital part of the testing setup because you'll use this to provide a 
 test 
 CoroutineContext
 , for your coroutines.
  
 class
 CoroutineContextProviderImpl
 ( 
  
  
 privateval
  context: CoroutineContext ) : 
 CoroutineContextProvider { 
  
 }
  
 overridefun
 context
 ()
 : CoroutineContext = context 
  
  
 Next, the 
 model
  package simply holds the 
 User
  which you'll fetch and display in 
 code, and use to test if the code is working properly.
  
 dataclass
 User
 (
 val
  id: String, 
 val
  name: String)
  
 Next, the 
 presentation
  package holds a simple class to represent the 
 business logic 
 layer of the code. You'll use 
 MainPresenter.kt
  to imitate the fetching of a piece of data.
  
 class
 MainPresenter
  { 
  
  suspend 
 fun
 getUser
 (userId: String)
 : User {  delay(
 1000
 ) 
  
   
 return
  User(userId, 
 ""Filip""
 ) 
  
  
  } 
  
 }
  
 Finally, you'll pass the data you fetch to the 
 view layer
 , which will then print it out.
  
 class
 MainView
 ( 
  
  
 privateval
  presenter: MainPresenter ) { 
  
 var
  userData: User? = 
 null
  
 fun
 fetchUserData
 ()
  { 
  
  
  GlobalScope.launch(Dispatchers.IO) { 
  
  userData = 
 presenter.getUser(
 ""101""
 ) 
  
  }
  
  
  
 raywenderlich.com
  
 236",NA
Wri+ng tests for Corou+nes,"If you've never written tests on the JVM, know that there's a couple of different 
 frameworks you can use and many different approaches to testing. For the sake of 
 simplicity, you'll write a simple, 
 value-asserting
  test, using the JUnit4 framework for the 
 JVM test suite.
  
 The name states what the test will do - assert and compare some values. This is one of 
 the most basic test types you could write.  In the 
 Project View
 , open the 
 MainViewTest
  
 file under the 
 test
  -> 
 view
  package. This is where you will begin writing your tests. Next, 
 add the following code:
  
 package
  view 
  
 import
  org.junit.Assert.assertEquals 
 import
  
 org.junit.Assert.assertNull 
 import
  org.junit.Test 
  
 import
  presentation.MainPresenter 
  
 class
 MainViewTest
  { 
  
 privateval
  mainPresenter 
 by
  lazy { MainPresenter() } 
 privateval
  mainView 
 by
  
 lazy { MainView(mainPresenter) } 
  
 @Test 
  
 fun
 testFetchUserData
 ()
  {
  
  
  
 raywenderlich.com
  
 237",NA
SeWng up the test environment,"The problem you're facing when running the test is because of the way coroutines and 
 test environments work internally. Because you're hardcoding the 
  
 MainPresenter
  and 
 MainView
  calls to the 
 GlobalScope
  and 
 Dispatchers.IO
 , you're losing the 
 ability for the test JVM environment to adapt to coroutines.
  
 To avoid this, you have to be explicit about your threading rules in tests, when testing 
 coroutine-related code. There are a couple of small steps you have to take, to fully achieve 
 this, so let's start with the simplest - 
 forcing coroutines to block
 .",NA
Running the tests as blocking,"One of the greatest benefits of coroutines is the ability to 
 suspend instead of block
 . This 
 proves to be a powerful mechanism, which allows for things like simple context switching 
 and thread synchronization, parallelism and much more.
  
  
 raywenderlich.com
  
 239",NA
Using test Corou+neScope and ,NA,NA
Corou+neContext,"To start using 
 runBlockingTest()
 , you have to integrate the rest of the test environment, 
 for coroutines. Two things will ultimately help you control and affect the coroutines and 
 other suspending functions within your test code. The 
  
 TestCoroutineScope
  and 
 TestCoroutineContext
 . Add the following declarations above your 
 testFetchUserData()
  method:
  
 // 1 
  
 privateval
  testCoroutineDispatcher = TestCoroutineDispatcher() 
  
 // 2 
  
 privateval
  testCoroutineScope = 
  
  
  TestCoroutineScope(testCoroutineDispatcher)
  
 These two values will help you dispatch the coroutines in the right contexts and within 
 correct scopes so that you can test them cleanly and correctly. The first is the 
 TestCoroutineDispatcher
 , which helps coroutines run immediately, and with the ability to 
 control internal system clocks. You can also choose to 
 pauseDispatcher() 
 if you need to 
 pause the execution, and to 
 resumeDispatcher()
  when you're ready again.
  
 The second is the 
 TestCoroutineScope
 , which exposes all the functions to control the 
 CoroutineDispatcher
 , and thus changing the execution flow of coroutines. If you pass in a 
 TestCoroutineScope
  to the function call, you effectively fully set up the environment you 
 need, to test coroutines.
  
 But you're still using hardcoded scopes, and contexts, within the 
 MainView
 , which in turn 
 affect the execution and how well the concurrency is structured. Change 
 MainView.kt
  
 to the following:
  
 class
 MainView
 ( 
  
  
 privateval
  presenter: MainPresenter, 
  
  
 privateval
  contextProvider: CoroutineContextProvider, 
  
 privateval
  
 coroutineScope: CoroutineScope 
  
 ) { 
  
 var
  userData: User? = 
 null
  
  
  
 raywenderlich.com
  
 241",NA
Advancing +me,"When you delay a coroutine, you're effectively stating how long it will wait until it 
 resumes again. If you want to 
 skip
  the wait, all you have to do, within a coroutine, is to 
 advance the time by the same amount you're delaying.
  
 The 
 TestCoroutineScope
  exposes a handy function for that, called 
  
 advancedTimeBy(milis: Long)
 . It advances the internal test clock, so you can skip any 
 amount of delaying you have within your code. To fix the broken test, and fully enable 
 testing of your code, change the test snippet to the following:
  
 @Test 
  
 fun
 testFetchUserData
 ()
  = testCoroutineScope.runBlockingTest { 
  
  
 assertNull(mainView.userData) 
  
  
  mainView.fetchUserData() 
  
 // advance the test clock
  
  advanceTimeBy(
 1000
 ) 
  
  
  assertEquals(
 ""Filip""
 , mainView.userData?.name) 
  
  
 mainView.printUserData() 
  
 }
  
 By calling 
 advanceTimeBy(1000)
 , you can skip the 
 delay()
  from within 
 MainPresenter
 s 
 getUser()
  code. Try running the tests now, you should see a positive result! :]
  
 You first check the value to be 
 null
 , fetching data next, advancing the time so that the value 
 is properly set, finally comparing the value to an expected result, and printing it for the 
 sake of clarity. All in all, a good way to check your code works! You should now be ready 
 to test the rest of your coroutine-related code, in your 
  
 applications.
  
  
 raywenderlich.com
  
 243",NA
Summing it up,"Chapter 15: Testing Coroutines
  
 Testing coroutines may not be completely straightforward as it is with regular code 
 which uses callbacks, or blocking calls, but there's a lot of documentation available, and 
 it's fairly easy to set up. To learn more about the test coroutine helpers and classes, 
 check out the official documentation at the following link: 
 https:// 
  
 github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-test
 .",NA
Key points,"• Testing code is extremely useful to prove the 
 stability
  of the software you write.
  
 • Testing usually involves writing 
 unit
  and 
 integration
  tests.
  
 • Commonly, unit tests validate input and output of functions.
  
 • Each unit test should cover one 
 unit of code
 , and be as small as possible.
  
 • Integration tests, on the other hand, validate 
 interaction between layers
  and 
  
 dependencies - the 
 behavior of code
 .
  
 •
  Value-asserting
  tests are most common and simple to write, as they rely on 
  
 comparing the result with expected values.
  
 • A common testing approach is the 
 AAA
  testing.
  
 • AAA stands for 
 Arrange, Act and Assert
 .
  
 •
  Arrange
  sets up all the dependencies and values you need to start testing a unit of 
  
 code.
  
 •
  Act
  calls the necessary functions to change the data or cause some code behavior, 
  
 which you will test.
  
 •
  Assert
  compares the behavior or results provided by acting and checks its validity.
  
 • To test coroutines, you have to set up a 
 coroutine-friendly environment
 .
  
 • To set up such an environment, you need to provide a 
 TestCoroutineScope
  and 
  
 TestCoroutineContext
 .
  
 •
  TestCoroutineScope
  takes care of the lifecycle and delays within 
 launch()
  and 
  
 async()
  
 blocks, making it easier to execute coroutines.
  
  
 raywenderlich.com
  
 244",NA
Sec+on III: Corou+nes & ,NA,NA
Android,"Coroutines are becoming a very important tool for any Kotlin application and in 
 particular for Android applications. They allow the creation of applications that are 
 more readable and use simpler code. In this section, you’ll learn how to use 
  
 coroutines as a valid option for running background tasks which interact with the UI 
 thread.
  
 •
  Chapter 16: Android Concurrency Before Coroutines
 : The Android platform allows 
 you to run background tasks in many different ways. In this chapter, you’ll see and 
 implement examples for all of them. You’ll learn what Looper and Handler are and 
 when to use an AsyncTask. You’ll finally see how coroutines can make the code more 
 readable and efficient.
  
 •
  Chapter 17: Coroutine on Android - Part 1
 : This chapter covers using Kotlin 
 Coroutines in an Android app, covering working with various context; i.e., UI and 
 background to simplify and manage code sequentially. It will cover converting async 
 callbacks for long-running tasks, such as a database or network access into sequential 
 tasks while also keeping track and handling of the app lifecycle.
  
 •
  Chapter 18: Coroutine on Android - Part 2
 : This chapter covers fortifying the use of 
 Kotlin Coroutines in an Android app; i.e., enabling logging, exception handling, 
 debugging and testing of code that uses Kotlin Coroutines. You will also discover the 
 Anko library.
  
  
 raywenderlich.com
  
 246",NA
16,NA,NA
Chapter 16: Android ,NA,NA
Concurrency Before ,"The importance of concurrency was discovered quite early on by people who started 
 with Android development. Android is inherently asynchronous and event-driven, with 
 strict requirements as to which threads certain things can happen. Add to this the often-
 cumbersome Java callback interfaces, and you will be trapped in spaghetti code pretty 
 quickly (aptly termed as “Callback Hell”). No matter how many coding patterns you use 
 to avoid it, you will encounter  state changes across multiple threads in one way or the 
 other.
  
 The only way to create a responsive app is by leaving the UI thread as free as possible, 
 letting all the hard work be done asynchronously by background threads.",NA
GeWng started,"Async Wars
  
 For this chapter, you will use a basic app called 
 Async Wars
  to learn about various 
 async primitives in Android and coroutines at a high level. If you have already 
 downloaded the starter project, then import it into Android Studio.
  
  
 raywenderlich.com
  
 248",NA
Does Android need corou+nes?,"When you start an Android application, the first thread spawned by its process is the 
 main thread, also known as the UI thread. This is the most important thread of an 
 application. It is responsible for handling all the user interface logic, user interaction and 
 also tying the application’s moving parts together.
  
 Android takes this very seriously; if your UI thread is stuck working on a task for more 
 than a few seconds, the Android framework will throw an 
 Application Not Responding
  
 (ANR) error and the app will crash. Most importantly, even small work on the UI/Main 
 thread can lead to your UI freezing, i.e., animations will stop, and the UI will become non-
 responsive to the user interaction; everything will stop until the work is finished.
  
  
 raywenderlich.com
  
 250",NA
Threads,"A thread is an independent path of execution within a program. Every thread in Java is 
 created and controlled by a 
 java.lang.Thread
  instance. A Java program can have many 
 threads, and these threads can run concurrently, either asynchronously or 
 synchronously.
  
 Every Android developer, at one point or another, needs to deal with threads in their 
 application. The main thread is responsible for dispatching events to the appropriate 
 user-interface widget, as well as communicating with components from the Android UI 
 toolkit. To keep your application responsive, it is essential to avoid using the main thread 
 to perform operations that may last for long.
  
 Network operations and database calls, as well as the loading of certain components, are 
 common examples of operations that should not run in the main thread. When they are 
 called in the main thread, they are called synchronously, which means that the UI will 
 remain completely unresponsive until the operation completes.
  
 For this reason, they are usually performed in separate threads, which thereby avoids 
 blocking the UI while they are being performed (i.e., they run asynchronously from the 
 UI).
  
 Sample usage
  
 You can create a thread in two ways:
  
 1. Extending the 
 Thread
  class:
  
 // Creation 
  
 class
 MyThread
  : 
 Thread
 () { 
  
  
 overridefun
 run
 ()
  { 
  
   
  doSomeWork() 
  
  
  } 
  
 } 
  
  
  
 raywenderlich.com
  
 253",NA
AsyncTask,"In Java, you usually put the code you want to run asynchronously into the 
 run 
 method of 
 a class, which implements the 
 Runnable
  interface. This works well if all you need to do is 
 offload work to another thread. However, it becomes cumbersome when you need to 
 relay the results of that thread back to the UI thread.
  
 When Google adopted Java for Android, it released a new type of class called 
 AsyncTask
  
 that made it easier to offload long-running tasks to a background thread, then update the 
 UI thread with the result if there was one. Using 
 AsyncTask 
  
 instances certainly was easier than 
 Runnable
 , but it came with its own set of issues.
  
  
 raywenderlich.com
  
 256",NA
Handlers,"Handler is part of the 
 HaMeR Framework
  (
 Handler
 , 
 Message
  & 
 Runnable
 ),  which is the 
 recommended framework for communication between threads in Android. This is the 
 one used, under the hood, by the 
 AsyncTask
  class.
  
 As you have seen in the previous chapters, threads can share data using queues, which 
 usually have a 
 producer
  and a 
 consumer
 . The producer is the object that puts data into 
 the queue, and the consumer is the object that reads the data from the queue when 
 available.
  
 If the producer runs on thread A and the consumer on thread B, you can use the queue as 
 a communication channel between different threads. This is the idea behind the HaMeR 
 framework. The queue is actually a 
 MessageQueue
 , and the data you pass are encapsulated 
 into a 
 Message
  object. Each 
 Message
  can contain some data or the reference to a 
 Runnable
  
 implementation that defines the code to execute in the thread of the consumer.
  
 If you had to implement the consumer of the queue on your own, you would probably 
 implement it with a cycle that waits for a 
 Message
  and, when available, reads and uses 
 the information into it or else run the code into the 
 Runnable
  object if available. That 
 cycle would be in the 
 run
  implementation of the related 
 Thread 
 class. Android defines 
 this cycle in a class called 
 Looper
 . It’s important to note that you decide the destination 
 thread putting the message into the related queue. This also implies that there is only 
 one 
 Looper
  per 
 Thread
 .
  
  
 raywenderlich.com
  
 260",NA
HandlerThreads,"The UI thread already comes with a 
 Looper
  and a 
 MessageQueue
 . For other threads, you 
 need to create the same objects if you want to leverage the HaMeR framework. 
  
 You can do this by extending the 
 Thread
  class as follows:
  
 // Preparing a Thread for HaMeR 
  
 class
 MyLooperThread
  : 
 Thread
 () { 
  
 lateinitvar
  handler: Handler 
  
 overridefun
 run
 ()
  { 
  
   
 // adding and preparing the Looper
  
  
 Looper.prepare() 
  
  
  
 // the Handler instance will be associated with Thread’s Looper
  
  handler = 
 object
  : Handler() { 
  
  
   
 overridefun
 handleMessage
 (msg: Message)
  { 
  
  
    
 // process incoming messages here
  
  } 
  
  } 
  
  
  
 raywenderlich.com
  
 263",NA
Service,"The definition of a 
 component
  implies the existence of a 
 container
 . You usually 
 describe all your components to the container using some document; the container will 
 create, suspend, resume and destroy components depending on the state of the 
 application or on the available resources on the device.
  
 You would say that the container is responsible for the component’s lifecycle. You can 
 apply the same concept to Android when you describe all your components to the 
 system using the 
 AndroidManifest.xml
  file.
  
 In the example you’ve seen earlier, the component is an 
 Activity
  whose lifecycle 
 depends mainly on the application usage and the available resources. For instance, 
 when the user rotates the device, the activity is destroyed and then re-created — 
 unless you don’t configure it differently.
  
 What happens when you start a task in the background from an 
 Activity
  and then rotate 
 the device? In the case of the 
 HandlerThread
 , you should make it aware of the lifecycle and 
 cancel any tasks, if any, and execute them again. This is not always the best solution — 
 especially in cases of very long tasks like downloading a file.
  
  
 raywenderlich.com
  
 266",NA
Intent service,"As stated previously, 
 Service
  components, by default, are started in the main thread like 
 any other Android component. If you need the service to run a task as a 
  
 background task, then it’s up to you to create a separate thread and move your work to 
 that thread. The Android frameworks also offers a sub-class of 
 Service
  that can do all the 
 threading work for you: 
 IntentService
 .
  
 It runs on a separate thread and stops itself automatically after it completes its work. 
 IntentService
  is usually used for short tasks that don’t need to be attached to any UI. Since 
 IntentService
  doesn’t attach to any activity and it runs on a non-UI thread, it serves that 
 need perfectly. Moreover, 
 IntentService
  stops itself 
  
 automatically, so there is no need to manually manage it, either.
  
 One of the biggest issues with a standard 
 started
  service is that it cannot handle multiple 
 requests at a time, but that is not the case with an 
 IntentService
 . It creates a default worker 
 thread for executing all intents that are received in 
  
 onStartCommand()
 , so all operations can happen off the main thread. It then creates a work 
 queue for sending each intent to 
 onHandleIntent()
  one at a time so that you don’t need to 
 worry about multi-threading issues.
  
 Essentially, there is always only one instance of your 
 IntentService 
  
 implementation at any given time and it has only one 
 HandlerThread
 . This means that if 
 you need more than one thing to happen at the same time, 
 IntentService
 s may not be a 
 good option.
  
  
 raywenderlich.com
  
 268",NA
Sending data from a Service to the UI,"You learned that a started 
 Service
  is an Android component that is not bound to the UI. If 
 you need to send some data from a service to a different component, like an 
 Activity
 , you 
 need some other mechanisms like the 
 LocalBroadcastManager
  that you used via the 
 BroadcasterUtil
  in the previous example. You can see how to send data from a service in the 
 onHandleIntent()
  method of the 
 MyIntentService
  class:
  
 overridefun
 onHandleIntent
 (intent: Intent?)
  { 
 // Download Image 
  
 val
  bmp = DownloaderUtil.downloadImage() 
  
  
 // Send local broadcast with the bitmap as payload
  
  
 BroadcasterUtil.sendBitmap(applicationContext, bmp) }
  
 Here, 
 sendBitmap(applicationContext, bmp)
  is a method defined inside 
 BroadcasterUtil
  class as shown below:
  
 /** 
  
  * Send local broadcast with the bitmap as payload  * @param context 
 Context 
  
  * @param bmp Bitmap 
  
  * @return Unit 
  
  */
  
  
  
 raywenderlich.com
  
 270",NA
Executors,"Chapter 16: Android Concurrency Before Coroutines
  
 You’ve seen that you can encapsulate code into a 
 Runnable
  implementation in order to 
 eventually run it in some given 
 Thread
 . Every object that can execute what’s defined as a 
 Runnable
  can be abstracted using the 
 Executor
  interface, introduced in Java 5.0 as part of 
 the concurrent APIs.
  
 interface
 Executor
  { 
  
  
 fun
 execute
 (command: Runnable) 
  
 }
  
 You can execute a 
 Runnable
  in many different ways. You can, for instance, simply 
 invoke directly the 
 run()
  method or pass the 
 Runnable
  object as a constructor 
 parameter of the 
 Thread
  class and start it, as seen previously. In the former case, you’re 
 executing the runnable code in the caller thread. In the latter, you’re executing the 
 same code into a different thread. This depends on the particular 
 Executor
  
 implementation.
  
 Creating a thread is simple in code but expensive in practice. Every time you create a 
 Thread
  instance you need to request resources from the operative system and every time 
 the thread completes its job — when its 
 run()
  method ends — it must be garbage 
 collected. The typical solution is the usage of a 
 thread pools
 , which need some kind of 
 lifecycle
 .
  
 The pool needs to be initialized with a minimum number of threads. When the 
 application ends, the pools should shut down and release all their resources. Even when 
 the pool is active, you can have a different policy for the minimum number of instances 
 of threads to keep alive or how to manage the creation of new instances when needed. 
 You could limit the number of threads, forcing the client to wait, or create a new thread 
 every time you need to run something. There  is more than the simple 
 Executor
  interface 
 and that is the 
 ExecutorService
  interface.
  
 The 
 ExecutorService
  is then the abstraction for a specific 
 Executor
 , which needs to be 
 initialized and shut down to allow for the execution of 
 Runnable
  objects in an efficient 
 and optimized way. The way this happens depends on the specific 
  
 implementation. One of the most important classes is the 
 ThreadPoolExecutor
 . It manages 
 a pool of worker threads and a queue of tasks to execute.
  
 Depending on the configured policy, it reuses an available thread or creates a new one 
 to consume the tasks from a queue.
  
 The concurrent APIs provide different implementations that are available through 
 some 
 static factory methods
  of the 
 Executors
  class. The most common is
  
  
 raywenderlich.com
  
 273",NA
WorkManager,"Chapter 16: Android Concurrency Before Coroutines
  
 Announced at Google I/O 2018 as part of Jetpack, 
 WorkManager
  aims to simplify the 
 developer experience by providing a first-class API for system-driven 
  
 background processing. The WorkManager API makes it easy to specify deferrable, 
 asynchronous tasks and when they should run. It is intended for background jobs that 
 should run even if the app is no longer in the foreground. Where possible, it delegates 
 its work to a JobScheduler, Firebase JobDispatcher, or Alarm Manager + Broadcast 
 receivers depending on the Android version. If your app is in the foreground, it will 
 even try to do the work directly in your process. The task is still guaranteed to run, 
 even if your app is force-quit or the device is rebooted.
  
 WorkManager chooses the appropriate way to run your task based on such factors as 
 the device API level and the app state.
  
 By default, WorkManager runs each task immediately, but you can also specify the 
 conditions the device needs to fulfill before the task can proceed, including network 
 conditions, charging status and the amount of storage space available on the device. If 
 WorkManager executes one of your tasks while the app is running, it can run your task 
 in a new thread in your app’s process.
  
 If your app is not running, WorkManager chooses an appropriate way to schedule a 
 background task—depending on the device API level and included dependencies. You 
 don’t need to write device logic to figure out what capabilities the device has and 
 choose an appropriate API; instead, you can just hand your task off to 
  
 WorkManager and let it choose the best option.
  
  
 WorkManager Process Flow
  
  
 raywenderlich.com
  
 276",NA
RxJava + RxAndroid,"Reactive programming is an asynchronous programming paradigm concerned with data 
 streams and the propagation of change. The essence of reactive programming is the 
 observer pattern
 .
  
 Note
 : The observer pattern is a software design pattern wherein data sources or 
 streams, called observables, emit data and one or more observers, who are 
 interested in getting the data, subscribe to the observable.
  
 In reactive programming, you are allowed to create data streams from anything 
 including 
 Array
 , 
 ArrayList
 , etc. These data streams can be observed, modified, filtered or 
 operated upon. You can use a stream as an input to another one. You can even use 
 multiple streams as inputs to another stream.
  
  
 raywenderlich.com
  
 277",NA
Corou+nes,"Now that you have a clear idea about various ways of doing asynchronous work in 
 Android, as well as the pros and cons, let’s come back to Kotlin coroutines. Kotlin 
 coroutines are a way of doing things asynchronously in a sequential manner. Creating 
 coroutines is cheap versus creating threads.
  
 Note
 : Coroutines are completely implemented through a compilation 
 technique (no support from the VM or OS side is required), and suspension 
 works through code transformation.
  
  
  
 raywenderlich.com
  
 280",NA
Introducing Anko,"While Kotlin does remove much of the verbosity and complexity typically associated 
 with Java, no programming language is perfect and, thus, libraries that build on top of 
 the language are born. Anko is one such library that uses Kotlin and provides a lot of 
 extension functions to make your Android development easier.
  
 Note
 : That’s how Anko got its name: (An)droid (Ko)tlin.
  
 Anko was originally designed as a single library. As the project grew, adding Anko as a 
 dependency began to have a significant impact on the size of the APK (Android 
 Application Package).
  
  
 raywenderlich.com
  
 282",NA
Key points,"• Android is inherently 
 asynchronous and event-driven
 , with strict requirements 
  
 as to which thread certain things can happen on.
  
 • The 
 UI thread
  — a.k.a., main thread — is responsible for interacting with the UI 
  
 components and is the most important thread of an Android application.
  
 • Almost all code in an Android application will be executed on the 
 UI thread
  by 
  
 default; blocking it would result in a non-responsive application state.
  
  
 raywenderlich.com
  
 283",NA
Where to go from here?,"Phew! That was a lot of background on asynchronous programming in Android! But the 
 good thing is that you made it!
  
 In the upcoming chapters, you will dive deeper into how you can leverage coroutines in 
 Android apps to handle async operations while keeping in sync with various nuances of 
 the Android platform, such as respecting lifecycles of an app and efficient context 
 switching to facilitate the various use cases of apps to fetch-process-display data.
  
  
 raywenderlich.com
  
 285",NA
17,NA,NA
Chapter 17: Corou+nes on ,"Most Android apps are data-consuming apps, meaning that, most of the time, these apps 
 are requesting data from some other source, usually a web service. Android apps run by 
 default on the 
 main
  thread. When it comes to consuming data either from local or 
 remote locations, they use multiple approaches to switch context from the  
 main (or 
 UI)
  thread to a 
 background
  thread in order to offload heavy 
  
 processing and/or long-running tasks, and then back to the 
 main
  thread to convey the 
 result in the UI (you read about many of these approaches in the previous chapter).
  
 Of those many approaches, coroutines stand out as a completely different approach to 
 handling async operations. As was made clear in the previous chapter, coroutines turn 
 out to be the simplest of them all. They make context switching clear, easy and 
 sequential, which, in turn, leads to a lean and readable implementation.",NA
GeWng started,"Coroutines on Android: Part 2
  
 Android apps mainly involve 
 CRUD
  operations on information (i.e., Create, Read, 
 Update, Delete). The information can be accessed either from the local database or from 
 a remote server via network calls, which can be a long-running task. Since the Android 
 OS executes tasks by default on the main/UI thread, executing such long-running tasks 
 can freeze your app, or crash the app and show an ANR (Application Not Responding) 
 error.
  
 Coroutines are a Kotlin feature that allows you to write asynchronous code in a sequential 
 manner while still ensuring that long-running operations, such as database or network 
 access, are properly dispatched to run in the background, which keeps the UI thread from 
 being blocked. Once the long-running or high-processing task complete, the result is 
 dispatched to the main/UI thread in an obvious manner.
  
 For this chapter, you will use a simple Android app called 
 StarSync
 , which is an offline 
 first 
 MVP
  (Model-View-Presenter) app. There is a repository that takes care of fetching 
 data from the 
 SWAPI
  API, which is a public 
 Star Wars
  API. You can access the 
 documentation for the same at 
 https://swapi.co
 . The SWAPI API is pretty straight 
 forward and completely public. You don’t even need to set up a token. Once fetched, the 
 data is saved to the local database using the Room architecture components library.
  
  
 raywenderlich.com
  
 287",NA
What’s in the context?,"When talking about Android apps, one cannot ignore the pain around multi-
  
 threading. Android apps are limited to a single main thread for all processing and this 
 makes it difficult to build highly responsive and performant apps. If a lot of processing is 
 done on the main thread, the UI can become non-responsive and eventually lead to an app 
 crash. To avoid that, do all heavy processing on a 
  
 background thread. This is easy to achieve because one can simply start a thread or a pool 
 of threads to offload the heavy processing.
  
 It becomes tricky when the heavy processing completes and the result needs to be 
 updated in the UI — i.e., back in the main thread. Switching back to the main thread isn’t 
 as easy it sounds. Passing values across threads is very painful and this is the reason 
 Android has constructs like AsyncTask, which switch from background thread to the main 
 thread automatically.",NA
Corou+neDispatcher,"The CoroutineDispatcher determines what thread or threads the corresponding 
 coroutine uses for its execution. It can confine (restrict) coroutine execution to a 
 specific thread, dispatch it to a thread pool, or let it run unconfined (unrestricted).
  
 In the simplest terms, it defines where your piece of code executes — i.e., on the 
 main thread, background thread or a pool of threads.
  
  
 raywenderlich.com
  
 291",NA
Corou+neScope,"Each coroutine runs inside a scope defined by you, so you can make it app-wide or 
 specific for an Android component with a well-defined life cycle, such as an Activity or 
 Fragment. The scope here is represented by the class name 
 CoroutineScope
 . Each 
 coroutine waits for all the coroutines inside their block/scope to complete before 
 completing themselves. A scope controls the lifetime of coroutines through its job. 
  
 When you cancel the scope's job, it cancels all coroutines started in that scope, i.e. 
 when the user navigates away from an Activity or Fragment.
  
 Note
 : Every coroutine builder is an extension of CoroutineScope and inherits its 
 coroutineContext to automatically propagate both context elements and 
 cancellation.
  
  
  
 raywenderlich.com
  
 295",NA
Conver+ng exis+ng API call to use ,NA,NA
corou+nes,"On Android, to guarantee a great and smooth user experience, the app needs to function 
 without any visible pauses. Most pauses are usually noticeable when the device cannot 
 refresh the screen at 60 frames per second. On Android, the main thread is a single thread 
 responsible for handling all updates to the UI, calls to all click handlers and other UI 
 callbacks. Common tasks, such as writing data to a database or fetching data from the 
 network, usually take longer than 16ms to do and this long processing time makes it hard 
 to keep screen refresh rates at 60 frames per second. Therefore, calling code like this from 
 the main thread can cause the app to pause, stutter, or even freeze. Moreover, if you block 
 the main thread for too long, the app may even crash and present an Application Not 
 Responding dialog.
  
 For performing long-running tasks without blocking the main thread, callbacks are a 
 common pattern you can use. By using callbacks, you can start long-running tasks on a 
 background thread. When the task completes, the callback is called to inform you of the 
 result on the main thread.
  
 If you look at the implementation of the 
 getData()
  method inside the 
 MainActivityPresenter
  class, you will find:
  
 overridefun
 getData
 ()
  { 
  
  
  
 // Start loading animation
  
  view?.showLoading() 
  
 } 
  
  
 // Fetch Data
  
  fetchData() 
  
 privatefun
 fetchData
 ()
  { 
  
  
 when
  (processingUsing) { 
  
  
  
  
 // 1
  
  
  
  ProcessUsing.BackgroundThread -> 
  
  
  
 raywenderlich.com
  
 298",NA
Corou+nes and Android lifecycle,"Android apps consists of various components, which have a lifecycle of their own such 
 as Activities, Fragments, Services, etc. Processing done outside the lifecycle of these 
 components can lead to memory leaks or crashes in general. For example, if the Activity 
 is destroyed and an async processing task — after finishing its work — tries to update 
 the UI of the Activity, it will lead to a crash. This is a serious problem when it comes to 
 configuration changes, such as when the phone is rotated.
  
 Coroutines are not free from such issues; however, they are well prepared to handle 
 them. One of the important concepts that can be used to combat these lifecycle issues is 
 to confine the CoroutineScope to the lifecycle of the Android component.
  
 To do that, you will need to observe the lifecycle of the Android component. Such 
 functionality is available via the Architecture Components Libraries. These libraries 
 consist of a 
 LifecycleObserver
  and 
 DefaultLifecycleObserver
  interfaces to enable 
 observing the lifecycle of a lifecycle owner.
  
 You already set up a CoroutineScope for the presenter. All you need to do now is to 
 make sure the presenter adheres to the lifecycle of the Activity. When the Activity goes 
 to the 
 onDestroy()
  state, it will call the presenters  
 cleanup()
  method, thus canceling all 
 the coroutines within the presenters CoroutineScope and its siblings. 
  
 This process makes sure there are no coroutines running once the Activity is 
 destroyed. This concurrency mechanism is called 
 Structured Concurrency
 .
  
 To implement this functionality, go to your app’s 
 build.gradle
  file and replace 
 // TODO: 
 add lifecycle dependencies here
  under the dependencies section with the following, and 
 sync your project:
  
  
 raywenderlich.com
  
 301",NA
Corou+nes and WorkManager,"WorkManager
  is a simple library that is a part of Android Jetpack, used for deferrable 
 background work. It enables a combination of 
 opportunistic
  and 
 guaranteed
  
 executions. Opportunistic execution means that WorkManager will do your background 
 work as soon as it can. Guaranteed execution means that 
  
 WorkManager will take care of the logic to start your work under a variety of situations, 
 even if you navigate away from your app.
  
 Some examples of tasks that are a good use of WorkManager include:
  
 • Uploading logs
  
 • Periodically syncing local data with the network
  
 • Applying filters to images and saving the image
  
 To enable coroutine support in WorkManager, you need the dependency shown 
 below, which is already added to the starter project.
  
 dependencies { 
  
  
 // Other dependencies
  
  
  
 final
  workManagerVersion = 
 ""2.1.0""
  
  implementation 
 ""androidx.work:work-runtime-ktx: 
 $workManagerVersion"" 
  
 }
  
 To define background work in WorkManager, you extend 
 Worker
  and implement 
 doWork()
 . However, when dealing with Coroutines, you would extend from 
 CoroutineWorker
  and implement the 
 doWork()
  method, which is a suspend 
 marked method; thus, it will not block the main thread when called.
  
  
 raywenderlich.com
  
 304",NA
Key points,"Chapter 17: Coroutines on Android - Part 1
  
 1.
  CoroutineDispatcher
  determines what thread or threads the corresponding 
  
 coroutine uses for its execution.
  
 2. A coroutine can switch dispatchers any time after it is started.
  
 3.
  Dispatchers.Main
  context for Android apps, allows starting coroutines confined 
  
 to the main thread.
  
 4. Each coroutine runs inside a defined scope.
  
 5. A Job  
 must
  be passed to CoroutineScope in order to cancel all coroutines started 
  
 in the scope.
  
 6. Coroutines can replace callbacks for more readable and clear code 
  
 implementation.
  
 7. 
  
 Making 
 CoroutineScope
  lifecycle aware helps to adhere to the lifecycle of 
  
 android components and avoid memory leaks.
  
 8. Coroutines seamlessly integrate with WorkManager to run background jobs 
  
 efficiently.",NA
Where to go from here?,"This chapter introduced the concept of using coroutines in an Android app. The concept 
 of various contexts was also covered and how to switch between them when required, 
 all while being able to react to lifecycle events in an Android app.
  
 In the next chapters, you will be working your way through the topics testing, 
 debugging and logging with Coroutines, which are the most important aspects of 
 building a solid Android app.
  
  
 raywenderlich.com
  
 308",NA
18,NA,NA
Chapter 18: Corou+nes on ,"Developing Android apps can get complex when dealing with asynchronous tasks. It is 
 not immediately clear on what thread the code is executing, and trying to figure it out 
 usually involves adding logging statements and debugging the code flow. More 
 importantly, it is the best practice to be able to test the business logic of complex 
 asynchronous tasks. It gets fairly more complex when coroutines are added to the 
 system.
  
 As you know by now, there could be hundreds of coroutines, and they can be executed 
 easily because they are very lightweight. Now, imagine trying to debug a codebase 
 wherein hundreds of these coroutines are executing. Thankfully, there are ways to 
 handle those and the tooling/libraries are built to address such situations.
  
 All of this and more will be covered in this chapter while working with an Android 
 app. Without much ado, jump over to the next section in this chapter.",NA
GeWng started,"For this chapter, you will start from where you left off in the last chapter, with the 
 Android app called 
 StarSync
 . As you already know, the app is an offline first MVP app. 
 There is a repository that takes care of fetching data from the 
 SWAPI
  API, which is a 
 public Star Wars API. You can access the documentation for the same at 
 https://swapi.co/
 . Once fetched, the data is saved to the local database using the Room 
 architecture components library.
  
 If you have already downloaded the starter project, then import it into Android 
 Studio.
  
 Run the starter app now and you will see the following:
  
  
 Starter App
  
  
 raywenderlich.com
  
 310",NA
Debugging corou+nes,"When you run the app, the various processes of fetching data from the local and remote 
 repository’s are fired up using multiple coroutines. At the same time, there is context 
 switching from executing a fetch operation on the background and then switching to the 
 main thread to display the result when it is available.
  
 While developing your app, you often need to know the name of the coroutine in which 
 your code is executed, mostly in order to debug the app. Having that 
  
 functionality makes visualizing the coroutines while they are executing much easier to 
 follow. There is a utility method 
 logCoroutineInfo
  already setup in 
  
 Extensions.kt
  file:
  
 // Log Coroutines 
  
 fun
 logCoroutineInfo
 (msg: String)
  = println(
 ""Running on: [
 $ 
 {Thread.currentThread().name}
 ] | 
 $msg
 ""
 )
  
 All it does is simply print to the standard output with a formatted text that includes the 
 name of the thread. You can use this right away in the starter project.
  
 Go to 
 RemoteRepo.kt
  first, under package 
 repository/remote
 . Now, find the method 
 getDataUsingCoroutines()
  and replace the line with comment 
 // TODO: Add a log with msg 
 ’Fetching from remote’
  with line of code as below:
  
 logCoroutineInfo(
 ""Fetching from remote""
 )
  
 Next, go to 
 MainActivityPresenter.kt
  under 
 ui/mainscreen
  package and find the method 
 fetchUsingCoroutines()
 . You will now add a couple of log statements by replacing 
 TODO
  
 comments as below
  
 Replace 
 // TODO: Add a log with msg ’launch executed’
  with:
  
 logCoroutineInfo(
 ""launch executed""
 )
  
 Replace 
 // TODO: Add a log with msg ’Fetching from local’
  with:
  
 logCoroutineInfo(
 ""Fetching from local""
 )
  
  
  
 raywenderlich.com
  
 312",NA
Excep+on handling,"Exception handling in coroutines was covered in previous chapters extensively, thus our 
 focus here will be on their behavior on the Android platform.
  
 Before you look into how exceptions are handled by coroutines on Android, 
 understand what actually happens when an exception is thrown in a coroutine:
  
 1. The exception is caught and then resumed through a 
 Continuation
 .
  
 2. If your code doesn’t handle the exception, and it isn’t a 
 CancellationException
 , the 
 first 
 CoroutineExceptionHandler
  is requested through the current 
  
 CoroutineContext
 .
  
  
 raywenderlich.com
  
 315",NA
Don’t forget tes+ng,"Tests in an Android app are one of the most important aspects of building a quality app. 
 Having tests in place makes sure that the business logic is correct and the app executes 
 as expected. When it comes to asynchronous programming, it becomes even more 
 important to have tests in place. Because of complex timing and execution states, the 
 multi-threaded nature of async operations on the Android platform increases the 
 chances of errors.
  
 One can spawn multiple Kotlin coroutines on a background thread or the main thread. But 
 when it comes to testing, you want to set a specific thread on which your tests run, 
 thereby removing ambiguity around where the coroutines are executing and eliminating 
 context switching completely. To enable that kind of functionality, you will need to make 
 sure you can specify the 
 Dispatchers
  your coroutines run on.
  
 In the starter app, you will notice all the coroutines are executing inside the 
 MainActivityPresenter
  class with each having their own 
 Dispatcher
  defined to execute 
 on. You need to now modify the 
 MainActivityPresenter
  class under 
 ui/ mainscreen
  
 package so that its constructor can take in two more arguments as below:
  
 class
 MainActivityPresenter
 (
 var
  view: ViewContract?, 
  
  
  
 var
  repository: DataRepositoryContract?, 
  
  uiDispatcher: CoroutineDispatcher = Dispatchers.Main, 
  
  
 val
  
 ioDispatcher: CoroutineDispatcher = Dispatchers.IO)
  
 Notice the two new arguments now being passed to the primary constructor of the 
 MainActivityPresenter
  class. To make sure the API does not break, default values are 
 provided.
  
  
 raywenderlich.com
  
 320",NA
Anko: Simplified corou+nes,"Kotlin coroutines are essentially a language feature. Similar to how the standard 
 kotlin.coroutines
  library builds upon them, 
 Anko (ANdroid KOtlin)
  coroutines is another 
 library that is based on the 
 kotlin.coroutines
  library, providing simpler syntax and 
 approach to async programing.
  
 Anko is a helper library built by the folks at JetBrain. Anko was originally designed as a 
 single library. As the project grew, adding Anko as a dependency began to have a 
 significant impact on the size of the APK, hence it was split out into sub-libraries, namely:
  
 •
  Commons
 : Helps you perform the most common Android tasks, including 
  
 displaying dialogues and launching new Activities.
  
 •
  Layouts
 : Provides a Domain Specific Language (DSL) for defining Android layouts.
  
 •
  SQLite
 : A query DSL and parser that makes it easier to interact with SQLite 
  
 databases.
  
 •
  Coroutines
 : Supplies utilities based on the 
 kotlinx.coroutines
  library.
  
 Anko-Coroutines
 , as of writing this chapter, provides access to only one helper 
 method called 
 asReference()
 .
  
 By default, a coroutine holds references to captured objects until it is finished or 
 cancelled. That means in the Android world, it will capture/hold on to the instance of 
 Activity or Fragment, until it is finished or cancelled. If not cancelled/finished, this might 
 lead to memory leaks.
  
  
 raywenderlich.com
  
 327",NA
Key points,"Android is an ever-evolving platform,  each year a new flavor of Android is released. The 
 complexity with each new release around async processing also increases as new APIs are 
 released. New devices with completely different setups are being released, such as 
 foldable phones. Handling the Activity/Fragment lifecycles and managing the app states is 
 going to become more complex. Thankfully, Kotlin coroutines are a step forward in 
 simplification of async processes, enabling well testable apps.
  
  
 raywenderlich.com
  
 330",NA
C,"Congratulations! After a long journey you learned a lot of new concepts about 
 multithreading and concurrent programming with Kotlin. With coroutines, you can now 
 execute tasks in the background using the proper data structure and the best coroutine 
 launcher. You now have the fundamentals of coroutines, like context and dispatcher, 
 flows, and you are able to learn all the new exciting APIs that the coroutine team is 
 going to release in the future.
  
 If you're an Android developer you've also learned how to use coroutines along with 
 the Activity and Fragment lifecycles with better and more efficient use of the device 
 resources.
  
 Finally, you learned how to use coroutines in different environment like Java.
  
 And, remember, if you want to further your understanding of Kotlin and Coroutine 
 app development after working through 
 Kotlin Coroutines
 , we suggest you read the 
 Android Apprentice
 , available on our online store:
  
 •
  https://store.raywenderlich.com/products/android-apprentice
  
 If you have any questions or comments as you work through this book, please stop by our 
 forums at 
 http://forums.raywenderlich.com
  and look for the particular forum category 
 for this book.
  
 Thank you again for purchasing this book. Your continued support is what makes the 
 tutorials, books, videos, conferences and other things we do at raywenderlich.com 
 possible, and we truly appreciate it!
  
 Wishing you all the best in your continued Kotlin and Coroutine adventures,
  
 – The 
 Kotlin Coroutines by Tutorials
   team
  
  
 raywenderlich.com
  
 332",NA
