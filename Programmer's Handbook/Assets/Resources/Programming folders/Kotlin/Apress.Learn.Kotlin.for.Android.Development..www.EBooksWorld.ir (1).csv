Larger Text,Smaller Text,Symbol
Learn Kotlin ,NA,NA
for Android ,NA,NA
Developme,NA,NA
nt,NA,NA
The Next Generation Language ,NA,NA
for ,NA,NA
Modern Android Apps ,NA,NA
Programming,NA,NA
—,NA,NA
Peter Späth,www.EBooksWorld.ir,NA
Learn Kotlin for ,NA,NA
Android ,NA,NA
Development,NA,NA
The Next Generation Language ,NA,NA
for ,NA,NA
Modern Android Apps ,NA,NA
Programming,NA,NA
Peter Späth,NA,NA
To Alina,www.EBooksWorld.ir,NA
Table of Contents,"About the Author xvii
  
 About the Technical Reviewer xix
  
 Introduction xxi
  
 Chapter 1
 : 
 Your First Kotlin Application: Hello Kotlin  1 
 Setting Up an IDE: Android 
 Studio  1 Connecting Your Android Device  3 Starting Your First Kotlin App  5 Setting 
 Up and Using Emulators  6 Continuing with the HelloKotlin App  8 Using the 
 Command Line  12
  
 Chapter 2
 : 
 Classes and Objects: Object Orientation Philosophy  15 
 Kotlin and 
 Object-Oriented Programming  18 Class Declaration  18 Exercise 1  19 Property 
 Declaration  20 Exercise 2  21 Exercise 3  21 Class Initialization 22 Exercise 4  23 
 Exercise 5  23 An Invoice in Kotlin  24 More Invoice Properties  25 Invoice Initialization  
 25 Exercise 6  26 Instantiation in Kotlin  26
  
 v
  
 www.EBooksWorld.ir",NA
About the Author,"Peter Späth
  graduated in 2002 as a physicist and soon afterward became an IT 
  
 consultant, mainly for Java-related projects. In 2016 he decided to concentrate on 
 writing books on various subjects, with a primary focus on software development. With 
 a wealth of experience in Java-related languages, the release of Kotlin for building 
 Android apps made him enthusiastic about writing books for Kotlin development in the 
 Android environment.
  
 xvii
  
 www.EBooksWorld.ir",NA
About the Technical Reviewer,"Ted Hagos
  is the CTO and Data Protection Officer of RenditionDigital International 
 (RDI), a software development company based out of Dublin. Before he joined RDI, he 
 had various software development roles and also spent time as a trainer at IBM 
 Advanced Career Education, Ateneo ITI, and Asia Pacific College. He spent many years 
 in software development, dating back to the days of Turbo C, Clipper, dBase IV, and 
 Visual Basic. Eventually, he found Java and spent many years working on Java-related 
 projects. Nowadays, he’s busy with full-stack JavaScript and Android.
  
 xix
  
 www.EBooksWorld.ir",NA
Introduction,"Computer programs are for executing operations using input data to produce output 
 data, sometimes by manipulating data taken from a database during that operation. 
  
 The word 
 database
  here is used in the most general sense: It could be a file, some 
 memory storage, or a full-fledged database product.
  
 Many different programming languages exist nowadays, each with its own merits 
 and drawbacks. Some of them aim at execution stability, some at high performance, 
 some are tailored to solve specific tasks, and some exist only because a company wants 
 to establish a strong market position. Looking at the way programming languages have 
 developed over time is an interesting subject in and of itself, and it has implications for 
 various aspects of information technology. One could write a separate book about that, 
 but for this book I simply want to stress one important fact about computer language 
 development, which I think has a direct effect on the way modern computer programs 
 are written. If you are looking at the historical development of computer languages, you 
 will notice a substantial change in the 
 abstraction level
  the languages exhibit. Whereas in 
 the infancy of the industry a programmer needed to have a fairly good knowledge of 
 computer hardware, now different levels of abstraction have been introduced into the 
 languages, meaning an increased conceptional and linguistic distance from hardware 
 features. This has increasingly alleviated the requirement that software developers 
 know what is occurring in a computer’s central processing unit (CPU).
  
 Along with an increasing level of abstraction, modern computer languages—
 sometimes implicitly, sometimes explicitly—exhibit a prominent new feature: the 
 expressiveness
  of language constructs. Let me try to illustrate this using an example 
 written in pseudo-code. Let’s say you have a list of items and want to perform an 
 operation on each of the items. With some knowledge of the internal functioning of 
 computers, a programmer might write a code snippet like this:
  
 • Create some array of data in the memory.
  
 • Assign a pointer to the first element.
  
 • Loop over the array.
  
 xxi
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 Making your code expressive from the very beginning will not only ,NA,NA
"help you to write good code, it will also help you to develop your ",NA,NA
programming skills beyond average. expressive code is easier to ,NA,NA
"maintain and extend, easier to reuse, easier to understand for others, ",NA,NA
and easier to debug if the program shows some deficiencies.,"The programming language Kotlin is capable of getting us to such an extent of 
 expressiveness, and in this book I want to introduce Kotlin as a programming language 
 for Android that allows you to accomplish things in an expressive and concise way. As a 
 matter of fact, in Kotlin the little looping example, with a filter added, reads:
  
 arrayOf(""Blue"", ""Green"", ""Yellow"", ""Gray"").
  
  filter 
 { it.startsWith(""G"") }.
  
  forEach { item ->
  
  
  println(item)
  
  }
  
 If you run this, it will print the text Green Gray on two lines of the console. 
 With the notion of parameters being placed inside round brackets, you should be 
 able to understand this snippet without knowing a single Kotlin idiom.",NA
Note,NA,NA
" don’t worry if you don’t know how to write and run this, we’ll ",NA,NA
be getting our feet wet very soon in the first chapter of the book.,"Once you reach the end of the book, you should be an advanced developer able to 
 address problems in the Kotlin language, with particular attention on Android matters. 
 Of course, you will not know all possible libraries that are out there in the wild for 
 solving specific problems, as only experience will help you there. Knowing most of the 
 language constructs and having good ideas concerning programming techniques, 
 however, will set you on the way to become an expert programmer for Android.
  
  
 The Kotlin version referred to in this book is 1.3. Most of the examples and most of 
 what gets explained here is likely valid for later versions as well.
  
 xxiii
  
 www.EBooksWorld.ir",NA
 The Book’s Target Audience,"The book is for beginning software developers with little or no knowledge of 
  
 programming, and for developers with knowledge of other languages who are 
 interested in using Kotlin for future Android projects. The target platforms are Android 
 devices. The book is not meant to present a thorough introduction into Android; instead, 
 it uses Android as a platform as is and thoroughly introduces the Kotlin programming 
 language and how it gets used for Android.
  
 Basic knowledge of how to use a desktop or laptop computer, including the 
 installation and starting of programs, is expected. The operating system you want 
 to use plays no major role, but because we are using Android Studio as a 
 development environment, you must choose an operating system able to run this 
 integrated development environment (IDE). This is the case for Linux, Windows, 
 and Mac OS. Screenshots are taken from an Ubuntu Linux installation.
  
  
 In the end, you will be able to write and run Kotlin programs for Android of 
 beginning to midlevel complexity.",NA
 Source Code,"All source code shown or referred to in this book can be found at 
  
  
 https://github.com/Apress/learn-kotlin-for-android-development",NA
 How to Read This Book,"Reading this book sequentially from the beginning to the end will provide the maximum 
 benefit. If you already have some basic development knowledge, you can skip sections 
 and chapters at will, and of course you can always take a step back and reread sections 
 and chapters while you are advancing through the book.
  
 xxiv
  
 www.EBooksWorld.ir",NA
CHAPTER 1,NA,NA
Your First Kotlin ,NA,NA
Application: Hello ,NA,NA
Kotlin,"In this chapter we are going to learn how to use the Android Studio integrated 
 development environment (IDE) to write and execute a first simple Kotlin program.",NA
 Setting Up an IDE: Android Studio,"Although computer programs could be written in simple text editors and then prepared 
 and executed by some system-level commands entered in a system terminal, using an 
 IDE helps in keeping project files together and also simplifies various development-
 related activities.",NA
Note,NA,NA
 Computer languages come in two flavors: Either you have some ,NA,NA
program code that by some execution engine gets interpreted while the ,NA,NA
"program is running and then executed on the CPU, or you have a ",NA,NA
compiling,NA,NA
 language with a special preparatory system command first ,NA,NA
translating the program code into a ,NA,NA
compiled ,NA,NA
program that can be ,NA,NA
directly executed by the operating system or by some specially tailored ,NA,NA
execution engine. Kotlin is such a compiling language. If you use an IDE ,NA,NA
"like Android Studio, the compilation step usually is automatically done ",NA,NA
for you.,"In this book we use Android Studio as an IDE. It is developed by Google, Inc., and based 
 on the community edition of the IntelliJ IDEA. You can freely download, install, and use 
 it. As of this writing, the download page is hosted at 
 https://developer. 
 android.com/studio/
 . If that link is not functioning, you can easily find the download",NA
Note,NA,NA
 To open a terminal in Ubuntu Linux press Ctrl+Alt+T. Inside the ,NA,NA
"terminal, commands need to be entered using the keyboard. To change ",NA,NA
to a directory enter cd /path/to/directory. To start a .sh file enter ,NA,NA
./name.sh,"The details of the installation depend on your operating system specifics, including 
 the operating system version, and also the version of your Android Studio download. 
  
 The page where you downloaded Android Studio will give you more details and even 
 present videos for the installation procedure.
  
 In any case the installer for Android Studio will download additional components. 
 The same holds for the Project Wizard when you create new projects, depending on the 
 features needed for the project and also depending on the components already installed. 
 You thus need to have some patience before you can start your first project; subsequent 
 startups will, of course, be faster.
  
 Proceed with the installer up to the point where you are being asked whether you 
 want to create a new project. For Linux this will look like Figure 
 1-1
 , and for other 
 operating systems you will be presented something similar.
  
 2",NA
 Connecting Your Android Device,"First it is important to say that for developing Android apps you don’t necessarily need 
 to have a real hardware device at hand. In the section “Setting Up and Using Emulators” 
 later in this chapter, we talk about how to use emulators to simulate Android devices. 
  
 For professional apps, however, it is a good idea to have at least one Android hardware 
 device at hand.
  
 Android Studio allows for working with both real and simulated devices. To work 
 with only a real device like a smartphone obviously can give you the most profound 
 assurance your app is running. However, it will tell you only your smartphone can 
 operate your app; you cannot be sure other devices will be just as happy with it. You 
 certainly don’t want to buy dozens of different smartphones and other Android devices. 
 Likewise, though, working only with simulated devices and not with a real device cannot 
 give you 100 percent assurance your app works on any real devices.
  
 3
  
 www.EBooksWorld.ir",NA
 Starting Your First Kotlin App,"It is now time to write our first Kotlin application inside Android Studio. From the 
 installation step where you are being asked whether you want to create a project, or 
 after you start an installed Android Studio instance the first time, or from inside a 
 running Android Studio at File 
 ➤
  New 
 ➤
  New Project, inside the menu, proceed as 
 follows:
  
  1. Select or click Start a New Android Studio Project.
  
  2. Inside the Project Wizard, as the application name, enter 
  
 HelloKotlin. Although not strictly necessary, it is better to avoid 
 space characters inside the name.
  
  3. For company domain, enter example.com. Aside from not using 
 spaces, what you enter here is up to you. It is, however, good 
 practice to enter a real domain name you or your company owns. 
  
 For projects you know you will never publish, choose 
 whatever you like.
  
  4. The project location that Android Studio suggests is decent 
 enough, but if you like you can choose a different one.
  
  5. Make sure Include Kotlin support is selected.
  
  6. Choose Phone and Tablet as a form factor.
  
  7. Choose API 19 as a minimum software development kit (SDK).
  
  8. Choose Empty Activity. As Activity name, use the suggested 
 MainActivity. Make sure Generate Layout File is selected, and as 
 a layout name, accept the suggested activity_main. Make sure 
 Backwards Compatibility is selected as well.
  
 The first time you create a project Android Studio will automatically download and 
 install any additional components it needs, and then it also performs an initial build. 
 This will take several minutes, so be patient here.
  
 At this point if everything worked well the Android Studio main window will appear as 
 shown in Figure 
 1-3
 .
  
 5
  
 www.EBooksWorld.ir",NA
 Setting Up and Using Emulators,"Now it is time to install a device emulator. Emulators are very handy, because they allow 
 for developing Android apps without having to connect a real device. Emulators 
 simulate Android devices on your computer’s screen. To install one of the several 
 available, go to Tools 
 ➤
  AVD Manager. The screen that appears shows the title Your 
 Virtual Devices. Click Create Virtual Device. The following screen shows a device list, as 
 shown in Figure 
 1-4
 .
  
 6
  
 www.EBooksWorld.ir",NA
 Continuing with the HelloKotlin App ,"Back in the Android Studio main window, on the left side inside the app, by clicking 
 on the small triangles next to the names you can navigate to the following files (see 
 Figure 
 1- 6
 ): 
  
 app →  java →
  
  
  com.example.hellokotlin → MainActivity 
  
 app →  res →
  
  
  layout →  activity_main.xml
  
 8
  
 www.EBooksWorld.ir",NA
 Using the Command Line,"Although you can continue using Android Studio for working on projects to any depth, it 
 is also possible to use the command line in a terminal to build and run apps. If you want 
 to continue using Android Studio, you can safely skip this section. For all others, I want 
 to describe how to use a terminal to build apps, and more precisely the HelloKotlin app 
 we created in the last section.
  
 12
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" Using the command line helps, for example, in cases where you ",NA,NA
"don’t have a desktop environment, like on servers. You can also use it in ",NA,NA
"an automated build environment where developers provide the code, ",NA,NA
but the program to be executed on Android devices is generated ,NA,NA
automatically.,"Interestingly, Android Studio helps us to get rid of itself. For any project you have 
 successfully built inside Android Studio, the folder containing the project files also will 
 contain specially tailored build scripts that you can use to build apps without using 
 Android Studio.
  
 First we need to open a terminal: In Ubuntu Linux, press Ctrl+Alt+T. In Windows you 
 find a terminal by searching for CMD in the system menu. For Apple Mac OS, a terminal 
 can be opened after you search for Terminal in Spotlight. Next we need to know where 
 in the file system the project files reside. If you accepted the suggestion Android Studio 
 gave while creating the project, the paths will be as follows:
  
 /home/[USER]/AndroidStudioProjects/HelloKotlin
  
  for 
 Linux 
  
 /Users/[USER]/AndroidStudioProjects/HelloKotlin
  
  for 
 Mac OS X 
  
 C:�sers\[USER]\AndroidStudioProjects\HelloKotlin
  
  for 
 Windows
  
 where [USER] is your logon username. If you used a custom project location instead, you 
 have to use that one.
  
 Fluently using a terminal is an art and we won’t go into details here. The following 
 commands will, however, give you a starting point. Inside the terminal we change to the 
 project folder as follows:
  
 cd [PATH]        #for Linux and Mac OS X and Windows
  
 where [PATH] is the project folder we just determined. From here we can build the 
 app by entering
  
 ./gradlew app:build      #for Linux and Mac OS X gradlew   
 app:build      #for Windows
  
 13",NA
Note,NA,NA
 The gradlew command belongs to the Gradle build system. ,NA,NA
Gradle gets used throughout Android Studio for building executable ,NA,NA
apps.,"The final app as an APK file with an .apk suffix will now show up inside app/build/ 
 outputs/apk/debug/. The APK comes from Android PacKage; such a file is a compressed 
 collection of all the files Android needs to install an app on your device. The gradlew 
 wrapper script actually allows for many more options to build and investigate projects. 
 Enter -help or tasks as an argument to have them all listed.
  
 ./gradlew –help    #for Linux and Mac OS X 
 ./gradlew tasks    #for Linux and Mac OS X 
 gradlew –help      #for Windows 
  
 gradlew tasks      #for Windows
  
  
 For the tasks command to specifically show the app’s tasks, you have to prepend 
 app:, which we saw earlier for the build task.",NA
Note,NA,NA
 Describing what you can do with such an APK file resulting from ,NA,NA
"a build is left to an Android book. As a hint to get you started, learn ",NA,NA
"how to use the tools provided in the SDK, especially the adb platform ",NA,NA
tool.,14,NA
CHAPTER 2,NA,NA
Classes and ,NA,NA
Objects: Object ,NA,NA
Orientation ,NA,NA
Philosophy,"At the beginning of the book we said that computer programs are about processing 
 some input and generating some output from it, possibly also altering the state of some 
 data-holding instance like a file or a database. Although this is certainly true, it does 
 not tell the whole story. In real-world scenarios, computer programs exhibit another 
 characteristic: They are supposed to be of some practical use, and as a result of that, 
 model real-world events and things.
  
 Say, for example, you write a simple program for registering paper invoices and 
 summing up the money amounts for each day. The input is clear: It is the paper invoices 
 in electronic form. The output is the daily sum, and along the way a database keeps 
 records for all registered invoices. The modeling aspect tells us that we deal with the 
 following objects: an invoice in electronic form, a database for keeping the records, and 
 some calculation engine for accessing the database and performing the summation 
 operation. To be of practical use these objects need to exhibit the following features. 
  
 First, depending on their nature, they might have a 
 state
 . For the invoice object, for 
 example, we have the name of the seller, the name of the buyer, the date, the name of the 
 goods, and of course the monetary amount. Such state elements are commonly referred 
 to as 
 properties
 . The database obviously has the database contents as its state. The 
 calculation engine, in contrast, doesn’t need its own state, and it uses the state from the 
 other objects to do its work. The second feature of objects is operations you can perform 
 on them, commonly referred to as 
 methods
 . The invoice object, for example, might have 
 methods to set and tell us about its state, the database object needs methods for saving",NA
Note,NA,NA
" Depending on the terminology used, methods are also sometimes ",NA,NA
called ,NA,NA
operations,NA,NA
 or ,NA,NA
functions,NA,NA
", and properties are sometimes referred to ",NA,NA
as ,NA,NA
attributes,NA,NA
. Although we continue to use ,NA,NA
property,NA,NA
 we’ll switch to using ,NA,NA
function ,NA,NA
for methods because the Kotlin documentation uses the term ,NA,NA
function,NA,NA
" and we want to keep things easy for you, including reference ",NA,NA
research in the Kotlin documentation.,"One important concept to understand is that Invoice is not an object, nor is Person, 
 nor is Triangle. How can that be? We just were talking of invoices as objects, and why 
 are Person and Triangle not objects? This contradiction comes from some kind of 
 linguistic fluffiness. Did you realize that we’re talking of Invoice, but not of an invoice? 
 There is a major difference between those: An invoice, or more precisely a particular 
 invoice, is an object, but Invoice is a classification or class. All possible invoices share 
 membership in the Invoice class, and all concrete persons share membership in the 
 Person class, just as all possible triangles belong to the Triangle class. Does this seem 
 theoretical or even nitpicking? Perhaps, but it has important practical implications and 
 we really need to 
  
 16
  
 www.EBooksWorld.ir",NA
 Kotlin and Object-Oriented Programming,"In this section we talk about the main characteristics of classes and objects in Kotlin. 
 Some aspects are covered in greater detail in later sections, but here we want to give 
 you the basics you need for Kotlin programming.",NA
 Class Declaration,NA,NA
Note,NA,NA
 the term ,NA,NA
declaration,NA,NA
 here is used for the description of the ,NA,NA
structure and the constituent parts of a class.,"In Kotlin, to declare a class you basically write
  
 class ClassName(Parameter-Declaration1, Parameter-Declaration2, ...) {
  
  
  [Class-Body]
  
  
  }
  
 Let us examine its parts:
  
 • ClassName: This is the name of the class. It must not contain spaces, and 
 in Kotlin by convention you should use CamelCase notation; that is, start 
 with a capital letter, and instead of using spaces between words, capitalize 
 the first letter of the second word, as in EmployeeRecord.
  
 • Parameter-Declaration: These declare a primary constructor and 
 describe data that are needed to instantiate classes. We talk more about 
 parameters and parameter types later, but for now we mention that such 
 parameter declarations basically come in three varieties:
  
 – Variable-Name:Variable-Type: An example would be userName: 
 String. Use this to pass a parameter usable for instantiating a class. 
 This happens inside a special construct called an init{} block. We’ll 
 talk about that initialization later.
  
 18
  
 www.EBooksWorld.ir",NA
 Exercise 1,"Which of the following appears to be a valid class declaration?
  
 1.    class Triangle(color:Int) (
  
  
  
  val coordinates:Array<Pair<Double,Double>>
  
  
  
  = arrayOf()
  
  
  )
  
 2.    class Triangle(color:Int) {
  
  
  
  val coordinates:Array<Pair<Double,Double>>
  
  
  
  = arrayOf()
  
  
  }
  
 19
  
 www.EBooksWorld.ir",NA
 Property Declaration,"We’ll be talking about detailed characteristics of properties in Chapter 
 3
 . Here I provide 
 just a brief summary for simple property declarations: They basically look like
  
 val Variable-Name:Variable-Type = value
  
 for immutable properties, and
  
 var Variable-Name:Variable-Type = value
  
 for mutable properties. The = value is not needed, however, if the variable’s value gets 
 set inside an init { } block.
  
 class ClassName(Parameter-Declaration1,
  
  
  Parameter-Declaration2, ...) {
  
  ...
  
  val propertyName:PropertyType = [init-value] var 
 propertyName:PropertyType = [init-value] ...
  
 }
  
 One word about mutability is in order: Immutable means the val variable gets its 
 value at some place and cannot be changed afterward, whereas mutable means the var 
 variable is freely changeable anywhere. Immutable variables have some advantages 
 concerning program stability, so as a rule of thumb you should always prefer immutable 
 over mutable variables.
  
 20
  
 www.EBooksWorld.ir",NA
 Exercise 2,"Which one of the following is a valid class?
  
 1.    class Invoice() {
  
  
  
  variable total:Double = 0.0
  
  
  }
  
 2.    class Invoice() {
  
  
  
  property total:Double = 0.0
  
  
  }
  
 3.    class Invoice() {
  
  
  
  Double total =
  
  
  
  0.0
  
  
  }
  
 4.    class Invoice() {
  
  
  
  var total:Double = 0.0
  
  
  }
  
 5.    class Invoice() {
  
  
  
  total:Double = 0.0
  
  
  }",NA
 Exercise 3,"What is wrong with the following class (not technically, but from a functional 
 perspective)?
  
 class Invoice() {
  
  
  val total:Double = 0.0 
  
 }
  
 How can it be fixed?
  
 21
  
 www.EBooksWorld.ir",NA
 Class Initialization,"An init { } block inside the class body may contain statements that get worked through 
 when the class gets instantiated. As the name says, it should be used to 
 initialize 
 instances before they actually get used. This includes preparing the state of an instance 
 so it is set up properly to do its work. You can in fact have several init{ } blocks inside a 
 class. In this case the init{ } blocks get worked through sequentially in the order in 
 which they appear in the class. Such init{ } blocks are optional, however, so in simple 
 cases it is totally acceptable to not provide one.
  
 class ClassName(Parameter-Declaration1,
  
  
  Parameter-Declaration2, ...) {
  
  ...
  
  init {
  
  
  // initialization actions...
  
  
  } 
  
 }",NA
Note,NA,NA
 A // starts a so-called ,NA,NA
end-of-line comment;,NA,NA
 anything starting from ,NA,NA
that until the end of the current line is ignored by the Kotlin language. ,NA,NA
you can use it for comments and documentation.,"If you set properties inside an init { } block, it is no longer necessary to write = 
 [value] inside the property declaration.
  
 class ClassName(Parameter-Declaration1,
  
  
  Parameter-Declaration2, ...) {
  
  val 
 someProperty:PropertyType
  
  
  ...
  
  init {
  
  someProperty = [some value]
  
  // more initialization actions...
  
  
  } 
  
 }
  
 22
  
 www.EBooksWorld.ir",NA
 Exercise 4,"What is wrong with the following class?
  
 class Color(val red:Int,
  
  
  
  
  val green:Int,
  
  
  
  
  val blue:Int) 
  
 {
  
  
  init {
  
  
  
  red = 0
  
  
  
  green = 0
  
  
  
  blue = 0
  
  
  } 
  
 }",NA
 Exercise 5,"What is wrong with the following class?
  
 class 
 Color() 
 {
  
  var 
 red:Int
  
  var green:Int
  
 23
  
 www.EBooksWorld.ir",NA
 An Invoice in Kotlin,"That is enough theory; let us work out the Invoice class we already talked about. For 
 simplicity, our invoice will have the following properties: the buyer’s first and last name, 
 the date, the name and amount of a single product, and the price per item. I know in real 
 life we need more properties, but this subset will do here because it describes enough 
 cases and you can easily extend it. A first draft of the actual Invoice class then reads:
  
 class Invoice(val buyerFirstName:String,
  
  
 val buyerLastName:String,
  
  
  val date:String,
  
  
  val goodName:String,
  
  
  val amount:Int,
  
  
  val pricePerItem:Double) { 
  
 }
  
 We talk about data types later in this chapter, but for now we need to know that 
 String is any character string, Int is an integer number, and Double is a floating-point 
 number. You can see that for all the parameters passed to the class I used the val ... 
 form, so after instantiation all those parameters will be available as immutable 
 (unchangeable) properties. This makes a lot of sense here, because the parameters are 
 exactly what is needed to describe the characteristics, or 
 state
 , of an invoice instance.",NA
Note,NA,NA
 in Kotlin it is permitted to omit empty blocks altogether. you could ,NA,NA
therefore remove the { } from the Invoice class declaration. ,NA,NA
"nevertheless, we leave it here, because we will add elements to the body ",NA,NA
soon.,"24
  
 www.EBooksWorld.ir",NA
 More Invoice Properties,"The class body is still empty, but we can easily think of properties we might want to add. 
 For example, it could be interesting to have the full name of the buyer at hand, and the 
 total price of all items. We can add the corresponding properties:
  
 class Invoice(val buyerFirstName:String,
  
  
  val buyerLastName:String,
  
  
  
  val date:String,
  
  
  
  val goodName:String,
  
  
  
  val amount:Int,
  
  
  
  val pricePerItem:Double) 
  
 {
  
  
  val buyerFullName:String
  
  
  val totalPrice:Double 
  
 }
  
 Did we forget to initialize the properties by adding values via = something? Well, 
 yes and no. Writing it that way is actually forbidden, but because we will initialize 
 those properties inside an init{ } block soon, it is allowable to not initialize the 
 properties.",NA
 Invoice Initialization,"No sooner said than done, we add a corresponding init{ } block:
  
 class Invoice(val buyerFirstName:String,
  
  
  
  val buyerLastName:String,
  
  
  
  val date:String,
  
  
  
  val goodName:String,
  
  
  
  val amount:Int,
  
  
  
  val pricePerItem:Double) 
  
 {
  
  
  val buyerFullName:String
  
  
  val totalPrice:Double
  
  
  init {
  
  
   
  buyerFullName = buyerFirstName + "" "" +
  
  
   
  buyerLastName
  
 25",NA
 Exercise 6,"Write the Invoice class without the init{ } block, keeping its full functionality.",NA
 Instantiation in Kotlin,"With the class declaration ready now, to instantiate an Invoice object from it, all you 
 have to do is write this:
  
 val firstInvoice = Invoice(""Richard"", ""Smith"", ""2018-10-23"", ""Peas"", 5, 2.99)
  
  
 If you don’t know how to put all that into a program, in Kotlin it is totally 
 acceptable to write everything in one file, which then reads:
  
 class Invoice(val buyerFirstName:String,
  
  
  val buyerLastName:String,
  
  
  
  val date:String,
  
  
  
  val goodName:String,
  
  
  
  val amount:Int,
  
  
  
  val pricePerItem:Double) 
  
 {
  
  
  val buyerFullName:String
  
  
  val totalPrice:Double
  
 26
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" having said that, please do not write files containing a lot of ",NA,NA
different classes or long functions. We’ll talk about program structure ,NA,NA
soon in the section “structuring and packages” later in this chapter. For ,NA,NA
"now, just remember that having short identifiable pieces of code helps a ",NA,NA
great deal in writing good software!,NA,NA
 Adding Functions to Invoices,"Our Invoice class does not yet have explicit functions. I deliberately said explicit, 
 because by virtue of both the constructor properties and the properties we added in the 
 class body, Kotlin provides us implicit accessor functions in the form of objectName.
  
 propertyName. We can, for example, add inside any function:
  
 ...
  
 val firstInvoice = Invoice(""Richard"", ""Smith"",
  
  ""2018-
 10-23"", ""Peas"", 5, 2.99) 
  
 val fullName = firstInvoice.buyerFullName
  
 27
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 Developers use the term ,NA,NA
implementation,NA,NA
 quite often to ,NA,NA
describe the transition from an idea to the code performing the idea.,"28
  
 www.EBooksWorld.ir",NA
 Exercise 7,"Add a method goodInfo() that returns something like “5 pieces of Apple.” Hint: Use 
 amount.toString() to convert the amount to a string.",NA
 The Complete Invoice Class,"The Invoice class with all properties and methods we have talked about so far, and some 
 code to invoke it, reads like this:
  
 class Invoice(val buyerFirstName:String,
  
  
  val buyerLastName:String,
  
  
  
  val date:String,
  
  
  
  val goodName:String,
  
  
  
  val amount:Int,
  
  
  
  val pricePerItem:Double) 
  
 {
  
  
  val buyerFullName:String
  
  
  val totalPrice:Double
  
  init {
  
  
  buyerFullName = buyerFirstName + "" "" +
  
  
  buyerLastName
  
  
  totalPrice = amount * pricePerItem }
  
  fun getState():String {
  
  
  return ""First name: ${buyerFirstName}\n"" +
   
  
 ""Last name: ${buyerLastName}\n"" +
  
  
  ""Full 
 name: ${buyerFullName}\n"" +
  
  
  ""Date: 
 ${date}\n"" +
  
  
  
  ""Good: ${goodName}\n"" +
  
  
  
  ""Amount: ${amount}\n"" +
  
  
  
  ""Price per item: ${pricePerItem}\n"" +
  
  
  ""Total price: ${totalPrice}""
  
  }
  
 30
  
 www.EBooksWorld.ir",NA
 A Simple Number Guessing Game,"In Android, applications circle around 
 Activities,
  which are identifiable pieces of code 
 corresponding to particular responsibilities from a user’s workflow perspective. Each 
 of these responsibilities can be handled by a distinct screen built up by graphical 
 objects positioned in a screen layout. An app can have one or more activities that are 
 represented by distinct classes, together with resource and configuration files. As we 
 have already seen in Chapter 
 1
 , Android Studio helps in preparing and tailoring all the 
 necessary files.
  
 For the rest of this chapter and most of the following chapters we will be working on 
 a simple game called the Number Guessing Game. Although extremely simple to 
 understand, it is complex enough to show basic Kotlin language constructs and allows 
 for extensions that help to illustrate most of the language features introduced during the 
 course of the book. We thus neither start with the most elegant solution, nor do we 
 show the most high-performance code from the beginning. The aim is to start with a 
 working app and introduce new features step by step so we can improve our Kotlin 
 language proficiency.
  
 31
  
 www.EBooksWorld.ir",NA
 Constructors,"We already learned that parameters passed to a class when an instantiation happens get 
 declared in parentheses after the class name:
  
 class ClassName(Parameter-Declaration1,
  
  
  Parameter-Declaration2, ...) {
  
  [Class-
 Body] 
  
 }
  
 We also know that parameters are accessible from inside any init{ } block and 
 furthermore lead to creating properties if we prepend val or var to the parameter 
 declaration:
  
 Variable-Name:Variable-Type
  
 for parameters that just are needed for the init{ } blocks,
  
 val Variable-Name:Variable-Type
  
 if you additionally want the parameter to be converted to an immutable property, and
  
 var Variable-Name:Variable-Type
  
 if you additionally want the parameter to be converted to a mutable property instead.
  
 Such a parameter declaration list in Kotlin is called a 
 primary constructor.
  As 
 you might guess, there are secondary constructors as well. Let’s talk about 
 primary constructors first, though, because they exhibit features we haven’t seen 
 yet.
  
 41",NA
Note,NA,NA
" in other languages, constructors contain statements, or code to be ",NA,NA
executed on instantiation. the Kotlin designers decided to only name ,NA,NA
the parameters in the (primary) constructor and move any class ,NA,NA
initialization code to the init{ } block.,"In our NumberGuess game the activity class MainActivity does not have a 
 constructor. Actually, it implicitly has the default no-operation constructor, which 
 doesn’t need to be declared. In fact, a specialty of Android is that activities should not 
 have an explicit constructor. This has nothing to do with Kotlin, though; it is just the way 
 Android 
  
 42
  
 www.EBooksWorld.ir",NA
 Exercise 8,"Create a class Person with constructor parameters: firstName (a String), lastName (a 
 String), ssn (a String), dateOfBirth (a String) and gender (a Char). Make sure the 
 parameters are later available as instance properties and are changeable afterward.",NA
 Constructor Invocation,"In the previous section we already applied the main usage pattern: Given, for example, 
 a class
  
 class GameUser(val firstName:String,
  
  
  val lastName:String,
  
  
  val birthday:String,
  
  
  val userName:String,
  
  
  val registrationNumber:Int,
  
  
  val userRank:Double) { 
  
 }
  
 you can instantiate the class via
  
 ...
  
 val firstUser = GameUser(""Richard"", ""Smith"",
  
  
 ""2008-10-23"", ""rsmith"", 123, 0.0)
  
  
 You can see that for this kind of instantiation you have to specify the parameters in 
 exactly the same order as in the class definition.",NA
 Exercise 9,"Instantiate the Person class from the previous exercise, using name John Smith, date of 
 birth 1997-10-23, SSN 0123456789, and gender M. Assign it to variable val person1. 
 Hint: Use single quotation marks for Char literals, like 'A' or 'B'.
  
 43
  
 www.EBooksWorld.ir",NA
 Exercise 10,"Add the GameUser class we talked about in this section to the NumberGuess game. Just 
 add the class for now; do not write code to include the user in the game logic.",NA
 Named Constructor Parameters,"There is actually a way to construct objects in a more readable and less error-prone 
 fashion, compared to just listing parameters in the same order as given in the 
 declaration. For instantiation you can also explicitly specify the parameter names and 
 then apply any order at will:
  
 val instance = TheClass(
  
  parameterName1 = [some value],
  
  parameterName2 = [some value],
  
  ...)
  
 For our GameUser from the last exercise you can write
  
 ...
  
 val user = GameUser(
  
  lastName = ""Smith"",
  
  firstName = ""Richard"",
  
  birthday = ""2098-10-23"",
  
  userName = ""rsmith"",
  
  registrationNumber = 765,
  
  userRank = 0.5)
  
  
 With the names given, the sort order of the call parameters no longer plays a role. 
 Kotlin knows how to properly distribute the passed-in parameters.",NA
 Exercise 11,"Rewrite the Person instantiation from Exercise 9 using named parameters.
  
 44
  
 www.EBooksWorld.ir",NA
 Exercise 12,"Add a var gameUser property to the MainActivity and initialize it with the name John 
 Doe, username jdoe, birthday 1900-01-01, registration number = 0 and user rank = 0.0. 
 Use named parameters. Hint: To initialize the property right in the declaration use var 
 gameUser = GameUser(...).",NA
 Constructor Default Values,"Constructor parameters can also have default values. We could, for example, use ”” as 
 a default birthday, and 0.0 as a rank in case we wouldn’t care. This simplifies the 
 construction of game users who don’t specify a birthday, and new users, for example, 
 with an initial ranking of 0.0. To declare such defaults you write:
  
 class GameUser(val firstName:String,
  
  
  val lastName:String,
  
  
  val userName:String,
  
  
  val registrationNumber:Int,
  
  
  val birthday:String = ""1900-01-01"",
  
  
 val userRank:Double = 0.0) { 
  
 }
  
 If you use parameters with and without defaults, such default values go frequently 
 to the end of the parameter list. Only then is the distribution of passed-in parameters 
 during invocation unique. You can now perform the very same construction as before, 
 but watch out for the changed order:
  
 ...
  
 val firstUser = GameUser(""Richard"", ""Smith"", ""rsmith"", 123, ""2008-10-23"", 0.4)
  
 Now, by virtue of the default parameters, it is possible to omit parameters. In
  
 ...
  
 val firstUser = GameUser(""Richard"", ""Smith"", ""rsmith"", 123, ""2008-10-23"")
  
 45
  
 www.EBooksWorld.ir",NA
 Exercise 13,"Update the Person class from the previous exercises: add the default value ”” (the 
 empty string) to the ssn parameter. Perform an instantiation using named parameters, 
 letting the SSN’s default value apply.",NA
 Exercise 14,"Update the GameUser class from the NumberGuess game: Add the default value ”” 
 (the empty string) to birthday, and add 0.0 to the userRank parameter.",NA
 Secondary Constructors,"With named parameters and default parameter values, we already have quite versatile 
 means for various construction needs. If this is not enough for you, there is another way 
 of describing different methods of construction: 
 secondary constructors
 . You can have 
 several of them, but their parameter list must differ from that of the primary 
 constructor and they must also be different from each other.
  
 46
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" More precisely, primary and secondary constructors all must have ",NA,NA
different ,NA,NA
parameter signatures,NA,NA
. A signature is the set of parameter ,NA,NA
"types, with the order taken into account.","To declare a secondary constructor, inside the class body write
  
 constructor(param1:ParamType1,
  
  
  
  param2:ParamType2, ...) 
  
 {
  
  
  // do some things...
  
 }
  
  
 If the class has an explicit primary constructor as well, you must delegate to 
 a primary constructor call as follows:
  
 constructor(param1:ParamType1,
  
  
  
  param2:ParamType2, ...) : this(...) {
  
  // 
 do some things...
  
 }
  
 where inside this(...) the parameters for the primary constructor have to be specified. It 
 is also possible here to specify the parameters for another secondary constructor, which 
 in turn delegates to the primary constructor.
  
  
 For our GameUser example, removing the default parameter values from the 
 primary constructor, a secondary constructor could read like this:
  
 constructor(firstName:String,
  
  
  
  
  lastName:String,
  
  
  
  
  userName:String,
  
  
  
  
  registrationNumber:Int) :
  
  
  this(firstName = firstName,
  
  
  
  lastName = lastName,
  
  
  
  userName = userName,
  
  
  
  registrationNumber = registrationNumber,
  
  
  birthday = """",
  
  
  
  userRank = 0.0
  
  
  )
  
 47
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 if you can achieve the same thing using default values and ,NA,NA
"secondary constructors, you should favor default values because ",NA,NA
the notation is more expressive and concise.,NA,NA
 Exercise 15,"In the Person class of the previous exercises, add a secondary constructor with 
  
 parameters firstName (a String), lastName (a String), ssn (a String), and gender (a Char). 
 Let it call the primary constructor, setting the missing dateOfBirth to 0000-00-00. Create 
 an instance using the secondary constructor.
  
 48
  
 www.EBooksWorld.ir",NA
 If Classes Are Not Needed: Singleton Objects,"Once in a while objects don’t need a classification because you know there will never 
 be different states associated with them. Here is another way of saying this: If we have 
 a class, there will never be more than one instance needed, because all instances would 
 somehow be forced to carry the same state during the lifetime of the application and 
 thus would be indistinguishable.
  
  
 To make things clear, Kotlin allows for creating such an object using the following 
 syntax:
  
 object ObjectName { [Object-Body] 
  
 }
  
 where the object body could contain property declarations, init{ } blocks, and 
 functions. Neither primary nor secondary constructors are allowed. To distinguish this 
 kind of object from objects that are the result of class instantiations for the rest of the 
 section, I use the term 
 singleton object
 .
  
  
 To access a singleton object’s properties and functions you use a similar notation as 
 for objects that are the result of a class’s instantiation:
  
 ObjectName.propertyName 
  
 ObjectName.function([function-parameters])
  
 You won’t use singleton objects too often, because object orientation without classes 
 wouldn’t make too much sense, and using too many singleton objects quite often is an 
 indication of poor application design. There are, however, some prominent examples 
 where object declarations make sense:
  
 • 
 Constants:
  For your application you might want to have a single 
 object containing all constants the application needs.
  
 • 
 Preferences:
  If you have a file with preferences you might want to use 
 an object to read in the preferences once the application has started.
  
 • 
 Database:
  If your application needs a database and you think your 
 application will never access a different database, you might want to 
 move database access functions into an object.
  
 49
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" this autoinferring works for other types as well, so a common ",NA,NA
practice is to leave out the type specification and add it only if it is ,NA,NA
needed or helps to improve readability.,"50
  
 www.EBooksWorld.ir",NA
 Exercise 16,"Which of the following is true?
  
  1. Using a lot of singleton objects helps to improve code quality.
  
  2. It is possible to instantiate singleton objects.
  
 51
  
 www.EBooksWorld.ir",NA
 Exercise 17,"Create a Constants singleton object with the following properties: numberOf- Tabs = 5, 
 windowTitle = ""Astaria"", prefsFile = ""prefs.properties"". Write some code to print out all 
 constants for diagnostic purposes. Hint: For formatting you could use \n inside strings 
 for a line break.",NA
 If State Doesn’t Matter: Companion Objects,"Quite often, perhaps without even noticing it, your classes will have two categories of 
 properties and functions: state related and not state related. Not state related means for 
 properties that their value will be the same for all possible instances. For functions it 
 means they will do exactly the same thing for all possible instances. This is somehow 
 related to singleton objects, which do not care about a distinguishable state at all, and for 
 that reason Kotlin allows for a construct named the 
 companion object
 . Such companion 
 objects have an indistinguishable state for all instances of a particular class they 
  
 accompany, and this is where the “companion” in the name comes from.
  
 To declare a companion object inside the class body, write this:
  
 companion object ObjectName {
  
  
  ...
  
 }
  
 where the ObjectName is optional; in most cases you can omit it. Inside the 
 companion object’s body you can add the same elements as for singleton objects (see 
 the previous section).
  
 52
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 you need the companion object to have a name only if you want to ,NA,NA
"address it from outside the class, using a dedicated name: ",NA,NA
ClassName.ObjectName. ,NA,NA
"however, even with the name missing you can access it via ",NA,NA
ClassName. Companion.,"A companion object is a really good place to declare constants used by the class. You 
 can then use the constants from anywhere inside the class as if they were declared in 
 the class itself:
  
 class TheClass {
  
  
  companion object ObjectName {
  
  
  
  val SOME_CONSTANT: Int = 42
  
  
  }
  
  
  ...
  
  fun someFunction() {
  
  val x = 7 * SOME_CONSTANT
  
  ...
  
  
  } 
  
 }
  
 In our NumberGuess game there are two constants in the Console class: Look at the 
 init{ } function where we specify a color value 0x40FFFF00 for the background color 
 (this is a pale yellow). Also, in the function fun log(...) you can see a 100, which happens 
 to specify a memorized line number limit. I intentionally left these out for the Constants 
 companion object, as those two new constants can be considered to more closely belong 
 to the Console class and maybe are misplaced in a common constants file.
  
 It is, however, a good idea to move them to a companion object, because both the 
 color and the line number limit values are shared by all instances of the Console class 
 and are not subject to being changed from inside an instance. An accordingly rewritten 
 Console class reads:
  
 class Console(ctx:Context, aset:AttributeSet? = null)
   
  
 : ScrollView(ctx, aset) {
  
  
  companion object {
  
   
  val BACKGROUND_COLOR = 0x40FFFF00
  
 53",NA
 Exercise 18,"Create a Triangle class. Add constructor parameters and properties at will, but also 
 create a companion object with a constant NUMBER_OF_CORNERS = 3. Inside the class, 
 create an info() function indicating the number of corners.
  
 54
  
 www.EBooksWorld.ir",NA
 Exercise 19,"Inside a main() function, instantiate the Triangle class from Exercise 18, then assign the 
 number of corners to some val numberOfCorners.",NA
 Describing a Contract: Interfaces,"Software development is about things that need to be done, and in object-oriented 
 development, this means things that need to be done on objects that are described 
 inside classes. Object orientation, however, unveils a feature we haven’t talked 
 about until now: the separation of intent and implementation.
  
 Consider, for example, a class or a couple of classes gathering information on two- 
 dimensional graphical objects, and another class or couple of classes providing such 
 graphical objects. This introduces a natural separation of classes. We call the information 
 collecting part of the classes the info collector module, and the part that provides the 
 graphical objects the client module. We want to extend that idea by allowing several 
 client modules, and in the end we want to make sure the info collector module wouldn’t 
 care how many clients there are (see Figure 
 2-1
 ).
  
  
 Figure 2-1. 
 Collector module and clients",NA
Note,NA,NA
 We deviate from the usual path and temporarily leave the ,NA,NA
NumberGuess game. the concept of interfaces is a little easier to ,NA,NA
"describe if we have several classes sharing some features, which the ",NA,NA
"NumberGuess game doesn’t have. i will, however, propose a possible ",NA,NA
extension to the NumberGuess game using an interface in one of the ,NA,NA
exercises.,55,NA
Note,NA,NA
 the : in the class header can be translated to “implements” or ,NA,NA
“is a ...” if there is an interface name to the right of it.,"Inside the coordsOf() function we use a couple of new constructs we haven’t seen 
 yet. For now, the when(){ } selects one of the x -> ... branches depending on the 
 argument, and the throw RuntimeException() stops the program flow and writes an 
 error message to the terminal. We’ll talk about those constructs in more detail in 
 subsequent chapters.",NA
Note,NA,NA
" you can see that for the triangle example we allow corner indexes 0, ",NA,NA
"1, and 2. it is common in many computer languages to start any kind of ",NA,NA
indexing at 0. Kotlin is no exception here.,"We still need the accessor function inside one of the collector module’s classes that a 
 client needs to register a graphics object. We call it add() and it could read like this:
  
 class Collector {
  
  
  ...
  
  fun add(graphics:GraphicsObject) {
  
  // do something with it...
  
  
  } 
  
 }
  
 The clients now write something like this:
  
 ...
  
 val collector = [get hold of it] 
  
 val triang:GraphicsObject = Triangle() 
 collector.add(triang) 
  
 ...
  
 59
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 internally the same object gets passed to the collector if we write ,NA,NA
either triang:Triangle or triang:GraphicsObject. but we don’t only want ,NA,NA
to write programs that work; they must also properly express what ,NA,NA
"they do. For that reason, triang:GraphicsObject is the much better ",NA,NA
option.,"To get you started for your own experiments, in the following listings I provide a 
 basic implementation of this interfacing procedure. First, in one file, we write a graphics 
 object collector and also add the interface.
  
 interface GraphicsObject {
  
  
  fun numberOfCorners(): Int
  
  
  fun coordsOf(index:Int): Pair<Double, Double>
  
  fun 
 fillColor(): String 
  
 }
  
 object Collector {
  
  
  fun add(graphics:GraphicsObject) {
  
  
  println(""Collector.add():"")
  
  
  
  println(""Number of corners: "" +
  
  
  
  graphics.numberOfCorners())
  
  
  println(""Color: "" +
  
  
  
  
  graphics.fillColor())
  
  
  } 
  
 }
  
  
 You can see we use a singleton object here to simplify access. In another file we 
 create a GraphicsObject and access the collector.
  
 60",NA
 Exercise 20,"Elementary particles have at least three things in common: a mass, a charge, and a spin. 
 Create an interface ElementaryParticle with three corresponding functions to fetch: 
 mass():Double, charge():Double, and spin():Double. Create classes Electron and Proton 
 that implement the interface. An electron returns mass 9.11 · 10
 -31
 , to be entered as 
 9.11e-31, charge −1.0, and spin 0.5. A proton returns mass 1.67·10
 -27
 , to be entered as 
 1.67e-27, charge and spin 0.5.
  
 61
  
 www.EBooksWorld.ir",NA
 Exercise 21,"Taking the interface and the classes from Exercise 20, which one is true?
  
  1. An ElementaryParticle can be instantiated: 
  
 var p = ElementaryParticle().
  
  2. An Electron can be instantiated: val electron = Electron().
  
  3. A Proton can be instantiated: val proton = Proton().
  
  4. The initialization var p:ElementaryParticle = Electron() 
  
 is 
 possible.
  
  5. The reassignment p = Proton() is possible.
  
  6. The initialization var p:Proton = Electron() is possible.",NA
 Exercise 22,"Imagine for the NumberGuess game we want to be able to try different functions 
  
 of random number generation. Create an interface RandomNumberGenerator with one 
 function fun rnd(minInt:Int, maxInt:Int): Int. Create a class StdRandom implementing 
 that interface using the current code from the MainActivity class: val span = maxInt - 
 minInt + 1; return minInt + Math.floor(Math.random()*span). toInt(). Create another 
 class RandomRandom also implementing the interface, but with a property val 
 rnd:Random = Random() (add import java.util.* to the imports) and using the code 
 minInt + rnd.nextInt( maxInt - minInt + 1 ). Add a property of type 
 RandomNumberGenerator to the activity, using either of the implementations. Alter the 
 start() function from the activity to use that interface.",NA
 Structuring and Packages,"For Kotlin applications it is possible to write all classes, interfaces, and singleton objects 
 into a single file in the main folder java. Whereas for experiments and small projects this 
 is totally acceptable, for larger projects you shouldn’t do this. Midsize to larger projects 
 will inevitably have classes, interfaces, and singleton objects that can be grouped into 
 modules doing different things from a bird’s-eye view perspective. Having large files 
 implies some kind of conceptual flatness real projects don’t actually have.
  
 62
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" to avoid always repeating the list, i henceforth use the term ",NA,NA
structure unit,NA,NA
" for classes, singleton objects, companion objects, and ",NA,NA
interfaces.,"For this reason Kotlin allows us to put structure units into different 
 packages 
 corresponding to different folders and spanning different namespaces. The first thing 
 we need to establish is a hierarchical structure. This means we assign structure units 
 to different nodes in a tree. Each node thus contains a couple of structure units that 
 show high cohesion, meaning they strongly relate to each other.",NA
 A Structured Project,"Let’s look at the NumberGuess example to find out what this structuring actually means. 
  
 Up until now, including all the improvements and also the exercises, we have the 
 following classes, interfaces, and singleton objects: the activity itself, a console class, a 
 constants object, two classes and one interface for random numbers, and one class for 
 user data. From this we identify the following packages:
  
 • The root for the activity class.
  
 • A package random for the random numbers. We put the interface 
 right into the package, and the two implementations into a 
 subpackage impl.
  
 • A gui package for the Console view element.
  
 • A model package for the user data class. Developers often use the 
 term 
 model
  to refer to data structures and data relations.
  
 • A common package for the Constants singleton object.
  
  
 We put this in corresponding directories and subdirectories under src and thus get 
 the packages and folder structure depicted in Figure 
 2-3
 .
  
 63",NA
 Exercise 23,"Prepare this structure in an Android Studio project. Start with empty files. Hint: 
 Packages (i.e., folders), classes, interface, and singleton objects all can be initialized by 
 right- clicking an item from the left side package structure in the Android Studio main 
 window and selecting New.",NA
 Namespaces and Importing,"As already mentioned, the hierarchical structure also spans namespaces. For example, 
 the Console class lives by virtue of the kotlinforandroid.book.numberguess.gui package 
 declaration in the kotlinforandroid.book.numberguess.gui namespace. This means there 
 cannot be another Console class in the same package, but there can be Console classes in 
 other packages, because they all have a different namespace.",NA
Caution,NA,NA
 Kotlin allows you to use a package declaration that differs from ,NA,NA
"the hierarchical position in the file system. however, do yourself a favor ",NA,NA
"and keep packages and file paths synchronized, otherwise you’ll end up ",NA,NA
with a complete mess.,"Structure units (i.e., classes, interfaces, singleton objects, and companion objects) can 
 use other structure units from the same package by just using their simple names. If they 
 use structure units from other packages, though, they must use their 
 fully qualified name
 , 
 which means it is necessary to prepend the package name with dots as separators. 
  
 The fully qualified name for Console, for example, reads kotlinforandroid.book. 
 numberguess.gui.Console. There is, however, a way to avoid typing lots of long names to 
 refer to structure units from other packages: As a shortcut, you can 
 import
  the referred- 
 to structure unit by using an import statement. We have already seen that in a couple of 
 examples, without further explaining it. To import the Console class, for example, you 
 write directly under the package declaration:
  
 package kotlinforandroid.book.numberguess
  
 import kotlinforandroid.book.numberguess.gui.Console
  
 class Activity {
  
  
  ...
  
 }
  
 65",NA
Note,NA,NA
 iDes like Android studio provide help to do these imports for you. ,NA,NA
if you type a simple name Android studio tries to determine what ,NA,NA
package might be intended. you can then press Alt+enter with the ,NA,NA
mouse over the name to perform the import.,"There is even a shortcut for importing all structure units from a package by using 
 an asterisk (*) as a wildcard. So, for example, to import all the classes from package 
 kotlinforandroid.book.numberguess.random.impl, you would write
  
 package kotlinforandroid.book.numberguess
  
 import kotlinforandroid.book.numberguess.
  
  
 random.impl.*
  
 class Activity {
  
  
  ...
  
 }
  
 You can see the common root of all packages of the NumberGuess game reads 
 kotlinforandroid.book.numberguess. Android Studio did that while we initialized the 
 project. It is common practice to prepend a reverse domain name that points to you as a 
 developer, or your educational institution or your company, plus a name for your 
 project. For example, if you own a domain john.doe.com and your project is named 
 elysium, you would use com.doe.john.elysium as your root package.
  
 66
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 there is no actual need for such a domain to exist. if you can’t use an ,NA,NA
"existing domain, you can use a made-up one. just make sure the ",NA,NA
probability of clashes with existing projects is low. if you don’t plan to ,NA,NA
"ever publish your software, you can use what you want, including not ",NA,NA
using a domain root at all.,NA,NA
 Exercise 24,"Distribute all the code we have for the NumberGuess game into the files of the new 
  
 structure from the previous section.
  
 67",NA
CHAPTER 3,NA,NA
Classes at Work: ,NA,NA
Properties and ,NA,NA
Functions,"After reading Chapter 
 2
  about classes and objects, it is now time shine more light on 
 properties and their types, and also on the options we have to declare functions and 
 what can be done from inside functions. This chapter talks about property and function 
 declarations, but also about an important feature of object-oriented languages, 
 inheritance
 , through which properties and functions of some class can be altered and 
 redefined by other classes. We also learn about visibility and encapsulation, which help 
 us to improve program structure.",NA
 Properties and Their Types,"Properties are data holders or variables that define the state of an object. A property 
 declaration inside a class uses the optional visibility type, optional modifiers, the 
 keyword val for immutable (nonchangeable) variables or var for mutable (changeable) 
 variables, the name, the type, and an initial value:
  
 [visibility] [modifiers] val propertyName:PropertyType = initial_value [visibility] 
 [modifiers] var propertyName:PropertyType = initial_value
  
 Apart from this, any property from a class’s constructor prepended by val or var 
 directly and automatically goes into a corresponding hidden property using the same 
 name. In the following paragraphs we discuss all the possible options for properties 
 given inside the class body.",NA
 Simple Properties,"Simple properties do not provide a visibility nor any modifiers, so their declaration 
 reads
  
 val propertyName:PropertyType = initial_value var 
 propertyName:PropertyType = initial_value
  
 respectively, for immutable and mutable variables. Here are some additional rules:
  
 • If inside the class or singleton object or companion object a value gets 
 assigned inside the init{ } block, the = initial_value can be omitted.
  
 • If Kotlin can infer the type by the initial value given, the 
 :PropertyType can be omitted.
  
 Such simple properties can be accessed from outside via 
 instanceName.propertyName for classes and ObjectName.propertyName for singleton 
 objects. Inside the class or singleton object, just use the propertyName to access it.
  
 Let’s add two simple properties to the GameUser class from the NumberGuess 
 project from Chapter 
 2
 . We know the first and last name from the constructor, so it 
 might be interesting to derive a property for initials and one for full name as follows:
  
 class GameUser(val firstName:String,
  
  
  
  
  val lastName:String,
  
  
  
  
  val userName:String,
  
  
  
  
  val registrationNumber:Int,
  
  
  
  
  val birthday:String = """",
  
  
  
  
  val userRank:Double = 0.0) {
  
  
  val fullName:String
  
  
  val initials:String
  
  
  init {
  
  
  
  fullName = firstName + "" "" + lastName
  
  
  initials = firstName.toUpperCase() +
  
  
  
  
  lastName.toUpperCase()
  
  } 
  
 }
  
 70
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" For example, you would introduce a new function like ",NA,NA
"setFirstName() and update the first name, the full name, and the initials ",NA,NA
accordingly. a possibly cleaner variant is a function that calculates the full ,NA,NA
"name on the fly, without using a separate property for it: fun fullName() = ",NA,NA
"firstName + "" "" + lastName","This is one of the reasons you should prefer vals over vars wherever possible; it 
 is just easier to avoid corrupted states.",NA
 Exercise 1,"What is wrong with the following code?
  
 class Triangle(color: String) {
  
  
  fun changeColor(newColor:String) {
  
  
  color = newColor
  
  
  } 
  
 }",NA
 Property Types,"In the example code snippets, we’ve already seen a couple of types you can use for 
 properties. Here is an exhaustive list.
  
 • String: This is a character string. Each character from the Basic 
 Multilingual Plane (the original Unicode specification) is of type Char 
 (see later). Supplementary characters use two Char elements. For most 
 practical purposes and in the majority of languages, assuming each string 
 element to be a single Char is an acceptable approach.
  
 72",NA
 Property Value Assignment,"Properties can have values assigned at four places. The first place is at the property’s 
 declaration, as in
  
 class TheClassName {
  
  val propertyName1:PropertyType1 = initial_value var 
 propertyName2:PropertyType2 = initial_value ...
  
 }
  
 object SingletonObjectName {
  
  val propertyName1:PropertyType1 = initial_value var 
 propertyName2:PropertyType2 = initial_value ...
  
 }
  
 class TheClassName {
  
  
  companion object {
  
  
  
  val propertyName1:PropertyType1 = initial_value
  
  
  var propertyName2:PropertyType2 = initial_value
  
  
  ...
  
  
  } 
  
 }
  
 where initial_value is any expression or literal that can be converted to the expected 
 property type. We will talk about literals and type conversion later in this chapter.
  
 74
  
 www.EBooksWorld.ir",NA
 Exercise 2,"Create a class A with one property var a:Int. Perform assignments: (a) set it to 1 inside 
 the declaration, (b) set it to 2 inside an init{ } block, (c) set it to 3 inside function fun 
 b(){ … }, and (d) set it to 4 inside a main function.",NA
 Literals,"Literals express fixed values you can use for property assignments and inside 
 expressions. Numbers are literals, but so are strings and characters. Here are some 
 examples:
  
 val anInteger = 42 
  
 val anotherInteger = anInteger + 7 
  
 val aThirdInteger = 0xFF473 
  
 val aLongInteger = 700_000_000_000L 
  
 val aFloatingPoint = 37.103 
  
 val anotherFloatingPoint = -37e-12 
  
 val aSinglePrecisionFloat = 1.3f 
  
 val aChar = 'A' 
  
 val aString = ""Hello World"" 
  
 val aMultiLineString = """"""First Line
  
  
  Second Line""""""
  
 76",NA
Note,NA,NA
 remember that in the decimal system 214 means 2 · 102+ 1 · 101+ 4 ,NA,NA
· 100. in the hexadecimal system we accordingly have 0x13d mean 2 · ,NA,NA
"162 + 3 · 161+ 13 · 160. the letters a, B, …, F correspond to 10, 11, …, 15.","As for type compatibility, you can assign normal integers to long integer 
 properties, but not the other way around. You can also assign reduced precision floats 
 to double 
  
 78",NA
 Exercise 3,"Find a shorter way to write
  
 val a = 42 
  
 val s = ""If we add 4 to a we get "" + (a+4).toString()
  
 avoiding the string concatenation ""…"" + ""…""",NA
 Property Visibility,"Visibility is about which parts of your program can access which functions and 
 properties from other classes, interfaces, objects, or companion objects. We talk about 
 visibility in depth in the section “Visibility of Classes and Class Members” later in this 
 chapter.",NA
 Null Values,"The special keyword null designates a value you can use for any nullable property. The 
 null as value means something like uninitialized, not yet decided, or undefined. Any 
 property can be nullable, but in the declaration you have to add a question mark to the 
 type specifier:
  
 var propertyName:PropertyType? = null
  
 This is possible for any type, including classes, so you can write, for example:
  
 var anInteger:Int? = null 
  
 var anInstance:SomeClass? = null
  
 79",NA
 Exercise 4,"Which of the following is true?
  
  1. You can perform an assignment val a:Int = null.
  
  2. It is possible to write val a:Int? = null; val b:Long = a.toLong().
  
  3. It is possible to write val a:Int? = null; val b:Long? = a.toLong().
  
  4. It is possible to write val a:Int? = null; val b:Long? = a?.toLong().",NA
 Property Declaration Modifiers,"You can add the following modifiers to your property declaration:
  
 • const: Add const as in
  
 const val name = ...
  
 80
  
 www.EBooksWorld.ir",NA
 Member Functions,"Member functions are elements of classes, singleton objects, and companion objects 
 responsible for accessing them. Inside functions, the state of the structure unit gets 
 queried, altered, or both. A calculation based on the state could happen, by taking an 
 input and producing an output dependent on that input and the state. Functions can 
 also be purely functional without using the state, which means given some particular 
 set of input parameters they always produce the same output. Figure 
 3-1
  illustrates the 
 various possibilities.
  
 81
  
 www.EBooksWorld.ir",NA
 Functions Not Returning Values,"To declare a function not returning anything, in Kotlin you write inside the body of a 
 class, a singleton object, or a companion object.
  
 [modifiers] 
  
 fun functionName([parameters]) {
  
  
  [Function Body] 
  
 }
  
 82
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" in kotlin, function arguments cannot be reassigned inside the ",NA,NA
"function body. this is not a disadvantage, as reassigning function ",NA,NA
parameters inside the function is considered bad practice anyway.,"Functions also can have variable argument lists. This feature is called 
 varargs
  and 
 we discuss it later. Another feature we cover later is 
 default arguments
 . Such 
 arguments allow for the specification of a default value that will be used if a parameter 
 is not specified in the function invocation.
  
  
 As an example, two simple function declarations with and without parameters look 
 like this:
  
 fun printAdded(param1:Int, param2:Int]) {
  
  
 console.log(param1 + param2) 
  
 } 
  
 fun printHello() {
  
  
  console.log(""Hello"") 
  
 }
  
 Inside an interface—remember that we use interface to describe what needs to be 
 done, but not how it needs to be done—functions do not have an implementation and 
 thus declaring a body is not allowed. For functions not returning anything, the function 
 declaration in interfaces thus reads like this:
  
 fun functionName([parameters])
  
  
 The optional [modifiers] you can prepend to the function declaration for fine- 
 tuning a function’s behavior are as follows:
  
 • private, protected, internal, and public: These are visibility modifiers. 
 Visibility is explained in the section “Visibility of Classes and Class 
 Members” later in this chapter.
  
 83
  
 www.EBooksWorld.ir",NA
 Exercise 5,"What is wrong with the following function?
  
 fun multiply10(d:Double):Double {
  
  
  d = d * 10
  
  
  return d 
  
 }
  
 84
  
 www.EBooksWorld.ir",NA
 Exercise 6,"What is wrong with the following function?
  
 fun printOut(d:Double) {
  
  
  println(d)
  
  
  return 
  
 }",NA
 Functions Returning Values,"To declare a value-returning function in Kotlin inside a class, a singleton object, or a 
 companion object, inside its body you add : ReturnType to the function header and write
  
 [modifiers] 
  
 fun functionName([parameters]): ReturnType {
  
  [Function Body]
  
  
  return [expression] 
  
 }
  
 The function parameters are the same as for functions not returning values, and so 
 are the modifiers discussed previously. For the value or expression returned, Kotlin 
 must be able to convert the expression’s type to the function return type. An example for 
 such a function would be as follows:
  
 fun add37(param:Int): Int {
  
  
  val retVal = param + 37
  
  
  return retVal 
  
 }
  
  
 It is possible to have more than one return statement inside the body, but they all 
 must return a value of the anticipated type.",NA
Note,NA,NA
 experience says that for improved code quality it is better to ,NA,NA
always use just one return statement at the end.,"85
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 actually kotlin internally lets all functions return a value. if a ,NA,NA
"returned value is not needed, kotlin assumes a special ",NA,NA
void,NA,NA
 type that it ,NA,NA
calls Unit. if you omit : ReturnType and the function does not return a ,NA,NA
"value, or if the function body does not have a return statement at all, ",NA,NA
"Unit is assumed. if, for whatever reason, it helps to improve the ",NA,NA
"readability of your program, you can even write fun name(…) : Unit { … ",NA,NA
} to express that a function does not return any interesting value.,NA,NA
 Exercise 7 ,"Is the following 
 true?
  
 fun printOut(d:Double) {
  
  
  println(d) 
  
 } 
  
 is the same as 
  
 fun printOut(d:Double):Unit {
  
  
  println(d) 
  
 }
  
 86",NA
 Exercise 8,"Create a shorter version of the following class:
  
 class A(val a:Int) {
  
  
  fun add(b:Int):Int {
  
  
  
  return a + b
  
  
  }
  
  
  fun mult(b:Int):Int {
  
  
  
  return a * b
  
  
  } 
  
 }",NA
 Exercise 9,Create an interface AInterface describing all of class A from Exercise 8.,NA
 Accessing Masked Properties,"In case of name clashes, function parameters may 
 mask
  class properties. Say, for 
 example, a class has a property 
 xyz
  and a function parameter has the very same name 
 xyz
 , as in
  
 class A {
  
  
  val xyz:Int = 7
  
  
  fun meth1(xyz:Int) {
  
  
  
  [Function-Body]
  
  
  } 
  
 }
  
 The parameter xyz is then said to mask the property xyz inside the function body. 
 This means if you write xyz inside the function, the parameter gets addressed, not 
 the property. It is still possible, though, to also address the property by prepending 
 this.
  
 to the name:
  
 class A {
  
  val xyz:Int = 7
  
  fun meth1(xyz:Int) {
  
 87",NA
Note,NA,NA
 some people use the term ,NA,NA
shadowed,NA,NA
 instead of ,NA,NA
masked,NA,NA
 for ,NA,NA
such properties. Both mean the same thing.,NA,NA
 Exercise 10,"What is the output of
  
 class A {
  
  
  val xyz:Int = 7
  
  
  fun meth1(xyz:Int):String {
  
  
  
  return ""meth1: "" + xyz +
  
  
  
  
  "" "" + this.xyz
  
  
  } 
  
 } 
  
 fun main(args:Array<String>) {
  
  
  val a = A()
  
  
  println(a.meth1(42)) 
  
 }",NA
 Function Invocation,"Given an instance, a singleton object, or a companion object, you invoke functions as 
 follows:
  
 instance.functionName([parameters]) // outside the class 
 functionName([parameters]) // inside the class
  
 88
  
 www.EBooksWorld.ir",NA
 Exercise 11,"Given this class
  
 class A {
  
  
  companion object {
  
  
  
  fun x(a:Int):Int { return a + 7 }
  
  } 
  
 }
  
 describe how to access function x() with 42 as a parameter from outside the class in a 
 println() function.",NA
 Function Named Parameters,"For a function invocation you can use the argument names to improve readability:
  
  instance.function(par1 = [value1], par2 = [value2], ...)
  
 or
  
  function(par1 = [value1], par2 = [value2], ...)
  
 from inside the class or object. Here the parN are the exact function parameter names as 
 in the function’s declaration. As an additional benefit of using named parameters, you 
 can use any parameter sort order you like, because Kotlin knows how to 
  
 properly distribute the parameters provided. You can also mix unnamed and named 
 parameters, but it is then necessary to have all named parameters at the end of the 
 parameter list.
  
 89
  
 www.EBooksWorld.ir",NA
 Exercise 12,"Given this class
  
 class Person {
  
  
  var firstName:String? = null
  
  
  var lastName:String? = null
  
  
  fun setName(fName:String, lName:String) {
  
  
  firstName = fName
  
  
  
  lastName = lName
  
  
  } 
  
 }
  
 create an instance and use named parameters to set the name to John Doe.",NA
Caution,NA,NA
 using named parameters in function calls greatly improves ,NA,NA
"code readability. however, be careful if you use code from other ",NA,NA
"programs, as with new program versions the parameter names might ",NA,NA
change.,NA,NA
 Function Default Parameters,"Function parameters might have defaults that apply if omitted in the function 
 invocation. To specify a default you just use
  
 parameterName:ParameterType = [default value]
  
 inside the function declaration. A function parameter list may have any number of 
 default values, but they all must be at the end of the parameter list:
  
 fun functionName(
  
  param1:ParamType1,
  
  param2:ParamType2,
  
  ...
  
  paramM:ParamTypeM = [default1],
  
  paramM+1:ParamTypeM+1 = [default2],
  
  ...) { ... }
  
  
 To let the defaults apply you then just omit them in the invocation. If you omit 
 x 
 parameters at the end of the list, the 
 x
  rightmost parameters take their default values. 
  
 90",NA
 Exercise 13,"To the function declaration
  
 fun set(lastName:String,
  
  firstName:String,
  
  birthDay?:String,
  
  ssn:String?) { ... }
  
 add as defaults lastName = """", firstName = """", birthDay = null, ssn = null. Then invoke the 
 function using named parameters, specifying just lastName = ""Smith"" and ssn = 
 ""1234567890"".",NA
 Function Vararg Parameters,"We learned functions exist to take input data and alter an object’s state from that, 
 possibly producing some output data. So far we have learned about fixed parameter 
 lists, covering a big subset of all possible use cases. What about lists of unknown, 
 potentially unlimited size, though? Such lists are called 
 arrays
  or 
 collections,
  and any 
 modern computer language needs to provide a way to handle such data in addition to 
 types holding single data elements. We cover arrays and collections in greater detail in 
 Chapter 
 9
 , but for now you should know that arrays and collections are fully fledged 
 types and you can use them for single constructor and function parameters, as in …, 
 someArray:Array<String>, ….
  
 There is, however, a construct that sits between using many different single-valued 
 parameters and one array or collection parameter: 
 varargs
 . The idea is as follows: As the 
 last element in the parameter list of a function declaration, add a vararg qualifier as in
  
 fun functionName(
  
  param1:ParamType1,
  
  param2:ParamType2,
  
  ...
  
  paramN:ParamTypeN,
  
  vararg paramV:ParamTypeV) { ... }
  
 91",NA
Note,NA,NA
 kotlin actually allows vararg parameters to appear anywhere ,NA,NA
"earlier in the parameter list. kotlin then, however, can distribute passed-",NA,NA
in parameters during function invocation only if the next parameter after ,NA,NA
"the vararg has a different type. Because this complicates call structures, it ",NA,NA
is better to avoid such vararg constructs.,"To invoke such a function, provide all non-vararg parameters in the call, then any 
 number of vararg parameters (including zero):
  
 functionName(param1, param2, ..., paramN,
  
  
 vararg1, vararg2, ...)
  
  
 As a simple example we create a function that takes a date as String, then any 
 number of names, again as Strings. The declaration reads:
  
 fun meth(date:String, vararg names:String) {
  
  ...
  
 }
  
 The following invocations are now possible:
  
 meth(""2018-01-23"") 
  
 meth(""2018-01-23"", ""Gina Eleniak"") 
  
 meth(""2018-01-23"", ""Gina Eleniak"",
  
  
  ""John Smith"") 
  
 meth(""2018-01-23"", ""Gina Eleniak"",
  
  
  ""John Smith"", ""Brad Cold"")
  
 You can extend the name list at will.
  
 92
  
 www.EBooksWorld.ir",NA
 Exercise 14,"Build a Club class and add a function addMembers with the single vararg parameter 
 names. Inside the function, use
  
 println(""Number: "" + names.size) 
  
 println(names.joinToString("" : ""))
  
 to print the parameter. Create a main(args:Array<String>) function outside the class, 
 instantiate a Club, and invoke its addMembers() function with three names “Hughes, 
 John”, “Smith, Alina”, and “Curtis, Solange”.",NA
 Abstract Functions,"Functions inside classes can be declared without body and marked abstract. This 
 transforms the class into an 
 abstract
  class as well, and Kotlin requires the class to 
 be marked abstract to be compilable.
  
 abstract class TheAbstractClass {
  
  abstract fun function([parameters]) ... 
 more functions ...
  
 }
  
 93
  
 www.EBooksWorld.ir",NA
 Polymorphism,"Inside a class, a singleton object, a companion object, or an interface, you can have 
 several functions using the same name with different parameters. There is no magic to 
 that, but this feature in object orientation theory has its own name: 
 polymorphism
 .
  
 If you have several functions with the same name, Kotlin decides by looking at the 
 parameters. An invoking code specifies which function to actually use. This dispatching 
 procedure usually works and you won’t see any problems, but with complicated 
 classes and lots of possibilities for a certain class, perhaps including complex 
 parameter lists with default arguments, interfaces, and varargs, the decision of which 
 function to call is not unambiguous. In such cases the compiler issues an error message 
 and you have to redesign the function call or your class for everything to work 
 correctly.
  
 94",NA
Caution,NA,NA
" Be careful with function naming: polymorphism (i.e., several ",NA,NA
functions with the same name) should not happen by accident or for ,NA,NA
"just technical reasons. instead, all functions using one particular name ",NA,NA
should serve the same purpose from a functional perspective.,NA,NA
 Local Functions,"In Kotlin, functions can be declared inside functions. Such functions are called 
 local 
 functions
  and they can be used from the point of their declaration until the end of the 
 enclosing function.
  
 fun a() {
  
  
  fun b() {
  
  
  
  ...
  
  }
  
  ...
  
 95
  
 www.EBooksWorld.ir",NA
 Inheritance,"In real life, inheritance means leaving one’s belongings to someone else. In object- 
 oriented computer languages like Kotlin, the idea is similar. Given a class A, writing 
 class B : A indicates that we give all the assets from class A to class B. What is this good 
 for, beyond having some kind of renamed copy of A? The magic is that class B can 
 overrule or 
 override
  parts of the assets it inherits from class A. This can be used to 
 alter some aspects of the class it inherits from to introduce new behavior.
  
 Although this overriding of functions and properties somewhat deviates from 
 the real-life analogy of inheritance, inheriting classes and overriding particular 
 functions and properties is one of the central aspects of any object-oriented 
 language.",NA
 Classes Inheriting from Other Classes,"The precise syntax for inheritance is
  
 open class A { ... } 
  
 class B : A() {
  
  
  [overriding assets]
  
  
  [own assets] 
  
 }
  
 if A has an empty default constructor, and
  
 open class A([constructor parameters]) { ... } class B : 
 A([constructor parameters]) {
  
  
  [overriding assets]
  
  
  [own assets] 
  
 }
  
 96",NA
Note,NA,NA
 this is a somewhat odd design decision from the makers of kotlin. ,NA,NA
it basically disables inheritance unless you add open to all possible ,NA,NA
"classes that could be used for inheritance. in real life, developers will ",NA,NA
likely forget to add open to all their classes or even refuse to add open ,NA,NA
"everywhere because it feels like a nuisance, so inheritance most likely ",NA,NA
is broken if your program uses classes from other programs or ,NA,NA
"libraries. unfortunately, there is no way out, so we have to live with ",NA,NA
"that. You can, of course, add open wherever needed in your own ",NA,NA
classes.,"In relation to each other, the class used as a basis for inheritance is also called a 
 superclass
  and the class inheriting from it is a 
 subclass
 . In the preceding code, therefore, 
 A is the superclass of B, and B is the subclass of A.
  
 In our NumberGuess example you can see, for instance, that our MainActivity 
 class inherits from AppCompatActivity. This subclassing of built-in activity classes is 
 important for any app to work with Android.",NA
 Constructor Inheritance,"At the very beginning of the subclass construction the superclass’s constructor including 
 the init{ } block will be called. If the superclass provides secondary constructors, for a 
 subclass it is also possible to call one of the secondary constructors instead. This 
 happens by simply using the secondary constructor’s parameter signature:
  
 97",NA
 Exercise 15,"What will be the output of
  
 open class A(open val a:Int) {
  
  
  fun x() {
  
  
  
  Log.d(""LOG"",
  
  
  
  
  ""A.x() -> a = ${a}"")
  
  
  }
  
 98
  
 www.EBooksWorld.ir",NA
 Overriding Functions,"To override functions of a superclass, in the subclass you have to use the override 
 modifier and write
  
 open class A {
  
  
  open fun function1() { ... } 
  
 } 
  
 class B : A() {
  
  
  override
  
  
  fun function1() { ... } 
  
 }
  
 Again we have to add open to the function in the superclass to make it eligible for 
 inheritance. The function could, of course, have a parameter list and parameter types 
 must be the same in the superclass and in the subclass for overriding to work 
 correctly. 
  
 99",NA
 Overriding Properties,"Kotlin has a special feature not found in other object-oriented languages. Not only is it 
 possible to override functions, but properties can also be overridden. For this to work, 
 such properties need to be marked open in the superclass, as in
  
 open class A {
  
  
  open var a:Int = 0 
  
 }
  
 A class that inherits from this superclass can then override the property by 
 declaring
  
 class B : A() {
  
  
  override var a:Int = 0 
  
 }
  
 Using this notation, any usage of the property from inside class B and A is then 
 covered by the property as declared in class B. The property behaves as if the 
 declaration in class A didn’t exist any longer, and functions in A formerly using “their” 
 version of this property will use the property from class B instead.",NA
 Exercise 16,"What will be the output of
  
 open class A() {
  
  
  private var g:Int = 99
  
  
  fun x() {
  
  
  
  Log.d(""LOG"", ""A.x() : g = ${g}"")
  
  }
  
  
  fun q() {
  
 100
  
 www.EBooksWorld.ir",NA
 Exercise 17,"In Exercise 16, remove the private from the property declaration and make class B 
 override property g from class A. What will be the output?",NA
 Accessing Superclass Assets,"Even with functions or properties overridden in some subclass, you can access the 
 original versions from the superclass if you prepend a super. So, for example, in
  
 open class A() {
  
  
  open var a:Int = 99
  
  
  open fun x() {
  
  
  
  Log.d(""LOG"", ""Hey from A.x()"")
  
  } 
  
 }
  
 101
  
 www.EBooksWorld.ir",NA
 Local Variables,"Local variables are val or var variables that get declared and used inside some function; 
 for example:
  
 class TheClass {
  
  
  fun function() {
  
  
  
  ...
  
 102
  
 www.EBooksWorld.ir",NA
 Exercise 18,"Which of the following classes is valid? For any invalid class, describe what the problem 
 is.
  
 1.    class TheClass {
  
  
  var a:Int = 7
  
  
  fun function() {
  
  
  
  val a = 7
  
  
  }
  
  }
  
 2.    class TheClass {
  
  
  
  fun function(a:String) {
  
  
  
  
  val a = 7
  
  
  
  }
  
  
  }
  
 3.    class TheClass {
  
  
  
  fun function() {
  
  
  
  
  println(a)
  
  
  
  
  val a = 7
  
  
  
  }
  
  
  }
  
 103",NA
 Visibility of Classes and Class Members,"We have mainly talked about classes, singleton objects, and companion objects 
 (structure units) and their properties and functions thus far in a literally free 
 manner:
  
 class TheName { // or object or companion object
  
  val 
 prop1:Type1
  
  
  var prop2:Type2
  
  
  fun function() {
  
  
  
  ...
  
  
  } 
  
 }
  
 Literally free here means structure units, functions, and properties declared this 
 way can be freely accessed from everywhere. In Kotlin, this kind of accessibility is called 
 public visibility
 . You can even add the keyword public to all of them this way to describe 
 this public visibility explicitly.
  
 104",NA
Note,NA,NA
" For small projects, you wouldn’t care about any visibility modifiers ",NA,NA
"apart from the default public one. For larger projects, adding visibility ",NA,NA
restrictions helps to improve software quality.,NA,NA
 Self-Reference: This,"Inside any class’s function, the keyword this refers to the current instance. We know that 
 from inside the class, we can refer to functions and properties from the same class by 
 just using their names. If visible, from outside the class we’d instead have to prepend the 
 instance name. You can consider this as the instance name that could be used from inside 
 the class, so, if we are in a function, to refer to a property or function from the same class 
 we could equivalently use
  
 functionName()      -the same as-      this.functionName() 
 propertyName        -the same as-      this.propertyName
  
 If a function’s argument uses the same name as a property of the same class, we 
 already know that the parameter 
 masks
  the property. We also know that we still could 
 access the property if we prepend this. In fact, this is the primary use case for using this. 
 Under some circumstances it could also help to improve the readability if you prepend 
 this. to function or property names. For example, in functions that set instance 
 properties, using this helps to express that setting properties is the primary purpose of 
 the function.
  
 Consider this:
  
 var firstName:String = """" 
  
 var lastName:String = """" 
  
 var socialSecurityNumber:String = """" 
  
 ...
  
 fun set(fName:String, lName:String, ssn:String) {
  
  
 this.lastName = lName
  
  
  this.firstName = fName
  
  
  this.socialSecurityNumber = ssn 
  
 }
  
  
 It technically also works without the three this. instances, but in that case it is less 
 expressive.
  
 110
  
 www.EBooksWorld.ir",NA
 Converting Classes to Strings,"In Kotlin, any class automatically and implicitly inherits from the built-in class Any. You 
 don’t have to explicitly state it, and there is no way to prevent it. This super-superclass 
 already provides a couple of functions, one of which has the name and return type 
 toString():String. This function is kind of a multipurpose diagnostic function that 
 frequently gets used to let an instance tell about its state in a textual representation. The 
 function is open, so any class can override this function to let your classes indicate 
 instance state in an informal way.
  
  
 You are free to do whatever you want inside an overridden toString(), but most of 
 the time one or the other property gets returned, as for example in this case:
  
 class Line(val x1:Double, val y1:Double,
  
  
  
  val x2:Double, val y2:Double) { {
  
  
  override fun toString() =
  
  
  
  ""(${x1},${y1}) -> (${x2},${y2})"" }
  
  
 Often you don’t want to miss what superclasses do in their own toString() 
 implementation, so you might prefer to write something like this:
  
 class Line(val x1:Double, val y1:Double,
  
  
  
  
  val x2:Double, val y2:Double) { {
  
  
  override fun toString() = super.toString()
   
  
 "" (${x1},${y1}) -> (${x2},${y2})"" 
  
 }
  
 Remember the super. addresses unoverridden properties and functions.
  
 111
  
 www.EBooksWorld.ir",NA
 Exercise 19,"Can you guess what happens if you write this?
  
 class Line(val x1:Double, val y1:Double,
  
  
  
  val x2:Double, val y2:Double) { {
  
  
  override fun toString() = toString() +
  
  
  "" (${x1},${y1}) -> (${x2},${y2})"" }
  
 Many built-in classes in their toString() implementation already provide some useful 
 output, so in most cases you don’t have to override built-in classes just for the sake of 
 providing a sensible toString() output. What happens for some of the other built-in 
 classes and for any of your classes without their own toString() implementation is that 
 toString() indicates the memory position of the instance. For example:
  
 class A 
  
 val a = A() 
  
 println(a.toString())
  
 will print something like A@232204a1, which, depending on the circumstances, 
 is not very informative. Therefore for diagnostic output, providing a toString() 
 implementation is a good idea.
  
 112
  
 www.EBooksWorld.ir",NA
CHAPTER 4,NA,NA
Classes and ,NA,NA
Objects: Extended ,NA,NA
Features,"This chapter covers some extended object orientation features that are not necessary 
 for a program to work, but nevertheless improve readability and expressiveness. The 
 chapter presumes that you have read Chapter 
 2
 . We also use the NumberGuess 
 sample app from Chapter 
 2
 .",NA
 Anonymous Classes,"Inside your coding in some instances you might want to create a one-time 
  
 implementation of an interface or a one-time subclass of some class. While in Kotlin, it is 
 possible to write
  
 class A : SomeInterface {
  
  
  // implement interface functions ...
  
 } 
  
 val inst:SomeInterface = A() 
  
 // use inst ...
  
 or
  
 open class A : SomeBaseClass() {
  
  // override functions ...
  
 } 
  
 val inst:SomeBaseClass = A() 
  
 // use inst ...",NA
Note,NA,NA
 The object : inside the declaration suggests that there is just a one-,NA,NA
time instantiation. It is not possible to have several instances of ,NA,NA
anonymous classes.,"We know that this refers to the actual instance. This is also the case from inside 
 anonymous classes, where this refers to the one instance of the anonymous class. There 
 is an extension of this that allows us to get the instance of the 
 enclosing
  class: Just 
 append @ClassName to this. For example in
  
 interface X {
  
  
  fun doSomething() 
  
 } 
  
 class A {
  
  
  fun meth() {
  
  
  
  val x = object : X {
  
  
  
  
  override doSomething() {
  
 114",NA
 Inner Classes,"Classes and singleton objects can also be declared inside other classes or singleton 
 objects, and even inside functions. They then can be accessed from inside their scope, so 
 if a class or singleton object gets declared inside some class A, it can be instantiated 
 inside A. If it is declared inside a function, it can be used from the point of its declaration 
 until the end of the function.
  
 class A {
  
  
  class B { ... }
  
  
  // B can now be instantiated from
  
  
  // everywhere inside A
  
  
  fun meth() {
  
  
  
  ...
  
  class C { ... }
  
  // C can now be used until the end of // the 
 function
  
  ...
  
  
  } 
  
 }
  
 Classes and objects inside other classes or other objects can be addressed from 
 outside using a path specification similar to packages: If X as a class or an object gets 
 declared inside A (a class or a singleton object), you can write A.X to access it from 
 outside. You should probably do this, however, only if the inner class provides some 
 kind of interface to the enclosing class, to avoid breaking encapsulation principles.
  
 115
  
 www.EBooksWorld.ir",NA
 Functions and Properties Outside Classes,"In your project you can have Kotlin files that do not contain a single class, interface, or 
 object declaration but nevertheless show val and var properties and functions. 
 Whereas at first sight we seem to work outside object orientation if we use such files, 
 in fact the Kotlin compiler implicitly and secretly creates a singleton object based on 
 the 
 package
  name and puts such properties and functions into this object.",NA
Note,NA,NA
 For very small projects it is acceptable to not use explicit classes ,NA,NA
"and singleton objects. If a project gets bigger, it is still possible to only use ",NA,NA
"such nonclass files, but you’ll then risk having chaotic and unreadable ",NA,NA
code in the end.,"Derived from that fact, the following rules apply for such properties and functions:
  
 • It does not matter where in the file you declare val and var properties 
 and functions; they will be usable from everywhere in the file.
  
 • Such properties and functions are visible to other classes or singleton 
 objects you write in other files using importthe.package.name.name 
 where the last name refers to the property or function name.
  
 • You can have several files of that type inside a package. The Kotlin 
 compiler then just sequentially parses all the files and gathers all the 
 functions and properties that are neither from inside a class nor a 
 singleton object. The file names play no role here.
  
 116
  
 www.EBooksWorld.ir",NA
 Exercise 1,"You have a utility singleton object
  
 package com.example.util
  
 object Util {
  
  
  fun add10(a:Int) = a + 10
  
  
  fun add100(a:Int) = a + 100 
  
 }
  
 and a client
  
 package com.example
  
 import com.example.util.Util
  
 class A(q:Int) {
  
  
  val x10:Int = Util.add10(q)
  
  
  val x100:Int = Util.add100(q) 
  
 }
  
  
 Could you think of a way to rewrite the Util.kt file to not use the object { } 
 declaration? What will the client code look like?
  
 117
  
 www.EBooksWorld.ir",NA
 Importing Functions and Properties,"Functions and properties from singleton objects can be imported via import statements 
 like these
  
 import package.of.the.object.ObjectName.propertyName 
 import package.of.the.object.ObjectName.functionName
  
 at the top of the file, after the package declaration and together with the other import 
 statements for importing classes and singleton objects. It is then possible to directly use 
 the function or property by using just its name, without a prepending ObjectName.",NA
Note,NA,NA
 There is no wildcard for importing all properties and functions of a ,NA,NA
singleton object. You have to put each of them into its own import line.,NA,NA
 Exercise 2,"Given that Math.log() calculates the logarithm of a number, and with Math residing 
 inside package java.lang, rewrite
  
 package com.example 
  
 class A {
  
  
  fun calc(a:Double) = Math.log(a) 
  
 }
  
 such that Math. is no longer needed.",NA
 Data Classes,"Classes that only contain properties and no or very few functions most likely are 
 data 
 classes,
  the purpose of which is to provision a bracket around a couple of properties. 
 They thus serve as a kind of container gathering a range of properties. Think of a 
 Person class which for a person gathers the name, birthday, place of birth, SSN, and so 
 on. 
  
 Kotlin has a special notation for such classes: Prepend data as in
  
 data class ClassName([constructor])
  
 118",NA
 Exercise 3,"With the data classes
  
 data class Point2D(val x:Double, val y:Double) 
  
 data class Point3D(val x:Double, val y:Double, val z:Double)
  
 119
  
 www.EBooksWorld.ir",NA
 Exercise 4 ,"Which classes of the NumberGuess game are considered data classes? Perform the 
 conversion.",NA
 Enumerations ,"The enumeration type is basically a nonnumeric data type with values from a given set. 
 Basically here means that internally the type gets handled by an integer by default, but 
 in basic usage scenarios you don’t have to be concerned about that. The term 
 set 
 is used 
 in a mathematical sense, which means that values must be unique and do not have a sort 
 order.
  
 Enumerations in Kotlin are a specialized form of a class:
  
 enum class EnumerationName {
  
  
  VALUE1, VALUE2, VALUE3, ...
  
 }
  
 where for EnumerationName you can use any camelCase name and VALUEx is any 
 string from the character set A-Z0-9_ starting with a letter or _.",NA
Note,NA,NA
" For the values, technically more characters are available, but by ",NA,NA
convention you should use a combination of the characters shown here.,"120
  
 www.EBooksWorld.ir",NA
 Exercise 5,"Add a Gender enumeration to the GameUser class from the NumberGuess game app. 
 Allow values M, F, and X. Add a corresponding constructor parameter gender to the 
 GameUser constructor parameters with default value X.",NA
 Custom Property Accessors,"We know that a var property basically gets declared by writing
  
 var propertyName:PropertyType = [initial_value]
  
  
 We also know that to get the var we write object.propertyName and to set it we 
 write object.propertyName =...
  
 122
  
 www.EBooksWorld.ir",NA
 Exercise 6,Can you guess what can be done with val instead of var properties?,NA
 Exercise 7,"Write an str property that does the same as the toString() function (so it is possible to 
 write obj.str instead of obj.toString()).",NA
 Exercise 8,"Recall the NumberGuess game app:
  
 data class GameUser(var firstName:String,
  
  
  var lastName:String,
  
  
  
  var userName:String,
  
  
  
  var registrationNumber:Int,
  
  
  var gender:Gender = Gender.X,
  
  
  
 var birthday:String = """",
  
  
  var 
 userRank:Double = 0.0) {
  
  enum class 
 Gender{F,M,X}
  
  
  var fullName:String
  
  
  var initials:String
  
  
  init {
  
  
  
  fullName = firstName + "" "" + lastName
  
  
  initials = firstName.toUpperCase() +
  
  
  
  lastName.toUpperCase()
  
  } 
  
 }
  
 124
  
 www.EBooksWorld.ir",NA
 Kotlin Extensions,"In Kotlin, it is possible to “dynamically” add extensions to classes. We need to put that 
 dynamically in quotation marks because the usage of such extensions must be defined 
 in your code prior to execution. It is not possible in Kotlin to decide during runtime 
 whether or not, and if so, which extensions get used. Computer language designers 
 usually refer to such features as 
 static
  features.
  
 Here is what we mean by extensions: Wouldn’t it be nice if we could add functions 
 and custom properties to any class? This could be very useful, for example, if we want to 
 add extra functionality to classes and functions provided by others. We know we can use 
 inheritance for that purpose, but depending on the circumstances, this might not be 
 possible or the implementation could feel clumsy.",NA
Caution,NA,NA
 The extension mechanism is extremely powerful. be ,NA,NA
cautious not to overuse it. You can write very elegant code using ,NA,NA
extensions that no one understands without time-consuming ,NA,NA
research of the extension definitions.,NA,NA
 Extension Functions,"Consider we’d like to have a hasLength(l:Int): Boolean function inside the built-in 
 String class. You might think that this is what inheritance is used for. However, it is not 
 possible to extend the String class, because it is forbidden to extend String by design, 
 so we can’t use inheritance for that aim. Still, the Kotlin extension mechanism helps us 
 here. We can write
  
 package the.ext.pckg
  
 fun String.hasLength(len:Int) = this.length == len
  
 125",NA
Note,NA,NA
 If extension functions have the same name and function ,NA,NA
"signature (parameter set) as already existing functions, the ",NA,NA
latter take priority.,NA,NA
 Extension Properties,"A similar procedure works for properties. Say you want to add an l property to String 
 that does the same as .length() and calculates the string length. You can do that via 
 some construct like this:
  
 package the.ext.pckg
  
 val String.l get() = this.length
  
 Note that we can’t use val String.l = this.length because for technical reasons 
 extension properties are not allowed to actually create real data fields. An initialization 
 is thus not possible, because in fact there is nothing that can be initialized. As for getters 
 we can write what we want, so we can directly refer to .length. Now it is possible to 
 write
  
 import the.ext.pckg.*
  
 // anywhere inside a function ...
  
 val len1 = someString.length 
  
 val len2 = someString.l // this is the same",NA
 Extensions with Nullable Receivers,NA,NA
Note,NA,NA
Receiver,NA,NA
 refers to the class or singleton object that is being extended.,"It is possible to catch null values for the extension. If you prepend a question mark as in
  
 fun SomeClass?.newFunction(...) { ... }
  
 you can check whether this == null inside the body and appropriately react in such 
 cases to do the right thing. You can then write instance.newFunction(...) even if 
 instance is null and even then get into the extension function.",NA
 Encapsulating Extensions,"If you want to encapsulate extensions inside particular classes, singleton objects, or 
 companion objects, it is possible to write something like this:
  
 class SomeClass {
  
  
  fun SomeOtherClass.meth() {
  
  
  
  ...
  
  
  } 
  
 }
  
 Here SomeOtherClass receives the extension function, but that function can only be 
 used from inside SomeClass. For the hasLength() extension for the String class, the 
 encapsulated version thus reads
  
 class SomeClass {
  
  
  fun String.hasLength(len:Int) = this.length == len
  
  fun 
 function() {
  
  
  
  ...
  
  // we can use hasLength() here
  
  val len10:Boolean = someString.hasLength(10) ...
  
  
  } 
  
 }
  
 127
  
 www.EBooksWorld.ir",NA
 Functions with Tail Recursion,"Recursive functions call themselves. This happens once in a while for certain algorithms. 
 For example, the factorial function n! = n⋅(n−1)⋅(n−2)⋅...2⋅1 can be implemented as
  
 fun factorial(n:Int):Int {
  
  
  return if(n==1) n else n * factorial(n-1) }
  
 Note that the if() expression returns the part before or after the else, depending on 
 whether the argument evaluates to true or false (we’ll be talking about branching later 
 in the book).
  
 128
  
 www.EBooksWorld.ir",NA
 Infix Operators,"Infix operators are used for operations notated by
  
 operand1    OPERATOR    operand2
  
 We know a lot of such infix operators: Think of multiplication (3 * 4), addition (3 + 
 4), and more. In Kotlin, many such infix operators are predefined, but it is also possible 
 to define your own infix operators. To do so, write
  
 infix operator 
  
 fun SomeClass1.oper(param:SomeClass2) = ...
  
 where oper is the name of the operator (use your own) and the ... performs any 
 calculation using this (the instance of SomeClass1) and param. You can then write
  
 [expression1] oper [expression2]
  
 where the type of [expression1] is SomeClass1 and the type of [expression2] is 
 SomeClass2. For more complicated calculations you can also use a function body 
 as usual:
  
 infix operator
  
 129
  
 www.EBooksWorld.ir",NA
 Operator Overloading,"Operators take one or two expressions and produce a single output from that using 
 the following notation:
  
 [OPER] expression 
  
 [expression] [OPER] [expression]
  
 130
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 because in the operator function body or expression you can ,NA,NA
"calculate what you want, you can let the operator do strange stuff. ",NA,NA
just bear in mind that your class users expect a certain behavior ,NA,NA
"when operators are used, so be reasonable with what you calculate ",NA,NA
there.,133,NA
 Exercise 9,"Add - and + operators to the Vector class. The calculation consists of adding or 
  
 subtracting the dx and dy members: Vector(this.dx + v2.dx, this.dy + v2.dy) and 
 Vector(this.dx - v2.dx, this.dy - v2.dy) if v2 is the operator function parameter.",NA
 Delegation,"We learned that inheritance via class TheClass : SomeInterface { ... } lets 
  
 TheClass implement functions the interface only declares in an abstract manner. The 
 implementation code enters the overridden functions in TheClass. Delegation is similar 
 to inheritance; it starts the same way: class TheClass : SomeInterface ... . The difference 
 is where the implementing code resides: For delegation it is presumed that an object is 
 at hand that already implements the interface and TheClass primarily delegates the 
 work to this object. Using the constructs we already know, this could be written as:
  
 interface TheInterface {
  
  
  fun someMethod(i:Int):Int
  
  
  ...more functions 
  
 }
  
 class Implementor0 : SomeInterface {
  
  
  override fun someMethod(i:Int):Int = i*2
  
  
 ...implement the other functions 
  
 }
  
 134
  
 www.EBooksWorld.ir",NA
CHAPTER 5,NA,NA
Expressions: ,NA,NA
Operations on Data,"We already used expressions a couple of times. Whenever you need to assign a value to 
 a variable, need function call parameters, or need to provide a value to some kind of 
 language construct, you need an expression. Expressions also show up where you don’t 
 expect them, and they can be ignored if we don’t need them.",NA
 Expression Examples,"Expressions can be subdivided into different types: numerical expressions, boolean 
 expressions, string and character expressions, expressions acting on bits and bytes, and 
 a few more unclassified expressions. Before we start explaining them in detail, here are 
 some examples:
  
 4 * 5         // multiplication 
  
 3 + 7         // addition 
  
 6 – 1         // subtraction 
  
 ""a"" + ""b""     // concatenation 
  
 ( 1 + 2 )     // grouping
  
 -5            // negation 
  
 a && b        // boolean a AND b 
  
 ""Hello""       // constant (String) 
  
 78            // another constant (Int) 3.14          // 
 another constant (Double) 'A'           // another 
 constant (Char) arr[43]       // index access 
  
 funct(...)    // function invocation
  
 © Peter Späth 2019 
  
 137
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_5
  
 www.EBooksWorld.ir",NA
 Ubiquity of Expressions,"In Kotlin, unlike many other computer languages, almost everything is an expression. 
 Look, for example, at the function invocation funct(). You might think that a function not 
 declared returning a value as in fun funct() { ... } is not an expression, because it 
 seemingly cannot be assigned to a variable. Try it and write
  
 fun a() { 
  
 }
  
 val aa = a()
  
 Surprisingly the compiler does not mark this code as erroneous. In fact, such a 
 function actually does return a value; it is the instance of the Unit class and gets called 
 Unit itself. You cannot do anything interesting with it, but it is a value and it makes a 
 function not explicitly returning anything implicitly return something.
  
  
 In the rest of this chapter we cover different expression types and 
 conversions between them.",NA
 Numerical Expressions,"Numerical expressions are constructs built of elements like literals, properties, and 
 subexpressions, possibly combined by operators and resulting in a number. The set 
 of commonly known operators referring to addition, subtraction, multiplication, and 
 division are usually called 
 arithmetics
 . In computation, this set of standard operators 
 usually gets augmented by an increment and decrement operator ++ and 
 −−
 , and an 
 integer division remainder operator %. For the full list of possible elements that are 
 usable for numerical expressions inside Kotlin, see Table 
 5-1
 .
  
 138
  
 www.EBooksWorld.ir",NA
 Exercise 1,"With Math.sqrt(...) designating the square root 
  
  
 , write this in Kotlin code:
  
 a
  + 
 b
  - 
 x
  
 2 
 b
  
 2
  - × 
 x
  
 Assume a, b, and x are existing properties.",NA
 Boolean Expressions,"Boolean expressions are expressions that evaluate to one of the boolean values true or 
 false. We use boolean expressions often if we need to decide which parts of a program 
 participate in the program flow. Objects and operators that participate in boolean 
 expressions are listed in Table 
 5-3
 .
  
 Table 5-3. 
 Boolean Expression Elements
  
 Symbol
  
 Meaning
  
 Examples
  
 literal 
  
 variable 
  
 funct()
  
 a literal
  
 true or false
  
 a property
  
 val a = true; val b = a
  
 the value of a function, if it returns a boolean fun a() = true; 
  
 val b = a()
  
 [ ]
  
 access to an element in an array or a 
 list of 
  
 arr[0]
  
 ( )
  
 booleans
  
 list[7]
  
 replaced by the result of the inside 
  
 b1 && ( a || b )
  
 expression
  
 (note: && = anD, || = or)
  
 (
 continued
 )
  
 141
  
 www.EBooksWorld.ir",NA
 String and Character Expressions,"There are not too many expression elements for strings. You can, however, concatenate 
 strings and perform string comparisons. See Table 
 5-5
  for the full list of string 
 expression elements.
  
 Table 5-5. 
 String Expression Elements
  
 Symbol
  
 Meaning
  
 Examples
  
 literal
  
 a literal
  
 ""Hello world""
  
 or """"""Hello world""""""
  
 variable
  
 a property
  
 val a = ""abc""; val b = a
  
 funct()
  
 the value of a function, if it 
 returns a 
  
 fun a() = ""abc""; val b = a()
  
 string
  
 [ ]
  
 access to an element in an array 
 or a 
  
 arr[0]
  
 str[ ]
  
 list of strings
  
 list[7]
  
 extracts a character from a string
  
 ""Hello"" [1] (yields ""e"")
  
 ( )
  
 replaced by the result of the 
 inside 
  
 ""ab"" + (""cd"" + ""ef"" )
  
 expression
  
 +
  
 string concatenation
  
 val a = ""Hello "" + ""world""
  
 (yields →""Hello world"") 
  
  
 (
 continued
 )
  
 144
  
 www.EBooksWorld.ir",NA
 Bits and Bytes,"A byte is a more hardware-oriented data storage unit. We know that there is a Byte 
 type and that it has values between −128 and 127. A byte corresponds to some 
 hardware storage and processing element that can be accessed and used in an 
 extremely fast manner. In your app you use bytes only once in a while, especially when 
 it comes to using some low-level system functions or addressing connected hardware 
 elements like the camera or the speaker.
  
 146
  
 www.EBooksWorld.ir",NA
 Other Operators,"Kotlin has a few more operators we can use in expressions. They don’t fit well into 
 the distinction among numeric, boolean, string and character, and bit expressions, so 
 we present them on their own in Table 
 5-8
 .
  
 148
  
 www.EBooksWorld.ir",NA
Caution,NA,NA
" even if the !! seems to be a versatile tool to simplify coding, you ",NA,NA
should not use it often. the operator somewhat thwarts Kotlin’s way of ,NA,NA
handling nullability. the !! breaks non-nullability and hides the ,NA,NA
advantages we have by differentiating between nullable and non-nullable ,NA,NA
types and expressions.,NA,NA
 Exercise 2,"Create a class Concatenator that allows string concatenation via a function 
  
 add(s:String). Add another function such that it is possible to write the following to see 
 whether the concatenated string contains some substring.
  
 val c = Concatenator() 
  
 c.add(""Hello"") 
  
 c.add("" "") 
  
 c.add(""world"") 
  
 val contained = ""ello"" in c",NA
 Conversions,"If you have a val or var property or a function parameter of some type, the question is 
 what happens if in an assignment we provide an expression of a different type. If this 
 type mismatch is substantial, for example if we need an Int number and a String gets 
 provided, the compiler will fail and we need to fix it. In other cases, for example 
 providing an Int if we actually needed a Long, a simple conversion between the types 
 would be nice.
  
 150
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" as a rule of thumb during coding, you can test whether ",NA,NA
"automatic conversions are possible, but in most cases it is better to ",NA,NA
explicitly declare the conversion.,"In expressions where operators work, another kind of conversion rules applies. 
 For any operator
  
 a°b
  
 where a is of type AType and b is of type BType, the operator implementation 
 decides what the operation outcome type is. An important case is
  
 [Number]   °  [Number]
  
 where [Number] is out of Byte, Short, Int, Long, Float, or Double, and the operator is 
 any numeric operator (+ - / * %). Here the type returned by the expression in most 
 cases is the type with the higher precision. The precision ranking is Byte < Short < Int 
 < Long < Float < Double. For example:
  
 7 + 10_000_000_000L -> Long 
  
 34 + 46.7          -> Double
  
  
 Another type of operator-induced conversion you’ll see quite often in Kotlin 
 programs is
  
 String + [Any]
  
  
 Here a concatenation of the string and the outcome of .toString() on [Any] will 
 happen. For example:
  
 ""Number is ""  +  7.3                ->   ""Number is 7.3"" ""Number is ""  +  
 7.3.toString()     ->   ""Number is 7.3"" ""Hell"" + 'o'                        ->   
 ""Hello""
  
 153
  
 www.EBooksWorld.ir",NA
CHAPTER 6,NA,NA
Comments in Kotlin ,NA,NA
Files,"Comments in computer language files are text that does not belong to the computer 
 language itself and thus have no influence over the program execution, but provide a 
 textual description of elements and constructs used in the program. Comments help the 
 reader to understand your program.
  
  
 From a technical point of view comments are easy to generate and differentiate from 
 the program syntax itself.
  
 • Everything starting with a double slash // (not inside a string literal) to 
 the end of the line is a comment.
  
 • Everything starting with a /* and ending with a */ (both not inside a 
 string literal) is a comment, no matter how many lines are spanned by 
 this.
  
 At first glance, comments might seem like a nice-to-have feature in programs, and 
 adding or omitting them seems to be a personal decision of each developer. There is 
 more to commenting, though. Looking a bit closer at the matter, comments are handled 
 in the realm between two limits:
  
 • 
 Writing no comments at all:
  For short programs and those that are 
 extremely well structured and self-explanatory, it is a valid, although 
 arguable position to write no comments at all. The advantages of such an 
 approach are obvious: You have to write less, there is no danger of 
 confusing comments and source code, and following the approach 
 properly will result in comprehensive code of high quality. There are 
 disadvantages as well, though: You might be wrong in your assessment of 
 whether your code is self-explanatory, tools depending on comments do 
 not provide output, or your company’s quality assurance guidelines might 
 get violated.",NA
Note,NA,NA
 I owe you a confession here. The NumberGuess game app ,NA,NA
from the previous chapters did not contain any comments in the ,NA,NA
sources I provided. ,NA,NA
"Comments were left out to keep the listings small, and the floating text ",NA,NA
around those listings serves as a substitute for the reader. After you’ve ,NA,NA
"read this chapter, feel free to remedy this and add appropriate ",NA,NA
"comments to the classes, interfaces, and singleton objects there.","In this chapter we cover exactly how comments should be added to Kotlin files, 
 including what can be done with them.",NA
 Package Comments,"We learned that packages correspond to files with a strong cohesion of their purpose 
 and functioning. From a technical point of view, each package also corresponds to a 
 directory in the operating system’s file hierarchy.
  
 It makes sense to describe packages through appropriate commenting, and the 
 way we do this in Kotlin is as follows: For each package, that is to say inside each 
 folder, create a file package-info.md. To do this inside Android Studio, you must switch 
 to the Project Files view type in the project explorer (see Figure 
 6-1
 ). Click the small 
 gray downward-pointing rectangle next to Android to switch the view type. You can 
 then right-click on one of the packages and from the shortcut menu select New 
 ➤
  File. 
 Enter the complete file name package-info.md.
  
 Files with the suffix .md are 
 Markdown
  files. Markdown is a styling language 
 similar to HTML, but with its own simplified syntax. We are going to describe 
 Markdown soon, but first we must teach Android Studio how to handle Markdown 
 files. To do 
  
 156",NA
 Markdown ,"Both Markdown files as used for package descriptions and inlined documentation inside 
 your Kotlin code files use a common syntax for styling issues. These Markdown syntax 
 elements are described in Table 
 6-1
 .
  
 Table 6-1. 
 Markdown Syntax
  
 Style
  
 Markdown Syntax
  
 Hints
  
 heading 
  
 # Heading
  
 The package-info.md file must not contain more than 
 one 
  
 level 1
  
 ## Heading
  
 level 1 heading. You can add a # at the end of the header 
 line.
  
 heading 
  
 The number of # determines the level. You can 
 improve 
  
 level 2–6
  
 readability by appending the same number of # at the 
 end of 
  
 ### Heading
  
 Unordere
 d 
  
 the header.
  
 …
  
 - Item1
  
 You could also use + or * as an item indicator.
  
 list
  
 - Item2
  
 …
  
 ordered list
  
 1. Item1
  
 The consecutive numbering will be assured 
 automatically, so 
  
 2. Item2
  
 you could write any number (write always “1.” or 
 whatever).
  
 …
  
  
 (
 continued
 )
  
 159
  
 www.EBooksWorld.ir",NA
 Class Comments,"We know that multiline comments can be written as /* ... */. As a slight modification, for 
 documenting code elements the convention is to add another asterisk (*) to the left 
 comment bracket: /** ... */, and in addition every line inside the comments is supposed 
 to start with an asterisk as shown here:
  
 /**
  
  *The comment ...
  
  * ...
  
  */
  
 This is still a multiline comment that happens to start with an asterisk, but the 
 tool that knows how to extract the documentation from the code recognizes this 
 as something that needs to be handled. You can still use normal multiline 
 comments /* ... */ at will, but the documentation tool will just ignore them.
  
 Class comments are written just in front of the class ... declaration, as such an 
 adapted multiline comment /** ... */. The content of the class description comment is 
 Markdown code, as described earlier.
  
 The first paragraph of such documentation should provide a short summary, as 
 tools might use it for listings. In addition to standard Markdown elements, in the 
 documentation you can add elements as follows:
  
 • @param <name> description: Describes a type parameter <name> of 
 the class. Class type parameters are described later in the book. You can 
 also write @param[name] description.
  
 162
  
 www.EBooksWorld.ir",NA
 Function and Property Comments,"For functions and properties, you basically do the same as for classes. Just add /** ... */ 
 in front of any function or property you want to comment. As for class documentation, 
 you start each line with any number of spaces and an asterisk. Inside use Markdown 
 code again. For example:
  
 ...
  
 class SomeClass {
  
  /**
  
  * This describes property prop
  
  * ...
  
  */
  
  val prop:Int = 7
  
  /**
  
  * This describes function func
  
  * ...
  
  
  */
  
  fun func() {
  
   
  ...
  
  
  } 
  
 }
  
  
 As for classes, interfaces, and singleton objects, the first paragraph of such 
 documentation should provide a short summary, as tools might use it for 
 listings.
  
 For properties, there are a couple of additional elements you can use:
  
 • @sample <specifier>: Inserts the specified function’s code.
  
 • @see <specifier>: Adds a link to the specified identifier (a class, 
 interface, singleton object, property, or method).
  
 • @author description: Adds authoring information.
  
 • @since description: Adds information about how long the 
 documented element has existed (version info, etc.).
  
 • @suppress: Excludes the property from the documentation.
  
 165",NA
 Exercise 1,"Add comments to all packages, classes, and public functions of the NumberGuess game 
 app.",NA
 Generate Your Own API Documentation,"With all elements of a program properly documented, we now need to find a way to 
 extract the documentation for creating, for example, a collection of interlinked HTML 
 documents. The generated documentation should describe all classes, interfaces, and 
 singleton objects, as well as all public methods and properties. Because these elements 
 are enough for a client software to know how to interact with your program, such 
 documentation is commonly referred to as 
 application programming interface (API) 
 documentation.
  
 166",NA
Note,NA,NA
 The term ,NA,NA
library,NA,NA
" commonly refers to programs built by others, ",NA,NA
from which parts get used by your app to perform certain tasks. You’ll ,NA,NA
very often add libraries to your projects so you can benefit from the ,NA,NA
work others have made available to the public.,"Open the Project build.gradle and add the following line right under buildscript {:
  
 ext.dokka_version = '0.9.17'
  
 In the same file, inside the dependencies block also add (one line):
  
 classpath ""org.jetbrains.dokka:
  
  
  dokka-android-gradle-plugin:${dokka_version}""
  
 This ensures the Dokka library gets added to the project.
  
 167
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 Dokka by default doesn’t know how to handle our package-info.md ,NA,NA
files. It instead expects a single file packages.md. The preparation step ,NA,NA
gathers all package- info.md files and builds a packages.md file. By the ,NA,NA
"way, this little script is written in Groovy, the language on which the ",NA,NA
Gradle build system relies.,168,NA
CHAPTER 7,NA,NA
Structural Constructs,"From the very beginning of computer languages, conditional branching of the program 
 flow has been one of the most basic things program code must be able to express. This 
 branching happens inside functions, so it imposes some kind of substructuring inside 
 classes and singleton objects. In this chapter we cover such branching constructs, 
 together with auxiliary classes that help us write corresponding code.",NA
 Ifs and Whens,"In real life many actions are based on decisions. If some condition is met, an action A 
 happens; otherwise, action B happens. For any programming language we need 
 something similar, and the most basic way of creating such a branching of the program 
 flow is the venerable if–else if–else construct. You check some condition, and if it is met, 
 the if branch gets executed. If not, optionally you check another else if condition, and if 
 this one is met, the corresponding branch is executed. After potentially more else if 
 clauses, a final else block gets executed if none of the if and else if checks yield true.
  
 In Kotlin, of course, we have such an if–else if–else program construct, which reads
  
 if( [condition] ) {
  
  
  [statements1] 
  
 } else if( [condition2] ) {
  
  
  [statements2] 
  
 } else if( [condition3] ) {
  
  
  [statements3] 
  
 ... more ""else ifs"" 
  
 } else {
  
  
  [statementsElse] 
  
 }
  
 © Peter Späth 2019 
  
 171
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_7
  
 www.EBooksWorld.ir",NA
 Ranges,"Ranges frequently get used for looping needs. We discuss looping in the next section, so 
 consider this section a preparatory step. A range is defined by two bound values and the 
 way values in between get interpolated.
  
  
 In Kotlin there are three types of ranges for Int, Long, and Char types. Using the 
 constructors, they can be built as follows:
  
 val r1 = IntRange(1, 1000) 
  
 val r2 = LongRange(1, 10_000_000_000) 
  
 val r3 = CharRange('A', 'I')
  
 In addition, to achieve the same you can use the range operator .. as follows:
  
 val r1 = 1..1000 
  
 val r2 = 1L..10_000_000_000L 
  
 val r3 = 'A'..'I'
  
 Finally, a couple of Kotlin standard library functions return ranges or act on 
 ranges. Any integral type (i.e., Byte, Short, Int, Long, and Char) has a rangeTo() 
 function to create a range from it. A 7..77 can therefore also be built by writing 
 7.rangeTo(77).
  
 175",NA
 For and While Loops,"A loop corresponds to a program part iterated over and over multiple times. One 
 possibility for such a loop is a for loop, which reads as follows:
  
 for( i in [loop data] ) {
  
  
  // do something with i 
  
 }
  
 where [loop data] is a range, a collection, an array, or any other object that has a 
 function iterator() returning an object that has a next():E and a hasNext():Boolean 
 function (E is the loop variable type). In the latter case all three functions, iterator(), 
 next(), and hasNext(), must be marked with operator.
  
  
 Similar to for loops are while and do .. while loops, which continue to loop until 
 some condition yields false:
  
 while( [condition] ) {
  
  
  // do something 
  
 }
  
 176
  
 www.EBooksWorld.ir",NA
Note,NA,NA
For and while loops are now considered quite old school. using ,NA,NA
forEach() on collections gives more power over loop preparation ,NA,NA
"actions like transformation and filtering, so prefer forEach() over for ",NA,NA
and while. We talk a lot about collections and iterating over collection ,NA,NA
data in a later chapter.,NA,NA
 Scoping Functions,"A couple of Kotlin’s standard library functions are extremely powerful when it comes 
 to expressiveness of your code. Five of them—apply, let, also, run, and with—are called 
 scoping functions
  because they open a new scope inside a function and thus improve 
 program flow structuring. Let’s see what they do and how they help us to write better 
 code.
  
 177",NA
Note,NA,NA
" By the way, if you need a mnemonic to memorize them, read “let ",NA,NA
us alSo run WIth applY.”,NA,NA
 The apply Function,"Let us look at the first one of these scoping functions, apply. You can hang this at any 
 object, as in
  
 object.apply {
  
  
  ...
  
 }
  
 That doesn’t look too adventurous, but the magic is what happens to the object 
 instance inside the curly brackets of apply: It gets transported to this. In addition, apply 
 automatically returns the object instance. Therefore if we write this.someProperty or 
 someProperty, or this.someFunction() alias someFunction(), it refers to the object in 
 front of apply, not to the surrounding context. What does that mean? Well, consider this:
  
 class A { var x:Int, var y:Int } 
  
 val instance = A() 
  
 instance.x = 4 
  
 instance.y = 5 
  
 instance.y *= instance.x
  
  
 If we now write .apply{ … } right behind the initialized object, we can use this to 
 access the instance and get
  
 class A { var x:Int, var y:Int } 
  
 val instance = A().apply{
  
  
  this.x = 4
  
  
  this.y = 5
  
  
  this.y *= this.x 
  
 }
  
 178
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 Because propertyName and functionName() target the this ,NA,NA
"instance, we can also say that this represents the ",NA,NA
receiver,NA,NA
 of such simple ,NA,NA
"property and function accesses. Without a scoping function, this refers ",NA,NA
to the surrounding class instance or singleton object. With this redefined ,NA,NA
inside apply{ ... } the instance in front of .apply becomes the new ,NA,NA
receiver.,"If a property or function identifier used inside the apply{} construct does not exist in 
 the receiver object, the surrounding context gets used instead:
  
 var q = 37 
  
 class A { var x:Int, var y:Int } 
  
 val instance = A().apply {
  
  
  x = 4
  
  
  y = 5
  
  
  q = 44 // does not exist in A, so the q from
  
  
  // outside gets used 
  
 }
  
 This strong coupling of the object the apply{ … } gets operated at, and the this scope 
 functions and properties inside the curly brackets being received by the same object, 
 makes the apply{} construct an extremely good candidate for preparing objects right 
 after their instantiation:
  
 val x = SomeClass().apply {
  
  
  // do things with the SomeClass instance
  
  // 
 while assigning it to x 
  
 }
  
 179",NA
 The let Function,"The let scoping function frequently gets used to transform an object into a different 
 object. Its complete synopsis reads like this:
  
 object.let { o ->
  
  
  [statements] // do s.th. with 'o'
  
  
  [value] 
  
 }
  
 The last line must contain the expression that let{} is supposed to return. The let{} 
 construct has a function as a parameter, and if you write it as shown here and using an 
 anonymous 
 lambda
  function with o as a parameter, this parameter function gets the 
 object itself as a parameter. You can also omit the o ->, in which case a special variable it 
 automatically gets used instead:
  
 object.let {
  
  
  [statements] // do s.th. with 'it'
  
  
 [value] 
  
 }
  
 180
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 Writing let { } without a x -> inside the curly brackets looks as if ,NA,NA
"the { } was a function block. this is a syntactical coincidence; in fact, it ",NA,NA
is an ,NA,NA
anonymous lambda function with the automatic variable it as the ,NA,NA
parameter.,NA,NA
Functions with other functions as parameters are called ,NA,NA
higher ,NA,NA
order functions.,NA,NA
 We cover higher order functions in Chapter ,NA,NA
12,NA,NA
.,"As an easy example, we take a string and use let{} to append a line break ""\n"" to it:
  
 val s = ""Hello World"" 
  
 val s2 = s.let { it + ""\n"" } 
  
 // or    s.let { string -> string + ""\n"" }",NA
 The with Function,"The with scoping function is the brother of apply{ … }. The difference is it just gets the 
 object or value to convert to a receiver as a parameter:
  
 val o = ... // some value 
  
 with(o){
  
  
  // o is now ""this""
  
  
  ...
  
 }
  
  
 The with function is frequently used to avoid repeatedly writing the object to act on, 
 as in
  
 with(object){ f1(37)
  
  
  f1(12)
  
  
  fx(""Hello"") 
  
 }
  
 instead of
  
 object.f1(37) 
  
 object.f1(12) 
  
 object.fx(""Hello"")
  
 181",NA
 The also Function,"The also scoping function is related to the apply{ … } function, but does not redefine this. 
 Instead it provides the object or value in front of also as a parameter to the lambda 
 function parameter:
  
 object.also { obj ->
  
  // 'obj' is object
  
  ...
  
 }
  
 or
  
 object.also {
  
  // 'it' is object
  
  ...
  
 }
  
 You use also{ } for cross-cutting concerns, which means you do not alter the object 
 (this is what apply{ … } is for), but perform actions that are not primarily related to the 
 current program flow. Performing caching, logging, authentication, or registering the 
 object in some registry object are suitable examples.",NA
 The run Function,"The run scoping function is similar to the apply{ … } function. However, it does not 
 return the receiver object, but instead returns the value of the last statement:
  
 val s = ""Hello"" 
  
 val x = s.run {
  
  
  // 'this' is 's'
  
  
  ...
  
  [value] 
  
 } 
  
 // x now has [value]
  
 182
  
 www.EBooksWorld.ir",NA
 Conditional Execution,"A construct that allows us to write a conditional branching as an instance function reads 
 as follows:
  
 someInstance.takeIf { [boolean_expression] }?.run {
  
  // do 
 something 
  
 }
  
 Here inside the boolean expression you can use it to refer to someInstance. The 
 takeIf() function returns the receiver (here someInstance) if the boolean expression 
 evaluates to true; otherwise it returns null. This works for any object.
  
 183",NA
CHAPTER 8,NA,NA
Exceptions: If ,NA,NA
Something Goes ,NA,NA
Wrong,"For very simple programs it is probably easy to make sure all program parts do exactly 
 what they are supposed to. For programs with a higher level of complexity, those built 
 by many developers, or those that use external programs (libraries), the situation is 
 not that clear. Problems will arise, for example, if lists or arrays get addressed out of 
 bounds, some I/O access to files or network data streams fails, or objects end up in an 
 unanticipated or corrupted state.
  
 This is what 
 exceptions
  are for. Exceptions are objects that get created or 
 thrown
  
 if something unanticipated and possibly malicious happens. Special program parts 
 can then receive such exception objects and act appropriately.",NA
 Kotlin and Exceptions,"Kotlin has a rather liberal way of treating exceptional states, but Android does not. If 
 you don’t care about exceptions in your app and any program part happens to throw an 
 exception, Android will soberly tell you the app crashed. You can prevent that by putting 
 suspicious program parts into a try-catch block:
  
 try {
  
  
  // ... statements 
  
 } catch(e:Exception) {
  
  
  // do something 
  
 }
  
 or",NA
Note,NA,NA
" As a rule of thumb, using many try-catch clauses in your code ",NA,NA
hardly increases code quality. Don’t do that. Having a few of them at ,NA,NA
"central places of your app usually is a good idea, though.","Once an exception occurs inside the try{ } block—and this includes any method 
 calls from there—the program flow immediately branches to the catch{ } block. What 
 exactly should happen there is a question that is difficult to answer, especially in an 
 Android environment. While you develop an app, writing logging entries certainly is a 
 good idea. This is not part of the Kotlin standard library, but Android provides a 
 singleton object android.util.Log you can use to write logs:
  
 import android.util.Log 
  
 ...
  
 try {
  
  
  // ... statements 
  
 } catch(e:Exception) {
  
  
  Log.e(""LOG"", ""Some exception occurred"", e) }
  
 where instead of the logging text shown here you could, of course, write some more 
 specific information.
  
 186
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" if you look at the android.util.Log class, you can see this is a Java ",NA,NA
class and function e() is a ,NA,NA
static,NA,NA
 function not requiring an instance. thus ,NA,NA
"it is not a singleton object in the strict sense, but from a Kotlin ",NA,NA
perspective you treat it as if it were a singleton object.,"While developing an app you can see the logging statements on the Logcat tab, 
 provided you are using an emulator or a connected hardware device with debugging 
 switched on. Using the e() function from the Log class provides the advantage that you 
 get a 
 stack trace
 , which means line numbers get indicated and the function calls leading 
 to the erroneous program part get listed. Figure 
 8-1
  shows an example.
  
  
 Figure 8-1. 
 Exception logging in Android Studio
  
 187
  
 www.EBooksWorld.ir",NA
 More Exception Types,"The Exception class we’ve seen so far is just one kind of exception. If we use Exception in 
 a catch statement, we formally express a very general kind of exception. Depending on 
 the circumstances, your app might coexist very well with try-catch clauses using only 
 Exception for its exception cases. There are, however, many subclasses of Exception you 
 can use as well. There is, for example, an ArrayIndexOutOfBounds exception, an 
 IllegalArgumentException, an IllegalStateException, and many more. You can even use 
 several at once by adding more catch{ } clauses:
  
 try {
  
  
  // ... statements 
  
 } catch(e:ExceptionType1) {
  
  
  // do something...
  
 } catch(e:ExceptionType2) {
  
  
  // do something...
  
 ... possibly more catch statements
  
 188
  
 www.EBooksWorld.ir",NA
 Throwing Exceptions Yourself,"To throw exceptions from your code you write
  
 throw exceptionInstance
  
 where exceptionInstance is the instance of an exception class, as for example in
  
 val exc = Exception(""The exception message"") 
 throw exc
  
 189
  
 www.EBooksWorld.ir",NA
 Exercise 1,"In the NumberGuess game app, define a new class GameException as an extension of 
 Exception. Check the numbers the user inputs and if the minimum or maximum 
 guessable numbers are exceeded, throw a GameException. Catch the new exception 
 inside the guess() function and possibly show a Toast message. Hint: Use if (num. 
 text.toString().toInt() < Constants.LOWER_BOUND) throw ... and if (num. 
 text.toString().toInt() > Constants.UPPER_BOUND) throw ... for the checks.",NA
 Exceptions in Expressions,"One interesting feature of Kotlin is that you can use try-catch blocks and throw 
  
 statements in expressions. The outcome of a try-catch block is the value of the last line 
 inside the try{ } or the catch(...){ } block, depending on whether the exception got 
 caught or not. You can use this for default values if something goes wrong, 
  
 for example. In
  
 val x = try{ arr[ind] }
  
  
  catch(e:ArrayIndexOutOfBoundsException) { -1 }
  
 190
  
 www.EBooksWorld.ir",NA
Caution,NA,NA
 Be careful not to abuse try-catch blocks for somewhat ,NA,NA
exceptional but otherwise expected program flow paths. You should ,NA,NA
really use exceptions only for unanticipated problems.,"A throw someException has a value, too. It is of type Nothing and in the Kotlin type 
 hierarchy is a subclass of everything. It is thus possible to write
  
 val v = map[someKey] ?: throw Exception(""no such key in the map"")
  
 Note that the operator ?: (sometimes called the 
 Elvis operator
 ) evaluates to the right 
 side only if the left side yields null; otherwise it takes the left side. Here this means that if 
 map[someKey] evaluates to null, equivalent to the map not having this key, the 
 exception is thrown.
  
 191
  
 www.EBooksWorld.ir",NA
CHAPTER 9,NA,NA
Data Containers,"Nature and human civilization are about collections. Families collect relatives, cities 
 collect people acting together, houses collect people and their belongings, math set 
 theory uses collections for relation formulas, galaxies collect stars, atoms collect 
 elementary particles, and so on. It is thus no surprise that computer languages, intended 
 to model real-world scenarios, must be able to model collections as well.
  
 In the real world this is not such a big topic, but computers from the very beginning 
 have drawn a sharp distinction between fixed-size collections and variable-size 
  
 collections. Fixed-size collections are easier to handle and show high performance, 
 whereas variable-size collections are slower, but show greater flexibility and according 
 to the circumstances could exhibit a lower memory footprint. Both options are needed 
 for various collection-related tasks, so a developer has to learn how to handle both 
 worlds. To make the difference clearer, fixed-size collections are called 
 arrays
 , and for 
 variable- size collections the term used is 
 collection
 .
  
 The built-in libraries of Kotlin contain several functions to mediate between arrays 
 and collections, and to make a developer’s life a little bit easier Kotlin also tries to unify 
 the handling of arrays and collections, so the switching between the two worlds is 
 easier to achieve. In the following section we first talk about arrays, as they came first 
 in computer language history, and later switch to collections.",NA
 Defining and Using Arrays,"Arrays are fixed-size containers for elements, which could be objects or primitive data 
 types. We know a lot about objects by now, but we haven’t talked much about 
 primitive data types yet. From the Kotlin point of view, it would be preferable to not 
 have this distinction at all, dealing with objects and nothing else.
  
 © Peter Späth 2019 
  
 193
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_9
  
 www.EBooksWorld.ir",NA
Note,NA,NA
"Any sits on the very top of Kotlin’s type hierarchy, and any object ",NA,NA
"implicitly and automatically inherits from it. therefore any object, no ",NA,NA
"matter how you declared it, automatically also is an instance of Any.",NA,NA
angle brackets declare a ,NA,NA
generic,NA,NA
 type. We cover generics later in the book.,"Primitive element arrays
  exist for the following element types: Boolean, Byte, Char, 
 Double, Float, Int, Long, and Short. For the corresponding array types, use any of those 
 and add Array, as in
  
 val byteArr:ByteArray = ... 
  
 var intArr:IntArray = ... 
  
 ...
  
 To access array elements, use array[index] where index ranges from 0 to the array 
 length diminished by one. The length itself is given by property size, and the last index 
 by property lastIndex. You can read array elements as in val elem1 = array[0] and 
 write array elements as in array[77] = .... If while accessing array elements you try to 
 address an element that is outside the bounds, your app will crash, so you must take 
 precautions to ensure index limits are not exceeded.",NA
 Array Instantiation,"Now that we know how to declare arrays, we need to now how to create or 
 instantiate them. This is the right side of val arr:IntArray = ... and alike.
  
 195
  
 www.EBooksWorld.ir",NA
 Exercise 1,"Define and initialize an IntArray with elements 100, 99, 98, ..., 0. Assign it to a val arr.
  
 There is a different way of initializing arrays if we have a known set of initial 
 member values. If, for example, we have five people at hand with ages 26, 56, 12, 17, and 
 26, and want to put that into an IntArray, there is no elegant way to use a constructor for 
 that aim. Of course, we could write
  
 val ages = IntArray(5) 
  
 ages[0] = 26 
  
 ages[1] = 56 
  
 ages[2] = 12 
  
 ages[3] = 17 
  
 ages[4] = 26
  
 but that looks rather lengthy. Kotlin helps us to write that in a shorter form. Inside its 
 standard library
  it contains a couple of functions to create arrays given the element 
 values. For IntArrays this function reads intArrayOf(...) and because it allows for any 
 number of arguments we can write
  
 val ages = intArrayOf(26, 56, 12, 17, 26)
  
 197
  
 www.EBooksWorld.ir",NA
 Exercise 2,"Create a BooleanArray with values true, false, true.",NA
 Array Operations,"Apart from accessing elements, arrays allow a couple of operations applied on them (E 
 is the element type):
  
 • first(): E
  
 This is the first element of the array.
  
 198
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" as of this writing, the api documentation of Kotlin can be found at ",NA,NA
https://kotlinlang.org/api/latest/jvm/stdlib/index.html,NA,NA
. if this link is out ,NA,NA
"of date, you can easily find the documentation by searching “kotlin stdlib ",NA,NA
api documentation” in your favorite search engine.,NA,NA
android studio helps a lot in finding object properties and functions. Just ,NA,NA
"enter the object’s name, a dot, and if necessary press alt+enter. android ",NA,NA
"studio then shows a list with all properties and functions, which you can ",NA,NA
scan through using the cursor up and down keys (see Figure ,NA,NA
9-2,NA,NA
). You ,NA,NA
can even go to the sources; place the cursor over a class name and then ,NA,NA
press Ctrl+B.,"Figure 9-2. 
 Automatic API documentation",NA
" Sets, Lists, and Maps","Collections get used if you need data containers for many elements and don’t know or 
  
 don’t want to specify the size. We basically have three types of collections:
  
 • 
 Sets:
  Sets are collections of unique elements. They contain any 
  
 number of elements, but duplicates are not allowed. So [1, 27, 3] is a 
  
 set, but [5, 1, 5] is not. Also, sets don’t have an order, so [1, 3, 5] is the 
  
 same set as [1, 5, 3].
  
 • 
 Lists:
  A list is an ordered collection of elements in which duplicates 
  
 are allowed. Therefore both [1, 2, 3, 1] and [1, 1, 2, 3] are lists, but they 
  
 are not the same.
  
 200",NA
 Sets,"For creating sets, you can use one of the constructors or library functions:
  
 val set1:Set<String> = HashSet() 
  
 val set2:MutableSet<String> = HashSet()
  
 val set3 = setOf(4, 7, 55) 
  
 val set4 = setOf<Long>(4, 7, 55) 
  
 val set5 = mutableSetOf(4, 7, 55)
  
 Looking at that code, we need to explain a couple of things.
  
 • Set is not a class, but an interface. For instantiation we need an 
 implementation. The HashSet you see here is a standard 
 implementation that gets used quite often for sets.
  
 201",NA
Note,NA,NA
" as of this writing, the api documentation of Kotlin can be found ",NA,NA
at ,NA,NA
https://kotlinlang.org/api/latest/jvm/stdlib/index.html,NA,NA
. If this ,NA,NA
"link is out of date, you can easily find the documentation by ",NA,NA
searching “kotlin stdlib api documentation” in your favorite search ,NA,NA
engine.,NA,NA
"as for arrays, you can let android studio show you all properties and ",NA,NA
"functions of an object. enter the object’s name, a dot, and if necessary ",NA,NA
press alt+enter (refer back to Figure ,NA,NA
9-2,NA,NA
"). to see the sources, place the ",NA,NA
cursor over a class name and then press Ctrl+B.,"The most often used properties and functions of the Set and MutableSet interfaces 
 are given here. I start with basic properties and functions.
  
 • size
  
 This indicates the size of the set.
  
 • add(element:E): Boolean
  
 (MutableSet only) Add an element. This returns true if the 
 element was really added (it didn’t exist before).
  
 • addAll(elements:Collection<E>): Boolean
  
 (MutableSet only) This adds many elements. A Collection is 
 another set or a list. It returns true if the set was modified due to 
 that operation.
  
 202",NA
 Exercise 3,"Create a mutable set val fruits with elements Apple, Banana, Grape, and Engine as 
 elements. In a separate statement, add Cherry to the set. In another statement, remove 
 Engine from the set. Create a new set val fruits5 from this set, as a result of filtering 
 elements with five characters. Note: You can get a string’s length by addressing its 
 length property.",NA
 Lists,"Lists are similar to sets, but they do not require uniqueness, so elements may appear 
 several times. In addition, lists have an order.
  
 205
  
 www.EBooksWorld.ir",NA
Note,NA,NA
"  this commonality is not just a coincidence. in fact, both Set and ",NA,NA
List are extending the Collection interface. You will see the Collection ,NA,NA
"interface used once in a while for certain tasks, but usually the ",NA,NA
"conceptional differences between Set and List are worth retaining, so ",NA,NA
set and list interfaces are being used more often.,"206
  
 www.EBooksWorld.ir",NA
 Maps,"Maps are probably the most interesting, but also the most involved part of the collection 
 framework in Kotlin. Maps get used whenever you need a mapping in the mathematical 
 sense, which means unique elements from a set A = {a0, a1, a2, ...} get mapped to 
 (possibly repeated) elements from a collection B = {b0, b1, b2, ...}. As a result, whenever 
 you have an a
 i
  you immediately can determine the (one and only) mapped b
 j
  from it. In 
 computer languages, the data you map from are usually called the 
 key
 , and the value you 
 map to has the name 
 value
 .
  
 In nature and culture, maps are everywhere: a pair of geographical coordinates on 
 earth map to an altitude, every second of January 23 maps to an air temperature in 
 New York, every Social Security number maps to a name, time maps to Earth’s position 
 in its orbit, the temperature maps to the state of aggregation (solid, liquid, gas) of 
 water, the note played by an instrument maps to a frequency, the index of an element 
 in an array maps to some value, and so on.
  
  
 Similar to sets and lists, we again have the distinction between mutable (changeable) 
 and immutable (unchangeable) maps.
  
  
 In the following code snippets we will be using the following map: SSN→name (all 
 numbers are made up):
  
 152835937 -> Albert Einstein 
  
 273495357 -> John Smith 
  
 346068589 -> John Smith 
  
 484767775 -> Barbra Streisand
  
  
 To declare maps, you use either Map or MutableMap as the type and add the key 
 and value type in angle brackets after it.
  
 val map1:Map<String,Int> = ...
  
 var map2:Map<Int,Double> = ...
  
 val map3:MutableMap<Int,String> = ...
  
 To create maps, we first have the option to use one of the constructors:
  
 val map: MutableMap<Int,String> =
  
  
  HashMap<Int,String>().apply {
  
  
  
  this[152835937] = ""Albert Einstein""
  
  
  this[273495357] = ""John Smith""
  
 212
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 the instances of to in the preceding initializers actually are ,NA,NA
"operators that create an instance of the built-in Pair class. if desired, ",NA,NA
you could use your own explicit instances of Pair as in val p1 = ,NA,NA
"Pair(152835937, ""Albert Einstein"") and then mapOf(p1, ...).","Maps are also the result of some operations on lists, sets, and arrays. With any of the 
 latter three, you can use one of these (T is the element type):
  
 • associate(transform: (T) -> Pair<K, V>): Map<K,V>
  
 This creates a map with key type K and value type V. The transform 
 function is supposed to create a Pair<K,V> given each element of 
 the original set, list, or array. Given, for example, a set of integers (T 
 = Int) such a transform function could read { i -> Pair(i, i*i) }, 
 creating a map mapping integers to their square.
  
 213
  
 www.EBooksWorld.ir",NA
 Pairs and Triples,"Two more types of data containers are pairs and triples. We’ve already seen the first 
 one, denoted by the Pair class and used for mapping purposes. The triple uses class 
 Triple and contains only three members. Of course, you can use both for whatever tasks 
 you like. The declaration and initialization are
  
 val pair = Pair<FirstType, SecondType>(
  
  
 firstVal, secondVal)
  
 214
  
 www.EBooksWorld.ir",NA
 Loops over Data Containers,"Looping over data containers means visiting each of their members to perform some 
 action on it. This is an important use case for data containers if you want to print it, 
 transform it, or aggregate over it to deduce some container characteristics. Think of 
 summing, concatenating, or averaging.
  
 In the past, computer languages provided some kind of a looping construct circling 
 around some indexing variable, and in fact this is possible with Kotlin as well. We 
 covered this old-fashioned kind of looping earlier in the book, but let me show you here 
 a more elegant and straightforward way to loop over containers in Kotlin.
  
  
 All collection type data containers like arrays, sets, and lists provide a forEach() 
 function, and you can use it concisely for looping needs. More precisely, write
  
 val container = ... // array or set or list 
 container.forEach { elem ->
  
  
  // do something with elem 
  
 }
  
 Why do we call this a function if it looks like a statement with a block? This is more 
 or less a coincidence; this sample could also be written as container.forEach({ ... 
  
 }) and the Kotlin compiler allows removal of the superfluous round brackets. In reality 
 the { ... } is not a statement block, but a function literal also called a 
 lambda function
 . The 
 elem is just an identifier; you could also use e or element or whatever you like. In any 
 case, it gets the currently visited element of the array or collection, and automatically 
 has the same type as it. For example, in
  
 215
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 in fact you could add :Int here as in forEach { elem:Int -> ... } if it ,NA,NA
helps to improve the readability of your code.,"If you need the iteration index inside the function you might be tempted to write
  
 var index = 0 
  
 container.forEach { elem ->
  
  
  // ... do s.th. with elem
  
  
  index++ // NOT ALLOWED!
  
 }
  
 to increment the index variable each iteration. This won’t work, however. It is a 
 restriction of 
 inner
  functions to not be allowed to reassign ”outside” variables. If you 
 need an index you can use a variant of forEach() that reads forEachIndexed(). This 
 time the inner function receives two arguments, the Int typed index and the element 
 variable:
  
 container.forEachIndexed { index, elem ->
  
  
 // ... do s.th. with elem 
  
 }
  
  
 The index variable gets values 0, 1, 2, ... and always has the type Int. Again, you are 
 free to change the name of the index variable to whatever you like.
  
  
 Looping through maps happens in a different manner, but it is not complicated 
 either. Maps also have a forEach() function, but with different parameter types.
  
 • If using a single parameter as in map.forEach { me -> ...} this parameter 
 will be of type Map.Entry<K,V> where K is the key type and V is the value 
 type. From me you then get the key via me.key and the value via me.value. 
 You can also write me.toPair() to build a Pair from that.
  
 216
  
 www.EBooksWorld.ir",NA
 Sorting Arrays and Collections,"Sorting arrays and collections like lists and sets is a task you frequently need to 
  
 accomplish before you present data to your app users. Also, sorting must happen before 
 you can start the binary search algorithm we discuss in the section ”Searching in Arrays 
 and Collections” later in this chapter.
  
 Sorting can happen in place, which means the array or collection you want to have 
 sorted gets altered, or in a functional style, which means the result of the operation is the 
 sorted array or collection and the original data container stays untouched. Sorting in 
 place will be the faster choice, but bears the risk that other program parts get corrupted 
 if they hold a reference to the original array or collection. Functional sorting can 
 improve program stability, but you can expect some performance penalty, so choose 
 wisely.
  
  
 For functional style sorting with the original array or collection untouched, you have 
 a couple of options (T is the element type).
  
 • Array.sorted() : List<T>
  
 This returns a List with the elements from the array sorted 
 according to their 
 natural
  sort order. The type T must be a 
 subinterface of Comparable, which is the case for all built-in 
 numeric types and strings. As the array, you can use an object 
 array or any of the primitive element type arrays (IntArray, 
 DoubleArray, etc.).
  
 • Array.sortedArray() : Array<T>
  
 This is the same as Array.sorted(), but returns an array 
  
 instead. Kotlin always returns an object array, never a 
 primitive typed array. Therefore, arrayOf(1,2,3).sorted() 
 returns an Array<Int>, not an IntArray. You can, however, add 
 method toIntArray() to convert the Int object array to an 
 IntArray. 
  
 The same holds for the other primitive element type objects.
  
 217",NA
 Exercise 4,"Using sortWith(), do a sorting of a list val gul = listOf(...) of GameUser instances from 
 the NumberGuess game app, first by the last name, and then by the first name. Assign 
 the result to val sorted.
  
 In-place sorting differs from the sorting functions handled so far in the original 
 array or collection (list or set) being altered to contain the sorted data afterward. For 
 lists and sets, this obviously makes sense only for the mutable variants. The functions 
 for in-place sorting are given here.
  
 220
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 You should prefer functional style sorting over in-place ,NA,NA
"sorting, unless performance or resources housekeeping is an ",NA,NA
important issue.,NA,NA
 Exercise 5,"Do the same as for Exercise 4, but perform in-place sorting.",NA
" Grouping, Folding, Reducing, and Zipping","Grouping, folding, reducing, and zipping are advanced operations on arrays and 
 collections like lists and sets. We discuss each of these in turn.
  
 221
  
 www.EBooksWorld.ir",NA
 Grouping,"Grouping is about reorganizing your data in such a way that groups of the data are 
 gathered according to some key deduced from the data or imposed on the data. Look at, 
 for example, a set of cars:
  
 data class Car(id:Int,make:Int,name:String,vin:String) val cars = 
 listOf(
  
  
  Car(1, 1994, ""Sirus"",       ""WXX 130 007-1J-582943""),
  
  
 Car(2, 1997, ""Sirus"",       ""WXX 130 008-1J-582957""),
  
  Car(3, 2010, 
 ""Casto 4.0"",   ""WXQ 456 088-4K-005614""),
  
  Car(4, 2010, ""Babo 
 MX"",     ""WYY 518 004-55-171598""),
  
  Car(5, 1994, ""Casto 4.0"",   
 ""WXQ 456 005-4K-005658""),
  
  Car(6, 2011, ""Quasto"",      ""WA0 100 
 036-00-012378"") )
  
 What if we want to find out which cars belong to a certain make year? We can 
 see that we have two cars belonging to 1994, one to 1997, two to 2010, and one to 
 2011 if looking at the IDs.:
  
 1994 -> [ 1, 5 ] 
  
 1997 -> [ 2 ] 
  
 2010 -> [ 3, 4 ] 
  
 2011 -> [ 6 ]
  
  
 This operation is called 
 grouping
 , and in this particular case we group based on the 
 make.
  
 In Kotlin we have a grouping function that helps us to achieve our aim: groupBy( 
 keysSelector: (T) -> K ): Map<K, List<T>> where the keySelector is supposed to 
 deduce the grouping key. The type parameter T is the class of the original elements or 
 a superclass of that. Type K is any type you need for the grouping key. The grouping 
 function for the cars example reads:
  
 data class Car(id:Int,make:Int,name:String,vin:String) val cars = 
 listOf( ... ) 
  
 val groupedByMake = cars.groupBy(Car::make) 
  
 ...
  
 val group1997:List<Car> = groupedByMake[1997]
  
 222
  
 www.EBooksWorld.ir",NA
 Exercise 6,"With substring(0,3) extracting the first three chapters from a string, perform a grouping 
 for the cars list with the first three characters of the vin as a key. Call it val 
 groupedByManufacturer. Extract the WXX manufacturer from the grouping result.
  
 There are three more grouping functions. The first is groupBy() with one more 
 parameter. This one performs a transformation on the values before adding them to the 
 grouping result. Two more functions, groupByTo()
 ,
  save the grouping result into a map 
 provided as a parameter. They are more or less convenience functions. For details, refer 
 to the official Kotlin API documentation.",NA
 Folding,"Folding is about letting an object scan through all elements of an array or collection 
 (set or list) and update itself each iteration. Think, for example, of a list of invoices and 
 summing up all money amounts. This is nothing spectacular; one could write
  
 val someObject = ...
  
 list.forEach { elem ->
  
  // update someObj using elem
  
  ...
  
 }
  
 However, there is an intrinsic danger that code could initialize the object before 
 the loop starts doing lots of weird things, so there is a function that performs the task 
 using one statement. Actually, it is a set of functions.
  
 • fold(initial: R, operation: (acc: R, T) -> R)): R
  
 The function takes as parameters the object that is going to be 
 updated each loop iteration and a function that performs the 
 updating. This updater takes as parameters the actual version of 
  
 223
  
 www.EBooksWorld.ir",NA
 Reducing,"Reducing is the little brother of folding. The gatherer is not specified explicitly and 
 instead the first element of the array or collection (a set or a list) is used. The folding 
 operation or more precisely 
 reduction
  operation then understandably starts with the 
 second element of the data. Reduction functions are listed here.
  
 224
  
 www.EBooksWorld.ir",NA
 Exercise 7,"Create a list [1, 2, 3, 4, ..., 100]. Then, using reduce, calculate the number 
 1∗2∗3∗...∗100 from it. Hint: You can convert a range (
 f rom..to
 ) to a list via function 
 toList().",NA
 Zipping,"Looping, sorting, folding, and reducing already provide a quite versatile tool set for 
 handling arrays and collections (sets and lists). We don’t have a tool yet, though, to 
 combine two arrays or collections element-wise. In Kotlin there is a set of functions 
 dealing with exactly this kind of task.
  
 The main functions that help us here are called zip() and unzip(). The first of them, 
 zip(), has the following signature: zip(other: Array<out R>): List<Pair<T, R>>) or 
 zip(other: Iterable<R>): List<Pair<T, R>>). Both of them are defined as infix functions, 
 so you can write
  
 225
  
 www.EBooksWorld.ir",NA
 Exercise 8,"With two lists val fruits = listOf(""Bananas"", ""Apples"", ""Oranges"") and val prices = 
 listOf(1.69, 2.19, 2.79), and a data class Fruit(val name:String, val price:Double), perform 
 a zipping with the resulting list containing Fruit elements.",NA
 Searching in Arrays and Collections,"We’ve already seen that by using indexOf() we can find the index of a particular element 
 in an array or a list. For very large arrays or collections (e.g., 1 million entries), that 
 might not be the fastest way to find an element. Internally indexOf() must iterate 
 through the whole array or list and must check for the equality of each data value until a 
 hit occurs.
  
 For sorted arrays or lists there is a better choice: a binary search. In such a binary 
 search, the 
 N
  elements of an array or list get split into two equal parts of approximate 
 size 
 N
  /2. Then the part that contains the search element is chosen. With the smaller 
 range, we again perform a split in the middle, do another check, and so on. Using this 
 algorithm to search for an element in an array or list of 1 million entries, we don’t need 
 more than about 20 checks to find it.
  
 227",NA
 The Spread Operator,"For any function with a vararg parameter, you can use an array to pass values to the 
 function:
  
 function xyz(a:Int, vararg x:String) {
  
  ...
  
 }
  
 val arr = arrayOf(""1"", ""2"", ""3"", ""4"", ""5"") xyz(42, 
 *arr)
  
 228
  
 www.EBooksWorld.ir",NA
 Queues and Stacks: Deques,"Sets and lists are not the only collection types you can use. Kotlin does not explicitly 
 handle collection types other than sets and lists, but it sits on top of the 
 Java virtual 
 machine (JVM)
  and includes a significant subset of the Java standard libraries, including 
 all Java collection types. We do not cover all of them, because some are rather specialized 
 and show features you don’t normally need. One interesting type is worth a more 
 thorough investigation, though: 
 deques
 .
  
 Deques are collections that are very similar to lists, but in addition they allow adding 
 elements at the head, and furthermore provide functions for removing elements from 
 both sides of the collection. Before we discuss the functions deques provide, we first 
 clarify a couple of terms:
  
 • 
 Head:
  The head of a list is the element first added to a list. It is thus 
 the element with index 0. For deques you explicitly state that you 
 want to do something with the head by using one of the functions 
 containing First in its name.
  
 • 
 Tail:
  The tail of a list is where elements get added via the add() function. 
 For deques you explicitly state that you want to do 
  
 something with the tail by using one of the functions containing Last in 
 its name.
  
 Because Deque is an interface, we need an implementation. There are several, 
 with java.util.ArrayDeque probably the one used most often. Class ArrayDeque has 
 three constructors (E is the element type).
  
 • ArrayDeque<E>()
  
 This constructs a deque with an initial capacity of 16 elements of 
 type E. From a client-side perspective, you don’t have to think 
 about capacities unless performance or resources housekeeping 
 is a problem. If you expect many elements, you could specify a 
 higher initial capacity size using the constructor shown later.
  
 229
  
 www.EBooksWorld.ir",NA
 A Statistics Class for the NumberGuess App,"Our NumberGuess game app to this point doesn’t contain any list-like structures, which 
 is why we didn’t mention it for a while. This can be changed readily and the extension 
 we add for that aim is a dedicated statistics activity that counts attempts and hits for us.",NA
 Adding an Action Bar to The App,"The first thing we do is add an action bar to the NumberGuess app:
  
  1. Update the AndroidManifest.xml file. Add as an XML attribute inside 
 the <activity> tag: android:theme = ""@style/AppTheme. 
 NoActionBar"" (right after the android:name= ... entry in a new 
 line)
  
 231",NA
 The Statistics Activity,"We now create a new activity for the statistics.
  
  1. Right-click app, then select New 
 ➤
  Activity 
 ➤
  Empty Activity. 
  
 As the activity’s name, enter StatisticsActivity. Make sure 
 Generate Layout file is selected, and use kotlinforandroid. 
 book.numberguess as a package name. As source language select 
 Kotlin and set main as the target source. Click Finish.
  
  2. Open the file res/layout/activity_statistics.xml, switch to the Text 
 view type, and replace its contents with this:
  
 <?xml version=""1.0"" encoding=""utf-8""?> 
  
 <LinearLayout
  
  
  xmlns:android=
  
   
  ""http://schemas.android.com/apk/res/android""
  
  
 xmlns:tools=
  
   
  ""http://schemas.android.com/tools""
  
  
  xmlns:app=
  
   
  ""http://schemas.android.com/apk/res-auto""
  
  
 android:id=""@+id/statisticsContainer""
  
  
  android:layout_width=""match_parent""
  
  
  android:orientation=""vertical""
  
  
  android:layout_height=""match_parent""
  
  
  tools:context="".StatisticsActivity""> 
  
 </LinearLayout>
  
 237
  
 www.EBooksWorld.ir",NA
 State Housekeeping for the Statistics,"In the Statistics singleton object we gather the outcome from all game sessions in a list. 
 Because in a session we get two figures—the number to guess and the number of tries 
 needed to guess the number—we define an inner class GameSessionRecord holding one 
 result pair. We therefore update the Statistics object accordingly:
  
 package kotlinforandroid.book.numberguess.statistics
  
 239
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 Unfortunately we cannot write val data = mutableListOf() ,NA,NA
because this is not marked serializable. We need a language-,NA,NA
"agnostic representation for the complete list as well, so we have ",NA,NA
to fall back to the concrete implementation.,"This data list represents the complete state of the Statistics object. We learned from 
 the MainActivity that we must find a way to save and restore the state, because Android 
 unexpectedly might put any activity into a suspended state, causing it to lose its 
 properties. We therefore add two functions, save() and restore(). As parameters they 
 have the Bundle instances needed for state saving and restoring as controlled by the 
 activity. We add a function call to onCreate():
  
 override 
  
 fun onCreate(savedInstanceState: Bundle?) {
  
  
  super.onCreate(savedInstanceState)
  
  
  setContentView(R.layout.activity_statistics)
  
  
  restoreData(savedInstanceState) // new!
  
  
 showData(Statistics.getStatistics()) }
  
 240
  
 www.EBooksWorld.ir",NA
 Communicating Between the Activities,"The game itself gets handled by the MainActivity class and the statistics by 
  
 StatisticsActivity. For those running the same process, we choose the simplest way of 
 communication: using a singleton object for sharing data. We have not yet covered 
 processes; in most cases it is enough to know that a process is a technical bracket 
 around app components, and that singleton objects reside within a process’s 
 boundaries.",NA
Note,NA,NA
 For more complicated data structures to share between app ,NA,NA
"components, consider using the built-in android database.","241
  
 www.EBooksWorld.ir",NA
 Implementing Statistical Calculations,"With the statistics activity all set up and the data from the game activity communicated, 
 we are now ready for some calculations on the data inside the Statistics class. We start 
 with a simple one, the number of game sessions.
  
 private fun numberOfSessions() : Int =
  
  data.size
  
 242
  
 www.EBooksWorld.ir",NA
(,NA,NA
),=,NA
å,N,NA
(,"tries 
 i
  - 
 trie
 s",NA
),"2
  
 i
  
 N
  - 1 
 where 
 tries
   designates the average. The corresponding Kotlin function reads:
  
 private fun triesNeededStdDev() : Double { 
 if(data.size < 2) return 0.0
  
  val avg = averageTriesNeeded()
  
  return Math.sqrt(
  
 243
  
 www.EBooksWorld.ir",NA
(,"• 
  
 -
 tries",NA
),"where 
 tries
   designates the average.
  
 • We again take the sum from the result list by applying sum().
  
 • The division by 
 size −
  1 is part of the formula.
  
 The next function we write calculates a histogram of the tries. For each possible 
 k 
 tries needed we figure out how often 
 k
  shows up in the statistics data. This is a typical 
 case for a map Int→Int mapping the 
 k
 s to their frequencies. The Kotlin function that 
 does this for our Statistics class reads:
  
 private fun neededTriesDistrib() : Map<Int, Int> = 
 data.groupBy({rec -> rec.tries}).
  
  mapValues { me -> me.value.size }
  
 It performs in this manner:
  
 • We see a practical implementation of groupBy(). You will see 
  
 groupBy() often when it comes to counting things based on some 
 criterion. Here we count record objects based on the number of tries. This 
 is exactly what the function parameter of groupBy() here does.
  
 244
  
 www.EBooksWorld.ir",NA
CHAPTER 10,NA,NA
"True, False, and ",NA,NA
Undecided: ,NA,NA
Nullability,"At school you learned about the dichotomy of true versus false, and you probably heard 
 that there is nothing else. Reading this book, thus far, you have learned that in Kotlin 
 there exists a boolean type Boolean with exactly those possible values: true and false. 
 Period. Really?
  
 If you think about real life, experience suggests something else. Ask someone: Is it 
 going to rain tomorrow? Maybe the answer is yes, and maybe it is no. Honestly, though, 
 no one knows with 100 percent certainty. We therefore have 
 true
 , 
 false,
  and 
 undecided 
 (or 
 unknown
 ). This trichotomy gets called 
 three-valued logic
  (also 
 trinary
 , 
 trivalent,
  or 
 ternary
  logic). Why are we talking about this here? This is not a philosophy book, is it? 
 For classes and objects, we already pointed out that computer programs need to model 
 real-world scenarios; therefore we need to have something that is neither true nor false 
 in a computer language.",NA
 What NULL Is,"Even with computer language developers not really being sound philosophers or 
 perhaps just being unaware of this trichotomy, 
 undecided
  has been around from the very 
 beginning of computer language history. It just didn’t get called that. Say, for example, 
 you need a variable that represents the size of some list. Depending on circumstances, a 
 list of size zero might make sense, and for coding reasons we might need to express that 
 a list is not yet defined. What can we do? Well, sizes are from the range 0, 1, 2, 3, ..., so we 
 just take a number that usually makes no sense and 
 define
  this to represent a 
 not yet 
 defined
 . Can you guess what number this could be? A possible answer is −1.",NA
 How Nullability Gets Handled Inside Kotlin,"Kotlin introduces a couple of new ideas about nullability, allowing its use but avoiding 
 most of the associated pitfalls. First, we notice that by default Kotlin does not allow null 
 values to sneak around in your app. Something like this
  
 var p:SomeType = ... 
  
 ...
  
 p = null
  
 just is not allowed for any type of property. The same holds for constructors and 
 function invocation:
  
 class A(var p:SomeType) ... 
  
 A(null) // does not compile
  
 249
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" because you have to add something to allow for nullability, Kotlin ",NA,NA
"slightly favors non-nullability. in fact, in many cases you can avoid null ",NA,NA
"values, and if this is the case, chances are good you have a good app ",NA,NA
design.,"For such nullable types Kotlin knows that a dereferencing via .property or 
 .function() might fail and prohibits using them:
  
 var p:SomeType? = ...
  
 ...
  
 p.property    // does not compile 
  
 p.function()  // does not compile
  
 This is even then prohibited if the value happens to be not null.
  
 How can we use such nullable properties then? The answer is that we have to use 
 one of the null-safe operators Kotlin provides. So for the dereferencing . there is a null- 
 safe variant ?. that you can use for nullable properties:
  
 var p:SomeType? = ... 
  
 ...
  
 p?.property     // OK 
  
 p?.function()   // OK
  
 250",NA
Caution,NA,NA
 using !! you essentially bypass Kotlin’s null-checking ,NA,NA
"mechanism, so try to avoid it.","var p:String? = ...
  
 // for whatever reason we know that p cannot be null
  
 val len = p!!.length 
  
 // valid, because the !! indicates it cannot be null // If it 
 accidentally _is_ null, we'll crash here.
  
 251
  
 www.EBooksWorld.ir",NA
CHAPTER 11,NA,NA
Handling Equality,"There is a strong distinction between 
 identity
  and 
 equality
 . Two things are identical if 
 they actually are the same. If you bought a white candle this morning, let’s call it A, the 
 white candle in your shopping bag and the white candle that this afternoon is placed in 
 your candleholder are the same and thus identical (presume this is the only candle you 
 own). Now assume you bought a second candle, B, of the same type from the same 
 manufacturer. 
  
 Apart from some linguistic mistakes you sometimes hear, those two candles are 
 not
  the 
 same. Candles A and B are not the same, but they are 
 equal
 . This is because they have the 
 same characteristics: the same color, the same weight, the same diameter, and the same 
 length. Hold on, though: This is not necessarily true. The manufacturer says such a 
 candle weights 300 g, but a high-precision balance tells us candle A weighs 300.00245 g, 
 and candle B weighs 299.99734 g. If you take a kitchen scale, though, the weights of 
 candles A and B are the same. Therefore you can see that equality depends on strictness 
 and it is 
 relative
 .
  
 This comparison between identity and equality teaches us an important lesson: 
 Identity is the case for things that are the same, whereas equality is relative and depends 
 on some definition.",NA
 Identity in Kotlin,"In Kotlin there is an identity operator === and its opposite !==. In Kotlin, identity 
 stands for 
 referential identity,
  which means if two variables point to the same object, or 
 refer
  to the same object, they are considered identical:
  
 data class A(val x:Double) 
  
 val a = A(7.0) 
  
 val b = A(7.0) 
  
 val c = a 
  
 val aIdenticalToC = a === c // -> true val 
 aIdenticalToB = a === b // -> false
  
 © Peter Späth 2019 
  
 253",NA
Note,NA,NA
 There is another ,NA,NA
identity,NA,NA
 notion that is revealed in a database ,NA,NA
environment. There you often have a numerical ID field for data records. ,NA,NA
This field gets used as a surrogate for the corresponding object’s ,NA,NA
"identity, instead of the language’s referential === identity. In this ",NA,NA
chapter we are not talking about this database kind of identity.,NA,NA
 Equality in Kotlin,"For equality Kotlin provides the comparison operator ==, and its opposite !=. Other than 
 identity, an object must tell whether it is equal to some other object. If you don’t do this 
 explicitly, the base implementation of an equality check is used, which falls back to the 
 identity check.
  
 Equality checks on numbers, booleans, chars, and strings do the obvious thing: 
 Strings are equal if they contain exactly the same characters, characters are equal if 
 they contain the same letter, and numbers and booleans are equal if they have the 
 same value.",NA
 Equals and Hash Code,"The way a class handles equality checks is governed by two functions: fun 
  
 equals(otherObject:Any?): Boolean and fun hashCode(): Int. If your classes need 
 equality checks, you must implement both. It might seem strange that we need two 
 functions for equality checks. Why does it not suffice to have just equals() for equality 
 checks? The reason lies in performance, and the precise idea is described later.
  
 254
  
 www.EBooksWorld.ir",NA
 Exercise 1 ,"If two variables a and b are identical, which of the following are 
 true?
  
  1. a and b refer to the same object.
  
  2. a == b necessarily yields true.
  
  3. a !== b necessarily yields false.",NA
 Exercise 2 ,"If two variables a and b are equal, a == b, which of the following are true?
  
  1. a.equals(b) must be true.
  
  2. a != b necessarily yields false.
  
  3. a.hashCode() == b.hashCode() must be true.
  
 258
  
 www.EBooksWorld.ir",NA
CHAPTER 12,NA,NA
Back to Math: ,NA,NA
Functional ,NA,NA
Programming,"If you look at the examples and exercises presented so far in this book you can see that 
 we fluctuate between two styles of programming:
  
 [statement1] // do something 
  
 [statement2] // do something 
  
 [statement3] // do something 
  
 ...
  
 and
  
 object.
  
  doSomething1().
  
  doSomething2().
  
  doSomething3().
  
  ...
  
 The first style is about a sequence of imperatively telling what a program has to do, 
 whereas the second is about sequentially applying functions on objects in a function 
 invocation chain. Because of this, the first style also gets called 
 imperative programming
 , 
 and the second is known as 
 functional programming
 . Functional programming 
  
 frequently also implies using functions as arguments to other functions, which then get 
 called 
 higher order functions
 . In addition, functional programming favors handling 
 immutable objects.",NA
 Kotlin and Functional Programming,"Kotlin, although a full-fledged imperative language, also allows for a functional 
 programming style by virtue of these features:
  
 • Kotlin has a function type declaration:
  
 ([parameters]) -> [result-type]
  
 where [parameters] is a comma-separated list of function 
 parameter types. For example,
  
 val f : (Int,String) -> String = ...
  
 The -> [result-type] cannot be omitted, so if a function doesn’t 
 return anything you write -> Unit.
  
 • Functions are first-class citizens: Any variable can have a built-in type, 
 can be an instance of any class, or can be a function. Functions can be 
 higher order functions by allowing functions as parameters.
  
 val f1 = { -> Log.d(""LOG"", ""Hello Kotlin"") } val f2 = { 
 i:Int, s:String -> ""${i}: ${s}"" } ...
  
 fun ff(fun1: (Int,String) -> String):String {
  
  return 
 fun1(7, ""Hello"") 
  
 } 
  
 ff(f2) 
  
 ff( { i:Int,s:String -> ""${i}- ${s}"" } )
  
 • Kotlin has anonymous lambda functions; these are function literals 
 that can be used as function invocation parameters. For example:
  
 val f = { i:Int, s:String ->
  
  
  
  i.toString() + "": "" + s } 
  
 fun fun1(p: (Int,String) -> String) {
  
  
  p(42, ""Hello"") 
  
 } 
  
 fun1 { i:Int, s:String -> i.toString() + "": "" + s }
  
 262
  
 www.EBooksWorld.ir",NA
 Functions Without Names: Lambda ,NA,NA
Functions,"We know that normal functions look like
  
 fun functionName([parameters]): ReturnType {
  
  ...
  
 }
  
 or
  
 fun functionName([parameters]): ReturnType = ...
  
 if the function can be reduced to an expression. Functions declared that way get 
 identified by functionName. The question is this: How can it be possible to have 
 functions without identifying the function name? For the answer, we look at 
 variables containing data; here we write
  
 val varName = 37
  
 264",NA
Note,NA,NA
 expressions with such anonymous functions also sometimes ,NA,NA
are called ,NA,NA
lambda calculus,NA,NA
.,"The same holds for functions that have been passed to other functions as 
 parameters:
  
 ff( { i:Int,s:String -> ""${i}- ${s}"" } )
  
 Here again we have a function without a name or a lambda function. 
 To invoke a lambda function, you write one of these:
  
 [lambda_function].invoke([parameters]) 
 [lambda_function]([parameters])
  
 Lambda functions can have a result. Contrary to a normal function, where you return 
 values via some return statement, the result of a lambda function is whatever the last 
 line evaluated to. The preceding example
  
 val f = { i:Int, s:String -> i.toString() + "": "" + s }
  
 thus returns the string representation of the Int parameter, plus a :, plus the String 
 parameter, all by virtue of the last line of the lambda function.
  
  
 In a lambda function with a single parameter, for brevity the parameter declaration 
 can be omitted and the special identifier it can be used instead to refer to the parameter. 
  
 The following two statements are therefore equivalent:
  
 { par ->
  
  
  ... // do something with 'par' } 
  
 {
  
  
  ... // do something with 'it' }
  
 265
  
 www.EBooksWorld.ir",NA
 Exercise 1,"Write as a lambda function: a function that takes an s:String and a num:Int and outputs a 
 string with num copies of s concatenated.",NA
 Exercise 2,"Rewrite
  
 val f : (String) -> String = { s:String -> s + ""!"" }
  
 to use it instead.
  
  
 If a lambda function has one or more parameters you don’t need in a definition, you 
 can use an underscore wildcard (_) as a parameter name:
  
 val f : (String, Int) -> String = { s:String, _ ->
  
  // the Int 
 parameter is not used
  
  
  s + ""!"" 
  
 }",NA
 Loops Once Again,"In Chapter 
 9
  we learned that we can iterate over the elements of an array or 
 collection (set, list) by writing data.forEach(...) or data.forEachIndexed(...):
  
 val arr = arrayOf(""Joe"", ""Isabel"", ""John"" } 
 arr.forEach { name ->
  
  
  Log.d(""A name: ${name}"") 
  
 } 
  
 arr.forEachIndexed { i,s ->
  
  
  Log.d(""Name #${i}: ${name}"") 
  
 }
  
 Here the Log comes from package android.util, so you have to import it:
  
 import android.util.Log
  
 266
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 pressing Ctrl+B is a good way to learn what is going on behind the ,NA,NA
scenes in kotlin. use it extensively to understand kotlin constructs and ,NA,NA
functions.,"Because forEach and forEachIndexed are functions and not language constructs, 
 they can be intuitively applied to any objects that look like they contain something that 
 can be iterated over. This includes arrays and collections that are the result of applying 
 other functions over arrays and collections. We could therefore include filters and 
 mappings in the function chain that ends up in a loop, as in
  
 originalCollection.
  
  filter([filter_function]).
  
  map([mapping_function]).
  
  take(37).
  
  forEach { elem ->
  
  
  ...
  
  }
  
 where we first apply a filter, then a mapping, then a reduction to the first 37 elements 
 before we start the loop. We can see that by virtue of functions being allowed as function 
 parameters, we can achieve a function chain and avoid intermediate variables as data 
 holders.
  
 267",NA
 Functions with Receivers,"Functions that are considered function objects and are embedded in a context, as, for 
 example, functions inside a class, are called 
 functions with receiver types
 . You declare 
 them as follows:
  
 val f : ReceiverType.([parameters]) = ...
  
 Such a function then acts as if it was a member function of class ReceiverType, and 
 inside the function implementation you can use this, which points to the instance. For 
 example, in
  
 class A {
  
  
  var d:Double = 0.0
  
  
  fun plus(x:Double) = d + x 
  
 } 
  
 val f : A.(Double) -> Double =
  
  
  
  { x:Double -> this.d - x } 
  
 fun A.minus(x:Double) = f
  
 function f is such a function with receiver type. We use it to extend class A with a 
 minus() function, and the this.d inside the implementation of f points to property d 
 inside the receiver type, A in this case.
  
 In the previous section we already noticed that a direct reference to a function 
 inside a class automatically is such a function with receiver type, because it only works 
 inside the environment of its class:
  
 class X {
  
  
  fun add(a:Int, b:Int): Int = a + b 
  
 } 
  
 ...
  
 val f : X.(Int,Int) -> Int = X::add
  
 268
  
 www.EBooksWorld.ir",NA
 Inline Functions,"Look at this code snippet:
  
 class A {
  
  
  fun function1(i:Int, f:(Int) -> String): String {
   
  return 
 f(i)
  
  
  }
  
  
  fun function2() {
  
   
  val a = 7
  
   
  val s = function1(8) {
  
   
  
  i -> ""8 + a = "" + (i+a) }
  
  
  } 
  
 }
  
 Inside the invocation of function1() we pass a function object in the form of a 
 lambda function i -> .... This function object must be created during runtime, and in 
 addition the compiler must allow for the local property a to be passed into that object. 
 This introduces a significant performance penalty. More precisely, the Kotlin compiler 
 produces something like this:
  
 public class A {
  
  
  public String function1(int i,
  
  
  
  
  Function1<? super Integer, String> f) {
  
  
  return f.invoke(i);
  
  
  }
  
  public void function2() {
  
  
  int a = 7;
  
  
  String s2 = this.function1(8,
  
  
  
  
  new Function1<Integer, String>(a){
  
  
  final int $a;
  
  
  
  public String invoke(int i) {
  
  
  
   
  return ""8 + a = "" + (i + this.$a);
  
  
  }
  
 269
  
 www.EBooksWorld.ir",NA
 Filters,"If you have a list of some objects, such as instances of a data class Employee(val 
 firstName:String, val lastName:String, val ssn:String, val yearHired:Int), in algorithms 
 you frequently need to extract list members based on some criterion. 
  
 Using an imperative programming style this often leads to code snippets like this:
  
 data class Employee(val firstName:String, val 
 lastName:String,
  
  val ssn:String,
  
  val yearHired:Int)
  
 271
  
 www.EBooksWorld.ir",NA
 Exercise 3,"Create another list startsWithL by applying a filter that only lets employees pass whose 
 first name starts with L. Note: String has a startsWith() function we can use for that 
 purpose.
  
 273
  
 www.EBooksWorld.ir",NA
CHAPTER 13,NA,NA
About Type ,NA,NA
Safety: Generics,"Generics
  is a term used for denoting a set of language features that allow us to add type 
 parameters to types. Consider, for example, a simple class with a function for adding 
 elements in the form of Int objects:
  
 class AdderInt {
  
  
  fun add(i:Int) {
  
  
  
  ...
  
  
  } 
  
 }
  
 and another one for String objects:
  
 class AdderString {
  
  
  fun add(s:String) {
  
  
  
  ...
  
  
  } 
  
 }
  
 Apart from what happens inside the add() function, these classes look suspiciously 
 similar, so we could think of a language feature that abstracts the type for the element to 
 add. Such a language feature exists in Kotlin, and it is called 
 generics
 . A corresponding 
 construct reads as follows:
  
 class Adder<T> {
  
  
  fun add(toAdd:T) {
  
  
  
  ...
  
  
  } 
  
 }
  
 © Peter Späth 2019 
  
 275
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_13
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 Generics are compile-time constructs. In the code the compiler ,NA,NA
"generates, no generics information appears. This effect is commonly ",NA,NA
referred to as ,NA,NA
type erasure.,"We’ve already used such a generic type a couple of times in the book. You might 
 remember as a holder for two data elements we talked about the Pair type, which is 
 parameterized:
  
 val p1 = Pair<String, String>(""A"", ""B"") val p2 = 
 Pair<Int,String>(1, ""A"")
  
 276
  
 www.EBooksWorld.ir",NA
 Simple Generics,"First, let’s address the basics. To type-parameterize a class or an interface, you add 
 a comma-separated list of formal type parameters inside angle brackets after the 
 type name:
  
 class TheClass<[type-list]> {
  
  
  [class-body] 
  
 } 
  
 interface TheInterface<[type-list]> {
  
  
  [interface-body] 
  
 }
  
  
 Inside the class or interface, including any constructor and init{} block, you can 
 then use the type parameters like any other type. For example:
  
 class TheClass<A, B>(val p1: A, val p2: B?) {
  
  
 constructor(p1:A) : this(p1, null)
  
  
  init {
  
  
  
  var x:A = p1
  
  
  
  ...
  
  
  }
  
  
  fun function(p: A) : B? = p2 
  
 }
  
 277",NA
 Exercise 1,"Similar to the Pair class, create a class Quadruple that can hold four data elements. 
 Create an instance with sample Int, Int, Double, and String type elements.",NA
 Declaration-Side Variance,"If we talk about generics, the term 
 variance
  denotes the ability to use more specific or 
 less specific types in assignments. Knowing that Any is less specific compared to String, 
 variance shows up in the question of whether one of the following is possible:
  
 class A<T> { ... } 
  
 var a = A<String>() 
  
 var b = A<Any>()
  
 a = b // variance? 
  
 ... or ...
  
 b = a // variance?
  
  
 Why is that important for us? The answer to that question becomes clear if we look 
 at type safety. Consider the following code snippet:
  
 class A<T> {
  
  
  fun add(p:T) { ... } 
  
 } 
  
 var a = A<String>() 
  
 var b = A<Any>()
  
 b = a // variance? 
  
 b.add(37)
  
 Adding 37 to a A<Any> does not pose a problem, because any type is a subclass of 
 Any. However, because b by virtue of b = a now points to an instance of A<String>, 
 we’ll get a runtime error, because 37 is not a string. The Kotlin compiler recognizes 
 this problem and doesn’t allow the b = a assignment.
  
 278
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 The out variance for classes also gets called ,NA,NA
covariance,NA,NA
", and ",NA,NA
the in variance is called ,NA,NA
contravariance.,NA,NA
The name declaration-side variance stems from declaring the in or out ,NA,NA
variance in the ,NA,NA
declaration,NA,NA
" of the class. other languages, such as Java, use ",NA,NA
a different type of variance that takes effect while ,NA,NA
using,NA,NA
 the class and ,NA,NA
hence gets called use-side variance.,NA,NA
 Variance for Immutable Collections,"Because immutable collections cannot be written to, Kotlin automatically makes them 
 covariant. If you prefer, you can think of Kotlin implicitly adding the out variance 
 annotation to immutable collections.
  
  
 Due to this fact, a List<SomeClass> can be assigned to a List<SomeClassSuper> 
 where SomeClassSuper is a superclass of SomeClass. For example:
  
 val coll1 = listOf(""A"", ""B"") // immutable val 
 coll2:List<Any> = coll1  // allowed!",NA
 Type Projections,"In the previous section we saw that for the out style variance the corresponding class is 
 not allowed to have functions with the generic type as a function parameter, and that for 
 the in style variance we accordingly cannot have a function returning the generic type. 
 This is, of course, unsatisfactory if we need both kinds of functions in a class. Kotlin also 
 has an answer for this type of requirement. It is called 
 type projection
  and because it 
 aims at variance while using different functions of a class, it is the Kotlin equivalent of 
 use-side variance.
  
  
 The idea goes as follows: We still use the in and out variance annotations, but 
 instead of declaring them for the whole class we add them to function parameters. 
  
 We slightly rewrite the example from the previous section and add in and out variance 
 annotations:
  
 class Producer<T> {
  
  
  fun getData(): Iterable<T>? = null }
  
 281
  
 www.EBooksWorld.ir",NA
 Star Projections,"If you have a class or an interface with in or out variance annotations, you can use the 
 special wildcard *, which means the following:
  
 • For the out variance annotation, * means out Any?.
  
 • For the in variance annotation, * means in Nothing.
  
  
 Remember that Any is the superclass of any class, and Nothing is the subclass of 
 any class.
  
 For example:
  
 interface Interf<in A, out B> {
  
  
  ...
  
 }
  
 val x:Interf<*, Int> = ...
  
  // ... same as Interf<in Nothing, Int>
  
 val y:Interf<Int, *> = ...
  
  // ... same as Interf<Int, out Any?>
  
  
 You use the star wildcard in cases where you know nothing about the type, but still 
 want to satisfy variance semantics prescribed by class or interface declarations.",NA
 Generic Functions,"Functions in Kotlin can also be generic, which means their parameters or some of their 
 parameters can have a generic type. In such cases, the generic type designators must 
 be added as a comma-separated list in angle brackets after the function keyword. The 
 generic types can also show up in the function’s return type. Here is an example.
  
 fun <A> fun1(par1:A, par2:Int) {
  
  
  ...
  
 }
  
 283
  
 www.EBooksWorld.ir",NA
 Generic Constraints ,"Until now there was no restriction to the type a generic type identifier could be mapped 
 to during instantiation. Therefore in class TheClass<T> the T generic type could be 
 anything, a TheClass<Int>, TheClass<String>, TheClass<Any>, or whatever. It is, 
 however, possible to restrict the type to a certain class or interface or one of its 
 subtypes. 
  
 For that aim you write 
  
 <T : SpecificType> 
  
 as in 
  
 class <T : Number> { ... }
  
 284",NA
 Exercise 2,"Write a generic class Sorter with a type parameter T and suitable type bound, which has 
 a property val list:MutableList<T> and a function fun add(value:T). With each function 
 invocation, the parameter must be added to the list and the list property must be sorted 
 according to its natural sorting order.
  
 287
  
 www.EBooksWorld.ir",NA
CHAPTER 14,NA,NA
Adding ,NA,NA
Hints: ,NA,NA
Annotations,"Annotations are for adding meta-information to your code. What does that mean? 
 Consider the following classes:
  
 class Adder {
  
  
  fun add(a:Double, b:Double) = a + b 
  
 } 
  
 class Subtractor {
  
  
  fun subtract(a:Double, b:Double) = a - b }
  
  
 If we have a larger arithmetic calculation project where the various operations 
 get handled by classes like Adder and Subtractor here, we could have something like
  
 val eng = CalculationEngine() 
  
 ...
  
 eng.registerAdder(Adder::class, ""add"") eng.registerSubtractor(Subtractor::c lass, 
 ""subtract"") 
  
 ...
  
 for registering the particular low-level operations.
  
 We could, however, follow a different approach where the operators somehow 
 announce their abilities to the framework. They could do this by special documentation 
 tags, as in
  
 /**
  
  * @Operator: ADDING
  
  * @Function: add
  
  */
  
 © Peter Späth 2019 
  
 289",NA
Note,NA,NA
 A ,NA,NA
framework,NA,NA
" is a collection of classes, interfaces, and singleton ",NA,NA
objects that provide a scaffolding structure to software. A framework is ,NA,NA
"not an executable program itself, but a software project uses the ",NA,NA
framework to establish a ,NA,NA
standardized structure. Different projects using a particular ,NA,NA
framework thus exhibit a similar structure and if a developer knows ,NA,NA
one project embedded into a particular framework it will be easier to ,NA,NA
understand other projects using the same framework.,"This method of letting classes announce themselves to a program frequently gets 
 used in a server environment where the program needs to be able to communicate with 
 clients over a network.
  
 There is, however, a problem with this approach. Because the meta-information gets 
 presented from inside the documentation, there is no possibility for the compiler to 
 check the correctness of the tags. Concerning the compiler, the contents of the 
 documentation are completely unimportant, and should be unimportant, because this is 
 what the language specification says.
  
 290
  
 www.EBooksWorld.ir",NA
 Annotations in Kotlin,"This is where annotations enter the game. They exist exactly for this kind of task: not 
 interfering with the class’s primary responsibilities, but providing meta-information to 
 the program or framework for maintenance or registration purposes. An annotation 
 looks like this:
  
 @AnnotationName
  
 or
  
 @AnnotationName(...)
  
 if there are parameters. A lot of language elements can be marked with such annotations: 
 files, classes, interfaces, singleton objects, functions, properties, lambdas, statements, 
 and even other annotations. The operator classes for the preceding calculation engine 
 example could read
  
 @Operator(ADDING) 
  
 class Adder {
  
  
  @OperatorFunction
  
  
  fun add(a:Double, b:Double) = a + b }
  
 @Operator(SUBTRACTING) 
  
 class Subtractor {
  
  
  @OperatorFunction
  
  
  fun subtract(a:Double, b:Double) = a - b }
  
 Now the compiler is in a better situation. Because annotations are part of the 
 language the compiler can check whether they exist, are spelled correctly, and have the 
 correct parameters provided.
  
  
 In the following sections we first discuss annotation characteristics, then annotations 
 that Kotlin provides. We then cover how to build and use our own annotations.
  
 291
  
 www.EBooksWorld.ir",NA
 Annotation Characteristics,"Annotations get declared by annotation classes as follows:
  
 annotation class AnnotationName
  
 We cover building our own annotations in a later section. For now we mention the 
 declaration because annotations have their characteristics described by their own 
 annotations, which then are meta-annotations:
  
 @Target(...) 
  
 @Retention(...) 
  
 @Repeatable 
  
 @MustBeDocumented 
  
 annotation class AnnotationName
  
  
 You can use any combination of them in any order, and they have default values if 
 unspecified. We describe them, including possible parameters, here.
  
 • @Target(...)
  
 Here you specify the possible element types to which the 
  
 annotation can be applied. The parameter is a comma-
  
 separated list of any of the following (all of them are fields of the 
 enumeration kotlin.annotation.AnnotationTarget):
  
 – CLASS: All classes, interfaces, singleton objects and annotation classes.
  
 – ANNOTATION_CLASS: Only annotation classes.
  
 – PROPERTY: Properties.
  
 – FIELD: A field that is the data holder for a property. Note that a property 
 by virtue of getters and setters does not necessarily need a field. However, 
 if there is a field, this annotation target points to that field. You put it in 
 front of a property declaration, together with the PROPERTY target.
  
 – LOCAL_VARIABLE: Any local variable (val or var inside a function).
  
 – VALUE_PARAMETER: A function or constructor parameter.
  
 292
  
 www.EBooksWorld.ir",NA
 Applying Annotations,"In general, annotations get written in front of the element to which the annotation is to 
 apply. The story gets a little bit complicated because it is not always clear what is meant 
 by element. Consider this example:
  
 class Xyz {
  
  
  @MyAnnot var d1:Double = 1.0 
  
 }
  
 Here we have four elements to which the annotation could be applied: the property, 
 the property getter, the property setter, and the data field. For this reason, Kotlin 
 introduced 
 use-site targets
  in the form of a qualifier: written between the @ and the 
 annotation name. The following use-site targets are available:
  
 • file
  
 We know that a Kotlin file can contain properties and functions 
 outside classes, interfaces, and singleton objects. For an annotation 
 applying to such a file, you write @file:AnnotationName in front of 
 the package declaration. For example:
  
 @file:JvmName(""Foo"") 
  
 package com.xyz.project 
  
 ...
  
 294
  
 www.EBooksWorld.ir",NA
 Annotations with Array Parameter,"Using arrays as an annotation constructor parameter is easy: Just use the vararg 
 qualifier in the annotation declaration, and in the annotation instantiation use a 
 comma-separated parameter list:
  
 annotation class Annot(vararg val params:String) ...
  
 @Annot(""A"", ""B"", ""C"", ...) val prop:Int = ...
  
 If you need to use an annotation with a single array parameter from a Java library 
 you included in your project, the parameter gets automatically converted to a vararg 
 parameter, so you basically do the same:
  
 @field:JavaAnnot(""A"", ""B"", ""C"", ...) val prop:Int = ...
  
 297
  
 www.EBooksWorld.ir",NA
 Reading Annotations,"For reading annotations with retention type SOURCE you need a special annotation 
 processor. Remember that for SOURCE type annotation the Kotlin compiler removes the 
 annotation during the compilation step, so in this case we must have some software 
 looking at the sources before the compiler does its work. Most source type annotation 
 processing happens inside bigger server framework projects; here the annotations get 
 used to produce some synthetic Kotlin or Java code that glues together classes to model 
 complex database structures. There is a special plug-in to be used for such purposes, 
 KAPT, which allows for the inclusion of such source type annotation preprocessors.
  
 You can find more information about KAPT usage in the online Kotlin 
 documentation. For the rest of this section we talk about RUNTIME retention 
 type annotation processing.
  
 For reading annotations that have been compiled by the Kotlin compiler and ended 
 up in the bytecode that gets executed by the runtime engine, the 
 reflection API
  gets used. 
 We discuss the reflection API later in this book; here we mention only annotation 
 processing aspects.",NA
Note,NA,NA
" to use reflection, the kotlin-reflect.jar must be in the class path. ",NA,NA
"this means you have to add implementation ""org.jetbrains.kotlin: kotlin-",NA,NA
"reflect:$kotlin_version"" inside the dependencies section of your ",NA,NA
module’s build.gradle file.,"To get the annotations for the most basic elements, see Table 
 14-1
 , which 
 describes how to get an annotation or a list of annotations.
  
 298
  
 www.EBooksWorld.ir",NA
 Built-in Annotations,"Kotlin provides a couple of annotations from the start. Table 
 14-2
  shows some general- 
 purpose annotations.
  
 300",NA
 Custom Annotations,"To define your own simple annotations, you write
  
 @Target(...) 
  
 @Retention(...) 
  
 @Repeatable 
  
 @MustBeDocumented 
  
 annotation class AnnotationName
  
 For the annotations for the annotation (i.e., the meta-annotations), note that they 
 are all optional and the order is free. For their meanings, see the section “Annotation 
 Characteristics” earlier in this chapter.
  
  
 If you need annotations with parameters, you add a primary constructor to the 
 declaration:
  
 [possibly meta-annotations] 
  
 annotation class AnnotationName(val p1:Type1, val p2:Type2, ...)
  
 where the following parameter types are allowed: types that correspond to primitive 
 types (i.e., Byte, Short, Int, Long, Char, Float, Double), strings, classes, enums, 
  
 other annotations, and arrays of those. You can add vararg for a variable number of 
 arguments. Note that for annotations used as parameters for other annotations, the @ 
 for the parameter annotations gets omitted.
  
 302
  
 www.EBooksWorld.ir",NA
 Exercise 1,"To the Calculator example, add a new annotation @NotNegative and a new operation 
 sqrt() for the square root. Make sure a negative parameter for this operator is not 
 allowed. Note: The actual square root gets calculated via java.lang.Math.sqrt().
  
 304
  
 www.EBooksWorld.ir",NA
CHAPTER 15,NA,NA
Using the Java ,NA,NA
and Kotlin APIs,"Kotlin has a language kernel that handles classes, objects, properties, functions, 
 structural constructs, and all that stuff. We’ve been talking about these a lot to this point. 
  
 Once in a while we have mentioned and used the term 
 Kotlin standard library
  without 
 explicitly stating what that actually is. In real life a library is a place where extensive 
 information is available. Whenever you need to know something you can go there and 
 try to find a book that can show you what things are or how they work, or what you have 
 to do to achieve something. For a computer language, a 
 library
  is something similar: a 
 repository with lots of classes and functions that you can use for certain tasks. We 
 already talked about collections, which are governed by library classes and functions.
  
 APIs go hand in hand with libraries. An API focuses more on the external 
 face
  of a 
 library; that is, how a library gets used from outside without having to know about 
 the internal functioning.
  
 There are many examples of libraries you can think of; for example, math, chemistry, 
 physics, biology, sociology, encryption standards, web services, user interfacing, sound 
 processing, and graphics, to name just a few, and writing a single book about all of them 
 is just not possible. It makes sense, though, to distinguish between basic libraries that get 
 shipped with Kotlin and external libraries that you can add on demand. Just looking the 
 built-in libraries is a much more feasible task, and in this chapter we look at the libraries 
 that get shipped with Kotlin.
  
 Note that it is neither possible nor desirable in a book like this to list all classes and 
 functions a library has to offer. There are just too many in any but very simple libraries. 
  
 We can, however, try to describe the libraries, show how to use them, and list the 
 most important classes and functions. This happens in subsequent chapters.
  
 © Peter Späth 2019 
  
 305
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_15
  
 www.EBooksWorld.ir",NA
 Kotlin and Java Libraries,"Before we start looking at the different APIs, we need to talk about where the Kotlin 
 libraries come from. Kotlin sits on top of the JVM, and the Kotlin developers did a good 
 job to allow for easy interoperation between Kotlin and Java. This includes the ability to 
 use Java APIs and libraries. With Java around for more than 20 years, it is not hard to 
 imagine that there are some extremely well-tailored Java libraries out there, and there is 
 no need for Kotlin to redo everything. What Kotlin instead does is include some of the 
 libraries that were already included with a Java distribution, and then extends or 
 redefines them at a couple of places using its class extension mechanisms.",NA
 Using the Online Resources,"For any of the APIs included in Kotlin, having the official API documentation at hand 
 always is a good idea. The place to go is 
 https://kotlinlang.org/
 . There you will find a 
 LEARN link that gets you to the language and standard library reference manual. If this 
 link is out of date, search “kotlin programming language” in your favorite search engine 
 to find it.
  
 As already pointed out, Kotlin has a strong relation to Java; it is especially easy to 
 incorporate Java standard modules into Kotlin. The Android platform includes various 
 Java APIs, and you don’t have to do anything to use them if you use Android Studio for 
 development. The API level 28 we have been using throughout this book has the 
 following Java APIs from Java 8:
  
 • java.beans
  
 • java.io
  
 • java.lang
  
 • java.math
  
 • java.net
  
 • java.nio
  
 • java.security
  
 • java.sql
  
 • java.text
  
 306
  
 www.EBooksWorld.ir",NA
 Making a Local Copy of the Documentation,"Inside Android Studio, once you press Ctrl+B over any class or interface name, you will 
 be taken to the Java or Kotlin sources. If you do this for the first time, Android Studio 
 might need to download the sources from the Internet, but afterward you will have the 
 sources locally stored inside your Android Studio installation.
  
 If you want to have a local copy of the API documentation on your PC, for Java the 
 corresponding links on the Oracle downloads web site are easy to find. For Kotlin, go 
 to 
 https://github.com/JetBrains/kotlin/releases
 , choose a release, and then 
 download the source code as a compressed archive.
  
 You can also fetch the sources from your Android Studio. Make sure the sources 
 were downloaded by pressing Ctrl+B over any Kotlin standard library class, then go 
 to STUDIO-INST/plugins/Kotlin/kotlinc/lib. There you’ll find a file  kotlin-stdlib- 
 sources.jar. This is a ZIP archive. You can extract all files from the archive and save 
 them anywhere on your PC.
  
 307
  
 www.EBooksWorld.ir",NA
CHAPTER 16,NA,NA
The Collections API,"We already talked about collections in Chapter 
 9
 , namely lists, sets, and maps. The 
 collections API, however, is extensive and contains more classes and interfaces than 
 we described in Chapter 
 9
 . For Java the API even gets called the 
 collections framework
 . 
 Without claiming to be exhaustive in this chapter, we revise what we already know 
 and also talk about a couple of more interesting collection interfaces, classes, and 
 functions.
  
  
 Unfortunately there is nothing like a java.collections package. Concerning Java, the 
 collections API is scattered with its main part lying inside the java.util package.",NA
Note,NA,NA
 We’ll exhibit a way to designate generic type parameters in this ,NA,NA
"chapter. Where obvious, for brevity they are not shown. In all cases ",NA,NA
"we use E as the element type of a list or a set, and K and V for the keys ",NA,NA
and values of maps.,NA,NA
 Interfaces,"Although Java already has interfaces for sets, lists, and maps, Kotlin has its own 
 interfaces for them. This mainly stems from Kotlin’s need to distinguish between 
 mutable and immutable collections and maps. For most use cases you can just use the 
 Kotlin versions, and the compiler even might warn you if you instead try to use the 
 Java variants. It is not forbidden, though, to use the Java variants as well, and there 
 might be reasons to do so. Table 
 16-1
  provides an overview.
  
 © Peter Späth 2019 
  
 309
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_16",NA
 Classes,"Table 
 16-2
  lists the classes that implement the collection and map interfaces.
  
 Table 16-2. 
 Collection Classes
  
 Class
  
 Description
  
 kotlin.collections.ArrayList 
 java.util.ArrayList
  
 A list implementation for both mutable and 
 immutable lists. The Java variant of an ArrayList; 
 don’t use it unless you 
  
 have good reasons to do so.
  
 kotlin.collections.HashSet 
  
 A set implementation for both mutable and 
 immutable sets.
  
 java.util.HashSet 
  
 The Java variant of a HashSet; don’t use it unless you 
 have 
  
 good reasons to do so.
  
 kotlin.collections. 
  
 A set implementation for both mutable and 
 immutable sets. 
  
 LinkedHashSet 
  
 Because the set elements are linked to each other, the 
  
 iteration order is the same as the insertion order.
  
 java.util.LinkedHashSet
  
 kotlin.collections.HashMap
  
 The Java variant of a LinkedHashSet; don’t use it 
 unless you have good reasons to do so.
  
 A map implementation for both mutable and 
 immutable maps.
  
 java.util.HashMap 
  
 The Java variant of a HashMap; don’t use it unless you 
 have 
  
 good reasons to do so.
  
 kotlin.collections. 
  
 A map implementation for both mutable and 
 immutable 
  
 LinkedHashMap 
  
 maps. Because the map elements are linked to each 
 other, 
  
 the iteration order is the same as the insertion order.
  
 java.util.LinkedHashMap
  
 The Java variant of a LinkedHashMap; don’t use it 
 unless you have good reasons to do so.
  
 java.util.ArrayDeque 
  
 A Deque implementation.
  
 java.util.EnumSet 
  
 A specialized java.util.Set implementation for 
  
 enumeration elements.
  
 java.util.LinkedList 
  
 A java.util.List implementation with linked list 
  
 elements.",NA
 Generator Functions,"Kotlin provides hundreds of functions inside its own collection classes, adds extension 
 functions to Java’s collection classes, and in addition serves us with many top-level 
 functions. Without being exhaustive, this section and those that follow list perhaps the 
 most important collection functions of both Kotlin and Java.
  
 Table 
 16-3
  shows top-level generator functions you can use to create collections. 
 Unless otherwise noted, the returned collections and maps are instances of classes from 
 inside package kotlin.collections only.
  
 315",NA
 Collection and Map Setters and Removers,"Table 
 16-4
  shows you how to add elements to mutable collections or maps, and also 
 how to remove them.
  
 Table 16-4. 
 Collection Mutators
  
 For
  
 Function
  
 Description
  
 lists, sets
  
 add(element:E)
  
 Add an element at the TAIl of a list, or 
 add 
  
 an element to a set.
  
 lists
  
 set(index:Int, element:E)
  
 overwrites element at the given 
 index. The 
  
 element to overwrite must exist.
  
 lists
  
 list[index] = value
  
 Same as set()
  
 lists, sets
  
 addAll(elements: 
  
 Adds all elements from the array 
 or 
  
  
 Collection<E>) 
  
 addAll(elements: Array<out E>)
  
 collection provided as the parameter 
 to the TAIl of a list, or add elements to 
 a set.
  
 Maps
  
 put(key:K, value:V)
  
 puts a key/value pair into a map. If 
 the key 
  
 already exists, the value gets overwritten.
  
 Maps
  
 map[key:K] = value:V
  
 Same as put().
  
 Maps
  
 putIfAbsent(key:K, value:V)
  
 puts a key/value pair into a map, but 
 only 
  
 if the key didn’t exist before.
  
 Maps
  
 set(key:K, value:V)
  
 Same as put().
  
 Maps
  
 putAll(from: Map<out K,V>)
  
 performs a put() for all the elements 
  
 from the map that gets provided as the 
  
 function parameter.
  
 (
 continued
 )
  
 317",NA
 Deterministic Getters,"Deterministic getters to retrieve elements from collections and maps are listed in 
  
 Table 
 16-5
 .
  
 318",NA
 Collection and Map Characteristics,"For collection and map characteristics, see Table 
 16-6
 .
  
 Table 16-6. 
 Characteristics
  
 Receivers
  
 Function
  
 Description
  
 Maps, lists, 
 sets
  
 Size
  
 The size of the collection or map.
  
 Maps, lists, 
 sets
  
 count()
  
 Same as size.
  
 Maps, lists, 
 sets
  
 isEmpty()
  
 returns true if empty.
  
 Maps, lists, 
 sets
  
 isNotEmpty()
  
 returns true if not empty.
  
 lists, sets
  
 count((E)  -> Boolean)
  
 Counts the elements that for the given 
  
 predicate lambda function return true.
  
 Maps 
  
 count((K,V)  -> Boolean) Counts the elements that for the given 
  
 predicate lambda function return true.
  
 lists, sets
  
 indices
  
 Valid indices as an IntRange.
  
 lists
  
 lastIndex
  
 The last valid index.
  
 320
  
 www.EBooksWorld.ir",NA
 Traversing Collections and Maps,"For traversing collections and maps, you can use one of the constructs shown in 
  
 Table 
 16-7
 .
  
 Table 16-7. 
 Traversing
  
 For
  
 Construct
  
 Description
  
 list, sets, 
 implements 
  
 for( i in x ) { ... }
  
 A language construct, i is the loop 
  
 Iterable
  
 for( me in x ) { ... }
  
 variable and receives the 
 elements.
  
 Maps
  
 A language construct, me is the 
  
 loop variable and receives Map.
  
 Element<K,V> elements. You can 
  
 fetch the key via me.key and the 
  
 value via me.value
  
 Maps
  
 for( (k,v) in x ) { ... }
  
 A language construct, k and v are 
  
 the loop variables and receive key 
  
 and value for each map element.
  
 list, sets, 
 implements 
  
 x.forEach { i -> ... }
  
 Iterates through all elements of 
 x, i
  
 Iterable
  
 x.onEach { i -> ... }
  
 receives each element.
  
 list, sets, 
 implements 
  
 Same as forEach(), but 
 afterward 
  
 Iterable
  
 returns the iterated-over list, 
 set, or 
  
 iterable.
  
 list, sets, 
 implements 
  
 x.forEachIndexed { ind, i 
  
 Iterates through all elements of x, 
 i
  
 Iterable
  
 -> ... }
  
 receives each element. Ind is the 
  
 index variable (0, 1, 2, ...).
  
 Maps
  
 x.forEach  {  me  -> ... }
  
 Iterates through all elements of 
 map 
  
 x, me has type Map.Element<K,V>. 
  
 You can fetch the key via me.key
  
 and the value via me.value
  
 Maps
  
 x.forEach  {  k,v  -> ... }
  
 Iterates through all elements of 
 map 
  
 x, k is the key and v the value of 
  
 each element.
  
 321
  
 www.EBooksWorld.ir",NA
 Transformations,"The possibilities to transform a collection or map into another collection or map are 
 potentially endless. Table 
 16-8
  shows functions to extract the keys and the values from a 
 map.
  
 Table 16-8. 
 Extraction Keys and Values
  
 Construct
  
 Returns
  
 Description
  
 map.keys
  
 MutableSet<K>
  
 Get the keys from a map as a set.
  
 map.values
  
 MutableCollection<V>
  
 Get the values from a map as a collection.
  
 Throughout this section we use list, set, map, coll, and iter for variables of type List, 
 Set, Map, Collection, and Iterable, respectively. Remember that a list or set is a 
 collection and that any collection is an iterable.
  
  
 Table 
 16-9
  shows various functions to transform collection or map elements on an 
 element-by-element basis.
  
 Table 16-9. 
 Transforming: Mapping
  
 Construct
  
 Returns
  
 Description
  
 iter.map(transform: 
  
 List<R>
  
 Transform all the collection’s or any 
 other 
  
  
 (E) -> R)
  
 iterable’s entries according to the 
 lambda function given. returns an 
 immutable list.
  
 iter.mapIndexed( 
  
 List<R>
  
 Transforms all the collection’s or any 
 other 
  
  
 transform: (Int, E) -> R)
  
 iterable’s entries according to the 
 lambda function given. The lambda 
 function gets the index (0, 1, 2, ...) as 
 its first parameter. returns an 
 immutable list.
  
 map.map(transform: (Map.
  
 List<R>
  
 Creates a new immutable list from 
 the 
  
  
 Entry<K,V>) -> R)
  
 results of the lambda function 
 provided to each map element.
  
 (
 continued
 )
  
 322",NA
 Exercise 1,"Given a class data class Employee(val lastName:String, val firstName:String, val 
 ssn:String) and a list
  
 val l = listOf(
  
  
  Employee(""Smith"", ""Eve"", ""012-12-5678""),
  
  
  Employee(""Carpenter"", ""John"", ""123-06-4901""),
  
  
 Employee(""Cugar"", ""Clara"", ""034-00-1111""),
  
  
 Employee(""Lionsgate"", ""Peter"", ""965-11-4561""),
  
  
 Employee(""Disney"", ""Quentin"", ""888-12-3412"") )
  
 get a new immutable list from that sorted by SSN.
  
 326
  
 www.EBooksWorld.ir",NA
 Exercise 2,"Given the employee list from Exercise 1, create an immutable map mapping SSNs to 
 employees.",NA
 Exercise 3,"What is the output of
  
 listOf(listOf(1, 2), listOf(3, 4)).flatten()",NA
 Exercise 4,"What is the output of
  
 listOf(listOf(1, 2), listOf(3, 4)).
  
  flatMap { it.map { it.toString() }    }",NA
 Filtering,"Strongly related to transformations are filtering functions. They are used to get a new 
 collection or map based on some criterion. Table 
 16-13
  lists the filtering functions.
  
 Throughout this section we use list, set, map, coll, and iter for variables of type List, 
 Set, Map, Collection, and Iterable, respectively. Remember that a list or set is a 
 collection and that any collection is an iterable.
  
 Table 16-13. 
 Filtering
  
 Function
  
 Description
  
 iter.filter( predicate: (E) -> 
 Boolean)
  
 iter.filterNot( predicate: (E) -> 
 Boolean)
  
 returns a new immutable list containing only 
 those elements that match the given 
 predicate.
  
 returns a new immutable list containing only 
 those elements that do not match the given 
 predicate.
  
 (
 continued
 )
  
 327
  
 www.EBooksWorld.ir",NA
 Exercise 5,"Given the employee list from Exercise 1, create a new immutable list containing only 
 SSNs starting with a 0. Hint: String.startsWith(...) checks whether a string starts 
 with certain characters.",NA
 Changing the Mutability,"You can see in Table 
 16-14
  that transformations of mutable maps and lists often return 
 immutable maps or collections. If you need a mutable map or collection instead, Kotlin 
 helps you.
  
 Table 16-14. 
 Changing Mode
  
 Function
  
 Description
  
  
 list.toMutableList() 
 set.toMutableSet() 
 map.toMutableMap() 
 mutableList.toList() 
 mutableSet.toSet() 
 mutableMap.toMap()
  
 Transforms an immutable list to a mutable list.
  
 Transforms an immutable set to a mutable 
 set. Transforms an immutable map to a 
 mutable map.
  
 Transforms a mutable list to an immutable list.
  
 Transforms a mutable set to an immutable 
 set. Transforms a mutable map to an 
 immutable map.",NA
 Element Checks,"To check whether any or all elements of a collection or a map satisfy some criterion, you 
 can use one of the functions depicted in Table 
 16-15
 . Throughout this section we use list, 
 set, map, coll, and iter for variables of type List, Set, Map, Collection, and Iterable, 
 respectively. Remember that a list or set is a collection and that any collection is an 
 iterable.
  
 Table 16-15. 
 Checks
  
 Function
  
 Description
  
  
 iter.any(predicate: (E) -> Boolean)
  
 iter.all(predicate: (E) -> Boolean)
  
 iter.none(predicate: (E) -> Boolean)
  
 map.any(predicate: (Map.Entry<K,V>) -> 
  
 returns true if any of the elements 
 satisfy the predicate.
  
 returns true if all of the elements 
 satisfy the predicate.
  
 returns true if none of the elements 
 satisfy the predicate.
  
 returns true if any of the elements satisfy 
  
 Boolean) 
  
 map.all(predicate: (Map.Entry<K,V>) -> 
 Boolean) 
  
 map.none(predicate: (Map.Entry<K,V>) -> 
 Boolean)
  
 the predicate.
  
 returns true if all of the elements 
 satisfy the predicate.
  
 returns true if none of the elements 
 satisfy the predicate.",NA
 Exercise 6 ,"Create a check for list listOf(1, 2, 3, 4) to see whether all elements are greater than 0.",NA
 Finding Elements ,"For finding particular elements from a collection or map, you can use one of the 
  
 functions shown in Table 
 16-16
 , to which we have also added containment checks.
  
 329
  
 www.EBooksWorld.ir",NA
 Exercise 7,"Given a list l of Ints, find a one-expression way, not using if, to throw an exception if 
  
 the list contains 42. Hint: Use find() or contains(), possibly takeIf(), and ?.run.",NA
" Aggregating, Folding, and Reducing","Aggregators deduce the sum, the maximum, the minimum, or the average from 
  
 collections. These are listed in Table 
 16-17
 .
  
 Throughout this section we use list, set, map, coll, and iter for variables of type 
  
 List, Set, Map, Collection, and Iterable, respectively. Remember that a list or set is a 
  
 collection and that any collection is an iterable.
  
 Table 16-17. 
 Aggregating
  
 For
  
 Function
  
 Description
  
 A collection of numbers 
 (Byte, 
  
 sum()
  
 Sums up the elements. Types Byte 
 and 
  
 Short, Int, Long, Float, 
  
 Short yield an Int-valued sum; all 
  
 Double)
  
 others yield the same result type as 
 the 
  
 elements.
  
 Any collection or 
 iterable
  
 sumBy( selector: 
  
 Sums up the elements after applying 
  
 (E) -> Int)
  
 the lambda function to each 
 element. 
  
 results in an Int number.
  
 Any collection or iterable
  
 sumByDouble( 
  
 Sums up the elements after applying 
  
 A collection of numbers 
 (Byte, 
  
 selector: (E) -> 
  
 the lambda function to each element. 
  
 Double)
  
 results in a Double number.
  
 average
  
 Calculates the average of all 
 elements, 
  
 Short, Int, Long, Float, 
  
 as a Double.
  
 Double)
  
 A collection of elements 
  
 max()
  
 returns the maximum value.
  
 implementing Comparable
  
 (
 continued
 )
  
 331
  
 www.EBooksWorld.ir",NA
 Exercise 8,"Given a class data class Parcel(val receiverId:Int, val weight:Double) and a list
  
 val l = listOf( Parcel(1267395, 1.45),
  
  
 Parcel(1515670, 0.46),
  
  
  Parcel(8345674, 2.50),
  
  
  Parcel(3418566, 1.47),
  
  
  Parcel(3491245, 3.04) 
  
 )
  
 calculate the weight sum without using a for or while loop.",NA
 Joining,"Sometimes instead of a full-fledged folding operation with an object receiving all the 
 elements from the iteration, all you need is a way to create a string representation of a 
 collection or an iterable, joining the string representations of all elements. Although this 
 is possible via fold(), a dedicated joining function provided by Kotlin has a couple of 
 extra features, namely a prefix and a postfix, and a limit and a truncation designator. 
  
 You use
  
 fun <E> Iterable<E>.joinToString(
  
  
  separator: CharSequence = "", "",
  
  
  prefix: CharSequence = """",
  
  
  postfix: CharSequence = """",
  
  
  limit: Int = -1,
  
  
  truncated: CharSequence = ""..."",
  
  
  transform: (E) -> CharSequence = null ): 
 String
  
 on the collection or iterable, with the following characteristics:
  
 • If you specify a separator, this one will be used for separating the 
 items in the output string. Otherwise a , will be used.
  
 • If you specify a prefix, it will be used as a prefix for the output string. 
 Otherwise none will be used.
  
 335
  
 www.EBooksWorld.ir",NA
 Grouping,"Grouping is about splitting a list into sublists based on some criterion. Think of a list of 
 employees with each employee having an employer field, and you want to create a list 
 for each employer. This is not hard to do by writing a few lines of code, but because it is 
 a recurring task, there are standard library functions that can help us. See Table 
 16-20
  
 for grouping-related functions.
  
 Table 16-20. 
 Grouping
  
 Function
  
 Returns
  
 Description
  
 <E, K> iter.groupBy( 
  
 Map<K, List<E>>
  
 Groups based on the key 
 calculated 
  
 keySelector: (E) -> K)
  
 Map<K, List<V>>
  
 by the keySelector function.
  
 <E, K> iter.groupBy( 
  
 Groups based on the key 
 calculated 
  
  
 keySelector: (E) -> K, 
 valueTransform: (E) -> V)
  
 by the keySelector function, 
 but also transforms the values 
 by the valueTransform 
 function.
  
 <E, K> iter.groupingBy( 
  
 Grouping<E,K>
  
 prepares a grouping based 
  
  
 keySelector: (E) -> K)
  
 on the key calculated by the 
  
 keySelector function. Creates a 
 special Grouping object that 
 can be used for further 
 operations.
  
  
 (
 continued
 ) 
 336",NA
 Zipping,"If you have two related lists and want to bring them together, Kotlin provides a zipping 
 function that can help you. Say, for example, you have a list of employees and another 
 list of yearly salaries for a year that has not yet been registered. Both lists have the 
 same 
  
 337",NA
 Windowing,"For user interface programming you frequently need to split a list into chunks of a given 
 size. Say, for example, the user interface shows chunks of size 10 and provides page 
 forward and page backward buttons to show the next or the previous chunk of a longer 
 list. For this aim the standard library provides a windowing function (see Table 
 16-21
 ).
  
 Table 16-21. 
 Windowing
  
 Function
  
 Returns
  
 Description
  
 <E> iterable.windowed( 
  
 List<List<E>>
  
 Creates a windowed view of an 
 iterable or 
  
  
 size: Int, step: Int = 1, 
 partialWindows: 
 Boolean = false )
  
 a collection. each chunk has size size, 
 and step indicates the index offset 
 for each chunk (usually you set step 
 = 
  
 size). You must set partialWindows 
 to true if you want to allow smaller 
 chunks at the end.
  
 <E, R> iterable.
  
 List<R>
  
 Same as windowed(), but provides 
  
 windowed( size: 
  
 a transform function to act on each 
  
 Int, step: Int = 1, 
  
 chunk.
  
 partialWindows: Boolean 
  
 = false, transform: 
  
 (List<E>) -> R)
  
 339",NA
 Sequences,"Sequences are lazily evaluated collections. By that we mean that other than for 
  
 collections from the kotlin.collections package, no large amounts of data are held in 
 memory. So, if you create a collection of size 1,000,000 there will be 1,000,000 items in 
 the form of object references or primitives allocated in memory. A sequence of size 
 1,000,000, however, just indicates we have something that can be iterated over 
 1,000,000 times, without all the values associated with it. Sequence interfaces, classes, 
 and functions have their own package: kotlin.sequences.
  
 Sequences expose a lot of functions we already know from collections. You can use 
 forEach(), apply filters, perform mappings, use reductions, perform foldings, and more. 
 We don’t show them all here; instead we list a few of the more important ones to get you 
 started. For more information, refer to the Kotlin documentation.
  
  
 To create a sequence given a list of values, you can use the sequenceOf() function; 
 for example:
  
 sequenceOf(1, 2, 7, 5)
  
 Or, you can take any Iterable (set or list or range, or any collection) and write
  
 iter.asSequence()
  
 To create genuine sequences that do not depend on existing collections or arrays, 
 there are several possibilities. The easiest of them perhaps consists of using the function 
 generateSequence() as in
  
 // Signature: 
  
 // fun <T : Any> generateSequence( 
  
 //     nextFunction: () -> T?
  
 // ): Sequence<T>
  
 var iterVar = 0 
  
 val seq = generateSequence {
  
  
  iterVar++ 
  
 }
  
 Here all we have to do is provide a function that generates the next sequence value. 
 The downside of this approach is that we have a state, namely the iteration property 
 iterVar, somewhere in the surrounding scope of generateSequence(). This is an 
  
 340
  
 www.EBooksWorld.ir",NA
 Operators,"For iterables, including all collections like sets and lists, and also for maps, there are a 
 couple of operators, shown in Table 
 16-22
 , you can use to combine two of them.
  
 Table 16-22. 
 Operators
  
 Operand
  
 Operator
  
 Operand
  
 Returns
  
 Iterable 
 (collections, 
  
 intersect
  
 Iterable 
 (collections, 
  
 Creates a new immutable Set that 
  
 lists, sets)
  
 lists, sets)
  
 contains all elements that are 
 included 
  
 in both operands.
  
 Iterable 
 (collections, 
  
 union
  
 Iterable 
 (collections, 
  
 Creates a new immutable Set that 
  
 lists, sets)
  
 lists, sets)
  
 contains all elements that are 
 included 
  
 in either or both operands.
  
 Iterable 
 (collections, 
  
 +
  
 e
  
 returns a new immutable List 
 with 
  
 lists, sets)
  
 all the elements from the left 
 operand, 
  
 appended to the right operand.
  
 Iterable 
 (collections, 
  
 +
  
 Iterable, array, 
  
 returns a new immutable List 
 with 
  
 lists, sets)
  
 sequence
  
 all the elements from the left 
 operand, 
  
 appended to all the elements 
 from the 
  
 right operand.
  
 (
 continued
 )
  
 343",NA
CHAPTER 17,NA,NA
More APIs,"This chapter gathers a couple of more APIs you can use in your app. First we have the 
 math API that gets used for mathematical calculations. For date and time handling, 
 including transformations between different time representations, and parsing and 
 formatting dates and times, we describe the date and time API. For input and output, 
 which for Android boils down to file handling, we give an overview of the input and 
 output API. For dynamically acquiring class member information the reflection API gets 
 used; this is not a prominent part of object orientation but can help under some 
 circumstances, so we include a treatise on reflection. Regular expressions provide a very 
 powerful means to investigate and manipulate patterns inside strings, so we finish the 
 chapter with a survey of regular expression constructs.",NA
 The Math API,"Kotlin allows you to import the Math package from package java.lang
  
 import java.lang.Math
  
 This can be used like a singleton object and has a lot of mathematical functions like 
 sin(), cos(), tan(), and others. You can look them all up in the Java API documentation. 
 Kotlin provides a copy of some of them inside the kotlin.math package, so in most cases 
 you can go without the java.lang import. The sine function, for example, is provided as an 
 out-of-class function inside the kotlin.math package, so to use it you can write
  
 import kotlin.math.sin 
  
 ...
  
 val x = sin(1.562)
  
  
 The same holds for many other functions. Table 
 17-1
  includes a nonexhaustive list. 
 For a complete list, please see the official Kotlin documentation on the Web.
  
 © Peter Späth 2019 
  
 347
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_17
  
 www.EBooksWorld.ir",NA
" The Date and Time API, API Level 25 or Less","Kotlin does not have a separate date and time API, which is why you wouldn’t find any 
 information on how to handle date and time in the Kotlin documentation. However, you 
 can use the date and time API from Java, which is included in Android and accessible to 
 Kotlin.",NA
Note,NA,NA
 The date and time apI substantially changed with Java 8. android ,NA,NA
"apI versions up to 25 don’t use Java 8, but the later apI versions do; this ",NA,NA
is why we need to describe two date and time apIs. This section is for ,NA,NA
all android apI levels and therefore refers to the older Java 7 date and ,NA,NA
time apI.,"The date and time API borrowed from Java version 7 centers around the 
 following expressions:
  
 import java.util.Date 
  
 import java.util.GregorianCalendar 
  
 import java.text.SimpleDateFormat
  
 val timeMillis:Long = System.currentTimeMillis() val d = 
 Date() 
  
 val cal = GregorianCalendar() 
  
 val sdf = SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"")
  
 349",NA
Caution,NA,NA
 Both Date and SimpleDateFormat are ,NA,NA
not,NA,NA
 thread safe; you must ,NA,NA
not share instances of them between different threads.,"For details about all these date and time API interfaces and classes, and also related 
 interfaces and classes, consult Oracle’s Java documentation. Make sure you don’t use the 
 documentation for a Java version higher than 7. We deal with the Java 8 related date and 
 time API in the next section.",NA
" The Date and Time API, API Level 26 or ",NA,NA
Greater,NA,NA
Note,NA,NA
 This section is for android apI levels starting from 26 (android ,NA,NA
"8.0), and therefore refers to the Java 8 date and time apI.","Starting with Android API level 26 (Android 8.0) a couple of new date and time related 
 interfaces and classes are available. You can continue using the old API described in 
 the previous section, but the new API contains some improvements we outline in this 
 section.
  
 352",NA
Note,NA,NA
" as of the beginning of 2019, the number of devices using apI level ",NA,NA
26 or greater is not very high. You should consult a distribution survey ,NA,NA
before you start developing for apI levels beyond 25.,"The new API can only be used if in your module’s build.gradle file you set the 
 minSdkVersion to 26 or greater:
  
 android {
  
  
  ...
  
  defaultConfig {
  
  
  ...
  
  minSdkVersion 26
  
  ...
  
  }
  
  ...
  
 }
  
  
 The new interfaces and classes reside in the package java.time. For the rest of this 
 section we usually omit the corresponding imports.",NA
 Local Dates and Times,"Local dates and times get described from the context of the observer and basically use 
 the following classes from the java.time package: 
  
 • LocalDate
  
 This class corresponds to a date representation of the format 
 yyyy-MM-dd (e.g., 2018- 11- 27) and disregards the time of 
 day.
  
 • LocalTime
  
 This class corresponds to a time representation of the format 
 HH:mm:ss (e.g., 21:27:55) and disregards the date.
  
 • LocalDateTime
  
 A combination of LocalDate and LocalTime, possibly represented 
 by yyyy-MM- ddTHH:mm:ss (the T is a literal).
  
 353",NA
 Instants,"An instant is an instantaneous point on the timeline. Use this for cases where you 
 need unique absolute timestamps, for example, to register events in databases and 
 the like. The precise definition is somewhat involved; for an introduction read the API 
 documentation for java.time.Instant.
  
 You can get an Instant by, for example, querying the system clock, specifying the 
 elapsed time since 1970-01-01T00:00:00Z, or parsing a time string, or from other 
 date and time objects:
  
 import java.time.*
  
 val inz1 = Instant.now() // default time zone
  
 // Specify time zone 
  
 val inz2 = Instant.now(Clock.system(
  
  
  ZoneId.of(""America/Buenos_Aires"")))
  
 val secondsSince1970 : Long = 1_000_000_000L val 
 nanoAdjustment : Long = 300_000_000 // 300ms val 
 inz3 = Instant.ofEpochSecond(
  
  
  secondsSince1970, nanoAdjustment)
  
 // ""Z"" is UTC (""Zulu"" time) 
  
 val inz4 = Instant.parse(""2018-01-23T23:33:14.513Z"")
  
 // Uniform converter, for the ZonedDateTime class 
  
 // see below 
  
 val inz5 =  Instant.from(ZonedDateTime.parse(""2019-02-13T21:17:23+01:00 
  
 [Europe/Paris]""))
  
 357
  
 www.EBooksWorld.ir",NA
 Offset Dates and Times,"Offset dates and times are like Instants with an additional time offset from UTC/ 
 Greenwich. For such offset dates and times, we have two classes, OffsetTime and 
 OffsetDateTime, for which you can get instances as follows:
  
 import java.time.* 
  
 import java.time.format.DateTimeFormatter
  
 // Get now ------------------------------------------
  
 // System clock, default time zone 
  
 val ot1 = OffsetTime.now() 
  
 val odt1 = OffsetDateTime.now()
  
 // Use a different clock 
  
 val clock:Clock = ...
  
 val ot2 = OffsetTime.now(clock) 
  
 val odt2 = OffsetDateTime.now(clock)
  
 // Use a different time zone 
  
 val ot3 = OffsetTime.now(
  
  
  ZoneId.of(""America/Buenos_Aires"")) val 
 odt3 = OffsetDateTime.now(
  
  
  ZoneId.of(""America/Buenos_Aires""))
  
 // From time details --------------------------------
  
 val ot4 = OffsetTime.of(23, 17, 3, 500_000_000,
  
  
 ZoneOffset.of(""-02:00"")) 
  
 val odt4 = OffsetDateTime.of(
  
  
  1985, 4, 23,            // 19685-04-23
  
  23, 17, 
 3, 500_000_000, // 23:17:03.5
  
  
 ZoneOffset.of(""+02:00""))
  
 // Parsed -------------------------------------------
  
 val ot5 = OffsetTime.parse(""16:15:30+01:00"") 
  
 val odt5 = OffsetDateTime.parse(""2007-12-03T17:15:30-08:00"")
  
 358
  
 www.EBooksWorld.ir",NA
 Zoned Dates and Times,"Local dates and times are great if we aren’t concerned about user location. If we have 
 different entities, users, computers, or devices all over the world entering dates and 
 times, we need to add the time zone information. This is what the class ZonedDateTime 
 is for.
  
 Note that this is not the same as a date and time with a fixed time offset 
 information, as is the case for OffsetDateTime. A time zone includes things like Daylight 
 Saving Time that need to be taken into account.
  
 Similar to LocalDateTime, the ZonedDateTime has factory methods for getting 
 now:
  
 import java.time.*
  
 // Get ""now"" using the system clock and the default // time 
 zone from your operating system.
  
 val zdt1 = ZonedDateTime.now()
  
 // Get ""now"" using a time zone. To list all available // 
 predefined zone IDs, try 
  
 //     Log.d(""LOG"", ZoneId.getAvailableZoneIds().
  
 //                 joinToString { it + ""\n"" }) val z2 = 
 ZoneId.of(""UTC+01"") 
  
 val zdt2 = ZonedDateTime.now(z2)
  
 // Get ""now"" using an instance of Clock val 
 clock3 = Clock.systemUTC() 
  
 val zdt3 = ZonedDateTime.now(clock3)
  
 360",NA
 Duration and Periods,"A duration is the physical time span between two instances. A period is similar, but 
 only handles years, months, and days, and takes the calendar system into account. there 
 are the special Duration and Period classes for handling durations and periods:
  
 import java.time.* 
  
 import java.time.temporal.ChronoUnit
  
 val ldt1 = LocalDateTime.parse(""2018-01-23T17:23:00"") val 
 ldt2 = LocalDateTime.parse(""2018-01-24T16:13:10"") val ldt3 
 = LocalDateTime.parse(""2020-01-24T16:13:10"")
  
 // Getting a duration: ------------------------------
  
 val d1 = Duration.between(ldt1, ldt2) 
  
 // Note: this works also for Instant and ZonedDateTime // 
 objects
  
 362
  
 www.EBooksWorld.ir",NA
 Clock,"A Clock sits in the depths of the date and time API. For many, if not most applications, 
 you can work well with local dates and times, offset and zoned dates and times, and 
 instants. It might be necessary to tweak the clock usage for getting 
 now
  for testing and 
 special cases:
  
 import java.time.*
  
 val clock : Clock = ...
  
 val ldt = LocalDateTime.now(clock) 
  
 val zdt = ZonedDateTime.now(clock) 
  
 val inz = Instant.now(clock)
  
  
 Apart from overwriting the abstract Clock class, Clock itself provides a couple of 
 functions to tweak clock usage. These two are particularly interesting:
  
  1. Clock.fixed(fixedInstant:Instant, zone:ZoneId): This is 
  
 always a 
 clock that always returns the same instant.
  
  2. Clock.offset(baseClock:Clock, offsetDuration:Duration): Returns a 
 new clock derived from the base clock with the specified duration 
 added.
  
 If, however, you overwrite the clock, you must implement at least the abstract 
 functions from the Clock base class. Here is an example of a clock that always returns the 
 same instant and doesn’t care about zones:
  
 import java.time.*
  
 val myClock = object : Clock() {
  
  
  override fun withZone(zone: ZoneId?): Clock {
  
  
  // Supposed to return a copy of this clock
   
  // 
 with a different time zone
  
  
  
  return this
  
  
  }
  
  override fun getZone(): ZoneId {
  
  // Supposed to return the zone ID 
 return ZoneId.of(""Z"")
  
 366
  
 www.EBooksWorld.ir",NA
 Exercise 1,"Create a clock ClockTwiceAsFast with a constructor fetching the time from the UTC 
 system clock. After that, the clock should run twice as fast. Disregard zone information. 
  
 To prove that it is running the intended way, use
  
 import java.time.*
  
 val myClock = ClockTwiceAsFast() 
  
 Log.d(""LOG"", LocalDateTime.now(myClock).format(
  
  
 DateTimeFormatter.ISO_LOCAL_DATE_TIME)) 
 Thread.sleep(1000L) 
  
 Log.d(""LOG"", LocalDateTime.now(myClock).format(
  
  
 DateTimeFormatter.ISO_LOCAL_DATE_TIME))",NA
 Input and Output,"In an Android environment you probably won’t use input and output very often. The 
 users of your app don’t see a console a println(""Hello World"") would print to, and any 
 logging your app produces is not supposed to be seen by end users anyway. In addition, 
 for persisting and reading data of any kind you can use the built-in database.
  
 367
  
 www.EBooksWorld.ir",NA
 Creating Some Test Files,"Just to have some files to get you started experimenting with the I/O API, run the 
 following once:
  
 dataDir.resolve(""a.txt"").takeIf{ 
 !it.exists() 
 }.appendText(""Hello 
 World 
 A"") 
 dataDir.resolve(""b.txt"").takeIf{ 
 !it.exists() 
 }.appendText(""Hello 
 World 
 B"") 
 File(dataDir,""dir1"").mkdirs()dataDir.resolve(""dir1"").resolve(""a.txt"").
  
  takeIf{ !it.exists() }.appendText(""Hello World dir1-A"")
  
 We discuss those functions later.",NA
 File Names,"For maximum interoperability you should restrict file names to contain only 
 characters from A–Z, a–z, 0–9, _, -, and . Also, to indicate that a file file lies inside a 
 directory dir, write dir/file. To designate the root directory of the file system, use /.
  
 368
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 The slash (/) is the file system separator on android. other ,NA,NA
operating systems use different separators. If you want to be really ,NA,NA
"polyglot, you can write ""dir"" + File.separator + ""file"". The runtime ",NA,NA
engine will then pick up the appropriate separator for the operating ,NA,NA
system in which it works.,"To address a file fileName inside a given directory you can use
  
 val someDir:File = ...
  
 val file:File = someDir.resolve(""fileName"")
  
 which works for real files and subdirectories.",NA
 Listing Directories,"To list the files of the app’s file storage write
  
 dataDir.walk().maxDepth(1).forEach { file ->
  
  
 Log.d(""LOG"", file.toString()) 
  
 }
  
  
 This shows the immediate contents of the data directory. If you ran the 
 little preparation code from earlier, the logging output will look like this:
  
 /data/user/0/multipi.pspaeth.de.multipi/files 
  
 /data/user/0/multipi.pspaeth.de.multipi/files/instant-run 
 /data/user/0/multipi.pspaeth.de.multipi/files/a.txt 
  
 /data/user/0/multipi.pspaeth.de.multipi/files/b.txt 
  
 /data/user/0/multipi.pspaeth.de.multipi/files/dirs1 
  
 /data/user/0/multipi.pspaeth.de.multipi/files/dir1
  
 The multipi.pspaeth.de.multipi happens to be the sample app where I’m running the 
 code, and in the second line, instant-run belongs to a directory Android installed by 
 default. You can, of course, apply walk() to any other directory, just make sure you have 
 the appropriate file system access rights. The maxDepth(1) confines traversal to the 
 immediate children of the directory only. Omitting it would traverse all contents 
 recursively, including files in directories, files in directories in directories, and so on.
  
 369",NA
Note,NA,NA
 The reason the Sequence interface exists is that sequences ,NA,NA
"potentially can be iterated over several times, which is not the case ",NA,NA
for implementations of Iterable.,"For example, to recursively list all real files inside dataDir, omitting directories, 
 you’d apply a filter as follows:
  
 dataDir.walk().filter { it.isFile() }.forEach {
  
  file ->
  
  
  Log.d(""LOG"", file.toString()) 
  
 }
  
 You can use the same filtering procedure to only list files that have a certain ending:
  
 dataDir.walk().filter { it.endsWith("".txt"") }.
  
 forEach {
  
  
  file ->
  
  
  Log.d(""LOG"", file.toString()) 
  
 }
  
  
 There is also a function startsWith(""someString"") to see whether a file name starts 
 with a certain string. You can also check the name against a regular expression:
  
 dataDir.walk().filter {
  
  
  
  it.name.matches("".*invoice\\d\\d.*\\.txt"") 
 }.forEach {
  
  
  file ->
  
  
  Log.d(""LOG"", file.toString()) 
  
 }
  
  
 This would match any file with a name that contains an invoice with two numbers 
 added, and ends with .txt.
  
 370
  
 www.EBooksWorld.ir",NA
 Writing to Files,"To write or append text to a file, you can use
  
 val file = dataDir.resolve(""a.txt"") 
  
 // or any other file
  
 // Write to the file 
  
 file.writeText(""In the house, there was no light"")
  
 // Append to the file 
  
 file.appendText(""\nIn the house, there was no light"")
  
 Note that writeText(text:String) and appendText(text:String) use the UTF-8 
 character set. If you need a different character set, you can add an instance of java.nio. 
 charset.Charset as a second parameter: writeText( ""..."", Charsets.ISO_8859_1 ) (Charsets 
 is a Kotlin class: kotlin.text.Charsets).
  
  
 To get more low level, it is also possible to write the raw bytes from a ByteArray to 
 a file:
  
 val file = dataDir.resolve(""a.txt"") 
  
 val bytes = byteArrayOf(27, 34, 13, 47, 50)
  
 // Write to the file 
  
 file.writeBytes(bytes)
  
 // Append to the file 
  
 file.appendBytes(bytes)",NA
Note,NA,NA
 If you need really heavy file handling with large files or many fine- ,NA,NA
"grained file operations, Kotlin provides more extensions that can help ",NA,NA
"you, and you can also use the plethora of Java file handling classes and ",NA,NA
methods. Because on android you have a built-in fast database for such ,NA,NA
"use cases, I don’t think you will use such special file handling very often, ",NA,NA
but feel free to explore the Kotlin and Java documentation.,"371
  
 www.EBooksWorld.ir",NA
 Reading from Files,"To read from files, you have to decide whether you want to read the complete file into 
 memory, you want to read a text file line by line, or you want to read a file containing 
 binary data block-wise.
  
  
 To read a moderately sized text file as a whole into a property, write this (again 
 we assume you ran that little preparatory program from the beginning of the 
 chapter):
  
 val file = dataDir.resolve(""a.txt"") 
  
 val fileText:String = file.readText()
  
  
 Here the UTF-8 character set gets used. To read a file with a different character 
 set, add a parameter:
  
 val file = dataDir.resolve(""a.txt"") 
  
 val fileText:String = file.readText(
  
  
  Charsets.ISO_8859_1)
  
  
 If you don’t have a text file, but a file with some raw byte data, to read the bytes 
 from a file use this:
  
 val file = dataDir.resolve(""a.txt"") 
  
 val fileBytes:ByteArray = file.readBytes()
  
  
 Reading a text file as a whole into a property certainly makes sense for small text 
 files. To handle larger text files, you can also read them line by line:
  
 val file = dataDir.resolve(""a.txt"")
  
 val allLines = file.readLines() 
  
 allLines.forEach { ln ->
  
  
  // do something with the line (a String) }
  
 The documentation says you shouldn’t do this for huge files. Internally the file gets 
 read into a big list containing all lines. Files with up to 100,000 lines do not actually 
 cause a problem, though. If you target Android devices starting from API level 26, there 
 is also a more efficient way for reading lines into a stream:
  
 372
  
 www.EBooksWorld.ir",NA
 Deleting Files,"To delete a file or a directory you write
  
 import java.io.File 
  
 ...
  
 val file:File = ...
  
 val wasDeleted:Boolean = file.delete()
  
 373
  
 www.EBooksWorld.ir",NA
 Working with Temporary Files,"If you need temporary files it is easier to use
  
 import java.io.File 
  
 ...
  
 val prefix = ""tmpFile"" 
  
 val suffix = "".tmp"" 
  
 val tmpFile:File = File.createTempFile(prefix, suffix) 
 tmpFile.deleteOnExit()
  
 ... use tmpFile
  
 compared to manually making up temporary files.
  
 374
  
 www.EBooksWorld.ir",NA
 More File Operations,"Copying a file using the functions we already know is relatively easy: file2.writeBytes( 
 file1.readBytes() ). There is also a library function, however, to make it more 
  
 expressive and also add some options:
  
 import java.io.File 
  
 ...
  
 val file1:File = ... 
  
 val file2:File = ...
  
 f1.copyTo(f2)       // f2 must not exist 
  
 f1.copyTo(f2, true) // overwrite if necessary
  
 // To fine-tune performance, you can tweak the // 
 buffer size 
  
 f1.copyTo(f2, bufferSize = 4096)
  
 The copyTo() function returns the target file.
  
  
 The ability to copy a complete directory recursively including all subdirectories and 
 their files is provided by another standard library function:
  
 import java.io.File 
  
 ...
  
 val dir1:File = ... 
  
 val dir2:File = ...
  
 f1.copyRecursively(f2)       // f2 must not exist 
 f1.copyRecursively(f2, true) // overwrite if necessary
  
 375
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 The java.nio package contains more classes and functions that ,NA,NA
"give more information about files, if you need even more details.",NA,NA
 Reading URLs,"The file API contains very convenient functions to read the contents of an Internet URL. 
 Just write
  
 import java.net.URL 
  
 import kotlin.concurrent.thread
  
 thread {
  
  
  val contents:String =
  
  
  
  URL(""http://www.example.com/something.txt"").
  
  readText()
  
  val isoContents =
  
  
  URL(""http://www.example.com/something.txt"").
  
  readText(Charsets.ISO_8859_1)
  
  val img:ByteArray =
  
  
  URL(""http://www.example.com/somepic.jpg"").
  
  
  readBytes() 
  
 }",NA
Note,NA,NA
" on android, you must request Internet access permission for this to ",NA,NA
work. ,NA,NA
"add <uses-permission android:name = ""android.permission. ",NA,NA
"INTERNET""/> right inside the manifest element in the ",NA,NA
AndroidManifest. xml file.,NA,NA
"on android, this must be run in a background thread. This is why I ",NA,NA
"wrapped the read operation in a thread{ } construct. This is easy, but in ",NA,NA
a serious app you should instead use one of android’s genuine ,NA,NA
"background execution features, for example, an IntentService. That one ",NA,NA
implies considerably more work. Consult the android documentation ,NA,NA
for more details.,377,NA
 Using Reflection,"Reflection is about considering classes as objects. How can that be? We learned that 
 objects are instances of classes. We also learned, though, that objects are identifiable 
 units describing something via properties, and giving methods at hand for doing 
 something with the properties using functions.
  
 The trick is this: Classes are also identifiable units, and if you want to describe them 
 you’d explain the nature of their properties and functions. Reflection is exactly that: 
 Classes are objects describing the properties and functions of the class to which they are 
 referring. In addition, we can also dynamically look up the interfaces a class implements, 
 and possible superclasses.",NA
Note,NA,NA
 Kotlin reflection is not part of the standard library. You must add ,NA,NA
"implementation ""org.jetbrains.kotlin:kotlin- reflect:$kotlin_ version""",NA,NA
(one line) to the dependencies section of your app module’s build.gradle ,NA,NA
file.,"We start with a simple class extending some base class, implementing some 
 arbitrary interface and furthermore with a constructor, two properties, and a function:
  
 import android.util.Log
  
 open class MyBase(val baseProp:Int) 
  
 class MyClass(var prop1:Int) :
  
  
  
  java.io.Serializable, MyBase(13) {
  
  
 var prop2:String
  
  
   
  get() = ""Hi""
  
  
   
  set(value) { /* ignore */ }
  
  init {
  
  
  Log.d(""LOG"", ""Hello from init"")
  
  }
  
 378
  
 www.EBooksWorld.ir",NA
Caution,NA,NA
 Do not make the mistake of taking the improved dynamics of ,NA,NA
"reflection over normal class, property, and function usage as a sign that ",NA,NA
using reflection for all property and function accesses is the better way ,NA,NA
of writing programs. ,NA,NA
"Using reflection, you’ll get a considerable performance degradation, ",NA,NA
"you’ll lose expressiveness and conciseness, and you also develop ",NA,NA
somewhat “around” object orientation. Use reflection with care.,NA,NA
 Regular Expressions,"Regular expressions try to give answers to the following questions:
  
 • Does a string contain a certain character pattern? For example, we 
 want to know whether the string invoice 2018-01-01-A4536 contains 
 a substring that starts with A. Or whether the same string contains 
 any date yyyy-MM-dd. We want to be pretty versatile here; patterns 
 should allow us to specify character classes like letters, lowercase 
 letters, uppercase letters, numbers, character enumerations, spaces, 
 repetitions, and more.
  
 • How can we split a string at delimiters in the form of patterns? For 
 example, we have a string A37 | Q8 | 156-WE and we want to split it at | 
 to get a string array [ ""A37 "", "" Q8 "", "" 156-WE"" ]. For the split marker it 
 should also be possible to specify a longer string, or a pattern.
  
 • How can we extract certain substrings from a string given a pattern? 
 For example, we have a string The invoice numbers are X-23725, X-7368 
 and X-71885 and we want to extract all the invoice numbers X-<some 
 digits> to get an array [ ""X-23725"", ""X-7368"", ""X- 71885"" ].
  
 382
  
 www.EBooksWorld.ir",NA
 Patterns,"Before we talk about how to achieve regular expression operations, we investigate 
 the patterns that can be used for them. A pattern is a string with regular expression 
 constructs, as shown in Table 
 17-2
 . You can enter patterns in a normal string with 
 backslashes (\) escaped: The pattern ^\w{3} (three word characters at the 
 beginning) thus must be entered as ^\\w{3}. You can use 
 raw
  strings to avoid 
 escaping:
  
 val patStr = ""^\\w{3}$""     // exactly 3 word chars val 
 patStr2 = """"""^\w{3}$"""""" // the same
  
 Note Table 
 17-2
  is not exhaustive; it shows the constructs most often used. For a 
 complete reference, consult the Java API documentation for java.util.regex.Pattern.
  
 Table 17-2. 
 Regular Expression Pattern
  
 Construct
  
 Matches
  
 x 
  
 \\ 
  
 \X 
  
 \n 
  
 \r 
  
 [abc] 
  
 [^abc] 
  
 [A-Z] 
  
 [0-9a-z] .
  
 any character x 
  
 The backslash character \ 
  
 a literal X, if X otherwise stands for a pattern 
 construct a newline character 
  
 a carriage return character 
  
 any of a, b, or c 
  
 anything but a, b, or c 
  
 anything between a and Z 
  
 anything between 0 and 9 or between a and z 
  
 any character
  
 (
 continued
 )
  
 383",NA
 Determining Matches ,"To see whether a string matches a given regular expression, you can use the following 
 function: 
  
 val re = Regex(""^\\w{3}$"")     // exactly 3 word chars 
  
 val matches1 = ""Hello"".matches(re) // -> false 
  
 val matches2 = ""abc"".matches(re)   // -> true",NA
 Exercise 2 ,"Write a string extension function that allows us to 
 write ""Hello"" % "".*ll.*"" 
  
 instead of 
  
 ""Hello"".matches(Regex("".*ll.*"")) 
  
  
 Hint: The operator % writes as .rem().
  
  
 The Regex class has constructors that allow specification of one or more 
 options: Regex(pattern:String, option:RegexOption) 
  
 Regex(pattern:String, options:Set<RegexOption>) 
  
  
 RegexOption is an enum class including the following members (see the API 
 documentation for the complete list):
  
  
  
 • 
  
 IGNORE_CASE: Use this to perform case-insensitive matches.
  
 • DOT_MATCHES_ALL: Use this if you want a . pattern to also include line 
 breaks.
  
 • MULTILINE: Use this if you want ^ and $ to respect line breaks.
  
 • COMMENTS: Allow comments in regular expression patterns.
  
 If you add the RegexOption.COMMENTS flag, you can add comments to your 
 regular expression patterns. This is invaluable if regular expressions are more 
 complex. As an example, consider this:
  
 386
  
 www.EBooksWorld.ir",NA
 Splitting Strings,"To split a string around a regular expression as a delimiter you write
  
 val re = Regex(""\\|"") 
  
 // <- use ""\"" escape to get a ""|"" as a literal
  
 val s = ""ABC|12345|_0_1"" 
  
 val split: List<String> = s.split(re) 
  
 // -> ""ABC"", ""12345"", ""_0_1""
  
 // limit to at most 37 splits 
  
 val split37 = s.split(re, limit = 37)",NA
Note,NA,NA
 For splitting up a big string including line breaks into lines you ,NA,NA
probably don’t want to use regular expressions for performance reasons. ,NA,NA
"It is much easier to use the lines() function, which can be applied on any ",NA,NA
"string: val s = ""big string... ""; s.lines().forEach { ln -> ... }","387
  
 www.EBooksWorld.ir",NA
 Extracting Substrings,"Finding patterns in a string and actually extracting them happens via functions of the 
 Regex class:
  
 // a number pattern 
  
 val re = Regex(""""""
  
  
  -?  # possibly a ""-""
  
  
  \d+ # one or more digits
  
  
  (
  
  
  
  \.   # a dot
  
  
  
  \d+  # one or more digits
  
  
  )?     # possibly
  
  """""", RegexOption.COMMENTS)
  
 val s = ""x = 37.5, y = 3.14, z = -100.0""
  
 val firstNumber:MatchResult? = re.find(s) // 
 start at a certain index instead: 
  
 // val firstNumber = re.find(s, 5)
  
 val notFound = firstNumber == null 
  
 firstNumber?.run {
  
  
  val num = groupValues[0]
  
  
  // do something with num...
  
 }
  
 val allNumbers:Sequence<MatchResult> = re.findAll(s) 
 allNumbers.forEach { mr ->
  
  
  val num = mr.groupValues[0]
  
  
  // do something with num...
  
 }
  
 This is fine if we want to assign each pattern match to a local property. There is 
 more to this, though: We can acquire match 
 groups
  that belong to subpatterns defined 
 by ( ) pairs. Consider the number matcher slightly rewritten:
  
 388
  
 www.EBooksWorld.ir",NA
Caution,NA,NA
" The destructured property, although easy to use, only can ",NA,NA
handle up to ten groups. The property groupValues is potentially ,NA,NA
unlimited.,NA,NA
 Replacing,"Replacing patterns in strings is similar to finding patterns. We have a function 
 replaceFirst() that only replaces the first occurrence of a pattern, and replace(), 
 which replaces all occurrences:
  
 390
  
 www.EBooksWorld.ir",NA
CHAPTER 18,NA,NA
Working in ,NA,NA
Parallel: ,NA,NA
Multithreading,"Modern computers and modern smartphones have several CPUs able to work in parallel. 
 You probably think of several apps running at the same time, but there is more to 
 concurrency; you can have several “actors” do work in parallel in one app, noticeably 
 speeding up program execution. I deliberately say “actors” because simply saying that 
 several CPUs work in parallel only covers part of the story. In fact, software developers 
 prefer to think of 
 threads,
  which are program sequences that can potentially run 
 independent of each other. Which CPU actually runs a thread is left to the process 
 scheduling managed by the operating system. We adopt that thread notion and by that 
 abstract from operation system process handling and hardware execution internals.
  
 Within one app, having several threads running concurrently is commonly referred 
 to as 
 multithreading
 . Multithreading has been a prominent part of Java for years now, 
 and you can find Java’s relevant interfaces and classes inside packages 
 java.lang 
 and 
 java.util.concurrent
  and subpackages. These are also included within Kotlin for 
 Android. However, Kotlin has its own idea about multithreading and introduces a 
 technique called 
 coroutines
 . You can use both features, and in this chapter we discuss 
 both of them.",NA
 Basic Multithreading the Java Way,"Without any further preparation, when you start a Kotlin (or Java) app the program 
 gets run in the 
 main
  thread. However, you can define and start other threads that can 
 be worked through concurrently while the main thread is running.
  
 © Peter Späth 2019 
  
 393",NA
Note,NA,NA
 The Java multithreading classes are automatically available to ,NA,NA
Kotlin in an Android development environment.,"The most important multithreading-related class in Java is 
 java.util.Thread
 . You 
 can create one using its constructor, but Kotlin has a function that simplifies thread 
 creation: 
 thread()
 . Its synopsis reads like this:
  
 fun thread(
  
  
  start: Boolean = true,
  
  
  isDaemon: Boolean = false,
  
  
  contextClassLoader: ClassLoader? = null,
  
  name: String? = null,
  
  
  priority: Int = -1,
  
  
  block: () -> Unit 
  
 )
  
 You use it as follows, for example:
  
 val thr:Thread = thread(start = true) {
  
  ... do 
 something ...
  
 }
  
 The 
 thread()
  function creates a 
 Thread
  using the following characteristics:
  
 • If you don’t explicitly specify the 
 start
  parameter to read 
 false
 , the 
 Thread.start()
  function gets called immediately after thread creation.
  
 • If you set 
 isDaemon
  to 
 true
 , a running thread will not prevent 
  
 the runtime engine from shutting down when the main thread has 
 finished its work. In an Android environment, however, 
  
 undaemonized threads will not make an app continue being active when 
 the system decides to shut down or suspend an app, so this flag has no 
 noticeable implications for Android.
  
 • Specifying a separate class loader is an advanced feature you can use if 
 you want the thread to use a class loader different from the system class 
 loader. In this book we don’t talk about class loading issues; usually you 
 can safely ignore class loading issues in an Android environment.
  
 394
  
 www.EBooksWorld.ir",NA
 Advanced Multithreading the Java Way,"Scattering 
 synchronized
  blocks and 
 join
  functions throughout your code poses a couple 
 of problems: First, it makes your code hard to understand; understanding multithreaded 
 state handling is anything but easy for nontrivial programs. Second, having several 
 threads and 
 synchronized
  blocks might end up in a deadlock: Some thread A waits for 
 thread B while thread B is waiting for thread A. Third, writing too many 
 join
  functions 
 for gathering the threads’ calculation results might result in too many threads just 
 waiting, thwarting the advantages of multithreading. Fourth, using 
 synchronized
  blocks 
 for any collection handling might also end up in too many threads just waiting.
  
 At some point in the history of Java’s evolution, advanced higher level multithreading 
 constructs were introduced, namely the interfaces and classes inside the 
 java.util. 
 concurrent
  package and subpackages. Without claiming completeness in this section, we 
 cover some of these constructs, because they are also included within Kotlin and you can 
 use them to any extent you wish.",NA
 Special Concurrency Collections,"Wrapping any list or set access into 
 synchronized
  blocks just for the sake of proper 
 concurrent accessibility, or 
 thread safety
 , leaves a feeling of discontent. If collections and 
 maps are important for your app, it almost seems like thinking about multithreading is 
 not worth the effort. Fortunately the 
 java.util.concurrency
  package contains some list, 
 set, and map implementations that help to avoid putting everything into a 
 synchronized
  
 block.
  
 • 
 CopyOnWriteArrayList
 : A list implementation where any mutation 
 operations happen on a fresh copy of the complete list. At the same time, 
 any iteration uses exactly the state of the list it had when the iterator got 
 created, so a 
 ConcurrentModificationException
  cannot happen. Copying 
 the complete list is costly, so this implementation usually helps only 
 where reading operations vastly outnumber writing operations. In such 
 cases, however, no 
 synchronized
  blocks are needed for thread safety.
  
 402
  
 www.EBooksWorld.ir",NA
 Locks,"In the section “Basic Multithreading the Java Way” earlier in this chapter, we learned 
 that 
 synchronized
  blocks make sure program parts cannot be worked at the same time 
 by different threads:
  
 val obj = ...
  
 thread {
  
  
  synchronized(obj) {
  
 403
  
 www.EBooksWorld.ir",NA
 Atomic Variable Types,"Consider the following example:
  
 class Counter {
  
  
  var c = 0
  
  
  fun increment() { c++ }
  
  
  fun decrement() { c-- } 
  
 }
  
 Because the runtime engine (Java virtual machine JVM) internally decomposes 
 c++ 
 into (1) get the value of 
 c
 , (2) increment what we just retrieved, and (3) write 
 back the altered value to 
 c
 , the following might happen:
  
 Thread-A calls increment 
  
 Thread-B calls decrement 
  
 Thread-A retrieves c 
  
 Thread-B retrieves c 
  
 Thread-A increments its version of c 
  
 Thread-A updates c, c is now +1 
  
 Thread-B decrements its version of c 
  
 Thread-B updates c, c is now -1
  
  
 The work of thread A therefore got lost entirely. This effect is commonly referred 
 to as 
 thread interference
 .
  
 We saw in the previous section that synchronization via 
 synchronized
  helps:
  
 class Counter {
  
  
  var c = 0
  
  
  fun increment() { synchronized(c){ c++ } }
  
  
 fun decrement() { synchronized(c){ c-- } } }
  
 406
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 The package ,NA,NA
java.util.concurrent.atomic,NA,NA
 has a few more atomic ,NA,NA
types that are for special use cases. have a look at the documentation if ,NA,NA
you are interested.,NA,NA
" Executors, Futures, and Callables","Inside the 
 java.util.concurrent
  package you will find a couple of interfaces and classes 
 that handle multithreading on a higher level. The following list shows the main 
 interfaces and classes important for high-level multithreading.
  
 • 
 Callable
  
 This is something that can be invoked, possibly by another thread, 
 and returns a result.
  
 • 
 Runnable
  
 This one is not in package 
 java.util.concurrent
 , but in package 
 java.lang
 . It is something that can be invoked, possibly by 
  
 another thread. No result is returned.
  
 407
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" This is definitely not the cleverest way to calculate π, but it is ",NA,NA
easy to understand and you can easily distribute the workload among ,NA,NA
multiple threads.,409,NA
 Exercise 1,Implement the multithreaded π calculation app as described in this section.,NA
 Kotlin Coroutines,"Kotlin has its own idea of how to handle multithreading. It uses a concept that has been 
 around for a while in older computer languages, 
 coroutines
 . Here the idea is 
 implemented to write functions that can get suspended and later resumed at certain 
 locations during their inner program flow. This happens in a 
 nonpreemptive
  way, which 
 means during running a program in a multithreaded way the program flow context 
 doesn’t get switched by the operating system, but rather by language constructs, library 
 calls, or both.
  
  
 Coroutines are not by default included within Kotlin. To install them, open the “app” 
 module’s 
 build.gradle
  file and add to the “dependencies” section:
  
 implementation
  
  
  'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.0'
  
 (one line).
  
 Before we continue to discuss coroutines for Kotlin, we first present an extended 
 glossary to help you get used to coroutines programming. You can quickly scan over 
 it or entirely skip it for now and come back later, as after the list we give a more 
 comprehensive introduction to coroutines.
  
 • 
 Coroutine scope:
  Any coroutine functionality runs within a 
  
 coroutine scope
 . A scope is like a bracket around a multithreading 
 ensemble, and scopes can have a parent scope defining a scope 
 hierarchy. The root of the scope hierarchy can either be the 
  
 414
  
 www.EBooksWorld.ir",NA
 Basic Coroutines,"The most important thing to know about coroutines is that we need a 
 coroutine scope 
 before we can use the coroutine way of multithreading. For simplicity it would be nice if 
 we had a construct like this:
  
 openScope {
  
  // Scope now automatically available ...
  
 }
  
 Kotlin knows how to do that by virtue of functions with receivers. Look, for example, 
 at the coroutines-related function 
 runBlocking()
 . In the source code you’ll basically find 
 this:
  
 fun <T> runBlocking(context: CoroutineContext =
  
  
  
  EmptyCoroutineContext,
  
  
  
  block: suspend CoroutineScope.() -> T): T {
  
  
  // code to run block in a blocking thread
  
  ...
  
 }
  
 419
  
 www.EBooksWorld.ir",NA
Caution,NA,NA
 interfaces can have ,NA,NA
val,NA,NA
s. We didn’t mention this feature in the ,NA,NA
"object orientation introductory chapters, and during the runtime engine ",NA,NA
evolution it was primarily introduced for technical reasons. here it gets ,NA,NA
used to make coroutines handling easier. using ,NA,NA
val,NA,NA
s and ,NA,NA
var,NA,NA
s in your ,NA,NA
"app’s interfaces is discouraged though, because variables usually belong ",NA,NA
"to implementation aspects, not to declaration aspects, which is what ",NA,NA
interfaces are for. use variables in interfaces with caution!,"Your options to use an existing scope if we already are running inside a coroutine or 
 to generate a new scope are as follows:
  
 • 
 runBlocking { ... }
  
 This enters a new blocking scope. Blocking here means the 
  
 runBlocking()
  invocation will only return after all activities inside 
 the 
 { ... }
  lambda finished their work. The 
 runBlocking()
  can be 
 started from inside and outside a coroutine scope, although using it 
 from inside a coroutine scope is discouraged. In both cases a fresh 
 context is created that includes using the currently running thread 
 for the job.
  
 • 
 runBlocking(context:CoroutineContext) { ... }
  
 This is the same as 
 runBlocking()
 , but with a base context as 
 given by the parameter.
  
 • 
 GlobalScope
  
 Use of this is discouraged. Use this singleton object if you want 
 to use a scope that is tied to the application itself and its life 
 cycle. You can, for example, use 
 GlobalScope.launch{ ... }
  or 
 GlobalScope.async{ ... }
 . Normally you should start from a 
 runBlocking{ ... }
  instead. Not explicitly using 
 GlobalScope 
 improves the structuring of your app.
  
 420",NA
 Coroutine Context,"A 
 CoroutineContext
  holds the state of the coroutine scope as a set of context elements. 
 Although the 
 CoroutineContext
  does not implement the normal 
 Set
 , 
 List
 , or 
 Map
  
 interface you’d normally use for such cases, you still can get its elements by one of these 
 methods.
  
 • 
 coroutineContext[Job]
  
 This retrieves the 
 Job
  instance that holds the instructions of 
 which the coroutine consists.
  
 • 
 coroutineContext[CoroutineName]
  
 Optionally, this retrieves the name of the coroutine. You can 
 specify the name via 
 coroutineContext + CoroutineName(""My 
 FancyCoroutine"")
  as the first parameter of a coroutine builder 
 (e.g., 
 launch()
  or 
 async()
 ) invocation.
  
 • 
 coroutineContext[CoroutineExceptionHandler]
  
 This is an optional dedicated exception handler. We’ll talk about 
 exceptions later.
  
 • 
 coroutineContext[ContinuationInterceptor]
  
 This internal item holds the object that is responsible for correctly 
 continuing a coroutine after it was suspended and resumes its 
 work.
  
 Although any scope builder like 
 runBlocking()
 , 
 launch()
 , or 
 async()
  spawns a new 
 coroutine context that gets forwarded to other coroutine functions invoked from inside, 
 you can temporarily tweak the context by using
  
 withContext(context: CoroutineContext) {
  
  
 ...
  
 }
  
 As a parameter you are free to build your own context, or use 
 +
  to change 
 dedicated elements of the current context. For example, to temporarily set the 
 coroutine name you’d write
  
 425",NA
 What a ,NA,NA
delay(),NA,NA
 Does,"At first glance the 
 delay(timeMillis:Long)
  function has the same use as the basic 
 Thread.sleep(millis:Long)
  function from the Java way of using concurrency: Let the 
 program flow wait for some time before it can continue with the instructions after the 
 delay()
  or 
 sleep()
  statement. However, there is a major difference between the two: The 
 function 
 Thread.sleep()
  actually blocks the current thread and lets other threads do 
 their work, whereas 
 delay()
  calls a suspending function that does not block the current 
 thread but instead schedules a resumption of the program flow after the specified time 
 elapses.
  
 From a use-case view you use both for the same purpose: to continue with the 
 program flow only after the specified time has elapsed. Knowing that for coroutines the 
 thread does not get blocked, however, helps to tailor concurrency for maximum 
 stability and performance.",NA
 What Is a Suspending Function?,"A suspending function is a function that might or might not execute immediately or be 
 suspended once invocation starts, and then eventually ends. It does not block a thread, 
 even when it or parts of it are suspended.
  
  
 From a coding point of view, you must make your own functions suspendable if you 
 extract functions from a coroutine:
  
 runBlocking {
  
  
  ...
  
  launch {
  
  
  ...
  
  
  } 
  
 }
  
 426
  
 www.EBooksWorld.ir",NA
 Waiting for Jobs,"Dispatching work to several concurrently acting coroutines is one part of the story. First, 
 if the coroutines calculated something, after the coroutines do their work we need to 
 make sure we can gather the results before we continue with the program flow. Second, 
 we must make sure the program as a big state machine is in a consistent state before we 
 can continue doing more work after the coroutines finish. Here we are talking about 
 result gathering
  and 
 concertation
  or 
 synchronization
 .
  
  
 For synchronization, to make sure a 
 Job
  or a 
 Deferred
  has finished its work, use 
 join()
  as in
  
 val job = launch { ... } 
  
 val deferr = async { ... }
  
 job.join() // suspend until job finished 
  
 deferr.join() // suspend until deferr finished
  
 We can do this also for the 
 Deferred
 , because it is a subclass of 
 Job
 . In both cases it 
 ensures that all the coroutine children of the jobs also finished their work. For the 
 Deferred
 , however, we actually want to get the result of the calculation, which leads us 
 to coroutines result gathering. You do so by writing
  
 427
  
 www.EBooksWorld.ir",NA
 Canceling Coroutines,"To cancel any job, invoke the 
 cancel()
  function on the 
 Job
  or 
 Deferred
  object.
  
 val job = launch { ... } 
  
 val deferr = async { ... } 
  
 ...
  
 job.cancel() // or deferr.cancel()
  
  
 Canceling does not mean a job immediately quits its work. Instead it is marked and 
 stops working at a feasible time.
  
 428
  
 www.EBooksWorld.ir",NA
 Timeouts,"You can specify timeouts to instructions inside a coroutine via
  
 withTimeout(1000L) { // milliseconds
  
  
  ...
  
 }
  
  
 This throws a 
 TimeoutCancellationException
  (a subclass of 
 CancellationException
 ) if the timeout limit gets reached, or
  
 429
  
 www.EBooksWorld.ir",NA
 Dispatchers,"A coroutine dispatcher actually tells where and how a job gets run. More precisely, it 
 describes which thread the coroutine runs in and how a thread gets created or looked 
 up (e.g., from a thread pool). You can get hold of the current dispatcher with
  
 coroutineContext[ContinuationInterceptor]
  
 If you don’t want to go with the defaults that a builder like 
 launch()
  or 
 async()
  uses, 
 you can explicitly prescribe a dispatcher. Remember we can give 
 launch()
  or 
 async() 
 the 
 context as a first parameter. If we have a dispatcher, then, we can write
  
 val myDispatcher = ...
  
 runBlocking {
  
  
  val job = launch(coroutineContext + myDispatcher) {
  
  
  ...
  
  
  }
  
  
  job.join() 
  
 }
  
  
 You don’t have to develop such a dispatcher on your own, because some dispatchers 
 are provided by the coroutines library:
  
 • 
 Dispatchers.Default
  
 This is the default dispatcher used if the context does not yet 
 contain a dispatcher. It uses a thread pool with at least two 
  
 430
  
 www.EBooksWorld.ir",NA
 Exception Handling,"During a coroutine’s execution, we basically have three kinds of exceptions, and unless 
 further precautions are taken, the following will happen:
  
 • 
 For
 CancellationException
 exceptions and
 launch()
 : Remember that 
 cancellation exceptions occur when you explicitly invoke 
 cancel()
  on a 
 Job
  element. If a 
 CancellationException
  gets thrown, it will lead to a 
 quitting of the current coroutine, but not to a quitting of any of the 
 parents; they will just ignore it. The hierarchy’s root coroutine will just 
 as well ignore the exception, so outside the coroutine machinery such an 
 exception will not be detected.
  
 • 
 For
 CancellationException
 exceptions and
 async()
 : Other than for 
 launch()
 , a cancellation of a 
 Deferred
  job by invoking 
 cancel()
  on the 
 Deferred
  element will not lead to the exception being ignored. Instead, 
 we must react on the exception, which will show up in the 
 await()
  
 function.
  
 • 
 For
 TimeoutCancellationException
 exceptions
 : If a timeout 
  
 in a 
 withTimeout( timeMillis:Long ) { ... }
  happens, a 
  
 TimeoutCancellationException
  gets thrown. This is a subclass of 
 CancellationException
  and receives no special treatment, so what is 
 true for normal cancellation exceptions holds for timeouts as well.
  
 • 
 Any other exception:
  Normal exceptions lead to an immediate 
  
 quitting of any running job in the coroutines hierarchy, and will also be 
 thrown by the root coroutine. If you expect such an exception, you must, 
 for example, wrap a root 
 runBlocking()
  into a try-catch clause. You can, of 
 course, add try-catch clauses inside the jobs to catch such exceptions 
 early.
  
  
 To see what happens with a cancellation exception and how it gets 
 propagated through the coroutines hierarchy, try the following code:
  
 var l1:Job? = null 
  
 var l11:Job? = null 
  
 var l111:Job? = null
  
 432
  
 www.EBooksWorld.ir",NA
 Exercise 2,"In the preceding example, remove the 
 cancel()
  statement and instead add a timeout of 
 0.5
  seconds to the 
 delay()
  immediately after label 
 E
 . What do you expect? 
 Will
  the 
 logging differ from the logging with the 
 cancel()
  statement?
  
  
 If you want to make sure a passage of the code cannot be canceled despite it 
 containing suspending function calls, you can wrap it into a special new context:
  
 ...
  
 withContext(NonCancellable) {
  
  // uncancellable code here
  
  ...
  
 } 
  
 ...
  
  
 If you need to tailor the exception handling, it is possible to explicitly register an 
 ExceptionHandler
  with a builder invocation:
  
 val handler = CoroutineExceptionHandler {
  
  
 _, exception ->
  
  
  Log.e(""LOG"", ""Caught $exception"") }
  
 runBlocking(handler) {
  
  
  ...
  
 }
  
 435
  
 www.EBooksWorld.ir",NA
CHAPTER 19,NA,NA
Using External ,NA,NA
Libraries,"External libraries are collections of interfaces and classes that are of general use and 
 thus can be reused in various projects. You won’t find many Kotlin libraries yet, but 
 because it is easy for Kotlin to interface with Java classes and interfaces, in your projects 
 you can use one or some of the plethora of Java libraries published by other developers 
 and development teams.
  
 Example fields for external libraries are encoding and decoding, compression, CSV 
 file handling, e-mailers, higher level math and statistics, databases, extended logging 
 facilities, XML and JSON file handling, and many more. You will learn more about XML 
 and JSON in Chapter 
 20
 .
  
 The rest of this chapter talks about ways to add external libraries to your Android 
 project, dives into peculiarities concerning nullability if you add external Java libraries, 
 and describes how to build your own libraries.",NA
 Adding External Libraries,"The first step in adding external libraries is specifying where the libraries come from. 
 The places where libraries can be loaded or included from are called 
 repositories
 . Once 
 you start a new Android project, the project’s build.gradle script contains the 
 repositories at two places, inside the buildscript section and inside the allprojects 
 section:
  
 buildscript {
  
  
  ...
  
  repositories {
  
  
  google()
  
  
  jcenter()
  
  }
  
  ...",NA
Note,NA,NA
 sometimes you also get the gradle syntax. even if it reads compile ,NA,NA
'org.apache.commons:commons-math3:3.2' do not use compile but ,NA,NA
implementation instead. the compile keyword belongs to an older ,NA,NA
version of gradle.,"Android Studio then asks you to synchronize your project. Do so, and after that you 
 can use the new library from inside your code.",NA
 Dependency Management,"Libraries can depend on other libraries. This happens quite often, and it could develop 
 into a real nightmare if we have to manually add all the dependencies a library exposes. 
 Another Apache Commons library called Apache Commons Configuration in version 2.4, 
  
 441
  
 www.EBooksWorld.ir",NA
 Unresolved Local Dependencies,"If you create a new project using Android Studio the first line inside the dependencies 
 section of the module’s build.gradle file reads
  
 fileTree(dir: 'libs', include: ['*.jar'])
  
 This means any .jar file you put into the libs folder will be added as a library to your 
 app. No automatic dependency resolution will happen and you have to download the 
 libraries yourself. This somewhat conflicts with the Maven method of dependency 
 inclusion, so try to avoid using this technique.",NA
 External Libraries and Nullability,"We know that in Kotlin the nullability of properties plays an important role in improving 
 program stability. If we include external Java libraries the story is different. Java as a 
 language does not draw the same precise distinction between nullable and non-nullable 
 variables as Kotlin does. To be able to use external Java libraries, Kotlin assumes all 
 function invocation parameters and function return values to be nullable.
  
 If the API documentation of an external library says a function return value cannot 
 be null, the only way to tell Kotlin about this fact is to use the Elvis operator and 
 throw an exception if the return value is null:
  
 val res = javaObject.function() ?:
  
  
  throw Exception(""Cannot happen"")
  
 442
  
 www.EBooksWorld.ir",NA
 Creating Your Own Library,"You can create a library in whatever way you want, including using the command line 
 or other IDEs such as Eclipse. In this section we cover how to create and use libraries 
 using Android Studio.
  
 In Android Studio, a library project actually is more than just a .jar file that could be 
 included in other projects. It is almost an app on its own because it can include Android 
 configuration files and files that describe the user interface. No one hinders us from 
 using Android libraries just for defining interfaces and classes that could be used from 
 other projects, though.
  
 As an example, we define a library named StringRegex that just extends the String 
 class by an operator function for checking regular expression matches, so we can write
  
 val s = ""The big brown fox jumps over the creek."" val 
 containsOnlyLetters = s % ""[A-Za-z ]*"" 
  
 // -> false because of the "".""
  
  
 For the definition of this extension function we overload the % operator rem(). The 
 code for this reads
  
 package org.foo.stringregex
  
 operator fun String.rem(re:String):Boolean =
  
  
 this.matches(Regex(re))
  
 where for the package you could, of course, use something different.
  
 We first start a new library project in Android Studio. To do so go to File 
 ➤
  New 
 ➤
 New Project and select Add No Activity. As a project name, enter StringRegexApp, and 
 as a package name enter org.foo.stringregex. As a Save location, enter whatever you like. 
 Make you have Kotlin selected as the Language setting, and as a Minimum API level 
 select anything that seems appropriate to you. Inside the new Android Studio project 
 window that then opens go to File 
 ➤
  New 
 ➤
  New Module. Select Java Library. Enter 
 StringRegex as the Library name. The other settings are not important here. The Project 
 view will now look similar to Figure 
 19-1
 .
  
 443
  
 www.EBooksWorld.ir",NA
Note,NA,NA
 For android studio 3.3 there is a bug in the Kotlin configuration ,NA,NA
wizard. inside the stringregex module’s build.gradle file you might ,NA,NA
have to comment out the plug-in version inside plugins:,NA,NA
id 'org.jetbrains.kotlin.jvm' //version '1.3.20',"Open the stringregex file and enter the extension function code shown in the 
 preceding listing. You can now close the window, as we will be making a reference to it 
 from a client project.
  
  
 From any app open in Android Studio, you can choose one of the apps we created for 
 this book, open the settings.gradle file, and add two statements.
  
 include ':StringRegex' 
  
 project(':StringRegex').projectDir =
  
  
  new File('../StringRegexApp/StringRegex')
  
 444
  
 www.EBooksWorld.ir",NA
CHAPTER 20,NA,NA
XML and JSON,"In Chapter 
 19
  we learned how to include external libraries in our Android projects. 
 Kotlin doesn’t have dedicated XML and JSON processing classes included in its standard 
 library, so to achieve XML- and JSON-related tasks we use appropriate external libraries 
 and add some convenience functions in the form of extension functions.",NA
Note,NA,NA
 Both XML and JSON are format specifications for structured data. ,NA,NA
You will frequently use them if your Android app communicates with ,NA,NA
the outside world for receiving or sending data in a standardized ,NA,NA
format.,"This chapter assumes you have a sample app you can use to test the code snippets 
 provided. Use whatever app you like or one of the apps we developed in this book. You 
 could, for example, add some sample code providing Log output for testing inside the 
 activity’s onCreate() function, or you could use a test class using one of Android’s test 
 methodologies. Choose a method that best suits your needs.",NA
 XML Processing,"XML files are at their simplest files of a form similar to this:
  
 <?xml version=""1.0"" encoding=""UTF-8""?> 
  
 <ProbeMsg>
  
  
  <TimeStamp>2016-10-30T19:07:07Z</TimeStamp>
  
  <ProbeId>1A6G</ProbeId>
  
  
  <ProbeValue ScaleUnit=""cm"">37.4</ProbeValue>
  
 © Peter Späth 2019 
  
 447
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8_20",NA
Note,NA,NA
 XML allows for more elaborate constructs like schema validation ,NA,NA
"and namespaces. In this chapter we only describe XML tags, attributes, ",NA,NA
and text contents. You are free to extend the samples and utility ,NA,NA
functions presented in this chapter to also include such extended ,NA,NA
features.,"For XML processing one or a combination of the following paradigms gets used.
  
 • 
 DOM Model: Complete tree handling:
  In the Document Object Model 
 (DOM) the XML data get treated as a whole represented by an in- 
 memory, tree-like structure.
  
 • 
 SAX: Event-based processing:
  Here an XML file gets parsed and with each 
 element or attribute an appropriate event is fired. The events are received 
 by callback functions that have to be registered with the SAX processor. 
 Such a “tell me what you are doing” style of processing is commonly called 
 push parsing
 .
  
 • 
 StAX: Stream-based processing:
  Here you perform operations like “Give 
 me the next XML element” and the like. In contrast to SAX, where we 
 have a push parsing, for StAX we tell the parser what it has to do: “I tell 
 you what you do.” This therefore is called 
 pull parsing
 .
  
 On Android you typically handle small to medium-size XML files. For this reason in 
 this chapter we use the DOM. For reading, we first parse the complete XML file and store 
 the data in a DOM tree in memory. Here operations on them like deleting, changing, or 
 adding elements are easy to accomplish and happen in memory; thus they are very fast. 
 For writing we take the complete DOM tree from memory and generate an XML 
 character stream from it, perhaps writing the result back to a file.
  
 448",NA
Note,NA,NA
" Xerces also implements the SAX and StAX ApIs, although we will ",NA,NA
use only its dOM implementation.,NA,NA
 Reading XML Data,"The DOM implementation we can use by virtue of the Xerces implementation already 
 contains everything needed to read XML elements. We will, however, add a couple of 
 extension functions that greatly improve the DOM API’s usability. For this aim, create a 
 package com.example.domext, or you can also use any other suitable package name. Add 
 a Kotlin file dom.kt inside this package, and as its contents write:
  
 package com.example.domext
  
 import org.apache.xerces.parsers.DOMParser import 
 org.w3c.dom.Document 
  
 import org.w3c.dom.Node 
  
 import org.xml.sax.InputSource 
  
 import java.io.StringReader 
  
 import java.io.StringWriter 
  
 import javax.xml.transform.OutputKeys 
  
 import javax.xml.transform.TransformerFactory 
 import javax.xml.transform.dom.DOMSource 
  
 import javax.xml.transform.stream.StreamResult
  
 fun parseXmlToDOM(s:String) : Document {
  
  val 
 parser: DOMParser = DOMParser()
  
  
  return parser.let {
  
   
  it.parse(InputSource(StringReader(s)))
  
  
  it.document
  
  
  } 
  
 }
  
 449
  
 www.EBooksWorld.ir",NA
Caution,NA,NA
" For simplicity, the code snippets shown in this section ",NA,NA
for dOM processing do not handle exceptions in a sensible ,NA,NA
manner. You must add appropriate error handling before using ,NA,NA
the code for production projects.,"This snippet provides examples of how to use the API and the extensions.
  
 import ...
  
 import com.example.domext.*
  
 ...
  
 val xml = """"""<?xml version=""1.0"" encoding=""UTF-8""?>
  
  <ProbeMsg>
  
   
  <TimeStamp>2016-10-30T19:07:07Z</TimeStamp>
   
  <ProbeId>1A6G</ProbeId>
  
   
  <ProbeValue ScaleUnit=""cm"">37.4</ProbeValue>
  
  <Meta>
  
   
  <Generator>045</Generator>
  
   
  <Priority>-3</Priority>
  
   
  <Actor>P. Rosengaard</Actor>
  
  
  </Meta> 
  
 </ProbeMsg>""""""
  
 try {
  
  // Parse the complete XML document val 
 dom = parseXmlToDOM(xml)
  
  // Access an element
  
  val ts = dom(""ProbeMsg"")(""TimeStamp"").text() 
 Log.d(""LOG"", ts) // 2001-11-30T09:08:07Z
  
 452",NA
 Altering XML Data,"Once we have a DOM representation of an XML tree in memory, we can add elements. 
 Although we could use the functions already provided by the DOM API, Kotlin allows us 
 to improve the expressiveness. For this purpose, add the following code to our extension 
 file dom.kt (I don’t add new imports; press Alt+Enter to let Android Studio help you add 
 necessary imports):
  
 fun prettyFormatXml(document:Document): String {
  
  
  val format = OutputFormat(document).apply { lineWidth = 65
  
  
  indenting = true
  
   
  indent = 2
  
  
  }
  
  
  val out = StringWriter()
  
  
  val serializer = XMLSerializer(out, format)
  
  
  serializer.serialize(document)
  
  
  return out.toString() 
  
 }
  
 453
  
 www.EBooksWorld.ir",NA
 Creating New DOMs,"If you need to write a DOM representation of an XML document from scratch, first create 
 a Document instance. This one does not have a public constructor; instead you write:
  
 val doc = DocumentBuilderFactory.
  
  newInstance().newDocumentBuilder().newDocument()
  
 From there you can add elements as described previously. Note that to see any 
 output from our prettyFormatXml() utility function you must add at least one child 
 element to doc.",NA
 Exercise 1,Add a createXmlDocument() function to the dom.kt file to simplify document creation.,NA
 JSON Processing,"JavaScript Object Notation (JSON) is the little sister of XML. Data written in the JSON 
 format require less space compared those same data using the XML format. In addition, 
 JSON data almost naturally map to JavaScript objects in a browser environment and 
 JSON therefore has gained considerable attention during recent years.
  
 Kotlin’s standard library doesn’t know how to handle JSON data, so, similar to XML 
 processing, we add a suitable external library. From several possibilities we use the 
 widely adopted Jackson library. To add it to an Android project, inside the module’s 
 build.gradle file in the dependencies section add
  
 implementation
  
  
  'com.fasterxml.jackson.core:jackson-core:2.9.8' 
 implementation
  
  
  'com.fasterxml.jackson.core:jackson-databind:2.9.8'
  
 (on two lines, remove the line breaks).
  
 Several paradigms exist for JSON processing. The most commonly used are a tree-
 like structure with JSON-specific objects, and a mapping between Kotlin and JSON 
 objects with various semiautomatic conversion mechanisms. We leave the mapping 
 methodology for your further research; it contains a couple of highly involved 
  
 458
  
 www.EBooksWorld.ir",NA
 JSON Helper Functions,"The Jackson library for JSON processing contains all that is needed to write, update, and 
 delete JSON elements. The library is quite extensive and contains an enormous amount 
 of classes and functions. To simplify the development and to include Kotlin goodies we 
 use a couple of package-level functions and extension functions to improve the JSON 
 code readability. These are best located in a Kotlin file json.kt inside some package 
 com.whatever.ext.
  
 We start with the imports, add an invoke operator so we can easily fetch a child from 
 a node, and add a remove and a forEach function for removing a node and traversing 
 through the children of a node:
  
 import com.fasterxml.jackson.core.JsonFactory 
  
 import com.fasterxml.jackson.core.util.DefaultPrettyPrinter import 
 com.fasterxml.jackson.databind.JsonNode 
  
 import com.fasterxml.jackson.databind.ObjectMapper
  
 459
  
 www.EBooksWorld.ir",NA
 Reading and Writing JSON Data,"To read in JSON data, all you have to do is to write:
  
 val json = ... // see section beginning val 
 mapper = ObjectMapper() 
  
 val root = mapper.readTree(json)
  
  
 From here we can investigate JSON elements, iterate through and fetch JSON object 
 members, and extract JSON array elements:
  
 try {
  
  val json = ... // see section beginning val 
 mapper = ObjectMapper()
  
  val root = mapper.readTree(json)
  
  // see what we got
  
  Log.d(""LOG"", root.toPrettyString())
  
  // type of the node
  
  Log.d(""LOG"", root.nodeType.toString()) // <- 
 OBJECT
  
  // is it a container?
  
 464
  
 www.EBooksWorld.ir",NA
 Creating New JSON Trees,"To create a new JSON tree in memory you use:
  
 val root = jsonObjectNodeOf()
  
 From there you can add JSON elements as described previously.",NA
 Exercise 2,"Create a JSON document corresponding to:
  
 {
  
  ""firstName"": ""Arthur"",
  
  ""lastName"": ""Doyle"",
  
  ""dateOfBirth"": ""03/04/1997"",
  
  ""address"": {
  
 466
  
 www.EBooksWorld.ir",NA
 Appendix,NA,NA
 Solutions to the Exercises,The following are the solutions to the exercises given in the chapters.,NA
 Chapter ,NA,NA
2,"Exercise 1:
  Only (2) is correct. Version (1) uses round brackets for the body, but 
 curly brackets are needed. Version (3) is technically correct but does not use 
 camelcase notation for the class name, and Version (4) tries to use a space in the class 
 name.
  
 Exercise 2:
  Only (4) is correct. Version (1) uses an undefined “variable” keyword. 
 Version (2) uses an undefined “property” keyword. Version (3) does not yield to the 
 propertyName:PropertyType property notation. Version (5) does not specify a 
 mutability keyword (var or val).
  
 Exercise 3:
  A val corresponds to an immutable (unchangeable) variable. Setting it to 
 0.0 means it will never have a different value, which makes no sense for an invoice. This 
 can be fixed by using var instead of val.
  
 Exercise 4:
  It is not allowed to change a val property. The property gets first set 
 by the parameter declaration part of the class declaration and cannot be changed 
 afterward.
  
  
 Exercise 5:
  The property blue must be initialized as well, either in the 
 property declaration or inside the init{ } block.
  
 Exercise 6:
  The class reads:
  
 class Invoice(val buyerFirstName:String, val 
 buyerLastName:String,
  
  val date:String,
  
  val goodName:String,
  
 © Peter Späth 2019 
  
 469
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8",NA
 MainActivity.kt,"package kotlinforandroid.book.numberguess
  
 import android.content.Context 
  
 import android.support.v7.app.AppCompatActivity 
  
 import android.os.Bundle 
  
 import android.util.AttributeSet 
  
 import android.util.Log 
  
 import android.view.View 
  
 import android.widget.ScrollView 
  
 import android.widget.TextView 
  
 import kotlinforandroid.book.numberguess.common.Constants 
  
 import kotlinforandroid.book.numberguess.model.GameUser 
  
 import kotlinforandroid.book.numberguess.random.RandomNumberGenerator 
 import kotlinforandroid.book.numberguess.random.impl.StdRandom 
  
 import kotlinx.android.synthetic.main.activity_main.* 
  
 import java.util.*
  
 class MainActivity : AppCompatActivity() {
  
  val rnd: RandomNumberGenerator = StdRandom() 
 // or ... = RandomRandom()
  
  var started = false var number = 0
  
  var tries = 0
  
 476
  
 www.EBooksWorld.ir",NA
 Constants.kt,"package kotlinforandroid.book.numberguess.common
  
 object Constants {
  
  
  val LOWER_BOUND = 
 1
  
  
  val UPPER_BOUND = 7 
  
 }",NA
 Console.kt,"package kotlinforandroid.book.numberguess.gui
  
  import android.content.Context
  
  import android.util.AttributeSet
  
  import android.widget.ScrollView
  
  import android.widget.TextView
  
  class Console(ctx: Context, aset: AttributeSet? = null) :
  
  
  
 ScrollView(ctx, aset) {
  
  
  companion object {
  
  
   
  val BACKGROUND_COLOR = 0x40FFFF00
  
  
   
  val MAX_LINES = 100
  
 479",NA
 GameUser.kt,"package kotlinforandroid.book.numberguess.model
  
 class GameUser(val firstName:String,
  
  
  val lastName:String,
  
 480
  
 www.EBooksWorld.ir",NA
 RandomNumberGenerator.kt,"package kotlinforandroid.book.numberguess.random 
 interface RandomNumberGenerator {
  
  
  fun rnd(minInt:Int, maxInt:Int):Int 
  
 }",NA
 RandomRandom.kt,"package kotlinforandroid.book.numberguess.random.impl
  
 import kotlinforandroid.book.numberguess.random.
  
  
 RandomNumberGenerator 
  
 import java.util.*
  
 class RandomRandom : RandomNumberGenerator {
  
  
  val rnd: Random = Random()
  
  
  override fun rnd(minInt: Int, maxInt: Int):Int {
  
  
  
 val span = maxInt - minInt + 1
  
  
  
  return minInt + rnd.nextInt(span)
  
  
  } 
  
 }",NA
 StdRandom.kt,"package kotlinforandroid.book.numberguess.random.impl
  
 import kotlinforandroid.book.numberguess.random.
  
  
 RandomNumberGenerator
  
 class StdRandom : RandomNumberGenerator {
  
  
  override fun rnd(minInt: Int, maxInt: Int):Int {
  
  
  
 val span = maxInt - minInt + 1
  
 481
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
3,"Exercise 1:
  The var or val in the constructor parameter is missing, so the color is not 
 transported to a property. In this case we have to use var, because we want to change 
 it:
  
 class Triangle(var color: String) {
  
  fun 
 changeColor(newColor:String) {
  
  
  color = newColor
  
  
  } 
  
 }
  
 Exercise 2:
  The code reads:
  
 class A {
  
  
  var a:Int = 1 // A
  
  
  init {
  
  
  
  a = 2     // B
  
  
  }
  
  
  fun b() {
  
  
  
  a = 3     // C
  
  
  } 
  
 } 
  
 fun main(args:Array<String>) {
  
  
  val a = A()
  
  
  a.a = 4        // D 
  
 }
  
 Exercise 3:
  Write
  
 val a = 42 
  
 val s = ""If we add 4 to a we get ${a+4}""
  
 482",NA
 Chapter ,NA,NA
4,"Exercise 1:
  Write
  
 package com.example.util
  
 fun add10(a:Int) = a + 10 
  
 fun add100(a:Int) = a + 100
  
  
 Maybe rename the file util.kt to avoid the impression that it contained a class or a 
 singleton object. The file name, in fact, no longer plays a role.
  
 The client code then reads:
  
 package com.example
  
 import com.example.util.*
  
 class A(q:Int) {
  
  
  val x10:Int = add10(q)
  
  
  val x100:Int = add100(q) 
  
 }
  
 Exercise 2:
  Write
  
 package com.example 
  
 import java.lang.Math.log 
  
 class A {
  
  
  fun calc(a:Double) = log(a) 
  
 }
  
 Exercise 3:
  (1) is not true, as the coordinates x and y cannot be swapped. (2) is 
 not true, because the classes don’t match. (3) is true, because the extracted x 
 coordinates match. (4) is true, because the 1 automatically gets converted to 1.0 and 
 after that all coordinates match. (5) is true, as the class and all coordinates match.
  
  
 Exercise 4:
  The GameUser class is a good candidate for a data class. Just 
 prepend data to the class declaration: data class GameUser ....
  
 486
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
5,"Exercise 1:
  The code reads:
  
 Math.sqrt(
  
  
  ( a + (b-x)/2 ) / ( b*b - 7*x ) 
  
 )
  
 You can also use Math.pow(b, 2.0) instead of b * b 
 Exercise 2:
  Write
  
 class Concatenator {
  
  
  var string:String = """"
  
  
  fun add(s:String) { string += s }
  
  
  operator fun contains(other:String) =
  
  
  string.contains(other) 
  
 }",NA
 Chapter ,NA,NA
6,"Exercise 1:
  Texts and formatting are up to you.",NA
 Chapter ,NA,NA
8,"Exercise 1:
  The exception class reads:
  
 package kotlinforandroid.book.numberguess.common
  
 class GameException(msg:String) : Exception(msg)
  
 The guess() function inside class MainActivity with the check added reads:
  
 fun guess(v:View) {
  
  
  if(num.text.toString() == """") return
  
  try {
  
  
  if (num.text.toString().toInt() <
  
   
  
  Constants.LOWER_BOUND)
  
   
  throw GameException(
  
 489
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
9,"Exercise 1:
  The code reads:
  
 val arr = IntArray(101, { i -> 100 - i })
  
 Exercise 2:
  The code reads:
  
 booleanArrayOf(true, false, true)
  
 Exercise 3:
  The code reads:
  
 val fruits = mutableSetOf(""Apple"", ""Banana"",
  
  
 ""Grape"", ""Engine"") 
  
 fruits.remove(""Engine"") 
  
 fruits.add(""Cherry"") 
  
 val fruits5 = fruits.filter {
  
  
  element -> element.length == 5 
  
 }
  
 490
  
 www.EBooksWorld.ir",NA
Note,NA,NA
" in Kotlin you can remove the round brackets from ({ ... }). Also, ",NA,NA
you can substitute the element with any other name you like.,"Exercise 4:
  You could write
  
 val sorted = gul.sortedWith(
  
  
  compareBy(GameUser::lastName)
  
  
  
  then
  
  
  compareBy(GameUser::firstName))
  
 Or, to be a little bit less expressive:
  
 val sorted = gul.sortedWith(
  
  
  compareBy(GameUser::lastName,
  
  
  
  GameUser::firstName))
  
 Exercise 5:
  The code reads:
  
 gul.sortWith(
  
  
  compareBy(GameUser::lastName)
  
  
  
  then
  
  
  compareBy(GameUser::firstName))
  
 or
  
 gul.sortWith(
  
  
  compareBy(GameUser::lastName,
  
  
  
  GameUser::firstName))
  
 Exercise 6:
  The code reads:
  
 val groupedByManufacturer = cars.groupBy {
  
  car 
 -> car.vin.substring(0,3) 
  
 } 
  
 val wxxCars = groupedByManufacturer[""WXX""]
  
 Exercise 7:
  The code reads:
  
 (1..100).toList().reduce{ acc,v -> acc*v }
  
 491
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
11,"Exercise 1:
  (1) and (3) are true, and (2) is only true in cases where we implemented 
 an appropriate equals() function.
  
 Exercise 2:
  (1) and (2) are true. (3) is true only if function hashCode() is 
  
 implemented appropriately. However, for == to work correctly, a hashCode() 
  
 implementation is not needed. It 
 should
  be provided, though, to avoid surprises if a class 
 gets used as a map key.",NA
 Chapter ,NA,NA
12,"Exercise 1:
  One possible solution would be:
  
 val f : (String, Int) -> String =
  
  
  { s:String, num:Int ->
  
  
  
  (1..num).map { s }.joinToString { it } }
  
 We use the range operator .. to get something that iterates num times over 
 whatever, map each iteration to the parameter string, and then concatenate the num 
 identical copies of the string.
  
 492
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
13,"Exercise 1:
  The code reads:
  
 class Quadruple<A,B,C,D>(
  
  
  var p1:A, var p2:B, var p3:C, var p4:D) val q1 = 
 Quadruple(1, 2, 3.14, ""Hello"")
  
 The type and property parameter names, of course, are up to you. 
 Note that we could have written this:
  
 class Quadruple<A,B,C,D>(
  
  
  var p1:A, var p2:B, var p3:C, var p4:D) val 
 q1:Quadruple<Int, Int, Double, String> =
  
  
 Quadruple<Int, Int, Double, String>(
  
  1, 2, 3.14, 
 ""Hello"")
  
  
 but the explicit type parameters could be omitted because Kotlin can infer the type 
 from the literals provided.
  
 Exercise 2:
  The code reads:
  
 class Sorter<T : Comparable<T>> {
  
  
  val list: MutableList<T> = mutableListOf()
  
  fun 
 add(value:T) {
  
  
  
  list.add(value)
  
  
  
  list.sort()
  
  
  } 
  
 }
  
 493
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
14 ,"Exercise 1:
  The annotation declaration reads: 
  
 @Target(AnnotationTarget.VALUE_PARAMETER) 
  
 @Retention(AnnotationRetention.RUNTIME) 
  
 annotation class NotNegative() 
  
  
  
 Inside the Calculator.Operator enumeration, add SQRT(”sqrt”) 
  
  
 Inside the f?.valueParameters?.forEachIndexed { ... loop, add 
 p.findAnnotation<NotNegative>()?.run {
  
  
  if (params[ind] < 0.0)
  
  
   
  throw RuntimeException(
  
  
   
  ""Parameter ${ind} must be positive"") 
  
 } 
  
  
  
 Finally, add a function: 
  
 fun sqrt(@NotNegative p:Double) : Double {
  
  
  return Math.sqrt(p) 
  
 }",NA
 Chapter ,NA,NA
16 ,"Exercise 1:
  Write 
  
 val sorted = l.sortedBy { empl -> empl.ssn } or 
  
 val sorted = l.sortedBy { it.ssn } 
  
  
 Exercise 2:
  Let it read 
  
 val map = l.associateBy { empl -> empl.ssn } or 
  
 val map = l.associateBy { Employee::ssn }
  
 494
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
17,"Exercise 1:
  There are several possibilities. We save the “now” instant on creation 
 and deduce a Duration object with twice the elapsed time since that instant:
  
 class  ClockTwiceAsFast : Clock() {
  
  
  val myStartInstant : Instant
  
  
  init {
  
  
  
  myStartInstant = Clock.systemUTC().instant()
  
  }
  
  override
  
  fun withZone(zone: ZoneId?): Clock = this 
 override
  
  fun getZone(): ZoneId = ZoneId.of(""Z"")
  
 495
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
18,"Exercise 1:
  Start creating the app as a “Basic Activity” app. Android Studio then 
 builds a standard activity_main.xml file. The actual user interface elements get 
 defined in content_main.xml:
  
 <?xml version=""1.0"" encoding=""utf-8""?> 
  
 <LinearLayout
  
  
  xmlns:android=
  
  
  
  ""http://schemas.android.com/apk/res/android""
  
  
 xmlns:tools=
  
  
  
  ""http://schemas.android.com/tools""
  
  
  xmlns:app=
  
  
  
  ""http://schemas.android.com/apk/res-auto""
  
  
 android:orientation=""vertical""
  
  
  android:layout_width=""match_parent""
  
  
  android:layout_height=""match_parent""
  
  
  app:layout_behavior=
  
  
  
  ""@string/appbar_scrolling_view_behavior""
  
  
 tools:showIn=""@layout/activity_main""
  
  
  tools:context="".MainActivity"">
  
 496
  
 www.EBooksWorld.ir",NA
 Chapter ,NA,NA
20,"Exercise 1:
  Write
  
 fun createXmlDocument(): Document =
  
  
  DocumentBuilderFactory.newInstance().
  
  newDocumentBuilder().newDocument()
  
 Exercise 2:
  A possible solution would be:
  
 val root = jsonObjectNodeOf() 
  
 with(root) {
  
  
  put(""firstName"", ""Arthur"")
  
  
  put(""lastName"", ""Doyle"")
  
  
  put(""dateOfBirth"", ""03/04/1997"")
  
  
  put(""address"",
  
  
  
  jsonObjectNodeOf(
  
  
  
  
  ""streetAddress"" to ""21 3rd Street"",
  
  
  
  ""city"" to ""New York"",
  
  
  
  
  ""state"" to ""NY"",
  
  
  
  
  ""postalCode"" to ""10021-1234""))
  
  
  put(""phoneNumbers"",
  
  
  
  jsonArrayNodeOf(
  
  
  
  
  jsonObjectNodeOf(""type"" to ""home"",
  
  
  
  
  ""number"" to ""212 555-1234""),
   
  
  jsonObjectNodeOf(""type"" to ""mobile"",
  
  
  
  
  ""number"" to ""123 456-7890"")
  
  
  
  ))
  
  
  put(""children"", jsonEmptyArrayNode())
  
  
  putNull(""spouse"") 
  
 } 
  
 Log.d(""LOG"", root.toPrettyString())
  
 500
  
 www.EBooksWorld.ir",NA
Index,NA,NA
A,"abs() function, 
 348 
  
 add() functions, 
 95,275,282 
 Aggregators function, 
 331–332 
 Android device, 
 3–4 
  
 Android Studio 
  
  
 adding external libraries 
  
  
  
 parameterized form, 
 440 
  
  
 repositories, 
 437–439 
  
  
 library creation, 
 443–445 
  
  
 nullability, 
 442 
  
 Annotations 
  
  
 applications, 
 296–297 
  
  
 array, 
 297 
  
  
 characteristics, 
 292–294 
  
  
 custom, 
 302–304 
  
  
 elements, 
 298–300 
  
  
 KAPT, 
 298 
  
  
 meta-information, 
 289–291 
  
 operator classes, 
 291 
  
  
 operator() function, 
 304 
  
  
 reflection API, 
 298 
  
  
 use-site targets, 
 294–295 
  
 Anonymous classes, 
 113 
  
 Any.notifyAll() function, 
 401 
 Any.notify() function, 
 401 
  
 Any.wait() function, 
 401 
  
 Apache Commons library, 
 441 
 API level 25 or less, 
 349–352 
  
 API level 26 or greater
  
  
 clock, 
 366–367 
  
  
 Duration and Period classes, 
 362–365 
  
 instants, 
 357 
  
  
 LocalDate, 
 353–356 
  
  
 LocalDateTime, 
 353–356,360–362 
  
  
 LocalTime, 
 353–356 
  
  
 minSdkVersion, 
 353 
  
  
 OffsetDateTime, 
 358–359 
  
  
 OffsetTime, 
 358–359 
  
  
 ZonedDateTime, 
 360–362 
  
 Application programming interface (API) 
  
  
 documentation, 
 166 
  
 Array 
  
  
 collections 
  
  
  
 lists, 
 200,205–211 
  
  
  
 maps, 
 201,212–214 
  
  
  
 sets, 
 200–204 
  
  
 constructors, 
 196–197 
  
  
 empty array of object references, 
 198 
  
 folding, 
 223–224 
  
  
 grouping, 
 222–223 
  
  
 lambda function, 
 196–197 
  
  
 null object references, 
 198 
  
  
 objects, 
 193–195 
  
  
 operations, 
 198–200 
  
  
 reducing, 
 224–225 
  
  
 sorting, 
 217–220 
  
  
 zipping, 
 225–227 
  
 async() function, 
 416,422 
  
 atan2() function, 
 348 
  
 await() function, 
 421,428,432
  
 © Peter Späth 2019 
  
 501
  
 P. Späth, 
 Learn Kotlin for Android Development
 , 
 https://doi.org/10.1007/978-1-4842-4467-8
  
 www.EBooksWorld.ir",NA
B,"Binary operations, 
 131 
  
 Bits, 
 147 
  
 Boolean expressions, 
 141 
 Bytes, 
 146
  
  
 traversing, 
 321 
  
 Command line, 
 12–14 
  
 Comments 
  
  
 advantages, 
 155 
  
  
 API documentation, 
 166 
  
 class, 
 162",NA
C,"disadvantages, 
 155 
  
 functions and properties, 
 165
  
  
 calc() function, 
 413 
  
 cancel() function, 
 428 
  
 Character expression elements, 
 146 
 childCount() function, 
 451 
  
 Classes, 
 313–315 
  
  
 benefits, 
 107 
  
  
 encapsulation, 
 105 
  
  
 if statement 
  
  
  
 companion objects, 
 52 
  
  
  
 singleton objects, 
 49 
  
  
  
 start() function, 
 51 
  
  
 self-reference (This), 
 110 
  
  
 strings conversion, 
 111 
  
  
 visibility of, 
 104 
  
 Clock class, 
 366 
  
 ClockTwiceAsFast class, 
 495 
  
 Collection and map 
  
  
 characteristics, 
 320 
  
  
 deterministic getters, 
 318–320 
  
  
 element checks, 
 329 
  
  
 filtering, 
 327–328 
  
  
 finding elements, 
 329–330 
  
  
 mutators, 
 317–318 
  
  
 transformations 
  
  
  
 association, 
 326 
  
  
  
 changing mode, 
 328 
  
  
  
 flattening, 
 325 
  
  
  
 keys and values, extraction, 
 322 
  
  
 mapping, 
 322,327 
  
  
  
 reordering, 
 323–325
  
 502
  
  
 markdown files, 
 157,159 
  
  
 multiline, 
 162 
  
  
 package, 
 156 
  
  
 project files view, 
 157 
  
  
 verbose commenting, 
 156 
  
 Companion objects, 
 52–54 
  
 Console class, 
 479–480 
  
 Constants class, 
 66,479 
  
 Constructors, 
 196–197 
  
  
 invocation, 
 43 
  
  
 modifiers, 
 42 
  
  
 named parameters, 
 44 
  
  
 parameters, 
 41 
  
  
 primary constructors, 
 41 
  
  
 secondary constructors, 
 46 
  
 Contravariance, 
 281 
  
 Conversions, 
 150–153 
  
 Coroutines 
  
  
 async() function, 
 422,424 
  
  
 await() function, 
 421 
  
  
 blocking, 
 418 
  
  
 builder, 
 416 
  
  
 cancellation, 
 417,428–429 
  
  
 channel, 
 419 
  
  
 context, 
 415,425–426 
  
  
 coroutineScope() function, 
 421 
  
 delay() function, 
 418,426 
  
  
 dispatchers, 
 418,430–431 
  
  
 exception handling, 
 417,432–436 
  
 global scope, 
 415",NA
D,"Data classes, 
 118–119 
  
 Data containers 
  
  
 loops, 
 215–216 
  
  
 pairs and triples, 
 214–
 215
  
  
 ubiquity of, 
 138 
  
  
 unclassified expressions, 
 137–138 
 exractTo() function, 
 282 
  
 Extensions 
  
  
 encapsulation, 
 127 
  
  
 functions, 
 125
  
  
 Date class, 
 350 
  
 Declaration-side 
  
 hasLength() extension, 
 127 
  
 nullable receivers, 
 127
  
 variance, 
 278–280 
  
 properties, 
 126
  
 Decoupling, 
 272 
  
 static features, 
 125
  
 delay() function, 
 429
  
 Delegation, 
 134–135 
  
 Deprecated annotation, 
 301",NA
F,"Document Object Model (DOM) model, 
 448
  
 fetchChildren() function, 
 451 
 File class, 
 376",NA
E,"FileTreeWalk class, 
 370 
  
 Filters, 
 271–273
  
  
 Elvis operator, 
 191,251,442 
  
 Emulators, 
 6–8 
  
 enum class, 
 386 
  
 Enumerations, 
 120–122 
  
 equals() function, 
 254–255,492
  
 First-in, first-out (FIFO), 
 231 
  
 Fixed-size collections, 
 see
  Array 
  
 Folding function, 
 334 
  
 forEach() function, 
 177,216,267,451 
 forEachIndexed() function, 
 267
  
 Exceptions 
  
 Functional programming, 
 259–260
  
 e() function, 
 187 
  
 features, 
 262–264
  
 error-handling, 
 188
  
 vs.
  imperative programming, 
 261 
  
  
 50
 3",NA
G,"GameUser class, 
 480,486–487 
  
 generateSequence() function, 
 340–341 
 Generator functions, 
 315–317 
  
 Generics, 
 275 
  
  
 compile-time constructs, 
 276 
  
  
 constraints, 
 284–287 
  
  
 functions, 
 283–284 
  
  
 type parameters, 
 276–277 
  
 get(i:Int) function, 
 451 
  
 getCompleted() function, 
 428 
  
 getFirst() function, 
 311 
  
 getLast() function, 
 311 
  
 getState() function, 
 28 
  
 GregorianCalendar class, 
 350 
  
 Grouping functions, 
 336–337 
  
 guess() function, 
 40,489",NA
H,"hashCode() function, 
 256–258,492 
 HelloKotlin app 
  
  
 emulated devices screen, 
 11–12 
  
 emulator window, 
 11 
  
  
 graphical design, 
 10 
  
  
 layout, 
 9 
  
 Higher order functions, 
 259
  
  
 overriding properties, 
 100 
  
  
 superclass assets, 
 101 
  
 Inline function, 
 269–271 
  
 Inner classes, 
 115–116 
  
 Input and output 
  
  
 copyTo() function, 
 375–376 
  
  
 file 
  
  
  
 append text, 
 371 
  
  
  
 creation, 
 368 
  
  
  
 deletion, 
 373–374 
  
  
  
 listing directories, 
 369–370 
  
  
  
 read, 
 372–373 
  
  
  
 (/) system separator, 
 368–369 
  
  
 internet URL, 
 377–378 
  
  
 temporary files, 
 375 
  
 Instantiation, 
 26 
  
 Integrated development environment 
 (IDE) 
  
 Android Studio, 
 1–3 
  
  
 command line, 
 12–14 
  
  
 emulators, 
 6–8 
  
  
 HelloKotlin app, 
 8–12 
  
 Interfaces, 
 309–312 
  
 Invoice class 
  
  
 complete class, 
 30 
  
  
 functions, 
 27 
  
  
 initialization, 
 25 
  
  
 Kotlin, 
 24 
  
  
 properties, 
 25",NA
I ,NA,NA
J,"Identity operator (===), 
 253 
  
 JavaScript Object Notation (JSON) 
  
 Immutable collections, 
 281 
  
 processing, 
 458
  
 Imperative programming, 
 259,260 
 504
  
 add() function, 
 461",NA
K,"KClass, 
 379 
  
 Kotlin programming, object orientation, 
  
 see
  Object orientation 
  
  
 programming",NA
L,"Lambda functions, 
 196–197,215,262, 
  
 265–266 
  
 Last-in, first-out (LIFO), 
 231 
  
 launch() function, 
 416 
  
 list.toMutableList() function, 
 328 
  
 Literals, 
 76–79 
  
 LocalDate class, 
 353 
  
 LocalDateTime class, 
 353 
  
 LocalTime class, 
 353 
  
 Local variables, 
 102–103
  
  
 local functions, 
 95 
  
  
 named parameters, 
 89 
  
  
 operations or methods, 
 82 
  
  
 polymorphism, 
 94 
  
  
 value-returning function, 
 85 
  
 vararg parameters, 
 91 
  
 movePoint() function, 
 119 
  
 Multithreading 
  
  
 atomic variable types, 
 406–407 
  
 callable, 
 407 
  
  
 executors class, 
 408 
  
  
 functions and 
  
  
  
  
 constructs, 
 400–401 
  
  
 future object, 
 408 
  
  
 joinToString() function, 
 397 
  
 list implementation, 
 402 
  
  
 lock object, 
 404–406 
  
  
 program development 
  
  
  
 Pi calculation, 
 409 
  
  
  
 Pi user interface, 
 410–414 
  
 set implementation, 
 403 
  
  
 thread() function, 
 394–395",NA
M,"thread-safe Deque implementation, 
 403 
 thread-safe Map implementation, 
 403
  
  
 MainActivity class, 
 475–478,489 
 map.toMutableMap() function, 
 328
  
 thread-safe Queue implementation, 
 403 
 thread-safe Set implementation, 
 403",NA
N,"Namespaces, 
 65 
  
 Not null assertion operator, 
 251–252 
 @NotZero annotation, 
 304 
  
 Nullability 
  
  
 elvis operator, 
 251 
  
  
 fictive computer 
  
  
  
  
 language, 
 248–249 
  
  
 not null assertion operator, 
 251 
  
 nullable properties, 
 250 
  
  
 pointer variable, 
 248 
  
 NumberGuess app 
  
  
 Android Studio, 
 32 
  
  
 error, 
 35 
  
  
 layout file, 
 33–35 
  
  
 Kotlin code, 
 36–41 
  
  
 statistics class 
  
  
  
 add action bar, 
 231–237 
  
  
  
 average tries needed, 
 243 
  
  
  
 data list, 
 240 
  
  
  
 getSerializable() function, 
 241 
  
  
 getStatistics() function, 
 245 
  
  
 groupBy() function, 
 245 
  
  
  
 histogram, 
 244 
  
  
  
 mutable list, 
 240 
  
  
  
 restore() function, 
 240 
  
  
  
 save() function, 
 240 
  
  
  
 singleton object, 
 241–242 
  
  
  
 standard deviation, 
 244 
  
  
  
 StatisticsActivity, 
 237–239 
  
  
  
 toSortedMap() function, 
 246 
 Numerical expressions, 
 138
  
 506",NA
O,"Object orientation programming 
  
  
 attributes, 
 16 
  
  
 class declaration, 
 18 
  
  
 class initialization, 
 22 
  
  
 computer mapping 
  
  
  
  
 methodology, 
 16 
  
  
 concrete invoice object, 
 17 
  
  
 constructors (
 see
  Constructors) 
  
  
 contract and interfaces 
  
  
  
 add() function, 
 59 
  
  
  
 characteristics, 
 56 
  
  
  
 collector module and clients, 
 55 
  
  
 coordsOf() function, 
 59 
  
  
  
 graphics collector, 
 56 
  
  
  
 GraphicsObject function, 
 60 
  
  
 module communication, 
 57 
  
  
  
 Triangle class, 
 58 
  
  
 definition, 
 17 
  
  
 end-of-line comment, 
 22 
  
  
 invoice class (
 see
  Invoice class) 
  
  
 methods, 
 15 
  
  
 properties, 
 15 
  
  
 property declaration, 
 20 
  
  
 structure unit and packages, 
 62 
  
  
  
 namespaces, 
 65 
  
  
  
 project, 
 63 
  
 onCreate() function, 
 413 
  
 onSaveInstanceState() function, 
 413 
 [] operator, 
 255
  
 -operator, 
 344 
  
 !! operator, 
 251–252 
  
 != operator, 
 254 
  
 + operator, 
 343–344 
  
 == operator, 
 254 
  
 Operator overloading, 
 130–134 
  
 Operators, 
 343–345",NA
P,"Pairs and triples containers, 
 214 
  
 Pointer value, 
 248 
  
 Polymorphism, 
 94 
  
 pow() function, 
 348 
  
 prettyFormatXml() function, 
 455,458 
  
 Primitive data types, 
 193–195 
  
 Properties 
  
  
 accessors, 
 122–124 
  
  
 data holders/variables, 
 69 
  
  
 declaration modifiers, 
 80 
  
  
 dereferencing operator (.), 
 80 
  
  
 fullName and initials, 
 71 
  
  
 GameUser class, 
 70 
  
  
 immutable and immutable variables, 
 70 
  
 literals, 
 76 
  
  
 null values, 
 79 
  
  
 rules, 
 70 
  
  
 string templates, 
 79 
  
  
 types, 
 72–74 
  
  
 vals function, 
 71 
  
  
 values assignment, 
 74 
  
  
 visibility, 
 79
  
 Regular expressions 
  
  
 patterns, 
 382–385 
  
  
 quantifiers, 
 384–385 
  
  
 strings 
  
  
  
 extraction, 
 388–390 
  
  
  
 matches, 
 386 
  
  
  
 replacing patterns, 
 390–391 
  
  
 splitting, 
 387 
  
 reified type parameters, 
 271 
  
 removeFirst() function, 
 311 
  
 removeLast() function, 
 311 
  
 @Repeatable(…) annotation, 
 294 
 replaceFirst() function, 
 390–391 
 ReplaceWith annotation, 
 301 
  
 Repositories, 
 437–439 
  
 @Retention(…) annotation, 
 293 
 round() function, 
 348 
  
 runBlocking() function, 
 416,419",NA
S,"SAX, 
 448 
  
 sequenceOf() function, 
 340 
 Sequences, 
 340–343",NA
Q,"setTime() function, 
 105 
  
 set.toMutableSet() 
  
  
 Quantifiers, 
 384–385 
  
 Queues and stacks, 
 229–231
  
 function, 
 328 
  
 sign() function, 
 348 
  
 SimpleDateFormat, 
 351–
 352",NA
R,"Spread operator, 
 228–
 229 
  
 sqrt() function, 
 348
  
  
 RandomNumberGenerator class, 
 481 
 RandomRandom class, 
 481 
  
 rangeTo() function, 
 175 
  
 Recursive functions, 
 128–129 
  
 Reduction function, 
 333 
  
 Reflection, 
 378–381
  
 Standard deviation, 
 243 
  
 Standard library, 
 305–306 
  
 API documentation, 
 307 
  
 API level, 
 306–307 
  
 Star projections, 
 283 
  
 startsWith() function, 
 273
  
 Regex class, 
 386,388 
  
 StAX, 
 448
  
 507",NA
U,"Unary operation, 
 131 
 unzip() function, 
 227 
 Use-side 
 variance, 
 281
  
 conditional execution, 
 183 
 for and while Loops, 
 176",NA
V,"ifs and whens 
  
  
 arbitrary expressions, 
 174
  
 Variable-size collections, 
 193
  
 conditional branching 
  
 construct, 
 173",NA
W,"else if and else clauses, 
 172 
 if–else program, 
 171
  
 Windowing function, 
 339
  
 inner blocks, 
 175 
  
 ranges, 
 174 
  
 statement blocks, 
 172",NA
X ,"Xerces, 
 449
  
  
 value-yielding variant, 
 173 
 let function, 
 180 
  
 ranges, 
 175–176 
  
 run scoping function, 
 182
  
 XML processing 
  
 add element, 
 456 
  
 alter data, 
 453–457 
  
 createElement() 
  
  
 scoping functions, 
 177 
  
  
 function, 
 456 
  
 with function, 
 181 
  
 DOM, 
 448,458 
 supervisorScope() function, 
 416 
  
 prettyFormatXml, 
 455 
 Suppress annotation, 
 301–302 
  
 read data
  
 System.currentTimeMillis() function, 
 356",NA
T ,"takeIf() function, 
 183
  
 API and extensions, 
 452–453 
  
 invoke operator, 
 451 
  
 Kotlin file, 
 449–450 
  
 parseXmlToDOM(s:String), 
 451
  
 @Target(…) annotation, 
 292–
 293 
 thread() function, 
 400",NA
Y,"thread.join() function, 
 401 
 three-valued logic, 
 247
  
 yield() function, 
 429
  
 time() function, 
 105 
  
 toDouble() function, 
 285",NA
Z,"Triangle class, 
 482 
  
 Type projections, 
 281–
 282
  
 508
  
 Zipping function, 
 225–227,337–
 339 
 ZonedDateTime class, 
 360–
 362",NA
