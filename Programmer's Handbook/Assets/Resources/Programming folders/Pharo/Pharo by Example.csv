Larger Text,Smaller Text,Symbol
Pharo by Example,NA,NA
"Andrew Black, Stéphane Ducasse, Oscar Nierstrasz, Damien Pollet, Damien",NA,NA
"Cassou, Marcus Denker",NA,NA
To cite this version:,"Andrew Black, Stéphane Ducasse, Oscar Nierstrasz, Damien Pollet, Damien Cassou, et al.. Pharo by",NA
Pharo by Example,"Andrew P. Black 
  
  
 Oscar Nierstrasz
  
 Stéphane Ducasse 
 Damien Pollet
  
 with Damien Cassou and Marcus Denker
  
 Version of 2009-10-28",NA
Contents,"Preface 
  
 ix
  
 I
  
 Getting Started
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 3
  
 1
  
 A quick tour of Pharo
  
 1.1
  
 Getting started .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 3
  
 1.2
  
 The World menu .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 7
  
 1.3
  
 Sending messages.
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 8
  
 1.4
  
 Saving, quitting and restarting a Pharo session
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 9
  
 1.5
  
 Workspaces and Transcripts .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 11
  
 1.6
  
 Keyboard shortcuts .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 12
  
 1.7
  
 The Class Browser
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 15
  
 1.8
  
 Finding classes .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 16
  
 1.9
  
 Finding methods .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 18
  
 1.10
  
 Defining a new method.
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 20
  
 1.11
  
 Chapter summary.
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 25
  
 2
  
 A first application
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 27
  
 2.1
  
 The Lights Out game.
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 27
  
 2.2
  
 Creating a new Package
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 28
  
 2.3
  
 Defining the class LOCell .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 29
  
 2.4
  
 Adding methods to a class.
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 31
  
 2.5
  
 Inspecting an object .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 33
  
 2.6
  
 Defining the class LOGame
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 34
  
 2.7
  
 Organizing methods into protocols
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 37",NA
Preface,NA,NA
What is Pharo?,"Pharo is a modern, open source, fully-featured implementation of the 
 Smalltalk programming language and environment. Pharo is derived from 
 Squeak
 1
 , a re-implementation of the classic Smalltalk-80 system. Whereas 
 Squeak was developed mainly as a platform for developing experimental 
 educational software, Pharo strives to offer a lean, open-source platform for 
 professional software development, and a robust and stable platform for 
 research and development into dynamic languages and environments. Pharo 
 serves as the reference implementation for the Seaside web development 
 framework.
  
 Pharo resolves some licensing issues with Squeak. Unlike previous ver-
 sions of Squeak, the Pharo core contains only code that has been contributed 
 under the MIT license. The Pharo project started in March 2008 as a fork of 
 Squeak 3.9, and the first 1.0 beta version was released on July 31, 2009.
  
 Although Pharo removes many packages from Squeak, it also includes 
 numerous features that are optional in Squeak. For example, true type fonts 
 are bundled into Pharo. Pharo also includes support for true block closures. 
 The user interfaces has been simplified and revised.
  
 Pharo is highly portable — even its virtual machine is written entirely in 
 Smalltalk, making it easy to debug, analyze, and change. Pharo is the vehicle 
 for 
 a wide range of innovative projects from multimedia applications and 
 educational platforms to commercial web development environments.
  
 There is an important aspect behind Pharo: Pharo should not just be a copy 
 of the past but really reinvent Smalltalk. Big-bang approaches rarely succeed. 
 Pharo will really favor evolutionary and incremental changes. We want to
  
 1
 Dan Ingalls et al., Back to the Future: The Story of Squeak, a Practical Smalltalk Written in 
 Itself. In Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, 
 systems, languages, and applications (OOPSLA’97). ACM Press, November 1997
  ⟨
 URL:
  http: 
 //www.cosc.canterbury.ac.nz/~wolfgang/cosc205/squeak.html
 ⟨
 .",NA
Who should read this book?,"This book is based on Squeak by Example
 2
 , an open-source introduction to 
 Squeak. The book has been liberally adapted and revised to reflect the differ-
 ences between Pharo and Squeak. This book presents the various aspects of 
 Pharo, starting with the basics, and proceeding to more advanced topics.
  
 This book will not teach you how to program. The reader should have 
 some familiarity with programming languages. Some background with object-
 oriented programming would be helpful.
  
 This book will introduce the Pharo programming environment, the lan-
 guage and the associated tools. You will be exposed to common idioms and 
 practices, but the focus is on the technology, not on object-oriented de-sign. 
 Wherever possible, we will show you lots of examples. (We have been inspired 
 by Alec Sharp’s excellent book on Smalltalk
 3
 .)
  
 There are numerous other books on Smalltalk freely available on the web 
 but none of these focuses specifically on Pharo. See for example:
  http: 
 //stephane.ducasse.free.fr/FreeBooks.html",NA
A word of advice,"Do not be frustrated by parts of Smalltalk that you do not immediately 
 understand. You do not have to know everything! Alan Knight expresses this 
 principle as follows
 4
 :
  
  
 2
 http://SqueakByExample.org 
  
  
 3
 Alec Sharp, Smalltalk by Example. McGraw-Hill, 1997
  ⟨
 URL:
  http://stephane.ducasse.free.fr/ 
 FreeBooks/ByExample/
 ⟨
 .
  
 4
 http://www.surfscranton.com/architecture/KnightsPrinciples.htm",NA
An open book,"This book is an open book in the following senses:
  
 • The content of this book is released under the Creative Commons 
 Attribution-ShareAlike (by-sa) license. In short, you are allowed to 
 freely share and adapt this book, as long as you respect the conditions of 
 the license available at the following URL:
  http://creativecommons.org/ 
 licenses/by-sa/3.0/
 .
  
 • This book just describes the core of Pharo. Ideally we would like to 
 encourage others to contribute chapters on the parts of Pharo that we 
 have not described. If you would like to participate in this effort, please 
 contact us. We would like to see this book grow!
  
 For more details, visit
  http://PharoByExample.org
 .",NA
The Pharo community,"The Pharo community is friendly and active. Here is a short list of resources 
 that you may find useful:
  
 •
  http://www.pharo-project.org
  is the main web site of Pharo.
  
 •
  http://www.squeaksource.com
  is the equivalent of SourceForge for Pharo 
 projects. Many optional packages for Pharo live here.",NA
Examples and exercises,"We make use of two special conventions in this book.
  
 We have tried to provide as many examples as possible. In particular, there 
 are many examples that show a fragment of code which can be evaluated. We",NA
Acknowledgments,"We would first like to thank the original developers of Squeak for making this 
 amazing Smalltalk development environment available as an open source 
 project.
  
 We would also like to thank Hilaire Fernandes and Serge Stinckwich who 
 allowed us to translate parts of their columns on Smalltalk, and Damien 
 Cassou for contributing the chapter on streams.
  
  
 We especially thank Alexandre Bergel, Orla Greevy, Fabrizio Perin, Lukas 
 Renggli, Jorge Ressia and Erwann Wernli for their detailed reviews.
  
  
 We thank the University of Bern, Switzerland, for graciously supporting 
 this open-source project and for hosting the web site of this book.
  
 We also thank the Squeak community for their enthusiastic support of this 
 book project, and for informing us of the errors found in the first edition of 
 this book.",NA
Part I ,NA,NA
Getting Started,NA,NA
Chapter 1,NA,NA
A quick tour of Pharo,"In this chapter we will give you a high-level tour of Pharo to help you get 
 comfortable with the environment. There will be plenty of opportunities to 
 try 
 things out, so it would be a good idea if you have a computer handy when 
 you 
 read this chapter.
  
 We will use this icon:
  
  
 to mark places in the text where you should try
  
 something out in Pharo. In particular, you will fire up Pharo, learn about the 
 different ways of interacting with the system, and discover some of the basic 
 tools. You will also learn how to define a new method, create an object and 
 send it messages.",NA
1.1 ,NA,NA
Getting started,"Pharo is available as a free download from
  http://pharo-project.org
 . There are 
 three parts that you will need to download, consisting of four files (see Figure 
 1.1).
  
  
  
  
  
 Virtual Machine
  
 Shared Sources
  
 User-specific system files 
  
 Figure 1.1: The Pharo download files for one of the supported platforms.
  
 1. The virtual machine (VM) is the only part of the system that is different 
 for each operating system and processor. Pre-compiled virtual machines 
 are available for all the major computing environments. In Figure 1.1 we 
 see the VM for the selected platform is called Pharo.exe.",NA
1.2 ,NA,NA
The World menu,"Click again on the Pharo background.
  
 You will see the
  World
  menu again. Most Pharo menus are not modal; you 
 can leave them on the screen for as long as you wish by clicking the push pin 
 icon in the top-right corner. Do this.
  
  
 The world menu provides you a simple means to access many of the tools 
 that Pharo offers.
  
  
 Have a closer look at the
  World
  and
  Tools . . .
  menus. (Figure 1.3 (a))
  
  
 4
 Note that the morphic handles are inactive by default in Pharo, but you can turn them on using 
 the Preferences Browser, which we will see shortly.",NA
1.3,NA,NA
Sending messages,"Open a workspace. Type in the following text:
  
  
 BouncingAtomsMorph new openInWorld
  
  
 Now action-click. A menu should appear. Select
  do it (d)
 . (See Figure 1.5.)
  
  
 A window containing a large number of bouncing atoms should open in the 
 top left of the Pharo image.
  
 You have just evaluated your first Smalltalk expression! You just sent the 
 message
  new
  to the
  BouncingAtomsMorph
  class, resulting in a new
  Bounc-
 ingAtomsMorph
  instance, followed by the message
  openInWorld
  to this instance. 
 The
  BouncingAtomsMorph
  class decided what to do with the
  new
  message, that",NA
1.4 ,NA,NA
"Saving, quitting and restarting a Pharo session","Now click on the bouncing atoms window and drag it anywhere you like. 
 You now have the demo “in hand”. Put it down by clicking anywhere.
  
  
 Select
  World
 ⟨
  Save as . . .
  , enter the name “myPharo”, and click on the
  OK
  
  
  
 button. Now select
  World
 ⟨
  Save and quit
 .
  
 Now if you go to the location where the original image and changes files 
 were, you will find two new files called “myPharo.image” and",NA
1.5 ,NA,NA
Workspaces and Transcripts,"Close all open windows. Open a transcript and a workspace. (The transcript 
 can be opened from the
  World
 ⟨
  Tools ...
  submenu.)
  
 Position and resize the transcript and workspace windows so that the 
 workspace 
 just overlaps the transcript.
  
 You can resize windows either by dragging one of the corners, or by meta-
 clicking the window to bring up the morphic halo, and dragging the yellow 
 (bottom right) handle.
  
  
 At any time only one window is active; it is in front and has its border 
 highlighted.
  
  
 The transcript is an object that is often used for logging system messages. It 
 is a kind of “system console”.
  
 Workspaces are useful for typing snippets of Smalltalk code that you 
 would like to experiment with. You can also use workspaces simply for typing 
 arbitrarily text that you would like to remember, such as to-do lists or 
 instructions for anyone who will use your image. Workspaces are often used 
 to hold documentation about a captured image, as is the case with the 
 standard image that we downloaded earlier (see Figure 1.2).
  
  
 Type the following text into the workspace:
  
  
 Transcript show: 'hello world'; cr.
  
 Try double-clicking in the workspace at various points in the text you 
 have 
 just typed. Notice how an entire word, entire string, or the whole text is
  
 5
 Remember, you may have to set the
  halosEnabled
  option in the Preferences Browser.",NA
1.6 ,NA,NA
Keyboard shortcuts,"If you want to evaluate an expression, you do not always have to action-click. 
 Instead, you can use keyboard shortcuts. These are the parenthesized 
 expressions in the menu. Depending on your platform, you may have to press 
 one of the modifier keys (control, alt, command, or meta). (We will indicate 
 these generically as
  CMD
 –key.)
  
 Evaluate the expression in the workspace again, but using the keyboard 
 shortcut: 
 CMD
 –d.
  
  
 In addition to
  do it
 , you will have noticed
  print it
 ,
  inspect it
  and
  explore it
 . Let’s 
 have a quick look at each of these.",NA
1.7 ,NA,NA
The Class Browser,"The class browser
 6
 is one of the key tools used for programming. As we shall 
 see, there are several interesting browsers available for Pharo, but this is the 
 basic one you will find in any image.
  
  
 Open a browser by selecting
  World
  ⟨
  Class browser
 .
 7
  
 Packages
  
 Protocols
  
 Methods
  
 Classes
  
 name of method 
  
 code of method 
  
 method 
  
 ""printString""
  
 comment 
  
 Figure 1.12: The browser showing the
  printString
  method of class object.
  
  
 We can see a browser in Figure 1.12. The title bar indicates that we are 
 browsing the class
  Object
 .
  
 When the browser first opens, all panes are empty but the leftmost one. 
 This first pane lists all known packages, which contain groups of related classes.
  
  
 Click on the
  Kernel
  
 package.
  
 6
 Confusingly, this is variously referred to as the “system browser” or the “code browser”. Pharo 
 uses the OmniBrowser implementation of the browser, which may also be variously known as 
 “OB” or the “Package browser”. In this book we will simply use the term “browser”, or, in case of 
 ambiguity, the “class browser”.
  
  
 7
 If the browser you get does not look like the one shown in Figure 1.12, then you may need to 
 change the default browser. See FAQ 5, p. 318.",NA
1.8 ,NA,NA
Finding classes,"There are several ways to find a class in Pharo. The first, as we have just seen 
 above, is to know (or guess) what category it is in, and to navigate to it using 
 the browser.
  
  
 A second way is to send the
  browse
  message to the class, asking it to open a 
 browser on itself. Suppose we want to browse the class
  Boolean
 .
  
 Type
  Boolean browse
  into a workspace and
  do it
 .
  
 A browser will open on the Boolean class (Figure 1.13). There is also a 
 keyboard shortcut
  CMD
 –b (browse) that you can use in any tool where you 
 find a class name; select the name and type
  CMD
 –b.
  
 Use the keyboard shortcut to browse the class
  Boolean
 .
  
 Notice that when the
  Boolean
  class is selected but no protocol or method is 
 selected, instead of the source code of a method, we see a class definition 
 (Figure 1.13). This is nothing more than an ordinary Smalltalk message that is 
 sent to the parent class, asking it to create a subclass. Here we see that the 
 class
  Object
  is being asked to create a subclass named
  Boolean
  with no instance 
 variables, class variables or “pool dictionaries”, and to put the class
  Boolean
  
 in the
  Kernel-Objects
  category. If you click on the
  ?
  at the bottom of the class
  
  
  
 pane, you can see the class comment in a dedicated pane (see Figure 1.14).",NA
1.9 ,NA,NA
Finding methods,"Sometimes you can guess the name of a method, or at least part of the name of 
 a method, more easily than the name of a class. For example, if you are 
 interested in the current time, you might expect that there would be a method 
 called “now”, or containing “now” as a substring. But where might it be? The 
 method finder can help you.
  
 Select
  World
  ⟨
  Tools ...
  ⟨
  Method finder
 . Type “now” in the top left pane, and 
 accept
  it (or just press the
  RETURN
  key).
  
 The method finder will display a list of all the method names that contain 
 the substring “now”. To scroll to
  now
  itself, move the cursor to the list and type 
 “
 n
 ”; this trick works in all scrolling windows. Select “now” and the right-hand 
 pane shows you the classes that define a method with this name, as shown in 
 Figure 1.16. Selecting any one of them will open a browser on it.
  
 At other times you may have a good idea that a method exists, but will 
 have no idea what it might be called. The method finder can still help! For",NA
1.10 ,NA,NA
Defining a new method,"The advent of Test Driven Development
 9
 (TDD) has changed the way that we 
 write code. The idea behind TDD is that we write a test that defines the 
 desired behaviour of our code before we write the code itself. Only then do we 
 write the code that satisfies the test.
  
 Suppose that our assignment is to write a method that “says something 
 loudly and with emphasis”. What exactly could that mean? What would be a 
 good name for such a method? How can we make sure that programmers who 
 may have to maintain our method in the future have an unambiguous 
 description of what it should do? We can answer all of these questions by 
 giving an example:
  
 When we send the message
  shout
  to the string “Don’t panic” the 
 result should be “DON’T PANIC!”.
  
 To make this example into something that the system can use, we turn it into a 
 test method:
  
 Method 1.1: A test for a shout method
  
 testShout
  
  
 self assert: ('Don''t panic' shout = 'DON''T PANIC!')
  
 9
 Kent Beck, Test Driven Development: By Example. Addison-Wesley, 2003, ISBN 0–321–14653–0.",NA
1.11 ,NA,NA
Chapter summary,"This chapter has introduced you to the Pharo environment and shown you 
 how to use some of the major tools, such as the browser, the method finder, 
 and the test runner. You have also seen a little of Pharo’s syntax, even though 
 you may not understand it all yet.
  
 • A running Pharo system consists of a virtual machine, a sources file, and 
 image and changes files. Only these last two change, as they record a 
 snapshot of the running system.
  
 • When you restore a Pharo image, you will find yourself in exactly the 
 same state — with the same running objects — that you had when you 
 last saved that image.
  
 • Pharo is designed to work with a three-button mouse to click, action-
 click 
 or meta-click. If you don’t have a three-button mouse, you can use 
 modifier keys to obtain the same effect.
  
 • You click on the Pharo background to bring up the World menu and 
  
 launch various tools.
  
 • A workspace is a tool for writing and evaluating snippets of code. You 
  
 can also use it to store arbitrary text.
  
 • You can use keyboard shortcuts on text in the workspace, or any 
  
 other tool, to evaluate code. The most important of these are
  do it",NA
Chapter 2,NA,NA
A first application,"In this chapter, we will develop a simple game: Lights Out.
 1
 Along the way we 
 will demonstrate most of the tools that Pharo programmers use to 
 construct 
 and debug their programs, and show how programs are exchanged 
 with other 
 developers. We will see the browser, the object inspector, the debugger and 
 the Monticello package browser. Development in Smalltalk is efficient: you 
 will find that you spend far more time actually writing code and far less 
 managing the development process. This is partly because the Smalltalk 
 language is very simple, and partly because the tools that make up the 
 programming environment are very well integrated with the language.",NA
2.1 ,NA,NA
The Lights Out game,"Figure 2.1: The Lights Out game board. The user has just clicked the mouse as 
 shown by the cursor.
  
 To show you how to use Pharo’s programming tools, we will build a simple 
 game called Lights Out. The game board is shown in Figure 2.1; it
  
 1
 http://en.wikipedia.org/wiki/Lights_Out_(game)",NA
2.2 ,NA,NA
Creating a new Package,"We have already seen the browser in Chapter 1, where we learned how to 
 navigate to classes and methods, and saw how to define new methods. Now 
 we will see how to create packages, categories and classes.
  
 Open a browser and action-click in the package pane. Select
  create package
 .
 2
  
  
 Figure 2.2: Adding a package.
  
  
 Figure 2.3: The class template.
  
  
 Type the name of the new package (we will use
  PBE-LightsOut
 ) in the dialog 
 box and click
  accept
  (or just press the return key); the new package is created,
  
 2
 We are assuming that the Package Browser is installed as the default browser, which should 
 normally be the case. If the browser you get does not look like the one shown in Figure 2.2, then 
 you may need to change the default browser. See FAQ 5, p. 318.",NA
2.3 ,NA,NA
Defining the class LOCell,"As yet there are of course no classes in the new package. However, the main 
 editing pane displays a template to make it easy to create a new class (see 
 Figure 2.3).
  
 This template shows us a Smalltalk expression that sends a message to a 
 class called
  Object
 , asking it to create a subclass called
  NameOfSubClass
 . The new 
 class has no variables, and should belong to the category
  PBE-LightsOut
 .
  
 On Categories and Packages
  
 Historically, Smalltalk only knows about categories, not packages. You may 
 well ask, what is the difference? A category is simply a collection of related 
 classes in a Smalltalk image. A package is a collection of related classes and 
 extension methods that may be versioned using the Monticello versioning tool. 
 By convention, package names and category names are the same. For most 
 purposes we do not care about the difference, but we will be careful to use the 
 correct terminology in this book since there are points where the difference is 
 crucial. We will learn more when we start working with Monticello.
  
 Creating a new class
  
 We simply modify the template to create the class that we really want.
  
 Modify the class creation template as follows:
  
 • Replace
  Object
  by
  SimpleSwitchMorph
 .
  
 • Replace
  NameOfSubClass
  by
  LOCell
 .
  
 • Add
  mouseAction
  to the list of instance variables.
  
 The result should look like class 2.1.
  
 Class 2.1: Defining the class
  LOCell
  
 SimpleSwitchMorph subclass: #LOCell
  
  
 instanceVariableNames: 'mouseAction'
  
  
 classVariableNames: ''
  
  
 poolDictionaries: ''
  
  
      
 category: 'PBE−LightsOut'",NA
2.4 ,NA,NA
Adding methods to a class,"Now let’s add some methods to our class.
  
 Select the protocol
  --all--
  in the protocol pane.
  
  
 You will see a template for method creation in the editing pane. Select it, 
 and replace it by the text of method 2.2.",NA
2.5 ,NA,NA
Inspecting an object,"You can test the effect of the code you have written by creating a new
  LOCell 
 object and inspecting it.
  
 Open a workspace. Type the expression
  LOCell new
  and
  inspect it
 .
  
  
 Figure 2.6: The inspector used to examine a LOCell object.
  
 The left-hand pane of the inspector shows a list of instance variables; if 
 you select one (try
  bounds
 ), the value of the instance variable is shown in the 
 right pane.
  
  
 The bottom pane of the inspector is a mini-workspace. It’s useful because 
 in 
 this workspace the pseudo-variable
  self
  is bound to the object selected.
  
  
 Select the LOCell at the root of the inspector window. Type the text
  self 
 bounds: (200@200 corner: 250@250)
  in the bottom pane and
  do it
 . The
  bounds
  
 variable should 
 change in the inspector. Now type the text
  self openInWorld
  in 
 the mini-workspace and
  do it
 .",NA
2.6 ,NA,NA
Defining the class LOGame,"Now let’s create the other class that we need for the game, which we will call 
 LOGame
 .
  
 Make the class definition template visible in the browser main window.
  
  
 Do this by clicking on the package name. Edit the code so that it reads as 
 follows, and
  accept
  it.
  
 Class 2.3: Defining the
  LOGame
  class
  
 BorderedMorph subclass: #LOGame
  
  
 instanceVariableNames: ''
  
  
 classVariableNames: ''
  
  
 poolDictionaries: ''
  
  
 category: 'PBE−LightsOut'
  
 Here we subclass
  BorderedMorph
 ;
  Morph
  is the superclass of all of the graph-
 ical shapes in Pharo, and (surprise!) a
  BorderedMorph
  is a
  Morph
  with a border. 
 We could also insert the names of the instance variables between the quotes on 
 the second line, but for now, let’s just leave that list empty.",NA
2.7 ,NA,NA
Organizing methods into protocols,"Before we define any more methods, let’s take a quick look at the third pane at 
 the top of the browser. In the same way that the first pane of the browser 
 lets 
 us categorize classes into packages so we are not overwhelmed by a very long 
 list of class names in the second pane, so the third pane lets us categorize 
 methods so that we are not overwhelmed by a very long list of method names 
 in the fourth pane. These categories of methods are called “protocols”.
  
 If there are only a few methods in a class, the extra level of hierarchy 
 provided by protocols is not really necessary. This is why the browser also 
 offers us the
  --all--
  virtual protocol, which, you will not be surprised to learn, 
 contains all of the methods in the class.
  
  
 Figure 2.10: Automatically categorize all uncategorized methods.",NA
2.8 ,NA,NA
Let’s try our code,"That’s it: the Lights Out game is complete!
  
  
 If you have followed all of the steps, you should be able to play the game, 
 consisting of just 2 classes and 7 methods.
  
 3
 In fact, the instance variables can be accessed in subclasses too.",NA
2.9 ,NA,NA
Saving and sharing Smalltalk code,"Now that you have the Lights Out game working, you probably want to save 
 it 
 somewhere so that you can share it with your friends. Of course, you can save 
 your whole Pharo image, and show off your first program by running it, but 
 your friends probably have their own code in their images, and don’t want to 
 give that up to use your image. What you need is a way of getting source code 
 out of your Pharo image so that other programmers can bring it into theirs.
  
 The simplest way of doing this is by filing out the code. The action-click 
 menu in the Package pane will give you the option to
  various
  ⟨
  file out
  the whole 
 of package
  PBE-LightsOut
 . The resulting file is more or less human readable, but 
 is really intended for computers, not humans. You can email 
 this file to your 
 friends, and they can file it into their own Pharo images using 
 the file list 
 browser.",NA
2.10 ,NA,NA
Chapter summary,"In this chapter you have seen how to create categories, classes and methods. 
 You have see how to use the browser, the inspector, the debugger and the 
 Monticello browser.",NA
Chapter 3,NA,NA
Syntax in a nutshell,"Pharo, like most modern Smalltalk dialects, adopts a syntax very close to that 
 of Smalltalk-80. The syntax is designed so that program text can be read aloud 
 as though it were a kind of pidgin English:
  
 (Smalltalk includes: Class) ifTrue: [ Transcript show: Class superclass ]
  
 Pharo’s syntax is minimal. Essentially there is syntax only for sending messages 
 (i.e., expressions) . Expressions are built up from a very small number of 
 primitive elements. There are only 6 keywords, and there is no syntax for 
 control structures or declaring new classes. Instead, nearly everything is 
 achieved by sending messages to objects. For instance, instead of an if-then-else 
 control structure, Smalltalk sends messages like
  ifTrue:
  to
  Boolean
  objects.
  
 New (sub-)classes are created by sending a message to their superclass.",NA
3.1 ,NA,NA
Syntactic elements,"Expressions are composed of the following building blocks: (i) six reserved 
 keywords, or pseudo-variables:
  self
 ,
  super
 ,
  nil
 ,
  true
 ,
  false
 , and
  thisContext
 , (ii) con-
 stant expressions for literal objects including numbers, characters, strings, 
 symbols and arrays, (iii) variable declarations, (iv) assignments, (v) block 
 closures, and (vi) messages.
  
 We can see examples of the various syntactic elements in Table 3.1.
  
 Local variables
  startPoint
  is a variable name, or identifier. By convention, 
 identifiers are composed of words in “camelCase” (i.e., each word except 
 the first starting with an upper case letter). The first letter of an instance 
 variable, method or block argument, or temporary variable must be 
 lower case. This indicates to the reader that the variable has a private",NA
3.2 ,NA,NA
Pseudo-variables,"In Smalltalk, there are 6 reserved keywords, or pseudo-variables:
  nil
 ,
  true
 ,
  false
 , 
 self
 ,
  super
 , and
  thisContext
 . They are called pseudo-variables because they are 
 predefined and cannot be assigned to.
  true
 ,
  false
 , and
  nil
  are constants while the 
 values of
  self
 ,
  super
 , and
  thisContext
  vary dynamically as code is executed.
  
  
 true
  and
  false
  are the unique instances of the
  Boolean
  classes
  True
  and
  False
 . 
 See Chapter 8 for more details.
  
 self
  always refers to the receiver of the currently executing method.
  
 super
  also refers to the receiver of the current method, but when you send 
 a message to
  super
 , the method-lookup changes so that it starts from the 
 superclass of the class containing the method that uses
  super
 . For further 
 details see Chapter 5.
  
  
 nil
  is the undefined object. 
  
 It is the unique instance of the class 
 UndefinedObject
 . Instance variables, class variables and local variables are 
 initialized to
  nil
 .
  
 thisContext
  is a pseudo-variable that represents the top frame of the run-
 time stack. In other words, it represents the currently executing
  MethodContext 
 or
  
 BlockClosure
 .
  thisContext
  is normally not of interest to most programmers,",NA
3.3 ,NA,NA
Message sends,"There are three kinds of messages in Pharo.
  
 1. Unary messages take no argument.
  1 factorial
  sends the message
  factorial 
  
 to the object
  1
 .
  
 2. Binary messages take exactly one argument.
  1 + 2
  sends the message
  + 
  
 with argument
  2
  to the object
  1
 .
  
 3. Keyword messages take an arbitrary number of arguments.
  2 raisedTo: 6 
 modulo: 10
  sends the message consisting of the message selector 
 raisedTo:modulo:
  and the arguments
  6
  and
  10
  to the object
  2
 .
  
  
 Unary message selectors consist of alphanumeric characters, and start with 
 a lower case letter.
  
  
 Binary message selectors consist of one or more characters from the fol-
 lowing set:
  
 + − / \ *
  ⟨
  < > = @ % | & ? ,
  
 Keyword message selectors consist of a series of alphanumeric keywords, 
 where each keyword starts with a lower-case letter and ends with a colon.
  
  
 Unary messages have the highest precedence, then binary messages, and 
 finally keyword messages, so:
  
 2 raisedTo: 1 + 3 factorial
  
 −→
  
 128
  
 (First we send
  factorial
  to
  3
 , then we send
  + 6
  to
  1
 , and finally we send
  raisedTo: 7
  
 to
  2
 .) Recall that we use the notation
  expression
  
 −→
  
 result
  to show the result
  
 of evaluating an expression.
  
 Precedence aside, evaluation is strictly from left to right, so
  
 1 + 2 * 3
  
 −→
  
 9
  
 not
  7
 . Parentheses must be used to alter the order of evaluation:
  
 1 + (2 * 3)
  
 −→
  
 7
  
 Message sends may be composed with periods and semi-colons. A period-
 separated sequence of expressions causes each expression in the series to be 
 evaluated as a statement, one after the other.",NA
3.4 ,NA,NA
Method syntax,"Whereas expressions may be evaluated anywhere in Pharo (for example, in a 
 workspace, in a debugger, or in a browser), methods are normally defined in a 
 browser window, or in the debugger. (Methods can also be filed in from an 
 external medium, but this is not the usual way to program in Pharo.)
  
 Programs are developed one method at a time, in the context of a given 
 class. (A class is defined by sending a message to an existing class, asking it to 
 create a subclass, so there is no special syntax required for defining classes.)
  
 Here is the method
  lineCount
  in the class
  String
 . (The usual convention is to 
 refer to methods as
  ClassName»methodName
 , so we call this method
  
 String»lineCount
 .)
  
 Method 3.1: Line count
  
 String»lineCount
  
  
 ""Answer the number of lines represented by the receiver,
  
  
 where every cr adds one line.""
  
  
 | cr count |
  
  
 cr := Character cr.
  
  
 count := 1 min: self size.
  
  
 self do:
  
  
 [:c | c == cr ifTrue: [count := count + 1]].
  
  
 ↑
  count
  
 Syntactically, a method consists of:",NA
3.5 ,NA,NA
Block syntax,"Blocks provide a mechanism to defer the evaluation of expressions. A block is 
 essentially an anonymous function. A block is evaluated by sending it the 
 message
  value
 . The block answers the value of the last expression in its body, 
 unless there is an explicit return (with
  ↑
 ), in which case it does not answer any 
 value.
  
 [ 1 + 2 ] value
  
 −→
  
 3
  
 Blocks may take parameters, each of which is declared with a leading 
 colon. A vertical bar separates the parameter declaration(s) from the body of 
 the block. To evaluate a block with one parameter, you must send it the 
 message
  value:
  with one argument. A two-parameter block must be sent 
 value:value:
 , and so on, up to 4 arguments.
  
 [ :x | 1 + x ] value: 2
  
 −→
  
 3
  
 −→
  
 3
  
 [ :x :y | x + y ] value: 1 value: 2
  
 If you have a block with more than four parameters, you must use 
 valueWithArguments:
  and pass the arguments in an array. (A block with a large 
 number of parameters is often a sign of a design problem.)
  
 Blocks may also declare local variables, which are surrounded by vertical 
 bars, just like local variable declarations in a method. Locals are declared after 
 any arguments:
  
 [ :x :y | | z | z := x+ y. z ] value: 1 value: 2
  
 −→
  
 3",NA
3.6 ,NA,NA
Conditionals and loops in a nutshell,"Smalltalk offers no special syntax for control constructs. Instead, these are typ-
 ically expressed by sending messages to booleans, numbers and collections, 
 with blocks as arguments.
  
 Conditionals are expressed by sending one of the messages
  ifTrue:
 ,
  ifFalse: 
 or
  ifTrue:ifFalse:
  to the result of a boolean expression. See Chapter 8 for more 
 about booleans.
  
 (17 * 13 > 220)
  
 −→
  
 'bigger'
  
 ifTrue: [ 'bigger' ]
  
 ifFalse: [ 'smaller' ]
  
 Loops are typically expressed by sending messages to blocks, integers or 
 collections. Since the exit condition for a loop may be repeatedly evaluated, it 
 should be a block rather than a boolean value. Here is an example of a very 
 procedural loop:
  
 n := 1.
  
 [ n < 1000 ] whileTrue: [ n := n*2 ].
  
 n
  
 −→
  
 1024
  
 whileFalse:
  reverses the exit condition.
  
 n := 1.
  
 [ n > 1000 ] whileFalse: [ n := n*2 ].
  
 n
  
 −→
  
 1024
  
 timesRepeat:
  offers a simple way to implement a fixed iteration:
  
 n := 1.
  
 10 timesRepeat: [ n := n*2 ].
  
 n
  
 −→
  
 1024",NA
Primitives and pragmas,Syntax in a nutshell,NA
3.7,"In Smalltalk everything is an object, and everything happens by sending 
 messages. Nevertheless, at certain points we hit rock bottom. Certain objects 
 can only get work done by invoking virtual machine primitives.
  
 For example, the following are all implemented as primitives: memory 
 allocation (
 new
 ,
  new:
 ), bit manipulation (
 bitAnd:
 ,
  bitOr:
 ,
  bitShift:
 ), pointer and 
 integer arithmetic (
 +
 ,
  −
 ,
  <
 ,
  >
 ,
  *
 ,
  /
  ,
  =
 ,
  ==
 ...), and array access (
 at:
 ,
  at:put:
 ).
  
 Primitives are invoked with the syntax
  <primitive: aNumber>
 . A method that 
 invokes such a primitive may also include Smalltalk code, which will be 
 evaluated only if the primitive fails.
  
  
 Here we see the code for
  SmallInteger»+
 . If the primitive fails, the expression 
 super + aNumber
  will be evaluated and returned.
  
 Method 3.2: A primitive method
  
 + aNumber
  
  
 ""Primitive. Add the receiver to the argument and answer with the result
  
  
 if it is a SmallInteger. Fail if the argument or the result is not a
  
  
 SmallInteger Essential No Lookup. See Object documentation whatIsAPrimitive.""
  
  
 <primitive: 1>
  
  
 ↑
  super + aNumber
  
  
 In Pharo, the angle bracket syntax is also used for method annotations 
 called pragmas.",NA
3.8 ,NA,NA
Chapter summary,"•
  Pharo has (only) six reserved identifiers also called pseudo-variables:
  true
 , 
  
 false
 ,
  nil
 ,
  self
 ,
  super
 , and
  thisContext
 .
  
 • There are five kinds of literal objects: numbers (
 5
 ,
  2.5
 ,
  1.9e15
 ,
  2r111
 ), 
  
 characters (
 $a
 ), strings (
 'hello'
 ), symbols (
 #hello
 ), and arrays (
 #('hello' #hi)
 )
  
 • Strings are delimited by single quotes, comments by double quotes. To 
  
 get a quote inside a string, double it.
  
 • Unlike strings, symbols are guaranteed to be globally unique.
  
 • Use
  #( ... )
  to define a literal array. Use
  { ... }
  to define a dynamic array.
  
 Note that
  #( 1 + 2 ) size
  
 −→
  
 3
 , but
  { 1 + 2 } size
  
 −→
  
 1
  
 • There are three kinds of messages: unary (e.g.,
  1 asString
 ,
  Array new
 ), bi-
  
 nary (e.g.,
  3 + 4
 ,
  'hi' , ' there'
 ), and keyword (e.g.,
  'hi' at: 2 put: $o
 )",NA
Chapter 4,NA,NA
Understanding message,NA,NA
syntax,"Although Smalltalk’s message syntax is extremely simple, it is unconventional 
 and can take some time getting used to. This chapter offers some guidance to 
 help you get acclimatized to this special syntax for sending messages. If you 
 already feel comfortable with the syntax, you may choose to skip this chapter, 
 or 
 come back to it later.",NA
4.1 ,NA,NA
Identifying messages,"In Smalltalk, except for the syntactic elements listed in Chapter 3 (
 :=
  ↑
  . ; # () {} [ : 
 | ]
 ), everything is a message send. As in C++, you can define operators like 
 +
  for 
 your own classes, but all operators have the same precedence. Moreover, 
 you 
 cannot change the arity of a method. “
 −
 ” is always a binary message; there is no 
 way to have a unary “
 −
 ” with a different overloading.
  
 In Smalltalk the order in which messages are sent is determined by the 
 kind of message. There are just three kinds of messages: unary, binary, and 
 keyword messages. Unary messages are always sent first, then binary messages 
 and finally keyword ones. As in most languages, parentheses can be used to 
 change the order of evaluation. These rules make Smalltalk code as easy to 
 read as possible. And most of the time you do not have to think about the 
 rules.
  
  
 As most computation in Smalltalk is done by message passing, correctly 
 identifying messages is crucial. The following terminology will help us:
  
 •
  A message is composed of the message selector and the optional message 
  
 arguments.",NA
4.2 ,NA,NA
Three kinds of messages,"Smalltalk defines a few simple rules to determine the order in which the 
 messages are sent. These rules are based on the distinction between 3 different 
 kinds of messages:
  
 •
  Unary messages are messages that are sent to an object without any other 
  
 information. For example in
  3 factorial
 ,
  factorial
  is a unary message.
  
 • Binary messages are messages consisting of operators (often arithmetic). 
 They are binary because they always involve only two objects: the 
 receiver and the argument object. For example in
  10 + 20
 ,
  +
  is a binary 
 message sent to the receiver
  10
  with argument
  20
 .
  
 •
  Keyword messages are messages consisting of one or more keywords, each 
 ending with a colon (
 :
 ) and taking an argument. For example in
  anArray at: 
 1 put: 10
 , the keyword
  at:
  takes the argument
  1
  and the keyword
  put: 
 takes 
 the argument
  10
 .",NA
4.3,NA,NA
Message composition,"The three kinds of messages each have different precedence, which allows 
 them to be composed in an elegant way.
  
 1. Unary messages are always sent first, then binary messages and finally 
  
 keyword messages.
  
 2. Messages in parentheses are sent prior to any kind of messages.
  
 3. Messages of the same kind are evaluated from left to right.
  
 These rules lead to a very natural reading order. Now if you want to be sure 
 that your messages are sent in the order that you want you can always",NA
aPen  go:   100 + 20 ,"Figure 4.4: Binary messages are sent
  
 before keyword messages.
  
 Parentheses first
  
 Pen new  go:  100 + 20
  
 Figure 4.5: Decomposing
  Pen new go:
  
 100 + 20
  
  
 Rule Two.
  Parenthesised messages are sent prior to other 
 messages.
  
 (Msg) > Unary > Binary > Keyword
  
  
 1.5 tan rounded asString = (((1.5 tan) rounded) asString)
  
 −→
  
 true
  
 ""parentheses
  
  
 not needed here""
  
 27
  
 ""(not 5040)""
  
 3 + 4 factorial
  
 −→
  
 (3 + 4) factorial
  
 −→
  
 5040
  
  
 Here we need the parentheses to force sending
  lowMajorScaleOn:
  before 
 play
 .
  
  
 (FMSound lowMajorScaleOn: FMSound clarinet) play
  
 ""(1) send the message clarinet to the FMSound class to create a clarinet sound.
  
  
 (2) send this sound to FMSound as argument to the lowMajorScaleOn: keyword
  
  
 message.
  
  
 (3) play the resulting sound.""
  
 Example.
  
 The message
  (65@325 extent: 134 @ 100) center
  returns the center
  
 of a rectangle whose top left point is (65
 ,
  325) and whose size is 134
 ×
 100. 
 Example 4.3 shows how the message is decomposed and sent. First the 
 message between parentheses is sent: it contains two binary messages
  65@325 
 and
  134@100
  that are sent first and return points, and a keyword message 
 extent:
  which is then sent and returns a rectangle. Finally the unary message 
 center
  is sent to the rectangle and a point is returned. Evaluating the message 
 without parentheses would lead to an error because the object
  100
  does not 
 understand the message
  center
 .",NA
4.4 ,NA,NA
Hints for identifying keyword messages,"Often beginners have problems understanding when they need to add paren-
 theses. Let’s see how keywords messages are recognized by the compiler.
  
 Parentheses or not?
  
 The characters
  [
 ,
  ]
 ,
  (
  and
  )
  delimit distinct areas. Within such an area, a 
 keyword message is the longest sequence of words terminated by
  :
  that is not 
 cut by the characters
  .
 , or
  ;
 . When the characters
  [
 ,
  ]
 ,
  (
  and
  )
  surround some 
 words with colons, these words participate in the keyword message local to 
 the area defined.
  
 In
  
 this
  
 example,
  
 there
  
 are
  
 two
  
 distinct
  
 keyword
  
 messages:
  
 rotatedBy:magnify:smoothing:
  and
  at:put:
 .
  
 aDict
  
  
 at: (rotatingForm
  
  
 rotateBy: angle
  
  
 magnify: 2
  
  
 smoothing: 1)
  
  
 put: 3
  
  
 The characters
  [
 ,
  ]
 ,
  (
  and
  )
  delimit distinct areas. Within 
 such an area, a keyword message is the longest sequence 
 of words terminated by
  :
  that is not cut by the characters 
 .
 , 
 or
  ;
 . When the characters
  [
 ,
  ]
 ,
  (
  and
  )
  surround some 
 words 
 with colons, these words participate in the keyword 
 message local to the area defined.
  
  
 Hints.
  
 If you have problems with these precedence rules, you may start sim-
  
 ply by putting parentheses whenever you want to distinguish two messages 
 having the same precedence.
  
 The following piece of code does not require parentheses because the 
 message send
  x isNil
  is unary hence is sent prior to the keyword message 
 ifTrue:
 .
  
 (x isNil)
  
  
 ifTrue:[...]
  
  
 The following piece of code requires parentheses because the messages 
 includes:
  and
  ifTrue:
  are both keyword messages.",NA
4.5,NA,NA
Expression sequences,"Expressions (i.e., messages sends, assignments...) separated by periods are 
 evaluated in sequence. Note that there is no period between a variable 
 definition and the following expression. The value of a sequence is the value of 
 the last expression. The values returned by all the expressions except the last 
 one are ignored. Note that the period is a separator and not a terminator. 
 Therefore a final period is optional.
  
 | box |
  
  
 box := 20@30 corner: 60@90.
  
 true
  
 box containsPoint: 40@50
  
 −→",NA
Cascaded messages,"Understanding message 
 syntax",NA
4.6,"Smalltalk offers a way to send multiple messages to the same receiver using a 
 semicolon (
 ;
 ). This is called the cascade in Smalltalk jargon.
  
 Expression Msg1 ; Msg2
  
  
 Transcript show: 'Pharo is '. 
 Transcript show: 'fun '. 
  
 Transcript cr.
  
 is equivalent 
 to:
  
  
 Transcript
  
  
 show: 'Pharo is';
  
  
 show: 'fun ';
  
  
 cr
  
     
 Note that the object receiving the cascaded messages can itself be the result 
 of a message send. In fact the receiver of all the cascaded messages is the 
 receiver of the first message involved in a cascade. In the following example, 
 the first cascaded message is
  setX:setY
  since it is followed by a cascade. The 
 receiver of the cascaded message
  setX:setY:
  is the newly created point resulting 
 from the evaluation of
  Point new
 , and not
  Point
 . The subsequent message
  isZero 
 is 
 sent to that same receiver.
  
 Point new setX: 25 setY: 35; isZero
  
 −→
  
 false",NA
4.7,NA,NA
Chapter summary,"• A message is always sent to an object named the receiver which may be 
  
 the result of other message sends.
  
 • Unary messages are messages that do not require any argument. 
 They are of the form of
  receiver
  selector
 .
  
 •
  Binary messages are messages that involve two objects, the receiver and 
 another object and whose selector is composed of one or more characters 
 from the following list:
  +
 ,
  −
 ,
  *
 ,
  /
 ,
  |
 , &,
  =
 ,
  >
 ,
  <
 , ˜, and
  @
 . They are of the form:
  
 receiver
  selector
  argument
  
 •
  Keyword messages are messages that involve more than one object and 
  
 that contain at least one colon character (
 :
 ).
  
 They are of the form:
  receiver
  selectorWordOne:
  argumentOne
  wordTwo: 
 argumentTwo
  
 •
  Rule One.
  Unary messages are sent first, then binary messages, and 
  
 finally keyword messages.",NA
Part II ,NA,NA
Developing in Pharo,NA,NA
Chapter 5,NA,NA
The Smalltalk object model,"Smalltalk’s programming model is simple and uniform: everything is an ob-
 ject, and objects communicate only by sending each other messages. However, 
 this simplicity and uniformity can be a source of difficulty for programmers 
 used to other languages. In this chapter we present the core concepts of the 
 Smalltalk object model; in particular we discuss the consequences of 
 representing classes as objects.",NA
5.1 ,NA,NA
The rules of the model,"The Smalltalk object model is based on a set of simple rules that are applied 
 uniformly. The rules are as follows:
  
 Rule 1
 . Everything is an object.
  
 Rule 2
 . Every object is an instance of a class.
  
 Rule 3
 . Every class has a superclass.
  
 Rule 4
 . Everything happens by sending messages.
  
 Rule 5
 . Method lookup follows the inheritance chain.
  
 Let us look at each of these rules in some detail.",NA
5.2 ,NA,NA
Everything is an Object,"The mantra “everything is an object” is highly contagious. After only a short 
 while working with Smalltalk, you will start to be surprised at how this rule",NA
5.3 ,NA,NA
Every object is an instance of a class,"Every object has a class; you can find out which by sending it the message 
 class
 .
  
 1 class
  
 −→
  
 SmallInteger
  
 20 factorial class
  
 −→
  
 LargePositiveInteger
  
 'hello' class
  
 −→
  
 ByteString
  
 #(1 2 3) class
  
 −→
  
 Array
  
 (4@5) class
  
 −→
  
 Point
  
 Object new class
  
 −→
  
 Object
  
 A class defines the structure of its instances via instance variables, and the 
 behavior of its instances via methods. Each method has a name, called its 
 selector, which is unique within the class.
  
 Since classes are objects, and every object is an instance of a class, it follows 
 that 
 classes must also be instances of classes. A class whose instances are 
 classes is called a metaclass. Whenever you create a class, the system 
 automatically 
 creates a metaclass for you. The metaclass defines the structure 
 and behavior",NA
5.4 ,NA,NA
Every class has a superclass,"Each class in Smalltalk inherits its behaviour and the description of its struc-
 ture from a single superclass. This means that Smalltalk has single inheritance.
  
 SmallInteger superclass
  
 −→
  
 Integer
  
 Integer superclass
  
 −→
  
 Number
  
 Number superclass
  
 −→
  
 Magnitude
  
 Magnitude superclass
  
 −→
  
 Object
  
 Object superclass
  
 −→
  
 ProtoObject
  
 ProtoObject superclass
  
 −→
  
 nil",NA
5.5 ,NA,NA
Everything happens by sending messages,"This rule captures the essence of programming in Smalltalk.
  
 In procedural programming, the choice of which piece of code to execute 
 when a procedure is called is made by the caller. The caller chooses the 
 procedure or function to execute statically, by name.
  
 In object-oriented programming, we do not “call methods”: we “send 
 messages.” The choice of terminology is significant. Each object has its own 
 responsibilities. We do not tell an object what to do by applying some 
 procedure to it. Instead, we politely ask an object to do something for us by 
 sending it a message. The message is not a piece of code: it is nothing but a 
 name and a list of arguments. The receiver then decides how to respond by 
 selecting its own method for doing what was asked. Since different objects 
 may have different methods for responding to the same message, the method 
 must be chosen dynamically, when the message is received.
  
 3 + 4
  
 −→
  
 7
  
 ""send message + with argument 4 to integer 3""
  
 (1@2) + 4
  
 −→
  
 5@6
  
 ""send message + with argument 4 to point (1@2)""
  
 As a consequence, we can send the same message to different objects, each of 
 which may have its own method for responding to the message. We do not tell 
 the
  SmallInteger 3
  or the
  Point 1@2
  how to respond to the message
  + 4
 . Each has 
 its own method for
  +
 , and responds to
  + 4
  accordingly.
  
 One of the consequences of Smalltalk’s model of message sending is that it 
 encourages a style in which objects tend to have very small methods and 
 delegate tasks to other objects, rather than implementing huge, procedural 
 methods that assume too much responsibility. Joseph Pelrine expresses this 
 principle succinctly as follows:
  
 Don’t do anything that you can push off onto someone else.
  
 Many object-oriented languages provide both static and dynamic opera-
 tions for objects; in Smalltalk there are only dynamic message sends. Instead of 
 providing static class operations, for instance, classes are objects and we 
 simply send messages to classes.
  
  
 Nearly everything in Smalltalk happens by sending messages. At some 
 point action must take place:",NA
5.6,NA,NA
Method lookup follows the inheritance chain,"What exactly happens when an object receives a message?
  
 The process is quite simple: the class of the receiver looks up the method to 
 use to handle the message. If this class does not have a method, it asks its 
 superclass, and so on, up the inheritance chain. When the method is found, the 
 arguments are bound to the parameters of the method, and the virtual 
 machine executes it.
  
  
 It is essentially as simple as this. Nevertheless there are a few questions 
 that need some care to answer:
  
 • What happens when a method does not explicitly return a value?
  
 • What happens when a class reimplements a superclass method?
  
 • What is the difference between
  self
  and
  super
  sends?
  
 • What happens when no method is found?
  
 The rules for method lookup that we present here are conceptual: virtual 
 machine implementors use all kinds of tricks and optimizations to speed-up",NA
5.7 ,NA,NA
Shared variables,"Now we will look at an aspect of Smalltalk that is not so easily covered by our 
 five rules: shared variables.
  
 Smalltalk provides three kinds of shared variables: (1) globally shared 
 variables; (2) variables shared between instances and classes (class variables), 
 and (3) variables shared amongst a group of classes (pool variables). The names 
 of all of these shared variables start with a capital letter, to warn us that they 
 are indeed shared between multiple objects.",NA
5.8 ,NA,NA
Chapter summary,"The object model of Pharo is both simple and uniform. Everything is an object, 
 and pretty much everything happens by sending messages.
  
 • Everything is an object. Primitive entities like integers are objects, but 
  
 also classes are first-class objects.
  
 • Every object is an instance of a class. Classes define the structure of their 
 instances via private instance variables and the behaviour of their 
 instances via public methods. Each class is the unique instance of its 
 metaclass. Class variables are private variables shared by the class and 
 all the instances of the class. Classes cannot directly access instance vari-
 ables of their instances, and instances cannot access instance variables of 
 their class. Accessors must be defined if this is needed.
  
 • Every class has a superclass. The root of the single inheritance hier-archy 
 is
  ProtoObject
 . Classes you define, however, should normally inherit from
  
 Object
  or its subclasses. There is no syntax for defining abstract classes. 
 An abstract class is simply a class with an abstract method — one whose 
 implementation consists of the expression
  self subclassResponsibility
 . 
 Although Pharo supports only single inheritance, it is easy to share 
 implementations of methods by packaging them as traits.
  
 • Everything happens by sending messages. We do not “call methods”, we 
 “send messages”. The receiver then chooses its own method for 
 responding to the message.",NA
Chapter 6,NA,NA
The Pharo programming,NA,NA
environment,"The goal of this chapter is to show you how to develop programs in the Pharo 
 programming environment. You have already seen how to define methods 
 and classes using the browser; this chapter will show you more of the features 
 of the browser, and introduce you to some of the other browsers.
  
 Of course, very occasionally you may find that your program does not 
 work as you expect. Pharo has an excellent debugger, but like most powerful 
 tools, it can be confusing on first use. We will walk you through a debugging 
 session and demonstrate some of the features of the debugger.
  
 One of the unique features of Smalltalk is that while you are programming, 
 you are living in a world of live objects, not in a world of static program text. 
 This makes it possible to get very rapid feedback while programming, which 
 makes you more productive. There are two tools that let you look at, and 
 indeed change, live objects: the inspector and the explorer.
  
 The consequence of programming in a world of live objects rather than 
 with files and a text editor is that you have to do something explicit to export 
 your program from your Smalltalk image. The old way of doing this, also 
 supported by all Smalltalk dialects, is by creating a fileout or a change set, 
 which are essentially encoded text files that can be imported into another 
 system. The new way of doing this in Pharo is to upload your code to a 
 versioned repository on a server. This is done using a tool called Monticello, 
 and is a much more powerful and effective way to work, especially when 
 working in a team.",NA
Overview,The Pharo programming environment,NA
6.1,"Smalltalk and modern graphical interfaces were developed together. Even 
 before the first public release of Smalltalk in 1983, Smalltalk had a self-hosting 
 graphical development environment, and all Smalltalk development was 
 taking place in it. Let’s start by looking at the main tools in Pharo.
  
 • The
  Browser
  is the central development tool. You will use it to create, 
 define, and organize your classes and methods. Using it you can also 
 navigate through all the library classes: unlike other environments 
 where the source code is stored in separate files, in Smalltalk all classes 
 and methods are contained in the image.
  
 • The
  Message Names
  tool is used to look at all of the methods with a 
 particular selector, or with a selector containing a substring.
  
 • The
  Method Finder
  tool will also let you find methods, but according to 
 what they do as well as what they are called.
  
 • The
  Monticello Browser
  is the starting point for loading code from, and 
  
 saving code in, Monticello packages.
  
 • The
  Process Browser
  provides a view on all of the processes (threads) 
  
 executing in Smalltalk.
  
 • The
  Test Runner
  lets you run and debug SUnit tests, and is described in 
  
 Chapter 7.
  
 • The
  Transcript
  is a window on the
  Transcript
  output stream, which is useful 
 for writing log messages and has already been described in Section 1.5.
  
 • The
  Workspace
  is a window into which you can type input. It can be used 
 for any purpose, but is most often used for typing Smalltalk 
 expressions 
 and executing them as
  do it
 s. The use of the workspace was 
 also 
 illustrated in Section 1.5.
  
 The
  Debugger
  has an obvious role, but you will discover that it has a 
 more 
 central place compared to debuggers for other programming languages, 
 because in Smalltalk you can program in the debugger. The debugger is not 
 launched from a menu; it is normally entered by running a failing test, by 
 typing
  CMD
 –
 .
  to interrupt a running process, or by inserting a
  self halt 
 expression in code.",NA
6.2 ,NA,NA
The Browser,"Many different class browsers have been developed over the years for 
 Smalltalk. Pharo simplifies this story by offering a single browser that inte-
 grates various views. Figure 6.1 shows the browser as it appears when you 
 first open it.
 1
  
  
 Figure 6.1: The Browser
  
 The four small panes at the top of the browser represent a hierarchic view 
 of 
 the methods in the system, much in the same way as the NeXTstep File Viewer 
 and the Mac OS X Finder in column mode provide a view of the files on the 
 disk. The leftmost pane lists packages of classes; select one (say
  Kernel
 ) 
 and the 
 pane immediately to the right will then show all of the classes in that 
 package.
  
 Similarly, if you select one of the classes in the second pane, say,
  Model 
 (see 
 Figure 6.2), the third pane will show all of the protocols defined for that 
 class, 
 as well as a virtual protocol
  --all--
 , which is selected by default. Protocols are a 
 way of categorizing methods; they make it easier to find and think about 
 the 
 behaviour of a class by breaking it up into smaller, conceptually coherent 
 pieces. The fourth pane shows the names of all of the methods defined in the 
 selected protocol. If you then select a method name, the source code of the 
 corresponding method appears in the large pane at the bottom of the browser, 
 where you can view it, edit it, and save the edited version. If you select class
  
  
 1
 Recall that if the browser you get does not look like the one shown in Figure 1.12, then you 
 may need to change the default browser. See FAQ 5, p. 318.",NA
6.3 ,NA,NA
Monticello,"We gave you a quick overview of Monticello, Pharo’s packaging tool, in 
 Section 
 2.9. However, Monticello has many more features than were discussed 
 there. 
 Because Monticello manages packages, before telling you more about 
 Monticello, it’s important that we first explain exactly what a package is.
  
 Packages: declarative categorization of Pharo code
  
 We have pointed out earlier, in Section 2.3 that packages are more or less 
 equivalent to categories. Now we will see exactly what the relationship is. The 
 package system is a simple, lightweight way of organizing Smalltalk source 
 code that exploits a simple naming convention for categories and protocols.
  
   
 Let’s explain this using an example. 
  
 Suppose that you are develop-ing 
 a framework named to facilitate the use of relational databases from Pharo. 
 You have decided to call your framework
  PharoLink
 , and have cre-ated a series 
 of categories to contain all of the classes that you have written, 
 e.g., category
  
 'PharoLink−Connections'
  contains
  OracleConnection MySQLConnection 
 PostgresConnection
  and category
  'PharoLink−Model'
  contains
  DBTable DBRow 
 DBQuery
 , and so on. However, not all of your code will reside in these classes. 
 For 
 example, you may also have a series of methods to convert objects into an SQL-
 friendly format:
  
 Object»asSQL
  
  
 String»asSQL
  
  
 Date»asSQL
  
 These methods belong in the same package as the classes in the categories 
 PharoLink−Connections
  and
  PharoLink−Model
 . But clearly the whole of class
  Object 
 does not belong in your package! So you need a way of putting certain 
 methods in a package, even though the rest of the class is in another package.
  
 The way that you do this is by placing those methods in a protocol (of 
 Object
 ,
  String
 ,
  Date
 , and so on) named
  *PharoLink
  (note the initial asterisk). The 
 combination of the
  PharoLink-. . .
  categories and the
  *PharoLink
  protocols form a 
 package named
  PharoLink
 . To be precise, the rules for what goes in a package 
 are as follows.
  
 A package named
  Foo
  contains:
  
 1. all class definitions of classes in the category
  Foo
 , or in categories with 
  
 names starting with
  Foo-
 , and
  
 2. all methods in any class in protocols named
  *Foo
  or
  *foo
 4
 , or whose name
  
 4
 When performing this comparison, the case of the letters in the names is ignored.",NA
6.4 ,NA,NA
The Inspector and the Explorer,"One of the things that makes Smalltalk so different from many other pro-
 gramming environments is that it is provides you with a window onto a world 
 of live objects, not a world of static code. Any of those objects can be examined 
 by the programmer, and even changed — although some care is necessary 
 when changing the basic objects that support the system. By all means 
 experiment, but save your image first!
  
 The Inspector
  
 As an illustration of what you can do with an inspector, type
  TimeStamp now 
 in a workspace, and then action-click and choose
  inspect it
 .
  
 (It’s not necessary to select the text before using the menu; if no text is 
 selected, the menu operations work on the whole of the current line. You can 
 also type
  CMD
 –i for
  i
 nspect it
 .)
  
 A window like that shown in Figure 6.22 will appear. This is an inspector, 
 and can be thought of as a window onto the internals of a particular object —
 in this case, the particular instance of
  TimeStamp
  that was created when you",NA
6.5 ,NA,NA
The Debugger,"The debugger is arguably the most powerful tool in the Pharo tool suite. It is 
 used not just for debugging, but also for writing new code. To demonstrate 
 the debugger, let’s start by creating a bug!
  
 Using the browser, add the following method to the class
  String
 :
  
 Method 6.1: A buggy method
  
 suffix
  
  
 ""assumes that I'm a file name, and answers my suffix, the part after the last dot""
  
  
 | dot dotPosition |
  
  
 dot := FileDirectory dot.
  
  
 dotPosition := (self size to: 1 by: −1) detect: [ :i | (self at: i) = dot ].
  
  
 ↑
  self copyFrom: dotPosition to: self size",NA
6.6 ,NA,NA
The Process Browser,"Smalltalk is a multi-threaded system: there are many lightweight processes 
 (also known as threads) running concurrently in your image. In the future 
 the 
 Pharo virtual machine may take advantage of multiprocessors when they 
 are 
 available, but at present concurrency is implemented by time-slicing.
  
 The process browser is a cousin of the debugger that lets you look at the 
 various processes running inside Pharo. Figure 6.33 shows a screenshot. The 
 top-left pane lists all of the processes in Pharo, in priority order, from the 
 timer interrupt watcher at priority 80 to the idle process at priority 10. Of 
 course, on a uniprocessor, the only process that can be running when you look 
 is the UI process; all others will be waiting for some kind of event. By 
 default, 
 the display of processes is static; it can be updated by action-clicking 
 and 
 selecting
  turn on auto-update (a)
  
 If you select a process in the top-left pane, its stack trace is displayed in 
 the top-right pane, just as with the debugger. If you select a stack frame, the 
 corresponding method is displayed in the bottom pane. The process browser is 
 not equipped with mini-inspectors for
  self
  and
  thisContext
 , but action-clicking 
 on 
 the stack frames provide equivalent functionality.",NA
6.7 ,NA,NA
Finding methods,"There are two tools in Pharo to help you find messages. They differ in both 
 interface and functionality.
  
 The method finder was described at some length in Section 1.9; you can 
 use it to find methods by name or by functionality. However, to look at the 
 body of a method, the method finder opens a new browser. This can quickly 
 become overwhelming.
  
 The message names browser has more limited search functionality: you 
 type a fragment of a message selector in the search box, and the browser lists all 
 methods that contain that fragment in their names, as shown in Figure 6.34. 
 However, it is a full-fledged browser: if you select one of the names in the left 
 pane, all of the methods with that name are listed in the right pane, and 
 can be 
 browsed in the bottom pane. As with the browser, the message names 
 browser 
 has a button bar that can be used to open other browsers on the selected 
 method or its class.",NA
6.8 ,NA,NA
Change sets and the Change Sorter,"Whenever you are working in Pharo, any changes that you make to meth-ods 
 and classes are recorded in a
  change set
 . This includes creating new classes, re-
 naming classes, changing categories, adding methods to existing classes — just 
 about everything of significance. However, arbitrary doits are",NA
6.9 ,NA,NA
The File List Browser,"The file list browser is in fact a general-purpose tool for browsing the file 
 system (and also FTP servers) from Pharo. You can open it from the 
 World
 ⟨
  
 Tools . . .
  ⟨
  File Browser
  menu. What you see of course depends on the contents 
 of your local file system, but a typical view is shown in Figure 6.36.
  
 When you first open a file list browser it will be focussed on the current 
 directory, that is, the one from which you started Pharo. The title bar shows 
 the path to this directory. The larger pane on the left-hand side can be used to 
 navigate the file system in the conventional way. When a directory is selected, 
 the files that it contains (but not the directories) are displayed on the right. 
 This list of files can be filtered by entering a Unix-style pattern in the small box 
 at the top-left of the window. Initially, this pattern is
  *
 , which matches all file 
 names, but you can type a different string there and accept it, 
 changing the 
 pattern. (Note that a
  *
  is implicitly prepended and appended to the pattern that 
  
 you type.) The sort order of the files can be changes using the
  
  
 name
  ,
  date
  and
  size
  buttons. The rest of the buttons depend on the name
  
  
  
  
   
 of the file selected in the browser. In Figure 6.36, the file name has the suffix",NA
6.10 ,NA,NA
"In Smalltalk, you can’t lose code","It is quite possible to crash Pharo: as an experimental system, Pharo lets you 
 change anything, including things that are vital to make Pharo work!
  
 To maliciously crash Pharo, try
  Object become: nil
 .
  
 The good news is that you need never lose any work, even if you crash and 
 go back to the last saved version of your image, which might be hours old. 
 This is because all of the code that you executed is saved in the .changes file. 
 All of it! This includes one liners that you evaluate in a workspace, as well as 
 code that you add to a class while programming.
  
 So here are the instructions on how to get your code back. There is no 
 need to read this until you need it. However, when you do need it, you’ll find 
 it 
 here waiting for you.
  
 In the worst case, you can use a text editor on the .changes file, but since it 
 is 
 many megabytes in size, this can be slow and is not recommended. Pharo 
 offers you better ways.
  
 How to get your code back
  
 Restart
  
 Pharo
  
 from
  
 the
  
 most
  
 recent
  
 snapshot,
  
 and
  
 selec
 t
  
 World
 ⟨
  Tools . . .
  ⟨
  Recover lost changes
 .
  
 This will give the opportunity to decide how far back in history you",NA
6.11 ,NA,NA
Chapter summary,"In order to develop effectively with Pharo, it is important to invest some effort 
 into learning the tools available in the environment.
  
 • The standard browser is your main interface for browsing existing cate-
 gories, classes, method protocols and methods, and for defining new 
 ones. The browser offers several useful buttons to directly jump to 
 senders or implementors of a message, versions of a method, and so on.
  
 • There exist several different browsers (such as the OmniBrowser and the 
 Refactoring Browser), and several specialized browsers (such as the 
 hierarchy browser) which provide different views of classes and 
 methods.
  
 •
  From any of the tools, you can highlight the name of a class or a method 
 and immediately jump to a browser by using the keyboard shortcut 
 CMD
 –b.",NA
Chapter 7,NA,NA
SUnit,NA,NA
7.1 ,NA,NA
Introduction,"SUnit is a minimal yet powerful framework that supports the creation and 
 deployment of tests. As might be guessed from its name, the design of SUnit 
 focussed on Unit Tests, but in fact it can be used for integration tests and 
 functional tests as well. SUnit was originally developed by Kent Beck and 
 subsequently extended by Joseph Pelrine and others to incorporate the notion 
 of a resource, which we will describe in Section 7.6.
  
 The interest in testing and Test Driven Development is not limited to Pharo 
 or Smalltalk. Automated testing has become a hallmark of the Agile software 
 development movement, and any software developer concerned with 
 improving software quality would do well to adopt it. Indeed, devel-opers in 
 many languages have come to appreciate the power of unit testing, and 
 versions of
  x
 Unit now exist for many languages, including Java, Python, Perl, 
 .Net and Oracle. This chapter describes SUnit 3.3 (the current version as of this 
 writing); the official web site of SUnit is
  sunit.sourceforge.net
 , where updates can 
 be found.
  
 Neither testing, nor the building of test suites, is new: everybody knows 
 that tests are a good way to catch errors. eXtreme Programming, by making 
 testing a core practice and by emphasizing automated tests, has helped to make 
 testing productive and fun, rather than a chore that programmers dislike. The 
 Smalltalk community has a long tradition of testing because of the incre-
 mental style of development supported by its programming environment. In 
 traditional Smalltalk development, the programmer would write tests in a 
 workspace as soon as a method was finished. Sometimes a test would be 
 incorporated as a comment at the head of the method that it exercised, or tests 
 that needed some set up would be included as example methods in the class. 
 The problem with these practices is that tests in a workspace are",NA
7.2 ,NA,NA
Why testing is important,"Unfortunately, many developers believe that tests are a waste of their time. 
 After all, they do not write bugs — only other programmers do that. Most of us 
 have said, at some time or other: “I would write tests if I had more time.”
 If you 
 never write a bug, and if your code will never be changed in the future, 
 then 
 indeed tests are a waste of your time. However, this most likely also means 
 that your application is trivial, or that it is not used by you or anyone 
 else. 
 Think of tests as an investment for the future: having a suite of tests will 
 be 
 quite useful now, but it will be extremely useful when your application, or the 
 environment in which it executes, changes in the future.
  
 Tests play several roles. First, they provide documentation of the func-
 tionality that they cover. Moreover, the documentation is active: watching the 
 tests pass tells you that the documentation is up-to-date. Second, tests help 
 developers to confirm that some changes that they have just made to a 
 package have not broken anything else in the system — and to find the parts 
 that break when that confidence turns out to be misplaced. Finally, 
 writing 
 tests at the same time as — or even before — programming forces you 
 to think 
 about the functionality that you want to design, and how it should 
 appear to 
 the client, rather than about how to implement it. By writing the tests first — 
 before the code — you are compelled to state the context in which your 
 functionality will run, the way it will interact with the client code, and the 
 expected results. Your code will improve: try it.",NA
7.3 ,NA,NA
What makes a good test?,"Writing good tests is a skill that can be learned most easily by practicing. Let 
 us look at the properties that tests should have to get a maximum benefit.
  
 1. Tests should be repeatable. You should be able to run a test as often as 
 you want, and always get the same answer.
  
 2.
  Tests should run without human intervention. You should even be able 
  
 to 
 run them during the night.
  
 3. Tests should tell a story. Each test should cover one aspect of a piece of 
 code. A test should act as a scenario that you or someone else can read 
 to understand a piece of functionality.
  
 4.
  Tests should have a change frequency lower than that of the functional-
 ity 
 they cover: you do not want to have to change all your tests every time 
 you modify your application. One way to achieve this is to write tests 
 based on the public interfaces of the class that you are testing. It is OK to 
 write a test for a private “helper” method if you feel that the method is 
 complicated enough to need the test, but you should be 
 aware that such a 
 test may have to be changed, or thrown away entirely, 
 when you think of 
 a better implementation.
  
 A consequence of property (3) is that the number of tests should be some-
 what proportional to the number of functions to be tested: changing one 
 aspect of the system should not break all the tests but only a limited number. 
 This is important because having 100 tests fail should send a much stronger 
 message than having 10 tests fail. However, it is not always possible to achieve 
 this ideal: in particular, if a change breaks the initialization of an object, or the 
 set-up of a test, it is likely to cause all of the tests to fail.
  
 eXtreme Programming advocates writing tests before writing code. This 
 may seem to go against our deep instincts as software developers. All we can 
 say is: go ahead and try it. We have found that writing the tests before the 
 code helps us to know what we want to code, helps us know when we are 
 done, and helps us conceptualize the functionality of a class and to design its",NA
7.4 ,NA,NA
SUnit by example,"Before going into the details of SUnit, we will show a step by step example. We 
 use an example that tests the class
  Set
 . Try entering the code as we go along.
  
 Step 1: create the test class
  
 First you should create a new subclass of
  TestCase
  called
  ExampleSetTest
 . Add 
 two instance variables so that your new class looks like this:
  
 Class 7.1: An Example Set Test class
  
 TestCase subclass: #ExampleSetTest
  
  
 instanceVariableNames: 'full empty'
  
  
 classVariableNames: ''
  
  
 poolDictionaries: ''
  
  
 category: 'MySetTest'
  
 We will use the class
  ExampleSetTest
  to group all the tests related to the 
 class
  Set
 . It defines the context in which the tests will run. Here the context is 
 described by the two instance variables
  full
  and
  empty
  that we will use to 
 represent a full and an empty set.
  
 The name of the class is not critical, but by convention it should end in
  Test
 . 
 If you define a class called
  Pattern
  and call the corresponding test class
  
 PatternTest
 , the two classes will be alphabetized together in the browser 
 (assuming that they are in the same category). It is critical that your class be a 
 subclass of
  TestCase
 .
  
 Step 2: initialize the test context
  
 The method
  setUp
  defines the context in which the tests will run, a bit like an 
 initialize method.
  setUp
  is invoked before the execution of each test method 
 defined in the test class.
  
 Define the
  setUp
  method as follows, to initialize the
  empty
  variable to refer to 
 an 
 empty set and the
  full
  variable to refer to a set containing two elements.",NA
7.5 ,NA,NA
The SUnit cook book,"This section will give you more details on how to use SUnit. If you have used 
 another testing framework such as JUnit
 1
 , much of this will be familiar, since all 
 these frameworks have their roots in SUnit. Normally you will use SUnit’s 
 GUI 
 to run tests, but there are situations where you may not want to use it.
  
 Other assertions
  
 In addition to
  assert:
  and
  deny:
 , there are several other methods that can be used 
 to make assertions.
  
 First,
  assert:description:
  and
  deny:description:
  take a second argument which is 
 a message string that can be used to describe the reason for the failure, if it 
 is 
 not obvious from the test itself. These methods are described in Section 7.7.
  
 Next,
  
 SUnit provides two additional methods,
  
 should:raise:
  and
  
 shouldnt:raise:
  for testing exception propagation. For example, you would use 
 (self should: aBlock raise: anException)
  to test that a particular exception is raised 
 during the execution of
  aBlock
 . Method 7.6 illustrates the use of
  should:raise:
 .
  
 Try running this test.
  
  
 Note that the first argument of the
  should:
  and
  shouldnt:
  methods is a block 
 that contains the expression to be evaluated.
  
 Method 7.6: Testing error raising
  
 ExampleSetTest»testIllegal
  
  
 self should: [empty at: 5] raise: Error.
  
  
 self should: [empty at: 5 put: #zork] raise: Error
  
 SUnit is portable: it can be used from all dialects of Smalltalk. To make 
 SUnit portable, its developers factored-out the dialect-dependent aspects. The 
 class method
  TestResult class»error
  answers the system’s error class in a
  
 1
 http://junit.org",NA
7.6 ,NA,NA
The SUnit framework,"SUnit consists of four main classes: 
 TestCase
 ,
  TestSuite
 ,
  TestResult
 , and 
 TestResource
 , as shown in Figure 7.3. The notion of a test resource was in-",NA
7.7,NA,NA
Advanced features of SUnit,"In addition to
  TestResource
 , the current version of SUnit contains assertion
  
 description strings, logging support, and resumable test failures.
  
 Assertion description strings
  
 The
  TestCase
  assertion protocol includes a number of methods that allow the
  
 programmer to supply a description of the assertion. The description is a
  
 String
 ; if the test case fails, this string will be displayed by the test runner. Of
  
 course, this string can be constructed dynamically.
  
  
 | e |
  
  
 e := 42.
  
 self assert: e = 23
  
  
 description: 'expected 23, got ', e printString
  
 The relevant methods in
  TestCase
  are:
  
  
 #assert:description:
  
  
 #deny:description:
  
  
 #should:description:
  
 #shouldnt:description:
  
 Logging support
  
 The description strings described above may also be logged to a
  Stream
  such
  
 as the
  Transcript
 , or a file stream. You can choose whether to log by overriding
  
 TestCase»isLogging
  in your test class; you must also choose where to log by
  
 overriding
  TestCase»failureLog
  to answer an appropriate stream.
  
 Continuing after a failure
  
 SUnit also allows us to specify whether or not a test should continue after a
  
 failure. This is a really powerful feature that uses the exception mechanisms",NA
7.8 ,NA,NA
The implementation of SUnit,"The implementation of SUnit makes an interesting case study of a Smalltalk 
 framework. Let’s look at some key aspects of the implementation by following 
 the execution of a test.
  
 Running one test
  
 To execute one test, we evaluate the expression
  (aTestClass selector: aSymbol) run.
  
 The method
  TestCase»run
  creates an instance of
  TestResult
  that will accu-
 mulate the results of the tests, then it sends itself the message
  run:
 . (See Figure 
 7.4.)
  
 Method 7.9: Running a test case
  
 TestCase»run
  
  
 | result |
  
  
 result := TestResult new.
  
  
 self run: result.
  
  
 ↑
 result",NA
7.9,NA,NA
Some advice on testing,"While the mechanics of testing are easy, writing good tests is not. Here is some 
 advice on how to design tests.
  
 Feathers’ Rules for Unit tests.
  Michael Feathers, an agile process consultant 
  
 and author, writes:
 3
  
 A test is not a unit test if:
  
 • it talks to the database,
  
 • it communicates across the network,
  
 • it touches the file system,
  
 •
  it can’t run at the same time as any of your other unit tests, or
  
 • you have to do special things to your environment (such as 
  
 editing config files) to run it.
  
 3
 See
  http://www.artima.com/weblogs/viewpost.jsp?thread=126923
 . 9 September 2005",NA
7.10 ,NA,NA
Chapter summary,"This chapter explained why tests are an important investment in the future of 
 your code. We explained in a step-by-step fashion how to define a few tests for 
 the class
  Set
 . Then we gave an overview of the core of the SUnit framework by 
 presenting the classes
  TestCase
 ,
  TestResult
 ,
  TestSuite
  and
  TestResources
 . Finally",NA
Chapter 8,NA,NA
Basic Classes,"Most of the magic of Smalltalk is not in the language but in the class libraries. 
 To 
 program effectively with Smalltalk, you need to learn how the class li-
 braries 
 support the language and environment. The class libraries are entirely written 
 in Smalltalk and can easily be extended since a package may add new 
 functionality to a class even if it does not define this class.
  
 Our goal here is not to present in tedious detail the whole of the Pharo 
 class library, but rather to point out the key classes and methods that you will 
 need to use or override to program effectively. In this chapter we cover the 
 basic classes that you will need for nearly every application:
  Object
 ,
  Number 
 and 
 its subclasses,
  Character
 ,
  String
 ,
  Symbol
  and
  Boolean
 .",NA
8.1 ,NA,NA
Object,"For all intents and purposes,
  Object
  is the root of the inheritance hierarchy. 
 Actually, in Pharo the true root of the hierarchy is
  ProtoObject
 , which is used to 
 define minimal entities that masquerade as objects, but we can ignore this 
 point for the time being.
  
 Object
  can be found in the
  Kernel-Objects
  category. Astonishingly, there are 
 some 400 methods to be found here (including extensions). In other words, 
 every class that you define will automatically provide these 400 methods, 
 whether you know what they do or not. Note that some of the methods should 
 be removed and new versions of Pharo may remove some of the superfluous 
 methods.
  
 The class comment for the
  Object
  states:",NA
8.2 ,NA,NA
Numbers,"Remarkably, numbers in Smalltalk are not primitive data values but true 
 objects. Of course numbers are implemented efficiently in the virtual machine, 
 but the
  Number
  hierarchy is as perfectly accessible and extensible as any other 
 portion of the Smalltalk class hierarchy.
  
 Object
  
 Magnitude
  
 Number
  
 Float
  
 Fraction
  
 Integer
  
  
 SmallInteger
  
 LargePositiveInteger
  
 LargeNegativeInteger
  
 Figure 8.1: The Number Hierarchy
  
 Numbers are found in the
  Kernel-Numbers
  category. The abstract root of this 
 hierarchy is
  Magnitude
 , which represents all kinds of classes supporting 
 comparision operators.
  Number
  adds various arithmetic and other operators as 
 mostly abstract methods.
  Float
  and
  Fraction
  represent, respectively, floating 
 point numbers and fractional values.
  Integer
  is also abstract, thus distinguish-
 ing between subclasses
  SmallInteger
 ,
  LargePositiveInteger
  and
  LargeNegativeInteger
 . 
 For the most part users do not need to be aware of the difference between the 
 three
  Integer
  classes, as values are automatically converted as needed.
  
 Magnitude
  
 Magnitude
  is the parent not only of the
  Number
  classes, but also of other classes 
 supporting comparison operations, such as
  Character
 ,
  Duration
  and
  Timespan
 .
  
 (
 Complex
  numbers are not comparable, and so do not inherit from
  Number
 .)",NA
8.3,NA,NA
Characters,"Character
  is defined in the
  Collections-Strings
  category as a subclass of
  Magnitude
 . 
 Printable characters are represented in Pharo as
  $
 ⟨
 char
 ⟨
 . For example:
  
 $a < $b
  
 −→
  
 true
  
 Non-printing characters can be generated by various class methods. 
 Character class»value:
  takes the Unicode (or ASCII) integer value as argument and 
 returns the corresponding character. The protocol
  accessing untypeable characters
  
 contains a number of convenience constructor methods such as 
 backspace
 ,
  cr
 ,
  
 escape
 ,
  euro
 ,
  space
 ,
  tab
 , and so on.
  
 Character space = (Character value: Character space asciiValue)
  
 −→
  
 true
  
  
 The
  printOn:
  method is clever enough to know which of the three ways to 
 generate characters offers the most appropriate representation:
  
 Character value: 1
  
 −→
  
 Character home
  
 Character value: 2
  
 −→
  
 Character value: 2
  
 Character value: 32
  
 −→
  
 Character space
  
 Character value: 97
  
 −→
  
 $a
  
  
 Various convenient testing methods are built in:
  isAlphaNumeric
 ,
  isCharacter
 , 
 isDigit
 ,
  isLowercase
 ,
  isVowel
 , and so on.",NA
8.4,NA,NA
Strings,"The
  String
  class is also defined in the category
  Collections-Strings
 . A
  String
  is an 
 indexed
  Collection
  that holds only
  Characters
 .
  
 Object
  
 Collection
  
 SequenceableCollection
  
 ArrayedCollection
  
 Array 
  
 String 
 Text
  
 ByteString Symbol
  
 Figure 8.2: The String Hierarchy
  
  
 In fact,
  String
  is abstract and Pharo
  Strings
  are actually instances of the 
 concrete class
  ByteString
 .
  
 'hello world' class
  
 −→
  
 ByteString",NA
8.5 ,NA,NA
Booleans,"The class
  Boolean
  offers a fascinating insight into how much of the Smalltalk 
 language has been pushed into the class library.
  Boolean
  is the abstract super-
 class of the
  Singleton
  classes
  True
  and
  False
 .
  
  
 Most of the behaviour of
  Boolean
 s can be understood by considering the 
 method
  ifTrue:ifFalse:
 , which takes two
  Blocks
  as arguments.",NA
8.6 ,NA,NA
Chapter summary,"• If you override
  =
  then you should override
  hash
  as well.
  
 • Override
  postCopy
  to correctly implement copying for your objects.• 
 Send
  self halt
  to set a breakpoint.
  
 • Return
  self subclassResponsibility
  to make a method abstract.
  
 • To give an object a
  String
  representation you should override
  printOn:
 .
  
 • Override the hook method
  initialize
  to properly initialize instances.•
  Number
  
 methods automatically convert between
  Floats
 ,
  Fractions
  and 
  
 Integers
 .
  
 •
  Fractions
  truly represent rational numbers rather than floats.
  
 •
  Characters
  are unique instances.
  
 •
  Strings
  are mutable;
  Symbols
  are not. Take care not to mutate string 
  
 literals, however!
  
 •
  Symbols
  are unique;
  Strings
  are not.
  
 •
  Strings
  and
  Symbols
  are
  Collections
  and therefore support the usual 
  
 Collection
  methods.",NA
Chapter 9,NA,NA
Collections,NA,NA
9.1 ,NA,NA
Introduction,"The collection classes form a loosely-defined group of general-purpose sub-
 classes of
  Collection
  and
  Stream
 . The group of classes that appears in the “Blue 
 Book”
 1
 contains 17 subclasses of
  Collection
  and 9 subclasses of
  Stream
 , for a total 
 of 28 classes, and had already been redesigned several times before the 
 Smalltalk-80 system was released. This group of classes is often considered to 
 be a paradigmatic example of object-oriented design.
  
    
 In Pharo, the abstract class
  Collection
  has 101 subclasses, and the abstract 
 class
  Stream
  has 50 subclasses, but many of these (like
  Bitmap
 ,
  FileStream
  and 
 CompiledMethod
 ) are special-purpose classes crafted for use in other parts of the 
 system or in applications, and hence not categorized as “Collections” by the 
 system organization. For the purposes of this chapter, we use the 
 term“Collection Hierarchy” to mean
  Collection
  and its 47 subclasses that are also 
 in the categories labelled
  Collections-*
 . We use the term “Stream Hierarchy”to 
 mean
  Stream
  and its 9 subclasses that are also in the
  Collections-Streams 
 categories. These 56 classes respond to 982 messages and define a total of 
 1609 methods!
  
  
 In this chapter we focus mainly on the subset of collection classes shown in 
 Figure 9.1. Streams will be discussed separately in Chapter 10.
  
  
 1
 Adele Goldberg and David Robson, Smalltalk 80: the Language and its Implementation. Reading, 
 Mass.: Addison Wesley, May 1983, ISBN 0–201–13688–0.",NA
9.2 ,NA,NA
The varieties of collections,"To make good use of the collection classes, the reader needs at least a superfi-
 cial knowledge of the wide variety of collections that they implement, and their 
 commonalities and differences.
  
 Programming with collections rather than individual elements is an im-
 portant way to raise the level of abstraction of a program. The Lisp function 
 map
 , which applies an argument function to every element of a list and returns 
 a new list containing the results is an early example of this style, but Smalltalk-
 80 adopted collection-based programming as a central tenet. Modern 
 functional programming languages such as ML and Haskell have followed 
 Smalltalk’s lead.
  
 Why is this a good idea? Suppose you have a data structure containing a 
 collection of student records, and wish to perform some action on all of the 
 students that meet some criterion. Programmers raised to use an imperative 
 language will immediately reach for a loop. But the Smalltalk programmer will 
 write:
  
 students select: [ :each | each gpa < threshold ]
  
 which evaluates to a new collection containing precisely those elements of 
 students
  for which the bracketed function returns
  true
 2
 . The Smalltalk code
  
 2
 The expression in brackets can be thought of as a
  λ
 -expression defining an anonymous",NA
9.3 ,NA,NA
Implementations of collections,"These categorizations by functionality are not our only concern; we must also 
 consider how the collection classes are implemented. As shown in Figure 9.3, 
 five 
 main implementation techniques are employed.",NA
Examples of key classes,Collections,NA
9.4,"We present now the most common or important collection classes using simple 
 code examples. The main protocols of collections are:
  at:
 ,
  at:put:
  — to access an 
 element,
  add:
 ,
  remove:
  — to add or remove an element,
  size
 ,
  isEmpty
 , 
 include:
  — to 
 get some information about the collection,
  do:
 ,
  collect:
 ,
  select:
  —to iterate over 
 the collection. Each collection may implement or not such protocols, and when 
 they do, they interpret them to fit with their semantics. We suggest you browse 
 the classes themselves to identify specific and more advanced protocols.
  
  
 We will focus on the most common collection classes:
  OrderedCollection
 ,
  Set
 , 
 SortedCollection
 ,
  Dictionary
 ,
  Interval
 , and
  Array
 .
  
 Common creation protocol. 
 There are several ways to create instances of 
 collections. The most generic ones use the methods
  new:
  and
  with:
 . 
  
 new: 
 anInteger
  creates a collection of size
  anInteger
  whose elements will all be
  nil
 . 
 with: 
 anObject
  creates a collection and adds
  anObject
  to the created collection. 
 Different collections will realize this behaviour differently.
  
  
 You can create collections with initial elements using the methods
  with:
 , 
 with:with:
  etc. for up to six elements.
  
 Array with: 1
  
 −→
  
 #(1)
  
 Array with: 1 with: 2
  
 −→
  
 #(1 2)
  
 Array with: 1 with: 2 with: 3
  
 −→
  
 #(1 2 3)
  
 Array with: 1 with: 2 with: 3 with: 4
  
 −→
  
 #(1 2 3 4)
  
 Array with: 1 with: 2 with: 3 with: 4 with: 5
  
 −→
  
 #(1 2 3 4 5)
  
 Array with: 1 with: 2 with: 3 with: 4 with: 5 with: 6
  
 −→
  
 #(1 2 3 4 5 6)
  
  
 You can also use
  addAll:
  to add all elements of one kind of collection to 
 another kind:
  
 (1 to: 5) asOrderedCollection addAll: '678'; yourself
  
 −→
  
 an OrderedCollection(1 2 3
  
  
 4 5 $6 $7 $8)
  
 Take care that
  addAll:
  also returns its argument, and not the receiver!
  
 You can also create many collections with
  withAll:
  or
  newFrom:
  
 Array withAll: #(7 3 1 3)
  
 −→
  
 #(7 3 1 3)
  
 OrderedCollection withAll: #(7 3 1 3)
  
 −→
  
 an OrderedCollection(7 3 1 3)
  
 SortedCollection withAll: #(7 3 1 3)
  
 −→
  
 a SortedCollection(1 3 3 7)
  
 Set withAll: #(7 3 1 3)
  
 −→
  
 a Set(7 1 3)
  
 Bag withAll: #(7 3 1 3)
  
 −→
  
 a Bag(7 1 3 3)
  
 Dictionary withAll: #(7 3 1 3)
  
 −→
  
 a Dictionary(1−>7 2−>3 3−>1 4−>3 )",NA
9.5 ,NA,NA
Collection iterators,"In Smalltalk loops and conditionals are simply messages sent to collections or 
 other objects such as integers or blocks (see also Chapter 3). In addition to 
 low-level messages such as
  to:do:
  which evaluates a block with an argument 
 ranging from an initial to a final number, the Smalltalk collection hierarchy 
 offers various high-level iterators. Using such iterators will make your code 
 more robust and compact.",NA
9.6,NA,NA
Some hints for using collections,"A common mistake with
  add: 
 quent Smalltalk mistakes.
  
 The following error is one of the most fre-
  
 collection := OrderedCollection new add: 1; add: 2.
  
 collection
  
 −→
  
 2
  
 Here the variable
  collection
  does not hold the newly created collection but 
 rather the last number added. This is because the method
  add:
  returns the 
 element added and not the receiver.
  
 The following code yields the expected result:
  
  
 collection := OrderedCollection new.
  
 collection add: 1; add: 2.
  
 collection
  
 −→
  
 an OrderedCollection(1 2)
  
  
 You can also use the message
  yourself
  to return the receiver of a cascade of 
 messages:
  
 collection := OrderedCollection new add: 1; add: 2; yourself
  
 −→
  
 an
  
  
 OrderedCollection(1 2)",NA
9.7 ,NA,NA
Chapter summary,"The Smalltalk collection hierarchy provides a common vocabulary for uni-
 formly manipulating a variety of different kinds of collections.
  
 • A key distinction is between
  SequenceableCollection
 s, which maintain 
 their 
 elements in a given order,
  Dictionary
  and its subclasses, which main-
 tain 
 key-to-value associations, and
  Set
 s and
  Bag
 s, which are unordered.",NA
Chapter 10,NA,NA
Streams,"Streams are used to iterate over sequences of elements such as sequenced 
 collections, files, and network streams. Streams may be either readable, or 
 writeable, or both. Reading or writing is always relative to the current position 
 in the stream. Streams can easily be converted to collections, and vice versa.",NA
10.1 ,NA,NA
Two sequences of elements,"A good metaphor to understand a stream is the following: A stream can be 
 represented as two sequences of elements: a past element sequence and a 
 future element sequence. The stream is positioned between the two se-
 quences. Understanding this model is important since all stream operations in 
 Smalltalk rely on it. For this reason, most of the
  Stream
  classes are sub-
 classes 
 of
  PositionableStream
 . Figure 10.1 presents a stream which contains five 
 characters. This stream is in its original position, i.e., there is no element in the 
 past. You can go back to this position using the message
  reset
 .
  
 past element
  
  
 a
  
 b
  
 c
  
 d
  
 e
  
 future element
  
 sequence
  
 sequence
  
 Figure 10.1: A stream positioned at its beginning.
  
 Reading an element conceptually means removing the first element of the 
 future element sequence and putting it after the last element in the past 
 element sequence. After having read one element using the message
  next
 , the 
 state of your stream is that shown in Figure 10.2.",NA
10.2 ,NA,NA
Streams vs. collections,"The collection protocol supports the storage, removal and enumeration of the 
 elements of a collection, but does not allow these operations to be inter-
 mingled. For example, if the elements of an
  OrderedCollection
  are processed by a
  
 do:
  method, it is not possible to add or remove elements from inside the
  do:
  
 block. Nor does the collection protocol offer ways to iterate over two 
 collections at the same time, choosing which collection goes forward and 
 which does not. Procedures like these require that a traversal index or position 
 reference is maintained outside of the collection itself: this is exactly the role of
  
 ReadStream
 ,
  WriteStream
  and
  ReadWriteStream
 .
  
 These three classes are defined to stream over some collection. For exam-
 ple, the following snippet creates a stream on an interval, then it reads two 
 elements.
  
 r := ReadStream on: (1 to: 1000).
  
 r next.
  
 −→
  
 1
  
 r next.
  
 −→
  
 2
  
 r atEnd.
  
 −→
  
 false
  
 WriteStream
 s can write data to the collection:",NA
10.3 ,NA,NA
Streaming over collections,"Streams are really useful when dealing with collections of elements. They can 
 be used for reading and writing elements in collections. We will now explore 
 the stream features for the collections.
  
 Reading collections
  
 This section presents features used for reading collections. Using a stream to 
 read a collection essentially provides you a pointer into the collection. That 
 pointer will move forward on reading and you can place it wherever you want. 
 The class
  ReadStream
  should be used to read elements from collections.
  
  
 Methods
  next
  and
  next:
  are used to retrieve one or more elements from the 
 collection.",NA
10.4 ,NA,NA
Using streams for file access,"You have already seen how to stream over collections of elements. It’s also 
 possible to stream over files on your hard disk. Once created, a stream on a 
 file is really like a stream on a collection: you will be able to use the same 
 protocol to read, write or position the stream. The main difference appears in 
 the creation of the stream. There are several different ways to create file 
 streams, as we shall now see.
  
 Creating file streams
  
 To create file streams, you will have to use one of the following instance 
 creation methods offered by the class
  FileStream
 :
  
 fileNamed:
  Open a file with the given name for reading and writing. If the file 
 already exists, its prior contents may be modified or replaced, but 
 the file 
 will not be truncated on close. If the name has no directory part, 
 then the 
 file will be created in the default directory.
  
 newFileNamed:
  Create a new file with the given name, and answer a stream 
 opened for writing on that file. If the file already exists, ask the user 
 what to do.
  
 forceNewFileNamed:
  Create a new file with the given name, and answer a 
 stream opened for writing on that file. If the file already exists, delete it 
 without asking before creating the new file.
  
 oldFileNamed:
  Open an existing file with the given name for reading and 
 writing. If the file already exists, its prior contents may be modified or 
 replaced, but the file will not be truncated on close. If the name has no 
 directory part, then the file will be created in the default directory.
  
 readOnlyFileNamed:
  Open an existing file with the given name for reading.
  
  
 You have to remember that each time you open a stream on a file, you have 
 to close it too. This is done through the
  close
  method.
  
  
 stream := FileStream forceNewFileNamed: 'test.txt'.
  
 stream
  
  
 nextPutAll: 'This text is written in a file named ';
  
  
 print: stream localName.
  
  
 stream close.
  
  
 stream := FileStream readOnlyFileNamed: 'test.txt'.
  
 stream contents.
  
 −→
  
 'This text is written in a file named ''test.txt'''
  
  
        
 stream close.",NA
10.5 ,NA,NA
Chapter summary,"Streams offer a better way than collections to incrementally read and write a 
 sequence of elements. There are easy ways to convert back and forth between 
 streams and collections.
  
 • Streams may be either readable, writeable or both readable and write-
  
 able.",NA
Chapter 11,NA,NA
Morphic,"Morphic is the name given to Pharo’s graphical interface. Morphic is written in 
 Smalltalk, so it is fully portable between operating systems; as a conse-quence, 
 Pharo looks exactly the same on Unix, MacOS and Windows. What 
 distinguishes Morphic from most other user interface toolkits is that it does 
 not have separate modes for “composing” and “running” the interface: all the 
 graphical elements can be assembled and disassembled by the user, at any 
 time.
 1",NA
11.1 ,NA,NA
The history of Morphic,"Morphic was developed by John Maloney and Randy Smith for the Self 
 programming language, staring around 1993. Maloney later wrote a new 
 version of Morphic for Squeak, but the basic ideas behind the Self version are 
 still alive and well in Pharo Morphic: directness and liveness. Directness means 
 that the shapes on the screen are objects that can be examined or changed 
 directly, that is, by pointing at them using the mouse. Liveness means that the 
 user interface is always able to respond to user actions: information on the 
 screen is continuously updated as the world that it describes changes. A 
 simple example of this is that you can detach a menu item and keep it as a 
 button.
  
 Bring up the world menu. Meta-click once on the world menu to bring up its 
 morphic halo
 2
 , then meta-click again on the menu item you want to detach to 
 bring 
 up its halo. Now drag that item elsewhere on the screen by grabbing the 
 black handle
  
  
 1
 We thank Hilaire Fernandes for permission to base this chapter on his original article in 
 French.
  
 2
 Recall that you should set
  halosEnabled
  in the Preferences browser. Alternatively, you can
  
  
  
 evaluate
  Preferences enable: #halosEnabled
  in a workspace.",NA
11.2 ,NA,NA
Manipulating morphs,"Morphs are objects, so we can manipulate them like any other object in 
 Smalltalk: by sending messages, we can change their properties, create new 
 subclasses of Morph, and so on.
  
 Every morph, even if it is not currently open on the screen, has a position 
 and a size. For convenience, all morphs are considered to occupy a rectangular 
 region of the screen; if they are irregularly shaped, their position and size are 
 those of the smallest rectangular “box” that surrounds them, which is 
 known 
 as the morph’s bounding box, or just its “bounds”. The
  position
  method 
 returns a
  
 Point
  that describes the location of the morph’s upper left corner (or the upper 
 left corner of its bounding box). The origin of the coordinate system is the 
 screen’s upper left corner, with
  y
  coordinates increasing down the screen and
  
 x
  coordinates increasing to the right. The
  extent
  method also returns a point, 
 but this point specifies the width and height of the morph rather than a 
 location.
  
 Type the following code into a workspace and
  do it
 :
  
 joe := Morph new color: Color blue.
  
  
 joe openInWorld.
  
  
 bill := Morph new color: Color red .
  
  
 bill openInWorld.
  
 Then type
  joe position
  and
  print it
 . To move joe, execute
  joe position: (joe position + 
 (10@3))
  repeatedly.
  
 It is possible to do a similar thing with size.
  joe extent
  answers joe’s size; to 
 have joe grow, execute
  joe extent: (joe extent * 1.1)
 . To change the color of a 
 morph, 
 send it the
  color:
  message with the desired
  Color
  object as argument, for 
 instance,
  
 joe color: Color orange
 . To add transparency, try
  joe color: (Color orange alpha: 0.5)
 .
  
  
 To make bill follow joe, you can repeatedly execute this code:
  
  
 bill position: (joe position + (100@0))",NA
11.3 ,NA,NA
Composing morphs,"One way of creating new graphical representations is by placing one morph in-
 side another. This is called composition; morphs can be composed to any depth. 
 You can place a morph inside another by sending the message
  addMorph:
  to the 
 container morph.
  
  
 Try adding a morph to another one:
  
  
  
 star := StarMorph new color: Color yellow.
  
  
 joe addMorph: star.
  
 star position: joe position.
  
 The last line positions the star at the same coordinates as joe. Notice that the 
 coordinates of the contained morph are still relative to the screen, not to the 
 containing morph. There are many methods available to position a morph; 
 browse the
  geometry
  protocol of class
  Morph
  to see for yourself. For example, to 
 center the star inside joe, execute
  star center: joe center
 .
  
  
 Figure 11.2: The star is contained inside joe, the translucent blue morph.
  
 If you now try to grab the star with the mouse, you will find that you 
 actually grab joe, and the two morphs move together: the star is embedded 
 inside joe. It is possible to embed more morphs inside joe. In addition to doing 
 this programmatically, you can also embed morphs by direct manipulation.",NA
11.4 ,NA,NA
Creating and drawing your own morphs,"While it is possible to make many interesting and useful graphical representa-
 tions by composing morphs, sometimes you will need to create something",NA
11.5,NA,NA
Interaction and animation,"To build live user-interfaces using morphs, we need to be able to interact with 
 them using the mouse and the keyboard. Moreover, the morphs need to be 
 able respond to user input by changing their appearance and position — that 
 is, by animating themselves.
  
 Mouse events
  
 When a mouse button is pressed, Morphic sends each morph under the mouse 
 pointer the message
  handlesMouseDown:
 . If a morph answers
  true
 , then Morphic 
 immediately sends it the
  mouseDown:
  message; it also sends the
  mouseUp: 
 message when the user releases the mouse button. If all morphs answer 
 false
 , 
 then Morphic initiates a drag-and-drop operation. As we will discuss 
 below, 
 the
  mouseDown:
  and
  mouseUp:
  messages are sent with an argument — a 
 MouseEvent
  object — that encodes the details of the mouse action.
  
  
 Let’s extend
  CrossMorph
  to handle mouse events. We start by ensuring that 
 all 
 crossMorphs answer
  true
  to the
  handlesMouseDown:
  message.",NA
11.6,NA,NA
Interactors,"To prompt the user for input, the
  UIManager
  class provides a large number
  
 of ready-to-use dialog boxes. For instance, the
  request:initialAnswer:
  method
  
 returns the string entered by the user (Figure 11.6).
  
 UIManager default request: 'What''s your name?' initialAnswer: 'no name'
  
 3
 stepTime
  is actually the minimum time between
  step
 s. If you ask for a
  stepTime
  of 1 ms, don’t
  
 be surprised if Pharo is too busy to step your morph that often.",NA
11.7,NA,NA
Drag-and-drop,"Morphic also supports drag-and-drop. Let’s examine a simple example with
  
 two morphs, a receiver morph and a dropped morph. The receiver will
  
 accept a morph only if the dropped morph matches a given condition: in
  
 our example, the morph should be blue. If it is rejected, the dropped morph
  
 decides what to do.
  
 Let’s first define the receiver morph:
  
 Class 11.20: Defining a morph on which we can drop other morphs
  
 Morph subclass: #ReceiverMorph
  
  
 instanceVariableNames: ''
  
  
 classVariableNames: ''
  
  
 poolDictionaries: ''",NA
11.8 ,NA,NA
A complete example,"Let’s design a morph to roll a die
 4
 . Clicking on it will display the values of all
  
 sides of the die in a quick loop, and another click will stop the animation.
  
 4
 NB: One die, two dice.",NA
11.9 ,NA,NA
More about the canvas,"The
  drawOn:
  method has an instance of
  Canvas
  as its sole argument; the canvas 
 is 
 the area on which the morph draws itself. By using the graphics methods 
 of 
 the canvas you are free to give the appearance you want to a morph. If you 
 browse the inheritance hierarchy of the
  Canvas
  class, you will see that it has 
 several variants. The default variant of
  Canvas
  is
  FormCanvas
 ; you will find the 
 key graphics methods in
  Canvas
  and
  FormCanvas
 . These methods can draw 
 points, lines, polygons, rectangles, ellipses, text, and images with rotation and 
 scaling.
  
 It is also possible to use other kinds of canvas, to obtain transparent 
 morphs, more graphics methods, antialiasing, and so on. To use these features 
 you will need an
  AlphaBlendingCanvas
  or a
  BalloonCanvas
 . But how can you obtain 
 such a canvas in a
  drawOn:
  method, when
  drawOn:
  receives an instance of
  
 FormCanvas
  as its argument? Fortunately, you can transform one kind of canvas 
 into another.",NA
11.10 Chapter summary,"Morphic is a graphical framework in which graphical interface elements can be 
 dynamically composed.
  
 • You can convert an object into a morph and display that morph on the 
  
 screen by sending it the messages
  asMorph openInWorld
 .
  
 • You can manipulate a morph by meta-clicking on it and using the handles 
 that appear. (Handles have help balloons that explain what they do.)
  
 • You can compose morphs by embedding one onto another, either by 
  
 drag and drop or by sending the message
  addMorph:
 .
  
 • You can subclass an existing morph class and redefine key methods, 
  
 like
  
 initialize
  and
  drawOn:
 .
  
 • You can control how a morph reacts to mouse and keyboard events by 
  
 redefining the methods
  handlesMouseDown:
 ,
  handlesMouseOver:
 , etc.
  
 • You can animate a morph by defining the methods
  step
  (what to do) 
  
 and
  
 stepTime
  (the number of milliseconds between steps).",NA
Chapter 12,NA,NA
Seaside by Example,"Seaside is a framework for building web applications in Smalltalk. It was 
 originally developed by Avi Bryant in 2002; once mastered, Seaside makes 
 web applications almost as easy to write as desktop applications.
  
 Two of the better known applications built with Seaside are SqueakSource
 1 
 and Dabble DB
 2
 . Seaside is unusual in that it is thoroughly object-oriented: 
 there are no XHTML templates, no complicated control flows through web 
 pages, and no encoding of state in URLs. Instead, you just send messages to 
 objects. What a nice idea!",NA
12.1 ,NA,NA
Why do we need Seaside?,"Modern web applications try to interact with the user in the same way as 
 desktop applications: they ask the user questions and the user responds, 
 usually by filling in a form or clicking a button. But the web works the other 
 way around: the user’s browser makes a request of the server, and the server 
 responds with a new web page. So web application development frameworks 
 have to cope with a host of problems, chief among them being the 
 management of this “inverted” control flow. Because of this, many web 
 applications try to forbid the use of the browser’s “back” button due to the 
 difficulty of keeping track of the state of a session. Expressing non-trivial 
 control flows across multiple web pages is often cumbersome, and multiple 
 control flows can be difficult or impossible to express.
  
 Seaside is a component-based framework that makes web development 
 easier in several ways. First, control flow can be expressed naturally using 
 message sends. Seaside keeps track of which web page corresponds to which
  
 1
 http://SqueakSource.com 
  
 2
 http://DabbleDB.com",NA
12.2 ,NA,NA
Getting started,"The easiest way to get started is to download the “Seaside One-Click Experi-
 ence” from the Seaside web site
 3
 . This is a prepackaged version of Seaside 
 2.8 
 for Mac OSX, Linux and Windows. The same web site lists many pointers 
 to 
 additional resources, including documentation and tutorials. Be warned, 
 however, that Seaside has evolved considerably over the years, and not all 
 available material refers to the latest version of Seaside.
  
 Seaside includes a web server; you can turn the server on, telling it to 
 listen on port 8080, by evaluating
  WAKom startOn: 8080
 , and you can turn it off 
 again by evaluating
  WAKom stop
 . In the default installation, the default 
 administrator login is
  admin
  and the default password is
  seaside
 . To change 
 them, evaluate:
  WADispatcherEditor initialize
 . This will prompt you for a new 
 name and password.
  
 Start the Seaside server and direct a web browser to
  http:// localhost:8080/ 
 seaside/
 .
  
 You should see a web page that looks like Figure 12.1.
  
 Navigate to the
  examples
 ⟨
  counter
  page. (Figure 12.2)
  
 This page is a small Seaside application: it displays a counter that can be 
 incremented or decremented by clicking on the
  ++
  and
  – –
  links.
  
 3
 http://seaside.st",NA
12.3 ,NA,NA
Seaside components,"As we mentioned in the previous section, Seaside applications are built out 
 of 
 components. Let’s take a closer look at how Seaside works by implementing 
 the 
 Hello World component.",NA
Rendering XHTML,Seaside by Example,NA
12.4,"The purpose of a web application is to create, or “render”, web pages. As we 
 mentioned in Section 12.3, each Seaside component is responsible for 
 rendering itself. So, lets start our exploration of rendering by seeing how the 
 counter component renders itself.
  
 Rendering the Counter
  
 The rendering of the counter is relatively straightforward; the code is shown 
 in Figure 12.8. The current value of the counter is displayed as an XHTML 
 heading, and the increment and decrement operations are implemented as 
 html anchors (that is, links) with callbacks to blocks that will send
  increase 
 and
  
 decrease
  to the counter object.
  
  
 We will have a closer look at the rendering protocol in a moment. But 
 before we do, let’s have a quick look at the multi-counter.
  
 From Counter to MultiCounter
  
 WAMultiCounter
 , shown in Figure 12.9 is also a standalone application, so it 
 overrides
  canBeRoot
  to answer
  true
 . In addition, it is a composite component, so 
 Seaside requires it to declare its children by implementing a method
  children 
 that answers an array of all the components it contains. It renders itself by 
 rendering each of its subcomponents, separated by a horizontal rule. Aside 
 from instance and class-side initialization methods, there is nothing else to 
 the multi-counter!
  
 ↑ #()
  
 WAComponent
  
 children
  
 ↑ true
  
 WAMultiCounter
  
 super initialize.
  
 counters := (1 to: 5) collect:
  
 counters
  
 [ :each | WACounter new ]
  
 ↑ counters
  
 canBeRoot
  
 counters
  
 initialize
  
 do: [ :each | html render: each ]
  
 renderContentOn: html
  
 separatedBy: [ html horizontalRule ]
  
 children
  
 Figure 12.9: WAMultiCounter",NA
12.5 ,NA,NA
CSS: Cascading style sheets,"Cascading Style Sheets
 5
 , or CSS for short, have emerged as a standard way for 
 web applications to separate style from content. Seaside relies on CSS to avoid 
 cluttering your rendering code with layout considerations.
  
 You can set the CSS style sheet for your web components by defining the 
 method
  style
 , which should return a string containing the CSS rules for that 
 component. The styles of all the components displayed on a web page are 
 joined together, so each component can have its own style. A better approach 
 can be to define an abstract class for your web application that defines a 
 common style for all its subclasses.
  
 Actually, for deployed applications, it is more common to define style 
 sheets as external files. This way the look and feel of the component is 
 completely separate from its functionality. (Have a look at
  WAFileLibrary
 , which 
 provides a way to serve static files without the need for a standalone server.)
  
 If you already are familiar with CSS, then that’s all you need to know.
  
 5
 http://www.w3.org/Style/CSS/",NA
12.6 ,NA,NA
Managing control flow,"Seaside makes it particularly easy to design web applications with non-trivial 
 control flow. There are basically two mechanisms that you can use:
  
 1. A component can call another component by sending
  caller call: callee
 . The 
 caller is temporarily replaced by the callee, until the callee returns 
 control by sending
  answer:
 . The caller is usually
  self
 , but could also be any 
 other currently visible component.
  
 2. A workflow can be be defined as a task. This is a special kind of com-
 ponent that subclasses
  WATask
  (instead of
  WAComponent
 ). Instead of 
 defining
  renderContentOn:
 , it defines no content of its own, but rather de-
 fines a
  go
  method that sends a series of
  call:
  messages to activate various 
 subcomponents in turn.
  
 6
 http://www.csszengarden.com/",NA
12.7,NA,NA
A complete tutorial example,"Let’s see how we can build a complete Seaside application from scratch.
 8
 We 
 will build a RPN (Reverse Polish Notation) calculator as a Seaside application 
 that uses a simple stack machine as its underlying model. Furthermore, the 
 Seaside interface will let us toggle between two displays — one which just 
 shows us the current value on top of the stack, and the other which shows us 
 the complete state of the stack. The calculator with the two display options is 
 shown in Figure 12.15.
  
 Figure 12.15: RPN calculator and its stack machine
  
 We begin by implementing the stack machine and its tests.
  
 Define a new class called
  MyStackMachine
  with an instance variable
  contents 
 initialized to a new
  OrderedCollection
 .
  
 8
 The exercise should take at most a couple of hours. If you prefer to just look at the com-pleted 
 source code, you can grab it from the SqueakSource project
  http://www.squeaksource.com/ 
 PharoByExample
 . The package to load is
  PBE-SeasideRPN
 . The tutorial that follows uses slightly 
 different class names so that you can compare your implementation with ours.",NA
12.8 ,NA,NA
A quick look at AJAX,"AJAX (Asynchronous JavaScript and XML) is a technique to make web appli-
 cations more interactive by exploiting JavaScript functionality on the client 
 side.
  
 Two 
 well-known 
 JavaScript 
 libraries 
 are 
 Prototype 
 (
 http://www.prototypejs.org
 ) 
 and script.aculo.us (
 http://script.aculo.us
 ). Prototype 
 provides a framework to ease writing JavaScript. script.aculo.us provides 
 some additional features to 
 support animations and drag-and-drop on top of 
 Prototype. Both frameworks 
 are supported in Seaside through the package 
 “Scriptaculous”.
  
 All ready-made images have the Scriptaculous package extensions already 
 loaded. The latest version is available from
  http://www.squeaksource.com/Seaside
 . 
 An online demo is available at
  http://scriptaculous.seasidehosting.st
 . Alternatively, 
 if 
 you have a enabled image running, simply go to
  http://localhost:8080/seaside/ 
 tests/scriptaculous
 .",NA
12.9 ,NA,NA
Chapter summary,"• The easiest way to get started is to download the “Seaside One-Click 
  
 Experience” from
  http://seaside.st
  
 •
  Turn the server on and off by evaluating
  WAKom startOn: 8080
  and
  WAKom 
 stop
 .
  
 • Reset
  
 the
  
 administrator
  
 login
  
 and
  
 password
  
 by
  
 evaluating
  
 WADispatcherEditor initialize
 .
  
 •
  Toggle Halos
  to directly view application source code, run-time objects, 
  
 CSS and XHTML.
  
 • Send
  WAGlobalConfiguration setDeploymentMode
  to hide the toolbar.
  
 • Seaside web applications are composed of components, each of which 
  
 is 
 an instance of a subclass of
  WAComponent
 .",NA
Part III ,NA,NA
Advanced Pharo,NA,NA
Chapter 13,NA,NA
Classes and metaclasses,"As we saw in Chapter 5, in Smalltalk, everything is an object, and every object is 
 an instance of a class. Classes are no exception: classes are objects, and class 
 objects are instances of other classes. This object model captures the essence 
 of object-oriented programming: it is lean, simple, elegant and uniform. 
 However, the implications of this uniformity may confuse newcomers. The 
 goal of this chapter is to show that there is nothing complex, “magic” or special 
 here: just simple rules applied uniformly. By following these rules you can 
 always understand why the situation is the way that it is.",NA
13.1 ,NA,NA
Rules for classes and metaclasses,"The Smalltalk object model is based on a limited number of concepts applied 
 uniformly. Smalltalk’s designers applied Occam’s razor: any consideration 
 leading to a model more complex than necessary was discarded.
  
  
 To refresh your memory, here are the rules of the object model that we 
 explored in Chapter 5.
  
 Rule 1
 . Everything is an object.
  
 Rule 2
 . Every object is an instance of a class.
  
 Rule 3
 . Every class has a superclass.
  
 Rule 4
 . Everything happens by sending messages.
  
 Rule 5
 . Method lookup follows the inheritance chain.
  
 As we mentioned in the introduction to this chapter, a consequence of Rule 
 1 is that classes are objects too, so Rule 2 tells us that classes must also be",NA
13.2 ,NA,NA
Revisiting the Smalltalk object model,"Since everything is an object, the color blue in Smalltalk is also an object.
  
 Color blue
  
 −→
  
 Color blue
  
 Every object is an instance of a class. The class of the color blue is the class 
 Color
 :
  
 Color blue class
  
 −→
  
 Color
  
 Interestingly, if we set the alpha value of a color, we get an instance of a 
 different class, namely
  TranslucentColor
 :
  
 (Color blue alpha: 0.4) class
  
 −→
  
 TranslucentColor
  
 We can create a morph and set its color to this translucent color:
  
 EllipseMorph new color: (Color blue alpha: 0.4); openInWorld
  
 You can see the effect in Figure 13.1.",NA
13.3,NA,NA
Every class is an instance of a metaclass,"As we mentioned in Section 13.1, classes whose instances are themselves 
 classes are called metaclasses.
  
 Metaclasses are implicit. 
  
 Metaclasses are automatically created when you 
 define a class. We say that they are implicit since as a programmer you never 
 have to worry about them. An implicit metaclass is created for each class you 
 create, so each metaclass has only a single instance.
  
 Whereas ordinary classes are named by global variables, metaclasses are 
 anonymous. However, we can always refer to them through the class that is 
 their instance. The class of
  Color
 , for instance, is
  Color class
 , and the class of 
 Object
  is
  Object class
 :
  
 Color class
  
 −→
  
 Color class
  
 Object class
  
 −→
  
 Object class
  
 Figure 13.3 shows how each class is an instance of its (anonymous) metaclass.
  
 translucentBlue
  
 Object
  
 Object class
  
 Color
  
 Color class
  
 TranslucentColor
  
 TranslucentColor class
  
  
 Key 
  
 instance-of
  
 Figure 13.3: The metaclasses of Translucent and its superclasses",NA
13.4,NA,NA
The metaclass hierarchy parallels the class ,NA,NA
hi-,NA,NA
erarchy,"Rule 7 says that the superclass of a metaclass cannot be an arbitrary class: it is 
 constrained to be the metaclass of the superclass of the metaclass’s unique 
 instance.
  
 TranslucentColor class superclass
  
 −→
  
 Color class
  
 TranslucentColor superclass class
  
 −→
  
 Color class
  
 This is what we mean by the metaclass hierarchy being parallel to the class 
 hierarchy; Figure 13.4 shows how this works in the
  TranslucentColor
  hierarchy.
  
 translucentBlue
  
 Object
  
 Object class
  
 Color
  
 Color class
  
 TranslucentColor
  
 TranslucentColor class
  
  
 Key 
  
 instance-of
  
 Figure 13.4: The metaclass hierarchy parallels the class hierarchy.",NA
13.5 ,NA,NA
Every metaclass Inherits from,Class,NA
 and,"Be-
  
 havior
  
 Every metaclass is-a class, hence inherits from
  Class
 .
  Class
  in turn inherits from 
 its superclasses,
  ClassDescription
  and
  Behavior
 . Since everything in Smalltalk is-
 an object, these classes all inherit eventually from
  Object
 . We can see the 
 complete picture in Figure 13.7.
  
 Where is
  new
  defined? 
  
 To understand the importance of the fact that meta-
 classes inherit from
  Class
  and
  Behavior
 , it helps to ask where
  new
  is defined",NA
13.6 ,NA,NA
Every metaclass is an instance of,"Metaclass
  
 Metaclasses are objects too; they are instances of the class
  Metaclass
  as shown 
 in Figure 13.9. The instances of class
  Metaclass
  are the anonymous metaclasses, 
 each of which has exactly one instance, which is a class.
  
 Metaclass
  represents common metaclass behaviour. It provides methods for 
 instance creation (
 subclassOf:
 ) creating initialized instances of the metaclass’s 
 sole instance, initialization of class variables, metaclass instance, method 
 compilation, and class information (inheritance links, instance variables, etc.).",NA
13.7 ,NA,NA
The metaclass of,Metaclass,NA
 is an Instance of,"Metaclass
  
 The final question to be answered is: what is the class of
  Metaclass class
 ?
  
  
 The answer is simple: it is a metaclass, so it must be an instance of 
 Metaclass
 , just like all the other metaclasses in the system (see Figure 13.10).
  
 The figure shows how all metaclasses are instances of
  Metaclass
 , including 
 the metaclass of
  Metaclass
  itself. If you compare Figures 13.9 and 13.10 you",NA
13.8,NA,NA
Chapter summary,"Now you should understand better how classes are organized and the impact 
 of 
 a uniform object model. If you get lost or confused, you should always 
 remember that message passing is the key: you look for the method in the 
 class of the receiver. This works on any receiver. If the method is not found in 
 the class of the receiver, it is looked up in its superclasses.
  
 • Every class is an instance of a metaclass. Metaclasses are implicit. A 
 Metaclass is created automatically when you create the class that is its 
 sole instance.
  
 • The metaclass hierarchy parallels the class hierarchy. Method lookup for 
 classes parallels method lookup for ordinary objects, and follows the 
 metaclass’s superclass chain.
  
 • Every metaclass inherits from
  Class
  and
  Behavior
 . Every class is a
  Class 
 . Since 
 metaclasses are classes too, they must also inherit from
  Class
 . 
 Behavior
  
 provides behaviour common to all entities that have instances.
  
 • Every metaclass is an instance of
  Metaclass
 .
  ClassDescription
  provides 
  
 everything that is common to
  Class
  and
  Metaclass
 .
  
 • The metaclass of
  Metaclass
  is an instance of
  Metaclass
 . The instance-of
  
 relation forms a closed loop, so
  Metaclass class class
  
 −→
  
 Metaclass
 .",NA
Chapter 14,NA,NA
Reflection,"Smalltalk is a reflective programming language. In a nutshell, this means that 
 programs are able to “reflect” on their own execution and structure. More 
 technically, this means that the metaobjects of the runtime system can be reified 
 as ordinary objects, which can be queried and inspected. The metaobjects in 
 Smalltalk are classes, metaclasses, method dictionaries, compiled methods, 
 the 
 run-time stack, and so on. This form of reflection is also called introspection, 
 and is supported by many modern programming languages.
  
 Metaobjects
  
 reification
  
 reflection
  
 Objects
  
 Figure 14.1: Reification and reflection.
  
 Conversely, it is possible in Smalltalk to modify reified metaobjects and 
 reflect these changes back to the runtime system (see Figure 14.1). This is 
 also called intercession, and is supported mainly by dynamic programming 
 languages, and only to a very limited degree by static languages.
  
 A program that manipulates other programs (or even itself) is a metapro-",NA
14.1 ,NA,NA
Introspection,"Using the inspector, you can look at an object, change the values of its instance 
 variables, and even send messages to it.
  
  
 Evaluate the following code in a workspace:
  
  
  
 w := Workspace new.
  
  
 w openLabel: 'My Workspace'.
  
 w inspect
  
 This will open a second workspace and an inspector. The inspector shows 
 the internal state of this new workspace, listing its instance variables in the 
 left part (
 dependents
 ,
  contents
 ,
  bindings
 ...) and the value of the selected instance 
 variable in the right part. The
  contents
  instance variable represents whatever 
 the workspace is displaying in its text area, so if you select it, the right part 
 will show an empty string.
  
 Now type
  'hello'
  in place of that empty string, then accept it.
  
 The value of the
  contents
  variable will change, but the workspace window 
 will not notice it, so it does not redisplay itself. To trigger the window refresh, 
 evaluate
  self contentsChanged
  in the lower part of the inspector.
  
 Accessing instance variables
  
 How does the inspector work? In Smalltalk, all instance variables are pro-
 tected. In theory, it is impossible to access them from another object if the 
 class 
 doesn’t define any accessor. In practice, the inspector can access instance 
 variables without needing accessors, because it uses the reflective abilities of 
 Smalltalk. In Smalltalk, classes define instance variables either by name or",NA
14.2 ,NA,NA
Browsing code,"In Smalltalk, everything is an object. In particular, classes are objects that 
 provide useful features for navigating through their instances. Most of the 
 messages we will look at now are implemented in
  Behavior
 , so they are under-
 stood by all classes.
  
  
 As we saw previously, you can obtain an instance of a given class by 
 sending it the message
  #someInstance
 .
  
 Point someInstance
  
 −→
  
 0@0
  
  
 You can also gather all the instances with
  #allInstances
 , or the number of 
 alive instances in memory with
  #instanceCount
 .
  
 ByteString allInstances
  
 −→
  
 #('collection' 'position' ...)
  
 ByteString instanceCount
  
 −→
  
 104565
  
 String allSubInstances size
  
 −→
  
 101675",NA
14.3 ,NA,NA
"Classes, method dictionaries and methods","Since classes are objects, we can inspect or explore them just like any other 
 object.
  
 Evaluate
  Point explore
 .
  
 In Figure 14.5, the explorer shows the structure of class
  Point
 . You can see 
 that the class stores its methods in a dictionary, indexing them by their 
 selector. The selector
  #*
  points to the decompiled bytecode of
  Point»*
 .
  
  
 Figure 14.5: Explorer class
  Point
  and the bytecode of its
  #*
  method.
  
 Let us consider the relationship between classes and methods. In Fig-ure 
 14.6 we see that classes and metaclasses have the common superclass 
 Behavior
 . 
 This is where
  new
  is defined, amongst other key methods for classes. 
 Every class 
 has a method dictionary, which maps method selectors to com-
 piled methods. 
 Each compiled method knows the class in which it is installed. 
 In Figure 14.5 we 
 can even see that this is stored in an association in
  literal5
 .
  
 We can exploit the relationships between classes and methods to pose 
 queries about the system. For example, to discover which methods are newly 
 introduced in a given class, i.e., do not override superclass methods, we can 
 navigate from the class to the method dictionary as follows:
  
 [:aClass| aClass methodDict keys select: [:aMethod |
  
  
 (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  
 −→
  
 an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)",NA
14.4,NA,NA
Browsing environments,"Although
  SystemNavigation
  offers some useful ways to programmatically query 
 and browse system code, there is a better way. The Refactoring Browser, 
 which is integrated into Pharo, provides both interactive and programmatic 
 ways to pose complex queries.
  
 Suppose we are interested to discover which methods in the
  Collection
  hier-
 archy send a message to
  super
  which is different from the method’s selector. 
 This is normally considered to be a bad code smell, since such a
  super
 -send 
 should normally be replaced by a
  self
 -send. (Think about it — you only need 
 super
  to extend a method you are overriding; all other inherited methods can 
 be accessed by sending to
  self
 !)
  
  
 The refactoring browser provides us with an elegant way to restrict our 
 query to just the classes and methods we are interested in.
  
  
 Open a browser on the class
  
 Collection
 .
  
 action-click on the class
  
 name and select
  
 refactoring scope>subclasses with
 .
  
 This will open a new
  
 Browser Environment on just the
  
 Collection
  hierarchy.
  
 Within this re-
  
 stricted scope select
  
 refactoring scope>super-sends
  
 to open a new environ-
  
 ment with all methods that perform super-sends within the
  Collectuon
  hierar-
  
 chy.
  
 Now click on any method and select
  refactor>code critics
 .
  
 Navigate to
  
 Lint checks>Possible bugs>Sends different super message
  and action-click to select 
 browse
 .
  
 In Figure 14.7 we can see that 19 such methods have been found within the
  
 Collection
  hierarchy, including
  Collection»printNameOn:
 , which sends
  super printOn:
 .
  
 Browser environments can also be created programmatically. Here, for 
 example, we create a new
  BrowserEnvironment
  for
  Collection
  and its subclasses, 
 select the super-sending methods, and open the resulting environment.
  
 ((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
  
  
 selectMethods: [:method | method sendsToSuper])
  
  
 label: 'Collection methods sending super';
  
  
 open.
  
  
 Note how this is considerably more compact than the earlier, equivalent 
 example using
  SystemNavigation
 .
  
  
 Finally, we can find just those methods that send a different super message 
 programmatically as follows:",NA
14.5 ,NA,NA
Accessing the run-time context,"We have seen how Smalltalk’s reflective capabilities let us query and explore
  
 objects, classes and methods. But what about the run-time environment?
  
 Method contexts
  
 In fact, the run-time context of an executing method is in the virtual machine
  
 — it is not in the image at all! On the other hand, the debugger obviously has",NA
14.6 ,NA,NA
Intercepting messages not understood,"So far we have used the reflective features of Smalltalk mainly to query and
  
 explore objects, classes, methods and the run-time stack. Now we will look
  
 at how to use our knowledge of the Smalltalk system structure to intercept
  
 messages and modify behaviour at run-time.
  
 When an object receives a message, it first looks in the method dictionary
  
 of its class for a corresponding method to respond to the message. If no such
  
 method exists, it will continue looking up the class hierarchy, until it reaches
  
 Object
 . If still no method is found for that message, the object will send itself
  
 the message
  doesNotUnderstand:
  with the message selector as its argument. The
  
 process then starts all over again, until
  Object»doesNotUnderstand:
  is found, and
  
 the debugger is launched.
  
 But what if
  doesNotUnderstand:
  is overridden by one of the subclasses of
  
 Object
  in the lookup path? As it turns out, this is a convenient way of realizing
  
 certain kinds of very dynamic behaviour. An object that does not understand",NA
14.7,NA,NA
Objects as method wrappers,"We have already seen that compiled methods are ordinary objects in Smalltalk, 
 and they support a number of methods that allow the programmer to query 
 the run-time system. What is perhaps a bit more surprising, is that any object 
 can play the role of a compiled method. All it has to do is respond to the 
 method
  run:with:in:
  and a few other important messages.
  
 Define an empty class
  Demo
 . Evaluate
  Demo new answer42
  and notice how the 
 usual “Message Not Understood” error is raised.
  
  
 Now we will install a plain Smalltalk object in the method dictionary of our
  
 Demo
  class.",NA
14.8 ,NA,NA
Pragmas,"A pragma is an annotation that specifies data about a program, but is not 
 involved in the execution of the program. Pragmas have no direct effect on the 
 operation of the method they annotate. Pragmas have a number of uses, among 
 them:
  
 • Information for the compiler: pragmas can be used by the compiler to 
 make a method call a primitive function. This function has to be defined 
 by the virtual machine or by an external plugging.
  
 • Runtime processing: Some pragmas are available to be examined at 
  
 runtime.
  
 Pragmas can be applied to a program’s method declarations only. A method 
 may declare one or more pragmas, and the pragmas have to be",NA
14.9 ,NA,NA
Chapter summary,"Reflection refers to the ability to query, examine and even modify the metaob-
 jects of the run-time system as ordinary objects.",NA
Part IV ,NA,NA
Appendices,NA,NA
Appendix A,NA,NA
Frequently Asked Questions,NA,NA
A.1 ,NA,NA
Getting started,"FAQ 1
  Where do I get the latest Pharo?
  
 Answer 
  
 http://www.pharo-project.org/
  
 FAQ 2
  Which Pharo image should I use with this book?
  
 Answer 
  
 You should be able to use any Pharo image, but we recommend you 
 to use the prepared image on the Pharo by Example web site:
  http:// 
 PharoByExample.org
 . You should also be able to use most other images, but you 
 may find that the hands-on exercises behave differently in surprising ways.",NA
A.2 ,NA,NA
Collections,"FAQ 3
  How do I sort an
  OrderedCollection
 ?
  
 Answer
  
 Send it the message
  asSortedCollection
 .
  
 #(7 2 6 1) asSortedCollection
  
 −→
  
 a SortedCollection(1 2 6 7)
  
 FAQ 4
  How do I convert a collection of characters to a
  String
 ?
  
 Answer
  
 String streamContents: [:str | str nextPutAll: 'hello' asSet]
  
 −→
  
 'hleo'",NA
Browsing the system,"Frequently Asked 
 Questions",NA
A.3,"FAQ 5
  The browser does not look like the one described in the book. What 
 gives?
  
 Answer 
  
 You are probably using an image in which a different version of the 
 OmniBrowser is installed as the default browser. In this book we assume that 
 the OmniBrowser Package Browser is installed as the default. You can change 
 the default by clicking on the menu bar of the browser. Just click on the gray 
 lozenge in the top right corner of the window, select “Choose new default 
 Browser”, and then pick the O2PackageBrowserAdaptor. The next browser you 
 open will be the Package Browser.
  
  
 (a) Choose a new browser
  
  
 (b) Select the OB Package Browser
  
 Figure A.1: Changing the default browser
  
 FAQ 6
  How do I search for a class?
  
 Answer 
  
 CMD
 –b
  (browse) on the class name, or
  CMD
 –f
  in the category pane
  
 of the browser.
  
 FAQ 7
  How do I find/browse all sends to super?
  
 Answer
  
 The second solution is much faster:
  
  
  
 SystemNavigation default browseMethodsWithSourceString: 'super'.
  
 SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
  
 FAQ 8
  How do I browse all super sends within a hierarchy?
  
 Answer",NA
A.4,NA,NA
Using Monticello and SqueakSource,"FAQ 14
  How do I load a SqueakSource project?
  
 Answer
  
 1. Find the project you want in
  http://squeaksource.com 
  
 2. Copy the registration code snippet 
  
 3. Select
  open
  ⟨
  Monticello browser 
  
 4. Select
  +Repository
  ⟨
  HTTP 
  
 5. Paste and accept the Registration code snippet; enter your password 6. 
 Select the new repository and
  Open
  it 
  
 7. Select and load the latest version
  
 FAQ 15
  How do I create a SqueakSource project?
  
 Answer
  
 1. Go to
  http://squeaksource.com 
  
 2. Register yourself as a new member 
  
 3. Register a project (name = category) 
  
 4. Copy the Registration code snippet 
  
 5.
  open
  ⟨
  Monticello browser 
  
 6.
  +Package
  to add the category 
  
 7. Select the package 
  
 8.
  +Repository
  ⟨
  HTTP 
  
 9. Paste and accept the Registration code snippet; enter your password 10.
  
 Save
  to save the first version
  
 FAQ 16
  How do I extend
  Number
  with
  Number»chf
  but have Monticello recognize 
 it 
 as being part of my
  Money
  project?",NA
A.5 ,NA,NA
Tools,"FAQ 17
  How do I programmatically open the SUnit TestRunner?
  
 Answer 
  
 Evaluate
  TestRunner open
 .
  
 FAQ 18
  Where can I find the Refactoring Browser?
  
 Answer 
  
 Load AST then Refactoring Engine from squeaksource.com:
  http:
  
 //www.squeaksource.com/AST http://www.squeaksource.com/RefactoringEngine
  
 FAQ 19
  How do I register the browser that I want to be the default?
  
 Answer 
  
 Click the menu icon in the top right of the Browser window.",NA
A.6 ,NA,NA
Regular expressions and parsing,"FAQ 20
  Where is the documentation for the RegEx package?
  
 Answer 
  
 Look at the
  DOCUMENTATION
  protocol of
  RxParser class
  in the
  
 VB-Regex
  category.
  
 FAQ 21
  Are there tools for writing parsers?
  
 Answer 
  
 Use SmaCC — the Smalltalk Compiler Compiler. You should
  
 install at least SmaCC-lr.13. 
  
 Load it from
  http://www.squeaksource.com/
  
 SmaccDevelopment.html
 . There is a nice tutorial online:
  http://www.refactory.com/
  
 Software/SmaCC/Tutorial.html
  
 FAQ 22
  Which packages should I load from SqueakSource SmaccDevelopment 
 to
  
 write parsers?
  
 Answer 
  
 Load the latest version of SmaCCDev — the runtime is already
  
 there. (SmaCC-Development is for Squeak 3.8)",NA
Bibliography,"Sherman R. Alpert, Kyle Brown and Bobby Woolf:
  The Design Patterns 
  
 Smalltalk Companion. Addison Wesley, 1998, ISBN 0–201–18462–1
  
 Kent Beck:
  Smalltalk Best Practice Patterns. Prentice-Hall, 1997
  
 Kent Beck:
  Test Driven Development: By Example. Addison-Wesley, 2003, 
  
 ISBN 0–321–14653–0
  
 John Brant et al.:
  Wrappers to the Rescue. In Proceedings European Con-
 ference on Object Oriented Programming (ECOOP’98). Volume 1445, 
 Springer-Verlag 1998, 396–417
  
 Erich Gamma et al.:
  Design Patterns: Elements of Reusable Object-Oriented 
 Software. Reading, Mass.: Addison Wesley, 1995, ISBN 0–201–63361–2–
 (3)
  
 Adele Goldberg and David Robson:
  Smalltalk 80: the Language and its 
 Implementation. Reading, Mass.: Addison Wesley, May 1983, ISBN 0–
 201–13688–0
  
 Dan Ingalls et al.:
  Back to the Future: The Story of Squeak, a Practi-
  
 cal Smalltalk Written in Itself. In Proceedings of the 12th ACM SIG-
  
 PLAN conference on Object-oriented programming, systems, languages, 
  
 and applications (OOPSLA’97). 
  
 ACM Press, November 1997
  ⟨
 URL: 
  
 http://www.cosc.canterbury.ac.nz/~wolfgang/cosc205/squeak.html
 ⟨
 , 318–326
  
 Wilf LaLonde and John Pugh:
  Inside Smalltalk: Volume 1. Prentice Hall, 
  
 1990, ISBN 0–13–468414–1
  
 Alec Sharp:
  Smalltalk by Example. McGraw-Hill, 1997
  ⟨
 URL:
  http://stephane. 
  
 ducasse.free.fr/FreeBooks/ByExample/
 ⟨
  
 Bobby Woolf:
  Null Object. In
  Robert Martin, Dirk Riehle and Frank 
 Buschmann, editors:
  Pattern Languages of Program Design 3. Ad-dison 
 Wesley, 1998, 5–18",NA
Index,"*, see package, dirty 
  
 Array
  (class), 186, 188, 189
  
 :=
 , see assignment 
  
 Array class
  
 ;, see cascade 
  
 new:
 , 189
  
 ←
 , see assignment 
  
 with:
 , 189
  
 [ ]
 , see block 
  
 #( )
 , see Array, literal 
 #
 , see literal symbol
  
 as yet unclassified
  (protocol), 38 
 assignment, 51, 92 
  
 association, see Object,
  −>
  
 _
 , see assignment 
  
 AST, 319
  
 .
 , see statement separator 
 ==
 , see Object, identity 
  
 =
 , see Object, equality 
  
 >>
 , see Behavior,
  >>
  
 at:
 , see Collection,
  at: 
  
 at:put:
 , see Collection,
  at:put: 
  
 attribute, see instance variable
  
 become:
 , see
  ProtoObject»become: 
  
 Bag 
  
 { }
 , see Array, dynamic 
  
  
 (class), 187, 193
 ↑
 , 
 see return 
  
 Bag
  (class), 186 
  
   
 BalloonCanvas
  (class), 236 
 abstract class, see class, abstract 
  
  
 Beck, Kent, 94, 147 abstract method, see method, abstract 
  
 Behavior 
  
 accept it, see keyboard shortcut, accept 
  
  
 >>
 , 22, 38
  
 accessing
  (protocol), 40, 82, 185 
  
 accessing untypeable characters
  (protocol),
  
 addSelector:withMethod:
 , 308 
 addSubclass:
 , 285
  
 177 
  
 allInstances
 , 285, 294
  
 accessor, 40, 81 
  
 ActiveHand
  (global), 99 
  
 adding
  (protocol), 185 
  
 Agile software development, 147 
 AJAX, 269
  
 allInstVarNames
 , 281, 294 
 allSelectors
 , 285, 294 
  
 allSubclasses
 , 294 
  
 allSubInstances
 , 294 
  
 allSuperclasses
 , 281, 294
  
 all
  (protocol), 31, 37, 108, 118 
  
 basicNew
 , 285
  
 AlphaBlendingCanvas
  (class), 236 
 basicNew:
 , 285
  
 Array 
 canUnderstand:
 , 285
  
 (class), 187, 189 
  
 at:
 , 189, 190
  
 compiledMethodAt:
 , 285 
  
 crossReference
 , 295
  
 at:put:
 , 189, 190 
  
 hasMethods
 , 285
  
 copy
 , 190 
  
 includesSelector
 , 285
  
 dynamic, 51, 167 
 literal, 51, 167, 190
  
 inheritsFrom:
 , 285 
  
 instanceCount
 , 294",NA
