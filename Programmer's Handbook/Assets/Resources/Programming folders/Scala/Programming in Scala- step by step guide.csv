Larger Text,Smaller Text,Symbol
A comprehensive step-by-step guide,NA,NA
Programming in ,NA,NA
Scala,NA,NA
Martin Odersky,NA,NA
Lex Spoon,"Prepared for 
 jacques weiss",NA
artima,NA,NA
Bill Venners,NA,NA
Programming in ,NA,NA
Scala ,PrePrint™ Edition,NA
Programming in ,NA,NA
Scala ,"PrePrint™ Edition
  
 Martin Odersky, Lex Spoon, Bill Venners",NA
artima ,"A
 RTIMA
  P
 RESS 
  
 M
 OUNTAIN
  V
 IEW
 , C
 ALIFORNIA
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Overview,"Prepared for jacques weiss
  
 Contents
  
 viii 
 Preface
  
 xvi 
 Acknowledgments
  
 xvii 
 Introduction
  
 xx 
 1.
  
 A Scalable Language
  
 27 
 2.
  
 First Steps in Scala
  
 47 
 3.
  
 Next Steps in Scala
  
 63 
 4.
  
 Classes and Objects
  
 90 
 5.
  
 Basic Types and Operations
  
 114 
 6.
  
 Functional Objects
  
 136 
 7.
  
 Built-in Control Structures
  
 151 
 8.
  
 Functions and Closures
  
 169 
 9.
  
 Control Abstraction
  
 190 
 10. Composition and Inheritance
  
 205 
 11. Traits and Mixins
  
 233 
 12. Case Classes and Pattern Matching
  
 249 
 13. Packages and Imports
  
 279 
 14. Working with Lists
  
 292 
 15. Collections
  
 322 
 16. Stateful Objects
  
 342 
 17. Type Parameterization
  
 362 
 18. Abstract Members and Properties
  
 379 
 19. Implicit Conversions and Parameters
  
 396 
 20. Implementing Lists
  
 413 
 21. Object Equality
  
 424 
 22. Working with XML
  
 438 
 23. Actors and Concurrency
  
 450 
 24. Extractors
  
 461 
 25. Objects As Modules
  
 473 
 26. Annotations
  
 484 
 27. Combining Scala and Java
  
 490 
 28. Combinator Parsing
  
 502 
 Glossary
  
 530 
 Bibliography
  
 544 
 About the Authors
  
 546 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  
 Index",NA
Contents,"Prepared for jacques weiss
  
 Contents
  
 viii
  
 Preface
  
 xvi
  
 Acknowledgments
  
 xvii
  
 Introduction
  
 xx
  
 1
  
 A Scalable Language
  
 27
  
 1.1
  
 A language that grows on 
 you
  
 . . . . . . . . . . . . . . . . 
 28 
 1.2
  
 What makes Scala scalable?
  
 . . . . . . . . . . . . . . . . . 
 33 
 1.3
  
 Why Scala?
  . . . . . . . . . . . . . . . . . . . . . . . . . . 
 36 
 1.4
  
 Scala’s roots
  . . . . . . . . . . . . . . . . . . . . . . . . . . 
 44 
 1.5
  
 Conclusion
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . 
 45 
 2
  
 First Steps in Scala
  
 47
  
 Step 1. Learn to use the Scala interpreter
  . . . . . . . . . . . . . . 
 47 
 Step 2. Define some variables
  . . . . . . . . . . . . . . . . . . . . 
 49 
 Step 3. Define some functions
  
 . . . . . . . . . . . . . . . . . . . 
 51 
 Step 4. Write some Scala scripts
  . . . . . . . . . . . . . . . . . . 
 55 
 Step 5. Loop with
  while
 , decide with
  if
  . . . . . . . . . . . . . . 
 57 
 Step 6. Iterate with
  foreach
  and
  for
  . . . . . . . . . . . . . . . . 
 59 
 Conclusion
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 62 
 3
  
 Next Steps in Scala
  
 63
  
 Step 7. Understand the importance of
  val
 s
  . . . . . . . . . . . . . 
 63 
 Step 8. Parameterize
  Array
 s with 
 types
  
 . . . . . . . . . . . . . . 
 65 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  
 Index",NA
Preface,"I’d like to thank you for purchasing the PrePrint™ Edition of
  
 Programming in Scala
 . Even though the book is still somewhat rough, 
 we believe you can already use this book very effectively to learn 
 Scala. 
 We released this PrePrint™ quite early in the book-writing process 
 in part because so little documentation has up to now existed for Scala, 
 but also because we want feedback to help us make the book better. At 
 the bottom of each page is a
  Suggest
  link, which will take you to a 
 small web application where you can submit comments about that 
 page. We’ll know which version and page you’re on, so all you need to 
 do is type your comment. 
 At this point we’re interested in feedback on all aspects of the book 
 ex-cept formatting. Please report any misspelled words, typos, or 
 grammar er-rors. Let us know if you find something confusing, and be 
 specific. Point out places where we appear to assume you know 
 something that you don’t. In short, we’re interested in hearing about 
 your reading experience, but please don’t report formatting errors. 
 Formatting is something we plan to fix shortly before we send the 
 book to the printer. At this point, we are aware that some lines are too 
 long, the words are spaced out a bit too much here and there, the 
 figures are surrounded by inconsistently sized white space, etc. Please 
 forgive us for this for the time being, and don’t report such problems. 
 By purchasing Version 2 of
  Programming in Scala
 , PrePrint™ 
 Edition, you are entitled to download all updates until we publish the 
 final version of 
 Prepared 
 for 
 jacques 
 weiss
  
 the book. We thank you again for getting in on the ground floor and look 
 forward to your feedback. 
 Bill Venners",NA
Acknowledgments,"Many people have contributed to this book and to the material it 
 covers. We are grateful to all of them. 
 Scala itself has been a collective effort of many people. The design 
 and the implementation of version 1.0 was helped by Philippe Altherr, 
 Vincent Cremet, Gilles Dubochet, Burak Emir, Stéphane Micheloud, 
 Nikolay Mi-haylov, Michel Schinz, Erik Stenman, and Matthias Zenger. 
 Iulian Dragos, Gilles Dubochet, Philipp Haller, Sean McDirmid, Ingo 
 Maier, and Adriaan Moors joined in the effort to develop the second 
 and current version of the language and tools. 
 Gilad Bracha, Craig Chambers, Erik Ernst, Matthias Felleisen, 
 Shriram Krishnamurti, Gary Leavens, Sebastian Maneth, Erik Meijer, 
 David Pol-lak, Jon Pretty, Klaus Ostermann, Didier Rémy, Vijay 
 Saraswat, Don Syme, Mads Torgersen, Philip Wadler, Jamie Webb, and 
 John Williams have shaped the design of the language by graciously 
 sharing their ideas with us in lively and inspiring discussions, as well 
 as through comments on previous versions of this document. The 
 contributors to the Scala mailing list have also given very useful 
 feedback that helped us improve the language and its tools. 
 George Berger has worked tremendously to make the build 
 process and the web presence for the book work smoothly. As a result 
 this project has been delightfully free of technical snafus. 
 Many people have given us feedback on early versions of the text. 
 Thank you to Eric Armstrong, George Berger, Gilad Bracha, William 
 Cook, Bruce",NA
Introduction,"This book is a tutorial for the Scala programming language, written by 
 peo-ple directly involved in the development of Scala. Our goal is that 
 by reading this book, you can learn everything you need to be a 
 productive Scala pro-grammer.",NA
Who should read this book,"The main target audience is programmers who want to learn to 
 program in Scala. If you want to do your next software project in Scala, 
 then this is the book for you. In addition, the book should be 
 interesting to program-mers wishing to expand their horizons by 
 learning new concepts. If you’re a Java programmer, for example, 
 reading this book will expose you to many concepts from functional 
 programming as well as advanced object oriented ideas. We believe 
 learning Scala can help you become a better programmer in general. 
  
 General programming knowledge is assumed. While Scala is a fine 
 first programming language, this is not the book to use to learn 
 programming. 
 On the other hand, no specific knowledge of programming 
 languages is required. Even though most people use Scala on the Java 
 platform, this book does not presume you know anything about Java. 
 However, we expect many readers to be familiar with Java, and so we 
 sometimes compare Scala to Java to help such readers understand the 
 differences.",NA
How to use this book ,"The main purpose of this book is to serve as a tutorial to help you 
 learn to program in Scala. Thus, the recommended way to read this 
 book is in chapter 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  
 Glossary
  ·
  Index",NA
How to learn Scala,"You will learn a lot about Scala simply by reading this book from cover 
 to cover. You can learn Scala faster and more thoroughly, though, if 
 you do a few extra things. 
 First of all, you can take advantage of the many program examples 
 in-cluded in the book. Typing them in yourself is a way to force your 
 mind through each line of code. Trying variations is a way to make 
 them more fun and to make sure you really understand how they 
 work. 
 Second, keep in touch with the numerous online forums. That way, 
 you and other Scala enthusiasts can help each other. There are 
 numerous mailing lists, there is a wiki, and there are multiple Scala-
 specific article feeds. Take some time to find ones that fit your 
 information needs. You will spend a lot less time stuck on little 
 problems, so you can spend your time on deeper,",NA
Ebook features,"The eBook is not simply a printable version of the paper version of the 
 book. While the content is the same as in the paper version, the eBook 
 has been carefully prepared for reading on a computer screen. 
 The first thing to notice is that most references within the book are 
 hy-perlinked. If you select a reference to a chapter, figure, or glossary 
 entry, your browser should take you immediately to the selected item 
 so that you do not have to flip around to find it. 
 Additionally, at the bottom of each page are a number of 
 navigation links. The “Cover,” “Overview,” and “Contents” links take 
 you to major portions of the book. The “Glossary” and “Index” links 
 take you to reference parts of the book. Finally, the “Discuss” link 
 takes you to an online forum where you discuss questions with other 
 readers, the authors, and the larger Scala community. If you find a 
 typo, or something you think could be explained better, please click on 
 the “Suggest” link, which will take you to an online web application 
 with which you can give the authors feedback. 
 Although the same pages appear in the eBook as the printed book, 
 blank pages are removed and the remaining pages renumbered. The 
 pages are num-bered differently so that it is easier for you to 
 determine PDF page numbers when printing only a portion of the 
 eBook. The pages in the eBook are, therefore, numbered exactly as in 
 your PDF reader will number them.",NA
Typographic conventions,"The first time a
  term
  is used, it is italicized. Small code examples, such 
 as 
 x + 1
 , are written inline with a mono-spaced font. Larger code 
 examples are put into mono-spaced quotation blocks like this: 
 def hello() {
  
 println(""Hello, world!"")
  
 }",NA
Content overview,"•
  Chapter 1
 , “A Scalable Language,” describes the history of Scala 
 and  
 why you should care about the language. 
 •
  Chapter 2
 , “First Steps in Scala,” rapidly shows you how to do a 
 num-ber of basic programming tasks in Scala, without going into 
 detail about how they work. 
 •
  Chapter 3
 , “Next Steps in Scala,” continues the previous chapter 
 and  
 rapidly shows you several more basic programming tasks. 
 •
  Chapter 4
 , “Classes and Objects,” starts the in-depth coverage of 
 Scala with a description of the basic building blocks of object-
 oriented lan-guages. 
 •
  Chapter 5
 , “Basic Types and Operations,” shows how to work with 
  common types like integers and common operations like 
 addition. 
 •
  Chapter 6
 , “Functional Objects,” goes into more depth on object-
 oriented  structures, using immutable rational numbers as a case 
 study. 
 •
  Chapter 7
 , “Basic Control Structures,” shows how to use familiar 
 con- 
 trol structures like
  if
  and
  while
 . 
 •
  Chapter 8
 , “Functions,” discusses in depth functions, the basic 
 build- 
 ing block of functional languages. 
 •
  Chapter 10
 , “Composition and Inheritance,” discusses more of 
 Scala’s support object-oriented programming. The topics are not 
 as funda-mental as those in
  Chapter 4
 , but they frequently arise 
 in practice. 
 •
  Chapter 11
 , “Traits and Mixins,” shows Scala’s
  trait
  mechanism for 
  mixin composition.",NA
Programming in ,NA,NA
Scala ,PrePrint™ Edition,NA
Chapter 1,NA,NA
A Scalable Language,"The name Scala stands for “scalable language.” The language is so 
 named because it was designed to grow with the demands of its users. 
 You can apply Scala to a wide range of programming tasks, from 
 writing small scripts to building large systems.
 1 
  
  
 Scala is easy to get into. It runs on the standard Java platform and it 
 inter-operates seamlessly with all Java libraries. It’s a great language 
 for writing scripts that pull together Java components. But it can play 
 out its strengths even more for building large systems and frameworks 
 of reusable compo-nents. 
 Technically, Scala is a blend of object-oriented and functional 
 program-ming concepts in a statically typed language. The fusion of 
 object-oriented and functional programming shows up in many 
 different aspects of Scala; it is probably more pervasive than in any 
 other widely used language. The two programming styles have 
 complementary strengths when it comes to scala-bility. Scala’s 
 functional programming constructs make it easy to build inter-esting 
 things quickly from simple parts. Its object-oriented constructs make 
 it easy to structure larger systems and to adapt them to new demands. 
 The combination of both styles in Scala makes it possible to express 
 new kinds of programming patterns and component abstractions. It 
 also leads to a legible 
 or jacques weiss
  
 and concise programming style. Because it is so malleable, 
 programming in Scala can be a lot of fun. 
 This initial chapter answers the question, “Why Scala?” It gives a 
 high-level view of Scala’s design and the reasoning behind it. After 
 reading the",NA
1.1 ,NA,NA
A language that grows on you,"Programs of different sizes tend to require different programming 
 constructs. Consider, for example, the following small Scala program: 
 var capital = Map(""US"" -> ""Washington"",
  
 ""France"" -> ""Paris"")
  
 capital += (""Japan"" -> ""Tokyo"")
  
 println(capital(""France""))
  
 This program sets up a map from countries to their capitals, modifies 
 the map by adding a new binding
  (""Japan"" -> ""Tokyo"")
 , and prints the 
 capital asso-ciated with the country France.
 2
 The notation in this 
 example is high-level, to the point, and uncluttered with extraneous 
 semicolons or type annotations. Indeed, the feel is that of a modern 
 “scripting” language like Perl, Python or Ruby. One common 
 characteristic of these languages, which is relevant for the example 
 above, is that they each support an “associative map” construct in the 
 syntax of the language. 
 Associative maps are very useful because they help keep programs 
 leg-ible and concise. However, sometimes you might not agree with 
 their “one size fits all” philosophy, because you need to control the 
 properties of the maps you use in your program in a more fine-grained 
 way. Scala gives you this fine-grained control if you need it, because 
 maps in Scala are not lan-guage syntax. They are library abstractions 
 that you can extend and adapt. 
 In the above program, you’ll get a default
  Map
  implementation, but 
 you can easily change that. You could for example specify a particular 
 imple- 
 cques weiss
  
 mentation, such as a
  HashMap
  or a
  TreeMap
 , or you could specify that the 
 map should be thread-safe, “mixing in” a
  SynchronizedMap
  “trait.” You 
 could specify a default value for the map, or you could override any 
 other",NA
1.2,"Chapter 1 · A Scalable Language
  
 33",NA
What makes Scala scalable?,"Scalability is influenced by many factors, ranging from syntax details 
 to component abstraction constructs. If we were forced to name just 
 one aspect of Scala that helps scalability, we’d pick its combination of 
 object-oriented and functional programming (well, we cheated, that’s 
 really two aspects, but they are intertwined). 
 Scala goes further than all other well-known languages in fusing 
 object-oriented and functional programming into a uniform language 
 design. For instance, where other languages might have objects and 
 functions as two different concepts, in Scala a function value
  is
  an 
 object. Function types are classes that can be inherited by subclasses. 
 This might seem nothing more than an academic nicety, but it has 
 deep consequences for scalability. In fact the actor concept shown 
 previously could not have been implemented without this unification 
 of functions and objects. 
 Scala is object-oriented
  
 Object-oriented programming has been immensely successful. Starting 
 from Simula in the mid-60’s and Smalltalk in the 70’s, it is now 
 available in more languages than not. In some domains objects have 
 taken over completely. While there is not a precise definition of what 
 object-oriented means, there is clearly something about objects that 
 appeals to programmers. 
 In principle, the motivation for object-oriented programming is 
 very sim-ple: all but the most trivial programs need some sort of 
 structure. The most straightforward way to do this is to put data and 
 operations into some form of containers. The great idea of object-
 oriented programming is to make these containers fully general, so 
 that they can contain data as well as operations, and that they are 
 themselves values that can be stored in other containers, or passed as 
 parameters to operations. Such containers are called objects. Alan Kay, 
 the inventor of Smalltalk, remarked that in this way the simplest 
 object",NA
1.3 ,NA,NA
Why Scala?,"Is Scala for you? You will have to see and decide for yourself. We have 
 found that there are actually many reasons besides scalability to like 
 pro-gramming in Scala. Four of the most important aspects will be 
 discussed in the following. They are: compatibility, brevity, high-level 
 abstractions, and advanced static typing. 
 Scala is compatible
  
 Scala’s doesn’t require you to leap backwards off the Java platform to 
 step forward from the Java language. It allows you to add value to 
 existing code—to build on what you already have, because it was 
 designed for seamless in-teroperability with Java.
 7
 Scala programs 
 compile to JVM bytecodes. Their run-time performance is usually on 
 par with Java programs. Scala code can 
 ques weiss
  
 call Java methods, access Java fields, inherit from Java classes, and 
 imple-ment Java interfaces. None of this requires special syntax, explicit 
 interface",NA
1.4,"Chapter 1 · A Scalable Language
  
 44",NA
Scala’s roots,"Scala’s design has been influenced by many programming languages 
 and ideas in programming language research. In fact, only a few 
 features of Scala are genuinely new; most have been already applied in 
 some form in other languages. Scala’s innovations come primarily 
 from how its constructs are put together. In this section, we list the 
 main influences on Scala’s design. The list cannot be exhaustive—
 there are simply too many smart ideas around in programming 
 language design to enumerate them all here. 
 At the surface level, Scala adopts a large part of the syntax of Java 
 and C#, which in turn borrowed most of their syntactic conventions 
 from C and C++. Expressions, statements and blocks are mostly as in 
 Java, as is the syntax of classes, packages and imports.
 12
 Besides 
 syntax, Scala adopts other elements of Java, such as its basic types, its 
 class libraries, and its execution model. 
 Scala also owes much to other languages. Its uniform object model 
 was pioneered by Smalltalk and taken up subsequently by Ruby. Its 
 idea of uni-versal nesting (almost every construct in Scala can be 
 nested inside any other construct) is also present in Algol, Simula, and, 
 more recently in Beta and gbeta. Its uniform access principle for 
 method invocation and field selection comes from Eiffel. Its approach 
 to functional programming is quite simi-lar in spirit to the ML family 
 of languages, which has SML, OCaml, and F# as prominent members. 
 Many higher-order functions in Scala’s standard library are also 
 present in ML or Haskell. Scala’s implicit parameters were motivated 
 by Haskell’s type classes; they achieve analogous results in a more 
 classical object-oriented setting. Scala’s actor-based concurrency 
 library was heavily inspired by Erlang. 
 Scala is not the first language to emphasize scalability and 
 extensibil-ity. The historic root of extensible languages that can span 
 different appli- 
 12
  The major deviation from Java concerns the syntax for type annotations—
 it’s“
 variable: Type
 ” instead of “
 Type variable
 ” in Java. Scala’s postfix type syntax re-
 sembles Pascal, Modula-2, or Eiffel. The main reason for this deviation has to do with 
 type",NA
1.5 ,NA,NA
Conclusion,"In this chapter, we gave you a glimpse of what Scala is and how it 
 might help you in your programming. To be sure, Scala is not a silver 
 bullet that will magically make you more productive. To advance, you 
 will need to apply Scala artfully, and that will require some learning 
 and practice. If you’re",NA
Chapter 2,NA,NA
First Steps in Scala,"It’s time to write some Scala code. Before we start on the in-depth 
 Scala tutorial, we put in two chapters that will give you the big picture 
 of Scala, and most importantly, get you writing code. We encourage 
 you to actually try out all the code examples presented in this chapter 
 and the next as you go. The best way to get started learning Scala is to 
 program in it. 
 To run the examples in this chapter, you should have a standard 
 Scala installation. To get one, go to
  http://www.scala-lang.org/downloads 
 and follow the directions for your platform. You can also use a Scala 
 plug-in for Eclipse, but for the steps in this chapter, we’ll assume 
 you’re using the Scala distribution from
  scala-lang.org
 . 
 If you are a veteran programmer new to Scala, the next two 
 chapters should give you enough understanding to enable you to start 
 writing useful programs in Scala. If you are less experienced, some of 
 the material may seem a bit mysterious to you. But don’t worry. 
 Everything will be explained in greater detail in later chapters.",NA
Step 1. Learn to use the Scala interpreter,"The easiest way to get started with Scala is by using the Scala interpreter,",NA
Step 2. Define some variables,"Scala has two kinds of variables,
  val
 s and
  var
 s.
  val
 s are similar to final 
 variables in Java. Once initialized, a
  val
  can never be reassigned.
  var
 s, by 
 contrast, are similar to non-final variables in Java. A
  var
  can be 
 reassigned throughout its lifetime. Here’s a
  val
  definition: 
 scala> val msg = ""Hello, world!""
  
 msg: java.lang.String = Hello, world!
  
 This statement introduces
  msg
  as a name for the
  String ""Hello world!""
 . The 
 type of
  msg
  is
  java.lang.String
 , because Scala strings are imple-mented by 
 Java’s
  String
  class. 
 If you’re used to declaring variables in Java, you’ll notice one 
 striking difference here: neither
  java.lang.String
  or
  String
  appear 
 anywhere in the
  val
  definition. This example illustrates
  type inference
 , 
 Scala’s ability to figure out types from context. In this case, because 
 you initialized
  msg
  with a",NA
Step 3. Define some functions,"Now that you’ve worked with Scala variables, you’ll probably want to write 
 some functions. Here’s how you do that in Scala: 
 scala> def max(x: Int, y: Int): Int = {
  
 | if (x > y)
  
 | x
  
 | else
  
 | y
  
 | }
  
 max: (Int,Int)Int
  
 Prepared for jacques weiss
  
 Function definitions start with
  def
 . The function’s name, in this case
  
 max
 , is followed by a comma-separated list of parameters in 
 parentheses. A type an-notation must follow every function 
 parameter, preceded by a colon, because the Scala compiler (and 
 interpreter, but from now on we’ll just say compiler) does not infer 
 function parameter types. In this example, the function named 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Step 4. Write some Scala scripts,"Although Scala is designed to help programmers build very large-scale 
 sys-tems, it also scales down nicely to scripting. A script is just a 
 sequence of statements in a file that will be executed sequentially. Put 
 this into a file named
  hello.scala
 : 
 println(""Hello, world, from a script!"")
  
 then run: 
 $ scala hello.scala
  
 And you should get yet another greeting: 
 Hello, world, from a script!
  
 Command line arguments to a Scala script are available via a Scala 
 ar-ray named
  args
 . In Scala, arrays are zero based, as in Java, but you 
 access an element by specifying an index in parentheses rather than 
 square brack-ets. So the first element in a Scala array named
  steps
  is
  
 steps(0)
 , not",NA
Step 5. Loop with,while,NA
", decide with","if
  
 You write
  while
  loops in Scala in much the same way as in Java. Try out a 
 while
  by typing the following into a file name
  printargs.scala
 : 
 var i = 0
  
 while (i < args.length) {
  
 println(args(i))
  
 i += 1
  
 }
  
 This script starts with a variable definition,
  var i = 0
 . Type inference 
 gives
  i
  the type
  scala.Int
 , because that is the type of its initial value,
  0
 . 
 The
  while
  construct on the next line causes the
  block
  (the code between 
 the curly braces) to be repeatedly executed until the boolean 
 expression 
 i < args.length
  is false.
  args.length
  gives the length of the
  args
  ar-
 ray, similar to the way you get the length of an array in Java. The block 
 contains two statements, each indented two spaces, the recommended 
 inden-tation style for Scala. The first statement,
  println(args(i))
 , prints 
 out the
  i
 th command line argument. The second statement,
  i += 1
 , 
 increments 
 i
  by one. Note that Java’s
  ++i
  and
  i++
  don’t work in Scala. To 
 increment in Scala, you need to say either
  i = i + 1
  or
  i += 1
 . Run this 
 script with the following command: 
 $ scala printargs.scala Scala is fun
  
 Prepared for jacques weiss
  
 And you should see:  
 Scala 
  
 is 
  
 fun 
  
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  
 Index",NA
Step 6. Iterate with,foreach,NA
 and,"for
  
 Although you may not have realized it, when you wrote the while 
 loops in the previous step, you were programming in an
  imperative
  
 style. In the imperative style, which is the style you would ordinarily 
 use with languages like Java, C++, and C, you give one imperative 
 command at a time, iterate with loops, and often mutate state shared 
 between different functions. Scala",NA
"(x: Int, y: Int) => x + y","Figure 2.2: The syntax of a function literal in Scala. 
 If instead of an explicit mood, you’re in the mood for even more 
 concise-ness, you can take advantage of a special shorthand in Scala. If 
 an function literal consists of one statement that takes a single 
 argument, 
 you 
 need 
 not 
 explicitly 
 name 
 and 
 specify 
 the 
 argument.
 11
 Thus, the following code also works: 
 args.foreach(println)
  
 To summarize, the syntax for a function literal is a list of named 
 parameters, in parentheses, a right arrow, and then the body of the 
 function. This syntax is illustrated in
  Figure 2.2
 . 
 Now, by this point you may be wondering what happened to those 
 trusty for loops you have been accustomed to using in imperative 
 languages such as Java. In an effort to guide you in a functional 
 direction, only a functional relative of the imperative
  for
  (called a
  for 
 expression
 ) is available in Scala. While you won’t see their full power 
 and expressiveness until you reach (or peek ahead to)
  Section 7.3
  on
  
 page 156
 , we’ll give you a glimpse here. In a new file named
  
 forprintargs.scala
 , type the following: 
 for (arg <- args)
  
 println(arg)
  
  weiss
  
 The parentheses after the 
 for
  in this for expression contain",NA
Conclusion,"In this chapter, you learned some Scala basics and, hopefully, took 
 advantage of the opportunity to write a bit of Scala code. In the next 
 chapter, we’ll continue this introductory overview and get into more 
 advanced topics.",NA
Chapter 3,NA,NA
Next Steps in Scala,"This chapter continues the previous chapter’s introduction to Scala. In 
 this chapter, we’ll introduce some more advanced features. When you 
 complete this chapter, you should have enough knowledge to enable 
 you to start writ-ing useful scripts in Scala. As with the previous 
 chapter, we recommend you try out these examples as you go. The 
 best way to start getting a feel for Scala is to start writing in it.",NA
Step 7. Understand the importance of,val,NA
s,"As mentioned in
  Chapter 1
 , Scala allows you to program in an
  
 imperative 
 style, but encourages you to adopt a more
  functional
  style. 
 If you are coming to Scala from an imperative background—for 
 example, if you are a Java programmer—one of the main challenges 
 you will likely face when learning Scala is figuring out how to program 
 in the functional style. We realize this transition can be difficult, and in 
 this book we try hard to guide you through it. But it will require some 
 work on your part, and we encourage you to make the effort. If you 
 come from an imperative background, we believe that learning to 
 program in a functional style will not only make you a better Scala 
 programmer, it will expand your horizons and make you a",NA
Step 8. Parameterize,Array,NA
s with types,"In addition to being functional, Scala is object-oriented. In Scala, as in 
 Java, you define a blueprint for objects with classes. From a class 
 blueprint, you can instantiate objects, or class instances, by using
  new
 . 
 For example, the following Scala code instantiates a new
  String
  and 
 prints it out: 
 val s = new String(""Hello, world!"")
  
 println(s)
  
 In the previous example, you
  parameterize
  the
  String
  instance with 
 the initial value
  ""Hello, world!""
 . Parameterization means configuring an 
 in-stance at the point in your program that you create that instance. 
 You con-figure an instance with values by passing objects to a 
 constructor of the in-stance in parentheses, just like you do when you 
 create an instance in Java. If you place the previous code in a new file 
 named
  paramwithvalues.scala 
 and run it with
  scala paramwithvalues.scala
 , 
 you’ll see the familiar 
 Hello, world!
  greeting printed out. 
 In addition to parameterizing instances with values at the point of 
 instan-tiation, you can also parameterize them with types. This kind of 
 parame-terization is akin to specifying a type in angle brackets when 
 instantiating a generic type in Java 5 and beyond. The main difference 
 is that instead of the angle brackets used for this purpose in Java, in 
 Scala you use square brackets. Here’s an example: 
 val greetStrings = new Array[String](3)
  
 greetStrings(0) = ""Hello""
  
 greetStrings(1) = "", """,NA
1 + 2,"Int
  object invoking on 
 1 
  
 Passing the 
 Int
  
 with value 
 1 
  
 a method 
  
  
 named ‘
 +
 ’
  
  
  
 object 
 2
  to 
 the
  
   
  
 ‘
 +
 ’ method",NA
(1).+(2),"Figure 3.1: All operations are method calls in Scala. 
 print(greetStrings(i))
  
 The first line of code in this for expression illustrates another general 
 rule of Scala: if a method takes only one parameter, you can call it 
 without a dot or parentheses.
  to
  is actually a method that takes one
  Int
  
 argument. The code
  0 to 2
  is transformed into the method call
  (0).to(2)
 . 
 (This
  to
  method actually returns not an
  Array
  but a Scala
  iterator
  
 containing the values 0, 1, and 2, which the for expression iterates 
 over. Iterators will be described in 
 Chapter 15
 .) Scala doesn’t 
 technically have operator overloading, because it doesn’t actually have 
 operators in the traditional sense. Characters such as
  +
 ,
 -
 ,
  *
 , and
  /
 , have 
 no special meaning in Scala, but they can be used in method names. 
 Thus, when you typed
  1 + 2
  into the Scala interpreter in Step 1, you 
 were actually invoking a method named
  +
  on the
  Int
  object
  1
 , passing in 
 2
  as a parameter. As illustrated in
  Figure 3.1
 , you could alternatively 
 have written
  1 + 2
  using traditional method invocation syntax,
  (1).+(2)
 . 
 Another important idea illustrated by this example will give you 
 insight into why arrays are accessed with parentheses in Scala. Scala 
 has fewer 
 Pr
 ep
 are
 d 
 for 
 jac
 qu
 es 
 we
 iss
  
 special cases than Java. Arrays are simply instances of classes like any",NA
Step 9. Use,List,NA
s and,Tuple,NA
s,"One of the big ideas of the functional style of programming is that 
 meth-ods should not have side effects. The only effect of a method 
 should be to compute the value or values that are returned by the 
 method. Some benefits gained when you take this approach are that 
 methods become less entangled, and therefore more reliable and 
 reusable. Another benefit of the functional style in a statically typed 
 language is that everything that goes into and out of a method is 
 checked by a type checker, so logic errors are more likely to manifest 
 themselves as type errors. To apply this functional philosophy to the 
 world of objects, you would make objects immutable. A simple 
 example of an immutable object in Java is
  String
 . If you create a
  String
  
 with the value
  ""Hello, ""
 , it will keep that value for the rest of its lifetime. 
 If you later call
  concat(""world!"")
  on that
  String
 , it will not add
  ""world!""
  to 
 itself. Instead, it will create and return a brand new
  String
  with the 
 value 
 ""Hello, world!""
 . 
  
 As you’ve seen, a Scala
  Array
  is a mutable sequence of objects that all 
 share the same type. An
  Array[String]
  contains only
  String
 s, for example. 
 Although you can’t change the length of an
  Array
  after it is in-stantiated, 
 you can change its element values. Thus,
  Array
 s are mutable objects. An 
 immutable, and therefore more functional-oriented, sequence of 
 objects that share the same type is Scala’s
  List
 .  
 As with
  Array
 s, a 
 List[String]
  contains only
  String
 s. Scala’s
  List
 ,
  scala.List
 , differs from Java’s
  
 java.util.List
  type in that Scala
  List
 s are always immutable (whereas Java
  
 List
 s can be mutable). But more importantly, Scala’s
  List 
 is designed to 
 enable a functional style of programming. Creating a
  List
  is easy, you 
 just say: 
 val oneTwoThree = List(1, 2, 3)
  
 This establishes a new
  val
  named
  oneTwoThree
 , which is initalized with a 
 new
  List[Int]
  with the integer element values 1, 2 and 3.
 1
 Because
  List
 s 
 ques weiss
  
 are immutable, they behave a bit like Java
  String
 s in that when you call 
 a method on one that might seem by its name to imply the
  List
  will be 
 mutated, it instead creates a new
  List
  with the new value and returns 
 it. For",NA
Step 10. Use,Set,NA
s and,Map,NA
s,"Because Scala aims to help you take advantage of both functional and 
 im-perative styles, its collections libraries make a point to differentiate 
 between mutable and immutable collection classes. For example,
  
 Array
 s are always mutable, whereas
  List
 s are always immutable. When 
 it comes to
  Set
 s and 
 Map
 s, Scala also provides mutable and immutable 
 alternatives, but in a differ-ent way. For
  Set
 s and
  Map
 s, Scala models 
 mutability in the class hierarchy.",NA
Set,"«trait»
  
 scala.collection.immutable",NA
Set,scala.collection.mutable,NA
Set,"«trait»
  
 «trait»
  
 scala.collection.immutable",NA
HashSet,scala.collection.mutable,NA
HashSet,"Figure 3.2: Class hierarchy for Scala
  Set
 s. 
 For example, the Scala API contains a base
  trait
  for
  Set
 s, where a 
 trait is similar to a Java interface. (You’ll find out more about traits in 
 Step 12.) Scala then provides two subtraits, one for mutable
  Set
 s and 
 another for im-mutable
  Set
 s. As you can see in
  Figure 3.2
 , these three 
 traits all share the same simple name,
  Set
 . Their fully qualified names 
 differ, however, because each resides in a different package. Concrete
  
 Set
  classes in the Scala API, such as the
  HashSet
  classes shown in
  Figure 
 3.2
 , extend either the mutable or immutable
  Set
  trait. (Although in Java 
 you “implement” interfaces, in Scala you “extend” traits.) Thus, if you 
 want to use a
  HashSet
 , you can choose between mutable and immutable 
 varieties depending upon your needs. 
 To try out Scala
  Set
 s, type the following code into file
  jetset.scala
 : 
 import scala.collection.mutable.HashSet",NA
Map,"«trait»
  
 scala.collection.immutable",NA
Map,scala.collection.mutable,NA
Map,"«trait»
  
 «trait»
  
 scala.collection.immutable",NA
HashMap,scala.collection.mutable,NA
HashMap,"Figure 3.3: Class hierarchy for Scala
  Map
 s. 
 import scala.collection.mutable.HashMap
  
 val treasureMap = new HashMap[Int, String]
  
 treasureMap += (1 -> ""Go to island."")
  
 treasureMap += (2 -> ""Find big X on ground."")
  
 treasureMap += (3 -> ""Dig."")
  
 println(treasureMap(2))
  
 On the first line of
  treasure.scala
 , you import the mutable form of 
 HashMap
 . After a blank line, you define a
  val
  named
  treasureMap
  and 
 initialize it with a new mutable
  HashMap
  whose keys will be
  Int
 s and 
 values 
 String
 s. On the next three lines you add key/value pairs to the
  
 HashMap
  us-ing the
  ->
  method. As illustrated in previous examples, the 
 Scala compiler",NA
Step 11. Understand classes and singleton objects,"Up to this point you’ve written Scala scripts to try out the concepts 
 presented in this chapter. For all but the simplest projects, however, 
 you will likely want to partition your application code into classes. To 
 give this a try, type the following code into a file called
  greetSimply.scala
 : 
 class SimpleGreeter {
  
 val greeting = ""Hello, world!""
  
 def greet() = println(greeting)
  
 }
  
 val g = new SimpleGreeter
  
 g.greet()
  
 greetSimply.scala
  is actually a Scala script, but one that contains a 
 class definition. This first example, however, illustrates that as in Java, 
 classes in Scala encapsulate fields and methods. Fields are defined 
 with either
  val
  or
  var
 . Methods are defined with
  def
 . For example, in 
 class 
 SimpleGreeter
 ,
  greeting
  is a field and
  greet
  is a method. To use the 
 class, you initialize a
  val
  named
  g
  with a new instance of
  SimpleGreeter
 . 
 You then invoke the
  greet
  instance method on
  g
 . If you run this script 
 with
  scala greetSimply.scala
 , you will be dazzled with yet another 
 Hello, 
 world!
 . 
 Although classes in Scala are in many ways similar to Java, in 
 several ways they are quite different. One difference between Java and 
 Scala in-volves constructors. In Java, classes have constructors, which 
 can take pa-rameters, whereas in Scala, classes can take parameters 
 directly. The Scala notation is more concise—class parameters can be 
 used directly in the body of the class; there’s no need to define fields 
 and write assignments that copy constructor parameters into fields. 
 This can yield substantial savings in boil-erplate code, especially for 
 small classes. To see this in action, type the following code into a file 
 named
  greetFancily.scala
 :",NA
Step 12. Understand traits and mixins,"As first mentioned in Step 10, Scala includes a construct called a trait, 
 which is similar in spirit to Java’s interface. One main difference 
 between Java interfaces and Scala traits is that whereas all methods in 
 Java interfaces are by definition abstract, you can give methods real 
 bodies with real code in Scala traits. Here’s an example: 
 trait Friendly {
  
 def greet() = ""Hi""
  
 }
  
 In this example, the
  greet
  method returns the
  String ""Hi""
 . If you are 
 coming from Java, this
  greet
  method may look a little funny to you, as if
  
 greet()
  is somehow a field being initialized to the
  String
  value
  ""Hi""
 . What 
 is actually going on is that lacking an explicit
  return
  statement, Scala 
 methods will return the value of the last expression. In this case, the 
 value of the last expression is
  ""Hi""
 , so that is returned. A more verbose 
 way to say the same thing would be: 
 Prepared for jacques weiss
  
 trait Friendly { 
  
  
 def greet(): String = { 
  
   
 return ""Hi"" 
  
  
 } 
  
 }
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Conclusion,"Prepared for jacques weiss
  
 With the knowledge you’ve gained in this chapter, you should already 
 be able to get started using Scala for small tasks, especially scripts. In 
 future chapters, we will dive into more detail in these topics, and 
 introduce other topics that weren’t even hinted at here. 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Chapter 4,NA,NA
Classes and Objects,"As computer hardware has become cheaper and more capable, the 
 software that people want to run on it has become larger and more 
 complex. Managing this complexity is one of the main challenges of 
 modern programming. Two of the most important tools provided by 
 Scala to help programmers deal with complexity are classes and 
 objects. 
 When you are faced with writing a program with complex 
 requirements, you divide those requirements into smaller, simpler 
 pieces. You decompose your program into classes, each of which 
 encompasses an amount of com-plexity that you can handle. In other 
 words, a class should be responsible for an
  understandable
  amount of 
 functionality. In the process of designing your classes, you also design 
 interfaces to those classes that abstract away the details of their 
 implementation. Finally, you instantiate those classes into objects and 
 orchestrate the objects in ways that will solve the larger problem. The 
 way classes and objects help you manage complexity at this stage is 
 that as you orchestrate the objects, you can think primarily in terms of 
 their ab-stract interfaces, and for the most part forget about the more 
 complex details of their implementations. 
 In this chapter you will learn the basics of classes and objects in 
 Scala. If you are familiar with Java, you’ll find the concepts in Scala are 
 similar, but",NA
4.1,"Chapter 4 · Classes and Objects
  
 91",NA
Objects and variables,"When writing the code of a Scala program, you create and interact 
 with 
 objects
 . To interact with a particular object, you can use a
  variable
  
 that refers to the object. You can define a variable with either a
  val
  or
  
 var
 , and assign an object to it with
  =
 . For example, when you write: 
 val i = 1
  
 You create an
  Int
  object with the value
  1
  and assign it to a variable (in 
 this case, a
  val
 ) named
  i
 . Similarly, when you write: 
 var s = ""Happy""
  
 You create a
  String
  object with the value
  ""Happy""
  and assign it to a 
 variable (in this case, a
  var
 ) named
  s
 . 
 You must assign an object to a variable when you define one, a 
 process called
  initialization
 .
 1
 You might say, for example, that in the 
 previous two lines of code you initialized variable
  i
  with the
  Int 1
  and 
 variable
  s
  with the 
 String ""Happy""
 . Once an object has been assigned to a 
 variable, you can say that the variable
  refers
  to the object. For 
 example, after the assignments of the previous two lines of code, you 
 could say that the variable named
  i 
 refers to an
  Int
  with the value
  1
 , and 
 the variable named
  s
  refers to a
  String 
 with the value
  ""Happy""
 . 
 As mentioned in the previous chapters, the difference between the 
 two kinds of variable,
  val
  and
  var
 , is that a
  val
  will always refer to the 
 object with which it is initialized, whereas a
  var
  can be made to refer to 
 different objects over time. For example, even though the
  var
  named
  s
  
 from the previous example was initialized with the
  String ""Happy""
 , you 
 could later make
  s
  refer to a different
  String
 : 
 s = ""Programming""
  
 Prepared for jacques weiss
  
 1
 In Java, a variable that is a field of an object may be left unassigned, in which case 
 it is initialized with a predefined default value. The default value depends on the type 
 of the variable: it is
  0
  or
  0.0
  for numbers,
  false
  for booleans, and
  null
  for reference types. 
 In Scala, you always need an explicit initializer. However, you can achieve the same 
 default initialization effect for fields (but not local variables) by “initializing” with an 
 underscore“_”, as in
  var x: Int = _
 .
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
7,"Here’s how you can give it a second name tag: 
 var tomahto = tomato
  
 In this line of code, you defined another variable, a
  var
  named
  
 tomahto
 , and initialized it with the object to which
  tomato
  refers (the
  Int
  
 with the value
  7
 ). Both
  tomato
  and
  tomahto
  now refer to the same object, 
 thus you can think of this as a
  7
  with two name tags. 
 acques weiss
  
 tomato 
  
 tomahto",NA
7,"Prepared for j
  
 2
 Functions that are members of classes are called
  methods
  in Scala, as in Java.
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
7,tomahto,NA
8,"If you want to really shake things up, though, try this: 
 tomato = tomahto
  
 Now the
  8
  has two names, as you’d expect, but what about poor
  7
 ?",NA
7,tomato,NA
8,"tomahto
  
 Well, the old saying “nothing lasts forever” holds for objects in 
 Scala programs too. At this point in your program, that
  7
  has become
  
 unreach-able
 . No variable refers to it—it has no name tags—so there is 
 no way your program can interact with it anymore. Therefore any 
 memory it consumes has become available to be automatically 
 reclaimed by the runtime. Thus, for all practical purposes, the picture 
 in memory now looks like this: 
 Prepared for jacques weiss
  
 tomato 
  
 tomahto",NA
8,NA,NA
4.2,NA,NA
Mapping to Java,NA,NA
4.3 ,NA,NA
Classes and types,"The primary tool Scala gives you to organize your programs is the
  
 class
 . A class is a blueprint for objects. Once you define a class, you can 
 create objects from the class blueprint with the keyword
  new
 . For 
 example, given the class definition: 
 class House {
  
 // class definition goes here
  
 }
  
 You can create
  House
  objects (also called
  instances
  of class
  House
 ) with: 
 new House
  
 You may wish to assign the new
  House
  to a variable so you can interact 
 with it later: 
 val h1 = new House
  
 And just as a builder could construct many houses from one blueprint, 
 you can construct many objects from one class: 
 val h2 = new House
  
 val h3 = new House
  
 You now have three
  House
  objects. You have arrived! 
 When you define a class, you establish a new
  type
 . You can then 
 define variables of that type. For example, when you defined class
  
 House
  previ-ously, you established
  House
  as a type. You next create 
 three variables:
  h1
 ,",NA
4.4 ,NA,NA
Fields and methods,"Inside a class definition, you place fields and methods, which are 
 collectively called
  members
 . Fields are variables that refer to objects. 
 Methods contain executable code. The fields hold the state, or data, of 
 an object, whereas the methods use that data to do the computational 
 work of the object. When you instantiate a class, the runtime sets aside 
 some memory to hold the image of that object’s state—
 i.e.
 , the content 
 of its variables. For example, if you defined a
  ChecksumCalculator
  class 
 and gave it a
  var
  field named
  sum
 : 
 class ChecksumCalculator {
  
 var sum = 0
  
 }
  
 and you instantiated it twice with: 
 val cc = new ChecksumCalculator
  
 val dd = new ChecksumCalculator
  
 The image of the objects in memory might look like: 
 sum
  
 Prepared 
 for 
 jacques 
 weiss
  
 cc",NA
0,NA,NA
3,"dd
  
 sum",NA
0,"The first thing to notice about this picture is that there are two
  sum
  
 vari-ables, one inside the
  ChecksumCalculator
  object referred to by
  cc
  and 
 the other inside the
  ChecksumCalculator
  object referred to by
  dd
 . Fields 
 are also known as
  instance variables
 , because every instance gets its 
 own set of these variables. Collectively, an object’s instance variables 
 make up the memory image of the object. You can see this illustrated 
 here not only in that you see two
  sum
  variables, but also that when you 
 changed one, the other was unaffected. After you executed
  cc.sum = 3
 , 
 for example, the
  sum
  inside the 
 ChecksumCalculator
  referred to by
  dd
  
 remained at 0. Similarly, if you re-assigned the
  sum
  instance variable 
 inside the
  ChecksumCalculator
  object referred to by
  dd
 : 
 dd.sum = 4
  
 The state of the other
  ChecksumCalculator
  object would be unaffected: 
 Prepared for jacques weiss
  
 cc
  
 sum",NA
3,"dd
  
 sum",NA
4,"Another thing to note in this example is that you were able to 
 mutate the objects
  cc
  and
  dd
  referred to, even though both
  cc
  and
  dd
  are
  
 val
 s. What 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
4.5 ,NA,NA
Class documentation,"To make
  ChecksumCalculator
  usable as a library component, you should 
 document it. The recommended way of doing this is to use Scaladoc 
 com-ments. A Scaladoc comment is essentially the same as a Javadoc 
 comment in Java: a multi-line comment that starts with
  /**
 . The 
 comment always applies to the definition that comes right after it. 
  
 With the help of the 
 scaladoc
  tool you can produce HTML pages that contain the signatures of 
 classes and their members together with their Scaladoc comments. The 
 Eclipse IDE plugin also displays Scaladoc comments when it shows 
 defini-tions in its context help feature. Here is a well-commented 
 version of class 
 ChecksumCalculator
 : 
 /** A class that calculates a checksum of bytes. This class
  
 Pr
 ep
 are
 d 
 for 
 jac
 qu
 es 
 wei
 ss
  
 *
  
 is not thread-safe.",NA
4.6 ,NA,NA
Variable scope,"Variable declarations in Scala programs have a
  scope
  that defines 
 where you can use the name. Outside that scope, any use must be via 
 inheritance, an import, or a field selection such as
  cc.sum
 . 
  
 The most common example is that curly braces generally introduce 
 a new scope, so anything defined inside curly braces leaves scope after 
 the final closing brace.
 5 
  
  
 For an illustration, consider the following script: 
 def printMultiTable() {
  
 var i = 1
  
 // only i in scope here
  
 while (i <= 10) {
  
 var j = 1
  
 // both i and j in scope here
  
 while (j <= 10) {
  
 val prod = (i * j).toString 
  
 // i, j, and prod in scope here
  
 var k = prod.length
  
 // i, j, prod, and k in scope here
  
 while (k < 4) {
  
 print("" "")
  
 es weiss
  
 k += 1 
  
 }
  
 Prepared for 
 jacqu
  
 5
 There are a few exceptions to this rule, because in Scala you can sometimes use 
 curly braces in place of parentheses. One example of this kind of curly-brace use is the 
 alternative for expression syntax described in
  Section 7.3
  on
  page 156
 .
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
4.7 ,NA,NA
Semicolon inference,"In a Scala program, a semicolon at the end of a statement is usually 
 optional. You can type one if you want but you don’t have to if the 
 statement appears by itself on a single line. Thus, code like the 
 following does not need any semicolons: 
 val prod = 15
  
 var k = prod.toString.length
  
 while (k < 4) {
  
 print("" "")
  
 k += 1
  
 }
  
 print(prod)
  
 A semicolon is only required if you write several statements on a single line: 
 val prod = 15; var k = prod.toString.length
  
 Prepared for jacques weiss
  
 while (k < 4) { print("" ""); k += 1 }
  
 print(prod)
  
 If you want to enter a statement that spans multiple lines, most of the 
 time you can simply enter it and Scala will separate the statements in 
 the correct place. For example, the following is treated as one four-line 
 statement: 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
4.8,"Chapter 4 · Classes and Objects
  
 110",NA
Singleton objects,"As mentioned in
  Chapter 1
 , one way in which Scala is more object-
 oriented than Java is that classes in Scala cannot have static members. 
 Instead, Scala has
  singleton objects
 . A singleton object definition looks 
 like a class defi-nition, except instead of the keyword
  class
  you use the 
 keyword
  object
 . 
 Here’s an example: 
 // In file ChecksumCalculator.scala
  
 object ChecksumCalculator {
  
 def calcChecksum(s: String): Int = {
  
 val cc = new ChecksumCalculator
  
 for (c <- s)
  
 cc.add(c.toByte)
  
 cc.checksum
  
 }
  
 }
  
 This singleton object is named
  ChecksumCalculator
 , which is the same 
 name as the class in the previous example. When a singleton object 
 shares the same name with a class, it is called that class’s
  companion 
 object
 . You must define both the class and its companion object in the 
 same source file. The class is called the
  companion class
  of the 
 singleton object. A class and its companion object can access each 
 other’s private members. 
 The 
 ChecksumCalculator
  
 singleton object has one method, 
 calcChecksum
 , which takes a
  String
  and calculates a checksum for the 
 characters in the
  String
 . The first line of the method defines a
  val 
 named
  
 cc
  and initializes it with a new
  ChecksumCalculator
  instance. Because the 
 keyword
  new
  is only used to instantiate classes, the new object created 
 here is an instance of the
  ChecksumCalculator
  class. The next line is a for 
 expression, which cycles through each character in the passed 
 String
 , 
 converts the character to a
  Byte
  by invoking
  toByte
  on it, and",NA
4.9 ,NA,NA
A Scala application,"To run a Scala program, you must supply the name of a standalone 
 singleton object with a
  main
  method that takes one parameter, an
  
 Array[String]
 , and has a result type of
  Unit
 . Any singleton object with a
  
 main
  method of the proper signature can be used as the entry point 
 into an application. Here’s an example: 
 // In file Summer.scala
  
 import ChecksumCalculator.calcChecksum
  
 object Summer {
  
 Prepared for 
 jacques weiss
  
 }
  
 def main(args: Array[String]) {
  
 for (arg <- args)
  
 println(arg + "": "" + calcChecksum(arg))
  
 }",NA
4.10 ,NA,NA
Conclusion,"This chapter has given you the basics of classes and objects in Scala. In 
 the next chapter, you’ll learn about Scala’s basic types and how to use 
 them.",NA
Chapter 5,NA,NA
Basic Types and Operations,"Now that you’ve taken a tour of Scala and seen how basic classes and 
 objects work, a good place to start understanding Scala in more depth 
 is by looking at its basic types and operations. If you’re familiar with 
 Java, you’ll be glad to find that Java’s basic types and operators have 
 the same meaning in Scala. However there are some interesting 
 differences that will make this chapter worthwhile reading even if 
 you’re an experienced Java developer. 
 As object-oriented languages go, Scala is quite “pure” in the sense 
 that every value in a Scala program is an object, and every operation 
 on an object is a method call. This characteristic holds true even for 
 the basic types such as integers and floating point numbers, and 
 operations such as addition and multiplication. As mentioned in 
 earlier chapters, this object-oriented purity gives rise to a conceptual 
 simplicity that makes it easier to learn Scala and understand Scala 
 programs. However, unlike attempts at purity in some other object-
 oriented languages,
 1
 it does not come with a significant performance 
 cost, because the Scala compiler takes advantage of the efficiency of 
 Java’s primitive types and their operations when it compiles your 
 Scala program down to Java bytecodes. 
 Given that all operations on objects in Scala are method calls, Scala 
 doesn’t have operators in the same sense as in most languages. 
 Instead, each 
 cques weiss
  
 of the value types (such as
  Int
 ,
  Boolean
 , and
  Double
 ,
  etc.
 ) have methods 
 with names that act as operators in many other languages. For 
 example, in Java,
  *
  is an operator that you can use to multiply two
  int
 s. 
 In Scala, by",NA
5.1 ,NA,NA
Some basic types,"Several fundamental types of Scala, along with the ranges of values 
 instances may have, are shown in
  Table 5.1
 . 
 Table 5.1: Some Basic Types 
 jacques weiss
  
 Value Type Range 
 Byte
  
 8-bit signed two’s complement integer (-2
 7
 to 2
 7
 - 1, inclusive) 
 Short
  
 16-bit signed two’s complement integer (-2
 15
 to 2
 15
 - 1, inclusive) 
 Int
  
 32-bit signed two’s complement integer (-2
 31
 to 2
 31
 - 1, inclusive) 
 Long
  
 64-bit signed two’s complement integer (-2
 63
 to 2
 63
 - 1, inclusive) 
 Char
  
 16-bit unsigned Unicode character (0 to 2
 16
 - 1, inclusive) 
 String
  
 a sequence of
  Char
 s 
 Float
  
 32-bit IEEE 754 single-precision float 
 Double
  
 64-bit IEEE 754 double-precision float 
 Boolean
  
 true
  or
  false
  
 Other than
  String
 , which resides in package
  java.lang
 , all of these 
 basic types are members of package
  scala
 .
 2
 For example, the full name 
 of 
 Int
  is
  scala.Int
 . However, given that all the members of package
  scala 
 and
  java.lang
  are automatically imported into every Scala source file, 
 you",NA
5.2 ,NA,NA
Literals,"All of the basic types listed in
  Table 5.1
  can be written with
  literals
 . A 
 literal is a way to write a constant value directly in code. The syntax of 
 these literals is exactly the same as in Java, so if you’re a Java master, 
 you may wish to skim most of this section. The one difference to note 
 is Scala’s multi-line 
 String
  literal, which is described on
  page 120
 . 
 Integer literals
  
 Integer literals for the types
  Int
 ,
  Long
 ,
  Short
 , and
  Byte
  come in three 
 forms: decimal, hexadecimal, and octal. The way an integer literal 
 begins indicates the base of the number. If the number begins with a
  0x
  
 or
  0X
 , it is hexadecimal (base 16), and may contain upper or lowercase 
 digits
  A
  through 
 F
  as well as
  0
  through
  9
 . Some examples are: 
 scala> val hex = 0x5
  
 hex: Int = 5
  
 scala> val hex2 = 0x00FF
  
 hex2: Int = 255
  
 scala> val magic = 0xcafebabe
  
 magic: Int = -889275714
  
 3
 You can in fact currently use lower case aliases for Scala value types, which 
 correspond to Java’s primitive types. For example, you can say
  int
  instead of
  Int
  in a 
 Scala program.",NA
5.3 ,NA,NA
Operators are methods,"Like most programming languages, Scala facilitates basic operations 
 on its basic types, such as adding and subtracting numeric values and 
 and-ing and or-ing boolean values. If you’re familiar with Java, you’ll 
 find that the se- 
 r jacques weiss
  
 mantics of such expressions in Scala look the same as corresponding 
 expres-sions in Java, even though they are arrived at in Scala in a 
 slightly more object-oriented way.",NA
5.4 ,NA,NA
Arithmetic operations,"You can invoke arithmetic methods via infix operator notation for 
 addition (
 +
 ), subtraction (
 -
 ), multiplication (
 *
 ), division (
 /
 ), and 
 remainder (%), on any integer or floating point type. Here are some 
 examples: 
 scala> 1.2 + 2.3
  
 res6: Double = 3.5
  
 scala> 3 - 1
  
 res7: Int = 2
  
 scala> 'b' - 'a'
  
 res8: Int = 1
  
 scala> 2L * 3L 
  
 res9: Long = 6
  
 scala> 11 / 4
  
 res10: Int = 2
  
 scala> 11
  %
  4
  
 res11: Int = 3
  
 scala> 11.0f / 4.0f
  
 res12: Float = 2.75
  
 scala> 11.0
  %
  4.0
  
 Prepared for jacques weiss
  
 res13: Double = 3.0
  
 When both the left and right operands are integer types (
 Int
 ,
  Long
 ,
  
 Byte
 , 
 Short
 , or
  Char
 ), the
  /
  operator will tell you the whole number 
 portion of the quotient, excluding any remainder. The % operator 
 indicates the remainder of an implied integer division. 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
5.5 ,NA,NA
Relational and logical operations,"You can compare two value types with the relational methods greater 
 than (
 >
 ), less than (
 <
 ), greater than or equal to (
 >=
 ), and less than or 
 equal to (
 <=
 ), which like the equality operators, yield a
  Boolean
  result. 
 In addition, you can use the unary
  !
  operator (the
  unary_!
  method) to 
 invert a
  Boolean 
 value. Here are a few examples:",NA
5.6 ,NA,NA
Object equality,"If you want to compare two objects to see if they are equal, you should 
 usually use either
  ==
 , or its inverse
  !=
 . Here are a few simple examples: 
 scala> 1 == 2
  
 res24: Boolean = false
  
 scala> 1 != 2
  
 res25: Boolean = true
  
 scala> 2 == 2
  
 res26: Boolean = true
  
 Prepared for jacques weiss
  
 These operations actually apply to all objects, not just basic types. For 
 ex-ample, you can use it to compare lists: 
 scala> List(1,2,3) == List(1,2,3)
  
 res27: Boolean = true
  
 scala> List(1,2,3) == List(4,5,6)
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
5.7,"Chapter 5 · Basic Types and Operations
  
 130",NA
Bitwise operations,"Scala enables you to perform operations on individual bits of integer 
 types with several bitwise methods. The bitwise methods are: bitwise-
 and (
 &
 ), bitwise-or (
 |
 ), and (or bitwise-xor) (
 ˆ
 ).
 9
 The unary bitwise 
 complement operator,
  ∼
  (the method
  unary_
 ∼
 ), inverts each bit in its 
 operand. For ex-ample: 
 scala> 1 & 2
  
 res34: Int = 0
  
 scala> 1 | 2
  
 res35: Int = 3
  
 scala> 1 ˆ 3
  
 res36: Int = 2
  
 scala>
  ∼
 1 
  
 res37: Int = -2
  
  
 The first expression,
  1 & 2
 , bitwise-ands each bit in 1 (0001) and 2 
 (0010), which yields 0 (0000).  The second expression,
  1 | 2
 , bitwise-
 ors each bit in the same operands, yielding 3 (0011). The third expres-
 sion,
  1 ˆ 3
 , bitwise-xors each bit in 1 (0001) and 3 (0011), yielding 2 
 (0010). The final expression,
  ∼
 1
 , inverts each bit in 1 (0001), yielding -
 2 (111111111111111111111111111110). 
 Scala integer types also offer three shift methods: shift left (
 <<
 ), 
 shift right (
 >>
 ), and unsigned shift right (
 >>>
 ). The shift methods, when 
 used in infix operator notation, shift the integer value on the left of the 
 operator by the amount specified by the integer value on the right. 
 Shift left and unsigned shift right fill with zeroes as they shift. Shift 
 right fills with the highest bit (the sign bit) of the left hand value as it 
 shifts. Here are some examples: 
 scala> -1 >> 31
  
 acques weiss
  
 res38: Int = -1 
  
 scala> -1 >>> 31 
  
 res39: Int = 1",NA
5.8 ,NA,NA
Operator precedence and associativity,"Operator precedence determines which parts of an expression are 
 evaluated before the other parts. For example, the expression
  2 + 2 * 7
  
 evaluates to 16, not 28, because the * operator has a higher 
 precedence than the + operator. Thus the 2 * 7 part of the expression 
 is evaluated before the 2 + 2 part. You can of course use parentheses in 
 expressions to clarify evaluation order or to override precedence. For 
 example, if you really wanted the result of the expression above to be 
 28, you could write the expression like this: 
 (2 + 2) * 7
  
 Given that Scala doesn’t have operators, per se, just a way to use 
 methods in operator notation, you may be wondering how operator 
 precedence works. Scala decides precedence based on the first 
 character of the methods used in 
 ques weiss
  
 operator notation. If the method name starts with a
  *
 , for example, it 
 will have a higher precedence than a method that starts with a
  +
 . Thus
  
 2 + 2 * 7 
 will be evaulated as
  2 + (2 * 7)
 , and
  a +++ b *** c
  (in which
  a
 ,
  b
 , and",NA
5.9 ,NA,NA
Rich wrappers,"You can invoke many more methods on Scala’s basic types than were 
 de-scribed in the previous sections. A few examples are shown in
  
 Table 5.4
 . These methods are available via
  implicit conversions
 , a 
 technique that will 
 cques weiss
  
 be described in detail in
  Chapter 19
 . All you need to know for now is 
 that for each basic type described in this chapter, there is also a “rich 
 wrapper”that provides several additional methods. So, to see all the 
 available methods",NA
5.10,NA,NA
Conclusion,"The main take-aways from this chapter are that operators in Scala are 
 method calls, that implicit conversions to rich variants exist for Scala’s 
 basic types that add even more useful methods. In the next chapter, 
 we’ll show you what 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Chapter 6,NA,NA
Functional Objects,"A common thing said about OO is that an object “encapsulates state, 
 behav-ior and identity”. In
  Chapter 4
  you have seen a class
  
 ChecksumCalculator 
 where the state was encapsulated in a variable. 
 However, there are many useful classes that do not encapsulate 
 mutable state, because they describe something that is immutable. 
 Cases of immutable objects are already found in Java: Take
  
 java.lang.String
  or
  java.lang.Integer
 , for example. As a functional language, 
 Scala puts great emphasis on such immutable ob-jects. In this chapter, 
 we present as a case study the design of a class for 
 Rational
  numbers, 
 which are immutable objects. On the way, you’ll learn more aspects of 
 object-oriented programming in Scala: class parameters and 
 constructors, methods and operators, private members, overloading, 
 and self references. 
 Prepa
 red for 
 jacque
 s weiss",NA
6.1,NA,NA
A class for rational numbers,NA,NA
6.2,"Chapter 6 · Functional Objects
  
 138",NA
Choosing between,val,NA
 and,"var
  
 Class
  Rational
  contains two fields,
  numer
  and
  denom
 , which are both de-
 fined as
  val
 s. This means that the fields are immutable; they won’t 
 change after their initial assignment. You could have also defined the 
 fields as
  var
 s. This would have led to
  Rational
  number objects that can 
 change their value over their lifetime. However, from a mathematical 
 standpoint, this makes lit-tle sense: A rational number is defined by its 
 value, so if you can change the value, you have a variable containing a 
 rational number, not a rational number itself. 
 If you’re coming from an imperative background, such as Java, C++, 
 or C#, you may think of
  var
  as a regular variable and
  val
  as a special 
 kind of variable. From the Java perspective, for example, a
  val
  is like a
  
 final 
 variable. On the other hand, if you’re coming from a functional 
 background, such as Haskell, OCaml, or Erlang, you might think of
  val
  
 as a regular vari-able and
  var
  as akin to blasphemy. The Scala 
 perspective, however, is that 
 val
  and
  var
  are just two different tools in 
 your 
 toolbox, 
 both 
 useful, 
 neither 
 inherently 
 evil. 
 The
  
 ChecksumCalculator
  of
  Chapter 4
  clearly required a mutable field, 
 whereas the
  Rational
  class in this chapter equally clearly should be 
 immutable. Scala encourages you to reach, without guilt, for the best 
 tool for the job at hand. Nevertheless, even if you agree with this bal-
 anced philosophy, you might be wondering how to apply
  val
  and
  var
  
 most effectively. 
 If you’re coming from an imperative background, you may find 
 yourself using
  var
 s everywhere when you start programming in Scala. 
 This is ac-tually a scientifically recognized disease known as
  varmonia
 . 
 Don’t worry. There’s a cure, which is simply this: challenge
  var
 s in your 
 code, and where possible and appropriate, try and change them into
  
 val
 s. The reason we recommend you prefer
  val
 s over
  var
 s is that 
 reassignable values are harder to reason about. An immutable object 
 is just itself, whereas an object with mutable fields changes its value 
 over time. You then need to worry whether the changes and 
 observations of an object are all done in the right order. This",NA
6.3,"Chapter 6 · Functional Objects
  
 139",NA
Class parameters and constructors,"Classes in Scala can take parameters. For instance, class
  Rational
  takes 
 two parameters
  n
  and
  d
  which represent the numerator and 
 denominator of the fraction. Assuming you have saved the definition 
 of class
  Rational
  above in a file
  Rational.scala
 , you can create Rational 
 numbers as follows: 
 scala> :load Rational.scala
  
 Loading Rational.scala...
  
 defined class Rational
  
 scala> new Rational(1,2)
  
 res0: Rational = Rational@11af7bb
  
 One difference between Java and Scala concerns constructors. In Scala, 
 classes can take parameters directly, whereas in Java, classes have 
 construc-tors, which can take parameters. The Scala notation is more 
 concise – class parameters can be used directly in the body of the 
 class; there’s no need to define fields and write assignments which 
 copy constructor parameters into fields. This can yield substantial 
 savings in boilerplate code; especially for small classes. 
 In fact, “under the covers”, a Scala class does have a constructor, 
 even though it is not directly visible to user programs. This 
 constructor is called the
  primary constructor
  of the class. It takes the 
 class parameters and exe-cutes all statements of the class body. You 
 can verify this by adding a print statement right into the body of
  
 Rational
 : 
 class Rational(n: Int, d: Int) {
  
 println(""created: ""+n+""/""+d)
  
 ... // rest of class is as before
  
 }
  
 If you re-load the changed class into the interpreter, you will get 
 something like the following:",NA
6.4 ,NA,NA
Multiple constructors,"Sometimes one wants multiple constructors in a class. Scala supports 
 this as well, through auxiliary constructors. An example of a auxiliary 
 constructor is found in the following version of
  Rational
 : 
 class Rational(n: Int, d: Int) {
  
 def this(n: Int) = this(n, 1)
  
 println(""created: ""+n+""/""+d)
  
 // rest of class is as before
  
 }
  
 Secondary constructors in Scala start with
  def this(...)
 ; In the code above, 
 an auxiliary constructor is used to create an instance of
  Rational 
 with a 
 default value of 1 for the denominator. It does this by calling the pri-
 mary constructor with the given parameter
  n
  and
  1
  as arguments. 
 Now, if you feed the following to the
  scala
  shell: 
 Prepared for jacques weiss
  
 scala> val y = new Rational(3) 
  
 you should see:  
 created: 3/1 
  
 y: Rational = Rational@de1520 
  
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  
 Index",NA
6.5 ,NA,NA
Reimplementing the,toString,NA
 method,"The current version of Rational does not display in a nice way. It’s time 
 to do something about this. When the interpreter prints out the value 
 of a rational number, it invokes the number’s
  toString
  method. This 
 method has a de-fault implementation in Scala’s (and Java’s) root class
  
 Object
 , where it just prints the class name and a hexadecimal number. 
 This default implementa-tion can be overridden by adding a method
  
 toString
  to class
  Rational
 : 
 override def toString() = numer+""/""+denom
  
 The
  override
  modifier in front of a method definition signals that a 
 previous method definition is overridden; more on this in
  Chapter 10
 . 
 You can test the new behavior of Rationals in the interpreter (since 
 now numbers display correctly, you can remove the
  println
  statement 
 from the body of class
  Rational
 ): 
 scala> val x = new Rational(1, 3)
  
 x: Rational = 1/3
  
 scala> val y = new Rational(5, 7)
  
 y: Rational = 5/7
  
 scala> val z = new Rational(3, 2)
  
 z: Rational = 3/2
  
 cques weiss
  
 scala> x.add(y).mul(z) 
  
 res7: Rational = 66/42",NA
6.6,"Chapter 6 · Functional Objects
  
 142",NA
Private methods and fields,"So far so good. But there is still something amiss: The numerator and 
 de-nominator of a rational are unnecessarily large – it prints
  66/42
  
 instead of 
 11/7
 . It would be better to normalize the number by dividing 
 both numera-tor and denominator with any common divisors they 
 might have. You could do this normalization in every arithmetic 
 operation, but that would lead to a lot of repetition. A more elegant 
 technique is to normalize when a rational number is created. Here’s 
 how this is done: 
 class Rational(n: Int, d: Int) {
  
 private def gcd(a: Int, b: Int): Int =
  
 if (b == 0) a else gcd(b, a
  %
  b)
  
 private val g = gcd(n, d)
  
 val numer: Int = n / g
  
 val denom: Int = d / g
  
 // rest of class as before
  
 }
  
 The new version of
  Rational
  has a private method
  gcd
  and a private field 
 g
 . As in Java, a
  private
  method can be accessed only from inside the class 
 in which it is defined. There’s also
  protected
 , which restricts access to a 
 member to the class in which it is defined and all its subclasses.
  Chap-
 ter 13
  contains more material on
  private
  and
  protected
 , and other ways 
 to control member visibility. 
 The
  gcd
  method computes the greatest common divisor of two 
 numbers. For instance
  gcd(12, 8)
  is
  4
 . The
  g
  field takes the result of 
 computing the
  gcd
  of the two class parameters. The
  numer
  and
  denom
  
 fields then are initialized to the corresponding class parameters 
 divided by
  g
 . 
  
 You can test the correct behavior of
  Rational
  by creating a non-
 normalized rational number. If you type 
 scala> val x = new Rational(12, 8)",NA
6.7,"Chapter 6 · Functional Objects
  
 143",NA
Self references,"Just like in Java, the reserved word
  this
  refers to the currently 
 executing object. As an example, consider adding a method,
  lessThan
 , 
 which tests whether the given rational is smaller than a parameter: 
 def lessThan(that: Rational) =
  
 this.numer * that.denom < that.numer * this.denom
  
 Here,
  this.numer
  refers to the numerator of the object in which the 
 lessThan
  method is executed. You can also leave off the
  this
 -prefix and 
 write just
  numer
 ; the two notations are equivalent. 
 As an example where you can’t do without
  this
 , consider adding a
  
 max 
 method to class
  Rational
  that returns the greater of the given 
 rational num-ber and an argument: 
 def max(that: Rational) =
  
 if (this.lessThan(that)) that else this
  
 Here, the first
  this
  is redundant, you could have equally well written 
 (lessThan(that))
 .  
 But the second
  this
  represents the result of the 
 method in the case where the test returns false; if you omit it, there 
 would be nothing left to return!",NA
6.8 ,NA,NA
Defining operators,"The current implementation of
  Rational
 s is OK as it stands, but it could 
 be made more convenient to use. You might ask yourself why you can 
 write 
 x * y + z
  
 if
  x
 ,
  y
 , and
  z
  are integers or floating point numbers, but you have to write 
 x.mul(y).add(z)",NA
6.9 ,NA,NA
Identifiers in Scala,"You have now seen the two most important ways to form an identifier 
 in Scala: alphanumeric and operator. Scala has very flexible rules for 
 forming identifiers. Besides the two forms you have seen there are 
 also two others. All four forms of identifier formation are described 
 below. 
 An
  alphanumeric identifier
  starts with a letter or an underscore 
 character, which can be followed by further letters, digits, or 
 underscore characters. So examples of alphanumeric identifiers are: 
 bob
  
 x1
  
 _out_
  
 MAX_DECIMAL_NUMBER
  
 CamelCase
  
 The ‘$’-character also counts as a letter, however it is reserved for 
 identifiers generated by the Scala compiler. Identifiers in user 
 programs should not contain ‘$’ character, even though it will compile; 
 if they do this might lead to name clashes with identifiers generated by 
 the Scala compiler. 
 An
  operator identifier
  consists of one or more operator characters. 
 Oper-ator characters are printable ASCII characters such as
  +
 ,
  :
 ,
  ?
 ,
  ∼
  or
  
 #
 . More precisely, an operator character belongs to the Unicode set of 
 mathematical symbols(Sm) or other symbols(So), or to the 7 Bit ASCII 
 characters that are not letters, digits, or one of the characters 
 Prepared for 
 jacques weiss
  
 _ ( ) [ ] { } . ; , "" ' ‘
  
 Examples of operator identifiers 
 are:",NA
6.10,"Chapter 6 · Functional Objects
  
 147",NA
Method overloading,"Back to class
  Rational
 . With the latest changes, you can now do 
 arithmetic operations in the natural style on rational numbers. But 
 one thing still miss-ing is mixed arithmetic. For instance, you cannot 
 multiply a rational number by an integer because the operands of ‘
 *
 ’ 
 always have to be rationals. So for a rational number
  r
  you can’t write
  r 
 * 2
 , it must be
  r * new Rational(2)
 , which is less nice. 
  
 To make
  Rational
  even more convenient, you can add new methods 
 to the class that perform mixed arithmetic on rationals and integers: 
 class Rational {
  
 ... // as before
  
 def +(that: Int): Rational = this + new Rational(that)
  
 def -(that: Int): Rational = this - new Rational(that)
  
 def *(that: Int): Rational = this * new Rational(that) def /(that: Int): Rational = 
 this / new Rational(that)
  
 }
  
 There are now two versions of each arithmetic operator method: one 
 that takes a rational as argument, the other which takes an integer. In 
 other words, the methods are
  overloaded
 . In a method call, the correct 
 version of an over-loaded method is picked based on the types of the 
 arguments. For instance, if the argument
  y
  in
  x.*(y)
  is a
  Rational
 , the 
 method
  *
  which takes a 
 Rational
  parameter is picked. But if the 
 argument is an integer, the method 
 *
 which takes a
  Int
  parameter is 
 picked instead. You can try this out in the interpreter: 
 scala> val x = new Rational(2, 3)
  
 x: Rational = 2/3
  
 scala> val y = x * x 
  
 y: Rational = 4/9
  
 Prepared for jacques weiss
  
 scala> val z = y * 2 
  
 z: Rational = 8/9
  
 The process of overloading resolution is very similar to what Java does. 
 In every case, the chosen overloaded version is the one which best 
 matches the 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
6.11 ,NA,NA
Going further,"There’s still room for improvement: Now that you can write
  r * 2
 , you 
 might also want to swap the operands, as in
  2 * r
 . Unfortunately this 
 does not work yet: 
 scala> 2 * r 
  
 <console>:5: error: overloaded method value * with alternatives (Double)Double <and> 
 (Float)Float <and> (Long)Long <and> (Int)Int
  
 <and> (Char)Int <and> (Short)Int <and> (Byte)Int cannot be
  
 Prepared for jacques weiss
  
 applied to (Rational) 
  
  
 val res2 = 2 * r
  
   
 ˆ
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
6.12 ,NA,NA
A word of caution,"As this chapter has demonstrated, creating methods with operator 
 names and defining implicit conversions can help you design libraries 
 for which client code is concise and easy to understand. This is even 
 easier to see in
  Section 1.1
  on
  page 29
 , where you can compare client 
 code for Java’s 
 BigInteger
  with code for Scala’s
  BigInt
 . Scala gives you a 
 great deal of",NA
6.13 ,NA,NA
Conclusion,"In this section, you have seen more elements of classes in Scala. You 
 have seen how to add parameters to a class, how to define several 
 constructors, how to define operators as methods, and how to 
 customize classes so that they are natural to use. Maybe most 
 importantly, you should have taken away from the treatment in this 
 chapter that objects without any mutable state manifested in
  var
 s are 
 quite a natural way to code things in Scala.",NA
Chapter 7,NA,NA
Built-in Control Structures,"There are not many control structures built into Scala. The only 
 control structures are
  if
 ,
  while
 ,
  for
 ,
  try
 ,
  match
 , and function calls. The 
 reason Scala has so few is that it has included function literals since its 
 inception. Instead of accumulating one higher-level control structure 
 after another in the base syntax, Scala accumulates them in libraries. 
 The next chapter will show precisely how that is done. This one will 
 show those few control structures that are built in. 
 One thing you will notice is that almost all of Scala’s control 
 structures result in some value. This is the approach taken by 
 functional languages, in which programs are viewed as computing a 
 value, thus the components of a program should also compute values. 
 You can also view this approach as the logical conclusion of a trend 
 already present in imperative languages. In im-perative languages, 
 function calls can return a value, even though having the called 
 function update an output variable passed as an argument would work 
 just as well. In addition, imperative languages often have a ternary 
 operator (such as the
  ?:
  operator of C, C++, and Java), which behaves 
 exactly like 
 if
 , but results in a value. Scala adopts this ternary operator 
 model, but calls it
  if
 . In other words, Scala’s
  if
  can result in a value. 
 Scala then continues this trend by having
  for
 ,
  try
 , and
  match
  also result 
 in values.",NA
7.1 ,NA,NA
If expressions,"Scala’s
  if
  works just like in many other languages. It tests a condition 
 and then executes one of two code branches depending on whether 
 the condition holds true. Here is a common example, written in an 
 imperative style: 
 var filename = ""default.txt""
  
 if (!args.isEmpty)
  
 filename = args(0)
  
 This code declares a variable,
  filename
 , and initializes it to a default 
 value. It then uses an
  if
  expression to check whether any arguments 
 were supplied to the program. If so, it changes the variable to hold the 
 value specified in the arguments list. If there are no arguments, it 
 leaves the variable set to the default. 
 This code can be written more nicely, because Scala’s
  if
  is an 
 expres-sion that returns a value. Here is the same example that uses 
 an
  if-else 
 expression and is written in a more functional style: 
 val filename =
  
 if (!args.isEmpty)
  
 args(0)
  
 else
  
 ""default.txt""
  
 This time, the
  if
  has two branches. If
  args
  is not empty, the initial element,",NA
7.2 ,NA,NA
While loops,"Scala’s
  while
  loop behaves just like in other languages such as Java. The 
 loop has a condition and a body, and the body is executed over and 
 over as long as the condition holds true. Here’s an example of a while 
 loop used in a function that takes an imperative approach to compute 
 the greatest common denominator of two
  Long
 s: 
 def gcdLoop(x: Long, y: Long): Long = {
  
 var a = x
  
 var b = y
  
 while (a != 0) {
  
 val temp = a
  
 a = b
  %
  a
  
 b = temp
  
 }
  
 b
  
 }
  
 Scala also has a
  do-while
  loop. This is a variant of the
  while
  loop that 
 simply tests the condition after the loop body instead of before. Here’s 
 an example: 
 var line = """"
  
 do {
  
 line = readLine",NA
7.3,"Chapter 7 · Built-in Control Structures
  
 156",NA
For expressions,"Scala’s for expression is a Swiss army knife of enumeration. It lets you 
 com-bine a few simple ingredients in different ways to express a wide 
 variety of enumerations. Simple uses allow common enumerations 
 such as iterat-ing through a sequence of integers. More advanced 
 expressions can iterate over multiple collections of different kinds, can 
 filter out elements based on arbitrary conditions, and can produce 
 new collections. 
 Iteration through collections
  
 The simplest thing you can do with
  for
  is to iterate through all the 
 elements of an entire collection. For example, here is some code that 
 prints out all files in the current directory. 
 val filesHere = (new java.io.File(""."")).listFiles
  
 for (file <- filesHere)
  
 println(file)
  
 The list of files is computed using methods from the Java API. The code 
 cre-ates a
  File
  on the current directory, and then it calls the standard
  
 listFiles 
 method. 
 To print out all of the files, the for expression iterates through 
 them and calls
  println
  on each one. The
  file <- filesHere
  syntax creates a 
 new variable
  file
  and then causes that variable to be set to one element 
 of
  filesHere
  at a time. For each setting of the variable, the body of the for 
 expression,
  println(file)
 , is executed. 
 This syntax works for any kind of collection, not just arrays.
 1
 One 
 con-venient special case is the
  Range
  type, which you briefly saw in
  
 Table 5.4
  on 
 page 134
 . You can create
  Range
 s using syntax like “
 1 to 5
 ,” 
 and you can iterate through them with a
  for
 . Here is a simple example: 
 scala> for (i <- 1 to 5)
  
 acques weiss
  
 |
  
 println(""Iteration "" + i)
  
 Iteration 1 
  
 Iteration 2",NA
7.4 ,NA,NA
Try expressions,"Scala’s exceptions behave just like in many other languages. Instead of 
 re-turning a value in the normal way, a method can terminate by 
 throwing an exception. The method’s caller can either catch and 
 handle that exception, or it can itself simply terminate, in which case 
 the exception propagates to the caller’s caller. The exception 
 propagates in this way, unwinding the call stack, until a method 
 handles it or there are no more methods left. 
 Throwing exceptions
  
 Throwing an exception looks the same as in Java. You create an exception",NA
7.5 ,NA,NA
Match expressions,"The final build-in control structure you will want to know about is the
  
 match 
 expression. Match expressions let you select from a number of 
 alternatives, just like
  switch
  statements in other languages. In general a
  
 match
  expres-sion lets you select using arbitrary
  patterns
 , as described 
 in
  Chapter 12
 . The general form can wait. For now, just consider using
  
 match
  to select among a number of alternatives. 
  
 As an example, the following code reads a food name from the 
 argument list and prints a companion to that food. 
 val firstArg = if (args.length > 0) args(0) else """"",NA
7.6,"Chapter 7 · Built-in Control Structures
  
 166",NA
Living without,break,NA
 and,"continue
  
 You may have noticed that there has been no mention of
  break
  or
  
 continue
 . Scala leaves out these commands because they do not mesh 
 well with func-tion literals, a feature described in the next chapter. It is 
 clear what
  continue 
 means inside a
  while
  loop, but what would it mean 
 inside a function literal? While Scala supports both imperative and 
 functional styles of programming, in this case it leans slightly towards 
 functional programming in exchange for simplifying the language. 
 Do not worry, though. There are many ways to program without
  
 break 
 and
  continue
 , and if you take advantage of function literals, those 
 alterna-tives can often be shorter than the original code. 
 The simplest approach is to replace every
  continue
  by an
  if
  and ev-
 ery
  break
  by a boolean variable. The boolean variable indicates 
 whether the enclosing
  while
  loop should continue. For example, 
 suppose you are searching through an argument list for a string that 
 ends with “.scala” but does not start with a hyphen. That is, you are 
 looking for a Scala file but want to ignore any options. In Java you 
 could—if you were quite fond of while loops,
  break
 , and
  continue
 —write 
 the following: 
 // This is Java...
  
 int i = 0;
  
 boolean foundIt = false;
  
 while (i < args.length) {
  
 if (args[i].startsWith(""-"")) {
  
 i = i + 1;
  
 continue;
  
 }
  
 if (args[i].endsWith("".scala"")) {
  
 foundIt = true;
  
 break;
  
 }
  
 Prepared for jacques weiss
  
  
 i = i + 1; 
  
 }
  
 To transliterate this directly to Scala, instead of doing an
  if
  and then a 
 continue
 , you could write an
  if
  that surrounds the entire remainder of the 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
7.7 ,NA,NA
Conclusion,"Scala’s build-in control structures are minimal, but they do the job. 
 They act much like their imperative equivalents, but because they tend 
 to result in a value, they support a functional style too. Just as 
 important, they are careful in what they omit, thus leaving room for 
 one of Scala’s most powerful features, the function literal.",NA
Chapter 8,NA,NA
Functions and Closures,"When programs get larger, you need some way to divide them into 
 smaller, more manageable pieces. For dividing up control flow, Scala 
 offers an ap-proach familiar to all experienced programmers: divide 
 the code into func-tions. In fact, Scala offers several ways to define 
 functions that are not present in Java. Besides methods, which are 
 functions that are members of some template (class, trait, or singleton 
 object), there are also nested func-tions and function literals. 
 Functions can also be values. This chapter shows how to write and use 
 such functions in Scala.",NA
8.1 ,NA,NA
Methods,"The most common way to define a function is as a member of some 
 object. Such a function is called a
  method
 . As an example, here are two 
 methods that together read a file with a given name and print out all 
 lines whose length exceeds a given width. Every printed line is 
 prefixed with the name of the file it appears in: 
 import scala.io.Source
  
 object LongLines {
  
 def processFile(filename: String, width: Int) {",NA
8.2 ,NA,NA
Nested functions,"The construction of the
  processFile
  method in the previous section 
 demon-strated an important design principle of the functional 
 programming style: programs should be decomposed into many small 
 functions that each do a well-defined thing. Individual functions are 
 often quite small. The advan-tage of this style is that it gives a 
 programmer many building blocks that can be flexibly composed to do 
 more difficult things. Each building block should be simple enough to 
 be understood individually. However, a problem with the “many small 
 functions” approach is that all these helper function names have a 
 tendency to pollute the program name space. In the interpreter shell 
 this not so much of a problem. But once functions are packaged in 
 reusable classes and objects, its desirable to hide the helper functions 
 from clients of a class, because they might not make sense individually. 
 In Java, you would use a
  private
  method for this purpose. This private-
 method ap-proach works in Scala as well, but Scala offers an 
 alternative approach: you can define functions inside other functions. 
 Just like local variables, such nested functions are visible only in their 
 enclosing block. Here’s how you can use this scheme to clean-up the
  
 processFile
  functions: 
 def processFile(filename: String, width: Int) {
  
 def processLine(filename: String, width: Int, line: String) {
  
 if (line.length > width) print(filename+"": ""+line)
  
 }
  
 val source = Source.fromFile(filename)
  
 for (line <- source.getLines) {
  
 processLine(filename, width, line)
  
 }
  
 }
  
 Prepared 
 for 
 jacques 
 weiss
  
 Once you have moved the helper function 
 processLine
  
 inside 
 processFile
 , another improvement becomes possible. 
 Notice how",NA
8.3 ,NA,NA
First-class functions,"In addition to methods and nested functions, Scala also offers
  first-
 class func-tions
 . At runtime, first-class functions are represented by 
 objects called
  func-tion values
 . Like other values, function values can 
 be passed as parameters to other functions, returned as results, or 
 assigned to variables. In the source code, you can express first-class 
 functions in a shorthand form called
  func-tion literals
 . We introduced 
 function literals in
  Chapter 2
  and showed the basic syntax in
  Figure 
 2.2
  on
  page 61
 . 
 A function literal is compiled into a class that when instantiated at 
 run-time is a function value.
 1
 Thus the distinction between function 
 literals and values is that function literals exist in the source code, 
 whereas function val-ues exist as objects at runtime. You can use the 
 term “first-class function” 
 weiss
  
 to refer to either a function literal or value, as first-class function means the",NA
8.4,"Chapter 8 · Functions and Closures
  
 175",NA
Short forms of function literals,"Scala provides a number of ways to leave out redundant information 
 and write function literals more briefly. Keep your eyes open for these 
 opportu-nities, because they allow you to remove clutter from your 
 code. 
 One way to make a function literal more brief is to leave off the 
 parameter types. For example, the previous example with filter could 
 be written like this: 
 scala> someNumbers.filter((x) => x > 0)
  
 res7: List[Int] = List(5, 10)
  
 The Scala compiler knows that
  x
  must be an integer, because it sees 
 that you are immediately using the function to filter a list of integers 
 (referred to by 
 someNumbers
 ). This is called
  target typing
 . The precise 
 definition is not important, though. In practice, you can try writing a 
 function literal without the argument type, and if the compiler gets 
 confused, you can add the type. Over time you’ll get a feel for which 
 situations the compiler can and cannot puzzle out. 
 Another way to remove useless characters is to leave out 
 parentheses when they are not needed. You can leave out the 
 parentheses around a func-tion argument if the type is inferred: 
 scala> someNumbers.filter(x => x > 0)
  
 res8: List[Int] = List(5, 10)",NA
8.5 ,NA,NA
Placeholder syntax,"To make a function literal even more concise, you can use underscores 
 as placeholders for one or more parameters, so long as each 
 parameter appears only one time within the function literal. For 
 example,
  _ > 0
  is very short no-tation for a function that checks whether 
 a value is greater than zero. Here’s",NA
8.6,"Chapter 8 · Functions and Closures
  
 177",NA
Partially applied functions,"Although the previous examples substitute underscores in place of 
 individual parameters, you can also replace an entire parameter list 
 with an underscore. For example, instead of writing
  println(_)
 , you can 
 write
  println _
 . 
 Here’s an example: 
 someNumbers.foreach(println _)
  
 Scala treats this short form exactly as if you had written the following: 
 someNumbers.foreach(x => println(x))
  
 Thus, the underscore in this case is not a placeholder for a single 
 parameter. It is a placeholder for an entire parameter list. Remember 
 that you need to leave a space between the function name and the 
 underscore, because otherwise the compiler will think you are 
 referring to a different symbol, such as for example, a method named
  
 println_
 , which likely does not exist. 
 When you use an underscore in this way, you are expressing 
 what’s called a
  partially applied function
 . In Scala, when you invoke a 
 function, passing in any needed arguments, you
  apply
  that function
  to
  
 the arguments. 
 For example, given this function: 
 scala> def sum(a: Int, b: Int, c: Int) = a + b + c
  
 sum: (Int,Int,Int)Int
  
 You could apply the function
  sum
  to the arguments
  1
 ,
  2
 , and
  3
  like this: 
 scala> sum(1, 2, 3)
  
 res13: Int = 6
  
 A partially applied function is an expression in which you don’t supply 
 all of the arguments needed by the function. Instead, you supply some, 
 or none, of the needed arguments. For example, here’s a partially 
 applied function",NA
8.7 ,NA,NA
Closures,"So far in this chapter, all the examples of function literals that we’ve 
 given have referred only to passed parameters. For example, in
  (x: Int) 
 => x > 0
 , the only variable used in the function body,
  x > 0
 , is
  x
 , which is 
 defined as a parameter to the function. You can, however, refer to 
 variables defined elsewhere. Here’s an example: 
 (x: Int) => x + more 
  
 // how much more?
  
 This function adds “
 more
 ” to its argument, but what is
  more
 ? From the 
 point of view of this function,
  more
  is a
  free variable
 , because the 
 function literal does not itself give a meaning to it. The
  x
  variable, by 
 contrast, is a
  bound variable
 , because it does have a meaning in the 
 context of the function: it is defined as the function’s lone parameter, 
 an
  Int
 . 
  
 If you try using this function literal by itself, without any
  more
  
 defined in its scope, the compiler will complain: 
 scala> (x: Int) => x + more
  
 <console>:5: error: not found: value more",NA
8.8 ,NA,NA
Repeated parameters,"Scala allows you to indicate that the last parameter to a function may 
 be repeated. This allows clients to pass variable length argument lists 
 to the function. To denote a repeated parameter, place an asterisk 
 after the type of the parameter. For example: 
 scala> def echo(args: String*) = for (arg <- args) println(arg) 
 echo: (String*)Unit
  
 Defined this way,
  echo
  can be called with zero to many
  String
  arguments: 
 scala> echo()
  
 scala> echo(""one"") 
  
 one
  
 scala> echo(""hello"", ""world!"") 
  
 hello 
  
 world!
  
 scala> echo(""1"", ""2"", ""3"", ""4"") 
  
 1 
  
 2 
  
 3 
  
 4
  
 Prepared for jacques weiss
  
 Inside the function, the type of the repeated parameter is an
  Array
  
 of the declared type of the parameter. Thus, the type of
  args
  inside the
  
 echo 
 function, which is declared as type “
 String*
 ” is actually
  Array[String]
 . 
 Nevertheless, if you have an array of the appropriate type, and attempt 
 to pass it as a repeated parameter, you’ll get a compiler error: 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
8.9 ,NA,NA
Tail recursion,"In
  Section 7.2
  on
  page 154
 , we mentioned that to transform a while 
 loop that updates
  var
 s into a more functional style that uses only
  val
 s, 
 you may sometimes need to use recursion.
 6
 Here’s an example of a 
 recursive function that approximates a value by repeatedly improving 
 a guess until it is good enough: 
 def approximate(guess: Domain) : Domain = 
  
 if (isGoodEnough(guess)) guess 
  
 else approximate(improve(guess))
  
 A function like this is often used in search problems, with the 
 appropriate implementations for the type
  Domain
  and the
  isGoodEnough
  
 and
  improve
  
 es weiss
  
 functions. If you want the
  approximate
  function to run faster, you might 
 be tempted to write it with a while loop to try and speed it up, like this: 
 Prepared for jacqu
  
 6
 A recursive function is one that calls itself.
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
8.10 ,NA,NA
Conclusion,This chapter has shown you several new ways functions can be defined in,NA
Chapter 9,NA,NA
Control Abstraction,"All functions are separated into common parts, which are the same in 
 every invocation of the function, and non-common parts, which may 
 vary from one function invocation to the next. The common parts are 
 in the body of the function, while the non-common parts must be 
 supplied via arguments. When you use a function value as an 
 argument, the non-common part of the algorithm is itself some other 
 algorithm! At each invocation of such a function, you can pass in a 
 different function value as an argument, and the invoked function will, 
 at times of its choosing, invoke the passed func-tion value. These
  
 higher-order functions
 —functions that take functions as parameters—
 give you extra opportunities to condense and simplify code.",NA
9.1 ,NA,NA
Reducing code duplication,"One benefit of higher-order functions is they enable you to create 
 control abstractions that allow you to reduce code duplication. For 
 example, suppose you are writing a file browser, and you want to 
 provide an API that allows users to search for files matching some 
 criterion. First, you add a facility to search for files whose names end 
 in a particular string. This would enable your users to find, for 
 example, all files with a “
 .scala
 ” extension. You",NA
9.2 ,NA,NA
Simplifying client code,"In addition to helping you reduce code duplication as you implement 
 an API, as demonstrated in the previous example, you can provide 
 higher-order func-tions in an API itself to make client code more 
 concise. A good example of this is the special-purpose looping 
 methods provided by Scala’s collection types,
 1
 many of which are listed 
 in
  Table 3.1
  in
  Chapter 3
 . Scala provides while loops and for 
 expressions as built-in control structures that can help 
 es weiss
  
 you with all of your looping needs. The while loop supports an 
 imperative style, and the for expression a functional style, of looping 
 code.",NA
9.3 ,NA,NA
Currying,"In Chapter 1, we said that Scala allows you to create new control 
 abstrac-tions that “feel like native language support.” Although the 
 examples you’ve",NA
9.4 ,NA,NA
Writing new control structures,"In languages with first-class functions, you can effectively make new control 
 ues weiss
  
 structures even though the syntax of the language is fixed. All you need 
 to do is create methods that take functions as arguments.",NA
9.5 ,NA,NA
By-name parameters,"The
  withPrintWriter
  method shown in the previous section differs from 
 built-in control structures of the language, such as
  if
  and
  while
 , in that 
 the code between the curly braces takes an argument. The
  
 withPrintWriter 
 method requires one argument of type
  PrintWriter
 . This 
 argument shows up as the “
 writer =>
 ” in: 
 withPrintWriter(file) {
  
 writer => writer.println(new java.util.Date)
  
 }
  
 What if you want to implement something more like
  if
  or
  while
 , 
 however, where there is no value to pass into the code between the 
 curly braces of the control structure? To help with such situations, 
 Scala provides
  by-name parameters
 . 
 As a concrete example, suppose you want to implement an 
 assertion con-struct called
  myAssert
 .
 3
 The
  myAssert
  function will take a 
 function value as input and consult a flag to decide what to do. If the 
 flag is set,
  myAssert
  
 cques weiss
  
 will invoke the passed function and verify that it returns
  true
 . If the flag 
 is turned off,
  myAssert
  will quietly do nothing at all. 
 Without using by-name parameters, you could write
  myAssert
  like this:",NA
9.6,"Chapter 9 · Control Abstraction
  
 204",NA
Conclusion,"This chapter has shown you several new ways functions can be 
 defined in Scala. You can nest them inside each other and you can use 
 them as first-class values. You have also seen several lightweight 
 methods to define a function value without giving it a name. Such 
 function values are also called closures. They are very flexible building 
 blocks for creating your own control structures. You have seen two 
 syntactic tweaks that make operating on clo-sures more pleasant: 
 currying and call-by-name parameters. With the help of these, you can 
 write control structures that look as if they were built-in language 
 constructs.",NA
Chapter 10,NA,NA
Composition and Inheritance,"This chapter discusses more of Scala’s support for object-oriented 
 program-ming. The topics are not as fundamental as those in
  Chapter 
 4
 , but they will frequently arise as you program in Scala.",NA
10.1 ,NA,NA
Introduction,"As a running example, this chapter presents a simple library for 
 building and rendering two-dimensional layout elements. Each 
 element represents a rect-angle filled with text. Elements can be 
 composed above or beside each other. For instance, assume you are 
 given a method with the following signature which creates a layout 
 element containing a string: 
 elem(s: String): Element
  
 Then the expression below would construct a larger element 
 consisting of two columns, each with a height of two. 
 val column1 = elem(""hello"") above elem(""***"") val column2 = 
 elem(""***"") above elem(""world"") column1 beside column2
  
 Prepared for jacques weiss
  
 Printing the result of this expression would 
 give: 
 hello *** 
  
   
 *** world
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
10.2,"Chapter 10 · Composition and Inheritance
  
 206",NA
Abstract classes,"The first task covered in this chapter is how to define the type
  Element
  
 of lay-out elements. What members should layout elements have? 
 Since elements are two dimensional rectangles of characters, it makes 
 sense to include a member
  contents
 , which refers to the contents of a 
 layout element. The contents can be represented as an array of strings, 
 where each string repre-sents a line. Hence, the type of the result 
 returned by
  contents
  should be 
 Array[String]
 . 
  
 Then there should be methods
  width
  and
  height
  that provide the di-
 mensions of the layout element. 
  
 Finally, there should be methods
  above
  and
  beside
  for forming new 
 elements by placing an element above and beside another, respectively. 
  
 All five methods together are bundled in a class
  Element
 . The outline 
 of this class is as follows: 
 abstract class Element {
  
 def contents: Array[String]
  
 def width: Int = ...
  
 def height: Int = ...
  
 def above(that: Element): Element = ...
  
 def beside(that: Element): Element = ...
  
 }
  
 The
  Element
  class declares five methods:
  contents
 ,
  width
 ,
  height
 , 
 above
 , 
 and
  beside
 . The implementations of the last four of these methods are 
 left out here; they will will be given below. The first method,
  contents
 , 
 does not have an implementation. In other words, the method is an
  
 abstract 
 member of class
  Element
 . A class with abstract members must 
 itself be declared abstract; this is done by writing an
  abstract
  modifier 
 in front of the
  class
  keyword: 
 abstract class Element ...
  
 Prepared for jacques weiss
  
 The
  abstract
  modifier in front of a class signifies that the class may have 
 abstract members which do not have an implementation. Therefore, it 
 is not permitted to create an object of an abstract class. If you try to 
 write 
 scala> new Element
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
10.3 ,NA,NA
The Uniform Access Principle,"The next thing to turn to is the implementation of the concrete methods 
 in class
  Element
 . Here are the first two: 
 def width: Int =
  
 if (height == 0) 0 else contents(0).length
  
 def height: Int = contents.length
  
 The
  height
  method returns the number of lines in
  contents
 . The
  width 
 method returns the length of the first line, or, if there are no lines in the 
 element, zero. (This means you cannot define an element with a height 
 of zero and a non-zero width.)  
  
 Note that neither method has a parameter list, not even an empty 
 one. Parameterless methods such as
  width
  or
  height
  are quite common in 
 Scala. The recommendation is to use a parameterless method 
 whenever there are",NA
10.4 ,NA,NA
Assertions and assumptions,"Note that the
  width
  method gives a correct result only if all lines in the 
 array have the same length. You can state this property as a set of 
 assertions in class
  Element
 : 
 for (line <- contents)
  
 assert(line.length == width, ""element is not rectangular"")
  
 Assertions in Scala are written as calls of a predefined method
  assert
 .
 1 
 The expression  
 assert(condition)
  throws an  
 AssertionError
  if 
 condition
  does not hold.  
 There’s also a two argument version: 
 assert(condition, explanation)
  tests
  condition
 , and, if it does not hold, throws 
 an
  AssertionError
  which contains the given
  String
  expla-nation. 
 A failing assertion always indicates that some code is incorrect. 
 The incorrect code is not always the code that contains the assertion, 
 however. For instance, consider the following function which returns 
 the inverse of its 
 acques weiss
  
 floating point argument. 
 def inverse(x: Double) = 1 / x",NA
10.5 ,NA,NA
Subclasses,"For the implementation of the remaining methods
  above
  and
  beside
  you 
 need a way to create new element objects.  You have already seen 
 that“
 new Element
 ” cannot be used for this because class
  Element
  is 
 abstract. You need to create a subclass which extends
  Element
  and which 
 implements the abstract
  contents
  method. Here’s a possible way to do 
 this: 
 class ArrayElement(conts: Array[String]) extends Element {",NA
10.6,NA,NA
"Two name spaces, not four",NA,NA
10.7 ,NA,NA
Class parameter fields,"Consider again the definition of class
  ArrayElement
  above. It has a 
 param-eter
  conts
  whose sole purpose is to be copied into the
  contents
  
 field. The name
  conts
  of the parameter was chosen just so that it would 
 look similar to the field name
  contents
  without actually clashing with it. 
 This is a “code smell”, a sure sign that there is some unnecessary 
 redundancy and repetition in your code. 
  
 You can avoid the code smell by combining the parameter and the 
 field in a single class parameter field definition, like this: 
 class ArrayElement(val contents: Array[String]) extends Element {}
  
 Note that now the
  contents
  parameter is prefixed by
  val
 . This is a short-
 hand which defines at the same time a parameter and a field with the 
 same name. Concretely, class
  ArrayElement
  now has an (unreassignable) 
 field 
 contents
  which can be accessed from outside the class. The field is 
 initial-ized with the value of the parameter. It’s as if the class had been 
 written as follows, where
  x123
  is an arbitrary fresh name for the 
 parameter:",NA
10.8 ,NA,NA
More method implementations,"Now that
  ArrayElement
  is defined, the next step is to implement method 
 above
  in class
  Element
 . Putting one element above another means 
 concate-nating the two
  contents
  values of the elements. So a first draft 
 of method 
 above
  could look like this: 
 def above(that: Element): Element =
  
 new ArrayElement(this.contents ++ that.contents)
  
 The ‘
 ++
 ’ operation concatenates two arrays. Arrays in Scala are 
 represented as Java arrays, but support many more methods. 
 Specifically, arrays in Scala 
 ques weiss
  
 inherit from a class
  scala.Seq
 , which represents sequence-like structures 
 and contains a number of methods for accessing and transforming 
 sequences.",NA
10.9 ,NA,NA
Private helper methods,"Here’s a first implementation of
  widen
  (you’ll see a more elegant one below). 
 private def widen(w: Int): Element =
  
 if (w <= width) this
  
 else {
  
 val lpad = (w - width) / 2
  
 val rpad = w - (lpad + width)
  
 new ArrayElement(
  
 for (line <- contents)
  
 yield spaces(lpad) + line + spaces(rpad)
  
 )
  
 }
  
 The
  widen
  method takes a target width
  w
  as parameter and returns an 
 Element
 . If the current element width is already greater or equal to the 
 Prepared for jacques weiss
  
 target width, the element itself is returned. Otherwise, the method 
 returns a new element where each line in
  contents
  is prefixed by
  lpad
  
 spaces and followed by
  rpad
  spaces. 
 Note that the for expression that performs this computation is used 
 di-rectly as an argument to the object creation
  new ArrayElement
 . This is 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
10.10 Imperative or functional?,"The next method to implement is
  beside
 . To put two elements beside 
 each other, you create a new element in which every line results from 
 concate-nating corresponding lines of the two elements. As a first step, 
 the elements must be adjusted so that they have the same height. This 
 leads to the follow-ing design of method
  beside
 : 
 Prepared for jacques weiss
  
 def beside(that: Element): Element = { 
  
 val this1 = this heighten that.height 
  
 val that1 = that heighten this.height 
  
 val contents = new Array[String](this1.contents.length) for (i <- 0 until 
 this1.contents.length)
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
10.11 Adding other subclasses,"You now have a complete system consisting of two classes: An abstract 
 class
  Element
  which is inherited by a concrete class
  ArrayElement
 . One 
 might also envisage other ways to express an element. Think for 
 instance of a layout element consisting of a single line which is given 
 by a string. Another possibility would be a layout element of given 
 width and height that is filled everywhere by some given character. 
 One important aspect of object-oriented programming is that it makes 
 it easy to extend a system with new data-variants. You can simply add 
 further subclasses that extend a common",NA
10.12,NA,NA
Override modifiers and the fragile base class,NA,NA
problem ,"Note that the definitions of
  width
  and
  height
  in these classes carry an 
 override
  modifier. Previously, you have already seen this modifier in the 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
10.13 Factories,"You now have a hierarchy of classes for layout elements. This hierarchy 
 could be presented to a user “as is”. But you might also choose to hide",NA
10.14 Putting it all together,"With the factory methods in
  Element
 , the subclasses
  ArrayElement
 , 
 LineElement
  and
  UniformElement
  can now be private because they need no 
 longer be accessed directly by clients.  
 Some simplifications of class 
 Element
  are also possible. First, direct object construction can now be 
 re-placed by a call to a factory method. Another simplification concerns 
 the implementations of the adjustment methods
  widen
  and
  heighten
  
 (which was not yet shown). Instead of directly manipulating content 
 arrays, they can also be implemented by composing the elements with 
 blank rectangles of the",NA
10.15 Scala’s class hierarchy,"Figure 10.2
  shows an outline of Scala’s class hierarchy. At the top of the 
 Prepared for jacques weiss
  
 hierarchy there is class
  Any
 . Every Scala class inherits from this class. 
 Class 
 Any
  defines some methods which are inherited by all other 
 classes. These include the following: 
 final def ==(that: Any): Boolean
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
10.16 Implementing primitives,"How is all this implemented? In fact, Scala stores integers in the same 
 way as Java: as 32-bit words. This is important for efficiency on the 
 JVM and also for interoperability with Java libraries. Standard 
 operations like addition or multiplication are implemented as 
 primitive operations. However, Scala uses the “backup” class
  
 java.lang.Integer
  whenever an integer needs to be seen as a (Java) object. 
 This happens for instance when invoking the 
 toString
  method on an 
 integer number or when assigning an integer to a variable of type
  Any
 . 
 Integers of type
  Int
  are converted transparently to“boxed integers” of 
 type
  java.lang.Integer
  whenever necessary. 
 All this sounds a lot like auto-boxing in Java 5 and it is indeed quite 
 similar. There’s one crucial difference, though, in that boxing in Scala 
 is much less visible than boxing in Java. Try the following in Java: 
 boolean isEqual(int x, int y) {
  
 return x == y;
  
 }
  
 System.out.println(isEqual(42, 42));
  
 You will surely get
  true
 . Now, change the argument types of
  isEqual
  to 
 java.lang.Integer
  (or
  Object
 , the result will be the same): 
 boolean isEqual(Integer x, Integer y) {
  
 return x == y;",NA
10.17 Bottom types,"At the bottom of the type hierarchy in
  Figure 10.2
  you see the two 
 classes 
 scala.Null
  and
  scala.Nothing
 . These are special types that handle 
 some“corner cases” of Scala’s object-oriented type system in a uniform 
 way. 
 Class
  Null
  is the type of the
  null
  reference; it is a subclass of every 
 reference class (
 i.e.
 , every class which itself inherits from
  AnyRef
 ).
  Null
  
 is not compatible with value types. Therefore, you cannot assign a
  null
  
 value to an integer variable, say. 
 The type
  Nothing
  is at the very bottom of Scala’s class hierarchy. It is 
 a subtype of every other type. However, there exist no values of this 
 type whatsoever. Why does it make sense to have a type without 
 values? One use of
  Nothing
  is that it signals abnormal termination. For 
 instance there’s the
  error
  method in the
  Predef
  object of Scala’s standard 
 library, which is defined as follows.",NA
10.18 Conclusion,"In this section, you have seen more concepts related to object-oriented 
 pro-gramming in Scala. Among others, you have encountered abstract 
 classes, inheritance and subtyping, class hierarchies, class parameter 
 fields, and method overriding. You should have developed a feel for 
 constructing a non-trivial class hierarchy in Scala. 
 Another important aspect that was treated mostly “between the 
 lines”in this chapter was composition. Layout elements are a good 
 example of a system where objects can be constructed from simple 
 parts (arrays, lines, and rectangles) with the aid of composing 
 operators (
 above
  and
  beside
 ). Such composing operators are also often 
 called
  combinators
  because they combine elements of some domain 
 into new elements. 
 Thinking in terms of combinators is generally a good way to 
 approach library design: It pays to think about the fundamental ways 
 to construct ob-jects in an application domain. What are the simple 
 objects? In what ways can more interesting objects be constructed out 
 of simpler ones? How do combinators hang together? What are the 
 most general combinations? Do they satisfy any interesting laws? If 
 you have good answers to these ques-tions, your library design is on 
 track. 
 So far, the whole treatment of classes and objects was based on 
 single inheritance, where every class inherits from just one superclass. 
 In the next chapter, you will find out about
  traits
 , which let you 
 construct even more interesting class hierarchies.",NA
Chapter 11,NA,NA
Traits and Mixins,"Traits offer a more fine-grained way to reuse code than normal 
 inheritance. Like inheritance, traits let you add code to a class that is 
 written elsewhere in the program. Unlike inheritance, however, a class 
 can “mix in” any number of traits. With inheritance, only one 
 superclass is allowed per class. 
 This chapter introduces traits and shows you two of the most 
 common ways they are useful: widening thin interfaces to thick ones, 
 and defining stackable modifications.
  Chapter 25
  will discuss the role 
 of traits in defining modules.",NA
11.1 ,NA,NA
Syntax,"A trait definition looks just like a class definition except that it uses the 
 key-word
  trait
 : 
 trait Printable {
  
 def print() {
  
 println(this)
  
 }
  
 }",NA
11.2 ,NA,NA
Thin versus thick interfaces,"One major use of traits is to automatically add methods to a class in 
 terms of methods that the class already has. That is, traits can expand 
 a
  thin
  interface into a
  thick
  interface. 
 Thin versus thick interfaces are a commonly faced trade-off in 
 object-oriented design. The trade-off is between the implementors and 
 clients of an interface. A thick interface has many methods, which 
 make it convenient for the caller. Clients can pick a method that 
 corresponds exactly to the functionality they want, instead of having 
 to use a more primitive method and write extra code to adapt the 
 method to their needs. A thin interface, on the other hand, has fewer 
 methods, and thus is easier to implement. Java’s interfaces are most 
 often of the thin kind. 
 Scala traits make thick interfaces more convenient. Unlike Java 
 inter-faces, traits can define methods that include code,
  i.e.
 , they can 
 not only declare abstract methods, but also define concrete ones. You 
 just saw one example of this: the
  print
  method of the
  Printable
  trait is 
 concrete. 
 Adding a concrete method to a trait tilts the thin-thick trade-off 
 heav-ily towards thick interfaces. Unlike with Java interfaces, adding a 
 concrete method to a Scala trait is a one-time effort. You only need to 
 implement the method once, in the trait itself, instead of needing to 
 reimplement it for every 
 ques weiss
  
 class that mixes in the trait. Thus, thick interfaces are less work to 
 provide in Scala than in a language without traits.",NA
11.3 ,NA,NA
The standard,Ordered,NA
 trait,"Comparison is one place where a thick interface is convenient. 
 Whenever you have objects that are ordered, it is convenient if you 
 can use the pre-cise ordering operation for each situation. Sometimes 
 you want ‘
 <
 ’ (less than), and sometimes you want ‘
 <=
 ’ (less than or 
 equal). A thin interface would provide just one of these methods, 
 forcing you to write things like 
 ((x < y) || (x == y))
 . A thick interface 
 would provide you with all of the usual comparison operators, so that 
 you can directly write things like 
 (x <= y)
 . The standard
  Ordered
  trait 
 allows you to implement one method and gain access to four different 
 variations. 
 Here is what you might do without the
  Ordered
  trait. If you are 
 imple-menting a
  Book
  class that has an ordering, you might write the 
 following code: 
 class Book(val author: String, val title: String) {
  
 def <(that: Book) =
  
 (author < that.author) ||
  
 ((author == that.author) && title < that.title)
  
 def >(that: Book) = that < this
  
 def <=(that: Book) = (this < that) || (this == that)
  
 def >=(that: Book) = (this > that) || (this == that)
  
 override def equals(that: Any) =",NA
11.4 ,NA,NA
Traits for modifying interfaces,"You have now seen one major use of traits: turning a thin interface 
 into a thick one. Now let us turn to a second major use: provide 
 stackable modi-fications to behavior. This section focuses on 
 modifications, while the next one is about making them stackable. 
 As an example modification, consider the caching of hash codes. 
 Hash codes need to be computed quickly, because hash-based 
 collections make more hash-code comparisons than full
  
 ==
  
 comparisons. If a class’s hash-code computation is slow, then 
 collections holding that class can waste a lot of time computing hashes. 
 One way to speed up hashing is to cache the computed values. That 
 way, even if a hash routine is not fast already, the cost is only paid one 
 time per object instead of one time per call to
  hashCode
 . Here is a simple 
 trait that caches the hash code of the class it is mixed into: 
 trait HashCaching {
  
 Prepared for jacques weiss
  
 /** A cache holding the computed hash. */ private var 
 cachedHash: Int = 0
  
 /** A boolean indicating whether the cache is defined */ private var 
 hashComputed: Boolean = false
  
 /** The hash code computation is abstract */
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
11.5 ,NA,NA
Stacking modifications,"Stackable modifications can be combined with each other in any way 
 you desire. Given a set of stackable traits that each modify a class in 
 some way, you can pick and choose any of those traits you would like 
 to use when defining new classes. 
 Let us continue the hashing example, and consider another 
 common hashing challenge: many times, the most useful bits of a hash 
 are concen-trated somewhere in the middle. For some hashing 
 collections, it is better to either move the useful bits to low-order bits, 
 or to spread the useful bits throughout the integer. 
  
 Thus, you can often improve on a hash function by scrambling the 
 bits around. Here is a trait that does just that: 
 trait HashScrambling
  
 {
  
 override def hashCode = {
  
 val original = super.hashCode
  
 def rl(i: Int) = Integer.rotateLeft(original, i)
  
 original ˆ rl(8) ˆ rl(16) ˆ rl(24)
  
 }
  
 }
  
 Prepared for jacques weiss
  
 To use this in the book class, change its definition to: 
 class Book(author: String, title: String) extends 
 BaseBook(author, title) 
  
 with Ordered[Book] 
  
 with HashScrambling
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
11.6 ,NA,NA
Locking and logging queues,"Locking and logging queues are a well-known example of stackable 
 modi-fications. It is well known within the Scala community because it 
 was con-sidered during the design of traits, and it is known in 
 language-design cir-cles because of early Scala materials that use it as 
 an example. This section overviews the problem, and gives the 
 solution in Scala using stackable traits. 
 The locking logging example involves the following three concepts: 
 •
  Queue
 : an abstract class that can get and put elements. 
 •
  Locking
 : a modification of a queue to use locking. 
 •
  Logging
 : a modification of a queue to log gets and puts. 
 Using stackable traits, the solution is just as easy as the hash code 
 exam-ples seen so far. To simplify the example, this code assumes that 
 the queues are over integers, as opposed to arbitrary objects. 
 trait Queue {
  
 def get(): Int
  
 def put(x: Int)
  
 }",NA
11.7,"Chapter 11 · Traits and Mixins
  
 245",NA
Traits versus multiple inheritance,"Traits are not the same as the multiple inheritance used in other 
 languages. The difference is in the meaning of
  super
  calls. In multiple 
 inheritance, a 
 super
  call invokes a method in one of the superclasses of 
 the calling class. With traits, the invoked method is found according to 
 a
  linearization
  of the classes and traits that are mixed into a class. 
 Because of this difference, Scala’s traits support stacking of 
 modifications as described above. 
 Before looking at linearization, take a moment to consider how to 
 stack modifications in a language with multiple inheritance. Perhaps 
 your first try is to implement locking and logging queues as described 
 previously. You would then instantiate a queue and call a method on it, 
 like this: 
 val q1 = new StandardQueue with LockingQueue with LoggingQueue
  
 q1.put(42) 
  
 // which put is called?
  
 The first question is, which
  put
  method gets invoked by this call? 
 Perhaps the rule is that the last superclass wins, in which case
  
 LoggingQueue
  will get called.
  LoggingQueue
  calls
  super
  and then logs the 
 call, and that is it. No locking happened! Likewise, if the rule is that the 
 first superclass wins, the resulting queue locks accesses but does not 
 log them. Thus neither ordering works. 
 Your next try might be to make an explicit subclass for locking, 
 logging queues. Now you have new problems. for example, suppose 
 you try the following: 
 trait LockingLoggingQueue extends LockingQueue with LoggingQueue {
  
 def put(x: Int) = {
  
 LockingQueue.super.put(x)
  
 LoggingQueue.super.put(x)
  
 }
  
 }",NA
11.8 ,NA,NA
"To trait, or not to trait?","Whenever you implement a reusable collection of behavior, you will 
 have to decide whether you want to use a trait or an abstract class. 
 There is no firm rule, but here are a few guidelines to consider. 
  
 If the behavior will not be reused
 , then make it into a concrete class. 
 It is not reusable behavior after all. 
  
 If it might be reused in multiple, unrelated classes
 , then make it a 
 trait. Only traits can be mixed into different parts of the class hierarchy. 
 If you want to inherit it in Java code
 , then use an abstract class. Since",NA
Chapter 12,NA,NA
Case Classes and Pattern Matching,"This chapter introduces
  case classes
  and
  pattern matching
 , twin 
 constructs that support you when writing regular, non-encapsulated 
 data structures. The two constructs are particularly helpful for tree-
 like recursive data. 
 If you have programmed in a functional language before, then you 
 will probably recognize pattern matching. Case classes will still be 
 new, how-ever. Case classes are Scala’s secret for allowing pattern 
 matching without requiring a large amount of boilerplate to set 
 everything up. In the common case, you add a single
  case
  keyword to 
 each class that you want to be pattern matchable. 
 This chapter starts with a simple example of case classes and 
 pattern matching. It then goes through all of the kinds of patterns that 
 are supported, talks about the role of
  sealed
  classes, discusses the
  
 Option
  type, and shows some unobvious places in the language that 
 pattern matching is used. Finally, a larger, more realistic example of 
 pattern matching is shown.",NA
12.1 ,NA,NA
A simple example,"Before delving into all the rules and nuances of pattern matching, it is 
 worth looking at a simple example to get the general idea. Let us say 
 you want to",NA
12.2 ,NA,NA
Kinds of patterns,"The previous example showed several kinds of patterns in quick 
 succession. Now take a minute to look at each. 
 The syntax of patterns is easy, so do not worry about that too 
 much. All patterns look exactly like the corresponding expression. For 
 instance, the pattern
  Number(x)
  matches any number object, binding
  x
  
 to the number. Used as an expression,
  Number(x)
  recreates an 
 equivalent object, assuming 
 x
  is already bound to the number. The 
 main thing to pay attention to is just what kinds of patterns are 
 possible.",NA
12.3,NA,NA
Pattern guards,"Sometimes, syntactic pattern matching is not precise enough. For 
 instance, say you are given the task of formulating a simplification rule 
 that replaces sum expressions with two identical operands such as
  e + 
 e
  by multiplications of two, e.g.
  e * 2
 . In the language of
  Expr
  trees, an 
 expression like 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
12.4,"Chapter 12 · Case Classes and Pattern Matching
  
 263",NA
Pattern overlaps,"Patterns are tried in the order in which they are written. The following 
 ver-sion of
  simplify
  presents an example where this order matters. 
 def simplifyAny(expr: Expr): Expr = expr match {
  
 case UnOp(""-"", UnOp(""-"", e)) => e case 
 BinOp(""+"", e, Number(0)) => e case BinOp(""*"", e, 
 Number(1)) => e
  
 // ‘-' is its own inverse 
  
 // ‘0' is a neutral element for ‘+' // ‘1' is a neutral 
 element for ‘*'
  
 case UnOp(op, e) => UnOp(op, simplifyAny(e))
  
 case BinOp(op, l, r) => BinOp(op, simplifyAny(l), simplifyAny(r))
  
 case _ => expr
  
 }
  
 This version of simplify will apply simplification rules anywhere in 
 an expression, not just at the top, as
  simplifyTop
  did. It can be derived 
 from 
 simplifyTop
  by adding two more cases for general unary and 
 binary ex-pressions (cases four and five in the example above). 
 The fourth case has the pattern
  UnOp(op, e)
 ;
  i.e.
  it matches every 
 unary operation. The operator and operand of the unary operation can 
 be arbitrary. They are bound to the pattern variables
  op
  and
  e
 , 
 respectively. The alterna-tive in this case applies
  simplifyAny
  
 recursively to the operand
  e
  and then re-builds the same unary 
 operation with the (possibly) simplified operand. The fifth case for
  
 BinOp
  is analogous; it is a “catch-all” case for arbitrary binary 
 operations, which recursively applies the simplification method to its 
 operands. 
 In this example, it is important that the “catch-all” cases come
  after
  
 the more specific simplification rules. If you wrote them in the other 
 order, then the catch-all case would be run in favor of the more 
 specific rules. In many cases, the compiler will even complain if you 
 try. For example: 
 scala> def simplifyBad(expr: Expr): Expr = expr match {
  
 Prepar
 ed for 
 jacques 
 weiss
  
 |
  
 case UnOp(op, e) => UnOp(op, simplifyBad(e))
  
 |
  
 case UnOp(""-"", UnOp(""-"", e)) => e",NA
12.5,"Chapter 12 · Case Classes and Pattern Matching
  
 264",NA
Sealed classes,"Whenever you write a pattern match, you need to make sure you have 
 cov-ered all of the possible cases. Sometimes you can do this by adding 
 a default case at the end of the match, but that only applies if there is a 
 sensible default behavior. What do you do if there is no default? How 
 can you ever feel safe that you covered all the cases? 
 In fact, you can enlist the help of the Scala compiler in detecting 
 missing combinations of patterns in a match expression. To be able to 
 do this, the compiler needs to be able to tell which are the possible 
 cases. In general, this is impossible in Scala, because new case classes 
 can be defined at any time and in arbitrary compilation units. For 
 instance, nobody would prevent you from adding a fifth case class to 
 the
  Expr
  class hierarchy in a different compilation unit from the one 
 where the other four cases are defined. 
 The alternative is to make the superclass of your case classes
  
 sealed
 . A sealed class cannot have any new subclasses added except 
 the ones in the same file. This is very useful for pattern matching, 
 because it means you only need to worry about the subclasses you 
 already know about. What’s more, you get better compiler support as 
 well. If you match against case classes that inherit from a sealed class, 
 the compiler will flag missing combinations of patterns with a warning 
 message. 
 Therefore, if you write a hierarchy of classes intended to be 
 pattern matched, you should consider sealing them. Simply put the
  
 sealed
  key-word in front of the class at the top of the hierarchy. 
 Programmers using your class hierarchy will then feel confident in 
 pattern matching against it. The
  sealed
  keyword, therefore, is often a 
 license to pattern match. 
  
 To experiment with sealed classes, you could turn the root
  Expr
  of 
 the arithmetic expression example defined previously into a sealed 
 class: 
 sealed abstract class Expr {}
  
 The four case classes
  Var
 ,
  Number
 ,
  UnOp
 , and
  BinOp
  can stay as they are. 
 Prepared for 
 jacques weiss
  
 Now define a pattern match where some of the possible cases are left 
 out: 
 def describe(e: Expr): String = e match { 
  
  
 case Number(x) => ""a number""",NA
12.6,"Chapter 12 · Case Classes and Pattern Matching
  
 266",NA
The,Option,NA
 type,"Scala has a standard type named
  Option
  for optional values. Such a 
 value can be of two forms: It can be of the form
  Some(x)
  where
  x
  is the 
 actual value. Or it can be the
  None
  object, which represents a missing 
 value. 
  
 Optional values are produced by some of the standard operations 
 on Scala’s collections.  
 For instance, the
  get
  method of a
  Map
  
 produces 
 Some(value)
  if a
  value
  corresponding to a given key has been 
 found, or 
 None
  if the given key is not defined in the
  Map
 . Here’s an 
 example: 
 scala> val capitals =
  
 | Map(""France"" -> ""Paris"", ""Japan"" -> ""Tokyo"")
  
 capitals:
  
 scala.collection.immutable.Map[java.lang.String,java.lang.String]
  
 = Map(France -> Paris, Japan -> Tokyo)
  
 scala> capitals get ""France""
  
 res19: Option[java.lang.String] = Some(Paris)
  
 scala> capitals get ""North Pole""
  
 res20: Option[java.lang.String] = None
  
 The most common way to take optional values apart is through a 
 pattern match. For instance: 
 scala> def show(x: Option[String]) = x match {
  
 | case Some(s) => s
  
 | case None => ""?""
  
 | }
  
 show: (Option[String])String
  
 scala> show(capitals get ""Japan"")
  
 res21: String = Tokyo
  
 scala> show(capitals get ""North Pole"")
  
 res22: String = ?",NA
12.7 ,NA,NA
Patterns everywhere,"Patterns are allowed in many parts of Scala, not just in standalone 
 match expressions. Take a look at some other places you can use 
 patterns. 
 Variable definitions
  
 Any time you define a
  val
  or a
  var
 , you can use a pattern instead of a 
 simple identifier. For example, you can use this to take apart a tuple 
 and assign each of its parts to its own variable: 
 scala> val mytuple = (123, ""abc"")
  
 mytuple: (Int, java.lang.String) = (123,abc)
  
 scala> val (number, string) = mytuple
  
 number: Int = 123
  
 string: java.lang.String = abc",NA
12.8 ,NA,NA
A larger example,"After having learned the different forms of patterns, you might be 
 interested in seeing them applied in a larger example. The proposed 
 task is to write an expression formatter class that displays an 
 arithmetic expression in a two-dimensional layout. Divisions such as
  x 
 / x + 1
  should be printed vertically, by placing the numerator on top of 
 the denominator, like this: 
 x
  
 -----
  
 x + 1
  
 As another example, here’s the expression ((a / (b * c) + 1 / n) / 3) in 
 two dimensional layout: 
 a 1
  
 ----- + -
  
 b * c n
  
 ---------
  
 3
  
 From these examples it looks like the class (let’s call it
  ExprFormatter
 ) 
 will have to do a fair bit of layout juggling, so it makes sense to use the 
 layout",NA
12.9 ,NA,NA
Conclusion,"This chapter has described Scala’s case classes and pattern matching 
 in de-tail. Using them, you can take advantage of several concise 
 idioms not nor-mally available in object-oriented languages. 
 Scala’s pattern matching goes further than this chapter describes, 
 how-ever. If you want to use pattern matching on one of your classes, 
 but you do 
 Prepared for jacques weiss
  
 not want to open access to your classes the way case classes do, then 
 you can use the
  extractors
  described in
  Chapter 24
 . 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Chapter 13,NA,NA
Packages and Imports,"When working with large programs, there is a risk that programmers 
 will either step on each other’s toes with conflicting code changes, or 
 be so afraid of that risk that they become mired in communication that 
 attempts to pre-vent such conflicts. One way to reduce this problem is 
 to write in a modular style. The program is divided into a number of 
 smaller modules, each of which has an inside and an outside. 
 Programmers 
 working 
 on 
 the 
 inside 
 of 
 a 
 module—its
  
 implementation
 —then only need to coordinate with other pro-
 grammers working on that very same module. Only when there are 
 changes to the outside of a module—its
  interface
 —is it necessary to 
 coordinate with developers working on other modules. Interface and 
 implementation were discussed in
  Chapter 4
  for classes, but the 
 concept applies just as well to packages. 
 This chapter shows several constructs that help you program in a 
 modular style. It shows how to place things in packages, how to make 
 names visible through imports, and how to control the visibility of 
 definitions through ac-cess modifiers. The constructs are similar in 
 spirit with constructs in Java, but there are some differences—usually 
 ways that are more consistent—so it is worth reading this chapter 
 even if you already know Java. 
 Looking ahead,
  Chapter 25
  shows some additional techniques to make",NA
13.1,"Chapter 13 · Packages and Imports
  
 280",NA
Packages,"Packages in Scala are similar to packages in Java. There is a global 
 hierarchy of packages. You can place the contents of an entire file into 
 one of these packages by putting a
  package
  clause at the top of the file. 
 package bobsrockets.navigation
  
 class Navigator { ... }
  
 In the above example, class 
 Navigator
  
 goes into the package 
 bobsrockets.navigation
 . Presumably, this is the navigation software de-
 veloped by Bob’s Rockets, Inc. 
 Scala also supports a syntax more like
  C#
  namespaces where a 
 package clause is followed by a section in curly braces which contains 
 the definitions that go into the package. Among other things, this 
 syntax lets you put differ-ent parts of a file into different packages. For 
 example, you might include a class’s tests in the same file as the 
 original code, but put the tests in a different package, as shown in
  
 Figure 13.1
 . 
  
 In   
 Figure 
  
 13.1
 ,  
 object   
 NavigatorTest 
  goes  into  pack-
 age  
  
 bobsrockets.tests
 ,   
 and class  
 Navigator 
  
  goes   into 
  
  
   
  
  
 In fact, the first Java-like syntax is just 
 bobsrockets.navigation
 . 
 syntactic sugar for the more general nested syntax. So the following 
 three versions of
  bobsrockets.navigation.Navigator
  are all equivalent: 
 // Java-like package clause
  
 package bobsrockets.navigation
  
 class Navigator { ... }
  
 // Namespace-like package
  
 package bobsrockets.navigation {
  
 class Navigator { ... }
  
 }
  
 // Nested namespace-like package",NA
13.2,NA,NA
Import,NA,NA
s,"Chapter 13 · Packages and Imports
  
 283 
 As in Java, packages and their members can be imported using
  import 
 clauses. Imported items can then be accessed by a single identifier like
  
 File
 , as opposed to requiring a qualified name like
  java.io.File
 . 
 Scala’s
  import
  clauses are quite a bit more flexible than Java’s. There 
 are three principal differences. In Scala, imports may appear 
 anywhere, they may refer to singleton objects in addition to packages, 
 and they let you re-name and hide some of the imported members. 
 The rest of this section explains the details. Assume for the discussion 
 the following code which defines some kinds of fruit: 
 package bobsdelights
  
 trait Fruit {
  
 val name: String
  
 val color: Color
  
 }
  
 object Fruits {
  
 object Apple extends Fruit { ... }
  
 object Orange extends Fruit { ... }
  
 object Pear extends Fruit { ... }
  
 val menu = List(Apple, Orange, Pear)
  
 }
  
 An
  import
  clause makes members of a package or object available by 
 their names alone without needing to prefix them by the package or 
 object. Here are some simple examples: 
 import bobsdelights.Fruit 
  
 import bobsdelights._ 
  
 import bobsdelights.Fruits._
  
 // easy access to Fruit 
  
 // easy access to all members of bobsdelights // easy access to 
 all members of Fruits
  
 The first of these corresponds to Java’s single type import, the second to 
 Prepared for jacques weiss
  
 Java’s “on demand” import. The only difference is that Scala’s on 
 demand imports are written with a trailing under-bar ‘
 _
 ’ instead of an 
 asterisk ‘
 *
 ’(after all,
  *
 , is a valid identifier in Scala!). The third import 
 clause above corresponds roughly to Java’s import of static class fields, 
 but it is more general. 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
13.3,"Chapter 13 · Packages and Imports
  
 286",NA
Access modifiers,"Members of packages, classes or objects can be labeled with the access 
 mod-ifiers
  private
  and
  protected
 .  These modifiers restrict accesses to 
 the members to certain regions of code. Scala’s treatment of access 
 modifiers roughly follows Java’s but there are some important 
 differences which are explained in the following. 
 Private members
  
 Private members are treated similarly to Java. A member labeled
  
 private 
 is visible only inside the class or object that contains the 
 member definition. In Scala, this rule applies also for inner classes. 
 This treatment is more consistent, but differs from Java. Consider this 
 example: 
 class Outer {
  
 class Inner {
  
 private def f() { println(""f"") }
  
 class InnerMost {
  
 f() // OK
  
 }
  
 }
  
 (new Inner).f() // error: ‘f' is not accessible
  
 }
  
 In Scala, the access
  (new Inner).f()
  is illegal because
  f
  is declared 
 private
  in
  
 Inner
  and the access is not from within class
  Inner
 . By con-trast, the first 
 access to
  f
  in class
  InnerMost
  is OK, because that access is contained in 
 the body of class
  Inner
 . Java would permit both accesses because it lets 
 an outer class access private members of its inner classes. 
 Protected members
  
 Access to
  protected
  members is a bit more restrictive than in Java. In",NA
Chapter 14,NA,NA
Working with Lists,"Lists are probably the most commonly used data structure in Scala 
 programs. This chapter explains lists in detail. It presents many 
 common operations that can be performed on lists. It also teaches 
 some important design principles for programs working on lists.",NA
14.1 ,NA,NA
List literals,"You have seen lists already in the preceding chapters, so you know 
 that a list containing the elements
  'a', 'b', 'c'
  is written
  List('a', 'b', 'c')
 . 
 Here are some other examples: 
 val fruit = List(""apples"", ""oranges"", ""pears"")
  
 val nums 
  
 = List(1, 2, 3, 4)
  
 val diag3 = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))
  
 val empty = List()
  
 Lists are quite similar to arrays, but there are two important 
 differences. First, lists are immutable. That is, elements of a list cannot 
 be changed by assignment. Second, lists have a recursive structure, 
 whereas arrays are flat. 
 Prepare
 d for 
 jacques 
 weiss",NA
14.2,NA,NA
The,List,NA
 type,NA,NA
14.3 ,NA,NA
Constructing lists,"All lists are built from two fundamental building blocks,
  Nil
  and ‘
 ::
 ’ 
 (pro-nounced “cons”).
  Nil
  represents an empty list. The infix operator 
 ‘
 ::
 ’ ex-presses list extension at the front. That is,
  x :: xs
  represents a list 
 whose first element is
  x
 , which is followed by (the elements of) list
  xs
 . 
 Hence, the previous list values above could also have been defined as 
 follows: 
 or jacques weiss
  
 val fruit
  
 = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))
  
 val nums
  
 = 1 :: (2 :: (3 :: (4 :: Nil)))
  
 val diag3
  
 = (1 :: (0 :: (0 :: Nil))) ::",NA
14.4 ,NA,NA
Basic operations on lists,"All operations on lists can be expressed in terms of the following three: 
 Prepared for jacques weiss
  
 head
  
 returns the first element of a list, 
 tail
  
 returns the list consisting of all elements except the first 
 element, 
 isEmpty
  
 returns
  true
  if the list is empty 
 These operations are defined as methods of class
  List
 . You invoke 
 them by selecting from the list that’s operated on. Some examples are 
 shown in 
 Table 14.1
 . 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
14.5 ,NA,NA
List patterns,"Lists can also be taken apart using pattern matching. List patterns 
 correspond one-by-one to list expressions. You can either match on all 
 elements of a list using a pattern of the form
  List(...)
 . Or you take lists 
 apart bit by bit using patterns composed from the ‘
 ::
 ’ operator and the
  
 Nil
  constant. 
 Here’s an example of the first kind of pattern: 
 scala> val List(a, b, c) = fruit
  
 a: java.lang.String = apples
  
 b: java.lang.String = oranges
  
 c: java.lang.String = pears",NA
14.6 ,NA,NA
Operations on lists Part I: First-order methods,"This section explains most first-order methods defined in the
  List
  class. 
 First-order methods are methods that do not take functions as 
 arguments. The section also introduces by means of two examples 
 some recommended techniques to structure programs that operate on 
 lists. 
 Concatenating lists
  
 An operation similar to ‘
 ::
 ’ is list concatenation, written ‘
 :::
 ’. Unlike 
 ‘
 ::
 ’,‘
 :::
 ’ takes two lists as arguments The result of
  xs ::: ys
  is a new list 
 which contains all the elements of
  xs
 , followed by all the elements of
  ys
 . 
 Here are some examples: 
 scala> List(1, 2) ::: List(3, 4, 5)
  
 res0: List[Int] = List(1, 2, 3, 4, 5)
  
 scala> List() ::: List(1, 2, 3)
  
 res1: List[Int] = List(1, 2, 3)
  
 scala> List(1, 2, 3) ::: List(4)
  
 res2: List[Int] = List(1, 2, 3, 4)
  
 Like cons, list concatenation associates to the right. An expression like this: 
 xs ::: ys ::: zs",NA
14.7 ,NA,NA
Operations on lists Part II: Higher-order methods,"Many operations over lists have a similar structure. One can identify 
 several patterns that appear time and time again. Examples are: 
 transforming every element of a list in some way, verifying whether a 
 property holds for all ele-ments of a list, extracting from a list 
 elements satisfying a certain criterion, or combining the elements of a 
 list using some operator. In Java, such pat-terns would usually be 
 expressed by idiomatic combinations of for-loops or while-loops. In 
 Scala, they can be expressed more concisely and directly us-",NA
14.8 ,NA,NA
Operations on lists Part III: Methods of the,List,NA
object,"So far, all operations you have seen in this chapter are implemented as 
 meth-ods of class
  List
 , so you invoke them on individual list objects. 
 There are also a number of methods in the globally accessible object
  
 scala.List
 , which is the companion object of class
  List
 . Some of these 
 operations are factory methods that create lists. Others are operations 
 that work on lists of some specific type of shape. Both kinds of 
 methods will be presented in the following. 
 Creating lists from their elements:
  List.apply
  
 You have already seen on several occasions list literals such as 
 List(1, 2, 
 3)
 . There’s nothing special about their syntax. A literal like 
 List(1, 2, 3)
  is 
 simply the application of the function object
  List
  to the elements
  1, 2, 3
 . 
 That is, it is equivalent to
  List.apply(1, 2, 3)
 . 
 scala> List.apply(1, 2, 3)
  
 res49: List[Int] = List(1, 2, 3)
  
 Creating a range of numbers:
  List.range
  
 The
  range
  method creates a list consisting of a range of numbers. Its 
 sim-plest form is
  List.range(from, to)
 ; this creates a list of all numbers 
 start-ing at
  from
  and going up to
  to
  minus one. So the end value
  to
  does 
 not form part of the range. 
 There’s also a version of
  range
  that takes a
  step
  value as third parame-",NA
14.9 ,NA,NA
Understanding Scala’s type inference algorithm,"One difference between the previous uses of
  sort
  and
  msort
  concerns the 
 admissible syntactic forms of the comparison function. Compare 
 scala> msort((x: Char, y: Char) => x > y)(abcde)
  
 res62: List[Char] = List(e, d, c, b, a)
  
 with 
 scala> abcde sort (_ > _)
  
 res63: List[Char] = List(e, d, c, b, a)
  
 The two expressions are equivalent, but the first uses a longer form of 
 com-parison function with named parameters and explicit types 
 whereas the sec-ond uses the concise form
  (_ > _)
  where named 
 parameters are replaced by underscores. Of course, you could also use 
 the first, longer form of compar-ison with
  sort
 . However, the short 
 form cannot be used with
  msort
 : 
 scala> msort(_ > _)(abcde)
  
 <console>:12: error: missing parameter type for expanded
  
 function ((x$1, x$2) => x$1.$greater(x$2))
  
 msort(_ > _)(abcde)
  
 ˆ
  
 To understand why, you need to know some details of Scala’s type 
 infer-ence algorithm. Type inference in Scala is flow based. In a 
 method ap-plication
  m(args)
 , the inferencer first checks whether the 
 method
  m
  has 
 Pre
 par
 ed 
 for 
 jac
 que
 s 
 wei
 ss
  
 a known type. If it has, that type is used to infer the expected type of",NA
Chapter 15,NA,NA
Collections,"Collections let you organize large numbers of objects. Scala has a rich 
 col-lection library. In the simple cases, you can throw a few objects 
 into a set or a list and not think much about it. For trickier cases, Scala 
 provides a general library with several collection types, such as 
 sequences, sets and maps. Each collection type comes in two 
 variants—mutable and immutable. Most kinds of collections have 
 several different implementations that have different tradeoffs of 
 speed, space, and the requirements on their input data. You’ve seen 
 many collection types in previous chapters. In this chapter we’ll show 
 you the big picture of how they relate to each other.",NA
15.1 ,NA,NA
Overview of the library,"Figure 10.2
  shows the class hierarchy of the most frequently used 
 kinds of collections in Scala’s standard library. Each of these types is a 
 trait, so each of them allows multiple implementations. All of them 
 have a good default implementation available in the standard library. 
  
 At the top of the hierarchy is
  Iterable
 , the trait for possibly infinite 
 groups of objects. The key property of an
  Iterable
  is that it is possi-ble to 
 iterate through the elements of the collection using a method named",NA
scala.collection ,NA,NA
Map,NA,NA
«trait»,"scala.collection.mutable 
  
 Map
  
 «trait»
  
 scala.collection.immutable 
  
 Map
  
 «trait»",NA
scala ,NA,NA
Iterable,NA,NA
«trait»,NA,NA
scala ,NA,NA
Collection,NA,NA
«trait»,NA,NA
scala.collection ,NA,NA
Set,NA,NA
«trait»,"scala.collection.mutable 
  
 Set
  
 «trait»
  
 scala.collection.immutable 
  
 Set
  
 «trait»
  
 scala 
  
 Array
  
 «final»",NA
scala ,NA,NA
Seq,NA,NA
«trait»,"scala 
  
 List
  
 «sealed abstract»
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  
 Index",NA
15.2 ,NA,NA
Sequences,"Sequences, classes that inherit from the
  Seq
  trait, let you work with 
 groups of data lined up in order. Because the elements are ordered, 
 you can ask for the first element, the second element, the 103rd 
 element, and so on. There are a few different kinds of sequences you 
 should learn about early on: arrays, array buffers, and lists.",NA
15.3 ,NA,NA
Tuples,"A tuple combines a fixed number of items together so that they can be 
 passed around as a whole. Unlike an array, a tuple can hold objects with 
 different",NA
15.4,"Chapter 15 · Collections
  
 331",NA
Sets and maps,"Two other kinds of collections you will use all the time when 
 programming Scala are sets and maps. Sets and maps have a fast 
 lookup algorithm, so they can quickly decide whether or not an object 
 is in the collection. 
 It is easiest to explain using an example. Start by importing the 
 pack-age
  scala.collection.mutable
 , so you have easy access to the relevant 
 classes. 
 scala> import scala.collection.mutable
  
 import scala.collection.mutable
  
 Now you can create a new set using the
  empty
  method: 
 scala> val words = mutable.Set.empty[String]
  
 words: scala.collection.mutable.Set[String] = Set()
  
 Note that you have to supply the type of objects this set will hold, 
 which in this example is
  String
 . You can then add elements to the set 
 using the
  += 
 method. 
 scala> words += ""hello""
  
 scala> words += ""there""
  
 scala> words += ""there""
  
 scala> words
  
 res21: scala.collection.mutable.Set[String] = Set(there,
  
 hello)
  
 Note that if an element is already included in the set, then it is not 
 added a second time. That is why
  ""there""
  only appears one time in the
  
 words
  set even though it was added twice. 
 As a longer example, you can use a set to count the number of 
 differ-ent words in a string. The
  split
  method can separate the string 
 into words, 
 Prepared for jacques 
 weiss
  
 if you specify spaces and punctuation as word separators. The regular 
 ex-pression
  [ !,.]+
  suffices: it indicates one or more space and/or 
 punctuation characters. 
 scala> val text = ""See Spot run.
  
 Run, Spot, Run!""",NA
15.5 ,NA,NA
Initializing collections,"You have already seen the syntax
  List(1,2,3)
  for creating a list with its 
 contents specified immediately. This notation works for sets and maps 
 as well. You leave off a
  new
  statement and then put the initial contents 
 in paren-theses. Here are a few examples: 
 scala> List(1,2,3)
  
 res30: List[Int] = List(1, 2, 3)
  
 scala> mutable.Set(1,2,3)
  
 res31: scala.collection.mutable.Set[Int] = Set(3, 1, 2)
  
 scala> mutable.Map(1->""hi"", 2->""there"")
  
 res32: scala.collection.mutable.Map[Int,java.lang.String] =",NA
15.6,NA,NA
Immutable collections,"Scala provides immutable versions of all of its collection types. These 
 ver-sions cannot be changed after they are initialized. You should use 
 them 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
15.7 ,NA,NA
Conclusion,"This chapter has shown you the most important kinds of Scala 
 collections. While you can get by if you simply use arrays for 
 everything, it is worth learning, over time, the map, set, and tuple 
 classes. Using the right class at the right time can make your code 
 shorter and cleaner. As you do so, keep an eye out for chances to use 
 immutable equivalents of the collection classes you choose. They can 
 make your code just a little more clean and easy to work with.",NA
Chapter 16,NA,NA
Stateful Objects,"Previous chapters have put the spotlight on functional objects. They 
 have done that because the idea of objects without any mutable state 
 deserves to be better known. However, it is also perfectly possible to 
 define objects with mutable state in Scala. Such stateful objects often 
 come up naturally when one wants to model objects in the real world 
 that change over time. 
 This chapter explains what stateful objects are, and what Scala 
 provides in term of syntax to express them. The second part of this 
 chapter also in-troduces a larger case study on discrete event 
 simulation, which is one of the application areas where stateful objects 
 arise naturally.",NA
16.1 ,NA,NA
What makes an object stateful?,"The principal difference between a purely functional object and a 
 stateful object can be observed even without looking at the object’s 
 implementation. When you invoke a method or dereference a field on 
 some purely functional object, you will always get the same result. For 
 instance, given a list of characters 
 val cs = List('a', 'b', 'c')",NA
16.2 ,NA,NA
Reassignable variables and properties,"There are two fundamental operations on a reassignable variable: you 
 can get its value or you can set it to a new value. In libraries such as 
 JavaBeans, these operations are often encapsulated in separate getter 
 and setter methods which need to be defined explicitly. In Scala, every 
 variable which is a non-private member of some object implicitly 
 defines a getter and a setter method with it. These getters and setters 
 are named differently from their Java conventions, however. The 
 getter of a variable
  x
  is just named
  x
 , while its setter is named 
 x_=
 . 
 For example, if it appears in a class, the variable definition 
 var hour: Int = 12
  
 generates a getter
  hour
  and setter
  hour_=
  in addition to a reassignable 
 field. The field is always marked
  private[this]
 , which means it can be 
 accessed only from the object that contains it. The getter and setter, on 
 the other hand,",NA
16.3 ,NA,NA
Case study: discrete event simulation,"The rest of this chapter shows by way of an extended example how 
 stateful objects can be combined with first-class function values in 
 interesting ways. You’ll see the design and implementation of a 
 simulator for digital circuits. This task is decomposed into several 
 subproblems, each of which is interest-ing individually: First, you’ll be 
 presented a simple but general framework for discrete event 
 simulation. The main task of this framework is to keep track of actions 
 that are performed in simulated time. Second, you’ll learn how 
 discrete simulation programs are structured and built. The idea of 
 such simulations is to model physical objects by simulated objects, and 
 to use the simulation framework to model physical time. Finally, you’ll 
 see a little do-main specific language for digital circuits. The definition 
 of this language highlights a general method for embedding domain-
 specific languages in a host language like Scala. 
 The basic example is taken from the classic textbook “Structure and",NA
16.4 ,NA,NA
A language for digital circuits,"Let’s start with a little language to describe digital circuits. A digital 
 circuit is built from
  wires
  and
  function boxes
 . Wires carry
  signals
  which 
 are trans-formed by function boxes. Signals will be represented by 
 booleans:
  true 
 for signal-on and
  false
  for signal-off. 
 Figure 16.1
  shows three basic function boxes (or:
  gates
 ): 
 • An
  inverter
 , which negates its signal 
 • An
  and-gate
 , which sets its output to the conjunction of its input. 
 • An
  or-gate
 , which sets its output to the disjunction of its input. 
 These gates are sufficient to build all other function boxes. Gates have
  
 de-lays
 , so an output of a gate will change only some time after its 
 inputs change. 
  
 We describe the elements of a digital circuit by the following set of 
 Scala classes and functions. 
 First, there is a class
  Wire
  for wires. We can construct wires as follows.",NA
16.5,"Chapter 16 · Stateful Objects
  
 352",NA
The,Simulation,NA
 API,"The simulation API is shown in
  Figure 16.4
 . It consists of class
  Simulation
  
 in package
  simulator
 . Concrete simulation libraries inherit this class 
 and augment it with domain-specific functionality.  The elements of the 
 Simulation
  class are presented in the following. 
 Discrete event simulation performs user-defined
  actions
  at 
 specified 
 times
 . The actions, which are defined by concrete simulation 
 subclasses, all share a common type: 
 type Action = () => Unit
  
 The definition above defines
  Action
  to be an alias of the type of 
 procedures that take an empty parameter list and that return
  Unit
 . 
 The time at which an action is performed is simulated time; it has 
 nothing to do with the actual “wall-clock” time. Simulated times are 
 represented simply as integers. The current simulated time is kept in a 
 private variable 
 private var curtime: Int = 0
  
 The variable has a public accessor method which retrieves the current time: 
 def currentTime: Int = curtime
  
 This combination of private variable with public accessor is used to 
 make sure that the current time cannot be modified outside the
  
 Simulation
  class. 
  
 An action which is to be executed at a specified time is called a
  work 
 item
 . Work items are implemented by the following class: 
 case class WorkItem(time: Int, action: Action)
  
 The
  WorkItem
  class is made a case class because of the syntactic conve-
 niences this entails: you can use the factory method
  WorkItem
  to create 
 instances of the class and you get accessors for the constructor 
 parameters 
 time
  and
  action
  for free. Note also that class
  WorkItem
  is 
 nested inside",NA
16.6 ,NA,NA
Circuit Simulation,"The next step is to use the simulation framework to implement the 
 domain-specific language for circuits. Recall that the circuit DSL 
 consists of a class for wires and methods that create and-gates, or-
 gates, 
 and 
 inverters. 
 These 
 are 
 all 
 contained 
 in 
 a 
 class
  
 BasicCircuitSimulation
  which extends the simulation framework. Here’s 
 an outline of this class: 
 abstract class BasicCircuitSimulation extends Simulation { def InverterDelay: Int 
  
 def AndGateDelay: Int 
  
 def OrGateDelay: Int 
  
 class Wire { ... } 
  
 def inverter(input: Wire, output: Wire) {...} 
  
 def andGate(a1: Wire, a2: Wire, output: Wire) {...} def orGate(o1: Wire, o2: Wire, 
 output: Wire) {...} 
  
 def probe(name: String, wire: Wire) {...}
  
 Prepared for jacques weiss
  
 }
  
 The class declares three abstract methods
  InverterDelay
 ,
  AndGateDelay 
 and
  OrGateDelay
  which represent the delays of the basic gates. The 
 actual delays are not known at the level of this class because they 
 would depend on 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
16.7 ,NA,NA
Conclusion,"This chapter has brought together two techniques that seem at first 
 disparate: mutable state and higher-order functions. Mutable state 
 was used to simulate physical entities whose state changes over time. 
 Higher-order functions were used in the simulation framework to 
 execute actions at specified points in simulated time. They were also 
 used in the circuit simulations as
  triggers
  that associate actions with 
 state changes. On the side, you have seen a simple way to define a 
 domain-specific language as a library. That’s probably enough for one 
 chapter! If you feel like staying a bit longer, maybe you want to try 
 more simulation examples. You can combine half-adders and full-
 adders to create larger circuits, or design new circuits from the basic 
 gates defined so far and simulate them.",NA
Chapter 17,NA,NA
Type Parameterization,"This chapter explains some of the techniques for information hiding 
 intro-duced in
  Chapter 13
  by means of concrete example: the design of 
 a class for purely functional queues. It also explains type parameter 
 variance as a new concept. There are some links between the two 
 concepts in that infor-mation hiding may be used to obtain more 
 general type parameter variance annotations – that’s why they are 
 presented together. 
 The chapter contains three parts. The first part develops a data 
 structure for purely functional queues, which is interesting in its own 
 right. The sec-ond part develops techniques to hide internal 
 representation details of this structure. The final part explains 
 variance of type parameters and how it interacts with information 
 hiding.",NA
17.1 ,NA,NA
Functional queues,"A functional queue is a data structure with three operations. 
 head
  returns the first element of the queue 
 tail
  returns a queue without its first element",NA
17.2,NA,NA
Information hiding,NA,NA
17.3,NA,NA
Variance annotations,"The combination of type parameters and subtyping poses some interest- 
 ing questions. 
 For instance, should
  Queue[String]
  be a subtype of 
 Queue[AnyRef]
 ? Intuitively, this seems OK, since a queue of
  String
 s is a 
 special case of a queue of
  AnyRef
 s. More generally, if
  T
  is a subtype of 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
17.4 ,NA,NA
Lower bounds,"Back to the
  Queue
  class.  
 You have seen that the previous definition of 
 Queue[T]
  cannot be made covariant in
  T
  because
  T
  appears as parameter 
 type of the
  append
  method, and that’s a contravariant position. 
  
 However, it’s possible to generalize the
  append
  method using a lower 
 bound: 
 class Queue[+T] {
  
 def append[U >: T](x: U) =
  
 new Queue(leading, x :: trailing)
  
 ...",NA
17.5 ,NA,NA
Contravariance,"So far, all types were either covariant or nonvariant. But there are also 
 cases where contravariance is natural. For instance, consider the 
 following trait of output channels:",NA
17.6,NA,NA
Object-local data,NA,NA
17.7 ,NA,NA
Conclusion,"In this chapter you have seen several techniques for information 
 hiding: Pri-vate constructors, factory methods, type abstraction, and 
 object-local mem-",NA
Chapter 18,NA,NA
Abstract Members and Properties,"A member of a class or trait is
  abstract
  if the member does not have a 
 com-plete definition in the class. Abstract members are supposed to 
 be imple-mented in subclasses of the class in which they are defined. 
 This idea is found in many object-oriented languages. For instance, 
 Java lets you declare abstract methods. Scala also lets you declare such 
 methods, as you have seen in chapter
  10
 . But it goes beyond that and 
 implements the idea in its full generality—besides methods you can 
 also define abstract fields and even abstract types. 
 An example is the following trait
  Abstract
  which defines an abstract 
 type
  T
 , an abstract method
  transform
 , an abstract value
  initial
 , and an 
 abstract variable
  current
 . 
 trait Abstract {
  
 type T
  
 def transform(x: T): T
  
 val initial: T
  
 var current: T
  
 }
  
 A concrete implementation of
  Abs
  needs to fill in definitions for each of its 
 Prepared for jacques weiss
  
 abstract members. Here is an example implementation that provides 
 these definitions. 
 class Concrete extends Abstract {
  
 type T = String
  
 def transform(x: String) = x + x
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
18.1 ,NA,NA
Abstract,val,NA
s,"An abstract
  val
  definition has a form like 
 val initial: String
  
 It gives a name and type for a
  val
 , but not its value. This value has to be 
 provided by a concrete value definition in a subclass. For instance, 
 class 
 Concrete
  implemented the value using 
 val initial = ""hi""
  
 You use an abstract value definition in a class when you do not know 
 the correct value in the class, but you do know that the variable will 
 have an unchangeable value in each instance of the class. 
  
 An abstract value definition resembles an abstract parameterless 
 method definition such as 
 def initial: String
  
 Client code refers to both the value and the method in exactly the same 
 way, i.e. 
 obj.initial
 . However, if
  initial
  is an abstract value, the client is 
 guaranteed that
  obj.initial
  will yield the same value everytime it is",NA
18.2 ,NA,NA
Abstract,var,NA
s,"Like an abstract
  val
 , an abstract
  var
  defines just a name and a type, but 
 not an initial value. For instance, here is a class
  AbstractTime
  which 
 defines two abstract variables named
  hour
  and
  minute
 . 
 trait AbstractTime { 
  
  
 var hour: Int 
  
  
 var minute: Int 
  
 }
  
 Prepared for jacques weiss
  
 What should be the meaning of an abstract
  var
  like
  hour
  or
  minute
 ? You 
 have seen in
  Chapter 16
  that
  var
 s that are members of classes come 
 equipped with getter and setter methods. This holds for concrete as 
 well as abstract variables. If you define an abstract
  var x
 , you implicitly 
 define a getter 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
18.3 ,NA,NA
Abstract,type,NA
s,"In the beginning of this chapter you saw an abstract type declaration 
 type T
  
 The rest of this chapter discusses what such an abstract type 
 declaration means and what it’s good for. Like all other abstract 
 declarations this is a placeholder for something that will be defined 
 concretely in subclasses. In this case, it is a type that will be defined 
 further down the class hierarchy. So 
 T
  above refers to a type that is at 
 yet unknown at the point where it is defined. Different subclasses can 
 provide different realizations of
  T
 . 
 Here is a well-known example where abstract types show up 
 naturally. Suppose you are given the task to model eating habits of 
 animals. You might start with a class
  Food
  and a class
  Animal
  with an
  eat
  
 method: 
 class Food {}
  
 abstract class Animal {
  
 def eat(food: Food)",NA
Path-dependent types,"Have a look at the last error message: What’s interesting about it is the 
 type required by the
  eat
  method:
  cow.SuitableFood
 . This type consists of 
 an object reference (
 cow
 ) which is followed by a type field
  SuitableFood
  
 of 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
18.4,NA,NA
Case study: Currencies,NA,NA
18.5 ,NA,NA
Conclusion,"Scala offers systematic and very general support for object-oriented 
 abstrac-tion: It enables you to not only abstract over methods, but also 
 to abstract over values, variables, and types. This chapter has shown 
 how to make use of abstract members. You have seen that they 
 support a simple yet effective principle for systems structuring: When 
 designing a class make everything which is not yet known at the level 
 of a class into an abstract member. This principle applies to all sorts of 
 members: methods and variables as well as types. 
 The chapter has also shown how variables which are members of 
 some class come equipped with setters and getters. You have seen 
 how these get-ters and setters can be used to implement properties.",NA
Chapter 19,NA,NA
Implicit Conversions and Parameters,"There’s a fundamental difference between your own code and 
 libraries of other people: You can change or extend your own code as 
 you wish, but if you want to use someone else’s libraries you usually 
 have to take them as they are. 
 A number of constructs have sprung up in programming languages 
 to alleviate this problem. Ruby has modules, and Smalltalk lets 
 packages add to each other’s classes. These are very powerful, but also 
 dangerous, in that you modify the behavior of a class for an entire 
 application, some parts of which you might not know. C# 3.0 has static 
 extensions methods, which are more local, but also more restrictive in 
 that you can only add methods, not fields or interfaces to a class. 
 Scala has implicit parameters and conversions. They can make 
 existing libraries much more pleasant to deal with by letting you leave 
 out tedious code that is more obvious than useful. Used tastefully, this 
 results in code that is focused on the interesting, non-trivial parts of 
 your program. This chapter shows you how implicits work, and 
 presents some of the most com-mon ways they are used. 
 Prepared for jacques weiss",NA
19.1,NA,NA
Implicit conversions,"Here’s a first example. 
 One of the central collection traits in Scala is 
 RandomAccessSeq[T]
 , which describes random access sequences over el-
 ements of type
  T
 .
  RandomAccessSeq
 s have most of the utility methods 
 which you know from arrays or lists:
  take
 ,
  drop
 ,
  map
 ,
  filter
 ,
  exists
 , 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
19.2,"Chapter 19 · Implicit Conversions and Parameters
  
 399",NA
The fine print,"Implicit definitions are those that the compiler is allowed to insert into 
 a program in order to fix any of its type errors. For example, if
  x + y
  
 does not type check, then the compiler might change it to
  convert(x) + y
 . 
 If 
 convert
  changes
  x
  into something that has a
  +
  method, then this 
 change might fix a program so that it type checks and runs correctly. If
  
 convert 
 really is just a simple conversion function, then leaving it out of 
 the source code can be a clarification. 
 Implicit conversions are governed by the following general rules. 
 Marking Rule: Only definitions marked
  implicit
  are available. 
  
 The 
 implicit
  keyword is used to mark which declarations the compiler may 
 use as implicits. You can use it to mark any variable, function, or object 
 definition, just like this: 
 implicit def int2string(x: Int) = x.toString
  
 The compiler will only change
  x + y
  to
  convert(x) + y
  if
  convert
  is marked 
 as
  implicit
 . This way, you avoid the confusion that would result if the 
 compiler picked random functions that happen to be in scope and 
 inserted them as “conversions.” The compiler will only select among 
 the things you have explicitly marked as conversions. 
 Scope Rule: An inserted implicit conversion must be a single 
 identifier or be associated with the source or target type of the 
 conversion. 
  
 The 
 compiler will usually not insert a conversion of the form
  foo.convert
 . It 
 will not expand
  x + y
  to
  foo.convert(x) + y
 . Any conversion must be 
 available in the current scope via a single identifier. If you want to 
 make 
 foo.convert
  available as an implicit, then you need to import it. In 
 fact, it is common for libraries to include a
  Preamble
  object including a 
 number of useful implicit conversions. Code that uses the library can 
 then do a single 
 insert Preamble._
  to access the library’s implicit 
 conversions.",NA
19.3,"Chapter 19 · Implicit Conversions and Parameters
  
 403",NA
Implicit conversion to an expected type,"Implicit conversions to an expected type are the first place that the 
 compiler will use implicits. The rule is simple. Whenever the compiler 
 sees an X, but needs a Y, it will look for an implicit function that 
 converts X’s to Y’s. For example, normally a double cannot used as an 
 integer, because it loses precision: 
 scala> val i: Int = 3.5
  
 <console>:8: error: type mismatch;
  
 found : Double(3.5)
  
 required: Int
  
 val i: Int = 3.5
  
 ˆ
  
 However, you can define an implicit conversion to smooth this over: 
 scala> implicit def double2int(x: Double) = x.toInt
  
 double2int: (Double)Int
  
 scala> val i: Int = 3.5
  
 i: Int = 3
  
 What happens here is that the compiler sees a double, specifically
  3.5
 , 
 in a context where it requires an integer. Before giving up, it searches 
 for an implicit conversion from doubles to integers. In this case, it 
 finds one: 
 double2int
 . It then inserts a call to
  double2int
  automatically. 
 Behind the scenes, the code becomes: 
 val i: Int = double2int(3.5)
  
 This is literally an
  implicit
  conversion. The programmer does not 
 explicitly ask for conversion. Instead, you mark
  double2int
  as an 
 available implicit conversion, and then the compiler automatically 
 uses it wherever it needs to convert from a double to an integer. 
 Prepared for jacques weiss",NA
19.4,NA,NA
Converting the receiver,"Implicit conversions also apply to the receiver of a method call, giving 
 two major applications that might not be obvious. These receiver 
 conversions 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
19.5 ,NA,NA
Implicit parameters,"The other place the compiler inserts implicits is within parameter lists. 
 The compiler will sometimes replace
  foo(x)
  with
  foo(x)(y)
 , or
  new Foo(x) 
 with
  new Foo(x)(y)
 , thus adding a missing parameter list to complete a 
 function call.  
 For this usage, not only must the inserted identifier 
 (
 y
 ) be marked
  implicit
 , but also the formal parameter list in
  foo
 ’s or 
 Foo's 
 definition be marked as
  \
 implicit@. Here is a simple example. The 
 following
  printSomething
  function prints whatever its argument is. 
 scala> def printSomething(implicit x: Int) = println(x)
  
 printSomething: (implicit Int)Unit
  
 This function can be called just like any other function:",NA
19.6 ,NA,NA
View bounds,"The previous example had an opportunity to use an implicit but did 
 not. Note that when you use
  implicit
  on a parameter, then not only will 
 the compiler",NA
19.7 ,NA,NA
Debugging implicits,"Implicits are an extremely powerful feature in Scala, but one which is 
 some-times difficult to get right and debug. So you should use implicits 
 with mod-eration. Before adding a new implicit conversion, you 
 should ask youself whether you can achieve the same effect through 
 other means, such as inher-itance, mixin composition or method 
 overloading. Only when these fail are implicits warranted. 
 Sometimes you might wonder why the compiler did not find an 
 implicit conversion which you think should apply. In that case it helps 
 writing the conversion out explicitly. If that also gives an error 
 message, you then know why the compiler could not apply your 
 implicit. For instance, assume that you mistakenly took
  stringWrapper
  to 
 be a conversion from
  String
 s to 
 List
 s, instead of
  RandomAccessSeq
 s. So you 
 would wonder why the fol-lowing scenario does not work: 
 scala> val chars: List[Char] = ""xyz""
  
 <console>:7: error: type mismatch;
  
 Pre
 par
 ed 
 for 
 jac
 que
 s 
 wei
 ss
  
 found
  
 : java.lang.String(""xyz"")",NA
Chapter 20,NA,NA
Implementing Lists,"Lists have been ubiquitous in this book. Class
  List
  is probably the most 
 commonly used structured data type in the majority of Scala 
 programs. This chapter “opens up the covers” and explains a bit how 
 lists are implemented in Scala. Knowing the internals of the
  List
  class is 
 useful for several rea-sons: You gain a better idea of the relative 
 efficiency of list operations, which will help you in writing fast and 
 compact code using lists. You also learn a toolbox of techniques that 
 you can apply in the design of your own libraries. Finally, the
  List
  class 
 is a sophisticated application of Scala’s type system in general and its 
 generics concepts in particular. So studying class
  List
  will deepen your 
 knowledge in these areas.",NA
20.1 ,NA,NA
The,List,NA
 class in principle,"Lists are not “built-in” as a language construct in Scala; they are 
 defined by an abstract class
  List
  in the
  scala
  package, which comes with 
 two sub-classes for ‘
 ::
 ’ and
  Nil
 . In the following we present a quick tour 
 through class
  List
 . This section presents a somewhat simplified account 
 of the class, compared to its real implementation in the Scala standard 
 library, which is covered in
  Section 20.3
 .",NA
20.2 ,NA,NA
The,ListBuffer,NA
 class,"The typical access pattern for a list is recursive. For instance, to 
 increment every element of a list without using
  map
  we could write: 
 def incAll(xs: List[Int]): List[Int] = xs match {
  
 case List() => List()
  
 case x :: xs1 => x + 1 :: incAll(xs1)
  
 }
  
 One shortcoming of this program pattern is that it is not tail-recursive. Note",NA
20.3,"Chapter 20 · Implementing Lists
  
 420",NA
The,List,NA
 class in practice,"The implementations of list methods given in
  Section 20.1
  are concise 
 and clear, but suffer from the same stack overflow problem as the non-
 tail re-cursive implementatiom of
  incAll
 . Therefore, most methods in 
 the real implementation of class
  List
  avoid recursion and use loops 
 with list buffers instead. For example, here is the real implementation 
 of
  map
  in class
  List
 : 
 final override def map[U](f: T => U): List[U] = {
  
 val b = new ListBuffer[U]
  
 var these = this
  
 while (!these.isEmpty) {
  
 b += f(these.head)
  
 these = these.tail
  
 }
  
 b.toList
  
 }
  
 This revised implementation traverses the list with a simple loop, 
 which is highly efficient. A tail recursive implementation would be 
 similarly efficient, but a general recursive implementation would be 
 slower and less scalable. But what about the operation
  b.toList
  at the 
 end? What is its complexity? In fact, the call to the
  toList
  method takes 
 only a small number of cycles, which is independent of the length of 
 the list. 
 To understand why, take a second look at class ‘
 ::
 ’ which constructs 
 non-empty lists. In practice, this class does not quite correspond to its 
 ideal-ized definition given previously in
  Section 20.1
 . There’s one 
 peculiarity: 
 final case class ::[U](hd: U,
  
 private[scala] var tl: List[U])
  
 extends List[U] {
  
 def head = hd
  
 def tail = tl",NA
20.4 ,NA,NA
Conclusion,"This section has shown key elements of the implementation of Scala’s
  
 List 
 and
  ListBuffer
  classes. You have seen that lists are purely functional 
 “at the outside” but have an imperative implementation using list 
 buffers “in-side”. This is a typical strategy in Scala programming: 
 trying to combine purity with efficiency by carefully delimiting the 
 effects of impure opera-tions. You might ask, why insist on purity? 
 Why not just open up the defini-tion of lists, making the
  tail
  field, and 
 maybe also the
  head
  field, mutable? The disadvantage of such an 
 approach is that it would make programs much more fragile. Note that 
 constructing lists with ‘
 ::
 ’ re-uses the tail of the",NA
Chapter 21,NA,NA
Object Equality,"Comparing two values for equality is ubiquitous in programming. It is 
 also more tricky than it looks at first glance. This chapter studies 
 object equality in detail and gives some recommendations to consider 
 when you design your own equality tests. 
 The definition of equality is different in Scala and Java. Java knows 
 two equality methods: ‘
 ==
 ’, which is the natural equality for value 
 types and object identity for reference types, and
  equals
  which is (user-
 defined) canonical equality for reference types. This convention is 
 problematic, be-cause the more natural symbol ‘
 ==
 ’ does not always 
 correspond to the natural notion of equality. When programming in 
 Java, one of the most frequently encountered pitfalls is to compare 
 objects with ‘
 ==
 ’ when they should have been compared with
  equals
 . 
 For instance, comparing two strings
  x
  and
  y 
 using
  (x == y)
  might well 
 yield
  false
  in Java, even if
  x
  and
  y
  are the same, meaning they consist of 
 exactly the same characters in the same order. 
 Scala also has an equality like ‘
 ==
 ’ in Java, but it is written
  eq
 .
  (x eq y) 
 is true if
  x
  and
  y
  reference the same object, or if
  x
  and
  y
  are the same 
 prim-itive value. The ‘
 ==
 ’ equality is reserved in Scala for the “natural” 
 equality of each type. For value types, ‘
 ==
 ’ is the same as
  eq
 . For 
 reference types,‘
 ==
 ’ is the same as
  equals
 . You can redefine the behavior 
 of ‘
 ==
 ’ for new",NA
21.1 ,NA,NA
Writing an equality method,"How should the
  equals
  method be defined? It turns out that writing a 
 correct equality method is surprisingly difficult in object-oriented 
 languages. Man-dana Vaziri and Frank Tip have recently done a study 
 of a large body of Java code, and concluded that almost all 
 implementations of
  equals
  methods are faulty. 
 This is problematic, because equality is at the basis of many other 
 things. For one, a faulty equality method for a type
  C
  might mean that 
 you cannot reliably put an object of type
  C
  in a collection. You might 
 have two elements 
 elem1
 ,
  elem2
  of type
  C
  which are equal,
  i.e.
  (elem1 
 equals elem2)
  yields 
 true
 . Nevertheless, with commonly occurring faulty 
 implementations of the 
 equals
  method you could still see behavior like 
 the following: 
 val set = new collection.immutable.HashSet
  
 set += elem1
  
 set get elem2 
  
 // returns None!
  
 Here are four common pitfalls that can cause inconsistent behavior of 
 equals
 . 
 1. Defining
  equals
  with the wrong signature. 
 2. Changing
  equals
  without also changing
  hashCode
 . 
 3. Defining
  equals
  in terms of mutable fields 
 4. Failing to define
  equals
  as an equivalence relation.",NA
Chapter 22,NA,NA
Working with XML,"This chapter introduces Scala’s support for XML. After discussing 
 semi-structured data in general, it shows the essential functionality in 
 Scala for manipulating XML: how to make nodes with XML literals, 
 how to save and load XML to files, and how to take apart XML nodes by 
 using query methods and by using pattern matching. This chapter is 
 just a brief introduction to what is possible with XML, but it shows 
 enough to get you started.",NA
22.1 ,NA,NA
Semi-structured data,"XML is a form of
  semi-structured data
 . It is more structured than plain 
 strings, because it organizes the contents of the data into a tree. With 
 XML, you can always take two fragments and combine them as part of 
 a new node. Later you can take those two apart and reliably get the 
 same two nodes again. With strings there are no such operations, so 
 you must design delimiters and escapes yourself. 
 Semi-structured data is very helpful any time you need to serialize 
 pro-gram data for saving in a file or shipping across a network. It 
 provides enough structure that it is easier to parse and to produce 
 than plain strings. Additionally, it is more flexible than raw object data, 
 because if the data",NA
22.2 ,NA,NA
Creating XML,"You can type an XML node anywhere that an expression is valid. 
 Simply type an open tag and then continue writing XML content. When 
 the compiler sees the last close tag, it will go back to reading arbitrary 
 Scala code. 
 scala> <a>
  
 | This is some XML.
  
 | Here is a tag: <atag/>
  
 | </a>
  
 res0: scala.xml.Elem =
  
 <a>
  
 This is some XML.
  
 Here is a tag: <atag></atag>
  
 </a>
  
 The result of this expression is of type Elem, meaning it is an XML 
 node that has a label (“a”) and children (“This is some XML,”
  etc.
 ). 
 Some other important XML classes are: 
 • Class Node is the abstract superclass of all XML node classes. 
 • Class Text is a node holding just text. 
  
 <a>stuff</a>
  is of class Text. 
 The “stuff” part of",NA
22.3 ,NA,NA
Taking XML apart,"Among the many methods available for the XML classes, there are 
 three of them that you should particularly be aware of. They allow you 
 to take apart XML without thinking too much about the precise way 
 XML is represented 
 Prepared for jacques weiss
  
 in Scala. 
 Extracting text.
  Send
  text
  to any XML node to retrieve all of the text 
 within that node, minus any element tags. 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
22.4,NA,NA
Loading and saving,"Converting XML to and from in-memory data structures is only half of 
 the conversion needed to use XML as an interchange format. You also 
 need to convert the XML to a sequence of bytes that can be saved to a 
 file or sent 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
22.5 ,NA,NA
Pattern matching,"So far you have seen how to dissect XML using the XPath-like
  text
 ,
  \
 , 
 and 
 \\
  methods. These are good when you know exactly what kind of 
 XML structure you are taking apart. Sometimes, though, there are a 
 few possible structures the XML could have. Maybe there are multiple 
 kinds of records within the data, for example because you have 
 extended your thermometer collection to include clocks and sandwich 
 plates. Maybe you simply want to skip over any white space between 
 tags. Whatever the reason, you can use the pattern matcher to sift 
 through the possibilities. 
 An XML pattern looks just like an XML literal. The main difference 
 is that if you insert a
  {}
  escape, then the code inside the
  {}
  is not an 
 expression but a pattern! A pattern embedded in
  {}
  can use the full 
 Scala pattern lan-guage, including binding new variables, performing 
 type tests, and ignoring content using the
  _
  and
  _*
  patterns. 
 Here is a simple example to give the idea. 
 scala> <a>blahblah</a> match {
  
 |
  
 case <a>{contents}</a>
  
 =>
  
 ""yes! "" + contents
  
 |
  
 case _ => ""no! ""
  
 | }
  
 res15: java.lang.String = yes! blahblah
  
 In the “yes” case, the pattern checks for an
  <a>
  tag with a single element. 
 It then binds that element to a new variable named
  cont
 . This code is 
 probably",NA
22.6,"Chapter 22 · Working with XML
  
 449",NA
Conclusion,"This chapter has only scratched the surface of what you can do with 
 XML. There are a multitude of tools that work with XML, some 
 customized for Scala, some for Java, and others not dependent on any 
 specific programming language. 
 What you should walk away with is how to use semi-structured 
 data for interchange purposes, and how to use Scala’s support for XML 
 as semi-structured data. With Scala, you can create XML using XML 
 literals, take it apart using three simple methods, sift through it using 
 pattern matching, and save and load it using fully automatic routines. 
 Prepared for jacques weiss
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Chapter 23,NA,NA
Actors and Concurrency,NA,NA
23.1 ,NA,NA
Overview,"Sometimes it helps in designing a program to specify that certain 
 things hap-pen independently, in parallel. Java includes support for 
 these notions, most notably its threads and locks. This support is 
 sufficient, but it turns out to have problems in practice as programs 
 get larger and more complex. 
 Scala augments Java’s native support by adding
  actors
 . Actors 
 avoid a lot of the problems with threads and locks by providing a safe 
 message-passing system. If you can design your program in an actors 
 style, then you will avoid the deadlocks and race conditions of Java’s 
 native concurrency support. This chapter shows you how.",NA
23.2 ,NA,NA
Locks considered harmful,"Java provides threads and locks and monitors, so you might ask, why 
 not use Java’s support directly? 
  
 As a Scala programmer, you are certainly free to use Java’s 
 concurrency constructs. Java provides you independent threads, locks, 
 and monitors. Your strategy would then be to hold a lock (or enter a 
 monitor) whenever",NA
23.3 ,NA,NA
Actors and message passing,"An actor is a kind of thread that has a mailbox for receiving messages. 
 To im-plement an actor, subclass
  scala.actors.Actor
  and implement an
  
 act() 
 method. 
 import scala.actors._
  
 object sillyActor extends Actor {
  
 def act() {
  
 for (i <- 1 to 5) {
  
 println(""I'm acting!"")
  
 Thread.sleep(1000)
  
 }
  
 }
  
 }
  
 Prepared for jacques weiss
  
 An actor can then be started with the
  start()
  method, just as if it were a 
 normal Java thread: 
 scala> sillyActor.start()
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
23.4 ,NA,NA
Treating native threads as actors,"The actor subsystem manages one or more native threads for its own 
 use. So long as you work with an explicit actor that you define, you do 
 not need to think much about how they map to threads. 
 The other direction is also supported by the subsystem: Every 
 native thread is also usable as an actor. However, you cannot use
  
 Thread.current 
 directly, because it does not have the necessary methods. 
 Instead, you should access
  Actor.self
  if you want to view the current 
 thread as an actor. 
  
 This facility is especially useful for debugging actors from the 
 interactive shell. 
 scala> import scala.actors._
  
 import scala.actors._
  
 scala> Actor.self ! ""hello""
  
 scala> Actor.self.receive { case x => x }
  
 res1: Any = hello
  
 scala>
  
 If you use this technique, it is better to use a timeout of
  0
  so that your 
 shell does not block forever. 
 scala> Actor.self.receiveWithin(0) { case x => x }
  
 res2: Any = TIMEOUT
  
 scala>
  
 Prepared for jacques weiss
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
23.5,"Chapter 23 · Actors and Concurrency
  
 455",NA
Tips for better actors,"At this point you have seen everything you need to write your own 
 actors. Consider a few tips, though on how to make those programs 
 shorter and easier to write. 
 Sharing threads with event-based actors
  
 Actors are implemented on top of normal Java threads. As described 
 so far, in fact, every actor must be given its own thread, so that all the
  
 act() 
 methods get their turn. 
 Unfortunately, threads are not cheap in Java. Threads use enough 
 mem-ory that typical Java virtual machines can have millions of 
 objects but only a couple of thousands of threads. Worse, switching 
 threads often takes hun-dreds if not thousands of processor cycles. If 
 you want your program be as efficient as possible, then it is important 
 to be sparing with thread creation and thread switching. 
 To help you with this task, Scala provides an alternative to the 
 usual 
 receive
  method called
  react
 . Unlike
  receive
 ,
  react
  does not return im-
 mediately to the caller. Instead, it evaluates the message handler and 
 then terminates the actor. Thus, the message handler you pass to
  react
  
 must not only process that message, but arrange to do all of the actor’s 
 remaining work! 
 This remaining work can often be accomplished by arranging to 
 have a top-level work method that the message handler calls when it 
 finishes. Do not worry about the apparent infinite recursion; the 
 actors system clears an actor’s stack every time it calls
  react
 . Here is an 
 example of using this approach. 
 object NameResolver extends Actor {
  
 import java.net.{InetAddress, UnknownHostException}
  
 def act() {
  
 Prepared for jacques weiss
  
 react { 
  
 case (name: String, actor: Actor) => 
  
 actor ! 
 getip(name) 
  
  
 act() 
  
 case msg =>
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
Chapter 24,NA,NA
Extractors,"By now you have probably grown accustomed to the concise way data 
 can be decomposed and analyzed using pattern matching. This chapter 
 shows you how to generalize this concept further. Until now, 
 constructor patterns were linked to case classes. For instance,
  Some(x)
  
 is a valid pattern because
  x
  is a case class. Sometimes you might wish 
 that you can write patterns like this without creating an associated 
 case class. In fact, you might wish to be able to create your own kinds 
 of patterns. Extractors give you a way to do this. 
  
 This chapter explains what extractors are and how you can use 
 them to define patterns that are decoupled from an object’s 
 representation.",NA
24.1 ,NA,NA
An Example,"Say you want to analyze strings that represent e-mail addresses. Given 
 a string, you want to decide whether it is an e-mail address or not, and, 
 if it is one, you want to access the user and domain parts of the 
 address. The traditional way to do this uses three helper functions: 
 def isEMail(s: String): Boolean
  
 def domain(s: String): String",NA
24.2,NA,NA
Extractors,"Chapter 24 · Extractors
  
 463 
 An extractor in Scala is an object that has a method called
  unapply
  as 
 one of its members. The purpose of that
  unapply
  method is to match a 
 value and take it apart. Often, the extractor object also defines a dual 
 method
  apply
  for building values, but this is not required. As an 
 example, here is an extractor object for e-mail addresses: 
 /** An extractor object */ 
  
 object EMail {
  
 /** The injection method (optional) */ 
  
 def apply(user: String, domain: String) = user+""@""+domain
  
 /** The extraction method (mandatory) */ 
  
 def unapply(email: String): Option[(String, String)] = {
  
 val parts = email split ""@""
  
 if (parts.length == 2) Some(parts(0), parts(1)) else None
  
 }
  
 }
  
 This object defines both
  apply
  and
  unapply
  methods. The
  apply
  method 
 has the same meaning as always:  
 It turns
  EMail
  into a function ob-ject. 
 So you can write
  EMail(""John"", ""epfl.ch"")
  to construct the string 
 ""John@epfl.ch@"". To make this more explicit, you could also let
  EMail 
 inherit from Scala’s function type, like this: 
 object EMail extends (String, String) => String { ... }
  
 The
  unapply
  method is what turns
  EMail
  into an extractor. In a sense, it 
 reverses the construction process of
  apply
 . Where
  apply
  takes two 
 strings and forms an e-mail address string out of them,
  unapply
  takes 
 an e-mail address and returns potentially two strings: the user and the 
 domain of the address. But
  unapply
  must also handle the case where the 
 given string is not an e-mail address. That’s why
  unapply
  returns an
  
 Option
 -type over pairs of",NA
24.3 ,NA,NA
Patterns with zero or one variables,"In
  unapply
  method of the previous example returned a pair of element 
 values in the success case. This is easily generalized to patterns of 
 more than two variables. To bind
  N
  variables, an
  unapply
  would return 
 a
  N
 -element tuple, wrapped in a
  Some
 . 
 The case where a pattern binds just one variable is treated 
 differently, however. There is no one-tuple in Scala. So to return just 
 one pattern ele-",NA
24.4 ,NA,NA
Variable argument extractors,"The previous extraction methods for e-mail addresses all returned a 
 fixed number of element values. Sometimes, this is not flexible enough. 
 For ex-ample, you might want to match on a string representing a 
 domain name, so that every part of the domain is kept in a different 
 sub-pattern. This would let you express patterns such as the following: 
 dom match {
  
 case Domain(""org"", ""acm"") => println(""acm.org"")
  
 case Domain(""com"", ""sun"", ""java"") => println(""java.sun.com"")
  
  
 case Domain(""net"", _*) => println(""a .net domain"") }
  
 In this example things were arranged so that domains are expanded in 
 re-verse order—from the top-level domain down to the sub-domains. 
 This was done so that one can better profit from sequence patterns. 
 You have seen in 
 Section 12.2
  that a sequence wildcard pattern
  _*
  at 
 the end of an argument list matches any remaining fields in a 
 sequence. This feature is more use-ful if the top-level domain comes 
 first, because then one can use sequence wildcards to match sub-
 domains of arbitrary depth. 
 But the question remains how an extractor can support
  vararg 
 matching 
 like in the previous example, where patterns can have a 
 varying number of sub-patterns. The
  unapply
  methods encountered so 
 far are not sufficient,",NA
24.5 ,NA,NA
Extractors and sequence patterns,"You have seen in
  Chapter 8
  that you can access the elements of a list or an 
 Prepared for jacques weiss
  
 array using sequence patterns such 
 as  
 List() 
  
 List(x, y, _*) 
  
 Array(x, 0, 0, _)
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
24.6 ,NA,NA
Extractors vs Case Classes,"Even though they are very useful, case classes have one shortcoming: 
 they expose the concrete representation of data. This means that the 
 name of the class in a constructor pattern corresponds to the concrete 
 representation type of the selector object. If a match against 
 case C(...)
  
 succeeds, you know that the selector expression is an instance of class
  C
 . 
 Prepared for jacques weiss
  
 Extractors break this link between data representations and 
 patterns. You have seen in the examples in this section that they 
 enable patterns that have nothing to do with the data type of the 
 object that’s selected on. This property is called
  representation 
 independence
 . In open systems of large size, repre-sentation 
 independence is very important because it allows you to change an 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
24.7,NA,NA
Conclusion,"Chapter 24 · Extractors
  
 472 
 In this chapter you have seen out how to generalize pattern matching 
 with extractors. Extractors let you define your own kinds of patterns, 
 which need not correspond to the type of the expressions you select 
 on. This gives you more flexibility for the kinds of patterns you want to 
 use for matching. In effect it’s like having different possible views on 
 the same data. It also gives you a layer between a type’s 
 representation and the way clients view it. This lets you do pattern 
 matching while maintaining representation independence, a property 
 which is very useful in large software systems.",NA
Chapter 25,NA,NA
Objects As Modules,"You saw in
  Chapter 13
  how to divide programs into packages and thus 
 get more modular code. While this kind of division is already quite 
 helpful, it is limited because it provides no way to abstract. You cannot 
 reconfigure a package two different ways within the same program, 
 and you cannot inherit between packages. A package always includes 
 one precise list of contents, and that list is fixed until you change the 
 code. 
 A more powerful approach is to make modules out of plain old 
 objects. In Scala, there is no need for objects to be “small” things, no 
 need to use some other kind of construct for “big” things like modules. 
 One of the ways Scala is a
  scala
 ble language is that the same constructs 
 are used for structures both small and large. 
 This chapter walks through using objects as modules, starting with 
 a basic example and then showing how to take advantage of various 
 Scala features to improve on them.",NA
25.1 ,NA,NA
A basic database,"Wwe’ll start by building a persistent database of recipes. The database 
 will be in one module, and a database browser will be in another. The 
 database",NA
25.2 ,NA,NA
Abstraction,"Suppose you want the same code base to support multiple recipe 
 databases, and you want to be able to create a separate browser for 
 each of these databases. You would like to reuse the browser code for 
 each of the instances, because the only thing different about the 
 browsers is which database they refer to. Except for the database 
 implementation, the rest of the code can be reused character for 
 character. How can the program be arranged to mini-mize repetitive 
 code? How can the code be made reconfigurable, so that you can 
 configure it using either database implementation? 
 The answer is a familiar one: if a module is an object, then a 
 template for module is a class. Just like a class describes the common 
 parts of all its",NA
25.3 ,NA,NA
Splitting modules into traits,"Often a module is too large to fit comfortably into a single file. When 
 that happens, you can use traits to split a module into separate files. 
 For example, suppose you wanted to move categorization code out 
 of the main
  Database
  file and into its own. You can create a trait for the 
 code like this: 
 Prepared for jacques weiss
  
 trait FoodCategories { 
  
  
 case class FoodCategory(name: String, foods: List[Food]) }
  
 Now the 
 Database
  class can mix in this trait instead of defining 
 FoodCategory
  itself:  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
25.4 ,NA,NA
Runtime linking,"One final feature of Scala modules is worth emphasizing: they can be 
 linked together at runtime, and you can decide which modules will 
 link to which depending on runtime computations. For example, here 
 is a small program that chooses a database at runtime and then prints 
 out all the apple recipes in it: 
 object GotApples { 
  
  
 def main(args: Array[String]) { 
  
   
 val db: Database = 
  
    
 if(args(0) == ""student"") 
  
    
 StudentDatabase 
  
    
 else 
  
    
 SimpleDatabase
  
 object browser extends Browser { 
  
 val database = db 
  
 }
  
 val apple = SimpleDatabase.foodNamed(""Apple"").get
  
 Prepared for jacques weiss
  
 }
  
 for(recipe <- browser.recipesUsing(apple))
  
 println(recipe)
  
 }
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
25.5 ,NA,NA
Tracking module instances,"Despite using the same code, the different browser and database mod-
 ules created above really are separate modules.  
 This means that 
 each module has its own contents,  
 including any nested classes. 
 FoodCategory
  in
  SimpleDatabase
  is a different class from
  FoodCategory 
 in
  
 StudentDatabase
 ! 
 scala> val category = StudentDatabase.allCategories.head
  
 category: StudentDatabase.FoodCategory =
  
 FoodCategory(edible,List(FrozenFood))
  
 scala> SimpleBrowser.displayCategory(category)
  
 <console>:12: error: type mismatch;
  
 found : StudentDatabase.FoodCategory
  
 required: SimpleBrowser.database.FoodCategory
  
 SimpleBrowser.displayCategory(category)
  
 ˆ
  
 If instead you prefer all
  FoodCategory
 s to be the same, you can 
 accomplish this by moving the definition of
  FoodCategory
  outside of any 
 class or trait. The choice is yours, but as it is written, each
  Database
  gets 
 its own, unique 
 FoodCategory
  class. 
 Prepared for jacques weiss
  
 The above two classes really are different, so the compiler is 
 correct to complain. Sometimes, though, you will encounter a case 
 where two types are the same but the compiler cannot verify it. You 
 will see the compiler com-plaining that two types are not the same, 
 even though you as the programmer know they perfectly well are. 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
25.6,"Chapter 25 · Objects As Modules
  
 483",NA
Conclusion,"This chapter has shown how to use Scala’s objects as modules. In 
 addition to simple static modules, this approach gives you a variety of 
 ways to create abstract, reconfigurable modules. There are actually 
 even more abstraction techniques than shown, because anything that 
 works on a class, also works on a class used to implement a module. As 
 always, how much of this power you use should be a matter of taste. 
 Modules are part of programming in the large, and thus are hard to 
 ex-periment with. You need a large program before it really makes a 
 difference. Nonetheless, after reading this chapter you know which 
 Scala features to think about when you want to program in a modular 
 style. Think about these techniques when you write your own large 
 programs, and recognize these coding patterns when you see them in 
 other people’s code.",NA
Chapter 26,NA,NA
Annotations,"Annotations are structured information added to program source 
 code. Like comments, they can be sprinkled throughout a program and 
 attached to any variable, method, expression, or other program 
 element. Unlike comments, they have structure, thus making them 
 easier to machine process. 
 This chapter shows how to use annotations in Scala. It shows the 
 syntax of them in general, and then it shows how to use several 
 standard annotations. 
 This chapter does not show how to write new annotation 
 processing tools. In general that topic is beyond the scope of this book, 
 but you can see one technique in
  Chapter 27
 .",NA
26.1 ,NA,NA
Why have annotations?,"There is no perfect programming language. We have done our best 
 with Scala to include today’s best proven ideas. Many more ideas are 
 under cur-rent research, though, and inevitably at least some of those 
 ideas will prove their worth in the future. The state of the art language 
 in ten years will be better than the state of the art language of today. 
 On top of that, there are a variety of special circumstances where 
 lan-guage support can help, but there is no way for a single language to 
 support",NA
26.2 ,NA,NA
Syntax of annotations,"A typical use of an annotation looks like this: 
 @deprecated def bigMistake() = //...
  
 The annotation is the
  @deprecated
  part, and it applies to the entirety of 
 the
  bigMistake
  method (not shown—it’s too embarrassing). In this case, 
 the method is being marked as something the author of
  bigMistake
  
 wishes you not to use. Maybe
  bigMistake
  will be removed entirely from 
 a future version of the code. 
 In the previous example, it is a method that is annotated as
  
 @deprecated
 . There are other places annotations are allowed, too. 
 Annotations are allowed on any other kind of declaration or definition, 
 including
  val
 s,
  var
 s,
  def
 s, 
 class
 es,
  object
 s,
  trait
 s, and
  type
 s. The annotation 
 applies to the entirety",NA
26.3,"Chapter 26 · Annotations
  
 487",NA
Standard annotations,"Scala includes several standard annotations. They are for features that 
 are used widely enough to merit putting in the language specification, 
 but that are not fundamental enough to merit their own syntax. Over 
 time, there should be a trickle of new annotations that are added to 
 the standard in just the same way. 
 Deprecation
  
 Sometimes you write a class or method that you later wish you had 
 not. Once it is available, though, code written by other people might 
 call the method. Thus, you cannot simply delete the method instantly, 
 because you would cause other people’s code to stop compiling. 
 Deprecation lets you gracefully remove a method or class that 
 turns out to be a mistake. You mark the method or class as deprecated, 
 and then any-one who calls that method or class will get a deprecation 
 warning. They had better head this warning and update their code! 
 The idea is that after a suit-able amount of time has passed, you feel 
 safe in assuming that all reasonable clients will have stopping 
 accessing the deprecated class or method and thus that you can safely 
 remove it. 
  
 You mark a method as deprecated simply by writing
  @deprecated
  be-
 fore it. For example: 
 @deprecated def bigMistake() = 
  
 //...
  
 Such an annotation will cause Scala to emit deprecation warnings 
 whenever Scala code accesses the method. 
 Volatile fields
  
 Concurrent programming does not mix well with shared mutable state. 
 For this reason, the focus of Scala’s concurrency support is message 
 passing and",NA
26.4 ,NA,NA
Conclusion,"This chapter has described how to use annotations, and how to use 
 several standard annotations.",NA
Chapter 27,NA,NA
Combining Scala and Java,"Scala code is often used in tandem with large Java programs and 
 frame-works. Since Scala is highly compatible with Java, most of the 
 time you can combine the languages without worrying very much. For 
 example, standard frameworks such as Swing, Servlets, and JUnit are 
 known to work just fine with Scala. Nonetheless, from time to time you 
 will run into some issue with combining Java and Scala. Further, you 
 might just have an engineer’s motives and want to know more about 
 how Scala works under the hood. 
 This chapter describes two aspects of combining Java and Scala. 
 First, it discusses how Scala is translated to Java, which is especially 
 important if you call Scala code from Java. Second, it discusses the use 
 of Java annotations in Scala, an important feature if you want to use 
 Scala with an existing Java framework.",NA
27.1 ,NA,NA
Translation details,"Most of the time you can just think of Scala at the source code level. 
 How-ever, you will have a richer understanding of how the system 
 works if you know something about its translation. Further, if you call 
 Scala code from Java, you will need to know what Scala code looks like 
 from a Java point of",NA
27.2 ,NA,NA
Annotations,"Scala’s general annotations system is discussed in
  Chapter 26
 . This 
 section discusses Java-specific aspects of annotations. 
 Additional effects from standard annotations
  
 Several annotations cause the compiler to emit extra information 
 when run-ning on Java. When the compiler sees such an annotation, it 
 processes it according to the general Scala rules, and then it does 
 something extra for Java. 
 Deprecation 
  For any method or class marked
  @deprecated
 , the 
 compiler will add Java’s own deprecation annotation to the emitted 
 code. Because of this, Java compilers can issue deprecation warnings 
 when Java code accesses the method. 
 Volatile fields 
  Likewise, any field marked
  @volatile
  in Scala is given the 
 @volatile
  Java annotation in the emitted code. Thus, volatile fields in 
 Scala behave exactly according to Java’s semantics, and accesses to 
 volatile fields are sequenced precisely according to the rules of the Java 
 Memory Model. 
 Serialization 
  Scala’s three standard serialization annotations 
 discussed are all translated to Java equivalents.  
 A
  @serializable
  class 
 has the Java 
 Serializable
  interface added to it. A
  @SerialVersionUID(1234L)
  
 an-notation is converted to the following Java field definition: 
 // Java serial version marker
  
 private final static long SerialVersionUID = 1234L",NA
27.3,NA,NA
Existential types,"All Java types have a Scala equivalent. 
 This is necessary so that Scala 
 code can access any legal Java class. 
 Most of the time the trans- 
 lation is straightforward. 
 Pattern
  in Java is
  Pattern
  in Scala, and 
 Iterator<Component>
  in Java is
  Iterator[Component]
  in Scala. 
 For",NA
27.4 ,NA,NA
Conclusion,"Most of the time, you can ignore how Scala is implemented and simply 
 write and run your code. Sometimes it is nice to “look under the hood,” 
 however,",NA
Chapter 28,NA,NA
Combinator Parsing,"Occasionally it can be useful to whip up a processor for a small 
 language. However, you must solve the problem of
  parsing
  sentences 
 in the language you want to process. Essentially, you have only a few 
 choices. 
 One choice is to roll your own parser (and lexical analyzer). If you 
 are not an expert this is hard. If you are an expert, it is still time-
 consuming to do this. 
 An alternative choice is to use a parser generator. There exist quite 
 a few of these generators. Some of the better known are Yacc or Bison 
 for parsers written in C and ANTLR for parsers written in Java. You’ll 
 probably also need a scanner generator such as Lex, Flex, or JFlex to go 
 with it. This might be the best solution, except for a couple of 
 inconveniences: You need to learn new tools, including their—
 sometimes obscure—error messages. You also need to figure out how 
 to connect the output of these tools to your program. This might limit 
 the choice of your programming language, and complicate your tool 
 chain. 
 This chapter presents a third alternative: Instead of using the 
 stand-alone domain specific language of a parser generator you will 
 use an
  embedded domain specific language
  (or: embedded DSL for 
 short). The embedded DSL consists of a library of
  parser combinators
 . 
 These are functions and",NA
28.1 ,NA,NA
Example: Arithmetic Expressions,"Let’s start with an example: Say you want to construct a parser for 
 arithmetic expressions consisting of integer numbers, parentheses, 
 and the binary op-erators
  +
 ,
  -
 ,
  *
 , and
  /
 . The first step is always to write 
 down a grammar for the language to be parsed. For arithmetic 
 expressions, this grammar reads as follows: 
 expr
  
 ::=
  
 term {'+' term | '-' term}.
  
 term
  
 ::=
  
 factor {'*' factor | '/' factor}.
  
 factor
  
 ::=
  
 numericLit | '(' expr ')'.
  
 Here, “
 |
 ” denotes alternative productions.
  {...}
  denotes repetition (zero 
 or more times) whereas
  [...]
  denotes an optional occurrence. 
 This context-free grammar defines formally a language of 
 arithmetic ex-pressions: Every expression (represented by
  expr
 ) is a
  
 term
 , which can be followed by a sequence of ‘
 +
 ’ or ‘
 -
 ’ operators and 
 further terms. A
  term
  is a factor, possibly followed by a sequence of ‘
 *
 ’ 
 or ‘
 /
 ’ operators and further factors. A
  factor
  is either a numeric literal 
 or an expression in parentheses. Note that the grammar already 
 encodes the relative precedence of operators.",NA
28.2 ,NA,NA
Running Your Parser,"You can test your parser with the following a small program: 
 object ArithTest extends Arith {
  
 def main(args: Array[String]) {
  
 val tokens = new lexical.Scanner(args(0))
  
 println(""input: ""+args(0))",NA
28.3,"Chapter 28 · Combinator Parsing
  
 507",NA
Another Example: JSON,"Let’s try another example. JSON, the JavaScript Object Notation, is a 
 popu-lar data interchange format. You’ll now find out how to write a 
 parser for it. 
 Here is the syntax of JSON: 
 value = obj | arr | stringLit | numericLit |
  
 ""null"" | ""true"" | ""false""
  
 obj = ""{"" [members] ""}""
  
 arr = ""["" [values] ""]""
  
 members = member {"","" member}
  
 member = stringLit "":"" value
  
 values = value {"","" value}
  
 A JSON value is an object, or an array, or a string, or a number, or one 
 of the three reserved words
  null
 ,
  true
 , or
  false
 . A JSON object is a 
 (possibly empty) sequence of members separated by commas and 
 enclosed in braces. Each member is a string/value pair where the 
 string and the value are sepa-rated by a colon. Finally, a JSON array is 
 a sequence of values separated by commas and enclosed in square 
 brackets. 
 Here is an example JSON object: 
 { ""address book"": {
  
 ""name"": ""John Smith"",
  
 ""address"": {
  
 ""street"": ""10 Market Street"",
  
 ""city"" : ""San Francisco, CA"",
  
 ""zip"" : 94111
  
 },
  
 ""phone numbers"": [
  
 ""408 338-4238"",
  
 ""408 111-6892""
  
 ]",NA
28.4 ,NA,NA
Parser Output,"The test run above succeeded; the JSON address book was successfully 
 parsed. However, the parser output looks strange—it seems to be a 
 sequence composed of bits and pieces of the input glued together with 
 lists and “
 ∼
 ”combinations. This parser output is not very useful. It is 
 certainly less read-able for humans than the input, but it is also too 
 disorganized to be easily analyzable by a computer. It’s time to do 
 something about this. 
 To figure out what to do, you need to know first what the 
 individual parsers in the combinator frameworks return as a result 
 (provided they suc-ceed in parsing the input). Here are the rules: 
 1. Each parser written as a string (such as:
  ""{""
  or
  "":""
  or
  ""null""
 ) returns 
  
 the parsed string itself.",NA
28.5 ,NA,NA
Implementing Combinator Parsers,"The previous sections have shown that Scala’s combinator parsers 
 provide a convenient means for constructing your own parsers. Since 
 they are nothing more than a Scala library, they fit seamlessly into 
 your Scala programs. So it’s very easy to combine a parser with some 
 code that processes the results it delivers, or to rig a parser so that it 
 takes its input from some specific source (say, a file, a string, or a 
 character array). 
 How is this achieved? In the rest of this chapter you’ll take a look 
 “under the hood” of the combinator parser library. You’ll see what a 
 parser is, and",NA
28.6,"Chapter 28 · Combinator Parsing
  
 522",NA
Lexing and Parsing,"The task of syntax analysis is usually split into two phases. The
  lexer
  
 phase recognizes individual words in the input and classifies them 
 into some
  token 
 classes. This phase is also called
  lexical analysis
 . This 
 is followed by a 
 syntactical analysis
  phase that analyzes sequences of 
 tokens. Syntactical analysis is also sometimes just called parsing, even 
 though this is slightly imprecise, as lexical analysis can also be 
 regarded as a parsing problem. 
 The
  Parsers
  class as described above can be used for either phase, 
 be-cause its input elements are of the abstract type
  Elem
 . For lexical 
 analysis, 
 Elem
  would be instantiated to
  Char
 , meaning that what’s 
 parsed are the in-dividual characters that make up a word. The 
 syntactical analyzer would in turn instantiate
  Elem
  to the type of
  Token
 s 
 returned by the lexer. 
 Scala’s parsing combinators provide several utility classes for 
 lexing and syntactic analysis. These are contained in two sub-
 packages, one each for lexical and syntactical analysis. 
 scala.util.parsing.combinator.lexical
  
 scala.util.parsing.combinator.syntactical
  
 In the following, you will learn of some of the abstractions in the 
 syntacti-cal analysis package, just enough to understand how standard 
 token parsers work. These parsers use a standard lexical analysis that 
 distinguishes a sub-set of the tokens of Java and Scala. If you need to 
 write a lexical analyzer that follows different rules, you should consult 
 the scaladoc API documentation for the
  lexical
  sub-package. 
  
 The tokens that are supported by the standard lexer are described 
 by the following class: 
 abstract class Token { def chars: String }
  
 Here, the
  chars
  method returns the characters making up the token as a 
 String
 . Class
  Token
  has four standard subclasses: 
 Prepa
 red 
 for 
 jacque
 s 
 weiss
  
 case class Keyword
  
 (override val chars: String)...",NA
28.7 ,NA,NA
Standard Token Parsers,"The
  StandardTokenParsers
  class is found in the syntactical analysis pack-
 age. It extends class
  Parsers
 , fixing the kind
  Elem
  of input elements to be 
 instances of class
  Token
 . A slightly simplified account of the class is 
 given below (in reality the contents of the class are spread over 
 several par-ent classes, to enable more flexible re-use): 
 package scala.util.parsing.combinator.syntactical
  
 class StandardTokenParsers extends Parsers {
  
 type Elem = Token
  
 ...
  
 The
  StandardTokenParsers
  class also defines four single-token parsers for 
 the four kinds of tokens that are supported. Each of these is defined in 
 terms of
  elem
 : 
 ...
  
 /** A parser that matches a numeric literal */ def numericLit: 
 Parser[String] =
  
 elem(""number"", _.isInstanceOf[NumericLit]) ˆˆ (_.chars)
  
 /** A parser that matches a string literal */ 
  
 def stringLit: Parser[String] =
  
 elem(""string"", _.isInstanceOf[StringLit]) ˆˆ (_.chars)
  
 /** A parser that matches an identifier */ 
  
 def ident: Parser[String] =
  
 elem(""identifier"", _.isInstanceOf[Identifier]) ˆˆ (_.chars)
  
 Prepared for jacques weiss
  
 /** A parser matching a given reserved word or delimiter */ implicit def 
 keyword(chars: String): Parser[String] =
  
 elem(""‘""+chars+""'"", _ == Keyword(chars))
  
 } // end StandardTokenParsers
  
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
28.8 ,NA,NA
Error reporting,"There’s one final topic that was not covered yet: How does the parser 
 issue an error message? Error reporting for parsers is somewhat of a 
 black art. One problem is that a parser that rejects some input 
 contains many different failures. After all each alternative parse must 
 have failed, and so on recur-sively for each choice point. Which of the 
 usually numerous failures should be emitted as error message to the 
 user? 
 Scala’s parsing library implements a simple heuristic: Among all 
 fail-ures, the one that occurred at the latest position in the input is 
 chosen. In other words, the parser picks the longest prefix that is still 
 valid and then issues an error message that describes why parsing the 
 prefix could not be continued further. If there are several failure 
 points at that latest position, the one that was visited last is chosen.",NA
28.9,NA,NA
Backtracking vs LL(1),NA,NA
28.10 Conclusion,"You have now seen all the essential elements of Scala’s combinator 
 parsing framework. It’s surprisingly little code for something that’s 
 genuinely useful. With the framework you can construct parsers for a 
 large class of context-free grammars. The framework lets you get 
 started quickly but it is also customizable to new kinds of grammars 
 and input methods. Being a Scala library, it integrates seamlessly with 
 the rest of the language. So it’s easy to integrate a combinator parser 
 in a larger Scala program. 
 One downside of combinator parsers is that they are not very 
 efficient, at least not when compared with parsers generated from 
 special purpose tools such as Yacc or Bison. This has to do with two 
 effects: First, the backtrack-ing method used by combinator parsing is 
 itself not very efficient. Depending on the grammar and the parse 
 input, it might yield an exponential slow-down due to repeated 
 backtracking. This can be fixed by making the grammar",NA
Glossary,"algebraic data type
  A type defined by giving several alternatives, 
 each of which comes with its own constructor. It usually comes 
 with a way to decompose the type through pattern matching. 
 The concept is found in specification languages and functional 
 programming languages. Al-gebraic data types can be emulated 
 in Scala with case classes. 
 alternative
  An
  alternative
  is a branch of a match expression. It has the 
 form“
 case
  pattern
  =>
  expression
 .” Another name for alternative is, 
 simply, 
 case
 . 
 annotation
  An annotation appears in source code and is attached to 
 some part of the syntax. Annotations are computer processable, 
 so you can use them to effectively add an extension to Scala. 
 anonymous function
  Another name for function literal. 
 apply
  You can
  apply
  a method, function, or closure
  to
  arguments, 
 which  
 means you invoke it on those arguments. 
 argument
  When a function is invoked, an
  argument
  is passed for each 
 pa-rameter of that function. The parameter is the variable that 
 refers to the argument. The argument is the object passed at 
 invocation time. In ad-dition, applications can take (command 
 line) arguments that show up in the
  Array[String]
  passed to
  main
  
 methods of singleton objects.",NA
Bibliography,"[Abe96] Abelson, Harold and Gerald Jay Sussman.
  Structure and Inter-
 pretation of Computer Programs
 . The MIT Press, second 
 edition, 1996. 
 [Emi07] Emir, Burak, Martin Odersky, and John Williams. “Matching 
 Ob-jects With Patterns.” In
  Proc. ECOOP
 , Springer LNCS, pages 
 273–295. July 2007. 
 [Gam94] Gamma, Erich, Richard Helm, Ralph Johnson, and John 
 Vlissides. 
 Design Patterns : Elements of Reusable Object-
 Oriented Software
 . Addison-Wesley, 1994. 
 [Kay96] Kay, Alan C. “The Early History of Smalltalk.” 
 In
  History of
  
 programming languages—II
 , pages 511–598. ACM, New York, 
 NY, 
 USA, 
 1996. 
 ISBN 
 0-201-89502-1. 
 doi:http://doi.acm.org/10.1145/ 234286.1057828. 
 [Lan66] Landin, Peter J. “The Next 700 Programming Languages.”
  Com-
  
 munications of the ACM
 , 9(3):157–166, 1966. 
 [Ode03] Odersky, Martin, Vincent Cremet, Christine Röckl, and 
 Matthias Zenger. “A Nominal Theory of Objects with 
 Dependent Types.” In 
 Proc. ECOOP’03
 , Springer LNCS, pages 
 201–225. July 2003. 
 Prepare
 d for 
 jacques 
 weiss
  
 [Ode05] Odersky, Martin and Matthias Zenger. “Scalable Component Ab- 
 stractions.” 
 In
  Proceedings of OOPSLA
 , pages 41–58. October",NA
About the Authors,NA,NA
Martin Odersky,"Martin Odersky is the creator of the Scala language. As a professor at 
 EPFL in Lausanne, Switzerland he is working on programming 
 languages, more specifically languages for object-oriented and 
 functional programming. His research thesis is that the two paradigms 
 are two sides of the same coin, to be identified as much as possible. To 
 prove this, he has experimented with a number of language designs, 
 from Pizza to GJ to Functional Nets. He has also influenced the 
 development of Java as a co-designer of Java generics and as the 
 original author of the current javac reference compiler. Since 2001 he 
 has concentrated on designing, implementing, and refining the Scala 
 programming language.",NA
Lex Spoon,"Lex Spoon worked on Scala for two years as a post-doc at EPFL. He has 
 a Ph.D. in computer science from Georgia Tech. His research is on pro-
 gramming environments and on better support for distributed 
 development. In addition to Scala, he has worked on a wide variety of 
 languages, ranging from the dynamic language Smalltalk to the 
 scientific language X10. He and his wife live in Atlanta with two cats, a 
 chihuahua, and a turtle.",NA
Bill Venners ,"Bill Venners is president of Artima, Inc., publisher of Artima Developer 
 (www.artima.com). He is author of the book, Inside the Java Virtual 
 Ma- 
 Cover
  ·
  Overview
  ·
  Contents
  ·
  Discuss
  ·
  Suggest
  ·
  Glossary
  ·
  Index",NA
