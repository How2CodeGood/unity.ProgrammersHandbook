Larger Text,Smaller Text,Symbol
Scala for the Impatient,"Copyright © Cay S. Horstmann 2012. All Rights Reserved.
  
 The evolution of Java and C++ has slowed down considerably, and programmers 
 who are eager to use more modern language features are looking elsewhere. Scala 
 is an attractive choice; in fact, I think it is by far the most attractive choice for 
 programmers who want to move beyond Java or C++. Scala has a concise syntax 
 that is 
  
 refreshing after the Java boilerplate. It runs on the Java virtual machine, providing 
 access to a huge set of libraries and tools. It embraces the functional programming 
 style without abandoning object-orientation, giving you an incremental learning 
 path to a new paradigm. The Scala interpreter lets you run quick experiments, 
 which makes learning Scala very enjoyable. And, last but not least, Scala is statically 
 typed, enabling the compiler to find errors, so that you don't waste time finding 
 them later in running programs (or worse, don't find them).
  
 I wrote this book for impatient readers who want to start 
  
 programming with Scala right away. I assume you know Java, C#, or C++, and I won't 
 bore you with explaining variables, loops, or classes.
  
 I won't exhaustively list all features of the language, I won't lecture you about the 
 superiority of one paradigm over another, and I won't make you suffer through 
 long and contrived examples. Instead, you will get the information that you need in 
 compact chunks that you can read and review as needed.
  
 Scala is a big language, but you can use it effectively without knowing all of its details 
 intimately. Martin Odersky, the creator of Scala, has identified the following levels of 
 expertise for application 
  
 programmers and library designers:
  
 Application Programmer Library Designer Overall Scala Level
  
 Beginning (A1)
  
  
 Beginning
  
  
  
 Intermediate (A2)
  
  
  
 Junior (L1)
  
  
  
 Intermediate
  
  
  
 Expert (A3)
  
  
  
 Senior (L2)
  
  
  
 Advanced
  
  
  
  
 Expert (L3)
  
  
  
 Expert
  
  
 For each chapter (and occasionally for individual sections), I indicate the 
 experience level. The chapters progress through levels A1, L1, A2, L2, A3, L3. Even if 
 you don't want to design your own libraries, knowing about the tools that Scala 
 provides for library designers can make you a more effective library user.",NA
The Basics,NA,NA
Topics in This Chapter  ,"A1
  
 1.1 The Scala Interpreter — page 3 
  
 1.2 Declaring Values and Variables — page 5 
  
 1.3 Commonly Used Types — page 6 
  
 1.4 Arithmetic and Operator Overloading — page 7 
 1.5 Calling Functions and Methods — page 9 
  
 1.6 The 
 apply
  Method — page 10 
  
 1.7 Scaladoc — page 10 
  
 Exercises — page 13",NA
Chapter,NA,NA
1,"In this chapter, you will learn how to use Scala as an industrial-strength pocket 
 calculator, working interactively with numbers and arithmetic operations. We 
 introduce a number of important Scala concepts and idioms along the way. 
 You will also learn how to browse the Scaladoc documentation at a beginner’s 
 level.
  
 Highlights of this introduction are:
  
 •
  
 Using the Scala interpreter 
  
  
 Defining variables with 
 var
  and 
 val
 •
  
 •
  
 Numeric types
  
 •
  
  
 Using operators and functions•
  
 Navigating Scaladoc",NA
1.1 The Scala Interpreter,"To start the Scala interpreter:
  
 •
  
 Install Scala.
  
 •
  
 Make sure that the 
 scala/bin
  directory is on the PATH.
  
 •
  
 Open a command shell in your operating system.
  
 Type 
 scala
  followed by the Enter key.•",NA
1.2 Declaring Values and Variables,"Instead of using the names 
 res0
 , 
 res1
 , and so on, you can define your own names:
  
 scala> 
 val answer = 8 * 5 + 2
  
 answer: Int = 42
  
 You can use these names in subsequent expressions:
  
 scala> 0.5 * answer
  
 res3: Double = 21.0
  
 A value declared with 
 val
  is actually a constant—you can’t change its contents:
  
 scala> 
 answer = 0
  
 <console>:6: error: reassignment to val
  
 To declare a variable whose contents can vary, use a 
 var
 :
  
 var counter = 0
  
 counter = 1 //
  OK, can change a 
 var
  
 In Scala, you are encouraged to use a 
 val
  unless you really need to change the 
 contents. Perhaps surprisingly for Java or C++ programmers, most programs 
 don’t need many 
 var
  variables.
  
 Note that you need not specify the type of a value or variable. It is inferred 
 from the type of the expression with which you initialize it. (It is an error to 
 declare a value or variable without initializing it.)
  
 However, you can specify the type if necessary. For example,
  
 val greeting: String = null
  
 val greeting: Any = ""Hello""",NA
1.3 Commonly Used Types,"You have already seen some of the data types of the Scala language, such as 
 Int 
 and 
 Double
 . Like Java, Scala has seven numeric types: 
 Byte
 , 
 Char
 , 
 Short
 , 
 Int
 , 
 Long
 , 
 Float
 , and 
 Double
 , and a 
 Boolean
  type. However, unlike Java, these types are 
 classes
 . There is no distinction between primitive types and class types in Scala. 
 You can invoke methods on numbers, for example:
  
 1.toString() //
  Yields the string 
 ""1""
  
 or, more excitingly,
  
 1.to(10) //
  Yields 
 Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
  
 (We will discuss the 
 Range
 class in Chapter 13. For now, just view it as a 
 collection of numbers.)
  
 In Scala, there is no need for wrapper types. It is the job of the Scala compiler 
 to convert between primitive types and wrappers. For example, if you make an 
 array of 
 Int
 , you get an 
 int[]
  array in the virtual machine.
  
 As you saw in Section 1.1, “The Scala Interpreter,” on page 3, Scala relies on the 
 underlying 
 java.lang.String
  class for strings. However, it augments that class with 
 well over a hundred operations in the 
 StringOps
  class. For example, the 
 intersect 
 method yields the characters that are common to two strings:",NA
1.4 Arithmetic and Operator Overloading,"Arithmetic operators in Scala work just as you would expect in Java or C++:
  
 val answer = 8 * 5 + 2
  
 The 
 + - * / %
  operators do their usual job, as do the bit operators 
 & | ^ >> <<
 . There 
 is just one surprising aspect: These operators are actually methods. For 
 example,
  
 a + b
  
 is a shorthand for
  
 a.+(b)
  
 Here, 
 +
  is the name of the method. Scala has no silly prejudice against non-
 alphanumeric characters in method names. You can define methods with just",NA
1.5 Calling Functions and Methods,"Scala has functions in addition to methods. It is simpler to use mathematical 
 functions such as 
 min
  or 
 pow
  in Scala than in Java—you need not call static 
 methods from a class.
  
 sqrt(2) //
  Yields 
 1.4142135623730951 
  
 pow(2, 4) //
  Yields 
 16.0 
  
 min(3, Pi) //
  Yields 
 3.0
  
 The mathematical functions are defined in the 
 scala.math
  package. You can 
 import them with the statement
  
 import scala.math._ //
  In Scala, the 
 _
  character is a “wildcard,” like 
 *
  in Java
  
  
 NOTE: To use a package that starts with 
 scala.
 , you can omit the 
 scala
  prefix. 
 For example, 
 import math._
  is equivalent to 
 import scala.math._
 , and 
 math.sqrt(2)
  
 is the same as 
 scala.math.sqrt(2)
 .
  
 We discuss the 
 import
  statement in more detail in Chapter 7. For now, just use 
 import 
 packageName
 ._
  whenever you need to import a particular package.
  
 Scala doesn’t have static methods, but it has a similar feature, called 
 singleton 
 objects
 , which we will discuss in detail in Chapter 6. Often, a class has a 
 companion object
  whose methods act just like static methods do in Java. For 
 exam-ple, the 
 BigInt
  companion object to the 
 BigInt
  class has a method 
 probablePrime
  that generates a random prime number with a given number of 
 bits:
  
 BigInt.probablePrime(100, scala.util.Random)
  
 Try this in the REPL; you’ll get a number such as 
 1039447980491200275486540240713
 . Note that the call 
 BigInt.probablePrime
  is 
 similar to a static method call in Java.
  
  
 NOTE: Here, 
 Random
  is a singleton random number generator object, 
 defined in the 
 scala.util
  package. This is one of the few situations where a 
 singleton
  
 object is better than a class. In Java, it is a common error to construct a new
  
 java.util.Random
  object for each random number.
  
 Scala methods without parameters often don’t use parentheses. For example, 
 the API of the 
 StringOps
  class shows a method 
 distinct
 , without 
 ()
 , to get the 
 distinct letters in a string. You call it as
  
 ""Hello"".distinct",NA
1.6 The ,NA,NA
apply,NA,NA
 Method,"In Scala, it is common to use a syntax that looks like a function call. For 
 example, if 
 s
  is a string, then 
 s(i)
  is the 
 i
 th character of the string. (In C++, you 
 would write 
 s[i]
 ; in Java, 
 s.charAt(i)
 .) Try it out in the REPL:
  
 ""Hello""(4) //
  Yields 
 'o'
  
 You can think of this as an overloaded form of the 
 ()
  operator. It is 
 implemented as a method with the name 
 apply
 . For example, in the 
 documentation of the 
 StringOps 
 class, you will find a method
  
 def apply(n: Int): Char 
  
 That is, 
 ""Hello""(4)
  is a shortcut for
  
 ""Hello"".apply(4)
  
 When you look at the documentation for the 
 BigInt
  companion object, you will 
 see 
 apply
  methods that let you convert strings or numbers to 
 BigInt
  objects. For 
 example, the call
  
 BigInt(""1234567890"")
  
 is a shortcut for
  
 BigInt.apply(""1234567890"")
  
 It yields a new 
 BigInt
  object, 
 without having to use
  new
 . For example:
  
 BigInt(""1234567890"") * BigInt(""112358111321"")
  
 Using the 
 apply
  method of a companion object is a common Scala idiom for 
 con-structing objects. For example, 
 Array(1, 4, 9, 16)
  returns an array, thanks to 
 the 
 apply
  method of the 
 Array
  companion object.",NA
1.7 Scaladoc,"Java programmers use Javadoc to navigate the Java API. Scala has its own 
 variant, called Scaladoc (see Figure 1–1).
  
 Navigating Scaladoc is a bit more challenging than Javadoc. Scala classes tend 
 to have many more convenience methods than Java classes. Some methods use 
 features that you haven’t learned yet. Finally, some features are exposed as 
 they are implemented, not as they are used. (The Scala team is working on 
 improving the Scaladoc presentation, so that it can be more approachable to 
 beginners in the future.)",NA
Exercises,"1. 
 2.
  
 3. 
 4. 
 5. 
 6. 
 7. 
 8.
  
 9.
  
 In the Scala REPL, type 
 3.
  followed by the Tab key. What methods can be 
 applied?
  
 In the Scala REPL, compute the square root of 3, and then square that 
 value. By how much does the result differ from 3? (Hint: The 
 res
  variables 
 are your friend.)
  
 Are the 
 res
  variables 
 val
  or 
 var
 ?
  
 Scala lets you multiply a string with a number—try out 
 ""crazy"" * 3
  in the 
 REPL. What does this operation do? Where can you find it in Scaladoc?
  
 What does 
 10 max 2
  mean? In which class is the 
 max
  method defined?
  
 Using 
 BigInt
 , compute 2
 1024
 .
  
 What do you need to import so that you can get a random prime as 
 probablePrime(100, Random)
 , without any qualifiers before 
 probablePrime
  and 
 Random
 ?
  
 One way to create random file or directory names is to produce a random 
 BigInt
  
 and 
 convert 
 it 
 to 
 base 
 36, 
 yielding 
 a 
 string 
 such 
 as 
 ""qsnvbevtomcj38o06kul""
 . Poke around Scaladoc to find a way of doing this in 
 Scala.
  
 How do you get the first character of a string in Scala? The last character?
  
 10. What do the 
 take
 , 
 drop
 , 
 takeRight
 , and 
 dropRight
  string functions do? What 
  
 advantage or disadvantage do they have over using 
 substring
 ?",NA
Control Structures and ,NA,NA
Functions,NA,NA
Topics in This Chapter  ,"A1
  
 2.1 Conditional Expressions — page 16 
  
 2.2 Statement Termination — page 17 
  
 2.3 Block Expressions and Assignments — page 18 
  
 2.4 Input and Output — page 19 
  
 2.5 Loops — page 20 
  
 2.6 Advanced 
 for
  Loops and 
 for
  Comprehensions — page 21 
 2.7 Functions — page 22 
  
 2.8 Default and Named Arguments 
 L1
  — page 23 
  
 2.9 Variable Arguments 
 L1
  — page 24 
  
 2.10 Procedures — page 25 
  
 2.11 Lazy Values 
 L1
  — page 25 
  
 2.12 Exceptions — page 26 
  
 Exercises — page 28",NA
Chapter,NA,NA
2,"In this chapter, you will learn how to implement conditions, loops, and 
 functions in Scala. You will encounter a fundamental difference between Scala 
 and other programming languages. In Java or C++, we differentiate between 
 expressions 
 (such as 
 3 + 4
 ) and 
 statements
  (for example, an 
 if
  statement). An 
 expression has a value; a statement carries out an action. In Scala, almost all 
 constructs have values. This feature can make programs more concise and 
 easier to read.
  
 Here are the highlights of this chapter:
  
 •
 •
 •
 •
 •
 •
 •
 •
  
 •
  
 An 
 if
  expression has a value.
  
 A block has a value—the value of its last expression.
  
 The Scala 
 for
  loop is like an “enhanced” Java 
 for
  loop.
  
 Semicolons are (mostly) optional.
  
 The 
 void
  type is 
 Unit
 .
  
 Avoid using 
 return
  in a function.
  
 Beware of missing 
 =
  in a function definition.
  
 Exceptions work just like in Java or C++, but you use a “pattern 
 matching”syntax for 
 catch
 .
  
 Scala has no checked exceptions.
  
 15",NA
2.1 Conditional Expressions,"Scala has an 
 if
 /
 else
  construct with the same syntax as in Java or C++. However, 
 in Scala, an 
 if
 /
 else
  has a value, namely the value of the expression that follows 
 the 
 if
  or 
 else
 . For example,
  
 if (x > 0) 1 else -1
  
 has a value of 
 1
  or 
 -1
 , depending on the value of 
 x
 . You can put that value in a 
 variable:
  
 val s = if (x > 0) 1 else -1
  
 This has the same effect as
  
 if (x > 0) s = 1 else s = -1
  
 However, the first form is better because it can be used to initialize a 
 val
 . In the 
 second form, 
 s
  needs to be a 
 var
 .
  
 (As already mentioned, semicolons are mostly optional in Scala—see Section 
 2.2,“Statement Termination,” on page 17.)
  
 Java and C++ have a 
 ?:
  operator for this purpose. The expression
  
 x > 0 ? 1 : -1 //
  Java or C++
  
 is equivalent to the Scala expression 
 if (x > 0) 1 else -1
 . However, you can’t put 
 statements inside a 
 ?:
  expression. The Scala 
 if
 /
 else
  combines the 
 if
 /
 else
  and 
 ?: 
 constructs that are separate in Java and C++.
  
 In Scala, every expression has a type. For example, the expression 
 if (x > 0) 1 else 
 -1
  has the type 
 Int
  because both branches have the type 
 Int
 . The type of a mixed-
 type expression, such as
  
 if (x > 0) ""positive"" else -1
  
 is the common supertype of both branches. In this example, one branch is a 
 java.lang.String
 , and the other an 
 Int
 . Their common supertype is called 
 Any
 . (See 
 Section 8.11, “The Scala Inheritance Hierarchy,” on page 96 for details.)
  
 If the 
 else
  part is omitted, for example in
  
 if (x > 0) 1
  
 then it is possible that the 
 if
  statement yields no value. However, in Scala, 
 every expression is supposed to have 
 some
  value. This is finessed by 
 introducing a class 
 Unit
  that has one value, written as 
 ()
 . The 
 if
  statement 
 without an 
 else
  is equivalent to
  
 if (x > 0) 1 else ()",NA
2.2 Statement Termination,"In Java and C++, every statement ends with a semicolon. In Scala—like in 
 JavaScript and other scripting languages—a semicolon is never required if it 
 falls just before the end of the line. A semicolon is also optional before an 
 }
 , an 
 else
 , and similar locations where it is clear from context that the end of a 
 statement has been reached.",NA
2.3 Block Expressions and Assignments,"In Java or C++, a block statement is a sequence of statements enclosed in 
 { }
 . 
 You use a block statement whenever you need to put multiple actions in the 
 body of a branch or loop statement.
  
 In Scala, a 
 { }
  block contains a sequence of 
 expressions
 , and the result is also an 
 expression. The value of the block is the value of the last expression.
  
 This feature can be useful if the initialization of a 
 val
  takes more than one step. 
 For example,
  
 val distance = { val dx = x - x0; val dy = y - y0; 
 sqrt(dx * dx + dy * dy)
  }",NA
2.4 Input and Output,"To print a value, use the 
 print
  or 
 println
  function. The latter adds a new line after 
 the printout. For example,
  
 print(""Answer: "")
  
 println(42)
  
 yields the same output as
  
 println(""Answer: "" + 42)
  
 There is also a 
 printf
  function with a C-style format string:
  
 printf(""Hello, %s! You are %d years old.\n"", ""Fred"", 42)
  
 You can read a line of input from the console with the 
 readLine
  function. To 
 read a numeric, Boolean, or character value, use 
 readInt
 , 
 readDouble
 , 
 readByte
 , 
 readShort
 , 
 readLong
 , 
 readFloat
 , 
 readBoolean
 , or 
 readChar
 . The 
 readLine
  method, but 
 not the other ones, take a prompt string:
  
 val name = readLine(""Your name: "")
  
 print(""Your age: "")
  
 val age = readInt()
  
 printf(""Hello, %s! Next year, you will be %d.\n"", name, age + 1)",NA
2.5 Loops,"Scala has the same 
 while
  and 
 do
  loops as Java and C++. For example,
  
 while (n > 0) {
  
  r = r * n
  
  n -= 1
  
 }
  
 Scala has no direct analog of the 
 for (
 initialize
 ; 
 test
 ; 
 update
 )
  loop. If you need 
 such a loop, you have two choices. You can use a 
 while
  loop. Or, you can use a 
 for
  statement like this:
  
 for (i <- 1 to n) 
  
  r = r * i
  
 You saw the 
 to
  method of the 
 RichInt
 class in Chapter 1. The call 
 1 to n
  returns a 
 Range
  of the numbers from 1 to 
 n
  (inclusive).
  
 The construct
  
 for (i <- 
 expr
 )
  
 makes the variable 
 i
  traverse all values of the expression to the right of the 
 <-
 . 
 Exactly how that traversal works depends on the type of the expression. For a 
 Scala collection, such as a 
 Range
 , the loop makes 
 i
  assume each value in turn.
  
  
 NOTE: There is no 
 val
  or 
 var
  before the variable in the 
 for
  loop. The type of 
 the variable is the element type of the collection.The scope of the loop 
 variable
  
 extends until the end of the loop.
  
 When traversing a string or array, you often need a range from 0 to 
 n
  – 1. In 
 that case, use the 
 until
  method instead of the 
 to
  method. It returns a range that 
 doesn’t include the upper bound.
  
 val s = ""Hello""
  
 var sum = 0
  
 for (i <- 
 0 until s.length
 ) //
  Last value for 
 i
  is 
 s.length - 1 sum 
 += s(i)
  
 In this example, there is actually no need to use indexes. You can directly loop 
 over the characters:
  
 var sum = 0
  
 for (ch <- ""Hello"") sum += ch",NA
2.6 Advanced ,NA,NA
for,NA,NA
 Loops and ,NA,NA
for,NA,NA
 Comprehensions,"In the preceding section, you saw the basic form of the 
 for
  loop. However, this 
 construct is much richer in Scala than in Java or C++. This section covers the 
 advanced features.
  
 You can have multiple 
 generators
  of the form 
 variable
  <-
 expression
 . Separate them 
 by semicolons. For example,
  
 for (i <- 1 to 3; j <- 1 to 3) print((10 * i + j) + "" "") // 
 Prints 
 11 12 13 21 22 23 31 32 33
  
 Each generator can have a 
 guard
 , a Boolean condition preceded by 
 if
 :
  
 for (i <- 1 to 3; j <- 1 to 3 
 if i != j
 ) print((10 * i + j) + "" "") // 
 Prints 
 12 
 13 21 23 31 32
  
 Note that there is no semicolon before the 
 if
 .
  
 You can have any number of 
 definitions
 , introducing variables that can be used 
 inside the loop:
  
 for (i <- 1 to 3; 
 from
  = 4 - i; j <- 
 from
  to 3) print((10 * i + j) + "" "") // 
 Prints 
 13 
 22 23 31 32 33",NA
2.7 Functions,"Scala has functions in addition to methods. A method operates on an object, 
 but a function doesn’t. C++ has functions as well, but in Java, you have to 
 imitate them with static methods.
  
 To define a function, you specify the function’s name, parameters, and body 
 like this:
  
 def abs(x: Double) = if (x >= 0) x else -x
  
 You must specify the types of all parameters. However, as long as the function 
 is not recursive, you need not specify the return type. The Scala compiler 
 deter-mines the return type from the type of the expression to the right of the 
 =
  
 symbol.
  
 If the body of the function requires more than one expression, use a block. The 
 last expression of the block becomes the value that the function returns. For 
 example, the following function returns the value of 
 r
  after the 
 for
  loop.
  
 def fac(n : Int) = {
  
  var r = 1
  
  for (i <- 1 to n) r = r * i
  
  r 
  
 }",NA
2.8 Default and Named Arguments ,"L1
  
 You can provide default arguments for functions that are used when you don’t 
 specify explicit values. For example,
  
 def decorate(str: String, left: String = ""["", right: String = ""]"") =
  
  left + str + right
  
 This function has two parameters, 
 left
  and 
 right
 , with default arguments 
 ""["" 
 and 
 ""]""
 .
  
 If you call 
 decorate(""Hello"")
 , you get 
 ""[Hello]""
 . If you don’t like the defaults, 
 supply your own: 
 decorate(""Hello"", ""<<<"", "">>>"")
 .
  
 If you supply fewer arguments than there are parameters, the defaults are 
 applied from the end. For example, 
 decorate(""Hello"", "">>>["")
  uses the default 
 value of the 
 right
  parameter, yielding 
 "">>>[Hello]""
 .
  
 You can also specify the parameter names when you supply the arguments. For 
 example,
  
 decorate(left = ""<<<"", str = ""Hello"", right = "">>>"")",NA
2.9 Variable Arguments ,"L1
  
 Sometimes, it is convenient to implement a function that can take a variable 
 number of arguments. The following example shows the syntax:
  
 def sum(args: Int*) = {
  
  var result = 0
  
  for (arg <- args) result += arg
  
  result
  
 }
  
 You can call this function with as many arguments as you like.
  
 val s = sum(1, 4, 9, 16, 25)
  
 The function receives a single parameter of type 
 Seq
 , which we will discuss in 
 Chapter 13. For now, all you need to know is that you can use a 
 for
  loop to visit 
 each element.
  
 If you already have a sequence of values, you cannot pass it directly to such a 
 function. For example, the following is not correct:
  
 val s = sum(1 to 5) // 
 Error
  
 If the 
 sum
  function is called with one argument, that must be a single integer, 
 not a range of integers. The remedy is to tell the compiler that you want the 
 parameter to be considered an argument sequence. Append 
 : _*
 , like this:
  
 val s = sum(1 to 5: _*) // 
 Consider 
 1 to 5
  as an argument sequence
  
 This call syntax is needed in a recursive definition:
  
 def sum(args: Int*) : Int = {
  
  if (args.length == 0) 0 
  
  else args.head + recursiveSum(args.tail : _*)
  
 }
  
 Here, the 
 head
  of a sequence is its initial element, and 
 tail
  is a sequence of all 
 other elements. That’s again a 
 Seq
 , and we have to use 
 : _*
  to convert it to an 
 argument sequence.",NA
2.10 Procedures,"Scala has a special notation for a function that returns no value. If the function 
 body is enclosed in braces 
 without a preceding 
 =
 symbol
 , then the return type is 
 Unit
 . Such a function is called a 
 procedure
 . A procedure returns no value, and 
 you only call it for its side effect. For example, the following procedure prints a 
 string inside a box, like
  
 -------
  
 |Hello|
  
 -------
  
 Because the procedure doesn’t return any value, we omit the 
 =
  symbol.
  
 def box(s : String) { //
  Look carefully: no 
 =
  
  val border = ""-"" * s.length + ""--\n""
  
  println(border + ""|"" + s + ""|\n"" + border) 
  
 } 
  
 Some people (not me) dislike this concise syntax for procedures and suggest 
 that you always use an explicit return type of 
 Unit
 :
  
 def box(s : String)
 : Unit =
  { 
  
  ... 
  
 } 
  
  
 CAUTION: The concise procedure syntax can be a surprise for Java and 
 C++ programmers. It is a common error to accidentally omit the 
 =
  in a 
 function
  
 definition.You then get an error message at the point where the function is 
 called, and you are told that 
 Unit
  is not acceptable at that location.",NA
2.11 Lazy Values ,"L1
  
 When a 
 val
  is declared as 
 lazy
 , its initialization is deferred until it is accessed for 
 the first time. For example,",NA
2.12 Exceptions,"Scala exceptions work the same way as in Java or C++. When you throw an 
 exception, for example
  
 throw new IllegalArgumentException(""x should not be negative"")
  
 the current computation is aborted, and the runtime system looks for an 
 exception handler that can accept an 
 IllegalArgumentException
 . Control resumes 
 with the innermost such handler. If no such handler exists, the program 
 terminates.
  
 As in Java, the objects that you throw need to belong to a subclass of 
 java.lang.Throwable
 . However, unlike Java, Scala has no “checked” exceptions—
 you never have to declare that a function or method might throw an exception.",NA
Exercises,"1. 
  
 2. 
  
 3. 
  
 4.
  
 The 
 signum
  of a number is 1 if the number is positive, –1 if it is negative, 
 and 0 if it is zero. Write a function that computes this value.
  
 What is the value of an empty block expression 
 {}
 ? What is its type?
  
 Come up with one situation where the assignment 
 x = y = 1
  is valid in Scala.
  
 (Hint: Pick a suitable type for 
 x
 .) 
  
 Write a Scala equivalent for the Java loop
  
 for (int i = 10; i >= 0; i--) System.out.println(i); 
  
 5. 
  
 6. 
  
 7. 
  
 8.
  
 Write a procedure 
 countdown(n: Int)
  that prints the numbers from 
 n
  to 0. 
 Write a 
 for
  loop for computing the product of the Unicode codes of all 
 letters in a string. For example, the product of the characters in 
 ""Hello""
  is 
 825152896
 . Solve the preceding exercise without writing a loop. (Hint: Look 
 at the 
 StringOps 
 Scaladoc.) 
  
 Write a function 
 product(s : String)
  that computes the product, as described in 
 the preceding exercises.",NA
Working with Arrays,NA,NA
Topics in This Chapter  ,"A1
  
 3.1 Fixed-Length Arrays — page 31 
  
 3.2 Variable-Length Arrays: Array Buffers — page 32 
 3.3 Traversing Arrays and Array Buffers — page 33 
 3.4 Transforming Arrays — page 34 
  
 3.5 Common Algorithms — page 35 
  
 3.6 Deciphering Scaladoc — page 37 
  
 3.7 Multidimensional Arrays — page 38 
  
 3.8 Interoperating with Java — page 39 
  
 Exercises — page 39",NA
Chapter,NA,NA
3,"In this chapter, you will learn how to work with arrays in Scala. Java and C++ 
 programmers usually choose an array or its close relation (such as array lists or 
 vectors) when they need to collect a bunch of elements. In Scala, there are 
 other choices (see Chapter 13), but for now, I’ll assume you are impatient and 
 just want to get going with arrays.
  
 Key points of this chapter:
  
 •
 •
 •
 •
 •
 •
  
 Use an 
 Array
  if the length is fixed, and an 
 ArrayBuffer
  if the length can 
 vary. Don’t use 
 new
  when supplying initial values.
  
 Use 
 ()
  to access elements.
  
 Use 
 for (elem <- arr)
  to traverse the elements.
  
 Use 
 for (elem <- arr if
  . . .  
 )
  . . .  
 yield
  . . .  to transform into a new array. Scala 
 and Java arrays are interoperable; with 
 ArrayBuffer
 , use 
 scala.collection. 
 JavaConversions
 .",NA
3.1 Fixed-Length Arrays,"If you need an array whose length doesn’t change, use the 
 Array
  type in Scala. 
 For example,
  
 31",NA
3.2 Variable-Length Arrays: Array Buffers,"Java has 
 ArrayList
  and C++ has 
 vector
  for arrays that grow and shrink on 
 demand. The equivalent in Scala is the 
 ArrayBuffer
 .
  
 import scala.collection.mutable.ArrayBuffer 
  
 val b = ArrayBuffer[Int]()
  
  // 
 Or 
 new ArrayBuffer[Int]
  
  // 
 An empty array buffer, ready to hold integers 
  
 b += 1
  
  // ArrayBuffer(1)
  
  // 
 Add an element at the end with 
 += 
  
 b += (1, 2, 3, 5)
  
  // ArrayBuffer(1, 
 1, 2, 3, 5
 )
  
  // 
 Add multiple elements at the end by enclosing them in parentheses 
 b 
 ++= Array(8, 13, 21)
  
  // ArrayBuffer(1, 1, 2, 3, 5, 
 8, 13, 21
 )
  
  // 
 You can append any collection with the 
 ++=
  operator 
  
 b.trimEnd(5)
  
  // ArrayBuffer(1, 1, 2)
  
  // 
 Removes the last five elements
  
 Adding or removing elements at the end of an array buffer is an efficient 
 (“amortized constant time”) operation.",NA
3.3 Traversing Arrays and Array Buffers,"In Java and C++, there are several syntactical differences between arrays and 
 array lists/vectors. Scala is much more uniform. Most of the time, you can use 
 the same code for both.
  
 Here is how you traverse an array or array buffer with a 
 for
  loop:
  
 for (i <- 0 until a.length) 
  
  println(i + "": "" + a(i))
  
 The variable 
 i
  goes from 
 0
  to 
 a.length - 1
 .
  
 The 
 until
  method belongs to the 
 RichInt
  class, and it returns all numbers up to 
 (but not including) the upper bound. For example,
  
 0 until 10 
  
  // Range(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  
 Note that 
 0 until 10
  is actually a method call 
 0.until(10)
 .",NA
3.4 Transforming Arrays,"In the preceding sections, you saw how to work with arrays just like you 
 would in Java or C++. But in Scala, you can go further. It is very easy to take an 
 array (or array buffer) and transform it in some way. Such transformations 
 don’t modify the original array, but they yield a new one.
  
 Use a 
 for
  comprehension like this:
  
 val a = Array(2, 3, 5, 7, 11)
  
 val result = 
 for
  (elem <- a) 
 yield
  2 * elem
  
  // result
  is 
 Array(4, 6, 10, 14, 22)
  
 The 
 for (...) yield
  loop creates a new collection of the same type as the original 
 collection. If you started with an array, you get another array. If you started 
 with an array buffer, that’s what you get from 
 for (...) yield
 .
  
 The result contains the expressions after the 
 yield
 , one for each iteration of the 
 loop.
  
 Oftentimes, when you traverse a collection, you only want to process the 
 elements that match a particular condition. This is achieved with a 
 guard
 : an 
 if
  
 inside the 
 for
 . Here we double every even element, dropping the odd ones:
  
 for (elem <- a 
 if a % 2 == 0
 ) yield 2 * elem
  
 Keep in mind that the result is a new collection—the original collection is not 
 affected.",NA
3.5 Common Algorithms,"It is often said that a large percentage of business computations are nothing 
 but computing sums and sorting. Fortunately, Scala has built-in functions for 
 these tasks.",NA
3.6 Deciphering Scaladoc,"There are lots of useful methods on arrays and array buffers, and it is a good 
 idea to browse the Scala documentation to get an idea of what’s there.
  
  
 NOTE: The methods for the 
 Array
  class are listed under 
 ArrayOps
 .Technically, an array is converted to an 
 ArrayOps
  object before 
 any of the operations is
  
 applied.
  
 Because Scala has a richer type system than Java, you may encounter some 
 strange-looking syntax as you browse the Scala documentation. Fortunately, 
 you don’t have to understand all nuances of the type system to do useful 
 work.
  
 Use Table 3–1 as a “decoder ring.”
  
 Table 3–1
  Scaladoc Decoder Ring
  
 Scaladoc
  
 Explanation
  
  
 def count(
 p: (A) => Boolean
 ): Int
  
 This method takes a 
 predicate
 , a function 
 from 
 A
  to Boolean. It counts for how 
 many elements the function is true. For 
 example, 
 a.count(_ > 0)
  counts how many 
 elements of 
 a
  are positive.
  
 def append(elems: 
 A*
 ): Unit
  
 This method takes 
 zero or more
  arguments 
 of type 
 A
 . For example, 
 b.append(1, 7, 2, 9) 
 appends four elements to 
 b
 .
  
 def appendAll(xs: 
 TraversableOnce[A]
 ): Unit
  
 The 
 xs
  parameter can be any collection 
 with the 
 TraversableOnce
  trait, the most 
  
 general trait in the Scala collections 
  
 hierarchy. Other common traits that you 
 may encounter in Scaladoc are 
 Traversable 
 and 
 Iterable
 . All Scala collections 
  
 implement these traits, and the difference 
 between them is academic for library 
 users. Simply think “any collection” 
 when you see one of these.",NA
3.7 Multidimensional Arrays,NA,NA
3.8 Interoperating with Java,"Since Scala arrays are implemented as Java arrays, you can pass them back and 
 forth between Java and Scala.
  
 If you call a Java method that receives or returns a 
 java.util.List
 , you could, of 
 course, use a Java 
 ArrayList
  in your Scala code—but that is unattractive. 
 Instead, 
 import 
 the 
 implicit 
 conversion 
 methods 
 in 
 scala.collection.JavaConversions
 . Then you can use Scala buffers in your code, and 
 they automatically get wrapped into Java lists when calling a Java method.
  
 For example, the 
 java.lang.ProcessBuilder
  class has a constructor with a 
 List<String> 
 parameter. Here is how you can call it from Scala:
  
 import scala.collection.JavaConversions.bufferAsJavaList
  
 import scala.collection.mutable.ArrayBuffer
  
 val command = ArrayBuffer(""ls"", ""-al"", ""/home/cay"")
  
 val pb = new ProcessBuilder(command) // 
 Scala to Java
  
 The Scala buffer is wrapped into an object of a Java class that implements the 
 java.util.List
  interface.
  
 Conversely, when a Java method returns a 
 java.util.List
 , you can have it 
 automatically converted into a 
 Buffer
 :
  
 import scala.collection.JavaConversions.asScalaBuffer
  
 import scala.collection.mutable.Buffer
  
 val cmd : Buffer[String] = pb.command() // 
 Java to Scala
  
  // 
 You can’t use 
 ArrayBuffer
 —the wrapped object is only guaranteed to be a 
 Buffer
  
 If the Java method returns a wrapped Scala buffer, then the implicit conversion 
 unwraps the original object. In our example, 
 cmd == command
 .",NA
Exercises,"1. 
 2. 
 3.
  
 Write a code snippet that sets 
 a
  to an array of 
 n
  random integers between 
 0 
 (inclusive) and 
 n
  (exclusive).
  
 Write a loop that swaps adjacent elements of an array of integers. For 
 example, 
 Array(1, 2, 3, 4, 5)
  becomes 
 Array(2, 1, 4, 3, 5)
 .
  
 Repeat the preceding assignment, but produce a new array with the 
 swapped values. Use 
 for
 /
 yield
 .",NA
Maps and Tuples,NA,NA
Topics in This Chapter  ,"A1
  
 4.1 Constructing a Map — page 43 
  
 4.2 Accessing Map Values — page 44 
  
 4.3 Updating Map Values — page 45 
  
 4.4 Iterating over Maps — page 45 
  
 4.5 Sorted Maps — page 46 
  
 4.6 Interoperating with Java — page 46 
  
 4.7 Tuples — page 47 
  
 4.8 Zipping — page 48 
  
 Exercises — page 48",NA
Chapter,NA,NA
4,"A classic programmer’s saying is, “If you can only have one data structure, 
 make it a hash table.” Hash tables—or, more generally, maps—are among the 
 most versatile data structures. As you will see in this chapter, Scala makes it 
 particularly easy to use them.
  
 Maps are collections of key/value pairs. Scala has a general notation of 
 tuples—aggregates of 
 n
  objects, not necessarily of the same type. A pair is 
 simply a tuple with 
 n
  = 2. Tuples are useful whenever you need to aggregate 
 two or more values together, and we briefly discuss the syntax at the end of 
 this chapter.
  
 Highlights of the chapter are:
  
 •
  
 Scala has a pleasant syntax for creating, querying, and traversing 
 maps.•
  
 You need to choose between mutable and immutable maps.
  
 •
  
 By default, you get a hash map, but you can also get a tree map.
  
  
 You can easily convert between Scala and Java 
 maps.•
  
 •
  
 Tuples are useful for aggregating values.",NA
4.1 Constructing a Map,"You can construct a map as
  
 val scores = Map(""Alice"" -> 10, ""Bob"" -> 3, ""Cindy"" -> 8)",NA
4.2 Accessing Map Values,"In Scala, the analogy between functions and maps is particularly close because 
 you use the 
 ()
  notation to look up key values.
  
 val bobsScore = scores(""Bob"") // 
 Like 
 scores.get(""Bob"")
  in Java
  
 If the map doesn’t contain a value for the requested key, an exception is 
 thrown.
  
 To check whether there is a key with the given value, call the 
 contains
  method:
  
 val bobsScore = if (scores.contains(""Bob"")) scores(""Bob"") else 0
  
 Since this call combination is so common, there is a shortcut:
  
 val bobsScore = scores.getOrElse(""Bob"", 0)
  
  //
  If the map contains the key 
 ""Bob""
 , return the value; otherwise, return 
 0
 .
  
 Finally, the call 
 map
 .get(
 key
 )
  returns an 
 Option
  object that is either 
 Some(
 value for 
 key
 )
  or 
 None
 . We discuss the 
 Option
 class in Chapter 14.",NA
4.3 Updating Map Values,"In a mutable map, you can update a map value, or add a new one, with a 
 ()
  to 
 the left of an 
 =
  sign:
  
 scores(""Bob"") = 10 
  
  //
  Updates the existing value for the key 
 ""Bob""
  (assuming 
 scores
  is mutable) 
 scores(""Fred"") = 7 
  
  //
  Adds a new key/value pair to 
 scores
  (assuming it is mutable)
  
 Alternatively, you can use the 
 +=
  operation to add multiple associations:
  
 scores += (""Bob"" -> 10, ""Fred"" -> 7) 
  
 To remove a key and its associated value, use the 
 -=
  operator:
  
 scores -= ""Alice""
  
 You can’t update an immutable map, but you can do something that’s just as 
 useful—obtain a new map that has the desired update:
  
 val newScores = scores + (""Bob"" -> 10, ""Fred"" -> 7) //
  New map with update
  
 The 
 newScores
  map contains the same associations as 
 scores
 , except that 
 ""Bob""
  has 
 been updated and 
 ""Fred""
  added.
  
 Instead of saving the result as a new value, you can update a 
 var
 :
  
 var scores = ...
  
 scores = scores + (""Bob"" -> 10, ""Fred"" -> 7)
  
 Similarly, to remove a key from an immutable map, use the 
 -
  operator to obtain 
 a new map without the key:
  
 scores = scores - ""Alice""
  
 You might think that it is inefficient to keep constructing new maps, but that is 
 not the case. The old and new maps share most of their structure. (This is 
 possible because they are immutable.)",NA
4.4 Iterating over Maps,"The following amazingly simple loop iterates over all key/value pairs of a map:
  
 for ((k, v) <- 
 map
 ) 
 process 
 k
  and 
 v
  
 The magic here is that you can use pattern matching in a Scala 
 for
  loop. 
 (Chapter 14 has all the details.) That way, you get the key and value of each 
 pair in the map without any tedious method calls.",NA
4.5 Sorted Maps,"When working with a map, you need to choose an implementation—a hash 
 table or a balanced tree. By default, Scala gives you a hash table. You might 
 want a tree map if you don’t have a good hash function for the keys, or if you 
 need to visit the keys in sorted order.
  
 To get an immutable tree map instead of a hash map, use
  
 val scores = scala.collection.immutable.SortedMap(""Alice"" -> 10, 
  
  ""Fred"" -> 7, ""Bob"" -> 3, ""Cindy"" -> 8)
  
 Unfortunately, there is (as of Scala 2.9) no mutable tree map. Your best bet is to 
 adapt a Java 
 TreeMap
 , as described in Chapter 13.
  
  
 TIP: If you want to visit the keys in insertion order, use a 
 LinkedHashMap
 . 
 For example,
  
 val months = scala.collection.mutable.LinkedHashMap(""January"" -> 1,
  
  ""February"" -> 2, ""March"" -> 3, ""April"" -> 4, ""May"" -> 5, ...)",NA
4.6 Interoperating with Java,"If you get a Java map from calling a Java method, you may want to convert it 
 to a Scala map so that you can use the pleasant Scala map API. This is also 
 useful if you want to work with a mutable tree map, which Scala doesn’t 
 provide.
  
 Simply add an 
 import
  statement:
  
 import scala.collection.JavaConversions.mapAsScalaMap
  
 Then trigger the conversion by specifying the Scala map type:
  
 val scores: scala.collection.mutable.Map[String, Int] = 
  
  new java.util.TreeMap[String, Int]
  
 In addition, you can get a conversion from 
 java.util.Properties
  to a 
 Map[String, 
 String]
 :",NA
4.7 Tuples ,"Maps are collections of key/value pairs. Pairs are the simplest case of 
 tuples
 —
 aggregates of values of different types.
  
 A tuple value is formed by enclosing individual values in parentheses. For 
 example, 
  
  
 (1, 3.14, ""Fred"") 
  
 is a tuple of type 
  
  
 Tuple3[Int, Double, java.lang.String] 
  
 which is also written as 
  
  
 (Int, Double, java.lang.String) 
  
 If you have a tuple, say, 
  
  
 val t = (1, 3.14, ""Fred"") 
  
 then you can access its components with the methods 
 _1
 , 
 _2
 , 
 _3
 , for example: 
  
 val second = t._2 // 
 Sets 
 second
  to 
 3.14 
  
 Unlike array or string positions, the component positions of a tuple start with 
 1
 , 
 not 
 0
 .
  
  
 NOTE: You can write 
 t._2
  as 
 t _2
  (with a space instead of a period), but 
 not 
 t_2
 .
  
 Usually, it is better to use pattern matching to get at the components of a tuple, 
 for example 
  
  
 val (first, second, third) = t //
  Sets 
 first
  to 
 1
 , 
 second
  to 
 3.14
 , 
 third
  to 
 ""Fred"" 
  
 You can use a 
 _
  if you don’t need all components: 
  
  
 val (first, second, _) = t",NA
4.8 Zipping,"One reason for using tuples is to bundle together values so that they can be 
 pro-cessed together. This is commonly done with the 
 zip
  method. For example, 
 the code
  
 val symbols = Array(""<"", ""-"", "">"")
  
 val counts = Array(2, 10, 2)
  
 val pairs = symbols.zip(counts)
  
 yields an array of pairs
  
 Array((""<"", 2), (""-"", 10), ("">"", 2))
  
 The pairs can then be processed together:
  
 for ((s, n) <- pairs) Console.print(s * n) //
  Prints 
 <<---------->>
  
  
 TIP: The 
 toMap
  method turns a collection of pairs into a map.
  
 If you have a collection of keys and a parallel collection of values, then zip
  
 them up and turn them into a map like this:
  
 keys.zip(values).toMap",NA
Exercises,"1. 
  
 2.
  
 Set up a map of prices for a number of gizmos that you covet. Then 
 produce a second map with the same keys and the prices at a 10 percent 
 discount.
  
 Write a program that reads words from a file. Use a mutable map to count 
 how often each word appears. To read the words, simply use a 
 java.util.Scanner
 :
  
 val in = new java.util.Scanner(java.io.File(""myfile.txt""))
  
 while (in.hasNext()) 
 process
  in.next()
  
 Or look at Chapter 9 for a Scalaesque way.
  
 At the end, print out all words and their counts.
  
 3. 
  
 4.
  
 Repeat the preceding exercise with an immutable map.
  
 Repeat the preceding exercise with a sorted map, so that the words are 
 printed in sorted order.",NA
Classes,NA,NA
Topics in This Chapter  ,"A1
  
 5.1 Simple Classes and Parameterless Methods — page 51 
 5.2 Properties with Getters and Setters — page 52 
  
 5.3 Properties with Only Getters — page 55 
  
 5.4 Object-Private Fields — page 56 
  
 5.5 Bean Properties 
 L1
  — page 57 
  
 5.6 Auxiliary Constructors — page 58 
  
 5.7 The Primary Constructor — page 59 
  
 5.8 Nested Classes 
 L1
  — page 62 
  
 Exercises — page 65",NA
Chapter,NA,NA
5,"In this chapter, you will learn how to implement classes in Scala. If you know 
 classes in Java or C++, you won’t find this difficult, and you will enjoy the 
 much more concise notation of Scala.
  
 The key points of this chapter are:
  
 •
 •
 •
 •
  
 •
  
 Fields in classes automatically come with getters and setters.
  
 You can replace a field with a custom getter/setter without changing the 
 client of a class—that is the “uniform access principle.”
  
 Use the 
 @BeanProperty
  annotation to generate the JavaBeans 
 getXxx
 /
 setXxx 
 methods.
  
 Every class has a primary constructor that is “interwoven” with the class 
 definition. Its parameters turn into the fields of the class. The primary 
 constructor executes all statements in the body of the class.
  
 Auxiliary constructors are optional. They are called 
 this
 .",NA
5.1 Simple Classes and Parameterless Methods,"In its simplest form, a Scala class looks very much like its equivalent in Java or 
 C++:
  
 51",NA
5.2 Properties with Getters and Setters,"When writing a Java class, we don’t like to use public fields:
  
 public class Person { //
  This is Java
  
  public int age; // 
 Frowned upon in Java 
  
 }",NA
5.3 Properties with Only Getters,"Sometimes you want a 
 read-only property
  with a getter but no setter. If the value 
 of the property never changes after the object has been constructed, use a 
 val 
 field:
  
 class Message { 
  
  val timeStamp = new java.util.Date
  
  ...
  
 }
  
 Scala makes a private 
 final
  field and a getter method, but no setter.
  
 Sometimes, however, you want a property that a client can’t set at will, but 
 that is mutated in some other way. The 
 Counter
  class from Section 5.1, “Simple 
 Classes and Parameterless Methods,” on page 51 is a good example. 
 Conceptually, the counter has a 
 current
  property that is updated when the 
 increment
  method is called, but there is no setter for the property.
  
 You can’t implement such a property with a 
 val
 —a 
 val
  never changes. Instead, 
 provide a private field and a property getter, like this:
  
 class Counter { 
  
 private var value = 0
  
  def increment() { value += 1 } 
  
  
 def current = value
  // 
 No 
 ()
  in declaration 
  
 }",NA
5.4 Object-Private Fields,"In Scala (as well as in Java or C++), a method can access the private fields of 
 all 
 objects of its class. For example,
  
 class Counter {
  
  private var value = 0
  
  def increment() { value += 1 }
  
  def isLess(other : Counter) = value < 
 other.
 value 
  
  // 
 Can access private field of other object 
  
 }
  
 Accessing 
 other.value
  is legal because 
 other
  is also a 
 Counter
  object.
  
 Scala allows an even more severe access restriction, with the 
 private[this]
  
 qualifier:
  
 private[this] var value = 0 //
  Accessing 
 someObject
 .value
  is not allowed
  
 Now, the methods of the 
 Counter
  class can only access the 
 value
  field of the 
 current object, not of other objects of type 
 Counter
 . This access is sometimes 
 called 
 object-private
 , and it is common in some OO languages, such as 
 SmallTalk.
  
 With a class-private field, Scala generates private getter and setter methods. 
 However, for an object-private field, no getters and setters are generated at all.",NA
5.5 Bean Properties ,"L1
  
 As you saw in the preceding sections, Scala provides getter and setter methods 
 for the fields that you define. However, the names of these methods are not 
 what Java tools expect. The JavaBeans specification (www.oracle.com/ 
 technetwork/java/javase/tech/index-jsp-138795.html) defines a Java property as 
 a pair of 
 getFoo
 /
 setFoo
  methods (or just a 
 getFoo
  method for a read-only 
 property). Many Java tools rely on this naming convention.
  
 When you annotate a Scala field with 
 @BeanProperty
 , then such methods are 
 automatically generated. For example,
  
 import scala.reflect.BeanProperty
  
 class Person {
  
  @BeanProperty var name: String = _ 
  
 }
  
 generates 
 four
  methods:
  
 1. 
  
 name: String
  
 2. 
  
 name_=(newValue: String): Unit
  
 3. 
  
 getName(): String
  
 4. 
  
 setName(newValue: String): Unit
  
 Table 5–1 shows which methods are generated in all cases.
  
  
 NOTE: If you define a field as a primary constructor parameter (see 
  
 Section 5.7, “The Primary Constructor,” on page 59), and you want 
 JavaBeans
  
 getters and setters, annotate the constructor parameter like this:
  
 class Person(@BeanProperty var name: String)",NA
5.6 Auxiliary Constructors,"As in Java or C++, a Scala class can have as many constructors as you like. 
 However, a Scala class has one constructor that is more important than all the 
 others, called the 
 primary constructor
 . In addition, a class may have any number 
 of 
 auxiliary constructors
 .
  
 We discuss auxiliary constructors first because they are easier to understand. 
 They are very similar to constructors in Java or C++, with just two differences.
  
 1.
  
 2.
  
 The auxiliary constructors are called 
 this
 . (In Java or C++, constructors have 
 the same name as the class—which is not so convenient if you rename the 
 class.)
  
 Each auxiliary constructor 
 must
  start with a call to a previously defined 
 auxiliary constructor or the primary constructor.",NA
5.7 The Primary Constructor,"In Scala, every class has a primary constructor. The primary constructor is not 
 defined with a 
 this
  method. Instead, it is interwoven with the class definition.
  
 1.
  
 The parameters of the primary constructor are placed 
 immediately after the 
 class name
 .
  
 class Person
 (val name: String, val age: Int)
  { 
  
  //
  Parameters of primary constructor in 
 (...)
  
  ...
  
 }
  
 Parameters of the primary constructor turn into fields that are initialized 
 with the construction parameters. In our example, 
 name
  and 
 age
  become 
 fields of the 
 Person
  class. A constructor call such as 
 new Person(""Fred"", 42)
  
 sets the 
 name
  and 
 age
  fields.
  
 Half a line of Scala is the equivalent of seven lines of Java:",NA
5.8 Nested Classes ,"L1
  
 In Scala, you can nest just about anything inside anything. You can define 
 func-tions inside other functions, and classes inside other classes. Here is a 
 simple example of the latter.",NA
Exercises,"1. 
 2. 
 3.
  
 4.
  
 5.
  
 6. 
 7.
  
 8.
  
 9.
  
 Improve the 
 Counter
  class in Section 5.1, “Simple Classes and Parameterless 
 Methods,” on page 51 so that it doesn’t turn negative at 
 Int.MaxValue
 .
  
 Write a class 
 BankAccount
  with methods 
 deposit
  and 
 withdraw
 , and a read-only 
 property 
 balance
 .
  
 Write a class 
 Time
  with read-only properties 
 hours
  and 
 minutes
  and a 
 method 
 before(other: Time): Boolean
  that checks whether this time comes 
 before the other. A 
 Time
  object should be constructed as 
 new Time(hrs, min)
 , 
 where 
 hrs
  is in military time format (between 0 and 23).
  
 Reimplement the 
 Time
  class from the preceding exercise so that the internal 
 representation is the number of minutes since midnight (between 0 and 24 
 × 60 – 1).
  Do not
  change the public interface. That is, client code should be 
 unaffected by your change.
  
 Make a class 
 Student
  with read-write JavaBeans properties 
 name
  (of type 
 String
 ) and 
 id
  (of type 
 Long
 ). What methods are generated? (Use 
 javap
  to 
 check.) Can you call the JavaBeans getters and setters in Scala? Should 
 you?
  
 In the 
 Person
  class of Section 5.1, “Simple Classes and Parameterless 
 Methods,”on page 51, provide a primary constructor that turns negative 
 ages to 0.
  
 Write a class 
 Person
  with a primary constructor that accepts a string 
 containing a first name, a space, and a last name, such as 
 new Person(""Fred 
 Smith"")
 . Supply read-only properties 
 firstName
  and 
 lastName
 . Should the 
 primary constructor parameter be a 
 var
 , a 
 val
 , or a plain parameter? Why?
  
 Make a class 
 Car
  with read-only properties for manufacturer, model name, 
 and model year, and a read-write property for the license plate. Supply 
 four constructors. All require the manufacturer and model name. 
 Optionally, model year and license plate can also be specified in the 
 constructor. If not, the model year is set to 
 -1
  and the license plate to the 
 empty string. Which constructor are you choosing as the primary 
 constructor? Why?
  
 Reimplement the class of the preceding exercise in Java, C#, or C++ (your 
 choice). How much shorter is the Scala class?
  
 10. Consider the class
  
 class Employee(val name: String, var salary: Double) { 
 def this() { this(""John Q. Public"", 0.0) } 
  
 }
  
 Rewrite it to use explicit fields and a default primary constructor. Which 
 form do you prefer? Why?",NA
Objects,NA,NA
Topics in This Chapter  ,"A1
  
 6.1 Singletons — page 67 
  
 6.2 Companion Objects — page 68 
  
 6.3 Objects Extending a Class or Trait — page 69 
 6.4 The 
 apply
  Method — page 69 
  
 6.5 Application Objects — page 70 
  
 6.6 Enumerations — page 71 
  
 Exercises — page 73",NA
Chapter,NA,NA
6,"In this short chapter, you will learn when to use the 
 object
  construct in Scala. 
 Use it when you need a class with a single instance, or when you want to find 
 a home for miscellaneous values or functions.
  
 The key points of this chapter are:
  
 •
 •
 •
 •
  
 •
 •
  
 Use objects for singletons and utility methods.
  
 A class can have a companion object with the same name.
  
 Objects can extend classes or traits.
  
 The 
 apply
  method of an object is usually used for constructing new instances 
 of the companion class.
  
 To avoid the 
 main
  method, use an object that extends the 
 App
  trait.
  
 You can implement enumerations by extending the 
 Enumeration
  object.",NA
6.1 Singletons,"Scala has no static methods or fields. Instead, you use the 
 object
  construct. An 
 object defines a single instance of a class with the features that you want. For 
 example,
  
 object Accounts {
  
  private var lastNumber = 0
  
  def newUniqueNumber() = { lastNumber += 1; lastNumber }
  
 }
  
 67",NA
6.2 Companion Objects,"In Java or C++, you often have a class with both instance methods and static 
 methods. In Scala, you achieve this by having a class and a “companion” object 
 of the same name. For example,
  
 class Account {
  
  val id = Account.newUniqueNumber()
  
  private var balance = 0.0
  
  def deposit(amount: Double) { balance += amount }
  
  ...
  
 }
  
 object Account { // 
 The companion object
  
  private var lastNumber = 0
  
  private def newUniqueNumber() = { lastNumber += 1; lastNumber }
  
 }
  
 The class and its companion object can access each other’s private features. 
 They must be located in the 
 same source file
 .",NA
6.3 Objects Extending a Class or Trait,"An 
 object
  can extend a class and/or one or more traits. The result is an object of 
 a class that extends the given class and/or traits, and in addition has all of the 
 features specified in the object definition.
  
 One useful application is to specify default objects that can be shared. For 
 example, consider a class for undoable actions in a program.
  
 abstract class UndoableAction(val description: String) { 
 def undo(): Unit
  
  def redo(): Unit 
  
 }
  
 A useful default is the “do nothing” action. Of course, we only need one of them.
  
 object DoNothingAction extends UndoableAction(""Do 
 nothing"") { override def undo() {}
  
  override def redo() {} 
  
 }
  
 The 
 DoNothingAction
  object can be shared across all places that need this default.
  
 val actions = Map(""open"" -> 
 DoNothingAction
 , ""save"" -> 
 DoNothingAction
 , 
 ...) // 
 Open and save not yet implemented",NA
6.4 The ,NA,NA
apply,NA,NA
 Method,"It is common to have objects with an 
 apply
  method. The 
 apply
  method is called 
 for expressions of the form
  
 Object
 (
 arg1
 , ..., 
 argN
 )
  
 Typically, such an 
 apply
  method returns an object of the companion class.",NA
6.5 Application Objects,"Each Scala program must start with an object’s 
 main
  method of type 
 Array[String] 
 => Unit
 :
  
 object Hello {
  
  def main(args: Array[String]) {
  
  
  println(""Hello, World!"")
  
  } 
  
 }
  
 Instead of providing a 
 main
  method for your application, you can extend the 
 App 
 trait and place the program code into the constructor body:",NA
6.6 Enumerations,"Unlike Java or C++, Scala does not have enumerated types. However, the 
 standard library provides an 
 Enumeration
  helper class that you can use to 
 produce enumerations.
  
 Define an object that extends the 
 Enumeration
  class and initialize each value in 
 your enumeration with a call to the 
 Value
  method. For example,
  
 object TrafficLightColor extends Enumeration {
  
  val Red, Yellow, Green = Value 
  
 }
  
 Here we define three fields, 
 Red
 , 
 Yellow
 , and 
 Green
 , and initialize each of them 
 with a call to 
 Value
 . This is a shortcut for",NA
Exercises,"1. 
 2.
  
 3. 
 4. 
 5.
  
 6. 
 7. 
 8.
  
 Write an object 
 Conversions
  with methods 
 inchesToCentimeters
 , 
 gallonsToLiters
 , 
 and 
 milesToKilometers
 .
  
 The preceding problem wasn’t very object-oriented. Provide a general 
 super-class 
 UnitConversion
  
 and 
 define 
 objects 
 InchesToCentimeters
 , 
 GallonsToLiters
 , and 
 MilesToKilometers
  that extend it.
  
 Define an 
 Origin
  object that extends 
 java.awt.Point
 . Why is this not actually a 
 good idea? (Have a close look at the methods of the 
 Point
  class.)
  
 Define a 
 Point
  class with a companion object so that you can construct 
 Point 
 instances as 
 Point(3, 4)
 , without using 
 new
 .
  
 Write a Scala application, using the 
 App
  trait, that prints the command-line 
 arguments in reverse order, separated by spaces. For example, 
 scala Reverse 
 Hello World
  should print 
 World Hello
 .
  
 Write an enumeration describing the four playing card suits so that the 
 toString 
 method returns 
 
 , 
 
 , 
 
 , or 
 
 .
  
 Implement a function that checks whether a card suit value from the 
 preceding exercise is red.
  
 Write an enumeration describing the eight corners of the RGB color cube. As 
 IDs, use the color values (for example, 
 0xff0000
  for 
 Red
 ).",NA
Packages and Imports,NA,NA
Topics in This Chapter  ,"A1
  
 7.1 Packages — page 76 
  
 7.2 Scope Rules — page 77 
  
 7.3 Chained Package Clauses — page 79 
  
 7.4 Top-of-File Notation — page 79 
  
 7.5 Package Objects — page 80 
  
 7.6 Package Visibility — page 80 
  
 7.7 Imports — page 81 
  
 7.8 Imports Can Be Anywhere — page 82 
  
 7.9 Renaming and Hiding Members — page 82 
 7.10 Implicit Imports — page 82 
  
 Exercises — page 83",NA
Chapter,NA,NA
7,"In this chapter, you will learn how packages and import statements work in 
 Scala. Both packages and imports are more regular than in Java; they are also a 
 bit more flexible.
  
 The key points of this chapter are:
  
 •
 •
 •
  
 •
 •
 •
 •
 •
 •
  
 Packages nest just like inner classes.
  
 Package paths are 
 not
  absolute.
  
 A chain 
 x.y.z
  in a package clause leaves the intermediate packages 
 x
  and 
 x.y 
 invisible.
  
 Package statements without braces at the top of the file extend to the entire 
 file. A package object can hold functions and variables.
  
 Import statements can import packages, classes, and objects.
  
 Import statements can be anywhere.
  
 Import statements can rename and hide members.
  
 java.lang
 , 
 scala
 , and 
 Predef
  are always imported.
  
 75",NA
7.1 Packages,"Packages in Scala fulfill the same purpose as packages in Java or namespaces in 
 C++: to manage names in a large program. For example, the name 
 Map
  can 
 occur in the packages 
 scala.collection.immutable
  and 
 scala.collection.mutable
  without 
 conflict. To access either name, you can use the fully qualified 
 scala.collection.immutable.Map 
 or 
 scala.collection.mutable.Map
 . Alternatively, use an 
 import
  statement to provide a shorter alias—see Section 7.7, “Imports,” on page 
 81.
  
 To add items to a package, you can include them in package statements, such 
 as:
  
 package com {
  
  package horstmann {
  
  
  package impatient {
  
   
  class Employee
  
   
  ...
  
  
  }
  
  } 
  
 }
  
 Then the class name 
 Employee
  can be accessed anywhere as 
 com.horstmann.impatient. Employee
 .
  
 Unlike the definition of an object or a class, a package can be defined in 
 multiple files. The preceding code might be in a file 
 Employee.scala
 , and a file 
 Manager.scala 
 might contain
  
 package com {
  
  package horstmann {
  
  
  package impatient {
  
   
  class Manager
  
   
  ...
  
  
  }
  
  } 
  
 }
  
  
 NOTE: There is no enforced relationship between the directory of the source 
 file and the package.You don’t have to put 
 Employee.scala
  and 
 Manager.scala
  
 into a 
 com/horstmann/impatient
  directory.
  
 Conversely, you can contribute to more than one package in a single file. The 
 file 
 Employee.scala
  can contain",NA
7.2 Scope Rules,"In Scala, the scope rules for packages are more consistent than those in Java. 
 Scala packages nest just like all other scopes. You can access names from the 
 enclosing scope. For example,
  
 package com {
  
  package horstmann {
  
  
  object Utils {
  
    
  def percentOf(value: Double, rate: Double) = value * rate / 100
  
   
  ...
  
  }
  
  package impatient {
  
  
  class Employee {
  
  
  ...
  
    
  def giveRaise(rate: scala.Double) { 
  
      
  salary += 
 Utils.percentOf
 (salary, rate) 
  
    
  }        
  
    
  }
  
  
  }
  
  } 
  
 }
  
 Note the 
 Utils.percentOf
  qualifier. The 
 Utils
  class was defined in the 
 parent
  
 package. Everything in the parent package is in scope, and it is not necessary 
 to use 
 com.horstmann.Utils.percentOf
 . (You could, though, if you prefer—after all, 
 com
  is also in scope.)",NA
7.3 Chained Package Clauses,"A package clause can contain a “chain,” or path segment, for example:
  
 package com.horstmann.impatient { 
  
  // 
 Members of 
 com
  and 
 com.horstmann
  are 
 not 
 visible 
 here
  package people { 
  
  
  class Person 
  
  
  ...
  
  } 
  
 }
  
 Such a clause limits the visible members. Now a 
 com.horstmann.collection
  package 
 would no longer be accessible as 
 collection
 .",NA
7.4 Top-of-File Notation,"Instead of the nested notation that we have used up to now, you can have 
 package 
 clauses at the top of the file, without braces. For example:
  
 package 
 com.horstmann.impatient 
  
 package people
  
 class Person
  
  ...
  
 This is equivalent to
  
 package com.horstmann.impatient 
 { 
  
  package people { 
  
  
  class Person 
  
  
  ...
  
  
  // 
 Until the end of the file
  
  } 
  
 }
  
 This is the preferred notation if all the code in the file belongs to the same 
 package (which is the usual case).",NA
7.5 Package Objects,"A package can contain classes, objects, and traits, but not the definitions of 
 functions or variables. That’s an unfortunate limitation of the Java virtual 
 machine. It would make more sense to add utility functions or constants to a 
 package than to some 
 Utils
  object. Package objects address this limitation.
  
 Every package can have one package object. You define it in the 
 parent
  
 package, and it has the same name as the child package. For example,
  
 package com.horstmann.impatient 
  
 package object
  people {
  
  val defaultName = ""John Q. Public""
  
 }
  
 package people {
  
  class Person {
  
  var name = defaultName // 
 A constant from the package
  }
  
  ...      
  
 }
  
 Note that the 
 defaultName
  value didn’t need to be qualified because it was in the 
 same package. Elsewhere, it is accessible as 
 com.horstmann.impatient.people.defaultName
 .
  
 Behind the scenes, the package object gets compiled into a JVM class with 
 static methods and fields, called 
 package.class
 , inside the package. In our 
 example, that would be a class 
 com.horstmann.impatient.people.package
  with a 
 static field 
 defaultName
 .
  
 (In the JVM, you can use 
 package
  as a class name.)
  
 It is a good idea to use the same naming scheme for source files. Put the 
 package object into a file 
 com/horstmann/impatient/people/package.scala
 . That 
 way, anyone who wants to add functions or variables to a package can find the 
 package object easily.",NA
7.6 Package Visibility,"In Java, a class member that isn’t declared as 
 public
 , 
 private
 , or 
 protected
  is 
 visible in the package containing the class. In Scala, you can achieve the same 
 effect with qualifiers. The following method is visible in its own package:",NA
7.7 Imports,"Imports let you use short names instead of long ones. With the clause
  
 import java.awt.Color
  
 you can write 
 Color
  in your code instead of 
 java.awt.Color
 .
  
 That is the sole purpose of imports. If you don’t mind long names, you’ll never 
 need them.
  
 You can import all members of a package as
  
 import java.awt._
  
 This is the same as the 
 *
  wildcard in Java. (In Scala, 
 *
  is a valid character for an 
 identifier. You could define a package 
 com.horstmann.*.people
 , but please don’t.)
  
 You can also import all members of a class or object.
  
 import java.awt.Color._ 
  
 val c1 = RED // Color.RED 
  
 val c2 = decode(""#ff0000"") // Color.decode
  
 This is like 
 import static
  in Java. Java programmers seem to live in fear of this 
 variant, but in Scala it is commonly used.
  
 Once you import a package, you can access its subpackages with shorter names. 
 For example:
  
 import java.awt._
  
 def handler(evt: event.ActionEvent) { // java.awt.event.ActionEvent ...
  
 }
  
 The 
 event
  package is a member of 
 java.awt
 , and the import brings it into scope.",NA
7.8 Imports Can Be Anywhere,"In Scala, an import statement can be anywhere, not just at the top of a file. The 
 scope of the import statement extends until the end of the enclosing block. For 
 example,
  
 class Manager { 
  
 import scala.collection.mutable._
  
  val subordinates = new ArrayBuffer[Employee]
  
  ...
  
 }
  
 This is a very useful feature, particularly with wildcard imports. It is always a 
 bit worrisome to import lots of names from different sources. In fact, some 
 Java programmers dislike wildcard imports so much that they never use them, 
 but let their IDE generate long lists of imported classes.
  
 By putting the imports where they are needed, you can greatly reduce the 
 potential for conflicts.",NA
7.9 Renaming and Hiding Members,"If you want to import a few members from a package, use a 
 selector
  like this:
  
 import java.awt.{Color, Font}
  
 The selector syntax lets you rename members:
  
 import java.util.{HashMap => JavaHashMap}
  
 import scala.collection.mutable._
  
 Now 
 JavaHashMap
  is a 
 java.util.HashMap
  and plain 
 HashMap
  is a 
 scala.collection. 
 mutable.HashMap
 .
  
 The selector 
 HashMap => _
  hides a member instead of renaming it. This is only 
 useful if you import others:
  
 import java.util.{HashMap => _, _}
  
 import scala.collection.mutable._
  
 Now 
 HashMap
  unambiguously refers to 
 scala.collection.mutable.HashMap
  since 
 java.util.HashMap
  is hidden.",NA
7.10 Implicit Imports,"Every Scala program implicitly starts with
  
 import java.lang._ 
  
 import scala._ 
  
 import Predef._",NA
Exercises,"1. 
  
 Write an example program to demonstrate that
  
 package com.horstmann.impatient
  
 is not the same as
  
 package com
  
 package horstmann
  
 package impatient
  
 2. 
 3.
  
 Write a puzzler that baffles your Scala friends, using a package 
 com
  that isn’t 
 at the top level.
  
 Write a package 
 random
  with functions 
 nextInt(): Int
 , 
 nextDouble(): Double
 , and 
 setSeed(seed: Int): Unit
 . To generate random numbers, use the linear 
 congruential generator
  
 next
  = 
 previous
  × 
 a
  + 
 b
  mod 2
 n
 ,
  
 where 
 a
  = 1664525, 
 b
  = 1013904223, and 
 n
  = 32.
  
 4. 
 5. 
 6. 
 7.
  
 Why do you think the Scala language designers provided the 
 package object 
 syntax instead of simply letting you add functions and variables to a 
 package?
  
 What is the meaning of 
 private[com] def giveRaise(rate: Double)
 ? Is it useful? 
 Write a program that copies all elements from a Java hash map into a Scala 
 hash map. Use imports to rename both classes.
  
 In the preceding exercise, move all imports into the innermost scope possible.",NA
Inheritance,NA,NA
Topics in This Chapter  ,"A1
  
 8.1 Extending a Class — page 87 
  
 8.2 Overriding Methods — page 88 
  
 8.3 Type Checks and Casts — page 89 
  
 8.4 Protected Fields and Methods — page 90 
  
 8.5 Superclass Construction — page 90 
  
 8.6 Overriding Fields — page 91 
  
 8.7 Anonymous Subclasses — page 93 
  
 8.8 Abstract Classes — page 93 
  
 8.9 Abstract Fields — page 93 
  
 8.10 Construction Order and Early Definitions 
 L3
  — page 94 
 8.11 The Scala Inheritance Hierarchy — page 96 
  
 8.12 Object Equality 
 L1
  — page 97 
  
 Exercises — page 98",NA
Chapter,NA,NA
8,"In this chapter, you will learn the most important ways in which inheritance in 
 Scala differs from its counterparts in Java and C++. The highlights are:
  
 •
  
 The 
 extends
  and 
 final
  keywords are as in Java.
  
 •
  
 You must use 
 override
  when you override a method.
  
 •
  
 Only the primary constructor can call the primary superclass constructor.•
  
 You can override fields.
  
 In this chapter, we only discuss the case in which a class inherits from another 
 class. See Chapter 10 for inheriting 
 traits
 —the Scala concept that generalizes 
 Java interfaces.",NA
8.1 Extending a Class,"You extend a class in Scala just like you would in Java—with the 
 extends
  keyword:
  
 class Employee 
 extends
  Person {
  
  var salary: 0.0
  
  ...
  
 }
  
 As in Java, you specify fields and methods that are new to the subclass or that 
 override methods in the superclass.
  
 87",NA
8.2 Overriding Methods,"In Scala, you 
 must
  use the 
 override
  modifier when you override a method that 
 isn’t abstract. (See Section 8.8, “Abstract Classes,” on page 93 for abstract 
 methods.) For example,
  
 public class Person {
  
  ...
  
  
 override
  def toString = getClass.getName + ""[name="" + name + 
 ""]"" }
  
 The 
 override
  modifier can give useful error messages in a number of common 
 situations, such as:
  
 •
 •
  
 •
  
 When you misspell the name of the method that you are overriding 
  
 When you accidentally provide a wrong parameter type in the overriding 
 method 
  
 When you introduce a new method in a superclass that clashes with a 
 subclass method
  
  
  
 NOTE: The last case is an instance of the 
 fragile base class problem
 , where 
 a change in the superclass cannot be verified without looking at all the sub-
  
 classes. Suppose programmer Alice defines a 
 Person
  class, and, 
 unbeknownst to Alice, programmer Bob defines a subclass 
 Student
  with a 
 method 
 id
  yielding the student ID. Later, Alice also defines a method 
 id
  that 
 holds the person’s national ID. When Bob picks up that change, something 
 may break in Bob’s program (but not in Alice’s test cases) since 
 Student
  
 objects now return unexpected IDs.
  
 In Java, one is often advised to “solve” this problem by declaring all 
 methods as 
 final
  unless they are explicitly designed to be overridden. That 
 sounds good in theory, but programmers hate it when they can’t make 
 even the most innocuous changes to a method (such as adding a logging 
 call). That’s why Java eventually introduced an optional 
 @Overrides
  
 annotation.
  
 Invoking a superclass method in Scala works exactly like in Java, with the 
 keyword
  super
 :",NA
8.3 Type Checks and Casts,"To test whether an object belongs to a given class, use the 
 isInstanceOf
  method. 
 If the test succeeds, you can use the 
 asInstanceOf
  method to convert a reference 
 to a subclass reference:
  
 if (p.isInstanceOf[Employee]) {
  
  val s = p.asInstanceOf[Employee] //s
  has type 
 Employee 
 ...
  
 }
  
 The 
 p.isInstanceOf[Employee]
  test succeeds if 
 p
  refers to an object of class 
 Employee
  
 or its subclass (such as 
 Manager
 ).
  
 If 
 p
  is 
 null
 , then 
 p.isInstanceOf[Employee]
  returns 
 false
  and 
 p.asInstanceOf[Employee] 
 returns
  null
 .
  
 If 
 p
  is not an 
 Employee
 , then 
 p.asInstanceOf[Employee]
  throws an exception.
  
 If you want to test whether 
 p
  refers to a 
 Employee
  object, but not a subclass, use
  
 if (p.getClass == classOf[Employee])
  
 The 
 classOf
  method is defined in the 
 scala.Predef
  object that is always imported.
  
 Table 8–1 shows the correspondence between Scala and Java type checks and 
 casts.
  
 Table 8–1
  Type Checks and Casts in Scala and Java
  
 Scala
  
 Java
  
 obj.isInstanceOf[Cl]
  
 obj instanceof Cl
  
 obj.asInstanceOf[Cl]
  
 (Cl) obj
  
 classOf[Cl]
  
 Cl.class
  
 However, pattern matching is usually a better alternative to using type checks 
 and casts. For example,",NA
8.4 Protected Fields and Methods,"As in Java or C++, you can declare a field or method as 
 protected
 . Such a 
 member is accessible from any subclass, but not from other locations.
  
 Unlike in Java, a 
 protected
  member is 
 not
  visible throughout the package to 
 which the class belongs. (If you want this visibility, you can use a package 
 modifier—see Chapter 7.)
  
 There is also a 
 protected[this]
  variant that restricts access to the current object, 
 similar to the 
 private[this]
 variant discussed in Chapter 5.",NA
8.5 Superclass Construction,"Recall from Chapter 5 that a class has one primary constructor and any 
 number of auxiliary constructors, and that all auxiliary constructors must start 
 with a call to a preceding auxiliary constructor or the primary constructor.
  
 As a consequence, an auxiliary constructor can 
 never
  invoke a superclass 
 constructor directly.
  
 The auxiliary constructors of the subclass eventually call the primary 
 constructor of the subclass. Only the primary constructor can call a superclass 
 constructor.
  
 Recall that the primary constructor is intertwined with the class definition. The 
 call to the superclass constructor is similarly intertwined. Here is an example:
  
 class Employee(name: String, age: Int, val salary : Double) extends
  
  Person(name, age)
  
 This defines a subclass
  
 class Employee
 (name: String, age: Int, val salary : Double)
  extends 
  
  Person
 (name, age)
  
 and a primary constructor that calls the superclass constructor
  
 class
  Employee(name: String, age: Int, val salary : Double) 
 extends
  
  Person(name, age)
  
 Intertwining the class and the constructor makes for very concise code. You 
 may find it helpful to think of the primary constructor parameters as 
 parameters of",NA
8.6 Overriding Fields,"Recall from Chapter 5 that a field in Scala consists of a private field 
 and 
 accessor/mutator methods. You can override a 
 val
  (or a parameterless 
 def
 ) with 
 another 
 val
  field of the same name. The subclass has a private field and a 
 public getter, and the getter overrides the superclass getter (or method).
  
 For example,
  
 class Person(val name: String) {
  
  override def toString = getClass.getName + ""[name="" + name + ""]"" }
  
 class SecretAgent(codename: String) extends Person(codename) { 
  
 override val
  name = ""secret"" //
  Don’t want to reveal name . . . 
  
  
 override val
  toString = ""secret"" //
  . . . or class name 
 } 
  
 This example shows the mechanics, but it is rather artificial. A more common 
 case is to override an abstract 
 def
  with a 
 val
 , like this:",NA
8.7 Anonymous Subclasses,"As in Java, you make an instance of an 
 anonymous
  subclass if you include a 
 block with definitions or overrides, such as
  
 val alien = new Person(""Fred"") {
  
  def greeting = ""Greetings, Earthling! My name is Fred.""
  
 }
  
 Technically, this creates an object of a 
 structural type
 —see Chapter 18 for 
 details. The type is denoted as 
 Person{def greeting: String}
 . You can use this type 
 as a parameter type:
  
 def meet(p: Person{def greeting: String}) {
  
  println(p.name + "" says: "" + p.greeting)
  
 }",NA
8.8 Abstract Classes,"As in Java, you can use the 
 abstract
  keyword to denote a class that cannot be in-
 stantiated, usually because one or more of its methods are not defined. For 
 example,
  
 abstract class Person(val name: String) {
  
  def id: Int // 
 No method body—this is an abstract method }
  
 Here we say that every person has an ID, but we don’t know how to compute 
 it. Each concrete subclass of 
 Person
  needs to specify an 
 id
  method. In Scala, 
 unlike Java, you do not use the 
 abstract
  keyword for an abstract method. You 
 simply omit its body. As in Java, a class with at least one abstract method must 
 be declared
  abstract
 .
  
 In a subclass, you need not use the 
 override
  keyword when you define a method 
 that was abstract in the superclass.
  
 class Employee(name: String) extends Person(name) {
  
  def id = name.hashCode //override
  keyword not required 
 }",NA
8.9 Abstract Fields,"In addition to abstract methods, a class can also have abstract fields. An abstract 
 field is simply a field without an initial value. For example,",NA
8.10 Construction Order and Early Definitions ,"L3
  
 When you overrride a 
 val
  in a subclass 
 and
  use the value in a superclass 
 constructor, the resulting behavior is unintuitive.
  
 Here is an example. A creature can sense a part of its environment. For 
 simplicity, we assume the creature lives in a one-dimensional world, and the 
 sensory data are represented as integers. A default creature can see ten units 
 ahead.
  
 class Creature {
  
  val range: Int = 10
  
  val env: Array[Int] = new Array[Int](range) 
  
 }
  
 Ants, however, are near-sighted:
  
 class Ant extends Creature {
  
  override val range = 2 
  
 }
  
 Unfortunately, we now have a problem. The 
 range
  value is used in the 
 superclass constructor, and the superclass constructor runs 
 before
  the subclass 
 constructor.
  
 Specifically, here is what happens:",NA
8.11 The Scala Inheritance Hierarchy,"Figure 8–1 shows the inheritance hierarchy of Scala classes. The classes that 
 correspond to the primitive types in Java, as well as the type 
 Unit
 , extend 
 AnyVal
 .
  
 All other classes are subclasses of the 
 AnyRef
  class, which is a synonym for the 
 Object
  class from the Java or .NET virtual machine.
  
 Both 
 AnyVal
  and 
 AnyRef
  extend the 
 Any
  class, the root of the hierarchy.
  
  
 Figure 8–1 
  The Inheritance Hierarchy of Scala Classes
  
 The 
 Any
  class defines methods 
 isInstanceOf
 , 
 asInstanceOf
 , and the methods for 
 equality and hash codes that we will look at in Section 8.12, “Object 
 Equality,”on page 97.
  
 AnyVal
  does not add any methods. It is just a marker for value types.",NA
8.12 Object Equality ,"L1
  
 In Scala, the 
 eq
  method of the 
 AnyRef
  class checks whether two references refer 
 to the same object. The 
 equals
  method in 
 AnyRef
  calls 
 eq
 . When you implement a 
 class, you should consider overriding the 
 equals
  method to provide a natural 
 notion of equality for your situation.
  
 For example, if you define a 
 class Item(val description: String, val price: Double)
 , you 
 might want to consider two items equal if they have the same description and 
 price. Here is an appropriate 
 equals
  method:",NA
Exercises,"1.
  
 Extend the following 
 BankAccount
  class to a 
 CheckingAccount
  class that 
 charges $1 for every deposit and withdrawal.
  
 class BankAccount(initialBalance: Double) {
  
  private var balance = initialBalance
  
  def deposit(amount: Double) = { balance += amount; balance } def 
 withdraw(amount: Double) = { balance -= amount; balance } }",NA
Files and Regular ,NA,NA
Expressions,NA,NA
Topics in This Chapter  ,"A1
  
 9.1 Reading Lines — page 102 
  
 9.2 Reading Characters — page 102 
  
 9.3 Reading Tokens and Numbers — page 103 
  
 9.4 Reading from URLs and Other Sources — page 104 
 9.5 Reading Binary Files — page 104 
  
 9.6 Writing Text Files — page 104 
  
 9.7 Visiting Directories — page 105 
  
 9.8 Serialization — page 106 
  
 9.9 Process Control 
 A2
  — page 107 
  
 9.10 Regular Expressions — page 108 
  
 9.11 Regular Expression Groups — page 109 
  
 Exercises — page 109",NA
Chapter,NA,NA
9,"In this chapter, you will learn how to carry out common file processing tasks,
  
 such as reading all lines or words from a file or reading a file containing numbers.
  
 Chapter highlights:
  
 •
 •
 •
 •
 •
 •
 •
  
 Source.fromFile(...).getLines.toArray
  yields all lines of a file.
  
 Source.fromFile(...).mkString
  yields the file contents as a string.
  
 To convert a string into a number, use the 
 toInt
  or 
 toDouble
  method.
  
 Use the Java 
 PrintWriter
  to write text files.
  
 ""
 regex
 "".r
  is a 
 Regex
  object.
  
 Use 
 """"""...""""""
  if your regular expression contains backslashes or quotes. If a 
 regex pattern has groups, you can extract their contents using the syntax 
 for 
 (regex(
 var
 1
 , ...,
 var
 n
 ) <- 
 string
 )
 .
  
 101",NA
9.1 Reading Lines,"To read all lines from a file, call the 
 getLines
  method on a 
 scala.io.Source
  object:
  
 import scala.io.Source
  
 val source = Source.fromFile(""myfile.txt"", ""UTF-8"")
  
  // 
 The first argument can be a string or a 
 java.io.File // 
 You 
 can omit the encoding if you know that the file uses
  // 
 the 
 default platform encoding 
  
 val lineIterator = source.getLines
  
 The result is an iterator (see Chapter 13). You can use it to process the lines one 
 at a time:
  
 for (l <- lineIterator) 
 process 
 l
  
 Or you can put the lines into an array or array buffer by applying the 
 toArray
  or 
 toBuffer
  method to the iterator:
  
 val lines = source.getLines.toArray
  
 Sometimes, you just want to read an entire file into a string. That’s even 
 simpler:
  
 val contents = source.mkString
  
  
 CAUTION: Call 
 close
  when you are done using the 
 Source
  object.",NA
9.2 Reading Characters,"To read individual characters from a file, you can use a 
 Source
  object directly as 
 an iterator since the 
 Source
  class extends 
 Iterator[Char]
 :
  
 for (c <- source) 
 process 
 c
  
 If you want to be able to peek at a character without consuming it (like 
 istream::peek 
 in C++ or a 
 PushbackInputStreamReader
  in Java), call the 
 buffered
  
 method on the source. Then you can peek at the next input character with the 
 head
  method without consuming it.",NA
9.3 Reading Tokens and Numbers,"Here is a quick-and-dirty way of reading all whitespace-separated tokens in a 
 source:
  
 val tokens = source.mkString.split(""\\s+"")
  
 To convert a string into a number, use the 
 toInt
  or 
 toDouble
  method. For 
 example, if you have a file containing floating-point numbers, you can read 
 them all into an array by
  
 val numbers = for (w <- tokens) yield w.toDouble
  
 or
  
 val numbers = tokens.map(_.toDouble) 
  
  
 TIP: Remember—you can always use the 
 java.util.Scanner
  class to process 
 a file that contains a mixture of text and numbers.
  
 Finally, note that you can read numbers from the 
 console
 :
  
 print(""How old are you? "")
  
  // Console
  is imported by default, so you don’t need to qualify 
 print
  and 
 readInt 
 val age = readInt()
  
  // 
 Or use 
 readDouble
  or 
 readLong
  
  
 CAUTION: These methods assume that the next input line contains a single 
 number, without leading or trailing whitespace. Otherwise, a
  
 NumberFormatException
  occurs.",NA
9.4 Reading from URLs and Other Sources,"The 
 Source
  object has methods to read from sources other than files:
  
 val source1 = Source.fromURL(""http://horstmann.com"", ""UTF-
 8"") val source2 = Source.fromString(""Hello, World!"") 
  
  // 
 Reads from the given string—useful for debugging 
 val 
 source3 = Source.stdin
  
  // 
 Reads from standard input
  
  
 CAUTION: When you read from a URL, you need to know the character 
 set in advance, perhaps from an HTTP header. See www.w3.org/
  
 International/O-charset for more information.",NA
9.5 Reading Binary Files,"Scala has no provision for reading binary files. You’ll need to use the Java 
 library. Here is how you can read a file into a byte array:
  
 val file = new File(filename) 
  
 val in = new FileInputStream(file) 
  
 val bytes = new Array[Byte](file.length.toInt) 
  
 in.read(bytes) 
  
 in.close()",NA
9.6 Writing Text Files,"Scala has no built-in support for writing files. To write a text file, use a 
 java.io.PrintWriter
 , for example:
  
 val out = new PrintWriter(""numbers.txt"") 
  
 for (i <- 1 to 100) out.println(i) 
  
 out.close()
  
 Everything works as expected, except for the 
 printf
  method. When you pass a 
 number to 
 printf
 , the compiler will complain that you need to convert it to an 
 AnyRef
 :
  
 out.printf(""%6d %10.2f"",
  
  quantity.asInstanceOf[AnyRef], price.asInstanceOf[AnyRef]) // 
 Ugh
  
 Instead, use the 
 format
  method of the 
 String
  class:
  
 out.print(""%6d %10.2f"".format(quantity, price))",NA
9.7 Visiting Directories,"There are currently no “official” Scala classes for visiting all files in a directory, 
 or for recursively traversing directories. In this section, we discuss a couple of 
 alternatives.
  
  
 NOTE: A prior version of Scala had 
 File
  and 
 Directory
  classes.You can still 
 find them in the 
 scala.tools.nsc.io
  package inside scala-compiler.jar.
  
 It is simple to write a function that produces an iterator through all 
 subdirectories of a directory:
  
 import java.io.File 
  
 def subdirs(dir: File): Iterator[File] = {
  
  val children = dir.listFiles.filter(_.isDirectory)
  
  children.toIterator ++ children.toIterator.flatMap(subdirs _) }
  
 With this function, you can visit all subdirectories like this:
  
 for (d <- subdirs(dir)) 
 process 
 d
  
 Alternatively, if you use Java 7, you can adapt the 
 walkFileTree
  method of the 
 java.nio.file.Files
  class. That class makes use of a 
 FileVisitor
  interface. In Scala, we 
 generally prefer to use function objects, not interfaces, for specifying work 
 (even though in this case the interface allows more fine-grained control—see 
 the Javadoc for details). The following implicit conversion adapts a function to 
 the interface:
  
 import java.nio.file._ 
  
 implicit def makeFileVisitor(f: (Path) => Unit) = new SimpleFileVisitor[Path] { 
 override def visitFile(p: Path, attrs: attribute.BasicFileAttributes) = { 
  
  f(p)
  
  
  FileVisitResult.CONTINUE 
  
  } 
  
 }",NA
9.8 Serialization,"In Java, serialization is used to transmit objects to other virtual machines or for 
 short-term storage. (For long-term storage, serialization can be awkward—it is 
 tedious to deal with different object versions as classes evolve over time.)
  
 Here is how you declare a serializable class in Java and Scala.
  
 Java:
  
 public class Person implements java.io.Serializable { 
 private static final long serialVersionUID = 42L; ...
  
 }
  
 Scala:
  
 @SerialVersionUID(42L) class Person extends Serializable
  
 The 
 Serializable
  trait is defined in the 
 scala
  package and does not require an 
 import.
  
  
 NOTE: You can omit the 
 @SerialVersionUID
  annotation if you are OK with 
 the default ID.
  
 You serialize and deserialize objects in the usual way:
  
 val fred = new Person(...) 
  
 import java.io._ 
  
 val out = new ObjectOutputStream(new 
 FileOutputStream(""/tmp/test.obj"")) out.writeObject(fred) 
  
 out.close() 
  
 val in = new ObjectInputStream(new FileInputStream(""/tmp/test.obj"")) 
 val savedFred = in.readObject().asInstanceOf[Person]
  
 The Scala collections are serializable, so you can have them as members of your 
 serializable classes:
  
 class Person extends Serializable {
  
  private val friends = new ArrayBuffer[Person] // 
 OK—
 ArrayBuffer
  is serializable
  ..
  
 }",NA
9.9 Process Control ,"A2
  
 Traditionally, programmers use shell scripts to carry out mundane processing 
 tasks, such as moving files from one place to another, or combining a set of 
 files. The shell language makes it easy to specify subsets of files, and to pipe 
 the output of one program into the input of another. However, as 
 programming languages, most shell languages leave much to be desired.
  
 Scala was designed to scale from humble scripting tasks to massive programs. 
 The 
 scala.sys.process
  package provides utilities to interact with shell programs. 
 You can write your shell scripts in Scala, with all the power that the Scala 
 language puts at your disposal.
  
 Here is a simple example:
  
 import sys.process._
  
 ""ls -al .."" !
  
 As a result, the 
 ls -al ..
  command is executed, showing all files in the parent 
 directory. The result is printed to standard output.
  
 The 
 sys.process
  package contains an implicit conversion from strings to 
 ProcessBuilder 
 objects. The 
 !
  operator 
 executes
  the 
 ProcessBuilder
  object.
  
 The result of the 
 !
  operator is the exit code of the executed program: 
 0
  if the 
 program was successful, or a nonzero failure indicator otherwise.
  
 If you use 
 !!
  instead of 
 !
 , the output is returned as a string:
  
 val result = ""ls -al .."" !!
  
 You can pipe the output of one program into the input of another, using the 
 #| 
 operator:
  
 ""ls -al .."" #| ""grep sec"" !
  
  
 NOTE: As you can see, the process library uses the commands of the un-
 derlying operating system. Here, I use 
 bash
  commands because 
 bash
  is
  
 available on Linux, Mac OS X, and Windows.
  
 To redirect the output to a file, use the 
 #>
  operator:
  
 ""ls -al .."" #> new File(""output.txt"") !
  
 To append to a file, use 
 #>>
  instead:
  
 ""ls -al .."" #>> new File(""output.txt"") !
  
 To redirect input from a file, use 
 #<
 :
  
 ""grep sec"" #< new File(""output.txt"") !",NA
9.10 Regular Expressions,"When you process input, you often want to use regular expressions to analyze 
 it. The 
 scala.util.matching.Regex
  class makes this simple. To construct a 
 Regex
  
 object, use the 
 r
  method of the 
 String
  class:
  
 val numPattern = ""[0-9]+"".r
  
 If the regular expression contains backslashes or quotation marks, then it is a 
 good idea to use the “raw” string syntax, 
 """"""...""""""
 . For example:
  
 val wsnumwsPattern = """"""\s+[0-9]+\s+"""""".r
  
  // 
 A bit easier to read than 
 ""\\s+[0-9]+\\s+"".r
  
 The 
 findAllIn
  method returns an iterator through all matches. You can use it in a 
 for
  loop:
  
 for (matchString <- numPattern.findAllIn(""99 bottles, 98 bottles""))
  
 process
  matchString
  
 or turn the iterator into an array:
  
 val matches = numPattern.findAllIn(""99 bottles, 98 bottles"").toArray
  
  // Array(99, 98)
  
 To find the first match anywhere in a string, use 
 findFirstIn
 . You get an 
 Option[String]
 . (See Chapter 14 for the 
 Option
  class.)",NA
9.11 Regular Expression Groups,"Groups are useful to get subexpressions of regular expressions. Add 
 parentheses around the subexpressions that you want to extract, for example:
  
 val numitemPattern = ""
 (
 [0-9]+
 )
  ([a-z]+)"".r
  
 To match the groups, use the regular expression object as an “extractor” (see 
 Chapter 14), like this:
  
 val numitemPattern(num, item) = ""99 bottles""
  
  // 
 Sets 
 num
  to 
 ""99""
 , 
 item
  to 
 ""bottles""
  
 If you want to extract groups from multiple matches, use a 
 for
  statement like this:
  
 for (numitemPattern(num, item) <- numitemPattern.findAllIn(""99 bottles, 98 bottles"")) 
  
 process 
 num
  and 
 item",NA
Exercises,"1. 
 2.
  
 3.
  
 Write a Scala code snippet that reverses the lines in a file (making the last 
 line the first one, and so on).
  
 Write a Scala program that reads a file with tabs, replaces each tab with 
 spaces so that tab stops are at 
 n
 -column boundaries, and writes the result 
 to the same file.
  
 Write a Scala code snippet that reads a file and prints all words with more 
 than 12 characters to the console. Extra credit if you can do this in a single 
 line.",NA
