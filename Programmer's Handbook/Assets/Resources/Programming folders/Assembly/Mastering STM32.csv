Larger Text,Smaller Text,Symbol
Mastering STM32,NA,NA
A step-by-step guide to the most complete ARM Cortex-M ,NA,NA
"platform, using a free and powerful development ",NA,NA
environment based on Eclipse and GCC,NA,NA
Carmine Noviello,"This book is for sale at
  http://leanpub.com/mastering-stm32
  
 This version was published on 2018-08-17
  
  
 This is a
  Leanpub
  book. Leanpub empowers authors and publishers with the Lean 
 Publishing process.
  Lean Publishing
  is the act of publishing an in-progress ebook using 
 lightweight tools and many iterations to get reader feedback, pivot until you have the right 
 book and build traction once you do.
  
 © 2015 - 2018 Carmine Noviello
  
 (byP3ATeam)",NA
Tweet This Book!,"Please help Carmine Noviello by spreading the word about this book on
  Twitter
 !
  
 The suggested hashtag for this book is
  #MasteringSTM32
 .
  
 Find out what other people are saying about the book by clicking on this link to search 
 for this hashtag on Twitter: 
  
 #MasteringSTM32",NA
Contents,"Preface
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 i
  
 Why Did I Write the Book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 i
  
 Who Is This Book For? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ii
  
 How to Integrate This Book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 iii
  
 How Is the Book Organized? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 iv
  
 About the Author . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . vii
  
 Errata and Suggestions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . viii
  
 Book Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . viii
  
 How to Help the Author 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ix
  
 Copyright Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ix
  
 Credits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ix
  
 Acknowledgments
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 x",NA
I ,NA,NA
Introduction,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
1,"1. 
  
 Introduction to STM32 MCU Portfolio
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 2
  
 1.1 
  
 Introduction to ARM Based Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
  
 1.1.1 Cortex and Cortex-M Based Processors . . . . . . . . . . . . . . . . . . . . 
  
 4
  
 1.1.1.1 
  
 Core Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
  
 1.1.1.2 
  
 Memory Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
  
 1.1.1.3 
  
 Bit-Banding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
  
 1.1.1.4 
  
 Thumb-2 and Memory Alignment . . . . . . . . . . . . . . . . 
  
 12
  
 1.1.1.5 
  
 Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 13
  
 1.1.1.6 
  
 Interrupts and Exceptions Handling . . . . . . . . . . . . . . . 
  
 15
  
 1.1.1.7 
  
 SysTimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 17
  
 1.1.1.8 
  
 Power Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 17",NA
II ,NA,NA
Diving into the HAL ,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
173,"6. 
  
 GPIO Management
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  174 
  
 6.1 
  
 STM32 
 Peripherals Mapping and HAL
  Handlers
  . . . . . . . . . . . . . . . . . . . . . 174 
  
 6.2 
  
 GPIOs 
 Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179 
  
  
 6.2.1 
  
 GPIO Mode . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181 
  
  
 6.2.2 
  
 GPIO Alternate Function . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . 183 
  
  
 6.2.3 
  
 Understanding GPIO Speed . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . 184 
  
 6.3 
  
 Driving a GPIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 
  
 6.4 
  
 De-initialize a GPIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
  
 7. 
  
 Interrupts Management
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  190 
  
 7.1 
  
 NVIC 
 Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190 
   
 7.1.1 
  
 Vector Table in 
 STM32 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191 
  
 7.2 
  
 Enabling Interrupts . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . 194 
  
  
 7.2.1 
  
 External Lines and NVIC . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . 195 
  
  
 7.2.2 
  
 Enabling Interrupts With CubeMX . . . . . . . . . . . . . . . . . . . . . . . 199 
  
 7.3 
  
 Interrupt Lifecycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 
  
 7.4 
  
 Interrupt Priority Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 
   
 7.4.1 
  
 Cortex-M0/0+ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 
  
  
 7.4.2 
  
 Cortex-
 M3/4/7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209 
   
 7.4.3 
  
 Setting Interrupt Priority in 
 CubeMX . . . . . . . . . . . . . . . . . . . . . 216 
  
 7.5 
  
 Interrupt Re-Entrancy . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . 216 
  
 7.6 
  
 Mask All Interrupts at Once or an a Priority Basis . . . . . . . . . . . . . . 
 . . . . . . 218
  
 8. 
  
 Universal Asynchronous Serial Communications
  . . . . . . . . . . . . . . . . . . . . . . .
  221 
  
 8.1 
  
 Introduction to UARTs and USARTs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221 
  
 8.2 
  
 UART 
 Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225 
  
  
 8.2.1 
  
 UART 
 Configuration Using CubeMX . . . . . . . . . . . . . . . . . . . . . 232 
  
 8.3 
  
 UART Communication in
  
 Polling Mode 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . 233 
  
  
 8.3.1 
  
 Installing a Serial 
 Console in Windows . . . . . . . . . . . . . . . . . . . . 237 
  
  
 8.3.2 
  
 Installing a Serial Console in 
 Linux and MacOS X . . . . . . . . . . . . . 239 
  
 8.4 
  
  
 UART Communication in
  Interrupt Mode
  . . . . . . . . . . . . . . . . . . . . . . . . . 241 
  
  
 8.4.1 
  
 UART Related Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 
  
 8.5 
  
 Error Management . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249 
  
 8.6 
  
 I/O Retargeting . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . 250
  
 9. 
  
 DMA Management
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  254 
  
 9.1 
  
 Introduction to DMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254 
  
  
 9.1.1 
  
 The 
 Need of a DMA and the Role of the Internal Buses . . . . . . . . . . 255 
  
  
 9.1.2 
  
 The 
 DMA Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258 
  
  
  
 9.1.2.1 
  
 The 
 DMA Implementation in F0/F1/F3/L1 MCUs . . . . . . . 259 
  
  
  
 9.1.2.2 
  
 The DMA Implementation in F2/F4/F7 MCUs . . . . . . . . . 263 
   
  
 9.1.2.3 
  
 The DMA Implementation in L0/L4 MCUs . . . . . . . . . . 266",NA
II,NA,NA
I,"18.
 1
  
 Introduction to the RTC Peripheral . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
  
 18.
 2
  
 HAL_RTC
  Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
  
 18.
 3
  
 18.2.1
  
 Setting and Retrieving the Current Date/Time . . . . . . . . . . . . . . . . 486
  
 18.2.1.1
  
 Correct Way to Read Date/Time Values . . . . . . . . . . . . 488
  
 18.2.2
  
 Configuring Alarms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489
  
 18.2.3
  
 Periodic Wakeup Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
  
 18.2.4
  
 Timestamp Generation and Tamper Detection . . . . . . . . . . . . . . . . 493
  
 18.2.5
  
 RTC Calibration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
  
 18.2.5.1
  
 RTC Coarse Calibration . . . . . . . . . . . . . . . . . . . . . . 494
  
 18.2.5.2
  
 RTC Smooth Calibration . . . . . . . . . . . . . . . . . . . . . 494
  
 18.2.5.3
  
 Reference Clock Detection . . . . . . . . . . . . . . . . . . . . 496
  
 Using the Backup SRAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496",NA
Advanced topics,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
498,"19. Power Management
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  499 
  
 19.1 
  
 Power 
 Management in Cortex-M Based MCUs . . . . . . . . . . . . . . . . . . . . . . 499 
  
 19.2 
  
 How Cortex-
 M MCUs Handle
  Run
  and
  Sleep
  Modes 
  
 . . . . . . . . . . . . . . . . . . 500 
  
  
 19.2.1 
  
 Entering/exiting sleep modes . . . . . . . . . . . . . . . . . . . . . . . . . . 503 
  
  
  
 19.2.1.1 
  
 Sleep-On-Exit . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505 
  
  
 19.2.2 
  
 Sleep
  
 Modes in Cortex-M Based MCUs . . . . . . . . . . . . . . . . . . . . 505",NA
Appendix,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
784,"A. Miscellaneous HAL functions and STM32 features
  . . . . . . . . . . . . . . . . . . . . . . . .
  785 
 Force 
 MCU reset from the firmware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785 STM32 96-bit 
 Unique CPU ID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785
  
 B. Troubleshooting guide
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  787 
 GNU MCU 
 Eclipse Installation Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 787 Eclipse related issue . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 787 Eclipse cannot locate the compiler . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . 788 
  
 Eclipse continuously breaks at every instruction during debug session . . . . . . . . 789 
  
 The step-by-step debugging is really slow . . . . . . . . . . . . . . . . . . . . . . . . . 789 
  
 The firmware works only under a debug session . . . . . . . . . . . . . . . . . . . . . 790 
  
 STM32 related issue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 790 The microcontroller 
 does not boot correctly . . . . . . . . . . . . . . . . . . . . . . . . 790 
  
 It is Not Possibile to Flash or to Debug the MCU . . . . . . . . . . . . . . . . . . . . . 792",NA
Preface,"As far as I know this book is the first attempt to write a systematic text about the STM32 
 platform and its official STM32Cube HAL. When I started dealing with this microcontroller 
 architecture, I searched far and wide for a book able to introduce me to the subject, with no 
 success.
  
 The book is divided in three parts: an introductory part showing how to setup a complete 
 development environment and how to work with it; a part that introduces the basics of 
 STM32 programming and the main aspects of the official HAL (Hardware Abstraction 
 Layer); a more advanced section covering aspects such as the use of a Real Time Operating 
 Systems, the boot sequence and the memory layout of an STM32 application.
  
 However, this book does not aim to replace official datasheets from ST Microelectronics. A 
 datasheet is still the main reference about electronic devices, and it is impossible (as well 
 as making little sense) to arrange the content of tens of datasheets in a book. You have to 
 consider that the official datasheet of the STM32F4 MCU alone is almost one thousand 
 pages, that is more than a book! Hence, this text will offer a hint to start diving inside the 
 official documentation from ST. Moreover, this book will not focus on low-level topics and 
 questions related to the hardware, leaving this hard work to datasheets. Lastly, this book is 
 not a cookbook about custom and funny projects: you will find several good tutorials on the 
 web.",NA
Why Did I Write the Book?,"I started to cover topics about STM32 programming on my personal blog in 2013. I first 
 started writing posts only in Italian and then translating them into English. I covered 
 several topics, ranging from how to setup a complete free tool-chain to specific aspects 
 related to STM32 programming. Since then, I have received plenty of comments and 
 requests about all kinds of topics. Thanks to the interaction with readers of my blog, I 
 realized that it is not simple to cover complex topics in depth on a personal web site. A blog 
 is an excellent place where to cover really specific and limited topics. If you need to explain 
 broader topics involving software frameworks or hardware, a book is still the right answer. 
 A book forces you to organize topics in a systematic way, and gives you all the necessary 
 space to expand the subject as needed (I am one of those people who still believe reading 
 long texts on a monitor is a bad idea).
  
 For reasons that I do not know, there are no books
 ¹
  covering the topics presented here. To 
 be honest, in the hardware industry is not so common to find books about 
 microcontrollers, and this is really strange. Compared to software, hardware has much 
 greater longevity. For example, all STM32 MCUs
  
 ¹
 This is not exactly true, since there is a good and free book from Geoffrey Brown of University of Indiana 
 (http://bit.ly/1Rc1tMl). However, in my opinion, it goes too quickly to the point, leaving out important topics such as the use of a",NA
Who Is This Book For?,"This book is addressed to novices of the STM32 platform, interested in learning in less time 
 how to program these fantastic microcontrollers. However,
  this book is not for people 
 completely new to the C language or embedded programming
 . I assume you have a decent 
 knowledge of C and are not new to most fundamental concepts of digital electronics and 
 MCU programming. The perfect reader of this book may be both a hobbyist or a student 
 who is familiar with the Arduino platform and wants to learn a more powerful and 
 comprehensive architecture, or a professional in charge of working with an MCU he/she 
 does not know yet.",NA
How to Integrate This Book?,"This book does not aim to be a full-comprehensive guide to STM32 microcontrollers, but is 
 essentially a guide to developing applications using the official ST HAL. It is strongly 
 suggested to integrate it with a book about the ARM Cortex-M architecture, and the series 
 by
  Joseph Yiu²
  is the best source for every Cortex-M developer.
  
 ²
 http://amzn.to/1P5sZwq",NA
How Is the Book Organized?,"The book is divided in twenty-seven chapters, and they cover the following topics.
  
 Chapter 1
  gives a brief and preliminary introduction to the STM32 platform. It presents 
 the main aspects of these microcontrollers, introducing the reader to the ARM Cortex-M 
 architecture. Moreover, the key features of each STM32 subfamily (L0, F1, etc.) are briefly 
 explained. The chapter also introduces the development board used throughout this book 
 as testing board for the presented topics: the Nucleo.
  
 Chapter 2
  shows how to setup a complete and working tool-chain to start developing 
 STM32 applications. The chapter is divided in three different branches, each one explaining 
 the tool-chain setup process for the Windows, Linux and Mac OS X platforms.
  
 Chapter 3
  is dedicated to showing how to build the first application for the STM32 Nucleo 
 development board. This is a really simple application, a blinking led, which is with no 
 doubt the 
 Hello World
  application of hardware.
  
 Chapter 4
  is about the STM32CubeMX tool, our main companion every time we need to 
 start a new application based on an STM32 MCUs. The chapter gives a hands-on 
 presentation of the tool, explaining its characteristics and how to configure the MCU 
 peripherals according to the features we need. Moreover, it explains how to dive into the 
 generated code and customize it, as well as how to import a project generated with it into 
 the Eclipse IDE.
  
 Chapter 5
  introduces the reader to debugging. A hand-on presentation of OpenOCD is 
 given, showing how to integrate it in Eclipse. Moreover, a brief view of Eclipse’s debugging 
 capabilities is presented. Finally, the reader is introduced to a really important topic: ARM 
 semihosting.
  
 Chapter 6
  gives a quick overview of the ST CubeHAL, explaining how peripherals are 
 mapped inside the HAL using
  handlers
  to the peripheral memory mapped region. Next, it 
 presents the
  HAL_GPIO 
 libraries and all the configuration options offered by STM32 GPIOs.
  
 Chapter 7
  explains the mechanisms underlying the NVIC controller: the hardware unit 
 integrated in every STM32 MCU which is responsible for the management of exceptions 
 and interrupts. The 
 HAL_NVIC
  module is introduced extensively, and the differences between 
 Cortex-M0/0+ and Cortex-M3/4/7 are highlighted.
  
 Chapter 8
  gives a practical introduction to the
  HAL_UART
  module used to program the UART 
 interfaces provided by all STM32 microcontrollers. Moreover, a quick introduction to the 
 difference between UART and USART interfaces is given. Two ways to exchange data 
 between devices using a UART are presented:
  polling
  and
  interrupt
  oriented modes. Finally 
 we present in a practical way how to use the integrated VCP of every Nucleo board, and 
 how to retarget the
  printf()
 /
 scanf() 
 functions using the Nucleo’s UART.
  
 Chapter 9
  talks about the DMA controller, showing the differences between several STM32 
 families. A more detailed overview of the internals of an STM32 MCU is presented, 
 describing the relations between the Cortex-M core, DMA controllers and slave peripherals. 
 Moreover, it shows how to",NA
About the Author,"When someone asks me about my career and my studies, I like to say that I am a high level 
 programmer that someday has started fighting against bits.
  
 I began my career in informatics when I was only a young boy with a 80286 PC, but unlike 
 all those who started programming in BASIC, I decided to learn a quite uncommon 
 language: Clipper. Clipper was a language mostly used to write software for banks, and a lot 
 of people suggested that I should start with this programming language (uh?!?). When 
 visual environments, like Windows 3.1, started to be more common, I decided to learn the 
 foundations of Visual Basic and I wrote several programs with it (one of them, a program 
 for patient management for medical doctors, made it to the market) until I began college, 
 where I started programming in Unix environments and programming languages like 
 C/C++. One day I discovered what would become the programming language of my life:",NA
Errata and Suggestions,"I am aware of the fact that there are several errors in the text. Unfortunately, English is not 
 my mother tongue, and this is one of the main reasons I like
  lean publishing
 : being an in-
 progress book I have all the time to check and correct them. I have decided that once this 
 book reaches completion, I will look for a professional editor to help me fix all the mistakes 
 in my English. However, feel free to contact me to signal what you find.
  
 On the other end, I am totally open to suggestions and improvements about book content. I 
 like to think that this book will save your day every time you need to understand an aspect 
 related to STM32 programming, so feel free to suggest any topic you are interested in, or to 
 signal parts of the book which are not clear or well explained.
  
 You can reach me through this book website:
  
 http://www.carminenoviello.com/en/mastering-stm32/³",NA
Book Support,"I have setup a small forum on my personal website as support site for the topics presented 
 in 
 this 
 book. 
 For 
 any 
 question, 
 please 
 subscribe 
 here:
  
 http://www.carminenoviello.com/en/mastering-stm32/⁴
 .
  
 It is impossible for me to answer questions sent privately by e-mail, since they are 
 often variations on the same topic. I hope you understand.
  
 ³
 http://www.carminenoviello.com/en/mastering-
 stm32/
  
 ⁴
 http://www.carminenoviello.com/en/mastering-
 stm32/",NA
How to Help the Author,"Almost twice a week I receive nice emails from readers of this book encouraging me to 
 continue the work. Some of them would also donate additional money to help me during 
 the book writing.
  
 Needless to say that these emails make me really happy for days on end :-)
  
 However, if you really want to help me, you may consider to:
  
 • give me feedback about unclear things or errors contained both in the text and 
 examples;• write a small review about what you think
 ⁵
  of this book in the
  feedback 
 section⁶
 .
  
 • use your favorite social network or blog
  to spread the word
 . The suggested hashtag for 
 this 
  
 book on Twitter is
  #MasteringSTM32⁷
 .",NA
Copyright Disclaimer,"This book contains references to several products and technologies whose copyright is 
 owned by their respective companies, organizations or individuals.
  
 ART
 TM
 Accelerator, STM32, ST-LINK, STM32Cube and the
  STM32 logo with the white 
 butterfly on the cover of this book
  are copyright ©ST Microelectronics NV.
  
 ARM, Cortex, Cortex-M, CoreSight, CoreLink, Thumb, Thumb-2, AMBA, AHB, APB, Keil are 
 registered trademarks of ARM Holdings.
  
 GCC, GDB and other tools from the GNU Collection Compilers mentioned in this book are 
 copyright© Free Software Foundation.
  
 Eclipse is copyright of the Eclipse community and all its contributors.
  
 During the rest of the book, I will mention the copyright of tools and libraries I will 
 introduce. If I have forgot to attribute copyrights for products and software used in this 
 book, and you think I should add them here, please e-mail me through the LeanPub 
 platform.",NA
Credits,"The cover of this book was designed by Alessandro Migliorato (
 AleMiglio⁸
 )
  
 ⁵
 Negative feedback is also welcome ;-)
  
 ⁶
 https://leanpub.com/mastering-
 stm32/feedback
  
 ⁷
 https://twitter.com/search?q=%23MasteringS
 TM32
  
 ⁸
 https://99designs.it/profiles/alemiglio",NA
Acknowledgments,"Even if there is just my name on the cover, this book would not have been possible without 
 the help of a lot of people who have contributed during its development.
  
 First and foremost, I big thank you to Alan Smith, manager of the ST Microelectronics site in 
 Naples (Arzano - Italy). Alan, with persistence and great determination, came to my office 
 more than three years ago bringing a couple of Nucleo boards with him. He said to me:
  You 
 must know STM32!
 . This book was born almost that day!
  
 I would like to thank several people that silently and actively contributed to this work. 
 Enrico Colombini (aka
  Erix⁹
 ) helped me a lot during the early stages of this book, by 
 reviewing several parts of it. Without his initial support and suggestions, probably this 
 book would have never seen the end. For a self-publishing and in-progress author the early 
 feedback is paramount to better understand how to arrange a so complex work.
  
 Ubaldo de Feo (aka
  @ubi¹⁰
  also helped me a lot by providing technical feedback and by 
 performing an excellent proof-reading of some chapters.
  
 Another special thanks goes to Davide Ruggiero, from ST Microelectronics in Naples, who 
 helped me by reviewing several examples and editing the chapter about CRC peripheral 
 (Davide is a mathematician and he better knows how to approach formulas :-)). Davide also 
 actively contributed by donating me some wine bottles: without adequate fuel you cannot 
 write a 900 pages book! Some english speaking people tried to help me with my poor 
 english, dedicating a lot of time and effort to several parts of the text. So a big thank you to: 
 Omar Shaker, Roger Berger, J. Clarke, William Den Beste, J.Behloul, M.Kaiser. I hope not to 
 forget anyone.
  
 A big thanks also to all early adopters of the book, especially to those ones that bought it 
 when it was made of just few chapters. This fundamental encouragement gave me the 
 necessary energies to complete a so long and hard work.
  
 Finally, a special thanks to my business partners Antonio Chello and Francesco Vitobello 
 who gave me a lot of help during last year with the management of our company: a book is 
 probably the most time-consuming activity after a business development.
  
 Regards, 
  
 Carmine I.D. Noviello
  
 ⁹
 http://www.erix.it
  
 ¹⁰
 http://ubidefeo.co
 m",NA
I Introduction,NA,NA
1. Introduction to STM32 ,NA,NA
MCU ,NA,NA
Portfolio,"This chapter gives a brief introduction to the entire STM32 portfolio. Its goal is to introduce 
 the reader to this rather complex family of microcontrollers subdivided in ten distinct sub-
 families. These share a set of characteristics and present features specific to the given 
 series. Moreover, a quick introduction to the Cortex-M architecture is presented. Far from 
 wanting to be a complete reference to either the Cortex-M architecture or STM32 
 microcontrollers, it aims at being a guide for the readers in choosing the microcontroller 
 that best suits their development needs, considering that, with more than 500 MCUs to 
 choose from, it is not easy to decide which one fits the bill.",NA
1.1 Introduction to ARM Based Processors,"With the term
  ARM
  we nowadays refer to both a multitude of families of
  Reduced 
 Instruction Set Computing
  (RISC) architectures and several families of complete
  cores
  which 
 are the building blocks (hence the term
  core
 ) of CPUs produced by many silicon 
 manufacturers. When dealing with ARM based processors, a lot of confusion may arise due 
 to the fact that there are many different ARM architecture revisions (ARMv6, ATMv6-M, 
 ARMv7-M, ARMv7-A, and so on) and many
  core 
 architectures, which are in turn based on 
 an ARM architecture revision. For the sake of clarity, for example, a processor based on the 
 Cortex-M4 core is designed on the ARMv7-M architecture.
  
 An ARM architecture is a set of specifications regarding the instruction set, the execution 
 model, the memory organization and layout, the instruction cycles and more, which 
 describes precisely a
  machine
  that will implement said architecture. If your compiler is able 
 to generate assembly instructions for that architecture, it is able to generate machine code 
 for all those
  actual
  machines (aka, processors) implementing that given architecture.
  
 Cortex-M is a family of
  physical cores
  designed to be further integrated with vendor-specific 
 silicon devices to form a finished microcontroller. The way a core works is not only defined 
 by its related ARM architecture (eg. ARMv7-M), but also by the integrated peripherals and 
 hardware capabilities defined by the silicon manufacturer. For example, the Cortex-M4 
 core architecture is designed to support bit-data access operations in two specific memory 
 regions using a feature called
  bit-banding
 , but it is up to the
  actual
  implementation to add 
 such feature or not. The STM32F4 is a family of MCUs based on the Cortex-M4 core that 
 implements this bit-banding feature.
  Figure 1
  clearly shows the relation between a Cortex-
 M3 based MCU and its Cortex-M3 core.",NA
1.1.1 Cortex and Cortex-M Based Processors,"ARM Cortex is a wide set of 32/64-bit
  architectures
  and
  cores
  really popular in the 
 embedded world. Cortex microcontrollers are divided into three main subfamilies:
  
 •
  Cortex-A
 , which stands for
  A
 pplication, is a series of processors providing a range of 
 solutions for devices undertaking complex computing tasks, such as hosting a rich 
 Operating System (OS) platform (Linux and its derivative Android are the most 
 common ones), and supporting multiple software applications. Cortex-A cores equip 
 the processors found in most of mobile devices, like phones and tablets. In this market 
 segment we can find several silicon manufacturers ranging from those who sell 
 catalogue parts (TI or Freescale) to those who produce processors for other licensees. 
 Among the most common cores in this segment, we can find Cortex-A7 and Cortex-A9 
 32-bit processors, as well as the latest ultra-performance 64-bit Cortex-A53 and 
 Cortex-A57 cores.
  
 •
  Cortex-M
 , which stands for e
 M
 bedded, is a range of scalable, compatible, energy 
 efficient and easy to use processors designed for the low-cost embedded market. The 
 Cortex-M family is optimized for cost and power sensitive MCUs suitable for 
 applications such as Internet of Things, connectivity, motor control, smart metering, 
 human interface devices, automotive and industrial control systems, domestic 
 household appliances, consumer products and medical instruments. In this market 
 segment, we can find many silicon manufacturers who produce Cortex-M processors: 
 ST Microelectronics is one of them.
  
 •
  Cortex-R
 , which stand for
  R
 eal-Time, is a series of processors offering high-
 performance computing solutions for embedded systems where reliability, high 
 availability, fault tolerance, maintainability and deterministic real-time response are 
 essential. Cortex-R series processors deliver fast and deterministic processing and 
 high performance, while meeting challenging real-time constraints. They combine 
 these features in a performance, power and area optimized package, making them the 
 trusted choice in reliable systems demanding fault tolerance.
  
 The next sections will introduce the main features of Cortex-M processors, especially from 
 the embedded developer point of view.
  
 1.1.1.1 Core Registers
  
 Like all RISC architectures, Cortex-M processors are
  load/store
  machines, which perform 
 operations only on CPU registers except
 ²
  for two categories of instructions:
  load
  and
  store
 , 
 used to transfer data between CPU registers and memory locations.",NA
1.2 Introduction to STM32 Microcontrollers,"STM32 is a broad range of microcontrollers divided in nine sub-families, each one with its 
 features. ST started the market production of this portfolio in 2007, beginning with the 
 STM32F1 series, which is still under development.
  Figure 12
  shows the internal die of an 
 STM32F103 MCU, one of the most widespread STM32 MCUs
 ¹⁴
 . All STM32 microcontrollers 
 have a Cortex-M core, plus some distinctive ST features (like the ART
 TM
 accelerator). 
 Internally, each microcontroller consists of the processor core, static RAM, flash memory, 
 debugging interface, and various other peripherals. Some MCUs provide additional types of 
 memory (EEPROM, CCM, etc.), and a whole line of devices targeting low-power applications 
 is continuously growing.
  
 ¹⁴
 This picture is taken from Zeptobars.ru (http://bit.ly/1FfqHsv), a really fantastic blog. Its authors
  decap
  (remove the 
 protective casing) integrated circuits in acid and publish images of what’s inside the chip. I love those images, because they show 
 what humans were able to achieve in electronics.",NA
1.2.1 Advantages of the STM32 Portfolio….,"The STM32 platform provides several advantages for embedded developers. This 
 paragraph tries to summarize the relevant ones.
  
 •
  They are Cortex-M based MCUs
 : this could still not be clear to those of you who are 
 new to this platform. Being Cortex-M based microcontrollers ensures that you have 
 several tools available on the market to develop your applications. ARM has become a 
 sort of standard in the embedded world (this is especially true for Cortex-A 
 processors; in the Cortex-M market segment there are still several good alternatives: 
 PIC, MSP430, etc.) and 50 billions of devices sold by 2014 is a strong guarantee that 
 investing on this platform is a good choice.
  
 •
  Free ARM based tool-chain
 : thanks to the diffusion of ARM based processors, it is 
 possible to work with completely free tool-chains, without investing a lot of money to 
 start working with this platform, which is extremely important if you are a hobbyist or 
 a student.",NA
1.2.2 ….And Its Drawbacks,"This book is not a brochure or a document made by marketing people. Nor is the author an 
 ST employee or is he having business with ST. So it is right to say that there are some 
 pitfalls regarding this platform.
  
 •
  Learning curve
 : STM32’s learning curve can be quite steep, especially for 
 inexperienced users. If you are completely new to embedded development, the 
 process of learning how to develop STM32 applications can be really frustrating. Even 
 if ST is doing a great job at trying to improve the overall documentation and the 
 official libraries, it is still hard to deal with this platform, and this is a shame. 
 Historically, ST documentation has not been the best one for inexperienced people, 
 being too cryptic and lacking clear examples.
  
 •
  Lack of official tools
 : this book will guide the reader through the process of setting up 
 a full 
  
 tool-chain for the STM32 platform. The fact that ST does not provide its 
 official development 
  
 environment (like, for example, Microchip does for its MCUs) 
 pushes a lot of people away from 
  
 this platform. This is a strategic mishap that 
 people at ST should seriously take into account.•
  Fragmented and dispersive 
 documentation
 : ST is actively working on improving its official 
  
 documentation for 
 the STM32 platform. You can find a lot of really huge datasheets on ST’s 
  
 website, but 
 there is still a lack of good documentation especially for its HAL. Recent versions 
  
 of the 
 CubeHAL provide one or more “CHM” files
 ¹⁵
 , which are automatically generated from",NA
1.3 A Quick Look at the STM32 Subfamilies,"As you read, the STM32 is a rather complex product lineup, spanning over ten product sub-
 families. 
 Figure 13
  and
  Figure 14
  summarize the current STM32 portfolio
 ¹⁸
 . The diagrams 
 aggregate the subfamilies in four macro groups:
  High-performance
 ,
  Mainstream
 ,
  Wireless
  
 and
  Ultra Low-Power 
 MCUs.
  
 High-performance
  microcontrollers are those STM32 MCUs dedicated to CPU-intensive and 
 mul-timedia applications. They are Cortex-M3/4F/7 based MCUs, with maximum clock 
 frequencies ranging from 120MHz (F2) up to 400MHz (H7). All MCUs in this group provide 
 ART
 TM
 Accelerator, an ST technology that allows
  0-wait
  execution from flash memory.
  
 ¹⁶
 http://bit.ly/1iRAKdf
  
 ¹⁷
 http://bit.ly/1LTf2MS
  
 ¹⁸
 The diagram was taken from this ST Microelectronics brochure 
 (
 http://bit.ly/1G7HMFj
 ).",NA
1.3.1 F0,"Table 4: STM32F0 features
  
 The STM32F0 series is the famous
  32-cents for 32-bit
  line of MCU from the STM32 portfolio. 
 It is designed to have a street price able to compete with 8/16-bit MCUs from other 
 vendors, offering a more advanced and powerful platform.
  
 The most important features of this series are:
  
 •
  Core
 :",NA
1.3.2 F1,"Table 5: STM32F1 features
  
 The STM32F1 series was the first ARM based MCU from ST. Introduced in the market in 
 2007, it is still the most widespread MCU from the STM32 portfolio. Plenty of development 
 boards are available on the market, produced by ST and other vendors, and you will find 
 tons of examples on the web for F1 microcontrollers. If you are new to the STM32 world, 
 probably the F1 line is the best choice to start working with to learn this platform.
  
 The F1-series has evolved over time by increasing speed, size of internal memory, variety 
 of peripherals. There are five F1 lines:
  Connectivity
  (STM32F105/107),
  Performance
  
 (STM32F103),
  USB Access
  (STM32F102),
  Access
  (STM32F101),
  Value
  (STM32F100).
  
 The most important features of this series are:
  
 ¹⁹
 F0/L0 are the only STM32 families that provides this convenient package.",NA
1.3.3 F2,"Table 6: STM32F2 features
  
 The STM32F2 series of STM32 microcontrollers is the cost-effective solution in the
  High-
 perfor-mance
  segment. It is the most recent and fastest Cortex-M3 based MCU, with 
 exclusive ART
 TM 
 Accelerator from ST. The F2 is pin-to-pin compatible with the STM32 F4-
 series. STM32F2 was the MCU chosen by the developers of popular Pebble watch for their 
 first smart-watch.",NA
1.3.4 F3,"Table 7: STM32F3 features
  
 The STM32F3 is the most powerful series of MCU in the
  Mainstream
  segment, based on the 
 ARM Cortex-M4F core. It is designed to be almost pin-to-pin compatible with the STM32 
 F1-series, even if it does not offer the same variety of peripherals. STM32F3 was the MCU 
 chosen by the developers of the
  BB-8 droid²⁰
  toy by
  Sphero²¹
 .
  
 The distinguishing feature for this series is the presence of integrated analog peripherals 
 leading to cost reduction at application level and simplifying application design, including:
  
 • Ultra-fast comparators (25 ns).
  
 • Op-amp with programmable gain.
  
 • 12-bit DACs.
  
 • Ultra-fast 12-bit ADCs with 5 MSPS (Million Samples Per Second) per channel (up to 18 
 MSPS 
  
 in Interleaved mode).
  
 • Precise 16-bit sigma-delta ADCs (21 channels).
  
 • 144 MHz Advanced 16-bit pulse-width modulation timer (resolution < 7 ns) for 
 control applications; high resolution timer (217 picoseconds), self-compensated vs 
 power supply and temperature drift.
  
 Another interesting feature of this series is the presence of a
  Core Coupled Memory
  (CCM), a 
 specific memory architecture which couples some regions of memory to the CPU core, 
 allowing
  0-wait",NA
1.3.5 F4,"Table 8: STM32F4 features
  
 The STM32F4 series is the most widespread group of Cortex-M4F based MCUs in the
  High-
 performance
  segment. The F4-series is also the first STM32 series to have DSP and Floating 
 Point SP instructions. The F4 is pin-to-pin compatible with the STM32 F2-series and adds 
 higher clock speed, 64K CCM static RAM, full duplex I²S, improved real-time clock, and 
 faster ADCs. The STM32F4-series is also targeted to multimedia applications, and some 
 MCUs offer dedicated support for LCD-TFT.
  
 The most important features of this series are:",NA
1.3.6 F7,Table 9: STM32F7 features,NA
1.3.7 H7,Table 10: STM32H7 features,NA
1.3.8 L0,"Table 11: STM32L0 features
  
 The STM32L0 series is the cost-effective solution of the
  Ultra Low-Power
  segment. The 
 combination of an ARM Cortex-M0+ core and ultra-low-power features makes STM32L0 
 the best fit for applications operating on battery or powered by energy harvesting, offering 
 the world’s lowest power consumption at 125°C. The STM32L0 offers dynamic voltage",NA
1.3.9 L1,Table 12: STM32L1 features,NA
1.3.10 L4,"Table 13: STM32L4 features
  
 The STM32L4 series is one of the best-in-class MCU series in the
  Ultra Low-Power
  segment. 
 The combination of an ARM Cortex-M4 core with FPU and ultra-low-power features, makes 
 the STM32L4 the best fit for applications demanding high performance while operating on 
 battery or powered by energy harvesting. Like the L1-series, The STM32L4 offers dynamic 
 voltage scaling and an ultra-low-power clock oscillator.
  
 Current consumption reference values:
  
 • Ultra-low-power mode: 30 nA with backup registers without RTC.
  
 • Ultra-low-power mode + RTC: 330 nA with backup registers (5 wakeup 
 lines).• Ultra-low-power mode + 32 Kbytes of RAM: 360 nA.
  
 • Ultra-low-power mode + 32 Kbytes of RAM + RTC: 660 nA.
  
 • Dynamic run mode: down to 100 μA/MHz.
  
 • Wake-up time: 5 μs.
  
 STM32L4 is pin-to-pin compatible with several MCU from the STM32F series. The most 
 important features of this series are:",NA
1.3.11 L4+,"Table 14: STM32L4+ features
  
 The STM32L4+ series, introduced on the market at the end of 2017, is the new best-in-class 
 MCU series in the
  Ultra Low-Power
  segment. The STM32L4+ series shatters processing 
 capabilities",NA
1.3.12 STM32WB,"Table 15: STM32WB features
  
 The STM32WB series, introduced on the market at the beginning of 2018, is the new MCU 
 series in the
  Wireless
  segment. STM32WB is a lineup of dual-core STM32 microcontrollers 
 with integrated 2.4GHz radio fronted suitable for wireless and Bluetooth 5.0 applications. 
 These MCUs feature a Cortex-M0+ core running at 32 MHz (named
  Network Processor
 ) 
 dedicated to the radio management (a companion BLE 5.0 stack is also provided by ST) and 
 a user-programmable Cortex-M4 core running at 64 MHz (named
  Application Processor
 ) for 
 the main embedded application.
  
 The STM32WB platform is an evolution of the STM32L4
  Ultra Low‑Power
  series of MCUs. It 
 provides the same digital and analog peripherals suitable for applications requiring 
 extended battery life and complex functionalities. STM32WB integrate several 
 communication peripherals, a convenient crystal-less USB2.0 FS interface, audio support, 
 an LCD driver, up to 72 GPIOs, an integrated SMPS for power consumption optimization 
 and multiple
  low-power
  modes to maximize battery life.
  
 On top of wireless and
  low‑power
  features, a particular focus was placed on embedding 
 security hardware functions such as a 256‐bit AES, PCROP, JTAG Fuse, PKA (elliptic curve 
 encryption engine), and Root Secure Services (RSS). The RSS allows authenticating OTA 
 communications, regardless of the radio stack or application.
  
 The STM32WB55 is a Bluetooth 5.0 certified device and it offers Mesh 1.0 software 
 support, multiple profiles and flexibility to integrate proprietary BLE stacks. OpenThread-
 certified software stack is also available. The radio can also run BLE/OpenThread protocols 
 concurrently. The embedded generic MAC allows the usage of other IEEE 802.15.4 
 proprietary stacks like ZigBee®, or proprietary protocols, giving even more options for 
 connecting devices to the Internet of Things (IoT).
  
 •
  Core
 :
  
 –
  ARM Cortex-M4F core with FPU at a maximum clock rate of 64 MHz (
 Application 
 Processor
 ). * ARM Cortex-M0+ core a maximum clock rate of 32 MHz (
 Network 
 Processor
 ).",NA
1.3.13 How to Select the Right MCU for You?,"Selecting a microcontroller for a new project is never a trivial task, unless you are reusing a 
 previous design. First of all, there are tens of MCU manufacturers on the market, each one 
 with its market share and audience. ST, Microchip, TI, Atmel, Renesas, NXP and so on
 ²²
 . In 
 our case we are very lucky: we have already picked a brand.
  
 As we have seen in the previous paragraphs, the STM32 is really an extensive portfolio. We 
 can choose an MCU from more than 500 devices (if we also consider package variants). So, 
 where to start?
  
 In an ideal world, the first step of the selection process involves the understanding of 
 needed computing power. If we are going to develop a CPU intensive application, focused 
 on multimedia and graphic applications, then we have to shift our attention to the
  High-
 Performance
  group of STM32 microcontrollers. If, on the other hand, the computing 
 power is not the main requirement of our electronic device, we can focus on the
  
 Mainstream
  segment, giving a close look at the STM32F1 series which offers the most 
 extensive selection to choose from.
  
 The next step is about connectivity requirements. If we need to interact with the external 
 world through an Ethernet connection or other industrial protocols such as a CAN bus, and 
 our application has to be responsive and able to deal with several Internet Protocols, then 
 the STM32F4 portfolio is probably your best option; otherwise the STM32F105/7 
 connectivity line is a better choice.",NA
1.4 The Nucleo Development Board,"Every practical text about an electronic device requires a development board (also known 
 as
  kit
 ) to start working with it. In the STM32 world the most widespread development 
 board is the STM32 Discovery. ST has developed more than 20 different discovery boards 
 useful to test STM32 MCUs and their capabilities.
  
  
 Figure 19: The STM32L0538 Discovery kit introduced by ST in 2015
  
 For example, the new STM32L0538DISCOVERY board (
 Figure 19
 ) allows to test both the 
 STM32L053 MCU and an e-paper display. You can find a lot of tutorials around the Internet 
 covering boards from the Discovery line.
  
 ²⁴
 http://apple.co/Uf20
 WR",NA
Why Use the Nucleo as Example Board for This Book?,"The answers to this question are almost all contained in the previous paragraphs. 
 First of all, Nucleo boards are cheap, and allow you to start learning the STM32 
 platform at nearly no cost. Second, they greatly simplify the instructions and 
 examples contained in this book. You are completely free to use the Nucleo you like. 
 The book will show all the steps required to easily adapt examples to your specific 
 Nucleo. The third reason comes from the previous statement: the author bought all 
 Nucleo-64 boards to run tests, and he did not invest a fortune :-)
  
  
 Keep in mind that the whole book is designed to give the reader all the necessary 
 tools to start working with any board, even custom ones. It will be really easy to 
 adapt the examples to your needs.",NA
2. Setting-Up the Tool-Chain,"Before we can start developing applications for the STM32 platform, we need a complete
  
 tool-chain
 . A tool-chain is a set of programs, compilers and tools that allows us:
  
 • to write down our code and to navigate inside source files of our application;
  
 • to navigate inside the application code, allowing us to inspect variables, function 
 definition-
  
 s/declarations, and so on;
  
 • to compile the source code using a cross-platform compiler;
  
 • to upload and debug our application on the target development board (or a custom 
 board we 
  
 have made).
  
 To accomplish these activities, we essentially need:
  
 • an IDE with integrated source editor and navigator;
  
 • a cross-platform compiler able to compile source code for the ARM Cortex-M 
 platform;• a debugger that allows us to execute step by step debugging of firmware on 
 the target board;• a tool that allows to interact with the integrated hardware debugger 
 of our Nucleo board (the 
  
 ST-LINK interface) or the dedicated programmer (e.g. a 
 JTAG adapter).
  
 There are several complete tool-chains for the STM32 Cortex-M family, both free and 
 commercial. 
 IAR for Cortex-M¹
  and
  Keil²
  are two of the most used commercial tool-chains 
 for Cortex-M microcontrollers. They are a complete solution for developing applications for 
 the STM32 platform, but being commercial products they have a street price that may be 
 too high for small sized companies or students (they may cost more than $5,000 according 
 the features you need). However, this book does not cover commercial IDEs and, if you 
 already have a license for one of these environments, you can skip this chapter, but you will 
 need to arrange the instructions contained in this book according your tool-chain.
  
 CooCox³
  and
  System Workbench for STM32⁴
  (shortened as SW4STM32) are two free 
 development environments for the STM32 platform. These IDEs are essentially based on 
 Eclipse and GCC. They do a good job trying to provide support for the STM32 family, and 
 they work out of the box in most cases. However, there are several things to consider while 
 evaluating these tools. First of all, CooCox IDE currently supports only Windows; instead, 
 SWSTM32 provides support for Linux and MacOS too, but it lacks of some additional 
 features found in the tool-chain described in this book. Moreover, they already come with 
 all needed tools preinstalled and configured. While this could be
  
 ¹
 http://bit.ly/1Qxtkql
  
 ²
 http://www.keil.com/arm/mdk.
 asp
  
 ³
 http://www.coocox.org/
  
 ⁴
 http://www.openstm32.org/",NA
2.1 Why Choose Eclipse/GCC as Tool-Chain for STM32,"Before we start setting up our tool-chain, there is a really common question to answer: 
 which tool-chain is the best one to develop applications for the STM32 platform? The 
 question is unfortunately not simple to answer. Probably the best answer is that it depends 
 on the type of application. First of all, the audience should be divided between 
 professionals and hobbyists. Companies often prefer to use commercial IDEs with annual 
 fees that allow to receive technical support. You have to figure out that in business time 
 means money and, sometimes, commercial IDE can reduce the learning curve (especially if 
 you consider that ST gives explicit support to these environments). However, I think that 
 even companies (especially small organizations) can take great advantages in using an 
 open source tool-chain.
  
 I think these are the most important reasons to use a Eclipse/GCC tool-chain for embedded 
 development with STM32 MCUs:
  
 •
  It is GCC based
 : GCC is probably the best compiler on the earth, and it gives excellent 
 results even with ARM based processors. ARM is nowadays the most widespread 
 architecture (thanks to the embedded systems becoming widespread in the recent 
 years), and many hardware and software manufacturers use GCC as the base tool for 
 their platform.
  
 •
  It is cross-platform
 : if you have a Windows PC, the latest sexy Mac or a Linux server 
 you will be able to successfully develop, compile and upload the firmware on your 
 development board with no difference. Nowadays, this is a mandatory requirement.",NA
2.1.1 Two Words About Eclipse…,"Eclipse⁵
  is an Open Source and a free Java based IDE. Despite this fact (unfortunately, Java 
 programs tend to eat a lot of machine resources and to slow down your PC), Eclipse is one 
 of the most widespread and complete development environments. Eclipse comes in several 
 pre-configured versions, customized for specific uses. For example, the
  Eclipse IDE for Java 
 Developers
  comes preconfigured to work with Java and with all those tools used in this 
 development platform (Ant, Maven, and so on). In our case, the
  Eclipse IDE for C/C++ 
 Developers
  is what fits our need.
  
 Eclipse is designed to be expandable thanks to plug-ins. There are several plug-ins available 
 in Eclipse Marketplace really useful for software development for embedded systems. We 
 will install and use most of them in this book. Moreover, Eclipse is highly customizable. I 
 strongly suggest you to take a look at its settings, which allow you to adapt it to your needs 
 and flavor.",NA
2.1.2 … and GCC,"The
  GNU Compiler Collection⁶
  (GCC) is a complete and widespread compiler suite. It is the 
 only development tool able to compile several programming languages (front-end) to tens 
 of hardware architectures that come in several variants. GCC is a really complex piece of 
 software. It provides several tools to accomplish compilation tasks. These include, in 
 addition to the compiler itself, an assembler, a linker, a debugger (known as
  GNU Debugger
  
 - GDB), several tools for binary files inspection, disassembly and optimization. Moreover, 
 GCC is also equipped with the
  run-time 
 environment for the C language, customized for the 
 target architecture.",NA
2.2 Windows - Installing the Tool-Chain,"The whole installation procedure assumes these requirements:
  
 • A Windows based PC with sufficient hardware resources (I suggest to have at least 
 4Gb of RAM and 5Gb of free space on the Hard Disk); the screen captures in this 
 section are based on Windows 7, but the instructions have been tested successfully on 
 Windows XP, 7, 8.1 and the latest Windows 10.
  
 • Java SE 8 Update 121 or later. If you do not have this version, you can download it for 
 free 
  
 from official
  Java SE support page⁷
 .",NA
2.2.1 Windows - Eclipse Installation,"The first step is to install the Eclipse IDE. As said before, we are interested in the Eclipse 
 version for C/C++ developers. The latest version at time of revising this chapter (August 
 2018) is Photon (Eclipse v4.8).
  However, it is strongly suggested to use the previous 
 release, that is Oxygen.3a (Eclipse v4.7.3a), since the newest one is still not 
 supported by the GNU MCU Eclipse plug-ins suite and by several other tools used in 
 this book.
  It can be downloaded from the official
  download page⁸
  as shown in
  Figure 1
 ⁹
 .
  
  
 Figure 1: Eclipse download page
  
 Choose the release (32bit or 64bit) for your PC.
  
  
 ⁸
 https://www.eclipse.org/downloads/packages/release/oxygen/3a/
  
  
 ⁹
 Some screen captures may appear different from the ones reported in this book. This happens because the Eclipse IDE is 
 updated frequently. Don’t worry about that: the installation instructions should work in any case.",NA
2.2.2 Windows - Eclipse Plug-Ins Installation,"Once Eclipse is started, we can proceed to install some relevant plug-ins.
  
  
 What Is a Plug-In?
  
 A plug-in is an external software module that extends Eclipse functionalities. A plug-
 in must adhere to a standard API defined by Eclipse developers. In this way, it is 
 possible for third party developers to add features to the IDE without changing the 
 main source code. We will install several plug-ins in this book to adapt Eclipse to our 
 needs.
  
 The first plug-in we need to install is the
  C/C++ Development Tools SDK
 , also known as 
 Eclipse CDT, or simply CDT. CDT provides a fully functional C and C++
  Integrated 
 Development Environment 
 (IDE) based on the Eclipse platform. Features include: support 
 for project creation and managed build for various tool-chains, standard make build, source 
 navigation, various source knowledge tools, such as type hierarchy, call graph, includes 
 browser, macro definition browser, code editor with syntax highlighting, folding and",NA
2.2.3 Windows - GCC ARM Embedded Installation,"The next step in tool-chain configuration is installing the GCC suite for ARM Cortex-M and 
 Cortex-R microcontrollers. This is a set of tools (macro preprocessor, compiler, assembler, 
 linker and debugger) designed to cross-compile the code we will create for the STM32 
 platform.
  
 The latest release of ARM GCC can be downloaded from
  ARM Developer¹¹
 . At the time of 
 writing this chapter, the latest available version is the 6.0. The Windows Installer can be 
 downloaded from the
  download section¹²
 .
  
 Once download is complete, run the installer. When the installer asks for the destination 
 folder, choose
  C:\STM32Toolchain\gcc-arm
  and then click on “
 Install
 ” button, as shown in
  
 Figure 9
 .
  
  
 Figure 9: Selection of GCC destination folder
  
  
 The installer, by default, suggests a destination folder that is related to the GCC 
 version we are going to install (
 6.0 2017q2
 ). This is not convenient, because when 
 GCC is updated to a newer version we need to change settings for each Eclipse 
 project we have made.
  
 Once the installation is complete, the installer will show us a form with four different 
 checkboxes. If only one GCC is installed on your system, or you do not know, check the 
 entry
  Add path to environment variable
  and
  Add registry information
  (two checked 
 boxes), as shown in
  Figure 10
 .",NA
2.2.4 Windows – Build Tools Installation,"Windows historically lacks some tools that are a must in the UNIX world. One of these is
  
 make
 , the tool that controls the compilation process of programs written in C/C++. If you 
 have already installed a product like MinGW or similar (and it is configured in your PATH 
 environment correctly), you can skip this process. If not, you can install the
  Build Tools
  
 package made by the same author of GCC ARM plug-ins for Eclipse. You can download 
 setup program from
  here¹³
 . Choose the version that fits your OS release (32 or 64 bit). At 
 the time of writing this chapter, the last available version is
  2.8
 .
  
 When asked, install the tools in this folder:
  C:\STM32Toolchain\Build Tools
 . Restart Eclipse if it 
 is already running.",NA
2.2.5 Windows – OpenOCD Installation,"OpenOCD¹⁴
  is a tool that allows to upload the firmware on the Nucleo board and to do the 
 step-by-step debugging. Originally started by Dominic Rath, OpenOCD is now actively 
 maintained by the community and several companies, including STM. We will discuss it in 
 depth in Chapter 5, which is dedicated to the debugging. But we will install it in this 
 chapter, because the procedure changes between the three different platforms (Windows, 
 Linux and Mac OS). The latest official release at the time of writing this book is the 0.10.
  
 Compiling a tool like OpenOCD, expressly designed to be compiled on UNIX like systems, is 
 not a trivial task. It requires a complete UNIX C tool-chain like MinGW or Cygwin. Luckily, 
 Liviu
  
 ¹³
 http://bit.ly/2g2b
 u5R",NA
2.2.6 Windows – ST Tools and Drivers Installation,"ST provides several tools that are useful for developing STM32 based applications. We will 
 install them in this chapter, and we will discuss their use later in this book.
  
 STM32CubeMX is a graphical tool used to generate setup files in C programming language 
 for an STM32 MCU, according the hardware configuration of our board. For example, if we 
 have the Nucleo-F401RE, which is based on the STM32F401RE MCU, and we want to use its 
 user LED (marked as LD2 on the board), then STM32CubeMX will automatically generate 
 all source files containing the C code required to configure the MCU (clock, peripheral 
 ports, and so on) and the GPIO connected to the LED (port GPIO 5 on port A on almost all 
 Nucleo boards). You can download STM32CubeMX from the official
  ST website¹⁶¹⁷
  (the 
 download link is at the bottom of the page), and follow the installation instructions.
  
 Another important tool is the
  STM32CubeProgrammer¹⁸
 . It is a software that uploads the 
 firmware on the MCU using the ST-LINK interface of our Nucleo, or a dedicated ST-LINK 
 programmer. We will use it in the next chapter. The STM32CubeProgrammer installation 
 package also pro-vides necessary drivers to interface ST development boards with 
 Windows. You can download STM32CubeProgrammer from the official
  ST page¹⁹
  (the 
 download link is at the bottom of the page in the
  GET SOFTWARE
  section), and follow the 
 installation instructions.
  
 2.2.6.1 Windows – ST-LINK Firmware Upgrade
  
  
 Warning
  
 Read this paragraph carefully. Do not skip this step!
  
 I bought several Nucleo boards and I saw that all boards come with an old ST-LINK 
 firmware. In order to use the Nucleo with OpenOCD, the firmware must be updated at least 
 to the 2.29.18 version.
  
 ¹⁵
 http://bit.ly/2khxhXL
  
 ¹⁶
 http://bit.ly/1RLCa4G",NA
2.3 Linux - Installing the Tool-Chain,"The whole installation procedure will assume these requirements:
  
 • A PC running Ubuntu Linux 14.04 LTS Desktop (aka Trusty Tahr) with sufficient 
 hardware resources (I suggest to have at least 4Gb of RAM and 5Gb of free space on 
 the Hard Disk); the instructions should be easily arranged for other Linux 
 distributions.
  
 • Java 8 Update 121 or later. Read the
  next paragraph
  dedicated for Java installation if it 
 is not 
  
 installed yet.
  
  
 Choosing a Tool-Chain Folder
  
 One interesting feature of Eclipse is that it is not required to be installed in a specific 
 path on the Hard Disk. This allows the user to decide where to put the whole tool-
 chain and, if desired, to move it in another place or to copy it on another machine 
 (this is really useful if you have several Linux machines to maintain).
  
 In this book we will assume that the whole tool-chain is installed inside 
 the
 ∼
 /STM32Toolchain
  folder on the Hard Disk (that is, a
  STM32Toolchain
  directory inside",NA
2.3.1 Linux - Install i386 Run-Time Libraries on a 64-bit Ubuntu,"If your Ubuntu is a 64-bit release, then you need to install some compatibility libraries that 
 allow to run 32-bit applications. To do so, simply run the following commands at Linux 
 console:
  
 $
  sudo dpkg –-add-architecture i386
  
 $
  sudo apt-get update
  
 $
  sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386
  
 If in doubt about your Ubuntu release, then you can run the following command at Linux 
 console:
  
 $
  uname -i
  
 If the result is
  x86_64
 , then you have a 64-bit machine, otherwise a 32-bit one.",NA
2.3.2 Linux - Java Installation,"Java 8 installation under Ubuntu Linux requires an in-depth analysis. It is strongly 
 suggested to install the official Oracle distribution of Java, as shown here.
  
 First we need to add
  webupd8team
  Java PPA repository in our system and install Oracle Java 
 8 using following set of commands at Linux console:
  
 $
  sudo add-apt-repository ppa:webupd8team/java
  
 $
  sudo apt-get update
  
 $
  sudo apt-get install oracle-java8-installer
  
 After successfully installing the JDK, check that all works well running the
  java -version
  
 command at command line:
  
 $
  java -version
  
 java version ""1.8.0_60""
  
 Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
  
 Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)",NA
2.3.3 Linux - Eclipse Installation,"The first step is to install the Eclipse IDE. As said before, we are interested in the Eclipse 
 version for C/C++ developers. The latest version at time of revising this chapter (August",NA
2.3.4 Linux - Eclipse Plug-Ins Installation,"Once Eclipse is started, we can proceed to install some relevant plug-ins.
  
  
 What Is a Plug-In?
  
 A plug-in is an external software module that extends Eclipse functionalities. A plug-
 in must adhere to a standard API defined by Eclipse developers. In this way, it is 
 possible for third party developers to add features to the IDE without changing the 
 main source code. We will install several plug-ins in this book to adapt Eclipse to our 
 needs.
  
 The first plug-in we need to install is the
  C/C++ Development Tools SDK
 , also known as 
 Eclipse CDT. CDT provides a fully functional C and C++ Integrated Development 
 Environment based on Eclipse platform. Features include: support for project creation and 
 managed build for various tool-chains, standard make build, source navigation, various 
 source knowledge tools, such as type hierarchy, call graph, include browser, macro 
 definition browser, code editor with syntax highlighting, folding and hyperlink navigation, 
 source code refactoring and code generation, visual debugging tools, including memory, 
 registers, and disassembly viewers.
  
 To install CDT we have to follow this procedure. Go to
  Help->Install new software…
  as 
 shown in 
 Figure 15
 .",NA
2.3.5 Linux - GCC ARM Embedded Installation,"The next step in tool-chain configuration is installing the GCC suite for ARM Cortex-M and 
 Cortex-R microcontrollers. This is a set of tools (macro preprocessor, compiler, assembler, 
 linker and debugger) designed to cross-compile the code we will create for the STM32 
 platform.
  
 The latest release of ARM GCC can be downloaded from
  ARM Developer²⁴
 . At the time of 
 writing this chapter, the latest available version is the 6.0. The Linux tarball can be 
 downloaded from the 
 download section²⁵
 .
  
 Once download is complete, extract the .tar.bz2 package inside the
  ∼
 /STM32Toolchain
  
  
 The extracted folder, by default, is named
  gcc-arm-none-eabi-6-2017-q2-update
 . This is 
 not convenient, because when GCC is updated to a newer version we need to change 
 settings for each Eclipse project we have made. So, rename it to simply
  gcc-arm
 .",NA
2.3.6 Linux - Nucleo Drivers Installation,"Warning
  
 Read this paragraph carefully. Do not skip this step!
  
 On Linux, we do not need to install Nucleo drivers from ST, but we need to install
  libusb-1.0
  
 with the following command:
  
 $
  sudo apt-get install libusb-1.0
  
 2.3.6.1 Linux – ST-LINK Firmware Upgrade
  
  
 Warning
  
 Read this paragraph carefully. Do not skip this step!
  
 I bought several Nucleo boards and I saw that all boards come with an old ST-LINK 
 firmware. In order to use the Nucleo with OpenOCD, the firmware must be updated at least 
 to the 2.29.18 version.",NA
2.3.7 Linux – OpenOCD Installation,"OpenOCD²⁷
  is a tool that allows to upload the firmware on the Nucleo board and to do the 
 step-by-step debugging. OpenOCD is a tool that originally started by Dominic Rath, and now 
 actively maintained by the community and several companies, including ST. We will discuss 
 it in depth in chapter 5, which is dedicated to the debugging. But we will install it in this 
 chapter, because the install procedure changes between the three different platforms 
 (Windows, Linux and Mac OS). The latest official release at the time of writing this book is 
 the 0.10.
  
 The quickest solution to install OpenOCD consists in using a pre-compiled package 
 provided by Liviu Ionescu. In fact, he has already done the dirty job for us. You can 
 download the latest development version of OpenOCD (0.10.0-5-20171110-* at the time of 
 writing this chapter) from the
  GNU MCU Eclipse official repository²⁸
 . Choose the
  .tgz
  
 package for your Linux platform (32-or 64-bits - they are named
  debian32
  or
  debian64
 ). 
 Extract the files in a convenient place. When complete, you will find a folder named
  openocd
 , 
 which in turn contains a folder named in the same way of the
  .tgz
  package (for example, 
 you will find a folder named
  0.10.0-5-20171110-1117
 ). Copy that folder inside the inside the
  
 ∼
 /STM32Toolchain
  folder and rename it in
  openocd
 , so that the final path is equal to
  
 ∼
 /STM32Toolchain/openocd
 .
  
  
 Once again, this ensures us that we should not change Eclipse settings when a new 
 release of OpenOCD will be released, but we only need to replace the content of",NA
2.3.8 Linux - ST Tools Installation,"ST provides several tools that are useful for developing STM32 based applications.
  
 STM32CubeMX is a graphical tool used to generate setup files in C programming language 
 for an STM32 MCU, according the hardware configuration of our board. For example, if we 
 have the Nucleo-F401RE, which is based on the STM32F401RE MCU, and we want to use its 
 user LED (marked as LD2 on the board), then STM32CubeMX will automatically generate 
 all source files containing the C code required to configure the MCU (clock, peripheral 
 ports, and so on) and the GPIO connected to the LED (port GPIO 5 on port A on almost all 
 Nucleo boards). You can download the latest version of STM32CubeMX (currently, the 
 4.23) from the official
  ST page²⁹
  (the download link is at the bottom",NA
2.4 Mac - Installing the Tool-Chain,"The whole installation procedure will assume these requirements:
  
 • A Mac running Mac OSX 10.11 (aka El Capitan) or higher with sufficient hardware 
 resources 
  
 (I suggest to have at least 4Gb of RAM and 5Gb of free space on the Hard 
 Disk).
  
 • You have already installed the Xcode release that fits your Mac OSX version (you can 
 download it using the App Store) and its corresponding
  command line tools
 . You will 
 find several tutorials",NA
2.4.1 Mac - Eclipse Installation,"The first step is to install the Eclipse IDE. As said before, we are interested in the Eclipse 
 version for C/C++ developers. The latest version at time of revising this chapter (August 
 2018) is Photon (Eclipse v4.8).
  However, it is strongly suggested to use the previous 
 release, that is Oxygen.3a (Eclipse v4.7.3a), since the newest one is still not 
 supported by the GNU MCU Eclipse plug-ins suite and by several other tools used in 
 this book.
  It can be downloaded from the official
  download page³⁴
  as shown in
  Figure 
 25
 ³⁵
 .
  
 ³²
 https://www.macports.org/
  
 ³³
 http://bit.ly/2k5ppYR
  
 ³⁴
 https://www.eclipse.org/downloads/packages/release/oxygen/3a/
  
 ³⁵
 Some screen captures may appear different from the ones reported in this book. This happens because the Eclipse IDE is updated 
 frequently. Don’t worry about that: the installation instructions should work in any case.",NA
2.4.2 Mac - Eclipse Plug-Ins Installation,"Once Eclipse is started, we can proceed to install some relevant plug-ins.
  
  
 What is a Plug-In?
  
 A plug-in is an external software module that extends Eclipse functionalities. A plug-
 in must adhere to a standard API defined by Eclipse developers. In this way, it is 
 possible for third party developers to add features to the IDE without changing the 
 main source code. We will install several plug-ins in this book to adapt Eclipse to our 
 needs.
  
 The first plug-in we need to install is the
  C/C++ Development Tools SDK
 , also known as 
 Eclipse CDT. CDT provides a fully functional C and C++ Integrated Development 
 Environment based on Eclipse platform. Features include: support for project creation and 
 managed build for various tool-chains, standard make build, source navigation, various 
 source knowledge tools, such as type hierarchy, call graph, include browser, macro 
 definition browser, code editor with syntax highlighting, folding and hyperlink navigation, 
 source code refactoring and code generation, visual debugging tools, including memory, 
 registers, and disassembly viewers.
  
 To install CDT we have to follow this procedure. Go to
  Help->Install new software…
 .",NA
2.4.3 Mac - GCC ARM Embedded Installation,"The next step in tool-chain configuration is installing the GCC suite for ARM Cortex-M and 
 Cortex-R microcontrollers. This is a set of tools (macro preprocessor, compiler, assembler, 
 linker and debugger) designed to cross-compile the code we will create for the STM32 
 platform.",NA
2.4.4 Mac - Nucleo Drivers Installation,"Warning
  
 Read this paragraph carefully. Do not skip this step!
  
 On Mac, we do not need to install Nucleo drivers from ST, but we need to install
  libusb-1.0
  
 with the following command:
  
 $
  sudo port install libtool libusb
  [
 libusb-compat
 ] [
 libftdi1
 ]
  
 2.4.4.1 Mac – ST-LINK Firmware Upgrade
  
  
 Warning
  
 Read this paragraph carefully. Do not skip this step!
  
 I have bought several Nucleo boards and I saw that all boards come with an old ST-LINK 
 firmware. In order to use the Nucleo with OpenOCD, the firmware must be updated at least 
 to the 2.29.18 version.
  
 Once the ST-LINK drivers are installed, we can download the latest ST-LINK drivers from
  
 ST website³⁹
 . The firmware is distributed as ZIP file. Extract it in a convenient place. 
 Connect your Nucleo board using a USB cable and go inside the
  AllPlatforms
  subfolder and 
 execute the file 
 STLinkUpgrade.jar
 . Click on
  Open in update mode
  button.
  
 ³⁷
 https://developer.arm.com/open-source/gnu-toolchain/gnu-rm
  
 ³⁸
 https://developer.arm.com/open-source/gnu-toolchain/gnu-
 rm/downloads
 ³⁹
 http://bit.ly/1RLDp3H",NA
2.4.5 Mac – OpenOCD Installation,"OpenOCD⁴⁰
  is a tool that allows to upload the firmware on the Nucleo board and to do the 
 step-by-step debugging. OpenOCD is a tool that originally started by Dominic Rath, and now 
 actively maintained by the community and several companies, including ST. We will discuss 
 it in depth in chapter 5, which is dedicated to the debugging. But we will install it in this 
 chapter, because the install procedure changes between the three different platforms 
 (Windows, Linux and Mac OS). The latest official release at the time of writing this book is 
 the 0.10.
  
 The quickest solution to install OpenOCD consists in using a pre-compiled package 
 provided by Liviu Ionescu. In fact, he has already done the dirty job for us. You can 
 download the latest development version of OpenOCD (0.10.0-5-20171110-* at the time of 
 writing this chapter) from the 
 GNU MCU Eclipse official repository⁴¹
 . Choose the file ending 
 with
  .pkg
  and launch the installer when downloaded. Follow the installation instructions. 
 When complete, the installer will place all files inside the
  /Applications/GNU MCU 
 Eclipse/OpenOCD
  folder. You will find in turn a folder named in the same way of the
  .pkg
  
 package (for example, you will find a folder named
  0.10.0-5-20171110-1117
 ). Copy that folder 
 inside the inside the
  ∼
 /STM32Toolchain
  folder and rename it in 
 openocd
 , so that the final path 
 is equal to
  ∼
 /STM32Toolchain/openocd
 .
  
  
 Once again, this ensures us that we will not change Eclipse settings when a new 
 release of OpenOCD will be released, but we will only need to replace the
  
 ∼
 /STM32Toolchain/openocd 
 with the new software release.
  
 Ok. We are ready to test our Nucleo board. Plug it in your Mac using USB cable. After a few 
 seconds, type the following commands:",NA
2.4.6 Mac - ST Tools Installation,"ST provides several tools that are useful for developing STM32 based applications.
  
 STM32CubeMX is a graphical tool used to generate setup files in C programming language 
 for an STM32 MCU, according the hardware configuration of our board. For example, if we 
 have the Nucleo-F401RE, which is based on the STM32F401RE MCU, and we want to use its 
 user LED (marked as LD2 on the board), then STM32CubeMX will automatically generate 
 all source files containing the C code required to configure the MCU (clock, peripheral 
 ports, and so on) and the GPIO connected to the LED (port GPIO 5 on port A on almost all 
 Nucleo boards). You can download the latest version of STM32CubeMX (currently, the 
 4.23) from the official
  ST page⁴²
  (the download link is at the bottom of the page). The file is 
 a ZIP archive. Once extracted, you will find a file named
  SetupSTM32CubeMX-4_14_0_macos
 . This 
 file is the setup program to install the tool. The setup program may need root privileges if 
 you want to install STM32CubeMX system wide. So, double click on the
  SetupSTM32CubeMX-
 4_14_0_macos
  icon. After a while, the setup wizard will appear, as shown in
  Figure 30
 .
  
  
 Figure 30: STM32CubeMX install wizard
  
 Follow the setup instructions. By default, the program is installed in
  /Applications/STMicroelec-
 tronics
 . Once setup is completed, open the Finder and go inside the
  /Applications/STMicroelec-
  
 ⁴²
 http://bit.ly/1RLCa4G",NA
"3. Hello, Nucleo!","There is no programming book that does not begin with the classic “Hello world!” program. 
 And this book will follow the tradition. In the previous chapter we have configured the 
 development environment needed to program STM32 based boards. So, we are now ready 
 to start coding.
  
 In this chapter we will create a really basic program: a blinking LED. We will use the GNU 
 MCU Eclipse plug-in to create a complete application in a few steps without dealing, in this 
 phase, with aspects related to the ST
  Hardware Abstraction Layer
  (HAL). I am aware that 
 not all details presented in this chapter will be clear from the beginning, especially if you 
 are totally new to embedded programming.
  
 However, this first example will allow us to become familiar with the development 
 environment. Following chapters, especially the
  next one
 , will clarify a lot of obscure 
 things. So I suggest you to be patient and try to take the best from the following paragraphs.",NA
A Note on GNU MCU Eclipse Plug-ins,"Experienced programmers might observe that these plug-ins are not strictly 
 necessary to generate code for the STM32 platform. It is perfectly possible to start 
 importing the HAL in an empty C/C++ project and to configure the tool-chain 
 accordingly. Moreover, as we will see in the
  next chapter
 , it is better to directly use 
 the code from the latest HAL release and the one automatically generated by 
 STM32CubeMX tool. However, the GNU MCU plugin brings several features that 
 simplify the project management. Moreover, I think that for newbies it is 
 recommended to start with an automatic-generated project to avoid a lot of 
 confusion. When writing code for the STM32 platform, we need to deal with a lot of 
 tools and libraries. Some of them are mandatory, while others may lead to confusion. 
 So it is best to start gradually and dive inside the whole stack. Once you get familiar 
 with the development environment, it will be really easy to adapt it to your needs.
  
 If you are totally new to Eclipse IDE, the next paragraph will briefly explain its main 
 functionalities.",NA
3.1 Get in Touch With the Eclipse IDE,"When you start Eclipse, you might be a bit puzzled by its interface.
  Figure 1
 ¹
  shows how 
 Eclipse appears when started for the first time.
  
  
 ¹
 Starting from this chapter, all screen captures, unless differently required, are based on Mac OS, because it is the OS the author 
 uses to develop STM32 applications (and to write this book). However, they also apply to other Operating Systems.",NA
3.2 Create a Project,"Let us create our first project. We will create a simple application that makes the Nucleo 
 LD2 LED (the green one) blink.
  
 Go to
  File->New->C Project
 . Eclipse shows a wizard that allows us to create our test 
 project (see 
 Figure 7
 ).",NA
3.3 Connecting the Nucleo to the PC,"Once we have compiled our test project, you can connect the Nucleo board to your 
 computer using an USB cable connected to micro-USB port (called
  VCP
  in
  Figure 12
 ). After 
 few seconds, you should see at least two LED turning ON.
  
  
 The first one is the LD1 LED, which in
  Figure 12
  is called
  ST-LINK LED
 . It is a red/green 
 LED and it is used to signal the ST-LINK activity: once the board is connected to the 
 computer, that LED is green; during a debug session or while uploading the firmware on 
 the MCU it blinks green and red alternatively.
  
 Another LED that turns ON when the board is connected to the computer is the LED LD3, 
 which is called
  POWER LED
  in
  Figure 12
 . It is a red LED that turns ON when the USB port 
 ends
  enumeration
 , that is the ST-LINK interface is properly recognized by the computer OS 
 as a USB peripheral. The",NA
3.4 Flashing the Nucleo using STM32CubeProgrammer,"ST has recently introduced a new and really practical tool to flash firmware on the target 
 board: STM32CubeProgrammer. Its aim is to replace the historical ST-LINK Utility tool and 
 the good news is that it is finally multi-platform. The tool is not still perfectly stable, but I 
 am sure that next releases will fix its early bugs.
  Figure 13
  shows the 
 STM32CubeProgrammer’s main interface.
  
  
 Figure 13: The STM32CubeProgrammer interface once connected to the board
  
 We installed STM32CubeProgrammer in Chapter 2 and now we are going to use it. Launch 
 the program and connect your Nucleo to the PC using the USB cable. Once 
 STM32CubeProgrammer has identified the board its serial number will appear in the
  
 Serial number
  combo box, as shown in 
 Figure A
 .",NA
3.5 Understanding the Generated Code,"Now that we brought a cold piece of hardware to life, we can give a first look at the code 
 generated by the GNU MCU plugin. Opening
  main.c
  file we can see the content of
  main()
  
 function, the entry point
 ⁹
  of our application.
  
 ⁹
 Experienced STM32 programmers know that it is improper to say that the
  main()
  function is the entry point of an STM32 
 application. The execution of the firmware begins much earlier, with the calling of some important setup routines that create the 
 execution environment for the firmware. However, from the
  application point of view
 , its start is inside the
  main()
  function. A
  
 following chapter
  will show in detail the bootstrap process of an STM32 microcontroller.",NA
4. STM32CubeMX Tool,"STM32CubeMX
 ¹
  is the Swiss army knife of every STM32 developer, and it is a fundamental 
 tool especially if you are new to the STM32 platform. It is a quite complex piece of software 
 distributed freely by ST, and it is part of the
  STCube initiative²
 , which aims to provide to 
 developers with a complete set of tools and libraries to speed up the development process.
  
 Although there is a well-established group of people that still develops embedded software 
 in pure assembly code
 ³
 , time is the most expensive thing during project development 
 nowadays, and it is really important to receive as much help as possible for a quite complex 
 hardware platform like the STM32.
  
 In this chapter we will see how this tool from ST works, and how to build Eclipse projects 
 from scratch using the code generated by it. This will make GNU MCU plugin a less critical 
 component for project generation, allowing us to create better code and ready to be 
 integrated with the STM32Cube HAL. However, this chapter is not a substitute for the
  
 official ST documentation for CubeMX tool⁴
 , a document made of more than 170 pages that 
 explains in depth all its functionalities.",NA
4.1 Introduction to CubeMX Tool,"CubeMX is the tool used to configure the microcontroller chosen for our project. It is used 
 both to choose the right hardware connections and to generate the code necessary to 
 configure the ST HAL.
  
 CubeMX is a
  MCU-centric
  application. This means that all activities performed by the tool 
 are based on:
  
 • The family of the STM32 MCU (F0, F1, and so on).
  
 • The type of package chosen for our device (LQFP48, BGA144, and so on).
  
 • The hardware peripherals we need in our project (USART, SPI, etc.).
  
 –
  How chosen peripherals are mapped to microcontroller pins.
  
 • MCU general configurations (like clock, power management, NVIC controller, and so 
 on)
  
 In addition to features related to the hardware, CubeMX is also able to deal with the 
 following software aspects:
  
 ¹
 STM32CubeMX name will be simplified in
  CubeMX
  in the rest of the book.
  
  
 ²
 http://bit.ly/1YKvl85
  
  
 ³
 Probably, one day someone will explain them that, except for really rare and specific cases, a modern compiler can generate 
 better assembly code from C than could be written directly in assembly by hand. However, we have to say that these habits are 
 limited to ultra low-cost 8-bit MCUs like PIC12 and similar.",NA
4.1.1 Pinout View,"The
  Pinout
  view is the first one, and it is divided in two parts. The right side contains the 
 MCU representation with the selected peripherals and GPIOs, and it is called by ST
  Chip 
 view
 . In the left side we have the list, in form of a tree view, of all peripherals (hardware 
 parts) and middleware libraries (software parts) that can be used with the selected MCU. 
 This is called by ST
  IP tree pane
 .
  
 4.1.1.1 Chip View
  
 The
  Chip view
  allows to easily navigate inside the MCU configuration, and it is a really 
 convenient way to configure the microcontroller.
  
 Pins
 ⁵
  colored in bright green are
  enabled
 . This means that CubeMX will generate the 
 needed code to configure that pin according its functionalities. For example, for pin
  PA5
  
 CubeMX will generate the C code needed to setup it as generic output pin
 ⁶
 .
  
 A pin is colored in orange when
  the corresponding peripheral
  is not enabled. For 
 example, pins 
 PA2
 ⁷
  and
  PA3
  are enabled and CubeMX will generate corresponding C code to 
 initialize them, but the associated peripherals (USART2) is not enabled and no setup code 
 will be automatically generated. Yellow pins are power source pins, and their configuration 
 cannot be changed.
  
 BOOT and RESET pins are colored in khaki, and their configuration cannot be changed.",NA
4.1.2 Clock View,"Figure 8: The CubeMX clock view
  
 Clock view is the area where all configurations related to clocks management take place. 
 Here we can set both the main core and the peripherals clocks. All clock sources and PLLs 
 configurations are presented in a graphical way (see
  Figure 8
 ). The first times the user see 
 this view, he could be puzzled by the amount of configuration options. However, with a 
 little bit of practice, this is the simplest way to deal with the STM32 clock configuration 
 (which is quite complex if compared to 8-bit MCUs).
  
 If your board design needs an external source for the High Speed clock (HSE), the Low 
 Speed clock (LSE) or both, you have to first enable it in the
  Pinout
  view in the RCC section, 
 as shown in
  Figure 9
 .",NA
4.1.3 Configuration View,"Configuration view allows to further setup peripherals and software components. For 
 example, it is possible to enable pull-up for a GPIO pin, or to configure the FATFS options.
  
  
 Figure 10: The CubeMX configuration view
  
 Configuration options defined in this view impact the automatically generated C source 
 code. A good management of this CubeMX section allows to simplify a lot the development 
 process related",NA
4.1.4 Power Consumption Calculator View,"Power Consumption Calculator
  (PCC) view is a feature of CubeMX that, given a 
 microcontroller, a battery model and a user-defined power sequence, provides an 
 estimation of the following parameters:
  
 • Average power 
 consumption.
  
 • Battery life.
  
 • Average DMIPS.
  
 It is possible to add user-defined batteries through a dedicated interface.
  
 For each step, the user can choose VBUS as possible power source instead of the battery. 
 This will impact the battery life estimation. If power consumption measurements are 
 available at different voltage levels, CubeMX will also propose a choice of voltage values.
  
  
 Figure 10: The CubeMX configuration view
  
 PCC view will be analyzed in a
  following chapter
 .",NA
4.2 Project Generation,"Once the configuration of the MCU, of its peripherals and middleware software is 
 completed, we can use CubeMX to generate the C project skeleton for us. In this paragraph 
 we will see all the required steps to:
  
 • Create a new “universal” Eclipse project, ready to accept CubeMX auto-generated C 
 code.• Import the CubeMX generated files inside the Eclipse project.
  
 • Configure the project, if needed.
  
 The final result of this chapter will be another
  blinking application
 , but this time we will 
 create it using the most of the code coming from the latest STCube framework. This will 
 also give us the opportunity to start understanding the foundation blocks of the STCube
  
 Hardware Abstraction Layer 
 (HAL). Once we understand the steps explained here, we 
 would be fully autonomous in setting up any project for the STM32 platform.",NA
4.2.1 Generate C Project with CubeMX,"The first step is to generate the C code containing HAL initialization code using CubeMX 
 tool. If you have done experiments in the previous paragraph, it is better to start a totally 
 new project, selecting your Nucleo board from the
  Board Selector Tool
 , as shown
  before
 .",NA
4.2.2 Create Eclipse Project,"We are now going to create an Eclipse project that will host the files generated by CubeMX. 
 Go to
  File->New->C Project
  menu. Type the project name you like and select
  Hello World 
 ARM Cortex-M C/C++ Project
  as project type.",NA
4.2.3 Importing Generated Files Into the Eclipse Project Manually,"Once we have created the Eclipse project, we need to import the CubeMX project inside it. 
 There are two ways to do this: manually or using a convenient tool made by the author of 
 this book. It is strongly suggested to execute the operation manually at least once, in order 
 to understand exactly what software components are involved in this operation.
  
 ¹⁰
 Clearly, the memory length depends on the specific MCU. Always double check that they correspond with the hardware 
 specifications of your MCU. If they do not match, strange faults may occur at startup (we will learn how to deal with hardware faults 
 in a
  following chapter
 ). Another quick solution is offered to us by CubeMX. Opening the
  ∼
 /STM32Toolchain/cubemx-out/<project-
 name>/SW4STM32/<project-name> Configuration
  folder you will find a file ending with
  .ld
 . It is the linker script containing the right 
 memory origin definitions for your MCU. You can simply copy the
  MEMORY
  section contained in that file and past it into the
  
 ldscripts/mem.ld
  file.",NA
4.2.4 Importing Files Generated With CubeMX Into the Eclipse ,NA,NA
Project Automatically,"The previous steps can be executed automatically using a bare-bone Python script. Its name 
 is CubeMXImporter and it can be downloaded by this author’s
  github account¹²
 .
  
  
 Read Carefully
  
 The tool automatically deletes all unneeded existing project files. This includes also 
 the 
 main.c
  file and all other files contained in
  src
  and
  include
  Eclipse Folder. For this 
 reason, do not execute the CubeMXImporter on an existing project. Always execute it 
 on a fresh new Eclipse project generated with the GNU MCU Eclipse plugin.
  
  
 This script works well only if you have generated a CubeMX project for the 
 SW4STM32 (aka AC6) tool-chain.
  
 CubeMXImporter relies on Python 2.7.x and the
  lxml
  library. Here you can find the 
 installation instructions for Windows, Linux and Mac OSX.
  
  
 Windows
  
 In Windows we have to install first the latest Python 2.7 release. We can download it 
 directly from
  this link¹³
 . Once downloaded, launch the installer and ensure that all 
 installation options are enabled, as shown in
  Figure 18
 . When the installation is 
 completed, you can install a pre-compiled lxml package, downloading
  it from here¹⁴
 .
  
  
 Linux and MacOS X
  
 On these two Operating Systems, Python 2.7 is installed by default. So, we only need 
 to install the
  lxml
  library (if it is not already installed). We can simply install it using 
 the
  pip 
 command:
  
 $
  sudo pip install lxml
  
 ¹²
 https://github.com/cnoviello/CubeMXImp
 orter
  
 ¹³
 http://bit.ly/1MjXoGb
  
 ¹⁴
 http://bit.ly/1P4lxSO",NA
4.3 Understanding Generated Application Code,"We finally have a fully working project template to start with. If you want, to avoid 
 repeating the previous annoying procedures, you can follow this recipe:
  
 • store the template project in a place separated from the Eclipse workspace;
  
 • import it inside the workspace when you need to start a new project (Go to File-
 >Import… and 
  
 choose the entry
  Import Existing Projects into Workspace
 );
  
 • open the project and rename it as you want by clicking with the right mouse button on 
 the 
  
 project root and choosing the entry
  Rename…
 .",NA
4.3.1 Add Something Useful to the Firmware,"Now that we are masters of the code generated by CubeMX, we can add something useful to 
 the 
 main()
  function. We will add the code required to blink the LD2 LED when the user 
 presses the Nucleo blue button connected to PC13.
  
 Filename:
  src/main.c
  
 7
 2 
  
 7
 3 
  
 7
 4 
  
 7
 5 
  
 7
 6 
  
 7
 7 
  
 7
 8 
  
 7
 9
  
 while
  (
 1
 )
  
 {
  
  
 if
 (HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin)
  ==
  GPIO_PIN_RESET) { 
  
  
 while
 (
 1
 ) { 
  
  
  
  
 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin); 
  
  
  
 HAL_Delay(
 500
 ); 
  
  
  
 } 
  
  
 } 
  
 }
  
 At line 72 there is an infinite loop that waits until
  HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) 
 returns the value
  GPIO_PIN_RESET
 , that is the user has pressed the blue button. When this 
 happens, the MCU enters another infinite loop where the
  LD2_Pin
  pin is toggled every 
 500ms. The macros 
 LD2_Pin
 ,
  B1_GPIO_Port
  and
  B1_Pin
  are defined inside the
  main.h
  file.",NA
4.4 Downloading Book Source Code Examples,"All examples presented in this book are available for downloading from its GitHub 
 repository: 
 http://github.com/cnoviello/mastering-stm32¹⁵
 .
  
 ¹⁵
 http://github.com/cnoviello/mastering-stm32",NA
5. Introduction to Debugging,"Coding is all about debugging
 , said a friend of mine one day. And this is dramatically true. 
 We can do all the best writing really great code, but sooner or later we have to deal with 
 software bugs (hardware bugs are another terrible beast to fight). And a good debugging of 
 embedded software is all about to be a happy embedded developer.
  
 In this chapter we will start analyzing an important debugging tool: OpenOCD. It has 
 become a sort of standard in the embedded development world, and thanks to the fact that 
 many companies (including ST) are officially supporting its development, OpenOCD is 
 facing a rapid growth. Every new release includes the support for tens of microcontrollers 
 and development boards. Moreover, being portable among the three major Operating 
 Systems (Windows, Linux and Mac OS), it allows us to use one unique and consistent tool to 
 debug examples in this book.
  
 This chapter also covers another important debugging mechanism:
  ARM semi-hosting
 . It is a 
 way to communicate input/output requests from application code to a host computer 
 running a debugger and it is extremely useful to execute functions that would be too 
 complicated (or impossible due to the lack of some hardware features) to execute on the 
 target microcontroller.
  
 This chapter is a preliminary view of the debugging process, which would require a 
 separate book even for simpler architectures like the STM32.
  Chapter 24
  will give a close 
 look at other debugging tools, and it will focus on Cortex-M exception mechanism, which is 
 a distinctive feature of this platform.",NA
5.1 Getting Started With OpenOCD,"The
  Open On-Chip Debugger¹
  (OpenOCD) started as thesis work by Dominic Rath and now 
 is actively developed and maintained by a large and growing community, with the official 
 support from several silicon vendors.
  
 OpenOCD aims to provide debugging, in-system programming and boundary-scan testing 
 for embedded target devices. It does so with the assistance of a hardware debug adapter, 
 which provides the right kind of electrical signaling to the target being debugged. In our 
 case, this adapter is the integrated ST-LINK debugger provided by the Nucleo board
 ²
 . Every 
 debug adapter uses a 
 transport protocol
  that mediates between the hardware under 
 debugging and the host software, that is OpenOCD.
  
  
 ¹
 http://openocd.org
  
  
 ²
 The Nucleo ST-LINK debugger is designed so that it can be used as standalone adapter to debug an external device (e.g., a 
 board designed by you equipping an STM32 MCU).",NA
5.1.1 Launching OpenOCD,"Before we configure Eclipse to use OpenOCD in our project, it is better to take a look at how 
 OpenOCD works at a lower level. This will allow us to familiarize with it and, in case 
 something does not works properly, it will allow to better investigate for issues related to 
 the OpenOCD configuration.
  
 The instructions to start OpenOCD are different between Windows and UNIX like systems. 
 So, jump to the paragraph that fits your OS.",NA
5.1.2 Connecting to the OpenOCD Telnet Console,"Once OpenOCD starts, it acts as a daemon program
 ⁶
  waiting for external connections. 
 OpenOCD offers two ways to interact with it. One of these is mode is through GDB (the GNU 
 Debugger), as we will see later. The other one is through a
  telnet
 ⁷
  connection to the 
 localhost port
  4444
  ⁸
 . Let us start a connection.
  
 $
  telnet localhost
  4444 
  
 Trying ::1...
  
 telnet: connect to address ::1: Connection refused Trying 
 127.0.0.1...
  
 Connected to localhost.
  
 Escape character is '^]'.
  
 Open On-Chip Debugger 
  
 >
  
 To access to the list of supported commands, we can type
  help
 . The list is quite huge, and its 
 content is outside of the scope of this book (the official OpenOCD document is a good place 
 to start understanding what those commands are used for). Here, we will simply see how to 
 flash the firmware.
  
 Before we can upload a firmware to the target MCU of our Nucleo, we have to halt the MCU. 
 This is done issuing a
  reset init
  command:
  
 Open On-Chip Debugger 
  
 >
  reset init 
  
 target state: halted 
  
 target halted due to debug-request, current mode: Thread xPSR: 
 0x01000000 pc: 0x080002a8 msp: 0x20018000, semihosting
  
 OpenOCD says to us that the micro is now halted and we can proceed to upload the 
 firmware using the
  flash write_image
  command:
  
  
 ⁶
 Daemon
  is the way in UNIX to name those programs that works like a service. For example, a hTTP server or an FTP server is 
 called a 
 daemon
  in UNIX. In the Windows world these kind of programs are called
  services
 .
  
  
 ⁷
 Starting from Windows 7,
  telnet
  is an optional component to install. However, it is strongly suggested to use a more evolute 
 telnet client like
  putty
  (http://bit.ly/1jsQjnt).",NA
5.1.3 Configuring Eclipse,"Now that we are familiar with the way OpenOCD works, we can configure Eclipse to debug 
 our application from the IDE. This will dramatically simplify the debugging process, 
 allowing us to easily set breakpoints in our code, to inspect the content of variables and to 
 do step-by-step execution.",NA
5.1.4 Debugging in Eclipse,"Eclipse provides a complete separated perspective dedicated to debugging. It is designed to 
 offer the most of required tools during the debugging process, and it can be customized at 
 need adding other views offered by additional plug-ins (more about this later).
  
 ¹⁰
 This setting saves the debug configuration at project level, and not as global Eclipse setting. This will allow us to share the 
 configuration with other people if we work in team.",NA
5.2 ARM Semihosting,"ARM semihosting
  is a distinctive feature of the Cortex-M platform, and it is extremely useful 
 for testing and debug purpose. It is a mechanism that allows target boards (e.g. the Nucleo 
 board) to“exchange messages” from the embedded firmware to a host computer running a 
 debugger. This mechanism enables some functions in the C library, such as
  printf()
  and
  
 scanf()
 , to use the screen and keyboard of the host instead of having a screen and keyboard 
 on the target system. This is useful because development hardware often does not have all 
 the input and output facilities of the final system. Semihosting enables the host computer to 
 provide these facilities.
  
 Semihosting requires additional runtime library code and it can be implemented in several 
 ways on Cortex-M architecture. However, the preferred one is by the use of the
  bktp
  ARM 
 assembly instruction, the one used by the debugger to set breakpoints. Luckily for us, Liviu 
 Ionescu has already packed in his GNU MCU Eclipse plugin a working support for the most 
 common semihosting operations. So it is extremely easy to enable this feature for our 
 projects. However, a deep understanding of how semihosting works can dramatically 
 simplify the debug process in certain critical operations.
  
 The next paragraph will give a quick explanation of how to configure our Eclipse project to 
 use semihosting in our code. This will allows us to print messages on the OpenOCD console. 
 This is a fantastic debug tool, especially when you need to understand what is happening to 
 your firmware.",NA
5.2.1 Enable Semihosting on a New Project,"GNU MCU plug-in allows to easily enable semihosting support during the project 
 generation. We already encountered these options so far, but for the sake of simplicity we 
 did not care about them. Now it is the right time to have a look. Let us generate a new 
 project.",NA
5.2.2 Enable Semihosting on an Existing Project,"If you have an existing project and you want to enable semihosting, we need to distinguish 
 between two cases.
  
 The first one is the more simple. If you have generated the project using the GNU MCU plug-
 in, you only need to add the following global macro to project settings:
  
 • If you want to use only the
  trace_printf()
  functions from Liviu Ionescu, then add the 
 macros 
  
 TRACE
  and
  OS_USE_TRACE_SEMIHOSTING_DEBUG
 .
  
 • If you want to use the C standard library I/O manipulation functions, then add the 
 macro
  OS_-USE_SEMIHOSTING
  and uncheck the flag
  Assume freestanding environment 
 (-ffreestanding)
 .
  
 The second case is the more complex. You have an existing project imported in Eclipse that 
 has not been generated using the GNU MCU Eclipse plugin. If it is sufficient to use the
  
 trace_printf() 
 function, then you can import inside your project these files taken from a 
 project generated with the GNU MCU plugin:
  
 •
  
 src/diag/trace_impl.
 c
  
 •
  src/diag/Trace.c
  
 •
  
 include/diag/Trace.
 h
  
 Next, you have to define the macros
  TRACE
  and
  OS_USE_TRACE_SEMIHOSTING_DEBUG
  at project 
 level and to call the routine
  initialise_monitor_handles()
  in your
  main()
  routine.
  
 In case you want to use all standard C library I/O routines, you need to:",NA
5.2.3 Semihosting Drawbacks,"Semihosting is an excellent feature, but it has also several drawbacks. First of all, it works 
 only during a debug session, and it completely hangs the firmware if not running under the 
 GDB control. For example, upload one of the previous examples on your Nucleo board and 
 terminate the debug session. If you reset your board pressing the RESET button, you will 
 not see the LD2 LED blinking. This happens because the firmware is stuck in the
  trace_printf()
  
 routine (more about why this happens in the next paragraph). This is a really common 
 issue that every novice encounters every time it starts working with the STM32 platform.
  
 Another important aspect to keep in mind is that semihosting has a great impact on the 
 firmware performance. Every semihosting call costs several CPU cycles, and it impacts on 
 the overall performance. Moreover, this cost in unpredictable, because it involves activities 
 that happens outside the MCU execution streams (more about this in the next paragraph).
  
 In
  Chapter 8
  we will see another interesting technique to exchange messages with the host 
 PC using one of the STM32 USARTs.",NA
5.2.4 Understanding How Semihosting Works,"If you are new to the STM32 world and you are a little bit confused by its initial complexity, 
 you can stop reading this paragraph and jump to next chapter. What we will be described 
 here is an advanced topic, that needs a bit of understanding of how ARM architecture 
 works and some advanced GCC features. It is not required you read this paragraph, but 
 having a look at it could improve your global understanding.
  
 There are several ways to implement semihosting capabilities. One of this is through the 
 use of software breakpoints. ARM Cortex-M offers two types of breakpoints: Hardware 
 (HBP) and Software (SBP) breakpoints.
  
 HBP is set by programming the
  Break Point Unit
  (a hardware unit inside every Cortex-M 
 core) to monitor the core buses for an instruction fetch from a specific memory location. 
 HBP can be set on any location in RAM or ROM using an external physical programmer 
 connected to the Debug Interface. In case of the Nucleo board, the integrated ST-LINK 
 programmer is connected to the MCU 
 Debug Interface
 , and it is in turn managed by 
 OpenOCD.
  Figure 20
  shows the relation between the external debugger and the internal 
 MCU debug unit.",NA
II Diving into the HAL,NA,NA
6. GPIO Management,"With the advent of the STCube initiative, ST has decided to completely revamp the
  
 Hardware Abstraction Layer
  (HAL) for its STM32 microcontrollers. Prior to the release of 
 the STCube HAL, the official library to develop STM32 applications was for a long time the
  
 Standard Peripheral Library
 . Despite of the fact it is still widespread between STM32 
 developers, and you can find a lot of examples on the web using this library, the STCube 
 HAL is a great improvement respect of the old Standard Peripheral Library. In fact, being 
 the first library developed by ST, not all of its parts were consistent between different 
 STM32 families and a lot of bugs were present in the early versions of the library. This 
 caused the emergence of different alternatives to the Standard Peripheral Library, and the 
 official software from ST is still considered poor by many people.
  
 So, ST has completely redesigned the HAL and, even if it still needs a little bit of tuning, it is 
 what ST will officially support in the future. Moreover, the new HAL simplifies a lot the 
 porting of code between the STM32 sub-families (F0, F1, etc.), reducing the effort needed to 
 adapt your application to a different MCU (without a good abstraction layer, the pin-to-pin 
 compatibility is just an advantage from the marketing point of view). For this and several 
 other reasons, this book is based exclusively on the STCube HAL.
  
 This chapter starts our journey inside the HAL looking to one of its simplest modules:
  
 HAL_GPIO
 . We have already used many functions from this module in the early examples in 
 this book, but now it is the right time to understand all possibilities offered by a so simple 
 and commonly used peripheral. However, before we can start describing HAL features, it is 
 best to give a quick look at how the STM32 peripherals are mapped to logical addresses 
 and how they are represented inside the HAL library.",NA
6.1 STM32 Peripherals Mapping and HAL,NA,NA
 Handlers,"Every STM32 peripheral is interconnected to the MCU core by several orders of buses, as 
 shown in 
 Figure 1
 ¹
 .
  
 ¹
 Here, to simplify this topic, we are considering the bus organization of one of the simplest STM32 microcontrollers, the 
 STM32F030. STM32F4 and STM32F7, for example, have a more advanced bus interconnection system, which is outside the scope of 
 this book. Please, always refer to the reference manual of your MCU.",NA
6.2 GPIOs Configuration,"Every STM32 microcontroller has a variable number of general programmable I/Os. The 
 exact number depends on:
  
 • The type of package chosen (LQFP48, BGA176, and so on).
  
 • The family of microcontroller (F0, F1, etc.).• 
 The usage of external crystals for HSE and 
 LSE.
  
 GPIOs are the way an MCU communicates with the external world. Every board uses a 
 variable number of I/Os to drive external peripherals (e.g. an LED) or to exchange data 
 through several types of communication peripherals (UART, USB, SPI, etc.). Every time we 
 need to configure a peripheral that uses MCU pins, we need to configure its corresponding 
 GPIOs using the
  HAL_GPIO
  module.
  
 As seen before, the HAL is designed so that it abstracts from the specific peripheral 
 memory mapping. But, it also provides a general and more user-friendly way to configure 
 the peripheral, without forcing the programmers to now how to configure its registers in 
 detail.",NA
6.2.1 GPIO Mode,"STM32 MCUs provide a really flexible GPIOs management.
  Figure 4
 ⁷
  shows the hardware 
 structure of a single I/O of an STM32F030 microcontroller.
  
  
 Figure 4: Basic structure of an I/O port bit
  
 Depending on the GPIO
  GPIO_InitTypeDef.Mode
  field, the MCU changes the way the hardware of 
 an I/O works. Let us have a look at the main modes.
  
 When the I/O is configured as
  GPIO_MODE_INPUT
 :
  
 • The output buffer is disabled.
  
 • The Schmitt trigger input is activated.
  
 • The pull-up and pull-down resistors are activated depending on the value of the
  Pull
  
 field.• The data present on the I/O pin are sampled into the input data register every 
 AHB clock cycle.• A read access to the input data register provides the I/O state.
  
 When the I/O port is programmed as
  GPIO_MODE_ANALOG
 :
  
 ⁷
 The figure is taken from the ST STM32F030 Reference Manual (http://bit.ly/1GfS3iC).",NA
6.2.2 GPIO Alternate Function,"Most of GPIOs have “alternate functions”, that is they can be used as I/O pin for at least one 
 internal peripheral. However, keep in mind that an I/O can be associated to only one 
 peripheral at a time.
  
  
 Figure 6: CubeMX can be easily used to discover alternate functions of an I/O
  
 To discover which peripherals can be bound to an I/O, you can refer to the MCU datasheet 
 or simply use the CubeMX tool. Clicking on a pin in the
  Pin View
  causes a pop-up menu to 
 appear. In this menu we can set the wanted alternate function. For example, in
  Figure 6
  
 you can see that
  PA3
  can be used as
  USART2_RX
  (that is, it can be used as RX pin for 
 USART/UART2 peripheral, and this is possible for every STM32 MCU with LQFP48",NA
6.2.3 Understanding GPIO Speed,"One of the most misleading things of STM32 microcontrollers is the
  GPIO_InitTypeDef.Speed 
 parameter. This field can assume the values from
  Table 4
  and it has effect only when the 
 GPIO is configured in output mode. Unfortunately, ST has not adopted a consistent name 
 for those constants inside the different Cube HALs.
  
 Table 4: Available
  Speed
  modes for a GPIO
  
 CubeF0/1/3/L0/L1
  
 CubeF4/L4
  
  
 GPIO_SPEED_LOW 
  
 GPIO_SPEED_MEDIUM 
  
 GPIO_SPEED_FAST 
  
 GPIO_SPEED_HIGH
 ⁸
  
 GPIO_SPEED_FREQ_LOW 
  
 GPIO_SPEED_FREQ_MEDIUM 
  
 GPIO_SPEED_FREQ_HIGH 
  
 GPIO_SPEED_FREQ_VERY_HIGH
  
 Speed. A so sweet word for anybody loving performances. But what does it exactly means 
 when it refers to a GPIO? Here a GPIO speed is not related to switching frequency, that is 
 how many times a pin goes from ON to OFF in a unit of time. The
  GPIO_InitTypeDef.Speed",NA
6.3 Driving a GPIO,"CubeHAL provides four manipulation routines to read, change and lock the state of 
 an I/O. To read the status of an I/O we can use the function:",NA
6.4 De-initialize a GPIO ,"It is possible to set a GPIO pin to its default reset status (that is in
  Input Floating Mode
 ). The 
 function:
  
 void
  HAL_GPIO_DeInit(GPIO_TypeDef
  
 does this job automatically for 
 us.
  
 *
 GPIOx,
  uint32_t
  GPIO_Pin).
  
 This function comes in really handy if we no longer need a given peripheral, or to avoid 
 waste of power when the CPU goes in sleep mode.",NA
7. Interrupts Management,"Hardware management is all about dealing with asynchronous events. The most of these 
 come from hardware peripherals. For example, a timer reaching a configured period value, 
 or a UART that warns about the arrival of data. Others are originated by the “world outside” 
 our board. For example, the user presses that damned switch that causes your board to 
 hang, and you will spend a whole day understanding what’s wrong.
  
 All microcontrollers provide a feature called
  interrupts
 . An interrupt is an asynchronous 
 event that causes stopping the execution of the current code on a priority basis (the more 
 important the interrupt is, the higher its priority; this will cause that a lower-priority 
 interrupt is suspended). The code that services the interrupt is called
  Interrupt Service 
 Routine
  (ISR).
  
 Interrupts are a source of multiprogramming: the hardware knows about them and it is 
 responsible of saving the current execution context (that is, the stack frame, the current 
 Program Counter and few other things) before switching to the ISR. They are exploited by 
 Real Time Operating Systems to introduce the notion of
  tasks
 . Without help by the 
 hardware it is impossible to have a true preemptive system, which allows switching 
 between several execution contexts without irreparably losing the current execution flow.
  
 Interrupts can originate both by the hardware and the software itself. ARM architecture 
 distin-guishes between the two types:
  interrupts
  originate by the hardware,
  exceptions
  by 
 the software (e.g., an access to invalid memory location). In ARM terminology, an interrupt 
 is a type of exception.
  
 Cortex-M processors provide a unit dedicated to exceptions management. This is called
  
 Nested Vectored Interrupt Controller
  (NVIC) and this chapter is about programming this 
 really fundamental hardware component. However, here we deal only with interrupts 
 management. Exceptions han-dling will be treated in
  Chapter 24
  about advanced 
 debugging.",NA
7.1 NVIC Controller,"NVIC is a dedicated hardware unit inside the Cortex-M based microcontrollers that is 
 responsible of the exceptions handling.
  Figure 1
  shows the relation between the NVIC unit, 
 the Processor Core and peripherals. Here we have to distinguish two types of peripherals: 
 those external to the Cortex-M core, but internal to the STM32 MCU (e.g. timers, UARTS, 
 and so on), and those peripherals external to the MCU at all. The source of the interrupts 
 coming from the last kind of peripherals are the MCU I/O, which can be both configured as 
 general purpose I/O (e.g. a tactile switch connected to a pin configured as input) or to drive 
 an external advanced peripheral (e.g. I/Os configured to exchange data with an
  ethernet 
 phyther
  through the RMII interface). A dedicated programmable controller, named
  External",NA
7.1.1 Vector Table in STM32,"All Cortex-M processors define a fixed set of exceptions (fifteen for the Cortex-M3/4/7 
 cores and thirteen for Cortex-M0/0+ cores) common to all Cortex-M families and hence 
 common to all STM32-series. We already encountered them in Chapter 1. Here, you can 
 find the same table (
 Table 1
 ) for your convenience. It is a good idea to take a quick look at 
 these exceptions (we will study fault exceptions better in
  Chapter 24
  dedicated to advanced 
 debugging).
  
 •
  Reset
 : this exception is raised just after the CPU resets. Its handler is the real entry 
 point of the running firmware. In an STM32 application all starts from this exception. 
 The handler contains some assembly-coded functions designed to initialize the 
 execution environment, such as the main stack, the
  .bss
  area, etc.
  Chapter 22
  dedicated 
 to the booting process will explain this deeply.
  
 •
  NMI
 : this is a special exception, which has the highest priority after the
  Reset
  one. Like 
 the 
 Reset
  exception, it cannot be masked (that is disabled), and it can be associated to 
 critical and non-deferrable activities. In STM32 microcontrollers it is linked to the
  
 Clock Security System 
 (CSS). CSS is a self-diagnostic peripheral that detects the failure 
 of the HSE. If this happens, HSE is automatically disabled (this means that the internal 
 HSI is automatically enabled) and a NMI interrupt is raised to inform the software that 
 something is wrong with the HSE. More about this feature in
  Chapter 10
 .",NA
7.2 Enabling Interrupts,"When an STM32 MCU boots up, only
  Reset
 ,
  NMI
  and
  Hard Fault
  exceptions are enabled by 
 default. The rest of exceptions and peripheral interrupts are disabled, and they have to be 
 enabled on request.",NA
7.2.1 External Lines and NVIC,"As we have seen in
  Figure 1
 , STM32 microcontrollers provide a variable number of 
 external interrupt sources connected to the NVIC through the EXTI controller, which in 
 turn is capable to manage several
  EXTI lines
 . The number of interrupt sources and lines 
 depends on the specific STM32 family.
  
 GPIO are connected to the EXTI lines, and it is possible to enable interrupts for every MCU 
 GPIO, even if the most of them share the same interrupt line. For example, for an STM32F4 
 MCU, up to 114 GPIOs are connected to 16 EXTI lines. However, only 7 of these lines have 
 an independent interrupt associated with them.
  
 Figure 3
  shows EXTI lines 0, 10 and 15 in an STM32F4 MCU. All Px0 pins are connected to 
 EXTI0, all Px10 pins are connected to EXTI10 and all Px15 pins are connected to EXTI15. 
 However, EXTI lines 10 and 15 share the same IRQ inside the NVIC (and hence are serviced 
 by the same ISR)
 ³
 .
  
 This means that:
  
 ³
 Sometimes, it also happens that different peripherals share the same request line, even in Cortex-M3/4/7 based MCUs where 
 up to 240 configurable request lines are available. For example, in an STM32F446RE MCU, timer TIM6 shares its global IRQ with 
 DAC1 and DAC2 under-run error interrupts.",NA
7.2.2 Enabling Interrupts With CubeMX,"CubeMX can be used to easily enable IRQs and to automatically generate the ISR code. The 
 first step is to enable the corresponding EXTI line using the
  Chip view
 , as shown in
  Figure 5
 .
  
  
 Figure 5: How a GPIO can be bound to EXTI line using CubeMX
  
 Once we have enabled an IRQ, we need to instruct CubeMX to generate the corresponding 
 ISR. This configuration is done through the
  Configuration view
 , clicking on the NVIC button. 
 A list of ISRs that can be enabled appears, as shown in
  Figure 6
 .",NA
7.3 Interrupt Lifecycle,"One dealing with interrupts, it is really important to understand their lifecycle. Although 
 the Cortex-M core automatically performs the most of the work for us, we have to pay 
 attention to some aspects that could be a source of confusion during the interrupt 
 management. However, this paragraph gives a look at the interrupts lifecycle from the 
 “HAL point of view”. If you are interested in looking deeper into this matter, the book series 
 from
  Joseph Yiu⁷
  it is again the best source.
  
 An interrupt can:
  
 1. either be disabled (default behavior) or enabled;
  
 • we enable/disable it calling the
  HAL_NVIC_EnableIRQ()
 /
 HAL_NVIC_DisableIRQ()
  function;
  
 2. either be pending (a request is waiting to be served) or not 
 pending; 3. either be in an active (being served) or inactive state.
  
 We have already seen the first case in the previous paragraph. Now it is important to study 
 what happens when an interrupt occurs.
  
 When an interrupt fires, it is marked as
  pending
  until the processor can serve it. If no other 
 interrupts are currently being processed, its pending state is automatically cleared by the 
 processor, which almost immediately starts serving it.
  
  
 Figure 7: The relation between the pending bit and the interrupt active status
  
 Figure 7
  shows how this works. Interrupt A fires at the time
  t
 0
  and, since the CPU is not 
 servicing another interrupt, its pending bit is cleared and its execution starts immediately
 ⁸
  
 (the interrupt becomes
  active
 ). At the time
  t
 1
  the B interrupt fires, but here we suppose that 
 it has a lower priority than A. So it is leaved in pending state until the A ISR concludes its 
 operations. When this happens, the pending bit is automatically cleared and the ISR 
 become
  active
 .
  
  
 ⁷
 http://amzn.to/1P5sZwq
  
  
 ⁸
 Here, it is important to understand the with the word “immediately” we are not saying that the interrupt execution starts 
 without delay. If no other interrupts are running, Cortex-M3/4/7 cores serve an interrupt in 12 CPU cycles, while Cortex-M0 does it 
 in 15 cycles and Cortex-M0+ in 16 cycles.",NA
7.4 Interrupt Priority Levels,"A distinctive features of the ARM Cortex-M architecture is the ability to prioritize interrupts 
 (except for the first three software exceptions that have a fixed priority, as shown in
  Table 
 1
 ). Interrupt priority allows to define two things:
  
 • the ISRs that will be executed first in case of concurrent interrupts;
  
 • those routines that can be optionally preempted to start executing an ISR with a higher 
 priority.
  
 NVIC priority mechanism is substantially different between Cortex-M0/0+ and Cortex-
 M3/4/7 cores. For this reason we are going to explain them in two separated 
 subparagraphs.",NA
7.4.1 Cortex-M0/0+,"Cortex-M0/0+ based microcontrollers have a simpler interrupt priority mechanism. This 
 means that STM32F0 and STM32L0 MCUs have a different behavior from the rest of STM32 
 microcontrollers.
  
 And you have to pay special attention if you are porting your code between the STM32 
 series.
  
 In Cortex-M0/0+ cores the priority of each interrupt is defined through an 8-bit register, 
 called
  IPR
 . In the ARMv6-M core architecture only 4 bits of this register are used, allowing 
 up to 16 different priority levels. However, in practice, STM32 MCUs implementing these 
 cores use only the two upper bits of this register, seeing all other bits equal to zero.
  
  
 Figure 13: The content of IPR register on an STM32 MCU based on Cortex-M0",NA
7.4.2 Cortex-M3/4/7,"Interrupt priority mechanism in Cortex-M3/4/7 is more advanced than the one available in 
 Cortex-M0/0+ based microcontrollers. Developers have a higher degree of flexibility, and 
 this is often source of several headaches for novices. Moreover, the way interrupt priority 
 is presented both in the ARM and ST documentation is a little bit counterintuitive.
  
 In Cortex-M3/4/7 cores the priority of each interrupt is defined through the
  IPR
  register. 
 This is a 8bit register in the ARMv7-M core architecture that allows up to 255 different 
 priority levels. However, in practice, STM32 MCUs implementing these cores use only the 
 four upper bits of this register, seeing all other bits equal to zero.
  
 ¹³
 Usually, a capacitor and a resistor in parallel with the switch contacts are sufficient in most cases. For example, you can take a 
 look at schematics of the Nucleo board to see how ST engineers have debounced the USER button connected to PC13 GPIO.",NA
7.4.3 Setting Interrupt Priority in CubeMX,"CubeMX can be also used to set the IRQ priority and the priority grouping schema. This 
 configu-ration is done through the
  Configuration view
 , clicking on the NVIC button. The list 
 of enableable ISRs appears, as shown in
  Figure 21
 .
  
  
 Figure 21: The NVIC configuration view allows to set the ISR priority
  
 Using the
  Priority Group
  combo box we can set the priority grouping schema, and then 
 assign the individual priority and sub-priority to each interrupt. CubeMX will automatically 
 generate the corresponding C code to setup the IRQ priority inside the
  MX_GPIO_Init()
  
 function. Instead, the global priority grouping schema is configured inside the
  HAL_MspInit()
  
 function.",NA
7.5 Interrupt Re-Entrancy,"Let us suppose to rearrange the Example 3 so that it uses pin PC12 instead of PB2. In this 
 case, since EXTI12 and EXTI13 share the same IRQ, our Nucleo would never stop blinking. 
 Due to the way the priority mechanism is implemented in Cortex-M processors (that is, an 
 exception with a given priority cannot be preempted by another one with same priority), 
 exceptions and interrupts are not re-entrant. So they cannot be called recursively
 ¹⁷
 .
  
 ¹⁷
 Joseph Yiu shows a way to bypass this limitation in
  his books
 . However, I strongly discourage from using these tricky techniques 
 unless you
  really
  need interrupt re-entrancy in your application.",NA
7.6 Mask All Interrupts at Once or an a Priority Basis,"Sometimes we want to be sure that our code is not preempted to allow the execution of 
 interrupts or more privileged code. That is, we want to ensure that our code is thread-safe. 
 Cortex-M based processors allow to temporarily mask the execution of all interrupts and 
 exceptions, without disabling one by one. Two special registers, named
  PRIMASK
  and
  
 FAULTMASK
  allow to disable all interrupts and exceptions respectively.
  
  
 Figure 22:
  PRIMASK
 ,
  FAULTMASK
  and
  BASEPRI
  registers
  
 Even if these registers are 32-bit wide, just the first bit is used to enable/disable interrupts 
 and exceptions. The ARM assembly instruction
  CPSID i
  disables all interrupt by setting the
  
 PRIMASK
  bit to 1, while the
  CPSIE i
  instructions enables them by setting
  PRIMASK
  to zero. 
 Instead, the instruction 
 CPSID f
  disables all exceptions (except for the NMI one) by setting 
 the
  FAULTMASK
  bit to 1, while the 
 CPSIE f
  instructions enables them.
  
 The CMSIS-Core package provides several macros that we can use to perform these 
 operation:
  __-disable_irq()
  and
  __enable_irq()
  automatically set and clear the
  PRIMASK
 . Any 
 critical task can be placed between these two macros, as shown below:
  
 ...
  
 __disable_irq();
  
 /* All exceptions with configurable priority are temporarily disabled.
  
 You can place critical code here */
  
 ...
  
 __enable_irq();
  
 However, take in mind that, as general rule, interrupt must be masked only for really short 
 time, otherwise you could lose important interrupts. Remember that interrupts are not 
 queued.
  
 Another macro we can use is the
  __set_PRIMASK(x)
  one, where
  x
  is the content of the
  PRIMASK 
 register (0 or 1). The macro
  __get_PRIMARK()
  returns the content of the
  PRIMASK
  register. 
 Instead, the macros
  __set_FAULTMASK(x)
  and
  __get_FAULTMASK()
  allow to manipulate the
  
 FAULTMASK
  register.
  
 It is important to remark that, once the
  PRIMASK
  register is again set to zero, all pending 
 interrupts are serviced according their priority:
  PRIMASK
  causes that the the interrupt 
 pending bit is set but the ISR is not serviced. This is the reason why we say that interrupt",NA
8. Universal Asynchronous ,NA,NA
Serial ,NA,NA
Communications,"Nowadays there is a really high number of serial communication protocols and hardware 
 interfaces available in the electronics industry. The most of them are focused on high 
 transmission bandwidths, like the more recent USB 2.0 and 3.0 standards, the Firewire 
 (IEEE 1394) and so on. Some of these standards come from the past, but are still 
 widespread especially as communication interface between modules on the same board. 
 One of this is the
  Universal Synchronous/Asynchronous Receiver/Transmitter
  interface, also 
 simply known as USART.
  
 Almost every microcontroller provides at least one UART peripheral. Almost all STM32 
 MCUs provide at least two UART/USART interfaces, but the most of them provide more 
 than two interfaces (some up to eight interfaces) according the number of I/O supported 
 by the MCU package.
  
 In this Chapter we will see how to program this really useful peripheral using the CubeHAL. 
 Moreover, we will study how to develop applications using the UART both in
  polling
  and
  
 interrupt 
 modes, leaving the third operative mode, the
  DMA
 , to the
  next chapter
 .",NA
8.1 Introduction to UARTs and USARTs,"Before we start diving into the analysis of the functions provided by the HAL to manipulate 
 universal serial devices, it is best to take a brief look at the UART/USART interface and its 
 communication protocol.
  
 When we want two exchange data between two (or even more) devices, we have two 
 alternatives: we can transmit it in parallel, that is using a given number of communication 
 lines equal to the size of the each data word (e.g., eight independent lines for a word made 
 of eight bits), or we can transmit each bit constituting our word one by one. A 
 UART/USART is a device that translates a parallel sequence of bits (usually grouped in a 
 byte) in a continuous stream of signals flowing on a single wire.
  
 When the information flows between two devices inside a common channel, both devices 
 (here, for simplicity, we will refer to them as
  the sender
  and
  the receiver
 ) have to agree on 
 the
  timing
 , that this how long it takes to transmit each individual bit of the information. In a
  
 synchronous transmission
 , the sender and the receiver share a common clock generated 
 by one of the two devices (usually the device that acts as
  the master
  of this interconnection 
 system).",NA
8.2 UART Initialization,"Like all STM32 peripherals, even the USARTs
 ⁴
  are mapped in the memory mapped 
 peripheral region, which starts from
  0x4000 0000
 . The CubeHAL abstracts the effective 
 location of each USART for a given STM32 MCU thanks to the
  USART_TypeDef
 ⁵
  descriptor. For 
 example, we can simply use the 
 USART2
  macro to refer to the second USART peripheral 
 provided by all STM32 microcontrollers with LQFP64 package.
  
 ⁴
 Starting from this paragraph, the terms USART and UART are used interchangeably, unless different 
 noticed.
 ⁵
 The analysis of the fields of this C
  struct
  is outside of the scope of this book.",NA
8.2.1 UART Configuration Using CubeMX,"As said before, the first time we configure the USART2 for our Nucleo it is best to use 
 CubeMX. The first step is enabling the USART2 peripheral inside the
  Pinout
  view, selecting 
 the
  Asynchronous 
 entry from the
  Mode
  combo box, as shown in
  Figure 5
 . Both PA2 and PA3 
 pins will be automatically highlighted in green. Then, go inside the
  Configuration
  section 
 and click on the
  USART2
  button. The configuration dialog will appear, as shown in
  Figure 
 5
  on the right
 ⁷
 . This allows us to configure the USART configuration settings, such as the
  
 BaudRate
 , word length and so on
 ⁸
 .
  
 Once we have configured the USART interface, we can generate the C code. You will notice 
 that CubeMX places all the USART2 initialization code inside the
  MX_USART2_UART_Init()
  
 (which is contained in the
  main.c
  file). Instead, all the code related to GPIO configuration is",NA
8.3 UART Communication in,NA,NA
 Polling Mode,"STM32 microcontrollers, and hence the CubeHAL, offer three ways to exchange data 
 between peers over a UART communication:
  polling
 ,
  interrupt
  and
  DMA
  mode. It is 
 important to stress right from now that these modes are not only three different flavors to 
 handle UART communications. They are three different programming approach to the 
 same task, which introduce several benefits both from the design and performance point of 
 view. Let us introduce them briefly.
  
 • In
  polling mode
 , also called
  blocking mode
 , the main application, or one of its threads, 
 synchronously waits for the data transmission and reception. This is the most simple 
 form of data communication using this peripheral, and it can be used when the 
 transmit rate is not too much low and when the UART is not used as critical peripheral 
 in our application (the classical example is the usage of the UART as output console for 
 debug activities).
  
 • In
  interrupt mode
 , also called
  non-blocking mode
 , the main application is freed from 
 waiting for the completion of data transmission and reception. The data transfer 
 routines terminate as soon as they complete to configure the peripheral. When the 
 data transmission ends, a subsequent interrupt will signal the main code about this. 
 This mode is more suitable when communication speed is low (below 38400 Bps) or",NA
8.3.1 Installing a Serial Console in Windows,"For the Windows OS we have a simple and reliable solution. This is based on two plug-ins. 
 The first one is a wrapper plug-in around the
  RXTX¹¹
  Java library. To install it, go to
  Help-
 >Install software…
 menu, then click on the
  Add…
  button, and fill the fields in the following 
 way: (see
  Figure 6
 ).
  
 Name
 : RXTX 
  
 Location
 : 
 http://rxtx.qbang.org/eclipse/
  
  
 Figure 6: The dialog to add a new plug-in repository
  
 Click on
  OK
  and install the release
  RXTX 2.1-7r4
  following the instructions.
  
 Now we need to install some files to enable the plugin to access your computers serial port 
 hardware.
  
 First we need to download the Windows binaries from the following link: 
 http://fizzed.com/oss/rxtx-for-java. If you’re using 32-bit Java download the Windows-x86 
 packet. For 64-bit Java download the Windows-x64 packet. Extract the downloaded file into 
 a folder of your choice. Finally we need to copy these files into the Java Runtime 
 Environment folder
 ¹²
 :
  
 • Copy
  RXTXcomm.jar
  to
  C:\Program Files\Java\jre1.8.0_121\lib\ext
 .
  
 • Copy
  rxtxParallel.dll
  and
  rxtxSerial.dll
  to
  C:\Program Files\Java\jre1.8.0_121\bin
 .• For 32-bit Java 
 change the paths to
  C:\Program Files (x86)\Java\jre1.8.0_121\lib\ext
  and 
  
 C:\Program Files 
 (x86)\Java\jre1.8.0_121\bin
 .
  
 We can now proceed by installing a terminal plug-in for Eclipse. Go to
  Help->Eclipse 
 Market-place…
 . In the
  Find
  text box write “terminal”. After a while, the
  TM Terminal
  
 plug-in should appear, as shown in
  Figure 7
 . Click on the
  Install
  button and follow the 
 instructions. Restart Eclipse when requested.
  
 ¹¹
 http://rxtx.qbang.org/
  
 ¹²
 Replace the JRE version (
 \jre1.8.0_121\
 ) with your installed version of the 
 JRE.",NA
8.3.2 Installing a Serial Console in Linux and MacOS X,"Unfortunately, installing the RXTX plug-in on Linux and MacOS X is not a trivial task. For 
 this reason we will go another way.
  
 The first step is installing the
  kermit
  tool. To install it in Linux, type at command line:",NA
8.4 UART Communication in,NA,NA
 Interrupt Mode,"Let us consider again the first example of this chapter. What’s wrong with it? Since our 
 firmware is all committed to this simple task, there is nothing wrong by using the UART in 
 polling mode. The MCU is essentially blocked waiting for the user input (the
  HAL_MAX_DELAY
  
 timeout value blocks the
  HAL_UART_Receive()
  until one char is sent over the UART). But what 
 if our firmware has to accomplish other cpu-intensive activities in real-time?
  
 Suppose to rearrange the
  main()
  from the first example in the following way:
  
 38 
 while
  (
 1
 ) {
  
 39 
 opt
  =
  readUserInput();
  
 40 
 processUserInput(opt);
  
 41 
 if
 (opt
  == 3
 )
  
 42 
  
 goto
  printMessage;
  
 43
  
 44
  
 }
  
 performCriticalTasks();
  
 45
  
 In this case we cannot block the execution of function
  processUserInput()
  waiting for the user 
 choice, but we have to specify a much more short timeout value to the
  HAL_UART_Receive() 
 function, otherwise
  performCriticalTasks()
  is never executed. However, this could cause the 
 loss of important data coming from the UART peripheral (remember that the UART 
 interface has a one byte wide buffer).
  
 To address this issue the HAL offers another way to exchange data over a UART peripheral: 
 the 
 interrupt mode
 . To use this mode, we have to accomplish the following tasks:
  
 • To enable the
  USARTx_IRQn
  interrupt and to implement the corresponding
  
 USARTx_IRQHan-
  
 dler()
  ISR.
  
 • To call
  HAL_UART_IRQHandler()
  inside the
  USARTx_IRQHandler()
 : this will perform all 
 activities 
  
 related to management of interrupts generated by the UART peripheral
 ¹³
 .
  
 • To use the functions
  HAL_UART_Transmit_IT()
  and
  HAL_UART_Receive_IT()
  to exchange data 
 over the UART. These functions also enables the
  interrupt mode
  of the UART 
 peripheral: in this way the peripheral will assert the corresponding line in the NVIC 
 controller so that the ISR is raised when an event occurs.
  
 • To rearrange our application code to deal with asynchronous events.
  
 Before we rearrange the code from the first example, it is best to take a look at the available 
 UART interrupts and to the way HAL routines are designed.
  
 ¹³
 If we use CubeMX to enable the
  USARTx_IRQn
  from the NVIC configuration section (as shown in
  Chapter 7
 ), it will automatically 
 place the call to the
  HAL_UART_IRQHandler()
  from the ISR.",NA
8.4.1 UART Related Interrupts,"Every STM32 USART peripheral provides the interrupts listed in
  Table 6
 . These interrupts 
 include both IRQs related to data transmission and to communication errors. They can be 
 divided in two groups:
  
 •
  IRQs generated during transmission
 : Transmission Complete, Clear to Send or Transmit 
 Data 
  
 Register empty interrupt.
  
 •
  IRQs generated while receiving
 : Idle Line detection, Overrun error, Receive Data 
 register not empty, Parity error, LIN break detection, Noise Flag (only in multi buffer 
 communication) and Framing Error (only in multi buffer communication).
  
 Table 6: The list of USART related interrupts
  
 Interrupt Event
  
 Event Flag
  
 Enable Control Bit
  
 Transmit Data Register Empty
  
 TXE
  
 TXEIE
  
 Clear To Send (CTS) flag
  
 CTS
  
 CTSIE
  
 Transmission Complete
  
 TC
  
 TCIE
  
 Received Data Ready to be Read
  
 RXNE
  
 RXNEIE
  
 Overrun Error Detected
  
 ORE
  
 RXNEIE
  
 Idle Line Detected
  
 IDLE
  
 IDLEIE
  
 Parity Error
  
 PE
  
 PEIE
  
 Break Flag
  
 LBD
  
 LBDIE
  
 Noise Flag, Overrun error and Framing
  
 NF or ORE or FE
  
 EIE
  
 Error in multi buffer communication
  
 These events generate an interrupt if the corresponding
  Enable Control Bit
  is set (third 
 column of 
 Table 6
 ). However, STM32 MCUs are designed so that all these IRQs are bound 
 to just one ISR for every USART peripheral (see
  Figure 11
 ¹⁴
 ). For example, the USART2 
 defines only the
  USART2_-IRQn
  as IRQ for all interrupts generated by this peripheral. It is up 
 to the user code to analyze the corresponding
  Event Flag
  to infer which interrupt has 
 generated the request.
  
 ¹⁴
 The Figure 9s taken from the STM32F030 Reference Manual (RM0390).",NA
8.5 Error Management,"When dealing with external communications, the error management is an aspect that we 
 must strongly take in consideration. An STM32 UART peripheral offers some error flags 
 related to communication errors. Moreover, it is possible to enable a corresponding 
 interrupt to be noticed when the error occurs.
  
 The CubeHAL is designed to automatically detect error conditions, and to warn us about 
 them. We only need to implement the
  HAL_UART_ErrorCallback()
  function inside our 
 application code. The 
 HAL_UART_IRQHandler()
  will automatically invoke it in case an error 
 occurs. To understand which error has been occurred, we can check the value of the
  
 UART_HandleTypeDef->ErrorCode
  field. The list of error codes is reported in
  Table 7
 .
  
 Table 7: List of
  UART_HandleTypeDef->ErrorCode
  possible values
  
 UART Error Code
  
 Description
  
 HAL_UART_ERROR_NON
 E HAL_UART_ERROR_PE 
  
 HAL_UART_ERROR_NE 
  
 HAL_UART_ERROR_FE 
  
 HAL_UART_ERROR_ORE 
 HAL_UART_ERROR_DMA
  
 No error occurred 
  
 Parity check error 
  
 Noise error 
  
 Framing error 
  
 Overrun error 
  
 DMA Transfer 
 error
  
 The
  HAL_UART_IRQHandler()
  is designed so that we should not care with the implementation 
 details of UART error management. The HAL code will automatically perform all needed 
 steps to handle the error (like clearing event flags, pending bit and so on), leaving to us the 
 responsibility to handle the error at application level (for example, we may ask to the other 
 peer to resend a corrupted frame).
  
  
 Read Carefully
  
 At the time of writing this chapter, December 2nd 2015, a subtle bug prevents the 
 right management of the
  Overrun error
 . You can read more about it on the official
  ST 
 forum¹⁷
 . You can reproduce this bug even with the second example of this chapter. 
 Run the example on your Nucleo, and hit the key ‘3’ on your keyboard leaving it 
 pressed. After a while, the firmware will hang. This happens because, after the 
 Overrun error occurs, the HAL does not restart the receiving process again. You can 
 address this bug implementing the 
 HAL_UART_ErrorCallback()
  function in the following 
 way:
  
 void
  HAL_UART_ErrorCallback
 (UART_HandleTypeDef
  *
 huart) {
  
 if
 (huart
 ->
 ErrorCode
  ==
  HAL_UART_ERROR_ORE)
  
 HAL_UART_Receive_IT(huart, readBuf,
  1
 );
  
 }
  
 }",NA
8.6 I/O Retargeting,"In
  Chapter 5
  we have learned how to use the
  semihosting
  feature to send debug messages to 
 the
  
 OpenOCD console using the C
  printf()
  function. If you have already used this feature, you 
 know
  
 that there are two strong limitations:
  
 •
  semihosting
  really slows down the firmware execution;
  
 • it also prevents your firmware from working if it is executed without a debug session 
 (due to
  
 the fact that
  semihosting
  is implemented using software breakpoints).
  
 Now that we are familiar with the UART management, we can redefine the needed system 
 calls
  
 (
 _write()
 ,
  _read()
  and so on) to retarget the
  STDIN
 ,
  STDOUT
  and
  STDERR
  standard streams to the
  
 Nucleo USART2. This can be easily done in the following way:
  
 Filename:
  system/src/retarget/retarget.c
  
 14
  
 #if !defined(OS_USE_SEMIHOSTING)
  
 15
  
 16 
 #define STDIN_FILENO 
  
 0
  
 17 
 #define STDOUT_FILENO 1
  
 18 
 #define STDERR_FILENO 2
  
 19
  
 20 
 UART_HandleTypeDef
  *
 gHuart;
  
 21
  
 22 
 void
  RetargetInit
 (UART_HandleTypeDef
  *
 huart) {
  
 23 
 gHuart
  =
  huart;
  
 24
  
 25
  
 }
  
 /* Disable I/O buffering for STDOUT stream, so that
  
 26
  
 * chars are sent out as soon as they are printed. */
  
 27
  
 setvbuf(stdout,
  NULL
 , _IONBF,
  0
 );
  
 28
  
 29
  
 30 
 int
  _isatty
 (
 int
  fd) {
  
 31 
 if
  (fd
  >=
  STDIN_FILENO
  &&
  fd
  <=
  STDERR_FILENO)
  
 32 
 return
  1
 ;
  
 33
  
 34
  
 }
  
 errno
  =
  EBADF;
  
 35
  
 return
  0
 ;
  
 36
  
 37
  
 38 
 int
  _write
 (
 int
  fd,
  char
 *
  ptr,
  int
  len) {",NA
9. DMA Management,"Every embedded application needs to exchange data with the outside world or to drive 
 external peripherals. For example, our microcontroller may exchange messages with other 
 modules on the PCB using an UART, or it may store data in an external flash using one of 
 the available SPI interfaces. This involves the transfer of a given amount of data between 
 the internal SRAM or flash memory and the peripheral registers, and it requires a certain 
 number of CPU cycles to accomplish the transfer. This leads to a loss of computing power 
 (the CPU is occupied in the transfer process), to a reduction of the overall performances 
 and eventually to a loss of important asynchronous events.
  
 The
  Direct Memory Access
  (DMA) controller is a dedicated and programmable hardware 
 unit that allows MCU peripherals to access to internal memories without the intervention 
 of the Cortex-M core. The CPU is completely freed from the overhead generated by the data 
 transfer (except for the overhead related to the DMA configuration), and it can perform 
 other activities in parallel
 ¹
 . The DMA is designed to work in both the ways (that is, it allows 
 data transfer from memory to peripheral and
  vice versa
 ), and all STM32 microcontrollers 
 provide at least one DMA controller, but the most of them implement two independent 
 DMAs.
  
 The DMA is an “advanced” feature of modern MCUs, and novice users tend to consider it too 
 complicated to use. Instead, the concepts underlying the DMA are really simple, and once 
 you understand them it will be really easy to use it. Moreover, the good news is that the 
 CubeHAL is designed to abstract the most of DMA configuration steps for a given 
 peripheral, leaving to the user the responsibility to provide just few basic configurations.
  
 This chapter will guide you to the fundamental concepts related to the DMA usage, and it 
 will offer an overview of the DMA characteristics in all STM32 families. As usual, this 
 chapter does not aim to be exhaustive and to substitute the official ST documentation
 ²
 , 
 which is a good thing to have as reference during the reading of this chapter. However, 
 once you master the fundamental concepts related to the DMA, you will be able to dive 
 inside your MCU datasheets easily.",NA
9.1 Introduction to DMA,"Before we can analyze the features offered by the
  HAL_DMA
  module, it is important to 
 understand some fundamental concepts behind the DMA controller. The next paragraphs 
 try to summarize the most important aspects to keep in mind during the study of this 
 peripheral. Moreover, they try to address the implementation differences between 
 STM32F2/4/7 and other STM32 families.
  
 ¹
 This is not exactly true, as we will see next. But it is ok to consider that sentence true here.
  
 ²
 ST provides a dedicated application note about the DMA for every STM32 family. For example, the AN4104 
 (
 http://bit.ly/1VMugtO
 ) talks about the DMA in STM32F0 MCUs. Curiously, the most of them are too much “cryptic” and lack of 
 examples and images to better explain how the DMA works. Instead, the AN4031 (
 http://bit.ly/1n66sW7
 ) related to the DMA in 
 STM32F2/F4 MCUs is the most complete, clear and well organized document about the DMA from ST, even if the DMA in these",NA
9.1.1 The Need of a DMA and the Role of the Internal Buses,"Why the DMA is a so important feature? Every peripheral in an STM32 microcontroller 
 needs to exchange data with the internal Cortex-M core. Some of them translate this data in 
 electrical I/O signals to exchange it to the outside world according a given communication 
 protocol (this is the case, for example, of UART or SPI interfaces). Others are just designed 
 so that the access to their registers inside the peripheral memory mapped region (from
  
 0x4000 0000
  to
  0x5FFF FFFF
 ) causes a changing to their state (for example, the
  GPIOx->ODR
  
 register drives the state of all I/Os connected to that port). However, keep in mind that 
 from the CPU point of view this also implies a memory transfer between the core and the 
 peripheral.
  
 The MCU core, in theory, could be designed so that every peripheral would have its own 
 storage area, and it in turn could be tightly coupled with the CPU core to minimize the costs 
 related to memory transfers
 ³
 . This, however, complicates the MCU architecture, requiring a 
 lot of more silicon and more“active components” that consume power. So, the approach 
 used in all embedded microcontrollers is to use some portions of the internal memory 
 (SRAM as well flash) as temporary area storage for different peripherals. It is up to the user 
 to decide how much room to dedicate to these areas. For example, let us consider this code 
 fragment:
  
 uint8_t
  buf[
 20
 ];
  
 ...
  
 HAL_UART_Receive(
 &
 huart2, buf,
  20
 , HAL_MAX_DELAY);
  
 Here we are going to read twenty bytes from the UART2 interface, and hence we allocate an 
 array (the temporary storage) of the same size inside the SRAM. The
  HAL_UART_Receive()
  
 function will access twenty times to the
  huart2.Instance->DR
  data register to transfer bytes 
 from the peripheral to the internal memory, plus it will poll the UART
  RXNE
  flag to detect 
 when the new data is ready to be transferred. The CPU will be involved during these 
 operations (see
  Figure 1
 ), even if its role is “limited” to move data from the peripheral to 
 the SRAM
 ⁴
 .
  
  
 ³
 This is what happens in some vector processors equipping really expensive supercomputers, but this is not the case of 32 cents 
 CPUs like the STM32.
  
 ⁴
 Keep in mind that using the UART in interrupt mode does not change the story. Once the UART generates the interrupt to 
 signal the core that new data is arriving, it is always up to the CPU to “move” this data byte-by-byte from UART data register to the 
 SRAM. That’s the reason why from the performance point of view there is no difference between UART management in polling and 
 interrupt mode.",NA
9.1.2 The DMA Controller,"In every STM32 MCU, the DMA controller is a hardware unit that:
  
 • has
  two master ports
 , named
  peripheral
  and
  memory
  port respectively, connected to 
 the 
  
 Advanced High-performance Bus
  (AHB), one able to interface a slave peripheral and 
 the other 
  
 one a memory controller (SRAM, flash, FSMC, etc.); in some DMA controllers a 
 peripheral port 
  
 is also able to interface a memory controller, allowing
  memory-to-
 memory
  transfers;• has
  one slave port
 , connected to the AHB bus, used to program the 
 DMA controller from the 
  
 other master, that is the CPU;
  
 • has a number of independent and programmable
  channels
  (request sources), each one 
 con-
  
 nectable to a given peripheral request line (
 UART_TX
 ,
  TIM_UP
  etc. - the number 
 and type of 
  
 requests for a channel is established during the MCU design);
  
 • allows to assign different
  priorities
  to channels, in order to arbitrate the access to the 
 memory 
  
 giving higher priority to faster and important peripherals;
  
 • allows the data to flow in
  both directions
 , that is from
  memory-to-peripheral
  and from 
  
 peripheral-to-memory
 .
  
 Each STM32 MCU provides a variable number of DMAs and Channels according its family 
 and sales type. The
  Table 1
  reports their exact number for the STM32 MCUs equipping all 
 Nucleo boards.
  
 These characteristics are broadly common to all STM32 microcontrollers. However, 
 STM32F2/F4/F7 families provide a more advanced DMA controller in conjunction with a 
 multilayer BusMatrix that allows boosting and parallelizing DMA transfers. This is the 
 reason why we are going to treat them separately
 ⁶
 .
  
  
 ⁶
 However, keep in mind that this book does not aim to be an exhaustive source of hardware details of each STM32 family. 
 Always keep in your hands the reference manual for the MCU you are considering, and look carefully to the chapter related to the 
 DMA.",NA
9.2,NA,NA
 HAL_DMA,NA,NA
 Module,"After a lot of talking, it is now the time to start writing code.
  
 Strictly speaking, programming the DMA is fairly simple, especially if it is clear how the 
 DMA works from a theoretical point of view. Moreover, the CubeHAL is designed to 
 abstract the most of underlying hardware details.
  
 All the HAL functions related to DMA manipulation are designed so that they accept as first 
 parameter an instance of the C
  struct DMA_HandleTypeDef
 . This structure is slightly different 
 from CubeF2/F4/F7 HALs and the other CubeHALs, due to the different DMA 
 implementation as shown in the previous paragraphs. For this reason, we will show them 
 separately.",NA
9.2.1,DMA_HandleTypeDef,NA
 in F0/F1/F3/L0/L1/L4 HALs,"The
  struct DMA_HandleTypeDef
  is defined in the following way in CubeF0/F1/F3/L1 HALs:
  
 typedef struct
  {
  
 DMA_Channel_TypeDef 
  
 *
 Instance; 
  
 /* Register base address 
  
 */
  
 DMA_InitTypeDef 
  
 Init; 
  
 /* DMA communication parameters 
  
 */
  
 HAL_LockTypeDef 
  
 Lock; 
  
 /* DMA locking object 
  
 */
  
 __IO HAL_DMA_StateTypeDef State; 
  
 /* DMA transfer state 
  
 */
  
 void 
  
 *
 Parent; 
  
 /* Parent object state 
  
 */
  
 void 
  
 (
 *
  XferCpltCallback)(
  struct
  __DMA_HandleTypeDef
  *
  hdma);
  
 void 
  
 (
 *
  XferHalfCpltCallback)(
  struct
  __DMA_HandleTypeDef
  *
  hdma);
  
 void 
  
 (
 *
  XferErrorCallback)(
  struct
  __DMA_HandleTypeDef
  *
  hdma);
  
 __IO
  uint32_t 
  
 ErrorCode; 
  
 /* DMA Error code 
  
 */
  
 } DMA_HandleTypeDef;
  
 Let us see more in depth the most important fields of this struct.
  
 •
  Instance
 : is the pointer to the DMA/Channel pair descriptor we are going to use. For 
 example, 
 DMA1_Channel5
  indicates the fifth channel of DMA1. Remember that channels 
 are bound to peripherals during the MCU design, so consult the datasheet for your 
 MCU to see the channel bound to the peripheral you want to use in DMA mode.
  
 •
  Init
 : is an instance of the C
  struct DMA_InitTypeDef
 , which is used to configure the 
  
 DMA/Channel pair. We will study it more in depth in a while.
  
 •
  Parent
 : this pointer is used by the HAL to keep track of the peripheral handlers 
 associated to the current DMA/Channel. For example, if we are using an UART in DMA 
 mode, this field will point to an instance of
  UART_HandleTypeDef
 . We will see soon how 
 peripheral handlers are “linked” to this field.
  
 •
  XferCpltCallback
 ,
  XferHalfCpltCallback
 ,
  XferErrorCallback
 : these are pointers to functions used 
 as callbacks to signal the user code that a DMA transfer is
  completed
 ,
  half-completed
  or",NA
9.2.2,DMA_HandleTypeDef,NA
 in F2/F4/F7 HALs,"The
  struct DMA_HandleTypeDef
  is defined in the following way in CubeF2/F4/F7 HALs:",NA
9.2.3,DMA_HandleTypeDef,NA
 in L0/L4 HALs,"Since STM32L0/L4 MCUs adopt a different nomenclature to indicate the stream/channel 
 pair (they adopt the channel/request one), the
  DMA_HandleTypeDef
  reflects this difference in 
 their HALs. However, we will avoid repeating the complete story here. The only two things 
 to keep in mind are:
  
 • the
  DMA_HandleTypeDef.Instance
  is the channel number, and it can assume the values
  
 DMA1_-
  
 Channel1..DMA1_Channel7
 ;
  
 • the
  DMA_HandleTypeDef.Init.Request
  is the request line, and it can assume the values
  DMA_-
  
 REQUEST_0..DMA_REQUEST_11
 ;
  
 • this DMA implementation does not support FIFO and burst mode.",NA
9.2.4 How to Perform Transfers in Polling Mode,"Once we have configured the DMA channel/stream we need, we have to do few other 
 things:
  
 • to setup the addresses on the memory and peripheral 
 port;• to specify the amount of data we are going to 
 transfer;• to arm the DMA;
  
 • to enable the DMA mode on the corresponding 
 peripheral.
  
 The HAL abstracts the first three points by using the",NA
9.2.5 How to Perform Transfers in Interrupt Mode,"From the performance point of view, the DMA transfer in polling mode is meaningless, 
 unless our code does not need to wait for transfer completion. If our goal is to improve the 
 overall performances, there are no reasons to use the DMA controller and then to consume 
 a lot of CPU cycles waiting for transfer completion. So the best option is to arm the DMA 
 and let it notify us when the transfer is completed. The DMA is able to generate interrupts 
 related to channel activities (for example, the DMA1 in an STM32F030 MCU has one IRQ for 
 channel 1, one for channels 2 and 3, one for channels 4 and 5). Moreover, three 
 independent enable bits are available to enable IRQ on
  half transfer
 ,
  full transfer
  and
  
 transfer error
 .
  
 The DMA can be enabled in interrupt mode following these steps:
  
 • define three functions acting as callback routines and pass them to function pointers
  
 XferCplt-
  
 Callback
 ,
  XferHalfCpltCallback
  and
  XferErrorCallback
  in a
  DMA_HandleTypeDef
  handler 
 (
 it 
  
 is ok to define only the functions we are interested in, but set the 
 corresponding pointer 
  
 to NULL, otherwise strange faults may occur
 );
  
 • write down the ISR for the IRQ associated to the channel you are using and do a call to 
 the 
  
 HAL_DMA_IRQHandler()
  passing the reference to the
  DMA_HandleTypeDef
  handler;
  
 • enable the corresponding IRQ in the NVIC controller;
  
 • use the function
  HAL_DMA_Start_IT()
 , which automatically performs all the necessary 
 setup 
  
 steps for you, passing to it the same arguments of the
  HAL_DMA_Start()
 .
  
  
 Purists of performances will be disappointed by the way the HAL manages DMA 
 interrupts. In fact, it enables by default all the available IRQs for a given channel, 
 even if we are not interested to some of them (for example, we might not interested 
 in capturing the
  
 half transfer
  interrupt). If performances are fundamental for you, then take a look at 
 the 
 HAL_DMA_Start_IT()
  code and rearrange it at your needs. Unfortunately, ST has 
 decided to design the HAL in a way that it abstracts a lot of detail to the user, at the 
 expense of speed.",NA
9.2.6 How to Perform,NA,NA
 Peripheral-To-Peripheral,NA,NA
 Transfers,"The official documentation from ST speaks broadly about
  peripheral-to-peripheral
  transfers 
 using DMA in F0/F1/F3/L0/L1/L4 MCUs. But looking at reference manuals, and 
 demonstration projects provided in CubeHAL, it is impossible to find any reasonably 
 example on how to use this feature. Even on the web (and on the official ST forum) there 
 are no hints about how to use it. In a first instance, I thought that this was an obviously 
 consequence of the fact that peripherals are memory mapped in the 4GB address space. 
 Hence, a
  peripheral-to-peripheral
  transfer would be simply a special case of
  peripheral-to-
 memory
  transfer. Instead, doing some tests, I have reached to the conclusion that this 
 feature requires that the DMA is expressly designed to allow trigger transfers between 
 different peripherals. Doing some experiments, I have found that in F2/F4/F7/L1/L4 MCUs 
 only the DMA2 controller has a complete access to the Bus Matrix and it is the only one 
 (together with the Cortex core) that can perform
  peripheral-to-peripheral
  transfers.
  
 This feature can be useful when we want to exchange data between two peripherals 
 without the intervention of Cortex core. The following example shows how to toggle the 
 Nucleo LD2 LED sending a sequence of messages from the UART2 peripheral
 ¹⁴
 .
  
 Filename:
  src/main-ex3.c
  
 4
 5 
  
 4
 6 
  
 4
 7 
  
 4
 8 
  
 4
 9 
  
 5
 0 
  
 5
 1 
  
 5
 2 
  
 5
 3
  
 hdma_usart2_rx.Instance
  =
  DMA1_Channel5; 
  
 hdma_usart2_rx.Init.Direction
  =
  DMA_PERIPH_TO_MEMORY; 
  
 hdma_usart2_rx.Init.PeriphInc
  =
  DMA_PINC_DISABLE; 
  
 hdma_usart2_rx.Init.MemInc
  =
  DMA_MINC_DISABLE; 
  
 hdma_usart2_rx.Init.PeriphDataAlignment
  =
  DMA_PDATAALIGN_BYTE; 
 hdma_usart2_rx.Init.MemDataAlignment
  =
  DMA_MDATAALIGN_BYTE; 
 hdma_usart2_rx.Init.Mode
  =
  DMA_CIRCULAR; 
  
 hdma_usart2_rx.Init.Priority
  =
  DMA_PRIORITY_LOW; 
  
 HAL_DMA_Init(
 &
 hdma_usart2_rx);
  
 54
  
 55 
  
 __HAL_RCC_DMA1_CLK_ENABLE();
  
 56
  
 57
  
 HAL_DMA_Start(
 &
 hdma_usart2_rx,
  
 (
 uint32_t
 )
 &
 huart2.Instance
 ->
 RDR,
  
 (
 uint32_t
 )
 &
 GPIOA
 ->
 ODR,
  1
 );
  
 58
  
 //Enable UART in DMA mode
  
 59
  
 huart2.Instance
 ->
 CR3
  |=
  USART_CR3_DMAR;
  
 This time we configure the channel to do a transfer from
  peripheral-to-memory
 , without 
 incre-menting neither the source peripheral register (UART data register) nor the target 
 memory location, which in our case is the address of the
  GPIOA->ODR
  register. Finally, the 
 channel is configured to work in circular mode: this will cause that all bytes transmitted 
 over the UART will be stored inside the
  GPIOA->ODR
  register continuously.
  
 To test the example, we can simply use the following Python script:
  
 ¹⁴
 The example is designed to run on a Nucleo-F030. For Nucleo boards based on F2/F4/L1/L4 MCUs, the example is designed to 
 work with the UART1, whose DMA requests are bound to the DMA2.",NA
9.2.7 Using the,HAL_UART,NA
 Module With DMA Mode Transfers,"In Chapter 8 we left out how to use the UART in DMA mode. We have already seen in the 
 previous paragraphs how to do it. However, we had to play with some USART registers to 
 enable the peripheral in DMA mode.
  
 The
  HAL_UART
  module is designed to abstract from all underlying hardware details. The 
 steps required to use it are the following:
  
 • configure the DMA channel/stream hardwired to the UART you are going to use, as 
 seen in 
  
 this chapter;
  
 • link the
  UART_HandleTypeDef
  to the
  DMA_HandleTypeDef
  using the
  __HAL_LINKDMA()
 ;
  
 • enable the DMA interrupt related to the channel/stream you are using and call the
  
 HAL_DMA_-
  
 IRQHandler()
  routine from its ISR;
  
 • enable the UART related interrupt and call the
  HAL_UART_IRQHandler()
  routine from its 
 ISR 
  
 (
 this is really important, do not skip this step
 ¹⁵
 );
  
 • Use the
  HAL_UART_Transmit_DMA()
  and
  HAL_UART_Receive_DMA()
  function to exchange data 
  
 over the UART and be prepared to be notified of transfer completion implementing the
  
 HAL_-
  
 UART_RxCpltCallback()
 .
  
 ¹⁵
 It is important to enable the UART-related interrupt and to invoke the
  HAL_UART_IRQHandler()
  routine, because the HAL is 
 designed so that UART-related errors (like parity error, overrun error, and so on) may be raised even when the UART is driven in",NA
9.2.8 Miscellaneous Functions From,HAL_DMA,NA
 and,HAL_DMA_Ex,NA
 ,NA,NA
Modules,"The
  HAL_DMA
  module provides other functions that help using the DMA controller. Let us 
 see them briefly.
  
 HAL_StatusTypeDef
  HAL_DMA_Abort
 (DMA_HandleTypeDef
  *
 hdma);",NA
9.3 Using CubeMX to Configure DMA Requests,"CubeMX can reduce to the minimum the effort required to setting up channel/stream 
 requests. Once you have enabled a peripheral in the
  Pinout
  section, go inside the
  
 Configuration
  section and click on the
  DMA
  button. The
  DMA Configuration
  dialog appears, 
 as shown in
  Figure 8
 .",NA
9.4 Correct Memory Allocation of DMA Buffers,"If you take a look at the source code of all examples presented in this chapter, you can see 
 that DMA buffers (that is, both source and destination arrays used to perform
  memory-to-
 peripheral 
 and
  peripheral-to-memory
  transfers) are always allocated at the global scope. 
 Why we are doing that?
  
 This is a common mistake that all novices sooner or later will do. When we declare a 
 variable at the local scope (that is, on the stack frame of the called routine), that variable 
 will “live” as long as that stack frame is active. When the called function exits, the stack area 
 where the variable has been allocated is reassigned to other uses (to store the arguments 
 or other local variables of the next called function). If we use a local variable as buffer for 
 DMA transfers (that is, we pass to the DMA memory port the address of a memory location",NA
9.5 A Case Study: The DMA,NA,NA
 Memory-To-Memory ,NA,NA
Transfer Performance Analysis,"The DMA controller can be also used to do
  memory-to-memory
  transfers
 ¹⁷
 . For example, it 
 can be used to move a large array of data from flash memory to the SRAM, or to copy arrays 
 in SRAM, or to zero a memory area. The C library usually provides a set of functions to 
 accomplish this task. 
 memcpy()
  and
  memset()
  are the most common ones. Surfing around in 
 the web, you can find several tests that do a performance comparison between
  
 memcpy()
 /
 memset()
  routines and DMA transfers. The majority of these tests claim that 
 usually the DMA is much more slower than the Cortex-M core. Is this true? The answer is: it 
 depends. So, why would you use the DMA when you actually have already those routines?
  
 The story behind these tests is much more complicated, and it involves several factors like 
 the memory align, the C library used and the right DMA settings. Let us consider the 
 following test application (the code is designed to run on an STM32F4 MCU) divided in 
 several stages:
  
 ¹⁷
 Remember that in STM32F2/F4/F7 MCUs only the DMA2 can be used for this kind of transfers.",NA
10. Clock Tree,"Almost every digital circuit needs a way to synchronize its internal circuitry or to 
 synchronize itself with other circuits. A clock is a device that generates periodic signals, and 
 it is the most widespread form of
  heart beat
  source in digital electronics.
  
 The same clock signal, however, cannot be used to feed all components and peripherals 
 provided by a modern microcontroller like STM32 ones. Moreover, power consumption is a 
 critical aspect directly connected with the clock speed of a given peripheral. Having the 
 ability to selectively disable or reduce the clock speed of some MCU parts allows to 
 optimize the overall device power consumption. This requires that the clock is organized in 
 a hierarchical structure, giving to the developer the possibility to choose different speeds 
 and clock sources.
  
 This chapter gives a brief introduction to the complex clock distribution network of an 
 STM32 MCU. Its intent is to provide to the reader necessary tools to understand and 
 manage the clock tree, showing the main functionalities of the
  HAL_RCC
  module. This 
 chapter will be further completed with
  Chapter 19
  dedicated to the power management.",NA
10.1 Clock Distribution,"A clock is a device that usually generates a square wave signal, with a 50% duty cycle, as 
 the one shown in
  Figure 1
 ¹
 .
  
  
 Figure 1: A typical clock signal with a 50% duty cycle
  
 A clock signal oscillates between
  V
 L
  and
  V
 H
  voltage levels, which for STM32 microcontrollers 
 are a fraction of the VDD supply voltage. The most fundamental parameter of a clock is the
  
 frequency
 , which indicates how many times it switches from
  V
 L
  to
  V
 H
  in a second. The 
 frequency is expressed in Hertz.
  
  
 ¹
 It is important to remark that the square wave represented in
  Figure 1
  is “ideal”. The real square wave of a clock source has a 
 trapezoidal form.",NA
10.1.1 Overview of the STM32 Clock Tree,"The clock tree of an STM32 MCU can have a really articulated structure. Even in “simpler” 
 STM32F0 MCUs, the internal clock network can have up to four PLL/prescaler stages, and 
 the
  System Clock Multiplexer
  (also known as
  System Clock Switch
  (SW)) can be fed by 
 several alternate sources.
  
 ²
 There exist some STM32 MCUs, especially those ones with low pin count, that cannot be clocked by an external clock source.
  
  
 ³
 http://bit.ly/1TkDnUd
  
  
 ⁴
 http://bit.ly/20ymjJx
  
  
 ⁵
 A 1% accuracy may seem a good compromise, especially if you consider that you can save PCB space and the cost of a 
 dedicated crystal, which is a device that has a non-negligible price. However, for time-constraint applications, 1% may be a huge 
 shift. For example, a day is made of 86,400 seconds. An error equal to 1% means that in the worst case we can lose (or earn) up to 
 864 seconds, which is equal to 14,4 minutes! And things may worsen if temperature increases. This is the reason why it is 
 mandatory to use an external low-speed crystal if you are going to use the RTC. However, a solution to increase this accuracy exists. 
 More about this
  later
 .",NA
Why So Many Intermediate PLL/Prescaler Stages?,"As said before, the clock speed determines the overall performances, but it also 
 affects the total power consumption of the MCU. Having the capability to selectively 
 turn ON/OFF or reduce the clock speed of some parts of the MCU gives the possibility 
 to reduce the power consumption according the effective computing power needed. 
 As we will see in
  Chapter 19
 , L0/1/4 MCUs introduce even more PLL/prescaler 
 stages to offer to developers more control on the overall MCU consumption. Together 
 with a dedicated hardware design, this allows to create battery-powered devices that 
 can be run even for years using the same battery.
  
 The clock tree configuration is performed through a dedicated peripheral
 ¹¹
  named
  Reset 
 and Clock Control
  (RCC), and it is a process essentially composed by three steps:
  
 1. The high-speed oscillator source is selected (
 HSI
  or
  HSE
 ) and properly configured, if 
 the
  HSE 
  
 is used.
 ¹²
  
 2. If we want to feed the
  SYSCLK
  with a frequency higher than the one provided by the 
 high-
  
 speed oscillator, then we need to configure the
  main PLL
  (which provides the
  
 PLLCLK
  signal). 
  
 Otherwise we can skip this step.
  
 3. The
  System Clock Switch
  (SW) is configured choosing the right clock source (
 HSI
 ,
  HSE
 , 
 or 
 PLLCLK
 ). Then we select the right AHB, APB1 and APB2 (if available) prescaler 
 settings to reach the wanted frequency of the
  High-speed clock
  (HCLK - that is the one 
 that feeds the core, DMAs and AHB bus), and the frequencies of
  Advanced Peripheral 
 Bus 1
  (APB1) and APB2 (if available) buses.
  
 Knowing the admissible values for PLLs and prescalers can be a nightmare, especially for 
 more complex STM32 MCUs. Only some combinations are valid for a given STM32 
 microcontroller, and
  
 ¹⁰
 A prescaler is an “electronic counter” used to reduce high frequencies. In this case, the “/2” prescaler reduces the main 8MHz 
 frequency to 4MHz.",NA
10.1.2 Configuring Clock Tree Using CubeMX,"We have already encountered in
  Chapter 4
  the CubeMX
  Clock Configuration
  view. Now it is 
 the right time to see how it works. The
  Figure 4
  shows the clock tree of the same F0 MCU 
 seen so far. As you can see, thanks to the more room available on the screen, the 
 distribution network looks less cumbersome.
  
  
 Figure 4: How the clock tree of an STM32F030R8 MCU is represented in CubeMX
  
 Even in this case, the most relevant paths of the clock tree have been highlighted in red and 
 blue. This should simplify the comparison with the
  Figure 3
 . When a new project is 
 created, by default CubeMX chooses the HSI oscillator as default clock source. HSI is also 
 chosen as default clock source for the
  System Clock Switch
  (path in blue), as shown in
  
 Figure 4
 . This means that, for the MCU we are considering here, the Cortex-M core 
 frequency will be equal to 8MHz.",NA
10.1.3 Clock Source Options in Nucleo Boards,"The Nucleo development boards offer several alternatives for the clock sources
  
 10.1.3.1 OSC Clock Supply
  
 There are four ways to configure the pins corresponding to external high-speed clock 
 external high-speed clock (HSE):
  
 •
  MCO from ST-LINK
 : MCO output of ST-LINK MCU is used as input clock. This 
 frequency cannot be changed, it is fixed at 8 MHz and connected to PF0/PD0/PH0-
 OSC_IN of target STM32 MCU.
  
 The following configuration is needed:
  
 –
  SB55 OFF
  
 –
  SB16 and SB50 ON
  
 –
  R35 and R37 removed
  
 •
  HSE oscillator on-board from X3 crystal (not provided)
 : for typical frequencies and 
 its capacitors and resistors, refer to STM32 microcontroller datasheet. Please refer to 
 the AN2867 for oscillator design guide for STM32 microcontrollers.
  
 The following configuration is needed:",NA
10.2 Overview of the,NA,NA
 HAL_RCC,NA,NA
 Module,"So far we have seen that the
  Reset and Clock Control
  (RCC) peripheral is responsible of the 
 configuration for the whole clock tree of an STM32 MCU. The
  HAL_RCC
  module contains the 
 corresponding descriptors and routines of the CubeHAL to abstract from the specific RCC 
 imple-mentation. However, the actual implementation of this module inevitably reflects the 
 peculiarities of the clock tree in a given STM32-series and part number. Deepening this 
 module, as we have done for other HAL modules, is outside the scope of this book. It would 
 require we keep track of too many differences among the several STM32 microcontrollers. 
 So, we will now give a brief overview to its main features and to the steps involved during 
 the configuration of the clock tree.
  
 The most relevant C
  struct
  to configure the clock tree are
  RCC_OscInitTypeDef
  and
  RCC_ClkInit-
 TypeDef
 . The first one is used to configure the RCC internal/external oscillator sources (HSE, 
 HSI, LSE, LSI), plus some additional clock sources if provided by the MCU. For example, 
 some STM32 MCUs from the F0 series (STM32F07x, STM32F0x2 and STM32F09x ones) 
 provide USB 2.0 support, in addition to an internal dedicated and factory-calibrated high-
 speed oscillator running at 48MHz to bias the USB peripheral. If this is the case, the",NA
10.2.1 Compute the Clock Frequency at Run-Time,"Sometimes it is important to know how fast is running the CPU core. If our firmware is 
 designed so that it always runs at an established frequency, we can easily hardcode that 
 value in the firmware using a symbolic constant. However, this is always a poor 
 programming style, and it is totally inapplicable if we manage the CPU frequency 
 dynamically. The CubeHAL provides a function that can be used to compute the SYSCLK 
 frequency: the
  HAL_RCC_GetSysClockFreq()
 ¹⁴
 . However, this function must be handled with 
 special care. Let us see why.
  
 The
  HAL_RCC_GetSysClockFreq()
  does not return the real SYSCLK frequency (it could never do 
 this in a reliable way without having a known and precise external reference), but it bases 
 the result on the following algorithm:
  
 • if SYSCLK source is the HSI oscillator, then returns the value based on the
  HSI_VALUE
  
 macro;• if SYSCLK source is the HSE oscillator, then returns the value based on the
  
 HSE_VALUE
  macro;• if SYSCLK source is the PLLCLK, then returns a value based on 
 HSI_VALUE/HSE_VALUE 
  
 multiplied by the PLL factor, according the specific 
 STM32 MCU implementation.
  
 HSI_VALUE
  and
  HSE_VALUE
  macros are defined inside the
  stm32xxx_hal_conf.h
  file, and they 
 are 
 hardcoded
  values. The
  HSI_VALUE
  is defined by ST during chip design, and we can trust 
 the value of the corresponding macro (except for that 1% of accuracy). Instead, if we are 
 using an external oscillator as HSE source, we must provide the actual value for the
  
 HSE_VALUE
  macro, otherwise the value returned by the
  HAL_RCC_GetSysClockFreq()
  function is 
 wrong
 ¹⁵
 . And this also affects the tick frequency (that is, how long it takes to generate the 
 timer interrupt) of the
  SysTick
  timer.
  
 We can also retrieve the core frequency by using the
  SystemCoreClock
  CMSIS global variable.
  
  
 Read Carefully
  
 If we decide to manipulate the clock tree configuration by hand without using 
 CubeHAL routines, we have to remember that every time we change the SYSCLK 
 frequency, we need to call the CMSIS function
  SystemCoreClockUpdate()
 , otherwise some 
 CMSIS routines may give wrong results. This function is automatically called for us 
 by the
  HAL_RCC_-ClockConfig()
  routine.
  
 ¹³
 As we will see in the next chapter, a timer is
  free counter
  module, that is a device that counts from 0 to a given value at every 
 clock cycle. Take note that, for the sake of completeness, the
  SysTick
  timer is a 24-bit
  downcounter timer
 , that is it counts from the 
 configured maximum value (48.000 in our case) down to zero, and then automatically restarts again. The source clock of a timer 
 establishes how fast this timer counts.",NA
10.2.2 Enabling the,NA,NA
 Master Clock Output,"As said before, depending on the IC package used, STM32 MCUs allow to route the clock 
 signal to one or two output I/Os, called
  Master Clock Output
  (MCO). This is performed by 
 using the function:
  
 void
  HAL_RCC_MCOConfig
 (
 uint32_t
  RCC_MCOx,
  uint32_t
  RCC_MCOSource,
  uint32_t
  RCC_MCODiv);
  
 For example, to route the PLLCLK to MCO1 pin in an STM32F401RE MCU (which 
 corresponds to PA8 pin), we must invoke the above function in the following way:
  
 HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_1);",NA
Read Carefully,"Please, take note that when configuring the MCO pin as output GPIO, its speed (that 
 is, the 
 slew rate
 ) affects the quality of the output clock. Moreover, for higher clock 
 frequencies the 
 compensation cell
  must be enabled in the following way:
  
 HAL_EnableCompensationCell();
  
 Refer to the datasheet of your MCU for more about this.",NA
10.2.3 Enabling the,NA,NA
 Clock Security System,"The
  Clock Security System
  (CSS) is a feature of the RCC peripheral used to detect 
 malfunctions of the external HSE. The CSS is an important feature in some critical 
 applications, where a malfunction of the HSE could cause injuries to the user. Its 
 importance is proven by the fact that the detection of a failure is noticed through the NMI 
 exception, a Cortex-M exception that cannot be disabled.
  
 When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is 
 selected as source for the SYSCLK clock. So, if a higher core frequency is needed, we need to 
 perform proper initializations inside the NMI exception handler.
  
 To enable the CSS we use the
  HAL_RCC_EnableCSS()
  routine, and we need to define the handler 
 for the NMI exception in the following way
 ¹⁶
 :
  
 void
  NMI_Handler
 (
 void
 ) {
  
 HAL_RCC_NMI_IRQHandler();
  
 }",NA
10.3 HSI Calibration,"We have left uncommented one line of code in the
  SystemClock_Config()
  routine seen before: 
 the instruction at line 7. It used to perform a fine-tune calibration of the HSI oscillator. But 
 what exactly it does?
  
 As said before, the frequency of the internal RC oscillators may vary from one chip to 
 another due to manufacturing process variations. For this reason, HSI oscillators are 
 factory-calibrated by ST to have a 1% accuracy at room temperature. After a reset, the 
 factory calibration value is automatically loaded in the second byte (HSICAL) of the
  RCC 
 configuration register
  (RCC_CR) (the
  Figure 8 
 shows the implementation of this register in 
 an STM32F401RE
 ¹⁷
 ).
  
  
 Figure 8: The RCC_CR register in an STM32F401RE MCU
  
 The frequency of the internal RC oscillator can be fine-tuned to achieve better accuracy 
 with wider temperature and supply voltage ranges. The trimming bits are used for this 
 purpose. Five trimming bits RCC_CR->HSITRIM[4:0] are used for fine-tuning. The default 
 trimming value is 16. An increase/decrease in this trimming value causes an 
 increase/decrease in HSI frequency. The HSI oscillator is fine-tuned in steps of 0.5% of the 
 HSI clock speed:
  
 • Writing a trimming value in the range of 17 to 31 increases the HSI frequency.
  
 • Writing a trimming value in the range of 0 to 15 decreases the HSI frequency.
  
 • Writing a trimming value equal to 16 causes the HSI frequency to keep its default 
 value.
  
 The HSI can be calibrated using the following procedure:
  
 1. set the internal high-speed RC oscillator system clock; 
  
 2. measure the internal RC oscillator frequency for each trimming value;",NA
11. Timers,"Embedded devices perform some activities on a time basis. For really simple and 
 inaccurate delays a busy loop could carry out the task, but using the CPU core to perform 
 time-related activities is never a smart solution. For this reason, all microcontrollers 
 provide dedicated hardware peripherals: the timers. Timers are not only timebase 
 generators, but they also provides several additional features used to interact with the 
 Cortex-M core and other peripherals, both internal and external to the MCU.
  
 Depending on the family and package used, STM32 microcontrollers implement a variable 
 number of timers, each one with specific characteristics. Some part numbers can provide 
 up to 14 independent timers. Different from the other peripherals, timers have almost the 
 same implementation in all STM32-series, and they are grouped inside nine distinct 
 categories. The most relevant of these are: 
 basic
 ,
  general purpose
  and
  advanced
  timers.
  
 STM32 timers are an advanced peripheral that offer a wide range of customizations. 
 Moreover, some of their features are specific of the application domain. This would require 
 a completely separated book to deepen the topic (you have to consider that usually more 
 than 250 pages of a typical STM32 datasheet is dedicated to timers). This chapter, which is 
 undoubtedly the longest in the book, tries to shape the most relevant concepts regarding
  
 basic
  and
  general purpose
  timers in STM32 MCUs, looking to the related CubeHAL module 
 used to program them.",NA
11.1 Introduction to Timers,"A timer is a
  free-running
  counter with a counting frequency that is a fraction of its source 
 clock. The counting speed can be reduced using a dedicated prescaler for each timer
 ¹
 . 
 Depending on the timer type, it can be clocked by the internal clock (which is derived from 
 the bus where it is connected), by an external clock source or by another timer used as 
 “master”.
  
 Usually, a timer counts from zero up to a given value, which cannot be higher than the 
 maximum unsigned value for its resolution (for example, a 16-bit timer overflows when the 
 counter reaches 65535), but it can also count on the contrary and in other ways we will see 
 next.
  
 The most advanced timers in an STM32 microcontroller have several features:
  
 • They can be used as time base generator (which is the feature common to all STM32 
 timers).
  
 • They can be used to measure the frequency of an external event (input capture 
 mode).• To control an output waveform, or to indicate when a period of time has 
 elapsed (output 
  
 compare mode).",NA
11.1.1 Timer Categories in an STM32 MCU,"STM32 timers can mainly grouped in nine categories. Let us give a brief look at each one of 
 them.
  
 •
  Basic timers
 : timers from this category are the simplest form of timers in STM32 
 MCUs. They are 16-bit timers used as time base generator, and they do not have 
 output/input pins.
  Basic timers
  are also used to feed the DAC peripheral, since their
  
 update event
  can trigger DMA requests for the DAC (for this reason they are usually 
 available in STM32 MCUs providing at least a DAC).
  Basic timers
  can be also used as 
 “masters” for other timers.
  
 •
  General purpose timers
 : they are 16/32-bit timers (depending on the STM32-series) 
 providing the classical features that a timer of a modern embedded microcontroller is 
 expected to implement. They are used in any application for output compare (timing 
 and delay generation), One-Pulse Mode, input capture (for external signal frequency 
 measurement), sensor interface (encoder, hall sensor), etc. Obviously, a
  general 
 purpose timer
  can be used as time base gen-erator, like a
  basic timer
 . Timers from this 
 category provide four-programmable input/output channels.",NA
11.1.2 Effective Availability of Timers in the STM32 Portfolio,"Not all types of timers are available in all STM32 MCUs. It depends mainly on the STM32-
 series, the sales type and package used. The
  Table 2
  summarizes the distribution of the 22 
 timers in all STM32 families.
  
  
 Table 2: Which timers are implemented in each STM32-series
  
 It is important to remark some things regarding
  Table 2
 :
  
 • Given a specific timer (e.g. TIM1, TIM8, etc.), its implementation (features, number and 
 types",NA
11.2 Basic Timers,"Basic timers
  TIM6, TIM7 and TIM18
 ⁸
  are the most simple timers available in the STM32 
 portfolio. Even if they are not provided by all STM32 MCUs, it is important to underline that 
 STM32 timers are designed so that more advanced timers implement the same features (in 
 the same way) of less powerful ones, as shown in
  Figure 1
 . This means that it is perfectly 
 possible to use a
  general purpose timer
  in the same way of a
  basic timer
 . The CubeHAL also 
 reflects this hardware implementation: the base operations on all timers are performed by 
 using the
  HAL_TIM_Base_XXX
  functions.
  
 ⁸
 The TIM18 basic timer is only available in STM32F37x microcontrollers.",NA
11.2.1 Using Timers in,NA,NA
 Interrupt Mode,"Before seeing a complete example, it is best to summarize what we have seen so far. A
  basic 
 timer
 :
  
 • is a
  free-running
  counter, which counts from 0 up to the value specified in the
  Period
 ⁹
  
 field in 
  
 the
  TIM_Base_InitTypeDef
  initialization structure, which can assume the 
 maximum value of 
  
 0xFFFF
  (
 0xFFFF FFFF
  for 32-bit timers);
  
 • the counting frequency depends on the speed of the bus where the timer is connected, 
 and it can 
  
 be lowered up to 65536 times by setting the
  Prescaler
  register in the 
 initialization structure;• when the timer reaches the
  Period
  value, it overflows and the
  
 Update Event
  (UEV) flag is set
 ¹⁰
 ; 
  
 the timer automatically restarts counting again 
 from the initial value (which is always zero for 
  
 basic timers
 )
 ¹¹
 .
  
 The
  Period
  and
  Prescaler
  registers determine the timer frequency, that is how long does it 
 takes to overflow (or, if you prefer, how often an
  Update Event
  is generated), according this 
 simply formula:
  
 ⁹
 The
  Period
  is used to fill the
  Auto-reload register
  (ARR) of the timer. I do not know why ST engineers have decided to name it in 
 this way, since ARR is the register name used in all ST datasheets. This can lead to a lot of confusion, especially when you are new to 
 the CubeHAL, but unfortunately there is nothing we can do.
  
 ¹⁰
 The
  Update Event
  (UEV) is latched to the prescaler clock, and it is automatically cleared on the next clock edge. Don’t confuse 
 the UEV with the
  Update Interrupt Flag
  (UIF), which must be cleared manually like every other IRQ. UIF is set only when the 
 corresponding interrupt is enabled. As we will discover in
  Chapter 19
 , the UEV event, like all event flags set for other peripherals, 
 allows to wake up the MCU when it entered a low-power mode using the
  WFE
  instruction.",NA
11.2.2 Using Timers in,NA,NA
 Polling Mode,"The CubeHAL provides three ways to use timers:
  polling
 ,
  interrupt
  and
  DMA mode
 . For this 
 reason, the HAL provides three distinct functions to start a timer:
  HAL_TIM_Base_Start()
 ,
  
 HAL_TIM_Base_-Start_IT()
  and
  HAL_TIM_Base_Start_DMA()
 . The idea behind the
  polling mode
  is that 
 the timer counter register (
 TIMx->CNT
 ) is accessed continuously to check for a given value. 
 But care must be taken when polling a timer. For example, it is quite common to find 
 around in the web code like the following one:
  
 ...
  
 while
  (
 1
 ) {
  
 if
 (__HAL_TIM_GET_COUNTER(
 &
 tim)
  ==
  value)
  
 ...
  
 That way to poll for a timer is completely wrong, even if it apparently works in some 
 examples. Why?
  
 Timers run independently from the Cortex-M core. A timer can count really fast, up to the 
 same clock frequency of the CPU core. But checking a timer counter for equality (that is, to 
 check if it is equal to a given value) requires several ARM assembly instructions, which in 
 turn need several clock cycles. There is no guarantee that the CPU accesses to the counter 
 register exactly at the same time it reaches the configured value (this happens only if the 
 timer runs really slow). A better way is to check if the timer current counter value is equal 
 or greater than the given value, or to check against the UIF flag status
 ¹⁵
 : in the worst case 
 we can have a shift in time measuring, but we will not lose the event at all (unless the timer 
 runs really fast and we lose the subsequent events because the interrupt is masked - that is, 
 UIF flag it still set before it is cleared manually by us or automatically by the HAL).
  
 ¹⁵
 However this requires that the timer is enabled in interrupt mode, using the
  HAL_TIM_Base_Start_IT()
  function.",NA
11.2.3 Using Timers in,NA,NA
 DMA Mode,"Timers are often programmed to work in
  DMA mode
 , especially when they are not used as 
 timebase generators. This mode guarantees that the operations performed by the timer are 
 deterministic and with the smallest possible latency, especially if they run really fast. 
 Moreover, the Cortex-M core is freed from the timer management, which usually involves 
 the handling of really frequent ISRs that could congest the CPU. Finally, in some advanced 
 modes, like the output PWM one, it is almost impossible to reach given switching 
 frequencies without using the timer in
  DMA Mode
 .
  
 For these reasons, timers offer up to seven DMA requests, which are listed in
  Table 6
 .
  Basic 
 timers 
 implement only the
  TIM_DMA_UPDATE
  request, since they do not have input/output 
 I/Os. However, it is really useful to take advantage of the TIMx_UP request in those 
 situation where we want to perform DMA transfers on a time-basis.
  
 Table 6: DMA requests (the most of them are available only in
  general purpose
  and
  advanced
  timers
  
 Timer DMA request
  
 Description
  
 TIM_DMA_UPDATE 
 TIM_DMA_CC1 
  
 TIM_DMA_CC2 
  
 TIM_DMA_CC3 
  
 TIM_DMA_CC4 
  
 TIM_DMA_COM 
  
 TIM_DMA_TRIGGE
 R
  
 Update request (it is generated on the UEV 
 event) Capture/Compare 1 DMA request 
  
 Capture/Compare 2 DMA request 
  
 Capture/Compare 3 DMA request 
  
 Capture/Compare 4 DMA request 
  
 Commutation request 
  
 Trigger request
  
 The following example is another variation of the blinking LED application, but this time we 
 use a timer in DMA mode to turn the LED ON/OFF. Here we are going to use the TIM6 timer 
 programmed to overflow every 500ms: when this happens, the timer generates the 
 TIM6_UP request (which in",NA
11.2.4 Stopping a Timer,"The CubeHAL provides three functions to stop a running timer:
  HAL_TIM_Base_Stop()
 ,
  
 HAL_TIM_-Base_Stop_IT()
  and
  HAL_TIM_Base_Stop_DMA()
 . We pick one of these depending on the 
 timer mode we are using (for example, if we have started a timer in
  interrupt mode
 , then 
 we need to stop it using the
  HAL_TIM_Base_Stop_IT()
  routine). Each function is designed to 
 properly disable IRQs and DMA configurations.",NA
11.2.5 Using CubeMX to Configure a,NA,NA
 Basic Timer,"CubeMX can reduce to the minimum the effort needed to configure a
  basic timer
 . Once the 
 timer is enabled in the
  Pinout
  view by checking the flag
  Activated
 , it can be configured 
 from the 
 Configuration
  view. The timer configuration view allows to setup the values for 
 the
  Prescaler 
 and
  Period
  registers, as shown in
  Figure 2
 . CubeMX will generate all the 
 necessary initialization code inside the
  MX_TIMx_Init()
  function. Moreover, always in the 
 same configuration dialog, it is possible to enable timer-related IRQs and DMA requests.",NA
11.3 General Purpose Timers,"The majority of STM32 timers are
  general purpose
  ones. Different from the
  basic timers
  
 seen before, they offer much more interaction capabilities, thanks to up to four 
 independent channels that can be used to measure input signals, to output signals on a time 
 basis, to generate
  Pulse-Width Modulation 
 (PWM) signals.
  General purpose
  timers, however, 
 offer much more functionalities that we will discover progressively in this part of the 
 chapter.",NA
11.3.1 Time Base Generator With External Clock Sources,"The
  Figure 3
  shows the block diagram of a
  general purpose
  timer
 ¹⁷
 . Some parts of the 
 diagram have been masked: we will study them more in depth later. The path highlighted 
 in red is used to feed the timer when the APB clock is selected as source: the internal clock
  
 CK_INT
  feeds the
  Prescaler 
 (
 PSC
 ), which in turn determines how fast the
  Counter 
 Register
  (
 CNT
 ) is increased/decreased. This one is compared with the content of the
  auto-
 reload register
  (which is filled with the value of the
  TIM_Base_InitTypeDef.Period
  field). When 
 they match, the UEV event is generated, and the corresponding IRQ is fired, if enabled.
  
 ¹⁷
 The figure is arranged from the one found in the
  RM0368
 (http://bit.ly/1Kq3SoE) reference manual from ST.",NA
11.3.2 Master/Slave Synchronization Modes,"Once a timer operates in
  master
  mode it can feed another timer configured in
  slave
  mode 
 through a dedicated output line, called
  Trigger Output
  (TRGO)
 ²³
 , connected to the internal 
 dedicated lines called ITR0, ITR1, ITR2 and ITR3. The
  master
  timer can both provide the 
 clock source (and hence act as a first order prescaler - this is what we have studied in the 
 previous paragraph) or trigger the 
 slave
  timer.
  
 These
  Internal Trigger (ITR)
  lines (ITR0, ITR1, ITR2 and ITR3) are precisely internal to the 
 chip, and each line is hardwired between two defined timers. For example, in an 
 STM32F030 MCU the TIM1 TRGO line is connected to the ITR0 line of TIM2 timer, as shown 
 in
  Figure 9
 .
  
  
 Figure 9: The TIM1 can fed the TIM2 timer through the ITR0 line
  
 A timer configured as
  slave
  can also simultaneously act as
  master
  for another timer, 
 allowing to create complex networks of timers. For example, the
  Figure 10
  shows how 
 timers can be connected in cascade, while
  Figure 11
  shows how timers can form 
 hierarchical structures using combinations of master/slave modes. Note that TIM1, TIM2 
 and TIM3 are internally interconnected through the same ITR0 line. This allows to 
 synchronize several timers upon the same event (reset, enable, update, etc.).
  
 ²³
 Some STM32 microcontrollers, notably STM32F3 ones, provide two independent trigger lines, named TRGO1 and TRGO2. This 
 case is not shown in this book.",NA
11.3.3 Generate Timer-Related Events by Software,"Timers usually generate events when a given condition is met. For example, they generate 
 the
  Update Event
  (UEV) when the counter register (CNT) matches the
  Period
  value. 
 However, we can force a timer to generate a particular event by software. Every timer 
 provide a dedicated register, named 
 Event Generator
  (
 EGR
 ). Some bits of this register are 
 used to fire a timer-related event. For example, the first bit, named
  Update Generator
  (
 UG
 ), 
 allows to generate a UEV event when set. This bit is automatically cleared once the event is 
 generated.
  
 To generate events by software, the HAL provides the following function:",NA
11.3.4 Counting Modes,"At the
  beginning of this chapter
  we have seen that a basic timer counts from zero to a given
  
 Period 
 value.
  General purpose
  and
  advanced
  timers can count in other different ways, as 
 reported in
  Table 4
 . The
  Figure 15
  shows the three main counting modes.
  
 When a timer counts in
  TIM_COUNTERMODE_DOWN
  mode, it starts from the
  Period
  value and 
 counts down to zero: when the counter reaches the end, the timer IRQ is raised and the UIF 
 flag is set (that is, the
  update event
  is generated and the
  HAL_TIM_PeriodElapsedCallback()
  is 
 called by the HAL).",NA
11.3.5 Input Capture Mode,"General purpose
  timers have not been designed to be used as timebase generators. Even if it 
 is perfectly possible to use them to accomplish this job, other timers like
  basic
  ones and the
  
 SysTick 
 timer can be used to carry out this task.
  General purpose
  timers offer much more 
 advanced capabilities, which can be used to drive other important time-related activities.
  
 The
  Figure 16
  shows the structure of the input channels in a
  general purpose
  timer
 ²⁵
 . As 
 you can see, each input is connected to an edge detector, which is also equipped with a 
 filter used to “debounce”the input signal. The output of the edge detector goes into a source 
 multiplexer (IC1, IC2, etc.). This allows to “remap” the input channels if a given I/O is 
 allocated to another peripheral. Finally, a dedicated prescaler allows to “slow down” the 
 frequency of the input signal, in order to match the timer running frequency if this cannot 
 be lowered, as we will see in a while.
  
 ²⁵
 Some
  general purpose
  timers (for example, TIM14) have less input channels and hence a simplified input stage structure. Refer to 
 the reference manual for your MCU to know the exact structure of the timer you are going to use.",NA
11.3.6 Output Compare Mode,NA,NA
11.3.7 Pulse-Width Generation,"The square waves generated until now have all one common characteristic: they have a
  T
 ON
  
 period equal to the
  T
 OF F
  one. For this reason they are also said to have a 50% duty cycle. A
  
 duty cycle
  is the percentage of one period of time (for example, 1s) in which a signal is 
 active. As a formula, a duty cycle is expressed as:
  
 D
  =
  
  
 T
 ON 
  
 Period×
  100
 %
  
 [8]
  
 where
  D
  is the duty cycle,
  T
 ON
  is the time the signal is active. Thus, a 50% duty cycle means 
 the signal is on 50% of the time but off 50% of the time. The duty cycle says nothing about 
 how long it lasts. The “on time” for a 50% duty cycle could be a fraction of a second, a day, 
 or even a week, depending on the length of the period. The
  pulse width
  is the duration of 
 the
  T
 ON
 , given the actual 
 period
 . For example, assuming a period of 1s, a duty cycle of 20% 
 generates a pulse width of 200ms.
  
  
 Figure 23: Three different duty cycles - 50%, 20% and 80%
  
 The
  Figure 23
  shows three different duty cycles: 50%, 20% and 80%.",NA
11.3.8 One Pulse Mode,"One Pulse Mode
  (OPM) is a mix of the input capture and the output compare modes offered 
 by 
 general purpose
  and
  advanced
  timers. It allows the counter to be started in response to a 
 stimulus and to generate a pulse with a programmable duration (PWM) after a 
 programmable delay.
  
 OPM is a mode designed to work exclusively with Channel 1 and 2 of a timer. We can decide 
 which of the two channels is the output and which is the input by using the function:
  
 HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef
  *
 htim, TIM_OnePulse_InitTypeDef
 *
  sConfig, 
  
 uint32_t
  
 OutputChannel, 
  
 uint32_t
  InputChannel);
  
 Both the channel are configured with an instance of the C
  struct TIM_OnePulse_InitTypeDef
 , 
 which is defined in the following way:
  
 typedef struct
  { 
  
 uint32_t
  Pulse; 
  
 /* Specifies the pulse value to be loaded into the CCRx register.*/ /* Output channel 
 configuration */ 
  
 uint32_t
  OCMode; 
  
  
 /* Specifies the TIM mode. */ 
  
 uint32_t
  OCPolarity; 
  
  
 /* Specifies the output polarity. */ 
  
 uint32_t
  OCNPolarity; 
  
 /* Specifies the complementary output polarity. */ 
  
 uint32_t
  OCIdleState; 
  
 /* Specifies the TIM Output Compare pin state during Idle state.*/ 
 uint32_t
  
 OCNIdleState;
  /* Specifies the TIM Output Compare pin state during Idle state.*/ /* Input channel configuration */ 
  
 uint32_t
  ICPolarity; 
  
  
 /* Specifies the active edge of the input signal. */ 
  
 uint32_t
  ICSelection; 
  
 /* Specifies the input. */ 
  
 uint32_t
  ICFilter; 
  
  
 /* Specifies the input capture filter. */ 
  
 } TIM_OnePulse_InitTypeDef;
  
 The
  struct
  is logically divided in two parts: one related to the configuration of the input 
 channel, and one to the output. We will not go into the details of the
  struct
  fields, because 
 they are similar to what seen so far when we have talked about input capture and output 
 compare modes.
  
 An important aspect to understand is the way the timer computes delay and pulse 
 durations. The delay is computed according the following formula:
  
 Delay
  =
  
 Pulse
  
 [10]
  
 (
 T IMx
 _
 CLK 
 Prescaler+1
 )
  
 while the duration (that is, the duty cycle) of the pulse is computed with this one:
  
 Duration
  =Period - Pulse 
  
 (
 T IMx
 _
 CLK 
 Prescaler+1
 )
  
 [11]",NA
11.3.9 Encoder Mode,"Rotary encoders are devices that have a really wide range of applications. They are used to 
 measure the speed as well as the angular position of rotating objects. They can be used to 
 measure RPM and direction of a motor, to control servo-motors as well step motors, and so 
 on. There are several types of rotary encoders: optical, mechanical, magnetic.
  
 Incremental encoders are a type of rotary encoders that provide cyclic output when they 
 detect movement. The mechanical type requires debouncing and is typically used as “digital 
 potentiome-ter”. Most modern home and car stereos use mechanical rotary encoders for 
 volume control. The incremental rotary encoder is the most widely used of all rotary 
 encoders due to its low cost and ability to provide signals that can be easily interpreted to 
 provide motion related information such as velocity.
  
  
 Figure 32: The square waves emitted by a quadrature encoder on A and B channels
  
 They employ two outputs called
  A
  and
  B
 , which are called quadrature outputs, as they are 
 90 degrees out of phase, as shown in
  Figure 32
 . The direction of the motor depends if 
 phase
  A
  leads phase
  B
 , or phase
  B
  leads phase
  A
 . An optional third channel,
  index pulse
 , 
 occurs once per revolution and it is used as a reference to measure an absolute position. 
 There are several ways to detect direction and position of a rotary encoder. By connecting 
 the
  A
  and
  B
  pins to two MCU I/O it is possible to detect when the signal goes HIGH and 
 LOW. This can be performed both manually (using interrupts to capture when the channel 
 changes status) or by using a timer: its channels can be configured in input capture mode 
 and the capture values are compared to compute the direction and speed of the encoder.
  
 STM32
  general purpose
  timers provide a convenient way to read rotary encoders: this 
 mode is indeed called
  encoder mode
  and it simplifies a lot the capture process. When a 
 timer is configured in encoder mode, the timer counter register (TIMx_CNT) is 
 incremented/decremented on the edge of input channels.",NA
11.3.10 Other Features Available in,NA,NA
 General Purpose,NA,NA
 and,NA,NA
 Advanced ,NA,NA
Timers,"The features seen so far represent the most common usages of a timer. However, STM32
  
 general purpose
  and
  advanced
  timers provide other important functionalities, really useful 
 in some specific application domains. We will now give a quick overview to these additional 
 capabilities. Since these",NA
11.3.11 Debugging and Timers,"During a debug session, when the execution is suspended due to a hardware or software 
 breakpoint, by default timers are not stopped. Sometimes is, instead, useful to stop a timer 
 during debug, especially if it is used to drive an external device.
  
 STM32 timers can be selectively configured to stop when the core is halted due to a 
 breakpoint. The HAL macro
  __HAL_DBGMCU_FREEZE_TIMx()
  (where the
  x
  corresponds to timer 
 number) enables this working mode of a timer. Additionally, the outputs of the timers 
 having complementary outputs are disabled and forced to an inactive state. This feature is 
 extremely useful for applications where the timers are controlling power switches or 
 electrical motors. It prevents the power stages from being damaged by excessive current, 
 or the motors from being left in an uncontrolled state when hitting a breakpoint.
  
 The macro
  __HAL_DBGMCU_UNFREEZE_TIMx()
  restores the default behaviour (that is, the timer 
 does not stop during a breakpoint).
  
  
 Please, take note that, before invoking the
  __HAL_DBGMCU_FREEZE_TIMx()
  macro, the
  
 MCU 
 debug 
 component
  
 (DBGMCU) 
 must 
 be 
 enabled 
 by 
 calling 
 the
  
 __HAL_RCC_DBGMCU_CLK_-ENABLE()
  macro.",NA
11.4 SysTick Timer,"SysTick
  is a special timer, internal to the Cortex-M core, provided by all STM32 
 microcontrollers. It is mainly used as timebase generator for the CubeHAL and the RTOS (if 
 used). The most important thing about
  SysTick
  timer is that, if used as timebase generator 
 for the HAL, it must be configured to generate an exception every 1ms: the exception 
 handler will increment the
  system tick counter
  (a global, 32-bit wide and static variable), 
 which can be accessed by calling the
  HAL_GetTick()
  routine.
  
 The
  SysTick
  is a 24-bit downcounter, clocked by the AHB bus (that is, it has the same 
 frequency of the
  High (speed) Clock
  - HCLK). Its clock speed can be eventually divided by 8 
 using the function:
  
 void
  HAL_SYSTICK_CLKSourceConfig
 (
 uint32_t
  CLKSource);
  
 which accepts the parameters
  SYSTICK_CLKSOURCE_HCLK
  and
  SYSTICK_CLKSOURCE_HCLK_DIV8
 .
  
 The
  SysTick
  update frequency is determined by the starting value of the
  SysTick
  counter, 
 which is configured using the function:
  
 uint32_t
  HAL_SYSTICK_Config
 (
 uint32_t
  TicksNumb);
  
 To configure the
  SysTick
  timer so that it generates an update event every 1ms, and 
 assuming that it is clocked at the same speed of the AHB bus, it is sufficient to invoke the
  
 HAL_SYSTICK_Config()
  in the following way:
  
 HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()
 /1000
 );
  
 The
  HAL_SYSTICK_Config()
  routine is also responsible of enabling the timer and its
  SysTick_IRQn 
 exception
 ³⁹
 . The priority of the exception can be configured at compile time setting the
  
 TICK_INT_-PRIORITY
  symbolic constant in the
  include/stm32XXxx_hal_conf.h
  file, or by 
 calling the
  HAL_-NVIC_SetPriority()
  on the
  SysTick_IRQn
  exception, as seen in
  Chapter 7
 .
  
 When the
  SysTick
  timer reaches zero, the
  SysTick_IRQn
  exception is raised, and the 
 corresponding handler is called. CubeMX already provides for us the right function body, 
 which is defined in the following way:
  
 void
  SysTick_Handler
 (
 void
 ) {
  
 HAL_IncTick();
  
 HAL_SYSTICK_IRQHandler();
  
 }
  
 ³⁹
 Remember that the
  SysTick_IRQn
  is an exception and not an interrupt, even if it is common to refer to it as interrupt. This means 
 that we cannot use the
  HAL_NVIC_EnableIRQ()
  function to enable it.",NA
Read Carefully,"Avoid to use slow code inside the
  HAL_SYSTICK_Callback()
  routine, otherwise the 
 timebase generation could be affected. This may lead to unpredictable behaviour of 
 some HAL modules, which rely on the exact
  1ms
  timebase generation.
  
 Moreover, care must be taken when using
  HAL_Delay()
 . This function provides 
 accurate delay (in milliseconds) based on
  SysTick
  counter. This implies that if
  
 HAL_Delay()
  is called from a peripheral ISR process, then the
  SysTick
  interrupt must 
 have higher priority (numerically lower) than the peripheral interrupt. Otherwise 
 the caller ISR process will be blocked (because the global tick counter is never 
 incremented).
  
 To suspend the system timebase generation, it is possible to use
  HAL_SuspendTick()
  routine, 
 while to resume it the
  HAL_ResumeTick()
  one.",NA
11.4.1 Use Another Timer as System Timebase Source,"SysTick
  timer has just one relevant application: as timebase generator for the HAL or an 
 optional RTOS. Since the
  SysTick
  clock cannot be easily prescaled to more flexible counting 
 frequencies, it is not suitable to be used as a conventional timer. However, it has a relevant 
 limitation that we will better analyze in
  Chapter 23
 : it is not suitable to be used with
  
 tickless
  modes offered by some RTOS for low-power applications. For this reason, 
 sometimes it is important to use another timer (maybe a LPTIM) as system timebase 
 generator. Finally, as we will discover in
  Chapter 23
 , when using an RTOS it is convenient 
 to separate the timebase source for the HAL and for the RTOS.
  
 Recent releases of the CubeMX software allow to easily use another timer instead of
  
 SysTick
 . To perform this, go in the
  Pinout
  view, then open the
  RCC
  entry from the
  IP tree
  
 pane and select the 
 Timebase source
 , as shown in
  Figure 35
 .
  
  
 Figure 35: How to select another timer as system timebase source",NA
11.5 A Case Study: How to Precisely Measure ,NA,NA
Microseconds With STM32 MCUs,"Sometimes, especially when dealing with communication protocols not implemented in 
 hardware by a peripheral, we need to precisely measure delays ranging from 1 up to a 
 fistful of microseconds. This leads to another more general question: how to measure 
 microseconds precisely in STM32 MCUs?
  
 There are several ways to do this, but some methods are more accurate and other ones are 
 more versatile among different MCUs and clock configurations.
  
 Let us consider one member of the STM32F4 family: STM32F401RE. This micro is able to 
 run up to 84MHz using internal RC clock. This means that ever 1µs, the clock cycles 84 
 times. So, we need a way to count 84 clock cycles to assert that 1µs is elapsed (I am 
 assuming that you can tolerate the internal RC clock 1% accuracy).
  
 Sometimes, it is common to find around delay routines like the following one:
  
 void
  delay1US
 () {
  
 #define CLOCK_CYCLES_PER_INSTRUCTION
  
 X
  
 //IN MHZ (e.g. 16 for 16 MHZ)
  
 #define CLOCK_FREQ
  
 Y
  
 volatile
  int
  cycleCount
  =
  CLOCK_FREQ
  /
  CLOCK_CYCLE_PER_INSTRUCTION;
  
 while
  (cycleCount
 --
 );
  
 }
  
 But how to establish how many clock cycles are required to compute one step of the
  
 while(cycleCount--)
  instruction? Unfortunately, it is not simple to give an answer. Let us assume 
 that
  cycleCount
  is equal to 1. Doing some tests (I will explain later how I have done them), with 
 compiler optimizations disabled (option -O0 to GCC), we can see that in this case the whole C 
 instruction requires 24 cycles to execute. How is it possible that? You have to figure out that 
 our C statement is unrolled in several assembly instructions, as we can see if we disassemble 
 the firmware binary file:",NA
12. Analog-To-Digital Conversion,"It is quite common to interface analog peripherals to a microcontroller. In the digital era, 
 there are still a lot of devices that produce analog signals: sensors, potentiometers, 
 transducers and audio peripherals are just few examples of analog devices that generate a 
 variable voltage, which usually ranges in a fixed interval. By reading this voltage, we can 
 convert it in a numerical entity useful to be processed by our firmware. For example, the 
 TMP36 is a quite-popular temperature sensor, which produces a variable voltage 
 proportional to the circuit operating voltage (it is said to give a 
 ratiometric output
 ) and the 
 ambient temperature.
  
 All STM32 microcontrollers provide at least one
  Analog-to-Digital Converter
  (ADC), a 
 peripheral able to acquire several input voltages through dedicated I/O, and to convert 
 them to a number. The input voltage is compared against a well know and fixed voltage, 
 also known as
  reference voltage
 . This reference voltage can be either derived from the 
 VDDA domain or, in MCUs with high pin count, supplied by an external and fixed reference 
 voltage generator (those MCUs provide a dedicated pin named VREF+). The majority of 
 STM32 MCUs provide a 12-bit ADC. Some of them from the STM32F3 portfolio even a 16-
 bit ADC.
  
 Differently from other STM32 peripherals seen so far, ADCs can diverge a lot between the 
 various STM32-series and even inside a given family. For this reason, will give only an 
 introduction to this useful peripheral, leaving to the reader the responsibility to analyze in 
 depth the ADC in the specific MCU he is considering.
  
 Before we analyze the features offered by the ADC in an STM32 microcontroller, and the 
 related CubeHAL, it is best to give a quick introduction to the way this peripheral works.",NA
12.1 Introduction to SAR ADC,"In almost all STM32 microcontrollers, the ADC is implemented as a 12-bit
  Successive 
 Approximation Register
  ADC
 ¹
 . Depending on the sales type and packaged used, it can have a 
 variable number of multiplexed input channels (usually more then ten channels in the most 
 of STM32 MCUs), allowing to measure signals from external sources. Moreover, some 
 internal channels are also available: a channel for internal temperature sensor (
 V
 SENSE
 ), one 
 for internal reference voltage (
 V
 REF INT
 ), one for monitoring external
  V
 BAT
  power supply and a 
 channel for monitoring LCD voltage in those MCUs providing a native monochrome passive 
 LCD controller (for example, the STM32L053 is one of these). ADCs implemented in 
 STM32F3 and in majority of STM32L4 MCUs are also capable of converting fully differential 
 inputs.
  Table 1
  lists the exact ADC peripherals number and their related
  
 ¹
 At the time of writing this chapter, the ADC provided by STM32F37x series is the only notably exception to this rule, since it 
 provides a more accurate 16-bit ADC with Sigma-Delta(Σ-Δ) modulator. This type of ADC will not be covered in this book. However, 
 the HAL routines to use it have the same organization.",NA
12.2,NA,NA
 HAL_ADC,NA,NA
 Module,"After a brief introduction to the most important features offered by the ADC peripheral in 
 STM32
  
 microcontrollers, it is the right time to dive into the related CubeHAL APIs.
  
 To manipulate the ADC peripheral, the HAL defines the C
  struct ADC_HandleTypeDef
 , which is
  
 defined in the following way:
  
 typedef struct
  {
  
 ADC_TypeDef 
  
 *
 Instance; 
 /* Pointer to ADC descriptor */
  
 ADC_InitTypeDef 
  
 Init; 
 /* ADC initialization parameters */
  
 __IO
  uint32_t 
  
 NbrOfCurrentConversionRank;
  /* ADC number of current conversion rank */
  
 DMA_HandleTypeDef
  *
 DMA_Handle; 
 /* Pointer to the DMA Handler */
  
 HAL_LockTypeDef 
  
 Lock; 
 /* ADC locking object */
  
 __IO
  uint32_t 
  
 State; 
 /* ADC communication state */
  
 __IO
  uint32_t 
  
 ErrorCode; 
 /* Error code */
  
 } ADC_HandleTypeDef;
  
 Let us analyze the most important fields of this
  struct
 .
  
 •
  Instance
 : is the pointer to the ADC descriptor we are going to use. For example,
  ADC1
  is 
 the
  
 descriptor of the first ADC peripheral.
  
 •
  Init
 : is an instance of the C
  struct ADC_InitTypeDef
 , which is used to configure the ADC.",NA
12.2.1 Conversion Modes,"ADCs implemented in STM32 MCUs provide several conversion modes useful to deal with 
 different application scenarios. Now we are going to brief introduce the most relevant of 
 them: the
  AN3116⁶
 from ST describes all possible conversion modes provided by the ADC.
  
 12.2.1.1 Single-Channel, Single Conversion Mode",NA
12.2.2 Channel Selection,"Depending on the STM32 family and package used, ADCs in STM32 MCUs can convert 
 signals from a variable number of channels. In F0 and L0 families the allocation of channel 
 is fixed: the first one is always IN0, the second IN1 and so on. User can decide only if a 
 channel is enabled or not. This means that in scan mode the first sampled channel will be 
 always IN0, the second IN1 and so on. Other",NA
12.2.3 ADC Resolution and Conversion Speed,"It is possible to perform faster conversions by reducing the ADC resolution
 ⁸
 . The sampling 
 time, in fact, is defined by a fixed number of cycles (usually 3) plus a variable number of 
 cycles depending the A/D resolution. The minimum conversion time for each resolution is 
 then as follows:
  
 • 12 bits: 3 +
  ∼
 12 = 15 ADCCLK 
 cycles
  
 • 10 bits: 3 +
  ∼
 10 = 13 ADCCLK 
 cycles
  
 • 8 bits: 3 +
  ∼
 8 = 11 ADCCLK cycles
  
 • 6 bits: 3 +
  ∼
 6 = 9 ADCCLK cycles
  
 By reducing the resolution is so possible to increase the number of maximum samples per 
 seconds, reaching even more then 15Msps in some STM32 MCUs. Remember that the 
 ADCCLK is derived from the peripheral clock: this means that SYSCLK and PCLK speeds 
 impact on the maximum number of samples per second.",NA
12.2.4 A/D Conversions in Polling Mode,"Like the majority of STM32 peripherals, the ADC can be driven in three modes:
  polling
 ,
  
 interrupt
  and 
 DMA
  mode. As we will see later, a timer can eventually drive this last mode so 
 that A/D conversions take place at regular interval. This is extremely useful when we need 
 to sample signals at a given frequency, like in audio applications.
  
 Once the ADC controller is configured by using an instance of the
  ADC_InitTypeDef struct
  
 passed to the
  HAL_ADC_Init()
  routine, we can start the peripheral using the
  HAL_ADC_Start()
  
 function. Depending on the conversion mode chosen, ADC will convert each selected input 
 continuously or once: in this case, to convert again selected inputs we need to call the
  
 HAL_ADC_Stop()
  function before calling again the
  HAL_ADC_Start()
  one.
  
 In
  polling mode
  we use the function
  
 HAL_StatusTypeDef
  HAL_ADC_PollForConversion
 (ADC_HandleTypeDef
 *
  hadc,
  uint32_t
  Timeout);
  
 to determine when the A/D conversion is complete and the result is available inside the 
 ADC
  data register
 . The function accepts the pointer to the ADC handler descriptor and a
  
 Timeout
  value, which represents the maximum time expressed in milliseconds we are 
 willing to wait. Alternatively, we can pass the
  HAL_MAX_DELAY
  to wait indefinitely.",NA
12.2.5 A/D Conversions in Interrupt Mode,"Performing an A/D conversion in
  interrupt
  mode is not too much different from what seen 
 so far. As usual, we have to define the ISR connected to the ADC interrupt, to assign a 
 wanted interrupt priority and to enable the corresponding IRQ. Like all other HAL 
 peripherals, we have to call the 
 HAL_ADC_IRQHandler()
  from the ADC ISR and to implement 
 the callback routine
  HAL_ADC_ConvC-pltCallback()
 , which is automatically called by the HAL 
 when a conversion ends. Finally, all the ADC related interrupts are enabled by starting the 
 ADC using the
  HAL_ADC_Start_IT()
  function.
  
 The following example just shows how to perform a conversion in
  interrupt
  mode. The 
 initialization code for the ADC is the same used in the previous example.
  
 int
  main
 (
 void
 ) {
  
 HAL_Init();
  
 Nucleo_BSP_Init();
  
 /* Initialize all configured peripherals */
  
 MX_ADC1_Init();
  
 HAL_NVIC_SetPriority(ADC_IRQn,
  0
 ,
  0
 );
  
 HAL_NVIC_EnableIRQ(ADC_IRQn);
  
 HAL_ADC_Start_IT(
 &
 hadc1);
  
 while
  (
 1
 );
  
 }",NA
12.2.6 A/D Conversions in DMA Mode,"The most interesting mode to drive the ADC peripheral is the
  DMA
  one. This mode allows to 
 perform conversions without the intervention of the CPU and, using DMA in circular mode, 
 we can easily setup ADC so that it performs continuous conversions. Moreover, as we will 
 discover next, this mode is perfect to drive conversions using a timer, allowing to sample 
 input signal at a fixed sampling rate. It is also mandatory to use the ADC peripheral in DMA 
 mode when we want to perform conversions of multiple channels using
  scan mode
 .
  
 To perform A/D conversions in DMA mode, as usual the steps involved in this process are 
 the following ones:
  
 • Setup the ADC peripheral according the wanted conversion mode (scan single, scan 
 continu-
  
 ous, etc).
  
 • Setup the DMA channel/stream corresponding to the ADC controller used.
  
 • Link the DMA handler descriptor to the ADC handler using the
  __HAL_LINKDMA()
  
 macro.• Enable the DMA and the IRQ associated to the DMA stream used.
  
 • Start the ADC in DMA mode using the
  HAL_ADC_Start_DMA()
  passing the reference to the 
 array 
  
 used to store acquired data from the ADC.
  
 • Be prepared to capture EOC event by defining the
  HAL_ADC_ConvCpltCallback()
 ¹¹
  callback.
  
 The following example, designed to run on an STM32F401RE MCU, shows how to perform a
  
 single scan
  conversion using DMA mode. The first part we are going to analyze is the one 
 related to the setup of both ADC peripheral and DMA controller.
  
 ¹¹
 The
  HAL_ADC
  module also provides the
  HAL_ADC_ConvHalfCpltCallback()
  callback called when half of the scan conversion sequence is 
 completed.",NA
12.2.7 Errors Management,"ADC peripheral has the ability to notify developers in case a conversion is lost. This error 
 condition happens when a continuous or scan mode conversion is ongoing and the ADC
  
 data register
  is overwritten by the successive transaction before it is read. When this 
 happens a special bit in the ADC_SR register is set and the ADC interrupt is generated.
  
 We can capture the
  overrun
  error by implementing the following callback:
  
 void
  HAL_ADC_ErrorCallback
 (ADC_HandleTypeDef
  *
 hadc);
  
 When the
  overrun
  error occurs, DMA transfers are disabled and DMA requests are no 
 longer accepted. In this case, if a DMA request is made, the regular conversion in progress 
 is aborted and further regular triggers are ignored. It is then necessary to clear the OVR flag 
 and the DMAEN bit of the used DMA stream, and to reinitialize both the DMA and the ADC 
 to have the wanted converted channel data transferred to the right memory location (all 
 these operations are automatically performed by the HAL when calling the
  
 HAL_ADC_Start_DMA()
  routine).
  
 We can simulate an
  overrun
  error by enabling the continuous conversion mode in the 
 previous example, and setting to
  ENABLE
  the
  hadc.Init.DMAContinuousRequests
  field
 ¹²
 : if the ADC 
 interrupt is enabled, and the
  HAL_ADC_IRQHandler()
  is invoked from it, then you will be able to 
 catch the 
 overrun
  error.
  
 ¹²
 In some STM32 MCUs it is also required to explicitly enable the
  overrun
  detection by setting the
  hadc.Init.Overrun
  to
  ADC_OVR_DATA_-
 OVERWRITTEN
 . Consult the HAL source code for the MCU family you are considering.",NA
12.2.8 Timer-Driven Conversions,"ADC peripheral can be configured to be driven from a timer through the TRGO trigger line. 
 The timer used to perform this operation is hardwired during the chip design. For example, 
 in an STM32F401RE MCU the ADC1 peripheral can be synchronized using the TIM2 timer. 
 This feature is extremely useful to perform ADC conversions at a given frequency. For 
 example, we can sample an audio wave generated by a microphone at 20kHz frequency. 
 The result data can be then stored in a persistent memory.
  
 The ADC conversions can be driven by timers both in
  interrupt
  and
  DMA
  mode. The former 
 is useful when we sample just one channel at low frequencies. The latter is mandatory for
  
 scan mode 
 conversions at high frequencies. To enable timer-driven conversions you can 
 follow this procedure:
  
 • Configure the timer connected to the ADC through the TRGO line according the wanted 
  
 sampling frequency.
  
 • Configure the timer’s TRGO line so that it triggers every time the update event is 
 generated 
  
 (
 TIM_TRGO_UPDATE
 )
 ¹³
 .
  
 • Configure the ADC so that the selected timer TRGO line triggers the conversions, and 
 be sure that
  continuous conversion mode
  is disabled (because it is the TRGO line that 
 fires the conversion). Moreover, set the
  hadc.Init.DMAContinuousRequests
  field to
  ENABLE
  
 and the DMA in circular mode if you want to perform N conversion at time indefinitely, 
 or set the 
 hadc.Init.DMAContinuousRequests
  field to
  DISABLE
  if you want to stop after N 
 conversions are performed.
  
 • Be sure to set the
  hadc.Init.ContinuousConvMode
  field to
  DISABLE
 , otherwise the ADC 
  
 performs conversions by its own without waiting the timer trigger.
  
 • Start the timer.
  
 • Start the ADC in
  interrupt
  or
  DMA
  mode.
  
 The following example shows how to trigger a conversion every 1s in an STM32F401RE 
 MCU using the TIM2 timer.
  
 ¹³
 Please, 
 take 
 note 
 that 
 it 
 is 
 important 
 to 
 configure 
 the 
 timer’s 
 TRGO 
 output 
 mode 
 by 
 using 
 the
  
 HAL_TIMEx_MasterConfigSynchronization() 
 routine even if the timer does not work in
  master
  mode. This is a source of confusion for 
 novice users and I have to admit that that is a little bit counter-intuitive.",NA
12.2.9 Conversions Driven by External Events,"In some STM32 MCUs it is possible to configure an EXTI line to trigger A/D conversions. 
 For example, in an STM32F401RE MCU the EXTI line 11 can be enabled for such uses. This 
 means that any MCU pin connected on that line (PA11, PB11, etc.) is a valid source to 
 trigger conversions. Take note that it is not possible to use an EXTI line and a timer as 
 trigger source at the same time.",NA
12.2.10 ADC Calibration,"The ADCs implemented by some STM32 families, like the STM32L4 and STM32F3 ones, 
 provide an automatic calibration procedure that drives all the calibration sequence 
 including the power-on/off sequence of the ADC. During the procedure, the ADC calculates 
 a calibration factor, which is 7-bit wide and which is applied internally to the ADC until the 
 next ADC power-off. During the calibration procedure, the application must not use the 
 ADC and must wait until calibration is complete. Calibration is preliminary to any ADC 
 operation. It removes the offset error that may vary from chip to chip due to process or 
 bandgap variation. The calibration factor to be applied for single-ended input conversions 
 is different from the factor to be applied for differential input conversions.
  
 The
  HAL_ADC_Ex
  module provides three functions useful to work with ADC calibration. The
  
 HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef
 *
  hadc,
  uint32_t
  SingleDiff);
  
 automatically performs a calibration procedure. It must be called just after the
  
 HAL_ADC_Init()
 , and before any
  HAL_ADC_Start_XXX()
  routine is used. Passing the parameter
  
 ADC_SINGLE_ENDED
  
 a 
 single-ended 
 calibration 
 is 
 performed, 
 while 
 passing 
 the
  
 ADC_DIFFERENTIAL_ENDED
  performs a differential input calibration.
  
 The function",NA
12.3 Using CubeMX to Configure ADC Peripheral,"CubeMX allows to easily configure the ADC peripheral in a few steps. The first one consists 
 in enabling the wanted ADC channels in the
  IP Tree
  view, as shown in
  Figure 11
 .
  
  
 Figure 11: The
  IP Tree
  view pane allows to select input channels of the ADC
  
 Once the inputs are enabled, we can configure the ADC peripheral from the
  Configuration
  
 view, as shown in
  Figure 12
 .",NA
13. Digital-To-Analog Conversion,"In the previous chapter we focused our attention on the ADC controller, showing the most 
 relevant characteristics of this important peripheral that all STM32 microcontrollers 
 provide. The reverse of this operation is demanded to the
  Digital to Analog Converter
  
 (DAC).
  
 Depending on the family and package used, STM32 microcontrollers usually provide only a 
 DAC with one or two dedicated outputs, with the exception of few part numbers from the 
 STM32F3-series that implement two DACs, the first one with two outputs and the other one 
 with just one output.
  
 DAC channels can be configured to work in 8/12-bit mode, and the conversion of the two 
 channels can be performed independently or simultaneously: this last mode is useful in 
 those applications where two independent but synchronous signals must be generated (for 
 example, in audio applications). Like the ADC peripheral, even the DAC can be triggered by 
 a dedicated timer, in order to generate analog signals at a given frequency.
  
 This chapter gives a quick introduction to the most relevant characteristics of this 
 peripheral, leaving to the reader the responsibility to deepen the features of the DAC in the 
 specific STM32 microcontroller he is considering. As usual, we are now going to give a brief 
 explanation about how a DAC controller works.",NA
13.1 Introduction to the DAC Peripheral,"A DAC is a device that converts a number to an analog signal, which is proportional to a 
 supplied reference voltage
  V
 REF
  (see
  Figure 1
 ). There are many categories of DACs. Some of 
 these include 
 Pulse Width Modulators
  (PWM), interpolating, sigma-delta DACs and high 
 speed DACs. We have analyzed how to use an STM32 timer to generate PWM signals in
  
 Chapter 11
 , and we have used this capability to generate an output sine wave with the help 
 of a RC low-pass filter.
  
  
 Figure 1: The general structure of a DAC
  
 DAC peripherals available in STM32 microcontrollers are based on the common R-2R 
 resistor ladder network. A
  resistor ladder
  is an electrical circuit made of repeating units of",NA
13.2,NA,NA
 HAL_DAC,NA,NA
 Module,NA,NA
13.2.1 Driving the DAC Manually,"The DAC peripheral can be driven manually or using the DMA and a trigger source (e.g. a 
 dedicated timer). We are now going to analyze the first method, which is used when we do 
 not need conversions at high frequencies.
  
 The first step consists in starting the peripheral by calling the function
  
 HAL_StatusTypeDef
  HAL_DAC_Start
 (DAC_HandleTypeDef
 *
  hdac,
  uint32_t
  Channel);
  
 The function accepts the pointer to an instance of the
  DAC_HandleTypeDef struct
 , and the 
 channel to activate (
 DAC_CHANNEL_1
  or
  DAC_CHANNEL_2
 ).
  
 Once the DAC channel is enabled, we can perform a conversion by calling the function:
  
 HAL_StatusTypeDef
  HAL_DAC_SetValue
 (DAC_HandleTypeDef
 *
  hdac,
  uint32_t
  Channel,
  
 uint32_t
  Alignment,
  uint32_t
  Data);
  
 where the
  Alignment
  parameter can assume the value
  DAC_ALIGN_8B_R
  to drive the DAC in 8-
 bit mode,
  DAC_ALIGN_12B_L
  or
  DAC_ALIGN_12B_R
  to drive the DAC in 12-bit mode passing the 
 output value left- or right-aligned respectively.
  
 The following example, designed to run on a Nucleo-F072RB, shows how to drive the DAC 
 peripheral manually. The example is based on the fact that in the majority of Nucleo boards 
 providing the DAC peripheral one of the output channels corresponds to the PA5 pin, which 
 is connected to LD2 LED. This allows us to fade ON/OFF the LD2 using the DAC.",NA
13.2.2 Driving the DAC in DMA Mode Using a Timer,"The most common usage of the DAC peripheral is to generate an analog waveform with a 
 given frequency (e.g. in audio applications). If this the case, then the best way to drive the 
 DAC is by using the DMA and a timer to trigger the conversions.
  
 To start the DAC and perform a transfer in DMA mode we need to configure the 
 corresponding DMA channel/stream pair and use the function:
  
 HAL_StatusTypeDef
  HAL_DAC_Start_DMA
 (DAC_HandleTypeDef
 *
  hdac,
  uint32_t
  Channel,
  
 uint32_t
 *
  pData,
  uint32_t
  Length,
  uint32_t
  Alignment);
  
 which accepts the pointer to an instance of the
  DAC_HandleTypeDef struct
 , the channel to 
 activate (
 DAC_CHANNEL_1
  or
  DAC_CHANNEL_2
 ), the pointer to the array of values to transfer in 
 DMA mode, its length, and the alignment of output values in memory, which can assume 
 the value
  DAC_ALIGN_8B_R 
 to drive the DAC in 8-bit mode,
  DAC_ALIGN_12B_L
  or
  DAC_ALIGN_12B_R
  
 to drive the DAC in 12-bit mode passing the output value left- or right-aligned respectively.
  
 For example, we can easily generate a sinusoidal wave using the DAC. In
  Chapter 11
  we 
 have analyzed how to use the PWM mode of a timer to generate sine waves. If our MCU 
 provides a DAC, then the same operation can be carried out more easily. Moreover, 
 depending the specific application, by enabling the output buffer we can avoid external 
 passives at all.
  
 To generate a sinusoidal wave running at a given frequency, we have to divide the complete 
 period in a number of steps. Usually more than 200 steps are are a good approximation for 
 an output wave. This means that if we want to generate a 50Hz sine wave, then we need to 
 perform a conversion every:",NA
13.2.3 Triangular Wave Generation,"In several audio applications it is useful to generate triangular waves. While it is perfectly 
 possible to generate a triangular wave using the DMA technique seen before, STM32 DACs 
 allow to generate",NA
13.2.4 Noise Wave Generation,"STM32 DACs are also able to generate noise waves (see
  Figure 5
 ), using a pseudo-random 
 generator. This is useful in some application domains, like audio applications and RF 
 systems. Moreover, it can be also used to increase the accuracy of ADC peripheral
 ¹
 .
  
 In order to generate a variable-amplitude pseudo-noise, an LFSR (linear feedback shift 
 register) is available in the DAC. This register is preloaded with the value 0xAAA, which 
 may be masked partially or totally. This value is then added up to the DAC data register 
 contents without overflow and this value is then used as output value.
  
  
 Figure 5: a noise wave generated with the DAC
  
 To generate the noise wave we can use the HAL routine
  
 HAL_StatusTypeDef
  HAL_DACEx_NoiseWaveGenerate
 (DAC_HandleTypeDef
 *
  hdac,
  uint32_t
  Channel,
  
 uint32_t
  Amplitude);
  
 which accepts the channel used to generate the wave and the amplitude value, which is 
 added to the LFSR content to generate the pseudo-random wave. Like for the triangular 
 wave generation, a timer can be used to trigger conversion: this means that the frequency 
 of the wave is determined by the overflow frequency of the timer.
  
 ¹
 ST provides the
  AN2668
 (http://bit.ly/25lJoqx) dedicated to this topic.",NA
14. I²C,"Nowadays even the simplest PCB contains two or more digital
  integrated circuits
  (IC), in 
 addition to the main MCU, designated to specific tasks. ADCs and DACs, EEPROM memories, 
 sensors, logic I/O ports, RTC clocks, RF circuits and dedicated LCD controllers are just a 
 small list of possible ICs specialized in doing just a single task. Modern digital electronics 
 design is all about the right selection (and programming) of powerful, specific and, most of 
 the times, cheap ICs to mix on the final PCB.
  
 Depending on the characteristics of these ICs, they are often designed to exchange 
 messages and data with a programmable device (which usually is, but not limited to, a 
 microcontroller) according to a well-defined communication protocol. Two of the most 
 used protocols for
  intra-board
  communications are the I²C and the SPI, both date back to 
 early ‘80 but still widespread in the electronics industry, especially when communication 
 speed is not a strict requirement and it is limited to the PCB boundaries
 ¹
 .
  
 Almost all STM32 microcontrollers provide dedicated hardware peripherals able to 
 communicate using I²C and SPI protocols. This chapter is the first of two dedicated to this 
 topic, and it briefly introduces the I²C protocol and the related CubeHAL APIs to program 
 this peripheral. If interested in deepen the I²C protocol, the
  UM10204 by NXP²
  provides the 
 complete and the most updated specification.",NA
14.1 Introduction to the I²C specification,"The
  Inter-Integrated Circuit
  (aka I²C - pronounced
  I-squared-C
  or very rarely
  I-two-C
 ) is a 
 hardware specification and protocol developed by the semiconductor division of Philips 
 (now
  NXP Semiconductors
 ³
 ) back in 1982. It is a
  multi-slave
 ⁴
 , half-duplex, single-ended 8-bit 
 oriented serial bus specification, which uses only two wires to interconnect a given number 
 of slave devices to a master. Until October 2006, the development of I²C-based devices was 
 subject to the payment of royalty fees to Philips, but this limitation has been superseded
 ⁵
 .
  
 ¹
 Although there exist applications where I²C and SPI protocols are used to exchange messages over external wires (usually 
 with a length around the meter), these specifications were not designed to guarantee the robustness of communication over 
 potentially noisy mediums. For this reason, their application is limited to the single PCB.
  
  
 ²
 http://bit.ly/29URmka
  
  
 ³
 NXP acquired
  Freescale Semiconductor
  in 2015 and both companies provide Cortex-M based microcontrollers. This means that 
 NXP currently provides two distinct and complimentary families of Cortex-M based MCU, the LPC one coming from NXP and the 
 Kinetis one from Freescale. These two families are direct competitors of the STM32 portfolio, and it is not clear which of the two 
 families will survive after this important acquisition (keep evolving both of them is a non-sense, according this author). Although 
 both Kinetis and LPC portfolios are comparable with the STM32-series, this last one is probably more widespread, especially 
 between makers and students.
  
 ⁴
 The I²C can be also a
  multi-master
  protocol, meaning that two or more masters can exist on the same bus, but only one master 
 at a time can take the bus control and it is up to masters to arbitrate the access to the bus. In practice, it is really rare to use the I²C 
 in multi-master mode in embedded systems. This book does not cover the multi-master mode.
  
  
 ⁵
 You still have to pay royalties to NXP if you want to receive an official and licensed I²C address pool for your devices, but I 
 think that this not the case of readers of this book.",NA
14.1.1 The I²C Protocol,"In the I²C protocol all transactions are always initiated and completed by the master. This is 
 one of the few rules of this communication protocol to keep in mind while programming 
 (and, especially, debugging) I²C devices. All messages exchanged over the I²C bus are 
 broken up into two types of frame: an
  address frame
 , where the master indicates to which 
 slave the message is being sent, and one or more
  data frames
 , which are 8-bit data 
 messages passed from master to slave or vice versa. Data is placed on the SDA line after SCL 
 goes low, and it is sampled after the SCL line goes high. The time between clock edges and 
 data read/write is defined by devices on the bus and it vary from chip to chip.
  
 As said before, both SDA and SCL are bidirectional lines, connected to a positive supply 
 voltage via a current-source or pull-up resistors (see
  Figure 1
 ). When the bus is free, both 
 lines are HIGH. The output stages of devices connected to the bus must have an open-drain 
 or open-collector to perform the wired-AND function. The bus capacitance limits the 
 number of interfaces connected to the bus. For a single master application, the master’s SCL 
 output can be a push-pull driver design if there are no devices on the bus that would 
 stretch the clock (more about this later).
  
 We are now going to analyze the fundamental steps of an I²C communication.
  
  
 Figure 2: The structure of a base I²C message
  
 ⁷
 This constitutes one of the most practical limits of the I²C protocol. In fact, IC manufacturers rarely dedicate enough pins to 
 configure the full slave address used on a given board (no more than three pins are dedicated to this feature, if you are lucky, giving 
 only eight choices of slave addresses). When designing a board with several I²C devices, pay attention to their address and in case of 
 collision you will need to use two or more I²C peripherals to drive them.
  
 ⁸
 There exist ICs communicating only at lower-speeds, but nowadays are uncommon.",NA
14.1.2 Availability of I²C Peripherals in STM32 MCUs,"Depending on the family type and package used, STM32 microcontrollers can provide up to 
 four independent I²C peripherals.
  Table 1
  summarizes the availability of I²C peripherals in 
 STM32 MCUs equipping all sixteen Nucleo boards we are considering in this book.",NA
14.2,NA,NA
 HAL_I2C,NA,NA
 Module,"To program the I²C peripheral, the CubeHAL defines the C
  struct I2C_HandleTypeDef
 , which is 
 defined in the following way:
  
 typedef struct
  {
  
 I2C_TypeDef
  
 *
 Instance;
  
 /* I²C registers base address
  
 */
  
 I2C_InitTypeDef
  
 Init;
  
 /* I²C communication parameters
  
 */
  
 uint8_t
  
 *
 pBuffPtr;
  
 /* Pointer to I²C transfer buffer */
  
 uint16_t
  
 XferSize;
  
 /* I²C transfer size
  
 */
  
 __IO
  uint16_t
  
 XferCount;
  
 /* I²C transfer counter
  
 */
  
 DMA_HandleTypeDef
  
 *
 hdmatx;
  
 /* I²C Tx DMA handle parameters
  
 */
  
 DMA_HandleTypeDef
  
 *
 hdmarx;
  
 /* I²C Rx DMA handle parameters
  
 */
  
 HAL_LockTypeDef
  
 Lock;
  
 /* I²C locking object
  
 */
  
 __IO HAL_I2C_StateTypeDef
  
 State;
  
 /* I²C communication state
  
 */
  
 __IO HAL_I2C_ModeTypeDef
  
 Mode;
  
 /* I²C communication mode
  
 */
  
 __IO
  uint32_t
  
 ErrorCode;
  
 /* I²C Error code
  
 */
  
 } I2C_HandleTypeDef;
  
 Let us analyze the most important fields of this C
  struct
 .
  
 •
  Instance
 : is the pointer to the I²C descriptor we are going to use. For example,
  I2C1
  is the 
  
 descriptor of the first I²C peripheral.
  
 •
  Init
 : is an instance of the C
  struct I2C_InitTypeDef
  used to configure the peripheral. We 
  
 will study it more in depth in a while.
  
 •
  pBuffPtr
 : pointer to the internal buffer used to temporarily store data transferred to and 
 from the I²C peripheral. This is used when the I²C works in interrupt mode and should 
 be not modified from the user code.
  
 •
  hdmatx
 ,
  hdmarx
 : pointer to instances of the
  DMA_HandleTypeDef struct
  used when the I²C 
  
 peripheral works in DMA mode.
  
 The setup of the I²C peripheral is performed by using an instance of the C
  struct 
 I2C_InitTypeDef
 , which is defined in the following way:",NA
14.2.1 Using the I²C Peripheral in,NA,NA
 Master Mode,"We are now going to analyze the main routines provided by the CubeHAL to use the I²C 
 peripheral in master mode. To perform a transaction over the I²C bus in write mode, the 
 CubeHAL provides the function:
  
 HAL_StatusTypeDef
  HAL_I2C_Master_Transmit
 (I2C_HandleTypeDef
  *
 hi2c,
  uint16_t
  DevAddress,
  
 uint8_t
  *
 pData,
  uint16_t
  Size,
  uint32_t
  Timeout);
  
 where:
  
 •
  hi2c
 : it is the pointer to an instance of the struct I2C_HandleTypeDef seen before, which 
  
 identifies the I²C peripheral;
  
 •
  DevAddress
 : it is the address of the slave device, which can be 7- or 10-bits long 
 depending on 
  
 the specific IC;
  
 •
  pData
 : it is the pointer to an array, with a length equal to the
  Size
  parameter, containing 
 the 
  
 sequence of bytes we are going to transmit;
  
 •
  Timeout
 : represents the maximum time, expressed in milliseconds, we are willing to 
 wait for 
  
 the transmit completion. If the transmission does not complete in the 
 specified timeout time, 
  
 the function aborts and returns the
  HAL_TIMEOUT
  value; 
 otherwise it returns the
  HAL_OK
  value if 
  
 no other errors occur. Moreover, we can 
 pass a timeout equal to
  HAL_MAX_DELAY
  (
 0xFFFF FFFF
 ) 
  
 to wait indefinitely for the transmit 
 completion.
  
 To perform a transaction in read mode we can use, instead, the following function:
  
 ¹³
 http://bit.ly/29URmka",NA
14.2.2 Using the I²C Peripheral in,NA,NA
 Slave Mode,"Nowadays there are a lot of
  System-on-Board
  (SoB) modules on the marked. These are 
 usually small PCBs already populated with several ICs and specialized in doing something 
 relevant. GPRS and GPS",NA
14.3 Using CubeMX to Configure the I²C Peripheral,"As usual, CubeMX reduces to the minimum the effort needed to configure the I²C 
 peripheral. Once the peripheral is enabled in the
  IP tree pane
  (from the
  Pinout view
 ), we can 
 configure all settings from the
  Configuration view
 , as shown in
  Figure 13
 .",NA
15. SPI,"In the previous chapter we have analyzed one of the two most widespread communication 
 standards that rule the “market” of intra-boards communication systems: the I²C protocol. 
 Now it is time to analyze the other player: the SPI protocol.
  
 All STM32 microcontrollers provide at least one SPI interface, which allows to develop both 
 master and slave applications. The CubeHAL implements all the necessary stuff to program 
 such peripherals easily. This chapter gives a quick overview of the
  HAL_SPI
  module after, as 
 usual, a brief introduction to the SPI specification.",NA
15.1 Introduction to the SPI Specification,"The
  Serial Peripheral Interface
  (SPI) is a specification about serial, synchronous and full-
 duplex communications between a master controller (which is usually implemented with 
 an MCU or something with programmable functionalities) and several slave devices. As we 
 will see next, the nature of the SPI interface allows full duplex as well as half duplex 
 communications over the same bus. SPI specification is a
  de facto
  standard, and it was 
 defined by Motorola
 ¹
  in late ‘70, and it is still largely adopted as communication protocol 
 for many digital ICs. Different from the I²C protocol, the SPI specification does not force a 
 given message protocol over its bus, but it is limited to bus signaling giving to slave devices 
 total freedom about the structure of exchanged messages.
  
  
 Figure 1: The structure of a typical SPI bus
  
  
 ¹
 Motorola was a company that has been split in several sub-companies over the years. The semiconductor division of Motorola 
 flowed into ON Semiconductor, which is still one of the largest semiconductors company in the world.",NA
15.1.1 Clock Polarity and Phase,"In addition to setting the bus clock frequency, the master and slaves must also agree on the 
 clock 
 polarity
  and
  phase
  with respect to the data exchanged over MOSI and MISO lines.
  SPI 
 Specification by Motorola⁴
  names these two settings as CPOL and CPHA respectively, and 
 most silicon vendors have adopted that convention.
  
 The combinations of polarity and phase are often referred to as SPI
  bus modes
  which are 
 commonly numbered according
  Table 1
 . The most common mode are
  mode 0
  and
  mode 3
 , 
 but the majority of slave devices support at least a couple of bus modes.
  
 Table 1: SPI bus modes according CPOL and CPHA configuration
  
 Mode
  
 CPOL
  
 CPHA
  
 0
  
 0
  
 0
  
 1
  
 0
  
 1
  
 2
  
 1
  
 0
  
 3
  
 1
  
 1
  
 The timing diagram is shown in
  Figure 4
 , and it is further described below:
  
 • At
  CPOL=0
  the base value of the clock is zero, i.e. the active state is 1 and idle state is 0.
  
 –
  For
  CPHA=0
 , data is captured on the SCK rising edge (LOW → HIGH transition) and 
 data is output on a falling edge (HIGH → LOW clock transition).
  
 –
  For
  CPHA=1
 , data is captured on the SCK falling edge and data is output on a rising 
 edge.
  
 • At
  CPOL=1
  the base value of the clock is one (inversion of CPOL=0), i.e. the active state 
 is 0 
  
 and idle state is 1.
  
 –
  For
  CPHA=0
 , data is captured on SCK falling edge and data is output on a rising 
 edge.
  
 –
  For
  CPHA=1
 , data is captured on SCK rising edge and data is output on a falling 
 edge.
  
 That is, CPHA=0 means sampling on the first clock edge, while CPHA=1 means sampling on 
 the second clock edge, regardless of whether that clock edge is rising or falling. Note that 
 with CPHA=0, the data must be stable for a half cycle before the first clock cycle.
  
 ⁴
 http://bit.ly/2cc3T3S",NA
15.1.2 Slave Select Signal Management,"As said before, the SPI slave devices do not have an address that identify them on the bus, 
 but they start exchanging data with the master as long as the
  Slave Select
  (SS) signal is 
 LOW. STM32 microcontrollers provide two distinct modes to handle the SS signal, which is 
 called NSS in the ST documentation. Let us analyze them.
  
 •
  NSS software mode
 : The SS signal is driven by the firmware and any free GPIO can be 
 used to drive an IC when the MCU works in master mode, or to detect when another 
 master is starting a transfer if the MCU works in slave mode.
  
 •
  NSS hardware mode
 : a specific MCU I/O is used to drive the SS signal, and it is 
 internally 
  
 managed by the SPI peripheral. Two configurations are possible depending 
 on the NSS output 
  
 configuration:
  
  
 – NSS output enabled
 : this configuration is used only when the device operates in 
 master 
  
  
 mode. The NSS signal is driven LOW when the master starts the 
 communication and is 
  
  
 kept LOW until the SPI is disabled. It is important to 
 remark that this mode is suitable 
  
  
 when there is just one SPI slave device on 
 the bus and its SS I/O is connected to the NSS 
   
 signal. This configuration does not 
 allow multi-master mode.
  
 – NSS output disabled
 : this configuration allows multi-master capability for devices 
 operating in master mode. For devices set as slave, the NSS pin acts as a classical 
 NSS input: the slave is selected when NSS is LOW and deselected when NSS HIGH.",NA
15.1.3 SPI,NA,NA
 TI Mode,"SPI peripherals in STM32 microcontrollers support the
  TI Mode
  when working in master 
 mode and when the NSS signal is configured to work in hardware. In
  TI mode
  the clock 
 polarity and phase are forced to conform to the Texas Instruments protocol requirements 
 whatever the values set. NSS management is also specific to the TI protocol, which makes 
 the configuration of NSS management transparent for the user. In
  TI mode
 , in fact, the NSS",NA
15.1.4 Availability of SPI Peripherals in STM32 MCUs,"Depending on the family type and package used, STM32 microcontrollers can provide up to 
 six independent SPI peripherals.
  Table 2
  summarizes the availability of SPI peripherals in 
 STM32 MCUs equipping all sixteen Nucleo boards we are considering in this book.",NA
15.2,NA,NA
 HAL_SPI,NA,NA
 Module,"To program the SPI peripheral, the HAL defines the C
  struct SPI_HandleTypeDef
 , which is 
 defined in the following way
 ⁵
 :
  
 typedef struct
  __SPI_HandleTypeDef {
  
 SPI_TypeDef
  
 *
 Instance;
  
 /* SPI registers base address */
  
 SPI_InitTypeDef
  
 Init;
  
 /* SPI communication parameters */
  
 uint8_t
  
 *
 pTxBuffPtr;
  
 /* Pointer to SPI Tx transfer Buffer */
  
 uint16_t
  
 TxXferSize;
  
 /* SPI Tx Transfer size */
  
 __IO
  uint16_t
  
 TxXferCount;
  
 /* SPI Tx Transfer Counter */
  
 uint8_t
  
 *
 pRxBuffPtr;
  
 /* Pointer to SPI Rx transfer Buffer */
  
 uint16_t
  
 RxXferSize;
  
 /* SPI Rx Transfer size */
  
 __IO
  uint16_t
  
 RxXferCount;
  
 /* SPI Rx Transfer Counter */
  
 DMA_HandleTypeDef
  
 *
 hdmatx;
  
 /* SPI Tx DMA Handle parameters
  
 */
  
 DMA_HandleTypeDef
  
 *
 hdmarx;
  
 /* SPI Rx DMA Handle parameters
  
 */
  
 HAL_LockTypeDef
  
 Lock;
  
 /* Locking object
  
 */
  
 __IO HAL_SPI_StateTypeDef
  
 State;
  
 /* SPI communication state */
  
 __IO
  uint32_t
  
 ErrorCode;
  
 /* SPI Error code */
  
 } SPI_HandleTypeDef;
  
 Let us analyze the most important fields of this struct.
  
 •
  Instance
 : is the pointer to the SPI descriptor we are going to use. For example,
  SPI1
  is the 
  
 descriptor of the first SPI peripheral.
  
 •
  Init
 : is an instance of the C
  struct SPI_InitTypeDef
  used to configure the peripheral. We 
  
 will study it more in depth in a while.
  
 •
  pTxBuffPtr
 ,
  pRxBuffPtr
 : pointer to the internal buffers used to temporarily store data 
 trans-ferred to and from the SPI peripheral. This is used when the SPI works in 
 interrupt mode and should be not modified from the user code.
  
 •
  hdmatx
 ,
  hdmarx
 : pointer to instances of the
  DMA_HandleTypeDef struct
  used when the SPI 
  
 peripheral works in DMA mode.
  
 The setup of the SPI peripheral is performed by using an instance of the C
  struct 
 SPI_InitTypeDef
 , which is defined in the following way:",NA
15.2.1 Exchanging Messages Using SPI Peripheral,"Once the SPI peripheral is configured, we can start exchanging data with slave devices. 
 Since the SPI specification does not forces a given communication protocol, there is no 
 difference among the CubeHAL routines when using the SPI peripheral in
  slave
  or
  master
  
 mode. The only difference resides in the peripheral configuration, setting the
  Mode
  
 parameter of the
  SPI_InitTypeDef
  structure accordingly.
  
 As usual, the CubeHAL provides three ways to communicate over a SPI bus:
  polling
 ,
  
 interrupt
  and 
 DMA
  mode.
  
 To send an amount of bytes to a slave device in
  polling
  mode, we use the function:
  
 HAL_StatusTypeDef
  HAL_SPI_Transmit
 (SPI_HandleTypeDef
  *
 hspi,
  uint8_t
  *
 pData,
  uint16_t
  Size,
  
 uint32_t
  Timeout);
  
 The function signature is almost identical to other communication routines seen so far (for 
 example, those used for the UART manipulation), so we will not describe its parameters 
 here. This function can be used if the SPI peripheral is configured to work both in
  
 SPI_DIRECTION_1LINE
  or
  SPI_DIRECTION_-2LINES
  modes. To receive an amount of bytes in
  polling
  
 mode, we use the function:
  
 HAL_StatusTypeDef
  HAL_SPI_Receive
 (SPI_HandleTypeDef
  *
 hspi,
  uint8_t
  *
 pData,
  uint16_t
  Size,
  
 uint32_t
  Timeout);
  
 This function can be used in all three
  Direction
  modes.
  
 If the slave device supports the full-duplex mode, then we can use the function:",NA
15.2.2 Maximum Transmission Frequency Reachable using the ,NA,NA
CubeHAL,"The SCK frequency is derived from the PCLK frequency using a programmable prescaler. 
 This prescaler ranges from 2¹ up to 2⁸. However, as said several other times before, the 
 CubeHAL adds an unavoidable overhead when driving peripherals. And this also applies to 
 the SPI one. In fact, using the CubeHAL it is not possible to reach all supported SPI 
 frequencies with the different SPI modes.
  
 ST engineers have clearly documented this in the CubeHAL. If you open the
  
 stm32XXxx_hal_-spi.c
  file, you can see (about at line 60) two tables that report the 
 maximum reachable transmission frequency given the direction mode (half-duplex or full-
 duplex) and the way to program and use the peripheral (
 polling
 ,
  interrupt
  and
  DMA
 ).
  
 For example, in an STM32F4 MCU we can reach the a SCK frequency equal to
  f
 P CLK
 /8
  if the 
 SPI peripherals works in
  slave
  mode and we program it using CubeHAL in
  interrupt
  mode.",NA
15.3 Using CubeMX to Configure SPI Peripheral,"To use CubeMX in order to enable the wanted SPI peripheral, we have to proceed in the 
 following order. First, we need to select the wanted communication mode from the
  IP tree
  
 view, as shown in 
 Figure 5
 . Next, we need to specify the behaviour of the NSS signal in the 
 same configuration view. Once these two parameters are set, we can proceed by 
 configuring other SPI settings in the CubeMX 
 Configuration
  view.
  
  
 Figure 5: How to select the SPI communication mode in CubeMX",NA
16. Cyclic Redundancy Check,"In digital systems it is perfectly possible that data gets corrupted, especially if it flows 
 through a communication medium. In digital electronics, a message is a stream of bits 
 either equal to 0 or 1 and it becomes corrupted when one of more of these bits accidentally 
 change during transmission. For this reason, messages are always exchanged with some 
 additional data used to detect if the original message was corrupted. In
  Chapter 8
  we have 
 analyzed an early form of error detection related to data transmission: the
  parity bit
  is an 
 additional bit added to the message used to keep track if the number of bits equal to 1 is 
 odd or even (depending on the type of parity). However, this method is not able to detect 
 errors if two or more bits change at the same time.
  
 The
  Cyclic Redundancy Check
  (CRC) is a widely-used technique for detecting errors in digital 
 data, both during transmission and storage. In the CRC method, a number of check bits, 
 called the
  checksum
 ¹
 , are appended to the message being transmitted. The receiver can 
 determine whether or not the check bits agree with the data, to assert with a certain degree 
 of probability if an error occurred in transmission. If so, the receiver can ask to the sender 
 to retransmit the message again. This technique is also applied in some data storage 
 devices, such as Hard Disk Drives. In this case each block on the disk would have certain 
 check bits, and the hardware might automatically initiate a reread of the block when an 
 error is detected, or it might report the error to software. It is important to underline that 
 CRC is a good method to identify corrupted messages, but not for making corrections when 
 errors are detected.
  
 Being the CRC method used by a lot of communication peripherals and protocols (like the 
 Ethernet, MODBUS, etc.), it is quite common to find in microcontrollers dedicated hardware 
 peripherals able to compute CRC checksum of byte streams, freeing the CPU from 
 performing this operation in software. All STM32 microcontrollers provide a dedicated CRC 
 peripheral, and this chapter briefly explains how to use the corresponding CubeHAL 
 module.
  
 As usual, before going into the implementation details, we will first give a brief introduction 
 to the math behind the CRC technique
 ²
 .",NA
16.1 Introduction to CRC Computing,"CRC technique is based on well-known properties of polynomial arithmetic. To compute 
 the checksum of a stream of bits, the message is seen as a polynomial that is divided by 
 another fixed polynomial, called
  generator polynomial
 . The remainder of this operation is 
 the
  checksum
 , which is
  
 ¹
 The
  checksum
  is often called the
  CRC
 . This is not entirely correct, because the CRC is a specific error-detecting method, which 
 uses a well-characterized algorithm plus a checksum sequence of bits to detect if a message is corrupted. However, it is quite 
 common to refer to the checksum as the
  CRC
 , or the
  CRC code
 .",NA
16.1.1 CRC Calculation in STM32F1/F2/F4/L1 MCUs,"The long division of polynomial is suitable to perform manual calculations. However, 
 another more efficient CRC algorithm is the polynomial division with the bitwise message 
 XORing technique,",NA
16.1.2 CRC Peripheral in STM32F0/F3/F7/L0/L4 MCUs,"In the previous paragraph we have seen that the STM32 peripheral provided by some 
 STM32 MCUs is limited to the computation of the CRC using the CRC-32 Ethernet 
 polynomial. Moreover, the handled data size for every computation is 32-bit.
  
 In more recent STM32-series this limitation has been superseded. In fact, 
 STM32F0/F3/F7/L0/L4 MCUs provide a more advanced CRC peripheral, as shown in
  
 Table 1
 .",NA
16.2,NA,NA
 HAL_CRC,NA,NA
 Module,"The CubeHAL provides a dedicated module to manipulate CRC peripheral registers: the
  
 HAL_CRC
 . The CRC peripheral is referenced by using an instance of the
  CRC_HandleTypeDef 
 struct
 . In STM32F1/F2/F4/L1 MCUs providing the simplest CRC peripheral, this
  struct
  is 
 defined in the following way:
  
 typedef struct
  {
  
 CRC_TypeDef
  
 *
 Instance;
  
 /* CRC registers base address
  
 */
  
 HAL_LockTypeDef
  
 Lock;
  
 /* CRC locking object */
  
 __IO HAL_CRC_StateTypeDef
  
 State;
  
 /* CRC communication state */
  
 } CRC_HandleTypeDef;
  
 The only relevant field is the
  Instance
  one, which is the pointer to the CRC peripheral 
 descriptor (whose base address is defined by the
  CRC
  macro).
  
 Instead, in STM32F0/F3/F7/L0/L4 MCUs the
  CRC_HandleTypeDef struct
  is defined in the 
 following way:",NA
17. IWDG and WWDG Timers,"Anything that can go wrong, will go wrong
 , states the Murphy’s Law
 ¹
 . And this is 
 dramatically true especially for embedded systems. Apart from hardware faults, which can 
 also impact on the software, even the most careful design may have some unexpected 
 conditions that lead to abnormal behaviour of our device. And this may have important 
 costs, especially if the device is designed to work in dangerous and critical contexts.
  
 Almost all embedded microcontrollers on the market provide a
  WatchDog Timer
  (WDT)
 ²
 . A 
 watchdog is usually implemented as a free-running and down-counter timer, which causes 
 a reset of the MCU when it reaches zero or if the timer counter is not reloaded to its initial 
 value within a well defined temporal window (in this case we talk about
  windowed 
 watchdog
 ). Once enabled, the firmware needs to “constantly” refresh the watchdog counter 
 register to its initial value, otherwise the MCU reset line is asserted low by the timer and a 
 hard reset keeps going.
  
 A smart management of the WDT can help us to handle all those unwanted situations that 
 lead to faulty conditions of the embedded firmware (un-handled exceptions, stack 
 overflows, access to invalid memory locations, corruption of the SRAM due to unstable 
 power source, unconditional loops and so on). Moreover, if the WDT is able to warn us 
 when the timer is running out, we can try to recover the regular activities of the firmware 
 or, at least, to put the device in a safe state.
  
 STM32 microcontrollers provide two independent watchdog timers: the
  Independent 
 Watchdog 
 (IWDG) and the System
  Window Watchdog
  (WWDG). They share almost the 
 same characteristics, except for a couple of them that make one timer more suitable than 
 the other in some specific applications. This chapter shows how to use the CubeHAL to take 
 advantage of these two important, and often underused, peripherals.",NA
17.1 The,NA,NA
 Independent Watchdog,NA,NA
 Timer,"The IWDG is a 12-bit down-counter timer clocked by the
  Low-Speed Internal
  (LSI) 
 oscillator: this explains the adjective
  independent
 , meaning that this peripheral is not fed by 
 the peripheral clock, which is in turn generated by HSI or HSE oscillators. This is an 
 important characteristic, which allows to the IWDG timer to work even if the main clock 
 fails: the watchdog still keeps counting even if the CPU is halted, and it will reset the MCU 
 when reaches zero. If the firmware is properly designed to address this issue, the MCU can 
 recover from a faulted clock using the internal oscillator (HSE).
  
 ¹
 This author prefers the less famous Smith’s Law, which states:
  Murphy was an optimist
 .
  
  
 ²
 There exist really low-cost MCUs that do not provide this feature, or which implement it in a unreliable way, requiring to adopt 
 external and dedicated ICs.",NA
17.1.1 Using the CubeHAL to Program IWDG Timer,"To manipulate the IWDG peripheral, the HAL defines the C
  struct IWDG_HandleTypeDef
 , which 
 is defined in the following way:
  
 typedef struct
  {
  
 IWDG_TypeDef 
 *
 Instance;
  /* Pointer to IWDG descriptor */
  
 IWDG_InitTypeDef Init; 
  
 /* IWDG initialization parameters */
  
 HAL_LockTypeDef Lock; 
  
 /* IWDG locking object 
  
 */
  
 __IO HAL_IWDG_StateTypeDef 
  
 State; 
  
 /* IWDG communication state */
  
 } IWDG_HandleTypeDef;
  
 To configure the IWDG peripheral we use an instance of the C
  struct IWDG_InitTypeDef
 , which 
 is defined in the following way:
  
 ³
 In
  Chapter 19
  about power management, we will see how to address this limitation.",NA
17.2 The,NA,NA
 System Window Watchdog,NA,NA
 Timer,"The WWDG is a 7-bit down-counter timer clocked by the APB clock. Different from the 
 IWDG timer, the WWDG one is designed to be refreshed within a given temporal window, 
 otherwise it triggers the MCU reset. The way the WWDG timer works may seem a little bit 
 counterintuitive for newcomers. Let us explain the way it works step-by-step.
  
 The WWDG is a 7-bit timer (see
  Figure 1
 ). Its counter register can be set from 0x7F down 
 to 0x40. This value will be used to reload the counter register upon refresh (we are going to 
 call this value 
 T
 S
 ).
  
  
 Figure 1: The content of the WWDG counter register upon reset",NA
17.2.1 Using the CubeHAL to Program WWDG Timer,"To manipulate the WWDG peripheral, the HAL defines the C
  struct WWDG_HandleTypeDef
 , 
 which is defined in the following way:
  
 typedef struct
  {
  
 WWDG_TypeDef 
 *
 Instance;
  /* Pointer to WWDG descriptor */
  
 WWDG_InitTypeDef Init; 
  
 /* WWDG initialization parameters */
  
 HAL_LockTypeDef Lock; 
  
 /* WWDG locking object 
  
 */
  
 __IO HAL_WWDG_StateTypeDef 
  
 State; 
  
 /* WWDG communication state */
  
 } WWDG_HandleTypeDef;
  
 To configure the WWDG peripheral we use an instance of the C
  struct WWDG_InitTypeDef
 , 
 which is defined in the following way:
  
 typedef struct
  {
  
 uint32_t
  Prescaler;
  /* Select the prescaler of the WWDG */
  
 uint32_t
  Window; 
 /* Specifies the window value to be compared to the down-counter */
  
 uint32_t
  Counter; 
 /* Specifies the WWDG down-counter reload value */
  
 uint32_t
  EWIMode; 
 /* Specifies if WWDG Early Wakeup Interupt is enable or not.
  
 This parameter can be a value of @ref WWDG_EWI_Mode */
  
 } WWDG_InitTypeDef;
  
 Let us study the fields of this C
  struct
 .
  
 •
  Prescaler
 : this field specifies the prescaler value, and it can range from all powers of two 
 between 1 and 8. To specify this value, the CubeHAL defines four different macros -
  
 WWDG_-PRESCALER_1
 ,
  WWDG_PRESCALER_2
 , …,
  WWDG_PRESCALER_8
 .",NA
17.3 Detecting a System Reset Caused by a Watchdog ,NA,NA
Timer,"It could be useful to detect when a system reset is caused by the expiring of a watchdog 
 timer. This may help us understanding what is going wrong during a debug session. Two 
 special bits in a register of the
  Reset and Clock Control
  (RCC) peripheral allows to detect this 
 event.",NA
17.4 Freezing Watchdog Timers During a Debug Session,"During a debug session, both WWDG and IWDG timers will keep counting. This will prevent 
 us to carry out a step-by-step debugging. We can configure debug interface so that it halts 
 watchdog timers when the MCU is halted using the following macros:
  
 __HAL_DBGMCU_FREEZE_IWDG();
  
 __HAL_DBGMCU_FREEZE_WWDG();",NA
17.5 Selecting the Right Watchdog Timer for Your ,NA,NA
Application,"Both the watchdog timers have similar functionalities, and both of them do the same thing: 
 to reset the MCU if we do not refresh their counter register in a given amount of time. But 
 when it is best to prefer a timer over to other?
  
 The IWDG timer is to prefer when we need to be sure that the main clock is working. Being 
 the IWDG clocked by the independent LSI, it is really useful to detect such malfunctions. 
 Moreover, if we are using an RTOS, we can setup an independent thread configured with 
 the maximum priority and that uses a software timer to refresh the IWDG timer 
 periodically. This also helps us understanding that the kernel is properly scheduling 
 threads.
  
 The WWDG timer must be preferred to the IWDG one when we have to be sure that some 
 operations are carried out in a fixed and well-characterized temporal window. If that 
 procedure takes less or more time, it will not be able to refresh the timer in the temporal 
 window, causing a system reset. Moreover, the WWDG is the right choice if we want to 
 perform critical operations (like putting the machine in a safe state, or saving special data 
 in non-volatile memory): thanks to the early-warning IRQ, we can get notified of the 
 ongoing system reset.",NA
18. Real-Time Clock,"There exist a significant number of embedded applications that need to keep track of the 
 current time and date. Data-loggers, timers, home appliances and control devices are just a 
 limited example. Traditionally, microcontrollers are interfaced with dedicated ICs, which 
 are able to communicate using the SPI or the I²C bus. For example, the same ST 
 Microelectronics sells the
  M41T81¹
  IC, a popular
  Real-Time Clock
  (RTC) that requires a 
 couple of passives and a 32kHz oscillator to keep track of the current time. Moreover, the 
 same IC is also able to generate alarm events and to act as a watchdog timer.
  
 All STM32 microcontrollers provide an integrated RTC unit that is not limited to keeping 
 track of the current date/time. In fact, RTC provides some additional and relevant features 
 such as anti-tampering detection, generation of alarm events and the ability to wake-up the 
 MCU from deeper 
 low-power
  modes. This chapter shows how to program this peripheral 
 using the related CubeHAL module.",NA
18.1 Introduction to the RTC Peripheral,"The STM32 RTC is an independent
  Binary Coded Decimal
  (BCD) counter. BCD is one type of 
 binary encoding where each digit of a decimal number is represented independently by a 
 fixed number of bits. For example, the RTC timer represents the current hour in the 
 following way:
  
 • two bits are used to encode the hour tens;
  
 • four bits are used to encode the hour units;
  
 • three bits are used to encode the minute 
 tens;
  
 • four bits are used to encode the minute 
 units.
  
  
 Figure 1: How the time is encoded in BCD format in an STM32 MCU
  
 Figure 1
  shows how the STM32 RTC encodes the current hour in BCD format. Why to use 
 this approach to encode the date/time? This way to keep track of current date/time is 
 typical of small embedded systems and it allows to represent the time in human-readable 
 format without performing",NA
18.2,NA,NA
 HAL_RTC,NA,NA
 Module,"To program the RTC peripheral, the HAL defines the C
  struct RTC_HandleTypeDef
 , which is 
 defined in the following way:
  
 typedef struct
  {
  
 RTC_TypeDef
  
 *
 Instance;
  
 /* Register base address
  
 */
  
 RTC_InitTypeDef
  
 Init;
  
 /* RTC required parameters
  
 */
  
 HAL_LockTypeDef
  
 Lock;
  
 /* RTC locking object
  
 */
  
 __IO HAL_RTCStateTypeDef
  
 State;
  
 /* Time communication state */
  
 } RTC_HandleTypeDef;
  
 The only notably fields of this
  struct
  are
  Instance
 , which is the pointer to the RTC peripheral 
 descriptor, and the
  Init
  field used to configure the peripheral. This field is an instance of the 
 C 
 struct RTC_InitTypeDef
 , which is defined in the following way:
  
 typedef struct
  {
  
 uint32_t
  HourFormat; 
  
 /* Specifies the RTC Hour Format. */
  
 uint32_t
  AsynchPrediv; 
  
 /* Specifies the RTC Asynchronous Predivider value. */
  
 uint32_t
  SynchPrediv; 
  
 /* Specifies the RTC Synchronous Predivider value. */
  
 uint32_t
  OutPut; 
  
 /* Specifies which signal will be routed to the RTC output. */
  
 uint32_t
  OutPutPolarity; 
  
 /* Specifies the polarity of the output signal. */
  
 uint32_t
  OutPutType; 
  
 /* Specifies the RTC Output Pin mode. */
  
 } RTC_InitTypeDef;
  
 •
  HourFormat
 : this field specifies the hour format, and it can assume the values
  
 RTC_HOURFORMAT_-12
  to setup the AM/PM hour format ant the
  RTC_HOURFORMAT_24
  to 
 specify the 24 hour/day format.
  
 •
  AsynchPrediv
  and
  SynchPrediv
 : two prescalers are used to derive the 1Hz clock to feed the 
 RTC peripheral from the LSI/LSE/HSE oscillator sources. The first one is the
  
 asynchronous prescaler
 , a 7-bit counter that feeds in turn the
  synchronous prescaler
 , 
 another 15-bit counter. The values of these two fields must be set so that the 1Hz 
 frequency is reached according to equation [1], where
  Calendar
 CLK
  is one of 
 LSI/LSE/HSE. At the time of writing this chapter, the latest CubeMX release (4.22) is 
 not able to automatically derive the proper values for the 
 AsynchPrediv
  and
  SynchPrediv
  
 fields. You can use the values reported in
  Table 1
  for most relevant oscillator 
 frequencies.",NA
18.2.1 Setting and Retrieving the Current Date/Time,"The CubeHAL implements separated routines and C structs to set and retrieve the current 
 date and time. The functions:
  
 HAL_StatusTypeDef
  HAL_RTC_SetTime
 (RTC_HandleTypeDef
  *
 hrtc,
  
 RTC_TimeTypeDef
  *
 sTime,
  uint32_t
  Format);
  
 HAL_StatusTypeDef
  HAL_RTC_GetTime
 (RTC_HandleTypeDef
  *
 hrtc,
  
 RTC_TimeTypeDef
  *
 sTime,
  uint32_t
  Format);
  
 are used to set/get the current time, while the functions:",NA
18.2.2 Configuring Alarms,"STM32 RTC provides two alarms, named
  Alarm A
  and
  Alarm B
 , which have the same 
 functional-ities. An alarm can be generated at a given time or/and date programmed by the 
 user. To setup an alarm we use the function:",NA
18.2.3 Periodic Wakeup Unit,"In the next chapter we will see that STM32 microcontrollers provide the ability to 
 selectively disable internal functionalities in order to reduce the power consumption. 
 Several
  low-power
  modes give to programmers the possibility to decide the power 
 consumption level that best fits his needs, especially when developing battery-powered 
 devices.
  
 The STM32 RTC features a periodic timebase and wakeup unit that can wakeup the system 
 when the microcontroller operates in
  low-power
  modes. This unit is a programmable 16-bit",NA
18.2.4 Timestamp Generation and Tamper Detection,"The RTC peripheral is hardwired to a number of signal I/Os depending on the package 
 used. These I/Os can be used to generate a timestamp when their state changes. Current 
 date/time is so saved inside dedicated registers, and the correspondng interrupt is also 
 fired if enabled.
  
 To set the timestamp generation, the CubeHAL provides the function:
  
 HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef
  *
 hrtc,
  uint32_t
  TimeStampEdge,
  
 uint32_t
  RTC_TimeStampPin);
  
 The
  TimeStampEdge
  parameter specifies the pin edge on which the timestamp is activated. 
 This parameter can be one of the following values:
  RTC_TIMESTAMPEDGE_RISING
  and
  
 RTC_TIMESTAMPEDGE_-FALLING
 . The
  RTC_TimeStampPin
  specifies the I/Os used to generate the 
 timestamp, and it can assume the value
  RTC_TIMESTAMPPIN_DEFAULT
  (which usually 
 corresponds to PC13 pin), or the value 
 RTC_TIMESTAMPPIN_PA0
  or
  RTC_TIMESTAMPPIN_POS1
  to 
 indicate an alternative pin (usually PA0 or PI8).
  
 To enable the corresponding interrupt, which is associated with the dedicated
  
 TAMP_STAMP_IRQn
  IRQ, we can use the function:
  
 HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef
  *
 hrtc,
  uint32_t
  TimeStampEdge,
  
 uint32_t
  RTC_TimeStampPin);
  
 The
  HAL_RTCEx_TamperTimeStampIRQHandler()
  is the handler to call from the ISR, while the
  
 HAL_-RTCEx_TimeStampEventCallback()
  is the corresponding callback. If, instead, we want to use 
 the timestamp feature in polling mode, we can use the function:
  
 HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef
  *
 hrtc,
  uint32_t
  Timeout);
  
 to poll for timestamp event. To retrieve the date/time saved in the timestamp registers, we 
 can use the function:
  
 HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef
  *
 hrtc, RTC_TimeTypeDef
  *
 sTimeStamp,
  
 RTC_DateTypeDef
  *
 sTimeStampDate,
  uint32_t
  Format);
  
 The same I/Os can be configured to detect tampering. The CubeHAL provides dedicated 
 routines and C structures to program this feature. We will not address them here. Refer to 
 the CubeHAL source code (especially to the module
  HAL_RTCEx
 ) for more about this.",NA
18.2.5 RTC Calibration,"RTC can be calibrated to compensate imprecisions of the RTCCLK source. This is especially 
 useful for applications that need an elevate RTC precision and for those applications that 
 demand RTC stability when temperature changes.",NA
18.3 Using the Backup SRAM,"The majority of STM32 microcontrollers provide an additional memory region called
  
 backup memory
  (or
  RTC backup data memory
 ). This memory is powered-on by VBAT when 
 VDD is switched off, if the VBAT pin is connected to a backup power source, so that its",NA
III Advanced topics,NA,NA
19. Power Management,"Energy efficiency is one of the trend topics in the electronics industry. Even if you are not 
 designing a battery-powered device, probably you have to address power-related 
 requirements anyway. A well-designed device, from the power point of view, not only 
 consumes less energy, but it also allows to simplify and minimize its power-section, 
 reducing the overall dimension of the PCB, the BOM and the power dissipation.
  
 Often we think that the power management of an electronic board is all related to its 
 powering stage. In the last two decades, power-conversion has been the hot topic. The 
 research and development made by IC vendors did generate a lot of integrated devices able 
 to boost the overall power efficiency in a lot of applications fields, ranging from low-power 
 solutions to high-load power conversion units able to supply thousands of amperes. 
 Instead, as embedded developers, we have great responsibility in ensuring that our 
 firmware can minimize the energy consumption of devices we make.
  
 Modern microcontrollers provide to developers a lot of tools to minimize the energy used. 
 Cortex-M cores aren’t an exception, and they provide an “abstract” power management 
 model that is rearranged by silicon manufacturers to create their own power management 
 scheme. This is exactly the case of STM32 MCUs: even if power management is addressed in 
 all STM32-series, it reaches a very sophisticated implementation in STM32L families, which 
 provide to developers a scalable power model to precisely tune-up the energy needed. This 
 allows to design electronic devices able to run even for years while powered by a coin-cell 
 battery.
  
 In this chapter we will give a quick look at the way power management is implemented in 
 STM32 MCUs, analyzing the STM32F-series and the STM32L-series separately. We will 
 start examining which features are provided by the Cortex-M core and then we will 
 discover how ST engineers have specialized them to provide up to eleven different power 
 modes in the recent STM32L4-series.",NA
19.1 Power Management in Cortex-M Based MCUs,"Before we study the features provided by Cortex-M based microcontrollers to 
 programmatically select the
  power mode
  of the MCU, it is best to do some considerations 
 about the power consumption sources in a digital device.
  
 First of all, the complexity of the device itself impacts on the energy consumed. The more 
 peripherals and features our board provides, the more power is needed. Moreover, some 
 peripherals are intrinsically energy-intensive. For example, TFT displays consume a lot of 
 power if compared with other parts of the electronic board. Finally, a low-power design",NA
19.2 How Cortex-M MCUs Handle,NA,NA
 Run,NA,NA
 and,NA,NA
 Sleep,NA,NA
 Modes,"When a Cortex-M based microcontroller resets, its power mode is set to the
  run
 ⁴
  one. In 
 this mode the energy needed is certainly established by the whole MCU design, but mainly 
 from the running frequency and the number of active peripherals. Here it is important to 
 remark that also the flash
  
  
 ¹
 As we will discover next, in some really “deep” sleep modes the MCU can be woken up only by few peripherals, which always 
 include the RTC.
  
  
 ²
 The I²C peripheral consumes up to 720µA in an “old” STM32F103 running at its maximum clock speed. This might seem not 
 that much for a device powered from the mains, but it has a dramatic impact on a battery-powered device.
  
 ³
 In this mode, the core of an STM32L4 MCU consumes about 1.1µA.",NA
19.2.1 Entering/exiting sleep modes,"As said in the previous paragraph, the CPU enters in sleep mode exclusively on a voluntary 
 basis, by using specific ARM assembly instructions. This means that, as programmers, we 
 have all the responsibility of the power consumption of devices we make
 ⁶
 .
  
 Cortex-M based MCUs offer two instructions to place the MCU in sleep mode:
  WFI
  and
  WFE
 . 
 The 
 Wait For Interrupt
  (
 WFI
 ) instruction is also called the un-conditional sleep instruction. 
 When the CPU executes that instruction it immediately halts the core execution. The CPU 
 will be resumed only by an interrupt request, depending on the interrupt priority and the 
 effective sleep level (more about this later), or in case of debug events. If an interrupt is 
 pending while the MCU executes the 
 WFI
  instruction, it enters in sleep mode and wakes up 
 again immediately.
  
 The
  Wait For Event
  (
 WFE
 ) is the other instruction that allows to place the MCU in sleep 
 mode. It differs from the
  WFI
  due to the fact that it checks the status of a particular event 
 register
 ⁷
  before it halts the core: if this register is set, the
  WFE
  clears it and does not halt the 
 CPU, continuing the program execution (this allows us to manage the pending event, if 
 needed). Otherwise, it halts the MCU until this event register is set again.
  
 But what is exactly the difference between an event and an interrupt? Events are a source 
 of confusion in the STM32 world (also in the Cortex-M world in general). They appear like 
 something intangible, compared to the interrupts that we have learned to handle in
  
 Chapter 7
 . Before we clarify what events are, we need to better explain the role of the EXTI 
 controller in an STM32 MCU. The 
 Extended Interrupts and Events Controller
  (EXTI) is the 
 hardware component internal to the MCU that manages the external and internal 
 asynchronous interrupts/events and generates the event request to the CPU/NVIC 
 controller and a wake-up request to the Power Controller (see
  Figure 2
 ). The EXTI allows 
 the management of several event lines, which can wake up the MCU from some sleep 
 modes (not all events can wake up MCU). The lines are either configurable or direct and 
 hence hardwired inside the MCU:
  
 •
  The lines are configurable
 : the active edge can be chosen independently, and a status 
 flag indicates the source of the interrupt. The configurable lines are used by the I/Os 
 external interrupts, and by few peripherals (more about this soon).
  
 •
  The lines are direct and hardwired
 : they are used by some peripherals to generate a 
 wakeup from stop event or interrupt. The status flag is provided by the peripheral 
 itself. For example, the RTC can be used to generate an event to wake up the MCU.
  
  
 ⁶
 Clearly, we are talking about the power consumption of the MCU core and all integrated peripherals. The power consumption 
 of the overall board is determined by other things that we will not address here.
  
  
 ⁷
 This register is internal to the core and not accessible to the user.",NA
19.2.2,NA,NA
 Sleep,NA,NA
 Modes in Cortex-M Based MCUs,"So far, we have talked broadly about
  sleep
  mode. This mainly because the power 
 management scheme defined by ARM is further specialized by chip vendors, like ST does 
 with its products. Cortex-M based microcontrollers architecturally support two
  sleep
  
 modes:
  normal sleep
  and
  deep sleep
 . As we will discover later in this chapter, STM32F 
 microcontrollers calls them
  sleep
  and
  stop
  modes",NA
19.3 Power Management in STM32F Microcontrollers,"The concepts illustrated so far are common to all STM32 microcontrollers. However, the 
 STM32 portfolio is divided in two main branches: STM32F and STM32L series. The second 
 one is addressed to low-power applications, and it provides a lot of more operative modes 
 to minimize the power consumption.
  
 We will start by analyzing how to manage power modes in STM32F microcontrollers. 
 However, it is important to underline that, as often happens for the other features offered 
 by this large portfolio, some STM32 families, and even some certain part numbers, offer 
 specific peculiarities that differ from the way the power management is handled in the 
 majority of STM32 microcontrollers. For this reason, always keep on hand the reference 
 manual for the MCU you are considering.",NA
19.3.1 Power Sources,"Figure 3
  shows the power sources of an STM32F microcontroller
 ¹⁰
 . As said before, even if 
 we are used to supply the MCU by just one power source (more about this in
  Chapter 27
 ), 
 the MCU has an internal power distribution network that defines several
  voltage domains
  
 used to power those peripherals that share the same powering characteristics. For 
 example, the
  VDDA domain
  includes those analog peripherals that need a separated (better 
 filtered) power source, fed through the VDDA pins.
  
 ⁹
 As we will discover next, STM32 microcontroller can be powered by a variable voltage source ranging from 2.0V to 3.6V (some 
 of them allow to be powered even down to 1.7V). This voltage source is also called
  VDD domain
  and all components inside the MCU 
 powered from this source are said to be part of the
  VDD domain
 . However, the internal MCU core and some other peripherals are 
 powered by a dedicated 1.8V (or even 1.0V in low power STM32L MCUs) internal voltage regulator. This defines the
  1.8V domain
 . 
 The low-voltage internal regulator can be independently turned OFF. More about this later.
  
 ¹⁰
 It is important to remark that the diagram in
  Figure 3
  is just a scheme. Some STM32F MCUs, especially those providing a TFT-
 LCD controller or other communication interfaces like the Ethernet, introduce other power source domains. In the same way,",NA
19.3.2 Power Modes,"In the first part of this chapter, we have seen that a Cortex-M MCU provides three main 
 power modes:
  run
 ,
  sleep
  and
  deep sleep
 . Now it is the right time to see how ST engineers 
 have rearranged them in STM32F MCUs.
  Table 1
  summarizes these modes and shows the 
 three main functions provided by the HAL to place the MCU in the corresponding power 
 mode. We will analyze them more in depth later.
  
 ¹¹
 Backup registers are a dedicated memory area, with a typical size of 4Kb, that is powered by a different power source usually 
 connected to a battery or a super-capacitor. This is used to store volatile data that remains valid even when the MCU is powered 
 OFF, either if the whole device is turned OFF or the MCU is placed in
  standby
  mode.",NA
19.3.3 An Important Warning for STM32F1 Microcontrollers,"During the development of the examples for the FreeRTOS
  tickless
  mode in the
  related 
 chapter
 , I have encountered a nasty behaviour of the STM32F103 MCU when entering in",NA
19.4 Power Management in STM32L Microcontrollers,"The STM32L-series is a quite extensive portfolio of MCUs tailored for low-power 
 applications. It is divided in three main families: L0, L1 and the more recent L4. These 
 microcontrollers provide more power modes than the STM32F ones, offering the ability to 
 precisely tune the energy consumed by the CPU core and integrated peripherals. Moreover, 
 they provide specific low-power peripherals (like the LPUART or the LPTIM timers). All 
 these features make STM32L MCUs suitable for battery-powered devices.
  
 In this part of the chapter we will analyze the most relevant power management-related 
 character-istics offered by STM32L MCUs, focusing our attention mainly on the STM32L4 
 family.",NA
19.4.1 Power Sources,"Figure 6
  shows the power sources of an STM32L4 microcontroller. As you can see, to allow 
 a precise tuning of the power consumed by peripherals, these MCUs provide more
  voltage 
 domains
  compared to the STM32F ones.
  
 ¹⁷
 http://bit.ly/1rVx4LN",NA
19.4.2 Power Modes,"Apart from a dedicated design that allows to reduce the power consumption of each 
 component of the MCU, STM32L MCU provide to the user up to eleven different power 
 modes, as shown in
  Figure 7
 . For the first three power modes, consumption values per 
 MHz are an average between the power consumption value when the CPU runs instructions 
 from the flash and from the SRAM
 ¹⁸
 . The first three power modes are based on the Cortex-
 M
  run
  mode, while the next four modes are based on the
  sleep
  one. Finally, all other low-
 power modes rely in the Cortex-M
  deep sleep
  mode.
  
 Table 2
  summarizes nine power modes and shows the functions provided by the HAL to 
 place the MCU in the corresponding power mode. We will analyze them more in depth later.
  
  
 Figure 7: The eleven power modes supported by STM32L4 microcontrollers
  
 19.4.2.1 Run Modes
  
 By default, and after power-on or a system reset, STM32L MCUs are placed in
  run
  mode. 
 The default clock source is set to the MSI, a power-optimized clock source that we have 
 encountered in
  Chapter 10
 . STM32L microcontrollers offer to developers more fine-tune 
 capabilities, which allow to reduce the power consumption in this mode. If we do not need 
 too much computing power, then we can leave the MSI as the main clock source, avoiding 
 the powering consumption introduced by the PLL multiplexer. By reducing the clock speed 
 down to 24-26MHz, we can configure the
  Dynamic Voltage Scaling
  (DVS)
  scale 2
  that 
 decreases the
  VCORE domain
  down to 1.0V in more recent STM32L4",NA
19.4.3 Power Modes Transitions,NA,NA
19.4.4 Low-Power Peripherals,"Almost all STM32L MCUs provide dedicated low-power peripherals. Here you can find a 
 brief introduction to them.
  
 19.4.4.1 LPUART
  
 The
  Low-Power UART
  (LPUART) is an UART that allows bidirectional UART 
 communications with limited power consumption. Only a 32.768 kHz LSE clock is required 
 to allow UART communications up to 9600 baud/s. Higher baud rates can be reached when 
 the LPUART is clocked by clock sources different from the LSE clock. Even when the 
 microcontroller is in
  stop
  mode, the LPUART can wait for an incoming UART frame while 
 having an extremely low-energy consumption. The LPUART includes all necessary 
 hardware support to make asynchronous serial communications possible with minimum 
 power consumption. It supports half-duplex single wire communications and modem",NA
19.5 Power Supply Supervisors,"The majority of STM32 microcontrollers provide two power supply supervisors: BOR and 
 PVD. The 
 Brownout Reset
  (BOR) is a unit that keeps the microcontroller under reset until 
 the supply voltage reaches the specified VBOR threshold. VBOR is configured through 
 device option bytes. By default, BOR is OFF. The user can select between three to five 
 programmable VBOR threshold levels. For full details about BOR characteristics, refer to 
 the “Electrical characteristics” section in the device datasheet. STM32 devices that do not 
 provide a BOR unit, usually have a similar unit named
  Power on Reset
  (POR)/
 Power Down 
 Reset
  (PDR), which perform the same operation of the BOR unit but with a fixed and 
 factory-configured voltage threshold.",NA
19.6 Debugging in Low-Power Modes,"By default, the debug connection is lost if the application puts the MCU in
  sleep
 ,
  stop
  and
  
 standby 
 modes while the debug features are used. This is due to the fact that the Cortex-M 
 core is no longer clocked. However, by setting some configuration bits in the
  DBGMCU_CR
  
 register of the
  MCU debug component
  (DBGMCU), the software can be debugged even when 
 using the low-power modes extensively.
  
 The CubeHAL provides convenient functions to enable/disable debug mode in low-power 
 modes. The function
  HAL_DBGMCU_EnableDBGSleepMode()
  is used to enable debugging during
  
 sleep
  
 mode
 ²¹
 ; 
 the 
 functions
  
 HAL_DBGMCU_EnableDBGStopMode()
  
 and
  
 HAL_DBGMCU_EnableDBGStandbyMode()
  allow to use debug interface during
  stop
  and
  standby
  
 modes respectively.
  
 It is important to remark that, if we want to debug the MCU in low-power modes, we 
 also have to leave ON the GPIO peripherals corresponding to SWDIO/SWO/SWCLK 
 pins. In all Nucleo boards these pins coincide with PA13, PA14 and PB3.
  
  
 Please, take note that, before enabling MCU debugging in low-power modes, DBGMCU 
 interface must be enabled by calling the
  __HAL_RCC_DBGMCU_CLK_ENABLE()
  macro.",NA
19.7 Using the CubeMX Power Consumption Calculator,"It may be a nightmare to manually estimate the power consumption of a microcontroller, 
 with several peripheral enabled and several transition states in its different power modes. 
 Even if MCU datasheets provide all necessary information, it is really hard to figure out the 
 exact power consumption levels.
  
 CubeMX provides a convenient tool, named
  Power Consumption Calculator
  (PCC), which 
 allows us to build a power sequence and to perform estimations of the MCU power 
 consumption.
  
 ²¹
 Debugging during the
  sleep
  mode is not available in STM32F0 microcontrollers and hence the corresponding HAL function is not 
 provided by the HAL.",NA
19.8 A Case Study: Using Watchdog Timers With ,NA,NA
Low-Power Modes,"Both IWDG and WWDG timers cannot be stopped once started. The WWDG timer keeps 
 counting until the
  stop
  mode, while the IWDG timer, being clocked by the LSI oscillator, 
 works even in 
 shutdown
  mode. This means that watchdog timers prevents the MCU from 
 staying in low-power mode for a long time.
  
 ²²
 http://bit.ly/1WDpa5r",NA
20. Memory layout,"Every time we compile our firmware using the GCC ARM tool-chain, a series of non-trivial 
 things takes place. The compiler translates the C source code in the ARM assembly and 
 organizes it to be flashed on a given STM32 MCU. Every microprocessor architecture 
 defines an execution model that needs to be “matched” with the execution model of the C 
 programming language. This means that several operations are performed during 
 bootstrap, whose task is to prepare the execution environment for our application: the 
 stack and heap creation, the initialization of data memory, the 
 vector table
  initialization are 
 just some of the activities performed during startup. Moreover, some STM32 
 microcontrollers provide additional memories, or allow to interface external ones using the 
 FSMC controller, that can be assigned to specific tasks during the firmware lifecycle.
  
 This chapter aims to throw light to those questions that are common to a lot of STM32 
 developers. What does it happen when the MCU resets? Why providing the
  main()
  function 
 is mandatory? And how long does it take to execute since the MCU resets? How to store 
 variables in flash instead of SRAM? How to use the STM32 CCM memory?",NA
20.1 The STM32 Memory Layout Model,"In Chapter 1 we have analyzed how STM32 MCUs organize the 4GB memory address space.
  
 Figure 4
  from that chapter clearly shows how the first 0.5GB of memory are dedicated to 
 the code area. In turn this area is subdivided in several sub-regions. The most important 
 one, starting from
  0x0800 0000
  address, is dedicated to the mapping of the internal flash 
 memory. Instead, the internal SRAM memory starts from the
  0x2000 0000
  address, and it is 
 organized in several sub-regions dedicated to specific tasks that we will see in a while.
  
 Figure 1
  shows the typical layout of flash and SRAM memories in an STM32 MCU
 ¹
 . In
  
 Chapter 7
  we learned that the initial bytes of flash memory are dedicated to the
  Main Stack 
 Pointer
  (MSP) and the 
 vector table
 ²
 . The MSP contains the address where the stack begins. 
 The Cortex-M architecture gives maximum freedom of placing the stack in the SRAM 
 memory as well as in other internal memories (for example, the CCM RAM available in 
 some STM32 MCUs) or external ones (connected to the FSMC controller). This explains the 
 need for the MSP.
  
 The flash memory can be also used to store read only data, also known as
  const data
  due to 
 the fact that variables declared as
  const
  are automatically placed in this memory. Finally, the 
 flash memory contains the assembly code generated from the C source code.
  
  
 ¹
 It is important to remark that this layout reflects just one of the possible memory configurations, and it changes in case we use 
 an RTOS. However, the underlying concepts remain the same, and it is better to consider this memory organization here.
  
  
 ²
 Remember that, as we will see next, the Cortex-M architecture defines the
  0x0000 0000
  address as the memory location where 
 starting to place MSP and
  vector table
 . This means that the flash starting address (
 0x0800 0000
 ) is aliased to
  0x0000 0000
 .",NA
20.1.1 Understanding Compilation and Linking Processes,"The process that goes from the compilation of the C source code to the generation of the 
 final binary image to flash on our MCU involves several steps and tools provided by the GCC 
 tool-chain. The 
 Figure 2
  tries to outline this process. All starts from the C source files. They 
 usually contain the following program structures.
  
 ³
 However, we will see next that its name is just a convention.",NA
20.2 The Really Minimal STM32 Application,"The most of applications seen until now seem really simple. Instead, both from the memory 
 organization point of view and from the operations performed when the MCU boots, they 
 already execute a lot of operations under the hood. For this reason, we are going to build a 
 really essential application.
  
 The first step is creating an empty project using Eclipse. Go to
  File->New->C Project
  menu. 
 Choose the
  Empty project
  type and select the
  Cross ARM GCC
  tool-chain, as shown in
  
 Figure 3
 . Complete the project wizard.
  
  
 Figure 3: The project settings to choose
  
 Create now a new file named
  main.c
  and place the following code inside it
 ⁸
 .
  
 ⁸
 This code is designed to work with the Nucleo-F401RE. Refer to the book examples for the other Nucleos.",NA
20.2.1 ELF Binary File Inspection,"An ELF binary file can be inspected using a series of tools provided by the GNU MCU tool-
 chain. 
 objdump
  and
  readelf
  are the most common ones. Describing their usage is outside the 
 scope of this book. However, it is strongly suggested to dedicate a couple of hours playing 
 with their optional parameters to the command-line. Understanding how a binary file is 
 made can dramatically improve the knowledge of what under the hood. For example, 
 running
  objdump
  with the
  -h
  parameter shows the content of all sections contained in the 
 firmware binary
 ¹²
 .
  
 ¹⁰
 The
  ENTRY()
  directive is meaningless in embedded applications, where the actual entry point corresponds to the handler of the
  
 Reset 
 exception. However, it may be informative for debuggers and simulators, and for this reason you will find it in ST official LD 
 linker scripts.
  
 ¹¹
 Ok, coding it in assembly will allow you to save additional space, but this book is not for masochists ;-D
  
 ¹²
 When you run the command, you will se much more sections all related to debug. Here you will not see them because the debug 
 information has been “stripped” from the file using the
  arm-none-eabi-strip
  command.",NA
20.2.2,.data,NA
 and,.bss,NA
 Sections Initialization,"Let us introduce a minor modification to the previous example.
  
 36 
 volatile
  uint32_t
  dataVar
  = 0x3f
 ;
  
 37
  
 38 
 int
  main
 () {
  
 39 
 /* enable clock on GPIOA and GPIOC peripherals */
  
 40 
 *
 RCC_APB1ENR
  = 0x1 | 0x4
 ;
  
 41 
 *
 GPIOA_MODER
  |= 0x400
 ;
  // Sets MODER[11:10] = 0x1
  
 42
  
 43
  
 }
  
 while
 (dataVar
  == 0x3f
 ) {
  // This is always true
  
 44
  
 *
 GPIOA_ODR
  = 0x20
 ;
  
 45
  
 delay(
 200000
 );
  
 46
  
 *
 GPIOA_ODR
  = 0x0
 ;
  
 47
  
 delay(
 200000
 );
  
 48
  
 }
  
 49
  
 This time we use a global initialized variable,
  dataVar
 , to start the blinking loop. The variable 
 has been declared
  volatile
  just to avoid that the compiler optimizes it (however, when 
 compiling this example, disable all optimizations [-ON] in the project settings). Looking at 
 the code, we can reach to the conclusion that it does the same thing of the previous 
 example. However, if you try to flash your Nucleo, you will see that the LD2 LED does not 
 blink. Why not?
  
 To understand what’s happening, we have to review some things from the C programming 
 language. Consider the following code fragment:",NA
20.2.3,.rodata,NA
 Section,"A program usually makes usage of constant data. Strings and numeric constants are just 
 two examples, but also large arrays of data can be initialized as constants (for example, a 
 HTML file used to generate web pages can be converted in an array, using tools like the
  xxd
  
 UNIX command). Being immutable, constant data can be placed inside the internal flash 
 memory (or inside external flash memories connected to the MCU through the Quad-SPI 
 interface) to save SRAM space. This can be simply achieved defining the
  .rodata
  section 
 inside the linker script:
  
 /* Constant data goes into flash */
  
 .rodata : ALIGN(4)
  
 {
  
 *(.rodata) 
  
 /* .rodata sections (constants) */
  
 *(.rodata*) 
  
 /* .rodata* sections (strings, etc.) */
  
 } >FLASH
  
 For example, considering this C code:
  
 Filename:
  src/main-ex4.c
  
 76 
  
 77
  
 const
  char
  msg[]
  =
  ""Hello World!""
 ; 
  
 const
  float
  vals[]
  =
  {
 3.14
 ,
  0.43
 ,
  1.414
 };
  
 78
  
 79 
 int
  main
 () {
  
 80 
 /* enable clock on GPIOA and GPIOC peripherals */
  
 81 
 *
 RCC_APB1ENR
  = 0x1 | 0x4
 ;
  
 82 
 *
 GPIOA_MODER
  |= 0x400
 ;
  // Sets MODER[11:10] = 0x1
  
 83
  
 84
  
 }
  
 while
 (vals[
 0
 ]
  >= 3.14
 ) {
  
 85
  
 *
 GPIOA_ODR
  = 0x20
 ;
  
 86
  
 delay(
 200000
 );
  
 87
  
 *
 GPIOA_ODR
  = 0x0
 ;
  
 88
  
 delay(
 200000
 );
  
 89
  
 }
  
 90",NA
20.2.4 Stack and Heap Regions,"We have already seen in
  Figure 1
  that heap and stack are two dynamic regions of the 
 SRAM memory that grow in the opposite direction. The stack is a descendant structure, 
 which grows from the end of SRAM up to the end of
  .bss
  section, or the end of the heap if 
 used. The heap grows in the opposite direction. While the stack is a mandatory structure in 
 C, the heap is used only if dynamic memory allocation is needed. In some application fields 
 (like in automotive area) the dynamic allocation is not used, or at least is strongly 
 suggested not to be used, because of the risk involved. A decent management of the heap 
 introduces a lot of performance penalties, and it is the source of possible leaks and memory 
 fragmentation.",NA
20.2.5 Checking the Size of Heap and Stack at Compile-Time,"Microcontrollers have limited memory resources. Especially with
  Value-lines
  STM32 MCUs, 
 it is really common to exceed the maximum SRAM memory. We can use the linker script",NA
20.2.6 Differences With the Tool-Chain Script Files,"The linker script made so far works well for the majority of STM32 applications. However, 
 if you are going to code your firmware in C++, or simply using libraries made in C++, then 
 those linker script and starting sequences are not sufficient. To understand why, consider 
 the following C++ application:
  
 1 
 class
  MyClass
  { 
  
 2 
  
 int
  i; 
  
 3 
  
 4 
 public
 : 
  
 5 
  
  
 MyClass() { 
 6 
   
  
 i
  = 
 100
 ; 
  
 7 
  
 }",NA
20.3 How to Use the CCM Memory,"Some microcontrollers from STM32F3/4/7 families provide an additional SRAM memory 
 named 
 Core Coupled Memory
  (CCM). Different from the regular SRAM, this memory is 
 tightly coupled with the Cortex-M core. A direct path connects both the D-Bus and I-Bus to 
 this memory area (see 
 Figure 5
 ¹⁷
 ), allowing 0-wait state execution. Although it is perfectly 
 possible to store data in this memory, like look-up tables and initialization vectors, the best 
 usage of this area is to store critical and computational intensive routines, which may be 
 executed in real-time. For this reason, MCUs with CCM memory are said to implement
  
 routine booster technology
 .
  
  
 Figure 5: The direct connection between the Cortex-M core and the CCM SRAM
  
 ¹⁷
 The figure has been arranged from the one contained in the
  AN4296 from ST
 (http://bit.ly/1QSctkT).",NA
20.3.1 Relocating the,NA,NA
 vector table,NA,NA
 in CCM Memory,"The CCM memory can be also used to store ISR routines, relocating the whole
  vector table
  
 inside the
  
 CCM memory. This can be especially useful for ISRs that need to be processed in the 
 shortest possible
  
 time. However, relocating the
  vector table
  requires additional steps, since the Cortex-M 
 architecture
  
 is designed so that the
  vector table
  starts from the
  0x0000 0004
  address (which corresponds 
 to the
  
 0x0800 0004
  address of the internal flash memory). The steps to follow are these ones:
  
 • define the
  vector table
  to place in the CCM RAM using the
  __attribute__((section("".isr_-
  
 vector_ccm""))
  keyword;
  
 • define the exception handlers for the interested exceptions and ISRs and place them in 
 the
  
 corresponding section using the
  __attribute__((section("".ccm""))
  keyword;
  
 • define a minimal
  vector table
 , composed by the MSP pointer and the address of the
  
 Reset
  
 exception handler, to place in the flash memory starting from
  0x0800 0000
  address;
  
 • relocate the
  vector table
  from the
  Reset
  exception by copying the content of the
  .ccm
  
 section
  
 from the flash memory into the SRAM.
  
 Let us start defining the
  vector table
  to place in CCM RAM. Here we are defining a file named
  
 ccm_vector.c
  with the following content:
  
 Filename:
  src/ccm_vector.c
  
 1
  
 #include
  <stm32f3xx_hal.h>
  
 2
  
 3
  
 #define GPIOA_ODR
  
 ((uint32_t*)(GPIOA_BASE + 0x14))
  
 4
  
 5 
  
 extern const
  uint32_t
  _estack;
  
 6
  
 7 
  
 void
  SysTick_Handler
 (
 void
 );
  
 8
  
 9 
  
 uint32_t
  *
 ccm_vector_table[] __attribute__((section(
 "".isr_vector_ccm""
 )))
  =
  {
  
 10 
 (
 uint32_t
  *
 )
 &
 _estack, 
  
 // initial stack pointer
  
 11 
 (
 uint32_t
  *
 )
  0
 , 
  
 // Reset_Handler not relocatable
  
 12 
 (
 uint32_t
  *
 )
  0
 ,",NA
20.4 How to Use the MPU in Cortex-M0+/3/4/7 Based ,NA,NA
STM32 MCUs,"Apart from the Cortex-M0 core, all Cortex-M based microcontrollers can optionally provide 
 a 
 Memory Protection Unit
  (MPU). And the good news is that all STM32 MCUs based on that 
 cores provide it. The MPU should not be confused with the
  Memory Management Unit
  
 (MMU), an advanced hardware component available in more performing microprocessors 
 like Cortex-A, which is mostly dedicated to the translation of virtual memory addresses in 
 physical ones.
  
 The MPU is used to protect up to eight memory regions, numbered from 0 to 7. These, in 
 turn can have eight subregions, if the main region is at least 256 bytes. The subregions have 
 all the same size, and can be enabled or disabled according to the subregion number. The 
 MPU is used to make an embedded system more robust and more secure, and in some 
 application domains its usage is mandatory (e.g. in automotive and aerospace). The MPU 
 can be used to:",NA
20.4.1 Programming the MPU With the CubeHAL,"The CubeHAL provides all the necessary abstraction layer to program the MPU. The 
 function
  
 void
  HAL_MPU_ConfigRegion
 (MPU_Region_InitTypeDef
  *
 MPU_Init);
  
 allows to configure a memory region. All region settings are specified with an instance of 
 the
  MPU_-
  
 Region_InitTypeDef struct
 , which is defined in the following way:
  
 typedef struct
  {
  
 uint8_t 
  
 Enable; 
  
 /* Specifies the status of the region. */
  
 uint8_t 
  
 Number; 
  
 /* Specifies the number of the region to protect. */
  
 uint32_t
  BaseAddress; 
  
 /* Specifies the base address of the region to protect. */
  
 uint8_t 
  
 Size; 
  
 /* Specifies the size of the region to protect. 
  
 */
  
 uint8_t 
  
 SubRegionDisable;
  /* Specifies the number of the subregion protection
  
 to disable. */
  
 uint8_t 
  
 TypeExtField; 
  
 /* Specifies the TEX field level. */
  
 uint8_t 
  
 AccessPermission;
  /* Specifies the region access permission type. */
  
 uint8_t 
  
 DisableExec; 
  
 /* Specifies the instruction access status. */
  
 uint8_t 
  
 IsShareable; 
  
 /* Specifies the shareability status of the
  
 protected region. */
  
 uint8_t
  
 IsCacheable;
  
 /* Specifies the cacheable status of the region protected. */
  
 uint8_t
  
 IsBufferable
  
 /* Specifies the bufferable status of the protected region. */
  
 } MPU_Region_InitTypeDef;
  
 Let us analyze the most relevant fields of this struct.
  
 •
  Enable
 : specifies the status of the region, and it can assume the values
  
 MPU_REGION_ENABLE
  and
  
 MPU_REGION_DISABLE
 .
  
 •
  Number
 : it is the region ID and it can spawn from 0 up to 7.
  
 •
  BaseAddress
 : corresponds to the base address of the region. In Cortex-M0+ this address 
 must",NA
21. Flash Memory Management,"Flash memory is a silent peripheral that we use without worrying too much about it. Once 
 we are sure that the flash has sufficient room to store the firmware, we upload the binary 
 image using the debugger or a dedicated flashing tool. And we completely forget it.
  
 However, the internal flash provided by all STM32 microcontrollers works in the same way 
 of other peripherals. It can be programmed directly from the firmware by configuring 
 specific registers, and this allows us to upgrade the firmware using the same on-board code 
 or to store relevant configuration data without using dedicated external hardware (an 
 external I²C EEPROM or an SPI flash).
  
 This chapter shows how to program the internal STM32 flash memory using the dedicated
  
 HAL_FLASH 
 module from the CubeHAL. It describes how the flash is usually organized in a 
 typical STM32 microcontroller, briefly illustrating the differences among each family and 
 the steps involved to program specific areas of this memory directly from the same 
 microcontroller.
  
 Finally, the role of the ART
 TM
 Accelerator is described, together with the evolutions of this 
 ST proprietary technology in STM32F7 microcontrollers.",NA
21.1 Introduction to STM32 Flash Memory,"Different from other embedded architectures
 ¹
 , all STM32 microcontrollers provide a 
 dedicated flash memory to store program code and constant data. There are currently 
 eleven memory sizes, ranging from 16KB up to 2MB. The last digit of the part number of a 
 given STM32 MCU defines the size of the flash memory, as shown in
  Table 1
 . For example, 
 an STM32F401R
 E
  MCU has 512KB of flash memory.
  
 Table 1: The size of the flash memory given the last digit in an STM32 part number
  
 Last digit in P/N
  
 Flash memory size (KB)
  
 4 
  
 6 
  
 8 
  
 B 
  
 Z 
  
 C 
  
 D 
  
 E
  
 16 
  
 32 
  
 64 
  
 12
 8 
  
 19
 2 
  
 25
 6 
  
 38
 4 
  
 51
 2
  
  
 ¹
 This is especially true for Cortex-A microprocessors or FPGAs, where the non-volatile memory is provided by external flash 
 memories connected to the CPU through dedicated bus lines.",NA
21.2 The,NA,NA
 HAL_FLASH,NA,NA
 Module,NA,NA
21.2.1 Flash Memory Unlocking,"The flash memory is write-protected by default, to prevent accidental writings caused by 
 electrical disturbances or program malfunctions. To enable write mode a sequence of 
 operations must be performed, and this is specific of the given STM32 family. To 
 accomplish this task, the CubeHAL provides the function:
  
 HAL_StatusTypeDef
  HAL_FLASH_Unlock
 (
 void
 );
  
 which allows us to completely ignore the specific flash memory architecture. Once the flash 
 memory write/erase protection is disabled, we can perform an erase or write operation. 
 The reverse of the unlock procedure is performed by using the function:
  
 HAL_StatusTypeDef
  HAL_FLASH_Lock
 (
 void
 );
  
 The write protection is automatically set upon a system reset. However, it is strongly 
 suggested to explicitly re-lock the memory when all writing operations are completed. This 
 prevents any accidental writing caused by firmware malfunction or power instability.",NA
21.2.2 Flash Memory Erasing,"Before we can change the content of a flash memory location we need to reset its bits to the 
 default value (“0” or “1” depending on the NOR-flash type). This is performed by an erase 
 operation on sector/page granularity. Alternatively, a mass erase of the whole bank can be 
 performed: this means that on those STM32 MCUs providing two banks we can mass erase 
 each bank at a time.
  
 In the majority of STM32 microcontrollers, the individual cells of a flash memory block 
 (sector or page) are set to “1” after an erase operation, with just two notably exceptions: 
 STM32L0 and STM32L1 microcontrollers, whose default value is instead “0”.
  
 The CubeHAL provides two ways to perform a flash erase operation: flash erasing in
  polling
  
 and 
 interrupt
  mode.
  
 The function:
  
 HAL_StatusTypeDef
  HAL_FLASHEx_Erase
 (FLASH_EraseInitTypeDef
  *
 pEraseInit,
  
 uint32_t
  *
 SectorError);",NA
21.2.3 Flash Memory Programming,"Once a sector/page is erased, we can proceed programming its content. In theory, it is 
 perfect possible to directly access to a flash location to change its content
 ⁶
  writing a C code 
 like the following one:
  
 ...
  
 *
 (
 volatile
  uint16_t
 *
 )
 0x0800AA00 =
  Data;
  
 ...
  
 However, this is basically not convenient for two main reasons. First of all, in some STM32 
 MCUs preliminary operations (like setting specific registers) may be required before we 
 can program a flash location. Secondly, depending on the specific STM32-series and the",NA
21.2.4 Flash Read Access During Programming and Erasing,"A read access to the flash memory while an erase or write operation is ongoing will cause a 
 bus stall, at least in the majority of STM32 microcontrollers
 ⁷
 . This means that if you need to 
 carry out other operations in parallel, you need to relocate in SRAM code to be executed 
 during a flash programming operation. A typical scenario is represented by a custom 
 bootloader: we may program our code so that we exchange the new firmware to flash using 
 the UART in
  interrupt
  or
  DMA
  mode. If this the case, we cannot lose asynchronous events 
 (for example, an interrupt that notifies us a data transfer) because the MCU is stalled 
 waiting for the ongoing operation. If so, it is best to relocate the code in SRAM (and 
 eventually to relocate the
  vector table
  too).",NA
21.3 Option Bytes,"Option bytes
  are two or more bytes whose bits are special configuration values. The concept 
 of 
 option bytes
  is similar to the one found in other microcontroller architectures, like the
  
 fuses
  in the AVR series from Atmel or the
  Configuration Bits
  found in PIC microcontrollers 
 from Microchip.
  
 Each individual bit of these special bytes in the
  Information Block
  region has a special 
 meaning. The number and type of configuration parameters depend on the specific STM32 
 MCU. The most common configuration parameters are related to:",NA
21.3.1 Flash Memory Read Protection,"Read Carefully
  
 Some procedures described in this paragraph may brick your microcontroller 
 preventing you from flashing and erasing it forever. Read carefully the content of this 
 paragraph and avoid performing operations if they are not
  totally clear
 .
  
 One option byte (called
  RDP
 ) deserves a separated paragraph: the configuration byte 
 related to the flash read protection. To avoid unwanted access to the flash memory through 
 the debug interface it is possible to temporarily or
  permanently
  disable the read access to 
 this memory from the external world (clearly, the access from the CPU core and the DMA",NA
21.4 Optional OTP and True-EEPROM Memories,"More recent and powerful STM32 microcontrollers provide an
  One-Time Programmable
  
 (OTP) memory. This is a dedicated memory with a size ranging from 512 up to 1024 bytes 
 with an unique characteristic: once a bit of this memory turns from 1 to 0 is no longer 
 possible to restore it to 1. This means that this region is not erasable. This memory area is 
 especially useful to store relevant configuration parameters connected with the given 
 device, such as serial numbers, MAC address, calibration values and so on. A typical 
 practice in the electronics industry is to produce devices with different functionalities 
 starting from the same PCB or even the same complete board. This area could be also used 
 to store configuration parameters employed by the firmware to adapt board features.
  
 The OTP area is divided into
  N
  OTP data blocks of 32 bytes and one lock OTP block of
  N
  
 bytes. The OTP data and lock blocks cannot be erased. The lock block contains
  N
  bytes
  
 LOCKB
 i
  (0 ≤ i ≤
  N-1
 ) to lock the corresponding OTP data block (blocks 0 to
  N
 ). Each OTP data 
 block can be programmed until the value 0x00 is programmed in the corresponding OTP 
 lock byte (clearly an individual bit already set to 0 cannot be restored to 1). The lock bytes 
 must only contain 0x00 and 0xFF values, otherwise the OTP bytes might not be taken into 
 account correctly.",NA
21.5 Flash Read Latency and the ART™ Accelerator,"In
  Chapter 1
  we have seen that Cortex-M cores provide an
  n-stage
 ⁸
  instruction pipeline
  
 designed to boost the program execution. However, that pipeline has to be filled with 
 machine instructions",NA
21.5.1 The Role of the TCM Memories in STM32F7 MCUs,"The memory organization of more recent and powerful STM32F7 MCUs deserves a 
 separate mention. In fact, this family of microcontrollers faces a more complex and flexible 
 memory and bus organization, offering two distinct interfaces to access flash and SRAM 
 memories: the
  Advanced eXtensible Interface
  (AXI), which is an ARM bus specification that 
 interconnects the CPU core to the other peripherals; the
  Tightly-Coupled Memory
  (TCM) 
 interface which interconnects the CPU core to volatile and non-volatile memories directly 
 coupled with it. Both the interfaces, AXI and TCM, face a Harvard architecture, providing 
 separated lines for instructions (
 I-Bus
 ) and data (
 D-Bus
 ).
  
 Looking at
  Figure 3
 ¹⁰
 , you can see that the Cortex-M7 core has three distinct paths to 
 access the flash controller (and so the flash memory). Before we describe these three paths, 
 it is important to note a fundamental thing: the Cortex-M7 core already provides an 
 integrated L1-cache. This cache has two dedicated cache pools, each one 64KB wide, one 
 dedicated to the
  I-Bus
  and one for the 
 D-Bus
 : this differs from other STM32 families, where 
 data and instruction caches are implemented exclusively inside the ART
 TM
 Accelerator.
  
  
 Figure 3: How the flash memory is accessed in an STM32F7 MCU
  
 In all STM32F7 MCUs, flash memory is accessible through three main interfaces for read 
 and/or write accesses: *
  A 64-bit ITCM interface
 : it connects the embedded flash memory 
 to the Cortex-M7 via the ITCM bus (Path 1 in
  Figure 3
 ) and it is used for the program 
 execution and data read access for literal values.
  The write access to the flash memory is 
 not permitted via this bus
 . The flash memory is accessible by the CPU through ITCM 
 starting from the address
  0x0020 0000
 . Being the embedded flash memory slower than the 
 CPU core, the ART
 TM
 Accelerator allows
  0-wait
  execution from the flash memory at a CPU 
 frequency up to 216MHz. The STM32F7 ART
 TM 
 Accelerator is available only for a flash 
 memory access on the ITCM interface. It implements an unified instruction and branch 
 cache of 256 bits x 64 lines in the STM32F74xxx and STM32F75xxx and 128/256 bits x 64 
 lines in the STM32F76xxx and STM32F77xxx devices following the bank",NA
22. Booting Process,"In
  Chapter 20
  we have seen that the handler of the
  Reset
  exception corresponds to the first 
 routine to be executed when the CPU starts. The fixed memory layout model of Cortex-M 
 based processors establishes that the address in memory of
  Reset
  exception handler is 
 placed just after the
  Main Stack Pointer
  (MSP), that is at the address
  0x0000 0004
 . This 
 memory location usually corresponds to the beginning of flash memory. However, silicon 
 vendors can bypass this limitation by “aliasing” other memories to the
  0x0000 0000
  address 
 with an operation called
  physical remapping
 . This operation is performed in hardware after 
 few clock cycles, and it is different from the
  vector table
  relocation seen in
  Chapter 20
 , 
 which is performed by the same code running on the MCU.
  
 Moreover, the STM32 platform provides a factory pre-programmed boot loader, which can 
 be used to load the firmware inside the flash memory from several sources. Depending on 
 the STM32 family and sales type used, an STM32 MCU can load the code using USART, USB, 
 CAN, I²C and SPI communication peripherals. The bootloader is selected thanks to specific 
 boot pins.
  
 This chapter completes the
  Chapter 20
  by showing the booting process performed by 
 STM32 microcontrollers after a system reset. It gives a detailed description of the steps 
 involved during the bootstrap and it briefly shows how to use the factory pre-programmed 
 bootloader in all STM32 MCUs. Finally, a custom bootloader is also shown, which allows to 
 upgrade the on-board firmware using the USART interface and a custom upload procedure.",NA
22.1 The Cortex-M Unified Memory Layout and the ,NA,NA
Booting Process,"Different from more advanced microprocessor architectures, like the ARM Cortex-A, 
 Cortex-M microcontrollers do not provide a
  Memory Management Unit
  (MMU), which 
 allows to alias logical addresses to actual physical addresses. This means that, from the 
 Cortex-M core point of view, the memory map is fixed and standardized among all 
 implementations.
  
 In Cortex-M based microcontrollers, the code area starts from the
  0x0000 0000
  address 
 (accessed through the
  I-Bus
 /
 D-Bus
 ¹
  buses in Cortex-M3/4/7 and through the
  S-Bus
  in 
 Cortex-M0/0+) while the data area (SRAM) starts from address
  0x2000 0000
  (accessed 
 through the
  S-Bus
 ). Cortex-M CPUs always fetch the
  vector table
  from the
  I-Bus
 , which 
 implies that they only boot from the code area (which typically correspond to flash 
 memory).",NA
22.1.1 Software,NA,NA
 Physical Remap,"Once the MCU boots up, that is the
  Reset
  exception is being executed, it is still possible to 
 remap the memory accessible through the code area (that is through
  I-Bus
  and
  D-Bus
  lines) 
 by programming some bits of the SYSCFG
  memory mapped register
  (
 SYSCFG->MEMRMP
  in the 
 CMSIS library).
  
 Depending on the specific STM32 MCU, the following memories can be remapped:
  
 ²
 Depending on the package used, in some STM32 MCUs the BOOT1 pin is absent and it is replaced by a special bit, called 
 nBOOT1, inside the
  option bytes
  region. Consult the reference manual for your MCU for more about this. In some other STM32 
 families, like the STM32F7, the functionality of the BOOT1 pin is completely replaced by two dedicated option bytes. Finally, in 
 those MCUs providing two boot pins, BOOT0 is most of the times a dedicated pin used exclusively to select boot origin, while BOOT1",NA
22.1.2 Vector Table Relocation,"In
  Chapter 20
  we have seen how to relocate the
  vector table
  in CCM memory so that we can 
 take advantage of this core-coupled memory. When we perform
  physical remapping
 , either 
 setting the BOOT pins or configuring the
  SYSCFG->MEMRMP
  register accordingly, there is no 
 need to perform 
 vector table
  relocation since the MCU automatically aliases the starting 
 address of the selected memory to
  0x0000 0000
 . Sometimes, however, we want to move the
  
 vector table
  in other memory locations that do not correspond to its origin. For example, 
 we may want to store two independent firmware images inside the flash memory (see
  
 Figure 1
 ) and to select one of these according a given initial condition. This is the case of
  
 bootloaders
 , special “system” programs that carry out important configuration tasks such 
 as upgrading the main firmware, as we will see later in this chapter.
  
 The
  Vector Table Offset Register
  (VTOR) is a register in the
  System Control Block
  (SCB) (
 SCB-
 >VTOR 
 in the CMSIS library) that allows to setup the base address of the
  vector table
 . Once 
 the content of this register is set, the CPU will treat the addresses starting from the new 
 base location as pointers to interrupt service routines.
  
 ³
 It is important to clarify that the CPU will not restart a reset sequence, invoking the handler of the
  Reset
  exception, once the 
 memory has been remapped using the
  SYSCFG->MEMRMP
  register. It will be your responsibility to invoke that exception handler, and 
 to ensure that the CPU is placed to the initial conditions that the target firmware expects to find (e.g. all peripherals disabled, and so 
 on).",NA
22.1.3 Running the Firmware From SRAM Using the GNU MCU ,NA,NA
Eclipse Toolchain,"Sometimes, it can be useful to load the binary firmware inside the SRAM and to boot from 
 it. This requires a special support of the debugger, and the following steps:
  
 1. BOOT pins (or the corresponding bit in the
  option bytes
  region) must be configured so 
 that the 
  
 MCU boots from SRAM (both pins connected to VDD in the most of STM32 
 MCUs).
  
 2. The linker script must be modified so that the FLASH region is mapped to the starting 
 address 
 0x0000 0000
  (or to the
  0x2000 0000
  address, which correspond to the same 
 memory if the SRAM is selected as boot origin).
  
 3. OpenOCD must be properly instructed to set the initial value for the program counter 
 to the 
  
 origin of SRAM address, plus 4 bytes.
  
 The first step can be easily accomplished in Nucleo boards by connecting both BOOT0 pin 
 (which corresponds to the pin 7 in the CN7 morpho connector) and BOOT1 pin (that is PB2 
 pin in almost all STM32 MCUs with LQFP-48 package, and which corresponds to the pin 22 
 in the CN10 morpho connector) to VDD, as shown in
  Figure 3
 .
  
 The second step can be usually limited to modifying the origin of the FLASH memory inside 
 the linker script (the file
  mem.ld
  in the GNU MCU Eclipse tool-chain), setting its origin to 
 the
  0x0000 0000
  (or the
  0x2000 0000
  address which also corresponds to the SRAM memory). If 
 this procedure sounds new to you, you have to study Chapter 19 better.
  
 Finally, we need to instruct OpenOCD so that it sets the
  Program Counter
  (PC) to the base 
 address of SRAM memory. This can be simply accomplished by modifying the debug 
 configuration for our project, going inside the
  Startup
  section, and then
  checking
  the
  
 Debug from RAM
  entry and 
 unchecking
  the
  Pre-run/Restart reset
 . These settings will 
 also cause that the firmware is uploaded again in SRAM every time we reset the MCU from 
 the IDE (obviously, if we reset the board by using the dedicated hardware button on the 
 Nucleo, the code is lost or, at least, it may be corrupted).
  
  
 Before filing a support request to this author, because this procedure may not to 
 work in your case, take in account that this procedure may not work for those of you 
 having Nucleo boards based on STM32 MCUs with few SRAM memory. This because 
 it could happen that
  
 the code area falls through the stack area. This procedure essentially works for really 
 small and limited programs.",NA
22.2 Integrated Bootloader,"In modern digital electronics it is almost impossible to distribute electronic devices without 
 releasing successive upgrades of the firmware. And this is especially true for complex 
 boards with a lot of integrated circuits and peripherals. Soon or later, all embedded 
 developers will need a way to distribute a firmware upgrade and, most important, they will 
 need a way to let customers uploading it on the MCU without a dedicated (and sometimes 
 expensive) debugger. Moreover, often the SWD debug port is not added to the final PCB for 
 a design choice.
 ⁴
 .
  
 A
  bootloader
  is a piece of software, usually executed first when the MCU boots, which has 
 the ability to upgrade the firmware inside the internal flash. This operation is also known 
 as
  In-Application Programming
  (IAP), which is distinct from the MCU programming using 
 an external and dedicated debugger: this other way to program MCUs is also known as
  In-
 System Programming
  (ISP).
  
 Bootloaders are usually designed so that they accept commands through a communication 
 periph-eral (USART, USB, Ethernet and so on), which is used to exchange the firmware 
 binary with the MCU. A dedicated program, designed to run on an external PC, is usually 
 also needed.
  
 All STM32 MCUs come from the factory with a pre-programmed bootloader in a ROM 
 memory, called
  System memory
 , which is mapped inside the address range
  0x1FFF 0000
  -
  
 0x1FFF 77FF
  in the majority of STM32 microcontrollers
 ⁵
 . Depending on the MCU family and 
 package used, this bootloader can interact with the outside world using:
  
  
 ⁴
 For those of you wondering how to upload the firmware on a board without the debug port, and without using the integrated 
 bootloader, it could be useful to know that ST can ship to you MCUs with your firmware already pre-programmed during MCU",NA
22.2.1 Starting the Bootloader From the On-Board Firmware,"The execution of the integrated bootloader is connected to the status of BOOT pins, which 
 are sampled during the first clock cycles. However, for several design choices, you may not 
 be able to configure BOOT pins as required. For this reason, you can “jump” to the
  System 
 memory
  from the firmware (for example, the user may be forced to press a hidden switch).",NA
22.2.2 The Booting Sequence in the GNU MCU Eclipse Tool-chain,"Now that the booting process is clear, we can analyze a really fundamental topic: what are 
 the exact steps performed during boot by an application developed with the GNU MCU 
 Eclipse tool-chain? The answer is not trivial, and there are several important things an 
 experienced programmer working with this tool-chain must know.
  
 In Chapter 19 we have deeply analyzed the way a
  Reset
  exception works. However, 
 examples made in that chapter are insulated from the real tool-chain: we have developed a 
 minimal STM32 application that does not use either the CubeHAL nor the startup files from 
 GNU MCU Eclipse tool-chain. So, to understand the actual boot sequence, we have to start 
 from the beginning: the
  Reset
  exception.
  
 In Chapter 7 we have seen that the assembly file
  system/src/cmsis/startup_stm32xxxx.S
  
 contains the definition of the
  vector table
 . This files is provided by ST and it is specific for 
 the given STM32 MCU. Opening the one fitting your MCU, you can find the definition of the
  
 Reset_Handler
 , about at line 76.",NA
22.3 Developing a Custom Bootloader,"Read Carefully
  
 The bootloader described in this paragraph works correctly if and only if the ST-
 LINK interface has a firmware version equal or higher than 2.27.15. Older releases 
 have a bug on the VCP preventing the USART interface to work as expected. Ensure 
 that your Nucleo is updated.
  
 Integrated bootloaders work well in a lot of cases. Many real projects can benefit from their 
 usage. Moreover, the free-of-charge tools provided by ST can reduce the effort needed to 
 develop custom applications that upload the firmware on the MCU. However, for some 
 applications you may need additional functionalities not implemented in standard 
 bootloaders. For example, we may want to encrypt the distributed firmware so that only 
 the on-board bootloader is able to decode it using a pre-shared key hardcoded inside the 
 bootloader code.
  
 We are now going to develop a custom bootloader that will allow us to upload a new 
 firmware on the target MCU. This will essentially provide only a fraction of the features 
 implemented by integrated bootloaders, but it will give us the opportunity to review the 
 fundamental steps needed to develop a custom bootloader. It will provide the following 
 functionalities:
  
 • Upload a new firmware using the UART interface (in our case, the UART2 interface 
 provided 
  
 by all Nucleo boards).
  
 • Retrieve the MCU type.
  
 • Erase a given amount of flash sectors/pages.
  
 • Write a series of bytes starting from a given address.
  
 • Encrypt/Decrypt the exchanged firmware using AES-128 algorithm
 ¹⁴
 .
  
 ¹⁴
 As far as I know, ST provides on request a custom bootloader that implements firmware encryption, in the same way other 
 silicon manufacturers do. However, I am almost sure that you have to compile and sign a lot of license agreements, and probably",NA
22.3.1,NA,NA
 Vector Table,NA,NA
 Relocation in STM32F0 Microcontrollers,"So far, we have seen that in Cortex-M0 based microcontrollers it is not possible to relocate 
 the
  vector table
  as it happens in Cortex-M0+/3/4/7 MCUs. This means that we cannot use",NA
22.3.2 How to Use the,flasher.py,NA
 Tool,"As said before, you can find a Python script named
  flasher.py
  inside the book source files for 
 this chapter. This tool simply allows to upload to the MCU a firmware generated using the 
 Intel HEX binary format, a specification for binary files developed by Intel several years ago 
 and still",NA
23. Running FreeRTOS,"Taking full-advantage of the computing power offered by 32-bit microcontrollers is not 
 easy, especially for powerful STM32F2/F4/F7 series. Unless our device needs to perform 
 really simple tasks, the correct allocation of computing resources requires special care 
 during the firmware development. Moreover, the use of improper synchronization 
 structures and poor-designed interrupt service routines could lead to the loss of important 
 asynchronous events and to overall unpredictable behaviour of our device.
  
 Real Time Operating Systems
  (RTOS) take advantage of the exceptions system provided by 
 Cortex-M cores to bring to programmers the notion of
  thread
 ¹
 , an independent execution 
 stream which“contends” the MCU with other threads involved in concurrent activities. 
 Moreover, they offer advanced synchronization primitives, which allow both to coordinate 
 the simultaneous access to physical resources from different threads and to avoid wasting 
 CPU cycles while waiting for slower and asynchronous events.
  
 The market segment of RTOSes is quite crowded nowadays, with several commercial as 
 well as free and open source solutions available to programmers. Being the Cortex-M a 
 standardized architectures among a lot of silicon manufacturers, STM32 developers can 
 choose from a really wide portfolio of RTOS systems, depending their need of complexity 
 handling and dedicated (and maybe commercial) support. ST Microelectronics has adopted 
 one popular free and Open Source OS as its official tool for the CubeHAL framework: 
 FreeRTOS.
  
 According some statistics, FreeRTOS is the most widespread RTOS on the market today. 
 Thanks to its dual license that allows the selling of commercial products without any 
 restriction
 ²
 , FreeRTOS has become a sort of standard in the electronics industry, and it is 
 also widely adopted by the Open Source community. Although it does not represent the 
 only solution available for the STM32 platform, in this book we will focus our attention 
 exclusively on this OS, since it is what ST officially supports and integrates in the CubeHAL.
  
 ¹
 Some RTOSes, like FreeRTOS, use the term
  task
  to indicate an independent execution stream contending the CPU with other 
 tasks. However, this author considers this terminology not appropriate. Traditionally, in general purpose Operating Systems,
  
 multitasking
  is a method by which multiple tasks, also known as
  processes
 , share common hardware resources (mainly the CPU and 
 the RAM). With a multitasking OS, such as Linux, you can simultaneously run multiple applications. Multitasking refers to the ability 
 of the OS to quickly switch between each computing task to give the impression that different applications are executing multiple 
 actions simultaneously. A process has one relevant characteristic: its memory space is physically insulated from other processes, 
 thanks to features offered by the
  Memory Management Unit 
 (MMU) inside the CPU.
  Multithreading
  extends the idea of multitasking 
 into single processes, so that you can subdivide specific operations within a single application into individual
  threads
 . Each thread 
 could run in parallel. The important trait of threads it that they share the same memory address space. True embedded 
 architectures, like the STM32 are, do not provide a MMU (only a features-limited
  Memory Protection Unit
  - MPU - is available in 
 some of them). The absence of this unit does not allow to have separated address spaces, since it is impossible to alias physical 
 addresses to logical ones. This means that they can carry out just one single application, which can be eventually split in several 
 threads sharing the same memory address space. For this reason, we will talk about
  threads
  in this book, even if sometimes we will 
 use the word “task” when talking about some FreeRTOS APIs or to indicate an activity of the firmware in general terms.
  
 ²
 FreeRTOS is licensed under a modified GPL 2.0 license, which allows companies to sell their devices based on FreeRTOS 
 without any restriction, unless they do not modify the FreeRTOS code and do not sell/distribute the derived firmware. If this the 
 case, they also need to distribute the FreeRTOS source code, while leaving their source code closed if they want. For more 
 information about FreeRTOS licensing model,
  see this page on the official web site
 (http://www.freertos.org/a00114.html).",NA
23.1 Understanding the Concepts Underlying an RTOS,"This paragraph gives a quick introduction to the main concepts underlying real-time 
 Operating Systems. Experienced users can safely skip it.
  
 Except for the ISRs and exception handlers, all the examples built so far are designed so 
 that our applications are composed by just one execution stream. Typically, starting from 
 the
  main()
  routine, a large and infinite
  while
  loop carries out firmware tasks:
  
 ...
  
 while
 (
 1
 ) {
  
 doOperation1();
  
 doOperation2();
  
 ...
  
 doOperationN();
  
 }
  
 The time spent by each
  doOperationX()
  is broadly estimated by the developer, who has the 
 responsibility to avoid that one of those functions sticks for too much time, preventing 
 other parts of the firmware from running correctly. Moreover, the calling order of the 
 functions also
  schedules 
 their execution, defining the sequence of operation performed by 
 the firmware. This, indeed, is a form of
  cooperative scheduling
 ³
 , where each function 
 concurs to the execution of the next activity by voluntarily releasing the control 
 periodically.
  
 In this early form of multiprogramming, there is no guarantee that a function cannot 
 monopolize the CPU. The application designer carefully needs to ensure that every function 
 should be carried out in the shortest possible time. In this execution model, an “innocent”
  
 busy loop
  can have dramatic effects. Let us consider the following pseudo-code:
  
 ³
 Experienced user will point out that it is not correct to talk about
  cooperative scheduling
  in this context for two fundamental 
 reasons: the execution order of tasks is fixed (the “schedule” is computed by the programmer during the firmware development) 
 and each routine is not able to save its execution context before leaving, that is the stack frame of the
  doOperationX()
  routine is 
 destroyed when it returns. As we will see in a while,
  co-routine
  are a generalization of subroutines in
  non-preemptive multitasking
  
 systems.",NA
23.2 Introduction to FreeRTOS and CMSIS-RTOS ,NA,NA
Wrapper,"As said at the beginning of this chapter, FreeRTOS is the OS chosen by ST as official RTOS 
 for its Cube distribution. Recent releases of CubeMX offer a good support to this OS, and 
 including it as 
 middleware
  component in a project is really easy. A lot of additional modules 
 of the CubeHAL (like the LwIP stack) rely on the services provided by it.
  
 However, ST did not limit its integration in shipping FreeRTOS in its CubeHAL distribution. 
 It has built a complete CMSIS-RTOS wrapper over it, allowing to develop CMSIS-RTOS 
 compliant",NA
23.2.1 The FreeRTOS Source Tree,"FreeRTOS source code is organized in a compact source tree, which spreads over a dozen of 
 files. The
  Figure 4
  shows how FreeRTOS is organized inside the CubeHAL
 ¹³
 . The files
  .c
  
 found in the root folder contain the main OS features (for example, the file
  tasks.c
  contains 
 all those routines related to the thread management). The sub-folder
  include
  contains 
 several include files used to define the most of C
  struct
  and macros used by the OS. The most 
 relevant of these files is the 
 FreeRTOSConfig.h
  one, which includes all the user-defined macros 
 used to configure the RTOS according user’s needs. The other sub-folder contained in the 
 root tree is
  portable
 . FreeRTOS is designed to run on about 30 different hardware 
 architectures and compilers, while ensuring the same consistent API. All platform-specific 
 features are organized inside two files
 ¹⁴
 ,
  port.c
  and 
 portmarco.h
 , which are in turn collected in 
 the 
 sub-folder 
 specific 
 of 
 the 
 given 
 architecture. 
 For 
 example, 
 the 
 folder
  
 portable/GCC/ARM_CMO
  contains
  port.c
  and
  portmarco.h
  files providing the code specific for the 
 Cortex-M0/0+ architecture and the GCC compiler.
  
 Finally, the
  CMSIS-RTOS
  folder contains the CMSIS-RTOS compliant layer developed by ST on 
 the top of FreeRTOS.
  
  
 Figure 4: The FreeRTOS source tree organization in the CubeHAL
  
 The next two paragraphs show how to import the FreeRTOS distribution inside an Eclipse 
 project, either manually or using the CubeMXImporter tool.
  
 ¹³
 FreeRTOS is available in all CubeHALs, inside the
  Middleware/Third_Party/Source
  folder.
  
 ¹⁴
 This part of FreeRTOS is considered separated from the core FreeRTOS source three, and it is said to implement the
  port layer
  
 of FreeRTOS.",NA
23.3 Thread Management,"Once we have configured the Eclipse project, we can start coding using the CMSIS-RTOS 
 layer and hence FreeRTOS.
  
 At the base of all RTOSes there is the notion of thread, which we have analyzed in the first 
 paragraph of this chapter. A thread is nothing more than a C function, which FreeRTOS 
 requires to be defined in the following way:",NA
23.3.1 Thread States,"In FreeRTOS a thread can have two major execution states:
  running
  and
  not running
 . On a 
 single-core architecture, just one thread at once can be in
  running
  state.
  
 In FreeRTOS the
  not running
  state is characterized by several sub-states, as shown in
  
 Figure 10
 . A
  not running
  thread can be
  ready
  (this is also the state of new threads), that is 
 it is ready to be scheduled for execution by the RTOS kernel.
  
 A
  running
  thread can voluntary suspend its execution, by calling the
  osThreadSuspend()
  
 function, which accepts the TID of the thread to suspend or
  NULL
  if called by the same 
 thread. In this case the thread assumes the
  suspended
 ²⁰
  state. To resume a
  suspended
  
 thread the
  osThreadResume()
  is used.
  
 ²⁰
 In FreeRTOS this state is called
  stopped
 , as shown in
  Figure 10
 .",NA
23.3.2 Thread Priorities and Scheduling Policies,"In the first example we have seen that each thread has a priority. But which practical effects 
 have priorities on threads execution? Priorities impact on the scheduling algorithm, 
 allowing to alter the execution order in case a thread with a higher priority turns in
  ready
  
 state. Priorities are a fundamental aspect of RTOSes, and provide the foundation blocks to 
 achieve short responses to deadlines.
  It is important to underline that thread priority is 
 not related to the priority of IRQs
 .
  
 Imagine you are designing the control board of a machine that could potentially cause 
 injuries to workers in critical situations. Usually, this type of machines has an emergency 
 stop button. That button could be connected to one pin of the MCU, and the corresponding 
 interrupt may resume a blocked thread waiting for this event. This thread may be designed 
 to shutdown an engine, or something like that, and to place the machine in a safe state.
  
 Once the IRQ fires, the task running at that moment is formally
  running
  but it is not 
 effectively running on the CPU, which is servicing the ISR. By invoking proper OS routines, 
 that we will see later, the OS places our emergency thread in
  ready
  mode, but we have to be 
 sure that it will be the first thread to be executed. Priorities allow to programmers to 
 distinguish deferrable activities from not-deferrable ones.",NA
23.3.3 Voluntary Release of the Control,"A
  running
  thread can release the control (it is said to
  yield
  the control), if the programmer 
 knows that it is useless to consume CPU cycles, by calling the function",NA
23.3.4 The,NA,NA
 idle,NA,NA
 Thread,"A CPU never stops, unless we enter one of the low-power modes offered by STM32 
 microcontrollers. This means that, if all threads in a system are
  blocked
  or
  stopped
  waiting 
 for external events, then we need a way to “do something” while waiting for other threads 
 becoming active again. For this reason, all Operative Systems provide a special tasks named
  
 idle
 , which is scheduled during system inactive states, and its priority is defined as the 
 lowest possible. For this reason, it is common to say that the lowest priority corresponds to 
 the
  idle priority
 .
  
 In FreeRTOS versions prior to version 9, whenever a thread was deleted, the memory 
 allocated by FreeRTOS to the thread was freed by the
  idle
  thread. In FreeRTOS version 9, if 
 one thread deletes another thread, then the memory allocated by FreeRTOS to the deleted 
 thread is freed immediately. However, if a thread deletes itself, then the memory allocated 
 by FreeRTOS to the thread is still freed by the
  idle
  thread. Note that, in all cases, it is only 
 the stack and task control block (TCB) allocated to the thread by the RTOS that get freed 
 automatically.
  
 The
  idle
  thread also plays an important role in
  low-power
  designs, as we will discover
  later 
 in this chapter
 .",NA
23.4 Memory Allocation and Management,"In the two previous examples we started using FreeRTOS without dealing too much with 
 the memory allocation for threads and the other structures used by the OS. The only 
 exception is represented by the last parameter passed to the
  osThreadDef()
  macro, which 
 corresponds to the amount of stack to reserve to the thread. FreeRTOS, however, not only",NA
23.4.1 Dynamic Memory Allocation Model,"FreeRTOS implements a dynamic memory allocation model, which uses regions of the 
 SRAM to allocate all OS internal structures, including TCBs. When compared to static 
 allocation model, the dynamic one has some non-negligible advantages:
  
 • The memory allocation occurs automatically, within the RTOS API functions.
  
 • Developers do not need to concern with allocating memory themselves.
  
 • The RAM used by an RTOS object can be re-used if the object is deleted, potentially 
 reducing 
  
 the application’s maximum RAM footprint.
  
 • RTOS API functions are provided to return information on heap usage, allowing the 
 heap size 
  
 to be optimized.
  
 • FreeRTOS provides five dynamic memory allocation schemes, and they can be chosen 
 to best 
  
 suite the application requirements.
  
 • Fewer function parameters are required when an object is created.
  
 FreeRTOS does not make use of the classical
  malloc()
  and
  free()
  functions provided by the C 
 run-time
  library
 ²³
 , because:
  
 1. they uses a lot of code space, increasing the size of the firmware; 
  
 2. they are not designed to be thread safe; 
  
 3. they are not deterministic (the amount of time taken to execute the function will differ 
 from 
  
 call to call).
  
 ²³
 With one notably exception represented by the
  heap_3.c
  allocator, as we will see soon.",NA
23.4.2 Static Memory Allocation Model,"Starting from FreeRTOS 9.x, it is possible to enable a full-static memory allocation model. 
 This means that we are totally responsible of the correct allocation of memory pools 
 needed by the OS to carry our its activities. Statically allocated RAM provides developers 
 some important advantages:
  
 • OS structures can be placed at specific memory locations. This constitutes an 
 important advantage for those STM32 microcontrollers having CCM memory or other 
 cached SRAM memories.
  
 • The maximum RAM footprint can be determined at link time, rather than at run-time.• 
 Developers do not need to concern themselves with graceful handling of memory 
 allocation 
  
 failures.
  
 • It allows the OS to be used in applications that simply do not allow any dynamic 
 memory allocation (although FreeRTOS includes allocation schemes that can 
 overcome most objections, as we will see later).
  
 The 
 static 
 memory 
 allocation 
 model 
 is 
 enabled 
 by 
 setting 
 the
  
 configSUPPORT_STATIC_ALLOCATION 
 macro to
  1
  and it affects all the APIs used to define 
 FreeRTOS objects. For example, the function corresponding to
  osThreadDef()
  when using the 
 static allocation model is
  osThreadStaticDef()
 . When using static allocation we must provide to 
 FreeRTOS the memory areas where to store objects by pre-allocating it. For example, when 
 creating a new thread we need to supply the area of memory containing the single TCP plus 
 the stack used by the thread.
  
 ...
  
 osThreadId threadID;
  
 uint32_t
  threadStack[
  128
  ];
  
 osStaticThreadDef_t threadTCB;
  
 osThreadStaticDef(tid, ThreadFunc, osPriorityNormal,
  0
 ,
  128
 , threadStack,
  &
 threadTCB);
  
 threadID
  =
  osThreadCreate(osThread(tid),
  NULL
 );",NA
23.4.3 Memory Pools,"The CMSIS-RTOS specification provides the notion of memory pools, and the layer 
 developed by ST on the top of the FreeRTOS OS implements them
 ²⁶
 .
  Memory pools
  are 
 fixed-size blocks of dynamic-allocated memory, implemented so that they are thread-safe. 
 This allows them to be accessed from threads and ISRs alike. Memory pool are 
 implemented by ST using the
  pvPortMalloc() 
 and
  vPortFree()
  routines, and hence the effective 
 memory allocation is demanded to one of the 
 heap_x.c
  allocators. Memory pools are an 
 optional feature, which we need to enable by setting the 
 osFeature_Pool
  macro to 1 in the
  
 cmsis_os.h
  file.
  
 A memory pool is defined by the following C
  struct
 :",NA
23.4.4 Stack Overflow Detection,"Before we talk about the features offered by FreeRTOS to detect stack overflows, we should 
 spend some words about how to compute the right amount of memory a thread needs.
  
 Unfortunately, it is not easy to give a definite answer, because it depends on a quite long list 
 of aspects to keep in mind. First of all, stack size is affected by how deep is the call stack, 
 that is by the number of functions called by our thread, and by the room occupied by each 
 one of them. This space is essentially composed by local variables and passed parameters. 
 Another relevant factors are the processor architecture, the compiler used and the 
 optimization level chosen.
  
 Usually the stack size of a thread is computed experimentally, and FreeRTOS offers a way 
 to try to detect stack overflows. Read my leaps:
  to try
  to detect. Because stack overflow 
 detection is one of the most hard aspect of debugging, as well as static analysis of program 
 code.
  
 FreeRTOS offers two ways to detect stack overflows. The first one consists in using the 
 function:
  
 UBaseType_t
  uxTaskGetStackHighWaterMark
 ( TaskHandle_t xTask );
  
 which returns the number of “unused” words of the thread stack. For example, assume a 
 thread defined with a stack of 100 words (that is, 400 bytes on an STM32). Suppose that, in 
 the 
 worst 
 scenario, 
 the 
 thread 
 uses 
 90 
 words 
 of 
 its 
 stack. 
 Then 
 the
  
 uxTaskGetStackHighWaterMark()
  returns the value 10.
  
 The
  TaskHandle_t
  type of the parameter
  xTask
  is nothing more than the
  osThreadId
  returned by 
 the
  osThreadCreate()
  function, and if we call the
  uxTaskGetStackHighWaterMark()
  from the same 
 thread we can pass
  NULL
 .
  
 This function is available only if:",NA
23.5 Synchronization Primitives,"In a multi-threaded application, soon or later threads need a way to synchronize 
 themselves, both while accessing to shared resources and when transmitting data between 
 several execution streams. The literature about concurrent programming is full of 
 algorithms and data structures best suited as synchronization primitives. The CMSIS-OS 
 API, and the underlying FreeRTOS OS, defines those primitives that are common to all 
 Operating Systems and threading libraries. This paragraph briefly introduces the most 
 relevant ones.",NA
23.5.1 Message Queues,"A
  queue
 ²⁷
  is a
  First-In-First-Out
  (FIFO) collection, which is implemented in FreeRTOS with a 
 linear data structure where the first added element will be the first to be removed. When 
 an element is added to the queue is said to be
  enqueued
 , while when it is removed is said to 
 be
  dequeued
 .
  
 Queues are widely used in concurrent programming, especially when data need to be 
 exchanged between several threads that have different response time to events. For 
 example, often we have two threads, one acting as
  producer
  and one as
  consumer
 , sharing a 
 common buffer. The producer’s job is to generate a piece of data, put it into the buffer and 
 start again. At the same time, the consumer job consists in removing it from the buffer one 
 piece at a time. The problem is to make sure that the producer will not try to add data into 
 the buffer if it is full and that the consumer will not try to remove data from an empty 
 buffer. In an RTOS, queues are designed so that if a thread tries to add data in full queue, it 
 can be placed in blocked mode until at least one element is removed from the queue. At the 
 same time, the OS kernel places the consumer in blocking mode if no data is available in the 
 queue). Being handled from the OS, queues are designed so that no race conditions can 
 occur between different threads (unless the programmer introduces evident errors in its 
 code).
  
 Queues are an optional data structure in the CMSIS-RTOS layer, which must be enabled by 
 setting the
  osFeature_MessageQ
  to 1 in
  cmsis_os.h
  file. A queue is defined by the following C
  
 struct
 :",NA
23.5.2 Semaphores,"In concurrent programming, a
  semaphore
  is a datatype used to control the access, by 
 multiple execution streams, to a common resource. A really simple form of semaphore is 
 represented by a boolean variable: the state of the variable is used as a condition to control 
 the access to a resource. For example, if the variable is equal to
  False
 , then a thread is placed 
 in the blocked state until that variable becomes
  True
  again. A semaphore is said
  to be taken
  
 from the thread that acquires it, that is the thread that firstly finds the semaphore equal to
  
 True
 . This is indeed a
  binary semaphore
 , since it can assume only two states, and in 
 FreeRTOS is implemented as a queue with just one element. If the queue is empty, then the 
 first thread that tries to acquire it places a “flag” value in the queue, and it continues its 
 execution; other threads will not be able to add other “flags” until the thread that has 
 acquired the semaphore does not dequeue its flag.
  
 A more general form of semaphore is the
  counting semaphore
 , which allows more than one 
 threads to acquire it. Just as binary semaphores are implemented as queues that have a 
 length of one, a counting semaphore can be thought as queues that have a length more than 
 one. A counting semaphore usually has an initial value, which is decremented every time a 
 thread acquires it. While binary semaphores are usually used to discipline the concurrent 
 access to just one resource, a counting semaphore can be used to:
  
 •
  discipline the access to pools of common resources
 : in this case the count value 
 indicates 
  
 the number of available resources;
  
 •
  count the number of recurring events
 : in this case an execution stream (for 
 simplicity assume 
  
 that it is an ISR) will release a semaphore (causing that its 
 counter increases) to signal to 
  
 another thread that a given event is occurred (e.g. a data 
 coming from the UART is ready 
  
 to be processed); this threads can then take the 
 semaphore and start performing its activities; if 
  
 another “event” takes place (new 
 data arrived), then the ISR will increase again the semaphore 
  
 by releasing it; in 
 this way the processing thread will be able to take again the semaphore and 
  
 perform its activities.
  
 However, a simple variable cannot be used as a semaphore, since there is no guarantee that 
 the operation of “taking” a semaphore is carried out in an atomic manner. So to acquire a 
 semaphore we need the intervention of a “third party”, that is the OS kernel, which 
 suspends the execution of other threads during the acquisition process.
  
 FreeRTOS provides two distinct APIs to manage binary and counting semaphores, while the 
 CMSIS-RTOS specifies that semaphores are implemented as counting semaphore (leaving 
 to the mutexes the role of binary semaphores). However, the usage of counting semaphores 
 increases the FreeRTOS codebase, which may have a dramatic impact on microcontrollers",NA
23.5.3 Thread Signals,"The example 4 could be rearranged to use a feature more suitable for this kind of 
 applications: the 
 signals
 . Signals are used to trigger execution states between threads or 
 between ISRs and threads. The signal management functions in CMSIS-RTOS allow you to 
 control or wait for signal flags. Each thread has up to 31 assigned signal flags. However, the 
 actual maximum number of signal flags is defined in the
  cmsis_os.h
  file by the macro
  
 osFeature_Signals
 . In FreeRTOS signals are called
  task notifications
  and they are an optional 
 feature available if the macro
  config_USE_TASK_-NOTIFICATIONS
  inside the
  FreeRTOSConfig.h
  file is 
 set and equal to 1.
  
 Signals have their benefits and drawbacks: they are faster than semaphores and need less 
 RAM, but they cannot be used to exchange data between threads and they cannot be used 
 to trigger multiple threads at once.
  
 If we want to trigger a thread signal, we have to set it using the function
  
 int32_t
  osSignalSet
 (osThreadId thread_id,
  int32_t
  signals);
  
 where the parameter
  thread_id
  is clearly the thread id and
  signal
  is the id of the signal we 
 want to trigger. Once a signal is set, it remains in this state until we expressly clear it by 
 using the function
  
 int32_t
  osSignalClear
 (osThreadId thread_id,
  int32_t
  signals);
  
 A thread can be placed in blocked state waiting for a signal by using the function
  
 osEvent
  osSignalWait
 (
 int32_t
  signals,
  uint32_t
  millisec);
  
 where the
  millisec
  parameter represents the timeout.",NA
23.6 Resources Management and Mutual Exclusion,"In embedded applications it is quite frequent to access to hardware resources. For example, 
 assume that we use the UART peripheral to write debug messages to the console, and 
 assume that our application is made of several threads that can print messages using the
  
 HAL_UART_Trasmit()
  routine. If you remember, in
  Chapter 8
  we have seen that when we use 
 the UART in polling mode, the bytes contained in the message we are going to transmit are 
 transferred one-by-one in the UART
  Data Register
  (DR). This is a quite “slow procedure”, 
 compared to the number of activities an RTOS may performs in a unit of time. This means 
 that, if two threads call the
  HAL_UART_Trasmit()
  they are likely to overwrite the content of the 
 buffer register.",NA
23.6.1 Mutexes,"Mutex is acronym for
  MUTual EXclusion
 , and they are a sort of binary semaphores used to 
 control the access to shared resources. From a conceptual point of view, mutexes 
 differentiate from semaphore for two reasons:
  
 • a mutex must be always taken and then released to signal that the protected resource 
 is now 
  
 available again, while a semaphore can even be released to wake up a 
 blocking thread (we have 
  
 seen this mode in the example 4); moreover, usually a 
 mutex is taken and released by the same 
  
 thread
 ³⁰
 ;
  
 • a mutex implement the
  priority inheritance
 , a feature we will analyze later used to 
 minimize 
  
 the
  priority inversion
  problem.
  
 To use mutexes, we need to define the macro
  configUSE_MUTEXES
  inside the
  FreeRTOSConfig.h
  
 file and set it to 1. A mutex is defined using the macro
  osMutexDef()
 , which accepts the mutex 
 name as the only parameter, and it is effectively created by the function
  
 osMutexId
  osMutexCreate
 (
 const
  osMutexDef_t
  *
 mutex_def);
  
 Similarly to semaphores, to acquire a mutex we use the function
  
 osStatus
  osMutexWait
 (osMutexId mutex_id,
  uint32_t
  millisec);
  
 and to release it we use the function:
  
 osStatus
  osMutexRelease
 (osMutexId mutex_id);
  
 Finally, to destroy a mutex we must explicitly call the function
  
 osStatus
  osMutexDelete
 (osMutexId mutex_id);
  
 ³⁰
 However, different from other Operating Systems, FreeRTOS is not implemented to check that only the thread that has acquired 
 the mutex can release it.",NA
23.6.2 Critical Sections,"Sometimes, especially when we need to perform a really quick operation on a shared 
 resource, it is best to avoid using synchronization primitives at all. As seen before, it is 
 really easy to introduce weird behaviour in our application unless we handle with special 
 care synchronization constructs offered by the RTOS.
  
 ³¹
 http://www.freertos.org/RTOS-Recursive-Mutexes.html",NA
23.6.3 Interrupt Management With an RTOS,NA,NA
23.7 Software Timers,"Software
  timers
  are the way an RTOS provides to schedule the execution of routines on a 
 time-basis. Software timers are implemented by, and under the control of, the FreeRTOS 
 kernel. They do not require specific hardware support (except for the timer used as
  tick
  
 generator for the OS) and they have nothing related to hardware timers. Moreover, they are 
 not able to provide the same accuracy of hardware timers and should never used to 
 perform activities related with the hardware (for example, to trigger a DMA event).
  
 ³⁴
 If you read the official FreeRTOS documentation, you can see that the macro used to setup the maximum interruptible priority 
 level is 
 configMAX_SYSCALL_INTERRUPT_PRIORITY
 . However, being FreeRTOS portable among several silicon vendors, the priority level 
 specified with that macro is the exact value of the
  IPR
  register, that accepts only the upper 4 bits in STM32 MCUs (for example, a 
 priority 
 equal 
 to 
 0x2 
 must 
 be 
 specified 
 as 
 0x20). 
 ST 
 engineers 
 have 
 defined 
 the 
 macro
  
 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY
  so that we can specify the priority level according the HAL convention (in LSB form), 
 while the
  configMAX_SYSCALL_INTERRUPT_PRIORITY
  is defined in the following way:
  #define configMAX_SYSCALL_INTERRUPT_PRIORITY ( 
 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )",NA
23.7.1 How FreeRTOS Manages Timers,"As you can see in the previous example, our application does not use threads. So, who takes 
 care of timers? FreeRTOS uses a centralized thread, named RTOS
  daemon
  (or also
  timer 
 service
  thread), which automatically calls the callback routines when a timer expires. This 
 thread 
 is 
 a 
 regular 
 thread, 
 which 
 has 
 a 
 priority 
 defined 
 by 
 the 
 macro
  
 configTIMER_TASK_PRIORITY
  
 and 
 a 
 stack 
 with 
 a 
 size 
 defined 
 by 
 the 
 macro
  
 configTIMER_TASK_STACK_DEPTH
 . Moreover, it has an internal pool of timer objects, whose size 
 is defined by the macro
  configTIMER_QUEUE_LENGTH
 .
  
 Another interesting aspect to consider is how FreeRTOS computes the time internally. 
 FreeRTOS measure the time in function of the
  tick
  frequency, which is in turn defined by 
 the overflow frequency of the timer chosen as timebase generator. This means that, if we 
 use the
  SysTick
  timer configured to overflow ever 1ms, then internal software timers have a 
 resolution of 1ms (which corresponds to 1 tick). The
  millisec
  value passed to the
  
 osTimerStart()
  routine is hence converted in
  ticks
 . This means that, in the case of the example 
 5, if the tick time is 1ms, then 500ms will be equal to 500 ticks. If the tick time is set to 
 500μs, the 500ms delay is converted to 1000 ticks.",NA
23.8 A Case Study: Low-Power Management With an ,NA,NA
RTOS,"This is a really advanced topic, that requires the knowledge of many concepts 
 underlying an RTOS. Moreover, a decent knowledge of the concepts illustrated in
  
 Chapter 20
  is required. 
 Un-experienced users can safely skip this part.",NA
23.8.1 The,NA,NA
 idle,NA,NA
 Thread Hook,"So far we have seen that the ISR associated to the timer used as timebase generator for the 
 RTOS (usually the
  SysTick
  timer) rules the RTOS activities. Every 1ms the
  SysTick
  timer 
 underflows, and its ISR passes the control to the OS scheduler, which establishes the next 
 thread to be executed
 ³⁵
 . If no thread is in
  ready
  state, then the OS execute the
  idle
  thread, 
 until another thread becomes ready. This means that, when the
  idle
  thread is scheduled, it 
 is likely to be the right time to place the MCU in
  sleep
  mode to reduce power consumption.
  
 For this reason, FreeRTOS gives to the user the ability to define an
  idle hook
 , that is a 
 callback function invoked within the
  idle
  thread. To enable the hook, we have to define the 
 macro 
 configUSE_IDLE_HOOK
  inside the
  FreeRTOSConfig.h
  file and set it to 1. Next, we can define 
 the function
  vApplicationIdleHook(void)
  somewhere in our source code.
  
 For example, to place the MCU in
  sleep
  mode every time the
  idle
  thread is scheduled, we can 
 define that function in this way:
  
 void
  vApplicationIdleHook
 (
  void
  ) {
  
 //Assume __HAL_RCC_PWR_CLK_ENABLE() is called elsewhere
  
 HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFE);
  
 }
  
 ³⁵
 This is behaviour is enabled when the scheduling policy is the
  prioritized preemptive scheduling with time slicing
 , according
  Table 
 2
 .",NA
23.8.2 The Tickless Mode in FreeRTOS,"To address these issues, FreeRTOS offers a working mode named
  tickless idle
  mode (or 
 simply
  tickless 
 mode), which stops the periodic
  tick
  interrupt during idle periods. The 
 duration of these
  periods
  is arbitrary: it can be several milliseconds, some seconds, minutes 
 or even days. When the MCU exits from low-power mode, FreeRTOS makes a correcting 
 adjustment to the
  tick
  count value when the tick interrupt is restarted, if needed (more 
 about this soon). This means that FreeRTOS does not stop the timer at all: it just configures 
 the timer so that it reaches its maximum update period before overflowing. When the MCU 
 wakes up again, the kernel reads the counter value of the timer and computes the number 
 of elapsed
  ticks
  during the sleep time.",NA
23.9 Debugging Features,"The debugging of a firmware built using an RTOS could not be trivial.
  Context switches
  can 
 make complicated to perform step-by-step debugging. FreeRTOS offers some debugging 
 features, and some of them are useful especially when your design uses a lot of threads 
 spawned dynamically.",NA
23.9.1,configASSERT(),NA
 Macro,"FreeRTOS source code is full of calls to the macro
  configASSERT()
 . This is an empty macro 
 that developers can define inside the
  FreeRTOSConfig.h
 , and it plays the same role of the C
  
 assert() 
 function. CubeMX automatically defines it for us in the following way:
  
 #define configASSERT( x ) if ((x) == 0) {taskDISABLE_INTERRUPTS(); for( ;; );}
  
 The macro works so that if the assert condition is false then all interrupts are disabled (by 
 setting the 
 PRIMASK
  register on Cortex-M0/0+ cores and rising the
  BASEPRI
  value in other",NA
23.9.2 Run-Time Statistics and Thread State Information,"When threads are spawned dynamically, it is hard to keep track of their lifecycle. FreeRTOS 
 provides a ways to retrieve both the complete list of live threads and some relevant 
 information regarding their status.
  
 The
  uxTaskGetNumberOfTasks()
  function returns the number of live threads. With the term
  live 
 threads we mean all threads effectively allocated by the kernel, even those ones marked as
  
 deleted
 ⁴¹
 .
  
 The function
  
 UBaseType_t
  uxTaskGetSystemState
 (TaskStatus_t
  *
  const
  pxTaskStatusArray, 
  
 const
  UBaseType_t uxArraySize,
  unsigned long
  *
  const
  pulTotalRunTime );",NA
23.10 Alternatives to FreeRTOS,"As stated in the introduction to this book, there are several good alternatives to FreeRTOS 
 on the market. Here you will find some words about other good RTOS available for the 
 STM32 platform.
  
 ⁴²
 http://www.freertos.org/rtos-run-time-stats.html",NA
23.10.1 ChibiOS,"If you are not new to the STM32 platform, probably you already know about
  ChibiOS⁴³
 . 
 ChibiOS is an independent and open source project started by an STMicroelectronics 
 engineer, Giovanni Di Sirio, who works at the ST site in Naples (Italy). ChibiOS is quite 
 popular in the STM32 community, due to the fact that Giovanni has a deep knowledge of 
 the STM32 platform, and this has allowed to him to create probably one of the most 
 optimized solution for STM32 MCUs. However, ChibiOS is designed to run on any MCU 
 architecture apart from STM32.
  
 ChibiOS is essentially composed by two layers: the kernels (named ChibiOS/RT or 
 ChibiOS/NIL) and a complete HAL (named Chibios/HAL), which allows to abstract from the 
 underlying hardware peculiarities. While it is perfectly possible to mix the official ST 
 CubeHAL with the ChibiOS/RT/NIL kernels, probably the ChibiOS/HAL is a simpler 
 solution to program STM32 devices, at least for the supported peripherals. Even if this 
 author does not have a direct experience with it, ChibiOS has a really good reputation 
 among a lot of people he knows and some readers of this book. Moreover, you can find 
 several projects and good tutorials
  around in the web⁴⁴
  based on this RTOS and its related 
 HAL. Different from the current production release of FreeRTOS, Chibios uses a full static 
 memory allocation model, allowing to use it in those application domains where dynamic 
 allocation is prohibited. Finally, Giovanni also provides a pre-configured version of Eclipse, 
 named ChibiStudio, which ships all required tools (GCC tool-chain, OpenOCD, etc.) already 
 pre-configured. Unfortunately, it runs only on the Windows OS at the time of writing this 
 chapter.
  
 ChibiOS uses a mixed licensing model. ChibiOS RT and NIL kernels are distributed under 
 the GPL 3 license, HAL is distributed under the more permissive Apache 2.0 license. GPL 3 
 prevents the usage of the software if you sell electronic devices without releasing the 
 firmware source code publicly. A“free commercial license” exists that removes GPL 3 for 
 commercial users. This license requires a registration process and it is valid for 500 MCU 
 cores. The free license can be renewed indefinitely by just re-submitting the request form 
 for extra 500 cores.",NA
23.10.2 Contiki OS,"Contiki⁴⁵
  is another open source RTOS, which has a strong accent on wireless low-power 
 sensors and IoT devices. It is a project started by Adam Dunkels in 2003, but it is currently 
 supported by several large companies including Texas Instruments and Atmel. It is quite 
 popular among CC2xxx devices from TI. It is based on a kernel scheduler and an 
 independent TCP/IP stack designed for low-resources devices, which provides IPv4 
 networking, the
  uIPv6
  stack and the Rime stack, which is a set of custom lightweight 
 networking protocols designed for low-power wireless networks. The IPv6 stack was 
 contributed by Cisco and was, when released, the smallest IPv6 stack to receive the
  IPv6 
 Ready
  certification. The IPv6 stack also contains the Routing Protocol for Low power and",NA
23.10.3 OpenRTOS,"OPENRTOS is the commercial edition of FreeRTOS, described in this chapter and officially 
 supported by ST. OPENRTOS and FreeRTOS share the same code base. The additional value 
 offered by OPENRTOS is a “commercial and legal wrapper” for FreeRTOS users.
  
 Developers upgrade to an OPENRTOS license for two main reasons: the ability to sell their 
 devices and/or to ship derived code without having to share source code publicly, and the 
 dedicated support in developing custom solutions based on OPENRTOS. For large 
 companies the possibility to receive paid support is really important.
  
 ⁴⁶
 http://bit.ly/1URnLZc",NA
24. Advanced Debugging Techniques,"In
  Chapter 5
  we have started analyzing basic tools and techniques to debug the firmware 
 running on a target microcontroller. We studied some important Eclipse features, like 
 breakpoints and step-by-step debugging, useful to understand what’s going wrong with our 
 code. Moreover, we deeply analyzed the way ARM
  semihosting
  works, a technique that 
 exploits the ARM
  bkpt
  assembly instruction to pass the control to the debugger so that data 
 can be transferred from the MCU to the OpenOCD debugger and vice versa. This feature is 
 extremely useful especially if our device does not provide a dedicated UART interface or if 
 we want to use some functionalities that it would be too complicated to perform on a low-
 cost embedded architectures. Those techniques, however, could be not sufficient to debug 
 real-life applications. Things can go wrong in several ways and it is quite common the need 
 of dedicated, and often expensive, hardware tools to better debug our embedded 
 applications.
  
 This chapter aims to introduce the reader to some advanced debugging capabilities offered 
 by Cortex-M based microcontrollers. The role of Cortex-M exceptions is finally presented, 
 showing how to decode some relevant core registers that can provide really useful 
 information about the exception source. This chapter also provides a brief introduction to 
 the ARM CoreSight
 TM
 features implemented in Cortex-M3/4/7 MCUs, a distinctive ARM 
 technology that allows to perform real-time tracing of the MCU activities using an external 
 debugger tool.
  
 This chapter is not limited to low-level debugging techniques . We will also see in action 
 some other features offered by the GNU MCU Eclipse tool-chain, like
  debug expressions
  and
  
 Keil Packs
 , and we will analyze the features offered by the CubeHAL to improve error 
 management and to optimize the debugging process.
  
  
 In an ideal world, this chapter would come right after the Chapter 5. Information 
 reported here is important to perform an efficient debug during the early 
 experiences with the STM32 platform. Unfortunately, to master concepts illustrated 
 in this chapter, you need to study
  
 several other topics before you can deeply understand the techniques and tools 
 shown here. As a rule of thumb, this author suggests to read at least chapters 7 and 
 15 before approaching this one.",NA
24.1 Understanding Cortex-M Fault-Related Exceptions,"At beginning of this long journey we have seen that Cortex-M based microcontrollers 
 implement a number of system-related exceptions. Some of them are fault-related, that is 
 those exceptions are triggered when something wrong happens during the normal",NA
24.1.1 The Cortex-M Exception Entrance Sequence and the ARM ,NA,NA
Calling Convention,"For high-level programmers
 ¹
 , to invoke a routine seems an obvious thing. We just write 
 down the name of the function we are going to call, passing to it a given number of 
 parameters. However, from the processor point-of-view, what happens under the hood 
 needs to be specified down to the finest details and it must match both the processor 
 architecture and the programming language semantics. For this reason, it is common to talk 
 about
  calling convention
  when describing the process of placing a new routine on the stack.
  
 The
  ARM Architecture Procedure Call Standard
  (AAPCS) precisely defines the calling 
 convention for ARM based architectures. In
  Chapter 1
  we have seen that Cortex-M based 
 microcontrollers provide a number of
  core registers
 , which are shown again in
  Figure 1
  for 
 your convenience. Not all those core registers are available in all Cortex-M cores: for 
 example, FPU registers S0-S31 are only available in Cortex-M4F and Cortex-M7 cores, when 
 the FPU unit is enabled and used.
  
  
 Figure 1: Cortex-M CPU core registers
  
 Some core registers play a special role, because they are used to carry out processor’s 
 activities. R13 is the
  Stack Pointer
  (SP), that is the pointer in SRAM (so something similar to
  
 0x2000 XXXX 
 in an STM32) to the base of the most recent entry placed on the stack. This 
 entry represents the local memory area of a given function and, in a full-descendent stack, 
 SP coincides with the lowest address of the stack. R14 is the
  Link Register
  (LR), that is the 
 address in FLASH
 ²
  (so something similar to
  0x0800X XXXX
  in an STM32) of the instruction 
 following the instruction that called the
  
 ¹
 As C programmers, we are all “high level programmers”, whether you believe it or not.",NA
24.1.2 Fault Exceptions and Faults Analysis,"The fault exception mechanism provided by Cortex-M CPU is really useful to detect sources 
 of faults. During the development lifecycle it is really common to have fault conditions, 
 especially if you are new to the STM32 platform or the embedded programming.
  
 This paragraph shows a brief overview of the analysis of fault conditions. It does not aim to 
 replace the official ARM documentation or the excellent work from
  Joseph 
 Yiu⁷
 (http://amzn.to/1P5sZwq). Its main goal is to provide the necessary tools and 
 concepts to understanding what’s going wrong when one of the four fault exceptions is 
 raised.
  
 Cortex-M3/4/7 cores provide a number of registers that are used for fault analysis. They 
 may be used by the fault handler code, but in the majority of cases they are used during a 
 debug session. 
 Table 2
  lists the available registers useful to fault analysis.
  
 Table 2: Registers for fault status and address information
  
 CMSIS Symbol
  
 Register name
  
 Description
  
 SCB->CFSR
  
 Configurable Fault Status Register
  
 Provides status information about configurable
  
 SCB->HFSR
  
 exceptions (
 MemFault
 ,
  BusFault
 ,
  UsageFault
 )
  
 Status for HardFault
  
 Provides status information for the
  HardFault
  
 SCB->DFSR
  
 Debug Fault Status Register
  
 exception
  
 Provides status information for the
  Debug
  
 SCB->MMFAR
  
 MemManage Fault Address Register
  
 Monitor
  exception
  
 If available, shows the address that triggered 
 the
  
 SCB->BFAR
  
 BusFault Address Register
  
 MemManage
  fault
  
 If available, shows the address that triggered 
 the
  
 BusFault
  fault
  
 SCB->CFSR
  is the
  Configurable Fault Status Register
  and it provides information for those 
 exceptions that can be optionally enabled (
 MemFault
 ,
  BusFault
 ,
  UsageFault
 ). It is in turn",NA
24.2 Eclipse Advanced Debugging Features,"In Chapter 5 we have started analyzing the debugging functionalities offered by Eclipse 
 CDT and GNU MCU Eclipse plug-ins. We have familiarized with the most basic features like 
 breakpoints insertion and step-by-step debugging. Now it is the right time to see the other 
 debugging function-alities integrated in the GNU MCU Eclipse tool-chain.
  
 All the features shown here are available through the
  Debugging
  perspective.",NA
24.2.1 Expressions,"The
  Expressions
  view is a powerful feature that allows to access to the content of memory 
 addresses, variables and other data structures during debugging. Moreover, it is also able 
 to perform function calls, so that you can evaluate the result of a given routine. The
  
 Expressions
  view must be explicitly enabled going to
  Window->Show View->Expressions
 .
  
  
 Figure 7: The
  Expressions
  view in the debug perspective
  
 The
  Figure 7
  shows several expression examples.
  msg
  is a character array containing the 
 “Hello World!” string.
  pMsg
  is a
  char
  pointer to the
  msg
  string. As you can see from
  Figure 7
 , 
 by simply writing down the variable name in the expression view we can access to its 
 content wherever it is defined in the code. We can also show a C pointer as an array, using 
 the expression
  (variable@len)
 , where
  variable
  is the pointer name and
  len
  is the amount of data 
 stored in the array.
  
 In
  Figure 7
  also shows that it is possible to call a function (the
  strlen()
  in our case) and to 
 obtain its result
 ⁹
 . An expression can also contain arithmetic operations. Finally, the
  
 Expression
  view is also able to access to the content of individual memory locations, and to 
 cast their content to a given datatype (by right-clicking on the expression row you can cast 
 a variable to a different datatype).
  
 Expressions
  view in recent Eclipse CDT releases accepts
  enhanced expressions
 . An enhanced 
 expression is a way of easily writing an expression pattern that will automatically expand 
 to a larger subset of children expressions. Four types of enhanced expressions can be used:
  
 ⁹
 Clearly, that function must be included in the binary image, that is it must be a function used in the firmware code.",NA
24.2.2 Watchpoints,"Every Cortex-M based processor provides a given number of breakpoints and watchpoints 
 (see
  Table 7
 ). While breakpoints are used to break execution at a given instruction, 
 watchpoints are used to break execution when a data location is accessed. Any data or 
 peripheral address can be marked as a watched variable, and an access to this address 
 causes a debug event to be generated, which halts program execution. Watchpoint can also 
 be used to halt execution only when a given expression matches.
  
 Table 7: Available breakpoints/watchpoints in Cortex-M cores
  
 Cortex-M
  
 Breakpoints
  
 Watchpoints
  
 M0/0+
  
 4
  
 2
  
 M3/4/7
  
 6
  
 4
  
 There are several ways to add a watchpoint in the Eclipse CDT tool-chain. For example, you 
 can right-click on a variable in the
  Variables
  view and the select the entry
  Add 
 Watchpoint(C/C++)
 . The same can be performed from the
  Expressions
  view and the
  
 Memory monitors
  view while right-clicking on a memory location.",NA
24.2.3 Instruction Stepping Mode,"The
  Instruction Stepping Mode
  is a debugging mode that allows to perform step-by-step 
 debugging of ARM assembly instructions “underlying” a given C instruction.
  
  
 Figure 11: The
  Instruction Stepping Mode
  icon on the Eclipse toolbar
  
 Instruction Stepping Mode
  is enabled by clicking on the related icon on the Eclipse main 
 toolbar, as shown in
  Figure 11
 . Once enabled, the
  Disassembly
  appears, as shown in
  Figure 
 12
 . Eclipse will automatically show ARM assembly instructions corresponding to the 
 current C instruction.
  
  
 Read Carefully
  
 The
  Instruction Stepping Mode
  dramatically slows down the debugging process, 
 because the CPU halts at every assembly instruction. If you cannot understand why 
 the debugging is so slow, then you probably forgot the
  Disassembly
  view active.",NA
24.2.4 Keil Packs and Peripheral Registers View,"During a debug session we may need to access to peripheral registers to better understand 
 what’s going wrong with a given peripheral. Accessing a peripheral register with a
  memory 
 monitor 
 requires a lot of effort from us to understand the meaning of individual bits. This is 
 largely impractical during a debug session.
  
 The GNU MCU Eclipse tool-chains offers a way to visualize peripheral registers content. 
 This ability is connected with a large distribution project made by ARM:
  Keil Packs
 . Packs 
 are a modular technology, similar to the packages distribution in the Linux world, intended 
 to simplify distribution of software and documentation. The main difference from usual 
 libraries or source archives is that the actual source/object files are accompanied by some 
 form of metadata, defining the dependencies between files, the use of constraints and 
 conditions, plus lists of devices the software runs on, with full descriptions of their memory 
 map, registers and peripherals, etc.
  
  
 Figure 13: The “Packs” icon on the perspective switcher toolbar
  
 To visualize peripheral registers in a convenient way we so need to download the
  pack
  
 corresponding to the STM32 family for our MCU. To perform this operation, we first need 
 to switch to the 
 Packs
  perspective, by clicking on the corresponding icon on the perspective 
 toolbar (see
  Figure 13
 ). The
  Packs
  perspective should appear empty on a fresh-new 
 Eclipse installation. You so need to synchronize Eclipse with the current
  Keil Packs
  
 repository by clicking on the icon highlighted in 
 Figure 14
 .",NA
24.2.5 Core Registers View,"The
  Register
  view, shown in
  Figure 18
 , allows to access to Cortex-M core registers, plus the 
 FPU registers in Cortex-M4F/7 cores if the FPU is enabled. The registers’ content can be 
 eventually modified by double-clicking on the register value.
  
  
 Figure 18: The
  Registers
  view in the debug perspective",NA
24.3 Debugging Aids From the CubeHAL,"The CubeHAL implements run-time failure detection by checking the input values of all 
 HAL API. The run-time checking is achieved by using an
  assert_param()
  macro. This macro is 
 used in all CubeHAL functions having an input parameter. It allows verifying that the input 
 value lies within the parameter allowed values.
  
 To enable run-time checking you need to define the
  USE_FULL_ASSERT
  macro at project level 
 (both in the project settings or by uncommenting the macro definition in the
  
 stm32XXxx_hal_conf.h
  file). CubeMX generates a function named
  assert_failed()
  in the
  main.c
  file. 
 The function is defined in the following way:
  
 void
  assert_failed
 (
 uint8_t
 *
  file,
  uint32_t
  line);
  
 The function is automatically invoked by the
  assert_param()
  macro if an assertion is not 
 satisfied. The macro will automatically pass to the function the filename and the exact lines 
 of code where the assert condition is not satisfied.
  
 The implementation of the
  assert_failed()
  function is left to the user. A simple implementation 
 consists in placing a software breakpoint by invoking the
  bkpt
  ARM instruction:
  
 void
  assert_failed
 (
 uint8_t
 *
  file,
  uint32_t
  line) {
  
 asm
 (
 ""BKPT #0""
 );
  
 }
  
 Enabling the
  USE_FULL_ASSERT
  macro during the development stage can provide a huge help 
 to understand what’s going wrong with the CubeHAL, especially if you are new to the 
 CubeHAL.",NA
24.4 External Debuggers,"Serious projects demand serious tools. And this is dramatically true in electronics design. If 
 you reached this part of the book without skipping any fundamental chapter, then you 
 already know the limits of the ST-LINK debugging interface.
  
 Unfortunately, ST-LINK tends to be slower then dedicated and external debuggers. It lacks 
 of some relevant features and it is affected by serious bugs that often make the debugging 
 experience a nightmare. Moreover, the OpenOCD support to the ST-LINK interface is still 
 incomplete, and several STM32 devices (especially those belonging to the STM32L-series) 
 are not supported at all. Finally, the OpenOCD development flows too slowly: the last stable 
 OpenOCD release (0.9) is date back to May 2015, and at the time of writing this chapter 
 (November 2016) the next stable release (0.10) is still under development.",NA
24.4.1 Using SEGGER J-Link for ST-LINK Debugger,"You need to install SEGGER software tools to start using SEGGER debug probes. You can 
 download them from the official
  SEGGER website¹⁴
 . The most relevant package is the
  J-
 Link Software and Documentation Pack
 . You will find installers for the three major OSes: 
 Windows, Mac OS and Linux. Once the installation is completed, you need to configure your 
 Eclipse workspace to make it aware of the filesystem path where the
  JLinkGDBServer.exe
  (or 
 simple
  JLinkGDBServer
  in Mac OS and Linux) is stored.
  
 ¹¹
 https://www.segger.com/jlink-st-link.html
  
 ¹²
 Unfortunately, at the time of writing this chapter, the upgrade tool is only available for the 
 Windows OS.
  
 ¹³
 Please, take note that the license of this “free” upgrade to the ST-LINK interface prevents you from using it to debug custom and 
 commercial devices. Take a look at the SEGGER website for the complete list of limitations.
  
 ¹⁴
 https://www.segger.com/downloads/jlink",NA
24.4.2 Using the ITM Interface and SWV Tracing,"Cortex-M based microcontrollers integrate several debugging and tracing technologies in 
 the same die. As said before, JTAG and SWD are two complimentary specifications that 
 allow to connect an external debugger to the target MCU. The same interfaces are used to 
 implement tracing capabilities. Tracing allows to export in real-time internal activities 
 performed by the CPU. It is a sort of live-hardware debugging, and it is carried out using the 
 5 signals of the JTAG port. Tracing is carried out due to the presence of a technology named
  
 Embedded Trace Macrocell
  (ETM), but it requires faster and more adavanced debuggers. 
 ETM tracing is a sort of “sniffing” technology, and it does not impact on the MCU 
 performances. SEGGER produces a separated line of debug probes named J-Trace, which 
 offer live-tracing of the MCU through the ETM interface.
  
 The
  Instrumentation Trace Macrocell
  (ITM) is a less demanding tracing technology that 
 allows sending software-generated debug messages through the SWD, using a specific 
 signal I/O named 
 Serial Wire Output
  (SWO). The protocol used by the SWO pin to exchange 
 data with the debugger probe is called
  Serial Wire Viewer
  (SWV). The SWV support is not 
 available in Cortex-M0/0+ based microcontrollers.
  
 Compared to other “debugging-alike” peripherals like UART or to other technologies like 
 the ARM semihosting, SWV is really fast. Its communication speed is proportional to the 
 MCU speed, and this allows to limit the impact of the exchanged data on firmware 
 performances. Clearly, the more fast runs the SWO I/O, the faster needs to be the debugger. 
 That is the reason why SEGGER sells several version of its J-Link probe. The expensive ones 
 are based on a FPGA, which allows to sample SWD I/Os at a speed up to 100MHz. The 
 integrated ST-LINK interface, with the dedicated J-Link firmware, can sample SWO signal 
 up to 4500kHz. The J-Link Ultra+ is able to sample up to 100MHz.
  
 The CMSIS-Core package for Cortex-M3/4/7 cores provides necessary glue to handle SWV 
 protocol. For example, the
  ITM_SendChar()
  routines allows to send a character using the SWO 
 pin. The GNU MCU Eclipse tool-chain automatically integrates the necessary logic: if we set",NA
24.5 STM Studio,"STM Studio¹⁵
  is a run-time variables monitoring and visualization tool for STM32 
 microcontrollers. It is developed and officially supported by ST, which distributes it freely. 
 It is designed to work with STM debuggers (ST-LINK, STIce, etc.). This tool supports both 
 JTAG and SWD debugging protocols, and it is a non-intrusive tool that allows to keep track 
 of variable values while firmware runs. The acquired values are then plotted on a graph 
 and this is a powerful tool that allows to understand what’s happening with our code 
 without affecting its execution. It is a fundamental tool in several time-critical applications, 
 like motor-control and so on. Unfortunately, even if developed with Java, at the time of 
 writing this chapter STM Studio supports exclusively Windows OSes, from Windows XP up 
 to the latest Windows 10.
  
 ¹⁵
 http://www.st.com/en/development-tools/stm-studio-stm32.html",NA
24.6 Debugging two Nucleo Boards Simultaneously,"We may need to debug two STM32 based devices simultaneously. This is not uncommon, 
 especially when dealing with communication protocols. OpenOCD allows us to debug two 
 or more boards on the same computer.
  
 To launch two OpenOCD instances we need to derive a fundamental information: the Serial 
 ID of the ST-LINK interface, which corresponds to the CPU ID of the STM32F1 in the ST-
 LINK debugger.
  
 Retrieve the ST-LINK Serial ID in Linux and MacOS 
  
 To retrieve the ST-LINK Serial ID we can use the ST-LINK Upgrade tool, available through 
 the 
 ST website¹⁹
  (you should already have downloaded it if you followed installation 
 instructions in Chapter 2). Extract the .zip package (
 stsw-link007.zip
 ) and go inside the
  
 AllPlatforms
  sub-directory.",NA
25. FAT Filesystem,"Electronic embedded devices are increasingly complex and nowadays it is really common 
 to have devices that need to read and store structured data. For example, consider an 
 Internet-enabled device, which needs to serve HTTP requests and to transfer HTML files. 
 Unless HTML pages are really simple, this device will need a way to handle several and 
 separated HTML files, as well as CSS stylesheets and JavaScript files. For this reason, a lot of 
 embedded developers need a way to handle structured filesystems in their applications.
  
 ST has integrated in its CubeHAL a well-known library to manipulate FAT filesystems 
 (FAT12, FAT16 and FAT32): the
  FatFs library by Chan¹
 . This is a library expressly designed 
 for embedded system, with limited SRAM and flash memories. It is really popular and it is 
 proven to be robust.
  
 This chapter provides a quick introduction to this middleware library. It describes how to 
 use CubeMX to generate a project that integrates it and how to develop applications based 
 on this useful library. Moreover, we will see how to interface SD cards using SPI, which 
 represents the most widespread way to use memory cards with low-cost embedded 
 microcontrollers.",NA
25.1 Introduction to FatFs Library,"The
  File Allocation Table
  (FAT) is a filesystem architecture designed by Microsoft in the 
 early ‘80 and used as official filesystem for the MS-DOS and Windows Operating Systems 
 until the Windows NT 3.1 release. FAT filesystem was superseded by the more advanced 
 NTFS, which offers improved support for metadata, and the use of advanced data 
 structures to improve performance, reliability, and disk space utilization, plus additional 
 extensions, such as security access control lists (that is, file permissions) and file system 
 journaling.
  
 Thanks to its simplicity and robustness, the FAT file system is still commonly found on 
 USB-based memories, flash and other solid-state memory cards and modules like SD cards, 
 and many portable and embedded devices. Technically, the term “FAT file system” refers to 
 all three major variants of the file system: FAT12, FAT16 and FAT32. Those numbers 
 essentially indicate how many bits are used to address filesystem
  clusters
 , a contiguous 
 area of disk storage. The more clusters the filesystem can handle, the more bytes can be 
 used. That’s the reason why FAT32 is nowadays the most-used filesystem on large solid-
 state and removable memories. A disk as well as a solid state memory initialized with the 
 FAT filesystem can have an arbitrary number of partitions.
  
 The FatFs is a really space-optimized
 ²
  library which provides the following features:",NA
25.1.1 Using CubeMX to Include FatFs Library in Your Projects,"As said before, FatFs library is a component of the CubeHAL framework, and CubeMX 
 supports it. However, the way CubeMX handles this library is a little bit counterintuitive, at 
 least for beginners.
  
  
 Figure 2: What CubeMX shows for those STM32 MCUs that does not provide a compatible adapter
  
 Many of you will notice that CubeMX shows just one option related to the FatFs middleware 
 library, as shown in
  Figure 2
 . The obscure
  User-defined
  entry will appear for the majority 
 of STM32 microcontrollers. But what exactly that means? It simply means that your specific 
 STM32 microcontroller provides no peripheral compatible with the adapters developed by 
 ST developers (SRAM/SDRAM, USB, and SDIO), and you will need to provide your own 
 implementation for the low-level I/O drivers.
  
  
 Figure 3: What CubeMX shows for an STM32F746VG MCU
  
 Figure 3
 , instead, shows the options available if you use an STM32F746VG MCU, which 
 provides the SDIO interface
 ⁴
 , the FMC controller and an USB-device interface. However, as 
 you can see in 
 Figure 3
 , the generation options appear grayed out. This happens because 
 we need to enable the corresponding peripheral first, and then check the wanted FatFs 
 configuration. For example, let us assume that we are working on an STM32F401RE MCU, 
 which provides a SDIO peripheral. We first need to enable the wanted SDIO mode (1-bit, 4-
 bit, etc) in the
  IP Tree
  view, and then check the corresponding FatFs option.
  
 The generated project has a structure similar to the one shown in
  Figure 4
 . The
  
 Middlewares/Third_-Party/FatFs/src
  folder contains the FatFs library, while the
  
 Middlewares/Third_Party/FatFs/src/-drivers
  folder contains I/O routines to handle SD 
 cards through the specific interface (the SDIO). Those routines are abstracted from the 
 specific board configurations, and they rely on APIs that are implemented inside the
  
 src/bsp_driver_sd.c
  file. The routines contained in that file use in turn CubeHAL functions 
 (from the
  HAL_SD
  module for the SDIO).
  
 ⁴
 In STM32F7 MCUs the SDIO peripheral is called SDMMC.",NA
25.1.2 Relevant FatFs Structures and Functions,"We are now going to analyze the most important structures and functions provided by the 
 FatFs library to manipulate FAT drives
 ⁷
 .
  
 25.1.2.1 Mounting a Filesystem
  
 Before accessing any file or directory on the filesystem we need to mount
 ⁸
  it using the 
 function:
  
 FRESULT
  f_mount
 (FATFS
  *
 fs,
  const
  TCHAR
  *
 path, BYTE opt);
  
 fs
  is an instance of the C
  struct FATFS
 , which holds information about the logical drive 
 (partition); 
 path
  is a pointer to the null-terminated string that specifies the logical drive 
 (more about this in a while);
  opt
  can assume the value 0 to delay the filesystem mounting 
 until to the first access to the volume (for example, opening a file or a directory) or it can 
 assume the value 1 to immediately mount the logical volume. Application program must 
 not modify any member the
  FATFS
  structure, otherwise the original logical/physical disk 
 could me irremediably damaged.
  
 The format of
  path
  parameter is similar to the drive name specification in Windows 
 Operating System, at it can assume the form
  N:/
 , where N is a number starting from 0 which 
 uniquely identifies a logical drive. By default each physical drive can have just one logical 
 drive (that is, a partition). This means that if our disk has more than one partition, then 
 only the first partition in the partitions table will be mounted and assigned to a logical 
 drive. Instead, by setting the macro
  _MULTI_PARTITION=1 
 in the
  ffconf.h
  file, FatFs library will 
 associate a logical drive to every partition in a physical disk. When drive number is omitted, 
 the drive number is assumed as default drive (drive 0 or current drive). We can so pass to 
 the
  path
  parameter slash or backslash chars (
 \
  or
  /
 ) or even specify a
  NULL 
 string. For 
 example, the following code forces the mounting of the first partition on a physical drive:
  
 FATFS fs;
  
 f_mount(
 &
 fs,
  ""/""
 ,
  1
 );
  
 If the logical disk is correctly mounted, then the
  f_mount()
  function returns the value
  FR_OK
 . 
 Other-wise a series of error conditions may be returned (
 FR_INVALID_DRIVE
 ,
  FR_DISK_ERR
 ,
  
 FR_NOT_READY
 , 
 FR_NO_FILESYSTEM
 ).
  
 25.1.2.2 Opening a File
  
 Once the drive is mounted, we can open a file by using the function:",NA
25.1.3 How to Configure the FatFs Library,"The FatFs library is highly customizable. A set of configuration parameters (that is, 
 configuration macros) allows to reduce the total footprint of the library and enable/disable 
 some features at compile time.
  
 All the configuration parameters are automatically exported by CubeMX inside the
  ffconf.h
  
 file. We are now going to analyze the most relevant ones. For a more complete treatment of 
 this subject the reader should refer to the
  official documentation¹⁰
 .
  
 •
  _FS_TINY
 : this macro can assume the values 0 (default) and 1. This option allows to 
 reduce the SRAM occupation of the FatFs library. When set to 0, every instance of the
  
 FIL struct
  has an its own temporary buffer used during file read/write. Instead, when 
 set to 1, a global pool defined in
  FATFS struct
  is used. This slows down the read/write 
 operations.
  
 •
  _FS_READONLY
 : this macro can assume the values 0 (default) and 1. This macro skips 
 from com-pilation those functionalities used to modify the filesystem, by removing 
 writing API functions such as
  f_write()
 ,
  f_sync()
 ,
  f_unlink()
 ,
  f_mkdir()
 ,
  f_chmod()
 ,
  f_rename()
 ,
  
 f_truncate()
 , 
 f_getfree()
  and optional writing functions as well.
  
 •
  _FS_MINIMIZE
 : this macro defines the library minimization level, which consists in 
 removing some API functions. If set to 0, all APIs are available. If set to 1,
  f_stat()
 ,
  
 f_getfree()
 , 
 f_unlink()
 ,
  f_mkdir()
 ,
  f_chmod()
 ,
  f_utime()
 ,
  f_truncate()
  and
  f_rename()
  functions are
  
 ¹⁰
 http://bit.ly/2dJGh3E",NA
26. Develop IoT Applications,"In a connected world, more and more devices are getting connected. Cars, home appliances 
 such as washing machines and freezers, lights, blinds, thermostats, but also sensors for 
 environmental monitoring are just few examples of devices that nowadays exchange 
 messages through the Internet. Several observers agree by saying that this is the
  Internet of 
 Things
  (IoT) era. Actually, it is hard to say if IoT will represent a new golden era for the 
 electronics industry. But it is certain that many semiconductor companies are investing 
 billions in this field.
  
 IoT is a vague term. It does say nothing about communication standards, protocols, 
 application layers and even system architectures. The world of IoT communication 
 protocols and technologies is a jun-gle. There exist tens of standards, especially for wireless 
 communication protocols. WiFi, Bluetooth, Zigbee, LoRaWAN, proprietary solutions like 
 SimpliciTI from TI or MiWI from Microchip, 4G/3G mobile networks. But there exist even 
 tens of communication mediums. For example, in wireless communications the 2.4GHz and 
 5.8GHz frequencies are worldwide standards, but there are several regional and alternative 
 frequencies such as the 868MHz in EU (915MHz in US), 434MHz in several parts of EU and 
 US, 169MHz in large parts of EU and Japan. Every one of these standards has its own rules 
 about TX power, duty cycle, and so on. Every one has its advantages and disadvantages.
  
 The choice of communication medium and protocol also impacts on the application 
 architecture. For example, a WiFi or Ethernet enabled device can connect to the Internet 
 using just a router with integrated MODEM. A device that uses a proprietary protocol (for 
 example, a Zigbee device) usually needs an intermediate device (a control unit) that 
 collects the messages and sends them to a centralized server (or a
  cloud server
  as now are 
 called centralized servers) through the Internet. For some “industrial” applications this is 
 often an advantage (local devices can keep working even in absence of the Internet). For 
 consumer applications usually this discourages users from adopting the solution.
  
 Nowadays there are several silicon manufacturers that offer microcontrollers with 
 integrated wired and wireless connectivity. Texas Instruments, after the acquisition of 
 ChipCon, has developed several MCU with integrated radio front ends. For example, the 
 CC2540 is an 8051 MCU with a 2.4GHz radio dedicated to Bluetooth applications. The 
 CC3200 is a Cortex-M4 core with a 2.4GHz radio able to communicate according to the WiFi 
 standard. Recently, another player appeared on the market.
  Espressif¹
  is a Chinese 
 company that introduced to the market a dual core Tensilica
 ²
  LX6 microcontroller running 
 at 240MHz with integrated 2.4GHz radio and MAC layer (
 ESP32³
 ). These MCUs cost less 
 than 5 USD at low volumes and they are becoming really popular between makers.
  
 Apart from the unlucky STM32W, ST still does not offer an STM32 MCU with integrated 
 radio front end. And this is really sad, especially because ST has all the required know-how 
 to build radio",NA
26.1 Solutions Offered by STM to Develop IoT ,NA,NA
Applications,"As said before, several STM32 microcontrollers from F1/2/4/7-series provide an 
 integrated Ethernet controller, which supports the
  Media-Independent Interface
  (MII) and 
 its variant
  Reduced-MII 
 (RMII). This is a communication standard that abstracts from the 
 given physical medium, and allows to connect the MAC layer of the ethernet controller to a 
 physical controller chip, also called
  phyther
 . There exists several LAN phythers on the 
 market, and the interconnection to the chip is all handled by the low-level MII protocol.
  
 However the existence of a dedicated hardware interface does not allow to build IoT 
 applications quickly. A complete TCP/IP stack is also needed, otherwise to handle a so 
 complex protocol stack like the TCP/IP is impossible for a single developer. ST does not 
 provide a custom solution, but it adopted the
  Lightweight IP
  (LwIP) stack. LwIP is an Open 
 Source framework started by Adam Dunkels and now maintained by a large community. 
 Moreover, several other semiconductor companies, like Altera, Xilinx and Freescale, 
 contribute to the development of this quite complex framework.
  
 ST has integrated LwIP in CubeMX, which automatically adds to the project all the 
 necessary files to work with this framework. Once you have enabled the Ethernet 
 controller, the LwIP appears as a selectable middleware component. The current stable 
 release is the 2.0.2, which was released by the end of 2016. ST actively maintains and 
 support it.
  
 These are the most relevant features of LwIP:
  
 • IP (Internet Protocol, IPv4 and IPv6) including packet forwarding over multiple 
 network 
  
 interfaces
  
 • ICMP (Internet Control Message Protocol) for network maintenance and debugging",NA
26.2 The W5500 Ethernet Controller,"Apart from the more recent Nucleo-144 boards, none of the other Nucleo-64 and Nucleo-32 
 boards provide an STM32 MCU with the integrated Ethernet controller. This means that, if 
 you want to develop IoT applications with your Nucleo, you need to use an external 
 expansion board.
  
 WIZnet is a Korean company that reached the popularity thanks to the Arduino board. In 
 fact, its first ethernet controller, the W5100 IC, was the chip used to create the Arduino 
 Ethernet Shield. Starting from the W5100 controller, WIZnet has iterated the development 
 of other similar products. The current best-in-class product is the W5500, which we will 
 study in this chapter.
  
 The W5500 is a monolithic Ethernet controller, with integrated LAN Phyther. Moreover it is 
 a complete network processor, with hardwired TCP/IP stack. The chip is designed to 
 exchange data",NA
26.2.1 How to Use the W5500 Shield and the,ioLibrary_Driver,NA
Module,"As said before, the W5500 mates seamlessly with all sixteen Nucleo boards. The
  Figure 5
 ¹⁷
  
 shows the shield pinout. The SPI interface is routed to D13, D12 and D11 pins, and they 
 correspond to the same pins of the SPI1 peripheral (apart for the Nucleo-F302R8 board 
 where those pins correspond to SPI2 peripheral). The
  Slave Select
  (SS) pin for the W5500 
 pin corresponds to the Arduino D10 pin, while the SS pin for the SD card corresponds to the 
 Arduino D4 pin.
  
  
 Figure 5: The pinout of the W5500 shield
  
 ¹⁷
 The figure is taken from the
  WIZnet website
 (http://bit.ly/2dxjblH).",NA
26.2.2 Socket APIs,"The
  ioLibrary_Driver
  module provides an API to manipulate sockets that resembles the BSD 
 socket API. Even if it is not compatible with it, if you have already worked with BSD API 
 then it will be very easy for you to start working with it.
  
 To initialize a new socket, we can use the function:
  
 int8_t
  socket
 (
 uint8_t
  sn,
  uint8_t
  protocol,
  uint16_t
  port,
  uint8_t
  flag);
  
 where:
  
 •
  sn
 : corresponds to the socket number, and it can range from 0 up to 7 if you are using a 
 W5500 
  
 IC that provides 8 sockets.
  
 •
  protocol
 : this parameter defines the socket protocol type. The W5500 is able to handle 
 three protocol types: TCP, UDP and RAW socket
 ²⁰
 . This parameter can so assume one 
 of the values 
 Sn_MR_TCP
 ,
  Sn_MR_UDP
  and
  Sn_MR_MACRAW
 .
  
 •
  port
 : specify the port number associated to the socket.
  
 •
  flag
 : it is a combination (logical or) of additional configuration parameters listed in
  
 Table 1
 .
  
 On success, the
  socket()
  function returns the
  sn
  value, otherwise it may return
  
 SOCKERR_SOCKNUM 
 to indicate a wrong socket number,
  SOCKERR_SOCKMODE
  to indicate a 
 wrong protocol or
  SOCKERR_-SOCKFLAG
  to indicate an invalid
  flag
  parameter.
  
 Table 1: Socket flag values
  
 Mode
  
 Description
  
 SF_IO_NONBLOCK
  
 SF_ETHER_OWN
  
 SF_IGMP_VER2
  
 SF_MULTI_ENABLE
  
 SF_TCP_NODELAY
  
 SF_BROAD_BLOCK
  
 SF_MULTI_BLOCK
  
 SF_IPv6_BLOCK
  
 SF_UNI_BLOCK
  
 Configures the socket in non-blocking mode 
  
 W5500 can only receive broadcasting packet or packet sent 
 to itself. This parameter applies only to RAW socket 
  
 Enables IGMP version 2 when socket protocol is UDP and 
 the 
 SF_MULTI_ENABLE
  mode is also specified 
  
 Enables multicast mode when socket protocol is UDP 
  
 Configures a TCP socket so that the ACK packet is sent as 
 soon as a data packet is received from the remote peer 
  
 Prevents the socket from receiving broadcast packets when 
 the socket protocol is UDP or RAW 
  
 Prevents the socket from receiving broadcast packets when 
 the socket protocol is RAW 
  
 Prevents the socket from receiving IPv6 packets when the 
 socket protocol is RAW 
  
 Prevents the socket from receiving unicast packets when the
  
 socket protocol is UDP
  
 ²⁰
 A RAW socket is a socket that allows to exchange packets using directly the IP protocol and without any protocol-specific 
 transport layer (that is, TCP or UDP).",NA
26.2.3 I/O Retargeting to a TCP/IP Socket,"In
  Chapter 8
  we have seen how to retarget C terminal I/O functions, like
  printf()
  and
  scanf()
 , 
 to
  
 an UART interface. During the development of IoT applications, it comes really in handy to 
 retarget
  
 I/O to a network socket, so that we can debug our device through a network connection. 
 This is
  
 really useful especially if the device is not under our direct control.
  
 This operation is really easy using a W5500 IC and the relative socket library. The
  
 RetargetInit()
  
 function can be rewritten in the following way:
  
 Filename:
  system/src/retarget/retarget-tcp.c
  
 12
  
 #ifdef RETARGET_TCP
  
 13
  
 14 
 #define STDIN_FILENO 
  
 0
  
 15 
 #define STDOUT_FILENO 1
  
 16 
 #define STDERR_FILENO 2
  
 17
  
 18 
 #ifndef RETARGET_PORT
  
 19 
 #define RETARGET_PORT 5000
  
 20 
 #endif
  
 21
  
 22 
 int8_t
  gSock
  = -1
 ;
  
 23
  
 24 
 uint8_t
  RetargetInit
 (
 int8_t
  sn) {
  
 25 
 gSock
  =
  sn;
  
 26
  
 27 
 /* Disable I/O buffering for STDOUT stream, so that
  
 28 
  
 * chars are sent out as soon as they are printed. */
  
 29 
 setvbuf(stdout,
  NULL
 , _IONBF,
  0
 );
  
 30
  
 31
  
 }
  
 /* Open 'sn' socket in TCP mode with a port number equal
  
 32
  
 * to the value of RETARGET_PORT macro */
  
 33
  
 if
 (socket(sn, Sn_MR_TCP, RETARGET_PORT,
  0
 )
  ==
  sn) {",NA
26.2.4 Setting up an HTTP Server,"The
  Internet/httpServer
  module provides a complete HTTP server implementation built upon 
 the 
 Ethernet
  layer. This module allows you to setup an HTTP server in a few steps, especially 
 if you need just to serve static content (that is, simple webpages that do not need to process 
 data dynamically).
  
 The function
  
 void
  httpServer_init
 (
 uint8_t
  *
  tx_buf,
  uint8_t
  *
  rx_buf,
  uint8_t
  cnt,
  uint8_t
  *
  socklist);
  
 is used to configure the HTTP module. It accepts two pointers,
  tx_buf
  and
  rx_buf
 , to two 
 memory buffers used to store data exchanged by the HTTP server. These arrays need to 
 have a sufficient amount of space to store HTTP headers. In fact, when accessing to a 
 webpage, the browser needs to exchange with the webserver several “underlying” 
 messages defined by the HTTP protocol. These messages consume several hundreds of 
 bytes, and for this reason a minimum viable size for both 
 tx_buf
  and
  rx_buf
  buffers is equal to 
 1024 bytes
 ²¹
 . The
  cnt
  parameter says to the HTTP module how many W5500 sockets it can 
 use, and the
  socklist
  parameter is used to pass the exact list of available sockets.
  
 For example, the following code fragment initialize the HTTP server by passing two buffers, 
 each one sized 1024 bytes, and an array containing the list of sockets to use to process 
 HTTP requests:
  
 #define DATA_BUF_SIZE 1024
  
 #define MAX_HTTPSOCK 5
  
 uint8_t
  RX_BUF[DATA_BUF_SIZE], TX_BUF[DATA_BUF_SIZE];
  
 uint8_t
  socknumlist[]
  =
  {
 0
 ,
  1
 ,
  2
 ,
  3
 ,
  4
 };
  
 ...
  
 httpServer_init(TX_BUF, RX_BUF, MAX_HTTPSOCK, socknumlist);
  
 ...
  
 Once the HTTP server is configured from the network point of view, we need to make it 
 aware of the content to serve (HTML pages, images, and so on). There are two ways to 
 perform this: one is suitable for really small and limited applications, and the other one for 
 more complex and structured web applications.
  
 By using the function:
  
 void
  reg_httpServer_webContent
 (
 uint8_t
  *
  content_name,
  uint8_t
  *
  content);
  
 we can associate to a given resource (for example the file
  index.html
 ) an array of bytes to 
 send over the socket to the browser. The
  content_name
  parameter corresponds to the 
 resource name and the 
 content
  one to the array containing the bytes forming the resource.",NA
27. Getting Started With a New ,NA,NA
Design,"If you use STM32 microcontrollers for work, or you are going to create your latest funny 
 project as a hobbyist, soon or later you will need to leave a development kit like the Nucleo, 
 and you have to design a custom board around a given STM32 MCU. For every hardware 
 engineer this is always an exciting process. You start from an idea, or a list of requirements, 
 and you will obtain a piece of hardware able to do magic things.
  
 The development process of a new board can be divided in two main steps: the hardware 
 design part, related to components selection and placement, and the software development 
 part, that consists in a starting configuration and all the code needed to make the board 
 working. This chapter aims to provide a brief introduction to this topic. The chapter is 
 logically divided in two parts: one related to the hardware design and one to software. Even 
 if you are one of those lucky people working in companies where the hardware engineer is 
 a separated figure from the firmware developer, it is strongly suggested to have a look at 
 this chapter, which is essentially based on the hardware design. Otherwise, if you are the 
 classical
  one man band
 ¹
 , reading this chapter at least once could help you if you are totally 
 new to the STM32 world.",NA
27.1 Hardware Design,"If you come from simpler microcontroller architectures, like the ATMEL AVR ATMega328p 
 used for the Arduino UNO, you may be familiar with some “artistic things” that often appear 
 on the web (
 Figure 1
  is an example
 ²
 ). A lot of projects arise from a breadboard, few 
 passives and several tons of wires. And they work great too.
  
 However, if you are going to make a new board with an STM32 MCU, you have to 
 completely forget this kind of design. This is because not only do not exist STM32 
 microcontrollers provided in a THT package. These MCUs require that special attention 
 must be placed to the PCB layout process, even for the low-cost line STM32F030. The PCB 
 design become really critical if you are planning to use the fastest STM32 MCUs, like the F4 
 and F7 series, in conjunction with external devices like fast QSPI memories and external 
 SDRAM.
  
 ¹
 Like this author is :-)
  
 ²
 The picture was taken from
  this 
 site
 (https://degreesplato.wordpress.com)",NA
27.1.1 PCB Layer Stack-Up,"Every time you start a new design based on a microcontroller, you need to decide which 
 PCB technology best fits your design and BOM cost, keeping in mind this important axiom: 
 the faster your board goes, the more PCB layers are required. And this also true for STM32 
 MCUs. Even if it is not rare to see some low-cost 8-bit MCUs soldered on a single layer CEM 
 PCB
 ⁴
 , for an STM32 MCU a 2-layers board is the minimum requirement. But, if you are 
 planning to use the fastest versions of the STM32F4 series (like the STM32F446 MCU able 
 to run up to 180MHz) or the latest STM32F7, then you have to consider a 4-layers PCB as 
 minimum requirement
 ⁵
 .
  
 Multi-layers PCBs have several advantages compared to 2-layers ones:
  
 • More layers simplify the routing process, and this is really important if you have space 
  
 constraints or if you need to route differential pair nets.
  
 • They allow better routing for power as well as ground connections; if the power is also 
 on a 
  
 plane, it is available to all points in the circuit simply by adding vias.",NA
27.1.2 MCU Package,"The MCU package choice is often related to the whole PCB technology. STM32 MCUs are 
 provided in several package variants (take a look at the
  final appendix
  to see the list of 
 available packages). The most common and “simple to use” packages are the LQFP ones, 
 like the LQFP-64 package used for all Nucleo boards. Packages with exposed pins have 
 several advantages:
  
 • They are easy to solder, even by hand for really low-volume productions or for 
 prototypes. With a little bit of practice, they can be soldered with the
  drag soldering
  
 technique
 ⁶
 , or simply placed on a PCB pre-covered with the solder paste using a 
 stencil.
  
 • They are easy to inspect using conventional
  Automatic Optical Inspection
  (AOI) 
 machines, and 
  
 they do not require x-ray inspection, which increases the production 
 cost of your boards.
  
 • They cost less for low and mid-volume productions, compared to other type of 
 packages.• They can be used on 2-layers low class PCBs (even a pattern class equal to 6 
 is sufficient
 ⁷
 ), 
  
 different from other packages (like the BGA ones) that usually require 
 more advanced PCB 
  
 due the use of vias with a really reduced annular ring.
  
 • They provide a lot of signal I/O to interface external peripherals (this is obviously, but 
 it is 
  
 always good to remark it).
  
 However, if space is a strict requirement for your design, then you have to consider BGA 
 and similar packages, which offer more signal I/O in a smaller footprint.",NA
27.1.3 Decoupling of Power-Supply Pins,"A really important design step is the decoupling of every power supply pair (VDD, VSS). The 
 key aspects can be summarized here:
  
 • Each power couple (VDD, VSS) should be connected to a parallel ceramic capacitor of 
 about 
  
 100nF (which is a widespread proven value) plus one 4.7uF ceramic 
 capacitor for the overall 
  
 MCU. It is best to choose 0805 or smaller capacitors (the 
 smaller is the better is, since smaller 
  
 capacitors have less ESR - for an STM32F7, 0402 
 capacitors is an option to consider). These 
  
 capacitors need to be placed as close as 
 possible to the appropriate pins, or the underside of the 
  
 PCB if a BGA package is 
 used for the fastest STM32 MCUs. If a ground plane is used, it is safe 
  
 to connect 
 VSS pins directly to the ground plane if this is extensive in the area of that pin.• This 
 author also uses a large electrolytic capacitor (typically 10 uF - a tantalum capacitor is 
  
 also OK if your budget allows it) no more than 3cm away from the chip. The purpose of 
 this 
  
 capacitor is to be a reservoir of charge to supply the instantaneous charge 
 requirements of the 
  
 circuits locally so the charge need not come through the 
 inductance of the power trace.• A small ferrite bead (with an impedance ranging from 
 600 to 1000Ω) placed in series between 
  
 the analog power supply (AVDD) and 
 digital power supply (VDD)
 ⁸
 . It is used to:
  
 –
  Localizes the noise in the system.
  
 –
  Keeps external high frequency noise from the IC.
  
 –
  Keeps internally generated noise from propagating to the rest of the system.
  
 • If your STM32 MCU provides a VBAT pin, it can be connected to the external battery 
 (1.65 V < VBAT < 3.6 V). If no external battery is used, it is recommended to connect 
 this pin to VDD with a 100nF external ceramic decoupling capacitor.
  
 Figure 2
  shows the reference schematics of an STM32F030CC MCU, while
  Figure 3
  shows 
 the typical layout style used by this author to proper decouple power pins. As you can see, a 
 solid ground plane ensures that decoupling capacitors are connected to the ground with 
 the shortest possible path
 ⁹
 .
  
 This document¹⁰
  from Texas Instruments is a good introduction to this topic.
  
 ⁸
 ST discourages the use of this ferrite if VDD is below 1.8V.
  
  
  
 ⁹
 However, keep in mind that the grounding scheme depends on the actual implementation. Some designs need a strong 
 separation between analog and digital ground, plus some EMC-friendly devices (like ferrite beads) to connect them. Welcome to the 
 “obscure” world of EMC :-)
 ¹⁰
 http://bit.ly/29pk0J9",NA
27.1.4 Clocks,"If your design needs an external clock source, either the LSE or HSE one, special attention 
 must be placed to the position of the external crystal and the selection of the capacitors 
 used to match its load capacitance (this value is established by the crystal manufacturer, 
 and it must be carefully checked during the selection process).
  
 ST provides a really excellent guide (
 AN2867¹¹
 ) about oscillator design. Summarizing that 
 guide is outside the scope of this paragraph, so I strongly suggest to have a look at that 
 application note. However, it is important to underline some things.
  
 The most starting up errors (that is, the MCU does not want to properly boot in our final 
 design when the external crystal is used) arises from bad choice of the external capacitors 
 and bad placing of the crystal. For example, assuming a stray capacitance equal to 5pF and 
 a crystal capacitance equal to 15pF, the following formula can be used to compute the value 
 of external capacitors:
  
 C
 1
 ,
 2
  = 2(
 C
 L
  -
  C
 stray
 ) = 2(15pF - 5pF) = 20pF.
  
 Moreover, it is best to place the crystal as close as possible to the MCU pins, surrounding it 
 by a separated ground plane, in turn connected to the bottom ground plane, as shown in
  
 Figure 4
  (the bottom ground plane is not shown).
  
 ST shows several “bad examples” in its Application Note. Moreover, all STM32 MCUs 
 provide a really useful feature to debug external oscillator issues: the
  Clock Security System
  
 (CSS). CSS is a self-diagnostic peripheral that detects the failure of the HSE. If this happens, 
 HSE is automatically disabled (this means that the internal HSI is automatically enabled) 
 and a NMI interrupt is raised to inform the software that something is wrong with the HSE. 
 So, if your board refuses to work correctly, I strongly suggest you to write down the 
 exception handler for NMI, as described in 
 Chapter 10
 . If the code hangs inside it, then 
 there is a problem with your oscillator design.
  
 Finally, consider that a lot of EMC issues come from bad placing of external clocks. Pay 
 attention to the instructions contained in the ST application note.
  
  
 The most of STM32 MCUs allow to connect an external or internal clock source (a 
 PLL, the HSI or HSE and so on) to an output pin, called
  Master Clock Output
 (MCO). 
 This is useful in some application, where this clock source may be used to drive an 
 external IC or in audio
  
 applications. However, pay attention to avoid long traces between the MCU and the 
 device connected to the MCO pin. In this case you have to consider the MCU like a 
 normal clock source, and hence you have to pay attention both to the length of the 
 trace and to cross-talks between MCO and other adjacent or underlying traces.
  
 ¹¹
 http://bit.ly/1RFYZbZ",NA
27.1.5 Filtering of RESET Pin,"To avoid unwanted reset of your board, it is strongly recommended to connect a 
 decoupling capacitor (100nF is a proven value) between the RESET pin (named
  NRST
 ) and 
 the ground, even if your design does not require the use of the reset pin.",NA
27.1.6 Debug Port,"In order to develop and test the firmware for the new board, or to simply upload it to 
 production devices, you need a way to interact with the target STM32 MCU using its debug 
 port. STM32 MCUs offer several ways to debug them. One of this is through the use of the
  
 Serial Wire Debug
  (SWD) interface. SWD replaces the traditional JTAG port, using a clock 
 line (named
  SWDCLK
 ) and a single bi-directional data pin (named
  SWDIO
 ¹²
 ), providing all the 
 normal JTAG debug and test functionality plus real-time access to system memory without 
 halting the processor or requiring any target resident code (the condition for this to 
 happen is that the SWD related I/O are not remapped to a different function - e.g. a general 
 purpose output GPIO). Moreover, it is possible to use any ST-LINK debugger as debug 
 device for your custom boards: all ST development boards (and, hence, the Nucleo too) are
  
 ¹²
 Sometimes, ST refers to these lines also as
  SWCLK
  and
  SWIO
 .",NA
27.1.7 Boot Mode,"Depending on the specific microcontroller model you are going to use in your design, 
 STM32 MCUs can load firmware from different sources: internal or external flash, internal 
 or external SDRAM, USART and USB are the most common sources for starting the 
 firmware execution. This is a really exciting feature of this platform described in
  Chapter 
 22
 .
  
 This happens thanks to the fact that several boot loaders are pre-programmed in the
  
 System memory 
 (the sub-region of code area starting from
  0x1FFF F000
 ) during the MCU 
 production. Each boot loader can be selected configuring one or two pins named
  BOOT0
  and
  
 BOOT1
 ¹³
 .
  
 The default behaviour, that is the regular boot from the internal flash, is obtained pulling to 
 the ground at least BOOT0 pin and leaving BOOT1 pin (if present) floating. Once the 
 firmware starts the execution, you can reuse BOOT pins as general I/O.",NA
27.1.8 Pay attention to “pin-to-pin” Compatibility…,"A lot of STM32 microcontrollers are designed to be pin-to-pin compatible with other MCUs 
 in the same series and between different series. This allows you to “simply” switch to a 
 more/less performant model in case you need to adapt your design for budget reasons or if 
 you are looking for a more powerful MCU.
  
 However, the pin-to-pin compatibility is a feature that needs to be planned during the MCU 
 selection process, even for MCUs belonging to the same STM32 series. Let us consider this 
 example
 ¹⁴
 . Suppose that you decide to use an STM32 MCU from the STM32F030 catalogue, 
 and suppose that you choose the STM32F030R8 MCU, the one equipping the STM32F030 
 Nucleo. As soon as the board design is finished, and gerber files are sent to the PCB fab, you 
 start developing the firmware (this is what often happens especially if you have to 
 complete the project one day before you start developing it). After a while, you discover 
 that the 8k of SRAM provided by this MCU are not sufficient for your project. So, you decide 
 to switch to the STM32F030RC model, which provides 32K of SRAM and 256K of internal 
 flash. However, after struggling several hours trying to understand why you cannot flash it, 
 you discover that this model requires four additional power sources (PF4, PF5, PF6 and 
 PF7), as you can see in
  Figure 7
 .
  
  
 Figure 7: The STM32F030RC MCU requires four additional power sources compared to the STM32F030R8 
 one
  
 So, how to avoid these kind of mistakes? The best option is to
  plan for the worst case
 . In this 
 specific case you may do a layout of your board that connects those pins (PF4, PF5, PF6 and 
 PF7) to power sources even if you are going to use the STM32F030R8 model (being those 
 pins regular I/O pins, it is ok to connect them to VDD and VSS, in parallel with decoupling 
 capacitors).",NA
27.1.9 …And to Selecting the Right Peripherals,"The most of STM32 MCUs have multiple peripherals of a given type (SPI1, SPI2, etc.). This is 
 a good thing for complex designs with multiple modules, but special care must be placed 
 during the peripheral selection even for simple designs. And this is not only a problem 
 related to the I/Os allocation. For example, suppose that you are basing your design on an 
 STM32F030 MCU, and suppose that your design needs an UART and a SPI interface. You 
 decide to use UART1 and SPI2 peripherals. During the firmware development, for 
 performance reasons you decide to use both of them in DMA mode. However, looking to
  
 Table 1
  in Chapter 9
  you can see that it is not allowed to use
  SPI2_TX
  and
  USART1_RX
  in DMA 
 mode simultaneously (they share the same channel). So, it is best to plan these software 
 design choices while you are writing down the schematics.
  
 If you are designing a device that will enter deeper sleep modes, like the
  standby
  one, and 
 you want your device to be woken up by the user (maybe by pressing a dedicated button), 
 then remember that usually just two I/Os can be used to this task (they are called
  wake up 
 pins
 ). So, avoid to assign those pins to other usages.",NA
27.1.10 The Role of CubeMX During the Board Design Stage,"It happens really often to me to talk with people about CubeMX. A lot of them have a wrong 
 consideration of what CubeMX is. Some of them consider it as a totally useless tool. Others 
 limit its usage to the software development stage.
  There is nothing more wrong
 .
  
 CubeMX is probably more useful during the hardware design process (both when drawing 
 schemat-ics and when doing board layout) than in the firmware development stage. Once 
 you get familiar with the CubeHAL, you will stop to use CubeMX as a tool for the IDE project 
 generation
 ¹⁵
 . But CubeMX is essential during the design stage, unless you are going to 
 reuse previous designs or to base your projects always on few types of STM32 MCUs.
  
 The most important part of CubeMX during the board design is the
  Chip view
 . Thanks to 
 this representation you can “preview” in your mind the layout of the MCU part, and 
 eventually adopt different layout strategies.
  
 CubeMX is a tool that can be used iteratively. Let us me explain this concept better with an 
 example. Suppose that you need to design a board based on an STM32F030C8Tx MCU. It is 
 an LQFP-48 MCU from the F0 line. Suppose also that you need to use:
  
 • Two SPI interfaces (SPI1 and SPI2).
  
 • An I²C interface (I2C1).
  
 • An external low speed clock source 
 (LSE).
  
 • Five GPIOs.
  
 • An UART (UART2).
  
 ¹⁵
 Honestly speaking, what CubeMX generates is not so good from a project organization point of view.",NA
27.1.11 Board Layout Strategies,"The layout of the final board is a sort of “art”, a complex task that involves a deep 
 knowledge of all modules used in your design. This is the reason why in large organizations 
 this work is accomplished by specific engineers.
  
 Here, I would like to provide a brief introduction to the whole process based on my 
 personal experience.
  
 •
  A good layout is all about component placing
 : if you are new to this task, remember 
 that all starts from placing components on the final board. Every board can logically 
 and physically divided in sub-modules: power part, MCU and digital part, analog part 
 and so no. Don’t start routing signals before you have placed all components on the 
 final board. Moreover, a good subdivision in sub-modules allows you to reuse design 
 for different boards.
  
 •
  Follow these steps when doing the layout of an STM32 MCU
 :
  
 –
  start placing the MCU;
  
 –
  if your board need external clock sources, place them immediately close to the 
 MCU pins;
  
 –
  next place all decoupling capacitors needed;
  
 –
  connect power sources to the corresponding power lines or power planes if your 
 layer stackup allows them;
  
 – never forget to tie to the ground BOOT0 pin if needed, and to decouple NRST 
 pin
 ;
  
 –
  if your design need an external SRAM or a fast flash memory, start placing them 
 and route differential pair first;
  
 –
  route all high speed signals;
  
 –
  route remaining signals;
  
 –
  avoid to use too many vias during the signal routing and use CubeMX looking for 
 better alternatives (that is, use other equivalent signal I/Os if possible).",NA
27.2 Software Design,"Once you have completed the hardware design, you can start developing the firmware part. 
 If you have used CubeMX to design the MCU section of your custom board, you should be 
 able to start coding the firmware really quickly. If the CubeMX project observes faithfully 
 the actual board design, you can simply generate the project as we have done for the 
 Nucleo development board, then you can import it inside a new Eclipse project and start 
 working on your application. Nothing different from what described in
  Chapter 4
 .
  
 If you have already developed the firmware using a development board, and you need to 
 adapt it to your custom design, you may proceed in this way:
  
 • Generate a fresh new CubeMX project both for your development board (e.g. the 
 Nucleo-F030), 
  
 enabling the needed peripherals, and for the custom board you have 
 designed.
  
 • Do a comparison between the initialization routines for the used peripherals: if they 
 differ, start replacing them one by one in the project made for the development board, 
 and do a complete project compilation before to continue with the next peripheral. 
 This will allow you to keep the control of what is changing in your firmware.
  
 • To simplify the porting process, never change the peripheral initialization code 
 generated by 
  
 CubeMX, but use CubeMX to change peripheral settings.
  
 • Try to use macros to wrap peripheral handlers. Once you change them, you only need 
 to redefine the macros (for example, if your firmware developed with the Nucleo uses 
 the USART2 peripheral, define a global macro in this way:
  #define USART_PERIPHERAL 
 huart2
  and base your code on that macro; if your new design uses the USART1, then 
 you have to redefine only that macro accordingly).
  
 Remember that CubeMX essentially generates 5 or 6 files. If you reduce the modification to 
 these files at minimum, it will be easy to rearrange the code.
  
 Having a minimum viable firmware made with a development kit helps a lot during the 
 debugging of your custom board. It happens really often that, during the testing of a new 
 board, you are in doubt if your issues arise from the hardware or the software. Knowing 
 that the firmware works simplifies the hardware debugging stage.",NA
27.2.1 Generating the binary image for production,"In large organizations, who effectively loads the binary image of the firmware on the final 
 board is a completely different person. As as engineer, you may be asked to generate an 
 image of the final firmware in
  release mode
 . This is a way to indicate a binary image of the 
 firmware compiled with the highest possible optimization level, in order to reduce the final 
 size of the image, and without including any debug information. This last requirement is",NA
Appendix,NA,NA
A. Miscellaneous HAL functions ,NA,NA
and STM32 features,"This appendix chapter contains an overview of some HAL functions and STM32 features 
 that makes little sense to treat in a separate chapter.",NA
Force MCU reset from the firmware,"Sometimes, when all is lost and we no longer have control of what is happening, the only 
 salvation is to reset the microcontroller. The function
  
 void
  HAL_NVIC_SystemReset
 (
 void
 );
  
 initiates a system reset of the MCU. It uses the
  void NVIC_SystemReset(void)
  provided by the 
 CMSIS package.",NA
STM32 96-bit Unique CPU ID,"The most of STM32 microcontroller provides an unique CPU ID, which is factory-
 programmed. It is read only, and it cannot be changed.
  
 This ID can be really useful in several contexts. For example, it can be used:
  
 • as unique USB device serial number;
  
 • to generate custom license keys;
  
 • for use as security keys in order to increase the security of code in Flash memory while 
 using 
  
 and combining this unique ID with software cryptographic primitives and 
 protocols before 
  
 programming the internal Flash memory;
  
 • to activate secure boot processes, etc.
  
 Unfortunately, the position in memory of this ID is not common to all STM32 
 microcontrollers, but its memory mapped address changes between each STM32-series.
  
 Table 1
  shows the memory-mapped address of the Unique MCU ID for the MCUs equipping 
 the Nucleos.",NA
B. Troubleshooting guide,"Here you can find common issues already reported from other readers. Before posting from 
 any kind of problem you can encounter, it is a good think to have a look here.",NA
GNU MCU Eclipse Installation Issues,"Several readers are reporting me issues in installing GNU MCU Eclipse plug-ins. During the 
 installation, Eclipse cannot access to the packages repository, and the following error 
 appears:
  
  
 This error is caused by Java, which does not support natively strong encryption due to 
 limitations to cryptographic algorithms in some countries. The workaround is described in 
 this stackoverflow answer: http://stackoverflow.com/a/38264878. Essentially, you need 
 to download an additional package (http://bit.ly/2jiC7GE) from the Java website; extract 
 the “.zip” file and copy the content of the
  UnlimitedJCEPolicyJDK8
  directory inside the following 
 dir:
  
 • In Windows:
  C:\Program Files\Java\jre1.8.0_121\lib\security
  
 • In Linux:
 /usr/lib/jvm/java-8-oracle/lib/security
  
 • In MacOS:
  /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/se-
  
 curity
  
 Restart Eclipse. You should be able to install GNU MCU Eclipse plug-ins now.",NA
Eclipse related issue,This section contains a list of frequently issues related with the Eclipse IDE.,NA
Eclipse cannot locate the compiler,"This is a problem that happens frequently on Windows. Eclipse cannot find the compiler 
 installation folder, and it generates compiling errors like the ones shown below.
  
  
 This happens because the GNU MCU plug-in cannot locate the GNU cross-compiler folder. 
 To address this issue, open the Eclipse preferences clicking on the
  Window->Preferences
  
 menu, then go to
  C/C++->Build->Global Tools Paths
  section. Ensure that the
  Build tools 
 folder
  path points to the directory containing the Build Tools (
 C:\STM32Toolchain\Build 
 Tools\bin
  if you followed the instructions in Chapter 3, or arrange the path accordingly), and 
 the
  Toolchain folder
  paths point to the GCC ARM installation folder (
 C:\STM32Toolchain\gcc-
 arm\bin
 ). The following image shows the right configuration:",NA
Eclipse continuously breaks at every instruction during debug ,NA,NA
session,"If you have not enabled the
  instruction stepping mode
 , this happens because you have 
 defined too many hardware breakpoints. Please, consider that the number of hardware 
 breakpoints is limited for every Cortex-M family, as shown in the following table:
  
 Available breakpoints/watchpoints in Cortex-M cores
  
 Cortex-M
  
 Breakpoints
  
 Watchpoints
  
 M0/0+
  
 4
  
 2
  
 M3/4/7
  
 6
  
 4
  
 To check the used breakpoints in your application, go to the
  Debug perspective
 , then in the 
 Breakpoints
  pane (see figure below) and disable or delete unneeded breakpoints.",NA
The step-by-step debugging is really slow,"This happens when the
  Disassembly view
  is enabled, as shown below.
  
  
 Eclipse needs to reload ARM assembly instructions at every steps (one C instruction can 
 correspond to a lot of assembly instructions), and this really slows down the debugging 
 session. It is not an issue related to OpenOCD or the ST-LINK interface, but instead is just an 
 overhead connected with Eclipse. Switch to another view (or simply close the
  Disassembly 
 view
 ) to resolve the issue.",NA
The firmware works only under a debug session,"This happens because, by default, projects generated with the GNU MCU Eclipse plugin 
 have the 
 semihosting
  support enabled. As described in
  Chapter 5
 , ARM
  semihosting
  relies on 
 the ARM assembly
  BKPT
  instruction, which halts the CPU execution waiting for an action of 
 the debugger. Even if we do not use none of the tracing routines provided by the tool-chain, 
 the startup routines made by Liviu Ionescu use semihosting to print CPU register at 
 firmware 
 startup 
 (you 
 can 
 take 
 a 
 look 
 at 
 the
  
 _start()
  
 routine 
 inside 
 the
  
 system/src/newlib/_startup.c
  file). So, to avoid MCU from halting when not under a 
 debug session, we can disable
  semihosting
  by removing the macro 
 OS_USE_SEMIHOSTING
  at 
 project level, as described in Chapter 5.",NA
STM32 related issue,"This section contains a list of frequently issues related with the programming of STM32 
 microcon-trollers.",NA
The microcontroller does not boot correctly,"Although this might seem strange, there is a quite long list of reasons why an STM32 
 refuses to boot properly. This issue usually has the following symptoms:
  
 • the firmware does not start.
  
 • the Program Counter points to a completely invalid address (usually
  0xfffffffd
  or
  0xfffffffe
 , 
 but other addresses of the 4GB memory space are possible too), as shown by Eclipse 
 during the debug session.
  
  
 To resolve this issue we need to distinguish between two cases: if you are developing the 
 firmware for a development board like the Nucleo or for a custom designed board (this 
 difference is just to simplify the analysis).",NA
It is Not Possibile to Flash or to Debug the MCU,"Sometimes it happens that it is not possible to flash the MCU or to debug it using OpenOCD. 
 Another recognizable symptom in that the ST-LINK LD1 LED (the one that blinks red and 
 green alternatively while the board is under debugging) stops blinking and remains frozen 
 with both the LEDs ON.
  
 When this happens, it means that the ST-LINK debugger cannot access to the debug port 
 (through SWD interface) of the target MCU or the flash is locked preventing its access to the 
 debugger. There are usually two reasons that leads to this faulty condition:
  
 • SWD pins have been configured as general-purpose GPIOs (this often happens if we 
 perform 
  
 a reset of pins configuration in CubeMX).
  
 • The MCU is in a deep low-power mode that turns off the debug port.
  
 • There is something wrong with the
  option bytes
  configuration (probably the flash has 
 been 
  
 write protected or read protection level 1 is turned on).
  
 To address this issue, we have to force ST-LINK debugger to connect to the target MCU 
 while keeping its nRST pin low. This operation is called
  connection under reset
 , and it can 
 be performed by using the STM32CubeProgrammer tool, by selection the
  Hardware reset
  
 mode inse the
  Reset mode
  combo box, as shown below.
  
  
 The same operation can be performed in OpenOCD, but with several additional steps. First 
 of all, we must say to OpenOCD to “connect under reset” by modifying the configuration file 
 of our board (for example, for a Nucleo-F0 we have to modify the file
  board/st_nucleo_f0.cfg
 ). 
 In that file you will find the
  reset_config
  command, which must be called in this other way:
  
 reset_config srst_only connect_assert_srst
  
 Next, we have to execute OpenOCD and connect to telnet console on the 4444 port, and 
 issuing the 
 reset halt
  command:
  
 $
 telnet localhost
  4444
  
 >
  reset halt
  
 Now it should be possible to reprogram the MCU again, or eventually perform a mass erase.",NA
C. Nucleo pin-out,"In the next paragraphs, you can find the correct pin-out for all Nucleo boards. The pictures 
 are taken from the
  mbed.org website¹⁶
 .
  
 Nucleo Release
  
 Nucleo-F446RE 
  
 Nucleo-F411RE 
  
 Nucleo-F410RB 
  
 Nucleo-F401RE 
  
 Nucleo-F334R8 
  
 Nucleo-F303RE 
  
 Nucleo-F302R8 
  
 Nucleo-F103RB 
  
 Nucleo-F091RC 
  
 Nucleo-F072RB 
  
 Nucleo-F070RB 
  
 Nucleo-F030R8 
  
 Nucleo-L476RG 
  
 Nucleo-L152RE 
  
 Nucleo-L073RZ 
  
 Nucleo-L053R8
  
 ¹⁶
 https://developer.mbed.org/platforms/?tvend=10",NA
Nucleo-F446RE ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F411RE ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F410RB ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F401RE ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F334R8 ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F303RE ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F302R8 ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F103RB ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F091RC ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F072RB ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F070RB ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-F030R8 ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-L476RG ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-L152RE ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-L073R8 ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
Nucleo-L053R8 ,NA,NA
Arduino compatible headers,NA,NA
Morpho headers,NA,NA
D. STM32 packages,"Here you will find the most common packages used for STM32 MCU. They are here only as 
 quick reference. The images are taken from official ST Microelectronics datasheets. They 
 are therefore copyright of ST Microelectronics.",NA
LFBGA,NA,NA
LQFP,NA,NA
TFBGA,NA,NA
TSSOP,NA,NA
UFBGA,NA,NA
UFQFPN,NA,NA
VFQFP,NA,NA
WLCSP,NA,NA
E. History of this book,"Being this an in-progress book, it is interesting to publish a complete history of 
 modifications.",NA
Release 0.1 - October 2015,"First public version of the book, made of 5 chapters.",NA
"Release 0.2 - October 28th, 2015","This release contains the following fixes:
  
 • Changed the
  Table 1 in Chapter 1
 : it wrongly stated that Cortex-M0/0+ allows 16 
 external 
  
 configurable interrupts. Instead, it is 32.
  
 • Paragraph 1.1.1.6 wrongly stated that the number of cycles required to service an 
 interrupt is 12 for all Cortex-M processors. Instead it is equal to 12 cycles for all 
 Cortex-M3/4/7 cores, 15 cycles for Cortex-M0, 16 cycles for Cortex-M0+.
  
 • Fixed a lot of errors in the text. Really thanks to Enrico Colombini (aka Erix -
  
 http://www.erix. 
  
 it
 ) who is doing this dirty job.
  
 This release adds the following chapters:
  
 • Chapters 6 about GPIOs management.
  
 • Added a troubleshooting section in the appendix.
  
 • Added a section in the appendix about miscellaneous HAL functions.",NA
"Release 0.2.1 - October 31th, 2015","This release contains the following fixes:
  
 • Changed again the
  Table 1 in Chapter 1
 : it did not indicate which Cortex exceptions are 
 not 
  
 available in Cortex-M0/0+ based processors.
  
 • Added several remarks to Chapter 4 (thanks again to Enrico Colombini) that better 
 clarify some steps during the import of CubeMX generated output in the Eclipse 
 project. Moreover, it is better explained why the
  startup file
  differs between Cortex-
 M0/0+ and Cortex-M3/4/7 processors.",NA
"Release 0.2.2 - November 1st, 2015 ","This release contains the following fixes:
  
  
 • Changed in Chapter 4 (
 ∼
 pg. 140) the description of project generated by CubeMX, since 
 ST has 
  
  
 updated the template files after this author submitted a bug report. Now the code 
 generated is 
  
  
 generic and works with all Nucleo boards (even the F302 one).",NA
"Release 0.3 - November 12th, 2015 ","This release contains the following changes:
  
  
 • Tool-chain installation instructions have been successfully tested on Windows XP, 7, 
 8.1 and 
  
  
 the latest Windows 10.
  
 • Added in chapter 4 the description of the CubeMXImporter, a tool made by this author 
 to automatically import a CubeMX project into an Eclipse project made with the GNU 
 MCU plug-in.
  
 This release adds the following 
 chapter:
  
  
 • Chapter 7 about NVIC 
 controller.",NA
"Release 0.4 - December 4th, 2015 ","This release contains the following changes:
  
  
 • Added in Chapter 5 the definition of
  freestanding 
 environment
 .
  
 • Figures 11 and 12 in Chapter 5 have been updated to better clarify the signal levels.
  
 • Added a paragraph about 96-bit Unique-ID in the Appendix A.
  
 This release adds the following 
 chapter:",NA
"Release 0.5 - December 19th, 2015 ","This release adds the following chapter:
  
  
 • Chapter 9 about how to start a new custom design with STM32 
 MCUs.",NA
"Release 0.6 - January 18th, 2016","This release adds the following chapter:
  
 • Chapter 9 about DMA controller and HAL_DMA module.",NA
"Release 0.6.1 - January 20th, 2016","This release contains the following changes:
  
 • Better clarified in paragraphs 7.1 and 7.2 the relation between NVIC and EXTI 
 controller.• In chapter 9 clarified that the BusMatrix also allows to automatically 
 interconnect several 
  
 peripherals between them. This topic will be explored in a 
 subsequent chapter.
  
 • Clarified at page 266 that the we have to enable the DMA controller, using the macro
  
 __DMA1_-
  
 CLK_ENABLE()
 , before we can use it.",NA
"Release 0.6.2 - January 30th, 2016","This release contains the following changes:
  
 • The
  Figure 4
  in Chapter 1, and the text describing it, was completely wrong. It wrongly 
 placed the boot loaders at the beginning of code area (
 0x0000 0000
 ), while they are 
 contained inside the
  System memory
 . Moreover, the role of the aliasing of flash 
 addresses is better clarified, both there and in Chapter 7.
  
 • Better clarified the role of
  I-Bus
 ,
  D-Bus
  and
  S-Bus
  in Chapter 9.
  
 • Fixed several errors in the text. Really thanks to Omar Shaker who is helping me.",NA
"Release 0.7 - February 8th, 2016","This release adds the following chapter:
  
 • Chapter 10 about memory layout and liker scripts.• 
 Appendix C with correct pin-out for all Nucleo 
 boards.
  
 This release also better introduces the whole Nucleo lineup in Chapter 1. Moreover, BB-8 
 droid by Sphero is now among us. We welcome BB-8 (can you find it? :-)).",NA
"Release 0.8 - February 18th, 2016","This release adds the following chapter:
  
 • Chapter 10 about clock tree configuration.
  
 This release contains the following changes:
  
 • In paragraph 4.1.1.2 the meaning of each IP Tree pane symbol has been better 
 clarified.• Fixed several errors in the text. Again, really thanks to Omar Shaker who 
 is helping me.",NA
"Release 0.8.1 - February 23th, 2016","This release contains the following changes:
  
 • The GCC tool-chain has been updated to the latest 5.2 release. There is nothing special 
 to report.",NA
"Release 0.9 - March 27th, 2016","This release adds the following chapter:
  
 • Chapter 11 about timers.
  
 This release contains the following changes:
  
 • The paragraph 9.2.6 has been updated: after several tests, I reach to the conclusion 
 that the 
 peripheral-to-peripheral
  transfer is possible only if the bus matrix is expressly 
 designed to trigger transfers between the two peripherals.
  
 • The paragraph 9.2.7 has been completely rewritten to better specify how to use the
  
 HAL_UART 
  
 module in DMA mode.
  
 • Added the paragraph 9.4 that explains the correct way to declare buffers for DMA 
 transfers.• Added the paragraph 10.1.1.1 about the MSI RC clock source in STM32L 
 MCUs.
  
 • Added the paragraph 10.1.3 about clock source options in Nucleo boards.
  
 • Added in Appendix C the Nucleo-L073 and Nucleo-F410 pinout diagrams.",NA
"Release 0.9.1 - March 28th, 2016",This release contains the following changes:,NA
"Release 0.10 - April 26th, 2016","This release adds the following chapter:
  
 • Chapter 12 about low-power modes.
  
 This release contains the following changes:
  
 • Explained in paragraph 6.2.2 why the field
  GPIO_InitTypeDef.Alternate
  is missed in CubeF1 
  
 HAL.
  
 • Fixed example 3 in Chapter 9. The example contained two errors, one related to the
  
 EXTI2_3_-IRQHandler()
  and one to the priority of IRQs. The code in the book examples 
 repository was instead correct.
  
 • Added few words about I/O debouncing at page 207.
  
 • The paragraph 7.6 has been completely rewritten to cover also the
  BASEPRI
  register.
  
 • Added the paragraph 11.3.3 about how to generate timer-related events by software.• 
 ST engineers have changed the way a peripheral clock is enabled/disabled: now all the 
  
 __<PPP>_CLK_ENABLE()
  macros have been renamed to
  __HAL_RCC_<PPP>_CLK_ENABLE()
 . The 
  
 whole book has been updated. However, they are still laving the old macro available 
 for 
  
 compatibility.",NA
"Release 0.11 - May 27th, 2016","This release adds the following chapter:
  
 • Chapter 14 about FreeRTOS.
  
 This release contains the following changes:
  
 • Changed
  Figure 16
  in Chapter 7: the temporal sequences of ISR B an C were wrong.• 
 Changed
  Figure 17
  in Chapter 7: the sub-priority of ISRs B and C were wrong, because 
  
 according that execution sequence, the right sub-priority is 0x0 for C and 0x1 for B.
  
 • Added another figure in Chapter 7 (the actual Figure 20), which better explains what 
 happens when the
  priority grouping
  is lowered from 4 to 1 in that example. Thanks to 
 Omar Shaker that helped me in refining this part.
  
 • Paragraph 11.3.10.4 has been completely rewritten to better describe the update 
 process of 
  
 TIMx->ARR register.
  
 • Clarified in Chapter 9 that, when using the UART in DMA mode, it is also important to 
 enable the corresponding UART interrupt and to add a call to the
  HAL_UART_IRQHandler()
  
 from the ISR.
  
 • Added an
  Eclipse intermezzo
  at the end of Chapter 6: it shows how to customize Eclipse 
  
 appearance with themes.
  
 • Added paragraph 12.3.3 regarding an important issue encountered with STM32F103 
 MCUs.
  
 • Now the book has a brand new and professionally designed cover ;-)",NA
"Release 0.11.1 - June 3rd, 2016 ","This release contains the following changes:
  
  
 • Better explained the
  vector table
  relocation process in 13.3.1 (in the previous releases 
 of the 
   
 book, the physical copy of the
  .ccm
  section from the flash memory to the CCM 
 one was missed). 
  
  
 The example 6 has been changed accordingly.",NA
"Release 0.11.2 - June 24th, 2016 ","This release contains the following changes:
  
  
 • Tool-chain installation instruction have been updated to Eclipse 4.6 (Neon) and 
 GCC 5.3.",NA
"Release 0.12 - July 4th, 2016","This release adds the following 
 chapter:
  
  
 • Chapter 12 about ADC.
  
 This release contains the following changes:
  
  
 • Better clarified in paragraph 7.2 the difference between enabling an interrupt at NVIC 
 level 
   
 and at the peripheral level.",NA
"Release 0.13 - July 18th, 2016","This release adds the following 
 chapter:
  
  
 • Chapter 13 about DAC.",NA
"Release 0.14 - August 12th, 2016","This release adds the following chapter:
  
  
 • Chapter 17 about flash memory 
 management.",NA
"Release 0.15 - September 13th, 2016","This release adds the following chapter:
  
  
 • Chapter 17 about booting process in STM32 
 microcontrollers.
  
 This release contains the following changes:
  
  
 • Equation [4] in Chapter 9 was wrong because, to properly measure the period between 
 two 
   
 consecutive captures, the right formula is the following one (thanks to Davide 
 Ruggiero to 
   
 point me this out):
  
  
 (
  
 TIMx
 _
 CLK
  
 )
 −
 1
  
  
 Period
  =
  Capture ·
  
 (
  
 (
 Prescaler
  + 1)(
 CH
 P rescaler
 )(
 Polarity
 Index
 )
  
  
 [4]
  
 • Described in Chapter 19 how to configure Eclipse to generate binary images of the 
 firmware 
  
 in
  Release
  mode.
  
 • Added a new
  Eclipse Intermezzo
  at the end of the Chapter 7. It explains how to use code 
  
 templates to increase coding productivity.",NA
"Release 0.16 - October 3th, 2016","This release adds the following 
 chapter:
  
  
 • Chapter 14 about I²C 
 peripheral.
  
 This release contains the following changes:
  
  
 • Added the paragraph 16.4 about MPU 
 unit.",NA
"Release 0.17 - October 24th, 2016",NA,NA
"Release 0.18 - November 15th, 2016","This release adds the following chapter:
  
 • Chapter 21 about advanced debugging techniques.
  
 This release contains the following changes:
  
 • Added the paragraph 12.2.6.2 that explains how to perform multiple and not 
 continuous 
  
 conversions in DMA mode.
  
 • Added the paragraph 1.3.7 that briefly mentions the new STM32H7-series.
  
 • OpenOCD installation instructions for Windows, Linux and MacOS have been 
 completely revised. Since the next OpenOCD release (0.10) is still under development, 
 I have decided to use the precompiled packages made by Liviu Ionescu. This because 
 they support the latest STM development boards. Several of you are, in fact, 
 experiencing issues with OpenOCD 0.9. The latest development packages by Liviu 
 should address these issues definitively. Please, Mac users take note that MacOS 
 releases prior to 10.11 (aka El Capitan) are no longer supported.",NA
"Release 0.19 - November 29th, 2016","This release adds the following chapter:
  
 • Chapter 16 about CRC peripheral.",NA
"Release 0.20 - December 28th, 2016","This release adds the following chapter:
  
 • Chapter 17 about IWDT and WWDT timers.",NA
"Release 0.21 - January 29th, 2017","This release adds the following chapter:
  
 • Chapter 24 about FatFs middleware library.
  
 This release contains the following changes:
  
 • Installation instructions have been updated to the latest official OpenOCD 0.10, Eclipse 
 Neon.2 and GCC 5.4.
  Please, take not that the latest ARM GCC 6.x appears to be 
 incompatible with the current GNU MCU Eclipse plug-ins. So keep using the 5.4 
 branch until Liviu fixes incompatibilities
 . Take also note that latest version of 
 Eclipse needs Java SE 8 update 121.",NA
"Release 0.22 - May 2nd, 2017","This release adds the following chapter:
  
 • Chapter 25 about W5500 ethernet processor.
  
 This release contains the following changes:
  
 • Chapter 22 has been updated to the latest FreeRTOS 9.x.
  Please take note that ST still 
 has not 
  
 completed the rollout of latest FreeRTOS release to all STM32 families.
  
 • Equation [1] in Chapter 17 was wrong. Thank you to Michael Kaiser to let me know 
 that.• Instructions in paragraph 23.6 have been updated to better clarify how to retrieve 
 the right 
  
 ST-LINK serial number in Windows.
  
 • Instructions in paragraph 8.3.1 have been updated to better clarify how to install RXTX 
 library 
  
 in Windows.
  
 • ST refactored the
  HAL_IWDG
  and
  HAL_WWDG
  modules. The chapter 17 has been updated 
 to cover 
  
 the new APIs.
  
 • This book is almost finished! Now it is the right time to add an acknowledgments 
 section to 
  
 thank all those people that helped me to make this work possible.",NA
"Release 0.23 - July 20th, 2017","This release adds the following chapter:
  
 • Chapter 18 about RTC.
  
 This release contains the following changes:
  
 • Chapter 4 has been updated to cover CubeMX 4.22 features.
  
 • Updated paragraph 23.3.4 to cover the new behaviour in FreeRTOS 9.x: now if one 
 thread deletes another thread, then the memory allocated by FreeRTOS to the deleted 
 thread is freed immediately.",NA
"Release 0.24 - December 11th, 2017","This release contains the following changes:
  
 • Chapter 1 has been updated to cover the new STM32L4+ family. Moreover, the 
 STM32L4 series 
  
 has been updated to cover the latest MCUs.
  
 • Installation instructions in Chapter 2 have been updated to cover Eclipse Oxygen and 
 the latest 
  
 GNU MCU Eclipse plug-ins.",NA
"Release 0.25 - January 3rd, 2018","This release contains the following changes:
  
 • ST has released a new flashing utility named STM32CubeProgrammer. The big news is 
 that STM32CubeProgrammer is now multi-platform, and it runs on Windows, Mac and 
 Linux. The tool is not yet perfectly stable, but it is a good start. That allowed me to 
 review installation instructions: now there is no longer need to install
  QSTLink2
  and
  
 texane
 .",NA
"Release 0.26 - May 7th, 2018","This release contains the following changes:
  
 • Chapter 1 has been updated to cover the new STM32WB 
 family.• Minor fixes to the text.",NA
