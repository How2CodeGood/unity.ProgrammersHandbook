Larger Text,Smaller Text,Symbol
Discovering the STM32 ,NA,NA
Microcontroller ,"Geoffrey Brown
  
 ©2012 
  
 June 5, 2016
  
 This work is covered by the Creative Commons Attibution-NonCommercial- 
 ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) license. 
 http://creativecommons.org/licenses/by-nc-sa/3.0/ 
  
 Revision: 14c8a1e (2016-06-05) 
  
 1",NA
Contents,"List of Exercises 
  
 7
  
 Foreword 
  
 11
  
 1 
  
 Getting Started 
  
 13
  
 1.1 Required Hardware . . . . . . . . . . . . . . . . . . . . . . . . . 16 
 STM32 VL Discovery  
 . . . . . . . . . . . . . . . . . . . . . . .  
 16 
 Asynchronous Serial . . . . . . . . . . . . . . . . . . . . . . . .  
 19 
 SPI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 20 
 I2C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 21 
 Time Based . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 22 
 Analog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 23 
 Power Supply . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 24 
 Prototyping Materials . . . . . . . . . . . . . . . . . . . . . . .  
 25 
 Test Equipment . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 25 
 1.2 Software Installation . . . . . . . . . . . . . . . . . . . . . . . . 26 
 GNU Tool chain  
 . . . . . . . . . . . . . . . . . . . . . . . . . .  
 27 
 STM32 Firmware Library . . . . . . . . . . . . . . . . . . . . .  
 27 
 Code Template . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 28 
 GDB Server . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 29 
 1.3 Key References . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 
 2 
  
 Introduction to the STM32 F1 
  
 31
  
 2.1 Cortex-M3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 
 2.2 STM32 F1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 
 3 
  
 Skeleton Program 
  
 47
  
 Demo Program . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 48 
 Make Scripts  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 50 
 STM32 Memory Model and Boot Sequence  
 . . . . . . . . . . .  
 52 
 2  
 Revision: 14c8a1e (2016-06-05)",NA
List of exercises,"Exercise 3.1
  GDB on STM32 
  
 . . . . . . . . . . . . . . . . . . . . . 50 
 Exercise 4.1
  Blinking Lights 
  
 . . . . . . . . . . . . . . . . . . . . . . 60 
 Exercise 4.2
  Blinking Lights with Pushbutton 
  
 . . . . . . . . . . . . . 65 
 Exercise 4.3
  Configuration without Standard Peripheral Library 
  
 . . 68 
 Exercise 5.1
  Testing the USB/UART Interface 
  
 . . . . . . . . . . . . 73 
 Exercise 5.2
  Hello World! 
  
 . . . . . . . . . . . . . . . . . . . . . . . 80 
 Exercise 5.3
  Echo 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 
 Exercise 6.1
  SPI Loopback 
  
 . . . . . . . . . . . . . . . . . . . . . . . 91 
 Exercise 6.2
  Write and Test an EEPROM Module 
  
 . . . . . . . . . . 96 
 Exercise 7.1
  Complete Interface Code
  
 . . . . . . . . . . . . . . . . . 101 
 Exercise 7.2
  Display Text 
  
 . . . . . . . . . . . . . . . . . . . . . . . . 102 
 Exercise 7.3
  Graphics
  . . . . . . . . . . . . . . . . . . . . . . . . . . 103 
 Exercise 8.1
  FAT File System 
  
 . . . . . . . . . . . . . . . . . . . . . 118 
 Exercise 9.1
  Reading Wii Nunchuk
  
 . . . . . . . . . . . . . . . . . . 130 
 Exercise 10.1
  Ramping LED 
  
 . . . . . . . . . . . . . . . . . . . . . . 144 
 Exercise 10.2
  Hobby Servo Control
  
 . . . . . . . . . . . . . . . . . . 144 
 Exercise 10.3
  Ultrasonic Sensor 
  
 . . . . . . . . . . . . . . . . . . . . 149 
 Exercise 11.1
  Timer Interrupt – Blinking LED 
  
 . . . . . . . . . . . . 161 
 Exercise 11.2
  Interrupt Driven Serial Communciations 
  
 . . . . . . . 170 
 Exercise 11.3
  External Interrupt 
 Exercise 12.1
  SPI DMA module
  
 . . . . . . . . . . . . . . . . . . . . 173 . . . . . . . . . . . . . . . . 
 . . . . 185 
 Exercise 12.2
  Display BMP Images from Fat File System 
  
 . . . . . . 185 
 Exercise 13.1
  Waveform Generator 
  
 . . . . . . . . . . . . . . . . . . 190 
 Exercise 13.2
  Application Software Driven Conversion 
  
 . . . . . . . 191 
 Exercise 13.3
  Interrupt Driven Conversion
  
 . . . . . . . . . . . . . . 192 
 Exercise 13.4
  Audio Player 
  
 . . . . . . . . . . . . . . . . . . . . . . . 195 
 Exercise 14.1
  Continuous Sampling
  
 . . . . . . . . . . . . . . . . . . 205 
 Exercise 14.2
  Timer Driven Conversion 
  
 . . . . . . . . . . . . . . . 207 
 Exercise 14.3
  Voice Recorder 
  
 . . . . . . . . . . . . . . . . . . . . . . 208 
 6  
 Revision: 14c8a1e (2016-06-05)",NA
Acknowledgment,"I have had a lot of help from various people in the Indiana University 
 School of Informatics in developing these materials. Most notably, Caleb Hess 
 developed the protoboard that we use in our lab, and he, along with Bryce 
 Himebaugh made significant contributions to the development of the various 
 experiments. Tracey Theriault provided many of the photographs. 
 I am grateful to ST Microelectronics for the many donations that al-lowed us to 
 develop this laboratory. I particularly wish to thank Andrew Dostie who 
 always responded quickly to any request that I made. 
 STM32 F1, STM32 F2, STM32 F3, STM32 F4, STM32 L1, Discovery Kit, 
 Cortex, ARM and others are trademarks and are the property of their owners. 
 Revision: 14c8a1e (2016-06-05) 
  
 9",NA
Foreword,"This book is intended as a hands-on manual for learning how to de-sign 
 systems using the STM32 F1 family of micro-controllers. It was written to 
 support a junior-level computer science course at Indiana University. The 
 focus of this book is on developing code to utilize the various peripherals 
 avail-able in STM32 F1 micro-controllers and in particular the STM32VL 
 Discovery board. Because there are other fine sources of information on the 
 Cortex-M3, which is the core processor for the STM32 F1 micro-controllers, 
 we do not examine this core in detail; an excellent reference is “The Definitive 
 Guide to the ARM CORTEX-M3.” [5] 
 This book is not exhaustive, but rather provides a single “trail” to 
 learning about programming STM32 micro controller built around a series of 
 laboratory exercises. A key design decision was to utilize readily available off-
 the-shelf hardware models for all the experiments discussed. 
 I would be happy to make available to any instructor the other materi-
 als developed for teaching C335 (Computer Structures) at Indiana University; 
 however, copyright restrictions limit my ability to make them broadly avail-
 able. 
 Geoffrey Brown  
 Indiana University 
 Revision: 14c8a1e (2016-06-05) 
  
 11",NA
Chapter 1,NA,NA
Getting Started,"The last few years has seen a renaissance of hobbyists and inventors 
 building custom electronic devices. These systems utilize off-the-shelf com-
 ponents and modules whose development has been fueled by a technological 
 explosion of integrated sensors and actuators that incorporate much of the 
 analog electronics which previously presented a barrier to system develop-
 ment by non-engineers. Micro-controllers with custom firmware provide the 
 glue to bind sophisticated off-the-shelf modules into complex custom systems. 
 This book provides a series of tutorials aimed at teaching the embedded pro-
 gramming and hardware interfacing skills needed to use the STM32 family of 
 micro-controllers in developing electronic devices. The book is aimed at read-
 ers with ’C’ programming experience, but no prior experience with embedded 
 systems. 
 The STM32 family of micro-controllers, based upon the ARM Cortex-M3 
 core, provides a foundation for building a vast range of embedded systems 
 from simple battery powered dongles to complex real-time systems such as 
 helicopter autopilots. This component family includes dozens of distinct con-
 figurations providing wide-ranging choices in memory sizes, available periph-
 erals, performance, and power. The components are sufficiently inexpensive 
 in small quantities – a few dollars for the least complex devices – to justify 
 their use for most low-volume applications. Indeed, the low-end “Value 
 Line”components are comparable in cost to the ATmega parts which are used 
 for the popular Arduino development boards yet offer significantly greater 
 perfor-mance and more powerful peripherals. Furthermore, the peripherals 
 used are shared across many family members (for example, the USART 
 modules are common to all STM32 F1 components) and are supported by a 
 single firmware library. Thus, learning how to program one member of the 
 STM32 F1 family 
 Revision: 14c8a1e (2016-06-05) 
  
 13",NA
1.1 ,NA,NA
Required Hardware,"A list of the hardware required for the tutorials in this book is provided 
 in Figure 1.1. The component list is organized by categories corresponding to 
 the various interfaces covered by this book followed by the required pro-
 totyping materials and test equipment. In the remainder of this section, I 
 describe each of these components and, where some options exist, key prop-
 erties that must be satisfied. A few of these components require header pins 
 to be soldered on. This is a fairly simple task that can be accomplished with 
 even a very low cost pencil soldering iron. The amount of soldering required 
 is minimal and I recommend borrowing the necessary equipment if possible. 
 There are many soldering tutorials on the web. 
 The most expensive component required is a logic analyzer. While I use 
 the Saleae Logic it may be too expensive for casual hobbyists ($150).
 3
 An 
 alternative, OpenBench Logic Sniffer, is considerably cheaper ($50) and prob-
 ably adequate. My choice was dictated by the needs of a teaching laboratory 
 where equipment takes a terrific beating – the exposed electronics and pins of 
 the Logic Sniffer are too vulnerable for such an environment. An Oscilloscope 
 might be helpful for the audio interfaces, but is far from essential. 
 STM32 VL Discovery
  
 The key component used in the tutorials is the STM32 VL discovery 
 board produced by STMicroelectronics (ST) and available from many 
 electron-ics distributors for approximately $10.
 4
 This board, illustrated in 
 Figure 1.2 includes a user configurable STM32 F100 micro-controller with 
 128 KB flash and 8 KB ram as well as an integrated hardware debugger 
 interface based upon a dedicated USB connected STM32 F103. With 
 appropriate software 
 3
 At the time of writing Saleae offers a discount to students and professors. 
 4
 http://www.st.com/internet/evalboard/product/250863.jsp
  
 16  
 Revision: 14c8a1e (2016-06-05)",NA
1.2 ,NA,NA
Software Installation ,"The software development process described in this book utilizes the 
 firmware libraries distributed by STMicroelectronics, which provide low-level 
 26  
 Revision: 14c8a1e (2016-06-05)",NA
1.3 ,NA,NA
Key References,"There are an overwhelming number of documents pertaining the the 
 STM32 family of Cortex-M3 MCUs. The following list includes the key docu-
 ments referred to in this book. Most of these are available on-line from www. 
 st.com. The Cortex-M3 technical reference is available from www.arm.com. 
 RM0041
  Reference manual for STM32F100x Advanced ARM-based 32-bit 
  
 MCUs [20].  
 This document provides reference information on all of 
  
 the peripheral used in the STM32 value line processors including the 
  
 processor used on the STM32 VL Discovery board. 
 PM0056
  STM32F10xx/20xx/21xx/L1xxx [19].  
 ST reference for program-
  
 ming the Cortex-M3 core. Include the execution model and instruction 
  
 set, and core peripherals (e.g. the interrupt controller). 
 Cortex-M3
  ARM Cortex-M3 (revision r1p1) Technical Reference Manual. 
  
 The definitive source for information pertaining to the Cortex-M3 [1]. 
 Data Sheet
  Low & Medium-density Value Line STM32 data sheet [15]. Pro-
 vides pin information – especially the mapping between GPIO names 
 and alternative functions. There are data sheets for a number of STM32 
 family MCUs – this one applies to the MCU on the STM32 VL discovery 
 board. 
 UM0919
  User Manual STM32 Value Line Discovery [14]. Provides detailed 
 information, including circuit diagrams, for the STM32 VL Discovery 
 board. 
 30  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 2,NA,NA
Introduction to the STM32 ,NA,NA
F1,"The STM32 F1xx micro-controllers are based upon the ARM Cortex-M3 core. 
 The Cortex-M3 is also the basis for micro-controllers from a number of other 
 manufacturers including TI, NXP, Toshiba, and Atmel.  
 Sharing 
 a common core means that the software development tools including com-
 piler and debugger are common across a wide range of micro-controllers. The 
 Cortex-M3 differs from previous generations of ARM processors by defining a 
 number of key peripherals as part of the core architecture including interrupt 
 controller, system timer, and debug and trace hardware (including external 
 interfaces). This additional level of integration means that system software 
 such as real-time operating systems and hardware development tools such as 
 debugger interfaces can be common across the family of processors. The var-
 ious Cortex-M3 based micro-controller families differ significantly in terms of 
 hardware peripherals and memory – the STM32 family peripherals are com-
 pletely different architecturally from the NXP family peripherals even where 
 they have similar functionality. In this chapter we introduce key aspects of the 
 Cortex-M3 core and of the STM32 F1xx micro-controllers. 
 A block diagram of the STM32F100 processor used on the value line discovery 
 board is illustrated in Figure 2.1. The Cortex-M3 CPU is shown in the upper left 
 corner. The value line components have a maximum frequency of 24 MHz – 
 other STM32 processors can support a 72 MHz clock. The bulk of the figure 
 illustrates the peripherals and their interconnection. The discovery processor 
 has 8K bytes of SRAM and 128K bytes of flash. There are two peripheral 
 communication buses – APB2 and APB1 supporting a wide variety of 
 peripherals. 
 Revision: 14c8a1e (2016-06-05) 
  
 31",NA
2.1 ,NA,NA
Cortex-M3,"The CM3 processor implements the Thumb-2 instruction set which pro-
 vides a large set of 16-bit instructions, enabling 2 instructions per memory 
 fetch, along with a small set of 32-bit instructions to support more complex 
 operations. The specific details of this instruction set are largely irrelevant for 
 this book as we will be performing all our programming in C. However, there 
 are a few key ideas which we discuss in the following. 
 As with all RISC processors, the Cortex-M3 is a load/store architec-ture 
 with three basic types of instructions – register-to-register operations for 
 processing data, memory operations which move data between memory and 
 registers, and control flow operations enabling programming language control 
 flow such as if and while statements and procedure calls. For example, 
 suppose we define the following rather trivial C-procedure: 
 34  
 Revision: 14c8a1e (2016-06-05)",NA
2.2 ,NA,NA
STM32 F1,"The STM32 is a family of micro-controllers. The STM32 F1xx micro-
 controllers are based upon the Cortex-M3 and include the STM32F100 value-
 line micro-controller used on the discovery board considered in this book. The 
 STM32 L1 series is derived from the STM32 F1 series but with reduced power 
 consumption. The STM32 F2 series is also based upon the Cortex-M3 but has 
 an enhanced set of peripherals and a faster processor core. Many of the 
 peripherals of the STM32 F1 series are forward compatible, but not all. The 
 STM32 F4 series of processors use the Cortex-M4 core which is a significant 
 enhancement of the Cortex-M3. Finally, there is a new STM32 family – the 
 STM32 F0 based upon the Cortex-M0. Each of these families – STM32F0, 
 STM32 F1, STM32 L1. STM32 F2, and STM32 F4 are supported by different 
 firmware libraries. While there is significant overlap between the families and 
 their peripherals, there are also important differences. In this book we focus 
 on the STM32 F1 family. 
 As illustrated in Figure 2.3, the STM32 F1 micro-controllers are based 
 upon the Cortex-M3 core with a set of peripherals distributed across three 
 buses – AHB and its two sub-buses APB1 and APB2. These peripherals are 
 38  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 3,NA,NA
Skeleton Program,"In this chapter I discuss the process of creating, compiling, loading, 
 executing, and debugging a program with the STM32 VL Discovery board and 
 Sourcery tools. For desktop machines, the standard first example is the“hello 
 world” program: 
 #include <stdio.h> 
  
 main() { 
  
  
 printf(""hello world\n""); 
  
 }
  
 which can be compiled and executed in a single step 
 $ gcc -o hello hello.c ; ./hello 
  
 hello world
  
 This simple program hides an enormous amount of complexity ranging from 
 the automatic inclusion of the standard libraries, to linking in startup code, to 
 interacting with the world through the shell. In the embedded world, much of 
 that complexity is visible to the programmer and hence it is necessary to 
 understand quite a bit more about the execution environment for even the 
 simplest program (and “hello world” is not a simple program). 
 In the embedded world, the simplest C program is one which does not require 
 any standard libraries and does not interact with the world: 
 main { 
  
 }
  
 Revision: 14c8a1e (2016-06-05) 
  
 47",NA
Chapter 4,NA,NA
STM32 Configuration,"The STM32 processors are complex systems with many peripherals. Be-
 fore any of these peripherals can be used they must be configured. Some of 
 this configuration is generic – for example clock distribution and pin config-
 uration – while the rest is peripheral specific. Throughout this chapter, we 
 utilize a simple “blinking lights” program as a guiding example. 
 The fundamental initialization steps required to utilize any of the STM32 
 peripherals are: 
 1. Enable clocks to the peripheral 
 2. Configure pins required by the peripheral 
 3. Configure peripheral hardware 
 The STM32 processors, as members of the Cortex-M3 family, all have a core 
 system timer which can be used to provide a regular timing “tick.” We utilize 
 this timer to provide a constant blink rate for our example. The overall 
 structure of this program is illustrated in Figure 4. The program begins by 
 including the relevant firmware library headers – in this case for clock and pin 
 configuration. The main routine follows the initialization steps described 
 above and then enters a loop in which it toggles an LED and waits for 250ms. 
 Procedure main is followed by code implementing the delay function which 
 utilizes the system timer.  
 Finally, a helper function is provided to handle 
 assertion violations in the firmware library (required if USE_FULL_ASSERT is 
 defined when compiling firmware library modules). While the assert_failed 
 handler does nothing, it is very useful when debugging new projects as the 
 Revision: 14c8a1e (2016-06-05) 
  
 57",NA
4.1 ,NA,NA
Clock Distribution,"In the world of embedded processors, power consumption is critical; 
 hence, most sophisticated embedded processors provide mechanisms to 
 power down any resources that are not required for a particular application. 
 The STM32 has a complex clock distribution network which ensures that only 
 those peripherals that are actually needed are powered. This system, called 
 Reset and Clock Control (RCC) is supported by the firmware module 
 stm32f10x_rcc.[ch]. While this module can be used to control the main system 
 clocks and PLLs, any required configuration of those is handled by the startup 
 code provided with the examples in this book. Our concern here is simply with 
 enabling the peripheral clocks. 
 The STM32 peripherals are organized into three distinct groups called 
 APB1, APB2, and AHB. APB1 peripherals include the I2C devices, USARTs 2-5, 
 and SPI devices; APB2 devices include the GPIO ports, ADC controllers and 
 USART 1. AHB devices are primarily memory oriented including the DMA 
 controllers and external memory interfaces (for some devices) 
 Clocks to the various peripherals can be controlled with three firmware 
 routines: 
 RCC_APB1PeriphClockCmd(uint32_t RCC_APB1PERIPH , 
  
 FunctionalState NewState) 
  
 RCC_APB2PeriphClockCmd(uint32_t RCC_APB2PERIPH , 
  
 FunctionalState NewState) 
  
 RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPERIPH , 
  
 FunctionalState NewState)
  
 Each routine takes two parameters – a bit-vector of peripherals whose 
 state should be modified, and an action – ENABLE or DISABLE. For example, 
 GPIO ports A and B can be enabled with the following call: 
 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | 
  
  
 RCC_APB2Periph_GPIOB , ENABLE);
  
 The appropriate constants are defined in stm32f10x_rcc.h; the con-
 stant names, shown in Table 4.1, are relatively self-explanatory and corre-
 spond to the device names utilized in the various STM32 reference manuals 
 ([20, 21]), limited to those that are present in the STM32 MCU on the dis-
 covery board. It is a testament to the STM32 family design that the same 
 constants and core library applies across a broad family of devices. (Note the 
 stm32f2xx and stm32f4xx components have different, although similar stan-
 dard peripheral libraries) 
 Revision: 14c8a1e (2016-06-05) 
  
 61",NA
4.2 ,NA,NA
I/O Pins,"Most of the pins of the STM32 can be configured as input or output and 
 may be connected to either the GPIO ports or “alternative functions”(other 
 peripherals). As a standard naming convention, the pins are called by their 
 GPIO function – for example PA0 (bit 0 of port A) or PB9 (bit 9 of port B). 
 Indeed, the labeling of the discovery board follows this convention. Subject to 
 specific hardware constraints, each pin can be configured in the modes 
 illustrated in Figure 4.2. 
  
 Function 
 Library Constant 
 Alternate function open-drain 
 Alternate function push-pull 
 Analog  
 Input floating  
 Input pull-down  
 Input pull-up  
 Output open-drain  
 Output push-pull 
 GPIO_Mode_AF_OD  
 GPIO_Mode_AF_PP  
 GPIO_Mode_AIN  
 GPIO_Mode_IN_FLOATING 
 GPIO_Mode_IPD  
 GPIO_Mode_IPU  
 GPIO_Mode_Out_OD  
 GPIO_Mode_Out_PP 
  
 Table 4.2: Pin Modes (stm32f10x_gpio.h) 
 By default, most pins are reset to “Input Floating” – this ensures that no 
 hardware conflicts will occur when the system is powering up. The firmware 
 library provides an initialization routine in stm32f10x_gpio.[ch] which may be 
 used to reconfigure the pins. For example, for the blinking lights we con-
 figured PC9 as a (slow) output as illustrated in Listing 4.1. 
 When configuring an output as shown above, we have three choices of 
 output “speed” – 50 MHz, 10 MHz, and 2 MHz. In general, for reasons of power 
 consumption and noise, it is desirable to use the lowest speed consistent 
 Revision: 14c8a1e (2016-06-05) 
  
 63",NA
4.3 ,NA,NA
Alternative Functions,"Peripherals such as the USARTs share pins with the GPIO devices. 
 Before these peripherals can be utilized, any outputs required by the 
 peripheral must be configured to an “alternative mode”. For example, the Tx 
 pin (data out) for USART1 is configured as follows: 
 GPIO_InitStruct.GPIO_PIN = GPIO_Pin_9; 
  
 GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; 
 GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; 
 GPIO_Init(GPIOA, &GPIO_InitStruct);
  
 The specific configuration required for each peripheral is described in 
 section 7.1.11 of the stm32f10xx reference manual RM0041 [20] (section 
 9.1.11 for stm32f103xx reference manual RM0008 [21]).",NA
4.4 ,NA,NA
Remapping,"It is also possible to “remap” pins so that non-default pins are used for 
 various peripherals in order to minimize conflicts. These re-mappings, which 
 Revision: 14c8a1e (2016-06-05) 
  
 65",NA
4.5 ,NA,NA
Pin Assignments For Examples and Exercises,"In this book we develop a series of examples and exercises based upon 
 the STM32VL Discovery board. Ensuring that these examples can work to-
 gether required some care in the selection of STM32 devices and GPIO pins– 
 for example we used the SPI2 device rather than the SPI1 device due to a 
 resource conflict. In Table 4.5 we enumerate all the pin assignments used in 
 this book along with the configurations required for these uses. 
 66  
 Revision: 14c8a1e (2016-06-05)",NA
4.6 ,NA,NA
Peripheral Configuration,"As mentioned the third configuration stage, after clock distribution and 
 pin configuration, is peripheral configuration. While we defer the discussion 
 of peripheral specific configuration, the standard firmware library offers a 
 stan-dard pattern for the configuration process. We’ve see a bit of this already 
 with GPIO configuration where a device specific structure was populated with 
 a set of parameters and one or more pins for a given port were initialized: 
 GPIO_StructInit(&GPIO_InitStructure); 
  
 ... fill in structure ...
  
 GPIO_Init(GPIOx, &GPIO_InitStructure);
  
  
 It is also possible to “de-initialize” a port, returning all of its pin con-
 figuration to the hardware reset state with a call to 
 GPIO_DeInit(GPIOx)
  
 The DeInit function resets the peripheral registers, but it does not dis-
 able the peripheral clock – that requires a separate call to the clock command 
 (with DISABLE replacing ENABLE). 
 This pattern – an initialization structure, an init function, and a de-init 
 function is repeated throughout the standard peripheral library. The basic 
 naming convention for peripheral “ppp” is: 
 Files  
 Init Structure  
 Zero Structure  
 Initialize Peripheral  
 De-initialize Peripheral 
 stm32f10x_ppp.[c|h]  
 ppp_InitTypeDef  
 ppp_StructInit(ppp_InitTypeDef*)  
 ppp_Init([sub-device,] ppp_InitTypeDef*) 
 ppp_DeInit([sub-device]) 
  
 Examples of devices with the optional “sub device” are USART, SPI, I2C. 
 Timers are a somewhat complicated case because each timer is typically 
 multiple devices – a “time base”, zero or more output compares, zero or more 
 input captures. There are other exceptions, but mostly for peripherals that are 
 not supported on the medium density value-line parts. 
 Exercise 4.3 Configuration without Standard Peripheral Library
  
 Write a program using only the constants defined in the programmer 
 reference manual ([20]) that: configures the pins for the user push-button and 
 blue LED, and, in an infinite loop, displays the button state on the LED. 
 Your code should look like 
 68  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 5,NA,NA
Asynchronous Serial ,NA,NA
Communication,"After LEDs and pushbuttons, the most basic method for communica-
 tion with an embedded processor is asynchronous serial. Asynchronous serial 
 communication in its most primitive form is implemented over a symmetric 
 pair of wires connecting two devices – here I’ll refer to them as the host and 
 target, although those terms are arbitrary. Whenever the host has data to send 
 to the target, it does so by sending an encoded bit stream over its trans-mit 
 (TX) wire; this data is received by the target over its receive (RX) wire. 
 Similarly, when the target has data to send to the host it transmits the en-
 coded bit stream over its TX wire and this data is received by the host over its 
 RX wire. This arrangement is illustrated in Figure 5. This mode of commu-
 nications is called “asynchronous” because the host and target share no time 
 reference. Instead, temporal properties are encoded in the bit stream by the 
 transmitter and must be decoded by the receiver. 
 Host
  
 RX
  
 TX
  
 Target
  
 TX
  
 RX
  
 Figure 5.1: Basic Serial Communications Topology 
 Revision: 14c8a1e (2016-06-05) 
  
 71",NA
5.1 ,NA,NA
STM32 Polling Implementation,"The simplest form of USART communication is based upon polling the 
 state of the USART device. Each STM32 USART has 6 registers – 4 of which are 
 used for configuration through the initialization routines provided by the 
 driver library as shown in Section 5.2.  
 The remaining 2 registers are 
 the“data register” and the “status register”. While the data register occupies a 
 single memory word, it is really two separate locations; when the data register 
 is written, the written character is transmitted by the USART. When the data 
 register is read, the character most recently received by the USART is returned. 
  
 The status register contains a number of flags to determine the current 
 USART state. The most important of these are: 
 76  
 Revision: 14c8a1e (2016-06-05)",NA
5.2 ,NA,NA
Initialization,"As with all STM32 peripherals, the USARTs must be initialized before 
 they can be used. This initialization includes pin configuration, clock distri-
 bution, and device initialization. Initialization is handled most conveniently 
 with the Standard Peripheral Driver library – in the following we assume ver-
 sion 3.5.0. The stm32f100 component in the discovery board has 3 USARTs 
 called USART1 – USART3 throughout the documentation and driver library. In 
 the following we will be utilizing USART1, but the principles for the other 
 USARTs are the same. 
 There are three modules (in addition to the general header) that are 
 part of the driver library which are required for USART applications (you will 
 need to include the associated object files in your make file). 
 #include <stm32f10x.h> 
  
 #include <stm32f10x_gpio.h> 
  
 #include <stm32f10x_rcc.h> 
  
 #include <stm32f10x_usart.h>
  
 The first initialization step is to enable the RCC (reset and clock con-
 trol) signals to the various functional blocks required for utilizing the USART– 
 these include GPIO ports (port A for USART1), the USART component and the 
 AF (alternative function) module. For USART1, the necessary RCC 
 configuration step is: 
 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | 
  
 RCC_APB2Periph_AFIO | 
  
 RCC_APB2Periph_GPIOA , ENABLE);
  
 USART2 and USART3 are “APB1” peripherals, hence their RCC ini-
 tialization differs slightly. Notice the that various APB2 flags are or’d to-
 gether; it is also acceptable to enable the clocks in separate steps. 
  
 Once clocks are enabled, it is necessary to configure the USART pins –the 
 default pins for all three USARTs are provided in Table 5.1. 
 The STM32 reference manuals provide key information for configuring 
 the GPIO pins for the various devices. For the USARTs, this information is 
 reproduced here as Table 5.2. More complete pin configuration information is 
 available from the device data sheet [15]. 
 78  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 6,NA,NA
SPI,"The SPI bus is widely used serial interface for communicating with 
 many common hardware devices including displays, memory cards, and 
 sensors. The STM32 processors have multiple SPI interfaces and each of these 
 interfaces can communicate with multiple devices. In this chapter we show 
 how to use the SPI bus to interface to widely available EEPROM memory 
 chips. These chips provide non-volatile storage for embedded systems and are 
 frequently used to store key parameter and state data. In Chapter 7 we show 
 how to use the SPI bus to interface with a color LCD display module and in 
 Chapter 8 we will use the same interface to communicate with a commodity 
 flash memory card.",NA
6.1,NA,NA
Protocol,"SCK
  
 SCK
  
 SPI
  
 SPI
  
 MOSI
  
 MOSI
  
 Master
  
 MISO
  
 MISO
  
 Slave
  
 SS
  
 SS
  
 Figure 6.1: SPI Protocol Block Diagram 
 The basic SPI interface is illustrated in Figure 6.1. Every instance of a 
 SPI bus has a single master and one or more slaves. While the STM32 can be 
 configured in either role, here we consider only the case where it is configured 
 as a master. In the figure there are four single-wire signals – three from the 
 Revision: 14c8a1e (2016-06-05) 
  
 85",NA
6.2,NA,NA
STM32 SPI Peripheral,"enum spiSpeed { SPI_SLOW , SPI_MEDIUM , SPI_FAST };
  
 void spiInit(SPI_TypeDef* SPIx); 
  
 int spiReadWrite(SPI_TypeDef* SPIx, uint8_t *rbuf, 
  
  
 const 
 uint8_t *tbuf, int cnt, 
  
 enum spiSpeed speed); 
  
 int spiReadWrite16(SPI_TypeDef* SPIx, uint16_t *rbuf, 
   
 const 
 uint16_t *tbuf, int cnt, 
  
  
 enum spiSpeed speed);
  
 Listing 6.1: SPI Module Interface 
 In this chapter we will develop and test a SPI driver with the simple 
 interface illustrated in Listing 6.1. The standard peripheral library defines 
 three SPI devices (SPI1, SPI2, and SPI3) and 8 possible clock prescalers in 
 stm32f10x_spi.h – for the 24MHz part on the Discovery board, a prescaler of 8 
 results in a 3MHz SPI clock (24/8). We use prescalers of 64, 8, and 2 for slow, 
 medium, and fast speeds, respectively. This interface provides for initializing 
 any of these three devices with a relatively generic configuration. There is one 
 data transfer operation which allows exchanging buffers of data with a SPI 
 device. Technically, every data transfer is bidirectional, but many devices do 
 not utilize this capability. Thus, the read/write operations accept null pointers 
 for either send or receive buffers. The SPI device also supports 
 Revision: 14c8a1e (2016-06-05) 
  
 87",NA
6.3 ,NA,NA
Testing the SPI Interface,"The easiest way to test this SPI interface is by wiring it in “loop-
 back”mode with MISO directly connected to MOSI and watching data 
 transmissions with the Saleae Logic. 
  
 Because the Logic expects a select signal (SS) the test program must 
 explicitly configure and control a select signal.  
 In the 
 following section, we will show how to use the SPI interface to control an 
 external EEPROM; for that example we will use PC10 as the select pin (for this 
 loopback example we are using PC3), therefore it is convenient to use the same 
 pin here. 
 The main routine of a simple test program is illustrated in Listing 6.4. 
 Notice that it tests both 8-bit and 16-bit modes. An fragment of the Logic 
 output for this program is illustrated in Figure 6.4. 
 90  
 Revision: 14c8a1e (2016-06-05)",NA
6.4 ,NA,NA
EEPROM Interface,"One of the simplest and most useful SPI devices is a serial EEPROM 
 (electrically erasable programmable memory) which is often used in embed-
 ded devices as a small non-volatile store for configuration parameters and 
 persistent state (e.g. high scores in a game). Data retention for EEPROMs is 
 measured in decades. One limitation is that they can survive only a limited 
 number of write cycles (perhaps a million) and hence should be used for rela-
 tively slowly changing information. SPI EEPROMs are available from many 
 manufacturers with common interfaces. The capacities vary from
  <
  1
 K
  bit to
  >
  
 1
 M
  bit. 
 Our choice of an EEPROM for the first SPI example application was 
 dictated by one consideration – the basic operation is intuitive (read/write) 
 and hence it is relatively easy to determine if interface code is working cor-
 rectly. In the preceding section we used data loop back and the Saleae Logic to 
 ensure that our SPI interface code was operating as expected. It’s time to 
 92  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 7,NA,NA
SPI : LCD Display,"In this chapter we consider the use of the STM32 SPI interface to com-
 municate with an LCD display module. The LCD is a 1.8” TFT display with 
 128x160 18-bit color pixels supported by a common (ST7735R) driver chip.",NA
7.1 ,NA,NA
Color LCD Module,"The LCD module we consider uses the ST7735R controller.
 1
 . We refer to 
 the display as a 7735 LCD. The 7735 LCD is a pixel addressable display; every 
 pixel requires multiple bytes to define color – the internal display memory 
 uses 18-bits/pixel (6 bits each for red, blue, and green). We will use this 
 display in a 16-bit mode with 5 bits defining red, 6 bits defining green, and 5 
 bits defining blue. The display controller automatically extrapolates from 16 
 bits to 18 bits when pixels are written to the display. This color model is 
 illustrated in Figure 7.1. There are two parts to this figure, the layout of the 
 separate colors within a 16-bit word, and colors resulting from various 16-bit 
 constants. 
 To understand the required interface to the 7735 LCD, consider the model in 
 Figure 7.1. There are three major components to consider – the controller, the 
 LCD panel, and the display RAM. The display ram contains 18 bits of color 
 information for each of the (128 x 160) pixels in the panel. 
 2
  The data in the 
 display RAM is continuously transferred to the panel –we configure the device 
 to sweep from bottom to top. The model for writing pixel (color) data is 
 somewhat indirect. First, using a separate “control” 
  
 1
 There are two variants of the ST7735 – when initializing the controller it is important to do 
 this for the correct variant !
  
 2
 Actually 132x162, but we configure the controller for the smaller number.
  
 Revision: 14c8a1e (2016-06-05) 
  
 97",NA
7.2 ,NA,NA
Copyright Information,"Our code for the ST7335 is derived from a module available from https: 
 //github.com/adafruit/Adafruit-ST7735-Library.git 
 The following copyright applies to that code: 
 /***************************************************  This is a 
 library for the Adafruit 1.8"" SPI display. 
 This library works with the Adafruit 1.8"" TFT Breakout w/SD card----> 
 http://www.adafruit.com/products/358  
 as well as Adafruit raw 1.8"" TFT display 
 ----> http://www.adafruit.com/products/618 
 Check out the links above for our tutorials and wiring diagrams These displays 
 use SPI to communicate, 4 or 5 pins are required to interface (RST is optional)  
 Adafruit invests time and resources providing this open source code, please 
 support Adafruit and open-source hardware by purchasing products from 
 Adafruit! 
 Written by Limor Fried/Ladyada for Adafruit Industries. 
 MIT license, all text above must be included in any redistribution 
 ****************************************************/",NA
7.3 ,NA,NA
Initialization Commands (Remainder),"108  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 8,NA,NA
SD Memory Cards,"In this chapter we show how to interface a commodity SD memory card 
 to the STM32 VL Discovery board using the SPI peripheral discussed in Chap-
 ter 6. While communicating with an SD memory card is a simple extension of 
 the previously presented work, controlling the card and interpreting the data 
 communicated requires a significant additional software. Fortunately, much of 
 the required software is available in the widely used FatFs module [3]. Only a 
 modest amount of porting is required to utilize this module with our SPI 
 driver. 
 The STM32 processors on the VL discovery board are relatively 
 memory constrained – 128K bytes flash and 8K bytes ram – which limits the 
 ability to store large quantities of data either as inputs to or outputs from an 
 embedded program. For example, in a game application it might be desirable 
 to access sound and graphic files or in a data logging application, to store 
 extended amounts of data. Furthermore, accessing the contents of the STM32 
 flash requires a special interface and software. In such applications it is 
 desirable to provide external storage which the STM32 can access while 
 running and the user/programmer can easily access at other times. 
 Commodity flash memory cards (in particular SD cards) provide a cost 
 effective solution which can reasonably easily be accessed by both the 
 processor and user. In practice, these cards have file systems (typically FAT) 
 and can be inserted in commonly available adaptors to be accessed by a 
 desktop machine. Furthermore, the physical interface has a SPI mode which is 
 accessible using the code described in Chapter 6. 
 Physically, SD memory cards consist of a flash memory array and a 
 control processor which communicates with a host over either the SD bus (a 
 parallel bus) or the SPI bus. Communication is transaction based – the host 
 Revision: 14c8a1e (2016-06-05) 
 111",NA
8.1 ,NA,NA
FatFs Organization,"The following discussion refers to the current (0.9) version of FatFs. The 
 code distribution is organized as illustrated in Figure 8.2 
 The interface between the fat file system driver and the SD driver is 
 defined in the module diskio.h illustrated in Listing 8.2. We have modified the 
 default distribution to include meaningful parameter names. An initialized 
 disk can be read, written, and controlled (ioctl). The read/write commands 
 are restricted to the block level (the size of blocks depends upon the SD card). 
 The ioctl function provides a means to determine the SD card “geometry”(e.g. 
 number and size of blocks), and may provide additionally functionality to 
 enable power control. The low level implementation described in the sequel 
 only supports ioctl functions to determine the disk “geometry” and to force 
 114  
 Revision: 14c8a1e (2016-06-05)",NA
8.2 ,NA,NA
SD Driver,"As described previously, the SD driver implements five functions to 
 support the FatFs and uses the SPI driver to communicate with the SDCard. 
 The SDCard communication protocol is transaction based. Each transaction 
 begins with a one-byte command code, optionally followed by parameters, 
 and then a data transfer (read or write). The SDCard protocol is well 
 documented. [9]. In the following we present a few examples to illustrated the 
 basic con-cepts. Fortunately, it is not necessary to create this module from 
 scratch. 
 There 
 is 
 a 
 distribution 
 of 
 sample 
 projects 
 http://elm-
 chan.org/fsw/ff/ 
 Revision: 14c8a1e (2016-06-05) 
 115",NA
8.3,NA,NA
FatFs Copyright,"FatFs module is an open source software to implement FAT file small embedded systems. 
 This is a free software and is opened for
 →
 system to
  
 research and commercial developments under license policy of
 →
 education ,
  
  
 →
 following terms.
  
 Copyright (C) 2011, ChaN, all right reserved.
  
 * The FatFs module is a free software and there is NO WARRANTY. * No restriction on use. 
 You can use, modify and redistribute it 
  
 personal , non-profit or commercial product 
 UNDER YOUR
 →
 for 
  
 * RESPONSIBILITY.
  
 * Redistributions of source code must retain the above copyright
 →
 notice.
  
 122  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 9,NA,NA
I,NA,NA
2,NA,NA
C – Wii Nunchuk,"In this chapter we introduce I
 2
 C, the third major protocol we use to 
 interface with external modules. I
 2
 C is a two wire protocol used to connect 
 one or more “masters” with one or more “slaves”, although we only discuss 
 the case of a single master (the STM32) communicating with slave devices. An 
 example configuration is illustrated in Figure 9.1. In this configuration, a 
 single master communicates with several slaves over the pair of signal wires 
 SDA and SCL. Example slave devices include temperature, humidity, and 
 motion sensors as well as serial EEPROMs. 
 As we shall see, the software required to interface with I
 2
 C devices is 
 considerably more complicated than with SPI. For example, I
 2
 C has multiple 
 error conditions that must be handled, SPI has no error conditions at the 
 physical level. Similarly, I
 2
 C has multiple transaction types, while SPI has a 
 single basic transaction type. Furthermore, SPI is generally a much faster bus 
 (1-3Mbit/sec vs 100-400Kbit/sec). The greatest advantage of I
 2
 C over SPI ist 
 that the number of wires required by I
 2
 C is constant (2) regardless of the 
 number of connected devices whereas SPI requires a separate select line for 
 each device. In place of select lines, I
 2
 C devices have internal addresses and 
 are selected by a master through the transmission of this address over the 
 bus. This difference makes I
 2
 C a good choice where a large number of devices 
 must be connected. Finally, I
 2
 C is a symmetric bus which can support multiple 
 masters whereas SPI is completely asymmetric. 
 The remainder of this chapter is organized as follows. We begin with an 
 introduction to the I
 2
 C protocol in Section 9.1. We then discuss the use of I
 2
 C 
 to communicate with a Wii Nunchuk. The Wii Nunchuk is an inexpensive input 
 device that includes a joystick, two buttons, and a three axis accelerom- 
 Revision: 14c8a1e (2016-06-05) 
 123",NA
9.1 ,NA,NA
I,2,NA
C Protocol,"In this Section we present a concise overview of the I
 2
 C bus protocol 
 which covers only those aspects of the protocol necessary to understand this 
 chapter. For a more complete description see the I
 2
 C specification manual [7]. 
 Electrically, I
 2
 C is a “wired-or” bus – the value of the two signal wires is 
 “high” unless one of the connected devices pulls the signal low. On the left side 
 of Figure 9.1 are two resistors that force (“pull up”) the default value of the 
 two bus wires to VCC (typically 3.3V). Any device on the bus may safely force 
 either wire low (to GND) at any time because the resistors limit the current 
 draw; however, the communication protocol constrains when this should 
 occur. The two wires are called SCL (serial clock line) and SDA (serial 
 data/address). To communicate, a master drives a clock signal on SCL while 
 driving, or allowing a slave to drive SDA. Thus, the bit-rate of a transfer is 
 determined by the master. 
 VCC
  
 Master
  
 Slave
  
 Slave
  
 SDA
  
 SCL
  
 Figure 9.1: Typical I
 2
 C Configuration 
 SDA
  
 MSB
  
 LSB
  
 ACK
  
 SCL
  
 S 
  
 P
  
 Figure 9.2: I
 2
 C Physical Protocol 
 Communication between a master and a slave consists of a sequence of 
 transactions where the master utilizes the SCL as a clock for serial data 
 124  
 Revision: 14c8a1e (2016-06-05)",NA
9.2 ,NA,NA
Wii Nunchuk,"Wii Nunchuks are inexpensive input devices with a joystick, two but-
 tons, and a three-axis accelerometer as illustrated in Figure 9.4. Notice par-
 ticularly the three axes X, Y, and Z which correspond to the data produced by 
 the accelerometer, joystick . X is right/left, Y is forward/backwards, and Z is 
 up/down (accelerometer only). The I
 2
 C bus is used to initialize the Nunchuk 
 to a known state and then to regularly “poll” its state. There is extensive 
 documentation on the web from which this chapter is drawn (e.g. [8]). 
 The data are read from the Nun chuck in a six-byte read transaction. 
 These data are formatted as illustrated in Figure 9.5 and are read beginning 
 with byte 0x0 (little-endian). The only complication with this format is that 
 the 10-bit/axis accelerometer data are split. 
 Communication with the Nunchuk consists of two phases – an initial-
 ization phase (executed once) in which specific data are written to to Nunchuk 
 126  
 Revision: 14c8a1e (2016-06-05)",NA
9.3 ,NA,NA
STM32 I,2,NA
C Interface,"The STM32 I
 2
 C device is extremely complicated. For example, read 
 transactions with 1, 2, and more than 2 bytes are handled in a significantly 
 different manner. The best references are the programmer’s manual ([21, 20]) 
 and ST application note AN2824 [13]. The later describes examples for polling, 
 interrupt-driven, and DMA-driven interfaces.  
 Unfortunately, the example 
 code weaves these three cases together and further does not make use of the 
 standard peripheral library. We have rewritten a polling-based solution using 
 the peripheral library. 
 As with all STM32 devices, the first task is to properly initialize the 
 device including clocks and pins. Our initialization code is illustrated in List-
 ing 9.1. 
 The write transaction implementation is the simplest of the two trans-
 action types with few special cases. This is illustrated in Listing 9.2. This 
 follows Figure 3 from AN2824. Comments of the form EVn (e.g. EV5) refer to 
 states as described in the programmers manual. The code provided does not 
 attempt to recover from I
 2
 C interface errors. Indeed, an interrupt handler is 
 required even to detect all possible errors. 
 Revision: 14c8a1e (2016-06-05) 
 131",NA
Chapter 10,NA,NA
Timers,"Micro-controllers, such as the STM32 utilize hardware timers to gen-
 erate signals of various frequencies, generate pulse-width-modulated (PWM) 
 outputs, measure input pulses, and trigger events at known frequencies or 
 delays. The STM32 parts have several different types of timer peripherals 
 which vary in their configurability. The simplest timers (TIM6 and TIM7) are 
 primarily limited to generating signals of a known frequency or pulses of fixed 
 width. While more sophisticated timers add additional hardware to uti-lize 
 such a generated frequency to independently generate signals with specific 
 pulse widths or measure such signals. In this chapter we show how timers can 
 be used to control the intensity of the ST7735 backlight (by modulating its 
 enable signal) and to control common hobby servos. 
 An example of a basic timer is illustrated in Figure 10.1. This timer has 
 four components – a controller, a prescaler (PSC), an “auto-reload” register 
 (ARR) and a counter (CNT). The function of the prescaler is to divide a 
 reference clock to lower frequency. The STM32 timers have 16-bit prescaler 
 registers and can divide the reference clock by any value 1..65535. For 
 example, the 24Mhz system clock of the STM32 VL Discovery could be used to 
 generate a 1 Mhz count frequency with a prescaler of 23 (0..23 == 24 values). 
 The counter register can be configured to count up, down, or up/down and to 
 be reloaded from the auto reload register whenever it wraps around (an 
 “update event”) or to stop when it wraps around. The basic timer generates an 
 output event (TGRO) which can be configured to occur on an update event or 
 when the counter is enabled (for example on a GPIO input). 
 To understand the three counter modes consider Figure 10.2. In these 
 examples, we assume a prescaler of 1 (counter clock is half the internal clock), 
 and a auto reload value of 3. Notice that in “Up” mode, the counter increments 
 Revision: 14c8a1e (2016-06-05) 
 139",NA
10.1 ,NA,NA
PWM Output,"In this section we consider two examples utilizing pulse-width-
 modulated output – a backlight control for the 7735 LCD and a hobby servo 
 control. 
 7735 Backlight
  
 The 7735 backlight consists of a number of LEDs which are turned on 
 by pulling the 7735 backlight control pin (PA1) low and off by pulling it high. 
 It is possible to “dim” LEDs by applying a PWM signal which modulates their 
 duty cycle. In this section, we show how to configure a timer to allow the 
 intensity of the 7735 backlight to be modified under program control. The 
 library code to configure timers is in stm32f10x_tim.[ch]. 
 By consulting the STM32 VL Discovery User Manual [14] we find that 
 PA1 is “conveniently” associated with TIM2_CH2 – that is, channel 2 of timer 
 142  
 Revision: 14c8a1e (2016-06-05)",NA
10.2 ,NA,NA
Input Capture,"In generating PWM output signals we use the “compare” feature of the 
 capture/compare register. In this section we discuss “capture”. The capture 
 registers provide a mechanism to monitor an input pin and, based upon a pro-
 grammed edge, capture the current value of the corresponding timer counter. 
 The main purpose of the capture registers is to enable measuring, relative to a 
 time reference, when events happen. It is possible to tie multiple capture 
 registers to a single input, capturing the times of both rising and falling edges, 
 to measure pulse widths. It is possible to use input events to reset the timer 
 counter, to use input values to enable a timer counter, and to synchronize 
 multiple timers. In this section we will show how input capture can be used in 
 conjunction with PWM output to control commonly available ultrasonic 
 ranging devices such as that illustrated in Figure 10.7. 
  
 Figure 10.7: Ultrasonic Sensor 
 The HC-SR04 ultrasonic ranging module is capable of 3mm resolution 
 in the range 20-500mm. It requires a 5V supply. In operation, the module is 
 triggered by delivering it a 10
 µs
  pulse. Some time later an “echo” pulse is 
 generated whose length is proportional to the measured distance as 
 illustrated in Figure 10.8 and defined by the following formula where
  pw
  is 
 the echo pulse. 
 distance
  =
  pw ◦cm 
 58
 µs
  
 If the distance is less than 20mm or greater than 500 mm, a 38ms pulse is 
 returned. Internally, the ultrasonic controller circuit generates an 8 pulse 40 
 kHz signal which drives the transducer. 
 In the remainder of this section we will describe to use two timers – one 
 for output and one for input to control such an ultrasonic ranger completely 
 autonomously. Meaning that after setting up the timers, an application need 
 146  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 11,NA,NA
Interrupts,"Interrupts are a fundamental hardware mechanism to enable 
 peripherals to notify software of critical events.
 1
 For example, we may wish to 
 generate an analog output signal at precise intervals in order to play an audio 
 file. One way to achieve this is to configure a timer to generate interrupts at 
 precise intervals. When the configured interrupt occurs, the processor 
 switches exe-cution from the application program to a special interrupt 
 handler which can then “service” the interrupt event by transferring a data 
 sample to the ana-log output. Once the interrupt handler has completed its 
 task, the processor resumes execution of the application program. Interrupts 
 are also important in communication – for example, notifying the processor 
 when a character has arrived at a UART. In this chapter we discuss how 
 interrupts work in the STM32 (more generally in the Cortex-M3) micro-
 controller family and present several concrete examples to demonstrate their 
 use. 
 We’ve actually been using interrupts throughout this book to implement 
 our delay function as illustrated by the code fragment in Listing 11.1. Within 
 main, we configure the Cortex-M3 “SysTick” to trigger an interrupt every milli-
 second. Furthermore, we define an interrupt handler,  
 SysTick_Handler, to be executed when the SysTick interrupt occurs. This 
 handler decrements the variable TimingDelay and then returns control to the 
 application program. The application program may wait for a precise period by 
 calling the procedure Delay with an interval and then waiting for this interval 
 to elapse (literally be counted down by the handler). 
 Interrupts may be triggered by many possible events including the sys- 
  
 1
 Interrupts are a special case of exceptions, which may include internal events such as 
 access violations.
  
 Revision: 14c8a1e (2016-06-05) 
 151",NA
11.1,NA,NA
Cortex-M3 Exception Model,"The Cortex-M3 processors support two modes of operation, Thread mode and 
 Handler mode.  
 Thread mode is entered on Reset, and can be 
 entered through an exception return. Handler mode is entered as a result of an 
 exception being taken. The Cortex-M3 processors support two distinct stack 
 pointers – as illustrated in Figure 11.1. Out of reset, all code utilizes the main 
 stack; however, the processor can be configured so that application code 
 utilizes a separate “process stack.” Whenever the processor invokes an 
 exception, the handler executes using the main stack, and when execution 
 returns from an exception, the processor resumes using the stack used prior 
 to the exception. When invoking an exception, the state of the currently 
 execut-ing code must be saved on the main stack to be restored when the 
 exception handler terminates. With single threaded applications, such as the 
 examples we have considered thus far, there is no significant advantage to 
 utilizing sep-arate stacks; however, when using an operating system 
 supporting threads, it is generally considered desirable to use a separate stack 
 for exception handling and execution within the OS kernel. 
  
  
 r0
  
 r1
  
 r2
  
 r3
  
 r4
  
 r5
  
 r6
  
 r7
  
 r8
  
 r9
  
 r10
  
 r11
  
 r12
  
 r13 (SP)
  
 r14 (LR)
  
 r15 (PC)
  
 xPSR
  
  
  
 PSP
  
  
  
 MSP
  
  
 Low registers
  
 High registers
  
  
  
  
 Program Status Register
  
 Figure 11.1: Processor Register Set 
 State saving and restoring is a collaboration between the processor 
 hard-ware and the exception handlers. The Cortex-M3 architecture assumes 
 that the exception handler code will obey the Arm Architecture Procedure Call 
 Revision: 14c8a1e (2016-06-05)
  
 155",NA
11.2 Enabling Interrupts and Setting Their ,NA,NA
Priority,"The Cortex-M3 core defines a sophisticated priority mechanism that allows 
 interrupt sources to be assigned both a priority and a sub-priority. At a given 
 priority level, two interrupt sources are serviced in order of their sub-priority 
 (lower number takes precedence). If an interrupt handler is active and another 
 interrupt arrives with a lower priority number, the the active handler will be 
 preempted. The Cortex-M3 defines up to 8 priority level bits that may be split 
 among the priority and sub-priority fields.  
 The STM32 
 processor implements only 4 of these bits. Throughout this book we utilize a 
 configuration where 0 bits are allocated to priority and 4 bits are allocated to 
 sub-priority. In other words, we choose not to enable interrupt preemption. 
 The interrupt priority mechanism is managed through the NVIC (Nested 
 Vectored Interrupt Controller) that is a standard peripheral for all Cortex-M3 
 based processors. The NVIC provides the following functions for every 
 interrupt source: 
 • Priority and sub-priority configuration. 
 • Enable (disable) interrupt. 
 • Set/Clear interrupt pending bit.",NA
11.3 NVIC Configuration,"The STM32 NVIC supports 16 distinct priority and sub-priority levels 
 supported by 4 bits which are partitioned between these two functions. Inter-
 rupts with different priorities can preempt each other (lower number 
 priorities have precedence) while sub-priorities within a single priority only 
 affect the choice of interrupt taken when two or more are pending. For the 
 examples in 
 Revision: 14c8a1e (2016-06-05) 
 159",NA
11.4 ,NA,NA
Example: Timer Interrupts,"In Section 10.1 we showed how to configure timer TIM2 to control the 
 LCD back light. In this example, we show how to enable the TIM2 interrupt. 
 Since this builds upon work you have seen before, we present a basic outline 
 in Listing 11.2. In addition to configuring the timer, it is necessary to configure 
 the NVIC for the appropriate interrupt vector and to enable the timer to 
 generate interrupts. Timers can generate interrupts on multiple conditions –
 here we choose to trigger interrupts whenever the counter is updated. Finally, 
 we need a handler which, at a minimum, clears the pending interrupt. 
 160  
 Revision: 14c8a1e (2016-06-05)",NA
11.5,NA,NA
Example: Interrupt Driven Serial ,NA,NA
Communications,"The fundamental weakness of the serial communication code presented 
 in Chapter 5 is that unless the user code is constantly polling the USART and is 
 prepared to receive characters as soon as they arrive, there is a high 
 probability that the (single) receive buffer will overflow and characters will be 
 lost. Ideally, we want a solution that does not require such a high degree of 
 attention from the user code and which also can guarantee that characters are 
 not lost. Similarly, when the user code wishes to transmit a string it must wait 
 for the transmit buffer to empty after each character sent. 
 A partial solution is to create larger transmit and receive buffers in 
 software and utilize an interrupt handler to manage the details of receiving 
 and transmitting characters. The interrupt handler is a user supplied routine 
 that is executed, asynchronously to the user code, whenever the USART 
 transmit 
 Revision: 14c8a1e (2016-06-05) 
 161",NA
11.6,NA,NA
External Interrupts,"The STM32 F1xx micro-controller provide up to 20 possible EXTI (ex-
 ternal interrupt) sources; although in many cases the various sources share a 
 single interrupt vector. The possible sources and their corresponding even-
 t/vector (for the STM32 F100) are: 
 Revision: 14c8a1e (2016-06-05) 
 171",NA
Chapter 12,NA,NA
DMA: Direct Memory Access,"In this chapter we discuss the use of direct memory access (DMA) to 
 relieve the processor of the costs of transferring blocks of data between 
 memory and peripherals. Consider the following idiom where a block data is 
 read from a peripheral by repeatedly waiting for a status flag and then reading 
 an item from the peripheral. 
 for (i = 0; i < N; i++) { 
  
  
 while(flagBusy); 
  
  
 buf[i] = peripheralRegister; 
  
 }
  
 We have seen this with serial communication (Section 5.1), SPI com-
 munication (Listing 6.3), and will see it again with I2C communication (Fig-
 ure 9.3). This approach, called software polling, has three limitations. First, 
 the processor is tied up during the transfer and cannot perform other tasks; 
 ideally with a large data transfer (consider reading a data sector from an SD 
 card), the transfer could be kicked off and the processor freed to perform 
 other work while the transfer is realized. Second, the actual transfer rate is 
 lower than the underlying hardware might permit. Finally, it is difficult to 
 achieve tight timing bounds, for example, audio streaming depends upon the 
 data samples to be transferred at a constant rate. 
 To see rather dramatically the differences in performance, consider the two 
 Logic screen captures showing the SPI transfers when filling and 7735 LCD 
 with a solid color shown in Figure 12. The upper capture mea-sures the time 
 for transferring 2 pixels, while the lower capture measures the time for 
 transferring 128 pixels.  
 The theoretical peak is 12
 x
 10
 6
 /16 = 
 750
 ,
  000
 pixels
 /
 second
  for a 12 MHz SPI clock. Without DMA, our trans- 
 Revision: 14c8a1e (2016-06-05) 
 179",NA
12.1 STM32 DMA Architecture,"The STM32 has two DMA peripherals each of which has multiple inde-
 pendently configurable “channels” (7 for DMA1 and 5 for DMA2). A channel is 
 roughly the hardware realization of a transaction. To initialize DMA be-tween 
 a peripheral and memory it is necessary to configure the appropriate channel. 
 For example, DMA1 channel 2 (3) can be used to receive (transmit) data from 
 (to) SPI1. 
 Prior to utilizing the DMA peripherals, remember to enable their clocks ! For 
 example, 
 RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1 , ENABLE);+
  
 Configuring a channel consists of setting appropriate parameters through a 
 DMA_InitTypeDef structure: 
 typedef struct 
  
 { 
  
 uint32_t DMA_PeripheralBaseAddr 
  
 uint32_t DMA_MemoryBaseAddr;
  
 Revision: 14c8a1e (2016-06-05) 
 181",NA
12.2 ,NA,NA
SPI DMA Support,"A complete SPI 8-bit data receive routine utilizing DMA is illustrated in 
 Listings 12.1 and 12.2. The DMA initialization structure is configured as 
 follows. 
 182  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 13,NA,NA
DAC : Digital Analog ,NA,NA
Converter,"The STM32 F1xx parts have a 12-bit digital-analog-converter (DAC) 
 module with two independent output channels – DAC1 (pin PA4) and DAC2 
 (pin PA5). The channels can be configured in 8-bit mode or 12-bit mode and 
 the conversions can be done independently or simultaneously. Simultaneous 
 mode can be used where two independent but synchronized signals must be 
 generated – for example, the left and right channels of stereo audio. It is often 
 important that the analog output is update at precise instants, sometimes 
 controlled by external hardware – thus the conversion process can be 
 triggered by timers or external signals. Finally, a common use for DAC 
 hardware is to generate a time varying signal. Where the sample rate is high, it 
 is impractical to control the conversion process entirely through application 
 software or even interrupt handlers. Thus, each DAC channel has DMA 
 capability which can be controlled by the trigger signal. 
 In this chapter we will explore the use of a single DAC channel. We will 
 start with the simplest case – direct software control of a analog output – 
 which is useful for creating slow moving signals that do not have to be 
 synchronized in time. We will then explore the generation of time-
 synchronized signals; first with DAC module provided triangle wave 
 generator, and then interrupt driven code to produce a sine wave. Interrupt 
 driven operation does not scale well to high update rates – eventually, all of 
 the processor cycles are required just to service the interrupt. Thus, we will 
 examine the use of DMA to “feed”the DAC, with a lower frequency interrupt 
 used to update the DMA buffer. Finally, we will define an exercise to read 
 audio files from an SD card and play them, via DMA, to an external audio 
 amplifier driven by the DAC. 
 Revision: 14c8a1e (2016-06-05) 
 189",NA
13.1 ,NA,NA
Example DMA Driven DAC,"While an interrupt driven DAC has fewer jitter issues, ultimately, the 
 interrupt handler will consume all the available cycles. With the use of DMA 
 we can reduce the software overhead by a factor proportional to the buffer 
 size that we are willing to allocate. The DMA hardware handles the details of 
 writing individual samples to the DAC at the timer rate while an interrupt 
 handler is responsible for refreshing the buffer. As we shall see, with a N-item 
 buffer, we can reduce our interrupt rate by a factor of N/2. 
 This example builds upon Exercise 13.3. The major changes are: 
 • Initialize a DMA channel (DMA1 Channel 3) 
 • Initialize the NVIC for an interrupt handler 
 • Create an interrupt handler 
 We continue to use TIM3 to drive the conversion process; however, 
 rather than calling an interrupt handler to generate the next datum, the DMA 
 device provides this datum. We assume that you have generated a 100 item 
 array with the A440 tone. For this example, we will create a buffer of the same 
 size – initially a perfect clone. 
 for (i = 0; i < A440LEN; i++) 
  
  
 outbuf[i] = a440[i];
  
 The DAC interrupt handler is responsible for refilling this buffer in 
 alternating halves (Listing 13.2). In this example, the refilling action is not 
 particularly interesting since we are simply re-copying the A440 tone into our 
 output buffer. However, the key idea is that the interrupt handler is called 
 with 
 the 
 DMA 
 transfer 
 is 
 completed 
 (DMA1_IT_TC3) 
 and 
 “half 
 completed”(DMA_IT_HC3) – each case fills a different half of the buffer. This 
 approach provides the greatest resilience to potential timing issues. 
  
 Configuration is somewhat more complicated because of the need to 
 initialize a DMA channel (Listing 13.3). Notice that the peripheral register is for 
 DHR12R1, and that the DMA is operating in “circular mode” which means that 
 it continuously pulls from a single memory buffer.  
 The DMA 
 channel is configured to generate interrupts at the half and full completion 
 marks. Another notable configuration step is the configuration of the DAC to 
 utilize DMA DAC_DMACmd(DAC_Channel_1, ENABLE). 
 194  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 14,NA,NA
ADC : Analog Digital ,NA,NA
Converter,"The dual of a DAC is an ADC (analog digital converter) which con-verts 
 analog signals to digital values. The STM32 processors include one or more 
 ADC peripherals – there is one on the medium density value line parts. The 
 STM32 ADC uses successive approximation – the ADC has the ability to 
 generate a discrete set of voltages and to compare these against a sampled 
 input voltage; it essentially performs binary search to find the best approx-
 imation. For 12 bits of accuracy, the STM32 takes at least 14 cycles of the ADC 
 clock (a multiple of the system clock) – the extra 2 cycles are overhead due to 
 sampling. Thus, With a 12 MHz ADC clock, the STM32 ADC can perform a 
 sample in slightly more than 1
 µsec
 . 
 Although the STM32 VL component has a single ADC, it can support multiple 
 analog inputs.  
 The basic architecture is illustrated in Figure 14. On 
 the discovery board, PA0-PA7, PB0-PB1, and PC0-PC5 may all be used as 
 analog inputs which can be multiplexed to the ADC. The ADC may be 
 configured to sample any subset of these inputs in succession. There are two 
 basic modes of operation – single and continuous conversion. With single 
 conversion, once the ADC is triggered, it converts a single input and stores the 
 result in its data register (DR). The trigger may either come from software or 
 signal such as a timer. In continuous mode, the ADC starts another conversion 
 as soon as it finishes one. The ADC may also operate in scan mode where a set 
 of inputs to be scanned is configured. A single conversion is performed for each 
 configured input in succession. Scans may also be continuous in the sense that 
 a new scan begins as soon as one is completed. 
 Revision: 14c8a1e (2016-06-05) 
 201",NA
14.1 ,NA,NA
About Successive Approximation ADCs,"To fully understand the STM32 ADC it is helpful to have some back-
 ground in how successive approximation ADCs operate. Consider Figure 14.1 
 which illustrates a typical ADC. At its heart is a digital analog converter (DAC). 
 To begin a conversion, a hardware control “captures” a sample of input 
 voltage (
 V
 ain
 ) – shown here with some external resistance
  R
 ain
  to be discussed 
 in the sequel. Once the input (
 V
 samp
 ) is captured, the controller generates a 
 sequence of digital approximations
  D
 (
 v
 est
 ) and checks each by converting the 
 approximation to an analog signal which is then compared against the 
 sampled input. The sequence of approximations corresponds to 
 202  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 15,NA,NA
NewLib,"Throughout this book we’ve lived without the standard C libraries (libc) 
 even though an implementation is distributed with the Sourcery tools that we 
 use for building projects. The primary reason we have avoided libc thus far is 
 to maintain clarity about what code is actually executing – as we’ll see, 
 introducing libc can quickly lead to obfuscation. A second reason is that libc is 
 a memory hog – with only 8k SRAM available on the discovery board 
 processor, there isn’t much room to spare. However, the first consideration is 
 now moot – you’ve had a pretty complete introduction to writing code for the 
 STM32, and the second consideration is much less important if you move on 
 to larger members of the STM32 family. There are many advantages to using 
 libc including access to the standard library functions. 
 The implementation of libc distributed with the Sourcery tools and widely 
 used for embedded systems is “newlib.” newlib includes the stdlib functions (e.g. 
 abs, atoi, atoll, malloc, and unicode support), stdio (printf, sprintf, scanf, ...), 
 string support, and many others. newlib also includes an implementation of the 
 standard math libraries libm. Unfortunately, the stdio functions are particular 
 memory hogs as they allocate rather large mem-ory buffers to support I/O. 
 Furthermore, by default (for example, the Sourcery distribution) newlib is not 
 configured to minimize memory use. Thus, we will also show how to compile 
 newlib from sources to optimize memory use. 
 The architecture of newlib requires an external implementation of key 
 system functions including – open, close, read, write, and sbrk – the last of 
 these is the building block upon which malloc is built. In order to use libc, it is 
 necessary to provide at least stubs for these and other functions. We will show 
 how to design these stubs to support standard I/O using the STM32 USART 
 Revision: 14c8a1e (2016-06-05) 
 209",NA
15.1 ,NA,NA
Hello World,"“Hello World” is the most famous programming example in the C uni-
 verse. As we pointed out in Chapter 3, it’s actually pretty complex. Consider 
 the program: 
 #include <stdio.h> 
  
 main() { 
  
  
 printf(""hello world\n""); 
  
 }
  
 printf is a library function which takes a format string and an optional 
 list of parameters. It must stringify these parameters, merge them with the 
 format string, and write the resulting string to stdout. What is stdout ? It’s a 
 buffered stream – the stdio libraries manage buffered streams. Data are 
 buffered as they are written, and then the buffered data are written to a file or 
 device. In this case, our intuition is that this stream should somehow be 
 connected to a UART to print to a screen somewhere. While our use of printf is 
 trivial, more complex invocations allocate memory in order to have space for 
 performing any conversions. 
 If we attempt to compile “hello world” (create a project and try this !), 
 we immediately learn that there are a number of undefined functions (List-ing 
 15.1). 
 In a desktop environment, these all correspond to operating system 
 calls– libc is just a code library, ultimately it needs access to an operating 
 system API. In order to use newlib, we must provide the missing functionality 
 in the form of procedures. Some of these we will replace with simple stubs, 
 others (read and write) with code that accesses a uart. 
 As we mentioned, libc allocates memory – a lot of it – from the 
 “heap.”libc provides functions to manage the heap (malloc and free), but it de- 
 210  
 Revision: 14c8a1e (2016-06-05)",NA
15.2 Building newlib,"The distribution of newlib with the Sourcery tool was not compiled for 
 minimum memory usage. You can build your own version by downloading the 
 newlib sources and using the following build process: 
 mkdir newlib -build 
  
 cd newlib -build 
  
 export CFLAGS_FOR_TARGET=''-g -O2 -DSMALL_MEMORY'' 
  
 /path_to_newlib_source/configure --target=arm-none-eabi
  
  
 →
 --prefix=/target-directory --disable -newlib -supplied -syscalls
  
 →
 --disable -libgloss 
 --disable -nls
  
 Revision: 14c8a1e (2016-06-05) 
 215",NA
Chapter 16,NA,NA
Real-Time Operating Systems,"The STM32 hardware is capable of simultaneously performing actions 
 on all its various communication buses – for example reading audio files from 
 an SD card on the SPI bus, playing these audio files through the DAC, mon-
 itoring Nunchuks over the I2C bus and logging messages through the UART. 
 However, coordinating these parallel activities through software can be a real 
 challenge – especially where hard timing constraints must be satisfied. One 
 common strategy is to partition responsibility for multiple activities among 
 separate threads – each of which acts autonomously – which are scheduled 
 based upon priorities. For example, threads with tight timing constraints are 
 given higher priorities than other threads. 
 Threads provide a way to partition the logic of a program into separate 
 tasks. Each thread has its own state and appears to execute as an autonomous 
 program while sharing data with other threads. In a uni-processor such as the 
 STM32, threads are executed in an interleaved manner with access to the 
 processor controlled by a scheduler. Whenever an interrupt occurs, there is 
 an opportunity to suspend the current thread and resume a blocked thread. A 
 timer interrupt provides the mechanism to “time-slice” the processor allowing 
 each ready thread the opportunity to make forward progress. 
 Coordination of hardware tasks by multiple threads is enabled through 
 synchronization objects. For example, a thread which is attempting to trans-
 mit a stream of data through a UART cannot make forward progress when the 
 output buffer is full. In this case, the thread should “wait” allowing other 
 threads to execute. Later when space is freed in the transmit buffer, for exam-
 ple by an interrupt handler, the waiting thread can be “signaled” to resume. 
 This wait/signal pattern is implemented using a synchronization object called 
 a “semaphore.” 
 Revision: 14c8a1e (2016-06-05) 
 217",NA
16.1 Threads,"The single threaded programs which we have developed throughout 
 this book organize RAM with all statically defined data allocated space in the 
 low address portion of RAM and the program stack initialized at the top 
 (highest address) in RAM. As the program executes, the stack grows 
 downward on entry to procedures and shrinks upward on procedure exit. 
 When interrupts occur, key portions of the execution context are pushed onto 
 the main stack –see Chapter 11 for further explanation. In a multi-threaded 
 environment, the main stack is used during initialization and then, primarily 
 as an interrupt stack. Each active thread is allocated its own stack within RAM 
 as illustrated in Figure 16.1. 
 RAM End (high)
  
 Main Stack
  
 SP
  
 Heap End
  
 Thread 1
  
 Thread 2
  
 SP thread 1
  
 SP thread 2
  
 Heap Start
  
 Data
  
 RAM Start (low)
  
 Figure 16.1: RAM Layout with Executing Threads 
 The data area is allocated statically at link time and includes all global and 
 static variables both initialized and uninitialized. The area above the data is 
 used for dynamic memory allocation (e.g. malloc). This area, called the heap, is 
 expanded by the memory allocator as required. The main stack is placed at the 
 high end of RAM by the linker and grows downward.  
 In 
 FreeRTOS, the thread stacks are allocated blocks within the heap. Space is 
 Revision: 14c8a1e (2016-06-05) 
 219",NA
16.2,NA,NA
FreeRTOS Configuration,"FreeRTOS/ 
  
  
  
 Demo/CORTEX_STM32F100_Atollic/Simple_Demo_Source/ 
  
  
 FreeRTOSConfig.h 
 Source/ 
  
  
  
  
  
  
  
 include/  
 list.c  
 portable/ 
  
  
  
 MemMang/ 
  
  
 heap_1.c 
 GCC/ARM_CM3/ 
  
  
  
 port.c  
 portmacro.h 
 queue.c  
 tasks.c  
 timers.c 
  
 Figure 16.3: Key Parts of FreeRTOS Distribution 
 The FreeRTOS source code is freely available from http://sourceforge. 
 net/projects/freertos/files/. The distribution can be a little overwhelm-ing. The 
 key files which we use are illustrated in Figure 16.3. In creating a sample 
 application, it will be necessary to augment your makefile to include the 
 necessary paths, as illustrated in Listing 16.2. 
 FreeRTOS = ... path_to_FreeRTOS ...
  
 CFLAGS 
  
 +=
  
 -I$(FreeRTOS)/include -DGCC_ARMCM3 ...
  
 vpath %.c $(FreeRTOS)/ 
  
 vpath %.c $(FreeRTOS)/portable/MemMang vpath %.c 
 $(FreeRTOS)/portable/GCC/ARM_CM3 ...
  
 OBJS+= tasks.o queue.o list.o timers.o heap_1.o port.o
  
 Listing 16.2: Build Paths for FreeRTOS 
 Every FreeRTOS project requires a configuration file. This is used to set 
 key parameters of the project; for example, enabling or disabling kernel 
 features – FreeRTOSConfig.h. We based our projects on the configuration file 
 shown in Figure 16.3. The configuration file serves several purposes. First, it 
 224  
 Revision: 14c8a1e (2016-06-05)",NA
16.3,NA,NA
Synchronization,"Threads cannot safely share either data structures or hardware without some 
 synchronization mechanisms. Consider the following getchar imple-mentation 
 discussed in Chapter 5: 
  
 int getchar(void){ 
  
  
 while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET); 
  
 return 
 USARTx ->DR & 0xff; 
  
 }
  
 Revision: 14c8a1e (2016-06-05) 
 225",NA
16.4 Interrupt Handlers,"The getchar code above has a major flaw – the thread holding the mutex will 
 continue to spin on the flag test until it succeeds.  
 Ideally, we 
 need a mechanism to allow the waiting thread to sleep until space is available. 
 With peripherals such as UARTs we have already seen that interrupt code can 
 handle the actual changes in hardware status. In Section 11.5 we showed how 
 this might work. The remaining issue is how to communicate these hardware 
 events with interrupt handlers. As we showed previously, we would like to 
 associate a pair of queues with the transmit and receive interfaces of the UART. 
 Where previously our putchar code failed when the trasmit queue was empty 
 and our getchar code failed when the receive queue was empty, in a multi-
 threaded environment we would like to block a thread in either of these cases 
 and have the interrupt handler wake the thread. 
 FreeRTOS provides its own blocking queue primitives (indeed, semaphores and 
 mutexes are special cases of queues): 
 Revision: 14c8a1e (2016-06-05) 
 227",NA
16.5 ,NA,NA
SPI,"The other communication interfaces we have introduced in this book 
 also need to be reconsidered in the face of multi-threading. The I2C interface 
 is much like the Uart interface in that a semaphore can be added directly to 
 the interface code to protect the read/write interfaces (only one semaphore is 
 needed). SPI is somewhat different – whereas the I2C protocol includes device 
 addressing in the transmitted data, SPI uses separate select lines for 
 230  
 Revision: 14c8a1e (2016-06-05)",NA
16.6 ,NA,NA
FatFS,"The FatFS code has some builtin support for multi-threading which must 
 be enabled in the ffconf.h. 
 #define _FS_REENTRANT 0 
  
 /* 0:Disable or 1:Enable 
  
 */ 
 #define _FS_TIMEOUT 
  
 1000 
  
 /* Timeout period in unit of ticks 
  
 */ 
 #define _SYNC_t 
  
 HANDLE
  /* O/S dependent type of sync object */
  
 It is up to the user to define an appropriate _SYNC_t type and to provide 
 implementations 
 for 
 ff_req_grant, 
 ff_rel_grant, 
 ff_del_syncobj 
 and 
 ff_cre_syncobj. It is also necessary to modify the low-level device in-terface to 
 utilize a modified SPI interface and to replace busy waiting with appropriate 
 RTOS delay functions. 
 Exercise 16.5 
  
 Multithreaded FatFS
  
 Rewrite the low-level interface for the FatFS to use the new SPI inter-
 face and to remove busy waiting – your changes should work either in a single 
 232  
 Revision: 14c8a1e (2016-06-05)",NA
16.7,NA,NA
FreeRTOS API,"Here we 
 The FreeRTOS API is documented at www.freertos.org. identify the 
 key API functions used throughout this chapter. 
  
  
 Task Creation 
 xTaskCreate()  
 Create task 
 xTaskDelete()  
 Delete task 
 Task Utilities 
 vTaskDelay()  
 Delay from now 
 vTaskDelayUntil()  
 Delay from previous wake time 
 Kernel Utilities 
 taskYIELD()  
 Force a context switch 
 vTaskSuspendAll()  
 Prevent current task from being preempted 
 vTaskResumeAll()  
 Resume normal scheduling 
 Queues 
 uxQueueMessagesWaiting()  
 Number of messages in queue 
 xQueueCreate()  
 Create queue 
 xQueueDelete()  
 Create queue 
 xQueueSend()  
 Send to queue 
 xQueueReceive()  
 Receive from queue 
 xQueueSendFromISR()  
 ISR send to queue 
 xQueueReceiveFromISR()  
 ISR Receive from queue 
 Sempahore 
 vSemephoreCreateBinary()  
 Create a binary semaphore 
 vSemephoreCreateCounting()  
 Create a counting semaphore 
 vSemephoreCreateMutex()  
 Create a mutex 
 vSemephoreCreateTake()  
 Take from semaphore 
 vSemephoreCreateGive()  
 Give to semaphore 
 vSemephoreCreateGiveFromISR()  
 Give from ISR to semaphore 
 Table 16.1: FreeRTOS API – Key Calls 
 Revision: 14c8a1e (2016-06-05) 
 233",NA
16.8 ,NA,NA
Discusion,"Developing a project with FreeRTOS is a lot of work ! All of the device 
 interfaces have to be written to support multi-threading and great care taken 
 to ensure freedom from race conditions. An alterantive is to use an RTOS with 
 a hardware abstraction layer such as Chibios where much of the heavy lifting 
 has been done for you. 
 You probably have also found that debugging multi-threaded code is 
 very challenging. The message is clear – use threads only when really needed. 
 234  
 Revision: 14c8a1e (2016-06-05)",NA
Chapter 17,NA,NA
Next Steps,"In the preceding chapters you’ve learned many of the basic skills 
 needed to build interesting projects using STM32 processors and off-the-shelf 
 modules. In this chapter, I provide pointers to many additional modules and 
 guidance for how the skills you’ve learned can be applied to develop code to 
 interface to these. By now, it should be evident that SRAM is a major limitation 
 of the STM32 VL Discovery Processor. Both newlib and FreeRTOS need much 
 more memory to operate and large projects can greatly benefit from the 
 additional abstraction layer provided by these libraries. Thus, I begin with a 
 discussion of boards providing STM32 processors with larger memories. It 
 should also be evident by now that using a SPI-based LCD, while adequate for 
 basic display isn’t really up to the performance needs of complex graphics; 
 higher performance is achieved at the expense of a new interface. 
 The interfaces you’ve learned can be applied to a wide variety of new 
 sensors including climate (temperature/pressure/humidity), position and 
 iner-tial (accelerometer/gyroscope/magnetometer/GPS), force (flex sensors) 
 – I’ll discuss some of these, but a useful step is to peruse the offerings of 
 companies such as Sparkfun while noting the interfaces their modules 
 require. The basic serial interface enables the use of various wireless 
 communication devices in-cluding bluetooth, wifi, and GSM (cell phone) while 
 the SPI interface enables the use of low-power radio devices. Finally timers 
 provide the key to motion control including stepper motor and DC control 
 with position feedback. 
 This chapter is intended primarily to illustrate the world your new 
 skills enable – not as definitive guide to interfacing and using new modules; 
 that job is up to you. 
 Revision: 14c8a1e (2016-06-05) 
 235",NA
17.1 ,NA,NA
Processors,"The STM32 F100 micro-controller used on the VL Discovery board is one 
 member of a series of STM32 F1xx components which includes: 
 • Value line STM32 F100 – 24 MHz CPU with motor control and CEC 
  
 functions 
 • Access line STM32 F101 – 36 MHz CPU, upt to 1 MByte Flash 
 • USB Access line STM32 F102 – 48 MHz with USB file system 
 • Performance line STM32 F103 – 72 MHz, up to 1 Mbyte Flash with 
  
 motor control, USB and CAN 
 • Connectivity line STM32 F105/STM32 F107 – 72 MHz CPU with Eth-
  
 ernet MAC, CAN and USB 2.0 OTG 
 All of these lines of components utilize the same standard peripheral 
 libraries. They do require modifications to the linker script (particularly the 
 definitions of memory regions) and startup code (the definitions of exception 
 vectors); however neither task is difficult. They also include peripherals that 
 you have not seen including support for external memory (FSMC), a higher 
 level SD interface (SDIO) and communication interfaces such as USB, Eth-
 ernet, and CAN. The communication interfaces generally require significant 
 additional software libraries and can be very difficult (e.g. USB) to debug. 
 All of the examples from this book should work without modification on 
 any processor from the the STM32F1xx families. A few changes will be 
 required to the files in the template directory provided with this book. The 
 linker script from STM32-Template needs the following modification: 
 MEMORY 
  
 { 
  
  
 RAM (rwx) 
  
 : ORIGIN = 0x20000000 , LENGTH = 8K 
  
 FLASH (rx) : ORIGIN = 0x08000000 , LENGTH = 128K }
  
 [frame=none] 
 The lengths of the two memory regions should be modified to reflect the 
 component being use. Makefile.common needs to have its LDSCRIPT, PTYPE, 
 STARTUP variables modified as appropriate. Finally, the vector table in 
 startup_stm32f10x.c will need to be updated to reflect the vectors in the 
 236  
 Revision: 14c8a1e (2016-06-05)",NA
17.2 ,NA,NA
Sensors,"There are many sensors available that have SPI, I2C, or analog inter-
 faces. In this section we discuss a few of these. Interested readers should 
 peruse the Sparkfun site for ideas. 
 Position/Inertial Measurement
  
 ST, Analog devices, and Freescale all make accelerometer devices –
 many of these are supported by break-out boards from Sparkfun.com which 
 provides a handy buying guide http://www.sparkfun.com/tutorials/167. In 
 general, these devices use I2C, SPI, or analog interfaces. A complete “iner-tial 
 measurement unit” generally contains a 3-axis accelerometer, 3-axis gyro-
 scope, and 3-axis magnetometer; ST produces a module containing all three of 
 these devices in a DIP form-factor (STEVAL-MKI108V2) which is available 
 from Mouser for $29. 
 Another useful position sensing device is a GPS receiver. Sparkfun sells 
 a nice unit based upon the Venus638FLPx for $50. Like most such units, this 
 communicates with asynchronous serial – simply hook it up to a UART. 
 Environmental Sensors
  
 Environmental sensors include temperature, humidity, and pressure. 
 These are widely available with I2C interfaces, although some such as Max-
 im/Dallas 1-wire devices require a special protocol. The 1-wire protocol is not 
 directly supported by the STM32 peripherals, but can be implemented with 
 238  
 Revision: 14c8a1e (2016-06-05)",NA
17.3 Communication,"Many interesting projects require enhanced communication either 
 wire-less or wired. In the wireless domain, inexpensive modules bluetooth, 
 wifi, and even GSM cellular phones are available with serial interfaces. For low 
 power applications, dedicated radio links such as the Nordic nRF24L01 utilize 
 SPI interfaces. Finally, it is relatively easy to interface to standard infrared 
 remote controls with a simple IR detector.",NA
17.4 Discussion,"I hope the ideas discussed in this chapter give you some idea of the 
 possibilities. There is a vibrant maker community that can provide practical 
 guidance – you might seek out examples developed for the arduino platform. 
 Revision: 14c8a1e (2016-06-05) 
 239",NA
Attributions,"Figure 1.10 was obtained from http://commons.wikimedia.org/wiki/ 
 File:Potentiometer.jpg under the Creative Commons Attribution-Share Alike 
 3.0 Unported license (http://creativecommons.org/licenses/by-sa/ 
 3.0/deed.en). This image is also used in Figure 14.1 
 Figure 1.6 is covered by the Creative Commons Attribution-NonCommercial-
 ShareAlike 3.0 Unported license. The image is due to www.sparkfun.com. 
 Revision: 14c8a1e (2016-06-05) 
 241",NA
Bibliography,"[1
 ]  
 [2
 ]  
 [3
 ]  
 [4
 ] 
 [5
 ]  
 [6
 ]  
 [7
 ]  
 [8
 ]  
 [9
 ] 
 ARM Limited. Cortex-M3 technical reference manual, 2006. 
 ARM Limited. Procedure call standard for the ARM® architecture, Oc-
 tober 2009. IHI 0042D. 
 ChaN. FatFs generic FAT file system module, 2011. http://elm-chan. 
 org/fsw/ff/00index_e.html. Accessed April 2012. 
 F. Foust. 
 Secure digital card interface for the MSP430, 
 2004. 
 http://alumni.cs.ucr.edu/~amitra/sdcard/Additional/sdcard_ 
 appnote_foust.pdf. Accessed July 2012. 
 J. Jiu.
  The Definitive guide to the ARM Cortext-M3
 . Newnes, 2010. 
 Microchip. 25AA160A/25LC160A 16K SPI bus serial EEPROM, 2004. 
 NXP. 
 ı2c bus specification and user manual (rev 03), June 2007. 
 UM10204. 
 C. Philips.  
 Read wii nunchuck data into arduino. 
 windmeadow.com/node/42. Accessed February 4, 2012. 
 http://www. 
 SD specifications, part 1, physcial layer simplified specification, version 
 3.01, May 2010. 
 [10] F. Semiconductor. Tilt sensing using linear accelerometers, 2012. [11] 
 Sitronix Technology Corporation. Sitronix st7735r 262k color single-chip TFT 
 controller/driver, 2009. 
 [12] STMicroelectronics.  
 How to get the best ADC accuracy in the 
 STM32F10xxx devices, November 2008. 
 [13] STMicroelectronics. STM32F10xxx ı2c optimized examples, 2010. 
 Revision: 14c8a1e (2016-06-05) 
 243",NA
