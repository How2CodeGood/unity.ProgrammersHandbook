Larger Text,Smaller Text,Symbol
Leo Brodie,NA,NA
THINKING ,NA,NA
FORTH ,NA,NA
A Language,NA,NA
and Philosophy,NA,NA
for Solving Problems,NA,NA
"Includes interviews with Forth’s inventor, C",HARLES,NA
 H.,NA,NA
M,OORE,NA
", and other Forth thinkers",NA,NA
Leo Brodie,NA,NA
THINKING ,NA,NA
FORTH ,NA,NA
A Language,NA,NA
and Philosophy,NA,NA
for Solving Problems,NA,NA
Contents,"Contents
 , vii 
  
 Preface to the 1994 Edition
 , xi 
  
 Preface
 , xiii
  
 The Philosophy of Forth
 , 1
  
 An Armchair History of Software Elegance
 , 2 
 The 
 Superficiality of Structure
 , 18 
  
 Looking Back, and Forth
 , 19 
  
 Component Programming
 , 20 
  
 Hide From Whom?
 , 24 
  
 Hiding the Construction of Data Structures
 , 25 
 But Is It a High-Level Language?
 , 27 
  
 The Language of Design
 , 31 
  
 The Language of Performance
 , 32 
  
 Summary
 , 34 
  
 References
 , 35
  
 Analysis
 , 37
  
 The Nine Phases of the Programming Cycle
 , 38 
 The Iterative Approach
 , 39 
  
 The Value of Planning
 , 40 
  
 The Limitations of Planning
 , 42 
  
 The Analysis Phase
 , 45 
  
 Defining the Interfaces
 , 49 
  
 Defining the Rules
 , 52 
  
 Defining the Data Structures
 , 59 
  
 Achieving Simplicity
 , 60 
  
 Budgeting and Scheduling
 , 66 
  
 Reviewing the Conceptual Model
 , 68 
  
 References
 , 69",NA
PREFACE TO THE ,NA,NA
1994 EDITION,"I’m honored that the Forth Interest Group is reprinting Thinking Forth. It’s 
 gratifying to know that the book may have value to appreciators and users of 
 Forth.
  
 This edition is a reproduction of the original edition, with only minor 
 typographical corrections. A lot has happened in the ten years since the book’s 
 original publication, rendering some of the opinions obsolete, or at best archaic. 
 A “revised, updated edition” would have entrailed a rewrite of many sections, a 
 larger effort than I’m able to make at the time.
  
 Off all the opinions in the book, the one that I most regret seeing gin print 
 is my criticism of object-oriented programming. Since penning this book, I’ve 
 had the pleasure of writing an application in a version of Forth with sup-port 
 for object-oriented programming, developed by Digalog Corp. of Ventura, 
 California. I’m no expert, but it’s clear that the methodology has much to offer.
  
 With all this, I believe that many of the ideas in Thinking Forth are as 
 valid today as they were back then. Certainly Charles Moore’s comments 
 remain a telling insight on the philosophy that triggered the development of 
 Forth.
  
 I with to thank Marlin Ouverson for his excellent job, patiently strug-gling 
 against incompatible file formats and OCR errors, to bring this reprint to life.",NA
PREFACE,"Programming computers can be crazy-making. Other professions give you the 
 luxury of seeing tangible proof of your efforts. A watchmaker can watch the 
 cogs and wheels; a seamstress can watch the seams come together with each 
 stitch. But programmers design, build, and repair the stuff of imagination, 
 ghostly mechanisms that escape the senses. Our work takes place not in RAM, 
 not in an editor, but within our own minds.
  
 Building models in the mind is both the challenge and the joy of program-
 ming. How should we prepare for it? Arm ourselves with better debuggers, 
 decompilers, and disassemblers? They help, but our most essential tools and 
 techniques are mental. We need a consistent and practical methodology for 
 Thinking about software problems. That is what I have tried to capture in this 
 book. Thinking Forth is meant for anyone interested in writing software to 
 solve problems. It focuses on design and implementation; deciding what you 
 want to accomplish, designing the components of the system, and finally 
 building the program.
  
 The book stresses the importance of writing programs that not only 
 work, but that are also readable, logical, and that express the best solution in 
 the simplest terms.
  
 Although most of the principles described here can be applied to any 
 language, I’ve presented them in the context of Forth. Forth is a language, an 
 operating system, a set of tools, and a philosophy. It is an ideal means for 
 thinking because it corresponds to the way our minds work. Thinking Forth is 
 thinking simple, thinking elegant, thinking flexible. It is not restrictive, not 
 complicated, not over-general. You don’t have to know Forth to benefit from 
 this book. Thinking Forth synthesizes the Forth approach with many principles 
 taught by modern computer science. The marriage of Forth’s simplicity with the 
 traditional disciplines of analysis and style will give you a new and better way 
 to look at software problems and will be helpful in all areas of computer 
 application.
  
 If you want to learn more about Forth, another book of mine, Starting 
 Forth, covers the language aspects of Forth. Otherwise, Appendix
  A
  of this book 
 introduces Forth fundamentals.",NA
ONE,NA,NA
The Philosophy,NA,NA
of Forth,NA,NA
An Armchair History of Software Elegance,"In the prehistoric days of programming, when computers were dinosaurs, the 
 mere fact that some genius could make a program run correctly provided great 
 cause for wonderment. As computers became more civilized, the wonder 
 waned.
  
 Management wanted more from programmers and from their programs.
  
 As the cost of hardware steadily dropped, the cost of software soared. It 
 was no longer good enough for a program to run correctly. It also had to be 
 developed quickly and maintained easily. A new demand began to share the 
 spotlight with correctness. The missing quality was called “elegance.”
  
  
 In this section we’ll outline a history of the tools and techniques for 
 writing more elegant programs.
  
 Memorability
  
 The first computer programs looked something like this:
  
 0011010
 1 
  
 1101001
 1 
  
 1101100
 1",NA
The Superficiality of Structure,"Parnas proposes two criteria for decomposition:
  
 1. possible (though currently unplanned) reuse, and
  
 2. possible (though unplanned) change.
  
 This new view of a “module” is different than the traditional view. This “mod-
 ule” is a collection of routines, usually very small, which together hide infor-
 mation about some aspect of the problem.
  
 Two other writers describe the same idea in a different way, using the 
 term “data abstraction” [
 5
 ]. Their example is a push-down stack. The 
 stack“module” consists of routines to initialize the stack, push a value onto the 
 stack, pop a value from the stack, and determine whether the stack is empty. 
 This“multiprocedure module” hides the information of how the stack is 
 constructed from the rest of the application. The procedures are considered to 
 be a single module because they are interdependent. You can’t change the 
 method for pushing a value without also changing the method for popping a 
 value.
  
  
 The word uses plays an important role in this concept. Parnas writes in a 
 later paper [
 6
 ]:
  
 Systems that have achieved a certain “elegance”. . . have done so by having parts of 
 the system use other parts. . .
  
 If such a hierarchical ordering exists then each level offers a testable and usable 
 subset of the system. . .
  
 The design of the “uses” hierarchy should be one of the major milestones in a 
 design effort. The division of the system into independently callable subpro-
 grams has to go in parallel with the decisions about uses, because they influence 
 each other.
  
 A design in which modules are grouped according to control flow or sequence 
 will not readily allow design changes. Structure, in the sense or control-flow 
 hierarchy, is superficial.
  
  
 A design in which modules are grouped according to things that may 
 change can readily accommodate change.
  
 18 
  
 The Philosophy of Forth",NA
"Looking Back, and Forth","In this section we’ll review the fundamental features of Forth and relate them to 
 what we’ve seen about traditional methodologies.
  
 Here’s an example of Forth code;
  
 : BREAKFAST
  
 HURRIED?
  
 IF
  
 CEREAL
  
 ELSE
  
 EGGS
  
 THEN CLEAN ;
  
 This is structurally identical to the procedure MAKE-BREAKFAST on page
  8
 . (If 
 you’re new to Forth, refer to Appendix
  A
  for an explanation.) 
  
 The words 
 HURRIED?, CEREAL, EGGS, and CLEAN are (most likely) also defined. as colon 
 definitions.
  
 Up to a point, Forth exhibits all the traits we’ve studied: mnemonic value, 
 abstraction, power, structured control operators, strong functional binding, But 
 regarding modularity, we encounter limited coupling, and modularity.
  
 what may be Forth’s most significant breakthrough:
  
 The smallest atom of a Forth program is not a module or a subroutine or a 
 procedure, but a “word.”
  
 Furthermore, there are no subroutines, main programs, utilities, or executives, 
 each of which must be invoked differently. Everything in Forth is a word. 
  
 Before we explore the significance of a word-based environment, let’s first 
 study two Forth inventions that make it possible.
  
 Implicit Calls
  
 First, calls are implicit. You don’t have to say CALL CEREAL, you simply say 
 CEREAL. In Forth, the definition of CEREAL “knows” what kind of word it is and 
 what procedure to use to invoke itself.
  
 Thus variables and constants, system functions, utilities, as well as any 
 user-defined commands or data structures can all be “called” simply by name.
  
 Implicit Data Passing
  
 Second, data passing is implicit. The mechanism that produces this effect is 
 Forth’s data stack. Forth automatically pushes numbers onto the stack; words 
 that require numbers as input automatically pop them off the stack; words that 
 produce numbers as output automatically push them onto the stack. The words 
 PUSH and POP do not exist in high-level Forth.
  
 Thus we can write:
  
 : DOIT
  
 GETC
  
 TRANSFORM-TO-DO
  
 PUT-D ;
  
 confident that GETC will get “C”, and leave it on the stack. TRANSFORM-TO-D 
 will pick up “C” from the stack, transform it, and leave “D” on the stack. Finally,
  
 Looking Back, and Forth 
  
 19",NA
Component Programming,"Having a larger set of simpler words makes it easy to use a technique we’ll 
 call“component programming.” To explain, let’s first reexamine these 
 collections we have vaguely described as “things that may change.” In a typical 
 system, just about everything is subject to change: I/O devices such as 
 terminals and printers, interfaces such as UART chips, the operating system, 
 any data struc-ture or data representation, any algorithm, etc.
  
  
 The question is: “How can we minimize the impact of any such change? 
 What is the smallest set of other things that must change along with such a 
 change?”
  
  
 The answer is: “The smallest set of interacting data structures and algo-
 rithms that share knowledge about how they collectively work.” We’ll call this 
 unit a “component.”
  
  
 A component is a resource. It may be a piece of hardware such as a UART 
 or a hardware stack. Or the component may be a software resource such as a 
 queue, a dictionary, or a software stack.
  
 20 
  
 The Philosophy of Forth",NA
Hide From Whom?,"Because modern mainstream languages give a slightly different meaning to the 
 phrase “information-hiding,” we should clarify. From what, or whom are we 
 hiding information?
  
 The newest traditional languages (such as Modula 2) bend over back-
 wards to ensure that modules hide internal routines and data structures from 
 other modules. The goal is to achieve module independence (a minimum cou-
 pling). The fear seems to be that modules strive to attack each other like alien 
 antibodies. Or else, that evil bands of marauding modules are out to clobber the 
 precious family data structures.
  
 This is not what we’re concerned about. The purpose of hiding informa-
 tion, as we mean it, is simply to minimize the effects of a possible design-change 
 by localizing things that might change within each component.
  
 Forth programmers generally prefer to keep the program under their 
 own control and not to employ any techniques to physically hide data 
 structures. (Nevertheless a brilliantly simple technique for adding Modula-type 
 modules to Forth has been implemented, in only three lines of code, by Dewey 
 Val Shorre [
 7
 ].)
  
 24 
  
 The Philosophy of Forth",NA
Hiding the Construction of Data Structures,"We’ve noted two inventions of Forth that make possible the methodology we’ve 
 described—implicit calls and implicit data passing. A third feature allows the 
 data structures within a component to be described in terms of previously-
 defined components. This feature is direct access memory.
  
 Suppose we define a variable called APPLES, like this:
  
 VARIABLE APPLES
  
 We can store a number into this variable to indicate how many apples we 
 currently have:
  
 20 APPLES !
  
 We can display the contents of the variable:
  
 APPLES ? 20 ok
  
 We can up the count by one:
  
 1 APPLES +!
  
 (The newcomer can study the mechanics of these phrases in Appendix A.) 
  
 The 
 word APPLES has but one function: to put on the stack the address of the 
 memory location where the tally of apples is kept. The tally can be thought of as 
 a “thing,” while the words that set the tally, read the tally, or increment the tally 
 can be considered as “actions.”
  
  
 Forth conveniently separates “things” from “actions” by allowing 
 addresses of data structures to be passed on the stack and providing the “fetch” 
 and “store”commands.
  
 We’ve discussed the importance of designing around things that may 
 change. Suppose we’ve written a lot of code using this variable APPLES. And 
 now, at the eleventh hour, we discover that we must keep track of two different 
 kinds of apples, red and green!
  
 We needn’t wring our hands, but rather remember the function of 
 APPLES: to provide an address. If we need two separate tallies, APPLES can 
 supply two different addresses depending on which kind of apple we’re 
 currently talking about. So we define a more complicated version of APPLES as 
 follows:
  
 VARIABLE COLOR 
   
 ( pointer to current tally) 
  
 VARIABLE REDS ( tally of red apples) 
  
 VARIABLE GREENS 
   
 ( tally of green apples) 
  
 : RED 
  
 ( set apple-type to RED) 
  
 REDS COLOR ! ; : GREEN ( set apple-type to GREEN) 
  
 GREENS 
 COLOR ! ; : APPLES 
  
 (-- adr of current apple tally) COLOR @ ;
  
 Hiding the Construction of Data Structures 
  
 25",NA
But Is It a High-Level Language?,"In our brief technical overview, we noted that traditional high-level languages 
 broke away from assembly-language by eliminating not only the one-for-one 
 correspondence between commands and machine operations, but also the 
 linear correspondence. Clearly Forth lays claim to the first difference; but 
 regarding the second, the order of words that you use in a definition is the 
 order in which those commands are compiled.
  
  
 Does this disqualify Forth from the ranks of high-level languages? Before 
 we answer, let’s explore the advantages of the Forth approach.
  
 Here’s what Charles Moore, the inventor of Forth, has to say:
  
 You define each word so that the computer knows what it means. The way it 
 knows is that it executes some code as a consequence of being invoked. The 
 computer takes an action on every word. It doesn’t store the word away and keep 
 it in mind for later.
  
 In a philosophical sense I think this means that the computer “understands”DUP, 
 perhaps more profoundly than you do, 
  
 because there’s never any question in its mind what DUP
  
 The connection between words that have meaning to you and words that have 
 meaning to the computer is a profound one. The computer becomes the vehicle 
 for communication between human being and concept.
  
 But Is It a High-Level Language? 
  
 27",NA
The Language of Design,"Forth is a design language. To the student of traditional computer science, this 
 statement is self-contradictory. “One doesn’t design with a language, one 
 implements with a language. Design precedes implementation.”
  
 Experienced Forth programmers disagree. In Forth you can write ab-
 stract, design-level code and still be able to test it at any time by taking 
 advantage of decomposition into lexicons. A component can easily be rewrit-
 ten, as development proceeds, underneath any components that use it. At first 
 the words in a component may print numbers on your terminal instead of con-
 trolling stepper motors. They may print their own names just to let you know 
 they’ve executed. They may do nothing at all.
  
  
 Using this philosophy you can write a simple by testable version of your 
 application, then successively change and refine it until you reach your goal.
  
 Another factor that makes designing in code possible is that Forth, like 
 some of the newer languages, eliminates the “batch-compile” development se-
 quence (edit-compile-test-edit-compile-test). Because the feedback is instanta-
 neous, the medium becomes a partner in the creative process. The program-
 mer using a batch-compiler language can seldom achieve the productive state 
 of mind that artists achieve when the creative current flows unhindered.
  
 For these reasons, Forth programmers spend less time planning than 
 their classical counterparts, who feel righteous about planning. To them, not 
 plan-ning seems reckless and irresponsible. Traditional environments force 
 program-mers to plan because traditional programming languages do not 
 readily accom-modate change.
  
  
 Unfortunately, human foresight is limited even under the best conditions. 
 Too much planning becomes counterproductive.
  
 Of course Forth doesn’t eliminate planning. It allows prototyping. Con-
 structing a prototype is a more refined way to plan, just as breadboarding is in 
 electronic design.
  
  
 As we’ll see in the next chapter, experimentation proves more reliable in 
 arriving at the truth than the guesswork of planning.
  
 The Language of Design 
  
 31",NA
The Language of Performance,"Although performance is not the main topic of this book, the newcomer to Forth 
 should be reassured that its advantages aren’t purely philosophical. Overall, 
 Forth outdoes all other high-level languages in speed, capability and compact-
 ness.
  
 Speed
  
 Although Forth is an interpretive language, it executes compiled code. There-
 fore it runs about ten times faster than interpretive BASIC.
  
 Forth is optimized for the execution of words by means of a technique 
 known as “threaded code” [
 9
 ], [
 10
 ], [
 11
 ]. The penalty for modularizing into 
 very small pieces of code is relatively slight.
  
 It does not run as fast as assembler code because the inner interpreter 
 (which interprets the list of addresses that comprise each colon definition) may 
 consume up to 50% of the run time of primitive words, depending on the 
 processor.
  
  
 But in large applications, Forth comes very close to the speed of assem-
 bler. Here are three reasons:
  
 First and foremost, Forth is simple. Forth’s use of a data stackgreatly 
 reduces the performance cost of passing arguments from word to word. In most 
 languages, passing arguments between modules is one of the main reasons that 
 the use of subroutines inhibits performance.
  
 Second, Forth allows you to define words either in high-level or in 
 machine language. Either way, no special calling sequence is needed. You can 
 write a new definition in high level and, having verified that it is correct, 
 rewrite it in assembler without changing any of the code that uses it. In a 
 typical application, perhaps 20% of the code will be running 80% of the time. 
 Only the most often used, time-critical routines need to be machine coded. The 
 Forth system itself is largely implemented in machine-code definitions, so you’ll 
 have few application words that need to be coded in assembler.
  
  
 Third, Forth applications tend to be better designed than those written 
 entirely in assembler. 
  
 Forth programmers take advantage of the language’s 
 prototyping capabilities and try out several algorithms before settling on the 
 one best suited for their needs. Because Forth encourages change, it can also be 
 called the language of optimization.
  
  
 Forth doesn’t guarantee fast applications. It does give the programmer a 
 creative environment in which to design fast applications.
  
 Capability
  
 Forth can do anything any other language can do—usually easier.
  
 32 
  
 The Philosophy of Forth",NA
Summary,"Forth has often been characterized as offbeat, totally unlike any other popular 
 language in structure or in philosophy, On the contrary, Forth incorporates 
 many principles now boasted by the most contemporary languages. Structured 
 design, modularity, and information-hiding are among the buzzwords of the 
 day.
  
 34 
  
 The Philosophy of Forth",NA
References,"[1] O.J. Dahl, E.W. Dijkstra, and C.A.R. Hoare, Structured Program-
  
 ming, 
 London, Academic Press, 1972.
  
 [2] Niklaus Wirth, “Program Development by Stepwise Refinement,” Com-
  
 munications of ACM, 14, No. 4 (1971), 221-27.
  
 [3] W.P. Stevens, G.J. Myers, and L.L. Constantine, “Structured De-
  
 sign,” IBM 
 Systems Journal, Vol. 13, No. 2, 1974.
  
 [4] David L. Parnas, “On the Criteria To Be Used in Decomposing Systems 
  
 into 
 Modules,” Communications of the ACM, December 1972.
  
 [5] Barbara H. Liskov and Stephen N. Zilles, “Specification Tech-niques for 
 Data Abstractions,” IEEE Transactions on Software Engineer-ing, March 
 1975.
  
 [6] David L. Parnas, “Designing Software for Ease of Extension and Con-
  
 traction,” IEEE Transactions on Software Engineering, March 1979.
  
 [7] Dewey Val Shorre, “Adding Modules to Forth,” 1980 FORML Pro-
  
 ceedings, p. 71.
  
 [8] Mark Bernstein, “Programming in the Laboratory,” unpublished paper, 
  
 1983.
  
 [9] James R. Bell, “Threaded Code,” Communications of ACM, Vol. 16, 
  
 No. 
 6, 370-72.
  
 [10] Robert B.K. DeWar, “Indirect Threaded Code,” Communications of 
  
 ACM, Vol. 18, No. 6, 331.
  
 [11] Peter M. Kogge, “An Architectural Trail to Threaded-Code Systems,”
  
 Computer, March, 1982.
  
 [12] Randy Dumse, “The R65F11 Forth Chip,” Forth Dimensions, Vol. 5, No. 
  
 2, p. 
 25.
  
 References 
 35",NA
TWO,NA,NA
Analysis,NA,NA
The Nine Phases of the Programming Cycle,"As we’ve seen, Forth integrates aspects of design with aspects of 
 implementation and maintenance. As a result, the notion of a “typical 
 development cycle” makes as much sense as a “typical noise.”
  
  
 But any approach is better than no approach, and indeed, some ap-
 proaches have worked out better than others. Here is a development cycle that 
 represents an “average” of the most successful approaches used in software 
 projects:
  
 Analysis
  
 1. Discover the Requirements and Constraints 2. 
 Build a Conceptual Model of the Solution 3. 
 Estimate Cost/Schedule/Performance
  
 Engineering
  
 4. Preliminary Design 
  
 5. Detailed Design 
  
 6. Implementation
  
 Usage
  
 7. Optimization 
  
 8. Validation and Debugging 
  
 9. Maintenance
  
 In this book we’ll treat the first six stages of the cycle, focusing on analysis, 
 design, and implementation.
  
 In a Forth project the phases occur on several levels. Looking at a project 
 from the widest perspective, each of these steps could take a month or more. 
 One step follows the next, like seasons.
  
 38 
  
 Analysis",NA
The Iterative Approach,"The iterative approach was explained eloquently by Kim Harris [
 1
 ]. He begins by 
 describing the scientific method:
  
 . . . a never-ending cycle of discovery and refinement. It first studies a natural 
 system and gathers observations about its behavior. Then the observations are 
 modeled to produce a theory about the natural system. Next, analysis tools are 
 applied to the model, which produces predictions about the real system’s 
 behavior. Experiments are devised to compare actual behavior to the predicted 
 behavior. The natural system is again studied, and the model is revised.
  
 The goal of the method is to produce a model which accurately predicts all 
 observable behavior of the natural system.
  
 Harris then applies the scientific method to the software development cycle, 
 illustrated in Figure
  2.1
 :
  
 1. A problem is analyzed to determine what functions are required in the 
  
 solution.
  
 2. Decisions are made about how to achieve those functions with the avail-
  
 able resources.
  
 3. A program is written which attempts to implement the design.
  
 Figure 2.1:
  The iterative approach to the software development cycle, from“The 
 Forth Philosophy,” by Kim Harris, Dr. Dobb’s Journal.
  
  
 The Iterative Approach 
  
 39",NA
The Value of Planning,"In the nine phases at the start of this chapter we listed five steps before “im-
 plementation.” Yet in Chapter
  One
  we saw that an overindulgence in planning is 
 both difficult and pointless.
  
 Clearly you can’t undertake a significant software project—regardless of 
 the language—without some degree of planning. Exactly what degree is ap-
 propriate?
  
 More than one Forth programmer has expressed high regard for Dave John-
 son’s meticulous approach to planning. Johnson is supervisor at Moore Prod-
 ucts Co. in Springhouse, Pennsylvania. The firm specializes in industrial in-
 strumentation and process control applications. Dave has been using Forth 
 since 1978.
  
 He describes his approach:
  
 Compared with many others that use Forth, I suppose we take a more formal 
 approach. I learned this the hard way, though. My lack of discipline in the early 
 years has come back to haunt me.
  
 We use two tools to come up with new products: a functional specification and a 
 design specification. Our department of Sales & Applications comes up with the 
 functional specification, through customer contact.
  
 Once we’ve agreed on what we’re going to do, the functional specification is 
 turned over to our department. At that point we work through a design, and come 
 up with the design specification.
  
 40 
  
 Analysis",NA
The Limitations of Planning,"Experience has taught us to map out where we’re going before we begin coding. 
 But planning has certain limitations. The following interviews give different 
 perspectives to the value of planning.
  
 Despite Teleska’s preference for a well-planned project, he suggests that the 
 choice between a top-down and bottom-up approach may depend on the situ-
 ation:
  
 On two recent projects involving a lot of technical interface work, I did the whole 
 thing bottom-up. I milled around in a bunch of data-sheets and technical 
 descriptions of little crannies of the operating system I was dealing with. I felt lost 
 most of the time, wondering why I ever took the job on. Then finally I reached a 
 critical mass of some sort and began putting small programs together that made 
 small things happen. I continued, bottom-up, until I matched the target 
 application.
  
 42 
  
 Analysis",NA
The Analysis Phase,"In the remainder of this chapter we’ll discuss the analysis phase. Analysis is an 
 organized way of understanding and documenting what the program should 
 do.
  
  
 With a simple program that you write for yourself in less than an hour, the 
 analysis phase may take about 250 microseconds. At the other extreme, some 
 projects will take many man-years to build. On such a project, the analysis phase 
 is critical to the success of the entire project.
  
 We’ve indicated three parts to the analysis phase:
  
 1. Discovering the requirements and constraints
  
 2. Building a conceptual model of the solution
  
 3. Estimating cost, scheduling, and performance
  
 Let’s briefly describe each part:
  
 The Analysis Phase 
  
 45",NA
Defining the Interfaces,"Tip
  
 First, and most importantly, the conceptual model should describe the system’s 
  
 2.6 
 interfaces.
  
 Teleska:
  
 The “spec” basically deals with WHAT. In its most glorious form, it describes what 
 the system would look like to the user—you might call it the user’s manual. I find I 
 write more notes on the human interaction—what it will look like on the 
 outside—than on the part that gets the job done. For instance, I’ll include a whole 
 error-action listing to show what happens when a particular error occurs.
  
 Oddly, this is the part that takes the most time to implement anyway.
  
 I’m currently working on a solid-state industrial washing-machine timer. In this 
 case, the user interface is not that complex. What is complex is the interface to the 
 washing machine, for which I must depend on the customer and the 
 documentation they can provide.
  
 The significant interface is whatever is the arms and legs of the product. I don’t 
 make the distinction between hardware and software at this early stage. They can 
 be interchanged in the implementation.
  
 The process of designing hardware and the process of designing software are 
 analogous. The way I design hardware is to treat it as a black box. The front panel 
 is input and output. You can do the same with software.
  
 I use any techniques, diagrams, etc., to show the customer what the inputs and 
 outputs look like, using his description of what the product has to do. But in 
 parallel, in my own mind, I’m imagining how it will be implemented. I’m 
 evaluating whether I can do this efficiently. So to me it’s not a black box, it’s a gray 
 box. The designer must be able to see inside the black boxes.
  
 When I design a system that’s got different modules, I try to make the coupling as 
 rational and as little as possible. But there’s always give and take, since you’re 
 compromising the ideal.
  
 For the document itself, I use DFDs [data-flow diagrams, which we’ll discuss 
 later], and any other kind of representation that I can show to my client. I show 
 them as many diagrams as I can to clarify my understanding. I don’t generally use 
 these once it comes to implementation. The prose must be complete, even without 
 reference to the diagrams.
  
 Defining the Interfaces 
  
 49",NA
Defining the Rules,"Most of your efforts at defining a problem will center on describing the 
 interface. Some applications will also require that you define the set of 
 application rules.
  
  
 All programming involves rules. Usually these rules are so simple it 
 hardly matters how you express them: “If someone pushes the button, ring the 
 bell.”
  
 Some applications, however, involve rules so complicated that they can’t 
 be expressed in a few sentences of English. A few formal techniques can come in 
 handy to help you understand and document these more complicated rules.
  
 Here’s an example. Our requirements call for a system to compute the 
 charges on long-distance phone calls. Here’s the customer’s explanation of its 
 rate structure. (I made this up; I have no idea how the phone company actually 
 computes their rates except that they overcharge.)
  
 All charges are computed by the minute, according to distance in hundreds of 
 miles, plus a flat charge. The flat charge for direct dial calls during weekdays 
 between 8 A.M. and 5 P.M. is .30 for the first minute, and .20 for each additional 
 minute; in addition, each minute is charged .12 per 100 miles. The flat charge for 
 direct calls during weekdays between 5 P.M. and 11 P.M. is .22 for the first
  
 52 
  
 Analysis",NA
Defining the Data Structures,"After defining the interfaces, and sometimes defining the rules, occasionally 
 you’ll need to define certain data structures as well. We’re not referring here to 
 the implementation of the data structures, but rather to a description of their 
 conceptual model.
  
 If you’re automating a library index, for instance, a crucial portion of your 
 analysis will concern developing the logical data structure. You’ll have to
  
 Defining the Data Structures 
  
 59",NA
Achieving Simplicity,"Tip
  
 2.11 Keep it simple.
  
 While you are taking these crucial first steps toward understanding the 
 problem, keep in mind the old saying:
  
 Given two solutions to a problem, the correct one is the simpler.
  
 This is especially true in software design. The simpler solution is often more 
 difficult to discover, but once found, it is:
  
 • easier to understand
  
 • easier to implement
  
 • easier to verify and debug
  
 • easier to maintain
  
 • more compact
  
 • more efficient
  
 • more fun
  
 One of the most compelling advocates of simplicity is Moore:
  
 You need a feeling for the size of the problem. How much code should it take to 
 implement the thing? One block? Three? I think this is a very useful design tool. 
 You want to gut-feel whether it’s a trivial problem or a major problem, how much 
 time and effort you should spend on it.
  
 60 
  
 Analysis",NA
Budgeting and Scheduling,"Another important aspect of the analysis phase is figuring the price tag. Again, 
 this process is much more difficult than it would seem. If you don’t know the 
 problem till you solve it, how can you possibly know how long it will take to 
 solve it?
  
  
 Careful planning is essential, because things always take longer than you 
 expect. I have a theory about this, based on the laws of probability:
  
 Tip
  
 2.17 The mean time for making a “two-hour” addition to an application is approxi-mately 12 
 hours.
  
 Imagine the following scenario: You’re in the middle of writing a large appli-
 cation when suddenly it strikes you to add some relatively simple feature. You 
 think it’ll take about two hours, so without further planning, you just do it. 
 Consider: That’s two hours coding time. The design time you don’t count 
 because you perceived the need—and the design—in a flash of brilliance while 
 working on the application. So you estimate two hours.
  
 But consider the following possibilities:
  
 1. Your implementation has a bug. After two hours it doesn’t work. So you 
  
 spend another two hours recoding. (Total 4.)
  
 2. OR, before you implemented it, you realized your initial design wouldn’t 
 work. You spend two hours redesigning. These two hours count. Plus 
 another two hours coding it. (Total 4.)
  
 3. OR, you implement the first design before you realize the design wouldn’t 
 work. So you redesign (two more hours) and reimplement (two more).
  
 (Total 6.)
  
 4. OR, you implement the first design, code it, find a bug, rewrite the code, 
 find a design flaw, redesign, recode, find a bug in the new code, recode 
 again. (Total 10.)
  
 You see how the thing snowballs?
  
 5. Now you have to document your new feature. 
  
 Add two hours to the 
  
 above. (Total 12.)
  
 6. After you’ve spent anywhere from 2 to 12 hours installing and debugging 
 your new feature, you suddenly find that element Y of your application
  
 bombs out.
  
 Worst yet, you have no idea why.
  
 You spend two hours
  
 reading memory dumps trying to divine the reason. Once you do, you 
 spend as many as 12 additional hours redesigning element Y. (Total 26.) 
 Then you have to document the syntax change you made to element Y.
  
 (Total 27.)
  
 66 
  
 Analysis",NA
Reviewing the Conceptual Model,"The final box on our iterative analytic wheel is labeled “Show Model to Cus-
 tomer.” With the tools we’ve outlined in this chapter, this job should be easy to 
 do.
  
 In documenting the requirements specification, remember that specs are 
 like snowmen. They may be frozen now, but they shift, slip, and melt away 
 when the heat is on. Whether you choose data-flow diagrams or straight Forth 
 pseudocode, prepare yourself for the great thaw by remembering to apply the 
 concepts of limited redundancy.
  
  
 Show the documented conceptual model to the customer. When the 
 customer is finally satisfied, you’re ready for the next big step: the design!
  
 68 
  
 Analysis",NA
References,"[1] Kim Harris, “The Forth Philosophy,” Dr. Dobb’s Journal, Vol. 6, Iss. 9, 
  
 No. 
 59 (Sept. 81), pp. 6-11.
  
 [2] Victor Weinberg, Structured Analysis, Englewood Cliffs, N.J.: Prentice-
  
 Hall, 
 Inc., 1980.
  
 [3] LaFarr Stuart, “LaFORTH”, 1980 FORML Proceedings, p. 78.
  
 [4] Frederick P. Brooks, Jr., The Mythical Man-Month, Reading, Mas-sachusetts, 
 Addison-Wesley, 1975.
  
 References 
 69",NA
THREE,NA,NA
Preliminary,NA,NA
Design/,NA,NA
Decomposition,NA,NA
Decomposition by Component,"Has this sort of thing ever happened to you? You’ve been planning for three 
 months to take a weekend vacation to the mountains. You’ve been making lists 
 of what to bring, and daydreaming about the slopes.
  
 Meanwhile you’re deciding what to wear to your cousin’s wedding next 
 Saturday. They’re informal types, and you don’t want to overdress. Still, a 
 wedding’s a wedding. Maybe you should rent a tuxedo anyway.
  
  
 For all this planning, it’s not until Thursday that you realize the two 
 events coincide. You have expletives for such moments.
  
  
 How is such a mental lapse possible, in one so intelligent as yourself? 
 Apparently the human mind actually makes links between memories. 
  
 New 
 ideas are somehow added onto existing paths of related thoughts.
  
 Figure 3.1:
  Pools of thought not yet linked
  
  
 72 
  
 Preliminary Design/Decomposition",NA
Example: A Tiny Editor,"Let’s apply decomposition by component to a real problem. It would be nice to 
 design a large application right here in Chapter
  Three
 , but alas, we don’t
  
 74 
  
 Preliminary Design/Decomposition",NA
Maintaining a Component-based Application,"How well will our design fare in the face of change? Envision the following 
 scenario: 
  
  
 We originally assumed that we could refresh the video display simply by 
 retyping the field every time a key is pressed. We even implemented the code 
 on our personal computer, with its memory-mapped video that refreshes an 
 entire line in the blink of a scan cycle. But now our customer wants the 
 application to run on a telephone-based network, with all I/O being done at a 
 not-so-fast baud rate. Since some of our input fields are almost as wide as the
  
 78 
  
 Preliminary Design/Decomposition",NA
Designing and Maintaining a Traditional Application,"Let’s pretend we haven’t studied the Tiny Editor problem yet, and we’re back 
 with a minimal set of specs. We’ll also start with our initial assumption, that we 
 can refresh the display by retyping the entire field after each keystroke.
  
 According to the dictum of top-down design, let’s take the widest-angle 
 view possible and examine the problem. Figure
  3.3
  depicts the program in its 
 simplest terms. Here we’ve realized that the editor is actually a loop which 
 keeps getting keystrokes and performing some editing function, until the user 
 presses the return key.
  
 Inside the loop we have three modules: getting a character from the 
 keyboard, editing the data, and finally refreshing the display to match the data.
  
  
 Clearly most of the work will go on inside “Process a Keystroke.”
  
 Applying the notion of successive refinement, Figure
  3.4
  shows the editor 
 problem redrawn with “Process a Keystroke” expanded. We find it takes several 
 attempts before we arrive at this configuration. Designing this level forces us
  
 80 
  
 Preliminary Design/Decomposition",NA
The Interface Component,"In computer science terminology, interfacing between modules has two 
 aspects. First, there’s the way other modules invoke the module; this is the 
 control interface. Second, there’s the way other modules pass and receive data 
 to and from the module; this is the data interface.
  
  
 Because of Forth’s dictionary structure, control is not an issue. 
  
 Defi-
 nitions are invoked by being named. In this section, when we use the 
 term“interface” we’re referring to data.
  
  
 When it comes to data interfaces between modules, traditional wisdom 
 says only that “interfaces should be carefully designed, with a minimum of 
 complexity.”The reason for the care, of course, is that each module must 
 implement its own end of the interface (Figure
  3.8
 ).
  
 This means the presence of redundant code. As we’ve seen, redundant 
 code brings at least two problems: bulky code and poor maintainability. A 
 change to the interface of one module will affect the interface of the opposite 
 module.
  
 Figure 3.8:
  Traditional view of the interface as a junction.
  
  
 There’s more to good interface design than that. Allow me to introduce a 
 design element which I call the “interface component.” The purpose an 
 interface component is to implement, and hide information about, the data 
 interface between two or more other components (Figure
  3.9
 ).
  
 The Interface Component 
  
 85",NA
Decomposition by Sequential Complexity,"We’ve been discussing one way to do decomposition: according to components. 
 The second way is according to sequential complexity.
  
 One of Forth’s rules is that a word must already have been defined to be 
 invoked or referred to. Usually the sequence in which words are defined 
 parallels the order of increasing capabilities which the words must possess. 
 This sequence leads to a natural organization of the source listing. The 
 powerful commands are simply added on top of the elementary application 
 (Figure
  3.10
 a).
  
 Like a textbook, the elementary stuff comes first. A newcomer to the 
 project would be able to read the elementary parts of the code before moving 
 on the advanced stuff.
  
 But in many large applications, the extra capabilities are best imple-
 mented as an enhancement to some private, root function in the elementary 
 part of the application (Figure
  3.10
 b). By being able to change the root’s ca-
 pability, the user can change the capability of all the commands that use the 
 root.
  
 Returning to the word processor for an example, a fairly primitive routine 
 is the one that starts a new page. It’s used by the word that starts a new line; 
 when we run out of lines we must start a new page. The word that starts a new 
 line, in turn, is used by the routine that formats words on the line; when the 
 next word won’t fit on the current line, we invoke NEWLINE. This 
 “uses”hierarchy demands that we define NEWPAGE early in the application.
  
 The problem? One of the advanced components includes a routine that 
 must be invoked by NEWPAGE. Specifically, if a figure or table appears in the
  
 88 
  
 Preliminary Design/Decomposition",NA
The Limits of Level Thinking,"Most of us are guilty of over-emphasizing the difference between “high-
 level”and “low-level.” This notion is an arbitrary one. It limits our ability to 
 think clearly about software problems.
  
  
 “Level” thinking, in the traditional sense, distorts our efforts in three 
 ways:
  
 1. It implies that the order of development should follow a hierarchical struc-
  
 ture
  
 2. It implies that levels should be segregated from each other, prohibiting 
  
 the benefits of reusability
  
 3. It fosters syntactical differences between levels (e.g., assembler vs. “high-
 level” languages) and a belief that the nature of programming somehow 
 changes as we move further from machine code.
  
 Let’s examine each of these misconceptions one by one.
  
 Where to Begin?
  
 I asked Moore how he would go about developing a particular application, a 
 game for children. As the child presses the digits on the numeric keypad, from 
 zero to nine, that same number of large boxes would appear on the screen.
  
 Moore:
  
 I don’t start at the top and work down. Given that exact problem, I would write a 
 word that draws a box. I’d start at the bottom, and I’d end up with a word called 
 GO, which monitored the keyboard.
  
 How much of that is intuitive?
  
 90 
  
 Preliminary Design/Decomposition",NA
Summary,"In this chapter we’ve seen two ways that applications can be decomposed: into 
 components, and according to sequential complexity.
  
  
 Special attention should be paid to those components that serve as inter-
 faces between other components.
  
 Now, if you’ve done preliminary design correctly, your problem is lying at 
 your feet in a heap of manageable pieces. Each piece represents a problem to 
 solve. Grab your favorite piece and turn to the next chapter.",NA
For Further Thinking,"(Answers appear in Appendix
  D
 .)
  
 1. Below are two approaches to defining an editor’s keyboard interpreter. 
  
 Which would you prefer? Why?
  
 (a) ( Define editor keys ) 
  
 HEX 
  
 72 CONSTANT UPCURSOR 
  
 80 CONSTANT 
 DOWNCURSOR 
  
 77 CONSTANT 
 RIGHTCURSOR 
  
 75 CONSTANT LEFTCURSOR 
  
 82 CONSTANT INSERTKEY 
  
 83 CONSTANT DELETEKEY 
  
 DECIMAL 
  
 ( Keystroke interpreter) 
  
 : EDITOR
  
 BEGIN
  
 MORE WHILE
  
 KEY
  
 CASE
  
 ENDOF
  
 Summary
  
 95
  
 UPCURSOR
  
 OF
  
 CURSOR-UP
  
 DOWNCURSOR
  
 OF
  
 CURSOR-DOWN
  
 ENDOF
  
 RIGHTCURSOR
  
 OF
  
 CURSOR>
  
 ENDOF
  
 LEFTCURSOR
  
 OF
  
 CURSOR<
  
 ENDOF
  
 INSERTKEY
  
 OF
  
 INSERTING
  
 ENDOF
  
 DELETEKEY
  
 OF
  
 DELETE
  
 ENDOF
  
 ENDCASE
  
 REPEAT ;",NA
FOUR,NA,NA
Detailed Design/,NA,NA
Problem Solving,NA,NA
Problem-Solving Techniques,"Even neophytes can solve programming problems without devoting any con-
 scious thought to problem solving techniques. So what’s the point in studying 
 techniques of problem solving? To quicken the process. By thinking about the 
 ways in which we solve problems, apart from the problems themselves, we 
 enrich our subconscious storehouse of techniques.
  
 G. Polya has written several books on problem solving, especially of the 
 mathematical problem. The most accessible of these is How to Solve It [
 1
 ]. 
 Although solving a mathematical problem isn’t quite the same as solving a 
 software problem, you’ll find some valuable suggestions there.
  
  
 The following series of tips summarize several techniques recommended 
 by the science of problem solving:
  
 100 
  
 Detailed Design/Problem Solving",NA
Interview with a Software Inventor,"Interview with a Software Inventor 
  
 107",NA
Detailed Design,"We’re now at the point in the development cycle at which we’ve decided we 
 need a component (or a particular word). The component will consist of a 
 number of words, some of which (those that comprise the lexicon) will be used 
 by other components and some of which (the internal words) will be only used 
 within this component.
  
 Create as many words as necessary to obey the following tip:
  
 Tip
  
 4.12 Each definition should perform a simple, well-defined task.
  
 Here are the steps generally involved in designing a component:
  
 1. Based on the required functions, decide on the names and syntax for the 
  
 external definitions (define the interfaces).
  
 2. Refine the conceptual model by describing the algorithm(s) and data 
  
 structure(s).
  
 3. Recognize auxiliary definitions.
  
 4. Determine what auxiliary definitions and techniques are already available.
  
 5. Describe the algorithm with pseudocode,
  
 6. Implement it by working backwards from existing definitions to the in-
  
 puts,
  
 7. Implement any missing auxiliary definitions.
  
 8. If the lexicon contains many names with strong elements in common, 
 design and code the commonalities as internal definitions, then 
 implement the external definitions.
  
 We’ll discuss the first two steps in depth. Then we’ll engage in an extended 
 example of designing a lexicon.",NA
Forth Syntax,"At this point in the development cycle you must decide how the words in your 
 new lexicon will be used in context. In doing so, keep in mind how the lexicon 
 will be used by subsequent components.
  
 Tip
  
 4.13 In designing a component, the goal is to create a lexicon that will make your later code 
 readable and easy to maintain.
  
 110 
  
 Detailed Design/Problem Solving",NA
Algorithms and Data Structures,"In Chapter
  Two
  we learned how to describe a problem’s requirements in terms 
 of interfaces and rules. In this section we’ll refine the conceptual model for each 
 component into clearly defined algorithms and data structures.
  
  
 An algorithm is a procedure, described as a finite number of rules, for 
 accomplishing a certain task. The rules must be unambiguous and guaranteed to 
 terminate after a finite number of applications. (The word is named for the ninth 
 century Persian mathematician al-Khowarizimi.) 
  
  
 An algorithm lies halfway between the imprecise directives of human 
 speech, such as “Please sort these letters chronologically,” and the precise direc-
 tives of computer language, such as “BEGIN 2DUP < IF . . . ” etc. The algorithm for 
 sorting letters chronologically might be this:
  
 1. Take an unsorted letter and note its date.
  
 Algorithms and Data Structures 
  
 119",NA
Calculations vs. Data Structures vs. Logic,"We’ve stated before that the best solution to a problem is the simplest adequate 
 one; for any problem we should strive for the simplest approach.
  
 Suppose we must write code to fulfill this specification:
  
 if the input argument is 1, the output is 10 
  
 if the input argument is 2, the output is 12 
  
 if the input argument is 3, the output is 14
  
 There are three approaches we could take:
  
 Calculation
  
 ( n) 1-
  
 2* 
  
 10 +
  
 120 
  
 Detailed Design/Problem Solving",NA
Solving a Problem: Computing Roman Numerals,"In this section we’ll attempt to demonstrate the process of designing a lexi-con. 
 Rather than merely present the problem and its solution, I’m hoping we can 
 crack this problem together. (I kept a record of my thought processes as I 
 solved this problem originally.) You’ll see elements of the problem-solving 
 guidelines previously given, but you’ll also see them being applied in a seem-
 ingly haphazard order—just as they would be in reality.
  
  
 Here goes: The problem is to write a definition that consumes a number 
 on the stack and displays it as a Roman numeral.
  
  
 This problem most likely represents a component of a larger system. We’ll 
 probably end up defining several words in the course of solving this problem, 
 including data structures. 
  
 But this particular lexicon will include only one 
 name, ROMAN, and it will take its argument from the stack. (Other words will 
 be internal to the component.) 
  
  
 Having thus decided on the external syntax, we can now proceed to devise 
 the algorithms and data structures.
  
 We’ll follow the scientific method—we’ll observe reality, model a 
 solution, test it against reality, modify the solution, and so on. We’ll begin by 
 recalling what we know about Roman numerals.
  
 Actually, we don’t remember any formal rules about Roman numerals. 
 But if you give us a number, we can make a Roman numeral out of it. We know 
 how to do it—but we can’t yet state the procedure as an algorithm.
  
 So, let’s look at the first ten Roman numerals:
  
 122 
  
 Detailed Design/Problem Solving",NA
Summary,"In this chapter we’ve learned to develop a single component, starting first with 
 deciding on its syntax, then proceeding with determining its algorithm(s) and 
 data structure(s), and concluding with an implementation in Forth.
  
  
 With this chapter we complete our discussion of design. The remainder of 
 the book will discuss style and programming techniques.",NA
References,"[1] G. Polya, How To Solve It: A New Aspect of Mathematical Method, 
  
 (Princeton, New Jersey, Princeton University Press).
  
 [2] Leslie A. Hart, How the Brain Works, c⃝ 1975 by Leslie A. Hart, 
  
 (New York, 
 Basic Books, Inc., 1975).
  
 [3] Evan Rosen, “High Speed, Low Memory Consumption Structures,” 1982 
  
 FORML Conference Proceedings, p. 191.
  
 [4] Michael Stolowitz, “A Compiler for Programmable Logic in FORTH,”
  
 1982 FORML Conference Proceedings, p. 257.",NA
For Further Thinking,"Design the components and describe the algorithm(s) necessary to simulate 
 shuffling a deck of cards. Your algorithm will produce an array of numbers, 0–
 51, arranged in random order.
  
  
 The special constraint of this problem, of course, is that no one card may 
 appear twice in the array.
  
 You may assume you have a random-number generator called CHOOSE. 
 It’s stack argument is “n”; it produces a random number between zero and n−1 
 inclusive. (See the Handy Hint, Chapter Ten, Starting Forth.)
  
 Summary 
  
 133",NA
FIVE,NA,NA
Implementation:,NA,NA
Elements of,NA,NA
Forth Style,NA,NA
Listing Organization,"A well-organized book has clearly defined chapters, with clearly defined sec-
 tions, and a table of contents to help you see the organization at a glance. A 
 well-organized book is easy to read. A badly organized book makes comprehen-
 sion more difficult, and makes finding information later on nearly impossible.
  
  
 The necessity for good organization applies to an application listing as 
 well. Good organization has three aspects:
  
 1. Decomposition
  
 136 
  
 Implementation: Elements of Forth Style",NA
An Alternative to Screens: Source in Named Files,"Some Forth practitioners advocate storing source code in variable-length, 
 named text files, deliberately emulating the approach used by traditional 
 compilers and editors. This approach may become more and more common, but 
 its usefulness is still controversial.
  
 Sure, it’s nice not to have to worry about running out of room in a screen, 
 but the hassle of writing in a restricted area is compensated for by retaining 
 control of discrete chunks of code. In developing an application, you spend a lot 
 more time loading and reloading screens than you do rearranging their 
 contents.
  
 “Infinite-length” files allow sloppy, disorganized thinking and bad factor-
 ing. Definitions become longer without the discipline imposed by the 1K block 
 boundaries. The tendency becomes to write a 20K file, or worse: a 20K defini-
 tion.
  
 Perhaps a nice compromise would be a file-based system that allows 
 nested loading, and encourages the use of very small named files. Most likely, 
 though, the more experienced Forth programmers would not use named files 
 longer than 5K to 10K. So what’s the benefit?
  
 Some might answer that rhetorical question: “It’s easier to remember
  
 names than 
 numbers.”constants, 
 e.g.:
  
 If that’s so, then predefine those block numbers as
  
 90 CONSTANT FRAMING
  
 Then to load the “framing” section, enter
  
 FRAMING LOAD
  
 Or, to list the section’s load block, enter
  
 FRAMING LIST
  
 (It’s a convention that names of sections end in “ING.”) 
  
  
 Of course, to minimize the hassle of the screen-based approach you need 
 good tools, including editor commands that move lines of source from one 
 screen to another, and words that slide a series of screens forward or back 
 within the listing.
  
 Disk Partitioning
  
 The final aspect of the well-organized listing involves standardizing an arrange-
 ment for what goes where on the disk. These standards must be set by each 
 shop, or department, or individual programmer, depending on the nature of the 
 work.
  
 Figure
  5.4
  shows a typical department’s partitioning scheme.
  
 In many Forth shops it’s considered desirable to begin sections of code on 
 screen numbers that are evenly divisible by three. Major divisions on a disk 
 should be made on boundaries evenly divisible by thirty.
  
 144 
  
 Implementation: Elements of Forth Style",NA
Screen Layout,"In this section we’ll discuss the layout of each source screen.
  
 Tip
  
 5.4 Reserve Line 0 as a “comment line.”
  
 The comment line serves both as a heading for the screen, and also as a line in 
 the disk INDEX. It should describe the purpose of the screen (not list the words 
 defined therein).
  
 The comment line minimally contains the name of the screen. In larger 
 applications, you may also include both the chapter name and screen name. If 
 the screen is one of a series of screens implementing a lexicon, you should 
 include a “page number” as well.
  
 The stamp 
 The upper right hand corner is reserved for the “stamp.”
  
 includes the date of latest revision and, when authorship is important, the 
 programmer’s initials (three characters to the left of the date); e.g.:
  
 ( Chapter name
  
 Screen Name -- pg #
  
 JPJ 06/10/83)
  
 Some Forth editors will enter the stamp for you at the press of a key. 
  
 A common form for representing dates is
  
 mm-dd-yy
  
 that is, February 6, 1984 would be expressed
  
 02-06-84
  
 An increasingly popular alternative uses
  
 ddMmmyy
  
 where “Mmm” is a three-letter abbreviation of the month. For instance:
  
 22Oct84
  
 This form requires fewer characters than
  
 10-22-84
  
 and eliminates possible confusion between dates and months.
  
  
 If your system has \ (“skip-line”-see Appendix
  C
 ), you can write the 
 comment line like this:
  
 146
  
 \ Chapter name
  
 Screen Name -- pg.#
  
 JPJ 06/10/83
  
 Implementation: Elements of Forth Style",NA
Comment Conventions,"Appropriate commenting is essential. There are five types of comments: stack-
 effect comments, data-structure comments, input-stream comments, purpose 
 comments and narrative comments.
  
 A stack-effect comment shows the arguments that the definition consumes 
 from the stack, and the arguments it returns to the stack, if any.
  
 A data-structure comment indicates the position and meaning of elements 
 in a data structure. For instance, a text buffer might contain a count in the 
 first byte, and 63 free bytes for text.
  
 An input-stream comment indicates what strings the word expects to see 
 in the input stream. For example, the Forth word FORGET scans for the 
 name of a dictionary entry in the input stream.
  
 150 
  
 Implementation: Elements of Forth Style",NA
Vertical Format vs. Horizontal Format,"The purpose of commenting is to allow a reader of your code to easily 
 determine what’s going on. But how much commenting is necessary? To 
 determine the level of commenting appropriate for your circumstances, you 
 must ask yourself two questions:
  
 • Who will be reading my code?
  
 Comments for Compiling Words 
  
 159",NA
Choosing Names: The Art,"Besides a mathematical inclination, an exceptionally good mastery of one’s native 
 tongue is the most vital asset of a competent programmer (Prof. Edsger W. 
 Dijkstra [
 3
 ]).
  
 We’ve talked about the significance of using names to symbolize ideas and 
 objects in the application. The choosing of names turns out to be an important 
 part of the design process.
  
  
 Newcomers tend to overlook the important of names. “After all,” they 
 think, “the computer doesn’t care what names I choose.”
  
  
 But good names are essential for readability. Moreover, the mental ex-
 ercise of summoning a one-word description bears a synergistic effect on your 
 perceptions of what the entity should or should not do.
  
 Here are some rules for choosing good names:
  
 Tip
  
 Choose names according to “what,” not “how.”
  
 5.15
  
 A definition should hide the complexities of implementation from other defini-
 tions which invoke it. The name, too, should hide the details of the procedure, 
 and instead should describe the outward appearance or net effect.
  
  
  
 ALLOT simply increments the dictionary 
 DP or HHHHH in most systems). But the name ALLOT 
  
 DP+! because the user is thinking of reserving space, not incrementing a pointer.
  
  
 The ’83 Standard adopted the name CMOVE> 
  
  
  
 <CMOVE. The operation makes it possible to copy a region 
 of memory forward into overlapping memory. It accomplishes this by starting 
 with the last byte and working backward. In the new name, the forwardness of 
 the “what” supersedes the backwardness of the “how.”
  
 Tip
  
 Find the most expressive word.
  
 Choosing Names: The Art
  
 5.16
  
 163",NA
Naming Standards: The Science,"Tip
  
 Learn and adopt Forth’s naming conventions. 
  
 5.22
  
 In the quest for short, yet meaningful names, Forth programmers have adopted 
 certain naming conventions. 
  
 Appendix
  E
  includes a list of the most useful 
 conventions developed over the years.",NA
More Tips for Readability,"Here are some final suggestions to make your code more readable. (Definitions 
 appear in Appendix
  C
 .) 
  
  
 One constant that pays for itself in most applications is BL (the ASCII value 
 for “blank-space”).
  
 ASCII is used primarily within colon definitions to free you 
 from having to know the literal value of an ASCII character. For instance, 
 instead of writing:
  
 : (
  
 41 
 WORD
  
 DROP ;
  
 IMMEDIATE
  
 where 41 is the ASCII representation for right-parenthesis, you can write
  
 : (
  
 ASCII ) WORD
  
 DROP ;
  
 IMMEDIATE
  
 A pair of words that can make dealing with booleans more readable are TRUE 
  
 FALSE. With these additions you can write phrases such as
  
 TRUE ’STAMP? !
  
 to set a flag or
  
 FALSE ’STAMP? !
  
 to clear it.
  
  
 (I once used TTTTT and FFFFF, but the words are needed so rarely I now 
 heed the injunction against abbreviations.) 
  
  
 As part of your application (not necessarily part of your Forth system), you 
 can take this idea a step further and define:
  
 : ON
  
 ( a)
  
 TRUE SWAP ! ;
  
 : OFF
  
 ( a)
  
 FALSE SWAP ! ;
  
 These words allow you to write:
  
 ’STAMP? ON
  
 or
  
 ’STAMP? OFF
  
 Other names for these definitions include SET and RESET, although SET and 
 RESET most commonly use bit masks to manipulate individual bits.
  
 WITHIN, which determines whether a given value lies within two other values. 
 The syntax is:
  
 n
  
 lo hi WITHIN
  
 More Tips for Readability
  
 16
 9",NA
Summary,"Maintainability requires readability. In this chapter we’ve enumerated various 
 ways to make a source listing more readable. We’ve assumed a policy of making 
 our code as self-documenting as possible. Techniques include listing organiza-
 tion, spacing and indenting, commenting, name choices, and special words that 
 enhance clarity.
  
  
 We’ve mentioned only briefly auxiliary documentation, which includes all 
 documentation apart from the listing itself. 
  
 We won’t discuss auxiliary 
 documentation further in this volume, but it remains an integral part of the 
 software development process.",NA
References,"[1] Gregory Stevenson, “Documentation Priorities,” 1981 FORML Confer-
  
 ence 
 Proceedings, p. 401.
  
 [2] Joanne Lee, “Quality Assurance in a Forth Environment,” (Appendix A), 
  
 1981 FORML Proceedings, p. 363.
  
 [3] Edsger W. Dijkstra, Selected Writings on Computing: A Personal Per-
  
 spective, New York, Springer Verlag, Inc., 1982.
  
 [4] Henry Laxen, “Choosing Names,” Forth Dimensions, vol. 4, no. 4, Forth 
  
 Interest Group.
  
 170 
  
 Implementation: Elements of Forth Style",NA
SIX,NA,NA
Factoring,NA,NA
Factoring Techniques,"If a module seems almost, but not quite, useful form a second place in the system, 
 try to identify and isolate the useful subfunction. The remainder of the module 
 might be incorporated in its original caller (from “Structured Design”[
 1
 ]).
  
 The “useful subfunction” of course becomes the newly factored definition.What 
 about the part that “isn’t quite useful”? That depends on what it is.
  
 Factoring Out Data
  
 The simplest thing to factor out is data thanks to Forth’s data stack. 
  
 For 
 instance, to compute two-thirds of 1,000, we write
  
 1000 2 3 */
  
 172 
  
 Factoring",NA
Factoring Criteria,"Armed with an understanding of factoring techniques, let’s now discuss several 
 of the criteria for factoring Forth definitions. They include:
  
 1. Limiting the size of definitions
  
 2. Limiting repetition of code
  
 3. Nameability
  
 4. Information hiding
  
 5. Simplifying the command interface
  
 Tip
  
 6.5 Keep definitions short.
  
 We asked Moore, “How long should a Forth definition be?”
  
 A word should be a line long. That’s the target.
  
 When you have a whole lot of words that are all useful in their own right—
 perhaps in debugging or exploring, but inevitably there’s a reason for their 
 existence—you feel you’ve extracted the essence of the problem and that those 
 words have expressed it.
  
 Short words give you a good feeling.
  
 An informal examination of one of Moore’s applications shows that he aver-ages 
 seven references, including both words and numbers, per definition. These are 
 remarkably short definitions. (Actually his code was divided about 50–50 
 between one-line and two-line definitions.) 
  
  
 Psychological tests have shown that the human mind can only focus its 
 conscious attention on seven things, plus or minus two, at a time [
 2
 ]. Yet all the 
 while, day and night, the vast amounts of data, making connections and 
 associations and solving problems.
  
 Even if out subconscious mind knows each part of an application inside 
 out, our narrow-viewed conscious mind can only correlate seven elements of it 
 at once. Beyond that, our grasp wavers. Short definitions match our mental 
 capabilities.
  
 Something that many Forth programmers to write overly long definitions 
 is the knowledge that headers take space in the dictionary. The coarser the 
 factoring, the fewer the names, and the less memory that will be wasted.
  
 It’s true that more memory will be used, but it’s hard to say that anything 
 that helps you test, debug and interact with your code is a “waste.” If your 
 application is large, try using a default width of three, with the ability to switch
  
 178 
  
 Factoring",NA
Compile-Time Factoring,"In the last section we looked at many techniques for organizing code and data to 
 reduce redundancy.
  
  
 We can also apply limited redundancy during compilation, by letting 
 Forth do some of out dirty work.
  
 Tip
  
 6.17 For maximum maintainability, limit redundancy even at compile time.
  
 Suppose in our application we must draw nine boxes as shown in Figure
  6.1
 .
  
 In our design we need to have constants that represent values such as the 
 size of each box, the size of the gap between boxes, and the left-most and top-
 most coordinates of the first box.
  
 Naturally we can define:
  
 188 
  
 Factoring",NA
The Iterative Approach in Implementation,"Earlier in the book we discussed the iterative approach, paying particular at-
 tention to its impact on the design phase. Now that we’re talking about im-
 plementation, let’s see how the approach is actually used in writing code.
  
 Tip
  
 6.19 Work on only one aspect of a problem at a time.
  
 Suppose we’re entrusted with the job of coding a word to draw or erase a box at 
 a given x–y coordinate. (This is the same problem we introduced in the section 
 called “Compile-Time Factoring.”) 
  
  
 At first we focus our attention on the problem of drawing a box—never 
 mind erasing it. We might come up with this:
  
 : LAYER 
    
 WIDE 
   
 0 DO 
   
 ASCII * EMIT 
 LOOP ; 
  
 : BOX 
  
 ( upper-left-x upper-left-y -- ) 
  
  
 HIGH 
   
 0 DO 2DUP 
  
 I + 
   
 XY LAYER LOOP 2DROP ;
  
 Having tested this to make sure it works correctly, we turn now to the problem 
 of using the same code to undraw a box. The solution is simple: instead of ASCII * 
 we’d like to change the emitted character from an 
  
 asterisk to a blank. This requires the addition of a variable, and some readable 
 words for setting the contents of the variable. So:
  
 VARIABLE INK
  
 192
  
 Factoring
  
 : DRAW
  
 ASCII *
  
 INK ! ;
  
 EMIT
  
 LOOP ;
  
 : UNDRAW
  
 BL
  
 INK ! ;
  
 : LAYER
  
 WIDT
 H
  
 0 DO
  
 INK @",NA
References,"[1] W.P. Stevens, G.J. Myers, and L.L. Constantine, 
  
 IBM Systems 
  
 Journal, vol. 13, no. 2, 1974, Copyright 1974 by International Business 
  
 Machines Corporation.
  
 [2] G.A. Miller, “The Magical Number Seven, Plus or Minus Two: Some Limits on 
 our Capacity for Processing Information,” Psychol. Rev., vol. 63, pp. 81-97, 
 Mar. 1956.
  
 [3] Kim R. Harris, “Definition Field Address Conversion Operators,” Forth–
  
 83 
 Standard, Forth Standards Team.
  
 Summary 
  
 195",NA
SEVEN,NA,NA
Handling Data:,NA,NA
Stacks and States,NA,NA
The Stylish Stack,"The simplest way for Forth words to pass arguments to each other is via the 
 stack. The process is “simple” because all the work of pushing and popping 
 values to and from the stack is implicit.
  
 Moore:
  
 The data stack uses this idea of “hidden information.” The arguments being 
 passed between subroutines are not explicit in the calling sequence. The same 
 argument might ripple through a whole lot of words quite invisibly, even below 
 the level of awareness of the programmer, simply because it doesn’t have to be 
 referred to explicitly.
  
 One important result of this approach: Arguments are unnamed. They reside on 
 the stack, not in named variables. This effect is one of the reasons for Forth’s 
 elegance. At the same time it’s one of the reasons badly written Forth code can 
 be unreadable. Let’s explore this paradox.
  
 The invention of the stack is analogous to that of pronouns in English.
  
 Consider the passage:
  
 Take this gift, wrap it in tissue paper and put it in a box.
  
 Notice the word “gift” is mentioned only once. The gift is referred to henceforth 
 as “it.”
  
  
 The informality of the “it” construct makes English more readable (pro-
 vided the reference is unambiguous). So with the stack, the implicit passing of 
 arguments makes code more readable. We emphasize the processes, not the 
 passing of arguments to the processes.
  
 198 
  
 Handling Data: Stacks and States",NA
The Stylish Return Stack,"What about this use of the return stack to hold temporary arguments? Is it good 
 style or what?
  
 Some people take great offense to its use. But the return stack offers the 
 simplest solution to certain gnarly stack jams. Witness the definition of 
 CMOVE> in the previous section.
  
 If you decide to use the return stack for this purpose, remember that you 
 are using a component of Forth for a purpose other than that intended. (See the 
 section called “Sharing Components,” later in this chapter.)
  
 Here’s some suggestions to keep you from shooting yourself in the foot:
  
 Tip
  
 7.7 
  
 1. Keep return stack operators symmetrical.
  
 2. Keep return stack operators symmetrical under all control flow condi-tions.
  
 3. In factoring definitions, watch out that one part doesn’t contain one return 
 stack operator, and the other its counterpart.
  
 LOOP, return stack operators must by symmetrical within the loop, and IIIII 
 is no longer valid in code bounded by >R
  
 R> in the same definition. Sometimes the 
 operators will appear to be symmetrical, but due to the control structure they 
 aren’t. For instance:
  
 ... BEGIN ... >R ... WHILE ... R> ... REPEAT
  
 If this construction is used in the outer loop of your application, everything will 
 run fine until you exit (perhaps hours later) when you’ll suddenly blow up. The 
 problem? The last time through the loop, the resolving R> 
  
 skipped.
  
 206 
  
 Handling Data: Stacks and States",NA
The Problem With Variables,"Although we handle data of immediate interest on the stack, we depend on 
 much information tucked away in variables, ready for recurring access. A piece 
 of code can change the contents of a variable without necessarily having to 
 know anything about how that data will be used, who will use it, or when and if 
 it will be used. Another piece of code can fetch the contents of a variable and 
 use it without knowing where that value came from.
  
 For every word that pushes a value onto the stack, another word must 
 consume that value. The stack gives us point-to-point communication, like the 
 post office.
  
 Variables, on the other hand, can be set by any command and accessed 
 any number of times—or not at all—by any command. Variables are available 
 for anyone who cares to look—like graffiti.
  
 Thus variables can be used to reflect the current state of affairs.
  
 Using currentness can simplify problems. In the Roman numeral example 
 of Chapter
  Four
 , we used the variable COLUMN# to represent the current 
 decimal-place; the words ONER, FIVER, and TENER depended on this 
 information to determine which type of symbol to display. We didn’t have to 
 specify both descriptions every time, as in TENS ONER, TENS FIVER, etc.
  
 On the other hand, currentness adds a new level of complexity. To make 
 something current we must first define a variable or some type of data 
 structure. We also must remember to initialize it, if there’s any chance that part 
 of our code will refer to it before another part has had a chance to set it.
  
  
 A more serious problem with variables is that they are not “reentrant.”On a 
 multi-tasked Forth system, each task which requires local variables must 
  
  
 USER variables serve this purpose. (See Starting Forth, Chapter Nine, 
 “Forth Geography.”) 
  
  
 Even within a single task, a definition that refers to a variable is harder to 
 test, verify, and reuse in a different situation than one in which arguments are 
 passed via the stack.
  
 Suppose we are implementing a word-processor editor. We need a routine that 
 calculates the number of characters between the current cursor position and 
 the previous carriage-return/line-feed sequence. So we write a word that LOOP 
 starting at the current position (CURSOR @) and ending at 
  
 the zeroth position, searching for the line feed character.
  
  
 Once the loop has found the character sequence, we subtract its relative 
 address from our current cursor position
  
 its-position CURSOR @ 
  
 SWAP -
  
 to determine the distance between them. 
  
  
 Our word’s stack effect is:
  
 ( -- distance-to-previous-cr/lf)
  
 The Problem With Variables 
  
 207",NA
Local and Global Variables/Initialization,"As we saw earlier, a variable that is used exclusively within a single definition 
 (or single lexicon), hidden from other code, is called a local variable. A variable 
 used by more than one lexicon is called a global variable. As we’ve seen in an 
 earlier chapter, a set of global variables that collectively describe a common 
 interface between several lexicons is called an “interface lexicon.”
  
  
 Forth makes no distinction between local and global variables. But Forth 
 programmers do.
  
 Moore:
  
 We should be writing for the reader. If something is referred to only locally, a 
 temporary variable just for accumulating a sum in, we should define it locally. It’s 
 handier to define it in the block where it’s used, where you can see its comment.
  
 If it’s used globally, we should collect things according to their logical function, 
 and define them together on a separate screen. One per line with a comment.
  
 The question is, where do you initialize them? Some say on the same line, 
 immediately following its definition. But that messes up the comments, and there 
 isn’t room for any decent comment. And it scatters the initialization all over the 
 application.
  
 I tend to do all my initialization in the load screen. After I’ve loaded all my blocks, 
 I initialize the things that have to be initialized. It might also set up color lookup 
 tables or execute some initialization code.
  
 If your program is destined to be target compiled, then it’s easy to write a word at 
 the point that encompasses all the initialization.
  
 It can get much more elaborate. 
  
 I’ve defined variables in ROM where the 
 variables were all off in an array in high memory, and the initial values are in 
 ROM, and I copy up the initial values at initialization time. But usually you’re only 
 initializing a few variables to anything other than zero.",NA
Saving and Restoring a State,"Variables have the characteristic that when you change their contents, you 
 clobber the value that was there before. Let’s look at some of the problems this 
 can create, and some of the things we can do about them.
  
 BASE is a variable that indicates the current number radix for all numeric 
 input and output. The following words are commonly found in Forth systems:
  
 : DECIMAL 
  
 10 BASE ! ; 
  
 : HEX 
  
 16 BASE ! ;
  
 Suppose we’ve written a word that displays a “dump” of memory. Ordinarily, 
 we work in decimal mode, but we want the dump in hexadecimal. So we write:
  
 210 
  
 Handling Data: Stacks and States",NA
Application Stacks,"In the last section we examined some ways to save and restore a single previous
  
 value. Some applications require several values to be saved and restored. You
  
 may often find the best solution to this problem in defining your own stack.
  
 Here is the code for a user stack including very simple error checking (an
  
 error clears the stack):
  
 CREATE STACK
  
 12 ALLOT
  
 \
  
 { 2tos-pointer | 10stack [5 cells] }
  
 HERE CONSTANT STACK>
  
 : INIT-STACK STACK STACK ! ; INIT-STACK
  
 : ?BAD ( ?) IF ."" STACK ERROR "" 
  
 INIT-STACK 
  
 ABORT 
  
 THEN ;
  
 : PUSH ( n) 2 STACK +! 
  
 STACK @ 
  
 DUP STACK> = ?BAD 
  
 ! ;
  
 : POP 
  
 ( -- n) 
  
 STACK @ @
  
 -2 STACK +! 
  
 STACK @ STACK < ?BAD ;
  
 The word PUSH takes a value from off of your data stack and “pushes” it onto
  
 this new stack. POP is the opposite, “popping” a value from off the new stack,
  
 and onto Forth’s data stack.
  
 In a real application you might want to change the names PUSH and POP
  
 to better match their conceptual purposes.",NA
Sharing Components,"Tip
  
 It’s legal to use a component for an additional purpose besides its intended one, 
  
 7.9
  
 provided:
  
 1. All uses of the component are mutually exclusive
  
 2. Each interrupting use of the component restores the component to its
  
 previous state when finished.
  
 Otherwise you need an additional component or level of complexity.
  
 We’ve seen a simple example of this principle with the return stack. The return
  
 stack is a component of the Forth system designed to hold return addresses, and
  
 thereby serve as an indication of where you’ve been and where you’re going. To
  
 use the return stack as a holder for temporary values is possible, and in many
  
 cases desirable. Problems occur when one of the above restrictions is ignored.
  
 In my text formatter the output can go invisible. This feature has two
  
 purposes:
  
 1. for looking ahead to see whether something will fit, and
  
 2. for formatting the table of contents (the entire document is formatted and
  
 page numbers are calculated without anything actually being displayed).
  
 Application Stacks 
  
 213",NA
The State Table,"A single variable can express a single condition, either a flag, a value, or the 
 address of a function.
  
 A collection of conditions together represent the state of the application 
 or of a particular component [
 2
 ]. Some applications require the ability to save a 
 current state, then later restore it, or perhaps to have a number of alternating 
 states.
  
 The State Table 
  
 215",NA
Vectored Execution,"Vectored execution extends the ideas of currentness and indirection beyond 
 data, to functions. Just as we can save values and flags in variables, we can also 
 save functions, because functions can be referred to by address.
  
 The traditional techniques for implementing vectored execution are de-
 scribed in Starting Forth, Chapter Nine. In this section we’ll discuss a new 
 syntax which I invented and which I think can be used in many circumstances 
 more elegantly than the traditional methods.
  
 The syntax is called DOER/MAKE. (If your system doesn’t include these words, 
 refer to Appendix
  B
  for code and implementation details.) It works like this: 
 You define the word whose behavior will be vectorable with the defining DOER, 
 as in
  
 DOER PLATFORM
  
 Initially, the new word PLATFORM does nothing. Then you can write words that 
 change what PLATFORM does by using the word MAKE
  
 : LEFTWING
  
 MAKE 
 PLATFORM
  
 ."" proponent "" ;
  
 : RIGHTWING
  
 MAKE 
 PLATFORM
  
 ."" opponent "" ;
  
 When you invoke LEFTWING, the phrase MAKE PLATFORM changes what 
 PLATFORM will do. Now if you type PLATFORM, you’ll see:
  
 LEFTWING ok 
  
 PLATFORM proponent ok
  
 RIGHTWING will make PLATFORM display 
 “opponent.”within another definition:
  
 You can use PLATFORM
  
 Vectored Execution 
  
 219",NA
Using DOER/MAKE,"There are many occasions when the DOER/MAKE construct proves beneficial. 
 They are:
  
 1. To change the state of a function (when external testing of the state is not 
 necessary). The words LEFTWING and RIGHTWING change the state of 
 the word PLATFORM.
  
 2. To factor out internal phrases from similar definitions, but within control 
  
 structures such as loops.
  
 Consider the definition of a word called DUMP, designed to reveal the 
 contents of a specified region of memory.
  
 : DUMP
  
 ( a # )
  
 DUP I +
  
 5 U.R
  
 2 SPACES
  
 THEN
  
 O DO
  
 I 16 MOD O= IF
  
 CR
  
 DUP I +
  
 @ 6 U.R
  
 2 +LOOP
  
 DROP ;
  
 The problem arises when you write a definition called CDUMP, designed 
 to format the output according to bytes, not cells:
  
 220 
  
 Handling Data: Stacks and States",NA
Summary,"In this chapter we’ve examined the tradeoffs between using the stack and using 
 variables and other data structures. Using the stack is preferable for testing and 
 reusability, but too many values manipulated on the stack by a single definition 
 hurts readability and writeability.
  
  
 We also explored techniques for saving and restoring data structures, and 
 concluded with a study of vectored execution using DOER/MAKE.",NA
References,"[1] Michael Ham, “Why Novices Use So Many Variables,” Forth Dimensions, 
  
 vol. 5, no. 4, November/December 1983.
  
 [2] Daniel Slater, “A State Space Approach to Robotics,” The Journal of 
  
 Forth 
 Application and Research, 1, 1 (September 1983), 17.
  
 226 
  
 Handling Data: Stacks and States",NA
EIGHT,NA,NA
Minimizing,NA,NA
Control Structures,NA,NA
What’s So Bad about Control Structures?,"Before we begin reeling off our list of tips, let’s pause to examine why condi-
 tionals should be avoided in the first place.
  
 The use of conditional structures adds complexity to your code. The more 
 complex your code is, the harder it will be for you to read and to maintain. The 
 more parts a machine has, the greater are its chances of breaking down. And 
 the harder it is for someone to fix.
  
 Moore tells this story:
  
 I recently went back to a company we had done some work for several years ago. 
 They called me in because their program is now five years old, and it’s gotten very 
 complicated. They’ve had programmers going in and patching things, adding state 
 variables and conditionals. Every statement that I recall being a simple thing five 
 years ago, now has gotten very complicated. “If this, else if this, else if this” . . . and 
 then the simple thing.
  
 228 
  
 Minimizing Control Structures",NA
How to Eliminate Control Structures,"In this section we’ll study numerous techniques for simplifying or avoiding
  
 conditionals. 
  
 Most of them will produce code that is more readable, more
  
 maintainable, and more efficient. Some of the techniques produce code that is
  
 more efficient, but not always as readable. Remember, therefore: Not all of the
  
 tips will be applicable in all situations.
  
 How to Eliminate Control Structures 
  
 231",NA
A Note on Tricks,"This sort of approach is often labeled a “trick.” In the computing industry at 
 large, tricks have a bad rep.
  
 A trick is simply taking advantage of certain properties of operation. 
 Tricks are used widely in engineering applications. Chimneys eliminate smoke 
 by taking advantage of the fact that heat rises. Automobile tires provide trac-
 tion by taking advantage of gravity.
  
  
 Arithmetic Logic Units (ALUs) take advantage of the fact that subtract-ing 
 a number is the same as adding its two’s complement.
  
  
 These tricks allow simpler, more efficient designs. What justifies their use 
 is that the assumptions are certain to remain true.
  
 The use of tricks becomes dangerous when a trick depends on something 
 likely to change, or when the thing it depends on is not protected by 
 information hiding.
  
 Also, tricks become difficult to read when the assumptions on which 
 they’re based aren’t understood or explained. In the case of replacing con-
 ditionals with AND, once this technique becomes part of every programmer’s 
 vocabulary, code can become more readable. In the case of a trick that is spe-
 cific to a specific application, such as the order in which data are arranged in a 
 table, the listing must clearly document the assumption used by the trick.
  
 Tip
  
 8.12 
  
 MAX for clipping.
  
 242 
  
 Minimizing Control Structures",NA
Decision Tables for Speed,"We’ve stated that if you can calculate a value instead of looking it up in a table, 
 you should do so. The exception is where the requirements for speed justify the 
 extra complexity of a table.
  
 Here is an example that computes powers of two to 8-bit precision:
  
 CREATE TWOS
  
 1 C,
  
 2 C,
  
 4 C,
  
 8 C,
  
 16 C,
  
 32 C,
  
 : 2**
  
 ( n -- 2 to the n)
  
 TWOS +
  
 C@ ;
  
 Instead of computing the answer by multiplying two times itself “n” times, the 
 answers are all pre-computed and placed in a table. We can use simple addition 
 to offset into the table and get the answer.
  
 In general, addition is much faster than multiplication.
  
 Moore provides another example:
  
 If you want to compute trig functions, say for a graphics display, you don’t need 
 much resolution. A seven-bit trig function is probably plenty. A table look-up of 
 128 numbers is faster than anything else you’re going to be able to do. For low-
 frequency function calculations, decision tables are great.
  
 But if you have to interpolate, you have to calculate a function anyway. You’re 
 probably better off calculating a slightly more complicated function and avoid-ing 
 the table lookup.
  
 248 
  
 Minimizing Control Structures",NA
Summary,"The use of logic and conditionals as a significant structural element in program-
 ming leads to overly-complicated, difficult-to-maintain, and inefficient code. In 
 this chapter we’ve discussed several ways to minimize, optimize or eliminate 
 unnecessary conditional structures.
  
  
 As a final note, Forth’s downplaying of conditionals is not shared by most 
 contemporary languages. 
  
 In fact, the Japanese are basing their fifth-
 generation computer project on a language called PROLOG—for PROgram-ming 
 in LOGic—in which one programs entirely in logic. It will be interesting to see 
 the battle-lines forming as we ponder the question:
  
 IF or not to IF
  
 In this book we’ve covered the first six steps of the software development cycle, 
 exploring both the philosophical questions of designing software and practical 
 considerations of implementing robust, efficient, readable software.
  
 We have not discussed optimization, validation, debugging, document-
 ing, project management, Forth development tools, assembler definitions, uses 
 and abuses of recursion, developing multiprogrammed applications, or target 
 compilation.
  
 But that’s another story.",NA
References,"[1] Charles Eaker, “Just in Case,” Forth Dimensions II/3, p. 37.",NA
For Further Thinking,"You have the word CHOOSE which takes an argument “n” and returns a random 
 number between 0 and n − 1. The result is always positive or zero. You can use 
 CHOOSE to produce a flag; the phrase
  
 Summary 
  
 259",NA
EPILOGUE,NA,NA
Forth’s Effect on,NA,NA
Thinking,NA,NA
APPENDIX A,NA,NA
Overview of Forth,NA,NA
(For Newcomers),NA,NA
The Dictionary,"Forth is expressed in words (and numbers) and is separated by spaces:
  
 HAND OPEN
  
 ARM LOWER
  
 HAND CLOSE
  
 ARM RAISE
  
 Such commands may be typed directly from the keyboard, or edited onto mass 
 storage then “LOAD 
  
  
 All words, whether included with the system or user-defined, exist in 
 the“dictionary,” a linked list. A “defining word,” is used to add new names to the 
 dictionary. One defining word is ::::: (pronounced “colon”), which is used to 
 define a new word in terms of previously defined words. Here is how one might 
 define a new word called LIFT:
  
 : LIFT
  
 HAND OPEN
  
 ARM LOWER
  
 HAND CLOSE
  
 ARM RAISE ;
  
 The ;;;;; terminates the definition. The new word LIFT may now be used instead 
 of the long sequence of words that comprise its definition.
  
 Forth words can be nested like this indefinitely. Writing a Forth applica-
 tion consists of building increasingly powerful definitions, such as this one, in 
 terms of previously defined ones.
  
 CODE, which is used in place of colon to define 
  
 a command in terms of machine instructions for the native processor. Words 
 CODE are indistinguishable to the user from words defined with 
  
 CODE definitions are needed only for the most time-critical portions of an 
 applications, if at all.",NA
Data Structures,"Still another defining word is CONSTANT
  
 17 CONSTANT SEVENTEEN
  
 The new word SEVENTEEN can now be used in place of the actual number 17. 
  
 The defining word VARIABLE creates a location for temporary data.
  
 VARIABLE is used like this:
  
 266 
  
 Overview of Forth (For Newcomers)",NA
The Stack,"In Forth, variables and arrays are used for saving values that may be required 
 by many other routines and/or at unpredictable times. They are not used for 
 the local passing of data between the definitions. For this, Forth employs a 
 much simpler mechanism: the data stack.
  
  
 When you type a number, it goes on the stack. When you invoke a word 
 which has numeric input, it will take it from the stack. Thus the phrase
  
 17 SPACES
  
 will display seventeen blanks on the current output device. “17” pushes the 
 binary value 17 onto the stack; the word SPACES 
  
  
 A constant also pushes its value onto the stack; thus the phrase:
  
 SEVENTEEN SPACES
  
 has the same effect.
  
 The stack operates on a “last-in, first-out” (LIFO) basis. This means that 
 data can be passed between words in an orderly, modular way, consistent with 
 the nesting of colon definitions.
  
 For instance, a definition called GRID might invoke the phrase 17 SPACES. 
 This temporary activity on the stack will be transparent to any other definition 
 that invokes GRID because the value placed on the stack is removed before the 
 definition of GRID ends. The calling definition might have placed some numbers 
 of its own on the stack prior to calling GRID. These will remain on the stack, 
 unharmed, until GRID has been executed and the calling definition continues.
  
 The Stack 
 267",NA
Control Structures,"Forth provides all the control structuresneeded for structured, GOTO-less pro-
 gramming.
  
 IF THEN construct is as follows:
  
 ... ( flag ) IF
  
 KNOCK
  
 THEN
  
 OPEN ...
  
 The “flag” is a value on the stack, consumed by IF. A non-zero value indicates 
 true, zero indicates false. A true flag causes the code after IF 
  
 word KNOCK) to be executed. The word THEN 
  
 phrase; execution resumes with the word OPEN. A false flag causes the code 
 THEN to not be executed. In either case, OPEN will be performed.
  
 ELSE allows an alternate phrase to be executed in the false case.
  
 In the phrase:
  
 ( flag ) IF KNOCK
  
 ELSE
  
 RING
  
 THEN
  
 OPEN ...
  
 the word KNOCK will be performed if the flag is true, otherwise the word RING 
 will be performed. Either way, execution will continue starting with OPEN.
  
 Forth also provides for indexed loops in the form
  
 ( limit) ( index) DO ... LOOP
  
 and indefinite loops in the forms:
  
 ... BEGIN
  
 ...
  
 ( flag) UNTIL
  
 and
  
 ... BEGIN
  
 ...
  
 ( flag) WHILE ... REPEAT ;",NA
For the Whole Story,"For a complete introduction to the Forth command set, read Starting Forth, 
 published by Prentice-Hall.
  
 268 
  
 Overview of Forth (For Newcomers)",NA
APPENDIX B,NA,NA
Defining,NA,NA
DOER/MAKE,NA,NA
APPENDIX C,NA,NA
Other Utilities,NA,NA
Described,NA,NA
in This Book,NA,NA
From Chapter,NA,NA
 Four,"Definitions are given in Forth-83
  
 ASCII that will work in ’83 Standard is:
  
 : ASCII
  
 ( -- c)
  
 \
  
 Compile:
  
 c
  
 ( -- )
  
 \ Interpret:
  
 c
  
 ( -- c)
  
 BL WORD 1+ C@
  
 STATE @
  
  
 IF [COMPILE] LITERAL",NA
From Chapter,NA,NA
 Five ,"The word \\\\\ can be defined 
 as:
  
 : \ 
  
 ( skip rest of line)
  
 THEN ; IMMEDIATE
  
 >IN @
  
 64 / 1+
  
 64 *
  
 >IN ! ; IMMEDIATE
  
  
  
  
 EXIT to terminate a screen, you can define \S : 
 \S 
  
 1024 >IN ! ; 
  
 FH can be defined simply as:
  
 : FH
  
 \
  
 ( offset -- offset-block)
  
 ""from here""
  
  
 BLK @ + ; 
  
 This factoring allows you to use FH in many ways, e.g.: 
  
 : TEST 
  
  
 [ 1 FH ] LITERAL LOAD ; 
  
 or 
  
  
 : SEE 
  
 [ 2 FH ] LITERAL LIST ;
  
 276 
  
 Other Utilities Described in This Book",NA
From Chapter,NA,NA
 Eight,"LEAP will depend on how your system implements DO 
  
 DO keeps two items on the return stack (the index and the limit), 
  
 LEAP must drop both of them plus one more return-stack item to exit:
  
 : LEAP
  
 R> R> 2DROP
  
 R> DROP ;
  
 DO keeps three items on the return stack, it must be defined:
  
 : LEAP
  
 R> R> 2DROP
  
 R> R> 2DROP ;
  
 From Chapter
  Eight
  
 27
 7",NA
APPENDIX D,NA,NA
Answers to,NA,NA
“Further Thinking”,NA,NA
Problems,NA,NA
Chapter,NA,NA
 Three,"1. The answer depends on whether you believe that other components will 
  
 need to “know the numeric code associated with each key. Usually this 
  
 would not be the case. 
  
 The simpler, more compact form is therefore 
  
 preferable. Also in the first version, to add a new key would require a 
  
 change in two places.
  
 2. The problem with the words RAM-ALLOT and THERE are that they are 
 time-dependent: we must execute them ina particular order. Our solution 
 then will be to devise an interface to the RAM allocation pointer that is 
 not dependent on order; the way to do this is to have a single word which 
 does both functions transparently.
  
 Our word’s syntax will be
  
 : RAM-
 ALLOT 
  
 ... ;
  
 ( #bytes-to-allot -- starting-adr)
  
 This syntax will remain the same whether we define it to allocate growing 
 upward: 
  
 : RAM-ALLOT 
  
 ( #bytes-to-allot -- starting-adr) 
  
 >RAM @ 
  
 DUP ROT + 
  
 >RAM ! ; 
  
 or to allocate growing downward: 
  
 : RAM-ALLOT 
  
 ( #bytes-to-allot -- starting-adr) 
  
 >RAM @ 
  
 SWAP -
  
 DUP >RAM ! ;",NA
Chapter,NA,NA
 Four,"Our solution is as follows:
  
 \ CARDS
  
 Shuffle
  
 6-20-83
  
 52 CONSTANT #CARDS
  
 280
  
 CREATE DECK
  
 #CARDS ALLOT
  
 \
  
 one card per byte
  
 Answers to “Further Thinking” Problems",NA
Chapter,NA,NA
 Eight,"This will work:
  
 20 CHOOSE
  
 2 CHOOSE
  
 IF NEGATE THEN
  
 But this is simpler:
  
 40 CHOOSE
  
 20 -
  
 Chapter
  Eight
  
 28
 1",NA
APPENDIX E,NA,NA
Summary of,NA,NA
Style Conventions,NA,NA
Spacing and Indentation Guidelines,"1 space between the colon and the name
  
 2 spaces between the name and the comment
 ∗
  
 2 spaces, or a carriage return, after the comment and before the definition
 ∗
  
 3 spaces between the name and definition if no comment is used
  
 3 spaces indentation on each subsequent line (or multiples of 3 for nested in-
  
 dentation)
  
 1 space between words/numbers within a phrase
  
 2 or 3 spaces between phrases
  
 1 space between the last word and the semicolon
  
 1 space between semicolon and IMMEDIATE
  
 No blank lines between definitions, except to separate distinct groups of defi-
  
 nitions",NA
Stack-Comment Abbreviations,"n single-length signed number
  
 d double-length signed number
  
 u single-length unsigned number
  
 ud double-length unsigned number
  
 t triple-length
  
 q quadruple-length
  
 ∗
  An often-seen alternative calls for 1 space between the name and comment and 3 between
  
 the comment and the definition. A more liberal technique uses 3 spaces before and after the
  
 comment. Whatever you choose, be consistent.
  
 284 
  
 Summary of Style Conventions",NA
Input-Stream Comment Designations,"c 
  
 single character, blank-delimited
  
 name 
  
 sequence of characters, blank delimited
  
 text 
  
 sequence of characters, delimited by non-blank
  
 Follow “text” with the actual delimiter required; e.g., text” or text).",NA
Samples of Good Commenting Style,"Here are two sample screens to illustrate good commenting style.
  
 Screen # 126
  
 06/06/83
  
 0
  \ Formatter
  
 Data Structures -- p.2
  
 1
  
 6 CONSTANT TMARGIN \ line# where body of text begins)
  
 2
  55 CONSTANT BMARGIN \ line# where body of text ends)
  
 3
  
 4
  CREATE HEADER 82 ALLOT
  
 5 
  
 { 1left-ent | 1right-cnt | 80header }
  
 6
  CREATE FOOTER 82 ALLOT
  
 7 
  
 { 1left-cnt | 1right-ent | 80footer }
  
 8
  
 9
  VARIABLE ACROSS 
  
 \ formatter’s current horizontal position
  
 10
  VARIABLE DOWNWARD \ formatter’s current vertical position
  
 11
  VARIABLE LEFT 
  
 \ current primary left margin
  
 12
  VARIABLE WALL 
  
 \ current primary right margin
  
 13
  VARIABLE WALL-WAS \ WALL when curr. line started being formt’d
  
 14
  
 Input-Stream Comment Designations 
  
 285",NA
Naming Conventions,"Meaning
  
 Form
  
 Example
  
 Arithmetic
  
 integer 1
  
 1name
  
 1+
  
 integer 2
  
 2name
  
 2*
  
 takes relative input parameters
  
 +name
  
 +DRAW
  
 takes scaled input parameters
  
 +name
  
 *DRAW
  
 Compilation
  
 start of “high-level” code
  
 name:
  
 CASE:
  
 end of “high-level” code
  
 ;name
  
 ;CODE
  
 put something into dictionary
  
 name,
  
 C,
  
 executes at compile time
  
 [name]
  
 [COMPILE]
  
 slightly different
  
 name’ (prime)
  
 CR’
  
 internal form or primitive
  
 (name)
  
 (TYPE)
  
 or <name>
  
 <TYPE>
  
 compiling word run-time part:
  
 systems with no folding
  
 lower-case
  
 if
  
 systems with folding
  
 (NAME)
  
 (IF)
  
 defining word
  
 :name
  
 :COLOR
  
 block-number where overlay begins
  
 nam
 ING
  
 DISKING
  
 Data Structures
  
 table or array
  
 names
  
 EMPLOYEES
  
 total number of elements
  
 #name
  
 #EMPLOYEES
  
 current item number (variable)
  
 name#
  
 EMPLOYEE#
  
 sets current item
  
 ( n) name
  
 13 EMPLOYEE
  
 advance to next element
  
 +name
  
 +EMPLOYEE
  
 size of offset to item from
  
 name+
  
 DATE +
  
 beginning of structure
  
 size of (bytes per)
  
 /name
  
 /EMPLOYEE
  
 (short for BYTES/name)
  
 286
  
 index pointer
  
 >name
  
 >IN
  
 Summary of Style Conventions",NA
Index,NA,NA
A ,"BASIC,
  3
 ,
  5
 ,
  7
  
 Abbreviations,
  165
 –
 166 
  
 Abstraction,
  3
 –
 5 
  
 Address-precedes-counts syntax 
 rule,
  
 Batch-compile development sequence 
 elimination of,
  31 
  
 Bernstein, Mark,
  29
 ,
  262
 –
 263
  
 115 
  
 Blank space (BL),
  169
 ,
  277
  
 Algorithms,
  12
 ,
  20
 ,
  21
 ,
  119
 –
 120
 , 
  
 122
 ,
  125
 –
 127
 ,
  133
 ,
  249
 –
 250
  
 Booleans, as hybrid values,
  240 
 Boutelle, Jerry,
  263
  
 Analogous problems,
  101 
  
 Branching,
  5
  
 Analysis,
  
 38
 ,
  
 45
 –
 49 
  
 budgeting,
  
 66
 –
 68 
  
 conceptual model,
  46
 –
 53
 ,
  59
 –
  
 Brooks,Fredrick P., Jr.,
  68 
  
 Budgeting,
  66
 –
 68 
  
 Bundling of names and numbers,
  
 60
 ,
  68 
  
 167
  
 constraints,
  46 
  
 Burgess, Donald A.,
  107
 –
 110
  
 data structure definition,
  59
 –
  
   
 60 
  
 decision table,
  55
 –
 59 
  
 decision tree,
  54
 –
 55 
  
 defined,
  45 
  
 interface definition,
  49
 –
 52 
 requirements,
  46 
  
 rule definition,
  52
 –
 59 
  
 scheduling,
  66
 –
 68 
  
 simplicity,
  60
 –
 65 
  
 Structured English,
  53
 –
 54 
 AND,
  241
 –
 242 
  
 Arrays,
  193
 –
 194 
  
 ASCII,
  234
 ,
  276 
  
 Assemblers,
  3
 ,
  34
 ,
  118 
  
 Assembly language,
  3
 ,
  5 
  
 Auxiliary problems,
  104
 ,
  106",NA
C ,"Calculations,
  120
 –
 122
 ,
  240
 –
 242 
  
 Calls, implicit,
  19 
  
  
 Capability,
  32 
  
  
 Case statements,
  175
 ,
  237
 –
 238 
  
 Chapter-load screens,
  140
 –
 143 
  
 Chapters,
  138 
  
  
 Clichés,
  188 
  
  
 CODE,
  266 
  
  
 Code: 
  
  
 factoring out from within con-
  
   
 trol structures,
  174
 –
 175 
  
 repetition of,
  180
 –
 181 
  
  
 Coincidental binding,
  14 
  
  
 Commands, reducing number of, 
  
   
 184
 –
 187",NA
B,"Comment conventions,
  150
 –
 159 
 Comment line,
  146
 –
 147
  
  
 BASE,
  148
 –
 149
 ,
  210
 –
 211
  
 Commenting style,
  285
 –
 286",NA
D ,"Data abstraction,
  18 
  
  
 Data coupling,
  15 
  
  
 Data handling, see Data stacks, 
    
 Data structures 
  
  
 Data passing, implicit,
  19
 ,
  25 
  
  
 Data stacks,
  19
 ,
  32 
  
   
 concept of,
  198
 –
 199 
  
   
 vs. data structures,
  201
 –
 203 
   
 defined,
  267 
  
   
 depth of,
  199
 –
 201 
  
   
 drawings,
  204
 –
 206 
  
   
 local variables and„
  201
 –
 203 
   
 PICK and ROLL,
  203
 –
 204 
  
   
 return,
  206
 ,
  213 
  
   
 saving and restoring states,
  210
 –
    
 212 
  
  
 Data structures:, see also Vari-
    
 ables 
  
   
 vs. calculation vs. logic,
  120
 –
    
 122 
  
   
 vs. data stacks,
  201
 –
 203 
  
   
 defined,
  120 
  
   
 defining,
  59
 –
 60 
  
   
 hiding construction of,
  25
 –
 27 
   
 operators,
  266
 ,
  267 
  
  
 Data, factoring out,
  172
 –
 173 
  
  
 Data-flow diagrams,
  49
 –
 51
  
 tricks,
  242 
 Data-structure comment,
  150
 ,
  155
  
 Control structures: Dates, representation of,
  146
  
 choosing,
  237 
 DECIMAL,
  148
 –
 149
  
 defined,
  268 
 Decision table,
  55
 –
 59
 ,
  243
 –
 249
  
 factoring out,
  174
 –
 175 
  
 factoring out code from within,
  
 Decision tree,
  54
 –
 55 
  
 Decomposition,
  138
  
 290
  
 INDEX
  
 174
 –
 175
  
 by component,
  72
 –
 88",NA
E,"length,
  178
 –
 180",NA
F,"Factoring,
  172
 –
 195
  
 procedure,
  266
  
 Definitions-consume-arguments syn-
  
 compile-time,
  188
 –
 192
  
 tax rule,
  114
  
 criteria,
  178
 –
 188
  
 Design, see Detailed design, Pre-
  
 defined,
  172
  
 liminary design
  
 iterative approach,
  192
 –
 195
  
 Dessy, Raymond E.,
  263
  
 techniques,
  172
 –
 177
  
 Detailed design,
  100
 –
 133
  
 FALSE,
  169
 ,
  277
  
 algorithms,
  119
 –
 120
  
 FH,
  276
 –
 277
  
 calculations,
  120
 –
 122
  
 File-based system,
  144
  
 data structures,
  120
 –
 122
  
 Flags,
  155
 ,
  174
 ,
  268
  
 demonstration of,
  122
 –
 133
  
 Flow charts,
  5
  
 Forth syntax,
  110
 –
 119
  
 Forth,
  19
 –
 35
  
 logic,
  120
 –
 122
  
 advantages of,
  29
 ,
  32
  
 problem solving techniques,
  100
 –
  
 capability of,
  32
  
 107
  
 component programming,
  20
 –
  
 steps in,
  110
  
 23
  
 Development cycle, see Program-
  
 data handling, see Data stacks,
  
 ming Cycle
  
 Data structures
  
 Dicing,
  21
  
 as design language,
  31
  
 Dictionary:
  
 effect on thinking,
  262
 –
 263
  
 control structure minimization
  
 high-level language issue,
  27
 –
  
 with,
  232
 –
 234
  
 31
  
 defined,
  266
 –
 267
  
 implicit calls,
  19
  
 Disk partitioning,
  144
  
 implicit data passing,
  19
 –
 20
  
 DO LOOP,
  188
 ,
  190
 ,
  238
  
 information-hiding,
  16
 –
 18
 ,
  24
 ,
  
 DOER/MAKE,
  219
 –
 226
 ,
  270
 –
 274
  
 182
 –
 184
  
 Dumb words,
  233
 –
 234
  
 lexicon,
  22
 –
 23
  
 Electives,
  145
 –
 146
  
 overview of,
  266
 –
 268
  
 performance of,
  32
 –
 34
  
 programming cycle, see Program-
  
 ELSE,
  268
  
 ming cycle
  
 EMIT,
  174
 –
 175
  
 size of,
  34
  
 Encryption,
  164
  
 speed of,
  32
  
 Engineering, see Detailed design;
  
 style, see Implementation
  
 Preliminary design
  
 syntax,
  110
 –
 119
  
 Error handling,
  50
  
 FORTRAN,
  3
 ,
  5
  
  
 Error-code,
  205
 –
 206
  
 Functional strength,
  14
 –
 15",NA
G,NA,NA
J,"Johnson, Dave,
  40
 –
 41
 ,
  52
 ,
  160
  
 Global variables,
  210
  
 GO TO commands,
  5
 ,
  6",NA
H,"Jump instructions,
  5
 ,
  6
  
  
 Ham, Michael,
  208
 ,
  262 
 Hardware constraints,
  46 
 Harris, Kim,
  39
 ,
  136",NA
K ,"Kogge, Peter,
  44
 –
 45
 ,
  208",NA
I,"Hart, Leslie,
  107",NA
L,"Hierarchical input-process-output
  
 designing,
  15
 –
 16
  
 LaManna, Michael,
  65
  
 High-level languages:
  
 Laxen, Henry,
  164
  
 development of,
  3
 ,
  5
  
 LEAP,
  277
  
 Forth as,
  27
 –
 31
  
 “Level” thinking, limits of,
  90
 –
 95
  
 How to Solve It (Polya),
  100
  
 Lexicons,
  22
 –
 23
 ,
  110
 –
 119
 ,
  138
  
 Hybrid values,
  241
 –
 242
  
 Line-by-line commenting,
  161
  
 Hyphenated names,
  166
 –
 167
  
 Listing organization,
  136
 –
 143
  
 Implementation,
  136
 –
 170
  
 LIT,
  177
  
 Load screens,
  138
 –
 143
  
 application,
  138
 –
 140
  
 chapter,
  140
 –
 143
  
 choosing names,
  163
 –
 168
  
 Local variables,
  201
 –
 203
 ,
  210
  
 comment conventions,
  150
 –
 159
  
 Logic,
  120
 –
 122
  
 factoring, see Factoring
  
 Logical binding,
  14
  
 listing organization,
  136
 –
 146
  
 Loops,
  5
 ,
  238
 –
 240
 ,
  268
  
 screen layout,
  146
 –
 150
  
 vertical format vs. horizontal",NA
M,"format,
  159
 –
 163
  
 Macro assembler,
  3
  
 Implicit calls,
  19
  
 Implicit data passing,
  19
 –
 20
  
 MAKE,
  234
  
 Indentation,
  150
 ,
  284
  
 Manageability,
  5
  
 INDEX,
  145
  
 MAX,
  242
  
 Information-hiding,
  16
 –
 18
 ,
  24
 ,
  85
 ,
  
 MIN,
  242
  
 182
 –
 184
  
 Mnemonics,
  3
  
 Input-process-output designing, hi-
  
 Modularity, see Structured pro-
  
 erarchical,
  15
 –
 16
  
 gramming
  
 Input-stream comment,
  150
 ,
  156
 ,
  
 Moore Products Company,
  142
  
 285
  
 Moore, Charles,
  27
 ,
  52
 ,
  60
 –
 63
 ,
  
  
 292
  
 INDEX",NA
N ,"Nameability,
  181
 –
 182 
  
  
 Named files, storing source code 
    
 in,
  144 
  
  
 Names: 
  
   
 choosing,
  163
 –
 167 
  
   
 factoring out,
  176
 –
 177 
  
  
 Naming conventions,
  167
 –
 168
 ,
  286
 –
    
 288 
  
  
 Narrative comments,
  151
 ,
  160
 –
 161 
  
 Nesting conditionals,
  235
 –
 236 
  
  
 Next block,
  143 
  
  
 Numbers-precede-names syntax 
 rule, 
  
  
  
 111
  
   
 119 
  
 Programming cycle: 
  
 analysis, see Analysis 
  
 detailed design, see Detailed de-
   
 sign 
  
 implementation, see Implemen-
   
 tation 
  
 iterative approach,
  39
 –
 40 
  
 limitations of planning,
  42
 –
 45 
  
 phases,
  38
 –
 39 
  
 preliminary design/decomposition, 
   
 see Preliminary design 
  
 value of planning,
  40
 –
 42 
  
 Prototyping,
  31 
  
 Pseudocode,
  51
 –
 52",NA
O ,"Object,
  92 
  
  
 OFF,
  169 
  
  
 ON,
  169 
  
  
 One-dimensional data table,
  243
 –
   
 244
  
  
 Purpose comment,
  151
 ,
  156
 –
 157",NA
Q ,"Quantization,
  63",NA
R,Redesigning to minimize control,NA
P ,"Parnas, David,
  16
 ,
  18
 ,
  20 
  
 Pascal,
  8 
  
  
 Pattern repetition,
  181 
  
 Performance,
  32
 –
 34 
  
  
 Phrases,
  164
 –
 165 
  
  
 PICK,
  203
 –
 204 
  
  
 Planning: 
  
   
 limitations of,
  42
 –
 45 
   
 value of,
  40
 –
 42
  
  
 structures,
  249
 –
 252 
  
 Relative loading,
  140
 –
 143 
  
 Requirements,
  46 
  
 Return stack,
  206
 ,
  211 
  
 Rockwell R65F11 Forth-based mi-
  
 croprocessor,
  34 
  
 ROLL,
  203
 –
 204 
  
 Roman numeral computation prob-
  
 lem,
  122
 –
 133 
  
 Rule definition,
  52
 –
 59
 ,
  101
  
 Polya, G.,
  100 
  
 Postfix notation,
  111
 –
 113",NA
S,"Prefixes,
  168 
  
 Preliminary Design,
  72
 –
 95
  
 Sanderson, Dean,
  238
 ,
  239 
 Scanning-for,
  156",NA
T ,"Target compilers,
  34 
  
  
 Teleska, John,
  41
 –
 43
 ,
  49 
  
  
 Terminators vs. counts,
  239
 –
 240 
  
 Text-follows-names syntax rule,
  113 
  
 Thesaurus,
  164 
  
  
 THRU,
  143 
  
  
 Top-down design,
  9 
  
  
 Tricks,
  242 
  
  
 TRUE,
  169
 ,
  277 
  
  
 Two-dimensional data table,
  244
 –
  
  
 245 
  
  
 Two-dimensional decision table,
  
 245
 –
  
  
 248
  
 Structure 
  
  
 superficiality of,
  18",NA
V,"294
  
 INDEX",NA
W ,"Whole-brain thinking,
  107 
  
  
 Wirth, Niklaus,
  8 
  
  
 WITHIN,
  169
 ,
  277 
  
  
 Words: 
  
   
 choosing names,
  163
 –
 168 
  
   
 defining, see Defining words 
  
   
 ordering,
  113 
  
  
 Working backwards,
  103
 –
 104 
  
  
 Working forwards,
  102 
  
  
 Writeability,
  8
 –
 9",NA
Z ,"Zero-relative numbering,
  114
 –
 115
  
 INDEX 
 295",NA
