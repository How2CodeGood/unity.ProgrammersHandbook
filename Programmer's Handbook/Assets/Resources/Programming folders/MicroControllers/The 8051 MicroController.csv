Larger Text,Smaller Text,Symbol
I. Scott MacKenzie ,NA,NA
York University ,NA,NA
Raphael C.-W. Phan ,NA,NA
Swinburne University of Technology ,NA,NA
(Sarawak Campus),NA,NA
Pearson Education International,NA,NA
CONTENTS,NA,NA
1,"INTRODUCTION TO MICROCONTROLLERS 1
  
 1.1
  
 Introduction
  
 1
  
 6
  
 5
  
 1.2
  
 Terminology
  
 3
  
 1.3
  
 The Central Processing Unit
  
 4
  
 1.4
  
 Semiconductor Memory: RAM and ROM
  
 1.5
  
 The Buses: Address, Data, and Control
  
 1.6
  
 Input/Output Devices
  
 7
  
 1.6.1 Mass Storage Devices | 1.6.2 Human Interface Devices | 1.6.3
  
 Control/Monitor Devices
  
 1.7 
  
 Programs: Big and Small 
  
 8
  
 1.8 
  
 Micros, Minis, and Mainframes 
  
 9
  
 1.9 
  
 Microprocessors vs. Microcontrollers 
  
 10
  
 1.9.1 Hardware Architecture | 1.9.2 Applications | 1.9.3 Instruction Set Features
  
 1.10 
  
 New Concepts 
  
 12
  
 1.11 
  
 Gains and Losses: A Design Example 
  
 13
  
 Problems 14",NA
2,"HARDWARE SUMMARY 17
  
 2.1 
  
 2.2
  
 2.
 3 
  
 2.
 4 
  
 2.
 5
  
 MCS
 -
 51
  Family Overview
  
 17
  
 Once Around the Pins
  
 18
  
 2.2.1 Port 0 | 2.2.2 Port 1 | 2.2.3 Port 2 | 2.2.4 Port 3 | 
  
 2.2.5 PSEN (Program Store Enable) | 2.2.6 ALE (Address Latch Enable) | 2.2.7 
 EA (External Access) | 2.2.8 RST (Reset) | 2.2.9 On-Chip Oscillator Inputs | 
 2.2.10 Power Connections
  
 I/O Port Structure
  
 22
  
 Timing and the Machine Cycle
  
 23
  
 Memory 
 Organization
  
 24
  
 vii",NA
3,"INSTRUCTION SET SUMMARY 49
  
 3.1
  
 Introduction
  
 49
  
 50
  
 3.2
  
 Addressing Modes
  
 3.2.1 Register Addressing | 3.2.2 Direct Addressing | 3.2.3 Indirect 
  
 Addressing | 3.2.4 Immediate Addressing | 3.2.5 Relative Addressing | 3.2.6 
 Absolute Addressing | 3.2.7 Long Addressing | 3.2.8 Indexed Addressing
  
 3.3
  
 Instruction Types
  
 59
  
 3.3.1 Arithmetic Instructions | 3.3.2 Logical Instructions | 3.3.3 Data Transfer 
 Instructions | 3.3.4 Boolean Instructions | 3.3.5 Program Branching Instructions
  
 Summary 7 8
  
 Problems 7 8",NA
4,"TIMER OPERATION 87
  
 4.1
  
 Introduction
  
 87
  
 89
  
 90
  
 4.2
  
 Timer Mode Register (TMOD)
  
 4.3
  
 Timer Control Register (TCON)
  
 89
  
 4.4
  
 Timer Modes and the Overflow Flag
  
 4.4.1 13-Bit Timer Mode (Mode 0) | 4.4.2 16-Bit Timer Mode (Mode 1) | 4.4.3 8-
 Bit Auto-Reload Mode (Mode 2) | 4.4.4 Split Timer Mode (Mode 3)
  
 4.5
  
 Clocking Sources
  
 92
  
 4.5.1 Interval Timing | 4.5.2 Event Counting",NA
5,"SERIAL PORT OPERATION 111
  
 5.1
  
 Introduction
  
 111
  
 5.2
  
 Serial Communication
  
 111
  
 5.3
  
 Serial Port Buffer Register (SBUF)
  
 5.4
  
 Serial Port Control Register (SCON)
  
 5.5
  
 Modes of Operation
  
 113
  
 5.5.1 8-Bit Shift Register (Mode 0) | 5.5.2 8-Bit UART with Variable Baud Rate 
 (Mode 1) | 5.5.3 9-Bit UART with Fixed Baud Rate (Mode 2) | 5.5.4 9-Bit 
 UART with Variable Baud Rate (Mode 3)
  
 5.6
  
 Full Duplex Serial Communication: Issues
  
 117
  
 118
  
 5.7
  
 Initialization and Accessing Serial Port Registers
  
 5.7.1 Receiver Enable | 5.7.2 The Ninth Data Bit | 5.7.3 Adding a Parity Bit | 
 5.7.4 Interrupt Flags |
  
 5.8
  
 Multiprocessor Communications
  
 119
  
 5.9
  
 Serial Port Baud Rates
  
 120
  
 5.9.1 Using Timer 1 as the Baud Rate Clock
  
 Summary 1 2 7
  
 Problems
  
 128
  
 132",NA
6,"INTERRUPTS 131
  
 6.1
  
 Introduction
  
 131
  
 6.2
  
 8051 Interrupt Organization
  
 6.2.1 Enabling and Disabling Interrupts | 6.2.2 Interrupt Priority | 6.2.3 
 Polling Sequence",NA
7,"ASSEMBLY LANGUAGE PROGRAMMING 151 
  
 7.1 
  
 Introduction 151
  
 7.2 
  
 Assembler Operation 152
  
 7.2.1 Pass One | 7.2.2 Pass Two
  
 7.3
  
 Assembly Language Program Format
  
 155
  
 7.3.1 Label Field | 7.3.2 Mnemonic Field | 7.3.3 Operand Field | 7.3.4 Comment 
 Field | 7.3.5 Special Assembler Symbols | 7.3.6 Indirect Address | 7.3.7 Immediate 
 Data | 7.3.8 Data Address | 7.3.9 Bit Address | 7.3.10 Code Address | 7.3.11 
 Generic Jumps and Calls
  
 7.4
  
 Assemble-Time Expression Evaluation
  
 160
  
 7.4.1 Number Bases | 7.4.2 Character Strings | 7.4.3 Arithmetic Operators | 7.4.4 
 Logical Operators | 7.4.5 Special Operators | 7.4.6 Relational Operators | 7.4.7 
 Expression Examples | 7.4.8 Operator Precedence
  
 7.5
  
 Assembler Directives
  
 164
  
 7.5.1 Assembler State Control | 7.5.2 Symbol Definition | 7.5.3 Storage 
 Initialization/Reservation | 7.5.4 Program Linkage | 7.5.5 Segment Selection 
 Directives
  
 7.6
  
 Assembler Controls
  
 173
  
 176
  
 7.7
  
 Linker Operation
  
 173
  
 7.8
  
 Annotated Example: Linking Relocatable Segments and Modules
  
 7.8.1 ECHO.LST | 7.8.2 IO.LST | 7.8.3 EXAMPLE.M51
  
 7.9
  
 Macros
  
 183
  
 7.9.1 Parameter Passing | 7.9.2 Local Labels | 7.9.3 Repeat Operations | 7.9.4 
 Control Flow Operations |
  
 Summary
  1 8 8
  
 Problems 
 188",NA
8,"8051 C PROGRAMMING 191
  
 191
  
 8.1
  
 Introduction
  
 191
  
 8.2
  
 Advantages and Disadvantages of 8051 C
  
 8.3
  
 8051 C Compilers
  
 192
  
 8.4
  
 Data Types
  
 193
  
 8.5
  
 Memory Types and Models
  
 197
  
 8.6
  
 Arrays
  
 198
  
 8.7
  
 Structures
  
 199
  
 8.8
  
 Pointers
  
 199
  
 8.8.1 A Pointer's Memory Type V 8.8.2 Typed Pointers | 
 8.8.3 Untyped Pointers
  
 8.9
  
 Functions
  
 202
  
 8.9.1 Parameter Passing | 8.9.2 Return Values
  
 8.10
  
 Some 8051 C Examples
  
 204
  
 8.10.1 The First Program || 8.10.2 Timers | 8.10.3 Serial Port | 8.10.4 
 Interrupts
  
 Summary 214
  
 Problems 214",NA
9,"PROGRAM STRUCTURE AND DESIGN 217
  
 219
  
 9.1
  
 Introduction
  
 217
  
 9.2
  
 Advantages and Disadvantages of Structured Programming
  
 9.3
  
 The Three Structures
  
 220
  
 9.3.1 Statements | 9.3.2 The Loop Structure | 9.3.3 The Choice Structure
  
 9.4
  
 Pseudo Code Syntax
  
 234
  
 237
  
 9.5
  
 Assembly Language Programming Style
  
 9.5.1 Labels | 9.5.2 Comments || 9.5.3 Comment Blocks | 9.5.4 Saving 
 Registers on the Stack | 9.5.5 The Use of Equates || 9.5.6 The Use of 
 Subroutines | 9.5.7 Program Organization
  
 9.6
  
 8051 C Programming Style
  
 243
  
 9.6.1 Comments | 9.6.2 The Use of Defines | 9.6.3 The Use of Functions | 9.6.4 
 The Use of Arrays and Pointers | 9.6.5 Program Organization
  
 Summary 2 4 5
  
 Problems 2 4 5",NA
10,"TOOLS AND TECHNIQUES FOR PROGRAM
  
 DEVELOPMENT 247
  
 10.1
  
 Introduction
  
 247
  
 247
  
 10.2
  
 The Development Cycle
  
 10.2.1 Software Development | 10.2.2 Hardware Development
  
 10.3
  
 Integration and Verification
  
 251
  
 10.3.1 Software Simulation | 10.3.2 Hardware Emulation | 10.3.3
  
 Execution from RAM | 10.3.4 Execution from EPROM | 10.3.5 The
  
 Factory Mask Process
  
 10.4
  
 Commands and Environments
  
 255
  
 Summary 2 5 7
  
 Problems 2 5 7",NA
11,"DESIGN AND INTERFACE EXAMPLES 259
  
 11.1 
  
 Introduction 
  
 259
  
 11.2 
  
 The SBC-51 
  
 259
  
 11.3 
  
 Hexadecimal Keypad Interface 
  
 265
  
 11.4 
  
 Interface to Multiple 7-Segment LEDs 
  
 267
  
 11.5 
  
 Interface to Liquid Crystal Displays (LCDs) 
  
 273
  
 11.6 
  
 Loudspeaker Interface 
  
 276
  
 11.7 
  
 Nonvolatile RAM Interface 
  
 277
  
 11.8 
  
 Input/Output Expansion 282
  
 11.8.1 Using Shift Registers | 11.8.2 Using the 8255
  
 11.9
  
 RS232 (EIA-232) Serial Interface
  
 291
  
 11.10
  
 Centronics Parallel Interface 294
  
 11.11
  
 Analog Output
  
 296
  
 11.12
  
 Analog Input
  
 300
  
 11.13
  
 Interface to Sensors
  
 303
  
 11.14
  
 Interface to Relays
  
 306
  
 11.15 
  
 Stepper Motor Interface 310
  
 Summary 315
  
 Problems 315",NA
12,"DESIGN AND INTERFACE EXAMPLES IN C 319
  
 12.1 
  
 Introduction 
  
 319
  
 12.2 
  
 Hexadecimal Keypad Interface 
  
 319
  
 12.3 
  
 Interface to Multiple 7-Segment LEDs 
  
 323",NA
13,"EXAMPLE STUDENT PROJECTS 353
  
 13.1
  
 Introduction
  
 353
  
 353
  
 13.2
  
 Home Security System
  
 13.2.1 Project Description | 13 .2.2 System Specifications 
 13.2.3 System Design | 13.2.4 Software Design
  
 13.3
  
 Elevator System
  
 355
  
 13.3.1 Project Description | 13 .3.2 System Specifications 
 13.3.3 System Design | 3.3.4 Software Design
  
 13
 . 4 
  
 Tic
 -
  Tac
 -
  Toe 358 
  
  
  
 13.4.1 Project Description | 13 .4.2 System Specifications 
  
  
 13.4.3 Software Design
  
 13.5
  
 Calculator
  
 363
  
 13.5.1 Project Description | 13.5.2 System Specifications 
 13.5.3 Software Design
  
 13
 . 6 
  
 Micromouse 366 
  
  
  
 13.6.1 Project Description | 13.6.2 System Specifications 
  
  
 13.6.3 System Design | 13.6.4 Software Design
  
 13.7
  
 A Soccer-Playing Robot
  
 369
  
 13.7.1 Project Description | 13.7.2 System Specifications 
 13.7.3 System Design | 13.7.4 Software Design
  
 13.8
  
 A Smart Card Application
  
 371
  
 13.8.1 Basic Security Concepts | 13.8.2 Project Description | 
 13.8.3 System Specifications | 13.8.4 Software Design
  
 Summary 373
  
 Problems 374",NA
14,"8051 DERIVATIVES 377
  
 377
  
 14.1
  
 Introduction
  
 377
  
 14.2
  
 MCS-151TM
 TM
 and MCS-251TM
 TM
 377
  
 14.3
  
 Microcontrollers with Flash Memory and NVRAM
  
 14.4
  
 Microcontrollers with ADCs and DACs
  
 378
  
 14.5
  
 High-Speed 
 Microcontrollers
  
 378
  
 14.6
  
 Network Microcontrollers
  
 379
  
 14.7
  
 Secure Microcontrollers
  
 379
  
 Summary 379
  
 Problems 380
  
 APPENDICES
  
 A 
  
 Quick Reference Chart 381
  
 B 
  
 Opcode Map 383
  
 C 
  
 Instruction Definitions 385
  
 D 
  
 Special Function Registers 431
  
 E 
  
 8051 Data Sheet 439
  
 F 
  
 ASCII Code Chart 
  
 455
  
 G 
  
 MON51—An 8051
  Monitor Program 
  
 457
  
 H 
  
 A Guide to Keil's µVision2 IDE 
  
 499
  
 I 
  
 A Guide to the 8052 Simulator 507
  
 J 
  
 The Advanced Encryption Standard 
  
 515
  
 K 
  
 Sources of
  8051 Development Products 
  
 521
  
 BIBLIOGRAPHY 527
  
 INDEX 529",NA
Introduction to Microcontrollers,NA,NA
1.1 INTRODUCTION,"Although computers have been with us for only a few decades, their impact has been pro-
 found, rivaling that of the telephone, automobile, or television. Their presence is felt by us 
 all, whether computer programmers or recipients of monthly bills printed by a large com-
 puter system and delivered by mail. Our notion of computers usually categorizes them as 
 ""data processors,"" performing numeric operations with inexhaustible competence.
  
 We confront computers of a vastly different breed in a more subtle context 
 performing tasks in a quiet, efficient, and even humble manner, their presence often 
 unnoticed. As a central component in many industrial, automotive, and consumer 
 products, we find com-puters at the supermarket inside cash registers and scales; at home 
 in ovens, washing ma-chines, alarm clocks, and thermostats; at play in toys, VCRs, stereo 
 equipment, and musical instruments; at the office in typewriters and photocopiers; in cars 
 in dashboards and ignition systems; and in industrial equipment such as drill presses and 
 phototypesetters. In these set-tings computers are performing ""control"" functions by 
 interfacing with the ""real world"" to turn devices on and off and to monitor conditions.
  
 Microcontrollers
  (as opposed to micro-computers or microprocessors) are often found in 
 applications such as these.
  
 It's hard to imagine the present world of electronic tool toys without the micro-
 processor. Yet this single-chip wonder has barely reached its 35th birthday. In 1971 Intel 
 Corporation introduced the 8080, the first successful microprocessor. Shortly thereafter, 
 Motorola, RCA, and then MOS Technology and Zilog introduced similar devices: the 
 6800, 1801, 6502, and Z80, respectively. Alone these integrated circuits (ICs) were rather 
 helpless (and they remain so); but as part of a single-board computer (SBC) they became 
 the central component in useful products for learning about and designing with 
 microprocessors. These SBCs, of which the
  D2
  by Motorola,
  KIM-1
  by MOS Technology, 
 and
  SDK-85
  by Intel are the most memorable, quickly found their way into design labs at 
 colleges, universities, and electronics companies.",NA
1.3,"THE CENTRAL PROCESSING UNIT
  
 The CPU, as the ""brain"" of the computer system, administers all activity in the system and 
 per-forms all operations on data. Most of the CPU's mystique is undeserved, since it is just 
 a col-lection of logic circuits that continuously performs two operations: fetching 
 instructions and executing instructions. The CPU has the ability to understand and execute 
 instructions based on a set of binary codes, each representing a simple operation. These 
 instructions are usually arithmetic (add, subtract, multiply, divide), logic (AND, OR, 
 NOT, etc.), data movement, or branch operations, and are represented by a set of binary 
 codes called the
  instruction set.
  
 Figure 1-3 is an extremely simplified view of the inside of a CPU. It shows a set of 
 registers
  for the temporary storage of information, an
  arithmetic and logic unit
  (ALU) 
 for performing operations on this information, an
  instruction decode and control unit
  
 that de-termines the operation to perform and sets in motion the necessary actions to 
 perform it, and two additional registers. The
  instruction register (IR)
  holds the binary 
 code for each instruction as it is executed, and the
  program counter (PC)
  holds the 
 memory address of the next instruction to be executed.
  
 Fetching an instruction from the system RAM or ROM is one of the most funda-
 mental operations performed by the CPU. It involves the following steps: (a) the contents 
 of the program counter are placed on the address bus, (b) a READ control signal is 
 activated, (c) data (the instruction opcode) are read from RAM and placed on the data bus, 
 (d) the op-code is latched into the CPU's internal instruction register, and (e) the program 
 counter is incremented to prepare for the next fetch from memory. Figure 1-4 illustrates 
 the flow of information for an instruction fetch.
  
  
 The execution stage involves decoding (or deciphering) the opcode and generating 
 con-trol signals to gate internal registers in and out of the ALU and to signal the ALU to 
 perform",NA
1.5,"THE BUSES: ADDRESS, DATA, AND CONTROL
  
 A bus is a collection of wires carrying information with a common purpose. Access to the 
 circuitry around the CPU is provided by three buses: the
  address bus, data bus,
  and 
 control bus.
  For each read or write operation, the CPU specifies the location of the data 
 (or instruction) by placing an address on the address bus and then activates a signal on the 
 control bus, indicating whether the operation is a read or write. Read operations retrieve a 
 byte of data from memory at the location specified and place it on the data bus. The CPU 
 reads the data and places it in one of its internal registers. For a write operation, the CPU 
 outputs data on the data bus. Because of the control signal, memory recognizes the 
 operation as a write cycle and stores the data in the location specified.
  
 Most small computers have 16 or 20 address lines. Given
  n
  address lines, each with 
 the possibility of being high (1) or low (0), 2
 n
 locations can be accessed. A 16-bit address 
 bus, therefore, can access 2
 16
 = 65,536 locations, and a 20-bit address can access 2
 20
 = 
 1,048,576 locations. The abbreviation
  K
  (for kilo) stands for 2
 10
 = 1024; therefore, 16 bits 
 can address 2
 6
 x
  2
 10
 = 64K locations, whereas 20 bits can address 1024K or 1 M locations. 
 The abbreviation M (for mega) stands for 2
 20
 = 1024
  x
  1024 = 1024K = 1,048,576.
  
 The data bus carries information between the CPU and memory or between the CPU 
 and I/O devices. Extensive research effort has been expended in determining the sort of 
 ac-tivities that consume a computer's valuable execution time. Evidently computers spend 
 up to two thirds of their time simply moving data. Since the majority of move operations 
 are between a CPU register and external RAM or ROM, the number of lines (the width) of 
 the data bus is important for overall performance. This limitation-by-width is a bottleneck: 
 There may be vast amounts of memory on the system, and the CPU may possess tremen-
 dous computational power, but access to the data—data movement between the memory 
 and CPU via the data bus—is bottlenecked by the width of the data bus.
  
 This trait is so important that it is common to add a prefix indicating the extent of 
 this bottleneck. The phrase ""16-bit computer"" refers to a computer with 16 lines on its data 
 bus. Most computers fit the 4-bit, 8-bit, 16-bit, or 32-bit classification, with overall 
 computing power increasing as the width of the data bus increases.
  
 Note that the data bus, as shown in Figure 1-2, is bidirectional, and the address bus 
 is unidirectional. Address information is always supplied by the CPU (as indicated by the 
 arrow in Figure 1-2), yet data may travel in either direction depending on whether a read 
 or write operation is intended.
 1
 Note also that the term ""data"" is used in a general sense: the 
 ""information"" that travels on the data bus may be the instructions of a program, an address 
 appended to an instruction, or the data used by the program.
  
 1
 Address information is sometimes also provided by direct memory access (DMA) circuitry (in
  
 addition to the CPU).",NA
1.6,"INPUT/OUTPUT DEVICES
  
 I/O devices, or ""computer peripherals,"" provide the path for communication between the 
 computer system and the ""real world."" Without these, computer systems would be rather 
 introverted machines, of little use to the people who use them. Three classes of I/O 
 devices are
  mass storage, human interface,
  and
  control/monitor.
  
 1.6.1 Mass Storage Devices
  
 Like semiconductor RAMS and ROMs, mass storage devices are players in the arena of 
 memory technology—constantly growing, ever improving. As the name suggests, they 
 hold large quantities of information (programs or data) that cannot fit into the computer's 
 relatively small RAM or ""main"" memory. This information must be loaded into main 
 mem-ory before the CPU accesses it. Classified according to ease of access, mass storage 
 devices are either
  online
  or
  archival.
  Online storage, usually on magnetic disk, is 
 available to the CPU without human intervention upon the request of a program, and 
 archival storage holds data that are rarely needed and require manual loading onto the 
 system. Archival storage is usually on magnetic tapes or disks, although optical discs, such 
 as CD-ROM or WORM technology, are now emerging and may alter the notion of 
 archival storage due to their re-liability, high capacity, and low cost.
 2
  
 1.6.2 Human Interface Devices
  
 The union of human and machine is realized by a multitude of human interface devices, 
 the most common being the video display terminal (VDT) and printer. Although printers 
 are strictly output devices that generate hardcopy output, VDTs are really two devices, 
 since they contain a keyboard for input and a CRT (cathode-ray tube) for output. An entire 
 field of engineering, called ""ergonomics"" or ""human factors,"" has evolved from the 
 necessity to design these peripheral devices with humans in mind, the goal being the safe, 
 comfortable, and efficient mating of the characteristics of people with the machines they 
 use. Indeed, there are more companies that manufacture this class of peripheral device 
 than companies that manufacture computers. For most computer systems, there are at least 
 three of these devices: a keyboard, CRT, and printer. Other human interface devices 
 include the joystick, light pen, mouse, microphone, and loudspeaker.
  
 2
 ""CD-ROM"" stands for compact-disc read-only memory. ""WORM"" stands for write-once read-mostly. A CD-
 ROM contains 700 Mbyte of storage, enough to store the entire 32 volumes of
  Encyclopedia Britannica.",NA
1.7,"PROGRAMS: BIG AND SMALL
  
 The preceding discussion has focused on computer systems hardware with only a passing 
 mention of the programs, or software, that make them work. The relative emphasis placed 
 on hardware versus software has shifted dramatically in recent years. Whereas the early 
 days of computing witnessed the materials, manufacturing, and maintenance costs of com-
 puter hardware far surpassing the software costs, today, with mass-produced LSI (large-
 scale integrated) chips, hardware costs are less dominant. It is the labor-intensive job of 
 writing, documenting, maintaining, updating, and distributing software that constitutes the 
 bulk of the expense in automating a process using computers.
  
 Let's examine the different types of software. Figure 1-5 illustrates three levels of 
 software between the user and the hardware of a computer system: the
  application soft-
 ware,
  the
  operating system,
  and the
  input/output subroutines.
  
 At the lowest level, the input/output subroutines directly manipulate the hardware of the 
 system, reading characters from the keyboard, writing characters to the CRT, reading 
 blocks of information from the disk, and so on. Since these subroutines are so intimately 
 linked to the hardware, they are written by the hardware designers and are (usually) stored 
 in ROM. (They are the BIOS—basic input/output system—on the IBM PC, for example.) 
 To provide close access to the system hardware for programmers, explicit entry and exit 
 conditions are defined for the input/output subroutines. One only needs to initialize values 
 in CPU registers and call the subroutine; the action is carried out with results returned in 
 CPU registers or left in system RAM.
  
 As well as a full complement of input/output subroutines, the ROM contains a start-up 
 program that executes when the system is powered up or reset manually by the operator. 
 The nonvolatile nature of ROM is essential here since this program must exist upon 
 power-up. ""Housekeeping"" chores, such as checking for options, initializing memory, 
 performing diag-nostic checks, etc., are all performed by the start-up program. Last, but 
 not least, a
  bootstrap loader
  routine reads the first track (a small program) from the disk",NA
1.8,"MICROS, MINIS, AND MAINFRAMES
  
 Using their size and power as a starting point, we classify computers as microcomputers, 
 minicomputers, or mainframe computers. A key trait of microcomputers is the size and 
 pack-aging of the CPU: It is contained within a single integrated circuit—a
  
 microprocessor.
  On the other hand, minicomputers and mainframe computers, as well as 
 being more complex in every architectural detail, have CPUs consisting of multiple ICs, 
 ranging from several ICs (minicomputers) to several circuit boards of ICs (mainframes). 
 This increased capacity is necessary to achieve the high speeds and computational power 
 of larger computers.
  
 Typical microcomputers such as the IBM
  PC,
  Apple
  Macintosh,
  and Commodore 
 Amiga
  incorporate a microprocessor as their CPU. The RAM, ROM, and interface circuits 
 require many ICs, with the component count often increasing with computing power. In-
 terface circuits vary considerably in complexity, depending on the I/O devices. Driving 
 the",NA
1.9,"MICROPROCESSORS VS. MICROCONTROLLERS
  
 It was pointed out above that microprocessors are single-chip CPUs used in 
 microcomputers. How, then, do microcontrollers differ from microprocessors? This 
 question can be addressed from three perspectives:
  hardware architecture, applications,
  
 and
  instruction set features.
  
 1.9.1 Hardware Architecture
  
 To highlight the difference between microcontrollers and microprocessors, Figure 1-2 is 
 redrawn in Figure 1-6, showing more detail.
  
 Whereas a microprocessor is a single-chip CPU, a microcontroller contains, in a sin-
 gle IC, a CPU and much of the remaining circuitry of a complete microcomputer system. 
 The components within the dotted line in Figure 1-6 are an integral part of most micro-
 controller ICs. As well as the CPU, microcontrollers include RAM, ROM, a serial 
 interface, a parallel interface, timer, and interrupt scheduling circuitry—all within the 
 same IC. Of course, the amount of on-chip RAM does not approach that of even a modest 
 microcomputer system; but, as we shall learn, this is not a limitation, since 
 microcontrollers are intended for vastly different applications.
  
 An important feature of microcontrollers is the built-in interrupt system. As control-
 oriented devices, microcontrollers are often called upon to respond to external stimuli 
 (interrupts) in real time. They must perform fast context switching, suspending one 
 process while executing another in response to an ""event."" The opening of a microwave 
 oven's door is an example of an event that might cause an interrupt in a microcontroller-
 based product. Of course, most microprocessors can also implement powerful interrupt 
 schemes, but external components are usually required. A microcontroller's on-chip 
 circuitry includes all the interrupt handling circuitry necessary.
  
 1.9.2 Applications
  
 Microprocessors are most commonly used as the CPU in microcomputer systems. This 
 function is what they are designed for, and this is where their strengths lie. 
 Microcontrollers, however, are found in small, minimum-component designs performing 
 control-oriented ac-tivities. These designs were often implemented in the past, using 
 dozens or even hundreds of digital ICs. A microcontroller can aid in reducing the overall",NA
1.10 NEW CONCEPTS,"Microcontrollers, like other products considered in retrospect to have been a breakthrough, 
 have arrived out of two complementary forces: market need and new technology. The new 
 technology is just that mentioned above: semiconductors with more transistors in less 
 space, mass produced at a lower cost. The market need is the industrial and consumer ap-
 petite for more sophisticated tools and toys.
 4
 This demand encompasses a lot of territory. 
 The most illustrative example, perhaps, is the automobile dashboard. Witness the transfor-
 mation of the car's ""control center"" over the past decade—made possible by the microcon-
 troller and other technological developments. Once, drivers were content to know their 
 speed; today they may find a display of fuel economy and estimated time of arrival. Once 
 it was sufficient to know if a seatbelt was unfastened while starting the car; today, we are 
 ""told"" which seatbelt is the culprit. If a door is ajar, we are again duly informed by the 
 spoken word. (Perhaps the seatbelt is stuck in the door.) 
  
 This brings to mind a necessary comment. Microprocessors (and in this sense micro-
 controllers) have been dubbed ""solutions looking for a problem."" It seems they have 
 proved so effective at reducing the complexity of circuitry in (consumer) products, that 
 manufac-turers are often too eager to include superfluous features simply because they are 
 easy to
  
 4
 1t is sometimes argued that ""market need"" is really ""market want,"" spurred on by the self-propelled growth of 
 technology.",NA
1.11 GAINS AND LOSSES: A DESIGN EXAMPLE,"The tasks performed by microcontrollers are not new. What is new is that designs are im-
 plemented with fewer components than before. Designs previously requiring tens or even 
 hundreds of ICs are implemented today with only a handful of components, including a 
 microcontroller. The reduced component count, a direct result of the microcontroller's pro-
 grammability and high degree of integration, usually translates into shorter development 
 time, lower manufacturing cost, lower power consumption, and higher reliability. Logic 
 operations that require several ICs can often be implemented within the microcontroller, 
 with the addition of a control program.
  
 One tradeoff is speed. Microcontroller-based solutions are never as fast as the dis-
 crete counterparts. Situations requiring extremely fast response to events (a minority of 
 ap-plications) are poorly handled by microcontrollers. For example, consider in Figure 1-7 
 the somewhat trivial implementation of the NAND operation using an 8051 
 microcontroller.",NA
Hardware Summary,NA,NA
2.1,"MCS-51
 TM
 FAMILY OVERVIEW
  
 The MCS-51
 TM
 is a family of microcontroller ICs developed, manufactured, and marketed 
 by Intel Corporation. Other IC manufacturers, such as Siemens, Advanced Micro Devices, 
 Fujitsu, and Philips are licensed ""second source"" suppliers of devices in the MCS-51
 TM 
 family. Each microcontroller in the family boasts a complement of features suited to a par-
 ticular design setting.
  
 In this chapter the hardware architecture of the MCS-51
 TM
 family is introduced. In-
 tel's data sheet for the entry-level devices (e.g., the 8051AH) is found in Appendix E. This 
 appendix should be consulted for further details, for example, on electrical properties of 
 these devices.
  
 Many of the hardware features are illustrated with short sequences of instructions. 
 Brief descriptions are provided with each example, but complete details of the instruction 
 set are deferred to Chapter 3. See also Appendix A for a summary of the 8051 instruction 
 set or Appendix C for definitions of each 8051 instruction.
  
 The generic MCS-51
 TM
 IC is the 8051, the first device in the family offered com-mercially. 
 Its features are summarized below.
  
 •
  4K bytes ROM (factory mask programmed)
  
 •
  128 bytes RAM
  
 •
  Four 8-bit I/O (Input/Output) ports
  
 •
  Two 16-bit timers
  
 •
  Serial interface
  
 •
  64K external code memory space
  
 •
  64K external data memory space
  
 •
  Boolean processor (operates on single bits)
  
 •
  210 bit-addressable locations
  
 •
  4 µs multiply/divide
  
 17",NA
2.2,"ONCE AROUND THE PINS
  
 This section 
  
 introduces 
  
 the 
  
 8051 
  
 hardware 
  
 architecture 
  
 from 
  
 an 
  
 external
  
 perspective—the pinouts (see Figure 2-2). A brief description of the function of
  
 each pin follows.
  
 As evident in Figure 2-2, 32 of the 8051's 40 pins function as I/O port lines.
  
 However, 24 of these lines are dual-purpose (26 on the 8032/8052). Each can
  
 operate as I/O, or as a control line or part of the address or data bus.
  
 Designs requiring a 
  
 minimum 
  
 of external 
  
 memory 
  
 or 
  
 other external
  
 components use these ports for general purpose I/O. The eight lines in each port
  
 can be treated as a unit in interfacing to parallel devices such as printers, digital-
  
 to-analog converters, and so on. Or, each line can operate independently in
  
 interfacing to single-bit devices such as switches, LEDs, transistors, solenoids,
  
 motors, and loudspeakers.
  
 2.2.1 Port 0
  
 Port 0 is a dual-purpose port on pins 32-39 of the 8051 IC. In minimum-component
  
 designs, it is used as a general purpose I/O port. For larger designs with external memory,
  
 it becomes a multiplexed address and data bus. (See 2.7 External Memory.)
  
 2.2.2 Port 1
  
 Port 1 is a dedicated I/O port on pins 1-8. The pins, designated as P1.0, P1.1, P1.2, etc., are
  
 available for interfacing to external devices as required. No alternate functions are as signed",NA
2.3,"I/O PORT STRUCTURE
  
 The internal circuitry for the port pins is shown in abbreviated form in Figure 2-4. Writing 
 to a port pin loads data into a port latch that drives a field-effect transistor connected to the 
 port pin. The drive capability is four low-power Schottky TTL loads for Ports 1, 2, and 3; 
 and eight LS loads for Port 0. (See Appendix E for more details.) Note that the pull-up 
 resistor is absent on Port 0 (except when functioning as the external address/data bus). An 
 external pull-up resistor may be needed, depending on the input characteristics of the 
 device driven by the port pin.
  
 There is both a ""read latch"" and ""read pin"" capability. Instructions that require a read-
 modify-write operation (e.g., CPL P1.5) read the latch to avoid misinterpreting the voltage 
 level in the event the pin is heavily loaded (e.g., when driving the base of a transistor). In-
 structions that input a port bit (e.g., MOV C,P1.5) read the pin. The port latch must contain",NA
2.4,"TIMING AND THE MACHINE CYCLE
  
 The 8051's on-chip oscillator is driven by an external quartz crystal through pins 18 and 
 19. This crystal has a typical frequency of 12 MHz, meaning that it generates 12 million 
 clock cycles per second. These oscillator clock cycles form the basis of the 8051's timing 
 and synchronization: Every operation performed by the 8051 is in step with these cycles.
  
 With the oscillator clock as reference, the 8051 requires two such clock cycles to 
 per-form a single discrete operation, which is either fetching an instruction, decoding, or 
 exe-cuting it. This duration of two clock cycles is also called a
  state.
  Therefore, in order to 
 fully process an instruction, the 8051 would generally require six such states, or 12 clock 
 cycles since it would have to first fetch and decode the instruction before it goes to 
 execute it. This duration of six states is also known as one
  machine cycle.
  Of course, 
 more complex in-structions would take more than one machine cycle to be carried out. 
 Both Appendix B and C provide a list of the number of machine cycles for all the 8051 
 instructions. This number ranges from one to four machine cycles. Figure 2-5 shows the 
 relationship between oscillator clock cycles (P), states (S), and a machine cycle.
  
 Typically, the 8051's on-chip oscillator, f
 osc
  is driven by a 12 MHz crystal, so the 
 period of one clock pulse, T
 clock
  = 1/f
 osc
  = 1/12 MHz = 83.33 ns. One machine cycle con-
 sists of 12 such clock pulses, hence its duration is 83.33 ns x 12 = 1 µs.",NA
2.5,"MEMORY ORGANIZATION
  
 FIGURE 2-5 
  
 Relationship between oscillator 
 clock cycles, states, and the 
 machine cycle
  
 Most microprocessors implement a shared memory space for data and programs. This is 
 reasonable, since programs are usually stored on a disk and loaded into RAM for execu-
 tion; thus both the data and programs reside in the system RAM. Microcontrollers, on the 
 other hand, are rarely used as the CPU in ""computer systems."" Instead, they are employed 
 as the central component in control-oriented designs. There is limited memory, and there is 
 no disk drive or disk operating system. The control program must reside in ROM.
  
 For this reason, the 8051 implements a separate memory space for programs (code) 
 and data. As shown in Table 2-1, both the code and data may be internal; however, both 
 expand using external components to a maximum of 64K code memory and 64K data 
 memory.
  
 The internal memory consists of on-chip ROM (8051/8052 only) and on-chip data 
 RAM. The on-chip RAM contains a rich arrangement of general-purpose storage, bit-
 addressable storage, register banks, and special function registers.
  
 Two notable features are: (a) the registers and input/output ports are memory mapped 
 and accessible like any other memory location, and (b) the stack resides within the internal 
 RAM, rather than in external RAM as typical of microprocessors.
  
 Figure 2-6 summarizes the memory spaces for the ROM-less 8031 device without showing 
 any detail of the on-chip data memory. (8032/8052 enhancements are summarized later.) 
  
 Figure 2-7 gives the details of the on-chip data memory. As shown, the internal data 
 memory space is divided between
  internal RAM
  (00H-7FH) and
  special function regis-
 ters
  (80H-0FFH). A confusion sometimes arises between the concept of internal (on-chip) 
 data memory and internal RAM. The 8051's internal data memory space has the range from 
 00H-0FFH, which is 256 bytes. However, only the lower half (00H-7FH) of the internal 
 memory space is for general data while the upper half (80H-0FFH) is mostly for specific 
 purposes and not for general data; hence, only the lower half is considered to be internal 
 RAM. The internal data RAM is further sub-divided into register banks (00H-1FH), bit-
 addressable RAM (20H-2FH), and general-purpose RAM (30H-7FH). Each of these sec-
 tions of internal memory is discussed below.
  
 2.5.1 General-Purpose RAM
  
 Although Figure 2-7 shows 80 bytes of general-purpose RAM from addresses 30H to 7FH, 
 the bottom 48 bytes from 00H to 2FH can be used similarly (although these locations have 
 other purposes as discussed below).",NA
2.6,"SPECIAL FUNCTION REGISTERS
  
 Internal registers on most microprocessors are accessed implicitly by the instruction set. 
 For example, ""INCA"" on the 6809 microprocessor increments the contents of the A accu-
 mulator. The operation is specified implicitly within the instruction opcode. Similar access 
 to registers is also used on the 8051 microcontroller. In fact, the 8051 instruction ""INC A"" 
 performs the same operation.
  
 The 8051 internal registers are configured as part of the on-chip RAM: therefore, 
 each register also has an address.
 1
 This is reasonable for the 8051, since it has so many reg-
 isters. As well as R0 to R7, there are 21 special function registers (SFRs) at the top of 
 internal RAM, from addresses 80H to 0FFH. (See Figure 2-7 and Appendix D.) Note that 
 most of the 128 addresses from 80H to 0FFH are not defined. Only 21 SFR addresses are 
 defined (26 on the 8032/8052).
  
 Although the accumulator (A or ACC) may be accessed implicitly as shown previ-
 ously, most SFRs are accessed using direct addressing. Note in Figure 2-7 that some SFRs 
 are both bit-addressable and byte-addressable. Programmers should be careful when ac-
 cessing bits versus bytes. For example, the instruction
  
 SETB 0E0H
  
 sets bit 0 in the accumulator, leaving the other bits unchanged. The trick is to recognize that 
 0E0H is both the byte address of the entire accumulator and the bit address of the least-
 significant bit in the accumulator. Since the SETB instruction operates on bits (not bytes), 
 only the addressed bit is affected. Notice that the addressable bits within the SFRs have the 
 five high-order address bits matching those of the SFR. For example, Port 1 is at byte 
 address 90H or 10010000B. The bits within Port 1 have addresses 90H to 97H, or 
 10010xxxB.
  
 1
 The program counter and the instruction register are exceptions. Since these registers are rarely manipulated 
 directly, nothing is gained by placing them in the on-chip RAM.",NA
2.7,"EXTERNAL MEMORY
  
 It is important that microcontrollers have expansion capabilities beyond the on-chip 
 resources to avoid a potential design bottleneck. If any resources must be expanded 
 (memory, I/O, etc.), then the capability must exist. The MCS-51
 TM
 architecture provides this 
 in the form of a 64K external code memory space and a 64K external data memory space. 
 Extra ROM and RAM can be added as needed. Peripheral interface ICs can also be added 
 to expand the I/O capa-bility. These become part of the external data memory space using 
 memory-mapped I/O.
  
 When external memory is used, Port 0 is unavailable as an I/O port. It becomes a 
 multi-plexed address (A0-A7) and data (D0-D7) bus, with ALE latching the low-byte of the 
 address at the beginning of each external memory cycle. Port 2 is usually (but not always) 
 employed for the high-byte of the address bus.
  
  
 FIGURE 2-8
  
 Multiplexing the address bus (low-byte) and data bus",NA
2.8,"8032/8052 ENHANCEMENTS
  
 The 8032/8052 ICs (and the CMOS and/or EPROM versions) offer two enhancements to 
 the 8031/8051 ICs. First, there is an additional 128 bytes of on-chip RAM from addresses",NA
2.9,"RESET OPERATION
  
  
 (a) Manual reset 
  
 (b) Power
 -
 on reset
  
 The 8051 is reset by holding RST high for at least two machine cycles and then returning 
 it low. RST may be manually activated using a switch, or it may be activated upon power-
 up using an RC (resistor-capacitor) network. Figure 2-16 illustrates two circuits for 
 implementing system reset.
  
 The state of all the 8051 registers after a system reset is summarized in Table 2-6. 
 The most important of these registers, perhaps, is the program counter, which is loaded 
 with 0000H. When RST returns low, program execution always begins at the first location 
 in code memory: address 0000H. The content of on-chip RAM is not affected by a reset 
 operation.
  
 TABLE 2-6
  
 Register values after system reset
  
 Register(s)
  
 Contents
  
 Program counter 
 Accumulator 
  
 B register 
  
 PSW 
  
 SP 
  
 DPTR 
  
 Ports 0-3 
  
 IP (8031/8051) IP 
 (8032/8052) IE 
 (8031/8051) E 
 (8032/8052) 
  
 Timer registers 
 SCON 
  
 SBUF 
  
 PCON (HMOS) 
 PCON (CMOS)
  
 0000H 
  
 00H 
  
 00H 
  
 00H 
  
 07H 
  
 0000H 
  
 0FFH 
  
 XX000000B 
  
 0X000000B 
  
 0XX00000B 
  
 XX000000B 
  
 00H 
  
 00H 
  
 00H 
  
 0XXXXXXXB 
 0XX00000B",NA
Instruction Set Summary,"3.1 INTRODUCTION
  
 Just as sentences are made of words, programs are made of instructions. When programs 
 are constructed from logical, well-thought-out sequences of instructions, fast, efficient, 
 and even elegant programs result. Unique to each family of computers is its instruction 
 set, a repertoire of primitive operations such as ""add,"" ""move,"" or ""jump."" This chapter 
 introduces the MCS-51
 TM
 instruction set through an examination of addressing modes and 
 examples from typical programming situations. Appendix A contains a summary chart of 
 all the 8051 instructions. Appendix C provides a detailed description of each instruction. 
 These appen-dices should be consulted for subsequent reference.
  
 Programming techniques are not discussed, nor is the operation of the assembler pro-
 gram used to convert assembly language programs (mnemonics, labels, etc.) into machine 
 language programs (binary codes). These topics are the subject of Chapter 7.
  
 The MCS-51
 TM
 instruction set is optimized for 8-bit control applications. It provides 
 a variety of fast, compact addressing modes for accessing the internal RAM to facilitate 
 operations on small data structures. The instruction set offers extensive support for 1-bit 
 variables, allowing direct bit manipulation in control and logic systems that require 
 Boolean processing.
  
 As typical of 8-bit processors, 8051 instructions have 8-bit opcodes. This structure 
 provides a possibility of 2
 8
 = 256 instructions. Of these, 255 are implemented and 1 is 
 undefined. As well as the opcode, some instructions have one or two additional bytes for 
 data or addresses. In all, there are 139 1-byte instructions, 92 2-byte instructions, and 24 
 3-byte instructions. The
  Opcode Map
  in Appendix B shows, for each opcode, the 
 mnemonic, the number of bytes in the instruction, and the number of machine cycles to 
 execute the instruction.
  
 49",NA
3.3,"INSTRUCTION TYPES
  
 The 8051 instructions are divided among five functional groups:
  
 •
  Arithmetic
  
 •
  Logical
  
 •
  Data transfer",NA
3.3.1 Arithmetic Instructions,"The arithmetic instructions are grouped together in Appendix A. Since four addressing 
 modes are possible, the ADD A instruction can be written in different ways:
  
 ADD A,7PH 
  
 ADD A,@R0 
  
 ADD A,R7 
  
 ADD 
 A,#35H
  
 (direct addressing) 
  
 (indirect addressing) 
  
 (register addressing) 
  
 (immediate 
 addressing)
  
 All arithmetic instructions execute one machine cycle except the INC DPTR 
 instruction (two machine cycles) and the MUL AB and DIV AB instructions (four machine 
 cycles).
  
 (Note that one machine cycle takes 1 µs if the 8051 is operating from a 12 MHz clock.)
  
 EXAMPLE 
 3.11
  
 The accumulator contains 63H, R3 contains 23H, and the PSW contains 00H. (a) What is 
 the hexadecimal content of the accumulator and the PSW after execution of the following 
 instruction?
  
 ADD A,R3
  
 (b) What is the content of the accumulator in decimal after execution of this instruction?
  
 Solution 
  
 (a) ACC = 86H, PSW = 05H. (b) Decimal content of ACC = ? (see discussion).
  
 Discussion 
  
 On the surface, this example seems straightforward: Given two values, add them and ob-
 tain the sum. However, there are some interesting conceptual issues that are important to 
 understand. Let us begin by expressing the initial values of the ACC and R3 in decimal. By 
 the usual method of conversion to decimal, 
  
 A = 63H = 01100011B = 99
 10
  and 
 R3 = 23H = 00100011B = 35
 10
 . So, the result of the addition is 99
 10
  + 35
 10
  = 134
 10
 . 
 However, there is a problem. If we assume that a two's-complement signed notation is 
 used, the largest positive number that can be expressed in 8 bits is +127
 10
 . If an unsigned 
 notation is used, the largest possible 8-bit value is +255
 10
  and, in this case, the final result 
 of 134
 10
  is perfectly OK.
  
 Of course, the 8051 CPU has no special knowledge of whether the data are signed 
 binary, unsigned binary, binary-coded decimal, ASCII, etc. Only you—the programmer—
 knows for sure. The mechanism to manage different formats of data is provided through 
 the status bits in the PSW. To illustrate this, the addition is worked out below in binary.
  
 11...11.
  
 01100011 (ACC = 63H)",NA
Timer Operation,"4.1 INTRODUCTION
  
 In this chapter we examine the 8051's on-chip timers. We begin with a simplified view of 
 timers as they are commonly used with microprocessors or microcontrollers.
  
 A timer is a series of divide-by-2 flip-flops that receive an input signal as a clocking 
 source. The clock is applied to the first flip-flop, which divides the clock frequency by 2. 
 The output of the first flip-flop clocks the second flip-flop, which also divides by 2, and so 
 on. Since each successive stage divides by 2, a timer with
  n
  stages divides the input clock 
 frequency by 2
 n
 . The output of the last stage clocks a timer overflow flip-flop, or
  flag, 
 which is tested by software or generates an interrupt. The binary value in the timer flip-
 flops can be thought of as a ""count"" of the number of clock pulses (or ""events"") since the 
 timer was started. A 16-bit timer, for example, would count from 0000H-to-0FFFFH. The 
 overflow flag is set on the 0FFFFH-to-0000H overflow of the count.
  
 The operation of a simple timer is illustrated in Figure 4-1 for a 3-bit timer. Each 
 stage is shown as a type-D negative-edge-triggered flip-flop operating in divide-by-2 
 mode (i.e., the Q output connects to the D input). The flag flip-flop is simply a type-D 
 latch, set by the last stage in the timer. It is evident in the timing diagram in Figure 4-1b 
 that the first stage (Q
 0
 ) toggles at 1/2 the clock frequency, the second stage at 1/4 the clock 
 frequency, and so on. The count is shown in decimal and is easily verified by examining 
 the state of the three flip-flops. For example, the count ""4"" occurs when Q
 2
  = 1, Q
 1
  = 0, 
 and Q
 o
  = 0 (4
 10
  = 100
 2
 ).
  
 Timers are used in virtually all control-oriented applications, and the 8051 timers 
 are no exception. There are two 16-bit timers each with four modes of operation. A third 
 16-bit timer with three modes of operation is added on the 8052. The timers are used for 
 (a) interval timing, (b) event counting, or (c) baud rate generation for the built-in serial
  
 87",NA
4.2,"TIMER MODE REGISTER (TMOD)
  
 The TMOD register contains two groups of four bits that set the operating mode for Timer 
 0 and Timer 1. (See Table 4-2 and Table 4-3.) 
  
 TMOD is not bit-addressable, nor does it need to be. Generally, it is loaded once by 
 software at the beginning of a program to initialize the timer mode. Thereafter, the timer 
 can be stopped, started, and so on by accessing the other timer SFRs.",NA
4.3,"TIMER CONTROL REGISTER (TCON)
  
 The TCON register contains status and control bits for Timer 0 and Timer 1 (see Table 4-
 4). The upper four bits in TCON (TCON.4—TCON.7) are used to turn the timers on and 
 off (TR0, TR1), or to signal a timer overflow (TF0, TF1). These bits are used extensively 
 in the examples in this chapter.
  
 TABLE 4-2 
  
 TMOD (timer mode) register summary",NA
4.4,"TIMER MODES AND THE OVERFLOW FLAG
  
 Each timer is discussed below. Since there are two timers on the 8051, the notation ""x"" is
  
 used to imply either Timer 0 or Timer 1; thus, ""THx"" means either TH1 or TH0,
  
 depending on the timer.
  
 The arrangement of timer registers TLx and THx and the timer overflow flags TFx
  
 is shown in Figure 4-2 for each mode.
  
 TABLE 4-4
  
 TCON (timer control) register summary",NA
4.5,"CLOCKING SOURCES
  
 Figure 4-2 does not show how the timers are clocked. There are two possible clock 
 sources, selected by writing to the counter/timer (C/ T ) bit in TMOD when the timer is 
 initialized. One clocking source is used for interval timing, the other for event counting.
  
 4.5.1 Interval Timing
  
 If C/ T = 0, continuous timer operation is selected and the timer is clocked from the on-
 chip oscillator. A divide-by-12 stage is added to reduce the clocking frequency to a value 
 reasonable for most applications.",NA
4.6,"STARTING, STOPPING, AND CONTROLLING THE TIMERS
  
 Figure 4-2 illustrates the various configurations for the timer registers, TLx and THx, and 
 the timer overflow flags, TFx. The two possibilities for clocking the timers are shown in 
 Figure 4-3. We now demonstrate how to start, stop, and control the timers.
  
 The simplest method for starting and stopping the timers is with the run-control bit, 
 TRx, in TCON. TRx is clear after a system reset; thus, the timers are disabled (stopped) by 
 default. TRx is set by software to start the timers. (See Figure 4-4.)",NA
4.11,"BAUD RATE GENERATION
  
 Another use of the timers is to provide the baud rate clock for the on-chip serial port. This 
 comes by way of Timer 1 on the 8051 IC or Timer 1 and/or Timer 2 on the 8052 IC. Baud 
 rate generation is discussed in Chapter 5.",NA
Serial Port Operation,NA,NA
5.1,NA,NA
 INTRODUCTION,"The 8051 includes an on-chip serial port that can operate in several modes over a wide 
 range of frequencies. The essential function of the serial port is to perform parallel-to-
 serial conversion for output data, and serial-to-parallel conversion for input data.
  
 Hardware access to the serial port is through the TXD and RXD pins introduced in 
 Chapter 2. These pins are the alternate functions for two Port 3 bits, P3.1 on pin 11 
 (TXD), and P3.0 on pin 10 (RXD).
  
 The serial port features
  full duplex
  operation (simultaneous transmission and recep-
 tion) and
  receive buffering,
  allowing one character to be received and held in a buffer 
 while a second character is received. If the CPU reads the first character before the second 
 is fully received, data are not lost.
  
  
 The serial port frequency of operation, or
  baud rate,
  can be fixed (derived from the 
 8051 on-chip oscillator) or variable. If a variable baud rate is used, Timer 1 supplies the 
 baud rate clock and must be programmed accordingly. (On the 8032/8052, Timer 2 can be 
 programmed to supply the baud rate clock.) 
  
  
 Two special function registers, the serial port buffer register (SBUF) and the serial 
 port control register (SCON), provide software access to the serial port.",NA
5.2,NA,NA
 SERIAL COMMUNICATION,"Before we move on to discuss the operation of the 8051 serial port, we first touch on some 
 basic concepts of serial communication. Serial communication involves the transmission 
 of bits of data through only one communication line. The data are transmitted bit by bit in 
 either synchronous or asynchronous format.
  Synchronous
  serial communication transmits 
 one whole block of characters in synchronization with a reference clock while
  
 asynchronous",NA
5.3,"SERIAL PORT BUFFER REGISTER (SBUF)
  
 The serial port buffer register (SBUF) at address 99H is really two buffers. Writing to SBUF 
 loads data to be transmitted, and reading SBUF accesses received data. These are two 
 separate and distinct registers, the transmit write-only register, and the receive read-only 
 register. (See Figure 5-1.) 
  
  
 Notice in Figure 5-1 that a serial-to-parallel shift register is used to clock in the 
 received data before it is transferred to the receive read-only register. This shift register is 
 the key element in providing receive buffering. Only when all 8 bits of the incoming data 
 are received will they be transferred to the receive read-only register. This ensures that 
 while the incoming data are being received, the previous received data are still intact in the 
 receive read-only register.
  
  
 FIGURE 5-1
  
 Serial port block diagram",NA
5.4,"SERIAL PORT CONTROL REGISTER (SCON)
  
 The serial port control register (SCON) at address 98H is a bit-addressable register contain-
 ing status bits and control bits. Status bits indicate the end of a character transmission or 
 reception and are tested in software or programmed to cause an interrupt. Meanwhile, writ-
 ing to the control bits would set the operating mode for the 8051 serial port. (See Table 5-1 
 and Table 5-2.) 
  
  
 Before using the serial port, SCON is initialized for the correct mode, and so on.
  
 For example, the following instruction
  
 MOV 
  
 SCON,#01010010B
  
 initializes the serial port for mode 1 (SM0/SM1 = 0/1), enables the receiver (REN = 1), and 
 sets the transmit interrupt flag (T1 = 1) to indicate the transmitter is ready for operation.",NA
5.5,"MODES OF OPERATION
  
 The 8051 serial port has four modes of operation, selectable by writing 1s or 0s into the 
 SM0 and SM1 bits in SCON. Three of the modes enable asynchronous communications, 
 with each character received or transmitted framed by a start bit and a stop bit. Readers fa-
 miliar with the operation of a typical RS232C serial port on a microcomputer will find 
 these modes familiar territory. In the fourth mode, the serial port operates as a simple shift 
 register. Each mode is summarized below.
  
 5.5.1 8-Bit Shift Register (Mode 0)
  
 Mode 0, selected by writing 0s into bits SM1 and SM0 of SCON, puts the serial port into 
 8-bit shift register mode. Serial data enter and exit through RXD, and TXD outputs the 
 shift clock. Eight bits are transmitted or received with the least-significant (LSB) first.
  
 TABLE 5-1
  
 SCON (serial port control) register summary",NA
5.6,"FULL DUPLEX SERIAL COMMUNICATION: ISSUES
  
 The 8051's serial port allows for full duplex operation, which means that both transmission 
 and reception of characters can be done simultaneously. However, there are some issues 
 involved.
  
 The first issue involves the physical connections. Full duplex communication must 
 use two separate lines, one for transmission and one for reception, otherwise the signals 
 from both parties would collide. In mode 0 of the serial port operation, only one line, the 
 RXD, is used for both transmission and reception, hence full duplex cannot be achieved in 
 this mode. In fact, as has been previously discussed in the section on the serial port modes 
 of operation, mode 0 provides only half duplex operation. Meanwhile, all the other three 
 modes use two separate lines, TXD and RXD for transmission and reception respectively, 
 hence they allow for full duplex operation.
  
 Secondly, the timing and synchronization must be considered. A common question asked 
 by the student when told that the serial port can operate in full duplex is: ""Suppose the 
 serial port is transmitting a character to a serial device, so both the 8051 and the serial 
 device are in synchronization. What would happen when in the midst of this, 
   
 an 
 incoming character is detected on the RXD line?"" 
  
 This poses an 
 interesting question. 
  
  
  
 For an answer to this, there is a need to understand the internal",NA
5.7,"INITIALIZATION AND ACCESSING SERIAL PORT REGISTERS
  
 5.7.1 Receiver Enable
  
 The receiver enable bit (REN) in SCON must be set by software to enable the reception of 
 characters. This is usually done at the beginning of a program when the serial port, timers, 
 etc., are initialized. This can be done in two ways. The instruction
  
 SETB REN
  
 explicitly sets REN, or the instruction
  
 MOV SCON,#xxx1xxxxB
  
 sets REN and sets or clears the other bits in SCON, as required. (The x's must be 1s or 0s to 
 set the mode of operation.)
  
 5.7.2 The Ninth Data Bit
  
 The ninth data bit transmitted in modes 2 and 3 must be loaded into TB8 by software. The 
 ninth data bit received is placed in RB8. Software may or may not require a ninth data bit, 
 depending on the specifications of the serial device with which communications are 
 established. (The ninth data bit also plays an important role in multiprocessor 
 communications. See below.)
  
 5.7.3 Adding a Parity Bit
  
 A common use for the ninth data bit is to add parity to a character. As discussed in Chapter 
 2, the P bit in the program status word (PSW) is set or cleared every machine cycle to es-
 tablish even parity with the eight bits in the accumulator. If, for example, communications 
 require eight data bits plus even parity, the following instructions could be used to transmit 
 the eight bits in the accumulator with even parity added in the ninth bit:
  
 MOV C,P 
  
 MOV TBS,C 
  
 MOV SBUF,A
  
 ; PUT EVEN PARITY BIT IN TBS ; 
 THIS BECOMES THE 9TH DATA BIT ; 
 MOVE S BITS FROM ACC TO SBUF",NA
5.8,"MULTIPROCESSOR COMMUNICATIONS
  
 Modes 2 and 3 have a special provision for multiprocessor communications. In these 
 modes, nine data bits are received and the ninth bit goes into RB8. 
  
 The port can be 
 programmed so",NA
5.9,"SERIAL PORT BAUD RATES
  
 As evident in Table 5-2, the baud rate is fixed in modes 0 and 3. In mode 0 it is always the 
 on-chip oscillator frequency divided by 12. Usually a crystal drives the 8051's on-chip 
 oscillator, but another clock source can be used as well. (See Chapter 2.) Assuming a 
 nominal oscillator frequency of 12 MHz, the mode 0 baud rate is 1 MHz. (See Figure 5-8a.) 
  
 By default following a system reset, the mode 2 baud rate is the oscillator frequency 
 divided by 64. The baud rate is also affected by a bit in the power control register, PCON.",NA
Interrupts,NA,NA
6.1,"INTRODUCTION
  
 An
  interrupt
  is the occurrence of a condition—an event—that causes a temporary 
 suspen-sion of a program while the condition is serviced by another program. Interrupts 
 play an important role in the design and implementation of microcontroller applications. 
 They allow a system to respond asynchronously to an event and deal with the event while 
 another program is executing. An
  interrupt-driven system
  gives the illusion of doing 
 many things simultaneously. Of course, the CPU cannot execute more than one 
 instruction at a time; but it can temporarily suspend execution of one program, execute 
 another, then return to the first program. In a way, this is like a subroutine. The CPU 
 executes another program—the subroutine—and then returns to the original program. The 
 difference is that in an interrupt-driven system, the interruption is a response to an ""event"" 
 that occurs asynchronously with the main program. It is not known when the main 
 program will be interrupted.
  
 The program that deals with an interrupt is called an
  interrupt service routine 
 (ISR) 
 or
  interrupt handler.
  The ISR executes in response to the interrupt and generally 
 performs an input or output operation to a device. When an interrupt occurs, the main 
 program tem-porarily suspends execution and branches to the ISR; the ISR executes, 
 performs the opera-tion, and terminates with a ""return from interrupt"" instruction; the 
 main program continues where it left off. It is common to refer to the main program as 
 executing at
  base-level and 
 the ISRs as executing at
  interrupt-level.
  The terms
  
 foreground
  (base-level) and
  back-ground
  (interrupt-level) are also used. This brief view 
 of interrupts is depicted in Figure 6-1, showing (a) the execution of a program without 
 interrupts and (b) execution at base-level with occasional interrupts and ISRs executing at 
 interrupt-level.
  
 A typical example of interrupts is manual input, using a keyboard. Consider an 
 appli-cation for a microwave oven. The main program (foreground) might control a 
 microwave power element for cooking; yet, during cooking, the system must respond to 
 manual input",NA
6.2,"8051 INTERRUPT ORGANIZATION
  
 There are five interrupt sources on the 8051: two external interrupts, two timer interrupts, 
 and a serial port interrupt. The 8052 adds a sixth interrupt source from the extra timer. All 
 interrupts are disabled after a system reset and are enabled individually by software.
  
 In the event of two or more simultaneous interrupts or an interrupt occurring while 
 another interrupt is being serviced, there is both a polling sequence and a two-level 
 priority scheme to schedule the interrupts. The polling sequence is fixed but the interrupt 
 priority is programmable.
  
 Let's begin by examining ways to enable and disable interrupts.
  
 6.2.1 Enabling and Disabling Interrupts",NA
6.3,"PROCESSING INTERRUPTS
  
 When an interrupt occurs and is accepted by the CPU, the main program is interrupted. 
 The following actions occur:
  
 •
  The current instruction completes execution.
  
 •
  The PC is saved on the stack.
  
 •
  The current interrupt status is saved internally.
  
 •
  Interrupts are blocked at the level of the interrupt.
 •
  
 The PC is loaded with the vector address of the ISR.
 •
  
 The ISR executes.
  
 The ISR executes and takes action in response to the interrupt. The ISR finishes 
 with a RETI (return from interrupt) instruction. This retrieves the old value of the PC from 
 the stack and restores the old interrupt status. Execution of the main program continues 
 where it left off.
  
 6.3.1 Interrupt Vectors
  
 When an interrupt is accepted, the value loaded into the PC is called the
  interrupt vector. 
 It is the address of the start of the ISR for the interrupting source. The interrupt vectors are 
 given in Table 6-4.
  
 The system reset vector (RST at address 0000H) is included in this table, since, in this 
 sense, it is like an interrupt: it interrupts the main program and loads the PC with a new 
 value.
  
 When ""vectoring to an interrupt,"" the flag that caused the interrupt is automatically 
 cleared by hardware. The exceptions are RI and TI for serial port interrupts, and TF2 and 
 EXF2 for Timer 2 interrupts. Since there are two possible sources for each of these inter-
 rupts, it is not practical for the CPU to clear the interrupt flag. These bits must be tested in 
 the ISR to determine the source of the interrupt, and then the interrupting flag is cleared by 
 software. Usually a branch occurs to the appropriate action, depending on the source of 
 the interrupt.
  
 Since the interrupt vectors are at the bottom of code memory, the first instruction of the 
 main program is often a jump above this area of memory, such as LJMP 0030H.
  
 TABLE 6-4 
  
 Interrupt vectors
  
 Interrupt
  
 Flag
  
 Vector Address
  
 System reset 
 External 0 
  
 Timer 0
  
 RST 
  
 IE0 
  
 TF0 
  
 IE1 
  
 TF0
  
 0000H 
  
 0003H
  
 000BH 
  
 0013H
  
 External 1 
  
 Timer 1 
  
 Serial port 
  
 Timer 2
  
 001BH 
  
 0023H
  
 RI or TI
  
 TF2 or EXF2
  
 002BH",NA
6.4,"PROGRAM DESIGN USING INTERRUPTS
  
 The examples in Chapter 3 and Chapter 4 did not use interrupts but made extensive use of 
 ""wait loops"" to test the timer overflow flags (TF0, TF1, or TF2) or the serial port transmit 
 and receive flags (TI or RI). The problem in this approach is that the CPU's valuable ex-
 ecution time is fully consumed waiting for flags to be set. This is inappropriate for control-
 oriented applications where a microcontroller must interact with many input and output 
 devices simultaneously.
  
 In this section, examples are developed to demonstrate practical methods for imple-
 menting software for control-oriented applications. The key ingredient is the interrupt. Al-
 though the examples are not necessarily bigger, they are more complex, and in recognition 
 of this, we proceed one step at a time. The reader is advised to follow the examples slowly 
 and to examine the software meticulously. Some of the most difficult bugs in system 
 designs often involve interrupts. The details must be understood thoroughly.
  
 Since we are using interrupts, the examples will be complete and self-contained. Each 
 program starts at address 0000H with the assumption that it begins execution following a 
 system reset. The idea is that eventually these programs develop into full-fledged applica-
 tions that reside in ROM or EPROM.
  
 The suggested framework for a self-contained program using interrupts is shown 
 below.
  
  
 The first instruction jumps to address 0030H, just above the vector locations where 
 the ISRs begin, as given in Table 6-4. As shown in Figure 6-3, the main program begins at 
 address 0030H.
  
 6.4.1 Small Interrupt Service Routines
  
 Interrupt service routines must begin near the bottom of code memory at the addresses 
 shown in Table 6-4. Although there are only eight bytes between each interrupt entry 
 point, this is often enough memory to perform the desired operation and return from the 
 ISR to the main program.
  
 If only one interrupt source was used, say Timer 0, then the following framework could be 
 used:
  
 ORG 
  
 LJMP
  
 0000H 
 MAIN
  
 ;RESET
  
 ORG
  
 000BH
  
 ;Timer 0 ENTRY POINT",NA
6.5,"TIMER INTERRUPTS
  
 Timer interrupts occur when the timer overflow flag, TFx, is set upon overflow of the 
 timer registers, THx/TLx. When the 8051 goes to service this interrupt, the timer overflow 
 flag, TFx is automatically cleared by hardware. Therefore, with interrupts enabled, there is 
 no need to explicitly clear TFx in software as was done in Chapter 4 where timers were 
 used without interrupts.
  
  
 EXAMPLE 
 6.1
  
 Square Wave Using Timer Interrupts 
  
 Write a program using Timer 0 and interrupts to create a 10 kHz square wave on P1.0.
  
 Solution
  
  
 Discussion 
  
 With timer interrupts enabled, the event that generates the interrupt is the setting of the 
 timer flag, TFx, upon overflow of the timer registers, THx/TLx. This example appears in 
 Chapter 4 without using interrupts. The bulk of the program is the same except it is now 
 organized into the framework for interrupts.
  
  
 The solution is a complete program. It could be burned into EPROM and installed in 
 an 8051 single-board computer for execution. Immediately after reset, the program counter 
 is loaded with 0000H. The first instruction executed is LJMP MAIN, which branches over 
 the timer ISR to address 0030H in code memory. 
  
 The next three instructions (lines 11-13)",NA
6.6,"SERIAL PORT INTERRUPTS
  
 Serial port interrupts occur when either the transmit interrupt flag (TI) or the receive inter-
 rupt flag (RI) is set. A transmit interrupt occurs when transmission of the previous 
 character written to SBUF has finished. A receive interrupt occurs when a character has 
 been completely received and is waiting in SBUF to be read.
  
 Serial port interrupts are slightly different from timer interrupts. The flag that causes 
 a serial port interrupt is not cleared by hardware when the CPU vectors to the interrupt. 
 The reason is that there are two sources for a serial port interrupt, TI or RI. The source of 
 the interrupt must be determined in the ISR and the interrupting flag cleared by software. 
 Recall that with timer interrupts the interrupting flag is cleared by hardware when the 
 processor vectors to the ISR.
  
  
 EXAMPLE 
   
 Character Output Using Interrupts 
  
 6.3 
  
 Write a program using interrupts to continually transmit the ASCII code set (excluding 
  
 control codes) to a terminal attached to the 8051's serial port.
  
 Solution 
  
 There are 128 7-bit codes in the ASCII chart. (See Appendix F.) These consist of 95 
 graphic codes (20H to 7EH) and 33 control codes (00H to 1FH, and 7FH). The program 
 shown below is self-contained and executable from EPROM or ROM immediately after a 
 system reset.
  
  
 Discussion 
  
 After jumping to MAIN at code address 0030H, the first three instructions initialize Timer",NA
6.7,"EXTERNAL INTERRUPTS
  
 External interrupts occur as a result of a low-level or negative edge on the INT0 or INT1 
 pin on the 8051 IC. These are the alternate functions for Port 3 bits P3.2 (pin 12) and P3.3 
 (pin 13), respectively.
  
 The flags that actually generate these interrupts are bits IE0 and IE1 in TCON. 
 When an external interrupt is generated, the flag that generated it is cleared by hardware 
 when vectoring to the ISR only if the interrupt was transition-activated. If the interrupt 
 was level-activated, then the external requesting source controls the level of the request 
 flag, rather than the on-chip hardware.
  
 The choice of low-level-activated interrupts versus negative-edge-activated 
 interrupts is programmable through the IT0 and IT1 bits in TCON. For example, if IT1 = 
 0, external interrupt 1 is triggered by a detected low at the INT1 pin. If IT1 = 1, external 
 interrupt 1 is edge-triggered. In this mode, if successive samples of the INT1 pin show a 
 high in one cycle and a low in the next, the interrupt request flag IE1 in ICON is set. Flag 
 bit IE1 then requests the interrupt.
  
 Since the external interrupt pins are sampled once each machine cycle, an input 
 should be held for at least 12 oscillator periods to ensure proper sampling. If the external 
 interrupt is transition-activated, the external source must hold the request pin high for at 
 least one cycle and then hold it low for at least one more cycle to ensure the transition is 
 detected. IE0 and IE1 are automatically cleared when the CPU vectors to the interrupt.",NA
6.8,"INTERRUPT TIMINGS
  
 Interrupts are sampled and latched on S5P2 of each machine cycle. (See Figure 6-7.) They 
 are polled on the next machine cycle, and if an interrupt condition exists, it is accepted if 
 (a) no other interrupt of equal or higher priority is in progress, (b) the polling cycle is the 
 last cycle in an instruction, and (c) the current instruction is not a RETI or any access to 
 IE or IP. During the next two cycles, the processor pushes the PC on the stack and loads 
 the PC with the interrupt vector address. The ISR begins.
  
  
 The stipulation that the current instruction is not RETI ensures that at least one in-
 struction executes after each interrupt service routine. The timing is shown in Figure 6-8.
  
  
 FIGURE 6-8 
  
 Polling of 
 interrupts",NA
Assembly Language ,NA,NA
Programming,NA,NA
7.1,"INTRODUCTION
  
 This chapter introduces assembly language programming for the 8051 microcontroller. 
 Assembly language is a computer language lying between the extremes of machine 
 language and high-level language. Typical high-level languages like Pascal or C use 
 words and statements that are easily understood by humans, although still a long way 
 from ""natural"" language. Machine language is the binary language of computers. A 
 machine language pro-gram is a series of binary bytes representing instructions the 
 computer can execute.
  
 Assembly language replaces the binary codes of machine language with easy to re-
 member ""mnemonics"" that facilitate programming. For example, an addition instruction 
 in machine language might be represented by the code ""10110011."" It might be 
 represented in assembly language by the mnemonic ""ADD."" Programming with 
 mnemonics is obviously preferable to programming with binary codes.
  
 Of course, this is not the whole story. Instructions operate on data, and the location 
 of the data is specified by various ""addressing modes"" embedded in the binary code of the 
 machine language instruction. So, there may be several variations of the ADD instruction, 
 depending on what is added. The rules for specifying these variations are central to the 
 theme of assembly language programming.
  
 An assembly language program is not executable by a computer. Once written, the 
 program must undergo translation to machine language. In the example above, the 
 mnemonic ""ADD"" must be translated to the binary code ""10110011."" Depending on the 
 complexity of the programming environment, this translation may involve one or more 
 steps before an executable machine language program results. As a minimum, a program 
 called an ""assembler"" is required to translate the instruction mnemonics to machine 
 language binary codes. A further step may require a ""linker"" to combine portions of 
 programs from separate files and to set the address in memory at which the program may 
 execute. We begin with a few definitions.",NA
7.2,"ASSEMBLER OPERATION
  
 There are many assembler programs and other support programs available to facilitate the 
 development of applications for the 8051 microcontroller. Intel's original MCS-51
 TM 
 family assembler, ASM51
 TM
 , is no longer available commercially. However, it set the 
 standard to which the others are compared. In this chapter, we focus on assembly language 
 programming as undertaken using the most common features of ASM51. Although many 
 features are standardized, some may not be implemented in assemblers from other 
 companies.
  
 ASM51 is a powerful assembler with all the bells and whistles. It is available on 
 Intel development systems and on the IBM
  PC
  family of microcomputers. Since these 
 ""host"" computers contain a CPU chip other than the 8051, ASM51 is called a
  cross 
 assembler.
  An 8051 source program may be written on the host computer (using any text 
 editor) and may be assembled to an object file and listing file (using ASM51), but the 
 program may not be executed. Since the host system's CPU chip is not an 8051, it does not 
 understand the binary instructions in the object file. Execution on the host computer 
 requires either hardware e-mulation or software simulation of the target CPU. A third 
 possibility is to download the object program to an 8051-based target system for 
 execution. Hardware emulation, software simulation, downloading, and other 
 development techniques are discussed in Chapter 10.",NA
7.3,"ASSEMBLY LANGUAGE PROGRAM FORMAT
  
 Assembly language programs contain the following:
  
 •
  Machine instructions
  
 •
  Assembler directives
  
 •
  Assembler controls
  
 •
  Comments
  
 Machine instructions are the familiar mnemonics of executable instructions (e.g., 
 ANL). Assembler directives are instructions to the assembler program that define program 
 structure, symbols, data, constants, and so on (e.g., ORG). Assembler controls set assem-
 bler modes and direct assembly flow (e.g., $TITLE). Comments enhance the readability of 
 programs by explaining the purpose and operation of instruction sequences.
  
 Those lines containing machine instructions or assembler directives must be written 
 following specific rules understood by the assembler. Each line is divided into ""fields"" 
 separated by space or tab characters. The general format for each line is as follows:
  
 [label:] mnemonic [operand] [,operand] [.. .] [;comment]
  
 Only the mnemonic field is mandatory. Many assemblers require the label field, if present, 
 to begin on the left in column 1, and subsequent fields to be separated by space or tab 
 characters. With ASM51, the label field needn't begin in column 1 and the mnemonic field 
 needn't be on the same line as the label field. The operand field must, however, begin on 
 the same line as the mnemonic field. The fields are described below.",NA
7.4,"ASSEMBLE-TIME EXPRESSION EVALUATION
  
 Values and constants in the operand field may be expressed three ways: (a) explicitly 
 (e.g., 0EFH), (b) with a predefined symbol (e.g., ACC), or (c) with an expression (e.g., 2 
 + 3). The use of expressions provides a powerful technique for making assembly language 
 programs more readable and more flexible. When an expression is used, the assembler 
 calculates a value and inserts it into the instruction.
  
 All expression calculations are performed using 16-bit arithmetic; however, either 8 
 or 16 bits are inserted into the instruction as needed. For example, the following two in-
 structions are the same:
  
 MOV DPTR,#04FFH + 3 
 MOV DPTR,#0502H
  
 ;ENTIRE 16-BIT RESULT USED
  
 If the same expression is used in a ""MOV A,#data"" instruction, however, the error 
 message ""value will not fit in a byte"" is generated by ASM51. An overview of the rules 
 for evaluating expressions follows.
  
 7.4.1 Number Bases
  
 The base for numeric constants is indicated in the usual way for Intel microprocessors. 
 Constants must be followed with ""B"" for binary, ""0"" or ""Q"" for octal, ""D"" or nothing for 
 decimal, or ""H"" for hexadecimal. For example, the following instructions are the same:
  
 MOV A,#15 
  
 MOV A,#1111B 
  
 MOV A,#0FH 
  
 MOV A,#17Q 
  
 MOV A,#15D
  
 Note that a digit must be the first character for hexadecimal constants in order to differen-
 tiate them from labels (i.e., ""0A5H"" not ""A5H"").
  
 7.4.2 Character Strings
  
 Strings using one or two characters may be used as operands in expressions. The ASCII 
 codes are converted to the binary equivalent by the assembler. Character constants are 
 enclosed in single quotes 0. Some examples follow.
  
 CJNE A,#'Q',AGAIN 
 SUBB A,#'0'
  
 MOV DPTR,#'AB' 
  
 MOV DPTR,#4142H
  
 ;CONVERT ASCII DIGIT TO 
 ;BINARY DIGIT
  
 ;SAME AS ABOVE",NA
7.5,"ASSEMBLER DIRECTIVES
  
 Assembler directives are instructions to the assembler program. They are not assembly 
 language instructions executable by the target microprocessor. However, they are placed 
 in the mnemonic field of the program. With the exception of DB and DW, they have no 
 direct effect on the contents of memory.
  
 ASM51 provides several categories of directives:
  
 •
  Assembler state control (ORG, END, USING)
  
 •
  Symbol definition (SEGMENT, EQU, SET, DATA, IDATA, XDATA, BIT, 
 CODE)
 •
  Storage initialization/reservation (DS, DBIT, DB, DW)
  
 •
  Program linkage (PUBLIC, EXTRN, NAME)
  
 •
  Segment selection (RSEG, CSEG, DSEG, ISEG, ESEG, XSEG)
  
 Each assembler directive is presented below, ordered by category.
  
 7.5.1 Assembler State Control
  
 7.5.1.1 ORG (Set Origin)
  The format for the ORG (set origin) directive is
  
 ORG expression
  
 The ORG directive alters the location counter to set a new program origin for statements 
 that follow. A label is not permitted. Two examples follow.
  
 ORG 100H 
  
 ORG ($ + 1000H) AND 0F000H
  
 ;SET LOCATION COUNTER TO 100H 
 ;SET TO NEXT 4K BOUNDARY
  
 The ORG directive can be used in any segment type. If the current segment is absolute, 
 the value will be an absolute address in the current segment. If a relocatable segment is 
 active, the value of the ORG expression is treated as an offset from the base address of the 
 current instance of the segment.
  
 7.5.1.2 End
  The format for the END directive is
  
 END
  
 END should be the last statement in the source file. No label is permitted and nothing be-
 yond the END statement is processed by the assembler.
  
 7.5.1.3 Using
  The format for the USING directive is
  
 USING 
  
 expression
  
 This directive informs ASM51 of the currently active register bank. Subsequent uses of 
 the predefined symbolic register addresses AR0 to AR7 will convert to the appropriate 
 direct address for the active register bank. Consider the following sequence:
  
 USING 
  
 PUSH
  
 3 
  
 AR7",NA
7.6,"ASSEMBLER CONTROLS
  
 Assembler controls establish the format of the listing and object files by regulating the 
 actions of ASM51. For the most part, assembler controls affect the look of the listing file, 
 without having any effect on the program itself. They can be entered on the invocation line 
 when a program is assembled, or they can be placed in the source file. Assembler controls 
 appearing in the source file must be preceded with a dollar sign and must begin in column 
 1.
  
 There are two categories of assembler controls: primary and general. Primary 
 controls can be placed in the invocation line or at the beginning of the source program. 
 Only other primary controls may precede a primary control. General controls may be 
 placed anywhere in the source program. Figure 7-6 shows the assembler controls 
 supported by ASM51.",NA
7.7,"LINKER OPERATION
  
 In developing large application programs, it is common to divide tasks into subprograms 
 or modules containing sections of code (usually subroutines) that can be written separately 
 from the overall program. The term ""modular programming"" refers to this programming 
 strategy. Generally, modules are relocatable, meaning they are not intended for a specific 
 address in the code or data space. A linking and locating program is needed to combine 
 the modules into one absolute object module that can be executed.
  
 Intel's RL51 is a typical linker/locator. It processes a series of relocatable object 
 modules as input and creates an executable machine language program (PROGRAM, per-
 haps) and a listing file containing a memory map and symbol table (PROGRAM.M51). 
 This is illustrated in Figure 7-7.
  
 As relocatable modules are combined, all values for external symbols are resolved with 
 values inserted into the output file. The linker is invoked from the system prompt by
  
 RL51 input_list [TO output_list] [location_controls]
  
 The input_list is a list of relocatable object modules (files) separated by commas. 
 The output_list is the name of the output absolute object module. If none is supplied, it 
 defaults to the name of the first input file without any suffix. The location_controls set 
 start addresses for the named segments.
  
 For example, suppose three modules or files (MAIN.OBJ, MESSAGES.OBJ, and 
 SUBROUTINES.OBJ) are to be combined into an executable program (EXAMPLE), and 
 that these modules each contain two relocatable segments, one called EPROM of type",NA
7.8,"ANNOTATED EXAMPLE: LINKING 
  
 RELOCATABLE SEGMENTS AND MODULES
  
 Many of the concepts just introduced are now brought together in an annotated example of 
 a simple 8051 program. The source code is split over two files and uses symbols declared 
 as EXTRN or PUBLIC to allow interfile communication. Each file is a module—one 
 named MAIN, the other named SUBROUTINES. The program uses a relocatable code 
 segment named EPROM and a relocatable internal data segment named ONCHIP. 
 Working with multiple files, modules, and segments is essential for large programming 
 projects. A careful examination of the example that follows will strengthen these core 
 concepts and prepare the reader to embark on practical 8051-based designs.
  
  
 Our example is a simple input/output program using the 8051's serial port and a 
 VDT's keyboard and CRT display. The program does the following:
  
 •
  Initialize the serial port (once)
  
 •
  Output the prompt ""Enter a command:""",NA
7.9,"MACROS
  
 For the final topic in this chapter, we return to ASM51. The macro processing facility 
 (MPL) of ASM51 is a ""string replacement"" facility. Macros allow frequently used sections 
 of code to be defined once using a simple mnemonic and used anywhere in the program by",NA
8051 C Programming,NA,NA
8.1,"INTRODUCTION
  
 Throughout the earlier chapters, we have discussed how to communicate with the 8051 by 
 using the assembly language. In fact, there is another way by which we can talk to the 
 8051. This is called 8051 C language, an often-preferred choice when the complexity of a 
 program increases considerably. This chapter introduces the 8051 C language as an 
 alternative to the assembly language programming. The choice of which to use is entirely 
 up to you, the programmer. Factors that commonly influence such a decision are the 
 desired speed, code size, and ease of programming. Since the intent of this chapter is to 
 present the basics of programming the 8051 in C, we will assume that the reader is already 
 familiar with con-ventional C programming, as is often the case due to C's popularity and 
 widespread usage.",NA
8.2,"ADVANTAGES AND DISADVANTAGES OF 8051 C
  
 The advantages of programming the 8051 in C as compared to assembly are:
  
 •
  Offers all the benefits of high-level, structured programming languages such as C, 
  
 including the ease of writing subroutines, and others discussed in more detail in 
  
 Section 9.2
  
 •
  Often relieves the programmer of the hardware details that the compiler handles 
  
 on behalf of the programmer
  
 •
  Easier to write, especially for large and complex programs
  
 •
  Produces more readable program source codes
  
 Nevertheless, 8051 C, being very similar to the conventional C language, also suffers from 
 the following disadvantages:",NA
8.3,"8051 C COMPILERS
  
 We saw in Figure 8-1 that a compiler is needed to convert programs written in 8051 C 
 language into machine language, just as an assembler is needed in the case of programs 
 written in assembly language. A compiler basically acts just like an assembler, except that 
 it is more com-plex since the difference between C and machine language is far greater 
 than that between as-sembly and machine language. Hence the compiler faces a greater 
 task to bridge that difference.
  
  
 Currently, there exist various 8051 C compilers, which offer almost similar functions. 
 All our examples and programs have been compiled and tested with Keil's µVision 2 IDE",NA
8.4,"DATA TYPES
  
 8051 C is very much like the conventional C language, except that several extensions and 
 adaptations have been made to make it suitable for the 8051 programming environment. 
 The first concern for the 8051 C programmer is the data types. Recall that a data type is 
 something we use to store data. Readers will be familiar with the basic C data types such 
 as int, char, and float, which are used to create variables to store integers, characters, or 
 floating-points. In 8051 C, all the basic C data types are supported, plus a few additional 
 data types meant to be used specifically with the 8051.
  
 Table 8-1 gives a list of the common data types used in 8051 C. The ones in bold are 
 the specific 8051 extensions. The data type
  bit
  can be used to declare variables that reside 
 in the 8051's bit-addressable locations (namely byte locations 20H to 2FH or bit locations 
 00H to 7FH). Obviously, these bit variables can only store bit values of either 0 or 1. As 
 an example, the following C statement:
  
 bit flag = 0;
  
 declares a
  bit
  variable called flag and initializes it to 0.
  
 The data type
  sbit
  is
  somewhat similar to the
  bit
  data type, except that it is normally used 
 to declare 1-bit variables that reside in special function registers (SFRs). For example:
  
 sbit P = 0xD0;
  
 1
 Keil Software, Inc., 1501 10
 a
 ' Street, Suite 110, Plano, TX 75074. Website:
  http://www.keil.com",NA
8.5,"MEMORY TYPES AND MODELS
  
 The 8051 has various types of memory space, including internal and external code and 
 data memory. When declaring variables, it is hence reasonable to wonder in which type of 
 memory those variables would reside. For this purpose, several memory type specifiers are 
 available for use, as shown in Table 8-2.
  
 The first memory type specifier given in Table 8-2 is code. This is used to specify that a 
 variable is to reside in code memory, which has a range of up to 64 Kbytes. For example:
  
 char code errormsg [1 = ""An error occurred"" ;
  
 declares a char array called
  errormsg
  that resides in code memory.
  
 If you want to put a variable into data memory, then use either of the remaining five 
 data memory specifiers in Table 8-2. Though the choice rests on you, bear in mind that 
 each type of data memory affects the speed of access and the size of available data mem-
 ory. For instance, consider the following declarations:
  
 signed int 
  
 data num1; 
  
 bit 
  
 bdata numbit; 
  
 unsigned int xdata num2;
  
 The first statement creates a signed int variable
  num1
  that resides in
  internal data memory 
 (00H to 7FH). The next line declares a bit variable
  numbit
  that is to reside in the bit-
 addressable memory locations (byte addresses 20H to 2FH), also known as
  bdata
 . Finally, 
 the last line declares an unsigned int variable called
  num2
  that resides in external data 
 memory,
  xdata
 . Having a variable located in the directly addressable internal data memory 
 speeds up access considerably; hence, for programs that are time-critical, the variables 
 should be of type data. For the 8052 and other variants with internal data memory up to 
 256 bytes, the idata specifier may be used. Note however that this is slower than data since 
 it must use indirect addressing. Meanwhile, if you would rather have your variables reside 
 in external memory, you have the choice of declaring them as pdata or xdata. A variable 
 declared to be in
  pdata
  resides in the first 256 bytes (a page) of external memory, while if 
 more storage is required,
  xdata
  should be used, which allows for accessing up to 64 
 Kbytes of external data memory.
  
 What if when declaring a variable you forget to explicitly specify what type of mem-ory it 
 should reside in, or you wish that all variables are assigned a default memory type
  
 TABLE 8-2 
  
 Memory types used in 8051 C language
  
 Memory Type
  
 Description (Size)
  
 code 
  
 data 
  
 idata 
  
 bdata 
  
 xdata 
  
 pdata
  
 Code memory (64 Kbytes) 
  
 Directly addressable internal data memory (128 bytes) 
 Indirectly addressable internal data memory (256 bytes) 
 Bit-addressable internal data memory (16 bytes) 
  
 External data memory (64 Kbytes) 
  
 Paged external data memory (256 bytes)",NA
8.6,"ARRAYS
  
 Often, a group of variables used to store data of the same type need to be grouped together for better 
 readability. For example, the ASCII table for decimal digits would be as in Table 8-4. To store such 
 a table in an 8051 C program, an
  array
  could be used. An array is a group of variables of the same 
 data type, all of which could be accessed by using the name of the array along with an appropriate 
 index.
  
 The array to store the decimal ASCII table is:
  
  
 int table([0] = 
  
 {0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38, 0x39};
  
 TABLE 8-4 
  
 ASCII table for decimal digits
  
 Decimal Digit
  
 ASCII Code In Hex
  
 0
  
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
 30
 H 
  
 31
 H 
  
 32
 H 
  
 33
 H 
  
 34
 H 
  
 35
 H 
  
 36
 H 
  
 37
 H 
  
 38",NA
8.7,"STRUCTURES
  
 Sometimes it is also desired that variables of different data types but which are related to 
 each other in some way be grouped together. For example, the name, age, and date of birth 
 of a person would be stored in different types of variables, but all refer to the person's per-
 sonal details. In such a case, a
  structure
  can be declared. A structure is a group of related 
 variables that could be of different data types. Such a structure is declared by:
  
 struct person { 
  
 char name[10]; 
  
 int age; 
  
 long DOB; 
  
 };
  
 Once such a structure has been declared, it can be used like a data type specifier to create 
 structure variables that have the member's name, age, and DOB. For example:
  
 struct person grace = {""Grace"", 22, 01311980};
  
 would create a structure variable grace to store the name, age, and date of birth of a person 
 called Grace. Then in order to access the specific members within the per son structure 
 variable, use the variable name followed by the dot operator ( . ) and the member name. 
 Therefore,
  grace.name, grace.age, grace.DOB
  would refer to Grace's name, age, 
 and date of birth, respectively.",NA
8.8,"POINTERS
  
 When programming the 8051 in assembly, sometimes registers such as R0, R1, and DPTR 
 are used to store the addresses of some data in a certain memory location. When data is ac-
 cessed via these registers, indirect addressing is used. In this case, we say that R0, R1, or 
 DPTR are used to point to the data, so they are essentially pointers.
  
 Correspondingly in C, indirect access of data can be done through specially defined 
 pointer variables. Many students studying C shy away from pointers. In fact, pointers are 
 simply just special types of variables, but whereas normal variables are used to directly 
 store data, pointer variables are used to store the addresses of the data. Just bear in mind 
 that whether you use normal variables or pointer variables, you still get to access the data 
 in the end. It is just whether you go directly to where it is stored and get the data, as in the 
 case of normal variables, or first consult a directory to check the location of that data be-
 fore going there to get it, as in the case of pointer variables. Figure 8
 -
 3 contrasts between 
 how data is accessed via normal variables and via pointers.",NA
8.9,"FUNCTIONS
  
 In programming the 8051 in assembly, we learnt the advantages of using subroutines to 
 group together common and frequently used instructions. The same concept appears in 
 8051 C, but instead of calling them subroutines, we call them
  functions.
  As in 
 conventional C, a function must be declared and defined. A function definition includes a 
 list of the number and types of inputs, and the type of the output (return type), plus a 
 description of the internal contents, or what is to be done within that function.
  
 The format of typical function definition is as follows:
  
 return_type function_name(arguments) [memory] 
 [reentrant] [interrupt] [using]
  
 {
  
 •
  
 •
  
 }",NA
8.10,"SOME 8051 C EXAMPLES
  
 We have so far briefly covered the basic concepts of programming the 8051 in C. In this 
 section, we will look at various examples of how to write such programs. All the 8051 C 
 programs discussed henceforth have been compiled and tested on Keil's µV
 ision2,
  which 
 is an 8051 integrated development environment (IDE) that includes source code editing, 
 compiling, and debugging.
 3
  
 8.10.1 The First Program
  
 As is customary in any introductory course on high-level, structured proi,amming languages, 
 the first demonstrative example is a simple program that displays the message ""Hello World,""
  
 #include <REG51.H> 
  
 #include <stdio.h>
  
 /* SFR declarations */ 
  
 /* Declarations for I/O 
  
 functions(eg. printf) */
  
 main () 
  
 { 
  
 SCON = 0x52;
  
 TMOD = 0x20;
  
 /* serial port, mode 1 */ 
 /* timer 1, mode 2
  */
  
  
 3
 A free evaluation version is available at
  http://www.keil.com
 .",NA
Program Structure and Design,NA,NA
9.1,"INTRODUCTION
  
 What makes one program better than the next? Beyond simple views such as ""it works,"" 
 the answer to this question is complex and depends on many factors: maintenance require-
 ments, computer language, quality of documentation, development time, program length, 
 execution time, reliability, security, and so on. In this chapter we introduce the characteris-
 tics of good programs and some techniques for developing good programs. We begin with 
 an introduction to structured programming techniques.
  
  
 Structured programming
  is a technique for organizing and coding programs that 
 reduces complexity, improves clarity, and facilitates debugging and modifying. The idea of 
 properly structuring programs is emphasized in most programming tasks, and we advance 
 it here as well. The power of this approach can be appreciated by considering the following 
 statement: All programs may be written using only three structures. This seems too good to 
 be true, but it's not. ""Statements,"" ""loops,"" and ""choices"" form a complete set of structures, 
 and all programs can be realized using only these three structures. Program control is 
 passed through the structures without unconditional branches to other structures. Each 
 structure has one entry point and one exit point. Typically, a structured program contains a 
 hierarchy of subroutines, each with a single entry point and a single exit point.
 1 
  
  
 The purpose of this chapter is to introduce structured programming as applied to as-
 sembly language programming and 8051 C programming. This is especially useful in the 
 context of assembly language programming, since although high-level languages (such as 
 Pascal or C) 
  
 promote structured programming through their statements (WHILE, FOR, 
 etc.) and notational conventions (indentation), assembly language lacks such inherent pro-
 perties. Nevertheless, assembly language programming can benefit tremendously through
  
 1
 In high-level languages, programs are composed of functions or procedures.
  
 217",NA
9.2,"ADVANTAGES AND DISADVANTAGES 
  
 OF STRUCTURED PROGRAMMING
  
 The advantages of adopting a structured approach to programming are numerous. These 
 include the following:
  
 •
  The sequence of operations is simple to trace, thus facilitating debugging.
  
 •
  There are a finite number of structures with standardized terminology.
  
 •
  Structures lend themselves easily to building subroutines.
  
 •
  The set of structures is complete; that is, all programs can be written using three 
  
 structures.
  
 •
  Structures are self-documenting and, therefore, easy to read.
  
 •
  Structures are easy to describe in flowcharts, syntax diagrams, pseudo code, and so 
 on.
 •
  Structured programming results in increased programmer productivity—pro-
  
 grams can be written faster.",NA
9.3,"THE THREE STRUCTURES
  
 All programming problems can be solved using three structures:
  
 •
  Statements
  
 •
  Loops
  
 •
  Choice
  
 The completeness of the three structures seems unlikely; but, with the addition of
  
 nesting (structures within structures), it is easily demonstrated that any programming pro-
  
 blem can be solved using only three structures. Let's examine each in detail.
  
 9.3.1 Statements
  
 Statements provide the basic mechanism to do something. Possibilities include the simple
  
 assigning of a value to a variable, such as
  
 [count = 0]
  
 or a call to a subroutine, such as
  
 PRINT STRING(""Select Option:"")
  
 Anywhere 
  
 a 
  
 single statement 
  
 can 
  
 be 
  
 used, 
  
 a 
  
 group 
  
 o
 f statements, or a
  
 statement block,
  can be used. This is accomplished in pseudo code by enclosing the
  
 statements between the keywords BEGIN and END as follows:
  
 BEGIN
  
 [statement 1]
  
 [statement 2]
  
 [statement 3]
  
 END
  
 Note that the statements within the statement block are indented from the BEGIN and
  
 END keywords. This is an important feature of structured programming.
  
 9.3.2 The Loop Structure
  
 The second of the basic structures is the ""loop,"" used to repeatedly perform an operation.",NA
9.4,"PSEUDO CODE SYNTAX
  
 Since pseudo code is similar to a high-level language such as Pascal or C, it is worthwhile 
 defining it somewhat more formally, so that, for example, a pseudo code program can be 
 written by one programmer and converted to assembly language by another programmer.
  
 We should acknowledge too that pseudo code is not always the best approach for 
 de-signing programs. While it offers the advantage of easy construction on a word 
 processor (with subsequent modifications), it suffers from a disadvantage common to 
 other program-ming languages: pseudo code programs are written line-by-line, so parallel 
 operations are not immediately obvious. With flowcharts, on the other hand, parallel 
 operations can be placed physically adjacent to one another, thus improving the 
 conceptual model (see Figure 9-10).
  
  
 Before presenting a formal syntax, the following tips are offered to enhance the 
 power of solving programming problems, using pseudo code.
  
 •
  Use descriptive language for statements.
  
 •
  Avoid machine dependencies in statements.
  
 •
  Enclose conditions and statements in brackets: [ ].
  
 •
  Begin all subroutines with their names followed by a set of parentheses: 0. Pa-
 rameters passed to subroutines are entered (by name or by value) within the 
 parentheses.
  
 •
  End all subroutines with RETURN followed by parentheses. Return values are en-
 tered within the parentheses.
  
 Examples of subroutines:
  
 INCHAR () 
  
 [statement] 
 . . .
  
 RETURN (char)
  
 OUTCHR(char) 
 [statement]
  
 STRLEN(pointer
 ) [statement]
  
 . . 
  
 .
  
 RETURN ( )
  
 . 
  
 . 
  
 .
  
 RETURN(length)",NA
9.5,"ASSEMBLY LANGUAGE PROGRAMMING STYLE
  
 It is important to adopt a clear and consistent style in assembly language programming. This is 
 particularly important when one is working as part of a team, since individuals must be able to 
 read and understand each other's programs.
  
 The assembly language solutions to problems up to this point have been deliberately 
 sketchy. For larger programming tasks, however, a more critical approach is required. The 
 following tips are offered to help improve assembly language programming style.",NA
9.6,"8051 C PROGRAMMING STYLE
  
 When programming in 8051 C, it is even more necessary to be clear and consistent. This is
  
 because programmers usually write in C when their 8051 programs are large and complex,
  
 and involve several programmers working on it at the same time. The following should be
  
 noted when programming the 8051 in C.
  
 9.6.1 Comments
  
 In C, comments are enclosed in between the /* and */ symbols. For example, the com-
  
 mented ""Hello World"" program is given below:
  
 main ()
  
 {
  
 SCON = 0x52; 
  
 /* perial port, mode 1 */
  
 TMOD = 0x20; 
  
 /* timer 1, mode 2 */
  
 TH1 
  
 = -13; 
  
 /* reload count for 2400 baud */
  
 TR1 
  
 = 1; 
  
 /* start timer 1 */
  
 while (1) 
  
 /* repeat forever */
  
 {
  
 printf (""Hello World\n""); /* Dipplay ""Hello World"" */
  
 }
  
 }",NA
Tools and Techniques for ,NA,NA
Program Development,NA,NA
10.1,"INTRODUCTION
  
 In this chapter, the process of developing microcontroller- or microprocessor-based pro-
 ducts is described as it follows a series of steps and utilizes a variety of tools. In 
 progressing from concept to product, numerous steps are involved and numerous tools are 
 used. The most common steps and tools are presented as found in typical design scenarios 
 employing the 8051 microcontroller.
  
 Design is a highly creative activity, and in recognition of this we state at the outset 
 that substantial leeway is required for individuals or development teams. Such autonomy 
 may be difficult to achieve for very large or safety-critical projects, however. Admittedly, 
 in such environments the management of the process and the validation of the results must 
 satisfy a higher order. The present chapter addresses the development of relatively small-
 scale products, such as controllers for microwave ovens, automobile dashboards, 
 computer peripherals, electronic typewriters, or high-fidelity audio equipment.
  
 The steps required and the tools and techniques available are presented and elabo-
 rated on, and examples are given. Developing an understanding of the steps is important, 
 but strict adherence to their sequence is not advocated. It is felt that forcing the develop-
 ment process along ordered, isolated activities is usually overstressed and probably wrong. 
 Later in the chapter we will present an all-in-one development scenario, where the avail-
 able resources are known and called upon following the instinct of the designer. We begin 
 by examining the steps in the development cycle.",NA
10.2,"THE DEVELOPMENT CYCLE
  
 Proceeding from concept to product is usually shown in a flow diagram known as the 
 development cycle,
  similar to that shown in Figure 10-1. The reader may notice that
  
 247",NA
10.3,"INTEGRATION AND VERIFICATION
  
 The most difficult stage in the development cycle occurs when hardware meets software. 
 Some very subtle bugs that eluded simulation (if undertaken) emerge under real-time exe-
 cution. The problem is confounded by the need for a full complement of resources: hard-
 ware such as the PC development system, target system, power supply, cables, and test 
 equipment; and software such as the monitor program, operating system, terminal emula-
 tion program, and so on.
  
  
 We shall elaborate on the integration and verification step by first expanding the area 
 within the dotted line in Figure 10-1. (See Figure 10-2.) 
  
  
 Figure 10-2 shows utility programs and development tools within circles, user files 
 within squares, and ""execution environments"" within double-lined squares. The use of an 
 editor to create a source file is straightforward. The translation step (from Figure 10-1) is 
 shown in two stages. An assembler (e.g., ASM51) converts a source file to an object file, 
 and a linker/locator (e.g., RL51) combines one or more relocatable object files into a sin-
 gle absolute object file for execution in a target system or simulator. The assembler and 
 linker/locator also create listing files.
  
 The most common filename suffixes are shown in parentheses for each file type. Al-
 though any filename and suffix usually can be provided as an argument, assemblers vary 
 in their choice of default suffixes.
  
 If the program was written originally in a single file following an absolute format, 
 linking and locating are not necessary. In this case, the alternate path in Figure 10-2 shows 
 the assembler generating an absolute object file.
  
 It is also possible (although not emphasized in this book) that high-level languages, 
 such as C or PL/M, are used instead of, or in addition to, assembly language. Translation 
 re-quires a
  cross-compiler
  to generate the relocatable object modules for linking and 
 locating.
  
 A
  librarian
  may also participate, such as Intel's LIB51. Relocatable object modules 
 that are general-purpose and useful for many projects (most likely subroutines) may be 
 stored in ""libraries."" RL51 receives the library name as an argument and searches the li-
 brary for the code (subroutines) corresponding to previously declared external symbols 
 that have not been resolved at that point in linking/locating.
  
 10.3.1 Software Simulation
  
 Five execution environments are shown in Figure 10-2. Preliminary testing (see Figure 10-
 1) proceeds in the absence of the target system. This is shown in Figure 10-2 as software 
 sim-ulation. A
  simulator
  is a program that executes on the development system and 
 imitates the architecture of the target machine. An 8051 simulator, for example, would 
 contain a fictitious (or ""simulated"") register for each of the special function registers and",NA
10.4,"COMMANDS AND ENVIRONMENTS
  
 In this section the overall development environment is considered. We present the notion 
 that at any time the designer is working within an ""environment"" with commands doing 
 the work. The central environment is the operating system on the host system, which is 
 most likely MS-DOS running on a member of the PC family of microcomputers. As 
 suggested in Figure 10-4, some commands return to MS-DOS upon completion, while 
 others evoke a new environment.
  
 Invoking Commands.
  Commands are either
  resident
  (e.g., DIR) or
  transient
  (e.g., 
 FORMAT, DISKCOPY). A resident command is in memory at all times, ready for execu-
 tion (e.g.,
  DIR
 ). A transient command is an executable disk file that is loaded into 
 memory for execution (e.g., FORMAT).
  
 Application programs are similar to transient commands in that they exist as an exe-
 cutable disk file and are invoked from the MS-DOS prompt. However, there are still many 
 possibilities. Commands or applications may be invoked as part of a batch file, by a func-
 tion key, or from a menu-driven user interface acting as a front-end for MS-DOS.",NA
Design and Interface Examples,NA,NA
11.1,"INTRODUCTION
  
 Many of the 8051's hardware and software features are brought together in this chapter 
 through several design and interface examples. The first is an 8051 single-board 
 computer—the SBC-51—suitable for learning about the 8051 or developing 8051-based 
 products. The SBC-51 uses a substantial monitor program offering basic commands for 
 system operation and user interaction. The monitor program (MON51) is described in 
 detail in Appendix G.
  
 The interface examples are advanced in comparison to those presented in previous 
 chapters. Each example includes a hardware schematic, a statement of the design 
 objective, a software listing of a program that achieves the design objective, and a general 
 description of the operation of the hardware and software. The software listings are 
 extensively commented and should be consulted for specific details.",NA
11.2,"THE SBC-51
  
 Several companies offer 8051 single-board computers similar to that described in this 
 section. Surprisingly, the basic design of an 8051 single-board computer does not vary 
 substantially among the various products offered. Since many features are ""on-chip,"" 
 designing an 8051 single-board computer is straightforward. For the most part, only the 
 basic connections to external memory and the interface to a host computer are required.
  
 A monitor program in EPROM is also required. The most basic system 
 requirements, such as examining and changing memory locations or downloading 
 application programs from a host computer, are needed to get ""up and running."" The 
 SBC-51 described here works together with a simple monitor program to provide these 
 basic functions.",NA
11.3,"HEXADECIMAL KEYPAD INTERFACE
  
 Interfaces to keypads are common for microcontroller-based designs. Keypad input and 
 LED output are an economical choice for a user interface and are often adequate",NA
11.4,"INTERFACE TO MULTIPLE 7-SEGMENT LEDS
  
 An interface to a 7-segment LED display was presented in a problem at the end of Chapter 
 3. (See Figure 3-8.) Unfortunately, the interface used seven lines on Port 1, so it represents 
 a poor allocation of the 8051's on-chip resources. In this section, we",NA
11.5,"INTERFACE TO LIQUID CRYSTAL DISPLAYS (LCDS)
  
 The previous section saw the use of 7-segment LEDs for display purposes. The 7-segment 
 display is sufficient for displaying numbers and simple characters but some more complex 
 characters require the use of other alternatives such as the liquid crystal display (LCD). 
 One very popular application of LCDs is in scientific calculators. In this section, we will 
 show how to interface to a simple LCD consisting of two lines of 16 characters, each 
 character formed by a 5
  x
  7 dot matrix. Most LCDs are compatible with the de facto 
 Hitachi HD44780 standard. The connections between the 8051 and an HD44780-
 compatible LCD are straightforward and are shown in Figure 11-7.
  
 FIGURE 11-7 
  
 Interface to an LCD",NA
11.6,"LOUDSPEAKER INTERFACE
  
 Figure 11-9 shows an interface between an 8031 and a loudspeaker. Small loudspeakers, 
 such as those found in personal computers or children's toys, can be driven from a single
  
  
 FIGURE 11-9 
  
 Interface to a loudspeaker",NA
11.8,"INPUT/OUTPUT EXPANSION
  
 The 8051 has four input/output ports, Port 0 to Port 3. If external memory is used, then all 
 or part of Port 0 and Port 2 would be taken up as data and/or address lines, thereby 
 reducing the number of available I/O lines for general purpose I/O usage. In this section, 
 we will discuss two simple ways to increase the number of I/O lines. This is called 
 expanding the I/O.
  
 11.8.1 Using Shift Registers
  
 Our next example illustrates a simple way to increase the number of input lines on the 
 8051. Three port lines are used to interface to multiple (in this example, 2) 74HC165 
 parallel-in serial-out shift registers. (See Figure 11-15.) The additional inputs are sampled",NA
11.9,"RS232 (EIA-232) SERIAL INTERFACE
  
 We have learn that the 8051 consists of a built-in serial port for interfacing to serial I/O de-
 vices. In fact, we could also connect the 8051 to the serial port of a personal computer 
 (PC). The PC's serial port follows the RS232 or EIA-232 serial interface standard and for 
 this rea-son, a normal RS232 cable can be used to connect between a PC and the 8051. The 
 RS232 cable is terminated at both ends by a connector (called DB-25) with 25 pins. 
 However, since not all of these pins are used in most PC applications, there is also a 
 different connector ver-sion called the DB-9 with only nine more commonly used pins. 
 Whether it is DB-25 or DB-9, the three most important pins are the receive data (RXD), 
 transmit data (TXD), and ground (GND). The RS232 serial interface also allows for 
 handshaking, where in order to establish a communications channel, one device initiates 
 by sending the request to send (RTS) signal to another device and waits for the 
 corresponding clear to send (CTS) signal to be returned.
  
 Upon reception of CTS, the two devices can then communicate messages back and forth.
  
 When connecting the 8051 to the RS232 serial interface, one major concern is the 
 difference in voltage levels between them. The 8051 uses the TTL voltage levels where a 
 5V would indicate a high while a DV indicates a low. Meanwhile, for the RS232, a high is 
 defined as being +3V to +15V while a low is between -5V to -15V. Because of this 
 difference, connections between the 8051 and the RS232 have to be done through line 
 drivers. Line drivers basically function to convert between the two different voltage levels 
 so that a high or low as understood by the 8051 also means a high or low to the RS232 and 
 vice versa. Figure 11-19 shows how the 8051 is connected to the RS232 serial interface via 
 RS232 line drivers such as the 1488/1489.
  
 FIGURE 11-19 
  
 Interface to RS232",NA
11.13,"INTERFACE TO SENSORS
  
 In Chapter 6's section on external interrupts, an example was given on the furnace controller 
 that makes use of a simple temperature sensor. In this section, we will look at a more 
 complex temperature sensor, the DS1620 digital thermometer and thermostat, manufactured 
 by Maxim.
 2 
 The DS1620 is an 8-pin IC with three thermal alarm outputs, T
 HIGH
 , T
 LOW
 , and 
 T
 COM
 . T
 HIGH
  goes high if the measured temperature is greater than or equal to the user-
 defined high temperature, TH. On the other hand, T
 LOW
  goes high if the temperature is less 
 than or equal to the user-defined low temperature, TL. In contrast, T
 COM
  goes high when the 
 temperature exceeds TH and only returns low when the temperature is less than TL.
  
 To use the DS1620 along with the 8051, the DS1620 has to be configured for 3-wire 
 communications. This is so called due to the fact that the communication between them is 
 done through a group of three wires, namely the data input/output (DQ) pin, the clock input 
 (CLK/CONV) pin, and the reset input (RST) pin. Communication is initiated by setting the 
 RST, and as clock signals are sent to the DS1620 through the CLK pin, data would be 
 clocked in or out through the DQ pin, with the LSB sent first.
  
 Figure 11-28 shows the connections between the 8051 and the DS1620. Interacting with the 
 DS1620 requires the 8051 to issue commands (see Table 11-5) to it.
  
 FIGURE 11-28 
  
 Interface to DS1620
  
  
 TABLE 11-5 
  
 DS1620 command set
  
  
 2
 Maxim Integrated Products, Inc., 120 San Gabriel Drive, Sunnyvale, CA 94086.",NA
11.14,"INTERFACE TO RELAYS
  
 A relay is a switch whose contacts are opened or closed due to a magnetic field produced by 
 the application of electricity to it. In essence, relays can be thought of as magneto-
 mechanical
  
 FIGURE 11-30 
  
 Internal connections for G6RN",NA
11.15,"STEPPER MOTOR INTERFACE
  
 Various devices such as the dot-matrix printer and the floppy disk drive make use of a 
 special type of motor called the stepper motor. Unlike the conventional DC motor, a 
 stepper motor moves in precise increments or steps. This allows for it to be used in 
 applications that require exact positioning of mechanical parts.
  
 Let's briefly review the basic operation of a stepper motor. A stepper motor has a 
 moving part called the
  rotor
  that is typically made from permanent magnet material. This 
 rotor is surrounded by the
  stator,
  which is an electromagnet made up of two windings 
 around some conducting poles. This is shown in more detail in Figure 11-34.
  
 Notice that both the two windings have a center tap, COM, which is typically con-
 nected to +5V. Consider next one of these windings shown oriented vertically in Figure 
 11-34(a), with its two ends denoted by A and B. This vertical winding will be wound 
 round the up and down stator poles, as shown in Figure 11-34(b). The two ends A and B 
 will be alternatively energized, causing current to flow through either one of them and 
 hence turning the stator pole into an electromagnet to attract the rotor magnet in the 
 middle to move in the desired direction. Figure 11-34(b) also shows that the stator A has 
 been energized to attract the rotor magnet towards it in the indicated direction. In the 
 similar way, the horizontal windings' two ends, C and D, would be wound round the left 
 and right stator poles, and these will be alternately energized as well.
  
 A further illustration of the interaction between the rotor and the stator is given in 
 Figure 11-35. Suppose that stator A is first energized and hence becomes an electromagnet 
 to attract the rotor, as shown in Figure 11-35(a). Next, stator D is energized and attracts
  
  
 FIGURE 11-34
  
 Configuration of the stator windings of a stepper motor",NA
Design and Interface ,NA,NA
Examples in C,NA,NA
12.1,"INTRODUCTION
  
 In the previous chapter, several design and interface examples involving the 8051 were 
 presented, with the corresponding interface programs written in assembly language. This 
 chapter will tackle these interface problems by writing similar proof-of-concept programs 
 in 8051 C. This will give a clearer view on the difference and also the similarities between 
 the two languages that we use to interact with the 8051.",NA
12.2,"HEXADECIMAL KEYPAD INTERFACE
  
 Recall from the discussion of the previous chapter the hexadecimal keypad interface 
 where the design objective was to write a program to continually read hexadecimal 
 characters from the 4
  x
  4 keypad and echo the corresponding ASCII code to the console. 
 A similar 8051 C program is shown in Example 12.1.
  
 EXAMPLE 
 12.1
  
 Hexadecimal Keypad Interface 
  
 Rewrite in C language the software for the hexadecimal keypad interface in Figure 11-4.
  
 Solution
  
 #include <reg51.h> 
  
 #include <stdio.h>
  
 unsigned char R3, R5, R6, R7, tempA; 
  
 unsigned char bdata A; 
  
 /* represents ACC */ 
  
 sbit aMSB = A^7; 
  
 /* variable aMSB to refer to 
  
  
 A.7
  */
  
 319",NA
12.4,"INTERFACE TO LIQUID CRYSTAL DISPLAYS (LCDS)
  
 Section 11.5 presented an interface example involving an LCD. The program that was 
 written continually retrieved ASCII characters from internal RAM locations 30H-7FH and 
 displayed them on the LCD, 16 characters at a time. The same program, rewritten in C, is 
 shown in Example 12.3.
  
 EXAMPLE
  Interface to LCDs
  
 12.3 
 Rewrite in C language the software for the LCD interface in Figure 11
 -
 8.
  
 Solution
  
 #include 
 <reg51.h> 
  
 #include 
 <stdio.h>
  
 sbit PS = P3
 ^
 0; 
  
 sbit RW = P3^1; 
  
 sbit E 
  
 = P3^2; 
  
 sbit busy = P1^7; 
  
 unsigned char bdata 
 A; unsigned char * 
 ptr; 
  
 unsigned char count; 
  
 void INIT(void); 
  
 void NEW(void); 
  
 void DISP(void); 
  
 void WAIT(void); 
  
 void OUT(void);
  
 /* represents ACC */
  
 main( ) 
  
 { 
  
 INIT(); 
  
 /* initialize LCD */
  
 count = 16; 
  
 /* initialize character count 
 */ while(1) 
  
 { 
  
 for (ptr = 0x30; ptr < 0x80; ptr++, count--) 
  
 }",NA
12.5,"LOUDSPEAKER INTERFACE
  
 Recall that in Section 11.6 in the previous chapter, an interrupt-driven assembly language 
 program to continually play an A-major musical scale was presented. The following 
 Example 12.4 shows the corresponding program in C.
  
 EXAMPLE 
 12.4
  
 Loudspeaker Interface 
  
 Rewrite in C language the software for the loudspeaker interface in Figure 11-10.
  
 Solution
  
 #include <reg51.h> 
  
 #include <stdio.h>
  
 #define LENGTH 12
  
 sbit outbit = P1^7; 
  
 int reload;
  
 int code * PC; 
  
 int REPEAT = 5;
  
 int ncount, tcount;
  
 /* use this to temporarily store the
  
 reload */
  
 /* value for the current note 
  
 */
  
 /* PC points to the TABLE */
  
 /* reload value = -50000 causes 0.05
  
 sec per */
  
 /* timeout. Do 5 times, to get 5 x
  
 0.05 
  
 */
  
 /* 
 = 0.25 seconds per note 
  
 */
  
 /* note counter & timeout counter */",NA
12.7,"INPUT/OUTPUT EXPANSION
  
 In the previous chapter, two ways to expand the I/O were demonstrated in assembly lang-
 uage. The following two examples show how the same thing can be done in C. In par-
 ticular, Example 12.6 shows the method of I/O expansion by using shift registers, while 
 Example 12.7 shows how to expand the I/O by using the 8255.
  
 EXAMPLE 
 12.6
  
 Interface to Shift Registers 
  
 Rewrite in C language the software for the Shift Register interface in Figure 11-16.
  
 Solution
  
 #include <reg51.h>
  
 #define COUNT 2
  
 unsigned char bdata * R0;
  
 unsigned char R6, R7;
  
 unsigned char xdata * idata DPTR;
  
 unsigned char bdata A;
  
 sbit aMSB 
  
 = A^7;
  
 sbit aLSB 
  
 = A^0;
  
 sbit SHIFT = P1^7;
  
 sbit CLOCK = P1^6;
  
 sbit DOUT 
  
 = P1^5;
  
 bit C;
  
 bit PY;
  
 /*
  
 numher
  
 of
  
 shift
  
 registers
  
 */
  
 /* DPTR in data, points to xdata 
 */ /* represents ACC */
  
 /* SHIFT/LOAD input: 1 = 
 shift, 
  
 0 = load */ 
  
 /* CLOCK input */ 
  
 /* DATA OUT output */
  
 /* represents PARITY bit */
  
 char * BANNER = {""*** TEST 74HC165 INTERFACE ***\n""}; 
  
 unsigned char bdata BUFFER[COUNT]; /* buffer to store hytes read */ 
 void GET_BYTES(void); 
  
 void SEND_HELLO_MESSAGE(void); 
  
 void DISPLAY_RESULTS(void); 
  
 bit RRC_A(bit C); 
  
 void OUTSTR(void); 
  
 void OUTCHR(void); 
  
 void OUT2HEX(void); 
  
 void SWAP_A(void); 
  
 void PARITY(void); 
  
 void HTOA(void); 
  
 main() 
  
 { 
  
 CLOCK = 1; 
  
 /* set interface lines initially in
  
 */
  
 SHIFT = 1; 
  
 DOUT = 1
 ; 
  
 SEND_HELLO_MESSAGE(); 
 while(l) 
  
  
 { 
  
  
 GET_BYTES();
  
 /* ... case not already */ 
  
 /* DOUT must he set (input ) 
 */ /* banner message */ 
  
 /* loop forever */
  
 /* read shift registers */",NA
12.8,"RS232 (EIA-232) SERIAL INTERFACE
  
 Connecting the 8051 to a PC via the RS232 serial interface was discussed in Section 11.9. 
 The design example was to write a program to input decimal numbers from the PC and 
 then send the corresponding ASCII code back to the PC screen. The C program to do this 
 is given in Example 12.8.
  
 EXAMPLE
  
 Interface to RS232
  
 12.8
  
 Rewrite in C language the software for the RS232 interface in Figure 11
 -
 20.
  
 Solution 
  
 #include <reg5l.h> 
  
 #include <stdio.h>
  
 unsigned char bdata A;
  
 /* represents ACC */ 
  
 /* variable aMSB to refer to 
 A.7
  
 */
  
 sbit aMSB = 
 A^7; sbit RTS = 
 P1
 ^
 7;
  
 /* variable RTS to refer to 
 P1.7
  
 */",NA
12.9,"CENTRONICS PARALLEL INTERFACE
  
 Printers interact with computers via the parallel port, and the common standard used is 
 called the Centronics parallel interface. We demonstrated in the previous chapter a 
 program to check the status of the printer before continually sending a test message to it 
 for printing. Example 12.9 shows just how this can be done in C.",NA
12.10,"ANALOG OUTPUT
  
 Interfacing to an analog device often requires the use of ADCs and DACs. In Section 
 11.11, it was shown how to connect the 8051 to the MC1408L8 DAC to generate an 
 analog sine wave by using a lookup table. Here we will present the corresponding C 
 program.
  
 EXAMPL
 E 
 12.10
  
 Analog Output 
  
 Rewrite in C language the software for the DAC interface in Figure 11-25.
  
 Solution
  
 #include <reg51.h>
  
 #define MAX 1024
  
  
 /* truncated TABLE of 1024 entries */ 
 unsigned char TABLE[MAX] = {127, 128, 129, 130, 131, ...};
  
 int data STEP = 1; 
 unsigned char A; 
  
 int index = 0;
  
 main( ) 
  
 { 
  
 TMOD = 0x2; 
  
 TH0 = -100; 
  
 TR0 = 1;
  
 IE = 0x82; 
  
 while(1); 
  
 }
  
 /* can he initialized to any increment value */ 
 /* represents ACC */ 
  
 /* use to point to entries in TABLE */
  
 /* 8-bit, auto reload */ 
  
 /* 100 ms delay */ 
  
 /* start timer */
  
 /* enable timer 0 interrupt */ 
 /* main loop does nothing! */
  
 void T0ISR (void) interrupt 1
  
 {
  
 index = index + STEP; 
  
 /* add STEP to index */
  
 if ( index > MAX )
  
 index = 0; 
  
 /* if end of TAELE, back to beginning */
  
 A = TABLE[index]; 
  
 /* get entry */
  
 P1 = A; 
  
 /* send it */
  
 }
  
 Discussion
  
 The main program initializes the Timer 0, enables the corresponding Timer 0 interrupt, and
  
 then does nothing. The bulk of the program lies in the Timer 0 interrupt function which, 
 upon
  
 every occurrence of the interrupt, accesses an entry from
  TABLE[]
 , which is an array of 
 1024
  
 entries between 0 and 255 that correspond to the magnitudes of one period of a sine wave.
  
 (Notice that in the program above,
  TAELE[]
  is shown in truncated form.) When the end of",NA
12.11,NA,NA
 ANALOG INPUT,"Figure 11-27 demonstrated how an assembly language program is used to use an ADC to 
 read and convert the voltage at a trimpot's center tap into digital form so that the correspon-
 ding ASCII code can be output to the console. Given here is the program rewritten in C.
  
 EXAMPLE 
 12.11
  
 Analog Input 
  
 Rewrite in C language the software for the ADC interface in Figure 11
 -
 27.
  
 Solution
  
 #include <reg51.h> 
  
 #define PORTA 0x101
  
 int xdata * idata DPTR; 
 unsigned char bdata A; 
 sbit aMSB = A^7; 
  
 sbit aLSB = A^0; 
  
 sbit WRITE = P1
 ^
 0; 
  
 sbit INTR = P1^1; 
  
 bit PY;
  
 /* 8155 Port A */
  
 /* DPTR in idata, points to xdata 
 */ /* represents ACC */ 
  
 /* variable aMSE to refer to A.7 
 */ /* variable aLSE to refer to 
 A.0 */ /* ADC0804 WR line */ 
  
 /* ADC0804 INTR line */ 
  
 /* represents parity bit */
  
 char * BANNER = (""*** TEST ADC0804 
 ***\n""}; void OUTSTR(void); 
  
 void 0UTCHR(void); 
  
 void OUT2HEX(void); 
  
 void SWAP_A(void); 
  
 void PARITY(void); 
  
 void HTOA(void);
  
 main()
  
 { 
  
 DPTR = BANNER;
  
 OUTSTR();
  
 while (1)
  
 /* send message */
  
 }
  
 { 
  
 WRITE = 0; 
  
 WRITE = 1; 
  
 while (INTR == 
 1); DPTR = PORTA; 
  
 A = *DPTR; 
  
 OUT2HEX(); 
  
 }
  
 /* toggle WR line */
  
 /* wait for INTR = 0 */ 
  
 /* knit DPTR -> Port A */ 
 /* read ADC0804 data */ 
  
 /* send data to console 
 */",NA
12.12,"INTERFACE TO SENSORS
  
 In this section, we again discuss how the 8051 can interact with a typical sensor, the tem-
 perature sensor. Recall that in Chapter 11, we presented an assembly language program to 
 monitor the room temperature by using the DS1620 temperature sensor. When the room 
 temperature is higher than 23°C, the furnace is turned on and the alarm sounds. If the tem-
 perature falls below 17°C, the furnace is switched off and the alarm is switched off. We 
 show in Example 12.12 the corresponding C example to accomplish this.
  
 EXAMPLE Interface to DS1620
  
 12.12 
  
 Rewrite in C language the software for the sensor interface in Figure 11
 -
 29.
  
 Solution
  
 #include <reg5l.h>
  
 #include <stdio.h>
  
 unsigned char bdata A; 
 sbit aMSB = A^7; 
  
 sbit aLSB = A^0; 
  
 sbit DQ = P1^0; 
  
 sbit CLK = P1^1; 
  
 sbit RST = P1^2; 
  
 sbit THI = P1^3; 
  
 sbit TLO = P1^4; 
  
 sbit TC0M = P1^5; 
  
 sbit FURN = P1^6; 
  
 int i; 
  
 void SEND(void); 
  
 bit RRC_A(bit);
  
 /* represents ACC */ 
  
 /* variable aMSB to refer to A.7 
 */ /* variable aLSB to refer to 
 A.0 */",NA
12.13,"INTERFACE TO RELAYS
  
 In the last chapter, a very interesting application of relays was presented, that of a pedes-
  
 trian traffic light system. The 8051 electrically controlled the relay to switch between two
  
 states, either to turn on the RED traffic light and GREEN pedestrian light in order to allow
  
 pedestrians to cross the road, or to turn on the GREEN traffic light and RED pedestrian
  
 light. The program written in C to control all this is given in Example 12.13.
  
 EXAMPLE 
 12.13
  
 Interface to a Relay: Pedestrian Traffic Light System 
  
 Rewrite in C language the software for the relay interface in Figure 11-33.
  
 Solution
  
 #include <reg51.h>
  
 #include <stdio.h>
  
 sbit LEDs = P1^0;
  
 int thousand = 1000; /* 1000 X 10000 us = 10 secs */ 
 int count; /* to store the count values */
  
 void delay(void);
  
 main( )
  
 { 
  
 IE = 0x81;
  
 IT0 = 1;
  
 TMOD = 1;
  
 /* enable 
  
 INT0 */
  
 /* negative edge triggered */
  
 /* timer 0 in mode 1 */",NA
12.14,"STEPPER MOTOR INTERFACE
  
 The stepper motor finds interesting applications where precision-positioning of compo-
 nents is required. We saw in Chapter 11 an example assembly language program that 
 demonstrated how to initially rotate a stepper motor clockwise, and whenever a switch
  
 connected to external interrupt 0 (INT0) causes a high-to-low transition, the direction of
  
 rotation should be reversed. In this section, we present the equivalent C program.",NA
Example Student Projects,NA,NA
13.1,"INTRODUCTION
  
 Students are often eager to do work on microcontroller and other robot-based projects. 
 When assigned the task of constructing 8051-based projects, one often wonders in amaze-
 ment at the enthusiasm and keen interest shown by the students. The student reader has 
 also seen some design and interface problems in Chapters 11 and 12. As an extension of 
 that, we will attempt in this chapter to outline potential student projects that would help to 
 tie together all the concepts discussed in the earlier chapters of this book.
  
 We will start with one of the simplest such projects: an 8051-based home security 
 system. Other more advanced-level projects would include a simple elevator system, a 
 Tic-TacToe game, an 8051-based calculator, a micromouse, a soccer-playing robot, and a 
 smart card application.",NA
13.2,"HOME SECURITY SYSTEM
  
 One of the simplest projects to build up the design skills in the student is the 8051-based 
 home security system. This is basically a demonstration of how to interact with I/O 
 devices through the 8051's I/O ports.
  
 13.2.1 Project Description
  
 A sample project description for such a home security system could be:
  
 Design an 8051 microcontroller-based home security system that has 64 Kbyte external 
 code memory and 64 Kbyte external data memory. Assume you only have 8 K EPROMs 
 and 8 K RAMs available.
  
 353",NA
13.3,"ELEVATOR SYSTEM
  
 An elevator system is another interesting project that students could undertake. For sim-
 plicity, we will only consider a three-floor elevator system.
  
 13.3.1 Project Description
  
 The project description follows:
  
 Design an 8051-based elevator system that supports three floors, namely ground, first 
 floor, and second floor",NA
13.4,"TIC-TAC-TOE
  
 A more challenging project for students would be the development of games, and the 
 corre-sponding artificial intelligence (AI) that would allow the program to compete with 
 humans and with each other. One such project is the developing the Tic-Tac-Toe game 
 based on the 8051.",NA
13.5,"CALCULATOR
  
 Calculators are so common these days that we sometimes tend to take them for granted. As 
 a further exercise in 8051-based system design and interfacing, an 8051-based would be a 
 con-tenting project. Of course, to keep it simple, only the basic operations would be 
 considered.",NA
13.6,"MICROMOUSE
  
 When you connect the 8051 (the brain), some sensors (the eyes, ears, etc.), and some mo-
 tors (the hands and feet), you get a basic robot. One such robot is the
  micromouse,
  which 
 is the name for a robot that imitates a mouse and which tries to solve a maze. Solving a 
 maze requires that the micromouse start from one end and slowly learn, mostly by trial and 
 error as well as memorizing, the correct path to the other end of the maze. Once it has 
 found the correct path and reached the other end of the maze, it should be able to follow 
 this path the next time it is put in the maze. Micromouse contests are popular and held in 
 many areas around the world. In this section, we will consider a micromouse project.
  
 13.6.1 Project Description
  
 As usual, we describe details of the project:
  
 Design an 8051 microcontroller-based micromouse that should have the ability to move
  
 forward, turn left and right as well as make U-turns. It should be able to solve a maze as
  
 fast as possible and once solved, should store the correct path in its memory.
  
 13.6.2 System Specifications
  
 In order to move forward and make turns, the micromouse should have two motors 
 attached, respectively, to its left and right wheels. It should also be able to know if it has 
 reached a dead end, or if there is a wall on its left or right if it wanted to turn in that 
 direction. For that, it would need some sensors. Two infrared sensors would suffice. 
 Probably we could also include some LEDs to indicate what the micromouse is currently 
 supposed to do, that is whether it is going forward, turning left, right, or making a U-turn. 
 The micromouse would also need some large external memory for memorizing paths 
 previously traversed. There-fore, the components for the micromouse are:
  
 •
  1
  x
  8051 microcontroller
  
 •
  2
  x
  motors
  
 •
  2
  x
  infrared sensors
  
 •
  1
  x
  64Kbyte RAM
  
 •
  2
  x
  LEDs
  
 13.6.3 System Design
  
 The main part of the system design stage is to decide where to put the infrared sensors. 
 The infrared sensor is typically made of two parts arranged side by side: an infrared LED 
 to emit infrared light and an infrared detector (phototransistor) to detect the presence of 
 any infrared light. If a wall is in the way of the sensor, the infrared light emitted by the 
 infrared LED would be reflected and subsequently detected by the infrared detector. 
 Otherwise, if no wall is present, there would be no reflection and hence no infrared light 
 would be detected. This is how the micromouse would know if there are any walls in a 
 certain direction.",NA
13.7,"A SOCCER-PLAYING ROBOT
  
 The previous section discussed how an 8051 could be used as the brain for a mouse-like 
 robot, enabling it to find its way through a maze and hence solve it. In fact, the 8051 can 
 be used to control any robot, and is among the popular microcontrollers that are used by 
 robot enthusiasts as robot brains. Robot contests are held around the world, and are very 
 interesting sights indeed. Participating robots would be required to do all sorts of tasks 
 ranging from playing simple sports to more complicated tasks such as climbing stairs. In 
 this section, we will discuss how an 8051 is used to control a soccer-playing robot.
  
 13.7.1 Project Description
  
 Design an 8051 microcontroller-based robot to take part in a robo-soccer contest, lasting 
 10
  
 minutes. During each match, two robots playing as blue and red are put in a grey-carpeted
  
 arena with randomly placed blue and red balls of 15mm in diameter. A common goal is lo-
  
 cated at one end of the arena and is illuminated by bright lights. Each robot should detect 
 the
  
 presence of balls, sense the ball colors, and collect balls of its own color. However, it 
 should
  
 only store one ball at a time. Once it has collected a ball, it should search for the common
  
 goal and kick the ball into the goal.
  
 13.7.2 System Specifications
  
 Similar to the micromouse, the robot should have wheels attached to motors. It would 
 also need some light sensors (LED and phototransistor pairs) to detect the goal, and ball 
 colors, plus some contact sensors such as switches to detect walls or the opponent robot. 
 Since the robot is to stand alone, it should have nonvolatile memory. In this case, an 
 EPROM would be a good choice since this would allow the program to be overwritten at 
 will, which is often desirable. The required components are then:",NA
13.8,"A SMART CARD APPLICATION
  
 Microcontrollers are finding increasing usage in
  smart cards,
  which are cards that inte-
 grate both memory and a microcontroller within its physical limits. Imagine having a 
 computer so small that we can wrap it up with a piece of plastic that fits into our wallet: 
 That's a smart card. Smart cards are being used as national identity cards, driving licenses, 
 passport information, and electronic cash (e-cash). Since these smart cards contain 
 personal as well as sensitive financial information, and would be issued to the public, it is 
 vital that the information contained within it be protected from being accessed or 
 tampered with by unauthorized parties. The following subsection briefly describes basic 
 security concepts for a better understanding of how the information within smart cards 
 can be protected.",NA
8051 Derivatives,NA,NA
14.1,"INTRODUCTION
  
 Since the advent of the MCS-51
 TM
 family of microcontroller ICs, newer and more 
 advanced versions have sprung up. These
  8051 derivatives
  have additional memory, 
 built-in I/0 such as ADCs and DACs, and other extended peripherals. In this section, we 
 will briefly review some of these derivatives.",NA
14.2,"MCS-151TM AND MCS-251TM
  
 Intel has produced advanced versions of the MCS-51
 TM
 family. These are the MCS-
 151TM, with five times increased performance, followed by the MCS-251
 TM
 family with 
 15 times performance increase. The MCS-251
 TM
 family has an advanced architecture that 
 increases the efficiency for 8051 C language programming, an extended instruction set 
 that includes 16- and 32-bit arithmetic and logic instructions, plus increased memory size 
 options (see Table 14-1). Here,
  One-Time Programmable (OTP) ROM
  refers to 
 EPROM-like code memory but without the quartz glass window for erasing the contents. 
 This reduces the packaging cost but prevents the OTP ROM from being erased with 
 ultraviolet (UV) light; hence, it can only be programmed once. ROMless versions are also 
 available.",NA
14.3,"MICROCONTROLLERS WITH FLASH MEMORY 
 AND NVRAM
  
 In Chapter 2 we were introduced to the MCS-51
 TM
 with different types of on-chip code 
 memory ranging from the ROMless 8031, through to the 8051 with on-chip ROM, and 
 the 8751 with on-chip EPROM.",NA
14.4,"MICROCONTROLLERS WITH ADCS AND DACS
  
 One of the most common features of 8051 derivatives are the built-in analog-to-digital 
 con-verters (ADCs) and digital-to-analog converters (DACs) that reduce the need for 
 connecting to external ADCs and DACs when interfacing the 8051 to analog I/O devices. 
 An example of such an 8051 derivative is the SAB80C515A microcontroller 
 manufactured by Siemens, which has a built-in 10-bit ADC. More advanced variants are 
 the collection of 8051 deriva-tives from Atmel that also function as MP3 players, 
 including the AT89C51SND1C and AT89C51SND2C that even come with the recently 
 popular USB 1.1 interface to PCs.",NA
14.5,"HIGH-SPEED MICROCONTROLLERS
  
 The 8051 runs at 12 clocks per machine cycle. Certain high-speed derivatives such as the 
 MCS-151
 TM
 and MCS-251
 TM
 run at only two clocks per machine cycle, and hence are ca-
 pable of executing more instructions within a given amount of time.
  
 'Atmel Corporation, 2125 O'Nel Drive, San Jose, CA 95131 
  
 2
 Maxim Integrated Products, Inc. includes the Dallas Semiconductors",NA
14.6,"NETWORK MICROCONTROLLERS
  
 The network microcontrollers manufactured by Maxim support various network protocols 
 such as the Ethernet and Controller Area Network (CAN). Other network microcontrollers 
 such as the 83751 by Philips
 3
 support the Inter-Integrated Circuit (I
 2
 C) network interface 
 while the COM20051 by Standard Microsystems
 4
 supports the ARCNET token ring net-
 work protocol. Such network protocols allow several microcontrollers and other 
 processors to be connected as a network to share and exchange data. Atmel's ATWebSEG-
 32 is an 8051 derivative that supports internet connection (TCP/IP) and the Ethernet.",NA
14.7,"SECURE MICROCONTROLLERS
  
 In the previous chapter, we had a look at how the 8051 can be used as the brain in smart 
 cards. This included a discussion of how confidential information could be protected via 
 software encryption. In fact, encryption can be done by dedicated security hardware, and 
 several 8051 derivatives such as Maxim's secure 8051 microcontrollers have been pro-
 duced to achieve this.
  
 The security system in the smart card that allows encryption, digital signatures, and 
 message authentication to be performed is commonly called a
  public-key infrastructure 
 (PKI).
  This PKI is commonly embedded within secure microcontrollers and is supported 
 by hardware peripherals built into these microcontrollers, for instance Maxim's DS5240, 
 which has a Modulo Arithmetic Accelerator (MAA) to support modulo arithmetic 
 operations, used extensively in PKIs. Other secure microcontrollers such as Maxim's 
 DS5000 support hardware encryption of the programs loaded into its code memory. By 
 encrypting these programs, even if the smart card is tampered with and its programs 
 accessed without authorization, the attacker would not be able to understand the meaning 
 of the programs.
  
 SUMMARY
  
  
 In this chapter, we have described the many derivatives of the 8051. These enhanced ver-
 sions of the 8051 typically have better types of on-chip memory, larger memory size, 
 higher speed, and more built-in peripherals to support interactions with analog I/O devices, 
 network, and security applications.",NA
Quick Reference Chart,"MNEMONIC
  
 DESCRIPTION MNEMONIC
  
 DESCRIPTION
  
  
 Arithmetic Operations
  
 ADD 
  
 A,source
  
 ADD 
  
 A,#data
  
 ADDC 
  
 A,source
  
 ADDC 
  
 A,#data
  
 SUBB 
  
 A,source
  
 SUBB 
  
 data
  
 INC 
  
 A
  
 INC 
  
 source
  
 DEC 
  
 A
  
 DEC 
  
 source
  
 INC 
  
 DPTR
  
 add source to A
  
 XRL 
  
 XRL 
  
 XRL 
  
 CLR 
  
 CPL 
  
 RL 
  
 RLC 
  
 RR 
  
 RRC 
  
 SWAP
  
 A,#data 
  
 direct,A 
  
 direct,#dat
 a A 
  
 A 
  
 A 
  
 A 
  
 A 
  
 A 
  
 A
  
 clear A 
  
 complement 
 A rotate A left 
  
 (through C) 
  
 rotate A right 
  
 (through C) 
  
 swap nibbles
  
 add with carry
  
 subtract from 
 A with borrow 
  
 increment
  
 decrement
  
 increment DPTR
  
 MUL 
 DIV
  
 AB 
  
 AB
  
  
 multiply A & B 
 divide A by B
  
 LEGEND
   
 DA 
  
 A
  
 decimal adjust A
  
 Rn 
  
 direct 
  
 @Ri 
  
 source 
  
 dest 
  
 #data 
  
 #data 16 
 bit 
  
 rel 
  
 addr11 
  
 addr16
  
 register addressing using R0-R7 
 8-bit internal address (00H-
 0FFH) indirect addressing using 
 R0 or R1 any of [Rn,direct,@Ri] 
  
 any of [Rn,direct,@Ri] 
  
 8-bit constant included in inst.
  
 16-bit constant 
  
 8-bit direct address of bit 
  
 signed 8-bit offset 
  
 11-bit address in current 2k 
 page 16-bit address
  
 Logical Operations
  
 ANL 
  
 A,source
  
 ANL 
  
 A,#data
  
 ANL 
  
 dlrect,A
  
 ANL 
  
 direct,#data
  
 ORL 
  
 A,source
  
 ORL 
  
 A,#data
  
 ORL 
  
 direct,A
  
 ORL 
  
 direct,#data
  
 XRL 
  
 A,source
  
 logical AND
  
 logical OR
  
 logical XOR
  
 FIGURE A-1
  
 Quick reference chart
  
 381",NA
Opcode Map,383,NA
Instruction Definitions,NA,NA
1,"LEGEND
  
 Symbol
  
 Interpretation
  
 
  
 () 
  
 (( )) 
  
 rrr 
  
 dddddddd 
  
 aaaaaaaa 
  
 bbbbbbbb
  
 eeeeeeee
  
 is replaced by ...
  
 the contents of . . .
  
 the data pointed at by . . .
  
 one of eight registers; 000 = R0, 001 = R1, etc.
  
 data bits 
  
 address bits 
  
 address of a bit 
  
 indirect addressing using R0 (i = 0) or R1 (i = 1) 8-
 bit relative address
  
 ACALL addr11
  
 Function: 
  
 Description:
  
 Absolute Call
  
 ACALL unconditionally calls a subroutine located at the indicated address. 
 The instruction increments the PC twice to obtain the address of the 
 following instruction, then pushes the 16-bit result onto the stack (low-
 order byte first) and increments the stack pointer twice. The destination 
 address is obtained by successively concatenating the five high-order bits of 
 the incremented PC, opcode bits 7-5, and the second byte of the instruction.
  
 1
 Adapted from 8-Bit Embedded Controllers (270645). Santa Clara, CA: Intel Corporation, 1991, by permission
  
 of Intel Corporation.
  
 385",NA
"MOV A,Rn","Bytes: 
  
 1
  
 Cycles: 
  
 1
  
 Encoding: 
  
 11101ra
  
 Operation: 
  
 (A)
  
  (Rn)",NA
"MOV A,direct","Bytes: 
  
 2
  
 Cycles: 
  
 1
  
 Encoding: 
  
 11100101 aaaaaaaa
  
 Operation: 
  
 (A)
  
  (direct)
  
 Note:
  MOV A,ACC is not a valid instruction.",NA
"MOV A,@Ri","Bytes: 
  
 1
  
 Cycles: 
  
 1",NA
RETI,"Function: 
  
 Description:
  
 Example:
  
 Return from interrupt
  
 RETI pops the high- and low-order bytes of the PC successively from the 
 stack and restores the interrupt logic to accept additional interrupts at the 
 same priority level as the one just processed. The stack pointer is left 
 decremented by 2. No other registers are affected; the PSW is
  not
  
 automatically restored to its preinterrupt status. Program execution 
 continues at the resulting address, which is generally an instruction 
 immediately after the point at which the interrupt request is detected. If a 
 lower- or same-level interrupt is pending when the RETI instruction is 
 executed, then one instruction is executed before the pending interrupt is 
 processed.
  
 The stack pointer originally contains the value 0BH. An interrupt is 
 detected during the instruction ending at location 0123H. Internal RAM 
 locations 0AH and 0BH contain the values 23H and 01H, respectively. 
 The instruction,
  
 RETI
  
 leaves the stack pointer equal to 09H and returns program execution
  
 to location 0123H.
  
 Bytes: 
  
 1
  
 Cycles: 2
  
 Encoding: 00110010
  
 Operation: 
  
 (PC15-PC8)
  
  ((SP))",NA
Special Function Registers,NA,NA
1,"The 8051's special function registers are shown in the SFR memory map in Figure D-1. 
 Blank locations are reserved for future products and should not be written to. The SFRs 
 identified with an asterisk contain bits that are defined as mode or control bits. These reg-
 isters and their bit definitions are described on the following pages.
  
 Some bits are identified as ""not implemented."" User software should not write 1s to 
 these bits, since they may be used in future MCS51
 TM
 products to invoke new features. In 
 that case, the reset or inactive value of the new bit will be 0, and its active value will be 1.
  
 PCON (POWER CONTROL REGISTER)
  
 Symbol: 
  
 PCON
  
 Function: 
  
 Power control and miscellaneous features
  
 Bit Address: 
  
 87H
  
 Bit-Addressable: 
  
 No
  
 Summary:
  
 7
  
 6
  
 5
  
 4
  
 3
  
 S MOD
  
 -
  
 -
  
 -
  
 GF1
  
  
 2
  
 1
  
 0
  
 GF0
  
 PD
  
 IDL
  
  
 1
 Adapted from
  8-Bit Embedded Controllers
  (270645). Santa Clara, CA: Intel Corporation, 1991, by permission 
 OF intel corporation.
  
 431",NA
8051 Data Sheet ,NA,NA
1,"1
 Reprinted with permission of Intel Corporation from
  8-Bit Embeded Controllers
  (270645). Santa Clara, CA:
  
 Intel Corporation, 1991.
  
 439",NA
ASCII Code Chart,"FIGURE F-1
  
 ASC1I code chart
  
 455",NA
MON51—An 8051 Monitor ,NA,NA
Program,"This appendix contains the listing for an 8051 monitor program (MON51) along with a 
 general description of its design and operation. Many of the concepts in assembly lan-
 guage programming developed earlier in short examples (see Chapter 7) can be reinforced 
 by reviewing this appendix. The source and listing files for MON51 are contained on the 
 diskette accompanying this text.
  
 MON51 is a monitor program written for the 8051 microcontroller and, more speci-
 fically, for the SBC-51 single-board computer (see Chapter 11). We begin with a 
 description of the purpose of a monitor program and then give a summary of MON51 
 commands. The overall operation of MON51 and some design details are also described. 
 The final pages of this appendix contain listings of each assembled source file, the listing 
 created by RL51, and a dump of MON51 in Intel hexadecimal format.
  
 A monitor program is not an operating system. It is a small program with commands 
 that provide a primitive level of system operation and user interaction. The major 
 difference is that operating systems are found on larger computers with disk drives, while 
 monitor programs are found on small systems, such as the SBC-51, with a keyboard (or 
 keypad) for input and a CRT (or LEDs) for output. Some single-board computers also 
 provide mass storage using an audio cassette interface.
  
  
 MON51 is an 8051 assembly language program approximately two kilobytes in 
 length. It was written on an Intel iPDS100 development system using an editor (CREDIT), 
 a cross assembler (ASM51), and a linker/locator (RL51). Testing and debugging were per-
 formed using a hardware emulator (EMV51) connected to an Intel SDK-51TM single-
 board computer. It is worth mentioning that hardware emulators are such powerful tools 
 that the first version of MON51 burned into EPROM was essentially ""bug-free."" 
  
  
 MON51 was developed using modular programming techniques. Ten source files 
 were used, including nine program files and one macro definition file. To keep the listing 
 files rel-atively short for this appendix, the ""create symbol table"" option was switched off 
 in each",NA
"""IS"" ROUTINES",488,NA
A Guide to Keil's,NA,NA
µVISION2 IDE,"INTRODUCTION
  
 Keil's µVision2 Integrated Development Environment (IDE)
 1
 is software that allows the 
 8051 C programmer to edit, compile, run, and debug 8051 C programs. This appendix 
 presents a brief guide to using the µVision2 IDE.
  
 THE µVISION2 WORKSPACE
  
 When you double-click the µVision2 IDE, you will see a screen similar to the one shown 
 in Figure H-1. The main windows that appear are the Workspace, the Edit window, and the 
 Output window.
  
 The Workspace is a pane with three tabs that open different windows—Files, Regs, 
 and Books. The Files window (see Figure H-2) allows you to manage the source code files 
 that you want to include in your current project. Right-click the Simulator option and then 
 choose ""Select Device for Target 'Simulators"" to indicate the target 8051 or derivative 
 device for which you want to write a C program. To add a file to your project, simply 
 right-click the ""Source Group 1"" option and browse for the desired C file.
  
 If you prefer to create a new program, then select New from the File menu and start 
 key-ing the code for your program. When you have finished, save it as a C file and add it 
 to your project. In Figure H-2, you can see that the sole file included in the project is test.c. 
 Double-click a file name to open it and it will display in the Edit window, as shown in 
 Figure H-1.
  
 COMPILING AND DEBUGGING
  
 When you have finished editing your program, the next thing you want to do is compile it 
 to see if there are any compile errors. For this, you could select ""Build target"" from the 
 Project
  
 1
 An evaluation version is available for download at
  http://www.keil.com/demo/.",NA
A Guide to the 8052 ,NA,NA
Simulator,"INTRODUCTION
  
 The 8052 Simulator for Windows is software that simulates the entire operation of the 
 8051 or 8052 microcontroller, plus all its registers, internal RAM locations, I/O ports, 
 timers, serial ports, and interrupts. During the initial stages of developing an 8051
 —
 or 
 8052
 —
 based system, you can test the assembled or compiled program entirely in 
 software with the help of this simulator, without having to worry about the actual 
 hardware. This appendix provides a brief guide to using the 8052 Simulator.
  
 The 8052 Simulator
  
 The main window of the 8052 Simulator is as shown in Figure I-1. The first thing you 
 need to do is to load an already assembled or compiled program that has been saved in 
 Intel HEX format. Most 8051 assemblers and compilers have an option to save the 
 assembled or com-piled output in this format. Figure 1-2 shows how this is done by 
 selecting the ""Open Intel-Standard File"" from the File menu and then browsing for the 
 Intel HEX file.
  
 The loaded program is now ready to be tested. First, you can choose to view various 
 components of the 8051, such as the internal RAM, I/O ports, special function registers 
 (SFRs), and timers. Select each of these from the View menu, as shown in Figure 1-3.
  
 Figure 1-4 shows the Internal Memory (RAM) window that was selected from the 
 View menu. All the rows of the first column represent the addresses of 16 memory 
 locations, the contents of which are displayed in the 16 columns on the right. For example, 
 the first row consists of the internal memory locations 00H to 0FH, and as can be seen in 
 Figure 1-4, the content of each is 0. To modify any location, click it and then key the new 
 value in hexa-decimal form. Alternatively, you can choose to check (set) or leave 
 unchecked (clear) any of the 8 bits in that location.
  
 'By Vault Information Services, 8174 S. Holly PMB 272, Littleton, CO 80122, U.S.A. 
 E-mail: sim8052@vaultbbs.com.
  
 507",NA
The Advanced Encryption ,NA,NA
Standard,"INTRODUCTION
  
 As the 8051 is used more and more in smart cards, where the security of information is 
 almost always important, it is most often used to execute software or hardware 
 implementations of encryption methods. The current standard for encryption is the 
 Advanced Encryption Standard (AES), a recent and secure method that was officially 
 adopted in 2000 by the U.S. National Institute of Standards & Technology (NIST) for 
 encrypting confidential, nonclassified information in the United States. It is expected that 
 the AES will replace the Data Encryption Standard in ATM cards, smart cards, online 
 transactions, and other security-related applications. Therefore, the study of the 8051 
 would not be complete without a discussion of the AES. This appendix is intended to 
 acquaint the reader on how the AES works so that you will understand how the AES can 
 be implemented with the 8051.
  
 BLOCK ENCRYPTION
  
 These days, messages and information are digitally stored in files in the computer in terms 
 of bits of 1 s and 0s. These messages vary in size from a few bytes to a few hundred 
 megabytes. For that reason, current encryption methods specify a standard input block 
 size, typically 128 bits. A message that is to be encrypted first must be broken down into 
 blocks of 128 bits, and then each block is encrypted. The encrypted blocks are then 
 concatenated to form the encrypted message. See Figure J-1 for an illustration of this 
 process.
  
 HOW THE AES WORKS
  
 For the purpose of describing the AES, its designers represented the 128-bit input block as 
 a 4
  x
  4 array of bytes. An element of this array is denoted by a
 1
 , where i and j are the row 
 and column indices respectively, numbered from 0 to 3, as shown in Figure J-2.",NA
Sources of 8051,NA,NA
Development Products,"Allen Systems, 2151 Fairfax Road, Columbus, OH 43221
  
 Product: 
  
 FX-31 8052-BASIC SBC
  
 Description: 
  
 8052 single-board computer with built-in BASIC interpreter
  
 Product: 
  
 CA-51
  
 Description: 
  
 8051 cross assembler
  
 Host Computer: 
  
 IBM
  PC
  and compatibles
  
 Product: 
  
 DP-31/535
  
 Description: 
  
 Single-board computer based on Siemens 80535 CPU
  
 Applied Microsystems Corp., 5020 148th Ave. N. E., P.O. Box
  
 97002, Redmond, WA 98073-9702
  
 Product: 
  
 EC7000
  
 Description: 
  
 8051 microcontroller emulator
  
 Host Computer: 
  
 IBM
  PC
  and compatibles
  
 Aprotek, 1071-A Avenida Acaso, Camarillo, CA 93010
  
 Product: 
  
 Description: 
 Features:
  
 PA8751 
  
 8751 programming adapter 
  
 Adapts 8751 EPROM microcontrollers to any EPROM 
  
 programmer as a 2732
  
 521",NA
BOOKS,"8-bit Embedded Controllers (270645).
  Santa Clara, CA: Intel, 1991.
  
 Ayala, K. J.
  The 8051 Microcontroller: Architecture, Programming, and Applications. 
  
 New York: West, 1991.
  
 Barnett, R. H.
  The 8051 Family of Microcontrollers.
  New Jersey: Prentice Hall, 1995. 
 Boyet, H., and R. Katz.
  The 8051: Programming Interfacing Applications.
  New York: 
 MTI Publications, 1981.
  
 Cx51 Compiler: Optimizing C Compiler and Library Reference for Classic and 
 Extended 
  
 8051 Microcontrollers.
  Keil Software, 2001.
  
 Getting Started with µVision2 and the C51 Microcontroller Development Tools.
  Keil 
  
 Software, 2001.
  
 Mazidi, M. A., and J. G. Mazidi.
  The 8051 Microcontroller and Embedded Systems. 
  
 New Jersey: Prentice Hall, 2000.
  
 MCS-51 Macro Assembler User's Guide (9800937-03).
  Santa Clara, CA: Intel, 1983.
  
 Schultz, T. C and the 8051:
  Hardware, Modular Programming, and Multitasking. 
  
 New Jersey: Prentice Hall, 1998.
  
 Schneier, B.
  Applied Cryptography: Protocols, Algorithms, and Source Code in C. 
  
 New York: John Wiley & Sons, 1996.
  
 Stallings, W.
  Cryptography and Network Security: Principles and Practice. New Jersey: 
  
 Prentice Hall, 1999.
  
 Stewart, J. W., and K. X. Miao.
  The 8051 Microcontroller: Hardware, Software and 
  
 Interfacing.
  New Jersey: Prentice Hall, 1999.
  
 Yeralan, S., and A. Ahluwalia.
  Programming and Interfacing the 8051 Microcontroller. 
  
 Massachusetts: Prentice Hall, 1995.",NA
