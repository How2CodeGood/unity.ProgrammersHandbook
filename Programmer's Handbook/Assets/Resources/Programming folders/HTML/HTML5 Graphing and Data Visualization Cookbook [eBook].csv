Larger Text,Smaller Text,Symbol
HTML5 Graphing and ,NA,NA
Data Visualization ,NA,NA
Cookbook,NA,NA
Learn how to create interactive HTML5 charts and graphs ,NA,NA
"with canvas, JavaScript, and open source tools",NA,NA
Ben Fhala,BIRMINGHAM - MUMBAI,NA
HTML5 Graphing and Data ,NA,NA
Visualization Cookbook,"Copyright © 2012 Packt Publishing
  
 All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or 
 transmitted in any form or by any means, without the prior written permission of the 
 publisher, except in the case of brief quotations embedded in critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of the 
 information presented. However, the information contained in this book is sold without 
 warranty, either express or implied. Neither the author, nor Packt Publishing, and its dealers 
 and distributors will be held liable for any damages caused or alleged to be caused directly 
 or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the companies 
 and products mentioned in this book by the appropriate use of capitals. However, Packt 
 Publishing cannot guarantee the accuracy of this information.
  
 First published: November 2012
  
 Production Reference: 1161112
  
 Published by Packt Publishing Ltd. 
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham B3 2PB, UK.
  
 ISBN 978-1-84969-370-7
  
 www.packtpub.com
  
 Cover Image by Ben Fhala (
 anx007@gmail.com
 )",NA
Credits,"Author 
  
 Ben Fhala
  
 Reviewer 
  
 Chris Valleskey
  
 Acquisition Editor 
 Joanna Finchen
  
 Lead Technical Editor 
 Kedar Bhat
  
 Technical Editors 
 Prasad Dalvi 
  
 Joyslita D'souza 
 Ankita Meshram
  
 Copy Editors 
  
 Brandt D'Mello 
  
 Insiya Morbiwala 
  
 Aditya Nair 
  
 Alfida Paiva 
  
 Laxmi Subramanian
  
 Project Coordinator 
 Michelle Quadros
  
 Proofreader 
  
 Chris Smith
  
 Indexer 
  
 Hemangini Bari
  
 Graphics 
  
 Valentina Dsilva
  
 Production Coordinator 
 Nilesh R. Mohite
  
 Cover Work 
  
 Nilesh R. Mohite",NA
About the Author,"Ben Fhala
  discovered his passion for data visualization six years ago while he was 
 working at Parsons in New York, in their data visualization department PIIM. He is the 
 owner of the online video training school, 02geek.com, and an Adobe ACP. He enjoys 
 spending most of his time learning and teaching, and has a love for visual programming 
 and visualization in general.
  
 Ben has had the honor of developing applications for US Congress members, Prime Ministers, 
 and Presidents around the world. He has built many interactive experiences for companies 
 such as Target, AT&T, Crayola, Marriott, Neutrogena, and Nokia. He has technically directed 
 many award-winning projects and has been a part of teams that have won three Agency of the 
 Year awards.
  
 I want to thank my cats for supporting me mentally while I was closed 
 down and avoiding the world as I was trying to come up with good ideas for 
 the book. I can't thank my editors Joanna Finchen and Kedar Bhat enough 
 for the insight and help I got from them. For their kindness, support, and 
 mainly their patience with me when I was struggling to fit my ideas into the 
 recipe format. 
  
 A very big thanks to my technical reviewer, Chris Valleskey, for the 
 detailed insights and suggestions that made this book better and shaped 
 this book to be a really great one. 
  
 Thanks to Oren Ofer, which helped inspire the last recipe. To my students, 
 co-workers, and friends at 02geek.com. Mom, for helping me through the 
 creation of my first book. Nature and Earth for giving me a great place to 
 be in, and the ocean for the great view throughout the writing of this 
 book. Thanks to God for always opening up new doors to me in the most 
 unexpected ways. 
  
 And last but definitely not the least, thanks for buying / renting / lending 
 / reading this book.",NA
About the Reviewer,"Chris Valleskey
  is a young and creative thinker who currently lives in Chicago, Illinois. 
  
 He started freelancing at the age of 17 and continued this role throughout college until 
 graduating in 2011 with a Bachelor of Arts in Graphic Design and Philosophy. Although he 
 has a normal job in the city, he enjoys spending time with his close friends as a part owner in 
 their co-owned company. In his free time he enjoys playing Halo, drinking Mountain Dew, 
 and hanging out with his awesome wife.
  
 I would like to thank my wife Krista for putting up with me, and my 
 friends and family for supporting and encouraging me in everything I do.",NA
www.PacktPub.com,NA,NA
"Support files, eBooks, discount offers and more ","You might want 
 to visit 
 www.PacktPub.com
  for support files and downloads related to your book.
  
 Did you know that Packt offers eBook versions of every book published, with PDF and ePub 
 files available? You can upgrade to the eBook version at 
 www.PacktPub.com
  and as a print 
 book customer, you are entitled to a discount on the eBook copy. Get in touch with us at 
 service@packtpub.com
  for more details.
  
 At 
 www.PacktPub.com
 , you can also read a collection of free technical articles, sign up 
 for a range of free newsletters and receive exclusive discounts and offers on Packt books 
 and eBooks.
  
 TM
  
 http://PacktLib.PacktPub.com 
  
 Do you need instant solutions to your IT questions? PacktLib is Packt's online digital 
 book library. Here, you can access, read and search across Packt's entire library of books.",NA
Why Subscribe?,"f 
  
 Fully searchable across every book published by Packt
  
 f 
  
 Copy and paste, print and bookmark content
  
 f 
  
 On demand and accessible via web browser",NA
Free Access for Packt account holders,"If you have an account with Packt at 
 www.PacktPub.com
 , you can use this to access 
 PacktLib today and view nine entirely free books. Simply use your login credentials 
 for immediate access.",NA
Table of Contents,"Preface 
  
 Chapter 1: Drawing Shapes in Canvas 
  
 Introduction  
 Graphics with 2D canvas  
 Starting from basic shapes  
 Layering rectangles to create the flag of Greece 
 Creating shapes using paths  
 Creating complex shapes  
 Adding more vertices  
 Overlapping shapes to create other shapes  
 Chapter 2: Advanced Drawing in Canvas 
 Introduction  
 Drawing arcs  
 Drawing curves with a control point  
 Creating a Bezier curve  
 Integrating images into our art  
 Drawing with text  
 Understanding pixel manipulation  
 Chapter 3: Creating Cartesian-based Graphs 
 Introduction  
 Building a bar chart from scratch  
 Spreading data in a scatter chart  
 Building line charts  
 Creating the flying brick chart (waterfall chart) 
 Building a candlestick chart (stock chart)  
 1
  
 7 
  
 7  
 8  
 14  
 16  
 19  
 24  
 31  
 35 
 37 
  
 37  
 37  
 40  
 42  
 46  
 50  
 54 
 61 
  
 61  
 62  
 68  
 76  
 84  
 92",NA
Preface,"Today, the Web and the world are increasingly being defined by data. With the data 
 revolution of the Internet in the early nineties and until today, more and more data has been 
 exposed and aggregated, from government agencies, public sector information, financial 
 information, digital media and news, and social media to private sector information, user 
 information, and so on. With the overload of data on the Web it's easy to overlook 
 information, as it's much harder to read and analyze in data format. That's where we come 
 in. Our goal in this book is to open up the door to you to data visualization. With step-by-step 
 guides that will take you from the basic creation of visual charts all the way through to 
 complex geographical location information driven by Google Maps and Google Docs (Drive).
  
 HTML5 and JavaScript are leading the new paths for data visualization and are moving us 
 away from traditional client-side graph creation in Adobe Flash or server-side generated 
 images. With the maturing of browsers, they are becoming more capable and solid than 
 ever before. This is a perfect time to start transitioning the creation of graphs to 
 HTML/JavaScript. But where do you start, and what is the best way to create the specific 
 graph/map your project needs?
  
 With that said, our goal in this book is to run through, showcase, and teach all the critical 
 skills needed in the HTML5/JavaScript age of data visualization. Our goal is to help you make 
 the right choice when you need to build a custom graphic or graph/chart and to help you 
 choose the right way between creating it on your own or using third-party, small/large tools 
 to create the graphic your task needs.
  
 Although this is a cookbook, I've painstakingly organized it topic by topic in a very linear way, 
 making it a great read from start to end. As such, I personally recommend that you sit back 
 and actually read it from start to finish, and if you do so, you will learn in the process 
 everything you ever needed to know about the two-dimensional Canvas API, how to create 
 shapes, interaction, and various graphs/charts, and how to create them from scratch in 
 HTML5 Canvas. You will learn how to work with and modify third-party tools, working with 
 the Google Visualization API, Google Maps, and Google Docs. Woven throughout the book are 
 various data formats from basic strings, external files, XML, and Google Docs to Twitter search 
 results. As such, you will get an extra practice in loading, modifying, and working with data in 
 JavaScript.",NA
What this book covers ,"Chapter 1
 , 
 Drawing Shapes in Canvas
 , introduces you to working with canvas. We will spend 
 the majority of our time working with canvas when creating our charts. In this chapter, we 
 will focus on getting to know how canvas works and how to create custom shapes with the 
 two-dimensional canvas API.
  
 Chapter 2
 , 
 Advanced Drawing in Canvas
 , continues where we left off in 
 Chapter 1
  as we master 
 our skills in canvas by adding to our tool belt various functions. We will be working with 
 curves, images, text, and even pixel manipulation.
  
 Chapter 3
 , 
 Creating Cartesian-based Graphs
 , presents our first cluster of charts under the 
 microscope, Cartesian-based graphs. Altogether this graph style is relatively simple; it opens 
 the door to amazingly creative ways of exploring data. In this chapter, we will lay down the 
 foundations to building charts, and with them, will continue and expand our overall canvas 
 knowledge.
  
 Chapter 4
 , 
 Let's Curve Things Up
 , leverages the capability of creating non-linear charts to 
 represent multidimensional data. In this chapter we will create Bubble, Pie, Doughnut, 
 Radar, and Tree charts.
  
 Chapter 5
 , 
 Getting Out of the Box
 , progresses into more out-of-the-box, less commonly used 
 charts and revisits some of our old charts to incorporate into them dynamic data or change 
 their layout. In this chapter, we will create a funnel chart, add interactivity to our charts, 
 create a recursive tree chart, add user interaction, and finish up with creating an 
 interactive click meter.
  
 Chapter 6
 , 
 Bringing Static Things to Life
 , introduces JavaScript object-oriented programming, 
 creating from scratch an animation library, adding multiple layers of canvas, and finishing up 
 with creating a legend that is aware of its surrounding. This chapter will break us into a few 
 new habits by first making everything dynamic followed by creating a more object-oriented 
 program so it's easier for us to differentiate between tasks and reduce our code footprint.
  
 Chapter 7
 , 
 Depending on the Open Source Sphere
 , introduces you to the various libraries. The 
 open source data visualization community is extremely rich and detailed with so many options 
 and some really amazing libraries. Each library has its strong points and its disadvantages. 
 Some are standalone code, while others depend on other platforms. Our goal in this chapter is 
 both to showcase what we think are the best, most creative options online, and with it, to also 
 learn the new skill of customizing third-party tools and expanding their features beyond their 
 available documentation.
  
 Chapter 8
 , 
 Playing with Google Charts
 , explores the Google visualization API, task by task. We 
 will look at the steps involved to create a chart and integrate it with the charting API. In the 
 process, we will create new graphs and explore the core capabilities of this library.
  
  
   
 2",NA
What you need for this book ,"You will need to have some basic background knowledge of HTML and JavaScript or a 
 comparable programming language.",NA
Who this book is for ,"This is not a beginner's book but is intended for JavaScript developers who want to expand 
 their skills into graphing, canvas, object-oriented programming in practice, third-party 
 modification, and overall data strategy and data visualization.",NA
Conventions ,"In this book, you will find a number of styles of text that distinguish between different kinds 
 of information. Here are some examples of these styles, and an explanation of their meaning.
  
 Code words in text are shown as follows: ""Set up our 
 grayStyle
  Styling Object to be our 
 default style:""
  
 A block of code is set as follows:
  
 var aGray =  [
  
  
  {
  
    
  stylers: [{saturation: -100}]
  
  
  }
  
  
  ];
  
  
 3",NA
Reader feedback ,"Feedback from our readers is always welcome. Let us know what you think about this 
 book—what you liked or may have disliked. Reader feedback is important for us to develop 
 titles that you really get the most out of.
  
 To send us general feedback, simply send an e-mail to 
 feedback@packtpub.com
 , and 
 mention the book title through the subject of your message.
  
 If there is a topic that you have expertise in and you are interested in either writing 
 or contributing to a book, see our author guide on 
 www.packtpub.com/authors
 .",NA
Customer support ,"Now that you are the proud owner of a Packt book, we have a number of things to help you 
 to get the most from your purchase.",NA
Downloading the example code ,"You can download the example code files for all Packt books you have purchased from your 
 account at 
 http://www.packtpub.com
 . If you purchased this book elsewhere, you can 
 visit 
 http://www.packtpub.com/support
  and register to have the files e-mailed 
 directly to you.
  
 The code files are also available at 
 http://02geek.com/books/html5-graphics-and-
 data-visualization-cookbook.html
 .
  
  
   
 4",NA
Errata ,"Although we have taken every care to ensure the accuracy of our content, mistakes do 
 happen. If you find a mistake in one of our books—maybe a mistake in the text or the code—
 we would be grateful if you would report this to us. By doing so, you can save other readers 
 from frustration and help us improve subsequent versions of this book. If you find any 
 errata, please report them by visiting 
 http://www.packtpub.com/support
 , selecting 
 your book, clicking on the erratasubmissionform link, and entering the details of your errata. 
 Once your errata are verified, your submission will be accepted and the errata will be 
 uploaded to our website, or added to any list of existing errata, under the Errata section of 
 that title.",NA
Piracy ,"Piracy of copyright material on the Internet is an ongoing problem across all media. At Packt, 
 we take the protection of our copyright and licenses very seriously. If you come across any 
 illegal copies of our works, in any form, on the Internet, please provide us with the location 
 address or website name immediately so that we can pursue a remedy.
  
 Please contact us at 
 copyright@packtpub.com
  with a link to the suspected 
 pirated material.
  
 We appreciate your help in protecting our authors, and our ability to bring 
 you valuable content.",NA
Questions ,"You can contact us at 
 questions@packtpub.com
  if you are having a problem with 
 any aspect of the book, and we will do our best to address it.
  
  
 5",NA
1 ,NA,NA
Drawing Shapes ,NA,NA
in Canvas,"In this chapter we will cover:
  
 f 
  
 Graphics with 2D canvas
  
 f 
  
 Starting from basic shapes
  
 f 
  
 Layering rectangles to create the flag of Greece
  
 f 
  
 Creating shapes using paths
  
 f 
  
 Creating complex shapes
  
 f 
  
 Adding more vertices
  
 f 
  
 Overlapping shapes to create other shapes",NA
Introduction,"This chapter's main focus is to make a breakthrough into working in canvas. We will spend the 
  
 majority of our time working with canvas when creating our charts.
  
 In this chapter, we will master the basic shapes and styles of drawing with the canvas API. 
  
 This chapter will be the graphic's backbone to the rest of the book, so if at any stage you feel 
  
 you need a refresher you could come back to this chapter. Drawing lines can be... well not very 
  
 thrilling. What better way to make it more dramatic than to integrate a theme into this chapter 
  
 as a subtopic: creating flags!",NA
Graphics with 2D canvas,"Canvas is the primary and most thrilling addition to HTML. It's the buzz of the industry, so 
 let's start there. We will revisit canvas again in the later chapters. In this recipe, we will learn 
 how to draw dynamically using canvas, and create an array of colorful circles that will 
 update once every second.",NA
How to do it...,"We will be creating two files (an HTML5 file and a JS file). Let's start by creating a new 
 HTML5 document:
  
 1. The first step is to create an empty HTML5 document:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <meta charset=""utf-8"" />
  
  
  <title>Canvas Example</title>
  
  
  </head>
  
  
  <body>
  
  
  </body> 
  
 </html>
  
  
 Downloading the example code
  
  
 You can download the example code files for all Packt books 
  
 you have purchased from your account at 
 http://www.
  
 PacktPub.com
 . If you purchased this book elsewhere, you 
  
 can visit 
 http://www.PacktPub.com/support
  and 
  
 register to have the files e-mailed directly to you.
  
 The code files are also available at 
 http://02geek.
  
 com/books/html5-graphics-and-data-
  
 visualization-cookbook.html
 .
  
 2. Create a new canvas element. We give our canvas element an ID of 
 myCanvas
 :
  
  
  <body>
  
  <canvas id=""myCanvas""> </canvas>
  
  
  </body>",NA
How it works...,"Before we jump right into the JavaScript portion of this application, we need to trigger the 
 onLoad
  event to call our 
 init
  function. We do that by adding the 
 onLoad
  property into 
 our HTML body tag:
  
 <body onLoad=""init();"">",NA
There's more...,"Let's make our element refresh once a second; to do that all we need to do is add two more 
 lines. The first one will trigger a new call to the 
 updateCanvas
  function once every second 
 using 
 setInterval
 .
  
 function init(){
  
  setInterval(updateCanvas,1000);
  
  updateCanvas();
  
 } 
  
 If you refresh your browser you will find that our sample is working. If you try really hard to 
 find issues with it you will not, but we have a problem with it. It's not a major problem but a 
 great opportunity for us to learn about another useful functionality of the canvas. At any 
 stage we can clear the canvas or parts of it. Instead of drawing on top of the current canvas, 
 let's clear it before we redraw. In the 
 updateCanvas
  function, we will add the following 
 highlighted code:
  
 var context = myCanvas.getContext(""2d""); 
  
 context.clearRect(0,0,width,height);
  
 As soon as we get the context we can clear the data that was already present by using the 
 clearRect
  method.",NA
See also,"f 
  
 The 
 Starting from basic shapes
  recipe",NA
Starting from basic shapes,"At this stage you know how to create a new canvas area and even create a few basic shapes. 
 Let's expand our skill and start creating flags.",NA
Getting ready,"Well, we won't start from the most basic flag as that would just be a green rectangle. If 
 you wanted to learn how to create a green flag you wouldn't need me, so let's move up to 
 a tad more complex flag.
  
 If you followed the 
 Graphics with 2D canvas
  recipe you already know how to do it. This one is 
 dedicated to our Palauan readers and to the perfect arc (also known as circle).
  
  
 In this recipe we will ignore the HTML part, so if you need a refresher on how to create a 
 canvas with an ID, please go back to the first recipe in this chapter and set up your HTML 
 document. Don't forget to create the canvas with the right ID. You could also download 
 our sample HTML files.",NA
How to do it...,"Add the following code block:
  
 var cnvPalau = document.getElementById(""palau""); 
 var wid = cnvPalau.width;
  
  var hei = cnvPalau.height;
  
  var context = cnvPalau.getContext(""2d"");
  
  context.fillStyle = ""#4AADD6"";
  
  context.fillRect(0,0,wid,hei);
  
  context.fillStyle = ""#FFDE00"";
  
  context.arc(wid/2.3, hei/2, 40, 0, 2 * Math.PI, false); 
 context.fill();
  
 That's it, you've just created a perfect arc, and with it your first flag that has a shape within it.",NA
How it works...,"A big chunk of this code should look very familiar at this stage. So I'll focus on the new lines 
 compared to the ones used in the first recipe in this chapter.
  
  var wid = cnvPalau.width;
  
  var hei = cnvPalau.height;
  
 In these lines, we extract the width and height of our canvas. We have two goals here: to 
 shorten our lines of code and to reduce the number of times we make an API call when not 
 needed. As we are using it more than one time, we first fetch the values and store them in 
 wid
  and 
 hei
 .
  
 Now that we know our canvas width and height, it's time for us to draw our circle. Before 
 we start drawing, we will call the 
 fillStyle
  method to define a background color to be 
 used in the canvas, and then we will create the arc followed by triggering the 
 fill
  method 
 when complete.
  
  context.fillStyle = ""#FFDE00"";
  
  context.arc(wid/2.3, hei/2, 40, 0, 2 * Math.PI, false); 
 context.fill();
  
 We then create our first perfect circle using the 
 arc
  method. It's important to note that we can 
 change the colors at any point, such as in this case, where we change our color just before we 
 create a new circle.",NA
Layering rectangles to create the flag of Greece,"We learned as we created the flag for Palau that when we create a circle using the 
 arc 
 method, we have to trigger a request separately to fill the shape. This is true for all 
 shapes that we create from scratch, and it is true for creating lines as well. Let's move to a 
 slightly more complex flag: the flag of Greece.",NA
Getting ready,"As in the previous recipe, we will be skipping the HTML part and will jump right into the 
 JavaScript portion of drawing in the canvas. For a detailed explanation of the steps involved 
 in the creation of the canvas element, please refer to the first recipe of this chapter.
  
 Before you start coding, look at the flag closely and try to come up with an attack plan on the 
 steps you would need to perform to create this flag.",NA
How to do it...,"If we look at the flag, it's easy to figure out how to plan this out. There are many ways to 
 do this but the following is our attempt:
  
 1. We will first start our app and create a blank blue canvas:
  
  var canvas = document.getElementById(""greece""); 
 var wid = canvas.width;
  
  var hei = canvas.height;
  
  var context = canvas.getContext(""2d"");
  
  context.fillStyle = ""#000080"";
  
  context.fillRect(0,0,wid,hei);
  
 2. If you take a look at the previous figure, there are four white strips and five blue strips 
 that will be part of the background. Let's divide the total height of our canvas by 
 9
 , 
 so we can find out the right size for our lines:
  
  var lineHeight = hei/9;
  
 3. So far we created shapes using built-in tools, such as 
 arc
  and 
 fillRect
 . Now we 
 are going to draw our lines manually, and to do so we will set the 
 lineWidth
  and 
 strokeStyle
  values, so we can draw lines on the canvas:
  
  context.lineWidth = lineHeight;
  
  context.strokeStyle = ""#ffffff"";
  
 4. Now, let's loop through and create four times a line that goes from the right-hand side 
  
 to the left-hand side, as follows:
  
  var offset = lineHeight/2;
  
  for(var i=1; i<8; i+=2){
  
  context.moveTo(0,i*lineHeight + offset);
  
  context.lineTo(wid,i*lineHeight+offset);
  
  }",NA
How it works...,"Notice the addition of an offset. This is done because 
 lineWidth
  grows in both directions 
 from the actual point in the center of the line. In other words, a line with the width of 20 pixels 
 that is drawn from (0, 0) to (0, height) would only have 10 pixels visible as the range of the 
 thickness of the line would be between (-10 to 10). As such, we need to take into account that 
 our first line needs to be pushed down by half its width so that it's in the right location.
  
 The 
 moveTo
  function takes in two parameters 
 moveTo(x,y)
 . The 
 lineTo
  function also 
 takes two parameters. I believe you must have guessed the difference between them. One 
 will shift the virtual point without drawing anything while the other will create a line 
 between the points.",NA
There's more...,"If you run your HTML file, you will find that our lines were not revealed. Don't worry, you 
 didn't make any mistake (At least, that's what I think ;)). For the lines to become visible, we 
 need to tell the browser that we are ready, just like we called the 
 fill()
  method when we 
 used 
 arc
 . 
  
 In this case, as we are creating lines we will call the 
 stroke()
  method right after we are 
 done defining our lines, as follows:
  
 var offset = lineHeight/2;
  
  for(var i=1; i<8; i+=2){
  
  context.moveTo(0,i*lineHeight + offset);
  
  context.lineTo(wid,i*lineHeight+offset);
  
  }
  
  context.stroke();
  
 If you refresh the screen now you will see we are getting much closer. It's time for us to 
 add that rectangle on the top-left area of the screen. To do that, we will reuse our 
 lineHeight 
 variable. The size of our rectangle is five times the length of 
 lineHeight
 :
  
  context.fillRect(0,0,lineHeight*5,lineHeight*5);
  
 It is now time to create the cross in the flag:
  
  context.moveTo(0, lineHeight*2.5);
  
  context.lineTo(lineHeight*5,lineHeight*2.5);
  
  context.moveTo(lineHeight*2.5,0);
  
  context.lineTo(lineHeight*2.5,lineHeight*5+1);
  
  context.stroke();",NA
Creating shapes using paths,"We ended the last recipe learning how to create one fourth of the flags of the world, but 
 that can't be the end of it, can it? This recipe will be dedicated to using paths to create 
 more complex shapes. We will start by creating a triangle and progress from there to 
 more complicated shapes.",NA
Getting ready,"Let's start from the simplest shape that isn't included in the basic shapes library: a triangle. 
 So if you're ready let's get started...",NA
How to do it...,"Let's start with creating our first shape, a triangle:
  
 context.fillStyle = 
 color; 
  
 context.beginPath(); 
  
 context.moveTo(x1,y1); 
  
 context.lineTo(x2,y2); 
  
 context.lineTo(x3,y3); 
  
 context.lineTo(x1,y1); 
  
 context.closePath(); 
  
 context.fill();
  
 The code here with points 
 x1,y1
  through 
 x3,y3
  is pseudocode. You would need to pick 
 your own points to create a triangle.",NA
How it works...,"Most of the elements here aren't new. The most important change here is that we are creating 
 the shape from scratch using the elements we worked with before. When we create a shape 
 we always start by declaring it using the 
 beginPath()
  method. We then create the shape and 
 end the creation with the 
 closePath()
  method. We will still not have anything visible on the 
 screen until we decide what we want to do with the shape we created, such as show its fill or 
 show its strokes. In this case as we are trying to create a triangle we will call the 
 fill
  
 function.
  
 Let's see this in action in a live flag sample. This time we will visit Mount Roraima in Guyana.",NA
There's more...,"Don't let triangles be your most complex shape, as you can create any number of pointed 
 shapes. Let's create a more complex zigzag pattern. To do so, we will fly over to the Kingdom 
 of Bahrain.
  
  
 Try to locate the new logic before we break it down and explain it.
  
 var canvas = document.getElementById(""bahrain""); 
 var wid = canvas.width; 
  
 var hei = canvas.height;
  
 var context = 
 canvas.getContext(""2d"");
  
  context.fillStyle = ""#CE1126"";
  
  context.fillRect(0,0,wid,hei); 
  
 var baseX = wid*.25;
  
  context.fillStyle = ""#ffffff"";
  
  context.beginPath();
  
  context.lineTo(baseX,0);
  
 var zagHeight = hei/5; 
  
 for(var i=0; i<5; i++){
  
  
  context.lineTo(baseX +25 , (i+.5)*zagHeight);
  
  context.lineTo(baseX  , (i+1)*zagHeight);
  
 } 
  
 context.lineTo(0,hei)
 ; 
  
 context.lineTo(0,0); 
  
 context.closePath(); 
  
 context.fill();
  
 addBoarder(context,wid,hei);",NA
Creating complex shapes,"It's time to take everything we learned and integrate it into the most complex shape we 
 have seen so far, the Star of David. This star is part of the flag of Israel (one of my favorite 
 flags in the world ;)). We need to take a roundabout before we can create it by visiting the 
 magical world of sine and cosine.",NA
Getting ready,"The easiest way to understand how sine/cosine work is by a live example, and in our case we 
 will use it to help us figure out how to create the Star of David in the flag of Israel. We will take 
 a step back and learn how we figured out the points on the screen to create the shapes. Again 
 we will be skipping the creation of the HTML file and will go right into the JavaScript code. For 
 an overview of how to get your HTML set, please review the 
 Graphics with 2D canvas
  recipe.",NA
How to do it...,"After creating the JavaScript file add the following code in your 
 init
  function.
  
 1. Create our basic canvas variables:
  
 var canvas = document.getElementById(""israel""); 
 var wid = canvas.width; 
  
 var hei = canvas.height; 
  
 var context = canvas.getContext(""2d"");
  
 2. Define one degree in radians. We do that since 
 Math.cos
  and 
 Math.sin
  expect a 
  
 radian value and not a degree value (
 radian
  is one degree measured in radians):
  
 var radian = Math.PI/180;
  
 3. Create a 
 tilt
  variable. This variable will define the tilt of the triangle that will be 
 created. Imagine the triangle is in a circle and we are rotating the circle with this 
 tilt
  variable:
  
 var tilt = radian*180;
  
 4. Define the center point of the canvas:
  
 var baseX = wid / 
 2; 
  
 var baseY = hei / 
 2;
  
 5. Set the radius of the invisible bounding circle of the Star of David:
  
 var radius = 24;
  
 6. Define the height of the strips in the flag:
  
 var stripHeight = 14;
  
 7. 
  
 Define a line width:
  
 context.lineWidth=5;
  
 8. Create two triangles (one tilted and one not):
  
 createTrinagle(context,
  
  baseX+ Math.sin(0) * radius,  
  
  baseY + Math.cos(0) * radius,
  
  baseX+ Math.sin(radian*120) * radius,  
  
  baseY + Math.cos(radian*120) * radius,
  
  baseX+ Math.sin(radian*240) * radius,  
  
  baseY + Math.cos(radian*240) * radius, 
  
  null,""#0040C0"");
  
 createTrinagle(context,
  
  baseX+ Math.sin(tilt) * radius,  
  
  baseY + Math.cos(tilt) * radius,
  
  baseX+ Math.sin(radian*120+tilt) * radius,   
 baseY + Math.cos(radian*120+tilt) * radius,",NA
How it works...,"Before we dig into the creation of the flag and how it was done, we need to understand 
 how we locate points in a circle. To do so let's look at a simpler example:
  
 var rad = Math.PI/180; 
  
 context.fillStyle = ""#FFDE00""; 
  
 context.arc(wid / 2, hei / 2, 30, 0, 2 * Math.PI, false); 
 context.fill();",NA
There's more...,"OK, time to connect the dots (literally speaking) and create the flag of Israel. Looking back at 
 our original code we find ourselves using the 
 createTriangle
  function twice to create the 
 full Star of David shape. Let's take a deeper look at the logic here by looking at the second 
 triangle (the one that is turned upside down):
  
 createTriangle(context,
  
  
  baseX+ Math.sin(tilt) * radius, 
  
  
  baseY + Math.cos(tilt) * radius,
  
  
  baseX+ Math.sin(radian*120+tilt) * radius, 
  
  baseY + Math.cos(radian*120+tilt) * radius, 
 baseX+ Math.sin(radian*240+tilt) * radius,
  
  
  baseY + Math.cos(radian*240+tilt) * radius,  
  
  null,""#0040C0"");
  
 We are sending in three points on the virtual circle to create a triangle. We split our virtual 
 circle to three equal parts and find the point values at the 
 0
 , 
 120
 , and 
 240 
 degrees. This way 
 if we drew a line between these points we would get a perfect triangle in which all of the 
 sides were equal.
  
 Let's take a deeper look at one of the points sent to the 
 createTriangle
  function:
  
 baseX + Math.sin(radian*120+tilt) * radius, 
 baseY + Math.cos(radian*120+tilt) * radius
  
 We start from 
 baseX
  and 
 baseY
  (the center of the screen) as the center point of our circle 
 before we figure out the actual point gap from that base starting point. We then add to it 
 the value that we get from 
 Math.sin
  and 
 Math.cos
  respectively. In this example, we are 
 trying to get 
 120
  degrees plus the tilt value. In other words, 
 120
  degrees plus 
 180
  degrees 
 (or 
 300
  degrees).
  
 To make it easier to comprehend, in pseudocode it would look similar to the 
 following code snippet:
  
  startingPositionX + Math.sin(wantedDegree) * Radius  
 startingPositionY + Math.cin(wantedDegree) * Radius 
  
 Not much more to say besides congrats. We just finished creating another flag and in the 
 process, learned how to create complex shapes, use math to help us figure out points on the 
 screen, and mix together different shapes to create more advanced shapes.",NA
Adding more vertices,"There are many flags that contain stars that just cannot be created by overlapping triangles. In 
 this recipe, we will figure out how to create a star that contains an arbitrary number of points 
 We will use the same key concept we discovered in the previous recipe by taking advantage of 
 a virtual circle to calculate positions, this time with only two virtual circles. In this recipe, we 
 will create the flag of Somalia and in the process figure out how to create a function that will 
 enable us to create stars.",NA
Getting ready,"Please continue working on the sample from the previous recipe. If you haven't worked on it 
 yet, I strongly encourage you to do so as this recipe is the next logical step of the previous 
 recipe. As in the previous recipe, we will be skipping the HTML portion of this sample. Please 
 review the first recipe in the book to refresh on the required HTML code.",NA
How to do it...,"Let's jump right in and create the flag of Somalia.
  
 1. Create the canvas standard logic:
  
 var canvas = document.getElementById(""somalia"");
  
 var wid = canvas.width;
  
 var hei = canvas.height;
  
 var context = canvas.getContext(""2d"");",NA
How it works...,"Let's start by understanding what the function we are going to create expects. The idea is 
 simple, to create a star we want to have a virtual inner circle and a virtual outer circle. We 
 can then draw lines between the circles back and forth to create the star. To do so, we need 
 some basic parameters.
  
 function createStar(context,baseX,baseY,
  
  innerRadius,outerRaduis,points,fillColor,
  
  
  strokeColor,tilt){
  
 Our regular context, 
 baseX
  and 
 baseY
  don't need further introductions. The virtual 
 innerRadius
  and 
 outerRadius
  are there to help define the length of the line segments 
 that create a star and their positions. We want to know how many points our star will have. 
  
 We do so by adding in the 
 points
  parameters. We want to know the 
 fillColor
  and/or 
 strokeColor
  so we can define the actual colors of the star. We top it with a 
 tilt
  value (it 
 can be useful as we've seen when creating the Star of David for the flag of Israel).
  
 var radian = Math.PI/180; 
  
 var radianStepper = radian * ( 360/points) / 2; 
 var currentRadian =0; 
  
 var radianTilt = tilt*radian;",NA
Overlapping shapes to create other shapes,"There are many flags and many shapes in general that can be created by combining the 
 shapes we created so far. One of the most popular shapes in 82 flags we don't know how to 
 create is the crescent shape like the one in the flag of Turkey. With it we learn a new skill of 
 using subtraction to create more in-depth shapes.",NA
Getting ready,"The previous recipe is our starting point in this recipe. From here, we will continue working 
 to create more advanced shapes that are built out of two shapes when combined. As such, we 
 will be using the code created in the last recipe located in 
 01.02.flags.js
 .",NA
How to do it...,"Let's jump right into our code and see it in action.
  
 1. Gain access to the context and save the width and height of the canvas into variables:
  
 var canvas = document.getElementById(""turkey"");
  
 var wid = canvas.width;
  
 var hei = canvas.height;
  
 var context = canvas.getContext(""2d"");",NA
How it works...,"The catch here is we are using two circles, one overlaps the other to create a crescent shape. 
 By the way, notice how we are tilting the star as well so that one of its points will point to the 
 middle of the circle.
  
 We've gone through a lot in the last few examples and at this stage you should be very 
 comfortable creating many shapes and elements in the canvas. There is still much to explore 
 before we can say we have mastered canvas, but we can definitely say we have mastered 
 creating most of the flags of the world and that's very cool. I would love to see your flags. 
  
 Drop me a line when you create one not in the book! :)",NA
2 ,NA,NA
Advanced Drawing ,NA,NA
in Canvas,"f 
  
 Drawing arcs
  
 f 
  
 Drawing curves with a control point
  
 f 
  
 Creating a Bezier curve
  
 f 
  
 Integrating images into our art
  
 f 
  
 Drawing with text
  
 f 
  
 Understanding pixel manipulation",NA
Introduction,"This is the last chapter where we will dig deep into canvas as the remaining chapters will 
  
 focus on building charts and interactivity.
  
 In this chapter, we will continue to master our skills with canvas by adding curves, images, 
  
 text, and even pixel manipulation to our tool belt.",NA
Drawing arcs,"There are three types of curves we can create in canvas—using the arc, quadratic curves, and 
  
 Bezier curves. Let's get started.",NA
Getting ready,"If you recall in 
 Chapter 1
 , 
 Drawing Shapes in Canvas
 , in our first recipe we used the arc method 
 to create perfect circles. The arc method is much more than just that. We can actually create 
 any partial curve in a circular shape. If you don't recall drawing circles, I strongly encourage 
 you to scan through 
 Chapter 1
 , 
 Drawing Shapes in Canvas
  again, and while you are there, you 
 will find the template for creating the HTML documents as well. We are exclusively going to 
 focus on the JavaScript code in this recipe.",NA
How to do it...,"Let's jump into it and create our first noncircle that has curves:
  
 1. Access the 
 pacman
  canvas element and fetch its width and height by using the 
  
 following code snippet:
  
 var canvas = document.getElementById(""pacman"");
  
 var wid = canvas.width;
  
 var hei = canvas.height;
  
 2. Create a 
 radian
  variable (one degree in radians):
  
 var radian = Math.PI/180;
  
 3. Get the canvas context and fill its background in black by using the following code 
  
 snippet:
  
 var context = canvas.getContext(""2d"");
  
  context.fillStyle = ""#000000"";
  
  context.fillRect(0,0,wid,hei);
  
 4. Begin a new path before starting to draw:
  
  context.beginPath();
  
 5. Change fill style color:
  
  context.fillStyle = ""#F3F100"";
  
 6. Move the pointer to the center of the screen:
  
  context.moveTo(wid/2,hei/2);
  
 7. 
  
 Draw a curve that starts at 40 degrees and ends at 320 degrees (with a radius of 40) 
  
 in the center of the screen:
  
  context.arc(wid / 2, hei / 2, 40, 40*radian, 320*radian,   
 false);",NA
How to do it...,"For the first time, we take advantage and create a pie-type shape, known as PacMan 
 (you can see how this can be very useful when we get into creating the pie graph). 
  
 Very simple—again we connect to that idea of radians:
  
 context.arc(wid / 2, hei / 2, 40, 40*radian, 320*radian, false);
  
 Notice how our 4th and 5th parameters—instead of being a complete circle by starting 
 from 0 and ending at 
 2*Math.PI
 —are setting the angle to start the arc at radian 40 and 
 end at radian 320 (leaving 80 degrees open to create the mouth of a PacMan ). All that is 
 left is to start drawing from the center of the circle:
  
 context.moveTo(wid/2,hei/2);
  
 context.arc(wid / 2, hei / 2, 40, 40*radian, 320*radian, false);
  
 context.lineTo(wid/2,hei/2);
  
 We start by moving our pointer to the center of our circle. We then create the arc. As our arc 
 isn't a complete shape it's continuing where we left off—drawing a line from the center of 
 the arc to the starting point (40 degrees). We complete the action by drawing a line back to 
 the center of the arc to complete the shape. Now we are ready to fill it and complete our 
 work.
  
  
 Now that we have got arcs out of the way, you can see how useful this will be for 
 creating pie charts.",NA
Drawing curves with a control point,"If the world was just two points with a perfect arc this would be the end of the book, but alas 
 or lucky for us, there are still many more complex shapes to learn and explore. There are 
 many curves that are not perfectly aligned curves. Till now all the curves that we created 
 were part of a perfect circle, but not any more. In this recipe, we will explore quadratic 
 curves. The quadratic curves enable us to create curves that are not circular, by adding a 
 third point—a controller to control the curve. You can easily understand this by looking at 
 the following diagram:
  
 control point
  
 point A
  
  
 point B
  
  
 A quadratic curve is a curve that has one control point. Consider the case when creating a 
 line, we draw it between two points (A and B in this illustration). When we want to create a 
 quadratic curve, we use an external gravity controller that defines the direction of the 
 curve while the middle line (the dotted line) defines how far will the curve reach.",NA
Getting ready,"As done in previous recipes, we are skipping the HTML part here too—not that it's not 
 needed, it just repeats itself in every recipe and if you need to refresh yourself on how to get 
 the HTML setup, please take a look at the 
 Graphics with 2D Canvas
  recipe in 
 Chapter 1
 , 
 Drawing Shapes in Canvas
 .",NA
How to do it...,"In this example, we will create a closed shape that looks like a very basic eye. 
 Let's get started:
  
 1. We always need to start with extracting our canvas element, setting up our width and 
  
 height variables, and defining a radian (as we find it useful to have one around):
  
 var canvas = document.getElementById(""eye"");
  
  var wid = canvas.width;
  
  var hei = canvas.height;
  
  var radian = Math.PI/180;",NA
How it works...,"Let's look at this method closely: 
  
  
 context.quadraticCurveTo(wid / 2, 0, wid,hei/2); 
  
 As we are already at the origin point (point A), we input two other points—the control 
 point and point B.
  
 context.quadraticCurveTo(controlX, controlY, pointB_X, pointB_Y);",NA
Creating a Bezier curve,"We've just learned that with the quadratic curve we have one control point. Although we 
 can do many things with one control point, we don't really have full control over the 
 curve. 
  
 So let's take it one step further by adding one more control point. Adding a second control 
 point actually adds the relationship between these two points as well making it three control 
 factors. If we include the actual anchor points (we have got two of them), we end up with five 
 points that control the shape of the curve. That does sound complicated; it's because the 
 more control we get the more complicated it is to actually understand how it works. It's 
 really not easy to figure out complicated curves by code alone and as such we actually use 
 other tools to help us figure out the right curves.
  
 To prove the preceding point, we can find a very complex shape and start with that one 
 (don't worry, later on in this recipe, we will practice on a very simple shape to make the 
 concept clear). We will pick to draw the flag of Canada and mainly the maple leaf.",NA
Getting ready,"This recipe is difficult to understand, but we will break it down into details in the following 
 How it works...
  section. So if you are new to curves, I strongly encourage you to start learning 
 from this 
 How it works...
  section before implementing it.",NA
How to do it...,"Let's create the flag of Canada. Let's jump right into the JavaScript code:
  
 1. Create the canvas and context:
  
 var canvas = document.getElementById(""canada""); 
 var wid = canvas.width; 
  
 var hei = canvas.height;
  
 var context = canvas.getContext(""2d"");
  
 2. Fill the background to match the background of the Canadian flag:
  
 context.fillStyle=""#FF0000""; 
  
 context.fillRect(0,0,50,100); 
  
 context.fillRect(wid-50,0,50,100);
  
 3. Begin a new path and move the pointer to 
 84,19
 :
  
 context.beginPath(); 
  
 context.moveTo(84,19);
  
 4. Draw curves and lines to create the maple leaf:
  
 context.bezierCurveTo(90,24,92,24,99,8); 
 context.bezierCurveTo(106,23,107,23,113,19)
 ; 
 context.bezierCurveTo(108,43,110,44,121,31)
 ; 
 context.bezierCurveTo(122,37,124,38,135,35)
 ; 
 context.bezierCurveTo(130,48,131,50,136,51)
 ; 
 context.bezierCurveTo(117,66,116,67,118,73)
 ; 
 context.bezierCurveTo(100,71,99,72,100,93); 
 context.lineTo(97,93); 
  
 context.bezierCurveTo(97,72,97,71,79,74); 
 context.bezierCurveTo(81,67,80,66,62,51); 
 context.bezierCurveTo(67,49,67,48,63,35); 
 context.bezierCurveTo(74,38,75,37,77,31); 
 context.bezierCurveTo(88,44,89,43,84,19);",NA
How it works...,"Before we can explain the details of how the Canadian flag works, we should take a step back 
 and create a simpler example. In this short example, we will create an oval shape by using the 
 bezierCurveTo
  method.
  
 context.moveTo(2,hei/2);
  
  context.bezierCurveTo(0, 0,wid,0, wid-2,hei/2);
  
  context.bezierCurveTo(wid, hei,0,hei, 2,hei/2);
  
  context.closePath();
  
  context.stroke();
  
  context.fill();
  
 That's it. The following is the outcome you get out of this:
  
  
 If you get this, you are in great shape. We will now explain how this works and then move into 
 how we figured out all the points for the Canadian flag. We are taking advantage of the full 
 canvas again and we are keeping our controllers under control by setting two of our 
 controllers to be the corners of the canvas:
  
 context.bezierCurveTo(controlPointX1, controlPointY1, controlPointX2, 
 controlPointY2, pointBX, pointBY);
  
 Play around with the controllers to see how much more control you get by using two dots—
 this is very useful when you need more detailed control over a curve.",NA
Integrating images into our art,"Lucky for us, we don't need to start from scratch always and we can leave the more 
 complex art for external images. Let's figure out how we can integrate images into our 
 canvas.",NA
Getting ready,"We've been in a flag theme in this chapter and getting another flag under our belt sounds 
 real good to me right now. So let's turn our heads to Haiti and get their flag up and running. 
  
 To create this flag, we need to have the image of the symbol that is placed in the center 
 of the flag.
  
  
 In the source files, you will find an image of the center graphic (at 
 img/haiti.png
 ). By 
 the way, when integrating art into canvas it's always best to avoid resizing the image 
 whenever possible via code to preserve the image quality.",NA
How to do it...,"We will prepare the background to match the flag and then put the entire image above it in 
 the center of the canvas/flag:
  
 1. Follow the basic steps that we need to access the canvas. Set the width, height, and 
  
 the actual context:
  
 var canvas = document.getElementById(""haiti"");
  
  var wid = canvas.width;
  
  var hei = canvas.height;
  
  var context = canvas.getContext(""2d""); 
  
 2. Draw the background elements:
  
 context.fillStyle=""#00209F"";
  
 context.fillRect(0,0,wid,hei/2);
  
 context.fillStyle=""#D21034"";
  
 context.fillRect(0,hei/2,wid,hei/2);
  
 3. Create a new 
 Image
  object:
  
 var oIMG = new Image();",NA
How it works...,"The steps involved in creating an image are downloading its data and then creating a new 
 image container in the same way as it is done in canvas:
  
 var oIMG = new Image();
  
 The next step is to create a listener that will be triggered when the image is loaded and ready 
 to be used:
  
 oIMG.onload = theListenerFunctionHere;
  
 The last step in the loading process is to tell canvas what image should be loaded. In our case 
 we are loading 
 img/haiti.png
 :
  
 oIMG.src = ""img/haiti.png"";
  
 Loading an image and having it ready to be used is only the first step. If we ran our 
 application without actually telling canvas what to do with it, nothing would 
 happen beyond the loading of the image.
  
 In our case, when our listener is triggered, we add the image as it is to the center 
 of the screen:
  
 context.drawImage(this, (wid-this.width)/2, (hei-this.height)/2);
  
 That is all it takes to integrate an image into a canvas project.",NA
There's more...,"There are more operations that we can do with images in canvas beyond using them as 
 backgrounds. We can define exactly what parts of the image we want (scaling). We can resize 
 and manipulate the full image (scaling). We can even pixel manipulate our images. There are 
 many things that we can do with images, but in the next few topics we will cover some of the 
 more often used ones.",NA
Drawing with text,"I agree, we've been working on some complicated things. Now, its time for us to lay back, 
 kick off the shoes, and do something a bit easier.",NA
Getting ready,"The good news is, if you are on this page, you should already know the basics of getting a 
 canvas up and running. So there isn't much more that you need to do besides picking the font, 
 size, and position of your text.
  
  
 Here, we aren't covering how you can embed fonts that aren't created 
  
  
 within JavaScript, but instead, via CSS, we will use a basic font and 
  
 hope for the best in this sample.",NA
How to do it...,"In this example, we are going to create a text field. In this process, we are going to use 
 gradients and shadows for the first time. Perform the following steps:
  
 1. Gain access to the canvas 2D API:
  
 var canvas = document.getElementById(""textCanvas""); 
 var wid = canvas.width;
  
  var hei = canvas.height;
  
  var context = canvas.getContext(""2d"");
  
 2. Create a gradient style and fill the background with it:
  
 var grd = context.createLinearGradient(wid/2, hei/2, wid, hei); 
 grd.addColorStop(0, ""#8ED6FF""); 
  
  grd.addColorStop(1, ""#004CB3"")
  
  context.fillStyle= grd;
  
  context.fillRect(0,0,wid,hei);
  
 3. Create a gradient to be used by the text:
  
  grd = context.createLinearGradient(100, hei/2, 200,   
 hei/2+110);
  
  grd.addColorStop(0, ""#ffff00""); 
  
  grd.addColorStop(1, ""#aaaa44"");
  
 4. Define the font to be used and set the style:
  
  context.font = ""50pt Verdana, sans-
 serif"";
  
  context.fillStyle = grd;
  
 5. Add shadow details before drawing the text:
  
  context.shadowOffsetX 
 = 
 0;
  
  context.shadowOffsetY 
 = 
 0;
  
  context.shadowBlur 
  
  
  
 = 
 8;
  
  context.shadowColor   = 'rgba(255, 255, 255, 
 0.5)';
  
 6. Use 
 fillText
  to fill the shape and 
 strokeText
  for outlines of the shape (notice that 
 I call the text a shape; this is because as soon as we draw it, it will just be a part of 
 our canvas and not live text):
  
  context.fillText(""Hello World!"", 100, hei/2); 
 context.strokeStyle = ""#ffffff"";
  
  context.strokeText(""Hello World!"", 100, hei/2);
  
 That's it, we just integrated our first drawn text into canvas.",NA
How it works...,"Until now, we were stuck with the solid colors. We will now break out of that and move 
 to a new world of gradient colors. Refer to the following code snippet:
  
 var grd = context.createLinearGradient(wid/2, hei/2, wid, hei);
  
  grd.addColorStop(0, ""#8ED6FF""); 
  
  grd.addColorStop(1, ""#004CB3"");
  
 There are a few steps involved with creating a gradient. The first step is defining its scope:
  
 var grd = context.createLinearGradient(x1, y1, x2, y2);
  
 Contrary to many other languages, it's really easy to define the rotation and size of a gradient 
 in canvas. If you have worked with Photoshop before, you will find this really easy (even if 
 you haven't, it will be easy).
  
 All you need to do is define where you want the gradient to start and where you want it to 
 end. You can send two dots into the method 
 createLinearGradient
 :
  
 grd.addColorStop(0, ""#8ED6FF""); 
  
 grd.addColorStop(1, ""#004CB3"");
  
 In this transition, we are using only two colors. Position them at a value between 0 and 1. 
 These values are ratios, so we are, in other words, requesting to spread the color transition 
 from the start of the gradient area all the way to the end. We could add more colors, but 
 our goal is to bind them all within the ratio 0 to 1. The more colors you add, the more 
 playing around you would need to do with the values sent into the first parameter.
  
 You just completed creating a gradient. Time to use it:
  
 context.fillStyle= grd;
  
 context.fillRect(0,0,wid,hei);
  
 In this part again, we will use the 
 fillStyle
  method and then create a rectangle.
  
 Please note the importance of the range of values that you may send to the 
 addColorStop 
 method. As you add more colors into your gradient, the more noticeable the importance of the 
 values sent here will be. The points are not counters but ratios of colors in our sample. The 
 transition is between the two colors' range from 0 to 1 or in other words they transition all the 
 way through from our first point that we send into the 
 createLinearGradient
  method all 
 the to the last point. As we are working with two colors, this is the perfect ratio for us.
  
 Although we are not getting into radial gradients, they should be really easy for you as we 
 have already learned a lot about radial shapes and gradients. The signature of this method 
 is as follows:
  
 context.createRadialGradient(startX,startY,startR, endX,endY,endR);",NA
There's more...,"There are some more options that you can explore.
  
 Using gradients in your text
  
 If you can do anything to any graphical element in canvas, you can do it to text as well—
 for example, in our sample we are using a gradient for our text.
  
 grd = context.createLinearGradient(100, hei/2, 200, hei/2+110);
  
  grd.addColorStop(0, ""#ffff00""); 
  
  grd.addColorStop(1, ""#aaaa44"");
  
  context.font = ""50pt Verdana, sans-serif"";
  
  context.fillStyle = grd;",NA
Understanding pixel manipulation,"Now that you have mastered drawing in canvas, it's time for us to turn to a new aspect of 
 working with canvas. In canvas, you can manipulate pixels. It's not only a vector drawing 
 tool, but a very smart pixel editor (raster).",NA
Getting ready,"Now that we are about to start reading data that is present on the canvas, we need to 
 understand how security works when it comes to pixels. In an effort to protect content that 
 isn't yours, there are security issues involved in working with data that isn't hosted on the 
 same host as yours. We will not cover these security issues in this section and will be always 
 working with images in the same domain as our code (or all locally).
  
 Your first step is to find an image that you wish to work with (I've added an old image of 
 my own into the source files). In this sample, we will recreate a pixel fade-out animation—
 really cool and useful for slides.",NA
How to do it...,"Let's get our code working and then break it down to see how it works. Perform 
 the following steps:
  
 1. Create a few helper global variables:
  
 var context; 
  
 var imageData; 
  
 var pixelData; 
  
 var pixelLen; 
  
 var currentLocation=0; 
  
 var fadeOutImageInterval;
  
 2. Create an 
 init
  function (for the rest of the steps, all code will be in this function):
  
 function init(){
  
  
  //all the rest of the code will go in 
 here }
  
 3. Create a context variable for the 2D Canvas API:
  
 function init(){
  
  var canvas = document.getElementById(""textCanvas""); 
 var wid = canvas.width;
  
  var hei = canvas.height;
  
  context = canvas.getContext(""2d"");",NA
How it works...,"We will skip explaining things that we have already covered in earlier samples such as how 
 to load images and how to work with the 
 drawImage
  method (covered in the 
 Integrating 
 images into our art
  recipe discussed earlier in this chapter).
  
 var context; 
  
 var imageData; 
  
 var pixelData; 
  
 var pixelLen; 
  
 var currentLocation=0; 
  
 var fadeOutImageInterval;
  
 We will see the usage of these variables in our code, but all these variables have been saved 
 as global variables so there is no need to redefine them in our functions. By defining these 
 variables once, we improve the efficiency of our application.
  
 The real new logic starts within the 
 onLoad
  listener. Right after we draw our image onto 
 the canvas, our new logic is added. It is highlighted in the following code snippet:
  
 var oIMG = new Image();
  
  
  oIMG.onload = function(){
  
  
  context.drawImage(this,  
  
  
  0,0,this.width,this.height,0,0,wid,hei);
  
  
  imageData = context.getImageData(0, 0, wid, hei);
  
  pixelData = imageData.data;",NA
3 ,NA,NA
Creating Cartesian-,NA,NA
based Graphs,"In this chapter, we will cover the following topics:
  
 f 
  
 Building a bar chart from scratch
  
 f 
  
 Spreading data in a scatter chart
  
 f 
  
 Building line charts
  
 f 
  
 Creating the flying brick chart (waterfall chart)
  
 f 
  
 Building a candlestick chart (stock chart)",NA
Introduction,"Our first graph/chart under the microscope is the most popular and simplest one to create. 
 We can classify them all roughly under Cartesian-based graphs. Altogether this graph style 
 is relatively simple; it opens the door to creating amazingly creative ways of exploring 
 data. In this chapter we will lay down the foundations to building charts in general and 
 hopefully motivate you to come up with your own ideas on how to create engaging data 
 visualizations.",NA
Building a bar chart from scratch,"The simplest chart around is the one that holds only one dimensional data (only one value per 
 type). There are many ways to showcase this type of data but the most popular, logical, and 
 simple way is by creating a simple bar chart. The steps involved in creating this bar chart will 
 be very similar even in very complex charts. The ideal usage of this type of chart is when the 
 main goal is to showcase simple data, as follows:",NA
Getting ready,"Create a basic HTML file that contains a canvas and an 
 onLoad
  event that will trigger the 
 init
  function. Load the 
 03.01.bar.js
  script. We will create the content of the JavaScript 
 file in our recipe as follows:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Bar Chart</title>
  
  
  <meta charset=""utf-8"" />
  
  
  <script src=""03.01.bar.js""></script> 
  
  
  </head>
  
  
  <body onLoad=""init();"" style=""background:#fafafa"">
  
  
 <h1>How many cats do they have?</h1>
  
  
  <canvas id=""bar"" width=""550"" height=""400""> </canvas>
  
  
 </body> 
  
 </html>",NA
How to do it...,"In our first case, we will compare a group of friends and how many cats they each own. We 
 will be performing the following steps:
  
 1. Define your data set:
  
 var data = [{label:""David"",
  
  value:3,
  
  style:""rgba(241, 178, 225, 0.5)""},
  
  {label:""Ben"",
  
  value:2,
  
  style:""#B1DDF3""},
  
  {label:""Oren"",
  
  value:9,
  
  style:""#FFDE89""},
  
  {label:""Barbera"",
  
  value:6,
  
  style:""#E3675C""},
  
  {label:""Belann"",
  
  value:10,
  
  style:""#C2D985""}];
  
 For this example I've created an array that can contain an unlimited number 
 of elements. Each element contains three values: a label, a value, and a style 
 for its fill color.
  
 2. Define your graph outlines.
  
 Now that we have a data source, it's time to create our basic canvas information, 
 which we create in each sample:
  
 var can = document.getElementById(""bar"");
  
  var wid = can.width;
  
  var hei = can.height;
  
  var context = can.getContext(""2d"");
  
  context.fillStyle = ""#eeeeee"";
  
  context.strokeStyle = ""#999999"";
  
  context.fillRect(0,0,wid,hei);",NA
How it works...,"I've created a variable called 
 CHART_PADDING
  that is used throughout the code to help me 
 position elements (the variable is in uppercase because I want it to be a constant; so it's to 
 remind myself that this is not a value that will change in the lifetime of the application).",NA
There's more...,"In our example, we created a non-flexible bar chart, and if this is the way we create charts we 
 will need to recreate them from scratch each time. Let's revisit our code and tweak it to 
 make it more reusable.
  
 Revisiting the code 
  
 Although everything is working exactly as we want it to work, if we played around with the 
 values, it would stop working. For example, what if I only wanted to have five steps; if we 
 go back to our code, we will locate the following lines:
  
 var stepSize = (hei - CHART_PADDING*2)/10; 
  
 for(var i=0; i<10; i++){
  
 We can tweak it to handle five steps:
  
 var stepSize = (hei - CHART_PADDING*2)5; 
  
 for(var i=0; i<5; i++){
  
 We would very quickly find out that our application is not working as expected.
  
 To solve this problem let's create a new function that will deal with creating the outlines of 
 the chart. Before we do that, let's extract the data object and create a new object that will 
 contain the steps. Let's move the data and format it in an accessible format:
  
 var data = [...]; 
  
 var chartYData = [{label:""10 cats"", value:1}, 
 {label:""5 cats"", value:.5},
  
  {label:""3 cats"", value:.3}]; 
  
 var range = {min:0, max:10};
  
 var CHART_PADDING = 20; 
  
 var wid; 
  
 var hei; 
  
 function init(){",NA
Spreading data in a scatter chart,"The scatter chart is a very powerful chart and is mainly used to get a bird's-eye view while 
 comparing two data sets. For example, comparing the scores in an English class and the 
 scores in a Math class to find a correlative relationship. This style of visual comparison can 
 help find surprising relationships between unexpected data sets.",NA
Getting ready,"If you haven't had a chance yet to scan through the logic of our first recipe in this chapter, 
 I recommend you take a peek at it as we are going to base a lot of our work on that while 
 expanding and making it a bit more complex to accommodate two data sets.
  
 The regular HTML start-up code can be found in the code bundle or go through 
 Chapter 1
 , 
 Drawing Shapes in Canvas
 , for more information on creating the HTML document.
  
 I've revisited our data source from the previous recipe and modified it to store three 
 variables of students' exam scores in Math, English, and Art.
  
 var data = [{label:""David"",
  
  math:50,
  
  english:80,
  
  art:92,
  
  style:""rgba(241, 178, 225, 0.5)""},
  
  {label:""Ben"",
  
  math:80,
  
  english:60,
  
  art:43,",NA
How to do it...,"Let's dive right into the JavaScript file and the changes we want to make:
  
 1. Define the 
 y
  space and 
 x
  space. To do that, we will create a helper object that will 
  
 store the required information:
  
 var chartInfo= { y:{min:40, max:100, steps:5,label:""math""},
  
  
  x:{min:40, max:100, steps:4,label:""english""}
  
  
  };
  
 2. It's time for us to set up our other global variables and start up our 
 init
  function:
  
 var CHART_PADDING = 30; 
  
 var wid; 
  
 var hei; 
  
 function init(){
  
  var can = document.getElementById(""bar"");
  
  wid = can.width;
  
  hei = can.height;
  
  var context = can.getContext(""2d"");
  
  context.fillStyle = ""#eeeeee"";
  
  context.strokeStyle = ""#999999"";",NA
How it works...,"We start by creating a new 
 chartInfo
  object:
  
 var chartInfo= { y:{min:40, max:100, steps:5,label:""math""},
  
  
  x:{min:40, max:100, steps:4,label:""english""}
  
  
  };
  
 This very simple object encapsulates the rules that will define what our chart will actually 
 output. Looking closely you will see that we set an object named 
 chartInfo
  that has 
 information on the y and x axes. We have a minimum value (
 min
  property), maximum 
 value (
 max
  property), and the number of steps we want to have in our chart (
 steps
  
 property), and we define a label.
  
 Let's look deeper into the way the 
 fillChart
  function works. In essence we have two 
 numeric values; one is the actual space on the screen and the other is the value the space 
 represents. To match these values we need to know what our data range is and also what 
 our view range is, so we first start by finding our 
 startY
  point and our 
 endY
  point followed 
 by calculating the number of pixels between these two points:
  
 var startY = CHART_PADDING; 
  
 var endY = hei-CHART_PADDING; 
  
 var chartHeight = endY-
 startY;
  
 These values will be used when we try to figure out where to place the data from the 
 chartInfo
  object. As we are already speaking about that object, let's look at what we 
 do with it:
  
  var yData = chartInfo.y;
  
  var steps = yData.steps;
  
  var rangeLength = yData.max-yData.min;
  
  var stepSize = rangeLength/steps;",NA
Building line charts,"The line charts are based on scatter charts. Contrary to scatter charts that show isolated 
 correlation between two variables, the line chart tells a story in many ways; we can go back 
 to our previous recipe, 
 Spreading data in a scatter chart
 , and draw a line between the dots to 
 create the connection. This type of chart is usually used in website statistics, tracking things 
 over time, speed, age, and so on. Let's jump right into it and see it in action.",NA
Getting ready,"As usual get your HTML wrapper ready. In this recipe we actually are going to base 
 our changes on the previous recipe, 
 Spreading data in a scatter chart
 .
  
 In our case study for this example, we will create a chart that shows how many new 
 members joined my site, 
 02Geek.com
 , in 2011 and 2010. I've gathered the information 
 month by month and gathered it into two arrays:
  
 var a2011 = 
 [38,65,85,111,131,160,187,180,205,146,64,212]; var a2010 
 = [212,146,205,180,187,131,291,42,98,61,74,69];
  
 Both arrays have a length of 12 (for 12 months of the year). I've deliberately created a new 
 data source that is totally different than the one we used earlier. I did that to render our old 
 map useless in this example. I've done it to add some extra value into this recipe (a good 
 lesson in manipulating data to fit even when it doesn't, instead of rebuilding things).
  
 var chartInfo= { y:{min:0, max:300, steps:5,label:""users""},
  
  
  x:{min:1, max:12, steps:11,label:""months""}
  
  
  };
  
 For our chart information we are using the same object type and for the 
 y
  position we will 
 assume a range from 0 to 300 (as I haven't had the privilege of having more than 300 
 members in one month, yet I'm hopeful). For our 
 x
  position we are setting it to output values 
 from 1 through 12 (for the 12 months of the year).
  
 OK, it's time to build it!",NA
How to do it...,"As always, our 
 init
  function is going to look very similar to the one we used in the 
 previous recipe. Let's take a look at the modifications that have taken place in this recipe:
  
 1. Update/create the global variables:
  
 var a2011 = [38,65,85,111,131,160,187,180,205,146,64,212]; 
 var a2010 = [212,146,205,180,187,131,291,42,98,61,74,69];
  
 var chartInfo= { y:{min:0, max:300, steps:5,label:""users""},
  
  
  x:{min:1, max:12, steps:11,label:""months""}
  
  
  };
  
 var CHART_PADDING = 20; 
  
 var wid; 
  
 var hei;",NA
How it works...,"I've added a new method, 
 rect
 , to our tool set for drawing; until now we worked with the 
 drawRect
  method. I've used the 
 rect
  method as it just adds the outlines without drawing 
 anything, so I can perform the stroke or fill function separately and create an outline 
 instead of a fill.
  
 The 
 fillChart
  function did not change at all, cool right? And I've renamed the function 
 createDots
  to 
 addLine
  as it seemed more appropriate for our sample. A few additions 
 have been made into that function and a new function, 
 formatData
 , is being used to format 
 the data to fit what the 
 addLine
  function is expecting.
  
 As you probably noticed we made a few small changes to our code to accommodate the needs 
 of this chart style. Let's dive in and see them in action:
  
 addLine(context,formatData(a2011,""/2011"",""#B1DDF3""),""#B1DDF3"")
  
 The biggest change we can visibly see in the way we are calling the 
 addLine
  function is that 
 we are calling the 
 formatData
  function to render a data source for us that will be acceptable 
 by the 
 addLine
  function. You might be thinking right now, why didn't I just create the data 
 the way it needs to work for the 
 addLine
  function. When we move to the real, live data 
 sources many times we will find data sources that just don't match our original work. That 
 doesn't mean we need to change our work, often a better solution is to create a converter 
 method that will modify the data and rebuild it to match our application structure so it is in 
 the format we expect.",NA
There's more...,"Let's revisit our code and optimize it to be more adaptable. Our goal is to add more 
 flexibility to our chart to render in various modes.
  
 My goal here is to enable our chart to render in three render modes: dot mode (as in the 
 previous sample), line mode (in this sample), and fill mode (new addition):",NA
Creating the flying brick chart ,NA,NA
(waterfall chart),"In each recipe in this chapter we've been advancing the complexity of our code and so we are 
 going to revisit the bar chart and modernize it to fit our evolving charting platform. After we 
 complete this mini task, we will be ready to create our first waterfall chart breaking away 
 from the standard charts into more creative avenues.
  
  
 The waterfall chart is a very useful chart to outline trends, such as monthly total changes 
 (positive and negative) while outlining the total value of the big picture. This type of 
 chart helps to outline total assets of a company while showing if they made profits or 
 losses throughout the month. This type of chart is ideal for data that shifts between 
 positive/ negative values.",NA
Getting ready,"We will be taking advantage of the interface we created in the earlier recipes and as such we 
 will be integrating the creation of bars into our library of updated functions. To do that, we 
 will need to dig out our old 
 createBars
  function created in 
 03.02.bar-revamp.js
 .",NA
How to do it...,"The first step to create a waterfall chart is to copy, paste, and rename the function 
  
 createBars
  and then manipulate it and change the way the data is rendered (mainly where 
 and how we position elements). Notice what we change in this method before I dig deeper into 
 why and how it was done:
  
 1. Let's start with an updated data source:
  
 var a2011 = [60,60,60,111,-31,-80,0,-43,-29,14,64,12]; 
 var 
 chartInfo= { y:{min:0, max:300, steps:5,label:""users""},
  
  
 x:{min:1, max:12, steps:11,label:""months""}
  
  
  }; 
  
 var CHART_PADDING = 20; 
  
 var wid; 
  
 var hei;
  
 2. In the 
 init
  function we will update the following highlighted code snippets:
  
 function init(){
  
  
  …
  
  
  context.strokeStyle = ""#cccccc"";
  
  
  fillChart(context,chartInfo);
  
  
  createWaterfall(context,formatData(a2011)); 
 }
  
 3. Add a few helper variables:
  
 function createWaterfall(context,data){
  
  var range = chartInfo.x;
  
  var elementWidth =(wid-CHART_PADDING*2)/ data.length;
  
  var startY = CHART_PADDING;
  
  var endY = hei-CHART_PADDING;
  
  var chartHeight = endY-startY;
  
  var stepSize = chartHeight/(chartInfo.y.max-chartInfo.y.min); 
 var currentY= endY;
  
  var elementValue ;
  
  var total=0;
  
  context.textAlign = ""center"";",NA
How it works...,"The first step and the first problem when we start to think about how to create a waterfall 
 chart is that there is a relationship between each element. To simplify the logic we would want 
 to create a counter that would store the changes (the current summary value).
  
  var elementValue ;
  
  var total=0;
  
 The first variable is just a helper variable to try to make our code more readable while the 
 total is all about keeping up with what is the current total.",NA
There's more...,"Where we ended, leads us to the issue that we can't control the data and the more we ask of 
 the end user/developer to adjust, the longer the learning curve is. It's great that we have our 
 chartInfo
  object that stores most of our helper information, but what if someone doesn't 
 fill out the attributes? Should our application fail or should we do our best to figure out new 
 default values for the user? So let's say in this example the user does not fill out the 
 max
  and 
 min
  attributes of the 
 y
  object:
  
 var chartInfo= { y:{steps:5,label:""users""},
  
  x:{min:1, max:12, steps:11,label:""months""}
  
  };
  
 The user indicates how many steps they want, but they do not provide any information on 
 the smallest and largest values the chart should output. To solve this issue we need to revisit 
 the way we are creating our charts. So far we created the chart in two totally separate steps 
 (the last two lines in our 
 init
  function):
  
  fillChart(context,chartInfo);
  
  createWaterfall(context,formatData(a2011)); 
  
 First we usually create the background and then draw the items, but in this case we have a 
 much clearer relationship between the 
 fillchart
  function and the 
 createWaterfall 
 function. As we are trying to reduce the user's code footprint we wouldn't want to add a bunch 
 of logic for each sample that would be unique for each bar type. So instead we will revisit all 
 the graphic functions we created (
 addLine
 , 
 createBars
 , and 
 createWaterfall
 ) and move 
 the 
 fillChart
  function call to be the first thing in the functions. This will enable us to create 
 custom tweaks before calling the 
 fillChart
  function that would be invisible to the end user 
 of our functions (such as you in a few months, so you don't need to remember how everything 
 works). Everything should work the same for now but only our 
 createWaterfall
  function 
 will know how to deal with missing information (I'll leave it up to you to update the other 
 functions).
  
 function createWaterfall(context,data){
  
  fillChart(context,chartInfo);",NA
Building a candlestick chart (stock chart),"We are just about to make a super leap. Until now we worked with charts that had one data 
 point, two data points, and a few variations on them, and now we are moving into a new world 
 of four data points in every bar. The stock chart is a way to showcase changes in the market in 
 a given time frame (in our example this is one day). Each day stock prices change many times, 
 but the most important factors are the low and high values of the day and the opening and 
 closing prices. A stock analyst needs to be able to see the information quickly and understand 
 overall trends. We are skipping three data points elements, but we will be back to them in the 
 recipe 
 Building a bubble chart
  in
  Chapter 4
 , 
 Let's Curve Things Up
 .",NA
Getting ready,"Our first step is going to be a bit different in this recipe. I've created a sample CSV file called 
 DJI.txt
 ; you can find it in our source files. The format is the standard CSV format and the 
 first line names all the data columns:
  
 DATE,CLOSE,HIGH,LOW,OPEN,VOLUME
  
 And all future lines contain the data (daily data in our case):
  
 1309752000000,12479.88,12506.22,12446.05,12505.99,128662688
  
 So the steps we will need to go through are loading the file, converting the data to fit our 
 standard data set, and then build the new chart type (and then fixing things as we discover 
 issues; agile development).",NA
How to do it...,"We are going to base our work starting from where we left in the previous recipe. We will 
 start the modifications right in the JavaScript file:
  
 1. Let's update our global variables:
  
 var chartInfo= { y:{min:11500, 
 max:12900,steps:5,label:""close""},
  
  x:{min:1, max:12, 
 steps:11,label:""date""}
  
  
  }; 
  
 var stockData; 
  
 var CHART_PADDING = 20; 
  
 var wid; 
  
 var hei
  
 2. Before we start our internal logic, we need to load our new external CSV file. We will 
  
 rename the 
 init
  function and call it 
 startUp
  and then create a new 
 init
  function:
  
 function init(){
  
  var client = new XMLHttpRequest();
  
  client.open('GET', 'data/DJI.txt');
  
  client.onreadystatechange = function(e) {
  
  
  if(e.target.readyState==4){
  
  var aStockInfo = e.target.responseText.split(""\n""); 
 stockData = translateCSV(aStockInfo,7);
  
  startUp()
  
  
  }
  
  }
  
  
  
 client.send(); 
  
 }
  
 function startUp(){
  
  
  //old init function 
  
 }
  
 3. The data we get back from the CSV file needs to be formatted to a structure we can 
 work with. For that we create the 
 translateCSV
  function that takes in the raw CSV 
 data and converts it into an object that matches our architecture needs:
  
 function translateCSV(data,startIndex){
  
  startIndex|=1; //if nothing set set to 1
  
  var newData = [];
  
  var aCurrent;",NA
How it works...,"Let's review the steps to load our external file. If you are working with open source tools 
 such as jQuery you will be better off using them to load external files but, to avoid using 
 other libraries, we will work with the 
 XMLHttpRequest
  object as it's supported in all 
 modern browsers that support HTML5.
  
 We start with creating a new 
 XMLHttpRequest
  object:
  
 var client = new XMLHttpRequest(); 
  
 client.open('GET', 'data/DJI.txt');
  
 The next step is to set what we want to do (
 GET/POST
 ) and the name of the file, followed by 
 creating a handler function for the 
 onreadystatechange
  callback and sending our request.
  
 client.onreadystatechange = function(e) {
  
  
  if(e.target.readyState==4){
  
  
  var aStockInfo = e.target.responseText.split(""\n"");
  
  
 stockData = translateCSV(aStockInfo,1);
  
    
  startUp()
  
  }
  
  }
  
  client.send();
  
 The event handler 
 onreadystatechange
  gets called a few times throughout the loading 
 process of a file. We only want to listen in and act once the file is loaded and ready to be 
 played with; to do that we will check whether the 
 readyState
  variable is equal to four 
 (ready and loaded). When the file is loaded, we want to split our file into an array based 
 on line breaks.",NA
There's more...,"It's time to fix our 
 x
  coordinate values:
  
 var chartInfo= { y:{min:11500, max:12900,steps:5,label:""close""},
  
 x:{min:1, max:12, steps:11,label:""date""}
  
  };
  
 We didn't change this variable before as until now there was a clear separation between the 
 outline and our content (the chart itself); but at this stage as our 
 x
  outline content isn't a 
 linear number anymore but a date; we need to somehow introduce into the 
 fillChart 
 method external data that is related to the content of the chart. The biggest challenge here is 
 that we don't want to introduce into this method something that is only relevant to our chart 
 as this is a globally used function. Instead we want to put our unique data in an external 
 function and send that function in as a formatter. So let's get started:
  
 var chartInfo= { y:{min:11500, max:12900,steps:5,label:""close""},
  
 x:{label:""date"",formatter:weeklyCapture}
  
  };
  
 Our 
 x
  space in a stock chart represents time and as such our previous usage based on linear 
 data does not apply (the properties such as 
 min
 , 
 max
 , and 
 steps
  have no meaning in this 
 case). We will remove them in favor of a new property 
 formatter
  that will take a function 
 as its value. We will use this 
 formatter
  function instead of the default function. If this 
 function is set we will let an external function define the rules. We will see more on this 
 when we describe the 
 weeklyCapture
  function. This method of coding is called plugin 
 coding. 
  
 Its name is derived out of the idea of enabling us to create replaceable functions without 
 reworking our core logic in the future. Before we create the 
 weeklyCapture
  function, let's 
 tweak the 
 chartInfo
  object so we have the right range and number of steps:
  
 function addStock(context,data){
  
  
  if(!chartInfo.x.max){
  
  
  chartInfo.x.min = 0;
  
  
  chartInfo.x.max = data.length;
  
  
  chartInfo.x.steps = data.length; 
  
  
  }
  
  fillChart(context,chartInfo);
  
 …",NA
4 ,NA,NA
Let's Curve Things Up,"In this chapter we will cover:
  
 f 
  
 Building a bubble chart
  
 f 
  
 Creating a pie chart
  
 f 
  
 Using a doughnut chart to show relationships
  
 f 
  
 Leveraging a radar
  
 f 
  
 Structuring a tree chart",NA
Introduction,"In the last chapter, we built a component for linear graphs ranging through dots, lines, and 
 bars. Most of the data we worked with was two-dimensional, while we ended our lesson with 
 a four-dimensional chart. It was still represented using linear art. In this chapter, we will 
 leverage the capability of creating non-linear data to represent data.",NA
Building a bubble chart,"Although many items in our chart will have correlations with earlier charts that we created 
 in 
 Chapter 3
 , 
 Creating Cartesian-based Graphs
 , we will start from scratch. Our goal is to create 
 a chart that has bubbles in it—the bubbles enable us to showcase data with three data points 
 (x, y, and the size of the bubble). This type of chart is really ideal when animated as it can 
 showcase changes over time (it could showcase many years in a few seconds).",NA
Getting ready,"We will start up our project with a canvas setup and skip the HTML end. If you have 
 forgotten how to create it please refer to the 
 Graphics with 2D Canvas
  recipe in 
 Chapter 1
 , 
 Drawing Shapes in Canvas
 .
  
 There are three major steps:
  
 f 
  
 Creating the data source
  
 f 
  
 Creating the background
  
 f 
  
 Adding the chart data info into the chart",NA
How to do it...,"Let's list the steps required to create a bubble chart:
  
 1. The next data object should look familiar in an array that has objects within it with 
  
 student scores in English, Math, and programming. Build the data object:
  
 var students2001 = [{name:""Ben"",
  
  math:30,
  
  english:60,
  
  programing:30},
  
  {name:""Joe"",
  
  math:40,",NA
How it works...,"Let's start with the 
 createOutline
  function. In this method, apart from the regular canvas 
 drawing methods that we grow to love, we introduce a new style of coding where we 
 manipulate the actual canvas to help us define our code in an easier way. The two important 
 key methods here are as follows:
  
 context.save(); 
  
 context.restore()
 ;
  
 We will be leveraging both the methods a few times. The 
 save
  method saves the current 
 view of the canvas while the 
 restore
  method returns users to the last saved canvas:
  
 context.save(); 
  
 context.translate(17, hei/2 ); 
  
 context.rotate(-Math.PI/2); 
  
 context.textAlign = ""center""; 
  
 context.fillText(chartInfo.y.label, 0, 0); 
  
 context.restore();
  
 In the first use of this style, we are using it to draw our text by rotating it to the right. The 
 translate
  method moves the 
 0,0
  coordinates of the canvas while the 
 rotate
  method 
 rotates the text using radians.
  
 After drawing the external bars, it's time for us to use this new capability to our advantage. 
  
 Most charts rely on a y coordinate that grows upwards, but this canvas has the y values 
 growing from the top to the bottom of the canvas area. We can flip this relationship by 
 adding some code before we loop through to add the range values.
  
 context.translate(pad+barSize,hei-pad-barSize); 
 context.scale(1, -1);",NA
Creating a pie chart,"The steps to create a pie chart are relatively easy and short. Pie charts are ideal for 
 showcasing a closed amount of data that we want to easily compare between data fields such 
 as, in our example, dividing the number of people in the world into groups based on their 
 region:",NA
Getting ready,"The first step will be to update our canvas size in the HTML area to be a rectangular area. 
 In our sample, we will update the values to 400 x 400. That's about it; let's start building 
 it.",NA
How to do it...,"In the following steps we will create our first pie chart. Let's get started:
  
 1. Set up our data source and our global variables:
  
 var data= [ 
  
 {label:""Asia"", value:3518000000,style:""#B1DDF3""},
  
  {label:""Africa"", value:839000000,style:""#FFDE89""},
  
  {label:""Europe"", value:803000000,style:""#E3675C""},
  
  {label:""Latin America and Caribbean"", value:",NA
How it works...,"Our pie chart, as its name indicates, uses pies and always showcases 100 percent of data. As 
 our arc method works based on radians, we need to convert these data points from 
 percentile to radians.
  
 After figuring out what the total of all the values is and the total radians in a circle (
 2*PI
 ), 
 we are ready to loop through and draw the slices.
  
 var currentTotal=0;
  
  
  for(i=0; i<data.length; i++){
  
  
  context.beginPath();
  
  
  context.moveTo(0,0);
  
  
  context.fillStyle = data[i].style;
  
 The logic is relatively simple; we loop through all the data elements, change the fill style based 
 on the data object, and move our pointer to 
 0,0
  (to the center of our screen as we have 
 changed the pivot point of our canvas).
  
 context.arc( 0,0,radius,currentTotal/total*rad360,(currentTotal+data 
 [i].value)/total*rad360,false); 
  
 context.lineTo(0,0); 
  
 context.closePath(); 
  
 context.fill(); 
  
 currentTotal+=data[i].value;
  
 Now we draw the arc. Pay attention to the highlighted text; we start with where we left off 
 our current total and through that we calculate the angle in radians:
  
 currentTotal/total*rad360
  
 We can turn this value into a percentage value that we can duplicate against the total radian of 
 our circle. Our second parameter is very close, so we just add into it the current value of the 
 current region we are in:
  
 (currentTotal+data[i].value)/total*rad360
  
 And the last point to note here is that we are setting the arc's last parameter to 
 false 
 (counter clockwise) as that works best for our calculations.
  
 Last but not least, we update our 
 currentTotal
  value to encompass the newly added 
 region as that will be our starting point in the next round of our 
 for
  loop.",NA
There's more...,"A pie chart without any information on its content is probably not going to work as well as a 
 chart with information, but we can figure out the locations... well worry not; we are going to 
 revisit our old friends 
 cos
  and 
 sin
  to help us locate the dots on our circle, to enable us to add 
 textual information on our newly created pie.
  
 Revisiting Math.cos() and Math.sin()
  
 We will start with adding a new global variable to store the color of our lines and then we 
 will call it 
 copyStyle
 :
  
 var copyStyle = ""#0000000000"";
  
 Now that we are right back into our 
 init
  function, let's add it into our 
 for
  loop just before 
 the last line:
  
 currentTotal+=data[i].value;
  
 As expected, we will first set our new 
 copyStyle
  variable as our fill and stroke value:
  
 context.strokeStype = context.fillStyle =  copyStyle;
  
 Our next step is to locate where in our pie we would like to draw a line out so that we can 
 add the text:
  
 midRadian = (currentTotal+data[i].value/2)/total*rad360;
  
 To accomplish this, we will use a new variable that will store the mid-value between the 
 last total and the new value (the center of the new slice). So far so good. Now we need to 
 figure out how to get the x and y positions of that point. Lucky for us, there is a very easy 
 way of doing it in a circle by using the 
 Math.cos
  (for the x) and 
 Math.sin
  (for our y) 
 functions:
  
 context.beginPath();
  
 context.moveTo(Math.cos(midRadian)*radius,Math.sin(midRadian)*radius);
  
 context.lineTo(Math.cos(midRadian)*(radius+20),Math. 
 sin(midRadian)*(radius+20));
  
 context.stroke();
  
 Armed with our 
 midRadian
  variable, we will get the value for a circle with a radius of 
 1
 , so 
 all that is left for us to do is duplicate that value by our real radius to find our starting point. 
 As we want to draw a line in the same direction to the arc externally, we will find the points 
 of an imaginary circle that is larger; so for that we are going to use the same formula, but 
 instead upgrade our radius values by 20, creating a diagonal line that is correlative to the 
 arc.",NA
Using a doughnut chart to show ,NA,NA
relationships,"The doughnut chart is a fancy pie chart. So if you haven't created a pie chart yet, I strongly 
 encourage you to revisit the previous recipe, 
 Creating a pie chart
 . A doughnut chart is a 
 layered pie chart. This chart is ideal for condensing the comparable data between data types 
 that would fit into a pie chart:",NA
Getting ready,"We are going to grab our code from the last example and adjust it to fit our needs. So we will 
 start with the same HTML file and the same code from the last example.",NA
How to do it...,"Perform the following steps:
  
 1. Let's update our data with some dummy data (we will create two data objects):
  
 var data1= [ {label:""Asia"", value:3518000000,style:""#B1DDF3""},
  
  {label:""Africa"", value:839000000,style:""#FFDE89""},
  
  
  {label:""Europe"", value:803000000,style:""#E3675C""},
  
  
  {label:""Latin America and Caribbean"", value:  
  
  
  539000000,style:""#C2D985""},
  
  
  {label:""North America"",  
  
  
  value:320000000,style:""#999999""},
  
  
  {label:""Near East"", value:179000000,style:""#666666""} 
  
 ];
  
 var data2= [ {label:""Asia"", value:151000,style:""#B1DDF3""},
  
  {label:""Africa"", value:232000,style:""#FFDE89""},
  
  
  {label:""Europe"", value:842000,style:""#E3675C""},
  
  
  {label:""Latin America and Caribbean"", value:  
  
  
  538100,style:""#C2D985""},
  
  
  {label:""North America"", value:3200,style:""#999999""},
  
  {label:""Near East"", value:17900,style:""#666666""} 
  
 ];
  
 2. Modify the 
 init
  function by extracting all the pie-creating lines to a separate function 
  
 and adding a new function 
 createHole
  (for our doughnut):
  
 function init(){
  
  
  var can = document.getElementById(""bar"");
  
  wid = can.width;
  
  hei = can.height;
  
  var context = can.getContext(""2d"");
  
  context.translate(wid/2,hei/2);
  
  
  createPie(context,data1,190);
  
  
  createPie(context,data2,150);
  
  
  createHole(context,100); 
  
 }
  
 3. Modify the pie creation to change the text layout to fit into a pie chart:
  
 function createPie(context,data,radius){
  
  var total=0;
  
  for(var i=0; i<data.length;i++) total+=data[i].value;",NA
How it works...,"The core logic of the doughnut chart is the same as that of the pie chart. Our main focus is 
 really about reformatting and rewiring the content to be outlined at the visual level. As such, 
 part of our work is to delete the things that are not relevant and to make the needed 
 updates:
  
 context.fillText(formatToPercent(data[i].value/total),Math. 
 cos(midRadian)*(radius-20),Math.sin(midRadian)*(radius-20) );
  
 The main thing to note is that we are hardcoding a value that is 20 less than the current 
 radius. If we wanted our sample to work for every possible option, we would need to figure 
 out a smarter way of generating this data as ideally we would want the text to be in between 
 the doughnut area and rotated, but we have done things of that nature before so I'll leave 
 that for you to explore.",NA
There's more...,"Although our doughnut is created and ready, it would help if we add some more information 
 to it, such as outlines and a legend, as we extracted the majority of the text from the last 
 example.
  
 Adding an outline
  
 We will use shadows to create a glow around our shapes. The easiest and quickest way to do 
 it is to revisit the 
 init
  function and add into it the shadow information to create this effect:
  
 function init(){
  
  var can = document.getElementById(""bar"");
  
  wid = can.width;
  
  hei = can.height;
  
  var context = can.getContext(""2d"");
  
  context.translate(wid/2,hei/2);
  
  context.shadowOffsetX = 0;
  
  context.shadowOffsetY = 0;
  
  context.shadowBlur    = 8;
  
  context.shadowColor   = 'rgba(0, 0, 0, 0.5)';
  
  createPie(context,data1,190);
  
  createPie(context,data2,150);
  
  createHole(context,100);
  
 }",NA
See also,"f 
  
 The 
 Creating a pie chart
  recipe",NA
Leveraging a radar,"Radars are very misunderstood charts but are really amazing. A radar enables us to showcase 
 a really large amount of comparable data in a very condensed way. The radar chart is known 
 as a spider chart as well.",NA
Getting ready ,"As always, we are going to start with our base HTML page with an 
 init
  callback.
  
  
 Note
  
  
 A radar chart is really a line chart wrapped up into a circular shape with a 
  
 lot of different math involved; but it's the same idea—instead of spreading 
  
 our data horizontally, we are spreading our data around a center point.",NA
How to do it...,"Let's see what are the steps involved in creating a radar chart:
  
 1. Create/Organize the chart data and the actual data:
  
 var data=[{label:""Ben"", style:""#E3675C"", math:90,english:45,spanis 
 h:25,programing:90,bible:20,art:90},
  
  
  {label:""Sharon"", style:""#C2D985"", math:100,english:90,spanish:60 
 ,programing:27,bible:80,art:20}];
  
 var chartInfo= {steps:10, max:100, types:[""math"",""english"",""spanis 
 h"",""programing"",""bible"",""art""]};
  
 2. Add a few helper variables and an 
 init
  function:
  
 var wid; 
  
 var hei; 
  
 var copyStyle = ""#0000000000""; 
  
 var radius = 180; 
  
 var radianOffset = Math.PI/2
  
 function init(){
  
  
  var can = document.getElementById(""bar"");
  
  wid = can.width;
  
  hei = can.height;
  
  var context = can.getContext(""2d"");
  
  
  createSpider(context,chartInfo,data); 
  
 }
  
 3. Now it is time to create the 
 createSpider
  function:
  
 function createSpider(context,chartInfo,data){ 
 drawWeb(context,chartInfo,radius);
  
  drawDataWeb(context,chartInfo,data,radius);
  
 }
  
 4. We split the creation of the radar web into two stages. The first is the lines coming out 
 of the center of the web and the other is the actual webs that loop around this center 
 point. Let's start with the first step and continue to the next part in the second loop:
  
 function drawWeb(context,chartInfo,radius){
  
  chartInfo.stepSize = chartInfo.max/chartInfo.steps; 
 var hSteps = chartInfo.types.length;
  
  var hStepSize = (Math.PI*2)/hSteps;
  
  context.translate(wid/2,hei/2);",NA
How it works...,"The radar chart is one of our more complicated chart types. So far it uses a lot of cos/sin 
 functions, but the logic is very consistent and as such relatively simple.
  
 Let's take a deeper look into the 
 drawWeb
  method:
  
 chartInfo.stepSize = chartInfo.max/chartInfo.steps; 
 var hSteps = chartInfo.types.length; 
  
 var hStepSize = (Math.PI*2)/hSteps; 
  
 context.translate(wid/2,hei/2); 
  
 context.strokeStyle = ""#000000"";
  
 We start by creating a few helper variables and repositioning our pivot point to the 
 center of the screen to help us with our calculations.
  
 for(var i=0; i<hSteps; i++){
  
  
  context.moveTo(0,0);
  
  
  context.lineTo(Math.cos(hStepSize*i +  
  
  
  radianOffset)*(radius+20),Math.sin(hStepSize*i +  
  
  radianOffset)*(radius+20)); 
  
 }
  
 We then create our spikes based on the number of courses, as each course will be 
 represented with a spike.
  
 It's time to create the interwebs of our spider web now that we have our core 
 building blocks (the spikes):
  
 var stepSize = 
 radius/chartInfo.steps;
  
  
  var cRad;",NA
There's more...,"Our radar isn't perfect as it could use a legend and some textual information around our radar 
 so that we know what each bar represents. We will let you sort out a legend as we've done in 
 the previous recipe 
 Using a doughnut chart to show relationships
 .
  
 Adding a rotated legend 
  
 To fix this issue and add our text, we will revisit our function 
 drawWeb
  with our first loop in 
 that function, and instead of updating the cos/sin values to find the rotation, we will just 
 rotate our canvas and integrate our text at the edge each time:
  
 function drawWeb(context,chartInfo,radius){
  
  chartInfo.stepSize = chartInfo.max/chartInfo.steps; 
 var hSteps = chartInfo.types.length;
  
  var hStepSize = (Math.PI*2)/hSteps;
  
  context.translate(wid/2,hei/2);
  
  context.strokeStyle = ""#000000"";",NA
Structuring a tree chart,"There are many types of trees in the virtual world, although the most intuitive one is a family 
 tree. A family tree is a bit more complex than a basic data tree such as a class inheritance 
 tree, as for the most part classes have only one parent while family trees usually have two.
  
 We will build an inheritance tree for the display objects of ActionScript 3.0.",NA
Getting ready,"Please note that this sample is cutting edge in HTML5. One of the new features that no one 
 really knows whether will get adopted or not is E4X. It's been embraced by Firefox, but not 
 all browsers have implemented it (it is fully supported in Flash as well).
  
 ECMAScript for XML (E4X) is a programming language extension that adds native XML 
 support to ECMAScript. It has replaced the DOM interface and is implemented as a primitive 
 (such as numbers and Booleans), making it faster and more optimized.
  
 As we are mainly working locally, we are going to save our XML document directly in 
 our JavaScript to avoid sandbox security issues.",NA
How to do it...,"Perform the following steps:
  
 1. We will start by creating our XML object that contains our class tree (please note 
 that this will only work on an up-to-date version of Firefox as at the time of this 
 book being written):
  
 var xml = <node name =""Display Object""> 
  
 <node name=""AVM1Mobie"" />
  
  
  <node name=""Bitmap"" />
  
  
  <node name=""InteractiveObject"" >
  
  
  <node name=""DisplayObjectContainer"">
  
  
  <node name=""Loader"" /> 
  
  
  <node name=""Sprite"" >
  
  
  <node name=""MovieClip""/> 
  
 </node> 
  
 <node name=""Stage"" /> 
  
 </node> 
  
 <node name=""SimpleButton"" /> 
  
  
  <node name=""TextField"" /> 
  
 </node>
  
  
  <node name=""MorphShape"" />
  
  
  <node name=""Shape"" />",NA
How it works...,"For more information on how E4X works, I recommend checking out some online 
 resources such as 
 http://goo.gl/jLWYd
  and 
 http://goo.gl/dsHD4
 .
  
 Let's take a deeper look at how our recursive 
 drawTree
  works. The basic idea of 
 createTree 
 is to create the current node in focus and to check if the node has children; if it 
 does, to send them to the 
 drawTree
  and have them recursively continue until all the 
 children are created and done. One of the most critical things you need to worry about when 
 creating a recursive function (a function that calls itself) is to make sure that it doesn't end 
 up being endless, and as our scenario has a very defined end that is based on the XML 
 structure, we are safe.
  
 We start by creating the current node in focus, based on the point values that were sent over 
 in our function's parameters:
  
 context.fillStyle=style.boxColor; 
  
 context.fillRect(_x-style.boxWidth/2,_y-style.boxHeight/2,style.
  
 boxWidth,style.boxHeight); 
  
 context.fillStyle=style.boxCopy; 
  
 context.fillText(node.@name,_x,_y+8);
  
 Right after these lines is where it starts getting really interesting. If our node is complex, 
 we are going to assume that it has children, as that's our base rule in creating our XML 
 object; and if so, it's time for us to draw the children:
  
 if(node.hasComplexContent()){
  
 We start by drawing a visualizer bar to help us see what the children of the current 
 element are, and create a few helper variables in the process:
  
 var nodes = node.node; 
  
 var totalWidthOfNewLayer = nodes.length()* 
 style.boxWidth; if(nodes.length()>1)",NA
There's more...,"In a perfect world our work with our tree would be done by now, but many a time in real-
 world scenarios we would encounter issues. If we play with our current tree enough, we will 
 discover visual issues, such as if a child node has more than one child, its children will 
 overlap the other tree branches. For example, if we update our 
 Loader
  class to have two 
 new children (two dummy classes just for the sake of our example):
  
 var xml = <node name =""Display Object"">
  
  <node name=""AVM1Mobie"" />
  
  <node name=""Bitmap"" />
  
  <node name=""InteractiveObject"" >
  
  <node name=""DisplayObjectContainer"">
  
  <node name=""Loader"">
  
  <node name=""SlideLoader""/>
  
  <node name=""ImageLoader""/>
  
  </node>",NA
5 ,NA,NA
Getting Out of the Box,"In this chapter we will cover:
  
 f 
  
 Going though a funnel (a pyramid chart)
  
 f 
  
 Revisiting lines: making the line chart interactive
  
 f 
  
 Tree mapping and recursiveness
  
 f 
  
 Adding user interaction into tree mapping
  
 f 
  
 Making an interactive click meter",NA
Introduction,"We have covered our bases with the majority of the standard charts. At this stage, it's time 
  
 for us to become more creative with our charts. From this chapter onwards, we will progress 
  
 into more out-of-the-box, less commonly used charts and revisit some of our old charts to 
  
 incorporate dynamic data into them or to change their layout.",NA
Going through a funnel (a pyramid chart),"It's rare that you see a pyramid chart that is actually created dynamically. For the most part, 
 they're designed and fleshed out creatively and turn into a 
 .jpg
  file when they reach the web, 
 and that's exactly why I wanted to start this chapter with this chart—it's not as complex as it 
 might sound.
  
  
 A pyramid chart is in essence a way for us to visualize changes in data that are quantitative 
 by nature. They have a clear relationship between the lower layers and the higher layers. 
 That sounded very vague, so let's explain it through an example.
  
 Imagine that X amount of people complete their eighth year of school in a given year, if we 
 follow the same group of people, how many of them would have completed their twelfth 
 year of education four years later? Fair enough! We can't know the answer to that, but one 
 thing we do know is that it can't be more than the initial X amount of people. The idea of a 
 pyramid chart is exactly that of a body of data, of which less and less goes through the funnel 
 as time or something else changes It's a really great chart to compare between levels of 
 education, finance, involvement in politics, and so on.",NA
Getting ready,"Just as always, set up our HTML file logic. For a refresher on how to start up the HTML 
 file, please go back to the 
 Graphics with 2D canvas
  recipe in 
 Chapter 1
 , 
 Drawing Shapes 
 in Canvas
 .",NA
How to do it...,"Beyond our standard HTML preparation, we need to come up with the data sources that 
 we wish to showcase. Let's start building our pyramid. Go right into the JS file and let's 
 start.
  
 1. For our example, we will create a pyramid to find out how many people that read this 
 book from chapter one through chapter five actually reach chapter five (this data is 
 fake; I hope everyone that starts reading will get there!).
  
 var layers = [{label:""Completed Chapter 1"", amount:23}, 
 {label:""Completed Chapter 2"", amount:15},
  
  {label:""Completed Chapter 3"", amount:11},
  
  {label:""Completed Chapter 4"", amount:7},
  
  {label:""Completed Chapter 5"", amount:3} ];
  
 2. Then, provide some charting and styling information.
  
 var chartInfo= {height:200, width:200};
  
 var s = { outlinePadding:4,
  
  
  barSize:16,
  
  
  font:""12pt Verdana, sans-serif"",
  
  
  background:""eeeeee"",
  
  
  stroke:""cccccc"",
  
  
  text:""605050"" 
  
 };
  
  
 Note that, for the first time, we are differentiating 
  
  
 between what we want the size of our canvas to be 
  
 and the actual size of our chart (funnel/triangle). 
  
 Another important thing to note is that, for our sample 
  
 to work in its current format, our triangle height and 
  
 width (base) must be the same.
  
 3. Define a few global helper variables.
  
 var wid; 
  
 var hei; 
  
 var totalPixels; 
  
 var totalData=0; 
  
 var pixelsPerData; 
  
 var currentTriangleHeight = chartInfo.height;",NA
How it works...,"After setting the code for lines in the 
 init
  function, we are ready to start thinking about 
 our triangle. First, we need to find out the total pixels that are within our triangle.
  
 totalPixels = (chartInfo.height * chartInfo.width) / 2;
  
 That is easy as we know our height and our width, so the formula is really simple. The next 
 data point that is critical is the total amount of data. We can create a relationship between the 
 pixels and the data.
  
 for(var i in layers) totalData +=layers[i].amount;
  
 As such, we loop through all the data layers and calculate the summary of all data points. 
 At this stage, we are ready to find out the actual number of pixels. Each data element is 
 equivalent to:
  
 pixelsPerData = totalPixels/totalData;
  
 After setting up the styles for our stroke and fill, we stop to think about the best translation 
 that would help us build our triangle. For our triangle, I've picked the top edge to be the 
 0,0 
 point, after creating the triangle:
  
 context.translate(wid/2,hei/2 - chartInfo.height/2);
  
 context.moveTo(-chartInfo.width/2 , chartInfo.height);
  
 context.lineTo(chartInfo.width/2,chartInfo.height);
  
 context.lineTo(0,0);
  
 context.lineTo(-chartInfo.width/2 , chartInfo.height);
  
 The last two lines of our 
 init
  function call the 
 findLine
  method for each element in 
 our 
 layers
  array:
  
 for(i=0; i+1<layers.length; i++) findLine(context, layers[i].amount);
  
 context.stroke();
  
 Time to dig into how the 
 findLine
  function actually finds the points to create the lines. 
  
 The idea is very simple. The basic idea is to try to find out how many lines it would take to 
 complete the number of pixels in a triangle. As we are not building a math formula, we 
 don't care if it's 100 percent accurate, but it should be accurate enough to work visually.",NA
There's more...,"Let's start with introducing color into our pallet.
  
 var layers = [{label:""Completed Chapter 1"", amount:23, 
 style:""#B1DDF3""},  {label:""Completed Chapter 2"", amount:15, 
 style:""#FFDE89""},
  
  
  {label:""Completed Chapter 3"", amount:11, style:""#E3675C""},
  
  {label:""Completed Chapter 4"", amount:7, style:""#C2D985""},
  
  {label:""Completed Chapter 5"", amount:3, style:""#999999""}];
  
 OK, we are done with the easy part. Now, it's time to rework our logic.
  
 Making findLine smarter 
  
 For us to be able to create a closed shape, we need to have a way to change the direction of 
 the line drawn from right to left or from left to right and not have it go in one direction 
 always. Beyond that, we are using 
 moveTo
  right now and as such can never create a closed 
 shape. 
  
 What we actually want is to move our point and draw a line:
  
 function findLine(context,val,isMove){
  
  var newHeight = currentTriangleHeight;
  
  var pixels = pixelsPerData * val;
  
  var lines = parseInt(pixels/newHeight); //rounded
  
  pixels = lines*lines/2; //missing pixels
  
  newHeight-=lines;
  
  lines += parseInt(pixels/newHeight);
  
  currentTriangleHeight-=lines;
  
  
  if(isMove){
  
  
  c
 ontext.moveTo(currentTriangleHeight/2,
  
  
 currentTriangleHeight);
  
  
  context.lineTo(-currentTriangleHeight/2 ,  
  
  currentTriangleHeight);
  
  
  }else{
  
  
  context.lineTo(-currentTriangleHeight/2 ,  
  
  currentTriangleHeight);
  
  
  context.lineTo(currentTriangleHeight/2, 
  
  
 currentTriangleHeight); 
  
  
  } 
  
 }",NA
Revisiting lines: making the line chart interactive,"In this recipe, we will travel back in time to one of our earlier recipes, 
 Building line charts in 
 Chapter 3
 , 
 Creating Cartesian-based Graphs
  and add some user control to it. This control 
 enables the user to turn on and off the streams of data.",NA
Getting ready,"The first step that you will need to take is to grab the source code from 
 Chapter 3
 , 
 Creating Cartesian-based Graphs
 . We will rename 
 03.05.line-revamp.html
  and 
 03.05.line-revamp.js
  to 
 05.02.line-revisit
 .
  
 Now that we have our files up to date, add our HTML file—three radio groups to represent 
 the three data sources (years 2009, 2010, and 2011).
  
 <hr/>
  
  2009 : <input type=""radio"" name=""i2009"" value=""-1"" /> off
  
  <input type=""radio"" name=""i2009"" value=""0"" /> line
  
  
  <input type=""radio"" name=""i2009"" value=""1"" select=""1"" />  
  
  full<br/>
  
  2010 : <input type=""radio"" name=""i2010"" value=""-1"" /> off
  
  <input type=""radio"" name=""i2010"" value=""0"" /> line
  
  
  <input type=""radio"" name=""i2010"" value=""1"" select=""1"" />  
  
  full<br/>
  
  
  2011 : <input type=""radio"" name=""i2011"" value=""-1"" /> off
  
  <input type=""radio"" name=""i2011"" value=""0"" /> line
  
  
  <input type=""radio"" name=""i2011"" value=""1"" select=""1"" />  
  
  full<br/>
  
 Note that I've named each radio group with ""i"" added to the year and set the possible 
 values to be 
 -1
 , 
 0
 , or 
 1
 .",NA
How to do it...,"Perform the following steps:
  
 1. Create a few constants (well, variables that are not going to change), and set the 
 following three lines, now that the default values have already been assigned:
  
 var HIDE_ELEMENT = -1; 
  
 var LINE_ELEMENT = 0; 
  
 var FILL_ELEMENT = 1;
  
 var elementStatus={ i2009:FILL_ELEMENT,
  
  i2010:FILL_ELEMENT,
  
  i2011:FILL_ELEMENT};",NA
How it works...,"We haven't planned for user interaction on this chart in advance. As such, we need to revisit it 
 to change some of the logic. When Canvas draws something, that's it, it's there forever! We 
 can't just delete an object, as there are no objects in Canvas, and as such, we need a way to 
 redraw on demand. To accomplish that, we need to extract all the drawing logic from the 
 init
  
 function and create the 
 drawChart
  function. Besides adding our logic to the end of the 
 function, we also need to add the start of the function:
  
 context.lineWidth = 1;
  
 Although we originally worked out the default to use as the width for our background, in 
 a second redraw, our canvas would still have stored its last size (in our case it could be 
 3
 ), and as such, we reset it to the original value.",NA
There's more...,"Unfortunately, because we are not using any open source library, the built-in HTML 
 capabilities don't allow us to set events to groups of radios, and as such, we need to find them 
 all and add the 
 onchange
  event to them using the IDs we are storing in our 
 elementStatus
  
 controller.
  
 var radios ;
  
  
  for(var id in elementStatus){
  
  
  radios = document.getElementsByName(id);
  
  
  for (var rid in radios){
  
    
  radios[rid].onchange = onChangedRadio;
  
    
  if(radios[rid].value == elementStatus[id] )  
    
  radios[rid].checked = true; 
  
  
  }
  
  }
  
 Pay attention to the highlighted code. Here, we are checking to see whether our current 
 radio button's value matches our element value in 
 elementStatus
 . If it does, it means that 
 the radio button will be selected.",NA
See also,"f 
  
 The 
 Building line charts
  recipe in 
 Chapter 3
 , 
 Creating Cartesian-based Graphs",NA
Tree mapping and recursiveness,"Tree mapping enables us to see in-depth data from a bird's-eye view. Contrary to 
 comparative charts—such as most of the charts that we have created until now—tree 
 mapping displays tree structured data as a set of nested rectangles, enabling us to visualize 
 their quantitative nature and relationship.
  
  
 Let's start with a tree mapping that showcases only one level of information.",NA
Getting ready,"We will start our application with the number of people in the world, in millions, divided 
 by continent (based on public data from 2011).
  
 var chartData = [
  
  
  {name: ""Asia"", value:4216},
  
  
  {name: ""Africa"",value:1051},
  
  
  {name: ""The Americas and the Caribbean"", 
 value:942},
  
  {name: ""Europe"", value:740},
  
  
  {name: ""Oceania"", value:37} 
  
 ];
  
 We will update this data source later in our example, so keep in mind that this dataset 
 is temporary.",NA
How to do it...,"We will start by creating a simple, working, flat tree chart. Let's jump right into it and figure 
 out the steps involved in creating the tree map:
  
 1. Let's add a few helper variables on top of our dataset.
  
 var wid; 
  
 var hei; 
  
 var 
 context; 
  
 var 
 total=0;
  
 2. Create the 
 init
  function.
  
 function init(){
  
  
  var can = document.getElementById(""bar"");
  
  wid = can.width;
  
  hei = can.height;
  
  context = can.getContext(""2d"");
  
  for(var item in chartData) total +=  
  
  chartData[item].value;
  
  context.fillRect(0,0,wid,hei);
  
  context.fillStyle = ""RGB(255,255,255)"";
  
  context.fillRect(5,5,wid-10,hei-10);
  
  context.translate(5,5);
  
  wid-=10;
  
  hei-=10;
  
  drawTreeMap(chartData);
  
 }",NA
How it works...,"Let's start with the initial idea. Our goal is to create a map that will showcase the bigger 
 volume areas inside our rectangular area and leave a strip on the side for the smaller areas. 
 So, let's start with our 
 init
  function. Our first task beyond our basic getting started work is 
 to calculate the actual total. We do that by looping through our data source, thus:
  
 for(var item in chartData) total += chartData[item].value;
  
 We continued with some playing around with the design and making our work area 10 
 pixels smaller than our total canvas size.
  
 CONTEXT.FILLRECT(0,0,WID,HEI); 
  
 CONTEXT.FILLSTYLE = ""RGB(255,255,255)""; 
  
 CONTEXT.FILLRECT(5,5,WID-10,HEI-10); 
  
 CONTEXT.TRANSLATE(5,5); 
  
 WID-=10; 
  
 HEI-=10;
  
 drawTreeMap(chartData);
  
 It's time to take a look into how our 
 drawTreeMap
  function works. The first thing to notice 
 is that we send in an array instead of working directly with our data source. We do that 
 because we want to be open to the idea that this function will be re-used when we start 
 building the inner depths of this visualization type.
  
 function drawTreeMap(infoArray){...}
  
 We start our function with a few helper variables (the 
 percent
  variable will store the 
 current 
 percent
  value in a loop). The 
 cx
  (the current x) position of our rectangle and 
 rollingPercent
  will keep track of how much of our total chart has been completed.
  
 var percent=0; 
  
 var cx=0; 
  
 var rollingPercent = 0;
  
 Time to start looping through our data and drawing out the rectangles.
  
 for(var i=0; i<infoArray.length; i++){
  
  percent = infoArray[i].value/total;
  
  rollingPercent +=percent
  
  context.fillStyle =
  
  formatColorObject(getRandomColor(255));
  
  context.fillRect(cx,0 ,wid*percent,hei);
  
  cx+=wid*percent;",NA
There's more...,"For our chart to really have that extra kick, we need to have a way to make it capable of 
 showing data in at least a second lower-level details of data. To do that, we will revisit our data 
 source and re-edit it:
  
 var chartData = [
  
  
  {name: ""Asia"", data:[
  
  
  {name: ""South Central"",total:1800},
  
  
  {name: ""East"",total:1588},
  
  
  {name: ""South East"",total:602},
  
  
  {name: ""Western"",total:238},
  
  
  {name: ""Northern"",total:143}
  
  
  ]},
  
  
  {name: ""Africa"",total:1051},",NA
See also,"f 
  
 The 
 Adding user interaction into tree mapping
  recipe",NA
Adding user interaction into tree mapping,"Until now, we have limited our user interaction with our samples. In one of our last samples, 
 we added a controlled way to add and remove chart elements; in this one, we will enable the 
 user to dig deeper into the chart and see more details by creating a truly endless experience 
 (if we only had an endless amount of data to dig into).
  
 In the following image, on the left-hand side, you can see the initial state and what happens 
 after one click of the user (the chart redraws itself to showcase the area that was clicked on).",NA
Getting ready,"To get this sample right, you will need to start from our last recipe, 
 Tree maping and 
 recursiveness
 , and adjust it to work for this sample.",NA
How to do it...,"This is our first sample where we make our canvas area interactive. In the next few steps, we 
 will add some logic from the last sample into our recipe, to enable the user to zoom into or 
 out of it:
  
 1. Add a new global variable,
  
 var currentDataset;
  
 2. Store the current data that is sent to the tree mapping function.
  
 currentDataset = chartData;
  
 drawTreeMap(chartData,wid,hei,0,0,total);
  
 3. Add a 
 click
  event to our canvas area.
  
 can.addEventListener('click', onTreeClicked, false);
  
 4. Create the 
 onTreeClick
  event.
  
 function onTreeClick(e) {
  
  var box;
  
  for(var item in currentDataset){
  
  if(currentDataset[item].data){
  
  box = currentDataset[item].box;",NA
How it works...,"The Canvas element doesn't currently support a smart way to interact with objects. As there 
 are no objects in the canvas, as soon as you create the element it tunes into a bitmap and its 
 information is removed from memory. Luckily for us, our sample is constructed out of 
 rectangles, making it much easier to recognize when our element is clicked on. We will need 
 to store in memory the current box location of each element that we draw.
  
 As such, our first step of logic is the last thing that we did in our procedure (in step 6). We 
 want to capture the points that construct our rectangles, so then in our 
 click
  event we 
 can figure out where our dot is in relation to the rectangle:
  
 function onTreeClick(e) {
  
   
  var box;
  
  
  for(var item in 
 currentDataset){
  
   
  if(currentDataset[item].data){",NA
There's more...,"Currently, there is just no way to get back without refreshing everything. So, let's add it to 
 our logic that if the user clicks in an element with no children, we will revert to the original 
 map.
  
 Going back to the main treemap 
  
 Let's add the following code into the 
 click
  event:
  
 function onTreeClick(e) {
  
   
  var box;
  
  
  for(var item in currentDataset){
  
   
  if(currentDataset[item].data){
  
     
  box = currentDataset[item].box;
  
     
  if(e.x>= box.x && e.y>= box.y &&
  
     
  e.x<= box.x2 && e.y<= box.y2){
  
      
  context.clearRect(0,0,wid,hei);
  
      
  drawTreeMap(currentDataset[item].data,wid, 
      
  hei,0,0,currentDataset[item].total);
  
      
  currentDataset = currentDataset[item].data;",NA
Making an interactive click meter,"In this next example, we will focus on one more powerful feature of any client-side 
  
 programming—the ability to interact with the user and the ability to update data 
 dynamically. To keep it simple, let's revisit an old chart—the bar chart from 
 Chapter 3
 , 
 Creating Cartesian-based Graphs
 —and integrate a counter that will count how many times 
 a user clicks on an HTML document in any given second and update the chart accordingly.",NA
How to do it...,"Most of the steps are going to be familiar, if you have worked on the bar chart from 
 Chapter 3
 , 
 Creating Cartesian-based Graphs
 . So, let's run through them and then focus on the new logic:
  
 1. Let's create some helper variables.
  
 var currentObject = {label:1,
  
  value:0,
  
  style:""rgba(241, 178, 225, .5)""};
  
  var colorOptions = [""rgba(241, 178, 225,   
 1)"",""#B1DDF3"",""#FFDE89"",""#E3675C"",""#C2D985""];
  
  var data = [];
  
 var 
 context; 
  
 var wid; 
  
 var hei;
  
 2. Follow this with our 
 init
  function.
  
 function init(){
  
  var can = document.getElementById(""bar"");
  
  wid = can.width;
  
  hei = can.height;
  
  context = can.getContext(""2d"");
  
  
  document.addEventListener(""click"",onClick);
  
  interval = setInterval(onTimeReset,1000);
  
  refreshChart(); 
  
 }
  
 3. Now it's time to create the 
 onTimeReset
  function.
  
 function onTimeReset(){
  
  
  if(currentObject.value){
  
  
  data.push(currentObject);
  
  
  if(data.length>25) data = data.slice(1);
  
  
  refreshChart(); 
  
  
  }
  
  
  currentObject = {label:currentObject.label+1, value:0,  
  
  style: colorOptions[currentObject.label%5]};
  
 }",NA
How it works...,"Let's focus on the breakdown of the data variables in 
 Chapter 3
 , 
 Creating Cartesian-based 
 Graphs
 . We had all our data ready inside our data object. This time around, we are keeping 
 the data object empty, and instead, we have one data line in a separate variable.
  
 var currentObject = {label:1,
  
  
  value:0,
  
  
  style:""rgba(241, 178, 225, .5)""}; 
  
 var data = [];
  
 Each time the user clicks, we update the counter for 
 currentObject
  and refresh the chart 
 thus making the user experience more dynamic and live.
  
 function onClick(e){
  
  
  currentObject.value++;
  
  
  refreshChart(); 
  
 }
  
 We set the interval in the 
 init
  function as follows:
  
 interval = setInterval(onTimeReset,1000);",NA
6 ,NA,NA
Bringing Static ,NA,NA
Things to Life,"In this chapter, we will cover the following topics:
  
 f 
  
 Stacking graphical layers
  
 f 
  
 Moving to an OOP perspective
  
 f 
  
 Animating independent layers
  
 f 
  
 Adding an interactive legend
  
 f 
  
 Creating a context-aware legend",NA
Introduction,"Until now, the importance of keeping things organized and clean wasn't as great as that of 
 getting our projects done as we had relatively small projects. This chapter will break us into a 
 few new habits by first making everything dynamic followed by creating a more object-
 oriented program so it's easier for us to separate tasks and reduce our code footprint. After all 
 this hard work, we will revisit our application and start adding extra logic geared at making 
 our application animated layer by layer.
  
 This chapter is a great resourse for refactoring practice. In the first half of this chapter, we 
 will be focused on improving our code structure to make it possible for us to have the level 
 of control we will need in the second half of the chapter.",NA
Stacking graphical layers,"Before we can do any real animations on our canvas we really need to rethink the concept of 
 building everything on one canvas layer. Once a canvas element is drawn, it's incredibly hard 
 to create subtle small changes to it, such as fade-ins for specific elements. We will revisit one 
 of our famous charts, the bar chart, which we played around with and enhanced many times 
 throughout the earlier chapters. In this chapter, our goal will be to break the logic apart and 
 make it more modular. In this recipe we will separate layers. Each layer will give us more 
 control later when we are ready to animate.",NA
Getting ready,"Start by grabbing the latest files from the previous chapter: 
 05.02.line-
 revisit.html 
 and 
 05.02.line-revisit.js
 .",NA
How to do it...,"The following changes are made to the HTML file:
  
 1. Update the HTML file to incorporate more canvas elements (one per drawn line):
  
 <body onLoad=""init();"" style=""background:#fafafa"">
  
  <h1>Users Changed between within a year</h1>
  
  <div class=""graphicLayers"" >
  
  
  
  <canvas id=""base"" class=""canvasLayer"" width=""550""  
  
  
  height=""400""> </canvas>
  
  <canvas id=""i2011"" class=""canvasLayer"" width=""550""   
 height=""400""> </canvas>
  
  <canvas id=""i2010"" class=""canvasLayer"" width=""550""   
 height=""400""> </canvas>
  
  <canvas id=""i2009"" class=""canvasLayer"" width=""550""   
 height=""400""> </canvas>
  
  
  </div>
  
  
  <div class=""controllers"">
  
  
  2009 : <input type=""radio"" name=""i2009"" value=""-1"" /> off
  
   
  <input type=""radio"" name=""i2009"" value=""0"" /> line
  
    
  <input type=""radio"" name=""i2009"" value=""1"" select=""1"" /> 
 full ||
  
  
  2010 : <input type=""radio"" name=""i2010"" value=""-1"" /> off
  
   
  <input type=""radio"" name=""i2010"" value=""0"" /> line
  
    
  <input type=""radio"" name=""i2010"" value=""1"" select=""1"" /> 
 full ||",NA
How it works...,"The heart of this recipe is our HTML file that enables us to layer canvas elements on top of 
 each other, and as our canvas is by default transparent, we can see through to the elements 
 that are under it. After our canvas is layered with four layers, it's time for us to separate our 
 background from our lines and as such we want to put all of our chart background information 
 right into the base canvas:
  
 var can = document.getElementById(""base"");
  
 With each line layer, we are using a preconfigured canvas element that is already set:
  
 changeLineView(""i2011"",barData.i2011.status); 
 changeLineView(""i2010"",barData.i2010.status); 
 changeLineView(""i2009"",barData.i2009.status); 
  
 The first parameter is both the ID of our canvas and the key we are using in our new object 
 that stores our line information (to keep our code simple):
  
 var barData = {
  
  i2009:{...},
  
  i2010:{...},
  
  i2011:{...} 
  
  };
  
 In this data object we have exactly the same number of elements as we do in our canvas with 
 the exact same names. This way we can very easily fetch information without using extra 
 variables or conditions. This ties in to the logic of creating/updating lines:
  
 function 
 changeLineView(id,value){
  
  barData[id].status = value;
  
  var dataSource = barData[id];
  
  can = document.getElementById(id);
  
  context = can.getContext(""2d"");
  
  context.clearRect(0,0,wid,hei);
  
  if( dataSource.status!=HIDE_ELEMENT){
  
  context.beginPath();
  
  addLine(context,formatData(dataSource.data, dataSource. 
  
  
  label,dataSource.style),dataSource.style,dataSource.status==1);
  
  } 
  
 }",NA
There's more...,"Our final goal is this recipe is to help minimize the number of changes the user needs to do 
 to create lines. Currently to add more lines the user would need to make changes in three 
 places. The next few optimization tricks will help us reduce the number of steps it takes to 
 add/remove lines.
  
 Optimizing the drawChart function
  
 Our 
 drawChart
  function has been through a facelift, but right now, when we are creating 
 our lines we are still referring directly to our current elements:
  
  changeLineView(""i2011"",barData.i2011.status);
  
  changeLineView(""i2010"",barData.i2010.status);
  
  changeLineView(""i2009"",barData.i2009.status);
  
 Instead, let's take advantage of the 
 barData
  object and use the data keys of this object. This 
 way we can completely avoid the need to refer directly to our explicit elements and instead 
 depend on our data source as the source of information:
  
  for(var id in barData){
  
  changeLineView(id,barData[id].status);
  
  }
  
 Perfect! Now any change in our 
 barData
  object will define the elements that will get rendered 
 initially when the application starts. We just cut down the number of changes users will need 
 to do to two.
  
 Further streamlining our code
  
 We are in much better shape now than when we started. Originally there where three 
 places in our code that referred directly to hardcoded values for our chart information. 
 With the last update we reduced it to two (once within the HTML file and once in our data 
 source).
  
 It's time for us to remove one more hardcoded instance. Let's remove our extra canvases and 
 create them dynamically.",NA
Moving to an OOP perspective,"Our application has been developing with a growing momentum. It's time for us to stop that 
 by changing our chart to be more OOP conducive. In this recipe we will clean up our code 
 some more and convert some of it into objects. We will continue from where we left off in 
 our previous recipe, 
 Stacking graphical layers
 .",NA
Getting ready,"The first step is to get our latest source files: 
 06.01.layers.optimized.html
  and 
 06.01.layers.optimized.js
 . We will rename them and add our animation logic. Beyond 
 changing the references on our HTML file we will not change anything else in our HTML file 
 but focus our attention into the JavaScript file.
  
 One of the simplest ways of creating objects in JavaScript is by using functions. We can create a 
 function and refer within the function name to 
 this
  and by doing that we can treat the 
 function as an object (more details in the 
 How it works...
  section of this recipe).",NA
How to do it...,"Let's jump right in and start converting our code to be more OOP friendly:
  
 1. We start our code changes in the JavaScript file. Create the 
 LineChart 
  
 constructor method:
  
 function LineChart(chartInfo,barData){
  
  this.chartInfo = chartInfo;
  
  this.barData = barData;
  
  this.HIDE_ELEMENT = -1;
  
  this.LINE_ELEMENT = 0;
  
  this.FILL_ELEMENT = 1;
  
  this.CHART_PADDING = 20;
  
  this.wid;
  
  this.hei;
  
  drawChart();
  
  var radContainer = document.getElementById(""controllers"");
  
  var hasLooped= false;
  
  for(var id in barData){
  
  radContainer.innerHTML += (hasLooped ? "" || "":"""") + 
 barData[id].label +"": "" ;
  
  appendRadioButton(radContainer,id,-1,"" 
 off 
 ""); appendRadioButton(radContainer,id,0,"" line 
 ""); appendRadioButton(radContainer,id,1,"" full 
 ""); hasLooped = true;
  
  }
  
  var radios ;
  
  for(id in barData){
  
  radios = document.getElementsByName(id);
  
  for (var i=0; i<radios.length; i++){
  
    
  radios[i].onchange = onChangedRadio;
  
  
  if(radios[i].value == barData[id].status ){
    
  radios[i].checked = true; 
  
  
  }
  
  }
  
  }
  
 }",NA
How it works...,"We kept our changes at this stage to a minimum. JavaScript is an object-oriented programing 
 language, and as such we can take advantage of that by wrapping all of our functions into a 
 new class. We start by creating a constructor function. This function will be used as our object 
 type/name:
  
 function MyFirstObject(){
  
  //constructor code 
  
 }
  
 To create object variables we will refer to the constructor variables with 
 this
 . The 
 this 
 operator is a dynamic name that always refers to the current scope. The current scope 
 within an object is the object itself; in our case the 
 MyFirstObject
  function will look as 
 follows:
  
 function MyFirstObject(){
  
  this.a = ""value""; 
  
 }",NA
There's more...,"Although right now we have a working OOP object, it's not really optimized and it can use 
 some refining. As we are in one scope, we can revisit and rewire what can be sent and what 
 can depend on internal variables. We will explore this next task in this section of the chapter.",NA
Animating independent layers,"After a few really hard recipes let's do something fun and easy; let's add some animation to 
 our chart and add some fade-ins and delays.",NA
Getting ready,"The core logic of our application was built in the previous two recipes 
 Stacking graphical 
 layers
  and 
 Moving to an OPP perspective
 . We are in great shape so it will be extremely easy 
 for us to expand and create content and add it into our application. We will make few very 
 slight updates to our latest HTML file, mainly deleting things we don't need and then it's all 
 JavaScript.
  
 Grab the latest files from our last sample (
 06.02.objects.optimized.html
  and 
 06.02. 
 objects.optimized.js
 ) and let's continue.",NA
How to do it...,"Our goal in the next few steps is to remove the code that is not required and then build our 
 layered animations. Perform the following steps:
  
 1. Remove the HTML, CSS, and 
 <div>
  tags that are not required (delete the highlighted 
  
 code snippets):
  
 <!DOCTYPE html>
  
 <html>
  
  <head>
  
  <title>Line Chart</title>
  
  <meta charset=""utf-8"" />
  
  <style>
  
  #chartContainer {",NA
How it works...,"Let's start by looking into our 
 Animator
  constructor. We start with a few variables in 
 our constructor:
  
 function Animator(refreshRate){
  
  
  this.animQue = [];
  
  
  this.refreshRate = refreshRate || 50; //if nothing set 20 FPS
  
  
 this.interval = 0; 
  
 }
  
 These variables are the key to everything else. The 
 animQue
  array will store each new 
 animation request we make. The 
 refreshRate
  property will control how often our 
 animation will update. The more often it updates the smoother our animation will be (the 
 higher the value in the refresh rate the less stress on user's system). For example, if we want 
 to have a few animations, one in a smoother setting and others with a lower refresh rate, we 
 can set two separate 
 Animator
  classes with different refresh rates.",NA
Adding an interactive legend,"Although we created a legend in the past, our legend was bound to be non-interactive as we 
 had no way to move it around. In this sample, we will create a quick and easy legend that will 
 update its position and fade in and fade out when a user rolls over our chart.",NA
Getting ready,"Grab the latest files from our previous recipe, 
 06.03.fade.html
  and 
 06.03.fade.js
 , and 
 let's jump right in. We will hardcode our values in this example, but a more modular approach 
 of extracting elements that would be dynamic is a great way to make this class reusable.",NA
How to do it...,"This time around we will create a method in the 
 LineChart
  object that will create legends for 
 us. Perform the following steps:
  
 1. Create the 
 createLegend
  method:
  
 LineChart.prototype.createLegend = function (){
  
  var can = document.createElement(""canvas"");
  
  
 can.width=70;
  
    
  can.height=100; 
  
  
  can.setAttribute(""class"",""canvasLayer"");
  
  
 chartContainer.appendChild(can);
  
  
  this.legend = can;
  
  
  this.updateLegend();
  
  
  can.style.opacity = 
 0; 
  
 }
  
 2. Create the 
 updateLegend
  method:
  
 LineChart.prototype.updateLegend = function(){ 
 var wid = this.legend.width;
  
  var hei = this.legend.height;
  
  var context = this.legend.getContext(""2d""); 
 context.fillStyle = ""rgba(255,255,255,.7)""; 
 context.strokeStyle = ""rgba(150,150,150,.7)""; 
 context.fillRect(0,0,wid,hei);
  
  context.strokeRect(5,5,wid-10,hei-10);
  
  var nextY= 10;
  
  var space = (hei-10 - this.chartInfo.bars * nextY) / 
 this.
  
 chartInfo.bars;
  
  
  for(var id in this.barData){
  
  
  context.fillStyle = this.barData[id].style;
  
  
  context.fillRect(10,nextY,10,10);
  
  
  context.fillText(this.barData[id].label,25, nextY+9);
  
  nextY+=10+space;
  
  }
  
  this.legend.style.left = this.wid +""px"";
  
 }",NA
How it works...,"The logic this time around is simple as our application already is nicely set and optimized. 
 Our 
 createLegend
  method creates for us a new canvas area that we can use for our legend. 
 I've added some hardcoded values into it, but it would be a good idea to extract them into 
 our 
 chartInfo
  variable.",NA
There's more...,"One more thing to note is, if you search hard and stress test our 
 Animator
  class in this 
 example, you will find that its not hundred percent optimized. If we send to the 
 Animator 
 class the same object with conflicting instructions, it will not automatically 
 terminate the conflict. Instead, it will run through both until completion (for example, it 
 will fade-out and fade-in at the same time; it will not break our application but it will 
 create unwanted outcomes). To solve problems such as this one, we would need to 
 modify our 
 Animator 
 class to override animations that are in conflict.
  
 Let's fix the animation conflicts by checking that our animation queue does not have the same 
 object with the same property animating already. We will create a 
 find
  function to help us 
 find in the 
 animQue
  property the index of a duplicate:
  
 Animator.prototype.find= function(obj,property){
  
  for(var i=0; i<this.animQue.length; i++){
  
  if(this.animQue[i].obj == obj && this.animQue[i].p == property) 
 return i; 
  
  }
  
  return -1;
  
 }
  
 The function will scan through our 
 animQue
  array and locate duplications. If a match is found, 
 the index value will be returned. If not, 
 -1
  will be returned. Now it's time to update our 
 add 
 method to use this new 
 find
  method:
  
 Animator.prototype.add = function(obj,property, from,to,time,delay){
  
  obj[property] = from;
  
  var index = this.find(obj,property);
  
  if(index!=-1) this.animQue.splice(index,1);
  
  this.animQue.push({obj:obj,
  
  p:property,
  
  crt:from,",NA
Creating a context-aware legend,"Our goal will be to create a legend that updates based on what is under the user's mouse 
 cursor as they roll over our application. Based on the mouse position of the user, we will 
 update our legend to reflect the information that is under the user's mouse.",NA
Getting ready,"Grab the latest files from the previous recipe: 
 06.04.legend.html
  and 
 06.04.legend.js
 .",NA
How to do it...,"We aren't going to change anything in the HTML files so let's jump right into the JavaScript and 
 build out our dynamic legend:
  
 1. From the 
 ChartLine
  constructor, remove rollover/rollout events as we want to keep 
  
 our legend always visible:
  
  this.drawChart();
  
  this.createLegend();
  
  this.mainDiv.onmousemove = this.bind(this,this.onMouseMoveArea); 
 this.mainDiv.onmouseover = this.bind(this,this.fadeInLegend); 
 this.mainDiv.onmouseout = this.bind(this,this.fadeOutLegend);",NA
How it works...,"In the last two steps of the previous section of this recipe, we add a few helper variables to 
 help us create our mouse move logic. This is an interesting part because in addition in this 
 sample we are asking our canvas for pixel information for the first time. We will focus our 
 attention mainly on the logic within the 
 onMouseMoveArea
  event listener.
  
 We start by establishing the boundaries of our canvas area:
  
 var chartX = e.layerX-this.CHART_PADDING; 
  
 var chartWid =  this.wid -this.CHART_PADDING*2;
  
 This will be followed by a quick calculation of the current area in the chart we are in:
  
 var currentXIndex = -1; 
  
  
 if(chartX>=0 && chartX<= chartWid){ 
  
  
  
 currentXIndex = Math.round(chartX/this.
  
 chartInfo.x.stepSize); 
  
  
 }
  
 If we are out of the area, our 
 currentXIndex
  variable will remain 
 -1
 , while if we are in the 
 area, we will get a value between 
 0
  and the highest possible value based on the number of 
 steps in the data source. We will send this value to our newly updated 
 updateLegend 
 method that will append the actual value of that index information from the data source into 
 the rendering of the legend.
  
 The next step is a 
 for
  loop where we loop through our data to test our canvas elements to 
 see if they are opaque or not:
  
 var renderList = {};
  
  
  var count = 0;
  
  
  for(var id in this.barData){
  
  
  barCanvas = this.barData[id].canvas; 
  
  
  pixelData = barCanvas.getImageData(e.layerX, e.layerY, 1, 1).data;",NA
7 ,NA,NA
Depending on the Open ,NA,NA
Source Sphere,"In this chapter we will cover:
  
 f 
  
 Animating a gauge meter (jqPlot)
  
 f 
  
 Creating an animated 3D chart (canvas3DGraph)
  
 f 
  
 Charting over time (flotJS)
  
 f 
  
 Building a clock with RaphaelJS
  
 f 
  
 Making a sunburst chart with InfoVis",NA
Introduction,"The open source data visualization community is extremely rich and detailed, with many 
 options and some really amazing libraries. Each library has its strong points and its 
  
 disadvantages. Some are standalone code while others depend on other platforms such as 
 jQuery. Some are really big and some are really small; there isn't any one option that is perfect 
 for all opportunities, but with such a rich amount of options, the most important thing is to 
 figure out what library is the right one for you.
  
 There is always a trade-off when working with open source libraries, mainly when it comes to 
 file sizes and having just too many features that drag down the speed of your application, load 
 time, and so on. But with the richness and creativeness of the community, it's hard to avoid 
 really fantastic charts that can be created in minutes instead of hours.",NA
Animating a gauge meter (jqPlot),"In this recipe, we will be creating a really fun gauge meter and injecting some random 
 animation into it to make it look like a real source of live data is connected to it, such as the 
 speed of a car:",NA
Getting ready,"To get started you will need to use jQuery and jqPlot. This time around we will start from scratch.
  
 To get the latest scripts, visit the creator site at 
 http://blog.everythingfla. com/?p=339
 .
  
 Download both jQuery and jqPlot, or download our source files to start with.",NA
How to do it...,"Let's list the steps required to complete the task:
  
 1. Create an HTML page for our project:
  
 <!DOCTYPE html>
  
 <html>
  
  <head>
  
  <title>JQPlot Meter</title>",NA
How it works...,"This task was really easy as we didn't need to start everything from scratch. For the meter to 
 run, we need to import the library 
 meterGaugeRenderer
 . We do that by adding that into 
 our JavaScript files that we are loading. But let's focus on our code. The first step in our 
 JavaScript is to prepare a few global variables; we are using global variables as we want to 
 re-use these variables in two different functions (when we are ready to reset our data).
  
 var meter; 
  
 var meterValue=0; 
  
 var startingSpeed = parseInt(Math.random()*60) + 30; 
 var isStarting = true;
  
 The 
 meter
  variable will hold the meter that we will generate from our open source library. 
  
 The 
 meterValue
  will be our initial value when the application loads. Our 
 startingSpeed 
 variable is going to be a random value between 
 30
  and 
 90
 . The goal is to start from a different 
 place each time to make it more interesting. As soon as our application starts, we will want our 
 meter to quickly animate to its new base speed (the 
 startingSpeed
  variable). Lastly, this 
 connects to the 
 isStarting
  variable as we will want to have one animation that will get us to 
 our base speed. When we get there, we want to switch to a random driving speed that would 
 cause the animation to change. Now that we have all the helper variables set, we are ready to 
 create the 
 renderOptions
  object:
  
 var renderOptions= {
  
  
  
  label: 'Miles Per Hour',
  
  
  
  labelPosition: 'bottom',
  
  
  
  labelHeightAdjust: -10,
  
  
  
  intervalOuterRadius: 45,
  
  
  
  ticks: [0, 40, 80, 120],
  
  
  
  intervals:[25, 90, 120],
  
  
  
  intervalColors:[ '#E7E658','#66cc66', '#cc6666']
  
  
 };
  
 This object is really the heart of the visuals for our application. (There are other options that 
 you are welcome to explore in the jqPlot project home page documentation.) Now let's 
 review a few of the key parameters.
  
 intervalOuterRadius
  has a bit of a tricky name, but it's actually the internal radius. The 
 actual size of our meter is controlled by the size of 
 div
  that we set our application to be in. 
 intervalOuterRadius
  controls the size of our internal shape in the speedometer's core.
  
 var renderOptions= {
  
  label: 'Miles Per 
 Hour',
  
  labelPosition: 
 'bottom',
  
  labelHeightAdjust: -10,
  
  intervalOuterRadius: 
 45,",NA
There's more...,"Let's explore a few more functions.
  
 Creating the updateMeter function
  
 The 
 updateMeter
  function gets called every 30 milliseconds. What we need to do is start by 
 clearing our art every time that it is called:
  
 meter.destroy(); 
  
 This will clear everything related to our meter so we can recreate it.
  
 If we are still in the intro part of our application where we want our speed to go up to the 
 goal speed, we need to update our 
 meterValue
  by 
 1
 .
  
 if(isStarting && meterValue<startingSpeed){
  
  ++meterValue; 
  
 }",NA
Creating an animated 3D chart ,NA,NA
(canvas3DGraph),"This recipe is real fun. It's based on the source files of Dragan Bajcic. It's not a full library 
 of charts, but it's a great inspirational chart that can be modified and used to create your 
 own 3D data visualizations.
  
 Although our source files in our attached sample are modified from the original source 
 (mainly 
 canvas3DGraph.js
 ), to get the original source for the open source projects used in 
 this book, please visit our centralized list at 
 http://blog.everythingfla.com/?p=339
 .",NA
Getting ready,"If you want to follow our updates, download the original source files from the provided link 
 or review the changes that we make to Dragan's source files.",NA
How to do it...,"Let's jump right in as we have a lot of work to do:
  
 1. Create the HTML file:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>canvas3DGraph.js</title>
  
  
  <meta charset=""utf-8"" />
  
  
  <link rel=""stylesheet""  
  
  
  href=""./external/dragan/canvas3DGraph.css"">
  
  
 <script src=""./external/dragan/ 
  
  
  canvas3DGraph.js""></script>
  
  
  <script src=""./07.02.3d.js""></script>
  
  </head>
  
  <body style=""background:#fafafa"">
  
  <div id=""g-holder"">  
  
  
  <div id=""canvasDiv"">  
  
   
  <canvas id=""graph"" width=""600"" height=""600"" > 
   
  </canvas>  
  
   
  <div id=""gInfo""></div>   
  
  
  </div>  
  
  
  </div>      
  
  
  </body> 
  
 </html>
  
 2. Create the CSS file 
 canvas3DGraph.css
 :
  
 #g-holder { 
  
  height:620px;  
  
  position:relative;  
  
 } 
  
 #canvasDiv{ 
  
  border:solid 1px #e1e1e1;  
  
  width:600px;  
  
  height:600px;  
  
  position:absolute;",NA
How it works...,"Let's first look at our code in the way that we interact with the JavaScript library. After that 
 we will dig deeper into the inner workings of this library.
  
 var gData = []; 
  
 var trailingArray=[]; 
  
 var trailCount = 5; 
  
 var curIndex=0;",NA
There's more...,"Next we call 
 plotBar
  and repeat the action every 40 milliseconds.
  
 The logic behind plotBar
  
 Let's review the logic within the 
 plotBar
  function. This is the really cool part of our 
 application, where we update the data feed to create an animation. We start by adding the 
 current index element into the 
 trailingArray
  array:
  
 trailingArray.push(gData[curIndex]);",NA
Charting over time (flotJS),"One of the more impressive features of this library is the ease with which one can update the 
 chart information. It's very easy to see from the first moment when you review this library 
 and its samples that the author loves math and loves charting. My favorite feature is the way 
 the chart can update its x ranges dynamically based on the input added into it.",NA
Getting ready,"To get the latest builds of the 
 flotJS
  library, please visit our link hub at 
 http://blog. 
 everythingfla.com/?p=339
  for charting open source libraries or download our 
 book's source files where we include the latest build as of publication at 
 http://02geek.com/ books/html5-graphics-and-data-visualization-
 cookbook.htm
 .",NA
How to do it...,"Let's create our HTML and JavaScript files:
  
 1. Create an HTML file:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>flot</title>
  
  
  <meta charset=""utf-8"" />
  
  
  <script src=""http://ajax.googleapis.com/ 
  
  
  ajax/libs/jquery/1.7.2/jquery.min.js""></script>
  
  <script src=""./external/flot/jquery.flot.js""> 
  
  </script>
  
  
  <script src=""./external/flot/ 
  
  
  jquery.flot.fillbetween.js""> 
  
  
  </script>    
  
  <script src=""./07.03.flot.js""></script>
  
  </head>
  
  <body style=""background:#fafafa"">
  
  
  <div id=""placeholder""  
  
  
  style=""width:600px;height:300px;""></div> 
  
  </body> 
  
 </html>
  
 2. Create a new JavaScript file (
 07.03.flot.js
 ) and then create our data source:
  
 var males = {
  
 //…
  
 //please grab from source files its a long list of numbers 
 };Create helper variables: 
  
 var VIEW_LENGTH = 5; 
  
 var index=0; 
  
 var plot;
  
 var formattingData = {",NA
How it works...,"flotJS
  has a built-in logic to reset itself when its redrawn, and that's part of our magic. Our 
 data source has been borrowed from one of the 
 flotJS
  samples. We are actually using the 
 data to represent a fictional situation. Originally this data was representing the average weight 
 of people based on their age, broken down into percentiles. But our point in this example is 
 not to showcase the data but instead show ways of visualizing the data. So in our case, we had 
 to treat the data by keeping the percentiles as they are intended to be, but use the inner data 
 to showcase the average over years instead of over ages, as follows:
  
 {'15%': [[yearID, value], [yearID, value]...
  
 The 
 yearID
  values range from 
 2
  through 
 19
 . We want to showcase this information as if 
 we started our data picking from 2006. Each 
 yearId
  will represent a month (19 would be 
 1.5 years after 2006, instead of the age 19 as the data actually represents).
  
 So let's start breaking it down. Now that we know how we are going to treat our dataset, we 
 want to limit the number of months that we can see at any given time. As such we will add two 
 helper parameters, one of which will keep track of our current index and the other will track 
 the maximum number of visible elements at any given time:
  
 var VIEW_LENGTH = 5;
  
 var index=0;
  
 We will create a global variable for our Flot graph and create a formatter to help us format 
 the data that will be sent in.
  
 var plot;
  
 var formattingData = {
  
  xaxis: { tickDecimals: 0, tickFormatter: function (v) { return   
 v%12 + ""/"" + (2003+Math.floor(v/12)); } },
  
  yaxis: { tickFormatter: function (v) { return v + "" cm""; } }
  
 };
  
 Note that 
 tickFormater
  enables us to modify the way our tick will look in the chart. In the 
 case of the x axis, the goal is to showcase the current date 
 2/2012...
 , and in the y axis, we 
 want to add 
 cm
  to the numbers that will be printed out on the screen.",NA
There's more...,"There are still two more things to cover—the 
 getData
  function and 
 the 
 updateChart
  function.
  
 The GetData function
  
 In 
 flotJS
  every data point has an ID. In our case, we want to showcase six related content 
 types. Play around with the parameters to see how they change the way the view is 
 rendered. Before we send the created array back, we update the index ID by one, so the next 
 time that the function is called it will send the next range.
  
 One more thing we need to note is the actual data range. As we are not sending the full data 
 range (but a maximum of 
 5
 ), we need to validate that there are atleast five items after the 
 index, and if not we will return the last element of the array, ensuring that we never slice more 
 than the actual length:
  
 var endIndex = index+5>=males.length?males.length-1:index+5;
  
 The UpdateChart function
  
 This part is probably the simplest one. The same code is used for the first render and all the 
 following renders. If the dataset is valid, we create a timeout and call this function again until 
 the animation completes.",NA
Building a clock with RaphaelJS,"Hands down this is my favorite sample in this chapter. It's based on a mix of two samples on 
 Raphael's website (I strongly encourage you to explore it). Although 
 Raphael
  isn't a 
 graphing library, it's a really powerful animation and drawing library that is really worth 
 playing with.
  
 In this recipe, we will create a clock that is creative (I think). I planned to play with this library 
 for a day or two, and ended up playing with it all weekend as I was just having so much fun. I 
 ended up with a digit morphing clock (based on a sample that Raphael created on his site for 
 letter morphing) and incorporated some arcing into it based on the polar clock example on his 
 site. Let's see it in action:",NA
Getting ready,"As always in this chapter, you need the original library of Raphael. I've added it into 
 our project. So just download the files and let's get rolling.
  
 To grab the original library, visit our external source files hub for this chapter 
 at 
 http://blog.everythingfla.com/?p=339
 .",NA
How to do it...,"Let's build up our application:
  
 1. Create the HTML file:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Raphael</title>
  
  
  <meta charset=""utf-8"" />
  
  
  <script src=""http://ajax.googleapis.com/ajax/ 
  
  libs/jquery/1.7.2/jquery.min.js""></script>
  
  
 <script src=""./external/raphael/raphael- 
  
  
 min.js""></script> 
  
  
  <script src=""./07.04.raphael.js""></script>
  
  
 <style>",NA
How it works...,"There are a lot of elements to this project. Let's start focusing on the arc animation. Note that 
 one of the elements that we are using in our code is when we are creating our new paths (we 
 create two of them). We are adding some hardcoded parameters that will be used later when 
 we draw the arcs in the 
 arc
  method:
  
 var sec = r.path();sec.props = {r:30,x:300,y:300}; //new mandatory 
 params
  
 var sec2 = r.path();sec2.props = {r:60,x:300,y:300};
  
 We are doing that to avoid sending these three properties into the arc each time, and to 
 enable us to pick a radius and stick with it without it being integrated or hardcoded into 
 the animations. We based our 
 arc
  method on the 
 arc
  method used for the polar clock in 
 Raphael's examples, but changed it so the values can be positive or negative (making it 
 easier to animate back and forth).
  
 The 
 arc
  method is then used to draw our arc when we are animating it inside 
 the 
 animateSeconds
  function:
  
 sec.attr({arc: [1]}); 
  
 sec.animate({arc: [0]}, 1000, 
 ""="",animateSeconds); sec2.attr({arc: [1,true]}); 
  
 sec2.animate({arc: [0,true]}, 999, ""="");
  
 The 
 attr
  method will reset our 
 arc
  attribute so that we can reanimate it.
  
 By the way, note that in 
 animateStrokeWidth
  we are animating the width of our 
 stroke for 60 seconds from its lowest value to its highest value.",NA
There's more...,"Did you really think we are done? I know you didn't. Let's take a look at a few 
 other critical steps.
  
 Animating paths
  
 One of the cooler things in this library is the capability to animate paths. If you have 
 ever worked with Adobe Flash Shape Tweens, this will look very familiar—hands down, 
 this is just really cool.
  
 The idea is very simple. We have an object with a lot of path points. They create a shape 
 together if we draw the line information through them. We have borrowed a list that 
 Raphael created so we don't need to start from scratch, and literally all that we are 
 changing in it is that we don't want our elements to be drawn in their current path. All we 
 need to do is transform their location using the internal 
 Raphael.transformPath
  
 method:
  
 transPath = Raphael.transformPath(helveticaForClock[0], 'T400,100');
  
 In other words, we are grabbing the path information for the digit 0 and then we are 
 transforming, moving it 400 pixels to the right and 100 pixels down.
  
 In our source code, it looks like we are executing the function in a loop (which is a bit more 
 complicated but condensed):
  
 for(i=0; i<aLast.length; i++){
  
  digit = r.path(""M0,0L0,0z"").attr({fill: ""#fff"", stroke: ""#fff"",   
 ""fill-opacity"": .3, ""stroke-width"": 1, ""stroke-linecap"":  
  
  ""round"", translation: ""100 100""});
  
  transPath = Raphael.transformPath(helveticaForClock[aLast[i]],   
 aTrans[i]);
  
  digit.attr({path:transPath});
  
  aDigits.push(digit);
  
 }
  
 We are basically looping through the 
 aLast
  array (the list of digits that we want to create) 
 and creating a new digit for each element. We then figure out the position of the digit based 
 on the transforming information that is located in the 
 aTrans
  array and then we draw it 
 out by adding a new path into the attributes. Last but not least, we are saving our digit into 
 our 
 aDigits
  array that is to be used when we re-render the element later.",NA
Making a sunburst chart with InfoVis,"Another really cool library is 
 InfoVis
 . If I had to categorize the library, I would say it's 
 about connections. When you review the rich samples provided by Nicolas Garcia Belmonte, 
 you will find a lot of relational datatypes that are very unique.
  
 This library is distributed freely through Sencha legal owners. (The copyright is easy to 
 follow, but please review the notes for this and any open source project that you encounter.)
  
 We will start with one of his base samples—the sunburst example from the source files. I've 
 made a few changes to give it a new personality. The basic idea of a sunburst chart is to 
 showcase relationships between nodes. While a tree is an ordered parent-child relationship, 
 the relationships in a sunbust chart are bidirectional. A node can have a relationship with any 
 other node, and it can be a two-way or one-way relationship. A dataset that is perfect for this 
 is the example of the total exports of a country—lines from one country to all the other 
 countries that get exports from it.",NA
Getting ready,"As always you will need the source files, you can either download our sample files or 
 get the latest release by visiting our aggregated list at 
 http://blog.everythingfla. com/?p=339
 .",NA
How to do it...,"Let's create some HTML and JavaScript magic:
  
 1. Create an HTML file as follows:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Sunberst - InfoVis</title>
  
  
  <meta charset=""utf-8"" />
  
  <style>
  
  
  #infovis {
  
   
  position:relative;
  
   
  width:600px;
  
   
  height:600px;
  
   
  margin:auto;
  
   
  overflow:hidden;
  
  
  }
  
  </style>
  
  <script  src=""./external/jit/jit-yc.js""></script> 
 <script src=""./07.05.jit.js""></script>
  
  </head>
  
  
  <body onload=""init();"">
  
  
  <div id=""infovis""></div>    
  
  
  </body> 
  
 </html>
  
 2. The rest of the code will be in 
 07.05.jit.js
 . Create a base data source as follows:
  
 var dataSource = [ {""id"": ""node0"", ""name"": """",""data"": {""$type"": 
 ""none"" },""adjacencies"": []}]; //starting with invisible root
  
 3. Let's create a function that will create the nodes needed for our chart system:
  
 function createNode(id,name,wid,hei,clr){
  
  var obj = {id:id,name:name,data:{""$angularWidth"":wid,  
 ""$height"":hei,""$color"":clr},adjacencies:[]};
  
  dataSource[0].adjacencies.push({""nodeTo"": id,""data"":   
 {'$type': 'none'}});
  
  dataSource.push(obj);
  
  
  return obj; 
  
 }",NA
How it works...,"I'll avoid getting into the details of the actual API as that is fairly intuitive and has a really 
 nice library of information and samples. So instead I will focus on the changes and 
 enhancements that I've created in this application.
  
 Before we do that we need to understand how the data structure of this chart works. 
 Let's take a deeper look into how the data source object will look when filled with 
 information:
  
 {
  
  
  ""id"": ""node0"",
  
  
  ""name"": """",
  
  
  ""data"": {
  
  
  ""$type"": ""none""
  
  
  },
  
  
  ""adjacencies"": [
  
  
   
  {""nodeTo"": ""node1"",""data"": {'$type': 'none'}}, 
  
   
  {""nodeTo"": ""node2"",""data"": {'$type': 'none'}}, 
  
   
  {""nodeTo"": ""node3"",""data"": {'$type': 'none'}}, 
  
   
  {""nodeTo"": ""node4"",""data"": {'$type': 'none'}}
  
    
  ] 
  
 }, 
  
 {
  
  
  ""id"": ""node1"",
  
  
  ""name"": ""node 1"",
  
  
  ""data"": {
  
  
  ""$angularWidth"": 300,
  
  
  ""$color"": ""#B1DDF3"",
  
  
  ""$height"": 40
  
  
  },
  
  
  ""adjacencies"": [
  
  
   
  {
  
  
   
  ""nodeTo"": ""node3"",
  
  
   
  ""data"": {
  
  
     
  ""$color"": ""#ddaacc"",",NA
There's more...,"One more thing left is that we need to be able to refresh our content when the user clicks 
 on an element. To accomplish this task, we will need to add an event parameter into the 
 initializing parameter object of 
 jit.Sunburst
 :
  
 var sb = new $jit.Sunburst({
  
  
  injectInto: 'infovis', //id container
  
  
  ...
  
  Events: {
  
  enable: true,
  
  type: 'Native',
  
  //List node connections onClick
  
  onClick: function(node, eventInfo, e){
  
  
  if (!node) return;
  
    
  highlight(node.id);
  
    
  
 sb.loadJSON(dataSource);
  
     
  sb.refresh();
  
  
  }
  
  
  },
  
  
  levelDistance: 120 
  
 });
  
 One more thing to note in this sample is the 
 levelDistance
  property that controls how 
 close/far you are to/from the rendered element (making it bigger or smaller).
  
 Where is the copy?
  
 There is still one more issue. We don't have any copy in our chart enabling us to know what 
 is actually being clicked on. I've removed it from the original sample as I just didn't like the 
 positioning of the text and couldn't figure out how to get it up right, so instead I came up 
 with a workaround. You can directly draw into the canvas by directly interacting with it. The 
 canvas element will always be called by the same ID as our project (in our case 
 infovis
  
 followed by 
 -canvas
 ):
  
 var can = document.getElementById(""infovis-canvas"");
  
  var context = can.getContext(""2d""); 
  
 …
  
 I'll leave the rest for you to explore. The rest of the logic is easy to follow as I've stripped 
 it down. So if you enjoy this project as well, please visit the InfoVis Toolkit site and play 
 more with their interface options.",NA
8 ,NA,NA
Playing with Google ,NA,NA
Charts,"In this chapter we will cover:
  
 f 
  
 Getting started with a pie chart
  
 f 
  
 Creating charts using the ChartWrapper
  
 f 
  
 Changing data source to Google Spreadsheet
  
 f 
  
 Customizing chart properties with an options object
  
 f 
  
 Adding a dashboard to charts",NA
Introduction,"In this chapter, we will explore the Google visualization API task by task. We will look at 
 the steps involved in creating a chart and integrating it with the charting API.
  
 To work with the Google APIs, you must comply with the Google terms of use and policies 
 that can be located at 
 https://google-developers.appspot.com/readme/terms
 .",NA
Getting started with a pie chart,"In this first recipe, we will start with Google Charts, covering the basic steps that you need to 
 understand when working with Google Charts through an interactive dataset that is based 
 on the CDC death rates in the USA (LCWK)—deaths, percent of total deaths, and death rates 
 for the 15 leading causes of death in five-year age groups, by race and sex in the United 
 States in 2008.",NA
Getting ready,"We will start from scratch with an empty HTML file and an empty JavaScript file 
 named 
 08.01.getting-started.html
  and 
 08.01.getting-started.js
 .",NA
How to do it...,"Let's list the steps required to complete the task starting with the HTML file:
  
 1. Let's start by creating a 
 head
  and linking it to the Google 
 jsapi
  and our local 
  
 JavaScript file:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Google Charts Getting Started</title>
  
  
  <meta charset=""utf-8"" />   
  
  
  <script src=""https://www.google.com/jsapi""></script>
  
  <script src=""./08.01.getting-started.js""></script>
  
  
 </head>
  
 2. Then create an empty 
 div
  with 
 idchart
 :
  
  
  <body style=""background:#fafafa"">
  
  
  <div id=""chart""></div>
  
  
  </body> 
  
 </html>
  
 Now, it's time to move into the 
 08.01.getting-started.js
  file.
  
 3. Lets request the visualization API from the Google 
 jsapi
 :
  
 google.load('visualization', '1.0', {'packages':['corechart']});
  
 4. We want to add a 
 callback
  that will be triggered when the library is ready:
  
 google.setOnLoadCallback(init);
  
 5. Create an 
 init
  function as follows:
  
 function 
 init(){ 
  
 ..
  
 }
  
 From now on we will break down the code added within the 
 init
  function:",NA
How it works...,"Let's explore the steps involved in working with Google Charts. The first step we 
 establish when working with the Google API's is adding Google's API link into our HTML 
 file:
  
  <script src=""https://www.google.com/jsapi""></script>
  
 Now that the Google API is loaded into our application, we can request the library 
 we wish to work with. In our case, we want to work with the visualization API and 
 the 
 corechart
  package:
  
 google.load('visualization', '1.0', {'packages':['corechart']});
  
 Notice that we are requesting version 1.0; this might be confusing but we are actually asking 
 for the production chart, 1.0 is always the current production version. As such if you wanted 
 to lock into a build, you would need to discover what its code version is and send it instead of 
 the 1.0 stable build.
  
 The 
 corechart
  library in the example defines most basic charts. For charts that are not 
 included, you would need to pass in the extra packages needed, such as the table chart:
  
 google.load('visualization', '1.0', {'packages':['corechart','tab 
 le']});
  
 This covers the basics of how to load the API. But before we can finish our loading process, 
 we need a way to have a callback so that we can know when the library is available for us 
 to manipulate:
  
 google.setOnLoadCallback(init);",NA
There's more...,"Let's explore a few more tips, tricks, and advanced features of Google Charts. Using the option 
 Objectto create 3D chartsTo
 , we can turn our chart into 3D. We can very quickly and 
 simply add a new parameter into the options object:
  
 var options = {'title':'Deaths, for the 15 leading causes of death: 
 United States, 2008',
  
  'width':800,
  
  'height':600,
  
  ""is3D"": true};
  
 The outcome would be a chart that is tilted in a 3D space.",NA
Creating charts using the ChartWrapper,"There are two ways to create charts with Google Charts. One is the way we did it in 
 the recipe 
 Getting started with a pie chart
  and the second will be covered in this 
 recipe. The goal of the ChartWrapper object is to enable you to cut down the amount 
 of code needed to create a chart.
  
 Its main advantages are less code and more flexibility of data sources. Its disadvantage 
 is less control over the steps of graph creation.",NA
Getting ready,"Grab the HTML file from the last recipe (
 Getting started with pie charts
 ). We will only 
 modify the file path of the external JavaScript file and the rest of the code will remain the 
 same.",NA
How to do it...,"After changing the path of the HTML file source to the JavaScript file, it's time to go into the 
 JavaScript file and start over:
  
 1. Load Google API (you do not need to mention what you want to load any more) and 
  
 add a callback:
  
 google.load('visualization', 
 '1.0'); 
  
 google.setOnLoadCallback(init);
  
 2. Create the 
 init
  function:
  
 function 
 init(){
  
 …
  
 }
  
 3. Build a 2D array with the data source:
  
 var dataTable = [
  
  
  
  ['Type of Death','Deaths'],
  
  
  
  ['Diseases of heart', 616828],
  
  
  
  ['Malignant neoplasms', 565469],
  
  
  
  ['Chronic lower respiratory diseases', 141090], 
  
  
  ['Cerebrovascular diseases', 134148],
  
  
  
  ['Accidents ', 121902],
  
  
  
  ['Alzheimer\'s disease ', 82435],
  
  
  
  ['Diabetes mellitus', 70553],
  
  
  
  ['Influenza and pneumonia', 56284],
  
  
  
  ['Suicide', 36035],
  
  
  
  ['Septicemia', 35927],
  
  
  
  ['Chronic liver disease and cirrhosis', 29963],
  
  
  ['Essential hypertension and hypertensive renal  
  
  
  disease', 25742],
  
  
  
  ['Parkinson\'s disease', 20483],
  
  
  
  ['Homicide', 17826],
  
  
  
  ['All other causes', 469062]
  
  
  ];",NA
How it works...,"The nice thing about this example is you don't need to know much more about how it works. 
 The 
 ChartWrapper
  function itself deals with all the information that you've had to deal with 
 in the last recipe. With that said, it doesn't mean this way is always the better way—if you 
 need more control over the steps, the last example would work better.",NA
There's more...,"As this recipe was very easy, let's add an extra pointer.
  
 Changing a chart in one line 
  
 It's really easy changing between the types of views of the Google Chart API. All you need to do 
 is switch the type. Let's change our chart to a 
 BarChart
 :
  
 var chart = new google.visualization.ChartWrapper({ 
 chartType:'BarChart',
  
  dataTable:dataTable,
  
  options:options,
  
  containerId:'chart'
  
 });",NA
Changing data source to Google ,NA,NA
Spreadsheet,"One of the powerful features of working with the Google API is the deep relationship between 
 the product lines. In this recipe, based on the last recipe, we will create a Google Spreadsheet 
 and then integrate it into our application.",NA
Getting ready,"Have a copy around you of the source files from the last recipe (
 Creating charts using the 
 ChartWrapper
 ).",NA
How to do it...,"The steps involved with creating a new Google document are simple, but are needed to be 
 able to integrate our work; as such we will run through them quickly.
  
 1. Go to 
 http://drive.google.com/
  (formally known as Google Docs) and 
  
 register/login.",NA
How it works...,"This is really the amazing part about it. You just don't need to understand how it works, all 
 you need to do is create your chart and use the steps provided in the preceding section, and 
 you can convert any of your own spreadsheets into a Google Spreadsheet.
  
 The most important step in the preceding steps is step 4. Notice that the URL that is 
 generated through the Google Documents (Google Drive) is not the same as the URL that we 
 need to hit when working in code. This is because the first URL is intended to be rendered as 
 a visual page, while the second link generates a new Google data object. Don't forget that 
 every page has its own unique ID.",NA
There's more...,"If you have a bit of a background with working with databases, you can send simple SQL 
 queries into the data source and only get the items that you want to view. Let's say in our 
 example we want to get the items in a different order, exclude column B, and sort based on 
 column D (by age):
  
 SELECT A,E,D,C ORDER BY D
  
 Our 
 Select
  statement is listing out what we want to select. The 
 ORDER BY
  statement 
 is self-explanatory. Let's add it to our code:
  
 var chart = new google.visualization.ChartWrapper({
  
  chartType:'BarChart',
  
  dataSourceUrl:""https://spreadsheets.google.com/  
 tq?key=0Aldzs55s0XbDdFJfUTNVSVltTS1ZQWQ0bWNsX2xSbVE"",
  
  query: 'SELECT A,E,D,C ORDER BY D',
  
  options:options,
  
  containerId:'chart'
  
 });
  
 When you refresh your code, column B will be missing and the data will be organized 
 based on column D.
  
 Last but not least, add this to your code:
  
 var chart = new google.visualization.ChartWrapper({
  
  chartType:'BarChart',
  
  dataSourceUrl:""https://spreadsheets.google.com/  
 tq?key=0Aldzs55s0XbDdFJfUTNVSVltTS1ZQWQ0bWNsX2xSbVE"",
  
  query: 'SELECT A,E,D,C ORDER BY D',
  
  refreshInterval: 1,",NA
Customizing the chart properties with an options ,NA,NA
object,"In this recipe, we will create a new chart with Google Charts API—a candlestick chart—and 
 we will incorporate a variety of configurations into it.",NA
Getting ready,We will start with a clean slate by creating a fresh new JavaScript and an HTML file.,NA
How to do it...,"Most of the steps will look almost identical to the past recipes in this chapter. Our main focus 
 will be on our 
 options
  parameters:
  
 1. Create an HTML file and link it to a JavaScript file (in our case 
 08.04. 
  
 candlestick.js
 ):
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Google Charts Getting Started</title>
  
  
  <meta charset=""utf-8"" />   
  
  
  <script src=""https://www.google.com/jsapi""></script>
  
  <script src=""./08.04.candlestick.js""></script> 
  
  
 </head>
  
  
  <body style=""background:#fafafa"">
  
  
  <div id=""chart""></div>
  
  
  </body> 
  
 </html>
  
 2. In the 
 08.04.candlestick.js
  file, add the API 
 load
  and 
 callback
  functions:
  
 google.load('visualization', '1', {packages: ['corechart']}); 
 google.setOnLoadCallback(init);
  
 function init(){",NA
How it works...,"This is the first time that we have used the method 
 google.visualization.
  
 arrayToDataTable
 . This method takes in an array and returns a data table. When the 
 second parameter of this method is set to 
 true
 , it will treat the first row in the array as part of 
 the data; and otherwise it will be treated as header data.
  
 There are many options and for a full list of them, review Google Charts documentation. We 
 will focus on the items that we have picked to modify our view. The Google charts enable you 
 to send an object with parameters. Each chart type has a different set of options. In our case, 
 we have many options that enable us to control the details of how our chart looks. Most of the 
 options are style related:
  
 backgroundColor:{fill:'#eeeeee',strokeWidth:2},
  
  bar:{groupWidth:17},
  
  candlestick:{hollowIsRising:true,
  
  fallingColor:{stroke:'red',fill:'#ffaaaa'},
  
  risingColor: {stroke:'blue',fill:'#aaaaff'}
  
  },
  
 Some options directly relate to the function such as disabling the legend:
  
 legend:'none',
  
 Or disabling interactive elements:
  
 enableInteractivity:false",NA
There's more...,"The main goal of highlighting this element is not because it's difficult, but because it's easy, 
 and it is the main place where you would find yourself making changes to the charts. One 
 point to note is that it is really important to check that you can do what you need by using 
 Google Charts before working with them, as contrary to other chart systems, you can't go 
 into their source files and change them, as we did in the recipes in 
 Chapter 7
 , 
 Depending on 
 the Open Source Sphere
 .",NA
Adding a dashboard to charts,"In this last recipe of this chapter we will add live controllers that will enable the users 
 to change the filtering of data to see less or more information.",NA
Getting ready,We will start from scratch so nothing to worry about.,NA
How to do it...,"The following are the steps needed to create a basic dashboard controller:
  
 1. Create an HTML file and link it to an external JavaScript file (in our case we will use 
  
 the file 
 08.05.slider.js
 ):
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Google Charts DASHBOARD</title>
  
  
  <meta charset=""utf-8"" />   
  
  
  <script src=""https://www.google.com/jsapi""></script>
  
  <script src=""./08.05.slider.js""></script>  
  
  
  </head>
  
  
  <body style=""background:#fafafa"">
  
  
  <div id=""chart""></div>
  
  
  <div id=""dashboard""></div>
  
  
  <div id=""filter""></div>
  
  
  </body> 
  
 </html>
  
 2. Now, it's time to get into 
 08.05.slider.js
  and to load the Google Visualization 
  
 API. This time around we will load in the controller package:
  
 google.load('visualization', '1', {packages: ['controls']});
  
 3. Now, it's time to add a callback:
  
 google.setOnLoadCallback(init); 
  
 function init(){
  
 4. Let's create our data source. We will base it on CDC death rates for 2008:
  
 var data = google.visualization.arrayToDataTable([ 
 ['Age (+- 2 Years)', 'Deaths'],
  
  
  
  [2, 4730],
  
  
  
  [7, 2502],
  
  
  
  [12, 3149], 
  
  
  
  [17, 12407],
  
  
  
  [22, 19791],
  
  
  
  [27,20786],
  
  
  
  [32,21489],
  
  
  
  [37,29864],
  
  
  
  [42,46506],
  
  
  
  [47,77417],",NA
How it works...,"This is probably one of the smoothest parts of working with the Google Charting API. So 
 let's break down and figure out the steps involved in creating controllers for your chart. 
 We will showcase one controller, but the same logic flow would work for all components.
  
 First in our HTML file, we need to have a 
 div
  layer with an ID associated for our dashboard 
 and a 
 div
  for each following controller. To add controllers we assign them to the dashboard. 
  
 We start with creating a dashboard: 
  
  
 var dashboard = new google.visualization.Dashboard(document.
  
 getElementById('dashboard'));",NA
9 ,NA,NA
Using Google ,NA,NA
Maps,"In this chapter we will cover:
  
 f 
  
 Creating a geographic chart with the Google Visualization API
  
 f 
  
 Obtaining a Google API key
  
 f 
  
 Building a Google map
  
 f 
  
 Adding markers and events
  
 f 
  
 Customizing controls and overlapping maps
  
 f 
  
 Redesigning maps using styles",NA
Introduction,"This chapter will be dedicated to exploring some of the features available on Google Maps 
  
 to get us ready to work with mapping in general. Mapping on its own isn't data visualization, 
  
 but after we establish our base by understanding how to work with maps, we will have a very 
  
 stable background that will enable us to create many cutting-edge, cool projects by integrating 
  
 data and data visualization.
  
 In this chapter, we will explore the main ways to create maps in the Google sphere.",NA
Creating a geographic chart with Google ,NA,NA
Visualization API,"In our first recipe for this chapter, we will start working with a vector-based map of the 
 world. We will use it to highlight countries based on a data feed. In our case, we will use 
 Wikipedia's list of countries as per the intentional homicide rate (latest numbers).
  
 To view this raw data go to 
 http://en.wikipedia.org/wiki/List_of_countries_ 
 by_intentional_homicide_rate
 .
  
 Our goal will be to have a map of the world highlighted with a range of colors according to the 
 number of intentional homicides per 100,000 people. As of the latest data in 2012 according to 
 Wikipedia, it sounds like the most unsafe place to live in is Honduras—if you don't want to be 
 intentionally killed—while you should feel really safe from intentional killing in Japan. How is 
 your country doing? Mine is not that bad. I should probably avoid my local news stations that 
 make me feel like I'm living in a war zone.",NA
Getting ready,"There isn't much that you need to do. We will be using the Google Visualization API for 
 creating a geographic chart.",NA
How to do it...,"We will create a new HTML and a new JavaScript file and call them 
 08.01.geo-
 chart.html 
 and 
 08.01.geo-chart.js
 . Follow these steps:
  
 1. In the HTML file add the following code:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Geo Charts</title>
  
  
  <meta charset=""utf-8"" />   
  
  
  <script src=""http://www.google.com/jsapi""></script>
  
  
 <script src=""./08.01.geo-chart.js""></script>
  
  
  </head>
  
  
  <body style=""background:#fafafa"">
  
  
  <div id=""chart""></div>
  
  
  </body> 
  
 </html>
  
 2. Let's move to the 
 js
  file. This time around we will want to request from the Google 
 Visualization package the 
 geochart
  functionality. To do that we will start our code, 
 as follows:
  
 google.load('visualization','1',{'packages': ['geochart']});
  
 3. We'll then add a callback that will trigger the 
 init
  function when the package 
  
 is ready:
  
 google.setOnLoadCallback(init); 
  
 function init(){
  
  //...
  
 }
  
 4. Now it's time to add the logic within the 
 init
  function. In the first step, we will 
 format the data from Wikipedia to another format that will work for the 
 Google Visualization API:
  
 var data = google.visualization.arrayToDataTable([
  
  ['Country','Intentional Homicide Rate per 100,000'], 
 ['Honduras',87],['El Salvador',71],['Saint Kitts and   
 Nevis',68],
  
  ['Venezuela',67],['Belize',39],['Guatemala',39],  
 ['Jamaica',39],
  
  ['Bahamas',36],['Colombia',33],['South Africa', 32], 
 ['Dominican Republic',31],['Trinidad and  
  
  Tobago',28],['Brazil',26],
  
  ['Dominica', 22],['Saint Lucia',22], 
  
  ['Saint Vincent and the Grenadines',22],",NA
How it works...,"The logic of this recipe is very simple, so let's quickly dash through it and add some extra 
 features. As in all the other visualization charts, there are three separate steps:
  
 f 
  
 Defining the data source
  
 f 
  
 Setting up the chart
  
 f 
  
 Drawing the chart",NA
There's more...,"Let's add some extra customization to our chart. As with all Google Visualization 
 library elements, we can control many visuals through the 
 options
  object.
  
 The green color highlighted in our map just seems wrong. You would think that the less the 
 killings the greener a country would be, so where the killings are more, a darker shade of 
 red would be more appropriate. So let's change the colors by updating the 
 options
  object:
  
  var options = {width:800,height:600,
  
  colorAxis: {colors: ['#eeffee', 'red']}
  
  };",NA
Obtaining a Google API key,"To work with most of the Google APIs, you must have a Google API key. As such we will 
 go through the steps involved in getting a Google API key.
  
 Google API has certain limitations and constraints. Although most of the APIs are free to use 
 for small- to medium-sized sites, you are bound by some rules. Please refer to each library 
 for its rules and regulations.",NA
Getting ready ,"To get through this recipe you must have a Google ID; if you do not have one, you will need 
 to create one.",NA
How to do it...,"Let's list the steps required to gain access to the Google API: 
  
  
 1. Log in to the API console at 
 https://code.google.com/apis/console
 .
  
 2. Select the Services option from the left-hand side menu:
  
  
 3. Activate the API that you want to use (for example, in the next recipe 
 Building a 
  
 Google map
  we will use the Google Maps API v3 service):",NA
How it works...,"It's not hard to understand how this works. You just need to remember the steps as they 
 will be the baseline of the future Google API interactions that we create.
  
 As you must have noticed, there are many more API's in the Google library than we could 
 even go through, but I do recommend that you scan through them and explore your options. 
 In the next few recipes, we will be using the Google API to perform some mapping-related 
 tasks.",NA
Building a Google map,"Data and geography have a very natural relation. Data has more meaning when it's on a map. 
 Using live maps is a very good option as it would enable the users to interact with a UI that is 
 integrated with your own data presentations within the geographic area. In this recipe, we 
 will integrate our first, real live map.",NA
Getting ready,"To get through this recipe, you must have a Google ID. If you do not have one, you will need 
 to create one. Beyond that you will need to activate the Google Maps API v3 service in the 
 API Console. For more information on this, please review the recipe 
 Obtaining a Google API 
 key 
 discussed earlier in this chapter.
  
 Our goal will be to create a full-screen Google map that will be zoomed in and focused 
 on France:",NA
How to do it...,"Let's list the steps to create this sample. To create this sample we will create two files—
 a 
 .html
  file and a 
 .js
  file:
  
 1. Let's start with the HTML file. We'll create a basic HTML file baseline for our project:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Google Maps Hello world</title>
  
  
  <meta charset=""utf-8"" />
  
  
  </head>
  
  
  <body>
  
  
  <div id=""jsmap""></div>
  
  
  </body> 
  
 </html>",NA
How it works...,"The most important and first step is loading the 
 maps
  API. For Google to honor your 
 request, you must have a valid API key. As such, don't forget to replace the bolded text with 
 your key:
  
 <script src=""http://maps.googleapis.com/maps/api/js?key=
 YOUR_ 
 KEY
 &sensor=true"">
  
 Don't forget to use your own key. You might find yourself with a site that has a broken map. 
  
 The 
 sensor
  parameter in the URL is mandatory and must be set to 
 true
  or 
 false
 . If your 
 map needs to know where the user location is, you must set it to 
 true
 , and if not you may 
 set it to 
 false
 .
  
 Another interesting thing to note in our application is that it's the first time we have used 
 the viewport in our samples. As this topic is out of the scope of this book, I wanted to leave 
 it. I know that many of you will end up using maps in mobile devices and will want to have 
 the map default to a vertical/horizontal view. To learn more on how viewports work, check 
 out the article available at: 
 https://developer.mozilla.org/en/Mobile/ 
 Viewport_meta_tag/
 .
  
 You must have noticed that we set many things in our CSS to be 100 percent, and as you 
 probably guessed, it was for backward compatibility and validating that the map will fill 
 the entire screen. If you just want to create a hard-set width/height, you may do so by 
 replacing the CSS with the following code:
  
 <style>
  
  #jsmap { height: 200px; width:300px; }
  
 </style>
  
 That covers the main things we need to do in the HTML file.",NA
There's more...,"We haven't yet covered the details of how the 
 init
  function works. The basics of the 
 init 
 function are very simple. There are only two steps involved with creating a map. We need 
 to know what 
 div
  layer we want the map to be in and what options we want sent to our 
 map:
  
 var map = new google.maps.Map(div,options);
  
 Contrary to the Google Visualization API that had three steps in the last recipe, we can see 
 that the Google 
 maps
  API has only one step and within it we send the two options directly 
 to be rendered (there is no step between creating and rendering).
  
 Let's take a deeper look into the options as they are what will change the majority of 
 the visuals and functionality of the map.",NA
Adding markers and events,"It's great that we have a map on our screen (assuming that you have followed the last recipe 
 Building a Google map
 ), but what about connecting data and integrating it into our map. I'm 
 glad you asked about that, as this recipe will be our first step into adding data in the form of 
 markers and events.
  
 In this sample, our goal is to place four markers in New York City. When the markers 
 are clicked, we will zoom into that area and switch the map view type.",NA
Getting ready,"At this stage, you should have created (at least once) a Google map by using the JS API; if you 
 haven't, please revert back to the 
 Building a Google map
  recipe.",NA
How to do it...,"We are not making any further changes in the HTML page created in the last recipe 
 Building a 
 Google map
 ; as such we will focus our attention on the JavaScript file:
  
 1. Create an 
 init
  function:
  
 function init(){
  
 //all the rest of logic in here
  
 }",NA
How it works...,"Working with events and Google Maps is very easy. The steps involved always start from 
 calling the static method 
 google.maps.event.addListener
 . This function takes in three 
 parameters, namely the item to be listened to, the event type (as a string), and a function.
  
 For example, in our 
 for
  loop we create markers and then add events to them:
  
  google.maps.event.addListener(marker, 'click', function(ev) 
 {
  
  map.setZoom(INNER_ZOOM);
  
  
  map.panTo(ev.latLng);
  
  
  map.setMapTypeId(INNER_MAP_TYPE);
  
  
  });
  
 Instead we can create the event and then do not need to recreate a new anonymous function 
 each time we loop through:
  
 for(var i=0; i<aMarkers.length; i++){
  
  
  marker = new google.maps.Marker({
  
  
  position: aMarkers[i].local,
  
  
  map: map,
  
  
  title: aMarkers[i].label
  
  
  }); 
  
  google.maps.event.addListener(marker, 'click', 
 onMarkerClicked
 );",NA
There's more...,"You might have noticed that we use the method 
 map.panTo
 , but no panning actually happens 
 and everything snaps to place. If you run the map, you will discover that we don't actually see 
 any panning; that is because we are switching the map type, zooming out, and panning at the 
 same time. Only panning can actually animate without a few tricks and bypasses, but all these 
 steps make our application a lot more complex and the actual control over animation is very 
 limited. We will come up with a solution to that in the next recipe as we use two maps instead 
 of one in 
 Customizing controls and overlapping maps
 . If we wanted we could add in a delay and 
 do each step separately and animate the pan, but if we want to create a smooth transition, I 
 would think about the idea of having two separate maps, one on top of each other instead, and 
 fading in and out the main world map.",NA
Customizing controls and overlapping maps,"The goal of this recipe is to practice working with Google Maps. We will integrate what we 
 learned about working with Google Maps in this chapter and incorporate our control over 
 the user behaviors, such as what controllers the user can use, into it. We will start digging 
 into creating our own unsupported undocumented behaviors, such as locking the users' pan 
 area.",NA
Getting ready,"Even though we are starting from scratch, a lot of the work that we did in the last recipe is 
 being re-used, so I strongly encourage you to go through the last recipe 
 Adding markers 
 and events
  before moving into this one.
  
 In this recipe, we will be integrating jQuery into our work as well, to save us time on 
 creating our own animator tool (or re-using the one that we created in the 
 Animating 
 independent layers
  recipe in 
 Chapter 6
 , 
 Bringing Static Things to Life
 ), as it would take us 
 away from our main topic.",NA
How to do it...,"In this recipe we will be creating two files. An HTML file and a JS file. Let's look into it, 
 starting with the HTML file:
  
 1. Create an HTML file and import the Google 
 maps
  API and jQuery:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Google Maps Markers and Events</title>
  
  
  <meta charset=""utf-8"" />
  
  
  <meta name=""viewport"" content=""initial-scale=1.0,  
  
  
 user-scalable=no"" />
  
  
  <script src=""http://ajax.googleapis.com/ 
  
  
  ajax/libs/jquery/1.7.2/jquery.min.js""></script>
  
  
  <script  
  
  
  src=""http://maps.googleapis.com/maps/api/js?key= 
  
  
 AIzaSyAywwIFJPo67Yd4vZgPz4EUSVu10BLHroE&sensor=true""> 
  
  </script>
  
  
  <script src=""./09.05.controls.js""></script>
  
  
  </head>
  
  
  <body onload=""init();"">
  
  
  <div id=""mapIn""></div>
  
  
  <div id=""mapOut""></div>
  
  
  </body> 
  
 </html>",NA
How it works...,"Our biggest step is the creation of two maps, one overlapping the other. We did that with 
 some CSS magic by layering the elements and putting our top layer at the last position in the 
 stack (we could probably use the z-index to validate it, but it worked so I didn't add that to 
 the CSS). After that we created our two 
 div
  layers and set their CSS code. In the JavaScript 
 code, contrary to the way we did in the last recipe, we hardcoded the values that we wanted 
 into both the maps.",NA
There's more...,"When you try to drag around the higher-level map (the first visible map), you will notice 
 that the map cannot move—it's not pannable. Google API v3 doesn't support the capability 
 to disable the panning, but it does support the capability to get updated every time the map 
 center point changes.
  
 As such we listen in to the following change:
  
 google.maps.event.addListener(mapOut, 'center_changed', function() {
  
  mapOut.panTo(BASE_CENTER); 
  
 });
  
 All we are doing is that each time the map position changes, we force it back to its 
 original position, making it impossible to move our map around.",NA
Redesigning maps using styles,"Many a time when creating more advanced applications by using Google Maps, you will want 
 to create your own custom, skinned maps. This is really useful when you want to have a 
 foreground content and don't want to have it compete with the background content.
  
 In this recipe we will create a few styled maps. By the end of this recipe, you will know how 
 to create global customization, individual styles, and last, but not least, add new map types.
  
 Here is one style that we will create:",NA
Getting ready,"To complete this recipe, you will have to start from a copy of the previous recipe. We will 
 only describe the new steps that differ from the last example in this recipe. To view and 
 understand all the steps, please read the 
 Customizing controls and overlapping maps
  recipe.
  
 As such, we will skip the HTML code as it's exactly the same as in the previous recipe.",NA
How to do it...,"Open up your JavaScript file (
 09.05.controls.js
 ) from the last recipe and follow 
 these steps:
  
 1. Within the 
 init
  function create a 
 aVeinStyle
  array. This array contains all the 
  
 visual guides for skinning the map in the vein style:
  
 var aVeinStyle =  [
  
  
  {
  
  
  featureType:'water',
  
  
  elementType: ""geometry"",
  
  
  stylers:[{color:'#E398BF'}]
  
  
  },
  
  
  {",NA
How it works...,"Working with Google styles is fun, and they work in a way that is very similar to the way 
 CSS works. The style we set has a few steps; the first step is to create the rules of the style, 
 the next one is to define a Google-style object (
 google.maps.StyledMapType
 ), and the 
 last step is to define what map this style information is relevant to. Styles can only be 
 applied to the maps of the 
 google.maps.MapTypeId.ROADMAP
  type.
  
 The first example is the creation of the bus style. The goal of this style is to make the map 
 black and white and only highlight the public transportation stations:
  
 var aBusStyle =  [
  
  
  {
  
  
  stylers: [{saturation: -100}]
  
  
  },
  
  
  {
  
  
  featureType:'transit.station.rail',
  
  
  stylers:[{ saturation:  
  
  
  60},{hue:'#0044ff'},{visibility:'on'}]",NA
There's more...,"Now that we have under our belts how to create the styles we want to use, the next critical 
 step is to actually connect our style to the map. The easiest way to do it (if we only have 
 one style) is to connect it directly to the map:
  
 inMap.setOptions({styles: styles});",NA
10 ,NA,NA
Maps in Action,"In this chapter we will cover the following topics:
  
 f 
  
 Connecting a Twitter feed to a Google map
  
 f 
  
 Building an advanced interactive marker
  
 f 
  
 Adding multiple tweets into an InfoWindow bubble
  
 f 
  
 Customizing the look and feel of markers
  
 f 
  
 Final project: building a live itinerary",NA
Introduction,"In this chapter on mapping, we will tie in more deeply to our topic of data visualization. One of 
  
 the most popular ways to visualize data these days is by using maps. In this chapter, we will 
  
 explore a few ideas on how to integrate data into maps, using the Google Maps platform.",NA
Connecting a Twitter feed to a Google map,"This is the start of a very fun experiment with Google Maps. The goal of the task is to create a 
 link between Twitter posts and a Google map. It will take us a few recipes to get to our final 
 goal. By the end of this recipe, we will have a Google map. This Google map will be clickable in 
 any area of the screen. When the user clicks on the map, they will connect to the Twitter API 
 and search for tweets in that area that have the word ""HTML5"" in them. When the result 
 comes back, it will pop a new marker onto the area that was clicked and add the most recent 
 tweet on that topic originating from that location. At this stage, it would just be a marker with 
 a rollover that shows us the actual tweet without more information.",NA
Getting ready,"If you haven't read through 
 Chapter 9
 , 
 Using Google Maps
 , you might find this chapter a little 
 difficult, so I encourage you to read it before starting with this recipe. At this stage you 
 should have a Google API set up (see the 
 Obtaining a Google API key
  recipe in 
 Chapter 9
 ).",NA
How to do it...,"We will create new HTML and JavaScript files and call them 
 10.01.socielmap.html
  and 
 10.01.socielmap.js
 , respectively, and then perform the following steps:
  
 1. Add the following code in the HTML file using your own API key:
  
 <!DOCTYPE html>
  
 <html>
  
  <head>
  
  <title>Google Maps Markers and Events</title>
  
  <meta charset=""utf-8"" />",NA
How it works...,"We live in an age when data about almost anything increasingly overlaps with geolocation 
 data and maps. It's almost impossible to write a book about data without talking about maps, 
 and it's not possible to write a book about data visualization without at least opening the 
 Pandora's box of the world of mapping and its possibilities, either.
  
 Twitter lately has been trying more and more to capture the location of users. For most of 
 the time, the location is still void. That having been said, Twitter always knows the base 
 location of users based on their information, and more so when users tweet through their 
 cell phones. As such, Twitter always has a rough idea of where users are when they send a 
 message, and in the coming years this accuracy is expected to only get better. In the future, 
 more and more Twitter results will have such an accurate location for users that we will be 
 able to pinpoint them directly on a map.
  
 After creating the map, the first step is that, as soon as a user clicks on any area of the map, 
 we start building out a search query to be used on the Twitter API:
  
 google.maps.event.addListener(map, 'click', function(e) {
  
  //console.log(e.latLng);
  
  var searchKeyWord = 'html5';
  
  var geocode=e.latLng.lat() + "","" + e.latLng.lng()+"",50km"";
  
  
  var searchLink = 'http://search.twitter.com/search.json?q='+ 
 searchKeyWord+ '&geocode=' + geocode +""&result_type=recent&rpp=1"";
  
 We don't cover all the possibilities with search, but instead we are focusing on two main 
 points: the search query, in our case HTML5, and the location of the query. We get the 
 location information directly from the event that is passed into a marker. We reformat the 
 information from our Google returned event and format it into a string, adding to it the 
 range; in our case we set this to 50 kilometers (you can choose 
 ml
  for miles as well). As we 
 are taking a look at the map of Europe now, I thought it would be appropriate to work in 
 kilometers and not miles.
  
 We want to get our search values back as JavaScript Object Notation (JSON) values. JSON is a 
 very minimal shorthand way to pass object information as strings between servers. For the 
 most part, you will usually work with automatic converters so you will be sending objects and 
 getting objects, but under the hood there is a JSON encoder and decoder that will process the 
 request.
  
  
 If you don't know what JSON is, don't worry about it; it's all 
  
  
 done in the background and it's not critical to understand 
  
 how JSON works in order to work with it.",NA
Building an advanced interactive marker,"The next step in our social map project is to add more details for our Twitter search result. 
 We would like to open up an information panel automatically when the Twitter result 
 comes in. In the process, we will create a subclass of Google Marker and extend it and add a 
 new InfoWindow to enable us to add live HTML data right into our map.",NA
Getting ready,"It will be really hard to join in, if you haven't started from the start of this chapter. As this 
 recipe is in continuation of the previous recipe, we will not create a new HTML file or a 
 new JavaScript file but will instead continue from where we left off.",NA
How to do it...,"Grab your latest JavaScript file and let's continue to the next steps:
  
 1. In the function 
 showTweet
 , replace the new marker with a new 
  
 TwitterMarker
  marker.
  
 function showTweet(obj,latLng){
  
  
  if(!obj) obj = {text:'No tweet found in this area for this 
 topic'};
  
  
  console.log(obj); 
  
  var marker = new TwitterMarker({
  
  map: map,
  
  position: latLng,
  
  tweet: obj,
  
  title:obj.text    });  
  
  }",NA
How it works...,"Although there are not many lines, a lot of logic is condensed into this code. Let's start by 
 looking at our new marker. This is the first time in this book that we use inheritance. 
 Inheritance, as its name implies, enables us to extend the features of an object in JavaScript 
 without affecting the original object. In our case, we want to take all the features of the 
 marker (methods, properties, and so on) and add to them some custom behaviors.
  
 The inheritance is done in JavaScript by defining a prototype. Until now, we have used the 
 prototype without talking about it much, but we used it mainly to create new methods. If 
 we assign a full object to the prototype, all of the properties and methods of that object will 
 be copied into our new object as well.
  
 TwitterMarker.prototype = new google.maps.Marker();
  
  
 Always start first with extending of the object you want to 
  
  
 extend, before any other additions. This is because if you've 
  
 placed any new prototype methods before this line of code, 
  
 they will silently be deleted and thus will not work.
  
 The 
 buildTwitterHTML
  method takes in the Twitter object returned and converts some of 
 its data into HTML. We use this method once per marker. When we create a new marker, we 
 create a new 
 InfoWindow
  object as well. We place an InfoWindow on top of the marker and 
 showcase the tweet information.
  
  function TwitterMarker(opt){
  
  var strTweet = this.buildTwitterHTML(opt.tweet)
  
  this.infoWindow = new google.maps.InfoWindow({
  
  maxWidth:300,
  
  content:strTweet
  
  });
  
 We are setting the width as well, to avoid having a really big panel. We send our newly 
 created 
 strTweet
  string into the 
 infoWindow
  object.",NA
Adding multiple tweets into an ,NA,NA
InfoWindow bubble,"So far, in our interactive social map, we added markers in each location that we clicked on 
 and opened up an InfoWindow with the tweet information. Our next step will be to enable 
 multiple tweets to live inside our InfoWindow by adding a pagination system into our 
 window.",NA
Getting ready,"To get through this recipe you must be knee deep into our holistic chapter. If you dropped 
 in just now, it would be a good idea to go back to the start of this chapter as we are going to 
 continue from where we left off in the previous recipe.",NA
How to do it...,"We are still in our JavaScript file and we will continue to add code and adjust our code to 
 get multiple Twitter posts into our social map.
  
 1. Let's start by changing our Twitter search to return up to 100 values per search. 
  
 We are doing this because there is a limit on how many times we can call the 
 Twitter API. So, we will try to grab as much as we can in one hit (this code should 
 be around line 30).
  
 var searchLink = 'http://search.twitter.com/search.
  
 json?q='+ searchKeyWord+ '&geocode=' + geocode +""&result_ 
 type=recent&rpp=100"";
  
 2. As we are now going to treat all the tweets that come back, we will need to change 
 our references to send to our 
 TwitterMaker
  marker the full array (changes 
 highlighted in the code snippet).
  
  google.maps.event.addListener(map, 'click', function(e) { 
 //console.log(e.latLng);
  
  
  var searchKeyWord = 'html5';
  
  
  var geocode=e.latLng.lat() + "","" + e.latLng.lng()+"",50km"";
  
  var searchLink = 'http://search.twitter.com/search.
  
 json?q='+ searchKeyWord+ '&geocode=' + geocode +""&result_ 
 type=recent&rpp=100"";
  
  
  $.getJSON(searchLink, function(data) 
 {
  
   
  showTweet(data.results,e.latLng);
  
  });
  
  });
  
  
  function showTweet(a,latLng){
  
   
  if(!a) a = [{text:'No tweet found in this area for this 
 topic'}];
  
   
  //console.log(obj); 
  
  var marker = new TwitterMarker({
  
  map: map,
  
  position: latLng,
  
  tweet: a,
  
  title:a[0].text    }); 
  
  
  } 
  
 }",NA
How it works...,"Our first change was to change the number of results coming back from the Twitter search 
 API. This change forced us to change the references in our code from referring directly to the 
 first object returned to focus on the full results object and sending it to our 
 TwitterMarker 
 constructor. This change created a few smaller changes in the flow of the information within 
 the constructor as well.",NA
Customizing the look and feel of markers,"This will be our last recipe for social mapping. In this recipe, we will revisit our marker itself 
 and give it a facelift. As our marker represents Twitter messages in a clicked area, we will 
 update our marker to look like a Twitter bird (hand made). We will not stop there; after 
 updating our graphic, we will add another graphical layer to shadow our Twitter marker. It 
 will be a shadow, and its opacity will range from zero to full, depending on the number of 
 tweets (a maximum of hundred tweets).
  
 The best way to understand our goal is by checking out the following screenshot:
  
  
 Note how some tweets have no visible circle outline, while others have a very dark one (that is 
 based on how many tweets are there).",NA
Getting ready,To complete this task you need to first complete all the previous recipes in this chapter.,NA
How to do it...,"We will jump right into the JavaScript file and continue from where we left off in 
 the previous recipe.
  
 1. Update the 
 showTweet
  function.
  
 function showTweet(a,latLng){
  
  
  if(!a) a = [{text:'No tweet found in this area for this 
 topic'}];
  
  
  //console.log(obj); 
  
  var marker = new TwitterMarker({
  
  map: map,
  
  position: latLng,
  
  tweet: a,
  
  title:a[0].text,
  
  icon:""img/bird.png""    });  
  
  }
  
 2. Create an instance of the 
 MarkerCounter
  object in the 
 TweeterMarker 
  
 constructor.
  
 function TwitterMarker(opt){
  
  
  this.count = opt.tweet.length;
  
  
  this.mc = new MarkerCounter(opt);
  
  
  this.crnt = 0; 
  
 ...
  
 3. Create the 
 MarkerCounter
  constructor.
  
 function MarkerCounter(opt) {
  
  
  this.radius = 15;
  
  
  this.opacity = (opt.tweet.length) /100;
  
  
  this.opt = opt;
  
  
  this.setMap(opt.map);
  
  
  }
  
 4. Create subclass, 
 MarkerCounter
 , for the 
 google.maps.OverlayView
  object.
  
 MarkerCounter.prototype = new google.maps.OverlayView();
  
 5. Create an 
 onAdd
  method. It will be called automatically when an element is added into 
 the map. In this method, we will finish up all the preparatory work for the drawing 
 but won't draw the elements.
  
 MarkerCounter.prototype.onAdd = function() 
 {
  
  var div = 
 document.createElement('div');
  
  
 div.style.border = ""none"";
  
  
  div.style.borderWidth = ""0px"";",NA
How it works...,"The first step is to swap the graphic that is the default graphic for the marker. As we are 
 extending the regular marker, we have all of its default features and behaviors. One of these 
 features is the ability to swap the icon. To do that, we pass in one of our object parameters as 
 the icon and its path.
  
 var marker = new TwitterMarker({
  
  map: map,
  
  position: latLng,
  
  tweet: a,
  
  title:a[0].text,
  
  icon:""img/bird.png""    });
  
 You might be wondering how this actually works, as we are not actually doing anything to 
 the icon parameter in our code. It's very simple. If you take a deeper look at the 
 TwitterMaker 
 constructor, you will find the following line:
  
 this.setValues(opt);
  
 Passing the 
 setValues
  method to the 
 opt
  object is our way of letting the marker continue 
 and rendering our marker with the information we just got into our constructor. All the 
 things that can be done in a regular marker can be done in ours as well.
  
 At this stage we have our Twitter bird as our graphic interface for our marker. 
 Unfortunately, this is as far as we can go with customizing our marker; next, we will need 
 to add another visual layer. As we want to create a visual layer that behaves like a marker 
 just visually (as it will be part of the marker), we will need to create a subclass for the 
 google.maps. OverlayView
  object.
  
 Similar to the marker logic, when we are ready to render our element, we want to call the 
 method 
 setMap
  (for the marker it was a different method but the same idea).
  
 function MarkerCounter(opt) {
  
  this.radius = 15;
  
  this.opacity = (opt.tweet.length) /100;
  
  this.opt = opt;
  
  this.setMap(opt.map);
  
  }
  
  MarkerCounter.prototype = new google.maps.OverlayView();
  
 In our constructor, we are only storing very basic global information, such as our 
 target opacity, radius, and the 
 options
  object. We can store any information we want 
 here. 
  
 The most important element of information that we will need is the position (latitude and 
 longitude). We will send that information into our marker, and it will be inside our 
 opt
  
 object.",NA
Final project: building a live itinerary,"Although the natural next step from our previous sample would be just to add an extra 
 feature to our already growing social map (which we have built throughout this chapter), we 
 are taking a direction shift.
  
 In our final recipe, we will build an interactive Google map that will animate with the travel 
 information of a close friend of mine in South America while I was working on this book. 
 To build this application, we will animate the map by adding drawings and moving 
 markers; we will integrate with an external feed of travel information and integrate 
 animations and text snippets that will describe the journey. In the following screenshot, 
 you can see a very small snapshot of the plain path:",NA
Getting ready,"Many of the elements we will be working with in this recipe will be based on work we did 
 throughout all of the chapters. As such, it will not be easy to just jump right in if you 
 haven't gone through the journey together with us. There are no prerequisites. We will 
 start from scratch, but we will not focus on things we have learned already.
  
 As the user ""travels"" around the world map when there is a message for the user in the data 
 source, the map will fade out and the message will be displayed before the user can continue 
 traveling the world:",NA
How to do it...,"In this recipe we will be creating two files: an HTML file and a JavaScript file. Let's look 
 into them, starting with the HTML file:
  
 1. Create the HTML file.
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>Google Maps Markers and Events</title>
  
  
  <meta charset=""utf-8"" />
  
  
  <meta name=""viewport"" content=""initial-scale=1.0, user-
  
 scalable=no"" />
  
  
  <link href='http://fonts.googleapis.com/css?family=Yellowtail' 
 rel='stylesheet' type='text/css'>
  
  
  <style>
  
    
  html { height: 100% }
  
    
  body { height: 100%; margin: 0; padding: 0 }
  
    
  #map { height: 100%; width:100%; position:absolute; top:0px; 
 left:0px }
  
  .overlay {
  
  background: #000000 scroll;
  
  height: 100%;
  
  left: 0;
  
  opacity: 0;",NA
How it works...,"There are many components in this example, but we will focus mainly on the new steps 
 that we haven't covered in any other part of this book.
  
 The first new thing we meet is right in our HTML and CSS:
  
 <link href='http://fonts.googleapis.com/css?family=Yellowtail' 
 rel='stylesheet' type='text/css'>
  
 We picked a font from the Google font library at 
 http://www.google.com/webfonts
  and 
 integrated it into the text overlays.
  
 .overlayBox {
  
  
  ...
  
  
  font-family: 'Yellowtail', cursive;
  
  }
  
 It is time to travel into our JavaScript file, which we start by loading in the Google 
 Visualization Library. It's the same library we were working with in 
 Chapter 8
 , 
 Playing with 
 Google Charts
 . Once it's loaded, the 
 init
  function is triggered. The 
 init
  function starts our 
 map up and starts loading in the spreadsheet.",NA
There's more...,"Let's take a deeper look at the logic behind the 
 GoogleMapTraveler.prototype. 
 nextPathPoint
  method. The first thing we do in this function is to set our map 
 view.
  
 this.setPosition(index-1,2);
  
 The 
 setPosition
  method does a few things that are all related to repositioning our map and 
 our zoom level based on the data in the current index that is sent. It's a bit smarter than that as 
 it takes in a second parameter that enables it to average out two points. As one travels 
 between two points, it would be best if our map is at the center of the two points. That is done 
 by sending in 
 2
  as the second parameter. The internal logic of the 
 setPosition
  method is 
 simple. It will loop through as many items as it needs to, to average out the right location.
  
 Next, we add a new point to our 
 this.pathPoints
  array. We start by duplicating the same 
 point that is already in the array, as we want our new second point to start from the starting 
 point. This way, we can update the last value in our array each time, until it reaches the end 
 goal (of the real next point).
  
 this.pathPoints.push(this.getPosition(index-1,1)); //add last point 
 again
  
 We create a few helper variables. One will point to the new object we just created and 
 pushed into our 
 pathPoints
  array. And the second is the point that we want to reach at the 
 end of our animation.
  
 var currentPoint = this.pathPoints[this.pathPoints.length-1];
  
 var point = this.getPosition(index,1);
  
  
 The first variable is not a new object but a reference to the 
  
  
 last point created, and the second line is a new object.",NA
Index,NA,NA
Symbols,$.getJSON function  292,NA
A,"aColorsLength variable  12 
  
 addColorStop method  52 
  
 addColumn method  243 
  
 addDots function  109, 112 
  
 addLine function  79 
  
 addRows method  243 
  
 addStock function  97 
  
 advanced interactive marker 
  
  
 building  293-296 
  
  
 working  295 
  
 animated 3D chart (canvas3DGraph) 
  
  
 creating  211-214 
  
  
 working  214, 215 
  
 animateSeconds recursive function  226 
 animateStrokeWidth function  227
  
  
 chart outlines, defining  64 
  
  
 code, revisiting  66, 67 
  
  
 createBars function, using  68 
  
  
 data bars, creating  64 
  
  
 data set, defining  63 
  
  
 fillChart function, using  67, 68 
  
  
 graph outlines, defining  63 
  
  
 working  64-66 
  
 barStyle property  215 
  
 baseCanvas object  183 
  
 basic shapes 
  
  
 starting  14, 15 
  
 beginPath method  12, 19 
  
 bezier curve 
  
  
 creating  42-46 
  
 bubble chart 
  
  
 bubbles text format, improving  118 
  
 building  105-111 
  
  
 working  111 
  
 buildTwitterHTML method  295, 299
  
 Animator object 
  
 updating  323, 324",NA
C,"animQue array  191, 192 
  
 appendRadioButton function  176 
 application 
  
  
 OOP perspective, moving to  177 
 arcs 
  
  
 drawing  37-39 
  
 arguments array  235 
  
 aTotal array  91",NA
B,"bar chart 
  
 about  62 
  
 building, from scratch  62-64
  
 candlestick chart (stock chart) 
  
  
 creating  92-94 
  
  
 working  96 
  
 canvas 
  
  
 about  8 
  
  
 arcs, drawing  38, 39 
  
  
 bezier curve, creating  42-46 
  
  
 curves, creating  37 
  
  
 curves, drawing with control point  40-
 42 
  
 images, integrating into art  46-
 48 
  
  
 pixel manipulation  54-59 
  
  
 shapes, drawing  7 
  
  
 text, drawing with  50-53",NA
D,"dashboard 
  
  
 adding, to Google charts  254-258 
  
 data source 
  
  
 changing, to Google Spreadsheet  248-251 
 Domain Specific Languages. 
 See
   DSLs
  
 customizing, with options object  252-254 doughnut chart
  
 ChartWrapper about  119
  
  
 used, for creating Google charts  245-247 
 clearRect method  13
  
 legend, creating  123 
  
 outline, adding  122, 123
  
 clock used, for showing relationships  119-122
  
 building, with RaphaelJS  222-227 working  122
  
 closePath method  12, 19 drawChart function  171
  
 closeYOffset variable  98 optimizing  174
  
 complex shapes 
  
 createTriangle function, creating  27 
 creating  24-30
  
 drawChart update code  195 
  
 drawDataWeb method  128 
  
 drawImage function  49, 57
  
 flag strips, drawing  27 drawRect method  79
  
 context-aware legend 
  
  
 createLegend method, updating  199
  
 drawTree function  131 
  
 drawTreeMap function
  
 creating  198-200 creating  152
  
  
 event listener onMouseMoveArea, 
   
 changing  200 
  
  
 fillChart method  200 
  
  
 updateLegend method, updating  199 
  
 working  201, 202 
  
 context parameter  113 
  
 context variable  55 
  
 controls, Google maps 
  
  
 customizing  276-278 
  
 createBars function 
  
  
 using  68
  
 turning, into recursive function  156",NA
E,"ECMAScript for XML (E4X) 
  
  
 about  129 
  
  
 online resources  132 
  
  
 working  132 
  
 elementStatus  147 
  
 elementValue*stepSize element  89 
 elementValue variable  89
  
 createDots function  74 
  
 createLinearGradient method  52",NA
F,"createNode function  235 
  
 createOutline function  111 
  
 createSpider function  125 
  
 createWaterfall function  90 
  
 currentRadian  34 
  
 currentXIndex variable  201 
  
 curves 
  
  
 drawing, with control point  40-
 42
  
 fadeOutImage  56 
  
 featureType property  285 
  
 fillChart function 
  
  
 about  67, 183 
  
  
 using  67 
  
 fillRect method  11 
  
 fill shapes 
  
  
 creating, in line chart  82, 83 
  
 fillStyle method  52 
  
 fillText  51 
  
 fillTriangle() function  21
  
  
  
   
 326",NA
G,"gauge meter (jqPlot) 
  
  
 animating  206-208 
  
  
 working  209, 210 
  
 gData array  215 
  
 geographic chart 
  
  
 creating, with Google visualization 
  
   
 API  260-262 
  
  
 smaller areas, making visible  264, 265 
 getData function  222 
  
 getImageData function  58 
  
 getPanes method  307 
  
 getPosition method  314 
  
 Google API key 
  
  
 obtaning  265-267 
  
  
 working  267 
  
 Google Charts 
  
  
 chart, changing in one line  247 
  
  
 chart properties, customizing with options 
   
 object  252-254 
  
  
 chart type, changing  245 
  
  
 creating, ChartWrapper used  245, 247 
  
 dashboard, adding  254-257 
  
  
 data source, changing to Google 
  
   
 Spreadsheet  248-251 
  
  
 pie chart, creating  239-242 
  
 Google map 
  
  
 building  267-270 
  
  
 controls, customizing  275-279 
  
  
 features  259 
  
  
 latitude and longitude, working with  271 
  
 maps, overlapping  275-279 
  
  
 maps, redesigning using styles  280-285 
  
 map types  271
  
 Google maps, creating 
  
  
 geographic chart, creating with Google 
  
   
 visualization API  260-262 
  
  
 Google API key, obtaining  265-267 
  
 google.maps.LatLng object  314 
  
 google.maps.MapTypeId.HYBRID  271 
  
 google.maps.MapTypeId.ROADMAP  271 
 google.maps.MapTypeId.SATELLITE  271 
  
 google.maps.MapTypeId.TERRAIN  271 
  
 google.maps.OverlayView object  307 
  
 GoogleMapTraveler object  313, 315, 320 
 GoogleMapTraveler.prototype.nextPathPoint 
   
 method  321 
  
 gradients 
  
  
 using, in text  53 
  
 graphical layers 
  
  
 code, streamlining  174, 175 
  
  
 drawChart function, optimizing  174 
  
  
 radio buttons, creating  176, 177 
  
  
 stacking  168-172 
  
  
 working  173, 174 
  
 graphics, with 2D canvas 
  
  
 about  8 
  
  
 canvas element, creating  8 
  
  
 helper variables, creating  10 
  
  
 HTML5 document, creating  8 
  
  
 JavaScript file, importing into 
  
   
 HTML document  9 
  
  
 nested loop, creating  10 
  
  
 onLoad listener, adding  9 
  
  
 rectangle, creating  10 
  
  
 updateCanvas function, creating  9 
  
  
 working  10-13 
  
 grayStyle styling object  290",NA
H,"helper global variables  55 
  
 helveticaForClock  224 
  
 hideOverlayCopy method  315 
 href buttons  301
  
  
  
 327",NA
I L,"imageData.data array  58 label parameter  113
  
 image grayscale latitude and longitude
  
 making  60 working with  271
  
 images latLng property  275
  
 control, adding  49 levelDistance property  237
  
 integrating, into art  46-48 line charts
  
 scaling  49 about  76
  
 using, as fill  49 building  76-78
  
 independent layers 
  
 add method, creating  188 
  
 animating  187-191 
  
 Animator constructor, creating  188 
  
 internal_animate method, creating  189
  
 fill shapes, creating  82, 83 
  
 formatData function, creating  79 
  
 logic of onChangedRadio, breaking  150 
 making interactive  145-149 
  
 switch mode, enabling between dots 
  
 InfoVis and lines  82
  
 about  229 working  79, 81
  
 used, for making sunburst chart  229-234 lineHeight variable  18
  
 working  234-237 listener function  290
  
 InfoWindow live flag sample
  
 about  293-295 in action  20, 21
  
 multiple tweets, adding  297-302 live itinerary project
  
 init function  55 building  310-319
  
 innerRadius  34 working  319-322
  
 interactive click meter look and feel, markers
  
 creating  162-165 customizing  303-306
  
  
 working  165, 166 
  
 interactive Google map 
  
  
 building  310-319 
  
 interactive legend 
  
  
 createLegend method, creating  194 
  
 creating  193-196 
  
  
 updateLegend method, creating  194 
  
 working  197, 198 
  
 intervalColors function  210 
  
 intervalOuterRadius  209 
  
 intervals function  210 
  
 isStarting variable  209",NA
M,"map types  271 
  
 MarkerCounter constructor  304 
  
 markers 
  
  
 look and feel, customizing  303-308 
 markers and events 
  
  
 adding, to Google map  272-275 
 Math.cos() 
  
  
 using  117 
  
 Math.min method  91 
  
 Math.sin()",NA
J,"JavaScript Object Notation (JSON)  291 
 jqPlot 
  
  
 using  206 
  
 JQuery 
  
  
 using  206
  
  
 using  117 
  
 meterGaugeRenderer library  209 
 midRadian variable  117 
  
 moveTo function  18 
  
 multiple tweets 
  
  
 adding, into InfoWindow  297-300 
 MyFirstObject function  181
  
  
  
   
 328",NA
N ,nextPathPoint method  315,NA
O ,"onAdd method  307 
  
 onChangedRadio callback function  172 
 onChangedRadio function  148
  
 projection.fromLatLngToDivPixel method  308 
 pyramid chart 
  
  
 about  138 
  
  
 creating  138-140 
  
  
 findLine function  142, 143 
  
  
 logic in init function, changing  143, 144 
  
  
 text, adding to graph  144 
  
  
 working  141
  
 onLoad event  62, 289 
  
 breaking  150",NA
Q,"onreadystatechange callback property  96 
 onTimeReset function  163 
  
 onTripDataReady listener  313 
  
 OOP perspective 
  
  
 base canvas element, moving into 
  
   
 constructor  183 
  
  
 charts, creating for testing  186, 187 
  
  
 code, converting  178 
  
  
 functions, updating  179 
  
  
 helper function, creating  180 
  
  
 HTML components, creating  183-185 
  
 init function, rewriting  180 
  
  
 lose ends, removing  185 
  
  
 working  181, 182 
  
 over time (flotJS) 
  
  
 charting  217-221 
  
  
 getData, creating  220 
  
  
 ready event, creating  220 
  
  
 updateChart, creating  220",NA
P,"paths 
  
  
 animating  228 
  
 pie chart 
  
  
 creating  114, 115, 239-241 
  
  
 Math.cos() and Math.sin(), using  117 
  
 working  116, 242, 243 
  
 pixel manipulation 
  
  
 about  54-56 
  
  
 image grayscale, making  60 
  
  
 pixel reversing  60 
  
  
 working  57-59 
  
 Pixel reversing  60 
  
 plotBar function  215 
  
 plugin coding  99
  
 quadratic curve 
  
 about  40 
  
 drawing  40",NA
R,"radar  123 
  
 radar chart 
  
  
 about  123 
  
  
 creating  125, 126 
  
  
 rotated legend, adding  128, 129 
  
  
 working  127, 128 
  
 radio buttons 
  
  
 creating  176 
  
 RaphaelJS 
  
  
 used, for building clock  222-227 
  
  
 working  227 
  
 readyState variable  96 
  
 rectangles 
  
  
 creating  23, 24 
  
  
 layering, for creating flag of Greece  16-18 
 rect method  79 
  
 refreshChart function  164 
  
 refreshRate property  191 
  
 renderLine method  315 
  
 renderList object  202 
  
 render options 
  
  
 adding, to stock chart  102 
  
 renderOptions object  209 
  
 ren parameter  202 
  
 restore method  111 
  
 rotate method  111",NA
S,"save method  111
  
  
  
 329",NA
U,"updateCanvas function  11 
  
 UpdateChart function  222 
  
 updateCumulativeChartInfo function  91 
 updateMeter function  208 
  
  
 creating  210 
  
 user interaction 
  
  
 adding, to tree mapping  158-161
  
 lightness  284 
  
 saturation  284",NA
V,"visibility  284 sunburst chart 
 creating, with InfoVis  229-234
  
 vector drawing tool  54 
  
 vertices 
  
  
 adding, to shapes  31-34",NA
T W,"text 
  
  
 drawing with  50-53 
  
  
 gradients, using  53 
  
  
 shadows and glows, adding  54 
 this.barData property  202 
  
 tickFormater method  218 
  
 ticks function  210
  
 waterfall chart 
  
  
 about  84 
  
  
 creating  84 
  
  
 format of numbers, clearing  92 
  
 weeklyCapture function  99 
  
 window.onload callback function  169
  
 trailCount variable  215 translateCSV function  94, 97",NA
X,"translate method  111 
 Traveler marker  323
  
 XMLHttpRequest object  96
  
  
  
   
 330",NA
Thank you for buying ,NA,NA
HTML5 Graphing and Data ,NA,NA
Visualization Cookbook,NA,NA
About Packt Publishing ,"Packt, pronounced 'packed', published its first book ""
 Mastering phpMyAdmin for Effective MySQL 
 Management
 "" in April 2004 and subsequently continued to specialize in publishing highly focused 
 books on specific technologies and solutions.
  
 Our books and publications share the experiences of your fellow IT professionals in adapting and 
 customizing today's systems, applications, and frameworks. Our solution based books give you 
 the knowledge and power to customize the software and technologies you're using to get the job 
 done. 
  
 Packt books are more specific and less general than the IT books you have seen in the past. Our 
 unique business model allows us to bring you more focused information, giving you more of 
 what you need to know, and less of what you don't.
  
 Packt is a modern, yet unique publishing company, which focuses on producing 
 quality, cutting-edge books for communities of developers, administrators, and 
 newbies alike. For more information, please visit our website: 
 www.packtpub.com
 .",NA
Writing for Packt ,"We welcome all inquiries from people who are interested in authoring. Book proposals should be 
 sent to 
 author@packtpub.com
 . If your book idea is still at an early stage and you would like to 
 discuss it first before writing a formal book proposal, contact us; one of our commissioning 
 editors will get in touch with you. 
  
 We're not just looking for published authors; if you have strong technical skills but no writing 
 experience, our experienced editors can help you develop a writing career, or simply get some 
 additional reward for your expertise.",NA
HTML5 Canvas Cookbook ,"ISBN:  978-1-849691-36-9            Paperback: 348 pages
  
 Over 80 recipes to revolutionize the web experience with 
 HTML5 Canvas
  
 1. 
  
 The quickest way to get up to speed with HTML5 
  
 Canvas application and game development
  
 2. 
  
 Create stunning 3D visualizations and games 
  
 without Flash
  
 3. 
  
 Written in a modern, unobtrusive, and objected 
  
 oriented JavaScript style so that the code can be 
  
 reused in your own applications. 
  
 4. 
  
 Part of Packt's Cookbook series: Each recipe is 
  
 a carefully organized sequence of instructions to 
  
 complete the task as efficiently as possible",NA
Data Visualization: a ,NA,NA
successful design process ,"ISBN: 978-1-
 849693-46-2            Paperback: 96 pages
  
 A structured design approach to equip you with the 
 knowledge of how to successfully undertake any data 
 visualization challenge efficiently and effectively.
  
 1. 
  
 A portable, versatile and flexible data visualization 
  
 design approach that will help you navigate the 
  
 complex path towards success
  
 2. 
  
 Explains the many different reasons for creating 
  
 visualizations and identifies the key parameters 
  
 which lead to very different design options
  
 3. 
  
 Thorough explanation of the many visual variables 
  
 and visualization taxonomy to provide you with a 
  
 menu of creative options
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
R Graphs Cookbook ,"ISBN: 978-1-849513-06-7             Paperback: 272 pages
  
 Detailed hands-on recipes for creating the most useful 
 types of graphs in R—starting from the simplest versions 
 to more advanced applications
  
 1. 
  
 Learn to draw any type of graph or visual data 
  
 representation in R
  
 2. 
  
 Filled with practical tips and techniques for 
  
 creating any type of graph you need; not just 
  
 theoretical explanations
  
 3. 
  
 All examples are accompanied with the 
  
  
 corresponding graph images, so you know 
 what 
  
 the results look like",NA
MATLAB Graphics and Data ,NA,NA
Visualization Cookbook ,"ISBN: 978-1-849693-16-5            Paperback: 350 pages
  
 Tell data stories with compelling graphics using this 
 collection of data visualization recipes
  
 1. 
  
 Collection of data visualization recipes with 
  
  
 functionalized versions of common tasks for easy 
  
 integration into your data analysis workflow
  
 2. 
  
 Recipes cross-referenced with MATLAB 
 product 
  
 pages and MATLAB Central File 
 Exchange 
  
  
 resources for improved coverage
  
 3. 
  
 Includes hand created indices to find exactly 
  
 what you need; such as application driven, or 
  
 functionality driven solutions
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
