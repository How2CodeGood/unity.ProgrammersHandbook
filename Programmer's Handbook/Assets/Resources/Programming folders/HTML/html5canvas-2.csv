Larger Text,Smaller Text,Symbol
HTML5 Canvas,NA,NA
HTML5 ,NA,NA
Canvas ,NA,NA
Native Interactivity and ,NA,NA
Animation for the Web,NA,NA
Steve Fulton and Jeff Fulton,"Beijing
  •
  Cambridge
  •
  Farnham
  •
  Köln
  •
  Sebastopol
  •
  Tokyo",NA
Table of Contents,"Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . xv
  
 1. Introduction to HTML5 Canvas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . .  1
  
 The Basic HTML Page 
  
  
 <!doctype html> 
  
  
 <html lang=""en""> 
  
  
 <meta charset=""UTF-8""> 
  
  
 <title>…</title> 
  
  
 A Simple HTML5 Page 
  
 Basic HTML We Will Use in This Book 
  
  
 <div> 
  
  
 <canvas> 
  
 The Document Object Model (DOM) and Canvas 
 JavaScript and Canvas 
  
  
 JavaScript Frameworks and Libraries 
  
  
 Where Does JavaScript Go and Why?
  
 HTML5 Canvas “Hello World!”
  
  
 Encapsulating Your JavaScript Code for Canvas 
  
  
 Adding Canvas to the HTML Page 
  
  
 Testing to See Whether the Browser Supports Canvas 
  
 Retrieving the 2D Context 
  
  
 The drawScreen() Function 
  
 Debugging with Console.log 
  
 The 2D Context and the Current State 
  
 The HTML5 Canvas Object 
  
 Another Example: Guess The Letter 
  
  
 How the Game Works 
  
  
 The “Guess The Letter” Game Variables 
  
  
 The initGame() Function 
  
  
 The eventKeyPressed() Function 
  
  
 The drawScreen() Function 
  
  
 Exporting Canvas to an Image
  
 2 
  
 3 
  
 3 
  
 3 
  
 3 
  
 3 
  
 4 
  
 4 
  
 5 
  
 5 
  
 6 
  
 6 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 11 
  
 14 
  
 15 
  
 16 
  
 17 
  
 17 
  
 17 
  
 19 
  
 19 
  
 21 
  
 22",NA
Preface,"HTML5 Canvas offers developers the chance to create animated graphics in 
 ordinary web browsers using common tools: HTML and JavaScript. Canvas is one of 
 the most visible parts of HTML5, fueling demo after demo, game after game. It 
 offers interactivity with great visuals, and provides tremendous freedom to do 
 whatever you want in the browser window. However, it differs enough from typical 
 JavaScript development (as well as Flash and Silverlight development) that it needs 
 careful exploration!",NA
Running the Examples in the Book,"The best part about programming HTML5 Canvas is that the entry barrier is very 
 low—all you need is a modern web browser and a text editor.
  
 As far as compatibility, we suggest you download and/or use the latest version of 
 the web browsers as ordered below.
  
 1. Chrome
  
 2. Safari
  
 3. Opera
  
 4. Firefox
  
 5. Internet Explorer (version 9 or higher)
  
 Every example in this book was tested with Google Chrome, Safari, and Opera. Late 
 in the development of the example code, Firefox started causing issues. While we 
 made every attempt to ensure these examples worked across as many browsers as 
 possible, we recommend you use Google Chrome or Safari for the best results until 
 Canvas support improves.
  
 Please note that if you are using the .pdf version of this book to cut and paste the 
 code, there may be instances where minus (“-”) signs are represented by another 
 character, such as a hyphen. You may need to replace the other character with a 
 minus sign (“-”) to get the code to work properly.
  
 xv",NA
What You Need to Know,"Ideally, you know your way around programming in some kind of modern 
 language, such as C, C++, C#, ActionScript 2, ActionScript 3, Java, or JavaScript. 
 However, if you’re new to this space, we will introduce Canvas in a way that should 
 familiarize you with web programming at the same time.
  
 Web developers with a foundation in HTML and JavaScript should easily be able to 
 pick up this book and run with it.
  
 If you are a Flash developer, JavaScript and ActionScript 1 are essentially the same 
 language. While Adobe took some liberties with ActionScript 2, you should be very 
 comfortable with JavaScript. If you only have experience with ActionScript 3, Java-
 Script might feel like a step backward.
  
 If you are a Silverlight or C# developer, take a deep breath and think about a time 
 before ASP.NET/C# when you might have had to develop web apps in VBScript. 
 You are about to enter a similar space.",NA
How This Book Is Organized,"This book is organized into 11 chapters. The first four chapters walk you through 
 the HTML Canvas API by example. The topics covered include text, images, and 
 drawing. These chapters contain a few finished apps, but mainly consist of demos 
 designed to show you the facets of the Canvas API. The following six chapters build 
 upon the Canvas API by expanding the scope of the examples to application length. 
 In these chapters, we discuss math and physics applications, video, audio, games, 
 and mobile.
  
 The final chapter introduces a couple experimental areas: 3D and multiplayer.
  
 What you won’t get in this book is a simple rundown and retelling of the published 
 W3C Canvas API. While we cover portions of the API in detail, some of it is not ap-
 plicable to games. Furthermore, you can just read the documentation here:
  
 http://dev.w3.org/html5/2dcontext
  
 Our goal is to feature the ways Canvas can be used to create animation, games, and 
 entertainment applications for the Web.
  
 xvi | Preface",NA
Conventions Used in This Book,"The following typographical conventions are used in this book:
  
 Plain text 
  
 Indicates menu titles, menu options, menu buttons, and keyboard accelerators 
 (such as Alt and Ctrl).
  
 Italic 
  
 Indicates new terms, URLs, email addresses, filenames, file extensions, 
 pathnames, directories, and Unix utilities.
  
 Constant width 
  
 Indicates commands, options, switches, variables, attributes, keys, functions, 
 types, classes, namespaces, methods, modules, properties, parameters, values, 
 ob-jects, events, event handlers, XML tags, HTML tags, macros, the contents of 
 files, or the output from commands.
  
 Constant width bold 
  
  
 Shows commands or other text that should be typed literally by the 
 user.
  
 Constant width italic 
  
  
 Shows text that should be replaced with user-supplied 
 values.
  
  
  
 This icon signifies a tip, suggestion, or general note.
  
 This icon indicates a warning or caution.",NA
Using Code Examples,"This book is here to help you get your job done. In general, you may use the code in 
 this book in your programs and documentation. You do not need to contact us for 
 permission unless you’re reproducing a significant portion of the code. For 
 example, writing a program that uses several chunks of code from this book does 
 not require permission. Selling or distributing a CD-ROM of examples from O’Reilly 
 books does require permission. Answering a question by citing this book and 
 quoting example code does not require permission. Incorporating a significant 
 amount of example code from this book into your product’s documentation does 
 require permission.
  
 We appreciate, but do not require, attribution. An attribution usually includes the 
 title, author, publisher, and ISBN. For example: “
 HTML5 Canvas
  by Steve Fulton and 
 Jeff Fulton (O’Reilly). Copyright 2011 8bitrocket Studios, 978-1-4493-9390-8.”",NA
We’d Like to Hear from You,"Please address comments and questions concerning this book to the publisher:
  
 O’Reilly Media, Inc.
  
 1005 Gravenstein Highway North 
  
 Sebastopol, CA 95472 
  
 (800) 998-9938 (in the United States or 
 Canada) (707) 829-0515 (international or 
 local) 
  
 (707) 829-0104 (fax)
  
 We have a web page for this book, where we list errata, examples, and any 
 additional information. You can access this page at:
  
 http://www.oreilly.com/catalog/9781449393908
  
 To comment or ask technical questions about this book, send email to:
  
 bookquestions@oreilly.com
  
 For more information about our books, courses, conferences, and news, see our 
 website at 
 http://www.oreilly.com
 .
  
 Find us on Facebook: 
 http://facebook.com/oreilly
  
 Follow us on Twitter: 
 http://twitter.com/oreillymedia
  
 Watch us on YouTube: 
 http://www.youtube.com/oreillymedia",NA
Safari® Books Online,"Safari Books Online is an on-demand digital library that lets you easily 
 search over 7,500 technology and creative reference books and videos 
 to
  
 find the answers you need quickly.
  
 With a subscription, you can read any page and watch any video from our library 
 online. Read books on your cell phone and mobile devices. Access new titles before 
 they are available for print, and get exclusive access to manuscripts in development 
 and post feedback for the authors. Copy and paste code samples, organize your 
 favorites, down-load chapters, bookmark key sections, create notes, print out 
 pages, and benefit from tons of other time-saving features.
  
 O’Reilly Media has uploaded this book to the Safari Books Online service. To have 
 full digital access to this book and others on similar topics from O’Reilly and other 
 pub-lishers, sign up for free at 
 http://my.safaribooksonline.com
 .
  
 xviii | Preface",NA
Acknowledgments,"First, Steve would like to thank his beautiful wife, Dawn, for the amazing patience, 
 guidance, and support she lovingly provided before, during, and after this book was 
 written. Steve would also like to thank his girls—Rachel, Daphnie, and Katie—for 
 all their enthusiastic support and for not getting too frustrated every time they 
 asked him to play and Daddy said, “Sure, yeah, in just a couple minutes” because his 
 head was buried in these pages. He’d also like to thank his mom and dad, plus his 
 sisters, Mari and Carol for everything they taught us; and his uncle Richard and 
 cousin John for all their love and support. Also thanks to Sue, Morgan, and Lauren 
 Miller; Jen, Eric, Sarah, and Paige Garnica; Dietrich; Chantal Martin; and Ryan and 
 Justin Fulton.
  
 Jeff would like to thank his amazing wife, Jeanne, and his two wonderful boys, Ryan 
 and Justin, for putting up with him writing this second book in two years. The 
 writing process is a time- and energy-consuming endeavor that demands patience 
 and under-standing from those in close proximity to the temperamental author. Jeff 
 would also like to thank his mom and dad, as well as sisters Mari and Carol, for the 
 morale and babysitting support that was needed during the crucial writing times. 
 Also, special thanks to the Perry and Backlar clans for all of their love and support.
  
 The authors would also like to acknowledge all the fine people at O’Reilly, 
 especially Mike Loukides, who took the chance on us for this book; and Simon 
 St.Laurent, who led us out of the wilderness; our copyeditor, Marlowe Shaeffer, 
 who made the text sparkle in her own special way; and our production editor, 
 Kristen Borg, for finishing the job.
  
 We’d also like to thank our technical reviewers, Raffaele Cecco, Shelley Powers, and 
 Andres Pagella.
  
 Thanks to everyone at Electrotank, especially Jobe Makar, Matthew Weisner, and 
 Teresa Carrigan; as well as our friends at Jett Morgan, Creative Bottle, Producto 
 Stu-dios, Mattel, Mochi, Adobe, Microsoft, Zynga, The SPIL Group, Giles Thomas 
 from 
 Learningwebgl.com
 , Ari Feldman, and Terry Paton, plus Ace The Super Villain, 
 Bas Alicante, egdcltd, Tony Fernando, SeuJogo, Hayes, Jose Garay, Richard Davey 
 (@PhotonStorm), Squize and nGfx (@GamingYourWay), and all our other friends at 
 8bitrocket.com
 . We would also like to give a huge shout out to the simply 
 outstanding team at 444 Deharo, especially the entire FV team and the Foo Fighters 
 pod!
  
 Finally, we'd like to thank all of our friends who helped along the way, including Ian 
 Legler, Brandon Crist, Eric Barth, Wesley Crews, Kenny Brown, Mike Foti, Evan 
 Pershing, Scott Johnson, Scott Lunceford, Kurt Legler, Ryan Legler, John Little, Matt 
 Hyatt, Varun Tandon, Mark Hall, Jason Neifeld, Mike Peters and The Alarm.
  
 …and, last but not least, thanks to the W3C for coming up with such a kickass spec 
 for HTML5 Canvas.",NA
CHAPTER 1,NA,NA
Introduction to HTML5 ,NA,NA
Canvas,"HTML5
  is the current iteration of HTML, the 
 HyperText Markup Language
 . HTML 
 was first standardized in 1993, and it was the fuel that ignited the World Wide 
 Web. HTML is a way to define the contents of a web page using tags that appear 
 within pointy brackets, < >.
  
 HTML5 Canvas
  is an 
 immediate mode
  bitmapped area of the screen that can be ma-
 nipulated with JavaScript. Immediate mode refers to the way the canvas renders 
 pixels on the screen. HTML5 Canvas completely redraws the bitmapped screen on 
 every frame using Canvas API calls from JavaScript. As a programmer, your job is to 
 set up the screen display before each frame is rendered so that the correct pixels 
 will be shown.
  
 This makes HTML5 Canvas very different from Flash, Silverlight, or SVG, which op-
 erate in 
 retained mode
 . In this mode, a display list of objects is kept by the graphics 
 renderer, and objects are displayed on the screen according to attributes set in 
 code (i.e., the 
 x
  position, 
 y
  position, and alpha transparency of an object). This keeps 
 the programmer away from low-level operations, but gives her less control over 
 the final rendering of the bitmapped screen.
  
 The basic HTML5 Canvas API includes a 2D context that allows a programmer to 
 draw various shapes, render text, and display images directly onto a defined area of 
 the browser window. You can apply colors; rotations; alpha transparencies; pixel 
 manip-ulations; and various types of lines, curves, boxes, and fills to augment the 
 shapes, text, and images you place onto the canvas.
  
 In itself, the HTML5 Canvas 2D context is a display API used to render graphics on a 
 bitmapped area, but there is very little in that context to create applications using 
 the technology. By adding cross-browser-compatible JavaScript functionality for 
 keyboard and mouse inputs, timer intervals, events, objects, classes, sound, math 
 functions, etc., you can learn to take HTML5 Canvas and create stunning 
 animations, applications, and games.
  
 Here’s where this book comes in. We are going to break down the Canvas API into 
 digestible parts and then put it back together, demonstrating how to use it to create",NA
Browser Support for HTML5 Canvas,"With the exception of Internet Explorer 8, HTML5 Canvas is supported in some 
 way by most modern web browsers, with specific feature support growing on an 
 almost daily basis. The best support seems to be from Google Chrome, followed 
 closely by Safari, Firefox, and Opera. We will utilize a JavaScript library named 
 modernizr.js
  that will help us figure out which browsers support which Canvas 
 features. At the same time, if you are worried about Internet Explorer, version 9 
 promises to have support for Canvas. In the meantime, you can check out Google 
 Chrome Frame (
 http://code .google.com/chrome/chromeframe/
 ), which delivers 
 Canvas support for IE.",NA
The Basic HTML Page,"Before we get to Canvas, we need to talk a bit about the HTML5 standards we will 
 be using to create our web pages.
  
 HTML is the standard language used to construct pages on the World Wide Web. 
 We will not spend much time on HTML, but it does form the basis of 
 <canvas>
 , so we 
 cannot skip it entirely.
  
 A basic HTML page is divided into sections, commonly 
 <head>
  and 
 <body>
 . The new 
 HTML5 specification adds a few new sections, such as 
 <nav>
 , 
 <article>
 , 
 <header>
 , and 
 <footer>
 .
  
 The 
 <head>
  tag usually contains information that will be used by the HTML 
 <body>
  
 tags to create the HTML page. It is a standard convention to put JavaScript 
 functions in the 
 <head>
 , as you will see later when we discuss the 
 <canvas>
  tag. 
 There may be reasons to put some JavaScript in the 
 <body>
 , but we will make every 
 attempt to keep things simple by having all JavaScript in the 
 <head>
 .
  
 Basic HTML for a page might look like 
 Example 1-1
 .
  
 Example 1-1. A basic HTML page
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH1EX1: Basic Hello World HTML Page</title> 
 </head> 
  
 <body> 
  
 Hello World!
  
 </body> 
  
 </html>
  
 2 | Chapter 1:Introduction to HTML5 Canvas",NA
<!doctype html>,"This tag informs the web browser to render the page in standards mode. According 
 to the HTML5 spec from W3C, this is required for HTML5 documents. This tag 
 simplifies a long history of oddities when it came to rendering HTML in different 
 browsers. This should always be the first line of HTML in a document.",NA
"<html lang=""en"">","This is the 
 <html>
  tag with the language referenced: for example, 
 “en”
  = English. 
 Some of the more common language values are:
  
 Chinese – 
 lang = “zh”
  
 French – 
 lang = “fr”
  
 German – 
 lang = “de”
  
 Italian – 
 lang = “it”
  
 Japanese – 
 lang = “ja”
  
 Korean – 
 lang = “ko”
  
 Polish – 
 lang = “pl”
  
 Russian – 
 lang = “ru”
  
 Spanish (Castilian) – 
 lang = “es”",NA
"<meta charset=""UTF-8"">","This tag tells the web browser which character-encoding method to use for the 
 page. Unless you know what you’re doing, there is no need to change it. This is a 
 required element for HTML5 pages.",NA
<title>…</title>,"This is the title that will be displayed in the browser window for the HTML page. 
 This is a very important tag, as it is one of the main pieces of information a search 
 engine uses to catalog the content on the HTML page.",NA
A Simple HTML5 Page,"Now let’s look at this page in a web browser (this would be a great time to get your 
 tools together to start developing code). Open your chosen text editor, and get 
 ready to use your preferred web browser: Safari, Firefox, Opera, Chrome, or IE.
  
 1. In your text editor, type in the code from 
 Example 1-1
 .
  
 2. Save the code as 
 CH1EX1.html
  in a directory of your choosing.
  
 The Basic HTML Page | 3",NA
Basic HTML We Will Use in This Book,"Many HTML tags can be used to create an HTML page. In past versions of HTML, 
 tags that specifically instructed the web browser on how to render the HTML page 
 (e.g., 
 <font>
  and 
 <center>
 ) were very popular. However, as browser standards have 
 become more restrictive in the past decade, those types of tags have been pushed 
 aside, and the use of CSS (Cascading Style Sheets) has been adopted as the primary 
 way to style HTML content. Because this book is not about creating HTML pages 
 (i.e., pages that don’t have Canvas in them), we are not going to discuss the inner 
 workings of CSS.
  
 We will focus on only two of the most basic HTML tags: 
 <div>
  and 
 <canvas>
 .",NA
<div>,"This is the main HTML tag that we will use in this book. We will use it to position 
 <canvas>
  on the HTML page.
  
 Example 1-2
  uses a 
 <div>
  tag to position the words “Hello World!” on the screen, as 
 shown in 
 Figure 1-2
 .
  
  
 Figure 1-2. HTML5 Hello World! with a <div>
  
 4 | Chapter 1:Introduction to HTML5 Canvas",NA
<canvas>,"Our work with 
 <canvas>
  will benefit from using the absolute positioning method 
 with 
 <div>
 . We will place our 
 <canvas>
  inside the 
 <div>
  tag, and it will help us 
 retrieve in-formation, such as the relative position of the mouse pointer when it 
 appears over a canvas.",NA
The Document Object Model (DOM) and ,NA,NA
Canvas,"The Document Object Model represents all the objects on an HTML page. It is 
 language- and platform-neutral, allowing the content and style of the page to be up-
 dated after it is rendered in the web browser. The DOM is accessible through 
 JavaScript, and has been a staple of JavaScript, DHTML, and CSS development since 
 the late 1990s.
  
 The 
 canvas
  element itself is accessible through the DOM in a web browser via the 
 Canvas 2D context, but the individual graphical elements created on Canvas are not 
 accessible to the DOM. As we stated earlier, this is because Canvas works in 
 immediate mode and does not have its own objects, only instructions on what to 
 draw on any single frame.
  
 Our first example will use the DOM to locate the 
 <canvas>
  tag on the HTML5 page so 
 that we can manipulate it with JavaScript. There are two specific DOM objects we 
 will need to understand when we start using 
 <canvas>
 : 
 window
  and 
 document
 .
  
 The 
 window
  object is the top level of the DOM. We will need to test this object to 
 make sure all the assets and code have loaded before we can start our Canvas 
 applications.
  
 The 
 document
  object contains all the HTML tags that are on the HTML page. We will 
 need to look at this object to find the instance of 
 <canvas>
  that manipulates with 
 JavaScript.",NA
JavaScript and Canvas,"JavaScript, the programming language we will use to create Canvas applications, 
 can be run inside nearly any web browser in existence. If you need a refresher on 
 the topic, read Douglas Crockford’s 
 JavaScript: The Good Parts
  (O’Reilly), which is a 
 very popular and well-written reference on the subject.",NA
JavaScript Frameworks and Libraries,"There are many popular JavaScript frameworks that developers use to help get 
 their JavaScript off the ground, including libraries such as jQuery, Processing.js, and 
 others. We expect these frameworks to add robust support for Canvas in the next 
 6–12 months. In the meantime, we will focus on straight JavaScript to control the 
 canvas. However, where appropriate, we will introduce you to frameworks and 
 JavaScript libraries that will help augment Canvas development (e.g., Modernizr, 
 JSColor, and WebGL).",NA
Where Does JavaScript Go and Why?,"Because we will create the programming logic for the Canvas in JavaScript, a 
 question arises: where does that JavaScript go in the pages we have already 
 created?
  
 It’s a good idea to place your JavaScript in the 
 <head>
  of your HTML page because it 
 makes it easy to find. However, placing JavaScript there means that the entire 
 HTML page needs to load before your JavaScript can work with the HTML. This also 
 means that the JavaScript code will start to execute before the entire page loads. As 
 a result, you will need to test to see whether the HTML page has loaded before you 
 run your JavaScript program.
  
 There has been a recent move to put JavaScript right before the 
 </body>
  at the end 
 of an HTML document to make sure the whole page loads before the JavaScript 
 runs. However, because we are going to test to see whether the page has loaded in 
 JavaScript before we run our 
 <canvas>
  program, we will put our JavaScript in the 
 traditional 
 <head>
  location. If you are not comfortable with this, you can adapt the 
 style of the code to your liking.
  
 No matter where you put the code, you can place it inline in the HTML page or load 
 an 
 external .js
  file. The code for loading an external JavaScript file might look like 
 this:
  
 <script type=""text/javascript"" src=""canvasapp.js""></script>
  
 To make things simple, we will code our JavaScript inline in the HTML page. 
 However, if you know what you are doing, saving an external file and loading it will 
 work just as well.",NA
HTML5 Canvas “Hello World!”,"As we just mentioned, one of the first things we need to do when putting Canvas on 
 an HTML5 page is test to see whether the entire page has loaded and all HTML 
 elements are present before we start performing any operations. This will become 
 essential when we start working with images and sounds in Canvas.
  
 To do this, you need to work with 
 events
  in JavaScript. Events are dispatched by 
 objects when a defined event occurs. Other objects listen for events so they can do 
 something based on the event. Some common events that an object in JavaScript 
 might listen for are key presses, mouse movements, and when something has 
 finished loading.
  
 The first event we need to listen for is a 
 window
  object’s 
 load
  event, which occurs 
 when the HTML page has finished loading.
  
 To add a 
 listener
  for an event, use the 
 addEventListener()
  method that belongs to 
 objects that are part of the DOM. Because 
 window
  represents the HTML page, it is 
 the top level of the DOM.
  
 The 
 addEventListener()
  function accepts three arguments:
  
 Event: 
 load 
  
 This is the named event for which we are adding a listener. Events for existing 
 objects like 
 window
  are already defined.
  
 Event handler function: 
 eventWindowLoaded() 
  
 Call this function when the event occurs. In our code, we will then call the 
 canvasApp()
  function, which will start our main application execution.
  
 useCapture
 : 
 true
  or 
 false 
  
 This sets the function to capture this type of event before it propagates lower in 
 the DOM tree of objects. We will always set this to 
 false
 .
  
 Below is the final code we will use to test to see whether the 
 window
  has loaded:
  
 window.addEventListener(""load"", eventWindowLoaded, false); 
 function eventWindowLoaded () {
  
  
  canvasApp(); 
  
 }
  
 Alternatively, you can set up an event listener for the 
 load
  event in a number of 
 other ways:
  
 window.onload = function()
  
  
  {
  
   
  canvasApp();
  
  
  }
  
 HTML5 Canvas “Hello World!” | 7",NA
Encapsulating Your JavaScript Code for Canvas,"Now that we have created a way to test to see whether the HTML page has loaded, 
 we can start creating our JavaScript application. Because JavaScript runs in an 
 HTML page, it could be running with other JavaScript applications and code 
 simultaneously. Usu-ally, this does not cause any problems. However, there is a 
 chance that your code might have variables or functions that conflict with other 
 JavaScript code on the HTML page.
  
 Canvas applications are a bit different from other apps that run in the web browser. 
 Because Canvas executes its display in a defined region of the screen, its 
 functionality is most likely self-contained, so it should not interfere with the rest of 
 the page, and vice versa. You might also want to put multiple Canvas apps on the 
 same page, so there must be some kind of separation of JavaScript when defining 
 the code.
  
 To avoid this issue, you can encapsulate your variables and functions by placing 
 them inside another function. Functions in JavaScript are objects themselves, and 
 objects in JavaScript can have both properties and methods. By placing a function 
 inside another function, you are making the second function local in scope to the 
 first function.
  
 In our example, we are going to have the 
 canvasApp()
  function that is called from the 
 window load
  event contain our entire Canvas application. This “Hello World!” 
 example will have one function named 
 drawScreen()
 . As soon as 
 canvasApp()
  is 
 called, we will call 
 drawScreen()
  immediately to draw our “Hello World!” text.
  
 The 
 drawScreen()
  function is now local to 
 canvasApp()
 . Any variables or functions we 
 create in 
 canvasApp()
  will be local to 
 drawScreen()
 , but not to the rest of the HTML 
 page or other JavaScript applications that might be running.
  
 Here is the sample code for how we will encapsulate functions and code for our 
 Canvas applications:
  
 function canvasApp() {
  
  
  drawScreen();
  
  ...
  
  function drawScreen() {
  
  ...
  
  }
  
 }",NA
Adding Canvas to the HTML Page,"In the 
 <body>
  section of the HTML page, add a 
 <canvas>
  tag using code such as the 
 following:
  
 <canvas id=""canvasOne"" width=""500"" height=""300""> 
 Your browser does not support HTML5 Canvas.
  
 </canvas>
  
 Now, let’s break this down to understand what we are doing. The 
 <canvas>
  tag has 
 three main 
 attributes
 . In HTML, attributes are set within pointy brackets of an 
 HTML tag. The three attributes we need to set are:
  
 id 
  
 The 
 id
  is the name we will use to reference this 
 <canvas>
  tag in our JavaScript 
 code. 
 canvasOne
  is the name we will use.
  
 width 
  
  
 The width, in pixels, of the canvas. The 
 width
  will be 
 500
  pixels.
  
 height 
  
  
 The height, in pixels, of the canvas. The 
 height
  will be 
 300
  pixels.
  
  
 HTML5 elements, including 
 canvas
 , have many more attributes: 
 tabindex
 , 
 title
 , 
 class
 , 
 accesskey
 , 
 dir
 , 
 draggable
 , 
 hidden
 , etc.
  
 Between the opening 
 <canvas>
  and closing 
 </canvas>
  tags, you can put text that will 
 be displayed if the browser executing the HTML page does not support Canvas. For 
 our Canvas applications, we will use the text “Your browser does not support 
 HTML5 Canvas.” However, you can adjust this text to say anything.
  
 Using document to reference the canvas element in JavaScript
  
 We will now make use of the DOM to reference the 
 <canvas>
  we defined in HTML. 
 Recall that the 
 document
  object represents every element of an HTML page after it 
 has loaded.
  
 We need a reference to the 
 Canvas
  object so that we will know where to display the 
 Canvas API calls we will make from JavaScript.
  
 First, we will define a new variable named 
 theCanvas
  that will hold the reference to 
 the 
 Canvas
  object.
  
 Next, we retrieve a reference to 
 canvasOne
  by calling the 
 getElementById()
  function 
 of 
 document
 , and passing the name 
 canvasOne
 , which we defined as the id of the 
 <canvas>
  tag we created in the HTML page:
  
 var theCanvas = document.getElementById(""canvasOne"");
  
 HTML5 Canvas “Hello World!” | 9",NA
Testing to See Whether the Browser Supports ,NA,NA
Canvas,"Now that we have a reference to the 
 canvas
  element on the HTML page, we need to 
 test to see whether it contains a 
 context
 . The Canvas context refers to the drawing 
 surface defined by a web browser to support Canvas. Simply put, if the context does 
 not exist, neither does the canvas. There are several ways to test this. This first test 
 looks to see whether the 
 getContext
  method exists before we call it using Canvas, as 
 we have already defined it in the HTML page:
  
 if (!theCanvas || !theCanvas.getContext) {
  
  
  return; 
  
 }
  
 Actually, this tests two things. First, it tests to see whether 
 theCanvas
  does not 
 contain 
 false
  (the value returned by 
 document.getElementById()
  if the named 
 id
  does 
 not exist). Then, it tests whether the 
 getContext()
  function exists.
  
 The 
 return
  statement breaks out and stops execution if the test fails.
  
 Another method—popularized by Mark Pilgrim on his HTML5 website, 
 http://divein tohtml5.org
 —uses a function with a test of a dummy canvas created 
 for the sole purpose of seeing whether browser support exists:
  
 function canvasSupport () {
  
    
  return !!document.createElement('testcanvas').getContext; } 
  
 function canvasApp() {
  
   
  if (!canvasSupport) {
  
     
  return;
  
  }
  
 }
  
 Our favorite method is to use the 
 modernizr.js
  library, which you can find here: 
 http:// www.modernizr.com/
 . Modernizr—an easy-to-use, lightweight library for 
 testing sup-port for various web-based technologies—creates a set of static 
 Booleans that you can test against to see whether Canvas is supported.
  
 To include 
 modernizr.js
  in your HTML page, download the code from 
 http://www.mod ernizr.com/
  and then include the 
 external .js
  file in your HTML 
 page:
  
 <script src=""modernizr-1.6.min.js""></script>
  
 To test for Canvas, change the 
 canvasSupport()
  function to look like this:
  
 function canvasSupport () {
  
  return Modernizr.canvas; 
  
 }
  
 We are going to use the 
 modernizr.js
  method because we think it offers the best ap-
 proach for testing whether Canvas is supported in web browsers.
  
 10 | Chapter 1:Introduction to HTML5 Canvas",NA
Retrieving the 2D Context,"Finally, we need to get a reference to the 2D context so we can manipulate it. 
 HTML5 Canvas is designed to work with multiple contexts, including a proposed 3D 
 context.
  
 However, for the purposes of this book, we only need to get the 2D context:
  
 var context = theCanvas.getContext(""2d"");",NA
The drawScreen() Function,"It’s time to create actual Canvas API code. Every operation we perform on Canvas 
 will be through the 
 context
  object, as it references the object on the HTML page.
  
 We will delve into writing text, graphics, and images to HTML5 Canvas in later 
 chap-ters, so for now, we will only spend a very short time on the code of the 
 drawScreen() 
 function.
  
 The “screen” here is really the defined drawing area of the canvas, not the whole 
 browser window. We refer to it as such because within the context of the games 
 and applications you will write, it is effectively the “window” or “screen” into the 
 canvas display that you will be manipulating.
  
 The first thing we want to do is clear the drawing area. The following two lines of 
 code draw a yellow box on the screen that is the same size as the canvas. 
 fillStyle()
  
 sets the color, and 
 fillRect()
  creates a rectangle and puts it on the screen:
  
 context.fillStyle = ""#ffffaa""; 
  
 context.fillRect(0, 0, 500, 300);
  
  
 Notice that we are calling functions of the 
 context
 . There are no 
 screen objects, color objects, or anything else. This is an example of 
 the im-mediate mode we described earlier.
  
 Again, we will discuss the text functions of Canvas in the next chapter, but here is a 
 short preview of the code we will use to put the text “Hello World!” on the screen.
  
 First, we set the color of the text in the same way we set the color of the rectangle:
  
 context.fillStyle  = ""#000000"";
  
 Then we set the font size and weight:
  
 context.font = ""20px _sans"";
  
 Next, we set the vertical alignment of the font:
  
 context.textBaseline = ""top"";
  
 HTML5 Canvas “Hello World!” | 11",NA
Debugging with Console.log,"There is one more thing to discuss before we explore bigger and better things 
 beyond“Hello World!” In this book, we have implemented a very simple debugging 
 method-ology using the 
 console.log
  functionality of modern web browsers. This 
 function lets you log text messages to the JavaScript console to help find problems 
 (or opportunities!) with your code. Any browser that has a JavaScript console 
 (Chrome, Opera, Safari, Firefox with Firebug installed) can make use of 
 console.log
 . 
 However, browsers with-out 
 console.log
  support throw a nasty error.
  
 To handle this error, we use a wrapper around 
 console.log
  that only makes the call if 
 the function is supported. The wrapper creates a class named 
 Debugger
 , and then 
 creates a static function named 
 Debugger.log
  that can be called from anywhere in 
 your code, like this:
  
 Debugger.log(""Drawing Canvas"");
  
 14 | Chapter 1:Introduction to HTML5 Canvas",NA
The 2D Context and the Current State,"The HTML5 2D context (the 
 CanvasRenderingContext2D
  object), retrieved by a call to 
 the 
 getContext()
  method of the 
 Canvas
  object, is where all the action takes place. The 
 CanvasRenderingContext2D
  contains all the methods and properties we need to draw 
 onto the canvas. The 
 CanvasRenderingContext2D
  (or context, as we will call it 
 hereafter) uses a Cartesian coordinate system with 0,0 at the upper left and corner 
 of the canvas, and coordinates increasing in value to the left and down.
  
 However, all of these properties and methods are used in conjunction with 
 current 
 state
 , a concept that must be grasped before you can really understand how to 
 work with HTML5 Canvas. The current state is actually a stack of drawing states 
 that apply globally to the entire canvas. You will manipulate these states when 
 drawing on the canvas. These states include:
  
 Transformation matrix 
  
  
 Methods for scale, rotate, transform, and 
 translate
  
 Clipping region 
  
  
 Created with the 
 clip()
  method
  
 Properties of the context 
  
 Properties include 
 strokeStyle
 , 
 fillStyle
 , 
 globalAlpha
 , 
 lineWidth
 , 
 lineCap
 , 
 line Join
 , 
 miterLimit
 , 
 shadowOffsetX
 , 
 shadowOffsetY
 , 
 shadowBlur
 , 
 shadowColor
 , 
 global 
 CompositeOperation
 , 
 font
 , 
 textAlign
 , and 
 textBaseline
 .
  
 Don’t worry; these should not look familiar to you just yet. We will discuss these 
 prop-erties in depth in the next three chapters.
  
 Remember earlier in this chapter when we discussed immediate mode versus 
 retained mode? The canvas is an immediate mode drawing surface, which means 
 everything needs to be redrawn every time something changes. There are some 
 advantages to this; for example, global properties make it very easy to apply effects 
 to the entire screen. Once you get your head around it, the act of redrawing the 
 screen every time there is an update makes the process of drawing to the canvas 
 straightforward and simple.
  
 On the other hand, retained mode is when a set of objects is stored by a drawing 
 surface and manipulated with a display list. Flash and Silverlight work in this mode. 
 Retained mode can be very useful for creating applications that rely on multiple 
 objects with",NA
The HTML5 Canvas Object,"Recall that the 
 Canvas
  object is created by placing the 
 <canvas>
  tag in the 
 <body>
  
 portion of an HTML page. You can also create an instance of a canvas in code like 
 this:
  
 var theCanvas = document.createElement(""canvas"");
  
 The 
 Canvas
  object has two associated properties and methods that can be accessed 
 through JavaScript: 
 width
  and 
 height
 . These tell you the current width and height of 
 the canvas rendered on the HTML page. It is important to note that they are 
 not
  
 read-only; i.e., they can be updated in code and changed on an HTML page. What 
 does this mean? It means you can dynamically resize the canvas on the HTML page 
 without reloading.
  
  
 You can also use CSS styles to change the scale of the canvas. Unlike 
 resizing, scaling takes the current canvas bitmapped area and 
 resamples it to fit into the size specified by the 
 width
  and 
 height
  
 attributes of the CSS style. For example, to scale the canvas to a 
 400×400 area, you might
  
 use this CSS style:
  
 style=""width: 400px; height:400px""
  
 We include an example of scaling the Canvas with a transformation 
 matrix in 
 Chapter 3
 .
  
 There are also two public methods for the 
 Canvas
  object. The first is 
 getContext()
 , 
 which we used earlier in this chapter. We will continue to use it throughout this 
 book to retrieve a reference to the Canvas 2D context so we can draw onto the 
 canvas. The second property is 
 toDataURL()
 . This method will return a string of data 
 that represents the bitmapped image of the 
 Canvas
  object as it is currently 
 rendered. It’s like a snapshot of the screen. By supplying different MIME types as a 
 parameter, you can retrieve the data in different formats. The basic format is an 
 image/png
 , but 
 image/jpeg
  and other formats can be retrieved. We will use the 
 toDataURL()
  in the next application to export an image of the canvas into another 
 browser window.",NA
Another Example: Guess The Letter,"Now we will take a quick look at a more involved example of a “Hello World!”-type 
 application, the game “Guess The Letter.” We’ve included this example to illustrate 
 how much more Canvas programming is done in JavaScript than in the Canvas API.
  
 In this game, shown in 
 Figure 1-4
 , the player’s job is to guess the letter of the 
 alphabet the computer has chosen randomly. The game keeps track of how many 
 guesses the player has made, lists the letters he has already guessed, and tells the 
 player whether he needs to guess higher (toward Z) or lower (toward A).
  
  
 Figure 1-4. HTML5 Canvas “Guess The Letter” game",NA
How the Game Works,"This game is set up with the same basic structure as “Hello World!” 
 canvasApp()
  is 
 the main function, and all other functions are defined as local to 
 canvasApp()
 . We 
 use a 
 drawScreen()
  function to render text on the canvas. However, there are some 
 other functions included as well, which are described next.",NA
The “Guess The Letter” Game Variables,"Here is a rundown of the variables we will use in the game. They are all defined and 
 initialized in 
 canvasApp()
 , so they have scope to the encapsulated functions that we 
 define locally.
  
 Another Example: Guess The Letter | 17",NA
The initGame() Function,"The 
 initGame()
  function sets up the game for the player. The two most important 
 blocks of code are as follows. This code finds a random letter from the letters array 
 and stores it in the 
 letterToGuess
  variable:
  
 var letterIndex = Math.floor(Math.random() * letters.length); 
 letterToGuess = letters[letterIndex];
  
 This code adds an event listener to the 
 window
  object of the DOM to listen for the 
 keyboard 
 keyup
  event. When a key is pressed, the 
 eventKeyPressed
  event handler is 
 called to test the letter pressed:
  
 window.addEventListener(""keyup"",eventKeyPressed,true);
  
 Here is the full code for the function:
  
 function initGame() {
  
  
  var letterIndex = Math.floor(Math.random() * letters.length);
  
  
 letterToGuess = letters[letterIndex];
  
  
  guesses = 0;
  
  
  lettersGuessed = [];
  
  
  gameOver = false;
  
  
  window.addEventListener(""keyup"",eventKeyPressed,true);
  
  
  drawScreen(); 
  
 }",NA
The eventKeyPressed() Function,"This function, called when the player presses a key, contains most of the action in 
 this game. Every event handler function in JavaScript is passed an 
 event
  object that 
 has information about the event that has taken place. We use the 
 e
  argument to 
 hold that object.
  
 The first test we make is to see whether the 
 gameOver
  variable is 
 false
 . If so, we 
 continue to test the key that was pressed by the player; the next two lines of code 
 are used for that purpose. The first line of code gets the key-press value from the 
 event, and converts it to an alphabetic letter that we can test with the letter stored 
 in 
 letterToGuess
 :
  
 var letterPressed = String.fromCharCode(e.keyCode);
  
 The next line of code converts the letter to lowercase so that we can test uppercase 
 letters if the player unintentionally has Caps Lock on:
  
 letterPressed = letterPressed.toLowerCase();
  
 Next, we increase the 
 guesses
  count to display, and use the 
 Array.push()
  method to 
 add the letter to the 
 lettersGuessed
  array:
  
 guesses++; 
  
 lettersGuessed.push(letterPressed);
  
 Another Example: Guess The Letter | 19",NA
The drawScreen() Function,"Now we get to 
 drawScreen()
 . The good news is that we have seen almost all of this 
 before—there are only a few differences from “Hello World!” For example, we paint 
 multiple variables on the screen using the Canvas Text API. We only set 
 context.text 
 Baseline = 'top';
  once for all the text we are going to display. Also, we change the 
 color using 
 context.fillStyle
 , and the font with 
 context.font
 .
  
 The most interesting thing we display here is the content of the 
 lettersGuessed
  array. 
 On the canvas, the array is printed as a set of comma-separated values, like this:
  
 Letters Guessed: p,h,a,d
  
 To print this value, all we do is use the 
 toString()
  method of the 
 lettersGuessed
  array, 
 which prints out the values of an array as—you guessed it—comma-separated 
 values:
  
 context.fillText  (""Letters Guessed: "" + lettersGuessed.toString(), 10, 260);
  
 We also test the 
 gameOver
  variable. If it is 
 true
 , we put 
 You Got It!
  on the screen in 
 giant 
 40px
  text so the user knows he has won.
  
 Here is the full code for the function:
  
 function drawScreen() {
  
  //Background
  
  context.fillStyle = ""#ffffaa"";
  
  context.fillRect(0, 0, 500, 300);
  
  //Box
  
  context.strokeStyle = ""#000000"";
  
  context.strokeRect(5,  5, 490, 290);
  
  context.textBaseline = ""top"";
  
  //Date
  
  context.fillStyle = ""#000000"";
  
  context.font = ""10px _sans"";
  
  context.fillText  (today, 150 ,10);
  
  //Message
  
  context.fillStyle = ""#FF0000"";
  
  context.font = ""14px _sans"";
  
  context.fillText  (message, 125, 30);
  
 Another Example: Guess The Letter | 21",NA
Exporting Canvas to an Image,"Earlier, we briefly discussed the 
 toDataUrL()
  property of the 
 Canvas
  object. We are 
 going to use that property to let the user create an image of the game screen at any 
 time. This acts almost like a screen-capture utility for games made on Canvas.
  
 We need to create a button in the HTML page that the user can press to get the 
 screen capture. We will add this button to 
 <form>
  and give it the id 
 createImageData
 :
  
 <form> 
  
 <input type=""button"" id=""createImageData"" value=""Export Canvas Image""> 
 </form>
  
 In the 
 init()
  function, we retrieve a reference to that form element by using the 
 getElementById()
  method of the 
 document
  object. We then set an event handler for 
 the button “click” event as the function 
 createImageDataPressed()
 :
  
 var formElement = document.getElementById(""createImageData""); 
  
 formElement.addEventListener('click', createImageDataPressed, false);
  
 In 
 canvasApp()
 , we define the 
 createImageDataPressed()
  function as an event handler. 
 This function calls 
 window.open()
 , passing the return value of the 
 Canvas.toDataUrl() 
 method as the source for the window. Since this data forms a valid 
 PNG
 , the image 
 is displayed in the new window:
  
 function createImageDataPressed(e) {
  
  window.open(theCanvas.toDataURL(),""canvasImage"",""left=0,top=0,width="" +  
 theCanvas.width + "",height="" + theCanvas.height +"",toolbar=0,resizable=0""); }
  
 22 | Chapter 1:Introduction to HTML5 Canvas",NA
The Final Game Code,"Example 1-4
  shows the full code for the Guess The Letter game.
  
 Example 1-4. Guess The Letter game
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH1EX4: Guesss The Letter Game</title> 
  
 <script src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript"">
  
 window.addEventListener('load', eventWindowLoaded, false);
  
 var Debugger = function () { }; 
  
 Debugger.log = function (message) {
  
  
  try {
  
   
  console.log(message);
  
  
  } catch (exception) {
  
   
  return;
  
  
  } 
  
 }
  
 function eventWindowLoaded() {
  
 }
  
  canvasApp();
  
 function canvasSupport () {
  
  
  return Modernizr.canvas; 
  
 }
  
 function eventWindowLoaded() {
  
 }
  
  canvasApp();
  
 function canvasApp() {
  
  
  var guesses = 0;
  
  
  var message = ""Guess The Letter From a (lower) to z (higher)"";
  
  
  var letters = [
  
   
  ""a"",""b"",""c"",""d"",""e"",""f"",""g"",""h"",""i"",""j"",""k"",""l"",""m"",""n"",""o"",
  
  
  
 ""p"",""q"",""r"",""s"",""t"",""u"",""v"",""w"",""x"",""y"",""z""
  
   
  ];
  
  
  var today = new Date();
  
  
  var letterToGuess = """";
  
  
  var higherOrLower = """";
  
 Another Example: Guess The Letter | 23",NA
What’s Next,"So now you should have a basic understanding of the HTML and JavaScript we will 
 use to render and control HTML5 Canvas on an HTML page. In the next chapter, we 
 will take this information and expand on it to create an interactive application that 
 uses the canvas to render information on the screen.
  
 26 | Chapter 1:Introduction to HTML5 Canvas",NA
CHAPTER 2,NA,NA
Drawing on the Canvas,"Using HTML5 Canvas effectively requires a strong foundation in drawing, coloring, 
 and transforming basic two-dimensional shapes. While the selection of built-in 
 shapes is relatively limited, we can draw any shape we desire using a series of line 
 segments called 
 paths
 , which we will discuss in the upcoming section 
 “Using Paths 
 to Create Lines” on page 30
 .
  
  
 The HTML5 Canvas API is well covered in many online forms. The 
 W3C site has an exhaustive and constantly updated reference that 
 de-tails the features of the Canvas 2D Drawing API. It can be viewed 
 at 
 http://dev.w3.org/html5/canvas-api/canvas-2d-api.html
 .
  
 However, this online reference lacks concrete examples on using the 
 API. Rather than simply reprinting this entire specification, we will 
 spend our time creating examples to explain and explore as many 
 fea-tures as we have space to cover.",NA
The Basic File Setup for This Chapter,"As we proceed through the Drawing API, all the examples in this chapter will use 
 the same basic file setup, shown below. Use this code as the basis for all of the 
 examples we create. You will only have to change the contents of the 
 drawScreen()
  
 function:
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>Ch2BaseFile - Template For Chapter 2 Examples</title> <script 
 src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript""> 
  
 window.addEventListener('load', eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
  canvasApp();
  
 27",NA
The Basic Rectangle Shape,"Let’s get our feet wet by looking at the single primitive, built-in geometric shape on 
 Canvas—the rectangle. On Canvas, basic rectangle shapes can be drawn in three 
 dif-ferent ways: filling, stroking, or clearing. We can also build rectangles (or any 
 other shape) by using paths, which we will cover in the next section.
  
 First, let’s look at the API functions used for these three operations:
  
 fillRect(x,y,width,height) 
  
  
 Draws a filled rectangle at position 
 x
 ,
 y
  for width and height.
  
 28 | Chapter 2:Drawing on the Canvas",NA
The Canvas State,"When we draw on the Canvas context, we can make use of a stack of so-called 
 drawing 
 states
 . Each of these states stores data about the Canvas context at any one 
 time. Here is a list of the data stored in the stack for each state:
  
 • Transformation matrix information such as rotations or translations using the 
  
 context.rotate()
  and 
 context.setTransform()
  methods
  
 • The current clipping region
  
 The Canvas State | 29",NA
What’s Not Part of the State?,"The current path (which we will explore later in this chapter) and current bitmap 
 (see 
 Chapter 4
 ) being manipulated on the Canvas context are 
 not
  part of the saved 
 state. This very important feature will allow us to draw and animate individual 
 objects on the canvas. The section 
 “Simple Canvas Transformations” on page 41
  
 utilizes the Canvas state to apply transformations to only the current shape being 
 constructed and drawn, leaving the rest of the canvas not transformed.",NA
How Do We Save and Restore the ,NA,NA
Canvas State? ,"To save (push) the current state 
 to the stack, call:
  
 context.save()
  
 To restore the canvas by “popping” the last state saved to the stack, use:
  
 context.restore()",NA
Using Paths to Create Lines,"Paths are a method we can use to draw any shape on the canvas. A path is simply a 
 list of points, and lines to be drawn between those points. A Canvas context can 
 only have a single “current” path, which is not stored as part of the current drawing 
 state when the 
 context.save()
  method is called.
  
 Context for paths is a critical concept to understand, because it will enable you to 
 transform only the current path on the canvas.
  
 30 | Chapter 2:Drawing on the Canvas",NA
Starting and Ending a Path,"The 
 beginPath()
  function call starts a path, and the 
 closePath()
  function call ends the 
 path. When you connect two points inside a path, it is referred to as a 
 subpath
 . A 
 subpath is considered “closed” if the final point connects to the first point.
  
  
 The current transformation matrix will affect everything drawn in 
 this path. As we will see when we explore the upcoming section on 
 trans-formations, we will always want to set the transformation 
 matrix to the identity (or reset) if we do not want any 
 transformation applied to a path.",NA
The Actual Drawing,"The most basic path is controlled by a series of 
 moveTo()
  and 
 lineTo()
  commands, as 
 shown in 
 Example 2-2
 .
  
 Example 2-2. A simple line path
  
 function drawScreen() {
  
  context.strokeStyle  = ""black""; //need list of available colors 
 context.lineWidth  = 10;
  
  context.lineCap  = 'square';
  
  context.beginPath();
  
  context.moveTo(20, 0);
  
  context.lineTo(100, 0);
  
  context.stroke();
  
  context.closePath();
  
 }
  
 Figure 2-2
  shows an example of this output.
  
  
 Figure 2-2. A simple line path
  
 Example 2-2
  simply draws a 10-pixel-wide horizontal line (or stroke) from position 
 20,0 to position 100,0.
  
 We have also added the 
 lineCap
  and 
 strokeStyle
  attributes. Let’s take a brief look at 
 the various attributes we can apply to a line before we move on to some more 
 advanced drawing.
  
 Using Paths to Create Lines | 31",NA
Examples of More Advanced Line Drawing,"Example 2-3
  shows these attributes in action; the results are depicted in 
 Figure 2-3
 . 
 There are a few oddities when drawing lines on the canvas, which we will point out 
 along the way.
  
 32 | Chapter 2:Drawing on the Canvas",NA
Advanced Path Methods,"Let’s take a deeper look at some of the other methods we can use to draw paths on 
 the canvas, including arcs and curves that can be combined to create complex 
 images.",NA
Arcs,"There are four functions we can use to draw arcs and curves onto the canvas. An arc 
 can be a complete circle or any part of a circle
  
 context.
 arc
 ()
  
 context.arc(x, y, radius, startAngle, endAngle, anticlockwise)
  
 The 
 x
  and 
 y
  values define the center of our circle, and the 
 radius
  will be the radius of 
 the circle upon which our arc will be drawn. 
 startAngle
  and 
 endAngle
  are in radians, 
 not degrees. 
 anticlockwise
  is a 
 true
  or 
 false
  value that defines the direction of the arc.
  
 For example, if we want to draw a circle with a center point at position 100,100 and 
 with a radius of 20, as shown in 
 Figure 2-4
 , we could use the code below for the 
 contents of 
 drawScreen()
 :
  
 context.arc(100, 100, 20, (Math.PI/180)*0, (Math.PI/180)*360, false);
  
 Example 2-4
  illustrates the code necessary to create a simple circle.
  
 Example 2-4. A circle arc
  
 function drawScreen() {
  
  context.beginPath();
  
  context.strokeStyle = ""black"";
  
  context.lineWidth = 5;
  
  context.arc(100, 100, 20, (Math.PI/180)*0, (Math.PI/180)*360, false);
  
  //full circle
  
  context.stroke();
  
  context.closePath();
  
 }
  
 34 | Chapter 2:Drawing on the Canvas",NA
Bezier Curves ,"Bezier curves, which are far more flexible than arcs, come in both the cubic and 
 quad-ratic types:
  
 •
  context.
 bezierCurveTo
 (
 cp1x, cp1y, cp2x, cp2y, x, y
 )
 •
  
 context.
 quadraticCurveTo
 (
 cpx, cpy, x, y
 )
  
 The Bezier curve is defined in 2D space by a “start point,” an “end point,” and one or 
 two “control” points, which determine how the curve will be constructed on the 
 canvas. A normal cubic Bezier curve uses two points, while a quadric version uses a 
 single point.
  
 The quadratic version, shown in 
 Figure 2-8
 , is the simplest, only needing the end 
 point (last) and a single point in space to use as a control point (first): 
  
  
 context.moveTo(0,0); 
  
  
 context.quadraticCurveTo(100,25,0,50);
  
  
 Figure 2-8. A simple quadratic Bezier curve
  
 This curve starts at 
 0,0
  and ends at 
 0,50
 . The point in space we use to create our arc 
 is 
 100,25
 . This point is roughly the center of the arc vertically. The 
 100
  value for the 
 single control point pulls the arc out to make an elongated curve.
  
 36 | Chapter 2:Drawing on the Canvas",NA
The Canvas Clipping Region,"Combining the 
 save()
  and 
 restore()
  functions with the Canvas clip region limits the 
 drawing area for a path and its subpaths. We do this by first setting 
 rect()
  to a 
 rectangle that encompasses the region we would like to draw in, and then calling 
 the 
 clip() 
 function. This will set the clip region to be the rectangle we defined with 
 the 
 rect() 
 method call. Now, no matter what we draw onto the current context, it 
 will only display the portion that is in this region. Think of this as a sort of mask 
 that you can use for your drawing operations. 
 Example 2-5
  shows how this works, 
 producing the clipped result shown in 
 Figure 2-10
 .
  
 Example 2-5. The Canvas clipping region
  
 function drawScreen() {
  
  //draw a big box on the screen
  
  context.fillStyle = ""black"";
  
  context.fillRect(10, 10, 200, 200);
  
  context.save();
  
  context.beginPath();
  
 Advanced Path Methods | 37",NA
Compositing on the Canvas,"Compositing refers to how finely we can control the transparency and layering 
 effects of objects as we draw them to the canvas. There are two attributes we can 
 use 
 to 
 control 
 Canvas 
 compositing 
 operations: 
 globalAlpha
  
 and 
 globalCompositeOperation
 .
  
 globalAlpha 
  
 The 
 globalAlpha
  Canvas property defaults to 
 1.0
  (completely opaque) and can be 
 set from 
 0.0
  (completely transparent) through 
 1.0
 . This Canvas property must 
 be set before a shape is drawn to the canvas.
  
 globalCompositeOperation 
  
 The 
 globalCompositeOperation
  value controls how shapes are drawn into the cur-
 rent Canvas bitmap after both 
 globalAlpha
  and any transformations have been 
 applied (see the next section, 
 “Simple Canvas Transformations” on page 41
 , for 
 more information).
  
 In the following list, the “source” is the shape we are about to draw to the 
 canvas, and the “destination” refers to the current bitmap displayed on the 
 canvas.
  
 copy 
  
  
 Where they overlap, displays the source and not the 
 destination.
  
 destination-atop 
  
 Destination atop the source. Where the source and destination overlap and 
 both are opaque, displays the destination image. Displays the source image 
 wherever the source image is opaque but the destination image is 
 transparent. Displays transparency elsewhere.
  
 destination-in 
  
 Destination in the source. Displays the destination image wherever both 
 the destination image and source image are opaque. Displays transparency 
 else-where.
  
 destination-out 
  
 Destination out source. Displays the destination image wherever the 
 destina-tion image is opaque and the source image is transparent. Displays 
 transpar-ency elsewhere.",NA
Simple Canvas Transformations,"Transformations on the canvas refer to the mathematical adjustment of physical 
 prop-erties of drawn shapes. The two most commonly used shape transformations 
 are scale and rotate, which we will focus on in this section.
  
 Simple Canvas Transformations | 41",NA
Rotation and Translation Transformations,"An object on the canvas is said to be at the 0 angle rotation when it is facing to the 
 left (this is important if an object has a facing; otherwise, we will use this as a 
 guide). Consequently, if we draw an equilateral box (all four sides are the same 
 length), it doesn’t have an initial facing other than one of the flat sides facing to the 
 left. Let’s draw that box for reference:
  
 //now draw a red square 
  
 context.fillStyle = ""red""; 
  
 context.fillRect(100,100,50,50);
  
 Now, if we want to rotate the entire canvas 45 degrees, we need to do a couple 
 simple steps. First, we always set the current Canvas transformation to the 
 “identity” (or “re-set”) matrix:
  
 context.setTransform(1,0,0,1,0,0);
  
 Because Canvas uses radians, not degrees, to specify its transformations, we need to 
 convert our 45-degree angle into radians:
  
 var angleInRadians = 45 * Math.PI / 180; 
  
 context.rotate(angleInRadians);
  
 Lesson 1: Transformations are applied to shapes and paths drawn after 
 the setTransform() or other transformation function is called
  
 If you use this code verbatim, you will see a funny result…
 nothing
 ! This is because 
 the 
 setTransform()
  function call only affects shapes drawn to the canvas 
 after
  it is 
 applied. We drew our square first, then set the transformation properties. This 
 resulted in no change (or transform) to the drawn square. 
 Example 2-7
  gives the 
 code in the correct order to produce the expected result, as illustrated in 
 Figure 2-
 12
 .
  
 Example 2-7. Simple rotation transformation
  
 function drawScreen() {
  
  //now draw a red square
  
  context.setTransform(1,0,0,1,0,0);
  
  var angleInRadians = 45 * Math.PI / 180;
  
  context.rotate(angleInRadians);
  
  context.fillStyle = ""red"";
  
  context.fillRect(100,100,50,50);
  
  }
  
 42 | Chapter 2:Drawing on the Canvas",NA
Scale Transformations,"The 
 context.scale()
  function takes in two parameters: the first is the scale attribute 
 for the x-axis, and the second is the scale attribute for the y-axis. The value 
 1
  is the 
 normal scale for an object. Therefore, if we want to double an object’s size, we can 
 set both values to 
 2
 . Using the code below in 
 drawScreen()
  produces the red square 
 shown in 
 Figure 2-18
 :
  
 Simple Canvas Transformations | 47",NA
Combining Scale and Rotation Transformations,"If we want to both scale and rotate an object, Canvas transformations can easily be 
 combined to achieve the desired results (as shown in 
 Figure 2-20
 ). Let’s look in 
 Ex-
 ample 2-12
  at how we might combine them by using 
 scale(2,2)
  and 
 rotate(angleIn 
 Radians)
  from our previous examples.
  
 Example 2-12. Scale and rotation combined
  
 function drawScreen() {
  
  context.setTransform(1,0,0,1,0,0);
  
  var angleInRadians = 45 * Math.PI / 180;
  
  var x = 100;
  
  var y = 100;
  
  var width = 50;
  
  var height = 50;
  
  context.translate(x+.5*width, y+.5*height);
  
  context.scale(2,2);
  
  context.rotate(angleInRadians);
  
  context.fillStyle = ""red"";
  
  context.fillRect(-.5*width,-.5*height , width, height);
  
  }
  
  
 Figure 2-20. Scale and rotation combined
  
 Example 2-13
  also combines rotation and scale, this time using a rectangle. 
 Fig-ure 
 2-21
  reveals what it creates.
  
 Example 2-13. Scale and rotate a nonsquare object
  
 function drawScreen() {
  
  //now draw a red rectangle
  
  context.setTransform(1,0,0,1,0,0);
  
  var angleInRadians = 90 * Math.PI / 180;
  
  var x = 100;
  
  var y = 100;
  
  var width = 100;
  
  var height = 50;
  
  context.translate(x+.5*width, y+.5*height);
  
  context.rotate(angleInRadians);
  
  context.scale(2,2);
  
 Simple Canvas Transformations | 49",NA
Finding the Center of Any Shape,"The rotation and scale of a rectangle or any other shape we draw on the canvas 
 acts much like that of a square. In fact, as long as we are sure to translate to the 
 center of our shape before we scale, rotate, or scale and rotate, we will see the 
 results we expect from our simple transformations. Keep in mind that the “center” 
 of any shape will be the 
 x
  value that is half its width, and the 
 y
  value that is half its 
 height. We need to use the 
 bounding box theory
  when we attempt to find this 
 center point.
  
 Figure 2-22
  demonstrates this theory. Even though the shape is not a simple 
 square, we have been able to find a bounding box that encompasses each point of 
 the object. 
 Figure 2-22
  is roughly square, but the same theory holds for rectangle-
 shaped bounding boxes.
  
  
  
 Figure 2-22. The bounding box of a complex shape
  
 50 | Chapter 2:Drawing on the Canvas",NA
Filling Objects with Colors and Gradients,"In this chapter, we have quickly looked at color and fill styles as we proceeded 
 through the discussions of basic and complex shape construction. In this section, 
 we will take a deeper look at coloring and filling shapes we draw on the canvas. In 
 addition to these simple colors and fills, there are a number of different gradient 
 styles that we can em-ploy. Furthermore, Canvas also has a method to fill shapes 
 with bitmap images (see 
 Chapter 4
 ).",NA
Setting Basic Fill Colors,"The Canvas 
 fillStyle
  property is used to set a basic color for filling shapes on the 
 canvas. We saw this earlier in the chapter when we used simple color names for 
 our 
 fillStyle
 . An example is:
  
 context.fillStyle = ""red"";
  
 Below is a list of the usable color string values from the HTML4 specification. As of 
 this writing, the HTML5 color specification has not been set. In the absence of any 
 additional HTML5-specific colors, the HTML4 colors will work properly in HTML5:
  
 Black = 
 #000000 
  
 Green = 
 #008000 
  
 Silver = 
 #C0C0C0 
  
 Lime = 
 #00FF00 
  
 Gray = 
 #808080 
  
 Olive = 
 #808000 
  
 White = 
 #FFFFFF 
  
 Yellow = 
 #FFFF00 
  
 Maroon = 
 #800000 
  
 Navy = 
 #000080 
  
 Red = 
 #FF0000 
  
 Blue = 
 #0000FF 
  
 Purple = 
 #800080 
  
 Teal = 
 #008080 
  
 Fuchsia = 
 #FF00FF 
  
 Aqua = 
 #00FFFF
  
  
 All these color values will work with the 
 strokeStyle
  as well as the 
 fillStyle
 .
  
 Of course, using a string for the color name is not the only available method of 
 speci-fying a solid color fill. The list below includes a few other methods:
  
 Filling Objects with Colors and Gradients | 51",NA
Filling Shapes with Gradients,"There are two basic options for creating gradient fills on the canvas: linear and 
 radial. A 
 linear
  gradient creates a horizontal, vertical, or diagonal fill pattern; the 
 radial
  variety creates a fill that “radiates” from a central point in a circular fashion. 
 Let’s look at some examples of each.
  
 Linear gradients
  
 Linear gradients come in three basic styles: horizontal, vertical, and diagonal. We 
 con-trol where colors change in our gradient by setting 
 color stops
  at points along 
 the length of the object we wish to fill.
  
 Linear horizontal gradients. 
 Example 2-14
  creates a simple horizontal gradient, 
 as shown in 
 Figure 2-23
 .
  
 Example 2-14. A linear horizontal gradient
  
 function drawScreen() {
  
  // horizontal gradient values must remain 0
  
  var gr = context.createLinearGradient(0, 0, 100, 0);
  
  // Add the color stops.
  
  gr.addColorStop(0,'rgb(255,0,0)');
  
  gr.addColorStop(.5,'rgb(0,255,0)');
  
  gr.addColorStop(1,'rgb(255,0,0)');
  
  // Use the gradient for the fillStyle.
  
  context.fillStyle = gr;
  
  context.fillRect(0, 0,100,100);
  
  }
  
 52 | Chapter 2:Drawing on the Canvas",NA
Filling Shapes with Patterns,"We will cover using bitmap images on the canvas in 
 Chapter 4
 , but for now, let’s 
 take a quick look at how images can be used as fill patterns for shapes we draw.
  
 Filling Shapes with Patterns | 61",NA
Creating Shadows on Canvas Shapes,"We can add shadows to shapes we draw on the canvas using four parameters. As 
 with the tiled fill patterns in the previous section, this feature has not been fully 
 implemented on all HTML5-compliant browsers.
  
 We add a shadow by setting four Canvas properties:
  
 •
  shadowOffsetX
  
 •
  shadowOffsetY
  
 •
  shadowBlur
  
 •
  shadowColor
  
 The 
 shadowOffsetX
  and 
 shadowOffsetY
  values can be positive or negative. Negative 
 val-ues will create shadows to the left and top rather than to the bottom and right. 
 The 
 shadowBlur
  property sets the size of the blurring effect on the shadow. None of 
 these three parameters is affected by the current Canvas transformation matrix. 
 The 
 shadow Color
  can be any color set via HTML4 color constant string—
 rgb()
  or 
 rgba()
 —or with a string containing a hex value.
  
 Example 2-27
  and 
 Figure 2-39
  show a few different boxes drawn with various 
 shadow settings.
  
 Creating Shadows on Canvas Shapes | 65",NA
What’s Next,"We covered a lot of ground in this chapter, introducing the ways to construct 
 primitive and complex shapes, and how we can draw and transform them on the 
 canvas. We also discussed how to composite, rotate, scale, translate, fill, and create 
 shadows on these shapes. But we’ve only just begun exploring HTML5 Canvas. In 
 the next chapter, we will look at how to create and manipulate text objects on the 
 canvas.
  
 What’s Next | 67",NA
CHAPTER 3,NA,NA
The HTML5 Canvas Text API,"The HTML5 Canvas Text API allows developers to render text on an HTML page in 
 ways that were either tricky or next to impossible before its invention.
  
 We are providing an in-depth analysis of the HTML5 Canvas Text API because it is 
 one of the most basic ways to interact with the canvas. However, that does not 
 mean it was the first Canvas API feature developed. In fact, for many browsers, it 
 was one of the last parts implemented.
  
 There was a time in the recent past when HTML5 Canvas Text API support in 
 browsers was spotty at best. Back then, using 
 modernizr.js
  to test for text support 
 would have been a good idea. However, at this historic moment, all modern 
 browser versions (be-sides IE) support the HTML5 Canvas Text API in some way.
  
 This chapter will create an application named “Text Arranger” to demonstrate the 
 features and interdependencies of the HTML5 Canvas Text API. This application 
 will display a single line of text in an almost infinite number of ways. This is also a 
 useful tool to see whether support for text is common among web browsers. Later 
 in this chapter you will see that some text features are incompatible when drawn 
 on the canvas at the same time.",NA
Displaying Basic Text,"Displaying text on HTML5 Canvas is simple. In fact, we covered the very basics in 
 Chapter 1
 . First, we will review these basics, and then we will show you how to 
 make them work with the Text Arranger application.",NA
Basic Text Display,"The simplest way to define text to be displayed on the canvas is to set the 
 context.font
  style using standard values for CSS font style attributes: 
 font-style
 , 
 font-
 weight
 , 
 font-size
 , and 
 font-face
 .
  
 69",NA
Handling Basic Text in Text Arranger,"For Text Arranger, we are going to allow the user to set the text displayed by the 
 call to 
 context.fillText()
 . To do this, we will create a variable named 
 message
  where 
 we will store the user-supplied text. We will later use that variable in our call to 
 context.fillText()
 , inside the standard 
 drawScreen()
  method that we introduced in 
 Chapter 1
  and will continue to use throughout this book:
  
 var message = ""
 your text
 ""; 
  
 ...
  
 function drawScreen() {
  
  ...
  
  context.fillStyle = ""#FF0000"";
  
  context.fillText  (message, 100, 80); 
  
 }
  
 To change the text displayed on the canvas to the text entered by the user, we need 
 to create an event handler for the text box 
 keyup
  event. This means that whenever 
 someone changes text in the box, the event handler function will be called.
  
 To make this work, we are going to name our text box in our HTML 
 <form>
  using an 
 <input>
  form element. Notice that the id is set to the value 
 textBox
 . Also notice that 
 we have set the 
 placeholder=""""
  attribute. This attribute is new to HTML5, so it might 
 not work in every browser. You can also substitute it with the 
 value=""""
  attribute, 
 which will not affect the execution of this application:
  
 70 | Chapter 3:The HTML5 Canvas Text API",NA
Communicating Between HTML Forms and the ,NA,NA
Canvas,"Back in our JavaScript code, we need to create an event handler for the 
 keyup
  event 
 of 
 textBox
 . We do this by finding the form element using the 
 document.getElement 
 ById()
  function of the DOM 
 document
  object, and storing it in the 
 formElement
  
 variable. Then we call the 
 addEventListener()
  method of 
 formElement
 , setting the 
 event to 
 keyup
  and the event handler to the function 
 textBoxChanged
 , which we have 
 yet to define:
  
 var formElement = document.getElementById(""textBox""); 
  
 formElement.addEventListener('keyup', textBoxChanged, false);
  
 The final piece of the puzzle is to define the 
 textBoxChanged()
  event handler. This 
 function works like the event handlers we created in 
 Chapter 1
 . It is passed one pa-
 rameter when it is called, an 
 event
  object that we universally name 
 e
  because it’s 
 easy to remember.
  
 The 
 event
  object contains a property named 
 target
  that holds a reference to the 
 HTML form element that created the 
 change
  event. In turn, the 
 target
  contains a 
 property named 
 value
  that holds the newly changed value of the form element that 
 caused the event to occur (i.e., 
 textBox
 ). We retrieve this value, and store it in the 
 message
  variable we created in JavaScript. It is the very same 
 message
  variable we 
 use inside the 
 drawScreen()
  method to paint the canvas. Now, all we have to do is 
 call 
 draw Screen()
 , and the new value of 
 message
  will appear “automagically” on the 
 canvas:
  
 function textBoxChanged(e) {
  
   
  var target = e.target;
  
   
  message = target.value;
  
   
  drawScreen();
  
  
  }
  
 We just spent a lot of time describing how we will handle changes in HTML form 
 controls with event handlers in JavaScript, and then display the results on an 
 HTML5 Canvas. We will repeat this type of code several more times while creating 
 Text Ar-ranger. However, we will refrain from explaining it in depth again, instead 
 focusing on different ways to render and capture form data and use it with Canvas.",NA
Using measureText,"The HTML5 Canvas context object includes a useful method, 
 measureText()
 . When 
 supplied with a text string, it will return some properties about that text based on 
 the current context settings (font face, size, etc.) in the form of a 
 TextMetrics
  object. 
 Right now the 
 TextMetrics
  object has only a single property: 
 width
 . The 
 width
  
 property of a",NA
fillText and strokeText,"The 
 context.fillText()
  function (as shown in 
 Figure 3-1
 ) will render solid colored text 
 to the canvas. The color used is set in the 
 context.fillColor
  property. The font used is 
 set in the 
 context.font
  property. The function call looks like this:
  
 fillText([text],[x],[y],[maxWidth]);
  
 where:
  
 text 
  
  
 The text to render on the canvas.
  
 x 
  
  
 The 
 x
  position of the text on the canvas.
  
 y 
  
  
 The 
 y
  position of the text on the canvas.
  
 maxWidth 
  
 The maximum width of the text as rendered on the canvas. At the time of this 
 writing, support for this property was just being added to browsers.
  
  
 Figure 3-1. fillText in action
  
 The 
 context.strokeText()
  function (as shown in 
 Figure 3-2
 ) is similar, but it specifies 
 the outline of text strokes to the canvas. The color used to render the stroke is set in 
 the 
 context.strokeColor
  property; the font used is set in the 
 context.font
  property.
  
 The function call looks like:
  
 strokeText([text],[x],[y],[maxWidth])
  
 Displaying Basic Text | 73",NA
eval(),"While we created a separate function for each event handler for the applications in 
 this chapter, in reality many of them work in an identical way. However, some 
 developers might be inclined to use an 
 eval()
  function, such as the following, as 
 their event handler for changes made to the HTML element that controls Text 
 Arranger:
  
 var formElement = document.getElementById(""textBox"");
  
  
 formElement.addEventListener('keyup', function(e) { 
  
  
  applyChange('message', e) }, false); 
  
 formElement = document.getElementById(""fillOrStroke""); 
 formElement.addEventListener('change', function(e) { 
  
  
 applyChange('fillOrStroke', e) }, false); 
  
 function applyChange (variable, e) {
  
  
  eval(variable + ' = e.target.value');
  
  
  drawScreen(); 
  
 }
  
 The code above uses 
 eval()
  to create and execute JavaScript code on the fly. It 
 dynam-ically creates the name of the HTML element so that the multiple event 
 handler func-tions do not need to be created individually. However, many 
 developers are wary of using 
 eval()
  because it opens up security holes, and makes 
 debugging code more difficult. Use at your own risk.
  
 In the 
 drawScreen()
  function, we test the 
 fillOrStroke
  variable to see whether it con-
 tains the value 
 fill
 . Since we have three states (
 fill
 , 
 stroke
 , or 
 both
 ), we use a 
 switch
  
 statement to handle the choices. If the choice is 
 both
 , we set the 
 strokeStyle
  to black 
 (
 #000000
 ) as the highlight for the colored 
 fillText
 .
  
 If we use the 
 xPosition
  and 
 yPosition
  calculated using the width and height of the 
 canvas, the 
 message
  variable that contains the default or user-input text, and the 
 fill 
 OrStroke
  variable to determine how to render the text, we can display the text as 
 con-figured by the user in 
 drawScreen()
 :
  
 Displaying Basic Text | 75",NA
Setting the Text Font,"Now that we have placed text on the canvas, it’s time to explore some of the basics 
 of setting the 
 context.font
  property. As you will see, specifying the font for displaying 
 basic text on Canvas is really no different from doing the same thing in HTML and 
 CSS.",NA
"Font Size, Face Weight, and Style Basics","It is very easy to style text that will be rendered on the canvas. It requires you to set 
 the size, weight, style, and font face in a CSS-compliant text string that is applied to 
 the 
 context.font
  property. The basic format looks like this:
  
 78 | Chapter 3:The HTML5 Canvas Text API",NA
Handling Font Size and Face in Text Arranger ,"In Text Arranger, we have implemented only a subset of the available font options 
 for displaying text. We have chosen these to make the application work in as many 
 brows-ers as possible. Here is a short rundown of the options we will implement.
  
 Available font styles 
  
 CSS defines the valid font styles as: 
  
  
 normal
  | 
 italic
  | 
 oblique
  | 
 inherit 
  
 In Text Arranger, we have implemented all but 
 inherit
 .
  
 Here is the markup we used to create the font style 
 <select>
  box in HTML. We made 
 the id of the form control equal to 
 fontStyle
 . We will use this id when we listen for a 
 change
  event, which is dispatched when the user updates the value of this control. 
 We will do this for all the controls in this version of Text Arranger: 
  
  
 <select id=""fontStyle"">
  
  
  <option value=""normal"">normal</option>
  
  
  <option value=""italic"">italic</option>
  
  
  <option value=""oblique"">oblique</option> 
  
  
 </select>
  
 Available font weights 
  
 CSS defines the valid font weights as: 
  
  
 normal
  | 
 bold
  | 
 bolder
  | 
 lighter
  | 
 100
  | 
 200
  | 
 300
  | 
 400
  | 
 500
  | 
 600
  | 
 700
  | 
 800
  | 
 900
  | 
  
 inherit
  | 
 auto 
  
 We have used only 
 normal
 , 
 bold
 , 
 bolder
 , and 
 lighter
  in Text Arranger. You can add the 
 other values as you see fit.
  
 Here is the markup we used to create the font weight 
 <select>
  box in HTML: 
 <select id=""fontWeight"">
  
  <option value=""normal"">normal</option>
  
  <option value=""bold"">bold</option>
  
  <option value=""bolder"">bolder</option>
  
 Setting the Text Font | 79",NA
Font Color,"Setting the font color for text rendered on HTML5 Canvas is as simple as setting the 
 context.fillStyle
  or 
 context.strokeStyle
  property to a valid CSS RGB color. Use the 
 format “#RRGGBB”, where RR is the red component hexadecimal value, GG is the 
 green component hexadecimal value, and BB is the blue component hexadecimal 
 value. Here are some examples:
  
 context.fillStyle = ""#FF0000""; 
  
  
 Sets the text fill to red.
  
 context.strokeStyle = ""#FF00FF""; 
  
  
 Sets the text stroke to purple.
  
 context.fillStyle = ""#FFFF00""; 
  
  
 Sets the text fill to yellow.
  
 Setting the Text Font | 83",NA
Font Baseline and Alignment,"You have options to align text on HTML5 Canvas both vertically and horizontally. 
 These alignments affect the text in relation to Canvas itself, but only to the invisible 
 bounding box that would surround the text’s topmost, bottommost, rightmost, and 
 leftmost sides. This is an important distinction because it means these alignments 
 affect the text in ways that might be unfamiliar to you.
  
 Vertical alignment
  
 The font baseline is the vertical alignment of the font glyphs based on predefined 
 hor-izontal locations in a font’s 
 em square
  (the grid used to design font outlines) in 
 relation to font descenders. Basically, font glyphs, like lowercase 
 p
  and 
 y
  that 
 traditionally ex-tend “below the line,” have 
 descenders
 . The baseline tells the canvas 
 where to render the font based on how those descenders relate to other glyphs in 
 the font face.
  
 The HTML5 Canvas API online has a neat graphic that attempts to explain baseline. 
 We could copy it here, but in reality, we think it’s easier to understand by 
 doing
 , 
 which is one of the main reasons we wrote the Text Arranger application.
  
 The options for the 
 context.textBaseline
  property are:
  
 top 
  
 The top of the text 
 em square
  and the top of the highest glyph in the font face. 
 Selecting this baseline will push the text the farthest down (highest 
 y
  position) 
 the canvas of all the baselines.
  
 hanging 
  
 This is a bit lower than the 
 top
  baseline. It is the horizontal line from which 
 many glyphs appear to “hang” from near the top of their face.
  
 middle 
  
 The dead vertical center baseline. We will use 
 middle
  to help us vertically center 
 the text in Text Arranger.
  
 alphabetic 
  
  
 The bottom of vertical writing script glyphs such as Arabic, Latin, and 
 Hebrew.
  
 ideographic 
  
 The bottom of horizontal writing script glyphs such as Han Ideographs, 
 Katakana, Hiragana, and Hangul.
  
 bottom 
  
 The bottom of the 
 em square
  of the font glyphs. Choosing this baseline will push 
 the font the farthest up (lowest 
 y
  position) the canvas.
  
 So, for example, if you want to place your text with a 
 top
  baseline, you would use the 
 following code:
  
 context.textBaseline = ""top"";",NA
Text Arranger Version 2.0,"Now, try the new version of Text Arranger, shown in 
 Example 3-2
 . You can see that 
 we have added a ton of new options that did not exist in version 1.0. One of the 
 most striking things is how fluidly the text grows and shrinks as the font size is 
 updated. Now, imagine scripting the font size to create animations. How would you 
 do that? Could you create an application to record the manipulations the user 
 makes with Text Arranger, and then play them back in real time?
  
 Also, notice how all the alignment options affect one another. Experiment with how 
 changing the text direction affects the vertical alignment. Choose different font 
 faces and see how they affect the baseline. Do you see how an application like Text 
 Arranger can help you understand the complex relationships of all the text 
 properties on HTML5 Canvas in an interactive and—dare we say—fun way?
  
 Example 3-2. Text Arranger 2.0
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH3EX2: Text Arranger Version 2.0</title> 
  
 <script src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript"" src=""jscolor/jscolor.js""></script> <script 
 type=""text/javascript"">
  
 window.addEventListener(""load"", eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
 }
  
  canvasApp();
  
 function canvasSupport () {
  
  
  return Modernizr.canvas; 
  
 }
  
 function eventWindowLoaded() {
  
 }
  
  canvasApp();
  
 function canvasApp() {
  
  var message = ""your text"";
  
  var fillOrStroke = ""fill"";
  
  var fontSize = ""50"";
  
  var fontFace = ""serif"";
  
  var textFillColor = ""#ff0000"";
  
  var textBaseline = ""middle"";
  
  var textAlign = ""center"";
  
  var fontWeight = ""normal"";
  
  var fontStyle = ""normal"";
  
 90 | Chapter 3:The HTML5 Canvas Text API",NA
Text and the Canvas Context,"We’ve already discussed a couple Canvas context properties that affect the canvas 
 in a global fashion: 
 fillStyle
  and 
 strokeStyle
 . However, there are two areas that 
 visually demonstrate how changes to the properties of the context can affect the 
 entire HTML5 Canvas: alpha transparencies and shadows.",NA
Global Alpha and Text,"Using alpha is a cool way to make objects seem to be partially or fully transparent 
 on HTML5 Canvas. The 
 globalAlpha
  property of the Canvas context is used for this 
 pur-pose. After 
 globalAlpha
  is applied, it affects all drawing on the canvas, so you 
 need to be careful when setting it.
  
 94 | Chapter 3:The HTML5 Canvas Text API",NA
Global Shadows and Text ,"HTML5 Canvas includes a unique set of properties for creating a shadow for 
 drawings. The 
 context.shadow
  functions are not unique to text, but they can make 
 some very good text effects with very little effort.
  
 96 | Chapter 3:The HTML5 Canvas Text API",NA
Text with Gradients and Patterns,"We’ve already explored the 
 fillColor
  and 
 strokeColor
  properties of the Canvas context 
 by setting those value to CSS-compliant colors. However, those very same 
 properties can be set to refer to a few other objects defined in the Canvas API to 
 create some stunning text effects. The objects are:
  
 Linear gradient 
  
  
 A linear color gradient with two or more 
 colors
  
 Radial gradient 
  
  
 A circular color gradient with two or more colors
  
 Image pattern 
  
  
 An 
 Image
  object used as a fill 
 pattern",NA
Linear Gradients and Text,"To create a linear gradient, make a call to the context’s 
 createLinearGradient()
  
 method to create a 
 Gradient
  object. The 
 createLinearGradient()
  method accepts four 
 param-eters that all define the line of the linear gradient. The 
 x0
  and 
 y0
  parameters 
 are the starting point of the line, and 
 x1
  and
 y1
  represent the ending point of the 
 line:
  
 var gradient = context.createLinearGradient( 
 [x0]
 ,
 [y0]
 ,
 [x1]
 ,
 [y1]
 );
  
 For example, if you want to create a linear gradient that starts at the beginning of 
 the text (located at 100,100), and has an endpoint that is the width of your text as 
 displayed on the canvas, you might write the following code:
  
 var metrics = context.measureText(message); 
  
 var textWidth = metrics.width; 
  
 var gradient = context.createLinearGradient(100, 100, textWidth, 100);
  
 After you have created the line that represents the gradient, you need to add colors 
 that will form the gradations of the gradient fill. This is done with the 
 addColorStop() 
 method, which requires two arguments: 
 offset
  and 
 color
 :
  
 gradient.addColorStop([offset],[color]);
  
 offset 
  
 This is the offset on the gradient line to start the color gradation. The entire 
 gradient is represented by the numbers between 0.0 and 1.0. The offset will be 
 a decimal that represents a percentage.
  
 color 
  
  
 A valid CSS color in the format “#RRGGBB”.
  
 So, if you want black to be the first color in the gradient, and then red to be the 
 second color that starts halfway down the gradient line, you would create two calls 
 to 
 add ColorStop()
 :",NA
Radial Gradients and Text,"A radial gradient is created much like a linear gradient, except that it represents a 
 cone—not a line. The cone is created by defining the center points and the radii of 
 two different circles when calling the 
 createRadialGradient()
  function of the Canvas 
 context:
  
 var gradient = context.createRadialGradient(
 [x0]
 ,
 [y0]
 ,
 [radius0]
 ,
 [x1]
 ,
 [y1]
 ,
 [radius1]
 );
  
 Let’s say you want to create a radial gradient based on a cone. It starts with a circle 
 that has its center point at 100,100 and a radius of 20, and ends at a circle with its 
 center point at 200,100 and a radius of 5. The code would look like this:
  
 var gradient = context.createRadialGradient(100,100,20,200,100,5);
  
 Adding color stops to a radial gradient works the same as with a linear gradient, 
 except the color moves along the cone instead of the line:
  
 gradient.addColorStop(0, ""#000000 ""); 
  
 gradient.addColorStop(.5, ""#FF0000"");",NA
Image Patterns and Text,"Another option for filling text on HTML5 Canvas is to use an 
 Image
  object. We will 
 devote all of 
 Chapter 4
  to using the Image API, so here we will only discuss the 
 basics of how to use one as a pattern for a text fill.
  
 To create an image pattern, call the 
 createPattern()
  method of the Canvas context, 
 passing a reference to an 
 Image
  object, and an option for 
 repetition
 :
  
 var pattern = context.createPattern(
 [image]
 , 
 [repetition]
 );
  
 image 
  
 A valid 
 Image
  object that has been loaded with an image by setting the 
 pattern 
 .src
  property and waiting for the image to load by setting an event listener for 
 the 
 Image onload
  event. The Canvas specification also allows for a 
 video
  element 
 or another 
 <canvas>
  to be used here as well.
  
 repetition 
  
  
 The “tiling” of the image. This can have one of four values:
  
 repeat 
  
  
 The image is tiled on both the x and y axes.
  
 repeat-x 
  
  
 The image is tiled only on the x-axis 
 (horizontally).
  
 repeat-y 
  
  
 The image is tiled only on the y-axis 
 (vertically).
  
 no-repeat 
  
  
 The image is not tiled.",NA
Patterns with Video: The Bad News,"The HTML5 Canvas API specifies that an HTML5 
 video
  element can be used as the 
 source for 
 createPattern()
  instead of an image. However, all of our attempts to do so 
 emitted the following JavaScript error:
  
 Uncaught Error: TYPE_MISMATCH_ERR: DOM Exception 17
  
 According to the DOM reference at 
 www.gnu.org
 , DOM Exception 17, TYPE 
 _MISMATCH_ERR occurs “if the type of an object is incompatible with the expected 
 type of the parameter associated to the object.”
  
 So it appears that most browsers have not included support for using video as the 
 pattern for 
 createPattern()
 . However, you can still load and play video on Canvas, 
 which we will discuss in depth in 
 Chapter 6
 .",NA
Handling Gradients and Patterns in Text Arranger,"Text Arranger 3.0 includes many changes that were implemented to support using 
 gradients and image patterns with text on HTML5 Canvas. To see these changes in 
 action, we first need to make sure that we have preloaded the 
 texture.jpg
  image, 
 which we will use for the 
 context.createPattern()
  functionality. To do this, we will 
 create a new function named 
 eventAssetsLoaded()
  that we will set as the event 
 handler for the 
 onload
  event of the 
 Image
  object that will hold the pattern. When 
 that image has loaded, we will call 
 canvasApp()
  in the same way we called it from 
 eventWindowLoaded()
 :
  
 function eventWindowLoaded() {
  
  
  var pattern = new Image();
  
  
  pattern.src = ""texture.jpg"";
  
  
  pattern.onload = eventAssetsLoaded; 
  
 }
  
 Text with Gradients and Patterns | 103",NA
"Width, Height, Scale, and toDataURL() ",NA,NA
Revisited,"In 
 Chapter 1
 , we briefly discussed that you can set the width and height of the 
 canvas, as well as the scale (style 
 width
  and 
 height
 ) of the canvas display area, 
 dynamically in code. We also showed you an example of using the 
 Canvas
  object’s 
 toDataURL()
  method to export a “screenshot” of the Canvas application. In this 
 section, we will revisit those functions as they relate to Text Arranger 3.0.",NA
Dynamically Resizing the Canvas,"In the code we developed in this chapter, we created a reference to the 
 Canvas
  
 object on the HTML page—with the id 
 canvasOne
 —and used it to retrieve the 2D 
 context of the 
 Canvas
  object:
  
 var theCanvas = document.getElementById(""canvasOne""); var 
 context = theCanvas.getContext(""2d"");
  
 While the 2D context is very important because we used it to draw directly onto the 
 canvas, we did not spend any time discussing the 
 Canvas
  object itself. In this 
 chapter, we use the 
 width
  property of the 
 Canvas
  object to center text on the canvas. 
 However, the 
 Canvas
  object also includes another property named 
 height
 , and both 
 of these properties can be used to dynamically resize the 
 Canvas
  object on demand. 
 Why would you want to do this? There could be many uses, such as:
  
 • Updating the canvas to the exact size of a loaded 
 video
  object
  
 • Dynamically animating the canvas after the page is loaded
  
 • Other, more creative uses like the one we will experiment with next
  
 Resizing the canvas on the fly is quite easy. To do it, simply set the 
 width
  and 
 height 
 properties of the 
 Canvas
  object, and then redraw the canvas contents:
  
 Canvas.width = 600; 
  
 Canvas.height = 500; 
  
 drawScreen();
  
 106 | Chapter 3:The HTML5 Canvas Text API",NA
Dynamically Scaling the Canvas,"Besides resizing the canvas using 
 theCanvas.width
  and 
 theCanvas.height
  attributes, 
 you can also use CSS styles to change its scale. Unlike resizing, scaling takes the 
 current canvas bitmapped area and resamples it to fit into the size specified by the 
 width
  and 
 height
  attributes of the CSS style. For example, to scale the canvas to a 
 400×400 area, you might use this CSS style:
  
 style = ""width: 400px; height:400px""
  
 To update the 
 style.width
  and 
 style.height
  properties of the canvas in Text Arranger, 
 we first create two more 
 range
  controls in the HTML page:
  
 Canvas Style Width:  <input type=""range"" id=""canvasStyleWidth""
  
  
 min=""0""
  
  
  max=""1000""
  
  
  step=""1""
  
  
  value=""500""/>
  
  <br>
  
  Canvas Style Height:
  
  <input type=""range"" id=""canvasStyleHeight""
  
  
  min=""0""
  
  
  max=""1000""
  
  
  step=""1""
  
  
  value=""300""/>
  
  <br>
  
 Next, we set the event handler for each 
 range
  control. However, this time we are 
 using the same handler —
 canvasStyleSizeChanged()
 —for both:
  
 formElement = document.getElementById(""canvasStyleWidth""); 
  
 formElement.addEventListener(""change"", canvasStyleSizeChanged, false); 
 formElement = document.getElementById(""canvasStyleHeight""); 
  
 formElement.addEventListener(""change"", canvasStyleSizeChanged, false);
  
 In the event handler, we use the 
 document.getElementById()
  method to get the values 
 from both 
 range
  controls. We then create a string that represents the style we want 
 to set for the canvas:
  
 ""width:"" + styleWidth.value + ""px; height:"" + styleHeight.value +""px;"";
  
 Width, Height, Scale, and toDataURL() Revisited | 109",NA
The toDataURL() Method of the Canvas Object,"As we briefly explained in 
 Chapter 1
 , the 
 Canvas
  object also contains a method 
 named 
 toDataURL()
 , which returns a string representing the canvas’ image data. A 
 call with no arguments will return a string of image data of MIME type 
 image/png
 . 
 If you supply the 
 image/jpg
  as an argument, you can also supply a second argument 
 between the numbers 0.0 and 1.0 that represents the quality/compression level of 
 the image.
  
 We are going to use 
 toDataURL()
  to output the image data of the canvas into a 
 <textarea>
  on our form, and then open a window to display the actual image. This is 
 just a simple way to show that the function is working.
  
 The first thing we do is create our last two form controls in HTML for Text 
 Arranger. We start by creating a button with the id of 
 createImageData
  that, when 
 pressed, will create the image data with a call to an event handler named 
 createImageDataPressed()
 .
  
 We also create a 
 <textarea>
  named 
 imageDataDisplay
  that will hold the text data of 
 the image after the 
 createImageData
  button is pressed:
  
 <input type=""button"" id=""createImageData"" value=""Create Image Data""> <br>
  
 <br> 
  
 <textarea id=""imageDataDisplay"" rows=10 cols=30></textarea>
  
 Next, we set up the event listener for the 
 createImageData
  button:
  
 formElement = document.getElementById(""createImageData""); 
  
 formElement.addEventListener('click', createImageDataPressed, false);
  
 Then, in the 
 createImageDataPressed()
  event handler, we call the 
 toDataURL()
  method 
 of the 
 Canvas
  object (
 theCanvas
 ), and set the value of the i
 mageDataDisplay<textarea>
  
 110 | Chapter 3:The HTML5 Canvas Text API",NA
SECURITY_ERR: DOM Exception 18,"In some web browsers, such as Google Chrome, you might experience an error 
 (SECURITY_ERR: DOM Exception 18) when trying to export the canvas while an 
 image is displayed (like the pattern fill type in 
 Example 3-3
 ). This usually occurs 
 because the web browser is executing a web page locally (loaded from the 
 filesystem). These errors can usually be removed by loading the HTML page from a 
 web server—either remotely or on your local machine.",NA
Final Version of Text Arranger,"The final version of Text Arranger (3.0) brings together all the HTML5 Text API fea-
 tures we have discussed in this chapter (see 
 Example 3-3
 ). Play with the final app, 
 and see how the different options interact with one another. Here are a couple 
 things you might find interesting:
  
 • Shadows don’t work with patterns or gradients.
  
 • Increasing the text size with a pattern that is the size of the canvas changes the 
  
 pattern on the text (it acts like a mask or window into the pattern itself).
  
 • Canvas width and height are affected by the style width and height (scaling).
  
 Example 3-3. Text Arranger 3.0
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH3EX3: Text Arranger 3.0</title> 
  
 <script src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript"" src=""jscolor/jscolor.js""></script> <script 
 type=""text/javascript"">
  
 window.addEventListener(""load"", eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
 }
  
  canvasApp();
  
 function canvasSupport () {
  
  
  return Modernizr.canvas; 
  
 }
  
 function eventWindowLoaded() {
  
  
  var pattern = new Image();
  
  
  pattern.src = ""texture.jpg"";
  
  
  pattern.onload = eventAssetsLoaded; 
  
 }
  
 function eventAssetsLoaded() {
  
 112 | Chapter 3:The HTML5 Canvas Text API",NA
What’s Next,"In this chapter, we introduced you to the fundamentals of the HTML5 Canvas Text 
 API, offered some general concepts relating to drawing on the canvas, and 
 explained how to communicate with HTML form controls. As you can now see, the 
 basic concept of writing text to HTML5 Canvas can be taken to very complex (and 
 some might argue ludicrous) levels. The final application, Text Arranger 3.0, allows 
 you to modify a single line of text in an almost infinite number of ways. In the next 
 chapter, we move on to displaying and manipulating images on the canvas.
  
 What’s Next | 121",NA
CHAPTER 4,NA,NA
Images on the Canvas,"Like the Canvas Drawing API, the Canvas Image API is very robust. With it, we can 
 load in image data and apply it directly to the canvas. This image data can also be 
 cut and spliced to display any desired portion. Furthermore, Canvas gives us the 
 ability to store arrays of pixel data that we can manipulate and then draw back to 
 the canvas.
  
 There are two primary Canvas functions we can perform with images. We can 
 display images, and we can modify them pixel by pixel and paint them back to the 
 canvas. There are only a few Image API functions, but they open up a world of pixel-
 level manipulation that gives the developer the power to create optimized 
 applications di-rectly in the web browser without needing any plug-ins.",NA
The Basic File Setup for This Chapter,"All the examples in this chapter will use the same basic file setup for displaying our 
 demonstrations as we proceed through the Drawing API. Use the following as the 
 basis for all the examples we create—you will only need to change the contents of 
 the 
 drawScreen()
  function:
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>Ch4BaseFile - Template For Chapter 4 Examples</title> <script 
 src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript""> 
  
 window.addEventListener('load', eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
  canvasApp();
  
 }
  
 function canvasSupport () {
  
  
  return Modernizr.canvas; 
  
 }
  
 123",NA
Image Basics,"The Canvas API allows access to the DOM-defined 
 Image
  object type through the use 
 of the 
 drawImage()
  method. The image can be defined in HTML, such as:
  
 <img src=""ship1.png"" id=""spaceship"">
  
 Or it can be defined in JavaScript. We create a new JavaScript 
 Image
  instance like 
 this:
  
 var spaceShip = new Image();
  
 We can then set the file source of the image by assigning a URL to the 
 src
  attribute 
 of our newly created 
 Image
  object:
  
 spaceShip.src = ""ship1.png"";
  
 124 | Chapter 4:Images on the Canvas",NA
Preloading Images,"Before an image can be called in code, we must ensure that it has properly loaded 
 and is ready to be used. We do this by creating an event listener to fire off when the 
 load 
 event on the image occurs:
  
 spaceShip.addEventListener('load', eventShipLoaded , false);
  
 When the image is fully loaded, the 
 eventShipLoaded()
  function will fire off. Inside 
 this function we will then call 
 drawScreen()
 , as we have in the previous chapters:
  
 function eventShipLoaded() {
  
  
  drawScreen(); 
  
 }
  
  
 In practice, we would not create a separate event listener function 
 for each loaded image. This code example works fine if your 
 application contains only a single image. In 
 Chapter 9
 , we will build 
 a game with multiple image files (and sounds) and use a single 
 listener function for
  
 all loaded resources.",NA
Displaying an Image on the Canvas with ,NA,NA
drawImage(),"Once we have an image loaded in, we can display it on the screen in a number of 
 ways. The 
 drawImage()
  Canvas method is used for displaying image data directly 
 onto the canvas. 
 drawImage()
  is 
 overloaded
  and takes three separate sets of 
 parameters, each allowing varied manipulation of both the image’s source pixels 
 and the destination location for those pixels on the canvas. Let’s first look at the 
 most basic:
  
 drawImage(
 Image
 , 
 dx
 , 
 dy
 )
  
 This function takes in three parameters: an 
 Image
  object, and 
 x
  and 
 y
  values 
 representing the top-left corner location to start painting the image on the canvas.
  
 Here is the code we would use to place our spaceship image at the 0,0 location (the 
 top-left corner) of the canvas:
  
 context.drawImage(spaceShip, 0, 0);
  
 If we want to place another copy at 50,50, we would simply make the same call but 
 change the location:
  
 context.drawImage(spaceShip, 50, 50);
  
 Example 4-1
  shows the full code for what we have done so far.
  
 Example 4-1. Load and display an image file
  
 var spaceShip = new Image(); 
  
 spaceShip.addEventListener('load', eventShipLoaded , false); 
 spaceShip.src = ""ship1.png"";",NA
Resizing an Image Painted to the Canvas,"To paint and scale drawn images, we can also pass parameters into the 
 drawImage() 
 function. For example, this second version of 
 drawImage()
  takes in an extra two 
 parameters:
  
 drawImage(
 Image, dx, dy, dw, dh
 )
  
 dw
  and 
 dh
  represent the width and height of the rectangle portion of the canvas 
 where our source image will be painted. If we only want to scale the image to 
 64×64 or 16×16, we would use the following code:
  
 context.drawImage(spaceShip, 0, 0,64,64); 
  
 context.drawImage(spaceShip, 0, 0,16,16);
  
 Example 4-2
  draws various sizes to the canvas.
  
 Example 4-2. Resizing an image as it is drawn
  
 function eventShipLoaded() {
  
  
  drawScreen(); 
  
 }
  
 function drawScreen() {
  
 }
  
  context.drawImage(spaceShip, 0, 0);
  
  context.drawImage(spaceShip, 0, 34,32,32); 
 context.drawImage(spaceShip, 0, 68,64,64); 
 context.drawImage(spaceShip, 0, 140,16,16);
  
 See 
 Figure 4-3
  for the output to this example.
  
 Image Basics | 127",NA
Copying Part of an Image to the Canvas,"The third set of parameters that can be passed into 
 drawImage()
  allows us to copy 
 an arbitrary rectangle of data from a source image and place it onto the canvas. 
 This image data can be resized as it is placed.
  
 We are going to use a second source image for this set of operations: spaceships 
 that have been laid out on what is called a 
 tile sheet
  (also known as a 
 sprite sheet
 , a 
 texture sheet
 , or by many other names). This type of file layout refers to an image 
 file that is broken up physically into rectangles of data. Usually these rectangles 
 have an equal width and height. The “tiles” or “sprites” we will be using are 32 
 pixels wide by 32 pixels high, commonly referred to as 32×32 tiles.
  
 128 | Chapter 4:Images on the Canvas",NA
Simple Cell-Based Sprite Animation,"With a tile sheet of images, it is relatively simple to create what seems like cell-
 based or flip-book animation. This technique involves rapidly swapping images 
 over time to simulate animation. The term 
 flip-book
  comes from the age-old 
 technique of drawing individual cells of animation in the top-left corner pages of a 
 book. When the pages are rapidly flipped through, the changes are viewed over 
 time, appearing to create a car-toon. 
 Cell-based animation
  refers to a similar 
 professional technique. Individual same-sized cells (or pages) of images are drawn 
 to simulate animation. When played back rapidly with special devices in front of a 
 camera, animated cartoons are recorded.
  
 We can use the 
 drawImage()
  function and the first two tiles on our tile sheet to do 
 the same thing.",NA
Creating an Animation Frame Counter,"We can simulate the ship’s exhaust firing by rapidly flipping between the first two 
 tiles (or cells) on our tile sheet. To do this, we set up a counter variable, which is 
 how we track the tile we want to paint to the canvas. We will use 
 0
  for the first cell 
 and 
 1
  for the second cell.",NA
Creating a Timer Loop,"As it currently stands, our code will only be called a single time. Let’s create a 
 simple timer loop that will call the 
 drawScreen()
  function 10 times a second, or once 
 every 100 milliseconds. A timer loop that is set to run at a certain frame rate is 
 sometimes referred to as a 
 frame tick
  or 
 timer tick
 . Each tick is simply a single 
 iteration of the timer running all the code we put into our 
 drawScreen()
  function. We 
 will also need a function that starts the timer loop and initiates the tick once the 
 image has preloaded properly. We’ll name this function 
 startUp()
 :
  
 function eventShipLoaded() {
  
  
  startUp(); 
  
 }
  
 function startUp(){
  
  
  setInterval(drawScreen, 100 ); 
  
 }",NA
Changing the Tile to Display,"To change the tile to display, we can multiply the counter variable by 
 32
  (the tile 
 width). Since we only have a single row of tiles, we don’t have to change the 
 y
  value:
  
 context.drawImage(tileSheet, 32*counter, 0,32,32,50,50,64,64);
  
  
 We will examine how to use a tile sheet consisting of multiple rows 
 and columns in the next section, 
 “Advanced Cell-Based Anima-tion” 
 on page 132
 .
  
 Example 4-3
  used this same line of code to draw our image. In 
 Example 4-4
 , it will 
 be placed on the canvas at 50,50 and scaled to 64×64 pixels. Let’s look at the entire 
 set of code.
  
 Simple Cell-Based Sprite Animation | 131",NA
Advanced Cell-Based Animation,"In the previous example, we simply flipped back and forth between two tiles on our 
 tile sheet. Next, we are going to create a method that uses a tile sheet to play 
 through a series of images. First, let’s look at the new tile sheet, created by using 
 tiles from SpriteLib. 
 Figure 4-7
  shows the example sprite sheet, 
 tanks_sheet.png
 ; we 
 will refer back to this figure throughout the chapter.
  
  
 Figure 4-7. Example tile sheet
  
 132 | Chapter 4:Images on the Canvas",NA
Examining the Tile Sheet,"The tile sheet is formatted into a series of tiles starting at the top left. As with a two-
 dimensional array, the numbering starts at 0—we call this 
 0 relative
 . Moving from 
 left to right and down, each tile will be referenced by a single number index (as 
 opposed to a multidimensional index). The gray square in the top left is tile 0, while 
 the tank at the end of the first row (the rightmost tank) is tile 7. Moving down to 
 the next row, the first tank on the far left of the second row is tile 8, and so on until 
 the final tile on row 3 (the fourth row down when we start numbering at 0) is tile 
 31. We have four rows with eight columns each, making 32 tiles with indexes 
 numbered 0 to 31.",NA
Creating an Animation Array,"Next, we are going to create an array to hold the tiles for the animation. There are 
 two tanks on the tile sheet: one is green and one is blue. Tiles 1‒8 are a series 
 that—when played in succession—will make it appear as though the green tank’s 
 tracks are moving.
  
  
 Remember, the tile sheet starts at tile 0, but we want start with the 
 first tank image at tile number 1.
  
 We will store the tile ids we want to play for the tank in an array:
  
 var animationFrames = [1,2,3,4,5,6,7,8];
  
 We will use a counter to keep track of the current index of this array:
  
 var frameIndex = 0;",NA
Choosing the Tile to Display,"We will use the 
 frameIndex
  of the 
 animationFrames
  array to calculate the 32×32 
 source rectangle from our tile sheet that we will copy to the canvas. First, we need 
 to find the x and y locations of the top-left corner for the tile we want to copy. To do 
 this, we will create local variables in our 
 drawScreen()
  function on each iteration 
 (frame) to calculate the position on the tile sheet. The 
 sourceX
  variable will contain 
 the top-left corner 
 x 
 position, and the 
 sourceY
  variable will contain the top-left 
 corner 
 y
  position.",NA
Looping Through the Tiles,"We will update the 
 frameIndex
  value on each frame tick. When 
 frameIndex
  becomes 
 greater than 
 7
 , we will set it back to 
 0
 :
  
 frameIndex++;
  
  if (frameIndex == animationFrames.length) { 
 frameIndex = 0;
  
  }
  
 The 
 animationFrames.length
  value is 
 8
 . When the 
 frameIndex
  is equal to 
 8
 , we must set 
 it back to 
 0
  to start reading the array values over again, which creates an infinite 
 ani-mation loop.",NA
Drawing the Tile,"We will use 
 drawImage()
  to place the new tile on the screen on each iteration:
  
 context.drawImage(tileSheet, sourceX, sourceY,32,32,50,50,32,32);
  
 Here, we are passing the calculated 
 sourceX
  and 
 sourceY
  values into the 
 drawImage() 
 function. We then pass in the width (
 32
 ), the height (
 32
 ), and the location (
 50,50
 ) to 
 draw the image on the canvas. 
 Example 4-5
  shows the full code.
  
 Example 4-5. Advanced sprite animation
  
 var tileSheet = new Image(); 
  
 tileSheet.addEventListener('load', eventShipLoaded , false);
  
 tileSheet.src = ""tanks_sheet.png"";
  
 var animationFrames = [1,2,3,4,5,6,7,8]; 
  
 var frameIndex = 0;
  
 134 | Chapter 4:Images on the Canvas",NA
Moving the Image Across the Canvas,"Now that we have the tank tracks animating, let’s “move” the tank. By animating 
 the tank tracks and applying a simple movement vector to the tank’s position, we 
 can achieve the simulation of animated movement.
  
 To do this, we first need to create variables to hold the current 
 x
  and 
 y
  positions of 
 the tank. These represent the top-left corner where the tile from our sheet will be 
 drawn to the canvas. In the previous examples, this number was set at 
 50
  for each, 
 so let’s use that value here as well:
  
 var x = 50; 
  
 var y = 50;
  
 We also need a movement vector value for each axis. These are commonly known 
 as 
 deltaX
  (
 dx
 ) and 
 deltaY
  (
 dy
 ). They represent the “delta” or “change” in the 
 x
  or 
 y
  
 axis position on each iteration. Our tank is currently facing in the “up” position, so 
 we will use 
 -1
  for the 
 dy
  and 
 0
  for the 
 dx
 :
  
 var dx = 0; 
  
 var dy = -1;
  
 Advanced Cell-Based Animation | 135",NA
Applying Rotation Transformations to an ,NA,NA
Image,"In the previous section, we created an animation using tiles from a tile sheet. In this 
 section, we will take it one step further and use the Canvas transformation matrix 
 to rotate our image before drawing it to the canvas. This will allow us to use only a 
 single set of animated tiles for all four (or more) rotated directions in which we 
 would like to display our images. Before we write the code, let’s examine what it 
 will take to rotate our tank animation from the previous section.
  
  
 In 
 Chapter 2
 , we dove into applying basic transformations when 
 draw-ing with paths. The same concepts apply to transforming 
 images on the canvas. If you have not read the section 
 “Simple 
 Canvas Transforma-tions” on page 41
  in 
 Chapter 2
 , you might want 
 to review it before
  
 reading on.",NA
Canvas Transformation Basics,"Although we covered basic Canvas transformations in detail in 
 Chapter 2
 , let’s 
 review what’s necessary to transform an individual object on the canvas. 
 Remember, the can-vas is a single immediate-mode drawing surface, so any 
 transformations we make are applied to the entire canvas. In our example, we are 
 drawing two objects. First, we draw a gray background rectangle, and then we copy 
 the current tile from our tile sheet to the desired location. These are two discrete 
 objects, but once they are on the canvas, they are both simply collections of pixels 
 painted on the surface. Unlike Flash or other platforms that allow many separate 
 sprites or “movie clips” to occupy the physical space, there is only one such object 
 on Canvas: the 
 context
 .
  
 To compensate for this, we create logical display objects. Both the background and 
 the tank are considered separate logical display objects. If we want to draw the 
 tank but rotate it with a transformation matrix, we must separate the logical 
 drawing operations by using the 
 save()
  and 
 restore()
  Canvas context functions.",NA
Animating a Transformed Image ,"To apply a series of image tiles to the rotated context, we simply have to add back in 
 the frame tick loop code and increment the 
 frameIndex
  variable on each frame tick. 
 Example 4-8
  has added this into the code for 
 Example 4-7
 .
  
 Example 4-8. Animation and rotation 
  
 var tileSheet = new Image(); 
  
 tileSheet.addEventListener('load', eventShipLoaded , false); 
 tileSheet.src = ""tanks_sheet.png""; 
  
 var animationFrames = [1,2,3,4,5,6,7,8]; 
  
 var frameIndex = 0; 
  
 var rotation = 90;
  
 140 | Chapter 4:Images on the Canvas",NA
Creating a Grid of Tiles,"Many games use what is called a 
 tile-based environment
  for backgrounds and level 
 graphics. We are now going to apply the knowledge we have learned from 
 animating an image on the canvas to create the background maze for our 
 hypothetical game: 
 No Tanks!
  We will use the same tile sheet from the previous 
 tank examples, but instead of showing the tank sprite tiles, we will create a maze 
 for the tank to move through. We
  
 142 | Chapter 4:Images on the Canvas",NA
Defining a Tile Map,"We will use the term 
 tile map
  to refer to a game level or background built from a 
 tile sheet. Take a look back at 
 Figure 4-7
 —the four row by eight column tile sheet 
 from earlier in this chapter. If we were to create a maze-chase game similar to 
 Pac-
 Man
 , we could define the maze using tiles from a tile sheet. The sequence of tiles for 
 our game maze would be considered a tile map.
  
 The first tile is a gray square, which we can use for the “road” tiles between the wall 
 tiles. Any tile that a game sprite can move on is referred to as 
 walkable
 . Even 
 though our tanks are not literally walking but driving, the concept is the same. In 
 Chapter 9 
 we will create a small game using these concepts, but for now, let’s 
 concentrate on defining a tile map and displaying it on the canvas.
  
 Our tile map will be a two-dimensional array of tile id numbers. If you recall, the 
 tile id numbers for our tile sheet are in a single dimension, numbering from 0 to 31. 
 Let’s say we are going to create a very small game screen consisting of 10 tiles in 
 length and 10 tiles in height. This means we need to define a tile map of 100 
 individual tiles (10×10). If our tiles are 32 pixels by 32 pixels, we will define a 
 320×320 game screen.
  
 There are many ways to define a tile map. One simple way is to use a tile map 
 editor program to lay out a grid of tiles, and then export the data to re-create the 
 tile map in JavaScript. This is precisely how we are going to create our tile map.",NA
Creating a Tile Map with Tiled,"The program we are going to use, Tiled, is a great tile map editor that is available 
 for Mac OS, Windows, and Linux. Of course, tile maps can be designed by hand, but 
 map creation is much easier if we utilize a program such as Tiled to do some of the 
 legwork for us. Tiled is available for free under the GNU free software license from 
 http://www .mapeditor.org/
 .
  
  
 As stated before, you do not need to use this software. Tile maps can 
 be created with other good (and free) software such as Mappy 
 (
 http://tile 
 map.co.uk/mappy.php
 ) 
 and 
 Tile 
 Studio 
 (
 http://tilestudio.sourceforge .net/
 ), and even by hand using MS 
 Paint.
  
 The goal of creating a tile map is to visually lay out a grid of tiles that represents the 
 game screen, and then export the tile ids that represent those tiles. We will use the 
 exported data as a two-dimensional array in our code to build the tile map on the 
 canvas.
  
 Creating a Grid of Tiles | 143",NA
Displaying the Map on the Canvas,"The first thing to note about the data from Tiled is that it is 
 1 relative
 , not 0 relative. 
 This means that the tiles are numbered from 1–32 instead of 0–31. We can 
 compensate for this by subtracting one from each value as we transcribe it to our 
 array, or programmatically during our tile sheet drawing operation. We will do it 
 programmat-ically by creating an offset variable to be used during the draw 
 operation:
  
 var mapIndexOffset = -1;
  
 Creating a Grid of Tiles | 145",NA
Zooming and Panning an Image,"In this section, we will examine some methods to zoom and pan an image on the 
 canvas. The image we are going to use is from a recent vacation to Central 
 California. It is a large 
 .jpg
  file, measuring 3648×2736. Obviously, this is far too 
 large to view in a single canvas, so we will build a simple application allowing us to 
 zoom and pan the image on our 500×500 canvas.
  
 Figure 4-11
  is a scaled-down version of this image.
  
  
 Figure 4-11. A scaled-down version of the image we will zoom and pan",NA
Creating a Window for the Image,"The first thing we are going to do is create a logical window, the size of the canvas, 
 where our image will reside. We will use the following two variables to control the 
 dimensions of this window:
  
 var windowWidth = 500; 
  
 var windowHeight = 500;
  
 Zooming and Panning an Image | 149",NA
Drawing the Image Window,"To draw the image window, we will simply modify the standard 
 context.drawImage() 
 function call using the values in the four variables we just defined:
  
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0, 0,
  
  windowWidth,windowHeight);
  
 Let’s take a closer look at this for a refresher on how the 
 drawImage()
  function 
 operates. The values are passed in order:
  
 photo 
  
  
 The image instance we are going to use as our source for painting onto the 
 canvas
  
 windowX 
  
  
 The top-left 
 x
  location to start copying from the source image
  
 windowY 
  
  
 The top-left 
 y
  location to start copying from the source image
  
 windowWidth 
  
  
 The width of the rectangle to start copying from the source 
 image
  
 windowHeight 
  
  
 The height of the rectangle to start copying from the source 
 image
  
 0 
  
  
 The top-left 
 x
  destination location for the image on the 
 canvas
  
 0 
  
  
 The top-left 
 y
  destination location for the image on the 
 canvas
  
 windowWidth 
  
 The width in pixels for the destination copy (this can be modified to scale the 
 image)
  
 windowHeight 
  
 The height in pixels for the destination copy (this can be modified to scale the 
 image)
  
 When we draw from the image to the canvas, we will be modifying the 
 windowX
  and 
 windowY
  values to create a panning effect. 
 Example 4-11
  demonstrates how to get 
 the image onto the canvas with the window location set to 
 0
 ,
 0
 . 
 Figure 4-12
  shows 
 an ex-ample of the output for 
 Example 4-11
 .",NA
Panning the Image,"To pan the window across the image, we simply need to modify the 
 windowX
  and 
 windowY
  coordinates. In 
 Example 4-12
 , we will modify the 
 windowX
  coordinate 
 inside a frame tick interval. During each loop iteration, we will increase the value of 
 windowX
  by 
 10
 . We need to be careful not to go off the far right side of the image, so 
 we will subtract the 
 windowWidth
  from the 
 image.width
 , and use the result as the 
 maximum 
 windowX 
 position:
  
 windowX+ = 10; 
  
 if (windowX>photo.width - windowWidth){
  
  windowX = photo.width - windowWidth; 
  
 }
  
 Example 4-12
  contains the changes necessary to perform this panning operation.
  
 Example 4-12. Simple image panning
  
 var photo = new Image(); 
  
 photo.addEventListener('load', eventPhotoLoaded , false);
  
 photo.src = ""butterfly.jpg"";
  
 var windowWidth = 500; 
  
 var windowHeight = 500;
  
 var windowX = 0; 
  
 var windowY = 0;
  
 function eventPhotoLoaded() {
  
  
  startUp(); 
  
 }
  
 function drawScreen(){
  
  context.drawImage(photo, windowX, windowY, windowWidth, windowHeight,
  
  
 0,0,windowWidth,windowHeight);
  
  windowX += 10;
  
  if (windowX>photo.width - windowWidth){
  
  
  windowX = photo.width - windowWidth;
  
  }
  
 }
  
 function startUp(){
  
 }
  
  setInterval(drawScreen, 100 );
  
 When you test 
 Example 4-12
 , you will see the window pan across the image and 
 stop at the rightmost edge. Next, we will start to implement zooming into this 
 simple example.
  
 152 | Chapter 4:Images on the Canvas",NA
Zoom and Pan the Image,"To zoom in or out of an image, we need to change the final 
 width
  and 
 height
  values 
 of the 
 drawImage()
  function. Let’s examine how we would zoom out to 50% of the 
 original size of the image while panning at the same time. The 
 drawImage()
  function 
 will look like this:
  
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight,
  
  0, 
 0, windowWidth*.5,windowHeight*.5);
  
 Example 4-13
  modifies 
 Example 4-12
  and adds in the 50% zoom.
  
 Example 4-13. Pan an image with a preset zoom out
  
 var photo = new Image(); 
  
 photo.addEventListener('load', eventPhotoLoaded , false);
  
 photo.src = ""butterfly.jpg""; 
  
 var windowWidth = 500; 
  
 var windowHeight = 500;
  
 var windowX = 0; 
  
 var windowY = 0;
  
 function eventPhotoLoaded() {
  
  
  startUp(); 
  
 }
  
 function drawScreen(){
  
  context.drawImage(photo, windowX, windowY, windowWidth, windowHeight,
  
  
 0,0,windowWidth*.5,windowHeight*.5);
  
  windowX += 10;
  
  if (windowX>photo.width - windowWidth){
  
  
  windowX = photo.width - windowWidth;
  
  }
  
 }
  
 function startUp(){
  
 }
  
  setInterval(drawScreen, 100 );
  
 When we test this example, we will see that when zoomed out, the image on the 
 canvas is 50% of its original size. To zoom in, we simply change the scale factor 
 from 
 .5
  to a number greater than 
 1
 :
  
 context.drawImage(photo, windowX, windowY, windowWidth,windowHeight,
  
  
 0,0,windowWidth*2,windowHeight*2);
  
 Example 4-14
  changes this single line from 
 Example 4-13
  to zoom in rather than 
 zoom out.
  
 Zooming and Panning an Image | 153",NA
Application: Controlled Pan and Zoom,"Our final example for this section will be a simple application allowing the user to 
 zoom and pan a photo.
  
 The zoom scale
  
 We are going to create a set of variables to handle the current zoom scale, the factor 
 by which the zoom scale is increased or decreased, as well as the maximum and 
 minimum zoom values:
  
 var currentScale = .5; 
  
 var minScale = .2 
  
 var maxScale = 3; 
  
 var scaleIncrement = .1;
  
 We will apply these values to the 
 drawImage()
  function:
  
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight,
  
  
 0,0,windowWidth*currentScale,windowHeight*currentScale);
  
 154 | Chapter 4:Images on the Canvas",NA
Pixel Manipulation,"In this section, we will first examine the Canvas Pixel Manipulation API, and then 
 build a simple application demonstrating how to manipulate pixels on the canvas in 
 real time.",NA
The Canvas Pixel Manipulation API,"The Canvas Pixel Manipulation API gives us the ability to “get,” “put,” and 
 “change”individual pixels utilizing what is known as the 
 CanvasPixelArray
  interface. 
 ImageData 
 is the base object type for this manipulation, and an instance of this 
 object is created with the 
 createImageData()
  function call. Let’s start there.
  
 The 
 createImageData()
  function sets aside a portion of memory to store individual 
 pixels’ worth of data based on the following three constructors:
  
 imagedata = context.
 createImageData
 (sw, sh) 
  
 The 
 sw
  and 
 sh
  parameters represent the 
 width
  and 
 height
  values for the 
 Image 
 Data
  object. For example, 
 imagedata=createImageData(100,100)
  would create a 
 100×100 area of memory in which to store pixel data.
  
 imagedata = context.
 createImageData
 (imagedata) 
  
 The 
 imagedata
  parameter represents a separate instance of 
 ImageData
 . This con-
 structor creates a new 
 ImageData
  object with the same width and height as the 
 parameter 
 ImageData
 .
  
 imagedata = context.
 createImageData
 () 
  
  
 This constructor returns a blank 
 ImageData
  
 instance.
  
 ImageData attributes
  
 An 
 ImageData
  object contains three attributes:
  
 ImageData.height 
  
  
 This returns the height in pixels of the 
 ImageData
  instance.
  
 ImageData.width 
  
  
 This returns the width in pixels of the 
 ImageData
  instance.",NA
Application Tile Stamper,"We are going to create a simple application that will allow the user to highlight a 
 box around some pixels on an image, copy them, and then use them as a stamp to 
 paint back to the canvas. It will not be a full-blown editing application by any 
 means—it’s just a demonstration of one use of the 
 ImageData
  object.
  
 Pixel Manipulation | 159",NA
Copying from One Canvas to Another,"The canvas allows us to use another canvas as the source of a bitmap drawing 
 operation. Let’s take a quick look at how we might utilize this functionality.
  
 We will need to modify the base file for this chapter and create an extra 
 <canvas>
  
 tag in our HTML. We will name this extra 
 <canvas>
  element 
 canvas2
  (it can be given 
 any id as long as it is not the same id as the first 
 <canvas>
 ). Here is what our HTML 
 <body>
  will look like now:
  
 <body> 
  
 <div> 
  
 <canvas id=""canvas"" width=""256"" height=""256""  style=""position: absolute; 
  
  top: 50px; left: 
 50px;"">Your browser does not support HTML5 Canvas.</canvas> <canvas id=""canvas2"" 
 width=""32"" height=""32""  style=""position: absolute; 
  
  
  top: 256px; left: 50px;"">Your browser does not support HTML5 Canvas.</canvas> </div> 
  
 </body>
  
 We will place the second 
 <canvas>
  below the original, and give it a 
 width
  and 
 height
  
 of 
 32
 . We will also need to create a new context and internal reference variable for 
 can vas2
 . Here is the code that will be used to provide a reference to both 
 <canvas>
  
 elements:
  
 if (!canvasSupport()) {
  
  
  return;
  
 166 | Chapter 4:Images on the Canvas",NA
What’s Next,"We covered quite a lot in this chapter, evolving from simply loading images to 
 animat-ing and rotating them. We looked at using tile sheets and tile maps, and 
 then we built some useful applications with Canvas image functions and 
 capabilities. In the first four chapters, we covered most of what Canvas offers as a 
 drawing surface. In the next six chapters, we will cover some more advanced topics, 
 such as applying 2D physics to 
 Canvas
  objects, integrating the HTML5 
 <video>
  and 
 <audio>
  tags with the 
 <canvas>
  tag, creating games, and looking at some libraries 
 and features that we can use to extend the functionality of HTML5 Canvas, even 
 creating applications for mobile devices.
  
 What’s Next | 169",NA
CHAPTER 5,NA,NA
"Math, Physics, and ",NA,NA
Animation,"Impressing users with animation involves more than knowing how to move 
 objects—you also need to know how to move them in ways that users expect. That 
 requires understanding some common algorithms for math-based movement and 
 physics in-teractions. Simple movement based on points and vectors provides a 
 foundation, and then it’s time to create objects that bounce off walls and one 
 another with a bit of friction added to the mix. After that, we will step back and talk 
 about movement that goes beyond straight lines: circles, spirals, and complex 
 Bezier curves. We will then cover how adding gravity can affect movement. Finally, 
 we will finish this chapter by dis-cussing easing and how it can have a positive 
 effect on math-based animations.",NA
Moving in a Straight Line,"For the simplest kinds of animations—moving objects in a straight line up and 
 down the canvas—this can take the form of adding a constant value to the 
 x
  or 
 y
  
 position of an object every time it is drawn.
  
 So, to animate graphics, we will need to create an interval and then call a function 
 that will display our updated graphics on every frame. Each example in this chapter 
 will be built in a similar way. The first step is to set up the necessary variables in 
 our 
 canvasApp()
  function. For this first, basic example of movement, we will create a 
 vari-able named 
 speed
 . We will apply this value to the 
 y
  position of our object on 
 every call to 
 drawScreen()
 . The 
 x
  and 
 y
  variables set up the initial position of the 
 object (a filled circle) we will move down the canvas:
  
 var speed = 5; 
  
 var y = 10; 
  
 var x = 250;
  
 After we create the variables, we set up an interval to call the 
 drawScreen()
  function 
 every 33 milliseconds. This is the loop we need to update our objects and move 
 them around the canvas:
  
 setInterval(drawScreen, 33);",NA
Moving Between Two Points: The Distance of a Line,"Movement based on constant changes to the 
 x
  or 
 y
  position of an object works well 
 for some applications, but other times you will need to be more precise. One such 
 instance is when you need to move an object from point A to point B at a constant 
 rate of speed.
  
 In mathematics, a common way to find the length of an unknown line is to use the 
 Pythagorean theorem:
  
 A
 2
  + B
 2
  = C
 2
  
 In this equation, C is the unknown side of a triangle when A and B are already 
 known. However, we need to translate this equation into something we can use 
 with the points and pixels we have available on the canvas.
  
 This is a good example of using a mathematical equation in your application. In this 
 case, we want to find the distance of a line, given two points. In English, this 
 equation reads like this:
  
 The distance equals the square root of the square of the difference between the 
 x
  
 value of the second point minus the 
 x
  value of the first point, plus the square of the 
 difference between the 
 y
  value of the second point minus the 
 y
  value of the first 
 point.
  
 You can see this in 
 Equation 5-1
 . It’s much easier to understand in this format.
  
 Equation 5-1. Distance equation
  
  
 In the second example, we need to create some new variables in the 
 canvasApp()
  
 func-tion. We will still use a 
 speed
  variable, just like in the first example, but this 
 time we set it to 
 5
 , which means it will move 
 5
  pixels on every call to 
 drawScreen()
 :
  
 var speed = 5;
  
 We then create a couple dynamic objects—each with an 
 x
  and a 
 y
  property—that 
 will represent the two points we want to move between. For this example, we will 
 move our circle from 
 20
 ,
 250
  to 
 480
 ,
 250
 :
  
 var p1 = {x:20,y:250}; 
  
 var p2 = {x:480,y:250};
  
 Now it is time to re-create the distance equation in 
 Equation 5-1
 . The first step is to 
 calculate the differences between the second and first 
 x
  and 
 y
  points:
  
 var dx = p2.x - p1.x; 
  
 var dy = p2.y - p1.y;",NA
Moving on a Vector,"Moving between two points is handy, but sometimes you don’t have a point to 
 move to, only a point to start from. In cases like this, it can be very useful to create a 
 vector 
 as a means to move your object.
  
 A 
 vector
  is a quantity in physics that has both magnitude and direction. For our pur-
 poses, the magnitude will be the 
 speed
  of the moving object, and the direction will 
 be an 
 angle
  that the object will move upon.
  
 The good news is that moving on a vector is very similar to moving between two 
 points. In 
 canvasApp()
 , we first set our 
 speed
  (magnitude). This is the number of 
 pixels the object will move on every call to 
 drawScreen()
 . We will set this to 
 5
 . We 
 will also set the starting point (
 p1
 ) for the object to 
 20
 ,
 20
 :
  
 var speed = 5; 
  
 var p1 = {x:20,y:20};
  
 Now, we will set the 
 angle
  (direction) of movement for our object to 
 45
  degrees. In 
 mathematics, a flat, straight line usually represents the 0 angle, which means a 
 vector with an angle of 45 degrees would be down and to the right on the canvas.
  
 With our angle set, we now need to convert it to radians. Radians are a standard 
 unit of angle measurement, and most mathematical calculations require you to 
 convert an angle into radians before you can use it.
  
 So why not just use radians and forget degrees altogether? Because it is much 
 easier to understand movement in degrees when working with vectors and moving 
 objects on a 2D surface. While a circle has 360 degrees, it has just about 6 radians, 
 which are cal-culated counterclockwise. This might make perfect sense to 
 mathematicians, but to move objects on a computer screen, angles are much easier. 
 So, we will work with
  
 Moving in a Straight Line | 179",NA
Bouncing Off Walls,"While it’s neat that we can create a vector with magnitude and direction and then 
 move an object along it infinitely, it’s probably not something you will need to do all 
 that often. Most of the time, you will want to see that object react to the world 
 around it by bouncing off horizontal and vertical walls, for example.
  
 To help you understand how to do this, there is a simple rule in physics. Although 
 this rule is usually applied to rays of light, it can be very useful when animating 2D 
 objects—especially when they are bouncing off horizontal and vertical walls. This 
 rule is known as 
 the angle of reflection
 :
  
 The angle of incidence is equal to the angle of reflection.
  
 The 
 angle of incidence
  is the angle an object is traveling when it hits the walls, and 
 the 
 angle of reflection
  is the angle it travels after it bounces off the wall.
  
 Figure 5-4
  illustrates that when an object hits a wall on a line that forms a 45-
 degree angle with a perpendicular line drawn to the point of impact, it will bounce 
 off (reflect) at a similar 45-degree angle.
  
 Bouncing Off Walls | 183",NA
Bouncing a Single Ball,"In this first example, we will create a ball traveling on a vector. We will set the 
 speed 
 (magnitude) to 
 5
  and the 
 angle
  (direction) to 
 35
  degrees. The rest of the variables 
 are identical to those in 
 Example 5-3
 . We are still moving on a vector, but now we 
 will test to see whether the ball hits a “wall” (the edges of the canvas), in which case 
 it will bounce off, using the rule of the angle of reflection. One big change from the 
 previous vector example is the location in which we initialize the values for 
 radians
 , 
 xunits
 , and 
 yunits
 . Instead of setting them up when we initialize the application in 
 canvasApp()
 , we save that for a call to a new function named 
 updateBall()
 :
  
 var speed = 5; 
  
 var p1 = {x:20,y:20}; 
  
 var angle = 35; 
  
 var radians = 0; 
  
 var xunits = 0; 
  
 var yunits = 0; 
  
 var ball = {x:p1.x, y:p1.y}; 
  
 updateBall();
  
 The 
 updateBall()
  function is called every time we set a new 
 angle
  for the ball, 
 because we need to recalculate the 
 radians
  and find new values for 
 xunits
  and 
 yunits
 . 
 A new 
 angle
  is generated when the app starts, as well as every time the ball bounces 
 off a wall:
  
 184 | Chapter 5:Math, Physics, and Animation",NA
Multiple Balls Bouncing Off Walls,"One ball is cool, but what about 100? Is the code 100 times more complicated? No, 
 not at all. In fact, the code is only slightly more complicated, but it is also more 
 refined. Most programming tasks that require only a single object of a type tend to 
 allow you to be a bit lazy. However, when you need to build an application that 
 must support 
 n 
 number of objects, you need to make sure the code will work in 
 many different cases.
  
 In the case of 100 balls bouncing on the canvas, we will need to create a ball object 
 with a few more properties. Recall that the ball object we created previously had 
 only 
 x
  and 
 y
  properties, and looked like this:
  
 var ball = {x:p1.x, y:p1.y};
  
 All the other variables that represented the ball (
 speed
 , 
 angle
 , 
 xunits
 , 
 yunits
 ) were 
 global in scope to the 
 canvasApp()
 . We used global variables because we could get 
 away with it. However, because we need to make sure everything works the same 
 way in this app, we make all those values properties of each ball object.
  
 For the multiple-ball-bounce application, we will create an object that holds all the 
 pertinent information about each bouncing ball: 
 x
 , 
 y
 , 
 speed
 , 
 angle
 , 
 xunits
 , and 
 yunits
 . 
 Because we are going to create 100 balls of various sizes, we also add a property 
 named 
 radius
 , which represents the size of the ball (well, half the size since it 
 is
  a 
 radius):
  
 tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, 
  
  angle:tempAngle, xunits:tempXunits, yunits:tempYunits}
  
 Inside 
 canvasApp()
 , we define some new variables to help manage the multiple balls 
 that will bounce around the canvas:
  
 numBalls 
  
  
 The number of balls to randomly create
  
 maxSize 
  
  
 The maximum radius length for any given ball
  
 minSize 
  
  
 The minimum radius length for any given ball
  
 maxSpeed 
  
  
 The maximum speed any ball can 
 travel
  
 balls 
  
  
 An array to hold all of the ball objects we will 
 create",NA
Multiple Balls Bouncing with a Dynamically Resized ,NA,NA
Canvas,"Before we move on to some more complex interaction among balls, let’s try one 
 more thing. Back in 
 Chapter 3
 , we resized the canvas with some HTML5 form 
 controls to display text in the center of the canvas. Well, let’s do the same thing now 
 with the ball example. This will give you a better idea of how we can make objects 
 interact with a dynamically resizing canvas.
  
 First, in the HTML, we create two HTML5 
 range
  controls, one for 
 width
  and one for 
 height
 , and set their maximum values to 
 1000
 . We will use these controls to set the 
 width and height of the canvas at runtime:
  
 Bouncing Off Walls | 193",NA
Multiple Balls Bouncing and Colliding,"Now it’s time to step it up again. Testing balls bouncing off walls is one thing, but 
 what about balls bouncing off one another? We will need to add some pretty 
 intricate code to handle this type of interaction.
  
 Ball interactions in physics
  
 For this example, we are going to create an 
 elastic collision
 , which means that the 
 total kinetic energy of the objects is the same before and after the collision. This is 
 known as the 
 law of conservation of momentum
  (Newton’s third law). To do this, we 
 will take the 
 x
  and 
 y
  velocities of two colliding balls, and draw a “line of action” 
 between their centers. This is illustrated in 
 Figure 5-8
 , which has been adapted 
 from Jobe Makar and Ben Winiarczyk’s 
 Macromedia’s Flash MX 2004 Game Design 
 Demystified
  (Macrome-dia Press). Then we will create new x and y velocities for 
 each ball based on this angle and the law of conservation of momentum.
  
 To properly calculate conservation of momentum when balls collide on the canvas, 
 we need to add a new property: 
 mass
 . Mass is the measurement of how much a ball 
 (or any object) resists any change in its velocity. Because collisions tend to change 
 the velocity of objects, this is an important addition to the ball objects we will use 
 on the canvas.
  
 198 | Chapter 5:Math, Physics, and Animation",NA
Multiple Balls Bouncing with Friction,"If we want the balls to slow down and eventually stop, we need to add friction to 
 Example 5-7
 . For our purposes, simple friction is a value we use to modify the 
 velocity of our objects every time they are drawn to the canvas.
  
 210 | Chapter 5:Math, Physics, and Animation",NA
Curve and Circular Movement,"Whew! Moving and colliding balls on vectors can create some cool effects. However, 
 moving in straight lines is not the only way you might want to move objects. In this 
 section, we will show you some ways to animate objects using circles, spirals, and 
 curves.
  
 216 | Chapter 5:Math, Physics, and Animation",NA
Uniform Circular Motion,"Uniform circular motion occurs when we move an object along the distinct radius 
 of a defined circle. Once we know the radius, we can use our old friends 
 cosine
  and 
 sine 
 to find the 
 x
  and 
 y
  locations of the moving object. The equations to find the 
 locations of an object moving uniformly on a defined circle are:
  
 x = radius * cosine(angle) 
  
 y = radius * sine(angle)
  
 We will create an example of uniform circular movement with a circle that has a 
 radius of 
 125
 , with its center position at 
 250
 ,
 250
  on the canvas. We will move a ball 
 along that circle, starting at an 
 angle
  of 
 0
 .
  
 In 
 canvasApp()
 , we will define this circle path as a dynamic object stored in the 
 circle
  
 variable. While this object defines the properties of a circle, we will not actually 
 draw this circle on the canvas; rather, it defines only the path on which we will 
 move our 
 ball
  object:
  
 var circle = {centerX:250, centerY:250, radius:125, angle:0} var ball = 
 {x:0, y:0,speed:.1};
  
 In 
 drawScreen()
 , we will incorporate the equations for uniform circular movement. 
 To do this, we will set the 
 x
  and 
 y
  properties of the 
 ball
  object to the products of the 
 equations, added to the center location of the circle path on the canvas (
 circle 
 .centerX
 , 
 circle.centerY
 ):
  
 ball.x = circle.centerX + Math.cos(circle.angle) * circle.radius; ball.y = 
 circle.centerY + Math.sin(circle.angle) * circle.radius;
  
 We then add the speed of the ball to the angle of the circle path. This effectively sets 
 the ball to move to a new location the next time 
 drawScreen()
  is called:
  
 circle.angle += ball.speed;
  
 Finally, we draw the ball onto the canvas:
  
 context.fillStyle = ""#000000""; 
  
 context.beginPath(); 
  
 context.arc(ball.x,ball.y,15,0,Math.PI*2,true); 
 context.closePath(); 
  
 context.fill();
  
 You can see what the circle path looks like in 
 Figure 5-12
 . We have drawn the 
 points on the canvas to illustrate the circle path.
  
 Curve and Circular Movement | 217",NA
Moving in a Simple Spiral,"There are many complicated ways to move an object on a spiral path. One such way 
 would be to use the Fibonacci sequence, which describes a pattern seen in nature 
 that appears to create perfect spirals. The Fibonacci sequence starts with the 
 number 0, and continues with each subsequent number calculated as the sum of the 
 two previous numbers in the sequence. Each subsequent rotation of the spiral is 
 the sum of the two previous numbers (1, 2, 3, 5, 8, 13, 21, 34, 55, 89...). However, as 
 you might imagine, the math used to create this sequence is quite involved, and it is 
 also difficult to translate to object movement.
  
 For our purposes, we can create a simple spiral by increasing the radius of the 
 circle path on each call to 
 drawScreen()
 . If we take the code from 
 Example 5-9
 , we 
 would add a 
 radiusInc
  variable, which we will use as the value to add the radius 
 movement path of the circle. We create this new variable in 
 canvasApp()
 :
  
 var radiusInc = 2;
  
 Then, in 
 drawScreen()
 , we add the following code to increase the radius of the circle 
 every time we move the object:
  
 circle.radius += radiusInc;
  
 In 
 Figure 5-13
 , you can see what the resulting spiral looks like (to illustrate the 
 path, this example includes the points).
  
 If you want a tighter spiral, decrease the value of 
 radiusInc
 . Conversely, if you want a 
 wider spiral, increase the value of 
 radiusInc
 .
  
 Example 5-10
  shows the code for 
 CH5EX10.html
  from the code distribution.
  
 220 | Chapter 5:Math, Physics, and Animation",NA
Cubic Bezier Curve Movement,"Cubic Bezier curves can be used to define a movement path for an object. Pierre 
 Bezier first popularized these curves in the 1960s. They are widely used in 2D 
 vector graphics to define smooth curves for drawing, but they can also be used in 
 animation to define a path for motion.
  
 A cubic Bezier curve is created using four distinct points—
 p0
 , 
 p1
 , 
 p2
 , and 
 p3
 :
  
 p0 
  
  
 The starting point of the curve. We will refer to these 
 x
  and 
 y
  values as 
 x0
  and 
 y0
 .
  
 p3 
  
  
 The ending point of the curve. We will refer to these 
 x
  and 
 y
  values as 
 x3
  and 
 y3
 .
  
 p1
  and 
 p2 
  
 The control points for the curve. The curve 
 does not pass through
  these points; 
 instead, the equation uses these points to determine the arc of the curve. We 
 will refer to these 
 x
  and 
 y
  values as 
 x0
 , 
 x1
 , 
 x2
 , 
 x3
 , 
 y0
 , 
 y1
 , 
 y2
 , and 
 y3
 .
  
  
 The usage of the 
 p1
  and 
 p2
  points is the biggest stumbling block for 
 understanding Bezier curves. The easiest way to understand the 
 rela-tionship between these points and the curve is to draw them on 
 a bitmapped canvas, which we will do several times in this chapter.
  
 After you have the four points, you need to calculate six coefficient values that you 
 will use to find the 
 x
  and 
 y
  locations as you move an object on the curve. These 
 coefficients are known as 
 ax
 , 
 bx
 , 
 cx
 , 
 ay
 , 
 by
 , and 
 cy
 . They are calculated as follows:
  
 cx = 3 (x1 - x0) 
  
 bx = 3 (x2 - x1) - cx 
  
 ax = x3 - x0 - cx - bx 
  
 cy = 3 (y1 - y0) 
  
 by = 3 (y2 - y1) - cy 
  
 ay = y3 - y0 - cy - by
  
 After you’ve calculated the six coefficients, you can find the 
 x
  and 
 y
  locations based 
 on the changing 
 t
  value using the following equations. The 
 t
  value represents 
 movement over time:
  
 x(t) = axt3 + bxt2 + cxt + x0 
  
 y(t) = ayt3 + byt2 + cyt + y0
  
 Curve and Circular Movement | 223",NA
Moving an Image,"Moving an image on a cubic Bezier curve path is just as easy as moving a circular 
 drawing object, as we’ll demonstrate in the next two examples. Suppose you are 
 making a game where bullseyes move across the canvas and the player must shoot 
 at them. You could use cubic Bezier curve paths to create new and interesting 
 patterns for the bullseyes to move along.
  
 For this example, we first create a global variable named 
 bullseye
 , which we will use 
 to hold the 
 bullseye.png
  image that we will load to display on the canvas:
  
 var bullseye; 
  
 function eventWindowLoaded() {
  
  
  bullseye = new Image();
  
  
  bullseye.src = ""bullseye.png""
  
  
  bullseye.onload = eventAssetsLoaded; 
  
 }
  
 In 
 canvasApp()
 , we will create a different path for the curve from the one in the first 
 example by setting new values for 
 p0
 , 
 p1
 , 
 p2
 , and 
 p3
 . Using these values, the 
 bullseye 
 will move on a parabola-like path (
 Figure 5-15
  shows the path of the curve):
  
 var p0 = {x:60, y:10}; 
  
 var p1 = {x:150, y:350}; 
  
 var p2 = {x:300, y:375}; 
  
 var p3 = {x:400, y:20};
  
 228 | Chapter 5:Math, Physics, and Animation",NA
Creating a Cubic Bezier Curve Loop,"You can create some very interesting paths using the four points in a cubic Bezier 
 curve. One such effect is a loop. To create a loop, you need to make sure the points 
 form an X, with 
 p0
  diagonal from 
 p1
 , and 
 p2
  and 
 p3
  on an opposite diagonal from 
 the other two points. 
 p0
  and 
 p3
  must be closer to the center of the canvas than 
 p1
  or 
 p2
 . Below are the points we will use to create this effect in 
 Example 5-13
 :
  
 var p0 = {x:150, y:440; 
  
 var p1 = {x:450, y:10}; 
  
 var p2 = {x:50, y:10}; 
  
 var p3 = {x:325, y:450};
  
 Since it is much easier to show than tell when it comes to cubic Bezier curves, look 
 at 
 Figure 5-16
 . It shows what the looping curve looks like when 
 Example 5-13
  is 
 executed in a web browser.
  
  
 This effect can only be created with the four points of a cubic Bezier 
 curve. There is also a three-point Bezier curve known as a quadratic 
 Bezier curve. You cannot create loops or S curves with quadratic 
 Bezier curves because the three points are not as precise as the four 
 points of
  
 a cubic Bezier curve.
  
 232 | Chapter 5:Math, Physics, and Animation",NA
"Simple Gravity, Elasticity, and Friction","Adding simulated gravity, elasticity, and friction to your objects adds a sense of 
 realism that otherwise would not exist in 2D. These properties are major forces in 
 nature that people feel and understand at nearly every moment of their lives. This 
 means that people who play games expect objects to act in a particular way when 
 these properties are applied. Our job is to simulate those effects as closely as 
 possible, while minimizing the processing power necessary to create them. While 
 there are some very complicated physics equations we could use to create these 
 effects, we will use simplified versions that work well with the limited resources 
 available to HTML5 Canvas in a web browser.",NA
Simple Gravity,"A very simple, yet seemingly realistic gravitational effect can be achieved by 
 applying a constant gravity value to the 
 y
  velocity of an object moving on a vector. 
 To do this, select a value for gravity, such as 
 .1
 , and then add that value to the 
 y
  
 velocity of your object on every call to 
 drawScreen()
 .
  
 For this example, let’s simulate a ball with a 
 radius
  of 
 15
  pixels being shot from a 
 cannon that rests near the bottom of the canvas. The ball will move at a 
 speed
  of 
 4
  
 pixels per frame, with an 
 angle
  of 
 305
  degrees. This means it will move up and to the 
 right on the canvas. If we did not apply any gravity, the ball would simply keep 
 moving on that vector until it left the canvas (actually, it would keep moving, we 
 just would not see it any longer).
  
 236 | Chapter 5:Math, Physics, and Animation",NA
Simple Gravity with a Bounce,"The last example showed what a cannonball might look like if it was shot out, 
 landed on a surface, and stuck there with no reaction. However, even a heavy 
 cannonball will bounce when it hits the ground.
  
 To create a bouncing effect we do not have to change the code very much at all. In 
 drawScreen()
 , we first apply 
 gravity
  on every frame; then, instead of stopping the ball 
 if it hits the bottom of the canvas, we simply need to reverse the 
 y
  velocity of 
 ball
  
 when it hits the ground.
  
 In 
 CH5EX14.html
  you would replace this code…
  
 if (ball.y + ball.radius <= theCanvas.height) {
  
  
 ball.velocityy += gravity; 
  
 } else {
  
  
  ball.velocityx = 0;
  
  
  ball.velocityy = 0;
  
  
  ball.y = theCanvas.height - ball.radius; }
  
 …with this:
  
 ball.velocityy += gravity; 
  
 if ((ball.y + ball.radius) > theCanvas.height) {
  
  
 ball.velocityy = -(ball.velocityy) 
  
 }
  
 This code will send the ball bouncing back “up” the canvas. Since it is still traveling 
 on the vector, and gravity is applied every time 
 drawScreen()
  is called, the ball will 
 even-tually come down again as the applied 
 gravity
  overtakes the reversed 
 y
  
 velocity.
  
 Figure 5-18
  shows what the cannonball looks like when the bounce is applied.
  
 240 | Chapter 5:Math, Physics, and Animation",NA
Gravity with Bounce and Applied Simple Elasticity,"In physics, the 
 elasticity
  of a bouncing ball refers to how much energy is conserved 
 when a ball bounces off a surface. We already covered a bit about conservation of 
 energy when we discussed balls colliding, but when we are simulating objects 
 falling, we need to take a slightly different path with our code. In 
 Example 5-15
 , we 
 applied 100% elasticity and the ball bounced forever (actually, this was only 
 implied since we did not consider elasticity at all). However, in real life, balls 
 usually lose some of their energy every time they bounce off a surface. The amount 
 of energy conserved depends on the material the ball is made from, as well as the 
 surface it is bouncing on. For example, a rubber Super Ball is much more elastic 
 than a cannonball and will bounce higher on the first bounce off a surface. Both will 
 bounce higher off a concrete surface than a surface made of thick mud. Eventually, 
 both will come to rest on the surface as all the energy is transferred away from the 
 ball.
  
 We can simulate simple elasticity by applying a constant value to the ball when it 
 bounces off the ground. For this example, we will set the 
 speed
  of the ball to 
 6
  pixels 
 per frame, and the 
 angle
  to 
 285
 . We will keep our 
 gravity
  at 
 .1
 , but set a new variable 
 named 
 elasticity
  to 
 .5
 . To make this more straightforward, we will also assume that 
 the surface the ball is bouncing on does not add or subtract from the elasticity of 
 the ball.
  
 In 
 canvasApp()
  we would set the new properties like this:
  
 var speed = 6; 
  
 var gravity = .1; 
  
 var elasticity = .5; 
  
 var angle = 285;
  
 We then add the new 
 elasticity
  property to the 
 ball
  object because, unlike 
 gravity
 , 
 elasticity describes a property of an object, not the entire world it resides within. 
 This means that having multiple balls with different values for elasticity would be 
 very easy to implement:
  
 var ball = {x:p1.x, y:p1.y, velocityx: vx, velocityy:vy, radius:radius, 
  
  elasticity: 
 elasticity};",NA
"Simple Gravity, Simple Elasticity, and Simple ",NA,NA
Friction,"Now that we have a ball traveling on a vector that is affected by both gravity and 
 elasticity, we have one more element to add to make the animation more realistic. 
 In the previous example, the 
 y
  velocity was affected by gravity and elasticity, but 
 the ball still traveled on the x-axis without any degradation in velocity. We will fix 
 this issue now by adding friction into the equation.
  
 In physics, 
 friction
  is a force that resists the motion of an object. We have already 
 discussed friction as it applies to colliding balls, and this implementation is similar 
 except that it affects only the 
 x
  velocity. For our purposes, we will achieve simple 
 friction by degrading the 
 x
  velocity as gravity degrades the 
 y
  velocity.
  
 Taking the code from 
 Example 5-16
 , in 
 canvasApp()
  we create a new variable named 
 friction
 . This is the amount of pixels to degrade the 
 x
  velocity on every frame:
  
 var friction = .008;
  
 246 | Chapter 5:Math, Physics, and Animation",NA
Easing,"Easing
  is a technique used in animation to make an object smoothly enter or leave a 
 location. The idea of easing is that instead of uniformly applying movement to 
 every frame of animation, you instead increase (
 easing in
 ) or decrease (
 easing out
 ) 
 the number of pixels you move on each frame. The result is that movement appears 
 to be more realistic and smooth. There are many different ways to create easing 
 animations. We will concentrate on two simple examples that will help pave the 
 way for you to further explore the subject on your own.",NA
Easing Out (Landing the Ship),"The process of easing out refers to easing at the end of an animation: an object 
 moving from one point to another, starting out fast, and slowing down as it reaches 
 the second point. To illustrate the concept, we will use the example of a spaceship 
 landing. A spaceship starts out very fast, applies negative thrust to slow down, and, 
 by the time it reaches the ground, is moving slowly enough to land without 
 incident. If you’ve ever played the video game 
 Lunar Lander
 , you will understand 
 exactly the type of movement we are trying to accomplish.
  
 Easing | 249",NA
Easing In (Taking Off),"Easing in is the opposite of easing out. When an animation 
 eases in
 , it starts slowly 
 and then gets faster and faster. If you have ever seen a video of a space shuttle 
 taking off, you will understand this much better. The thrust builds up as the craft 
 moves slowly, and then gets faster and faster as it moves through the sky. We are 
 going to use this“taking off” example as a way to develop code for an easing-in 
 animation on HTML5 Canvas.
  
 In 
 canvasApp()
 , we start our code much the same way as in the last example—by 
 cre-ating a variable named 
 easeValue
 :
  
 var easeValue = .05;
  
 However, for easing in, instead of this being a percentage of the remaining distance 
 between two points, it is simply a constant value added to the velocity of the ship 
 on each frame. 
 Figure 5-22
  shows what this would look like. We have added the 
 points again to illustrate how the animation speeds up as the ship takes off.
  
 Easing | 253",NA
What’s Next?,"We have shown you a plethora of examples for how you can use HTML5 Canvas to 
 animate objects using some basic principles of math and physics. However, we have 
 really only begun to scratch the surface of the multitude of ways you can use math 
 and physics in your applications. In the next couple chapters we will switch gears, 
 discus-sing audio and video, before we start applying many of the concepts we have 
 learned in this book to a couple of in-depth game projects.
  
 What’s Next? | 257",NA
CHAPTER 6,NA,NA
Mixing HTML5 Video and ,NA,NA
Canvas,"Using the new 
 <video>
  tag, HTML5 lets sites show video directly in HTML without 
 needing any plug-in technologies. However, the simple 
 <video>
  tag opens up a 
 whole slew of complexities and opportunities for developers. While we can’t cover 
 everything related to video in this chapter, we will introduce you to the HTML5 
 <video>
  tag, and then show you ways in which video can be incorporated and 
 manipulated by HTML5 Canvas.",NA
HTML5 Video Support,"HTML5 specifies a new tag, 
 <video>
 , that allows developers to place video directly 
 in an HTML page. With a few simple options, you can autoplay, loop, and add 
 playback controls to the embedded video.
  
 First, let’s talk about video format support, which is a very complicated issue. Some 
 video formats are free, and others are licensed. Some formats look better than 
 others, some make smaller file sizes, and some are supported in one browser while 
 others are supported in a different browser. In this chapter we will concentrate on 
 three formats that either have broad support now or promise to have broad 
 support in the fu-ture:
  .ogg
 , 
 .mp4
 , and 
 .webm
 .
  
 We will discuss these video formats in terms of 
 video codecs
 . Each format uses one 
 or more 
 codecs
  to compress and decompress video. Codecs are usually the secret 
 sauce of a video format because compression is the key to making video that, in the 
 wild, can convert very large files into file sizes that can be easily transported on the 
 Internet.",NA
Theora + Vorbis = .ogg,"Theora (
 http://www.theora.org/
 ) is an open source, free video codec developed by 
 Xiph.org. Vorbis (
 http://www.vorbis.com
 ) is a free, open source audio codec that is 
 used in conjunction with Theora. Both Theora and Vorbis are stored in an 
 .ogg
  file. 
 .ogg
  files have the broadest support among traditional web browsers, but, 
 unfortunately, not on handheld devices. Many commercial companies (e.g., Apple) 
 have balked at using Theora/Vorbis because they are unsure whether somewhere, 
 someplace, someone might own a patent that covers part of the technology, and 
 thus they might get sued for using it.
  
  
 Sometimes technology companies get hit with what is known as a 
 sub-marine patent
 . This was a patent tactic—available up until 1995 
 in the U.S.—that allowed a filer to delay the publication of a patent. 
 Because patents were only enforceable for 17 years, if someone 
 filed one but
  
 delayed the publications, he could wait years (even decades) until 
 some-one else came up with the same idea, then hit that person with a 
 lawsuit.",NA
H.264 + $$$ = .mp4,"H.264 is a high-quality video standard that has received the backing of some very 
 big players, such as Apple, Adobe, and Microsoft. However, despite offering high-
 quality video, it only defines a standard—not a video codec. An organization named 
 MPEG LA owns the intellectual property, and they license it out to software and 
 hardware vendors. Many companies that have implemented H.264 have done so 
 with their own proprietary codecs. As a result, the varying codecs are incompatible 
 with one another, making this a tricky format to use across multiple platforms. 
 H.264 videos have the 
 .mp4
  extension. Most for-profit corporations have 
 implemented support for this format on their platforms, but the developers of open 
 source browsers like Firefox and Opera have not. In late 2010, Google dropped 
 H.264 support in Chrome in favor of WebM.",NA
VP8 + Vorbis = .webm,"WebM is a new open source video standard supported by Google, Adobe, Mozilla, 
 and Opera. It is based on the VP8 codec and includes Vorbis (just like Theora) as an 
 audio codec. When 
 YouTube.com
  announced they had converted many of their 
 videos to be HTML5-compatible, one of the formats they used was WebM. 
 Currently, only Google Chrome and Opera support WebM, but broader support 
 should be coming in the future.
  
 260 | Chapter 6:Mixing HTML5 Video and Canvas",NA
Combining All Three,"The examples in this chapter will introduce a strategy that may seem crazy at 
 first—using all three formats at once. While this might seem to be more work than 
 necessary, right now it is the only way to ensure broad support across as many 
 platforms as pos-sible. The HTML5 
 <video>
  tag allows us to specify multiple formats 
 for a single video, and this will help us achieve our goal of broad video support 
 when working with HTML5 Canvas.",NA
Converting Video Formats,"Before we get into some video demonstrations, we should discuss video 
 conversions. Since we are going to use 
 .ogg
 , 
 .mp4
 , and 
 .webm
  videos in all our 
 projects, we need to have a way to convert video to these formats. Converting video 
 can be a daunting task for someone unfamiliar with all the existing and competing 
 formats; luckily, there are some great free tools to help us do just that:
  
 Miro Video Converter (
 http://www.mirovideoconverter.com/
 ) 
  
 This application will quickly convert most video types to 
 .ogg
 , 
 .mp4
 , and 
 .webm
 . 
 It is available for both Windows and Mac.
  
 SUPER © (
 http://www.erightsoft.com/SUPER.html
 ) 
  
 This is a free video-conversion tool for Windows only that creates 
 .mp4
  and 
 .ogg 
 formats. If you can navigate through the maze of screens trying to sell you 
 other products, it can be very useful for video conversions.
  
 Converting Video Formats | 261",NA
Basic HTML5 Video Implementation,"In the 
 <video>
  tag’s most minimal implementation, it only requires a valid 
 src
  
 atrribute. For example, if we took a nifty little video of the waves crashing at Muir 
 Beach, Cali-fornia (just north of San Francisco), and we encoded it as an H.264 
 .mp4
  
 file, the code might look like this:
  
 <video src=""muirbeach.mp4"" />
  
  
 To see an example of this basic code, look at the 
 CH6EX1.html
  file in 
 the code distribution.
  
 There are many properties that can be set in an HTML5 video embed. These 
 properties are actually part of the 
 HTMLMediaElement
  interface, implemented by the 
 HTMLVideo Element
  object. Some of the more important properties include:
  
 src 
  
  
 The URL to the video that you want to play.
  
 autoplay 
  
  
 true
  or 
 false
 . Forces the video to play automatically when loaded.
  
 loop 
  
 true
  or 
 false
 . Loops the video back to the beginning when it has finished playing 
 (at the time of this writing, this did not work in Firefox).
  
 volume 
  
  
 A number between 0 and 1. Sets the volume level of the playing 
 video.
  
 poster 
  
  
 A URL to an image that will be shown while the video is loading.
  
 262 | Chapter 6:Mixing HTML5 Video and Canvas",NA
Plain-Vanilla Video Embed,"To demonstrate a plain-vanilla embed, we are going to work under our previously 
 established rules for video formats. We will use three formats because no one 
 format will work in every browser. We have created a version of the Muir Beach 
 video as a 
 .webm
 , an 
 .ogg
 , and a 
 .mp4
 . For the rest of this chapter, we will use all 
 three formats in all of our video embeds.
  
 Basic HTML5 Video Implementation | 263",NA
"Video with Controls, Loop, and Autoplay","While a video displayed without controls might suit your needs, most users expect 
 to see some way to control a video. Also, as the developer, you might want a video 
 to play automatically or loop back to the beginning when it finishes. All of these 
 things (if supported in the browser) are very easy to accomplish in HTML5.
  
 Adding controls, looping, and autoplay to an HTML5 video embed is simple. All you 
 need to do is specify the options 
 controls
 , 
 loop
 , and/or 
 autoplay
  in the 
 <video>
  tag, 
 like this:
  
 <video autoplay loop controls id=""thevideo"" width=""320"" height=""240"">
  
  <source src=""muirbeach.mp4"" type='video/mp4; codecs=""avc1.42E01E, mp4a.40.2""' > 
 <source src=""muirbeach.webm""type='video/webm; codecs=""vp8, vorbis""' >
  
  <source src=""muirbeach.ogg"" type='video/ogg; codecs=""theora, vorbis""'> 
  
 </video>
  
  
 As of this writing, 
 loop
  does not work in Firefox; however, support is 
 expected in version 4.0.
  
 The code to embed our Muir Beach video with controls, loop, and autoplay is in 
 CH6EX2.html
  in the code distribution. 
 Figure 6-2
  shows what a video with controls 
 looks like in Google Chrome.
  
 Basic HTML5 Video Implementation | 265",NA
Altering the Width and Height of the Video,"In our first example, we showed how you could embed a video without changing 
 the default width or height. However, there are many good reasons why you might 
 want to change the default width and height of a video in the HTML page, such as 
 fitting it into a particular part of the page, or enlarging it so it is easier to see. 
 Similar to embed-ding an image into HTML with the 
 <img>
  tag, a video will scale to 
 whatever 
 width
  and 
 height
  you provide in the 
 <video>
  tag. Also, like with the 
 <img>
  
 tag, this scale does not
  
 266 | Chapter 6:Mixing HTML5 Video and Canvas",NA
Preloading Video in JavaScript,"It is often necessary to preload a video before you do anything with it. This is 
 especially true when using video with HTML5 Canvas because many times what 
 you want to do goes beyond the simple act of playing the video.
  
 We are going to leverage the DOM and JavaScript to create a preload architecture 
 that can be reused and expanded upon. We are still not using Canvas, but this 
 process will lead directly to it.
  
 To do this, we must first embed the video in the HTML page in the same way we 
 have done previously in this chapter. However, this time, we are going to add 
 <div>
  
 with the id of 
 loadingStatus
 .
  
  
 In practice, you probably would not display the loading status on the 
 HTML page.
  
 This 
 <div>
  will report the percentage of the video that has loaded when we retrieve 
 it through JavaScript:
  
 Preloading Video in JavaScript | 271",NA
A Problem with Events and Embedded Video in ,NA,NA
HTML5,"Now that we have gone through this exercise, we have to give you some bad news. 
 While the code we presented for 
 CH6EX5.html
  works in most HTML5-compliant 
 web browsers, the code stopped working in Google Chrome as we finished up the 
 first draft of this book. This was upsetting because we used Chrome as our primary 
 platform when developing and testing all the book’s examples.
  
 With a bit of investigation, we discovered that Chrome was not firing the 
 canplay 
 through
  or 
 progress
  events. At the same time, Firefox removed the 
 load
  event. While 
 these were anecdotal occurrences, they lead to one common truth: 
 the HTML5
  
 274 | Chapter 6:Mixing HTML5 Video and Canvas",NA
Video and the Canvas,"The HTML 
 video
  object already has a 
 poster
  property for displaying an image before 
 the video starts to play, as well as functions to 
 autoplay
  and 
 loop
 . So why is it 
 necessary to preload the video? Well, as we alluded to in the previous section, 
 simply playing a video is one thing—manipulating it with HTML5 Canvas is quite 
 another. If you want to start manipulating video while it is displayed on the canvas, 
 you first need to make sure it is loaded.
  
 In this section, we will load video and then manipulate it in various ways so you can 
 see how powerful Canvas can be when it is mixed with other HTML5 elements.",NA
Displaying a Video on HTML5 Canvas,"First, we must learn the basics of displaying video on HTML5 Canvas. There are a 
 few important things to note that are not immediately obvious when you start 
 working with video and the canvas. We worked through them so you don’t have to 
 do it yourself (you’re welcome).
  
 Video must still be embedded in HTML
  
 Even though the video is only displayed on HTML5 Canvas, you still need a 
 <video> 
 tag in HTML. The key is to put the video in a 
 <div>
  (or a similar construct), and set 
 the 
 display
  CSS style property of that 
 <div>
  to 
 none
  in HTML. This will ensure that 
 while the video is loaded in the page, it is not displayed. If we wrote the code in 
 HTML, it might look like this:
  
 Video and the Canvas | 275",NA
HTML5 Video Properties,"We have already talked about some properties of 
 HTMLVideoElement
  (inherited 
 from 
 HTMLMediaElement
 ), but now that we have a video loaded onto the canvas, it 
 would be interesting to see them in action.
  
 In this example, we are going to display seven properties of a playing video, taken 
 from the 
 HTMLVideoElement
  object: 
 duration
 , 
 currentTime
 , 
 loop
 , 
 autoplay
 , 
 muted
 , 
 controls
 , and 
 volume
 . Of these, 
 duration
 , 
 loop
 , and 
 autoplay
  will not update because 
 they are set when the video is embedded. Also, since we call the 
 play()
  function of 
 the video after it is preloaded in JavaScript, 
 autoplay
  may be set to 
 false
 , but the 
 video will play anyway. The other properties will update as the video is played.
  
 To display these values on the canvas, we will draw them as text in the 
 drawScreen() 
 function called by 
 setInterval()
 . Below is the 
 drawScreen()
  that we have created to 
 display these values:
  
 function  drawScreen () {
  
  //Background
  
  context.fillStyle = '#ffffaa';
  
  context.fillRect(0, 0, theCanvas.width, theCanvas.height);
  
  //Box
  
  context.strokeStyle = '#000000';
  
  context.strokeRect(5,  5, theCanvas.width−10, theCanvas.height−10); //video
  
  context.drawImage(videoElement , 85, 30);
  
 Video and the Canvas | 281",NA
Video on the Canvas Examples,"In the last section, we learned that the video playing on the canvas and the video 
 em-bedded with the 
 <video>
  tag are, in fact, the same video. It took a lot more code 
 to play the video on the canvas than it did to embed and play the video in 
 JavaScript. So, this begs the question: 
 why load video onto the canvas at all?
  
 Well, sometimes simply displaying a video and playing it is not enough. You might 
 want events to occur as the video is playing, or perhaps you want to use 
 transformations on it, use it in a game, create custom video controls, or animate it 
 and move it on the canvas.
  
 The following five examples will show you in very specific detail why the canvas 
 can be an exciting way to display video.",NA
Using the currentTime Property to Create Video ,NA,NA
Events,"The first way we will use video in conjunction with Canvas is to use the 
 currentTime 
 property of a playing video to trigger events. Recall that the 
 currentTime
  property is 
 updated as the video plays, and it shows the video’s elapsed running time.
  
 For our example, we are going to create a dynamic object in JavaScript containing 
 the following properties:
  
 time 
  
  
 The elapsed time to trigger the 
 event
  
 message 
  
  
 A text message to display on the canvas
  
 x 
  
  
 The 
 x
  position of the text message
  
 y 
  
  
 The 
 y
  position of the text message
  
 First, we will create an array of these objects and place them into a variable named 
 messages
 . We will then create four events (messages that will appear) that will take 
 place at the elapsed 
 currentTime
  of 
 0
 , 
 1
 , 
 4
 , and 
 8
  seconds:
  
 var messages = new Array();
  
  messages[0] = {time:0,message:"""", x:0 ,y:0};
  
  messages[1] = {time:1,message:""This Is Muir Beach!"", x:90 ,y:200}; messages[2] 
 = {time:4,message:""Look At Those Waves!"", x:240 ,y:240}; messages[3] = 
 {time:8,message:""Look At Those Rocks!"", x:100 ,y:100};
  
 To display the messages, we will call a 
 for:next
  loop inside our 
 drawScreen()
  
 function. Inside the loop, we test each message in the 
 messages
  array to see whether 
 the 
 current Time
  property of the video is greater than the 
 time
  property of the 
 message. If so, we know that it is OK to display the message. We then display the 
 message on the canvas",NA
Canvas Video Transformations: Rotation,"Showing a static video on the screen is one thing, but transforming it on the screen 
 using alpha transparency and rotations is quite another. These types of 
 transformations can be easily applied to video on the canvas in much the same way 
 as you would apply them to an image or a drawing object.
  
 In this example, we will create a video that rotates clockwise. To achieve this effect, 
 we first create a variable, 
 rotation
 , which we will use to hold the current values of 
 the rotation property that we will apply to the video. We create this variable 
 outside of the 
 drawScreen()
  function, inside 
 canvasApp()
 :
  
 var rotation = 0;
  
 The 
 drawScreen()
  function is where all the real action takes place for this example. 
 First, we need to save the current canvas context so we can restore it after we 
 perform the transformation. We covered this in depth in 
 Chapter 2
 , but here’s a 
 quick refresher. Transformations on the canvas are global in nature, which means 
 they affect 
 every-thing
 . Since the canvas works in immediate mode, there is no stack 
 of objects to ma-nipulate. Instead, we need to save the canvas context before the 
 transformation, apply the transformation, and then restore the saved context 
 afterward.
  
 First, we save it:
  
 context.save();
  
 Next, we reset the context transformation to the identity, which clears anything that 
 was set previously:
  
 context.setTransform(1,0,0,1,0,0);
  
 Then we need to set up some variables that will be used for the rotation calculation. 
 The 
 x
  and 
 y
  variables set the upper-left location of the video on the canvas. The 
 video Width
  and 
 videoHeight
  variables will be used to help rotate the video from the 
 center:
  
 var x = 100; 
  
 var y = 100; 
  
 var videoWidth=320; 
  
 var videoHeight=240;
  
 Now it is time to use the 
 rotation
  variable, which represents the angle that we 
 rotated the video on the canvas. It starts at 
 0
 , and we will increase it every time 
 drawScreen() 
 is called. However, the 
 context.rotate()
  method requires an angle to be 
 converted to radians when passed as its lone parameter. The following line of code 
 converts the value in the 
 rotation
  variable to radians, and stores it in a variable 
 named 
 angleInRadians
 :
  
 var angleInRadians = rotation * Math.PI / 180;",NA
Canvas Video Puzzle ,"Now we arrive at the most involved example of this section. We are going to create 
 a puzzle game based on the video we have displayed on the canvas, illustrated in 
 Fig-ure 6-10
 . Here are the steps showing how the game will operate:
  
 1. We will load the video onto the canvas but not display it.
  
 2. We will decide how many parts we want to be in our puzzle.
  
 3. We will create a 
 board
  array that holds all the puzzle pieces.
  
 4. The pieces will be displayed in a 4×4 grid.
  
 5. We will randomize the pieces on the board to mix up the puzzle.
  
 6. We will add an event listener for the mouse button.
  
 7. We will set an interval to call 
 drawScreen()
 .
  
 8. We will wait for the user to click a puzzle piece.
  
 9. While we are waiting, the various parts of the video will play just as though they 
 were one video.
  
 10. When a user clicks a puzzle piece, it will highlight in yellow.
  
 11. If the user has selected two pieces, we will swap their positions.
  
 12. The user will attempt to put the puzzle back together so she can see the video as 
 it was created.
  
 Setting up the game
  
 To start, we are going to set up some variables that will define the game’s playfield. 
 Here is a rundown of the variables and how they will be used:
  
 rows 
  
  
 The numbers of rows in the grid of puzzle pieces 
  
 cols 
  
  
 The number of columns in the grid of puzzle pieces 
  
 xPad 
  
  
 The space, in pixels, between each column 
  
 yPad 
  
  
 The space, in pixels, between each row 
  
 startXOffset 
  
  
 The number of pixels from the left of the canvas to the location where we will 
 start 
  
 drawing the grid of puzzle pieces
  
 294 | Chapter 6:Mixing HTML5 Video and Canvas",NA
Creating Video Controls on the Canvas,"One obvious use of the HTML5 Canvas video display functionality is to create 
 custom video controls to play, pause, stop, etc. You may have already noticed that 
 when a video is rendered on the canvas, it does not retain any of the HTML5 video 
 controls. If you want to create controls on the canvas, you need to make them 
 yourself. Thankfully, we have already learned most everything we need to do this—
 now we just have to put it all together.
  
 Creating video buttons
  
 We are going to use some video control buttons that were created specifically for 
 this example. 
 Figure 6-11
  shows a tile sheet that consists of 
 off
  and 
 on
  states for 
 play, pause, and stop. The top row images are the on state; the bottom row images 
 are the off state.
  
  
 Figure 6-11. Video control button tile sheet
  
  
 We don’t use the off state of the stop button in this application, but 
 we included it in case you—the amazing reader and programmer 
 that you are—want to use it later.
  
 We will load this image dynamically onto the canvas, and then place each 32×32 
 button onto the canvas individually. We use the width and height to calculate which 
 part of the image to display as a control.
  
 Preloading the buttons
  
 The first thing we need to do is preload the button tile sheet. Since we are already 
 testing for the video to preload before we display the canvas, we need a slightly 
 new strategy to preload multiple objects. For this example, we will use a counter 
 variable named 
 loadCount
  that we will increment each time we detect that an item 
 has loaded. In con-junction with that variable, we will create another named 
 itemsToLoad
 , which will hold the number of things we are preloading. For this app 
 that number is two: the video and the tile sheet. These two variables are created 
 outside of all functions at the top of our JavaScript:
  
 var loadCount = 0; 
  
 var itemsToLoad = 2;
  
 Video on the Canvas Examples | 307",NA
Animation Revisited: Moving Videos,"Now we are going to revisit the bouncing balls demo from 
 Chapter 5
  to show you 
 how you can achieve the same effect with images and videos. Since we covered this 
 in detail in 
 Example 5-5
  (
 CH5EX5.html
 ), we don’t need to examine all the code—just 
 the changes that make the videos move.
  
  
 Remember that videos are drawn in much the same way as images, 
 so with very few changes this application would work just as well 
 with a static image.
  
 While there are a few other changes, the most important is in the 
 drawScreen()
  
 function when we draw the videos onto the canvas. Recall that in 
 Chapter 5
  we 
 created an array named 
 balls
  and a dynamic object to hold the properties of each 
 ball that looked like this:
  
 tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, 
  
  
 xunits:tempXunits, yunits:tempYunits}
  
 For videos, we will create a similar array, named 
 videos
 , but we will alter the 
 dynamic object:
  
 tempvideo = {x:tempX,y:tempY,width:180, height:120, speed:tempSpeed, angle:tempAngle, 
  
  
 xunits:tempXunits, yunits:tempYunits}
  
 The big difference here is that we no longer need a 
 radius
  that represents the size of 
 the ball; instead, we need the 
 width
  and 
 height
  so we can render the video to our 
 desired size in the 
 drawScreen()
  function.
  
 Back in 
 Chapter 5
  we used the canvas drawing command to draw balls on the screen 
 like this:
  
 context.beginPath(); 
  
 context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); 
 context.closePath(); 
  
 context.fill();
  
 To draw videos, we need to change the code:
  
 context.drawImage(videoElement, video.x, video.y, video.width, video.height);
  
 That is pretty much all you need to do! There are some others changes here (e.g., 
 we start all the videos in the center of the screen before they start moving), but the 
 items mentioned above are the main things you need to concentrate on to move 
 video, not yellow balls, around the screen. 
 Figure 6-13
  shows what the example 
 looks like with bouncing videos instead of balls. You can see the full code in 
 Example 6-12
 .
  
 316 | Chapter 6:Mixing HTML5 Video and Canvas",NA
What’s Next?,"In this chapter we introduced the HTML 
 <video>
  tag and showed some basic ways 
 that it could be used on an HTML page, including how to manipulate loaded video 
 in numerous ways. While we showed you how to do some pretty cool stuff with the 
 video and HTML5 Canvas, this is really just the tip of the iceberg. We believe that 
 these two very powerful and flexible new features of HTML5 (video and the 
 canvas) will prove to be a very potent combination for web applications of the 
 future. In the next chapter, we will dive into HTML5 audio and how it can be used 
 with applications created on the canvas.
  
 320 | Chapter 6:Mixing HTML5 Video and Canvas",NA
CHAPTER 7,NA,NA
Working with Audio,"You can’t physically manipulate audio with HTML5 Canvas as directly as you can 
 video, but many canvas applications can use that extra dimension of sound. Audio 
 is represented by the 
 HTMLAudioElement
  object manipulated through JavaScript, 
 and by the 
 <audio>
  tag in HTML5. There is no Canvas API for audio nor, really, is 
 one neces-sary. However, there are many ways that you might want to use audio 
 with HTML5 Canvas.",NA
The Basic <audio> Tag,"The basic usage of the 
 <audio>
  tag in HTML5 is very similar to that of the 
 <video>
  
 tag. The only required property is 
 src
 , which needs to point to an existing audio file 
 to play in the browser. Of course, it’s always nice to show some audio controls on 
 the page, and this can be accomplished using the 
 controls
  Boolean, just as we did 
 with 
 <video>
 .
  
 The code in 
 Example 7-1
  will load and play 
 song1.ogg
  in a web browser that sup-
 ports 
 .ogg
  file playback, as shown in 
 Figure 7-1
 . (Reminder: not all browsers 
 support all formats.)
  
 Example 7-1. Basic HTML5 audio
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH7EX1: Basic HTML5 Audio</title> 
  
 </head> 
  
 <body> 
  
 <div> 
  
 <audio src=""song1.ogg"" controls> 
  
 Your browser does not support the audio element.
  
 </audio> 
  
 </div> 
  
 </body> 
  
 </html>
  
 321",NA
Audio Formats,"Similar to video formats, which we learned about in 
 Chapter 6
 , not every web 
 browser supports every audio format. In fact, audio support appears to be in worse 
 shape than video. As you will soon discover in this chapter, audio is one place 
 where HTML5 needs some serious work. However, we will show you some 
 strategies and workarounds for making audio easier to use in your applications.",NA
Supported Formats,"Here is a quick chart to show you which audio formats are supported by which 
 brows-ers. We are not going to use version numbers here because we assume the 
 latest version of each product:
  
 Platform
  
 .ogg
  
 .mp3
  
 .wav
  
 Chrome
  
 X
  
 X
  
 X
  
 Firefox
  
 X
  
 Safari
  
 X
  
 X
  
 X
  
 Opera
  
 X
  
 Internet 
 Explorer 9
  
 X
  
 X
  
 The situation is much like that of the 
 <video>
  tag. To support 
 <audio>
  we will need 
 to use multiple separate formats for each piece of audio we want to play. To be on 
 the safe side, we will use three formats: 
 .mp3
 , 
 .ogg
 , and 
 .wav
 .",NA
Audacity,"Fortunately, there is a great free audio tool available that will help you convert 
 audio into any format. In our case, we need to convert to 
 .mp3
 , 
 .ogg
 , and 
 .wav
 .
  
 Audacity (
 http://audacity.sourceforge.net/
 ) is an open source, cross-platform 
 project designed to bring sophisticated audio editing to the desktop. The current 
 version works on Mac, Windows, and Linux.
  
 Figure 7-2
  shows a sample screen from Audacity. When you load a sound into 
 Audacity, it displays the waveform of the sound. You can manipulate the sound in 
 many ways, including trimming, splitting, and duplicating, and then add effects 
 such as fade, echo,
  
 322 | Chapter 7:Working with Audio",NA
Example: Using All Three Formats,"In 
 Example 7-2
 , we are going to embed a 40-second song, 
 song1
 , in an HTML5 page 
 and play it. To make sure 
 song1
  can play in as many browsers as possible, we are 
 going to embed it with three different sources. For this example, we are also going 
 to set the 
 autoplay
 , 
 loop
 , and 
 controls
  properties so the song will start automatically, 
 replay when it reaches the end, and display the default browser audio controls. 
 Here is the code to embed 
 song1
 :
  
 Audio Formats | 323",NA
"Audio Tag Properties, Functions, and ",NA,NA
Events,"Similar to the 
 <video>
  tag, the 
 <audio>
  tag in HTML5 is based on the 
 HTMLAudio 
 Element
  DOM object, which is derived from 
 HTMLMediaElement
 .",NA
Audio Functions,"load() 
  
  
 Starts loading the sound file specified by the 
 src
  property of the 
 <audio>
  
 tag.
  
 play() 
  
 Starts playing the sound file specified by the 
 src
  property of the 
 <audio>
  tag. If 
 the file is not ready, it will be loaded.
  
 pause() 
  
  
 Pauses the playing audio file.
  
 canPlayType() 
  
 Accepts a MIME type as a parameter, and returns the value 
 maybe
  or 
 probably
  if 
 the browser can play that type of audio file. It returns 
 “”
  (an empty string) if it 
 cannot.",NA
Important Audio Properties,"There are many properties defined for the 
 audio
  element in HTML5. We are going to 
 focus on the following because they are the most useful for the applications we will 
 build:
  
 duration 
  
  
 The total length, in seconds, of the sound represented by the 
 audio
  object.
  
 currentTime 
  
  
 The current playing position, in seconds, of the playing audio 
 file.
  
 loop 
  
 true
  or 
 false
 : whether the audio clip should start playing at the beginning when 
 currentTime
  reaches the 
 duration
 .
  
 autoplay 
  
 true
  or 
 false
 : whether the audio should start playing automatically when it has 
 loaded.
  
 muted 
  
 true
  or 
 false
 . Setting this to 
 true
  silences the 
 audio
  object regardless of 
 volume 
 settings
  
 controls 
  
 true
  or 
 false
 . Displays controls for an 
 audio
  object in an HTML page. Controls will 
 not display on the canvas unless they are created in HTML (for example, with a 
 <div>
  overlay).
  
 volume 
  
  
 The volume level of the 
 audio
  object; the value must be between 
 0
  and 
 1
 .
  
 paused 
  
 true
  or 
 false
 : whether the 
 audio
  object is paused. Set with a call to the 
 pause() 
 function.",NA
Important Audio Events,"Many events are defined for the HTML5 
 audio
  element. We are going to focus on the 
 following events because they have proven to work when building audio 
 applications:
  
 progress 
  
 Raised when the browser is retrieving data while loading the file. (This still has 
 spotty support in browsers, so be careful with it.)
  
 canplaythrough 
  
 Raised when the browser calculates that the media element could be played 
 from beginning to end if started immediately.
  
 playing 
  
  
 Set to 
 true
  when the audio is being played.
  
 volumechange 
  
  
 Set when either the 
 volume
  property or the 
 muted
  property 
 changes.
  
 ended 
  
 Set when playback reaches the 
 duration
  of the audio file and the file stops being 
 played.",NA
Loading and Playing the Audio,"We are going to use the 
 canplaythrough
  and 
 progress
  events to load 
 <audio>
  before 
 we try to play it. Here is how we embed the audio for 
 song1
 :
  
 <audio id=""theAudio"" controls> 
  
 <source src=""song1.mp3"" type=""audio/mp3""> 
  
 <source src=""song1.wav"" type=""audio/wav""> 
  
 <source src=""song1.ogg"" type=""audio/ogg""> 
  
 Your browser does not support the audio element.
  
 </audio>",NA
Displaying Attributes on the Canvas,"Now we are going to display the attribute values of an 
 audio
  element playing on an 
 HTML page. In this example (
 CH7EX3.html
 ), we are also going to display the 
 audio 
 element in the HTML page so you can see the relationship between what is shown 
 on the canvas and the state of the 
 <audio>
  tag in the page.
  
 In the 
 drawScreen()
  function we will add the following code to display the attributes 
 of the 
 audioElement
  variable:
  
 context.fillStyle = ""#000000""; 
  
 context.fillText  (""Duration:"" + audioElement.duration,  20 ,20); context.fillText  
 (""Current time:"" + audioElement.currentTime,  20 ,40); context.fillText  (""Loop: "" + 
 audioElement.loop,  20 ,60); 
  
 context.fillText  (""Autoplay: "" +audioElement.autoplay,  20 ,80); context.fillText  
 (""Muted: "" + audioElement.muted,  20 ,100); 
  
 context.fillText  (""Controls: "" + audioElement.controls,  20 ,120); context.fillText  
 (""Volume: "" + audioElement.volume,  20 ,140);
  
 Audio Tag Properties, Functions, and Events | 327",NA
Playing a Sound with No Audio Tag,"Now that we have a sound playing in an HTML5 page and we are tracking the 
 properties of the 
 audio
  element on the canvas, it is time to step up their integration. 
 The next step is to do away with the 
 <audio>
  tag embedded in the HTML page.
  
 If you recall from 
 Chapter 6
 , we created a 
 video
  element dynamically in the HTML 
 page and then used the 
 canPlayType()
  method of the 
 HTMLVideoElement
  object to 
 figure out what video file type to load for a particular browser. We will do 
 something very similar for audio.",NA
Dynamically Creating an Audio Element in ,NA,NA
JavaScript,"The first step to dynamically creating 
 audio
  elements is to create a global variable 
 named 
 audioElement
 . This variable will hold an instance of 
 HTMLAudioElement
  that 
 we will use in our canvas application. Recall that 
 audio
  elements in an HTML page 
 are instances of the 
 HTMLAudioElement
  DOM object. We refer to them as 
 audio
  
 objects when embed-ded in an HTML page, and as instances of 
 HTMLAudioElement
  
 when created dynamically in JavaScript. However, they are essentially the same.
  
  
 Don’t fret if you don’t like using global variables. By the end of this 
 chapter, we will show you a way to make these variables local to 
 your canvas application.
  
 Next, we create our event handler for the window 
 load
  event named 
 eventWindow 
 Loaded()
 . Inside that function, we call the 
 createElement()
  function of the DOM 
 document
  object, passing the value 
 audio
  as the type of element to create. This will 
 dynamically create an 
 audio
  object and put it into the DOM. By placing that object in 
 the 
 audioElement
  variable, we can then dynamically place it onto the HTML page 
 with a call to the 
 appendChild()
  method of the 
 document.body
  DOM object:
  
 window.addEventListener('load', eventWindowLoaded, false); var 
 audioElement; 
  
 function eventWindowLoaded() {
  
  
  audioElement = document.createElement(""audio"");
  
  
  document.body.appendChild(audioElement);
  
 However, just having a dynamically created 
 audio
  element is not enough. We also 
 need to set the 
 src
  attribute of the 
 HTMLAudioElement
  object represented by 
 audioElement
  to a valid audio file to load and play. But the problem is that we don’t 
 yet know what type of audio file the current browser supports. We will get that 
 information from a function we will create named 
 supportedAudioFormat()
 . We will 
 define this function so that it returns a string value representing the extension of 
 the file type we want to load. When we have that extension, we concatenate it with 
 the name of the sound we want to load, and set the 
 src
  with a call to the 
 setAttribute()
  method of the 
 HTMLAudioElement
  object:",NA
Finding the Supported Audio Format,"Before the code in the previous section will work, we need to define the 
 supported 
 AudioFormat()
  function. Since we are adding 
 audio
  objects dynamically to the HTML 
 page, we do not have a way to define multiple 
 <source>
  tags like we can in HTML. 
 Instead, we are going to use the 
 canPlayType()
  method of the 
 audio
  object to tell us 
 which type of audio file to load. We already introduced you to the 
 canPlayType() 
 method in 
 Chapter 6
 , but to refresh your memory, 
 canPlayType()
  takes a single 
 parameter—a MIME type. It returns a text string of 
 maybe
 , 
 probably
 , or “” (nothing). 
 We are going to use these values to figure out which media type to load and play. 
 Just like in 
 Chapter 6
 , and for the sake of this exercise, we are going to assume that 
 both 
 maybe
  and 
 probably
  equate to 
 yes
 . If we encounter either result with any of our 
 three MIME types (
 audio/ogg
 , 
 audio/wav
 , 
 audio/mp3
 ), we will return the extension 
 associated with that MIME type so the sound file can be loaded.
  
  
 The next function is essentially the same as the one we created in 
 Chap-ter 6
  to handle video formats. The obvious changes here are 
 with the MIME types for audio.
  
 In the function below, 
 audio
  represents the instance of 
 HTMLAudioElement
  that we 
 will test. The 
 returnExtension
  variable represents that valid extension for the first 
 MIME type found that has the value of 
 maybe
  or 
 probably
  returned:
  
 function supportedAudioFormat(audio) {
  
  
  var returnExtension = """";
  
  
  if (audio.canPlayType(""audio/ogg"") ==""probably"" || 
  
  
  audio.canPlayType(""audio/ogg"") == ""maybe"") {
  
   
  returnExtension = ""ogg"";
  
 332 | Chapter 7:Working with Audio",NA
Playing the Sound,"Finally, we get to the point where we can play a sound inside our 
 canvasApp()
  
 function. Since we preloaded the sound originally outside the context of this 
 function into a variable with a global scope, we just need to call the 
 play()
  function 
 audioElement
  to start playing the sound:
  
 audioElement.play();
  
 Figure 7-4
  shows what this canvas application will look like when executed in an 
 HTML5-compliant web browser (notice that we have left the display of the audio 
 properties in this application).
  
 Playing a Sound with No Audio Tag | 333",NA
"Look Ma, No Tag!","Now, check out the full application in 
 Example 7-4
 . Notice that there is no 
 <audio>
  
 tag defined in the HTML, but the sound still plays. This is our first step toward 
 integrating 
 HTMLAudioElement
  objects with HTML5 Canvas.
  
 Example 7-4. Playing a sound with no tag
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH7EX4: Playing A Sound With No Tag</title> 
  
 <script src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript""> 
  
 window.addEventListener('load', eventWindowLoaded, false); var 
 audioElement; 
  
 function eventWindowLoaded() {
  
  audioElement = document.createElement(""audio"");
  
  document.body.appendChild(audioElement);
  
  var audioType = supportedAudioFormat(audioElement);
  
  if (audioType == """") {
  
  
  alert(""no audio support"");
  
  
  return;
  
  }
  
  audioElement.setAttribute(""src"", ""song1."" + audioType);
  
  audioElement.addEventListener(""canplaythrough"",audioLoaded,false);
  
 }
  
 334 | Chapter 7:Working with Audio",NA
Creating a Canvas Audio Player,"Now that we can play an audio file directly in an HTML page using the 
 <audio>
  tag, 
 or through JavaScript by creating a dynamic 
 HTMLAudioElement
  object, it’s time to 
 step up our game. We are going to create an audio player on the canvas that we can 
 use to control dynamically loaded audio files. Why do we want to do this? Well, 
 while the audio controls baked into HTML5-compliant browsers might look decent, 
 it is often necessary for developers to implement a design that more closely 
 matches a particular website. HTML5 Canvas provides a way to create a dynamic 
 set of audio controls with nearly any look-and-feel you desire.
  
 However, this flexibility comes at a cost. HTML5 Canvas does not natively support 
 common GUI controls such as push buttons, toggle buttons, and sliders. So to create 
 a decent audio player, we need to make these types of GUI user controls from 
 scratch. We could create these controls in HTML and JavaScript, but we have 
 already covered communication between HTML and Canvas via form controls 
 several times in this book. You wanted to know how to make HTML5 Canvas apps 
 when you started read-ing, so we won’t pull any punches in this chapter.
  
 336 | Chapter 7:Working with Audio",NA
Creating Custom User Controls on the Canvas,"For this application we are going to create four elements:
  
 Play/pause push button 
  
 The audio file is either playing or is paused. Whichever state it is currently in, 
 we show the other button (i.e., show pause when playing).
  
 A sliding progress bar 
  
 This is a noninteractive slider. It displays how much of the audio track has 
 played and how much is left to play. The movement of this bar needs to be 
 dynamic and based on the 
 duration
  and 
 currentTime
  properties of the 
 HTMLAudioElement
  object.
  
 An interactive volume slider 
  
 We want to create a sliding volume control that the user can manipulate with a 
 click-and-drag operation. This is the trickiest control we will build because 
 Canvas has no native support for click-and-drag.
  
 A loop toggle button 
  
 This is a bonus. Most of the default embedded HTML5 audio players do not 
 have a loop/no-loop toggle button, but we are going to add one. Already, we are 
 out-stripping the functionality of standard HTML5!
  
 Figure 7-5
  shows the 
 audiocontrols.png
  image that we created. It holds all the 
 images we will use for the audio player. The top row consists of:
  
 • The play state of the play/pause button
  
 • The background of the play slider
  
 • The moving slider we will use for the play and volume sliders
  
 The second row consists of:
  
 • The pause state of the play/pause button
  
 • The background of the volume slider
  
 • The “off” state of the loop button
  
 • The “on” state of the loop button
  
  
 Figure 7-5. audiocontrols.png",NA
Loading the Button Assets,"Since we are going to load in both an audio file and an image file for this application, 
 we need to employ a strategy that will allow us to preload two assets instead of just
  
 Creating a Canvas Audio Player | 337",NA
Setting Up the Audio Player Values,"Inside the 
 canvasApp()
  function we need to create some values to help us place all 
 the various buttons and sliders on the canvas.
  
 First, 
 bH
  represents the height of all the controls; 
 bW
  represents the width of a 
 standard button (play/pause, loop/not loop):
  
 var bW = 32; 
  
 var bH = 32;
  
 Next, we set the width of the playback area, 
 playBackW
 , and the width of the volume 
 background, 
 volBackW
 . We also set the slider’s width (
 sliderW
 ) and height (
 sliderH
 ):
  
 var playBackW = 206; 
  
 var volBackW = 50; 
  
 var sliderW = 10; 
  
 var sliderH = 32;
  
 We also need a couple variables to represent the 
 x
  and 
 y
  locations on the canvas 
 where we will start to build our audio controls. We will define those as 
 controlStartX
  
 and 
 controlStartY
 :
  
 var controlStartX = 25; 
  
 var controlStartY = 200;
  
 Finally, we need to specify the 
 x
  and 
 y
  locations for the play/pause button (
 playX
 , 
 playY
 ), the playing slider background 
 (playBackX
 , 
 playBackY
 ), the volume slider back-
 ground (
 volBackX
 , 
 volBackY
 ), and the location of the loop/no loop toggle button 
 (
 loopX
 , 
 loopY
 ):
  
 var 
 playX 
 = 
 controlStartX; 
  
 var 
 playY 
 = 
 controlStartY; 
  
 var playBackX = controlStartX+bW
  
 Creating a Canvas Audio Player | 339",NA
Mouse Events,"Since we are going to create our own functions for interactivity between the mouse 
 and our custom canvas audio controls, we need to add some event handlers for 
 certain common mouse events.
  
 First, we need to create a couple variables—
 mouseX
  and 
 mouseY
 —that will hold the 
 current 
 x
  and 
 y
  locations of the mouse pointer:
  
 var mouseX; 
  
 var mouseY;
  
 Next, we need to create the event handlers. First, we listen for the 
 mouseup
  event. 
 This event fires when a user stops pressing the mouse button. We will listen for this 
 event when we are trying to determine whether we should stop dragging the 
 volume slider:
  
 theCanvas.addEventListener(""mouseup"",eventMouseUp, false);
  
 We also need to listen for the 
 mousedown
  event to determine whether the 
 play/pause button was pressed, the loop on/off toggle button was pressed, and/or 
 the volume slider was clicked so we can start dragging it:
  
 theCanvas.addEventListener(""mousedown"",eventMouseDown, false);
  
 Finally, we listen for 
 mousemove
  so we can figure out the current 
 x
  and 
 y
  locations 
 of the mouse pointer. We use this value to determine whether buttons have been 
 pressed, as well as whether the volume slider has been clicked and/or dragged:
  
 theCanvas.addEventListener(""mousemove"",eventMouseMove, false);",NA
Sliding Play Indicator,"The sliding play indicator is the simplest control we are going to draw onto the 
 canvas. It is not interactive—it just gives the user a visual indication of how much 
 of the audio clip is left to play.
  
 First of all, in 
 canvasApp()
  we need to make sure that we call the 
 drawScreen()
  
 function on an interval, so our updated controls will be displayed:
  
 setInterval(drawScreen, 33);",NA
Play/Pause Push Button: Hit Test Point Revisited,"The first thing we need to do when implementing the play/pause button is create 
 the event handler for the 
 mousemove
  event. The function really is just the standard 
 cross-browser code we introduced earlier in the book for tracking the mouse 
 position, de-pending on which properties the DOM in browsers supports: 
 layerX
 /
 layerY
  or 
 offsetX
 / 
 offsetY
 . This function is called every time the mouse is 
 moved on the canvas to update the 
 mouseX
  and 
 mouseY
  variables. Those variables 
 are scoped to 
 canvasApp()
  so all func-tions defined inside of it can access them:
  
 function eventMouseMove(event) {
  
  
  if ( event.layerX ||  event.layerX == 0) { // Firefox
  
  
     
  mouseX = event.layerX ;
  
  
   
  mouseY = event.layerY;
  
  
  
  } else if (event.offsetX || event.offsetX == 0) { // Opera
  
  
   
  mouseX = event.offsetX;
  
  
   
  mouseY = event.offsetY;
  
  
  
  }
  
  }
  
 Now we need to create the 
 eventMouseUp()
  handler function. This function is called 
 when the user releases the mouse button after clicking. Why 
 after
  and not when the 
 mouse is clicked? Well, one reason is because we generally use the 
 mousedown
  
 event for the start of a “dragging” operation, which we will show you shortly.
  
 The heart of this function is a hit test point-style collision detection check for the 
 but-tons. We discussed this in depth in 
 Chapter 6
  when we created the buttons for 
 the video puzzle game (
 CH6EX10.html
 ). Notice that here we are using the variables 
 we create to represent the 
 x
  and 
 y
  locations of the button (
 playX
 , 
 playY
 ) and the 
 width and height of a button (
 bW
 , 
 bH
 ) to form the bounds of the area we will test. If 
 the mouse pointer is within those bounds, we know the button has been clicked:
  
 function eventMouseUp(event) {
  
 if ( (mouseY >= playY) && (mouseY <= playY+bH) && (mouseX >= playX) && 
  
  
 (mouseX <= playX+bW) ) {
  
  
 If you had images stacked on top of one another, you would need to 
 store some kind of stacking value or z-index to know which item 
 was on top and was clicked at any one time. Because the canvas 
 works in immediate mode, you would have to “roll your own” just 
 like the other
  
 functionality we have discussed.
  
 After a hit is detected, we need to determine whether we are going to call the 
 play()
  
 or 
 pause()
  method of the 
 HTMLAudioElement
  object represented by the 
 audioElement
  
 vari-able. To figure out which method to call, we simply test to see whether the 
 audio is paused by checking the 
 audioElement.paused
  property. If so, we call the 
 play()
  method; if not, we call 
 pause()
 . Recall that the 
 HTMLAudioElement.paused
  
 property is set to
  
 342 | Chapter 7:Working with Audio",NA
Loop/No Loop Toggle Button,"Implementing the loop/no loop toggle button is nearly identical to implementing 
 the play/pause button. In 
 Figure 7-5
 , you can see that the last two buttons on the 
 bottom row represent the “on” and “off” states of the loop/no loop button. Unlike 
 the play/ pause button, this button shows the “state” of looping: the lighter, 3D-
 looking “out”button is displayed when the audio is not set to loop. The inverse, 
 darker button is displayed when the audio is set to loop (because it looks like the 
 button has been pressed).
  
 Creating a Canvas Audio Player | 343",NA
Click-and-Drag Volume Slider,"So now we make it to the last, but certainly not least, piece of functionality for the 
 audio player: the volume slider. The volume slider is an interactive control allowing 
 the user to manipulate it by sliding it right or left to control the volume of the 
 playing audio element. Before we create the volume slider, we need to define some 
 boundaries for its usage:
  
 • The slider never moves on the y-axis; it will always keep a constant 
 y
  value.
  
 • The farther the volume slider is to the right (the greater the 
 x
  value), the higher 
 the 
  
 volume.
  
 • The slider moves on the x-axis but is bounded by the starting 
 x
  value of the 
 volume slider image—
 volumeSliderStart
  on the left and 
 volumeSliderEnd
  on the right.
  
 • When the user clicks on the volume slider, we will assume that the user wants to 
 set the volume, so we will start “dragging” the slider. This means that if the 
 user moves the mouse on the x-axis, we will move the slider accordingly.
  
 344 | Chapter 7:Working with Audio",NA
Case Study in Audio: Space Raiders Game,"If we were writing a book about standard HTML5, we might be able to stop here 
 and continue on with another topic. However, there is a lot more to playing audio in 
 an application than simply getting a song to play and tracking its progress. In the 
 last part of this chapter, we will look at a case study: 
 Space Raiders
 . We will iterate 
 through several ideas and attempts to get audio working in an efficient way in 
 conjunction with action on HTML5 Canvas.
  
 352 | Chapter 7:Working with Audio",NA
Why Sounds in Apps Are Different: Event Sounds,"Why make a game as an example for playing sounds in HTML5? Well, a game is a 
 perfect example because it is difficult to predict how many sounds might be playing 
 at any one time.
  
 If you can imagine, games are some of the most demanding applications when it 
 comes to sound. In most games, sounds are played based on user interactions, and 
 those interactions are usually both asynchronous and unpredictable. Because of 
 those factors, we need to create a strategy for playing sounds that is flexible and 
 resource-efficient.
  
 To demonstrate how tricky sounds can be when using JavaScript and HTML5 with a 
 canvas game, we will iterate this game several times until we have a working 
 model.
  
 Here are some assumptions we will make regarding sound in 
 Space Raiders
  based 
 on what we know about the HTML5 
 audio
  object.
  
 1. After loading a sound, you can make another object with the same source 
 and“load” it without having to wait for it to load. (Flash sort of works this way.)
  
 2. Playing sounds locally is the same as playing them on a remotely hosted web 
 page.
  
 It turns out that both of these assumptions are 
 wrong
 . As we continue through this 
 case study, we will show you why, as well as how to accommodate them.
  
 Since this is not a chapter about making games, 
 Space Raiders
  is only going to be a 
 façade. In Hollywood, a façade is a structure built for filming, containing only the 
 parts the camera will see. For example, a building façade might have only the front 
 wall and windows—with nothing behind them. 
 Space Raiders
  is like this because 
 we are only going to create the parts necessary to include the dynamic sounds we 
 will be using. It will be most of a game, leading you into Chapters 
 8
  and 
 9
 , which 
 take a deep dive into making complete games with HTML5 Canvas.",NA
Iterations,"In this case study, we will create four iterations of 
 Space Raiders
 . Each one will 
 attempt to solve a dynamic audio problem in a different way. First, we will show 
 you the basics of the 
 Space Raiders
  game structure, and then we will discuss how to 
 solve the audio problem.",NA
Space Raiders Game Structure,"Space Raiders
  is an iconic action game where a swarm of alien invaders attack from 
 the top of the screen, and the player’s job is to defend the world. The raiders move 
 in horizontal lines near the top of the screen. When each raider reaches the side of 
 the playfield, it moves down the screen and then switches direction.",NA
Iteration #1: Playing Sounds Using a Single Object,"We just described the first iteration of the dynamic audio code. It works by 
 attempting to call the 
 play()
  function of both 
 shootSound
  and 
 explodeSound
  as often 
 as necessary. This appears to work at first, but if you listen carefully (and this is 
 apparent on some browsers more than others), the sounds start to play “off,” or not 
 play at all. This is because we are using a single object and attempting to play and 
 replay the same sound over and over. A single 
 HTMLAudioElement
  was not designed 
 to operate this way. You can test this example in the code distribution by running 
 CH7EX6.html
  in your HTML5-compliant web browser. Press the fire button as 
 quickly as possible and listen to when and how the sounds play. After a bit, they 
 start to play at the wrong time, don’t finish, or don’t play at all. 
 Figure 7-7
  shows 
 what the first iteration of 
 Space Raiders 
 looks like in a web browser.",NA
Iteration #2: Creating Unlimited Dynamic Sound ,NA,NA
Objects,"So, we almost got what we wanted with the first iteration, but we ran into some 
 oddities when calling the 
 play()
  function on a single 
 HTMLAudioElement
  multiple 
 times before the sound had finished playing.
  
 For our second iteration, we are going to try something different. Let’s see what 
 happens when you simply create a new 
 HTMLAudioElement
  object every time you 
 want to play a sound. If this doesn’t sound like an efficient use of memory or 
 resources in the web browser, you are a keen observer. It’s actually a horrible idea. 
 However, let’s proceed just to see what happens.
  
 362 | Chapter 7:Working with Audio",NA
Iteration #3: Creating a Sound Pool,"So, now we know we don’t want to play an 
 HTMLAudioElement
  repeatedly, or create 
 unlimited 
 sound
  objects on the fly. However, what if we cap the number of 
 audio
  
 objects we create, and put those objects in a pool so we can use them over and 
 over? This will save us memory, and after the sounds are loaded, we shouldn’t see 
 any loading pause before they are played, right?
  
 We will implement a solution that uses 
 HTMLAudioElement
  objects as general-
 purpose 
 sound
  objects. We will keep a pool of them, and change the 
 src
  attribute to 
 whatever sound we want to play. This appears to be an elegant solution that reuses 
 as much as possible, in addition to giving us a lot of flexibility as to which sounds 
 we want to play.
  
 In 
 canvasApp()
 , we will create a new constant named 
 MAX_SOUNDS
 . This will 
 represent the maximum number of 
 sound
  objects we can create at any one time. We 
 will also rename our 
 sounds
  array to 
 soundPool
  to better describe its purpose:
  
 Case Study in Audio: Space Raiders Game | 365",NA
Iteration #4: Reusing Preloaded Sounds,"Even though the code in iteration #3 was pretty clean, it simply did not work for us. 
 Instead, we need to compromise and implement a solution that is less elegant, but 
 that works to play sounds nearly every time they are needed. This solution must 
 also work both locally and when loaded from a website.
  
 For this final iteration, we are going to use a sound pool just like in iteration #3, but 
 it will operate in a different way. We will not reuse 
 sound
  objects for different sound 
 files. Instead, we will load all our sounds up front, and simply play a 
 sound
  object 
 that is currently not being used. In effect, we will “prime the pump,” creating three 
 sound 
 objects for each of our two sounds for a total of six 
 sound
  objects when we 
 start the application. While this may not seem like the perfect solution, it appears to 
 work fairly well in all browsers and plays sounds in the most effective way.
  
 In 
 canvasApp()
 , we set our 
 MAX_SOUNDS
  constant to 
 6
 . We could make it higher, but 
 for this example we will limit it to the number of sounds we will create and preload:
  
 const MAX_SOUNDS = 6;
  
 We then create six variables to hold our 
 HTMLAudioElement
  objects: three for the 
 explode sound…
  
 var explodeSound ; 
  
 var explodeSound2 ; 
  
 var explodeSound3 ;
  
 …and three for the shoot sound:
  
 var shootSound; 
  
 var shootSound2; 
  
 var shootSound3;
  
 In the 
 initApp()
  function, we preload all of these 
 sound
  objects. Yes, we load the same 
 object multiple times:
  
 explodeSound = document.createElement(""audio""); 
  
 document.body.appendChild(explodeSound); 
  
 audioType = supportedAudioFormat(explodeSound); 
  
 explodeSound.setAttribute(""src"", ""explode1."" + audioType); 
  
 explodeSound.addEventListener(""canplaythrough"",itemLoaded,false);
  
 explodeSound2 = document.createElement(""audio""); 
  
 document.body.appendChild(explodeSound2); 
  
 explodeSound2.setAttribute(""src"", ""explode1."" + audioType); 
  
 explodeSound2.addEventListener(""canplaythrough"",itemLoaded,false);
  
 explodeSound3 = document.createElement(""audio""); 
  
 document.body.appendChild(explodeSound3); 
  
 explodeSound3.setAttribute(""src"", ""explode1."" + audioType); 
  
 explodeSound3.addEventListener(""canplaythrough"",itemLoaded,false);
  
 shootSound = document.createElement(""audio""); 
  
 document.body.appendChild(shootSound);
  
 368 | Chapter 7:Working with Audio",NA
What’s Next,"Since this is not a book about the HTML5 
 <audio>
  tag, we did not cover every aspect 
 of that new feature. Instead, we focused on the elements of 
 audio
  that could be used 
 with HTML5 Canvas. We created two in-depth applications that make use of sound 
 with HTML5 Canvas in very different ways: an audio player that plays one song, 
 and a game that plays many sounds dynamically. During that process we learned 
 that audio in HTML, while being a wonderful new feature, is not without its pitfalls 
 and gotchas.
  
 In the next two chapters we will expand upon the last section we presented here, 
 and discuss how to implement games on HTML5 Canvas.
  
 378 | Chapter 7:Working with Audio",NA
CHAPTER 8,NA,NA
Canvas Game Essentials,"Games are the reason why many of us initially became interested in computers, and 
 they continue to be a major driving force that pushes computer technology to new 
 heights. In this chapter, we will examine how to build a mini game framework that 
 can be used to create games on the canvas. We will explore many of the core 
 building blocks associated with game development and apply them to HTML5 
 Canvas with the Java-Script API.
  
 We don’t have the space to cover every type of game you might want to create, but 
 we will discuss many elementary and intermediate topics necessary for most 
 games. At the end of this chapter, we will have a basic clone of Atari’s classic 
 Asteroids
  game. We will step through the creation of this game by first applying 
 some of the techniques for drawing and transformations specific to our game’s 
 visual objects. This will help get our feet wet by taking some of the techniques we 
 covered in previous chapters and applying them to an arcade game application. 
 Next, we will create a basic game frame-work that can be applied to any game we 
 want to make on the canvas. Following this, we will dive into some game 
 techniques and algorithms, and finally, we will apply everything we have covered to 
 create the finished product.",NA
Why Games in HTML5?,"Playing games in a browser has become one of the most popular activities for 
 Internet users. HTML5 Canvas gives web developers an API to directly manage 
 drawing to a specific area of the browser. This functionality makes game 
 development in JavaScript much more powerful than ever before.",NA
Canvas Compared to Flash,"We’ve covered this topic in earlier chapters, but we expect that a large portion of 
 readers might have previously developed games in Flash. If so, you will find that 
 Canvas offers similar functionality in certain areas, but lacks some of the more 
 refined features of Flash.
  
 379",NA
What Does Canvas Offer?,"Even though Canvas lacks some of the features that make the Flash platform very 
 nice for game development, it also has some strengths.
  
 A powerful single stage 
  
 HTML5 Canvas is closely akin to the Flash Stage. It is a rectangular piece of 
 screen real estate that can be manipulated programmatically. Advanced Flash 
 developers might recognize the canvas as a close cousin to both the 
 BitmapData
  
 and 
 Shape 
 objects in ActionScript. We can draw directly to the canvas with 
 paths and images, and transform them on the fly.
  
 Logical display objects 
  
 Canvas gives us a single physical display object, but we can create any number 
 of logical display objects. We will use JavaScript objects to hold all of the logical 
 data and methods we need to draw and transform our logical game objects to 
 the phys-ical canvas.",NA
Our Basic Game HTML5 File,"Before we start to develop our arcade game, let’s look at 
 Example 8-1
 , the most 
 basic HTML file we will use in this chapter (
 CH8EX1.html
 ). We’ll start by using the 
 basic HTML5 template we defined in 
 Chapter 1
 . Our canvas will be a 200×200 
 square.
  
 Example 8-1. The Basic HTML file for 
 Chapter 8
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH8EX1: Filled Screen With Some Text</title> 
  
 <script type=""text/javascript"">
  
  
  window.addEventListener('load', eventWindowLoaded, false);
  
  function eventWindowLoaded() {
  
   
  canvasApp();
  
  
  }
  
  
  function canvasApp(){
  
   
  var theCanvas = document.getElementById(""canvas"");
  
 380 | Chapter 8:Canvas Game Essentials",NA
Our Game’s Design,"We are not going to assume that everyone who reads this chapter knows of or 
 under-stands Atari’s classic arcade game 
 Asteroids
 . So, let’s start by taking a peek at 
 Aste-roids
 ’ game-play elements.
  
 Asteroids
 , designed by Ed Logg and Lyle Rains, was released by Atari in 1979. The 
 game pitted a lone triangular two-dimensional vector spaceship (the player ship) 
 against screen after screen of asteroid rocks that needed to be dodged and 
 destroyed. Every so often a space saucer would enter the screen attempting to 
 destroy the player ship.
  
 All asteroids started the game as large rocks; once they were hit, they would split 
 into two medium-sized rocks. When hit by a player missile, these medium-sized 
 rocks would then split into two small rocks. The small rocks would simply be 
 destroyed when hit (small was the final size for all asteroids).
  
 When the player destroyed all the asteroids, a new screen of more and slightly 
 faster asteroids would appear. This went on until the player exhausted his three 
 ships. At each 10,000-point score mark, the player was awarded an extra ship.
  
 All of the game objects moved (thrusting, rotating, and/or floating) freely across 
 the entire screen, which represented a slice of space as a flat plane. When an object 
 went off the side of the screen, it would reappear on the opposite side, in warp-like 
 fashion.",NA
Game Graphics: Drawing with Paths,"Let’s jump into game development on Canvas by first taking a look at some of the 
 graphics we will use in our game. This will help give us a visual feel for what type of 
 code we will need to implement.",NA
Needed Assets,"For our 
 Asteroids
 -like game, 
 Geo Blaster Basic
 , we will need some very simple game 
 graphics, including:
  
 • A solid black background.
  
 • A player ship that will rotate and thrust (move on a vector) across the game 
 screen. There will be two frames of animation for this ship: a “static” frame and 
 a “thrust”frame.
  
 • A saucer that flies across the screen and shoots at the player.
  
 • Some “rocks” for the player to shoot. We will use a simple square as our rock.
  
 There are two different methods we can employ to draw the graphics for our game: 
 bitmap images or paths. For the game in this chapter, we will focus on using paths. 
 In 
 Chapter 9
 , we will explore how to manipulate bitmap images for our game 
 graphics.",NA
Using Paths to Draw the Game’s Main Character,"Paths offer us a very simple but powerful way to mimic the vector look of the 
 classic 
 Asteroids
  game. We could use bitmap images for this purpose, but in this 
 chapter we are going to focus on creating our game in code with no external assets. 
 Let’s take a look at the two frames of animation we will create for our player ship.
  
 The static player ship (frame 1)
  
 The main frame of the player ship will be drawn with paths on a 20×20 grid, as 
 shown in 
 Figure 8-2
 .
  
  
 Figure 8-2. The player ship
  
 Using the basic HTML file presented in 
 Example 8-1
 , we can simply swap the 
 drawScreen()
  function with the code in 
 Example 8-2
  to draw the ship.
  
 Example 8-2. Drawing the player ship
  
 function drawScreen() {
  
  // draw background and text
  
  context.fillStyle = '#000000';
  
  context.fillRect(0, 0, 200, 200);
  
  context.fillStyle = '#ffffff';
  
  context.font = '20px _sans';
  
  context.textBaseline = 'top';
  
  context.fillText  (""Player Ship - Static"", 0, 180);
  
  //drawShip
  
  context.strokeStyle = '#ffffff';
  
  context.beginPath();
  
  context.moveTo(10,0);
  
  context.lineTo(19,19);
  
  context.lineTo(10,9);
  
  context.moveTo(9,9);
  
  context.lineTo(0,19);
  
  context.lineTo(9,0);
  
 }
  
  context.stroke();
  
  context.closePath();
  
 Game Graphics: Drawing with Paths | 383",NA
Drawing with ,NA,NA
Paths ,"The list below is a refresher on drawing 
 with paths:
  
 1. Always start a new path with the 
 context.beginPath()
  function call.
  
 2. Set 
 context.strokeStyle()
  before starting to draw the path.
  
 3. Use a combination of the 
 context.moveTo()
  and 
 context.drawTo()
  stroke com-
  
 mands to paint the path lines.
  
 4. End the drawing with the 
 context.stroke()
  call, and close off the path with 
  
 context.closePath()
 .
  
 We are drawing to the upper-left corner of the screen starting at 
 0
 ,
 0
 . 
 Figure 8-3
  
 shows what this will look like.
  
  
 Figure 8-3. The player ship on the canvas
  
 The ship with thrust engaged (frame 2) 
  
 Now let’s take a look at the second frame of animation for the player ship, which is 
 shown in 
 Figure 8-4
 .
  
  
 Figure 8-4. The player ship with thrust engaged
  
 384 | Chapter 8:Canvas Game Essentials",NA
Animating on the Canvas,"The player ship we just created has two frames (static and thrust), but we can only 
 display a single frame at a time. Our game will need to switch out the frame of 
 animation based on the state of the player ship, and it will need to run on a timer so 
 this animation can occur. Let’s take a quick look at the code necessary to create our 
 game timer.",NA
Game Timer Loop,"Games on HTML5 Canvas require the use of the repeated update/render loop to 
 sim-ulate animation. We do this by using the 
 setInterval()
  JavaScript function, which 
 will repeatedly call a function of our choosing at millisecond intervals. Each second 
 of game/ animation time is made up of 1,000 milliseconds. If we want our game to 
 run at 30 update/render cycles per second, we call this a 30 frames per second 
 (FPS) rate. To run",NA
The Player Ship State Changes,"We simply need to switch between the static and thrust states to simulate the 
 animation. Let’s take a look at the full HTML file to do this. In 
 Example 8-4
 , we will 
 start to place 
 canvasApp
  class-level variables in a new section just above the 
 drawScreen()
  function. This will be the location going forward for all variables 
 needing a global scope inside the 
 canvasApp()
  object.
  
 Example 8-4. The player ship state changes for thrust animation
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH8EX4: Ship Animation Loop</title> 
  
 <script type=""text/javascript""> 
  
 window.addEventListener('load', eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
 }
  
  canvasApp();
  
 function canvasApp(){
  
  var theCanvas = document.getElementById(""canvas""); if 
 (!theCanvas || !theCanvas.getContext) {
  
  
  return;
  
  }
  
  var context = theCanvas.getContext(""2d"");
  
  if (!context) {
  
  
  return;
  
  }
  
  //canvasApp level variables
  
  var shipState = 0; //0 = static, 1 = thrust
  
 386 | Chapter 8:Canvas Game Essentials",NA
Applying Transformations to Game ,NA,NA
Graphics,"Our game will probably have many individual logical display objects that need to be 
 updated on a single frame tick. We can make use of the Canvas stack (
 save()
  and 
 restore()
  functions), and use the transformation matrix to ensure the final output 
 affects only the current object we are working on—not the entire canvas.",NA
The Canvas Stack,"The Canvas state can be saved to a stack and retrieved. This is important when we 
 are 
 transforming and animating 
 game 
 objects because 
 we 
 want our 
 transformations to affect only the current game object and not the entire canvas. 
 The basic workflow for using the Canvas stack in a game looks like this:
  
 1. Save the current canvas to the stack.
  
 2. Transform and draw the game object.
  
 3. Retrieve the saved canvas from the stack.
  
 As an example, let’s set up a basic rotation for our player ship. We will rotate it by 1 
 degree on each frame. Since we are currently drawing the player ship in the top-left 
 corner of the canvas, we are going to move it to a new location. We do this because 
 the basic rotation will use the top-left corner of the ship as the 
 registration point
 : 
 the axis location used for rotation and scale operations. So, if we kept the ship at 
 the 
 0
 ,
 0
  location and rotated it by its top-left corner, you would not see it half the 
 time because its location would be off the top and left edges of the canvas. Instead, 
 we will place the ship at 
 50
 ,
 50
 .
  
 We will be using the same HTML code as in 
 Example 8-4
 , changing out only the 
 drawCanvas()
  function. To simplify this example, we will remove the 
 shipState
  
 variable and concentrate on the static state only. We will be adding in three new 
 variables above the 
 drawCanvas()
  function:
  
 var rotation = 0; - holds the current rotation of the player ship var x = 50; - 
 holds the x location to start drawing the player ship var y = 50; - holds the y 
 location to start drawing the player ship
  
 Example 8-5
  gives the full code.",NA
Game Graphic Transformations,"As we saw in the previous section, we can easily rotate a game graphic at the top-
 left corner by using the 
 context.rotate()
  transformation. However, our game will 
 need to rotate objects at the center rather than the top-left corner. To do this, we 
 must change the transformation point to the center of our game graphic object.",NA
Rotating the Player Ship from the Center,"The code to rotate the player ship from its center point is almost exactly like the 
 code used to rotate it at the top-left corner. What we need to modify is the point of 
 the translation. In 
 Example 8-5
 , we placed the immediate-mode drawing context at 
 the 
 x 
 and 
 y
  coordinates of our game object (
 50
 ,
 50
 ). This had the effect of rotating 
 the object from the top-left corner. Now we must move the translation to the center 
 of our object:
  
 context.translate(x+.5*width,y+.5*height);
  
  
 The 
 width
  and 
 height
  variables represent attributes of our drawn 
 player ship. We will create these attributes in 
 Example 8-6
 .
  
 This is not the only change we need to make; we also need to draw our ship as 
 though it is the center point. To do this, we will subtract half the 
 width
  from each 
 x
  
 attribute in our path draw sequence, and half the 
 height
  from each 
 y
  attribute:
  
 context.moveTo(10-.5*width,0-.5*height); 
  
 context.lineTo(19-.5*width,19-.5*height);
  
 As you can see, it might get a little confusing trying to draw coordinates in this 
 manner. It is also slightly more processor-intensive than using constants. In that 
 case, we would simply hardcode in the needed values. Remember, the 
 width
  and 
 height
  attributes of our ship are both 
 20
 . The hardcoded version would look 
 something like this:
  
 context.moveTo(0,−10);  //10-10, 0-10 
  
 context.lineTo(9,9); //19-10, 19-10
  
 The method where we use the calculated values (using the 
 width
  and 
 height
  
 variables) is much more flexible, while the hardcoded method is much less 
 processor-intensive. 
 Example 8-6
  contains all the code to use either method. We 
 have commented out the calculated version of the code.
  
 Example 8-6. Rotating an image from its center point
  
 //canvasApp level variables
  
  var rotation = 0;
  
  var x = 50;
  
  var y = 50;",NA
Alpha Fading the Player Ship,"When a new player ship in 
 GeoBlaster Basic
  enters the game screen, we will have it 
 fade from transparent to opaque. 
 Example 8-7
  shows how we will create this 
 transfor-mation in our game.
  
 Using the context.globalAlpha attribute
  
 To use the 
 context.globalAlpha
  attribute of the canvas, we simply set it to a number 
 between 
 0
  and 
 1
  before we draw the game graphics. We will create a new variable 
 in our code called 
 alpha
 , which will hold the current alpha value for our player ship. 
 We will increase it by 
 .01
  until it reaches 
 1
 . When we actually create our game we 
 will stop it at 
 1
  and then start the game level. However, for this demo, we will just 
 repeat it over and over.
  
 Example 8-7. Alpha fading to the player ship
  
 //canvasApp level variables
  
  var x = 50;
  
  var y = 50;
  
  var width = 20;
  
  var height = 20;
  
  var alpha = 0;
  
  context.globalAlpha  = 1;
  
  function drawScreen() {
  
  context.globalAlpha = 1;
  
  context.fillStyle = '#000000';
  
  context.fillRect(0, 0, 200, 200);
  
  context.fillStyle = '#ffffff';
  
  context.font = '20px _sans';
  
  context.textBaseline = 'top';
  
  context.fillText  (""Player Ship - alpha"", 0, 180); 
 context.globalAlpha = alpha;
  
  context.save(); //save current state in stack
  
  context.setTransform(1,0,0,1,0,0); // reset to identity
  
  //translate the canvas origin to the center of the player 
 context.translate(x+.5*width,y+.5*height);
  
  //drawShip
  
  context.strokeStyle = '#ffffff';
  
  context.beginPath();
  
  //hardcoding in locations
  
  context.moveTo(0,-10);
  
  context.lineTo(9,9);
  
  context.lineTo(0,-1);
  
  context.moveTo(-1,-1);
  
  context.lineTo(-10,9);
  
  context.lineTo(-1,-10);
  
 392 | Chapter 8:Canvas Game Essentials",NA
Game Object Physics and Animation,"All of our game objects will move on a two-dimensional plane. We will use basic di-
 rectional movement vectors to calculate the change in the 
 x
  and 
 y
  coordinates for 
 each game object. At its very basic level, we will be updating the delta x (
 dx
 ) and 
 delta y (
 dy
 ) of each of our game objects on each frame to simulate movement. These 
 dx
  and 
 dy
  values will be based on the angle and direction in which we want the 
 object to move. All of our logical display objects will add their respective 
 dx
  and 
 dy
  
 values to their 
 x
  and 
 y
  values on each frame of animation. The player ship will not 
 use strict 
 dx
  and 
 dy
  because it needs to be able to float and turn independently. 
 Let’s take a closer look at the player movement now.",NA
How Our Player Ship Will Move,"Our player ship will change its angle of center axis rotation when the game player 
 presses the left and right arrow keys. When the game player presses the up arrow 
 key, the player ship will accelerate (thrust) in the angle it is facing. Because there is 
 no friction applied to the ship, it will continue to float in the current accelerated 
 angle until a different angle of acceleration is applied. This happens when the game 
 player rotates to a new angle and presses the up (thrust) key once again.
  
 The difference between facing and moving
  
 Our player ship can rotate to the direction it is facing while it is moving in a 
 different direction. For this reason, we cannot simply use classic 
 dx
  and 
 dy
  values to 
 represent the movement vector on the x and y axes. We must keep both sets of 
 values for the ship at all times. When the player rotates the ship but does not thrust 
 it, we need to draw the ship in the new rotated angle. All missile projectiles the ship 
 fires must also move in the direction the ship is facing. On the x-axis, we will name 
 this value 
 facingX
 ; on the y-axis, it’s 
 facingY
 . 
 movingX
  and 
 movingY
  values will handle 
 moving the ship in the direction it was pointed in when the thrust was applied. All 
 four values are needed to thrust the ship in a new direction. Let’s take a look at this 
 next.
  
 Game Object Physics and Animation | 393",NA
Controlling the Player Ship with the Keyboard,"We will add in two keyboard events and an array object to hold the state of each 
 key press. This will allow the player to hold down a key and have it repeat without 
 a pause. Arcade games require this type of key-press response.
  
 The array to hold our key presses
  
 An array will hold the 
 true
  or 
 false
  value for each 
 keyCode
  associated with key 
 events. The 
 keyCode
  will be the index of the array that will receive the 
 true
  or 
 false
  
 value:
  
 var keyPressList = [];
  
 The key events
  
 We will use separate events for both key down and key up. The key 
 down
  event will 
 put a 
 true
  value in the 
 keyPressList
  array at the index associated with the event’s 
 keyCode
 . Conversely, the key 
 up
  event will place a 
 false
  in that array index:
  
 Game Object Physics and Animation | 395",NA
Giving the Player Ship a Maximum Velocity,"If you play with the code in 
 Example 8-8
 , you will notice two problems:
  
 1. The ship can go off the sides of the screen and get lost.
  
 2. The ship has no maximum speed.
  
 We’ll resolve the first issue when we start to code the complete game, but for now, 
 let’s look at how to apply a maximum velocity to our current movement code. 
 Suppose we give our player ship a maximum acceleration of 
 2
  pixels per frame. It’s 
 easy to calculate the current velocity if we are only moving in the four primary 
 directions: up, down, right, left. When we are moving left or right, the 
 movingY
  value 
 will always be 
 0
 . If we are moving up or down, the 
 movingX
  value will always be 
 0
 . 
 The current velocity we are moving on one axis would be easy to compare to the 
 maximum velocity.
  
 But in our game, we are almost always moving in the 
 x
  and 
 y
  directions at the same 
 time. To calculate the current velocity and compare it to a maximum velocity, we 
 must use a bit more math.
  
 First, let’s assume that we will add a maximum velocity variable to our game:
  
 var maxVelocity = 2;
  
 Next, we must make sure to calculate and compare the 
 maxVelocity
  to the current 
 velocity 
 before
  we calculate the new 
 movingX
  and 
 movingY
  values. We will do this 
 with local variables used to store the new values for 
 movingX
  and 
 movingY
  before 
 they are applied:
  
 var movingXNew = movingX+thrustAcceleration*facingX; var 
 movingYNew = movingY+thrustAcceleration*facingY;
  
 Game Object Physics and Animation | 399",NA
A Basic Game Framework,"Now that we have gotten our feet wet (so to speak) by taking a peek at some of the 
 graphics, transformations, and basic physics we will use in our game, let’s look at 
 how we will structure a simple framework for all games we might want to create on 
 HTML5 Canvas. We will begin by creating a simple state machine using constant 
 variables. Next, we will introduce our game timer interval function to this structure, 
 and finally, we will create a simple reusable object that will display the current 
 frame rate our game is running in. Let’s get started.",NA
The Game State Machine,"A state machine is a programming construct that allows for our game to be in only a 
 single application state at any one time. We will create a state machine for our 
 game, called 
 application state
 , which will include seven basic states (we will use 
 constants to refer to these states):
  
 •
  GAME_STATE_TITLE
  
 •
  GAME_STATE_NEW_GAME
  
 •
  GAME_STATE_NEW_LEVEL
  
 •
  GAME_STATE_PLAYER_START
  
 •
  GAME_STATE_PLAY_LEVEL
  
 •
  GAME_STATE_PLAYER_DIE
  
 •
  GAME_STATE_GAME_OVER
  
 We will create a 
 function
  object for each state that will contain game logic necessary 
 for the state to function and to change to a new state when appropriate. By doing 
 this, we can use the same structure for each game we create by simply changing out 
 the content of each 
 state function
  (as we will refer to them).
  
 Let’s take a look at a very basic version of this in action. We will use a function 
 reference variable called 
 currentGameStateFunction
 , as well as an integer variable 
 called 
 current GameState
  that will hold the current application state constant value:
  
 400 | Chapter 8:Canvas Game Essentials",NA
The Update/Render (Repeat) Cycle,"In any of our application states, we might need to employ animation and screen up-
 dates. We will handle these updates by separating our code into distinct 
 update()
  
 and 
 render()
  operations. For example, as you might recall, the player ship can move 
 around the game screen, and when the player presses the up arrow key, the ship’s 
 thrust frame of animation will be displayed rather than its static frame. In the 
 previous examples, we contained all the code that updates the properties of the 
 ship, as well as the code that actually draws the ship, in a single function called 
 drawScreen()
 . Starting with 
 Example 8-10
 , we will rid ourselves of this simple 
 drawScreen()
  function and instead employ 
 update()
  and 
 render()
  functions 
 separately. We will also separate out the code that checks for the game-specific key 
 presses into a 
 checkKeys()
  function.
  
 Let’s reexamine the contents of the 
 drawScreen()
  function from 
 Example 8-8
 , but 
 this time break the function up into separate functions for each set of tasks, as 
 shown in 
 Example 8-10
 .
  
 Example 8-10. Splitting the update and render cycles
  
 function gameStatePlayLevel() {
  
  
  checkKeys();
  
  
  update();
  
  
  render(); 
  
 }
  
 function checkKeys() {
  
  //check keys
  
  if (keyPressList[38]==true){
  
  //thrust
  
  var angleInRadians = rotation * Math.PI / 180; facingX 
 = Math.cos(angleInRadians);
  
  facingY = Math.sin(angleInRadians);
  
  movingX = movingX+thrustAcceleration*facingX; 
 movingY = movingY+thrustAcceleration*facingY;
  
  }
  
  if (keyPressList[37]==true) {
  
  
  //rotate counterclockwise
  
  
  rotation−=rotationalVelocity;
  
  }
  
 }
  
  if (keyPressList[39]==true) {
  
  
  //rotate clockwise
  
  
  rotation+=rotationalVelocity;; }
  
 function update() {
  
 404 | Chapter 8:Canvas Game Essentials",NA
The FrameRateCounter Object Prototype,"Arcade games such as 
 Asteroids
  and 
 Geo Blaster Basic
  rely on fast processing and 
 screen updates to ensure all game-object rendering and game-play logic are 
 delivered to the player at a reliable rate. One way to tell whether your game is 
 performing up to par is to employ the use of a frame rate per second (FPS) counter. 
 Below is a simple one that can be reused in any game you create on the canvas:
  
 //*** FrameRateCounter  object prototype 
  
 function FrameRateCounter() {
  
 }
  
  this.lastFrameCount = 0;
  
  var dateTemp = new Date();
  
  this.frameLast = dateTemp.getTime(); delete 
 dateTemp;
  
  this.frameCtr = 0;
  
 FrameRateCounter.prototype.countFrames=function() { var 
 dateTemp = new Date();
  
  this.frameCtr++;
  
  if (dateTemp.getTime() >=this.frameLast+1000) {
  
  
 ConsoleLog.log(""frame event"");
  
  
  this.lastFrameCount = this.frameCtr;
  
  
  this.frameLast = dateTemp.getTime();
  
  
  this.frameCtr = 0;
  
  }
  
 }
  
  delete dateTemp;
  
 Our game will create an instance of this object and call the 
 countFrames()
  function 
 on each frame tick in our 
 update()
  function. We will write out the current frame rate 
 in our 
 render()
  function.
  
 Example 8-11
  shows these functions by adding code to 
 Example 8-10
 . Make sure 
 you add the definition of the 
 FrameRateCounter
  prototype object to the code in 
 Exam-ple 8-10
  under the 
 canvasApp()
  function but before the final 
 <script>
  tag. 
 Alternatively, you can place it in its own 
 <script\>
  tags, or in a separate 
 .js
  file and 
 set the URL as the 
 src=
  value of a 
 <script>
  tag. For simplicity’s sake, we will keep all 
 our code in a single file.
  
 Example 8-11
  contains the definition for our 
 FrameRateCounter
  object prototype, as 
 well as the code changes to 
 Example 8-10
  that are necessary to implement it.
  
 Example 8-11. The FrameRateCounter is added
  
 function update() {
  
  
  x = x+movingX;
  
  
  y = y+movingY;
  
  
  frameRateCounter.countFrames(); 
  
 }
  
 406 | Chapter 8:Canvas Game Essentials",NA
Putting It All Together,"We are now ready to start coding our game. First, we will look at the structure of 
 the game and some of the ideas behind the various algorithms we will employ to 
 create it. After that, we will present the full source code for 
 Geo Blaster Basic
 .",NA
Geo Blaster Game Structure,"The structure of the game application is very similar to the structure we started to 
 build earlier in this chapter. Let’s take a closer look at the state functions and how 
 they will work together.
  
 Game application states
  
 Our game will have seven distinct game application states. We will store these in 
 constants:
  
 const GAME_STATE_TITLE = 0; 
  
 const GAME_STATE_NEW_GAME = 1; 
  
 const GAME_STATE_NEW_LEVEL = 2; 
  
 const GAME_STATE_PLAYER_START = 3; 
  
 const GAME_STATE_PLAY_LEVEL = 4; 
  
 const GAME_STATE_PLAYER_DIE = 5; 
  
 const GAME_STATE_GAME_OVER = 6;
  
 Game application state functions
  
 Each individual state will have an associated function that will be called on each 
 frame tick. Let’s look at the functionality for each:
  
 Putting It All Together | 407",NA
Geo Blaster Global Game Variables,"Now let’s look at the entire set of game application scope variables needed for our 
 game.
  
 Variables that control screen flow 
  
 These variables will be used when the title and “Game Over” screens first 
 appear. They will be set to 
 true
  once the screen is drawn. When these variables 
 are 
 true
 , the screens will look for the space bar to be pressed before moving on 
 to the next application state:
  
 410 | Chapter 8:Canvas Game Essentials",NA
The player Object,"The 
 player
  object contains many of the variables we encountered earlier in this 
 chapter when we discussed animating, rotating, and moving the player ship about 
 the game screen. We have also added in three new variables that you have not seen 
 before:
  
 player.maxVelocity = 5; 
  
 player.width = 20; 
  
 player.height = 20; 
  
 player.halfWidth = 10; 
  
 player.halfHeight = 10; 
  
 player.rotationalVelocity = 5 
  
 player.thrustAcceleration = .05; 
  
 player.missileFrameDelay = 5; 
  
 player.thrust = false;
  
 The new variables are 
 halfWidth
 , 
 halfHeight
 , and 
 missileFrameDelay
 . 
 halfWidth
  and 
 halfHeight
  simply store half the width and half the height values, so these need not 
 be calculated on each frame tick in multiple locations inside the code. The 
 missileFrame Delay
  variable contains the number of frame ticks the game will count 
 between firing player missiles. This way, the player cannot simply fire a steady 
 stream of ordnance and destroy everything with little difficulty.
  
 The 
 player.thrust
  variable will be set to 
 true
  when the player presses the up key.",NA
Geo Blaster Game Algorithms,"The game source code covers a lot of ground that we did not touch on earlier in this 
 chapter. Let’s discuss some of those topics now; the rest will be covered in detail in 
 Chapter 9
 .",NA
Arrays of Logical Display Objects,"We have used arrays to hold all our logical display objects, and we have an array for 
 each type of object (
 rocks
 , 
 saucers
 , 
 playerMissiles
 , 
 saucerMissiles
 , and 
 particles
 ).
  
 412 | Chapter 8:Canvas Game Essentials",NA
Level Knobs,"Even though we never show the level number to the game player, we are adjusting 
 the difficulty every time a screen of rocks is cleared. We do this by increasing the 
 level variable by 
 1
  and then recalculating these values before the level begins. We 
 refer to the variance in level difficulty as 
 knobs
 , which refers to dials or switches. 
 Here are the variables we will use for these knobs:
  
 level+3 
  
  
 Number of rocks
  
 levelRockMaxSpeedAdjust = level*.25; 
  
  
 Rock max speed
  
 levelSaucerMax = 1+Math.floor(level/10); 
  
 Number of simultaneous saucers
  
 levelSaucerOccurrenceRate = 10+3*level; 
  
  
 Percent chance a saucer will appear
  
 levelSaucerSpeed = 1+.5*level; 
  
  
 Saucer speed
  
 levelSaucerFireDelay = 120-10*level; 
  
 Delay between saucer missiles
  
 levelSaucerFireRate = 20+3*level; 
  
  
 Percent chance a saucer will fire at the 
 player
  
 levelSaucerMissileSpeed = 1+.2*level; 
  
  
 Speed of saucer missiles",NA
Level and Game End,"We need to check for game and level end so we can transition to either a new game 
 or to the next level.
  
 Level end
  
 We will check for level end on each frame tick. The function to do so will look like 
 this:
  
 function checkForEndOfLevel(){
  
  
  if (rocks.length==0) {
  
   
  
 switchGameState(GAME_STATE_NEW_LEVEL);
  
  
  } 
  
 }
  
 Once the 
 rocks
  array length is 
 0
 , we switch the state to 
 GAME_STATE_NEW_LEVEL
 .",NA
Awarding the Player Extra Ships,"We want to award the player extra ships at regular intervals based on her score. 
 We do this by setting an amount of points that the game player must achieve to 
 earn a new ship—this also helps us keep a count of the number of ships earned:
  
 416 | Chapter 8:Canvas Game Essentials",NA
Applying Collision Detection,"We will be checking the bounding box around each object when we do our collision 
 detection. A bounding box is the smallest rectangle that will encompass all four 
 corners of a game logic object. We have created a function for this purpose:
  
 function boundingBoxCollide(object1, object2) {
  
  var left1 = object1.x;
  
  var left2 = object2.x;
  
  var right1 = object1.x + object1.width;
  
  var right2 = object2.x + object2.width;
  
  var top1 = object1.y;
  
  var top2 = object2.y;
  
  var bottom1 = object1.y + object1.height;
  
  var bottom2 = object2.y + object2.height;
  
  if (bottom1 < top2) return(false);
  
  if (top1 > bottom2) return(false);
  
  if (right1 < left2) return(false);
  
  if (left1 > right2) return(false);
  
  return(true);
  
 };
  
 We can pass any two of our game objects into this function as long as each contains 
 x
 , 
 y
 , 
 width
 , and 
 height
  attributes. If the two objects are overlapping, the function will 
 return 
 true
 . If not, it will return 
 false
 .
  
 The 
 checkCollision()
  function for 
 Geo Blaster Basic
  is quite involved. The full code 
 listing is given in 
 Example 8-12
 . Rather than reprint it here, let’s examine some of 
 the basic concepts.
  
 One thing you will notice is the use of “labels” next to the 
 for
  loop constructs. Using 
 labels such as in the following line can help streamline collision detection:
  
 rocks: for (var rockCtr=rocksLength;rockCtr>=0;rockCtr--){
  
 Geo Blaster Game Algorithms | 417",NA
The Geo Blaster Basic Full Source,"Example 8-12
  shows the entire set of code for our game. You can download this and 
 the entire set of example files from the book’s website.
  
 Example 8-12. The Geo Blaster Basic full source listing
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>Geo Blaster Basic Game</title> 
  
 <script type=""text/javascript""> 
  
 window.addEventListener('load', eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
  
  canvasApp(); 
  
 }
  
 function canvasApp(){
  
  
  var theCanvas = document.getElementById(""canvas"");
  
  
 if (!theCanvas || !theCanvas.getContext) {
  
   
  return;
  
  
  }
  
  var context = theCanvas.getContext(""2d"");
  
  if (!context) {
  
  
  return;
  
  }
  
  //application states
  
  const GAME_STATE_TITLE = 0;
  
  const GAME_STATE_NEW_GAME = 1;
  
  const GAME_STATE_NEW_LEVEL = 2;
  
  const GAME_STATE_PLAYER_START = 3;
  
  const GAME_STATE_PLAY_LEVEL = 4;
  
  const GAME_STATE_PLAYER_DIE = 5;
  
  const GAME_STATE_GAME_OVER = 6;
  
  var currentGameState = 0;
  
  var currentGameStateFunction = null;",NA
Rock Object Prototype,"To conserve space, we did not create separate object prototypes for the various 
 display objects in this game. However, 
 Example 8-13
  is a Rock prototype object that 
 can be used in a game such as 
 Geo Blaster Basic
 .
  
 Example 8-13. The Rock.js prototype
  
 //*** Rock Object Prototype
  
 function Rock(scale, type) {
  
  //scale
  
  //1 = large
  
  //2 = medium
  
  //3 = small
  
  //these will be used as the divisor for the new size //50/1 = 
 50
  
  //50/2 = 25
  
  //50/3 = 16
  
  this.scale = scale;
  
  if (this.scale <1 || this.scale >3){
  
  
  this.scale=1;
  
  }
  
 Rock Object Prototype | 443",NA
What’s Next,"We covered quite a bit in this chapter. HTML5 Canvas might lack some of the more 
 refined features common to web game development platforms such as Flash, but it 
 contains powerful tools for manipulating the screen in immediate mode. These 
 features allow us to create a game application with many individual logical display 
 objects—even though each canvas can support only a single physical display object 
 (the canvas itself).
  
 In 
 Chapter 9
  we will explore some more advanced game topics, such as replacing 
 paths with bitmap images, creating object pools, and adding a sound manager. We’ll 
 extend the game we built in this chapter and create a new turn-based strategy 
 game.
  
 What’s Next | 445",NA
CHAPTER 9,NA,NA
Combining Bitmaps and ,NA,NA
Sound,"Geo Blaster Basic
  was constructed using pure paths for drawing. In its creation, we 
 began to cover some game-application-related topics, such as basic collision 
 detection and state machines. In this chapter, we will focus on using bitmaps and 
 tile sheets for our game graphics, and we will also add sound using techniques 
 introduced in 
 Chapter 7
 .
  
 Along the way, we will update the 
 FrameRateCounter
  from 
 Chapter 8
  by adding in 
 a“step timer.” We will also examine how we can eliminate the use of a tile sheet for 
 rotations by precreating an array of 
 imageData
  instances using the 
 getImageData()
  
 and 
 putImageData()
  Canvas functions.
  
 In the second half of this chapter, we will create another small turn-based strategy 
 game using bitmaps. This game will be roughly based on the classic computer game 
 Daleks
 .",NA
Geo Blaster Extended,"We will create a new game, 
 Geo Blaster Extended
 , by adding bitmaps and sound to 
 the 
 Geo Blaster Basic
  game from 
 Chapter 8
 . Much of the game logic will be the same, 
 but adding bitmaps to replace paths will enable us to optimize the game for 
 rendering. Optimized rendering is very important when you are targeting limited-
 processor devi-ces, such as mobile phones. We will also add sound to 
 Geo Blaster 
 Extended
 , and apply an object pool to the particles used for game explosions. 
 Figure 
 9-1
  shows an example screen of the finished game.",NA
Geo Blaster Tile Sheet,"In 
 Chapter 4
 , we examined applying bitmap graphics to the canvas, and we 
 explored using tile sheet methods to render images. In 
 Chapter 8
 , we drew all our 
 game graphics as paths and transformed them on the fly. In this chapter, we will 
 apply the concepts from 
 Chapter 4
  to optimizing the rendering of the 
 Geo Blaster 
 Basic
  game. We will do this by prerendering all of our game graphics and 
 transformations as bitmaps. We will then use these bitmaps instead of paths and 
 the immediate-mode transformations that were necessary in 
 Chapter 8
  to create 
 Geo Blaster Extended
 .
  
 Figure 9-2
  shows one of the tile sheets we will use for this game (
 ship_tiles.png
 ).
  
 These tiles are the 36 rotations for our player ship. We are “canning” the rotations 
 in a tile sheet to avoid spending processor cycles transforming them on each frame 
 tick as we draw them to the canvas.
  
 448 | Chapter 9:Combining Bitmaps and Sound",NA
Rendering the Other Game Objects,"The rocks, saucers, missiles, and particles will all be rendered in a manner similar 
 to the method implemented for the player ship. Let’s first look at the code for the 
 saucer’s render function.
  
 Rendering the saucers
  
 The saucers do not have a multiple-cell tile sheet, but to be consistent, we will 
 render them as though they do. This will allow us to add more animation tiles for 
 the saucers later:
  
 function renderSaucers() {
  
  
  var tempSaucer = {};
  
  
  var saucerLength = saucers.length-1;
  
  
  for (var saucerCtr=saucerLength;saucerCtr>=0;saucerCtr--){
  
  
  //ConsoleLog.log(""saucer: "" + saucerCtr);
  
   
  tempSaucer = saucers[saucerCtr];
  
 }
  
  }
  
  context.save(); //save current state in stack
  
  var sourceX = 0;
  
  var sourceY = 0;
  
  context.drawImage(saucerTiles, sourceX, sourceY, 30, 15,
  
  tempSaucer.x,tempSaucer.y,30,15);
  
  context.restore(); //pop old state on to screen
  
 There is no need to actually calculate the 
 sourceX
  and 
 sourceY
  values for the saucer 
 because the saucer is only a single tile. In this instance, we can just set them to 
 0
 . 
 We have hardcoded the 
 saucer.width (30)
  and 
 saucer.height (15)
  as an example, but 
 with all the rest of the game objects, we will use the object 
 width
  and 
 height
  
 attributes rather than literals.
  
 Next, let’s look at the rock rendering, which varies slightly from both the player ship 
 and the saucers.
  
 Rendering the rocks
  
 The rock tiles are contained inside three separate tile sheets based on their size 
 (large, medium, and small), and we have used only five tiles for each rock. The 
 rocks are square with a symmetrical pattern, so we only need to precreate a single 
 quarter-turn rotation for each of the three sizes.
  
 Here is the 
 renderRocks()
  function. Notice that we must “switch” based on the scale 
 of the rock (1=large, 2=medium, 3=small) to choose the right tile sheet to render:
  
 function renderRocks() {
  
  var tempRock = {};
  
  var rocksLength = rocks.length-1;
  
  for (var rockCtr=rocksLength;rockCtr>=0;rockCtr--){ 
 context.save(); //save current state in stack
  
 454 | Chapter 9:Combining Bitmaps and Sound",NA
Adding Sound,"In 
 Chapter 7
 , we covered everything we need to know to add robust sound 
 management to our canvas applications. If you are unfamiliar with the concepts 
 presented in 
 Chap-ter 7
 , please review that chapter first. In this chapter, we will 
 cover only the code nec-essary to include sound in our game.
  
 Arcade games need to play many sounds simultaneously, and sometimes those 
 sounds play very rapidly in succession. In 
 Chapter 7
 , we used the HTML5 
 <audio>
  
 tag to create a pool of sounds, solving the problems associated with playing the 
 same sound instance multiple times.
  
 Geo Blaster Extended | 459",NA
Pooling Object Instances,"We have looked at object pools as they relate to sounds, but we have not applied 
 this concept to our game objects. Object pooling is a technique designed to save 
 processing time, so it is very applicable to an arcade game application such as the 
 one we are building. By pooling object instances, we avoid the sometimes 
 processor-intensive task of creating object instances on the fly during game 
 execution. This is especially appli-cable to our particle explosions, as we create 
 multiple objects on the same frame tick.",NA
Adding in a Step Timer,"In 
 Chapter 8
 , we created a simple 
 FrameRateCounter
  object prototype that was used 
 to display the current frame rate as the game was running. We are going to extend 
 the functionality of this counter to add in a “step timer.” The step timer will use the 
 time difference calculated between frames to create a “step factor.” This step factor 
 will be used when updating the positions of the objects on the canvas. The result 
 will be smoother rendering of the game objects when there are drops in frame rate, 
 as well as keeping relatively consistent game play on browsers and systems that 
 cannot maintain the frame rate needed to play the game effectively.
  
 How the step timer works
  
 We will update the constructor function for 
 FrameRateCounter
  to accept in a new 
 single parameter called 
 fps
 . This value will represent the frames per second that we 
 want our game to run:
  
 function FrameRateCounter(fps) {
  
  
  if (fps == undefined){
  
   
  this.fps = 40
  
  
  }else{
  
   
  this.fps = fps
  
  
  }
  
 If no 
 fps
  value is passed in, the value 
 40
  will be used.
  
 We will also add in two new object-level scope variables to calculate the 
 step
  in our 
 step timer:
  
 this.lastTime = dateTemp.getTime(); 
  
 this.step = 1;
  
 The 
 lastTime
  variable will contain the time in which the previous frame completed 
 its work.
  
 We calculate the 
 step
  by comparing the current time value with the 
 lastTime
  value 
 on each frame tick. This calculation will occur in the 
 FrameRateCountercountFrames() 
 function:
  
 FrameRateCounter.prototype.countFrames=function() {
  
  var dateTemp = new Date();
  
  var timeDifference = dateTemp.getTime()-this.lastTime; 
 this.step = (timeDifference/1000)*this.fps;
  
  this.lastTime = dateTemp.getTime();
  
 The local 
 timeDifference
  value is calculated by subtracting the 
 lastTime
  value from 
 the current time (represented by the 
 dateTemp.getTime()
  return value).
  
 To calculate the 
 step
  value, divide the 
 timeDifference
  by 
 1000
  (the number of milli-
 seconds in a single second), and multiply the result by the desired frame rate. If the
  
 466 | Chapter 9:Combining Bitmaps and Sound",NA
Geo Blaster Extended Full Source,"Example 9-1. Geo Blaster Extended full source code listing
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH9EX1: Geo Blaster Extended</title> 
  
 <script src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript""> 
  
 window.addEventListener('load', eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
  canvasApp();
  
 }
  
 function canvasSupport () {
  
  return Modernizr.canvas; 
  
 }
  
 function supportedAudioFormat(audio) {
  
  
  var returnExtension = """";
  
  
  if (audio.canPlayType(""audio/ogg"") ==""probably"" || 
  
   
  audio.canPlayType(""audio/ogg"") == ""maybe"") {
  
   
  
  returnExtension = ""ogg"";
  
  
  } else if(audio.canPlayType(""audio/wav"") ==""probably"" || 
  
  
  audio.canPlayType(""audio/wav"") == ""maybe"") {
  
   
  
  returnExtension = ""wav"";
  
  
  } else if(audio.canPlayType(""audio/wav"") == ""probably"" || 
  
  
  audio.canPlayType(""audio/wav"") == ""maybe"") {
  
   
  
  returnExtension = ""mp3"";
  
  
  }
  
  return returnExtension;
  
 468 | Chapter 9:Combining Bitmaps and Sound",NA
Creating a Dynamic Tile Sheet at Runtime,"In 
 Chapter 4
 , we briefly examined two principles we can use to help eliminate the 
 need to precreate rotations of objects in tile sheets. Creating these types of tile 
 sheets can be cumbersome and use up valuable time that’s better spent elsewhere 
 in the project.
  
 The idea will be to take a single image of a game object (e.g., the first tile in the 
 medium rock tile sheet), create a “dynamic tile sheet” at runtime, and store it in an 
 array rather than using the prerendered image rotation tiles.
  
 To accomplish this, we need to make use of a second canvas, as well as the 
 getImage 
 Data()
  and 
 putImageData()
  Canvas functions. If you recall from 
 Chapter 4
 , 
 getImage 
 Data()
  will throw a security error if the HTML page using it is not on a web server.
  
 Currently, only the Safari browser will not throw this error if the file is used on a 
 local filesystem. For this reason, we have separated this functionality from the 
 Geo 
 Blaster Extended
  game and will simply demonstrate how it could be used instead of 
 replacing all the tile sheets in the game with this type of prerendering.
  
 We will start by creating two 
 <canvas>
  elements on our HTML page:
  
 <body> 
  
 <div> 
  
 <canvas id=""canvas"" width=""256"" height=""256"" style=""position: absolute; top: 50px; left: 
 50px;"">
  
  Your browser does not support HTML5 Canvas.
  
 </canvas>
  
 <canvas id=""canvas2"" width=""32"" height=""32""  style=""position: absolute; top:  256px; left: 
 50px;"">
  
  Your browser does not support HTML5 Canvas.
  
 </canvas> 
  
 </div> 
  
 </body>
  
 The first 
 <canvas>
 , named 
 canvas
 , will represent our hypothetical game screen, 
 which will be used to display the precached dynamic tile sheet animation.
  
 The second 
 <canvas>
 , named 
 canvas2
 , will be used as a drawing surface to create the 
 dynamic tile frames for our tile sheet.
  
 We will need to separate context instances in the JavaScript, one for each 
 <canvas>
 :
  
 var theCanvas = document.getElementById(""canvas""); var 
 context = theCanvas.getContext(""2d""); 
  
 var theCanvas2 = document.getElementById(""canvas2""); var 
 context2= theCanvas2.getContext(""2d"");
  
 We will use the 
 mediumrocks.png
  file (
 Figure 9-9
 ) from the 
 Geo Blaster Extended
  
 game as our source for the dynamic tile sheet. Don’t let this confuse you. We are not 
 going to use all five tiles on this tile sheet—only the first tile.
  
 Creating a Dynamic Tile Sheet at Runtime | 497",NA
A Simple Tile-Based Game,"Let’s move from 
 Asteroids
  to another classic game genre, the tile-based maze-chase 
 game. When you’re discussing early tile-based games, undoubtedly 
 Pac-Man
  enters 
 the conversation. 
 Pac-Man
  was one of the first commercially successful tile-based 
 games, although it certainly was not the first of its kind. The maze-chase genre was 
 actually well covered by budding game developers before microcomputers were 
 even thought possible. Many minicomputer and mainframe tile-based games, such 
 as 
 Daleks
 , were crafted in the ’60s and ’70s. In this section, we will create a simple 
 turn-based maze-chase game. Our game, 
 Micro Tank Maze
 , will be based loosely on 
 Daleks
 , but we will use the tank sprites from 
 Chapter 4
 . 
 Figure 9-10
  is a screenshot 
 from the finished game.",NA
Micro Tank Maze Description,"Micro Tank Maze
  is a simple turn-based strategy game played on a 15×15 tile-based 
 grid. At the beginning of each game, the player (the green tank), 20 enemy tanks 
 (the blue tanks), 25 wall tiles, and a single goal tile (the phoenix) are randomly 
 placed on the grid. The rest of the grid is simply “road” tiles on which the tanks 
 move. The player is tasked with getting to the goal object without running into any 
 walls or any of the enemy tanks. On each turn, the player and all enemy tanks will 
 move a single space (tile) on the grid. Neither the player nor the enemy tanks can 
 move off the grid edges. If the player runs into a wall tile or an enemy tank, his 
 game is over. If an enemy tank runs into a wall or another tank, it is destroyed and 
 removed from the game board. If an enemy tank runs into the player tank, it and 
 the player are destroyed. If the player hits the goal tile without an enemy tank also 
 hitting the tile on the same turn, the player wins.
  
 A Simple Tile-Based Game | 501",NA
The Tile Sheet for Our Game,"Make sure you’ve read 
 Chapter 4
  and the 
 Chapter 8
  section 
 “A Basic Game Frame-
 work” on page 400
  before moving on. Even though 
 Micro Tank Maze
  is a relatively 
 simple game, it is still quite a few lines of code. We’ll hit the major points, but we 
 don’t have space to discuss every detail.
  
 The tile sheet (
 tanks_sheet.png
 ) we are going to use will look very familiar if you’ve 
 read 
 Chapter 4
 . 
 Figure 9-11
  shows 
 tanks_sheet.png
 .
  
  
 Figure 9-11. The Micro Tank Maze tile sheet
  
 We will be using only a very small portion of these tiles for 
 Micro Tank Maze
 .
  
 Road tile 
  
 This is the tile on which the player and the enemy tanks can move. Tile 0, the 
 road tile, is in the top-left corner.
  
 Wall tile 
  
 The wall tile will cause any tank moving on it to be destroyed. Tile 30, the 
 second to last tile on the sheet, will be the wall tile.
  
 Goal tile 
  
 This is the tile the player must reach to win the game. It is the last tile in the 
 second to last row (the phoenix).
  
 Player tiles 
  
 The player will be made up of the first eight green tank tiles. Each tile will be 
 used to simulate the tank treads moving from tile to tile.
  
 Enemy tiles 
  
 The enemy will be made up of the second eight blue tank tiles. These tiles will 
 be used to animate the tank treads as it moves from tile to tile.
  
 A Simple Tile-Based Game | 503",NA
The Playfield,"The game playfield will be a 15×15 grid of 32×32 tiles. This is a total of 225 tiles 
 with a width and height of 480 pixels each. Every time we start a new game, all the 
 objects will be placed randomly onto the grid. The 
 playField[]
  array will hold 
 15
  row 
 arrays each with 
 15
  columns. This gives us 225 tiles that can be easily accessed 
 with the simple 
 playField[row][col]
  syntax.
  
 Creating the board
  
 We will first place a road tile on each of the 225 
 playField
  array locations. We then 
 randomly place all of the wall tiles (these will actually replace some of the road tiles 
 at locations in the 
 playField
  array).
  
 Next, we randomly place all of the enemy tank tiles. Unlike the wall tiles, the tank 
 tiles will 
 not
  replace road tiles in the 
 playField
  array. Instead, they will be placed 
 into an array of their own called 
 enemy
 . To ensure that neither the player nor the 
 goal object occupies the same tile space as the enemy tanks, we will create another 
 array called 
 items
 .
  
 The 
 items
  array will also be a 15×15 two-dimensional array of rows and columns, 
 which can be considered the “second” layer of playfield data. Unlike the 
 playField
  
 array, it will only be used to make sure no two objects (player, enemy, or goal) 
 occupy the same space while building the playfield. We must do this because the 
 player and enemy objects are not added to the 
 playField
  array.
  
 Once we have placed the enemy, we will randomly place the player at a spot that is 
 not currently occupied by an enemy or a wall. Finally, we will place the goal tile in a 
 spot not taken by the player, a wall, or an enemy tank.
  
 504 | Chapter 9:Combining Bitmaps and Sound",NA
The Player,"The player and all of its current attributes will be contained in the 
 player
  object. 
 Even a game as simple as 
 Micro Tank Maze
  requires quite a few attributes. Here is a 
 list and description of each:
  
 player.row 
  
  
 The current row on the 15×15 
 playField
  grid where the player resides.
  
 player.col 
  
  
 The current column on the 15×15 
 playField
  grid where the player resides.
  
 player.nextRow 
  
  
 The row the player will move to next, after a successful key press in that 
 direction.
  
 player.nextCol 
  
 The column the player will move to next, after a successful key press in that 
 direction.
  
 player.currentTile 
  
  
 The id of the current tile used to display the player from the 
 playerTiles
  array.
  
 player.rotation 
  
 The player starts pointed up, so this will be the 0 rotation. When the player 
 moves in one of the four basic directions, this rotation will change and will be 
 used to move the player in the direction it is facing.
  
 player.speed 
  
  
 The number of pixels the 
 player
  object will move on each frame tick.
  
 A Simple Tile-Based Game | 505",NA
The Enemy,"Each 
 enemy
  object will have its own set of attributes that are very similar to those of 
 the player. Like the player, each enemy will be an object instance.
  
 Here is the code from the 
 createPlayField()
  function that sets up the attributes for a 
 new 
 enemy
  object:
  
 EnemyLocationFound = true; 
  
 var tempEnemy = {}; 
  
 tempEnemy.row = randRow;",NA
The Goal,"The tile id of the goal tile will be stored in the 
 playField
  array along with the road 
 and wall tiles. It is not considered a separate item because, unlike the 
 player
  and 
 enemy 
 objects, it does not need to move. As we have described previously, since the 
 enemy and player tiles move on top of the playfield, they are considered moving 
 items and not part of the playfield.",NA
The Explosions,"The explosion tiles are unique. They will be rendered on top of the playfield when 
 an enemy tank or the player’s 
 hit
  attribute has been set to 
 true
 . The explosion tiles 
 will animate through a list of five tiles and then be removed from the game screen. 
 Again, tiles for the explosion are set in the 
 explodeTiles
  array:
  
 var explodeTiles = [17,18,19,18,17];
  
 A Simple Tile-Based Game | 507",NA
Turn-Based Game Flow and the State Machine,"Our game logic and flow is separated into 16 discrete states. The entire application 
 runs on a 
 40
  frames per second interval timer:
  
 switchGameState(GAME_STATE_INIT); 
  
 const FRAME_RATE = 40; 
  
 var intervalTime = 1000/FRAME_RATE; 
  
 setInterval(runGame, intervalTime )
  
 As with the other games, in 
 Chapter 8
  and earlier in this chapter, we will use a 
 function reference state machine to run our current game state. The 
 switchGameState() 
 function will be used to transition to a new game state. Let’s 
 begin by discussing this function briefly, and then moving through the rest of the 
 game functions.
  
  
 We will not reprint each line of code or dissect it in detail here. Use 
 this section as a guide for perusing the entire set of game code 
 included at the end of this chapter (in 
 Example 9-3
 ). By now, you 
 have seen most of the code and ideas used to create this game logic. 
 We will break out
  
 the new ideas and code in the sections that follow.
  
 GAME_STATE_INIT
  
 This state loads in the assets we need for our game. We are loading in only a single 
 tile sheet and no sounds for 
 Micro Tank Maze
 .
  
 After the initial load, it sends the state machine to the 
 GAME_STATE_WAIT_FOR_LOAD
  
 state until the load event has occurred.
  
 GAME_STATE_WAIT_FOR_LOAD
  
 This state simply makes sure that all the items in 
 GAME_STATE_INIT
  have loaded 
 properly. It then sends the state machine to the 
 GAME_STATE_TITLE
  state.
  
 GAME_STATE_TITLE
  
 This state shows the title screen and then waits for the space bar to be pressed. 
 When this happens, it sends the state machine to 
 GAME_STATE_NEW_GAME
 .
  
 GAME_STATE_NEW_GAME
  
 This state resets all of the game arrays and objects and then calls the 
 createPlay 
 Field()
  function. The 
 createPlayField()
  function creates the 
 playField
  and 
 enemy
  ar-
 rays for the new game, as well as sets the 
 player
  object’s starting location. Once it 
 has",NA
Simple Tile Movement Logic Overview,"Micro Tank Maze
  employs simple tile-to-tile movement using the “center of a tile” 
 logic. This logic relies on making calculations once the game character has reached 
 the center of a tile. The origin point of our game character tiles is the top-left 
 corner. Because of this, we can easily calculate that a game character is in the 
 center of a tile when its 
 x 
 and 
 y
  coordinates are equal to the destination tile’s 
 x
  and 
 y
  coordinates.
  
 When the user presses a movement key (up, down, right, or left arrow), we first 
 must check whether the player is trying to move to a “legal” tile on the 
 playField
 . In 
 Micro Tank Maze
 , all tiles are legal. The only illegal moves are off the edges of the 
 board. So, if the player wants to move up, down, left, or right, we must first check 
 the 
 tile 
 in 
 that 
 direction 
 based 
 on 
 the 
 key 
 pressed 
 in 
 the 
 gameStateWaitForPlayerMove()
  function. Here is the switch statement used to 
 determine whether the player pressed an arrow key:
  
 if (keyPressList[38]==true){
  
  
  
  //up
  
  
  
  if (checkBounds(-1,0, player)){
  
  
  
  setPlayerDestination();
  
  
  
  }
  
  
  }else if (keyPressList[37]==true) {
  
  
  
  //left
  
  
  
  if (checkBounds(0,-1, player)){
  
  
  
  setPlayerDestination();
  
  
  
  }
  
  
  }else if (keyPressList[39]==true) {
  
  
  
  //right
  
  
  
  if (checkBounds(0,1, player)){
  
  
  
  setPlayerDestination();
  
  
  
  }
  
  
  }else if  (keyPressList[40]==true){
  
  
  
  //down
  
  
  
  if (checkBounds(1,0, player)){
  
  
  
  setPlayerDestination();
  
  
  
  }
  
  
  }",NA
Rendering Logic Overview,"Each time the game renders objects to the screen, it runs through the entire 
 render() 
 function. It does this to ensure that even the nonmoving objects are 
 rendered back to the game screen. The 
 render()
  function looks like this:
  
 function renderPlayField() {
  
  
  fillBackground();
  
  
  drawPlayField();
  
  
  drawPlayer();
  
  
  drawEnemy();
  
  
  drawExplosions(); 
  
 }
  
 First, we draw the plain black background, then we draw the 
 playField
 , and after 
 that we draw the game objects. 
 drawPlayField()
  draws the map of tiles to the game 
 screen. This function is similar to the functions in 
 Chapter 4
 , but with some 
 additions for our game. Let’s review how it is organized:
  
 function drawPlayField(){
  
  
  for (rowCtr=0;rowCtr<15;rowCtr++){
  
  for (colCtr=0;colCtr<15;colCtr++) {
  
  var sourceX = Math.floor((playField[rowCtr][colCtr]) % 8) * 32; var 
 sourceY = Math.floor((playField[rowCtr][colCtr]) /8) *32;
  
  }
  
  
  if (playField[rowCtr][colCtr] != roadTile){
  
    
  context.drawImage(tileSheet, 0, 0,32,32,colCtr*32,rowCtr*32,32,32);
  
  }
  
  
  context.drawImage(tileSheet, sourceX, sourceY, 32,32, 
  
   
  colCtr*32,rowCtr*32,32,32);
  
   
  }
  
  }
  
 514 | Chapter 9:Combining Bitmaps and Sound",NA
Simple Homegrown AI Overview,"The enemy tanks chase the 
 player
  object based on a set of simple rules. We have 
 coded those rules into the 
 gameStateEnemyMove()
  function, which is one of the 
 longest and most complicated functions in this book. Let’s first step through the 
 logic used to create the function, and then you can examine it in 
 Example 9-3
 .
  
 This function starts by looping through the 
 enemy
  array. It must determine a new 
 tile location on which to move each enemy. To do so, it follows some simple rules 
 that determine the order in which the 
 testBounds()
  function will test the movement 
 directions:
  
 1. First, it tests to see whether the player is closer to the enemy vertically or 
 horizontally.
  
 2. If vertically, and the player is above the enemy, it places 
 up
  and then 
 down
  into 
 the 
 directionsToTest
  array.
  
 3. If vertically, and the player is below the enemy, it places 
 down
  and then 
 up
  into 
 the 
 directionsToTest
  array.
  
  
 The 
 up
  and then 
 down
 , or 
 down
  and then 
 up
 , directions are 
 pushed into the 
 directionsTest
  array to simplify the AI. The logic 
 here is if the player is “up” from the enemy, but the enemy is 
 blocked by an object, the enemy will try the opposite direction 
 first. In our
  
 game, there will be no instance where an object blocks the 
 direction the enemy tank wants to move in. This is because the 
 only illegal direction is trying to move off the bounds of the 
 screen. If we add tiles to our playfield that “block” the enemy, 
 this entire set of AI code suddenly becomes very useful and 
 necessary. We have inclu-ded this entire “homegrown chase AI” 
 in our game in case more of these tile types are added.
  
 4. It then looks to see where to add the 
 left
  and 
 right
  directions. It does this based 
 on which way will put it closer to the player.
  
 5. If the horizontal direction and not the vertical direction is the shortest, it runs 
 through the same type of logic, but this time using 
 left
  and then 
 right
 , then 
 up 
 and then 
 down
 .
  
 6. When this is complete, all four directions will be in the 
 directionsToTest
  array.
  
 A Simple Tile-Based Game | 515",NA
Micro Tank Maze Complete Game Code,"Example 9-3. Micro Tank Maze full source code listing
  
  <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH(EX3: Micro Tank Maze Game</title> 
  
 <script src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript""> 
  
 window.addEventListener('load', eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
 }
  
  canvasApp();
  
 function canvasSupport () { 
  
 return Modernizr.canvas; 
  
 }
  
 function canvasApp(){
  
  if (!canvasSupport()) {
  
    
  return;
  
  
  }else{
  
   
  theCanvas = document.getElementById(""canvas"");
  
  
  context = theCanvas.getContext(""2d"");
  
  }
  
  //application states
  
  const GAME_STATE_INIT = 0;
  
  const GAME_STATE_WAIT_FOR_LOAD = 10;
  
  const GAME_STATE_TITLE = 20;
  
  const GAME_STATE_NEW_GAME = 30;
  
  const GAME_STATE_WAIT_FOR_PLAYER_MOVE = 
 40;
  
  const GAME_STATE_ANIMATE_PLAYER = 50;
  
  const GAME_STATE_EVALUATE_PLAYER_MOVE = 
 60;
  
  const GAME_STATE_ENEMY_MOVE = 70;
  
  const GAME_STATE_ANIMATE_ENEMY = 80;
  
  const GAME_STATE_EVALUATE_ENEMY_MOVE = 
 90;
  
  const GAME_STATE_EVALUATE_OUTCOME = 100;
  
  const GAME_STATE_ANIMATE_EXPLODE = 110;
  
  const GAME_STATE_CHECK_FOR_GAME_OVER = 
 120;",NA
What’s Next,"Throughout this entire book, we have used game- and entertainment-related 
 subjects to demonstrate canvas application building concepts. Over these last two 
 chapters, we’ve sped up the game discussion and covered many game concepts 
 directly by cre-ating two unique games and optimizing a third with bitmaps and 
 object pooling. In doing so, we have applied many of the concepts from the earlier 
 chapters in full-blown game applications. The techniques used to create a game on 
 Canvas can be applied to almost any canvas application from image viewers to 
 stock charting. The sky is really the limit, as the canvas allows the developer a full 
 suite of powerful low-level capabilities that can be molded into any application.
  
 In 
 Chapter 10
 , we will look at porting a simple game from the canvas into a native 
 iPhone application.
  
 534 | Chapter 9:Combining Bitmaps and Sound",NA
CHAPTER 10,NA,NA
Mobilizing Games with ,NA,NA
PhoneGap,NA,NA
Going Mobile!,"Nowadays it seems that everyone is making, planning to make, or thinking of 
 making applications for mobile devices. Mobile is the next great (or maybe actually 
 the current) place to make money by selling applications. The Apple iPhone is 
 currently one of the most popular personal communication devices, and the iTunes 
 Store gives budding application developers a place to show and sell the fruits of 
 their labor. Apple separates their application-development platforms into three 
 categories: Desktop (OS X), Browser (Safari), and iPhone/iPad/iPod Touch (iOS).
  
 Most iOS applications, especially games, are written in Objective-C and compiled di-
 rectly to the platform using the Xcode IDE. This is a large barrier to entry to 
 develop native applications, as Objective-C is not widely used on platforms other 
 than Apple devices. Up until early 2010, Objective-C/Xcode was the only viable 
 development sys-tem for targeting iOS development.
  
 In this chapter, we will “port” our HTML5 Canvas application to the iPhone using a 
 technology called PhoneGap. PhoneGap allows an HTML application to run natively 
 on an iPhone by packaging the application as a Safari Mobile “app.” This app can be 
 run from the iPhone interface, and it will look and act like an app compiled in 
 Objective-C. Applications packaged with PhoneGap can even be sold in the iTunes 
 Store.
  
  
 Other third-party tools can be used to create iOS applications and 
 games. For example, Unity (
 http://unity3d.com/
 ) is a powerful 
 game-development platform that can target iOS. In addition, there 
 are 
 tools 
 such 
 as 
 Ansca’s 
 Corona 
 SDK 
 (
 http://www.anscamobile.com/
 ) that use
  
 scripting languages to harness the power of the platform.",NA
Introducing PhoneGap,"PhoneGap is an open source development tool created by Nitobi (
 http://www.nitobi 
 .com
 ) that acts as a software bridge between standards-based HTML development 
 and several mobile platforms. Using PhoneGap, the HTML5 Canvas developer has 
 access to the various hardware APIs for supported devices through an 
 abstraction 
 layer
 . This software interface allows the same code to be used to target features 
 common among various devices—such as geolocation, touch screens, microphones, 
 and other hardware capabilities—so that separate code does not need to be written 
 for each device.
  
  
 You will need an Intel-based Macintosh running Xcode to be able to 
 compile a PhoneGap project. There currently is no development 
 plat-form for Windows that will allow compiling Safari Mobile 
 applications
  
 to the iOS platform with an Objective-C wrapper.
  
 We won’t target too many specific iPhone features in this chapter. In the allotted 
 space, we will cover the basics needed to take a simple application and get it up and 
 running in the iPhone simulator, and then onto a physical device. We will then 
 implement an accelerometer feature into our application.
  
  
 For further reading, Jonathan Stark’s 
 Building iPhone Apps with 
 HTML, CSS, and JavaScript
  (O’Reilly) covers PhoneGap and hardware 
 feature API integration in detail. If you’d rather try this with 
 Android, explore the similar 
 Building Android Apps with HTML, CSS, 
 and JavaScript
  
 (O’Reilly), also by Jonathan Stark, which applies PhoneGap to create 
 applications for Android.",NA
The Application,"The application we are going to create is a simple 
 BS Bingo
  game. BS Bingo was 
 designed on paper well before mobile devices were available. This cynical game 
 concept is based on the feeling (by some) that the typical business workplace has 
 been overtaken with 
 Dilbert-
  or 
 Office Space
 -esque annoying corporate jargon and 
 doublespeak. This dou-blespeak seems to have deeply rooted itself in the 
 workplace over the last 20 years, mostly to the annoyance of software developers 
 (such as ourselves).
  
 In the pen-and-paper version of the game, each player brings a “bingo card” to a 
 meeting where he expects to hear a lot of this corporate doublespeak. The bingo 
 card is a 5×5 grid, and each of the 25 squares is filled with one of the annoying 
 words or jargon phrases. During the meeting, each player marks off squares as the 
 words or phrases are said aloud by the unsuspecting (and not playing) members of 
 the meeting. When a player has a full column of his card marked off, he is supposed 
 to jump up from the meeting table and yell “BS!”",NA
The Code,"Example 10-1
  gives the code for our game. We’ll discuss the various functions in 
 the next section before we move on to installing, modifying, and testing it in Xcode 
 using PhoneGap. This version of the game will work fine on a Safari desktop 
 browser. We will highlight the modifications necessary to port it to the iPhone in 
 the next section.
  
 Example 10-1. BSBingo.html full source listing
  
 <!doctype html>
  
  <html lang=""en"">
  
  <head>
  
  
  <meta charset=""UTF-8"">
  
  <title>BS Bingo</title>
  
  <script src=""modernizr-1.6.min.js""></script>
  
  <script src=""TextButton.js""></script>
  
  <script src=""ConsoleLog.js""></script>
  
  <script type=""text/javascript"">
  
  window.addEventListener('load', eventWindowLoaded, false); 
 function eventWindowLoaded() {
  
  canvasApp();
  
  }
  
  function canvasSupport () {
  
  
  return Modernizr.canvas;
  
  }
  
  function canvasApp(){
  
  if (!canvasSupport()) {
  
     
  return;
  
  
  }else{
  
   
  theCanvas = document.getElementById(""canvas"");
  
   
  context = theCanvas.getContext(""2d"");
  
  }
  
  var bingoCard = [];
  
  var buttons = [];
  
  var standardJargonList = [];
  
  var tempButton = {};
  
  var clickSound;",NA
Examining the Code for BSBingo.html,"When designing an application for the iPhone using PhoneGap, we 
 are actually targeting the Safari Mobile browser. This means we can 
 make concessions rather than having to target all available HTML5-
 compatible devices. You will notice this especially when we discuss
  
 <audio>
  tag usage.
  
 The TextButton.js file
  
 Our BS Bingo game will be played on a grid of 25 squares. We created a class (an 
 object prototype, actually) called 
 TextButton.js
  to help us create buttons with the 
 text, as well as a “press” state we can use to show that the button has been clicked. 
 You will want to save this file in the project folder along with the 
 BSBingo.html
  file. 
 Here is the code for this file:
  
 function TextButton(x,y,text, width, height, backColor, strokeColor,  overColor, 
 textColor){
  
  
  this.x = x;
  
  
  this.y = y;
  
  
  this.text = text;
  
  
  this.width = width;
  
  
  this.height = height;
  
  
  this.backColor = backColor;
  
  
  this.strokeColor = strokeColor;
  
  
  this.overColor = overColor;
  
  
  this.textColor = textColor;
  
  
  this.press = false; 
  
 }
  
 TextButton.prototype.pressDown=function() {
  
  
  if (this.press==true){
  
  
  
  this.press = false;
  
 542 | Chapter 10:Mobilizing Games with PhoneGap",NA
The Application Code,"Once all the functions and the 
 TextButton
  object prototype are created, the actual 
 ap-plication code is very simple. Because this is a completely event-based 
 application, we don’t need a main loop. We also have not put in any other states or 
 buttons, such as a title screen or a reset button. This makes the app less user-
 friendly, but it is fine for this simple example. It also makes the application code 
 very simple:
  
  //**** start application
  
  
  var gr = context.createLinearGradient(0, 0, 100, 100);
  
  // Add the color stops.
  
  gr.addColorStop(0,'#ffffff');
  
  gr.addColorStop(.5,'#bbbbbb');
  
  gr.addColorStop(1,'#777777');
  
  theCanvas.addEventListener(""mousemove"", onMouseMove, false); 
 theCanvas.addEventListener(""click"", onMouseClick, false); 
 initSounds();
  
  initButtons();
  
  initLists();
  
  chooseButtonsForCard();
  
  drawScreen();
  
 First, we create a shared linear gradient that can be used by all the 
 TextButton
  
 instances. Next, we add the mouse event listeners for click and move. Finally, we 
 run through our functions to set up the card, and then we simply wait for the user 
 to click a button. That’s all there is to it. We haven’t even added a way to announce 
 that the player has won. Extending this into a full-fledged application would be very 
 simple, so we leave this task up to the reader if you have the desire to do so.
  
 Figure 10-1
  shows the screen for the finished application.
  
 Going Mobile! | 545",NA
Creating the iOS Application with ,NA,NA
PhoneGap,"You will need to install and set up two tools to get an iOS application up and 
 running on your iOS device simulator: Xcode, a free application development IDE 
 from Apple, and PhoneGap. Let’s start with Xcode.",NA
Installing Xcode,"Xcode actually comes packaged on the installable operating system DVD for Snow 
 Leopard, but this version will not be as up-to-date as the version available on the 
 Apple developer website.
  
 First, 
 you 
 will 
 want 
 to 
 visit 
 the 
 iOS 
 Developer 
 Center: 
 http://developer.apple.com/dev center/ios/index.action
 . Once there, you can create 
 a free user account, which you will need to download Xcode and the latest iOS 
 developer SDK. You will also need to create a paid account if you would like to test 
 or deploy on a physical device and/or sell your application in the iTunes Store. You 
 do not need a paid account to build and test your application in the SDK and the 
 included iOS device simulators.
  
 Download and install the latest version of Xcode and the iOS SDK. This is a large 
 download (3.5 GB at the time of this writing). See 
 Figure 10-2
 .",NA
Installing PhoneGap,"Download PhoneGap from 
 https://github.com/phonegap/phonegap
 , choosing the 
 ZIP file option, as shown in 
 Figure 10-3
 .
  
 The file will most likely be saved into your Mac Downloads folder. Unpack this ZIP 
 file in a safe location, such as the desktop.
  
 Inside the ZIP, you will find a series of folders for various devices. We are interested 
 in the iOS folder. 
 Figure 10-4
  illustrates this folder structure.
  
 Creating the iOS Application with PhoneGap | 547",NA
Creating the BS Bingo PhoneGap Project in Xcode ,"To begin, launch Xcode and create a new PhoneGap project. See 
 Figure 10-5
  for an 
 example of the New Project screen.
  
 Select the PhoneGap-based application and click the Choose button.
  
 You will next be asked to save the project in a location and give it a name. We will 
 use the name 
 chapter10_bs_bingo
 .
  
 You will be presented with a screen that resembles 
 Figure 10-6
 .
  
 On the lefthand side, you will find a folder called “www”. This is the most important 
 folder because it is where we will place all of the files for our game. Before we do 
 that, we need to make sure that the SDK is set to the correct version. In the top left, 
 you might see a drop-down with the words “Base SDK Missing” (as shown in 
 Fig-
 ure 10-6
 ). This means that we will not be able to build and compile our game until 
 we choose an SDK.
  
 Creating the iOS Application with PhoneGap | 549",NA
Testing the New Blank Application in the Simulator,"We are now ready to build our first application and see it in the simulator. We have 
 not added any of our own code yet (though we will in the next section), so we will 
 be testing the contents of the 
 index.html
  file in the project’s www folder. Simply 
 click the“Build and Run” button at the top of the IDE. If everything is set up 
 properly, the simulator will come up with a blank screen, as shown in 
 Figure 10-9
 .
  
 Creating the iOS Application with PhoneGap | 551",NA
Integrating BS Bingo into the Project,"We are now going to copy code from the 
 BSBingo.html
  file we created earlier into 
 the 
 index.html
  file in our project.
  
 First we will copy our JavaScript include files and add them under the 
 phonegap.js
  
 script include. We will not need the 
 modernizer.js
  file, as we will assume the iOS 
 platform can use HTML5 Canvas:
  
 <script type=""text/javascript"" charset=""utf-8"" src=""phonegap.js""></script> <script 
 src=""TextButton.js""></script> 
  
 <script src=""ConsoleLog.js""></script>
  
 The 
 phonegap.js
  file should already be included in the www folder, along with 
 index.html
 . It is part of the project template and is needed for all PhoneGap iOS 
 applications.
  
 Next, we will need to add the call to start our application into the 
 deviceReady() 
 function:
  
 /*When this function is called, PhoneGap has been initialized and is ready to roll*/
  
  
 function onDeviceReady()
  
  
  {
  
   
  // do your thing!
  
  
 canvasApp();
  
  }
  
 We can now replace the rest of the 
 script
  code in the file with our code.
  
  
 At this step, don’t replace from the 
 <body>
  tag down to the end of 
 the 
 <html>
 . Just add the game code inside the 
 <script>
  tags. You can 
 use the existing 
 <script></script>
  tags; if you do, be careful not to 
 copy
  
 them from 
 BSBingo.html
 .
  
 Make sure that the first few lines look like this because we are removing the check 
 for Canvas support:
  
 function canvasApp(){
  
  theCanvas = document.getElementById(""canvas""); 
 context = theCanvas.getContext(""2d"");
  
  var bingoCard = [];
  
  var buttons = [];
  
  var standardJargonList = [];
  
  var tempButton = {};
  
  var clickSound;
  
 Creating the iOS Application with PhoneGap | 553",NA
Setting the Orientation,"It is important to note that Safari Mobile and iOS applications render the screen in 
 different ways. A Safari Mobile application can be set to automatically scale to fit in 
 the iOS device’s window, while a pure iOS application needs to be coded to fit the 
 size of the target device. If an application targeted to the iOS platform is taller or 
 wider than the device, the application will automatically be put into “scroll” mode.
  
 We set the width of our application to be 570 and the height to be 418. The height 
 will fit fine in either Landscape or Portrait orientation, but the width will only fit in 
 Land-scape (without scrolling). For this reason, we will want our application to run 
 in Landscape mode only.
  
 To set the application to default to Landscape and not allow Portrait, we must make 
 some changes to a file called 
 chapter10_bs_bingo-info.plist
 , which is in the root 
 folder (the parent of the www folder) for our project.
  
 Creating the iOS Application with PhoneGap | 555",NA
Changing the Banner and Icon,"We have the option of changing the startup banner and “desktop” icon for our appli-
 cation to customized graphics.
  
 In the root folder of our project, we will customize two image files. 
 default.png
  is 
 the banner image that shows up when the application starts. 
 icon.png
  is the 
 “desktop” icon that remains on the iOS device just like any other installed 
 application.
  
 556 | Chapter 10:Mobilizing Games with PhoneGap",NA
Testing on the Simulator,"Our project is set to target the iPhone (not iPad). Before we test, we must make 
 sure that we target that platform in the simulator. To do this, choose the iPhone 
 simulator from the SDK drop-down menu at the top left of the Xcode screen, as 
 shown in 
 Figure 10-15
 .
  
 558 | Chapter 10:Mobilizing Games with PhoneGap",NA
Adding in an iPhone “Gesture”,"The PhoneGap API allows us to add in control over various iOS features, such as 
 vibrate, geolocation, and accelerometer. We will target one of these features by 
 adding code that will wipe our board clean and create a fresh new game when the 
 phone is shaken.
  
 To do this, we will look for changes to the device’s physical location in space (using 
 JavaScript), and then simply call our existing 
 chooseButtonsForCard()
  and 
 drawScreen()
  functions to refresh the card.
  
 First, we need to add a single line to the 
 chooseButtonsForCard()
  function that will set 
 all the 
 buttons
  instances’ 
 press
  attributes to 
 false
 :
  
 function chooseButtonsForCard(){
  
  
  //copy jargon into temp array
  
  
  var tempArray = [];
  
  
  for (var arrayctr=0;arrayctr<standardJargonList.length;arrayctr++){
  
  
  tempArray.push(standardJargonList[arrayctr]);
  
  
  }
  
  for (var ctr1=0;ctr1<buttons.length;ctr1++){
  
  }
  
  for (var ctr2=0; ctr2<buttons[ctr1].length;ctr2++){
  
  
  var randInt = Math.floor(Math.random()*tempArray.length)
  
  buttons[ctr1][ctr2].text = tempArray[randInt]; 
  
  
  
 buttons[ctr1][ctr2].press = false;
  
  
  tempArray.splice(randInt,1);
  
  }
  
  }
  
 Next, we need to add a function that will listen for the iOS “shake” event, and then 
 refresh the card.
  
 Apple makes it pretty easy to test for changes in the 
 x
 , 
 y
 , and 
 z
  coordinate spaces of 
 an iOS device (and PhoneGap makes it even easier), but acting on this information 
 is a little tricky and will require the use of an actual device for testing.
  
  
 At the time of this writing, a PhoneGap Adobe AIR iPhone simulator 
 was available that goes beyond the limited shake gestures available 
 in the SDK simulator. If you do not have a device to test with, we 
 recom-mend 
 trying 
 this 
 emulator. 
 It 
 can 
 be 
 found 
 at 
 http://blogs.nitobi.com/
  
 yohei/2009/04/01/phonegap-air-simulator-in-development/
 .",NA
Adding the Gesture Functions to index.html,"Inside the 
 canvasApp()
  function, we will need to add a series of functions and a 
 variable to use in testing the iPhone’s accelerometer, which detects movement in 
 our application.
  
 Creating the iOS Application with PhoneGap | 561",NA
Testing on a Device,"Before we can test the application on an actual device, we need to “provision” the 
 device. To do this, we will need the device, a paid iOS developer account, and a de-
 velopment Mac computer all synced up into a single provisioning profile. This 
 neces-sary process is not for the faint of heart.
  
 Step 1: Launch the Provisioning Assistant
  
 Begin by visiting the Developer Provisioning Assistant (
 http://developer.apple.com/ 
 iphone
 ) and logging in with your paid iOS developer ID. Once logged in, click on the 
 link for the “iOS Provisioning Portal” (currently in the upper-right side menu). 
 There should be a button called “Launch the Provisioning Assistant.” Click on this 
 button and follow all the on-screen instructions.
  
 Step 2: Find the device’s Unique ID
  
 You will be asked to find the Unique ID of your physical device. This is found by 
 plugging the device into your computer, and then looking up the ID in Xcode. In the 
 Window
 →
 Organizer Information window, you will see a list of the attached 
 devices. The ID will be a long alphanumeric string next to the word Identifier.
  
 Creating the iOS Application with PhoneGap | 563",NA
Using Xcode to Target a Test Device,"We will need to change the build profile to target the attached device rather than 
 the simulator. To do this, we simply change the drop-down in the upper left from 
 Simulator to Device, as shown in 
 Figure 10-18
 .
  
 564 | Chapter 10:Mobilizing Games with PhoneGap",NA
Beyond the Canvas,"A nice set of tools and frameworks are available (with more emerging every day) 
 that can help transform the look and feel of HTML or an HTML5 application (not 
 neces-sarily just on Canvas) into an iPhone-like application. These can be used in 
 conjunction with a canvas app to provide a seamless iPhone look and feel for the 
 user.
  
 Beyond the Canvas | 565",NA
What’s Next,"As you can see, HTML5 Canvas is a powerful and easy way to target native apps 
 across a variety of mobile devices. In this chapter, we built a small game to run in 
 the Safari browser, and then installed PhoneGap and modified the application to 
 run on the iPhone simulator using an Xcode project template. Once the simulation 
 was successful, we added in a device-specific accelerometer feature, and then 
 provisioned a physical device for testing. Finally, we were able to see our 
 completed application running on an actual iOS device.
  
 In 
 Chapter 11
 , we will look at applying multiplayer capabilities to a canvas 
 application using ElectroServer, and we’ll even take a small tour of 3D in Canvas.
  
 566 | Chapter 10:Mobilizing Games with PhoneGap",NA
CHAPTER 11,NA,NA
Further Explorations,"There are many emerging technologies and frameworks that can help take HTML5 
 Canvas into rarely explored areas. In this chapter, we will cover a couple of those 
 areas: using Canvas for 3D with WebGL, and using Canvas for multiplayer 
 applications. Both of these areas are still experimental, requiring you to either 
 download beta/developer versions of browsers, or launch browsers using 
 command-line switches so you can turn various technologies off and on.
  
 This chapter is structured a bit differently. The discussions are focused on giving 
 you some tools and information about these new and emerging areas for Canvas. 
 While we will offer code, examples, and some explanation, it’s geared more toward 
 getting you started on the path to learning than on teaching you how every detail 
 works. We have structured these two topics in this way for one very simple reason: 
 they are incom-plete
 . With APIs, libraries, locations, browsers, names, etc., all 
 subject to change, we are not comfortable presenting these topics as finished and 
 ready to go. You need to approach this chapter knowing that things are bound to go 
 wrong or change frequently.
  
 Having said that, even though these topics are experimental, that does not mean 
 you cannot use them right now, nor does it mean they are not useful or capable of 
 doing very cool things. You just need to be aware of the pitfalls before treading 
 forward.",NA
3D with WebGL,"The 2D capabilities of HTML5 Canvas are impressive, but what about 3D? There is 
 no“production” 3D context available in the standard version of any web browser at 
 this time. However, the best support for a 3D context will probably come in the 
 form of WebGL.
  
 567",NA
What Is WebGL?,"WebGL is a JavaScript API that gives programmers access to the 3D hardware on 
 the user’s machine. Currently, it is only supported by the debug/development 
 versions of Opera, Firefox, and Chrome. The API is managed by Kronos, the same 
 organization that manages OpenGL. In fact, much of WebGL is similar to 
 programming in OpenGL. This is both good and bad. It’s good because it’s a 
 standard programming interface that is recognizable to many developers, but bad 
 because it is not as easy to learn as the 2D Canvas context.",NA
How Do I Test WebGL?,"First, you need to find a web browser that supports WebGL. When trying to run a 
 WebGL application, a browser that does not support WebGL might give a message 
 like the one shown in 
 Figure 11-1
 .
  
  
 Figure 11-1. Trying to run WebGL in a standard web browser
  
  
 Chromium, the open source version of Chrome, will display WebGL. 
 You can download the latest development build of Chromium from 
 http://build.chromium.org/f/chromium/continuous/
 .
  
 Once you have a browser that can display WebGL, you need to write the code to 
 make it happen. You start that process by accessing the WebGL context instead of 
 the Canvas 
 2d
  context. So, instead of this code, which we have used throughout this 
 book:
  
 context = theCanvas.getContext(""2d"");
  
 We reference the 
 experimental-webgl
  context, like this:
  
 gl = theCanvas.getContext(""experimental-webgl"");
  
 568 | Chapter 11:Further Explorations",NA
How Do I Learn More About WebGL?,"The best place to learn about WebGL is at 
 http://learningwebgl.com/
 . This site has 
 an FAQ, a blog, and some helpful low-level lessons on how to create apps using 
 WebGL. You can also find a ton of great content about WebGL at 
 http://developer.mozilla.org
 .
  
 One warning, though: programming WebGL is not for the uninitiated. Although 
 WebGL is based on OpenGL, it is still a very low-level API, meaning you will need to 
 create everything by hand. At the end of this section, we will guide you toward 
 some higher-level libraries that should make this process a bit easier.",NA
What Does a WebGL Application Look Like?,"Now we are going to show you a WebGL application demo that rotates a 3D cube on 
 Canvas (see 
 Figure 11-2
 ). Since we are not experts in 3D graphics, we will forgo our 
 practice of describing every line of code in the example; instead, we will highlight 
 in-teresting sections of code to help you understand what is happening.
  
 This demo is based on Lesson 4 from Giles Thomas’s Learning WebGL website 
 (
 http: //learningwebgl.com/blog/?p=370
 ). While this is only one short demo, it 
 should give you a very good idea of how to structure and build code for a WebGL 
 application.
  
  
 Much of this code has been adapted from the work of Giles Thomas 
 with his expressed, written permission.
  
 JavaScript libraries
  
 First, we add some JavaScript libraries. Modernizr 1.6 includes a test for WebGL 
 sup-port in a web browser. This version was freshly released, but it could be 
 updated with new features at any time (in fact, at the time of this writing, this had 
 been updated to version 1.7). It is necessary to make sure you have the most recent 
 versions of your libraries:
  
 <script src=""modernizr-1.6.min.js""></script>
  
 We now need to include some JavaScript libraries to assist with our application. 
 sylvester.js
  and 
 glUtils.as
  are two libraries that you will find included for most apps 
 that use WebGL. 
 sylvester.js
  (
 http://sylvester.jcoglan.com/
 ) is a library that helps 
 when per-forming vector and matrix math calculations in JavaScript. 
 glUtils.as
  is an 
 extension for 
 sylvester.js
 , specifically for helping with math related to WebGL:
  
 <script type=""text/javascript"" src=""sylvester.js""></script> <script 
 type=""text/javascript"" src=""glUtils.js""></script>",NA
Full Code Listing,"Example 11-1
  gives the full code listing for 
 CH11EX1.html
 . Notice that many of the 
 code styles and constructs we have used over the past 10 chapters are still in place 
 in this application. Besides the obvious inclusion of code related directly to WebGL, 
 this application operates essentially the same way as the other apps we discussed 
 in this book.
  
 Example 11-1. WebGL test
  
 <!doctype html> 
  
 <html lang=""en""> 
  
 <head> 
  
 <meta charset=""UTF-8""> 
  
 <title>CH11EX1: WebGL Test </title> 
  
 <script src=""modernizr-1.6.min.js""></script> 
  
 <script type=""text/javascript"" src=""sylvester.js""></script> <script 
 type=""text/javascript"" src=""glUtils.js""></script>
  
 <script id=""shader-fs"" type=""x-shader/x-fragment""> #ifdef 
 GL_ES
  
  precision highp float;
  
  #endif
  
  varying vec4 vColor;
  
  
  void main(void) {
  
   
  gl_FragColor = vColor;
  
  
  } 
  
 </script>
  
 <script id=""shader-vs"" type=""x-shader/x-vertex""> 
 attribute vec3 aVertexPosition;
  
  attribute vec4 aVertexColor;
  
  uniform mat4 uMVMatrix;
  
  uniform mat4 uPMatrix;
  
  varying vec4 vColor;
  
 3D with WebGL | 575",NA
Further Explorations with WebGL,"Obviously, we cannot teach you all about WebGL in this chapter. We opted to 
 include this demo and short discussion to introduce you to WebGL and show you 
 what it looks like. In reality, a full discussion of WebGL, even the basic concepts, 
 could take up an entire volume.
  
 If you are interested in WebGL, we strongly recommend you consult 
 http://learning 
 webgl.com
  for more examples and the latest information about this exciting yet still 
 experimental context for HTML5 Canvas.",NA
WebGL JavaScript Libraries,"At the start of this section, we promised to show you some libraries that can be 
 used with WebGL to make it easier to develop applications. Here are some of the 
 more interesting libraries and projects.
  
 Google O3D
  
 Google’s O3D library (
 http://code.google.com/p/o3d/
 ) was once a browser plug-in 
 but has now been released as a standalone JavaScript library for WebGL. The 
 examples of using O3D with JavaScript—including a fairly spectacular 3D pool 
 game—are very
  
 3D with WebGL | 581",NA
Multiplayer Applications with ,NA,NA
ElectroServer 5,"The extended HTML5 specification includes an API for what is known as 
 WebSockets
 . Socket communications allow a client application to remain constantly 
 connected to a server-aide application. This type of communication can be 
 especially useful for chat, multiplayer games, e-learning applications, and multiuser 
 whiteboards, as well as many others. At this point, WebSockets is just a promise 
 with very little support beyond test and development builds of web browsers. In 
 fact, security concerns have halted some implementations and slowed others. 
 However, this does not mean you cannot make use of socket-server applications 
 with HTML5 Canvas.
  
 Because Flash has built-in support for communication via sockets, its applications 
 have had the ability to open socket communications with server-side applications 
 for many years. HTML, on the other hand, has never had the ability to reliably 
 communicate to a socket server without performing some sleight of hand, usually 
 involving constant polling by the web browser for new information from the web 
 server.
  
 ElectroServer from Electrotank was one of the first reliable socket-server 
 applications built to communicate with Flash clients. Over the past couple years, 
 ElectroServer has been updated with APIs for iOS, C#, C++, and now JavaScript. This 
 first iteration of the ElectroServer JavaScript API does not use WebSockets, but 
 instead implements JavaScript polling. However, with the availability of 
 ElectroServer’s simplified Java-Script API, you can still start to write multiplayer 
 applications using HTML5 Canvas.
  
  
 While this portion of the chapter is specific to ElectroServer, many 
 of the multiplayer/multiuser concepts are applicable to other 
 technologies as well.",NA
Installing ElectroServer,"To get started with multiplayer development using HTML5 Canvas and the Electro-
 Server socket server, you first need to download the free, 25-user version of the 
 software from Electrotank. You can download the appropriate version for your 
 operating 
 system 
 (Windows, 
 Mac, 
 Linux) 
 at 
 http://www.electrotank.com/resources/downloads.html
 .",NA
The Basic Architecture of a Socket-Server ,NA,NA
Application,"Now that you have ElectroServer ready to go, and you have the JavaScript API, it is 
 time to learn a bit about how socket-server-based multiplayer/multiuser 
 applications are designed. Using a socket server means you are creating an 
 application that relies on a client for input from a user, as well as relying on a 
 server to distribute that input to other users who are connected to the first user.
  
 A good example of this is a chat application. Most chat applications require a user to 
 enter a 
 room
  (a logical space in which people are “chatting,” i.e., exchanging 
 messages),",NA
The Basic Architecture of an ElectroServer ,NA,NA
Application,"ElectroServer acts very much like the socket-server application we described in the 
 previous section. It listens on specified ports for different protocols; when 
 messages arrive, they are routed back to the connected clients.
  
 However, ElectroServer has some specific features that we should discuss. Some of 
 these exist on other socket-server platforms, while some don’t. However, much of 
 this discussion will still be applicable to other socket servers once they make 
 JavaScript APIs available.
  
 Client
  
 The client for an ElectroServer application is a program written in one of the API-
 supported language platforms, including Flash ActionScript 2, Flash ActionScript 3, 
 Java, Objective-C, C#/.NET, and now JavaScript. The client is the application, which 
 the user will manipulate to send messages through the API to ElectroServer. This is 
 usually a game, a chat room, a virtual world, or some other kind of multiuser social 
 or communication application.
  
 All the communication with ElectroServer is 
 event
 -based. The client application 
 uses the JavaScript API to send events, and the client defines event handlers that 
 listen for messages from ElectroServer. All of these messages and events are 
 communicated through the API, which in turn is communicating through port 8989 
 using the BinaryHTTP protocol (at least for our examples).
  
 Zones, rooms, and games
  
 When a user first connects to ElectroServer, she needs to join or create a 
 zone
 , 
 which is simply a collection of rooms. If the user tries to create a zone that already 
 exists, she will be added to that zone without creating a new one.
  
 After entering a zone, the user needs to join a room in that zone. If a user attempts 
 to create a new room that already exists, she will be added to that room instead.
  
  
 Beyond zones and rooms, ElectroServer also offers a GameManager 
 API that allows you to further segment users into specific instances 
 of a game that is being played. We do not get this granular for the 
 examples in this chapter.
  
 Extensions
  
 Extensions are server-side code modules that can process data sent by clients 
 before that data is sent back to other clients. Extensions can also process and create 
 their own events. For many games, the extension contains much of the game logic, 
 relying on the clients for displaying and gathering user input.
  
 Multiplayer Applications with ElectroServer 5 | 587",NA
Creating a Chat Application with ElectroServer,"As an example, we are going to create a single chat application using the 
 ElectroServer JavaScript API. Users will submit a chat message through an HTML 
 form, and the displayed chat will be in HTML5 Canvas. We are also going to create 
 and display some messages from ElectroServer so you can see the status of the 
 connection to the server.
  
 Establishing a connection to ElectroServer
  
 First, a client application is written so that it includes the ElectroServer JavaScript 
 API:
  
 <script src=""ElectroServer-5-Client-JavaScript.js""></script>
  
 The client application makes a connection to ElectroServer running on a server at a 
 specific URL, listening on a specific port, using a specific protocol. For our 
 examples, this will be 
 localhost
 , 
 8989
 , and 
 BinaryHTTP
 , respectively.
  
 We need to use these values to make a connection from the client to the server. We 
 do this by first creating an instance of the 
 ElectroServer
  object, and then calling its 
 meth-ods. We start by creating an instance of an ElectroServer server connection 
 named 
 server
 . We then configure a new variable named 
 availableConnection
  with the 
 previ-ous properties we described, then add it to the server variable with a call to 
 the method 
 addAvailableConnection()
 . We will create all of this code inside our 
 canvasApp() 
 function:
  
 var server = new ElectroServer.Server(""server1""); 
  
 var availableConnection = new ElectroServer.AvailableConnection
  
  
 (""localhost"", 8989, ElectroServer.TransportType.BinaryHTTP); 
 server.addAvailableConnection(availableConnection);
  
 Now, we need to use the 
 server
  variable we just configured to establish a 
 connection to 
 ElectroServer
 . We do this by setting a new variable, 
 es
 , as an instance 
 of the class 
 ElectroServer
 . We then call its 
 initialize()
  method and add the server we 
 just con-figured to the 
 es
  object by calling the 
 addServer()
  method of the 
 ElectroServer
  server engine property:
  
 var es = new ElectroServer(); 
  
 es.initialize(); 
  
 es.engine.addServer(server);",NA
Testing the Application in Google Chrome,"To test the current ElectroServer JavaScript API, you need to start Google Chrome 
 with web security disabled. The method of doing this varies by OS, but on Mac OS X, 
 you can open a Terminal session and execute the following command (which will 
 open Chrome if you have it in your Applications folder):
  
 /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --disable-web-security
  
 On a Windows PC, input a command similar to this from a command prompt or 
 from a 
 .bat
  file:
  
 ""C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"" --disable-web-security
  
 Multiplayer Applications with ElectroServer 5 | 593",NA
Further Explorations with ElectroServer,"Displaying text on HTML5 Canvas is interesting, but as we have shown you in this 
 book, you can do much more. Let’s add some graphics to the previous demo. We 
 have added a second application for you to peruse, named 
 CH11EX3.html
 . This 
 application adds the bouncing ball demo app from 
 Chapter 5
  to the chat application 
 we just created.
  
 It allows chatters to “send” bouncing balls to each other by clicking on the canvas.
  
 The heart of the app is simply another use of the 
 EsObject
  from the chat application, 
 which is created when the user clicks on the canvas. This 
 EsObject
  adds information 
 about a 
 ball
  that one user created for the others in the room:
  
 function eventMouseUp(event) {
  
  
  var mouseX;
  
  
  var mouseY;
  
  
  if (event.layerX ||  event.layerX == 0) { // Firefox
  
   
  mouseX = event.layerX ;
  
   
  mouseY = event.layerY;
  
  
  } else if (event.offsetX || event.offsetX == 0) { // Opera
   
  
 mouseX = event.offsetX;
  
   
  mouseY = event.offsetY;
  
  
  }
  
  
  ballcounter++;
  
  
  var maxSize = 8;
  
  
  var minSize = 5;
  
  
  var maxSpeed = maxSize+5;
  
  
  var tempRadius = Math.floor(Math.random()*maxSize)+minSize;
  
  var 
 tempX = mouseX;
  
  
  var tempY = mouseY;
  
  
  var tempSpeed = maxSpeed-tempRadius;
  
  
  var tempAngle = Math.floor(Math.random()*360);
  
  
  var tempRadians = tempAngle * Math.PI/ 180;
  
  
  var tempvelocityx = Math.cos(tempRadians) * tempSpeed;
  
  var 
 tempvelocityy = Math.sin(tempRadians) * tempSpeed;
  
  var pmr = 
 new PublicMessageRequest();
  
 598 | Chapter 11:Further Explorations",NA
This Is Just the Tip of the Iceberg,"There is much more you can do with ElectroServer than what we showed you in 
 this chapter. Sending and receiving 
 PublicMessage
  events can only get you so far 
 when de-signing multiuser/multiplayer applications.
  
 To start designing multiplayer applications seriously, you will need to delve into 
 the extension and plug-in architecture of ElectroServer, as well as explore plug-in 
 events, which are used to communicate to the server portion of an application. We 
 suggest you check out 
 http://www.electrotank.com/es5.html
  for more information 
 about the socket server. You can also read 
 ActionScript for Multiplayer Games and 
 Virtual Worlds
  by Jobe Makar (New Riders). Even though it centers on Flash and an 
 earlier version of
  
 606 | Chapter 11:Further Explorations",NA
Conclusion,"Over the past 11 chapters, you have been immersed in the world of HTML5 Canvas. 
 We have given you dozens of examples and applications to work from and through 
 so you can start building your own creations. From simple text displays to high-
 performance games, we have showed you many ways to bring some of the magic of 
 previous RIA (Rich Internet Application) technologies into the plug-in-
 less
  browser 
 experience.
  
 We offered many strategies for integrating Canvas with other HTML5 technologies, 
 as well as techniques for handling text, displaying graphics, scrolling bitmaps, 
 creating animation, detecting multiple types of collisions, embedding and 
 manipulating video, playing music, handling sound effects, creating user interfaces, 
 optimizing code, and preparing apps for mobile platforms. We even introduced you 
 to the future of 3D and multiuser applications directly in the web browser.
  
 The true future, though, is up to you. HTML5 and Canvas are dynamic topics that 
 are still in a rapid state of change and adoption. While this book is a good starting 
 point, you will need to keep abreast of new changes to the technology. Visit our 
 website, 
 http: //www.8bitrocket.com
 , for news and updates on HTML5 Canvas.
  
 O’Reilly also has several books that you might find useful, including:
  
 •
  HTML5: Up and Running
  by Mark Pilgrim
  
 •
  Supercharged JavaScript Graphics
  by Raffaele Cecco
  
 If you are interested in learning how some of the game-development techniques de-
 scribed in this book (as well as many others) can be applied to Flash, check out our 
 other most recent book, 
 The Essential Guide to Flash Games
  (friendsofED).
  
 There is a real paradigm shift occurring right now on the Web. For most of the first 
 decade of the 21st century, Java, Flash, Silverlight, and other plug-in RIA 
 technologies dominated application development and design. At the time, there 
 appeared to be no",NA
Index,NA,NA
Symbols,"- (minus sign), -- (decrement) operator, 175 
 2D context, 1 
  
  
 and current state, 15 
  
  
 retrieving, 11 
  
 3D with WebGL, 567–583 
  
  
 JavaScript libraries used with WebGL, 581 
  
 resources for learning about WebGL, 569 
  
 rotating cube application, 569 
  
  
  
 adding JavaScript libraries, 569 
  
  
  
 animating the cube, 573 
  
  
  
 complete code, 575–581 
  
  
  
 initialization in canvasApp( ), 571 
  
  
  
 shaders, 570 
  
  
  
 testing for WebGL support, 571 
  
  
 testing WebGL, 568 
  
 ? (question mark), ?: ternary operator, 155
  
  
 vertical, 86 
  
  
 vertically centering text on canvas, 72 
 alpha values 
  
  
 alpha fading player ship (game 
 example), 
   
  
 392 
  
  
 globalAlpha property, 39 
  
  
  
 using with text, 94 
  
  
 manipulating via pixel color values, 160 
  
 rgba colors, 52 
  
 angle of incidence, 183 
  
 angle of reflection, 183 
  
 angles 
  
  
 defined in radians for drawing arcs, 34 
  
 direction of movement on a vector, 179 
  
 measurement in radians, 42 
  
 animations 
  
  
 adding step timer to FrameRateCounter 
  
  
  
 object prototype, 466–468",NA
A ,"accelerometer (iPhone), 561 
  
  
 adding gesture to BS Bingo game 
 (example), 
   
  
 561–563 
  
 addColorStop( ) method, CanvasGradient 
  
  
 objects, 100 
  
 addEventListener( ) method, window objects, 
  
  
 7, 19 
  
 alignment, text, 86–90 
  
  
 centering text with TextMetrics, width 
  
  
  
  
 property, 72 
  
  
 handling in Text Arranger (example), 87–
  
  
  
 90 
  
  
 horizontal, 87 
  
  
 setting vertical alignment with 
 textBaseline
  
 advanced cell-based animation, 132–137 
 bouncing off walls, 183–216 
  
  
 multiple balls, 188–193 
  
  
 multiple balls bouncing with friction, 
  
  
  
 210–216 
  
  
 multiple balls colliding, 198–210 
  
  
 multiple balls with dynamically 
 resized 
   
  
 canvas, 193–198 
  
  
 single ball, 184–188 
  
 Canvas compared to Flash, 379 
  
 combining rotation, animation, and 
  
  
  
 movement, 141–142 
  
  
 displaying tile map on canvas, 147 
  
 combining with rotation 
 transformations, 
  
  
 140 
  
 curve and circular movement, 216–236
  
 property, 11
  
 We’d like to hear your suggestions for improving our indexes. Send email to 
 index@oreilly.com
 .
  
 609",NA
B ,"Base SDK, selecting for PhoneGap project, 
  
  
  
 551 
  
 baseline and alignment, fonts, 86–90 
  
  
 handling in Text Arranger (example), 
 87–
   
  
  
 90 
  
  
 horizontal alignment, 87 
  
  
 vertical alignment, 86 
  
 beginPath( ) function, 31 
  
 Bezier curves, 36, 225, 232 
  
  
 (see also curve and circular movement) 
  
 defined, 223 
  
 BinaryHTTP protocol, 585, 587 
  
 bitmaps 
  
  
 adding to Geo Blaster game, 447 
  
  
  
 rendering other game objects, 454–
 459 
   
 tile sheet, 448–453 
  
  
 bitmapped image of Canvas object, 16 
  
 bitmapped screen, 1 
  
 bouncing effects 
  
  
 adding bouncing balls to ElectroServer 5 
  
  
  
  
 chat application, 598–606
  
  
 gravity with bounce and applied 
 elasticity, 
   
  
 243–246 
  
  
 simple gravity with a bounce, 240–243 
  
 simple gravity, elasticity, and friction 
  
  
  
  
 applied to, 246–249 
  
  
 video animation, 316–320 
  
 bouncing off walls, 183–216 
  
  
 multiple balls, 188–193 
  
  
  
 with collisions, 198–210 
  
  
  
 with dynamically resized canvas, 193–
  
  
  
  
 198 
  
  
  
 with friction, 210–216 
  
  
 single ball, 184–188 
  
 bounding box collision detection, 359 
  
 bounding box theory, 50 
  
 BS Bingo game (example), 536 
  
  
 application code, 545 
  
  
 complete source code, 537 
  
  
 porting to iPhone using PhoneGap, 546–
  
  
  
 565 
  
  
  
 adding gesture functions to 
 index.html, 
   
   
 561 
  
  
  
 changing banner and icon, 556 
  
  
  
 creating project in Xcode, 549 
  
  
  
 installing PhoneGap, 547 
  
  
  
 installing Xcode, 546 
  
  
  
 integrating BS Bingo into project, 553 
  
  
 setting orientation, 555 
  
  
  
 testing blank application in simulator, 
  
  
  
  
 551 
  
  
  
 testing on a device, 563 
  
  
  
 testing on iPhone simulator, 558 
  
  
 TextButton.js file, 542–545 
  
 buffers, creating for WebGL application, 572 
 buttons 
  
  
 creating and adding to form, 22 
  
  
 creating video control buttons, 307 
  
  
 listening for presses in video controls, 
 310 
  
 placing video control buttons, 309 
  
  
 preloading for audio player, 338 
  
  
 preloading for video controls, 307",NA
C ,"C3DL library, 582 
  
 canplaythrough events 
  
  
 audio, 326 
  
  
  
 event listener for, 332 
  
  
  
 using to force audio loading, 327
  
 video, 272
  
 Index | 611",NA
D ,"Daleks game, 447, 501 
  
 data property, ImageData objects, 159 
  
 debugging, using console.log, 14 
  
 decrement operator (--), 175 
  
 degrees, converting to radians for angles, 42 
 deltaX (dx) and deltaY (dy) change in axis 
  
  
 position, 135 
  
 descenders (font), 86 
  
 Developer Provisioning Assistant, 563 
  
 development certificates, 564 
  
 diagonal linear gradients, 57 
  
 dir attribute, Canvas object, 87 
  
 direction of movement (vectors), 179 
  
 displaying video on HTML5 Canvas, 275–281 
  
 embedding video in HTML, 275 
  
  
 setting interval to update display, 278–280 
 distance of a line, 174–179 
  
  
 distance equation, 174 
  
 <div> tags, 4
  
  
 compositing, 39–41 
  
  
 creating lines using paths, 30–34 
  
  
 creating shadows, 65 
  
  
 filling objects with colors, 51 
  
  
 filling shapes with gradients, 52–61 
  
  
 filling shapes with patterns, 61–63 
  
  
 rectangle basic shape, 28 
  
  
 transformations, 41–51 
  
  
  
 combining scale and rotation, 49 
  
  
  
 rotation and translation, 42–47 
  
  
  
 scale, 47 
  
 drawing states, 29 
  
  
 current state, 15 
  
 drawing with paths, 34, 382–385 
  
  
 (see also drawing on Canvas) 
  
  
 creating lines, 30–34 
  
  
 drawing game’s main character, 383 
  
  
  
 player ship with thrust engaged, 384 
  
  
 static player ship, 383 
  
  
 graphics for Asteroids-like game, 382 
  
 drawScreen( ) function, 11 
  
  
 drawing screen for video puzzle game, 
 298",NA
E ,"easing, 249–256 
  
  
 easing in, 253–256 
  
  
 easing out, 249–253 
  
  
 Robert Penner’s easing equations and 
  
  
  
  
 implementation in jQuery, 256 
 elastic collisions, 198 
  
 elasticity 
  
  
 applied with gravity and friction to 
 bouncing 
   
  
 ball, 246–249 
  
  
 gravity with bounce and applied simple 
  
  
  
 elasticity, 243 
  
 ElectroServer 5, 583–607 
  
  
 admin tool, 584 
  
  
 basic architecture of an application, 587 
  
 basic architecture of socket-server 
  
  
  
  
 application, 585 
  
  
 creating chat application with, 588–593 
  
  
 adding bouncing ball to chat, 598 
  
  
  
 creating chat functionality, 590–593 
  
  
 establishing connection to ElectroServer, 
  
  
  
  
 588–590 
  
  
  
 full code for ball demo, 600–606 
  
  
 installing, 583 
  
  
 JavaScript API, 585 
  
  
 other uses of, 606 
  
  
 starting the server, 584 
  
  
 testing chat application in Google Chrome, 
  
  
  
 593–598 
  
 Electrotank, 583 
  
 em square (fonts), 86 
  
 embedding video in HTML, 275 
  
  
 plain-vanilla embed, 263 
  
  
 properties and methods, 262 
  
  
 video with controls, loop, and autoplay,
  
  
 createImageDataPressed( ) function 
  
  
  
 (example), 22 
  
  
 creating for mouse events on play/pause 
  
  
 push button, 342 
  
  
 defining for click-and-drag volume slider, 
  
  
 346 
  
  
 defining for mouse events in Space 
 Raiders 
  
  
 game, 359 
  
  
 eventKeyPressed( ) function, 19 
  
  
 mouse events on loop toggle button, 343 
  
 registering, 7 
  
  
 setting in canvasApp( ), Text Arranger 
  
  
  
 (example), 81 
  
 events, 7 
  
  
 canplay event handler for video, changing 
 to 
   
 itemLoaded, 308 
  
  
 changes in shadow settings, Text 
 Arranger 
   
 (example), 98 
  
  
 ElectroServer, creating handlers for, 589 
  
 embedded video in HTML5, problem with, 
  
  
 274 
  
  
 handler for keyup event of textBox, 71 
  
  
 handling for videoSize form control, 269 
  
 handling keyup event in Guess The Letter 
  
  
 game, 19 
  
  
 handling mouse events in Tile Stamper 
  
  
 application, 161 
  
  
 handling mouse events in video puzzle 
  
  
  
 game, 300 
  
  
 handling range controls change event, 
 194 
  
 important audio events, 326 
  
  
 interactivity of mouse events with audio 
  
  
 player controls, 340 
  
  
 keyboard controlling game player ship, 
 395–
  
  
 399
  
 265
  
 Index | 615",NA
F ,"faces, font, 80 
  
 facing versus moving, game object animation, 
  
  
  
 393 
  
 fade effects, alpha fading player ship (game 
  
  
  
 example), 392 
  
 Feldman, Ari, 126 
  
 fill( ) method, context objects, 56 
  
 fillColor property, context objects, 73 
  
 fillRect( ) method, context objects, 11, 28, 57 
  
 linear gradient fills, 52–54 
  
 fills, 51–63 
  
  
 filling shapes with gradients, 52–61 
  
  
  
 diagonal linear gradients, 57 
  
  
  
 linear horizontal gradients, 52–56 
  
  
  
 radial gradients, 58–61 
  
  
  
 vertical linear gradients, 56 
  
  
 filling shapes with patterns, 61–63 
  
  
 setting basic fill colors, 51 
  
  
 setting for filled text, 70 
  
 fillStyle property, context objects, 15, 70 
  
  
 formatting with color, gradient, or pattern, 
  
  
  
  
 105 
  
  
 pattern, 103 
  
  
 setting colors, 51 
  
  
 setting font color for text, 83 
  
  
 setting for Hello World (example), 11 
  
  
 setting gradients, 52–61 
  
  
 setting in Guess The Letter game 
 (example), 
   
  
  
 21 
  
 fillStyle( ) method, context objects, 11
  
  
 context.font property, 73 
  
  
 context.font style, setting, 69 
  
  
 handling font size and face in Text 
 Arranger 
   
  
 (example), 79–83 
  
  
 handling in Text Arranger 2.0 (example), 
  
  
  
 90–94 
  
  
 size, face weight, and style basics, 78 
  
 for:next loops, 286 
  
  
 using in video puzzle game, 300 
  
 formats 
  
  
 audio, 322 
  
  
  
 converting, 322 
  
  
  
 finding supported format, 332 
  
  
  
 using .mp3, .ogg, and .wav formats, 323 
  
 video, 259 
  
  
  
 .mp4 files, 260 
  
  
  
 .ogg files, 260 
  
  
  
 .webm, 260 
  
  
  
 converting, 261 
  
  
  
 web browsers’ support of, 261 
  
 forms (see HTML forms) 
  
 fragment shaders, 570 
  
 frame counter, creating for animation, 130 
 frame tick, 131 
  
 FrameRateCounter object prototype, 406–
 407 
  
 adding step timer, 466–468 
  
 frames per second (FPS), 278, 386 
  
 frameworks, JavaScript, 6 
  
 friction 
  
  
 ball bouncing with applied gravity, 
  
  
  
  
 elasticity, and friction, 246–249 
  
 multiple balls bouncing with, 210–216 
  
 fromCharCode( ) method, String object, 19 
 functions",NA
G ,"GameManager API (ElectroServer), 587 
  
 games, 379–445 
  
  
 animating on canvas, 385–388 
  
  
  
 game timer loop, 386 
  
  
  
 player ship state changes (example), 
  
  
  
  
 386 
  
  
 applying transformations to graphics, 388–
  
  
  
 389 
  
  
 basic game framework, 400–407 
  
  
  
 FrameRateCounter object prototype, 
  
  
  
  
 406–407 
  
  
  
 state machine, 400–403 
  
  
  
 update/render (repeat) cycle, 404–405 
  
 basic HTML5 file for, 380 
  
  
 creating dynamic tile sheet at runtime, 
 497–
   
  
 501 
  
  
 creating for mobile devices with PhoneGap, 
  
  
  
 535 
  
  
 creating simple tile-based game, 501–534 
  
  
 Micro Tank Maze complete code, 516–
  
  
  
  
 534 
  
  
 design, Asteroids-like game, 382 
  
  
 development using HTML5 Canvas, 379 
  
 Geo Blaster Basic (example) 
  
  
  
 applying collision detection, 417 
  
  
  
 arrays of logical display objects, 412 
  
  
 awarding player extra ships, 416 
  
  
  
 full source code, 419–443 
  
  
  
 game structure, 407–410 
  
  
  
 global game variables, 410 
  
  
  
 level and game end, 415 
  
  
  
 level knobs, 415 
  
  
  
 Rock object prototype, 443–445 
  
  
 going mobile (see BS Bingo game; 
  
  
  
  
 PhoneGap) 
  
  
 graphic transformations 
  
  
  
 alpha fading player ship (example), 392 
  
  
 rotating player ship from center 
  
  
  
  
  
 (example), 390 
  
  
 graphics, drawing with paths, 382–385 
  
  
 drawing game’s main character, 383 
  
 Guess The Letter (example), 17–26 
  
  
 multiplayer applications with 
 ElectroServer 
    
 5, 583–607
  
  
  
  
  
  
 393–395 
  
  
  
 maximum velocity for player ship, 399 
  
 player object, 412 
  
  
 tile-based environment for backgrounds 
 and 
   
  
  
 level graphics, 143 
  
 Geo Blaster Basic (example) 
  
  
 applying collision detection, 417 
  
  
 arrays of logical display objects, 412 
  
  
  
 explosions and particles, 414 
  
  
  
 missiles, 414 
  
  
  
 rocks, 413 
  
  
  
 saucers, 413 
  
  
 awarding player extra ships, 416 
  
  
 Basic version, full source code, 419–443 
  
 game structure, 407 
  
  
  
 application functions, 408 
  
  
  
 application states, 407 
  
  
 global variables, 410 
  
  
 level and game end, 415 
  
  
 level knobs, 415 
  
  
 player object, 412 
  
  
 Rock object prototype, 443–445 
  
 Geo Blaster Extended (example), 447 
  
  
 adding sound, 459–463 
  
  
 adding step timer, 466–468 
  
  
 complete source code, 468–497 
  
  
 pooling object instances, 464–466 
  
  
 rendering other game objects, 454 
  
  
 tile sheet, 448 
  
 gesture (iPhone), adding to BS Bingo 
 (example), 
   
  
 561 
  
  
 adding gesture functions to index.html, 
  
  
  
  
 561–563 
  
 getContext( ) method, Canvas object, 10, 15, 
  
  
  
 16 
  
 getElementById( ) method, document objects, 
  
  
  
 9, 22, 71 
  
 getImageData( ) function, 159, 497 
  
 getShader( ) function, WebGL application, 
  
  
  
 572 
  
 GLGE library, 582 
  
 global variables 
  
  
 Geo Blaster game (example), 410 
  
  
 initializing Space Raiders game without 
  
  
  
  
 using, 355
  
 object physics and animation, 393–400
  
 Index | 617",NA
H ,"H.264 video standard, 
 260
  
 HTMLVideoElement objects 
  
 canPlayType( ) method, 277 
 methods, 263 
  
 properties, 262, 263, 281–
 285
  
 <head> tags, placement of JavaScript in, 6 
 height attribute, <canvas> element, 9",NA
I,"height of text, 72 
  
 height property, Canvas objects, 16
  
 “Hello World!” program (example), 7–14
  
 id attribute, <canvas> element, 
 9 if:then statements, 301 
  
 Image objects, 124",NA
J ,"JavaScript 
  
  
 dynamically creating audio element, 331 
  
 ElectroServer API, 585 
  
  
 encapsulating code for Canvas, 8 
  
  
 events, 7 
  
  
 frameworks and libraries, 6 
  
  
 libraries for WebGL, 569, 581 
  
  
 modernizr.js library, 2 
  
  
 placement in HTML documents, 6 
  
  
 preloading video, 271–274 
  
  
 programming Canvas applications with, 6 
  
 using document object to reference 
 canvas 
  
  
 element in, 9
  
 jQTouch, 566
  
 Index | 619",NA
K ,"keyboard 
  
  
 checks for game-specific key presses, 404 
  
 controlling player ship (game example), 
  
  
  
  
 395–399 
  
  
  
 array holding key presses, 395 
  
  
  
 evaluating key presses, 396 
  
  
  
 key events, 395 
  
  
  
 source code, 396–399 
  
  
 event listener and handler for keyup 
 event, 
   
  
  
 19 
  
 keyboard input, event handler for controlled 
  
  
  
 pan and zoom, 155",NA
L ,"language, specifying in <html> tag, 3 
  
 law of conservation of momentum, 204 
  
 layerX and layerY properties, event objects, 
  
  
  
 300 
  
 Learning WebGL website, 569 
  
 level knobs (Geo Blaster game), 415 
  
 levels, checking in Geo Blaster Basic 
 (example), 
  
  
  
 415 
  
 libraries, JavaScript, 6 
  
 linear gradients, 52–58 
  
  
 diagonal, 57 
  
  
 horizontal, 52–56 
  
  
  
 applying to a stroke, 54 
  
  
  
 applying to complex shape, 55 
  
  
  
 on multiple objects, 53 
  
  
 text with, 100 
  
  
 vertical, 56 
  
 lineCap property, context objects, 15 
  
  
 defining attributes, 31 
  
  
 using in more advanced line drawing, 32 
 lineJoin property, context objects 
  
  
 defining attributes, 32 
  
  
 using in more advanced line drawing, 32 
 lines 
  
  
 creating using paths, 30–34 
  
  
  
 more advanced examples, 32–34 
  
  
 finding length of, 174 
  
  
 moving in straight line, 171–179 
  
 lineTo( ) method, context objects, 31 
  
 lineWidth property, context objects, 15
  
 load event, window objects, 7 
  
 load( ) function, audio objects, 325 
  
 loading audio, 326 
  
 Logg, Ed, 382 
  
 logging text messages to JavaScript console, 
  
  
 14 
  
 logical display objects, arrays of, 413 
  
 look and feel for iPhone-like application, 565 
 loop property 
  
  
 audio objects, 325 
  
  
 video objects, 262, 265 
  
 loop toggle button, 337 
  
  
 implementing for canvas audio player, 
 343 
  
 values for placement of, 339",NA
M ,"magnitude (speed) of movement, 179 
  
 Makar, Jobe, 198 
  
 math-based movement, 171 
  
  
 moving in straight line, 171–179 
  
  
  
 length of a line, 174 
  
 Math.atan2( ) function, 204 
  
 Math.cos( ) function, 180, 204 
  
 Math.PI, 179 
  
 Math.PI/180, 35 
  
 Math.sin( ) function, 180, 204 
  
 Math.sqrt( ) function, 175, 204 
  
 measureText( ) method, context objects, 
 72, 
   
  
 89 
  
 <meta charset=""UTF-8""> tags, 3 
  
 Micro Tank Maze game (example), 501–
 534 
  
 complete code, 516–534 
  
  
 description of game, 501 
  
  
 enemy object, 506 
  
  
 player, 505 
  
  
 playfield, 504 
  
  
 rendering logic overview, 514 
  
  
 simple AI overview, 515 
  
  
 tile movement logic overview, 512–514 
  
 tile sheet, 503 
  
 MIME types 
  
  
 audio, 332 
  
  
 canPlayType( ) method parameter, 277 
 missiles (in Geo Blaster game), 414 
  
  
 prerendering as bitmaps, 450 
  
  
 rendering for Geo Blaster Extended, 456
  
 620 | Index",NA
N ,"Nitobi, PhoneGap, 536",NA
O ,"O3D library, 582 
  
 object pools in Geo Blaster Extended 
  
  
 (example), 464–466 
  
 Objective-C, iOS applications in, 535 
  
 offsetX and offsetY properties, event objects, 
  
 300 
  
 .ogg files, 260, 322 
  
 onMouseClick( ) function, TextButton object 
  
 in BS Bingo (example), 545 
  
 onMouseMove( ) function, TextButton object 
  
 in BS Bingo (example), 545 
  
 open( ) method, window objects, 22 
  
 OpenGL, 568 
  
 orientation, setting for iOS application, 555",NA
P ,"Pac-Man, 501 
  
 panning an image, 152 
  
  
 (see also zooming and panning images) 
 paths, 27 
  
  
 advanced drawing methods, 34–39 
  
  
  
 arcs, 34 
  
  
  
 Bezier curves, 36 
  
  
  
 clipping region, 37 
  
  
 drawing game graphics with, 382–385 
  
  
 drawing methods of context object, 384 
  
 tracing movement with path of points, 
 176
  
 using to create lines, 30–34
  
 Index | 621",NA
Q ,"quadratic Bezier curves, 36, 
 232",NA
R ,"radial gradients, 52, 58–61 
  
  
 applied to a circle, 60 
  
  
 arc stroke gradient, 60 
  
  
 complex, 59 
  
  
 simple, 59 
  
  
 text with, 102 
  
 radians 
  
  
 converting angles to, 42, 179 
  
 defining angles in, 34 
  
 Rains, Lyle, 382 
  
 range controls, 193
  
 rooms in ElectroServer zones, 587 
  
 rotate( ) function, 43 
  
 rotation 
  
  
 around the center point, 45 
  
  
 redrawing player ship (example) to start 
 at 
   
  
 angle 0, 394 
  
  
 thrusting in rotated direction (game 
  
  
  
  
 example), 394 
  
 rotation transformations, 42–47, 137–142 
  
 animating rotated image, 140–141 
  
  
 Canvas state and, 43 
  
  
 Canvas transformation basics, 137–140 
  
 combining with animation and 
 movement, 
   
  
 141–142 
  
  
  
 displaying tile map, 147 
  
  
 combining with scale transformations, 49
  
 Index | 623",NA
S ,"Safari Mobile applications, automatic scaling 
 to 
   
 iOS device window, 555 
  
 Sampaio, Felipe, 205 
  
 saucers (in Geo Blaster game), 413 
  
  
 prerendering as bitmaps, 450 
  
  
 rendering for Geo Blaster Extended, 454 
 save( ) and restore( ) methods, context 
 objects, 
   
 30, 137 
  
 scale transformations, 47 
  
  
 combining with rotation transformations, 
  
  
  
 49 
  
  
 performing translation before, 48 
  
 scale( ) function, 47 
  
 scaling 
  
  
 altering width and height of video, 267 
  
 dynamically scaling the Canvas, 109 
  
  
 dynamically scaling video, 268 
  
  
 resizing image as it’s drawn, 127 
  
 SceneJS library, 582 
  
 scenes, 570 
  
 SDK (iOS) 
  
  
 downloading, 546 
  
  
 setting for PhoneGap project, 549 
  
 SECURITY_ERR: DOM Exception 18, 112 
 <select> elements, 74 
  
 sendMessage( ) function, 591 
  
 setAttribute( ) method, 110 
  
  
 HTMLAudioElement object, 331 
  
 setInterval( ) function, 278, 386 
  
 setTransform( ) method, context objects, 42, 
  
  
 138 
  
 shaders, 570 
  
 shadowBlur property, context objects, 65, 97 
 shadowColor property, context objects, 65, 97 
 shadowOffsetX property, context objects, 15, 
  
  
 65, 97
  
  
 testing blank PhoneGap application, 551 
  
 testing iPhone PhoneGap app on, 558 
 sine, 180 
  
 socket-server applications, 583 
  
  
 basic architecture of, 585 
  
 sound pool, creating, 365 
  
 <source> tags, within <video> tag, 264 
  
 Space Raiders game, audio case study, 352–
  
  
  
 378 
  
  
 creating sound pool, 365 
  
  
 creating unlimited dynamic sounds, 362 
  
 final code, 371–378 
  
  
 game structure, 353–362 
  
  
  
 bounding box collision detection, 359 
  
  
 initializing game, 355 
  
  
  
 mouse control, 359 
  
  
  
 playing the game, 360 
  
  
  
 preloading assets, 356 
  
  
  
 resetting the game, 358 
  
  
  
 state machine, 354 
  
  
 other possible improvements, 371 
  
  
 playing sounds using single object, 362 
  
 reusing preloaded sounds, 368–371 
  
  
 sounds and games, 353 
  
 speed 
  
  
 magnitude of movement, 179 
  
  
 multiple balls bouncing, 189 
  
 SpiderGL library, 582 
  
 spiral, moving in, 220–223 
  
 sprite sheet, 128 
  
 SpriteLib, 126 
  
 sqrt( ) function, Math object, 175 
  
 src property 
  
  
 Image objects, 12, 124 
  
  
 setting for audio element, 331 
  
  
 videos, 262 
  
 stack, saving and retrieving current canvas, 
  
  
  
 388 
  
 state
  
 624 | Index",NA
T ,"ternary operator (?:), 155 
  
 text 
  
  
 drawing to screen in Guess The Letter 
 game 
   
  
  
 (example), 21 
  
  
 putting “Hello World!” on the screen, 11 
 Text API, 69–121 
  
  
 basic text display, 69 
  
  
 communicating between HTML forms and 
  
  
  
  
 Canvas, 71 
  
  
 dynamically resizing the canvas, 106–109 
  
 dynamically scaling the canvas, 109 
  
  
 fillText( ) and strokeText( ) methods, 73 
  
 final version of Text Arranger (example), 
  
  
  
  
 112–121 
  
  
 global shadows and text, 96–100 
  
  
 handling basic text in Text Arranger, 70 
  
 handling gradient and patterns in Text 
  
  
  
  
  
 Arranger, 103 
  
  
 setting fonts, 78–94 
  
  
  
 baseline and alignment, 86–90 
  
  
  
 Text Arranger 2.0 (example), 90–94 
  
 text and Canvas context, 94–100 
  
  
 text with gradients, 100 
  
  
 text with image patterns, 102 
  
  
 toDataURL( ) method of Canvas object, 
  
  
  
  
 110 
  
  
 using measureText( ) method, 72 
  
 Text Arranger (example) 
  
  
 complete code, version 1.0, 76–78 
  
  
 dynamically resizing text, 108 
  
  
 final version 3.0, 112–121 
  
  
 handling basic text, 70 
  
  
 handling font color, 83 
  
  
 handling font size and face, 79–83 
  
  
 handling gradient and patterns, 103–106 
  
 handling text baseline and alignment, 87–
  
  
  
  
 90 
  
  
 version 2.0, 90–94 
  
 textAlign property, context objects, 15, 87 
 textBaseline property, context objects, 15, 86 
  
 setting in Guess The Letter game 
 (example), 
   
  
  
 21 
  
  
 setting in Hello World (example), 11 
  
 TextButton.js file, BS Bingo game (example), 
  
  
  
 542–545 
  
  
 chooseButtonsForCard( ) function, 544 
  
 drawScreen( ) function, 545
  
 initButtons( ) function, 544
  
 Index | 625",NA
U ,"Unique ID, finding for physical mobile 
 device, 
  
 563
  
 626 | Index",NA
V ,"variables 
  
  
 encapsulating for Canvas applications, 8 
  
 Guess The Letter game (example), 17 
  
 vectors 
  
  
 moving object on, 179–183 
  
  
 object moving on, simple gravity with, 236 
 velocity (maximum), giving to player ship 
  
  
  
  
 (example), 399 
  
 Vertex Color buffer, WebGL application, 573 
 Vertex Index buffer, WebGL application, 573 
 vertex shaders, 570 
  
 vertical alignment of text, 86 
  
 vertical linear gradients, 56 
  
 video, 259–320 
  
  
 animation, 316–320 
  
  
 basic HTML5 implementation, 262–271 
  
  
 altering video’s width and height, 267–
  
  
  
  
 271 
  
  
  
 plain-vanilla embed, 263 
  
  
  
 video with controls, loop, and autoplay, 
  
  
  
  
 265 
  
  
 converting formats, 261 
  
  
 displaying on HTML5 Canvas, 275–281 
  
 HTML5 properties, 281–285 
  
  
 HTML5 video format support, 259 
  
  
 preloading in JavaScript, 271–275 
  
  
  
 problem with events, 274 
  
  
 using as source for patterns, 103 
  
  
 using with Canvas, examples 
  
  
  
 creating video controls on Canvas, 307–
  
  
  
  
 316 
  
  
  
 rotation video transformation, 289–294 
  
  
 using currentTime property to create 
  
  
  
  
 video events, 285–289 
  
  
  
 video puzzle game, 294–307 
  
 video codecs, 259 
  
 <video> tags, 259 
  
 viewport, setting up, 573 
  
 volume property 
  
  
 audio objects, 325 
  
  
 video objects, 262, 281 
  
 volume slider, interactive, 337 
  
  
 click-and-drag volume slider, 344
  
 VP8 codec, 260",NA
W ,"W3C website, coverage of Canvas 2D 
 Drawing 
   
  
 API, 27 
  
 walls, better interaction with, in balls 
 bouncing 
  
   
 with collisions, 
 202 
  
 .wav files, 322 
  
 web application development, paradigm shift 
  
  
  
 in, 607 
  
 web browsers 
  
  
 HTML5 Canvas Text API support, 69 
  
  
 looking at simple HTML5 page, 3 
  
  
 pattern fills, 63 
  
  
 running examples in this book, xv 
  
  
 support for HTML5 Canvas, 2 
  
  
 supported audio formats, 322 
  
  
 testing for canvas support, 10 
  
  
 testing for WebGL support, 571 
  
  
 video formats supported by, 261 
  
 web page for this book, xviii 
  
 web security, disabling for Chrome, 593 
  
 WebGL, 567–583 
  
  
 application, 3D rotating cube, 569 
  
  
  
 adding JavaScript libraries, 569 
  
  
  
 animating the cube, 573 
  
  
  
 complete code, 575–581 
  
  
  
 initialization in canvasApp( ), 571 
  
  
  
 shaders, 570 
  
  
  
 testing for WebGL support with 
  
  
  
  
  
 Modernizr, 571 
  
  
 defined, 568 
  
  
 JavaScript libraries used with, 581 
  
  
 resources for information, 569 
  
  
 testing, 568 
  
 .webm files, 260 
  
 WebM video standard, 260 
  
 WebSockets, 583 
  
 weights, font, 79 
  
 while loops, 297 
  
 width and height 
  
  
 altering for videos, 267–271 
  
  
 dynamically resizing the canvas, 106 
  
  
 ImageData objects, 158
  
 Index | 627",NA
X ,"Xcode IDE, 535 
  
  
 creating BS Bingo PhoneGap project, 549 
  
  
 installing, 546 
  
  
 looking up mobile device’s Unique ID, 563 
  
  
 setting build target to a device, 564 
  
  
 testing BS Bingo on iPhone simulator, 558",NA
Z ,"zones, rooms, and games in ElectroServer, 
 587 
  
 zooming and panning images, 149–158 
  
  
 controlled pan and zoom, 154–158 
  
  
 creating logical window for, 149–152 
  
  
 panning an image, 152 
  
  
 simultaneously zooming and panning an 
  
  
  
 image, 153",NA
About the Authors,"Steve Fulton
  is an RIA and web game developer who has been cultivating an 
 audience for news, stories, blogs, and tutorials about Flash, Silverlight, and now the 
 HTML5 Canvas at his website, 
 http://www.8bitrocket.com
 , for the past 3½ years. He 
 has one of the highest Alexa rankings among Flash game developers’ blogs. Steve 
 has worked as a web development manager at Mattel Toys for the past 14 years, 
 helping to create Mattel’s extensive online presence.
  
 Jeff Fulton
  has been creating games and RIAs for the past 17 years. He is currently 
 a Senior Game Engineer at Zynga, having previously plied his trade at Mattel Toys 
 and freelanced for his own consulting company, 8bitrocket Studios. Jeff has 
 previously co-authored (with his brother Steve) a book on advanced Flash game 
 development, and currently runs a popular and successful blog site, 
 http://www.8bitrocket.com
 , which focuses on Flash, HTML5, Silverlight, and retro 
 gaming.",NA
Colophon,"The animal on the cover of 
 HTML5 Canvas
  is the New Zealand kaka (
 Nestor meridio-
 nalis
 ), a parrot endemic to that country. The kaka’s name comes from the Maori 
 word for parrot (a duplication of the word 
 kā
 , Maori for “to screech”). It is part of 
 the Stri-gopidae family, which diverged from other parrots 80–100 million years 
 ago when the landmass that is now New Zealand broke apart from the 
 supercontinent Gondwana. A defining characteristic of this family of parrots is the 
 bristles on their tongues, which are used to collect nectar.
  
 A medium-sized parrot about 18 inches in length, the kaka is stocky and has a 
 short, square tail. Its feathers are primarily olive-brown, with brighter splashes of 
 crimson on the underwings and rump. It also has yellow-brown spots on its cheeks 
 and a gray crown. It possesses the sharp curved beak common to many parrot 
 species, which it uses to pry seeds loose from cones and dig up insects. The kaka 
 also eats fruit, berries, nectar, and flowers.
  
 These birds are primarily arboreal, living in the canopies of New Zealand forests. 
 Very social creatures, kakas live in large flocks that sometimes include other local 
 parrot species as well. In winter, breeding pairs build nests in hollow trees, and lay 
 a clutch of two to four eggs. Both parents help feed their young.
  
 The kaka is currently endangered due to deforestation, predators, and competition 
 for food with non-native species. The closely related kea and kakapo parrots are 
 facing similar challenges—and in fact, two species within the 
 Nestor
  genus have 
 already gone extinct (most recently in 1851).
  
 The cover image is from Cassell’s 
 Natural History
 . The cover font is Adobe ITC Gara-
 mond. The text font is Linotype Birka; the heading font is Adobe Myriad Condensed; 
 and the code font is LucasFont’s TheSansMonoCondensed.",NA
