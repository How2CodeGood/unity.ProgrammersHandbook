Larger Text,Smaller Text,Symbol
Modern Java ,NA,NA
EE Design ,NA,NA
Patterns,NA,NA
Building Scalable Architecture for ,NA,NA
Sustainable Enterprise Development,NA,NA
Markus Eisele,NA,NA
Modern Java EE ,NA,NA
Desig,NA,NA
n ,NA,NA
Patte,NA,NA
rns,NA,NA
Building Scalable ,NA,NA
Architecture,NA,NA
for Sustainable Enterprise ,NA,NA
Development,NA,NA
Markus Eisele,NA,NA
Table of Contents,"Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . .  v
  
 1. Enterprise Development Today. . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . .  1
  
 Enterprise 
 Goals 
 and 
 Objectives                                
 2 
 Resistant 
 to 
 Change 
 and 
 Economically 
 Efficient                            
 2 
 Developers 
 Left 
 Alone                                
 3 
 Technology-Centric 
 Versus 
 Business-Centric                                
 3 
 Aims 
 and 
 Scope                                
 3
  
 2. History of Java EE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . .  5
  
 Mistakes We Made                                                                               6 
 Evolution 
 Continues 
 with 
 ESBs                                
 7 
 Challenges 
 and 
 Lessons 
 Learned                                
 9
  
 3. Designing Software for a Scalable Enterprise. . . . . . 
 . . . . . . . . . . . . .  13
  
 Greenfield 
 Versus 
 Brownfield                                
 15 
 Domain-Driven 
 Design                                
 16 
 Service 
 Characteristics                                
 17 
 Microservices 
 Best 
 Practices                                
 19 
 Independently 
 Deployable 
 and 
 Fully 
 Contained                          
 26 
 Crosscutting 
 Concerns                                
 26",NA
Acknowledgments,"Writing books takes a lot more time than reading them—and it 
 requires a lot more people to be successful at it. I am thankful to 
 have had the technical support and creativity of Mark Little, 
 Arun Gupta, and Daniel Bryant throughout the writing process 
 and beyond.
  
 I cannot forget my girls here. Thank you! I love you!™
  
 v",NA
CHAPTER 1,NA,NA
Enterprise ,NA,NA
Development Today,"Enterprise is a noun. One of its meanings refers to a project or 
 undertaking, especially a bold or complex one. But it also refers 
 more generally to businesses or corporations. Used in the 
 context of software technology, the term encapsulates a mixture 
 of these mean‐ings, which is underlined by the inability to adopt 
 new technologies at a reasonable speed due to a large 
 organization’s inability to move quickly. Nevertheless, all those 
 attributes and descriptions are very personal based on specific 
 work environments. And not everything about this negative 
 introduction is bad. The reasons behind this are obvious: those 
 complex undertakings or large organizations need a much 
 higher level of standardization than startups. Changing a small 
 thing for one out of a hundred projects might lead to unantici‐
 pated problems.
  
 One major technology that has become a standard platform 
 across most enterprises to build complex—and stable—
 applications is Java Enterprise Edition (Java EE). And while this 
 technology stack has come a long way since its inception in 
 1998, it is still not meant to be used for innovation and the 
 adoption of more cutting-edge technol‐ogies and development 
 paradigms.
  
 Nevertheless, innovation and constant improvement are the 
 drivers behind enterprises and enterprise-grade projects. 
 Without innova‐tion, there will be outdated and expensive 
 infrastructure compo‐nents (e.g., host systems) that are kept 
 alive way longer than the software they are running was",NA
Enterprise Goals and Objectives,"As technology has evolved, the decision makers in enterprise IT 
 departments have implemented new capabilities and processes 
 across their organizations. Thus, IT has changed operations and 
 turnaround for the better. But besides this technical 
 standardization and forward march of progress in internal 
 operations and cost cut‐ting, these departments are still accused 
 of not understanding the needs of the business. Operations and 
 buying decisions are still focused on generating quick results 
 from investments and long-term cost savings. These results 
 ignore the need for new business require‐ments or market 
 developments, such as the still growing mobile market or the 
 new communication style of a whole generation.",NA
Resistant to Change and ,NA,NA
Economically Efficient,"Speaking of this mismatch, operations and business have always 
 fol‐lowed completely distinct goals while working on the 
 greater good. Operations and sourcing have won out mostly. It’s 
 an easier business case to calculate how much a corporation-
 wide standardization for a Java EE application server can 
 produce in savings than to examine the individual lines of 
 source code and maintenance that must be dealt with for each 
 individual project. And it’s not only the differ‐ence in mindset 
 behind this. It’s also about long-term support and license 
 agreements. Instead of changing the foundation and every‐",NA
Developers Left Alone,"Even if the preceding analysis barely scratches the surface, it 
 reveals why developers are feeling left alone in those enterprise 
 settings. Having to fight the same stack day in and day out might 
 have advan‐tages for generating knowledge about common 
 pitfalls and short‐comings, but it also puts a strong block on 
 everything that promises to solve problems more elegantly, in 
 shorter timeframes, and with a lot less code. And we haven’t 
 even talked about the other problem that results from this.",NA
Technology-Centric Versus ,NA,NA
Business-Centric,"Many traditional enterprises have become strongly business-
 centric and mostly treat IT and operations as cost centers. The 
 goal of pro‐viding homogenous IT services was mostly reached 
 by overly focus‐ing on IT architectures, information formats, 
 and technology selec‐tion processes to produce a standard 
 platform for application opera‐tions. This produced a dangerous 
 comfort zone that siphons atten‐tion away from the real value 
 of business software: the business domains and relevant 
 processes whose standardization and optimi‐zation promise a 
 much higher payback than just operational opti‐mizations.
  
 The good news is that many organizations have started to take 
 notice and are undertaking changes toward easier and more 
 efficient architecture management. But change is something 
 that doesn’t nec‐essarily have to come from above; it is also the 
 responsibility of every developer and architect. As a result, 
 today’s buzzwords have to be incorporated in a manageable 
 way by all parties responsible for creating software.",NA
Aims and Scope,"So, there’s a lot to reflect on here. This report focuses on how 
 enter‐prises work and how the situation can be improved by 
 understand‐ing 
 how—and 
 when—to 
 adopt 
 the 
 latest 
 technologies in such an",NA
CHAPTER 2,NA,NA
History of Java EE,"“Develop once, run everywhere!” This developer promise was 
 the key driving force behind much of the success enjoyed by the 
 Java programming language. And as interest in Java continued 
 to rise through broad adoption, the need for robust enterprise-
 grade appli‐cations soared. The advent of the Internet and the 
 first browser ver‐sions led to the implementation of the first 
 web server in Java as well as the introduction of the Servlet and 
 JSP specifications. These two specifications became the 
 foundation for the Java 2 Enterprise Edi‐tion (J2EE) platform, 
 and from 1999 to 2003, the number of con‐tained Java 
 Specification Requests (JSRs) grew from 10 to 18. The platform 
 was renamed Java EE in 2006 (and now carries its version 
 number on the tail end). As of the writing of this report, the 
 most recent version is Java EE 7 (JSR 342), with Java EE 8 (JSR 
 366) due to release at the end of 2016.
  
 Enterprises adopted Java EE early—and often—because of the 
 many 
 advantages 
 it 
 promised, 
 such 
 as 
 centralized 
 infrastructures, a scala‐ble, transactional, and standardized 
 programming model, high throughput, and reliable operations. 
 However, every single promise came with a drawback, and it 
 took a while until the platform as a specification embraced 
 operational and developer performance. Given the slow uptake 
 of new versions by both vendors and custom‐ers, we still see a 
 lot of Java EE 5-based applications out in the wild (this 
 particular release dates back to mid-2006).",NA
Mistakes We Made,"Traditionally, Java EE applications followed the core pattern 
 defined in the book 
 Core J2EE Patterns
  and were separated into 
 three main layers: presentation, business, and integration. The 
 presentation layer was packaged in Web Application Archives 
 (WARs) while business and integration logic went into separate 
 Java Archives (JARs). Bundled together as one deployment unit, 
 a so-called Enter‐prise Archive (EAR) was created.
  
 The technology and best practices around Java EE have always 
 been sufficient to build a well-designed monolith application. 
 But most enterprise-grade projects tend to lose a close focus on 
 architecture. The aspects of early Java EE applications outlined 
 in 
 Figure 2-1
  don’t make assumptions about their technical 
 capabilities, and are derived from experience in the field.
  
  
 Figure 2-1. Typical enterprise Java application
  
 Those applications could be scaled with the help of more 
 instances of the application server and a load balancer. If the 
 responsible architect thought about reuse here, he most likely 
 considered imple‐menting a common JAR or library that became 
 part of all the appli‐cations in the enterprise. Crosscutting 
 concerns, such as single sign-on (SSO), were taken care of by 
 enterprise access management
  
  
 6 
  
 | 
  
 Chapter 2: History of Java EE",NA
Evolution Continues with ESBs,"Another technology was created in the advent of business-
 centered designs and the broader shift into more service-
 oriented organiza‐tions. The enterprise service bus (ESB) 
 promised to deliver reusabil‐ity and exchangeability by still 
 standing up as a centralized and managed infrastructure 
 component. Evangelized by many vendors, this technology was 
 poised to be the number one solution to all of the monolithic 
 applications in existence.
  
 All of the applications needed to be sliced and rebuilt to support 
 exchangeable services. Service-oriented architectures (SOA) 
 were the new paradigm behind this. Unfortunately, the interface 
 technol‐ogy of choice tended to be web services (WS). Web 
 services trans‐",NA
Challenges and Lessons Learned,"From what you’ve read so far, it’s pretty clear that enterprise 
 projects contain challenges on varying levels. And going through 
 the last 5 to 10 years of evolution in this field, it is obvious that 
 the technical challenges haven’t been the only ones. It took 
 some time, but the first experts mastered the complexity and 
 refactored the first pattern and best practices.
  
 Our industry also had to learn to handle project management 
 differ‐ently, and new project management methodologies 
 became broadly accepted. Iterative and agile approaches 
 required a more fine-grained cut of requirements and teams, 
 and this led to even more",NA
DevOps: Highly Effective Teams,"Another very important part of successful software delivery 
 was a tighter coupling between operations and development. 
 With more frequent changes and a very high automation rate, 
 the number of deployments to individual environments spiked. 
 This was some‐thing straight deployment processes could 
 hardly handle. This is why DevOps was born. At its core, the 
 DevOps movement is about team culture. It aims at improving 
 communication 
 and 
 collabora‐tion 
 between 
 developers, 
 operations, and other IT professionals. Based on automation 
 and tooling, it helps organizations to rapidly put high-quality 
 software into production. Even more than that, it manifested 
 itself in a new team communication methodology embracing 
 frequent changes. Development teams not only wanted to just 
 produce code, but also were responsible for pushing com‐plete 
 changes down the DevOps chain into production.",NA
Microservices: Lightweight and Fast,"Centralized components no longer fit into this picture, and even 
 heavyweight application servers were revisited alongside 
 wordy pro‐tocols and interface technologies. The technical 
 design went back to more handy artifacts and services with the 
 proven impracticality of most of the service implementation in 
 SOA- and ESB-based projects. Instead of intelligent routing and 
 transformations, 
 micro‐services 
 use 
 simple 
 routes 
 and 
 encapsulate logic in the endpoint itself. And even if the name 
 implies a defined size, there isn’t one.
  
 Microservices are about having a single business purpose. And 
 even more vexing for enterprise settings, the most effective 
 runtime for microservices isn’t necessarily a full-blown 
 application server. It might just be a servlet engine or that the 
 JVM is already sufficient as an execution environment. With the 
 growing runtime variations and the broader variety of 
 programming language choices, this development turned into 
 yet another operations nightmare. Where Platform as a Service 
 (PaaS) offerings used to be the number one",NA
Containers: Fully Contained ,NA,NA
Applications,"If operations can’t provide full support for all of the available 
 lan‐guages and runtimes out there, there has to be something 
 else filling the gap. Instead of hiring an army of specialists for a 
 multitude of runtime environments, containers became an 
 obvious choice. Con‐tainers are an approach to virtualization in 
 which the virtualization layer runs as an application within the 
 operating system (OS). The OS’s kernel runs on the hardware 
 node with several isolated guest virtual machines (VMs) 
 installed on top of it. The isolated guests are called containers.
  
 They finally gave application developers the opportunity and 
 tooling to not only build, test, and stage applications, but also 
 the complete middleware infrastructure, including the relevant 
 configurations and dependencies. The good news here was that 
 projects no longer depended on centralized platform decisions, 
 and operations were still able to ensure a smooth production.",NA
"Public, Private, Hybrid: Scalable ",NA,NA
Infrastructures,"The number of environments needed for those projects spiked. 
 And none of the changes just discussed effectively saved money 
 in opera‐tions. Even worse, the additional time spent on making 
 DevOps and containers functional needed to be compensated. 
 This might be the most compelling explanation for the still-
 growing demand for cloud infrastructures.
  
 Although virtualization has proven to be cost-efficient by 
 running any number of the same instances, it was never easy to 
 manage and was tightly coupled to the hardware underneath. 
 As a matter of fact, it still had to scale alongside the demand of 
 the projects, and there was a cost assigned to every single 
 instance. It literally had to be bought and owned by the project 
 in most cases.
  
 Cloud infrastructures changed this quickly—pay for what you 
 use with rapid provisioning. Just recently, cloud platforms 
 received an upgrade to their capabilities with the emerging 
 container technolo‐gies. Instead of spinning up instances of 
 application servers or data‐bases, today’s most relevant 
 products rely on containers to define the",NA
CHAPTER 3,NA,NA
Designing ,NA,NA
Software for ,NA,NA
a Scalable ,NA,NA
Enterprise,"Looking back at the lessons learned alongside the latest 
 develop‐ments in software, the most pressing question 
 becomes: how do developers and architects design software for 
 enterprises that need to scale more quickly? With clouds and 
 containers serving as the new foundation, and more and more 
 applications adopting micro‐services architecture, everything 
 we knew about software design seems to be turned on its head.
  
 With that said, the basic concepts of software architecture and 
 design that were developed to cater to a multitude of 
 stakeholders, follow separation of concern principles, generate 
 quality, and guar‐antee the conceptual integrity of our 
 applications remain the pri‐mary drivers for creating great 
 software. And yet we do need to pay close attention to some of 
 the principles we already know and choose the correct 
 approach.
  
 Microservices remain an ever-present buzzword and viable 
 design pattern, yet upon closer inspection the name represents 
 a new term for a style of architecture that has been around a 
 while: modular design. Microservices are the right choice if you 
 have a system that is too complex to be handled as a monolith. 
 And this is exactly what makes this architectural style a valid 
 choice for enterprise applica‐tions. As Martin Fowler states in 
 his article about 
 “MicroservicePre‐mium”
 :",NA
Greenfield Versus Brownfield,"Most of today’s enterprise software was built years ago and still 
 undergoes regular maintenance to adopt the latest regulations 
 or new business requirements. Unless there is a completely new 
 busi‐ness case or significant internal restructuring, the need to 
 construct a piece of software from scratch is rarely considered. 
 But let’s assume we want to assess the need or even advantage 
 of implement‐ing a new microservices-based architecture. What 
 would be the most successful way to proceed? Start with a new 
 development from scratch (i.e., greenfield), or tear apart an 
 existing application into services (i.e., brownfield)? Both 
 approaches offer some risks and challenges.
  
 I remain convinced that it is much easier to partition an 
 existing,“brownfield” system than to do so up front with a new, 
 greenfield system.
  
 —Sam Newman 
  
 (Source: 
  
 http://bit.ly/1FMXNjs)
  
 As usual, the common ground is small but critical: you need to 
 know the business domain you’re working on. And I would like 
 to take this point even further: enterprise projects, especially 
 those 
 considered 
 long-term, 
 tend 
 to 
 be 
 sparse 
 on 
 documentation, and it is even more important to have access to 
 developers who are working in this domain and have firsthand 
 knowledge.
  
 Additionally, I believe any decision will have various shades of 
 com‐plexity. There are a range of options in brownfield 
 developments (i.e., migrations), and this allows for a very 
 selective and risk-free approach that will fit most business 
 requirements (more on this later in 
 “Migration Approaches” on 
 page 35
 ). No matter which avenue you pursue, you’ll need to 
 evaluate your own personal toolbox for success. Therefore, in 
 order to help you make the best decision pos‐sible, let’s get to 
 know the best methodologies and design patterns behind 
 modern enterprise application development.",NA
Domain-Driven Design,"The philosophy of domain-driven design (DDD) is about placing 
 the attention at the heart of the application, focusing on the 
 com‐plexity of the core business domain. Alongside the core 
 business features, you’ll also find supporting subdomains that 
 are often generic in nature, such as money or time. DDD aims to 
 create mod‐els of a problem domain. All the implementation 
 details—like per‐sistence, user interfaces, and messaging—
 come later. The most cru‐cial thing to understand is the domain, 
 because this is what a major‐ity of software design decisions are 
 going to be based on. DDD defines a set of concepts that are 
 selected to be implemented in soft‐ware, and then represented 
 in code and any other software artifact used to construct the 
 final system.
  
 Working with a model always happens within a context. It can 
 vary between different requirements or just be derived, for 
 example, from the set of end users of the final system. The 
 chosen context relates to the concepts of the model in a defined 
 way. In DDD, this is called the bounded context (BC). Every 
 domain model lives in precisely one BC, and a BC contains 
 precisely one domain model. A BC helps to model and define 
 interactions between the BC and the model in many different 
 ways. The ultimate mapping for the model is the inside view of 
 the one related BC.
  
 Assuming we already have a layered application approach (e.g., 
 pre‐sentation, application, domain, infrastructure), DDD acts on 
 the domain layer. While the application layer mostly acts as a 
 mediator between presentation, domain, and infrastructure 
 (and holds addi‐tional crosscutting concerns, such as security 
 and transactions), the domain layer only contains the business 
 objects. This includes the value objects themselves and all 
 related artifacts (e.g., property files, translations) and the 
 module structure, which typically is expressed in packages (e.g., 
 in Java) or namespaces.
  
 Entities, values, and modules are the core building blocks, but 
 DDD also has some additional features that will help you to 
 model your application so that you can build it from domain 
 services. A domain service corresponds to business logic that 
 does not easily live within an entity or it can act as a proxy to 
 another BC. While a domain ser‐vice can both call or be called 
 by a domain entity, an application ser‐vice sits above the 
 domain layer, so it cannot be called by entities",NA
Service Characteristics,"For a first migration assessment, it is helpful to identify and 
 separate the services into categories by looking at some key 
 characteristics. It is recommended to only use them in a first 
 round of qualification for a potential microservices migration 
 and not as a design or refac‐toring methodology. Let’s discuss 
 the most important ones in the following subsections.",NA
Core Services,"Core services follow the definition of domain services and 
 expose a specific domain entity, including all relevant base 
 operations, directly to a consumer. If you don’t have a domain 
 model, you can watch out for entities named after nouns. 
 Another good starting point is a use case or user story. You can 
 even find a lot of examples from common business processes, 
 such as:
  
 • Order
  
 • Shipping
  
 • Catalog
  
 • User
  
 • Customer",NA
Process Services,"Process services follow the business services definition and are 
 responsible for performing a single, complex task. They usually 
 rep‐resent a business action or process related to and relying on 
 one or more core services. Finding the right partition without a 
 domain model is time consuming and needs to be thought 
 through before implementing. Try to keep the focus on the 
 different business capa‐bilities of a system. Respect the already-
 known drawbacks from tra‐ditional architectures, and keep the 
 network latency and number of hops in mind. It might be easier 
 to verbalize a process service by putting its mission statement 
 up front, such as the following:
  
 • This service lists similar courses for a given course.
  
 • This service places an order for a customer.
  
 • This service reroutes a shipment.
  
 • This service logs an order step for a customer.
  
 If the work of a first assessment is done, you also want to see 
 how much of the existing application already adheres to the 
 basic requirements for building a microservices architecture.",NA
Microservices Best Practices,"The following principles have emerged as best practices for 
 develop‐ing, 
 and 
 working 
 with, 
 microservices-based 
 architecture. These principles are helpful during the initial 
 assessment and serve as a checklist for your greenfield project.",NA
Design for Automation,"Continuous delivery (CD) is a software engineering approach 
 where teams produce usable software in short cycles while 
 ensuring that they can be reliably released at any time. It is used 
 in software devel‐opment to automate and improve the process 
 of software delivery. CD is a complex and comprehensive 
 enough topic to take up vol‐umes and not just a few paragraphs. 
 However, the idea behind con‐tinuous delivery provides the 
 mechanism by which the innovation cycle for microservices-
 based applications can operate. The princi‐ple of continuous 
 delivery that is most relevant here is the ability to deploy 
 rapidly into production, shortening the cycle time between an 
 idea and feedback on the value of the idea.
  
 Achieving rapid deployment requires many continuous delivery 
 techniques, 
 including 
 infrastructure 
 automation, 
 build 
 automation, deployment and rollback automation, data 
 migration automation, and (of course) test automation. Each of 
 these 
 techniques 
 is 
 neces‐sary 
 to 
 support 
 the 
 rapid 
 development of new features, rapid testing of the new system, 
 safe and rapid deployment of the application into production, 
 and safe and rapid rollback in case the system isn’t working as 
 expected or if the feature turns out to be a bad idea.",NA
Design for Failure,"The premium standard for high availability is five 9s, which 
 stands for a guaranteed uptime of 99.999%. Over the course of a 
 complete year, that means just five and a half minutes of 
 downtime. Tradi‐tional approaches often use the words 
 “reliability” and “preventing failure” interchangeably. But cloud-
 based microservices architec‐tures are completely different.
  
 With applications composed of a large number of individual 
 serv‐ices, you have to deal with an exponentially growing 
 complexity that touches all relevant parts of an application in 
 order to measure avail‐ability and design for failure. And 
 complexity due to more interde‐",NA
Design for Data Separation,"Consider a traditional monolithic application that stores data in 
 a single relational database. Every part of the application",NA
Design for Integrity,"While data for each service is kept fully separate, services can 
 be kept in a consistent state with compensating transactions. 
 The rule of thumb should be that one service is exactly related 
 to one transac‐tion. This is only a viable solution while all 
 services which persist data are up and running and available. If 
 this isn’t the case, you can still completely fail the calling service 
 cascade 
 and 
 rollback 
 earlier 
 calls 
 with 
 compensation 
 transactions, but the end result is eventual consistency without 
 any guarantees. This might not be enough for enterprise 
 systems. The following subsections discuss several differ‐ent 
 approaches you can use to solve this issue.
  
 Use transactions
  
 It is a common misunderstanding that microservices-based 
 archi‐tectures can’t have or use transactions at all. There are 
 plenty of ways to use atomic or extended transactions with 
 different technologies that consider themselves part of the 
 modern software stack. Exam‐ples of technologies range from 
 server-supported transaction man‐agers, to OMG’s Additional 
 Structuring Mechanisms for the OTS and WS-Transactions from 
 OASIS, to even vendor-specific solutions like REST-AT. 
 Implementing equivalent capabilities in your infra‐structure or 
 the services themselves (e.g., consistency in the pres‐ence of 
 arbitrary failures, opaque recovery for services, modular 
 structuring mechanisms, and spanning different communication 
 patterns) is something you should consider very carefully.",NA
Design for Performance,"Performance is the most critical part of all enterprise 
 applications. Even if it is the most underspecified, nonfunctional 
 requirement of all, it is still the most complained about.
  
 Microservices-based architectures can significantly impact 
 perfor‐mance in both directions. First of all, the more coarse-
 grained serv‐ices lead to a lot more service calls. Depending on 
 the business logic and service size, this effect is known to fan 
 out a single service call to up to 6 to 10 individual backend-
 service calls, which only adds the same amount of additional 
 network latency in the case of a synchro‐nous service. The 
 strategies to control this issue are plenty and vary depending on 
 many factors.
  
 Load-test early, load-test often
  
 Performance testing is an essential part of distributed 
 applications. This is even more important with new 
 architectures. You need to make sure that the performance of 
 the complete system is actively tested and individual services 
 perform as they’ve been tested in development already.
  
 This is equally important as actual runtime monitoring. But the 
 big‐gest difference is that load testing is a proactive way to 
 verify the ini‐tial metainformation of an individual service or 
 group of services. It is also a way to identify and define the 
 initial SLAs. Whereas most articles and books on microservices 
 don’t stress this part explicitly, load testing is especially 
 important in enterprises to help with the mind shift needed for 
 this new kind of application architecture and operational model.
  
 Use the right technologies for the job
  
 The usual approach is to base all your endpoints on RESTful 
 calls. As a matter of fact, this might not be the only feasible 
 solution for your requirements. The often-preached, one-to-one 
 relationship between HTTP-based RESTful services and 
 microservices architec‐tures isn’t cast in stone. Everything 
 about endpoint technologies, interface architecture, and 
 protocols can be put to the test in enter‐prise environments.
  
 Some services will be better off communicating via synchronous 
 or asynchronous messaging, but others will be ideally 
 implemented using RESTful endpoints communicating over 
 HTTP. There may",NA
Independently ,NA,NA
Deployable and Fully ,NA,NA
Contained,"A microservices architecture will make it easier to scale 
 develop‐ment. With this technology, there is no large team of 
 developers responsible for a large set of features or individual 
 layers of the monolith. However, with constantly shifting team 
 setups and responsibilities for developers comes another 
 requirement: services need to be independently deployable.
  
 Teams 
 are 
 fully 
 responsible 
 for 
 everything 
 from 
 implementation to commissioning and this requires that they 
 are in full control of the individual services they are touching. 
 Another advantage is that this design pattern supports fault 
 isolation. If every service ideally comes with its own runtime, 
 there is no chance a memory leak in one ser‐vice can affect 
 other services.",NA
Crosscutting Concerns,"Crosscutting concerns typically represent key areas of your 
 software design that do not relate to a specific layer in your 
 application. In a domain-driven design approach, this shouldn’t 
 happen. But you really want crosscutting concerns to be 
 reusable non-domain-related concerns that aren’t scattered 
 around the whole project. This is where design concepts like 
 dependency injection (DI)
  and 
 aspect-oriented programming 
 (AOP)
  can be used to complement object-oriented design 
 principles to minimize tight coupling, enhance modularity, and 
 better manage the crosscutting concerns.",NA
Security,"Security in microservices applications breaks down into three 
 differ‐ent levels (
 Figure 3-3
 ).",NA
Logging,"Although logging in typical enterprise environments only has to 
 ful‐fill a few basic needs (such as developer support, debugging 
 in pro‐duction, and business transaction logging), the nature of 
 a dis‐tributed system requires a lot more.
  
 Because one service request can be split out to many different 
 subse‐quent requests and produce an error somewhere 
 downstream, log‐ging should be able to follow the complete 
 request path down to the error. This might be done with unique 
 service request IDs or even with the help of an HttpSession or 
 SSL session ID (captured at the entry service). And all the 
 distributed logging sources need to be collected in a single 
 application-wide log.
  
 Depending on the existing environment, this can be done with 
 log‐ging frameworks that support syslog or other existing 
 centralized",NA
Health Checks,"Health checks are an important part of DevOps. Every part 
 needs to be controlled and monitored from the very beginning. 
 Besides just having a simple “is-alive” servlet, the need for more 
 sophisticated health checks on a service level arises when using 
 a microservices architecture.
  
 However, there are different ways of approaching this 
 requirement. A simple approach is to select an API management 
 solution that not only deals with governance and load balancing 
 but also handles the SLA and implicit health monitoring of every 
 service. Although this is strongly recommended, there are 
 plenty 
 of 
 other 
 solutions 
 start‐ing 
 from 
 custom 
 implementations up to more complex monitoring approaches.",NA
Integration Testing,"While integration testing for Java EE applications has always 
 been important 
 but complex, 
 it 
 is 
 even 
 harder for 
 microservices-based, distributed systems. As usual, testing 
 begins with the so-called mod‐ule or developer tests. Typically 
 running on a single developer machine, integration tests for 
 distributed systems require the pres‐ence of all downstream 
 services. With everything completely auto‐mated, this also 
 includes controlling the relevant containers with the dependent 
 services. Although mocking and tests based on intelligent 
 assumptions were best practices a couple of years back, today’s 
 sys‐tems have to be tested with all the involved services at the 
 correct version.
  
 First and foremost, this requires a decent infrastructure, 
 including complete test and integration systems for the various 
 teams. If you’re coming from a traditional enterprise 
 development environment, it might feel odd to exceed the 
 existing five different test stages and corresponding physical 
 machines. But working with microservices and being successful 
 in enterprise settings will require having a PaaS offering, which 
 can spin up needed instances easily and still be cost-effective.
  
 Depending on the delivery model that has been chosen, this 
 might involve building container images and spinning up new 
 instances as",NA
CHAPTER 4,NA,NA
Java EE and ,NA,NA
Microservices,"Java EE began with less than 10 individual specifications, but it 
 has grown over time through subsequent updates and releases 
 to 
 encompass 
 34. 
 Compared 
 to 
 microservices-based 
 architectures, Java EE and its included specifications were 
 originally 
 designed 
 for 
 a 
 dif‐ferent 
 development 
 and 
 deployment model. Only one monolithic server runtime or 
 cluster hosted many different applications pack‐aged according 
 to standards. Such a model runs opposite to the goal of 
 microservices.
  
 Most Java EE APIs are synchronous, and scaling these resources 
 is done through thread pools. Of course, this has its limits and is 
 not meant to be adjusted for quickly changing requirements or 
 excessive load situations. Given these requirements, it appears 
 as if Java EE isn’t the best choice for developing microservices-
 based architec‐tures.
  
 But the latest versions of Java EE added a ton of developer 
 produc‐tivity to the platform alongside a streamlined package. 
 With the sloping modularity of Java and the JVM, an established 
 platform, 
 and 
 skilled 
 developers 
 alongside 
 individual 
 implementations, Java EE is considered to be a reasonable 
 solution for microservices devel‐opment.",NA
Matching the Real World,"The latest available Java EE specification as of the writing of this 
 report is Java EE 7. It contains 
 34 individual specifications
 , as 
 shown in 
 Figure 4-1
 .
  
  
 Figure 4-1. Java EE 7 at a glance
  
 There are a lot of technologies that barely offer any advantages 
 to microservices-based architectures, such as the Java 
 Connector Architecture or the Batch Processing API. If you are 
 starting to build microservices architectures on top of Java EE, 
 make sure to look at the asynchronous features and try to use 
 the best available parts. One important item to keep in mind: 
 Java EE was never built to work with distributed applications or 
 microservices. So every decision and line of code should be 
 carefully inspected and validated to maximize asynchronicity.
  
 JAX-RS 2.0
  
 To execute asynchronous requests in JAX-RS, inject a reference 
 to a 
 javax.ws.rs.container.AsyncResponse
  interface in the JAX-RS 
 resource method as a parameter. The 
 resume
  method on the 
 AsyncResponse
  object needs to be called from within a separate 
 thread after the business logic execution is complete, as 
 illustrated here:
  
 32 
  
 | 
  
 Chapter 4: Java EE and Microservices",NA
The Missing Pieces,"To build a complete and reliable microservices application, you 
 need something more than what typical Java EE servers provide 
 today. Those missing pieces are relevant, and you only have the 
 chance to build them individually or put an infrastructure in 
 place to deliver them. Those pieces are also called “NoOps” or 
 the outer architec‐ture
 ; see 
 Figure 4-2
 .
  
  
 Figure 4-2. Outer architecture for microservices",NA
API Gateway/Management Solution,"See 
 “Microservices Best Practices” on page 19
  in 
 Chapter 3
  for 
 fur‐ther 
 information 
 about 
 this 
 solution. 
 API 
 gateway/management is an integral part of any microservices 
 infrastructure.",NA
Service Registry,"Multiple microservices are composed to create an application, 
 and each microservice can scale independently. The endpoint of 
 the ser‐vice may not be known until it’s deployed, especially if 
 it’s deployed in a PaaS. Service registration allows each 
 microservice to register itself with a registry using a logical 
 name. This name is bound to a physical URI and additional 
 metainformation.
  
 By using the logical name, a consumer can locate and invoke the 
 microservice after a simple registry query. If the microservice 
 goes",NA
Security,"In a traditional multitiered server architecture, a server-side 
 web tier deals with authenticating the user by calling out to a 
 relational data‐base or a Lightweight Directory Access Protocol 
 (LDAP) server. An HTTP session is then created containing the 
 required authentication and user details. The security context is 
 propagated between the tiers within the application server so 
 there’s no need to reauthenti‐cate the user.
  
 This is different with microservices because you don’t want to 
 let this expensive operation occur in every single microservices 
 request over and over again. Having a central component that 
 authenticates a user and propagates a token containing the 
 relevant information downstream is unavoidable. Enterprise 
 access management (EAM) systems mostly provide the needed 
 features in an enterprise envi‐ronment. In addition, some API 
 management solutions also contain security features on top of 
 their government engine. And last but not least, there are 
 dedicated products, like JBoss Keycloak.",NA
Migration Approaches,"Putting the discussion in 
 Chapter 3
  about greenfield versus 
 brown‐field development into practice, there are three different 
 approaches to migrating existing applications to microservices.",NA
Selective Improvements,"The most risk-free approach is using selective improvements 
 (
 Figure 4-3
 ). After the initial assessment, you know exactly 
 which parts of the existing application can take advantage of a 
 microservi‐ces architecture. By scraping out those parts into 
 one or more serv‐ices and adding the necessary glue to the 
 original application, you’re able to scale out the microservices in 
 multiple steps:
  
 • First, as a separate deployment in the same application 
 server 
  
 cluster or instance",NA
The Strangler Pattern,"Comparable but not equal is the second approach where you 
 run two different systems in parallel (
 Figure 4-4
 ). First coined 
 by 
 Martin 
 Fowler 
 as 
 the 
 StranglerApplication
 , 
 the 
 refactor/extraction candi‐dates move into a complete new 
 technology stack, and the existing parts of the applications 
 remain untouched. A load balancer or proxy decides which 
 requests need to reach the original application and which go to 
 the new parts. There are some synchronization issues between 
 the two stacks. Most importantly, the existing appli‐cation can’t 
 be allowed to change the microservices’ databases.",NA
Big Bang: Refactor an Existing System,"In very rare cases, complete refactoring of the original 
 application might be the right way to go. It’s rare because 
 enterprise applications will need ongoing maintenance during 
 the complete refactoring. What’s more, there won’t be enough 
 time to make a complete stop for a couple of weeks—or even 
 months, depending on the size of the application—to rebuild it 
 on a new stack. This is the least recom‐mended approach 
 because it carries a comparably high risk of fail‐ure.
  
 Migration Approaches 
  
 | 
  
 37",NA
CHAPTER 5,NA,NA
Microservices ,NA,NA
Design Pattern,"Functional decomposition of an application with the help of 
 DDD is a prerequisite for building a microservices architecture. 
 Only this approach allows you to effectively design for loose 
 coupling and high cohesion. Even if you go with the much 
 simpler service charac‐teristics, you’ll still be able to decompose 
 already 
 existing 
 applica‐tions. 
 However, 
 unlike 
 with 
 applications, which are tied together by the frontend, 
 microservices can interact with each other and span a network 
 of service calls. To keep the variety of interactions compre‐
 hensible and maintainable, a first set of patterns have emerged 
 that will help you to model the service interaction. These 
 patterns were first published by 
 Arun Gupta
 , but have been 
 revised for this report.",NA
Common Principles,"Every microservice has some common basic principles that 
 need to be taken into account. They are derived from a quick 
 recap 
 of 
 “Ser‐vice 
 Characteristics” 
 on 
 page 
 17
  
 and 
 “Microservices Best Practices”on page 19
 .",NA
"To Avoid Trunk Conflict, Each ",NA,NA
Microservice Is Its Own Build,"Conduct a separate build for each microservice. One reason for 
 this is that teams can be fully responsible for putting new 
 versions into production. It also enables the team to use the 
 needed downstream services at the correct revision by querying 
 the repository. Compare
 “Independently Deployable and Fully 
 Contained” on page 26
 .",NA
The Business Logic Is Stateless,"Treat the logic in your services as stateless. Needing to replicate 
 state across various services is a strong indicator of a bad 
 design. Services are fully contained and independent and should 
 be able to work without any prepopulated state. Compare 
 Chapter 3
 .",NA
The Data Access Layer Is Cached,"In order to keep service response times to a minimum, you 
 should consider data caching in every service you build. And 
 keep in mind
 “Design for Performance” on page 24
 .",NA
Create a Separate Data Store for Each ,NA,NA
Microservice,"Compare 
 “Design for Integrity” on page 22
  and 
 “Design for Data 
 Separation” on page 21
 .",NA
Aggregator Pattern,"The most simplistic pattern used with microservices is the 
 aggrega‐tor pattern (
 Figure 5-1
 ). It is already well known from 
 the Enterprise Integration pattern catalog and has proven to be 
 useful outside microservices architecture. The primary goal of 
 this pattern is to act as a special filter that receives a stream of 
 responses from service calls and identifies or recognizes the 
 responses that are correlated. Once all the responses have been 
 been collected, the aggregator cor‐relates them and publishes a 
 single response to the client for further processing.
  
 In its most basic form, aggregator is a simple, single-page 
 applica‐tion (e.g., JavaScript, AngularJS) that invokes multiple 
 services to achieve the functionality required by a certain use 
 case. Assuming",NA
Proxy Pattern,"The proxy pattern allows you to provide additional interfaces to 
 services by creating a wrapper service as the proxy (
 Figure 5-2
 ). 
 The wrapper service can add additional functionality to the 
 service of interest without changing its code.
  
 Proxy Pattern 
  
 | 
  
 41",NA
Pipeline Pattern,"In more complex scenarios, a single request triggers a complete 
 ser‐ies of steps to be executed. In this case, the number of 
 services that have to be called for a single response is larger 
 than one. Using a pipeline of services allows the execution of 
 different operations on the incoming request (
 Figure 5-3
 ). A 
 pipeline can be triggered syn‐chronously or asynchronously, 
 although the processing steps are most likely synchronous and 
 rely on each other. But if the services are using synchronous 
 requests, the client will have to wait for the last step in the 
 pipeline to be finished.
  
 42 
  
 | 
  
 Chapter 5: Microservices Design Pattern",NA
Shared Resources,"One of the critical design principles of microservices is 
 autonomy. Especially in migration scenarios (see “Migration 
 Approaches” on page 43), it might be hard to correct design 
 mistakes made a couple of years ago. And instead of reaching 
 for the big bang, there might be a more reasonable way to 
 handle those special cases.
  
 Running into a situation where microservices have to share a 
 com‐mon data source isn’t ideal. However, it can be worked 
 around with the “shared resources” pattern (
 Figure 5-4
 ). The 
 key here is to keep the business domain closely related and not 
 to treat this exception as a rule; it may be considered an 
 antipattern but business needs might",NA
Asynchronous Messaging,"Typical RESTful design patterns are common in the 
 microservices world. Most likely, they are implemented in a 
 synchronous and therefore blocking manner. Even if this can be 
 changed in Java EE, and the implementations support 
 asynchronous calls, it might still be considered a second-class 
 citizen in the enterprise systems you are trying to build. 
 Message-oriented middleware (MOM) is a more reasonable 
 solution to integration and messaging problems in this field, 
 especially when it comes to microservices that are exposed by 
 host systems and connected via MOMs. A combination of REST 
 request/response and pub/sub messaging may be used to 
 accom‐plish the business need (
 Figure 5-5
 ).
  
 44 
  
 | 
  
 Chapter 5: Microservices Design Pattern",NA
CHAPTER 6,NA,NA
Conclusion,"The world of IT as we know it is changing dramatically. Just 
 over five years ago, developers would spend months or even 
 years devel‐oping infrastructures and working on the 
 integration of various applications. Huge projects with multiple 
 participants were required to implement the desired specific 
 features.
  
 With the advent of DevOps and various Platform as a Service 
 (PaaS) environments, many complex requirements must now be 
 met within a much shorter timeframe. The Internet of Things 
 (IoT) is also anticipated to change established applications and 
 infrastructures. As a result of these converging trends, the way 
 in which developers work is set to undergo a fundamental shift 
 in the coming years.
  
 As these trends unfold, the industry is already mapping the way 
 for‐ward, 
 anticipating 
 how 
 all 
 the 
 components—from 
 technologies to processes—will come together in this new 
 development paradigm. And all of this will find its way into 
 today’s enterprises. While the adoption speed will vary and the 
 pure doctrine of the early adopters will have to be tweaked, 
 there are strong signs that the recent uptake in microservices 
 architectures will not fade. Knowing this, we need to be aware 
 of the challenges to come and figure out how to adapt to these 
 paradigms in practice.
  
 It is a core responsibility for enterprise developers to help 
 further shape this future and keep on learning how to best 
 adopt the new technologies in the field. 
 Appendix B
  contains a 
 long list of refer‐ences and recommended readings for getting 
 started with this future. Another excellent publication for 
 learning more about",NA
APPENDIX A,NA,NA
Additional Technologies ,NA,NA
and Team ,NA,NA
Considera,NA,NA
tions,"As already mentioned, software architecture does not adhere to 
 a strict process for creation. However, what it does involve is a 
 lot of teamwork, creativity, and flexibility in adopting changing 
 require‐ments. This not only covers the design of the system or 
 individual services, but also reaches out to the technologies 
 used and various team dynamics. Unlike with traditional Java EE 
 applications, where the infrastructure is well defined by the 
 application server in use, the solution space for microservices-
 based systems is open ended and requires a different 
 perspective on teams.
  
 This appendix is designed to point you to alternative 
 microservices solutions outside of the traditional Java EE 
 ecosystem. It also pro‐vides greater insight into aligning teams 
 to work with highly scalable architectures.",NA
Architecture != Implementation,"Approaches to architectural design do not contain an implicit 
 method for implementation. This is also true for microservices, 
 although the service contracts in a microservices-based 
 architecture allow for a flexible decision about the underlying 
 implementation. It doesn’t even have to be on one platform or 
 language.",NA
Vert.x,"Vert.x
  is an asynchronous, nonblocking framework for 
 development of applications of all kinds. Although it has been 
 mainly discussed in the context of web applications, it has far 
 broader appeal than purely the Web.
  
 Unlike traditional stacks, it’s been designed from day one to be 
 scal‐able and compatible with microservices architectures, so 
 it’s almost completely nonblocking when it comes to OS threads. 
 This is the most critical component for microservices-based 
 applications, which naturally have to handle a lot of concurrent 
 processing of messages or events while holding up a lot of 
 connections. Vert.x also supports the usage of a variety of 
 different languages (e.g., Java‐Script, Ruby, and Groovy).
  
 This type of functionality can be achieved without being a 
 container or an invasive framework. You can use Vert.x inside 
 your applica‐tions and integrate with already existing 
 frameworks such as Spring. The nonblocking nature and 
 reactive programing model speeds along the adoption of basic 
 microservices design principles and rec‐ommendations, making 
 this framework easier to use than other platforms. It’s also 
 minimally invasive and can be integrated with existing 
 applications, in turn offering an interesting migration path for 
 brownfield developments.",NA
WildFly Swarm,"WildFly Swarm
  is a sidecar project of 
 WildFly 9.x
  to enable 
 decon‐structing the WildFly Java EE application server to your 
 needs. WildFly Swarm allows developers to package just enough 
 of its modules back together with their application to create a 
 self-contained executable JAR.
  
 The typical application development model for a Java EE 
 application is to create an EAR or WAR archive and deploy it to 
 an application server. All the required Java EE dependencies are 
 already available to",NA
Spring Boot with Spring Cloud,"Spring Boot
  is part of the larger Spring ecosystem. It has 
 evolved as a framework especially designed for microservices. It 
 is built on top of the Spring framework and uses the maturity of 
 it while adding additional features to aid the development of 
 microservices-based applications.
  
 Developer productivity is a “first class” citizen, and the 
 framework 
 adds 
 some 
 basic 
 assumptions 
 about 
 how 
 microservices applications should be built. This includes the 
 assumption that all services have RESTful endpoints and are 
 embedded into a standalone web appli‐cation runtime. The 
 overall Spring methodology to adopt the rele‐vant features and 
 leave out the others is also practiced here. This leads to a very 
 lean approach that can produce small units of deployments that 
 can be used as runnable Java archives.",NA
Dropwizard,"Dropwizard
  is a Java framework for developing ops-friendly, 
 high-performance, RESTful web services. It pulls together well-
 known, stable, mature libraries from the Java ecosystem (e.g., 
 Jetty, Jersey, and Jackson) into a “fat JAR.” Dropwizard has out-
 of-the-box sup‐port for configuration, application metrics, 
 logging, 
 operational 
 tools, 
 and 
 more. 
 The 
 individual 
 technologies are wired together with the help of various 
 interfaces and annotations that can be viewed as the glue in 
 between. This leaves the user with having to know the 
 individual technologies first, plus the wiring in between them. 
 So, there is a learning curve involved, but not a steep one.",NA
Roll Your Own,"Another very common alternative is to roll your own Java EE-
 like platform on the base of 
 Apache Tomcat
 . By packaging the 
 relevant and needed modules together, it can be a feasible 
 alternative even if it will require a lot more effort in building the 
 initial stack of frame‐works and libraries.",NA
Thoughts About Teams and ,NA,NA
Cultures,"While you can read a lot about how early adopters like Netflix 
 struc‐tured their teams for speed instead of efficiency, there is 
 another more reasonable approach for enterprise software 
 development teams. Most basically, it is important to keep them 
 focused. Teams should be aligned around business capabilities 
 and responsibilities. This ensures that the business focus is 
 present and can be reused with every new service that falls into 
 one of the business domains. On the other hand, it is also very 
 important to still have a business consultant as part of a team.",NA
APPENDIX B,NA,NA
Further Resources,"Each of the following resources will provide additional insight 
 and help you to develop your own perspective on 
 microservices-based architecture:
  
 •
  Martin Fowler on “Microservices”
 . A gentle introduction and 
 a first approach at a definition.
  
 •
  Martin Fowler on “MicroservicePremium”
 . Some further 
 explanation on what microservices and enterprises mean.
  
 •
  “The microservice resource guide”
  by Martin Fowler. 
 Collecting various articles and discussions along this topic.
  
 •
  Netflix Open Source Software Center
 . Contains links and fur‐
 ther information on the frameworks and libraries 
 referenced throughout the book.
  
 •
  Microservices at Netflix: Best Practices and Tools
 . One of 
 many presentations from the Netflix team that gives a good 
 overview of the company’s work.
  
 •
  “Microservices Design Patterns”
  by Arun Gupta. The first col‐
 lection of patterns for the newly emerging architecture 
 style. Arun is also featuring more 
 microservices-related 
 posts
  on his blog.
  
 • Mark Little, 
 “What is so Special about Microservices?”
  Deals 
 with how microservices reflect an evolution in our 
 understand‐ing of how to build services.
  
 55",NA
About the Author,"Markus Eisele is a Developer Advocate at Red Hat, and focuses 
 on JBoss Middleware. He has been working with Java EE servers 
 from different vendors for more than 14 years and talks about 
 his favorite topics relating to Java EE at conferences all over the 
 world. He has been a principal consultant and worked with 
 different customers on all kinds of Java EE-related applications 
 and solutions. Outside of this, he is a prolific blogger, writer, and 
 tech editor for Java EE-related books and publications. He is a 
 board member of the Ger‐man DOAG e.V. and serves as its 
 representative on the iJUG e.V. As a Java Champion and former 
 ACE Director, he is well known in the community. More 
 frequent updates are available on his 
 Twitter feed 
 and 
 blog
 .",NA
