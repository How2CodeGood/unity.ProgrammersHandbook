Larger Text,Smaller Text,Symbol
Power Programming ,NA,NA
with ,NA,NA
Mathematica,"Disclaimer & Limitation Liability
  
 McGraw-Hill makes no representations or warranties as to the accuracy of 
 any information contained in the McGraw-Hill Material, including any 
 warranties of merchantability or fitness for a particular purpose. In no 
 event shall McGraw-Hill have any 
  
 liability to any party for special, incidental, tort, or 
  
 consequential damages arising out of or in connection with the McGraw-Hill 
 Material, even if McGraw-Hill has been advised of the possibility of such 
 damages.",NA
Power Programming ,NA,NA
with ,NA,NA
Mathematica,NA,NA
The Kernel,NA,NA
David B. Wagner,"Principia Consulting
  
 Boulder, Colorado
  
 McGraw-Hill
  
 New York San Francisco Washington, D.C. Auckland Bogoti Caracas 
 Lisbon London Madrid Mexico City Milan 
  
 Montreal New Delhi San Juan Singapore 
  
 Sydney Tokyo Toronto",NA
McGraw-Hill ,NA,NA
gg,"A Division ofTheMcGmm-HtUCon^xmies
  
 Copyright © 1996 by The McGraw-Hill Companies, Inc. All rights 
 reserved. Printed in the United States of America. Except as permitted 
 under the United States Copyright Act of 1976, no part of this 
 publication may be reproduced or distributed in any form or by any 
 means, or stored in a data base or retrieval system, without the prior 
 written permission of the publisher.
  
 1 2 3 4 5 6 7 8 9 0  AGM/AGM 9 0 1 0 9 8 7 6
  
 P/N 067679-8 
  
 PART OF 
  
 ISBN 0-07-912237-
 X
  
 The sponsoring editor for this book was John Wyzalek, the editing supervisor was
  
 Stephen M. Smith, and the production supervisor was Pamela A. Pelton.
  
 Printed and bound by Quebecor/Martinsburg.
  
 McGraw-Hill books are available at special quantity discounts to use 
 as premiums and sales promotions, or for use in corporate training 
 programs. For more information, please write to the Director of 
 Special Sales, McGraw-Hill, 11 West 19th Street, New York, NY 
 10011. Or contact your local bookstore.
  
 This book is printed on acid-free paper.
  
 Information contained in this work has been obtained by The 
 McGraw-Hill Companies, Inc. (“McGraw-Hill”) from sources 
 believed to be reliable. However, neither McGraw-Hill nor its 
 authors guarantee the accuracy or com-pleteness of any information 
 published herein and neither McGraw-Hill nor its authors shall be 
 responsible for any errors, omissions, or damages arising out of use 
 of this information. This work is published with the understanding 
 that McGraw-Hill and its authors are supplying information but are 
 not attempting to render engineering or other professional services.",NA
Contents ,Preface ix,NA
P arti: Preliminaries,"1 
  
 2 
  
 3 
  
 Introduction 3
  
 1.1 
 1.2 
 1.3 
  
 Programming in 
 Mathematica 4 
 Power Programming Examples 7 
 Where to Go Next 15
  
 Language Fundamentals 17
  
 2.1 
 2.2 
 2.3 
  
 Expressions 17 
  
 Evaluation of Expressions 25 
 Special Input Forms 30
  
 Lists and Strings 49
  
 3.1 
  
 List Basics 49
  
 3.2 
 3.3 
 3.4 
 3.5 
 3.6 
 3.7 
  
 Generating Lists 52 
  
 Listable Functions 54 
  
 Getting Information about Lists 56 
 Manipulating Lists 58 
  
 Character Strings 63 
  
 Appendix: Listable Functions 67",NA
Part 2: Programming Techniques,"4 
  
 Procedural Programming 71
  
 4.1 
 4.2 
 4.3 
  
 Functions 71 
  
 Conditional Execution 80 
  
 Iteration 83
  
 4.4 
 4.5 
  
 Parameter-Passing Semantics 88 
 Advanced Topic: Scoping 93",NA
Part 3: Extending the System,"8 
  
 9 
  
 Writing Packages 229
  
 8.1 Contexts 229 
  
 8.2 Package Mechanics 235 
  
 8.3 Stylistic Considerations 241 
  
 8.4 Advanced Topic: Shadowing 243 8.5 
 Additional Resources 256
  
 Details, Details 257
  
 9.1 Diagnostic Messages 257 
  
 9.2 Options 262 
  
 9.3 Numerical Evaluation 266 
  
 9.4 Custom Output Formats 274 
  
 9.5 Respect Existing Definitions 279
  
 9.6 
 9.7 
  
 Application: Defining a New Data Type 283 
 Additional Resources 293",NA
Part 4: Programming for Performance,"10 Performance Tuning 297
  
 10.1 Rules of Thumb 298 
  
 10.2 Procedural Perils 305 
  
 10.3 Recursion Risks and Rewards 314 
  
 10.4 Rewrite Rules 320 
  
 10.5 Compiled Functions 325 
  
 10.6 Additional Resources 334
  
 11 
 MathUnk
 335
  
 11.1 
 MathLink
  Fundamentals 336 
  
 11.2 Template-Based 
 MathLink
  Programs 341 
  
 11.3 Debugging 
 MathLink
  Programs 349 
  
 11.4 Manual Data Handling 356 
  
 11.5 Integrating Installable Functions and Packages 365 
 11.6 Callbacks to the Kernel 369 
  
 11.7 Error Checking 372 
  
 11.8 Making Installed Functions Abortable 377 
  
 11.9 Miscellaneous 
 MathLink
  Data Types 378 
  
 11.10 Additional Resources 384",NA
PartS: Miscellanea,"12 Input/Output 387
  
 12.1 File and Directory Management 387 
 12.2 High-Level Output 388 
  
 12.3 Low-Level Output 392 
  
 12.4 High-Level Input 396 
  
 12.5 Low-Level Input 402 
  
 12.6 Additional Resources 404
  
 13 Debugging 405
  
 13.1 Tracing Evaluations 405 
  
 13.2 Interactive Debugging 413 
  
 13.3 Additional Resources 421
  
 Bibliography 423
  
 Index 427",NA
Preface,NA,NA
About ,NA,NA
Mathematica,"Mathematica
  has become phenomenally popular in the last few years for its 
 sophisti-cated numeric and symbolic mathematical capabilities. A lesser-known feature 
 of 
 Mathematica
  is its very elegant programming language. This language allows 
 virtually unlimited extension of the system’s capabilities to solve problems in special 
 areas of interest. In fact, hundreds of 
 Mathematica packages,
  embodying applications 
 ranging from airfoil design to Z transforms, are available from public Internet sites.
  
 Mathematica
  offers a combination of features that is unmatched by traditional pro-gram 
 development systems such as C, Fortran, and Lisp, including:
  
 • An interpretive environment for fast prototyping
  
 • Compilation for speed
  
 • An API (applications programming interface) for communicating with external pro­
  
 grams written in compiled languages
  
 • Functional and rule-based programming styles
  
 • Abstract data typing and modularity
  
 • Typeset mathematical input and output (version 3.0)
  
 • Seamless integration with the computational and graphical capabilities of 
 Mathema-tica
  (a partial list: exact or arbitrary-precision arithmetic (real or complex); 
 linear algebra; symbolic and/or numerical evaluation of derivatives, integrals, and 
 differen-tial equations; hundreds of built-in functions from number theory, 
 combinatorics, probability, statistics, and physics; 2-D and 3-D line, contour, surface, 
 and vector plots).",NA
Why 1 Wrote This Book,"There are scores of 
 Mathematica
  books available today; why bring yet another one into 
 the world? I wrote this book to give 
 Mathematica
  users a comprehensive source for 
 learning how to program in 
 Mathematica.
  There are two parts of this statement that I 
 want to stress: 
 comprehensive
  and 
 learning how to program.
  
 Regarding learning how to program: The majority of existing books about 
 Mathema-tica
  are example-based texts in a particular area of application. Some appear 
 to be pro-gramming books, but typically the author covers just enough about 
 Mathematica 
 programming to get to “the good stuff’ — that is, applying 
 Mathematica
  
 to his or her",NA
Why You Need This Book,"The audience for this book consists of 
 Mathematica
  users who want to start writing 
 programs, or who simply have a nagging feeling that the ways they solve their 
 prob-lems could be improved. In addition, 
 Mathematica
  programmers who want to write 
 sig-nificant extensions to the system will find this book valuable.
  
 Subtleties of the 
 Mathematica
  programming language
  
 There are three programming paradigms that 
 Mathematica
  supports: 
 procedural, 
 which is Fortran- or C-like; 
 functional,
  with which you might have some experience if 
 you've every programmed in Lisp; and 
 rule-based,
  which is typified by Prolog. Most 
 scientists and engineers, who are 
 Mathematica's
  principal user base, have no 
 experi-ence with any but the first of these paradigms.
  
 Because 
 Mathematica
  provides procedural programming constructs, a programmer 
 with a traditional background is likely to fall into the trap of programming the same 
 way he always has. Unfortunately,
  
 • Different ways of performing an equivalent computation can vary dramatically in 
  
 speed.
  
 • The best way of doing something is almost never the procedural way, and thus is not 
  
 obvious to someone who is used to traditional programming languages.
  
 1. Says one restaurant patron to another: “The food at this restaurant is 
 terrible!” Replies his companion: “Yes, and the portions are so 
 small!'’",NA
How to Use This Book,"Road map
  
 This book is designed to be read in a linear fashion; it does 
 not
  consist of a series of 
 stand-alone examples like some other books. Nevertheless, many people are going to 
 want to pick and choose from the available material. Section 1.3, “Where to Go Next,” 
 gives a broad overview of the book.
  
 Before going any further
  
 If you don’t already own a copy of 
 The Mathematica Book
  ([Wolfram 91] for 
 ver-sions prior to 3.0, [Wolfram 96] for version 3.0 and later), go out right now and buy 
 one. You can’t put it off forever, and it can save you untold amounts of frustration in 
 certain circumstances. It is the 
 final authority
  on 
 Mathematica.
  
 This book uses the generic term 
 “The Mathematica Book
 ” to refer to either [Wolfram 
 91] or [Wolfram 96], whichever is appropriate to the version of 
 Mathematica 
 that you 
 are using. For those cases in which the location of a reference differs between the two 
 books, a more specific citation of the form “[Wolfram 91] §A.B or [Wolfram 96] §X.Y” 
 will be used instead.
  
 Pedagogical notes
  
 Here are a few notes to give you some idea of what to expect as you read this book. 
 For the most part, the presentation style is based on what I have found to be 
 pedagogi-cally effective during my five years as a university professor.
  
 • In contrast to some authors’ preferences for presenting a completely developed piece 
 of code and then explaining it, I prefer to integrate the development of the code into 
 the presentation. This mirrors the way persons typically develop code in an 
 interac-tive programming environment such as 
 Mathematica.
  Presenting the 
 development step by step, rather than as an a 
 posteriori
  discussion, also makes it less 
 likely that explanations of crucial steps are omitted.
  
 • In those cases in which showing the final version of the code under development 
 would be too repetitive, the “finished product” can be found on the supplemental 
 dis-kette.
  
 • During the development of an example, I often show the “dead ends” that other authors 
 leave out. I believe that these dead ends, when properly explained, are valu-able 
 examples in and of themselves. Besides, except in the most trivial cases no one writes 
 a perfect program on the very first try, and it’s unrealistic to give the reader the 
 impression that he should be able to do so.",NA
Contacting the Author,"I would greatly appreciate hearing your comments about any of the material in this 
 book. This includes corrections, requests for clarification, and requests for additional 
 topics that you would like to see in a future edition. Please address all correspondence 
 to the author via the Internet at:
  
 dbwagner@princon.com
  
 And while you’re on-line, don’t forget to check out 
 Principia C onsulting’s 
 World-Wide 
 Web site at:
  
 http: //ww. princon. com/princon
  
 Corrections to the book and the electronic supplement, and answers to frequently-asked 
 questions, will be posted there as they are discovered. I ask that you please check that 
 site before contacting me with a bug report or a question.",NA
Colophon,"This book was produced on a Power Macintosh using versions 2.2.2 and 3.0|3l of 
 Mathematica,
  and version 4.0.4 of FrameMaker. The 
 Mathematica
  notebooks were 
 translated into Maker Interchange Format files using a proprietary filter developed by 
 me. The body text face is Times, the section head and side head face is Optima, the 
 chapter number face is Avant Garde, and the face used for computer voice is a 
 semicon-densed version of Prestige Elite with a few modifications (made using the font-
 editing program FontMonger).",NA
Acknowledgments,"First of all, a disclaimer: This list may be incomplete due to failing memory on my part; 
 I don’t mean to slight anyone who helped me out!
  
 I have a lot of WRI people to thank, but particularly John Fultz, Todd Gayley, Theo 
 Gray, Rob Knapp, Roman Maeder, K.J. Paradise, Shawn Sheridan, Robby Villegas, 
 Tom Wickham-Jones, and Dave Withoff. Without their willingness to discuss technical 
 issues, often in painstaking detail, this book would have been a lot less authoritative.
  
 4. MacOS users: If your computer won’t recognize this diskette, install the 
 PC 
 Exchange
  control panel and restart your machine. If your version of the system 
 doesn’t have this control panel, you will need to obtain a program called 
 Apple 
 File Exchange
  from Apple Computer, Inc.",NA
Power Programming ,NA,NA
with ,NA,NA
Mathematica,NA,NA
Part 1 ,NA,NA
Preliminarie,NA,NA
s,NA,NA
Introduction,"Different people have different ideas of what it means to program in 
 Mathematica. 
 To some, programming in 
 Mathematica
  means using the myriad of powerful built-in 
 functions to create “one-liners” that perform nontrivial calculations with a 
 minimum 
 of 
 effort. To others, it means defining new functions that extend the capabilities of the 
 sys-tem in some way. More advanced users want to place their function definitions in 
 sepa-rate files, called 
 packages,
  that encapsulate the details of the implementation.
  
 This book is intended to be a comprehensive reference to programming in 
 Mathema-tica.
  In addition to all of the above, we attempt to assemble under a single 
 cover many advanced techniques that either are scattered around the existing literature 
 or can’t be found at all. These techniques, which we group under the moniker 
 power 
 programming, 
 deal with issues such as: overriding built-in functions; making user-
 defined functions behave as much like the built-in ones as possible; adding new abstract 
 data types; changing the global behavior of the system; tuning 
 Mathematica
  code for 
 performance; and using the 
 MathLink
  interprogram communication protocol. We also 
 devote an entire chapter to the much-neglected topic of debugging 
 Mathematica
  
 programs.
  
    
 This introduction takes you on a tour through ever increasingly advanced 
 program-ming examples, beginning with the simplest imaginable and concluding with a 
 demon-stration of some of the more sophisticated programs developed in this book. In 
 the course of doing so, the author hopes to provide the reader with a better idea of what 
 power programming
  is all about, and how this book differs from existing ones.
  
 If your experience with 
 Mathematica
  is very limited, you may wish to review the basic 
 syntax of the language in the next chapter before continuing with this one.",NA
1.1 Programming in ,NA,NA
Mathematica,"Mathematica
  is an interactive system for doing mathematical calculations by computer. 
 Mathematica
  can also be considered a programming language. Because 
 Mathematica
  is 
 interactive, however, it’s often unclear what constitutes “programming” and what does 
 not. For example, is
  
 2 + 3
  
 5
  
 a program? Technically speaking, yes, but most users would not consider it so. How 
 about:
  
 a = 2; 
  
 b = 3; 
  
 a + b
  
 5
  
 There are three separate “statements” here; assignments are made to “variables” and 
 then those “variables” are used in further calculations. Nevertheless, most 
 Mathematica 
 users probably would be too modest to consider this to be a program either. Then how 
 about this:
  
 f  [x_] := x + 3 
  
 f[2 ]
  
 5
  
 Surely, this is a program: A function of a single argument is declared and then called.
  
 As the 
 Mathematica
  user gains expertise, her programs become more involved and, 
 hopefully, more sophisticated as well. For example, the naive 
 Mathematica
  
 program-mer might write the following code to compute the moving average of a list of 
 num-bers:
  
 The fcth moving average of a 
  
 list of numbers averages 
  
 every group of 
 k
 + 1 contig-
  
 uous numbers in the list.",NA
1.2 Power Programming Examples,"There is nothing magical about the standard packages; you don’t have to work at 
 Wol-fram Research or know any secret handshakes to write programs like, them. As 
 proof of this, we will now demonstrate some of the more sophisticated programs that 
 will be developed later in this book. If you’re the kind of person who hates “spoilers,” 
 you might want to skip this section. On the other hand, if you are the kind of person who 
 can’t resist sneaking a peek at the last page of a mystery novel, or if you simply want a 
 better idea of where we’re heading, you’ll want to read this first.
  
 1. From this point on, the author will take the liberty of dropping the prefix 
 “pseudo” 
  
 from the term “pseudorandom.”",NA
1.2.1 Optimal dot-product evaluation,"The number of scalar multiplications required to evaluate the dot product of a chain of 
 rectangular matrices can vary dramatically, depending on the order in which the 
 sub-products are evaluated. The built-in Dot function does not take this into account. 
 For example,
  
 Here are three matrices; we 
  
 wish to compute bl .b2.b3.
  
 The default multiplication 
  
 order takes this long ...
  
 but multiplying in the opti-
  
 mal order (for this chain) 
  
 takes only 1/20th the time!
  
 In Section 6.4, “Dynamic Programming,” we will write a function that calculates the 
 optimal matrix-chain multiplication order. Both the type of algorithm 
 (dynamic 
 pro-gramming)
  and the technique used to implement it (recursion with 
 result caching)
  
 are interesting in their own right. Later in that chapter (Section 6.5, “Overriding Built-in 
 Functions”) we will learn how to override the built-in Dot function so that it uses our 
 function whenever the arguments to Dot consist of three or more matrices. Finally, after 
 learning about packages in Section 8.2, “Package Mechanics,” we will be able to 
 encapsulate this code inside of a package: 
  
 ■
  
 N e e d s ["" O p tim a lD o t'""]
  
 Now  Dot uses the optimal
  
 order.
  
 2. And in anticipation of your next question: No, not all of the concepts 
 embodied in a program are necessarily contained in a single chapter. Some 
 programs draw on con-cepts learned in earlier chapters as well.",NA
1.2.2 A default thickness for Plot,"Another example of overriding a built-in function is the modification of the P lo t 
 func-tion to give curves a default thickness when none is specified explicitly (Section 
 6.5.3, “Application: A default thickness for Plot”). Here is an example:
  
 Needs[""DefaultThickness'""]
  
 The default thickness is 
  
 added
  to the style of the gray 
  
 curve, but the manifest 
  
 thickness directive for the 
  
 dashed curve is not overrid-
  
 den.
  
 Naturally, the program also respects a Thickness directive specified by a default P lo tS 
 ty le option, if one exists.",NA
1.2.3 Finding symbol dependencies,"In a very large program it can be difficult to anticipate the consequences of changing a 
 small part of the code on the rest of the program. Many conventional languages have 
 tools — such as call-graph analyzers and class browsers — that help the programmer 
 understand the “big picture” structure of a program. In Section 7.3.7, “Application: 
 Dependency analysis,” we will develop a function called dependson that provides a first 
 step in this direction for 
 Mathematica
  programs.",NA
1.2.4 A package that prevents shadowing,"Every 
 Mathematica
  user has, at one time or another, made a mistake like the following:
  
 You inadvertently refer to a 
  
 package symbol before 
  
 loading the package.
  
 You then load the package. 
  
 Strange error messages
  
 appear.",NA
1.2.5 A new data type: Prime factorizations ,"In Section 9.6, “Application: Defining a New Data Type,” we will create a package that 
 defines a new data type called a F acto rizatio n .
  
 Needs[""Factorization'""]
  
 ?Factorization 
  
 Factorization[{nl, pi}, (n2, p2), ...] represents the 
 number nlApl * n2Ap2 * ...
  
 Factorization 
 has a 
 spe-cial print format.
  
 The package overrides the 
 built-in 
 Factorlnteger 
  
 function so that it returns a 
 Factorization.
  
 Factorization[{3, 2}] 
  
 2
  
 Factorlnteger[9] 
  
  
 2
  
 The package overrides all of the arithmetic operators (and quite a few other 
 numeri­cal functions) so that they “do the right thing” when given one or more F ac to 
 riz a -tio n s as arguments. Here are some examples:",NA
1.2.6 Program performance,"Many programmers assail 
 Mathematica
  for its inefficiency relative to compiled 
 lan-guages such as C and Fortran. To be sure, there is a price to be paid for the power 
 and flexibility of 
 Mathematica
 ’s interpreted execution and symbolic manipulation 
 capabili-ties. What the critics do not realize, however, is that much of the perceived 
 inefficiency of 
 Mathematica
  is due to the use of ineffectual programming idioms from 
 other lan-guages; alternative techniques exist that are a better match for 
 Mathematica.
  
 As an example, consider the two moving average functions that were given as 
 exam-ples of programming style in Section 1.1. The first function, which has a 
 decidedly pro-cedural flavor to it (i.e., it smacks of C and Fortran), is terribly 
 inefficient:
  
 It takes over 30 seconds for 
  
 nums 
 =  
 Range 
 [ 1 . ,  1 0 0 0 . 1 . ] ;
  
 ]
  
 M ovingAveragel to com-
  
 T im in g  [ M o v in g A v e ra g e l 
  
 [nums , 1 0 0 ]; 
  
 pute 900 different 100-num - 
  
 ber averages! 
  
 {3 4 .6 3 3 3  S eco nd . 
  
 N u l l}
  
 There are many reasons for the inefficiency of MovingAveragel; in fact, that 
 func­tion is something of a “straw man” in that it represents just about the poorest 
 possible way of coding this algorithm in 
 Mathematica.
  The fact that this happens to 
 coincide with the way that is most likely to come first to the mind of the C or Fortran 
 program-mer is unfortunate; the author is convinced that this unhappy coincidence is the 
 source",NA
1.3 Where to Go Next,"The remaining chapters in Part 1 cover the basic syntax and use of 
 Mathematica.
  If you 
 have a nontrivial amount of experience using 
 Mathematica,
  you may find that you can 
 skip this material. Be forewarned, however, that there are important concepts presented 
 here that won’t be mentioned explicitly again. You should probably at least skim the 
 remainder of Part 1, and keep a lookout for the icons in the 
 margin 
 (described in the 
 Preface). This will provide a reality check for you, to see if your self-assessment of your 
 abilities is accurate. If you have used 
 Mathematica
  to do numerical mathematics but not 
 any 
 programming, 
 then you should still be sure to read Chapter 3, “Lists and Strings.”
  
 Part 2, “Programming Techniques,” introduces the three fundamental programming 
 paradigms supported by 
 Mathematica:
  procedural (Chapter 4), functional (Chapter 5), 
 and rule-based (Chapter 6). Needless to say, these chapters are a prerequisite for the 
 remainder of the book and should be read, in the order presented, by all but the most 
 expert 
 Mathematica
  programmers. Unless you really are an expert, you will find the rest 
 of the book to be 
 very heavy sledding
  if you skip any of these chapters! Chapter 7, 
 “Expression Evaluation,” presents the author’s version of a 
 Grand Unified Theory
  of 
 Mathematica
  — that is, an attempt to explain all of the diverse behaviors observed in 
 earlier chapters in terms of a minimal collection of concepts. This chapter can be 
 skipped on a first reading.
  
 Part 3, “Extending the System,” makes the quantum jump from writing small, 
 stand-alone functions to writing integrated collections of functions and grouping them 
 into packages. It also covers many techniques for making user-defined functions behave 
 as the built-in ones do.
  
 Part 4, “Programming for Performance,” and Part 5, “Miscellanea,” cover topics such 
 as improving the performance of 
 Mathematica
  code, the 
 MathLink
  interprocess 
 communication protocol, input/output, and debugging. Readers with a particular inter-est 
 in any of those topics may skip directly there after completing Chapter 6.",NA
2,NA,NA
Language Fundamentals,"Mathematica
  is a 
 term-rewriting system.
  Given an 
 expression
  — which we will define 
 in a precise manner below — as input, the fundamental operation performed by the 
 Mathematica
  kernel is to recognize terms within the expression that it knows how to 
 replace with other, hopefully simpler terms. For example, in the expression a*a + D 
 [aA3 , a ], 
 Mathematica
  rewrites a*a as a A2 (Ais the exponentiation operator); then it 
 rewrites D [aA3 , a] as 3 aA2 (D is the derivative operator); and it then recog-nizes that a 
 A2 + 3 a A2 can be rewritten as 4 aA2. It thus mimics the way that a human being does 
 mathematics, although it does so in a completely algorithmic manner.
  
 It turns out that expressions are the only type of object in 
 Mathematica
  — they are 
 used to represent both code and data. Furthermore, expressions have a recursive 
 struc-ture: Bigger expressions are composed of smaller expressions, which are in turn 
 con-structed of even smaller expressions, continuing in this manner until the 
 subexpressions can be broken down no further — the 
 atoms
  of the language. When 
 Mathematica
  per-forms term rewriting, it always replaces one expression by another 
 expression. This consistency of representation and operation is the key to the remarkable 
 power of the 
 Mathematica
  programming language.",NA
2.1 Expressions,NA,NA
2.1.1 Normal expressions,"Everything in 
 Mathematica
  is an 
 expression.
  There are fundamentally two types of 
 expressions: 
 normal
  expressions, which are of the form
  
 head[parti, part2, ...]
  
 where each of head, p a rti, part2, etc. is another expression; and 
 atoms,
  which can be 
 symbols, numbers, or character strings. (Atoms will be discussed in the next sec-",NA
2.1.2 Atoms,"An 
 atom
  is a 
 Mathematica
  expression that cannot be broken down into smaller 
 Mathe-matica
  expressions. There are three broad classes of atoms: 
 symbols, numbers,
  
 and 
 character strings.
  
 Symbols
  
 A 
 symbol
  is a sequence of letters, digits, and the character $ that does not begin with a 
 digit. Examples of symbols are a, abc, a2, a2b, $a, and a$. Though it may be tempt-ing 
 to think of symbols as being similar to 
 variables
  in programming languages such as C or 
 Fortran, you should try not to do so. Symbols are much more powerful because 
 symbols 
 do not need to have any value assigned to them in order to be used in computa-tions.
  
 That is, a symbol can stand for itself; it is not merely a proxy for data.
  
 Here is an example of a 
  
 symbolic computation. The 
 result is mathematically true for 
 arbitrary values.
  
 a +  b -  2a 
  
 _a +  ^
  
 All system-defined symbols begin with capital letters or the $ character (e.g., Plus, D, 
 FullForm, $Version), so it’s a good idea to begin user-defined symbols with low-ercase 
 letters to avoid confusion.
  
 Numbers
  
 There are four types of numbers in 
 Mathematica:
  integers, which consist of a 
 sequence of decimal digits 
 dddddd\
  real numbers, which are of the form 
 ddd.ddd; 
 rational numbers of the form 
 in te g e rl/in te g e r2 ;
  and complex numbers of the form 
 a + b
  I, where 
 a
  and 
 b
  can be any of the other three types.
  
 This is an integer. 
  
 1 2 3 4 5 6 7 8 9 0
  
 1 2 3 4 5 6 7 8 9 0
  
 This is a real number. 
  
 1 2 3 4 5 .6 7 8 9 0
  
 1 2 3 4 5 .6 7 8 9
  
 This is a rational number. 2 /3
  
 2
  
 3
  
 This is a complex number. 
  
 2 /3  +  4 .5 1
  
 3 
 + 
  
 4 . 5 1
  
 Any of the numeric types can have a virtually unlimited number of digits.
  
 This is 5 raised to the power 73.
  
 5 A73 
  
 1 0 5 8 7 9 1 1 8 4 0 6 7 8 7 5 4 2 3 8 3 5 4 0 3 1 2 5 8 4 9 5 5 2 4 5 2 5 6 4 2 3 9 5 0 1 
 9 5 3 1 2 5",NA
#,"5.O' 25 A 73 
  
 1 .0 5 8 7 9 1 1 8 4 0 6 7 8 7 5 4 2 3 8 3 5 4  1 0
  5 
 1
  
 As an optimization, approximate numbers that are input with no more digits than are 
 supported by the computer’s floating-point hardware are stored in native double-
 preci-sion floating-point format, and all arithmetic operations on such numbers are 
 performed in hardware. Numbers such as this are termed 
 machine-precision
  numbers. 
 The read­only system variable $M achinePrecision specifies the precision of “native” 
 floating-point numbers, which may vary on different processor architectures.
  
 This is the native floating- 
 point precision supported 
  
 $ M a c h in e P r e c is io n 
  
 ^
  
 by a PowerPC 601 proces-
  
 1. 
 Caveat:
 The result of P recision sometimes does not match the number of digits 
 that is displayed. The reason for this is that numerical precision actually is 
 tracked in terms of binary digits, and is converted to the nearest number of 
 decimal digits by Precision.",NA
H,NA,NA
r,"Precision[%]
  
 16
  
 It is important to note that while the precision of a machine number is always $M 
 achinePrecision, the converse is not necessarily true: If the result of an arbitrary- 
 precision calculation happens to have $M achinePrecision or fewer significant dig-its, it 
 is still stored internally as an arbitrary-precision number. Use MachineNumberQ to be 
 certain.
  
 Also note that an input containing a decimal point is 
 always
  considered to be an 
 approximate number, even when you “know” it isn’t. For 
 Mathematica
  to assume 
 oth-erwise would be incorrect.
  
 This result is only 
 approxi-
 mately
  zero (note the deci- mal 
 point).
  
 3 / 4  -  0 .7 5 
  
 q
  
 If what was really meant in this case was “exactly three-fourths,” then that is what 
 should have been entered.",NA
2.2 Evaluation of Expressions,"The basic evaluation process is very simple: The kernel continues to rewrite terms until 
 there is nothing left that it knows how to rewrite in another form. Since term rewriting 
 replaces one expression by another, whatever is left after this process terminates must be 
 a valid expression, which implies that the set of all expressions is 
 closed
  under 
 eval-uation. This allows any expression to be nested inside of any other (although the 
 result of doing so may not make any sense!). By analogy with function call in other 
 lan-guages, we often will call the result of evaluating an expression the 
 return value
  of 
 the expression.
  
 You can obtain a post mortem description of the evaluation of any expression by 
 wrapping the expression inside the head Trace. The results may be slightly different, 
 depending on the version of 
 Mathematica
  that is being used.
  
 Trace[Sin [Log[2.5, 7]]]
  
 I I L ° s [ 2 ' 5 ’ 71 ■ S 
  
 l O 
  
 I -
  
 {(Log[2.5], 0.916291], 
 —
  
 \ 6 2 g i .
  1-09136},
  
 (Log[7.], 1.94591}, 1.09136 1.94591, 2.12368},
  
 Sin[2.12368], 0.851013}
  
 Trace[Sin[Log [2.5, 7]]]
  
 {{Log [2.5, 7], ^ [ 2 5 ]  ■ {Log [7 . ] , 1.94591},
  
  
 1 94591 
  
 {Log [2.5], 0.916291}, ----, 
 2.12368},
  
 0.916291
  
 Sin[2.12368] , 0.851013}
  
 The curly braces indicate the 
 depth
  of the subexpressions being evaluated. The steps 
 involved in this evaluation in version 3.0 are:
  
 1. Log 
 [2.5, 7] 
 is rewritten as Log 
 [7
 . ] /Log 
 [2.5],
  
 2. Log [7. ] is evaluated numerically, yielding 1.94591....
  
 3. Log [2.5] is evaluated numerically, yielding 0.916291....
  
 4. The quotient of the two previous results is evaluated numerically.
  
 5. The Sin of the quotient is evaluated numerically.
  
 6. The result is an atom (a real number), which cannot be rewritten, hence the process 
 terminates.",NA
/ \ ,".5 7
  
 ^",NA
* ,"Sin
  
    
 1 
  
  
 Times",NA
/ \ ,"Log 
   
 Power
  
 7 Log -1",NA
1 ,NA,NA
/ \ ,NA,NA
1 ,"2.5
  
 ^ 
  
 Sin 
  
 1 1
  
 Times",NA
/ \ ,1.95 Power,NA
/ \,"Log -1
  
 /
  
 .",NA
* ,"Sin 
  
      
 1 
  
  
 Times",NA
/ \ ,1.95 Power,NA
/ \ ,".916 -1
  
 2.5 
  
 '",NA
1 ,"Times 
 Sin",NA
1,NA,NA
/ \ ,"1.95 1.09
  
 .851
  
 Sin
  
 2.12
  
 Figure 2-1 Tree representation of evaluation of the expression Sin [Log [2.5, 7]. The 
 process is streamlined somewhat in version 3.0 (as indicated by the dashed arrow).
  
 Mathematica
  has a built-in function called TreeForm that attempts to print an 
 expression in the form of a tree, subject to the limitations of ASCII output. Here is an 
 example:
  
 TreeForm[x + Cos[y]*Log[z]]
  
 Plus[x, I 
  
 ] 
  
 ]
  
 Times[| 
  
 , | 
  
 Cos [y] 
  
 Log 
 [z]
  
 The output of TreeForm is not very appealing to look at, especially when the expres-sion 
 being formatted is so large that the output wraps across multiple lines. It is usually better 
 just to examine the FullForm carefully.
  
 Incidentally, look at what happens if we try to print the TreeForm of the example in 
 Figure 2-1:",NA
2.3 Special Input Forms,"Now that we understand the basic structure of expressions and how they are evaluated, 
 we turn our attention to the rich syntax that is available for entering expressions. Much 
 of the syntax is evocative of other programming languages; the C language probably had 
 the strongest influence on the syntax of 
 Mathematica.
  However, identical syntax does 
 not necessarily imply identical 
 semantics,
  and we will take pains to point out per-tinent 
 differences as we go along.
  
 We will not attempt to describe every special input form here, only the most common 
 and elementary ones (see [Wolfram 91] §A.2.3 or [Wolfram 96] §A.2.7 for an 
 exhaus-tive list). We will encounter additional special input forms throughout the 
 remainder of the book.",NA
2.3.1 Arithmetic operators,"The arithmetic operators are + (addition), - (subtraction), * (multiplication), /  (divi-sion), 
 and A (exponentiation). Addition and subtraction have a lower precedence than 
 multiplication and division, which in turn have a lower precedence than exponentiation.
  
 This is 3 + 
 8
  . 
  
 3 + 2 * 4
  
 11
  
 This is 3 * 16. 
  
 3 * 2 A 4
  
 48
  
 W hen in doubt, you can 
  
 substitute symbolic argu-
  
 ments and look at the 
 Full -
 Form 
 of the expression.
  
 FullForm[Hold[a 
 * b A c ] ] 
 Hold[Times[a, Power[b, c] ] 
 ]",NA
2.3.2 Relational and boolean operators,"Mathematical
  relational and boolean operators are the same as C’s, with one excep­tion: 
 there is no exclusive-or operator (but there is an Xor function). Here are some examples.",NA
IT ,"to numbers, in which case it’s possible that the relational operator will not evaluate.2 
  
 Second, and more important, the arguments to a relational operator need not evaluate 
  
 This may not be what you 
  
 a =
  
  b
  
 had in mind. 
  
 a == b 
 ,
  
 When comparing two symbolic expressions, you may want to test them for “sameness.” 
 This is accomplished by using the SameQ function, abbreviated === (triple equal sign).
  
 Since a and b are not mani- 
 festly identical, SameQ 
  
 returns F als e . 
  
 Mathematica
  
 knows 
 about 
 properties 
 such 
 as 
 the 
 asso-ciativity of addition.
  
 a
  
 --------b
  
 „
  
 i a i s e
  
 a 
  
 +  b = =  b +  a
  
 True
  
 The logical negation of SameQ is called UnsameQ, abbreviated =! =. Remember, 
 SameQ and UnsameQ always evaluate to either True or False; Equal and Unequal 
 may 
 not.",NA
2.3.3 Reusing results,"The % character stands for the result of the most recent evaluation. For example:
  
 Here is an evaluation. 
  
 Sin[Pi/3]
  
 Sqrt [3]
  
 2
  
 % here refers to S q rt [3] /2 , 
 the result of the last 
 evalua-tion.
  
 ArcSin[%] 
  
 Pi 
  
 3
  
 (Incidentally, this example shows the benefit of working with exact quantities: Had 
 either of the last two evaluations been done numerically, the eventual result would have 
 been only an 
 approximation to
  Jl/3.)
  
 More generally, a sequence of 
 n
  percent signs refers to the nth previous result.
  
 ArcCos[%%]
  
 Pi 
  
 6
  
 You can also use %n or Out [n] to refer to output number 
 n.
  However, this is a 
 danger-ous tactic, because if you save your notebook and reopen it during another 
 Mathema-tica
  session, chances are extremely remote that these references will be 
 correct. A much better strategy is to assign the results of computations to symbols, 
 which we will see how to do in the next section.
  
 Bear in mind that % always refers to the most recent output 
 in the order of evaluation. 
 Because the notebook interface allows you to move the insertion point around and to 
 cut/copy/paste cells, the most recent output is not necessarily the same output cell that 
 textually precedes the current input cell! Fortunately, the front end provides commands 
 that copy the contents of the preceding input or output cell into the current input cell. 
  
 These commands can be found in the 
 Prepare Input 
 submenu of the 
 Action 
 menu.",NA
2.3.4 Assignment statements,"The operators = (which is called Set3) and : = (which is called SetDelayed) perform a 
 role in 
 Mathematica
  that is similar to that of 
 assignment
  in other languages. Either of the 
 expressions J As = 
 rhs
  or 
 lh s
   := 
 rhs
  creates a rewrite rule for 
 Ihs.
  The differ-ence 
 between Set and SetDelayed is their treatment of 
 rhs\
  this difference is subtle and will be 
 illustrated by an example.
  
 3. Set is a verb, not a noun. The Set operation has nothing to do with 
 sets
  in the 
 mathematical sense. Furthermore, mathematicians have to get used to the idea 
 that = does not mean 
 equivalent, =
   is used for that (see Section 2.3.2).",NA
2.3.5 Function call,"As noted earlier, the syntax head [p a rts . . .  ] for constructing expressions can be 
 thought of as a function call, and the resemblance to function call in other languages is 
 no coincidence. Note that you must use square brackets, not parentheses, to indicate a 
 function call. In fact, using parentheses is such a common mistake that the parser will 
 even warn you about it:
  
 This expression is equivalent 
  
 S q r t  (3 )
  
 to S q rt * 3, which is mean- g y n t a x . .  b k t w m .
  
 ing ess. 
  
 Warning: ""Sqrt(3)"" should probably be ""Sqrt [3]"".
  
 3 Sqrt
  
 Believe it or not, there actually are three special input forms for function call — two for 
 functions of a single argument and one for functions of two arguments. The first two
  
 4. A description of which would be completely incomprehensible at this point. 
 Wait 
  
 until Section 6.5.2, “Upvalues.”
  
 5. The historic reason for these operators’ presence in C is that they 
 corresponded to 
   
 assembly-language addressing modes on the DEC 
 PDP-8. C programmers love 
  
 them because they allow one to create the 
 infamous one-line string copy function. 
  
 The only explanation for their appearance in 
 Mathematica
  is that they are 
 the pro-gramming language equivalent of an inherited defect.",NA
2.3.6 Function definition,"Mathematica
  allows you to define your own functions.
  
 This defines z as a function 
  
 z [ x _ ,  y _ ] 
  
 : =  x  +  y
  
 of two parameters, x  and y.
  
 The expression on the left-hand side of the assignment is called the 
 declaration
  of the 
 function, and the expression on the right-hand side is called the 
 body
  of the function. 
 Whenever you use the function in an expression, the function is said to be 
 called,
  and 
 the value computed by the function (the 
 return value)
  is substituted for the function call. 
 When this function is called, for example, by evaluating
  
 z [Sqrt [3] , 2 Pi]
  
 Sqrt[3] + 2 Pi
  
 the values Sqrt 
 [3] 
 and 2 P i are substituted for x and y, respectively, everywhere that x 
 and y occur in the body of the function. In computer science lingo, x and y are called 
 formal parameters,
  and the values Sqrt 
 [3] 
 and 2 Pi are called 
 actual parameters
  or 
 arguments.
  
 Note that the values of the formal parameters x and y do not depend on the values of the 
 global symbols x and y:
  
 x  :=  
 1
  
 y := Log[2] 
  
 z [Sqrt [3] , 2 
 Pi]
  
 Sqrt[3] + 2 Pi
  
 or vice versa:
  
 x  +  y
  
 1 + Log[2]",NA
2.3.7 Compound expressions,"Multiple expressions can be placed anywhere a single expression could go by separat-ing 
 them with semicolons.
  
 a = 1; b = 2; a + b
  
 3
  
 Note that the output of every expression that is followed by a semicolon is suppressed. 
 This is quite handy for suppressing the output of trivial operations, or of expressions 
 that evaluate to enormous messes.",NA
2.3.8 Lists,"Lists
  are the basic data structure in 
 Mathematica.
  A list is used to group expressions in a 
 particular order. Curly braces delimit a list:
  
 This is a list of three expres- 
 sions.
  
 The internal form of a list is 
 quite straightforward.
  
 {
  1
  , x ,  i  +  j } 
  
 (
  1
  . x , i  +  j ]
  
 F u llF o r m  [%] 
  
 List[l, x, Plus[i, j]]
  
 The head L ist doesn’t cause any evaluation to take place; it simply has appealing 
 spe-cial input and output forms.
  
  
 Many of the built-in functions require that certain parameters be grouped into lists. 
 For example, in the expression Plot3D [Sin [x 
 y ]  
 , {x, 0, Pi}, 
  
 { y ,  
 0, Pi}], the 
 lists are used to group each independent variable with its desired plot range.",NA
IT ,"programmers take note!) 
  
  
 and Fortran. However, note that lists always use 1-based indexing, as in Fortran. (C 
  
 Since lists are expressions, they can be nested arbitrarily. By convention, rectangular 
  
 nested lists are used to represent matrices, with each row of the matrix stored as a sub-
  
 list.
  
 s is a nested list that repre- 
  
 s =  { { a ,  b } , 
  
 { c ,  d} , ( e ,  f } } ;
  
 sents a 3 x  2 matrix.
  
 The elements of s also are lists; 
 this represents a row of 
  
 s [ [1 ] ] 
  
 j a
  
 the matrix.
  
 Thesublistscanofcoursebe 
 indexed as well; this repre- 
 sents an element of the
  
 %[ [2 ] ] 
  
 ^
  
 matrix.
  
 All of the above can be 
 accomplished in a single 
  
 s [ [ l ,  2 ] ] 
  
 ^
  
 step.
  
 Lists are pervasive in 
 Mathematica;
  in fact, there are so many built-in functions for 
  
 operating on them that we will devote nearly all of Chapter 3 and a good part of 
  
 Chapter 5 to them.
  
 Exercise
  
 1. What subscript is needed to extract the element c from the following list? How 
  
 about e?
  
 { a . 
  
 { b , 
  
 { c , d } .  e } .  f }",NA
2.3.9 Rules,"The special input form a 
 - > b
  is called a 
 rule.
  By itself, a rule is little more than a con-
  
 tainer for a pair of expressions (with a special input/output form), but there are several 
  
 functions that expect rules as arguments. The most common such function is called 
  
 ReplaceAll. R eplaceA ll[expr, a -> 
 b]
  replaces every occurrence of a in 
 expr
  
 by 
 b:",NA
2.3.10 Control flow ,"Although 
 Mathematica
  contains functions for conditional execution such as I f  and 
 Switch, and loop-control functions such as Do, While, and For, there is no special syntax 
 for any of these. The reason for this is that they aren’t used all that frequently. 
  
 We’ll discuss these functions in Chapter 4, “Procedural Programming.”",NA
2.3.11 Syntax traps for the unwary,"f l y
  
 There are a couple of features of the 
 Mathematica
  parser that are intended to make input 
 more natural for users, but can result in unintended consequences if you are not aware 
 of them.
  
 First of all, a space may be used instead of an asterisk to signify multiplication. This 
 looks much like standard mathematical notation when symbols are being multiplied 
 together:
  
 a b 
  
  
  
 a b 
  
 In very special cases, even the space is unnecessary. The author knows of only two such 
 cases. The first is when a number is followed by a nonnumeric character:
  
 Since symbol names cannot 
 begin with a digit, this is 
  
 interpreted as multiplica-
  
 2a 
  
 ^
  a
  
 tion.
  
 The second is when two symbols are separated by a delimiter such as a parenthesis or a 
 list brace:7
  
 The parenthesis between the 
  
 a (b  + 
  
 c )
  
 symbols a and b implies
  
 multiplication.
  
 7. This works for either left or right parentheses and list 
 braces. It also works for sin-gle and double square brackets, 
 but only on the right, of course, since a [b] is a function 
 call and a [ [b] ] is a subscripting operation.",NA
2.3.12 Symbol information,"Information 
 about any symbol can be obtained with the 
  
 syntax ?
 name.
  
 Here's some information ? Factorlnteger
  
 about the Factorlnteger Factorlnteger [n] gives a list of the prime factors of
  
 function. integer n, together with their exponents.
  
 You can get even more ? ?FactorInteger
  
 detail using 
 tlname. 
 Factorlnteger [n] gives a list of the prime factors of
  
 the integer n, together with their exponents.
  
 Attributes[Factorlnteger] = {Listable, Protected}
  
 Options[Factorlnteger] =
  
 {FactorComplete -> True, Gaussianlntegers -> False}
  
 You can get information ?Gaussianlntegers
  
 about any symbol 
  
 notjust Gaussianlntegers is an option 
  
 for Factorlnteger,
  
 function names. 
  
 PrimeQ, Factor and related functions which
  
 specifies whether factorization should be done over
  
 Gaussian integers.
  
 The asterisk can be used to do wildcard searches for 
  
 symbol names.
  
 Here are the names of all ?‘Solve*
  
 functions that contain the DSolve 
  
 NDSolve 
  
 SolveAlways
  
 word Solve. (Not all of DSolveConstants NSolve 
  
 SolveDelayed
  
 these appear in version 2.2.) LinearSolve 
  
 Solve 
  
 $DSolveIntegrals
  
 MainSolve
  
 Note that in version 3.0, 
 Iname
  and 
 11 name
  are expressions that return N ull (the 
  
 information that appears on the screen is printed, rather than being returned as a value).",NA
3,NA,NA
Lists and Strings,"Lists are the basic data structure used in 
 Mathematica
  programs. In addition to 
 extracting parts of a list, you can Append, Prepend, In s e rt, or D elete parts to/from a 
 list; Take or Drop an arbitrary number of parts from the front, back, or middle; R otate it 
 left or right; Sort it; Reverse it; “wrap a function around” every part in it (Map); Count 
 parts that match a specification; and more. Operations on multiple lists include Join 
 (concatenation), Union, In te rse c tio n , and Complement. In this chap-ter we will cover 
 the basic repertoire of list operations; even more sophisticated opera-tions on lists will be 
 discussed in Chapter 5, “Functional Programming.”
  
 We conclude this chapter with a brief discussion of string operations, because they are in 
 many ways analogous to list operations.",NA
3.1 List Basics,NA,NA
3.1.1 List input and output,"A list is composed of a sequence of expressions, separated by commas and enclosed in 
 curly braces.
  
 Here is a list of three expres- 
  
 listl 
 =  { a , N [ P i]  , 
 Sqrt[3]}
  
 SIOnS' 
  
 {a, 3.14159, Sqrt [3]}
  
 Since each part of a list is an expression, as is an entire list, lists can contain other lists.
  
 Here is a nested list whose 
  
 l i s t
  2
  =  { l i s t l , 
  
 { d . 
  
 { e . 
  
 {d. 
  
 f } } }
  
 parts are also lists. The sec- 
 ond part of the second sub- 
  
 , , 
  
 { { a ’ 
  
 3 - 1 4 1 5 9 > 
  
 0 
  
 S q r t  [ 3 ] } . 
  
 { e.  f } } ]
  
 list is also a list.",NA
3.1.2 Extracting parts of lists,"To extract a part from a list, use 
 double
  square brackets. The parts are numbered 
 start-ing with 1. The time required to extract any part is independent of the part being 
 accessed.
  
 listl [ [3]]
  
 Sqrt [3]
  
 You can extract multiple parts at a time by using a list of indices. The result is a list of 
 items, in an order corresponding to the indices.
  
 listl[
 [{3, 2}]]
  
 {Sqrt[3], 3.14159)
  
  
 Extracting a part from a nested list can be accomplished by using a comma-separated 
 sequence of indices inside the double square brackets.",NA
3.2 Generating Lists,"Entering a list directly is fine for small lists, but for large lists some kind of automation 
 is a necessity. There are three general-purpose automated list generators:1 Range, 
 Array, and Table. In addition, there are a few special-purpose generators for matrices.",NA
3.2.1 Range,"Range can be used to generate a list of numbers in an arithmetic progression.
  
 In its simplest form, 
  
 Range [n] 
 generates a 
  
 sequence of the positive 
 integers that are less than
  
 Range[5] 
  
 (1, 2, 3, 4, 5)
  
 or equal to 
 n.
  
 If you pass two arguments to
  
 Range[4, 12]
  
 1 2
  )
  
 Range, 
 they are taken as the 
 starti ng and end i ng poi nts of
  
 {4, 5, 
 6
  . 7, 
 8
  , 9. 10, 
 11,
  
 the sequence.
  
 A third argument specifies 
 the step size.
  
 Note that the range 
 specifi-cations do not have to 
 be integers.
  
 Range[4,
  
 12",NA
", ",2,NA
],"(4, 
 6
  , £
  
 , 
 1 0
  , 
 1 2
  )
  
 Range[2/3, 5.5, 9/11]
  
 ,2 49 76 
  
 103 
  
 130 
  
 157
  
 3' 33’ 33’ 33 ’ 33 ’ 33",NA
3.2.2 Array,"Array [f, n] or Array 
 [f, [n
  } ] , where f  is a function of a single variable, creates the list 
 {f[l] , . . . .  
 f[ n \} .
  
 1. In addition to the operations discussed in this section, you can also read data 
 from a file directly into a list using the 
 ReadList 
 function (see Section 12.4, 
 “High-Level Input”).",NA
3.2.3 Table,"Table is the most general of the iterators. It takes a 
 minimnm 
 of two arguments: an 
 expression to be iterated and one or more range specifications of the form 
 W ar, s ta r t, 
 end, step}.
  The result is a list of the expression iterated over the given range(s).
  
 Here's another way to gen- 
 erate the table of primes. 
  
 A range specification with only 
 three parts is inter- preted as 
 I 
 v a r ,  s t a r t , 
 end,
 1
  }.
  
 Table [Prime [i] , {i, 
 1 , 1 0 , 1 }]
  
 {2> 
  
 3> 5 _ n > 
  
 1 3 _ 
  
 1?> 
  
 ig >  2 3 _ 2g}
  
 T a b le  [ x A2 -  4 x , 
  
 { x ,  3 ,  7 } ]
  
 j 
 _ 3
  
 q 
  
 5
  
 1 2
  
 2 ^,
  
 .
   
 . .
  
 .
  
 Note that the first argument to Table is an expression that depends on an explicit 
 itera-tion variable, which is specified in the second argument. Contrast this with Array, 
 in which the iteration variable is implicit.
  
 If there is more than one iterator, the resulting list is multidimensional. The last iter-ator 
 varies most quickly.
  
 A range specification with only 
 two parts is interpreted as 
 Ivar,
 1
  , 
 end,
 1
  }. 
  
 T a b l e [ a [ i ,  j ] 
  
 , { i ,  2 } , 
  
  { j  , 2 , 4 } ]
  
 { { a [ 
  
 2] 
  
 a [ 
  
 3] 
  
 a [ 
  
 4] ,
  
 , r , P 
  
 , 
  
 r 
  
 , ,
  
 {a [2 , 2] . a [2 , 3] , a[2, 4] )}",NA
3.2.4 Generating matrices,"In addition to the general-purpose list-generating commands just presented, there are 
 two special generators just for matrices:
  
 IdentityMatrix
 [4 ] 
  
 {{1, 0, 0, 0), {0, 1, 0, 0), {0, 0, 1, 0), {0, 0, 0, 1}}
  
 DiagonalMatrix[{a, b, c, d}]
  
 { { a , 
  
 0
  , 
 0
  , 
 0), 
 (
  0
  , b , 
  
 0
  , 
 0}, {0, 0, 
 c ,  
 0), {0, 0, 0, 
 d}}
  
 Exercises
  
 1. Generate a list of (a) the first 10 integers, (b) all integers between 30 and 40, (c) all 
  
 of the odd integers between 30 and 40.
  
 2. Generate a list of values of the B esselJ [0, x] function at the points 1, 1.5, 2, 
  
 2.5, . 
 . . .  
 10
 .
  
 3. Create a 2-D list of values Binomial [i + j , i] for integer values of i  and j run-
  
 ning 
 from 0 (not 1) up to some integer. Display this list using TableForm.
  
 4. Modify the answer to the previous exercise so that the table takes on an upper-
 trian-gular form. 
 (Hint:
  You can make the upper limit for j depend on i.) Do you see 
 a well-known pattern?",NA
3.3 Listable Functions,"Virtually all of the built-in numerical functions (and a few symbolic ones as well) can 
 take lists as arguments, which they operate upon element by element. This feature is 
 called 
 listability.
  For example, the following expression takes the square root of each 
 element of the list.
  
 Sqrt[{a, b, c}]
  
 { S q r t [ a ] , 
  
 S q r t [ b ] , 
  
 S q r t [ c ] )
  
 Contrast the above with Sqrt [a , b , c ], which would generate an error message.
  
  
 If the function takes multiple arguments, then zero or more of the arguments can be 
 lists, so long as all of the list arguments are the same length.
  
 Here the first argument to { a , b , c } A d
  
 Power is a list. 
  
 d 
  
 d 
  
 d
  
 {a  , b , c }",NA
Dr ,"C learA ll[f] to do both.
  
 Caveat:
  Clear [f] removes definitions for f, but does not remove attributes. Use 
  
 All of the built-in numerical functions (e.g., Plus, Sin, Gamma), predicates (e.g., 
 IntegerQ, PrimeQ), and some symbolic functions (e.g., Together, ToExpression) are 
 listable. An inventory of 
 Mathematica’s
  listable functions can be found in Table 3-1 on 
 page 67. See Exercise 5.2.1.3 to learn how that table was generated.
  
 Exercises
  
 1. Generate a list of the square roots of all the odd integers between 1 and 20 without 
 using Table or Array.
  
 2. Given a list of coefficients of a polynomial (from low order to high order, including 
 explicit zeros), generate that polynomial using Table and Dot.",NA
3.4 Getting Information about Lists,"There are several functions for querying the structure or contents of a list.
  
 You can find the length of 
 a list. 
  
 Length[{a, b, c}] 3
  
 {d, e, f}}]
  
 You can obtain the 
 dimen- 
 sions of a matrix. 
 The length
  
 Dimensions [{ Ca, b, c}, 
  
 { 2 , 
  
 3}
  
 of this list is 
 2
  .",NA
3.5 Manipulating Lists,"All of the operations discussed in this section modify a 
 copy
  of the original list and 
 return the copy, leaving the original list unchanged. Only two operations (AppendTo 
 and PrependTo) overwrite the original list with the new list. This means you can 
 experiment almost endlessly on a data set without worrying about overwriting it; on the 
 other hand, it also means that the memory used by your 
 Mathematica
  session will grow 
 by leaps and bounds unless you take care to release the memory (by using Clear) used 
 by lists that you don’t need anymore.3",NA
3.5.1 Operations on a single list,"You can add expressions to a list at its beginning, end, or anywhere in between.
  
 3. In version 3.0, the global variable $HistoryLength can be used to limit the 
 num-ber of inputs and outputs that 
 Mathematica
  keeps track of in a session.",NA
3.5.2 Operations on multiple lists ,You can concatenate one list onto another.,NA
3.5.3 Mapping functions onto lists,"Sometimes you want to apply a function to each part of a list. If it is a built-in, listable 
  
 function, this is no problem; for example,
  
 OddQ[ { 1 ,  2 ,  3 } ]
  
 { T r u e , F a ls e , T ru e )
  
 However, if the function is user-defined, this simple approach won’t work. For exam­
  
 ple, suppose you would like to test each expression in a list to see if it is greater than 2.
  
 First define an appropriate 
 predicate.
  
 Passing the entire list to the 
 predicate doesn't work.
  
 C l e a r A l l [ g r e a t e r 2 ]
  
 g r e a t e r
  2
  [x _ ] 
  
 :=  x  > 
 2
  
 g r e a t e r 2 [ { l ,  2 ,  3 } ]
  
 { 1 , 
  
 2 ,  3} > 2
  
 One way to create the desired result would be to give greater2 the L ista b le 
  
 attribute, as discussed in Section 3.3. This isn’t always desirable, however, as we’ll see 
  
 below. Another strategy would be to use Table to construct each individual result:
  
 T a b l e [ { 1 ,  2 , 
 3}[[i]] 
 > 2 . 
  
 { i ,  
 3}]
  
 { F a ls e , F a ls e , T ru e )",NA
3.5.4 Modifying lists in place,"All of the operations we have seen so far (with the exception of AppendTo and 
 PrependTo) are 
 side effect-free.
  That is, they do not change the original list; instead, 
 they make a copy of it and modify the copy, which is returned. When you are working 
 with a very large list, however, it may save a lot of memory to modify the original list. 
  
 Indexing can be used on the left side of an assignment operator for this purpose.
  
 Note that the assignment 
 operator returns the value 
 being assigned, not the new 
 list.
  
 I i s t 5  =  { 1 , 2 , S q r t [ 3 ] } l i s t 
 5 [ [ 2 ] ]  =  L o g [7]
  
 { 1 , 
  
 2,  S q r t [ 3 ] }
  
 Log [7]
  
 The original list has been 
  
 l i s t 5
  
 modified. 
  
 { 1 , L o g [ 7 ] ,  S q r t [ 3 ] }",NA
Hr ,"ties. We’ll deal with this problem in Section 10.2, “Procedural Perils.”
  
  
  
 Working with large lists in this way can lead to some unexpected performance penal-",NA
3.6 Character Strings,"Although character strings are not lists, we discuss them in this chapter because most of 
 the operations on them are so similar to the operations defined for lists. Furthermore, it 
 is a simple matter to convert a character string into a list of individual characters (and 
 back again), so that any list operation can be applied to them.",NA
3.6.1 Getting information about strings,"StringLength and S trin g P o sitio n  are analogous to the Length and P o sitio n 
 operations on lists.
  
 Here's a string consisting of the 
 first 
 1 0
   letters of the 
  
 alphabet.
  
 S trin g L e n g th  is analogous 
 to Length.
  
 You can find all the posi-tions 
 of a given substring within a 
 string. The return value is a 
 list of { s t a r t , end} pairs.
  
 s =  "" a b c d e f g h ij"" 
  
 a b c d e fg h ij
  
 S t r in g L e n g th [ s ] 
  
 10
  
 S t r i n g P o s i t i o n [ s , 
  
 "" c d "" ]
  
 { { 3 ,  4 } ] 
  
 S t r i n g P o s i t i o n [ "" h e l l o  t h e r e "" , "" h e "" ]
  
 { ( 1 .  2 ) , 
  
 {
  8
  , 9 } }",NA
3.6.2 Operations on strings,"As with lists, you can take or 
 drop a given number of 
  
 characters from the begin-ning, 
 middle, or end of a string.
  
 StringTake[s, 3] 
  
 abc
  
 StringTake[s,-3]
  
 h i j
  
 StringTake[s, {4. 7}] 
  
 defg
  
 StringDrop[s, {4, 7}] 
  
 abchij
  
 You can also insert a string at 
 an arbitrary position 
  
 within another string.
  
 As with lists, negative 
 indices count backward 
 from the end.
  
 Stringlnsert[s, ""012345"", 3] 
 abO12345cdefghij
  
 Stringlnsert[s, ""012345"", -2] 
 abcdefghiO12345j",NA
3.6.3 Converting strings to/from other forms ,"You can break a string down into a list of characters. 
  
 Characters[s] 
  
 (a, b, c, d. e, f , g , h, i ,  j}
  
 Note that each character 
 is actually a string of 
 length 1.
  
 InputForm [%]
  
 ""d"" 
  
 11 e"" 
  
 11 g” 
  
 ""h” 
  
 ""i"" 
  
 Mj M}
  
 [11 a” 
  
 ""b"" 
  
 Hc H 
  
 Thus, StringJoin reverses 
 this process. 
  
 StringJoin [%] 
 abcdefghij
  
 Alternatively, you can convert a string to a list of ASCII codes using ToCharacter- 
 Code, and you can go in the reverse direction using FromCharacterCode.
  
  
 ToCharacterCode[s] 
  
  
    
 (97, 98, 99, 100, 101, 102, 103, 104, 105, 106} 
  
 FromCharacterCode[%] 
  
  
   
 abcdefghij 
  
 You can convert 
 Mathematica
  expressions to strings, and vice versa.
  
  
 ToString[a + b + c] 
  
  
  
 a + b + c 
  
 Is that really a string? 
  
 InputForm [%] 
  
  
    
 ""a + b + c"" 
  
 This one is a little unusual. 
  
 ToString [a/b] 
  
  
   
 a 
  
  
 b
  
 \n represents a 
 newline 
  
 character. This is 
 unsuitable for a linear 
 representation.
  
 You can specify an output 
 format when converting 
 to a
  
 string.
  
 InputForm 
 [%] 
  
 ""a\n—\nb""
  
 ToString [InputForm[a/b] ]
  
 For more information about output formats, see Section 12.3.2, “Writing to a stream,” or 
 refer to [Wolfram 91] §2.7 or [Wolfram 96] §2.8.
  
 Convert strings to 
 Mathematica
  expressions using ToExpression.
  
 ToExpression[""a + b""] 
  
 a + b",NA
3.7 Appendix: Listable Functions,"Table 3-1 shows all of the functions with the L ista b le  attribute in version 3.0 of 
 Mathematica.
  Functions marked with an asterisk (*) do not exist in earlier versions; 
 functions marked with a dagger (f) exist but do not have the L ista b le  attribute in 
 ear-lier versions. Functions with extremely long names appear at the end of the table.
  
 Table 3-1 
 Listable functions in version 3.0.
  
 Abs
  
 AiryAi
  
 AiryAiPrime
  
 AiryBi
  
 AiryBiPrime
  
 Apart^
  
 ArcCos
  
 ArcCosh
  
 ArcCoth
  
 ArcCsc
  
 ArcCsch
  
 ArcCot
  
 ArcSec
  
 ArcSech
  
 ArcSin
  
 ArcSinh
  
 ArcTan
  
 ArcTanh
  
 Arg
  
 Attributes
  
 Bessell
  
 BesselJ
  
 BesselK
  
 BesselY
  
 Beta
  
 BetaRegularized
  
 Binomial
  
 Cancel",NA
Part 2 ,NA,NA
Programming ,NA,NA
Techniques,NA,NA
4,NA,NA
Procedural Programming,"In this chapter we present those features of 
 Mathematica
  that correspond most closely 
 to the features of 
 procedural
  programming languages such as C, C++, Fortran, aiid 
 Pascal. Procedural programming is a style of programming that is characterized by lots 
 of small steps and pervasive use of side effects (e.g., assignments to variables) to convey 
 information between those steps. It also relies on iteration (e.g., loops) to pro-cess 
 collections of data. Generally speaking, if you see assignment statements and loops, the 
 style is procedural.
  
 While most 
 Mathematica cognoscenti
  discourage the use of procedural 
 program-ming, it can be a useful stepping-stone into 
 Mathematica
  programming for 
 program-mers whose experience lies mainly with the languages mentioned above. Bear 
 in mind that most of the techniques illustrated in this chapter are but “tips of icebergs”; 
 that is, they are simple manifestations of very powerful concepts that we will explore in 
 greater detail in the chapters to come.",NA
4.1 Functions,"A 
 Mathematica Junction
  is a programming construct that allows you to reuse pieces of 
 code over and over in a convenient manner. Hundreds of functions, such as I n t e -grate, 
 Table, and P lot, are built into 
 Mathematica.
  But 
 Mathematica
  also makes it easy for 
 you to define your own functions, which can be just as sophisticated as the functions 
 provided by the system.",NA
4.1.1 Function definition,"Here is the definition of a function that computes the area of a circle of radius r: 
  
 area[] := Pi rA2",NA
4.1.2 Parameters,"The expression returned by the area function involves a symbol called r. If this sym-bol 
 has a value assigned to it, that value will be substituted into the body of the function 
 when the function is called.
  
 r  =  
 2
  ;
  
 a r e a  []
  
 4 P i
  
 This is a cumbersome and error-prone way of getting values into a function; a better 
 way is to use the mechanism of 
 parameters.
  
 Here is a redefinition
 1
  of a re a  
 that uses a parameter instead 
 of a global symbol.
  
 C le a r  [a r e a ]
  
 a r e a [ r _ ] 
  
 :=  P i r A2
  
 The symbol r is the parameter The underscore (_) is called Blank, which is intended to 
 convey the idea “fill in the blank.” When you call this function, for example, by 
 evalu-ating
  
 1. For reasons that w ill become much clearer (no pun intended) later, it’s good practice
  
 to always C le a r  a function before m aking changes to its definition.",NA
I,3,NA
r ,"function call that “does nothing.”
  
 notoriously hard to track down, since you don’t 
 get any kind of warning message, just a 
  
 happens! 
 A very common source of errors is to forget the 
 blanks!
  These errors can be 
  
 Here’s a slightly more interesting example: a function with three parameters.
  
 This function returns one root 
 of the quadratic equa-
  
 q u a d [a _ , b _ . c _ ] 
  
 :=  ( - b  +  S q r t [ b A2 -  4 a  c ] ) 
  
 / 
  
 (2  a )
  
 tion 
 ax2 + bx + c
  = 
 0
   .
  
 One nice thing about symbolic computation is that it’s very easy to see if a function 
 returns the intended result: simply call it with symbolic arguments. However, you 
 should try to get in the habit of using arguments whose names are different than the 
 names of the parameters, for the reason explained above.
  
 This is a poor test of the 
  
 quad [ a , b , c]
  
 „
  
 - 4 a c]
  
 quad function. 
  
 -b  +  S q r t [ b 
  
 2
  a
  
 This is a much better test; it 
  
 quad [ d , e , f  ]
  
 f ]
  
 demonstrates that parameter 
  
 „
  
 substitution really is taking 
  
 - e  +  S q r t [e 
  
 - 4 d 
  
 place.
  
 d x A2 + 
  
 e x  +  f  / . 
  
 x->%  / /  Expand
  
 Here we substitute the result 
  
 of quad into a quadratic 
  
 q
  
 equation.",NA
4.1.3 Type checking,"Most procedural programming languages allow (or require!) a programmer to specify 
 that the arguments to a function must be of a certain 
 type
  such as integer or real. In 
 Mathematica,
  every expression has a 
 head
  that can be considered to be its “type.”
  
 The head of any 
 expression can be found 
 using 
  
 Head [expr].
  
 Map[Head, {3, 3/2, 3 + 2 1 ,  {3, 2}, a}] 
  
 (Integer, Rational, Complex, List, Symbol)
  
 It is possible to specify that an argument to a function must have a certain head by 
 using 
 a formal parameter of the form 
 name_head
  in the definition of the function. For 
 example, the factorial function is defined only for integer arguments, so we might write 
 it like this:
  
 fact[n_Integer] 
 := 
 Product
 [i, {i, 
 n}]
  
 fact will evaluate for inte- 
 ger arguments... 
  
 but not for any other type. 
  
 fa c t [4] 
  
 24
  
 fa c t [3.5]
  
 fact [3.5]
  
 Similarly, a function requiring a list as an argument could be defined as 
 fu n c
  [s_ L ist].",NA
Dr ,"than semantic, in nature. In other words, even though every integer is a 
 real number and 
  
 every real number is also complex, you can’t pass an integer to a function that is 
  
 declared to take a real argument, or a real number to a function that is declared to taVp a 
 The kind of type checking afforded by the construct 
 name_head
  is syntactic, rather 
  
 complex argument. There is no automatic 
 type promotion
  of arguments as there is in 
  
 some other languages. This should be considered advantageous, as it gives the pro-
  
 grammer tighter control over how a function can be called. It is still possible to write a 
  
 type-checked function that takes more than one type of argument. One way to do this is 
  
 shown below:
  
 The vertical bar operator is 
  
 squareA nyN um ber [ n _ In t e g e r  | n _ R e a l 
  
 |
  
 called A lte r n a tiv e s . 
  
 n _ R a t io n a l | n _C o m p lex] 
  
 :=  n A2
  
 The function operates on 
  
 Map [sq u are A n y N u m b e r, 
  
 { 3 . 4 . 5 ,  2 / 3 ,  3 + 
  
 4 1 ,  x } ]
  
 any type of numerical 
  
 ^
  
 argument. 
  
 ( 9 , 
  
 2 0 . 2 5 ,  —, 
  
 - 7  +  24 I , squareA nyN um ber [ x ] }
  
 Furthermore, you can use Head to test the type of an argument, and react accord-
  
 ingly. Here is an example of a factorial function that is extended to the entire complex 
  
 plane.2
  
 The I f  function w ill be 
 covered in detail in 
  
 Section 4 .2.1. 
  
 e x t e n d e d f a c t o r ia l [ n _ In t e g e r  | n _ R e a l |
  
 n _ R a t io n a l 
  
 | n _C o m p lex] 
  
 : =
  
 I f  [H ead [n ] =
  
  I n t e g e r ,
  
 ( * t h e n * )  P r o d u c t [ i, 
  
 { i ,  n } ] ,
  
 ]
  
 ( * e l s e  e v a lu a t e  a pow er s e r ie s  f o r  Gamma[ n + 1 ] * )
  
 A more elegant way to accomplish the same thing is to create multiple definitions of the 
  
 ex ten d ed facto rial function, each one taking different types of arguments:
  
 C l e a r [ e x t e n d e d f a c t o r i a l ] ;
  
 e x t e n d e d f a c t o r ia l[ n _ In t e g e r ] 
  
 :=  P r o d u c t [ i, 
  
 { i ,  n } ]
  
 e x t e n d e d f a c t o r ia l[ n _ R e a l 
  
 | n _ R a tio n a l 
  
 | n_C om plex] 
  
 :=
  
 ( *  p ow er s e r ie s  f o r  Gamm a[n+1] 
  
 * )
  
 When the argument to ex ten d ed facto rial has head Integer, the first definition 
  
 will be used; when the head is Real, R ational, or Complex, the second definition 
  
 will be used. This is analogous to 
 Junction-name overloading
  in languages such as C++ 
  
 [Stroustrup 91]. In 
 Mathematica,
  however, it is a simple use of a much more general 
  
 mechanism, 
 pattern matching,
  that we will discuss in Chapter 6.",NA
4.1.4 Local variables,"Suppose we want to modify the quad function introduced in Section 4.1.2 to return a 
  
 list containing 
 both
  roots of the quadratic equation. Since the value of the radical is 
  
 used twice (once for each root), it would be sensible to compute it only once and store it 
  
 in a variable. Here is how that could be done:
  
 C le a r[q u a d ]
  
 q u a d [a _ , b _ , c _ ] 
  
 :=  (
  
 d =  S q r t [ b A2 -  4 a c ] ;
  
 { - b  +  d, -b  -  d} / 
 ( 2
   a)
  
 )
  
 Here are both roots of q u a d [ l, - 3 ,  2]
  
 xA2 - 3 x + 2 =  0. 
  
 {
  2
  , 
 1
 }
  
 The quad function now consists of a CompoundExpression having two subexpres-
  
 sions (Section 2.3.7); these subexpressions correspond to 
 statements
  in procedural pro-
  
 gramming languages. The entire CompoundExpression must be surrounded by 
  
 parentheses, or else the parser would assume that the function ended after the first semi-
  
 colon it encountered. Note that there is no semicolon following the final subexpression",NA
Hr ,"effect in the global name space. In other words, if we already had defined a 
 symbol 
  
 named d, its value would be trashed whenever quad was called!
  
 There’s a potentially serious problem with this definition of quad: It produces a side in 
 the function — if there were, the function would return Null.
  
 d has been overwritten by 
  
 d =  
 0
  ;
  
 the value of the discrimi- 
  
 q u a d [ l, 
  
 1
  , 
  
 1
  ]
  
 nant. 
  
 d
  
 j -1  +  I  S q r t [3 ] 
  
 I  S q r t [3]
  
 -1  -  I  S q r t [3 ] ^
  
 To avoid this problem, a symbol like d in the quad function should be made 
 local
  to that 
 function. This can be done by enclosing the body of the function in a Module. The 
 syn-tax of a Module is Module 
 [d ecla ra tio n s, body
 ], where 
 d ecla ra tio n s
  contains 
 a list of the symbols in 
 body
  that are to be considered local.",NA
4.1.5 Set versus SetDelayed,"In the examples given so far we have used SetDelayed (: =) to define functions. The 
 difference between SetDelayed and Set (=) is that the right-hand side (RHS) of a Set is 
 evaluated immediately, whereas the RHS of a SetDelayed is not. SetDelayed is almost 
 always what you want to use to define a function, and here’s why:
  
 Using Set, the current value of a 
 (3) is substituted into the RHS 
 of the function def- 
  
 a  =  3 ; 
  
 f o o [a _ ]  =  a A3 
  
 ^
  
 inition.
  
 The function always returns 
  
 f o o [ 2 ]
  
 2 7 
  
 27
  
 This is another source of hard-to-find bugs. Fortunately, checking the definition of your 
 function by using ?name shows this type of error immediately.
  
 ? fo o
  
 G lo b a l'f o o
  
 f o o [ a
  _
 ] = 27
  
 However, there are occasions on which Set is exactly what you need. Suppose you 
 have some expression resulting from another calculation, and you want to create a 
 func-tion that returns that expression. The following will not work:
  
 The intention here is for 
  
 N o rm a l [ S e r ie s  [B e s s e lJ  [ 0 , x ] , 
  
 { x , 0 , 3 } ] ]
  
 g [x ] to evaluate to the first 
  
 24
  
 three terms in the Taylor 
  
 _ x
  ___
 x
  
 series approximation for 
  
 4
  ”  64
  
 B esselJ [0 , x ] .
  
 g [x _ ] 
  
 : =  %",NA
Hr ,"called, you are reevaluating whatever result immediately preceded 
 the call — in this 
  
 case, Log[17.5]. 
  
 The literal % operator appears in the definition 
 of g. In other words, every rime, g is 
  
  
  
  
 g [xj : = %
  
  
 The correct thing to do in this case is to use Set, so that the RHS is evaluated at the 
 point of function definition.
  
 The value returned is the RHS 
 of the function defini-tion —  
 i.e., the % has been expanded.
  
 Now  g works as expected.
  
 Clear[g] 
  
 Normal[Series[BesselJ[0, x], {x. 0, 3}]] 
 g[x_] = %
  
 1 . 5_ + 5_ 
  
 4 64
  
 Log[17.5] 
 ; 
  
 g[z]
  
 1
  
 - 
  
 2 
  
 + 
  
 4
  
 —
  
 4 
  
 —
  
 64
  
 Another case in which you might want to use Set for function definition is when the 
 RHS can be simplified symbolically, even before the substitution of any parameters. If 
 the simplification saves a significant amount of computation, you probably want it to be 
 done in advance. For example, the following symbolic integration is fairly slow:
  
 The error message occurs 
 only in version 3.0.
  
 f[a_, b_] := Integrate[BesselJ[0, x] , {x, a, 
 b}] Timing[Table[f[0, c], {c, 1, 3}];]
  
 Integrate::gener: Unable to check convergence 
 (4.51667 Second. Null}
  
 By using Set, the integral is 
 evaluated before the 
 assign-ment to f.
  
 Clear[f] 
  
 f[a_. b_] = Integrate[BesselJ[0, x] , {x, a, b}]
  
 Integrate::gener: Unable to check convergence
  
  
 j 
 -(a HypergeometricPFQ[{-
 ;
  
 u . f ,-- 
  
 -2 
  
 T » -",NA
4.1.6 Return values,"Functions should always return their values using the normal function return 
 mecha-nism [i.e., the last expression evaluated by the function, or the argument to an 
 explicit call to Return (Section 4.3.4), is the return value of the function].
  
 It is considered the poorest of style to print results using P rin t rather than to return 
 them, because printed results are a computational dead-end — they cannot be used as 
 input to other commands. Even if a function returns highly formatted data, it is better to 
 return the raw data (in a nested list, if necessary) and allow the caller to format it as 
 desired. Better yet, write a second function that formats the data returned by the first 
 function.",NA
4.2 Conditional Execution,"Sometimes your code needs to take different actions depending on the value of some 
 expression. 
 Mathematica
  provides three conditional execution primitives: If, Switch, 
 and Which. Unlike procedural languages, however, these primitives are themselves 
 function calls, rather than syntactic keywords.4
  
 3. Of course, if the original intent were to plot the values of the integral, it would 
 have 
  
 been speedier still to define f  [a_, b_] := NIntegrate [BesselJ [0, x] , 
  
 {x, a, b}]. In this case the use of Set would cause an error (why?).
  
 4. This is a reflection of the fact that, underneath the procedural veneer, 
 Mathematica 
 is actually a functional programming language — the topic of the 
 next chapter.",NA
4.2.1 If,"The I f  function takes three arguments: the 
 test,
  the 
 if
  branch, and the 
 else
  branch.
  
 This function calculates the a b s v a l[x _ ] 
  
 :=  I f [ x  > 0 ,  x , 
  
 - x ]
  
 absolute value of its argu- T a b le  [a b s v a l [ i ]  . 
  
 { i , 
  
 - 3 ,  3 } ]
  
 m6nt‘ 
  
 ( 3 , 
  
 2 , 
  
 1 , 0 , 
  
 1 , 
  
 2 , 
  
 3 )
  
 Each of the arguments can be a list of expressions separated by semicolons, so
  
 Mathematica
 ’s I f  is just as powerful 
  
 as any syntactic 
 if
  statement. For example,
  
 The (*th e n » ) and 
  
 a = 5; b = 2;
  
 ( • e ls e * )  are merely com­
 I f
  [a < b,
  
 ments. The statements 
  
 (*then*)
  
 single argument to the I f between them constitute a 
  
 little = a;
  
 function. 
 big = b,
  
 (*else*)
  
 little = b;
  
 big = a
  
 {little, big}
  
 ( 2 , 5}
  
 Note that I f  returns the result of the last expression evaluated within its body.5 As 
  
 always, this can be suppressed with a semicolon.
  
 Since one or more of the arguments to a boolean operation could be symbolic, it is 
  
 quite possible that the operation cannot be evaluated. If this happens, I f  will be unable 
  
 to choose either alternative. For example,
  
 Clear [a, b]
  
 If[a < b, a, b]
  
 I f [ a  
 < b, a, b]
  
 To handle cases such as this, I f  takes an optional fourth parameter:
  
 If[a < b, a, b, ""I give up""]
  
 I give up
  
 Sometimes you want to execute the 
 else
  part even if the test expression can’t be eval­
  
 uated. Rather than using a four-parameter I f  with identical third and fourth parameters, 
  
 wrap the first argument inside the TrueQ function.
  
 5. Thus, the 
 Mathematica
  expression x = If [a, b, c] is analogous to the C state-
  
 ment x = a ? b : c. Note, however, that the roles of semicolons and commas are 
  
 reversed relative to C, e.g., 
 Mathematical
  x = If [a, bl; b2, cl; c2] corre-
  
 sponds to C’sx = a ? b l, b2 : cl. c2.",NA
4.2.2 Switch,"The Switch function is used to test the value of an expression against several different 
 alternatives. It is similar to the C statement of the same name. The first argument to 
 Switch is an expression to be tested; subsequent arguments, which must come in pairs, 
 consist of alternative values for the tested expression and the actions to be taken for 
 each possible value.
  
 This example does one of three 
 things, depending on whether 
 the remainder of x after 
 division by 3 is 0, 1, or 
 2
  .
  
 x = 88; 
  
 Switch [Mod [x, 3] 
 .
  
 0, ""remainder is 0"", 
  
 1, ""remainder is 1"", 
  
 2, ""remainder is 2""
  
 re m a in d e r i s  
 1
  
 If the expression does not
  
 Switch[Mod[x, 5], 
  
 0, ""remainder is 0"", 
 2, ""remainder is 2"", 
 4, ""remainder is 4""
  
 2 ,
  
 match any of the available
  
 cases, the S w itch remains
  
 unevaluated.
  
 A  default case can be speci-
  
 S w itc h [M o d [x , 5 ] ,  0 , re m a in d e r i s  0 , 
  
 re m a in d e r i s  2 , 4 , 
  
 re m a in d e r i s  4]
  
 Switch [Mod [x, 5] , 
  
 0, ""remainder is 0"", 
 2, ""remainder is 2"", 
 4, ""remainder is 4"",
  
 fied using a B lank (J .",NA
4.2.3 Which,"The Which statement is an alternative to a sequence of if-e ls e if-e ls e if-...-e ls e 
 statements. It is similar to the 
 cond
  statement of Lisp.
  
 Which[x < 0, ""negative"", 
  
 x =  
 0
  , ""zero"", 
  
 x > 
 0
  , ""positive""]
  
 positive
  
 In this example, the three cases cover all possibilities. As with Switch, it sometimes is 
 desirable to have a default case. Such a case can be implemented by specifying a final 
 condition of True.
  
 Which[x < 0, ""negative"", 
  
 x =  
 0
  , ""zero"", 
  
 True, ""positive""]
  
 positive
  
 Exercise
  
 1. Which is useful for defining piecewise functions. Write a function of a single 
 vari-able x that is equal to Sqrt [-x - 1] when x <= -1, to Sqrt [x - 1] when x >= 1, and 
 to 1 - xA2 when x is between -1 and 1. Plot this function from x = -2 to 2.",NA
4.3 Iteration,"Mathematica
  contains three looping constructs that are found in other procedural 
 pro-gramming languages: Do, While, and For. However, as with conditional execution, 
 these primitives are all functions; there is no built-in syntax to support loops.
  
  
 Do, While, and For all share an unusual trait (for 
 Mathematica
  functions, that is): 
 They don’t return any values.6 To get any useful results out of them requires the use of
  
 6. To be pedantic, they return Null.",NA
4.3.1 Do ,"The Do function is a concise way to iterate over an index variable that takes on values in 
 an arithmetic progression. It takes the same arguments as Table and Sum; unlike those 
 functions, however, Do returns Null. Compare the following:
  
 Table 
 returns a list of the 
  
 T a b le  [ k , 
  
 { k , 3 , 9 , 
  
 2 } ]
  
 first argument evaluated at 
  
 ^ 
  
 5
  
 7
  
 9
  }
  
 each value in the range of 
  
 ' 
  
 ’ 
  
 ’
  
 3 ,  9,  2 } ]
  
 the index variable.
  
 D o [ k , 
  
 { k , 
  
 Do 
 does all the work, but 
  
 returns nothing; this was a
  
 waste of processor time!
  
 In order to do any useful work, the code inside of a Do must create some kind of side 
 effect. Examples of side effects are: creating, removing, or changing the values of 
 sym-bols; output to a file; or the rendering of graphics on the screen.
  
 Here's one example of using 
  
 s =  { } ;
  
 2 } ]
  
 side effects to get results out 
  
 Do [AppendTo [ s , k ] , { k , 3 , 9 , 
  
 of a Do loop.
  
 To result has been stored 
  
 s
  
 9 )
  
 in s.
  
 13, 5 , 7 , 
  
 Sum returns the sum of the 
  
 S u m [k, { k , 
  
 3 , 9 , 2 } ]
  
 first argument evaluated at 
  
 2 4
  
 each value in the range of
  
 the index variable.
  
 Here is how to get the 
  
 s =  0 ;
  
 k ,  { k , 3 , 
  
 9 ,  2 } ]
  
 equivalent effect with Do. 
  
 D o [ s  + = 
 s
  
 24
  
  
 Here is a particularly useful trick for generating a sequence of animation frames. The 
 output is not shown because it would take up several pages.
  
 D o [ P l o t [ S i n [ x  -  y ] , 
  
 { x , 0 , 
  
 2 P i } ] . 
  
 { y ,  0 , 
  
 1 5 P i/8 , P i /
  8
  } ]
  
 (* many graphics omitted *)
  
  
 T .ikp. 
 the Table command, Do can accept multiple index variables and ranges. This 
 feature allows you to write nested loops in a very concise manner:",NA
4.3.2 For,"For implements a C-styl
 efor
  loop. Like its C counterpart, For takes four arguments: the 
 initializer, the test, the increment, and the body. Here is how you would implement the 
 summation example from the previous section using For:
  
 Like 
 Do, For 
 returns 
 Null; 
 you have to evaluates to get the 
 result of the computa- tion. 
  
 s = 
  
 0;
  
 F o r [ i  =  
 3
  , i  <= 
 9
  , i  + =  
 2
  , s + =  i ]  ; s
  
 2 4
  
 For is more general than Do because the initializer, test, and increment can be 
 arbi-trary 
 Mathematica
  expressions. For the same reason, a For loop is slower than an 
 equivalent Do loop, not to mention harder to parse by the human eye, so Do should be 
 given preference whenever circumstances permit. Also note that to implement an 
 itera-tion over more than one variable, For commands must be nested explicitly (i.e., 
 there is no multivariable form of For as there is for Do).",NA
0 -,"n ( n -
   1) -  (n - r + 1)—
 -----
 ~r
 — tt
 ----
  :
 -----",NA
 -,"r
  a 
 positive integer 
 r ( r -
   1) — 1
  
 1 
  
 r = 0
  
 0 
  
 r
  a negative integer",NA
4.3.3 While,"Another looping construct borrowed from C is While, which takes two arguments, a test 
 and a body. Here is the same summation example, this time using While:
  
 Since the W h ile loop does 
  
 i  =  3 ; s =  0 ;
  
 s 4 =  i ;  i  + =  2 ] ;
  
 not return a value, s must be 
  
 W h ile  [ i  < = 9 , 
  
 returned explicitly. 
  
 s
  
 24
  
 What appears at first to be a third argument to While (i += 2) actually is a continua-tion 
 of the second argument: This is evidenced by the fact that the two expressions are 
 separated by a semicolon, not a comma. This syntax may take a while (no pun intended) 
 for C programmers to get used to.
  
 It should be noted that For and While are equally powerful; i.e., any While loop can 
 be rewritten as a For loop and vice versa. Which one to use is a matter of stylistic 
 preference.
  
 While loops typically are used to loop for an unknown number of times, such as during 
 an iterative approximation. Here is a function that approximates the square root",NA
4.3.4 Miscellaneous control flow,"There are functions called Break, Continue, Return, Goto, and Label that are iden-tical 
 to the C statements of the same name. Continue [] skips the remainder of the cur-rent 
 iteration of a loop, whereas Break [] exits the loop entirely. Return 
 [val]
  exits a",NA
4.4 Parameter-Passing Semantics,NA,NA
4.4.1 Parameters are ,NA,NA
not,NA,NA
 local variables,"It will come as a surprise to programmers who are used to other 
 programming 
 lan-guages that 
 you cannot modify a parameter of a function inside the body of the 
 function.
  
 For example:
  
 This function tries to use its 
 parameter as a loop counter.
  
 sumdown [n_] := Module[{s =0}, 
  
 While[n > 0, s += n; n--];
  
 5
  
 Not only do we get this 
  
 strange error message, but 
 also we have to abort the 
 computation.
  
 sumdown [3] 
  
 Decrement::rvalue: 3 has not been assigned a value.
  
 $Aborted",NA
4.4.2 Call by value,"The solution to the problem demonstrated in the previous section is, of course, to use a 
 local variable as a proxy for the parameter.
  
 Although you can't modify n, 
 you certainly can 
  
 m odifyx. 
  
 C le a r  [sumdown]
  
 sumdown [n _ ] 
  
 : =
  
 M o d u le [ {x  = 
  
 n , s =  0 } ,
  
 W h ile [ x  > 0 , 
  
 s + =  x ; x - - ] ;
  
 ]
  
 s
  
 sum down[3 ]
  
 6
  
 This effectively simulates 
 call by value
  parameter-passing semantics, which is the 
 semantic model used for all parameters in C [Kemighan & Ritchie 78] and for non-var 
 parameters in Pascal [Jensen & Wirth 74].",NA
4.4.3 Call by name,"Call by name
  is a fairly esoteric semantic model for parameter passing that was 
 intro-duced by Algol-60 [Naur 63]. The semantics of call by name are that a function 
 should",NA
Hr ,"expression rather than on the value to which the expression would evaluate (the 
 mysum 
  
  
 function is an example). Quite often, however, there are alternatives that are safer. 
  
   
 algebra system such as 
 Mathematica'.
  Sometimes you need to operate on a symbolic 
   
   
 Call by name is powerful and dangerous.
  Legitimate uses do exist in a symbolic 
  
 Unless you are writing functions that truly need this capability, you are better off 
 stay-ing away from it.
  
 As a final warning to the skeptics, consider the infamous call by name swap func-tion:
  
 This function is designed to 
 swap its arguments.
  
 It seems to work just fine.
  
 SetAttributes[swap, HoldAll] 
 swap[a_, b_] := 
  
 Module[{temp}, 
  
  
 temp = a; 
  
   
 a = b ; 
  
  
 b = temp; 
  
 ]
  
 {p. q} = {
 1
  . 
 2
  
 }; 
  
 swap [p, q] 
  
 {p. q}
  
 (
 2
  , 
 1
  }
  
 p = 1; t = {3, 2. 4};",NA
4.4.4 Call by reference,"Call by reference is a semantic model for parameter passing that allows changes made 
 to a parameter inside of a function to be visible outside the function. This is the model 
 used by all Fortran parameters, by C++ 
 reference
  parameters [Stroustrup 91], and by 
 Pascal 
 var
  parameters. It typically is used by functions that need to return more than a 
 single value, although it is preferable in such cases to return a list of values.
  
 Mathematical
  call by name semantics can be used to simulate call by reference 
 behavior in a “safe” fashion. The trick [Maeder 94a] is to give the function one of the 
 Hold- attributes 
 and
  to specify that the arguments to be modified be symbols rather than 
 arbitrary expressions. The latter can be effected by using a formal parameter of the form 
 flame_Symbol. For example:
  
 S e tA ttr ib u te s [n e w s w a p , H o ld A ll]
  
 Since you cannot pass arbi- 
  
 n ew s w a p [a _ S y m b o l, b _S ym b o l] 
  
 : =
  
 trary expressions to new- 
  
 M o d u le  [ {te m p } ,
  
 swap, it is safer than swap. 
  
 tem p =  a ;
  
 a =  b ;
  
 ]
  
 b =  tem p ;
  
 2
  } ;
  
 { p , q ) =  {
  1
  , 
  
 n e w s w a p [p , q]
  
 {p. q>
  
 {
 2
  , 
 1
 }",NA
4.5 Advanced Topic: Scoping,"The 
 scope
  of a symbol is the region of a program within which the name of the symbol 
 actually refers to 
 that
  symbol, as opposed to some other symbol having the same name. 
 For example, the scope of a formal parameter in a function is the body of the function; 
 outside the body of the function, the same name refers to a different symbol.
  
 We’ve already seen three scoping constructs: function declaration, Module, and With. 
 All three of these constructs scope a symbol in space, that is, in a particular region of the 
 program. This is called 
 lexical
  scoping. In contrast, the often-misunder-stood scoping 
 construct Block scopes a symbol in 
 time
 ; this is called 
 dynamic
  scoping. In Section 4.5.1 
 we compare Block to Module. Finally, in Section 4.5.2 we explain how lexical scoping 
 constructs behave when they are nested inside of other lexical scoping constructs.",NA
4.5.1 Lexical versus dynamic scoping,"The Module command scopes symbols in a way that computer scientists call 
 lexical 
 scoping
  [MacLennan 83]. What this means is that the actual symbol that is bound to a 
 name can be inferred completely from the textual context in which the name is used. 
  
 Here is an example that hopefully will clarify this explanation:
  
 W ith this definition, the 
  
 value of f  oo depends on the
  
 foo := x;
  
 value of the global symbol x.
  
 Changing x  affects the 
 eval-uation of foo.
  
 x = 
 1
  ; foo 
  
 1
  
 x = 
 2
  ; foo
  
 2
  
 But foo is unaffected by the 
  
 M o d u le  [ { x  =  3 } ,  fo o ]
  
 local symbol named x. 
  
 ~",NA
4.5.2 Nested scoping constructs,"When lexical scoping constructs with possibly conflicting name declarations are nested, 
 the innermost construct that declares a given name is the one that determines the 
 sym-bol to which the name refers. For example,
  
 Two different x's are being 
  
 W i t h [ { x  =  a } ,  W it h [ { x  =  b } , x ] +  2 x ]
  
 used to compute the result. 
  
 ? *  +  h",NA
5,NA,NA
Functional ,NA,NA
Programming,"Chapter 4 illustrated how one can program in a procedural style using 
 Mathematica. 
 However, procedural programming constructs in 
 Mathematica
  really are just a facade; 
 deep down inside, 
 Mathematica
  is 
 afunctional
  programming language.
  
 In the functional programming paradigm there is no distinction between functions 
 and data. Functions can be manipulated just as any other data, including being passed as 
 arguments to and returned as results from other functions. You can, for example, write a 
 program that writes other programs and executes them. This is why functional 
 programming is so popular in the field of artificial intelligence: It enables the creation of 
 programs that have the ability to change their behavior as they run.
  
 Furthermore, in functional programs there are no assignment statements and no 
 loops.1 In place of assignments to variables, data are moved strictly through function 
 call and return (by nesting function calls, sometimes quite deeply). In place of loops, 
 there are 
 higher-order functions
  that apply other functions to collections of data, or 
 recursion
  is used. Because functional programming is so different from procedural 
 pro-gramming, it does require some effort to master, but the payback is its ability to 
 pro-duce programs that are elegant, concise, and powerful.
  
 In the early parts of this chapter we restrict our attention to performing functional 
 operations on lists. In the last part of the chapter we show how these operations 
 general-ize to arbitrary expressions.
  
 The most well-known functional programming language undoubtedly is 
 Lisp 
 [Steele 
 84]. Throughout this chapter we shall remark on the similarities and differences between 
 Mathematica
  and Lisp; a summary of these observations is given in Section 5.7.
  
 1. Although these seem like drastic restrictions, their virtue is that they allow 
 func-
  
 tional programming to be placed on a sound mathematical footing.",NA
5.1 Basic Functional Programming,NA,NA
5.1.1 Map and Apply,"Map and Apply are two of the most fundamental functional programming operations.
  
 Map wraps a given function around each element of a list and returns a list of the 
  
 results.2 It is similar to the Lisp function mapcar.
  
 M a p [ f , 
  
 { a , b , c } ]
  
 ( f  [a ] , f  [b] , f  [c ] }
  
 Map has a special input 
  
 f  /@ { a . b , c }
  
 form - 
  
 I f  [ a ] ,  f [ b ] ,  f  [c] }
  
 Apply, on the other hand, wraps a function around 
 all of the elements of a list at
  
 once
  (not the list itself):
  
 Apply[f, {a, b, c}]
  
 f [ a ,  b ,  c]
  
 Apply, too, has a special 
 input form. 
  
 f  @@ { a , b , c } 
  
 f [ a >  b> c]
  
 For example, suppose we wanted to sum all of the elements of a list. We could do 
  
 this with some kind of iterator, but it’s much more elegant (and efficient) to use Apply:
  
 The internal form of the 
  
 P lu s  @@ { a , b , c )
  
 result is P lus [a , b , c ]. 
  
 a +  b +  c
  
 In contrast, 
 mapping
  Plus onto a list has no apparent effect:
  
 M a p [P lu s , 
  
 { a , b , c } ]
  
 ( a ,  b , c )
  
 A trace of the evaluation shows why.
  
 Each application of Plus is 
  
 T r a c e  [Map [ P lu s . 
  
 { a , 
  
 b . 
  
 c } ] ]
  
 c l )
  
 interpreted as unary plus, 
 which is an identity opera- 
  
 {p lu g  /@ { 
  
 b c ) 
  
 { p i u s [a ] p P lu s  [b ] . P lu s  [ c ] },
  
 , r 
  
 , r , r ,
  
 { P l u s [ a ] ,  a } , 
  
 { P l u s [ b ] ,  b } , 
  
 { P l u s [ c ] ,  c } , 
  
 { a ,  b . 
  
 tion.
  
 We can use Apply to create the following concise function that computes the arith-
  
 metic mean of a list. Note that this function works on lists of any length because Plus 
  
 is an n-ary operator (Section 2.3.1).
  
 2. Map was introduced in Section 3.5.3. You may wish to go back and review that
  
 material, as well as other coverage of lists in Chapter 3, before proceeding.",NA
5.1.2 Pure functions,"At this point, we will postpone the introduction of any new functional programming 
 operations to talk about a feature of 
 Mathematica
  that makes all of these operations 
 more convenient to use, namely, 
 pure functions.
  
 As savvy 
 Mathematica
  programmers, we are well aware of the fact that there is no 
 real distinction between code and data — everything is an expression. Whether or not an 
 expression is a function is simply a matter of interpretation by the kernel. There are 
 basically only two things that distinguish the body of the function definition f  [x_] : = 
 xA (1/3) from the “naked” expression xA(l/3 ). First of all, in the former case the body 
 expression is not evaluated until the function is used. Second, the function decla-ration 
 alerts the kernel that the symbol x in the expression is actually a parameter, and not a 
 global symbol called x.
  
 It would be nice if we could take an arbitrary expression and say to the kernel, 
 “Please treat this as a function just for a moment,” without actually having to define a 
 function in the normal way. It turns out that there is a special head that does exactly 
 that. It is called — what else? — Function. The first argument to Function is the name 
 of the formal parameter, and the second argument is the expression that we wish to use 
 as a function. Here is an example of using Function to create a function that applies 
 Power to its argument:
  
 Function
 [ x . 
 Power @@ 
 x ]
  
 Function[x, Apply[Power, 
 x ]
  ]
  
 Passing a list to this function 
 applies Power to the list. 
  
 % [ { a ,  b } ] 
  
 ^ 
  
 a
  
 Note that there is no Blank appended to the formal parameter as there is in a normal 
 function definition. Also note that Function is a lexical scoping construct (Section 
 4.5.1); therefore, the name chosen for the formal parameter does not affect the 
 computation.
  
 Function
 [ x , 
 Power @@ 
 x ] [ { 1  
 + 
 x ,  1 / x } ]
  
 An expression with head Function is called a 
 pure function.
  Note that Function is 
 simply a “container” that provides the twin essentials for interpreting the expression 
 within it as a function: It does not evaluate the expression (it has the HoldAll attri-bute), 
 and it specifies which symbols in the body of the function are parameters.",NA
5.1.3 Level specifications,"The 
 level
  of an element in an expression is the number of subscripts that are necessary 
 to identify its position within the expression. 
 Level 
 [ l i s t , lev]
  returns a list of all 
 elements of 
 l i s t
   that are at level 
 lev. 
 For example,
  
 The sublists {a . b} and 
  
 a l i s t  =  { { a ,  b } , 
  
 { c , 
  
 { d ,  e } } } ;
  
 L e v e l [ a l i s t , 
  
 { 1 } ]
  
 { c,  {d , e } }  are at level 
 1
  .
  
 { { a ,  b ) , 
  
 ( c , 
  
 { d,  e > } }
  
 a, b, c, and the sub-sublist 
  
 L e v e l [ a l i s t , 
  
 { 2 } ]
  
 {d,  e} are at level 
 2
  .
  
 { a , b , 
  
 c , 
  
 {d , 
  
 e )
  
 d and e are at level 3. 
  
 L e v e l [ a l i s t , 
  
 { 3 } ]
  
 {d,  
 e}
  
   
 By default, Map operates only at level 1, and Apply operates only at level 0 (the 
 entire expression). However, both take an optional third argument, called a 
 level 
 speci-fication,
  that controls the levels at which they operate. There are several forms of 
 level specifications, similar to the forms of the index range in functions such as Take and 
 Drop.
  
 A level specification of the form {n} specifies level 
 n
  only. Compare the following 
 results carefully:
  
 The default behavior of Map 
  
 M a p [ f, 
  
 a l i s t ]
  
 e } } ] }
  
 e } ] }}
  
 is to operate at level 
 1
  only. 
  
 { f [ { a >  b } ]  _ f [ { c > 
  
 { d _ 
  
 Here we Map at level 2. 
  
 M a p [ f , 
  
 a l i s t ,  { 2 } ]
  
 , f  [ { d , 
  
 { { f  [a] . f [ b ] l ,  ( f  [c]",NA
5.1.4 MapAt,"Contrast the use of Map with level specifications to the function MapAt, which allows 
 you to target the application of a function to a 
 particular element
  within an expression 
 rather than to an entire level. For example,
  
 b is at position {1, 2). 
  
 Therefore, this wraps f only 
  
 around b.
  
 Multiple specifications can 
  
 be enclosed within another 
  
 P osition [ a lis t, b] 
  
   
 ({1, 2)} 
  
 MapAt [f, a l i s t ,  {1. 2}] 
  
  
 {{a, f [ b ] }, {c, {d, e}}: 
  
 MapAt[f, a l i s t ,  {{1, 2}, {2, 2, 1}}] ({a> 
 f[b]}> ^  {f [d] _ e}))
  
 We’ll see some sophisticated uses of MapAt in Section 5.5.3.
  
  
 There is no corresponding function ApplyAt; however, it’s not hard to build one 
 using MapAt.
  
 Exercise
  
 1. Write an ApplyAt function. It should behave as follows:
  
 ApplyAt[f, a l i s t ,  {{1}, {2, 2}}]
  
 {f [a, b] , (c, f  [d, e] }}",NA
5.2 Variations on a Theme,Map has quite a few less-familiar relatives that are useful in particular circumstances.,NA
5.2.1 MapThread and Thread,"MapThread is a generalization of Map to functions that take more than one argument. 
 The first argument to MapThread is the function to be mapped, and the second 
 argu-ment is a matrix.",NA
5.2.2 Maplndexed,"Sometimes the function you want to map onto a list needs to know the position of the 
 element it is operating upon. For example, you may want to compare every element in 
 the list to its neighbor(s), compute a moving average of data, or check a matrix to see if 
 it has any special structure. You might think that you have to resort to an explicit loop to 
 do this (so that the function has access to the loop index), but in fact there are 
 alterna-tives. The Maplndexed function is one such alternative.
  
 Maplndexed applies a given function to each element of a list, but passes an 
 addi­tional argument to the function indicating the position of the list element. Here’s a 
 sim-ple example:
  
 The second argument 
  
 Maplndexed
 [ f ,  
 {a, 
 b , c l ]
  
 {
  3
  } ] )
  
 passed to the function con- 
 tains the position of the cur-
  
 { f [ 
  
 { 1 } ]  , f [ b > 
  
 {
  2
  j ] f f [ c> 
  
 rent element.
  
 Of course, the actual function being mapped had better expect this additional argument.
  
  
 The position argument is wrapped in list braces so that Maplndexed can work at 
 deeper levels of the list in a consistent manner:
  
 The level specification maps f a 
 t  level 2 of this list. Thus 
  
 Maplndexed 
 [ f ,  
 {{a. 
 b , c } 
 , {d. e}}. 
  
 { 2 } ]
  
 { { f [ 
  
 {1> 
  
 1 } ]  _ f [ b > 
  
 {1> 
  
 2 } ]  _ f [ c >  {1> 3 } ] ) >
  
 fnTegeP""
  
 IS 
  
 'St 
  
 {ftd’ (2' 
 ^  •
  f te ’ (2’
  
  
 One practical use of Maplndexed is to check a matrix for certain properties. For 
 example, suppose we wanted to check a matrix to see if it is diagonal. For any element x 
 at position {i , j } in the matrix, either x must be zero or i  must equal j . The latter 
 condition can be checked easily by using Equal @@ { i, j }. Therefore all we need to do 
 is to use Maplndexed to map the pure function Function [{x, index}, x =  0 
  
 | 
 Equal @@ index] onto the matrix at level 2:
  
 This matrix is diagonal. 
  
 m l 
  
 =  { { 1 ,  0 } , 
  
 { 0 ,  1 } } ;
  
 M a p ln d e x e d [
  
 F u n c t io n [ { x , in d e x } , x  = =  0 | | E q u a l @@ i n d e x ] ,
  
 m l, 
  
 {
  2
  }]
  
 ({True, True}, (True, True})
  
 This matrix has a nonzero 
  
 m2 
  
 =  { { 1 , 
  
 1 } , 
  
 { 0 ,  1 } } ;
  
 entry off the diagonal at
  
 position {
  1
  , 
 2
  ).",NA
5.2.3 Through,"Through is complementary to Thread: Rather than applying a single function to 
 argu-ments that are lists, Through applies a 
 list of functions
  to scalar arguments. 
 Compare the following to see the difference:
  
 Thread[f[{al, bl, cl}, {a2, b2, c2}]]
  
 (f[al, a
 2
  ] , f[bl, b
 2
  ] , f[cl, c
 2
  ]}
  
 Through[{f, g, h}[a, b, c]]
  
 {f[a, b, c], g[a, b, c], h[a, b, c]}
  
 Through is rather uncommon; we’ll see just a few examples of its use in this book.",NA
5.2.4 Scan,"Scan is not a true functional primitive. It is like Map in that it applies a function to a list 
 of arguments, but it does not return a list of the results. By default, Scan returns Null, 
 which means that it can act only through side effects:
  
 Scan[Print, {a, b}]
  
 a 
  
 b
  
 An example of a useful side effect would be to increment a counter, perhaps to create a 
 histogram of the values in a list. For example,
  
 Here are some data.
  
 Initialize a histogram with 5 
 bins.
  
 Since the data are real 
 num-bers between 
 0
  and 
 1
 , 
  
 C e ilin g  [5#] is a number
  
 data = Table[Random[], {100}] ; 
 hist 
 = 
 Table
 [0, {5}]:
  
 Scan[hist[[Ceiling
 [5#]]]++ 
 &, data]
  
 between 
 1
  and 5.
  
 Here's the result.
  
 hist
  
 { 1 7 , 
  
 23, 
  
 2 1 , 
  
 13, 
  
 26}",NA
5.3 Iterating Functions,"Mathematica
  provides three functions for iterating other functions, either for a given 
 number of times or until some convergence criterion is satisfied. These functions 
 fre-quently can be used in place of procedural looping constructs.",NA
5.3.1 Nest,"The Nest function composes a function with itself a given number of times, starting from 
 a specified value.
  
 Nest[f, a, 4]
  
 f [f [f [f [a]]]]
  
 Here is an example of using Nest to compute a continued fraction.
  
 Nest[l/(1 + #) &. x, 3]
  
 1 +
  
 1 + 
  
 1 
 +  x 
 1
  
 It might be easier to understand what’s going on if we could see the intermediate 
 expressions that are used to build up the final expression. That is what N estL ist is for.
  
 NestList[1/(1 + #) &. x. 3]
  
 1 
  
 1 + X
  
 ,
  
 {x ,
  
 1
  
 1
  
 1 + x ' i + d 
 1 +  X
 - ’ i
  
 +
  
 1 
 +
  
 Exercise
  
 1. Use N estL ist to calculate a random walk5 on the integers. That is, starting from 
 some initial value, repeatedly move up or down by 1 with a 50-50 (or some other) 
 chance. You can plot the result using L istP lo t.",NA
5.3.2 FixedPoint,"The function FixedPoint is like Nest except that it continues to compose the given 
 function until the returned values converge or until an optional iteration limit is reached. 
 This is useful for performing iterative numerical procedures. Here is an exam-
  
 5. Random walks often are used to model gambling games. The initial value is 
 the amount of money with which the gambler begins. The problem of 
 determining how long, on average, until this value reaches 0 is called the 
 Gambler’s Ruin
  problem.",NA
’Sr ,"explained below.
  
 Note the decimal point in the second argument; this is 
 very important,
  for reasons 
  
 As with N estL ist, there’s an analogous function called F ixedP ointL ist that 
  
 shows all of the intermediate results.
  
 This computation converges 
  
 F ix e d P o in t L is t  [ ( # +  2 / # ) / 2 & , 
  
 1 . ]
  
 quite rapidly. 
  
 { 1 > 
  
 1 5 > 
  
 1 _
 4
  1667> 
  
 1
  .
  4 1 4 2 2
  . 
  
 1 . 4 1 4 2 1 , 
  
 1 . 4 1 4 2 1 , 
  
 1 . 4 1 4 2 1 }
  
 As noted above, using an approximate number in at least one of the arguments is 
  
 crucial.
  It prevents symbolic expansion of the computation, which would be a mess — 
  
 and wouldn’t converge either. The third argument to F ixedP ointL ist in the follow­
  
 ing example specifies an iteration limit. Without it, this computation would continue 
  
 until 
 Mathematica
  had run out of memory.
  
 FixedPointList[(# + 2/#)/2&, 1, 5]
  
 ’ 
  
 3 
  
 17 
  
 577 
  
 6 6 5 85 7 
  
 8 8 6 7 3 1 0 8 8 8 9 7
  
 2 ’ 
  
 1 2 ’ 
  
 4 0 8 ’ 4 7 0 8 3 2 ’ 
  
 6 2 7 0 1 3 5 6 6 0 4 8
  
 The reason that this computation would fail to terminate without the iteration limit is 
  
 that the default test for convergence is syntactic, not semantic. Even though the 
 numer-
  
 ical
  values of the rationals are converging, the rationals themselves remain syntacti-
  
 cally distinct.
  
 The SameTest option can be used to specify a different convergence test, which 
  
 should be a function of two arguments that returns True or False. This is 
 particularly
  
 useful if the iterates are not approximate numbers (e.g., they may be vectors or sym-
  
 bolic quantities). For example, suppose we were interested in a rational approximation 
  
 to the square root of 2 to within a given tolerance. We could proceed this way:
  
 This computation converges 
  
 F ix e d P o in t L is t  [ (#  +  2 / # ) / 2 & ,  1 ,  2 0 ,
  
 < 1 0 A- 1 2 & ) ]
  
 before the iteration limit is 
  
 S a m e T e s t-> (Abs [ N [ # l -  # 2 ] ] 
  
 reached.
  
 {1,
  
 3 
  
 17 
  
 577 
  
 6 6 5 85 7 
  
 8 8 6 7 3 1 0 8 8 8 9 7
  
 2 ’ 
  
 1 2 ’ 
  
 4 0 8 ’ 4 7 0 8 3 2 ’ 6 2 7 0 1 3 5 6 6 0 4 8 ’
  
 1 5 7 2 5 8 4 0 4 8 0 3 2 9 1 8 6 3 3 3 5 3 2 1 7 ,
  
 1 1 1 1 9 8 4 8 4 4 3 4 9 8 6 8 1 3 7 9 3 8 1 1 2
  
 It is always prudent to specify an iteration limit to prevent infinite looping in case the 
  
 function being iterated does not converge. Even when you “know” the computation 
  
 converges, it is still all too easy to make a typographic error (such as leaving out a dec-",NA
5.3.3 Fold,"The function Fold is somewhat like Nest, except that its first argument is a function of 
 two
  arguments. It is 
 similar 
 to the reduce function of Lisp. Here is the analogous func-tion 
 FoldL ist, which makes the operation of Fold easier to understand:
  
 The list of second arguments to 
 f  gets ""folded in"" as the 
 computation proceeds.
  
 F o ld L is t  [ f ,  a , 
  
 { b , c , d} 3
  
 { 
  
 f [ 
  
 b ] 
  
 f [ f [ a >  b] > c] _ f [f [f [ a> b ] , c ] , d ] }
  
 Although this seems like a curiosity, it’s actually very useful. For example, if f  is the 
 Plus function, F oldL ist will compute all cumulative partial sums of the elements of a 
 list:
  
 cumulsuia[l_] := FoldList[Plus, First[l], Rest[l]] 
 cumulsum[{a, b, c, d}]
  
 { a , a + b ,  a + b + c ,  a + b + c + d }
  
 This technique will work for any left-associative operator.
  
 Another practical use of Fold is to implement 
 Homer’s rule
  for evaluating a 
 poly­nomial. The basic motivation behind Homer’s rule is that it significantly reduces 
 the number of multiplications used to evaluate the polynomial. For example, Homer’s 
 rule would compute the polynomial 
 a0
  + 
 axx
  + 
 a^x1 + ay>?
  as 
 a0 + x(al + x(a2 + 
 xa3)).
  This can be accomplished very elegantly using Fold:
  
 Fold[(#l*x + #2)&, a3, {a2, al, a0}]
  
 aO +  x  ( a l  +  x  ( a2 +  a3 x ) )
  
 In Section 5.3.5 we will use Fold to implement a finite state machine.
  
 6. Press Command-, (period) on the MacOS, Alt-, on Windows, or Control-C 
 on UNIX. Consult the 
 User’s Guide
 for your specific system if you are unsure.",NA
5.3.4 Throw and Catch,"Throw and Catch provide a mechanism for altering the flow of execution of any 
 Mathematica
  computation. Recall from Section 4.3.4 that 
 Mathematica
  contains 
 func-tions such as Break, Continue, and Return for altering or terminating the execution 
 of loops and procedures. Unfortunately, these functions cannot be used to exit from any 
 of the functional iteration constructs discussed in this section. For example, when the 
 function f , defined below, is passed to N estL ist, the Return expression within f  has no 
 apparent effect on the computation:
  
 f[x_] := (If[x > 5, Return[x + 1]]; 2x) 
  
 NestList[f, 1, 6]
  
 { 1 , 2, 
  
 4 , 
  
 8 , 
  
 9, 
  
 1 0 , 
  
 11}
  
 The reason for this behavior is that the Return causes f, not N estL ist, to return. It 
 would be useful if there were some way to return from more than one function at a time. 
 This is exactly what Throw and Catch are for.
  
 The expression Catch [expr] normally returns the value of 
 expr.
  However, if a Throw 
 [val] is encountered during the evaluation of 
 expr,
  the evaluation stops and Catch 
 [expr]
  
 returns 
 val
  instead. Here is a concrete example:
  
 Redefine f  to use Throw 
 rather than Return. 
  
 In this case, the Throw is not 
  
  
 C le a r  [ f  ] 
  
 f [ x_] := (If[x > 5, Throw [x + 1 ] ] ;  2x)
  
 C a tc h  [ N e s t L is t  [ f , 
  
 1 , 3 ] ]
  
 7. This operation is so frequently requested that version 3.0 introduced a new 
 function, 
  
 FromDigits, that performs it.",NA
5.3.5 Application: Huffman coding,"In this section we apply functional programming techniques to the problem of 
 con-structing and using 
 Huffman codes
  (described below). This application provides 
 many excellent examples of the use of high-level functional programming operations, 
 such as FixedPoint and Fold, and the treatment of functions as data. It also demonstrates 
 how 
 Mathematica
  lists can be used to represent graph-theoretic trees. This section is 
 quite long but should reward the reader by crystallizing many important concepts.
  
 Character codes
  
 A 
 character code
  is a mapping from characters to binary integers. Character codes 
 come in two basic “flavors,” fixed-length and variable-length. The advantage of vari- 
 able-length codes is that they typically can encode a particular message in fewer bits 
 than a fixed-length code. A Huffman code is a particular type of variable-length 
 charac-ter code that has several desirable properties. Before getting into the details of 
 Huffman codes, however, we will give an example to motivate their development. 
 Here’s an example message that we wish to encode:
  
 msg = ""she sells sea shells by the sea shore"";
  
  
 In preparation for constructing a code we have to find the 
 alphabet
  of the message, 
 i.e., the set of all unique characters that appear in the message.
  
 8. The 
 form
  argument can be a constant expression or it can be a 
 pattern 
 (Section 6.1).",NA
5.4 Recursion,"Divide and conquer
  is an algorithmic strategy whereby problems are solved by break-ing 
 them down into one or more smaller problems of the same type. This procedure 
 continues until the problems being considered are so small that their solutions are 
 triv-ial. The subsolutions are then combined to form the solution to the original problem.
  
 Recursion
  is the act of a function calling itself. Programming languages that support 
 recursion (a class that includes nearly all modem languages) make the implementation 
 of divide-and-conquer algorithms straightforward. This is because the mechanism of 
 recursion handles the combination of the subsolutions automatically.",NA
5.4.1 The basics,"Without a doubt, the most famous example of a recursive function is the factorial:
  
 fact[n_Integer] := If[n =  0, 1, n fact[n - 1]] 
 Array[fact, 5]
  
 (1, 
 2
  , 
 6
  . 24, 120}
  
 As you can see, the fa c t function calls itself. There’s nothing wrong with doing this, so 
 long as “the buck stops” somewhere (in this case, when n becomes 0).",NA
5.4.2 Recursion on lists,"The principal data structure in the functional programming paradigm is the list. Since 
  
 lists have basically the same structure no matter what size they are, recursion is a natu-
  
 ral choice for implementing many operations on lists. Here is a recursive function that 
  
 reverses the elements in a list:
  
 r e v [ s _ L i s t ] :=
  
 I f [  s = { } , 
  
 { } .
  
 A p p e n d [ r e v [R e s t [ s ] ] ,  F i r s t [ s ] ]
  
 ]
  
 r e v [ { l .  2 .  3 } ]
  
 ( 3 ,  2 , 
  
 1}
  
 The strategy of rev is this:
  
 1. If the list is empty (the base case), the result is another empty list. Otherwise...
  
 2. Form a sublist consisting of the original list minus the first element.",NA
5.5 Manipulating Normal Expressions,"Up to this point we have restricted our application of functional programming 
 opera-tions to lists. Now we take into consideration the structure of general 
 Mathematica 
 expressions — of which lists are merely a special case — and show how functional 
 operations can be used on them.
  
   
 Recall that expressions can be either atomic (symbols, numbers, strings) or non- 
 atomic. The general structure of a nonatomic, or 
 normal,
  expression is 
 head [ p a rti, 
 . . . 
 .  
 p a rtn
 ], where the head and each of the parts are other expressions. We can use the 
 FullForm function to explore the internal representation of various expressions. 
  
 For example,
  
 FullForm[a + b]
  
 Plus[a, b]
  
 A list is just a normal expression with the head L ist:
  
 FullForm[{a, b}]
  
 List[a, b]
  
 Since lists are represented internally just as any other expressions are, and since there 
 are many functions for operating on lists, you might suspect that you can use these 
 functions on more general expressions as well. In fact, almost anything you can do to a 
 list you also can do to an arbitrary expression, which is a very powerful capability. In 
 the remainder of this section we will highlight this capability.",NA
5.5.1 Subscripting expressions,"One particular list operation that can be applied to any expression is subscripting. This 
 concept is important enough that it deserves special treatment.",NA
5.5.2 Levels in expressions,"Levels in arbitrary expressions are counted just as they are in lists, of course. However, 
 there are some finer points about levels that we have neglected until now because they 
 aren’t very interesting when all of the heads in an expression are L ist. In particular, we 
 need to discuss how heads are treated with regard to level specification.
  
  
 You might have noticed by now that heads seem to be ignored by level 
 specifica­tions! For example, here are “all” of the subexpressions in the expression a/b:
  
 W here are the symbols 
 Times and Power? 
  
 L e v e l [ a / b , 
  
 { 0 , 
 ,
  
 I n f i n i t y } ]
  
 Every function that takes a level specification (see Table 5-1 on page 106) also has an 
 option called Heads. The default value of this option for most of these functions is",NA
5.5.3 Functional operations on expressions ,"Here are some examples of applying functional operations to arbitrary expressions. 
 We’ll begin with Map.
  
 This wraps f  around each 
 argument to g.
  
 Level specifications work in the 
 usual way.
  
 H eads->True directs Map (and 
 its ilk) to operate on the head of 
 an expression as 
  
 well as its parts.
  
 The Heads options can be 
 combined with a level 
 spec-ification.
  
 Map[f, g[a, h[b]]] 
  
 g[f [a] , f 
 [h[b]]]
  
 Map [f, g [a, h [b] 
 ] ,
  
 {2}]
  
 gta, h[f[b]]] 
  
 Map[f, g[a, h[b]], Heads->True] 
 f [g] [f [a] , f [h[b]]]
  
 Map[f, g[a, h[b]]
  
 {2}, Heads->True]
  
 g[a, f[h] [f[b]]]
  
 11. One exception to this rale is Position, for which the default is Heads-
 >True. 
  
 Thus, Position will find a subexpression anywhere within an 
 expression.",NA
5.5.4 Miscellaneous list operations ,"As mentioned at the beginning of this section, nearly any list operation can be applied to 
 arbitrary expressions, as long as it makes sense to do so from a structural point of view. 
 Here are some examples.
  
 The only difference between 
 this expression and the list {a , 
 b , c , d j is its head 
 (Plus 
 versus 
 List).
  
 Thus you can use almost any 
 list operation on it.
  
 FullForm[a + b + c + d] 
 Plus[a, b, c, d]
  
 Drop[%, 1] 
  
 b + c + d
  
 Append[%, e] 
  
 b + c + d + e
  
 Take[%, {2. 3}] 
  
 c + d",NA
5.6 Additional Resources,NA,NA
5.6.1 Standard packages,"Examples of functional programming can be found in many of the standard packages. 
 In particular, S ta t is tic s ' DataM anipulation and LinearAlgebra'M atrixM a- n ip u la 
 tio n  rely heavily on these techniques.",NA
5.6.2 Publications,"[Wagon 91] is notable for its many elegant applications of functional programming 
 using 
 Mathematica.
  
 Readers interested in the theoretical aspects of functional programming may consult 
 [Henderson 80].
  
 12. Orderless (i.e., commutative) functions automatically sort their arguments. 
 Thus 
 Reverse [Plus [a, b]] =>Plus[b, a] => Plus [a, b].",NA
5.7 Appendix: ,NA,NA
Lisp-Mathematica,NA,NA
 Dictionary ,"For the benefit of experienced Lisp programmers, Table 5-4 draws analogies between 
 some common operations in Lisp and their closest 
 Mathematica
  equivalents.
  
 Table 5-4 
 Lisp-Mathematica
  Dictionary
  
 Lisp
  
 Mathematica
  
 Comments/Special Input Forms
  
 (a b c ...)
  
 {a, b, c, ... }
  
 a is not a function
  
 (f a b .. .)
  
 f[a, b, ...]
  
 f is a function
  
 apply
  
 Apply
  
 @@
  
 catch
  
 Catch
  
 cond
  
 Which
  
 #. &
  
 lambda
  
 Function
  
 let
  
 With
  
 /@
  
 mapcar
  
 Map
  
 quote
  
 Unevaluated
  
 : =
  
 reduce
  
 Fold
  
 setq
  
 SetDelayed
  
 throw
  
 Throw
  
 Lisp programmers should note that lists in 
 Mathematica
  are implemented using 
 arrays, not linked lists. Thus, some algorithms that might be efficient in Lisp are 
 extremely inefficient in 
 Mathematica.
  We’ll discuss performance issues in detail in 
 Chapter 10, “Performance Tuning.”",NA
6,NA,NA
Rule-Based ,NA,NA
Programming,"The programming paradigms that we have studied so far can all be categorized as 
 imperative programming,
  in which it is the programmer’s job to state, step by step, how 
 to carry out the solution to the problem. 
 Rule-based programming
  is fundamentally 
 dif-ferent from this. In the rule-based paradigm, the programmer simply writes down a 
 set of rules that specify what transformations should be applied to any expression that is 
 encountered during the course of solving the problem. The programmer need not specify 
 the order in which these rules are to be executed; the underlying 
 programming 
 system 
 figures that out.
  
 Rule-based programming is a very natural way to implement mathematical 
 computa-tion, since symbolic mathematics essentially consists of applying 
 transformation rules to expressions (e.g., differentiation rules, tables of integrals). 
 Mathematical
  versatile pattern-matching capability, which we have only begun to 
 explore, often makes rule- based programming the paradigm of choice for 
 Mathematica
  
 programmers.",NA
6.1 Patterns,NA,NA
6.1.1 What is a pattern?,"A 
 pattern
  is a 
 Mathematica
  expression that represents an entire class of expressions. The 
 simplest example of a pattern is a single Blank, _, which represents any expres-sion. 
 Another example is _ f, which represents any expression having f  as its head. We have 
 already used patterns like these as formal parameters in function definitions. We’ll 
 explore this use in greater detail in Section 6.2.
  
 Patterns also can be used by a variety of built-in functions to alter the structure of 
 expressions. For example, a replacement rule can have a pattern on its left-hand side.",NA
6.1.2 Destructuring,"A pattem can be constructed from any expression merely by substituting Blanks for 
 various subexpressions. (The name Blank is meant to connote the idea, “Fill in the 
 blank.”) Furthermore, any Blank can be given a name and used as a pattem variable.
  
 The pattern variable x 
  
 f [ a ]  +  g [ b ] 
  
 / .  x _ [_ ] 
  
 ->  x
  
 matches the head of any
  
 f  +  g
  
 expression having a single
  
 part.
  
 Now  x matches the head of 
  
 f [ a ]  + 
  
 g [ b ] 
  
 / .  x _ [ _ ,  _ ] 
  
 - > 
  
 x
  
 any expression having 
  
 P lu s
  
 exactly two parts: In this
  
 particular example, that is 
 Plus [a, b].
  
 The technique of extracting parts of patterns using pattem variables is sometimes 
 called 
 destructuring.
  Destructuring combined with rule replacement is a very powerful 
 capability.
  
 This extreme example illus- 
  
 f [ a ]  + 
  
 g [b ] 
  
 / .  x _ [y _ ] 
  
 ->  y [ x ]
  
 trates that it's possible to do 
 just about anything with 
  
 a r f l  + h r o l
  
 ®
  
 destructuring.
  
 Practically speaking, destructuring and rule replacement are often easier than using 
 MapAt (see Section 5.1.4) to modify a subexpression, and it is almost always easier to 
 understand at a glance what a destructuring operation is doing, as opposed to what part 
 of an expression is referred to by a long sequence of subscripts. The only time you 
 would have to use subscripting instead of destructuring is when an expression contains 
 multiple subexpressions with the exact same structure, only one of which you wish to 
 extract or modify.
  
 Suppose we have a list of {x. y} data points that we wish to plot as a logplot.1 A 
 functional way to transform the data would be as follows:
  
 d a ta  =  { { x l ,  y l } , 
  
 { x 2 ,  y 2 } , 
  
 { x 3 , y 3 } , 
  
 { x 4 ,  y 4 } } ;
  
 1. For educative purposes, let us agree to ignore the fact that the Graphic s ' 
 Graph - 
  
 ic s' package contains a function to do logplots.",NA
6.1.3 Testing patterns,"There are two functions for testing patterns to see what kinds of expressions they will 
  
 match: MatchQ and Cases.
  
 The MatchQ predicate simply tests to see if a pattern matches an expression:
  
 M a tc h Q [a  +  b +  c , _ P lu s ]
  
 True
  
 A more sophisticated function is Cases, which picks out all expressions in a list that 
  
 match a given pattern. Cases is very useful for “debugging” your patterns.
  
 If you don't understand why the 
 pattern fails to match a+a, look 
 at its FullForm .
  
 C ases [ { a ,  a  +  b ,  a +  a }  , x _  +  y _ ] { a +  b }
  
 The second argument to Cases can be a rule, in which case the rule is applied to 
  
 each of the matched expressions before returning.
  
 C a s e s [ { a ,  a +  b ,  a + a } ,  x _  +  y _  - >  y]
  
 ( bl
  
 The head of the first argument to Cases need not be L ist. By default, Cases 
  
 searches only at level 1.",NA
6.1.4 The role of attributes,"Mathematica
  can be surprisingly intelligent about destructuring. Consider this example:
  
 Even though this expression 
  
 L e n g th  /@ {a  +  b +  c , x _  +  y _ }
  
 y }
  
 and this pattern have differ-
  
 { 3 , 
  
 2)
  
 ent structures ...
  
 the pattern nevertheless 
  
 a + b + 
 c 
 /. x_ + 
  
 y _  
 -> {x, 
  
 matches. 
  
 / _ l a , 
  
 ■u 
 d
 +  c ) _ i
  
 The reason that the pattern matched is that 
 Mathematica
  knows that Plus is an 
 asso-ciative operator, i.e., a + b + c =  a +  (b + c ). This knowledge is encoded into the 
 attributes of the Plus function:
  
 The F la t  attribute means 
  
 A ttributes [Plus]
  
 that P lus is associative. 
  
 { F l a t ,  L i s t a b l e ,  N u m e ric F u n c tio n , O n e ld e n t it y .
  
 O r d e r le s s , P r o te c te d }
  
 We’ve already seen L istab le. F la t means that Plus is associative, as we saw above. O 
 neldentity means that Plus [x] =  x. O rderless means that Plus is commuta-",NA
6.1.5 Functions that use patterns,"We have already used some functions that can take patterns as arguments, although we 
 didn’t know it at the time. The second argument to the Count and P o sitio n  functions 
 is actually a pattem. So, for example,
  
 Count[{a, a + b, a + b + c ,  a + a } ( x _ +  y_]
  
 2
  
 Position[{a, a + b ,  a + b + c .  a + a } ,  x _ +  y_]
  
 { { 2 } , 
  
 ( 3 ) }
  
 2. See Section 6.5, “Overriding Built-in Functions.”",NA
6.2 Rules and Functions,"We’ll see in this section that there is an intimate connection between rules and 
 func-tions. Before proceeding, however, we need to introduce a new type of rule.",NA
6.2.1 Delayed rules,"Just as there are two types of assignment operations, Set and SetDelayed, so there are 
 two types of rules: Rule and RuleDelayed. The difference between the two forms is that 
 the right-hand side of a RuleDelayed is not evaluated until 
 after
  the pattern variables 
 have been substituted. Delayed rules can be specified using the syntax a : > b.
  
 As an example of when you would need this behavior, consider once again the prob-lem 
 of trying to cancel Sqrt [u - 1] from the following expression:
  
 e x p r =  S q r t [ u  -  l ] / S q r t [ u A2 -  1 ] ;
  
 We solved this problem in Section 5.5.3 by using MapAt to Factor the expression inside 
 the radical. As an alternative, we might use the following rule:
  
 All that remains to do is to 
  
 e x p r / .  u A2 -  1 -> 
  
 (u  -  1) 
  
 (u  +  1 )
  
 apply PowerExpand to this 
  
 S q r t [ - 1  +  u]
  
 r8SU^‘ 
  
 Sqrt[(-1 + u) (1 + u)]
  
 This rule is fine for this simple case, but in a more complicated case it would be a 
 burden to have to supply the factored form of the polynomial. In that case we might try 
 a rule of the following form:",NA
6.2.2 Function definitions are rules,"When you define a function in 
 Mathematica,
  you actually are defining a rule. The 
 rule(s) for a function 
 f
   can be displayed using DownValues [f ]:
  
 fact[n_Integer] := Times @@ Range[n] 
  
 DownValues[fact]
  
 {HoldPattern[fact[n_Integer]] :> Times @@ Range[n]}
  
 As you can see, this definition has created a delayed rule that represents what should 
 happen to expressions that match the pattern H oldPattern [fact [n_Integer] ]. H 
 oldPattern is a head that, like Hold, keeps its argument from evaluating.3 Unlike Hold, 
 however, H oldPattern is ignored for pattern-matching purposes. Hold-P attern  will be 
 discussed in greater detail in Section 7.2.5.
  
 3. Prior to version 3.0, HoldPattern was known as Literal. Users of 
 those ver-
  
 sions will see Literal everywhere this book shows HoldPattern.",NA
6.2.3 Multiple definitions for the same symbol,"Mathematica
  allows you to write multiple function definitions for the same symbol, to 
 cover (presumably) different cases; these definitions become separate mles. Here is a 
 recursive definition of fa c t in which we have defined the base case as a separate rule:
  
 Clear [fact] 
  
 fact[
 0
  ] = 
 1
  ; 
  
 fact[n_Integer] := n*fact[n - 
 1
  ]
  
 There are now two 
 rules for 
 fact- 
  
 DownValues [fact] 
  
 {HoldPattern[fact[0]] :> 1, 
  
 HoldPattern[fact[n_Integer]] :> n fact[n - 1]}
  
 Having multiple definitions for the same function might seem analogous to 
 over-loading
  in languages such as C++ [Stroustrup 91], but in fact it is much more 
 powerful. First of all, 
 Mathematica
  patterns can test for much more than just the “type” 
 of an argument; we’ll discuss the full generality of patterns in Section 6.3.
  
 Less obvious, but perhaps more important, is that the different alternatives do not 
 have to be disjoint: Note that zero is an integer, yet when the argument to the fa c t 
 function is zero, the rule for fa c t [0] is used rather than fa c t [_ In teg er]. This 
 illus-trates a general strategy of 
 Mathematica’s
  pattern-matching engine: 
 It always tries 
 to apply more specific rules before more general rules.
  DownValues [f] displays the 
 rules for f  in the order in which the kernel tries to apply them. You can also see the 
 order in which the rules for a symbol are applied by using 
 Isym.",NA
6.2.4 Advantages of rule-based function definition,"There are many advantages to implementing a function as a collection of rules rather 
 than as one monolithic piece of code.
  
 First, rule-based functions usually are faster than all-in-one function definitions, 
 because in many cases 
 Mathematical
  pattern-matching engine can evaluate alterna-tives 
 faster than explicit conditional statements (e.g., If, Switch) can.
  
 Second, using multiple rules to define functions is very natural for mathematicians. 
 For example, here is a definition of the absolute value function that parallels the way the 
 definition would be presented in a mathematics textbook:
  
 a b s v a l[x _ ] 
  
 :=  x 
  
 / ;  x  >= 0
  
 a b s v a l[x _ ] 
  
 :=  - x 
  
 / ;  x  < 0
  
 (The “/; ” construct will be discussed in Section 6.3.1, “Pattern constraints.”)
  
 4. Unlike logic programming languages such as Prolog [Clocksin & Mellish 84], 
 Mathematica
  does not implement 
 backtracking.
  This means that although the 
 ker-nel tries to guess the best order in which to apply rules, if it turns out to 
 have made a wrong choice, it makes no attempt to try some other order. 
 Maeder develops a Prolog-style backtracking interpreter in 
 Mathematica
  in 
 [Maeder 94b].",NA
6.2.5 Clearing definitions selectively,"Sometimes when you are developing a new function, you make a mistake and need to 
 redefine the function. Rather than doing a C lear [f ], which requires starting all over, 
 you can selectively clear a single definition using “f  [patt] 
  
 This operation is 
 called Unset.
  
 Here's a botched attempt to 
  
 fact[n_] := Gamma[n] 
 extend the definition of fac-
  
 torial to the real numbers 
  
 fact /@ {3.99, 4, 4.01} 
 (fa c t[n _ ] should evaluate
  
 to Gamma [n + 1]). 
  
 (5.92519, 24, 6.07593}
  
 W e attempt to redefine the 
  
 fact[m_] := Gamma[m + 1] 
 bad rule, but it seems to
  
 have no effect. 
  
 fact /@ {3.99, 4, 4.01}
  
 {5.92519, 24, 6.07593)
  
 The reason is that the old rule 
 for f a c t  [n_] is still 
  
 there, and it comes before the 
 new rule for f a c t  [m _].
  
 Tfact 
  
 Global'fact
  
 fact[0] = 1
  
 fact[n_Integer] := Apply[Times, Range[n]]",NA
"6.2.6 ""Pure"" rule-based programming","Rather than writing rules as function definitions, you can apply the rules to expressions 
 locally using ReplaceRepeated, essentially mimicking the operation of the kernel. For 
 example, here’s an alternative way to compute the factorial. Note that you 
 must 
 specify 
 the rules in the order shown, or else the rule for f  [0] will never be used!
  
 ReplaceRepeated contin- 
  
 f  [5 ] 
  
 / / . 
  
 { f [ 0 ] 
  
 :> 1,  f [ n _ ] 
  
 :>  n * f [ n  - 1 ] }
  
 ues to apply rules from the
  
 given rule set until the
  
 expression stops changing.
  
  
 In contrast to recursion, this technique does not build up a large evaluation stack, and 
 hence is not constrained by the $RecursionLimit “safety net.”
  
 T a b l e [ D e p t h [ T r a c e [ f a c t [ i ] ] ] , 
  
 { i , 
  
 1 0 } ]
  
 { 6 , 
  
 7, 
  
 8 , 
  
 9, 
  
 10, 
  
 11 , 
  
 12, 
  
 13, 
  
 1 4 , 
  
 15}
  
 T a b le [ D e p t h [ T r a c e [
  
 { 9 , 
  
 9, 
  
 f [ i ] 
  
 / / . 
  
 {i. 10}]
  
 { f [0] 
  
 : > 1,  f [ n _ ] 
  
 :>  n * f [ n  -  1 ] } ] ] ,
  
 9 , 
  
 9, 
  
 9, 
  
 9 , 
  
 9. 
  
 9, 
  
 9,  9}
  
 This may be seen as an advantage or a disadvantage, depending on the circumstances.
  
 ReplaceRepeated and its relatives scan lists of rules sequentially for pattem matches. For 
 long lists of rules, Replace-type operations may be sped up by using the",NA
6.3 Pattern Building Blocks,"Mathematica
  provides a rich set of building blocks for constructing patterns. We cannot 
 do more than provide a few examples of each here. You will come to really appreciate 
 what patterns can do as you read the remainder of this book and other 
 Mathematica
  
 lit-erature.",NA
6.3.1 Pattern constraints,"There are three constructs that can be used to constrain patterns. Two of them constrain 
 the values of individual Blanks, while the third one can be used to specify relationships 
 between different pattern variables.
  
 head
  
 As we saw in Section 4.1.3, “Type checking,” a Blank can be constrained to match only 
 those expressions with a particular head by appending the head to the Blank.
  
 This pattern matches only C ases [ { 1 ,  S q r t [ 2 ] ,  b } , _ In t e g e r ]
  
 integers. {
  y
  )
  
 _?test
  
 A Blank also can be constrained using the form 
 J lte s t,
  where 
 te s t
  can be any 
 function of a single argument. If the application of 
 t e s t
  to the expression that matches 
 the Blank returns True, then the pattern matches.
  
 Here's another way to write a 
 pattern that matches only
  
 C a s e s [ { l, S q r t [ 2 ] ,  b } , _ ? In te g e rQ ]
  
 integers.
  
 Note that, given the choice, it’s more efficient to match the head 
 structurally
  using 
 _In teg er than to use _? IntegerQ, so you probably wouldn’t use a test function in this 
 simple case. However, many predicates exist (see Section 3.4) that can test for more 
 complicated conditions, such as whether or not an expression is an atom (AtomQ) or a 
 number (NumberQ). And in addition to using the system-defined predicates, you can of 
 course define your own.
  
 Here's a pattern that 
  
 matches an expression only 
  
 if it is a number between 
 1 
 and 
 1 0
  .
  
 between [x_] := 1 <= x <= 10 
  
 Cases [Table [Random [Real, {1, 100}], {20}], 
 _?between]
  
 . 
  
 9 1 9 9 1
  
 9
  1 5 8 7 1 }
  
 You also can combine head matching with a test function.",NA
6.3.2 Patterns with default values,"A default value can be defined for a pattern by using the 
 p a tte r n : value
  construct. 
 This is a useful technique for providing optional arguments to functions.
  
 This function uses Horner's 
 rule (Section 5.3.3) to con- 
 vert base-b digits into a
  
 t o l n t e g e r  [ d i g i t s _ L i s t , b _ : 2 ] 
  
 : =
  
 F o ld [ b  # 1  +  # 2  &. 0 , d i g i t s ]
  
 base
 - 1 0
  integer.
  
 By default, the digits are 
  
 t o l n t e g e r  [ { 1 , 
  
 0 , 
  
 0 , 1 }]
  
 treated as base 
 2
  . 
  
 g
  
 0 , 
  
 0 , 1 } , 3]
  
 Other bases can be used by 
  
 t o l n t e g e r  [ { 1 , 
  
 supplying a second argu- 
  
 28
  
 ment.
  
 Note that when there is more than one pattern variable with a default value and there 
 are not enough parts in the expression to fill them all, 
 Mathematica
  will fill them in left- 
 to-right order. Using the Cases function with a rule as the second argument, we can see 
 what is being assigned to a pattern variable under different circumstances:
  
 b gets a value before c does. 
  
 C le a r  [ f ,  a , b , c]
  
 C a s e s [ { f [ x ,  y , z ] , f [ x ,  y ] , f [ x ] } ,
  
 f[a_, b_:2, c_:3] -> {a, b, c}]
  
 { { x , y , z ) , 
  
 ( x , y , 3 } , 
  
 { x , 
  
 2 , 3 } )
  
 Some functions have predefined default values for certain arguments. These pre-defined 
 defaults can be specified with a pattern of the form 
  
 . ”. For example, the 
 default value for an argument to the Plus function is 0. Therefore, the pattern “a_ + b_. ” 
 matches any of the following:
  
 Cases[{x, x + y}, a_ + b_. -> {a, b}]
  
 { { x , 
  
 0
  } , 
  
 { y , x } }
  
  
 You can see what the default values for a function are by evaluating Def aultV al - 
 ues 
 [name
 ] :",NA
6.3.3 Example: Writing a derivative function,"Although 
 Mathematica
  has a built-in differentiation function, writing one is a good way 
 to illustrate the use of destructuring, conditions, and default values, and also to show 
 how rule-based programming allows easy incremental enhancements to a function.
  
  
 We will make heavy use of the FreeQ predicate. FreeQ
 [expr, 
  
 form]
  returns 
 True if no subexpression in 
 expr
  matches 
 form
  (which can be a pattern). 
 Mathemati-cally speaking, FreeQ 
 [expr, var]
  means that 
 expr
  does not depend on the 
 variable 
 var.
  
  
 Here are the basic rules for differentiation. The first two embody the fact that 
 differ-entiation is a linear operator:
  
 d if f [ c _  * f_ , x_] /;  FreeQ[c, x] := c * d i f f [ f , x] d i f f [ f _  
 + 
 g_,
 x_] := d i f f [ f ,  x] + d if f [ g , x]
  
 Using no more than these two rules, d if f  can rewrite derivatives of linear expressions 
 in terms of the derivatives of the parts that involve the variable x.
  
 d i f f [3 x A2 - 2 x + 1, x]
  
 diff[l, x] 
 -  2 
 diff[x, x] 
 +  3 
 diff[x2, 
  
 x]
  
 We continue to add rules for d iff, with each new rule building upon and enhancing the 
 functionality of the previous ones. The derivative of a constant is 0:
  
 d if f [ c _ , x_] /;  FreeQ[c, x] := 0",NA
6.3.4 Patterns that match more than one expression,"There are two patterns that can be used to match sequences of expressions:
 __
  (a double 
 Blank, called BlankSequence) and 
 ___
  (triple Blank, called BlankNullSe-quence). The 
 double Blank matches a sequence (comma-separated) of one or more expressions, and 
 the triple Blank matches a sequence of zero or more expressions. (A sequence of zero 
 length is equivalent to Null.)
  
 The triple Blank matches 
 everything the double 
  
 Blank does, plus Null. 
  
 Clear [f] 
  
 C a s e s [{ f[], 
 Cases 
 [ t f [ ] , 
  
 f  [1] , f  [1. 2 ]} , f  
 [1] . f [ l ,  2 ]} . 
  
 f  
 \ 
  
 11
  
 f [ ____]]
  
 {f [1] , f 
 [1. 
  
 2] }
  
 (f[] . f[l]. f[l. 2]}
  
  
 When qualified with a head test or predicate test, all of the expressions in a sequence 
 must satisfy the test in order for the pattern to match.
  
 __Integer matches a 
  
 sequence of one or more 
 integers, but not a mixture of 
 integers and other types.
  
 Cases [ { f [ l ,  2, 3 ], f [ l ,  a, 3 ]} , f [
  __
 Integer]]
  
 {f[l 
  
 2 
 ’
  
 3]}
  
 Probably the most common use for Blank sequences is destructuring lists of unknown 
 lengths. This capability makes functions and rules that operate on lists much more 
 compact and easy to write. For example, here’s a reimplementation of the rev function 
 of Section 5.4.2 that uses destructuring:",NA
6.3.5 Application: Functions with options,"A very common reason to have a variable number of arguments in a 
 Mathematica
  
 func-tion is to implement 
 options.
  Options are named arguments of the form 
 name-
 >value 
 or 
 name
 : 
 >value
  that follow the positional arguments in a function call.
  
 The predicate OptionQ is available to test an expression to see if it is an option or a 
 list of options. Since there may be zero or more options in a function call, the pattern 
 ___
 ? OptionQ is exactly the right tool for the job. For example, here is how one could 
 declare a function that has one positional parameter and an arbitrary number of options:
  
 f[argl_, opts___?OptionQ] := ...
  
 Here are the kinds of expressions that are matched by the pattern variable opts:
  
 Cases[{f[x], f[x, a->b], f[x, a:>b, c->d] , 
  
  
 f[x, {a->b, c->d}, e->f]}, 
  
 f[argl_, opts___?OptionQ]->{opts}]
  
 {{}, {a -> b), (a :> b, c -> d).
  
 {{a -> b, c -> d), e -> f )}
  
 The use of rules for specifying options makes it quite easy to extract the values 
 car-ried by the options. The sequence of options is wrapped in a list and then used on the 
 right-hand side of a ReplaceAll operator (“/ .  ”). However, a bit of care must be 
 exer-cised because of the possible presence of nested lists in {opts}. For example,
  
 The last value of 
 {opts} 
 in 
 the 
 previous 
 example 
 can't 
 be 
 used 
 directly. 
  
 {a, c, e} /. Last[%] 
  
 RepiaceAll: : rmlx: 
  
 Elements of {{a -> b, c -> d). e -> f}
  
 are a mixture of lists and non-lists.
  
 (a, c, e) /. {{a -> b, c -> d}. e -> f]
  
 Simply Flatten 
 [{opts}] 
 before passing it 
 to 
  
 R e p la c e A ll. The values of 
 the options are extracted.
  
 {a, c, e} /. Flatten [Last [%%] 
 ] {b, d, f)
  
 Another possible fly in the ointment arises in the case of missing options — options 
 are, after all, optional! To handle this possibility, simply follow the initial replacement 
 with another set of options that carry the default values for each possible optional 
 parameter. For example,
  
 The user specifies only one of 
 two possible options. 
  
 The default value for the 
  
 unspecified option is substi- 
 tuted 
 afterward.
  
 {namel, name2} /. {namel->valuel} 
 {
 valu 
 e l. name2
 }
  
 % / .  
 {namel->defaultl, name2->default2} 
 {v a i u e 
 i , d e f
 ault2
  }",NA
6.3.6 Assigning names to entire patterns,"The construct 
 n
  : 
 p
  assigns the name 
 n
  to the entire pattern 
 p.
  What makes this different 
 from a construct such as 
 n_
  is that 
 p
  can be an arbitrarily complicated pattern. For 
 example, the pattern n :{
 ___
 Integer} matches the same class of expressions as n_ /; 
 VectorQ [n, IntegerQ] or n_? (VectorQ [#, IntegerQ] &) — namely, a list of zero or 
 more integers — but is faster 
 and
  easier to understand.",NA
6.3.7 Repeated patterns,"The construct “p .. ” indicates one or more repetitions of the pattem p. The construct “p . 
 . .  ” indicates 0 or more repetitions of p. We’ll illustrate the use of the former with a 
 function that performs a form of data compression known as 
 run-length encoding.",NA
6.3.8 Alternative patterns,"You can specify a pattern that matches one or more alternatives by separating the 
 alter-natives with the vertical bar “ | ”:
  
 Here's a pattern that 
 matches either a or b. 
  
 { a ,  b ,  c l  / .  a | b - >  d
  
 j ^ 
  
 ^ 
  
 c j
  
 If the rule’s right-hand side contains a pattern variable, it must appear on both sides of 
 the vertical bar.
  
 { L o g [ 2 ] , 4 . 5 ,  2 + 3 1 }  / .  x _ In t e g e r  | x _ R e a l ->  S q r t [ x ]
  
 (LoS [2], 2.12132, 2 + 3 1 }
  
 You can see that if the same pattern variable did not occur in both alternatives in the 
 second example, there would be no way to write the right-hand side of the rule 
 cor-rectly.
  
 Alternatives and repeated patterns can be combined to write a pattern that matches a 
 sequence of any number of elements, each of which matches one of a set of alterna-tives. 
 For example, here is how one could write a pattern that matches a list 
 containing 
 only 
 integers or symbols:
  
 C ases [ { { 1 ,  2 } , 
  
 { 3 , a } , 
  
 { b . 4 , c } , 
  
 { d , 2 . 5 } } ,
  
 {(_Integer | _Symbol)...}]
  
 {{1, 2}, {3, al, {b, 4, cl}",NA
6.4 Dynamic Programming,"Certain problems have recursive solutions that are very natural but also are very 
 ineffi-cient. The reason for this inefficiency is that many identical recursive calls are 
 made during any given computation. This property, called 
 overlapping subproblems,
  is 
 char-acteristic of many important problems. The most well-known examples are discrete 
 optimization problems such as the 0-1 knapsack problem, optimal matrix-chain 
 multi-plication, finding the longest common subsequence of two sequences, and the 
 Floyd- Warshall algorithm for finding shortest paths in a graph (see [Cormen et al. 90]). 
 Other, non-optimization examples include convolution and multiple-class mean value 
 analysis of queuing networks (see [Jain 91]).
  
 Problems having the overlapping-subproblems property almost always are solved 
 using 
 dynamic programming
  [Cormen et al. 90], a catch-all term for any algorithm in 
 which the definition of a function is extended as the computation proceeds. This is 
 gen­erally accomplished by constructing a solution “bottom up” (e.g., progressing from 
 simpler to more complex cases), the goal being to solve each subproblem 
 before
  it is 
 needed by any other subproblem. The main disadvantage of dynamic programming is 
 that it is often nontrivial to write code that evaluates the subproblems in the most 
 effi-cient order.
  
 However, there is an elegant dynamic programming technique that does not require 
 the programmer to establish the evaluation order: recursion with 
 result caching
  
 [some-times called 
 memoization (sic)
  in the computer science literature]. By caching the 
 results of all recursive calls, the second and subsequent evaluations of any subproblem 
 become constant-time operations, reducing the overall running time considerably. The 
 ability to add rules to a function as the function executes makes result caching very easy 
 to implement in 
 Mathematica.
  
 In this section we will solve two problems having the overlapping-subproblems 
 property. The first of these, the computation of Fibonacci numbers, is a “toy” problem 
 that we use merely to illustrate the concepts. The second problem we will consider is 
 finding 
 the optimal multiplication order for a chain of matrix multiplications, a problem 
 having considerable practical significance. For an example of using this technique to 
 implement multiple-class mean value analysis see [Wagner 95].",NA
6.4.1 Fibonacci numbers ,"Consider the following function that generates the well-known 
 Fibonacci numbers: 
  
  
  
 fib[n_] := fib[n - 
 1
  ] + fib[n 
 -  
 2
 ] 
  
  
  
 fib [
 0
  ] = fib [
 1
  ] = 
 1
  :
  
 Here are the first eight
  
 Array[fib, 
 8
  
 ]
  
 8
  ,
  
 13, 21, 34}
  
 Fibonacci numbers.
  
 { 1 . 2 , 3 , 5 , 
  
 Unfortunately, the time required to calculate f  ib  [n] is exponential in 
 n: 
  
 t = Table[Timing[fib[n]][[1. 1]], {n, 1, 16}]; 
  
 ListPlot[t. PlotJoined->True, 
  
  
   
  
 PlotLabel->""Timings for fib[n]"", 
  
  
  
 Frame->True, FrameLabel->{""n"". ""Seconds""}.
  
 FrameTicks->{Range[0, 16, 2], Automatic}, 
 DefaultFont->{""Times"", 9} 
  
 ]; 
  
  
  
 Timings for fib[n]
  
 ra 
  
 TJ
 a
 o
 v 
  
 <D
 C
 O
  
 A look at the execution trace of fib  reveals the source of the inefficiency:
  
 The second argument to 
  
 T race tells it to print only those 
 intermediate expres-sions that 
 match the pattern
  
 Trace [fib [4] , fib [_] ] 
  
 {fib 
 [4], 
 {fib 
 [3], 
 {fib 
 [2], 
 {fib[l]}> {fib[0]}}> 
  
  
 {fib [1] }}, (fib [2], {fib [1] }, {fib [0] }}}
  
 f i b  [ _ ] .
  
 In this small example, fib  [3] is evaluated once, fib  [2] is evaluated twice (once dur-ing 
 the call to fib  [4] and once during the call to fib  [3]), fib  [1] is evaluated three times, 
 and fib  [0] is evaluated twice. In fact, the number of times fib  [1] is called during the 
 evaluation of fib  [n] is equal to fib  [n-1]:
  
 This counts the number of 
 times f i b  [
  1
  ] occurs in the list 
 returned by T ra c e
  .5
  
 Table[Count[Flatten[Trace[fib[i], fib[_]]]. 
  
  
 HoldForm[fib[1]]], 
  
 {i, 
 1
  , 
 1 2
  } 
  
 ]
  
 {1, 1, 2, 3, 5. 
 8
  , 13, 21, 34, 55, 89, 144}",NA
6.4.2 Application: Matrix-chain multiplication,"The 
 matrix-chain multiplication
  problem can be stated as follows: Given a chain (i.e., a 
 sequence) of matrices whose dot product we wish to compute, parenthesize the chain so 
 as to force the pairwise dot products to occur in an order that minimizes the number of 
 scalar multiplications performed. Our presentation of this problem is modeled after 
 [Cormen et al. 90] Section 16.1, and we quote results freely from that source. Readers 
 interested in all of the details should consult [Cormen et al. 90].
  
 The total number of scalar multiplications necessary to carry out a matrix-chain 
 product can vary dramatically based on the parenthesization of the chain. Here’s an 
 example that shows how important the choice of parenthesization can be:
  
 7. “For all intents and purposes” means about 108 years, give or take an 
 order of 
  
 magnitude.",NA
6.5 Overriding Built-in Functions,NA,NA
6.5.1 Protected symbols,"Sometimes you want to override the behavior of one of the built-in functions. For 
 example, suppose you have defined your own logarithm function, and you want it to 
 have the property that log [a b] factors to log [a] + log [b]. If you try to modify the F 
 actor function, you’re in for a rude surprise.
  
 Factor[log[x_ y_]] := log[x] + log[y]
  
 SetDelayed::write: 
  
 Tag Factor in Factor[log[(x_) (y_)]] is Protected.
  
 $Failed
  
  
 Most of the built-in symbols, such as Factor, have the attribute Protected, which 
 prevents them from being modified inadvertently.
  
 Attributes[Factor]
  
 {Listable, Protected}
  
 However, if you are resolute in your desire to add this rule to F acto r’s repertoire, you 
 can remove the P ro tected  attribute and press onward.",NA
6.5.2 Upvalues,"As an alternative to modifying a protected symbol, you can associate a rule for that 
 symbol with certain other symbols that appear in the rule definition.
  
 Before continuing, w e have 
  
 U n p r o te c t [F a c to r ] ;
  
 A : = l o g [ x ]  + l o g [ y ]
  
 to remove any definitions 
  
 C le a r  [F a c to r ]
  
 w e have added to the Fac- t o r  
 symbol.
  
 P r o t e c t  [F a c to r ] ;
  
 This rule for factoring a log 
  
 F a c t o r  [ lo g  [x _ * y _ ] ] 
  
 is not associated with F ac-
  
 D o w nV alu es [F a c to r ]
  
 t o r - 
  
 {}
  
 Rather, it is associated with 
  
 ? lo g
  
 the symbol lo g . 
  
 G lo b a l'lo g
  
 Factor[log[(x_)*(y_)]] A:= log[x] + log[y]
  
  
 The funny assignment operator A: = is called UpSetDelayed.11 The example rule is 
 not a downvalue for log, it is a new kind of rule called an 
 upvalue
 :
  
 {DownValues[log], Upvalues[log]}
  
 {{}, {HoldPattern[Factor[log[(x_) (y_)]]] :>
  
 log[x] + log[y])}
  
 The names are meant to reflect where in the definition a symbol is. If it’s the head of the 
 expression, it is “looking down” into the expression; if it’s nested within the expression, 
 it’s “looking up” out of the expression.
  
 The new definition works just 
 like a DownValue for 
 Factor. 
  
 F a c t o r  [ lo g  [ (x  +  2 ) (x  -  5 ) ] ]
  
 1 
  
 r 
  
 & 
  
 }
  
 x 
  
 5
  
 r 
  
 } 
  
 J
  
  
 Another way to define an upvalue is to use the TagSetDelayed12 (/: ... : =) opera-tor:
  
 This is equivalent to the 
  
 lo g  / :  F a c t o r  [ lo g  [x _ * y _ ] ] 
  
 :=  lo g  [x ] +  lo g [ y ]
  
 above use of UpSet-
  
 D elayed.
  
 11. Naturally, there is a corresponding operator UpSet (A=) that evaluates the right-
 hand side of the definition before performing the assignment. Except for that 
 differ-ence, everything we have to say about one applies to the other. To keep 
 things sim­ple, we’ll use UpSet as a generic term.
  
 12. Likewise, there is a TagSet ( / : ... =) operator; similar comments apply as 
 for 
  
 UpSet.",NA
6.5.3 Application: A default thickness for Plot,"A question arose in the Internet newsgroup com p.soft-sys.m ath.m athem atica 
 concerning how one could change the default thickness of the lines used by the P lot 
 command. One might suppose that the answer is simply to set the default option for P lo 
 tS ty le using SetO ptions [P lo tS ty le, P lo tS ty le -> Thickness [n] ]. Unfortunately, 
 this will not work if the user specifies an explicit P lo tS ty le option in a call to P lot, 
 even if that P lo tS ty le does not specify a Thickness (e.g., P lo t[f[x ], {x, a, b }, P lo tS 
 ty le -> RGBColor[l, 0, 0]). No specific option for plot thickness exists, and no global 
 variable exists for this purpose either (e.g., as $Def aultF ont does for plot fonts).
  
 It’s possible to solve this problem by adding a few new rules to the P lo t command, but 
 getting it right is tricky. One must realize that:
  
 (a) P lo tS ty le may be a single graphics directive, or it may be a list.
  
 (b) If P lo tS ty le is a list, its elements may themselves be either single graphics 
  
 directives or lists of such.",NA
s ,"s
  
 s
  
 s
  
 s
  
 s '
  
 .
  
 1
  
 0.5
  
 0.25
  
 . 
  
 0.5 
  
 ^6^25
  
 ^  ^  -0.5
  
 But look at what happens if 
 the default PlotStyle is 
 Automatic.
  
 ^ 
  
 -0.75
  
 SetOptions[Plot, PlotStyle->Automatic] 
 Plot[Sin[x], {x, -1, 1}];
  
 Graphics;:gprim: 
  
 Unknown Graphics primitive Automatic encountered.
  
 What went wrong? Our last rule inserted the PlotStyle->A utom atic option in this 
 plot command, and since the right-hand-side of this rule does not contain Thick-ness, 
 another one of our rules appended the Thickness directive to Automatic. The net result 
 was P lotS tyle->  {Automatic, Thickness [. 01] }, which gave rise to the error message. 
 What we need is for the Thickness directive to 
 replace
  the word Automatic. It should be 
 easy to fix:
  
 This rule traps the problem-atic 
 case.
  
 Plot [heads___, PlotStyle->Automatic, tails
 ___
  ] : = 
 Plot[heads, 
  
  
 PlotStyle->Thickness[$DefaultThickness], tails]",NA
6.6 Additional Resources,"Almost every book about 
 Mathematica
  is replete with 
 programming 
 examples, and some 
 books are dedicated entirely to the subject. Two that stand out for their technical depth 
 are by Maeder ([Maeder 91], [Maeder 94a]). Neither one is recommended for beginners, 
 although readers of this book ought to be able to tackle them after 
 finishing 
 this chapter.
  
  
 Another book devoted entirely to 
 Mathematica
  programming, but at the level of an 
 introductory text, is [Gaylord et al. 93].
  
  
 [Gray 94] contains several nontrivial examples of using rule-based 
 programming 
 to 
 implement knowledge bases.",NA
7,NA,NA
Expression Evaluation,"The most 
 important 
 function of the 
 Mathematica
  kernel is to evaluate expressions to 
 produce new expressions. We already know what expressions are, but what, exactly, 
 does it mean to 
 evaluate
  an expression? Until now we have been content with the 
 some­what vague and definitely oversimplified description, “The kernel applies rules to 
 the expression until the expression stops changing.” However, the evaluation process is 
 much deeper than this. Aside from the fact that there are six different kinds of rules, 
 there also are a number of 
 attributes
  that affect the evaluation process, as well as an 
 assortment of symbols that receive special treatment. A thorough comprehension of 
 expression evaluation will greatly increase your abilities as a 
 Mathematica
  
 program-mer, and furthermore will enable you to understand the occasional unexpected 
 result that most 
 Mathematica
  users find inscrutable.
  
 Section 7.1, “The Evaluation Process,” is a description of the evaluation process in 
 all its generality. Toward the end of that section some special cases that are not widely 
 understood will be examined in greater detail. Section 7.2, “Nonstandard Evaluation,” 
 focuses on the aspects of the evaluation process that are exceptions to the general rule of 
 evaluating all parts of an expression completely. Section 7.3, “Working with Held 
 Expressions,” puts the knowledge gained in Section 7.2 to practical use.",NA
7.1 The Evaluation Process,NA,NA
7.1.1 Rules are associated with symbols,"Every value or function definition entered into a 
 Mathematica
  session is stored as a 
 glo-bal rule,
  that is, a rule that is matched against every expression encountered by the 
 ker-nel. For example, a definition like this one:
  
 a :=  b +  c",NA
7.1.2 ,NA,NA
Properties that affect the evaluation process,"The evaluation process is affected in certain ways by properties that are associated with 
 symbols. The properties that can affect the evaluation of an expression with head sym 
 are A ttrib u te s [sym] and D efaultValues [sym]. Default values (Section 6.3.2) are 
 used in pattern matching, and will not be discussed here. The different kinds of 
 attributes are listed in Table 7-2. Many of these will be discussed throughout this 
 chapter.
  
 Table 7-2 Attributes
  
 Attribute
  
 Meaning
  
 Example Symbols
  
 Constant
  
 All derivatives are 0
  
 E, GoldenRatio, Pi
  
 Flat
  
 Associativity
  
 And, Dot, Join, Max, 
 Plus
  
 HoldAll
  
 All arguments are unevaluated
  
 And, Clear, If, Plot, 
 While,
  
 HoldAllComplete
  
 No modification of any kind 
 to any
  
 Protect, SetDelayed
  
 BoxForm, HoldComplete,
  
 HoldFirst
  
 argument
  
 Unevaluated
  
 First argument is unevaluated
  
 AppendTo, Increment, Set
  
 HoldRest
  
 All but first argument are 
 unevaluated
  
 RuleDelayed, Save
  
 Listable
  
 Automatically threaded over 
 lists
  
 All numerical functions
  
 Locked
  
 Attributes cannot be changed
  
 $Aborted, I, List, 
 Symbol,
  
 NHoldAlla
  
 Arguments are unaffected by N
  
 True, False
  
 Root
  
 NHoldFirst®
  
 First argument is unaffected 
 by N
  
 EllipticTheta, PolyGamma
  
 NHoldResta
  
 All but first argument are 
 unaffected
  
 None
  
 NumericFunction
  
 by N
  
 All numerical functions
  
 f [__?NumericQ] is numeric
  
 Oneldentity
  
 f [a], f [f [a] ], etc. are 
 equivalent to
  
 And, Dot, Join, Max, 
 Plus
  
 Orderless
  
 a for purposes of pattern 
 matching
  
 And, Max, Plus
  
 Commutativity",NA
7.1.3 The main evaluation loop,"The main evaluation loop executed by the 
 Mathematica
  kernel is summarized below. 
 Most of this information is from [Withoff 93], with some explanatory comments and 
 version 3.0-specific features added by the author. Although this summary is rather dry, 
 the entire remainder of this chapter is devoted to explaining the nuances of the 
 algorithm.
  
 The first few steps of the evaluation process deal with atomic expressions:",NA
7.1.4 Observations,"A solid understanding of the evaluation process is one of the crucial characteristics that 
 separates casual 
 Mathematica
  programmers from 
 power programmers.
  This 
 under-standing, combined with judicious use of Trace (discussed in detail in Chapter 13, 
 “Debugging), FullForm, Hold, and related functions, makes it possible to figure out 
 about 99.99 percent of the mystifying results that the kernel occasionally produces.2
  
 In this section we’ll give some examples of less obvious consequences of the 
 algo-rithm outlined in the previous section. Along the way, it is hoped that you will have 
 an
  
 2. For the remaining 0.01 percent, contact WRI technical support. You may have 
 found 
  
 a bug!",NA
7.2 Nonstandard Evaluation,"Normally, the head and the parts of an expression are evaluated before any mles are 
 applied to that expression; this is called 
 standard,
  evaluation. However, certain 
 attributes and heads affect this process by preventing or forcing the evaluation of cer-",NA
7.2.1 The Hold- attributes,"The attributes H oldFirst, HoldRest, and HoldAll were first introduced in Section 4.4, 
 “Parameter-Passing Semantics.” Basically, these attributes prevent the evaluation of the 
 first, all but the first, or all of the arguments to a function. For exam-ple, here is how you 
 could write a function that increments the value stored in a symbol:
  
 S e t A t t r i b u t e s [ i n c , H o l d F i r s t ] ;
  
 This call is equivalent 
 to
  
 in c [x _ S y m b o l] 
  
 :=  x  =  x  +  1
  
 y  =  7 ;
  
 y = y + 1.
  
 in c  [y ] ;
  
 y
  
 8
  
 Note that if inc didn’t hold its argument, y would evaluate to 7 before the evaluation of 
 the function, resulting in the nonsensical expression 7 = 7 + 1.
  
 One might well wonder how it is possible for an expression like x = x + 1 to turn into 
 y = y + 1 without evaluating x and, in the process of doing so, y. This brings up a subtle 
 point that is worth stressing: Pattern variables like x do not 
 evaluate,
  in the technical 
 sense, to the values matched by them. When a rule is matched (and as we saw in Section 
 7.1.1, a function definition is just a special kind of rule), 
 Mathematica textu-ally 
 substitutes
  the values that are matched by the pattern variables into the correspond-ing 
 placeholder symbols (i.e., x in the example above) in the body of the rule. If a function 
 evaluates its arguments, the arguments evaluate before the substitution is per-
  
 3. Version 3.0 only.
  
 4. In versions prior to 3.0, HoldPattern was called L iteral. Note that L iteral is 
 still supported in version 3.0 as well.",NA
7.2.2 Evaluate,"E valuate is a head that can be used to force an argument to a function to evaluate, even 
 if that argument is in a held position. It frequently is applied to arguments of numeric 
 functions that normally hold their arguments, to allow useful symbolic simpli-fications 
 to take place prior to numerical evaluation.
  
 For example, the P lo t command does not evaluate its arguments. This is done under 
 the assumption that evaluating the arguments symbolically might not be a correct thing 
 to do (for example, if the argument to be plotted contained conditional execution 
 con-structs such as If). Instead, the expression to be plotted is evaluated numerically for 
 each plot point chosen by P lot. Sometimes this strategy backfires, however: It is easy to 
 construct cases in which it is more efficient to evaluate the expression before plot-ting, 
 rather than every time a value is plugged in. Here’s an example of the time taken to 
 compute, but not render, a plot of the function given by the first 20 terms of the 
 expo-nential expansion:
  
 The D is p la y F u n c tio n -
 > Id e n t it y  option sup-
  
 presses rendering of the 
 image.
  
 P lo t[S u m [x Ak / k ! . 
  
 { k , 
  
 1 , 2 0 } ] , 
  
 { x , 0 . 
  
 1 } ,
  
 D is p la y F u n c t io n - > Id e n t it y ] 
  
 I I
   T im in g
  
 {1. Second, -Graphics-}
  
  
 The 
 computation 
 can be sped up tremendously by telling the kernel that the first 
 argument 
 should
  be evaluated.
  
 Plot[Evaluate[Sum
 [xAk /k !, {k, 1, 20}]], {x, 0, 1}, 
  
 DisplayFunction->Identity] 
 II
  Timing
  
 {0.0666667 Second, -Graphics-}
  
 In the first case, the Sum expression evaluates to l + x + xA2/2 + . . .  every time P lo t 
 attempts to numerically evaluate it. In the second case, the symbolic transforma-tion 
 occurs only once, before P lo t begins its work.
  
 Another common use of Evaluate with P lo t involves plotting a table of functions. 
 That example is covered by many different authors (including 
 The Mathematica 
 Book,
 §1.9.1) and so it will not be repeated here.
  
  
 For a rather unorthodox use of Evaluate, we can force the left-hand side of a Set 
 operation to evaluate to simulate “pointer dereferencing”:
  
 a behaves as a ""pointer"" to 
 b.
  
 Clear[a, b] 
  
 a = b ; Evaluate[a] = 2; 
  
 {OwnValues[a], OwnValues[b]}
  
 {{HoldPattern[a] :> 
 b}, 
 (HoldPattern
 [b] 
 :> 
 2}}
  
 Don’t try to carry this analogy too far, though! It’s very difficult to implement true 
 pointer semantics in 
 Mathematica
  because we can’t make expressions evaluate only 
 part
  
 of the way. A slight modification to the previous example demonstrates the diffi-culty:",NA
"7.2.3 Hold, HoldForm, and HoldComplete","Hold and HoldForm are wrappers that prevent expressions from evaluating. There’s 
 nothing very special about them; they simply are symbols that have the HoldAll 
 attribute. The only difference between them is that, in standard output format, the head 
 HoldForm does not appear.
  
 The HoldForm head ""van- 
 ishes,"" leaving an impossi- 
 ble-looking result.
  
 The head is still there, how- 
  
 ever- 
  
 { H o l d [ l  +  1 ] ,  H o ld F o rm  [1 +  1 ] }
  
 { 
  
 l d [ 
  
 j 
  
 ,
  
 In p u tF o rm  [%] 
  
 (Hold [1 + 1], HoldForm [1 + 
 1])
  
 HoldForm is used by the Trace function, for example, in order to return partially 
 evaluated expressions without undesirable visual clutter. Every element of a trace is 
 wrapped in HoldForm:
  
 Trace[1 + 2 * 3 ]  // InputForm
  
 {(HoldForm[2 * 3], HoldForm[6]}, HoldForm[l + 6]. 
 HoldForm[7]}
  
 Note that arguments to Hold or HoldForm that have the head Evaluate will still get 
 evaluated. Not so with HoldComplete, which is analogous to Hold except that it has the 
 HoldAllComplete attribute:
  
 HoldComplete[Evaluate[1 + 1], Sequence[a, b]]
  
 HoldComplete[Evaluate[1 + 1], Sequence[a, b]]
  
 There are sneaky ways to cause evaluation of the parts of an expression with a Hold 
 or HoldForm head (or any head having the HoldAll, H oldFirst, or HoldRest attribute). 
 Like any other expression, these expressions are checked not only for down-values, but 
 also for upvalues! That makes bizarre behavior like the following possible:",NA
7.2.4 Unevaluated,"Unevaluated is a special head that can be wrapped around an argument to any func-tion 
 to prevent the evaluation of that argument before the function is called. The beauty of 
 Unevaluated is that it is invisible to the function being called — it makes the func-tion 
 temporarily behave as though it had one of the Hold- attributes.
  
 x  is a symbol that evaluates 
  
 Head does not hold its argu- 
  
 ment, so Head [x] returns
  
 Head [7].
  
 U n evalu ated  allows us to 
  
 get the head of x. 
  
 x  =  7 ;
  
 Head [x]
  
 Integer
  
 H ead [U n e v a lu a te d  [x ] ]
  
 Sym bol
  
 Unevaluated may seem similar to Hold, but there is an important difference: Hold (or 
 HoldForm) is visible to the function being called.
  
 H e a d [ H o ld [ x ] ]
  
 H o ld
  
 As we can see from steps 7 and 16 of the main evaluation loop (Section 7.1.3), the 
 special behavior of Unevaluated is accomplished by removing the head Unevalu-ated 
 from an expression before rules for the surrounding expression are applied, and 
 restoring the head to the expression afterward if no applicable rules were found.
  
 This function returns its 
  
 C l e a r A l l  [ f ]
  
 :=  y
  
 argument, if the argument is 
  
 f [ y _ I n t e g e r ] 
  
  
 an integer.",NA
7.2.5 HoldPattern (a.k.a. Literal),"H oldPattern (which was known as L ite ra l in versions prior to 3.0) is another sym-bol 
 with the HoldAll attribute, but unlike Hold or HoldAll, and like Evaluate or 
 Unevaluated, it gets special treatment by the kernel. You might have noted, however, 
 that nowhere does this head appear in the description of the main evaluation loop in 
 Section 7.1.3. That is because H oldPattern is recognized by the pattern matcher.
  
  
 We have run across H oldPattern several times so far, generally when we have 
 inspected the rules associated with a symbol. For example,
  
 ClearAll[f] 
  
 f[x_] := xA2 
  
 DownValues[f]
  
 (HoldPattern[f[x_]] :> x^}
  
 The purpose of the head H oldPattern is to keep the expression f  [x_] on the left- hand 
 side of the downvalue from evaluating to (x_) A2. However, unlike other heads",NA
7.2.6 Verbatim,"Verbatim, which is new to version 3.0, is a “quoting” mechanism for patterns. Like H 
 oldPattern, it is recognized by the pattern matcher. However, Verbatim has a dif-ferent 
 purpose: It specifies that the expression it contains must be matched exactly, without 
 any special interpretation by the pattern matcher. For example, ordinarily a pat-tern like 
 x
 _
 matches any expression. When wrapped in Verbatim, however, it matches only the 
 expression x_:
  
 C l e a r [ x ,  y ]
  
 { x , x _ , y , y _ } / .  V e r b a tim [x _ ] 
  
 ->  m atch ed
  
 {x, matched, y, y_}
  
 Suppose that we wanted to write a pattern that could match any pattern variable in an 
 expression, rather than a specific pattern variable such as x_. The canonical internal 
 representation of any pattern variable is P atte rn  
 [var,
  ex p r]:",NA
7.2.7 Magic cookies,"The symbols Evaluate, Unevaluated, and Sequence are 
 magic cookies.
  This is a 
 whimsical term used by computer scientists to refer to any type of value that has special 
 significance to the software system of which it is a part. The behavior of these symbols 
 is not a result of any values or attributes that they possess; rather, it is “wired into” the 
 kernel. This implies that these behaviors simply can’t be altered, nor can they be 
 dupli-cated.
  
  
 For example, there is no way to give any other symbol the special properties of these 
 symbols:
  
 z = Evaluate; 
  
 Hold[z[2 + 2]]
  
 Hold[z[2 + 2]]",NA
7.3 Working with Held Expressions,"It may seem strange to discuss the topic of working with held expressions in a chapter 
 entitled “Expression Evaluation,” since this topic is all about expression nonevaluation! 
 However, this material logically belongs here since a thorough understanding of the 
 evaluation process — which you of course possess at this point — is a prerequisite for 
 working with held expressions.",NA
7.3.1 How do held expressions arise?,"It is anticipated that you may well be wondering how held expressions arise in practice. 
 After all, the examples in the previous section all seem very contrived. Before 
 proceed-ing, then, we will motivate the discussion.
  
 The most common source of held expressions is an argument passed to a function 
 with a Hold- attribute. Up until now, all of our examples of such functions have 
 imme­diately “passed the buck” to system-defined functions — for example, the inc and",NA
7.3.2 Part extraction and replacement,"The most important thing to realize about held expressions is that they are, first and 
 foremost, expressions. Their parts and levels are numbered just as any other 
 expres­sion’s are, and you can extract and replace those parts.
  
 a =  3 ; b =  4 ;
  
 Note that U nevaluated P o s it io n  [H o ld  [a  +  b ] , H o ld P a t t e r n  [b ] ]
  
 would also work here in 
 place of H o ld P a tte rn . 
  
 ’
  
 { { 1 2 ) 1
  
 Most likely, a part extracted from a held expression may be something that shouldn’t be 
 allowed to evaluate, as the following example shows:",NA
7.3.3 Application: Modifying large lists,"Although procedural programming is discouraged in 
 Mathematica,
  sometimes there is 
 no practical alternative. Functional programming primitives modify 
 copies
  of their 
 arguments; when arguments are large data structures and memory is tight, this simply is 
 not feasible. In situations like this, there may be no alternative but to operate on the 
 original data directly, modifying it in place.
  
 Unfortunately, in-place modification of large lists is extremely inefficient in 
 Mathe-matica.
  As an example, consider the following two ways of computing the first 
 moving average of a list of numbers:
  
 Here the result is computed 
  
 s =  R ange [1 0 0 0 ] ;
  
 in place (i.e., it overwrites 
  
 Do [s [ [ i ]  ] =  (s  [ [ i ]  ] +  s [ [ i  +  1] ] ) / 2 ,
  
 the original data). { i p L e n g th [s ] 
  
 -  1 } ] ;  / /  T im in g
  
 (3.01667 Second, Null}
  
 Here the result is stored in a 
 different list than the origi- nal 
 data. The creation of the 
 destination list is included 
  
 inthe,lnninS' 
  
 s =  Range [1 0 0 0 ] ;
  
 ( t  =  T a b le [ 0 , 
  
 { 1 0 0 0 } ] :
  
 D o [ t [ [ i ] ]  =  (s  [ [ i ]  ] +  s [ [ i  +  1] ] ) / 2 ,
  
 { i>  L e n g t h [ s ] 
  
 -  1 } ] ; ) 
  
 / /  T im in g
  
 [0 .6 3 3 3 3 3  S eco n d , N u l l)
  
 What could possibly explain such a great disparity in execution time? The answer is 
 that each time an expression like s [ [i] ] is evaluated, the list s is evaluated. During the 
 evaluation of s the kernel has to attempt to evaluate each element of s and check to see if 
 there are upvalues defined for L ist [
 ___
 , 
 el ement,
 ____
 ]. 
 Even if it turns out that none of 
 the elements of the list need to be evaluated, the process of ascertaining this fact takes an 
 amount of time that is proportional to the length of the list. Ordinarily the kernel avoids 
 this overhead by keeping track of whether or not the entire expression has changed since 
 the last time it underwent a full evaluation (see step 4 of the main evaluation loop in 
 Section 7.1.3). In the second algorithm, since s never changes, the kernel never has to 
 fully evaluate s. In the first algorithm, however, every time an ele-ment of s is modified, 
 s is marked as modified. Thus, s undergoes a full evaluation on each loop iteration, 
 which makes the running time of the first algorithm 
 quadratic
  in the length of the list, 
 rather than linear.
  
 We can prevent this overhead by changing the head of s to HoldComplete. As 
 dis-cussed at the end of Section 7.2.3, the parts of a HoldComplete object (or any 
 expres-sion whose head has the HoldAllComplete attribute) are 
 completely
  ignored — 
 there isn’t even a scan for upvalues. Nevertheless, we still are able to index into a 
 HoldCom-p le te  object as we would any other expression.",NA
7.3.4 Functional operations,"You can also use functional operations on a held expression. Here we use MapAt to 
 accomplish the same transformation for which we used part replacement in Section 
 7.3.2.
  
 M a p A t[S q r t, H o ld [a  +  b ] , 
  
 { 1 , 2 } ]
  
 H o ld
  [a 
 +  S q r t [ b ] ]
  
 One very useful functional operation on held expressions is plain old Apply (@@). 
 Apply allows you to “hand off’ a held expression to another function that operates on 
 held expressions, 
 without
  allowing the parts of the held expression to evaluate. For 
 example, suppose we wanted to use the contents of the held expression above on the 
 left-hand side of a rule. We could do this easily by applying H oldPattern, which 
 replaces the head Hold:",NA
7.3.5 Application: Filtering symbols,"Finding all symbols having certain properties is a good example of using functional 
 operations on held expressions. Names 
 [""strin g p a ttern ""] 
 returns a list of the names of 
 all symbols that match the given 
 string pattern
  — e.g., a string containing wildcard 
 characters like 
  
 (matches zero or more characters) or 
  
 (matches one or 
 more characters, excluding uppercase letters). For example,
  
 There are over 1500 names 
  
 n =  Names ["" S y s te m ' * "" ]  :
  
 defined by the version 3.0 
  
 S h o r t [n] 
  
 kernel!
  
 (Abort, AbortProtect, <<1524>>, $VersionNumber)
  
 The output of Names is a list of strings, not symbols (you can verify this using 
 InputForm), because symbols might evaluate. Now we could, for example, select the 
 names of all symbols in such a list that have a certain attribute by using a predicate like",NA
7.3.6 Rule substitution,"You can use rule substitution on held expressions, although frequently when you do so, 
 it is necessary to wrap part or all of the left-hand side of the rule in H oldPattern, as 
 explained in Section 7.2.5. For example, here is yet another way to turn Hold [a + b] into 
 Hold [a + S qrt[b]]:
  
 Hold[a + b] /. HoldPattern[b] :> Sqrt[b]
  
 Hold[a + Sqrt[b]]
  
 H oldPattern keeps the left-hand side of the rule from evaluating, and RuleDelayed 
 keeps the right-hand side from evaluating.
  
 One of the most powerful uses of pattem matching in 
 Mathematica
  is 
 destructuring, 
 which is the process of using patterns to take apart expressions. Here’s an alternative 
 way to solve the problem, posed in the last section, of finding all built-in symbols 
 hav-ing the Heads option:
  
 n = Names[""System'*""]; 
  
 Cases[ToHeldExpression[n], Hold[sym_] /; 
  
  
 MemberQ[Options[Unevaluated[sym]] , Heads->_]]
  
 {Hold[Apply], Hold[Cases], Hold[Count],
  
 Hold[DeleteCases], Hold[FreeQ], Hold[Level],
  
 Hold[Map], Hold[MapAll], Hold[MapAt],
  
 Hold[Maplndexed], Hold[MapThread], Hold[MemberQ],
  
 Hold[Position], Hold[Scan]}
  
 This technique — extracting part of a held expression and plugging it directly into 
 another expression — is arguably more straightforward than using S elect with a pure 
 function with a Hold- attribute. The output is a bit more awkward than before, but that 
 is easily fixed by using the Thread trick:
  
 Thread[%, Hold]
  
 Hold[{Apply, Cases, Count, DeleteCases, FreeQ, Level,
  
 Map, MapAll, MapAt, Maplndexed, MapThread,
  
 MemberQ, Position, Scan}]
  
 For our final example of using rule substitution on held expressions, we return to the 
 optimal matrix-chain multiplication problem of Section 6.4.2. Recall that we had 
 con-structed the following expression (page 173):
  
 multorder = {{1, {2, 3}}, {(4, 5), 
 6
  }};
  
 which we needed to transmogrify into the following form (A was the list of matrices to 
 be multiplied):",NA
7.3.7 Application: Dependency analysis,"Suppose that we want to analyze an expression to find all of the symbols upon which it 
 depends. Let us take as an initial example the expression Function [{x, y }, 
 x 
 + y] [{u, 
 v}]. Note that a prerequisite for success is that this expression not be allowed to evaluate 
 while it is being analyzed.",NA
__,"]] := 
  
 Union[Flatten[parse /@ Unevaluated[{hd, parts}]]]
  
 When a symbol is encountered, it is returned wrapped in HoldForm:
  
 parse[s_Symbol] := HoldForm[s]
  
 Everything else is ignored at this early stage of development.
  
 parse[_] := {}
  
 At this point we have implemented the functionality of the first Cases statement in this 
 section:
  
 parse[Function[{x, y}, x + y][u, v]] 
  
 {Function, L ist, Plus, u, v, x, y}
  
 5. Users of versions prior to 3.0 should choose the HoldFirst or HoldAll 
 attribute. Certain features of parse, pointed out below, will not be available.",NA
", ",s,NA
 2,The output of parse applied to this expression should therefore be:,NA
7.3.8 The Block trick,"The construct Block [ 
 {sym l, sym2
 . 
  
 . . . } , 
 expr]
  effectively gives the kernel a case 
 of temporary amnesia, preventing it from applying any rules associated with any of the 
 symbols 
 syml, sym2,
  etc. until after 
 expr
  has been constructed and returned from the 
 Block. This technique was first made known to the author by Allan Hayes.
  
 The Block trick is very useful for constructing expressions that are meant to evalu-ate 
 eventually, but only after they have been fully constructed. For example,
  
 a and b do not evaluate until 
  
 B lo c k [ { a , b } ,
  
 the B lo ck returns. a  +  b / .  b ->  S q r t [ b ] 
  
  
  
 ]
  
 5",NA
7.4 Additional Resources,"Chapter 10 of [Maeder 94a] contains many examples of applying functions to held lists 
  
 of symbols.
  
 Recursive descent parsing ([Aho & Ullman77]) originally was developed as a 
 method of parsing computer programming languages. It has the advantage of being easy 
 to code by hand. Nowadays, however, more sophisticated parsers are generated by 
 special computer programs called 
 parser generators,
  so recursive descent usually is 
 used only as an educational example in most texts.
  
 Algorithms for computing the transitive closure of a relation (or equivalently, a 
 graph) can be found in any text on algorithms and data structures. See, for example, 
  
 [Cormen et al. 90].
  
 A complete treatment of the symbol dependency analysis problem can be found in 
  
 [Wagner 96a].",NA
7.5 Appendix: Functions with Hold- Attributes,"Tables 7-3, 7-4, and 7-5 on the next page show all of the functions in version 3.0 of 
 Mathematica
  that have the H oldFirst, HoldRest, and HoldAll attributes, respec-tively. 
 Functions marked with an asterisk (*) do not exist in earlier versions; functions marked 
 with a dagger (t) exist but do not have the given attribute in earlier versions. In Table 7-
 5, certain functions with extremely long names appear at the end of the table.",NA
Part 3 ,NA,NA
Extending the ,NA,NA
System,NA,NA
8,NA,NA
Writing Packages,"A 
 package
  is basically a text file containing function definitions written in the 
 Mathematica
  programming language. The purpose of a package is not to perform a 
 par-ticular computation, but rather to extend the system by defining new functions. In 
 fact, 
 Mathematica
  ships with over 100 packages, called the 
 standard packages
  [WRI 
 93b]. This strategy gives users who need a particular functionality easy access to it, 
 without forcing users who don’t need it to pay the price for it (in terms of kernel memory 
 requirements and loading time).
  
 There is nothing magical about the standard packages; any 
 Mathematica
  program-mer 
 can write packages of his or her own. There are, however, several conventions that 
 packages must observe regarding the naming and visibility of symbols, proper 
 docu-mentation, and related issues, that are the main topic of this chapter. At the end of 
 the chapter we also discuss the 
 symbol shadowing
  problem, an advanced topic that may 
 be skipped on a first reading.",NA
8.1 Contexts,"A properly designed package should not modify the definitions of any symbols that are 
 in existence at the time the package is loaded — with the possible exception of system- 
 defined symbols that are enhanced by the package. Obviously, the author of a package 
 can't possibly anticipate what symbol names will be in use already. Therefore, multiple 
 distinct symbols with the same name need to be able to coexist. 
 Contexts
  are the 
 mech-anism used to manage such symbol names in a 
 Mathematica
  session.
  
 Contexts also provide 
 modularity:
  They hide implementation details from users. 
 Proper use of contexts in a package encourages users to access the package’s data 
 struc-tures through a well-defined interface; this makes the package more reliable.
  
 For these reasons, learning about contexts is a prerequisite to learning to write pack-
  
 ages.",NA
"8.1,1 Contexts are containers for symbols","Every symbol in a 
 Mathematica
  session belongs to some context.
  
 Sy stem-def i ned symbol s 
 such as 
 Plus 
 are in the 
  
 S y s t ^ ' context, 
  
 C ont e x t  [ P lu g  ]
  
 _ 
  
 ,
  
 Sy f lte a
  
 (The grave accent, or backquote 'following a context name is called a 
 context mark.)
  
 Upon the first use of a new symbol name, a symbol with that name is created in 
 whatever context happens to be the 
 current contact*
  The current context is kept in the 
 system variable $ Context.
  
 (C o n te x t
  
 Global
 1
  
 Most of the time the current context is G lo b al', so the vast majority of symbols that 
 are defined by a user in the course of a 
 Mathematica
  session fall into that context. The 
 input shown below creates a symbol at in the G lobal' context:
  
 x  =  5 :
  
 C o n t e n t [x j
  
 Global'
  
 Note that it is not necessary to assign a value to a symbol in order to create it; the 
 mere utterance of a symbol name (metaphorically speaking, of course) causes its 
 cre-ation.
  
 y
  is created simply by C o n te x t [y j
  
 mentioning it. G lo b a l'
  
 Symbol names are unique within any one context, but the same symbol name 
 appearing in different contexts refers to different symbols. How can these different 
 symbols be specified unambiguously? Every symbol has a long name and a short name; 
 the long nil me is of the form 
 contextname' shortname.
  
 Normally you need lo use only 
 the short name of a symbol, 
 and symbols print as short 
 names.
  
 The 7 operator shows the 
  
 long name of a symbol. 
  
  
 {at, y }
  
 .
  
 * ""
  
 7
  x
  
 G1 o b a l' 
 it
  
 x  -  5
  
  
 The following input creates a context called temp, as well as a symbol 
 x. 
 within that 
 context. Note that this symbol is distinct from the symbo! G lobal' 
 x.",NA
8.1.2 Nested contexts,"Contexts can be nested. For example, this input creates a symbol x in a subcontext foo 
 of the context temp.",NA
8.1.3 The context search path,"To allow you to use symbols from multiple contexts conveniently, 
 Mathematica
  
 main-tains a 
 context search path,
  which is simply a list of context names in the order in 
 which",NA
8.2 Package Mechanics,"Now that you understand contexts, you have almost all of the tools necessary to write a 
 package. There are two other context-related functions, BeginPackage and EndPack- 
 age, that make context management for a package much easier. After discussing these, 
 we will develop a complete example package.",NA
8.2.1 BeginPackage and EndPackage,"The first thing that every package must do is to call BeginPackage, which creates a new 
 context and changes the context search path to consist of only the newly defined context 
 and the System' context:
  
 The current context is 
  
 B e g in P a c k a g e  ["" e x a m p le '""]
  
 changed to e x a m p le '. 
  
 e x a m p le '
  
 And the context search path 
  
 $ C o n te x tP a th
  
 is changed as shown. 
  
 { e x a m p le ', 
  
 S y s te m '}
  
 BeginPackage temporarily removes all other contexts except System' from the con-text 
 search path, which guarantees that symbols defined by the package will be distinct from 
 symbols defined by other packages or by the user.2 The System' context is left on the 
 context search path so that the package can use built-in functions.3
  
 Here are some symbols created in the package context:
  
 2. This assumes, of course, that the user does not load two different packages 
 that define the same context. Thus, the problem has not been “solved,” but 
 merely pushed to a higher level. In practice, however, this is all that’s 
 necessary.
  
 3. If a package needs the services of other packages, a mechanism exists for 
 allowing 
  
 this; see Section 8.2.3.",NA
8.2.2 An example package,"The example package developed in this section generates pseudorandom numbers using 
  
 the linear congruential generator 
 xn +1 =
  75xnmod(231 -  1) ([Jain 91] example 26.3).
  
 The first thing that the package needs to do is to call BeginPackage:
  
 B e g in P a c k a g e [""L C G R a n d o m '""]
  
 LCGRandom'
  
 The next thing to do is to create any symbols that will be 
 exported,
  i.e., visible out-
  
 side of the package. This is conventionally done by defining 
 usage messages
  for these 
  
 symbols. These are the messages that will be printed when the user evaluates 
  
 Isymbolname.
  
 The package exports two 
  
 L C G S e tS e e d ::u s a g e  =  ""LC G S etS eed [x ] 
  
 s e ts  t h e  LCG \
  
 functions. 
  
 random  num ber g e n e r a t o r ’ s s e e d  t o  t h e  in t e g e r  x . "" ;
  
 LCG Random ::u s a g e  =  ""LCGRandom[] 
  
 g e n e ra te s  a \
  
 u n if o r m ly  d i s t r i b u t e d  random  num ber i n  t h e  r a n g e \
  
 u s in g  a  l i n e a r  c o n g r u e n t ia l g e n e r a t o r ."" ;
  
 Here's an example of a 
  
 ?LCGRandom
  
 usage message at work. LCGRandom [] 
  
 g e n e ra te s  a u n if o r m ly  d is t r i b u t e d  random
  
 (This code is not part of the 
  
 num bgr ±n t h e  ra n g e  { 0 . , 
 1
  .}  u s in g  a l i n e a r
  
 package.) 
  
 c o n g r u e n tia l g e n e r a t o r .
  
 The implementation of the exported functions is done inside of a private subcontext.
  
 B e g i n [ "" 'P r i v a t e '"" ]
  
 L C G R a n d o m 'P riv a te '
  
 Private data are defined first. To speed up the generator, we precompute the constant 
  
 231 -  1 and store it in a symbol called modulus. The symbol seed is used to keep track 
  
 of the most recent value returned by the generator.
  
 m o d ulus =  2 A31 -  1 ;
  
 s e e d  =  
 1
  ;
  
 This is also the place to define any error messages for the functions defined in the 
  
 package. We will defer a discussion of error messages to Section 9.1, “Diagnostic Mes­
  
 sages.”
  
 Now for the actual implementation of the two functions exported by the package:
  
 The seed must lie between 
 1
  
 LC G SetS eed [ x _ In t e g e r  / ; 
  
 1 <= s e e d  < m o d u lu s] 
  
 : =
  
 and modulus - 
 1
 . 
  
 seed = x
  
 LCGRandom takes no param- 
  
 LCGRandom [] 
  
 :=  (
  
 m o d u lu s ];
  
 eters; it uses the package's 
  
 s e ed =  M o d [7 A5 * s e e d , 
  
 internal state. 
  
 N [s e e d /m o d u lu s ]
  
 )",NA
8.2.3 Using other packages,"If a package depends on some other package, there are two ways to ensure that the other 
 package is available at the time the package is loaded: 
 normal import
  and 
 hidden
  
 import.
  
 To import packages in the normal way, add the context names of those packages to 
 the BeginPackage call. For example, the following BeginPackage statement loads the 
 context NeededPackage' (if necessary) and places it on the context path right after 
 MyPackage':
  
 BeginPackage[""MyPackage'"", ""NeededPackage'""]
  
 Now MyPackage' can use any symbols defined in NeededPackage'.
  
 One possible drawback to this method is that it “pollutes” the context path with extra 
 contexts. The user may stumble across a symbol that is defined in a subsidiary package, 
 which she or he isn’t even aware has been loaded. This has the potential to cause some 
 confusion.
  
 To avoid this problem, the subsidiary contexts can be loaded, using Needs, 
 after
  the 
 call to BeginPackage; this is called hidden import [Maeder 91]. Now the package can 
 still use all of the symbols defined in the other packages, but after the EndPackage 
 statement is executed, the other packages will not appear on the context path (but they 
 will appear in $Packages).",NA
8.3 Stylistic Considerations,"There are quite a few stylistic considerations to which you should pay heed when you 
 write a package.",NA
8.3.1 Naming conventions,"The general naming convention for symbols used in 
 Mathematica
  is that names should 
 be capitalized English words or concatenations of such words. Names should be 
 descriptive and fully spelled out. Abbreviations should not be used unless they are in 
 widespread use (e.g., Det instead of Determinant).
  
 Function names should be unique whenever possible; however, if you define a 
 func-tion whose purpose is similar to a built-in function, its name should be similar to 
 that of the built-in function. Avoid adding definitions to built-in functions unless 
 absolutely necessary, as this may lead to unexpected results in some cases and may slow 
 down the evaluation of a wide class of expressions. Also, try to avoid defining two 
 different func-tions when a single function with an option would do.
  
 Package filenames should be unique within the first eight characters in order to avoid 
 problems on DOS-based file systems.",NA
8.3.2 Export a minimal interface,"yp
  
 As discussed earlier in this chapter, a package should encapsulate the details of its 
 implementation inside of a private subcontext. Moreover, even the 
 names
  of functions 
 and symbols that are not of immediate utility to the user should be hidden; this avoids 
 confusion on the user’s part. A good rule to follow is that only those symbols that have 
 usage messages should be visible outside of the package. Any auxiliary functions 
 and/or temporary variables (such as modulus and seed in the LCGRandom' example) 
 should be created inside of a private subcontext.
  
 The package 
 EscapingSymbols.m(MathSource
  item #0204-961-0022) can help you to 
 identify symbols defined by a package that “escape” from it without usage messages.
  
 N e e d s ["" E s c a p in g S y m b o ls '"" ,
  
 "" M a th S o u rc e : E n h a n c e m e n ts : L a n g u a g e :0 2 0 4 -9 6 1 ;
  
 D e v e lo p e r T o o ls  f o r  A :E s c a p in g S y m b o ls .m ""]
  
 ? E s c ap in g S y m b o ls
  
 E s c a p in g S y m b o ls [e x p r] 
  
 r e t u r n s  a l i s t  o f  sym bols
  
 e s c a p in g  fro m  t h e  e x e c u tio n  o f  e x p r ( i . e . ,  new
  
 sym b ols v i s i b l e  t o  t h e  u s e r b u t la c k in g  u sag e
  
 m e s s a g e s ).
  
 The file example. m contains a simple package that we will use to demonstrate the 
 action of EscapingSymbols.",NA
8.3.3 Usage message conventions,"Every usage message should begin with a syntax declaration. This is because some ver-
  
 sions of the front end have a command called Make Template that pastes generic argu-
  
 ments for a function into the notebook following the name of the function (see your 
  
 User’s Guide
  for details). This is very handy for functions that take several arguments, 
  
 the order of which is uncertain to the user. The template mechanism looks at only the 
  
 beginning
  of a usage message for a template, hence the first thing in the usage message 
  
 should be a usable template. Compare the following two examples:
  
 This is a good usage mes- 
  
 L C G S e tS e e d ::u sa g e  =  ""LC G S etS eed [x ] 
  
 s e ts  t h e  LCG
  
 sage. 
  
 random  num ber g e n e r a t o r ’ s seed  t o  th e  in t e g e r  x . "" ;
  
 This is a bad usage message. 
  
 LC G S etS eed: :u sa g e  =  ""LC G S etS eed i s  u sed  t o  s e t  th e
  
 s eed  f o r  th e  LCG random  num ber g e n e r a t o r .
  
 L C G S e tS e e d [x ] 
  
 s e ts  t h e  s eed  t o  x . "" ;",NA
8.3.4 Diagnostic messages,"Never use P rin t to issue diagnostics; use Message instead. There are several good 
  
 reasons for this, which we’ll discuss in detail in Section 9.1, “Diagnostic Messages.”",NA
8.3.5 Package documentation,"If you look inside any of the standard packages, you will see many comments at the 
  
 beginning of the file that have the following general format:
  
 ( * 
  
 :Nam e: C a l c u l u s 'L im it ' 
  
 * )
  
 ( * 
  
 :A u th o r: V i c t o r  S . A d a m c h ik , Summer 1991 * )
  
 ( * 
  
 : Summary:",NA
8.4 Advanced Topic: Shadowing,"Shadowing
  occurs when more than one context on the context search path contains a 
 symbol of a given name. The most common cause of shadowing, which will be 
 illus-trated in Section 8.4.1, is attempting to use a symbol from a package before 
 loading that package.
  
 Several techniques and tools exist for preventing or at least minimizing the 
 shadow-ing problem. Some of these are aimed at package developers (Sections 8.4.2 
 and 8.4.3). In Section 8.4.4 we demonstrate a package called 
 Unshadow.m,
  available 
 from 
 Math-Source,
  that provides a tool for removing symbols that shadow other 
 symbols. Finally, in Section 8.4.5 we develop a new package that avoids shadowing 
 automatically.",NA
8.4.1 The shadowing problem,"Every 
 Mathematica
  user has, at one time or another, made a mistake like the following: 
  
 A package symbol is 
  
 Show [P o ly h e d ro n  [D o d e ca h e d ro n ] ]
  
 a e ^ fo a d e d
  ^01^0 1 '18
  ^aC^"" 
  
 S h o w ::g ty p e : P o ly h e d ro n  i s  n o t a ty p e  o f  g r a p h ic s . 
  
 S h o 
 w [P o ly h e d ro n [D o d e c a h e d ro n ] ]",NA
8.4.2 Designing packages to prevent shadowing,"Package designers can spare users of their packages the frustration of shadowing by 
 using one of the following tricks. Unfortunately, each of these techniques has 
 draw-backs as well.
  
 Roman Maeder [Maeder 91] suggests including the G lobal' context in the Begin- 
 Package command:
  
 B e g in P a c k a g e ["" M y P a c k a g e '"" ,  "" G lo b a l'"" 
  
 . . ]
  
 This adds the G lobal' context to the context search path at the time the package is 
 loaded. Any symbol created by the package that does not already exist in the G lobal' 
 context will be created in the MyPackage' context. If such a symbol already exists in the 
 G lobal' context (because a user tried to use it too soon), then that symbol — in the G 
 lobal' context — will be redefined by the package. Hence, there will be only one symbol 
 with the given name, and no shadowing will occur.
  
 Of course, Maeder’s trick is a calculated risk, since the user may have deliberately 
 associated a definition with one of the conflicting symbol names, and the package might 
 wipe out that definition. To get around this problem, Nancy Blachman [Blachman 92] 
 recommends starting a package with the following code:
  
 B e g in P a c k a g e ["" M y P a c k a g e '""]
  
 E n d P a c k a g e []
  
 The purpose of this device is to prepend MyPackage' to the context search path. Now 
 continue with the rest of the package; all symbols will be created in the context in which 
 Needs was called, which 
 probably
  is G lo b al'. (Be sure to declare the pack­age’s 
 private subcontext as M yPackage'Private' rather than just 'P r iv a te ', to ensure that the 
 package’s private symbols do not end up in a context called Glo­b a l'P riv a te '.)
  
 It may seem as though this method has the same potential for problems as Maeder’s. 
 The difference is that if a sophisticated user wishes to create the package’s symbols in a 
 different context — which cannot be done using Maeder’s method — he or she can 
 always do this:
  
 B e g in P a c k a g e ["" N e w C o n te x t'""]
  
 N e e d s ["" M y P a c k a g e '""]
  
 E n d P a c k a g e []",NA
8.4.3 Predeclaring package symbols,"Every standard package directory (e.g., 
 Graphics)
  contains a file called 
 Master.m, 
 which 
 contains declarations for each package contained in that directory (e.g., Graph- ic s'G ra 
 p h ic s', G raphics'G raphics3D ', etc.). These declarations have the fol-lowing general 
 form:
  
 D e c la r e P a c k a g e ["" G r a p h ic s ' P o ly h e d r a '"" ,
  
 { "" P o ly h e d r o n "" , "" D o d e c a h e d ro n "" }];
  
 This declaration doesn’t actually load the G raphics'Polyhedra' package; it simply tells 
 the kernel that the symbols Polyhedron and Dodecahedron can be found there. 
  
 The symbols are created in the package context and given the Stub attribute:
  
 ?P o ly h e d ro n
  
 G r a p h ic s 'P o ly h e d r a 'P o ly h e d r o n
  
 A t t r ib u t e s [ P o ly h e d r o n ]  = (S tu b )
  
 P o ly h e d ro n  = """"
  
 The Stub attribute signifies that the package that defines a symbol has not yet been 
 loaded. Upon the first use of any symbol having this attribute, the kernel will 
 automati-cally load the package that defines that symbol.
  
 Using the symbol P o lyhe- 
 dron causes the G raph- ic s ' P 
 o ly h e d ra ' package 
 to 
 load. 
  
 P o ly h e d ro n 
  
 P o ly h e d ro n
  
 ?P o ly h e d ro n 
 t , 
 ,
  
 P o ly h e d ro n [n a m e ] 
  
 g iv e s  a G ra p h ic s 3 D  o b je c t
  
 r e p r e s e n t in g  t h e  s p e c if ie d  s o li d  c e n te r e d  a t  th e o r i g i 
 n  and w it h  u n i t  d is t a n c e  t o  t h e  m id p o in ts  o f
  
 t h e  e d g e s . 
  
 P o ly h e d ro n [n a m e , c e n t e r , 
  
 s iz e ]  u se s  t h e
  
 g iv e n  c e n t e r  and s i z e .  The p o s s ib le  names a r e  i n
  
 t h e  l i s t  P o ly h e d ra .
  
  
 If there are certain standard packages that you use on occasion but which would 
 occupy too much memory if they were all loaded simultaneously, you can avoid any",NA
8.4.4 Removing shadows after the fact,"Shadowing happens
  would make a perfect bumper sticker for a 
 Mathematica
  user. The 
 fact is, the vast majority of packages — standard packages included — do not take any 
 of the steps described in Section 8.4.2 for avoiding the shadowing problem. Each of the 
 standard package directories does provide a master package; however, it’s often the case 
 that users forget to load them.
  
 In response to this situation, Ulrich Jentschura has written a package called 
 Unshadow.m (MathSource
  item #0204-815), which defines a function called Unshadow 
 that seeks out and destroys 
 all
  global symbols that are shadowing other symbols. This is 
 especially useful in cases where the user has shadowed so many symbols that the error 
 message mechanism suppresses some of the 
 sym :
 : shdw messages! Here is a 
 demon-stration of using Unshadow to rectify the situation illustrated in Section 8.4.1.
  
 First, remove the Graph- ic s 
 'P o ly h e d ra ' context
  
 C le a n S la t e  [ "" G r a p h ic s 'P o ly h e d r a '""] ;
  
 from the current session.
  
 Now make the same mis- take 
 as before. 
  
 g =  P o ly h e d ro n  [D o d e ca h e d ro n ] ; 
 Show [g]
  
 S h o w ::g ty p e : P o ly h e d ro n  i s  n o t a ty p e  o f  g r a p h ic s .
  
 S h o w [P o ly h e d ro n [D o d e c a h e d ro n ]]",NA
"8.4.5 ""Smart"" shadow removal","Unshadow does not make any attempt to distinguish between symbols that the user 
 might or might not need. One obvious way to do this would be simply to return the list 
 of shadowing symbols without removing them; the user could then verify that none of 
 the symbols are important and execute the command Remove @@ %. Alternatively, 
 Unshadow could prompt the user for confirmation (using the Input function) before 
 removing each symbol. Better yet, it could give the user the best of both worlds by 
 pro-viding an option that controls its behavior in this regard.
  
 On the other hand, there is something to be said for making the process as automatic 
 as possible. A more sophisticated approach that subscribes to this philosophy would be 
 to determine whether or not the shadowing symbol has any values; if it does not, then it 
 probably is not important and can be removed automatically. This is the approach that 
 we shall take next. Our efforts will culminate in a new package, AntiShadow, that 
 removes shadows during the package-loading process, taking care never to remove a 
 symbol that has any values.
  
 Determining if a symbol has values
  
 A symbol can have many different kinds of values. For example, this assignment creates 
 an ownvalue:
  
 t e s t  :=  
 1 / 0
  
 OwnValues [sj'm] lists the 
  
 O w nV alues [ t e s t ]
  
 :>
  
 ownvalue of a symbol.
  
 { H o ld P a t t e r n [ t e s t ]",NA
8.5 Additional Resources,NA,NA
8.5.1 Packages about packages,"A skeleton package that you can fill in with your own code is in the file 
 Skeleton.m, 
 located in the 
 Programming Examples
  subdirectory of the main 
 Packages
  directory (file 
 and directory names may vary on different platforms).
  
 The collection of files entitled “Developer Tools for Applications Package Testing” 
 (MathSource
  item #0204-961) contains documentation and packages that deal with the 
 design and testing of other packages. This collection contains the package 
 Escaping-
 Symbols.m
  (discussed in Section 8.3.2), among other things.",NA
8.5.2 Publications,"[Maeder 91] contains a lucid discussion of contexts and packages.
  
 Most of the information in Section 8.3 has been adapted from [WRI 93d] and 
 [Gayley 94d], each of which contains many useful coding tricks and package style 
 guidelines. Both are available from 
 MathSource
  and are highly recommended. [WRI 
 93d] is one of the components of WRI’s “Developer Tools for Applications Pack­age 
 Testing” (see above).
  
 Packages also can be distributed as notebook files; style guidelines for these types of 
 packages can be found in [WRI 93d], and portability issues are discussed in [Novak 94], 
 The 
 Factorization.ma
  and 
 DependencyAnalysis.ma
  packages on the sup-plementary 
 diskette are written in this format. See Section 7.3.7, “Application: Depen­dency 
 analysis,” and Section 9.6, “Application: Defining a New Data Type,” for descriptions of 
 these packages.",NA
9,NA,NA
"Details, Details","When you create a quick-and-dirty function for your own immediate use, it doesn’t 
 really matter how you write it. On the other hand, if you write a function that is going to 
 be used by other people, it should behave as much like a built-in function as possible. 
 This chapter covers a potpourri of implementation techniques that are not widely known 
 or used outside of the built-in functions and standard packages.
  
 Section 9.1 discusses the proper use of diagnostic messages, and why it’s a good idea 
 to use the Message function for this purpose. Section 9.2 covers some advanced 
 tech-niques for working with options. Section 9.3 explains the much-misunderstood 
 numeri-cal evaluation mechanisms of 
 Mathematica
  and how to control them. Section 9.4 
 shows how to change the output formatting of expressions by attaching format values to 
 sym-bols. Section 9.5 points out recommended precautions to take when you make 
 defini-tions that affect the global state of a 
 Mathematica
  session. Finally, Section 9.6 
 unifies a number of the techniques presented in this and earlier chapters with a case 
 study.
  
 This chapter is concerned mainly with minutiae. “Big picture” style guidelines, e.g., for 
 entire packages, were discussed in Section 8.3.",NA
9.1 Diagnostic Messages,"Diagnostics should be generated using Message, not P rin t. In a nutshell, here is how 
 the Message mechanism is used:
  
 Define a message of 
 the form 
 symbol:: tag. 
  
 Note that Message 
 returns 
  
 Null. 
  
 foo::bar = ""This is a message with parameters '1' and 
 '
 2
  ' . "" ;
  
 Message [foo:: bar, ""this"", ""that""]
  
 foo::bar: This is a message with parameters this and 
 that.",NA
9.1.1 Why use Message?,"You can’t pass a string as the first argument to the Message function — you must take 
 the extra step of defining a message of the form 
 sym bol
 :: 
 tag
  and passing that object 
 instead. Although this seems like unnecessary work, there are at least five good reasons 
 for going to the trouble.
  
 First of all, from a code maintenance standpoint, it is easier to find all of the 
 mes-sages that can be generated by a package if they are declared all in one place, as 
 opposed to having strings scattered throughout the code of the entire package. 
 Further-more, users can get a list of all messages associated with a symbol by using 
 Mes-sages 
 [symbol].
  
 Messages[foo]
  
 {HoldPattern[foo::bar] :>
  
 This is a message with parameters '1' and ""2',}
  
 Second, the Message mechanism allows a user to enable or suppress messages on an 
 individual basis using 
 On 
 [symbol: : tag
 ] and 
 Off 
 [symbol: : tag
  ] .
  
 Off[foo::bar]; 
  
 Message[foo::bar, ""ain’t gonna"", ""happen""]
  
 On[foo::bar]; 
  
 Message[foo::bar, ""I’m"", ""baaaack!""]
  
 foo::bar: This is a message with parameters I ’m and 
 baaaack!.
  
 The third reason to use the Message mechanism is that the system-defined variable 
 $Messages contains a list of output streams (Section 12.3, “Low-Level Output”) to 
 which messages are written. (The default value of this variable is the list { ""stdout"" }.) 
 The user can thus redirect all Message output by modifying this variable. For example, 
 messages could be echoed to a file like this:
  
 W e use B lock to alter the 
  
 m s g lo g  =  O p e n W rite  [""m s g lo g ""] ;
  
 m s g lo g ]} ,
  
 value of $Messages tempo- 
  
 B lo c k  [{{M e s s a g e s  =  Append [{M e s s a g e s , 
  
 Message[foo::bar, ""echoed to"", ""file msglog""];
  
 Close[msglog];
  
 foo::bar: This is a message with parameters echoed to 
  
 and file msglog.
  
 !! 
 f i l e
   prints the contents of a 
 file to the screen. 
  
 ! Im s g lo g
  
 - 
  
 , 
  
 „  . 
  
 . 
  
 . , , 
  
 ,
  
 foo::bar: This is a message with parameters echoed to
  
 and file msgdemo.",NA
9.1.2 General messages,"Message [
 symbol:: tag]
  works by first searching Messages 
 [symbol]
  for a mes-
  
 sage with tag 
 tag.
  If found, that string is used.
  
 M e s s a g e s [fo o ]
  
 { H o ld P a t t e r n [ f o o : :b a r ] :>
  
 T h is  i s  a m essage w it h  p a ra m e te rs  ' 1 '  and ' 2 ' . )
  
 If no such message is found, Message tries to use the message G eneral:: 
 tag.
  This 
  
 allows functions to share message definitions. For example,
  
 G e n e r a l: : a rg b u
  
 '
  1
  ' c a l l e d  w it h  
 1
  a rg u m e n t; b e tw e e n  '
  2
  ' and ' 3 ' \
  
 a rg u m e n ts  a r e  e x p e c te d .
  
 M e s s a g e [fo o :: a rg b u , 
  
 "" f o o "" , 3 , 4]
  
 f o o : : a rg b u :
  
 fo o  c a l l e d  w it h  1 a rg u m e n t; b e tw e e n  3 and 4
  
 a rg u m e n ts  a r e  e x p e c te d .
  
 Use General messages, rather than defining new ones, whenever possible. You can 
  
 get a list of all General messages by evaluating Messages [G eneral]. Each of these 
  
 messages is documented in [WRI 91].
  
 The argument count message shown above is one of several that deal with that type 
  
 of error. We should have used these system-defined messages in the LCGRandom 
 exam-
  
 ple of Section 8.2.2. For example:
  
 The actual number of argu- LCGRandom [] 
  
 :=  "" a  random  n um ber""
  
 ments supplied is obtained LCGRandom [x 
  
 ] 
  
 : =
  
 using Length. 
  
 M essag e[L C G R and om :: a r g r x , ""LCGRandom"".
  
 L e n g t h [ { x } ] , 0]
  
 LCG Random [a, b]
  
 LCG Random :: a r g r x :
  
 LCGRandom c a ll e d  w it h  2 a rg u m e n ts ; 0
  
 a rg u m e n ts  a r e  e x p e c te d .",NA
9.1.3 Issuing diagnostics without evaluating,"There is one more stylistic point regarding diagnostic messages: Built-in functions 
  
 return 
 without evaluating
  when they are called incorrectly. If you have ever tried in",NA
9.2 Options,"As a general rule, use options, rather than global variables, to control the way a function 
 works. We discussed the basics of options in Section 6.3.5. Here is a recap of what was 
 covered in that section; if any of this seems unfamiliar, you may wish to review that 
 section before proceeding with this one.
  
 1. Options to a function are specified as Rule or RuleDelayed objects. Options, if 
 present, always follow nonoptional arguments.
  
 2. The correct pattem for matching any sequence of options is
 ___
 ?OptionQ.
  
 3. Option values are extracted using ReplaceA ll (/.). In order to have user-specified 
 option values override default option values, value extraction is done thus:
  
 {o p tio n N a m e l, o p tio n N a m e
  2
  , 
  
 . . . }  / .
  
 / . 
  
 { d e f a u ltO p tio n s }
  
 F la t t e n [ { u s e r S p e c if ie d O p t io n s } ] 
  
 A concrete example of this technique will be given below.",NA
9.2.1 Default option values,"A function f that supports options should allow the user to change the default option 
 values using 
 S e tO p tio n s . 
 This is accomplished by storing default option values in 
 O p tio 
 n s  
 [f ] and evaluating 
 O p tio n s  
 [f ] each time f  is called.
  
 C le a rA ll clears values, 
  
 C l e a r A l l  [ f  ]
  
 : =
  
 options, and attributes.Then set 
 the default options for
  
 O p tio n s  [ f ]  =  { o p t l - > l ,  o p t 2 - > 2 } ;
  
 the function f .
  
 f [ a r g l _ ,  o p ts
  ___
 ? O p tio n Q ] 
  
 This is the canonical way to 
  
 handle options with default 
  
 M o d u le  [ { o p t l v a l , o p t 2 v a l } ,
  
 / .  O p t io n s [ f ] ;
  
 values. 
  
 { o p t l v a l ,  o p t
  2
  v a l }  =
  
 { o p t l , o p t2 }  / .  F l a t t e n [ { o p t s } ] 
  
 ]
  
 { a r g l ,  o p t l v a l ,  o p t
  2
  v a l }
  
 For illustrative purposes, f  returns a list consisting of its argument and the values it 
 intends to use for each option. Here are some examples:",NA
9.2.2 Checking options for validity,"Built-in functions print the G eneral: : optx message when passed an option that they 
 don’t understand.
  
 G e n e r a l: : o p tx
  
 Unknown option '
 1 ' i n  ' 2 ' .
  
 This needn’t be a fatal error, but the user should be informed in case he or she simply 
 spelled one of the options incorrectly. Finding invalid options is easy:
  
 Suppose that this sequence of 
 options is passed to the 
 function f . 
  
 Here are the names of all 
 valid options for f . 
  
 Simply check that the left- hand 
 side of each rule in opts is a 
 member of v a lid .
  
 o p ts  =  S equence [o p t l- > w , o p t 2 -> y , o p t 3 - > z , o p t4 -> 4 2 ]
  
 Seq uen ce [ o p t l ->  w , o p t2  ->  y , o p t3  ->  z , o p t4 
  
 J 
  
 r  r
  
 ->  42]
  
 v a l i d  =  F i r s t  /@ O p tio n s  [ f ] 
  
 { o p tl>  o p t2 }
  
 MemberQ [ v a l i d . F i r s t [ # ] ] &  /@ { o p ts } ]
  
 { T r u e , T r u e , F a ls e , F a ls e }
  
 Below, we integrate this code into the body of f . We use Scan to apply to the list of 
 supplied option names a pure function that checks for option validity. If an option is 
 invalid, the message f : : optx (not G eneral: : optx) is generated.
  
 C l e a r [ f ]
  
 f c a l l : f [ a r g l _ ,  o p ts ____? O p tio n Q ] 
  
 := 
  
 M o d u le [ { o p t l v a l ,  o p t 2 v a l, 
  
  
  
 v a l i d  =  F i r s t  /@ O p t io n s [ f ] } , 
  
  
  
 S c a n [ I f [ ! M e m b e rQ [v a lid . F i r s t [ # ] ] . 
  
  
  
  
  
 M e s s a g e [ f : : o p t x , T o S t r i n g [ F i r s t [ # ] ] , 
  
  
  
  
  
 T o S t r in g [ U n e v a l u a t e d [ f c a ll ] ] ] ] & ,
  
 ];
  
 F l a t t e n [ { o p t s } ]",NA
9.2.3 Filtering options,"Sometimes a function needs to call other functions that take options of their own. In 
 such cases the calling function must be sure to pass to those functions only the options 
 that they understand, or else error messages will be generated. The package U tili- tie s 
 'F ilte rO p tio n s ' defines a function F ilterO p tio n s [f, 
 o p ts
 ] that returns a sequence 
 of the options in 
 opts
  that are valid for 
 f.
  
 Load the package. 
  
 Needs [""Utilities'FilterOptions'""]
  
 Recall the phony options We used in the last example.
  
 opts
  
 Sequence[optl -> w, opt2 -> y, opt3 -> z, opt4 -> 42]
  
 If we filter this sequence of options with respect to f, the invalid options opt3 and opt4 
 are removed.
  
 Note that 
 FilterOptions 
 returns another 
 Sequence. 
  
 okay Opts = FilterOptions [f, 
 opts] Sequence [optl -> w, opt2 -
 > y]
  
 Sequence was discussed in detail in Section 7.1, but a brief refresher is appropriate 
 here. Sequence is the head of expressions that match patterns like x",NA
__,"or x
 ___
  . 
 When-ever a Sequence appears inside of another expression, its head is stripped off and 
 the elements of the Sequence are “spliced” into the enclosing expression. F ilterO p ­tio 
 n s takes a sequence of options, such as might be matched b y
  ___
 ?OptionQ, and returns 
 a new sequence of options. Because the return value of F ilterO p tio n s is a Sequence, it 
 can be inserted into a function call and the effect is the same as inserting the individual 
 options.
  
 f[x. okayOf>ts]
  
 {x, w, y)",NA
9.3 Numerical Evaluation,"There are many nuances of numerical evaluation, particularly in regard to the 
 interac-tion between user-defined functions and the numerical evaluation operator N. 
 There are several mechanisms available to make user-defined functions behave 
 numerically as the built-in ones:
  
 1. The arguments to a function can be tested to see whether they are exact or approxi-
  
 mate, and different rules can be written for each case.
  
 2. The arguments to a function can be shielded from numerical evaluation.
  
 3. The behavior of N 
 [expr]
  can be overridden.
  
 4. Upvalues can be defined for S eries 
 [expr
 , . . .  ].",NA
9.3.1 Numerical arguments,"Many important functions can be evaluated only approximately except for certain 
 spe-cial cases — transcendental and special functions are good examples of this. The 
 built- in numerical functions all observe the convention of never returning an 
 approximate result given exact inputs unless the user specifically requests it (using N). 
 Your func-tions should observe this convention as well. If the arguments are exact and 
 no special rule exists for those particular values, a function should return unevaluated, or 
 perhaps rewritten in terms of other exact expressions. However, if the user supplies an 
 approxi-mate argument, or if the user calls N [f [arg] ], a function should return an 
 approxi-mate numerical answer.
  
 Mathematica
  provides several predicates and other functions for testing the 
 numeri-cal properties of an expression. The simplest of these, NumberQ, returns True if 
 its argument is a 
 manifest
  number, i.e., has the head Integer, R ational, Real, or 
 Complex.",NA
9.3.2 Shielding arguments from numerical evaluation,"In most cases, handling N [futic [arg] ] is automatic, because of the way that N works. 
 The argument to N is evaluated first in the normal way; if the result is nonnumeric, then 
 the N function is applied recursively to all parts of the result (including the head, if the 
 result is a normal expression). Finally, the N function is applied to the overall result.
  
 Here is a simple example that illustrates the operation of N:
  
 This function rounds inexact 
  
 C le a r  [ f  ]
  
 Round [x]
  
 numbers. 
  
 f [ x _ ] 
  
 / ;  P r e c is io n  [x ] 
  
 < I n f i n i t y  := 
  
 The options to T race are 
  
 T r a c e  [N [ f  [3 ] ] , T r a c e In t e r n a l- > T r u e , 
  
 T r a c e O f f - > f  ]
  
 explained in Section 13.1. 
  
 { N [ f [ 3 ] ] 
  
 ( f [ 3  ] 
  
 3 ) 
  
 3 
  
 }",NA
9.3.3 Overriding N,NA,NA
[expr],"There are rare cases in which it is desirable to evaluate N 
 [ f
  [
 arg
 ] ] differently than 
 f
   [N 
 [arg] 
 ]. An example is provided by the In te g ra te  function, which attempts to do 
 symbolic integration even if some of its arguments are inexact. If an expression like In te 
 g ra te  
 [func, 
  
 range]
  cannot be evaluated, then N [In teg ra te 
 [func
 , 
 range]
  ] 
 calls N Integrate 
 [func, range
 ] , which is a completely different function that uses 
 completely different algorithms than In teg rate. Here is proof:
  
 Integrate 
 cannot do this 
  
 Trace[N[Integrate
 [ x / ( x  +  E x p [ x ] ) , 
  
 { x , 
 0, 
 1 } ] ] , 
 integral. A trace reveals that 
  
  
 N [__] | NIntegrate[__], 
  
 N[Integrate 
 [ . . . ]  ] calls 
  
  
  
 TraceInternal->True, TraceForward->True] 
 NIntegrate[...].
  
 {N[Integrate[— —
 --
  , {x, 0, 1}]],
  
 EX + x
  
 {NIntegrate[— ----, {x, 0, 11,
  
 EX + x
  
 WorkingPrecision -> 16, AccuracyGoal -> Infinity. 
 PrecisionGoal -> 
 6
  ], 0.203039), 0.203039}
  
 This kind of behavior can be effected for any function 
 f
   by defining a rule of the 
 form “N [f [ .. .  ] ] : = .. . ” or “N [f [. . . ] , 
 precision_]
  : = . . . ”, This kind of rule is 
 stored with f , not N, but it is not an upvalue: It is a type of rule called an Nvalue 
 (Section 7.1.1).
  
 For purposes of exposition only, suppose we were to add the following rule for the 
 function f  defined in the last section:
  
 N[f[x_], prec_:$MachinePrecision] := 
 StringForm[""precision requested 
  
 prec]",NA
IT ,"N evaluates its arguments before checking for Nvalues, and f  [3. ] evaluates to the inte-
  
 ger 3. This behavior is not a bug, however; it is perfectly consistent with that of the Note 
 that N [f [3. ] , 20] uses the downvalue for f, not the Nvalue! The reason is that 
  
 built-in functions:
  
 This does not give a 45-digit 
  
 N [ S i n [ 2 . ] p 4 5 ]
  
 result 
  
 0 .9 0 9 2 9 7 4 2 6 8 2 5 6 8 2
  
 This does, because an inter- 
  
 N [ S in [ 2 ]  , 4 5 ]
  
 nal Nvalueis used. 
  
 0 .9 0 9 2 9 7 4 2 6 8 2 5 6 8 1 6 9 5 3 9 6 0 1 9 8 6 5 9 1 1 7 4 4 8 4 2 7 0 2 2 5 4 9 7 1
  
 The error in each case is the user’s, not the system’s. If you want a high-precision result 
  
 from a numerical function, you have to pass in high-precision arguments!",NA
D,NA,NA
r,"It’s difficult to come up with an uncontrived example of using Nvalues for a function 
 that isn’t already built into 
 Mathematica.
  In addition to the Integrate-N Integrate duo, 
 there are Roots and NRoots; Solve and NSolve; DSolve and NDSolve; Sum and NSum; 
 and Product and NProduct. Note that all of these examples ar
 e, functionals 
 (functions 
 that operate on other functions). For functions of numeric arguments, you can almost 
 always effect the desired behavior simply by using different rules for exact and 
 approximate arguments (as we did in the ErlangB example). In the example using the 
 function f 
  
  
 above, if there were no Nvalue for f, the expression N[f [3] , 20] would be converted 
 to f  [N [3 , 20] ], so f  could determine the precision requested simply by checking the 
 precision of the argument.
  
  
 Remember:
  The purpose of Nvalues is not to distinguish between exact and 
 approxi-mate arguments to a function; it is to distinguish between N [ 
 f  [arg]
  ] and 
 f
   [N 
 [
 arg
 ] ].
  
 Another use of Nvalues is to define mathematical constants such as E, Pi, and so 
 forth. Once again, all of the most useful constants are built into the system, or can be 
 expressed in terms of the built-in constants, so it’s difficult to come up with an example 
 that isn’t contrived.
  
 The following example was used in Section 7.1.1 to illustrate Nvalues: Let omega 
  
 denote an exact solution to the transcendental equation omega == Exp [omega]. We 
  
 created two rules for omega: an upvalue for simplifying the expression Exp [omega] 
  
 and an Nvalue for evaluating omega numerically:
  
 Exp[omega] A:= omega",NA
9.3.4 Functions defined by power series,"Finally, a few words on power series and functions that are defined by them. When a 
 request is made for a numerical evaluation of such a function, it is up to the 
 implemen-tation of the function to figure out how many terms in the series need to be 
 used to achieve the desired precision. For series that are “well behaved,” a good strategy 
 is to use enough terms so that the first unused term is smaller than the allowable error. 
 For an example of coding this technique, look at the implementation of the StruveH 
 function in the package 
 ProgrammingExamples
 ' S tru v e '. This package is described in 
 detail in [Maeder 91].
  
 If the convergence rate of the series is harder to check, you can let the built-in 
 func-tion NSum do the hard part for you. NSum takes options called T argetP recision 
 and W orkingPrecision that allow you to set goals for the numerical properties of the 
 result, albeit indirectly. It is important to use the correct method of convergence 
 check-ing (there are two). A discussion of them is beyond the scope of this book; see 
 [Keiper 93a] for more information.
  
 If you wish to define an upvalue for S eries [f [x] , 
  
 . . .  ], you should be aware 
 that you can take any expression and turn it into a SeriesD ata object simply by add-ing 
 a term of the form 0 [x] 
 An.
  For example,
  
 This is an upvalue associ-
 e 
 /: 
 S e r ie s [ e
  [x_], {x_, 0, n_}] := 
  
 ated with the symbol e. 
  
  
 Sum
 [xAk 
 / 
 k ! , {k, 0, n}] 
 + 
 0 [x ]A(n 
 + 
 1)
  
 Series[e[z], {z, 0, 5}]
  
 7
  
 3 
  
 4 
  
 5
  
 Head [%]
  
 SeriesData",NA
9.4 Custom Output Formats,NA,NA
9.4.1 Format values,"Mathematica
  allows you to define custom output formats for expressions by creating 
 format values.
  A format value is defined using the Format function:
  
 This rule is attached to the B 
 esselJ symbol.
  
 B esselJ functions now 
  
 print in a traditional format.
  
 Unprotect[BesselJ]; 
  
 Format[BesselJ[n_, x_] ] := Subscripted[J[n]] 
 [x] Protect[BesselJ];
  
 B e s s e lJ  [ 1 , P i / 2 ]
  
 It is important to keep in mind that formatting functions such as Subscripted are just 
 “wrappers” that affect only the displayed form of an expression, and not its internal 
 value:
  
 The expression still is a call to 
 B esselJ.
  
 FullForm[%] 
  
 BesselJ[n, x]
  
 Format value rules are attached to the symbol for which they are defined, not to the 
 Format function (much like Nvalues); that is why it was necessary to unprotect the B 
 esselJ function before defining the format value above. The format values for a symbol 
 can be listed using FormatValues 
 [sym
 ] :
  
 Users of versions prior to 3.0 w 
 ill see only the second of these 
 rules.
  
 FormatValues[BesselJ] // InputForm 
  
 {HoldPattern[ 
  
  
 MakeBoxes[BesselJ[n_, x _ ] , FormatType_]] :>
  
 ToBoxes[Subscripted[J[n]] [x], FormatType],
  
 HoldPattern[BesselJ[n_, x_]] :>
  
 Subscripted[J[n]] [x]}
  
 Subscripted is one of a number of formatting wrappers that produce two-
 dimen-sional output, but all of the others take sequences of individual expressions. 
 Some examples of these functions are Subscript, Superscript, O verscript (version 3.0 
 only), U nderscript (version 3.0 only), and Subsuperscript (version 3.0 only). For 
 example,
  
 Overscript[x, ""_""]
  
 x
  
 WjHpr 
  
 The way that S ubscript and S u p erscrip t work has been changed in version 3.0. In 
 earlier versions, the arguments to these functions were considered to be all subscripts or 
 all superscripts, and the way to produce a superscripted variable, for example, was to",NA
9.4.2 Output formats,"There are many different available output formats, such as InputForm, OutputForm (the 
 default for version 2.2), StandardForm (the default for version 3.0), T ra d itio n - 
 alForm (a new format in version 3.0 that mimics traditional mathematical notation), 
 TeXForm, CForm, and FortranForm. StandardForm and T raditionalForm  are based on 
 a completely new 
 box representation
  of two-dimensional input and output (see the first 
 of the two rules for FormatValues [BesselJ] on page 274). The advan-tage of the box 
 representation is that it can be used for two-dimensional input as well as output (cf. the 
 string representation on page 276, which is useless as input). A discus-sion of these 
 forms would require a discussion of box representation, which is outside the scope of the 
 current volume. This topic will be addressed in a future companion vol-ume on the 
 Mathematica
  user interface.",NA
9.5 Respect Existing Definitions,"You should never modify the state of the user’s session unnecessarily. There are many 
  
 aspects of global state, including external rules for built-in functions, the protected sta-
  
 tus of functions, and system variables that may have been given specific values by the 
  
 user.",NA
9.5.1 Preserve existing definitions,"Some “built-in” functions are actually implemented, wholly or in part, outside of the 
  
 kernel! Members of the Expand family are good examples of this. The definition for 
  
 ExpandNumerator in version 2.2 basically applies Expand to the Numerator of the 
  
 input and divides the result by the Denominator of the input:
  
 D o w n V a lu e s [E x p a n d N u m e ra to r]
  
 { H o ld P a tte r n [E x p a n d N u m e r a to r [S y s te m 'P r iv a te 'in p u t_ ,
  
 S y s t e m 'P r iv a t e 'o p t io n s ____] ] :>
  
 I f [ H e a d [ S y s t e m 'P r iv a t e 'in p u t ] 
  
 === P lu s ,
  
 (E x p a n d N u m e ra to r[# 1 ,
  
 S y s t e m 'P r iv a t e 'o p t io n s ] 
  
 & ) 
  
 l@
  
 S y s t e m 'P r i v a t e 'i n p u t ,
  
 E x p a n d [N u m e r a to r [S y s te m 'P r iv a te ' in p u t ]  .
  
 S y s t e m 'P r iv a t e 'o p t io n s ] 
  
 /
  
 D e n o m in a t o r [ S y s t e m 'P r iv a t e 'in p u t ] ] }
  
 (In version 3.0, the external downvalue for ExpandNumerator does some preprocess-
  
 ing of options and then calls the hidden function System'Dump' expandNumerator, 
  
 which has an external downvalue that looks a lot like the one shown above.)
  
 fl y
  
  
 The point of this example is that you should never Clear a built-in function, because 
 you might break it!",NA
9.5.2 Proper use of Protect and Unprotect,"It is quite often the case that you want to override the behavior of a built-in function. 
 The preferred way to do this is by using upvalues. Sometimes, however, there is no 
 choice but to add downvalues to a built-in function, which requires unprotecting the 
 function. A common mistake is to then reprotect the function without regard to what its 
 state was before the new definitions were made.
  
 For example, suppose you have written a package that modifies the built-in function 
 F, and suppose that a user had unprotected F and then loaded your package. If your 
 package outline is
  
 U n p r o t e c t [ F ] ;
  
 ( *  d e f in e  new  v a lu e s  f o r  F * )
  
 P r o t e c t [ F ] ;
  
 then after loading your package, the user will find that F is once again protected! While 
 this is at most a minor annoyance in an interactive session, think about what would 
 hap-pen if your package were loaded inside of 
 another
  package that modified F:
  
 B e g in [ "" o t h e r p a c k a g e '""] ;
  
 U n p r o t e c t [ F ] ;
  
 Protects F. 
  
 N eeds [ "" y o u r 'p a c k a g e '""] ;
  
 Causes an error! 
  
 F [ . .  ] 
  
 : =  . . .
  
 P r o t e c t [ F ] ;
  
 E n d P a c k a g e [];
  
 This package will fail to load properly because its attempted creation of a downvalue for 
 F will fail.
  
 The P ro te c t and U nprotect functions have a feature that, if used conscientiously by 
 all parties, avoids this problem. U nprotect returns a list of the symbols passed to it that 
 were in fact protected before the call. For example:
  
 O nly one of these symbols is 
 protected.
  
 x ; y ; P r o t e c t  [x ] ;",NA
9.5.3 Preserving global variables,"There are many global variables that affect the state of the system as a whole. These 
 variables all begin with the $ character. Of particular interest here are those variables 
 that contain functions that are applied at various stages in the evaluation process:
  
 $PreRead — applied to every input string before it is parsed.
  
 $Pre — applied to every input after it has been parsed, but before it is passed to the 
 main evaluation loop (Section 7.1.3).
  
 $Post — applied to every expression after it is evaluated but before the result is 
 assigned to Out [u].
  
 $P reP rint — applied to every expression after it has been assigned to Out [n], but 
 before it is printed.
  
 Judicious use of these functions can give the user a lot of control over the behavior of 
 Mathematica.
  For example, one could use the following value for $P reP rint in order to 
 make 
 Mathematica
  print all approximate numbers in scientific notation:
  
 $ P r e P r in t  =  S c ie n t if ic F o r m ;
  
 Here's an example of the 
  
 3 7 3 .4
  
 2
  
 effect of the definition. 
  
 3 .7 3 4  10
  
 As a developer, you may want to define a value for one of the 
 $ global
  functions, but 
 in doing so you should not wipe out any value that has been defined by the user! For 
 example, suppose that the user had defined:
  
 $ P r e P r in t  =  S h o r t;
  
 S h o rt is now applied to 
  
 Range [1 0 0 , 
  
 1 2 0 , 
  
 .1 ]
  
 « 1 9 5 » , 
  
 1 1 9 .9 . 
  
 1 2 0 .)
  
 every result before printing. {10Q< 
  
 1 0 0
  - i i 
  
 1 0 0 .2 , 
  
 1 0 0 .3 .",NA
9.6 Application: Defining a New Data Type,"In this section we will take on one of the most challenging problems that any 
 program-mer can face: defining a completely new data type and making it look as 
 though it is built in. The data type that we will define is an integer prime factorization, 
 inspired by one of the examples discussed in Section 9.4.1. This exercise will bring 
 together many of the techniques that have been developed in this and earlier chapters.",NA
9.6.1 Design issues,"We could define a factorization data type as a product of the IntegerPower objects 
 introduced in Section 9.4.1, but there’s a problem with this approach. The problem is 
 that some factorizations would have the head Times, while others (those with a single 
 prim p, 
 factor) would have the head IntegerPower. Having two possible representa-tions 
 for a factorization would complicate the logic for every rule we have to write. 
 Fur-thermore, it would be nontrivial to figure out if a given expression with head Times 
 represented a factorization or not. A less obvious, and even more troublesome, problem 
 is that there is no way, short of fully parsing an expression, to determine whether or not 
 an IntegerPower object is part of a larger factorization. This is important, for exam-ple, 
 in order to be able to create a rule that turns a solitary IntegerPower [p, 1] into the 
 integer 
 p
  (which would be an incorrect thing to do if the IntegerPower were part of a 
 larger factorization). Therefore, we consider this approach to be fundamentally flawed. 
 Instead, the data type that we develop here will have a unique head, F acto r-iz atio n .
  
 A factorization w ill havethis 
  
 f a c t z n  =  F a c t o r i z a t i o n  @@ F a c t o r ln t e g e r  [2 3 8 5 0 0 ]
  
 simple representation. 
  
 F a c t o r i z a t i o n  [ 12 , 2 } , 
  
 { 3 , 
  
 2 ) , 
  
 { 5 , 3 } , 
  
 (5 3 , 
  
 1 }]",NA
9.6.2 Formatting,"We will construct a formatting rule for F a c to riz a tio n  objects from low-level 
 for-matting primitives. Each pair {a, b} in the F acto rizatio n  object will be formatted 
 as ab, and each pair {a, 1} will be formatted simply as a. Also, we will want a space 
 character between every pair of factors. Therefore, we will apply the following two 
 rules to a F a c to riz a tio n  object:
  
 f o r m a t r u le s  =  t
  
 Note the blank character
  
 { a _ , 
  
 1 } ->  S e q u e n c e F o rm [a , "" "" ] ,
  
 "" ""]
  
 { a _ , b _ } ->  S e q u e n c e F o rm [a , S u p e r s c r ip t [ b ] , 
  
 };
  
 F a c t o r i z a t i o n [ { a ,  b } , 
  
 [ c ,  d }] 
  
 / .  f o r m a t r u le s
  
 after each superscript.
  
 „ F a c t o r i z a t i o n  La 
 . • 
  
 r 
 b 
  
 , c d i J",NA
9.6.3 Overriding Factorlnteger,"As the next step toward integrating the F a c to riz a tio n  data type into the system, we 
 will override F acto rln teg er to produce a F acto riz a tio n  directly. First, we 
 unpro-tect F actorlnteger, being careful to save its protected status.
  
 w a s P ro te c te d  =  U n p r o t e c t [ F a c t o r ln t e g e r ]
  
 ( F a c t o r ln t e g e r )
  
 Overriding F acto rln teg er brings up an interesting issue, namely that our defini-tion 
 for F acto rln teg er has to call the “real” F acto rln teg er to factor the integer in the first 
 place! Without a bit of care, we could easily wind up in an infinite recursion. The 
 uninspired way out of this dilemma would be to define a function having a different 
 name, but we want our new data type to be integrated as seamlessly as possible into the 
 system. Therefore, we will create a new rule for F actorlnteger, but we must some-how 
 ensure that our rule is not matched when we make the recursive call.
  
 The following technique is due to Robby Villegas. A global variable,4 in tercep t, is 
 used inside of a rule condition to control whether or not the rule matches. When the rule 
 does match, the rule immediately uses Block to set in te rc e p t to False for the duration 
 of its execution. Thus, any nested calls to F acto rln teg er will not match this rule, 
 because the rule condition will fail. When the rule is through executing, Block 
 automatically restores the previous value of in te rc e p t. A hidden advantage of using 
 Block for this purpose is that, even if the user aborts the computation, in te rc e p t will 
 still be reset correctly.
  
 4. Naturally, when we put these definitions into a package, this variable will be 
 hidden 
  
 inside of the package’s 
 private subcontext
  (Section 8.2.1).",NA
9.6.4 Expanding Factorizations,"So far, so good! Now we need to create a function that turns a F a c to riz a tio n  back 
  
 into an integer. We already developed such a function, back in Section 5.1.3:
  
 E x p a n d F a c t o r iz a t io n [ x _ F a c t o r iz a t io n ] 
  
 ;=
  
 T im e s  @@ A p p ly [P o w e r, x , { 1 } ]
  
 E x p a n d F a c t o r iz a t io n [x _ ] 
  
 :=  x
  
 E x p a n d F a c t o r iz a t io n  /@ t
  
 { 0 , 
  
 1 , 2 , 3 , 
  
 4 , 5 , 
  
 6 . 
  
 7 , 
  
 8 , 9 , 
  
 10}
  
 Note that E xpandFactorization will not do anything unless its top-level argu-
  
 ment is a F acto rizatio n . If the F a c to riz a tio n  is an element at some lower level, 
  
 nothing will happen:
  
 5. Users o f version 2.2 and earlier take note: Prior to version 3.0, F a c t o r ln t e g e r
  
 acted as an identity operator on the integers -
  1
  ,
  0
  , and 
 1
  , which leads to an error
  
 message. You can fix this by making special-case definitions fo r these inputs.",NA
9.6.5 Multiplication rules,"The product of two factorizations should be another factorization. The way things are 
 now, however, factorizations do not combine automatically:
  
 f 2 4  =  F a c t o r l n t e g e r [2 4 ] ;
  
 f l
  8
   =  F a c t o r l n t e g e r [ 1 8 ] ;
  
 f 2 4  * f 18
  
  
 2 
  
 2 3 
  
 3 2 
  
 3
  
 As a first step toward simplifying expressions of this type, here is an upvalue for F 
 acto rizatio n  with respect to Times that turns a product of two factorizations into a 
 single factorization:
  
 J o in  works on any expres- 
  
 F a c t o r i z a t i o n  / :
  
 :=  J o i n [ x , y ]
  
 sions that have the same 
 head.
  
 x _ F a c t o r iz a t io n  * y _ F a c t o r iz a t io n 
  
 In p u tF o r m [f2 4  * f l
  8
  ]
  
 F a c t o r i z a t i o n [ { 2 , 
  
 1 } , 
  
 { 3 , 
  
 2 1 , { 2 , 3 } ,  { 3 , 
  
 1 }]
  
 Obviously, we have more work to do. Now we need a rule that combines matching 
 prime factors inside of a factorization. This rule will be easier to write and more 
 effi-cient if we give F a c to riz a tio n  the O rderless attribute.
  
 S e t A t t r i b u t e s [ F a c t o r i z a t i o n ,  O r d e r le s s ]
  
 A step in the right direction. 
  
 In p u tF o r m [f2 4  * f l
  8
  ]
  
 1 } , 
  
 {2 , 
  
 3 ) ,  ( 3 , 
  
 1 ) ,  { 3 , 
  
 2 } ]
  
 F a c t o r i z a t i o n [ { 2 , 
  
  
 Because of the O rderless attribute, we know that any two matching prime factors 
 must be consecutive, which makes combining them quite easy:
  
 F a c t o r i z a t i o n [ h ______, 
  
 { a _ , b _ } , { a _ , c _ } , t
  ____
  ] 
  
 :=
  
  
 F a c t o r i z a t i o n [ h , 
  
 { a , b +  c } , t ]",NA
9.6.6 Rules for powers,"Despite our rules for multiplication, 
 quotients
  of factorizations do not simplify: 
  
 f24 / f 18
  
 3 23
  
 2 32
  
 The reason for this behavior is that the denominator is a multiplicative term of the form 
 P 
 o w e r  
 [F a c to riz a tio n [. . 
  
 , 
  
 -1], which prevents it from combining with the F 
 acto rizatio n  in the numerator.
  
 FullForm[%]
  
 Times[Power[Factorization[List
 [2, 
 1], 
 L i s t [3, 
 2]],
  
 -1], 
 Factorization[List
 [2 , 
 3], List[3, 
 1]]]
  
 Likewise, powers of F acto rizatio n s do not simplify, and furthermore they look 
  
 terrible:
  
 The apparent exponent of 32 
 actually is the textual 
 concatenation of the expo- 
 nents 3 and 2.
  
 f 24 A 2
  
 22
  
 3 
 2
  
 It’s quite easy to write a rule to take care of these problems.
  
 Factorization /: 
  
  
 Power[a_Factorization, b_Integer | b_Rational] := 
  
 a /. {x_. y_) -> (x, y b}
  
 { 
 f24 
 / 
 f
 18
 , f24 A 2, 
 Sqrt
 [f24]}
  
 (22 3’1 . 26 32 , 23«  31/2)
  
 l / %
  
 13 2 ' 2 , 2‘6 3’2 . 2 - <3/2) 3 - (i/2> )
  
 Incidentally, the parentheses in the exponents of the last two results were inserted 
 automatically by the output formatter, because the precedence of unary minus is greater 
 than the precedence of multiplication. For a complete discussion of how precedence",NA
9.6.7 Addition rules,"Finally, here are some rules for addition of factorizations. The straightforward way to 
  
 implement addition would be with a rule like this:
  
 Plus[a_Factorization, b_Factorization] :=
  
 Factorlnteger[
  
 ExpandF actorizatlon[a] + ExpandFactorization[b]
  
 ]
  
 This rule relies on the Flatness of Plus to handle longer sums. However, this rule 
  
 would be very inefficient for sums of many terms, because of all the conversions back 
  
 and forth between factored and unfactored forms. Instead, we would like to write a rule 
  
 that will handle a sum of any number of factorizations all in “one fell swoop.”
  
 Toward this end it will prove convenient to add a rule to ExpandFactorization 
  
 that takes a Sequence of factorizations as an argument and returns a Sequence of 
  
 integers as a result.
  
 ExpandFactorization[x
 _
 Factorization] :=
  
 Sequence @@ ExpandFactorization /@ {x}
  
 Here's what this rule does. 
  
 And here's what we'll 
 do 
  
 with the result. 
  
 E x p a n d F a c t o r iz a t io n  [ f 2 4 , f l
  8
  ]
  
 S e q u e n c e [2 4 
 , 
  
 18]
  
 Plus 
 [%] 
  
 ^
  
 Now it should be quite clear how to write a rule for Plus that handles any number of 
  
 factorization arguments at once:
  
 Factorization /:
  
 Plus[a__Factorization] :=
  
 Factorlnteger[Plus[ExpandFactorization[a]]]",NA
9.6.8 Nvalues,"Factorization 
 provides an uncontrived illustration of the use of Nvalues. When N is 
 applied to a 
 Factorization, 
 the result should be a number, but it’s not:
  
 N[Factorlnteger[
 8
  ] ]
  
 2 .3'
  
 To recast the discussion of Section 9.3.3 into the present context: Since F a c to riz a -tio 
 n  [ {2, 3}] does not evaluate to a numeric quantity, N applies itself to all parts of that 
 expression, which results in the intermediate form F acto rizatio n  [ {2. , 3 .} ]. N then 
 attempts to evaluate this new expression, which still evaluates to itself.
  
 We can solve this problem by defining an Nvalue that expands a factorization into a 
 product of powers when N is applied. After expansion, N applies itself again, resulting 
 in a numerical answer.
  
 N[a_Factorization, _] := ExpandFactorization[a]
  
 N[Factorlnteger[
 8
  ]]
  
 8.
  
  
 Note that we can ignore the precision argument because the 
 second
  application of N 
 does all the numerical work.",NA
9.6.9 Modifying $Pre,"Suppose we want to set things up so that anytime the user entered a manifest prime 
  
 raised to a manifest integer exponent, the expression would be converted to a F acto r-
  
 iz atio n . We could effect this behavior by applying a rule of the form 
  
 Power[a_?PrimeQ, b_Integer] -> F a c to riz a tio n [{a, b}] to every user 
  
 input 
 before
  it evaluates.
  
 Here is the function that we will use. Note that the function must hold its argument, 
  
 or else the powers would simplify before it had a chance to act on them.
  
 SetAttributes[AutoFactor, HoldFirst]
  
 AutoFactor[command_] :=
  
 Unevaluated[command] /.
  
 a_?PrimeQ A b_Integer -> Factorization[{a, b}]
  
 AutoFactor[g[2A3 , 3A2 + 1]]
  
 g [ 2 3 , 
  
 2 5]
  
 The question is, How do we apply AutoFactor to every user input? We accomplish 
  
 this by assigning AutoFactor to the global variable $Pre (Section 9.5.3).
  
 Before assigning to $Pre ... 
  
 g [ 2 A3 , 
  
 3 A2 +  1]
  
 g [
  8
  . 
  
 1 0
  ]
  
 $Pre = AutoFactor;
  
 and after. 
  
 g [ 2 A3 , 
  
 3 A2 +  
 1
  ]
  
 g [ 2 3 , 
  
 2 5]
  
 Naturally, production-quality code would save the user’s value of $Pre before mak­
  
 ing this assignment.",NA
9.7 Additional Resources,"Mark Sofroniou has written a package called 
 FormaLm
  that provides a totally rewritten 
 set of formatting primitives for C, Fortran, TeX, and Maple. This package is available 
 from 
 MathSource
  as item #0205-254.",NA
Part ,NA,NA
4 Programming ,NA,NA
for Performance,NA,NA
10,NA,NA
Performance Tuning,"For many users the principal drawback of 
 Mathematica
  is its lack of speed relative to 
 other programming tools. Being an interpreted language, 
 Mathematica
  is of course 
 slower than compiled languages such as C or Fortran. The very features that make 
 Mathematica
  so powerful — dynamically typed data, pattern matching, and the very 
 general way in which expressions are evaluated (Chapter 7, “Expression Evaluation”)— 
 also exact a toll on performance.
  
 Most of the time, however, what is perceived to be a problem with 
 Mathematica 
 actually is a problem with the way that the code is written; a different solution in 
 Mathematica
  may be many times faster, and certain built-in functions rival the speed of 
 compiled languages. In this chapter we examine the intricate details of performance- 
 tuning 
 Mathematica
  code.
  
 There are several general rules of thumb. Some of them are obvious, such as using 
 special-purpose built-in functions whenever possible; others are quite unobvious, such 
 as avoiding in-place modification of large lists. The 
 what
  of most of them can be arrived 
 at through experimentation, but the 
 why
  sometimes requires a deep understand-ing of 
 how 
 Mathematica
  evaluates expressions.
  
 Some of the techniques for tuning 
 Mathematica
  code basically are “tweaks” that 
 speed up a computation by a constant factor; others can result in qualitatively different 
 time, complexities — for example, reducing a computation’s time complexity from 
 qua-dratic in the problem size to linear. Simply incorporating a few new programming 
 idi-oms into the code may be all that is necessary.
  
 Another method for speeding up a program is to use the internal compilation facility. 
 The speedup gained through compilation can be substantial, and the technique is quite 
 easy to use (modulo a few “gotchas,” of course). Unfortunately, the compiler can 
 han-dle only a limited set of 
 Mathematica
  expressions in version 2.2; the capabilities of 
 the compiler are greatly expanded in version 3.0.",NA
10.1 Rules of Thumb,"There are many general strategies, or “rules of thumb,” of which one needs to be aware. 
 Most of these rules can be arrived at through experimentation, but to really understand 
 them requires an understanding of the evaluation process (Chapter 7). In this section 
 we’ll list the rules and give examples to motivate them. In later sections we’ll examine 
 techniques for avoiding some of the pitfalls pointed out here.
  
 Incidentally, the rules here are 
 not
  necessarily presented in order of their impact on 
 performance, but rather in the order that makes the presentation as coherent as possible.",NA
10.1.1 Rule 1: Use built-in functions,"This rule is not surprising, since built-in functions are (with a few exceptions) 
 imple-mented in the kernel, which is written in C. There are various overheads involved 
 in evaluating general expressions (see Chapter 7) that are not a factor inside of an 
 internal function. In general, pick the method that moves as much of the computation as 
 possi-ble into the internal code.
  
  
 As a simple example, suppose we wish to sum the squares of the first 5000 integers. 
 This could be done quite easily using any of the looping constructs.
  
 {s, i} = {
 0
  , 
 1
  }; 
  
 While[i <= 5000, s += iA2; i++] // Timing 
 s
  
 {3.26667 Second, Null}
  
 41679167500
  
 For no obvious reason, a For 
 loop is a bit faster than an 
 equivalent W hile loop.
  
 A Do loop is quite a bit faster 
 than either of those.
  
 s = 
 0
  ; 
  
 For[i =1, i <= 5000, i++, s += iA2] // Timing
  
 {2.98333 Second, Null)
  
 s = 
 0
  ; 
  
 Do[s ■+= iA2 , {i, 5000}] // 
 Timing
  
 {2. Second, Null)
  
 None can match the speed of 
 a special-purpose func-tion 
 like Sum, however.
  
 Sum[iA2, {i, 5000}] 
 II
  Timing 
 {0.933333 Second, 41679167500}",NA
10.1.2 Rule 2: Program functionally,"The basic goal when using functional programming techniques to improve performance 
 is this: Try to apply operations to as much of the data at one time as possible. (This rule 
 is just another facet of the general strategy of trying to push as much of the computation 
 as possible into the kernel’s internal routines.) This strategy is facilitated by the fact that 
 all numerical functions are listable (Section 3.3), and for those functions that aren’t, 
 Map, Apply, etc. can be used.
  
 Therefore, a good general approach to the example introduced in the previous sec-tion 
 is to generate a list of all of the summands, and then apply Plus to it. There are several 
 different ways to generate the list of summands, and a little experimentation shows their 
 relative speeds.
  
 Using T a b le  to generate the 
 list of squares is probably the 
 most obvious method.
  
 The effect of squaring the 
 entire list at once is quite 
 noticeable.
  
 A further improvement 
 comes from replacing 
 Table with Range.
  
 P lu s  @@ T a b l e [ i A2 , 
  
 { i ,  5 0 0 0 } ] 
  
 / /  T im in g
  
 {Q _9 Second> 
  
 4 1 6 7 9 1 6 7 5 0 0
  }
  
 Plus @@ (Table[i, {i, 
 5 0 0 0 } ]A2) / / 
  
 Timing
  
 {0 .6 3 3 3 3 3  Second, 41679167500}
  
 P lu s @@ (Range [5000] A2) 
 II
  Tim ing
  
 {Q 55
  Second) 4 i 679167500}
  
 Note again that the more specific operator (Range) is more efficient than the more 
 gen-eral operator (Table) because more of the computation is done inside of the kernel.
  
 Of course, the strategy suggested here is trading memory for time. When there is not 
 enough memory available to hold all of the intermediate results at one time, a 
 proce-dural solution may be a better alternative. Furthermore, other factors such as the 
 use of virtual memory can affect the performance of functional programming algorithms 
 sig-nificantly.",NA
10.1.3 Rule 3: Use machine-precision arithmetic,"When the eventual answer is going to be an approximate number, and machine-preci- 
 sion arithmetic does not pose numerical problems, convert numbers to machine 
 preci-sion as early as possible in the computation.
  
  
 Let us change the example problem so that instead of summing squares, we sum 
 square roots. A sum of 5000 symbolic square roots is of dubious value; we almost cer-",NA
10.1.4 Rule 4: Evaluate when possible,"Functions such as For, Sum, and P lo t evaluate their first argument numerically at 
 sev-eral values of an independent variable. Such arguments are always 
 held
  (that is, not 
 evaluated before the function is called):",NA
10.1.5 Rule 5: Compile when possible,"Another technique that NSum uses is to 
 compile
  the summand into 
 pseudocode
  before 
 evaluating the sum.3 The pseudocode is basically an assembly language program for an 
 idealized register machine that is implemented by the kernel. This pseudocode can be 
 evaluated much more quickly than the equivalent normal expression.
  
 Compilation is directly available to the programmer as well. Note the speed increase 
 achieved by compiling a simple expression like ( i - l ) / ( i  + 1):
  
 Sum[(i - l . ) / ( i +  1 .), {i, 1., 5000., 1.}] 
 II
  Timing
  
 {1 .2 3 3 3 3  S eco nd , 4 9 8 3 .8 1 }
  
 The syntax for Compile is 
 similar to the syntax for F u n 
 ctio n . 
  
 c f  =  C o m p ile [ { x } , 
  
 (x  -  l . ) / ( x  +  1 . ) ]
  
 x  - 
  
 1
  
 C o m p lle d F u n c tlo n [ { x } , — + 
  
 ' , 
  
 -C o m p ile d C o d e -]
  
 Sum[cf[i], {i, 1., 5000., 1.}] // Timing
  
 [0 .9 1 6 6 6 7  S eco nd , 4 9 8 3 .8 1 }
  
 The speedup can be even more dramatic when the compiled function is less trivial. Not 
 all 
 Mathematica
  expressions can be compiled, unfortunately. We’ll discuss the 
 subtle-ties of compilation in Section 10.5.",NA
10.1.6 Rule 6: Avoid Append and Prepend,"This is one of the most important rules. Append, Prepend, and their ilk, when they 
 appear inside of a loop, are like a death sentence for performance purposes. Consider the 
 following two methods for generating a list of 1000 numbers:
  
 Table[i, {i. 1000}]; / /  Timing
  
 {0 .0 3 3 3 3 3 3  S eco nd , N u ll)
  
 s =  { } ; 
  
 Do[AppendTo[s, i ] , {i, 1000}]; // Timing 
  
 {2 .1 1 6 6 7  S eco n d , N u l l)
  
 This is an example in which the blame could mistakenly be placed on the looping 
 construct. In fact, the loop itself is quite speedy:
  
 Do[x = i, {i, 1000}]; 
 II
  Timing
  
 { 0 .0 5  S eco nd , N u l l )
  
 3. Many other functions (e.g., Plot) also compile some of their arguments. You can 
 find out which ones do so by searching for functions having the Compiled 
 option (using the techniques of Section 7.3.5).",NA
10.1.7 Rule 7: Do not modify large lists in place,"In-place modification of large lists is extremely inefficient in 
 Mathematica.
  As an 
 example, consider the following two ways of computing the first moving average of a 
 list of numbers:
  
 Here the result is computed 
 in place (i.e., it replaces 
 the original data). 
  
 s = Range [1 0 0 0 ]; 
  
 Do[s[[i]] = (s [ [i] ] + s [ [ i  + l ] ] ) / 2 , 
  
  
 { i t Length[s] - 1}]; 
 II
  Timing
  
 (3 .0 1 6 6 7  S eco nd , N u l l)
  
 Here the result is stored in a 
 different list than the origi- 
 nal data. The creation of 
 the 
 destination list is 
 included in the timing. 
  
 s = Range [1 0 0 0 ];
  
 ( t  = T a b le [0 , 
  
 { 1 0 0 0 } ];
  
 D o [ t [ [ i ] ]  = ( s [ [ i ] ]  + s [ [ i + 
 1] 
 ] )
  / 2
  ,
  
 {i>  L e n g th [s ] 
  
 - i } ] ; ) / /  T id in g
  
 , „ „,
  
 (0 .6 3 3 3 3 3  S eco n d , N u l l)
  
 In Section 7.3.3 we explained that this disparity is due to the way that the kernel 
 evaluates an expression like s [ [i] ] if s has been modified since its last access. The 
 evaluation process requires a scan of each element of s to check for upvalues, which 
 takes time proportional to the length of s (review Section 7.3.3 for a more in-depth 
 explanation). Thus, in the first algorithm s undergoes a scan on each loop iteration, 
 which makes the running time 
 quadratic
  in the length of the list, rather than linear.
  
 Unfortunately, there are three possible drawbacks to the second approach: First, the 
 length of the result may not be known in advance; second, it may result in a lot of 
 unnecessary data movement; and third, the list may be just too large to copy. There are 
 other solutions to this problem, and they will be discussed in Section 10.2.2.",NA
10.1.8 Rule 8: Beware of inefficient patterns,"Pattern matching and rule replacement often provide some of the most elegant solutions 
 to a particular problem. However, incorrect use of these techniques can drastically 
 impair performance.",NA
"10.1.9 Rule 9: Use #, &-style pure functions","This is completely unobvious, but a pure function defined using # and & is faster than a 
 “normal” function.4 Surprisingly, however, a definition using Function is about as slow 
 as a normal function. Here is an example:
  
 func
 1
  [x_] := x
 A-2 
  
 func2 = Function[{x}, xA-2]; 
  
 func3 = #A-2 &;
  
 z = Range[5000.]; 
  
 fund /@ z; // Timing
  
 (2.01667 Second, Null)
  
 func2 /@ z; 
 II
  Timing
  
 {2.08333 Second, Null]
  
 func3 /@ z: 
 11
  Timing
  
 {1.25 Second, Null)
  
  
 There are several things that might explain why the #, & form is faster than the 
 nor-mal function: no pattern matching is taking place, there is no search for upvalues or 
 attributes, etc. However, the relative slowness of the Function [
 params, 
  
 body
 ] 
 form is a mystery.",NA
10.2 Procedural Perils,"A handful of terribly inefficient procedural programming techniques are what give 
 pro-cedural programming in 
 Mathematica
  a bad reputation. A handful of new 
 procedural programming idioms are all that the programmer needs to avoid these 
 problems.",NA
10.2.1 Building up large lists,"f l y
  
 The problem with building up lists an element at a time is that 
 Mathematica
  lists are 
 implemented as arrays. The advantage of this implementation is that a list can be 
 ran-domly indexed in time that is independent of the length of the list; the disadvantage 
 is that every time, an element is added to or taken away from a list, the list has to be 
 copied into a new list — leading to a quadratic time complexity for algorithms that 
 build up large lists one element at a time.
  
 Consider the problem of writing a function that merges two sorted lists, which is an 
 essential component of a 
 mergesort
  algorithm (Section 5.4.2). Here is a (bad) 
 proce-dural algorithm for doing this:
  
 4. Allan Hayes first pointed this out to the author.",NA
10.2.2 Modifying lists in place,"In Section 10.1.7 we pointed out that algorithms that read and write each element of a 
 list have time complexity that is quadratic in the length of the list, rather than linear as 
 might be expected. Writing all results to a second list provides a way around this 
 prob-lem, at the cost of extra memory. Figure 10-2 contains a graphical comparison of 
 the running times of the two moving-average algorithms given in Section 10.1.7, as a 
 func-tion of list size. The upper, quadratic curve represents the algorithm that modifies 
 the list in place; the lower, linear curve represents the algorithm that writes results to a 
 sec-ond list.
  
 Figure 10-2
  
 For simple computations on lists that are small enough to copy, writing results to a 
 second list works well. However, not all computations are so simple. An excellent 
 example of such a computation is the sorting algorithm known as 
 quicksort
  [Cormen et 
 al. 90]. Quicksort is essentially an extremely sophisticated “shell game” that per­mutes 
 data into sorted order by swapping strategically chosen pairs of data elements. Quicksort 
 is performed in stages (the actual number of stages depends on the data, although the 
 expected number is close to logn), and the number of data elements that move at each 
 stage typically is less than 
 n.
  Because of this, quicksort usually moves around many 
 fewer data elements than other sorting algorithms, enabling it to outper-",NA
10.3 Recursion Risks and Rewards,"Recursion is a very elegant programming strategy, but there are two problems with 
  
 using it in 
 Mathematica:
  First, it often doesn’t seem to be as fast as other solutions, and 
  
 second, it can’t be applied to very large problems because of evaluation stack size limi­
  
 tations. In this section we’ll show that both of these problems can be overcome.",NA
10.3.1 Building up list results,"Here is a recursive version of the merge function that we coded procedurally in 
  
 Section 10.2.1.
  
 rmergel[a_List, b_List] := 
  
 Which[ 
  
  
  
 a = { }  | | b =  t } , Join [a, b] .
  
  
 F irst[a] <= First[b] , 
  
  
   
 Prepend[rmergel[Rest[a], b ], F irst [a]] , 
  
  
 True, 
  
  
   
  
 Prepend[rmergel[a, Rest[b]] , F ir s t[b]] ]
  
 rmergel[{l, 5, 8}, {2, 3, 4, 7}]
  
 (1. 2, 3, 4, 5, 7, 8}
  
 Because deep recursion can crash the kernel, we test this function on small 
 bench-marks, computing averages over several runs to smooth out timing fluctuations. 
 Figure 10-6 contains a graph of the results, along with a quadratic curve fit. Clearly, the 
 time 
 complexity of this algorithm is quadratic.
  
 Figure 10-6
  
 The reason for the quadratic complexity of rmergel is the same as in the procedural 
 case: building up lists one element at a time (in this case, using Prepend). We can use 
 linked lists to solve that problem here as well. Here is a recursive merge function that 
 builds up a linked list of results as the recursion “unwinds.”
  
 rmerge2[a_List, b_List] := 
  
  
 Which[a =  {} || b =  {}, Join[a, b ], 
  
  
 F irst[a] <= F irst[b ], 
  
  
  
  
 { F irst[a], rmerge2[Rest[a], b ]} .
  
  
 True, 
  
  
  
 {First [b], rmerge2[a, Rest [b]]} 
  
 ]",NA
10.3.2 Tail recursion,"Recursion uses lots of memory for stack space. $RecursionLimit can be increased 
 somewhat, but increasing it too much can easily crash the kernel. Is there some way to 
 get the elegance of recursion without running into $RecursionLimit?
  
  
 The answer to this question turns out to be a qualified “yes.” Consider the following 
 two functions for computing the length of a list:
  
 This is the straightforward 
  
 l e n l  [x _ ] 
  
 :=  I f [ x = { } ,  0 , 
  
 1 +  l e n l  [R e s t [x ] ] ]
  
 recursive length function.",NA
10.4 Rewrite Rules,"We can avoid $RecursionLimit by using rewrite rules instead of recursion. In prepa-
  
 ration for that, let’s convert rmerge3 into a rule-based recursive function. As before, 
  
 we’ll use the linked-list “tricks” to achieve a linear running time.
  
 rbmergeO[a_List, {}] := a
  
 rbmergeO[{}, b_List] := b
  
 rbmergeO[{al_, arest_}, b:{bl_, _}] :=
  
 {al, rbmergeO[arest, b]} /; al <= bl
  
 rbmergeO[a:{al_, 
  
 , {bl_, brest_}] :=
  
 {bl, rbmergeO[a, brest]}
  
 rbmergeO[toLinkedList [{1, 5, 
 8
  }],
  
 toLinkedList[{2, 3, 4, 7}]] // Flatten
  
 {1, 2, 3, 4, 5. 7, 
 8
  )",NA
10.5 Compiled Functions,"Mathematica
  has a built-in compilation facility that can be used to speed up certain types 
 of computations. The compiler doesn’t translate 
 Mathematica
  code into actual machine-
 level instructions, because that would not be portable to versions of 
 Mathema-tica
  
 running on other machine architectures. Instead, the code is translated into a simple 
 register-based assembly language for a virtual machine that is interpreted by the kernel. 
 Even though this code is interpreted, it still executes much faster than 
 Mathematica 
 expressions do because it avoids the main evaluation loop.",NA
10.5.1 An example,"Here’s a simple example of a compiled function. It takes two arguments and computes the 
 ratio of their logarithms. We also define an uncompiled version of it for comparison.
  
 fl[x_, y j  := Log[x]/Log[y]
  
 cfl = Compile[{x, y}, Log[x]/Log[y]]
  
 CompiledCode-]
  
 The output of Compile is a CompiledFunction, which you should think of as being 
 analogous to a Function (e.g., pure function). A CompiledFunction object contains the 
 parameters to the function, the 
 Mathematica
  version of the code, and a list of 
 pseudocode instructions that print as -CompiledCode- in standard output form. You can 
 inspect these instructions using, e.g., InputForm, which we’ll do shortly.
  
 The compiled function is used in the same way as the uncompiled function. Note, 
 however, that the arguments to a compiled function and all of the arithmetic in the func-
  
 tion are assumed to be real.
  
 The integer arguments to c 
 f l are evaluated 
 numeri-cally before the 
 compiled function begins 
 executing.
  
 {f1[3, 4], cfl[3. 4]}
  
 {L o g [3 ] 
  
 , 0.792481) 
 0 7 9 248 1 )
  
 The compiled function is dramatically faster than the uncompiled function.
  
 Here is a list of pairs of real 
 numbers.
  
 data = Partition[ 
  
 Table[Random[Real, {2., 100.}], {3000}], 
  
 2]; 
  
 Short[data]
  
 ({90.8874, 5.70024), «1498>>, {78.5354, 4.13602))
  
 The compiled function is 
 about 4 times faster than the 
 uncompiled function.
  
 Timing[Apply[fl, data, {1}];] 
 {0.766667 Second, Null)
  
 Timing[Apply[cfl, data, {1}];]
  
 {0.133333 Second, Null)",NA
10.5.2 Compiled code,"We can use InputForm to inspect the actual pseudocode contained in a 
 Compiled-Function.",NA
10.5.3 Specifying types,"The general form of the parameter list to Compile is { {
 nam el, ty p e l
 } , {
 name2, type2
  
 } , . ..} . The types are specified as _Integer, _Real, _Complex, and True | F alse for 
 boolean. (We defer discussion of the tensor type to Section 10.5.5.) Note that types are 
 not specified the way they are for ordinary function declarations, e.g., c_Complex, and 
 that each {
 name, ty p e
  } pair must be in its own sublist, even if there is only a single 
 parameter.
  
 For example, here is a function that takes a boolean and a complex number as 
 argu-ments; if the boolean is True, the function returns the conjugate of the complex 
 num-ber, otherwise it returns the original number.
  
 7. Note that some of these instructions will be different in versions prior to 3.0. 
 A list-ing of all pseudocode instructions for version 2.2 can be found in 
 [Keiper 93a], At the time of this writing there is no official source for the 
 pseudocodes in version 3.0, although one will surely appear on 
 MathSource
  
 before long.",NA
10.5.4 Uncompilable expressions,"Now that we have discussed argument types, it’s time to explain what the compiler can 
 and cannot do. The compiler’s repertoire is limited to arithmetic and logical operations, 
 elementary functions, and procedural constructs such as If, Do, Module, etc. (The 
 ver-sion 3.0 compiler also can compile most list operations; see Section 10.5.5.) 
 Whenever the expression to be compiled contains any unknown functions — and this 
 includes many built-in functions as well as all user-defined functions — the compiler 
 generates instructions that evaluate those functions using the standard evaluation 
 process. Here’s an example:",NA
10.5.5 The tensor type,"In version 3.0 the compiler supports an additional type, the 
 tensor.
  A tensor is a 
 gener-alized vector; in 
 Mathematica,
  a tensor is a nested list in which every element at 
 the same level has the same number of subelements. The number of levels in a tensor is 
 called its 
 rank.
  For example, a list is a rank-1 tensor, and a matrix is a rank-2 tensor.
  
 In order to be used by the compiler, all elements of a tensor must be one of the three 
 numeric types supported by the compiler (integer, real, or complex), and all of the 
 ele-ments within a given tensor must be of the same type. Furthermore, the compiler 
 needs to know the rank of a tensor at compile time in order to generate code for 
 operations on it. Thus, tensor parameters have one extra element in their declaration, 
 namely, the rank of the tensor. For example, the following compiled function sums the 
 elements of a list that is passed as a parameter:
  
 s 
 is a rank-1 tensor with real 
 elements. 
  
 Sum a list of 
 100,000 
 real numbers. 
  
 csuml = Compile [{{s, _Real, 1}}, 
 Module [{i 
 = 
 0, sum =0.},
  
 ] :
  
 ]
  
 For[i =1 ,  i <= Length[s], i++. sum += s 
 [[i]]]; sum
  
 z 
 = 
 Range [1., 100000]; 
  
 Timing [csuml [z] 
 ]
  
 (1.36667 Second, 5.00005 109 }
  
 csuml 
 is much faster than 
 an uncompiled For 
 loop. 
  
 sum 
 = 
 0
  ; 
  
 Timing [For [i = 1, i <= Length [z] , i++, sum 4= z [ 
 [i] ] ] ]
  
 (50.8667 Second, Null}
  
 It is even faster than the 
 built-in Sian function. 
  
 Timing [Sum[z [ [i] ] , {i, 
 Length[z]}]] 
  
 n
  
 (9.83333 Second, 5.00005 10 }",NA
1,NA,NA
0.6 Additional Resources,"Two recent articles in the 
 Mathematica Journal
  ([Gayley 94a], [Hayes 95]) deal with a 
 number of techniques for writing efficient programs.
  
 A good description of internal compilation can be found in [Keiper 93a]. A list of 
 opcodes for version 2.2 of the compiler can be found on 
 MathSource
  in item #0201-889, 
 “The 
 Mathematica
  Compiler.”",NA
11,NA,NA
MathLink,"MathLink
  is a cross-platform communication protocol defined by Wolfram Research, 
 Inc. There is a C-library interface to 
 MathLink
  as well as a 
 Mathematica
  command- 
 based interface. 
 MathLink
  typically is used to communicate between a 
 Mathematica 
 kernel and a program written in a compiled language such as C, although it can also be 
 used for kernel-to-kernel communication or even C program-to-C program 
 communi-cation (without any 
 Mathematica
  involvement whatsoever).
  
 There are two typical uses for 
 MathLink.
  The first of these is to allow the kernel to 
 call functions written in another programming language. These functions may be part of 
 a pre-existing scientific application library, or they may have been written specifi-cally 
 for the purpose of performing some computation that is inefficient in 
 Mathema-
  
 tica.
  
 The other common use for 
 MathLink
  is to allow a C program to exploit the 
 computa-tional power of the 
 Mathematica
  kernel, or to provide a nicer interface to it. In 
 fact, the front end communicates with the kernel using 
 MathLink,
  which should give you 
 some appreciation of the protocol’s versatility. An example of an alternative front end is 
 the 
 MathLink for Excel and Mathematica
  program that is distributed by WRI, which 
 allows users to enter arbitrary 
 Mathematica
  expressions into spreadsheet cells.
  
 In the present context of performance enhancement, we are concerned mainly with 
 the first use of 
 MathLink,
  that is, calling other programs from 
 Mathematica.
  We will, 
 however, discuss how such programs can send 
 Mathematica
  expressions back to the 
 kernel for evaluation, which lays the foundation for constructing programs of the 
 sec-ond type. We also will discuss using 
 MathLink
  for kernel-to-kemel communication, 
 which can be used to implement large-grained parallel processing.
  
 At the time of this writing the only compiled language supported directly by 
 Math-Link
  is C. However, this does not exclude the use of other languages (e.g., 
 Fortran),",NA
11.1 ,NA,NA
MathLink,NA,NA
 Fundamentals,"In this section we will discuss the most basic aspects of the 
 MathLink
  C language 
 inter-face. Although it may seem as though there is a lot of drudgery involved, fear not! 
 There are some excellent higher-level tools provided with the 
 MathLink
  distribution that 
 simplify the construction of 
 MathLink
  programs enormously. We’ll begin introduc­ing 
 these tools in the next section. However, as with all things involving computers and 
 especially programming, some knowledge of the fundamentals can go a long way 
 toward figuring out what to do when the “canned” solutions don’t work.",NA
11.1.1 Hello world,"We begin with the 
 de rigueur
  demonstration of any programming language or 
 para­digm: the “hello world” program. Do not be dismayed by the apparent complexity 
 of the code shown below — over 90 percent of it (everything but the call to MLPut- 
 String) is “boilerplate” initialization and cleanup code that can be used in any 
 Math-Link
  
 program.1
  
 This header file must be 
 included in all 
 MathLink 
 programs.
  
 These data types are defined 
 in mathlink.h.
  
 Initialize 
 the 
 MathLink
  
 run-time environment and 
 open a link.2
  
 Send a string to the other 
 side.
  
 Wait until the other side of 
 the link is closed.
  
 Close the link and clean up 
 before exiting.
  
 #include ""mathlink.h"" 
  
 main(int argc, char **argv)
  
 { 
  
 MLEnvironment mlenv;
  
 MLINK mlink: 
  
 mlenv = MLInitialize((MLParametersPointer)0) mlink 
 = MLOpenArgv(argc, argv); 
  
 MLPutString(mlink, ""Hello world!""); 
  
 MLGetNext(mlink); 
  
 MLClose(mlink); 
  
 MLDeinitialize(mlenv);
  
 return 0;
  
 1. N.B.: If you are using the MacOS operating system, your program must 
 initialize the Macintosh toolbox before using any 
 MathLink
  calls, or else the 
 program may crash. See the documentation that comes with the 
 MathLink
  
 distribution for MacOS if you don’t know how to do this.
  
 2. Prior to version 3.0, MLOpenArgv was called MLOpen.",NA
11.1.2 Two-way communication,"Our next example is a function that sets a given bit in an integer. This is a task for which 
 Mathematica
  is not well suited; it would be necessary to break the integer up into binary 
 digits using In teg erD ig its 
 [num
 , 2], manipulate the resulting list of Os and Is, and then 
 reconstitute the answer as another integer using Homer’s rule (Section 5.3.3, “Fold”). 
 Although this is certainly doable, it’s ugly and inefficient. On the other hand, this kind of 
 “bit bashing” is easy to do in a low-level language like C.
  
 The external program shown below expects the kernel to send it two arguments, the 
 integer and a bit number, and the program returns the result of setting the given bit 
 number in the given integer. The boilerplate from the 
 hello
  example can be used 
 unchanged; merely declare the following variables at the beginning of main:
  
 in t n; 
  
 in t b ;
  
 and replace the call to MLPutString with the three calls shown below:
  
 Uiame
  passes 
 name
  as a 
 by- reference parameter. 
  
 MLGetlnteger (m link, &n) 
 MLGetlnteger (m link, &b) 
  
 ; 
  
 ;
  
 << is left-shiftand I is 
 logical 
 OR.
  
 MLPutlnteger (m link, n | 
  
 l<<b) ;
  
 3. L in k L a u n c h  is new to version 3.0. Users o f earlier versions should use L in k O p e n
  
 instead.",NA
11.1.3 A ,NA,NA
MathLink,NA,NA
server program,"The program of the preceding section, in addition to not being very robust, is rather 
 inefficient and user-unfriendly. First of all, it would be nice if the program would 
 con-tinue to execute after answering a request from the kernel, so that it could be 
 launched once but used repeatedly. This is quite easy to fix:",NA
11.2 Template-Based ,NA,NA
MathLink,NA,NA
 Programs,"In the last section we developed, from the ground up, a simple 
 MathLink
  server pro-gram 
 and a 
 Mathematica
  interface corresponding to it. This is such a common use of 
 MathLink
  
 that some tools exist for automating a large part of this process. The basic idea behind 
 these tools is that you provide C source code for functions that you would like to be able 
 to call from 
 Mathematica,
  and a high-level description — a 
 template
  — of the interface 
 to these functions. The tools then generate all of the communication- related code for you 
 and combine it with your function definitions to produce a com-plete server program. 
 The C functions that have been encapsulated in this way are called 
 installable
  functions 
 for reasons that will become clear later.
  
 The tools that accomplish this feat are called 
 mprep
  and 
 mcc.6 mprep
  reads a file 
 called a 
 template file
  that specifies, for each installable function, such things as the name 
 of the function, the types of parameters it expects, and the name that the kernel should 
 use to refer to the function, 
 mprep
  translates this information into a set of C lan-guage 
 functions that handles all of the communication details for the 
 MathLink
  pro-gram and 
 makes ordinary C language function calls to the installable functions. Then an 
 appropriate C compiler or integrated development environment is used to compile and 
 link the 
 mprep-
 generated
 code with the file(s) containing the installable functions and the 
 MathLink
  library. In the simplest cases no changes to the functions’ code are required, 
 and a very minimal amount of interface code needs to be written.
  
 6. 
 mprep
  is the name of a program that is invoked from the command line on 
 UNIX and DOS/Windows systems, and 
 mcc
  is a UNIX shell script that 
 invokes 
 mprep. 
 The 
 MathLink
  distribution for MacOS includes both an MPW-
 shell version of 
 mprep
  and a double-clickable application file called 
 SAmprep
  
 (for “stand-alone
  
 mprep"").",NA
11.2.1 Making setbit and clearbit installable,"For our first example of a template-based program, we will turn the C functions s e t-b it 
 and c le a rb it from the last section into installable functions. Here is 
 all
  of the C code 
 that we need to write:
  
 #include ""mathlink.h""
  
 A single line of ""glue code"" 
 has to be written to interface 
 with the mprep-generated
  
 code.
  
 The functions being 
  
 installed require no modifi- 
 cations in this example. 
  
 i n t  main ( in t a rg c , ch ar **argv) { 
  
 re tu rn  MLMain(argc, argv) ;
  
 }
  
 int setbit (int n, int 
 b )
  
 { 
  
 j 
  
 return n I (l«b) ;
  
  
 ’
  
 int clearbit(int n, int b)
  
 { 
  
 }
  
 return n & ~ ( l « b ) ;
  
 It is the programmer’s responsibility to write the main routine, but the only 
 require-ment for main is that it call the function MLMain (which is written by 
 mprep),
  
 passing to it the command-line arguments that it receives from the operating system.7 
 MLMain opens the link and then enters a loop, translating 
 MathLink
  messages from the 
 kernel into ordinary function calls to s e tb it and c le a rb it, and translating their return 
 val-ues into 
 MathLink
  replies. Finally, when the kernel closes the link, MLMain returns 
 and the programmer’s main function resumes control. By structuring the control flow in 
 this way the programmer has an opportunity to perform whatever initialization is 
 neces-sary before relinquishing control to MLMain, and an opportunity to clean up after 
 MLMain returns.
  
  
 The only other code that we must write is a set of 
 template
  descriptions for the 
 func-tions being installed. The templates for s e tb it and c le a rb it are shown below:
  
 :Begin:
  
 :Function: setbit
  
 :Pattern: SetBit[n_, b_]
  
 :Arguments: (n, b}
  
 :ArgumentTypes:{Integer, Integer}
  
 :ReturnType: Integer
  
 :End:
  
 7. Command-line arguments are another UNIX/DOS-specific feature. If you are 
 pro-gramming under MacOS, your development environment should have a 
 compatibil-ity library that allows a program to receive these arguments. The 
 library typically puts up a dialog box when the program begins running that 
 prompts the user for the arguments.",NA
11.2.2 Using lists as arguments,"Suppose now that we want to enhance SetB it and C learB it so that they can set or clear 
 more than one bit at a time. Writing a C function to take a variable number of arguments 
 is extremely tricky and sometimes system-dependent; furthermore, 
 mprep 
 can’t deal 
 with it. However, an installable function can take a 
 list
  of Integers or Reals as an 
 argument, which correspond to C 
 arrays
  of in ts or doubles, respectively. The 
 MathLink
  
 type keywords used for this purpose are In te g e rL ist and R ealList.
  
 Here is the template for the new version of SetB it; the template for C learB it is 
 analogous:
  
 setbit is declared to 
 take an IntegerList 
 as its sec- ond 
 argument. Note how 
 the pattern checks 
 for this type, 
  
 : Begin: 
  
 :Function: 
 ~ ..
  
 :Pattern: 
  
 :Arguments: 
  
 setbit 
  
 SetBit [n_Integer, b : 
 {_Integer}] {n, 
 b }
  
 :ArgumentTypes:{Integer, IntegerList}
  
 :ReturnType: 
  
 Integer
  
 :End:
  
 The C code for the new s e tb it function is straightforward, except that certain 
 parameter-passing conventions must be observed.
  
 The second 
 and
  
 third 
  
 parameters 
 correspond to 
  
 the IntegerList type 
 key-word.
  
 int setbit(int n, int bits[], long nbits)
  
 { j_nt 
  
 . 
  
 ’
  
 for (i = 
 0
  ; i < nbits: i++)
  
 n |= (l«bits[i]);
  
 }
  
 return n;
  
 The first parameter to s e tb it corresponds to the first In teg er argument, as before. 
 However, 
 two
  parameters are required to receive an In te g e rL ist argument: an inte-ger 
 array of unspecified size, and a long integer that gives the size of the foregoing array.10 
 This parameter layout is mandatory, as it corresponds to the way that the m/>rep-
 generated code will call the function.
  
 10. 
 Similarly, the template type keyword R ealL ist corresponds to a pair of C 
 argu-ments having types pointer-to-double and long.",NA
11.2.3 Including ,NA,NA
Mathematica,NA,NA
 code in a template file,"We would like to fix the problem observed at the end of the last section by allowing 
 SetB it to be called as either SetB it 
 [num, b i t
  ] or SetB it 
 [num. { b its }
  ]. An obvious 
 way to achieve this end would be to create a 
 Mathematica
  definition like the following:
  
 S e t B it [ n _ In t e g e r , b _ In te g e r] 
  
 :=  S e tB it[n , 
  
 {b }]
  
 We want this definition to be created automatically when the external program is 
 installed. This can be accomplished using the : E valuate: template statement.
  
 The : E v a lu a t e :  tem plate statement allows you to specify an arbitrary 
 Mathema-
  
 tica
 expression that is sent to the kernel, verbatim , during the installation process. You
  
 can use any num ber o f :E v a lu a t e :  statements in a tem plate file. In  the follow ing
  
 exam ple w e use : E v a lu a t e :  statements to create usage messages fo r S e t B it  and",NA
11.3 Debugging ,NA,NA
MathLink,NA,NA
 Programs,"All of the examples of link connection that we have seen in this chapter so far have used 
 what is called a 
 parent-child
  connection, in which the 
 Mathematica
  kernel plays the role 
 of the parent process and the 
 MathLink
  program is the child process.11 You can’t debug 
 an external program using this type of connection, since there’s no way for a debugger to 
 gain control of the child process. However, there is another type of con-nection, called a 
 peer-to-peer
  connection, that allows both ends of the connection to be run independently 
 — for example, one or both processes can be run from within a debugger. Peer-to-peer 
 connections also can be used to interpose a third 
 MathLink
  pro-cess between the parent 
 and the child, which can be used to monitor and/or filter the messages that are sent 
 between them.",NA
11.3.1 Peer-to-peer connections,"In order for a peer-to-peer connection to be made, each 
 MathLink
  program must be told 
 the name of a link to open. Using the TCP network protocol, a link name is an integer; 
 using the local communication protocols on MacOS or Windows, a link name can be an 
 arbitrary string. One side opens the link in 
 create
 12 mode, after which the other side
  
 11. It is also possible for the kernel to play the role of the child process; in fact, 
 this is exactly what happens when the kernel is started from the front end.
  
 12. Prior to version 3.0, 
 create
  mode was called 
 listen
  mode.",NA
11.3.2 Monitoring traffic on a link,"Another way to use peer-to-peer connections is to interpose a third 
 MathLink
 -aware 
 program between the two parties whose interaction is of interest. This third program 
 simply opens a link to each of the other two parties and copies data back and forth 
 between them, as shown in Figure 11-1. Each party thinks that it is connected directly 
  
 to the other.
  
 Kernel■'N",NA
J ,"r-------------►
  
 “client”
  
 snoop
  
 ^
  _____",NA
r,"MathLink 
 program
  
 “server”",NA
v,"Figure 11-1 Monitoring 
 MathLink
  traffic using a “snoop” program.
  
 You can use such a program to generate a log of the traffic on a link in real time. This is 
 a great way to gain an understanding of the workings of higher-level protocols (such as 
 the one used by I n s ta ll and 
 mprep,
  or the one used by the front end and the kernel).
  
 Although it would be possible to write the “snoop” program in C, it’s much easier to 
 use another 
 Mathematica
  kernel for this purpose, because the kernel gives us such a 
 high-level interface to a link. (Of course, we pay a price in terms of memory usage by 
  
 doing this.)
  
 To begin, start another 
 Mathematica
  kernel15 (which we will refer to as the 
 snooping
  
 kernel)
  and evaluate the following definition:
  
 Evaluate this 
 definition in the 
 new (snooping) 
 kernel. 
  
 snoop [linkl_LinkOb j ect, link2_Link0b j ect] : = 
  
 Module [{msg} , 
  
  
 LlnkConnect /@ {linkl, link2}; 
  
  
 While[LinkConnectedQ[linkl] && 
  
  
  
  
 LinkConnectedQ[link2], 
  
  
  
 If[LinkConnectedQ[linkl] && LinkReadyQ[linkl], 
  
 msg = 
 LinkReadHeld[linkl]
 ; 
  
 If [msg = =  $Failed, Break[]]; 
 Print[""--> "", HoldForm @@ msg]; 
 If[LinkConnectedQ[link2], 
  
    
 LinkWriteHeld[link2, msg]];
  
 If[LinkConnectedQ[link2] && LinkReadyQ[link2], 
 msg = LinkReadHeld[link2]; 
  
 If [msg = =  $Failed, Break []]; 
  
 Print[""<-- "", HoldForm @@ msg];
  
 15. Note that you can run two kernels from the same front end, and have each 
 one take input from a different window. If memory is really tight, try 
 running each kernel directly, without using the front end.",NA
11.4 Manual Data Handling,"In many common situations, you can rely on 
 mprep
  to handle all of the details of 
 com-municating with the kernel. Up to this point we have seen examples of (or at least 
 heard mention of) the types Integer, Real, String, Symbol, In teg erL ist, and Real- L ist. 
 In addition, 
 mprep
  supports — this is an undocumented feature! — the types S 
 hortlnteger, Longlnteger, F loat, Double, and LongDouble, with the obvious 
 correspondence to C types.17 Version 3.0 introduces several more types (see Section 
 11.9.3) that are used for 16-bit character data. You can use any of these types for 
 function arguments, and any of the scalar numeric types, String, or Symbol for function 
 return values.
  
 17. [Wolfram 96] §A. 11 states that MLPutReal and MLGetReal are “normally equiva­lent” 
 to MLPutDouble and MLGetDouble, whatever that means. Furthermore, the 
 MathLink 
 Reference Guide
  [WRI 93c] coyly points out that this equivalence is not guaranteed in 
 future versions of 
 MathLink!",NA
11.4.1 Returning lists,"Suppose that we want to create functions that pack and unpack a list of binary values into 
 an arbitrary-length bit vector. (Such functions would have been very handy to have when 
 we developed the Huffman coding example of Section 5.3.5.) The inputs 
 and
  out-puts to 
 these functions will be lists of integers. However, the only return types for which 
 mprep
  
 can generate code are scalars and character strings. In order to return an array of integers 
 (or doubles), the programmer must bypass the 
 mprep-
 generated code and make calls to 
 low-level 
 MathLink
  functions directly.
  
    
 For every type supported by 
 MathLink
  there are C library functions called MLPut- 
 type
  and 
 MLGettype.
  For example, to send an In teg er to the kernel, you could call 
 MLPutlnteger. In most cases this is handled by the 
 mprep-
 generated code — for 
 example, if your template file declares the return type of a function as Integer, then the 
 mprep
  code will store the return value from the function in a C in t and pass this integer 
 to MLPutlnteger for you. However, when you need to return a type that 
 mprep 
 doesn’t 
 support, you have to make these calls yourself. If you make an explicit MLPut- 
 type
  call 
 to return a value, your function should not return any value to the 
 mprep 
 code. 
 Therefore, the C function is declared void.
  
 In the present example we wish to return an 
 IntegerList 
 to the kernel, which is done 
 in C with the 
 MLPutlntegerList 
 library function.
  
 ^0
  
 Here is the C code that implements packbits. The format of a bit vector is a list of 
 integers, where the first integer in the list indicates the total number of valid bits. Bits 
 are packed a maximum of 8 per integer. While this is not the most compact 
 representa­tion possible, the kernel could easily convert these “byte codes” to a 
 character string18 
 using 
 FromCharacterCode; the result could be written to a file using 
 W riteString or the functions in U tilitie s 'B in a r y F ile s '.
  
 int bitsPerWord = 
 8
  ;
  
 18. The reason for not using character strings in the first place is that a 0 byte 
 in the middle of a C string would be interpreted as the end of the string. 
 See 
  
 Section 11.9.3, “String and symbol types,” for two ways around this 
 problem.",NA
IT,"It is vitally important to free any dynamically allocated storage after you are finished 
 using it; MLPuttype will not do it for you! Remember that the 
 MathLink
  program is 
 initialized only once, when the link is opened, and continues to run for as long as the 
 link is open. Therefore, if you forget to release dynamically allocated storage, then the 
 program will have a “memory leak” — i.e., it will lose some amount of memory 
 every 
 time
  the installed function is used. Eventually the 
 MathLink
  program will run out of 
 memory and chaos will ensue.
  
 In the template file, you must declare the return type as Manual so that the 
 mprep 
 code will not expect your C function to return a value to it. Here are the template file 
 statements for the function packbits.
  
 This predicate is used for 
 type-checking the pattern 
 below.
  
 :Evaluate:
  
 BinaryQ[x_] := x =  0 II x =  1
  
 :Evaluate: 
  
 PackBits::usage = ""PackBits[list] packs
  
 a list of binary digits into a list of byte codes."" 
 :Begin:
  
 :Function:
  
 packbits",NA
11.4.2 Returning arbitrary normal expressions,"In the previous section we learned how to send a list of integers manually to the kernel. 
 Because this is such a common thing to want to do, there is a special 
 MathLink
  library 
 call, M LPutlntegerList, for doing it. (Likewise, there is a corresponding library call for 
 putting a R ealList.) In general, however, in order to send a normal expression to the 
 kernel, you have to put it one part at a time.
  
 As mentioned earlier, there are MLPut 
 type
  functions for atomic types such as 
 Integer, Real, String, and Symbol. But in order to send a normal expression, you need to 
 use the MLPutFunction call to inform the kernel that what is being sent is the head of a 
 normal expression. MLPutFunction takes two arguments in addition to a link: a 
 character string, which is interpreted as the symbolic head of the expression, and a long 
 integer, which tells the kernel how many parts the expression will have.19 If you specify 
 a part count of 
 n,
  for example, then you must follow the call to MLPut-Function with 
 n
  
 calls to other MLPut type functions.
  
 19. 
 To 
 send expressions whose heads are not symbols (e.g., 
 Derivative [2] 
 [f 
 ] [x]) 
 you need to use the 
 MLPutNext 
 and 
 MLPutArgCount 
 functions. See 
 [Wolfram 96] §2.12.12 or the 
 MathLink Reference Guide
  [WRI 93c] for 
 details.",NA
11.4.3 Manual arguments,"Just as an installable function can manually send 
 Mathematica
  expressions to the 
 ker-nel, so can it also manually receive them as arguments. This may be necessary if the 
 type of argument to the function is not supported by 
 mprep.
  For each MLPuttype 
 func-tion there is a corresponding MLGet 
 type
  function, the only significant difference 
 being that the data parameters to an MLGettype are passed by reference (e.g., 
 MLGetlnte-ger takes a 
 pointer
  to a C integer as its second argument).
  
 Suppose that we want to write a version of unpackbits that could accept a B itV ector 
 as an argument directly (i.e., without being destructured first). Here are the relevant 
 template file entries:
  
 : B e g in :
  
 : F u n c tio n : 
  
 u n p a c k b its
  
 The argument is not destruc- : P a t t e r n : 
  
 U n p a c k B its  [b itv e c _ ? B itV e c to r Q ]
  
 tured. :A rg u m e n ts : 
  
 { b it v e c }
  
 Note that the argument type : A r g u m e n tT y p e s : {M a n u a l}
  
 is now Manual. : R e tu r n T y p e : M a n u a l
  
 :E n d:
  
 You might well wonder, if the argument type is Manual, why does the :Argu- m ents: 
 statement still specify an argument? The : Arguments: statement (along with the :P 
 attern : statement) is used to construct the 
 Mathematica
  definition for UnpackBits. In 
 other words, it tells the kernel what data to send across the link. The kernel doesn’t 
 know or care what is done with those data on the other end of the link. The : 
 ArgumentTypes: statement, on the other hand, is used by 
 mprep
  to construct the code 
 that receives the data from the kernel. If the keyword in this statement is Manual, 
 mprep
  
 simply 
 doesn’t write
  that code. Note, however, that if you want to send mani-festly 
 typed arguments as well as manual arguments to the same 
 MathLink
  function, the 
 Manual keyword must be the last element of the '.ArgumentTypes: statement. 
 Other-wise, 
 mprep
  would have no way of telling which arguments to generate code for 
 and which ones to ignore.
  
 Here is the C code for the new unpackbits. The main difference from the previous 
 version is, of course, the explicit calls to various MLGet type functions. There also is an 
 important extra bit of cleanup: a call to MLDisownlntegerList (explained below).",NA
11.5 Integrating Installable Functions and Packages,"It is easy to imagine circumstances in which one would like to include installable 
 func-tions in a package. Todd Gayley [Gayley 94c] points out that there are two 
 completely different ways of doing this, each with its own strengths and weaknesses. 
 One way is to use :E valuate: statements to embed the entire package inside of the 
 template file; there are examples of this in the 
 MathLink
  documentation. The other way, 
 which Gay-ley advocates, is to call I n s ta ll from within an ordinary 
 Mathematica
  
 package file. In the following two sections we will discuss each of these methods.",NA
11.5.1 Embedding a package in a template file,"Suppose that we want to extend the s e tb it and c le a rb it functions of Section 11.2.1 to 
 work on bit vectors. One way to do this would be to modify the code for these func-tions 
 to handle the B itV ector type as an argument and as a return value. However, there 
 really is no need to do so: Given the number of the bit to be modified, it is quite easy to 
 figure out which element of the bit vector data structure contains the relevant bit. By 
 passing only this single integer we not only simplify the C code (the original definitions 
 of s e tb it and c le a rb it from Section 11.2.1 can be used), we also cut down on the 
 amount of data passed between the kernel and the installed function — dramatically so 
 in the case of very large bit vectors.
  
 We can define the following “wrapper” function for s e tb it (the wrapper function for c 
 le a rb it is analogous):
  
 SetB i-t extracts the relevant 
  
 S e t B i t [ b : B i t V e c t o r [ n b it s _ ,  d a ta _ ] , n _ In t e g e r ] 
  
 / ;
  
 byte code and calls s e tb it. 
  
 B itV e c to r Q  [b ] 
  
 && 1 <= n <= n b it s  : =
  
 The return value is passed to 
  
 W it h [ { p  =  Q u o tie n t [n  -  1 , 
  
 8
  ] + 2 } ,
  
 ReplacePart to update the 
  
 BitVector [nbits ,
  
 B itV e c to r's  list of bits. 
  
 R e p la c e P a r t [ d a t a ,
  
 s e t b i t [ d a t a [ [ p ] ] , M od[n - 1 , 
  
 8
  ] + 1 ] ,
  
 ]
  
 p]
  
 Now we have a situation in which one function implements a public interface to another 
 function — a situation that cries out for a package structure. We can use :E valuate: 
 statements to embed within the template file all of the necessary calls (Section 8.2.1) to 
 BeginPackage, EndPackage, and so forth, as well as the wrapper functions themselves! 
 Here is the overall structure of the template file:",NA
11.5.2 Calling Install from within a package,"The second way to integrate installable functions and packages is to call I n s ta ll from 
 within an ordinary 
 Mathematica
  package. Although this may seem like the most 
 obvi-ous thing to do, there are a number of subtle difficulties involved.
  
 Here is an illustration of what happens when I n s ta ll is used within a package 
 (note:
  
 the following example was created using a “fresh” kernel session):
  
 Start a package. B e g in P a c k a g e [ "" t e s t '""]
  
 t e s t '
  
 Install a 
 MathLink
  program.
  
 The symbol B itA nd 
 refer-enced in this statement 
 is not the one created by 
  
 I n s t a l l .
  
 l i n k  =  I n s t a l l [ "" b i t a n d "" ]
  
 L in k O b je c t [ b it a n d , 
  
 2 ,
  2]
  
 C o n te x t[B itA n d ] 
  
 B it A n d : : shdw: 
  
 W a rn in g : Sym bol B itA n d 
  
  
  
 a p p e a rs  i n  m u l t ip l e  c o n te x ts  { t e s t ' . G l o b a l ') ;
  
 d e f i n i t i o n s  i n  c o n te x t t e s t '
  
 may shadow  o r  b e shadow ed b y o th e r  d e f i n i t i o n s .
  
 t e s t '
  
 The B itA nd function was
  
 ?G lo b a l'B itA n d
  
 2 ] ,
  
 installed in the G lo b a l'
  
 G lo b a l'B itA n d
  
 context.
  
 Exit the package context.
  
 G lo b a l'B it A n d [ G lo b a l'x _ . G lo b a l'y _ ] 
  
 :=
  
 E x t e r n a lC a l l[ L in k O b j e c t [ "" b i t a n d "" , 
  
 2 , 
  
 C a llP a c k e t [0 , 
  
 { G lo b a l'x , G l o b a l 'y ) ] ]
  
 E n d P a c k a g e [ ] ;
  
 The symbol l i n k  was cre-
  
 U n i n s t a l l [ t e s t ' l i n k ]
  
 ated in the package context.
  
 b it a n d
  
 The problem demonstrated above is a consequence of the fact that every installed 
 function is created in the G lobal' context, no matter where I n s ta ll is called from. This 
 happens because I n s ta ll explicitly overrides the value of $Context. Thus, in order to 
 embed an installable function in a package such as the following,
  
 B e g in P a c k a g e [""
  pkgnam e
 '"" ]
  
 . . . 
  
 ( o t h e r  p a c k a g e  s t u f f ) 
  
 . . .
  
 I n s t a l l
  [ "" e x t e r n a lp r o g "" ] :
  
 . . . 
  
 ( o t h e r  p a c k a g e  s t u f f ) 
  
 . . .
  
 E n d P a c k a g e []",NA
11.6 Callbacks to the Kernel,"Sometimes during the course of execution of an installed function the function needs to 
 have the 
 Mathematica
  kernel evaluate an expression. This is accomplished by calling 
 the function MLEvaluate (which is generated by 
 mprep).
  MLEvaluate takes a string as 
 an argument, which it sends to the kernel for evaluation. The value returned by the 
 kernel is retrieved using MLGet 
 type
  calls, just as would be done for manual arguments 
 (Section 11.4.3).
  
 As an example we will create a 
 MathLink
  function that finds a root of a continuous 
 function of a single variable (henceforth referred to as the 
 subject function)
  on a 
 speci-fied interval using bisection. The bisection logic will be implemented in C, but 
 each time the subject function needs to be evaluated, a request will be made to the kernel 
 to do so. In this way, the subject function can depend on other symbols and functions in 
 the 
 Mathematica
  session that the installed function doesn’t know about.
  
 The pattern for the installed function will be B isect [expr_, {x_Symbol, x0_, xl_>] 
 (by analogy with the built-in function FindRoot). It is expected that the end-points of the 
 interval xO and x l are numerical, that expr evaluated at each endpoint is numerical, and 
 that expr has opposite signs at the two endpoints. All of this is checked by 
 Mathematica
  
 code attached to the pattern as a condition. Before this code calls the installed function, 
 it converts expr to a string in order to obviate the need for the installed function to 
 accept an arbitrary normal expression as an argument.
  
 :Begin: 
  
 :Function: 
  
 bisect",NA
11.7 Error Checking,"There is a limit to how “bulletproof’ we can make 
 MathLink,
  functions through type 
 checking in the link patterns. There are some cases in which error conditions will arise 
 during the execution of the function no matter how carefully (within reason) the 
 argu­ments are checked. Here’s an example of such an error occurring during the 
 execution o fb isect:
  
 B i s e c t [ 1 / x . 
  
 { x , 
  
 - 1 , 
  
 1 }]
  
 1
  
 P o w e r : : in f y : 
  
 I n f i n i t e  e x p r e s s io n  —  e n c o u n te re d . 
 0.
  
 $ F a ile d
  
 U n i n s t a l l [ l i n k ] ;
  
 The error message shown above was generated by the kernel during the evaluation of 
 1/x / . x->0. The kernel returned a packet containing the expression D irectedln- fin ity [] 
 in response. What happened next is that evaluate_expression tried to get a real number 
 out of the packet, which caused an error. The value of the variable r e s u lt was thus 
 unchanged by the call to MLGetDouble (s td lin k , & result), and the value returned by 
 evaluate_expr was the value of an uninitialized local variable! The bisection process 
 continued, albeit to an incorrect conclusion (b isect attempted to return 1).",NA
H,NA,NA
r,"The reason the symbol $Failed was returned is a bit more complicated. It turns out 
 that after an error occurs on a link, 
 all subsequent calls using that link continue to fail 
 until the error condition is cleared explicitly.
  The error condition wasn’t noticed until b 
 ise c t returned to the 
 mprep-
 generated code. That code (a) cleared the error condition 
 and (b) returned the symbol $Failed.
  
 In other words, we were just 
 lucky
  that something reasonable happened. Since b is e 
 c t sanguinely ignores link errors, every call to evaluate_expr after the first bad one 
 returned garbage, too — it seems almost miraculous that b is e c t terminated at all! In 
 general we won’t be so lucky; the 
 MathLink
  function might return a nonsensical result, 
 loop forever, or turn into a pillar of digital salt (i.e., crash).",NA
11.7.1 General error checking,"The least we should do in a situation like the one above is to print a reasonable error 
 message and return the symbol $Failed immediately. In order to return a value other 
 than a real number, however, we will have to put the return value manually. We already 
 know how to do that: Simply change the :ReturnType: 
  
 Real statement to : 
 ReturnType: Manual in the template file, and use MLPuttype functions to return values 
 from b ise c t. Here is the new b isect:
  
 No return value. 
 void bisect(char *expr, char *x, double xO, double xl)
  
 { 
  
 double xmid, yO, yl. ymid; 
  
  
 char *buf = malloc(strlen(expr) + strlen(x) + 
 1 0 0
  );
  
 e v a lu a te _ e x p r now 
  
 if (evaluate_expr(buf, expr, x, xO, &y0) ||
  
 returns a status code. 
  
 evaluate_expr(buf, expr, x, xl, &yl)) {
  
 If it fails, return $ F a ile d .
  
 -
 -----
  MLPutSymbol (stdlink, "" $Failed"");
  
  
 return; 
  
 }
  
 while (fabs(xl - xO) > .000001)
  
 { xmid = (xO + xl)/2.0; 
  
  
  
 if (evaluate_expr(buf, expr, x, xmid. &ymid))
  
 If e v a lu a te _ e x p r fails, bail 
  
 { 
  
 MLPutSymbol(stdlink, ""$Failed""):
  
 out. 
  
   
   
 return; 
  
  
   
  
 } 
  
  
   
 /*** bisect step — as before ***/ 
  
  
 } 
  
  
 free(buf);
  
 Normal termination: Use 
  
  
 MLPutReal(stdlink, 
  
 MLPutReal to return the 
  
  
 (fabs(yO) 
  
 < fabs(yl)) ? xO : xl); 
 answer. 
  
 }
  
  
 Now for the error checking itself. As the saying goes, it’s a dirty job, but 
  
 ... This 
 code is rather subtle and we’ll go through it step by step below.",NA
11.7.2 Checking the types of packets and expressions,"The code given in the previous section will handle any conceivable error situation, but it 
 leaves something to be desired with regard to user-friendliness! For the b is e c t func-
  
 21. 
 MLEvaluateString is new in version 
 3.0. Users 
 of earlier versions should use 
 MLEvaluate, followed by a loop that “eats” everything up to and including the
  
 next RETURNPKT.",NA
11.8 Making Installed Functions Abortable,"Any installable function that performs a nontrivial amount of computation should be 
 maHp 
 abortable,
  particularly if the function involves any kind of iteration. What makes 
 this possible is a global variable called MLAbort in the 
 MathLink
  program that is set to 
 1 
 asynchronously22
  by the 
 mprep
  code if the kernel sends an interrupt packet (which it 
 does in response to the user typing the keyboard combination that requests an abort). 
  
 Therefore, any time-consuming loop should be structured as follows:
  
 while(test && IMLAbort) {
  
  
 /* loop body */ 
  
 }
  
 22. This is strictly true only on operating systems that have preemptive 
 multitasking, such as UNIX, OS/2, and Windows 95. MacOS System 7jc 
 and Windows 3 
 .x
  pro-grammers need to take some extra precautions, 
 discussed in [Gayley 94c].",NA
11.9 Miscellaneous ,NA,NA
MathLink,NA,NA
 Data Types,"Mathematica
  can handle some types of data for which there are no counterparts in C. 
 Two immediate examples are exact integers and arbitrary-precision numbers, which can 
 have far more digits than can be represented by any of the numeric types in C. 
 MathLink
  
 solves this problem by allowing programs to put and get numbers in textual, rather than 
 binary, form. This technique will be discussed in Section 11.9.1.
  
 Version 2.2 added the ability to put and get multidimensional arrays of numbers with a 
 single library call. The array types will be discussed in Section 11.9.2.
  
  
 Finally, version 3.0 adds a few new types for dealing with 16-bit character data, 
 which will be discussed in Section 11.9.3.",NA
11.9.1 Numbers as text,"As mentioned at the beginning of Section 11.4, there are 
 MathLink
  functions for putting 
 and getting sh o rt or long ints, flo ats, doubles, and long doubles. These func-tions have 
 names like M LPutShortlnteger, MLGetFloat, etc.
  
 Conspicuously absent from this list are functions for putting and getting 
 unsigned 
 integer types. This really is a problem only for the type unsigned long, since any smaller 
 unsigned integers can be put or gotten using a larger signed integer type. A gen-eral 
 mechanism for getting around this problem is to put or get numbers in textual, rather 
 than binary, form. This technique can be used to get and put numbers that have many 
 more digits than can be represented by native C types (although it’s not at all clear what 
 you would 
 do
  with such numbers inside of a C program).
  
 For example, MLGetLonglnteger will fail if the integer on the link is greater than 
 231-1. But MLGetString will succeed, returning the integer as a string (e.g., 
 ""1234567890""). If the integer is within the range of an unsigned long (0..2 '2-l), then it 
 can be extracted from the string using the standard C library function sscan f. 
  
 The following C code fragment illustrates these steps:
  
 char *s; 
  
 unsigned long x; 
  
 if(MLGetNext(stdlink) == MLTKINT) { 
  
  
 MLGetString(stdlink, &s);
  
 sscanf(s, ""%lu"", &x); 
  
 MLDisownString(stdlink, s);
  
 J 
  
 else { 
  
 /* error - do something about it */ 
  
 }
  
 MLGetNext returns a constant indicating the type of data on the link 
 (MLTKINT signi-
  
 fies an integer, MLTKREAL signifies a real number, and so on). However, 
 the fact that
  
 there is an integer on the link does not mean that it can fit into any C  
 integer type. Pro-
  
 duction-quality code would, of course, check for this. (Don’t assume that 
 sscanf does
  
 so!)
  
 Conversely, an integer can be put as a string as shown below:23
  
 char s
 2
  [
 2 0
  ]; 
  
 sprintf(s
 2
  , ""%lu"", x);
  
 MLPutNext(stdlink, MLTKINT); 
  
 MLPutString(stdlink, s2);
  
 23. 
 This particular technique does not work in earlier versions of 
 MathLink.
  The 
 textual interface
  functions, MLPutData and MLGetData, can be used to send 
 and receive any type of data in textual form. However, those functions are now 
 obsolete, and their use is strongly discouraged.",NA
11.9.2 Array types,"Beginning in version 2.2, 
 MathLink
  provides functions for putting and getting 
 multidi-mensional arrays of any of the scalar numeric types. In addition to an argument 
 that specifies a pointer to the data, these functions take an array of dimensions, rather 
 than a scalar length; an array of strings giving the heads to use in each dimension; and 
 the number of dimensions. For example, the following C code fragment sends a 2x3 
 matrix of short integers to the kernel:
  
 short int data[2, 3] = {{1, 2, 3}, {4. 5, 
 6
  }}; 
 long ndims = 
 2
  ;
  
 long dims[2] = {2. 3};
  
 MLPutShortlntegerArray(
  
 stdlink, data, dims, NULL, ndims);
  
 The fourth parameter to MLPut type Array is a list of character strings that specify the 
 names of the heads to use in each dimension of the array. Passing a NULL pointer 
 causes the head L ist to be used for all dimensions of the array.
  
  
 The following C code fragment shows how to use the MLGettypeArray functions, 
 using MLGetLongDoubleArray as a specific example:
  
 long double *data;
  
 long ‘dims;
  
 char **heads;
  
 long ndims;
  
 MLGetLongDoubleArray(
  
 stdlink, &data, &dims. &heads. &ndims);
  
 /* ...use the data... */
  
 MLDisownLongDoubleArray(
  
 stdlink, data, dims, heads, ndims);
  
 Note that all of the arguments (except the link) are passed by reference, and that the 
 MLGettypeArray function allocates the necessary storage for each of the C arrays (data, 
 dims, and heads). When you are finished using the array, you should be sure to call the 
 matching MLDisowntypeArray function to allow the 
 MathLink
  library to reclaim that 
 storage.
  
 Finally, note that in order to use the array data you must calculate your own indices, 
 because the dimensions of the array were unknown when the code was compiled. For 
 example, the (2, 3) element of a 10 x 10 array x would be accessed asx[2 * 10 + 3].",NA
11.9.3 String and symbol types,"Mathematica
  strings may contain 16-bit characters. The 
 MathLink
  S trin g  type encodes 
 all characters outside of a certain range — 
 including some 8-bit characters
  — using 
 multibyte sequences. In version 2.2, 
 MathLink
  programs must manipulate such 
 Hata 
 with 
 explicit translation functions (see the note at the end of this section). Version 3.0 
 introduces several new data types and functions for dealing with 16-bit character data in 
 a more direct fashion.
  
 The following string contains some special characters.
  
 s = ""Q\\s\n~ii7t""
  
 Q \s 
  
 ~ii7T
  
 \ \  is a 
 Mathematica
  escape sequence for the backslash character. The \n  escape 
 sequence represents a newline character, ii is a standard character in every Macintosh 
 font; methods for entering such characters may vary from system to system, 
 k
   can be 
 entered in a system-independent way in version 3.0 using the escape sequence \ [P i].
  
 Here is the kernel's internal 
 representation of s. 
  
 T o C h a ra c te rC o d e  [s ] 
  
 { gl> g2> 1 1 5 _ 13> 
 126,
  252, 960}
  
 In order to gain some insight into the 
 MathLink
  representation of strings, we will use 
 the following installable function that takes a string, as passed to it by 
 mprep
  code, and 
 returns a list of all of the 8-bit integers it finds in that string. (You should write the 
 mprep
  template file for this function as an exercise; note that it puts its result manually.)
  
 ^ 0
  
 void stringpeek(char *s)
  
 { 
  
 long len = strlen(s);
  
 int ‘charcodes = (int*) calloc(len, sizeof(int));
  
 int i;
  
 for (i = 
 0
  ; i < len; i++)
  
 charcodes[i] = s[i]:
  
 MLPutlntegerList(stdlink, charcodes, len);
  
 }
  
 free(charcodes);
  
 Below, strin g p eek  is installed into the kernel under the name StringPeek, and is then 
 used on the string s defined earlier.
  
 Install 
 stringpeek. 
  
 link = Install [""string""] 
 ;
  
 49i  5 3 , 126> 92t 51> 55< 5 2 .
  
 Here are the character 
  
 S tr in g P e e k  [s ]
  
 codes passed by 
 MathLink. 
 Users of 
 version 2.2 will see 
  
 {gl> g2> g2> n 5 >  g 2 _ 48> 
  
 .
  
 a different result. 
  
 9 2 - 5 8 ’ 4 8 > 5 1 - 67 ■ 481",NA
11.10 Additional Resources,"In this chapter we have concentrated mainly on using 
 MathLink
  to install externally 
 compiled functions into the 
 Mathematica
  kernel. 
 MathLink
  also can be used by an 
 external program to control a 
 Mathematica
  kernel in a master-slave relationship — the 
 Mathematica
  front end uses 
 MathLink
  in this way. This topic will be fully explored in a 
 future companion volume to this book. The protocol used by the 
 Mathematica
  front end 
 to control the kernel is investigated thoroughly in [Wagner 96b].
  
 The official documentation for 
 MathLink
  version 3.0 appears in [Wolfram 96] §2.12. 
 Documentation for earlier versions is scattered all over the place. The official, albeit 
 somewhat dated, documentation for version 2 is the 
 MathLink Reference Guide 
 [WRI 
 93c]. Another source, usually overlooked, is the WRI technical report entitled 
 Major 
 New Features in Mathematica Version 2.2
  [WRI 93a], which marks the first appearance 
 of non-ASCII string manipulation (Section 11.9.3), array functions (Section 11.9.2), and 
 other features such as new packet types, yield functions, and loop-back links (not 
 discussed here). The documentation for version 3.0 subsumes all of this material, of 
 course.
  
 Todd Gayley of WRI has written a tutorial guide to 
 MathLink
  [Gayley 94c] that is in 
 some ways superior to the official sources (but you will still need [WRI 93c] as a 
 refer-ence). Although it predates version 3.0, this tutorial is highly recommended for 
 readers seeking an alternative presentation. Gayley’s article describing his 
 MathLink
  
 program for accessing binary files [Gayley 94b] also contains quite a bit of tutorial 
 material about 
 MathLink.
  
 Some things about 
 MathLink
  can be learned only by examining the many sample 
 programs that come with the 
 MathLink
  distribution. Particularly useful examples in this 
 regard are 
 factorinteger2.c
  and 
 factorinteger3.c,
  which show how to read arbitrary 
 expressions from a link.
  
 Finally, 
 always
  read the release notes that come with the 
 MathLink
  distribution that 
 you are using! In addition to containing platform-specific and compiler-specific 
 infor-mation, they are the source of many useful tidbits about new experimental 
 functions, alternatives to obsolete functions, and so forth.",NA
Part ,NA,NA
5 ,NA,NA
Miscellane,NA,NA
a,NA,NA
12,NA,NA
Input/Output,NA,NA
12.1 File and Directory Management,"Before we begin doing input and output to files, we ought to make sure that we are using 
 those files that we intend to! 
 Mathematica
  provides several functions for query-
  
 ing and changing the program’s working directory.
  
 Directory 
 [] returns the working directory that a 
 Mathematica
  session is using.1
  
 Directory[] // InputForm
  
 ""Sartorius:Mathematica 3.0""
  
 The current working directory is the one containing the 
 Mathematica
  program files. We 
 probably don’t want to be writing a bunch of files into this directory, as we might over­
  
 write something important, so we should change the working directory.
  
 S e tD ire c to ry  changes the 
 working directory. 
  
 Mathematica
  keeps track of 
 the 
 directories that have 
  
 been visited.
  
 S e t D ir e c t o r y  ["" V a s t u s : te m p 
 ""] V a s t u s : tem p
  
 D ir e c t o r y S t a c k  []
  
 {Sartorius: Mathematica 
  
 3.0}
  
 1. The pathname shown is a MacOS-style pathname, which uses : as the 
 directory separator. On DOS/Windows systems the directory separator 
 character is \, and on UNIX it is /. Pathnames cannot contain spaces on either 
 of those systems.
  
 2. On the MacOS version of the front end, one can use the 
 Action/Prepare 
  
 Input/Paste File Pathname 
 menu command to locate the desired directory 
 using the standard open file dialog box. This doesn’t actually change 
 directories; it merely pastes a pathname at the notebook’s current insertion 
 point — e.g., inside a SetDi-
  
 rectory command.",NA
IT,"It would be a good idea to change your working directory to some scratch directory 
 before proceeding. You can always return to the most recent directory using the R esetD 
 irectory [] command.",NA
12.2 High-Level Output,NA,NA
12.2.1 Put and Get,"Put 
 [expr, ""filenam e""],
  which can be abbreviated 
 expr »  filenam e,
  writes an 
  
 expression to a file.
  
 This puts the result of the 
  
 E xpand [ ( 1  +  x ) A
 6
  ] 
  
 >> tmp
  
 Expand into the file 
 tmp.
  
 You can view the contents of a file using the ! ! operator. Note, however, that this is 
  
 not a 
 Mathematica
  function — it prints the contents of the file as a side effect and does 
  
 not return a value.
  
 ! Itm p
  
 1 + 
  
 6
  * x  + 
  
 1 5 * x A2 +  2 0 * x A3 +  1 5 * x A4 + 
  
 6 * x A5 
  
 + 
  
 x
  A6
  
 Put overwrites whatever is 
  
 already in the file, if anything. If you want to append an
  
 expression to a file, used PutAppend (» > ) instead.
  
 The output of this command E x p a n d [( l +  x ) A4] 
  
 » >  tmp
  
 is appended to 
 tmp. 
  
 11
  tm p
  
 1 + 
  
 6
  * x  + 
  
 1 5 * x A2 +  2 0 * x A3 +  1 5 * x A4 + 6 * x A5 + 
  
 x
  A6
  
 1 + 4 * x  + 
  
 6*
 x
  a2 
 +  4 * x A3 + 
  
 x A4
  
 You can read a file of 
 Mathematica
  expressions that you created with Put by using 
  
 Get 
 [""filenam e""]
 , which can be abbreviated 
 « filen a m e.
  Get attempts to evaluate 
  
 every line in the file as 
 Mathematica
  input; it returns the value of the last expression 
  
 read from the file.
  
 « t m p
  
 1 +  4 x  +  
 6
  x 
  
 2 
  
 3 +  4 x 
  
 +  x
  
 4
  
 You can use Get to read in any file containing 
 Mathematica
  input, including pack-
  
 ages. However, it is better to use Needs to read a package, since it prevents the same 
  
 package from being loaded more than once (Section 8.2.2).",NA
12.2.2 Exporting data using special output formats,"The advent of the notebook interface has made using Put and Get to save and restore 
  
 Mathematica
  expressions pretty much unnecessary, if not obsolete. In this section we 
  
 explore how to save data in other formats.",NA
12.2.3 Save and DumpSave,"Sometimes you want to save the definition of a symbol (or group of symbols) to a file, in 
 a form that can be used to “reconstitute” the symbol at a later time. The Save func­tion 
 writes the definition of one or more symbols, along with the definitions of all the 
 symbols they depend upon, into a file.
  
 a = 5;
  
 b := a;
  
 Save doesn't save just the 
 values of symbols, it saves 
 their literal definitions.
  
 S a v e [""tm p "", b] 
  
 ! !tmp 
  
 b := a 
  
 a = 5
  
 Save is most useful when you want to save the definitions of a large number of 
 sym-bols at once. You can specify a list of symbols, a string pattem (e.g., ""*foo*""), or a 
 context name as the second argument to Save.
  
 Starting with version 3.0, you also can save symbol definitions in a binary format 
 using DumpSave. By convention, such files have the suffix 
 .mx.
  (Regardless of the 
 suf-fix, Get automatically figures out if a file being read is in the binary format.) The 
 advantage of DumpSave over Save is that the binary data are much quicker to load into 
 the kernel than the InputForm that is written by Save.
  
  
 Furthermore, DumpSave can save the definition of an entire package using the syntax 
 DumpSave 
 [ f i l e , 
  
 "" c o n te x t'
  "" ]. Loading a binary package created by DumpSave",NA
12.3 Low-Level Output,"In some cases you may need more control over the format of the output than Put affords. 
 The functions described in this section give you that control.",NA
12.3.1 Streams,"In 
 Mathematica,
  a 
 stream
  is a source of input or output. Streams can be files, 
 pipes
  (on 
 some operating systems), or even character strings.3 Before a stream can be used, it 
 must be 
 opened,
  and when it is no longer needed, it should be 
 closed.
  
 Here's a file with some data 
 in it.
  
 ""Hello there"" »  tmp 
  
 ! !tmp
  
 ""Hello there""
  
 OpenWrite 
 associates 
 an output stream with a 
 file.
  
 OpenWrite 
 wipes out 
 what-ever data were in the 
 file.
  
 s = OpenWrite[""tmp""] 
  
 OutputStream[tmp, 
 8
  ]
  
 ! !tmp
  
 OpenAppend is similar to OpenWrite, with the obvious difference.
  
 The value returned by OpenWrite or OpenAppend is passed as an argument to the 
 functions that actually write the data to, and close, the stream. You can get a list of all 
 open streams using the Streams command.
  
 3. This is similar to 
 string streams
  in C++ ([Stroustrup 91] §10.5.2). Associating a 
 stream with a character string in 
 Mathematica
  is done with the 
 StringToStream function ([Wolfram 91] §2.10.8 or [Wolfram 96] §2.11.9).",NA
12.3.2 Writing to a stream,"Once you have opened a stream for writing or appending, you can write data to it. There 
 are two functions for this: W rite, which writes 
 Mathematica
  expressions, and W rite- S 
 tring, which writes character strings.
  
  
 W rite 
 [s, e x p r l
 , . . .  ] writes the given expression(s) to the stream s, followed by a 
 newline character. W rite leaves no spaces or other delimiters between the expres-
  
 sions.
  
 s = OpenWrite[""tmp""]; 
  
 Clear[a, b] 
  
 Write[s, (a + b)A2, "" expands to 
  
 Expand[(a + b)A2]]
  
 ! !tmp
  
 (a + b)A
 2
  "" expands to ""a
 A2
  + 
 2
  *a*b + b
 A2
  
 Note the quirky string output in the above example. This is because, by default, W 
 rite writes its arguments using the InputForm format, and strings in InputForm show 
 their double quotes. You can override the format for each argument on an individ-
  
 ual basis:
  
 Subsequent 
 Write com- 
 mands append to the file. 
  
 Write [s, (a + b)A2, OutputForm ["" expands to ""] 
 . 
  
 Expand [(a + b)A2]] 
  
 ! !tmp
  
 (a + b)A
 2
  "" expands to ""a
 A2
  + 
 2
  *a*b + b
 A2 
  
 (a + b
 ) A2
  expands to a
 A2
  + 
 2
  *a*b + b
 A2
  
  
 The default format is InputForm because, as the next example shows, OutputForm is 
 unsuitable for subsequent input whenever exponents or fractions are involved.4
  
 The exponent 
 is 
 written on 
 a 
 different line of the output than 
 everything else. 
  
 Write [s. OutputForm [""The OutputForm of ""] .
  
 (a + 
 b ) A2, 
  
 OutputEorm["" is: ""] 
 ,
  
 ]
  
 OutputForm[(a + b)A2]
  
 4. In version 3.0, the formats StandardForm and TraditionalForm  behave as 
  
 OutputForm unless the stream being written to is a front-end window.",NA
12.3.3 Display,"D isplay 
 [s
 , 
 g]
  writes the 
 Mathematica
  graphics object 
 g
  to the stream 
 s
  in Post-Script 
 format. If 
 s
  refers to a notebook window, the graphic is rendered in the notebook. In 
 general, however, you can use D isplay to write the PostScript to any stream, such 
  
 as a file or pipe.
  
 Like the other output commands, the first argument to D isplay can be a list of 
 streams or strings. Note that if any of these strings is the name of a file that is not 
 already open, D isplay opens the file, write the graphics data to it, 
 and then closes it.
  
 When you create a 
 Mathematica
  graphic using any of the plotting commands, the 
 return value from the function is a graphics object. The picture that you see on your 
 screen is actually a 
 side effect
  that is caused by passing the graphics object to the 
 func-tion specified by the D isplayFunction option.
  
 Options[Plot, DisplayFunction]
  
 {DisplayFunction :> $DisplayFunction}",NA
12.4 High-Level Input,"The most common input operation in 
 Mathematica
  is to read a file of regularly 
 format-ted data into some kind of list structure. The ReadList function accomplishes this 
 with a minimum of fuss.",NA
12.4.1 Data types and templates,"ReadList takes two arguments: a filename and an optional 
 template.
  The template is an 
 expression containing type keywords such as Byte, C haracter, Expression, Number, 
 Real, Record, String, or Word. The template informs ReadList how the data are to be 
 interpreted. For example:
  
 I ! i n t d a t a
  
 967 682 130 
  
 375 963 64 
  
 525 839 941 
  
 144 969 891 
  
 206 325 234
  
 This interprets the data in 
 the file as numbers.
  
 Now  the data are 
 inter-preted as real 
 numbers.
  
 Character 
 reads each 
 char-acter separately. "" \n ""  is 
 an ASCII newline character.
  
 Byte 
 interprets each 
 charac-ter in the file as an 
 8
  -bit 
  
 integer.
  
 Word 
 breaks up the file into wh 
 ite-space-del im ited 
  
 strings.
  
 S trin g  breaks the input 
 only at newlines.
  
 Expression 
 interprets 
  
 each line as a 
 Mathematica 
 expression.
  
 R e a d L is t [ "" i n t d a t a "" , Num ber]
  
 {9 6 7 , 6 8 2 , 
  
 1 3 0 , 3 7 5 , 9 6 3 , 6 4 , 5 2 5 , 8 3 9 , 
  
 9 4 1 , 
  
 1 4 4 ,
  
 9 6 9 , 8 9 1 , 
  
 2 0 6 , 3 2 5 , 
  
 2 3 4 )
  
 R e a d L i s t [ "" i n t d a t a "" . R e a l]
  
 { 9 6 7 ., 6 8 2 ., 
  
 1 3 0 ., 3 7 5 .,  9 6 3 ., 
  
 6 4 . ,  5 2 5 ., 
  
 8 3 9 ., 
  
 9 4 1 .
  
 1 4 4 ., 
  
 9 6 9 ., 
  
 8 9 1 ., 2 0 6 .. 
  
 3 2 5 ., 
  
 2 3 4 .}
  
 R e a d L i s t
  [ "" i n t d a t a "" .  C h a r a c te r ] 
  
 / /  In p u tF o rm
  
 n gn
  
 ”
  6
  "" ,
  
 ir 
 -j
  ii
  
 11
  
 116
  "" , 
  
  
 f| 
 5
  
 n
  
 ""
  8
  "" ,
  
 1
 1
  
 ’
  2
  "" , 
  
 ""
  
 11 
  
 II
  1
  "" .
  
 "" 6
  "" , 
 11
 3
  
 9 "" .
  
 ""
  0
  "" ,
  
 "" \n "" 
  
 "" V  
 f 
 n 
 9
  ti
  
 it 
 3
  ii
  
 11711
  
 11
  
 11911
  
 "" \n ""
  
 n ^ 
 11
  
 ""
  2
  "" ,
  
 11
 5 
 ”
 11
  «
  
 11
  n
  
 ""
  6
  "" , 
  
 n ii
  
 ""
  8
  ” , 
 n^ii
  
 ""3 
  
 n
  
 11411
  
 ii 
  
 11
  
 "" W
  
 .
  
 ” 4 ” ,
  
 9 "" .
  
 ""
  6
  "" , 
  
 ii it
  
 "" 3 "" ,
  
 11
  n
  
 ""
  8
  "" , 
 115
  n
  
 11911
  
 11
  
 11
  
 "" \ n ’\ 
 H 
 3
  II
  
 11
 2
  ” ,
  ”0
 ” 
 411 
 "" \n
  
 6
  "" .
  
 ""
  2
  "" ,
  
 11
  n
  
 ""
  2
  "" ,
  
 R e a d L i s t [ "" i n t d a t a "" , B y te ]
  
 {5 7 , 5 4 , 5 5 , 3 2 , 5 4 , 5 6 . 5 0 , 3 2 , 4 9 , 5 1 , 4 8 , 
  
 1 3 , 5 1 ,
  
 5 5 , 5 3 , 
  
 3 2 , 5 7 , 
  
 5 4 , 5 1 , 
  
 3 2 , 5 4 , 
  
 5 2 , 
  
 1 3 , 
  
 5 3 , 5 0 , 
  
 5 3 ,
  
 3 2 . 5 6 , 
  
 5 1 . 5 7 , 3 2 , 5 7 , 
  
 5 2 , 4 9 , 
  
 1 3 , 4 9 , 5 2 , 5 2 , 
  
 3 2 ,
  
 5 7 , 5 4 , 
  
 5 7 , 3 2 , 5 6 , 5 7 , 
  
 4 9 , 1 3 , 
  
 5 0 , 4 8 , 5 4 , 3 2 , 
  
 5 1 ,
  
 5 0 . 5 3 , 
  
 3 2 , 5 0 , 5 1 , 5 2 , 
  
 13}
  
 R e a d L i s t [ "" i n t d a t a "" , W ord] 
  
 / /  In p u tF o rm
  
 { "" 9 6 7 "" , 
  
 "" 6 8 2 "" , 
  
 "" 1 3 0 "" , 
  
 "" 3 7 5 "" , 
  
 "" 9 6 3 "" , 
  
 "" 6 4 "" , 
  
 "" 5 2 5 "" , 
  
 "" 8 3 9 "" ,
  
 "" 9 4 1 "" , 
  
 "" 1 4 4 "" , 
  
 "" 9 6 9 "" , 
  
 "" 8 9 1 "" , 
  
 "" 2 0 6 "" , 
  
 "" 3 2 5 "" , 
  
 "" 2 3 4 "" }
  
 R e a d L i s t [ "" i n t d a t a "" ,  S t r in g ] 
  
 / /  In p u tF o rm
  
 {"" 9 6 7  682 1 3 0 "" , 
  
 ""3 7 5  963 6 4 "" , 
  
 ""5 2 5  839 9 4 1 "" ,
  
 ""1 4 4  969 8 9 1 "" , 
  
 ""2 0 6  325 2 3 4 ""}
  
 R e a d L i s t [ "" i n t d a t a "" , E x p re s s io n ]
  
 {8 5 7 3 4 2 2 0 , 
  
 2 3 1 1 2 0 0 0 , 4 1 4 4 8 6 9 7 5 , 
  
 1 2 4 3 2 6 5 7 6 , 
  
 1 5 6 6 6 3 0 0 }",NA
12.4.2 Reading numbers,"ReadList is terrific when the input data consist of numerical values separated by white-
 space. The simplest way to read such data is to read each number separately, as 
 illustrated earlier:
  
 R e a d L i s t [ "" i n t d a t a "" , Num ber]
  
 { 9 6 7 , 
  
 6 8 2 , 
  
 1 3 0 , 
  
 3 7 5 , 
  
 9 6 3 , 
  
 6 4 , 5 2 5 , 8 3 9 , 
  
 9 4 1 , 
  
 1 4 4 ,
  
 9 6 9 , 
  
 8 9 1 , 2 0 6 , 3 2 5 , 
  
 2 3 4 }",NA
12.4.3 Reading strings,"There are three different ways to read strings from a file, using the String, Word, and 
  
 Record type keywords. S trin g  is the simplest of these:
  
 !Iworddata
  
 The quick, brown, fox jumps
  
 over the lazy dog.
  
 Objects of 
 type 
 String 
 are 
 ReadList [""worddata"" , String] 
  
 II
  InputForm
  
 delimited by newlines. 
  
 {""The quick, brown, fox jumps"", ""over the lazy dog."")
  
 If you want more control over how the input is broken up, you can read objects of 
  
 type Record and specify a list of RecordSeparators (which defaults to newline).",NA
12.4.4 Application: Reading comma-delimited data,"Okay, now for the bad news: ReadList gives only minimal support for this common 
 case. The file 
 csv
  contains the data that we used in our export example, except that it is 
 in “comma-separated values” format.
  
 ! ! c s v
  
 12. ,162754.7914190039 
  
 13..442413.3920089206 
  
 14..1.202604284164777e6 
  
 15..3.269017372472111e6 
  
 16. ,8.88611052050787e6 
  
 17..2.41549527535753e7",NA
12.5 Low-Level Input,"Corresponding to the low-level output primitives, there are low-level input primitives 
 that can be used to read just about any kind of data, if you are willing to work hard 
 enough at it.",NA
12.5.1 OpenRead,"OpenRead is analogous to OpenWrite. It returns an InputStream  rather than an 
 OutputStream:
  
 s = OpenRead[""tmp""]
  
 InputStream[tmp, 21]
  
  
 As in the case of output streams, you should close an input stream after you are done 
 with it.
  
 Close [s];",NA
12.5.2 Reading from a stream,"Read allows you to read an object from a stream, where “object” is any of the types 
  
 supported by ReadList.
  
 s  = O p e n R e a d [ "" e d a t a f i l e "" ] ;
  
 Here w e read a number and a 
 word.
  
 Next, three strings. The first 
 string read is the end of the 
 current line.
  
 R e a d [s , 
  
 {N um ber, W o rd }] 
  
 / /  In p u tF o rm
  
 { 1 2 . , 
  
 "" 1 6 2 7 5 4 .7 9 1 4 1 9 0 0 3 9 "" }
  
 R e a d [s , T a b le  [ S t r i n g , 
  
 { 3 } ] ] 
  
 / /  In p u tF o rm
  
 { "" "" , 
  
 "" 1 3 . 4 4 2 4 1 3 .3 9 2 0 0 8 9 2 0 6 "" ,
  
 "" 1 4 . 
  
 1 . 2 0 2 6 0 4 2 8 4 1 6 4 7 7 7 e 6 "" )
  
 Read keeps track of your position within the stream. You can get the current position 
  
 using the St r 
 e am P o  
 s i t  ion function, and you can set the position using SetStreani 
  
 P osition.
  
 Save the current position. 
 Read four numbers.
  
 Return to the saved position. 
  
 Read four strings instead.
  
 Note the E n d O fF ile  
 indica-tion.
  
 p =  S tr e a m P o s it io n [ s ] ;
  
 R e a d [s , T a b le [N u m b e r, 
  
 { 4 } ] ]
  
 { 1 5 . , 
  
 3 .2 6 9 0 2  10 6 , 
  
 1 6 . , 
  
 8 .8 8 6 1 1  1 0 6 }
  
 S e t S t r e a m P o s it io n [s , p] ;
  
 R e a d [s , T a b l e [ S t r i n g , 
  
 { 4 } ] ] 
  
 / /  In p u tF o rm
  
 { "" 1 5 . 
  
 3 . 2 6 9 0 1 7 3 7 2 4 7 2 1 1 1 e 6 "" 
 , 
  
 "" 1 6 . 
  
 8 . 8 8 6 1 1 0 5 2 0 5 0 7 8 7 e 6 "" ,
  
 "" 1 7 . 
  
 2 .4 1 5 4 9 5 2 7 5 3 5 7 5 3 e 7 "" . E n d O fF ile }
  
 At any point during the course of reading from an input stream, you can use 
  
 ReadList to read everything from the current position to the end of the stream.
  
 S e t S t r e a m P o s it io n [s , p ] :
  
 R e a d L is t [ s , S t r in g ] / /  In p u tF o rm
  
 { "" 1 5 . 3 .2 6 9 0 1 7 3 7 2 4 7 2 1 1 l e 6 "" , "" 1 6 . 8 . 8 8 6 1 1 0 5 2 0 5 0 7 8 7 e 6 "" ,
  
 "" 1 7 . 2 .4 1 5 4 9 5 2 7 5 3 5 7 5 3 e 7 "" )
  
 Alternatively, you can use ReadList [ s , 
 tem p la te, n]
  to read at most 
 n
  objects of 
  
 the specified template from the stream s. Streams allow you to mix calls to Read and 
  
 ReadList without losing your position.
  
 Don't forget to close the C lo s e  [s ]
  
 stream.",NA
12.6 Additional Resources,"[Shaw & Tigg 94] contains many practical examples of reading data from files.
  
 6. Note that in versions 2.2 and earlier, Read erroneously returns EndOfFile 
 under these circumstances. This does not prevent you from continuing to 
 read the file, however.",NA
13,NA,NA
Debugging,"Most of the time the interactive nature of 
 Mathematica
  makes debugging easy. There 
 are occasions, however, on which executing a function step by step in search of a bug is 
 unacceptably tedious. In earlier chapters we saw a few uses of the Trace command to 
 enable postmortem examination of the evaluation of 
 Mathematica
  expressions, but until 
 now we have ignored the details of this technique. Trace has many options that 
  
 we will explore in Section 13.1.
  
 There are some additional, more interactive, debugging tools in 
 Mathematica
  that 
 few users know about and even fewer use. These tools, which are the topic of Section 
 13.2, are quite unlike the interactive debuggers that users of compiled lan-
  
 guages are familiar with.",NA
13.1 Tracing Evaluations,"The Trace function (and its relatives) can be used to trace the evaluation of an 
 expres-sion. We have already seen uses of Trace scattered throughout the earlier 
 chapters. In this section we present a comprehensive discussion of Trace.
  
 All of the Trace outputs in this chapter were generated using 
 Mathematica
  version 
 3.0, which in certain instances gives different output than version 2.2. Mostly, this 
 dif-ference consists of certain trivial evaluations that appear in version 2.2 traces that do 
 not appear in version 3.0 traces. Less commonly, the version 3.0 traces contain expres-
  
 sions that version 2.2 omits.",NA
13.1.1 Trace basics,"Trace 
 [expr]
  returns a list of all intermediate forms encountered during the evaluation 
  
 of 
 expr.",NA
13.1.2 Restricting the trace,"We saw in the previous section that the output of Trace can be large even when tracing 
  
 trivial computations; it typically is 
 enormous
  when tracing nontrivial ones. For exam-
  
 ple, it would be quite difficult to understand the trace of the merge function on any 
  
 realistically sized inputs. To alleviate this problem, Trace takes a second argument that 
  
 can be used to restrict the information in the trace. There are two forms for this argu-
  
 ment.
  
 One form of the argument is called a 
 tag.
  A tag is a symbol with which a particular 
  
 transformation rule is associated. It is usually the head of an expression, but it also may 
  
 be a symbol at level 1 for which an Upvalue has been defined (refer to Sections 6.5.2 
  
 and 7.1.1).
  
 For example, here we trace all subexpressions in the evaluation of merge [ {1, 3. 
  
 5}, {2, 4}] that are tagged with the symbol merge:
  
 This is much more digestible 
  
 T ra c e  [m erg e [ { 1 ,  3 , 5 } , 
  
 { 2 . 4 } ] ,  m erge]
  
 than a full trace. 
  
 {m erge [ {
  1
  , 
  
 3
  , 
  
 5
  ) , {
  2
  , 
  
 4
  } ] ,  m e r g e [{
  2
  , 
  
 4
  } , 
  
 (
  1
  , 
 3
  , 
  
 5
  } ] ,
  
 P re p e n d [m e rg e [ { 3 ,  5 ) , 
  
 ( 2 , 4 } ] , 
  
 1 ] ,
  
 {m e rg e [ { 3 ,  5 ) , 
  
 { 2 , 4 } ] ,  m e rg e [ { 2 ,  4 ) , 
  
 { 3 , 5 } ] ,
  
 P re p e n d [m e rg e [ { 4 1 , { 3 , 5 } ] , 
  
 2 ] ,
  
 { m e r g e [{ 4 } , { 3 , 5 1 ] ,  P re p e n d [m e rg e [ { 5 ) , 
  
 ( 4 ) ] ,  3 ] ,
  
 {m e rg e [ { 5 } , { 4 1 ] ,  m e rg e [ { 4 } , 
  
 { 5 1 ] ,
  
 P re p e n d [m e rg e [ { } , { 5 } ] ,  4 ] ,
  
 {m e rg e [ { } , 
  
 { 5 } ] , 
  
 { 5 ) } } } ) }
  
 The reordering of the arguments is quite explicit here. Also note that it is quite easy to 
  
 see the recursive structure of the computation.
  
 When a tag is used as the second argument to Trace, Trace includes not only the 
  
 expressions that match rules associated with this tag, but also the results of evaluating 
  
 those rules (in the case of the tag merge, a call to Prepend). We can restrict the trace 
  
 even further by specifying a pattem as the second argument to Trace. Trace will then 
  
 include only those intermediate expressions that match the pattem in the returned trace.",NA
13.1.3 Looking forward or backward,"Note that the traces in the previous section did not reveal what the eventual outcome of 
 each traced expression was. We can obtain this information using the TraceForward 
  
 option:
  
 Trace[merge[{1, 3, 5}, {2, 4}], merge[_, _ ] , 
 TraceForward->True]
  
 {merge[{1, 3, 5}, {2, 4)], merge[{2, 41, {1, 3, 5}], {merge[{3, 
 5), {2, 4)], merge[{2, 4}, {3, 5)].
  
 {merge[(4), {3, 5)], 
  
 {merge[{5}, {4}], merge[{4}, {5}], 
  
  
 {merge[{}, {5}]. {5)1, {4, 5}), {3, 4, 5)}.
  
 {2, 3, 4, 5}] , {1. 2. 3, 4, 5}}
  
 TraceForward->True shows the final expression in each evaluation chain that is traced. 
 Now we can see, for example, that merge [ {}, {5} ] evaluated to {5 } and that merge 
 [{5}, {4}] evaluated to {4, 5}.
  
 A similar option, TraceForward->A11, shows 
 all
  intermediate results in the 
 evalu-ation chain from the traced form until the end of the chain. Because of the volume 
 of output this produces, the next example restricts the traced forms to those calls to 
 merge that have {5} as their second argument.
  
 Trace[merge[{1, 3, 5}, {2, 4}], merge[_, {5}], 
  
   
  
 TraceForward->A11] 
  
 {{{{merge[{4}, {5}], Prepend[merge[{), {5}], 4], 
  
   
 {merge[{}. {5}], {5)1, Prepend[{55, 4], {4, 5})}} 
   
 )
  
   
 Often, however, what is desired is to find out where a particular subexpression came 
 from.
  For example, suppose we want to see what evaluation gave rise to the 
 intermedi-ate result {3, 4, 5 }. This can be done with the TraceBackward option.",NA
"13.1.4 TraceOn, TraceOff","The TraceOn and TraceOff options control which parts of a computation are traced. 
  
 For example, suppose we already had debugged the merge function, and now we want 
  
 to debug m ergesort (Section 5.4.2):",NA
13.1.5 TraceDepth,"TraceDepth is another option that limits the amount of information present in a trace. It 
 simply eliminates all information below a certain depth in the trace.
  
 By setting 
 TraceD epth 
 to 
 1 
 in 
 this example, we do not see a 
 trace of any of the 
  
 lower-level recursive calls.
  
 Trace[mergesort[{5, 3, 2}], TraceDepth->l] 
  
 {mergesort[(5, 3, 2}], 
  
   
 W i t h [{half$ = Quotient[Length[{5, 3, 2}], 2]}, 
    
 merge[mergesort[Take[{5, 3, 2}, half$]],
  
   
 mergesort[Drop[{5, 3, 2}, half$]]]], 
  
 merge[mergesort[Take[{5, 3, 2}, 1]], 
  
  
 mergesort[Drop (5, 3, 2}, 1]]],",NA
13.1.6 MatchLocalNames,"The names of all local symbols declared in a Module command are made unique by 
  
 appending a $ followed by the current value of $ModuleNumber (Section 4.1.4). By 
  
 default, Trace will match names like x$nn to the pattern x_, which is very convenient. 
  
 Consider the following recursive function that calculates the length of a list:
  
 l e n [ { a _ ,  b____} ] 
  
 l e n [ { } ]  =  
 0
  ;
  
 l e n [ { 1 , 2 , 3 } ]
  
 3
  
 :=  M o d u le [{s  =  { b } } ,  1 +  l e n [ s ] ]
  
 We can trace all assignments to the local symbol s using the following command:
  
 The name of the local sym- 
  
 T ra c e  [ le n  [ { 1 ,  2 . 3 } ] ,  s =  _]
  
 ( { { s $ 6  = { } } } ) } } }
  
 bol s is different in each 
  
 { ( g$4 = {2> 3} } > 
  
 { { { g $ 5  _ { 3 } } j 
  
 recursive call, but Trace
  
 matches them all to the pat-
  
 tern s_.
  
 In certain cases this behavior may not be desirable: for example, when there are 
 mul-tiple Modules having the same local variable name, or if there is a global variable 
 of the same name that is the true subject of interest. In such cases you can disable this 
 fea-ture with the MatchLocalNames->False option setting.
  
 In case you want to trace only 
 certain
  local variables with a given name, you can, 
 with a bit of effort, figure out what the unique variable name will be (using $Module- 
 Number) and use that in the trace pattern.
  
 $M oduleN um ber
  
 7
  
 The nesting of the result 
 reflects the structure of the 
 entire computation.
  
 T ra c e  [le n  [ { 1 ,  2, 
 3 , 4 , 
 5,  6 } ] ,  s$10 = _] { { , { { { { 
 {s$10 = {5 > 6 ) } } j }} j j }",NA
13.1.7 TraceOriginal,"TraceO riginal->True is an option to Trace and related functions that allows you to see 
 expressions before their parts have been evaluated. Compare the following two 
 examples to see the effect of this option:
  
 T r a c e [C o s [ . 7 ]  +  S q r t [ 2 . 5 ] ,  P lu s [
 __
  ] ]
  
 { 0 .7 6 4 8 4 2  +  1 .5 8 1 1 4 }",NA
13.2 Interactive Debugging,"The tracing techniques that we examined in the last section all have one thing in 
 com-mon: All they provide is postmortem information. Debugging using them is a 
 process of successive refinement, as we repeatedly trace a computation with different 
 options, trying to “zero in” on the problem. Sometimes this is not practical — a 
 computation that fails to terminate is an obvious example — and in such cases the only 
 alternative is to interact with the computation as it executes. This mode of debugging 
 probably is 
 fa m ilia r 
 to programmers of other programming languages.",NA
13.2.1 TracePrint,"T raceP rint prints the trace, one expression per line, as the computation proceeds. It is 
 interactive in die sense that it can be used to monitor a badly behaving computation and 
 then abort the computation from the keyboard as soon as it’s clear what is going wrong.
  
  
 Since the output of T raceP rint is so verbose, we return to tracing a very simple 
 example.
  
 Note that the expressions 
 are indented according to 
 their level in the trace.
  
 TracePrint[ 2 - 3 * 4 ]
  
 2 - 3 4 
  
 P lu s 
  
 2
  
    
 - ( 3  4 ) 
  
      
 T im 
 es
  
         
 -1 
  
       
 3 
  
       
 4
  
    
 -12
  
 2 
  
 -10
  
 -  
 12
  
 -10
  
 As usual, you can limit the trace using a tag or pattern as a second argument.",NA
13.2.2 TraceDialog,"The most powerful interactive debugging command is TraceDialog. TraceDia- log 
 [expr, 
 form, options]
  enters a 
 dialog
  each time 
 form
  occurs during the eval-uation of 
 expr.
  A 
 dialog is a subsidiary 
 Mathematica
  session in the midst of some other evaluation during 
 which your interactive commands have the full attention of the ker-nel. A dialog can be 
 initiated at any time by calling the function Dialog. While inside a",NA
13.2.3 The evaluation stack,"Mathematica
  records computations in progress on the 
 evaluation stack,
  which can be 
 viewed at any time using the Stack function. It is quite useful in combination with 
 TraceDialog, as it shows how the computation came to be at its current point.",NA
13.2.4 TraceScan,"TraceScan [ f , 
 expr]
  applies the function f  to every intermediate expression in a trace 
 before 
 expr
  is evaluated. As usual, you can restrict the action of TraceScan by 
 specifying a tag or pattem as an additional argument.
  
 You can use TraceScan to cause some side effect such as keeping track of some 
 sta­tistics about a computation. For example, let’s count the number of assignments to 
 xn during the evaluation of ite rS q rt [2]:
  
 Note that the pure function 
 completely ignores its argu- 
  
 ment. 
  
 c = 
  
 0 :
  
 T ra c e S c a n  [c-H- &, i t e r S q r t  [2 ] ,
  
 ]
  
 x n  =  y _  / ;  NumberQ [U n e v a lu a te d  [y ] ]
  
 665857
  
 4 7 0 8 3 2
  
 The count includes the 
  
 assignment at the beginning 
  
 c 
  
 ^
  
 of the Module.
  
 Another possible application would be to abort a computation (by calling Abort [] 
 from within f) if some criterion is true, such as exceeding a given amount of time, 
 memory, iterations, etc.3
  
 TraceScan applies 
 f
   before the parts of the matched expression are evaluated. 
 TraceScan takes an optional fourth argument, which is a function that is to be applied to 
 the matched expression after the 
 parts
  of the expression (but not the expression itself) 
 have been evaluated.
  
 Exercises
  
 1. Use TraceScan to implement your own version of TraceDialog.
  
 2. Implement a function that prompts the user every time a message is generated, 
 ask-ing whether or not to abort the computation. (Use the Input function to prompt 
 the user.)
  
 3. Note that there are built-in mechanisms for imposing each of these 
 constraints that may be easier to use in many cases: the functions 
 MemoryConstrained and TimeConstrained, and the global variables 
 $RecursionLimit and $Itera- tionLimit.",NA
13.3 Additional Resources,"For a novel application of Trace, see [Gayley 95], which describes an 
 execution pro-filer
  
 for 
 Mathematica
  programs. An execution profiler is a run-time tool that breaks down the 
 execution time of a program into the parts that are attributable to particular statements or 
 functions within the program. It is useful for locating performance bottle-
  
 necks.
  
 [Smith 93] discusses the use of TraceDialog in some detail.
  
 Christopher R. Stover has written a package called tra c e U til that uses T race- Scan 
 to give the user detailed control over what parts of a trace are printed. It is avail-
  
 able as 
 MathSource
  item #0207-920.",NA
Bibliography,"[Aho & Ullman 77] 
  
  
 A.V. Aho and J.D. Ullman. 
 Principles of Compiler Design.
  Addison-Wesley, Reading, MA, 
  
 1977.
  
 [Blachman 92] 
  
  
 N. Blachman. 
 Mathematica: A Practical Approach.
  Prentice-Hall, Englewood Cliffs, NJ, 
  
 1992.
  
 [Clocksin & Mellish 84] 
  
  
 W.F. Clocksin and C.S. Mellish. 
 Programming in Prolog,
  2e. Springer-Verlag, Berlin, Ger-
  
 many, 1984.
  
 [Cormen et al. 90] 
  
 T.H. Cormen, C.E. Leiserson, and R.L. Rivest. 
 Introduction to Algorithms.
  McGraw-Hill, 
 New York, NY, 1990. (Also available from MIT Press, Cambridge, MA.)
  
 [Fleck 76] 
  
 A.C. Fleck. On the impossibility of content exchange through the by-name parameter 
 trans-mission mechanism. ACM 
 SIGPLAN Notices
  11(11):38^U.
  
 [Gayley 93a] 
  
 T. Gayley. CleanSlate: A package for clearing symbols and freeing memory. 
 The 
 Mathema-tica Journal
  3(3): 46-51. The 
 CleanSlate.m
  package is available as 
 MathSource
  
 item #0204-
  
 310.
  
 [Gayley 94a] 
  
 T. Gayley (with J. Fultz, D. Withoff, and R. Villegas). Customizing the X front end, 
 han-dling large lists, and generating surface plots. 
 The Mathematica Journal
  4(2):54-61.
  
 [Gayley 94b] 
  
  
 T. Gayley. A 
 MathLink
  program for accessing binary files. 
 The Mathematica Journal
  
 4(2):44-51.
  
 [Gayley 94c] 
  
 T. Gayley. A 
 MathLink Tutorial.
  Wolfram Research, Inc., Champaign, IL, 1994. Available as 
  
 MathSource
  item #0206-693.",NA
Index,"Symbols
  
 ! ! (show file) 388 
  
 ! (F acto rial) 31 
  
 ## (SlotSequence) 197 # 
 (Slot) 102 
  
 $Aborted 378 
  
 $Context 230 
  
 $ContextPath 234 
  
 $DefaultFont 179 
  
 $Display 396 
  
 $D isplayFunction 396 
 $Failed 404 
  
             
 returned from installable 
             
  
 functions 345 
  
 $HistoryLength 58 
  
 $ Iteratio n L im it 29 
  
 $M achinePrecision 20 
 $Messages 258 
  
 $0utput 395 
  
 $Packages 239 
  
 $Path 239 
  
 $Post 281 
  
 $Pre 281,292 
  
 $P reP rint 281 
  
 $PreRead 281 
  
 $RecursionLimit 152 
  
 $SystemID 345, 392 
  
 $TracePattern 416 
  
 % (previous result) 33 
  
 & (Function) 102 
  
 0  31 
  
 * (strin g  w ildcard) 46, 64 
  
 * (Times) 30 
  
 + (Plus) 30 
  
 / /  (postfix function application) 37 / / 
 .  (ReplaceRepeated) 152 
  
 /: ... := (TagSetDelayed) 177
  
 /: ...= (TagSet) 177 
  
 / @ (Map) 62, 98 
  
 := (SetDelayed) 33 
  
 :> (RuleDelayed) 147 
  
 «  (Get) 388 
  
 <> (S tringJoin) 65 
  
 = != (UnsameQ) 32 
  
 = (Set) 33 
  
 = . (Unset) 151 
  
 =
  
  (SameQ) 32 
  
 »  (Put) 388 
  
 » >  (PutAppend) 388 
  
 ? (help) 46 
  
 @ (prefix function application) 37 
 @@ (Apply) 98 
  
 [ [ ]] (Part) 42 
  
 A (Power) 30 
  
 A:= (UpSetDelayed) 177 
  
 A= (UpSet) 177 
  
 ' (context mark) 230 
  
 {} (list braces) 49 
  
 | (A lternatives) 164 
  
 ~ (infix function application) 37 - 
 (Subtract) 30 
  
 -> (Rule) 42
  
 A
  
 addition 30 
  
 And 32 
  
 A nnotation 243 
  
 AppendTo 59 
  
 Apply 98 
  
 approximate numbers 20 
 arithmetic 
  
    
 arbitrary-precision 20 
    
 exact 20 
  
    
  
 operators 30",NA
o ,"O neldentity 190 
  
 OpenAppend 392 
  
 OpenWrite 392 
  
 operators 
  
        
            
 arithmetic 30 
  
        
            
 assignment 33 
  
        
           
 relational and logical 31 
  
 Options 43, 162 
  
 options 
  
        
           
 to functions 43 
  
        
          
 implementing 161 
  
 Or 32 
  
 O rderless 190 
  
 OutputForm 277, 393 
  
 output formats 
  
        
       
 box representation 277 
  
        
        
 CForm 277 
  
        
        
 CommaDelimitedForm 391 
        
     
 customizing 274 
  
        
    
 DelimitedForm 391 
  
        
    
 FortranForm 277, 390 
  
        
        
 InputForm 277, 393 
  
        
  
 MatrixForm 50 
  
        
    
 OutputForm 277, 389, 393 
        
    
 O verscript 274 
  
        
     
 SequenceForm 275 
  
        
    
 SpaceDelimitedForm 390 
        
    
 StandardForm 277, 393 
  
        
    
 StringForm 275 
  
        
    
 S ubscript 274 
  
        
  
 Subscripted 274 
  
        
  
 S uperscript 274 
  
        
  
 TableForm 50, 389 
  
        
  
 TeXForm 394 
  
       
 TraditionalForm  277, 393 
 OwnValues 186
  
 P
  
 packages 229 
  
 annotations and keywords 243 
 AntiShadow 249
  
   
       
 C leanSlate 244 
  
   
      
 DependencyAnalysis 223 
   
      
 importing other packages 240 
   
    
 LCGRandom 237 
  
   
    
 Unshadow 248 
  
   
    
 U tilitie s 'P a c k a g e ' 243 
 parameters 72 
  
 parent-child connection 349 
  
 parentheses 31 
  
 parser traps 44 
  
 patterns 141 
  
   
   
 blank sequences 158 
  
   
   
 constraining 153 
  
   
   
 default values for 155 
  
   
  
 naming 162 
  
   
  
 repeated 163 
  
 peer-to-peer connection 349 
  
 P i 23 
  
 P o sitio n  57,134, 137 
  
 P recisio n  20 
  
 predicates 57 
  
 PrependTo 59 
  
 Prolog 150 
  
 P rotected 175, 179, 191 
  
 pure functions 101 
  
  
 and held expressions 213 
  
 Put 388 
  
 PutAppend 388",NA
Q ,"quicksort 310 
  
 R
  
 Random 36 
  
 Range 52 
  
 rank (of a tensor) 332 
  
 rational numbers 19 
  
 Read 403 
  
 reading 
  
  
  
 comma-delimited data 400 
  
 numbers 398 
  
  
  
 strings 399 
  
 ReadList 396 
  
 ReadProtected 191, 239 
  
 R ealL ist 346",NA
About the Author,"David B. Wagner is the president of Principia Consulting, which 
 provides train-ing and rnnsnlting on the 
 Mathematica
  system for doing 
 mathematics by com-puter. He also is a columnist for 
 The Mathematica 
 Journal
  and a consulting instructor at the 
 Mathematica
  Training Center 
 of Wolfram Research, Inc. Previously, he was a faculty member in the 
 Department of Computer Science at the University of Colorado, where 
 he used 
 Mathematica
  in his research on computer systems performance 
 analysis. Dr. Wagner holds a Ph.D. in Computer
  
 Science from the University of Washington.",NA
