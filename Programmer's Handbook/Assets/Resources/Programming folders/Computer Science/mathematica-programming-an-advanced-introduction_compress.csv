Larger Text,Smaller Text,Symbol
Mathematica,NA,NA
 programming:  an ,NA,NA
advanced introduction,NA,NA
Leonid     Shifrin,NA,NA
Part I: The core language,"Version 1.0
 1",NA
Leonid ,"Shifrin DN: cn=Leonid 
 Shifrin, o=Brunel University, ou, 
  
 Digitally signed by Leonid",NA
Shifrin ,"ming-intro.org, c=GB Date: 
 2009.02.04 11:30:22 -08'00' 
  
 email=leonid@mathprogram",NA
To my parents,NA,NA
Contents,NA,NA
Preface,NA,NA
.......................................................................................18,NA,NA
I. Introduction,NA,NA
..............................................................................26,"1.1    First principle: everything is an expression
 ................................................................26
  
  1.1.1      Atoms and the built-in AtomQ predicate
 ......................................................................26
  
 1.1.2      
 Mathematica
  normal (composite) expressions
 ............................................................26
  
 1.1.3      Literal equivalents of built-in functions, and FullForm command
 ................................26
  
 1.1.4.     All normal expressions are trees - TreeForm command
 ............................................ .27
  
 1.1.5.     Heads of expressions and the Head command
 ...........................................................27
  
 1.1.6      Accessing individual parts of expressions through indexing 
 ......................................28
  
 1.1.7      Levels of expressions and the Level command
 ...........................................................28
  
  1.2    Second principle: pattern-matching and rule substitution
 ...........................................30
  
  1.2.1       Rewrite Rules
 ..............................................................................................................30
  
 1.2.2       An example of a simple pattern-defined function
 ........................................................30
  
 1.2.3       Functions are really rules :  DownValues command.
 ...................................................31
  
 1.2.4       Example of a function based on a restricted pattern
 ...................................................31
  
 1.2.5       A bit about evaluation
 ..................................................................................................31
  
 1.2.6       Patterns allow for multiple definitions of the same function
 .........................................31
  
 1.2.7       Non - commutativity of rules substitution
 .....................................................................32
  
 1.2.8       Automatic rule reordering
 .............................................................................................32
  
  1.3      Third principle: expression evaluation
 ........................................................................33
  
 Summary
 ...............................................................................................................................33",NA
II. ,NA,NA
Elementary operations,NA,NA
..............................................................34,"2.1     Introduction
 ..................................................................................................................34
  
 2.2     Symbols and  variables
 ............................................................................................. ..34
  
  2.2.1      Legitimate symbol names
 ............................................................................................. 34
  
 2.2.2      Getting information about symbols",NA
III. Lists,NA,NA
......................................................................................... .58,NA,NA
 3.1  Introduction,NA,NA
.................................................................................................58,NA,NA
 ,NA,NA
3.2  The main rule of thumb when working with lists in Mathematica,NA,NA
.................58,NA,NA
 ,NA,NA
3.3  The content of lists,NA,NA
......................................................................................58,NA,NA
 ,NA,NA
3.4  Generation of lists,NA,NA
.......................................................................................58,"3.4.1       Generating a list by hand
 ................................................................................................58
  
 3.4.2       Generation of lists of equidistant numbers by the Range command
 ..............................59
  
 3.4.3       Generation of lists with the Table command
 ...................................................................59
  
 3.4.4       A comment on universality of Range
 ..............................................................................60
  
 3.4.5       Generation of lists inside loops
 .......................................................................................62",NA
 3.5  Internal (full) form of lists,NA,NA
.............................................................................64,NA,NA
 ,NA,NA
3.6  Working with lists and their parts,NA,NA
3.6  Working with lists and their parts,NA,NA
................................................................64,"3.6.1      List indexing and element extraction with the Part command
 .........................................64
  
 3.6.2      Extract
 .............................................................................................................................66
  
 3.6.3      Take and Drop
 ................................................................................................................66
  
 3.6.4      First, Rest, Last and Most
 ...............................................................................................67
  
 3.6.5      Length
 .............................................................................................................................67
  
 3.6.6      Modification of list elements by direct indexing (using Part)
 ...........................................68
  
 3.6.7      ReplacePart
 ....................................................................................................................69
  
 3.6.8      Position
 ...........................................................................................................................70",NA
 3.7    Adding elements to the list and removing them from the list,NA,NA
.....................75,"3.7.1     Append, Prepend, AppendTo and PrependTo
 ................................................................75
  
 3.7.2     Insert and Delete
 .............................................................................................................76",NA
 3.8     Working with nested lists,NA,NA
.........................................................................77,"3.8.1     Partition
 ...........................................................................................................................77
  
 3.8.2     Transpose
 .......................................................................................................................81
  
 3.8.3      Flatten 
 ...........................................................................................................................82",NA
 3.9    Working with several lists,NA,NA
.........................................................................84,"3.9.1     The Join command
 .........................................................................................................85
  
 3.9.2     The Intersection command
 .............................................................................................85
  
 3.9.3     The Complement command
 ...........................................................................................85",NA
 3.10    Functions related to list sorting ,NA,NA
..............................................................86,"3.10.1    The Sort command
 ........................................................................................................86
  
 3.10.2    The Union command
 .....................................................................................................88
  
 3.10.3    The Split command
 ........................................................................................................89",NA
 Summary,NA,NA
..........................................................................................................91 ,NA,NA
IV.  ,NA,NA
"Rules, patterns and functions",NA,NA
..................................................92,NA,NA
 4.1    Introduction,NA,NA
..............................................................................................92,NA,NA
 ,NA,NA
4.2    Rules and patterns,NA,NA
4.2    Rules and patterns,NA,NA
..................................................................................92,"4.2.1      Rule,  RuleDelayed, Replace and ReplaceAll commands
 ...........................................92
  
 4.2.2      Rule substitution is not commutative
 ...........................................................................95
  
 4.2.3      An interplay between rules and evaluation process
 .....................................................96
  
 4.2.4      Rules and simple (unrestricted) patterns
 .....................................................................98
  
 4.2.5      Applying rules repeatedly - the ReplaceRepeated function
 ........................................111
  
 4.2.6      Conditional (restricted) patterns
 ..................................................................................114
  
 4.2.7      Alternative patterns
 .....................................................................................................120
  
 4.2.8      Giving names to entire patterns - the Pattern command 
 ............................................121
  
 4.2.9      Optional patterns
 .........................................................................................................121
  
 4.2.10    Repeated patterns
 .......................................................................................................122",NA
 4.3     Built-in functions that use patterns,NA,NA
........................................................123,"4.3.1     Cases
 ...........................................................................................................................123
  
 4.3.2     DeleteCases
 .................................................................................................................128
  
 4.3.3     MemberQ
 ......................................................................................................................130
  
 4.3.4     Position  - a second look
 ...............................................................................................132
  
 4.3.5     Count
 .............................................................................................................................133
  
 4.3.6     FreeQ
 ............................................................................................................................134
  
 4.3.7     A note on the Heads option
 ...........................................................................................134
  
 4.3.8     A more complicated example - finding subsequences
 ..................................................134",NA
 4.4    Functions - starting examples and syntax,NA,NA
..............................................138,"4.4.1     A definition and a simple example
 ................................................................................138
  
 4.4.2     More on function names and evaluation surprises
 .......................................................139
  
 4.4.3     On the necessity of patterns
 .........................................................................................139
  
 4.4.4     More on the correct syntax of the function calls
 ............................................................140
  
 4.4.5     On function definitions and assignment operators
 ........................................................141
  
 4.4.6     Assigning values to function symbols (names)
 .............................................................143
  
 4.4.7     Advanced topic:   parameter passing
 ............................................................................144
  
 4.4.8     Function calls: prefix and postfix syntax 
 .......................................................................149
  
 4.4.9     Function name conventions
 ...........................................................................................151",NA
 4.5     Examples of functions of a single argument,NA,NA
4.5     Examples of functions of a single argument,NA,NA
...........................................151,"4.5.1     Example:   Integer part of a number
 ..............................................................................152
  
 4.5.2     What we will not call a function definition
 ......................................................................152
  
 4.5.3     Example: some trigonometric function
 ..........................................................................153
  
 4.5.4     Example:  a function to reverse a string of symbols 
 .....................................................153
  
 4.5.5     Example:  A function of function
 ....................................................................................154
  
 4.5.6     Example:  a function which exchanges another function and its argument
 ...................155
  
 4.5.7     Example:  a recursive factorial function
 .........................................................................155
  
 4.5.8     Infinite iteration and recursion traps
 ...............................................................................156
  
 4.5.9     An esoteric example: a self-destructive printing function
 ..............................................157
  
 4.5.10   Mathematical functions and programming functions
 .....................................................158",NA
 4.6     Functions of several variables,NA,NA
................................................................159,"4.6.1     Starting examples and a definition
 ................................................................................159
  
 4.6.2     Putting constraints on the arguments
 ............................................................................160
  
 4.6.3     Examples of functions of several variables (arguments)
 ..............................................163
  
 4.6.4     Functions with the variable number of arguments
 .........................................................171",NA
 4.7    Functions with multiple definitions,NA,NA
...........................................................173,"4.7.1      Example: a discontinuous function
 ...............................................................................173
  
 4.7.2      Adding more definitions
 ................................................................................................174
  
 4.7.3      Changing definitions selectively
 ...................................................................................175
  
 4.7.4      Warning: a common mistake
 ........................................................................................176
  
 4.7.5      Selective removal of the definitions
 ..............................................................................176
  
 4.7.6      Case study: changing the weights of words
 ................................................................ .176",NA
" 4.8 Larger functions, local variables and the code modularization",NA,NA
...................180,"4.8.1      Module
 ...........................................................................................................................180
  
 4.8.2      Block
 ..............................................................................................................................181
  
 4.8.3.     With
 ...............................................................................................................................182",NA
 4.9  Function attributes,NA,NA
.....................................................................................182,4.9.1      Listable attribute and SetAttributes command,NA
 4.10    Advanced topic: parameter passing and local variables,NA,NA
.......................192,NA,NA
 ,NA,NA
4. 11   Pure functions,NA,NA
.......................................................................................194,"4.11.1     The # - & notation
 ........................................................................................................195
  
 4.11.2     Pure functions defined with  Func
 t
 ion
 ..........................................................................201
  
 4.11.3     Differences between pure functions defined with Function and with # - & notation
 .....202",NA
 4.12     Functions with defaults and options ,NA,NA
....................................................205,"4.12.1     Functions with defaults
 ................................................................................................205
  
 4.12.2     Funct
 i
 ons with options
 .................................................................................................206",NA
 Summary,NA,NA
..................................................................................................212 ,NA,NA
V. ,NA,NA
Functions on lists and functional programming,NA,NA
.......................214,NA,NA
 5.1   Introduction,NA,NA
.............................................................................................214,NA,NA
 ,NA,NA
5.2   Core higher-order functions,NA,NA
....................................................................215,"5.2.1    Introduction
 .....................................................................................................................215
  
 5.2.2    Map
 .................................................................................................................................215
  
 5.2.3    MapAt
 .............................................................................................................................227
  
 5.2.4    MapAll
 ............................................................................................................................232
  
 5.2.5    Scan
 ...............................................................................................................................235
  
 5.2.6    MapIndexed
 ....................................................................................................................236
  
 5.2.7    Apply
 ..............................................................................................................................244
  
 5.2.8    When short-hands let us down: the Heads option
 .........................................................255",NA
 5.3      Generalizations,NA,NA
5.3      Generalizations,NA,NA
......................................................................................257,"5.3.1     Thread
 ........................................................................................................................257
  
 5.3.2     MapThread
 .................................................................................................................263
  
 5.3.3     Inner
 ...........................................................................................................................277
  
 5.3.4     Outer
 ..........................................................................................................................280",NA
 5.4      Nest Family ,NA,NA
...........................................................................................292,"5.4.1     Nest and NestList
 .......................................................................................................292
  
 5.4.2     NestWhile and NestWhileList
 .....................................................................................301",NA
 5.5     Fold and FoldList,NA,NA
....................................................................................320,"5.5.1    Fold: syntax and starting examples
 .............................................................................320
  
 5.5.2    More examples
 ............................................................................................................320
  
 5.5.3    Restriction of Fold-ed function to two arguments is spurious
 ......................................330
  
 5.5.4    Case study: Gram - Schmidt orthogonalization
 ...........................................................333
  
 5.5.5    Small case study: local maxima for a list
 ....................................................................339",NA
 5.6   FixedPoint and FixedPointList ,NA,NA
..................................................................342,"5.6.1    The syntax and functionality
 ........................................................................................342
  
 5.6.2    Example:  the Collatz problem revisited
 ......................................................................342
  
 5.6.3    How to reformulate a problem for FixedPoint
 ..............................................................343
  
 5.6.4    Example:  deleting numbers from the list revisited
 ......................................................343
  
 5.6.5    Example:  approximating the square root of a number revisited
 .................................344
  
 5.6.6    FixedPoint dangers
 .....................................................................................................344
  
 5.6.7    Small case study: merging overlapping intervals - Functional vs. Rule-based
 ...........345
  
 5.6.8    Example:  local (relative) maxima in a list revisited
 ....................................................348",NA
 5.7     Operators on functions,NA,NA
...........................................................................350,"5.7.1     Through
 ......................................................................................................................350
  
 5.7.2     Operate
 ......................................................................................................................353",NA
 Summary,NA,NA
Summary,NA,NA
...........................................................................................................354 ,NA,NA
VI. ,NA,NA
Writing efficient programs: some techniques and applications,NA,NA
...355,NA,NA
 6.1    Introduction,NA,NA
...............................................................................................355,NA,NA
 ,NA,NA
6.2    Case study I:  checking if a square matrix is diagonal,NA,NA
..............................355,"6.2.1    The problem
 ..................................................................................................................355
  
 6.2.2    The test matrices
 ..........................................................................................................355
  6.2.3    
 Procedural implementation
 ...........................................................................................355
  6.2.4    
 Functional implementations
 ..........................................................................................356
  6.2.5    
 Implementations based on structural operations
 ..........................................................357
  6.2.6    
 Conclusions
 ..................................................................................................................361",NA
 6.3     Case study II:  extracting matrix diagonals,NA,NA
..............................................362,"6.3.1    The problem
 .................................................................................................................362
  
 6.3.2    Test matrices
 ................................................................................................................362
  6.3.3    
 Extract - based implementation
 ....................................................................................362
  6.3.4    
 Procedural implementation
 ...........................................................................................369
  6.3.5    The 
 fastest version for all diagonal extraction, based on  structural operations
 ...........371
  6.3.6    
 Conclusions
 ..................................................................................................................375",NA
 6.4    Case study  III: generating complex random  Wishart matrices,NA,NA
...............376,"6.4.1    The problem
 .................................................................................................................376
  
 6.4.2    Preliminaries
 ................................................................................................................376
  
 6.4.3    Procedural implementation
 ..........................................................................................376
  
 6.4.4    Functional implementation
 ...........................................................................................377
  
 6.4.5    Implementation based on structural operations
 ...........................................................379
  
 6.4.6    Conclusions
 .................................................................................................................380",NA
" 6.5   Case study  IV: sorting, mapping and membership tests",NA,NA
..........................381,"6.5.1    The problem
 ................................................................................................................381
  
 6.5.2    Test sets",NA
 Summary ,NA,NA
.........................................................................................................394,NA,NA
Appendices,NA,NA
.............................................................................................................395,"Appendix A   What is so special about 
 Mathematica 
 (a personal evaluation) 
 .........................395
  
 Appendix B   Some of my favorite books on 
 Mathematica 
 programming  -  brief reviews
 ..  ....399
  
 Appendix C   Performance of some built-in functions in certain important special cases
 .........401
  
  ReplacePart
 .........................................................................................................................401
  
 Insert
 ....................................................................................................................................401
  
 Union, Intersection
  and 
 Complement
 ...................................................................................402
  
 Sort 
 .....................................................................................................................................404
  
 MapAt
 ..................................................................................................................................405
  
  Appendix D  Some online 
 Mathematica
  resources
 .....................................................................407",NA
The bibliography,NA,NA
......................................................................................................408,NA,NA
List of case studies and selected examples,NA,NA
Examples,"3.6.8.3          Extracting sublists containing given element
 .................................................................71
  
 3.6.8.4          Sublists with odd number of odd elements
 ....................................................................72
  
 3.8.1.2          Computation of the moving average in a list.
 .................................................................77
  
 3.8.2.3          Combining names with grades
 .......................................................................................81
  
 3.8.3.3          Computation of quadratic norm of a tensor of arbitrary rank (vector, matrix etc).
 ..........83
  
  3.8.3.4          Relatively fast list generation with Flatten
 ......................................................................84
  
 3.10.3.3        Run-length encoding
 ......................................................................................................90
  
 3.10.3.4        Computing frequencies of identical list elements
 ...........................................................90
  
 4.2.4.4          Patterns:  any  function of a single fixed argument
 .......................................................101
  
 4.2.4.5          Patterns:  any function of 2 arguments, but with the first fixed
 ......................................101
  
 4.2.4.6          Patterns:  combining 1, 2 and 3-argument cases together
 ............................................102
  
 4.2.4.10        Patterns:  rule within a rule, and a better catchall solution for our example
 ..................104
  
 4.2.4.15        Patterns:  a bit more useful example
 ............................................................................109
  
 4.2.5.1          ReplaceRepeated: sorting a list of numbers
 .................................................................111
  
 4.2.5.2          ReplaceRepeated: deleting duplicate elements
 ...........................................................111
  
 4.2.5.3          ReplaceRepeated - a rule-based factorial
 ....................................................................112
  
 4.3.1.2          Filtering data
 .................................................................................................................123
  
 4.3.1.6          Sublists with odd number of odd elements: pattern-based solution
 .............................126
  
 4.3.1.9          Collecting  terms in a polynomial of 2 variables
 ...........................................................127
  
 4.3.2.1          Deleting odd numbers from a list
 .................................................................................128
  
 4.3.2.2          Non-zero ineteger subsequences
 ................................................................................129
  
 4.3.3.4          Unsorted Intersection
 ...................................................................................................131
  
 4.3.4.2          An example with symbolic expression
 .........................................................................132
  
 4.3.5.2          Counting characters
 ....................................................................................................133
  
 4.3.8             Locating given  subsequences
 ....................................................................................134
  
 4.5.5             Functions of a single argument:  a function of function
 ...............................................154
  
 4.5.6             Functions of a single argument:  a function which exchanges another function
 .........155 
  
 and its argument
  
  4.5.7             Functions of a single argument:  a recursive factorial function",NA
Case studies,"4.7.6          Changing the weights of words
 .......................................................................................176
  
 5.3.2.3       Checking lists for equality
 ...............................................................................................265
  
 5.3.4.7       Creating ordered subsets for a given set
 ........................................................................286
  
 5.4.1.7       Sorting a list of numbers
 .................................................................................................297
  
 5.4.2.7       Automatic and programmatic construction of patterns - patterns for poker 
 ...................311 
  
 combinations revisited  (not NestWhile - related)
  
  5.4.2.8       Fibonacci numbers
 .........................................................................................................314
  
 5.5.4          Gram - Schmidt orthogonalization
 ..................................................................................333
  
 5.5.5          Local maxima for a l
 is
 t
 ....................................................................................................339
  
 5.6.7          Merging overlapping intervals - Functional vs. Rule-based
 ............................................345
  
 6.2             Checking if a square matrix is diagonal
 ..........................................................................355
  
 6.3             Extracting matrix diagonals
 .............................................................................................362
  
 6.4             Generating complex random Wishart matrices
 ...............................................................376
  
 6.5             Sorting, mapping and membership tests
 .........................................................................381",NA
Preface,"The history of this project
  
 I started using 
 Mathematica
   about 10 years ago for my Masters thesis. Since then, I have been using it 
 occasionally during my PhD, until about 3 years ago. At that point, just for curiosity,  I tried to use 
 Mathe-
 matica
   for  a small side project which had nothing to do with the field of my professional activity 
 (theoretical physics). And then, I have suddenly discovered that behind all the built - in commands and 
 simple procedural  programming constructs there is a much more powerful programming language (the fact 
 of course well-known by then to lots of people, but not to me). I was hooked and spent some time 
 experimenting with its different features and then read a few books to get a deeper insight into it. At that 
 time, it was mostly for my own amusement, since ways in which I used 
 Mathematica 
 professionally did not 
 require even a fraction of the full power of this language. However, the character of my work has changed 
 since, and it’s been about one and a half years now that I use 
 Mathematica
  heavily on a daily basis and very 
 frequently need the full power it can give me, in terms of speed, numerical and symbolic capabilities. And I 
 can safely say that without the knowledge of how to program in it properly, most of my recent scientific 
 results would be a lot harder to get.  At some point, I decided to create some notes on 
 Mathematica
  
 programming, mainly for myself, and also to somehow organize the code that I have accumu-lated so far for 
 various projects. But as the notes started to expand, it occur
 r
 ed to me that with some more effort I could 
 convert them into a text possibly useful for other people. So, that’s how it started. 
  
  The audience for this book
  
 When writing this book  I mostly had in mind people who want to understand 
 Mathematica
   program-ming, 
 and particularly those 
 Mathematica
  users who would like to make a transition from a user to a programmer, 
 or perhaps those who already have some  limited 
 Mathematica
  programming experience but want to improve 
 their command of the system. Expert 
 Mathematica
  programmers will probably find little new information in 
 the book  - may be, the last chapter could be of some interest to them.
  
 The first part of the audience for this book  are  scientists who would like to  understand 
 Mathematica 
 programming better, to take advantage of the possibilities it offers. The second part are (software) engi-neers 
 who may consider 
 Mathematica
   as a tool for a prototype design. In this context, 
 Mathematica
   can serve as 
 a tool of ""experimental programming"",  especially useful in projects  where  some  non-trivial 
 computations/research have to accompany programming.",NA
I. Introduction,"Mathematica
   is built on a small number of universal principles. Good understanding of these principles is a 
 pre-requisite for understanding how to program in 
 Mathematica.  
 Here I will discuss them, but rather 
 briefly. Excellent and in-depth discussion of them can be found in several places [1,2,6 - 9]. 
  
  1.1  First principle: everything is an expression
  
 The first principle states that every object dealt with by 
 Mathematica
 , is an expression. Every 
 Mathe-
 matica
  expression is either Atom, or a Normal Expression. 
  
  1.1.1 Atoms and the built-in AtomQ predicate
  
 Atoms are numbers, symbols and strings, and numbers are further divided into Integers, Reals, Rationals 
 and Complex. All other objects are composite and are called Normal Expressions.  It is always possible to 
 check whether or not an expression is an atom or a composite, by acting on it with the built-in predicate 
 AtomQ. For instance:
  
 ClearAll""Global‘""; 
  
  
 AtomQx, AtomQSinx, AtomQ1I 2, AtomQ2 3
  
 True, False, True, True
  
  1.1.2 
 Mathematica
  normal (composite) expressions
  
 Every normal expression (composite) is built according to a universal pattern:
  
 exprel1, ..., eln
  
 Here it is required that some symbol < expr > is present (it can itself be a normal expression, not necessar-
 ily an atom), as well as the single square brackets. Inside the square brackets, there can be zero, one or 
 several comma-separated  elements <el1>,...,<eln>.  These elements themselves can be either atoms or 
 normal expressions. In an expression Sin[x], <expr> is Sin, and there is a single element <x>, which is atom 
 (as long as x is not defined as something else, but this already has to do with expression evaluation and will 
 be discussed below). It is clear that an arbitrary 
 Mathematica
  expression must have a tree-like structure, 
 with the branches being normal (sub)expressions and leaves being atoms.
  
  1.1.3 Literal equivalents of built-in functions, and FullForm command
  
  As a consequence, any built-in command/function in 
 Mathematica
  has a literal/string equivalent (so that it 
 can be represented  in the above uniform way). This is most easily seen with the help of the built-in function 
 FullForm, which shows the internal representation of any object/expression, in the way it is really ""seen"" by 
 the kernel. For instance:
  
 z Sinxy, FullFormz Sinxy
  
 z Sinxy,
  Timesz, SinPlusx, y
  
 The second expression in the curly braces is equivalent to the first one, but explicitly shows the structure 
 described above.",NA
II. Elementary operations,"2.1     Introduction
  
 In this chapter we will discuss some basic operations with variables such as assignments, and also some 
 procedural control flow structures, such as conditionals and loops.
  
  2.2   Symbols and  variables 
  
 In 
 Mathematica
  , variables are (possibly composite) symbols that can store some definitions. More pre-
 cisely, as  variables can be used expressions which can be the l.h.s. of global rules not containing patterns 
 (consider this as our definition of variables. What it means is explained below). 
  
  2.2.1    Legitimate symbol names
  
 An immediate comment on legal symbol names is due here. Any name which has a head Symbol and is not 
 a name used by the system, is legal to associate some rules (global definitions) with - in other words, a legal 
 name for a variable or a function. It can not start with a number, but can contain numbers. It can contain 
 both capital and small letters, and 
 Mathematica
  is case-sensitive, so names like <totalsum> and <totalSum> 
 are considered different. There are several special symbols that should not be used in symbol names, such as 
 @,#,$,%,^,&,*,!,~,‘. What may be surprising for C programmers  is that the underscore <_> should not be 
 used either - it has a different purpose in 
 Mathematica. 
  
 If  you  are  in  doubtwhether  your  symbol  is  legitimate,  you  can  always  use  the  
 Head[-
 Unevaluated[yoursymbol]]
   command  to check its head: if it is <Symbol>, you are in business. The 
 reasons why you need <Unevaluated> are a bit involved to discuss now, but basically it guarantees that the 
 Head function tests the head of your original symbol rather than what it may evaluate to. For instance, you 
 decide to use <a&&True> symbol. This is the result of using Head:
  
 Heada && True
  
 Symbol
  
 We happily try to assign something to it :
  
 a && True b
  
 Set::write : Tag And in a && True is Protected.
  
 b
  
 and get an error message. 
  
 What happens is that our symbol is really a logical And of <a> and True, and it evaluates to <a> when we 
 try to use Head function - so the head seems to be Symbol. But in the assignment, the original symbol is 
 used, and its head is And. For reasons which will become clear soon, this leads to an error. Using Head[-
 Unevaluated[symbol]] reveals that our symbol is bad:
  
 HeadUnevaluateda && True
  
 And
  
 This behavior will become clear after we cover more material.",NA
III. Lists,NA,NA
3.1     Introduction,"Lists are the main data structure in  
 Mathematica
 , and also in functional programming languages such as 
 LISP. Any complex data structure can be represented as some (perhaps, complex and nested) list. For 
 example, N-dimensional array is represented as a list with depth N. Any tree can also be represented as a 
 list.
  
 Lists can be generated dynamically during the process of program execution, and the correctly written 
 functions work on lists of arbitrary length without taking the length of the list as an explicit parameter. This 
 results in a quite ""clean"" code, which is at the same time easy to write. Another advantage of lists is that it 
 is usually easy to debug functions that work on them - we will see many examples of these features.
  
 In this chapter we will cover several built-in functions which are used to generate and process lists.",NA
3.2     The main rule of thumb when working with lists in Mathematica,"When we work with lists in 
 Mathematica
 ,  especially large ones, it makes sense to stick to the following 
 main rule: any list we have to treat as a single unit, and avoid operations that break it into pieces, such as 
 array indexing. In other words, the best programming style is to try writing the programs such that the 
 operations are applied to the list as a whole. This approach is especially important in the functional pro-
 gramming style, and leads to significant increase of code efficiency. We will illustrate this issue on many 
 examples, particularly in the chapter V on functional programming.",NA
3.3       The content of lists,"Lists are not required  to contain only elements of the same type - they can contain any 
 Mathematica 
 expressions mixed in an arbitrary way. These expressions may themselves be lists or more general 
 Mathe-
 matica
  expressions, of any size and depth. Essentially, a list is a particular case of a general 
 Mathematica 
 expression, characterized by having the head List:
  
 Clearx; 
  
 ListSinx, Cosx, Tanx
  
 Sinx, Cosx, Tanx",NA
3.4         Generation of lists,"There are many ways to generate a list
  
  3.4.1        Generating a list by hand
  
 First of all, it is of course possible to generate a list by hand. That is, some fixed lists in the programs are 
 just defined by the programmer. For instance:",NA
3.5        Internal (full) form of lists,"Let me emphasize once again that internal form of  lists satisfies the general requirement of how normal 
 expressions are built in 
 Mathematica
  (see chapter I). For example, here are simple and nested lists:
  
 Cleartestlist, complextestlist; 
  
 testlist Range10 
  
 complextestlist Range Range5
  
 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  
 1,1, 2,1, 2, 3,1, 2, 3, 4,1, 2, 3, 4, 5
  
 And here are their full forms:
  
 FullFormtestlist
  
 List1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  
 FullFormcomplextestlist
  
 ListList1, List1, 2, List1, 2, 3, List1, 2, 3, 4, List1, 2, 3, 4, 5
  
 This shows in particular that list indexing can be performed in the same way as indexing of more general 
 no
 r
 mal 
 Mathematica
   expressions, outlined in chapter I. We will use this fact in the next subsection.
  
 Cleartestlist, complextestlist;",NA
3.6       Working with lists and their parts,"3.6.1   List indexing and element extraction with the Part command
  
  3.6.1.1     Simple lists
  
 Consider a simple list:
  
 Cleartestlist; 
  
 testlist Range1, 20, 3
  
 1, 4, 7, 10, 13, 16, 19
  
 Say we need to extract its first element. This is accomplished as follows:
  
 testlist3
  
 7
  
 Or, which is the same, like this:",NA
3.7    Adding elements to the list and removing them from the list,"3.7.1     Append, Prepend, AppendTo and PrependTo
  
 Some of these commands we have already encountered before. They add an element to the end or to the 
 beginning of the list. For example:
  
 Cleara; 
  
 testlist Range5
  
 1, 2, 3, 4, 5
  
 Appendtestlist, a
  
 1, 2, 3, 4, 5, a
  
 Prependtestlist, a
  
 a, 1, 2, 3, 4, 5
  
 testlist
  
 1, 2, 3, 4, 5
  
 The last output shows that the list <testlist> did not change. As we discussed, the absence of side-effects is 
 typical for 
 Mathematica
   built-in functions. In this case, Append and Prepend forged a copy of <testlist> and 
 modified this copy. If we want an original list to be modified, we have either to write:
  
 testlist Appendtestlist, a; 
  
  
 testlist
  
 1, 2, 3, 4, 5, a
  
 or, which is equivalent, to use the function AppendTo, which does exactly this:
  
 testlist Range5
  
 1, 2, 3, 4, 5
  
 AppendTotestlist, a; 
  
 testlist
  
 1, 2, 3, 4, 5, a
  
 The situation with Prepend  and PrependTo  is completely analogous. And also, recalling the previous 
 discussions, we may suspect that the application of AppendTo or PrependTo to a list which is not assigned to 
 any variable (not an L-value) is a mistake, and we will be correct:
  
 AppendRange5, a
  
 1, 2, 3, 4, 5, a",NA
3.8     Working with nested lists,"It is often necessary to work with nested lists, that is - lists whose elements themselves are lists. We have 
 seen simple examples of such lists already. Let me emphasize that in general such lists are not identical to 
 multidimensional arrays but in fact much more general, because the lengths of sublists at each level can be 
 different. The only thing we can say about the general nested list is that it represents some tree. 
  
 Here we will consider several special-purpose commands which were designed for efficient processing of 
 some special types of such nested lists.
  
  3.8.1   Partition
  
 This command is used to ""cut"" or ""slice"" some list into (possibly overlapping) pieces. In its simplest form, it 
 has a format 
 Partition[list, size, shift]
 . It cuts the list into pieces with the length <size>, and shifted one with 
 respect to another by <shift>. If the <shift> parameter is not given, the list is cut into non-overlapping pieces. 
 For example:
  
  3.8.1.1   A simple example
  
 testlist TableSqrti,i, 1, 10
  
 1,
  
 2 ,
  
 3 , 2,
  
 5 ,
  
 6 ,
  
 7 , 2
  
 2 , 3,
  
 10
  
 Partitiontestlist, 3
  
 1,
  
 2 ,
  
 3,2,
  
 5 ,
  
 6, 7 , 2
  
 2 , 3
  
 Partitiontestlist, 7
  
 1,
  
 2 ,
  
 3 , 2,
  
 5 ,
  
 6 ,
  
 7
  
 In the last example, the remaining piece had a size smaller than 7, so it was ""eaten up"". Now we will 
 partition with overlaps:
  
 Partitiontestlist, 7, 1
  
 1,
  
 2 ,
  
 3 , 2,
  
 5 ,
  
 6 
 ,
  
 7, 2 ,
  
 3 , 2,
  
 5 ,
  
 6 ,
  
 7 , 2
  
 2,
  
  3 , 2,
  
 5 ,
  
 6 ,
  
 7 , 2
  
 2 , 3,2,
  
 5 ,
  
 6 ,
  
 7 , 2
  
 2 , 
 3,
  
 10
  
  3.8.1.2   An example of practical use: computation of the moving average in a list.
  
 This example is based on a similar discussion in Wagner’ 96.
  
 The problem
  
 The m-moving average for a list is an average which is obtained by averaging every element in a list with 
 <m> neighbors to the right and to the left (which means that this quantity is only defined for points 
 (elements)  having at least m neighbours both to the left and to the right). Thus, moving average is actually a 
 list of such averages, of the length <len>-2m, where <len> is a length of an initial list.",NA
3.9    Working with several lists,"It is often necessary to obtain unions, intersections, and complements of two or more lists, and also to 
 remove duplicate elements from a list. This is done by such built-in commands  as Join, Intersection, 
 Complement and Union.",NA
3.10        Functions related to list sorting ,"Here we will discuss three very useful built-in functions related to list sorting. 
 Sort 
 function sorts the list. 
 Union
  function removes duplicate elements from the list and also sorts the result. 
 Split
  function splits the 
 list into  sublists of  same  adjacent  elements.  For  all three  functions,  one  can  define  the  notion  of 
 ""sameness"" different from the default one. Below we give more details and examples of  use for every of 
 these functions.
  
  3.10.1   The Sort command
  
  3.10.1.1    Basic Sort 
  
 This function is used for list sorting. For example : 
  
  
  
 Cleara, b, c, d, e, f, g, t; 
  
  
  
 Sorta, d, e, b, g, t, f, d, a, b, f, c 
  
  
   
 a, a, b, b, c, d, d, e, f, f, g, t 
  
  
  
 Sort5, 7, 2, 4, 3, 1 
  
  
   
 1, 2, 3, 4, 5, 7 
  
 Sort will sort a list of arbitrary 
 Mathematica
  expressions. By default, the sorting is performed lexicographi-
 cally for symbols, in ascending order for numbers, by the first elements for lists. In general, this is called a 
 canonical sorting order in 
 Mathematica
  - consult 
 Mathematica
  Help for more information.
  
  For example, here we will sort a nested list of integers: 
  
  
 nested 
  
  
  
 TableRandomInteger,1, 15,5,RandomInteger,3, 10 
   
 13, 
 3, 11, 7,15, 15, 14, 11, 15, 14, 
  
  
  
 11, 10, 2,11, 12, 9, 11, 1, 4,7, 4, 15, 11, 9",NA
Summary,"In this chapter we introduced  lists - the main building blocks of data structures  in 
 Mathematica
 . We 
 considered various operations on lists such as list generation, element extraction, addition, replacement and 
 deletion, locating elements with certain properties in the list, and also several specialized commands for 
 fast structural operations on one or several lists, as well as those related to sorting of lists. The follow-ing 
 built-in functions were considered in detail: Range,Table,Part, Extract, Take, Drop, First, Rest, Most, Last, 
 Position, Length, Append,  Prepend,  AppendTo,  PrependTo,  Partition, Transpose,  Flatten, Join, Union, 
 Intersection, Complement, Sort, Split. 
  
 Armed with these functions, we can already go a long way in solving various problems. However, we need 
 another major component for serious program building - an understanding of functions in 
 Mathemat-ica
 : 
 what they are,  how to define them, etc. This is a topic of the next chapter.",NA
"IV.  Rules, patterns and functions",NA,NA
4.1      Introduction,"In this chapter we will introduce the notion of functions in 
 Mathematica
 , and also consider numerous 
 examples of functions. Since the 
 Mathematica
  programming language is to a large extent a functional 
 programming  language, functions are the central objects here. Also, since lists are used  as universal 
 building blocks for data structures,  and any complex data structure can be built with lists and modified ""on 
 the fly"", the emphasis is shifted more towards functions, as compared say to OO programming lan-guages. 
  
 Another important aspect of functions and functional programming in 
 Mathematica
  is that this ""layer"" of 
 programming is built upon a (in my view, more fundamental in 
 Mathematica
 ) rule-based engine. This 
 results in the notion of function which is wider than, and also s
 i
 gnificantly different from that in most other 
 programming languages. Thus, one will not have a complete grasp of functions in 
 Mathematica 
 without the 
 understanding of rules and rule-based programming techniques. We will discuss them here as well.",NA
4.2       Rules and patterns,"To better understand functions in 
 Mathematica
 , we need a good understanding of patterns and rule substi-
 tution. These two topics are just two facets of a single one, since it is the form of the pattern which deter-
 mines when (on which class of objects) the associated rule will apply.
  
  4.2.1    Rule,  RuleDelayed, Replace and ReplaceAll commands
  
  4.2.1.1     Basic rules and the Rule head (function)
  
 It is very easy to organize a rewrite rule in 
 Mathematica
 . For example, the following rule will replace a to b
  
 Cleara, b, ourrule; 
  
 ourrule a b
  
 a b
  
 The literal equivalent to the arrow (which represents the rule) is the Rule command.  If we look at the 
 FullForm of < ourrule > variable, we see that Rule is used :
  
 FullFormourrule
  
 Rulea, b",NA
4.3     Built-in functions that use patterns ,"Let us look at some highly useful built-in functions which take patterns as some of their arguments. One 
 such function - MatchQ - we already discussed.
  
  4.3.1   Cases
  
 This function is used for expression destructuring. More precisely, it is used to search for subexpressions 
 inside an expression, which match certain pattern. 
 Cases[expr, pattern]
  returns all elements of <expr> on 
 the level 1, which match the pattern <pattern>. As an optional third argument Cases takes a level specifica-
 tion, which can be an integer (positive or negative, including Infinity), an integer in list braces, or a  pair of 
 integers in a list. In the first case, Cases performs search on all levels up to and including the indicated 
 number (from the top or from the bottom of the expression tree, depending on its sign), in the second case it 
 only searches on the indicated level only, and in the third case it searches in the range of levels given by the 
 two numbers in the list. As an optional fourth argument, it accepts an integer indicating how many results 
 have to be found until Cases stops. If it is not given, Cases will produce all the results on given level(s) of 
 expression. 
  
 Now some examples :
  
  4.3.1.1  Example: choosing integers from the list
  
 The simplest example: let us choose all integer numbers from a simple (1-dimensional) list:
  
 Cleartestlist; 
  
 testlist3 2, Pi, 3, 1.4142135, 10, 99.99, 15, 25;
  
 Casestestlist,Integer
  
 3, 10, 15, 25
  
 Notice that here we don’t even need to attach a tag to the pattern, since we don’t  need to perform any 
 transformations on the results. 
  
  4.3.1.2  Example: filtering data
  
 Let us consider a bit more practical example : suppose we have a set of data and need to remove all the data 
 points with values smaller than a given cutoff < eps > "" 
  
 eps 0.3; 
  
 data TableRandom,10
  
 0.558611, 0.087393, 0.699237, 0.393591, 
 0.815213, 0.251073, 0.756381, 0.383772, 0.24806, 
 0.721713
  
 This is how one does this with Cases :",NA
4.4    Functions - starting examples and syntax,"4.4.1    A definition and a simple example
  
 By function we will mean a pair: any normal (non-atomic) 
 Mathematica
  expression which contains pat-terns, 
 and a rule in a global rule base, reflected by the DownValues command,  which tells what should replace the 
 first expression when it is encountered (we will ignore functions defined by SubValues, for the time being). 
  
 For example, this defines a function:
  
 Clearf, x;
  
  
 fx : x^3;
  
 Here f[x_] is a normal expression (we see a Head <f> and single square brackets - the characteristics of the 
 normal expression), the pattern is <x_> (we can see that it is a pattern by the presence of the under-score, 
 which is one of the symbols that distinguish patterns;   <x_>  stands for exactly one argument), and one can 
 check the presence of the global rule in a rule base by checking the DownValues command on a symbol 
 <f> (see Chapter 1, section 1.2.3):
  
 DownValuesf
  
 We can now make sure that the function works as intended :
  
 fa, fPi, fEinstein
  
 a3,
  Π
 3, Einstein3
  
 We see that the function as defined above works on any single expression.
  
 By a single expression I mean single argument  - for example <f> will not work in this situation:
  
 fa, b
  
 fa, b
  
 This is not an error, but 
 Mathematica
   simply does not know what to do with such an expression, and thus 
 returns it back, in accordance with its general evaluation strategy.
  
 Notice by the way, that all the ingredients needed to define a function we have already encountered before- 
 patterns, assignment operator,  etc. No new syntax is needed for function definitions - indeed because they 
 are just some type of global rules, similar to variables. The non - trivial part here is in the action of an 
 assignment operator (SetDelayed or sometimes Set): it decides whether or not the l.h.s. of the emerging 
 global rule is legitimate, and if so, what type of global rule the new rule will be. When the l.h.s. contains 
 patterns and the resulting global rule is stored in DownValues, we say that we have defined a function.
  
 Often one needs to perform type or more general argument checks. They  are very easy to implement in 
 Mathematica
   and we will discuss them in the section on conditional patterns.
  
 Clearf;",NA
4.5     Examples of functions of a single argument,"All built-in functions (or commands) in 
 Mathematica
  are functions in the sense described above: all of them 
 have a format fname[arg1,...,argn]  (caveat: sometimes,  the symbol <fname> here may be not a symbol, but  
 a normal expression itself, like for instance for an expression Derivative[1][f][x], which represents a first 
 derivative of the function <f> with respect to the variable <x>, the <fname> symbol will actually be   
 Derivative[1][f]. But such cases are not very frequent, and also represent no problems - they result in 
 definitions stored in SubValues rather than DownValues). 
  
 The rules associated with the built-in functions can not normally be read - they are ""wired in"" the kernel 
 (some of the externally-defined rules can be read, but they are also ""hidden"" by  default). However, the way 
 built-in functions work can be significantly altered by the user, since it is possible to redefine them and 
 associate new rules with them, which will take preced
 e
 nce over the system-defined rules. All these 
 techniques are not normally needed, fairly advanced and assume high level of competence with 
 Mathemat-
 ica
 . I mention these possibilities here just to illustrate the consistency of the whole approach.  In principle, 
 the built-in functions are not too different from the user-defined ones. They are just faster (being imple-
 mented in lower-level language like C), and already interconnected by a large base of global rules built into 
 the system.
  
 Let us now give some examples of functions of a single argument.",NA
4.6     Functions of several variables,"So far, we considered in detail only functions of single argument. We will now consider functions of 
 several variables.
  
  4.6.1     Starting examples and a definition
  
 Since we can define functions to work on lists, one way to define a function of several arguments is to 
 define a function on a list of arguments. For example, if we need a function which raises one number to the 
 power given by another number, we can do it as follows :
  
 Clearf, x, y;
  
  
 fxList : Powerx1, x2;
  
 f2, 3, f5, 2, f10, 3, f3, 4
  
 8, 25, 1000, f3, 4
  
 In the last case the function did not evaluate, since its argument was not a list. This definition is however 
 unsatisfactory for many reasons. First of all, the list of arguments in such a definition is non - uniform, since 
 the first element gives the base while the second gives the power. This is not a good programming style and  
 often leads to bugs in more com
 p
 licated cases (There is nothing 
 wrong
  in mixing  elements of different types 
 in a single list, but there should be more compelling reasons to do so).  The second prob-lem is that we have 
 to impose an additional constraint that the length of the list is exactly two, otherwise we will get either errors 
 or unexpected results:
  
 f1, f2, 3, 4
  
 Part::partw : Part 2 of1 does not exist.
  
 1, 8
  
 Let us redefine :
  
 Clearf;
  
  
 fxList; Lengthx 2 : Powerx1, x2;
  
 f1, f3, 4, f2, 3, 4
  
 f1, 81, f2, 3, 4
  
 As a somewhat better alternative, we may define a function as follows:
  
 Clearf;
  
  
 fbase, power : Powerbase, power;",NA
4.7     Functions with multiple definitions,"We have seen such functions many time in our examples already, but here we will treat them more system-
 atically. So, In 
 Mathematica
   a function can have more than one definition. More precisely, there can be 
 more than one rule associated with a function symbol, with different rules applying on different forms of 
 arguments. In particular, one and the same function can be defined differently on different number and types 
 of arguments. All this is possible because patterns are used for function definitions. To start with, consider an 
 example:
  
  4.7.1    Example: a discontinuous function
  
 Consider a function which is 1 on integer numbers and - 1 on those which are not integer (in the spirit of 
 the  Dirichlet function - the latter is very different of course, being defined differently on rational and 
 irrational numbers) :
  
 Clearf;
  
  
 fxInteger : 1;
  
  
 fx :1;
  
 We check :
  
 f1, f1.5, f2, f2.5, f4, fPi, fE
  
 1,1, 1,1, 1,1,1
  
 Notice that in the second part of our definition in this case  we don’ t necessarily need to use a pattern that 
 is  exact opposite of the first one, which would look like f[x_ /; Not[IntegerQ[x]]]. This is so beca
 u
 se when 
 the first pattern does not match, the second will match automatically, since it matches any single 
 expression. 
  
 It is interesting that if we plot this function, the values on the integers (1) are not visible. One may think 
 that this is  because the probability that the sample point in the Plot procedure becomes exactly  integer is 
 very small (integers represent a set of measure 0). However, the truth is simpler: the numerical values for 
 the sample points will never match the _Integer pattern just syntactically.
  
 Plotfx,x, 0, 10",NA
"4.8 Larger functions, local variables and the code modularization","In the majority of real situations, the code for a typical function is longer than one or two lines (in other 
 words, not every problem can be solved by one - liners). Also, it is often convenient to introduce intermedi-
 ate variables, both to avoid redundant computations and to improve the code readability.  Such vari
 a
 bles one 
 has to localize, in order to avoid name conflicts with the global variables already defined in the sys-tem, and 
 in general not to ""pollute"" the global name space. On the scale of a single function or program, there are 3 
 constructs in 
 Mathematica
  which provide this functionality: Module, Block and With. These constructs are 
 explai
 n
 ed in detail in 
 Mathematica
   Book and 
 Mathematica
   Help, so I will say just a few words about them 
 here. On the larger scale, this is supported through the system of packages - we will consider them in part II.
  
  4.8.1    Module
  
 The goal of Module is to localize names of the variables, and avoid the name conflicts between the global 
 names (and by global I mean everything exterior to the body of the Module), and the local names used in the 
 code inside Module. What is important is that if this code calls some function which contains one of the 
 global symbols with the name coinciding with the name of some of the local variables, the global value will 
 be used. Put in another way, the variables are localized in space - only in the code inside Module, but not in 
 functions which may be called from within this Module.  The way Module does it is to create tempo-rary 
 variables with names which can not possibly collide with any other name (but see 
 Mathematica
   Book for 
 some subtleties). In fact, the workings of Module correspond most directly to standard vari
 a
 ble scopes in 
 other languages such as C.
  
 The format of Module is 
 Module[{var1,  var2, ...}, body]
 , where var1, var2, ... are the variables we localize, 
 and < body > is the body of the function. The value returned by Module is the value returned by the last 
 operator in the <body> (unless an explicit Return[] statement is used within the body of Module. In this case, 
 the argument of Return[arg] is returned). In particular, if one places the semicolon after this last operator, 
 nothing (Null) is returned. As a variant, it is acceptable to initialize the local variables in the place of the 
 declaration, with some global values : 
 Module[{var1 = value1, var2, ...}, body]
 . However, one local 
 variable (say, the one ""just initialized"" can not be used in the initialization of another local vari-able inside 
 the declaration list. The following would be a mistake : 
 Module[{var1 = value1, var2 = var1, ...}, body]
 . 
 Moreover,  this will not result in an error, but just the global value for the symbol <var1> would be used in 
 this example for the <var2> initialization (this is even more dangerous since no error message is generated 
 and thus  we don’t  see the problem). In this case, it would be better to do initializa-tion in steps: 
 Module[{var1=value1,var2,...},  var2=var1;body]
  , that is, include the initialization of part of the variables in 
 the body of Module.
  
 One can use Return[value] statement to return a value from anywhere within the Module. In this case, the 
 rest of the code (if any) inside Module is slipped, and the result <value> is returned.
  
 One difference between Module and the localizing constructs in some other programming languages is that 
 Module allows to define not just local variables, but local functions (essentially, this is because in 
 Mathematica
  there is no strong distinction between the two).  This opens new interesting possibilities, in 
 particular this is useful for implementing recursive functions. The same comment holds also for the Block 
 construct.
  
 A simple example : here is a function which computes the sum of the first <n> natural numbers :",NA
4.9  Function attributes,"Apart from the  definitions, functions can be assigned certain properties which affect the way they are 
 executed. These properties are called Attributes. There are many possible attributes which a function may 
 have, and we will only briefly discuss very few of them here. It is important that all possible attributes are 
 only those built in 
 Mathematica
 , and one can not assign to a function a ""home-made"" attribute that 
 Mathe-
 matica
  does not know. 
  
  4.9.1   Listable attribute and SetAttributes command",NA
4.11   Pure functions,"The notion of a pure function comes from the 
 Λ
  - calculus, and is widely used in functional programming 
 la
 n
 guages, 
 Mathematica
   in particular. From the practical viewpoint, the idea is that often we need some 
 intermediate functions which we have to use just once, and we don’ t want to give them separate names. 
 Pure functions allow to use them without assigning them names, storing them in the global rule base etc. 
 Another application of them is that while they can be assigned to some symbols, they exist independently 
 of their arguments and can be called just by name with the arguments being supplied separately, so that the 
 ""assembly"" to the working function happens already at the place where  the function is used.  Finally, these 
 functions may be dynamically changed and modified during the program’ s execution. 
  
 In 
 Mathematica
 , the  pure function can be defined in two (in principle, equivalent modulo some subtleties 
 which we will discuss) ways: through the built-in function  <Function> and through the so-called #-& 
 notation (anon
 y
 mous pure functions).",NA
4.12      Functions with defaults and options ,"It is often needed that part of the arguments are optional in the sense that some of the ""argument slots"" may 
 be either used or not, and the function has to do meaningful things in both cases. In 
 Mathematica
 , like in 
 many other modern  languages (Python comes to mind), there are two mechanisms to provide this 
 functionality: default values (for positional arguments), and Options (this corresponds  to ""named argu-
 ments""). 
  
 What is perhaps unusual and specific to 
 Mathematica
  is that neither of these mechanisms require some new 
 special syntax in the sense that it has to be added externally into the system. Rather, both of them exploit 
 some features already present in the system, such as optional patterns  (see section 4.2.9) or non -
 commutativity of the rule substitutions (see section 4.2.2.).
  
  4.12.1  Functions with defaults
  
 Default arguments are those which we can leave out when calling a function, in which case there are some 
 default values that the function will use for these arguments. The matching between missed arguments and 
 values is based on the positions of the arguments in this case. In 
 Mathematica
 , this mechanism is realized 
 through optional patterns  (section 4.2.9). We will give just a few simple examples of such  functions
  
 Here we define a function which sums all its arguments, and has the last two arguments optional, with 
 default values being 1 and 2 :
  
 ClearAllf; 
  
 fx, y:1, z:2 : xyz
  
 Check :
  
 f1, f1, 3, f1, 3, 5
  
 4, 6, 9
  
 The dafault patterns may be interspersed with the patterns for fixed arguments. The rule how the argu-ments 
 are filled in is more complicated in this case: the pattern - matcher first determines how many optional 
 arguments can be filled (from left to right), and then fills all the arguments from left to right, fixed and 
 optional at the same time (not like fixed first, optional next). This is the consequence of the general way of 
 how the pattern - matcher works, but one conclusion is that it is best to move all optional (default)",NA
V. Functions on lists and functional programming,NA,NA
5.1   Introduction,"Functional programming is a programming paradigm in which the central role is played by application of 
 functions, to both data and other functions. Functions themselves are treated as data, and thus can be 
 arguments of other functions.  Since any data structure  can be represented  as a (possibly nested) list, 
 functional programming then is about application of functions to lists.
  
 There are important differences between functional programming in 
 Mathematica
   and other functional 
 languages (LISP). One difference is that recursion on lists is inefficient in 
 Mathematica
   since lists are 
 implemented here as arrays rather than linked lists. Another difference is induced by the rule - based nature 
 of 
 Mathematica
   in the way it reflects itself in function definitions (in the case of pattern - defined 
 functions) and evaluation procedure (global rule base, expression rewriting etc).
  
 Apart from being concise, the functional programming style is usually the most efficient in 
 Mathematica
 . 
 Also, although we do not consider it in this chapter, in 
 Mathematica
   it is possible to use functional pro-
 gramming techniques on expressions more general than lists  - basically, on general 
 Mathematica
   expres-
 sions. This is a very powerful capability.
  
 A few words about the role of this chapter. Perhaps, it will not be an overestimation to say that this is the 
 most important chapter of all. Mainly, this is because it introduces certain new programming style and a 
 number of programming idioms, which will be heavily used in all later chapters and which together form a 
 different level of programming in 
 Mathematica, 
 not just as technical tricks, but as a new way of thinking 
 about the problems. Those who are familiar with functional programming languages may find some of the 
 material familiar. However even for them, there will be a lot of new information specific to 
 Mathematica
 , 
 which must be used in order to program it most efficiently.
  
 Examples in this chapter play an important role in the overall exposition of the material. Many of them are 
 used to illustrate some important concepts or subtleties, since I believe that any new idea is best under-stood 
 when illustrated by a few examples. To get a complete grasp of this chapter, it is recommended to go through 
 all examples, and pay attention to the annotations attached to them. Some of the examples use admittedly 
 rather artificial settings. This is because their primary goal is to illustrate a given language idiom in a rather 
 simple situation.",NA
5.2  Core higher-order functions,"5.2.1   Introduction
  
 Roughly speaking, functional programming (FP) in 
 Mathematica
   consists of application of functions to 
 Mathematica
   normal expressions. A very important special case is when the normal expression is a list 
 (i.e, it’s Head is List), and we will be mostly concerned with this one in this chapter. However, most of 
 what can be done with lists within functional programming  paradigm,  can also be done with general 
 normal expressions.
  
 Two things make FP non-trivial:
  
  1. Functions can take other functions as their arguments (this has an analog of function pointers in C), 
 but also can create and/or return new functions at run-time, be that pure functions or pattern-based ones. 
 The latter capability has no direct analog in procedural  languages, where the functions definitions are 
 determined at compile time.
  
  2. Lists can be made of arbitrary 
 Mathematica
  expressions, be those atoms (numbers, strings or sym-
 bols),  or normal expressions.  In particular, one may consider nested lists which can be used to implement 
 various data structures (lists, trees etc). This also means that a single list may contain objects of different 
 types.
  
 There are a few characteristic features of the functional programming style which I would like to mention 
 here in order to give a flavor of it. One is that side effects (such as variable assignments) are (almost) 
 absent. Another is that loops are very rarely used if at all. In 
 Mathematica
 , this is not an absolute restric-
 tion however - it is just more natural to use other constructs, as we will see below. 
  
 Functions which take other functions as their arguments, are called higher order functions. On the concep-
 tual level, there are just two most important built-in higher order functions in 
 Mathematica 
 - Map and Apply. 
 On the practical level, these two are still most frequently used functions, but some ""less fundamen-tal"" 
 operations are still needed so often that special built-in functions exist for them, and are also quite handy. 
  
 We will now go through several most often used built-in higher order functions, illustrating their use with 
 examples. Since they serve as building blocks of most of functional programs, one can do quite a lot being 
 equipped with just these functions. 
  
  5.2.2   Map - simplest form
  
 This is one of the two most fundamental built-in higher order functions, and by far the most frequently 
 used one. Very roughly, one may say that it is used to replace loops within the FP paradigm.
  
 In it’s simplest form, Map takes two arguments: another function - let us call it <f> - of a single argument (I 
 hasten to comment that the function may have no name, if it is a 
 pure function 
 (see section 4.11)), and an 
 expression - let us call it <expr>, on which this function should by mapped. If <expr> is an atom, it is 
 returned back. If <expr> is a list (or other normal expression), then f is applied to every element of the list, 
 and the resulting list is returned.",NA
5.3      Generalizations,"5.3.1   Thread
  
 This function threads a function of several variables  over the list in which first sublist gives all first argu-
 ments, second gives second  arguments, etc. For example:
  
  5.3.1.1     Initial examples
  
 Clearf;
  
 ThreadfRange10, Range11, 20
  
 f1, 11, f2, 12, f3, 13, f4, 14, f5, 15, f6, 
 16, f7, 17, f8, 18, f9, 19, f10, 20
  
 ThreadfRange10, Range11, 20, Range21, 30
  
 f1, 11, 21, f2, 12, 22, f3, 13, 23, f4, 14, 24, f5, 15, 25, f6, 
 16, 26, f7, 17, 27, f8, 18, 28, f9, 19, 29, f10, 20, 30
  
 The lists of arguments need not be the same length, and this is in fact quite useful at times:
  
 ThreadfRange10, 1
  
 f1, 1, f2, 1, f3, 1, f4, 1, f5, 1, f6, 
 1, f7, 1, f8, 1, f9, 1, f10, 1
  
 When used in cases like above, Thread may be thought of as a generalization of Map. 
  
 However, the input like this is ambiguous, and the system complains:
  
 ThreadfRange10,1, 2
  
 Thread::tdlen : Objects of unequal length in 
  
  
 f1, 2, 3, 4, 5, 6, 7, 8, 9, 10,1, 2 cannot be combined. More
  
 f1, 2, 3, 4, 5, 6, 7, 8, 9, 10,1, 2
  
  5.3.1.2 Example: imitating Thread
  
 As an amusing exercise, we may imitate the workings of Thread in the first case  above. This will also 
 clarify how it works in  that case.
  
 This will imitate Thread for the inputs with equal number of all arguments
  
 ClearmyThread;
  
  
 myThreadfxList; Equal MapLength,x :
  
  
 f Transposex;
  
  
 myThreadxList : x;
  
 In the above, the pattern checks that all elements are lists, and the condition checks that all lengths of all 
 lists are the same (the second definition is needed  to reproduce  the behavior of the built-in Thread on 
 simple lists). We then Transpose the lists, for instance:",NA
5.4      Nest Family ,"5.4.1      Nest and NestList 
  
 This function is used to repeatedly apply the same function on an expression. The format is : 
  
   
 Nestfunction, expression, n, 
  
 where <n > should be an integer giving the number of times that the function has to be applied. For 
 example:
  
  5.4.1.1    Simple examples 
  
  
  
 ClearAllf, x; 
  
  
   
 Nestf, x, 5 
  
  
  
 fffffx 
  
 Co
 n
 sider, for instance, 
  
  
  
 fx : x^2; 
  
  
   
 Nestf, 2, 3 
  
  
  
 256
  
  5.4.1.2    NestList 
  
 The function NestList is really the same as Nest but it gives more information, since its output is a list of all 
 intermediate steps of the application of Nest. For the above example: 
  
  
  
 NestListf, 2, 3 
  
  
   
 2, 4, 16, 256 
  
  
  
 NestListf, x, 3 
  
  
   
 x, x2, x4, x8
  
 We also see that the first element in the NestList is always the original expression, which corresponds to 
 the function <f> applied zero times.
  
 It is important that NestList is as efficient as Nest - there is no penalty for getting all the intermediate results. 
 Indeed, the function still has to apply in stages - once, twice, etc - so the intermediate results are in principle 
 internally available to the system. Simple Nest just does not collect them.
  
  5.4.1.3     Pure functions 
  
 Both Nest and NestList work with pure functions as well: 
  
  
 NestList^2 &, 2, 3 
  
  
   
 2, 4, 16, 256",NA
5.5     Fold and FoldList,"5.5.1   Fold: syntax and starting examples
  
 Fold is a generalization of Nest, for the case when the nested function is a function of two variables, rather 
 than of a single variable. While the first supplied variable is again a result of the previous action of the 
 function itself, a second argument is supplied externally by Fold, from a list which is a parameter to Fold.
  
 So, the syntax: 
  
 Foldf, start, secarglist
  
 Simple example:
  
 Clearf; 
  
 Foldf, x,a, b, c
  
 fffx, a, b, c
  
 Fold is a remarkably useful function. One may think of it as follows: if <f> can be thought of as a function 
 which realizes a transition between the states of some finite state machine each application of Fold is like 
 ""rotating the crank"" of this finite state machine, and we will rotate it until there are elements left in the 
 second argument list (this analogy belongs to David Wagner). The number of times that the function will be 
 nested, is equal to the length of the second argument list. The function FoldList is related to Fold in the same 
 way as NestList to Nest - it gives all intermediate results of ""rotating the crank"". 
  
 One very frequent use of Fold is recursion removal. This we will cover later in part II, chapter in recursion 
 and iteration.
  
  5.5.2   More examples:
  
  5.5.2.1   Example:    partial sums
  
 FoldListPlus, 0,a, b, c, d, e, f
  
 0, a, ab, abc, abcd, abcde, abcdef
  
 Here, as compared to Fold, we get all the intermediate partial sums for free. At the same time, FoldList is 
 almost as efficient as Plus@@ for the final sum:",NA
5.6   FixedPoint and FixedPointList ,"5.6.1   The syntax and functionality
  
 These functions are very similar to Nest and NestList. Instead of asking, how many  times the function 
 should be nested, they nest the function until the result no longer changes. The format is 
  
 FixedPointf, expr
  
 In some cases, it is desirable to have a ""safety net"" - to stop nesting after certain maximal allowed number 
 of iterations regardless of whether or not the result has stabilized. To account for these cases, there is an 
 optional third argument <n> which gives a maximal number of iterations.
  
 Since these functions are very similar to Nest/NestList except their termination condition, we will illustrate 
 them by revisiting certain examples considered before. 
  
  5.6.2   Example:  the Collatz problem revisited
  
 Here is the already discussed (section 5.4.2.6) Collatz iteration definition:
  
 Clearc;
  
  
 cn? OddQ : 3 n1;
  
  
 cn? EvenQ : n 2;
  
 Previously we solved the problem of generation of the Collatz sequence by using NestWhileList. The 
 solution was:
  
 ClearcolSequence;
  
  
 colSequenceqInteger : NestWhileListc, q,1 1 &;
  
 Imagine for a moment that it is unavailable (like it was in earlier versions of 
 Mathematica
 ). Can we find a 
 substitute? Here is the solution that uses FixedPointList:
  
 ClearcolSequenceFP;
  
  
 colSequenceFPqInteger :
  
  
 DropFixedPointListIf 1, c, 1 &, q,1;
  
 (here, FP stands for ""FiexedPoint""). The idea is that after the result becomes one for the first time, it will 
 remain one due to the way the nested function is written. Then, after the next iteration, the last two results 
 will be both equal to 1  and to each other, and thus the process will stop. For instance",NA
5.7     Operators on functions,"5.7.1    Through
  
  5.7.1.1   Syntax and functionality 
  
 This function is quite useful at times, although generally used less than those we discussed already. Actu-
 ally, my feeling is that it is used less than it deserves to be.  The format is 
  
  
  
 Throughpf1, f2, ..., fnx 
  
 The result is 
  
  
  
 Clearp, f, g, h, x; 
  
  
  
 Throughpf, g, hx 
  
  
  
 pfx, gx, hx
  
  5.7.1.2    Initial examples 
  
 As I said, this can be quite useful. For instance: 
  
  
  
 ThroughSin Cosx 
  
  
  
 Cosx Sinx 
  
 Or, when we have a list of functions: 
  
  
  
 Throughf1, f2, f3x
  
 f1x, f2x, f3x
  
  5.7.1.3     When it goes wrong 
  
 But be careful - this for example may be a surprise: 
  
  
  
 ThroughSin Cosx 
  
  
    
 1 
  
  
   
 Cosx Sinx 
  
 The last output is such because division has been internally rewritten as a mu
 l
 tiplication by the inverse, as 
 can be seen from the FullForm: 
  
  
  
 FullFormSin Cos 
  
  
  
 TimesPowerCos,1, Sin
  
 There is an alternative (for this particular case) which will do what we failed to accomplish with Through: 
  
  
 MapIfHead Symbol,x, &, Sin Cos,1 
  
  
 Tanx 
  
 The result has been simplified to Tan[x] immediately.
  
 Let me now illustrate the use of Through in a less trivial setting, where it is really useful.",NA
5.8  Summary,"This chapter has been very important in many aspects. For one thing, we considered a large number of 
 examples which illustrated many subtle points of 
 Mathematica
   programming.
  
 Another good thing is that we covered in details most of important built-in higher-order functions, which 
 serve as building blocks of most 
 Mathematica
   programs. We have now a toolbox ready to be used for 
 larger or more complicated problems. 
  
 Yet another important thing is that starting with this chapter, we systematically emphasized efficiency. I 
 tried to convey the style of programing  where efficiency considerations are used from the very beginning 
 and all the way through solving the problem, but on the other hand not to hide the essence of the problem 
 by efficiency analysis. 
  
 Also, we went many times through typical stages of  development process for 
 Mathematica
  programs. It is 
 amazingly easy  to develop a program in 
 Mathematica
 : we start with a very simple test case, each step is 
 usually just one line, each step is easily tested, the final code is trivially combined from the steps of the 
 sample solution.
  
 But most importantly, all the considerations of this chapter taken together hopefully  illustrated the func-
 tional style of programming as not just a number of clever tricks but as an entirely different way to think 
 about programming. This is the style that will be used most frequently and heavily in the chapters that 
 follow, so it is very important that this material is well-understood.",NA
VI. Writing efficient programs: some techniques and applications ,NA,NA
6.1    Introduction,"This last  chapter of this part serves to illustrate the relative efficiency of different programming styles in 
 Mathematica
  on several non - trivial applications. This chapter is somewhat different from the previous ones 
 in style - it is somewhat less pedagogical  - I don’t explain every line of code in such detail as before (I 
 assume that the interested reader who made it that far will be able to understand the workings of the code 
 using my rather brief explanations as hints). But it shows real problems, wins and trade
 -
 offs that one deals 
 with in more serious 
 Mathematica
  programming. Also, some of the techniques discussed here are rather 
 general and may be used in many other situations. Finally,  the problems I discuss may be of interest by 
 themselves.
  
 However, there is a lot more to performance tuning in 
 Mathematica
  than what is discussed in this chapter. I 
 will have more to say about it in other parts of the tutorial. Excellent treatment of performance-tuning 
 techniques is given in the book of David Wagner.",NA
6.2   Case study I:  checking if a square matrix is diagonal,"6.2.1   The problem
  
 The formulation of the problem is extremely simple: given a square matrix of some size, return True if all the 
 off - diagonal elements are zero and False otherwise.
  
  6.2.2   The test matrices
  
 Here we will introduce relatively large test  matrices : a random matrix which is almost certainly not 
 diagonal, and an identity matrix of the same size, which is of course diagonal. All our implementations of 
 DiagonalQ will be tested on these matrices.
  
 testmatr ArrayRandom &,400, 400; 
 testiden IdentityMatrix400;
  
  6.2.3   Procedural implementation
  
 The procedural implementation is straightforward 
  
 CleardiagonalQProc;
  
  
 diagonalQProcm? MatrixQ; Equal Dimensionsm :
  
  
 Modulelen Lengthm, i, j,
  
  
 Fori 1, i len, i,
  
  
 Forj 1, j len, j,
  
  
 Ifi j, Continue, Ifmi, j 0, ReturnFalse;
  
  
 ReturnTrue;
  
 We can now test the performance of this implementation :",NA
6.3     Case study II:  extracting matrix diagonals,"6.3.1    The problem
  
 Consider the following problem: we need to extract from the matrix some or all of its diagonals, either right 
 diagonals (going from top left  to bottom right), or left diagonals (going from  bottom left  to top right). We 
 should provide a list of matrix element positions, and our function has to extract all right or left (or both) 
 diagonals which pass through these elements. And of course, we would like to do it as efficiently as possible.
  
  6.3.2    Test matrices
  
 testmatr ArrayRandomInteger,1, 15 &,4, 6 MatrixForm
  
  
 6
  
 7
  
 14
  
 1
  
 8
  
 6
  
  
 11 13 15
  
 6
  
 12 11
  
 12
  
 4
  
 5
  
 11
  
 7
  
 4
  
 10
  
 8
  
 10
  
 8
  
 14 11
  
 powertestmatr ArrayRandomInteger,1, 50 &,500, 500;
  
  6.3.3   Extract - based implementation
  
  6.3.3.1   The implementation 
  
 The idea of this implementation is to generate a list of positions for elements on each diagonal that we need 
 to extract. Then, we can use the built - in Extract, which may accept a list of positions of elements to be 
 extracted.
  
 Since we define a diagonal by any element through which it passes, we will need a number of auxiliary 
 functions.
  
  First, we will need a function which takes matrix dimensions and an address of a single element < elem > 
 in question, and determines the address of the ""starting"" element of (say, right) diagonal which passes 
 through < elem > . This is done by the following code : 
  
 CleardiagRightStart; 
  
 diagRightStartrInteger? Positive, cInteger? Positive, 
  
  
 rowsInteger? Positive, columnsInteger? Positive 
  
 r 
 rows && c columns :
  
 ;
  
  
 Switchrc,? Positive,1rc, 1,
  
  
 ? Negative,1, 1cr, 0,1, 1
  
  
 ;
  
  
 diagRightStartx :;
  
 Here, < r > and < c > represent a row and col
 u
 mn of the element in question, while < rows > and < 
 col
 u
 mns > represent matrix dimensions. For example :",NA
6.4    Case study  III: generating complex random  Wishart matrices,"6.4.1   The problem
  
 Here we will consider a problem of generation of complex random Wishart matrices with the normally 
 distributed complex entries. Wishart matrices are block matrices of the form
  
 0, W,WH, 0 MatrixForm
  
 0 
  
 W 
  
 WH 0
  
 where W is n x m complex matrix and WH is its hermitian conjugate. Thus, the total matrix is (m + n) x (m 
 + n).  Random complex Wishart matrices with uncorrelated (other than due to WH being hermitian 
 conjugate of W) normally distributed entries of W, form the so-called chiral ensembles and are used, in 
 particular, for the low-energy description of Quantum ChromoDynamics. Of main interest usually are the 
 eigenvalue correlations, but here we will just consider a way to generate these matrices.
  
  6.4.2    Preliminaries
  
 We will need to load  a package Statistics‘ContinuousDistributions :
  
 <<Statistics‘ContinuousDistributions‘
  
 The way to generate the gaussian numbers is as follows :
  
 RandomArrayNormalDistribution0, 1,10
  
 0.284087,0.364616,0.0643195,2.03162, 
  
 1.03452, 1.74043,0.13117, 2.22543,3.16775, 1.32895
  
 Here we have generated 10 random numbers with zero mean and unit variance.
  
  6.4.3    Procedural implementation
  
 Here is the straightforward procedural implementation. This function generates a single Wishart matrix of 
 specified dimensions, mean and variance of the elements distribution.",NA
"6.5   Case study  IV: sorting, mapping and membership tests","6.5.1   The problem
  
 It is often needed in practice to do something to those elements of one list (set) which are also the mem-bers 
 of  another list (set). Some examples of this kind we have considered before - the unsorted Intersec-tion 
 function (section 4.3.3.4), and unsorted Union function (section 5.2.6.2.5), but this is a rather general 
 formulation. Here we will consider a following problem:  we need to Map some function <f> on these 
 elements. As usual, we will move from the easiest procedural solution to more efficient ones, and develop 
 some  generally useful functionality along the way. 
  
  6.5.2   Test sets
  
 These will be our simple test sets that we will use to develop our functions: a first list on which elements 
 we should Map f, and the second list membership in which we will test for the elements of the first one.
  
 Clearf;
  
 testlst TableRandomInteger,1, 15,20
  
 1, 5, 3, 6, 7, 2, 4, 2, 8, 14, 12, 13, 4, 14, 2, 4, 4, 13, 9, 10
  
 memblist TableRandomInteger,1, 15,5
  
 3, 13, 4, 9, 3
  
 These 2 lists will be our ""power"" test lists, which we will use to test the efficiency of our implementations:
  
 powertestlst Range4000; 
  
 powermemblist Range1000, 3000;
  
  6.5.3   Procedural solutions
  
 We will start with a couple of straightforward procedural attempts to solve our problem.
  
  6.5.3.1   The absolutely worst way to do it
  
 Below is the absolutely worst possible solution  for this problem.",NA
6.6   Summary ,"In this chapter we went through a lot of code of type common to see in real 
 Mathematica
   programs. My goal 
 was to illustrate several things, such as the typically large number of ways to solve a given problem in 
 Mathematica
 , and the relative efficiency of these solutions. The rule of thumb is that the procedural 
 programming style is more likely to produce  inefficient solutions, the functional programming  style is 
 usually more efficient (when applied with some thought), and the programming based on the structural 
 operations is typically the most efficient style, which sometimes can improve performance by an order of 
 magnitude or lead to a solution of different computations complexity altogether.
  
 Also, one could naively expect that the code size of the best solution should be larger than that of the worst 
 one (because the former has to be more sophisticated than the latter). This is generally not so. The best 
 solution is the one which achieves the closest correspondence between the structure of the problem and the 
 efficient structures and operations built in 
 Mathematica
 .  But due to a very high level of the lan-guage,  this 
 does not necessarily imply longer code, and often in fact implies just the opposite.
  
 We have also seen that many of our best solutions resulted from the complementary use of several differ-ent 
 programming styles, such as structural operations, functional programming, rule-based programming 
 (especially in combination with  hashing through Dispatch). This is perhaps where the most interesting and 
 efficient solutions in 
 Mathematica
  should be, since this possibility to mix  different programming styles is 
 one of the unique features of 
 Mathematica
  system.",NA
Appendices,"Appendix A: what is so special about 
 Mathematica 
 (a personal evaluation) 
  
 Mathematica
  is distant from many other programming languages in many ways. One that seems most 
 important to me is that it is not a minimal language, in the sense I will explain. This leads to lots of ways of 
 how any given problem can be solved.  
 Mathematica
  language supports all major programming styles -
 procedural,  rule-based,  functional and object-oriented (OO is not directly supported  but can be imple-
 mented within 
 Mathematica
  [3,4,1]) . This richness of the langu
 a
 ge is a great strength since it allows to 
 choose the programming style which is best suited for a particular problem - some people say that 
 Mathe-
 matica
  language is ""problem-oriented"". 
  
 It allows one to program and research at the same time, using in the research, in principle, all the power of 
 modern mathematics. The great advantage here is that it is very easy to switch the thinking mode from 
 programming to research and back, or do necessary (non-trivial) mathematical (or statistical, etc) checks 
 quickly without resorting to special libraries and interrupting the main programming workflow. 
  
 The problem (pun unintended) is however that all the different solutions possible for a given problem, are 
 inequivalent, primarily in terms of efficiency, but also in terms of the code readability, ease of maint
 e
 n-ance 
 and debugging. These issues will probably be of no concern for a pure scientist who just needs to plot a 
 graph or two, simplify some formula etc. But this will certainly be a concern for people from the software 
 development community who may consider to use 
 Mathematica
  as a tool for rapid prototyping, for which, in 
 my opinion, it has major advantages for complex software. 
  
 When I program in C, and say solve some problem in two different ways, it is not very likely that the 
 performance of the two implementations will be different more than a factor of 2 (unless I do something 
 stupid, or when the difference in solutions will be actually in algorithms of different complexity).  In 
 Mathematica
  however, it is quite easy to get say 5 or 10 different solutions where the performance of the 
 most and least efficient may differ in several orders of magnitude or have different computational complex-
 ity altogether. Of course, the reason is that, programming in 
 Mathematica
 , we ""sit"" on top of a lot of internal 
 algorithms used to implement given built-in functions that we are using.  But from the user view-point, these 
 performance differences are often completely unobvious, until one gets a better understanding of how the 
 system works.
  
 Imagine now that we are building a system which has 4 stages of information processing, each one taking as 
 an input a result from the previous one. And then, on each stage we produce 2 different solutions which 
 differ in performance 10 times. At the end, we get one system working 10000 faster than the other. In 
 practice, this means that the ""slow"" system in most cases will be completely useless, given that there anyway 
 exists an overhead due to the symbolic nature of 
 Mathematica
  and a very high level of its lan-guage. If one 
 wants to build something serious and interesting  in 
 Mathematica,
  one has to learn tech-niques to program in 
 it efficiently, or at the very least, be aware of certain performance pitfalls associated with each programming 
 style.
  
 At the same time, the great advantages that 
 Mathematica
  brings are the ease and speed of writing and 
 debugging the code, the extremely small code size, and the ability to stay on quite a high level of abstrac-
 tion throughout the process of solving the problem, without going into unnecessary low-level details which 
 hide the essence of the problem. This allows a single person to manage substantial projects. 
 Mathematica 
 is 
 a great ""thinking laboratory"". Due to its highly interactive nature, it is also a great tool to design and analyze 
 algorithms. For me personally, this overweights the eventual complications arising from the above 
 performance  issues, especailly because  once you understand the system, you rarely get an unexpected 
 behavior or nasty performance surprises.",NA
The bibliography,"Books devoted mostly or entirely  to 
 Mathematica
  programming
  
 1
 . John W.Gray, 
 Mastering  Mathematica,  Second  Edition:  Programming  Methods  and  Applications
 , 
 Academic Press, 2 edition (1997) 
  
 2
 . Roman E.Maeder, 
 Programming in Mathematica, 
 Addison-Wesley Professional;3 rd Edition. (1997) 
 3
 . 
 Roman E.Maeder, 
 Computer Science with Mathematica
 , Cambridge University Press (2000) 
 4
 . Roman 
 E.Maeder,  
 The Mathematica Programmer,
  Academic Press (1994) 
  
 5
 . Roman E.Maeder,  
 The Mathematica Programmer II
 , Academic Press (1996) 
  
 6
 . Michael Trott,  
 The Mathematica Guidebook for Programming
 , 
 The Mathematica Guidebook for Graphics
 , 
 The 
 Mathematica Guidebook for Symbolics
 , 
 The 
 Mathematica Guidebook for Numerics
 , 
  
 Springer  (2004) 
  
 Springer  (2004) 
  
 Springer  (2005) 
  
 Springer  (2005)
  
 7
 . David B.Wagner, 
 Power Programming With Mathematica: The Kernel
 , Mcgraw-Hill  (1996)
  
 8
 . Paul R.Wellin, Richard J.Gaylord, and Samuel N.Kamin, 
 An Introduction to Programming with Mathe-
 matica
 , Third Edition, Cambridge University Press (2005)
  
 9
 . Stephen Wolfram, 
 The Mathematica Book
 , Wolfram Media, Fifth Edition (2003)
  
  Some general and introductory  
 Mathematica
  books 
  
 10
 . Nancy Blachman and Colin Williams, 
 Mathematica : A Practical Approach
 , Prentice Hall PTR; 2nd 
 Edition (1999)
  
 11
 . Heikki Ruskeepaa,  
 Mathematica Navigator: Mathematics, Statistics, and Graphics
 , Academic Press, 
 Second Edition  (2004)
  
 12
 . William T.Shaw and Jason Tigg, 
 Applied Mathematica : Getting Started, Getting it Done
 , Addison -
 Wesley Professional (1993)
  
  Mathematica
   - unrelated references
  
 13
 . Paul Graham, ANSI Common Lisp, Prentice Hall (1995)
  
 14
 . http : // paulgraham.com/power.html",NA
