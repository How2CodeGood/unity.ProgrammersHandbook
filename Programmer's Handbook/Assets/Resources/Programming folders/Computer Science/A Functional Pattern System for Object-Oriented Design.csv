Larger Text,Smaller Text,Symbol
A Functional Pattern System for Object-Oriented Design ,"Article
  · January 
 1999
  
 CITATIONS 
  
 27
  
 READS 
  
 1,304
  
 1 author:
  
  
 Thomas Kühne 
  
 Victoria University of Wellington
  
 99
 PUBLICATIONS
 3,230
 CITATIONS
  
 SEE PROFILE
  
 All content following this page was uploaded by 
 Thomas Kühne
  on 03 March 2015.
  
 The user has requested enhancement of the downloaded file.",NA
A Functional Pattern System for,NA,NA
Object-Oriented Design,NA,NA
Thomas K¨uhne,NA,NA
 Pattern,"that is used to remember 
 facts and to construct new solutions. When grown-ups 
   
  
 are about to learn something or have to apply 
  
   
   
 unknown tools, they are put into a child’s 
  
   
     
 position again. They will favor concrete 
  
   
     
   
  
 examples over abstract rules. The 
  
   
     
   
   
 rules will happily be gen-
  
   
     
   
   
  
  
  
    
 automatically, erated 
  
   
     
   
   
  
  
 for 
  
 this 
  
   
 is how 
    
  
  
  
     
   
  
 the 
  
  
 brain 
  
   
     
   
   
  
  
  
   
 works.
  
 ♦",NA
Thesis,"Design patterns inspired by functional programming concepts can advance object-
 oriented design.",NA
Problem,"The object-oriented paradigm has undoubtfully raised our ability to design and 
 maintain large complex software systems. However, it does not seem to have 
 meet the high expectations concerning reuse and ease of evolution which have 
 been pro-moted ever since its commercial success.
  
 There are many potential reasons for the above observation such as unquali-
 fied staff, immature languages, inadequate methodologies, inappropriate business 
 processes, etc.
  
 The view presented here is that although the object-oriented paradigm is a 
 pow-erful basis, it is incomplete in its inherent concepts and therefore restricts the 
 design space to inappropriate solutions. It is assumed that both software 
 development and language design are restrained from achieving their full 
 potential when restricted to a purely object-oriented world view.",NA
Solution,"Since the complementary paradigm to object-orientation is represented by func-
 tional programming, I investigate high-level, well-known to work functional con-
 cepts and examine their suitability to enhance object-oriented design. I explore the 
 software engineering relevance of each concept and present its intent, 
 applicability, implementation, and consequences in the literate form of a design 
 pattern.
  
 My approach clearly motivates functional techniques for object-oriented 
 design from a software engineering point of view. This is different to the usual 
 procedure of designing a new language with an “ad-hoc” conglomeration of 
 functional and object-oriented features. The latter case requires excellence in 
 language design and makes it hard to find out and evaluate uses of the new 
 language.
  
 In contrast, design patterns are already widely used to improve design. As 
 func-tional concepts constitute a powerful paradigm by themselves, it is more 
 than sug-gestive to assume that design patterns expressing successful functional 
 concepts will enhance the object-oriented paradigm with new capabilities.",NA
Contribution,NA,NA
Feasibility,"I demonstrate the feasibility of using functional techniques in object-oriented de-
 signs which are to be implemented by ordinary object-oriented programming lan-
 guages. This is done at the level of a calculus comparison and in concrete design 
 pattern implementation descriptions. I demonstrate synergetic effects caused by 
 concept integration, which together with the advantages of functional patterns, 
 thus, show the utility of the approach.",NA
Software production,"Object-oriented practitioners hopefully will use the names of functional design 
 pat-terns as a vocabulary to discuss solutions in a new design space. I present a 
 system of patterns which are connected by relations that describe how individual 
 patterns may interact and collaborate with each other. This system, consisting of 
 state-of-the-art mini-architectures, may allow thinking and designing beyond 
 restrictions imposed by a dogmatic object-oriented approach. As a result, the 
 quality of soft-ware is hoped to improve.",NA
Language Design,"Using functional patterns for object-oriented design can be regarded as dual-
 paradigm design. In this light, functional design patterns appear as language id-
 ioms that lift an object-oriented language to a dual paradigm implementation lan-
 guage.
  
 It is very instructive to verify how well an object-oriented language supports 
 the implementation of these idioms, since limiting properties are expected to 
 interfere in other attempts to produce flexible and maintainable software as well.
  
 Unless one is restricted to use a certain existing language, it is, however, only 
 natural to consider direct language support in order to avoid the repetitive im-
 plementation of these idioms. A holistic language that encompasses both object-
 oriented and functional paradigms should provide more ease of use, increased 
 safety, better initial execution efficiency, and higher optimization potential.
  
 I consider each presented design pattern for its contribution to language con-
 structs that support a dual paradigm language. The software engineering consid-
 erations, contained in each design pattern description, help to avoid “featurism” 
 in favor of conceptually founded language principles.
  
 Ultimately, impulses initiated by the functional pattern system lead to a 
 reeval-uation of the role distribution between a programming language and its 
 associated environment. The result allows transcending the limitations of each 
 paradigm by providing the optimal paradigm view on demand.",NA
Preface,"Example is the school of mankind, and they will learn at no other.
  
 – Edmund Burke
  
  
 A number of people directly or indirectly influenced my work and I am grateful 
 for their contributions.
  
  
 Norbert Ihrig made my early years in school a worthwhile experience and with-
 out him my way would have been much harder.
  
 Gregor Snelting proposed an interesting master thesis to me and, thus, opened 
 up the subsequent opportunity for a research position at the institute for “Praktis-
 che Informatik” at the Darmstadt University of Technology. I enjoyed his lectures 
 and am thankful for his continued support.
  
  
 Thilo Kielman introduced me to the world of being a scientist. I owe him many 
 hints, paper reviews, and enjoyable hours.
  
 Alberto Pardo was my roommate over a long period and shared many 
 stimulat-ing discussions with me. I would like to express my gratitude for his ever 
 present willingness to help and for a lot of advice in the areas of calculi and 
 algebras. He and Nick Dyson helped to improve the chapter on functional 
 programming.
  
  
 John Sargeant invested considerable effort to discuss the Void Value pattern 
 with me and provided useful information on U
 FO
 .
  
 Dirk Koschorek provided invaluable last minute advice on S
 MALLTALK
 .
  
  
 Many scientists, who I had the honor to meet at workshops or conferences, dis-
 cussed aspects of my work with me and made me reflect about it.
  
 Gillian L. Lovegrove and J¨urgen Ebert accepted to be external examiners and I 
 am indebted to their timely efforts. I would like to thank J¨urgen Ebert for his 
 invitation to the “Bad Honnef” workshop series and for his personal interest in 
 my work.
  
 Finally, I would like to express my gratitude to my thesis supervisor Wolfgang 
 Henhapl. He gave me all the freedom I could wish for and stimulated my work on 
 several occasions. He asked the question to which function objects present an an-
 swer and challenged me to conceive the Translator design. Numerous discussions 
 with him created an abundance of insights for me.
  
 I am honestly grateful to the nameless cosmic particles that hit me when I had 
 the idea of function objects, to replace Nil with a type specific value, to solve the 
 forces of internal and external iteration with multiple consumable intermediate 
 streams, to express functional ideas by devising a pattern system, and to rethink 
 the roles of languages and their environments based on the notion of tiles.",NA
Contents,NA,NA
I,"Thesis
  
 iii
  
 Preface
  
 v
  
 Prologue
  
 1",NA
Foundation,NA,NA
7,"1
  
 Functional programming
  
 1.1 Worldview 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9 
  
 9
  
 2
  
 1.2
  
 Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 1.2.1
  
 Functional decomposition . . . . . . . . . . . . . . . . . . . .
  
 10
  
 1.2.2
  
 Reduction Semantics . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 1.2.3
  
 Higher-Order Functions . . . . . . . . . . . . . . . . . . . . .
  
 12
  
 1.2.4
  
 Lazy evaluation . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 1.2.5
  
 Pattern Matching . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 1.2.6
  
 Type inference . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 1.3
  
 Review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 1.3.1
  
 Pro
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 1.3.1.1
  
 Programming Discipline
  
 . . . . . . . . . . . . . . .
  
 18
  
 1.3.1.2
  
 Concise programs
  
 . . . . . . . . . . . . . . . . . . .
  
 18
  
 1.3.2
  
 Contra
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
  
 1.3.2.1
  
 Functional decomposition . . . . . . . . . . . . . . .
  
 21
  
 1.3.2.2
  
 Reduction semantics . . . . . . . . . . . . . . . . . .
  
 21
  
 1.3.2.3
  
 Deceptive Clearness . . . . . . . . . . . . . . . . . .
  
 26
  
 Object-
 orientation 
 2.1 
 Worldview
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 29 
 29
  
 2.2
  
 Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 31
  
 2.2.1
  
 Object-oriented decomposition . . . . . . . . . . . . . . . . .
  
 32
  
 2.2.2
  
 Encapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 32
  
 2.2.3
  
 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 33
  
 2.2.4
  
 Subtyping
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 34
  
 2.2.5
  
 Dynamic Binding . . . . . . . . . . . . . . . . . . . . . . . . .
  
 35",NA
II Pattern System ,NA,NA
83,"6 
  
 Catalog 
  
 85
  
 6.1 Proto-Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 85
  
 6.2 Pattern System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 86
  
 6.2.1 
  
 Function Object . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 86
  
 6.2.2 
  
 Lazy Object 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 87
  
 6.2.3 
  
 Value Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 87
  
 6.2.4 
  
 Transfold . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 88
  
 6.2.5 
  
 Void Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 88
  
 6.2.6 
  
 Translator 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 89
  
 6.3 Why Eiffel? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 91
  
 7 
  
 Function Object 
  
 93
  
 7.1 Intent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 93
  
 7.2 Also Known As . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 93
  
 7.3 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 93
  
 7.3.1 
  
 Problem 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 93
  
 7.3.2 
  
 Solution 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 96
  
 7.4 Applicability 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 98
  
 7.5 Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
  
 7.6 Participants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
  
 7.7 Collaborations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
  
 7.8 Consequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
  
 7.9 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
  
 7.10 Function Object variants . . . . . . . . . . . . . . . . . . . . . . . . . . 107
  
 7.11 Known Uses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
  
 7.12 Related Patterns 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
  
 7.12.1 
  
 Categorization . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
  
 7.12.2 
  
 Collaboration 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
  
 7.12.3 
  
 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . 113
  
 8 
  
 Lazy Object 
  
 115
  
 8.1 Intent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
  
 8.2 Also Known As . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
  
 8.3 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115",NA
III Language design ,NA,NA
231,"14 Pattern Driven Language Design 
  
 233
  
 14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
  
 14.2 Function Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
  
 14.3 Translator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
  
 14.4 Transfold . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
  
 14.5 Value Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
  
 14.6 Lazy Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
  
 14.7 Void Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
  
 14.8 Conclusion 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
  
 Epilogue 
  
 261
  
 Bibliography 
  
 275
  
 Index 
  
 305",NA
List of Figures,"1.1 
  
 1.2 
  
 1.3 
  
 1.4
  
 2.1 
  
 2.2 
  
 2.3 
  
 2.4 
  
 2.5
  
 3.1 
  
 3.2 
  
 3.3 
  
 3.4
  
 4.1 
  
 4.2 
  
 4.3 
  
 4.4 
  
 4.5 
  
 4.6 
  
 4.7 
  
 4.8
  
 5.1 
  
 5.2 
  
 5.3 
  
 5.4 
  
 5.5 
  
 5.6
  
 7.1 
  
 7.2
  
 8.1 
  
 8.2
  
 Functional decomposition . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 Comparison between imperative and functional style . . . . . . . . .
  
 19
  
 Functional and imperative LIFE
  
 . . . . . . . . . . . . . . . . . . . . .
  
 25
  
 I/O feedback model . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 Object-oriented taxonomy . . . . . . . . . . . . . . . . . . . . . . . . .
  
 30
  
 Ideal inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 31
  
 Classes as versions and variants . . . . . . . . . . . . . . . . . . . . .
  
 33
  
 Subtyping inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 34
  
 Dynamic method lookup
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 36
  
 Screenshot: O
 PULUS
  expression
  
 . . . . . . . . . . . . . . . . . . . . .
  
 49
  
 Screenshot: O
 PULUS
  expression represented in the
  
 -calculus . . . .
  
 49
  
 Screenshot:
  
 -calculus expression
  
 . . . . . . . . . . . . . . . . . . . .
  
 51
  
 Screenshot:
  
 -calculus expression represented in O
 PULUS
  
 . . . . . .
  
 51
  
 Classification of programming paradigms
  
 . . . . . . . . . . . . . . .
  
 56
  
 Cooking with object responsibility . . . . . . . . . . . . . . . . . . . .
  
 60
  
 Cooking with single inheritance . . . . . . . . . . . . . . . . . . . . .
  
 61
  
 Cooking with multiple inheritance . . . . . . . . . . . . . . . . . . . .
  
 61
  
 Cooking with repeated inheritance . . . . . . . . . . . . . . . . . . . .
  
 62
  
 Cooking with parameterization
  
 . . . . . . . . . . . . . . . . . . . . .
  
 63
  
 Cooking with synergy . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 63
  
 Restructured dependencies . . . . . . . . . . . . . . . . . . . . . . . .
  
 67
  
 A composer’s pattern
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 70
  
 Space filling pattern . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 73
  
 Software system of interwoven patterns.
  
 . . . . . . . . . . . . . . . .
  
 77
  
 OMT Notation: Class diagram . . . . . . . . . . . . . . . . . . . . . .
  
 80
  
 OMT Notation: Object diagram
  
 . . . . . . . . . . . . . . . . . . . . .
  
 80
  
 OMT Notation: Interaction diagram . . . . . . . . . . . . . . . . . . .
  
 81
  
 Function Object structure diagram . . . . . . . . . . . . . . . . . . . . 101 Function 
 Object interaction diagram . . . . . . . . . . . . . . . . . . . 102
  
 Schematic CD-player . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 Plug-in 
 modules in a bitstream architecture . . . . . . . . . . . . . . . 116",NA
List of Tables,"3.1 
  
 3.2 
  
 3.3 
  
 3.4 
  
 3.5 
  
 3.6
  
 4.1 
  
 4.2 
  
 4.3
  
 5.1 
  
 5.2
  
 6.1 
  
 6.2 
  
 6.3
  
 10.1 
 10.2
  
 12.1
  
 13.1
  
 14.1 
 14.2 
 14.3
  
 Opulus syntax 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Opulus BNF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 46 
  
 47
  
 Translation of Opulus to
  
 -calculus 
  
 . . . . . . . . . . . . . . . . . . .
  
 Translation of
  
 -calculus to Opulus 
  
 . . . . . . . . . . . . . . . . . . .
  
 Complexity of Opulus in the
  
 -calculus . . . . . . . . . . . . . . . . .
  
 Complexity of
  
 -calculus in Opulus . . . . . . . . . . . . . . . . . . .
  
 48 
  
 50 
  
 52 
  
 52
  
 Criteria to evaluate cook and recipe combination
  
 . . . . . . . . . . .
  
 60
  
 Decomposition matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . Sensitivity of 
 decomposition types . . . . . . . . . . . . . . . . . . . .
  
 65 
  
 65
  
 Facets of “pattern” . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 71
  
 Promise of design patterns
  
 . . . . . . . . . . . . . . . . . . . . . . . .
  
 76
  
 Functional pattern spectrum 
  
 . . . . . . . . . . . . . . . . . . . . . . .
  
 Language levels 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 90 
  
 91
  
 Functional pattern system . . . . . . . . . . . . . . . . . . . . . . . . .
  
 92
  
 External versus internal iteration . . . . . . . . . . . . . . . . . . . . . 167 Transfold’s 
 arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
  
 Simplifications possible while translating . . . . . . . . . . . . . . . . 211
  
 Benefits of the functional pattern design example . . . . . . . . . . . 228
  
 Pattern implications on language design 
  
 . . . . . . . . . . . . . . . . 252 Tiles 
 with object-oriented and functional dimensions . . . . . . . . . 256 Concrete 
 types with implementation and interface views . . . . . . . 257",NA
Prologue,"A paradigm is not a dogma.
  
 – me
  
 P 
  
 cal structure of functions defined on passive data, or a set of interacting 
  
 active objects, or a web of concurrent processes? In analogy to theories, 
  
 aradigms define ways to perceive the world. Is a cannery a hierarchi-
  
 the value of a paradigm is determined by the usefulness of creating models 
 accord-ing to it. A paradigm, therefore, is a means to an end. In software 
 development the goal is to avoid semantic gaps inbetween analysis, design, and 
 implementation while achieving reusable components, extendable applications, 
 and maintainable software.",NA
Motivation,"During its now three decades spanning history, the object-oriented paradigm has 
 proved to be tremendously useful as a basis for development methodologies and 
 as an implementation strategy. Object-oriented languages are truly general 
 purpose languages since they may conquer any domain by defining the 
 appropriate abstrac-tions. Domain specific libraries or frameworks enable 
 designers to define and use 
 application languages
 , specifically tailored to model 
 particular domains [Hudak96]. Application languages avoid an impedance 
 mismatch between analysis and imple-mentation. Object-oriented languages to a 
 large extent allow a natural definition of application languages with the help of 
 class abstractions. They, hence, enable a so-called
  middle-out
  development 
 [Ward94], where one team implements the appli-cation language while another 
 builds the application on top of it. It appears to be almost certain that object-
 orientation will not cease as a dead end in the evolution of programming and 
 design paradigms.
  
  
 However, there are signs of a disintegrating kingdom. 
  
 The fact that the next 
 Kuhnian paradigm shift [Kuhn70] is overdue [Quibeldey-Cirkel94] is not a strong 
 indication, but in 1994 an issue of B
 YTE
  magazine devoted to compo-nent software 
 shook the object-oriented community by stating that object-oriented technology 
 failed to keep its promises and that V
 ISUAL
  B
 ASIC
 -like, component oriented 
 languages offer higher productivity [Byte94]. 
  
 Subsequently, the func-
 tional paradigm scored higher in analysis suitability [Harrison et al.94] and the 
 supremacy of the object-oriented paradigm was found to be “an open research",NA
Paradigm integration,"While object-orientation and design patterns — the buzzwords of the eighties and 
 nineties respectively — receive a great deal of attention, it got rather quiet around 
 a field which has mostly been of academic interest only: Functional programming 
 is known for its elegance but also has the reputation of being an academic toy 
 only. Quite often the desirable features of functional programming are believed to 
 be inaccessible from other programming language types.",NA
Hints on reading,"The “Newsreader” approach to this thesis is to read chapter “Thesis” on page iii 
 only. A more comprehensive quicktour is obtained by adding the prologue on 
 page 1 and epilogue on page 261. Anybody interested in a glance at the patterns 
 may take a pattern quicktour by reading chapters catalog on page 85 and collab-
 oration on page 221. Design practitioners, however, will savor the whole pattern 
 system part starting on page 85.
  
 Chapters of interest to language designers are the calculus comparison on 
 page 45, the analysis of paradigm integration on page 55, and the whole language 
 design part beginning on page 233.
  
 Chapters functional programming on page 9, object-orientation on page 29, 
 and design patterns on page 69 are meant as an introduction to the uninitiated but 
 also serve to establish and clarify terminology.",NA
Newsreader,NA,NA
Thesis,5,NA
Prologue ,NA,NA
FOUNDATION ,NA,NA
Functional Programming ,NA,NA
Object-Orientation ,NA,NA
Calculus Comparison ,NA,NA
Conflict & Cohabitance ,NA,NA
Design Patterns,NA,NA
Design Practitioner,NA,NA
PATTERN SYSTEM,NA,NA
Language Designer,NA,NA
Quicktour,NA,NA
Pattern Quicktour,NA,NA
Catalog,NA,NA
Function Object,NA,NA
Lazy Object,NA,NA
Value Object,NA,NA
Transfold ,NA,NA
Void Value ,NA,NA
Translator ,NA,NA
Collaboration ,NA,NA
LANGUAGE DESIGN ,NA,NA
Epilogue,NA,NA
Part I,NA,NA
Foundation,NA,NA
1 ,NA,NA
Functional programming,"T 
  
 that are used in later discussions. I explain the underlying worldview 
  
 (section 1.1) and the most important concepts (section 1.2 on the next 
  
 his 
 chapter introduces functional programming and defines some terms
  
 page). Finally, section 1.3 on page 17 enumerates pros and cons of functional pro-
 gramming.",NA
1.1 ,NA,NA
Worldview,"The functional paradigm suggests to regard everything as an expression. 
  
 This 
 can be seen as the logical conclusion from F
 ORTRAN
  (mathematical flavor through 
 expressions), to functions in P
 ASCAL
 , to expression oriented style in S
 CHEME
  
 [Hudak89]. Since the value of mathematical expressions does not change over time, 
 there is no need for any notion of state. Also, there is no need for control flow, 
 because the order of expression evaluation has no impact on the final result (as 
 long as partiality is excluded).
  
 The most important type of expression is called function application, i.e., some 
 data is fed into a function and the function produces a result. We might say “The 
 functional paradigm suggests to regard everything as a function” and loose only a 
 little bit of truth. In fact, it is possible to model everything with functions only 
 (e.g., with the pure
  
 -calculus [Barendregt84, Hankin94]), but functional 
 programming languages typically provide built-in primitive data structures and 
 operations.
  
 Apparently, functional programming corresponds to two outdated software 
 paradigms: On a small scale the transformation of data with functions 
 corresponds to the Input/Processing/Output model [Pepper92], which has been 
 replaced by more modern views such as distributed computation and event-
 triggered behav-ior. On a large scale the structuring of a program into a hierarchy 
 of functions corresponds to structured analysis and design, which has been 
 replaced by entity-relationship or object-oriented decomposition techniques.
  
 The above should not create the impression that functional programming is of 
 no use anymore. On the contrary, we will see that data transformation and 
 functional decomposition are still very useful concepts. Also, apart from the on-
 going academic interest in functional programming languages (e.g., [Hudak96, 
 Gostanza et al.96, L¨aufer96]) the rise of new parallel computer architectures adds 
 importance to languages with a strong potential for parallel execution models.",NA
Concepts,"1
  
 Functional programming",NA
1.2,"The following sections are meant to briefly introduce concepts in functional pro-
 gramming. For a more thorough discussion and also for a history of functional 
 programming languages the reader is referred to [Ebert87] and [Hudak89]. Some 
 readers may miss the concepts of polymorphism, strong static typing, data 
 abstrac-tion, and garbage collection. These are not discussed since they can be 
 regarded as orthogonal to language paradigms. Equally, all these concepts have 
 been adopted by both functional and object-oriented languages. Type inference is 
 not paradigm specific either but has not been successfully applied to object-
 oriented languages yet and therefore will be a stimulus for the extension of object-
 oriented languages (see part III starting at page 233).
  
 Subsequently, I will use the syntax of the functional language H
 ASKELL
  to de-
 pict functional concepts. The notation is very intuitive, but you may want to refer 
 to an introduction like [Hudak & Fasel92].",NA
1.2.1 ,NA,NA
Functional decomposition,"I already mentioned the correspondence between functional decomposition and 
 structured analysis and design. A program is viewed as a main function, that is 
 decomposed into more functions with less work to accomplish (see figure 1.1).
  
 Main Function
  
  
 Decomposition Function 
  
 Decomposition Function
  
  
 Library Function
  
 Decomposition Function
  
  
  
  
 Operations
  
 Operations
  
 Figure 1.1: Functional decomposition
  
 By functional decomposition I also include the separation between functions 
 and data, i.e., the
  tools and materials
  metaphor. New functionality typically does 
 not require to change existing data structures. It is simply added with external 
 functions operating on top of existing data structures. However, changes to data 
 structures often require to change existing functions. As functions depend on 
 data, they must be adapted to properly react to, e.g., new constructors. See 
 [Cook90] for a technical and Chapter 12 of [Meyer88] for a software engineering 
 discussion of functional versus object-oriented decomposition.",NA
1.2.2 ,NA,NA
Reduction Semantics,"Computations within a functional programming language are performed just like 
 reductions in a calculus. Instead of altering an implicit state with instructions, 
 com-putation is defined as the reduction of expressions. Intuitively, we can think 
 of a reduction step as a replacement of a term with a simpler term
 1
 . For instance:
  
 1
 +
 2
 +
 4
  =
 ♦
  3
 +
 4
  =
 ♦
  7
  
 Reduction does not always mean simplification in a na¨ıve sense, i.e., expressions 
 may as well grow in size in intermediate steps:
  
 (
 1
 +
 2
 )
 2
 =
 ♦
  (
 1
 +
 2
 )
 ♦
 (
 1
 +
 2
 ) =
 ♦
  3
 ♦
 3
  =
 ♦
  9 
  
 (1.1)
  
 Yet, reduction is guaranteed to produce a unique so-called normal form, if it ter-
 minates at all
 2
 . An expression in normal form cannot be reduced any further and 
 is what we intuitively think of as the value of an expression. Uniqueness of nor-
 mal forms for the untyped
  
 -calculus is guaranteed by the Church-Rosser 
 Theorem I [Hudak89].
  
  
 In addition, the normal form may be reached through every possible reduction 
 order, e.g., 
  
  
  
  
 (1.2) 
 (
 1
 +
 2
 )
 2
 =
 ♦
  (
 3
 )
 2
 =
 ♦
  (
 3
 )
 ♦
 (
 3
 ) =
 ♦
  9
  
 yields the same result as the above calculation. We have to be more precise if errors 
 (e.g., division by zero) or non-termination may also occur. For instance,
  
 False
 ♦
 (
 1
 /
 0
  =
  1
 ) =
 ♦
  False
  
 but only if logical conjunction (
 ♦
 ) is non-strict, that is, does not evaluate its second 
 argument unless necessary. Here, the reduction order used in reduction 1.2 called 
 applicative-order reduction
 3
 would not produce the normal form “False”, but pro-
 duce a division by zero error.
  
 Fortunately, normal-order reduction
 4
 , the strategy used in reduction 1.1, always 
 yields the normal form, if it exists. This is stated by the Church-Rosser Theorem II 
 for the untyped
  
 -calculus [Hudak89].
  
 Reduction results, as well as any other expression, are immutable values. 
 Adding an element to a list produces a new list copy with that element appended. 
 Furthermore, the result is not distinguishable from a second list with identical el-
 ement order that was obtained in a different way (e.g., by removing an element), 
 that is, values have no identity. This is a remarkable property. To see why, 
 consider the following (non-H
 ASKELL
 ) code:
  
 1
 Though this view is a crude oversimplification it suffices for our purposes here.
  
 2
 Termination is not guaranteed in general. However, there are special systems like the simply 
 typed
  
 -calculus, the polymorphic typed
  
 -calculus, system F, and languages like F
 P
  that even 
 guarantee termination.",NA
1.2.3 ,NA,NA
Higher-Order Functions,"Functions are first-class values often called first-class citizens. A function can be 
 an argument to another function (downward-funarg) as well as be the result of 
 another function (upward-funarg). An example for passing a function as an 
 argument is the 
 map
  function:
  
 map f
  [ ]
  
 =
  
 [ ]
  
 (1.3)
  
 map f
  (
 x
  :
  xs
 )
  
 =
  
 (
  f x
 )
  :
  map f xs
  
 (1.4)
  
 It applies a function to all elements of a list. Hence,
  
 map
  (+
  1
 ) [
 1
 ,
 2
 ,
 3
 ]
  
 =
 ♦
  
 [
 2
 ,
 3
 ,
 4
 ]
  
 and
  
 [
 ”
 House
 ”
 ,
  ”
 Boat
 ”
 ]
  
 map
  (
 ”
 my
 ”
  ++)
 6 
 =
 ♦
  
 [
 ”
 myHouse
 ”
 ,
  ”
 myBoat
 ”
 ]
 .
  
 5
 Even in imperative languages!",NA
1.2.4 ,NA,NA
Lazy evaluation,"Most programming languages have strict semantics. We already got to know this 
 type of evaluation strategy in section 1.2.2 on page 11 as applicative-order 
 reduction and it is also known as call-by-value parameter passing. Yet another 
 name for it is eager evaluation. Here is why: Given
  
 select x y
  
 =
  
 x
  
 we may obtain a reduction sequence like
  
 select
  1
  (
 2
 +
 3
 ) =
 ♦
  select
  1 5
  =
 ♦
  1
 .
  
 The intermediate result 5 was computed although it was subject to be thrown 
 away immediately. Even worse, eagerness may not only cause unnecessary work 
 to be done it can also prevent the computation of meaningful results. Just imagine 
 a non-terminating expression or
  (
 1
 /
 0
 )
  in place of
  (
 2
 +
 3
 )
 . The result would be non-
 termination or a division-by-zero error, though the result 1 would be perfectly 
 rea-sonable.
  
  
 The solution is to use normal-order reduction, akin to call-by-name. With a non-
 strict
  select
  function the reduction sequence becomes
  
 select
  1
  (
 2
 +
 3
 ) =
 ♦
  1
 ,
  
 which is both faster and safer. Indeed, almost any programming language 
 contains at least one non-strict operator/statement in order to allow recursion or 
 choice of side-effects. Typically, it is an
  if
 -statement that does not evaluate its 
 branching ar-guments until one can be chosen.
  
  
 Nevertheless, we already have seen an example when lazy evaluation causes 
 more work than eager-evaluation. 
  
 If you compare reduction sequence 1.2 on 
 page 11 using eager evaluation to reduction sequence 1.1 you will note that it 
 needs one addition operation less. The problem was created by duplicating an 
 expression (by unfolding exponentiation to multiplication) which also duplicated 
 the compu-tation amount. Alas, all we need to do is to record the duplication and 
 to share com-putation results. Speaking in calculi terms we replace string reduction 
 by graph reduction. Then, reduction sequence 1.1, becomes",NA
1.2.5 ,NA,NA
Pattern Matching,"Pattern matching is a typical example for syntactic sugar. Instead of testing for 
 argument values within the function body, e.g.,
  
 fac n
  
 =
  
 if n
  ==
  0
  then
  1
  
 or
  
 fac n
  
 =
  
 case n of
  
 else n
 ♦
 fac
  (
 n
 −
 1
 )
  
 1
  
 n
  ==
  0
  →
  1 
  
 n
  >
  0
  →
  n
 ♦
 fac
  (
 n
 −
 1
 )
  
 we may write:
  
 =
  
 fac
  0
  
 fac
  (
 n
 +
 1
 )
  
 =
  
 (
 n
 +
 1
 )
 ♦
 fac n
 .
  
 Along with the idea of using equations as part of the syntax, pattern matching 
 adds much to the declarative nature of functional programs. All case 
 discriminations are clearly separated from each other and the implicit assembly of 
 partial function def-initions is very appealing. Note, however, besides a possibly 
 psychological factor there is no real software engineering significance associated 
 with pattern matching. The expressive power of a language [Felleisen91] is not 
 augmented with pattern matching in any way.
  
 11
 Eratosthenes was a Alexandrian Greek philosopher in the third century B.C.",NA
1.2.6 ,NA,NA
Type inference,"Among the many innovations of M
 L
  [Milner et al.90, Wikstr¨om87] was a type 
 sys-tem that liberated a programmer from explicitly declaring the types of 
 expressions. For instance, the type system would automatically infer the type of 
 function
  map 
 (see definition 1.3 on page 12) to be
  
 map
  ::
  (
 a
  →
  b
 )
  →
  [
 a
 ]
  →
  [
 b
 ]
 , 
  
 (1.7)
  
 that is, a function from type
  a
  to
  b
  and a list of elements of type
  a
  is used to 
 produce a list with elements of type
  b
 . This is an example of parametric 
 polymorphism, that is, a single function definition works in the same way for 
 many types.
  
 A strongly and statically typed language with type inference ensures the ab-
 sence of any runtime type errors without putting any declaration burden on the 
 programmer. For each expression the most general (so-called principle) type is 
 computed. With explicit type declarations a programmer might over-specify types 
 and thereby unintentionally narrow the use of a function. For instance, someone 
 programming functions on integer lists may type
  map
  as
  
 map
  ::
  (
 Int
  →
  Int
 )
  →
  [
 Int
 ]
  →
  [
 Int
 ]
 ,
  
 thus, excluding many other possible applications of map.
  
 There is a different view on this matter that argues that type declarations are 
 not just a service to compilers but constitute a part of the programs documenta-
 tion and even constitutes an albeit weak specification contribution. The nice thing 
 about type inference is that it allows a mixed style, i.e., explicit type declarations 
 overrule computed types and affect the type inference of associated expressions. 
 In effect, in the presence of type declarations the type system performs type 
 checking, comparing the inferred with the declared type.
  
 Like pattern matching there is no real impact of type inference in comparison 
 with type checking on software designs. Notwithstanding, the impact of the read-
 ability of programs should not be underestimated. An example how type declara-
 tions can get in the way of an otherwise clean syntax is L
 EDA
  [Budd95].",NA
1.3 ,NA,NA
Review,"The following two sections give a subjective assessment of functional 
 programming from a software engineering point of view.",NA
1.3.1 ,NA,NA
Pro,"Pointers are like jumps, leading wildly from one part of the data structure to another.
  
 Their introduction into high-level languages has been a step backwards
  
 from which we may never recover.
  
 – C.A.R. Hoare",NA
1.3.2 ,NA,NA
Contra,"Purely applicative languages are poorly applicable.
  
 – Alan J. Perlis
  
 The more light there is, the more shadow one might expect. Indeed, a part of 
 the same aspects that we mentioned in favor of functional programming can be 
 turned into counterarguments from a different perspective.
  
 1.3.2.1 
  
 Functional decomposition
  
 Functional decomposition works fine for the tools and materials metaphor when 
 programming in the small. Also, a decomposition based on actions and trans-
 formations can often be more intuitive than some entity-relationship organiza-tion 
 [Moynihan94]. On the other hand, it is difficult to assign a “main function”to any 
 large system and any choice is likely to be invalidated some time. A func-tional 
 decomposition is inherently instable, since the topmost functions are not 
 grounded in the problem domain and are subject to change whenever new re-
 quirements occur. Additionally, often systems are expected to cope with new data 
 which demands to accommodate all affected functions. Precisely these reasons led 
 to the redemption of structured analysis and design by object-oriented 
 methodolo-gies [Meyer88].
  
 1.3.2.2 
  
 Reduction semantics
  
 The very same feature — renunciation of state — that gives functional program-
 ming its strength (absence of side effects) is responsible for its main weakness 
 (lack of updates).
  
 “How can someone program in a language that does not have a notion of 
 state? The answer, of course, is that we cannot... [Hudak89].” –
  Paul Hudak
  
 Of course, Hudak goes on explaining that functional languages treat state
  
 explicitly 
 rather than
  implicitly
 . Passing around state for clarity and modeling 
 references by indirection is fine but some serious problems remain.
  
 Essential State
  
 Felder sind physikalische Zust¨ande des Raumes.
  
 – Albert Einstein",NA
2 ,NA,NA
Object-orientation,"Computing is viewed as an intrinsic capability of objects
  
 that can be uniformly invoked by sending messages.
  
 – Adele Goldberg
  
 T 
  
 are used in later discussions. I explain the underlying worldview (sec-
  
 tion 2.1) and the most important concepts (section 2.2 on page 31). Fi-
  
 his 
 chapter introduces object-orientation and defines some terms that
  
 nally, section 2.3 on page 38 enumerates pros and cons of object-orientation.
  
 In this dissertation I restrict myself to class based languages like C
 ++
 , E
 IFFEL
 , 
 and S
 MALLTALK
 . There is another interesting class of so-called delegation based or 
 prototyping languages like S
 ELF
  which use a dynamic type of inheritance and 
 renounce classes. However, classless languages are not in widespread use and one 
 of my aims is to improve the practice in object-oriented design.",NA
2.1 ,NA,NA
Worldview,"The object-oriented paradigm suggests to decompose systems in autonomous ob-
 jects. Autonomous means an object
  
 1. represents a complete entity. It is not just material or tools but both at once.
  
 2. has a self-supporting state. It manages and keeps its state without needing 
  
 support.
  
 3. provides self-sustained operations. In case it refers to other objects it does not 
  
 matter to clients.
  
 In terms of real world modeling objects represent real world objects and capture 
 their identity, state, and behavior. In terms of software decomposition each object 
 can be regarded as a little computer inside the computer.
  
 “For the first time I thought of the whole as the entire computer and
  
 wondered why anyone would want to divide it up into weaker things called
  
 data structures and procedures. 
  
 Why not divide it up into little comput-
  
 ers. . . ? [Kay96]”
  
  
 –
  Alan Kay",NA
2.2,NA,NA
Concepts,"The following sections are meant to briefly introduce concepts of object-oriented 
 languages. For a more thorough discussion the reader is referred to [Wegner87, 
 Wegner90, Beaudouin-Lafon94] for technical matters, to [Nelson91] for a clarifica-
 tion of terms, and to [Meyer88, Nierstrasz89, Jacobson et al.94, Booch94] for soft-
 ware engineering and system development relevance.
  
 Subsequently, I will use the syntax of the object-oriented language E
 IFFEL
  in 
 order to depict object-oriented concepts. The syntax is very clean and intuitive, 
 but you may want to refer to a definition [Meyer92], introduction [Racko94], 
 textbook [Rist & Terwilliger95, Thomas & Weedon95], or application development 
 books [Walden & Nerson95, J´ez´equel96]. E
 IFFEL
 ’s garbage collection avoids dis-
 tractions from memory management and its static type system allows typing 
 issues to be discussed. E
 IFFEL
 ’s clear syntax, simple semantics, and support of 
 correctness through the use of assertions made it the premier choice for an 
 education language for many universities throughout the world [Meyer93].
  
 1
 With multiple inheritance one may even let whales inherit from mammals and fishes, thus, 
 avoiding duplications caused by single inheritance.",NA
Object-oriented decomposition,"2
  
 Object-orientation",NA
2.2.1,"The idea to draw subsystem boundaries around data and associated functions is 
 one of the most important aspect of object-orientation. Actually, it is a simple ap-
 plication of information hiding [Parnas72]. That way, the representation of data 
 and the implementation of functions is hidden from other subsystems. Object-
 orientation supports this modularity by encapsulation (see section 2.2.2) and 
 boosts it by allowing multiple instances of modules. The latter lifts a tool to 
 control soft-ware complexity to a paradigm for real world modeling.
  
 Right in the spirit of S
 IMULA
  object-oriented systems simulate real world pro-
 cesses. Each participant in the real world can be represented by a software artifact 
 called object. In an object-oriented bureau we would not see functions like “
 file 
 content of incoming letter into drawer
 ”, but objects like
  Letter
  (supporting retrieval of 
 content) and
  Drawer
  (supporting addition of information). Clearly, objects offer 
 services and do not prescribe the order of actions. The object-oriented secretary 
 be-comes a conductor of object capabilities as opposed to a hierarchical 
 manipulator of materials. As a result, the design is much more stable, because 
 even if processes in the bureau are drastically changed the basic participants 
 (objects) are likely to stay. This promises less software maintenance in case of 
 change but also greater potential for reuse of objects in other domains (e.g.,
  Letter
  
 will be useful in other domains as well). Again, the reason for this reuse potential 
 is the absence of a rigid top-down conceived function call structure. The bottom-
 up provision of general services is more suited to be reused in altered conditions.
  
 The recursive decomposition of data works especially fine due to the concept 
 of procedural abstraction (see section 2.2.5 on page 35). In the object-oriented bu-
 reau objects issue goals to each other. The secretary may ask a drawer to file an 
 information. The drawer in turn forwards the goal to one of its sub-compartments 
 and so on until the goal is achieved. The secretary does not need to know about 
 the internal organization of drawers which also do not care what types of sub-
 compartments exist. Clients never care about the types of their servers. Conse-
 quently, servers may be exchanged without need to alter clients. This would not 
 be the case if, e.g., a secretary took different actions depending on drawer types.",NA
2.2.2 ,NA,NA
Encapsulation,"We already noted above that encapsulation supports the mutual protection of in-
 dependent software entities. This observation is important for programming in 
 the large. For programming in the small it is important to recognize the support of 
 encapsulation for data integrity. An object is responsible for its own initialization 
 after creation. It is ought to establish a consistent state at this point. Later ma-
 nipulations to the object’s state may only occur through the associated 
 procedures. These, however, are designed to keep the object’s state consistent as 
 well. It is not possible to accidentally add an element to the bottom of a
  Stack
  
 because one has access to the stack’s
  List
  representation and choose an invalid 
 operation. A client of the chessboard data structure from section 1.3.2 on page 21 
 may insert an integer",NA
2.2.,NA,NA
3,NA,NA
Inheritance,"In comparison to languages like P
 ASCAL
  or C, object-oriented languages empower 
 the programmer much more, since it is not only possible to define new types 
  
  
 but these can be made to appear just 
  
  
 like 
 built-in types
 3
 . 
  
 Even beyond, 
 COMMON_BASE 
  
 types can be incrementally derived 
  
  
 from other types by inheritance. An
  
  
 Different refinements yield variants
  
  
  
 VERSION 
  
  
   
 cialize a type, e.g., derive a 
 sports-
    
  
 car from a car. Other uses of inher-
  
  
   
 itance are discussed in section 2.3.2 
  
  
  
  
 on page 41. Inheritance can be use 
   
  
  
 to classify both 
 data (see figure 2.1 on 
  
  
   
 page 30) and algorithms 
 [Schmitz92]. 
  
  
   
 heir inherits both interface 
 (method 
 Changes in time yield versions 
  
  
   
  
 signatures) and code (attributes and 
  
   
  
 method bodies) from its ancestor. A 
  
   
  
 typical use of inheritance is to spe-
  
 VARIANT1 
  
 VARIANT2
  
 Therefore, it can be used as an orga-
  
 Figure 2.3: Classes as versions and variants
  
 nization principle for libraries.
  
 There is also an interesting corre-
 spondence between Inheritance and
  
 2
 C
 LOS
  methods may break the encapsulation of more than one object. 
 3
 C
 ++
  and E
 IFFEL
  even allow user defined infix operators.",NA
2.2.4,NA,NA
Subtyping,"We already got subtyping to know as a
  
 special kind of inheritance in section 
 2.1 on page 29. 
  
 Yet, Subtyping has 
 less to do with incremental class 
 definitions but rather denotes a 
 particular form of polymorphism called 
 inclusion poly-
  
 FIGURE
  
 scale
  
 morphism [Cardelli & Wegner85]. Fig-
 uratively, one can assume the type
  Fig-
 ure
  (see figure 2.4) to
  include
  the type
  
 CIRCLE
  
 ELLIPSE
  
 scale
  
 scale
  
 Circle
 , since a
  Circle
  will behave ex-
 actly as a
  Figure
  when viewed and
  
 radius
  
 radius1
  
 radius2
  
 manipulated through a
  Figure
  inter-
 face. For subtyping, or the
  Liskov Sub-
 stitution principle
  [Liskov & Wing93], to
  
 Figure 2.4: Subtyping inheritance
  
 hold true it is important that not only argument types vary contravariantly and 
 result types vary covariantly, but also the pre- and post-conditions must obey the 
 same principle. That is, pre-conditions may be weakened and post-conditions can 
 be be strengthened. Subtyping, hence, works especially well with a programming-
 by-contract model, which is supported by E
 IFFEL
 . Its language support for pre-and 
 post-conditions promotes the verification of behavioral subtyping as well.
  
 Inclusion polymorphism is one of the distinguished features of object-oriented 
 languages in comparison to functional languages. Functional languages, typically 
 offer so-called parametric polymorphism only
 5
 . For instance, in the type of
  map
  
 4
 Consult [Schroeder95] for terminology, history, and classification of version controlling. 
 5
 Of 
 course, subtyping is desirable for functional languages too and its integration into functional",NA
2.2.5 ,NA,NA
Dynamic Binding,"Just as structure programming hid the functionality of goto behind if/else, while and do;
  
 OOP has hidden the functionality of indirect goto behind polymorphism.
  
 – Robert C. Martin
  
 Subtyping without existential qualification of type variables would be akin to 
 H
 ASKELL
 ’s type classes. This is a fine mechanism to make ad-hoc polymorphism 
 less ad-hoc [Wadler & Blott89]. Contrary to an occasional misconception 
 [Berger91] type classes do not allow for true object-oriented programming.
  
 Most important for true object-oriented programming is the concept of 
 dynamic binding. Subtyping just restricts dynamic binding “vertically” to the 
 inheritance hierarchy. Now, a routine call to an object variable is not compiled as 
 a standard subroutine call. The code to be executed is not determined before 
 runtime. That is why, dynamic binding is often also called late binding. The code 
 selection depends on the actual object contained in the variable at runtime. 
 Consider the code
  
 figure : FIGURE;
  
 !CIRCLE!figure;
  
 figure.display;
  
 figure.typeMessage;
  
 Although
  figure
  is of type
  Figure
  it refers to an object of type
  Circle
 . In figure 2.5 
 on the next page the lookup of methods is depicted.
  
 All method searches start at
  Circle
 . As method
  display
  is defined by
  Circle
  it is 
 used in spite the presence of a general
  display
  method in
  Figure
 . As innocent as this
  
 languages is a important research topic [L¨aufer96].",NA
2.2.6 ,NA,NA
Identity,"All objects are created unequal.
  
 – me
  
 The concept of object identity [Khoshafian & Copeland86] is easily overlooked 
 due to the presence of more prominent concepts like inheritance, encapsulation, 
 and polymorphism. Nevertheless it also significantly contributes to the 
 expressive-ness of the object-oriented paradigm. What does object identity mean? 
 One way to look at it is to observe that objects are mutable. When an object 
 changes, e.g., an element is inserted into a list, there is no new list being created. 
 The list remains the",NA
2.3 ,NA,NA
Review,"The following two sections give a subjective assessment of object-oriented pro-
 gramming from a software engineering point of view.",NA
2.3.1 ,NA,NA
Pro,"Why does the combination of the above presented concepts work well? This 
 section examines the positive implications of the object-oriented paradigm.
  
 2.3.1.1 
  
 Real world modeling
  
 Whereas Turing machine behavior can be expressed by mathematical models,
  
 the observable behavior of interaction machines corresponds to that
  
 of empirical systems in the natural sciences.
  
 – Peter Wegner
  
 Two properties allow for real world modeling without
  impedance mismatch
 8
 :
  
 8
 When a modulated current flows through a conductor which is not properly terminated some 
 energy will be lost due to reflections. Similarly, “energy” will be lost if the modeling domain 
 cannot adequately express the things to be modeled.",NA
2.3.2 ,NA,NA
Contra,"Programming today is a race between software engineers
  
 striving to build bigger and better idiot-proof programs,
  
 and the Universe trying to produce bigger and better idiots.
  
 So far, the Universe is winning.
  
 – Rich Cook
  
 2.3.2.1 
  
 Imperative heritage
  
 Most object-oriented languages are based on A
 LGOL
 -like languages (C
 ++
 , S
 IMULA
 , 
 E
 IFFEL
 ) and some on L
 ISP
  (S
 MALLTALK
 , C
 LOS
 , D
 YLAN
 ). All share an imperative base 
 trough their ancestors. While we argued in section 2.3.1.2 on page 39 that object-
 oriented languages reach beyond their imperative roots, they still suffer from their 
 imperative heritage. One example are system shut-downs due to method calls on 
 void references. This is clearly an initialization problem which in general has 
 already been criticized by John Backus [Backus78] and which we will tackle in 
 chapter 11 on page 191.
  
 Aliasing 
  
 Consider a program fragment using a complex number library:
  
 !!a.make(2,0);
  
 b:=a;
  
 c:=a+b;
  
 !!a.make(0,2);
  
 d:=a+b;
  
 We would expect
  d
  to have the value
  2
 +
 2
 i
  but if complex numbers are 
 implemented with reference semantics — which is quite likely to be the case due 
 to efficiency considerations — the result will be
  4
 i
 . The reason for this is the 
 unexpected aliasing of
  b
  with
  a
 . Though object-oriented languages typically 
 provide support for value semantics (e.g., expanded classes in E
 IFFEL
 , part-objects 
 in B
 ETA
 , non-reference variables in C
 ++
 ) there is no agreed system how to choose 
 between reference and value semantics.
  
  
 Another source of aliasing are interferences between parameters and results. A 
 method does not represent a good abstraction if the effects of
  
 o.m(x, y)
  
 differ to
  
 o.m(x, x).
  
 Also,
  
 aMatrix.multiply(aMatrix2)
  
 possibly yields the wrong result when
  aMatrix2
  happens to reference
  aMatrix
 , 
 since then result elements will override still to be used argument elements.",NA
3 ,NA,NA
Calculus comparison,"A 
  
 paradigm in chapter 4 on page 55 and aim at capturing functional tech-
  
 niques with object-oriented design patterns in part II starting at page 85 
  
 s we are going to subsume functional concepts with the object-oriented
  
 this chapter shall assure us about the validity of this approach.
  
 Of course, all functional and object-oriented languages are Turing complete 
 with regard to their computation power. There is no doubt that any of these lan-
 guages can emulate one of the other. In spite of that it is quite interesting to ask 
 whether one emulation is easier to accomplish than the other. If it is easier to cap-
 ture object-oriented programming with a functional language we should write 
 pat-terns facilitating object-oriented programming in a functional language. The 
 goal of this chapter is to prove the opposite.",NA
3.1 ,NA,NA
Language comparisons,"Looking for the computational difference between two languages is like
  
 comparing apples to oranges only to find out that both are fruit.
  
 – me
  
 What is left if we beware of falling into to the Turing tarpit, i.e., try to find a 
 difference in computational power that is simply not there? What other indica-
 tors for expressiveness are available? One interesting approach is to evaluate the 
 amount of restructuring a program necessary to emulate the addition of new con-
 struct [Felleisen91]. If local changes are necessary only then the new construct can 
 be judged to add no further expressiveness. Unfortunately, the theoretical frame-
 work used for this approach does work for conservative extensions to languages 
 only, i.e., cannot be used to compare two fundamentally different languages.
  
 For the purpose of this chapter my idea was to define a translation of one lan-
 guage into the other and vice versa and then compare the translation 
 complexities. The rational is that a language should emulate a less expressive 
 language with ease while a considerable amount of machinery would be 
 necessary the other way round.
  
 In order to compare the fundamental mechanisms instead of technicalities of 
 specific languages it appeared most reasonable to compare calculi expressing the 
 nature of the two paradigms respectively. The calculus representing functional 
 pro-gramming is easily found and is referred to as the
  
 -calculus. You might want 
 to",NA
3.2 ,NA,NA
Opulus,"O
 PULUS
  is a simple calculus that denotes
  
 •
  encapsulation of multiple methods to an object by
 . . . . . . . . . . . . . . .
 [
 E
 ]
 ,
  
 •
  referencing “Self” as
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  $
 ,
  
 •
  sending a message
  N
  with Argument
  F
  to object
  E
  with
  . . . . .
  E N
  :
  F
 ,
  
 •
  referencing the parameter of a message send as
  . . . . . . . . . . . . . . . . . . .
 #
 ,
  
 •
  incremental modification (
 E
  is subclassed by
  F
 ) by
  . . . . . . . . . . .
  E
  +
 F
 ,
  
 •
  declaration of attributes as
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  N
  =
  E
 ,
  
 •
  declaration of methods (with Name
  N
  and body
  E
 ) as
  . . . . . .
  
 N
  =
  E
 ,
  
 •
  the empty object by
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ,
  
 •
  and finally, hiding of methods (
 N
 1
 –
 N
 k
 ) with
  . . . . . . . . . . .
 E
 {
 N
 1
 ,...,
 N
 k
 }
 . 
  
 Table 3.1: Opulus syntax
  
  
 Its grammar (with start-symbol “Expression”), therefore, is as given in table 3.2 
 on the facing page.
  
 For a more thorough definition please consult [Thierbach96]. For our purposes 
 we will be satisfied with just one example showing how the calculus works. Con-",NA
3.3 ,NA,NA
Opulus within,NA,NA
 ,NA,NA
-calculus,"A standard translation of O
 PULUS
  into the
  
 -calculus represents O
 PULUS
  terms in a 
 tree structure and uses programmed reduction rules to manipulate the tree 
 [Thierbach96]. The fixpoint combinator
  Y
  can then be employed to, e.g., re-
 peatedly apply
  
 -reduction.
  
 A more efficient translation is achievable
  
 •
  by recognizing that substitution in O
 PULUS
  (e.g., replacing # with the argu-
 ment value) can be captured with
  
 -abstraction variable bindings,",NA
3.4,NA,NA
,NA,NA
-calculus within Opulus,"Again a standard translation is easily obtained by encoding
  
 -terms into objects 
 which understand application and substitution messages [Thierbach96]. The diffi-
 culties with
  
 -conversions necessary for
  
 -reductions are easily avoided by calcu-
 lating weak-head-normal-forms only [Field & Harrison88].
  
  
 A cleverer translation is obtained by exploiting the closure like nature of 
 objects. 
  
 Closures are functions that carry their variable environment with them 
 [Field & Harrison88]. How can we make use of closures then? It is easy to",NA
3.5 ,NA,NA
Conclusion,"It did not come as a surprise that either translation was possible at all but how 
 about the results of comparing the complexity of performing one calculus in the 
 other? Table 3.5 on the next page summarizes the results for emulating O
 PULUS
  in 
 the
  
 -calculus and table 3.6 on the following page shows the results for 
 emulating
  
 -calculus in O
 PULUS
 . Ranges of complexity denote the best and worst 
 case, whereas the average case is always closer to the lower bound.
  
 Let us first regard the standard translation which we did not explicate in the 
 preceding sections but that we remember as using a straightforward term repre-
 sentation with associated reduction functions. We note that the derivation of emu-
 lating the
  
 -calculus in O
 PULUS
  was done within two pages [Thierbach96] 
 resulting in three conceptually easy object definitions all implementing two 
 messages each (substitution and
  
 -reduction). Deriving the opposite standard 
 translation took more than three pages and resulted in nine translation rules 
 needing nine construc-tors with nine associated selection functions. In addition, 
 this does not include the emulation of O
 PULUS
  names in the
  
 -calculus.
  
  
 The difference in verbosity of the two emulations can be explained by two rea-
 sons:
  
 1. The
  
 -calculus is somewhat weaker in its basic operations causing the need 
  
 for a name comparison emulation and",NA
4 ,NA,NA
Conflict & Cohabitance,"When two worlds collide the question is whether they cancel out or enlighten each other.
  
 – me
  
 N 
  
 programming and convinced ourselves that subsuming functional pro-
  
 gramming with an object-oriented language works fine at the calculus 
  
 ow that we know the foundations of both functional and object-oriented
  
 level it is time to refocus our overall goal. Part II starting at page 85 is going to 
 present functional concepts made amenable to object-oriented design by captur-
 ing them in design patterns. But which functional concepts are appropriate? This 
 chapter discusses functional and object-oriented concepts that seem to be at odds 
 with each other (section 4.1) and shows a path of possible integration (section 4.2 
 on page 57) partly reconciling conflicts discovered in the following section.",NA
4.1 ,NA,NA
Conflict,"Although, the preceding chapter gave us confidence that an integration of func-
 tional concepts into an object-oriented language is viable it might be the case that 
 incommensurable properties prevent an integration at the programming language 
 level. Indeed, the following sections reveal some immediate oppositions and re-
 dundancies.",NA
4.1.1 ,NA,NA
Oppositions,"This section discusses diametral oppositions of the functional and the object-
 oriented paradigm.
  
 4.1.1.1 
  
 Semantic model
  
 As elaborated in section 1.2.2 on page 11 functional programming is founded on 
 reduction semantics, i.e., excludes the presence of side-effects. Object-orientation, 
 however, relies on stateful objects (see section 2.2.6 on page 37). This is a serious 
 conflict. Abandoning either reduction semantics or stateful objects seems to de-
 stroy one of the paradigm foundation piles respectively. Actually, the integration 
 of functional and object-oriented features amounts to combining both declarative 
 and algorithmic language paradigms (see figure 4.1 on the next page).",NA
4.1.2 ,NA,NA
Redundancy,"It is obvious that opposing concepts exclude their integration. All the same, it is of 
 no use to integrate concepts that are redundant to each other. Concepts must 
 complement each other otherwise a software solution will become an incoherent 
 mix of styles which is hard to understand but does not justify its diversity with 
 corresponding properties.
  
 4.1.2.1 
  
 Parameterization
  
 Higher-order functions (see section 1.2.3 on page 12) and inheritance (see sec-tion 
 2.2.3 on page 33) can both be used for behavior parameterization [K¨uhne95b]. 
 The Template Method pattern uses subclassing to achieve behavior parameteriza-
 tion akin to higher-order functions. Unless the two mechanism do not yield soft-
 ware solutions with different properties and no further complement of one to the 
 other can be found, one should be dismissed.
  
 4.1.2.2 
  
 Dispatch
  
 Pattern matching (section 1.2.5 on page 16) and dynamic binding (section 2.2.5 on 
 page 35) can both be used to decompose a function into partial definitions and to 
 select the appropriate portion when executing the function. Both mechanisms di-
 vide a function according to the constructors it operates on. While pattern 
 matching keeps the patterns at one place, dynamic binding distributes it to the 
 constructors. It should be clear whether two code selection mechanisms are 
 needed.",NA
4.2 ,NA,NA
Cohabitance,"If we literally agreed to all the arguments made in the previous sections it would 
 be time to abandon any paradigm integration at all. Luckily, many points made 
 above that at first appear excluding are in fact complementing. In the following, I 
 propose how to subsume and integrate functional concepts into those of the 
 object-oriented paradigm. The last section goes beyond feasibility and presents 
 synergistic effects between the two paradigms.",NA
4.2.1 ,NA,NA
Subsumption,"Subsuming functional concepts into object-oriented ones means to find ways to 
 express them without changing an object-oriented language.
  
 4.2.1.1 
  
 Pure functions
  
 Even without motivation from functional languages it has been suggested to use 
 side-effect free functions only [Meyer88]. The so-called command-query 
 separation principle prescribes to use side-effects for commands only. For 
 instance the code,",NA
4.2.2 ,NA,NA
Integration,"In contrast to subsumption, integration demands for adaptions of the host 
 language in order to encompass functional concepts.
  
 4.2.2.1 
  
 Evaluation
  
 We already regained functions for lazy evaluation (section 4.2.1.1 on page 57) but 
 may also want to have lazy object state semantics too. Otherwise, internal object 
 state might be computed without being requested at all. 
  
 One approach 
 to achieve lazy effects relies on a refined state monad concept [Launchbury93, 
 Launchbury & Jones94]. Another opportunity is to use models from concurrent 
 object-oriented languages and to propose lazy message mailboxes for objects. In 
 the context of this dissertation we will be satisfied with lazy functions only, 
 though.
  
 A short note is in order regarding the remark that dynamic binding does not 
 co-habit with lazy evaluation (see section 4.1.1.3 on page 56). First, dynamic 
 binding only requires to know the type the receiver which amounts to a partial 
 evaluation only. Second, function application is strict in its first argument 
 anyway. One might evaluate arguments first but eventually the function to be 
 applied must be eval-uated to a function abstraction. Therefore, dynamic binding 
 poses no additional requirements that would render lazy evaluation useless.
  
 4.2.2.2 
  
 Closures
  
 Section 3.4 on page 49 demonstrated how to use objects as closures in order to im-
 plement functions with lexical scoping. Closures capture the values of variables at 
 their declaration and/or application environment as opposed to the point of exe-
 cution. That is why, one can safely use closures in conjunction with lazy 
 evaluation (see section 4.2.1.1 on page 57). Once applied to values closures do not 
 depend on state changes anymore.
  
 Why do closures need to be integrated rather than subsumed? Most object-
 oriented languages do not allow free functions
 2
 and require class definition over-
 head for closures which especially gets worse when currying should be supported. 
 Moreover, few object-oriented languages (e.g., S
 MALLTALK
  and J
 AVA
 ) provide 
 mechanisms for anonymous closures (e.g., blocks [Goldberg & Robson83] and in-
 ner classes [Sun97] respectively).",NA
4.2.3 ,NA,NA
Synergy,"Synergy occurs when two or more concepts complement each other in a way that 
 results in properties that cannot be described by the sum of the separated concepts.
  
 2
 C
 ++
  being an exception but then its functions are too weak to support closures.",NA
Conclusion,"4
  
 Conflict & Cohabitance",NA
4.3,"Although a fruitful integration of functional concepts into object-oriented 
 program-ming appeared to be impossible first (section 4.1 on page 55) I 
 demonstrated the most concepts to be complementary rather then excluding 
 (section 4.2 on page 57).
  
  
 We retained stateful objects for real world modeling without impedance mis-
 match, efficiency, and for maintenence reasons.
  
 “Pure languages ease change by making manifest the data upon which each
  
 operation depends. But, sometimes, a seemingly small change may require a
  
 program in a pure language to be extensively restructured, when judicious use
  
 of an impure feature may obtain the same effect by altering a mere handful of
  
 lines. [Wadler92]”
  
 –
  Philip Wadler
  
 Nevertheless, the virtues of referential transparency are still available due to the 
 command-query separation principle.
  
  
 We have seen that a restriction to a pure functional or object-oriented de-
 composition leads to unsatisfactory results in either case. 
  
 Both object-oriented 
 or functional decomposition can be appropriate depending whether the objects or 
 the functions (business-transactions) are the more stable concept. 
  
 After an 
 initial repulsion of any function which is not a object method it is time to re-
 integrate free functions into object-oriented design again. A move towards this 
 direction are so-called command objects, e.g., used for application callback func-
 tions [Meyer88, Gamma et al.94]. Still, these are not acknowledged as functions but 
 as representations of actions to be undone or protocoled [Meyer88].
  
 Regarding the separation between subsumption (section 4.2.1 on page 57) and 
 integration (section 4.2.2 on page 59) it should be noted that the borderline be-
 tween is somewhat arbitrary. One may also claim that objects subsume functions 
 without further integration needed or that side-effect free functions and value se-
 mantics need further integration. With the assessment that stateful programming 
 subsumes functional programming and objects subsume values I meant the op-
 portunity to partly renounce side-effects by programmer discipline. Of course, it 
 is acknowledged that language support for controlling side-effects is highly 
 desirable (see section 14.5 on page 243).
  
 In conclusion, it appears quite reasonable and promising to integrate two 
 seem-ingly contradicting paradigms. However, someone using such a dual-
 paradigm approach needs guidance
  when
  to choose
  which
  alternative. Figuratively 
 speaking, when to choose the declarative or the procedural branch of figure 4.1 on 
 page 56. It is the intent of the pattern system presented in part II starting at page 
 85 to provide a base of arguments for a decision.",NA
5 ,NA,NA
Design Patterns,"Once is an event, twice is an incident, thrice it’s a pattern.
  
 – Jerry Weinberg
  
 T 
  
 than two years after design patterns have been popularized in 1994 there 
  
 are still argues about their correct definition and their meaning for soft-
  
 he notion of a software design pattern is not formally defined. More
  
 ware development [Gabriel96]. In order to define the role of design patterns in the 
 context of this dissertation I provide an introductory definition starting with ex-
 amples from everyday life (section 5.1). After considering the origins of patterns 
 (section 5.2 on page 74) I mention some of the promises to be expected from 
 design patterns (section 5.3 on page 76). This chapter concludes with an 
 explanation of the design pattern format (section 5.4 on page 76) and a description 
 of the diagram notation (section 5.5 on page 79) both to be used in part II 
 beginning at page 85.",NA
5.1 ,NA,NA
Definition,"Patterns are ubiquitous. Most often they are not recognized and less often they are 
 captured by a literate form, but still they exist. This is true of the everyday 
 meaning of the word “pattern”, but also, and more importantly, it is also true for a 
 special meaning first described by the architect Christopher Alexander:
  
 “Each pattern is a three-part rule, which expresses a relation between a
  
 certain context, a problem, and a solution [Alexander79].”
  
  
 –
  Christopher Alexander
  
 However, it is the nature of patterns to recur, so let us simplify the above to:
  
 A pattern is a recurring solution to a problem in a context.
  
 That is why patterns are ubiquitous. People, but also the mechanisms of nature, 
 repeatedly apply the same solutions to problems that occur in a certain context.",NA
5.1.1 ,NA,NA
A gentle introduction,"Let us assume the context of writing a piece of music for the mass market. We are 
 confronted with conflicting forces:",NA
A,NA,NA
B,NA,NA
A,NA,NA
C,NA,NA
A,NA,NA
B,"Figure 5.1: A composer’s pattern
  
 Using this pattern has several consequences:
  
 •
  Familiarity.
  The listener is smoothly introduced into our musical ideas and can 
 learn the themes due to their repetition. After the exiting change with 
  
 special theme “C” we calm him down again.
  
 •
  Keep awake.
  At the point when the listener might think there is no new stuff to 
 discover we surprise him with the more exiting “C” theme.
  
 •
  Regularity.
  If we build all our songs according to this knitting pattern the lis-
 tener will recognize it in the long run and be bored in spite of the surprising 
  
 variation of repetition.
  
 This description does not aim at completeness. It merely attempts to explain the 
 pattern concept with everyday notions. If we travel a bit further down this road 
 we can see how patterns may collaborate with each other. Let us imagine we 
 composed a song according to the “ABACAB” pattern but aim at a very dramatic",NA
5.1.2 ,NA,NA
Software Patterns,"Patterns are useful in the context of software development, since software engi-
 neering is not a science yet. There is no straight way of creating an optimal system 
 and probably never will be. This is the case for patterns. They are useful when 
 something creative has to be build and no hard and fast rules apply. Patterns are 
 to be applied by humans not by (today’s) computers.
  
 “
 ...
 software designers are in a similar position to architects and civil en-
  
 gineers, particularly those concerned with the design of large heterogeneous
  
 constructions, such as towns and industrial plants. It therefore seems natural
  
 that we should turn to these subjects for ideas about how to attack the design
  
 problem. As one single example of such a source of ideas I would like to mention
  
 Christopher Alexander: Notes on the Synthesis of Form [Alexander64].”
  
 –
  
 Peter Naur
  
 “Subsystems created by the composition of objects or interaction machines
  
 do not conform to any accepted notion of structure and are very hard to charac-
  
 terize, though they do determine subsystems that exhibit reusable regularities
  
 of interface behavior. The term pattern is used to denote reusable regularities
  
 of behavior exhibited by interactive subsystems created by the composition of
  
 interaction primitives. [Wegner95].”
  
 –
  Peter Wegner
  
 1
 These are partly taken from a dictionary [Harkavy & et al.94].",NA
5.2 ,NA,NA
History,"It is hard to determine who described the notion of a pattern first. Because of its 
 fundamental and universal meaning for the human mind it should not come as a 
 surprise to discover works as old as Liu Hsieh‘s (465–522) “The Literary Mind and 
 the Carving of Dragons” (subtitle: A study of thought and pattern in Chinese 
 literature). He discusses forty nine different patterns in Chinese literary classics in 
 the style of a cookbook [Freddo96].
  
 The first to popularize patterns, however, was Christopher Alexander. He cap-
 tured successful architectural solutions in pattern descriptions that are supposed to 
 allow even non-architects to create their own individual architectural solutions 
 (e.g., rooms, houses, gardens) [Alexander et al.77, Alexander79]. His patterns form 
 a language, i.e., they provide a top-down guidance from the arrangements of cities 
 down to areas, houses, and the shaping of rooms. Alexander’s work also caused 
 the software community to pay attention to patterns. His first influence already 
 took place at the 1968 NATO conference
 3
 in Garmisch when Naur, referring to 
 Alexan-der’s Ph.D. thesis [Alexander64], mentioned the connection between 
 architecture
  
 3
 Coincidentally, Friedrich L. Bauer coined the term “Software Engineering” at this conference.",NA
Promise,"5
  
 Design Patterns",NA
5.3,"Design patterns recommend themselves by many good reasons (see table 5.2).
  
 Category
  
 Reusable Software
  
 Reusable Design
  
 Documentation
  
 Communication
  
 Teaching
  
 Language Design
  
 Description
  
 Software systems built with patterns are easier to main-
 tain, since patterns, among other aspects, often capture 
 the key solutions that make software extensible.
  
 Patterns can be used as building blocks for system de-
 signs [Beck & Johnson94]. There is no need to invent 
 these micro-architectures again and again.
  
 Augmenting a design documentation with pattern names 
 and assigning pattern roles to system components in-
 stantly communicates a chosen design decision to a pat-
 tern connoisseur
 7
 [Johnson92].
  
 Pattern names establish a vocabulary that enables to dis-
 cuss about designs at a higher level.
  
 As recorded experience patterns can be used for teaching 
 successful designs. Patterns are a way to hand down cul-
 ture from generation to generation [Coplien96b].
  
 If a recurring solution can be recognized as a work-
 around 
 due 
 to 
 an 
 inappropriate 
 implementation 
 language, it should be taken in consideration for the 
 design of new lan-guages [Baumgartner et al.96, Seiter et 
 al.96].
  
 Table 5.2: Promise of design patterns
  
 The last category in table 5.2 is not usually promoted as a benefit of patterns, 
 yet plays an important role for this dissertation: Part III starting at page 233 
 discusses the impact on language design caused by the pattern system presented 
 in part II beginning at page 85.",NA
5.4 ,NA,NA
Form,"All design pattern descriptions of part II use a slightly modified GOF pattern tem-
 plate [Gamma et al.94]. Besides minor changes to style and the division of the mo-
 tivation into a problem and solution section I added categories to section “Related 
 Patterns” in order to clarify the nature of each relation. The following template 
 description has been adapted from the original GOF template description:
  
 7
 A scientific proof of this statement has been made with a controlled experiment showing the 
 recognition of patterns to result in faster and better changes to a program [Prechel et al.97].",NA
Pattern Name ,"The pattern’s name conveys the essence of the pattern succinctly. A good name is 
 vital, because it will be used in design discussions.",NA
Intent ,"A short statement that answers the following questions: What does the design pat-
 tern do? What is its rationale and intent? What particular design issue or problem 
 does it address?",NA
Also Known As ,"Other well-known names for the pattern, if any.",NA
Motivation ,"A scenario that illustrates —
  
 Problem
  
 — a design problem —
  
 Solution
  
 — and how the class and object structures in the pattern solve the problem. 
  
 The scenario will help you understand the more abstract description of the pat-
 tern that follows.",NA
Applicability ,"What are the situations in which the design pattern can be applied? What are ex-
 amples of poor designs that the pattern can address? How can you recognize these 
 situations?
  
 •
  An applicability bullet.
  An applicable situation.",NA
Structure ,A diagram showing relationships between participating classes and/or objects.,NA
Participants ,"The classes and/or objects participating in the design pattern and their responsi-
 bilities.
  
 •
  Participant Name
  
  
 –
  Responsibility for what.",NA
Collaborations ,"An interaction diagram and verbal description explaining how the participants col-
 laborate to carry out their responsibilities.
  
 •
  Collaboration.",NA
Consequences ,"How does the pattern support its objectives? What are the trade-offs and results of 
 using the pattern? What aspect of system structure does it let you vary indepen-
 dently?
  
 •
  An consequence bullet.
  Description of consequence.",NA
Implementation ,"What pitfalls, hints, or techniques should you be aware of when implementing the 
 pattern? Are there language-specific issues?
  
 •
  An implementation bullet.
  Description of implementation aspect.",NA
Sample Code ,"Code fragments that illustrate how you might implement the pattern in E
 IFFEL
 .",NA
Known Uses ,Examples of the pattern found in real systems or languages.,NA
Related Patterns ,"What design patterns are closely related to this one?
  
 Categorization 
  
 Patterns with important similarities and differences.
  
 Collaboration 
  
 Patterns that allow useful collaborations.
  
 Implementation 
  
 Patterns likely to be used for implementation.",NA
5.5 ,NA,NA
Diagram notation,"Following the GOF pattern template, all interaction-, class- and object diagrams 
 use an extended OMT diagram notation [Rumbaugh91]. In the following figures 
 shadowed ellipses are used to separate notational elements from their description.",NA
5.5.1,NA,NA
Class diagram notation,"Type parameter
  
 Class name
  
 AbstractClass
  
 method(argument : ArgType)
  
 inherits
  
 ConcreteClass
  
 GenericClass
  
 method(argument : ArgType)
  
 method(argument : ArgType) : ResultType
  
 creates
  
 Heir
 1
  
 Heir
 2
  
 Heir
 3
  
 uses
  
 aggregates
  
 Figure 5.4: OMT Notation: Class diagram
  
 Aggregation, as usual, means that a class has an attribute of the pointed-to class
  
 type. The uses relation denotes the pointed-to class to be a server and thus includes
  
 aggregation and parameter passing.",NA
5.5.2 ,NA,NA
Object diagram notation,"anObject
  
 references 
  
 creates
  
 anObject 
  
 anObject
  
 Figure 5.5: OMT Notation: Object diagram",NA
5.5.3 ,NA,NA
Interaction diagram notation,"Object identifier
  
 anObject
  
 anObject
  
 anObject
  
 create
  
 Timeline
  
 method call
  
 returning a result
  
 Object active
  
 method(argument)
  
 Skipping time
  
  
 Figure 5.6: OMT Notation: Interaction diagram",NA
Part II,NA,NA
Pattern System,NA,NA
6 ,NA,NA
Catalog,"Design patterns are points in a multidimensional design space
  
 that denote configurations of abstract design rules that actually work.
  
 – me
  
 C 
  
 functional concepts for object-oriented design. Now we select the con-
  
 cepts to be presented as design patterns. First, I briefly discuss the ten-
  
 hapter 3 on page 45 discussed the compatibility and utility of several
  
 sion between Patterns and Proto-Patterns. Second, I motivate the particular selec-
 tion of concepts made and use so-called pattlets to generalize on each resulting 
 pattern’s solution or supporting idea. Table 6.3 on page 92 lists all patterns with 
 page index and intent description. Finally, I motivate the use of E
 IFFEL
  for sam-ple 
 code. Chapter 13 on page 221 elaborates on the possible interactions between 
 patterns of the system.",NA
6.1 ,NA,NA
Proto-Patterns,"Before I am going to present a system of patterns I should elucidate whether it 
 should better be called a system of Proto-Patterns. Section 5.1.1 on page 69 intro-
 duced the term “Proto-Pattern” to denote patterns that lack the empirical 
 evidence of successful application. After all, I aim at enriching object-oriented 
 culture with concepts from a different paradigm. Indeed, for most of the 
 presented patterns and their variants I cannot fulfill the rule of three, that is, name 
 three occurrences in software systems. Does that make the patterns less useful? 
 My answer is no! First, it is problematic to define the quality of something by its 
 quantitative occur-rence. According to this measure, F
 ORTRAN
  and C
 OBOL
  would 
 probably be the best programming languages. Neither does the widespread use of 
 a design solu-tion imply its quality. Second, the patterns presented are proven 
 designs though not in object-oriented systems. Nevertheless, they record 
 successful designs from functional programming.
  
  
 Apparently, the rule of three is a good idea to motivate pattern authors to do 
 their homework but should not be taken too literally.
  
 “And occasionally, we do not start from concrete observation at all, but
  
 build up the invariant by purely abstract reasoning.",NA
6.2 ,NA,NA
Pattern System,"The subsequent sections motivate each pattern (see table 6.3 on page 92) in the 
 context of the discussion in chapter 4 on page 55. The actual patterns are 
 presented in the following chapters using the template description of section 5.4 
 on page 76. Any collaboration between patterns within the presented system will 
 be covered in chapter 13 on page 221.
  
 Subsequently, I use so-called pattlets to express the general idea, wisdom be-
 hind, or observations supporting a pattern. Pattlets recommend themselves to ex-
 press a practical advise without the overhead of a full blown pattern description.
  
 For instance:
  
 Pattlet I
  
 Describe a very general pattern extremely poignant and concise with a pattlet.
  
 ♦
  
 A pattlet just very briefly expresses a statement that has a very general 
 applica-bility and would need specializations at least in the form of multiple 
 examples or even dedicated patterns in order to be a comprehensible pattern 
 description.",NA
6.2.1 ,NA,NA
Function Object,"One of the most important concepts in functional programming are higher-order 
 functions [Hughes87]. Coincidentally, parameterization was shown to cohabit 
 with inheritance even synergistically (see section 4.2.3.1 on page 60):
  
 Pattlet II
  
 For mature domains use black-box reuse.
  
 ♦",NA
6.2.2 ,NA,NA
Lazy Object,"The second most important concept supporting modularity — next to higher-
 order functions — from functional programming is lazy evaluation [Hughes87]. It 
 is worthwhile attempting to achieve the same decoupling between generators and 
 consumers, to aim at a similar independence of irrelevant dependencies —
  
 Pattlet III
  
 The early bird gets the worm but the lazy lion gets the flesh.
  
 ♦
  
 — and to capture infinite data structures.
  
 Pattlet IV
  
 Capture infinity by creating a cycle.
  
 ♦
  
 Lazy Object handles both aspects of call-by-need semantics:
  
 1. Latest possible evaluation and
  
 2. at most once evaluation of expressions.
  
 It also leads to the particular useful notion of lazy streams, which can be used to 
 support iteration and conversion of collections.",NA
6.2.3 ,NA,NA
Value Object,"Section 4.2.1.1 on page 57 argued in favor of pure, i.e., side-effect free functions. A 
 deliberate renunciation of state in programming was chosen to reduce software 
 complexity due to state interactions.",NA
6.2.4 ,NA,NA
Transfold,"Whereas in object-oriented programming iterators are very popular (see Iterator 
 pattern [Gamma et al.94]) functional programmers use so-called mappers.
  
 Pattlet VI
  
 For safety and reuse: Don’t call us we call you.
  
 ♦
  
 Mappers (e.g.,
  map
  and
  fold
 ) accept a function and apply it to all elements of a 
 collection. Transfold, therefore, is an application of the functional principle to use 
 general purpose library functions which can be specialized by using higher-order 
 functionality. Transfold is shown to be specializeable to a plethora of operations.
  
 Pattlet VII
  
 Provide the most powerful concept and specialize it to solve concrete problems.
  
 ♦
  
  
 Although, it is acknowledged that functional mappers are easier and safer to 
 use than conventional iterators, it is commonly assumed that
  
 •
  they are not applicable in languages without built-in support for closures and
  
 •
  they are less flexible than iterators.
  
 Transfold invalidates both arguments by generalized folding with function objects.",NA
6.2.5 ,NA,NA
Void Value,"Void Value [K¨uhne96b] is inspired by pattern matching. Yet, instead of 
 establishing a similar mechanism I observe that pattern matching is simply 
 another form of case statements. One of the fundamentals of object-oriented 
 design, however, is
  
 Pattlet VIII
  
 Replace case statements with dynamic binding.
  
 ♦",NA
6.2.6 ,NA,NA
Translator,"Translator [K¨uhne98] uses external functions to avoid element interfaces from be-
 coming bloated and being subject to changes. It, accordingly, prefers a functional 
 over an object-oriented decomposition (see section 4.2.3.2 on page 64). Actually, it 
 employs the Generic Function Object pattern on page 109 to implement free multi-
 dispatching functions. Translator is inspired by denotational semantics descrip-
 tions [Schmidt86] and facilitates incremental evaluation.
  
 Pattlet X
  
 Incremental evaluation calls for homomorphic translations.
  
 ♦
  
 Homomorphic translations are well-known in functional programming (e.g., 
 by the so-called fold operators [Bird86, Gibbons & Jones93]) and Translator relies 
 on them for local function descriptions and incremental evaluation.
  
 Translator also uses an intermediate data structure which is in close correspon-
 dence to the explicit data structures used in functional programming to facilitate 
 proofs and clarify design [King & Launchbury93]. John Backus’ F
 P
  language com-
  
 1
 Nil has many different names such as Null, None, and Void.",NA
6.3,NA,NA
Why Eiffel?,"I choose E
 IFFEL
  as the language to illustrate pattern issues with sample code, since
  
 •
  it is well-known,
  
 •
  uses garbage collection,
  
 •
  has a clean-syntax,
  
 •
  and is purely object-oriented.
  
 A language like C
 ++
 would force the examples to include code for memory 
 management, distracting from the prior goals. E
 IFFEL
 ’s syntax is sufficiently easy 
 to read in order to allow C
 ++
 - or S
 MALLTALK
  programmers to benefit from the 
 examples. B
 ETA
  has a much less clear syntax and is also already influenced by 
 functional ideas which makes it less clear to demonstrate the emulations needed 
 for pure object-oriented languages.
  
  
 E
 IFFEL
  scores well above a number of other well-known general purposes lan-
 guages with 21 source statements per function point [Jones96] (see table 6.2).
  
 Language
  
 Level
  
 Average source
  
 statements per
  
 function point
  
 A
 DA
  95
  
 6.50
  
 49
  
 C
 LOS
  
 15.00
  
 21
  
 C
 ++
  
 6.00
  
 53
  
 E
 IFFEL
  
 15.00
  
 21
  
 H
 ASKELL
  
 8.50
  
 38
  
 J
 AVA
  
 6.00
  
 53
  
 S
 MALLTALK
  
 15.00
  
 21
  
 Table 6.2: Language levels
  
 J
 AVA
  would have been a very good candidate too. I expect a correction to the 
 language level given in table 6.2. Unfortunately, until today J
 AVA
  lacks support 
 for generic datatypes. Any generic treatment of datatypes means to create 
 superfluous subclasses or spurious cast statements. Given this limitation, E
 IFFEL
  
 was the best choice to express pattern goals with the least distraction from 
 language limitations.",NA
7 ,NA,NA
Function Object,"The secret of dealing successfully with a child is not to be its parent.
  
 – Mell Lazarus",NA
7.1 ,NA,NA
Intent,"Encapsulate a function with an object. This is useful for parameterization of algo-
 rithms, partial parameterization of functions, delayed calculation, lifting methods 
 to first-class citizens, and for separating functions from data.",NA
7.2 ,NA,NA
Also Known As,"Lexical Closure [Breuel88], Functor [Coplien92], Agent [Hillegass93], Agent-
 Object [K¨uhne94], Functionoid [Coleman et al.94], Functoid [L¨aufer95], 
 Function-Object [Stepanov & Lee94, K¨uhne95b, K¨uhne97].",NA
7.3 ,NA,NA
Motivation,"Almost any software system makes use of behavior parameterization in one or the 
 other way. Iterators are a good example. The iteration algorithm is constant 
 whereas an iteration action or function varies. A special kind of iteration is the 
 has
  
 (member test) function of a collection. Consider a collection of books. Member 
 testing should cover testing for a particular book title, book author, book type, etc.",NA
7.3.1 ,NA,NA
Problem,"We may implement the predicate in the collection’s elements. This works nicely if
  
 •
  the element’s natural interface contains the predicate.
  
 •
  the predicate implementation may vary with the element type, but we do not 
 want to have a selection of several predicates for one element type.
  
 Composing traversal algorithm and predicate as above uses dynamic binding of 
 the element’s predicate method. For instance, it is acceptable for a
  SortedList
  of",NA
7.3.2 ,NA,NA
Solution,"The best way to get rid of the above disadvantages is to objectify predicates with 
 the Function Object pattern. Combining traversal algorithm and function with 
 Func-tion Object works through literally “giving” an objectified function to an 
 internal iterator. In our example, the member test method accepts a test predicate 
 to be used during iteration:
  
 has(predicate : Function[Book, Boolean]) : Boolean is 
 do 
  
 from 
  
 i:=1; 
  
 until i>count or Result 
  
 loop 
  
  
 if predicate @ (books.item(i)) then 
  
  
  
 Result:=true; 
  
  
 end; 
  
  
 i:=i+1; 
  
 end; 
  
 end
  
 Here, the collection of books simply consists of an array of books that is tra-
 versed with an integer loop. Note how E
 IFFEL
  allows using a nice function appli-
 cation syntax for passing the current book to the predicate. The operator “
 @
 ” is 
 defined as an infix operator in the common interface for all function objects:
  
 deferred class Function[In, Out] 
  
 feature 
  
 infix 
  
 ""@"" (v : In) : Out is deferred end; 
 end
  
 The
  @
 -operator is defined to take a generic argument type
  In
  and to return a 
 generic result type
  Out
 . The member test method from above instantiates these to 
 Book
  and
  Boolean
  respectively.
  
 A predicate to check for a bible instance is:
  
 class IsBible 
  
 inherit Function[Book, Boolean] 
  
 feature 
  
 infix 
  
 ""@"" (b : Book) : Boolean is 
  
 do 
  
  
 Result:=(b.title.is_equal(""Bible"")); 
 end; 
  
 end",NA
7.4 ,NA,NA
Applicability,"•
  Parameterization.
  Function objects are a good candidate whenever general be-
 havior can be adapted to special behavior:
  
 Dynamics.
  In addition to runtime selection of existing function objects, new 
 function objects can also be created at runtime. A user may dynamically 
 com-pose a multi-media function object from text-, graphic-, and sound-
 producing function objects.
  
 Orthogonality.
  Having more than one behavior parameter creates the 
 problem of handling all possible combinations of the individual cases. 
 Function objects can freely be mixed without interfering and without 
 combinator classes.
  
 Reuse.
  Function objects can be used by any adaptable algorithm that knows 
 their interface. Even if the algorithm was not designed to supply a function 
 with mandatory arguments, it is often possible to supply them to the func-
 tion in advance. Consider an error reporter, parameterized by output format 
 functions, only intended for generating text messages. We can upgrade the 
 re-porter to create a graphical alert-box by passing a function object that 
 already received information about box-size, colors, etc.
  
 Identity.
  When the behavior of an object should change while keeping its 
 identity, function objects can be used as behavior parameters to the ob-ject. 
  
 In contrast, encoding behavior in subclasses calls for something like 
 S
 MALLTALK
 ’s “
 become:
 ” in order to achieve the same effect.
  
 •
  Business transactions.
  Often the
  functions
  are the stable concepts of a system 
 and represent good maintainance spots, in order to cope with changing func-
  
 tionality. 
  
 Instead of being a well-defined operation on one single object, 
  
 transactions are
  “an orchestration of objects working together toward a common 
  
 goal”
  [Coplien92]. When transactions do not naturally fit into existing data ab-
  
 stractions, Function Object can lift them to first-class status while providing a",NA
7.5 ,NA,NA
Structure,See figure 7.1 on the next page.,NA
7.6 ,NA,NA
Participants,"•
  Function
  
 –
  declares an interface for function application.
  
 •
  ConcreteFunction
  (e.g.,
  isBible
 )
  
 –
  implements a function.
  
 –
  collects argument values until evaluation.",NA
7.7 ,NA,NA
Collaborations,"•
  A client creates a function and possibly supplies 
 arguments.
 •
  An invoker takes the function as a parameter.
  
 •
  The invoker applies the function to arguments.
  
 •
  The client receives a result from the invoker.
  
 Client and invoker do not necessarily have to be different objects. A client may 
 evaluate a function object itself if no further arguments are needed or it does not 
 need an invoker to determine the point of evaluation. If an invoker does not 
 supply further argument but uses a dummy argument only to evaluate the 
 function object than we have an application of the Command pattern.",NA
7.8 ,NA,NA
Consequences,"•
  Abstraction.
  Function objects abstract from function pointers and in particular 
 from pointers to methods [Coplien92]. Instead of the C
 ++
 code:
  
 aFilter.*(aFilter.current)(t);
  
 we can write
  
 aFilter(t);
  
 •
  Simplicity.
  The use of function objects does not introduce inheritance relation-
 ships and does not create spurious combinator classes.
  
 •
  Explicitness.
  The code
  cook.prepare(fish)
  is easy to understand. When 
 recipes are wired into
  Cook
  subclasses,
  cook.prepare
  depends on the
  
 actual
  Cook
  type. 
  
 Clever variable names (e.g.,
  fishCook.prepare
 )
  
 often are not 
  
 an option, 
  
 e.g., 
 cook.prepare(fish)
 , 
  
 followed 
  
 by
  
 cook.prepare(desert)
 .
  
 Note that the client must know the function object. A variability on the im-
  
 plementation — rather than the behavior — of
  Cook
  is better treated with a
  
 Bridge [Gamma et al.94]. Clients of
  Cook
 s should not know about implemen-
  
 tation alternatives, unless they explicitly want to decide on time and space
  
 behavior.",NA
7.9 ,NA,NA
Implementation,"•
  Creation.
  Quite naturally, function objects must be created before they can be 
 used. A typical code fragment shows the overhead in notation to create the 
  
 object:
  
 ...
  
 local
  
 times : Times[Integer];
  
 do",NA
7.10 Function Object variants,This section shortly touches upon important extensions to Function Object.,NA
7.11 Known Uses,"Apart from the uncountable uses of Function Object in functional programming 
 and S
 CHEME
  [Abelson & Sussman87], there are many truly object-oriented uses: 
 S
 MALLTALK
  [Goldberg & Robson83] features
  blocks
  as true closures with implicit 
 binding of free variables. S
 ATHER
  provides
  bound routines
  [Omohundro94]. A
 L
 -
 GOL
  
 68’s thunks for call-by-name parameter passing are also closures but bind free 
 variables dynamically in the calling environment. J
 AVA
  1.1 features “inner 
 classes”which are essentially (anonymous) closures used, e.g., for callbacks 
 [Sun97]. The Eiffel Booch Components uses Function Object for searching, sorting, 
 transforming and filtering of containers [Hillegass93]. The Standard Template 
 Library, which was adopted as part of the standard C
 ++
 library, uses Function 
 Object to inline operations for arithmetic, logic, and comparison [Stepanov & 
 Lee94].
  
 5
 A more flexible approach is to use dynamically extendible dictionaries that associate types with 
 code.",NA
7.12 Related Patterns,NA,NA
7.12.1 ,NA,NA
Categorization,"Objectifier:
  A function object, like Objectifier, does not represent a concrete object
  
 from the real world [Zimmer94], though one can reasonably take business-
  
 transactions for real. Function Object is very similar to Objectifier, in that it
  
 objectifies behavior and takes parameters during initialization and call. Per
  
 contra, clients “have-an” objectifier, while clients “take-a” function object.
  
 The latter is a
  uses
 , not a
  has-a
  relationship.
  
 Command:
  A procedure object which does not take any arguments after cre-
  
 ation and produces side-effects only boils down to the Command pat-
  
 tern [Gamma et al.94]. One key aspect of Command is to decouple an invoker
  
 from a target object. Function objects typically do not delegate functionality.
  
 Rather than delegating behavior to server objects they implement it them-
  
 selves. So, function objects normally do not work with side-effects, but return
  
 their computation as an argument-application result. Nevertheless, function
  
 objects also can be used for client/server separation, i.e., as Call-back func-
  
 tions. In addition to Command, invokers are then able to pass additional
  
 information to function objects by supplying arguments.
  
 State,
  
 Strategy:
  Function Object, State, and Strategy [Gamma et al.94] are concerned with
  
 encapsulating behavior. A decision between them can be based on concerns
  
 such as:
  
 •
  Who is responsible for changing the variable part of an algorithm?
  
 The State pattern manages the change of variability autonomously.
  
 Function objects are explicitly chosen by the client. Strategies are chosen
  
 by the client also, but independently of operation requests. Requesting
  
 an operation can rely on a Strategy choice made some time earlier.
  
 •
  Is it feasible to impose the same interface on all variations?
  
 If 
  
 the 
  
 available 
  
 Strategies 
  
 range 
  
 from 
  
 simple 
  
 to 
  
 complex, 
  
 the
  
 abstract 
  
 Strategy 
  
 must 
  
 support 
  
 the 
  
 maximum 
  
 parameter 
  
 inter-
  
 face [Gamma et al.94]. 
  
 Function Object avoids this by partial param-
  
 eterization.
  
 •
  Does the combination of common and variable part constitute a useful 
 concept?
  
 The State pattern conceptually represents a monolithic finite state ma-
  
 chine, so the combination of standard- and state-dependent behavior
  
 makes sense indeed. Strategies are a
  permanent
  part of general behav-",NA
7.12.2 ,NA,NA
Collaboration,"Iterator:
  Function objects allow the use of data from inside (elements) and outside 
 the collection (previous arguments). There is no collaboration between Com-
 mand and Iterator, since Command does not take arguments.",NA
7.12.3 ,NA,NA
Implementation,"Composite:
  Standard and composed function objects can be uniformly accessed 
 with the Composite pattern [Gamma et al.94]. A composite function 
 forwards arguments to its component functions. A tuple-Composite applies 
 all func-tions in parallel to the same argument and thus produces multiple 
 results. Several reduce functions (e.g.,
  and
  of section 7.3.2 on page 96) may 
 somehow fold all results into one output.
  
 A pipeline-Composite applies each function to the result of its predecessor 
 and thus forms a calculation pipeline.
  
 Prototype:
  Often it is useful to distribute the accumulated state of a function object 
 to different clients. For instance, a command for deleting text can capture the 
 information whether to ask for confirmation or not. However, when placed 
 on a history list for undoing, different commands must maintain different 
 pointers to the deleted text. Consequently, Prototype can be used to clone 
 pre-configured function objects which should not share their state any fur-
 ther. With this regard, any partially parameterized function object can be in-
 terpreted as a prototype for further applications (see example about the 
 costly calculation in section 7.8 on page 102,
  Efficiency
 ).
  
 Chain of Responsibility:
  Generic Function Object can employ a Chain of 
 Responsibil-ity for argument type discrimination. Chain members check 
 whether they can handle the actual argument type. This enables a highly 
 dynamic exchange of the dispatch strategy.",NA
8 ,NA,NA
Lazy Object,"Ungeduld hat h¨aufig Schuld.
  
 – Wilhelm Busch",NA
8.1 ,NA,NA
Intent,"Defer calculations to the latest possible point in time. This is useful for resolving 
 dependencies, calculation complexity reduction, increased modularity and infinite 
 data structures.",NA
8.2 ,NA,NA
Also Known As,"Stream [Ritchie84, Abelson & Sussman87, Edwards95], Pipes and Filters Architec-
 ture [Meunier95b, Buschmann et al.96], Pipeline [Posnak et al.96, Shaw96].",NA
8.3 ,NA,NA
Motivation,"Typically, the specification of a solution to a problem inevitably also makes a state-
 ment about the order of solution steps to be applied
 1
 . In this context, it does not 
 matter whether order is expressed as a sequence of events in time or as a chain of 
 data dependencies. The crucial point is that we welcome to be able to order sub-
 solutions in order to decompose problems into easier sub-problems. But sometimes 
 overstating the order of events yields complex systems.",NA
8.3.1 ,NA,NA
Problem,"Listening to music at home usually amounts to the problem of converting a pit 
 structure on a flat disc to an alternation in air pressure. In this example we 
 concen-trate on the part to be accomplished by the compact disc player (see figure 
 8.1 on the next page).
  
 We may think of the surface-reading-unit (SRU) as some electronic circuit that 
 controls the spinning speed of the disc, tracks the laser, and produces a digital bit
  
 1
 Note, however, that especially the logical paradigm allows being very unspecific about order.",NA
8.3.2 ,NA,NA
Solution,"Instead of handshaking the bits through a “push and request” procedure call pro-
 tocol, we better recognize the data flow architecture of the schematic compact disc 
 player. We should observe that a unit either produces (SRU), transforms (EC and 
 DF), or consumes (DAC) a stream of bits (see figure 8.2).
  
 Surface
  
 Error
  
 Digital
  
 Digital/
  
 Reading
  
 Analog
  
 Correction
  
 Filter
  
 Unit
  
 Converter
  
 Figure 8.2: Plug-in modules in a bitstream architecture
  
 With this view, it is most natural to let the DAC request further bits from its 
 preceding unit whenever its (self managed) buffer runs out of data. Driven by the 
 demand of the DAC each unit generates bits, possibly by pulling further data 
 from its preceding unit. In this scenario the modules are much less coupled since 
 buffer management is solely accomplished by the DAC itself. The interface 
 between the",NA
8.4 ,NA,NA
Applicability,"•
  Unknown demands.
  Often, the amount of certain data needed is not known 
 before that data is actually accessed. We might, for instance, repeatedly ac-
 cess fibonacci numbers in order to achieve an evenly workload distribution 
 for the parallel evaluation of polynomials. An upper bound is difficult to es-
 timate and we do not want to waste time and space for providing fibonacci 
 numbers that will never be accessed. The solution is to generate them lazily, 
 i.e., calculate them on demand. Note that although we sometimes might be 
 in a position to provide enough space for some data to be calculated in 
 advance, nevertheless infinite data (like fibonacci numbers) would force us 
 to fix an artificial upper bound.
  
 •
  Up-front declaration.
  The freedom of not needing to care about unnecessary 
 evaluations allows the adoption of a declarative style of programming. It is 
 possible to decompose a routine’s arguments or make recursive calls to parts 
 of them without concern whether the results will be needed [Jeschke95]. This 
 style is clearer if the routine needs to multiply access the results. Otherwise, 
 the repeated decomposition code might even require a distributed cache 
 man-agement, if it is not known which branch — of several — will cause the 
 first evaluation and calculations should be made at most once.
  
 •
  Dependency specification.
  Execution of lazy functions follows dynamic data 
 dependencies. As a result, even statically circular definitions can be 
 specified, without regard for execution order. For instance, a machine code 
 generator needs to determine the destination address for a forward jump. At",NA
8.5,NA,NA
Structure,"Client
  
 request : LazyObject 
  
 access : T
  
 Suspension 
  
 Value
  
 request : LazyObject 
  
 access : T
  
 request : LazyObject 
  
 access : T
  
 Figure 8.4: Structure diagram",NA
8.6 ,NA,NA
Participants,"•
  Client
  
  
 –
  issues a request to
  LazyObject
  (e.g., calling
  tail
  on a stream of 
 hamming 
  
 numbers).
  
 –
  accesses
  Suspension
  and later
  Value
  for a value (e.g., calling
  item
  on a 
 stream of hamming numbers).
  
 •
  LazyObject
  
 –
  provides an interface for requests and 
 accesses.
 –
  creates and returns a
  Suspension
  on 
 request.
  
 •
  Suspension
  (e.g., representing a stream’s tail)
 –
  
 implements
  LazyObject
 ’s interface.
  
 –
  represents a suspended calculation.
  
 –
  calculates a result when accessed.
  
 –
  creates a
  Value
  for further accesses.
  
 •
  Value
  (e.g., a cached hamming number)
  
  
 –
  implements
  LazyObject
 ’s interface.
  
 –
  caches the result calculated by
  Suspension
 .",NA
8.7 ,NA,NA
Collaborations,"•
  A client issues a request to a lazy object.
  
 •
  The lazy object creates a suspension and returns it to the client.
  
 •
  Some time later the client accesses the suspension.
  
 •
  The suspension calculates a result (possibly accessing the lazy object), returns 
 it to the client, and creates a value for future accesses
 2
 .
  
 •
  Future client accesses are made to the value that caches the calculation result.",NA
8.8 ,NA,NA
Consequences,"•
  Initialization.
  The best place for initialization values (e.g., return 1 as the ra-
 dius of a fresh circle) is the data abstraction they belong to [Auer94]. 
  
 A
  
 getter-routine can calculate an initial value whenever it is called the first time.
  
 Hence, initial values will not be calculated unless they are actually needed.
  
 Also, setter-routines may provide space for received arguments, only when
  
 actually asked to do so.",NA
8.9 ,NA,NA
Implementation,"On a first reading the reader might want to skip this section. After examination of 
 the sample code in section 8.10 the following implementations details are easier to 
 deal with.
  
 •
  Stream functions.
  It is very interesting to note that the
  value
 ,
  step
 , and
  eos
  in-
 terface of
  ContFunc
  (see section 8.10 on page 130) is justified by a categori-
 cal interpretation of streams as coinductive types [Jacobs & Rutten97]. Here, 
 streams over a type
  A
  are modeled as a state of type
  B
  (state of a
  ContFunc",NA
8.10 Sample Code,"We will now consider the implementation of lazy streams in detail. Again, note 
 that a stream is just an example for Lazy Object and that there are many other 
 applications for Lazy Object besides streams (see section 8.4 on page 119).
  
 The most important issue to establish upfront is the stream interface
 9
 to clients:
  
 deferred class Stream[G]
  
 feature 
  
 item : G is deferred end 
  
 tail : Stream[G] is deferred end 
 last : Boolean is deferred end
  
 feature {Stream} 
  
 isNotSuspended : Boolean is deferred end 
 toValue : StreamVal[G] is deferred end
  
 feature {StreamTail} 
  
 forcedTail : Stream[G] is deferred end 
 end
  
 Class
  Stream
  plays the role of
  LazyObject
  (see figure 8.4 
 on page 121) with the exception that it defers creation of 
 sus-pensions to its heirs. For now, we do not care about the 
 non-public features of
  
 Stream
  
 besides noting that
  
 toValue
  al-lows converting a stream element, which no 
 longer needs to be suspended, into a value (see class
  Value
  
 in figure 8.4 on page 121).
  
 We start simple by trying to establish a stream of natu-
 ral numbers. In this case our
  Suspension
  (see figure 8.4 on 
 page 121) will be a function (represented by class
  NatFunc
 ) 
 that yields the next natural number. Heading for a general 
 scheme we introduce an indirection with
  StreamFunc
  that 
 uses any
  ContFunc
  to generate a stream element (see fig-
 ure 8.7) and make
  NatFunc
  an heir to
  ContFunc
  (see figure 
 8.8 on the facing page).
  
 StreamFunc
  
 NatFunc
  
 arg = 1
  
 Figure 8.7: Natural
  
 number stream
  
 9
 For brevity I omitted an
  out
  feature that is useful to display streams to the user.",NA
8.11 Known Uses,"The U
 NIX
  operating system owes much of its flexibility to stream based
  
 commands that can be interconnected via pipes [Ritchie84]. 
  
 The com-
  
 mon format 
  
 of 
  
 line 
  
 separated 
  
 A
 SCII 
  
 characters 
  
 allows 
  
 the 
  
 free 
  
 compo-
  
 sition of services. 
  
 For instance, 
  
 to uncompress a bitmap, 
  
 convert it to
  
 P
 OST
 S
 CRIPT
 10
 , and to finally view it, one can build a pipe of four commands:
  
 cat bitmap.pbm.gz | unzip | pbmtolps | ghostview -
 .
  
 S
 ATHER
  [Omohundro94] supports a restricted form of coroutine called an
  
 “iter” [Murer et al.93b]. Iters yield elements to be used in iterations. Their pri-",NA
8.12 Related Patterns,NA,NA
8.12.1 ,NA,NA
Categorization,"Iterator:
  The interface of
  Iterator
  from the Iterator pattern is very similar to that of
  
 Stream
 . Both internal iterators and streams allow separating the iteration 
 loop and collection navigation from the iteration body. Streams, however, 
 do not provide a
  first
  method. As opposed to external iterators, streams are 
 not stateful objects. To re-iterate a stream, one has to keep a copy of the 
 stream’s start.
  
 Stream, Pipeline,
  
 Pipes and Filters:
  are architectural views on the stream concept which can 
  
 be 
  
 provided 
  
 by 
  
 lazy 
  
 evaluation 
  
 [Ritchie84, 
  
 Edwards95, 
  
 Meunier95b, 
  
 Buschmann et al.96, Posnak et al.96, Shaw96].
  
 Singleton:
  A Singleton is a Lazy Object since it is created at most once. If created at 
 all, every accessor will be given the same instance, which exactly 
 corresponds to call-by-need semantics.
  
 Co-Routine:
  A stream can be regarded as a co-routine. Resuming happens through 
 tail
  calls and one can think of a series of subsequent continuation 
 functions as co-routine incarnations distributed over stream element 
 functions. The co-routining behavior of lazy objects is vital for their ability to 
 avoid large in-termediate structures. Calculation suspension allow building 
 a pipeline that processes elements one by one rather then causing whole 
 transient structures to be constructed in between.",NA
8.12.2 ,NA,NA
Collaboration,"Function Object:
  Function Object can be used for lazy evaluation as well. A func-
 tion object represents a suspended calculation until requested to evaluate its 
 result.
  
 Streams are connected to function objects through class
  Map
 . It allows apply-
 ing standard function objects to streams. Ergo, it is easy to obtain a stream 
 function, if a corresponding a single element function already exists.
  
 Translator:
  The result of a translation obtained using Translator can be a stream.
  
 Transfold:
  Transfold processes lazy streams, that function as a
  lingua franca
  between 
  
 collections and iterators.
  
 Serializer:
  Serializer could be used to flatten data in order to transfer it via a stan-
 dard stream channel. Instead of using Serializer on may alternatively simply 
 use a specialized object stream.",NA
8.12.3 ,NA,NA
Implementation,"Memoization:
  Being a technique rather than a pattern, memoization nevertheless is 
 used by Lazy Object in order to perform calculations only once. Further 
 requests are served by accessing a cache [Keller & Sleep86].
  
 Value Object:
  A lazy object may use Value Object (see chapter 9 on page 149) to 
 produce immutable cached values of calculated results, e.g., stream elements.
  
 Command, 
  
 Function Object:
  StreamTail
  can be regarded as a function object with one argument 
  
 (
 suspension
 ) and three entry points with no further arguments. Its task is to 
  
 separate the
  creation
  of an operation and its actual
  invocation
  in time, very 
  
 similar to the Command pattern.
  
 Factory Method:
  If clients defer the creation of stream functions to continuation 
 functions 
 — 
 that 
 know 
 whether 
 to 
 choose 
 a
  
 StreamFunc
  
 or
  
 StreamFuncOpt
 — the corresponding method is a Factory Method [Gamma 
 et al.94].
  
 Void Value:
  The behavior of a stream’s end may be implemented with Void Value 
  
 (see chapter 11 on page 191).",NA
9 ,NA,NA
Value Object,"Even in change, it stays the same.
  
 – Heraklit",NA
9.1 ,NA,NA
Intent,"Use immutable objects with generator operations for protection against side-effects 
 and aliasing.",NA
9.2 ,NA,NA
Also Known As,Immutable Object [Siegel95].,NA
9.3 ,NA,NA
Motivation,"Mutable objects are the bedrock of object-oriented design and programming. The 
 ability to dynamically instantiate objects, change their value, retrieve their state, 
 and share them among multiple users for communication allows the development 
 of efficient software with a close relationship to real word models (see chapter 2 
 on page 29).
  
 Yet, another bedrock of object-orientation is encapsulation (see section 2.2.2 on 
 page 32). Encapsulated objects provide us with the peace of mind that every 
 change to an object is controlled by the object itself. Obviously, an inconsistent or 
 unex-pected change of object state can be caused by the object itself only. 
 Unfortunately, this is not quite true.",NA
9.3.1 ,NA,NA
Problem,"Surprisingly many object-oriented languages do not provide complex numbers ei-
 ther as primitive types or as a library component. Luckily, we can extend the 
 exist-ing library and provide a complex number class as if it has been part of the 
 stan-dard
 1
 . The straightforward approach is to write a class with a set of 
 operations,
  
 1
 As always the devil lurks in the details. See Matthew Austern’s account on the difficulties of 
 introducing a
  Complex
  class with E
 IFFEL
 .",NA
9.3.2 ,NA,NA
Solution,"Complex numbers are values, i.e., they are timeless abstractions and therefore un-
 changeable [MacLennan82]. They deserve to be implemented with value seman-
 tics. Instead of modifying the receiver of operation
  add
 , the receiver should be left",NA
9.4 ,NA,NA
Applicability,"•
  Modeling.
  When clients are interested in values only and never care about 
 identity, use Value Object for the object in question. Types representing val-
 ues, i.e., abstractions with no identity for which creation, change, and shar-
 ing have no meaning, should be implemented with value semantics. Besides 
 numbers, strings are a typical example. Sharing of string contents easily oc-
 curs with a straightforward implementation but is certainly unexpected
 4
 .
  
 •
  Aliasing protection.
  When a type should be immune to aliasing effects, replace 
 its 
  
 mutator 
  
 operations 
  
 with generator 
  
 operations. 
  
 For 
   
 in-
  
 stance, a matrix multiplication using destructive updating of the receiver 
  
 works fine until someone calls: 
  
  
 aMatrix.mult(aMatrix);
 . 
  
  
  
 This 
  
 may destroy parts of the matrix that are still needed for input. 
  
 With 
  
 aMatrix:=aMatrix.mult(aMatrix);
  there is no such 
 danger since 
  
 target and source matrix are different.
  
 •
  Small objects.
  Use Value Object preferably for small data structures. The 
 larger the structure, the greater the overhead through duplication of 
 unchanged data when creating a new instance in response to an operation. 
 Using Value Object for larger structures can still be reasonable to avoid 
 aliasing and does not necessarily have to be inefficient (see 9.9 on page 158,
  
 Copy on demand
 ), but is most appropriate for objects with a small memory 
 footprint.
  
 •
  Efficient value passing.
  Creating new instances when changes occur is appro-
 priate when the frequency of passing and assigning values is higher than 
  
 their update frequency. 
  
 If updating values is the predominant operation 
  
 then consider to implement a copy-on-passing scheme (see 9.9 on page 158, 
  
 When to copy values
 ) or use a language’s built-in support for value types (e.g., 
  
 expanded types in E
 IFFEL
  or non-pointer variables in C
 ++
 ).",NA
9.5 ,NA,NA
Structure,"Client 
  
 ValueObject
  
 make 
  
 accessors 
  
 generators
  
 Figure 9.2: Structure diagram",NA
9.6,NA,NA
Participants,"•
  Client
  
  
 –
  calls an accessor or generator operation of
  ValueObject
 .
  
 •
  ValueObject
  
  
 –
  returns a value on access.
  
 –
  creates and returns a new object when asked for a modified version of 
 itself.",NA
9.7,NA,NA
Collaborations,"aValue
  
 aValue*
  
 aClient
  
 generator
  
 Figure 9.3: Interaction diagram
  
 •
  A client performs an operation on a value object.
  
 •
  The value object creates a new instance containing the information according 
 to the requested operation.
  
 •
  The value object returns the freshly created instance.",NA
9.8 ,NA,NA
Consequences,"•
  Simplicity.
  Code using values can be much simpler than code using objects, 
 since there is no need to be cautious about side-effects and aliasing. All ad-
 vantages of dealing with immutable values apply (e.g., validation of correct-
 ness, understandability, transformability (see section 1.3.1 on page 17)). 
 Value objects do not offer mutator operations, but use generator operations 
 to pro-vide new instances. Note that object encapsulation is still preserved. 
 Any changes to the object are still under the regime of the object itself.",NA
9.9 ,NA,NA
Implementation,"•
  When to copy values.
  Value Object creates new values when values are gener-
 ated. Another choice would have been to create copies whenever the possi-
 bility of aliasing is created, i.e., whenever a new access thread is created by 
 parameter passing or assignment.
  
 In figure 9.5 on the next page an arrow pointing downwards denotes the cre-
 ation of a new value by a generator operation. Indexes and shading indi-cate 
 the generation of a value, i.e., the count of copy operations in its history. 
 Note that the situation in figure 9.5 on the facing page is in favor of copy-on-
 passing rather than copy-on-change, but with less updates and more passing 
 or assignments the score is reversed.
  
 Most programming languages implement their basic types with copy-on-
 passing. And in most languages we have no choice but implement Value Ob-",NA
copy on change,NA,NA
copy on passing,NA,NA
copy on demand,"Figure 9.5: Copy strategies
  
 •
  Value Object versus language support.
  Some languages offer support for the ad-
 dition of types with non-reference semantics. Typically, however, another 
 motivation was the driving factor, for instance, the ability to specify ob-ject 
 containment rather than object referencing [Madsen et al.93, Meyer92]. 
 Consequently, value semantics is often, e.g., in E
 IFFEL
 , not sufficiently sup-
 ported [Kent & Howse96]: Expanded types, for instance,
  
 •
  do not allow polymorphism.
  
 •
  cannot be specified with deferred classes.
 •
  
 make shallow copies on assignment only.
  
 •
  Abstract state.
  Value objects must preserve equality only modulo their respec-
 tive equality operation. For instance, fraction numbers could decide to nor-
 malize their representation after addition but not after multiplication. Hence,
  
 15 
  
 6
 +
  15 6
 =
  15
  
 while 
  
  
 15 
  
  
  
 6
 ♦
 2
  =
  30 6
 ,",NA
9.10 Known Uses,"It is needless to emphasize that functional programming languages treat their 
 com-putational “objects” as values. Many object-oriented languages split their 
 types into basic types (with value semantics) and reference types. Even in 
 S
 MALLTALK
 , where everything is an object, numbers are
  correctly
  treated 
 differently, i.e., they do not provide mutator but generator operations.
  
 Ian Poole et al. use a combination of Lazy Object and Value Object, i.e., im-
 mutable lazy values to represent complex computation networks [Poole et al.98]. 
 The benefits of their Lazy/RT
 9
 pattern (e.g., modular reasoning, parallel evaluation",NA
9.11 Related Patterns,NA,NA
9.11.1 ,NA,NA
Categorization,"Constant Object:
  A value object interface to a mutable object fulfills the same pur-
 pose as an immutable interface (see section 9.3 on page 149). In addition to 
 accessor functions, a value object interface, furthermore, provides generator 
 operations, which can be used to create new values without altering the 
 orig-inal.
  
 Identity Object,
  
 Singular Object:
  This pattern emerges when Value Object or Constant Object is 
 implemented with unique value instances as described in section 9.9 on 
 page 158. For instance, the datatype
  Symbol
  in S
 MALLTALK
  is implemented 
 as an Identity Object.
  
 Unshareable Object:
  Another way to prevent aliasing it to allow single references to 
 an object only [Minsky95, Minsky96]. While values can be motivated from a 
 modeling point of view, it is unclear what the real world equivalent of an 
 unshareable reference is. Unshareable references are not copied but moved, 
 i.e., the source of an assignment statement will be
  nil
  afterwards. A useful 
 analogy might be a physical object that can only be moved but not shared or 
 a unique item that is allowed to occur only once, e.g., a token in a network.",NA
9.11.2 ,NA,NA
Collaboration,"Function Object:
  If function objects accept arguments through a value object inter-
 face, they do not need to copy arguments in order to be safe from future 
 changes. This, however, does not hold if there is also a mutating interface 
 available (see figure 9.4 on page 158) through which arguments could be 
 cor-rupted.
  
 Strategy,
  
 Function Object:
  The equality operation can be parameterized with a function ob-
 ject predicate. Depending on the application, several “views” on equality 
 could be implemented (e.g., books which differ in publishers only could be 
 considered equal for a certain purpose).
  
 Void Value:
  Default values (e.g.,
  0
 +
 0
 i
  for complex numbers) can be provided with 
  
 Void Value.
  
 Transfold:
  Due to the absence of aliasing, it is less error prone to generate new val-
 ues from a collection of values than dealing with shared objects. A value 
 aggregate can be iterated without concerns for changes occurring during 
 iter-ation.",NA
9.11.3 ,NA,NA
Implementation,"Lazy Object:
  A value object may return a lazy result. Especially, if the calculation 
 of a new value is costly and frequently only parts of the result are actually 
 used then it is worthwhile to defer the calculation until the result is accessed.
  
 Transfold:
  A value object may implement equality by using Transfold to compare 
  
 reference type collections in subcomponents.
  
 Translator:
  Extremely complex values may implement sophisticated operations —
 such as providing a certain view or an interpretation of a value — by
  
 translat-ing
  their subcomponents.",NA
10 ,NA,NA
Transfold,"I can’t understand why a person will take a year or two to write a novel
  
 when he can easily buy one for a few dollars.
  
 – Fred Allen",NA
10.1 Intent,"Process the elements of one or more aggregate objects without exposing their rep-
 resentation and without writing explicit loops.",NA
10.2 Motivation,"Collections play a very important role in software design. They allow us 
 regarding a bunch of objects as a single abstraction. Clients pass and store 
 collections as sin-gle entities and defer the responsibility of reacting to a message 
 to the collections. A single request to a collection may mean to forward the 
 request to all collection members (e.g., most
  Composite
  services in the Composite 
 pattern), find a member best suited to deal with the request (e.g., Chain of 
 Responsibility pattern), extract one member with particular properties (e.g., a
  
 detect
  method), etc. Hence, with the exception of a few
  Dispenser
  types like
  Stack
  
 and
  Queue
 , that restrict access to one end, it is common to access collection 
 members one by one until a condition is met or full coverage has been achieved. 
 In other words, a frequent operation on collections is iteration.",NA
10.2.1 ,NA,NA
Problem,"It is clearly not an option to let clients iterate over collections — or more generally, 
 aggregates — using knowledge about an aggregate’s internals. In
  
 ...
  
 list : List[Integer]
  
 l : Link[Integer];
  
 do
  
 from l:=list.first;
  
 until l=void",NA
10.2.2 ,NA,NA
Solution,"An elegant way to resolve the forces is to
  
 •
  provide a way to flatten aggregates to a stream of data and
  
 •
  iterate passively over (multiple) streams.",NA
10.3 Applicability ,"Transfold
  
 •
  Abstraction.
  Transfold allows accessing the elements of a collection or the 
 components of an aggregate without ex-
  
  
  
 posing its internal representation.
  
 •
  Concentration.
  Use Transfold if you want to release clients from the duty of 
 providing a control structure. 
  
  
 Transfold
  
 •
  Multiple traversals.
  When a structure is to be iterated by multiple clients 
 in alternation, Transfold allows sharing the 
  
  
 structure’s stream for independent consumption by multi-
  
 Data
  
 ple clients. 
  
 Aggregate",NA
10.4,NA,NA
Structure,"Aggregate
  
 Client
  
 asStream : Stream
  
 Function
  
 Stream
  
 ConcreteFunction
  
 Transfold 
  
 ConcreteStream
  
 Figure 10.10: Structure diagram",NA
10.5,NA,NA
Participants,"•
  Client
  
  
 –
  requests an
  Aggregate
  to provide a
  Stream
  of itself.
  
 –
  passes two
  Function
 s and a value as parameters to
  Transfold
 .
  
 •
  Aggregate
  
 –
  provides a
  ConcreteStream
 , containing a flattened version of itself.
 –
  
 uses a lazy
  Function
  to produce a
  ConcreteStream
 .
  
 •
  Function
  
  
 –
  provides an application interface for all functions including the stream 
  
 building function, the
  Transfold
  parameters, and
  Transfold
 .
  
 •
  Stream
  
 –
  provides an interface to access any concrete 
 streams.
 –
  implements a lazy, infinite list semantics.
  
 •
  Transfold
  
  
 –
  takes two
  Function
 s and a value as processing parameters.
  
 –
  transforms its input (a
  Stream
  of
  Stream
 s) to an arbitrary result type.",NA
10.6 Collaborations,"•
  A client requests an aggregate to flatten itself to a stream.
  
 •
  The aggregate’s
  asStream
  method and a lazy function mutually call each other 
 to explore the aggregate lazily, while producing a stream.
  
 •
  The client uses or creates two function objects, which it passes — along with 
 an initial value — to a transfold object.",NA
10.7 Consequences,"•
  Inverted control.
  Clients do not repeatedly call iterator operations, but a trans-
 fold repeatedly calls functions supplied by the client. Therefore, a client does 
 not have to provide a control structure to drive the iteration (see section 10.8 
 on page 180 for a comparison of
  transfold
  implemented with external and in-
 ternal iteration). For the reason that there is only one iteration loop, used by 
 all clients, loop-related errors are much easier to avoid and to discover. If the 
 Mariner-loop (see figure 10.1 on page 166) had been used by another client, 
 tests of that client might have revealed the problem. More time can be spent 
 on the validation of a single loop
 11
 and any errors are removed for all clients.
  
 •
  Traversal alternatives.
  Since iteration (stream consumption) is external to 
 structures it is easy to support a variety of traversal strategies and to dynam-
 ically dispatch on these. The stream consuming process (a transfold object) is 
 in command of the exploration order, because the stream contains iteration 
 continuations, which may be invoked in any order (see bullet
  Separation
 ).
  
 •
  Multiple traversals.
  Each transfold manages its own stream consumption 
 progress and, therefore, enables multiple pending iterations on a shared struc-",NA
10.8 Implementation,"The remarkable separation of iteration and demand driven structure exploration 
 re-lies on lazy intermediate stream semantics. It is, therefore, vital to use lazy 
 streams (see chapter 8 on page 115) and both lazy generation and consumption 
 functions.
  
 •
  Stream consumption.
  Whenever we referred to
  fold
 , we meant
  foldr
  [Bird86] and 
 not its counterpart
  foldl
 . The
  foldr
  function —
  
 foldr f a
  [ ] = 
  
 a
  
 foldr f a
  (
 x
  :
  xs
 ) = 
 f x
  (
 foldr f a xs
 ) 
 (10.9)
  
 — has the nice property that the passed function
  f
  controls the recursive call 
 of
  foldr
 , i.e., determines the extent of structure exploration. An implementa-
 tion aiming at true laziness must, consequently, wrap the recursive call (the 
 expression in parentheses) into a lazy object, e.g., a function object with a 
 dummy parameter. For the reason that
  fold
  may produce any result type 
 from a stream, it is unfortunately not possible to design it as a stream pipe 
 like
  map
 . This underlines the importance of language supported laziness, 
 which would make the difference between strict and non-strict values 
 transparent to clients (see section 14.6 on page 246).
  
 •
  Stream creation.
  Streams may be created eagerly but typically the structure 
 will return a stream containing iteration continuations. In other words, the",NA
Sample Code,"10
  
 Transfold",NA
10.9,"To calculate the inner product of a matrix (see figure 10.7 on page 172) we code the 
 inner product product operation (see definition 10.8 on page 172) in E
 IFFEL
  as:
  
 ...
  
 local 
  
 ip : Function [Stream [Stream [Integer]], Double] 
 ...
  
 ip:=transfold @ plus @ 0.00 @ (fold @ times @ 1.0); 
 ...
  
 We use the same type progression (integer, real, double) for the intermediate 
 results as in figure 10.7 on page 172. Hence,
  times
  and
  plus
  must promote 
 from integer to real and real to double respectively, but — apart from that — are 
 standard func-tion objects. In case of a fully lazy treatment — which we omit here 
 for the sake of clarity —
  times
  and
  plus
  must respect the laziness of their 
 second argument.
  
 The new function
  ip
  can be applied to a matrix, so presuming
  
 vec1, vec2, vec3 : Stream [Integer]; 
  
 vecs 
  
 : Stream [Stream [Integer]]; 
 ...
  
 vec1:=cons @ 8 @ (cons @ 1 @ fromconst 
 (6)); vec2:=cons @ 3 @ (cons @ 5 @ 
 fromconst (7)); vec3:=cons @ 4 @ (cons @ 9 
 @ fromconst (2));
  
 vecs:=conss @ vec1 @ (conss @ 
  
  
 vec2 @ (conss @ vec3 @ void));
  
 — note that
  cons
  produces an integer stream, while
  conss
  produces a stream of 
 an integer streams — the examples
  
 io.putdouble (ip @ vecs);
  
 io.putdouble (ip @ vecs.tail);
  
 will produce the output as given in figure 10.12.
  
 225
  = IP
  @
  vecs
 8
  
 3
  
 4 
  
  
 1
  
 5",NA
10.10 Known Uses,"Although C
 ++
 usually promotes external iteration, there is an example of an in-
 ternal iterator (
 foreach
 ) interface in the Borland C
 ++
 libraries [Borland94]. Since it 
 builds on passing function pointers, it must use an extra, unsafe
  void
  type for 
 passing parameters, though.
  
 Folding is commonplace in functional programming [Bird & Wadler88], but 
 also used in S
 CHEME
  [Abelson & Sussman87] and available in the S
 MALLTALK
  li-
 brary [LaLonde94]. It is not a frequently used operation in S
 MALLTALK
  [Smith95], 
 which can be attributed to the peculiar name (
 inject: into:
 ), but also to the unfamil-
 iarity of most S
 MALLTALK
  users with the nature of that operation. The S
 MALLTALK 
 collection library even contains a
  with: do:
  method, allowing to iterate two struc-
 tures in parallel, which represents a special case of transfolding. S
 MALLTALK
  also 
 uses streams to efficiently implement concatenation of collections. The caching ef-
 fect of streams avoids to repeatedly generate the prefix of sequenced 
 concatenations like
  coll1 + coll2 + coll3 + coll4 + ...
 .
  
 A
 PL
  [Harms & Zabinski77] is well-known for its high-level operations on vec-
 tors, matrices, and structures of even higher dimension. Three of its four primitive 
 extension operators
 18
 ,
  reduction
  (
 f/
 A
 ),
  scan
  (
 f\
 A
 ), and
  innerProduct
  (
 A
 f.g
 B
 ), can 
 directly be expressed with
  transfold
 . The fourth,
  outerProduct
  (
 A
 ♦
 .f
 B
 ), is express-
 ible with a combination of
  transfold
  and
  map
 . The matrix multiplication example 
 from section 10.9 on page 182, builds an outer product of the matrices’ rows and 
 columns, and then reduces it with an inner product.
  
 16
 number
  is a variable declared to be of the generic matrix element type.
  
 17
 Although an escape was possible, one would wish that simply
  0
  has had sufficed. 
 18
 Extend an operation to a collection.",NA
Related Patterns,"10
  
 Transfold",NA
10.11,NA,NA
10.11.1,NA,NA
Categorization,"Function Object:
  Transfold’s interface to clients is that of a Function Object.
  
 Iterator:
  Transfold realizes internal iteration, whereas the Iterator pattern uses ex-
 ternal iteration [Gamma et al.94]. There is also an internal variant of the Iter-
 ator pattern [Gamma et al.94], but it uses inheritance for iterator and action 
 combination and exhibits the normal one-structure-iteration inflexibility.
  
 Bridge:
  The stream between structure and iterator is like a Bridge [Gamma et 
 al.94], separating a consumption interface from the implementation of a 
 structure (including the exploration implementation).
  
 Serializer:
  The use of an intermediate stream resulting from structure exploration 
 is akin to the Serializer pattern [Riehle et al.97], whose purpose is to flatten 
 structures for persistence.",NA
10.11.2 ,NA,NA
Collaboration,"Lazy Object:
  Transfold is very well suited to transform one lazy structure into an-
  
 other.
  
 Value Object,
  
 Composite:
  Iterators are often applied to recursive (possibly value) structures like 
 Composite
 . Furthermore, Composite [Gamma et al.94] may be implemented 
 with Transfold to enumerate its children.
  
 Translator,
  
 Visitor:
  Structure consuming patterns may defer their structure exploration to 
  
 Transfold.
  
 Chain of Responsibility:
  An event may be transfolded over a collection of handlers 
  
 to find the most appropriate handler.
  
 Observer:
  An Observer [Gamma et al.94] may use Transfold to iterate over its 
  
 dependents-collection.
  
 Keyword Parameter:
  Transfold may use the keyword parameter variant of Function 
  
 Object (see section 7.10 on page 107) to ease supplement of its parameters.",NA
10.11.3 ,NA,NA
Implementation,"Lazy Object:
  Transfold uses a lazy stream as well as lazy generation and consump-
  
 tion functions.",NA
11 ,NA,NA
Void Value,"I’m not completely worthless! I can still serve as a bad example.
  
 – Mark Twain",NA
11.1 Intent,"Raise Nil to a first-class value. This allows to treat void and non-void data uni-
 formly, is a way to provide default behavior, facilitates the definition of recursive 
 methods, and enables to deal with error situations more gracefully.",NA
11.2 Motivation,"Classes are often regarded as representing abstract data types (ADTs). Typically, 
 the
  empty
  constructor of an ADT is translated to Nil. For instance, an empty
  Bina-
 ryTree
  is represented by Nil and a tree leaf is represented by setting both child at-
 tributes to Nil. It is tempting to identify
  empty
  constructors with the special 
 pointer content Nil, since there are some reasons in favor of it:
  
 •
  Operations are often partial due to
  empty
 , well accounted for by Nil.
  
 •
  Nil does not waste any storage.
  
 •
  Most languages initialize references to Nil, i.e., provide the empty case by 
 default.
  
 It is, for instance, suggested to represent an unknown book author with a void 
 reference [Meyer97].",NA
11.2.1 ,NA,NA
Problem,"However, such a design decision puts a great burden on the clients of the ADT. 
 Before the client can apply operations on a tree, it must check whether it is void or 
 not. Otherwise, invoking a method through a Nil reference would produce a 
 runtime-exception or even -error. Typical (E
 IFFEL
 ) code
 1
 is depicted at the upper 
 part of figure 11.1 on the next page.
  
 1
 All code examples in this chapter have been extracted from a commercially available library; 
 identifiers have been adapted for presentation, though.",NA
11.2.2 ,NA,NA
Solution,"The code in the upper part of figure 11.1 can be replaced with the code at the 
 lower part of figure 11.1, if we abandon Nil (Void) and replace it with an extra 
 class (
 VoidTree
 ) (see figure 11.2).
  
 Client 
  
 Tree
  
 has(v : Any), out, ...
  
 VoidTree 
  
 MutableTree
  
 has(v : Any) = false 
  
 out 
  
 ...
  
 has(v : Any) ... 
  
 out 
  
 ...
  
 Figure 11.2: Empty tree as void value
  
 Now we can define
  VoidTree
  to return
  false
  on a
  has
  message and to produce no 
 output on
  out
 . In fact, we applied the general pattern to replace case analysis 
 (testing for Nil) with dynamic binding (provision of an extra type constructor
  Void-
 Value
 ). As a result, many such
  if
  statements as above can be removed from client 
 code.
  
 An important special case of robust behavior is a Null iterator (also see Itera-
 tor [Gamma et al.94]). Instead of external iteration (upper part of figure 11.3 on 
 the next page) one should use internal iteration, e.g., and let void sets do nothing 
 on iteration (lower part of figure 11.3 on the facing page).
  
 Answering queries to void values with default values again allows replacing 
 the upper part of figure 11.4 on the next page with its lower part. This obviously 
 improves the treatment of trees from a client’s perspective, but there is more to 
 gain. Let us count the number of nodes in a tree.",NA
11.3 Applicability,"•
  Uniformity.
  Clients benefit from Void Value by uniformly treating void and 
 non-void data. Inquiring information and invoking behavior can be done 
 independently of the data’s void state, without the eventual need for 
 creating initial instances first.
  
 •
  Default behavior.
  Void values allow the specification of default behavior. In 
 contrast to Nil, a void value may specify results and behavior for any of its 
 interface methods. This is useful for providing reasonable behavior for 
 unini-tialized data and void result values.
  
 •
  Error handling.
  A value [Cunningham94] when most of the code should not 
 deal with er-
  
  
 void 
  
 value 
  
 can 
  
 be 
  
 used 
  
 just 
  
 like 
  
 an 
  
 exceptional
  
 ror situations. An exceptional value may either behave properly indicating 
 an error situation (e.g., by describing the error when by default displayed to 
 the user) or can be caught with error checking code by the application’s top-
 level code.",NA
11.,NA,NA
4,NA,NA
Structure,"Client
  
 is_void 
  
 operation
  
 VoidValue*
  
 VoidValue
  
 MutableObject
  
  
 is_void = true
  
 is_void = true
  
 is_void = false
  
 operation
  
 operation
  
 operation
  
 Figure 11.7: Void Value structure diagram",NA
11.5 Participants,"•
  Client
  
  
 –
  accesses both
  MutableObject
  and
  VoidValue
  through
  ObjectInterface
 .
  
 •
  ObjectInterface
  
  
 –
  provides the common interface for
  MutableObject
  and
  VoidValue
 .
  
 –
  
 may provide common abstract
 2
 behavior to
  MutableObject
  and
  Void-
  
 Value
 .
  
 •
  MutableObject
  
  
 –
  defines the standard object behavior.
  
 –
  introduces attributes for object state.
  
 –
  does not care for recursion base cases, default- and error behavior.
  
 •
  VoidValue
  
  
 –
  replaces Nil.
  
 –
  defines base cases for recursion, default- and error behavior.
  
 2
 Concrete methods do not rely on state (attributes), but on an abstract interface, only.",NA
11.6 Collaborations,"•
  Clients use the
  ObjectInterface
  to manipulate void, non-void, default, and er-
 ror objects. If
  MutableObject
  extends the interface of
  ObjectInterface
 , clients 
 may maintain specialized references to
  MutableObject
 , provided they are 
 guaranteed to receive objects of type
  MutableObject
  only.",NA
11.7 Consequences,"•
  Abstraction.
  Void Value abstracts from the implementation detail to represent 
 void or uninitialized data with Nil. Clients, therefore, are relieved of the 
 need to treat data with Nil differently from data which does not use Nil for 
 its representation.
  
 •
  Object-Orientation.
  Checking for Nil, i.e., case analysis, is replaced with dy-
 namic binding. This moves all case analysis from the program to a single 
 distinction between normal
  object
  and void
  value
 . Object behavior must be 
 defined at two places (object and void value). One the one hand, this allows 
 combining several void values with a single object. On the other hand, 
 chang-ing a single method might mean to change two class definitions 
 (object and value class).
  
 •
  Efficiency.
  It is more storage friendly to use void values, instead of full blown 
 objects that simply have the state of being empty or uninitialized, but carry 
 the overhead of unused attributes. Note, however, that void values are not 
 as easily turned into objects again without support for “Implicit creation” 
 (see sections 11.8 on the facing page & 14.7 on page 248).
  
 Depending on the implementation of dynamic binding a calling overhead 
 may be incurred, compared to
  if
  statements. Note, however, that the tradi-
 tional solution at the upper part of figure 11.5 on page 193, unnecessarily 
 checks
 arity
 depth
 −
 1
  
 call. 
  
 arity
 −
 1 
  
 nodes for being void, in addition to the following
  count
  
 •
  Immutability.
  If void values should not need more storage than Nil, they have 
 to be immutable. Mutable objects without attributes just claim code space for 
 their methods once, and possibly a little storage for housekeeping mecha-
 nisms such as RTTI (Run Time Type Identification) and object identification.
  
 •
  Separation.
  Program code relying on Void Value describes the standard case 
 only. In analogy to language support for exception handling, framework",NA
11.8 Implementation,"•
  Interface extension.
  In analogy to the Composite pattern [Gamma et al.94],
  Mu-
 tableObject
  might provide more operations than
  ObjectInterface
 , in order to 
 provide operations that make no sense to
  VoidValue
 . Each such extension, 
 however, will minimize the applicability of
  VoidValue
  to play the role of an 
 error value. Clients using the extended
  MutableObject
  interface, will not be 
 able to transparently work on void values too. In this context, it is better to 
 have the full interface at
  ObjectInterface
  and to define exception (e.g., error 
 reporting) methods in
  VoidValue
  respectively.
  
 •
  Storage requirements.
  Any behavior that goes to
  ObjectInterface
  should rely on 
 abstract state only, i.e. “Implement behavior with abstract state” [Auer94]. 
  
 Any attributes will incur a space penalty on
  VoidValue
 .
  
 •
  Value initialization.
  If representation of a complex constant (requiring creation 
 effort) is more important than preserving minimal space requirements, then 
 a void value may calculate the constant information (possibly taking 
 creation arguments) and store it in attributes. Accordingly,
  VoidValue
  is best",NA
11.9 Known Uses,"NoController
 ,
  NullDragMode
 ,
  NullInputManager
 ,
  NullScope
  are classes in the class 
 hierarchy of V
 ISUAL
 W
 ORKS
  S
 MALLTALK
  that are used as void values [Smith95].",NA
11.10 ,NA,NA
Related Patterns,NA,NA
11.10.1 ,NA,NA
Categorization,"Composite:
  Both Composite and Void Value provide uniform access to 
 components (value & object) of a structure (type). A
  VoidValue
  plays the role 
 of a spe-cial immutable component leaf. As a difference, Void Value does 
 not involve issues of child management.
  
 Value Object,
  
 Constant Object:
  A void value “is-a” value object, in that it does not offer mutator 
 operations. As value objects, void values lend themselves to be implemented 
 with Identity Object (see next bullet and section 9.11.1 on page 161).
  
 Singleton:
  A void value is a Singleton [Gamma et al.94], in that it can be shared by 
 all objects of a type. As it is immutable, there is no need to have multiple 
 instances.
  
 Flyweight:
  VoidValue
  can be regarded as a
  ConcreteFlyweight
 , as it holds intrinsic 
  
 data and is shared among all clients that use it.
  
 State:
  When used as described in
  Implicit creation
  at section 11.8 on page 197,
  Void-
 Value
  and
  MutableObject
  play the role of
  ConcreteStates
 , representing the 
 void and non-void states of data.",NA
11.10.2 ,NA,NA
Collaboration,"Lazy Object:
  Pattern Lazy Object (see chapter 8 on page 115) may be used to lazily 
  
 initialize void value components.
  
 Command:
  Void Command may stand for default or idle behavior.
  
 3
 S
 MALLTALK
 ’s method name to replace objects.",NA
11.10.3 ,NA,NA
Implementation,"Proxy:
  DefaultReference
  (see figure 11.8 on page 198) works as a Proxy since it 
  
 keeps a reference to an object whose interface it shares.
  
 Bridge:
  DefaultReference
  behaves like a bridge, in that it shields the clients from the 
  
 two “implementations”
  VoidValue
  and
  MutableObject
 .",NA
12 ,NA,NA
Translator,"The art of programming is the art of organizing complexity.
  
 – Edsger W. Dijkstra",NA
12.1 Intent,"Add semantics to structures with heterogeneous elements without changing the 
 elements. Separate interpretations from each other and use local interpretations 
 that allow for incremental reevaluation.",NA
12.2 Motivation,"Many operations on data structures can be viewed as homomorphisms, that is, as 
 structure preserving mappings from one domain into another. For instance, com-
 pilers typically map the abstract syntax of the source language into a specific ma-
 chine code language
 1
 . Other kinds of abstract interpretations (e.g., pretty-printing 
 and type-checking) should be expressed as homomorphisms between source and 
 target domain as well. The reason for this recommendation can be explained by 
 means of an equation that holds, if a homomorphic relationship between two struc-
 tures exists:
  
  
 
 (
 op
 (
 a
 ,
 b
 )) =
  op
 ′
 (
 
 (
 a
 )
 ,
 
 (
 b
 )) 
  
 (12.1)
  
 An interpretation
  
  on an operation
  op
  (from a source domain) with subcompo-
 nents
  a
  and
  b
  is defined as a new operation
  op
 ′
 (from a target domain) whose 
 subcomponents are determined by again applying
  
  to
  a
  and
  b
  [Wechler92]. An 
 instance of this general equation for a compiler is, e.g.:
  
 compile
 (
 assign
 (
 lhs
 ,
  rhs
 )) = 
  
 store
 (
 compile
 (
 lhs
 ),
  
 compile
 (
 rhs
 ))
  
 Note how in the above equations an interpretation is shifted down from operators 
 down to operands. Also, the right hand side of the equations has a structure that 
 allows us to account for incremental modifications to the source structure. In case 
 of changing the left-hand-side (
 lhs
 ) of
  assign
 , there is no need to rebuild the
  
 1
 Historically,
  
 homomorphisms
  
 are
  
 closely
  
 connected
  
 to
  
 syntax-directed
  
 transla-
  
  
 tions [Aho et al.86] and correspond to compositional definitions [Nielson & Nielson93].",NA
12.2.1 ,NA,NA
Problem,"Consider a programming environment that represents programs as abstract 
 syntax trees. It will need to perform various interpretations on the abstract syntax 
 tree like type-checking, code generation, and pretty-printing. Figure 12.1 depicts 
 two sample transformations.",NA
abstract Syntax Tree ,NA,NA
Pretty Print,"IfThen 
  
 ""IF""
  
 ""THEN""
  
 ""B""
  
 ""V""
  
 Assign
  
 ""W""
  
 ""B""
  
 ""END""
  
 "":=""
  
 ""W""",NA
Assembler Code,"""V""
  
 TEST
  
 BEQ <LABEL>
  
 <LABEL> NOP
  
 MOVE B(vars), R n
  
 MOVE R  , R n 
  
 m
  
 MOVE V(vars), R n 
  
 MOVE W(vars), R n
  
 Figure 12.1: Homomorphic translations of trees
  
 The result of a mapping (dashed arrows in figure 12.1) depends on the inter-
 pretation (e.g., compilation) and concrete node type (e.g., assign) involved. One 
 may put all various interpretations (type-check, pretty-print, etc.) into the node 
 interface in order to rely on dynamic binding. However, this is often not a good 
 idea:
  
 •
  It leads to a system that is hard to understand, maintain, and change.
 •
  Adding 
 a new interpretation means changing and recompiling all node types.",NA
12.2.2 ,NA,NA
Solution,"What we need is double-dispatch on both
  node-type
  and
  interpretation
 . 
 Fortunately, there are ways to emulate double-dispatch and its generalization 
 multi-dispatch, with a single-dispatch language. We opt for a solution which can 
 be characterized as external polymorphism (see section 12.10 on page 217 for 
 Visitor type double-dispatch). Unlike Cleeland et al., however, we do not use a 
 combina-tion of C
 ++
 templates, Adapter, and Decorator [Cleeland et al.96]. We 
 simply use the natural notion of a generic function [K¨uhne97].
  
 When a generic function object is applied to a node, it determines the node’s 
 type (by using runtime type information), creates the corresponding specialized 
 function object, and returns the result of applying the specialized function object 
 to the node.
  
 Figure 12.2 on the next page depicts how concrete element types (e.g.,
  IfThen
 ) 
 in-duce the creation of their corresponding specialized functions. A specialized 
 func-tion knows the exact type of its argument and, therefore, can appropriately 
 exploit the argument’s full interface.
  
 2
 Languages with multi-dispatch, e.g., C
 LOS
 , Cecil, or Dylan are not in widespread use.",NA
Interpretation,"12
  
 Translator",NA
abstract Syntax Tree,"generic Function
  
  
 in
  
 interpret 
 Assign
  
 interpret IfThen
  
 IfThen
  
 ""B""
  
 Assign
  
 ""V""
  
 ""W""
  
 interpret Identifier
  
 Figure 12.2: Generic interpretation on an abstract syntax tree
  
 Note that it is not only natural to deal with generic functions to achieve 
 double-dispatch, but also very natural to employ functions for translations. The 
 approach of formally defining the semantics of a programming language called 
 denotational semantics is entirely based on semantic functions, i.e., functions that 
 transform phrases into denotations [Schmidt86].
  
 Figure 12.3 on the facing page shows the structure diagram that corresponds to 
 the domains used in figure 12.1 on page 202. Only relationships relevant to 
 Transla-tor have been included. For instance, language nodes like
  ToyIf
  will 
 typically have an aggregation relation with
  ToyLang
  which is not shown here. 
 Exclamation marks denote places of possible extension (see section 12.7 on page 
 209,
  Extensibility
 ).
  
 Class
  Language
  in figure 12.3 on the next page is not required in general (see 
 figure 12.4 on page 206). Also, it is not required that
  ToyIf
 ,
  ToyAss
 , etc. have a 
 com-mon ancestor (like
  ToyLang
 ). Hence, one can define semantics on 
 heterogeneous collections where element types may come from different libraries.",NA
12.3 Applicability,"Use the Translator pattern for
  
 •
  Adding semantics.
  When you want to add an interpretation (even without 
 having planned for it) to a number of classes that have different interfaces, 
 Translator allows accessing the heterogeneous interfaces individually. The 
 classes need not belong to same hierarchy or library.",NA
!,"ToyAss
  
 print(indent : Integer)
  
 PpAss
  
 Client
  
 Function
  
 GenFunc",NA
!,"Functions
  
 PfIf
  
 PfAss
  
 PfVar",NA
!,"PpFunctions
  
 Figure 12.3: Sample structure
  
 tions require additional servers (e.g., environment lookup for type-checking) 
 the
  interpretations
 , as opposed to the
  elements
 , will depend on the servers, i.e., 
 require recompilation in case one server changes.
  
 •
  Incrementality.
  When small changes to big structures should not cause reeval-
 uation of the whole structure, exploit the homomorphic properties of 
 Transla-tor and use the intermediate structure (see figure 12.6 on page 209) 
 for storing computed results.
  
 Do not use the Translator pattern in case of",NA
12.4 Structure,"SourceElement 
 1 
 TargetLang
  
  
 evaluate",NA
Application related ,"SourceElement 
 2
  
 TargetElement 
 1 
  
 TargetElement 
 2
  
 Client
  
 Function
  
 GenFunc
  
 FunctionPackage
  
 SpecialFunction
  
 1
  
 SpecialFunction
  
 2",NA
Pattern related,ConcreteFunctionPackage,NA
12.5,NA,NA
Participants,"•
  Function
  (
 Function
 )
  
  
 –
  declares an interface for function application. Its two type parameters 
  
 specify argument and result type respectively
 3
 .
  
 –
  is used as the interface specification for both generic and specialized 
 functions.
  
 •
  Generic function
  (
 GenFunc
 )
  
  
 –
  corresponds to a denotational function definition.
  
 –
  uses function package
  Functions
  and runtime type information to choose 
 and then delegate to a specialized function.
  
 •
  Specialized function
  (e.g.,
  PfIf
 )
  
  
 –
  corresponds to one pattern matching branch of a denotational function 
  
 definition.
  
 –
  defines a local transformation for a source element (e.g.,
  ToyIf
 ) to a cor-
 responding target element (e.g.,
  PpIf
 ).
  
 –
  recursively transforms subcomponents of its argument as well.
  
 •
  Function package
  (e.g.,
  Functions
 )
  
  
 –
  conceptually bundles related specialized functions.
  
 –
  declares a generic package type for specialized functions to be refined by 
 concrete function packages.
  
 •
  Concrete Function package
  (e.g.,
  PpFunctions
 )
  
  
 –
  defines a mapping from source elements to their corresponding special-
  
 ized functions.
  
 –
  creates prototypes of — and then aggregates — specialized functions.
  
 •
  Client
  
  
 –
  creates or uses a source structure (e.g.,
  ToyLang
 ).
  
 –
  initializes or uses a function package (e.g.,
  
 PpFunctions
 ).
 –
  creates or uses a generic function 
 (
 GenFunc
 ).
  
 –
  applies a generic function to a source structure.
  
 3
 As is the case with all generic functions of figure 12.4 on the preceding page.",NA
Collaborations,"12
  
 Translator",NA
12.6,"Figure 12.5 shows important object interactions. It refers to “
 @
 ” for an infix func-
 tion application syntax (see sample code in section 12.9 on page 214 or design pat-
 tern Function Object at chapter 7 on page 93).
  
 client
  
 ty_if
  
 pp_functions
  
 pf_var
  
 pf_ass
  
 pf_if
  
 pf_if*
  
 prettyPrint
  
 pp_if
  
 make 
  
 init 
  
 make 
  
 make 
  
 make 
  
 make(pp_functions)
  
 @(ty_if) 
  
  
  
 item(""ToyIf"") 
  
   
  
 clone 
  
  
 @(ty_if) 
  
 @(ty_ass) 
  
 @(ty_var)
  
 make(pp_var, pp_ass)
  
 Figure 12.5: Interaction diagram
  
 •
  A client initializes a function package in order to create a generic function 
 from it. The client applies the generic function to the source structure in order 
  
 to obtain the translation result.
  
 •
  The generic function consults the function package for a specialized function 
 that matches the type of the argument. Then it applies a cloned exemplar of 
  
 the 
 specialized function to the argument.",NA
12.7 Consequences,"Tradeoffs of Translator are:
  
 •
  External functionality.
  Translator to data structures with heterogeneous 
 elements. 
  
  
 makes 
  
 it 
  
 easy 
  
 to 
  
  
  
  
  
  
 In contrast to Visi-
  
  
  
  
  
  
  
 add 
  
 interpretations
  
 tor [Gamma et al.94] there is no need to impose an
  Accept
  method on the 
 elements. Spreading interpretations over all elements (corresponding to 
 object-oriented design) would demand changing all elements when intro-
 ducing a new interpretation. Gathering all related behavior into one generic 
 function (corresponding to functional design) — thus separating unrelated 
 behavior (e.g., compilation from pretty-printing) — results in a clean 
 partition and allows to hide interpretation specific details (like interpretation 
 specific data structures and accumulated state) in generic functions.",NA
abstract Syntax Tree ,NA,NA
Pretty-Print Structure ,NA,NA
Pretty-Print,"IfThen
  
 ""IF""
  
 ""B""
  
 ""V""
  
 Assign
  
 Translation
  
 ""B""
  
 ""THEN""
  
 "":=""
  
 Evaluation
  
 IF b THEN
  
 ""W""
  
 ""END""
  
 ""W""
  
 v := w;
  
 END
  
 ""V""
  
 Figure 12.6: Distinct interpretation phases
  
 •
  Instability.
  When using Translator, adding new elements (e.g., changing the 
 abstract syntax of a language) becomes difficult. Unlike Visitor, Translator 
 does not demand that one extend all interpretations with a meaning for a 
 new element (e.g., compilation is not affected by adding a new type-",NA
12.8,NA,NA
Implementation,"Here are two issues to consider when implementing Translator (also see sec-tion 
 12.10 on page 217,
  Collaboration
  &
  Implementation
 ):
  
 •
  Mapping elements to functions.
  Translator (RTTI) to determine the concrete type 
 of a generic function argument. This 
  
  
 uses 
  
 runtime 
  
 type 
  
 information
  
 mechanism is very language dependent and may also vary with different 
 compilers for one language. Usually, it is possible to obtain a string of the 
 class name or test for successful downcasting to a specific type. If no such 
 mechanism is available, one is left with explicitly programming a type in-
 quiry interface. This is, however, incompatible to the otherwise non-
 intrusive nature of Translator.
  
 In any case, a generic function may also dispatch on values of objects as op-
 posed to their type. Consequently, you may represent musical notes and 
 quar-ter notes by the same class. The corresponding objects will differ in a 
 value, e.g., of attribute
  duration
 . Nevertheless, it is still possible to use a 
 generic func-tion to dispatch on this note representation.
  
 •
  Hiding function packages.
  It is easy to shield the client from the existence of 
 particular function packages, by providing a tailored generic function that 
 creates a standard generic function with a fixed function package (e.g., 
 prettyFunctions
 ). The client code, i.e., using a generic function is simpli-
 fied to
  
 source: 
  
 ToyLang;
  
 prettyPrint: 
  
 PrettyPrint;
  
 ...
  
 !!prettyPrint.init;
  
 (prettyPrint @ source).display;
  
 (compare to the version on page 215 of section 12.9). In order to achieve this 
 code shortening and client encapsulation from function packages one simply 
 needs to provide a tailored generic function like the one below.
  
 class PrettyPrint
  
 inherit Switch[ToyLang, PpLang]
  
 redefine functions end
  
 creation init
  
 feature
  
 functions : PpFunctions;
  
 init is do",NA
Sample Code,"12
  
 Translator",NA
12.9,"The following use of E
 IFFEL
  code should not conceal the fact that you may use 
 Translator with any language featuring runtime type information such as 
 S
 MALLTALK
 , C
 ++
 , and J
 AVA
 .
  
 Assume a toy source language with an if-statement (see figure 12.3 on page 
 205):
  
 class 
  
 ToyIfthen 
  
 inherit 
  
 ToyLang 
  
 creation make 
  
 feature 
  
 exp, stat: 
  
 ToyLang; 
  
 ...
  
 end
  
 The corresponding pretty-print element could be:
  
 class 
  
 PpIfthen 
  
 inherit 
  
 PpLang 
  
 creation make 
  
 feature 
  
 pexp, pstat: PpLang;
  
 make (e, s : PpLang) is 
  
 do 
  
 pexp:=e; 
  
 pstat:=s; 
  
 end
  
 display is 
  
 do 
  
  
 io.putstring (""IF ""); 
  
  
 pexp.display 
  
  
 io.putstring ("" THEN ""); 
  
  
 pstat.display; 
  
  
 io.putstring ("" END"") 
  
  
 io.new_line; 
  
 end; 
  
 end
  
  
 Now we need the specialized function that maps an if-statement to its pretty-
 print element.
  
 class PrettyFunctionIfthen 
  
 inherit Function[ToyIfthen, PpIfthen] 
 creation make",NA
12.10 Related Patterns,NA,NA
12.10.1 ,NA,NA
Categorization,"Function Object:
  Translator’s interface to clients is that of a function object.
  
 Interpreter:
  Interpreter suggests inventing and representing small languages for re-
 occurring problems [Gamma et al.94]. Translator and Interpreter do not ad-
 dress parsing, i.e., already presume the existence of an abstract syntax rep-
 resentation. Translator is well-suited defining the interpretation part of In-
 terpreter which defines interpretations in member methods of elements (see 
 discussion in section 12.2 on page 201) or by using Visitor.
  
 Visitor:
  Visitor [Gamma et al.94] has similar motivations as Translator. Yet, besides 
 the fact that Visitor does not cover homomorphic and incremental transla-
 tions, it also uses a different means of achieving double-dispatch. Visitor re-
 lies on the straightforward technique of encoding an argument’s type into 
 method names [Ingalls86]. However, several disadvantages are aligned with 
 this approach:
  
 5
 At this point a runtime error may occur due to a missing specialized function. Some exception 
 handling or other kinds of gracefully dealing with such a situation would be appropriate.",NA
12.10.2 ,NA,NA
Collaboration,"Transfold:
  The exploration of the source structure may be deferred to Transfold.
  
 Composite:
  Translator can be used for interpretations on Composite struc-
  
 tures 
 [Gamma et al.94].
  
 Observer:
  On may use Translator to create a view presented with the Ob-
  
 server 
 [Gamma et al.94] pattern.
  
 Flyweight:
  Leaves 
  
 of abstract
  
 weights [Gamma et al.94].
  
 syntax
  
 trees
  
 can
  
 be
  
 represented
  
 as
  
 Fly-",NA
12.10.3 ,NA,NA
Implementation,"Function Object:
  The specialized functions that map source elements to target ele-
  
 ments are function objects [K¨uhne97].
  
 The result produced by Translator may be a hierarchy of function objects, 
 i.e., a parameterized result. For instance, a pretty print result could be a 
 func-tion (itself calling other functions) awaiting the indentation level of the 
 cur-rent subtree. Such a structure corresponds to
  translucent procedures
  
 [Rozas93]. Such a function structure is able to evaluate, but also subject to 
 examination 
 and 
 decomposition 
 into 
 individual 
 functions 
 again. 
 Consequently, a transla-tor may also interpret such a translucent function 
 structure.
  
 Generic Function Object:
  The generic functions capable of realizing double- and 
 multi-dispatching interpretations on heterogeneous data structures are 
 generic function objects [K¨uhne97].
  
 Lazy Object:
  Translator may employ Lazy Object to implement lazy interpretations, 
  
 i.e., both intermediate structure and result may be lazy objects.
  
 Prototype:
  Function packages contain function prototypes [Gamma et al.94]. Fur-
 ther instances are created by cloning and the associated generic function is a 
 preset attribute value.
  
 Singleton:
  Instead of using an attribute
  genFunc
  (see section 12.9 on page 214) 
  
 in 
  
 specialized functions, 
  
 these 
  
 may 
  
 alternatively 
  
 access 
  
 a 
  
 Singleton 
  
 class [Gamma et al.94] in order to retrieve their corresponding generic func-
  
 tion. E
 IFFEL
  allows for a particularly easy Singleton implementation, using 
  
 the “once” mechanism.
  
 Observer:
  A chain of Observers [Gamma et al.94] can be employed to account for 
 the data dependency between source structure, target structure, and target 
 semantics.",NA
13 ,NA,NA
Collaboration,"Learn the patterns, and then forget ’em.
  
 – Charlie Parker
  
 The previous chapters introduced six functional patterns. Each is of value on 
 its own. A language, design toolkit, pattern system, or paradigm is of special 
 value, however, if the elements are orthogonal to each other and allow mutual 
 combina-tion to the extent of being a generative
 1
 system.
  
 “A pattern system for software architecture is a collection of patterns for
  
 software architecture, together with guidelines for their implementation, com-
  
 bination and practical use in software development [Buschmann et al.96].”
  
 –
  PoSA Group
  
 The presented functional pattern system exhibits a remarkable amount of in-
 terconnection and collaborations (e.g., 
  
 compared against the 23 GOF pat-terns 
 [Gamma et al.94]). 
  
 Figure 13.4 on page 226 shows the full relationship 
 graph for the pattern system, but it is more instructive to view partial diagrams 
 first. According to our separation of the
  Related Patterns
  section, we organize 
 pattern relationships into three
 2
 items:
  
 •
  Categorization.
  Which pattern “is-a” kind of another pattern? This relationship 
 reveals what other
  pattern roles
  a pattern may adopt in a 
  
 particular use.
  
 •
  Implementation.
  Which patterns do implement other patterns? Which patterns 
 are useful to realize the inner mechanics of another pattern?
  
 •
  Collaboration.
  Which patterns can collaborate with each other? This is a 
 symmetric relationship where individual pattern strengths are con-
  
 nected 
 like pieces in a jigsaw puzzle.
  
 The following diagrams and explanations collects and concentrates pattern re-
 lationships to create new perspectives. For a full understanding and more 
 example relationships, it may be required to (re-) consult the individual
  Related 
 Patterns
  sec-tions.
  
 1
 Pattern languages are also called “generative”. They allow generating a product by following 
 course patterns to finer grained patters through the language. Here, we mean bottom-up 
 generation from composable components.",NA
13.1 Example collaboration,"This section demonstrates all patterns in a single example. A well-known, non-
 trivial problem consists of determining whether two trees contain the same ele-
 ments with respect to an in-order traversal. The challenge is to stop searching 
 when a difference is found, i.e., to avoid unnecessary exploration of subtrees. This 
 task is known as the
  samefringe problem
  [Hewitt77] and has been used to both, 
 argue in fa-vor of lazy lists [Friedman & Wise76], and also to demonstrate the 
 inferior iteration mechanisms available with C
 ++
 [Baker93]
 4
 .
  
  
 In this example (see figure 13.5 on page 229) we are comparing machine code 
 consisting of instructions like load-data (
 LD data
 ), load-address (
 LA address
 ), etc. 
 The machine code is generated by interpreting an abstract syntax tree, whose 
 nodes are represented in conformity with the Void Value pattern. 
  
 The 
 interpretation to machine code is defined with the Translator pattern. Translator 
 employs the Generic Function Object pattern for its local transformations. The 
 result of the ab-stract syntax tree interpretation is a tree of machine code 
 instruction nodes, which is flattened
 5
 to a lazy stream of instructions using the Lazy 
 Object pattern. Lazy Object generates a lazy stream of instructions using the Value 
 Object pattern to cache already generated results. Finally, two differently generated 
 streams are com-pared using the Transfold pattern. Transfold itself, is 
 parameterized according to the Function Object pattern.
  
  
 In addition to be a readily accessible design, the configuration depicted in fig-
 ure 13.5 on page 229 has several benefits listed in table 13.1 on the next page.
  
 Note that Function Object alone would have sufficed to solve the samefringe 
 problem [Baker93, L¨aufer95], by defining two lazy functions to generate and 
 com-pare two streams. Still, pattern Lazy Object helps to better understand the 
 delay-ing aspect of Function Object and makes the stream concept explicit. 
 Transfold generalizes the parallel consumption of two streams to an iteration 
 framework and Translator allows the two tree arguments to be the result of 
 complex interpreta-tions. Void Value and Value Object help to simplify and 
 optimize the underlying data structures.
  
  
 Ergo, by no means all patterns are
  required
  to solve the problem, but each con-
 tributes to the accessibility and extendibility of the presented design.
  
 4
 This article did not consider the use of Function Object and, hence, did not tell the whole story. 
 5
 Using a post-order traversal rather than the usual in-order traversal.",NA
Translator,"Move
  
 229
  
 :=
  
  
 c
  
 a+b
  
 Generic 
  
 Function Object
  
 Add
  
 LA ""c""",NA
Void Value,"LD ""a""
  
 LD ""b""",NA
Lazy Object,Function Object,NA
=?,"LA ""a""
  
 LD ""b""
  
 Add
  
 LD ""b""
  
 LA ""a""
  
 LD ""b""
  
 Add
  
 LD ""d""",NA
Value Object,NA,NA
Transfold,"Move
  
 LD ""a""
  
 LD ""b""
  
 LD ""d""
  
 Add
  
 Figure 13.5: Functional pattern decomposition of “Samefringe”",NA
Part III,NA,NA
Language design,NA,NA
14 ,NA,NA
Pattern Driven Language Design,"Die Grenzen meiner Sprache sind die Grenzen meiner Welt.
  
 – Ludwig Wittgenstein",NA
14.1 Introduction,"T 
  
 twofold contribution to language design. First, implementing patterns 
  
 that represent flexibility and reuse promoting designs, puts an imple-
  
 he 
 functional pattern system presented in the previous part makes a
  
 mentation language to the test. Any encountered problems are likely to occur in 
 other attempts to produce flexible designs as well. Second, most patterns claim to 
 be supported by the implementation language directly instead of being coding 
 con-ventions. How are the suggested language concepts interrelated and what 
 type of individual support should be provided? As the emphasis of this book is 
 the func-tional pattern system itself, the intent of the following observations is to 
 provide an outlook to further developments, i.e., the aim is to identify impulses 
 rather than complete solutions.
  
 This part is organized as sections of patterns, each commenting on both above 
 mentioned aspects. It concludes with an overall reflection and suggests to reevalu-
 ate the roles of languages and their associated environments.",NA
14.2 Function Object,"Undeniably, function objects enrich object-oriented programming with many use-
 ful properties. Function objects hide the number of both parameters and results to 
 clients. This can be viewed as an aid to modularization, just like classes in object-
 oriented design [Parnas72] or higher-order functions and lazy evaluation in func-
 tional programming [Hughes87]. Accordingly, aggregation (“has-a”), inheritance 
 (“is-a”), and behavior parameterization (“takes-a”) should be equally well-known 
 to designers. “Takes-a” realizes object-composition, as opposed to breaking 
 encap-sulation with inheritance [Snyder86]. It is therefore a means of reaching the 
 goal of component oriented software [Jazayeri95, Nierstrasz & Meijler95]. In 
 combina-tion, inheritance and Function Object allow for flexible prototyping as 
 well as safe 
 black-box
  composition. Indeed, function objects reintroduce some 
 flavor of struc-tured analysis and design to object-orientation. This is definitely 
 useful. While",NA
14.3 Translator,"The most pressing issue with regard to language support for Translator is the pos-
  
 sibility of generic functions failing to find an appropriate specialized function at
  
 runtime. Since multi-dispatch is only emulated by using the Generic Function
  
 Object pattern, without further support there is no way that type safe application
  
 of generic functions can be ensured statically. Although the implementation pre-
  
 sented (see section 12.9 on page 214) avoids type-switch statements which require
  
 maintenence and even allows the addition of specialized functions at runtime, the
  
 introduction of a new type in the generic function domain will cause a runtime
  
 error if a generic function encounters an instance of it.
  
 In fact, historically multi-dispatch supporting languages have not been
  
 statically typed 
  
 either 
  
 [Bobrow et al.86b, 
  
 Shalit et al.92, 
  
 Chambers92b] 
  
 al-
  
 though 
  
 early 
  
 work on 
  
 combining 
  
 multi-dispatch 
  
 with 
  
 static 
  
 typing 
  
 ex-
  
 ists [Agrawal et al.91, Mugridge et al.91]. 
  
 Nevertheless, static type checking of
  
 multi-methods is highly desirable and possible solutions have been presented in
  
 the meantime [Chambers & Leavens95].
  
 Another common counterargument towards multi-methods is that they break
  
 encapsulation by accessing internals of multiple abstractions. Especially the in-
  
 carnation of multi-methods in C
 LOS
  with its unprotected data abstractions
 3
 and
  
 freely addable functions exemplifies the softening of an object-centered, encapsu-
  
 lation promoting, single-dispatch approach. The C
 ECIL
  language tries to maintain
  
 encapsulation by conceptually assigning one multi-method to all abstractions that
  
 2
 Unfortunately, the creator of E
 IFFEL
 , Bertrand Meyer, can not imagine E
 IFFEL
 ’s type system
  
 to develop into that direction [Meyer95] and proposed an alternative that simply and, therefore,",NA
14.4 Transfold,"The Transfold approach to iteration holds a number of implications for client soft-
 ware and library organization. Viewing data structures as maps (with internal 
 iter-ation) rather than indexable structures (with external iteration) increases the 
 level of abstraction [Pepper92]. If
  ordered
  iteration is necessary at all, it is deferred 
 to the internal iterator. Copy semantics for structures (including iteration results) 
 may help to avoid aliasing. For instance, implementing matrix multiplication with 
 ex-ternal iteration and side effects may not work anymore if the target of the 
 operation happens to be one of the arguments.
  
  
 The discussion in chapter 10 on page 163 actually developed a general frame-
 work for data interpretation, construction, and transformation. 
  
 The concept of 
 structural interpretations producing streams that are consumed by internal iter-
 ators, was found to extend to issues like creating data from manifest constants, 
 transforming structures into each other, and data persistence.
  
 In fact, assuming language support for all other functional patterns, no further 
 support for Transfold is required. This is not a reason, though, to exclude Trans-
 fold issues from a language design discussion. The borderline between languages 
 and library organization and frameworks respectively, has become more and 
 more fuzzy. Especially S
 MALLTALK
  makes this evidentially clear. While it takes 
 only a short time to learn the language, it is a major achievement to aquire 
 expertise on its rich library. Learning the operations available on collections, for 
 instance, is compa-rable to learning various loop constructs in other, less library 
 oriented, languages. In the future, more extendible languages will further the 
 trend to shift organization principles from languages to libraries.
  
 The uniformity by which Transfold lets us flexibly interpret data structures 
 sug-gests to facilitate the “folding” of structures by a suitable library organization. 
 From this point of view, it seems natural to have an
  Inductive
  class very high in 
 the hierar-chy. Data structures of various branching arity (such as linear 
 structures, trees, and graphs) but also abstractions like grammars, could be 
 accessible via this interface.
  
 The general nature of folding allows expressing many operations (see sec-tion 
 10.3 on page 173,
  Versatility
 ) with just one iteration primitive. This is in contrast to 
 E
 IFFEL
 ’s plethora of iteration features (
 do all
 ,
  do if
 ,
  do while
 ,
  do until
 , etc.) in its 
 iteration classes [Meyer94b] that still can not cover all cases. Although E
 IFFEL
  sup-
 ports only one language loop construct, its library approach to iteration apparently 
 does not allow such a minimalistic solution. While folding is not a computationally 
 complete function
 4
 it is sufficiently general to rely on it as the basic iteration prin-
 ciple. In fact, the combination of creating a structure from a source (unfold) and 
 subsequent processing (fold) — a so-called hylomorphism — is computationally 
 complete [Pardo98b].
  
  
 Unfold operations are needed when the computation is not driven by the 
 structure of the argument but by the structure of the expected result. 
  
 For in-
 stance, parsing is a tree structured process although the consumed structure is
  
 4
 Not every computable function is expressible as folding [Kieburtz & Lewis95].",NA
14.5 Value Object,"The problems induced by reference semantics are well known. In S
 MALLTALK
  the 
 sometimes unwanted and especially unexpected effects of aliasing are said to be a 
 bigger source of problems than the lack of a static type system. For instance, the 
 code
  
 aPoint := button getTopLeft. 
 aPoint y: (aPoint y - 3).
  
 aToolTip setTopLeft: aPoint.
  
 ""get reference location"" 
 ""move three pixels up"" 
  
 ""set toolbar above button""
  
 does not only place
  aToolTip
  three pixels above a
  button
 , but also, 
 unintention-ally, moves the button [Harris97]. Of course, a more functional 
 version would have been in order:
  
 aPoint := button getTopLeft.
  
 aToolTip setTopLeft: (aPoint - 0@3).
  
 The latter version works as expected since the minus operator produces a new 
 value.",NA
Lazy Object,"14
  
 Pattern Driven Language Design",NA
14.6,"Theoreticians value lazy semantics for the property of yielding at least the same 
 results as eager semantics but possibly more, and for the ability to apply “back-
 wards” substitutions — e.g., replacement of a constant
  1
  with
  if true then
  1
  else f
  —
 which is not possible with eager semantics (see section 1.2.4 on page 14). Chapter 
 8 on page 115, furthermore, showed a number of practical benefits resulting from 
 lazy semantics:
  
 •
  The reputation of functional programming languages to enable a declarative 
 programming style, may deceptively explained by pointing out the pattern 
 matching style of function definitions. Yet, the latter is, in effect, syntactic 
 sugar only and true declarative programming style is enabled by
  
 –
  not being forced to be explicit about artificial upper bounds,
  
 –
  allowing up-front declarations, and
  
 –
  being able to specify data dependencies only, without worrying for their 
 resolution (see section 8.4 on page 119).
  
 Even statically circular definitions are possible as long as a dynamic resolu-
 tion is possible. Specifying dependencies, rather than implementing 
 aggrega-tion relationships, may also help in achieving memory friendly 
 behavior for parallel programming [Kashiwagi & Wise91].
  
 •
  Data consumption can be separated from data generation. Still, termination 
 control is available for both producers and consumers. Hence, traditionally 
  
 opposing design goals, efficiency and modularity, are effectively reconciled 
  
 since partial evaluation is enabled across module boundaries. 
  
 Moreover, 
  
 space efficient, interleaved execution of producer-consumer pipelines is au-
  
 tomatic.
  
 •
  Lazy evaluation allows initialization code to be placed at the best possible 
 position; the corresponding data abstractions [Auer94]. Additionally, lazy 
  
 attribute evaluation opens up the possibility of overcoming current limita-
  
 tions in dealing with value types. 
  
 E
 IFFEL
  does not allow recursive refer-
  
 ences in expanded classes, e.g., a
  Person
  referring to another
  Person
  as its 
  
 spouse, since that implies an infinite initialization sequence and space re-
  
 quirement [Meyer92]. Lazy initialization would unfold such potentially in-
  
 finite structures only as much as necessary. 
  
 This is particular interesting 
  
 for Value Object and Void Value language support because of potential self-
  
 references.
  
 •
  A system based on streams is determined by the types of modules and the 
 interconnections (streams) between the modules. 
  
 Stream processes, such",NA
Void Value,"14
  
 Pattern Driven Language Design",NA
14.7,"Following the virtue of making programs robust, i.e., let them react sensibly in 
 case of unusual circumstances, previously simple code may become cluttered with 
 safety checks (e.g., see code examples 11.1– 11.6 starting on page 192). For this rea-
 son, the concept of exception handling was introduced. Interestingly, the reasons 
 that may cause an exception to be raised in E
 IFFEL
  are:
  
 (a) Hardware
  
 1. Hardware signal for user requests, such as hitting a “break” key.
  
 2. Memory exhausted, integer overflow, etc.
  
 (b) Software
  
 1. Programmer generated exception.
  
 2. Assertion violation.
  
 3. Applying an operation to an unattached reference [Meyer92].
  
 Taking into consideration that the first item in category “Hardware” and the first 
 two items in category “Software” represent welcome aids, and that there is effec-
 tively nothing that can be done against hardware limitations, one is left with just 
 one exception cause: Trying to call a feature on a void reference.
  
 For certain, chapter 11 on page 191 demonstrated a better way to deal with 
 such situations by avoiding them in the first place. A remaining discussion is
  how
  
 to avoid void references. There are two dual alternatives:
  
 Void Value 
 Provide a void class for each
 8
 class in the system [K¨uhne96b].
  
 Nullcase 
  
 Provide a nullcase for each function in the system [Sargeant93].
  
 An example of using a nullcase in an U
 FO
  [Sargeant93] function definition is:
  
 length: Int is
  
 nullcase: 0
  
 otherwise: 1 + self.tail.length
  
 How do nullcases compare to pattern Void Value? As a consequence of the en-
 capsulation breaking properties of pattern matching, function definitions in U
 FO 
 are sensitive to the introduction and change of null values. For instance, if a set of 
 functions is designed to always operate on non-null lists and later it is discovered 
 that indeed null lists may also occur, then all function definitions must be 
 changed to include the nullcase branch. In contrast, methods of an object do not 
 need to be changed, since they operate on a non-void object per definition. The 
 necessary addition here consists of adding one
  VoidClass
 .
  
 8
 In analogy to an object root class, there should be a void value root class which is inherited by all 
 void classes. Hence, only deviations actually need to be specified.",NA
Conclusion,"14
  
 Pattern Driven Language Design",NA
14.8,"A language that doesn’t affect 
  
 the way you think about programming, 
  
 is not worth knowing.
  
 – Alan J. Perlis
  
 The impact of the functional pattern system on language design, as detailed in the 
 previous sections, is summarized in table 14.1.
  
 Name 
 language concept
  
 Motivation / Effect
  
  
 Function Object 
 higher-order functions
  
 Translator 
  
 multi-dispatch
  
 Lazy Object 
  
 lazy evaluation
  
 Transfold 
  
 algebraic library 
  
 organization
  
 Value Object 
  
 value semantics
  
 Void Value 
  
 void behavior
  
 user defined control structures, component 
 programming, functional extensibility.
  
 heterogeneity 
  
 problem 
  
 non-intrusively 
 solved, datatype extensibility in the presence 
 of functional extensibility.
  
 modularization, declarative 
  
 programming 
 style, iteration framework, recursive value 
 initialization, user defined control structures.
  
 library organization with inductive and coin-
 ductive types, emphasis on hylomorphisms 
 (
 fold
  ♦
  unfold
  operations), operation imple-
 mentation with parallel hardware.
  
 default value assignment, additional broad-
 casting assignment, value subtyping.
  
 void behavior instead of exceptions, reference 
 initialization.
  
 Table 14.1: Pattern implications on language design
  
 Pattern Function Object adds functional decomposition (i.e., functional exten-
 sibility) to object-oriented design (see section 14.2 on page 233). It is an essen-tial 
 means for the construction of components [Jazayeri95] and black-box frame-
 works [Johnson & Foote88]. Translator makes datatype extensions feasible in the 
 presence of a functional decomposition by means of extensible multi-dispatching 
 functions. Heterogenous data (in a structure or coming from, e.g., a database or 
 net-work) can be dealt with, without imposing an interface on the respective 
 datatypes (see section 14.3 on page 238).",NA
Epilogue,"Not only will men of science have to grapple with the sciences that deal with man,
  
 but — and this is a far more difficult matter — they will have to persuade
  
 the world to listen to what they have discovered. If they cannot succeed
  
 in this difficult enterprise, man will destroy himself
  
 by his halfway cleverness.
  
 – Bertrand Russel
  
 A 
  
 sections conclude about the many facets involved by the successful at-
  
 tempt to capture the functional programming paradigm with patterns 
  
 functional pattern system is valuable in many aspects. The following
  
 for object-oriented design.",NA
Software design,"Each of the six presented patterns is capable of improving today’s software de-
 signs. Even those patterns that do not represent completely novel approaches, for 
 the first time explicitely describe the applicability and resulting consequences of 
 each technique in a functional pattern system context. To my knowledge, my 
 work represents the first comprehensive attempt to examine functionally inspired 
 tech-niques in terms of software engineering concepts.",NA
Understanding object-oriented practice,"In the context of the functional pattern system, many object-oriented practices ap-
 pear as special cases of more general functional patterns. For instance, call-back 
 functions according to the Command pattern are function objects
 14
 that do not take 
 arguments after their creation. The acceptance of arguments after creation opens 
 up a wealth of useful applications (see pattern Function Object on page 93). So-
 called iterator objects, coming into existence through the need to separate iteration 
 action refinement inheritance from data structures [Meyer94b], may also be 
 regarded as function objects with a non-standard application interface. Likewise, a 
 visitor ca-pable of visiting several node types, is a function object with several 
 entry points.
  
 14
 Procedure objects, to be precise (see section 7.10 on page 107).",NA
Object-oriented fertilization,"Although techniques similar to function objects and lazy object have been de-
 scribed before, they gave a partial view only.",NA
Function Object,"For instance, descriptions of techniques similar to function objects concentrated on 
 the locality of function definition [Breuel88], discussed a weakly typed way of 
 achieving dynamic dispatch on functions [Coplien92], or used a non-uniform 
 appli-cation syntax for algorithm parameterization [Hillegass93]. Apart from 
 discussing the software engineering consequences of first class functions, pattern 
 Function Object introduces innovations such as returning functions as a result, 
 type safe cur-rying of functions, keyword parameters, and generic function 
 objects [K¨uhne97].
  
  
 15
 There is no doubt, however, that engineering itself is not a mechanical activity and genius will 
 still shine through exceptional masterpieces of engineering.",NA
Lazy Object,"Precursors of Lazy Object descriptions described a “trick” only to avoid unneces-
 sary and repetitive evaluations [Smith95] or concentrated on the architectural as-
 pects of pipes and filters [Buschmann et al.96]. John Hughes’ investigation in the 
 benefits of higher-order functions and lazy evaluation [Hughes87] is the only 
 work I know of, which is similar in spirit to the research performed for this thesis. 
 Of course, combined in a functional pattern system context, Function Object and 
 Lazy Object go far beyond the issues discussed by John Hughes.",NA
Transfold,"Neither external iterators [Gamma et al.94], nor internal iterators operating on a 
 single structure only [Goldberg & Robson83] provide a satisfactory general itera-
 tion framework. The availability of Function Object, however, makes internal it-
 eration feasible even for object-oriented languages without support for closures. 
 The availability of Lazy Object makes the separation of structure exploration and 
 data consumption feasible. Combined with the idea of simultaneously processing 
 multiple structures during one internal iteration, the result called Transfold pro-
 vides the safety and economic notation of internal iteration while maintaining the 
 flexibility and control of external iteration.",NA
Translator,"Without having been designed for this purpose, pattern Translator resolves some 
 problematic issues associated with Visitor [Gamma et al.94]. 
  
 Other pro-
 posals have been made to avoid interface pollution and a dependency cy-cle 
 [Martin97], to allow partial visitations [Nordberg96], or to provide extensi-ble 
 visitors [Krishnamurthi et al.98]. But none of them introduces the elegant no-tion of 
 an iteration with a generic function and coincidentally opens up the pos-sibility of 
 incremental evaluation with the concept of homomorphic interpreta-tions 
 [K¨uhne98].
  
  
 In sum, patterns Transfold and Translator yield remarkable solutions for previ-
 ously — with a pure object-oriented mind-set — unsuccessfully tackled problems.",NA
Void Value,"While there have been examples of default objects in the spirit of Void Value (e.g., 
 NoController
  in V
 ISUAL
 W
 ORKS
 ), the idea to completely abandon
  nil
  and provide void 
 values as a general principle is without precedent. 
  
 The nullcases of U
 FO 
 represent a corresponding idea in a functional programming framework. A com-
 parison between the two diametrical approaches found Void Value to be supe-rior 
 [K¨uhne96b].",NA
Value Object,"Finally, pattern Value Object touches upon a much neglected topic in object-
 orientation: The taming of state. 
  
 Software methodologies typically ignore this 
 topic generously and focus on interfaces. 
  
 Other approaches take reference se-
 mantics for granted and try to establish restrictions in order to prevent alias-ing 
 [Hogg91, Minsky96, Almeida97]. Value Object is a small, but maybe not that 
 unimportant, reminder of the fact that reference semantics is a natural solution for 
 efficient execution but not for intuitive programming.
  
 In conclusion, functional patterns have been shown to be superior to a number 
 of purely object-oriented solutions, e.g., using (multiple) inheritance and double-
 dispatch emulation.",NA
The human side of patterns,"One part of the pattern community believes that “
 patterns are not so much about form
  
 and technology as they are about aesthetics and decency, about improving quality of life, 
 about human dignity and decency
 ” [Coplien96a]. While the effect is indirect, I see a 
 good chance that the presented pattern system will bring more comfort and qual-
 ity to software users. Pattern Function Object promotes software with dynamically 
 exchangeable strategies. This may induce a change in human computer interface 
 design and the way software can be updated. A user of a word processor might be 
 able to select between formating strategies and combine them with hyphenation 
 algorithms. Software updates might consist of single components only that, e.g., 
 add a formatting strategy to allow text to float around figures. This perspective 
 provides an interesting alternative to the current buy-all-or-nothing choice, where 
 fat software includes many unwanted features but almost certainly misses individ-
 ually interesting ones. With function-object-like components, users would be em-
 powered to configurate their own systems by buying components from the shelf.
  
 The stream concept described in Lazy Object may help to work towards the 
 same goal. Streams are the foundation of a pipes and filters architecture that 
 allows configuration by the user. As a U
 NIX
  user creates new commands by 
 combining ex-isting commands with pipes, an application user may freely 
 combine and arrange components that communicate with streams. This also 
 would allow deferring de-cisions about application design to the user, creating 
 more tailored and, thus, more useful and comfort providing software.
  
 Transfold provides the most comfort to the programmer using it, but also 
 users benefit from increased safety. However small the risk of introducing errors 
 with external control structures is, it is there (see the Mariner incident in section 
 10.2.1 on page 163) and internal iteration minimizes that risk to absolutely zero.
  
 The contribution of Value Object to end user comfort is quite indirect, but it 
 may help to produce software containing less bugs (caused by aliasing) and 
 allows programmers investing more time in improving software quality, because 
 they are freed from tracking down tricky, state induced problems.",NA
Pattern system ,"Object 
  
  
  
 Transfold 
  
  
 Lazy
  
 Within the functional pattern sys-
  
 Object 
   
 Value
  
 tem, patterns reinforce each other 
  
 due to their manifold interactions 
  
 Translator
  
 and collaborations. The analysis of 
  
 pattern relationships revealed the 
  
 nature of individual patterns and 
  
 allowed them to be placed in a con-
  
 ceptual space. Pattern Translator 
  
 Value 
  
  
  
 Void",NA
Drawbacks,"The most obvious drawback with respect to the functional ideal is the overhead in 
 description complexity. Some services, such as lazy streams, can be coded once 
 and for all but, for instance, the tedious coding of dedicated classes for function 
 currying must be repeated for every new function object definition. Although the 
 benefits outweigh the required effort, the sometimes apparent need to code an 
 em-ulation of fundamental mechanisms ultimately calls for language support.
  
 Furthermore, object-oriented emulations of built-in functional concepts may 
 in-cur efficiency penalties. While most systems will not be as time critical as to 
 dis-allow functional patterns — and may in fact experience a speed up due to lazy 
 evaluation, for instance — language support could significantly speed up execu-
 tion and would allow compiler optimizations.",NA
Tool support,"Tools could aid in using functional patterns in conventional object-oriented lan-
 guages from simple support such as automatically generating all necessary classes 
 for a function object, till sophisticated type checking to discover possible failure to 
 find an appropriate special function when a generic function is applied to a poly-
 morphic variable.
  
 The most intriguing impulse for tool support, however, is initiated by pattern 
 Void Value. Research, comparing nullcases to Void Value [K¨uhne96b], led to the 
 idea of moving responsibilities away from languages towards their associated en-
 vironments.
  
 Tool support as described in section 14.8 on page 252, frees a language from 
 committing itself to either paradigm. The language just provides the notation for 
 filling in the tiles of figure 4.2 on page 65 (the implementation corresponding to a 
 function and an argument type) while a browser generates either a functional 
 (rows), an object-oriented (columns), or a global (full table) view. This approach 
 opens up the way to a (tile based) language supporting both procedural and type
  
  
 16
 Or “boss”, i.e., the last structural stone in the dome of a cathedral that imparts its grandeur the 
 necessary stability.",NA
Paradigm integration,"When inquired for his opinion about object technology Timothy Budd felt positive 
 about it but, referring to multi-paradigm programming, added:
  
 “. . . the real revolution would arrive when we finally understood how to
  
 bring these diverse points of view together into one framework. [Budd95]”–
  
 Timothy Budd
  
 Without doubt the functional pattern system is a contribution to multi-paradigm 
 software and language design. Its basic idea, to express functional concepts with 
 patterns for object-oriented design with a view to holistic language design was 
 acknowledged to be a contribution against a proliferation of concepts and termi-
 nology which would leave everyone with an incomplete picture [Reynolds96]. 
 The functional pattern system advances the integration of the functional and 
 object-oriented paradigms since
  
 •
  an analysis on calculus level was performed to ensure the adequateness of 
 embedding functions into objects,",NA
Patterns and Paradigms,"Patterns and paradigms have an interesting relationship. Just like patterns depend 
 on the level of abstraction, e.g., one could consider subroutines to be a pattern in 
 assembler languages but not for higher level languages, they also depend on the 
 context’s paradigm. For instance, in a C
 LOS
  like setting based on generic functions, 
 the Visitor pattern makes much less sense, since it mainly shows a technique to 
 achieve double dispatch in single-dispatch languages. Also, most arguments of 
 the Iterator pattern are obsolete for S
 MALLTALK
  with its rich iteration interface for 
 col-lections. Therefore, the occurrence of certain patterns typically denotes 
 weaknesses of their context paradigms, since they provide functionality which is 
 not available at a primitive level. As has been carried out in this thesis, patterns 
 may also be used to describe and characterize a paradigm by capturing its 
 foundations in well documented mini-architectures. So, as a third relationship 
 aspect between patterns and paradigms, patterns may be used to embed one 
 paradigm into another. The
  
 •
  signaling (what is wrong with a paradigm),
  
 •
  descriptive (what are the constituents of a paradigm), and",NA
Language design,"As patterns are hoped to form the engineering handbooks of software 
 development— and, therefore, contribute to make software engineering a science 
 — language concept patterns, as presented here, may as well contribute to make 
 language de-sign a science. A dissection of programming languages into software 
 engineering principles supporting concepts would allow the design of new 
 languages from a known set of pieces. The functional pattern system captures the 
 essence of soft-ware engineering properties supported by functional concepts. 
  
 Along with an 
 analysis of an effective paradigm integration approach (see chapter 4 on page 55) it 
 enables a language designer to take a shopping list approach for the design of",NA
Previous integration attempts,"The functional and object-oriented paradigms have been the target for many inte-
  
 gration attempts. However, often only a partial attempt (e.g., just providing func-
  
 tions) has been made [van Rossum91, Klagges93, Dami94, Watt et al.94], or state is
  
 completely rejected [Braine94, R´emy & Vouillon97].
  
 Object-oriented extensions to functional languages typical concentrate on typ-
  
 ing issues and do not provide dynamic binding [R´emy & Vouillon97]. One dialect
  
 of H
 ASKELL
  uses existential types to enable dynamic binding [L¨aufer96] but state
  
 has to be modeled in programs, i.e., is not supported as a primitive.
  
 C
 LOS 
  
 [Bobrow et al.86b], 
  
 O
 AKLISP 
 [Lang & Pearlmutter86] 
  
 and 
  
 D
 Y
 -
  
 LAN 
 [Shalit et al.92] 
  
 can be 
  
 regarded 
  
 as 
  
 object-oriented 
  
 extensions 
  
 to
  
 L
 ISP
  [Winston & Horn84] but they have no strong notion of encapsulation. Classes
  
 are modeled with records with no access restrictions. Their generic functions are a
  
 very powerful approach but when viewed from a paradigm integration perspective
  
 the languages appear unpolished. The frequent use of macros and the meta-level
  
 facilities make them suitable for explorative programming but questionable for
  
 being software engineering languages
 18
 .
  
 Two languages, U
 FO
  [Sargeant93] and L
 EDA
  [Budd95], attempt a full integra-
  
 tion including state. A comparison between the
  nullcases
  of U
 FO
  and Void Value
  
 has been given in [K¨uhne96b] (see also section 14.7 on page 248). Timothy Budd",NA
Bibliography,"[Abadi & Cardelli94]
  
 [Abadi & Cardelli95]
  
 [Abadi94]
  
 Mart´in Abadi and Luca Cardelli. A theory of 
 prim-itive objects: untyped and first order systems. 
 In 
 Proc. Theor. Aspects of Computer Software
 , pages 
 296–320, Japan, 1994.
  
 Mart´in Abadi and Luca Cardelli. On subtyping 
 and matching. In W. Olthoff, editor,
  Proceedings 
 ECOOP’95
 , LNCS 952, pages 145–167, Aarhus, 
 Denmark, Springer-Verlag, August 1995.
  
 Mart´in Abadi. Baby modula 3 and a theory of ob-
 jects.
  Journal of Functional Programming
 , 4:249–283, 
 April 1994.
  
  
 [Abelson & Sussman87]
  
 Harold Abelson and Gerald Jay Sussman.
  Structure 
 and Interpretation of Computer Programs
 . 
  
 The MIT 
 Press, Cambridge, MA, London,
  6
 th
 edition, 1987.
  
 [Agrawal et al.91]
  
 [Aho & Ullmann92]
  
 [Aho et al.86]
  
 [Alexander et al.77]
  
 [Alexander64]
  
 [Alexander79]
  
 Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. 
 Lindsay. Static type checking of multi-methods. In 
 Proceedings OOPSLA ’91
 , pages 113–128, November 
 1991.
  
 Alfred V. Aho and Jeffrey D. Ullmann.
  Foundations 
 of Computer Science
 . Computer Science Press, New 
 York, 1992.
  
 Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. 
 Compilers: Principles, Techniques, and Tools
 . Addison 
 Wesley, Reading, Massachusetts, March 1986.
  
 C. Alexander, S. Ishikawa, and M. Silverstein. 
 Pattern Language
 . Oxford University Press, 1977.
  
 A
  
 Christopher Alexander. 
  
 Notes on the Synthesis of
  
 Form
 . Harvard University Press, 1964.
  
 Christopher Alexander.
  A Timeless Way of Building
 .
  
 Oxford University Press, 1979.",NA
M,"uSE
  — Multimediale Systementwicklung. 
  
 In 
 I. Toch, G. Kampe, H. Ecker, and F. Breitenecker, 
 editors,
  ASIM-Arbeitskreistreffen Simulation Technis-
  
 cher Systeme und Simulationsmethoden und Sprachen 
 f¨ur parallele Prozesse (Wien, 31.1.-1.2. 1994)
 . ASIM, 
 1994.
  
  
 [DeMichiel & Gabriel87]
  
 Linda G. DeMichiel and Richard P. Gabriel. 
  
 The 
 common lisp object system: 
  
 An overview. 
   
 In 
 J. Bezivin, J-M. Hullot, P. Cointe, and H. Lieber-
 mann, editors,
  Proceedings ECOOP ’87
 , LNCS 276, 
 pages 151–170. Springer Verlag, June 1987.
  
 [Despeyroux88]
  
 [Dijkstra76]
  
 [Dosch95]
  
 [Duke95]
  
 Thierry Despeyroux. Typol: a formalism to imple-
 ment natural semantics. Technical report, INRIA 
 re-search report 94, 1988.
  
 Edsgar W. Dijkstra. 
  
 A Discipline of Programming
 . 
 Prentice Hall, Englewood Cliffs, N.J., 1976.
  
 Walter 
 Dosch. 
 Personal 
 communication. 
 Workshop Alternative Konzepte f¨ur Sprachen 
 und Rechner in Bad Honnef, May 1995.
  
 Roger Duke. Do formal object-oriented methods 
 have a future? In Christine Mingins and Bertrand",NA
Index,"Symbols
  
 
 -conversion
  . . . . . . . . . . . . . . . . . . . . . .
  
 49
 
 -reduction
 . . . . . . . . .
 47, 49, 51, 53, 
 106
 
 -reduction
  . . . . . . . . . . . . . . . . . . . .
  48, 
 52
 
 -reduction
  . . . . . . . . . . . . . . . .
  47, 48, 
 53
 
 -calculus
  . . . . . . . . . . . . . . . .
  9, 11, 45–
 54
 ♦
 -operator
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 60
 ♦ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 27
 
 -calculus
 . . . . . . . . . . . . . . . . . . . . . . . . .
 46 
 L
 A
 TEX 2
 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 vi 
 6502 processor
  . . . . . . . . . . . . . . . . . . . .
  26 
 68000 processor
  . . . . . . . . . . . . . . . . . . .
  26
  
  
  
 A 
  
 ABACAB
  . . . . . . . . . . . . . . . . . . . . . . . . .
  70 
 Abelson, Hal
  . . . . . . . . . . . . . . . . . . . . .
  273 
 abstract datatype
  . . . . . . . . . . . . . .
  26,
  30 
 Abstract Factory pattern
 . . . . . . . . . .
 200 
 abstract interpretation
 . . . . . . . . . . . .
 201 
 abstract state
  . . . . . . . . . . . . .
  58, 156, 159 
 abstract syntax tree
  . . . . . . . . . .
  202, 227 
 abstraction
  . . . . . . . . . . . . . . . . . .
  102, 196 
 iterator
 . . . . . . . . . . . . . . . . . . . . . . .
 164 
 procedural
  . . . . . . . . . . . . . . . . . . .
  255 
 timeless
  . . . . . . . . . . . . . . . . . . . . . .
  152 
 type
 . . . . . . . . . . . . . . . . . . . . . . . . . .
 255 
 access 
  
 read-only
  . . . . . . . . . . . . . . . . . . . .
  152 
 access thread
 . . . . . . . . . . . . . . . . . . . . .
 158 
 accessor function
 . . . . . . . . . . . . . . . . .
 161 
 accumulator technique
  . . . . . . . . . . . .
  23 
 Acyclic Visitor pattern
 . . . . . . . . . . . .
 218 
 ad-hoc polymorphism
 . . . . . . . . . . . . .
 35 
 A
 DA
  95
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  91 
 Adapter pattern
 . . . . . . . . .
  112, 129, 203 
 adding functionality
  . . . . . . . . . . . . .
  203 
 adding semantics
  . . . . . . . . . . . . . . . .
  204 
 addition
  
 non-intrusive
 . . . . . . . . . . . . . . . . .
 212 
 adjustment 
  
 iterator
 . . . . . . . . . . . . . . . . . . . . . . .
 179 ADT
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  191 
 aggregate
  . . . . . . . . . . . . . . . . . . . . . . . .
  163 
 Alexander, Christopher
 . . . . .
 69, 74, 86 
 algebraic datatype
  . . . . . . . . . . . . . . .
  239 
 A
 LGOL
  . . . . . . . . . . . . . . . . . . . . .
  40, 41, 75 
 A
 LGOL
  60
  . . . . . . . . . . . . . . . . . . . . . . .
  144 
 A
 LGOL
  68
 . . . . . . . . . . . . . . . . . . . . . . . .
 110 
 algorithm 
  
 graph
  . . . . . . . . . . . . . . . . . . . . . . . .
  144 
 algorithm classification
 . . . . . . . . . . . .
 98 
 algorithmic skeleton
  . . . . . . . . . . . . .
  242 
 algorithms 
  
 monolithic
  . . . . . . . . . . . . . . . . . . . .
  99 
 aliasing
  . . .
  12, 26, 38, 92, 149, 151, 152, 
  
 154, 155, 158, 161, 244 
  
 control
  . . . . . . . . . . . . . . . . . . . . . . .
  244 direct
  
 . . . . . . . . . . . . . . . . . . . . . . . .
  156 indirect
  . . . . 
 . . . . . . . . . . . . . . . . . .
  156 aliasing 
 protection
  . . . . . . . . . . . . . . .
  154 all-
 quantifier
  . . . . . . . . . . . . . . . . . . . . . .
  35 
 Allen, Fred
 . . . . . . . . . . . . . . . . . . . . . . .
 163 
 anonymous closures
 . . . . . . . . . . . . . . .
 59 
 anonymous function
  . . . . . . . . . . . . .
  235 
 A
 PL
 . . . . . . . . . . . . . . . . . . . . .
 179, 186, 187 
 Appel, Andrew W.
  . . . . . . . . . . . . . . . .
  22 
 append operator
  . . . . . . . . . . . . . . . . . .
  23 
 application skeleton
  . . . . . . . . . . . . . . .
  36 
 applicative-order reduction
  . . . .
  11
 , 14 
 architecture 
  
 data-flow
  . . . . . . . . . . . . . . . . . . . .
  123 
 language
  . . . . . . . . . . . . . . . . . . . . .
  270 von 
 Neumann
 . . . . . . . . . . . . . . . . .
 40 argument 
  
 immutable
  . . . . . . . . . . . . . . . . . . .
  158",NA
