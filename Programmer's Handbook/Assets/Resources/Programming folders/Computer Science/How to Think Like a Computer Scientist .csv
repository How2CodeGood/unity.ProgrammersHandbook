Larger Text,Smaller Text,Symbol
How to Think Like a Computer ,NA,NA
Scientis,NA,NA
t ,NA,NA
C ,NA,NA
Version,NA,NA
Allen B. Downey ,C-Version by Thomas Scheffler,NA
Version 1.09 ,"January 5th, 2018",NA
Contents,"1
  
 The way of the program
  
 1
  
  
 2
  
 1.1
  
 What is a programming language? . . . . . . . . . . . . . . . . .
  
 1
  
 1.2
  
 What is a program?
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.3
  
 What is debugging?
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.3.1
  
 Compile-time errors
  
 . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 1.3.2
  
 Run-time errors . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 1.3.3
  
 Logic errors and semantics
  
 . . . . . . . . . . . . . . . . .
  
 4
  
 1.3.4
  
 Experimental debugging . . . . . . . . . . . . . . . . . . .
  
 5
  
 1.4
  
 Formal and natural languages . . . . . . . . . . . . . . . . . . . .
  
 5
  
 1.5
  
 The first program . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 1.6
  
 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 1.7
  
 Exercise
 s
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 Variables and types
  
 13
  
 2.1
  
 More output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 2.2
  
 Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 2.3
  
 Variable
 s
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 2.4
  
 Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 2.5
  
 Outputting variables . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 2.6
  
 Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 2.7
  
 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 2.8
  
 Order of operations . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 2.9
  
 Operators for characters . . . . . . . . . . . . . . . . . . . . . . .
  
 20",NA
Chapter 1,NA,NA
The way of the program,"The goal of this book, and this class, is to teach you to think like a computer 
 scientist. I like the way computer scientists think because they combine some of 
 the best features of Mathematics, Engineering, and Natural Science. Like math-
 ematicians, computer scientists use formal languages to denote ideas (specifi-
 cally computations). Like engineers, they design things, assembling components 
 into systems and evaluating tradeoffs among alternatives. Like scientists, they 
 observe the behavior of complex systems, form hypotheses, and test predictions.
  
 The single most important skill for a computer scientist is
  problem-solving
 . By 
 that I mean the ability to formulate problems, think creatively about solu-tions, 
 and express a solution clearly and accurately. As it turns out, the process of 
 learning to program is an excellent opportunity to practice problem-solving 
 skills. That’s why this chapter is called “The way of the program.”
  
 On one level, you will be learning to program, which is a useful skill by itself. On 
 another level you will use programming as a means to an end. As we go along, 
 that end will become clearer.",NA
1.1 ,NA,NA
What is a programming language?,"The programming language you will be learning is C, which was developed in 
 the early 1970s by Dennis M. Ritchie at the Bell Laboratories. C is an example of 
 a
  high-level language
 ; other high-level languages you might have heard of are 
 Pascal, C++ and Java.
  
 As you might infer from the name “high-level language,” there are also
  low-level 
 languages
 , sometimes referred to as machine language or assembly language. 
 Loosely-speaking, computers can only execute programs written in low-level 
 languages. Thus, programs written in a high-level language have to be trans-
 lated before they can run. This translation takes some time, which is a small 
 disadvantage of high-level languages.",NA
1.2 ,NA,NA
What is a program?,"A program is a sequence of instructions that specifies how to perform a com-
 putation. The computation might be something mathematical, like solving a 
 system of equations or finding the roots of a polynomial, but it can also be a 
 symbolic computation, like searching and replacing text in a document or 
 (strangely enough) compiling a program.
  
 The instructions, which we will call
  statements
 , look different in different 
 programming languages, but there are a few basic operations most languages 
 can perform:
  
 input:
  Get data from the keyboard, or a file, or some other device.
  
 output:
  Display data on the screen or send data to a file or other device.
  
 math:
  Perform basic mathematical operations like addition and multiplication.
  
 testing:
  Check for certain conditions and execute the appropriate sequence of 
  
 statements.
  
 repetition:
  Perform some action repeatedly, usually with some variation.
  
 That’s pretty much all there is to it. Every program you’ve ever used, no matter 
 how complicated, is made up of statements that perform these operations. Thus, 
 one way to describe programming is the process of breaking a large, complex 
 task up into smaller and smaller subtasks until eventually the subtasks are 
 simple enough to be performed with one of these basic operations.",NA
1.3 ,NA,NA
What is debugging?,"Programming is a complex process, and since it is done by human beings, it 
 often leads to errors. For whimsical reasons, programming errors are called
  
 bugs
  and the process of tracking them down and correcting them is called
  
 debugging
 .
  
 There are a few different kinds of errors that can occur in a program, and it is 
 useful to distinguish between them in order to track them down more quickly.",NA
1.4 ,NA,NA
Formal and natural languages,"Natural languages
  are the languages that people speak, like English, Spanish, 
 and French. They were not designed by people (although people try to impose 
 some order on them); they evolved naturally.
  
 Formal languages
  are languages that are designed by people for specific appli-
 cations. For example, the notation that mathematicians use is a formal language 
 that is particularly good at denoting relationships among numbers and symbols. 
 Chemists use a formal language to represent the chemical structure of 
 molecules.
  
 And most importantly:
  
 Programming languages are formal languages that have been 
 designed to express computations.
  
 As I mentioned before, formal languages tend to have strict rules about syntax. 
 For example, 3 + 3 = 6 is a syntactically correct mathematical statement, but",NA
1.5 ,NA,NA
The first program,"Traditionally the first program people write in a new language is called “Hello, 
 World.”
  
 because all it does is display the words “Hello, World.”
  
 In C, this 
 program looks like this:
  
 #include <stdio.h> 
  
 #include <stdlib.h>
  
 /* main: generate some simple output */
  
 int main(void) 
  
 { 
  
  
 printf(""Hello, World.\n""); 
  
  
 return(EXIT_SUCCESS); 
  
 }
  
 Some people judge the quality of a programming language by the simplicity of 
 the “Hello, World.” program. By this standard, C does reasonably well. Even so, 
 this simple program contains several features that are hard to explain to 
 beginning programmers. For now, we will ignore some of them, like the first two 
 lines.
  
 The third line begins with /* and ends with */, which indicates that it is a 
 comment
 . A comment is a bit of English text that you can put in the middle of a 
 program, usually to explain what the program does. When the compiler sees a 
 /*, it ignores everything from there until it finds the corresponding */.
  
 In the forth line, you notice the word main. main is a special name that indicates 
 the place in the program where execution begins. When the program runs, it 
 starts by executing the first
  statement
  in main() and it continues, in order, until 
 it gets to the last statement, and then it quits.
  
 There is no limit to the number of statements that can be in main(), but the 
 example contains only two. The first is an
  output
  statement, meaning that",NA
1.6 Glossary,"problem-solving:
  The process of formulating a problem, finding a solution, 
  
 and 
 expressing the solution.",NA
1.7,NA,NA
Exercises,"Exercise 1.1
  
 Computer scientists have the annoying habit of using common English words to mean 
 something different from their common English meaning. For example, in English, a 
 statement and a comment are pretty much the same thing, but when we are talking about 
 a program, they are very different.
  
 The glossary at the end of each chapter is intended to highlight words and phrases that 
 have special meanings in computer science. When you see familiar words, don’t assume 
 that you know what they mean!
  
 a. In computer jargon, what’s the difference between a statement and a comment?
  
 b. What does it mean to say that a program is portable?
  
 c. What is an executable?
  
 Exercise 1.2
  
 Before you do anything else, find out how to compile and run a C program in your 
 environment. Some environments provide sample programs similar to the example in 
 Section 1.5.
  
 a. Type in the “Hello World” program, then compile and run it.
  
 b. Add a second print statement that prints a second message after the “Hello World.”. 
 Something witty like, “How are you?” Compile and run the program again.
  
 c. Add a comment line to the program (anywhere) and recompile it. Run the pro-gram 
 again. The new comment should not affect the execution of the program.
  
 This exercise may seem trivial, but it is the starting place for many of the programs we 
 will work with. In order to debug with confidence, you have to have confidence in your 
 programming environment. In some environments, it is easy to lose track of which 
 program is executing, and you might find yourself trying to debug one program while you 
 are accidentally executing another. Adding (and changing) print statements is a simple 
 way to establish the connection between the program you are looking at and the output 
 when the program runs.
  
 Exercise 1.3
  
 It is a good idea to commit as many errors as you can think of, so that you see what error 
 messages the compiler produces. Sometimes the compiler will tell you exactly what is 
 wrong, and all you have to do is fix it. Sometimes, though, the compiler will produce 
 wildly misleading messages. You will develop a sense for when you can trust the compiler 
 and when you have to figure things out yourself.
  
 a. Remove the closing curly-bracket (}).
  
 b. Remove the opening curly-bracket ({).
  
 c. Remove the int before main.",NA
Chapter 2 ,NA,NA
Variables and types,NA,NA
2.1 ,NA,NA
More output ,"As I mentioned in the last chapter, you can put as many statements as you want
  
 in main(). For example, to output more than one line:
  
 #include <stdio.h>
  
 #include <stdlib.h>
  
 /* main: generate some simple output */
  
 int main (void) 
  
 { 
  
  
 printf (""Hello World.\n""); 
  
 printf (""How are you?\n""); 
  
 return (EXIT_SUCCESS); 
  
 }
  
 /* output one line */ 
  
 /* output another line */
  
 As you can see, it is legal to put comments at the end of a line, as well as on a line 
 by themselves.
  
 The phrases that appear in quotation marks are called
  strings
 , because they are 
 made up of a sequence (string) of letters. Actually, strings can contain any 
 combination of letters, numbers, punctuation marks, and other special charac-
 ters.
  
 Often it is useful to display the output from multiple output statements all on one 
 line. You can do this by leaving out the
  \
 n from the first printf: 
  
  
 int main (void) 
  
  
 { 
  
   
 printf (""Goodbye, ""); 
  
   
 printf (""cruel world!\n"");",NA
2.2 Values,"Computer programs operate on values stored in computer memory. A value—
 like a letter or a number— is one of the fundamental things that a program 
 manipulates. The only values we have manipulated so far are the strings we 
 have been outputting, like ""Hello, world."". You (and the compiler) can identify 
 these string values because they are enclosed in quotation marks.
  
 There are different kinds of values, including integers and characters. It is im-
 portant for the program to know exactly what kind of value is manipulated 
 because not all manipulations will make sense on all values. We therefore dis-
 tinguish between different
  types
  of values.
  
 An integer is a whole number like 1 or 17. You can output integer values in a 
 similar way as you output strings:
  
 printf(""%i\n"", 17);
  
 When we look at the printf() statement more closely, we notice that the value 
 we are outputting no longer appears inside the quotes, but behind them 
 separated by comma. The string is still there, but now contains a %i instead of 
 any text. The %i a placeholder that tells the printf() command to print",NA
2.3 ,NA,NA
Variables,"One of the most powerful features of a programming language is the ability to 
 manipulate values through the use of
  variables
 . So far the values that we have 
 used in our statements where fixed to what was written in the statement. Now 
 we will use a variable as a named location that stores a value.
  
 Just as there are different types of values (integer, character, etc.), there are 
 different types of variables. When you create a new variable, you have to declare 
 what type it is. 
  
 For example, the character type in C is called char. 
  
 The 
 following statement creates a new variable named fred that has type char.
  
 char fred;
  
 This kind of statement is called a
  declaration
 .
  
 The type of a variable determines what kind of values it can store. A char 
 variable can contain characters, and it should come as no surprise that int 
 variables can store integers.
  
 Contrary to other programming languages, C does not have a dedicated variable 
 type for the storage of string values. We will see in a later chapter how string 
 values are stored in C.
  
 To create an integer variable, the syntax is
  
 int bob;
  
 where bob is the arbitrary name you choose to identify the variable. In general, 
 you will want to make up variable names that indicate what you plan to do with 
 the variable. For example, if you saw these variable declarations:
  
 char first_letter; 
  
 char last_letter; 
  
 int hour, minute;
  
 you could probably make a good guess at what values would be stored in them. 
 This example also demonstrates the syntax for declaring multiple variables with 
 the same type: hour and minute are both integers (int type).",NA
2.4 Assignment,"Now that we have created some variables, we would like to store values in them. 
 We do that with an
  assignment statement
 .
  
 first_letter = ’a’; hour = 
 11; 
  
 minute = 59;
  
 /* give first_letter the value ’a’ */ /* assign the 
 value 11 to hour */ 
  
 /* set minute to 59 */
  
 This example shows three assignments, and the comments show three different 
 ways people sometimes talk about assignment statements. The vocabulary can 
 be confusing here, but the idea is straightforward:
  
 •
  When you declare a variable, you create a named storage location.
  
 •
  When you make an assignment to a variable, you give it a value.
  
 A common way to represent variables on paper is to draw a box with the name 
 of the variable on the outside and the value of the variable on the inside. This 
 kind of figure is called a
  state diagram
  because is shows what state each 
 variable is in (you can think of it as the variable’s “state of mind”). This diagram 
 shows the effect of the three assignment statements:
  
 first_letter
  
 hour
  
 minute
  
  
 a
  
  
  
 11
  
  
  
 59
  
  
 When we assign values to variables, we have to make sure that the assigned 
 value correspondents to the type of the variable. In C a variable has to have the 
 same type as the value you assign. For example, you cannot store a string in an 
 int variable. The following statement generates a compiler warning:
  
 int hour; 
  
 hour = ""Hello."";
  
 /* WRONG !! */
  
 This rule is sometimes a source of confusion, because there are many ways that 
 you can convert values from one type to another, and C sometimes converts 
 things automatically. But for now you should remember that as a general rule 
 variables and values have the same type, and we’ll talk about special cases later.
  
 Another source of confusion is that some strings
  look
  like integers, but they are 
 not. For example, the string ""123"", which is made up of the characters 1, 2 and 3, 
 is not the same thing as the
  number
  123. This assignment is illegal:
  
 minute = ""59""; 
  
 /* WRONG!! */",NA
2.5,NA,NA
Outputting variables,"You can output the value of a variable using the same commands we used to 
 output simple values.
  
 int hour, minute; 
  
 char colon;
  
 hour = 11; 
  
 minute = 59; 
  
 colon = ’:’;
  
 printf (""The current time is ""); 
  
 printf (""%i"", hour); 
  
 printf (""%c"", colon); 
  
 printf (""%i"", minute); 
  
 printf (""\n"");
  
 This program creates two integer variables named hour and minute, and a 
 character variable named colon. It assigns appropriate values to each of the 
 variables and then uses a series of output statements to generate the following:
  
 The current time is 11:59
  
 When we talk about “outputting a variable,” we mean outputting the
  value
  of the 
 variable. The name of a variable only has significance for the programmer. The 
 compiled program no longer contains a human readable reference to the 
 variable name in your program.
  
 The 
  
 printf() command is capable of outputting several variables in a single 
 statement. To do this, we need to put placeholders in the so called
  format string
 , 
 that indicate the position where the variable value will be put. 
  
 The 
 variables will be inserted in the order of their appearance in the statement. It is 
 important to observe the right order and type for the variables.
  
 By using a single output statement, we can make the previous program more 
 concise:
  
 int hour, minute; 
  
 char colon;
  
 hour = 11; 
  
 minute = 59; 
  
 colon = ’:’;
  
 printf (""The current time is %i%c%i\n"", hour, colon, minute);
  
 On one line, this program outputs a string, two integers and a character. Very 
 impressive!",NA
2.6,NA,NA
Keywords,"A few sections ago, I said that you can make up any name you want for your 
 variables, but that’s not quite true. There are certain words that are reserved in 
 C because they are used by the compiler to parse the structure of your program, 
 and if you use them as variable names, it will get confused. These words, called 
 keywords
 , include int, char, void and many more.
  
 Reserved keywords in the C language
  
  
 auto
  
 double
  
 inline
  
 sizeof
  
 volatile
  
 break
  
 else
  
 int
  
 static
  
 while
  
 case
  
 enum
  
 long
  
 struct
  
 _Bool
  
 char
  
 extern
  
 register
  
 switch
  
 _Complex
  
 const
  
 float
  
 restrict
  
 typedef
  
 _Imaginary
  
 continue
  
 for
  
 return
  
 union
  
 default
  
 goto
  
 short
  
 unsigned
  
 do
  
 if
  
 signed
  
 void
  
  
 The complete list of keywords is included in the C Standard, which is the official 
 language definition adopted by the the International Organization for Standard-
 ization (ISO) on September 1, 1998.
  
 Rather than memorize the list, I would suggest that you take advantage of a 
 feature provided in many development environments: code highlighting. 
  
 As 
 you type, different parts of your program should appear in different colors. For 
 example, keywords might be blue, strings red, and other code black. If you type a 
 variable name and it turns blue, watch out! You might get some strange behavior 
 from the compiler.",NA
2.7 Operators,"Operators
  are special symbols that are used to represent simple computations 
 like addition and multiplication. Most of the operators in C do exactly what you 
 would expect them to do, because they are common mathematical symbols. For 
 example, the operator for adding two integers is +.
  
 The following are all legal C expressions whose meaning is more or less obvious:
  
 1+1
  
 hour-1
  
 hour*60+minute
  
 minute/60
  
 Expressions
  can contain both variables names and values. In each case the 
 name of the variable is replaced with its value before the computation is per-
 formed.
  
 Addition, subtraction and multiplication all do what you expect, but you might be 
 surprised by division. For example, the following program:",NA
2.8 ,NA,NA
Order of operations,"When more than one operator appears in an expression the order of evaluation 
 depends on the rules of
  precedence
 . A complete explanation of precedence can 
 get complicated, but just to get you started:
  
 •
  Multiplication and division happen before addition and subtraction. So 2*3-1 yields 
 5, not 4, and 2/3-1 yields -1, not 1.
  
 •
  If the operators have the same precedence they are evaluated from left to 
 right. So in the expression minute*100/60, the multiplication happens 
 first, yielding 5900/60, which in turn yields 98. If the operations had gone 
 from right to left, the result would be 59*1 which is 59, which is wrong.
  
 •
  Any time you want to override the rules of precedence (or you are not sure 
 what they are) you can use parentheses. Expressions in parentheses are 
 evaluated first, so 2*(3-1) is 4. You can also use parentheses to make an",NA
2.9,NA,NA
Operators for characters,"Interestingly, the same mathematical operations that work on integers also work 
 on characters. For example,
  
 char letter; 
  
 letter = ’a’ + 1; 
  
 printf (""%c\n"", letter);
  
 outputs the letter b. Although it is syntactically legal to multiply characters, it is 
 almost never useful to do it.
  
 Earlier I said that you can only assign integer values to integer variables and 
 character values to character variables, but that is not completely true. In some 
 cases, C converts automatically between types. For example, the following is 
 legal.
  
 int number; 
  
 number = ’a’; 
  
 printf (""%i\n"", number);
  
 The result is 97, which is the number that is used internally by C to represent 
 the letter ’a’. However, it is generally a good idea to treat characters as 
 characters, and integers as integers, and only convert from one to the other if 
 there is a good reason.
  
 Automatic type conversion is an example of a common problem in designing a 
 programming language, which is that there is a conflict between
  formalism
 , 
 which is the requirement that formal languages should have simple rules with 
 few exceptions, and
  convenience
 , which is the requirement that programming 
 languages be easy to use in practice.
  
 More often than not, convenience wins, which is usually good for expert pro-
 grammers, who are spared from rigorous but unwieldy formalism, but bad for 
 beginning programmers, who are often baffled by the complexity of the rules 
 and the number of exceptions. In this book I have tried to simplify things by 
 emphasizing the rules and omitting many of the exceptions.",NA
2.10 ,NA,NA
Composition,"So far we have looked at the elements of a programming language—variables, 
 expressions, and statements—in isolation, without talking about how to 
 combine them.
  
 One of the most useful features of programming languages is their ability to take 
 small building blocks and
  compose
  them. For example, we know how to 
 multiply integers and we know how to output values; it turns out we can do both 
 at the same time:
  
 printf (""%i\n"", 17 * 3);",NA
2.11 ,NA,NA
Glossary,"variable:
  A named storage location for values. All variables have a type, which 
  
 determines which values it can store.
  
 value:
  A letter, or number, or other thing that can be stored in a variable.
  
 type:
  The meaning of values. The types we have seen so far are integers (int 
  
 in C) and characters (char in C).
  
 keyword:
  A reserved word that is used by the compiler to parse programs. 
  
 Examples we have seen include int, void and char.
  
 statement:
  A line of code that represents a command or action. So far, the 
 statements we have seen are declarations, assignments, and output state-
 ments.
  
 declaration:
  A statement that creates a new variable and determines its type.
  
 assignment:
  A statement that assigns a value to a variable.
  
 expression:
  A combination of variables, operators and values that represents a 
 single result value. Expressions also have types, as determined by their 
 operators and operands.
  
 operator:
  A special symbol that represents a simple computation like addition 
  
 or multiplication.
  
 operand:
  One of the values on which an operator operates.",NA
2.12 ,NA,NA
Exercises,"Exercise 2.1
  
 a. Create a new program named MyDate.c. Copy or type in something like the 
  
 ""Hello, World"" program and make sure you can compile and run it.
  
 b. Following the example in Section 2.5, write a program that creates variables 
  
 named day, month and year What type is each variable?
  
 Assign values to those variables that represent today’s date.
  
 c. Print the value of each variable on a line by itself. This is an intermediate step 
  
 that 
 is useful for checking that everything is working so far.
  
 d. Modify the program so that it prints the date in standard American form: 
  
 mm/dd/yyyy.
  
 e. Modify the program again so that the total output is:
  
 American format: 
  
 3/18/2009 
  
 European format: 
  
 18.3.2009
  
 The point of this exercise is to use the output function printf to display values with 
 different types, and to practice developing programs gradually by adding a few 
 statements at a time.
  
 Exercise 2.2
  
 a. Create a new program called MyTime.c. From now on, I won’t remind you to 
  
 start 
 with a small, working program, but you should.
  
 b. Following the example in Section 2.7, create variables named hour, minute and 
 second, and assign them values that are roughly the current time. Use a 24-hour 
 clock, so that at 2pm the value of hour is 14.
  
 c. Make the program calculate and print the number of seconds since midnight.
  
 d. Make the program calculate and print the number of seconds remaining in the 
  
 day.
  
 e. Make the program calculate and print the percentage of the day that has passed.
  
 f. Change the values of hour, minute and second to reflect the current time (I assume 
 that some time has elapsed), and check to make sure that the program works 
 correctly with different values.",NA
Chapter 3,NA,NA
Function,NA,NA
3.1 ,NA,NA
Floating-point,"In the last chapter we had some problems dealing with numbers that were not 
 integers. We worked around the problem by measuring percentages instead of 
 fractions, but a more general solution is to use floating-point numbers, which 
 can represent fractions as well as integers. In C, there are two floating-point 
 types, called float and double. In this book we will use doubles exclusively.
  
 You can create floating-point variables and assign values to them using the same 
 syntax we used for the other types. For example:
  
 double pi; 
  
 pi = 3.14159;
  
 It is also legal to declare a variable and assign a value to it at the same time:
  
 int x = 1; 
  
 char first_char = ""a""; 
  
 double pi = 3.14159;
  
 In fact, this syntax is quite common. A combined declaration and assignment is 
 sometimes called an
  initialization
 .
  
 Although floating-point numbers are useful, they are often a source of confusion 
 because there seems to be an overlap between integers and floating-point num-
 bers. For example, if you have the value 1, is that an integer, a floating-point 
 number, or both?
  
 Strictly speaking, C distinguishes the integer value 1 from the floating-point value 
 1.0, even though they seem to be the same number. 
  
 They belong to 
 different types, and strictly speaking, you are not allowed to make assignments 
 between types. For example, the following is illegal:
  
 int x = 1.1;",NA
3.2 Constants,"In the previous section we have assigned the value 3.14159 to a floating point 
 variable. An important thing to remember about variables is, that they can hold– 
 as their name implies – different values at different points in your program. For 
 example, we could assign the value 3.14159 to the variable pi now and assign 
 some other value to it later on:
  
 double pi = 3.14159;
  
 ...
  
 pi = 10.999; /* probably a logical error in your program */
  
 The second value is probably not what you intended when you first created the 
 named storage location pi . The value for
  π
  is constant and does not change over 
 time. Using the storage location pi to hold arbitrary other values can cause some 
 very hard to find bugs in your program.
  
 C allows you to specify the static nature of storage locations through the use of 
 the keyword const. It must be used in conjunction with the required type of the 
 constant. A value will be assigned at initialisation but can never be changed 
 again during the runtime of the program.",NA
3.3 ,NA,NA
Converting from,NA,NA
 double,NA,NA
 to,NA,NA
 int,"As I mentioned, C converts ints to doubles automatically if necessary, because no 
 information is lost in the translation. On the other hand, going from a double to 
 an int requires rounding off. C doesn’t perform this operation automatically, in 
 order to make sure that you, as the programmer, are aware of the loss of the 
 fractional part of the number.
  
 The simplest way to convert a floating-point value to an integer is to use a 
 typecast
 . Typecasting is so called because it allows you to take a value that 
 belongs to one type and “cast” it into another type (in the sense of molding or 
 reforming, not throwing).
  
 The syntax for typecasting requires the explicit specification of the target type, set 
 in parenthesis before the expression (Type). For example:
  
 const double PI = 3.14159; 
  
 int x = (int) PI;
  
 The (int) operator casts the value of PI into an integer, so x gets the value 3. 
 Converting to an integer always rounds down, even if the fraction part is 
 0.99999999.
  
 For every type in C, there is a corresponding operator that typecasts its argu-ment 
 to the appropriate type.",NA
3.4 ,NA,NA
Math functions,"In mathematics, you have probably seen functions like sin and log, and you have 
 learned to evaluate expressions like sin(
 π/
 2) and log(1
 /x
 ). First, you evaluate 
 the expression in parentheses, which is called the
  argument
  of the function. For 
 example,
  π/
 2 is approximately 1.571, and 1
 /x
  is 0.1 (if
  x
  happens to be 10).
  
 Then you can evaluate the function itself, either by looking it up in a table or by 
 performing various computations. The sin of 1.571 is 1, and the log of 0.1 is-1 
 (assuming that log indicates the logarithm base 10).
  
 This process can be applied repeatedly to evaluate more complicated 
 expressions like log(1
 /
  sin(
 π/
 2)). First we evaluate the argument of the 
 innermost function, then evaluate the function, and so on.",NA
3.5 Composition,"Just as with mathematical functions, C functions can be
  composed
 , meaning that 
 you use one expression as part of another. For example, you can use any 
 expression as an argument to a function:
  
 double x = cos (angle + PI/2);
  
 This statement takes the value of PI, divides it by two and adds the result to the 
 value of angle. The sum is then passed as an argument to the cos function.
  
 You can also take the result of one function and pass it as an argument to 
 another:
  
 double x = exp (log (10.0));
  
 This statement finds the log base
  e
  of 10 and then raises
  e
  to that power. The 
 result gets assigned to x; I hope you know what it is.",NA
3.6,NA,NA
Adding new functions,"So far we have only been using the functions that are built into C, but it is also 
 possible to add new functions. Actually, we have already seen one function 
 definition: main(). The function named main() is special because it indicates 
 where the execution of the program begins, but the syntax for main() is the same 
 as for any other function definition:
  
 void NAME ( LIST OF PARAMETERS ) 
  
 { 
  
  
 STATEMENTS 
  
 }
  
 You can make up any name you want for your function, except that you can’t call it 
 main or any other C keyword. 
  
 The list of parameters specifies what 
 information, if any, you have to provide in order to use (or
  call
 ) the new function.
  
 main() doesn’t take any parameters, as indicated by the parentheses containing 
 the keyword (void) in it’s definition. The first couple of functions we are going to 
 write also have no parameters, so the syntax looks like this:
  
 void PrintNewLine (void) 
  
 { 
  
  
 printf (""\n""); 
  
 }
  
 This function is named PrintNewLine(). It contains only a single statement, which 
 outputs a newline character. 
  
 Notice that we start the function name 
 with an uppercase letter. The following words of the function name are also 
 capitalized. We will use this convention for the naming of functions consistently 
 throughout the book.
  
 In main() we can call this new function using syntax that is similar to the way we 
 call the built-in C commands:
  
 int main (void) 
  
 { 
  
 printf (""First Line.\n""); 
  
 PrintNewLine (); 
  
 printf (""Second Line.\n""); 
  
 return EXIT_SUCCESS; 
  
 }
  
 The output of this program is:
  
 First line.
  
 Second line.
  
 Notice the extra space between the two lines. What if we wanted more space 
 between the lines? We could call the same function repeatedly:
  
 int main (void) 
  
 { 
  
  
 printf (""First Line.\n"");",NA
3.7,NA,NA
Definitions and uses,"Pulling together all the code fragments from the previous section, the whole 
 program looks like this:
  
 #include <stdio.h> 
  
 #include <stdlib.h>
  
 void PrintNewLine (void) 
  
 { 
  
  
 printf (""\n""); 
  
 }
  
 void PrintThreeLines (void) 
  
 { 
  
  
 PrintNewLine (); 
  
 PrintNewLine (); }
  
 int main (void) 
  
 { 
  
 printf (""First Line.\n""); 
 PrintThreeLines (); 
  
 printf (""Second Line.\n""); return 
 EXIT_SUCCESS; 
  
 }
  
 PrintNewLine ();
  
 This 
  
 program 
  
 contains three
  
 PrintThreeLine(), and main().
  
 function
  
 definitions:
  
 PrintNewLine(),
  
 Inside the definition of main(), there is a statement that uses or calls 
 PrintThreeLine(). Similarly, PrintThreeLine() calls PrintNewLine() three times. 
 Notice that the definition of each function appears above the place where it is 
 used.
  
 This is necessary in C; the definition of a function must appear before (above) 
 the first use of the function. You should try compiling this program with the 
 functions in a different order and see what error messages you get.",NA
3.8 ,NA,NA
Programs with multiple functions,"When you look at the C source code that contains several functions, it is tempt-
 ing to read it from top to bottom, but that is likely to be confusing, because that 
 is not the
  order of execution
  of the program.
  
 Execution always begins at the first statement of main(), regardless of where it 
 is in the program (often it is at the bottom). Statements are executed one at a 
 time, in order, until you reach a function call. Function calls are like a detour in 
 the flow of execution. Instead of going to the next statement, you go to the",NA
3.9 Parameters and arguments,"Some of the built-in functions we have used have
  parameters
 , which are values 
 that you provide to let the function do its job. For example, if you want to find 
 the sine of a number, you have to indicate what the number is. Thus, sin() takes 
 a double value as a parameter.
  
 Some functions take more than one parameter, like pow(), which takes two 
 doubles, the base and the exponent.
  
 Notice that in each of these cases we have to specify not only how many pa-
 rameters there are, but also what type they are. So it shouldn’t surprise you that 
 when you write a function definition, the parameter list indicates the type of 
 each parameter. For example:
  
 void PrintTwice (char phil) 
  
 { 
  
  
 printf(""%c%c\n"", phil, phil); 
  
 }
  
 This function takes a single parameter, named phil, that has type char. What-
 ever that parameter is (and at this point we have no idea what it is), it gets 
 printed twice, followed by a newline. I chose the name phil to suggest that the 
 name you give a parameter is up to you, but in general you want to choose 
 something more illustrative than phil.
  
 In order to call this function, we have to provide a char. For example, we might 
 have a main() function like this:
  
 int main (void) 
  
 { 
  
  
 PrintTwice (’a’); 
  
  
 return EXIT_SUCCESS; 
  
 }",NA
3.10 ,NA,NA
Parameters and variables are local,"Parameters and variables only exist inside their own functions. 
  
 Within the 
 confines of main(), there is no such thing as phil. If you try to use it, the compiler 
 will complain. Similarly, inside PrintTwice() there is no such thing as argument.
  
 Variables like this are said to be
  local
 . In order to keep track of parameters and 
 local variables, it is useful to draw a
  stack diagram
 . Like state diagrams, stack 
 diagrams show the value of each variable, but the variables are contained in 
 larger boxes that indicate which function they belong to.
  
 For example, the stack diagram for PrintTwice() looks like this:
  
 PrintTwice()
  
 main()
  
   
  phil
  
  
 'B'
  
  
  
   
  argument
  
  
 'B'",NA
3.11 ,NA,NA
Functions with multiple parameters,"The syntax for declaring and invoking functions with multiple parameters is a 
 common source of errors. First, remember that you have to declare the type of 
 every parameter. For example
  
 void PrintTime (int hour, int minute) 
  
 { 
  
  
 printf (""%i"", hour); 
  
  
 printf ("":""); 
  
  
 printf (""%i"", minute); 
  
 }
  
 It might be tempting to write (int hour, minute), but that format is only legal for 
 variable declarations, not for parameters.
  
 Another common source of confusion is that you do not have to declare the types 
 of arguments. The following is wrong!
  
 int hour = 11; 
  
 int minute = 59; 
  
 PrintTime (int hour, int minute);
  
 /* WRONG! */
  
 In this case, the compiler can tell the type of hour and minute by looking at their 
 declarations. It is unnecessary and illegal to include the type when you pass 
 them as arguments. The correct syntax is PrintTime (hour, minute);.",NA
3.12 ,NA,NA
Functions with results,"You might have noticed by now that some of the functions we are using, like the 
 math functions, yield results. Other functions, like PrintNewLine, perform an 
 action but don’t return a value. That raises some questions:
  
 •
  What happens if you call a function and you don’t do anything with the 
 result (i.e. you don’t assign it to a variable or use it as part of a larger 
  
 expression)?
  
 •
  What happens if you use a function without a result as part of an expres-sion, like 
 PrintNewLine() + 7?",NA
3.13 ,NA,NA
Glossary,"constant:
  A named storage location similar to a variable, that can not be 
  
 changed once it has been initialised.
  
 floating-point:
  A type of variable (or value) that can contain fractions as well as 
 integers. There are a few floating-point types in C; the one we use in this 
 book is double.
  
 initialization:
  A statement that declares a new variable and assigns a value 
  
 to it 
 at the same time.
  
 function:
  A named sequence of statements that performs some useful function. 
 Functions may or may not take parameters, and may or may not produce a 
 result.
  
 parameter:
  A piece of information you provide in order to call a function. 
 Parameters are like variables in the sense that they contain values and 
 have types.
  
 argument:
  A value that you provide when you call a function. This value must 
  
 have the same type as the corresponding parameter.
  
 call:
  Cause a function to be executed.",NA
3.14 ,NA,NA
Exercises,"Exercise 3.1
  
 The point of this exercise is to practice reading code and to make sure that you understand 
 the flow of execution through a program with multiple functions.
  
 a. What is the output of the following program? Be precise about where there are spaces 
 and where there are newlines.
  
 HINT: Start by describing in words what Ping() and Baffle() do when they are 
 invoked.
  
 #include <stdio.h>
  
 #include <stdlib.h>
  
 void Ping ()
  
 {
  
 printf ("".\n"");
  
 }",NA
Chapter 4,NA,NA
Conditionals and recursion,NA,NA
4.1 ,NA,NA
Conditional execution,"In order to write useful programs, we almost always need the ability to check
  
 certain conditions and change the behavior of the program accordingly.
  Condi-
  
 tional statements
  give us this ability. The simplest form is the if statement:
  
 if (x > 0)
  
 {
  
 printf (""x is positive\n"");
  
 }
  
 The expression in parentheses is called the condition. If it is true, then the
  
 statements in brackets get executed. If the condition is not true, nothing hap-
  
 pens.
  
 The condition can contain any of the
  comparison operators
 :
  
 x == y 
  
 /* x equals y */
  
 x != y 
  
 /* x is not equal to y */
  
 x > y 
  
 /* x is greater than y */
  
 x < y 
  
 /* x is less than y */
  
 x >= y 
  
 /* x is greater than or equal to y */
  
 x <= y 
  
 /* x is less than or equal to y */
  
 Although these operations are probably familiar to you, the syntax C uses is a
  
 little different from mathematical symbols like =,
  ̸
 = and
  ≤
 . A common error is to use a 
 single = instead of a double ==. Remember that = is the assignment
  
 operator, and == is a comparison operator. Also, there is no such thing as =<
  
 or =>.
  
 The two sides of a condition operator have to be the same type. You can only
  
 compare ints to ints and doubles to doubles. Unfortunately, at this point
  
 you can’t compare strings at all! There is a way to compare strings, but we
  
 won’t get to it for a couple of chapters.",NA
4.2,NA,NA
The modulus operator,"The modulus operator works on integers (and integer expressions) and yields 
 the 
 remainder
  when the first operand is divided by the second. In C, the modulus 
 operator is a percent sign, %. 
  
 The syntax is exactly the same as for other 
 operators:
  
 int quotient = 7 / 3; 
  
 int remainder = 7 % 3;
  
 The first operator, integer division, yields 2. 
 Thus, 7 divided by 3 is 2 with 1 left over.
  
 The second operator yields 1.
  
 The modulus operator turns out to be surprisingly useful. For example, you can 
 check whether one number is divisible by another: if x % y is zero, then x is 
 divisible by y.
  
 Also, you can use the modulus operator to extract the rightmost digit or digits 
 from a number. For example, x % 10 yields the rightmost digit of x (in base 10). 
 Similarly x % 100 yields the last two digits.",NA
4.3 Alternative execution,"A second form of conditional execution is alternative execution, in which there 
 are two possibilities, and the condition determines which one gets executed. The 
 syntax looks like:
  
 if (x%2 == 0) 
  
 { 
  
  
 printf (""x is even\n""); 
  
 } 
  
 else 
  
 { 
  
  
 printf (""x is odd\n""); 
  
 }
  
 If the remainder when x is divided by 2 is zero, then we know that x is even, and 
 this code displays a message to that effect. If the condition is false, the second set 
 of statements is executed. Since the condition must be true or false, exactly one 
 of the alternatives will be executed.
  
 As an aside, if you think you might want to check the parity (evenness or 
 oddness) of numbers often, you might want to “wrap” this code up in a function, 
 as follows:
  
 void PrintParity (int x) 
  
 { 
  
  
 if (x%2 == 0) 
  
  
 { 
  
  
 printf (""x is even\n""); 
  
  
 }",NA
4.4 ,NA,NA
Chained conditionals,"Sometimes you want to check for a number of related conditions and choose one 
 of several actions. One way to do this is by
  chaining
  a series of ifs and elses:
  
 if (x > 0) 
  
 { 
  
  
 printf (""x is positive\n""); 
  
 } 
  
 else if (x < 0) 
  
 { 
  
  
 printf (""x is negative\n""); 
  
 } 
  
 else 
  
 { 
  
  
 printf (""x is zero\n""); 
  
 }
  
 These chains can be as long as you want, although they can be difficult to read if 
 they get out of hand. One way to make them easier to read is to use standard 
 indentation, as demonstrated in these examples. If you keep all the statements 
 and squiggly-braces lined up, you are less likely to make syntax errors and you 
 can find them more quickly if you do.",NA
4.5 ,NA,NA
Nested conditionals,"In addition to chaining, you can also nest one conditional within another. We 
 could have written the previous example as:
  
 if (x == 0) 
  
 {",NA
4.6 The,NA,NA
 return,NA,NA
 statement,"The return statement allows you to terminate the execution of a function before 
 you reach the end. One reason to use it is if you detect an error condition:
  
 #include <math.h>
  
 void PrintLogarithm (double x) 
  
 { 
  
  
 if (x <= 0.0) 
  
  
 { 
  
  
 printf (""Positive numbers only, please.\n""); 
  
 return; 
  
  
 }
  
 }
  
 double result = log (x); 
  
 printf (""The log of x is %f\n"", result);
  
 This defines a function named PrintLogarithm() that takes a double named x as 
 a parameter. The first thing it does is check whether x is less than or equal to 
 zero, in which case it displays an error message and then uses return to exit",NA
4.7 ,NA,NA
Recursion,"I mentioned in the last chapter that it is legal for one function to call another, 
 and we have seen several examples of that. I neglected to mention that it is also 
 legal for a function to call itself. It may not be obvious why that is a good thing, 
 but it turns out to be one of the most magical and interesting things a program 
 can do.
  
 For example, look at the following function:
  
 void Countdown (int n) 
  
 { 
  
  
 if (n == 0) 
  
  
 { 
  
  
  
 printf (""Blastoff!""); 
  
  
 } 
  
  
 else 
  
  
 { 
  
  
  
 printf (""%i"", n); 
  
  
  
 Countdown (n-1); 
  
  
 } 
  
 }
  
 The name of the function is Countdown() and it takes a single integer as a 
 parameter. If the parameter is zero, it outputs the word “Blastoff.” Otherwise, it 
 outputs the parameter and then calls a function named Countdown()—itself—
 passing n-1 as an argument.
  
 What happens if we call this function like this:
  
 int main (void) 
  
 { 
  
 Countdown (3); 
  
 return EXIT_SUCCESS; 
  
 }
  
 The execution of Countdown() begins with n=3, and since n is not zero, it outputs 
 the value 3, and then calls itself...
  
 The execution of Countdown() begins with n=2, and since n is not 
 zero, it outputs the value 2, and then calls itself...",NA
4.8,NA,NA
Infinite recursion,"In the examples in the previous section, notice that each time the functions get 
 called recursively, the argument gets smaller by one, so eventually it gets to 
 zero. When the argument is zero, the function returns immediately,
  without 
 making any recursive calls
 . This case—when the function completes without 
 making a recursive call—is called the
  base case
 .
  
 If a recursion never reaches a base case, it will go on making recursive calls 
 forever and the program will never terminate. This is known as
  infinite re-
 cursion
 , and it is generally not considered a good idea.
  
 In most programming environments, a program with an infinite recursion will 
 not really run forever. Eventually, something will break and the program will 
 report an error. This is the first example we have seen of a run-time error (an 
 error that does not appear until you run the program).
  
 You should write a small program that recurses forever and run it to see what 
 happens.",NA
4.9 ,NA,NA
Stack diagrams for recursive functions,"In the previous chapter we used a stack diagram to represent the state of a 
 program during a function call. The same kind of diagram can make it easier to 
 interpret a recursive function.
  
 Remember that every time a function gets called it creates a new instance that 
 contains the function’s local variables and parameters.
  
 This figure shows a stack diagram for Countdown, called with n = 3:
  
 Countdown()
  
 Countdown()
  
 Countdown()
  
 Countdown()
  
 main()
  
   
  n
  
  
 0
  
  
  
   
  n
  
  
 1
  
  
  
   
  n
  
  
 2
  
  
  
   
  n
  
  
 3
  
  
  
  
  
      
 There is one instance of main() and four instances of Countdown(), each with a 
 different value for the parameter n. The bottom of the stack, Countdown()",NA
4.10 ,NA,NA
Glossary,"modulus:
  An operator that works on integers and yields the remainder when 
 one number is divided by another. In C it is denoted with a percent sign 
 (%).
  
 conditional:
  A block of statements that may or may not be executed depend-
  
 ing on some condition.
  
 chaining:
  A way of joining several conditional statements in sequence.
  
 nesting:
  Putting a conditional statement inside one or both branches of an-
  
 other conditional statement.
  
 recursion:
  The process of calling the same function you are currently execut-
  
 ing.
  
 infinite recursion:
  A function that calls itself recursively without every reach-
 ing the base case. Eventually an infinite recursion will cause a run-time 
 error.",NA
4.11 ,NA,NA
Exercises,"Exercise 4.1 
  
 This exercise reviews the flow of execution through a program with 
 multiple methods. Read the following code and answer the questions below.
  
 #include <stdio.h> 
  
 #include <stdlib.h>
  
 void Zippo (int quince, int flag);
  
 void Baffle (int output) 
  
 { 
  
    
 printf (""%i\n"",output); 
  
    
 Zippo (12, -5); 
  
   
 }
  
 void Zippo (int quince, int flag) 
  
 { 
  
  
 if (flag < 0) 
  
  
 { 
  
  
  
 printf (""%i zoop\n"", quince);",NA
Chapter 5,NA,NA
Fruitful functions,NA,NA
5.1 ,NA,NA
Return values,"Some of the built-in functions we have used, like the math functions, have 
 produced results. That is, the effect of calling the function is to generate a new 
 value, which we usually assign to a variable or use as part of an expression. For 
 example:
  
 double e = exp (1.0); 
  
 double height = radius * sin (angle);
  
 But so far all the functions we have written have been
  void
  functions; that is, 
 functions that return no value. When you call a void function, it is typically on a 
 line by itself, with no assignment:
  
 PrintLines (3); 
  
 Countdown (n-1);
  
 In this chapter, we are going to write functions that return things, which I will 
 refer to as
  fruitful
  functions, for want of a better name. The first example is 
 area, which takes a double as a parameter, and returns the area of a circle with 
 the given radius:
  
 double Area (double radius) 
  
 { 
  
  
 double pi = acos (-1.0); 
  
  
 double area = pi * radius * radius; 
  
  
 return area; 
  
 }
  
 The first thing you should notice is that the beginning of the function definition 
 is different. Instead of void, which indicates a void function, we see double, 
 which indicates that the return value from this function will have type double.
  
 Also, notice that the last line is an alternate form of the return statement that 
 includes a return value. This statement means, “return immediately from this",NA
5.2 ,NA,NA
Program development,"At this point you should be able to look at complete C functions and tell what 
 they do. But it may not be clear yet how to go about writing them. I am going to 
 suggest one technique that I call
  incremental development
 .
  
 As an example, imagine you want to find the distance between two points, given 
 by the coordinates (
 x
 1
 , y
 1
 ) and (
 x
 2
 , y
 2
 ). By the usual definition,
  
 distance
  = 
  
 (
 x
 2
  − x
 1
 )
 2
 + (
 y
 2
  − y
 1
 )
 2 
  
 (5.1)
  
 The first step is to consider what a Distance function should look like in C. In 
 other words, what are the inputs (parameters) and what is the output (return 
 value).
  
 In this case, the two points are the parameters, and it is natural to represent 
 them using four doubles. The return value is the distance, which will have type 
 double.
  
 Already we can write an outline of the function:",NA
5.3 ,NA,NA
Composition,"As you should expect by now, once you define a new function, you can use it as 
 part of an expression, and you can build new functions using existing functions. 
 For example, what if someone gave you two points, the center of the circle and a 
 point on the perimeter, and asked for the area of the circle?
  
 Let’s say the center point is stored in the variables xc and yc, and the perimeter 
 point is in xp and yp. The first step is to find the radius of the circle, which is the 
 distance between the two points. Fortunately, we have a function, Distance(), 
 that does that.
  
 double radius = Distance (xc, yc, xp, yp);
  
 The second step is to find the area of a circle with that radius, and return it.",NA
5.4 Boolean values,"The types we have seen so far can hold very large values. There are a lot of 
 integers in the world, and even more floating-point numbers. By comparison, 
 the set of characters is pretty small. Well, many computing languages implement 
 an even more fundamental type that is even smaller. It is called
  _Bool
 , and the 
 only values in it are true and false.
  
 Unfortunately, earlier versions of the C standard did not implement boolean as a 
 separate type, but instead used the integer values 0 and 1 to represent truth 
 values. By convention 0 represents false and 1 represents true. Strictly speaking 
 C interpretes any integer value different from 0 as true. This can be a source of 
 error if you are testing a value to be true by comparing it with 1.
  
 Without thinking about it, we have been using boolean values in the last of 
 chapter. The condition inside an if statement is a boolean expression. Also, the 
 result of a comparison operator is a boolean value. For example:
  
 if (x == 5) 
  
 { 
  
  
 /* do something*/ 
  
 }
  
 The operator == compares two integers and produces a boolean value.
  
 Pre C99 has no keywords for the expression of true or false. A lot of programs 
 instead are using C preprocessor definitions anywhere a boolean expression is 
 called for. For example,
  
 #define FALSE 0 
  
 #define TRUE 1 
  
 ...
  
 if (TRUE) 
  
 {",NA
5.5 ,NA,NA
Boolean variables,"Since boolean values are not supported directly in C, we can not declare 
 variables of the type boolean. Instead, programmers typically use the short 
 datatype in combination with preprocessor definitions to store truth values.
  
 #define FALSE 0 
  
 #define TRUE 1 
  
 ...
  
 short fred; 
  
 fred = TRUE; 
  
 short testResult = FALSE;
  
 The first line is a simple variable declaration; the second line is an assignment, 
 and the third line is a combination of a declaration and as assignment, called an 
 initialization.
  
 As I mentioned, the result of a comparison operator is a boolean, so you can store 
 it in a variable
  
 short evenFlag = (n%2 == 0); short 
 positiveFlag = (x > 0);
  
 /* true if n is even */ 
  
 /* true if x is positive */
  
 and then use it as part of a conditional statement later
  
 if (evenFlag)
  
 {
  
 printf(""n was even when I checked it"");
  
 }
  
 A variable used in this way is called a
  flag
 , since it flags the presence or absence of 
 some condition.",NA
5.6 ,NA,NA
Logical operators,"There are three
  logical operators
  in C: AND, OR and NOT, which are denoted by 
 the symbols &&, || and !. The semantics (meaning) of these operators is similar 
 to their meaning in English. For example x > 0 && x < 10 is true only if x is 
 greater than zero AND less than 10.
  
 evenFlag || n%3 == 0 is true if
  either
  of the conditions is true, that is, if evenFlag is 
 true OR the number is divisible by 3.
  
 Finally, the NOT operator has the effect of negating or inverting a bool ex-
 pression, so !evenFlag is true if evenFlag is false; that is, if the number is odd.",NA
5.7 Bool functions,"It is sometimes appropriate for functions to return boolean values just like any 
 other return type. This is is especially convenient for hiding complicated tests 
 inside functions. For example:
  
 int IsSingleDigit (int x) 
  
 { 
  
 if (x >= 0 && x < 10) 
  
 { 
  
  
 return TRUE; 
  
 } 
  
 else 
  
 { 
  
  
 return FALSE; 
  
 } 
  
 }
  
 The name of this function is IsSingleDigit(). It is common to give such test 
 functions names that sound like yes/no questions. The return type is int, which 
 means that again we need to follow the agreement that 0 represents false and 1 
 represents true. Every return statement has to follow this convention, again, we 
 are using preprocessor definitions.
  
 The code itself is straightforward, although it is a bit longer than it needs to be. 
 Remember that the expression x >= 0 && x < 10 is evaluated to a boolean value, 
 so there is nothing wrong with returning it directly, and avoiding the if 
 statement altogether:
  
 int IsSingleDigit (int x) 
  
 { 
  
 return (x >= 0 && x < 10); 
  
 }
  
 In main() you can call this function in the usual ways:
  
 printf(""%i\n"", IsSingleDigit (2)); 
  
 short bigFlag = !IsSingleDigit (17);",NA
5.8 ,NA,NA
Returning from,NA,NA
 main(),"Now that we know functions that return values, we can look more closely at the 
 return value of the main() function. It’s supposed to return an integer:
  
 int main (void)
  
 The usual return value from main() is 0, which indicates that the program 
 succeeded at whatever it was supposed to to. If something goes wrong, it is 
 common to return -1, or some other value that indicates what kind of error 
 occurred.
  
 C provides two predefined constants EXIT_SUCCESS and EXIT_FAILURE
  
 int main (void) 
  
 { 
  
  
 return EXIT_SUCCESS; }
  
 /*program terminated successfully*/
  
 Of course, you might wonder who this value gets returned to, since we never call 
 main() ourselves. It turns out that when the operating system executes a 
 program, it starts by calling main() in pretty much the same way it calls all the 
 other functions.
  
 There are even some parameters that can be passed to main() by the system, but 
 we are not going to deal with them for a little while, so we define main() as 
 having no parameters: int main (void).",NA
5.9 ,NA,NA
Glossary,"return type:
  The type of value a function returns.
  
 return value:
  The value provided as the result of a function call.",NA
5.10 ,NA,NA
Exercises,"Exercise 5.1 
  
 If you are given three sticks, you may or may not be able to arrange 
 them in a triangle. For example, if one of the sticks is 12 inches long and the other two are 
 one inch long, it is clear that you will not be able to get the short sticks to meet in the 
 middle. For any three lengths, there is a simple test to see if it is possible to form a 
 triangle:
  
 “If any of the three lengths is greater than the sum of the other two, then you 
 cannot form a triangle. Otherwise, you can.”
  
 Write a function named IsTriangle() that it takes three integers as arguments, and that 
 returns either TRUE or FALSE, depending on whether you can or cannot form a triangle 
 from sticks with the given lengths.
  
 The point of this exercise is to use conditional statements to write a function that
  
 returns a value.
  
 Exercise 5.2 
  
 What is the output of the following program?
  
 The purpose of this exercise is to make sure you understand logical operators and the flow 
 of execution through fruitful methods.
  
 #define TRUE 1
  
 #define FALSE 0
  
 short IsHoopy (int x)
  
 {
  
 short hoopyFlag;
  
 if (x%2 == 0)
  
 {",NA
Chapter 6,NA,NA
Iteration,NA,NA
6.1 ,NA,NA
Multiple assignment,"I haven’t said much about it, but it is legal in C to make more than one assign-
 ment to the same variable. The effect of the second assignment is to replace the 
 old value of the variable with a new value.
  
 int fred = 5; 
  
 printf (""%i"", fred); 
  
 fred = 7; 
  
 printf (""%i"", fred);
  
 The output of this program is 57, because the first time we print fred his value is 
 5, and the second time his value is 7.
  
 This kind of
  multiple assignment
  is the reason I described variables as a 
 container
  for values. When you assign a value to a variable, you change the 
 contents of the container, as shown in the figure:
  
 int fred = 5;
  
 fred
  
  
 5
  
  
 fred = 7;
  
 fred
  
  
 5 7
  
  
 When there are multiple assignments to a variable, it is especially important to 
 distinguish between an assignment statement and a statement of equality. Be-
 cause C uses the = symbol for assignment, it is tempting to interpret a statement 
 like a = b as a statement of equality. It is not!
  
 First of all, equality is commutative, and assignment is not. For example, in 
 mathematics if
  a
  = 7 then 7 =
  a
 . But in C the statement a = 7; is legal, and 7 = a; is 
 not.",NA
6.2 Iteration,"One of the things computers are often used for is the automation of repetitive 
 tasks. Repeating identical or similar tasks without making errors is something 
 that computers do well and people do poorly.
  
 In section 4.7 we have seen programs that use
  recursion
  to perform repetition, 
 such as PrintLines() and Countdown(). I now want to introduce a new type of 
 repetition, that is called
  iteration
 , and C provides several language features that 
 make it easier to write repetetive programs.
  
 The two features we are going to look at are the while statement and the for 
 statement.",NA
6.3 The,NA,NA
 while,NA,NA
 statement,"Using a while statement, we can rewrite Countdown():
  
 void Countdown (int n) 
  
 { 
  
  
 while (n > 0) 
  
  
 { 
  
  
 printf (""%i\n"", n); 
  
  
 n = n-1; 
  
  
 } 
  
  
 printf (""Blastoff!\n""); 
  
 }
  
 You can almost read a while statement as if it were English. What this means is, 
 “While n is greater than zero, continue displaying the value of n and then 
 reducing the value of n by 1. When you get to zero, output the word ‘Blastoff!”’
  
 More formally, the flow of execution for a while statement is as follows:",NA
6.4 Tables,"One of the things loops are good for is generating tabular data. For example, 
 before computers were readily available, people had to calculate logarithms, 
 sines and cosines, and other common mathematical functions by hand. 
  
 To 
 make that easier, there were books containing long tables where you could find 
 the values of various functions. Creating these tables was slow and boring, and 
 the result tended to be full of errors.
  
 When computers appeared on the scene, one of the initial reactions was, “This is 
 great! We can use the computers to generate the tables, so there will be no 
 errors.” That turned out to be true (mostly), but shortsighted. Soon thereafter 
 computers and calculators were so pervasive that the tables became obsolete.
  
 Well, almost. It turns out that for some operations, computers use tables of 
 values to get an approximate answer, and then perform computations to 
 improve the approximation. In some cases, there have been errors in the 
 underlying tables, most famously in the table the original Intel Pentium used to 
 perform floating-point division.
  
 Although a “log table” is not as useful as it once was, it still makes a good 
 example of iteration. The following program outputs a sequence of values in the 
 left column and their logarithms in the right column:
  
 double x = 1.0; 
  
 while (x < 10.0) 
  
 { 
  
  
 printf (""%.0f\t%f\n"", x ,log(x)); 
  
  
 x = x + 1.0; 
  
 }
  
 The sequence \t represents a
  tab
  character. 
  
 The sequence \n represents a 
 newline character. They are so called
  escape sequences
  which are used to encode 
 non-printable ASCII-characters. Escape sequences can be included anywhere in a 
 string, although in these examples the sequence is the whole string.
  
 A tab character causes the cursor to shift to the right until it reaches one of the
  
 tab stops
 , which are normally every eight characters. As we will see in a minute, 
 tabs are useful for making columns of text line up. A newline character causes 
 the cursor to move on to the next line.
  
 The output of this program is:",NA
6.5 Two-dimensional tables,"A two-dimensional table is a table where you choose a row and a column and 
 read the value at the intersection. A multiplication table is a good example. Let’s 
 say you wanted to print a multiplication table for the values from 1 to 6.
  
 A good way to start is to write a simple loop that prints the multiples of 2, all on 
 one line.
  
 int i = 1; 
  
 while (i <= 6) { 
  
 printf(""%i i = i + 
 1; } 
  
 printf(""\n"");
  
 "", i*2);
  
 The first line initializes a variable named i, which is going to act as a counter, or
  
 loop variable
 . As the loop executes, the value of i increases from 1 to 6, and 
 then when i is 7, the loop terminates. Each time through the loop, we print the 
 value 2*i followed by three spaces. By omitting the \n from the first output 
 statement, we get all the output on a single line.
  
 The output of this program is:
  
 2
  
 4
  
 6
  
 8
  
 10
  
 12
  
 So far, so good. The next step is to
  encapsulate
  and
  generalize
 .",NA
6.6 Encapsulation and generalization,"Encapsulation usually means taking a piece of code and wrapping it up in a 
 function, allowing you to take advantage of all the things functions are good for. 
 We have seen two examples of encapsulation, when we wrote PrintParity() in 
 Section 4.3 and IsSingleDigit() in Section 5.7.
  
 Generalization means taking something specific, like printing multiples of 2, and 
 making it more general, like printing the multiples of any integer.
  
 Here’s a function that encapsulates the loop from the previous section and 
 generalizes it to print multiples of n.",NA
6.7,NA,NA
Functions,"In the last section I mentioned “all the things functions are good for.” About this 
 time, you might be wondering what exactly those things are. Here are some of 
 the reasons functions are useful:
  
 •
  By giving a name to a sequence of statements, you make your program easier to read 
 and debug.
  
 •
  Dividing a long program into functions allows you to separate parts of the program, 
 debug them in isolation, and then compose them into a whole.
  
 •
  Functions facilitate both recursion and iteration.
  
 •
  Well-designed functions are often useful for many programs. Once you write 
 and debug one, you can reuse it.",NA
6.8 More encapsulation,"To demonstrate encapsulation again, I’ll take the code from the previous section 
 and wrap it up in a function:
  
 void PrintMultTable () 
  
 { 
  
 int i = 1; 
  
 while (i <= 6) 
  
 { 
  
  
 PrintMultiples (i); 
  
  
 i = i + 1; 
  
 } 
  
 }
  
 The process I am demonstrating is a common development plan. You develop 
 code gradually by adding lines to main() or someplace else, and then when you 
 get it working, you extract it and wrap it up in a function.
  
 The reason this is useful is that you sometimes don’t know when you start 
 writing exactly how to divide the program into functions. This approach lets you 
 design as you go along.",NA
6.9 Local variables,"About this time, you might be wondering how we can use the same variable i in 
 both PrintMultiples() and PrintMultTable(). Didn’t I say that you can only 
 declare a variable once? And doesn’t it cause problems when one of the 
 functions changes the value of the variable?",NA
6.10,NA,NA
More generalization,"As another example of generalization, imagine you wanted a program that 
 would print a multiplication table of any size, not just the 6x6 table. You could 
 add a parameter to PrintMultTable():
  
 void PrintMultTable (int high) 
  
 { 
  
  
 int i = 1; 
  
  
 while (i <= high) 
  
  
 { 
  
  
  
 PrintMultiples (i); 
  
  
  
 i = i + 1; 
  
  
 } 
  
 }",NA
6.11 ,NA,NA
Glossary,"loop:
  A statement that executes repeatedly while a condition is true or until 
  
 some condition is satisfied.
  
 infinite loop:
  A loop whose condition is always true.
  
 body:
  The statements inside the loop.
  
 iteration:
  One pass through (execution of) the body of the loop, including the 
  
 evaluation of the condition.
  
 tab:
  A special character, written as \t in C, that causes the cursor to move to 
  
 the next tab stop on the current line.
  
 encapsulate:
  To divide a large complex program into components (like func-
 tions) and isolate the components from each other (for example, by using 
 local variables).
  
 local variable:
  A variable that is declared inside a function and that exists only 
 within that function. Local variables cannot be accessed from outside their 
 home function, and do not interfere with any other functions.
  
 generalize:
  To replace something unnecessarily specific (like a constant value) 
 with something appropriately general (like a variable or parameter). Gen-
 eralization makes code more versatile, more likely to be reused, and some-
 times even easier to write.
  
 development plan:
  A process for developing a program. In this chapter, I 
 demonstrated a style of development based on developing code to do sim-
 ple, specific things, and then encapsulating and generalizing.",NA
6.12,NA,NA
Exercises,"Exercise 6.1
  
 void Loop(int n) 
  
 { 
  
  
 int i = n; 
  
  
 while (i > 1) 
  
  
 { 
  
  
  
 printf (""%i\n"",i); 
  
  
  
 if (i%2 == 0) 
  
  
  
 { 
  
  
  
  
 i = i/2; 
  
  
  
 } 
  
  
  
 else 
  
  
  
 { 
  
  
  
  
 i = i+1; 
  
  
  
 } 
  
  
 } 
  
 }
  
 int main (void) 
  
 { 
  
  
 Loop(10); 
  
  
 return EXIT_SUCCESS; 
  
 }
  
 a. Draw a table that shows the value of the variables i and n during the execution of 
 the program. The table should contain one column for each variable and one line 
 for each iteration.
  
 b. What is the output of this program?
  
 Exercise 6.2 
  
 In Exercise 5.4 we wrote a recursive version of Power(), which takes a 
 double x and an integer n and returns
  x
 n
 . Now write an iterative function to perform the 
 same calculation.
  
 Exercise 6.3 
  
 Let’s say you are given a number,
  a
 , and you want to find its square 
 root. One way to do that is to start with a very rough guess about the answer,
  x
 0
 , and then 
 improve the guess using the following formula:
  
 x
 1
  = (
 x
 0
  +
  a/x
 0
 )
 /
 2
  
 For example, if we want to find the square root of 9, and we start with
  x
 0
  = 6, then 
 x
 1
  = (6 + 
 9
 /
 6)
 /
 2 = 15
 /
 4 = 3
 .
 75, which is closer.
  
 We can repeat the procedure, using
  x
 1
  to calculate
  x
 2
 , and so on. In this case, 
 x
 2
  = 3
 .
 075 and
  
 x
 3
  = 3
 .
 00091. So that is converging very quickly on the right answer (which is 3).
  
 Write a function called SquareRoot that takes a double as a parameter and that returns 
 an approximation of the square root of the parameter, using this algorithm. You may not 
 use the sqrt() function from the math.h library.",NA
Chapter 7,NA,NA
Arrays,"A
  array
  is a set of values where each value is identified and referenced by a 
 number (called an index). The nice thing about arrays is that they can be made 
 up of any type of element, including basic types like ints and doubles, but all the 
 values in an array have to have the same type.
  
 When you declare an array, you have to determine the number of elements in the 
 array. Otherwise the declaration looks similar to other variable types:
  
 int c[4]; 
  
 double values[10];
  
 Syntactically, array variables look like other C variables except that they are 
 followed by [NUMBER_OF_ELEMENTS], the number of elements in the array en-
 closed in square brackets. The first line in our example, int c[4]; is of the type 
 ""array of integers"" and creates a array of four integers named c. The second line, 
 double values[10]; has the type ""array of doubles"" and creates an array of 10 
 doubles.
  
 C allows you to to initialize the element values of an array immediately after you 
 have declared it. The values for the individual elements must be enclosed in 
 curly brakets {} and separated by comma, as in the following example:
  
 int c[4] = {0, 0, 0, 0};
  
 This statement creates an array of four elements and initializes all of them to 
 zero. This syntax is only legal at initialisation time. Later in your program you 
 can only assign values for the array element by element.
  
 The following figure shows how arrays are represented in state diagrams:",NA
c,"0
  
 0
  
 0
  
 0
  
  
 c[0] c[1] c[2] c[3]
  
 The large numbers inside the boxes are the values of the
  elements
  in the array. 
 The small numbers outside the boxes are the indices used to identify each",NA
7.1 Increment and decrement operators,"Incrementing and decrementing are such common operations that C provides 
 special operators for them. The ++ operator adds one to the current value of an 
 int, char or double, and -- subtracts one.
  
 Technically, it is legal to increment a variable and use it in an expression at the 
 same time. For example, you might see something like:
  
 printf (""%i\n "", i++);
  
 Looking at this, it is not clear whether the increment will take effect before or 
 after the value is displayed. Because expressions like this tend to be confusing, I 
 would discourage you from using them. In fact, to discourage you even more, I’m 
 not going to tell you what the result is. If you really want to know, you can try it.
  
 Using the increment operators, we can rewrite the PrintMultTable() from Section 
 6.10:
  
 void PrintMultTable(int high) 
  
 { 
  
 int i = 1; 
  
 while (i <= high) 
  
 { 
  
  
 PrintMultiples(i); 
  
  
 i++; 
  
 } 
  
 }
  
 It is a common error to write something like:
  
 index = index++; 
  
 /* WRONG!! */
  
 Unfortunately, this is syntactically legal, so the compiler will not warn you. The 
 effect of this statement is to leave the value of index unchanged. This is often a 
 difficult bug to track down.
  
 Remember, you can write index = index + 1;, or you can write index++;, but you 
 shouldn’t mix them.",NA
7.2 Accessing elements,"The [] operator allows us to read and write the individual elements of an array. 
 The indices start at zero, so c[0] refers to the first element of the array, and c[1] 
 refers to the second element. You can use the [] operator anywhere in an 
 expression:",NA
c,"7
  
 14
  
 1
  
 -60
  
  
 c[0] c[1] c[2] c[3]
  
 Here is the effect of this code
  
 By now you should have noticed that the four elements of this array are num-
 bered from 0 to 3, which means that there is no element with the index 4.
  
 Nevertheless, it is a common error to go beyond the bounds of an array. In safer 
 languages such as Java, this will cause an error and most likely the program 
 quits. C does not check array boundaries, so your program can go on accessing 
 memory locations beyond the array itself, as if they where part of the array.
  
 This is most likely wrong and can cause very severe bugs in your program.
  
 It is necessary that you, as a programmer, make sure that your 
 code correctly observes array boundaries!
  
 You can use any expression as an index, as long as it has type int. One of the most 
 common ways to index an array is with a loop variable. For example:
  
 int i = 0; 
  
 while (i < 4) 
  
 { 
  
  
 printf (""%i\n"", c[i]); 
  
  
 i++; 
  
 }
  
 This is a standard while loop that counts from 0 up to 4, and when the loop 
 variable i is 4, the condition fails and the loop terminates. Thus, the body of the 
 loop is only executed when i is 0, 1, 2 and 3.
  
 Each time through the loop we use i as an index into the array, printing the ith 
 element. This type of array traversal is very common. Arrays and loops go 
 together like fava beans and a nice Chianti.",NA
7.3 ,NA,NA
Copying arrays,"Arrays can be a very convenient solution for a number of problems, like storing 
 and processing large sets of data.
  
 However, there is very little that C does automatically for you. For example you 
 can not set all the elements of an array at the same time and you can not assign 
 one array to the other, even if they are identical in type and number of elements.",NA
7.4 ,NA,NA
for,NA,NA
 loops,"The loops we have written so far have a number of elements in common. All of 
 them start by initializing a variable; they have a test, or condition, that depends 
 on that variable; and inside the loop they do something to that variable, like 
 increment it.
  
 This type of loop is so common that there is an alternate loop statement, called 
 for, that expresses it more concisely. The general syntax looks like this:
  
 for (INITIALIZER; CONDITION; INCREMENTOR) 
  
 { 
  
 BODY 
  
 }
  
 This statement is exactly equivalent to
  
 INITIALIZER; 
  
 while (CONDITION) 
  
 { 
  
 BODY 
  
 INCREMENTOR 
  
 }
  
 except that it is more concise and, since it puts all the loop-related statements in 
 one place, it is easier to read. For example:
  
 int i; 
  
 for (i = 0; i < 4; i++) 
  
 { 
  
 printf(""%i\n"", c[i]); 
  
 }
  
 is equivalent to",NA
7.5 ,NA,NA
Array length,"C does not provide us with a convenient way to determine the actual length of an 
 array. Knowing the size of an array would be convenient when we are looping 
 through all elements of the array and need to stop with the last element.
  
 In order to determine the array length we could use the sizeof() operator, that 
 calculates the size of data types in bytes. Most data types in C use more than one 
 byte to store their values, therefore it becomes necessary to divide the byte-
 count for the array by the byte-count for a single element to establish the 
 number of elements in the array.
  
 sizeof(ARRAY)/sizeof(ARRAY_ELEMENT)
  
 It is a good idea to use this value as the upper bound of a loop, rather than a 
 constant. That way, if the size of the array changes, you won’t have to go through 
 the program changing all the loops; they will work correctly for any size array.
  
 int i, length; 
  
 length = sizeof (c) / sizeof (c[0]);
  
 for (i = 0; i < length; i++) 
  
 { 
  
  
 printf(""%i\n"", c[i]); 
  
 }
  
 The last time the body of the loop gets executed, the value of i is length - 1, which 
 is the index of the last element. When i is equal to length, the condition fails and 
 the body is not executed, which is a good thing, since it would access a memory 
 location that is not part of the array.",NA
7.6 ,NA,NA
Random numbers,"Most computer programs do the same thing every time they are executed, so 
 they are said to be
  deterministic
 . Usually, determinism is a good thing, since we 
 expect the same calculation to yield the same result. For some applications, 
 though, we would like the computer to be unpredictable. Games are an obvious 
 example.
  
 Making a program truly
  nondeterministic
  turns out to be not so easy, but there 
 are ways to make it at least seem nondeterministic. One of them is to",NA
7.7,NA,NA
Statistics,"The numbers generated by rand() are supposed to be distributed uniformly. 
 That means that each value in the range should be equally likely. If we count the 
 number of times each value appears, it should be roughly the same for all values, 
 provided that we generate a large number of values.
  
 In the next few sections, we will write programs that generate a sequence of 
 random numbers and check whether this property holds true.",NA
7.8 ,NA,NA
Array of random numbers,"The first step is to generate a large number of random values and store them in a 
 array. By “large number,” of course, I mean 20. It’s always a good idea to start 
 with a manageable number, to help with debugging, and then increase it later.
  
 The following function takes three arguments, an array of integers, the size of 
 the array and an upper bound for the random values. It fills the array of ints with 
 random values between 0 and upperBound-1.
  
 void RandomizeArray (int array[], int length, int upperBound) { 
  
  
 int i; 
  
  
 for (i = 0; i < length; i++) 
  
  
 { 
  
  
  
 array[i] = rand() % upperBound; 
  
  
 } 
  
 }
  
 The return type is void, which means that this function does not return any 
 value to the calling function. To test this function, it is convenient to have a 
 function that outputs the contents of a array.
  
 void PrintArray (int array[], int length) 
  
 { 
  
  
 int i; 
  
  
 for (i = 0; i < length; i++) 
  
  
 { 
  
  
  
 printf (""%i "", array[i]); 
  
  
 } 
  
 }
  
 The following code generates an array filled with random values and outputs it:
  
 int r_array[20]; 
  
 int upperBound = 10; 
  
 int length = sizeof(r_array) / sizeof(r_array[0]);
  
 RandomizeArray (r_array, length, upperBound); 
 PrintArray (r_array, length);",NA
7.9 Passing an array to a function,"You probably have noticed that our RandomizeArray() function looked a bit 
 unusual. We pass an array to this function and expect to get a a random-ized 
 array back. Nevertheless, we have declared it to be a void function, and 
 miraculously the function appears to have altered the array.
  
 This behaviour goes against everything what I have said about the use of vari-
 ables in functions so far. C typically uses the so called
  call-by-value
  evaluation 
 of expressions. If you pass a value to a function it gets copied from the calling 
 function to a variable in the called function. The same is true if the function 
 returns a value. Changes to the internal variable in the called function do not 
 affect the external values of the calling function.
  
 When we pass an array to a function this behaviour changes to something called 
 call-by-reference
  evaluation. C does not copy the array to an internal array– it 
 rather generates a reference to the original array and any operation in the called 
 function directly affects the original array. This is also the reason why we do not 
 have to return anything from our function. The changes have already taken 
 place.
  
 Call by reference also makes it necessary to supply the length of the array to the 
 called function, since invoking the sizeof operator in the called function would 
 determine the size of the reference and not the original array.
  
 We will further discuss call by reference and call by value in Section 8.7, Sec-tion 
 9.6 and 9.7.",NA
7.10 ,NA,NA
Counting,"A good approach to problems like this is to think of simple functions that are 
 easy to write, and that might turn out to be useful. Then you can combine them 
 into a solution. This approach is sometimes called
  bottom-up design
 .",NA
7.11,"for (i=0; i < length; i++) 
  
  
 { 
  
  
 if (array[i] == value) count++; 
  
 } 
  
 return count;",NA
Checking the other values,"HowMany() only counts the occurrences of a particular value, and we are inter-
 ested in seeing how many times each value appears. We can solve that problem 
 with a loop:
  
 int i; 
  
 int r_array[20]; 
  
 int upperBound = 10; 
  
 int length = sizeof(r_array) / sizeof(r_array[0]);
  
 RandomizeArray(r_array, length, upperBound);
  
 printf (""value\tHowMany\n""); 
  
 for (i = 0; i < upperBound; i++) 
  
 {",NA
7.12 ,NA,NA
A histogram,"It is often useful to take the data from the previous tables and store them for 
 later access, rather than just print them. What we need is a way to store 10 
 integers. We could create 10 integer variables with names like howManyOnes, 
 howManyTwos, etc. But that would require a lot of typing, and it would be a real 
 pain later if we decided to change the range of values.
  
 A better solution is to use a array with length 10. That way we can create all ten 
 storage locations at once and we can access them using indices, rather than ten 
 different names. Here’s how:
  
 int i; 
  
 int upperBound = 10; 
  
 int r_array[100000];",NA
7.13 ,NA,NA
A single-pass solution,"Although this code works, it is not as efficient as it could be. Every time it calls 
 HowMany(), it traverses the entire array. In this example we have to traverse 
 the array ten times!
  
 It would be better to make a single pass through the array. For each value in the 
 array we could find the corresponding counter and increment it. In other words, 
 we can use the value from the array as an index into the histogram.
  
 Here’s what that looks like:
  
 int upperBound = 10; 
  
 int histogram[upperBound] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  
 for (i = 0; i < r_array_length; i++) 
  
 { 
  
  
 int index = r_array[i]; 
  
  
 histogram[index]++; 
  
 }
  
 The second line initializes the elements of the histogram to zeroes. That way, 
 when we use the increment operator (++) inside the loop, we know we are 
 starting from zero. Forgetting to initialize counters is a common error.
  
 As an exercise, encapsulate this code in a function called Histogram() that takes 
 an array and the range of values in the array (in this case 0 through 10) as two 
 parameters min and max. You should pass a second array to the function where 
 a histogram of the values in the array can be stored.",NA
7.14,NA,NA
Random seeds,"If you have run the code in this chapter a few times, you might have noticed that 
 you are getting the same “random” values every time. That’s not very random!
  
 One of the properties of pseudorandom number generators is that if they start 
 from the same place they will generate the same sequence of values. The starting 
 place is called a
  seed
 ; by default, C uses the same seed every time you run the 
 program.
  
 While you are debugging, it is often helpful to see the same sequence over and 
 over. That way, when you make a change to the program you can compare the 
 output before and after the change.
  
 If you want to choose a different seed for the random number generator, you can 
 use the srand() function. It takes a single argument, which is an integer between 
 0 and RAND_MAX.
  
 For many applications, like games, you want to see a different random sequence 
 every time the program runs. A common way to do that is to use a library 
 function like time() to generate something reasonably unpredictable and unre-
 peatable, like the number of seconds since January 1970, and use that number as 
 a seed. The details of how to do that depend on your development environment.",NA
7.15 ,NA,NA
Glossary,"array:
  A named collection of values, where all the values have the same type, 
  
 and each value is identified by an index.
  
 element:
  One of the values in a array. The [] operator selects elements of a 
  
 array.
  
 index:
  An integer variable or value used to indicate an element of a array.
  
 increment:
  Increase the value of a variable by one. The increment operator in 
  
 C is ++.
  
 decrement:
  Decrease the value of a variable by one. The decrement operator 
  
 in C is --.
  
 deterministic:
  A program that does the same thing every time it is run.
  
 pseudorandom:
  A sequence of numbers that appear to be random, but which 
  
 are actually the product of a deterministic computation.
  
 seed:
  A value used to initialize a random number sequence. Using the same 
  
 seed should yield the same sequence of values.
  
 bottom-up design:
  A method of program development that starts by writing 
  
 small, useful functions and then assembling them into larger solutions.
  
 histogram:
  A array of integers where each integer counts the number of values 
  
 that fall into a certain range.",NA
7.16,NA,NA
Exercises,"Exercise 7.1
  
 A friend of yours shows you the following method and explains that if number is any two-
 digit number, the program will output the number backwards. He claims that if number is 
 17, the method will output 71.
  
 Is he right? If not, explain what the program actually does and modify it so that it does the 
 right thing.
  
 #include <stdio.h> 
  
 #include<stdlib.h>
  
 int main (void) 
  
 { 
  
  
 int number = 71; 
  
  
 int lastDigit = number%10; 
  
  
 int firstDigit = number/10; 
  
  
 printf(""%i"",lastDigit + firstDigit); 
  
  
 return EXIT_SUCCESS; 
  
 }
  
 Exercise 7.2 
  
 Write a function that takes an array of integers, the length of the array 
 and an integer named target as arguments.
  
 The function should search through the provided array and should return the first index 
 where target appears in the array, if it does. If target is not in the array the function 
 should return an invalid index value to indicate an error condition (e.g.-1).
  
 Exercise 7.3
  
 One not-very-efficient way to sort the elements of an array is to find the largest element 
 and swap it with the first element, then find the second-largest element and swap it with 
 the second, and so on.
  
 a. Write a function called IndexOfMaxInRange() that takes an array of integers, finds the 
 largest element in the given range, and returns
  its index
 .
  
 b. Write a function called SwapElement() that takes an array of integers and two 
  
 indices, and that swaps the elements at the given indices.
  
 c. Write a function called SortArray() that takes an array of integers and that uses 
 IndexOfMaxInRange() and SwapElement() to sort the array from largest to 
 smallest.",NA
Chapter 8,NA,NA
Strings and things,NA,NA
8.1 ,NA,NA
Containers for strings,"We have seen four types of values—characters, integers, floating-point numbers 
 and strings—but only three types of variables—char, int and double. So far we 
 have no way to store a string in a variable or perform operations on strings.
  
 This chapter is going to rectify this situation and I can now tell you that strings in 
 C are stored as an array of characters terminated by the character \0.
  
 By now this explanation should make sense to you and you probably understand 
 why we had to learn quite a bit about the working of the language before we 
 could turn our attention towards string variables.
  
 In the previous chapter we have seen that operations on arrays have only mini-
 mal support from the C language itself and we had to program extra functions by 
 ourselves. Fortunately things are a little bit easier when we manipulate these 
 special types of arrays - called strings. There exist a number of library func-tions 
 in string.h that make string handling a bit easier than operations on pure arrays.
  
 Nevertheless string operations in C are still a lot more cumbersome than their 
 equivalence in other programing languages and can be a potential source of 
 errors in your programs, if not handled carefully.",NA
8.2 ,NA,NA
String variables,"You can create a string variable as an array of characters in the following way:
  
 char first[] = ""Hello, ""; 
  
 char second[] = ""world."";",NA
8.3 Extracting characters from a string,"Strings are called “strings” because they are made up of a sequence, or string, of 
 characters. The first operation we are going to perform on a string is to extract 
 one of the characters. C uses an index in square brackets ([ and ]) for this 
 operation:
  
 char fruit[] = ""banana""; 
  
 char letter = fruit[1]; 
  
 printf (""%c\n"", letter);
  
 The expression fruit[1] indicates that I want character number 1 from the string 
 named fruit. The result is stored in a char named letter. When I output the value 
 of letter, I get a surprise:
  
 a",NA
8.4 ,NA,NA
Length,"To find the length of a string (the number of characters this string contains), we 
 can use the strlen() function. The function is called using the string variable as 
 an argument:
  
 #include <string.h> 
  
 int main(void) 
  
 { 
  
 int length; 
  
 char fruit[] = ""banana"";
  
 }
  
 length = strlen(fruit); return 
 EXIT_SUCCESS;
  
 The return value of strlen() in this case is 6. We assign this value to the integer 
 length for further use.
  
 In order to compile this code, you need to include the header file for the string.h 
 library. This library provides a number of useful functions for oper-ations on 
 strings. You should familiarize yourself with these functions because they can 
 help you to solve your programming problems faster.
  
 To find the last letter of a string, you might be tempted to try something like
  
 int length = strlen(fruit); char 
 last = fruit[length];
  
 /* WRONG!! */
  
 That won’t work. The reason is that fruit is still an array and there is no letter at 
 the array index fruit[6] in ""banana"". Since we started counting at 0, the 6 letters 
 are numbered from 0 to 5. To get the last character, you have to subtract 1 from 
 length.
  
 int length = strlen(fruit);
  
 char last = fruit[length-1];",NA
8.5 ,NA,NA
Traversal,"A common thing to do with a string is start at the beginning, select each char-acter 
 in turn, do something to it, and continue until the end. This pattern of",NA
8.6 Finding a,NA,NA
 character,NA,NA
 in a,NA,NA
 string,"If we are looking for a letter in a string, we have to search through the string and 
 detect the position where this letter occurs in the string. Here is an imple-
 mentation of this function:
  
 int LocateCharacter(char *s, char c) 
  
 { 
  
 int i = 0; 
  
 while (i < strlen(s)) 
  
 { 
  
  
 if (s[i] == c) return i; 
  
  
 i = i + 1; 
  
 } 
  
 return -1; 
  
 }
  
 We have to pass the string as the first argument, the other argument is the 
 character we are looking for. Our function returns the index of the first occur-
 rence of the letter, or -1 if the letter is not contained in the string.",NA
8.7,NA,NA
Pointers and Addresses,"When we look at the definition of the LocateCharacter() function you may notice 
 the following construct char *s which looks unfamiliar.
  
 Remember, when we discussed how we had to pass an array to a function, back 
 in Section 7.9, we said that instead of copying the array, we only pass a reference 
 to the function. Back then, we did not say exactly what this reference was.
  
 C is one of the very few high-level programming languages that let you directly 
 manipulate objects in the computer memory. In order to do this direct manip-
 ulation, we need to know the location of the object in memory: it’s address. 
 Adresses can be stored in variables of a special type. These variables that point 
 to other objects in memory (such as variables, arrays and strings) are therefore 
 called
  pointer
  variables.
  
 A pointer references the memory location of an object and can be defined like 
 this:
  
 int *i_p;
  
 This declaration looks similar to our earlier declarations, with one difference: 
 the asterisk in front of the name. We have given this pointer the type int. The 
 type specification has nothing to do with the pointer itself, but rather defines 
 which object this pointer is supposed to reference (in this case an integer). This 
 allows the compiler to do some type checking on, what would otherwise be, an 
 anonymous reference.
  
 A pointer all by itself is rather meaningless, we also need an object that this 
 pointer is referencing:
  
 int number = 5; 
  
 int *i_p;
  
 This code-fragment defines an int variable and a pointer. 
  
 We can use the 
 ""address-of"" operator & to assign the memory location or
  address
  of our variable 
 to the pointer.
  
 i_p = &number;
  
 Pointer i_p now references integer variable number. We can verify this using the 
 ""content-of"" operator *.
  
 printf(""%i\n"", *i_p);
  
 This prints 5, which happens to be the content of the memory location at our 
 pointer reference.
  
 With pointers we can directly manipulate memory locations:
  
 *i_p = *i_p + 2; 
  
 printf(""%i\n"", number);
  
 Our variable number now has the value 7 and we begin to understand how our 
 LocateCharacter() function can directly access the values of string variables 
 through the use of a char pointer.",NA
8.8 String concatenation,"In Section 8.6 we have seen how we could implement a search function that finds 
 a character in a string.
  
 One useful operation on strings is string
  concatenation
 . To concatenate means 
 to join the two operands end to end. For example: shoe and maker becomes 
 shoemaker.
  
 Fortunately, we do not have to program all the necessary functions in C our-
 selves. The string.h library already provides several functions that we can 
 invoke on strings.
  
 We can use the library function strncat() to concatenate strings in C.
  
 char fruit[20] = ""banana""; 
  
 char bakedGood[] = "" nut bread""; 
  
 strncat(fruit, bakedGood, 10); 
  
 printf (""%s\n"", fruit);
  
 The output of this program is banana nut bread.
  
 When we are using library functions it is important to completely understand all 
 the necessary arguments and to have a complete understanding of the working 
 of the function.
  
 The strncat() does not take the two strings, joins them together and produces a 
 new combined string. It rather copies the content from the second argument 
 into the first.
  
 We therefore have to make sure that our first string is long enough to also hold 
 the second string. We do this by defining the maximum capacity for string fruit to 
 be 19 characters + 1 termination character (char fruit[20]). The third argument 
 of strncat() specifies the number of characters that will be copied from the 
 second into the first string.",NA
8.9 Assigning new values to,NA,NA
 string,NA,NA
 variables,"So far we have seen how to initialise a string variable at declaration time. As 
 with arrays in general, it is not legal to assign values directly to strings, because 
 it is not possible to assign a value to an entire array.
  
 fruit = ""orange""; /* Wrong: Cannot assign directly! */
  
 In order to assign a new value to an existing string variable we have to use the 
 strncpy() function. For example,",NA
8.10 ,NA,NA
string,NA,NA
s are not comparable,"All the comparison operators that work on ints and doubles do work on strings. 
  
 For example, if you write the following code to determine if two 
 strings are equal:
  
 if (word == ""banana"") /* Wrong! */
  
 This test will always fail.
  
 You have to use the strcmp() function to compare two strings with each other. 
 The function returns 0 if the two strings are identical, a negative value if the first 
 string is ’alphabetically less’ than the second (would be listed first in a 
 dictionary) or a positive value if the second string is ’greater’.
  
 Please notice, this return value is not the standard true/false result, where the 
 return value 0 is interpreted as ’false’.
  
 The strcmp() function is useful for putting words in alphabetical order.",NA
8.11 ,NA,NA
Character classification,"It is often useful to examine a character and test whether it is upper or lower 
 case, or whether it is a character or a digit. C provides a library of functions that 
 perform this kind of character classification. In order to use these functions, you 
 have to include the header file ctype.h.
  
 char letter = ’a’; 
  
 if (isalpha(letter)) 
  
 { 
  
 printf(""The character %c is a letter."", letter); }
  
 The return value from isalpha() is an integer that is 0 if the argument is not a 
 letter, and some non-zero value if it is.
  
 It is legal to use this kind of integer in a conditional, as shown in the example. The 
 value 0 is treated as false, and all non-zero values are treated as true.
  
 Other character classification functions include isdigit(), which identifies the 
 digits 0 through 9, and isspace(), which identifies all kinds of “white” space, 
 including spaces, tabs, newlines, and a few others. There are also isupper() and 
 islower(), which distinguish upper and lower case letters.
  
 Finally, there are two functions that convert letters from one case to the other, 
 called toupper() and tolower(). Both take a single character as an argument and 
 return a (possibly converted) character.",NA
8.12 ,NA,NA
Getting user input,"The programs we have written so far are pretty predictable; they do the same 
 thing every time they run. Most of the time, though, we want programs that take 
 input from the user and respond accordingly.
  
 There are many ways to get input, including keyboard input, mouse movements 
 and button clicks, as well as more exotic mechanisms like voice control and 
 retinal scanning. In this text we will consider only keyboard input.
  
 In the header file stdio.h, C defines a function named scanf() that handles input 
 in much the same way that printf() handles output. We can use the following 
 code to get an integer value from the user:
  
 int x;
  
 scanf(""%i"", &x);
  
 The scanf() function causes the program to stop executing and wait for the user 
 to type something. If the user types a valid integer, the program converts it into 
 an integer value and stores it in x.
  
 If the user types something other than an integer, C doesn’t report an error, or 
 anything sensible like that. Instead, the scanf() function returns and leaves the 
 value in x unchanged.
  
 Fortunately, there is a way to check and see if an input statement succeeds. The 
 scanf() function returns the number of items that have been successfully read. 
 This number will be 1 when the last input statement succeeded. If not, we know 
 that some previous operation failed, and also that the next operation will fail.
  
 Getting input from the user might look like this:
  
 int main (void)
  
 {
  
 int success, x;
  
 /* prompt the user for input */
  
 printf (""Enter an integer: \n"");
  
 /* get input */",NA
8.13 ,NA,NA
Glossary,"index:
  A variable or value used to select one of the members of an ordered set, 
  
 like a character from a string.
  
 traverse:
  To iterate through all the elements of a set performing a similar 
  
 operation on each.
  
 counter:
  A variable used to count something, usually initialized to zero and 
  
 then 
 incremented.
  
 concatenate:
  To join two operands end-to-end.
  
 pointer:
  A reference to an object in computer memory.
  
 address:
  The exact storage location of objects in memory.",NA
8.14 ,NA,NA
Exercises,"Exercise 8.1 
  
 A word is said to be “abecedarian” if the letters in the word appear in 
 alphabetical order. For example, the following are all 6-letter English abecedarian words.
  
 abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, beknow, 
 bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort, deinos, diluvy, dimpsy
  
 a. Describe an algorithm for checking whether a given word (String) is abecedarian, 
 assuming that the word contains only lower-case letters. Your algorithm can be 
 iterative or recursive.
  
 b. Implement your algorithm in a function called IsAbecedarian().",NA
Chapter 9,NA,NA
Structures,NA,NA
9.1 ,NA,NA
Compound values,"Most of the data types we have been working with represent a single value—an 
 integer, a floating-point number, a character value. Strings are different in the 
 sense that they are made up of smaller pieces, the characters. Thus, strings are 
 an example of a
  compound
  type.
  
 Depending on what we are doing, we may want to treat a compound type as a 
 single thing (or object), or we may want to access its parts (or member 
 variables). This ambiguity is useful.
  
 It is also useful to be able to create your own compound values. C provides a 
 mechanism for doing that:
  structures
 .",NA
9.2 ,NA,NA
Point,NA,NA
 objects,"As a simple example of a compound structure, consider the concept of a math-
 ematical point. 
  
 At one level, a point is two numbers (coordinates) that we treat 
 collectively as a single object. In mathematical notation, points are often written 
 in parentheses, with a comma separating the coordinates. For example, (0
 ,
  0) 
 indicates the origin, and (
 x, y
 ) indicates the point
  x
  units to the right and 
 y
  units up 
 from the origin.
  
 A natural way to represent a point in C is with two doubles. The question, then, is 
 how to group these two values into a compound object, or structure.
  
 The answer is a struct definition:
  
 typedef struct 
  
 { 
  
  
 double x; 
  
  
 double y; 
  
 } Point_t;",NA
9.3 Accessing member variables,"You can read the values of an member variable using the same syntax we used to 
 write them:
  
 double x = blank.x;
  
 The expression blank.x means “go to the object named blank and get the value of 
 x.” In this case we assign that value to a local variable named x. Notice that there 
 is no conflict between the local variable named x and the member variable 
 named x. The purpose of dot notation is to identify
  which
  variable you are 
 referring to unambiguously.
  
 You can use dot notation as part of any C expression, so the following are legal.
  
 printf (""%0.1f, %0.1f\n"", blank.x, blank.y);
  
 double distance = blank.x * blank.x + blank.y * blank.y;
  
 The first line outputs 3, 4; the second line calculates the value 25.",NA
9.4,NA,NA
Operations on structures,"Most of the operators we have been using on other types, like mathematical 
 operators ( +, %, etc.) and comparison operators (==, >, etc.), do not work on 
 structures.
  
 On the other hand, the assignment operator
  does
  work for structures. It can be 
 used in two ways: to initialize the member variables of a structure or to copy the 
 member variables from one structure to another. An initialization looks like this:
  
 Point_t blank = { 3.0, 4.0 };
  
 The values in squiggly braces get assigned to the member variables of the struc-
 ture one by one, in order. So in this case, x gets the first value and y gets the 
 second.
  
 Unfortunately, this syntax can be used only in an initialization, not in an as-
 signment statement. So the following is illegal:
  
 Point_t blank; 
  
 blank = { 3.0, 4.0 };
  
 /* WRONG !! */
  
 You might wonder why this perfectly reasonable statement should be illegal; I’m 
 not sure, but I think the problem is that the compiler doesn’t know what type the 
 right hand side should be. You must specify the type of the assignment by adding 
 a typecast:
  
 Point_t blank; 
  
 blank = (Point_t){ 3.0, 4.0 };
  
 That works.
  
 It is legal to assign one structure to another. For example:
  
 Point_t p1 = { 3.0, 4.0 }; 
  
 Point_t p2 = p1; 
  
 printf (""%f, %f\n"", p2.x, p2.y);
  
 The output of this program is 3, 4.",NA
9.5 ,NA,NA
Structures as parameters,"You can pass structures as parameters in the usual way. For example,
  
 void PrintPoint (Point_t point) 
  
 { 
  
  
 printf (""(%0.1f, %0.1f)\n"", point.x, point.y); }
  
 PrintPoint() takes a point as an argument and outputs it in the standard format. If 
 you call PrintPoint(blank), it will output (3.0, 4.0).
  
 As a second example, we can rewrite the ComputeDistance() function from 
 Section 5.2 so that it takes two Points as parameters instead of four doubles.",NA
9.6 Call by value,"When you pass a structure as an argument, remember that the argument and 
 the parameter are not the same variable. Instead, there are two variables (one in 
 the caller and one in the callee) that have the same value, at least initially.
  
 For example, when we call PrintPoint(), the stack diagram looks like this:
  
 PrintPoint()
  
 main()
  
  
 point
  
  
 x: 3
  
 y: 4
  
  
  
   
 blank
  
  
 x: 3
  
 y: 4
  
  
  
   
 If PrintPoint() happened to change one of the member variables of point, it 
 would have no effect on blank. Of course, there is no reason for PrintPoint() to 
 modify its parameter, so this isolation between the two functions is appropriate.
  
 This kind of parameter-passing is called “pass by value” because it is the value of 
 the structure (or other type) that gets passed to the function.",NA
9.7 Call by reference,"An alternative parameter-passing mechanism that is available in C is called“pass 
 by reference.” By now we already know that C uses pointers as references. This 
 mechanism makes it possible to pass a structure to a procedure and modify it 
 directly.
  
 For example, you can reflect a point around the 45-degree line by swap-ping the 
 two coordinates. The most obvious (but incorrect) way to write a ReflectPoint() 
 function is something like this:
  
 void ReflectPoint (Point_t point)
  
 /* Does not work! */
  
 {
  
 double temp = point.x;",NA
9.8 Rectangles,"Now let’s say that we want to create a structure to represent a rectangle. The 
 question is, what information do I have to provide in order to specify a 
 rectangle? To keep things simple let’s assume that the rectangle will be oriented 
 vertically or horizontally, never at an angle.
  
 There are a few possibilities: I could specify the center of the rectangle (two 
 coordinates) and its size (width and height), or I could specify one of the corners 
 and the size, or I could specify two opposing corners.
  
 The most common choice in existing programs is to specify the upper left corner 
 of the rectangle and the size. To do that in C, we will define a structure that 
 contains a Point_t and two doubles.
  
 typedef struct 
  
 { 
  
 Point_t corner; 
  
 double width, height; 
  
 } Rectangle_t;
  
 Notice that one structure can contain another. In fact, this sort of thing is quite 
 common. Of course, this means that in order to create a Rectangle_t, we have to 
 create a Point_t first:
  
 Point_t corner = { 0.0, 0.0 }; 
  
 Rectangle_t box = { corner, 100.0, 200.0 };
  
 This code creates a new Rectangle_t structure and initializes the member 
 variables. The figure shows the effect of this assignment.
  
 box
  
   
 point
  
 width
  
 height
  
  
 x: 3
  
 y: 4
  
  
 100
  
  
 200
  
    
  
  
 We can access the width and height in the usual way:
  
 box.width += 50.0; 
  
 printf(""%f\n"", box.width);",NA
9.9 ,NA,NA
Structures as return types,"You can write functions that return structures. For example, FindCenter() has a 
 Rectangle_t parameter and returns a Point_t that contains the coordinates of the 
 center of the rectangle:
  
 Point_t FindCenter (Rectangle_t box) 
  
 { 
  
  
 double x = box.corner.x + box.width/2; 
  
  
 double y = box.corner.y + box.height/2; 
  
  
 Point_t result = {x, y}; 
  
  
 return result; 
  
 }
  
 To call this function, we have to pass a Rectangle_t as an argument (notice that it 
 is being passed by value), and assign the return value to a Point_t variable:
  
 Rectangle_t box = { {0.0, 0.0}, 100, 200 }; 
  
 Point_t center = FindCenter (box); 
  
 PrintPoint (center);
  
 The output of this program is (50, 100).
  
 We could have passed the structure as a reference to the function. In this case our 
 function would look like this:
  
 Point_t FindCenter (Rectangle_t *box) 
  
 { 
  
  
 double x = box->corner.x + box->width/2; 
  
 double y = box->corner.y + box->height/2; 
  
 Point_t result = {x, y}; 
  
  
 return result; 
  
 }",NA
9.10 ,NA,NA
Passing other types by reference,"It’s not just structures that can be passed by reference. All the other types we’ve 
 seen can, too. For example, to swap two integers, we could write something like:
  
 void Swap (int *x, int *y) 
  
 { 
  
 int temp = *x; 
  
 *x = *y; 
  
 *y = temp; 
  
 }
  
 We would call this function in the usual way:
  
 int i = 7; 
  
 int j = 9; 
  
 printf ("" i=%i, j=%i\n"", i, j); 
  
 Swap (&i, &j); 
  
 printf ("" i=%i, j=%i\n"", i, j);
  
 The output of this program shows that the variable values have been swapped. 
 Draw a stack diagram for this program to convince yourself this is true. If the 
 parameters x and y were declared as regular integer variables (without the s), 
 Swap() would not work. It would modify x and y and have no effect on i and j.
  
 When people start passing things like integers by reference, they often try to use 
 an expression as a reference argument. For example:
  
 int 
 i 
 = 
 7; 
  
 int 
 j 
 = 
 9; 
  
 Swap (&i, &j+1);
  
 /* WRONG!! */
  
 Presumably the programmer wanted to increase the value of j by 1 before it is 
 passed to the function. This does not work as expected, because the expression 
 j+1 now is interpreted a pointer value and in now pointing to a memory location 
 beyond the variable j. It is a little tricky to figure out exactly what kinds of 
 expressions make sense to be passed by reference. For now a good rule of 
 thumb is that reference arguments have to be variables.",NA
9.11 ,NA,NA
Glossary,"structure:
  A collection of data grouped together and treated as a single object.
  
 member variable:
  One of the named pieces of data that make up a structure.",NA
9.12 ,NA,NA
Exercises,"Exercise 9.1
  
 Section 9.5 defines the function PrintPoint(). The argument of this function is passed along 
 as a value (call-by-value).
  
 a. Change the definition of this function, so that it only passes a reference of the 
 structure to the function for printing (call-by-reference).
  
 b. Test the new function with different values and document the results.
  
 Exercise 9.2
  
 Most computer games can capture our interest only when their actions are non-
 predictable, otherwise they become boring quickly. Section 7.6 tells us how to generate 
 random numbers in in C.
  
 Write a simple game, where the computer chooses an arbitrary number in the range 
 between 1 and 20. You will then be asked to guess the number chosen by the Computer.
  
 To give you a hint the computer should answer your guess in the following way: in case 
 your guess was lower than the number of the computer, the output should be: 
 My number 
 is larger!
  
 If you guess was higher than the number of the computer, the output should read: 
 My 
 number is smaller!
  
 It is necessary to seed the random number generator when you start your program (cf. 
 Section 7.14. You could use the time() function for this. It returns the actual time 
 measured in seconds since 1971.
  
 srand(time(NULL)); /*Initialisation of the random number generator*/
  
 When you found the right answer, the computer should congratulate you. The program 
 should also display the number of tries that where needed in order to guess the number.
  
 The program should also keep the a ‘High-Score’, that gets updated once our number of 
 trials is lower than any previous try. The High-Score (the number of minimal guesses) 
 should be stored in a struct, together with the name of the player.
  
 The High-Score() function should ask for your name and store it, when your current 
 number of tries is lower than the previous High-Score value.",NA
Appendix A,NA,NA
Coding Style,NA,NA
A.1 ,NA,NA
A short guide on style,"In the last few sections, I used the phrase “by convention” several times to indi-
 cate design decisions that are arbitrary in the sense that there are no significant 
 reasons to do things one way or another, but dictated by convention.
  
 In these cases, it is to your advantage to be familiar with convention and use it, 
 since it will make your programs easier for others to understand. At the same 
 time, it is important to distinguish between (at least) three kinds of rules:
  
 Divine law:
  This is my phrase to indicate a rule that is true because of some 
 underlying principle of logic or mathematics, and that is true in any pro-
 gramming language (or other formal system). For example, there is no way 
 to specify the location and size of a bounding box using fewer than four 
 pieces of information. Another example is that adding integers is 
 commutative. That’s part of the definition of addition and has nothing to 
 do with C.
  
 Rules of C:
  These are the syntactic and semantic rules of C that you cannot 
  
 violate, because the resulting program will not compile or run. Some are 
  
 arbitrary; for example, the fact that the = symbol represents assignment 
  
 and
  not
  equality. Others reflect underlying limitations of the compila-
  
 tion 
 or execution process. For example, you have to specify the types of 
  
 parameters, 
 but not arguments.
  
 Style and convention:
  There are a lot of rules that are not enforced by the 
 compiler, but that are essential for writing programs that are correct, that 
 you can debug and modify, and that others can read. Examples include 
 indentation and the placement of squiggly braces, as well as conventions 
 for naming variables, functions and types.",NA
A.2,NA,NA
Naming ,NA,NA
rules,NA,NA
conventions,NA,NA
and,NA,NA
capitalization,"As a general rule, you should always choose meaningful names for your identi-
 fiers. Ideally the name of a variable or function already explains its behaviour or 
 use.
  
 It may be more typing effort to use a function named FindSubString() rather 
 than FndSStr(). However, the former is almost self describing and might save 
 you a lot in debugging-time.
  
 Don’t use single letter variable names!
  
 Similarly to functions, you should give your variables names that speak for 
 themselves and make clear what values will be stored by this variable. There are 
 few noticeable exceptions to this rule: People use i, j and k as counter variables 
 in loops and for spacial coordinates people use x, y and z. Use these conventions 
 if they suit you. Don’t try to invent new conventions all by yourself.
  
 The following capitalization style shold be used for the different elements in 
 your program. The consistent use of one style gives the programmer and the 
 reader of the source code a quick way to determine the meaning of different 
 items in your program:
  
 variableNames: 
  
 variable names always start with lower-case, multiple words 
  
 are separated by capitalizing the first letter.
  
 CONSTANTS: 
 use all upper case letters. 
  
 In order to avoid name space 
  
 collisions it might be necessary to use a prefix such as MY_CONSTANT.
  
 FunctionNames:
  start always with upper case and should possibly contain a 
 verb describing the function. Names for functions that test values should 
 start with ’Is’ or ’Are’.
  
 UserDefinedTypes_t:
  always end in ’_t’. Type names names must be capi-
  
 talised in order to avoid conflict with POSIX names.
  
 pointerNames_p:
  in order to visually separate pointer variables from ordi-
  
 nary variables you should consider ending pointers with ’_p’.
  
 1
 www.scribd.com/doc/6878959/NASA-C-programming-guide",NA
A.3,NA,NA
Bracing style,"There exist different bracing or indent styles that serve the goal to make your 
 code more readable through the use of a consistent indentation for control block 
 structures. The styles differ in the way the braces are indented with the rest of 
 the control block. This book uses the BSD/Allman Style because its is the most 
 readable of the four. It needs more horizontal space than the K&R Style but it 
 makes it very easy to track opening and closing braces.
  
 When you are writing programs, make sure that you are using one style con-
 sistently. In larger projects all contributors should agree on the style they are 
 using. Modern programming environments like Eclipse support you through the 
 automatic enforcement of a single style.
  
 /*Whitesmiths Style*/ 
  
 if (condition) 
  
  
 { 
  
  
 statement1; 
  
  
 statement2; 
  
  
 }
  
 Is named after Whitesmiths C, an early commercial C compiler that used this style 
 in its examples. Some people refer to it as the One True Brace Style.
  
 /*GNU Style*/ 
  
 if (condition) 
  
  
 { 
  
  
  
 statement1; 
  
  
  
 statement2; 
  
  
 }
  
 Indents are always four spaces per level, with the braces halfway between the 
 outer and inner indent levels.
  
 /*K&R/Kernel Style*/ 
  
 if (condition) { 
  
  
 statement1; 
  
  
 statement2; 
  
 }
  
 This style is named after the programming examples in the book
  The C Program-
 ming Language
  by Brian W. Kernighan and Dennis Ritchie (the C inventors).
  
 The K&R style is the style that is hardest to read. The opening brace happens to 
 be at the far right side of the control statement and can be hard to find. The 
 braces therefore have different indentation levels. Nevertheless, many C 
 programs use this style. So you should be able to read it.
  
 /*BSD/Allman Style*/ 
  
 if (condition)",NA
A.4 ,NA,NA
Layout,"Block comments should be used at the top of your file, before all function decla-
 rations, to explain the purpose of the program and give additional information.
  
 You should also use a similar documentation style before every relevant function 
 in your program.
  
 /* 
  
 * File: 
  
  
 test.c 
  
 * Author: 
  
  
 Peter Programmer 
  
 * Date: 
  
  
 May, 29th, 2009 
  
 * 
  
 * Purpose: to demonstrate good programming 
  
 * practise 
  
 * /
  
 #include <stdlib.h>
  
 /* 
  
 * main function, does not use arguments 
  
 */
  
 int main (void) 
  
 { 
  
  
 return EXIT_SUCCESS; 
  
 }",NA
Appendix B ,NA,NA
ASCII-Table,"Dec
  
 Hex
  
 Oct
  
 Character
  
 Dec
  
 Hex
  
 Oct
  
 Character
  
 0 
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13 
  
 14 
  
 15 
  
 16 
  
 17 
  
 18 
  
 19 
  
 20 
  
 21 
  
 22 
  
 23 
  
 24 
  
 25 
  
 26 
  
 27 
  
 28 
  
 29 
  
 30 
  
 31
  
 0x00 
  
 0x01 
  
 0x02 
  
 0x03 
  
 0x04 
  
 0x05 
  
 0x06 
  
 0x07 
  
 0x08 
  
 0x09 
  
 0x0A 
 0x0B 
 0x0C 
 0x0D 
 0x0E 
 0x0F 
 0x10 
  
 0x11 
  
 0x12 
  
 0x13 
  
 0x14 
  
 0x15 
  
 0x16 
  
 0x17 
  
 0x18 
  
 0x19 
  
 0x1A 
 0x1B 
 0x1C 
 0x1D 
 0x1E 
 0x1F
  
 00
 0 
 00
 1 
 00
 2 
 00
 3 
 00
 4 
 00
 5 
 00
 6 
 00
 7 
 01
 0 
 01
 1 
 01
 2 
 01
 3 
 01
 4 
 01
 5 
 01
 6 
 01
 7 
 02
 0 
 02
 1 
 02
 2 
 02
 NUL 
  
 SOH 
  
 STX 
  
 ETX 
  
 EOT 
  
 ENQ 
  
 ACK 
  
 BEL 
  
 BS 
  
 TAB 
  
 LF 
  
 VT 
  
 FF 
  
 CR 
  
 SO 
  
 SI 
  
 DLE 
  
 DC1 
  
 DC2 
  
 DC3 
  
 DC4 
  
 NAK 
  
 SYN 
  
 ETB 
  
 CAN 
  
 EM 
  
 SUB 
  
 ESC 
  
 FS 
  
 GS 
  
 RS 
  
 US
  
 3
 2 
  
 3
 3 
  
 3
 4 
  
 3
 5 
  
 3
 6 
  
 3
 7 
  
 3
 8 
  
 3
 9 
  
 4
 0 
  
 4
 1 
  
 4
 2 
  
 4
 3 
  
 4
 4 
  
 4
 5 
  
 4
 6 
  
 4
 7 
  
 4
 8 
  
 4
 9 
  
 5
 0 
  
 5
 0x20 
  
 0x21 
  
 0x22 
  
 0x23 
  
 0x24 
  
 0x25 
  
 0x26 
  
 0x27 
  
 0x28 
  
 0x29 
  
 0x2A 
 0x2B 
 0x2C 
 0x2D 
 0x2E 
 0x2F 
 0x30 
  
 0x31 
  
 0x32 
  
 0x33 
  
 0x34 
  
 0x35 
  
 0x36 
  
 0x37 
  
 0x38 
  
 0x39 
  
 0x3A 
 0x3B 
 0x3C 
 0x3D 
 0x3E 
 0x3F
  
 04
 0 
 04
 1 
 04
 2 
 04
 3 
 04
 4 
 04
 5 
 04
 6 
 04
 7 
 05
 0 
 05
 1 
 05
 2 
 05
 3 
 05
 4 
 05
 5 
 05
 6 
 05
 7 
 06
 0 
 06
 1 
 06
 2 
 06
 SP 
  
 !
  
 ""’
  
 # 
  
 $ 
  
 % 
  
 &
  
 ’
  
 ( 
  
 ) 
  
 * 
  
 + 
  
 ,
  
 -
  
 .
  
 / 
  
 0 
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 : 
  
 ; 
  
 ""< 
  
 = 
  
 ""> 
  
 ?",NA
Index,"<ctype.h>, 98 
  
 <math.h>, 28 
  
 <stdio.h>, 28 
  
 <stdlib.h>, 82 
  
 <string.h>, 91, 93
  
 absolute value, 51 
  
 address, 95, 101 
  
 ambiguity, 6 
  
 argument, 27, 32, 35 
  
 arithmetic 
  
  
 floating-point, 26 
  
  
 integer, 19 
  
 array, 88 
  
  
 copying, 79 
  
  
 element, 78 
  
  
 length, 81 
  
 array parameters, 84 
  
 arrays, 77 
  
 assigning 
  
  
 string, 96 
  
 assignment, 16, 22, 63
  
 body, 73 
  
  
 loop, 65 
  
 bool, 56, 58 
  
 boolean, 54 
  
 bottom-up design, 85 
  
 bug, 3
  
 call, 35 
  
 call by reference, 84, 106, 110 
 call by value, 84, 106 
  
 character operator, 20 
  
 Chianti, 79 
  
 coding style, 113 
  
 comment, 7, 9 
  
 comparison 
  
  
 operator, 39
  
  
 string, 97 
  
 comparison operator, 54 
  
 compile, 2, 9 
  
 compile-time error, 4, 51 
  
 composition, 20, 22, 28, 53, 109 
 concatenate, 101 
  
 conditional, 39, 46 
  
  
 alternative, 40 
  
  
 chained, 41, 46 
  
  
 nested, 41, 46 
  
 constant values, 26 
  
 constants, 26 
  
 counter, 84, 101
  
 dead code, 50, 58 
  
 debugging, 3, 9, 51 
  
 declaration, 15, 104 
  
 decrement, 78, 101 
  
 deterministic, 81, 88 
  
 diagram 
  
  
 stack, 45, 71 
  
  
 state, 45 
  
 distribution, 83 
  
 division 
  
  
 floating-point, 66 
  
  
 integer, 19 
  
 double (floating-point), 25 
 Doyle, Arthur Conan, 5
  
 element, 78, 88 
  
 encapsulation, 68, 70, 73 
  
 error, 9 
  
  
 compile-time, 4, 51 
  
  
 logic, 4 
  
  
 run-time, 4 
  
 expression, 18, 20, 22, 27, 28, 79
  
 fava beans, 79 
  
 flag, 55",NA
