Larger Text,Smaller Text,Symbol
Programming from the Ground Up,NA,NA
Jonathan Bartlett,NA,NA
Edited by,NA,NA
"Dominick Bruno, Jr.",NA,NA
Table of Contents,"1. 
 Introduction................................................................................................................................1
  
 Welcome to Programming 
 .......................................................................................................1 Your 
 Tools................................................................................................................................2
  
 2. Computer Architecture 
 .............................................................................................................5
  
 Structure 
 of 
 Computer 
 Memory...............................................................................................5 
 The 
 CPU...................................................................................................................................6 
 Some 
 Terms 
 .............................................................................................................................7 Interpreting 
 Memory................................................................................................................9 
 Data 
 Accessing 
 Methods........................................................................................................10 
 Review 
 ...................................................................................................................................11
  
 3. Your First 
 Programs................................................................................................................13
  
 Entering 
 in 
 the 
 Program.........................................................................................................13 Outline of an 
 Assembly Language Program..........................................................................15 Planning the 
 Program.............................................................................................................19 Finding a 
 Maximum 
 Value.....................................................................................................22 
 Addressing 
 Modes 
 .................................................................................................................29 
 Review 
 ...................................................................................................................................31
  
 4. All About Functions.................................................................................................................35
  
 Dealing 
 with 
 Complexity.......................................................................................................35 
 How 
 Functions 
 Work 
 .............................................................................................................35 
 Assembly-Language 
 Functions 
 using 
 the 
 C 
 Calling 
 Convention 
 ..........................................37 
 A 
 Function 
 Example 
 ..............................................................................................................41 
 Recursive 
 Functions...............................................................................................................45 
 Review 
 ...................................................................................................................................51
  
 5. Dealing with Files.....................................................................................................................53
  
 The 
 UNIX 
 File 
 Concept.........................................................................................................53 Buffers and
  
 .bss
  ...................................................................................................................54 Standard 
 and Special Files.....................................................................................................55 Using 
 Files 
 in 
 a 
 Program........................................................................................................56",NA
Chapter 1. Introduction,NA,NA
Welcome to Programming,"I love programming. I enjoy the challenge to not only make a working program, but to do so 
 with style. Programming is like poetry. It conveys a message, not only to the computer, but to 
 those who modify and use your program. With a program, you build your own world with your 
 own rules. You create your world according to your conception of both the problem and the 
 solution.
  
 Masterful programmers create worlds with programs that are clear and succinct, much like a 
 poem or essay.
  
 One of the greatest programmers, Donald Knuth, describes programming not as telling a 
 computer how to do something, but telling a person how they would instruct a computer to do 
 something. The point is that programs are meant to be read by people, not just computers. Your 
 programs will be modified and updated by others long after you move on to other projects. Thus, 
 programming is not as much about communicating to a computer as it is communicating to those 
 who come after you. A programmer is a problem-solver, a poet, and an instructor all at once.
  
 Your goal is to solve the problem at hand, doing so with balance and taste, and teach your 
 solution to future programmers. I hope that this book can teach at least some of the poetry and 
 magic that makes computing exciting.
  
 Most introductory books on programming frustrate me to no end. At the end of them you can 
 still ask ""how does the computer really work?"" and not have a good answer. They tend to pass 
 over topics that are difficult even though they are important. I will take you through the difficult 
 issues because that is the only way to move on to masterful programming. My goal is to take you 
 from knowing nothing about programming to understanding how to think, write, and learn like a 
 programmer. You won’t know everything, but you will have a background for how everything 
 fits together. At the end of this book, you should be able to do the following:
  
 •
  Understand how a program works and interacts with other programs
  
 •
  Read other people’s programs and learn how they work
  
 •
  Learn new programming languages quickly
  
 •
  Learn advanced concepts in computer science quickly
  
 I will not teach you everything. Computer science is a massive field, especially when you 
 combine the theory with the practice of computer programming. However, I will attempt to get 
 you started on the foundations so you can easily go wherever you want afterwards.
  
 There is somewhat of a chicken and egg problem in teaching programming, especially 
 assembly language. There is a lot to learn - it’s almost too much to learn almost at once, but 
 each piece",NA
Your Tools,"This book teaches assembly language for x86 processors and the GNU/Linux operating system. 
 Therefore we will be giving all of the examples using the GNU/Linux standard GCC tool set. If 
 you are not familiar with GNU/Linux and the GCC tool set, they will be described shortly. If you 
 are new to Linux, you should check out the guide available at http://rute.sourceforge.net/
 1
 What I 
 intend to show you is more about programming in general than using a specific tool set on a 
 specific platform, but standardizing on one makes the task much easier.
  
 Those new to Linux should also try to get involved in their local GNU/Linux User’s Group.
  
 User’s Group members are usually very helpful for new people, and will help you from 
 everything from installing Linux to learning to use it most efficiently. A listing of 
 GNU/Linux User’s Groups is available at http://www.linux.org/groups/
  
 All of these programs have been tested using Red Hat Linux 8.0, and should work with any other 
 GNU/Linux distribution, too.
 2
 They will not work with non-Linux operating systems such as
  
 1. 
  
 This is quite a large document. You certainly don’t need to know everything to get started with this 
 book.
  
 You simply need to know how to navigate from the command line and how to use an editor like
  pico
 ,
  
 emacs
 ,
  
 or
  vi
  (or others).
  
 2. 
  
 By ""GNU/Linux distribution"", I mean an x86 GNU/Linux distribution. GNU/Linux distributions for the
  
 Power Macintosh, the Alpha processor, or other processors will not work with this book.
  
 2",NA
Chapter 2. Computer Architecture,"Before learning how to program, you need to first understand how a computer interprets 
 programs. You don’t need a degree in electrical engineering, but you need to understand some 
 basics.
  
 Modern computer architecture is based off of an architecture called the Von Neumann 
  
 architecture, named after its creator. The Von Neumann architecture divides the computer up 
 into two main parts - the CPU (for Central Processing Unit) and the memory. This architecture is 
 used in all modern computers, including personal computers, supercomputers, mainframes, and 
 even cell phones.",NA
Structure of Computer Memory,"To understand how the computer views memory, imagine your local post office. They usually 
 have a room filled with PO Boxes. These boxes are similar to computer memory in that each are 
 numbered sequences of fixed-size storage locations. For example, if you have 256 megabytes of 
 computer memory, that means that your computer contains roughly 256 million fixed-size 
 storage locations. Or, to use our analogy, 256 million PO Boxes. Each location has a number, 
 and each location has the same, fixed-length size. The difference between a PO Box and 
 computer memory is that you can store all different kinds of things in a PO Box, but you can 
 only store a single number in a computer memory storage location.
  
  
 Memory locations are like PO Boxes
  
 You may wonder why a computer is organized this way. It is because it is simple to implement. 
 If
  
 5",NA
The CPU,"So how does the computer function? Obviously, simply storing data doesn’t do much help - 
 you need to be able to access, manipulate, and move it. That’s where the CPU comes in.
  
 The CPU reads in instructions from memory one at a time and executes them. This is known as 
 the
  fetch-execute cycle
 . The CPU contains the following elements to accomplish this:
  
 •
  Program Counter
  
 •
  Instruction Decoder
  
 •
  Data bus
  
 •
  General-purpose registers
  
 •
  Arithmetic and logic unit
  
 The
  program counter
  is used to tell the computer where to fetch the next instruction from. We 
 mentioned earlier that there is no difference between the way data and programs are stored, they 
 are just interpreted differently by the CPU. The program counter holds the memory address of 
 the next instruction to be executed. The CPU begins by looking at the program counter, and 
 fetching
  
 6",NA
Some Terms,"Computer memory is a numbered sequence of fixed-size storage locations. The number attached 
 to each storage location is called it’s
  address
 . The size of a single storage location is called a
  
 byte
 . On x86 processors, a byte is a number between 0 and 255.
  
 You may be wondering how computers can display and use text, graphics, and even large 
 numbers when all they can do is store numbers between 0 and 255. First of all, specialized 
 hardware like graphics cards have special interpretations of each number. When displaying to the
  
 7",NA
Interpreting Memory,"Computers are very exact. Because they are exact, programmers have to be equally exact. A 
 computer has no idea what your program is supposed to do. Therefore, it will only do exactly 
 what you tell it to do. If you accidentally print out a regular number instead of the ASCII codes 
 that make up the number’s digits, the computer will let you - and you will wind up with jibberish 
 on your screen (it will try to look up what your number represents in ASCII and print that). If 
 you tell the computer to start executing instructions at a location containing data instead of 
 program instructions, who knows how the computer will interpret that - but it will certainly try. 
 The computer will execute your instructions in the exact order you specify, even if it doesn’t 
 make sense.
  
 The point is, the computer will do exactly what you tell it, no matter how little sense it makes.
  
 Therefore, as a programmer, you need to know exactly how you have your data arranged in 
 memory. Remember, computers can only store numbers, so letters, pictures, music, web pages, 
 documents, and anything else are just long sequences of numbers in the computer, which 
 particular programs know how to interpret.
  
 For example, say that you wanted to store customer information in memory. One way to do so 
 would be to set a maximum size for the customer’s name and address - say 50 ASCII characters 
 for each, which would be 50 bytes for each. Then, after that, have a number for the customer’s 
 age and their customer id. In this case, you would have a block of memory that would look like 
 this:
  
 Start of Record: 
  
 Customer’s name (50 bytes) - start of record 
  
 Customer’s address (50 bytes) - start of record + 50 bytes 
 Customer’s age (1 word - 4 bytes) - start of record + 100 bytes
  
 2. 
  
 Note that here we are talking about general computer theory. Some processors and operating systems
  
 actually mark the regions of memory that can be executed with a special marker that indicates this.
  
 9",NA
Data Accessing Methods,"Processors have a number of different ways of accessing data, known as addressing modes. 
 The simplest mode is
  immediate mode
 , in which the data to access is embedded in the 
 instruction itself. For example, if we want to initialize a register to 0, instead of giving the 
 computer an address to read the 0 from, we would specify immediate mode, and give it the 
 number 0.
  
 In the
  register addressing mode
 , the instruction contains a register to access, rather than 
 a memory location. The rest of the modes will deal with addresses.
  
 In the
  direct addressing mode
 , the instruction contains the memory address to access. For 
 example, I could say, please load this register with the data at address 2002. The computer 
 would go directly to byte number 2002 and copy the contents into our register.
  
 In the
  indexed addressing mode
 , the instruction contains a memory address to access, and also 
 specifies an
  index register
  to offset that address. For example, we could specify address 2002 and 
 an index register. If the index register contains the number 4, the actual address the data is loaded 
 from would be 2006. This way, if you have a set of numbers starting at location 2002, you can 
 cycle between each of them using an index register. On x86 processors, you can also specify a 
 multiplier
  for the index. This allows you to access memory a byte at a time or a word at a time (4 
 bytes). If you are accessing an entire word, your index will need to be multiplied by 4 to get the",NA
Review,NA,NA
Know the Concepts,"•
  Describe the fetch-execute cycle.
  
 •
  What is a register? How would computation be more difficult without registers?
  
 •
  How do you represent numbers larger than 255?
  
 •
  How big are the registers on the machines we will be using?
  
 •
  How does a computer know how to interpret a given byte or set of bytes of memory?
  
 •
  What are the addressing modes and what are they used for?
  
 •
  What does the instruction pointer do?
  
 11",NA
Use the Concepts,"•
  What data would you use in an employee record? How would you lay it out in memory?
  
 •
  If I had the pointer the the beginning of the employee record above, and wanted to access a 
  
 particular piece of data inside of it, what addressing mode would I use?
  
 •
  In base-pointer addressing mode, if you have a register holding the value 3122, and an offset of 
  
 20, what address would you be trying to access?
  
 •
  In indexed addressing mode, if the base address is 6512, the index register has a 5, and the 
  
 multiplier is 4, what address would you be trying to access?
  
 •
  In indexed addressing mode, if the base address is 123472, the index register has a 0, and the 
  
 multiplier is 4, what address would you be trying to access?
  
 •
  In indexed addressing mode, if the base address is 9123478, the index register has a 20, and the 
  
 multiplier is 1, what address would you be trying to access?",NA
Going Further,"•
  What are the minimum number of addressing modes needed for computation?
  
 •
  Why include addressing modes that aren’t strictly needed?
  
 •
  Research and then describe how pipelining (or one of the other complicating factors) affects 
  
 the fetch-execute cycle.
  
 •
  Research and then describe the tradeoffs between fixed-length instructions and variable-length 
  
 instructions.
  
 12",NA
Chapter 3. Your First Programs,"In this chapter you will learn the process for writing and building Linux assembly-language 
 programs. In addition, you will learn the structure of assembly-language programs, and a few 
 assembly-language commands. As you go through this chapter, you may want to refer also to 
 Appendix B and Appendix F.
  
 These programs may overwhelm you at first. However, go through them with diligence, read 
 them and their explanations as many times as necessary, and you will have a solid foundation of 
 knowledge to build on. Please tinker around with the programs as much as you can. Even if your 
 tinkering does not work, every failure will help you learn.",NA
Entering in the Program,"Okay, this first program is simple. In fact, it’s not going to do anything but exit! It’s short, but 
 it shows some basics about assembly language and Linux programming. You need to enter the 
 program in an editor exactly as written, with the filename
  exit.s
 . The program follows. 
 Don’t worry about not understanding it. This section only deals with typing it in and running it. 
 In the Section called
  Outline of an Assembly Language Program
  we will describe how it 
 works.
  
 #PURPOSE: Simple program that exits and returns a 
 # status code back to the Linux kernel #
  
 #INPUT: none 
  
 #
  
 #OUTPUT:
  
 returns a status code.
  
 This can be viewed
  
 #
  
 by typing
  
 # 
  
 # echo $?
  
 # 
  
 # after running the program 
  
 #
  
 #VARIABLES: 
  
 # %eax holds the system call number # (this 
 is always the case) 
  
 # 
  
 # %ebx holds the return status 
  
 # 
  
 .section .data
  
 13",NA
Outline of an Assembly Language Program,"Take a look at the program we just entered. At the beginning there are lots of lines that begin 
 with hashes (
 #
 ). These are
  comments
 . Comments are not translated by the assembler. They are 
 used only for the programmer to talk to anyone who looks at the code in the future. Most 
 programs you write will be modified by others. Get into the habit of writing comments in your 
 code that will help them understand both why the program exists and how it works. Always 
 include the following in your comments:
  
 •
  The purpose of the code
  
 •
  An overview of the processing involved
  
 •
  Anything strange your program does and why it does it
 3
  
 1. 
  
 If you are new to Linux and UNIX, you may not be aware that files don’t have to have extensions. In 
 fact, while Windows uses the
  .exe
  extension to signify an executable program, UNIX executables usually 
 have no extension.
  
 2. 
  
 .
  refers to the current directory in Linux and UNIX systems.
  
 3. 
  
 You’ll find that many programs end up doing things strange ways. Usually there is a reason for that, but, 
 unfortunately, programmers never document such things in their comments. So, future programmers either 
 have to learn the reason the hard way by modifying the code and watching it break, or just leaving it alone
  
 15",NA
Planning the Program,"In our next program we will try to find the maximum of a list of numbers. Computers are 
 very detail-oriented, so in order to write the program we will have to have planned out a 
 number of details. These details include:
  
 5. 
  
 You may be wondering why it’s
  0x80
  instead of just
  80
 . The reason is that the number is written in 
 hexadecimal. In hexadecimal, a single digit can hold 16 values instead of the normal 10. This is done by 
 utilizing the letters
  a
  through
  f
  in addition to the regular digits.
  a
  represents 10,
  b
  represents 11, and so 
 on. 0x10 represents the number 16, and so on. This will be discussed more in depth later, but just be aware 
 that numbers starting with
  0x
  are in hexadecimal. Tacking on an
  H
  at the end is also sometimes used 
 instead, but we won’t do that in this book. For more information about this, see Chapter 10 
  
  
 Actually, the interrupt transfers control to whoever set up an
  interrupt handler
  for the interrupt number. 
 6.
  
 In the case of Linux, all of them are set to be handled by the Linux kernel.
  
 7. 
  
 If you don’t watch Veggie Tales, you should.
  
 19",NA
Finding a Maximum Value,"Enter the following program as
  maximum.s
 :
  
 #PURPOSE: This program finds the maximum number of a 
 # set of data items.
  
 #
  
 #VARIABLES: The registers have the following uses: 
  
 # 
  
 # %edi - Holds the index of the data item being examined 
 # %ebx - Largest data item found 
  
 # %eax - Current data item 
  
 # 
  
 # The following memory locations are used: 
  
 #
  
 # data_items - contains the item data. 
 # 
  
 to terminate the data #
  
 .section .data
  
 A 0 is used
  
 data_items: 
  
 #These are the data items 
  
 .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0
  
 .section .text
  
  
 .globl _start 
  
 _start: 
  
  
 movl $0, %edi 
  
 # move 0 into the index register 
  
  
 movl data_items(,%edi,4), %eax # load the first byte of data 
  
 movl %eax, %ebx 
  
 # since this is the first item, %eax is 
   
 # the biggest
  
 start_loop: 
  
  
 # start loop 
  
  
 cmpl $0, %eax 
  
 # check to see if we’ve hit the end 
  
 je loop_exit 
  
  
 incl %edi 
  
 # load next value 
  
  
 movl data_items(,%edi,4), %eax 
  
  
 cmpl %ebx, %eax 
  
 # compare values 
  
  
 jle start_loop 
  
 # jump to loop beginning if the new
  
 22",NA
Addressing Modes,"In the Section called
  Data Accessing Methods
  in Chapter 2 we learned the different types of 
 addressing modes available for use in assembly language. This section will deal with how 
 those addressing modes are represented in assembly language instructions.
  
 The general form of memory address references is this:
  
 ADDRESS_OR_OFFSET(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)
  
 All of the fields are optional. To calculate the address, simply perform the following calculation:
  
 FINAL ADDRESS = ADDRESS_OR_OFFSET + %BASE_OR_OFFSET + MULTIPLIER * %INDEX
  
 ADDRESS_OR_OFFSET
  and
  MULTIPLIER
  must both be constants, while the other two must 
 be registers. If any of the pieces is left out, it is just substituted with zero in the equation.
  
 All of the addressing modes mentioned in the Section called
  Data Accessing Methods
  in Chapter 
 2 except immediate-mode can be represented in this fashion.
  
 direct addressing mode
  
 This is done by only using the
  ADDRESS_OR_OFFSET
  portion. Example:
  
 movl ADDRESS, %eax
  
 This loads
  %eax
  with the value at memory address
  ADDRESS
 .
  
 indexed addressing mode
  
 This is done by using the
  ADDRESS_OR_OFFSET
  and the
  %INDEX
  portion. You can use any 
 general-purpose register as the index register. You can also have a constant multiplier of 1, 
 2, or 4 for the index register, to make it easier to index by bytes, double-bytes, and words. 
 For example, let’s say that we had a string of bytes as
  string_start
  and wanted to access 
 the third one (an index of 2 since we start counting the index at zero), and
  %ecx
  held the 
 value 2. If you wanted to load it into
  %eax
  you could do the following:
  
 movl string_start(,%ecx,1), %eax
  
 29",NA
Review,NA,NA
Know the Concepts,"•
  What does if mean if a line in the program starts with the ’#’ character?
  
 •
  What is the difference between an assembly language file and an object code file?
  
 13. When we talk about the most or least
  significant
  byte, it may be a little confusing. Let’s take the number 
 5432. In that number, 54 is the most significant half of that number and 32 is the least significant half. You 
 can’t quite divide it like that for registers, since they operate on base 2 rather than base 10 numbers, but 
 that’s the basic idea. For more information on this topic, see Chapter 10.
  
 31",NA
Use the Concepts,"•
  Modify the first program to return the value 3.
  
 •
  Modify the
  maximum
  program to find the minimum instead.
  
 •
  Modify the
  maximum
  program to use the number 255 to end the list rather than the number 0
 •
  
 Modify the
  maximum
  program to use an ending address rather than the number 0 to know when 
  
 to stop.
  
 •
  Modify the
  maximum
  program to use a length count rather than the number 0 to know when to 
  
 stop.
  
 •
  What would the instruction
  movl _start, %eax
  do? Be specific, based on your knowledge 
 of both addressing modes and the meaning of
  _start
 . How would this differ from the 
 instruction
  movl $_start, %eax
 ?
  
 32",NA
Going Further,"•
  Modify the first program to leave off the
  int
  instruction line. Assemble, link, and execute 
 the 
  
 new program. What error message do you get. Why do you think this might be?
  
 •
  So far, we have discussed three approaches to finding the end of the list - using a special 
 number, using the ending address, and using the length count. Which approach do you think is 
 best? Why? Which approach would you use if you knew that the list was sorted? Why?
  
 33",NA
Chapter 4. All About Functions,NA,NA
Dealing with Complexity,"In Chapter 3, the programs we wrote only consisted of one section of code. However, if we 
 wrote real programs like that, it would be impossible to maintain them. It would be really 
 difficult to get multiple people working on the project, as any change in one part might adversely 
 affect another part that another developer is working on.
  
 To assist programmers in working together in groups, it is necessary to break programs apart into 
 separate pieces, which communicate with each other through well-defined interfaces. This way, 
 each piece can be developed and tested independently of the others, making it easier for multiple 
 programmers to work on the project.
  
 Programmers use
  functions
  to break their programs into pieces which can be independently 
 developed and tested. Functions are units of code that do a defined piece of work on specified 
 types of data. For example, in a word processor program, I may have a function called 
  
 handle_typed_character
  which is activated whenever a user types in a key. The data the 
 function uses would probably be the keypress itself and the document the user currently has 
 open.
  
 The function would then modify the document according to the keypress it was told about.
  
 The data items a function is given to process are called it’s
  parameters
 . In the word processing 
 example, the key which was pressed and the document would be considered parameters to the 
 handle_typed_characters
  function. Much care goes into determining what parameters a 
 function takes, because if it is called from many places within a project, it is difficult to change if 
 necessary.
  
 A typical program is composed of thousands of functions, each with a small, well-defined task to 
 perform. However, ultimately there are things that you cannot write functions for which must be 
 provided by the system. Those are called
  primitive functions
  (or just
  primitives
 ) - they are the 
 basics which everything else is built off of. For example, imagine a program that draws a 
 graphical user interface. There has to be a function to create the menus. That function probably 
 calls other functions to write text, to write icons, to paint the background, calculate where the 
 mouse pointer is, etc. However, ultimately, they will reach a set of primitives provided by the 
 operating system to do basic line or point drawing. Programming can either be viewed as 
 breaking a large program down into smaller pieces until you get to the primitive functions, or 
 building functions on top of primitives until you get the large picture in focus. In assembly 
 language, the primitives are usually the same thing as the system calls, even though they aren’t 
 true functions as we will talk about.
  
 35",NA
How Functions Work,"Functions are composed of several different pieces:
  
 function name
  
 A function’s name is a symbol that represents the address where the function’s code starts. 
 In assembly language, the symbol is defined by typing the the function’s name followed by 
 a colon immediately before the function’s code. This is just like labels you have used for 
 jumping.
  
 function parameters
  
 A function’s parameters are the data items that are explicitly given to the function for 
 processing. For example, in mathematics, there is a sine function. If you were to ask a 
 computer to find the sine of 2, sine would be the function’s name, and 2 would be the 
 parameter. Some functions have many parameters, others have none. Function 
 parameters can also be used to hold data that the function wants to send back to the 
 program.
  
 local variables
  
 Local variables are data storage that a function uses while processing that is thrown away it 
 returns. It’s kind of like a scratch pad of paper. You get a new piece of paper every time the 
 function is activated, and you have to throw it away when you are finished processing. 
 Local variables of a function are not accessible to any other function within a program.
  
 static variables
  
 Static variables are data storage that a function uses while processing that is not thrown 
 away afterwards, but is reused for every time the function’s code is activated. This data is 
 not accessible to any other part of the program. Static variables are generally not used 
 unless absolutely necessary, as they can cause problems later on.
  
 global variables
  
 Global variables are data storage that a function uses for processing which are managed 
 outside the function. For example, a simple text editor may put the entire contents of the file 
 it is working on in a global variable so it doesn’t have to be passed to every function that 
 operates on it.
 1
 Configuration values are also often stored in global variables.
  
 1. 
  
 This is generally considered bad practice. Imagine if a program is written this way, and in the next 
 version they decided to allow a single instance of the program edit multiple files. Each function would then 
 have to be modified so that the file that was being manipulated would be passed as a parameter. If you had 
 simply passed it as a parameter to begin with, most of your functions could have survived your upgrade 
 unchanged.
  
 36",NA
Assembly-Language Functions using the C Calling Convention,"You cannot write assembly-language functions without understanding how the computer’s
  stack 
 works. Each computer program that runs uses a region of memory called the stack to enable 
 functions to work properly. Think of a stack as a pile of papers on your desk which can be added 
 to indefinitely. You generally keep the things that you are working on toward the top, and you 
 take things off as you are finished working with them.
  
 Your computer has a stack, too. The computer’s stack lives at the very top addresses of memory. 
 You can push values onto the top of the stack through an instruction called
  pushl
 , which 
 pushes
  
 2. 
  
 A
  convention
  is a way of doing things that is standardized, but not forcibly so. For example, it is a 
 convention for people to shake hands when they meet. If I refuse to shake hands with you, you may think I 
 don’t like you. Following conventions is important because it makes it easier for others to understand what 
 you are doing, and makes it easier for programs written by multiple independent authors to work together.
  
 37",NA
Destruction of Registers,"When you call a function, you should assume that everything currently in your 
 registers will be wiped out. The only register that is guaranteed to be left with the 
 value it started with is
  %ebp
 .
  %eax
  is guaranteed to be overwritten, and the others 
 likely are. If there are registers you want to save before calling a function, you need to 
 save them by pushing them on the stack before pushing the function’s paramters. 
 You can then pop them back off in reverse order after popping off the parameters. 
 Even if you know a function does not overwrite a register you should save it, because 
 future versions of that function may.
  
 Other languages’ calling conventions may be different. For example, other calling 
 conventions may place the burden on the function to save any registers it uses. Be 
 sure to check to make sure the calling conventions of your languages are 
 compatible before trying to mix languages. Or in the case of assembly language, be 
 sure you know how to call the other language’s functions. them.
  
 Extended Specification:
  Details of the C language calling convention (also known as the 
 ABI, or Application Binary Interface) is available online. We have oversimplified and left 
 out several important pieces to make this simpler for new programmers. For full details, 
 you should check out the documents available at http://www.linuxbase.org/spec/refspecs/ 
 Specifically, you should look for the
  System V Application Binary Interface - Intel386 
 Architecture Processor Supplement
 .
  
 4. 
  
 This is not always strictly needed unless you are saving registers on the stack before a function call. The 
 base pointer keeps the stack frame in a reasonably consistent state. However, it is still a good idea, and is 
 absolutely necessary if you are temporarily saving registers on the stack..
  
 41",NA
A Function Example,"Let’s take a look at how a function call works in a real program. The function we are going to
  
 write is the
  power
  function. We will give the power function two parameters - the number and
  
 the power we want to raise it to. For example, if we gave it the paramters 2 and 3, it would raise 
 2
  
 to the power of 3, or 2*2*2, giving 8. In order to make this program simple, we will only allow
  
 numbers 1 and greater.
  
 The following is the code for the complete program. As usual, an explanation follows. Name the
  
 file
  power.s
 .
  
 #PURPOSE: Program to illustrate how functions work
  
 # This program will compute the value of
  
 # 2^3 + 5^2
  
 #
  
 #Everything in the main program is stored in registers,
  
 #so the data section doesn’t have anything.
  
 .section .data
  
 .section .text
  
 .globl _start
  
 _start:
  
 pushl $3 
  
 #push second argument
  
 pushl $2 
  
 #push first argument
  
 call 
  
 power 
  
 #call the function
  
 addl 
  
 $8, %esp 
  
 #move the stack pointer back
  
 pushl %eax 
  
 #save the first answer before
  
 #calling the next function
  
 pushl $2 
  
 #push second argument
  
 pushl $5 
  
 #push first argument
  
 call 
  
 power 
  
 #call the function
  
 addl 
  
 $8, %esp 
  
 #move the stack pointer back
  
 popl 
  
 %ebx 
  
 #The second answer is already
  
 #in %eax. 
  
 We saved the
  
 #first answer onto the stack,
  
 #so now we can just pop it
  
 #out into %ebx
  
 addl
  
 %eax, %ebx
  
 #add them together
  
 #result in %ebx
  
 42",NA
Recursive Functions,"The next program will stretch your brains even more. The program will compute the
  factorial
  of 
 a number. A factorial is the product of a number and all the numbers between it and one. For 
 example, the factorial of 7 is 7*6*5*4*3*2*1, and the factorial of 4 is 4*3*2*1. Now, one thing 
 you might notice is that the factorial of a number is the same as the product of a number and the 
 factorial just below it. For example, the factorial of 4 is 4 times the factorial of 3. The factorial of 
 3 is 3 times the factorial of 2. 2 is 2 times the factorial of 1. The factorial of 1 is 1. This type of 
 definition is called a recursive definition. That means, the definition of the factorial function
  
 45",NA
Review,NA,NA
Know the Concepts,"•
  What are primitives?
  
 •
  What are calling conventions?
  
 •
  What is the stack?
  
 •
  How do
  pushl
  and
  popl
  affect the stack? What special-purpose register do they affect?
  
 •
  What are local variables and what are they used for?
  
 •
  Why are local variables so necessary in recursive functions?
  
 •
  What are
  %ebp
  and
  %esp
  used for?
  
 •
  What is a stack frame?",NA
Use the Concepts,"•
  Write a function called
  square
  which receives 1 argument and returns the square of that 
  
 argument.
  
 •
  Write a program to test your
  square
  function.
  
 •
  Convert the maximum program given in the Section called
  Finding a Maximum Value
  in 
 Chapter 3 so that it is a function which takes a pointer to several values and returns their
  
 51",NA
Going Further,"•
  Do you think it’s better for a system to have a large set of primitives or a small one, assuming 
  
 that the larger set can be written in terms of the smaller one?
  
 •
  The factorial function can be written non-recursively. Do so.
  
 •
  Find an application on the computer you use regularly. Try to locate a specific feature, and 
 practice breaking that feature out into functions. Define the function interfaces between that 
 feature and the rest of the program.
  
 •
  Come up with your own calling convention. Rewrite the programs in this chapter using it. An 
 example of a different calling convention would be to pass paramters in registers rather than 
 the stack, to pass them in a different order, to return values in other registers or memory 
 locations. Whatever you pick, be consistent and apply it throughout the whole program.
  
 •
  Can you build a calling convention without using the stack? What limitations might it have?
  
 •
  What test cases should we use in our example program to check to see if it is working properly?
  
 52",NA
Chapter 5. Dealing with Files,"A lot of computer programming deals with files. After all, when we reboot our computers, the 
 only thing that remains from previous sessions are the things that have been put on disk. Data 
 which is stored in files is called
  persistent
  data, because it persists in files that remain on the disk 
 even when the program isn’t running..",NA
The UNIX File Concept,"Each operating system has it’s own way of dealing with files. However, the UNIX method, 
 which is used on Linux, is the simplest and most universal. UNIX files, no matter what program 
 created them, can all be accessed as a sequential stream of bytes. When you access a file, you 
 start by opening it by name. The operating system then gives you a number, called a
  file 
 descriptor
 , which you use to refer to the file until you are through with it. You can then read and 
 write to the file using its file descriptor. When you are done reading and writing, you then close 
 the file, which then makes the file descriptor useless.
  
 In our programs we will deal with files in the following ways:
  
 1. Tell Linux the name of the file to open, and in what mode you want it opened (read, write, 
 both read and write, create it if it doesn’t exist, etc.). This is handled with the
  open
  system 
 call, which takes a filename, a number representing the mode, and a permission set as its 
 parameters.
  %eax
  will hold the system call number, which is 5. The address of the first 
 character of the filename should be stored in
  %ebx
 . The read/write intentions, represented 
 as a number, should be stored in
  %ecx
 . For now, use 0 for files you want to read from, and 
 03101 for files you want to write to (you must include the leading zero).
 1
 Finally, the 
 permission set should be stored as a number in
  %edx
 . If you are unfamiliar with UNIX 
 permissions, just use 0666 for the permissions (again, you must include the leading zero).
  
 2. Linux will then return to you a file descriptor in
  %eax
 . Remember, this is a number that you 
  
 use to refer to this file throughout your program.
  
 3. Next you will operate on the file doing reads and/or writes, each time giving Linux the file 
 descriptor you want to use.
  read
  is system call 3, and to call it you need to have the file 
 descriptor in
  %ebx
 , the address of a buffer for storing the data that is read in
  %ecx
 , and the 
 size of the buffer in
  %edx
 . Buffers will be explained in the Section called
  Buffers and
  
 .bss
 .
  
 read
  will return with either the number of characters read from the file, or an error code.
  
 Error codes can be distinguished because they are always negative numbers (more 
  
 information on negative numbers can be found in Chapter 10).
  write
  is system call 4, and 
 it
  
 1. 
  
 This will be explained in more detail in the Section called
  Truth, Falsehood, and Binary Numbers
  in
  
 Chapter 10.",NA
Buffers and,NA,NA
 .bss,"In the previous section we mentioned buffers without explaining what they were. A buffer is a 
 continuous block of bytes used for bulk data transfer. When you request to read a file, the 
 operating system needs to have a place to store the data it reads. That place is called a buffer.
  
 Usually buffers are only used to store data temporarily, and it is then read from the buffers and 
 converted to a form that is easier for the programs to handle. Our programs won’t be 
 complicated enough to need that done. For an example, let’s say that you want to read in a single 
 line of text from a file but you do not know how long that line is. You would then simply read a 
 large number of bytes/characters from the file into a buffer, look for the end-of-line character, 
 and copy all of the characters to that end-of-line character to another location. If you didn’t find 
 and end-of-line character, you would allocate another buffer and continue reading. You would 
 probably wind up with some characters left over in your buffer in this case, which you would use 
 as the starting point when you next need data from the file.
 2
  
 Another thing to note is that buffers are a fixed size, set by the programmer. So, if you want to 
 read in data 500 bytes at a time, you send the
  read
  system call the address of a 500-byte unused 
 location, and send it the number 500 so it knows how big it is. You can make it smaller or 
 bigger, depending on your application’s needs.
  
 To create a buffer, you need to either reserve static or dynamic storage. Static storage is what we 
 have talked about so far, storage locations declared using
  .long
  or
  .byte
  directives. Dynamic 
 storage will be discussed in the Section called
  Getting More Memory
  in Chapter 9. There are 
 problems, though, with declaring buffers using
  .byte
 . First, it is tedious to type. You would 
 have to type 500 numbers after the
  .byte
  declaration, and they wouldn’t be used for anything 
 but to take up space. Second, it uses up space in the executable. In the examples we’ve used so 
 far, it doesn’t use up too much, but that can change in larger programs. If you want 500 bytes 
 you have to type in 500 numbers and it wastes 500 bytes in the executable. There is a solution to 
 both of these. So far, we have discussed two program sections, the
  .text
  and the
  .data
  
 sections. There is another section called the
  .bss
 . This section is like the data section, except 
 that it doesn’t take up space in the executable. This section can reserve storage, but it can’t 
 initialize it. In the
  .data
  
 2. 
  
 While this sounds complicated, most of the time in programming you will not need to deal directly with 
 buffers and file descriptors. In Chapter 8 you will learn how to use existing code present in Linux to handle 
 most of the complications of file input/output for you.
  
 54",NA
Standard and Special Files,"You might think that programs start without any files open by default. This is not true. 
 Linux programs usually have at least three open file descriptors when they begin. They are:
  
 STDIN
  
 This is the
  standard input
 . It is a read-only file, and usually represents your keyboard.
 3
 This 
 is always file descriptor 0.
  
 STDOUT
  
 This is the
  standard output
 . It is a write-only file, and usually represents your screen 
 display. This is always file descriptor 1.
  
 STDERR
  
 This is your
  standard error
 . It is a write-only file, and usually represents your screen 
 display. Most regular processing output goes to
  STDOUT
 , but any error messages that 
 come
  
 3. 
  
 As we mentioned earlier, in Linux, almost everything is a ""file"". Your keyboard input is considered a 
 file,
  
 and so is your screen display.",NA
Using Files in a Program,"We are going to write a simple program to illustrate these concepts. The program will take two 
 files, and read from one, convert all of its lower-case letters to upper-case, and write to the 
 other file. Before we do so, let’s think about what we need to do to get the job done:
  
 •
  
 •
  
 •
  
 Have a function that takes a block of memory and converts it to upper-case. This function 
 would need an address of a block of memory and its size as parameters.
  
 Have a section of code that repeatedly reads in to a buffer, calls our conversion function on 
 the buffer, and then writes the buffer back out to the other file.
  
 Begin the program by opening the necessary files.
  
 Notice that I’ve specified things in reverse order that they will be done. That’s a useful trick in 
 writing complex programs - first decide the meat of what is being done. In this case, it’s 
 converting blocks of characters to upper-case. Then, you think about what all needs to happen to 
 get that done. In this case, you have to open files, and continually read and write blocks to disk. 
 One of the keys of programming is continually breaking down problems into smaller and smaller 
 chunks until it’s small enough that you can easily solve the problem. Then you can build these 
 chunks back up until you have a working program.
 4
  
 You may have been thinking that you will never remember all of these numbers being thrown at 
 you - the system call numbers, the interrupt number, etc. In this program we will also introduce a 
 new directive,
  .equ
  which should help out.
  .equ
  allows you to assign names to numbers. For
  
 4. 
  
 Maureen Sprankle’s
  Problem Solving and Programming Concepts
  is an excellent book on the problem-
  
 solving process applied to computer programming.
  
 56",NA
Review,NA,NA
Know the Concepts,"•
  Describe the lifecycle of a file descriptor.
  
 •
  What are the standard file descriptors and what are they used for?
  
 •
  What is a buffer?
  
 •
  What is the difference between the
  .data
  section and the
  .bss
  section?
  
 •
  What are the system calls related to reading and writing files?",NA
Use the Concepts,"•
  Modify the
  toupper
  program so that it reads from
  STDIN
  and writes to
  STDOUT
  instead of 
  
 using the files on the command-line.
  
 •
  Change the size of the buffer.
  
 •
  Rewrite the program so that it uses storage in the
  .bss
  section rather than the stack to store the 
  
 file descriptors.
  
 •
  Write a program that will create a file called
  heynow.txt
  and write the words ""Hey diddle 
  
 diddle!"" into it.",NA
Going Further,"•
  What difference does the size of the buffer make?
  
 •
  What error results can be returned by each of these system calls?
  
 •
  Make the program able to either operate on command-line arguments or use
  STDIN
  or
  
 STDOUT 
  
 based on the number of command-line arguments specified by
  ARGC
 .
  
 •
  Modify the program so that it checks the results of each system call, and prints out an error 
  
 message to
  STDOUT
  when it occurs.
  
 66",NA
Chapter 6. Reading and Writing Simple Records,"As mentioned in Chapter 5, many applications deal with data that is
  persistent
  - meaning that the 
 data lives longer than the program by being stored on disk inf files. You can shut down the 
 program and open it back up, and you are back where you started. Now, there are two basic 
 kinds of persistent data - structured and unstructured. Unstructured data is like what we dealt 
 with in the
  toupper
  program. It just dealt with text files that were entered by a person. The 
 contents of the files weren’t usable by a program because a program can’t interpret what the user 
 is trying to say in random text.
  
 Structured data, on the other hand, is what computers excel at handling. This is data that is 
 divided up into fields and records. For the most part, the fields and records are fixed-length. 
 Because the data is divided into fixed-length records and fixed-format fields, the computer 
 can interpret the data. Structured data can contain variable-length fields, but at that point you 
 are usually better off with a database.
 1
  
 This section deals with reading and writing simple fixed-length records. Let’s say we wanted to 
 store some basic information about people we know. We could imagine the following example 
 fixed-length record about people:
  
 •
  Firstname - 40 bytes
  
 •
  Lastname - 40 bytes
  
 •
  Address - 240 bytes
  
 •
  Age - 4 bytes
  
 In this, everything is character data except for the age, which is simply a numeric field, using a 
 standard 4-byte word (we could just use a single byte for this, but keeping it at a word makes it 
 easier to process).
  
 In programming, you often have certain definitions that you will use over and over again within 
 the program, or perhaps within several programs. It is good to separate these out into files that 
 are simply included into the assembly language files as needed. For example, in our next 
 programs we will need to access the different parts of the record above. This means we need to 
 know the offsets of each field from the beginning of the record in order to access them using 
 base pointer addressing. The following constants describe the offsets to the above structure. Put 
 them in a file named
  record-def.s
 :
  
 1. 
  
 A database is a program which handles persistent structured data for you. You don’t have to write the 
 programs to read and write the data to disk, to do lookups, or even to do basic processing. It is a very high-
 level interface to structured data which, although it adds some overhead and additional complexity, is very 
 useful for complex data processing tasks. References for learning how databases work are listed in Chapter 
 13.
  
 67",NA
Writing Records,"This program will simply write some hardcoded records to disk. It will:
  
 •
  Open the file
  
 •
  Write three records
  
 70",NA
Reading Records,"Now we will consider the process of reading records. In this program, we will read each record 
 and display the first name listed with each record.
  
 Since each person’s name is a different length, we will need a function to count the number of 
 characters we want to write. Since we pad each field with null characters, we can simply count 
 characters until we reach a null byte.
 2
 Note that this means our records must contain at least one 
 null byte each.
  
 Here is the code. Put it in a file called
  count-chars.s
 :
  
 #PURPOSE: Count the characters until a null byte is reached.
  
 # 
  
 #INPUT: The address of the character string # 
  
 #OUTPUT: Returns the count in %eax 
  
 # 
  
 #PROCESS:
  
 2.
  
 If you have used C, this is what the
  strlen
  function does.
  
 74",NA
Modifying the Records,"In this section, we will write a program that:
  
 •
  Opens an input and output file
  
 •
  Reads records from the input
  
 •
  Increments the age
  
 •
  Writes the new record to the output file
  
 Like most programs we’ve encountered recently, this program is pretty straightforward.
 3
  
 .include ""linux.s"" 
  
 .include ""record-def.s""
  
 .section .data 
  
 input_file_name:
  
 3. 
  
 You will find that after learning the mechanics of programming, most programs are pretty 
 straightforward once you know exactly what it is you want to do. Most of them initialize data, do some 
 processing in a loop, and then clean everything up.
  
 79",NA
Review,NA,NA
Know the Concepts,"•
  What is a record?
  
 •
  What is the advantage of fixed-length records over variable-length records?
  
 •
  How do you include constants in multiple assembly source files?
  
 •
  Why might you want to split up a project into multiple source files?
  
 •
  What does the instruction
  incl record_buffer + RECORD_AGE
  do? What addressing 
 mode is it using? How many operands does the
  incl
  instructions have in this case? Which 
 parts are being handled by the assembler and which parts are being handled when the program 
 is run?",NA
Use the Concepts,"•
  Add another data member to the person structure defined in this chapter, and rewrite the 
 reading and writing functions and programs to take them into account. Remember to 
 reassemble and relink your files before running your programs.
  
 •
  Create a program that uses a loop to write 30 identical records to a file.
  
 •
  Create a program to find the largest age in the file and return that age as the status code of the 
  
 program.
  
 •
  Create a program to find the smallest age in the file and return that age as the status code of the 
  
 program.",NA
Going Further,"•
  Rewrite the programs in this chapter to use command-line arguments to specify the filesnames.
  
 82",NA
Chapter 7. Developing Robust Programs,"This chapter deals with developing programs that are
  robust
 . Robust programs are able to handle 
 error conditions gracefully. They are programs that do not crash no matter what the user does. 
 Building robust programs is essential to the practice of programming. Writing robust programs 
 takes discipline and work - it is usually finding every possible problem that can occur, and 
 coming up with an action plan for your program to take.",NA
Where Does the Time Go?,"Programmers schedule poorly. In almost every programming project, programmers will take 
 two, four, or even eight times as long to develop a program or function than they originally 
 estimated.
  
 There are many reasons for this problem, including:
  
 •
  Programmers don’t always schedule time for meetings or other non-coding activities that make 
  
 up every day.
  
 •
  Programmers often underestimate feedback times (how long it takes to pass change requests 
  
 and approvals back and forth) for projects.
  
 •
  Programmers don’t always understand the full scope of what they are producing.
  
 •
  Programmers often have to estimate a schedule on a totally different kind of project than they 
  
 are used to, and thus are unable to schedule accurately.
  
 •
  Programmers often underestimate the amount of time it takes to get a program fully robust.
  
 The last item is the one we are interested in here.
  It takes a lot of time and effort to develop 
 robust programs.
  More so than people usually guess, including experienced programmers. 
 Programmers get so focused on simply solving the problem at hand that they fail to look at the 
 possible side issues.
  
 In the
  toupper
  program, we do not have any course of action if the file the user selects does 
 not exist. The program will go ahead and try to work anyway. It doesn’t report any error 
 message so the user won’t even know that they typed in the name wrong. Let’s say that the 
 destination file is on a network drive, and the network temporarily fails. The operating system is 
 returning a status code to us in
  %eax
 , but we aren’t checking it. Therefore, if a failure occurs, 
 the user is totally unaware. This program is definitely not robust. As you can see, even in a 
 simple program there are a lot of things that can go wrong.
  
 In a large program, it gets much more problematic. There are usually many more possible error 
 conditions than possible successful conditions. Therefore, you should always expect to spend the 
 majority of your time checking status codes, writing error handlers, and performing similar tasks 
 to make your program robust. If it takes two weeks to develop a program, it will likely take at
  
 85",NA
Some Tips for Developing Robust Programs,NA,NA
User Testing,"Testing is one of the most essential things a programmer does. If you haven’t tested something, 
 you should assume it doesn’t work. However, testing isn’t just about making sure your program 
 works, it’s about making sure your program doesn’t break. For example, if I have a program that 
 is only supposed to deal with positive numbers, you need to test what happens if the user enters a 
 negative number. Or a letter. Or the number zero. You must test what happens if they put spaces 
 before their numbers, spaces after their numbers, and other little possibilities. You need to make 
 sure that you handle the user’s data in a way that makes sense to the user, and that you pass on 
 that data in a way that makes sense to the rest of your program. When your program finds input 
 that doesn’t make sense, it needs to perform appropriate actions. Depending on your program, 
 this may include ending the program, prompting the user to re-enter values, notifying a central 
 error log, rolling back an operation, or ignoring it and continuing.
  
 Not only should you test your programs, you need to have others test it as well. You should 
 enlist other programmers and users of your program to help you test your program. If something 
 is a problem for your users, even if it seems okay to you, it needs to be fixed. If the user doesn’t 
 know how to use your program correctly, that should be treated as a bug that needs to be fixed.
  
 You will find that user’s find a lot more bugs in your program than you ever could. The reason is 
 that user’s don’t know what the computer expects. You know what kinds of data the computer 
 expects, and therefore are much more likely to enter data that makes sense to the computer. 
 User’s enter data that makes sense to them. Allowing non-programmers to use your program 
 usually gives you much more accurate results as to how robust your program truly is.",NA
Data Testing,"When designing programs, each of your functions needs to be very specific about the type and 
 range of data that it will or won’t accept. You then need to test these functions to make sure that 
 they perform to specification. Most important is testing
  corner cases
  or
  edge cases
 . Corner cases 
 are the inputs that are most likely to cause problems or behave unexpectedly.
  
 When testing numeric data, there are several corner cases you always need to test:
  
 •
  The number 0
  
 86",NA
Module Testing,"Not only should you test your program as a whole, you need to test the individual pieces of your 
 program. As you develop your program, you should test individual functions by providing it with 
 data you create to make sure it responds appropriately.
  
 In order to do this effectively, you have to develop functions whose sole purpose is to call 
 functions for testing. These are called
  drivers
  (not to be confused with hardware drivers) . They 
 simply loads your function, supply it with data, and check the results. This is especially useful if 
 you are working on pieces of an unfinished program. Since you can’t test all of the pieces 
 together, you can create a driver program that will test each function individually.
  
 Also, the code you are testing may make calls to functions not developed yet. In order to 
 overcome this problem, you can write a small function called a
  stub
  which simply returns 
 the
  
 87",NA
Handling Errors Effectively,"Not only is it important to know how to test, but it is also important to know what to do when 
 one is detected.",NA
Have an Error Code for Everything,"Truly robust software has a unique error code for every possible contingency. By simply 
 knowing the error code, you should be able to find the location in your code where that error was 
 signalled.
  
 This is important because the error code is usually all the user has to go on when reporting 
 errors. Therefore, it needs to be as useful as possible.
  
 Error codes should also be accompanied by descriptive error messages. However, only in rare 
 circumstances should the error message try to predict
  why
  the error occurred. It should simply 
 relate what happened. Back in 1995 I worked for an Internet Service Provider. One of the web 
 browsers we supported tried to guess the cause for every network error, rather than just reporting 
 the error. If the computer wasn’t connected to the Internet, and the user tried to connect to a 
 website, it would say that there was a problem with the Internet Service Provider, that the server 
 was down, and that the user should contact their Internet Service Provider to correct the problem. 
 Nearly a quarter of our calls were from people who had received this message, but merely 
 needed to connect to the Internet before trying to use their browser. As you can see, trying to 
 diagnose what the problem is can lead to a lot more problems than it fixes. It is better to just 
 include a troubleshooting guide which includes possible reasons and courses for action for each 
 error message.",NA
Recovery Points,"In order to simplify error handling, it is often useful to break your program apart into 
 distinct units, where each unit fails and is recovered as a whole. For example, you could 
 break your program up so that reading the configuration file was a unit. If reading the 
 configuration file failed at any point (opening the file, reading the file, trying to decode the 
 file, etc.) then the",NA
Making Our Program More Robust,"This section will go through making the
  add-year.s
  program from Chapter 6 a little more 
 robust.
  
 Since this is a pretty simple program, we will limit ourselves to a single recovery point that 
 covers the whole program. The only thing we will do to recover is to print the error and exit. The 
 code to do that is pretty simple:
  
  
 .include ""linux.s"" 
  
  
 .equ ST_ERROR_CODE, 8 
  
  
 .equ ST_ERROR_MSG, 12 
  
  
 .globl error_exit 
  
  
 .type error_exit, @function 
  
 error_exit: 
  
  
 pushl %ebp 
  
  
 movl 
  
 %esp, %ebp
  
 #Write out error code 
  
 movl 
  
 ST_ERROR_CODE(%ebp), %ecx 
  
 pushl %ecx 
  
 call 
  
 count_chars 
  
 popl 
  
 %ecx 
  
 movl 
  
 %eax, %edx 
  
 movl 
  
 $STDERR, %ebx 
  
 movl 
  
 $SYS_WRITE, %eax 
  
 int 
  
 $LINUX_SYSCALL
  
 89",NA
Review,NA,NA
Know the Concepts,"•
  What are the reasons programmer’s have trouble with scheduling?
  
 •
  What are corner cases? Can you list examples of numeric corner cases?
  
 •
  Why is user testing so important?
  
 •
  What are stubs and drivers used for? What’s the difference between the two?
  
 •
  What are recovery points used for?
  
 91",NA
Use the Concepts,"•
  Go through the
  add-year.s
  program and add error-checking code after every system call.
  
 •
  Find one other program we have done so far, and add error-checking to that program.
 •
  Add a 
 recovery mechanism for
  add-year.s
  that allows it to read from STDIN if it cannot 
  
 open the standard file.",NA
Going Further,"•
  What, if anything, should you do if your error-reporting function fails? Why?
 •
  
 Try to find bugs in at least one open-source program. File a bug report for it.
 •
  
 Try to fix the bug you found in the previous exercise.
  
 92",NA
Chapter 8. Sharing Functions with Code Libraries,"* Need to also include scanf and other input mechanisms.
  
 By now you should realize that the computer has to do a lot of work even for simple tasks. 
 Because of that, you have to do a lot of work to write the code for a computer to even do 
 simple tasks. In addition, programming tasks are usually not very simple. Therefore, we neeed 
 a way to make this process easier on ourselves. There are several ways to do this, including:
  
 •
  Write code in a high-level language instead of assembly language
  
 •
  Have lots of pre-written code that you can cut and paste into your own programs
  
 •
  Have a set of functions on the system that are shared among any program that wishes to use it
  
 All three of these are usually used to some degree in any given project. The first option will be 
 explored further in Chapter 11. The second option is useful but it suffers from some drawbacks, 
 including:
  
 •
  Code that is copied often has to be majorly modified to fit the surrounding code.
  
 •
  Every program containing the copied code has the same code in it, thus wasting a lot of space.
  
 •
  If a bug is found in any of the copied code it has to be fixed in every application program.
  
 Therefore, the second option is usually used sparingly. It is usually only used in cases where you 
 copy and paste skeleton code for a specific type of task, and add in your program-specific 
 details. The third option is the one that is used the most often. The third option includes having a 
 central repository of shared code. Then, instead of each program wasting space storing the same 
 copies of functions, they can simply point to the shared files which contain the functions they 
 need. If a bug is found in one of these functions, it only has to be fixed within the shared file, and 
 all applications which use it are automatically updated. The main drawback with this approach is 
 that it creates some dependency problems, including:
  
 •
  If multiple applications are all using the shared file, how do we know when it is safe to delete 
 the file? For example, if three applications are sharing a file of functions and 2 of the 
 programs are deleted, how does the system know that there still exists an application that uses 
 that code, and therefore it shouldn’t be deleted?
  
 •
  Some programs inadvertantly rely on bugs within shared functions. Therefore, if upgrading the 
 shared program fixes a bug that a program depended on, it could cause that application to 
 cease functioning.
  
 These problems are what lead to what is known as ""DLL hell"". However, it is generally assumed 
 that the advantages outweigh the disadvantages.
  
 93",NA
Using a Shared Library,"The program we will examine here is simple - it writes the characters
  hello world
  to the
  
 screen and exits. The regular program,
  helloworld-nolib.s
 , looks like this:
  
 #PURPOSE: This program writes the message ""hello world"" and
  
 # exits
  
 #
  
 .include ""linux.s""
  
 .section .data
  
 helloworld:
  
 .ascii ""hello world\n""
  
 helloworld_end:
  
 .equ helloworld_len, helloworld_end - helloworld
  
 .section .text
  
 .globl _start
  
 _start:
  
 movl 
  
 $STDOUT, %ebx
  
 movl 
  
 $helloworld, %ecx
  
 movl 
  
 $helloworld_len, %edx
  
 movl 
  
 $SYS_WRITE, %eax
  
 int 
  
 $LINUX_SYSCALL
  
 movl 
  
 $0, %ebx
  
 movl 
  
 $SYS_EXIT, %eax
  
 int 
  
 $LINUX_SYSCALL
  
 That’s not too long. However, take a look at how short
  helloworld-lib
  is which uses a 
 library:
  
 #PURPOSE: This program writes the message ""hello world"" and
  
 # exits
  
 #
  
 94",NA
How Shared Libraries Work,"In our first programs, all of the code was contained within the source file. Such programs are 
 called
  statically-linked executables
 , because they contained all of the necessary functionality for 
 the program that wasn’t handled by the kernel. In the programs we wrote in Chapter 6, we used 
 both our main program file and files containing routines used by multiple programs. In these 
 cases, we combined all of the code together using the linker at link-time, so it was still 
  
 statically-linked. However, in the
  helloworld-lib
  program, we started using shared libraries. 
 When you use shared libraries, your program is then
  dynamically-linked
 , which means that not 
 all of the code needed to run the program is actually contained within the program file itself, but 
 in external libraries.
  
 When we put the
  -lc
  on the command to link the
  helloworld
  program, it told the linker to 
 use the
  c
  library (
 libc.so
 ) to look up any symbols that weren’t already defined in
  
 helloworld.o
 . However, it doesn’t actually add any code to our program, it just notes in the 
 program where to look. When the
  helloworld
  program begins, the file
  /lib/ld-
 linux.so.2
  is loaded first. This is the dynamic linker. This looks at our
  helloworld
  program 
 and sees that it needs the
  c 
 library to run. So, it searches for a file called
  libc.so
  in the 
 standard places (listed in 
  
 /etc/ld.so.conf
  and in the contents of the
  LD_LIBRARY_PATH
  environment variable), then 
 looks in it for all the needed symbols (
 printf
  and
  exit
  in this case), and then loads the library 
 into the program’s virtual memory. Finally, it replaces all instances of
  printf
  in the program 
 with the actual location of
  printf
  in the library.
  
 Run the following command:
  
 ldd ./helloworld-nolib
  
 It should report back
  not a dynamic executable
 . This is just like we said -
 helloworld-nolib
  is a statically-linked executable. However, try this:
  
 ldd ./helloworld-lib
  
 It will report back something like
  
 libc.so.6 => /lib/libc.so.6 (0x4001d000)
  
 96",NA
Finding Information about Libraries,"Okay, so now that you know about libraries, the question is, how do you find out what libraries 
 you have on your system and what they do? Well, let’s skip that question for a minute and ask 
 another question: How do programmers describe functions to each other in their documentation? 
 Let’s take a look at the function
  printf
 . It’s calling interface (usually referred to as a
  
 prototype
 ) looks like this:
  
 int printf(char *string, ...);
  
 In Linux, functions are described in the C programming language. In fact, most Linux programs 
 are written in C. That is why most documentation and binary compatibility is defined using the C 
 language. The interface to the
  printf
  function above is described using the C programming 
 language.
  
 This definition means that there is a function
  printf
 . The things inside the parenthesis are the 
 functions parameters or arguments. The first argument here is
  char *string
 . This means 
 there is an argument named
  string
  (the name isn’t important, except to use for talking about 
 it), which has a type
  char *
 .
  char
  means that it wants a character. The
  *
  after it means that it 
 doesn’t actually want a character as an argument, but instead it wants the address of a character 
 or sequence of characters. If you look back at our
  helloworld program
 , you will notice that 
 the function call looked like this:
  
 pushl $hello 
  
 call 
  
 printf
  
 So, we pushed the address of the
  hello
  string, rather than the actual characters. You might 
 notice that we didn’t push the length of the string. The way that
  printf
  found the end of the 
 string was because we ended it with a null character (
 \0
 ). Many functions work that way, 
 especially C language functions. The
  int
  before the function definition tell what type of value 
 the function will return in
  %eax
  when it returns.
  printf
  will return an
  int
  when it’s 
 through. Now, after the
  char *string
 , we have a series of periods,
  ...
 . This means that it 
 can take an
  
 97",NA
Useful Functions,"Several useful functions you will want to be aware of from the
  c
  library include:
  
 •
  size_t strlen (const char *s)
  calculates the size of null-terminated strings.
  
 •
  int strcmp (const char *s1, const char *s2)
  compares two strings alphabetically.
  
 •
  char * strdup (const char *s)
  takes the pointer to a string, and creates a new copy in 
  
 a new location, and returns the new location.
  
 •
  FILE * fopen (const char *filename, const char *opentype)
  opens a 
  
 managed, buffered file (allows easier reading and writing than using file descriptors 
 directly).
 23
  
 2. 
  
 stdin
 ,
  stdout
 , and
  stderr
  (all lower case) can be used in these programs to refer to the files of 
 their
  
 corresponding file descriptors.
  
 3. 
  
 FILE
  is a struct. You don’t need to know it’s contents to use it. You only have to store the pointer and
  
 pass it to the relevant other functions.
  
 101",NA
Building a Shared Library,"Let’s say that we wanted to take all of our shared code from Chapter 6 and build it into a shared 
 library to use in our programs. The first thing we would do is assemble them like normal:
  
 as write-record.s -o write-record.o 
  
 as read-record.s -o read-record.o
  
 Now, instead of linking them into a program, we want to link them into a shared library. 
 This changes our linker command to this:
  
 ld -shared write-record.o read-record.o -o librecord.so
  
 This links both of these files together into a shared library called
  librecord.so
 . This file can 
 now be used for multiple programs. If we need to update the functions contained within it, we 
 can just update this one file and not have to worry about which programs use it.
  
 Let’s look at how we would link against this library. To link the
  write-records
  program, 
 we would do the following:
  
 as write-records.s -o write-records 
  
 ld -L . -dynamic-linker /lib/ld-linux.so.2 
 \-o write-records -lrecord write-records.o
  
 In this command,
  -L .
  told the linker to look for libraries in the current directory (it usually 
 only searches
  /lib
  directory,
  /usr/lib
  directory, and a few others). As we’ve seen, the 
 option
 -dynamic-linker /lib/ld-linux.so.2
  specified the dynamic linker. The option
  
 -lrecord
  tells the linker to search for functions in the file named
  librecord.so
 .
  
 Now the
  write-records
  program is built, but it will not run. If we try it, we will get an 
 error like the following:
  
 102",NA
Review,NA,NA
Know the Concepts,"•
  What are the advantages and disadvantages of shared libraries?
  
 •
  Given a library named ’foo’, what would the library’s filename be?
  
 •
  What does the
  ldd
  command do?
  
 103",NA
Use the Concepts,"•
  Rewrite one or more of the programs from the previous chapters to print their results to the 
 screen using
  printf
  rather than returning the result as the exit status code. Also, make the 
 exit status code be 0.
  
 •
  Use the
  factorial
  function you developed in the Section called
  Recursive Functions
  in 
 Chapter 4 to make a shared library. Then re-write the main program so that it links with the 
 library dynamically.
  
 •
  Rewrite the program above so that it also links with the ’c’ library. Use the ’c’ library’s 
  
 printf
  function to display the result of the
  factorial
  call.
  
 •
  Rewrite the
  toupper
  program so that it uses the
  c
  library functions for files rather than 
 system 
  
 calls.",NA
Going Further,"•
  Make a list of all the environment variables used by the GNU/Linux dynamic linker.
  
 •
  Research the different types of executable file formats in use today and in the history of 
  
 computing. Tell the strengths and weaknesses of each.
  
 •
  What kinds of programming are you interested in (graphics, databbases, science, etc.)? Find a 
  
 library for working in that area, and write a program that makes some basic use of that library.
  
 104",NA
Chapter 9. Intermediate Memory Topics,"Okay, so the last chapter was quite a doozy. This may seem overwhelming at first, but if you can 
 stick it out you will have the background you need to being a successful programmer.",NA
How a Computer Views Memory,"Let’s review how memory within a computer works. You may also want to re-read Chapter 2.
  
 A computer looks at memory as a long sequence of numbered storage locations. A sequence of 
 millions
  of numbered storage locations. Everything is stored in these locations. Your programs 
 are stored there, your data is stored there, everything. Each storage location looks like every 
 other one. The locations holding your program are just like the ones holding your data. In fact, 
 the computer has no idea which are which. So, we’ve seen how numbers are stored - each value 
 takes up four storage locations. How are the instructions stored? Each instruction is a different 
 length. Most instructions take up one or two storage locations for the instruction itself, and then 
 storage locations for the instruction’s arguments. For example,
  
 movl data_items(,%edi,4), %ebx
  
 takes up 7 storage locations. The first two hold the instruction, the third one tells which registers 
 to use, and the next four hold the storage location of
  data_items
 . In memory, these look just 
 like all the other numbers, and the instructions themselves can be moved into and out of registers 
 just like numbers, because that’s what they are. Now, let’s define a few terms:
  
 Address
  
 An address is the number of a storage location. For example, the first storage location on a 
 computer has an address of 0, the second has an address of 1, and so on.
 1
 Every piece of data 
 on the computer not in a register has an address. Normally, we don’t ever type the exact 
 address of something, but we use symbols instead (like using
  data_items
  in our second 
 program).
  
 Pointer
  
 A pointer is a register or memory storage location whose value is an address. In our second 
 example,
  %ebp
  was a pointer to the current stack position. Programming uses a lot of 
 pointers, which we will see eventually.
  
 1.
  
 You actually never use addresses this low, but it works for discussion.
  
 107",NA
The Instruction Pointer,"Previously we have concentrated on general registers and how they work. The only special 
 register we’ve dealt with is the status register, and we really didn’t say much about it. The next 
 special register we will deal with is the instruction pointer, or
  %eip
 . We mentioned earlier that 
 the computer sees every byte on the computer in the same way. If we have a number that is an 
 entire word, the computer doesn’t know what address that word starts or ends at. The computer 
 doesn’t know the difference between instructions and data, either. Any value in memory could 
 be instructions, data, or the middle of an instruction or piece of data. So how does the computer 
 know what to execute? The answer is the instruction pointer. The instruction pointer always has 
 the value of the next instruction. When the computer is ready to execute an instruction, it looks 
 at the instruction pointer to see where to go next. It then increments the instruction pointer to 
 point to the next instruction. After it finishes executing the current instruction, it looks at the 
 instruction pointer again. That’s all well and good, but what about jumps (the
  jmp
  family of 
 instructions)? At the end of those instructions, the computer does _not_ look at the next 
 instruction, it goes to an instruction in a totally different place. How does this work? Because
  
 jmp somewhere
  
 is exactly the same as
  
 movl $somewhere, %eip
  
 Where
  somewhere
  is a symbol referring to a program section. Now, you can’t actually do this, 
 because you are not allowed to refer directly to
  %eip
 , but if you could this would be how. Also 
 note that we put a dollar sign in front of
  somewhere
 . How do we know when to put a dollar 
 sign and when not to? The dollar sign says to use immediate mode addressing, which means to 
 treat 
 somewhere
  as a value. If the dollar sign weren’t there, it would switch to direct addressing 
 mode,
  
 108",NA
The Memory Layout of a Linux Program,"This section is based off of Konstantin Boldyshev’s document, ""Startup state of a Linux/i386 
 ELF binary"", available at http://linuxassembly.org/startup.html
  
 When you program is loaded into memory, each
  .section
  is loaded into its own spot. The 
 actual code (the
  .text
  section) is loaded at the address 0x08048000. The
  .data
  section is 
 loaded immediately after that, followed by the
  .bss
  (see the Section called
  Buffers and
  .bss
  
 in Chapter 5) section. Remember, the
  .bss
  section has all of the memory locations that we 
 reserve that we don’t put values in until run-time. In the
  .data
  section, we put actual values 
 into the storage spaces we reserved (with the
  .long
  directive). This information is embedded in 
 the program file, and loaded when the program starts. The
  .bss
  section is not initialized until 
 after the program is run. Therefore, the data doesn’t have to be stored in the program file itself, it 
 just notes that it needs a certain number of storage spaces. Anyway, we’ll talk more about that 
 later.
  
 The last storage location that can be addressed is location 0xbfffffff. The
  .text
 ,
  .data
 , and 
 .bss
  sections all start at 0x08048000 and grow larger. The next sections start at the end and 
 grow back downward.
 2
 First, at the very end of memory, there are two words that just contain 
 zeroes.
  
 After that comes the name of the program. Each letter takes up one byte, and it is ended by the 
 NULL character (the
  \0
  we talked about earlier).
 3
 After the program name comes the program 
 environment values. These are not important to us now. Then come the program arguments. 
 These are the values that the user typed in on the command line to run this program. In the case 
 of the ""maximum"" program, there would only be one value,
  ./maximum
 . Other programs take 
 more arguments. When we run
  as
 , for example, we give it several arguments -
  as
 ,
  
 maximum.s
 ,
 -o
 , and
  maximum.o
 . After these, we have the stack. This is where all of our data 
 goes when we do pushes, pops and calls. Since the stack is at the top of the memory, it grows 
 down.
  %esp
  
 2. 
  
 You may be thinking, ""what if they grow toward each other and overlap?"" Although this is possible, it is 
 extremely unlikely, because the amount of space in-between is huge.
  
 3. 
  
 The NULL character is actually the number 0, not to be confused with the
  character
  0
 , whose numeric 
 value is not zero. Every possible letter, symbol, or number you can type with your keyboard has a number 
 associated with it. These numbers are called ""ASCII codes"". We’ll deal more with these later.",NA
Every Memory Address is a Lie,"So, why does the computer not allow you to access memory in the break area? To answer this 
 question, we will have to delve into the depths of how your computer really handles memory. Be 
 warned, reading this section is like taking the blue pill
 4
 .
  
 You may have wondered, since every program gets loaded into the same place in memory, don’t 
 they step on each other, or overwrite each other? It would seem so. However, as a program 
 writer, you only access
  virtual memory
 .
  Physical memory
  refers to the actual RAM chips inside 
 your
  
 4.
  
 as in the movie,
  The Matrix",NA
Getting More Memory,"We know that Linux maps all of our virtual memory into real memory or swap. If you try to 
 access a piece of virtual memory that hasn’t been mapped yet, it triggers an error known as a 
 segmentation fault, which will terminate your program. The program break point, if you 
 remember, is the last valid address you can use. Now, this is all great if you know beforehand 
 how much storage you will need. You can just add all the memory you need to your data section, 
 and it will all be there. But let’s say you don’t know how much memory you will need. For 
 example, with a text editor, you don’t know how long the person’s file will be. You could try to 
 find a maximum file size, and just tell the user that they can’t go beyond that, but that’s a waste 
 if the file is small. So, Linux has a facility to move the break point. If you need more memory, 
 you can just tell Linux where you want the new break point to be, and Linux will map all the 
 memory you need, and then move the break point. The way we tell Linux to move the break 
 point is the same way we told Linux to exit our program. We load
  %eax
  with the system call 
 number, 45 in this case, and load
  %ebx
  with the new breakpoint. Then you call
  int $0x80
  to 
 signal Linux to do its work. Linux will do its thing, and then return either 0 if there is no memory 
 left or the new break point in
  %eax
 . The new break point might actually be larger than what you 
 asked for, because Linux rounds up to the nearest page.
  
 The problem with this method is keeping track of the memory. Let’s say I need to move the 
 break to have room to load a file, and then need to move a break again to load another file. Later, 
 let’s say you get rid of the first file. You now have a giant gap in memory that’s mapped, but you 
 aren’t using. If you continue to move the break for each file you load, you can easily run out of 
 memory. So, what you need is a
  memory manager
 . A memory manager consists of two basic 
 functions -
 allocate
  and
  deallocate
 . A memory manager usually also has an initialization 
 function. Note that the function names might not be
  allocate
  and
  deallocate
 , but that the 
 functionality will be the same. Whenever you need a certain amount of memory, you can simply 
 tell 
  
 allocate
  how much you need, and it will give you back an address to the memory. When 
 you’re done with it, you tell
  deallocate
  that you are through with it. Then
  allocate
  will be 
 able to reuse the memory. This minimizes the number of ""holes"" in your memory, making sure 
 that you are making the best use of it you can.
  
 * FIXME - what about talking about handles?",NA
A Simple Memory Manager,"Here I will show you a simple memory manager. It is extremely slow at allocating memory,
  
 112",NA
Variables and Constants,"At the beginning of the program, we have two locations set up -
  
 heap_begin: 
  
  
 .long 0
  
 current_break: 
  
  
 .long 0
  
 119",NA
The,allocate_init,NA
 function,"Okay, this is a simple function. All it does is set up the
  heap_begin
  and
  current_break 
 variables we discussed earlier. So, if you remember the discussion earlier, the current break can 
 be found using the break system call. So, the function looks like this:
  
 pushl %ebp 
  
 movl 
  
 %esp, %ebp
  
 movl 
  
 $BRK, %eax 
  
 movl 
  
 $0, %ebx 
  
 int 
  
 $LINUX_SYSCALL
  
 incl 
  
 %eax
  
 Anyway, after
  int $LINUX_SYSCALL
 ,
  %eax
  holds the last valid address. We actually want 
 the first invalid address, so we just increment
  %eax
 . Then we move that value to the
  
 heap_begin 
 and
  current_break
  locations. Then we leave the function. Like this:
  
 movl 
  
 %eax, current_break 
  
 movl 
  
 %eax, heap_begin 
  
 movl 
  
 %ebp, %esp 
  
 popl 
  
 %ebp
  
 So, why do we want to put an invalid address as the beginning of our heap? Because we don’t 
 control any memory yet. Our
  allocate
  function will notice this, and reset the break so that 
 we actually have memory.",NA
The,allocate,NA
 function,"This is the doozy function. Let’s start by looking at an outline of the function:
  
 1. Start at the beginning of the heap
  
 2. Check to see if we’re at the end of the heap
  
 3. If we are at the end of the heap, grab the memory we need from the kernel, mark it as 
  
 ""unavailable"" and return it. If the kernel won’t give us any more, return a 0.
  
 121",NA
The,deallocate,NA
 function,"The
  deallocate
  function is much easier than the allocate one. That’s because it doesn’t have 
 to do any searching at all. It can just mark the current memory segment as
  AVAILABLE
 , and 
 allocate
  will find it next time it is run. So we have
  
 movl 
  
 ST_MEMORY_SEG(%esp), %eax 
  
 subl 
  
 $HEADER_SIZE, %eax 
  
 movl 
  
 $AVAILABLE, HDR_AVAIL_OFFSET(%eax) 
 ret
  
 In this function, we don’t have to save
  %ebp
  or
  %esp
  since we’re not changing them, nor do we 
 have to restore them at the end. All we’re doing is reading the address of the memory segment 
 from the stack, backing up to the beginning of the header, and marking the segment as available. 
 This function has no return value, so we don’t care what we leave in
  %eax
 .",NA
Performance Issues and Other Problems,"Okay, so we have our nice little memory manager. It’s a very simplistic one. Most memory 
 managers are much more complex. Ours was simple so you could see the basics of what a 
 memory manager has to deal with. Now, our memory manager does work, it just doesn’t do so 
 optimally. Before you read the next paragraph, try to think about what the problems with it might 
 be.
  
 Okay, the biggest problem here is speed. Now, if there are only a few allocations made, then 
 speed won’t be a big issue. But think about what happens if you make a thousand allocations. On 
 allocation number 1000, you have to search through 999 memory segments to find that you have 
 to request more memory. As you can see, that’s getting pretty slow. In addition, remember that 
 Linux can keep pages of memory on disk instead of in memory. So, since you have to go through 
 every piece of memory, that means that Linux has to load every part of memory from disk to 
 check to see if its available. You can see how this could get really, really slow.
 6
 This method is 
 said to run in
  linear
  time, which means that every element you have to manage makes your 
 program take longer. A program that runs in
  constant
  time takes the same amount of time no 
 matter how many elements you are managing. Take the
  deallocate
  function, for instance. It 
 only runs 4 instructions, no matter how many elements we are managing, or where they are in
  
 6. 
  
 This is why adding more memory to your computer makes it run faster. The more memory your 
 computer has, the less it puts on disk, so it doesn’t have to always be interrupting your programs to retreive 
 pages off the disk.
  
 125",NA
Review,NA,NA
Know the Concepts,"•
  Describe the Linux stack.
  
 •
  What are the initial contents of the Linux stack?
  
 •
  What happens when you access unmapped memory?
  
 •
  How does the operating system prevent processes from writing over each other’s 
 memory?
 •
  What happens if a piece of memory you are using is currently residing on disk?
  
 •
  What is the
  current break?
  
 •
  Why do you need an allocator?",NA
Use the Concepts,•,NA
Going Further,"•
  
 127",NA
Chapter 10. Counting Like a Computer,NA,NA
Counting,NA,NA
Counting Like a Human,"In many ways, computers count just like humans. So, before we start learning how computers 
 count, let’s take a deeper look at how we count.
  
 How many fingers do you have? No, it’s not a trick question. Humans (normally) have ten 
 fingers. Why is that significant? Look at our numbering system. At what point does a one-digit 
 number become a two-digit number? That’s right, at ten. Humans count and do math using a 
 base ten numbering system. Base ten means that we group everything in tens. Let’s say we’re 
 counting sheep. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Why did we all of a sudden now have two digits, and 
 re-use the 1? That’s because we’re grouping our numbers by ten, and we have 1 group of ten 
 sheep. Okay, let’s go to the next number 11. That means we have 1 group of ten sheep, and 1 
 sheep left ungrouped. So we continue - 12, 13, 14, 15, 16, 17, 18, 19, 20. Now we have 2 groups 
 of ten. 21 -2 groups of ten, and 1 sheep ungrouped. 22 - 2 groups of ten, and 2 sheep ungrouped. 
 So, let’s say we keep counting, and get to 97, 98, 99, and 100. Look, it happened again! What 
 happens at 100? We now have ten groups of ten. At 101 we have ten groups of ten, and 1 
 ungrouped sheep. So we can look at any number like this. If we counted 60879 sheep, that would 
 mean that we had 6 groups of ten groups of ten groups of ten groups of ten, 0 groups of ten 
 groups of ten groups of ten, 8 groups of ten groups of ten, 7 groups of ten, and 9 sheep left 
 ungrouped.
  
 So, is there anything significant about grouping things by ten? No! It’s just that grouping by ten 
 is how we’ve always done it, because we have ten fingers. We could have grouped at nine or at 
 eleven, in which case we would have had to make up a new symbol. The only difference 
 between the different groupings of numbers, is that we have to re-learn our multiplication, 
 addition, subtraction, and division tables. The rules haven’t changed, just the way we represent 
 them. Also, some of our tricks that we learned don’t always apply, either. For example, let’s say 
 we grouped by nine instead of ten. Moving the decimal point one digit to the right no longer 
 multiplies by ten, it now multiplies by nine. In base nine, 500 is only nine times as large as 50.",NA
Counting Like a Computer,"The question is, how many fingers does the computer have to count with? The computer only 
 has two fingers. So that means all of the groups are groups of two. So, let’s count in binary - 0 
 (zero), 1 (one), 10 (two - one group of two), 11 (three - one group of two and one left over), 100 
 (four -two groups of two), 101 (five - two groups of two and one left over), 110 (six - two groups 
 of two",NA
Conversions Between Binary and Decimal,"Let’s learn how to convert numbers from binary (base two) to decimal (base ten). This is actually
  
 a rather simple process. If you remember, each digit stands for some grouping of two. So, we just
  
 need to add up what each digit represents, and we will have a decimal number. Take the binary
  
 number 10010101. To find out what it is in decimal, we take it apart like this:
  
 1 
  
 0 
  
 0 
  
 1 
  
 0 1 
  
 0 
  
 1
  
 | 
  
 | 
  
 | 
  
 | 
  
 | | 
  
 | 
  
 |
  
 | 
  
 | 
  
 | 
  
 | 
  
 | | 
  
 | 
  
 Individual units (2^0)
  
 | 
  
 | 
  
 | 
  
 | 
  
 | | 
  
 0 groups of 2 (2^1)
  
 | 
  
 | 
  
 | 
  
 | 
  
 | 1 group of 4 (2^2)
  
 | 
  
 | 
  
 | 
  
 | 
  
 0 groups of 8 (2^3)
  
 | 
  
 | 
  
 | 
  
 1 group of 16 (2^4)
  
 | 
  
 | 
  
 0 groups of 32 (2^5)
  
 | 
  
 0 groups of 64 (2^6)
  
 1 group of 128 (2^7)
  
 and then we add all of the pieces together, like this:
  
 1*128 + 0*64 + 0*32 + 1*16 + 0*8 + 1*4 + 0*2 + 1*1 =
  
 128 + 16 + 4 + 1 =
  
 149
  
 So 10010101 in binary is 149 in decimal. Let’s look at 1100101. It can be written as
  
 1*64 + 1*32 + 0 * 16 + 0*8 + 1*4 + 0*2 + 1*1 =
  
 64 + 32 + 4 + 1 =
  
 101
  
 So we see that 1100101 in binary is 101 in decimal. Let’s look at one more number,
  
 11101011001001. You can convert it to decimal by doing
  
 1*8192 + 1*4096 + 1*2048 + 0*1024 + 1*512 + 0*256 + 1*128 + 1*64 + 0*32 +
  
 0*16 + 1*8 + 0*4 + 0*2 + 1*1 =
  
 8192 + 4096 + 2048 + 512 + 128 + 64 + 8 + 1 =
  
 15049
  
 131",NA
"Truth, Falsehood, and Binary Numbers","Now we’ve seen that the computer stores everything as sequences of 1’s and 0’s. Let’s look at 
 some other uses of this. What if, instead of looking at a sequence of bits as a number, we instead 
 looked at it as a set of switches. For example, let’s say there are four switches that control lighting 
 in the house. We have a switch for outside lights, a switch for the hallway lights, a switch for the 
 living room lights, and a switch for the bedroom lights. We could make a little table showing 
 which of these were on and off, like so:
  
 Outside
  
 Hallway
  
 Living Room
  
 Bedroom
  
 On
  
 Off
  
 On
  
 On
  
 It’s obvious from looking at this that all of the lights are on except the hallway ones. Now, instead 
 of using the words ""On"" and ""Off"", let’s use the numbers 1 and 0. 1 will represent on, and 0 will 
 represent off. So, we could represent the same information as
  
 Outside
  
 Hallway
  
 Living Room
  
 Bedroom
  
 1
  
 0
  
 1
  
 1
  
 Now, instead of having labels on the light switches, let’s say we just memorized which 
 position went with which switch. Then, the same information could be represented as
  
 1
  
 0
  
 1
  
 1
  
 or as
  
 1011
  
 133",NA
The Program Status Register,"We’ve seen how bits on a register can be used to give the answers of yes/no and true/false 
 statements. On your computer, there is a register called the
  program status register
 . This register 
 holds a lot of information about what happens in a computation. For example, have you ever 
 wondered what would happen if you added two numbers and the result was larger than would fit 
 in a register? The program status register has a flag called the overflow flag. You can test it to 
 see if the last computation overflowed the register. There are flags for a number of different 
 statuses.
  
 139",NA
Other Numbering Systems,"What we have studied so far only applies to positive integers. However, real-world numbers are 
 not always positive integers. Negative numbers and numbers with decimals are also used.",NA
Floating-point Numbers,"So far, the only numbers we’ve dealt with are integers - numbers with no decimal point.
  
 Computers have a general problem with numbers with decimal points, because computers can 
 only store fixed-size, finite values. Decimal numbers can be any length, including infinite 
 length (think of a repeating decimal, like the result of 1 / 3). The way a computer handles this is 
 by storing decimals at a fixed precision. A computer stores decimal numbers in two parts - the 
 exponent
  and the
  mantissa
 . The mantissa contains the actual digits that will be used, and the 
 exponent is what magnitude the number is. For example, 12345.2 is stored as 1.23452 * 10^4.
  
 The mantissa is 1.23452 and the exponent is 4. All numbers are stored as X.XXXXX * 
  
 10^XXXX. The number 1 is stored as 1.00000 * 10^0. Now, the mantissa and the exponent are 
 only so long, which leads to some interesting problems. For example, when a computer stores an 
 integer, if you add 1 to it, the resulting number is one larger. This does not necessarily happen 
 with floating point numbers. If the number is sufficiently big, like 5.234 * 10^5000, adding 1 to 
 it might not even register in the mantissa (remember, both parts are only so long). This affects 
 several things, especially order of operations. Let’s say that I add 1 to 5.234 * 10^5000 a few 
 billion or trillion times. Guess what, the number won’t change at all. However, if I add one to 
 itself a few trillion or billion times, and then add it to the original number, it might make a dent.
  
 140",NA
Negative Numbers,"How would you think that negative numbers on a computer might be represented? One thought 
 might be to use the first digit of a number as the sign, so 
  
 00000000000000000000000000000001
  would represent the number 1, and 
  
 10000000000000000000000000000001
  would represent -1. This makes a lot of sense, and in 
 fact some old processors work this way. However, it has some problems. First of all, it takes a lot 
 more circuitry to add and subtracted signed numbers. Even more so, this representation has a 
 problem with the number 0. In this system, you could have both a negative and a positive 0. This 
 leads to a lot of questions, like ""should negative zero be equal to positive zero?"", ""What should 
 the sign of zero be in various circumstances?"".
  
 These problems were overcome by using a representation of negative numbers called
  two’s 
 complement
  representation. To get the negative representation of a number in two’s 
 complement form, you must perform the following steps:
  
 1. Perform a NOT operation on the number
  
 2. Add one to the resulting number
  
 So, to get the negative of
  00000000000000000000000000000001
 , you would first do a NOT 
 operation, which gives
  11111111111111111111111111111110
 , and then add one, giving 
 11111111111111111111111111111111
 . To get negative two, first take 
  
 00000000000000000000000000000010
 . The NOT of that number is 
  
 11111111111111111111111111111101
 . Adding one gives 
  
 11111111111111111111111111111110
 . With this representation, you can add numbers just 
 as if they were positive, and come out with the right answers. For example, if you add one plus 
 negative one in binary, you will notice that all of the numbers flip to zero. Also, the first digit 
 still carries the sign bit, making it simple to determine whether or not the number is positive or 
 negative. Negative numbers will always have a
  1
  in the leftmost bit.
  
 One thing to note about the two’s complement representation of signed numbers is that, unlike 
 unsigned quantities, if you increase the number of bits, you can’t just add zeroes to the left of the 
 number. For example, let’s say we are dealing with four-bit quantities and we had the number -3, 
 1101
 . If we were to extend this into an eight-bit register, we could not represent it as
  00001101 
 as this would represent 13, not -3. When you increase the size of a signed quantity in two’s 
 complement representation, you have to perform
  sign extension
 . Sign extension means that you
  
 141",NA
Octal and Hexadecimal Numbers,"The numbering systems discussed so far have been decimal and binary. However, two others are 
 used common in computing - octal and hexadecimal. In fact, they are probably written more 
 often than binary. Octal is a representation that only uses the numbers 0 through 7. So the octal 
 number 10 is actually 8 in decimal because it is one group of eight. Octal 121 is decimal 81 (one 
 group of 64 (8^2), two groups of 8, and one left over). What makes octal nice is that every 3 
 binary digits make one octal digit (there is no such grouping of binary digits into decimal). So 0 
 is 000, 1 is 001, 2 is 010, 3 is 011, 4 is 100, 5 is 101, 6 is 110, and 7 is 111.
  
 Permissions in Linux are done using octal. This is because Linux permissions are based on the 
 ability to read, write and execute. The first bit is the read permission, the second bit is the write 
 permission, and the third bit is the execute permission. So, 0 (000) gives no permissions, 6 (110) 
 gives read and write permission, and 5 (101) gives read and execute permissions. These numbers 
 are then used for the three different sets of permissions - the owner, the group, and everyone 
 else. The number 0644 means read and write for the first permission set, and read-only for the 
 second and third set. The first permission set is for the owner of the file. The third permission set 
 is for the group owner of the file. The last permission set is for everyone else. So,
  0751
  means 
 that the owner of the file can read, write, and execute the file, the group members can read and 
 execute the file, and everyone else can only execute the file.
  
 Anyway, as you can see, octal is used to group bits (binary digits) into threes. The way the 
 assembler knows that a number is octal is because octal numbers are prefixed with a zero. For 
 example 010 means 10 in octal, which is 8 in decimal. If you just write 10 that means 10 in 
 decimal. The beginning zero is what differentiates the two. So,
  be careful not to put any 
 leading zeroes in front of decimal numbers, or they will be interepreted as octal numbers
 !
  
 Hexadecimal numbers (also called just ""hex"") use the numbers 1-15 for each digit. however, 
 since 10-15 don’t have their own numbers, hexadecimal uses the letters
  a
  through
  f
  to 
 represent them. For example, the letter
  a
  represents 10, the letter
  b
  represents 11, and so on. 10 
 in hexadecimal is 16 in decimal. In octal, each digit represented three bits. In hexadecimal, each 
 digit represents
  
 142",NA
Order of Bytes in a Word,"One thing that confuses many people when dealing with bits and bytes on a low level is that, 
 when bytes are written from registers to memory, their bytes are written out 
  
 least-significant-portion-first. What most people expect is that if they have a word in a register, 
 say
  0x5d 23 ef ee
  (the spacing is so you can see where the bytes are), the bytes will be 
 written in that order. However, on x86 processors, the bytes are actually written in reverse order. 
 In memory the bytes would be
  0xee ef 23 5d
  on x86 processors. The bytes are written in 
 reverse order as they would appear conceptually, but the bits within the bytes are ordered 
 normally.
  
 Not all processors behave this way. The x86 processor is a
  little-endian
  processor, which 
 means that it stores the ""little end"" of its words first.
  
 143",NA
Converting Numbers for Display,"So far, we have been unable to display any number stored to the user, except by the extremely 
 limitted means of passing it through exit codes. In this section, we will discuss converting 
 positive numbers into strings for display.
  
 The function will be called
  integer2string
 , and it will take two parameters - an integer to 
 convert and a string buffer filled with null characters (zeroes). The buffer will be assumed to be 
 big enough to store the entire number as a string.(at least 11 characters long, to include a trailing 
 null character).
  
 Remember that the way that we see numbers is in base 10. Therefore, to access the individual 
 decimal digits of a number, we need to be dividing by 10 and displaying the remainder for each 
 digit. Therefore, the process will look like this:
  
 •
  Divide the number by ten
  
 •
  The remainder is the current digit. Convert it to a character and store it.
  
 •
  We are finished if the quotient is zero.
  
 145",NA
Review,NA,NA
Know the Concepts,"•
  Convert the decimal number 5,294 to binary.
  
 •
  Add the binary numbers 10111001 and 101011.
  
 •
  Multiply the binary numbers 1100 1010110.
  
 •
  Convert the results of the previous two problems into decimal.
  
 •
  Describe how
  and
 ,
  or
 ,
  not
 , and
  xor
  work.
  
 •
  What is masking for?
  
 •
  What number would you use for the flags of the
  open
  system call if you wanted to open the 
  
 file for writing, and create the file if it doesn’t exist?
  
 •
  How would you represent -55 in a thirty-two bit register?
  
 •
  Sign-extend the previous quantity into a 64-bit register.
  
 •
  Describe the difference between little-endian and big-endian storage of words in memory.",NA
Use the Concepts,"•
  Go back to previous programs that returned numeric results through the exit status code, and 
  
 rewrite them to print out the results instead using our integer to string conversion function.
 •
  
 Modify the
  integer2number
  code to return results in octal rather than decimal.
  
 •
  Modify the
  integer2number
  code so that the conversion base is a parameter rather than 
  
 hardcoded.
  
 •
  Write a function called
  is_negative
  that takes a single integer as a parameter and returns 1 if 
  
 the parameter is negative, and 0 if the parameter is positive.
  
 150",NA
Going Further,"•
  Modify the
  integer2number
  code so that the conversion base can be greater than 10 (this 
  
 requires you to use letters for numbers past 9).
  
 •
  Create a function that does the reverse of
  integer2number
  called
  number2integer
  which 
 takes a character string and converts it to a register-sized integer. Test it by running that 
 integer back through the
  integer2number
  function and displaying the results.
  
 •
  Write a program that stores likes and dislikes into a single machine word, and then compares 
  
 two sets of likes and dislikes for commonalities.
  
 151",NA
Chapter 11. High-Level Languages,"In this chapter we will begin to look at our first ""real-world"" programming language. Assembly 
 language is the language used at the machine’s level, but most people (including me) find coding 
 in assembly language too cumbersome for normal use. Many computer languages have been 
 invented to make the programming task easier. Knowing a wide variety of languages is useful 
 for many reasons, including
  
 •
  Different languages are based on different concepts, which will help you to learn different and 
  
 better programming methods and ideas.
  
 •
  Different languages are good for different types of projects.
  
 •
  Different companies have different standard languages, so knowing more languages makes 
  
 your skills more marketable.
  
 •
  The more languages you know, the easier it is to pick up new ones.
  
 As a programmer, you will often have to pick up new languages. Professional programmers can 
 usually pick up a new language with about a weeks worth of study and practice. Languages are 
 simply tools, and learning to use a new tool should not be something a programmer flinches at. 
 In fact, if you do computer consulting you will often have to learn new languages on the spot in 
 order to keep yourself employed. It will often be your customer, not you, who decides what 
 language is used. This chapter will introduce you to a few of the languages available to you. I 
 encourage you to explore as many languages as you are interested in.",NA
Compiled and Interpreted Languages,"Many languages are
  compiled
  languages. When you write assembly language, each instruction 
 you write is translated into exactly one machine instruction for processing. With compilers, a 
 statement can translate into one or hundreds of machine instructions. In fact, depending on how 
 advanced your compiler is, it might even restructure parts of your code to make it faster. In 
 assembly language, what you write is what you get.
  
 There are also languages that are
  interpreted
  languages. These languages require that the user 
 run a program called an
  interpreter
  that in turn runs the given program. These are usually slower 
 than compiled programs, since the translator has to read and interpret the code as it goes along.
  
 However, in well-made translators, this time can be fairly negligible. There is also a class of 
 hybrid languages which partially compile a program before execution into byte-codes, which are 
 only machine readable. This is done because the translator can read the byte-codes much faster 
 than it can read the regular language.
  
 153",NA
Your First C Program,"Here is your first C program, which prints ""Hello world"" to the screen and exits. Type it in, and 
 give it the name Hello-World.c
  
 #include <stdio.h>
  
 /* PURPOSE: This program is mean to show a basic C program. */ 
 /* All it does is print ""Hello World!"" to the 
  
 */ 
 /* screen and exit. 
  
 */
  
 /* Main Program */ 
  
 int main(int argc, char **argv) 
  
 { 
  
  
 puts(""Hello World!\n""); /* Print our string to standard output */ 
  
 return 0; 
  
  
 /* Exit with status 0 */ 
  
 }
  
 154",NA
Perl,"Perl is an interpreted language, existing mostly on Linux and UNIX-based platforms. It actually 
 runs on almost all platforms, but you find it most often on Linux and UNIX-based ones. 
 Anyway, here is the Perl version of the program, which should be typed into a file named 
  
 Hello-World.pl
 :
  
 #!/usr/bin/perl
  
 print(""Hello world!\n"");
  
 Since Perl is interpreted, you don’t need to compile or link it. Just run in with the 
 following command:
  
 perl Hello-World.pl
  
 As you can see, the Perl version is even shorter than the C version. With Perl you don’t have to 
 declare any functions or program entry points. You can just start typing commands and the 
 interpreter will run them as it comes to them. In fact this program only has two lines of code, one 
 of which is optional.
  
 The first, optional line is used for UNIX machines to tell which interpreter to use to run the 
 program. The
  #!
  tells the computer that this is an interpreted program, and the
  
 /usr/bin/perl 
 tells the computer to use the program
  /usr/bin/perl
  to interpret the 
 program. However, since we ran the program by typing in
  perl Hello-World.pl
 , we had already 
 specified that we were using the perl interpreter.
  
 156",NA
Python,"The python version of the program looks almost exactly like the Perl one. However, Python is 
 really a very different language than Perl, even if it doesn’t seem so from this trivial example.
  
 Type the program into a file named
  Hello-World.py
 . The program follows:
  
 #!/usr/bin/python
  
 print ""Hello World"";
  
 You should be able to tell what the different lines of the program do.",NA
Review,NA,NA
Know the Concepts,"•
  What is the difference between an intepretted language and a compiled language?
  
 •
  What reasons might cause you to need to learn a new programming language?",NA
Use the Concepts,"•
  Learn the basic syntax of a new programming language. Recode one of the programs in this 
  
 book in that language.
  
 157",NA
Going Further,"•
  Having seen languages which have such brevity as Perl, why do you think this book started 
  
 you with a language as verbose as assembly language?
  
 •
  How do you think high level languages have affected the process of programming?
  
 •
  Why do you think so many languages exist?
  
 •
  Learn two new high level languages. How do they differ from each other? How are they 
  
 similar? What approach to problem-solving does each take?
  
 158",NA
Chapter 12. Optimization,"Optimization is the process of making your application run more effectively. You can 
 optimize for many things - speed, memory space usage, disk space usage, etc. This chapter, 
 however, focuses on speed optimization.",NA
When to Optimize,"It is better to not optimize at all than to optimize too soon. When you optimize, your code 
 generally becomes less clear, because it becomes more complex. Readers of your code will have 
 more trouble discovering why you did what you did which will increase the cost of maintenance 
 of your project. Even when you know how and why your program runs the way it does, 
 optimized code is harder to debug and extend. It slows the development process down 
 considerably, both because of the time it takes to optimize the code, and the time it takes to 
 modify your optimized code.
  
 Compounding this problem is that you don’t even know beforehand where the speed issues in 
 your program will be. Even experienced programmers have trouble predicting which parts of the 
 program will be the bottlenecks which need optimization, so you will probably end up wasting 
 your time optimizing the wrong parts. the Section called
  Where to Optimize
  will discuss how to 
 find the parts of your program that need optimization.
  
 While you develop your program, you need to have the following priorities:
  
 •
  Everything is documented
  
 •
  Everything works as documented
  
 •
  The code is written in an modular, easily modifiable form
  
 Documentation is essential, especially when working in groups. The proper functioning of the 
 program is essential. You’ll notice application speed was not anywhere on that list. Optimization 
 is not necessary during early development for the following reasons:
  
 •
  Minor speed problems can be usually solved through hardware, which is often much cheaper 
  
 than a programmer’s time.
  
 •
  Your application will change dramatically as you revise it, therefore wasting most of your 
  
 efforts to optimize it.
 1
  
 •
  Speed problems are usually localized in a few places in your code - finding these is difficult 
  
 before you have most of the program finished.
  
 1. 
  
 Many new projects often have a first code base which is completely rewritten as developers learn more
  
 about the problem they are trying to solve. Any optimization done on the first codebase is completely 
 wasted.
  
 159",NA
Where to Optimize,"Once you have determined that you have a performance issue you need to determine where in 
 the code the problems occur. You can do this by running a
  profiler
 . A profiler is a program that 
 will let you run your program, and it will tell you how much time is spent in each function, and 
 how many times they are run.
  gprof
  is the standard GNU/Linux profiling tool, but a discussion 
 of using profilers is outside the scope of this text. After running a profiler, you can determine 
 which functions are called the most or have the most time spent in them. These are the ones you 
 should focus your optimization efforts on.
  
 If a program only spends 1% of its time in a given function, then no matter how much you speed 
 it up you will only achieve a
  maximum
  of a 1% overall speed improvement. However, if a 
 program spends 20% of its time in a given function, then even minor improvements to that 
 functions speed will be noticeable. Therefore, profiling gives you the information you need to 
 make good choices about where to spend your programming time.
  
 In order to optimize functions, you need to understand in what ways they are being called and 
 used. The more you know about how and when a function is called, the better position you will 
 be in to optimize it appropriately.
  
 There are two main categories of optimization - local optimizations and global optimizations. 
 Local optimizations consist of optimizations that are either hardware specific - such as the fastest 
 way to perform a given computation - or program-specific - such as making a specific piece of 
 code perform the best for the most often-occuring case. Global optimization consist of 
  
 optimizations which are structural. For example, if you were trying to find the best way for three 
 people in different cities to meet in St. Louis, a local optimization would be finding a better road 
 to get there, while a global optimization would be to decide to teleconference instead of meeting 
 in person. Global optimization often involves restructuring code to avoid performance problems, 
 rather than trying to find the best way through them.
  
 160",NA
Local Optimizations,"The following are some well-known methods of optimizing pieces of code. When using 
 high level languages, some of these may be done automatically by your compiler’s 
 optimizer.
  
 Precomputing Calculations
  
 Sometimes a function has a limitted number of possible inputs and outputs. In fact, it may 
 be so few that you can actually precompute all of the possible answers beforehand, and 
 simply look up the answer when the function is called. This takes up some space since you 
 have to store all of the answers, but for small sets of data this works out really well, 
 especially if the computation normally takes a long time.
  
 Remembering Calculation Results
  
 This is similar to the previous method, but instead of computing results beforehand, the 
 result of each calculation requested is stored. This way when the function starts, if the result 
 has been computed before it will simply return the previous answer, otherwise it will do the 
 full computation and store the result for later lookup. This has the advantage of requiring 
 less storage space because you aren’t precomputing all results. This is sometimes termed 
 caching
  or
  memoizing
 .
  
 Locality of Reference
  
 Locality of reference
  is a term for where in memory the data items you are accessing are. 
 With virtual memory, you may access pages of memory which are stored on disk. In such a 
 case, the operating system has to load that memory page from disk, and unload others to 
 disk. Let’s say, for instance, that the operating system will allow you to have 20k of 
 memory in physical memory and forces the rest of it to be on disk, and your application 
 uses 60k of memory. Let’s say your program has to do 5 operations on each piece of data. If 
 it does one operation on every piece of data, and then goes through and does the next 
 operation on each piece of data, eventually every page of data will be loaded and unloaded 
 from the disk 5 times. Instead, if you did all 5 operations on a given data item, you only 
 have to load each page from disk once. When you bundle as many operations on data that is 
 physically close to each other in memory, then you are taking advantage of locality of 
 reference. In addition, processors usually store some data on-chip in a cache. If you keep all 
 of your operations within a small area of physical memory, you can bypass even main 
 memory and only use the chips ultra-fast cache memory. This is all done for you - all you 
 have to do is to try to operate on small sections of memory at a time, rather than bouncing 
 all over the place in memory.
  
 Register Usage
  
 Registers are the fastest memory locations on the computer. When you access memory, the",NA
Global Optimization,"Global optimization has two goals. The first one is to put your code in a form where it is easy 
 to do local optimiztions. For example, if you have a large procedure that performs several slow, 
 complex calculations, you might see if you can break parts of that procedure into their own 
 functions where the values can be precomputed or memoized.
  
 Stateless functions (functions that only operate on the parameters that were passed to them - i.e. 
 no globals or system calls) are the easiest type of functions to optimize in a computer. The more 
 stateless parts of your program you have, the more opportunities you have to optimize. In the e-
 commerce situation I wrote about above, the computer had to find all of the associated parts for 
 specific inventory items. This required about 12 database calls, and in the worst case took about 
 20 seconds. However, the goal of this program was to be interactive, and a long wait would 
 destroy that goal. However, I knew that these inventory configurations do not change. Therefore, 
 I converted the database calls into their own functions, which were stateless. I was then able to 
 memoize the functions. At the beginning of each day, the function results were cleared in case 
 anyone had changed them, and several inventory items were automatically preloaded. From then 
 on during the day, the first time someone accessed an inventory item, it would take the 20 
 seconds it did beforehand, but afterwards it would take less than a second, because the database 
 results had been memoized.
  
 Global optimization usually often involves achieving the following properties in your functions:
  
 Parallelization
  
 Parallelization means that your algorithm can effectively be split among multiple 
 processes. For example, pregnancy is not very parallelizable because no matter how many 
 women you have, it still takes nine months. However, building a car is parallelizable 
 because you can have one worker working on the engine while another one is working on 
 the interior.
  
 Usually, applications have a limit to how parallelizable they are. The more parallelizable
  
 163",NA
Review,NA,NA
Know the Concepts,"•
  At what level of importance is optimization compared to the other priorities in programming?
  
 •
  What is the difference between local and global optimizations?
  
 •
  Name some types of local optimizations.
  
 •
  How do you determine what parts of your program need optimization?
  
 •
  At what level of importance is optimization compared to the other priorities in programming? 
  
 Why do you think I repeated that question?",NA
Use the Concepts,"•
  Go back through each program in this book and try to make optimizations according to the 
  
 procedures outlined in this chapter
  
 164",NA
Going Further,"•
  Find an open-source program that you find particularly fast. Contact one of the developers and 
  
 ask about what kinds of optimizations they performed to improve the speed.
  
 •
  Find an open-source program that you find particularly slow, and try to imagine the reasons for 
 the slowness. Then, download the code and try to profile it using
  gprof
  or similar tool. Find 
 where the code is spending the majority of the time and try to optimize it. Was the reason for 
 the slowness different than you imagined?
  
 •
  Has the compiler eliminated the need for local optimizations? Why or why not?
  
 •
  What kind of problems might a compiler run in to if it tried to optimize code across function 
  
 call boundaries?
  
 2. 
  
 Since these programs are usually short enough not to have noticeable performance problems, looping
  
 through the program thousands of times will exaggerate the time it takes to run enough to make calculations.
  
 165",NA
Chapter 13. Moving On from Here,"Congratulations on getting this far. You should now have a basis for understanding the issues 
 involved in many areas of programming. Even if you never use assembly language again, you 
 have gained a valuable perspective and mental framework for understanding the rest of computer 
 science.
  
 There are essentially three methods to learn to program:
  
 •
  From the Bottom Up - This is how this book teaches. It starts with low-level programming, and 
  
 works toward more generalized teaching.
  
 •
  From the Top Down - This is the opposite direction. This focuses on what you want to do with 
 the computer, and teaches you how to break it down more and more until you get to the low 
 levels.
  
 •
  From the Middle - This is characterized by books which teach a specific programming 
  
 language or API. These are not as concerned with concepts as they are with specifics.
  
 Different people like different approaches, but a good programmer takes all of them into 
 account. The bottom-up approaches help you understand the machine aspects, the top-down 
 approaches help you understand the problem-area aspects, and the middle approaches help you 
 with practical questions and answers. To leave any of these aspects out would be a mistake.
  
 Computer Programming is a vast subject. As a programmer, you will need to be prepared to be 
 constantly learning and pushing your limits. These books will help you do that. They not only 
 teach their subjects, but also teach various ways and methods of
  thinking
 . As Alan Perlis said, ""A 
 language that doesn’t affect the way you think about programming is not worth knowing"" 
 (http://www.cs.yale.edu/homes/perlis-alan/quotes.html). If you are constantly looking for new 
 and better ways of doing and thinking, you will make a successful programmer. If you do not 
 seek to enhance yourself, ""A little sleep, a little slumber, a little folding of the hands to rest - and 
 poverty will come on you like a bandit and scarcity like an armed man."" (Proverbs 24:33-34 
 NIV). Perhaps not quite that severe, but still, it’s best to always be learning.
  
 These books were selected because of their content and the amount of respect they have in the 
 computer science world. Each of them brings something unique. There are many books here. 
 The best way to start would be to look through online reviews of several of the books, and find a 
 starting point that interests you.",NA
From the Bottom Up,"This list is in the best reading order I could find. It’s not necessarily easiest to hardest, but 
 based on subject matter.
  
 167",NA
From the Top Down ,"These books are arranged from the simplest to the hardest. However, they can be read in any 
 order you feel comfortable with.
  
 •
  How to Design Programs
  by Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and 
  
 Shiram Krishnamurthi, available online at http://www.htdp.org/
  
 •
  Simply Scheme: An Introduction to Computer Science
  by Brian Harvey and Matthew Wright
 •
  
 How to Think Like a Computer Scientist: Learning with Python
  by Allen Downey, Jeff Elkner, 
  
 and Chris Meyers, available online at http://www.greenteapress.com/thinkpython/
  
 •
  Structure and Interpretation of Computer Programs
  by Harold Abelson and Gerald Jay 
  
 Sussman with Julie Sussman, available online at http://mitpress.mit.edu/sicp/
  
 •
  Design Patterns
  by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides
  
 •
  What not How: The Rules Approach to Application Development
  by Chris Date
  
 •
  The Algorithm Design Manual
  by Steve Skiena
  
 •
  Programming Language Pragmatics
  by Michael Scott
  
 •
  Essentials of Programming Languages
  by Daniel P. Friedman, Mitchell Wand, and Christopher 
  
 T. Haynes",NA
From the Middle Out ,"Each of these is the best book on its subject. If you need to know these languages, these will 
 tell you all you need to know.
  
 168",NA
Specialized Topics ,"These books are the best books that cover their topic. They are thorough and authoritative. To 
 get a broad base of knowledge, you should read several outside of the areas you normally 
 program in.
  
 •
  Practical Programming -
  Programming Pearls
  and
  More Programming Pearls
  by Jon Louis 
  
 Bentley
  
 •
  Databases -
  Understanding Relational Databases
  by Fabian Pascal
  
 •
  Project Management -
  The Mythical Man-Month
  by Fred P. Brooks
  
 •
  UNIX Programming -
  The Art of UNIX Programming
  by Eric S. Raymond, available online at 
  
 http://www.catb.org/~esr/writings/taoup/
  
 •
  UNIX Programming -
  Advanced Programming in the UNIX Environment
  by W. Richard 
  
 Stevens
  
 •
  Network Programming -
  UNIX Network Programming
  (2 volumes) by W. Richard Stevens
 •
  
 Generic Programming -
  Modern C++ Design
  by Andrei Alexandrescu
  
 •
  Compilers -
  The Art of Compiler Design: Theory and Practice
  by Thomas Pittman and James 
  
 Peters
  
 •
  Compilers -
  Advanced Compiler Design and Implementation
  by Steven Muchnick
  
 •
  Development Process -
  Refactoring: Improving the Design of Existing Code
  by Martin Fowler, 
  
 Kent Beck, John Brant, William Opdyke, and Don Roberts
  
 •
  Typesetting -
  Computers and Typesetting
  (5 volumes) by Donald Knuth
  
 •
  Cryptography -
  Applied Cryptography
  by Bruce Schneier
  
 169",NA
Further Resources on Assembly Language ,"In assembly language, your best resources are on the web.
  
 •
  http://www.linuxassembly.org/ - a great resource for Linux assembly language programmers
 •
  
 http://www.sandpile.org/ - a repository of reference material on x86, x86-64, and compatible 
  
 processors
  
 •
  http://www.x86.org/ - Dr. Dobb’s Journal Microprocessor Resources
  
 •
  http://www.drpaulcarter.com/pcasm/ - Dr. Paul Carter’s PC Assembly Language Page
 •
  
 http://webster.cs.ucr.edu/ - The Art of Assembly Home Page
  
 •
  http://www.intel.com/design/pentium/manuals/ - Intel’s manuals for their processors
 •
  
 http://www.amd.com/us-en/Processors/DevelopWithAMD/0„30_2252_739_7203,00.html -
  
 AMD’s processor documentation
  
 •
  http://www.janw.easynet.be/ - Jan Wagemaker’s Linux assembly language examples
 •
  
 http://www.azillionmonkeys.com/qed/asm.html - Paul Hsieh’s x86 Assembly Page
  
 170",NA
Appendix A. GUI Programming,"Introduction to GUI Programming
  
 The purpose of this appendix is not to teach you how to do Graphical User Interfaces. It is 
 simply meant to show how writing graphical applications is the same as writing other 
 applications, just using an additional library to handle the graphical parts. As a programmer you 
 need to get used to learning new libraries. Most of your time will be spent passing data from one 
 library to another.
  
 The GNOME Libraries
  
 The GNOME projects is one of several projects to provide a complete desktop to Linux users. 
 The GNOME project includes a panel to hold application launchers and mini-applications called 
 applets, several standard applications to do things such as file management, session 
 management, and configuration, and an API for creating applications which fit in with the way 
 the rest of the system works.
  
 One thing to notice about the GNOME libraries is that they constantly create and give you 
 pointers to large data structures, but you never need to know how they are laid out in memory. 
 All manipulation of the GUI data structures are done entirely through function calls. This is a 
 characteristic of good library design. Libraries change from version to version, and so does the 
 data that each data structure holds. If you had to access and manipulate that data yourself, then 
 when the library is updated you would have to modify your programs to work with the new 
 library, or at least recompile them. When you access the data through functions, the functions 
 take care of knowing where in the structure each piece of data is. The pointers you receive from 
 the library are
  opaque
  - you don’t need to know specifically what the structure they are pointing 
 to looks like, you only need to know the functions that will properly manipulate it. When 
 designing libraries, even for use within only one program, this is a good practice to keep in mind.
  
 This chapter will not go into details about how GNOME works. If you would like to know more, 
 visit the GNOME developer web site at http://developer.gnome.org/. This site contains tutorials, 
 mailing lists, API documentation, and everything else you need to start programming in the 
 GNOME environment.
  
 A Simple GNOME Program in Several Languages
  
 This program will simply show a Window that has a button to quit the application. When that 
 button is clicked it will ask you if you are sure, and if you click yes it will close the application.
  
 To run this program, type in the following as
  gnome-example.s
 :
  
 #PURPOSE: This program is meant to be an example
  
 171",NA
Appendix B. Common x86 Instructions,"Reading the Tables
  
 The tables of instructions presented in this appendix include:
  
 •
  The instruction code
  
 •
  The operands used
  
 •
  The flags used
  
 •
  A brief description of what the instruction does
  
 In the operands section, it will list the type of operands it takes. If it takes more than one 
 operand, each operand will be separated by a comma. Each operand will have a list of codes 
 which tell whether the operand can be an immediate-mode value (I), a register (R), or a memory 
 address (M). For example, the
  movl
  instruction is listed as
  I/R/M, R/M
 . This means that the 
 first operand can be any kind of value, while the second operand must be a register or memory 
 location. Note, however, that in x86 assembly language you cannot have more than one operand 
 be a memory location.
  
 In the flags section, it lists the flags affected by the instruction. The following flags are 
 mentioned:
  
 O
  
 Overflow flag. This is set to true if the destination operand was not large enough to hold the 
 result of the instruction.
  
 S
  
 Sign flag. This is set to the sign of the last result.
  
 Z
  
 Zero flag. This flag is set to true if the result of the instruction is zero.
  
 A
  
 Auxillary carry flag. This flag is set for carries and borrows between the third and fourth 
 bit. It is not often used.
  
 P
  
 Parity flag. This flag is set to true if the low byte of the last result had an even number of 1 
 bits.
  
 185",NA
Appendix C. Important System Calls,"These are some of the more important system calls to use when dealing with Linux. For most 
 cases, however, it is best to use library functions rather than direct system calls, because the 
 system calls were designed to be minimalistic while the library functions were designed to be 
 easy to program with. For information about the Linux C library, see the manual at 
  
 http://www.gnu.org/software/libc/manual/
  
 Remember that
  %eax
  holds the system call numbers, and that the return values and error 
 codes are also stored in
  %eax
 .
  
 Table C-1. Important Linux System Calls
  
 %eax
  
 Name
  
 %ebx
  
 %ecx
  
 %edx
  
 Notes
  
 1
  
 exit
  
 return 
  
 value (int)
  
  
  
 Exits the program
  
 3
  
 read
  
 file 
  
 descriptor
  
 buffer start 
  
 buffer size 
 (int)
  
 Reads into the given buffer
  
 4
  
 write
  
 file 
  
 descriptor
  
 buffer start 
  
 buffer size 
 (int)
  
 Writes the buffer to the file 
 descriptor
  
 5
  
 open
  
 null-
  
 terminate
 d file 
 name
  
 option list
  
 permission 
 mode
  
 Opens the given file. Returns the 
 file descriptor or an error number.
  
 6
  
 close
  
 file 
  
 descriptor
  
  
  
 Closes the give file descriptor
  
 12
  
 chdir
  
 null-
  
 terminate
 d 
 directory 
  
 name
  
  
  
 Changes the current directory of 
 your program.
  
 19
  
 lseek
  
 file 
  
 descriptor
  
 offset
  
 mode
  
 Repositions where you are in the 
 given file. The mode (called the 
 ""whence"") should be 0 for absolute 
 positioning, and 1 for relative 
  
 positioning.
  
 20
  
 getpid
  
  
  
  
 Returns the process ID of the 
 current process.
  
 195",NA
Appendix D. Table of ASCII Codes,"To use this table, simply find the character or escape that you want the code for, and add the 
 number on the left and the top.
  
 Table D-1. Table of ASCII codes in decimal
  
  
 +0
  
 +1
  
 +2
  
 +3
  
 +4
  
 +5
  
 +6
  
 +7
  
 0
  
 NUL
  
 SOH
  
 STX
  
 ETX
  
 EOT
  
 ENQ
  
 ACK
  
 BEL
  
 8
  
 BS
  
 HT
  
 LF
  
 VT
  
 FF
  
 CR
  
 SO
  
 SI
  
 16
  
 DLE
  
 DC1
  
 DC2
  
 DC3
  
 DC4
  
 NAK
  
 SYN
  
 ETB
  
 24
  
 CAN
  
 EM
  
 SUB
  
 ESC
  
 FS
  
 GS
  
 RS
  
 US
  
 32
  
  
 !
  
 ""
  
 #
  
 $
  
 %
  
 &
  
 ’
  
 40
  
 (
  
 )
  
 *
  
 +
  
 ,
  
 -
  
 .
  
 /
  
 48
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 56
  
 8
  
 9
  
 :
  
 ;
  
 <
  
 =
  
 >
  
 ?
  
 64
  
 @
  
 A
  
 B
  
 C
  
 D
  
 E
  
 F
  
 G
  
 72
  
 H
  
 I
  
 J
  
 K
  
 L
  
 M
  
 N
  
 O
  
 80
  
 P
  
 Q
  
 R
  
 S
  
 T
  
 U
  
 V
  
 W
  
 88
  
 X
  
 Y
  
 Z
  
 [
  
 \
  
 ]
  
 ^
  
 _
  
 96
  
 ‘
  
 a
  
 b
  
 c
  
 d
  
 e
  
 f
  
 g
  
 104
  
 h
  
 i
  
 j
  
 k
  
 l
  
 m
  
 n
  
 o
  
 112
  
 p
  
 q
  
 r
  
 s
  
 t
  
 u
  
 v
  
 w
  
 120
  
 x
  
 y
  
 z
  
 {
  
 |
  
 }
  
 ~
  
 DEL
  
 ASCII is actually being phased out in favor of an international standard known as Unicode, which 
 allows you to display any character from any known writing system in the world. As you may 
 have noticed, ASCII only has support for English characters. Unicode is much more complicated, 
 however, because it requires more than one byte to encode a single character. There are several 
 different methods for encoding Unicode characters. The most common is UTF-8 and UTF-32.
  
 UTF-8 is somewhat backwards-compatible with ASCII (it is stored the same for English 
 characters, but expands into multiple byte for international characters). UTF-32 simply 
 requires four bytes for each character rather than one. Windows uses UTF-16, which is a 
 variable-length encoding which requires at least 2 bytes per character, so it is not backwards-
 compatible with ASCII.
  
 A good tutorial on internationalization issues, fonts, and Unicode is available in a great Article by 
 Joe Spolsky, called ""The Absolute Minimum Every Software Developer Absolutely, Positively 
 Must Know About Unicode and Character Sets (No Excuses!)"", available online at
  
 197",NA
Appendix E. C Idioms in Assembly Language,"This appendix is for C programmers learning assembly language. It is meant to give a general 
 idea about how C constructs can be implemented in assembly language.
  
 If Statement
  
 In C, an if statement consists of three parts - the condition, the true branch, and the false branch. 
 However, since assembly language is not a block structured language, you have to work a little 
 to implement the block-like nature of C. For example, look at the following C code:
  
 if(a == b) 
  
 { 
  
  
 /* True Branch Code Here */ 
  
 } 
  
 else 
  
 { 
  
  
 /* False Branch Code Here */ 
  
 }
  
 /* At This Point, Reconverge */
  
 In assembly language, this can be rendered as:
  
 ;Move a and b into registers for comparison 
 movl a, %eax 
  
 movl b, %ebx
  
 ;Compare 
  
 cmpl %eax, %ebx
  
 ;If True, go to true branch 
  
 je true_branch
  
 false_branch: ;This label is unnecessary, 
  
 ;only here for documentation 
  
 ;False 
 Branch Code Here
  
 ;Jump to recovergence point 
  
 jmp reconverge
  
 true_branch: 
  
  
 ;True Branch Code Here
  
 199",NA
Appendix F. Using the GDB Debugger,"By the time you read this appendix, you will likely have written at least one program with an 
 error in it. In assembly language, even minor errors usually have results such as the whole 
 program crashing with a segmentation fault error. In most programming languages, you can 
 simply print out the values in your variables as you go along, and use that output to find out 
 where you went wrong. In assembly language, calling output functions is not so easy. 
 Therefore, to aid in determining the source of errors, you must use a
  source debugger
 .
  
 A debugger is a program that helps you find bugs by stepping through the program one step at a 
 time, letting you examine memory and register contents along the way. A
  source debugger
  is a 
 debugger that allows you to tie the debugging operation directly to the source code of a program. 
 This means that the debugger allows you to look at the source code as you typed it in - complete 
 with symbols, labels, and comments.
  
 The debugger we will be looking at is GDB - the GNU Debugger. This application is present on 
 almost all GNU/Linux distributions. It can debug programs in multiple programming 
 languages, including assembly language.
  
 An Example Debugging Session
  
 The best way to explain how a debugger works is by using it. The program we will be using 
 the debugger on is the
  maximum
  program used in Chapter 3. Let’s say that you entered the 
 program perfectly, except that you left out the line:
  
 incl %edi
  
 When you run the program, it just goes in an infinite loop - it never exits. To determine the cause, 
 you need to run the program under GDB. However, to do this, you need to have the assembler 
 include debugging information in the executable. All you need to do to enable this is to add the
 -
 -gstabs
  option to the
  as
  command. So, you would assemble it like this:
  
 as --gstabs maximum.s -o maximum.o
  
 Linking would be the same as normal. ""stabs"" is the debugging format used by GDB. Now, to 
 run the program under the debugger, you would type in
  gdb ./maximum
 . Be sure that the 
 source files are in the current directory. The output should look similar to this:
  
 GNU gdb Red Hat Linux (5.2.1-4) 
  
 Copyright 2002 Free Software Foundation, Inc.
  
 GDB is free software, covered by the GNU General Public License, and you are 
 welcome to change it and/or distribute copies of it under certain conditions. 
 Type ""show copying"" to see the conditions.
  
 209",NA
Warning,"One problem that GDB has is with handling interrupts. Often times GDB will miss 
 the instruction that immediately follows an interrupt. The instruction is actually 
 executed, but GDB doesn’t step through it. This should not be a problem - just be 
 aware that it may happen.
  
 GDB Quick-Reference 
  
 This quick-reference table is copyright 2002 Robert M. Dondero, Jr., and is used by permission in 
 this book. Parameters listed in brackets are optional.
  
 Table F-1. Common GDB Debugging Commands
  
 Miscellaneous
  
 quit
  
 Exit GDB
  
 help [cmd]
  
 Print description of debugger command
  
 cmd
 . Without
  cmd
 , prints a list of topics.
  
 directory [dir1] [dir2] ...
  
 Add directories
  dir1
 ,
  dir2
 , etc. to the list 
 of directories searched for source files.
  
 Running the Program
  
 run [arg1] [arg2] ...
  
 Run the program with command line arguments 
 arg1
 ,
  arg2
 , etc.
  
 set args arg1 [arg2] ...
  
 Set the program’s command-line arguments to 
 arg1
 ,
  arg2
 , etc.
  
 show args
  
 Print the program’s command-line arguments.
  
 Using Breakpoints
  
 info breakpoints
  
 Print a list of all breakpoints and their 
 numbers (breakpoint numbers are used for 
 other 
  
 breakpoint commands).
  
 break
  linenum
  
 Set a breakpoint at line number
  linenum
 .
  
 break *
 addr
  
 Set a breakpoint at memory address
  addr
 .
  
 break
  fn
  
 Set a breakpoint at the beginning of function
  fn
 .
  
 condition
  bpnum expr
  
 Break at breakpoint
  bpnum
  only if 
 expression 
 expr
  is non-zero.
  
 213",NA
Appendix G. Document History,"•
  12/17/2002 - Version 0.5 - Initial posting of book under GNU FDL
  
 •
  07/18/2003 - Version 0.6 - Added ASCII appendix, finished the discussion of the CPU in the 
 Memory chapter, reworked exercises into a new format, corrected several errors. Thanks to 
 Harald Korneliussen for the many suggestions and the ASCII table.
  
 •
  01/11/2004 - Version 0.7 - Added C translation appendix, added the beginnings of an appendix 
 of x86 instructions, added the beginnings of a GDB appendix, finished out the files chapter, 
 finished out the counting chapter, added a records chapter, created a source file of common 
 linux definitions, corrected several errors, and lots of other fixes
  
 •
  01/22/2004 - Version 0.8 - Finished GDB appendix, mostly finished w/ appendix of x86 
 instructions, added section on planning programs, added lots of review questions, and got 
 everything to a completed, initial draft state.
  
 •
  01/29/2004 - Version 0.9 - Lots of editting of all chapters. Made code more consistent and 
  
 made explanations clearer. Added some illustrations.
  
 217",NA
Appendix H. GNU Free Documentation License,"0. PREAMBLE
  
 The purpose of this License is to make a manual, textbook, or other written document “free” in 
 the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with 
 or without modifying it, either commercially or noncommercially. Secondarily, this License 
 preserves for the author and publisher a way to get credit for their work, while not being 
 considered responsible for modifications made by others.
  
 This License is a kind of “copyleft”, which means that derivative works of the document must 
 themselves be free in the same sense. It complements the GNU General Public License, which is 
 a copyleft license designed for free software.
  
 We have designed this License in order to use it for manuals for free software, because free 
 software needs free documentation: a free program should come with manuals providing the 
 same freedoms that the software does. But this License is not limited to software manuals; it can 
 be used for any textual work, regardless of subject matter or whether it is published as a printed 
 book. We recommend this License principally for works whose purpose is instruction or 
 reference.
  
 1. APPLICABILITY AND DEFINITIONS
  
 This License applies to any manual or other work that contains a notice placed by the copyright 
 holder saying it can be distributed under the terms of this License. The “Document”, below, 
 refers to any such manual or work. Any member of the public is a licensee, and is addressed as 
 “you”.
  
 A “Modified Version” of the Document means any work containing the Document or a portion 
 of it, either copied verbatim, or with modifications and/or translated into another language.
  
 A “Secondary Section” is a named appendix or a front-matter section of the Document that deals 
 exclusively with the relationship of the publishers or authors of the Document to the Document’s 
 overall subject (or to related matters) and contains nothing that could fall directly within that 
 overall subject. (For example, if the Document is in part a textbook of mathematics, a Secondary 
 Section may not explain any mathematics.) The relationship could be a matter of historical 
 connection with the subject or with related matters, or of legal, commercial, philosophical, 
 ethical or political position regarding them.
  
 The “Invariant Sections” are certain Secondary Sections whose titles are designated, as 
 being those of Invariant Sections, in the notice that says that the Document is released under 
 this License.
  
 The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts 
 or Back-Cover Texts, in the notice that says that the Document is released under this 
 License.",NA
Index,"as, 14 
  
 ASCII, 8
  
  
 %ah, 31 
  
 %al, 31 
  
 %ax, 31 
  
 %eax, 17, 28, 41, 48, 53, 64, 83, 90, 97,
  ??
 , 195 
 %ebp, 17, 39, 44, 212 
  
 %ecx, 17, 53, 64,
  ??
 ,
  ??
 , 202 
  
 %edi, 17 
  
 %edx, 17, 53, 64,
  ??
 ,
  ??
  
 %eflags, 18, 27,
  ??
  
 %eip, 17, 39
  
 assemble, 14 
  
 assembler, 16 
  
 assembler directives, 16 
  
 Assembly Language, 4, 14 
  
 base case, 46 
  
 base pointer, 40 
  
 base pointer addressing, 40, 49 
  
 base pointer addressing mode, 38 
  
 base pointer register, 39 
  
 base-pointer addressing mode, 11, 30
  
 %esi, 17 
  
 branch prediction, 7
  
 %esp, 17, 38, 207, 212 
  
 buffers, 54
  
 ./, 15 
  
 byte, 7, 30
  
 .ascii, 24 
  
 C language calling convention, 38
  
 .bss, 54 
  
 C programming language, 37
  
 .byte, 23, 54 
  
 cache hierarchies, 7
  
 .data, 54 
  
 call, 37, 39, 44, 48
  
 .endr, 71 
  
 calling conventions, 37, 41
  
 .globl, 16, 24 
  
 close, 54
  
 .int, 24 
  
 cmpl, 27
  
 .lcomm, 55 
  
 comments, 15
  
 .long, 23 
  
 computer architecture, 5
  
 .rept, 71 
  
 conditional jump, 21
  
 .section, 16 
  
 coprocessors, 7
  
 .text, 16, 54 
  
 CPU, 5, 6
  
 .type, 44, 49 
  
 Data bus, 6
  
 0x80, 19 
  
 data section, 16, 23
  
 @function, 44 
  
 decl, 50
  
 \0, 24 
  
 destination operand, 30
  
 \n, 24 
  
 direct addressing, 18
  
 \t, 24 
  
 direct addressing mode, 10, 29, 55
  
 _start, 16, 24 
  
 echo, 15
  
 ABI, 41 
  
 echo $?, 19
  
 addl, 17 
  
 exit, 18
  
 address, 7 
  
 exit status, 18, 25
  
 addressing modes, 10, 29 
  
 exit status code, 15
  
 Application Binary Interface, 41 
  
 fetch-execute cycle, 6
  
 Arithmetic and logic unit, 6 
  
 file descriptor, 53
  
 227",NA
