Larger Text,Smaller Text,Symbol
Reverse Engineering for Beginners,NA,NA
Dennis Yurichev,NA,NA
Reverse Engineering for Beginners,"Dennis Yurichev 
  
 <dennis(a)yurichev.com>
  
 cbnd
  
 ©2013-2015, Dennis Yurichev.
  
 This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License. To view a 
 copy of this license, visit
  http://creativecommons.org/licenses/by-nc-nd/3.0/
 .
  
 Text version (
 June 12, 2016
 ).
  
 The latest version (and Russian edition) of this text is accessible at
  beginners.re
 . An e-book reader version is also 
 available.
  
 There is also a LITE-version (introductory short version), intended for those who want a very quick introduction to the 
 basics of reverse engineering:
  beginners.re 
  
 You can also follow me on twitter to get information about updates of this text:
  @yurichev
 1
 , or subscribe to the mailing 
 list
 2
 .
  
 The cover was made by Andy Nechaevsky:
  facebook
 .
  
 1
 twitter.com/yurichev 
  
 2
 yurichev.com",NA
Call for translators!,"You may want to help me with translation this work into languages other than English and Russian.
  
 Just send me any piece of translated text (no matter how short) and I’ll put it into my LaTeX source code.
  
 Speed isn’t important, because this is open-source project, after all. Your name will be mentioned as project contributor. 
 Korean, Chinese and Persian languages are reserved by publishers.
  
 English and Russian versions I do by myself, but my English is still that horrible, so I’m very grateful for any notes about 
 grammar, etc. Even my Russian is also flawed, so I’m grateful for notes about Russian text as well!
  
 So do not hesitate to contact me:
  dennis(a)yurichev.com
 .
  
 ii",NA
Abridged contents,"I
  
 Code patterns
  
 1
  
  
 II
  
 Important fundamentals
  
 429
  
 438
  
 585
  
 623
  
 647
  
 701
  
 707
  
 822
  
 853
  
 871
  
 876
  
 878
  
 908
  
 III
  
 Slightly more advanced examples
  
 IV
  
 Java
  
 V
  
 Finding important/interesting stuff in the code
  
 VI
  
 OS-specific
  
 VII
  
 Tools
  
 VIII
  
 Examples of real-world RE",NA
3,"tasks
  
 IX
  
 Examples of reversing proprietary file formats
  
 X
  
 Other things
  
 XI
  
 Books/blogs worth reading
  
 Afterword
  
 Appendix
  
 Acronyms used
  
 3
 Reverse Engineering
  
 iii",NA
Contents,"I
  
 Code patterns
  
 1
  
  
 1
  
 A short introduction to the CPU 
  
 1.1 
  
 A couple of words about different ISA
 4
 s
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 3
  
 2
  
 The simplest Function
  
 4
  
 2.1
  
 x86
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 2.2
  
 ARM
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 2.3
  
 MIPS
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5
  
 3
  
 2.3.1
  
 A note about MIPS instruction/register names
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5
  
 Hello, world!
  
 6
  
 3.1
  
 x86
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 3.1.1
  
 MSVC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 3.1.2
  
 GCC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 3.1.3
  
 GCC: AT&T syntax
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 3.2
  
 x86-64
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 3.2.1
  
 MSVC—x86-
 64
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 3.2.2
  
 GCC—x86-64
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 3.3
  
 GCC—one more thing
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 3.4
  
 ARM
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 3.4.1
  
 Non-optimizing Keil 6/2013 (ARM 
 mode)
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 12
  
 3.4.2
  
 Non-optimizing Keil 6/2013 (Thumb mode)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 3.4.3
  
 Optimizing Xcode 4.6.3 (LLVM) (ARM mode)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 4
  
 3.4.4
  
 Optimizing Xcode 4.6.3 (LLVM) (Thumb-2 mode)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 3.4.5
  
 ARM64
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 3.5
  
 MIPS
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 3.5.1
  
 A word about the “global pointer”
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 3.5.2
  
 Optimizing GCC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 3.5.3
  
 Non-optimizing GCC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 3.5.4
  
 Role of the stack frame in this example
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 20
  
 3.5.5
  
 Optimizing GCC: load it into GDB
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 20
  
 3.6
  
 Conclusion
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
  
 3.7
  
 Exercises
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
  
 Function prologue and epilogue
  
 22
  
 4.1
  
 Recursion
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22
  
 5
  
 Stack
  
 23
  
 5.1
  
 Why does the stack grow backwards?
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 23
  
 5.2
  
 What is the stack used for?
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 5.2.1
  
 Save the function’s return address
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 5.2.2
  
 Passing function arguments
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 25
  
 5.2.3
  
 Local variable storage
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 26
  
 5.2.4
  
 x86: alloca() function
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 26
  
 5.2.5
  
 (Windows) SEH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 5.2.6
  
 Buffer overflow protection
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 5.2.7
  
 Automatic deallocation of data in stack
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 5.3
  
 A typical stack layout
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 5.4
  
 Noise in stack
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 4
 Instruction Set Architecture
  
 iv",NA
Preface,"CONTENTS
  
 There are several popular meanings of the term “
 reverse engineering
 ”: 1) The reverse engineering of software: researching 
 compiled programs; 2) The scanning of 3D structures and the subsequent digital manipulation required in order to 
 duplicate them; 3) Recreating
  DBMS
 9
 structure. This book is about the first meaning.
  
 Topics discussed in-depth
  
 x86/x64, ARM/ARM64, MIPS, Java/JVM.
  
 Topics touched upon
  
 Oracle RDBMS (
  81 on page 794
 ), Itanium (
  93 on page 865
 ), copy-protection dongles (
  78 on page 730
 ), LD_PRELOAD (
  
 67.2 on page 665
 ), stack overflow,
  ELF
 10
 , win32 PE file format (
  68.2 on page 671
 ), x86-64 (
  26.1 on page 403
 ), critical 
 sections (
  68.4 on page 699
 ), syscalls (
  66 on page 661
 ),
  TLS
 11
 , position-independent code (
 PIC
 12
 ) (
  67.1 on page 663
 ), 
 profile-guided optimization (
  95.1 on page 869
 ), C++ STL (
  51.4 on page 538
 ), OpenMP (
  92 on page 859
 ), SEH (
  68.3 on 
 page 677
 ).
  
 Exercises and tasks
  
 …are all moved to the separate website:
  http://challenges.re
 .
  
 About the author
  
  
 Dennis Yurichev is an experienced reverse engineer and programmer. He can be 
 contacted by email:
  dennis(a)yurichev.com
 , or on Skype:
  dennis.yurichev
 .
  
 Praise for
  Reverse Engineering for Beginners
  
 • “It’s very well done .. and for free .. amazing.”
 13
 Daniel Bilar, Siege Technologies, LLC.
  
 • “... excellent and free”
 14
 Pete Finnigan, Oracle RDBMS security guru.
  
 • “... book is interesting, great job!” Michael Sikorski, author of
  Practical Malware Analysis: The Hands-On Guide to 
  
 Dissecting Malicious Software
 .
  
 • “... my compliments for the very nice tutorial!” Herbert Bos, full professor at the Vrije Universiteit Amsterdam, co-
 author 
  
 of
  Modern Operating Systems (4th Edition)
 .
  
 • “... It is amazing and unbelievable.” Luis Rocha, CISSP / ISSAP, Technical Manager, Network & Information Security at 
  
 Verizon Business.
  
 • “Thanks for the great work and your book.” Joris van de Vis, SAP Netweaver & Security specialist.
  
 • “... reasonable intro to some of the techniques.”
 15
 Mike Stay, teacher at the Federal Law Enforcement Training Center, 
  
 Georgia, US.
  
 9
 Database management systems 
  
 10
  Executable file format widely used in *NIX systems including 
 Linux 
  
 11
 Thread Local Storage 
  
 12
 Position Independent Code:
  67.1 on page 663 
  
 13
 twitter.com/daniel_bilar/status/436578617221742593",NA
Part I ,NA,NA
Code patterns,1,NA
Exercises,"When the author of this book studied assembly language, he also often compiled small C-functions and then rewrote them 
 gradually to assembly, trying to make their code as short as possible. This probably is not worth doing in real-world 
 scenarios today, because it’s hard to compete with modern compilers in terms of efficiency. It is, however, a very good way 
 to gain a better understanding of assembly. Feel free, therefore, to take any assembly code from this book and try to make 
 it shorter. However, don’t forget to test what you have written.",NA
Optimization levels and debug information,"Source code can be compiled by different compilers with various optimization levels. A typical compiler has about three 
 such levels, where level zero means disable optimization. Optimization can also be targeted towards code size or code 
 speed. A non-optimizing compiler is faster and produces more understandable (albeit verbose) code, whereas an 
 optimizing compiler is slower and tries to produce code that runs faster (but is not necessarily more compact). In addition 
 to optimization levels and direction, a compiler can include in the resulting file some debug information, thus producing 
 code for easy debugging. One of the important features of the ´debug’ code is that it might contain links between each 
 line of the source code and the respective machine code addresses. Optimizing compilers, on the other hand, tend to 
 produce output where entire lines of source code can be optimized away and thus not even be present in the resulting 
 machine code. Reverse engineers can encounter either version, simply because some developers turn on the compiler’s 
 optimization flags and others do not. Because of this, we’ll try to work on examples of both debug and release versions of 
 the code featured in this book, where possible.
  
 22
 In fact, he still does it when he can’t understand what a particular bit of code does.",NA
Chapter 1,NA,NA
A short introduction to the CPU,"The
  CPU
  is the device that executes the machine code a program consists of.
  
 A short glossary:
  
 Instruction
  : A primitive
  CPU
  command. The simplest examples include: moving data between registers, working with 
  
 memory, primitive arithmetic operations. As a rule, each
  CPU
  has its own instruction set architecture (
 ISA
 ).
  
 Machine code
  : Code that the
  CPU
  directly processes. Each instruction is usually encoded by several bytes.
  
 Assembly language
  : Mnemonic code and some extensions like macros that are intended to make a programmer’s life 
 easier. 
 CPU register
  : Each
  CPU
  has a fixed set of general purpose registers (
 GPR
 ).
  ≈ 8
  in x86,
  ≈ 16
  in x86-64,
  ≈ 16
  in ARM. 
 The with a high-level
  PL
 1
 and could only use eight 32-bit (or 64-bit) variables. Yet a lot can be done using just these!
  
 One might wonder why there needs to be a difference between machine code and a
  PL
 . The answer lies in the fact that 
 humans and
  CPU
 s are not alike—it is much easier for humans to use a high-level
  PL
  like C/C++, Java, Python, etc., but it is 
 easier for a
  CPU
  to use a much lower level of abstraction. Perhaps it would be possible to invent a
  CPU
  that can execute 
 high-level
  PL
  code, but it would be many times more complex than the
  CPU
 s we know of today. In a similar fashion, it is 
 very inconvenient for humans to write in assembly language, due to it being so low-level and difficult to write in without 
 making a huge number of annoying mistakes. The program that converts the high-level
  PL
  code into assembly is called a
  
 compiler
 . 
 2
 .",NA
1.1 A couple of words about different,NA,NA
 ISA,NA,NA
s,"The x86
  ISA
  has always been one with variable-length opcodes, so when the 64-bit era came, the x64 extensions did not 
 impact the
  ISA
  very significantly. In fact, the x86
  ISA
  still contains a lot of instructions that first appeared in 16-bit 8086 
 CPU, yet are still found in the CPUs of today. ARM is a
  RISC
 3
 CPU
  designed with constant-length opcode in mind, which had 
 some advantages in the past. In the very beginning, all ARM instructions were encoded in 4 bytes
 4
 . This is now referred to 
 as“ARM mode”. Then they thought it wasn’t as frugal as they first imagined. In fact, most used
  CPU
  instructions
 5
 in real 
 world applications can be encoded using less information. They therefore added another
  ISA
 , called Thumb, where each 
 instruction was encoded in just 2 bytes. This is now referred as “Thumb mode”. However, not
  all
  ARM instructions can be 
 encoded in just 2 bytes, so the Thumb instruction set is somewhat limited. It is worth noting that code compiled for ARM 
 mode and Thumb mode may of course coexist within one single program. The ARM creators thought Thumb could be 
 extended, giving rise to Thumb-2, which appeared in ARMv7. Thumb-2 still uses 2-byte instructions, but has some new 
 instructions which have the size of 4 bytes. There is a common misconception that Thumb-2 is a mix of ARM and Thumb. 
 This is incorrect. Rather, Thumb-2 was extended to fully support all processor features so it could compete with ARM 
 mode—a goal that was clearly achieved, as the majority of applications for iPod/iPhone/iPad are compiled for the Thumb-2 
 instruction set (admittedly, largely due to the fact that Xcode does this by default). Later the 64-bit ARM came out. This
  
 ISA
  has 4-byte opcodes, and lacked the need of any additional Thumb mode. However, the 64-bit requirements affected 
 the
  ISA
 , resulting in us now having three ARM instruction sets: ARM mode, Thumb mode (including Thumb-2) and ARM64. 
 These
  ISA
 s intersect partially, but it can be said that they are different
  ISA
 s, rather than variations of the same one. 
 Therefore, we would try to add fragments of code in all three ARM
  ISA
 s in this book. There are, by the way, many other
  
 RISC ISA
 s with fixed length 32-bit opcodes, such as MIPS, PowerPC and Alpha AXP.
  
 1
 Programming language 
  
 2
 Old-school Russian literature also use term “translator”.",NA
Chapter 2,NA,NA
The simplest Function,"The simplest possible function is arguably one that simply returns a constant 
 value: Here it is:
  
 Listing 2.1: C/C++ Code
  
 int f() 
  
 {
  
 return 123; 
  
 };
  
 Lets compile it!",NA
2.1 x86,"Here’s what both the optimizing GCC and MSVC compilers produce on the x86 platform:
  
 Listing 2.2: Optimizing GCC/MSVC (assembly output)
  
 f: 
  
 mov 
  
 eax, 123 
  
 ret
  
  
 There are just two instructions: the first places the value 123 into the
  EAX
  register, which is used by convention for storing 
 the return value and the second one is
  RET
 , which returns execution to the
  caller
 . 
  
 The caller will take the result from the
  EAX
  register.",NA
2.2 ARM,"There are a few differences on the ARM platform:
  
 Listing 2.3: Optimizing Keil 6/2013 (ARM mode) ASM Output
  
 f PROC 
  
 MOV 
  
 r0,#0x7b ; 123
  
 BX 
  
 lr
  
 ENDP
  
 ARM uses the register
  R0
  for returning the results of functions, so 123 is copied into
  R0
 .
  
 The return address is not saved on the local stack in the ARM
  ISA
 , but rather in the link register, so the
  BX LR
  instruction 
 causes execution to jump to that address—effectively returning execution to the
  caller
 .
  
 It is worth noting that
  MOV
  is a misleading name for the instruction in both x86 and ARM
  ISA
 s.
  
 The data is not in fact
  moved
 , but
  copied
 .",NA
2.3 MIPS,"CHAPTER 2. THE SIMPLEST FUNCTION
  
 There are two naming conventions used in the world of MIPS when naming registers: by number (from $0 to $31) or by 
 pseudoname ($V0, $A0, etc).
  
 The GCC assembly output below lists registers by number:
  
 Listing 2.4: Optimizing GCC 4.4.5 (assembly output)
  
 j 
  
 $31
  
 li
  
 $2,123
  
 # 0x7b
  
  
 …while
  IDA
 1
 does it—by their pseudonames:
  
 Listing 2.5: Optimizing GCC 4.4.5 (IDA)
  
 jr 
  
 $ra
  
 li 
  
 $v0, 0x7B
  
 The $2 (or $V0) register is used to store the function’s return value.
  LI
  stands for “Load Immediate” and is the MIPS 
 equivalent to
  MOV
 .
  
 The other instruction is the jump instruction (J or JR) which returns the execution flow to the
  caller
 , jumping to the address 
 in the $31 (or $RA) register.
  
 This is the register analogous to
  LR
 2
 in ARM.
  
 You might be wondering why positions of the the load instruction (LI) and the jump instruction (J or JR) are swapped. This is 
 due to a
  RISC
  feature called “branch delay slot”.
  
 The reason this happens is a quirk in the architecture of some RISC
  ISA
 s and isn’t important for our purposes—we just 
 need to remember that in MIPS, the instruction following a jump or branch instruction is executed
  before
  the jump/branch 
 instruction itself.
  
 As a consequence, branch instructions always swap places with the instruction which must be executed beforehand.
  
 2.3.1 
  
 A note about MIPS instruction/register names
  
 Register and instruction names in the world of MIPS are traditionally written in lowercase. However, for the sake of consis-
 tency, we’ll stick to using uppercase letters, as it is the convention followed by all other
  ISA
 s featured this book.
  
 1
  Interactive Disassembler and debugger developed by
  Hex-Rays 
  
 2
 Link Register",NA
Chapter 3,NA,NA
"Hello, world!","Let’s use the famous example from the book
  
 “The C programming Language”[
 Ker88
 ]:
  
  
 #include <stdio.h> 
  
 int main() 
  
 {
  
  
 printf(""hello, world\n""); 
  
  
 return 0; 
  
 }",NA
3.1 ,3.1.1,NA
x86 ,"MSVC
  
 Let’s compile it in MSVC 2010:
  
 cl 1.cpp /Fa1.asm
  
  
 (/Fa option instructs the compiler to generate assembly listing file)
  
 Listing 3.1: MSVC 2010
  
 CONST 
  
 SEGMENT 
  
 $SG3830 DB 
  
 'hello, world', 0AH, 00H 
  
 CONST 
  
 ENDS 
  
 PUBLIC 
  
 _main 
  
 EXTRN 
  
 _printf:PROC 
  
 ; Function compile flags: /Odtp
  
 _TEXT
  
 SEGMENT
  
 ebp
  
 _main
  
 PROC
  
 push
  
  
 _main
  
 mov
  
 ebp, esp
  
 push
  
 OFFSET $SG3830
  
 call
  
 _printf
  
 add
  
 esp, 4
  
 xor
  
 eax, eax
  
 pop
  
 ebp
  
 ret
  
 0
  
 ENDP
  
 _TEXT
  
 ENDS
  
  
  
 MSVC produces assembly listings in Intel-syntax. 
 in
  3.1.3 on page 8
 .
  
 The difference between Intel-syntax and AT&T-syntax will be discussed
  
 The compiler generated the file,
  1.obj
 , which is to be linked into
  1.exe
 . In our case, the file contains two segments: 
 CONST
  
 (for data constants) and
  _TEXT
  (for code).
  
 The string
  hello, world
  in C/C++ has type
  const char[]
 [
 Str13
 , p176, 7.3.2], but it does not have its own name. The compiler 
 needs to deal with the string somehow so it defines the internal name
  $SG3830
  for it.
  
 That is why the example may be rewritten as follows:
  
 6",NA
3.2 x86-64,"3.2.1 
  
 MSVC—x86-64
  
 Let’s also try 64-bit MSVC:
  
 Listing 3.7: MSVC 2012 x64
  
 $SG2989 DB 
  
 'hello, world', 0AH, 00H
  
 main 
  
 PROC
  
 sub 
  
 rsp, 40
  
 lea 
  
 rcx, OFFSET FLAT:$SG2989
  
 call 
  
 printf
  
  
 7
 This GCC option can be used to eliminate “unnecessary” macros:
  -fno-asynchronous-unwind-tables 
  
  
 8
 By the way, in some C standard functions (e.g., memcpy(), strcpy()) the arguments are listed in the same way as in Intel-syntax: first the pointer to the 
 destination memory block, and then the pointer to the source memory block.",NA
3.3 GCC—one more thing,"CHAPTER 3. HELLO, WORLD!
  
 The fact that an
  anonymous
  C-string has
  const
  type (
  3.1.1 on page 6
 ), and that C-strings allocated in constants segment are 
 guaranteed to be immutable, has an interesting consequence: the compiler may use a specific part of the string.
  
 Let’s try this example:
  
 #include <stdio.h>
  
 int f1() 
  
 { 
  
 printf (""world\n""); 
  
 }
  
 int f2() 
  
 {
  
 printf (""hello world\n""); 
  
 }
  
 int main() 
  
 { 
  
 f1(); 
  
 f2(); 
  
 }
  
 Common C/C++-compilers (including MSVC) allocate two strings, but let’s see what GCC 4.8.1 does:
  
 Listing 3.10: GCC 4.8.1 + IDA listing
  
 f1 
  
 proc near
  
 s 
  
 = dword ptr -1Ch
  
 sub 
  
 esp, 1Ch
  
 mov 
  
 [esp+1Ch+s], offset s ; ""world\n""
  
 call 
  
 _puts
  
 add 
  
 esp, 1Ch
  
 retn
  
 f1 
  
 endp
  
 f2 
  
 proc near
  
 s 
  
 = dword ptr -1Ch
  
 sub 
  
 esp, 1Ch
  
 mov 
  
 [esp+1Ch+s], offset aHello ; ""hello ""
  
 call 
  
 _puts
  
 add 
  
 esp, 1Ch
  
 retn
  
 f2 
  
 endp
  
 aHello 
  
 db 'hello '
  
 s 
  
 db 'world',0xa,0
  
 Indeed: when we print the “hello world” string these two words are positioned in memory adjacently and
  puts()
  called from 
 f2() function is not aware that this string is divided. In fact, it’s not divided; it’s divided only “virtually”, in this listing. When
  
 puts()
  is called from f1(), it uses the “world” string plus a zero byte.
  puts()
  is not aware that there is something before this 
 string!
  
 This clever trick is often used by at least GCC and can save some memory.",NA
3.4 ARM,"For my experiments with ARM processors, several compilers were 
 used:• Popular in the embedded area: Keil Release 6/2013.
  
 • Apple Xcode 4.6.3 IDE (with the LLVM-GCC 4.2 compiler
 10
 ).
  
 10
 It is indeed so: Apple Xcode 4.6.3 uses open-source GCC as front-end compiler and LLVM code generator
  
 11",NA
3.5 MIPS,"3.5.1 
  
 A word about the “global pointer”
  
 One important MIPS concept is the “global pointer”. As we may already know, each MIPS instruction has a size of 32 bits, 
 so it’s impossible to embed a 32-bit address into one instruction: a pair has to be used for this (like GCC did in our 
 example for the text string address loading).
  
 It’s possible, however, to load data from the address in the range of
  register
  − 32768
 ...register
  + 32767
  using one single for 
 this purpose and also allocate a 64KiB area of most used data. 
  
 This allocated register is called a “global pointer” and 
 it points to the middle of the 64KiB area. 
  
 This area usually contains global variables and addresses of imported functions 
 like
  printf()
 , because the GCC developers decided that getting the address of some function must be as fast as a single 
 instruction execution instead of two. 
  
 In an ELF file this 64KiB area is located partly in sections .sbss (“small
  BSS
 27
 ”) for 
 uninitialized data and .sdata (“small data”) for initialized data.
  
 This implies that the programmer may choose what data he/she wants to be accessed fast and place it into .sdata/.sbss.
  
 Some old-school programmers may recall the MS-DOS memory model
  94 on page 868
  or the MS-DOS memory managers 
 like XMS/EMS where all memory was divided in 64KiB blocks.
  
 This concept is not unique to MIPS. At least PowerPC uses this technique as well.
  
 3.5.2 
  
 Optimizing GCC
  
 Lets consider the following example, which illustrates the “global pointer” concept.
  
 Listing 3.18: Optimizing GCC 4.4.5 (assembly output)
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1 
 1
 2 
 1
 3 
 1
 4 
 1
 5 
 1
 6 
 1
 7 
 1
 $LC0: 
  
 ; \000 is zero byte in octal base: 
  
 .ascii 
  
 ""Hello, world!\012\000"" 
  
 main: 
  
 ; function prologue.
  
 ; set the GP: 
  
  
  
 $28,%hi(__gnu_local_gp) lui 
  
 addiu 
  
 $sp,$sp,-32 
  
 addiu 
  
 $28,$28,%lo(__gnu_local_gp) 
  
 ; save the RA to the local stack: 
  
 sw 
  
 $31,28($sp) 
  
 ; load the address of the puts() function from the GP to $25:
  
 lw 
  
 $25,%call16(puts)($28) 
  
 ; load the address of the text string to $4 ($a0): 
  
 lui 
  
 $4,%hi($LC0) 
  
 ; jump to puts(), saving the return address in the link register: jalr 
  
 $25 
  
 addiu 
  
 $4,$4,%lo($LC0) ; branch delay slot 
  
 ; restore the RA: 
  
 lw 
  
 $31,28($sp) 
  
 ; copy 0 from $zero to $v0: 
  
 move 
  
 $2,$0 
  
 ; return by jumping to the RA: 
  
 j 
  
 $31
  
  
  
 27
 Block Started by Symbol",NA
3.6,NA,NA
Conclusion,"The main difference between x86/ARM and x64/ARM64 code is that the pointer to the string is now 64-bits in length. 
 Indeed, modern
  CPU
 s are now 64-bit due to both the reduced cost of memory and the greater demand for it by modern 
 applications. We can add much more memory to our computers than 32-bit pointers are able to address. As such, all 
 pointers are now 64-bit.",NA
3.7 Exercises,"•
  http://challenges.re/48
  
 •
  http://challenges.re/49",NA
Chapter 4,NA,NA
Function prologue and epilogue,"A function prologue is a sequence of instructions at the start of a function. It often looks something like the following code 
 fragment:
  
 push ebp
  
 mov ebp, esp
  
 sub esp, X
  
 What these instruction do: save the value in the
  EBP
  register, set the value of the
  EBP
  register to the value of the
  ESP
  and 
 then allocate space on the stack for local variables.
  
 The value in the
  EBP
  stays the same over the period of the function execution and is to be used for local variables and 
 arguments access. For the same purpose one can use
  ESP
 , but since it changes over time this approach is not too 
 convenient.
  
 The function epilogue frees the allocated space in the stack, returns the value in the
  EBP
  register back to its initial state 
 and returns the control flow to the
  callee
 :
  
 mov 
  
 esp, ebp
  
 pop 
  
 ebp
  
 ret 
  
 0
  
 Function prologues and epilogues are usually detected in disassemblers for function delimitation.",NA
4.1 Recursion,"Epilogues and prologues can negatively affect the recursion performance.
  
 More about recursion in this book:
  36.3 on page 450
 .",NA
Chapter 5,NA,NA
Stack,"The stack is one of the most fundamental data structures in computer science
 1
 .
  
 Technically, it is just a block of memory in process memory along with the
  ESP
  or
  RSP
  register in x86 or x64, or the
  SP 
 register in ARM, as a pointer within that block.
  
 The most frequently used stack access instructions are
  PUSH
  and
  POP
  (in both x86 and ARM Thumb-mode).
  PUSH
  
 subtracts from
  ESP
 /
 RSP
 /
 SP
  4 in 32-bit mode (or 8 in 64-bit mode) and then writes the contents of its sole operand to the 
 memory address pointed by
  ESP
 /
 RSP
 /
 SP
 .
  
 POP
  is the reverse operation: retrieve the data from the memory location that
  SP
  points to, load it into the instruction 
 operand (often a register) and then add 4 (or 8) to the
  stack pointer
 .
  
 After stack allocation, the
  stack pointer
  points at the bottom of the stack.
  PUSH
  decreases the
  stack pointer
  and
  POP
  
 increases it. The bottom of the stack is actually at the beginning of the memory allocated for the stack block. It seems 
 strange, but that’s the way it is.
  
 ARM supports both descending and ascending stacks.
  
 For example the
  STMFD
 /
 LDMFD
 ,
  STMED
 2
 /
 LDMED
 3
 instructions are intended to deal with a descending stack (grows down-
 wards, starting with a high address and progressing to a lower one). The
  STMFA
 4
 /
 LDMFA
 5
 ,
  STMEA
 6
 /
 LDMEA
 7
 instructions are 
 intended to deal with an ascending stack (grows upwards, starting from a low address and progressing to a higher one).",NA
5.1 Why does the stack grow backwards?,"Intuitively, we might think that the stack grows upwards, i.e. towards higher addresses, like any other data structure.
  
 The reason that the stack grows backward is probably historical. When the computers were big and occupied a whole 
 room, it was easy to divide memory into two parts, one for the
  heap
  and one for the stack. Of course, it was unknown how 
 big the 
 heap
  and the stack would be during program execution, so this solution was the simplest possible.
  
 Start of heap
  
 Heap
  
 Stack
  
 Start of stack
  
 In [
 RT74
 ] we can read:
  
 The user-core part of an image is divided into three logical segments. The program text segment 
 begins at location 0 in the virtual address space. During execution, this segment is write-protected and a 
 single copy of it is shared among all processes executing the same program. At the first 8K byte boundary 
 above the program text segment in the virtual address space begins a nonshared, writable data segment, 
 the size
  
 1
 wikipedia.org/wiki/Call_stack 
  
 2
 Store Multiple Empty Descending (ARM instruction) 
  
 3
 Load Multiple Empty Descending (ARM instruction) 
  
 4
 Store Multiple Full Ascending (ARM instruction) 
  
 5
 Load Multiple Full Ascending (ARM instruction) 
  
 6
 Store Multiple Empty Ascending (ARM instruction) 
  
 7
 Load Multiple Empty Ascending (ARM instruction)",NA
5.2 What is the stack used for?,"5.2.1 
  
 Save the function’s return address
  
 x86
  
 When calling another function with a
  CALL
  instruction, the address of the point exactly after the
  CALL
  instruction is saved 
 to the stack and then an unconditional jump to the address in the CALL operand is executed.
  
 The
  CALL
  instruction is equivalent to a
  PUSH address_after_call / JMP operand
  instruction pair. 
 RET
  fetches a 
 value from the stack and jumps to it —that is equivalent to a
  POP tmp / JMP tmp
  instruction pair.
  
 Overflowing the stack is straightforward. Just run eternal recursion:
  
 void f() 
  
 {
  
 f(); 
  
 };
  
 MSVC 2008 reports the problem:
  
 c:\tmp6>cl ss.cpp /Fass.asm 
  
 Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 15.00.21022.08 for 80x86 Copyright (C) Microsoft 
 Corporation. 
  
 All rights reserved.
  
 ss.cpp 
  
 c:\tmp6\ss.cpp(4) : warning C4717: 'f' : recursive on all control paths, function will cause
  ⤦
  
 …but generates the right code anyway:
  
 ?f@@YAXXZ PROC 
   
 ; f ; 
 File c:\tmp6\ss.cpp 
  
 ; Line 2 
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 ; Line 3
  
 call
  
 ?f@@YAXXZ
  
 ; f
  
 ; Line 4
  
 pop
  
 ebp
  
 ; f
  
 ret
  
 0
  
 ?f@@YAXXZ ENDP
  
  
  
 …Also if we turn on the compiler optimization (
 /Ox
  option) the optimized code will not overflow the stack and will work 
 correctly
 8
 instead:
  
 ?f@@YAXXZ PROC 
  
 ; f ; 
 File c:\tmp6\ss.cpp 
  
 ; Line 2 
  
 $LL3@f:
  
 ; Line 3
  
 jmp
  
 SHORT $LL3@f
  
 ; f
  
 ?f@@YAXXZ ENDP
  
  
 GCC 4.4.1 generates similar code in both cases without, however, issuing any warning about the problem.
  
 8
 irony here",NA
5.3 A typical stack layout,"A typical stack layout in a 32-bit environment at the start of a function, before the first instruction execution looks like this:
  
 …
  
 …
  
 ESP-0xC
  
 local variable #2, marked in
  IDA
  as
  var_8
  
 ESP-8
  
 local variable #1, marked in
  IDA
  as
  var_4
  
 ESP-4
  
 saved value of
  EBP
  
 ESP
  
 return address
  
 ESP+4
  
 argument#1, marked in
  IDA
  as
  arg_0
  
 ESP+8
  
 argument#2, marked in
  IDA
  as
  arg_4
  
 ESP+0xC
  
 argument#3, marked in
  IDA
  as
  arg_8
  
 …
  
 …",NA
5.4,NA,NA
Noise in stack,"Often in this book “noise” or “garbage” values in the stack or memory are mentioned. Where do they come from? These are 
 what was left in there after other functions’ executions. Short example:
  
 #include <stdio.h> 
  
 void f1() 
  
 { 
  
 int a=1, b=2, c=3; 
  
 }; 
  
 void f2()
  
 { 
  
 int a, b, c; 
  
 printf (""%d, %d, %d\n"", a, b, c); 
  
 };
  
 int main() 
  
 { 
  
 f1();
  
 16
 Structured Exception Handling :
  68.3 on page 677",NA
5.5 Exercises,"•
  http://challenges.re/51
  
 •
  http://challenges.re/52",NA
Chapter 6,NA,NA
printf(),NA,NA
 with several arguments,"Now let’s extend the
  Hello, world!
  (
  3 on page 6
 ) example, replacing
  printf()
  in the
  main()
  function body with this:
  
 #include <stdio.h> 
  
 int main() 
  
 {
  
 printf(""a=%d; b=%d; c=%d"", 1, 2, 3); 
  
 return 0; 
  
 };",NA
6.1 ,6.1.1,NA
x86 ,"x86: 3 arguments
  
 MSVC
  
 When we compile it with MSVC 2010 Express we get:
  
 $SG3830 DB 
  
 'a=%d; b=%d; c=%d', 00H
  
 ...
  
 push 
  
 3
  
 push
  
 2
  
 ; 00000010H
  
 push
  
 1
  
 push
  
 OFFSET $SG3830
  
 call
  
 _printf
  
 add
  
 esp, 16
  
  
 Almost the same, but now we can see the
  printf()
  arguments are pushed onto the stack in reverse order. The first argument 
 is pushed last.
  
 By the way, variables of
  int
  type in 32-bit environment have 32-bit width, that is 4 bytes.
  
 So, we have 4 arguments here.
  4 ∗ 4 = 16
  —they occupy exactly 16 bytes in the stack: a 32-bit pointer to a string and 3 
 When the
  stack pointer
  (
 ESP
  register) has changed back by the
  ADD ESP, X
  instruction after a function call, often, the 
 number of function arguments could be deduced by simply dividing X by 4.
  
 Of course, this is specific to the
  cdecl
  calling convention, and only for 32-bit environment.
  
 See also the calling conventions section (
  64 on page 648
 ).
  
 In certain cases where several functions return right after one another, the compiler could merge multiple “ADD ESP, 
 X”instructions into one, after the last call:
  
 push 
 a1 
  
 push 
 a2 
  
 call ...
  
 ...
  
 push a1",NA
6.2 ,6.2.1,NA
ARM ,"ARM: 3 arguments
  
 ARM’s traditional scheme for passing arguments (calling convention) behaves as follows: the first 4 arguments are passed
  
 through the
  R0
 -
 R3
  registers; the remaining arguments via the stack. This resembles the arguments passing scheme in
  
 fastcall (
  64.3 on page 649
 ) or win64 (
  64.5.1 on page 650
 ).
  
 32-bit ARM
  
 Non-optimizing Keil 6/2013 (ARM mode)
  
 Listing 6.7: Non-optimizing Keil 6/2013 (ARM mode)
  
 .text:00000000 main
  
 .text:00000000 10 40 2D E9
  
 STMFD
  
 SP!, {R4,LR}
  
 .text:00000004 03 30 A0 E3
  
 MOV
  
 R3, #3
  
 .text:00000008 02 20 A0 E3
  
 MOV
  
 R2, #2
  
 .text:0000000C 01 10 A0 E3
  
 MOV
  
 R1, #1
  
  
  
 .text:00000010 08 00 8F E2
  
 ADR
  
 R0, aADBDCD
  
 ; ""a=%d; b=%d; c=%d""
  
 .text:00000014 06 00 00 EB
  
 BL
  
 __2printf
  
 ; return 0
  
 .text:00000018 00 00 A0 E3
  
 MOV
  
 R0, #0
  
 .text:0000001C 10 80 BD E8
  
 LDMFD
  
 SP!, {R4,PC}
  
  
 So, the first 4 arguments are passed via the
  R0
 -
 R3
  registers in this order: a pointer to the
  printf()
  format string in
  R0
 ,
  
 then 1 in
  R1
 , 2 in
  R2
  and 3 in
  R3
 .
  
 The instruction at
  0x18
  writes 0 to
  R0
 —this is
  return 0
  C-statement.
  
 There is nothing unusual so far.
  
 Optimizing Keil 6/2013 generates the same code.
  
 Optimizing Keil 6/2013 (Thumb mode)
  
 Listing 6.8: Optimizing Keil 6/2013 (Thumb mode)
  
 .text:00000000 main
  
 .text:00000000 10 B5
  
 PUSH
  
 {R4,LR}
  
 .text:00000002 03 23
  
 MOVS
  
 R3, #3
  
 .text:00000004 02 22
  
 MOVS
  
 R2, #2
  
 .text:00000006 01 21
  
 MOVS
  
 R1, #1
  
  
  
 .text:00000008 02 A0
  
 ADR
  
 R0, aADBDCD
  
 ; ""a=%d; b=%d; c=%d""
  
 .text:0000000A 00 F0 0D F8
  
 BL
  
 __2printf
  
 .text:0000000E 00 20
  
 MOVS
  
 R0, #0
  
 .text:00000010 10 BD
  
 POP
  
 {R4,PC}
  
  
 There is no significant difference from the non-optimized code for ARM mode.
  
 Optimizing Keil 6/2013 (ARM mode) + let’s remove return
  
 Let’s rework example slightly by removing
  return 0
 :
  
 #include <stdio.h> 
  
 void main()
  
 { 
  
 printf(""a=%d; b=%d; c=%d"", 1, 2, 3); 
  
 };",NA
6.3 MIPS,"6.3.1 
  
 3 arguments
  
 Optimizing GCC 4.4.5
  
 The main difference with the “Hello, world!” example is that in this case
  printf()
  is called instead of
  puts()
  and 3 more 
 arguments are passed through the registers $5…$7 (or $A0…$A2).
  
 That is why these registers are prefixed with A-, which implies they are used for function arguments passing.
  
 Listing 6.12: Optimizing GCC 4.4.5 (assembly output)
  
 $LC0: 
  
 .ascii 
  
 ""a=%d; b=%d; c=%d\000"" 
  
 main: 
  
 ; function prologue: 
  
 lui 
  
 $28,%hi(__gnu_local_gp) 
  
 addiu 
  
  
 $sp,$sp,-32 addiu 
  
 $28,$28,%lo(__gnu_local_gp) 
  
 sw 
  
 $31,28($sp) 
  
 ; load address of printf(): 
  
 lw 
  
 $25,%call16(printf)($28) 
  
 ; load address of the text string and set 1st argument of printf(): lui 
  
 $4,%hi($LC0) 
  
 addiu 
  
 $4,$4,%lo($LC0) 
  
 ; set 2nd argument of printf():
  
 li
  
 $5,1
  
 # 0x1
  
  
 ; set 3rd argument of printf():
  
 li
  
 $6,2
  
 # 0x2
  
 ; call printf(): 
  
 jalr 
  
 $25 
  
 ; set 4th argument of printf() (branch delay slot):
  
 li
  
 $7,3
  
 # 0x3
  
 ; function epilogue: 
  
 lw 
  
 $31,28($sp) 
  
 ; set return value to 0: 
  
 move 
  
 $2,$0 
  
 ; return 
  
 j 
  
  
 $31 addiu 
  
 $sp,$sp,32 ; branch delay slot
  
 Listing 6.13: Optimizing GCC 4.4.5 (IDA)
  
  
 .text:00000000 main:",NA
6.4,NA,NA
Conclusion,"Here is a rough skeleton of the function call:
  
 Listing 6.20: x86
  
 ...
  
 PUSH 3rd argument 
  
 PUSH 2nd argument
  
 PUSH 1st argument 
  
 CALL function 
  
 ; modify stack pointer (if needed)
  
 Listing 6.21: x64 (MSVC)
  
 MOV RCX, 1st argument 
  
 MOV RDX, 2nd argument 
  
 MOV R8, 3rd argument 
  
 MOV R9, 4th argument
  
 ...
  
 PUSH 5th, 6th argument, etc (if needed) 
  
 CALL function 
  
 ; modify stack pointer (if needed)
  
 Listing 6.22: x64 (GCC)
  
 MOV RDI, 1st argument 
  
 MOV RSI, 2nd argument 
  
 MOV RDX, 3rd argument 
  
 MOV RCX, 4th argument 
  
 MOV R8, 5th argument
  
 MOV R9, 6th argument 
  
 ...
  
 PUSH 7th, 8th argument, etc (if needed) 
  
 CALL function 
  
 ; modify stack pointer (if needed)
  
 Listing 6.23: ARM
  
 MOV R0, 1st argument 
  
 MOV R1, 2nd argument 
  
 MOV R2, 3rd argument 
  
 MOV R3, 4th argument
  
 ; pass 5th, 6th argument, etc, in stack (if needed) BL function 
  
 ; modify stack pointer (if needed)
  
 56",NA
6.5,NA,NA
By the way,"By the way, this difference between the arguments passing in x86, x64, fastcall, ARM and MIPS is a good illustration of 
 the fact that the CPU is oblivious to how the arguments are passed to functions. It is also possible to create a hypothetical 
 compiler able to pass arguments via a special structure without using stack at all.
  
 MIPS $A0 …$A3 registers are labelled this way only for convenience (that is in the O32 calling convention). 
 may use any other register (well, maybe except $ZERO) to pass data or use any other calling convention.
  
 Programmers
  
 The
  CPU
  is not aware of calling conventions whatsoever.
  
 We may also recall how newcoming assembly language programmers passing arguments into other functions: usually via 
 registers, without any explicit order, or even via global variables. Of course, it works fine.",NA
Chapter 7,NA,NA
scanf(),Now let’s use scanf().,NA
7.1,NA,NA
Simple example,"#include <stdio.h>
  
 int main() 
  
 { 
  
 int x; 
  
 printf (""Enter X:\n"");
  
 scanf (""%d"", &x); 
  
 printf (""You entered %d...\n"", x); 
  
 return 0; 
  
 };
  
 It’s not clever to use
  scanf()
  for user interactions nowadays. But we can, however, illustrate passing a pointer to a variable 
 of type
  int
 .
  
 7.1.1 
  
 About pointers
  
 Pointers are one of the fundamental concepts in computer science. Often, passing a large array, structure or object as an 
 argument to another function is too expensive, while passing their address is much cheaper. In addition if the
  callee
  
 function needs to modify something in the large array or structure received as a parameter and return back the entire 
 structure then the situation is close to absurd. So the simplest thing to do is to pass the address of the array or structure 
 to the
  callee 
 function, and let it change what needs to be changed.
  
 A pointer in C/C++—is simply an address of some memory location.
  
 In x86, the address is represented as a 32-bit number (i.e., it occupies 4 bytes), while in x86-64 it is a 64-bit number 
 (occupying 8 bytes). By the way, that is the reason behind some people’s indignation related to switching to x86-64—all 
 pointers in the x64-architecture require twice as much space, including cache memory, which is “expensive” memory.
  
 It is possible to work with untyped pointers only, given some effort; e.g. the standard C function
  memcpy()
 , that copies a 
 block from one memory location to another, takes 2 pointers of type
  void*
  as arguments, since it is impossible to predict 
 the type of the data you would like to copy. Data types are not important, only the block size matters.
  
 Pointers are also widely used when a function needs to return more than one value (we are going to get back to this later (
  
 10 on page 100
 ) ).
  
 scanf()
  function—is such a case.
  
 Besides the fact that the function needs to indicate how many values were successfully read, it also needs to return all 
 these values.
  
 In C/C++ the pointer type is only needed for compile-time type checking.
  
 Internally, in the compiled code there is no information about pointer types at all.",NA
7.2,NA,NA
Global variables,"What if the
  x
  variable from the previous example was not local but a global one? Then it would have been accessible from
  
 any point, not only from the function body. Global variables are considered
  anti-pattern
 , but for the sake of the experiment,
  
 we could do this.
  
 #include <stdio.h>
  
 // now x is global variable 
  
 int x;
  
 int main() 
  
 { 
  
 printf (""Enter X:\n"");
  
 scanf (""%d"", &x); 
  
 printf (""You entered %d...\n"", x); 
  
 return 0; 
  
 };
  
  
 7.2.1
  
 MSVC: x86
  
   
 _DATA
  
 SEGMENT
  
 'Enter X:', 0aH, 00H
  
 COMM
  
 _x:DWORD
  
 $SG2456
  
 DB
  
 $SG2457
  
 DB
  
 '%d', 00H",NA
7.3 ,NA,NA
scanf() result checking,"CHAPTER 7. SCANF()
  
 As was noted before, it is slightly old-fashioned to use
  scanf()
  today. But if we have to, we need to at least check if 
 scanf()
  
 finishes correctly without an error.
  
 #include <stdio.h>
  
 int main() 
  
 { 
  
 int x; 
  
 printf (""Enter X:\n"");
  
 if (scanf (""%d"", &x)==1) 
  
  
 printf (""You entered %d...\n"", x); 
  
 else 
  
  
 printf (""What you entered? Huh?\n"");
  
 return 0; 
  
 };
  
 By standard, the
  scanf()
 4
 function returns the number of fields it has successfully read.
  
 In our case, if everything goes fine and the user enters a number
  scanf()
  returns 1, or in case of error (or
  EOF
 5
 ) — 0. 
 Let’s add some C code to check the
  scanf()
  return value and print error message in case of an error.
  
 This works as expected:
  
 C:\...>ex3.exe 
  
 Enter X: 
  
 123 
  
 You entered 123...
  
 C:\...>ex3.exe 
  
 Enter X: 
  
 ouch 
  
 What you entered? Huh?
  
  
 7.3.1
  
 MSVC: x86
  
 Here is what we get in the assembly output (MSVC 2010):
  
 lea 
  
 eax, DWORD PTR _x$[ebp] 
  
 push 
  
 eax 
  
 push 
  
 OFFSET $SG3833 ; '%d', 00H 
  
 call 
  
 _scanf 
  
 add 
  
 esp, 8 
  
 cmp 
  
 eax, 1 
  
 jne 
  
 SHORT $LN2@main 
  
 mov 
  
 ecx, DWORD PTR _x$[ebp] 
  
 push 
  
 ecx 
  
 push 
  
 OFFSET $SG3834 ; 'You entered %d...', 0aH, 00H
  
 call 
  
 _printf 
  
 add 
  
 esp, 8 
  
 jmp 
  
 SHORT $LN1@main 
  
 $LN2@main: 
  
 push 
  
  
 OFFSET $SG3836 ; 'What you entered? Huh?', 0aH, 00H call 
  
 _printf 
  
 add 
  
 esp, 4 
  
 $LN1@main: 
  
 xor 
  
 eax, eax
  
 The
  caller
  function (
 main()
 ) needs the
  callee
  function (
 scanf()
 ) result, so the
  callee
  returns it in the
  EAX
  register. We check it 
 with the help of the instruction
  CMP EAX, 1
  (
 CoMPare
 ). In other words, we compare the value in the
  EAX 
 register with 1.
  
 4
 scanf, wscanf:
  MSDN 
  
 5
 End of file
  
 76",NA
7.4 ,NA,NA
Exercise,"•
  http://challenges.re/53",NA
Chapter 8,NA,NA
Accessing passed arguments,"Now we figured out that the
  caller
  function is passing arguments to the
  callee
  via the stack. But how does the
  callee
  access 
 them?
  
 Listing 8.1: simple example
  
 #include <stdio.h>
  
 int f (int a, int b, int c) 
  
 { 
  
 return a*b+c; 
  
 };
  
 int main() 
  
 { 
  
 printf (""%d\n"", f(1, 2, 3)); 
  
 return 0; 
  
 };",NA
8.1 ,8.1.1,NA
x86 ,"MSVC
  
 Here is what we get after compilation (MSVC 2010 Express): 
  
  
 Listing 8.2: MSVC 2010 Express
  
 _TEXT
  
 SEGMENT
  
 ebp
  
 ; size = 4
  
 _a$ = 8
  
 _b$ = 12
  
 ; size = 4
  
 _c$ = 16
  
 ; size = 4
  
 _f
  
 PROC
  
 push
  
 mov
  
 ebp, esp
  
 mov
  
 eax, DWORD PTR _a$[ebp]
  
 imul
  
 eax, DWORD PTR _b$[ebp]
  
 add
  
 eax, DWORD PTR _c$[ebp]
  
 pop
  
 ebp
  
 ret
  
 0
  
  
 _f
  
 ENDP
  
 ebp
  
 _main
  
 PROC
  
 push
  
 mov
  
 ebp, esp
  
 push
  
 3 ; 3rd argument
  
 push
  
 2 ; 2nd argument
  
 push
  
 1 ; 1st argument
  
 call
  
 _f
  
 add
  
 esp, 12
  
 push
  
 eax
  
 push
  
 OFFSET $SG2463 ; '%d', 0aH, 00H
  
  
 88",NA
8.2 x64,"The story is a bit different in x86-64. Function arguments (first 4 or first 6 of them) are passed in registers i.e. the
  callee 
 reads them from registers instead of reading them from the stack.
  
 8.2.1 
  
 MSVC
  
 Optimizing MSVC:
  
 Listing 8.4: Optimizing MSVC 2012 x64
  
 $SG2997 DB 
  
 '%d', 0aH, 00H
  
 main 
  
 PROC
  
 sub 
  
 rsp, 40
  
 mov 
  
 edx, 2
  
 lea 
  
 r8d, QWORD PTR [rdx+1] ; R8D=3
  
 lea 
  
 ecx, QWORD PTR [rdx-1] ; ECX=1
  
 call 
  
 f
  
 lea 
  
 rcx, OFFSET FLAT:$SG2997 ; '%d'
  
 mov 
  
 edx, eax
  
 main
  
 call
  
 printf
  
 xor
  
 eax, eax
  
 add
  
 rsp, 40
  
 ret
  
 0
  
 ENDP
  
 f
  
 PROC
  
 ; ECX - 1st argument 
  
 ; EDX - 2nd argument 
  
 ; R8D - 3rd argument 
  
 imul 
  
 ecx, edx",NA
8.3 ,8.3.1,NA
ARM ,"Non-optimizing Keil 6/2013 (ARM mode)
  
   
 .text:000000A4 00 30 A0 E1
  
 MOV
  
 R3, R0
  
 .text:000000A8 93 21 20 E0
  
 MLA
  
 R0, R3, R1, R2
  
 .text:000000AC 1E FF 2F E1
  
 BX
  
 LR
  
 ...
  
 .text:000000B0
  
 main
  
 STMFD
  
 SP!, {R4,LR}
  
 .text:000000B0 10 40 2D E9
  
 .text:000000B4 03 20 A0 E3
  
 MOV
  
 R2, #3
  
 .text:000000B8 02 10 A0 E3
  
 MOV
  
 R1, #2
  
  
 .text:000000BC 01 00 A0 E3
  
 MOV
  
 R0, #1
  
 ; ""%d\n""
  
 .text:000000C0 F7 FF FF EB
  
 BL
  
 f
  
 .text:000000C4 00 40 A0 E1
  
 MOV
  
 R4, R0
  
 .text:000000C8 04 10 A0 E1
  
 MOV
  
 R1, R4
  
 .text:000000CC 5A 0F 8F E2
  
 ADR
  
 R0, aD_0
  
 .text:000000D0 E3 18 00 EB
  
 BL
  
 __2printf
  
 .text:000000D4 00 00 A0 E3
  
 MOV
  
 R0, #0
  
 .text:000000D8 10 80 BD E8
  
 LDMFD
  
 SP!, {R4,PC}
  
  
 The
  main()
  function simply calls two other functions, with three values passed to the first one —(
 f()
 ).
  
 As was noted before, in ARM the first 4 values are usually passed in the first 4 registers (
 R0
 -
 R3
 ).
  
 The
  f()
  function, as it seems, uses the first 3 registers (
 R0
 -
 R2
 ) as arguments.
  
 The
  MLA
  (
 Multiply Accumulate
 ) instruction multiplies its first two operands (
 R3
  and
  R1
 ), adds the third operand (
 R2
 ) to the 
 product and stores the result into the zeroth register (
 R0
 ), via which, by standard, functions return values.
  
 Multiplication and addition at once
 3
 (
 Fused multiply–add
 ) is a very useful operation. By the way, there was no such 
 instruction in x86 before FMA-instructions appeared in SIMD
 4
 .
  
 3
 Wikipedia: Multiply–accumulate operation 
  
 4
 wikipedia",NA
8.4 MIPS,"CHAPTER 8. ACCESSING PASSED ARGUMENTS
  
 Listing 8.10: Optimizing GCC 4.4.5
  
 .text:00000000 f: 
  
 ; $a0=a 
  
 ; $a1=b 
  
 ; $a2=c
  
 .text:00000000
  
 mult
  
 $a1, $a0
  
 ; branch delay slot
  
 .text:00000004
  
 mflo
  
 $v0
  
 .text:00000008
  
 jr
  
 $ra
  
 .text:0000000C
  
 addu
  
 $v0, $a2, $v0
  
 ; result in $v0 upon return
  
 .text:00000010 main: 
  
 .text:00000010 
  
 .text:00000010 var_10 
  
 = -0x10 
  
 .text:00000010 var_4 
  
 = -4 
  
 .text:00000010
  
 .text:00000010
  
 lui
  
 $gp, (__gnu_local_gp >> 16)
  
 .text:00000014
  
 addiu
  
 $sp, -0x20
  
 .text:00000018
  
 la
  
 $gp, (__gnu_local_gp & 0xFFFF)
  
 .text:0000001C
  
 sw
  
 $ra, 0x20+var_4($sp)
  
 .text:00000020
  
 sw
  
 $gp, 0x20+var_10($sp)
  
  
 ; set c:
  
 .text:00000024
  
 li
  
 $a2, 3
  
 ; set a:
  
 .text:00000028
  
 li
  
 $a0, 1
  
 .text:0000002C
  
 jal
  
 f
  
 ; set b:
  
 .text:00000030
  
 li
  
 $a1, 2
  
 ; branch delay slot
  
 ; result in $v0 now
  
 .text:00000034
  
 lw
  
 $gp, 0x20+var_10($sp)
  
 .text:00000038
  
 lui
  
 $a0, ($LC0 >> 16)
  
 .text:0000003C
  
 lw
  
 $t9, (printf & 0xFFFF)($gp)
  
 .text:00000040
  
 la
  
 $a0, ($LC0 & 0xFFFF)
  
 .text:00000044
  
 jalr
  
 $t9
  
 ; take result of f() function and pass it as a second argument to printf():
  
 .text:00000048
  
 move
  
 $a1, $v0
  
 ; branch delay slot
  
 .text:0000004C
  
 lw
  
 $ra, 0x20+var_4($sp)
  
 .text:00000050
  
 move
  
 $v0, $zero
  
 .text:00000054
  
 jr
  
 $ra
  
 .text:00000058
  
 addiu
  
 $sp, 0x20
  
 ; branch delay slot
  
  
 The first four function arguments are passed in four registers prefixed by A-.
  
 There are two special registers in MIPS: HI and LO which are filled with the 64-bit result of the multiplication during the 
 execution of the
  MULT
  instruction. 
  
 These registers are accessible only by using the
  MFLO
  and
  MFHI
  instructions. 
  
 MFLO 
 here takes the low-part of the multiplication result and stores it into $V0. 
  
 So the high 32-bit part of the multiplication 
 result is dropped (the HI register content is not used). Indeed: we work with 32-bit
  int
  data types here.
  
 Finally,
  ADDU
  (“Add Unsigned”) adds the value of the third argument to the result.
  
 There are two different addition instructions in MIPS:
  ADD
  and
  ADDU
 . The difference between them is not related to 
 signed-ness, but to exceptions.
  ADD
  can raise an exception on overflow, which is sometimes useful
 5
 and supported in Ada
  
 PL
 , for instance.
  ADDU
  does not raise exceptions on overflow. 
  
 Since C/C++ does not support this, in our example we see
  
 ADDU 
 instead of
  ADD
 .
  
 The 32-bit result is left in $V0.
  
 There is a new instruction for us in
  main()
 :
  JAL
  (“Jump and Link”). The difference between JAL and JALR is that a relative 
 offset is encoded in the first instruction, while JALR jumps to the absolute address stored in a register (“Jump and Link 
 Register”). Both
  f()
  and
  main()
  functions are located in the same object file, so the relative address of
  f()
  is known and 
 fixed.
  
 5
 http://go.yurichev.com/17326",NA
Chapter 9,NA,NA
More about results returning,"In x86, the result of function execution is usually returned
 1
 in the
  EAX
  register. If it is byte type or a character (
 char
 ), then 
 the lowest part of register
  EAX
  (
 AL
 ) is used. If a function returns a
  float
  number, the FPU register
  ST(0)
  is used instead. In 
 ARM, the result is usually returned in the
  R0
  register.",NA
9.1 ,NA,NA
Attempt to use the result of a function returning,NA,NA
 void,"So, what if the
  main()
  function return value was declared of type
  void
  and not
  int
 ?
  
 The so-called startup-code is calling
  main()
  roughly as follows:
  
 push 
 envp 
  
 push 
 argv 
  
 push argc
  
 call main 
  
 push eax 
  
 call exit
  
 In other words:
  
 exit(main(argc,argv,envp));
  
  
 If you declare
  main()
  as
  void
 , nothing is to be returned explicitly (using the
  return
  statement), then something random, 
 that was stored in the
  EAX
  register at the end of
  main()
  becomes the sole argument of the exit() function. Most likely, 
 there will be a random value, left from your function execution, so the exit code of program is pseudorandom.
  
 We can illustrate this fact. Please note that here the
  main()
  function has a
  void
  return type:
  
 #include <stdio.h> 
  
 void main()
  
 { 
  
 printf (""Hello, world!\n""); 
  
 };
  
 Let’s compile it in Linux.
  
 GCC 4.8.1 replaced
  printf()
  with
  puts()
  (we have seen this before:
  3.4.3 on page 14
 ) , but that’s OK, since
  puts() 
 returns the 
 number of characters printed out, just like
  printf()
 . Please notice that
  EAX
  is not zeroed before
  main()
 ’s end. This implies 
 that the value of
  EAX
  at the end of
  main()
  contains what
  puts()
  has left there.
  
 Listing 9.1: GCC 4.8.1
  
 .LC0: 
  
 .string ""Hello, world!"" 
  
 main: 
  
 push 
  
 ebp
  
 mov 
  
 ebp, esp 
  
 and 
  
 esp, -16 
  
 sub 
  
 esp, 16 
  
 mov 
  
 DWORD PTR [esp], OFFSET FLAT:.LC0
  
 1
 See also: MSDN: Return Values (C++):
  MSDN",NA
9.2 What if we do not use the function result?,"printf()
  returns the count of characters successfully output, but the result of this function is rarely used in practice. It is also 
 possible to call a function whose essence is in returning a value, and not use it:
  
 int f() 
  
 { 
  
  
 // skip first 3 random values 
  
  
 rand(); 
  
  
 rand();
  
  
 rand(); 
  
  
 // and use 4th 
  
  
 return rand(); 
  
 };
  
 The result of the rand() function is left in
  EAX
 , in all four cases. But in the first 3 cases, the value in
  EAX
  is just not used.",NA
9.3 Returning a structure,"Let’s go back to the fact that the return value is left in the
  EAX
  register. That is why old C compilers cannot create functions 
 capable of returning something that does not fit in one register (usually
  int
 ), but if one needs it, one have to return 
 information via pointers passed as function’s arguments. So, usually, if a function needs to return several values, it returns 
 only one, and all the rest—via pointers. Now it has become possible to return, let’s say, an entire structure, but that is still 
 not very popular. If a function has to return a large structure, the
  caller
  must allocate it and pass a pointer to it via the first 
 argument, transparently for the programmer. That is almost the same as to pass a pointer in the first argument manually, 
 but the compiler hides it.
  
 Small example:
  
 struct s 
  
 { 
  
  
 int a; 
  
  
 int b; 
  
  
 int c; 
  
 };
  
 struct s get_some_values (int a) 
  
 {
  
 struct s rt;
  
 rt.a=a+1; 
  
 rt.b=a+2; 
  
 rt.c=a+3;
  
  
 return rt; 
  
 };",NA
Chapter 10,NA,NA
Pointers,"Pointers are often used to return values from functions (recall
  scanf()
  case (
  7 on page 58
 )). For example, when a function
  
 needs to return two values.",NA
10.1,NA,NA
Global variables example,"#include <stdio.h>
  
 void f1 (int x, int y, int *sum, int *product) 
  
 { 
  
 *sum=x+y; 
  
 *product=x*y; 
  
 };
  
 int sum, product;
  
 void main() 
  
 { 
  
 f1(123, 456, &sum, &product); 
  
 printf (""sum=%d, product=%d\n"", sum, product); };
  
 This compiles to:
  
 Listing 10.1: Optimizing MSVC 2010 (/Ob0)
  
 COMM 
  
 _product:DWORD
  
 COMM 
  
 _sum:DWORD
  
 $SG2803 DB 
  
 'sum=%d, product=%d', 0aH, 00H
  
 _x$ = 8 
  
 ; size = 4
  
 _y$ = 12 
  
 ; size = 4
  
 _sum$ = 16 
  
 ; size = 4
  
 _product$ = 20 
  
 ; size = 4
  
 _f1 PROC
  
 mov 
  
 ecx, DWORD PTR _y$[esp-4]
  
 mov 
  
 eax, DWORD PTR _x$[esp-4]
  
 lea 
  
 edx, DWORD PTR [eax+ecx]
  
 imul 
  
 eax, ecx
  
 _f1
  
 mov
  
 ecx, DWORD PTR _product$[esp-4]
  
 ; 000001c8H
  
 push
  
 esi
  
 mov
  
 esi, DWORD PTR _sum$[esp]
  
 mov
  
 DWORD PTR [esi], edx
  
 mov
  
 DWORD PTR [ecx], eax
  
 pop
  
 esi
  
 ret
  
 0
  
 ENDP
  
 _main
  
 PROC
  
 OFFSET _product
  
 push
  
 push
  
 OFFSET _sum
  
 push
  
 456
  
  
 100",NA
10.2 ,NA,NA
Local variables example,"Let’s rework our example slightly:
  
 Listing 10.2: now the
  sum
  and
  product
  variables are local
  
 void main() 
  
 { 
  
 int sum, product; // now variables are local in this function
  
 f1(123, 456, &sum, &product); 
  
 printf (""sum=%d, product=%d\n"", sum, product); };
  
 f1()
  code will not change. Only the code of
  main()
  will do:
  
 Listing 10.3: Optimizing MSVC 2010 (/Ob0)
  
 _product$ = -8 
  
  
 ; size = 4 
 _sum$ = -4 
  
  
 ; size = 4 
 _main 
  
 PROC 
  
 ; Line 10 
  
  
 sub 
  
  
 esp, 8 ; Line 13
  
 lea
  
 eax, DWORD PTR _product$[esp+8]
  
 ; 000001c8H
  
 push
  
 eax
  
 lea
  
 ecx, DWORD PTR _sum$[esp+12]
  
 push
  
 ecx
  
 push
  
 456
  
 push
  
 123
  
 ; 0000007bH
  
  
 call 
  
 _f1 
  
 ; Line 14 
  
 mov 
  
 edx, DWORD PTR _product$[esp+24] 
  
 mov 
  
 eax, DWORD PTR _sum$[esp+24] 
  
 push 
  
  
 edx push 
  
 eax 
  
 push 
  
 OFFSET $SG2803 
  
 call 
  
 DWORD PTR __imp__printf 
  
 ; Line 15
  
 xor
  
 eax, eax
  
 ; 00000024H
  
 add
  
 esp, 36
  
 ret
  
 0
  
  
 106",NA
10.3 ,NA,NA
Conclusion,"f1()
  could return pointers to any place in memory, located anywhere. This is in essence the usefulness of the pointers.
  
 By the way, C++
  references
  work exactly the same way. Read more about them: (
  51.3 on page 538
 ).
  
 109",NA
Chapter 11,NA,NA
GOTO operator,"The GOTO operator is generally considered as anti-pattern. [
 Dij68
 ], Nevertheless, it can be used reasonably [
 Knu74
 ], [
 Yur13
 ,
  
 p. 1.3.2].
  
 Here is a very simple example:
  
 #include <stdio.h>
  
 int main() 
  
 { 
  
 printf (""begin\n"");
  
 goto exit; 
  
 printf (""skip me!\n""); 
  
 exit: 
  
 printf (""end\n""); 
  
 };
  
 Here is what we have got in MSVC 2012:
  
 Listing 11.1: MSVC 2012
  
 $SG2934 DB 
  
 'begin', 0aH, 00H 
  
 $SG2936 DB 
  
 'skip me!', 0aH, 00H 
  
 $SG2937 DB 
  
 'end', 0aH, 00H
  
 _main 
  
 PROC 
  
  
 push 
  
 ebp 
  
  
 mov 
  
 ebp, esp 
  
  
 push 
  
 OFFSET $SG2934 ; 'begin' 
  
  
 call 
  
 _printf 
  
  
 add 
  
 esp, 4 
  
  
 jmp 
  
 SHORT $exit$3
  
 push 
  
 OFFSET $SG2936 ; 'skip me!'
  
 call 
  
 _printf
  
 add 
  
 esp, 4
  
 $exit$3:
  
 _main
  
 push
  
 OFFSET $SG2937 ; 'end'
  
 call
  
 _printf
  
 add
  
 esp, 4
  
 xor
  
 eax, eax
  
 pop
  
 ebp
  
 ret
  
 0
  
 ENDP
  
  
 The
  goto
  statement has been simply replaced by a
  JMP
  instruction, which has the same effect: unconditional jump to 
 another
  
 place. The second
  printf()
  could be executed only with human intervention, by using a debugger or by patching the code.",NA
11.1,NA,NA
Dead code,"The second
  printf()
  call is also called “dead code” in compiler terms. This means that the code will never be executed. So 
 when you compile this example with optimizations, the compiler removes “dead code”, leaving no trace of it: 
  
 Listing 
 11.2: Optimizing MSVC 2012
  
 $SG2981 DB 
  
 'begin', 0aH, 00H 
  
 $SG2983 DB 
  
 'skip me!', 0aH, 00H 
  
 $SG2984 DB 
  
 'end', 0aH, 00H
  
 _main 
  
 PROC 
  
  
 push 
  
 OFFSET $SG2981 ; 'begin' 
  
  
 call 
  
 _printf
  
 push 
  
 OFFSET $SG2984 ; 'end'
  
 $exit$4:
  
 _main
  
 call
  
 _printf
  
 add
  
 esp, 8
  
 xor
  
 eax, eax
  
 ret
  
 0
  
 ENDP
  
  
 However, the compiler forgot to remove the “skip me!” string.
  
 112",NA
11.2 ,NA,NA
Exercise,"CHAPTER 11. GOTO OPERATOR
  
 Try to achieve the same result using your favorite compiler and debugger.
  
 113",NA
Chapter 12,NA,NA
Conditional jumps,NA,NA
12.1,NA,NA
Simple example,"#include <stdio.h>
  
 void f_signed (int a, int b) 
  
 { 
  
  
 if (a>b) 
  
  
 printf (""a>b\n""); 
  
  
 if (a==b) 
  
  
 printf (""a==b\n""); 
  
  
 if (a<b) 
  
  
 printf (""a<b\n""); 
  
 };
  
 void f_unsigned (unsigned int a, unsigned int b) 
  
 {
  
  
 if (a>b) 
  
  
 printf (""a>b\n""); 
  
  
 if (a==b) 
  
  
 printf (""a==b\n""); 
  
  
 if (a<b) 
  
  
 printf (""a<b\n""); 
  
 };
  
 int main() 
  
 { 
  
  
 f_signed(1, 2); 
  
  
 f_unsigned(1, 2); 
  
  
 return 0; 
  
 };
  
  
 12.1.1
  
 x86
  
 x86 + MSVC
  
 Here is how the
  f_signed()
  function looks like:
  
 Listing 12.1: Non-optimizing MSVC 2010
  
 _a$ = 8 
  
 _b$ = 12 
  
 _f_signed PROC 
  
  
 push 
  
 ebp 
  
  
 mov 
  
 ebp, esp 
  
  
 mov 
  
 eax, DWORD PTR _a$[ebp]
  
 mov 
  
 eax, DWORD PTR _a$[ebp]
  
 cmp 
  
 eax, DWORD PTR _b$[ebp]
  
 jle 
  
 SHORT $LN3@f_signed
  
 push 
  
 OFFSET $SG737 
  
 ; 'a>b'
  
 call 
  
 _printf
  
 add 
  
 esp, 4
  
 114",NA
12.2 ,NA,NA
Calculating absolute value,"CHAPTER 12. CONDITIONAL JUMPS
  
 A simple function:
  
 int my_abs (int i) 
  
 { 
  
 if (i<0) 
  
  
  
 return -i;
  
 else 
  
  
  
 return i; 
  
 };
  
  
 12.2.1
  
 Optimizing MSVC
  
 This is how the code is usually generated: 
  
 Listing 12.13: Optimizing MSVC 2012 x64
  
 i$ = 8 
  
 my_abs 
  
 PROC 
  
 ; ECX = input 
  
  
 test 
  
 ecx, ecx 
  
 ; check for sign of input value 
  
 ; skip NEG instruction if sign is positive 
  
  
 jns 
  
 SHORT $LN2@my_abs
  
 ; negate value 
  
 neg 
  
 ecx 
  
 $LN2@my_abs: 
  
 ; prepare result in EAX:
  
 my_abs
  
 mov
  
 eax, ecx
  
 ret
  
 0
  
 ENDP
  
  
 GCC 4.9 does mostly the same.
  
 12.2.2 
  
 Optimizing Keil 6/2013: Thumb mode
  
 Listing 12.14: Optimizing Keil 6/2013: Thumb mode
  
 my_abs PROC 
  
 CMP 
  
 r0,#0 
  
 ; is input value equal to zero or greater than zero?
  
 ; skip RSBS instruction then 
  
 BGE 
  
 |L0.6|
  
 ; subtract input value from 0: 
  
 RSBS 
  
 r0,r0,#0 
  
 |L0.6| 
  
 BX 
  
 lr 
  
 ENDP
  
 ARM lacks a negate instruction, so the Keil compiler uses the “Reverse Subtract” instruction, which just subtracts with 
 reversed operands.
  
 12.2.3 
  
 Optimizing Keil 6/2013: ARM mode
  
 It is possible to add condition codes to some instructions in ARM mode, so that is what the Keil compiler 
 does: 
  
 Listing 12.15: Optimizing Keil 6/2013: ARM mode
  
 my_abs PROC 
  
 CMP 
  
 r0,#0 
  
 ; execute ""Reverse Subtract"" instruction only if input value is less than 0:
  
 RSBLT 
  
 r0,r0,#0 
  
 BX 
  
 lr 
  
 ENDP
  
 Now there are no conditional jumps and this is good:
  33.1 on page 436
 .
  
 131",NA
12.3 ,NA,NA
Ternary conditional operator,"The ternary conditional operator in C/C++ has the following syntax:
  
 expression ? expression : expression
  
  
 Here is an example:
  
 const char* f (int a) 
  
 { 
  
 return a==10 ? ""it is ten"" : ""it is not ten""; };
  
  
 132",NA
12.4 ,NA,NA
Getting minimal and maximal values,"CHAPTER 12. CONDITIONAL JUMPS
  
 12.4.1
  
 32-bit
  
  
 int my_max(int a, int b) 
  
 { 
  
 if (a>b) 
  
  
  
 return a; 
  
 else 
  
  
  
 return b; 
  
 };
  
 int my_min(int a, int b) 
  
 { 
  
 if (a<b) 
  
  
  
 return a; 
  
 else 
  
  
  
 return b; 
  
 };
  
 Listing 12.26: Non-optimizing MSVC 2013
  
 _a$ = 8 
  
 _b$ = 12 
  
 _my_min PROC 
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 mov 
  
  
 eax, DWORD PTR _a$[ebp] ; compare A and B: 
  
 cmp 
  
 eax, DWORD PTR _b$[ebp] 
  
 ; jump, if A is greater or equal to B: 
  
 jge 
  
 SHORT $LN2@my_min 
  
 ; reload A to EAX if otherwise and jump to exit 
  
 mov 
  
 eax, DWORD PTR _a$[ebp] 
  
 jmp 
  
 SHORT $LN3@my_min 
  
 jmp 
  
 SHORT $LN3@my_min ; this is redundant JMP $LN2@my_min: 
  
 ; return B 
  
 mov 
  
 eax, DWORD PTR _b$[ebp] 
  
 $LN3@my_min: 
  
 pop 
  
 ebp 
  
 ret 
  
 0 
  
 _my_min ENDP
  
 _a$ = 8 
  
 _b$ = 12 
  
 _my_max PROC 
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 mov 
  
  
 eax, DWORD PTR _a$[ebp] ; compare A and B: 
  
 cmp 
  
 eax, DWORD PTR _b$[ebp] 
  
 ; jump if A is less or equal to B: 
  
 jle 
  
 SHORT $LN2@my_max 
  
 ; reload A to EAX if otherwise and jump to exit 
  
 mov 
  
 eax, DWORD PTR _a$[ebp] 
  
 jmp 
  
 SHORT $LN3@my_max 
  
 jmp 
  
 SHORT $LN3@my_max ; this is redundant JMP $LN2@my_max: 
  
 ; return B 
  
 mov 
  
 eax, DWORD PTR _b$[ebp] 
  
 $LN3@my_max: 
  
 pop 
  
 ebp 
  
 ret 
  
 0 
  
 _my_max ENDP
  
 These two functions differ only in the conditional jump instruction: JGE (“Jump if Greater or Equal”) is used in the first one 
 and JLE (“Jump if Less or Equal”) in the second.
  
 136",NA
12.5 ,NA,NA
Conclusion,"12.5.1 
  
 x86
  
 Here’s the rough skeleton of a conditional jump:
  
 Listing 12.34: x86
  
 CMP register, register/value 
  
 Jcc true ; cc=condition code 
  
 false: 
  
 ... some code to be executed if comparison result is false ...
  
 JMP exit 
  
 true: 
  
 ... some code to be executed if comparison result is true ...
  
 exit:
  
  
 12.5.2
  
 ARM
  
 Listing 12.35: ARM
  
 CMP register, register/value 
  
 Bcc true ; cc=condition code 
  
 false: 
  
 ... some code to be executed if comparison result is false ...
  
 JMP exit 
  
 true: 
  
 ... some code to be executed if comparison result is true ...
  
 exit:
  
 140",NA
12.6,NA,NA
Exercise,"(ARM64) Try rewriting the code in listing.
 12.23
  by removing all conditional jump instructions and using the
  CSEL
  instruction.",NA
Chapter 13,NA,NA
switch()/case/default,NA,NA
13.1,NA,NA
Small number of cases,"#include <stdio.h>
  
 void f (int a) 
  
 { 
  
  
 switch (a) 
  
  
 { 
  
  
 case 0: printf (""zero\n""); break; 
  
  
 case 1: printf (""one\n""); break; 
  
  
 case 2: printf (""two\n""); break;
  
  
 default: printf (""something unknown\n""); break; 
  
 }; 
  
 };
  
 int main() 
  
 { 
  
  
 f (2); // test 
  
 };
  
  
 13.1.1
  
 x86
  
 Non-optimizing MSVC
  
 Result (MSVC 2010):
  
 Listing 13.1: MSVC 2010
  
 tv64 = -4 ; size = 4 
  
 _a$ = 8 
  
 ; size = 4 
  
 _f 
  
  
 PROC 
  
  
 push 
   
 ebp 
  
  
 mov 
  
  
  
 ebp, esp 
  
 push 
  
  
 ecx 
  
  
 mov 
  
  
 eax, DWORD PTR _a$[ebp] 
  
  
 mov 
  
  
 DWORD PTR tv64[ebp], eax 
  
  
 cmp 
  
  
  
 DWORD PTR tv64[ebp], 0 
  
 je 
  
  
 SHORT $LN4@f 
  
  
 cmp 
  
  
 DWORD PTR tv64[ebp], 1
  
  
 je 
  
 SHORT $LN3@f 
  
  
 cmp 
  
 DWORD PTR tv64[ebp], 2 
  
  
 je 
  
 SHORT $LN2@f 
  
  
 jmp 
  
 SHORT $LN1@f 
  
 $LN4@f: 
  
  
 push 
  
 OFFSET $SG739 ; 'zero', 0aH, 00H 
  
  
 call 
  
 _printf 
  
  
 add 
  
 esp, 4 
  
  
 jmp 
  
  
 SHORT $LN7@f $LN3@f: 
  
  
 push 
  
 OFFSET $SG741 ; 'one', 0aH, 00H
  
 142",NA
13.2 ,NA,NA
A lot of cases,"If a
  switch()
  statement contains a lot of cases, it is not very convenient for the compiler to emit too large code with a lot 
 JE
 /
 JNE
  instructions.
  
 #include <stdio.h>
  
 void f (int a) 
  
 { 
  
  
 switch (a) 
  
  
 { 
  
  
 case 0: printf (""zero\n""); break; 
  
  
 case 1: printf (""one\n""); break; 
  
  
 case 2: printf (""two\n""); break; 
  
  
 case 3: printf (""three\n""); break;
  
  
 case 4: printf (""four\n""); break; 
  
  
 default: printf (""something unknown\n""); break; 
  
 }; 
  
 };
  
 int main() 
  
 { 
  
  
 f (2); // test 
  
 };
  
  
 13.2.1
  
 x86
  
 Non-optimizing MSVC
  
 We get (MSVC 2010):",NA
13.3 ,NA,NA
When there are several,NA,NA
 case,NA,NA
 statements in one block ,"Here is a very widespread construction: several
  case
  statements for a single block:
  
 #include <stdio.h>
  
 void f(int a) 
  
 { 
  
 switch (a) 
  
 { 
  
 case 1: 
  
 case 2: 
  
 case 7: 
  
 case 10: 
  
  
  
 printf (""1, 2, 7, 10\n""); 
  
  
  
 break; 
  
 case 3: 
  
 case 4: 
  
 case 5: 
  
 case 6: 
  
  
  
 printf (""3, 4, 5\n""); 
  
  
  
 break; 
  
 case 8:
  
 case 9: 
  
 case 20: 
  
 case 21: 
  
  
  
 printf (""8, 9, 21\n""); 
  
  
  
 break; 
  
 case 22: 
  
  
  
 printf (""22\n""); 
  
  
  
 break; 
  
 default: 
  
  
  
 printf (""default\n""); 
  
  
  
 break; 
  
 }; 
  
 };
  
 int main() 
  
 { 
  
 f(4); 
  
 };
  
 It’s too wasteful to generate a block for each possible case, so what is usually done is to generate each block plus some 
 kind of dispatcher.
  
 13.3.1 
  
 MSVC 
  
  
  
 Listing 13.10: Optimizing MSVC 2010
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1 
 1
 2 
 1
 3 
 1
 $SG2798 DB 
  
 '1, 2, 7, 10', 0aH, 00H
  
 $SG2800 DB 
  
 '3, 4, 5', 0aH, 00H
  
 $SG2802 DB 
  
 '8, 9, 21', 0aH, 00H
  
 $SG2804 DB 
  
 '22', 0aH, 00H
  
 $SG2806 DB 
  
 'default', 0aH, 00H
  
 _a$ = 8
  
 _f PROC
  
 mov 
  
 eax, DWORD PTR _a$[esp-4] 
  
 dec 
  
 eax 
  
 cmp 
  
 eax, 21 
  
 ja 
  
 SHORT $LN1@f 
  
 movzx 
  
 eax, BYTE PTR $LN10@f[eax] 
  
 jmp 
  
 DWORD PTR $LN11@f[eax*4] 
  
 $LN5@f: 
  
 mov 
  
 DWORD PTR _a$[esp-4], OFFSET $SG2798 ; '1, 2, 7, 10'
  
  
 167",NA
13.4 ,NA,NA
Fall-through,"Another very popular usage of
  switch()
  is the fall-through. Here is a small example:
  
 1
  
  
 2
  
  
 3
  
 #define 
 R 
 1 
  
 #define 
 W 
 2 
  
 #define RW 3
  
  
 170",NA
13.5 ,NA,NA
Exercises,"13.5.1 
  
 Exercise #1
  
 It’s possible to rework the C example in
  13.2 on page 155
  in such way that the compiler can produce even smaller code, 
 but will work just the same. Try to achieve it.
  
 172",NA
Chapter 14,NA,NA
Loops,NA,NA
14.1 ,NA,NA
Simple example,"14.1.1 
  
 x86
  
 There is a special
  LOOP
  instruction in x86 instruction set for checking the value in register
  ECX
  and if it is not 0, to
  
 decrement 
 ECX
  and pass control flow to the label in the
  LOOP
  operand. Probably this instruction is not very convenient, 
 and there are no any modern compilers which emit it automatically. So, if you see this instruction somewhere in code, it is 
 most likely that this is a manually written piece of assembly code.
  
 In C/C++ loops are usually constructed using
  for()
 ,
  while()
  or
  do/while()
  statements.
  
 Let’s start with
  for()
 .
  
 This statement defines loop initialization (set loop counter to initial value), loop condition (is the counter bigger than a 
 limit?), what is done at each iteration (
 increment
 /
 decrement
 ) and of course loop body.
  
 for (initialization; condition; at each iteration) {
  
  
 loop_body; 
  
 }
  
 The generated code is consisting of four parts as well. 
  
 Let’s start with a simple example:
  
 #include <stdio.h>
  
 void printing_function(int i) 
  
 { 
  
 printf (""f(%d)\n"", i); 
  
 };
  
 int main()
  
 { 
  
 int i;
  
 for (i=2; i<10; i++) 
  
  
 printing_function(i);
  
 return 0; 
  
 };
  
 Result (MSVC 2010):
  
 Listing 14.1: MSVC 2010
  
 _i$ = -4 
  
 _main 
  
 PROC 
  
  
 push 
   
 ebp
  
 mov
  
 ebp, esp
  
 ; loop initialization
  
 push
  
 ecx
  
 mov
  
 DWORD PTR _i$[ebp], 2
  
 jmp
  
 SHORT $LN3@main",NA
14.2 ,NA,NA
Memory blocks copying routine,"Real-world memory copy routines may copy 4 or 8 bytes at each iteration, use
  SIMD
 2
 , vectorization, etc. But for the sake of 
 simplicity, this example is the simplest possible.
  
 #include <stdio.h> 
  
 void my_memcpy (unsigned char* dst, unsigned char* src, size_t cnt) {
  
 size_t i; 
  
 for (i=0; i<cnt; i++) 
  
  
  
 dst[i]=src[i]; 
  
 };
  
  
 14.2.1
  
 Straight-forward implementation
  
 Listing 14.10: GCC 4.9 x64 optimized for size (-Os)
  
 my_memcpy: 
  
 ; RDI = destination address 
  
 ; RSI = source address 
  
 ; RDX = size of block
  
 ; initialize counter (i) at 0 
  
 xor 
  
 eax, eax 
  
 .L2: 
  
 ; all bytes copied? exit then: 
  
 cmp 
  
 rax, rdx 
  
 je 
  
  
 .L5 ; load byte at RSI+i: 
  
 mov 
  
 cl, BYTE PTR [rsi+rax]
  
  
 2
 Single instruction, multiple data",NA
14.3 ,NA,NA
Conclusion,"CHAPTER 14. LOOPS
  
 Rough skeleton of loop from 2 to 9 inclusive: 
  
  
 Listing 14.15: x86
  
  
 mov [counter], 2 ; initialization 
  
  
 jmp check 
  
 body: 
  
  
 ; loop body 
  
  
 ; do something here
  
  
 ; use counter variable in local stack 
  
  
 add [counter], 1 ; increment 
  
 check: 
  
  
 cmp [counter], 9 
  
  
 jle body
  
 The increment operation may be represented as 3 instructions in non-optimized code: 
  
 Listing 14.16: x86
  
  
 MOV [counter], 2 ; initialization 
  
  
 JMP check 
  
 body: 
  
  
 ; loop body 
  
  
 ; do something here 
  
  
 ; use counter variable in local stack
  
  
 MOV REG, [counter] ; increment 
  
  
 INC REG 
  
  
 MOV [counter], REG 
  
 check: 
  
  
 CMP [counter], 9 
  
  
 JLE body
  
 If the body of the loop is short, a whole register can be dedicated to the counter variable: 
  
 Listing 14.17: x86
  
  
 MOV EBX, 2 ; initialization 
  
  
 JMP check 
  
 body: 
  
  
 ; loop body 
  
  
 ; do something here
  
  
 ; use counter in EBX, but do not modify it! 
  
  
 INC EBX ; increment 
  
 check: 
  
  
 CMP EBX, 9 
  
  
 JLE body
  
 Some parts of the loop may be generated by compiler in different 
 order: 
  
 Listing 14.18: x86
  
  
 MOV [counter], 2 ; initialization 
  
  
 JMP label_check 
  
 label_increment: 
  
  
 ADD [counter], 1 ; increment 
  
 label_check: 
  
  
 CMP [counter], 10
  
  
 JGE exit 
  
  
 ; loop body 
  
  
 ; do something here 
  
  
 ; use counter variable in local stack 
  
  
 JMP label_increment 
  
  
 exit:
  
 Usually the condition is checked
  before
  loop body, but the compiler may rearrange it in a way that the condition is checked
  
 after
  loop body.
  
 This is done when the compiler is sure that the condition is always
  true
  on the first iteration, so the body
  
 of the loop is to be executed at least once:
  
 186",NA
14.4,NA,NA
Exercises,"•
  http://challenges.re/54
  
 •
  http://challenges.re/55
  
 •
  http://challenges.re/56
  
 •
  http://challenges.re/57",NA
Chapter 15,NA,NA
Simple C-strings processing,NA,NA
15.1 ,NA,NA
strlen(),"Let’s talk about loops one more time. Often, the
  strlen()
  function
 1
 is implemented using a
  while()
  statement. Here is how it 
 is done in the MSVC standard libraries:
  
 int my_strlen (const char * str) 
  
 { 
  
 const char *eos = str;
  
 while( *eos++ ) ;
  
 return( eos - str - 1 );
  
 }
  
 int main() 
  
 { 
  
 // test 
  
 return my_strlen(""hello!""); 
  
 };
  
  
 15.1.1
  
 x86
  
 Non-optimizing MSVC
  
 Let’s compile:
  
 _eos$ = -4 
  
 ; size = 4 
  
 _str$ = 8 
  
 ; size = 4 
  
 _strlen PROC
  
 push
  
 ebp
  
 ; place pointer to string from ""str""
  
 mov
  
 ebp, esp
  
 push
  
 ecx
  
 mov
  
 eax, DWORD PTR _str$[ebp]
  
 mov
  
 DWORD PTR _eos$[ebp], eax
  
 ; place it to local variable ""eos""
  
 $LN2@strlen_:
  
 mov
  
 ecx, DWORD PTR _eos$[ebp]
  
 ; ECX=eos
  
  
 ; take 8-bit byte from address in ECX and place it as 32-bit value to EDX with sign extension
  
 movsx
  
 edx, BYTE PTR [ecx]
  
 ; EAX=eos
  
 mov
  
 eax, DWORD PTR _eos$[ebp]
  
 add
  
 eax, 1
  
 ; increment EAX
  
 mov
  
 DWORD PTR _eos$[ebp], eax
  
 ; place EAX back to ""eos""
  
 test
  
 edx, edx
  
 ; EDX is zero?
  
 je
  
 SHORT $LN1@strlen_
  
 ; yes, then finish loop
  
 jmp
  
 SHORT $LN2@strlen_
  
 ; continue loop
  
 $LN1@strlen_:
  
 1
 counting the characters in a string in the C language
  
 188",NA
Chapter 16,NA,NA
Replacing arithmetic instructions to other ones,"In the pursuit of optimization, one instruction may be replaced by another, or even with a group of instructions.
  
 For example,
  ADD
  and
  SUB
  can replace each other: line 18 in listing.
 52.1
 .
  
 For example, the
  LEA
  instruction is often used for simple arithmetic calculations:
  A.6.2 on page 887
 .",NA
16.1 ,NA,NA
Multiplication,"16.1.1 
  
 Multiplication using addition
  
 Here is a simple example:
  
 Listing 16.1: Optimizing MSVC 2010
  
 unsigned int f(unsigned int a) 
  
 {
  
 return a*8; 
  
 };
  
  
 Multiplication by 8 is replaced by 3 addition instructions, which do the same. 
 this code can be faster.
  
 Apparently, MSVC’s optimizer decided that
  
  
 _TEXT
  
 SEGMENT
  
 ; size = 4
  
 _a$ = 8
  
 PROC
  
 _f
  
 ; File c:\polygon\c\2.c 
  
 mov 
  
 eax, DWORD PTR _a$[esp-4] 
  
 add 
  
 eax, eax
  
 _f
  
 add
  
 eax, eax
  
 add
  
 eax, eax
  
 ret
  
 0
  
 ENDP
  
 _TEXT
  
 ENDS
  
 END
  
  
 16.1.2
  
 Multiplication using shifting
  
 Multiplication and division instructions by a numbers that’s a power of 2 are often replaced by shift instructions.
  
 unsigned int f(unsigned int a) 
  
 {
  
 return a*4; 
  
 };
  
 Listing 16.2: Non-optimizing MSVC 2010
  
  
 _a$ = 8
  
 PROC
  
 ; size = 4
  
 _f
  
 ebp
  
 push
  
  
  
 199",NA
16.2 ,16.2.1,NA
Division ,"Division using shifts
  
 Example of division by 4:
  
 unsigned int f(unsigned int a) 
  
 {
  
 return a/4; 
  
 };
  
 We get (MSVC 2010): 
  
  
 Listing 16.11: MSVC 2010
  
 _a$ = 8
  
 PROC
  
 eax, DWORD PTR _a$[esp-4]
  
 ; size = 4
  
 _f
  
 mov
  
  
 _f
  
 shr
  
 eax, 2
  
 ret
  
 0
  
 ENDP
  
  
 The
  SHR
  (
 SHift Right
 ) instruction in this example is shifting a number by 2 bits to the right. The two freed bits at left (e.g., 
 two most significant bits) are set to zero. The two least significant bits are dropped. In fact, these two dropped bits are the 
 division operation remainder.
  
 The
  SHR
  instruction works just like
  SHL
 , but in the other direction.
  
 0
  
 7
  
 6
  
 5
  
 4
  
 3
  
 2
  
 1
  
 0
  
 CF
  
 7
  
 6
  
 5
  
 4
  
 3
  
 2
  
 1
  
 0
  
 It is easy to understand if you imagine the number 23 in the decimal numeral system. 23 can be easily divided by 10 just by 
 dropping last digit (3—division remainder). 2 is left after the operation as a
  quotient
 .
  
 So the remainder is dropped, but that’s OK, we work on integer values anyway, these are not a
  real numbers
 !
  
 Division by 4 in ARM: 
  
  
 Listing 16.12: Non-optimizing Keil 6/2013 (ARM mode)
  
 f PROC 
  
 LSR 
  
 r0,r0,#2
  
 BX 
  
 lr
  
 ENDP
  
 Division by 4 in MIPS: 
  
  
 Listing 16.13: Optimizing GCC 4.4.5 (IDA)
  
 jr 
  
 $ra
  
 srl 
  
 $v0, $a0, 2 ; branch delay slot
  
 The SRL instruction is “Shift Right Logical”.",NA
16.3 ,NA,NA
Exercise,"•
  http://challenges.re/59",NA
Chapter 17,NA,NA
Floating-point unit,"The
  FPU
  is a device within the main
  CPU
 , specially designed to deal with floating point numbers. It was called 
 “coprocessor”in the past and it stays somewhat aside of the main
  CPU
 .",NA
17.1 IEEE 754,"A number in the IEEE 754 format consists of a
  sign
 , a
  significand
  (also called
  fraction
 ) and an
  exponent
 .",NA
17.2 x86,"It is worth looking into stack machines
 1
 or learning the basics of the Forth language
 2
 , before studying the
  FPU
  in x86.
  
 It is interesting to know that in the past (before the 80486 CPU) the coprocessor was a separate chip and it was not 
 always pre-installed on the motherboard. It was possible to buy it separately and install it
 3
 . Starting with the 80486 DX 
 CPU, the 
 FPU
  is integrated in the
  CPU
 .
  
 The
  FWAIT
  instruction reminds us of that fact—it switches the
  CPU
  to a waiting state, so it can wait until the
  FPU
  is done 
 with its work. Another rudiment is the fact that the
  FPU
  instruction opcodes start with the so called “escape”-opcodes 
 (
 D8..DF
 ), i.e., opcodes passed to a separate coprocessor.
  
 The FPU has a stack capable to holding 8 80-bit registers, and each register can hold a number in the IEEE 754
 4
 format. 
  
 They 
 are
  ST(0)
 ..
 ST(7)
 . For brevity, IDA and OllyDbg show
  ST(0)
  as
  ST
 , which is represented in some textbooks and manuals as 
 “Stack Top”.",NA
"17.3 ARM, MIPS, x86/x64 SIMD","In ARM and MIPS the FPU is not a stack, but a set of registers. The same ideology is used in the SIMD extensions of 
 x86/x64 CPUs.",NA
17.4 C/C++,"The standard C/C++ languages offer at least two floating number types,
  float
  (
 single-precision
 5
 , 32 bits)
 6
 and
  double
  (
 double-
 precision
 7
 , 64 bits).
  
 GCC also supports the
  long double
  type (
 extended precision
 8
 , 80 bit), which MSVC doesn’t.
  
  
 1
 wikipedia.org/wiki/Stack_machine 
  
  
 2
 wikipedia.org/wiki/Forth_(programming_language) 
  
  
 3
 For example, John Carmack used fixed-point arithmetic (
 wikipedia.org/wiki/Fixed-point_arithmetic
 ) values in his Doom video game, stored in 32-bit 
 GPR
  registers (16 bit for integral part and another 16 bit for fractional part), so Doom could work on 32-bit computers without FPU, i.e., 80386 and 80486 
 SX.
  
 4
 wikipedia.org/wiki/IEEE_floating_point 
  
 5
 wikipedia.org/wiki/Single-precision_floating-point_format 
  
 6
 the single precision floating point number format is also addressed in the
  Working with the float type as with a structure
  (
  21.6.2 on page 355
 ) 
 section 
 7
 wikipedia.org/wiki/Double-precision_floating-point_format 
  
 8
 wikipedia.org/wiki/Extended_precision",NA
17.5 Simple example,"Let’s consider this simple example:
  
 #include <stdio.h>
  
 double f (double a, double b) 
  
 { 
  
 return a/3.14 + b*4.1; 
  
 };
  
 int main() 
  
 { 
  
 printf (""%f\n"", f(1.2, 3.4)); 
  
 };
  
  
 17.5.1
  
 x86
  
 MSVC
  
 Compile it in MSVC 2010:
  
 Listing 17.1: MSVC 2010:
  f()
  
 CONST 
  
 SEGMENT 
  
 __real@4010666666666666 DQ 04010666666666666r 
  
 ; 4.1 
 CONST 
  
 ENDS 
  
 CONST 
  
 SEGMENT 
  
 __real@40091eb851eb851f DQ 040091eb851eb851fr 
  
 ; 3.14 
 CONST 
  
 ENDS 
  
 _TEXT 
  
 SEGMENT 
  
 _a$ = 8 
  
   
 ; size = 8 
  
 _b$ = 16 
  
   
 ; size = 8 
  
 _f 
  
 PROC 
  
  
 push 
   
 ebp 
  
  
 mov 
   
 ebp, esp 
  
  
 fld 
  
  
 QWORD PTR _a$[ebp]
  
 ; current stack state: ST(0) = _a
  
 fdiv 
  
 QWORD PTR __real@40091eb851eb851f
  
 ; current stack state: ST(0) = result of _a divided by 3.14
  
  
 fld 
  
 QWORD PTR _b$[ebp] 
  
 ; current stack state: ST(0) = _b; ST(1) = result of _a divided by 3.14 
  
 fmul 
  
 QWORD PTR 
 __real@4010666666666666 
  
 ; current stack state: 
  
 ; ST(0) = result of _b * 4.1; 
  
 ; ST(1) = result of _a divided by 3.14 
  
  
 faddp 
  
 ST(1), ST(0) 
  
 ; current stack state: ST(0) = result of addition
  
 _f
  
 pop
  
 ebp
  
 ret
  
 0
  
 ENDP
  
  
 206",NA
17.6,NA,NA
Passing floating point numbers via arguments,"11
 dennis(a)yurichev.com
  
 216",NA
17.7 Comparison example,"CHAPTER 17. FLOATING-POINT UNIT
  
 Let’s try this:
  
 #include <stdio.h>
  
 double d_max (double a, double b) 
  
 { 
  
 if (a>b) 
  
  
  
 return a;
  
 return b;
  
 };
  
 int main() 
  
 { 
  
 printf (""%f\n"", d_max (1.2, 3.4)); 
  
 printf (""%f\n"", d_max (5.6, -4)); 
  
 };
  
 Despite the simplicity of the function, it will be harder to understand how it works.
  
 17.7.1 x86
  
 Non-optimizing MSVC
  
 MSVC 2010 generates the following: 
  
  
 Listing 17.10: Non-optimizing MSVC 2010
  
 PUBLIC 
  
 _d_max
  
 _TEXT 
  
 SEGMENT
  
 _a$ = 8 
  
 ; size = 8
  
 _b$ = 16 
  
 ; size = 8
  
 _d_max 
  
 PROC
  
 push 
  
 ebp
  
 mov 
  
 ebp, esp
  
 fld 
  
 QWORD PTR _b$[ebp]
  
 ; current stack state: ST(0) = _b
  
 ; compare _b (ST(0)) and _a, and pop register
  
 fcomp 
  
 QWORD PTR _a$[ebp]
  
 ; stack is empty here
  
 fnstsw ax 
  
 test 
  
 ah, 5 
  
 jp 
  
 SHORT $LN1@d_max
  
 ; we are here only if a>b
  
  
 fld 
  
 QWORD PTR _a$[ebp] 
  
  
 jmp 
  
 SHORT $LN2@d_max 
  
 $LN1@d_max: 
  
  
 fld 
  
 QWORD PTR _b$[ebp] 
  
 $LN2@d_max: 
  
  
 pop 
  
 ebp 
  
  
 ret 
  
 0 
  
 _d_max 
  
 ENDP
  
 So,
  FLD
  loads
  _b
  into
  ST(0)
 .
  
 FCOMP
  compares the value in
  ST(0)
  with what is in
  _a
  and sets
  C3
 /
 C2
 /
 C0
  bits in FPU status word register, accordingly. This 
 is a 16-bit register that reflects the current state of the FPU.
  
 After the bits are set, the
  FCOMP
  instruction also pops one variable from the stack. This is what distinguishes it from
  
 FCOM
 , which is just compares values, leaving the stack in the same state.
  
 220",NA
"17.8 Stack, calculators and reverse Polish notation","Now we undestand why some old calculators used reverse Polish notation
 22
 . 
  
 For example, for addition of 12 and 34 one 
 has to enter 12, then 34, then press “plus” sign. It’s because old calculators were just stack machine implementations, and 
 this was much simpler than to handle complex parenthesized expressions.",NA
17.9 x64,"On how floating point numbers are processed in x86-64, read more here:
  27 on page 411
 .",NA
17.10 ,NA,NA
Exercises,"•
  http://challenges.re/60
  
 •
  http://challenges.re/61
  
 22
 wikipedia.org/wiki/Reverse_Polish_notation",NA
Chapter 18,NA,NA
Arrays,"An array is just a set of variables in memory that lie next to each other and that have the same type
 1
 .",NA
18.1,NA,NA
Simple example,"#include <stdio.h> 
  
 int main() 
  
 { 
  
  
 int a[20]; 
  
  
 int i; 
  
  
 for (i=0; i<20; i++)
  
 a[i]=i*2;
  
 for (i=0; i<20; i++) 
  
 printf (""a[%d]=%d\n"", i, a[i]);
  
  
 return 0; 
  
 };
  
  
 18.1.1
  
 x86
  
 MSVC
  
 Let’s compile: 
  
  
 Listing 18.1: MSVC 2008
  
 _TEXT 
  
 SEGMENT 
  
 _i$ = -84 
    
 ; size = 4 
  
 _a$ = -80 
    
 ; size = 80 
  
 _main 
  
  
 PROC 
  
  
 push 
   
 ebp 
  
  
 mov 
   
 ebp, esp 
  
  
 sub 
   
 esp, 84 
  
 ; 00000054H 
  
  
 mov 
  
  
  
 DWORD PTR _i$[ebp], 0 
  
 jmp 
  
  
 SHORT $LN6@main
  
 $LN5@main: 
  
  
 mov 
  
 eax, DWORD PTR _i$[ebp] 
  
  
 add 
  
 eax, 1 
  
  
 mov 
  
 DWORD PTR _i$[ebp], eax 
  
 $LN6@main:
  
 cmp
  
 DWORD PTR _i$[ebp], 20
  
 ; 00000014H
  
 jge
  
 SHORT $LN4@main
  
 mov
  
 ecx, DWORD PTR _i$[ebp]
  
 shl
  
 ecx, 1
  
  
 1
 AKA
 2
  “homogeneous container”
  
 253",NA
18.2 ,NA,NA
Buffer overflow,"18.2.1 
  
 Reading outside array bounds
  
 So, array indexing is just
  array[index]
 . If you study the generated code closely, you’ll probably note the missing index 
 bounds checking, which could check
  if it is less than 20
 . What if the index is 20 or greater? That’s the one C/C++ feature it is 
 often blamed for.
  
 Here is a code that successfully compiles and works:
  
 #include <stdio.h>
  
 int main() 
  
 { 
  
 int a[20]; 
  
 int i;
  
 for (i=0; i<20; i++) 
  
  
 a[i]=i*2;
  
 printf (""a[20]=%d\n"", a[20]);
  
 return 0; 
  
 };
  
  
 Compilation results (MSVC 2008):
  
 Listing 18.5: Non-optimizing MSVC 2008
  
 $SG2474 DB 
  
 'a[20]=%d', 0aH, 00H
  
 _i$ = -84 ; size = 4 
  
 _a$ = -80 ; size = 80 
  
 _main 
  
 PROC 
  
  
 push 
   
 ebp 
  
  
 mov 
   
 ebp, esp 
  
  
 sub 
   
 esp, 84 
  
  
 mov 
   
 DWORD PTR _i$[ebp], 0 
  
  
 jmp 
   
 SHORT $LN3@main 
  
 $LN2@main: 
  
  
 mov 
  
  
  
 eax, DWORD PTR _i$[ebp] 
  
 add 
   
 eax, 1 
  
  
 mov 
   
 DWORD PTR _i$[ebp], eax 
  
  
 mov 
  
 DWORD PTR _i$[ebp], eax 
  
 $LN3@main: 
  
  
 cmp 
  
 DWORD PTR _i$[ebp], 20 
  
  
 jge 
  
 SHORT $LN1@main 
  
  
 mov 
  
  
 ecx, DWORD PTR _i$[ebp] 
  
 shl 
  
 ecx, 1 
  
  
 mov 
  
 edx, DWORD PTR _i$[ebp] 
  
  
 mov 
  
 DWORD PTR _a$[ebp+edx*4], ecx 
  
  
 jmp 
  
  
 SHORT $LN2@main $LN1@main: 
  
  
 mov 
  
 eax, DWORD PTR _a$[ebp+80] 
  
  
 push 
  
 eax 
  
  
 push 
  
 OFFSET $SG2474 ; 'a[20]=%d' 
  
  
 call 
  
 DWORD PTR __imp__printf",NA
18.3 ,NA,NA
Buffer overflow protection methods,"CHAPTER 18. ARRAYS
  
 There are several methods to protect against this scourge, regardless of the C/C++ programmers’ negligence. MSVC has 
 options like
 6
 :
  
 /RTCs Stack Frame runtime checking
  
 /GZ Enable stack checks (/RTCs)
  
 One of the methods is to write a random value between the local variables in stack at function prologue and to check it in 
 function epilogue before the function exits. If value is not the same, do not execute the last instruction
  RET
 , but stop (or 
 hang). The process will halt, but that is much better than a remote attack to your host.
  
 This random value is called a “canary” sometimes, it is related to the miners’ canary
 7
 , they were used by miners in the past 
 days in order to detect poisonous gases quickly. 
  
 Canaries are very sensitive to mine gases, they become very agitated in 
 case of danger, or even die.
  
 If we compile our very simple array example (
  18.1 on page 253
 ) in
  MSVC
  with RTC1 and RTCs option, you can see a call to 
 @_RTC_CheckStackVars@8
  a function at the end of the function that checks if the “canary” is correct.
  
 Let’s see how GCC handles this. Let’s take an
  alloca()
  (
  5.2.4 on page 26
 ) example:
  
 #ifdef __GNUC__ 
  
 #include <alloca.h> // GCC 
  
 #else 
  
 #include <malloc.h> // MSVC 
  
 #endif 
  
 #include <stdio.h>
  
 void f() 
  
 {
   
 char *buf=(char*)alloca (600); 
  
 #ifdef __GNUC__ 
  
  
 snprintf (buf, 600, ""hi! %d, %d, %d\n"", 1, 2, 3); // GCC #else 
  
  
 _snprintf (buf, 600, ""hi! %d, %d, %d\n"", 1, 2, 3); // MSVC #endif
  
  
 puts (buf); 
  
 };
  
 By default, without any additional options, GCC 4.7.3 inserts a “canary” check into the code:
  
 Listing 18.7: GCC 4.7.3
  
 .LC0: 
  
 .string ""hi! %d, %d, %d\n"" 
  
 f: 
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 push 
  
  
 ebx sub 
  
 esp, 676 
  
 lea 
  
 ebx, [esp+39] 
  
 and 
  
 ebx, -16 
  
 mov 
  
  
 DWORD PTR [esp+20], 3 mov 
  
 DWORD PTR [esp+16], 2 
  
 mov 
  
 DWORD PTR [esp+12], 1
  
 mov
  
 DWORD PTR [esp+8], OFFSET FLAT:.LC0
  
 ; ""hi! %d, %d, %d\n""
  
 mov
  
 DWORD PTR [esp+4], 600
  
 ; canary
  
 mov
  
 DWORD PTR [esp], ebx
  
 mov
  
 eax, DWORD PTR gs:20
  
 mov
  
 DWORD PTR [ebp-12], eax
  
 ; check canary
  
 xor
  
 eax, eax
  
 call
  
 _snprintf
  
 mov
  
 DWORD PTR [esp], ebx
  
 call
  
 puts
  
 mov
  
 eax, DWORD PTR [ebp-12]
  
 xor
  
 eax, DWORD PTR gs:20
  
 jne
  
 .L5
  
  
 6
 compiler-side buffer overflow protection methods:
  wikipedia.org/wiki/Buffer_overflow_protection 
 7
 wikipedia.org/wiki/Domestic_canary#Miner.27s_canary",NA
18.4 ,NA,NA
One more word about arrays,"Now we understand why it is impossible to write something like this in C/C++ code:
  
 void f(int size) 
  
 { 
  
  
 int a[size];
  
 ... 
  
 };
  
 That’s just because the compiler must know the exact array size to allocate space for it in the local stack layout on at the 
 compiling stage.
  
 If you need an array of arbitrary size, allocate it by using
  malloc()
 , then access the allocated memory block as an array of 
 variables of the type you need.
  
 Or use the C99 standard feature[
 ISO07
 , pp. 6.7.5/2], and it works like alloca() (
  5.2.4 on page 26
 ) internally.
  
 It’s also possible to use garbage collecting libraries for C. And there are also libraries supporting smart pointers for C++.",NA
18.5 ,NA,NA
Array of pointers to strings,"Here is an example for an array of pointers.
  
 Listing 18.8: Get month name
  
 #include <stdio.h> 
  
 const char* month1[]= 
  
 { 
  
 ""January"", 
  
 ""January"", 
  
 ""February"", 
  
 ""March"", 
  
 ""April"", 
  
 ""May"",",NA
18.6 ,NA,NA
Multidimensional arrays,"CHAPTER 18. ARRAYS
  
 Internally, a multidimensional array is essentially the same thing as a linear array. Since the computer memory is linear, it 
 is an one-dimensional array. For convenience, this multi-dimensional array can be easily represented as one-dimensional.
  
 For example, this is how the elements of the 3x4 array are placed in one-dimensional array of 12 cells:
  
 Offset in memory
  
 array element
  
 0
  
 [0][0]
  
 1
  
 [0][1]
  
 2
  
 [0][2]
  
 3
  
 [0][3]
  
 4
  
 [1][0]
  
 5
  
 [1][1]
  
 6
  
 [1][2]
  
 7
  
 [1][3]
  
 8
  
 [2][0]
  
 9
  
 [2][1]
  
 10
  
 [2][2]
  
 11
  
 [2][3]
  
 Table 18.1: Two-dimensional array represented in memory as one-dimensional
  
 Here is how each cell of 3*4 array are placed in memory:
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 8
  
 9
  
 10
  
 11
  
 Table 18.2: Memory addresses of each cell of two-dimensional array
  
 So, in order to calculate the address of the element we need, we first multiply the first index by 4 (array width) and then 
 add the second index. That’s called
  row-major order
 , and this method of array and matrix representation is used in at least 
 C/C++ and Python. The term
  row-major order
  in plain English language means: “first, write the elements of the first row, 
 then the second row …and finally the elements of the last row”.
  
 Another method for representation is called
  column-major order
  (the array indices are used in reverse order) and it is used 
 at least in FORTRAN, MATLAB and R.
  column-major order
  term in plain English language means: “first, write the elements 
 of the first column, then the second column …and finally the elements of the last column”.
  
 Which method is better? 
  
 In general, in terms of performance and cache memory, the best scheme for data organization is 
 the one, in which the elements are accessed sequentially. 
  
 So if your function accesses data per row,
  row-major order
  is 
 better, and vice versa.
  
 18.6.1 
  
 Two-dimensional array example
  
 We are going to work with an array of type
  char
 , which implies that each element requires only one byte in memory.
  
 Row filling example
  
 Let’s fill the second row with these values 0..3:
  
 Listing 18.20: Row filling example
  
 #include <stdio.h> 
  
 char a[3][4]; 
  
 int main()
  
 { 
  
 int x, y;
  
 // clear array 
  
 for (x=0; x<3; x++)",NA
18.7,NA,NA
Pack of strings as a two-dimensional array,"Let’s revisit the function that returns the name of a month: listing.
 18.8
 . As you see, at least one memory load operation is
  
 needed to prepare a pointer to the string that’s the month’s name.
  
 Is it possible to get rid of this memory load operation?
  
 In fact yes, if you represent the list of strings as a two-dimensional array:
  
  
 #include <stdio.h> 
  
 #include <assert.h>
  
 const char month2[12][10]= 
  
 {
  
 { 'J','a','n','u','a','r','y',
  
 0,
  
 0,
  
 0 },
  
 { 'F','e','b','r','u','a','r','y',
  
 0,
  
 0 },
  
 { 'M','a','r','c','h',
  
 0,
  
 0,
  
 0,
  
 0,
  
 0 },
  
 { 'A','p','r','i','l',
  
 0,
  
 0,
  
 0,
  
 0,
  
 0 },
  
 { 'M','a','y',
  
 0,
  
 0,
  
 0,
  
 0,
  
 0,
  
 0,
  
 0 },
  
 { 'J','u','n','e', 
  
 0, 
  
 0, 
  
 0, 
  
 0, 
  
 0, 
  
 0 },
  
  
 { 'J','u','n','e', 
  
 0, 
  
 0, 
  
 0, 
  
 0, 
  
 0, 
  
 0 },
  
 { 'J','u','l','y', 
  
 0, 
  
 0, 
  
 0, 
  
 0, 
  
 0, 
  
 0 },
  
 { 'A','u','g','u','s','t', 
  
 0, 
  
 0, 
  
 0, 
  
 0 },
  
 { 'S','e','p','t','e','m','b','e','r', 
  
 0 },
  
 { 'O','c','t','o','b','e','r', 
  
 0, 
  
 0, 
  
 0 },
  
 { 'N','o','v','e','m','b','e','r', 
  
 0, 
  
 0 },
  
 { 'D','e','c','e','m','b','e','r', 
  
 0, 
  
 0 }
  
 };
  
 // in 0..11 range
  
 const char* get_month2 (int month)
  
 284",NA
18.8 ,NA,NA
Conclusion,"CHAPTER 18. ARRAYS
  
 An array is a pack of values in memory located adjacently. It’s true for any element type, including structures. Access to a 
 specific array element is just a calculation of its address.",NA
18.9 ,NA,NA
Exercises,"•
  
 http://challenges.re/62
  
 •
  
 http://challenges.re/63
  
 •
  
 http://challenges.re/64
  
 •
  
 http://challenges.re/65
  
 •
  http://challenges.re/66",NA
Chapter 19,NA,NA
Manipulating specific bit(s),"A lot of functions define their input arguments as flags in bit fields. Of course, they could be substituted by a set of
  bool
 -
 typed variables, but it is not frugally.",NA
19.1 ,NA,NA
Specific bit checking,"19.1.1 
  
 x86
  
 Win32 API example:
  
 HANDLE fh;
  
 fh=CreateFile (""file"", GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS
 ⤦
  
 We get (MSVC 2010): 
  
  
 Listing 19.1: MSVC 2010
  
 push
  
 0
  
 ; 00000080H
  
 push
  
 128
  
 push
  
 4
  
 push
  
 0
  
 push
  
 1
  
  
  
 push
  
 -1073741824
  
 ; c0000000H
  
 push
  
 OFFSET $SG78813
  
 call
  
 DWORD PTR __imp__CreateFileA@28
  
 mov
  
 DWORD PTR _fh$[ebp], eax
  
  
 Let’s take a look in WinNT.h: 
  
  
 Listing 19.2: WinNT.h
  
 #define GENERIC_READ 
  
 (0x80000000L)
  
 #define GENERIC_WRITE 
  
 (0x40000000L)
  
 #define GENERIC_EXECUTE 
  
 (0x20000000L)
  
 #define GENERIC_ALL 
  
 (0x10000000L)
  
 Everything is clear,
  GENERIC_READ | GENERIC_WRITE = 0x80000000 | 0x40000000 = 0xC0000000
 , and that value is used 
 as the second argument for the
  CreateFile()
 1
 function.
  
 How would
  CreateFile()
  check these flags? If we look in KERNEL32.DLL in Windows XP SP3 x86, we’ll find this fragment of 
 code in
  CreateFileW
 : 
  
  
 Listing 19.3: KERNEL32.DLL (Windows XP SP3 x86)
  
 .text:7C83D429
  
 test
  
 byte ptr [ebp+dwDesiredAccess+3], 40h
  
 .text:7C83D42D
  
 mov
  
 [ebp+var_8], 1
  
  
 .text:7C83D434
  
 jz
  
 short loc_7C83D417
  
 .text:7C83D436
  
 jmp
  
 loc_7C810817
  
  
 1
 msdn.microsoft.com/en-us/library/aa363858(VS.85).aspx
  
 289",NA
19.2 ,NA,NA
Setting and clearing specific bits,"For example:
  
 #include <stdio.h> 
  
 #define IS_SET(flag, bit) 
  
 ((flag) & (bit)) 
  
 #define SET_BIT(var, bit) 
  
 ((var) |= (bit))",NA
19.3 ,NA,NA
Shifts,"The x86
  ISA
  has the SHL (SHift Left) and SHR (SHift Right) instructions for this. Bit shifts in C/C++ are implemented using
  ≪
  
 and
  ≫
  operators.
  
 Shift instructions are often used in division and multiplications by powers of two:
  2
 n
 (e.g., 1, 2, 4, 8, etc):
  16.1.2 on page 199
 ,
  
 16.2.1 on page 204
 .
  
 Shifting operations are also so important because they are often used for specific bit isolation or for constructing a value of 
 several scattered bits.",NA
19.4 ,NA,NA
Setting and clearing specific bits:,NA,NA
 FPU,NA,NA
 example,"Here is how bits are located in the
  float
  type in IEEE 754 form:
  
 300",NA
19.5 ,NA,NA
Counting bits set to 1,"Here is a simple example of a function that calculates the number of bits set in the input value.
  
 This operation is also called “population count”
 7
 .
  
 #include <stdio.h> 
  
 #define IS_SET(flag, bit) 
  
 ((flag) & (bit)) 
  
 int f(unsigned int a) 
  
 { 
  
  
 int i; 
  
  
 int rt=0; 
  
  
 for (i=0; i<32; i++)
  
 if (IS_SET (a, 1<<i)) 
  
  
 rt++;
  
  
 return rt; 
  
 };
  
 int main() 
  
 { 
  
  
 f(0x12345678); // test 
  
 };
  
  
 In this loop, the iteration count value
  i
  is counting from 0 to 31, so the
  1 ≪
  i
  statement is counting from 1 to
  0x80000000
 . 
 Describing this operation in natural language, we would say
  shift 1 by n bits left
 . In other words,
  1 ≪
  i
  statement 
 consequently
  
 Here is a table of all possible
  1 ≪
  i
  for
  i
  = 0
 ...
 31
 : 
 7
 modern x86 CPUs (supporting SSE4) even have a POPCNT instruction for it",NA
19.6,NA,NA
Conclusion,"Analogous to the C/C++ shifting operators
  ≪
  and
  ≫
 , the shift instructions in x86 are
  SHR
 /
 SHL
  (for unsigned values) and 
 The shift instructions in ARM are
  LSR
 /
 LSL
  (for unsigned values) and
  ASR
 /
 LSL
  (for signed values). It’s also possible to add 
 shift suffix to some instructions (which are called “data processing instructions”).
  
 19.6.1 
  
 Check for specific bit (known at compile stage)
  
 Test if the 1000000 bit (0x40) is present in the register’s value:
  
 Listing 19.38: C/C++
  
 if (input&0x40) 
  
  
 ...
  
  
 Listing 19.39: x86
  
 TEST REG, 40h 
  
 JNZ is_set
  
 ; bit is not set
  
 Listing 19.40: x86
  
 TEST REG, 40h 
  
 JZ is_cleared
  
 ; bit is set
  
 Listing 19.41: ARM (ARM mode)
  
 TST REG, #0x40 
  
 BNE is_set
  
 ; bit is not set
  
 Sometimes,
  AND
  is used instead of
  TEST
 , but the flags that are set are the same.
  
 19.6.2 
  
 Check for specific bit (specified at runtime)
  
 This is usually done by this C/C++ code snippet (shift value by
  n
  bits right, then cut off lowest bit):
  
 Listing 19.42: C/C++
  
 if ((value>>n)&1)
  
 ....
  
 This is usually implemented in x86 code as:
  
 Listing 19.43: x86
  
 ; REG=input_value 
  
 ; CL=n
  
 SHR REG, CL 
  
 AND REG, 1
  
 Or (shift 1 bit
  n
  times left, isolate this bit in input value and check if it’s not zero):
  
 320",NA
19.7,NA,NA
Exercises,"•
  
 http://challenges.re/67
  
 •
  
 http://challenges.re/68
  
 •
  
 http://challenges.re/69
  
 •
  http://challenges.re/70
  
 322",NA
Chapter 20,NA,NA
Linear congruential generator as pseudorandom ,NA,NA
number generator,"The linear congruential generator is probably the simplest possible way to generate random numbers. It’s not in favour in 
 modern times
 1
 , but it’s so simple (just one multiplication, one addition and one AND operation), we can use it as an example.
  
 #include <stdint.h> 
  
 // constants from the Numerical Recipes book 
  
 #define RNG_a 1664525 
  
 #define RNG_c 1013904223 
  
 static uint32_t rand_state; 
  
 void my_srand (uint32_t init) 
  
 {
  
 rand_state=init; 
  
 }
  
 int my_rand () 
  
 { 
  
 rand_state=rand_state*RNG_a; 
  
 rand_state=rand_state+RNG_c; 
  
 return rand_state & 0x7fff; 
  
 }
  
 There are two functions: the first one is used to initialize the internal state, and the second one is called to generate 
 pseudorandom numbers.
  
 We see that two constants are used in the algorithm. They are taken from [
 Pre+07
 ]. 
   
 Let’s define them using a
  #define 
 C/C++ statement. It’s a macro. 
  
 The difference between a C/C++ macro and a constant is that all macros are replaced with 
 their value by C/C++ preprocessor, and they don’t take any memory, unlike variables. 
  
 In contrast, a constant is a read-only 
 variable. It’s possible to take a pointer (or address) of a constant variable, but impossible to do so with a macro.
  
 The last AND operation is needed because by C-standard
  my_rand()
  has to return a value in the 0..32767 range. 
  
 If you 
 want to get 32-bit pseudorandom values, just omit the last AND operation.",NA
20.1 ,NA,NA
x86,"Listing 20.1: Optimizing MSVC 2013
  
 _BSS 
  
 SEGMENT
  
 _rand_state DD 
  
 01H DUP (?)
  
 _BSS 
  
 ENDS
  
 _init$ = 8
  
 _srand
  
 PROC
  
 eax, DWORD PTR _init$[esp-4]
  
 mov
  
 mov
  
 DWORD PTR _rand_state, eax
  
  
 1
 Mersenne twister is better",NA
20.2,NA,NA
x64,"The x64 version is mostly the same and uses 32-bit registers instead of 64-bit ones (because we are working with
  int
  values 
 here). But
  my_srand()
  takes its input argument from the
  ECX
  register rather than from stack:
  
 Listing 20.3: Optimizing MSVC 2013 x64
  
 _BSS 
  
 SEGMENT
  
 rand_state DD 
  
 01H DUP (?)
  
 _BSS 
  
 ENDS
  
 init$ = 8 
  
 my_srand PROC 
  
 ; ECX = input argument 
  
 mov 
  
 DWORD PTR rand_state, ecx",NA
20.3 ,NA,NA
32-bit ARM ,"Listing 20.4: Optimizing Keil 6/2013 (ARM mode)
  
 my_srand PROC
  
 LDR
  
 r1,|L0.52|
  
 ; load pointer to rand_state
  
 STR
  
 r0,[r1,#0]
  
 ; save rand_state
  
 BX
  
 lr
  
 ENDP
  
 my_rand PROC
  
 LDR
  
 r0,|L0.52|
  
 ; load pointer to rand_state
  
 LDR
  
 r2,|L0.56|
  
 ; load RNG_a
  
 LDR
  
 r1,[r0,#0]
  
 ; load rand_state
  
 MUL
  
 r1,r2,r1
  
 ; load RNG_c
  
 LDR
  
 r2,|L0.60|
  
 ADD
  
 r1,r1,r2
  
 ; save rand_state
  
 STR
  
 r1,[r0,#0]
  
 ; AND with 0x7FFF: 
  
 LSL 
  
 r0,r1,#17
  
 LSR 
  
 r0,r0,#17 
  
 BX 
  
 lr 
  
 ENDP
  
 |L0.52| 
  
 DCD 
  
 ||.data|| 
  
 |L0.56| 
  
 DCD 
  
 0x0019660d 
  
 |L0.60| 
  
 DCD 
  
 0x3c6ef35f
  
 AREA ||.data||, DATA, ALIGN=2
  
 rand_state 
  
 DCD 
  
 0x00000000
  
  
 It’s not possible to embed 32-bit constants into ARM instructions, so Keil has to place them externally and load them addi-
 tionally. One interesting thing is that it’s not possible to embed the 0x7FFF constant as well. So what Keil does is shifting 
 rand_state
  left by 17 bits and then shifting it right by 17 bits. This is analogous to the
  (
 rand
 _
 state
  ≪ 17) ≫ 17
  statement 
 that’s our goal after all.
  
 Optimizing Keil for Thumb mode generates mostly the same code.",NA
20.4 ,NA,NA
MIPS ,"Listing 20.5: Optimizing GCC 4.4.5 (IDA)
  
  
 my_srand:
  
  
 325",NA
20.5 ,NA,NA
Thread-safe version of the example,"The thread-safe version of the example is to be demonstrated later:
  65.1 on page 656
 .
  
 327",NA
Chapter 21,NA,NA
Structures,"A C/C++ structure, with some assumptions, is just a set of variables, always stored in memory together, not necessary of the 
 same type
 1
 .",NA
21.1 ,NA,NA
MSVC: SYSTEMTIME example,"Let’s take the SYSTEMTIME
 2
 win32 structure that describes time. 
  
 This is how it’s defined: 
  
  
 Listing 21.1: WinBase.h
  
 typedef struct _SYSTEMTIME { 
  
 WORD wYear; 
  
 WORD wMonth; 
  
 WORD wDayOfWeek; 
  
 WORD wDay;
  
 WORD wHour; 
  
 WORD wMinute; 
  
 WORD wSecond; 
  
 WORD wMilliseconds; 
  
 } SYSTEMTIME, *PSYSTEMTIME;
  
 Let’s write a C function to get the current time:
  
 #include <windows.h> 
  
 #include <stdio.h>
  
 void main() 
  
 { 
  
  
 SYSTEMTIME t; 
  
  
 GetSystemTime (&t);
  
 printf (""%04d-%02d-%02d %02d:%02d:%02d\n"", 
  
 t.wYear, t.wMonth, t.wDay, 
  
 t.wHour, t.wMinute, t.wSecond);
  
  
 return; 
  
 };
  
 We get (MSVC 2010): 
  
  
 Listing 21.2: MSVC 2010 /GS-
  
 _t$ = -16 ; size = 16 
  
 _main 
  
 PROC 
  
  
 push 
  
 ebp
  
 mov 
  
 ebp, esp
  
 sub 
  
 esp, 16
  
 lea 
  
 eax, DWORD PTR _t$[ebp]
  
 1
 AKA
  “heterogeneous container”
  
 2
 MSDN: SYSTEMTIME structure
  
 328",NA
21.2 ,NA,NA
Let’s allocate space for a structure using malloc(),"Sometimes it is simpler to place structures not the in local stack, but in the
  heap
 :
  
 331",NA
21.3 ,NA,NA
UNIX: struct tm,"21.3.1 
  
 Linux
  
 Let’s take the
  tm
  structure from
  time.h
  in Linux for example:
  
 #include <stdio.h> 
  
 #include <time.h>
  
 void main() 
  
 { 
  
  
 struct tm t; 
  
  
 time_t unix_time;",NA
21.4,NA,NA
Fields packing in structure,"One important thing is fields packing in structures
 6
 .
  
 Let’s take a simple example:
  
 #include <stdio.h>
  
 struct s 
  
 { 
  
  
 char a; 
  
  
 int b; 
  
  
 char c; 
  
  
 int d; 
  
 };
  
 void f(struct s s) 
  
 {
   
 printf (""a=%d; b=%d; c=%d; d=%d\n"", s.a, s.b, s.c, s.d); };
  
 int main() 
  
 { 
  
  
 struct s tmp; 
  
  
 tmp.a=1; 
  
  
 tmp.b=2; 
  
  
 tmp.c=3; 
  
  
 tmp.d=4; 
  
  
 f(tmp); 
  
 };
  
 As we see, we have two
  char
  fields (each is exactly one byte) and two more —
 int
  (each — 4 bytes).
  
 21.4.1 
  
 x86
  
 This compiles to:
  
 Listing 21.16: MSVC 2012 /GS- /Ob0
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1 
 1
 2
  
 _tmp$ = -16
  
 _main
  
 PROC
  
 ; set field a
  
 push
  
 ebp
  
 mov
  
 ebp, esp
  
 sub
  
 esp, 16
  
 mov
  
 BYTE PTR _tmp$[ebp], 1
  
  
 mov 
  
 DWORD PTR _tmp$[ebp+4], 2 
  
 ; set field b
  
 mov 
  
 BYTE PTR _tmp$[ebp+8], 3 
  
 ; set field c
  
 mov 
  
 DWORD PTR _tmp$[ebp+12], 4 ; set field d
  
 sub 
  
 esp, 16 
  
 ; allocate place for temporary structure
  
 mov 
  
 eax, esp
  
 mov 
  
 ecx, DWORD PTR _tmp$[ebp] 
  
 ; copy our structure to the temporary one
  
  
  
 6
 See also:
  Wikipedia: Data structure alignment
  
 343",NA
21.5 ,NA,NA
Nested structures,"Now what about situations when one structure is defined inside of another?
  
 #include <stdio.h>
  
 struct inner_struct 
  
 { 
  
  
 int a; 
  
  
 int b; 
  
 };
  
 struct outer_struct 
  
 { 
  
  
 char a; 
  
  
 int b; 
  
  
 struct inner_struct c; 
  
  
 char d; 
  
  
 int e; 
  
 };
  
 void f(struct outer_struct s) 
  
 { 
  
  
 printf (""a=%d; b=%d; c.a=%d; c.b=%d; d=%d; e=%d\n"", 
  
 s.a, s.b, 
 s.c.a, s.c.b, s.d, s.e); 
  
 };
  
 int main() 
  
 { 
  
  
 struct outer_struct s; 
  
  
 s.a=1; 
  
  
 s.b=2; 
  
  
 s.c.a=100; 
  
  
 s.c.b=101; 
  
  
 s.d=3; 
  
  
 s.e=4; 
  
  
 f(s); 
  
 };
  
 … in this case, both
  inner_struct
  fields are to be placed between the a,b and d,e fields of the
  outer_struct
 . Let’s 
 compile (MSVC 2010):
  
 Listing 21.24: Optimizing MSVC 2010 /Ob0
  
  
 $SG2802 DB
  
 'a=%d; b=%d; c.a=%d; c.b=%d; d=%d; e=%d', 0aH, 00H
  
  
 349",NA
21.6 ,NA,NA
Bit fields in a structure,"21.6.1 
  
 CPUID example
  
 The C/C++ language allows to define the exact number of bits for each structure field. It is very useful if one needs to save 
 memory space. For example, one bit is enough for a
  bool
  variable. But of course, it is not rational if speed is important. Let’s 
 consider the
  CPUID
 9
 instruction example. This instruction returns information about the current CPU and its features.
  
 If the
  EAX
  is set to 1 before the instruction’s execution,
  CPUID
  returning this information packed into the
  EAX
  register:
  
 3:0 (4 bits) 
  
 7:4 (4 bits) 
  
 11:8 (4 bits) 
 13:12 (2 bits) 
 19:16 (4 bits) 
 27:20 (8 bits)
  
 Stepping 
  
 Model 
  
 Family 
  
 Processor Type 
  
 Extended Model 
 Extended Family
  
 MSVC 2010 has
  CPUID
  macro, but GCC 4.4.1 does not. So let’s make this function by ourselves for GCC with the help of its 
 built-in assembler
 10
 .
  
 #include <stdio.h> 
  
 #ifdef __GNUC__
  
 static inline void cpuid(int code, int *a, int *b, int *c, int *d) { asm 
 volatile(""cpuid"":""=a""(*a),""=b""(*b),""=c""(*c),""=d""(*d):""a""(code)); }
  
 9
 wikipedia 
  
 10
 More about internal GCC assembler",NA
21.7 ,NA,NA
Exercises,"•
  http://challenges.re/71
  
 •
  http://challenges.re/72",NA
Chapter 22,NA,NA
Unions,"C/C++
  union
  is mostly used for interpreting a variable (or memory block) of one data type as a variable of another data type.",NA
22.1 ,NA,NA
Pseudo-random number generator example,"If we need float random numbers between 0 and 1, the simplest thing is to use a
  PRNG
  like the Mersenne twister. It 
 produces random 32-bit values in DWORD form. Then we can transform this value to
  float
  and then divide it by
  
 RAND_MAX 
 (
 0xFFFFFFFF
  in our case)— we getting a value in the 0..1 interval.
  
 But as we know, division is slow. Also, we would like to issue as few FPU operations as possible. Can we get rid of the 
 division?
  
 Let’s recall what a floating point number consists of: sign bit, significand bits and exponent bits. We just need to store 
 random bits in all significand bits to get a random float number!
  
 The exponent cannot be zero (the floating number is denormalized in this case), so we are storing
  01111111
  to exponent—
 this means that the exponent is 1. Then we filling the significand with random bits, set the sign bit to 0 (which means a 
 positive number) and voilà. The generated numbers is to be between 1 and 2, so we must also subtract 1.
  
 A very simple linear congruential random numbers generator is used in my example
 1
 , it produces 32-bit numbers. The
  
 PRNG 
 is initialized with the current time in UNIX timestamp format.
  
 Here we represent the
  float
  type as an
  union
 —it is the C/C++ construction that enables us to interpret a piece of memory 
 as different types. In our case, we are able to create a variable of type
  union
  and then access to it as it is
  float
  or as it is 
 uint32_t
 . It can be said, it is just a hack. A dirty one.
  
 The integer
  PRNG
  code is the same as we already considered:
  20 on page 323
 . So this code in compiled form is omitted.
  
 #include <stdio.h> 
  
 #include <stdint.h> 
  
 #include <time.h>
  
 // integer PRNG definitions, data and routines:
  
 // constants from the Numerical Recipes book 
  
 const uint32_t RNG_a=1664525; 
  
 const uint32_t RNG_c=1013904223; 
  
 uint32_t RNG_state; // global variable
  
 void my_srand(uint32_t i)
  
 { 
  
 RNG_state=i; 
  
 };
  
 uint32_t my_rand() 
  
 { 
  
 RNG_state=RNG_state*RNG_a+RNG_c; 
  
 return RNG_state; 
  
 };
  
 // FPU PRNG definitions and routines:
  
 1
 the idea was taken from:
  http://go.yurichev.com/17308",NA
22.2 ,NA,NA
Calculating machine epsilon,"The machine epsilon is the smallest possible value the
  FPU
  can work with. The more bits allocated for floating point 
 number, the smaller the machine epsilon. It is
  2
 −23
 = 1
 .
 19
 e
  − 07
  for
  float
  and
  2
 −52
 = 2
 .
 22
 e
  − 16
  for
  double
 .
  
 #include <stdio.h> 
  
 #include <stdint.h>
  
 union uint_float 
  
 { 
  
 uint32_t i; 
  
 float f; 
  
 };
  
 float calculate_machine_epsilon(float start) 
  
 { 
  
 union uint_float v;",NA
22.3 ,NA,NA
Fast square root calculation,"Another well-known algorithm where
  float
  is interpreted as integer is fast calculation of square root. 
  
 Listing 22.8: The source code is taken from Wikipedia:
  http://go.yurichev.com/17364
  
 /* Assumes that float is in the IEEE 754 single precision floating point format 
  
 * and that int is 32 bits. */ 
  
 float sqrt_approx(float z) 
  
 { 
  
   
 int val_int = *(int*)&z; /* Same bits, but as an int */ 
  
   
 /* 
  
   
  
 * To justify the following code, prove that 
  
   
  
 * 
  
   
  
 * ((((val_int / 2^m) - b) / 2) + b) * 2^m = ((val_int - 2^m) / 2) + ((b + 1) / 2) * 2^m) 
   
  
 * 
  
   
  
 * where 
  
   
  
 *
  
 * b = exponent bias 
  
 * m = number of mantissa bits 
  
 * 
  
 * .
  
 */
  
 val_int -= 1 << 23; /* Subtract 2^m. */ 
  
 val_int >>= 1; /* Divide by 2. */ 
  
 val_int += 1 << 29; /* Add ((b + 1) / 2) * 2^m. */
  
  
 return *(float*)&val_int; /* Interpret again as float */ }
  
 365",NA
Chapter 23,NA,NA
Pointers to functions,"A pointer to a function, as any other pointer, is just the address of the function’s start in its code segment.
  
 They are often used for calling callback functions
 1
 .
  
 Well-known examples are:
  
 •
  qsort()
 2
 ,
  atexit()
 3
 from the standard C library;
  
 • *NIX OS signals
 4
 ;
  
 • thread starting:
  CreateThread()
  (win32),
  pthread_create()
  (POSIX);• lots of 
 win32 functions, like
  EnumChildWindows()
 5
 .
  
 • lots of places in the Linux kernel, for example the filesystem driver functions are called via callbacks:
  http://go.
  
  
 yurichev.com/17076
  
 • The GCC plugin functions are also called via callbacks:
  http://go.yurichev.com/17077
  
 • Another example of function pointers is a table in the “dwm” Linux window manager that defines shortcuts. 
  
 Each 
  
 shortcut has a corresponding function to call if a specific key is pressed:
  GitHub
 . 
  
 As we can see, such table is easier 
  
 to handle than a large switch() statement.
  
 So, the
  qsort()
  function is an implementation of quicksort in the C/C++ standard library. The functions is able to sort 
 anything, any type of data, as long as you have a function to compare these two elements and
  qsort()
  is able to call it.
  
 The comparison function can be defined as:
  
 int (*compare)(const void *, const void *)
  
  
 Let’s use a slightly modified example which was found
  here
 :
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1 
 1
 2 
 1
 3 
 1
 4 
 1
 5 
 1
 6 
 1
 7 
 1
 8 
  
 /* ex3 Sorting ints with qsort */
  
 #include <stdio.h> 
  
 #include <stdlib.h>
  
 int comp(const void * _a, const void * _b) 
  
 { 
  
 const int *a=(const int *)_a; 
  
 const int *b=(const int *)_b;
  
 if (*a==*b) 
  
   
 return 0; 
  
 else 
  
   
 if (*a < *b) 
  
     
 return -1; 
  
    
 else 
  
     
 return 1; 
  
 }
  
 int main(int argc, char* argv[])
  
  
  
 1
 wikipedia 
  
 2
 wikipedia 
  
 3
 http://go.yurichev.com/17073 
  
 4
 wikipedia 
  
 5
 MSDN",NA
23.1,NA,NA
MSVC,"Let’s compile it in MSVC 2010 (some parts were omitted for the sake of brevity) with
  /Ox
  option:
  
 Listing 23.1: Optimizing MSVC 2010: /GS- /MD
  
  
 __a$ = 8
  
 eax, DWORD PTR __a$[esp-4]
  
 ; size = 4
  
 __b$ = 12
  
 ; size = 4
  
 _comp
  
 PROC
  
 mov
  
 mov
  
 ecx, DWORD PTR __b$[esp-4]
  
 mov
  
 eax, DWORD PTR [eax]
  
 mov
  
 ecx, DWORD PTR [ecx]
  
 cmp
  
 eax, ecx
  
 jne
  
 SHORT $LN4@comp
  
 xor
  
 eax, eax
  
 ret
  
 0
  
 $LN4@comp:
  
 xor
  
 edx, edx
  
 ; size = 40
  
 cmp
  
 eax, ecx
  
 setge
  
 dl
  
 lea
  
 eax, DWORD PTR [edx+edx-1]
  
 ret
  
 0
  
 _comp
  
 ENDP
  
 _numbers$ = -40
  
 _argc$ = 8
  
 ; size = 4
  
 _argv$ = 12
  
 ; size = 4
  
  
 _main
  
 PROC
  
 esp, 40
  
 ; 00000028H
  
 sub
  
 push
  
 esi
  
 ; 0000000aH
  
 push
  
 OFFSET _comp
  
 push
  
 4
  
 lea
  
 eax, DWORD PTR _numbers$[esp+52]
  
 push
  
 10
  
 push
  
 eax
  
 ; 00000764H
  
 mov
  
 DWORD PTR _numbers$[esp+60], 1892
  
 mov
  
 DWORD PTR _numbers$[esp+64], 45
  
 ; 0000002dH
  
 mov
  
 DWORD PTR _numbers$[esp+68], 200
  
 ; 000000c8H
  
 mov
  
 DWORD PTR _numbers$[esp+72], -98
  
 ; ffffff9eH
  
 mov
  
 DWORD PTR _numbers$[esp+76], 4087
  
 ; 00000ff7H
  
 mov
  
 DWORD PTR _numbers$[esp+80], 5
  
 ; ffffcfc7H
  
 mov
  
 DWORD PTR _numbers$[esp+84], -12345
  
 mov
  
 DWORD PTR _numbers$[esp+88], 1087
  
 ; 0000043fH
  
 mov
  
 DWORD PTR _numbers$[esp+92], 88
  
 ; 00000058H
  
 mov
  
 DWORD PTR _numbers$[esp+96], -100000
  
 ; fffe7960H
  
 call
  
 _qsort
  
 ; 00000010H
  
 add
  
 esp, 16
  
 ...
  
 Nothing surprising so far. As a fourth argument, the address of label
  _comp
  is passed, which is just a place where
  comp() 
 is 
 located, or, in other words, the address of the very first instruction of that function.
  
 How does
  qsort()
  call it?
  
 Let’s take a look at this function, located in MSVCR80.DLL (a MSVC DLL module with C standard library functions):
  
 368",NA
23.2 ,NA,NA
GCC,"Not a big difference:
  
 Listing 23.3: GCC
  
 lea 
  
 eax, [esp+40h+var_28]
  
 mov 
  
 [esp+40h+var_40], eax
  
 mov 
  
 [esp+40h+var_28], 764h
  
 mov 
  
 [esp+40h+var_24], 2Dh
  
 mov 
  
 [esp+40h+var_20], 0C8h
  
 mov 
  
 [esp+40h+var_1C], 0FFFFFF9Eh
  
 mov 
  
 [esp+40h+var_18], 0FF7h
  
 mov 
  
 [esp+40h+var_14], 5
  
 mov 
  
 [esp+40h+var_10], 0FFFFCFC7h 
  
 mov 
  
 [esp+40h+var_C], 43Fh 
  
 mov 
  
 [esp+40h+var_8], 58h 
  
 mov 
  
 [esp+40h+var_4], 0FFFE7960h 
  
 mov 
  
 [esp+40h+var_34], offset comp 
  
 mov 
  
 [esp+40h+var_38], 4 
  
 mov 
  
 [esp+40h+var_3C], 0Ah 
  
 call 
  
 _qsort
  
 374",NA
Chapter 24,NA,NA
64-bit values in 32-bit environment,"In a 32-bit environment,
  GPR
 ’s are 32-bit, so 64-bit values are stored and passed as 32-bit value pairs
 1
 .",NA
24.1,NA,NA
Returning of 64-bit value,"#include <stdint.h> 
  
 uint64_t f ()
  
 { 
  
 return 0x1234567890ABCDEF; 
  
 };
  
  
 24.1.1
  
 x86
  
 In a 32-bit environment, 64-bit values are returned from functions in the
  EDX
 :
 EAX
  register 
 pair. 
  
 Listing 24.1: Optimizing MSVC 2010
  
 _f
  
 PROC
  
 eax, -1867788817
  
 ; 90abcdefH
  
 mov
  
 mov
  
 edx, 305419896
  
 ; 12345678H
  
  
 _f
  
 ret
  
 0
  
 ENDP
  
  
  
 24.1.2
  
 ARM
  
 A 64-bit value is returned in the R0-R1 register pair (R1 is for the high part and R0 for the low part): 
  
 Listing 24.2: Optimizing Keil 6/2013 (ARM mode)
  
 ||f|| PROC 
  
 LDR 
  
 r0,|L0.12| 
  
 LDR 
  
 r1,|L0.16| 
  
 BX 
  
 lr 
  
 ENDP
  
 |L0.12| 
  
 DCD 
  
 0x90abcdef 
  
 |L0.16| 
  
 DCD 
  
 0x12345678
  
 1
 By the way, 32-bit values are passed as pairs in 16-bit environment in the same way:
  53.4 on page 576
  
 379",NA
24.2,NA,NA
"Arguments passing, addition, subtraction","#include <stdint.h>
  
 uint64_t f_add (uint64_t a, uint64_t b) 
  
 { 
  
 return a+b; 
  
 };
  
 void f_add_test () 
  
 { 
  
 #ifdef __GNUC__
  
 printf (""%lld\n"", f_add(12345678901234, 23456789012345)); #else 
  
 printf (""%I64d\n"", f_add(12345678901234, 23456789012345)); #endif 
  
 };
  
 uint64_t f_sub (uint64_t a, uint64_t b) 
  
 { 
  
 return a-b; 
  
 };
  
  
 24.2.1
  
 x86
  
 Listing 24.5: Optimizing MSVC 2012 /Ob1
  
 _a$ = 8 
  
 ; size = 8
  
 _b$ = 16 
  
 ; size = 8
  
 _f_add 
  
 PROC
  
 mov 
  
 eax, DWORD PTR _a$[esp-4]
  
 add 
  
 eax, DWORD PTR _b$[esp-4]
  
 mov 
  
 edx, DWORD PTR _a$[esp]
  
 adc 
  
 edx, DWORD PTR _b$[esp]
  
 ret 
  
 0
  
 _f_add 
  
 ENDP
  
 _f_add_test PROC
  
 push
  
 5461
  
 ; 00001555H
  
 push
  
 1972608889
  
 ; 75939f79H
  
 push
  
 2874
  
 ; 00000b3aH
  
 push
  
 1942892530
  
 ; 73ce2ff_subH
  
 call
  
 _f_add
  
 push
  
 edx
  
 push
  
 eax
  
  
 380",NA
24.3,NA,NA
"Multiplication, division","#include <stdint.h> 
  
 uint64_t f_mul (uint64_t a, uint64_t b) 
  
 { 
  
 return a*b; 
  
 }; 
  
 uint64_t f_div (uint64_t a, uint64_t b)
  
 { 
  
 return a/b; 
  
 };
  
 uint64_t f_rem (uint64_t a, uint64_t b) 
  
 { 
  
 return a % b; 
  
 };
  
  
 24.3.1
  
 x86
  
 Listing 24.9: Optimizing MSVC 2013 /Ob1
  
  
  
 _a$ = 8 ; size = 8
  
   
 _b$ = 16 ; size = 8",NA
24.4,NA,NA
Shifting right,"#include <stdint.h> 
  
 uint64_t f (uint64_t a)
  
 { 
  
 return a>>7; 
  
 };
  
  
 24.4.1
  
 x86
  
 Listing 24.14: Optimizing MSVC 2012 /Ob1
  
  
 _a$ = 8
  
 PROC
  
 ; size = 8
  
 _f
  
 eax, DWORD PTR _a$[esp-4]
  
 mov
  
 mov
  
 edx, DWORD PTR _a$[esp]
  
  
 _f
  
 shrd
  
 eax, edx, 7
  
 shr
  
 edx, 7
  
 ret
  
 0
  
 ENDP
  
  
 Listing 24.15: Optimizing GCC 4.8.1 -fno-inline
  
 _f: 
  
 mov 
  
 edx, DWORD PTR [esp+8] 
  
 mov 
  
 eax, DWORD PTR [esp+4]
  
 shrd 
  
 eax, edx, 7 
  
 shr 
  
 edx, 7 
  
 ret
  
 Shifting also occurs in two passes: first the lower part is shifted, then the higher part. But the lower part is shifted with 
 the help of the
  SHRD
  instruction, it shifts the value of
  EDX
  by 7 bits, but pulls new bits from
  EAX
 , i.e., from the higher 
 part. The higher part is shifted using the more popular
  SHR
  instruction: indeed, the freed bits in the higher part must be 
 filled with zeroes.
  
 24.4.2 
  
 ARM
  
 ARM doesn’t have such instruction as SHRD in x86, so the Keil compiler ought to do this using simple shifts and OR 
 operations:
  
 Listing 24.16: Optimizing Keil 6/2013 (ARM mode)
  
 ||f|| PROC 
  
 LSR 
  
 r0,r0,#7 
  
 ORR 
  
 r0,r0,r1,LSL #25
  
 LSR 
  
 r1,r1,#7 
  
 BX 
  
 lr 
  
 ENDP
  
 Listing 24.17: Optimizing Keil 6/2013 (Thumb mode)
  
 ||f|| PROC
  
 LSLS 
  
 r2,r1,#25
  
 LSRS 
  
 r0,r0,#7",NA
24.5,NA,NA
Converting 32-bit value into 64-bit one,"#include <stdint.h> 
  
 int64_t f (int32_t a)
  
 { 
  
 return a; 
  
 };
  
  
 24.5.1
  
 x86
  
 Listing 24.19: Optimizing MSVC 2012
  
 _a$ = 8
  
 _f
  
 PROC
  
 eax, DWORD PTR _a$[esp-4]
  
 mov
  
  
 cdq
  
 _f
  
 ret
  
 0
  
 ENDP
  
  
  
 Here we also run into necessity to extend a 32-bit signed value into a 64-bit signed one.
  
 Unsigned values are converted
  
 straightforwardly: all bits in the higher part must be set to 0.
  
 But this is not appropriate for signed data types: the sign
  
 has to be copied into the higher part of the resulting number. The
  CDQ
  instruction does that here, it takes its input value 
 in
  EAX
 , extends it to 64-bit and leaves it in the
  EDX
 :
 EAX
  register pair. In other words,
  CDQ
  gets the number sign from
  EAX 
 (by getting the most significant bit in
  EAX
 ), and depending of it, sets all 32 bits in
  EDX
  to 0 or 1. Its operation is somewhat 
 similar to the
  MOVSX
  instruction.
  
 24.5.2
  
 ARM
  
 Listing 24.20: Optimizing Keil 6/2013 (ARM mode)
  
 ||f|| PROC 
  
 ASR 
  
 r1,r0,#31
  
 BX 
  
 lr
  
 ENDP
  
  
 Keil for ARM is different: it just arithmetically shifts right the input value by 31 bits.
  
 As we know, the sign bit is
  MSB
 , and
  
 the arithmetical shift copies the sign bit into the “emerged” bits. So after “ASR r1,r0,#31”, R1 containing 0xFFFFFFFF if the 
 input value was negative and 0 otherwise. R1 contains the high part of the resulting 64-bit value.
  
 In other words, this code just copies the
  MSB
  (sign bit) from the input value in R0 to all bits of the high 32-bit part of the
  
 resulting 64-bit value.",NA
Chapter 25,NA,NA
SIMD,"SIMD
  is an acronym:
  Single Instruction, Multiple Data
 .
  
 As its name implies, it processes multiple data using only one instruction.
  
 Like the
  FPU
 , that
  CPU
  subsystem looks like a separate processor inside x86.
  
 SIMD began as MMX in x86. 8 new 64-bit registers appeared: MM0-MM7.
  
 Each MMX register can hold 2 32-bit values, 4 16-bit values or 8 bytes. For example, it is possible to add 8 8-bit values 
 (bytes) simultaneously by adding two values in MMX registers.
  
 One simple example is a graphics editor that represents an image as a two dimensional array. When the user changes the 
 brightness of the image, the editor must add or subtract a coefficient to/from each pixel value. For the sake of brevity if 
 we say that the image is grayscale and each pixel is defined by one 8-bit byte, then it is possible to change the brightness 
 of 8 pixels simultaneously. By the way, this is the reason why the
  saturation
  instructions are present in SIMD. When the 
 user changes the brightness in the graphics editor, overflow and underflow are not desirable, so there are addition 
 instructions in SIMD which are not adding anything if the maximum value is reached, etc.
  
 When MMX appeared, these registers were actually located in the FPU’s registers. It was possible to use either FPU or 
 MMX at the same time. One might think that Intel saved on transistors, but in fact the reason of such symbiosis was 
 simpler —older
  OS
 es that are not aware of the additional CPU registers would not save them at the context switch, but 
 saving the FPU registers. Thus, MMX-enabled CPU + old
  OS
  + process utilizing MMX features will still work.
  
 SSE—is extension of the SIMD registers to 128 bits, now separate from the FPU.
  
 AVX—another extension, to 256 bits.
  
 Now about practical usage.
  
 Of course, this is memory copy routines (
 memcpy
 ), memory comparing (
 memcmp
 ) and so on.
  
 One more example: the DES encryption algorithm takes a 64-bit block and a 56-bit key, encrypt the block and produces a 
 64-bit result. The DES algorithm may be considered as a very large electronic circuit, with wires and AND/OR/NOT gates.
  
 Bitslice DES
 1
 —is the idea of processing groups of blocks and keys simultaneously. Let’s say, variable of type
  unsigned int
  
 on x86 can hold up to 32 bits, so it is possible to store there intermediate results for 32 block-key pairs simultaneously, 
 using 64+56 variables of type
  unsigned int
 .
  
 There is an utility to brute-force Oracle RDBMS passwords/hashes (ones based on DES), using slightly modified bitslice 
 DES algorithm for SSE2 and AVX—now it is possible to encrypt 128 or 256 block-keys pairs simultaneously.
  
 http://go.yurichev.com/17313",NA
25.1 ,NA,NA
Vectorization,"Vectorization
 2
 is when, for example, you have a loop taking couple of arrays for input and producing one array. The loop 
 body takes values from the input arrays, does something and puts the result into the output array. Vectorization is to 
 process several elements simultaneously.
  
 Vectorization is not very fresh technology: the author of this textbook saw it at least on the Cray Y-MP supercomputer line 
 from 1988 when he played with its “lite” version Cray Y-MP EL
 3
 .
  
 For example:
  
 1
 http://go.yurichev.com/17329 
  
 2
 Wikipedia: vectorization 
  
 3
 Remotely. It is installed in the museum of supercomputers:
  http://go.yurichev.com/17081",NA
25.2,NA,NA
SIMD,NA,NA
 strlen(),NA,NA
 implementation,"It has to be noted that the
  SIMD
  instructions can be inserted in C/C++ code via special macros
 7
 . For MSVC, some of them 
 are located in the
  intrin.h
  file.
  
 It is possible to implement the
  strlen()
  function
 8
 using SIMD instructions that works 2-2.5 times faster than the common 
 implementation. This function loads 16 characters into a XMM-register and check each against zero
 9
 .
  
 size_t strlen_sse2(const char *str) 
  
 { 
  
  
 register size_t len = 0; 
  
  
 const char *s=str; 
  
  
 bool str_is_aligned=(((unsigned int)str)&0xFFFFFFF0) == (unsigned int)str;
  
 if (str_is_aligned==false) 
  
 return strlen (str);
  
 __m128i xmm0 = _mm_setzero_si128(); 
  
 __m128i xmm1; 
  
 int mask = 0;
  
 for (;;) 
  
 { 
  
 xmm1 = _mm_load_si128((__m128i *)s);
  
 xmm1 = _mm_cmpeq_epi8(xmm1, xmm0); 
  
 if ((mask = _mm_movemask_epi8(xmm1)) != 0) 
  
 { 
  
  
 unsigned long pos; 
  
  
 _BitScanForward(&pos, mask); 
  
  
 len += (size_t)pos;
  
  
 break; 
  
 } 
  
 s += sizeof(__m128i); 
  
 len += sizeof(__m128i); 
  
 };
  
  
 return len; 
  
 }
  
 Let’s compile it in MSVC 2010 with
  /Ox
  option:
  
 Listing 25.2: Optimizing MSVC 2010
  
 _pos$75552 = -4 
  
 ; size = 4 
  
 _str$ = 8 
  
 ; size = 4 
  
 ?strlen_sse2@@YAIPBD@Z PROC ; strlen_sse2
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 and 
  
 esp, -16 
  
 ; fffffff0H 
  
 mov 
  
  
 eax, DWORD PTR _str$[ebp] sub 
  
 esp, 
 12 
  
 ; 0000000cH
  
 sub 
  
 esp, 12 
  
 ; 0000000cH
  
 push 
  
 esi
  
 mov 
  
 esi, eax
  
 and 
  
 esi, -16 
  
 ; fffffff0H
  
 xor 
  
 edx, edx
  
 mov 
  
 ecx, eax
  
 cmp 
  
 esi, eax
  
 je 
  
 SHORT $LN4@strlen_sse
  
 lea 
  
 edx, DWORD PTR [eax+1]
  
 7
 MSDN: MMX, SSE, and SSE2 Intrinsics 
  
 8
 strlen() —standard C library function for calculating string length 
  
 9
 The example is based on source code from:
  http://go.yurichev.com/17330
 .",NA
Chapter 26,NA,NA
64 bits,NA,NA
26.1 ,NA,NA
x86-64,"It is a 64-bit extension to the x86 architecture.
  
 From the reverse engineer’s perspective, the most important changes are:
  
 • Almost all registers (except FPU and SIMD) were extended to 64 bits and got a R- prefix. 8 additional registers wer 
  
 added. Now
  GPR
 ’s are:
  RAX
 ,
  RBX
 ,
  RCX
 ,
  RDX
 ,
  RBP
 ,
  RSP
 ,
  RSI
 ,
  RDI
 ,
  R8
 ,
  R9
 ,
  R10
 ,
  R11
 ,
  R12
 ,
  R13
 ,
  R14
 ,
  R15
 .
  
 It is still possible to access the
  older
  register parts as usual. For example, it is possible to access the lower 32-bit part 
 of the
  RAX
  register using
  EAX
 :
  
 7th
 (byte number)
  
 6th
  
 5th
  
 4th
  
 3rd
  
 2nd
  
 1st
  
 0th
  
 RAX
 x64
  
  
 EAX
  
  
 AX
  
  
 AH
  
 AL
  
 The new
  R8-R15
  registers also have their
  lower parts
 :
  R8D-R15D
  (lower 32-bit parts),
  R8W-R15W
  (lower 16-bit parts), 
 R8L-R15L
  (lower 8-bit parts).
  
 7th
 (byte number)
  
 6th
  
 5th
  
 4th
  
 3rd
  
 2nd
  
 1st
  
 0th
  
 R8
  
  
 R8D
  
  
 R8W
  
  
 R8L
  
 The number of SIMD registers was doubled from 8 to 16:
  XMM0
 -
 XMM15
 .
  
 • In Win64, the function calling convention is slightly different, somewhat resembling fastcall (
  64.3 on page 649
 ) . 
 The first 4 arguments are stored in the
  RCX
 ,
  RDX
 ,
  R8
 ,
  R9
  registers, the rest —in the stack. The
  caller
  function must 
 also allocate 32 bytes so the
  callee
  may save there 4 first arguments and use these registers for its own needs. Short 
 functions may use arguments just from registers, but larger ones may save their values on the stack.
  
 System V AMD64 ABI (Linux, *BSD, Mac OS X)[
 Mit13
 ] also somewhat resembles fastcall, it uses 6 registers
  RDI
 ,
  RSI
 , 
 RDX
 ,
  RCX
 ,
  R8
 ,
  R9
  for the first 6 arguments. All the rest are passed via the stack.
  
 See also the section on calling conventions (
  64 on page 648
 ).
  
 • The C/C++
  int
  type is still 32-bit for compatibility.
  
 • All pointers are 64-bit now.
  
 This provokes irritation sometimes: now one needs twice as much memory for storing pointers, including cache 
 memory, despite the fact that x64
  CPU
 s can address only 48 bits of external
  RAM
 .
  
 Since now the number of registers is doubled, the compilers have more space for maneuvering called
  register allocation
 . 
 For us this implies that the emitted code containing less number of local variables.
  
 For example, the function that calculates the first S-box of the DES encryption algorithm processes 32/64/128/256 values 
 at once (depending on
  DES_type
  type (uint32, uint64, SSE2 or AVX)) using the bitslice DES method (read more about this 
 technique here (
  25 on page 390
 )):
  
 /* 
  
 * Generated S-box files. 
  
 * Generated S-box files. 
  
 *",NA
26.2 ,NA,NA
ARM,"64-bit instructions appeared in ARMv8.
  
 409",NA
26.3 ,NA,NA
Float point numbers,"CHAPTER 26. 64 BITS
  
 How floating point numbers are processed in x86-64 is explained here:
  27 on the following page
 .
  
 410",NA
Chapter 27,NA,NA
Working with floating point numbers using SIMD,"Of course, the
  FPU
  has remained in x86-compatible processors when the
  SIMD
  extensions were added. 
 The
  SIMD
  extensions (SSE2) offer an easier way to work with floating-point numbers.
  
 The number format remains the same (IEEE 754).
  
 So, modern compilers (including those generating for x86-64) usually use
  SIMD
  instructions instead of FPU ones. 
 It can be said that it’s good news, because it’s easier to work with them.
  
 We are going to reuse the examples from the FPU section here:
  17 on page 205
 .",NA
27.1,NA,NA
Simple example,"#include <stdio.h>
  
 double f (double a, double b) 
  
 { 
  
 return a/3.14 + b*4.1; 
  
 };
  
 int main() 
  
 { 
  
 printf (""%f\n"", f(1.2, 3.4)); 
  
 };
  
  
 27.1.1
  
 x64
  
 Listing 27.1: Optimizing MSVC 2012 x64
  
 __real@4010666666666666 DQ 04010666666666666r 
  
 ; 4.1 
 __real@40091eb851eb851f DQ 040091eb851eb851fr 
  
 ; 3.14
  
 a$ = 8 
  
 b$ = 16 
  
 f PROC
  
  
 f
  
 divsd
  
 xmm0, QWORD PTR __real@40091eb851eb851f
  
 mulsd
  
 xmm1, QWORD PTR __real@4010666666666666
  
 addsd
  
 xmm0, xmm1
  
 ret
  
 0
  
 ENDP
  
  
 The input floating point values are passed in the
  XMM0
 -
 XMM3
  registers, all the rest—via the stack
 1
 .
  
 a
  is passed in
  XMM0
 ,
  b
 —via
  XMM1
 . The XMM-registers are 128-bit (as we know from the section about
  SIMD
 :
  25 on page 
 390
 ), but the
  double
  values are 64 bit, so only lower register half is used.
  
 DIVSD
  is an SSE-instruction that stands for “Divide Scalar Double-Precision Floating-Point Values”, it just divides one value 
 of type
  double
  by another, stored in the lower halves of operands.
  
 1
 MSDN: Parameter Passing
  
 411",NA
27.2 Passing floating point number via arguments,"#include <math.h> 
  
 #include <stdio.h>
  
 int main () 
  
 {
  
 printf (""32.01 ^ 1.54 = %lf\n"", pow (32.01,1.54)); return 0; 
  
 }
  
 They are passed in the lower halves of the
  XMM0
 -
 XMM3
  registers. 
  
  
 Listing 27.5: Optimizing MSVC 2012 x64
  
 $SG1354 DB 
  
 '32.01 ^ 1.54 = %lf', 0aH, 00H
  
 __real@40400147ae147ae1 DQ 040400147ae147ae1r 
  
 ; 32.01
  
 __real@3ff8a3d70a3d70a4 DQ 03ff8a3d70a3d70a4r 
  
 ; 1.54
  
 main 
  
 PROC
  
 sub 
  
 rsp, 40 
  
 ; 00000028H
  
 movsdx 
  
 xmm1, QWORD PTR __real@3ff8a3d70a3d70a4
  
 movsdx 
  
 xmm0, QWORD PTR __real@40400147ae147ae1
  
 main
  
 call
  
 pow
  
 ; 00000028H
  
 lea
  
 rcx, OFFSET FLAT:$SG1354
  
 movaps
  
 xmm1, xmm0
  
 movd
  
 rdx, xmm1
  
 call
  
 printf
  
 xor
  
 eax, eax
  
 add
  
 rsp, 40
  
 ret
  
 0
  
 ENDP
  
  
 There is no
  MOVSDX
  instruction in Intel [
 Int13
 ] and AMD [
 AMD13a
 ] manuals, there it is called just
  MOVSD
 . So there are 
 two instructions sharing the same name in x86 (about the other see:
  A.6.2 on page 887
 ). Apparently, Microsoft developers 
 wanted to get rid of the mess, so they renamed it to
  MOVSDX
 . It just loads a value into the lower half of a XMM register. 
 pow()
  takes arguments from
  XMM0
  and
  XMM1
 , and returns result in
  XMM0
 . It is then moved to
  RDX
  for
  printf()
 . Why? 
 Maybe because
  printf()
 —is a variable arguments function?
  
 Listing 27.6: Optimizing GCC 4.4.6 x64
  
 .LC2: 
  
 .string ""32.01 ^ 1.54 = %lf\n"" 
  
 main: 
  
 sub 
  
 rsp, 8 
  
 movsd 
  
 xmm1, QWORD PTR .LC0[rip] 
  
 movsd 
  
  
 xmm0, QWORD PTR .LC1[rip] call 
  
 pow 
  
 ; result is now in XMM0 
  
 mov 
  
 edi, OFFSET FLAT:.LC2 
  
 mov 
  
 eax, 1 ; number of vector registers passed
  
 call 
  
 printf 
  
 xor 
  
 eax, eax 
  
 add 
  
 rsp, 8 
  
 ret 
  
 .LC0: 
  
 .long 
  
 171798692 
  
 .long 
  
 1073259479 
  
 .LC1: 
  
 .long 
  
 2920577761 
  
 .long 
  
 1077936455
  
 GCC generates clearer output. The value for
  printf()
  is passed in
  XMM0
 . By the way, here is a case when 1 is written into 
 EAX
  for
  printf()
 —this implies that one argument will be passed in vector registers, just as the standard requires [
 Mit13
 ].",NA
27.3 Comparison example,"CHAPTER 27. WORKING WITH FLOATING POINT NUMBERS USING SIMD
  
  
 #include <stdio.h>
  
 double d_max (double a, double b) 
  
 { 
  
 if (a>b) 
  
  
  
 return a;
  
 return b;
  
 };
  
 int main() 
  
 { 
  
 printf (""%f\n"", d_max (1.2, 3.4)); 
  
 printf (""%f\n"", d_max (5.6, -4)); 
  
 };
  
  
 27.3.1
  
 x64
  
 Listing 27.7: Optimizing MSVC 2012 x64
  
 a$ = 8 
  
 b$ = 16
  
 d_max
  
 PROC
  
 xmm0, xmm1
  
 comisd
  
 ja
  
 SHORT $LN2@d_max
  
  
 movaps 
  
 xmm0, xmm1
  
 $LN2@d_max:
  
 d_max
  
 fatret
  
 0
  
 ENDP
  
  
 Optimizing MSVC generates a code very easy to understand.
  
 COMISD
  is “Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS”. Essentially, that is what it 
 does.
  
 Non-optimizing MSVC generates more redundant code, but it is still not hard to understand:
  
 Listing 27.8: MSVC 2012 x64
  
 a$ = 8 
  
 b$ = 16
  
 d_max
  
 PROC
  
 QWORD PTR [rsp+16], xmm1
  
 movsdx
  
 movsdx
  
 QWORD PTR [rsp+8], xmm0
  
 movsdx
  
 xmm0, QWORD PTR a$[rsp]
  
 comisd
  
 xmm0, QWORD PTR b$[rsp]
  
 jbe
  
 SHORT $LN1@d_max
  
  
 movsdx 
  
 xmm0, QWORD PTR a$[rsp]
  
 jmp 
  
 SHORT $LN2@d_max
  
 $LN1@d_max:
  
 movsdx 
  
 xmm0, QWORD PTR b$[rsp]
  
 $LN2@d_max:
  
 d_max
  
 fatret
  
 0
  
 ENDP
  
  
 However, GCC 4.4.6 did more optimizations and used the
  MAXSD
  (“Return Maximum Scalar Double-Precision Floating-
 Point Value”) instruction, which just choose the maximum value!
  
 Listing 27.9: Optimizing GCC 4.4.6 x64
  
 d_max: 
  
 maxsd 
  
 xmm0, xmm1
  
 ret",NA
27.4 Calculating machine epsilon: x64 and SIMD,"Let’s revisit the “calculating machine epsilon” example for
  double
  listing.
 22.2.2
 .
  
 Now we compile it for x64: 
  
  
 Listing 27.11: Optimizing MSVC 2012 x64
  
 421",NA
27.5 Pseudo-random number generator example revisited,"Let’s revisit “pseudo-random number generator example” example 
 listing.
 22.1
 . If we compile this in MSVC 2012, it will use the SIMD instructions 
 for the FPU.
  
 Listing 27.12: Optimizing MSVC 2012
  
 __real@3f800000 DD 03f800000r 
  
 ; 1
  
 tv128 = -4 
  
 _tmp$ = -4 
  
 ?float_rand@@YAMXZ PROC 
  
 push 
  
 ecx 
  
 call 
  
 ?my_rand@@YAIXZ 
  
 ; EAX=pseudorandom value
  
 and
  
 eax, 8388607
  
 ; 007fffffH
  
 or
  
 eax, 1065353216
  
 ; 3f800000H
  
 ; EAX=pseudorandom value & 0x007fffff | 0x3f800000 ; store it into 
 local stack:
  
 mov 
  
 DWORD PTR _tmp$[esp+4], eax 
  
 ; reload it as float point number: 
  
 movss 
  
 xmm0, DWORD PTR _tmp$[esp+4] 
  
 ; subtract 1.0: 
  
 subss 
  
 xmm0, DWORD PTR __real@3f800000 
  
 ; move value to ST0 by placing it in temporary variable...
  
 movss 
  
 DWORD PTR tv128[esp+4], xmm0 
  
 ; ... and reloading it into ST0: 
  
 fld 
  
 DWORD PTR tv128[esp+4] 
  
 pop 
  
 ecx 
  
 ret 
  
  
 0 ?float_rand@@YAMXZ ENDP
  
  
 All instructions have the -SS suffix, which stands for “Scalar Single”. 
 register. “Single” stands for
  float
  data type.",NA
27.6 Summary,"“Scalar” implies that only one value is stored in the
  
 Only the lower half of XMM registers is used in all examples here, to store number in IEEE 754 format.
  
 Essentially, all instructions prefixed by
  -SD
  (“Scalar Double-Precision”)—are instructions working with floating point 
 numbers in IEEE 754 format, stored in the lower 64-bit half of a XMM register.
  
 And it is easier than in the FPU, probably because the SIMD extensions were evolved in a less chaotic way than the FPU 
 ones in the past. The stack register model is not used.
  
 2
 As an exercise, you may try to rework this code to eliminate the usage of the local stack.",NA
Chapter 28,NA,NA
ARM-specific details,NA,NA
28.1,NA,NA
Number sign (#) before number,"The Keil compiler,
  IDA
  and objdump precede all numbers with the “#” number sign, for example: listing.
 14.1.4
 . But when
  
 GCC 4.9 generates assembly language output, it doesn’t, for example: listing.
 39.3
 .
  
 The ARM listings in this book are somewhat mixed.
  
 It’s hard to say, which method is right. Supposedly, one has to obey the rules accepted in environment he/she works in.",NA
28.2 ,NA,NA
Addressing modes,"This instruction is possible in ARM64:
  
 ldr x0, [x29,24]
  
  
  
 This means add 24 to the value in X29 and load the value from this address. 
 The meaning is different if the number is outside the brackets:
  
 Please note that 24 is inside the brackets.
  
 ldr w4, [x1],28
  
  
 This means load the value at the address in X1, then add 28 to X1.
  
 ARM allows you to add or subtract a constant to/from the address used for loading. And it’s possible to do that both before 
 and after loading.
  
 There is no such addressing mode in x86, but it is present in some other processors, even on PDP-11. There is a legend that 
 the pre-increment, post-increment, pre-decrement and post-decrement modes in PDP-11, were “guilty” for the appearance
  
 of such C language (which developed on PDP-11) constructs as *ptr++, *++ptr, *ptr--, *--ptr.
  
 By the way, this is one of the
  
 hard to memorize C features. This is how it is:
  
  
 C term
  
 ARM term
  
 C statement
  
 how it works
  
 Post-increment
  
 post-indexed addressing
  
 *ptr++
  
 use
  *ptr
  value, 
  
 then
  increment
  ptr
  pointer
  
 Post-decrement
  
 post-indexed addressing
  
 *ptr--
  
 use
  *ptr
  value, 
  
 then
  decrement
  ptr
  pointer
  
 Pre-increment
  
 pre-indexed addressing
  
 *++ptr
  
 increment
  ptr
  pointer, 
 then use
  *ptr
  value
  
 Pre-decrement
  
 pre-indexed addressing
  
 *--ptr
  
 decrement
  ptr
  pointer, 
 then use
  *ptr
  value
  
 Pre-indexing is marked with an exclamation mark in the ARM assembly language. For example, see line 2 in listing.
 3.15
 .
  
 Dennis Ritchie (one of the creators of the C language) mentioned that it probably was invented by Ken Thompson (another 
 C creator) because this processor feature was present in PDP-7 [
 Rit86
 ][
 Rit93
 ]. 
  
 Thus, C language compilers may use it, if it 
 is present on the target processor.
  
 That’s very convenient for array processing.
  
 424",NA
28.3 ,NA,NA
Loading a constant into a register,"CHAPTER 28. ARM-SPECIFIC DETAILS
  
 28.3.1
  
 32-bit ARM
  
 Aa we already know, all instructions have a length of 4 bytes in ARM mode and 2 bytes in Thumb mode. Then how can we 
 load a 32-bit value into a register, if it’s not possible to encode it in one instruction?
  
 Let’s try:
  
 unsigned int f() 
  
 {
  
 return 0x12345678; 
  
 };
  
 Listing 28.1: GCC 4.6.3 -O3 ARM mode
  
 f:
  
 ldr 
  
 r0, .L2
  
 bx 
  
 lr
  
 .L2: 
  
 .word 
  
 305419896 ; 0x12345678
  
 So, the
  0x12345678
  value is just stored aside in memory and loaded if needed. But it’s possible to get rid of the additional 
 memory access.
  
 Listing 28.2: GCC 4.6.3 -O3 -march=armv7-a (ARM mode)
  
  
 movw
  
 r0, #22136
  
 ; 0x5678
  
 movt
  
 r0, #4660
  
 ; 0x1234
  
 bx
  
 lr
  
  
  
 We see that the value is loaded into the register by parts, the lower part first (using MOVW), then the higher (using MOVT).
  
 This implies that 2 instructions are necessary in ARM mode for loading a 32-bit value into a register. It’s not a real problem, 
 because in fact there are not many constants in real code (except of 0 and 1). Does it mean that the two-instruction version 
 is slower than one-instruction version? Doubtfully. Most likely, modern ARM processors are able to detect such sequences 
 and execute them fast.
  
 On the other hand,
  IDA
  is able to detect such patterns in the code and disassembles this function as:
  
 MOV 
  
 R0, 0x12345678
  
 BX 
  
 LR
  
  
 28.3.2
  
 ARM64
  
  
 uint64_t f() 
  
 {
  
 return 0x12345678ABCDEF01; 
  
 };
  
 Listing 28.3: GCC 4.9.1 -O3
  
 mov x0, 61185 
  
 ; 0xef01
  
 movk 
  
 x0, 0xabcd, lsl 16
  
 movk 
  
 x0, 0x5678, lsl 32
  
 movk 
  
 x0, 0x1234, lsl 48
  
 ret
  
 MOVK
  stands for “MOV Keep”, i.e., it writes a 16-bit value into the register, not touching the rest of the bits. The
  LSL
  
 suffix shifts left the value by 16, 32 and 48 bits at each step. The shifting is done before loading. This implies that 4 
 instructions are necessary to load a 64-bit value into a register.",NA
28.4,NA,NA
Relocs in ARM64,"As we know, there are 4-byte instructions in ARM64, so it is impossible to write a large number into a register using a 
 single instruction. Nevertheless, an executable image can be loaded at any random address in memory, so that’s why relocs 
 exists. Read more about them (in relation to Win32 PE):
  68.2.6 on page 673
 .
  
 The address is formed using the
  ADRP
  and
  ADD
  instruction pair in ARM64. 
  
 The first loads a 4KiB-page address and the 
 second one adds the remainder. Let’s compile the example from “Hello, world!” (listing.
 6
 ) in GCC (Linaro) 4.9 under win32:
  
 Listing 28.6: GCC (Linaro) 4.9 and objdump of object file
  
 ...>aarch64-linux-gnu-gcc.exe hw.c -c 
  
 ...>aarch64-linux-gnu-objdump.exe -d hw.o 
  
 ...
  
 0000000000000000 <main>:
  
 0:
  
 a9bf7bfd
  
 stp
  
 x29, x30, [sp,#-16]!
  
 4:
  
 910003fd
  
 mov
  
 x29, sp
  
 8:
  
 90000000
  
 adrp
  
 x0, 0 <main>
  
  
  
 c:
  
 91000000
  
 add
  
 x0, x0, #0x0
  
 // #0
  
 10:
  
 94000000
  
 bl
  
 0 <printf>
  
 14:
  
 52800000
  
 mov
  
 w0, #0x0
  
 18:
  
 a8c17bfd
  
 ldp
  
 x29, x30, [sp],#16
  
 1c:
  
 d65f03c0
  
 ret
  
 ...>aarch64-linux-gnu-objdump.exe -r hw.o
  
 ...
  
 1
 wikipedia
  
 426",NA
Chapter 29,NA,NA
MIPS-specific details,NA,NA
29.1,NA,NA
Loading constants into register,"unsigned int f() 
  
 {
  
 return 0x12345678; 
  
 };
  
 All instructions in MIPS, just like ARM, have a of 32-bit, so it’s not possible to embed a 32-bit constant into one instruction. 
 So this translates to at least two instructions: the first loads the high part of the 32-bit number and the second one applies 
 an OR operation, which effectively sets the low 16-bit part of the target register:
  
 Listing 29.1: GCC 4.4.5 -O3 (assembly output)
  
  
 li
  
 $2,305397760
  
 # 0x12340000
  
 j
  
 $31
  
 ori
  
 $2,$2,0x5678 ; branch delay slot
  
  
  
 IDA
  is fully aware of such frequently encountered code patterns, so, for convenience it shows the last ORI instruction as the 
 LI pseudoinstruction, which allegedly loads a full 32-bit number into the $V0 register.
  
 Listing 29.2: GCC 4.4.5 -O3 (IDA)
  
 lui $v0, 0x1234
  
 jr $ra
  
 li $v0, 0x12345678 ; branch delay slot
  
  
 The GCC assembly output has the LI pseudoinstruction, but in fact, LUI (“Load Upper Imeddiate”) is there, which stores a 
 16-bit value into the high part of the register.",NA
29.2 ,NA,NA
Further reading about MIPS,"[
 Swe10
 ].",NA
Part II ,NA,NA
Important fundamentals,429,NA
Chapter 30,NA,NA
Signed number representations,"There are several methods for representing signed numbers
 1
 , but “two’s complement” is the most popular one in 
 computers. Here is a table for some byte values:
  
 binary
  
 hexadecimal
  
 unsigned
  
 signed (2’s complement)
  
 01111111
  
 0x7f
  
 127
  
 127
  
 01111110
  
 0x7e
  
 126
  
 126
  
 ...
  
 00000110
  
 0x6
  
 6
  
 6
  
 00000101
  
 0x5
  
 5
  
 5
  
 00000100
  
 0x4
  
 4
  
 4
  
 00000011
  
 0x3
  
 3
  
 3
  
 00000010
  
 0x2
  
 2
  
 2
  
 00000001
  
 0x1
  
 1
  
 1
  
 00000000
  
 0x0
  
 0
  
 0
  
 11111111
  
 0xff
  
 255
  
 -1
  
 11111110
  
 0xfe
  
 254
  
 -2
  
 11111101
  
 0xfd
  
 253
  
 -3
  
 11111100
  
 0xfc
  
 252
  
 -4
  
 11111011
  
 0xfb
  
 251
  
 -5
  
 11111010
  
 0xfa
  
 250
  
 -6
  
 ...
  
 10000010
  
 0x82
  
 130
  
 -126
  
 10000001
  
 0x81
  
 129
  
 -127
  
 10000000
  
 0x80
  
 128
  
 -128
  
 The difference between signed and unsigned numbers is that if we represent
  0xFFFFFFFE
  and
  0x00000002
  as unsigned, 
 then the first number (4294967294) is bigger than the second one (2). If we represent them both as signed, the first one 
 becomes
  −2
 , and it is smaller than the second (2). That is the reason why conditional jumps (
  12 on page 114
 ) are present 
 For the sake of simplicity, this is what one needs to know:
  
 • Numbers can be signed or unsigned.
  
 • C/C++ signed types:
  
  
 –
  int64_t
  (-9,223,372,036,854,775,808..9,223,372,036,854,775,807) (- 9.2.. 9.2 quintillions) or 
  
  
 0x8000000000000000..0x7FFFFFFFFFFFFFFF
 ),
  
  
 –
  int
  (-2,147,483,648..2,147,483,647 (- 2.15.. 2.15Gb) or
  0x80000000..0x7FFFFFFF
 ),
  
 –
  char
  (-
 128..127 or
  0x80..0x7F
 ),
  
  
 –
  ssize_t
 .
  
 Unsigned:
  
 –
  uint64_t
  (0..18,446,744,073,709,551,615 ( 18 quintillions) or
  0..0xFFFFFFFFFFFFFFFF
 ),
 –
  
 unsigned int
  (0..4,294,967,295 ( 4.3Gb) or
  0..0xFFFFFFFF
 ),
  
 –
  unsigned char
  (0..255 or
  0..0xFF
 ),
  
 1
 wikipedia",NA
Chapter 31,NA,NA
Endianness,The endianness is a way of representing values in memory.,NA
31.1 ,NA,NA
Big-endian,"The
  0x12345678
  value is represented in memory as:
  
 address in memory
  
 byte value
  
 +0
  
 0x12
  
 +1
  
 0x34
  
 +2
  
 0x56
  
 +3
  
 0x78
  
 Big-endian CPUs include Motorola 68k, IBM POWER.",NA
31.2 ,NA,NA
Little-endian,"The
  0x12345678
  value is represented in memory as:
  
 address in memory
  
 byte value
  
 +0
  
 0x78
  
 +1
  
 0x56
  
 +2
  
 0x34
  
 +3
  
 0x12
  
 Little-endian CPUs include Intel x86.",NA
31.3 ,NA,NA
Example,"Let’s take big-endian MIPS Linux installed and ready in QEMU
 1
 . 
 And let’s compile this simple example:
  
 #include <stdio.h> 
  
 int main() 
  
 { 
  
 int v, i; 
  
 v=123;
  
 printf (""%02X %02X %02X %02X\n"", 
  
  
  
 *(char*)&v, 
  
  
  
 *(((char*)&v)+1), 
  
  
  
 *(((char*)&v)+2), 
  
  
  
 *(((char*)&v)+3)); 
  
 };
  
 1
 Available for download here:
  http://go.yurichev.com/17008
  
 433",NA
31.4 ,NA,NA
Bi-endian,"CPUs that may switch between endianness are ARM, PowerPC, SPARC, MIPS,
  IA64
 2
 , etc.",NA
31.5 ,NA,NA
Converting data,"The
  BSWAP
  instruction can be used for conversion.
  
 TCP/IP network data packets use the big-endian conventions, so that is why a program working on a little-endian 
 architecture has to convert the values.
  
 The
  htonl()
  and
  htons()
  functions are usually used.
  
 In TCP/IP, big-endian is also called “network byte order”, while byte order on the computer “host byte order”. “host byte 
 order” is little-endian on Intel x86 and other little-endian architectures, but it is big-endian on IBM POWER, so
  htonl() 
 and
  
 htons()
  don’t shuffle any bytes on the latter.
  
 2
 Intel Architecture 64 (Itanium):
  93 on page 865",NA
Chapter 32,NA,NA
Memory,"There are 3 main types of memory:
  
 • Global memory
  AKA
  “static memory allocation”. No need to allocate explicitly, the allocation is done just by declaring 
 variables/arrays globally. These are global variables, residing in the data or constant segments. They are available 
 globally (hence, considered as an
  anti-pattern
 ). Not convenient for buffers/arrays, because they must have a fixed 
 size. Buffer overflows that occur here usually overwrite variables or buffers residing next to them in memory. There’s 
 an example in this book:
  7.2 on page 67
 .
  
 • Stack
  AKA
  “allocate on stack”. The allocation is done just by declaring variables/arrays locally in the function. These 
   
 are usually local variables for the function. Sometimes these local variable are also available to descending 
 functions 
  
 (to
  callee
  functions, if 
 caller passes a pointer to a variable to the
  callee
  to be executed). Allocation and deallocation 
   
 are very fast, it just
  
 SP
  needs to be shifted. But they’re also not convenient for buffers/arrays, because the buffer size 
   
 has to be 
 fixed, unless
  alloca()
  (
  5.2.4 on page 26
 ) (or a variable-length array) is used. 
  
 Buffer overflows usually 
   
 overwrite important stack structures:
  18.2 on page 260
 .
  
 • Heap
  AKA
  “dynamic memory allocation”. Allocation/deallocation is done by calling
  malloc()/free()
  or
  new/delete 
  
 in C++. 
  
 This is the most convenient method: the block size may be set at runtime. Resizing is possible (using 
  
 realloc()
 ), but can be slow. 
  
 This is the slowest way to allocate memory: the memory allocator must support 
  
 and update all control structures while allocating and deallocating. Buffer overflows usually overwrite these struc-
  
 tures. Heap allocations are also source of memory leak problems: each memory block has to be deallocated explicitly, 
  
 but one may forget about it, or do it incorrectly. Another problem is the “use after free”—using a memory block after 
  
 free()
  was called on it, which is very dangerous. Example in this book:
  21.2 on page 331
 .",NA
Chapter 33,NA,NA
CPU,NA,NA
33.1 ,NA,NA
Branch predictors,"Some modern compilers try to get rid of conditional jump instructions. Examples in this book are:
  12.1.2 on page 125
 ,
  12.3 
 on page 132
 ,
  19.5.2 on page 314
 .
  
 This is because the branch predictor is not always perfect, so the compilers try to do without conditional jumps, if 
 possible. Conditional instructions in ARM (like ADRcc) are one way, another one is the CMOVcc x86 instruction.",NA
33.2 ,NA,NA
Data dependencies,"Modern CPUs are able to execute instructions simultaneously (
 OOE
 1
 ), but in order to do so, the results of one instruction 
 in a group must not influence the execution of others. Hence, the compiler endeavors to use instructions with minimal 
 influence on the CPU state.
  
 That’s why the
  LEA
  instruction is so popular, because it does not modify CPU flags, while other arithmetic instructions 
 does.
  
 1
 Out-of-order execution",NA
Chapter 34,NA,NA
Hash functions,"A very simple example is CRC32, an algorithm that provides “stronger” checksum for integrity checking purposes. It is im-
 possible to restore the original text from the hash value, it has much less information: But CRC32 is not cryptographically 
 secure: it is known how to alter a text in a way that the resulting CRC32 hash value will be the one we need. Cryptographic 
 hash functions are protected from this.
  
 MD5, SHA1, etc are such functions and they are widely used to hash user passwords in order to store them in a database. 
 Indeed: an internet forum database may not contain user passwords (a stolen database can compromise all users’ 
 passwords) but only hashes (so a cracker can’t reveal the passwords). Besides, an internet forum engine does not need to be 
 aware of your password, it needs only to check if its hash is the same as the one in the database, and give you access if 
 they match. One of the simplest password cracking methods is just to try hashing all possible passwords in order to see 
 which matches the resulting value that we need. Other methods are much more complex.",NA
34.1 ,NA,NA
How do one-way functions work?,"A one-way function is a function which is able to transform one value into another, while it is impossible (or very hard) to 
 reverse it. Some people have difficulties while understanding how this is possible at all. Here is a simple demonstration.
  
 We have a vector of 10 numbers in range 0..9, each is present only once, for example:
  
 4 6 0 1 3 5 7 8 9 2
  
  
 The algorithm for the simplest possible one-way function is:
  
 • take the number at zeroth position (4 in our case);
  
 • take the number at first position (6 in our case);
  
 • swap numbers at positions of 4 and 6.
  
 Let’s mark the numbers at positions 4 and 6:
  
 4 6 0 1 3 5 7 8 9 2
  
 ^ 
  
 ^
  
 Let’s swap them and we get this result:
  
 4 6 0 1 7 5 3 8 9 2
  
  
 While looking at the result, and even if we know the algorithm, we can’t know unambiguously the initial state, because the 
 first two numbers could be 0 and/or 1, and then they could participate in the swapping procedure.
  
 This is an utterly simplified example for demonstration. Real one-way functions are much more complex.",NA
Part III ,NA,NA
Slightly more advanced examples,438,NA
Chapter 35,NA,NA
Temperature converting,"Another very popular example in programming books for beginners is a small program that converts Fahrenheit temperature
  
 to Celsius or back.
  
 C
  = 5 ⋅ (
 F
  − 32)
  
 We can also add simple error handling: 1) we must check if the user has entered a correct number; 2) we must check if the
  
 Celsius temperature is not below
  −273
  (which is below absolute zero, as we may remember from school physics lessons).",NA
35.1,NA,NA
Integer values,"#include <stdio.h> 
  
 #include <stdlib.h>
  
 int main() 
  
 { 
  
 int celsius, fahr; 
  
 printf (""Enter temperature in Fahrenheit:\n""); 
  
 if (scanf (""%d"", &fahr)!=1) 
  
 { 
  
  
  
 printf (""Error while parsing your input\n""); 
  
  
 exit(0);
  
 };
  
 celsius = 5 * (fahr-32) / 9;
  
 if (celsius<-273) 
  
 { 
  
  
  
 printf (""Error: incorrect temperature!\n""); 
   
 exit(0); 
  
 }; 
  
 printf (""Celsius: %d\n"", celsius); 
  
 };
  
  
 35.1.1
  
 Optimizing MSVC 2012 x86
  
 Listing 35.1: Optimizing MSVC 2012 x86
  
 $SG4228 DB 
  
 'Enter temperature in Fahrenheit:', 0aH, 00H
  
 $SG4230 DB 
  
 '%d', 00H
  
 $SG4231 DB 
  
 'Error while parsing your input', 0aH, 00H
  
 $SG4233 DB 
  
 'Error: incorrect temperature!', 0aH, 00H
  
 $SG4234 DB
  
 'Celsius: %d', 0aH, 00H
  
 ; size = 4
  
 _fahr$ = -4
  
 _main
  
 PROC",NA
35.2,NA,NA
Floating-point values,"#include <stdio.h> 
  
 #include <stdlib.h>
  
 int main() 
  
 { 
  
 double celsius, fahr; 
  
 printf (""Enter temperature in Fahrenheit:\n""); 
  
 if (scanf (""%lf"", &fahr)!=1) 
  
 { 
  
  
  
 printf (""Error while parsing your input\n""); 
  
  
 exit(0);
  
 };
  
 celsius = 5 * (fahr-32) / 9;
  
 if (celsius<-273) 
  
 { 
  
  
  
 printf (""Error: incorrect temperature!\n""); 
   
 exit(0); 
  
 }; 
  
 printf (""Celsius: %lf\n"", celsius); 
  
 };
  
 MSVC 2010 x86 uses
  FPU
  instructions…
  
  
 Listing 35.2: Optimizing MSVC 2010 x86
  
 $SG4038 DB 
  
 'Enter temperature in Fahrenheit:', 0aH, 00H $SG4040 DB 
  
 '%lf', 00H 
  
 $SG4041 DB 
  
 'Error while parsing your input', 0aH, 00H $SG4043 DB 
  
 'Error: incorrect temperature!', 0aH, 00H $SG4044 DB 
  
 'Celsius: %lf', 0aH, 00H
  
 __real@c071100000000000 DQ 0c071100000000000r 
  
 ; -273 
 __real@4022000000000000 DQ 04022000000000000r 
  
 ; 9 
 __real@4014000000000000 DQ 04014000000000000r 
  
 ; 5 
 __real@4040000000000000 DQ 04040000000000000r 
  
 ; 32
  
 _fahr$ = -8 
  
 ; size = 8
  
 _main
  
 PROC
  
 esp, 8
  
 sub
  
 push
  
 esi
  
 mov
  
 esi, DWORD PTR __imp__printf
  
 push
  
 OFFSET $SG4038
  
 ; 'Enter temperature in Fahrenheit:'
  
 call
  
 esi
  
 ; call printf()
  
 lea
  
 eax, DWORD PTR _fahr$[esp+16]
  
 push
  
 eax
  
 push
  
 OFFSET $SG4040
  
 ; '%lf'
  
 call
  
 DWORD PTR __imp__scanf
  
 add
  
 esp, 12
  
 ; 0000000cH
  
 cmp
  
 eax, 1
  
 je
  
 SHORT $LN2@main
  
  
 1
 another popular one is
  longjmp()
  
 441",NA
Chapter 36,NA,NA
Fibonacci numbers,"Another widespread example used in programming textbooks is a recursive function that generates the Fibonacci 
 numbers
 1
 . The sequence is very simple: each consecutive number is the sum of the previous two. The first two numbers are 
 1’s or 0, 1 and 1.
  
 The sequence starts like this:
  
 0
 ,
 1
 ,
 1
 ,
 2
 ,
 3
 ,
 5
 ,
 8
 ,
 13
 ,
 21
 ,
 34
 ,
 55
 ,
 89
 ,
 144
 ,
 233
 ,
 377
 ,
 610
 ,
 987
 ,
 1597
 ,
 2584
 ,
 4181
 ...",NA
36.1 ,NA,NA
Example #1,"The implementation is simple. This program generates the sequence until 21.
  
 #include <stdio.h>
  
 void fib (int a, int b, int limit) 
  
 { 
  
 printf (""%d\n"", a+b); 
  
 if (a+b > limit) 
  
  
  
 return; 
  
 fib (b, a+b, limit);
  
 };
  
 int main() 
  
 { 
  
 printf (""0\n1\n1\n""); 
  
 fib (1, 1, 20); 
  
 };
  
 Listing 36.1: MSVC 2010 x86
  
 _a$ = 8 
  
   
  
 ; size = 4 
  
 _b$ = 12 
    
 ; size = 4 
  
 _limit$ = 16 
  
  
 ; size = 4 
  
 _fib 
  
 PROC 
  
  
 push 
  
 ebp 
  
  
 mov 
  
 ebp, esp 
  
  
 mov 
  
 eax, DWORD PTR _a$[ebp] 
  
  
 add 
  
 eax, DWORD PTR _b$[ebp] 
  
  
 push 
  
 eax 
  
  
 push 
  
 OFFSET $SG2643
  
 call 
  
 DWORD PTR __imp__printf 
  
 add 
  
 esp, 8 
  
 mov 
  
 ecx, DWORD PTR _a$[ebp] 
  
 add 
  
 ecx, DWORD PTR _b$[ebp] 
  
 cmp 
  
 ecx, DWORD PTR _limit$[ebp] 
  
 jle 
  
 SHORT $LN1@fib 
  
 jmp 
  
 SHORT $LN2@fib 
  
 $LN1@fib: 
  
 mov 
  
  
 edx, DWORD PTR _limit$[ebp] push 
  
 edx
  
 1
 http://go.yurichev.com/17332
  
 444",NA
36.2 ,NA,NA
Example #2,"My function has some redundancy, so let’s add a new local variable
  next
  and replace all “a+b” with it:
  
 #include <stdio.h>
  
 void fib (int a, int b, int limit) 
  
 { 
  
 int next=a+b;
  
 printf (""%d\n"", next); 
  
 if (next > limit) 
  
  
 return; 
  
 fib (b, next, limit);
  
 2
 By the way, it’s possible to select several entries in OllyDbg and copy them to the clipboard (Ctrl-C). That’s what was done for this example. 
 3
 i.e., it calls itself",NA
36.3 ,NA,NA
Summary,"Recursive functions are æsthetically nice, but technically may degrade performance because of their heavy stack usage. 
 Everyone who writes performance critical code probably should should avoid recursion.
  
 For example, the author of this book once wrote a function to seek a particular node in a binary tree. As a recursive 
 function it looked quite stylish but since additional time was spent at each function call for the prologue/epilogue, it was 
 working a couple of times slower than an iterative (recursion-free) implementation.
  
 By the way, that is the reason that some functional
  PL
 4
 compilers (where recursion is used heavily) use
  tail call
 .
  
 4
 LISP, Python, Lua, etc.
  
 450",NA
Chapter 37,NA,NA
CRC32 calculation example,"This is a very popular table-based CRC32 hash calculation technique
 1
 .
  
 /* By Bob Jenkins, (c) 2006, Public Domain */
  
 #include <stdio.h> 
  
 #include <stddef.h> 
  
 #include <string.h>
  
 typedef
  
 unsigned long
  
 ub4;
  
 typedef
  
 unsigned char
  
 ub1;
  
 static const ub4 crctab[256] = { 
  
 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 
 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 
 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 
 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 
 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0xfa0f3d63, 
 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0x3c03e4d1, 
 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0xdbbbc9d6, 
 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0x26d930ac, 
 0x51de003a, 0xc8d75180, 0xbfd06116, 0xcfba9599, 
 0xb8bda50f, 0x2802b89e, 0x5f058808, 0x2f6f7c87, 
 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x98d220bc, 
 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x7807c9a2, 
 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x91646c97, 
 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x6c0695ed, 
 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x8bbeb8ea, 
 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x4db26158, 
 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0xa4d1c46d, 
 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0x44042d73, 
 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0xbe0b1010, 
 0xc90c2086, 0x5768b525, 0x206f85b3, 0x5edef90e, 
 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0xb7bd5c3b, 
 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0xead54739, 
 0x9dd277af, 0x04db2615, 0x73dc1683, 0x0d6d6a3e, 
 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0xf00f9344, 0x8708a3d2, 
 0x1e01f268, 0x6906c2fe, 0x196c3671, 0x6e6b06e7, 
 0xfed41b76, 0x89d32be0, 0xf9b9df6f, 0x8ebeeff9, 
 0x17b7be43, 0x60b08ed5, 0x38d8c2c4, 0x4fdff252, 
 0xd1bb67f1, 0xa6bc5767, 0xd80d2bda, 0xaf0a1b4c, 
 0x36034af6, 0x41047a60, 0x316e8eef, 0x4669be79, 
 0xcb61b38c, 0xbc66831a, 0xcc0c7795, 0xbb0b4703, 
 0x220216b9, 0x5505262f, 0x2bb45a92, 0x5cb36a04, 
 0xc2d7ffa7, 0xb5d0cf31, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 
 0x026d930a, 0x72076785, 0x05005713, 0x95bf4a82, 
 0xe2b87a14, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 
 0x0bdbdf21, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 
 0xf6b9265b, 0x88085ae6, 0xff0f6a70, 0x66063bca, 
 0x11010b5c, 0x616bffd3, 0x166ccf45, 0xa00ae278, 
 0xd70dd2ee, 0xa7672661, 0xd06016f7, 0x4969474d, 
  0x076dc419, 
 0x706af48f,
  
  0xe0d5e91e, 
 0x97d2d988,
  
  0x1db71064, 
 0x6ab020f2,
  
  0xf4d4b551, 
 0x83d385c7,
  
  0x14015c4f, 
 0x63066cd9,
  
  0xd56041e4, 
 0xa2677172,
  
  0x35b5a8fa, 
 0x42b2986c,
  
  0xdcd60dcf, 
 0xabd13d59,
  
  0x21b4f4b5, 
 0x56b3c423,
  
  0xc60cd9b2, 
 0xb10be924,
  
  0x76dc4190, 
 0x01db7106,
  
  0x9fbfe4a5, 
 0xe8b8d433,
  
  0x7f6a0dbb, 
 0x086d3d2d,
  
  0x856530d8, 
 0xf262004e,
  
  0x65b0d9c6, 
 0x12b7e950,
  
  0x8cd37cf3, 
 0xfbd44c65,
  
  0x4adfa541, 
 0x3dd895d7,
  
  0xad678846, 
 0xda60b8d0,
  
  0x5005713c, 
 0x270241aa,
  
  0xb966d409, 
 0xce61e49f,
  
  0x59b33d17, 
 0x2eb40d81,
  
  0x03b6e20c, 
 0x74b1d29a,
  
  0xe3630b12, 
 0x94643b84,
  
  0x0a00ae27, 
 0x7d079eb1,
  
  0xf762575d, 
 0x806567cb,
  
  0x10da7a5a, 
 0x67dd4acc,
  
  0xd6d6a3e8, 
 0xa1d1937e,
  
  0x3fb506dd, 
 0x48b2364b,
  
  0xdf60efc3, 
 0xa867df55,
  
  0x256fd2a0, 
 0x5268e236,
  
  0xc5ba3bbe, 
 0xb2bd0b28,
  
  0x2cd99e8b, 
 0x5bdeae1d,
  
  0x9c0906a9, 
 0xeb0e363f,
  
  0x7bb12bae, 
 0x0cb61b38,
  
  0x86d3d2d4, 
 0xf1d4e242,
  
  0x6fb077e1, 
 0x18b74777,
  
  0x8f659eff, 
 0xf862ae69,
  
  0x4e048354, 
 0x3903b3c2,
  
  0xaed16a4a, 0xd9d65adc,
  
 1
 The source code was taken from here:
  http://go.yurichev.com/17327
  
 451",NA
Chapter 38,NA,NA
Network address calculation example,"As we know, a TCP/IP address (IPv4) consists of four numbers in the
  0
 ...
 255
  range, i.e., four bytes. Four bytes can be fit in
  
 a 32-bit variable easily, so an IPv4 host address, network mask or network address can all be 32-bit integers.
  
 From the user’s point of view, the network mask is defined as four numbers and is formatted like 255.255.255.0 or so, but 
 network engineers (sysadmins) use a more compact notation (
 CIDR
 1
 ), like /8, /16 or similar. 
  
 This notation just defines the 
 number of bits the mask has, starting at the
  MSB
 .
  
  
 Mask
  
 Hosts
  
 Usable
  
 Netmask
  
 Hex mask
   
 /30
  
 4
  
 2
  
 255.255.255.252
  
 fffffffc
  
  
 /29
  
 8
  
 6
  
 255.255.255.248
  
 fffffff8
  
  
 /28
  
 16
  
 14
  
 255.255.255.240
  
 fffffff0
  
  
 /27
  
 32
  
 30
  
 255.255.255.224
  
 ffffffe0
  
  
 /26
  
 64
  
 62
  
 255.255.255.192
  
 ffffffc0
  
  
 /24
  
 256
  
 254
  
 255.255.255.0
  
 ffffff00
  
 class C network
  
 /23
  
 512
  
 510
  
 255.255.254.0
  
 fffffe00
  
  
 /22
  
 1024
  
 1022
  
 255.255.252.0
  
 fffffc00
  
  
 /21
  
 2048
  
 2046
  
 255.255.248.0
  
 fffff800
  
  
 /20
  
 4096
  
 4094
  
 255.255.240.0
  
 fffff000
  
  
 /19
  
 8192
  
 8190
  
 255.255.224.0
  
 ffffe000
  
  
 /18
  
 16384
  
 16382
  
 255.255.192.0
  
 ffffc000
  
  
 /17
  
 32768
  
 32766
  
 255.255.128.0
  
 ffff8000
  
  
 /16
  
 65536
  
 65534
  
 255.255.0.0
  
 ffff0000
  
 class B network
  
 /8
  
 16777216
  
 16777214
  
 255.0.0.0
  
 ff000000
  
 class A network
  
 Here is a small example, which calculates the network address by applying the network mask to the host address.
  
 #include <stdio.h> 
  
 #include <stdint.h>
  
 uint32_t form_IP (uint8_t ip1, uint8_t ip2, uint8_t ip3, uint8_t ip4) { 
  
 return (ip1<<24) | (ip2<<16) | (ip3<<8) | ip4; 
  
 };
  
 void print_as_IP (uint32_t a) 
  
 { 
  
 printf (""%d.%d.%d.%d\n"", 
  
  
  
 (a>>24)&0xFF,
  
  
 (a>>16)&0xFF, 
  
  
 (a>>8)&0xFF, 
  
  
 (a)&0xFF); 
  
 };
  
 // bit=31..0 
  
 uint32_t set_bit (uint32_t input, int bit) 
  
 { 
  
 return input=input|(1<<bit); 
  
 };
  
 uint32_t form_netmask (uint8_t netmask_bits)
  
 1
 Classless Inter-Domain Routing
  
 454",NA
38.1,NA,NA
calc_network_address(),"calc_network_address()
  function is simplest one: it just ANDs the host address with the network mask, resulting in
  
 the network address.
  
 Listing 38.1: Optimizing MSVC 2012 /Ob0
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1 
 1
 2 
 1
 3 
 1
 4 
 1
 5 
 1
 6 
 1
 7 
 1
 8 
 1
 _ip1$ = 8 
   
 ; size = 1 
  
 _ip2$ = 12 
  
  
 ; size = 1 
  
 _ip3$ = 16 
  
  
 ; size = 1 
  
 _ip4$ = 20 
  
  
 ; size = 1 
  
 _netmask_bits$ = 24 
  
 ; size = 1 
  
 _calc_network_address PROC 
  
 push 
  
 edi 
  
 push 
  
 DWORD PTR _netmask_bits$[esp] 
  
 call 
  
  
 _form_netmask push 
  
 OFFSET $SG3045 ; 
 'netmask=' 
  
 mov 
  
 edi, eax 
  
 call 
  
 DWORD PTR __imp__printf 
  
 push 
  
  
 edi call 
  
 _print_as_IP
  
 call 
  
 _print_as_IP
  
 push 
  
 OFFSET $SG3046 ; 'network address='
  
 call 
  
 DWORD PTR __imp__printf
  
 push 
  
 DWORD PTR _ip4$[esp+16]
  
 push 
  
 DWORD PTR _ip3$[esp+20]
  
 push 
  
 DWORD PTR _ip2$[esp+24]
  
 push 
  
 DWORD PTR _ip1$[esp+28]
  
 call 
  
 _form_IP
  
 and 
  
 eax, edi 
  
 ; network address = host address & netmask
  
 push 
  
 eax
  
 call 
  
 _print_as_IP
  
 add 
  
 esp, 36
  
 pop 
  
 edi
  
 ret 
  
 0",NA
38.2 ,NA,NA
form_IP(),"The
  form_IP()
  function just puts all 4 bytes into a 32-bit value.
  
 Here is how it is usually done:
  
 • Allocate a variable for the return value. Set it to 0.
  
 • Take the fourth (lowest) byte, apply OR operation to this byte and return the value. The return value contain the 4th 
  
 byte now.
  
 • Take the third byte, shift it left by 8 bits. You’ll get a value like
  0x0000bb00
  where
  bb
  is your third byte. Apply the 
 OR operation to the resulting value and it. The return value has contained
  0x000000aa
  so far, so ORing the values 
 will produce a value like
  0x0000bbaa
 .
  
 • Take the second byte, shift it left by 16 bits. You’ll get a value like
  0x00cc0000
 , where
  cc
  is your second byte. Apply 
 the OR operation to the resulting value and return it. The return value has contained
  0x0000bbaa
  so far, so ORing 
 the values will produce a value like
  0x00ccbbaa
 .
  
 • Take the first byte, shift it left by 24 bits. You’ll get a value like
  0xdd000000
 , where
  dd
  is your first byte. Apply the 
 OR operation to the resulting value and return it. The return value contain
  0x00ccbbaa
  so far, so ORing the values 
 will produce a value like
  0xddccbbaa
 .
  
 And this is how it’s done by non-optimizing MSVC 2012:
  
 Listing 38.2: Non-optimizing MSVC 2012
  
 ; denote ip1 as ""dd"", ip2 as ""cc"", ip3 as ""bb"", ip4 as ""aa"".
  
 _ip1$ = 8 
  
 ; size = 1 
  
 _ip2$ = 12 
  
 ; size = 1 
  
 _ip3$ = 16 
  
 ; size = 1 
  
  
  
 ; size = 1 _ip4$ = 20 
  
 _form_IP PROC 
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 movzx 
  
 eax, BYTE PTR _ip1$[ebp] 
  
 ; EAX=000000dd 
  
 shl 
  
 eax, 24 
  
 ; EAX=dd000000 
  
 movzx 
  
 ecx, BYTE PTR _ip2$[ebp] 
  
 ; ECX=000000cc 
  
  
  
 ecx, 16 shl 
  
 ; ECX=00cc0000
  
 or 
  
 eax, ecx 
  
 ; EAX=ddcc0000 
  
 movzx 
  
 edx, BYTE PTR _ip3$[ebp] 
  
 ; EDX=000000bb 
  
 shl 
  
 edx, 8 
  
 ; EDX=0000bb00 
  
 or 
  
 eax, edx 
  
 ; EAX=ddccbb00 
  
 movzx 
  
 ecx, BYTE PTR _ip4$[ebp] 
  
 ; ECX=000000aa 
  
 or 
  
  
 eax, ecx ; EAX=ddccbbaa 
  
 pop 
  
 ebp 
  
 ret 
  
 0 
  
 _form_IP ENDP
  
 Well, the order is different, but, of course, the order of the operations doesn’t matters. 
 Optimizing MSVC 2012 does essentially the same, but in a different way:
  
 Listing 38.3: Optimizing MSVC 2012 /Ob0
  
 ; denote ip1 as ""dd"", ip2 as ""cc"", ip3 as ""bb"", ip4 as ""aa"". _ip1$ = 8 
  
 ; size = 1
  
 _ip1$ = 8 
  
 ; size = 1
  
 _ip2$ = 12 
  
 ; size = 1",NA
38.3 ,NA,NA
print_as_IP(),"print_as_IP()
  does the inverse: splitting a 32-bit value into 4 bytes.
  
 Slicing works somewhat simpler: just shift input value by 24, 16, 8 or 0 bits, take the bits from zeroth to seventh (lowest 
 byte), and that’s it:
  
 Listing 38.4: Non-optimizing MSVC 2012
  
 _a$ = 8 
  
  
  
 ; size = 4 
  
 _print_as_IP PROC 
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 mov 
  
  
 eax, DWORD PTR _a$[ebp] ; EAX=ddccbbaa 
  
 and 
  
 eax, 255 
  
 ; EAX=000000aa 
  
 push 
  
 eax 
  
 mov 
  
  
 ecx, DWORD PTR _a$[ebp] ; ECX=ddccbbaa 
  
 shr 
  
 ecx, 8 
  
 ; ECX=00ddccbb 
  
 and 
  
 ecx, 255
  
 ; ECX=000000bb 
  
 push 
  
 ecx 
  
 mov 
  
 edx, DWORD PTR _a$[ebp] 
  
 ; EDX=ddccbbaa 
  
 shr 
  
 edx, 16 
  
 ; EDX=0000ddcc 
  
 and 
  
 edx, 255 
  
 ; EDX=000000cc 
  
 push 
  
 edx 
  
 mov 
  
 eax, DWORD PTR _a$[ebp] 
  
 ; EAX=ddccbbaa 
  
 shr 
  
 eax, 24 
  
 ; EAX=000000dd 
  
 and 
  
 eax, 255 ; probably redundant instruction",NA
38.4,NA,NA
form_netmask() and set_bit(),"form_netmask()
  makes a network mask value from
  CIDR
  notation. Of course, it would be much effective to use here some 
 kind of a precalculated table, but we consider it in this way intentionally, to demonstrate bit shifts. We will also write a 
 separate function
  set_bit()
 . It’s a not very good idea to create a function for such primitive operation, but it would be easy 
 to understand how it all works.
  
 Listing 38.6: Optimizing MSVC 2012 /Ob0
  
 _input$ = 8 
  
  
 ; size = 4 
  
 _bit$ = 12 
   
 ; size = 4 
  
 _set_bit PROC 
  
 mov 
  
 ecx, DWORD PTR _bit$[esp-4] 
  
 mov 
  
  
 eax, 1 shl 
  
 eax, cl 
  
 or 
  
 eax, DWORD PTR _input$[esp-4] 
  
 ret 
  
 0 
  
 _set_bit ENDP
  
 _netmask_bits$ = 8 
  
 ; size = 1 
  
 _form_netmask PROC 
  
 push 
  
 ebx 
  
 push 
  
 esi 
  
 movzx 
  
 esi, BYTE PTR _netmask_bits$[esp+4]",NA
38.5 ,NA,NA
Summary,"That’s it! We run it and getting:
  
 netmask=255.255.255.0 
  
 network address=10.1.2.0 
  
 netmask=255.0.0.0 
  
 network address=10.0.0.0
  
 netmask=255.255.255.128 
  
 network address=10.1.2.0 
  
 netmask=255.255.255.192 
  
 network address=10.1.2.64",NA
Chapter 39,NA,NA
Loops: several iterators,"In most cases loops have only one iterator, but there could be several in the resulting code. 
 Here is a very simple example:
  
 #include <stdio.h>
  
 void f(int *a1, int *a2, size_t cnt) 
  
 { 
  
 size_t i;
  
 // copy from one array to another in some weird scheme for (i=0; i<cnt; i++) 
  
  
  
 a1[i*3]=a2[i*7]; 
  
 };
  
  
 There are two multiplications at each iteration and they are costly operations. Can we optimize it somehow? 
 notice that both array indices are jumping on values that we can easily calculate without multiplication.
  
 Yes, if we",NA
39.1,NA,NA
Three iterators,"Listing 39.1: Optimizing MSVC 2013 x64
  
 f PROC 
  
 ; RDX=a1 
  
 ; RCX=a2 
  
 ; R8=cnt
  
 test
  
 r8, r8
  
 ; cnt==0? exit then
  
 je
  
 SHORT $LN1@f
  
 npad
  
 11
  
 $LL3@f: 
  
 mov 
  
 eax, DWORD PTR [rdx]
  
 lea 
  
 rcx, QWORD PTR [rcx+12] 
  
 lea 
  
 rdx, QWORD PTR [rdx+28] 
  
 mov 
  
 DWORD PTR [rcx-12], eax 
  
 dec 
  
 r8 
  
 jne 
  
 SHORT $LL3@f 
  
 $LN1@f:
  
 f
  
 ret
  
 0
  
 ENDP
  
  
 Now there are 3 iterators: the
  cnt
  variable and two indices, which are increased by 12 and 28 at each iteration. We can 
 rewrite this code in C/C++:
  
 #include <stdio.h> 
  
 void f(int *a1, int *a2, size_t cnt) 
  
 {
  
 size_t i; 
  
 size_t idx1=0; idx2=0;
  
 // copy from one array to another in some weird scheme
  
 460",NA
39.2 ,NA,NA
Two iterators,"GCC 4.9 does even more, leaving only 2 iterators:
  
 Listing 39.2: Optimizing GCC 4.9 x64
  
 ; RDI=a1 
  
 ; RSI=a2 
  
 ; RDX=cnt 
  
 f:
  
 test
  
 rdx, rdx
  
 ; cnt==0? exit then
  
 je
  
 .L1
  
 ; calculate last element address in ""a2"" and leave it in RDX lea 
  
 rax, [0+rdx*4] 
  
 ; RAX=RDX*4=cnt*4 
  
 sal 
  
 rdx, 5 
  
 ; RDX=RDX<<5=cnt*32 
  
 sub 
  
 rdx, rax
  
 ; RDX=RDX-RAX=cnt*32-cnt*4=cnt*28 
  
 add 
  
 rdx, rsi 
  
 ; RDX=RDX+RSI=a2+cnt*28 
  
 .L3: 
  
 mov 
  
 eax, DWORD PTR [rsi] 
  
 add 
  
  
 rsi, 28 add 
  
 rdi, 12 
  
 mov 
  
 DWORD PTR [rdi-12], eax 
  
 cmp 
  
 rsi, rdx 
  
 jne 
  
  
 .L3 .L1: 
  
 rep ret
  
  
 There is no
  counter
  variable any more: GCC concluded that it is not needed. 
  
 The last element of the
  a2
  array is calculated
  
 before the loop begins (which is easy:
  cnt
  ∗ 7
 ) and that’s how the loop is to be stopped: just iterate until the second index
  
 You can read more about multiplication using shifts/additions/subtractions here:
  16.1.3 on page 200
 .
  
 This code can be rewritten into C/C++ like that:
  
 #include <stdio.h>
  
 void f(int *a1, int *a2, size_t cnt) 
  
 { 
  
 size_t i; 
  
 size_t idx1=0; idx2=0; 
  
 size_t last_idx2=cnt*7;
  
 // copy from one array to another in some weird scheme
  
 for (;;) 
  
 { 
  
  
  
 a1[idx1]=a2[idx2]; 
  
  
  
 idx1+=3; 
  
  
  
 idx2+=7; 
  
  
  
 if (idx2==last_idx2) 
  
  
  
  
 break; 
  
 }; 
  
 };
  
 461",NA
39.3,NA,NA
Intel C++ 2011 case,"Compiler optimizations can also be weird, but nevertheless, still correct. Here is what the Intel C++ compiler 2011 does: 
  
 Listing 39.5: Optimizing Intel C++ 2011 x64
  
 f PROC 
  
 ; parameter 1: rcx = a1 
  
 ; parameter 2: rdx = a2
  
 ; parameter 3: r8
  
 = cnt
  
 ; Preds .B1.0
  
 .B1.1::
  
  
  
 462",NA
Chapter 40,NA,NA
Duff’s device,"Duff’s device
 1 
  
 is an unrolled loop with the possibility to jump inside it.
  
 fallthrough switch() statement.
  
 We would use here a slightly simplified version of Tom Duff’s original code.
  
 The unrolled loop is implemented using a
  
 Let’s say, we need to write a function that clears a region in memory. One can come with a simple loop, clearing byte by 
 byte. It’s obviously slow, since all modern computers have much wider memory bus. 
  
 So the better way is to clear the 
 memory region using 4 or 8 byte blocks. Since we are going to work with a 64-bit example here, we are going to clear the 
 memory in 8 byte blocks. So far so good. But what about the tail? 
  
 Memory clearing routine can also be 
 called for regions of size that’s not a multiple of 8.
  
 So here is the algorithm:
  
 • calculate the number of 8-byte blocks, clear them using 8-byte (64-bit) memory accesses;
  
 • calculate the size of the tail, clear it using 1-byte memory accesses.
  
 The second step can be implemented using a simple loop. But let’s implement it as an unrolled loop:
  
 #include <stdint.h> 
  
 #include <stdio.h>
  
 void bzero(uint8_t* dst, size_t count) 
  
 { 
  
 int i;
  
 if (count&(~7)) 
  
  
 // work out 8-byte blocks 
  
  
 for (i=0; i<count>>3; i++) 
  
  
 { 
  
  
  
 *(uint64_t*)dst=0; 
  
  
  
 dst=dst+8; 
  
  
 // work out the tail 
  
 };
  
 switch(count & 7) 
  
 { 
  
 case 7: *dst++ = 0; 
  
 case 6: *dst++ = 0; 
  
 case 5: *dst++ = 0; 
  
 case 4: *dst++ = 0; 
  
 case 3: *dst++ = 0; 
  
 case 2: *dst++ = 0; 
  
 case 1: *dst++ = 0; 
  
 case 0: // do nothing 
  
  
  
 break; 
  
 } 
  
 }
  
 Let’s first understand how the calculation is done. The memory region size comes as a 64-bit value. And this value can be 
 divided in two parts:
  
 1
 wikipedia",NA
Chapter 41,NA,NA
Division by 9,"A very simple function:
  
 int f(int a) 
  
 {
  
 return a/9; 
  
 };",NA
41.1,NA,NA
x86,"…is compiled in a very predictable way:
  
 Listing 41.1: MSVC
  
 _a$ = 8 
  
 ; size = 4
  
 _f 
  
 PROC
  
 push 
  
 ebp
  
 mov 
  
 ebp, esp
  
 mov 
  
 eax, DWORD PTR _a$[ebp]
  
 cdq ; sign extend EAX to EDX:EAX
  
 _f
  
 mov
  
 ecx, 9
  
 idiv
  
 ecx
  
 pop
  
 ebp
  
 ret
  
 0
  
 ENDP
  
  
 IDIV
  divides the 64-bit number stored in the
  EDX:EAX
  register pair by the value in the
  ECX
 . As a result,
  EAX
  will contain 
 the
  quotient
 , and
  EDX
 —the remainder. The result is returned from the
  f()
  function in the
  EAX
  register, so the value is not 
 moved after the division operation, it is in right place already. Since
  IDIV
  uses the value in the
  EDX:EAX
  register pair, the 
 CDQ
  instruction (before
  IDIV
 ) extends the value in
  EAX
  to a 64-bit value taking its sign into account, just as
  MOVSX
  does.
  
 If we turn optimization on (
 /Ox
 ), we get:
  
 Listing 41.2: Optimizing MSVC
  
 _a$ = 8 
  
 ; size = 4
  
 _f 
  
 PROC
  
 mov 
  
 ecx, DWORD PTR _a$[esp-4]
  
 mov 
  
 eax, 954437177 
  
 ; 38e38e39H
  
 imul 
  
 ecx
  
 _f
  
 sar
  
 edx, 1
  
 ; 0000001fH
  
 mov
  
 eax, edx
  
 shr
  
 eax, 31
  
 add
  
 eax, edx
  
 ret
  
 0
  
 ENDP
  
  
 This is division by multiplication. Multiplication operations work much faster. And it is possible to use this trick
 1
 to produce 
 code which is effectively equivalent and faster.
  
 1
 Read more about division by multiplication in [
 War02
 , pp. 10-3]",NA
41.2,NA,NA
ARM,"The ARM processor, just like in any other “pure” RISC processor lacks an instruction for division. It also lacks a single
  
 instruction for multiplication by a 32-bit constant (recall that a 32-bit constant cannot fit into a 32-bit opcode).
  
 By taking
  
 advantage of this clever trick (or
  hack
 ), it is possible to do division using only three instructions: addition, subtraction and 
 bit shifts (
  19 on page 289
 ).
  
 Here is an example that divides a 32-bit number by 10, from [
 Ltd94
 , 3.3 Division by a Constant]. The output consists of the 
 quotient and the remainder.
  
 ; takes argument in a1 
  
 ; returns quotient in a1, remainder in a2 
  
 ; cycles could be saved if only divide or remainder is required
  
 SUB
  
 a2, a1, #10
  
 ; keep (x-10) for later
  
 SUB
  
 a1, a1, a1, lsr #2
  
 ADD
  
 a1, a1, a1, lsr #4
  
 ADD
  
 a1, a1, a1, lsr #8
  
  
 ADD
  
 a1, a1, a1, lsr #16
  
 ; calc (x-10) - (x/10)*10
  
 MOV
  
 a1, a1, lsr #3
  
 ADD
  
 a3, a1, a1, asl #2
  
 SUBS
  
 a2, a2, a3, asl #1
  
 ADDPL
  
 a1, a1, #1
  
 ; fix-up quotient
  
 ADDMI
  
 a2, a2, #10
  
 ; fix-up remainder
  
 MOV
  
 pc, lr
  
  
  
 41.2.1
  
 Optimizing Xcode 4.6.3 (LLVM) (ARM mode)
  
  
 __text:00002C58 39 1E 08 E3 E3 18 43 E3
  
 MOV
  
 R1, 0x38E38E39
  
 __text:00002C60 10 F1 50 E7
  
 SMMUL
  
 R0, R0, R1
  
 __text:00002C64 C0 10 A0 E1
  
 MOV
  
 R1, R0,ASR#1
  
  
 __text:00002C68 A0 0F 81 E0
  
 ADD
  
 R0, R1, R0,LSR#31
  
 __text:00002C6C 1E FF 2F E1
  
 BX
  
 LR
  
  
 This code is almost the same as the one generated by the optimizing MSVC and GCC. Apparently, LLVM uses the same 
 algorithm for generating constants.
  
 The observant reader may ask, how does
  MOV
  writes a 32-bit value in a register, when this is not possible in ARM mode. it 
 is impossible indeed, but, as we see, there are 8 bytes per instruction instead of the standard 4, in fact, there are two",NA
41.3 ,NA,NA
MIPS,"For some reason, optimizing GCC 4.4.5 generate just a division instruction:
  
 Listing 41.4: Optimizing GCC 4.4.5 (IDA)
  
 f:
  
 li 
  
 $v0, 9
  
 bnez 
  
 $v0, loc_10
  
 div 
  
 $a0, $v0 ; branch delay slot
  
 break 
  
 0x1C00 
  
 ; ""break 7"" in assembly output and objdump
  
 loc_10:
  
 mflo 
  
 $v0
  
 jr 
  
 $ra
  
 or 
  
 $at, $zero ; branch delay slot, NOP
  
  
 Here we see here a new instruction: BREAK. It just raises an exception.
  
 In this case, an exception is raised if the divisor
  
 is zero (it’s not possible to divide by zero in conventional math).
  
 But GCC probably did not do very well the optimization
  
 job and did not see that $V0 is never zero.
  
 So the check is left here. So if $V0 is zero somehow, BREAK is to be executed,
  
 signaling to the
  OS
  about the exception.
  
 Otherwise, MFLO executes, which takes the result of the division from the LO
  
 register and copies it in $V0.
  
 By the way, as we may know, the MUL instruction leaves the high 32 bits of the result in register HI and the low 32 bits in 
 register LO. DIV leaves the result in the LO register, and remainder in the HI register.
  
 If we alter the statement to “a % 9”, the MFHI instruction is to be used here instead of MFLO.
  
 2
 These instructions are also called “data processing instructions”",NA
41.4 ,NA,NA
How it works,"CHAPTER 41. DIVISION BY 9
  
 That’s how division can be replaced by multiplication and division with
  2
 n
 numbers:
  
 Where
  M
  is a
  magic
  coefficient.
  
 result
  =
 input divisor
 =
  input
  ⋅2
 n
  
 divisor
  
 2
 n
  
 =
 input
  ⋅
  M
  
 This is how
  M
  can be computed:
  
 M
  
  
 2
 n
  
 M
  
  
 divisor
  
 So these code snippets usually have this form:
  
  
 result
  =
 input
  ⋅
  M 
  
 Division by
  2
 n
 is usually done by simply shifting to the right. If
  n
  < 32
 , then the low part of the
  product
  is shifted (in
  EAX
  or 
 RAX
 ). If
  n
  ≥ 32
 , then the high part of the
  product
  is shifted (in
  EDX
  or
  RDX
 ).
  
 When doing signed division, the sign of the multiplication result is also added to the output result.
  
 Take a look at the difference:
  
 int f3_32_signed(int a) 
  
 { 
  
 return a/3; 
  
 };
  
 unsigned int f3_32_unsigned(unsigned int a) 
  
 { 
  
 return a/3; 
  
 };
  
 In the unsigned version of the function, the
  magic
  coefficient is
  0xAAAAAAAB
  and the multiplication result is divided by 
 2
 33
 .
  
 In the signed version of the function, the
  magic
  coefficient is
  0x55555556
  and the multiplication result is divided by
  2
 32
 . 
 There are no division instruction though: the result is just taken from
  EDX
 .
  
 The sign is also taken from the multiplication result: the high 32 bits of the result are shifted by 31 (leaving the sign in the 
 least significant bit of
  EAX
 ). 1 is added to the final result if the sign is negative, for result correction.
  
 Listing 41.5: Optimizing MSVC 2012
  
 _f3_32_unsigned PROC 
  
 mov 
  
 eax, -1431655765 
  
 ; aaaaaaabH mul 
  
 DWORD PTR _a$[esp-4] ; unsigned multiply ; 
 EDX=(input*0xaaaaaaab)/2^32 
  
 shr 
  
  
 edx, 1 ; EDX=(input*0xaaaaaaab)/2^33 
  
 mov 
  
 eax, edx 
  
 ret 
  
 0 
  
 _f3_32_unsigned ENDP
  
 _f3_32_signed PROC 
  
 mov 
  
 eax, 1431655766 
  
 ; 55555556H 
  
 imul 
  
 DWORD PTR _a$[esp-4] ; signed multiply 
  
 ; take high part of product 
  
 ; it is just the same as if to shift product by 32 bits right or to divide it by 2^32
  
 mov
  
 eax, edx
  
 ; EAX=EDX=(input*0x55555556)/2^32
  
 shr
  
 eax, 31
  
 ; 0000001fH
  
 add
  
 eax, edx
  
 ; add 1 if sign is negative
  
 ret
  
 0
  
 _f3_32_signed ENDP
  
 471",NA
41.5 ,NA,NA
Getting the divisor,"41.5.1 
  
 Variant #1
  
 Often, the code looks like this:
  
 mov 
  
 eax, MAGICAL CONSTANT 
  
 imul 
  
 input value 
  
 sar 
  
 edx, SHIFTING COEFFICIENT ; signed division by
  2
 x
 using arithmetic shift right
  
 mov 
  
 eax, edx
  
 shr 
  
 eax, 31
  
 add 
  
 eax, edx
  
 Let’s denote the 32-bit
  magic
  coefficient as
  M
 , the shifting coefficient as
  C
  and the divisor as
  D
 . 
 The divisor we need to get is:
  
  
  
 D
  = 2
 32+
 C 
  
  
  
  
 M 
  
 For example: 
  
  
 Listing 41.6: Optimizing MSVC 2012
  
 mov
  
 eax, 2021161081
  
 ; 78787879H
  
 imul
  
 DWORD PTR _a$[esp-4]
  
 sar
  
 edx, 3
  
  
 mov
  
 eax, edx
  
 ; 0000001fH
  
 shr
  
 eax, 31
  
 add
  
 eax, edx
  
  
 This is:
  
  
 2
 32+3
  
 D
  =
  
 202116108
 1
  
 The numbers are larger than 32-bit, so we can use Wolfram Mathematica for convenience: 
  
 Listing 41.7: Wolfram Mathematica
  
 In[1]:=N[2^(32+3)/2021161081]
  
 Out[1]:=17.
  
 So the divisor from the code we used as example is 17.
  
 For x64 division, things are the same, but
  2
 64
 has to be used instead of
  2
 32
 :
  
 uint64_t f1234(uint64_t a) 
  
 {
  
 return a/1234; 
  
 };
  
 3
 Wikipedia
  
 472",NA
41.6 ,NA,NA
Exercise,"•
  http://challenges.re/27
  
 473",NA
Chapter 42,NA,NA
String to number conversion (atoi()),Let’s try to reimplement the standard atoi() C function.,NA
42.1 ,NA,NA
Simple example,"Here is the simplest possible way to read a number represented in
  ASCII
 1
 encoding. It’s not error-prone: a character other
  
 than a digit leads to incorrect result.
  
 #include <stdio.h>
  
 int my_atoi (char *s) 
  
 { 
  
 int rt=0;
  
 while (*s) 
  
 { 
  
  
 rt=rt*10 + (*s-'0'); 
  
  
 s++;
  
 };
  
 return rt; 
  
 };
  
 int main() 
  
 { 
  
 printf (""%d\n"", my_atoi (""1234"")); 
  
 printf (""%d\n"", my_atoi (""1234567890"")); 
  
 };
  
  
 So what the algorithm does is just reading digits from left to right.
  
 The zero
  ASCII
  character is subtracted from each digit.
  
 The digits from “0” to “9” are consecutive in the
  ASCII
  table, so we do not even need to know the exact value of the 
 “0”character. All we need to know is that “0” minus “0” is 0, “9” minus “0”’is 9 and so on. Subtracting “0” from each 
 character results in a number from 0 to 9 inclusive. Any other character leads to an incorrect result, of course! Each digit 
 has to be added to the final result (in variable “rt”), but the final result is also multiplied by 10 at each digit. In other 
 words, the result is shifted left by one position in decimal form on each iteration. The last digit is added, but there is no 
 no shift.
  
 42.1.1
  
 Optimizing MSVC 2013 x64
  
 Listing 42.1: Optimizing MSVC 2013 x64
  
 s$ = 8 
  
 my_atoi PROC 
  
 ; load first character 
  
 movzx 
  
 r8d, BYTE PTR [rcx]
  
 ; EAX is allocated for ""rt"" variable 
  
 ; its 0 at start' 
  
 xor 
  
 eax, eax 
  
 ; first character is zero-byte, i.e., string terminator?
  
 1
 American Standard Code for Information Interchange
  
 474",NA
42.2,NA,NA
A slightly advanced example,"My new code snippet is more advanced, now it checks for the “minus” sign at the first character and reports an error if a
  
 non-digit was found in the input string:
  
 #include <stdio.h>
  
 int my_atoi (char *s) 
  
 { 
  
 int negative=0; 
  
 int rt=0;
  
 if (*s=='-') 
  
 { 
  
  
 negative=1; 
  
  
 s++; 
  
 };
  
 while (*s) 
  
 { 
  
  
 if (*s<'0' || *s>'9') 
  
  
 {
  
  
  
 printf (""Error! Unexpected char: '%c'\n"", *s); 
  
  
 exit(0); 
  
  
 }; 
  
  
 rt=rt*10 + (*s-'0'); 
  
  
 s++; 
  
 };
  
 if (negative) 
  
  
  
 return -rt; 
  
 return rt; 
  
 };
  
 int main() 
  
 { 
  
 printf (""%d\n"", my_atoi (""1234"")); 
  
 printf (""%d\n"", my_atoi (""1234567890"")); 
  
 printf (""%d\n"", my_atoi (""-1234"")); 
  
 printf (""%d\n"", my_atoi (""-1234567890""));
  
 477",NA
42.3 ,NA,NA
Exercise,"CHAPTER 42. STRING TO NUMBER CONVERSION (ATOI())
  
 Oh, by the way, security researchers deals often with unpredictable behaviour of program while handling of incorrect data. 
 For example, while fuzzing. As an exercise, you may try to enter non-digit characters and see what happens. Try to 
 explain, what happened and why.
  
 480",NA
Chapter 43,NA,NA
Inline functions,"Inlined code is when the compiler, instead of placing a call instruction to a small or tiny function, just places its body right 
 in-place.
  
 Listing 43.1: A simple example
  
 #include <stdio.h>
  
 int celsius_to_fahrenheit (int celsius) 
  
 { 
  
 return celsius * 9 / 5 + 32; 
  
 };
  
 int main(int argc, char *argv[]) 
  
 { 
  
 int celsius=atol(argv[1]); 
  
 printf (""%d\n"", celsius_to_fahrenheit (celsius)); };
  
 … is compiled in very predictable way, however, if we turn on GCC optimizations (
 -O3
 ), we’ll see:
  
 Listing 43.2: Optimizing GCC 4.8.1
  
 _main: 
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 and 
  
 esp, -16 
  
 sub 
  
  
 esp, 16 call 
  
 ___main 
  
 mov 
  
 eax, DWORD PTR [ebp+12] 
  
 mov 
  
 eax, DWORD PTR [eax+4] 
  
 mov 
  
  
 DWORD PTR [esp], eax call 
  
 _atol 
  
 mov 
  
 edx, 1717986919 
  
 mov 
  
 DWORD PTR [esp], OFFSET FLAT:LC2 ; ""%d\12\0""
  
 lea 
  
 ecx, [eax+eax*8] 
  
 mov 
  
 eax, ecx 
  
 imul 
  
 edx 
  
 sar 
  
 ecx, 31 
  
 sar 
  
 edx 
  
 sub 
  
 edx, ecx 
  
 add 
  
 edx, 32 
  
 mov 
  
 DWORD PTR [esp+4], edx 
  
 call 
  
 _printf 
  
 leave 
  
 ret
  
 (Here the division is done by multiplication(
  41 on page 468
 ).)
  
 Yes, our small function
  celsius_to_fahrenheit()
  was just placed before the
  printf()
  call. than 
 executing this function’s code plus the overhead of calling/returning.
  
 Why? It can be faster
  
 Modern optimizing compilers are choosing small functions for inlining automatically. But it’s possible to force compiler 
 additionally to inline some function, if to mark it with the “inline” keyword in its declaration.
  
 481",NA
43.1 ,NA,NA
Strings and memory functions,"CHAPTER 43. INLINE FUNCTIONS
  
 Another very common automatic optimization tactic is the inlining of string functions like
  strcpy()
 ,
  strcmp()
 ,
  strlen()
 ,
  
 memset()
 , 
 memcmp()
 ,
  memcpy()
 , etc.
  
 Sometimes it’s faster than to call a separate function.
  
 These are very frequent patterns and it is highly advisable for reverse engineers to learn to detect automatically.
  
 43.1.1 
  
 strcmp()
  
 Listing 43.3: strcmp() example
  
 bool is_bool (char *s) 
  
 { 
  
 if (strcmp (s, ""true"")==0) 
  
  
  
 return true; 
  
 if (strcmp (s, ""false"")==0)
  
  
  
 return false; 
  
 assert(0); 
  
 };
  
 Listing 43.4: Optimizing GCC 4.8.1
  
 .LC0: 
  
 .string ""true"" 
  
 .LC1: 
  
 .string ""false"" 
  
 is_bool: 
  
 .LFB0: 
  
 push 
  
 edi 
  
 mov 
  
 ecx, 5 
  
 push 
  
 esi 
  
 mov 
  
 edi, OFFSET FLAT:.LC0 
  
 sub 
  
 esp, 20 
  
 mov 
  
 esi, DWORD PTR [esp+32] 
  
 repz cmpsb 
  
 je 
  
 .L3 
  
 mov 
  
 esi, DWORD PTR [esp+32] 
  
 mov 
  
  
 ecx, 6 mov 
  
 edi, OFFSET FLAT:.LC1 
  
 repz cmpsb 
  
 seta 
  
 cl 
  
 setb 
  
 dl
  
 xor 
  
 eax, eax 
  
 cmp 
  
 cl, dl 
  
 jne 
  
 .L8 
  
 add 
  
 esp, 20 
  
 pop 
  
 esi 
  
 pop 
  
 edi 
  
 ret 
  
 .L8: 
  
 mov 
  
 DWORD PTR [esp], 0 
  
 call 
  
 assert 
  
 add 
  
 esp, 20 
  
 pop 
  
 esi 
  
 pop 
  
 edi 
  
 ret 
  
 .L3: 
  
 add 
  
 esp, 20 
  
 mov 
  
 eax, 1 
  
 pop 
  
 esi 
  
 pop 
  
 edi 
  
 ret
  
 Listing 43.5: Optimizing MSVC 2010
  
  
 $SG3454 DB
  
 'true', 00H
  
  
 482",NA
Chapter 44,NA,NA
C99 restrict,"Here is a reason why FORTRAN programs, in some cases, work faster than C/C++ ones.
  
 void f1 (int* x, int* y, int* sum, int* product, int* sum_product, int* update_me, size_t s) { 
  
 for (int i=0; i<s; i++) 
  
 { 
  
  
  
 sum[i]=x[i]+y[i];
  
  
  
 product[i]=x[i]*y[i]; 
  
  
  
 update_me[i]=i*123; // some dummy value 
  
  
 sum_product[i]=sum[i]+product[i]; 
  
 }; 
  
 };
  
 That’s very simple example with one specific thing in it: the pointer to the
  update_me
  array could be a pointer to the
  sum 
 array,
  product
  array, or even the
  sum_product
  array—nothing forbids that, right?
  
 The compiler is fully aware of this, so it generates code with four stages in the loop body:
  
 • calculate next
  sum[i]
  
 • calculate next
  product[i]
  
 • calculate next
  update_me[i]
  
 • calculate next
  sum_product[i]
 — on this stage, we need to load from memory the already calculated
  sum[i]
  and 
  
 product[i] 
  
 Is it possible to optimize the last stage? Since we have already calculated
  sum[i]
  and
  product[i]
  it is not necessary to load 
 them again from memory. 
  
  
 Yes, but compiler is not sure that nothing was overwritten in the 3rd stage! This is called “pointer aliasing”, a situation 
 when the compiler cannot be sure that a memory to which a pointer is pointing was not changed.
  
 restrict
  in the C99 standard[
 ISO07
 , pp. 6.7.3/1] is a promise, given by programmer to the compiler that the function 
 arguments marked by this keyword always points to different memory locations and never intersects.
  
 To be more precise and describe this formally,
  restrict
  shows that only this pointer is to be used to access an object, and no 
 other pointer will be used for it. 
  
 It can be even said the object will be accessed only via one single pointer, if it is marked 
 as
  restrict
 .
  
 Let’s add this keyword to each pointer argument:
  
 void f2 (int* restrict x, int* restrict y, int* restrict sum, int* restrict product, int*
  ⤦
 int* restrict update_me, size_t s) 
  
 { 
  
 for (int i=0; i<s; i++) 
  
 {
  
  
  
 sum[i]=x[i]+y[i]; 
  
  
  
 product[i]=x[i]*y[i]; 
  
  
  
 update_me[i]=i*123; // some dummy value 
  
  
 sum_product[i]=sum[i]+product[i]; 
  
 }; 
  
 };
  
 Let’s see results:",NA
Chapter 45,NA,NA
Branchless,NA,NA
 abs(),NA,NA
 function,"Let’s revisit an example we considered earlier
  12.2 on page 131
  and ask ourselves, is it possible to make a branchless 
 version of the function in x86 code?
  
 int my_abs (int i) 
  
 { 
  
 if (i<0) 
  
  
  
 return -i;
  
 else 
  
  
  
 return i; 
  
 };
  
 And the answer is yes.",NA
45.1 ,NA,NA
Optimizing GCC 4.9.1 x64,"We could see it if we compile it using optimizing GCC 4.9:
  
 Listing 45.1: Optimizing GCC 4.9 x64
  
 my_abs: 
  
 mov 
  
 edx, edi 
  
 mov 
  
 eax, edi 
  
 sar 
  
 edx, 31 
  
 ; EDX is 0xFFFFFFFF here if sign of input value is minus ; EDX is 0 if sign of 
 input value is plus (including 0)
  
 ; the following two instructions have effect only if EDX is 0xFFFFFFFF ; or idle if EDX is 0 
  
 xor 
  
 eax, edx 
  
 sub 
  
 eax, edx 
  
 ret
  
 This is how it works:
  
 Arithmetically shift the input value left by 31. Arithmetical shift implies sign extension, so if the
  MSB
  is 1, all 32 bits are to 
 be filled with 1, or with 0 if otherwise. In other words, the
  SAR REG, 31
  instruction makes
  0xFFFFFFFF
  if the sign was 
 negative or 0 if positive. After the execution of
  SAR
 , we have this value in
  EDX
 . Then, if the value is
  0xFFFFFFFF
  (i.e., the 
 sign is negative), the input value is inverted (because
  XOR REG, 0xFFFFFFFF
  is effectively an inverse all bits operation). 
 Then, again, if the value is
  0xFFFFFFFF
  (i.e., the sign is negative), 1 is added to the final result (because subtracting
  −1 
 is 
 negated:
  30 on page 431
 .
  
 We may observe that the last two instruction do something if the sign of the input value is negative. Otherwise (if the sign 
 is positive) they do nothing at all, leaving the input value untouched.
  
 The algorithm is explained in [
 War02
 , pp. 2-4]. It’s hard to say, how GCC did it, deduced it by itself or found a suitable 
 pattern among known ones?",NA
45.2 ,NA,NA
Optimizing GCC 4.9 ARM64,"CHAPTER 45. BRANCHLESS ABS() FUNCTION
  
 GCC 4.9 for ARM64 generates mostly the same, just decides to use the full 64-bit registers.
  
 There are less instructions,
  
 because the input value can be shifted using a suffixed instruction (“asr”) instead of using a separate instruction.
  
 Listing 45.2: Optimizing GCC 4.9 ARM64
  
 my_abs: 
  
 ; sign-extend input 32-bit value to X0 64-bit register: sxtw 
  
 x0, w0 
  
 eor 
  
 x1, x0, x0, asr 63
  
 ; X1=X0^(X0>>63) (shift is arithmetical) 
  
 sub 
  
 x0, x1, x0, asr 63 
  
 ; X0=X1-(X0>>63)=X0^(X0>>63)-(X0>>63) (all shifts are arithmetical) ret
  
 494",NA
Chapter 46,NA,NA
Variadic functions,"Functions like
  printf()
  and
  scanf()
  can have a variable number of arguments. How are these arguments accessed?",NA
46.1,NA,NA
Computing arithmetic mean,"Let’s imagine that we need to calculate
  arithmetic mean
 , and for some weird reason we need to specify all the values as 
 function arguments.
  
 But it’s impossible to get the number of arguments in a variadic function in C/C++, so let’s denote the value of
  −1
  as a 
 There is the standard stdarg.h header file which define macros for dealing with such arguments. 
  
 The
  printf()
  and 
 scanf()
  functions use them as well.
  
  
 #include <stdio.h> 
  
 #include <stdarg.h>
  
 int arith_mean(int v, ...) 
  
 { 
  
 va_list args; 
  
 int sum=v, count=1, i; 
  
 va_start(args, v);
  
 while(1) 
  
 { 
  
  
 i=va_arg(args, int); 
  
  
 if (i==-1) // terminator
  
  
  
 break; 
  
  
 sum=sum+i; 
  
  
 count++; 
  
 }
  
 va_end(args); 
  
 return sum/count; 
  
 };
  
 int main() 
  
 { 
  
 printf (""%d\n"", arith_mean (1, 2, 7, 10, 15, -1 /* terminator */)); };
  
 The first argument has to be treated just like a normal argument. All other arguments are loaded using the
  va_arg
  macro
  
 and then summed.
  
 So what is inside?
  
 46.1.1 
  
 cdecl
  calling conventions
  
 Listing 46.1: Optimizing MSVC 6.0
  
  
 _v$ = 8
  
  
 495",NA
46.2 ,NA,NA
vprintf(),NA,NA
 function case,"Many programmers define their own logging functions which take a printf-like format string + a variable number of argu-
 ments.
  
 Another popular example is the die() function, which prints some message and exits.
  
 We need some way to pack input
  
 arguments of unknown number and pass them to the
  printf()
  function. But how?
  
 That’s why there are functions with
  
 “v” in name. One of them is
  vprintf()
 : it takes a format-string and a pointer to a variable of type
  va_list
 :
  
  
 #include <stdlib.h> 
  
 #include <stdarg.h>
  
 void die (const char * fmt, ...) 
  
 { 
  
 va_list va;
  
 va_start (va, fmt); 
  
 vprintf (fmt, va); 
  
 exit(0); 
  
 };
  
 By closer examination, we can see that
  va_list
  is a pointer to an array. Let’s compile:
  
 Listing 46.4: Optimizing MSVC 2010
  
 _fmt$ = 8 
  
 _die 
  
 PRO
 C
  
 ; load 1st argument (format-string) 
  
 mov 
  
 ecx, DWORD PTR _fmt$[esp-4]",NA
Chapter 47,NA,NA
Strings trimming,"A very common string processing task is to remove some characters at the start and/or at the end.
  
 In this example, we are going to work with a function which removes all newline characters (
 CR
 1
 /
 LF
 2
 ) from the end of the 
 input string:
  
 #include <stdio.h> 
  
 #include <string.h>
  
 char* str_trim (char *s) 
  
 { 
  
 char c; 
  
 size_t str_len;
  
 // work as long as \r or \n is at the end of string 
  
 // stop if some other character there or its an empty string' // (at start or due to our operation) 
  
 for (str_len=strlen(s); str_len>0 && (c=s[str_len-1]); str_len--) { 
  
  
  
 if (c=='\r' || c=='\n') 
  
  
  
  
 s[str_len-1]=0; 
  
  
  
 else 
  
  
  
  
 break; 
  
 }; 
  
 return s; 
  
 };
  
 int main() 
  
 { 
  
 // test
  
 // strdup() is used to copy text string into data segment, // because it will crash on 
 Linux otherwise, 
  
 // where text strings are allocated in constant data segment, // and not modifiable.
  
 printf (""[%s]\n"", str_trim (strdup(""""))); 
  
 printf (""[%s]\n"", str_trim (strdup(""\n""))); 
  
 printf (""[%s]\n"", str_trim (strdup(""\r""))); 
  
 printf (""[%s]\n"", str_trim (strdup(""\n\r""))); 
  
 printf (""[%s]\n"", str_trim (strdup(""\r\n""))); 
  
 printf (""[%s]\n"", str_trim (strdup(""test1\r\n""))); printf (""[%s]\n"", str_trim 
 (strdup(""test2\n\r""))); printf (""[%s]\n"", str_trim (strdup(""test3\n\r\n\r""))); printf 
 (""[%s]\n"", str_trim (strdup(""test4\n""))); printf (""[%s]\n"", str_trim (strdup(""test5\r""))); 
 printf (""[%s]\n"", str_trim (strdup(""test6\r\r\r""))); };
  
 The input argument is always returned on exit, this is convenient when you need to chain string processing functions, like 
 it was done here in the
  main()
  function.
  
 1
 Carriage return (13 or’\r’ in C/C++) 
  
 2
 Line feed (10 or’\n’ in C/C++)
  
 500",NA
47.1 x64: Optimizing MSVC 2013,"Listing 47.1: Optimizing MSVC 2013 x64
  
 s$ = 8 
  
 str_trim PROC
  
 ; RCX is the first function argument and it always holds pointer to the string mov 
  
 rdx, rcx 
  
 ; this is strlen() function inlined right here: 
  
 ; set RAX to 0xFFFFFFFFFFFFFFFF (-1) 
  
 or 
  
 rax, -1 
  
 $LL14@str_trim: 
  
 inc 
  
 rax 
  
 cmp 
  
 BYTE PTR [rcx+rax], 0 
  
 jne 
  
 SHORT $LL14@str_trim 
  
 ; is the input string length zero? exit then: 
  
 test 
  
  
 rax, rax je 
  
 SHORT $LN15@str_trim 
  
 ; RAX holds string length 
  
 dec 
  
 rcx 
  
 ; RCX = s-1 
  
 mov 
  
  
 r8d, 1 add 
  
 rcx, rax 
  
 ; RCX = s-1+strlen(s), i.e., this is the address of the last character in the string sub 
  
 r8, rdx 
  
 ; R8 = 1-s 
  
 $LL6@str_trim:
  
 ; load the last character of the string: 
  
 ; jump, if its code is 13 or 10: 
  
 movzx 
  
 eax, BYTE PTR [rcx] 
  
 cmp 
  
 al, 13 
  
 je 
  
 SHORT $LN2@str_trim 
  
 cmp 
  
 al, 10 
  
 jne 
  
 SHORT $LN15@str_trim 
  
 $LN2@str_trim: 
  
 ; the last character has a 13 or 10 code 
  
 ; write zero at this place: 
  
 mov 
  
  
 BYTE PTR [rcx], 0 ; decrement address of the last character, 
  
 ; so it will point to the character before the one which has just been erased: 
  
 dec 
  
 rcx 
  
 lea 
  
 rax, QWORD PTR [r8+rcx] 
  
 ; RAX = 1 - s + address of the current last character 
  
 ; thus we can determine if we reached the first character and we need to stop, if it is so test 
  
 rax, rax 
  
 jne 
  
 SHORT $LL6@str_trim 
  
 $LN15@str_trim: 
  
 mov 
  
 rax, rdx 
  
 ret 
  
 0 
  
 str_trim ENDP
  
 First, MSVC inlined the
  strlen()
  function code, because it concluded this is to be faster than the usual
  strlen()
  work + the 
 cost of calling it and returning from it. This is called inlining:
  43 on page 481
 .
  
 The first instruction of the inlined
  strlen()
  is
  OR RAX, 0xFFFFFFFFFFFFFFFF
 . It’s hard to say why MSVC uses
  OR 
 instead of
  
 MOV RAX, 0xFFFFFFFFFFFFFFFF
 , but it does this often. And of course, it is equivalent: all bits are set, and
  
 Why would the
  −1
  number be used in
  strlen()
 , one might ask. Due to optimizations, of course. Here is the code that a 
 number with all bits set is
  −1
  in two’s complement arithmetic:
  30 on page 431
 .
  
 Listing 47.2: Inlined
  strlen()
  by MSVC 2013 x64
  
   
 ; RCX = pointer to the input string",NA
47.2,NA,NA
x64: Non-optimizing GCC 4.9.1,"str_trim: 
  
 push 
  
 rbp 
  
 mov 
  
 rbp, rsp 
  
 sub 
  
 rsp, 32 
  
 mov 
  
  
 QWORD PTR [rbp-24], rdi ; for() first part 
 begins here
  
 mov
  
 rax, QWORD PTR [rbp-24]
  
 ; str_len
  
 mov
  
 rdi, rax
  
 call
  
 strlen
  
 mov
  
 QWORD PTR [rbp-8], rax
  
 ; for() first part ends here 
  
 jmp 
  
 .L2 
  
 ; for() body begins here 
  
 .L5:
  
 cmp
  
 BYTE PTR [rbp-9], 13
  
 ; c=='\r'?
  
 je
  
 .L3
  
 ; c=='\n'?
  
 cmp
  
 BYTE PTR [rbp-9], 10
  
 jne
  
 .L4
  
 .L3:
  
 .L3:
  
 mov
  
 rax, QWORD PTR [rbp-8]
  
 ; str_len
  
 lea
  
 rdx, [rax-1]
  
 ; EDX=str_len-1
  
 mov
  
 rax, QWORD PTR [rbp-24]
  
 ; s
  
 add
  
 rax, rdx
  
 ; RAX=s+str_len-1
  
 mov
  
 BYTE PTR [rax], 0
  
 ; s[str_len-1]=0
  
 ; for() body ends here 
  
 ; for() third part begins here
  
 sub
  
 QWORD PTR [rbp-8], 1
  
 ; str_len--
  
 ; for() third part ends here 
  
 .L2: 
  
 ; for() second part begins here
  
 cmp
  
 QWORD PTR [rbp-8], 0
  
 ; str_len==0?
  
 je
  
 .L4
  
 ; exit then
  
 ; check second clause, and load ""c""
  
 mov
  
 rax, QWORD PTR [rbp-8]
  
 ; RAX=str_len
  
 lea
  
 rdx, [rax-1]
  
 ; RDX=str_len-1
  
 mov
  
 rax, QWORD PTR [rbp-24]
  
 ; RAX=s
  
 add
  
 rax, rdx
  
 ; RAX=s+str_len-1",NA
47.3,NA,NA
x64: Optimizing GCC 4.9.1,"str_trim: 
  
 push 
  
 rbx 
  
 mov 
  
 rbx, rdi 
  
 ; RBX will always be ""s"" 
  
 call 
  
 strlen 
  
 ; check for str_len==0 and exit if its so' 
  
 test 
  
 rax, rax 
  
 je 
  
 .L9 
  
 lea 
  
 rdx, [rax-1] 
  
 ; RDX will always contain str_len-1 value, not str_len 
  
 ; so RDX is more like buffer index variable 
  
 lea 
  
 rsi, [rbx+rdx] 
  
 ; RSI=s+str_len-1 
  
 movzx 
  
 ecx, BYTE PTR [rsi] ; load character 
  
 test 
  
 cl, cl 
  
 je 
  
 .L9 
  
 ; exit if its zero' 
  
 cmp 
  
 cl, 10 
  
 je 
  
 .L4 
  
 cmp 
  
  
 cl, 13 
  
 ; exit if its not' '\n' and not '\r' jne 
  
 .L9
  
 .L4: 
  
 ; this is weird instruction. we need RSI=s-1 here.
  
 ; its possible to get it by' MOV RSI, EBX / DEC RSI 
  
 ; but this is two instructions instead of one 
  
 sub 
  
 rsi, rax 
  
 ; RSI = s+str_len-1-str_len = s-1 
  
 ; main loop begin 
  
 .L12: 
  
 test 
  
  
 rdx, rdx ; store zero at address s-1+str_len-1+1 = s-1+str_len = s+str_len-1 mov 
  
 BYTE PTR [rsi+1+rdx], 0 
  
 ; check for str_len-1==0. exit if so.
  
 je
  
 .L9
  
 ; equivalent to str_len--
  
 sub
  
 rdx, 1
  
 ; load next character at address s+str_len-1
  
 movzx
  
 ecx, BYTE PTR [rbx+rdx]
  
 ; is it zero? exit then
  
 test
  
 cl, cl
  
 je
  
 .L9
  
 ; is it '\n'?
  
 cmp
  
 cl, 10
  
  
 503",NA
47.4 ARM64: Non-optimizing GCC (Linaro) 4.9,"This implementation is straightforward:
  
 Listing 47.4: Non-optimizing GCC (Linaro) 4.9
  
 str_trim: 
  
 stp 
  
 x29, x30, [sp, -48]!
  
 add 
  
 x29, sp, 0 
  
 str 
  
 x0, [x29,24] ; copy input argument into local stack 
   
 x0, [x29,24] ; s ldr 
  
 bl 
  
 strlen 
  
 str 
  
 x0, [x29,40] ; str_len variable in local stack b 
  
 .L2 
  
 ; main loop begin 
  
 .L5: 
  
 ldrb 
  
 w0, [x29,39] 
  
 ; W0=c
  
 cmp
  
 w0, 13
  
 ; is it '\r'?
  
 beq
  
 .L3
  
 ldrb
  
 w0, [x29,39]
  
 ; W0=c
  
 cmp
  
 w0, 10
  
 ; is it '\n'?
  
 bne
  
 .L4
  
 ; goto exit if it is not
  
 .L3: 
  
 ldr 
  
 x0, [x29,40] 
  
 ; X0=str_len 
  
 sub 
  
 x0, x0, #1 
  
 ; X0=str_len-1 
  
 ldr 
  
  
 x1, [x29,24] ; X1=s 
  
 add 
  
 x0, x1, x0 
  
 ; X0=s+str_len-1
  
 strb
  
 wzr, [x0]
  
 ; write byte at s+str_len-1
  
 ; decrement str_len: 
  
 ldr 
  
 x0, [x29,40] 
  
 ; X0=str_len 
  
 sub 
  
 x0, x0, #1 
  
 ; X0=str_len-1",NA
47.5,NA,NA
ARM64: Optimizing GCC (Linaro) 4.9,"This is a more advanced optimization.
  
 The first character is loaded at the beginning, and compared against 10 (the
  LF
  
 character).
  
 Characters are also loaded in the main loop, for the characters after first one.
  
 This is somewhat similar to
  
 the
  47.3 on page 503
  example.
  
 Listing 47.5: Optimizing GCC (Linaro) 4.9
  
 str_trim: 
  
 stp 
  
 x29, x30, [sp, -32]!
  
 add 
  
 x29, sp, 0 
  
 str 
  
 x19, [sp,16] 
  
  
  
 x19, x0 mov 
  
 ; X19 will always hold value of ""s"" 
  
 bl 
  
  
 strlen ; X0=str_len
  
 cbz
  
 x0, .L9
  
 ; goto L9 (exit) if str_len==0
  
 sub
  
 x1, x0, #1
  
 ; X1=X0-1=str_len-1 
  
 add 
  
 x3, x19, x1 
  
 ; X3=X19+X1=s+str_len-1
  
 ldrb
  
 w2, [x19,x1]
  
 ; load byte at address X19+X1=s+str_len-1
  
 ; W2=loaded character
  
 cbz
  
 w2, .L9
  
 ; is it zero? jump to exit then
  
 cmp
  
 w2, 10
  
 ; is it '\n'?
  
 bne
  
 .L15
  
 .L12: 
  
 ; main loop body. loaded character is always 10 or 13 at this moment!
  
 sub 
  
 x2, x1, x0 
  
 ; X2=X1-X0=str_len-1-str_len=-1 
  
 add 
  
 x2, x3, x2 
  
 ; X2=X3+X2=s+str_len-1+(-1)=s+str_len-2
  
 strb
  
 wzr, [x2,1]
  
 ; store zero byte at address s+str_len-2+1=s+str_len-1
  
 cbz
  
 x1, .L9
  
 ; str_len-1==0? goto exit, if so
  
 sub
  
 x1, x1, #1
  
 ; str_len--
  
 ldrb
  
 w2, [x19,x1]
  
 ; load next character at address X19+X1=s+str_len-1
  
 cmp
  
 w2, 10
  
 ; is it '\n'?
  
 cbz
  
 w2, .L9
  
 ; jump to exit, if its zero'
  
  
 505",NA
47.6,NA,NA
ARM: Optimizing Keil 6/2013 (ARM mode),"And again, the compiler took advantage of ARM mode’s conditional instructions, so the code is much more compact.
  
 Listing 47.6: Optimizing Keil 6/2013 (ARM mode)
  
 str_trim PROC 
  
 PUSH 
  
 {r4,lr} 
  
 ; R0=s 
  
 MOV 
  
 r4,r0 
  
 ; R4=s
  
 BL
  
 strlen
  
 ; strlen() takes ""s"" value from R0
  
 ; R0=str_len 
  
 MOV 
  
 r3,#0 
  
 ; R3 will always hold 0 
  
 |L0.16|
  
  
 CMP
  
 r0,#0
  
 ; str_len==0?
  
 ADDNE
  
 r2,r4,r0
  
 ; (if str_len!=0) R2=R4+R0=s+str_len
  
 LDRBNE
  
 r1,[r2,#-1]
  
 ; (if str_len!=0) R1=load byte at address R2-1=s+str_len-1
  
 CMPNE
  
 r1,#0
  
 ; (if str_len!=0) compare loaded byte against 0
  
 BEQ
  
 |L0.56|
  
 ; jump to exit if str_len==0 or loaded byte is 0
  
 CMP
  
 r1,#0xd
  
 ; is loaded byte '\r'?
  
 CMPNE
  
 r1,#0xa
  
 ; (if loaded byte is not '\r') is loaded byte '\r'?
  
 SUBEQ
  
 r0,r0,#1
  
 ; (if loaded byte is '\r' or '\n') R0-- or str_len--
  
 STRBEQ
  
 r3,[r2,#-1]
  
 ; (if loaded byte is '\r' or '\n') store R3 (zero) at
  
  
 address R2-1=s+str_len-1
  
 BEQ
  
 |L0.16|
  
 ; jump to loop begin if loaded byte was '\r' or '\n'
  
 |L0.56| 
  
 ; return ""s""
  
 MOV 
  
 r0,r4 
  
 POP 
  
 {r4,pc} 
  
 ENDP",NA
47.7,NA,NA
ARM: Optimizing Keil 6/2013 (Thumb mode),"There are less conditional instructions in Thumb mode, so the code is simpler.
  
 But there are is really weird thing with
  
 the 0x20 and 0x19 offsets. Why did the Keil compiler do so? Honestly, it’s hard to say.
  
 Probably, this is a quirk of Keil’s
  
 optimization process. Nevertheless, the code works correctly.
  
 Listing 47.7: Optimizing Keil 6/2013 (Thumb mode)
  
 str_trim PROC 
  
 PUSH 
  
 {r4,lr} 
  
 MOVS 
  
 r4,r0 
  
 ; R4=s
  
 BL
  
 strlen
  
 ; strlen() takes ""s"" value from R0
  
 ; R0=str_len
  
 MOVS 
  
 r3,#0 
  
 ; R3 will always hold 0 
  
 B 
  
 |L0.24| 
  
 |L0.12|
  
 CMP
  
 r1,#0xd
  
 ; is loaded byte '\r'?
  
 BEQ
  
 |L0.20|
  
 ; is loaded byte '\n'?
  
 CMP
  
 r1,#0xa",NA
47.8,NA,NA
MIPS,"Listing 47.8: Optimizing GCC 4.4.5 (IDA)
  
 str_trim: 
  
 ; IDA is not aware of local variable names, we gave them manually: saved_GP 
  
 = -0x10 
  
 saved_S0 
  
 = -8 
  
 saved_RA 
  
 = -4
  
  
 lui 
  
 $gp, (__gnu_local_gp >> 16) 
  
  
 addiu 
  
 $sp, -0x20 
  
  
 la 
  
 $gp, (__gnu_local_gp & 0xFFFF) 
  
  
 sw 
  
 $ra, 0x20+saved_RA($sp) 
  
  
 sw 
  
 $s0, 0x20+saved_S0($sp) 
  
  
 sw 
  
 $gp, 0x20+saved_GP($sp) 
  
 ; call strlen(). input string address is still in $a0, strlen() will take it from there: 
  
 lw 
  
 $t9, (strlen & 0xFFFF)($gp) 
  
  
 or 
  
  
 $at, $zero ; load delay slot, NOP 
  
 jalr 
  
 $t9 
  
 ; input string address is still in $a0, put it to $s0:
  
 move
  
 $s0, $a0
  
 ; branch delay slot
  
 ; result of strlen() (i.e, length of string) is in $v0 now ; jump to exit if $v0==0 (i.e., 
 if length of string is 0): 
  
 beqz 
  
 $v0, exit 
  
  
 or 
  
 $at, $zero ; branch delay slot, NOP 
  
 addiu 
  
 $a1, $v0, -1 
  
  
 addiu 
  
 $a1, $v0, -1 
  
 ; $a1 = $v0-1 = str_len-1 
  
  
 addu 
  
 $a1, $s0, $a1 
  
 ; $a1 = input string address + $a1 = s+strlen-1 
  
 ; load byte at address $a1: 
  
  
 lb 
  
  
 $a0, 0($a1) 
  
 or 
  
 $at, $zero ; load delay slot, NOP ; 
 loaded byte is zero? jump to exit if its so': 
  
  
 beqz 
  
 $a0, exit 
  
  
 or 
  
 $at, $zero ; branch delay slot, NOP 
  
 addiu 
  
 $v1, $v0, -2 
  
 ; $v1 = str_len-2 
  
  
 addu 
  
 $v1, $s0, $v1 
  
 ; $v1 = $s0+$v1 = s+str_len-2 
  
  
 li 
  
 $a2, 0xD 
  
 ; skip loop body:
  
 b
  
 loc_6C
  
 ; branch delay slot
  
 li
  
 $a3, 0xA
  
 loc_5C: 
  
 ; load next byte from memory to $a0: 
  
  
 lb 
  
 $a0, 0($v1) 
  
  
 move 
  
 $a1, $v1",NA
Chapter 48,NA,NA
toupper() function,"Another very popular function transforms a symbol from lower case to upper case, if needed:
  
 char toupper (char c) 
  
 { 
  
 if(c>='a' && c<='z') 
  
  
  
 return c-'a'+'A';
  
 else 
  
  
  
 return c; 
  
 }
  
 The
  'a'+'A'
  expression is left in the source code for better readability, it will be optimized by compiler, of course
 1
 . The
  ASCII
  
 code of “a” is 97 (or 0x61), and 65 (or 0x41) for “A”. The difference (or distance) between them in the
  ASCII
  table is 32 (or 
 0x20).
  
 For better understanding, the reader may take a look at the 7-bit standard
  ASCII
  table:
  
  
 Figure 48.1: 7-bit
  ASCII
  table in Emacs",NA
48.1 ,NA,NA
x64,"48.1.1 
  
 Two comparison operations
  
 Non-optimizing MSVC is straightforward: the code checks if the input symbol is in [97..122] range (or in [‘a’..‘z’] range) and 
 subtracts 32 if it’s true. There are also some minor compiler artefact:
  
 Listing 48.1: Non-optimizing MSVC 2013 (x64)
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 c$ = 8 
  
 toupper PROC 
  
 mov 
  
 BYTE PTR [rsp+8], cl 
  
 movsx 
  
 eax, BYTE PTR c$[rsp]
  
 cmp 
  
 eax, 97
  
 jl 
  
 SHORT $LN2@toupper
  
 movsx 
  
 eax, BYTE PTR c$[rsp]
  
 cmp 
  
 eax, 122
  
  
  
 1
 However, to be meticulous, there still could be compilers which can’t optimize such expressions and will leave them right in the code.
  
 509",NA
48.2 ,NA,NA
ARM,"Optimizing Keil for ARM mode also generates only one comparison:
  
 Listing 48.5: Optimizing Keil 6/2013 (ARM mode)
  
 toupper PROC
  
 SUB 
  
 r1,r0,#0x61
  
 CMP 
  
 r1,#0x19
  
 SUBLS 
  
 r0,r0,#0x20
  
 ANDLS 
  
 r0,r0,#0xff
  
 BX 
  
 lr
  
 ENDP
  
 The SUBLS and ANDLS instructions are executed only if the value in
  R1
  is less than 0x19 (or equal). They also do the actual 
 conversion.
  
 Optimizing Keil for Thumb mode generates only one comparison operation as well:
  
 Listing 48.6: Optimizing Keil 6/2013 (Thumb mode)
  
 toupper PROC 
  
 MOVS 
  
 r1,r0 
  
 SUBS 
  
 r1,r1,#0x61 
  
 CMP 
  
 r1,#0x19 
  
 BHI 
  
  
 |L0.14| SUBS 
  
 r0,r0,#0x20
  
 LSLS 
  
 r0,r0,#24 
  
 LSRS 
  
 r0,r0,#24 
  
 |L0.14| 
  
 BX 
  
 lr 
  
 ENDP
  
  
 The last two LSLS and LSRS instructions work like
  AND reg, 0xFF
 : they are equivalent to the C/C++-expression
  (
 i
  << 24) >> 
 24
 . Seems like that Keil for Thumb mode deduced that two 2-byte instructions are shorter than the code that loads
  
 48.2.1
  
 GCC for ARM64
  
 Listing 48.7: Non-optimizing GCC 4.9 (ARM64)
  
 toupper: 
  
 sub 
  
 sp, sp, #16 
  
 strb 
  
 w0, [sp,15] 
  
 ldrb 
  
 w0, [sp,15] 
  
 cmp 
  
  
 w0, 96 bls 
  
 .L2 
  
 ldrb 
  
 w0, [sp,15] 
  
 cmp 
  
 w0, 122 
  
 bhi 
  
 .L2",NA
48.3,NA,NA
Summary,"All these compiler optimizations are very popular nowadays and a practicing reverse engineer usually sees such code 
 patterns
  
 often.",NA
Chapter 49,NA,NA
Incorrectly disassembled code,Practicing reverse engineers often have to deal with incorrectly disassembled code.,NA
49.1 ,NA,NA
Disassembling from an incorrect start (x86),"Unlike ARM and MIPS (where any instruction has a length of 2 or 4 bytes), x86 instructions have variable size, so any
  
 disassembler that starts in the middle of a x86 instruction may produce incorrect results.
  
 As an example:
  
 add 
  
 [ebp-31F7Bh], cl 
  
 dec 
  
 dword ptr [ecx-3277Bh] 
  
 dec 
  
 dword ptr [ebp-2CF7Bh] 
  
 inc 
  
 dword ptr [ebx-7A76F33Ch] 
  
 fdiv 
  
 st(4), st 
  
 db 0FFh 
  
 dec 
  
 dword ptr [ecx-21F7Bh] 
  
 dec 
  
 dword ptr [ecx-22373h] 
  
 dec 
  
  
 dword ptr [ecx-2276Bh] dec 
  
 dword ptr [ecx-22B63h] 
  
 dec 
  
 dword ptr [ecx-22F4Bh] 
  
 dec 
  
 dword ptr [ecx-23343h] 
  
 jmp 
  
  
 dword ptr [esi-74h] xchg 
  
 eax, ebp 
  
 clc 
  
 std 
  
 db 0FFh 
  
 db 0FFh 
  
 mov 
  
  
 word ptr [ebp-214h], cs ; <- disassembler finally found right track here mov 
  
 word ptr [ebp-238h], 
 ds 
  
 mov 
  
 word ptr [ebp-23Ch], es
  
 mov 
  
 word ptr [ebp-240h], fs 
  
 mov 
  
 word ptr [ebp-244h], gs 
  
 pushf 
  
 pop 
  
 dword ptr [ebp-210h] 
  
 mov 
  
  
 eax, [ebp+4] mov 
  
 [ebp-218h], 
 eax 
  
 lea 
  
 eax, [ebp+4] 
  
 mov 
  
 [ebp-20Ch], eax 
  
 mov 
  
  
 dword ptr [ebp-2D0h], 10001h mov 
  
 eax, [eax-4] 
  
 mov 
  
 [ebp-21Ch], eax 
  
 mov 
  
 eax, [ebp+0Ch] 
  
 mov 
  
  
 [ebp-320h], eax mov 
  
 eax, [ebp+10h] 
  
 mov 
  
 [ebp-31Ch], eax 
  
 mov 
  
 eax, [ebp+4] 
  
 mov 
  
  
 [ebp-314h], eax call 
  
 ds:IsDebuggerPresent 
  
 513",NA
49.2 ,NA,NA
How does random noise looks disassembled?,"Common properties that can be spotted easily are:
  
 • Unusually big instruction dispersion. 
  
 The most frequent x86 instructions are
  PUSH
 ,
  MOV
 ,
  CALL
 , but here we see 
  
  
 instructions from all instruction groups:
  FPU
  instructions,
  IN
 /
 OUT
  instructions, rare and system instructions, 
 everything 
  
  
 mixed up in one single place.
  
 • Big and random values, offsets and immediates.
  
 • Jumps having incorrect offsets, often jumping in the middle of another instructions.
  
 Listing 49.1: random noise (x86)
  
 mov bl, 0Ch 
  
 mov ecx, 0D38558Dh 
  
 mov eax, ds:2C869A86h 
  
 db 67h 
  
 mov dl, 0CCh 
  
 insb 
  
 movsb 
  
 push eax 
  
 xor [edx-53h], ah 
  
 fcom qword ptr [edi-45A0EF72h] 
  
 pop esp 
  
 pop ss 
  
 in eax, dx 
  
 dec ebx 
  
 push esp 
  
 lds esp, [esi-41h] 
  
 retf 
  
 rcl 
  
 dword ptr [eax], cl mov cl, 9Ch 
  
 mov ch, 0DFh 
  
 push cs 
  
 insb 
  
 mov esi, 0D9C65E4Dh 
  
 imul ebp, [ecx], 66h
  
 pushf 
  
 sal dword ptr [ebp-64h], cl 
  
 sub eax, 0AC433D64h 
  
 out 8Ch, eax 
  
 pop 
  
 ss sbb [eax], ebx 
  
 aas 
  
 xchg cl, [ebx+ebx*4+14B31Eh] 
  
 jecxz short near ptr loc_58+1 
  
 xor al, 0C6h 
  
 inc edx 
  
 db 36h 
  
 pusha 
  
 stosb 
  
 test [ebx], ebx 
  
 sub al, 0D3h ; 'L' 
  
 pop eax 
  
 stosb
  
 loc_58: ; CODE XREF: seg000:0000004A 
  
  
 test 
  
 [esi], eax 
  
  
 inc 
  
 ebp 
  
  
 das 
  
  
 db 
  
 64h",NA
Chapter 50,NA,NA
Obfuscation,The obfuscation is an attempt to hide the code (or its meaning) from reverse engineers.,NA
50.1 ,NA,NA
Text strings,"As we saw in (
  57 on page 630
 ) , text strings may be really helpful. 
 making it impossible to find the string in
  IDA
  or any hex editor.
  
 Here is the simplest method.
  
 This is how the string can be constructed:
  
 Programmers who are aware of this try to hide them,
  
 mov byte ptr [ebx], 'h' 
  
 mov byte ptr [ebx+1], 'e' 
  
 mov byte ptr [ebx+2], 'l' 
  
 mov byte ptr [ebx+3], 'l' 
  
 mov byte ptr [ebx+4], 'o' 
  
 mov byte ptr [ebx+5], ' '
  
 mov byte ptr [ebx+6], 'w'
  
 mov byte ptr [ebx+7], 'o'
  
 mov byte ptr [ebx+8], 'r'
  
 mov byte ptr [ebx+9], 'l'
  
 mov byte ptr [ebx+10], 'd'
  
 The string is also can be compared with another one like this:
  
 mov ebx, offset username 
  
 cmp byte ptr [ebx], 'j' 
  
 jnz fail 
  
 cmp byte ptr [ebx+1], 'o' 
  
 jnz fail
  
 cmp byte ptr [ebx+2], 'h' 
  
 jnz fail 
  
 cmp byte ptr [ebx+3], 'n' 
  
 jnz fail 
  
 jz it_is_john
  
 In both cases, it is impossible to find these strings straightforwardly in a hex editor.
  
 By the way, this is a way to work with the strings when it is impossible to allocate space for them in the data segment, for 
 example in a
  PIC
  or in shellcode.
  
 Another method is to use
  sprintf()
  for the construction:
  
 sprintf(buf, ""%s%c%s%c%s"", ""hel"",'l',""o w"",'o',""rld"");
  
  
 The code looks weird, but as a simple anti-reversing measure, it may be helpful.
  
 Text strings may also be present in encrypted form, then every string usage is to be preceded by a string decrypting 
 routine. For example:
  78.2 on page 737
 .
  
 518",NA
50.2 ,NA,NA
Executable code,"CHAPTER 50. OBFUSCATION
  
 50.2.1
  
 Inserting garbage
  
 Executable code obfuscation implies inserting random garbage code between real one, which executes but does nothing 
 useful.
  
 A simple example:
  
 Listing 50.1: original code
  
 add eax, ebx
  
 mul ecx
  
 Listing 50.2: obfuscated code
  
 xor esi, 011223344h ; garbage
  
 add esi, eax 
  
 ; garbage
  
 add eax, ebx
  
 mov edx, eax 
  
 ; garbage
  
 shl
  
 edx, 4
  
 ; garbage
  
 mul
  
 ecx
  
 ; garbage
  
 xor
  
 esi, ecx
  
  
 Here the garbage code uses registers which are not used in the real code (
 ESI
  and
  EDX
 ). However, the intermediate results 
 produced by the real code may be used by the garbage instructions for some extra mess—why not?
  
 50.2.2 
  
 Replacing instructions with bloated equivalents
  
 •
  MOV op1, op2
  can be replaced by the
  PUSH op2 / POP op1
  pair.
  
 •
  JMP label
  can be replaced by the
  PUSH label / RET
  pair.
  IDA
  will not show the references to the label.•
  CALL label
  
 can be replaced by the following instructions triplet:
  PUSH label_after_CALL_instruction / 
  
 PUSH label / RET
 .
  
 •
  PUSH op
  can also be replaced with the following instructions pair:
  SUB ESP, 4 (or 8) / MOV [ESP], op
 .
  
 50.2.3 
  
 Always executed/never executed code
  
 If the developer is sure that ESI at always 0 at that point:
  
 mov esi, 1 
  
 ... ; some code not touching ESI 
  
 dec esi 
  
 ... ; some code not touching ESI
  
 cmp esi, 0 
  
 jz real_code 
  
 ; fake luggage 
  
 real_code:
  
 The reverse engineer needs some time to get into it.
  
 This is also called an
  opaque predicate
 .
  
 Another example ( and again, the developer is sure that ESI is always zero):
  
 add
  
 eax, ebx
  
 ; real code
  
 mul
  
 ecx
  
 ; real code
  
  
  
 add
  
 eax, esi
  
 ; opaque predicate. XOR, AND or SHL, etc, can be here instead of ADD.
  
  
  
 50.2.4
  
 Making a lot of mess
  
  
 instruction 1 
  
 instruction 2
  
 instruction 3
  
 519",NA
50.3 Virtual machine / pseudo-code ,"A programmer can construct his/her own
  PL
  or
  ISA
  and interpreter for it. (Like the pre-5.0 Visual Basic, .NET or Java 
 machines).
  
 The reverse engineer will have to spend some time to understand the meaning and details of all of the
  ISA
 ’s instructions.
  
 Probably, he/she will also have to write a disassembler/decompiler of some sort.",NA
50.4 ,NA,NA
Other things to mention ,"My own (yet weak) attempt to patch the Tiny C compiler to produce obfuscated code:
  http://go.yurichev.com/17220
 .
  
 Using the
  MOV
  instruction for really complicated things: [
 Dol13
 ].",NA
50.5 ,NA,NA
Exercise,"•
  http://challenges.re/29",NA
Chapter 51,NA,NA
C++,NA,NA
51.1 ,NA,NA
Classes,"51.1.1 
  
 A simple example
  
 Internally, the representation of C++ classes is almost the same as the structures.
  
 Let’s try an example with two variables, two constructors and one method:
  
 #include <stdio.h>
  
 class c 
  
 { 
  
 private: 
  
  
 int v1; 
  
  
 int v2; 
  
 public: 
  
  
 c() // default ctor 
  
  
 { 
  
  
 v1=667; 
  
  
 v2=999; 
  
  
 };
  
 c(int a, int b) // ctor 
  
 { 
  
 v1=a; 
  
 v2=b;
  
 };
  
  
 void dump() 
  
  
 { 
  
  
 printf (""%d; %d\n"", v1, v2); 
  
  
 }; 
  
 };
  
 int main() 
  
 { 
  
  
 class c c1; 
  
  
 class c c2(5,6);
  
 c1.dump(); 
  
 c2.dump();
  
  
 return 0; 
  
 };
  
 MSVC—x86
  
 Here is how the
  main()
  function looks like, translated into assembly language:
  
 521",NA
51.2 ,NA,NA
ostream,"Let’s start again with a “hello world” example, but now we are going to use ostream:
  
 #include <iostream> 
  
 int main()
  
 { 
  
  
 std::cout << ""Hello, world!\n""; 
  
 }
  
 Almost any C++ textbook tells us that the
  <<
  operation can be replaced (overloaded) for other types. That is what is done 
 in ostream. We see that
  operator<<
  is called for ostream: 
  
 Listing 51.18: MSVC 2012 (reduced listing)
  
 $SG37112 DB 'Hello, world!', 0aH, 00H
  
 _main PROC 
  
 push OFFSET $SG37112 
  
 push OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout call 
 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?
  
 add $char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> > 
  
  
 esp, 8
  
 ⤦
  
  
 xor 
  
 eax, eax 
  
  
 ret 
  
 0 
  
 _main ENDP
  
 Let’s modify the example:
  
 #include <iostream> 
  
 int main()
  
 { 
  
  
 std::cout << ""Hello, "" << ""world!\n""; 
  
 }
  
 And again, from many C++ textbooks we know that the result of each
  operator<<
  in ostream is forwarded to the next one.
  
 Indeed: 
  
  
 Listing 51.19: MSVC 2012
  
 $SG37112 DB 'world!', 0aH, 00H 
  
 $SG37113 DB 'Hello, ', 00H
  
 _main PROC 
  
 push OFFSET $SG37113 ; 'Hello, ' 
  
 push OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout call 
 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?
 ⤦
 add 
 $char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> > esp, 8
  
 push OFFSET $SG37112 ; 'world!' 
  
 push eax 
  
 ; result of previous function execution 
  
 call ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?
 ⤦
 add 
 $char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> > 
  
  
 esp, 
 8
  
  
 xor 
  
 eax, eax 
  
  
 ret 
  
 0 
  
 _main ENDP
  
 If we would rename
  operator<<
  method name to
  f()
 , that code will looks like:
  
 537",NA
51.3 ,NA,NA
References,"In C++, references are pointers (
  10 on page 100
 ) as well, but they are called
  safe
 , because it is harder to make a mistake 
 while dealing with them [
 ISO13
 , p. 8.3.2]. For example, reference must always be pointing to an object of the 
 corresponding type and cannot be NULL [
 Cli
 , p. 8.6]. Even more than that, references cannot be changed, it is impossible 
 to point them to another object (reseat) [
 Cli
 , p. 8.5].
  
 If we are going to try to change the example with pointers (
  10 on page 100
 ) to use references instead …
  
 void f2 (int x, int y, int & sum, int & product) 
  
 { 
  
 sum=x+y;
  
 product=x*y; 
  
 };
  
 …then we can see that the compiled code is just the same as in the pointers example (
  10 on page 100
 ):
  
 Listing 51.20: Optimizing MSVC 2010
  
 _x$ = 8 
  
  
  
 ; size = 4 _y$ = 
 12 
  
  
  
 ; size = 4 
 _sum$ = 16 
  
  
 ; size = 4 
 _product$ = 20 
  
  
 ; size = 4 
 ?f2@@YAXHHAAH0@Z PROC 
  
 ; f2 mov 
  
 ecx, DWORD PTR _y$[esp-4] 
  
 mov 
  
 eax, DWORD PTR _x$[esp-4] 
  
 lea 
  
 edx, DWORD PTR [eax+ecx] 
  
 imul eax, ecx
  
 mov ecx, DWORD PTR _product$[esp-4] 
  
 push esi 
  
 mov 
  
 esi, DWORD PTR _sum$[esp] 
  
 mov 
  
 DWORD PTR [esi], edx 
  
 mov 
  
 DWORD PTR [ecx], eax 
  
 pop 
  
 esi 
  
 ret 
  
 0 
  
 ?f2@@YAXHHAAH0@Z ENDP 
  
 ; f2
  
 ( The reason why C++ functions has such strange names is explained here:
  51.1.1 on page 522
 .)
  
 Hence, C++ references are as much efficient as usual pointers.",NA
51.4 ,NA,NA
STL,"N.B.: all examples here were checked only in 32-bit environment. x64 wasn’t checked.
  
 51.4.1 
  
 std::string
  
 Internals
  
 Many string libraries [
 Yur13
 , p. 2.2] implement a structure that contains a pointer to a string buffer, a variable that always 
 contains the current string length (which is very convenient for many functions: [
 Yur13
 , p. 2.2.1]) and a variable containing 
 the current buffer size. The string in the buffer is usually terminated with zero, in order to be able to pass a pointer to the 
 buffer into the functions that take usual C
  ASCIIZ
  strings.
  
 It is not specified in the C++ standard [
 ISO13
 ] how std::string has to be implemented, however, it is usually implemented as 
 explained above.
  
 The C++ string is not a class (as QString in Qt, for instance) but a template (basic_string), this is done in order to support 
 various character types: at least
  char
  and
  wchar_t
 .
  
 So, std::string is a class with
  char
  as its base type. And std::wstring is a class with
  wchar_t
  as its base type.",NA
Chapter 52,NA,NA
Negative array indices,"It’s possible to address the space
  before
  an array by supplying a negative index, e.g.,
  array
 [−1]
 . It’s very hard to say why 
 one should use it, there is probably only one known practical application of this technique. C/C++ array elements indices 
 start at 0, but some
  PL
 s have a first index at 1 (at least FORTRAN). Programmers may still have this habit, so using this 
 little trick, it’s possible to address the first element in C/C++ using index 1:
  
  
 #include <stdio.h>
  
 int main() 
  
 { 
  
 int random_value=0x11223344; 
  
 unsigned char array[10]; 
  
 int i; 
  
 unsigned char *fakearray=&array[-1];
  
 for (i=0; i<10; i++) 
  
  
 array[i]=i;
  
 printf (""first element %d\n"", fakearray[1]); 
  
 printf (""second element %d\n"", fakearray[2]); 
  
 printf (""last element %d\n"", fakearray[10]);
  
 printf (""array[-1]=%02X, array[-2]=%02X, array[-3]=%02X, array[-4]=%02X\n"", 
  
  
 array[-1], 
  
  
  
 array[-2], 
  
  
  
 array[-3], 
  
  
  
 array[-4]); 
  
 };
  
 Listing 52.1: Non-optimizing MSVC 2010
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1 
 1
 2 
 1
 3 
 1
 4 
 1
 5 
 1
 6 
 1
 $SG2751 DB 
  
 'first element %d', 0aH, 00H 
  
 $SG2752 DB 
  
 'second element %d', 0aH, 00H 
  
 $SG2753 DB 
  
 'last element %d', 0aH, 00H 
  
 $SG2754 DB 
  
 'array[-1]=%02X, array[-2]=%02X, array[-3]=%02X, array[-4' DB 
  
 ']=%02X', 
 0aH, 00H
  
 _fakearray$ = -24 
  
  
 ; size = 4 
  
 _random_value$ = -20 
  
 ; size = 4 
  
 _array$ = -16 
  
 ; size = 10 
  
 _i$ = -4 
  
 ; size = 4 
  
 _main 
  
 PROC
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 sub 
  
 esp, 24 
  
 mov 
  
 DWORD PTR _random_value$[ebp], 287454020 ; 11223344H ; set 
 fakearray[] one byte earlier before array[] 
  
 lea 
  
 eax, DWORD PTR _array$[ebp] 
  
 add 
  
 eax, -1 ; eax=eax-1 
  
 mov 
  
 DWORD PTR _fakearray$[ebp], eax 
  
 mov 
  
  
 DWORD PTR _i$[ebp], 0 jmp 
  
 SHORT $LN3@main 
  
 ; fill array[] with 0..9
  
  
 571",NA
Chapter 53,NA,NA
Windows 16-bit,"16-bit Windows programs are rare nowadays, but can be used in the cases of retrocomputing or dongle hacking (
  78 on 
 page 730
 ).
  
 16-bit Windows versions were up to 3.11. 96/98/ME also support 16-bit code, as well as the 32-bit versions of the
  Windows 
 NT
  line. The 64-bit versions of
  Windows NT
  line do not support 16-bit executable code at all.
  
 The code resembles MS-DOS’s one.
  
 Executable files are of type NE-type (so-called “new executable”).
  
 All examples considered here were compiled by the OpenWatcom 1.9 compiler, using these 
 switches: 
 wcl.exe -i=C:/WATCOM/h/win/ -s -os -bt=windows -bcl=windows example.c",NA
53.1,NA,NA
Example#1,"#include <windows.h>
  
 int PASCAL WinMain( HINSTANCE hInstance, 
  
 HINSTANCE hPrevInstance, 
  
 LPSTR lpCmdLine,
  
  
  
 int nCmdShow ) 
  
 { 
  
 MessageBeep(MB_ICONEXCLAMATION); 
  
 return 0; 
  
 };
  
  
 WinMain
  
 proc near
  
 ; MB_ICONEXCLAMATION constant
  
 push
  
 bp
  
 mov
  
 bp, sp
  
 mov
  
 ax, 30h ; '0'
  
 push
  
 ax
  
  
 WinMain
  
 call
  
 MESSAGEBEEP
  
 ; return 0
  
 xor
  
 ax, ax
  
 pop
  
 bp
  
 retn
  
 0Ah
  
 endp
  
  
 Seems to be easy, so far.",NA
53.2,NA,NA
Example #2,"#include <windows.h> 
  
 int PASCAL WinMain( HINSTANCE hInstance, 
  
  
 HINSTANCE hPrevInstance,
  
  
  
 LPSTR lpCmdLine, 
  
  
  
 int nCmdShow ) 
  
 { 
  
 MessageBox (NULL, ""hello, world"", ""caption"", MB_YESNOCANCEL);
  
 574",NA
53.3,NA,NA
Example #3,"#include <windows.h>
  
 int PASCAL WinMain( HINSTANCE hInstance, 
  
  
  
 HINSTANCE hPrevInstance, 
  
  
  
 LPSTR lpCmdLine, 
  
  
  
 int nCmdShow ) 
  
 { 
  
  
 int result=MessageBox (NULL, ""hello, world"", ""caption"", MB_YESNOCANCEL);
  
 if (result==IDCANCEL) 
  
 MessageBox (NULL, ""you pressed cancel"", ""caption"", MB_OK); else if (result==IDYES) 
  
 MessageBox (NULL, ""you pressed yes"", ""caption"", MB_OK); else if (result==IDNO) 
  
 MessageBox (NULL, ""you pressed no"", ""caption"", MB_OK);
  
  
 return 0; 
  
 };
  
   
 WinMain
  
 proc near
  
 ; NULL
  
 push
  
 bp
  
 mov
  
 bp, sp
  
 xor
  
 ax, ax
  
 push
  
 ax
  
 push
  
 ds
  
  
 mov 
  
 ax, offset aHelloWorld ; ""hello, world"" 
  
 push 
  
 ax 
  
 push 
  
 ds 
  
 mov 
  
 ax, offset aCaption ; ""caption"" 
  
 push 
  
 ax 
  
 mov 
  
 ax, 3 
  
 ; MB_YESNOCANCEL 
  
 push 
  
 ax",NA
53.4,NA,NA
Example #4,"#include <windows.h>
  
 int PASCAL func1 (int a, int b, int c) 
  
 { 
  
 return a*b+c; 
  
 };
  
 long PASCAL func2 (long a, long b, long c) 
  
 { 
  
 return a*b+c; 
  
 };
  
 long PASCAL func3 (long a, long b, long c, int d)
  
 { 
  
 return a*b+c-d; 
  
 };
  
 int PASCAL WinMain( HINSTANCE hInstance, 
  
  
  
 HINSTANCE hPrevInstance, 
  
  
  
 LPSTR lpCmdLine, 
  
  
  
 int nCmdShow ) 
  
 { 
  
 func1 (123, 456, 789); 
  
 func2 (600000, 700000, 800000); 
  
 func3 (600000, 700000, 800000, 123); 
  
 return 0;
  
 576",NA
53.5,NA,NA
Example #5,"#include <windows.h> 
  
 int PASCAL string_compare (char *s1, char *s2) 
  
 {
  
 while (1) 
  
 { 
  
  
 if (*s1!=*s2) 
  
  
  
 return 0;",NA
53.6,NA,NA
Example #6,"#include <windows.h> 
  
 #include <time.h> 
  
 #include <stdio.h>
  
 char strbuf[256];
  
 int PASCAL WinMain( HINSTANCE hInstance, 
  
  
 HINSTANCE hPrevInstance, 
  
  
 LPSTR lpCmdLine, 
  
  
 int nCmdShow ) 
  
 {
  
 struct tm *t;
  
 time_t unix_time; 
  
 unix_time=time(NULL); 
  
 t=localtime (&unix_time);
  
  tm_mday, sprintf (strbuf, ""%04d-%02d-%02d %02d:%02d:%02d"", t->tm_year+1900, t->tm_mon, t->
 ⤦
 t->tm_hour, t-
 >tm_min, t->tm_sec); 
  
  
 MessageBox (NULL, strbuf, ""caption"", MB_OK); 
  
  
 return 0; 
  
 };
  
  
 WinMain 
  
 proc near
  
 var_4 
  
 = word ptr -4
  
 var_2 
  
 = word ptr -2
  
 push 
  
 bp
  
 mov 
  
 bp, sp
  
 push 
  
 ax
  
 push 
  
 ax
  
 xor 
  
 ax, ax
  
 call 
  
 time_
  
 mov
  
 [bp+var_4], ax
  
 ; low part of UNIX time
  
 mov
  
 [bp+var_2], dx
  
 ; high part of UNIX time
  
 lea
  
 ax, [bp+var_4]
  
 ; take a pointer of high part
  
 call
  
 localtime_
  
 ; t
  
 mov
  
 bx, ax
  
 push
  
 word ptr [bx]
  
 ; second
  
 push
  
 word ptr [bx+2]
  
 ; minute
  
 push
  
 word ptr [bx+4]
  
 ; hour
  
 push
  
 word ptr [bx+6]
  
 ; day
  
 push
  
 word ptr [bx+8]
  
 ; month
  
 mov
  
 ax, [bx+0Ah]
  
 ; year",NA
Part IV ,NA,NA
Java,585,NA
Chapter 54,NA,NA
Java,NA,NA
54.1 ,NA,NA
Introduction,"There are some well-known decompilers for Java (or
  JVM
  bytecode in general)
 1
 .
  
 The reason is the decompilation of
  JVM
 -bytecode is somewhat easier than for lower level x86 
 code:• There is much more information about the data types.
  
 • The
  JVM
  memory model is much more rigorous and outlined.
  
 • The Java compiler don’t do any optimizations (the
  JVM JIT
 2
 does them at runtime), so the bytecode in the class files is 
  
 usually pretty readable.
  
 When can the knowledge of
  JVM
  be useful?
  
 • Quick-and-dirty patching tasks of class files without the need to recompile the decompiler’s results.
  
 • Analysing obfuscated code.
  
 • Building your own obfuscator.
  
 • Building a compiler codegenerator (back-end) targeting
  JVM
  (like Scala, Clojure, etc
 3
 ).
  
 Let’s start with some simple pieces of code. JDK 1.7 is used everywhere, unless mentioned otherwise.
  
 This is the command used to decompile class files everywhere :
  javap -c -verbose 
 This 
 is the book I used while preparing all examples : [
 Jav13
 ].",NA
54.2,NA,NA
Returning a value,"Probably the simplest Java function is the one which returns some value. Oh, and we must keep in mind that there are no
  
 “free” functions in Java in common sense, they are “methods”.
  
 Each method is related to some class, so it’s not possible to
  
 define a method outside of a class. But we’ll call them “functions” anyway, for simplicity.
  
  
 public class ret 
  
 { 
  
 public static int main(String[] args) 
  
 {
  
  
  
 return 0; 
  
 } 
  
 }
  
 Let’s compile it:
  
 javac ret.java
  
  
 …and decompile it using the standard Java utility:
  
 javap -c -verbose ret.class
  
  
 1
 For example, JAD:
  http://varaneckas.com/jad/ 
  
 2
 Just-in-time compilation 
  
 3
 Full list:
  http://en.wikipedia.org/wiki/List_of_JVM_languages
  
 586",NA
54.3,NA,NA
Simple calculating functions,"Let’s continue with a simple calculating functions.
  
 public class calc 
  
 { 
  
 public static int half(int a) 
  
 {
  
  
  
 return a/2; 
  
 } 
  
 }
  
 Here’s the output when the
  iconst_2
  instruction is used:
  
 public static int half(int); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC
  
 Code: 
  
 stack=2, locals=1, args_size=1",NA
54.4 ,NA,NA
JVM,NA,NA
 memory model,"x86 and other low-level environments use the stack for argument passing and as a local variables storage.
  
 different.
  
 JVM
  is slightly
  
 It has:
  
 • Local variable array (
 LVA
 6
 ). Used as storage for incoming function arguments and local variables. 
  
 Instructions like 
  
 iload_0
  load values from it.
  istore
  stores values in it. In the beginning the function arguments are stored: starting 
  
 at 0 or at 1 (if the zeroth argument is occupied by
  this
  pointer). Then the local variables are allocated.
  
 Each slot has size of 32-bit. Hence, values of
  long
  and
  double
  data types occupy two slots.
  
 • Operand stack (or just “stack”). It’s used for computations and passing arguments while calling other functions. 
 Unlike low-level environments like x86, it’s not possible to access the stack without using instructions which 
 explicitly pushes or pops values to/from it.
  
 • Heap. It is used as storage for objects and arrays.
  
 These 3 areas are isolated from each other.",NA
54.5 ,NA,NA
Simple function calling,"Math.random()
  returns a pseudorandom number in range of [0.0 …1.0), but let’s say that for some reason we need to devise 
 a function that returns a number in range of [0.0 …0.5):
  
 public class HalfRandom 
  
 { 
  
 public static double f() 
  
 {
  
  
  
 return Math.random()/2; 
  
 } 
  
 }
  
 Listing 54.8: Constant pool
  
 ...
  
 #2 = Methodref
  
 #18.#19
  
 //
  
 java/lang/Math.random:()D
  
 #3 = Double
  
 2.0d
  
 ...
  
 #12 = Utf8 
  
 ()D
  
 ...
  
 #18 = Class
  
 #22
  
 //
  
 java/lang/Math
  
 #19 = NameAndType
  
 #23:#12
  
 //
  
 random:()D
  
 #22 = Utf8
  
 java/lang/Math
  
 #23 = Utf8
  
 random
  
  
  
 public static double f(); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
  
 Code: 
  
   
 stack=4, locals=0, args_size=0
  
 0: invokestatic
  
 #2
  
 // Method java/lang/Math.random:()D
  
 3: ldc2_w
  
 #3
  
 // double 2.0d
  
 6: ddiv 
  
 7: dreturn
  
  
 invokestatic
  calls the
  Math.random()
  function and leaves the result at the
  TOS
 .
  
 Then the result is divided by 2.0
  
 and returned.
  
 But how is the function name encoded?
  
 It’s encoded in the constant pool using a
  Methodref
  expression.
  
 It defines the class and method names. The first field of
  Methodref
  points to a
  Class
  expression which, in turn, points to
  
 the usual text string (“java/lang/Math”).
  
 The second
  Methodref
  expression points to a
  NameAndType
  expression which
  
 also has two links to the strings.
  
 The first string is “random”, which is the name of the method.
  
 The second string is “()D”,
  
 which encodes the function’s type. It means that it returns a
  double
  value (hence the
  D
  in the string). This is the way 1) JVM 
 can check data for type correctness; 2) Java decompilers can restore data types from a compiled class file.
  
 Now let’s try the “Hello, world!” example:
  
 6
 (Java) Local Variable Array",NA
54.6 ,NA,NA
Calling beep(),"This is a simple calling of two functions without arguments:
  
 public static void main(String[] args) 
  
 {
  
  
 java.awt.Toolkit.getDefaultToolkit().beep(); };
  
 7
 About difference in pointers and
  reference
 ’s in C++ see:
  51.3 on page 538
 .
  
 594",NA
54.7 ,NA,NA
Linear congruential,NA,NA
 PRNG,"Let’s try a simple pseudorandom numbers generator, which we already considered once in the book (
  20 on page 323
 ):
  
 public class LCG 
  
 { 
  
 public static int rand_state;
  
 public void my_srand (int init) 
  
 { 
  
  
 rand_state=init; 
  
 }
  
 public static int RNG_a=1664525;
  
 public static int RNG_c=1013904223;
  
 public int my_rand () 
  
 { 
  
  
  
 rand_state=rand_state*RNG_a; 
  
  
  
 rand_state=rand_state+RNG_c; 
  
  
  
 return rand_state & 0x7fff; 
  
 } 
  
 }
  
 There are couple of class fields which are initialized at start. But how? In
  javap
  output we can find the class constructor:
  
 static {}; 
  
  
 flags: ACC_STATIC 
  
  
 Code: 
  
   
 stack=1, locals=0, args_size=0
  
 0: ldc
  
 #5
  
 // int 1664525
  
  
  
 2: putstatic
  
 #3
  
 // Field RNG_a:I
  
 5: ldc
  
 #6
  
 // int 1013904223
  
 7: putstatic
  
 #4
  
 // Field RNG_c:I
  
 10: return
  
  
 That’s the way variables are initialized. 
 the constants there.
  
 RNG_a
  occupies the 3rd slot in the class and
  RNG_c
 —4th, and
  putstatic
  puts
  
 The
  my_srand()
  function just stores the input value in
  rand_state
 :
  
 public void my_srand(int); 
  
  
 flags: ACC_PUBLIC 
  
  
 Code: 
  
   
 stack=1, locals=2, args_size=2
  
 0: iload_1
  
 1: putstatic
  
 #2
  
 // Field rand_state:I
  
 4: return
  
  
 iload_1
  takes the input value and pushes it into stack. But why not
  iload_0
 ?
  
 It’s because this function may use fields
  
 of the class, and so
  this
  is also passed to the function as a zeroth argument. The field
  rand_state
  occupies the 2nd slot in 
 the class, so
  putstatic
  copies the value from the
  TOS
  into the 2nd slot.
  
 Now
  my_rand()
 :",NA
54.8,NA,NA
Conditional jumps,"Now let’s proceed to conditional jumps.
  
 public class abs 
  
 { 
  
 public static int abs(int a) 
  
 { 
  
  
  
 if (a<0)
  
  
  
  
 return -a; 
  
  
  
 return a; 
  
 } 
  
 }
  
  
 public static int abs(int); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
  
 Code: 
  
   
 stack=1, locals=1, args_size=1 
  
    
 0: iload_0 
  
    
 1: ifge 
  
 7
  
 4: iload_0 
  
 5: ineg 
  
 6: ireturn 
  
 7: iload_0 
  
 8: ireturn
  
 ifge
  jumps to offset 7 if the value at
  TOS
  is greater or equal to 0. Don’t forget, any
  ifXX
  instruction pops the value (to be 
 compared) from the stack.
  
 ineg
  just negates value at
  TOS
 .
  
 Another example:
  
 public static int min (int a, int b) 
  
 { 
  
  
 if (a>b)
  
  
  
 return b; 
  
  
 return a; 
  
 }
  
 We get:
  
 public static int min(int, int); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC
  
 Code: 
  
 stack=2, locals=2, args_size=2
  
 596",NA
54.9 ,NA,NA
Passing arguments,"Let’s extend our
  min()
 /
 max()
  example:
  
 public class minmax 
  
 { 
  
 public static int min (int a, int b) 
  
 { 
  
  
  
 if (a>b) 
  
  
  
  
 return b; 
  
  
  
 return a; 
  
 }
  
 public static int max (int a, int b) 
  
 { 
  
  
 if (a>b) 
  
  
  
 return a;
  
  
 return b; 
  
 }
  
 public static void main(String[] args) 
  
 { 
  
  
  
 int a=123, b=456; 
  
  
  
 int max_value=max(a, b); 
  
  
  
 int min_value=min(a, b); 
  
  
  
 System.out.println(min_value); 
  
  
  
 System.out.println(max_value); 
  
 } 
  
 }
  
 Here is
  main()
  function code:
  
 public static void main(java.lang.String[]); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
  
 Code: 
  
   
 stack=2, locals=5, args_size=1
  
 0: bipush 
  
 123 
  
 2: istore_1 
  
 3: sipush 
  
 456 
  
 6: istore_2",NA
54.10 ,NA,NA
Bitfields,"All bit-wise operations work just like in any other
  ISA
 :
  
 public static int set (int a, int b) 
  
 { 
  
  
 return a | 1<<b; 
  
 }
  
 public static int clear (int a, int b) 
  
 { 
  
  
 return a & (~(1<<b)); 
  
 }
  
  
 public static int set(int, int); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
  
 Code: 
  
   
 stack=3, locals=2, args_size=2 
  
    
 0: iload_0 
  
    
 1: iconst_1 
  
    
 2: iload_1 
  
    
 3: ishl 
  
    
 4: ior 
  
    
 5: ireturn
  
 public static int clear(int, int);
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
 Code: 
  
 stack=3, locals=2, args_size=2 
  
   
 0: iload_0 
  
   
 1: iconst_1 
  
   
 2: iload_1 
  
   
 3: ishl 
  
   
 4: iconst_m1 
  
   
 5: ixor 
  
   
 6: iand 
  
   
 7: ireturn
  
   
 iconst_m1
  loads
  −1
  in the stack, it’s the same as the
  0xFFFFFFFF
  number. Let’s 
 extend all data types to 64-bit
  long
 :
  
 XORing with
  0xFFFFFFFF
  has the same
  
 public static long lset (long a, int b) 
  
 { 
  
  
 return a | 1<<b;
  
 }
  
 599",NA
54.11,NA,NA
Loops,"public class Loop 
  
 { 
  
 public static void main(String[] args) 
  
 { 
  
  
  
 for (int i = 1; i <= 10; i++)
  
  
  
 { 
  
  
  
  
 System.out.println(i); 
  
  
  
 } 
  
 } 
  
 }
  
  
 public static void main(java.lang.String[]); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
  
 Code: 
  
   
 stack=2, locals=2, args_size=1 
  
    
 0: iconst_1 
  
    
 1: istore_1 
  
    
 2: iload_1 
  
    
 3: bipush 
  
 10
  
 5: if_icmpgt
  
 21
  
 // Field java/lang/System.out:Ljava/io/
 ⤦
 // Method 
 java/io/PrintStream.println:(I)V
  
 8: getstatic
  
 #2
  
  PrintStream; 
  
 11: iload_1 
  
 12: invokevirtual #3
  
 15: iinc
  
 1, 1
  
 18: goto
  
 2
  
 21: return",NA
54.12 ,NA,NA
switch(),"The switch() statement is implemented with the
  tableswitch
  instruction:
  
 public static void f(int a) 
  
 { 
  
  
 switch (a) 
  
  
 { 
  
  
 case 0: System.out.println(""zero""); break; 
  
 case 1: 
 System.out.println(""one\n""); break;
  
  
 case 2: System.out.println(""two\n""); break; 
  
  
 case 3: System.out.println(""three\n""); break; 
  
  
 case 4: System.out.println(""four\n""); break; 
  
  
 default: System.out.println(""something unknown\n""); break; 
  
 }; 
  
 }
  
 As simple, as possible:
  
 public static void f(int); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
  
 Code: 
  
   
 stack=2, locals=1, args_size=1 
  
    
 0: iload_0 
  
    
 1: tableswitch 
  
  
 { // 0 to 4 
  
    
  
  
 0: 36 
  
    
  
  
 1: 47 
  
    
  
  
 2: 58 
  
    
  
  
 3: 69 
  
    
  
  
 4: 80 
  
    
  
 default: 91
  
 }
  
 // Field java/lang/System.out:Ljava/io/
 ⤦
 // String zero
  
 // Method java/io/PrintStream.println:(Ljava/lang
 ⤦
  
 // Field java/lang/System.out:Ljava/io/
  
 36: getstatic
  
 #2
  
  PrintStream;
  
 39: ldc
  
 #3
  
  
 41: invokevirtual #4 
 /String;)V
  
 44: goto
  
 99
  
 47: getstatic
  
 #2
  
  
  PrintStream;
  
 // String one\n
 ⤦
  
 // Method java/io/PrintStream.println:(Ljava/lang
 ⤦
  
 // Field java/lang/System.out:Ljava/io/
 ⤦
 // String two\n
  
 // Method java/io/PrintStream.println:(Ljava/lang
 ⤦
  
 // Field java/lang/System.out:Ljava/io/
 ⤦
 // String three\n
  
 // Method java/io/PrintStream.println:(Ljava/lang
 ⤦
  
 // Field java/lang/System.out:Ljava/io/
 ⤦
 // String four\n
  
 50: ldc
  
 #5
  
  
 52: invokevirtual #4 
 /String;)V
  
 55: goto
  
 99
  
 58: getstatic
  
 #2
  
  PrintStream;
  
 61: ldc
  
 #6
  
  
 63: invokevirtual #4 
 /String;)V
  
 66: goto
  
 99
  
 69: getstatic
  
 #2
  
  PrintStream;
  
 72: ldc
  
 #7
  
  
 74: invokevirtual #4 
 /String;)V
  
 77: goto
  
 99
  
 80: getstatic
  
 #2
  
  PrintStream;
  
 83: ldc
  
 #8",NA
54.13 ,54.13.1,NA
Arrays ,"Simple example
  
 Let’s first create an array of 10 integers and fill it:
  
 public static void main(String[] args) 
  
 { 
  
  
 int a[]=new int[10]; 
  
  
 for (int i=0; i<10; i++)
  
  
  
 a[i]=i; 
  
  
 dump (a); 
  
 }
  
  
 public static void main(java.lang.String[]); 
  
  
 flags: ACC_PUBLIC, ACC_STATIC 
  
  
 Code: 
  
   
 stack=3, locals=3, args_size=1 
  
    
 0: bipush 
  
 10 
  
    
 2: newarray 
  
  
 int 
  
    
 4: astore_1 
  
    
 5: iconst_0 
  
    
 6: istore_2 
  
    
 7: iload_2 
  
    
 8: bipush 
  
 10
  
 10: if_icmpge 
  
 23 
  
 13: aload_1 
  
 14: iload_2 
  
 15: iload_2 
  
 16: iastore 
  
 17: iinc 
  
 2, 1 
  
 20: goto 
  
 7 
  
 23: aload_1
  
 24: invokestatic
  
 #4
  
 // Method dump:([I)V
  
 27: return
  
  
 The
  newarray
  instruction creates an array object of 10
  int
  elements.
  
 The array’s size is set with
  bipush
  and left at
  TOS
 .
  
 The array’s type is set in
  newarray
  instruction’s operand. After
  newarray
 ’s execution, a
  reference
  (or pointer) to the newly
  
 created array in the heap is left at the
  TOS
 .
  
 astore_1
  stores the
  reference
  to the 1st slot in
  LVA
 .
  
 The second part of the
  
 main()
  function is the loop which stores
  i
  into the corresponding array element.
  
 aload_1
  gets a
  reference
  of the array
  
 and places it in the stack.
  iastore
  then stores the integer value from the stack in the array,
  reference
  of which is currently
  
 in
  TOS
 .
  
 The third part of the
  main()
  function calls the
  dump()
  function.
  
 An argument for it is prepared by
  aload_1
  
 (offset 23).
  
 Now let’s proceed to the
  dump()
  function:
  
 public static void dump(int a[]) 
  
 { 
  
  
 for (int i=0; i<a.length; i++)
  
  
 System.out.println(a[i]); 
  
 }
  
  
 public static void dump(int[]); 
  
 flags: ACC_PUBLIC, ACC_STATIC
  
 Code: 
  
 stack=3, locals=2, args_size=1
  
 603",NA
54.14 ,NA,NA
Strings,"54.14.1 
  
 First example
  
 Strings are objects and are constructed in the same way as other objects (and arrays).
  
 public static void main(String[] args) 
  
 { 
  
  
 System.out.println(""What is your name?"");
  
  
 String input = System.console().readLine(); 
  
 System.out.println(""Hello, ""+input); 
  
 }
  
 610",NA
54.15,NA,NA
Exceptions,"Let’s rework our
  Month
  example (
  54.13.4 on page 605
 ) a bit:
  
 Listing 54.10: IncorrectMonthException.java
  
 public class IncorrectMonthException extends Exception { 
  
 private int index;
  
 public IncorrectMonthException(int index)",NA
54.16,NA,NA
Classes,"Simple class:
  
 Listing 54.15: test.java
  
 public class test 
  
 { 
  
 public static int a; 
  
 private static int b;
  
 public test() 
  
 { 
  
  
 a=0; 
  
  
 b=0; 
  
 } 
  
 public static void set_a (int input) 
  
 public static void set_a (int input) 
  
 { 
  
  
 a=input; 
  
 } 
  
 public static int get_a () 
  
 { 
  
  
 return a; 
  
 } 
  
 public static void set_b (int input) 
  
 { 
  
  
 b=input;
  
 615",NA
54.17,NA,NA
Simple patching,"54.17.1
  
 First example
  
 Let’s proceed with a simple code patching task.
  
 public class nag 
  
 { 
  
 public static void nag_screen() 
  
 { 
  
  
  
 System.out.println(""This program is not registered""); };
  
 public static void main(String[] args) 
  
 { 
  
  
  
 System.out.println(""Greetings from the mega-software""); 
  
  
 nag_screen(); 
  
 } 
  
 }
  
 How would we remove the printing of “This program is not registered” string?
  
 Let’s load the .class file into IDA:
  
 617",NA
54.18 ,NA,NA
Summary,"What is missing in Java in comparison to C/C++?
  
 • Structures: use classes.
  
 • Unions: use class hierarchies.
  
 • Unsigned data types. By the way, this makes cryptographic algorithms somewhat harder to implement in 
 Java.• Function pointers.
  
 622",NA
Part V ,NA,NA
Finding important/interesting stuff in the code,623,NA
Chapter 55,NA,NA
Identification of executable files,NA,NA
55.1 ,NA,NA
Microsoft Visual C++ ,"MSVC versions and DLLs that can be imported:
  
 Marketing version
  
 Internal version
  
 CL.EXE version
  
 DLLs that can be imported
  
 Release date
  
 6
  
 6.0
  
 12.00
  
 msvcrt.dll, msvcp60.dll
  
 June 1998
  
 .NET (2002)
  
 7.0
  
 13.00
  
 msvcr70.dll, msvcp70.dll
  
 February 13, 2002
  
 .NET 2003
  
 7.1
  
 13.10
  
 msvcr71.dll, msvcp71.dll
  
 April 24, 2003
  
 2005
  
 8.0
  
 14.00
  
 msvcr80.dll, msvcp80.dll
  
 November 7, 2005
  
 2008
  
 9.0
  
 15.00
  
 msvcr90.dll, msvcp90.dll
  
 November 19, 2007
  
 2010
  
 10.0
  
 16.00
  
 msvcr100.dll, msvcp100.dll
  
 April 12, 2010
  
 2012
  
 11.0
  
 17.00
  
 msvcr110.dll, msvcp110.dll
  
 September 12, 2012
  
 2013
  
 12.0
  
 18.00
  
 msvcr120.dll, msvcp120.dll
  
 October 17, 2013
  
 msvcp*.dll contain C++-related functions, so if it is imported, this is probably a C++ program.
  
 55.1.1 
  
 Name mangling 
  
 The names usually start with the
  ?
  symbol.
  
 You can read more about MSVC’s
  name mangling
  here:
  51.1.1 on page 522
 .",NA
55.2 GCC ,"Aside from *NIX targets, GCC is also present in the win32 environment, in the form of Cygwin and MinGW.
  
 55.2.1 
  
 Name mangling 
  
 Names usually start with the
  _Z
  symbols.
  
 You can read more about GCC’s
  name mangling
  here:
  51.1.1 on page 522
 .
  
 55.2.2 
  
 Cygwin 
  
 cygwin1.dll is often imported.
  
 55.2.3 
  
 MinGW 
  
 msvcrt.dll may be imported.
  
 625",NA
55.3 ,NA,NA
Intel FORTRAN,"CHAPTER 55. IDENTIFICATION OF EXECUTABLE FILES
  
 libifcoremd.dll, libifportmd.dll and libiomp5md.dll (OpenMP support) may be 
 imported. libifcoremd.dll has a lot of functions prefixed with
  for_
 , which means 
 FORTRAN.",NA
55.4 ,NA,NA
"Watcom, OpenWatcom","55.4.1 
  
 Name mangling
  
 Names usually start with the
  W
  symbol.
  
 For example, that is how the method named “method” of the class “class” that does not have any arguments and returns
  
 void 
 is encoded:
  
 W?method$_class$n__v",NA
55.5,NA,NA
Borland,"Here is an example of Borland Delphi’s and C++Builder’s
  name mangling
 :
  
 @TApplication@IdleAction$qv 
  
 @TApplication@ProcessMDIAccels$qp6tagMSG 
  
 @TModule@$bctr$qpcpvt1 
  
 @TModule@$bdtr$qv 
  
 @TModule@ValidWindow$qp14TWindowsObject 
  
 @TrueColorTo8BitN$qpviiiiiit1iiiiii
  
 @TrueColorTo16BitN$qpviiiiiit1iiiiii 
  
 @DIB24BitTo8BitBitmap$qpviiiiiit1iiiii 
  
 @TrueBitmap@$bctr$qpcl 
  
 @TrueBitmap@$bctr$qpvl 
  
 @TrueBitmap@$bctr$qiilll
  
 The names always start with the
  @
  symbol, then we have the class name came, method name, and encoded the types of 
 the arguments of the method.
  
 These names can be in the .exe imports, .dll exports, debug data,etc.
  
 Borland Visual Component Libraries (VCL) are stored in .bpl files instead of .dll ones, for example, vcl50.dll, rtl60.dll. 
 Another DLL that might be imported: BORLNDMM.DLL.
  
 55.5.1 
  
 Delphi
  
 Almost all Delphi executables has the “Boolean” text string at the beginning of the code segment, along with other type 
 names.
  
 This is a very typical beginning of the
  CODE
  segment of a Delphi program, this block came right after the win32 PE file 
 header:
  
  
 00000400
  
 04 10 40 00 03 07 42 6f
  
 6f 6c 65 61 6e 01 00 00
  
 |..@...Boolean...|
  
 00000410
  
 00 00 01 00 00 00 00 10
  
 40 00 05 46 61 6c 73 65
  
 |........@..False|
  
 00000420
  
 04 54 72 75 65 8d 40 00
  
 2c 10 40 00 09 08 57 69
  
 |.True.@.,.@...Wi|
  
 00000430
  
 64 65 43 68 61 72 03 00
  
 00 00 00 ff ff 00 00 90
  
 |deChar..........|
  
 00000440
  
 44 10 40 00 02 04 43 68
  
 61 72 01 00 00 00 00 ff
  
 |D.@...Char......|
  
 00000450
  
 00 00 00 90 58 10 40 00
  
 01 08 53 6d 61 6c 6c 69
  
 |....X.@...Smalli|
  
 00000460
  
 6e 74 02 00 80 ff ff ff
  
 7f 00 00 90 70 10 40 00
  
 |nt..........p.@.|
  
  
 00000470
  
 01 07 49 6e 74 65 67 65
  
 72 04 00 00 00 80 ff ff
  
 |..Integer.......|
  
 00000480
  
 ff 7f 8b c0 88 10 40 00
  
 01 04 42 79 74 65 01 00
  
 |......@...Byte..|
  
 00000490
  
 00 00 00 ff 00 00 00 90
  
 9c 10 40 00 01 04 57 6f
  
 |..........@...Wo|
  
 000004a0
  
 72 64 03 00 00 00 00 ff
  
 ff 00 00 90 b0 10 40 00
  
 |rd............@.|
  
 000004b0
  
 01 08 43 61 72 64 69 6e
  
 61 6c 05 00 00 00 00 ff
  
 |..Cardinal......|
  
 000004c0
  
 ff ff ff 90 c8 10 40 00
  
 10 05 49 6e 74 36 34 00
  
 |......@...Int64.|
  
 000004d0
  
 00 00 00 00 00 00 80 ff
  
 ff ff ff ff ff ff 7f 90
  
 |................|
  
 000004e0
  
 e4 10 40 00 04 08 45 78
  
 74 65 6e 64 65 64 02 90
  
 |..@...Extended..|",NA
55.6 ,NA,NA
Other known DLLs,• vcomp*.dll—Microsoft’s implementation of OpenMP.,NA
Chapter 56,NA,NA
Communication with the outer world (win32),"Sometimes it’s enough to observe some function’s inputs and outputs in order to understand what it does. That way you 
 can save time.
  
 Files and registry access: for the very basic analysis, Process Monitor
 1
 utility from SysInternals can help.
  
 For the basic analysis of network accesses, Wireshark
 2
 can be useful.
  
 But then you will have to to look inside anyway.
  
 The first thing to look for is which functions from the
  OS
 ’s
  API
 3
 s and standard libraries are used.
  
 If the program is divided into a main executable file and a group of DLL files, sometimes the names of the functions in 
 these DLLs can help.
  
 If we are interested in exactly what can lead to a call to
  MessageBox()
  with specific text, we can try to find this text in the 
 data segment, find the references to it and find the points from which the control may be passed to the
  MessageBox() 
 call 
 we’re interested in.
  
 If we are talking about a video game and we’re interested in which events are more or less random in it, we may try to 
 find the 
 rand()
  function or its replacements (like the Mersenne twister algorithm) and find the places from which those 
 functions are called, and more importantly, how are the results used. One example:
  75
 .
  
 But if it is not a game, and
  rand()
  is still used, it is also interesting to know why. There are cases of unexpected
  rand() 
 usage in data compression algorithms (for encryption imitation):
  blog.yurichev.com
 .",NA
56.1 ,NA,NA
Often used functions in the Windows API,"These functions may be among the imported. It is worth to note that not every function might be used in the code that 
 was written by the programmer. A lot of functions might be called from library functions and
  CRT
  code.
  
 • Registry access (advapi32.dll): RegEnumKeyEx
 4 5
 , RegEnumValue
 6 5
 , RegGetValue
 7 5
 , RegOpenKeyEx
 8 5
 , RegQueryVal-
  
 ueEx
 9 5
 .
  
 • Access to text .ini-files (kernel32.dll): GetPrivateProfileString
 10 5
 .
  
 • Dialog boxes (user32.dll): MessageBox
 11 5
 , MessageBoxEx
 12 5
 , SetDlgItemText
 13 5
 , GetDlgItemText
 14 5
 .
  
 • Resources access (
  68.2.8 on page 676
 ) : (user32.dll): LoadMenu
 15 5
 .
  
 1
 http://go.yurichev.com/17301 
  
 2
 http://go.yurichev.com/17303 
  
 3
 Application programming interface 
  
 4
 MSDN 
  
 5
 May have the -A suffix for the ASCII version and -W for the Unicode version 
  
 6
 MSDN 
  
 7
 MSDN 
  
 8
 MSDN 
  
 9
 MSDN 
  
 10
 MSDN 
  
 11
 MSDN 
  
 12
 MSDN 
  
 13
 MSDN 
  
 14
 MSDN 
  
 15
 MSDN",NA
56.2 ,NA,NA
tracer: Intercepting all functions in specific module,"There are INT3 breakpoints in the
  tracer
 , that are triggered only once, however, they can be set for all functions in a 
 specific DLL.
  
 --one-time-INT3-bp:somedll.dll!.*
  
  
 Or, let’s set INT3 breakpoints on all functions with the
  xml
  prefix in their name:
  
 --one-time-INT3-bp:somedll.dll!xml.*
  
  
 On the other side of the coin, such breakpoints are triggered only once.
  
 Tracer will show the call of a function, if it happens, but only once. Another drawback—it is impossible to see the function’s 
 arguments.
  
 Nevertheless, this feature is very useful when you know that the program uses a DLL, but you do not know which functions 
 are actually used. And there are a lot of functions.
  
 For example, let’s see, what does the uptime utility from cygwin use:
  
 tracer -l:uptime.exe --one-time-INT3-bp:cygwin1.dll!.*
  
  
 Thus we may see all that cygwin1.dll library functions that were called at least once, and where from:
  
 One-time INT3 breakpoint: cygwin1.dll!__main (called from uptime.exe!OEP+0x6d (0x40106d)) One-time INT3 breakpoint: 
 cygwin1.dll!_geteuid32 (called from uptime.exe!OEP+0xba3 (0x401ba3)) One-time INT3 breakpoint: cygwin1.dll!_getuid32 (called 
 from uptime.exe!OEP+0xbaa (0x401baa)) One-time INT3 breakpoint: cygwin1.dll!_getegid32 (called from uptime.exe!OEP+0xcb7 
 (0x401cb7)) One-time INT3 breakpoint: cygwin1.dll!_getgid32 (called from uptime.exe!OEP+0xcbe (0x401cbe)) One-time INT3 
 breakpoint: cygwin1.dll!sysconf (called from uptime.exe!OEP+0x735 (0x401735)) One-time INT3 breakpoint: cygwin1.dll!setlocale 
 (called from uptime.exe!OEP+0x7b2 (0x4017b2)) One-time INT3 breakpoint: cygwin1.dll!_open64 (called from 
 uptime.exe!OEP+0x994 (0x401994)) One-time INT3 breakpoint: cygwin1.dll!_lseek64 (called from uptime.exe!OEP+0x7ea 
 (0x4017ea)) One-time INT3 breakpoint: cygwin1.dll!read (called from uptime.exe!OEP+0x809 (0x401809))
  
 One-time INT3 breakpoint: cygwin1.dll!sscanf (called from uptime.exe!OEP+0x839 (0x401839)) One-time INT3 breakpoint: 
 cygwin1.dll!uname (called from uptime.exe!OEP+0x139 (0x401139)) One-time INT3 breakpoint: cygwin1.dll!time (called from 
 uptime.exe!OEP+0x22e (0x40122e)) One-time INT3 breakpoint: cygwin1.dll!localtime (called from uptime.exe!OEP+0x236 
 (0x401236)) One-time INT3 breakpoint: cygwin1.dll!sprintf (called from uptime.exe!OEP+0x25a (0x40125a)) One-time INT3 
 breakpoint: cygwin1.dll!setutent (called from uptime.exe!OEP+0x3b1 (0x4013b1)) One-time INT3 breakpoint: 
 cygwin1.dll!getutent (called from uptime.exe!OEP+0x3c5 (0x4013c5)) One-time INT3 breakpoint: cygwin1.dll!endutent (called 
 from uptime.exe!OEP+0x3e6 (0x4013e6)) One-time INT3 breakpoint: cygwin1.dll!puts (called from uptime.exe!OEP+0x4c3 
 (0x4014c3))
  
 16
 MSDN 
  
 17
 MSDN 
  
 18
 MSDN 
  
 19
 MSDN 
  
 20
 MSDN 
  
 21
 MSDN 
  
 22
 MSDN 
  
 23
 MSDN 
  
 24
 MSDN",NA
Chapter 57,NA,NA
Strings,NA,NA
57.1 Text strings,"57.1.1 
  
 C/C++ 
  
 The normal C strings are zero-terminated (
 ASCIIZ
 -strings).
  
 The reason why the C string format is as it is (zero-terminated) is apparently historical. In [
 Rit79
 ] we read:
  
 A minor difference was that the unit of I/O was the word, not the byte, because the PDP-7 was a word-
 addressed machine. In practice this meant merely that all programs dealing with character streams ignored 
 null characters, because null was used to pad a file to an even number of characters.
  
 In Hiew or FAR Manager these strings looks like this:
  
 int main() 
  
 {
  
 printf (""Hello, world!\n""); 
  
 };
  
  
 Figure 57.1: Hiew
  
 57.1.2 
  
 Borland Delphi 
  
 The string in Pascal and Borland Delphi is preceded by an 8-bit or 32-bit string length.
  
 For example: 
  
 Listing 57.1: Delphi
  
 CODE:00518AC8 
  
 dd 19h
  
 CODE:00518ACC aLoading___Plea db 'Loading... , please wait.',0
  
 ...
  
 CODE:00518AFC 
  
 dd 10h
  
 CODE:00518B00 aPreparingRun__ db 'Preparing run...',0
  
 630",NA
57.2 Error/debug messages,"CHAPTER 57. STRINGS
  
 Debugging messages are very helpful if present. In some sense, the debugging messages are reporting what’s going on in 
 the program right now. Often these are
  printf()
 -like functions, which write to log-files, or sometimes do not writing 
 anything but the calls are still present since the build is not a debug one but
  release
  one. If local or global variables are 
 dumped in debug messages, it might be helpful as well since it is possible to get at least the variable names. For example, 
 one of such function in Oracle RDBMS is
  ksdwrt()
 .
  
 Meaningful text strings are often helpful. The
  IDA
  disassembler may show from which function and from which point this 
 specific string is used. Funny cases sometimes happen
 4
 .
  
 The error messages may help us as well. In Oracle RDBMS, errors are reported using a group of functions. 
 You can read more about them here:
  blog.yurichev.com
 .
  
 It is possible to find quickly which functions report errors and in which conditions. 
  
 By the way, this is often the reason for 
 copy-protection systems to inarticulate cryptic error messages or just error numbers. No one is happy when the software 
 cracker quickly understand why the copy-protection is triggered just by the error message.
  
 One example of encrypted error messages is here:
  78.2 on page 737
 .",NA
57.3 Suspicious magic strings,"Some magic strings which are usually used in backdoors looks pretty suspicious. 
  
 For example, there was a backdoor in the 
 TP-Link WR740 home router
 5
 . The backdoor was activated using the following URL: 
  
 http://192.168.0.1/userRpmNatDebugRpm26525557/start_art.html
 .
  
 Indeed, the “userRpmNatDebugRpm26525557” string is present in the firmware. This string was not googleable until the 
 wide disclosure of information about the backdoor. You would not find this in any
  RFC
 6
 . You would not find any computer 
 science algorithm which uses such strange byte sequences. And it doesn’t look like an error or debugging message. So it’s 
 a good idea to inspect the usage of such weird strings.
  
  
 Sometimes, such strings are encoded using base64. 
 ally, even a glance should be enough.
  
 So it’s a good idea to decode them all and to scan them visu-
  
 More precise, this method of hiding backdoors is called “security through obscurity”.
  
 4
 blog.yurichev.com
  
 5
 http://sekurak.pl/tp-link-httptftp-backdoor/
  
 6
 Request for Comments",NA
Chapter 58,NA,NA
Calls to assert(),"Sometimes the presence of the
  assert()
  macro is useful too: commonly this macro leaves source file name, line number and 
 condition in the code.
  
 The most useful information is contained in the assert’s condition, we can deduce variable names or structure field names 
 from it. Another useful piece of information are the file names—we can try to deduce what type of code is there. Also it is 
 possible to recognize well-known open-source libraries by the file names.
  
 Listing 58.1: Example of informative assert() calls
  
 .text:107D4B29 mov 
  
 dx, [ecx+42h] 
  
 .text:107D4B2D cmp 
  
 edx, 1 
  
 .text:107D4B30 jz 
  
 short loc_107D4B4A 
  
 .text:107D4B32 push 1ECh 
  
 .text:107D4B37 push offset aWrite_c ; ""write.c"" 
  
 .text:107D4B3C push offset aTdTd_planarcon ; ""td->td_planarconfig == PLANARCONFIG_CON""...
  
 .text:107D4B41 call ds:_assert
  
 ...
  
 .text:107D52CA mov 
  
 edx, [ebp-4] 
  
 .text:107D52CD and 
  
 edx, 3 
  
 .text:107D52D0 test edx, edx 
  
 .text:107D52D2 jz 
  
 .text:107D52D4 push 58h 
  
 short loc_107D52E9
  
 .text:107D52D6 push offset aDumpmode_c ; ""dumpmode.c"" 
 .text:107D52DB push offset aN30 
  
 ; ""(n & 3) == 0"" 
 .text:107D52E0 call ds:_assert
  
 ...
  
 .text:107D6759 mov 
  
 cx, [eax+6] 
  
 .text:107D675D cmp 
  
 ecx, 0Ch 
  
 .text:107D6760 jle 
  
 short loc_107D677A 
  
 .text:107D6762 push 2D8h 
  
 .text:107D6767 push offset aLzw_c 
  
  
 ; ""lzw.c"" .text:107D676C push offset aSpLzw_nbitsBit ; ""sp->lzw_nbits 
 <= BITS_MAX"" .text:107D6771 call ds:_assert
  
 It is advisable to “google” both the conditions and file names, which can lead us to an open-source library. For example, if 
 we“google” “sp->lzw_nbits <= BITS_MAX”, this predictably gives us some open-source code that’s related to the LZW 
 compression.",NA
Chapter 59,NA,NA
Constants,"Humans, including programmers, often use round numbers like 10, 100, 1000, in real life as well as in the code. The 
 practicing reverse engineer usually know them well in hexadecimal representation: 10=0xA, 100=0x64, 1000=0x3E8, 
 10000=0x2710.
  
 The constants
  0xAAAAAAAA
  (10101010101010101010101010101010) and 
  
 0x55555555
  (01010101010101010101010101010101) are also popular—those are composed of alternating bits. 
  
 That 
 may help to distinguish some signal from a signal where all bits are turned on (1111 …) or off (0000 …). For example, the 
 0x55AA
  constant is used at least in the boot sector,
  MBR
 1
 , and in the
  ROM
  of IBM-compatible extension cards.
  
 Some algorithms, especially cryptographical ones use distinct constants, which are easy to find in code using
  IDA
 .
  
 For example, the MD5
 2
 algorithm initializes its own internal variables like this: 
  
 var int h0 := 0x67452301 
  
 var int h1 := 0xEFCDAB89 
  
 var int h2 := 0x98BADCFE 
  
 var int h3 := 0x10325476 
  
 If you find these four constants used in the code in a row, it is highly probable that this function is related to MD5. Another 
 example are the CRC16/CRC32 algorithms, whose calculation algorithms often use precomputed tables like this one:
  
 Listing 59.1: linux/lib/crc16.c
  
 /** CRC table for the CRC-16. The poly is 0x8005 (x^16 + x^15 + x^2 + 1) */ u16 const 
 crc16_table[256] = { 
  
 0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
  
 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 
 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, ...
  
 See also the precomputed table for CRC32:
  37 on page 451
 .",NA
59.1 ,NA,NA
Magic numbers,"A lot of file formats define a standard file header where a
  magic number(s)
 3
 is used, single one or even several.
  
 For example, all Win32 and MS-DOS executables start with the two characters “MZ”
 4
 .
  
 At the beginning of a MIDI file the “MThd” signature must be present. If we have a program which uses MIDI files for 
 something, it’s very likely that it must check the file for validity by checking at least the first 4 bytes.
  
 This could be done like this: 
  
 (
 buf
  points to the beginning of the loaded file in memory)
  
 cmp [buf], 0x6468544D ; ""MThd"" 
  
 jnz _error_not_a_MIDI_file
  
  
 1
 Master Boot Record 
  
 2
 wikipedia 
  
 3
 wikipedia 
  
 4
 wikipedia",NA
59.2,NA,NA
Searching for constants,"It is easy in
  IDA
 : Alt-B or Alt-I. And for searching for a constant in a big pile of files, or for searching in non-executable files, 
 there is a small utility called
  binary grep
 6
 .
  
 6
 GitHub
  
 638",NA
Chapter 60,NA,NA
Finding the right instructions,"If the program is utilizing FPU instructions and there are very few of them in the code, one can try to check each one 
 manually with a debugger.
  
 For example, we may be interested how Microsoft Excel calculates the formulae entered by user. For example, the division 
 operation.
  
 If we load excel.exe (from Office 2010) version 14.0.4756.1000 into
  IDA
 , make a full listing and to find every
  FDIV
  
 instruction (except the ones which use constants as a second operand—obviously, they do not suit us):
  
 cat EXCEL.lst | grep fdiv | grep -v dbl_ > EXCEL.fdiv
  
  
 …then we see that there are 144 of them.
  
 We can enter a string like
  =(1/3)
  in Excel and check each instruction.
  
 By checking each instruction in a debugger or
  tracer
  (one may check 4 instruction at a time), we get lucky and the sought-
 for instruction is just the 14th:
  
 .text:3011E919 DC 33
  
 fdiv
  
 qword ptr [ebx]
  
  
   
 PID=13944|TID=28744|(0) 0x2f64e919 (Excel.exe!BASE+0x11e919) 
 EAX=0x02088006 EBX=0x02088018 ECX=0x00000001 EDX=0x00000001 
 ESI=0x02088000 EDI=0x00544804 EBP=0x0274FA3C ESP=0x0274F9F8 
 EIP=0x2F64E919
  
 FLAGS=PF IF 
  
 FPU ControlWord=IC RC=NEAR PC=64bits PM UM OM ZM DM IM FPU 
 StatusWord= 
  
 FPU ST(0): 1.000000
  
 ST(0)
  holds the first argument (1) and second one is in
  [EBX]
 .
  
 The instruction after
  FDIV
  (
 FSTP
 ) writes the result in memory:
  
 .text:3011E91B DD 1E
  
 fstp
  
 qword ptr [esi]
  
  
  
 If we set a breakpoint on it, we can see the result:
  
 PID=32852|TID=36488|(0) 0x2f40e91b (Excel.exe!BASE+0x11e91b) 
 EAX=0x00598006 EBX=0x00598018 ECX=0x00000001 EDX=0x00000001 
 ESI=0x00598000 EDI=0x00294804 EBP=0x026CF93C ESP=0x026CF8F8 
 EIP=0x2F40E91B
  
 FLAGS=PF IF 
  
 FPU ControlWord=IC RC=NEAR PC=64bits PM UM OM ZM DM IM FPU 
 StatusWord=C1 P 
  
 FPU ST(0): 0.333333
  
 Also as a practical joke, we can modify it on the fly:
  
 tracer -l:excel.exe bpx=excel.exe!BASE+0x11E91B,set(st0,666)",NA
Chapter 61,NA,NA
Suspicious code patterns,NA,NA
61.1 ,NA,NA
XOR instructions,"Instructions like
  XOR op, op
  (for example,
  XOR EAX, EAX
 ) are usually used for setting the register value to zero, but if the 
 operands are different, the “exclusive or” operation is executed. 
  
 This operation is rare in common programming, but 
 widespread in cryptography, including amateur one. It’s especially suspicious if the second operand is a big number. 
  
 This 
 may point to encrypting/decrypting, checksum computing,etc.
  
 One exception to this observation worth noting is the “canary” (
  18.3 on page 268
 ). Its generation and checking are of-ten 
 done using the
  XOR
  instruction.
  
 This AWK script can be used for processing
  IDA
  listing (.lst) files:
  
 gawk -e '$2==""xor"" { tmp=substr($3, 0, length($3)-1); if (tmp!=$4) if($4!=""esp"") if ($4!=""ebp"")
  
  
 It is also worth noting that this kind of script can also match incorrectly disassembled code (
  49 on page 513
 ).",NA
61.2 ,NA,NA
Hand-written assembly code,"Modern compilers do not emit the
  LOOP
  and
  RCL
  instructions. On the other hand, these instructions are well-known to 
 coders who like to code directly in assembly language. If you spot these, it can be said that there is a high probability that 
 this fragment of code was hand-written. Such instructions are marked as (M) in the instructions list in this appendix:
  A.6 
 on page 885
 .
  
 Also the function prologue/epilogue are not commonly present in hand-written assembly.
  
 Commonly there is no fixed system for passing arguments to functions in the hand-written code.
  
 Example from the Windows 2003 kernel (ntoskrnl.exe file):
  
 MultiplyTest proc near 
  
 ; CODE XREF: Get386Stepping 
  
 xor 
  
 cx, cx 
  
 loc_620555: 
  
  
  
 ; CODE XREF: MultiplyTest+E 
  
 push 
  
 cx 
  
  
 call 
  
 Multiply 
  
  
 pop 
  
 cx 
  
  
 jb 
  
 short locret_620563 
  
  
 loop 
  
 loc_620555 
  
  
 clc 
  
 locret_620563: 
   
 ; CODE XREF: MultiplyTest+C
  
 retn 
  
 MultiplyTest endp
  
 Multiply
  
 proc near
  
 ; CODE XREF: MultiplyTest+5
  
 mov
  
 ecx, 81h
  
 mov
  
 eax, 417A000h
  
 mul
  
 ecx
  
 cmp
  
 edx, 2
  
 stc 
  
 jnz short locret_62057F",NA
Chapter 62,NA,NA
Using magic numbers while tracing,"Often, our main goal is to understand how the program uses a value that was either read from file or received via network. 
 The manual tracing of a value is often a very labour-intensive task. One of the simplest techniques for this (although not 
 100% reliable) is to use your own
  magic number
 .
  
 This resembles X-ray computed tomography is some sense: a radiocontrast agent is injected into the patient’s blood, 
 which is then used to improve the visibility of the patient’s internal structure in to the X-rays. It is well known how the 
 blood of healthy humans percolates in the kidneys and if the agent is in the blood, it can be easily seen on tomography, 
 how blood is percolating, and are there any stones or tumors.
  
 We can take a 32-bit number like
  0x0badf00d
 , or someone’s birth date like
  0x11101979
  and write this 4-byte number to 
 some point in a file used by the program we investigate.
  
 Then, while tracing this program with
  tracer
  in
  code coverage
  mode, with the help of
  grep
  or just by searching in the text 
 file (of tracing results), we can easily see where the value was used and how.
  
 Example of
  grepable
  tracer
  results in
  cc
  mode:
  
 0x150bf66 (_kziaia+0x14), e= 
  
 1 [MOV EBX, [EBP+8]] [EBP+8]=0xf59c934
  
 0x150bf69 (_kziaia+0x17), e= 
  
 1 [MOV EDX, [69AEB08h]] [69AEB08h]=0
  
 0x150bf6f (_kziaia+0x1d), e= 
  
 1 [FS: MOV EAX, [2Ch]]
  
 0x150bf75 (_kziaia+0x23), e= 
  
 1 [MOV ECX, [EAX+EDX*4]] [EAX+EDX*4]=0xf1ac360
  
 0x150bf78 (_kziaia+0x26), e= 
  
 1 [MOV [EBP-4], ECX] ECX=0xf1ac360
  
 This can be used for network packets as well. It is important for the
  magic number
  to be unique and not to be present in the 
 program’s code.
  
 Aside of the
  tracer
 , DosBox (MS-DOS emulator) in heavydebug mode is able to write information about all registers’ states 
 for each executed instruction of the program to a plain text file
 1
 , so this technique may be useful for DOS programs as well.
  
 1
 See also my blog post about this DosBox feature:
  blog.yurichev.com",NA
Chapter 63,NA,NA
Other things,NA,NA
63.1 General idea ,"A reverse engineer should try to be in programmer’s shoes as often as possible. To take his/her viewpoint and ask himself, 
 how would one solve some task the specific case.",NA
63.2 ,NA,NA
C++ ,"RTTI
  (
  51.1.5 on page 536
 )-data may be also useful for C++ class identification.",NA
63.3 ,NA,NA
Some binary file patterns ,"Sometimes, we can clearly spot an array of 16/32/64-bit values visually, in hex editor. 
  
 Here is an example of very typical 
 MIPS code. 
  
 As we may remember, every MIPS (and also ARM in ARM mode or ARM64) instruction has size of 32 bits (or 4 
 bytes), so such code is array of 32-bit values. By looking at this screenshot, we may see some kind of pattern. Vertical red 
 lines are added for clarity:
  
 644",NA
63.4 ,NA,NA
Memory “snapshots” comparing,"The technique of the straightforward comparison of two memory snapshots in order to see changes was often used to hack 
 8-bit computer games and for hacking “high score” files.
  
 For example, if you had a loaded game on an 8-bit computer (there isn’t much memory on these, but the game usually 
 consumes even less memory) and you know that you have now, let’s say, 100 bullets, you can do a “snapshot” of all memory 
 and back it up to some place. Then shoot once, the bullet count goes to 99, do a second “snapshot” and then compare both: 
 the must be must be a byte somewhere which was 100 in the beginning, and now it is 99. Considering the fact that these 8-
 bit games were often written in assembly language and such variables were global, it can be said for sure which address in 
 memory was holding the bullet count. If you searched for all references to the address in the disassembled game code, it 
 was not very hard to find a piece of code
  decrementing
  the bullet count, then to write a
  NOP
  instruction there, or a couple 
 of
  NOP
 -s, and then have a game with 100 bullets forever. Games on these 8-bit computers were commonly loaded at the 
 constant address, also, there were not much different versions of each game (commonly just one version was popular for a 
 long span of time), so enthusiastic gamers knew which bytes must be overwritten (using the BASIC’s instruction
  POKE
 ) at 
 which address in order to hack it. This led to “cheat” lists that contained
  POKE
  instructions, published in magazines related 
 to 8-bit games. See also:
  wikipedia
 .
  
 Likewise, it is easy to modify “high score” files, this does not work with just 8-bit games. Notice your score count and back 
 up the file somewhere. When the “high score” count gets different, just compare the two files, it can even be done with 
 the DOS utility FC
 1
 (“high score” files are often in binary form). There will be a point where a couple of bytes are different 
 and it is easy to see which ones are holding the score number. However, game developers are fully aware of such tricks 
 and may defend the program against it.
  
 Somewhat similar example in this book is:
  85 on page 831
 .
  
 1
 MS-DOS utility for comparing binary files",NA
Part VI ,NA,NA
OS-specific,647,NA
Chapter 64,NA,NA
Arguments passing methods (calling conventions),NA,NA
64.1 ,NA,NA
cdecl,"This is the most popular method for passing arguments to functions in the C/C++ languages.
  
 The glscaller also must return the value of the
  stack pointer
  (
 ESP
 ) to its initial state after the
  callee
  function exits.
  
 Listing 64.1: cdecl
  
 push 
 arg3 
  
 push 
 arg2 
  
 push arg1
  
 call function 
  
 add esp, 12 ; returns ESP",NA
64.2,NA,NA
stdcall,"It’s almost the same as
  cdecl
 , with the exception that the
  callee
  must set
  ESP
  to the initial state by executing the
  RET x 
 instruction instead of
  RET
 , where
  x = arguments number * sizeof(int)
 1
 . The
  caller
  is not adjusting the
  stack pointer
 , there 
 are no
  add esp, x
  instruction.
  
 Listing 64.2: stdcall
  
 push 
 arg3 
  
 push 
 arg2 
  
 push 
 arg1 
  
 call function
  
 function: 
  
 ... do something ...
  
 ret 12
  
 The method is ubiquitous in win32 standard libraries, but not in win64 (see below about win64).
  
 For example, we can take the function from
  8.1 on page 88
  and change it slightly by adding the
  __stdcall
  modifier:
  
 int __stdcall f2 (int a, int b, int c) 
  
 {
  
 return a*b+c; 
  
 };
  
 It is to be compiled in almost the same way as
  8.2 on page 88
 , but you will see
  RET 12
  instead of
  RET
 .
  SP
  is not update in 
 the
  caller
 .
  
 As a consequence, the number of function arguments can be easily deduced from the
  RETN n
  instruction: just divide
  n
  by 4.
  
 Listing 64.3: MSVC 2010
  
  
 _a$ = 8
  
 ; size = 4
  
  
 1
 The size of an
  int
  type variable is 4 in x86 systems and 8 in x64 systems
  
 648",NA
64.3,NA,NA
fastcall,"That’s the general naming for the method of passing some arguments via registers and the rest via the stack. It worked 
 faster than
  cdecl
 /
 stdcall
  on older CPUs (because of smaller stack pressure). It may not help to gain any significant 
 performance on modern (much more complex) CPUs, however.
  
 It is not standardized, so the various compilers can do it differently. It’s a well known caveat: if you have two DLLs and the 
 one uses another one, and they are built by different compilers with different
  fastcall
  calling conventions, you can expect 
 problems.
  
 Both MSVC and GCC pass the first and second arguments via
  ECX
  and
  EDX
  and the rest of the arguments via the stack.
  
 The
  stack pointer
  must be restored to its initial state by the
  callee
  (like in
  stdcall
 ).
  
 Listing 64.4: fastcall
  
 push arg3 
  
 mov edx, arg2 
  
 mov ecx, arg1 
  
 call function
  
 function: 
  
 .. do something ..
  
 ret 4
  
 For example, we may take the function from
  8.1 on page 88
  and change it slightly by adding a
  __fastcall
  modifier:
  
 int __fastcall f3 (int a, int b, int c) 
  
 {
  
 return a*b+c; 
  
 };
  
 Here is how it is to be compiled:",NA
64.4 ,NA,NA
thiscall,"This is passing the object’s
  this
  pointer to the function-method, in C++.
  
 In MSVC,
  this
  is usually passed in the
  ECX
  register.
  
 In GCC, the
  this
  pointer is passed as the first function-method argument. Thus it will be very visible that internally: all 
 function-methods have an extra argument.
  
 For an example, see (
  51.1.1 on page 522
 ).",NA
64.5 ,NA,NA
x86-64,"64.5.1 
  
 Windows x64
  
 The method of for passing arguments in Win64 somewhat resembles
  fastcall
 . The first 4 arguments are passed via
  RCX
 , 
 RDX
 ,
  R8
  and
  R9
 , the rest—via the stack. The
  caller
  also must prepare space for 32 bytes or 4 64-bit values, so then the
  
 callee 
 can save there the first 4 arguments. Short functions may use the arguments’ values just from the registers, but 
 larger ones may save their values for further use.
  
 2
 http://go.yurichev.com/17040",NA
64.6 ,NA,NA
Return values of,NA,NA
 float,NA,NA
 and,NA,NA
 double,NA,NA
 type,"In all conventions except in Win64, the values of type
  float
  or
  double
  are returned via the FPU register
  ST(0)
 .
  
 In Win64, the values of
  float
  and
  double
  types are returned in the low 32 or 64 bits of the
  XMM0
  register.",NA
64.7 ,NA,NA
Modifying arguments,"Sometimes, C/C++ programmers (not limited to these
  PL
 s, though), may ask, what can happen if they modify the 
 arguments? The answer is simple: the arguments are stored in the stack, that is where the modification takes place. The 
 calling functions is not using them after the
  callee
 ’s exit (author of these lines have never seen any such case in his 
 practice).
  
 #include <stdio.h> 
  
 void f(int a, int b) 
  
 {
  
 a=a+b; 
  
 printf (""%d\n"", a); 
  
 };
  
 Listing 64.9: MSVC 2012
  
  
 _a$ = 8
  
 ; size = 4",NA
64.8 ,NA,NA
Taking a pointer to function argument,"… even more than that, it’s possible to take a pointer to the function’s argument and pass it to another function:
  
 #include <stdio.h>
  
 // located in some other file 
  
 void modify_a (int *a);
  
 void f (int a) 
  
 { 
  
 modify_a (&a); 
  
 printf (""%d\n"", a); 
  
 };
  
  
 It’s hard to understand how it works until we can see the code:
  
 Listing 64.10: Optimizing MSVC 2010
  
 $SG2796 DB 
  
 '%d', 0aH, 00H
  
 _a$ = 8
  
 _f
  
 PROC
  
 eax, DWORD PTR _a$[esp-4] ; just get the address of value in local stack
  
 lea
  
 push
  
 eax
  
 ; and pass it to modify_a()
  
 call
  
 _modify_a
  
  
 _f
  
 mov
  
 ecx, DWORD PTR _a$[esp]
  
 ; reload it from the local stack
  
 push
  
 ecx
  
 ; and pass it to printf()
  
 push
  
 OFFSET $SG2796 ; '%d'
  
 call
  
 _printf
  
 add
  
 esp, 12
  
 ret
  
 0
  
 ENDP
  
  
 The address of the place in the stack where
  a
  was passed is just passed to another function. It modifies the value addressed 
 by the pointer and then
  printf()
  prints the modified value.
  
 The observant reader might ask, what about calling conventions where the function’s arguments are passed in registers?
  
 That’s a situation where the
  Shadow Space
  is used. 
  
 The input value is copied from the register to the
  Shadow Space
  in the 
 local stack, and then this address is passed to the other function:
  
 Listing 64.11: Optimizing MSVC 2012 x64
  
 $SG2994 DB 
  
 '%d', 0aH, 00H
  
 a$ = 48 
  
 f PROC",NA
Chapter 65,NA,NA
Thread Local Storage,"TLS is a data area, specific to each thread. Every thread can store what it needs there. One well-known example is the C 
 standard global variable
  errno
 . 
  
 Multiple threads may simultaneously call functions which return an error code in
  errno
 , so 
 a global variable will not work correctly here for multi-threaded programs, so
  errno
  must be stored in the
  TLS
 .
  
  
 In the C++11 standard, a new
  thread_local
  modifier was added, showing that each thread has its own version of the 
 variable, it can be initialized, and it is located in the
  TLS
 1
 :
  
 Listing 65.1: C++11
  
 #include <iostream> 
  
 #include <thread>
  
 thread_local int tmp=3;
  
 int main() 
  
 { 
  
 std::cout << tmp << std::endl; 
  
 };
  
 Compiled in MinGW GCC 4.8.1, but not in MSVC 2012.
  
 If we talk about PE files, in the resulting executable file, the
  tmp
  variable is to be allocated in the section devoted to the 
 TLS
 .",NA
65.1 ,NA,NA
Linear congruential generator revisited,"The pseudorandom number generator we considered earlier
  20 on page 323
  has a flaw: it’s not thread-safe, because it has 
 an internal state variable which can be read and/or modified in different threads simultaneously.
  
 65.1.1 
  
 Win32
  
 Uninitialized
  TLS
  data
  
 One solution is to add
  __declspec( thread )
  modifier to the global variable, then it will be allocated in the
  TLS
  (line 9):
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1
  
  
 #include <stdint.h> 
  
 #include <windows.h> 
  
 #include <winnt.h>
  
 // from the Numerical Recipes book:
  
 #define RNG_a 1664525 
  
 #define RNG_c 1013904223 
  
 __declspec( thread ) uint32_t rand_state; 
  
 void my_srand (uint32_t init)
  
  
 1
  C11 also has thread support, optional though
  
 656",NA
Chapter 66,NA,NA
System calls (syscall-s),"As we know, all running processes inside an
  OS
  are divided into two categories: those having full access to the hardware 
 (“kernel space”) and those that do not (“user space”).
  
 The
  OS
  kernel and usually the drivers are in the first category.
  
 All applications are usually in the second category.
  
 For example, Linux kernel is in
  kernel space
 , but Glibc in
  user space
 .
  
 This separation is crucial for the safety of the
  OS
 : it is very important not to give to any process the possibility to screw up 
 something in other processes or even in the
  OS
  kernel. 
  
 On the other hand, a failing driver or error inside the
  OS
 ’s kernel 
 usually leads to a kernel panic or
  BSOD
 1
 .
  
 The protection in the x86 processors allows to separate everything into 4 levels of protection (rings), but both in Linux and 
 in Windows only two are used: ring0 (“kernel space”) and ring3 (“user space”).
  
 System calls (syscall-s) are a point where these two areas are connected. 
 to applications.
  
 As in
  Windows NT
 , the syscalls table resides in the
  SSDT
 2
 .
  
 It can be said that this is the main
  API
  provided
  
 The usage of syscalls is very popular among shellcode and computer viruses authors, because it is hard to determine the 
 addresses of needed functions in the system libraries, but it is easier to use syscalls. However, much more code has to be 
 written due to the lower level of abstraction of the
  API
 . It is also worth noting that the syscall numbers may be different 
 in various OS versions.",NA
66.1 ,NA,NA
Linux,"In Linux, a syscall is usually called via
  int 0x80
 . The call’s number is passed in the
  EAX
  register, and any other parameters 
 —in the other registers.
  
 Listing 66.1: A simple example of the usage of two syscalls
  
 section .text
  
 global 
  
 _start
  
 _start:
  
 mov 
  
 edx,len ; buffer len
  
 mov 
  
 ecx,msg ; buffer
  
 mov 
  
 ebx,1 
  
 ; file descriptor. 1 is for stdout
  
 mov 
  
 eax,4 
  
 ; syscall number. 4 is for sys_write
  
 int 
  
 0x80
  
  
 mov
  
 eax,1
  
 ; syscall number. 1 is for sys_exit
  
 int
  
 0x80
  
 section .data
  
 msg db 
  
 'Hello, world!',0xa
  
 len equ $ - msg
  
 1
 Blue Screen of Death 
  
 2
 System Service Dispatch Table",NA
66.2 ,NA,NA
Windows,"Here they are called via
  int 0x2e
  or using the special x86 instruction
  SYSENTER
 . The 
 full list of syscalls in Windows:
  http://go.yurichev.com/17320
 .
  
 Further reading:
  
 “Windows Syscall Shellcode” by Piotr Bania: 
  
 http://go.yurichev.com/17321
 .
  
 662",NA
Chapter 67,NA,NA
Linux,NA,NA
67.1 Position-independent code,"While analyzing Linux shared (.so) libraries, one may frequently spot this code pattern:
  
 Listing 67.1: libc-2.17.so x86
  
 .text:0012D5E3 __x86_get_pc_thunk_bx proc near 
  
 ; CODE XREF: sub_17350+3 
 .text:0012D5E3 
  
 ; sub_173CC+4 ...
  
 .text:0012D5E3 
  
 mov 
  
 ebx, [esp+0] 
  
 retn .text:0012D5E6 
  
 .text:0012D5E6 __x86_get_pc_thunk_bx endp
  
 ...
  
 .text:000576C0 sub_576C0
  
 proc near
  
 ; CODE XREF: tmpfile+73
  
 ...
  
 .text:000576C0
  
 push
  
 ebp
  
 .text:000576C1
  
 mov
  
 ecx, large gs:0
  
 .text:000576C8
  
 push
  
 edi
  
 .text:000576C9
  
 push
  
 esi
  
 .text:000576CA
  
 push
  
 ebx
  
  
 .text:000576CB
  
 call
  
 __x86_get_pc_thunk_bx
  
 .text:000576D0
  
 add
  
 ebx, 157930h
  
 .text:000576D6
  
 sub
  
 esp, 9Ch
  
 ...
  
 .text:000579F0
  
 lea
  
 eax, (a__gen_tempname - 1AF000h)[ebx] ; ""__gen_tempname""
  
 .text:000579F6
  
 mov
  
 [esp+0ACh+var_A0], 
 eax 
  
 eax, (a__SysdepsPosix - 1AF000h)[ebx] ; ""../sysdeps/
 ⤦
 [esp+0ACh+var_A8], 
 eax 
  
 eax, (aInvalidKindIn_ - 1AF000h)[ebx] ; ""! \""invalid
  ⤦
 [esp+0ACh+var_A4], 
 14Ah
  
 .text:000579FA
  
 lea
  
  posix/tempname.c""
  
 mov
  
 .text:00057A00
  
 .text:00057A04
  
 lea
  
  KIND in __gen_tempname\""""
  
 mov
  
 .text:00057A0A
  
 .text:00057A12
  
 mov
  
 [esp+0ACh+var_AC], eax
  
 .text:00057A15
  
 call
  
 __assert_fail
  
  
  
 All pointers to strings are corrected by some constants and the value in
  EBX
 , which is calculated at the beginning of each
  
 function.
  
 This is the so-called
  PIC
 , it is intended to be executable if placed at any random point of memory, that is why it
  
 cannot contain any absolute memory addresses.
  
 PIC
  was crucial in early computer systems and is crucial now in embedded systems without virtual memory support 
 (where all processes are placed in a single continuous memory block). It is also still used in *NIX systems for shared 
 libraries, since they are shared across many processes while loaded in memory only once. But all these processes can map 
 the same shared library at different addresses, so that is why a shared library has to work correctly without using any 
 absolute addresses.
  
 Let’s do a simple experiment:
  
  
 #include <stdio.h>",NA
67.2 ,NA,NA
LD_PRELOAD,NA,NA
 hack in Linux,"This allows us to load our own dynamic libraries before others, even before system ones, like libc.so.6.
  
 This, in turn, allows us to “substitute” our written functions before the original ones in the system libraries. For example, it 
 is easy to intercept all calls to time(), read(), write(), etc.
  
 Let’s see if we can fool the
  uptime
  utility. As we know, it tells how long the computer has been working. With the help of 
 strace(
  71 on page 704
 ), it is possible to see that the utility takes this information the
  /proc/uptime
  file:
  
 $ strace uptime 
  
 ...
  
 open(""/proc/uptime"", O_RDONLY) 
  
 = 3
  
 lseek(3, 0, SEEK_SET) 
  
 = 0 
  
 read(3, ""416166.86 414629.38\n"", 2047) 
  
 = 20 
  
 ...
  
 It is not a real file on disk, it is a virtual one and its contents are generated on fly in the Linux kernel. There are just two 
 numbers:
  
 $ cat /proc/uptime
  
 416690.91 415152.03
  
 What we can learn from Wikipedia
 2
 :
  
  
 The first number is the total number of seconds the system has been up. The second number is how 
 much of that time the machine has spent idle, in seconds.
  
 1
 program counter in AMD64 
  
 2
 wikipedia",NA
Chapter 68,NA,NA
Windows NT,NA,NA
68.1 ,NA,NA
CRT (win32),"Does the program execution start right at the
  main()
  function? No, it does not. 
  
 If we would open any executable file in 
 IDA
  or HIEW, we can see
  OEP
  pointing to some another code block. This code is doing some maintenance and preparations 
 before passing control flow to our code. It is called startup-code or CRT code (C RunTime).
  
 The
  main()
  function takes an array of the arguments passed on the command line, and also one with environment variables. 
 But in fact a generic string is passed to the program, the CRT code finds the spaces in it and cuts it in parts. The CRT code 
 also prepares the environment variables array
  envp
 . As for
  GUI
 1
 win32 applications,
  WinMain
  is used instead of
  main()
 , 
 having its own arguments:
  
 int CALLBACK WinMain( 
  
 _In_ 
  
 HINSTANCE hInstance, 
  
 _In_ 
  
 HINSTANCE hPrevInstance,
  
 _In_ 
  
 LPSTR lpCmdLine, 
  
 _In_ 
  
 int nCmdShow 
  
 );
  
 The CRT code prepares them as well.
  
 Also, the number returned by the
  main()
  function is the exit code. 
 function, which takes the exit code as an argument. 
  
 Usually, each compiler has its own CRT code.
  
 Here is a typical CRT code for MSVC 2008.
  
 It may be passed in CRT to the
  ExitProcess()
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
 1
 1 
 1
 2 
 1
 3 
 1
 4 
 1
 5 
 1
 6 
 1
 7 
 ___tmainCRTStartup proc near
  
 var_24 
 = 
 dword 
 ptr 
 -24h 
  
 var_20 
 = 
 dword 
 ptr 
 -20h 
  
 var_1C 
 = 
 dword 
 ptr 
 -1Ch 
  
 ms_exc = CPPEH_RECORD ptr -18h
  
 push 
  
 14h 
  
 push 
  
 offset stru_4092D0 
  
 call 
  
 __SEH_prolog4 
  
 mov 
  
 eax, 5A4Dh
  
 cmp 
  
 ds:400000h, ax 
  
 jnz 
  
 short loc_401096 
  
 mov 
  
 eax, ds:40003Ch 
  
 cmp 
  
 dword ptr [eax+400000h], 4550h 
  
 jnz 
  
 short loc_401096 
  
 mov 
  
 ecx, 10Bh 
  
 cmp 
  
 [eax+400018h], cx 
  
 jnz 
  
 short loc_401096 
  
 cmp 
  
 dword ptr [eax+400074h], 0Eh 
  
 jbe 
  
 short loc_401096 
  
 xor 
  
 ecx, ecx
  
  
  
 1
 Graphical user interface",NA
68.2 ,NA,NA
Win32 PE,"PE
  is an executable file format used in Windows.
  
 The difference between .exe, .dll and .sys is that .exe and .sys usually do not have exports, only imports.
  
 A
  DLL
 3
 , just like any other PE-file, has an entry point (
 OEP
 ) (the function DllMain() is located there) but this function usually 
 does nothing.
  
 .sys is usually a device driver.
  
 As of drivers, Windows requires the checksum to be present in the PE file and for it to be correct
 4
 .
  
 Starting at Windows Vista, a driver’s files must also be signed with a digital signature. It will fail to load otherwise.
  
 Every PE file begins with tiny DOS program that prints a message like “This program cannot be run in DOS mode.”— if you 
 run this program in DOS or Windows 3.1 (
 OS
 -es which are not aware of the PE format), this message will be printed.
  
 68.2.1 
  
 Terminology
  
 • Module—a separate file, .exe or .dll.
  
 • Process—a program loaded into memory and currently running. Commonly consists of one .exe file and bunch of .dll 
  
 files.
  
 • Process memory—the memory a process works with. Each process has its own. 
  
 memory of the stack,
  heap
 (s),etc.
  
 There usually are loaded modules,
  
 •
  VA
 5
 — an address which is to be used in program while runtime.
  
 • Base address (of module)— the address within the process memory at which the module is to be loaded.
  OS
  loader 
  
 may change it, if the base address is already occupied by another module just loaded before.
  
 •
  RVA
 6
 —the
  VA
 -address minus the base address. Many addresses in PE-file tables use
  RVA
 -addresses.
  
 2
 Portable Executable:
  68.2 
  
 3
 Dynamic-link library 
  
 4
 For example, Hiew(
  73 on page 706
 ) can calculate it 
  
 5
 Virtual Address 
  
 6
 Relative Virtual Address",NA
68.3 ,NA,NA
Windows SEH,"68.3.1 
  
 Let’s forget about MSVC
  
 In Windows, the
  SEH
  is intended for exceptions handling, nevertheless, it is language-agnostic, not related to C++ or
  OOP
  
 in any way. Here we are going to take a look at
  SEH
  in its isolated (from C++ and MSVC extensions) form.
  
 Each running process has a chain of
  SEH
  handlers,
  TIB
  has the address of the last handler. 
  
 When an exception occurs 
 (division by zero, incorrect address access, user exception triggered by calling the
  RaiseException()
  function), the
  OS 
 finds 
 the last handler in the
  TIB
  and calls it, passing all information about the
  CPU
  state (register values, etc) at the moment of 
 the exception. 
  
 The exception handler considering the exception, was it made for it? If so, it handles the exception. 
  
 If 
 not, it signals to the
  OS
  that it cannot handle it and the
  OS
  calls the next handler in the chain, until a handler which is 
 able to handle the exception is be found.
  
 At the very end of the chain there a standard handler that shows the well-known dialog box, informing the user about a 
 process crash, some technical information about the
  CPU
  state at the time of the crash, and offering to collect all 
 information and send it to developers in Microsoft.
  
 25
 http://go.yurichev.com/17052 
  
 26
 http://go.yurichev.com/17052 
  
 27
 http://go.yurichev.com/17049 
  
 28
 yurichev.com 
  
 29
 yurichev.com 
  
 30
 http://go.yurichev.com/17056",NA
68.4 ,NA,NA
Windows NT: Critical section,"Critical sections in any
  OS
  are very important in multithreaded environment, mostly for giving a guarantee that only one 
 thread can access some data in a single moment of time, while blocking other threads and interrupts.
  
 That is how a
  CRITICAL_SECTION
  structure is declared in
  Windows NT
  line OS:
  
 Listing 68.14: (Windows Research Kernel v1.2) public/sdk/inc/nturtl.h
  
 typedef struct _RTL_CRITICAL_SECTION { 
  
  
 PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
  
 // 
  
 // 
  
 The following three fields control entering and exiting the critical // 
  
 section for the 
 resource 
  
 //
  
  
 LONG LockCount; 
  
  
 LONG RecursionCount; 
  
  
 HANDLE OwningThread; 
  
 // from the thread's ClientId->UniqueThread 
  
 HANDLE 
 LockSemaphore; 
  
  
 ULONG_PTR SpinCount; 
  
 // force size on 64-bit systems when packed } 
 RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
  
 That’s is how EnterCriticalSection() function works:
  
 Listing 68.15: Windows 2008/ntdll.dll/x86 (begin)
  
 _RtlEnterCriticalSection@4
  
 var_C 
  
 = dword ptr -0Ch
  
 var_8 
  
 = dword ptr -8
  
 var_4 
  
 = dword ptr -4
  
 arg_0 
  
 = dword ptr 
  
 8
  
 mov 
  
 edi, edi
  
 push 
  
 ebp
  
 mov 
  
 ebp, esp
  
 sub 
  
 esp, 0Ch
  
 push 
  
 esi
  
 push 
  
 edi
  
 mov 
  
 edi, [ebp+arg_0]
  
 lea 
  
 esi, [edi+4] ; LockCount
  
 mov 
  
 eax, esi
  
 lock btr dword ptr [eax], 0 
  
 jnb 
  
 wait ; jump if CF=0
  
 loc_7DE922DD: 
  
  
 mov 
  
 eax, large fs:18h 
  
  
 mov 
  
 ecx, [eax+24h] 
  
  
 mov 
  
 [edi+0Ch], ecx 
  
  
 mov 
  
  
 dword ptr [edi+8], 1 
  
 pop 
  
 edi 
  
  
 xor 
  
 eax, eax 
  
  
 pop 
  
 esi 
  
  
 mov 
  
  
 esp, ebp 
  
 pop 
  
 ebp 
  
  
 retn 
  
 4
  
 ... skipped
  
 The most important instruction in this code fragment is
  BTR
  (prefixed with
  LOCK
 ): the zeroth bit is stored in the CF flag 
 and cleared in memory. This is an
  atomic operation
 , blocking all other CPUs’ access to this piece of memory (see the
  LOCK
  
 prefix before the
  BTR
  instruction). If the bit at
  LockCount
  is 1, fine, reset it and return from the function: we are in a 
 critical",NA
Part VII ,NA,NA
Tools,701,NA
Chapter 69,NA,NA
Disassembler,NA,NA
69.1 ,NA,NA
IDA,"An older freeware version is available for download
 1
 .
  
 Hot-keys cheatsheet:
  F.1 on page 904
  
 1
 hex-rays.com/products/ida/support/download_freeware.shtml
  
 702",NA
Chapter 70,NA,NA
Debugger,NA,NA
70.1 ,NA,NA
OllyDbg,"Very popular user-mode win32 debugger: 
  
 ollydbg.de
 .
  
 Hot-keys cheatsheet:
  F.2 on page 904",NA
70.2 ,NA,NA
GDB,"Not very popular debugger among reverse engineers, but very comfortable nevertheless. 
 Some commands:
  F.5 on page 905
 .",NA
70.3 ,NA,NA
tracer,"The author often uses
  tracer
 1
 instead of a debugger.
  
 The author of these lines stopped using a debugger eventually, since all he needs from it is to spot function arguments 
 while executing, or registers state at some point. Loading a debugger each time is too much, so a small utility called
  
 tracer
  was born. It works from command line, allows intercepting function execution, setting breakpoints at arbitrary 
 places, reading and changing registers state, etc.
  
 However, for learning purposes it is highly advisable to trace code in a debugger manually, watch how the registers state 
 changes (e.g. classic SoftICE, OllyDbg, WinDbg highlight changed registers), flags, data, change them manually, watch the 
 reaction, etc.
  
 1
 yurichev.com",NA
Chapter 71,NA,NA
System calls tracing,"71.0.1 
  
 strace / dtruss
  
 It shows which system calls (syscalls(
  66 on page 661
 )) are called by a process right now.
  
 For example:Por ejemplo:
  
 # strace df -h 
  
 ...
  
 access(""/etc/ld.so.nohwcap"", F_OK) 
  
 = -1 ENOENT (No such file or directory)
  
 open(""/lib/i386-linux-gnu/libc.so.6"", O_RDONLY|O_CLOEXEC) = 3 
  
 read(3, ""\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220\232\1\0004\0\0\0""..., 512) = 512 fstat64(3, 
 {st_mode=S_IFREG|0755, st_size=1770984, ...}) = 0 
  
 mmap2(NULL, 1780508, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb75b3000
  
 Mac OS X has dtruss for doing the same.
  
 Cygwin also has strace, but as far as it’s known, it works only for .exe-files compiled for the cygwin environment itself.
  
 704",NA
Chapter 72,NA,NA
Decompilers,"There is only one known, publicly available, high-quality decompiler to C code: Hex-Rays:
  
 hex-rays.com/products/decompiler/
  
 705",NA
Chapter 73,NA,NA
Other tools,"• Microsoft Visual Studio Express
 1
 : Stripped-down free version of Visual Studio, convenient for simple experiments.
  
 Some useful options:
  F.3 on page 905
 .
  
 • Hiew
 2
 : for small modifications of code in binary files.
  
 • binary grep: a small utility for searching any byte sequence in a big pile of files, including non-executable ones:
  
 GitHub
 .
  
 1
 visualstudio.com/en-US/products/visual-studio-express-vs
  
 2
 hiew.ru",NA
Part VIII ,NA,NA
Examples of real-world,NA,NA
 RE,NA,NA
 tasks,707,NA
Chapter 74,NA,NA
Task manager practical joke (Windows Vista),"Let’s see if it’s possible to hack Task Manager slightly so it would detect more
  CPU
  cores.
  
 Let us first think, how does the Task Manager know the number of cores? There is the
  GetSystemInfo()
  win32 function 
 present in win32 userspace which can tell us this. But it’s not imported in
  taskmgr.exe
 . There is, however, another one in
  
 NTAPI
 ,
  NtQuerySystemInformation()
 , which is used in
  taskmgr.exe
  in several places. 
  
 To get the number of 
 cores, one has to call this function with the
  SystemBasicInformation
  constant as a first argument (which is zero
 1
 ).
  
 The second argument has to point to the buffer which is getting all the information.
  
 So we need to find all calls to the
  NtQuerySystemInformation(0, ?, ?, ?)
  function. Let’s open
  taskmgr.exe 
 in IDA. What is 
 always good about Microsoft executables is that IDA can download the corresponding
  PDB
  file for this executable and 
 show all function names. 
  
 It is visible that Task Manager is written in C++ and some of the function names 
 and classes are really speaking for themselves. There are classes CAdapter, CNetPage, CPerfPage, CProcInfo, CProcPage, 
 CSvcPage, CTaskPage, CUserPage. Apparently, each class corresponds to each tab in Task Manager.
  
 Let’s visit each call and add comment with the value which is passed as the first function argument. We will write “not 
 zero”at some places, because the value there was clearly not zero, but something really different (more about this in the 
 second part of this chapter). And we are looking for zero passed as argument, after all.
  
  
 Figure 74.1: IDA: cross references to NtQuerySystemInformation()
  
 Yes, the names are really speaking for themselves.
  
 When we closely investigate each place where
  NtQuerySystemInformation(0, ?, ?, ?)
  is called, we quickly find what we 
 need in the
  InitPerfInfo()
  function:
  
 Listing 74.1: taskmgr.exe (Windows Vista)
  
 .text:10000B4B3
  
 xor
  
 r9d, r9d
  
 .text:10000B4B6
  
 lea
  
 rdx, [rsp+0C78h+var_C58] ; buffer
  
 .text:10000B4BB
  
 xor
  
 ecx, ecx
  
  
 .text:10000B4BD
  
 lea
  
 ebp, [r9+40h]
  
 .text:10000B4C1
  
 mov
  
 r8d, ebp
  
 .text:10000B4C4
  
 call
  
 cs:__imp_NtQuerySystemInformation ; 0
  
  
 1
 MSDN",NA
74.1 ,NA,NA
Using LEA to load values,"Sometimes,
  LEA
  is used in
  taskmgr.exe
  instead of
  MOV
  to set the first argument of
  NtQuerySystemInformation()
 : Listing 
 74.2: taskmgr.exe (Windows Vista)
  
 xor 
  
 r9d, r9d
  
 div 
  
 dword ptr [rsp+4C8h+WndClass.lpfnWndProc]
  
 lea 
  
 rdx, [rsp+4C8h+VersionInformation]
  
 lea 
  
 ecx, [r9+2] 
  
 ; put 2 to ECX
  
 mov 
  
 r8d, 138h
  
 mov 
  
 ebx, eax
  
 ; ECX=SystemPerformanceInformation
  
 call 
  
 cs:__imp_NtQuerySystemInformation ; 2
  
 711",NA
Chapter 75,NA,NA
Color Lines game practical joke,"This is a very popular game with several implementations in existence. We can take one of them, called BallTriX, from 
 1997,
  
 available freely at
  http://go.yurichev.com/17311
 1
 . Here is how it looks:
  
  
 Figure 75.1: How this game looks usually
  
 1
 Or at
  http://go.yurichev.com/17365
  or
  http://go.yurichev.com/17366
 .",NA
Chapter 76,NA,NA
Minesweeper (Windows XP),"For those who is not very good at playing Minesweeper, we could try to reveal the hidden mines in the debugger. As we 
 know, Minesweeper places mines randomly, so there has to be some kind of random number generator or a call to the 
 standard
  rand()
  C-function. 
  
 What is really cool about reversing Microsoft products is that there are
  PDB
  file with 
 symbols (function names, etc). When we load
  winmine.exe
  into
  IDA
 , it downloads the
  PDB
  file exactly for this executable 
 and shows all names.
  
 So here it is, the only call to
  rand()
  is this function:
  
 .text:01003940 ; __stdcall Rnd(x)
  
 .text:01003940 _Rnd@4
  
 proc near
  
 ; CODE XREF: StartGame()+53
  
 .text:01003940
  
 ; StartGame()+61
  
 .text:01003940
  
 .text:01003940 arg_0
  
 = dword ptr
  
 4
  
 .text:01003940
  
 .text:01003940
  
 call
  
 ds:__imp__rand
  
 .text:01003946
  
 cdq
  
 [esp+arg_0]
  
 .text:01003947
  
 idiv
  
 .text:0100394B
  
 mov
  
 eax, edx
  
 .text:0100394D
  
 retn
  
 4
  
 .text:0100394D _Rnd@4
  
 endp
  
  
 IDA
  named it so, and it was the name given to it by Minesweeper’s 
 developers. The function is very simple:
  
 int Rnd(int limit) 
  
 {
  
  
 return rand() % limit; 
  
 };
  
 (There was no “limit” name in the
  PDB
  file; we manually named this argument like this.) 
 So it returns a random value from 0 to a specified limit.
  
 Rnd()
  is called only from one place, a function called
  StartGame()
 , and as it seems, this is exactly the code which place the 
 mines:
  
 .text:010036C7
  
 push
  
 _xBoxMac
  
 ; Rnd(x)
  
 .text:010036CD
  
 call
  
 _Rnd@4
  
 .text:010036D2
  
 push
  
 _yBoxMac
  
 ; Rnd(x)
  
 .text:010036D8
  
 mov
  
 esi, eax
  
 .text:010036DA
  
 inc
  
 esi
  
 .text:010036DB
  
 call
  
 _Rnd@4
  
 .text:010036E0
  
 inc
  
 eax
  
 .text:010036E1
  
 mov
  
 ecx, eax
  
  
 .text:010036E3
  
 shl
  
 ecx, 5
  
 ; ECX=ECX*32
  
 .text:010036E6
  
 test
  
 _rgBlk[ecx+esi], 80h
  
 .text:010036EE
  
 jnz
  
 short loc_10036C7
  
 .text:010036F0
  
 shl
  
 eax, 5
  
 ; EAX=EAX*32
  
 .text:010036F3
  
 lea
  
 eax, _rgBlk[eax+esi]
  
 .text:010036FA
  
 or
  
 byte ptr [eax], 80h
  
 .text:010036FD
  
 dec
  
 _cBombStart
  
 .text:01003703
  
 jnz
  
 short loc_10036C7
  
  
 717",NA
76.1 ,NA,NA
Exercises,"• Why do the
  border bytes
  (0x10) exist in the array? What they are for if they are not visible in Minesweeper’s interface? 
  
 How could it work without them?
  
 • As it turns out, there are more values possible (for open blocks, for flagged by user, etc). Try to find the meaning of 
  
 each one.
  
 • Modify my utility so it can remove all mines or set them in a fixed pattern that you want in the Minesweeper process 
  
 currently running.
  
 • Modify my utility so it can work without the array address specified and without a
  PDB
  file. 
  
 board information in the data segment of Minesweeper’s running process automatically.
  
 Yes, it’s possible to find
  
 2
 Program/process ID 
  
 3
 PID it can be seen in Task Manager (enable it in “View
  →
  Select Columns”)",NA
Chapter 77,NA,NA
Hand decompiling + Z3 SMT solver,"Amateur cryptography is usually (unintentionally) very weak and can be broken easily—for cryptographers, of course. 
 But let’s pretend we are not among these crypto-professionals.
  
 Here is one-way hash function (read more about them:
  34 on page 437
 ), that converted a 64-bit value to another and we 
 need to try to reverse its flow back.",NA
77.1 Hand decompiling,"Here its assembly language listing in
  IDA
 :
  
 sub_401510 
  
 proc near 
  
  
 ; ECX = input 
  
  
 mov 
  
 rdx, 5D7E0D1F2E0F1F84h 
  
  
 mov 
  
 rax, rcx 
  
 ; input 
  
  
 imul 
  
 rax, rdx 
  
  
 mov 
  
 rdx, 388D76AEE8CB1500h 
  
  
 mov 
  
 ecx, eax 
  
  
 and 
  
 ecx, 0Fh 
  
  
 ror 
  
 rax, cl 
  
  
 xor 
  
 rax, rdx 
  
  
 mov 
  
 rdx, 0D2E9EE7E83C4285Bh 
  
  
 mov 
  
 ecx, eax 
  
  
 and 
  
 ecx, 0Fh 
  
  
 rol 
  
 rax, cl
  
  
 lea 
  
 r8, [rax+rdx] 
  
  
 mov 
  
 rdx, 8888888888888889h 
  
  
 mov 
  
 rax, r8 
  
  
 mul 
  
 rdx 
  
  
 shr 
  
 rdx, 5 
  
  
 mov 
  
 rax, rdx 
  
  
 lea 
  
 rcx, [r8+rdx*4] 
  
  
 shl 
  
 rax, 6 
  
  
 sub 
  
 rcx, rax 
  
  
 mov 
  
 rax, r8 
  
  
 rol 
  
 rax, cl 
  
  
 ; EAX = output 
  
  
 retn 
  
 sub_401510 
  
 endp
  
 The example was compiled by GCC, so the first argument is passed in
  ECX
 .
  
 If you don’t have Hex-Rays or if you distrust to it, you can try to reverse this code manually. One method is to represent the 
 CPU
  registers as local C variables and replace each instruction by a one-line equivalent expression, like:
  
 uint64_t f(uint64_t input) 
  
 { 
  
 uint64_t rax, rbx, rcx, rdx, r8;
  
 ecx=input; 
  
 rdx=0x5D7E0D1F2E0F1F84;
  
 722",NA
77.2 Now let’s use the Z3 SMT solver,"Still, without any special cryptographic knowledge, we may try to break this algorithm using the excellent SMT solver 
 from Microsoft Research named Z3
 1
 . It is in fact theorem prover, but we are going to use it as SMT solver. Simply said, we 
 can think about it as a system capable of solving huge equation systems.
  
 Here is the Python source code:
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 from z3 import * 
  
 C1=0x5D7E0D1F2E0F1F84 
  
 C2=0x388D76AEE8CB1500 
  
 C2=0x388D76AEE8CB1500 
  
 C3=0xD2E9EE7E83C4285B
  
 inp, i1, i2, i3, i4, i5, i6, outp = BitVecs('inp i1 i2 i3 i4 i5 i6 outp', 64)
  
  
  
 1
 http://go.yurichev.com/17314",NA
Chapter 78,NA,NA
Dongles,"Author of these lines, occasionally did software copy-protection
  dongle
  replacements, or “dongle emulators” and here are 
 couple examples of how it’s happening.
  
 About one of the cases that is not present here, you can read here: [
 Yur12
 ].",NA
78.1 ,NA,NA
Example #1: MacOS Classic and PowerPC,"Here is an example of a program for MacOS Classic
 1
 , for PowerPC. The company who developed the software product has 
 disappeared a long time ago, so the (legal) customer was afraid of physical dongle damage.
  
 While running without a dongle connected, a message box with the text ”Invalid Security Device” appeared. 
 text string could easily be found in the executable binary file.
  
 Luckily, this
  
 Let’s pretend we are not very familiar both with Mac OS Classic and PowerPC, but will try anyway.
  
 IDA
  opened the executable file smoothly, reported its type as ”PEF (Mac OS or Be OS executable)” ( indeed, it is a standard 
 Mac OS Classic file format).
  
 By searching for the text string with the error message, we’ve got into this code fragment:
  
 ...
  
 seg000:000C87FC 38 60 00 01
  
 li
  
 %r3, 1
  
 seg000:000C8800 48 03 93 41
  
 bl
  
 check1
  
 seg000:000C8804 60 00 00 00
  
 nop
  
  
 seg000:000C8808 54 60 06 3F 
  
 clrlwi. %r0, %r3, 24
  
 seg000:000C880C 40 82 00 40 
  
 bne 
  
 OK
  
 seg000:000C8810 80 62 9F D8 
  
 lwz 
  
 %r3, TC_aInvalidSecurityDevice
  
 ...
  
 Yes, this is PowerPC code. The CPU is a very typical 32-bit
  RISC
  of 1990s era. Each instruction occupies 4 bytes (just as in 
 MIPS and ARM) and the names somewhat resemble MIPS instruction names.
  
 check1()
  is a function name we’ll give to it later.
  BL
  is
  Branch Link
  instruction, e.g., intended for calling subroutines. The 
 crucial point is the
  BNE
  instruction which jumps if the dongle protection check passes or not if an error occurs: then the 
 address of the text string gets loaded into the r3 register for the subsequent passing into a message box routine.
  
 From the [
 SK95
 ] we will found out that the r3 register is used for return values (and r4, in case of 64-bit values).
  
 Another yet unknown instruction is
  CLRLWI
 . From [
 IBM00
 ] we’ll learn that this instruction does both clearing and loading. 
 In our case, it clears the 24 high bits from the value in r3 and puts them in r0, so it is analogical to
  MOVZX
  in x86 (
  15.1.1 
 on page 189
 ), but it also sets the flags, so
  BNE
  can check them afterwards.
  
 Let’s take a look into the
  check1()
  function:
  
 seg000:00101B40 
  
 check1: # CODE XREF: seg000:00063E7Cp 
 seg000:00101B40 
  
  
 # sub_64070+160p ...
  
 seg000:00101B40
  
 seg000:00101B40
  
 .set arg_8,
  
 8
  
 seg000:00101B40
  
 seg000:00101B40 7C 08 02 A6
  
 mflr
  
 %r0
  
  
 1
 pre-UNIX MacOS",NA
78.2 ,NA,NA
Example #2: SCO OpenServer,"An ancient software for SCO OpenServer from 1997 developed by a company that disappeared a long time ago.
  
 There is a special dongle driver to be installed in the system, that contains the following text strings: “Copyright 1989, 
 Rainbow Technologies, Inc., Irvine, CA” and “Sentinel Integrated Driver Ver. 3.0 ”.
  
 After the installation of the driver in SCO OpenServer, these device files appear in the /dev filesystem:
  
 /dev/rbsl8 
  
 /dev/rbsl9
  
 /dev/rbsl10
  
 The program reports an error without dongle connected, but the error string cannot be found in the 
 executables. Thanks to
  IDA
 , it is easy to load the COFF executable used in SCO OpenServer.
  
 Let’s also try to find “rbsl” string and indeed, found it in this code fragment:
  
 .text:00022AB8 
  
 public SSQC 
  
 .text:00022AB8 SSQC 
  
 proc near ; CODE XREF: SSQ+7p 
 .text:00022AB8 
  
 .text:00022AB8 var_44 = byte ptr -44h 
  
 .text:00022AB8 var_29 = byte ptr -29h
  
 .text:00022AB8 arg_0
  
 = dword ptr
  
 8
  
 .text:00022AB8
  
 .text:00022AB8
  
 push
  
 ebp
  
 .text:00022AB9
  
 mov
  
 ebp, esp
  
 .text:00022ABB
  
 sub
  
 esp, 44h
  
 .text:00022ABE
  
 push
  
 edi
  
 .text:00022ABF
  
 mov
  
 edi, offset unk_4035D0
  
 .text:00022AC4
  
 push
  
 esi
  
 .text:00022AC5
  
 mov
  
 esi, [ebp+arg_0]
  
 .text:00022AC8
  
 push
  
 ebx
  
 .text:00022AC9
  
 push
  
 esi
  
 .text:00022ACA
  
 call
  
 strlen
  
 .text:00022ACF
  
 add
  
 esp, 4
  
 .text:00022AD2
  
 cmp
  
 eax, 2
  
 .text:00022AD7
  
 jnz
  
 loc_22BA4
  
 .text:00022ADD
  
 inc
  
 esi
  
  
 .text:00022ADE
  
 mov
  
 al, [esi-1]
  
 .text:00022AE1
  
 movsx
  
 eax, al
  
 .text:00022AE4
  
 cmp
  
 eax, '3'
  
 .text:00022AE9
  
 jz
  
 loc_22B84
  
 .text:00022AEF
  
 cmp
  
 eax, '4'
  
 .text:00022AF4
  
 jz
  
 loc_22B94
  
 .text:00022AFA
  
 cmp
  
 eax, '5'
  
 .text:00022AFF
  
 jnz
  
 short loc_22B6B
  
 .text:00022B01
  
 movsx
  
 ebx, byte ptr [esi]
  
 .text:00022B04
  
 sub
  
 ebx, '0'
  
 .text:00022B07
  
 mov
  
 eax, 7
  
 .text:00022B0C
  
 add
  
 eax, ebx
  
 .text:00022B0E
  
 push
  
 eax
  
 .text:00022B0F
  
 lea
  
 eax, [ebp+var_44]
  
 .text:00022B12
  
 push
  
 offset aDevSlD
  
 ; ""/dev/sl%d""
  
 .text:00022B17
  
 push
  
 eax
  
 .text:00022B18
  
 call
  
 nl_sprintf
  
 .text:00022B1D
  
 push
  
 0
  
 ; int
  
 .text:00022B1F
  
 push
  
 offset aDevRbsl8 ; char *
  
 .text:00022B24
  
 call
  
 _access
  
 .text:00022B29
  
 add
  
 esp, 14h",NA
78.3 ,NA,NA
Example #3: MS-DOS,"Another very old software for MS-DOS from 1995 also developed by a company that disappeared a long time ago. In the 
 pre-DOS extenders era, all the software for MS-DOS mostly relied on 16-bit 8086 or 80286 CPUs, so en masse the code was 
 16-bit. The 16-bit code is mostly same as you already saw in this book, but all registers are 16-bit and there are less 
 instructions available.
  
 The MS-DOS environment has no system drivers, and any program can deal with the bare hardware via ports, so here you 
 can see the
  OUT
 /
 IN
  instructions, which are present in mostly in drivers in our times (it is impossible to access ports 
 directly in
  user mode
  on all modern
  OS
 es).
  
 Given that, the MS-DOS program which works with a dongle has to access the LPT printer port directly. 
 search for such instructions. And yes, here they are:
  
 So we can just
  
  
 seg030:0034 
  
 out_port proc far ; CODE XREF: sent_pro+22p seg030:0034 
  
  
 ; sent_pro+2Ap ...
  
 seg030:0034
  
 seg030:0034
  
 arg_0
  
 = byte ptr
  
 6
  
 seg030:0034
  
 seg030:0034 55
  
 push
  
 bp
  
 seg030:0035 8B EC
  
 mov
  
 bp, sp
  
  
  
 seg030:0037 8B 16 7E E7
  
 mov
  
 dx, _out_port ; 0x378
  
 seg030:003B 8A 46 06
  
 mov
  
 al, [bp+arg_0]
  
 seg030:003E EE
  
 out
  
 dx, al
  
 seg030:003F 5D
  
 pop
  
 bp
  
 seg030:0040 CB
  
 retf
  
 seg030:0040
  
 out_port endp
  
  
 (All label names in this example were given by 
 me). 
  
 out_port()
  is referenced only in one function:
  
 seg030:0041 
  
 sent_pro proc far ; CODE XREF: check_dongle+34p
  
 seg030:0041
  
 seg030:0041
  
 var_3
  
 = byte ptr -3
  
  
 seg030:0041
  
 var_2
  
 = word ptr -2
  
 seg030:0041
  
 arg_0
  
 = dword ptr
  
 6
  
 seg030:0041
  
 seg030:0041 C8 04 00 00
  
 enter
  
 4, 0",NA
Chapter 79,NA,NA
“QR9”: Rubik’s cube inspired amateur ,NA,NA
crypto-algorithm,"Sometimes amateur cryptosystems appear to be pretty bizarre.
  
 The author of this book was once asked to reverse engineer an amateur cryptoalgorithm of some data encryption utility, the 
 source code for which was lost
 1
 .
  
 Here is the listing exported from
  IDA
  for the original encryption utility:
  
  
 .text:00541000 set_bit
  
 proc near
  
 ; CODE XREF: rotate1+42
  
 .text:00541000
  
 ; rotate2+42 ...
  
 .text:00541000
  
 .text:00541000 arg_0
  
 = dword ptr
  
 4
  
 .text:00541000 arg_4
  
 = dword ptr
  
 8
  
 .text:00541000 arg_8
  
 = dword ptr
  
 0Ch
  
 .text:00541000 arg_C
  
 = byte ptr
  
 10h
  
 .text:00541000
  
 .text:00541000
  
 mov
  
 al, [esp+arg_C]
  
 .text:00541004
  
 mov
  
 ecx, [esp+arg_8]
  
 .text:00541008
  
 push
  
 esi
  
 .text:00541009
  
 mov
  
 esi, [esp+4+arg_0]
  
 .text:0054100D
  
 test
  
 al, al
  
 .text:0054100F
  
 mov
  
 eax, [esp+4+arg_4]
  
 .text:00541013
  
 mov
  
 dl, 1
  
 .text:00541015
  
 jz
  
 short loc_54102B
  
 .text:00541017
  
 shl
  
 dl, cl
  
 .text:00541019
  
 mov
  
 cl, cube64[eax+esi*8]
  
 .text:00541020
  
 or
  
 cl, dl
  
 .text:00541022
  
 mov
  
 cube64[eax+esi*8], cl
  
 .text:00541029
  
 pop
  
 esi
  
  
 .text:0054102A 
  
 retn 
  
 .text:0054102B
  
 .text:0054102B loc_54102B:
  
 shl
  
 ; CODE XREF: set_bit+15
  
 .text:0054102B
  
 dl, cl
  
 .text:0054102D
  
 mov
  
 cl, cube64[eax+esi*8]
  
 .text:00541034
  
 not
  
 dl
  
 .text:00541036
  
 and
  
 cl, dl
  
 .text:00541038
  
 mov
  
 cube64[eax+esi*8], cl
  
 .text:0054103F
  
 pop
  
 esi
  
 .text:00541040
  
 retn
  
 .text:00541040 set_bit
  
 endp
  
 .text:00541040 
  
 .text:00541041 
  
 align 10h 
  
 .text:00541050 
  
 .text:00541050 ; =============== S U B R O U T I N E ======================================= 
 .text:00541050 
  
 .text:00541050
  
 .text:00541050 get_bit
  
 proc near
  
 ; CODE XREF: rotate1+16
  
 .text:00541050
  
 ; rotate2+16 ...
  
 .text:00541050
  
 .text:00541050 arg_0
  
 = dword ptr
  
 4
  
  
 1
 He also got permission from the customer to publish the algorithm’s details
  
 752",NA
Chapter 80,NA,NA
SAP,NA,NA
80.1 ,NA,NA
About SAP client network traffic compression,"(Tracing the connection between the TDW_NOCOMPRESS SAPGUI
 1
 environment variable and the pesky annoying pop-up 
 window and the actual data compression routine.)
  
 It is known that the network traffic between SAPGUI and SAP is not encrypted by default, but compressed (see here
 2
 and 
 here
 3
 ).
  
 It is also known that by setting the environment variable
  TDW_NOCOMPRESS
  to 1, it is possible to turn the network packet 
 compression off.
  
 But you will see a annoying pop-up window that cannot be closed:
  
  
 Figure 80.1: Screenshot
  
 Let’s see if we can remove the window somehow.
  
 But before this, let’s see what we already know. First: we know that the environment variable
  TDW_NOCOMPRESS
  is 
 checked somewhere inside the SAPGUI client. Second: a string like “data compression switched off” must be present 
 somewhere in it. 
  
 With the help of the FAR file manager
 4
 we can found that both of these strings are stored in the 
 SAPguilib.dll file.
  
 So let’s open SAPguilib.dll in
  IDA
  and search for the
  “TDW_NOCOMPRESS ”
  string. Yes, it is present and there is only one 
 reference to it.
  
 We see the following fragment of code (all file offsets are valid for SAPGUI 720 win32, SAPguilib.dll file version 
 7200,1,0,9009):
  
 1
 SAP GUI client 
  
 2
 http://go.yurichev.com/17221",NA
80.2 ,NA,NA
SAP 6.0 password checking functions,"One time when the author of this book have returned again to his SAP 6.0 IDES installed in a VMware box, he figured out 
 that he forgot the password for the SAP* account, then he have remembered it, but then we got this error message
  
 «Password logon no longer possible - too many failed attempts»
 , since he’ve made all these attempts in trying to recall it.
  
 The first extremely good news was that the full
  disp+work.pdb
  PDB
  file is supplied with SAP, and it contain almost 
 everything: function names, structures, types, local variable and argument names, etc. What a lavish gift!
  
 8
 http://go.yurichev.com/17312",NA
Chapter 81,NA,NA
Oracle RDBMS,NA,NA
81.1 ,NA,NA
V$VERSION,NA,NA
 table in the Oracle RDBMS,"Oracle RDBMS 11.2 is a huge program, its main module
  oracle.exe
  contain approx. 124,000 functions. For comparison, the 
 Windows 7 x86 kernel (ntoskrnl.exe) contains approx. 11,000 functions and the Linux 3.9.8 kernel (with default drivers 
 compiled)—31,000 functions.
  
 Let’s start with an easy question. Where does Oracle RDBMS get all this information, when we execute this simple 
 statement in SQL*Plus:
  
 SQL> select * from V$VERSION;
  
  
 And we get:
  
 BANNER
  
 --------------------------------------------------------------------------------
  
 Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production
  
 PL/SQL Release 11.2.0.1.0 - Production
  
 CORE
  
 11.2.0.1.0
  
 Production
  
 TNS for 32-bit Windows: Version 11.2.0.1.0 - Production NLSRTL Version 
 11.2.0.1.0 - Production
  
 Let’s start. Where in the Oracle RDBMS can we find the string
  V$VERSION
 ?
  
 In the win32-version,
  oracle.exe
  file contains the string, it’s easy to see. But we can also use the object (.o) files from the 
 Linux version of Oracle RDBMS since, unlike the win32 version
  oracle.exe
 , the function names (and global variables as 
 well) are preserved there.
  
 So, the
  kqf.o
  file contains the
  V$VERSION
  string. The object file is in the main Oracle-library
  libserver11.a
 .
  
 A reference to this text string can find in the
  kqfviw
  table stored in the same file,
  kqf.o
 :
  
 Listing 81.1: kqf.o
  
 .rodata:0800C4A0 kqfviw 
  
 dd 0Bh 
  
 ; DATA XREF: kqfchk:loc_8003A6D 
 .rodata:0800C4A0 
  
  
 ; kqfgbn+34 
  
 .rodata:0800C4A4 
  
 dd offset _2__STRING_10102_0 ; ""GV$WAITSTAT"" 
  
 .rodata:0800C4A8 
  
  
 dd 4 .rodata:0800C4AC 
  
 dd offset _2__STRING_10103_0 ; ""NULL"" 
  
 .rodata:0800C4B0 
  
 dd 3 
  
 .rodata:0800C4B4 
  
 dd 0 
  
 .rodata:0800C4B8 
  
  
 dd 195h .rodata:0800C4BC 
  
 dd 4 
  
 .rodata:0800C4C0 
  
 dd 0
  
 .rodata:0800C4C4 
  
 dd 0FFFFC1CBh 
  
 .rodata:0800C4C8 
  
 dd 3 
  
 .rodata:0800C4CC 
  
 dd 0 
  
 .rodata:0800C4D0 
  
 dd 0Ah 
  
 .rodata:0800C4D4 
  
 dd offset _2__STRING_10104_0 ; ""V$WAITSTAT"" 
 .rodata:0800C4D8 
  
 dd 4 
  
 .rodata:0800C4DC 
  
 dd offset _2__STRING_10103_0 ; ""NULL"" .rodata:0800C4E0 
  
 dd 3 
  
 .rodata:0800C4E4 
  
 dd 0 
  
 .rodata:0800C4E8 
  
 dd 4Eh",NA
81.2 ,NA,NA
X$KSMLRU,NA,NA
 table in Oracle RDBMS,"There is a mention of a special table in the
  Diagnosing and Resolving Error ORA-04031 on the Shared Pool or Other Memory
  
 Pools [Video] [ID 146599.1]
  note:
  
  
 There is a fixed table called X$KSMLRU that tracks allocations in the shared pool that cause other 
 objects in the shared pool to be aged out. This fixed table can be used to identify what is causing the large 
 allocation.
  
 If many objects are being periodically flushed from the shared pool then this will cause response time 
 problems and will likely cause library cache latch contention problems when the objects are reloaded into 
 the shared pool.
  
 One unusual thing about the X$KSMLRU fixed table is that the contents of the fixed table are erased 
 whenever someone selects from the fixed table. This is done since the fixed table stores only the largest 
 allocations that have occurred. The values are reset after being selected so that subsequent large 
 allocations can be noted even if they were not quite as large as others that occurred previously. Because of 
 this resetting, the output of selecting from this table should be carefully kept since it cannot be retrieved 
 back after the query is issued.
  
 However, as it can be easily checked, the contents of this table are cleared each time it’s queried. Are we able to find why?",NA
81.3 ,NA,NA
V$TIMER,NA,NA
 table in Oracle RDBMS,"V$TIMER
  is another
  fixed view
  that reflects a rapidly changing value:
  
 V$TIMER displays the elapsed time in hundredths of a second. Time is measured since the beginning 
 of the epoch, which is operating system specific, and wraps around to 0 again whenever the value 
 overflows four bytes (roughly 497 days).
  
 (From Oracle RDBMS documentation
 5
 ) 
  
 It is interesting that the periods are different for Oracle for win32 and for Linux. Will we be able to find the function that 
 generates this value?
  
 As we can see, this information is finally taken from the
  X$KSUTM
  table.
  
 SQL> select * from V$FIXED_VIEW_DEFINITION where view_name='V$TIMER';
  
 VIEW_NAME
  
 ------------------------------
  
 VIEW_DEFINITION
  
 --------------------------------------------------------------------------------
  
 V$TIMER 
  
 select 
  
 HSECS from GV$TIMER where inst_id = USERENV('Instance')
  
 SQL> select * from V$FIXED_VIEW_DEFINITION where view_name='GV$TIMER';
  
 VIEW_NAME
  
 ------------------------------
  
 VIEW_DEFINITION
  
 --------------------------------------------------------------------------------
  
 GV$TIMER 
  
 select inst_id,ksutmtim from x$ksutm
  
 Now we are stuck in a small problem, there are no references to value generating function(s) in the tables
  kqftab
 /
 kqftap
 :
  
 Listing 81.12: Result of oracle tables
  
 kqftab_element.name: [X$KSUTM] ?: [ksutm] 0x1 0x4 0x4 0x0 0xffffc09b 0x3 
 kqftap_param.name=[ADDR] ?: 0x10917 0x0 0x0 0x0 0x4 0x0 0x0 
  
 kqftap_param.name=[INDX] ?: 0x20b02 0x0 0x0 0x0 0x4 0x0 0x0 
  
 kqftap_param.name=[INST_ID] ?: 0xb02 0x0 0x0 0x0 0x4 0x0 0x0
  
 kqftap_param.name=[KSUTMTIM] ?: 0x1302 0x0 0x0 0x0 0x4 0x0 0x1e 
 kqftap_element.fn1=NULL 
  
 kqftap_element.fn2=NULL
  
 When we try to find the string
  KSUTMTIM
 , we see it in this function:
  
  
 kqfd_DRN_ksutm_c proc near
  
 8
  
 ; DATA XREF: .rodata:0805B4E8
  
 arg_0
  
 = dword ptr
  
 arg_8
  
 = dword ptr
  
 10h
  
 arg_C
  
 = dword ptr
  
 14h
  
  
 push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 push 
  
 [ebp+arg_C] 
  
 push 
  
 offset ksugtm 
  
 push 
  
 offset _2__STRING_1263_0 ; ""KSUTMTIM""
  
 5
 http://go.yurichev.com/17088",NA
Chapter 82,NA,NA
Handwritten assembly code,NA,NA
82.1 ,NA,NA
EICAR test file,"This .COM-file is intended for testing antivirus software, it is possible to run in in MS-DOS and it prints this string: “EICAR-
 STANDARD-ANTIVIRUS-TEST-FILE!”
 1
 .
  
 Its important property is that it’s consists entirely of printable ASCII-symbols, which, in turn, makes it possible to create it 
 in any text editor:
  
 X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
  
  
 Let’s decompile it:
  
 ; initial conditions: SP=0FFFEh, SS:[SP]=0
  
 0100 58
  
 pop
  
 ax
  
 ; AX=0, SP=0
  
 0101 35 4F 21
  
 xor
  
 ax, 214Fh
  
 ; AX = 214Fh and SP = 0
  
 0104 50
  
 push
  
 ax
  
 ; AX = 214Fh, SP = FFFEh and SS:[FFFE] = 214Fh
  
 0105 25 40 41
  
 and
  
 ax, 4140h
  
 ; AX = 140h, SP = FFFEh and SS:[FFFE] = 214Fh
  
 0108 50
  
 push
  
 ax
  
 ; AX = 140h, SP = FFFCh, SS:[FFFC] = 140h and SS:[FFFE] = 214Fh
  
 0109 5B
  
 pop
  
 bx
  
 ; AX = 140h, BX = 140h, SP = FFFEh and SS:[FFFE] = 214Fh
  
 010A 34 5C
  
 xor
  
 al, 5Ch
  
 ; AX = 11Ch, BX = 140h, SP = FFFEh and SS:[FFFE] = 214Fh
  
 010C 50
  
 push
  
 ax
  
 010D 5A
  
 pop
  
 dx
  
 ; AX = 11Ch, BX = 140h, DX = 11Ch, SP = FFFEh and SS:[FFFE] = 214Fh
  
  
 010E 58
  
 pop
  
 ax
  
 ; AX = 214Fh, BX = 140h, DX = 11Ch and SP = 0
  
 010F 35 34 28
  
 xor
  
 ax, 2834h
  
 ; AX = 97Bh, BX = 140h, DX = 11Ch and SP = 0
  
 0112 50
  
 push
  
 ax
  
 0113 5E
  
 pop
  
 si
  
 ; AX = 97Bh, BX = 140h, DX = 11Ch, SI = 97Bh and SP = 0
  
 0114 29 37 sub 
  
 [bx], si
  
 0116 43 inc 
  
 bx
  
 0117 43 inc 
  
 bx
  
 0118 29 37 sub 
  
 [bx], si
  
 011A 7D 24 jge 
  
 short near ptr word_10140
  
 011C 45 49 43 ... db 'EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$'
  
 0140 48 2B 
  
 word_10140 
  
 dw 2B48h 
  
 ; CD 21 (INT 21) will be here
  
 0142 48 2A 
  
 dw 2A48h 
  
 ; CD 20 (INT 20) will be here
  
 0144 0D 
  
 db 
  
 0Dh
  
 0145 0A 
  
 db 
  
 0Ah
  
 We will add comments about the registers and stack after each instruction. 
 Essentially, all these instructions are here only to execute this code:
  
 1
 wikipedia
  
 807",NA
Chapter 83,NA,NA
Demos,"Demos (or demomaking) were an excellent exercise in mathematics, computer graphics programming and very tight x86
  
 hand coding.",NA
83.1 ,NA,NA
10 PRINT CHR$(205.5+RND(1)); : GOTO 10,"All examples here are MS-DOS .COM files.
  
 In [
 al12
 ] we can read about one of the most simple possible random maze generators. 
 characters randomly and endlessly, resulting in something like this:
  
 It just prints a slash or backslash
  
  
 There are a few known implementations for 16-bit x86.
  
 83.1.1 
  
 Trixter’s 42 byte version
  
 The listing was taken from his website
 1
 , but the comments are mine.
  
 00000000: B001
  
 mov
  
 al,1
  
 ; set 40x25 video mode
  
 00000002: CD10
  
 int
  
 010
  
 ; set video page for int 10h call
  
 00000004: 30FF
  
 xor
  
 bh,bh
  
 00000006: B9D007
  
 mov
  
 cx,007D0
  
 ; 2000 characters to output
  
 00000009: 31C0
  
 xor
  
 ax,ax
  
  
 00000009: 31C0
  
 xor
  
 ax,ax
  
 ; push flags
  
 0000000B: 9C
  
 pushf
  
 ; get random value from timer chip
  
 0000000C: FA
  
 cli
  
 043,al
  
 ; disable interrupts
  
 0000000D: E643
  
 out
  
 ; write 0 to port 43h
  
  
 1
 http://go.yurichev.com/17305
  
 809",NA
83.2 ,NA,NA
Mandelbrot set,"CHAPTER 83. DEMOS
  
 Mandelbrot set is a fractal, which exhibits self-similarity. When you increase scale, you see that this characteristic pattern 
 repeating infinitely.
  
 Here is a demo
 5
 written by “Sir_Lagsalot” in 2009, that draws the Mandelbrot set, which is just a x86 program with 
 executable file size of only 64 bytes. There are only 30 16-bit x86 instructions.
  
 Here it is what it draws:
  
  
 Let’s try to understand how it works.
  
 5
 Download it
  here
 ,
  
 812",NA
Part IX ,NA,NA
Examples of reversing proprietary file formats,822,NA
Chapter 84,NA,NA
Primitive XOR-encryption,823,NA
84.1 ,NA,NA
Norton Guide: simplest possible 1-byte XOR encryption,"Norton Guide
 1
 was popular in the epoch of MS-DOS, it was a resident program that worked as a hypertext reference 
 manual. Norton Guide’s databases are files with the extension .ng, the contents of which look encrypted:
  
  
 Figure 84.1: Very typical look
  
 Why did we think that it’s encrypted but not compressed? We see that the 0x1A byte (looking like “
 →
 ”) occurs often, it 
 would an unknown language.
  
 1
 wikipedia
  
 824",NA
84.2 ,NA,NA
Simplest possible 4-byte XOR encryption,"CHAPTER 84. PRIMITIVE XOR-ENCRYPTION
  
 If a longer pattern was used for XOR-encryption, for example a 4 byte pattern, it’s easy to spot as well.
  
 For example, here
  
 is the beginning of the kernel32.dll file (32-bit version from Windows Server 2008):
  
  
 Figure 84.3: Original file
  
 827",NA
Chapter 85,NA,NA
Millenium game save file,"The “Millenium Return to Earth” is an ancient DOS game (1991), that allows you to mine resources, build ships, equip 
 them
  
 on other planets, and so on
 1
 .
  
 Like many other games, it allows you to save all game state into a file.
  
 Let’s see if we can find something in it.
  
 1
 It can be downloaded for free
  here",NA
Chapter 86,NA,NA
Oracle RDBMS: .SYM-files,"When an Oracle RDBMS process experiences some kind of crash, it writes a lot of information into log files, including stack 
 trace, like this:
  
 ----- Call Stack Trace -----
  
 calling
  
 call
  
 entry
  
 argument values in hex
  
 location
  
 type
  
 point
  
 (? means dubious value)
  
 -------------------- -------- -------------------- ----------------------------
  
 _kqvrow()
  
 CALLptr
  
 00000000
  
 23D4B914 E47F264 1F19AE2
  
 _opifch2()+2729
  
 00000000
  
 EB1C8A8 1
  
 _kpoal8()+2832
  
 CALLrel
  
 _opifch2()
  
 89 5 EB1CC74
  
 _opiodr()+1248
  
 CALLreg
  
 00000000
  
 5E 1C EB1F0A0
  
 _ttcpip()+1051
  
 CALLreg
  
 00000000
  
 5E 1C EB1F0A0 0
  
 _opitsk()+1404
  
 CALL???
  
 00000000
  
 C96C040 5E EB1F0A0 0 EB1ED30
  
  
 EB1F1CC 53E52E 0 EB1F1F8
  
 _opiino()+980
  
 CALLrel
  
 _opitsk()
  
 0 0
  
 _opiodr()+1248
  
 CALLreg
  
 00000000
  
 3C 4 EB1FBF4
  
 _opidrv()+1201
  
 CALLrel
  
 _opiodr()
  
 3C 4 EB1FBF4 0
  
 _sou2o()+55
  
 CALLrel
  
 _opidrv()
  
 3C 4 EB1FBF4
  
 _opimai_real()+124
  
 CALLrel
  
 _sou2o()
  
 EB1FC04 3C 4 EB1FBF4
  
 _opimai()+125
  
 CALLrel
  
 _opimai_real()
  
 2 EB1FC2C
  
 _OracleThreadStart@
  
 CALLrel
  
 _opimai()
  
 2 EB1FF6C 7C88A7F4 EB1FC34 0
  
 4()+830
  
 CALLreg
  
 00000000
  
 EB1FD04
  
 77E6481C
  
 E41FF9C 0 0 E41FF9C 0 EB1FFC4
  
 00000000
  
 CALL???
  
 00000000
  
  
 But of course, Oracle RDBMS’s executables must have some kind of debug information or map files with symbol 
 information included or something like that.
  
 Windows NT Oracle RDBMS has symbol information in files with .SYM extension, but the format is proprietary. (Plain text 
 files are good, but needs additional parsing, hence offer slower access.)
  
 Let’s see if we can understand its format. We will pick the shortest
  orawtc8.sym
  file that comes with the
  orawtc8.dll 
 file in 
 Oracle 8.1.7
 1
 .
  
 1
 We can chose an ancient Oracle RDBMS version intentionally due to the smaller size of its modules",NA
Chapter 87,NA,NA
Oracle RDBMS: .MSB-files,"When working toward the solution of a problem, it
  
 always helps if you know the answer.
  
 Murphy’s Laws, Rule of Accuracy
  
 This is a binary file that contains error messages with their corresponding numbers. Let’s try to understand its format and
  
 find a way to unpack it.
  
 There are Oracle RDBMS error message files in text form, so we can compare the text and packed binary files
 1
 .
  
 This is the beginning of the ORAUS.MSG text file with some irrelevant comments stripped:
  
 Listing 87.1: Beginning of ORAUS.MSG file without comments
  
 00000, 00000, ""normal, successful completion"" 
  
 00001, 00000, ""unique constraint (%s.%s) violated"" 
  
 00017, 00000, ""session requested to set trace event"" 
  
 00018, 00000, ""maximum number of sessions exceeded"" 
  
 00019, 00000, ""maximum number of session licenses exceeded"" 
  
 00020, 00000, ""maximum number of processes (%s) exceeded"" 
  
 00021, 00000, ""session attached to some other process; cannot switch session"" 00022, 00000, ""invalid session 
 ID; access denied"" 
  
 00023, 00000, ""session references process private memory; cannot detach session""
  
 00024, 00000, ""logins from more than one process not allowed in single-process mode"" 00025, 00000, ""failed to 
 allocate %s"" 
  
 00026, 00000, ""missing or invalid session ID"" 
  
 00027, 00000, ""cannot kill current session"" 
  
 00028, 00000, ""your session has been killed"" 
  
 00029, 00000, ""session is not a user session"" 
  
 00030, 00000, ""User session ID does not exist."" 
  
 00031, 00000, ""session marked for kill"" 
  
 ...
  
 The first number is the error code. The second is perhaps maybe some additional flags.
  
 1
 Open-source text files don’t exist in Oracle RDBMS for every .MSB file, so that’s why we will work on their file format
  
 847",NA
87.1 Summary,"The method is probably too old-school for modern computers. Supposedly, this file format was developed in the mid-80’s 
 by someone who also coded for
  big iron
  with memory/disk space economy in mind. Nevertheless, it was an interesting and 
 yet easy task to understand a proprietary file format without looking into Oracle RDBMS’s code.",NA
Part X ,NA,NA
Other things,853,NA
Chapter 88,NA,NA
npad,"It is an assembly language macro for aligning labels on a specific boundary.
  
 That’s often needed for the busy labels to where the control flow is often passed, e.g., loop body starts. So the CPU can load 
 the data or code from the memory effectively, through the memory bus, cache lines, etc.
  
 Taken from
  listing.inc
  (MSVC): 
  
 By the way, it is a curious example of the different
  NOP
  variations. All these instructions have no effects whatsoever, but 
 have a different size.
  
 Having a single idle instruction instead of couple of NOP-s, is accepted to be better for CPU performance.
  
 ;; LISTING.INC 
  
 ;; 
  
 ;; This file contains assembler macros and is included by the files created ;; with the -FA compiler 
 switch to be assembled by MASM (Microsoft Macro ;; Assembler).
  
 ;; 
  
 ;; Copyright (c) 1993-2003, Microsoft Corporation. All rights reserved.
  
 ;; non destructive nops 
  
 npad macro size 
  
 if size eq 1 
  
  
 nop 
  
 else 
  
 if size eq 2 
  
    
 mov edi, edi 
  
 else 
  
  
 if size eq 3 
  
     
 ; lea ecx, [ecx+00] 
  
     
 DB 8DH, 49H, 00H 
  
  
 else 
  
    
 if size eq 4
  
  
 ; lea esp, [esp+00] 
  
  
 DB 8DH, 64H, 24H, 00H 
  
 else 
  
 if size eq 5 
  
   
 add eax, DWORD PTR 0 
  
 else 
  
  
 if size eq 6 
  
     
 ; lea ebx, [ebx+00000000] 
  
     
 DB 8DH, 9BH, 00H, 00H, 00H, 00H 
  
  
 else 
  
   
 if size eq 7 
  
     
 ; lea esp, [esp+00000000] 
  
     
 DB 8DH, 0A4H, 24H, 00H, 00H, 00H, 00H 
  
   
 else 
  
     
 if size eq 8 
  
     
 ; jmp .+8; .npad 6 
  
     
 DB 0EBH, 06H, 8DH, 9BH, 00H, 00H, 00H, 00H 
  
     
 else 
  
     
 if size eq 9 
  
       
 ; jmp .+9; .npad 7 
  
       
 DB 0EBH, 07H, 8DH, 0A4H, 24H, 00H, 00H, 00H, 00H
  
 854",NA
Chapter 89,NA,NA
Executable files patching,NA,NA
89.1 ,NA,NA
Text strings,"The C strings are the thing that is the easiest to patch (unless they are encrypted) in any hex editor. This technique is 
 available even for those who are not aware of machine code and executable file formats. The new string has not to be 
 bigger than the old one, because there’s a risk of overwriting another value or code there. Using this method, a lot of 
 software was
  localized 
 in the MS-DOS era, at least in the ex-USSR countries in 80’s and 90’s. It was the reason why some 
 weird abbreviations were present in the
  localized
  software: there was no room for longer strings.
  
 As for Delphi strings, the string’s size must also be corrected, if needed.",NA
89.2 ,NA,NA
x86 code,"Frequent patching tasks are:
  
 • One of the most frequent jobs is to disable some instruction. It is often done by filling it using byte
  0x90
  (
 NOP
 ).
  
 • Conditional jumps, which have an opcode like
  74 xx
  (
 JZ
 ), can be filled with two
  NOP
 s. It is also possible to disable 
  
 a conditional jump by writing 0 at the second byte (
 jump offset
 ).
  
 • Another frequent job is to make a conditional jump to always trigger: this can be done by writing
  0xEB
  instead of the 
  
 opcode, which stands for
  JMP
 .
  
 • A function’s execution can be disabled by writing
  RETN
  (0xC3) at its beginning. This is true for all functions 
 excluding 
 stdcall
  (
  64.2 on page 648
 ). While patching
  stdcall
  functions, one has to determine the number of 
 arguments (for example, by finding
  RETN
  in this function), and use
  RETN
  with a 16-bit argument (0xC2).
  
 • Sometimes, a disabled functions has to return 0 or 1. This can be done by
  MOV EAX, 0
  or
  MOV EAX, 1
 , but it’s 
 slightly verbose. A better way is
  XOR EAX, EAX
  (2 bytes
  0x31 0xC0
 ) or
  XOR EAX, EAX / INC EAX
  (3 bytes 
 0x31 0xC0 
 0x40
 ).
  
 A software may be protected against modifications. 
  
 This protection is often done by reading the executable code and 
 calculating a checksum. Therefore, the code must be read before protection is triggered. This can be determined by setting 
 a breakpoint on reading memory.
  
 tracer
  has the BPM option for this.
  
 PE executable file relocs (
  68.2.6 on page 673
 ) must not to be touched while patching, because the Windows loader may 
 overwrite your new code. (They are grayed in Hiew, for example: fig.
 7.12
 ). As a last resort, it is possible to write jumps 
 that circumvent the relocs, or you will need to edit the relocs table.",NA
Chapter 90,NA,NA
Compiler intrinsic,"A function specific to a compiler which is not an usual library function. The compiler generates a specific machine code
  
 instead of a call to it. It is often a pseudofunction for specific
  CPU
  instruction.
  
 For example, there are no cyclic shift operations in C/C++ languages, but they are present in most
  CPU
 s. For program-
  
 mer’s convenience, at least MSVC has pseudofunctions
  _rotl()
  and
  _rotr()
 1
 which are translated by the compiler directly to 
 the
  
 ROL/ROR x86 instructions.
  
 Another example are functions to generate SSE-instructions right in the code.
  
 Full list of MSVC intrinsics:
  MSDN
 .
  
 1
 MSDN",NA
Chapter 91,NA,NA
Compiler’s anomalies,"Intel C++ 10.1, which was used for Oracle RDBMS 11.2 Linux86 compilation, may emit two
  JZ
  in row, and there are no 
 references to the second
  JZ
 . The second
  JZ
  is thus meaningless.
  
 Listing 91.1: kdli.o from libserver11.a
  
 .text:08114CF1 
  
 loc_8114CF1: ; CODE XREF: __PGOSF539_kdlimemSer+89A
  
 .text:08114CF1 
  
 ; __PGOSF539_kdlimemSer+3994
  
 .text:08114CF1 8B 45 08 
  
 mov 
  
 eax, [ebp+arg_0]
  
 .text:08114CF4 0F B6 50 14 
  
 movzx 
  
 edx, byte ptr [eax+14h]
  
 .text:08114CF8 F6 C2 01 
  
 test 
  
 dl, 1
  
 .text:08114CFB 0F 85 17 08 00 00 
  
 jnz 
  
 loc_8115518
  
 .text:08114D01 85 C9 
  
 test 
  
 ecx, ecx
  
 .text:08114D03 0F 84 8A 00 00 00 
  
 jz 
  
 loc_8114D93
  
 .text:08114D09 0F 84 09 08 00 00 
  
 jz 
  
 loc_8115518
  
 .text:08114D0F 8B 53 08
  
 mov
  
 edx, [ebx+8]
  
 .text:08114D12 89 55 FC
  
 mov
  
 [ebp+var_4], edx
  
 .text:08114D15 31 C0
  
 xor
  
 eax, eax
  
 .text:08114D17 89 45 F4
  
 mov
  
 [ebp+var_C], eax
  
 .text:08114D1A 50
  
 push
  
 eax
  
 .text:08114D1B 52
  
 push
  
 edx
  
 .text:08114D1C E8 03 54 00 00
  
 call
  
 len2nbytes
  
 .text:08114D21 83 C4 08
  
 add
  
 esp, 8
  
  
 Listing 91.2: from the same code
  
 .text:0811A2A5 
  
 loc_811A2A5: ; CODE XREF: kdliSerLengths+11C
  
 .text:0811A2A5 
  
 ; kdliSerLengths+1C1
  
 .text:0811A2A5 8B 7D 08 
  
 mov 
  
 edi, [ebp+arg_0]
  
 .text:0811A2A8 8B 7F 10 
  
 mov 
  
 edi, [edi+10h]
  
 .text:0811A2AB 0F B6 57 14 
  
 movzx 
  
 edx, byte ptr [edi+14h]
  
 .text:0811A2AF F6 C2 01 
  
 test 
  
 dl, 1
  
 .text:0811A2B2 75 3E 
  
 jnz 
  
 short loc_811A2F2
  
 .text:0811A2B4 83 E0 01
  
 and
  
 eax, 1
  
 .text:0811A2B7 74 1F
  
 jz
  
 short loc_811A2D8
  
 .text:0811A2B9 74 37
  
 jz
  
 short loc_811A2F2
  
 .text:0811A2BB 6A 00
  
 push
  
 0
  
 .text:0811A2BD FF 71 08
  
 push
  
 dword ptr [ecx+8]
  
 .text:0811A2C0 E8 5F FE FF FF
  
 call
  
 len2nbytes
  
  
 It is probably a code generator bug that was not found by tests, because resulting code works correctly anyway.
  
 Other compiler anomalies here in this book:
  19.2.4 on page 299
 ,
  39.3 on page 462
 ,
  47.7 on page 506
 ,
  18.7 on page 286
 ,
  
 12.4.1 on page 136
 ,
  19.5.2 on page 316
 .
  
 Such cases are demonstrated here in this book, to show that such compilers errors are possible and sometimes one should 
 not to rack one’s brain while thinking why did the compiler generate such strange code.",NA
Chapter 92,NA,NA
OpenMP,"OpenMP is one of the simplest ways to parallelize simple algorithms.
  
 As an example, let’s try to build a program to compute a cryptographic
  nonce
 . 
  
 In my simplistic example, the
  nonce
  is a 
 number added to the plain unencrypted text in order to produce a hash with some specific features. For example, at some 
 step, the Bitcoin protocol requires to find such
  nonce
  so the resulting hash contains a specific number of consecutive 
 zeroes. This is also called “proof of work”
 1
 ( i.e., the system proves that it did some intensive calculations and spent some 
 time for it).
  
 My example is not related to Bitcoin in any way, it will try to add numbers to the “hello, world!_” string in order to find such 
 number that when “hello, world!_<number>” is hashed with the SHA512 algorithm, it will contain at least 3 zero bytes.
  
 Let’s limit our brute-force to the interval in 0..INT32_MAX-1 (i.e.,
  0x7FFFFFFE
  or 2147483646).
  
 The algorithm is pretty straightforward:
  
 #include <stdio.h> 
  
 #include <string.h> 
  
 #include <stdlib.h> 
  
 #include <time.h> 
  
 #include ""sha512.h""
  
 int found=0; 
  
 int32_t checked=0;
  
 int32_t* __min; 
  
 int32_t* __max;
  
 time_t start;
  
 #ifdef __GNUC__ 
  
 #define min(X,Y) ((X) < (Y) ? (X) : (Y)) 
  
 #define max(X,Y) ((X) > (Y) ? (X) : (Y)) 
  
 #endif
  
 void check_nonce (int32_t nonce) 
  
 { 
  
 uint8_t buf[32]; 
  
 struct sha512_ctx ctx; 
  
 uint8_t res[64];
  
 // update statistics 
  
 int t=omp_get_thread_num();
  
 if (__min[t]==-1) 
  
  
 __min[t]=nonce; 
  
 if (__max[t]==-1) 
  
  
 __max[t]=nonce;
  
 __min[t]=min(__min[t], nonce); 
  
 __max[t]=max(__max[t], nonce);
  
 // idle if valid nonce found
  
 1
 wikipedia",NA
92.1 ,NA,NA
MSVC,"CHAPTER 92. OPENMP
  
 Now this is how MSVC 2012 generates the main loop:
  
 Listing 92.1: MSVC 2012
  
 push 
  
 OFFSET _main$omp$1
  
 push 
  
 0
  
 push 
  
 1
  
  
 call
  
 __vcomp_fork
  
 ; 00000010H
  
 add
  
 esp, 16
  
  
 All functions prefixed by
  vcomp
  are OpenMP-related and are stored in the vcomp*.dll file. So here a group of threads is 
 started.
  
 Let’s take a look on
  _main$omp$1
 :
  
 Listing 92.2: MSVC 2012
  
 $T1 = -8 
   
  
 ; size = 4 $T2 
 = -4 
  
  
  
 ; size = 4 
 _main$omp$1 PROC 
  
 ; COMDAT push 
  
 ebp 
  
 mov 
  
 ebp, esp 
  
 push 
  
 ecx 
  
 push 
  
 ecx 
  
 push 
  
 esi 
  
 lea 
  
 eax, DWORD PTR $T2[ebp] 
  
 push 
  
 eax 
  
 lea 
  
 eax, DWORD PTR $T1[ebp] 
  
 push 
  
 eax 
  
 push 
  
 1 
  
 push 
  
 1 
  
 push 
  
 2147483646 
  
 ; 7ffffffeH push 
  
  
 0 call 
  
 __vcomp_for_static_simple_init
  
  
 mov
  
 esi, DWORD PTR $T1[ebp]
  
 ; 00000018H
  
 add
  
 esp, 24
  
 jmp
  
 SHORT $LN6@main$omp$1
  
 $LL2@main$omp$1: 
  
 push 
  
 esi 
  
 call 
  
 _check_nonce 
  
 pop 
  
 ecx 
  
 inc 
  
  
 esi $LN6@main$omp$1: 
  
 cmp 
  
 esi, DWORD PTR $T2[ebp] 
  
 jle 
  
 SHORT $LL2@main$omp$1 
  
 call 
  
 __vcomp_for_static_end 
  
 pop 
  
 esi 
  
 leave 
  
 ret 
  
 0 
  
 _main$omp$1 ENDP
  
 This function is to be started
  n
  times in parallel, where
  n
  is the number of
  CPU
  cores.
  vcomp_for_static_simple_init() 
 calculates the interval for the for() construct for the current thread, depending on the current thread’s number. The loop’s 
 start and end values are stored in the
  $T1
  and
  $T2
  local variables. You may also notice
  7ffffffeh
  (or 2147483646) as an 
 argument to the
  vcomp_for_static_simple_init()
  function—this is the number of iterations for the whole loop, to be divided 
 evenly.
  
 Then we see a new loop with a call to the
  check_nonce()
  function, which does all the work.
  
 Let’s also add some code in the beginning of the
  check_nonce()
  function to gather statistics about the arguments with 
 which the function was called.
  
 This is what we see when we run it:
  
 threads=4 
  
 ...
  
 checked=2800000
  
 checked=3000000 
  
 checked=3200000 
  
 checked=3300000",NA
92.2 ,NA,NA
GCC,"GCC 4.8.1 produces a program which shows exactly the same statistics table, so, GCC’s implementation divides the loop in 
 parts in the same fashion.
  
 4
 Read more about LOCK prefix:
  A.6.1 on page 885 
  
 5
 You can read more about critical sections here:
  68.4 on page 699",NA
Chapter 93,NA,NA
Itanium,"Although almost failed, Intel Itanium (
 IA64
 ) is a very interesting arcutecture. 
  
 While
  OOE
  CPUs decides how to rearrange 
 their instructions and execute them in parallel,
  EPIC
 1
 was an attempt to shift these decisions to the compiler: to let it group 
 the instructions at the compile stage.
  
 This resulted in notoriously complex compilers.
  
 Here is one sample of
  IA64
  code: simple cryptographic algorithm from the Linux kernel: 
  
 Listing 93.1: Linux kernel 3.2.0.4
  
 #define TEA_ROUNDS 
  
 32 
  
 #define TEA_DELTA 
  
 0x9e3779b9
  
 static void tea_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src) { 
  
 u32 y, z, n, sum = 0; 
  
 u32 k0, k1, k2, k3; 
  
 struct tea_ctx *ctx = crypto_tfm_ctx(tfm); 
  
 const __le32 *in = (const __le32 *)src; 
  
 __le32 *out = (__le32 *)dst;
  
 y = le32_to_cpu(in[0]); 
  
 z = le32_to_cpu(in[1]);
  
 k0 = ctx->KEY[0];
  
 k1 
 = 
 ctx->KEY[1]; 
  
 k2 
 = 
 ctx->KEY[2]; 
  
 k3 = ctx->KEY[3];
  
 n = TEA_ROUNDS;
  
 while (n-- > 0) { 
  
  
 sum += TEA_DELTA; 
  
  
 y += ((z << 4) + k0) ^ (z + sum) ^ ((z >> 5) + k1); 
  
 z += ((y 
 << 4) + k2) ^ (y + sum) ^ ((y >> 5) + k3); }
  
 out[0] = cpu_to_le32(y); 
  
 out[1] = cpu_to_le32(z); 
  
 }
  
 Here is how it was compiled: 
  
  
 Listing 93.2: Linux Kernel 3.2.0.4 for Itanium 2 (McKinley)
  
 0090|
  
 tea_encrypt:
  
 // ptr to ctx->KEY
 ⤦
 // ptr to ctx-
 >KEY
  
 0090|08 80 80 41 00 21
  
 adds r16 = 96, r32
  
  [2]
  
 adds r8 = 88, r32
  
 0096|80 C0 82 00 42 00
  
  
  [0]
  
 nop.i 0
  
 ⤦
  
 009C|00 00 04 00
  
 // ptr to ctx->KEY
 ⤦
  
 00A0|09 18 70 41 00 21
  
 adds r3 = 92, r32
  
  [1]
  
  
 1
 Explicitly parallel instruction computing
  
 865",NA
Chapter 94,NA,NA
8086 memory model,"When dealing with 16-bit programs for MS-DOS or Win16 (
  78.3 on page 746
  or
  53.5 on page 578
 ), we can see that the 
 pointers consist of two 16-bit values. What do they mean? Oh yes, that is another weird MS-DOS and 8086 artefact.
  
 8086/8088 was a 16-bit CPU, but was able to address 20-bit address in RAM (thus being able to access 1MB of external 
 memory). The external memory address space was divided between
  RAM
  (640KB max),
  ROM
 , windows for video memory, 
 EMS cards, etc.
  
 Let’s also recall that 8086/8088 was in fact an inheritor of the 8-bit 8080 CPU. The 8080 has a 16-bit memory space, i.e., it 
 was able to address only 64KB. And probably because of old software porting reason
 1
 , 8086 can support many 64KB 
 windows simultaneously, placed within the 1MB address space. This is some kind of a toy-level virtualization. 
  
 All 8086 
 registers are 16-bit, so to address more, special segment registers (CS, DS, ES, SS) were introduced. Each 20-bit pointer is 
 calculated using the values from a segment register and an address register pair (e.g. DS:BX) as follows:
  
 For example, the graphics (
 EGA
 2
 ,
  VGA
 3
 ) video
  RAM
  window on old IBM PC-compatibles has a size of 64KB. To access it, a 
 real
 _
 address
  = (
 segment
 _
 register
  ≪ 4) +
  address
 _
 register 
  
 value of 0xA000 has to be stored in one of the segment registers, e.g. into DS. Then DS:0 will address the first byte of 
 video 
 RAM
  and DS:0xFFFF — the last byte of RAM. The real address on the 20-bit address bus, however, will range from 
 0xA0000 to 0xAFFFF.
  
 The program may contain hard-coded addresses like 0x1234, but the
  OS
  may need to load the program at arbitrary 
 addresses, so it recalculates the segment register values in a way that the program does not have to care where it’s placed 
 in the RAM.
  
 So, any pointer in the old MS-DOS environment in fact consisted of the segment address and the address inside segment, 
 i.e., two 16-bit values. 20-bit was enough for that, though, but we needed to recalculate the addresses very often: passing 
 more information on the stack seemed a better space/convenience balance.
  
 By the way, because of all this it was not possible to allocate a memory block larger than 64KB.
  
 The segment registers were reused at 80286 as selectors, serving a different function.
  
 When the 80386 CPU and computers with bigger
  RAM
  were introduced, MS-DOS was still popular, so the DOS extenders 
 emerged: these were in fact a step toward a “serious”
  OS
 , switching the CPU in protected mode and providing much better 
 memory
  API
 s for the programs which still needed to run under MS-DOS. Widely popular examples include DOS/4GW (the 
 DOOM video game was compiled for it), Phar Lap, PMODE.
  
 By the way, the same way of addressing memory was used in the 16-bit line of Windows 3.x, before Win32.",NA
Chapter 95,NA,NA
Basic blocks reordering,NA,NA
95.1 ,NA,NA
Profile-guided optimization,"This optimization method can move some
  basic block
 s to another section of the executable binary file.
  
 Obviously, there are parts of a function which are executed more frequently (e.g., loop bodies) and less often (e.g., error 
 reporting code, exception handlers).
  
 The compiler adds instrumentation code into the executable, then the developer runs it with a lot of tests to collect 
 statistics. Then the compiler, with the help of the statistics gathered, prepares final the executable file with all infrequently 
 executed code moved into another section.
  
 As a result, all frequently executed function code is compacted, and that is very important for execution speed and cache 
 usage.
  
 An example from Oracle RDBMS code, which was compiled with Intel C++:
  
 Listing 95.1: orageneric11.dll (win32)
  
 public _skgfsync
  
 _skgfsync 
  
 proc near
  
 ; address 0x6030D86A
  
 db 
  
 66h
  
 nop
  
 push
  
 ebp
  
 ; write to log
  
 mov
  
 ebp, esp
  
 mov
  
 edx, [ebp+0Ch]
  
 test
  
 edx, edx
  
 jz
  
 short loc_6030D884
  
 mov
  
 eax, [edx+30h]
  
 test
  
 eax, 400h
  
 jnz
  
 __VInfreq__skgfsync
  
 continue:
  
 mov 
  
 eax, [ebp+8]
  
 mov 
  
 edx, [ebp+10h]
  
 mov
  
 dword ptr [eax], 0
  
 ; exit with error
  
 lea
  
 eax, [edx+0Fh]
  
 and
  
 eax, 0FFFFFFFCh
  
 mov
  
 ecx, [eax]
  
 cmp
  
 ecx, 45726963h
  
 jnz
  
 error
  
 mov
  
 esp, ebp
  
 pop
  
 ebp
  
 retn
  
 _skgfsync 
  
 endp
  
 ...
  
 ; address 0x60B953F0
  
 __VInfreq__skgfsync:
  
 mov 
  
 eax, [edx]
  
 test 
  
 eax, eax
  
 869",NA
Part XI ,NA,NA
Books/blogs worth reading,871,NA
Chapter 96,NA,NA
Books,NA,NA
96.1 ,NA,NA
Windows ,"[
 RA09
 ].",NA
96.2 ,NA,NA
C/C++ ,"[
 ISO13
 ].",NA
96.3 ,NA,NA
x86 / x86-64 ,"[
 Int13
 ], [
 AMD13a
 ]",NA
96.4 ARM ,"ARM manuals:
  http://go.yurichev.com/17024",NA
96.5 ,NA,NA
Cryptography ,"[
 Sch94
 ]
  
 872",NA
Chapter 97,NA,NA
Blogs,NA,NA
97.1 Windows,"•
  Microsoft: Raymond Chen
  
 •
  nynaeve.net
  
 873",NA
Chapter 98,NA,NA
Other,"There are two excellent
  RE
 -related subreddits on reddit.com: 
 (on the topics for the intersection of
  RE
  and mathematics).
  
 There is also a
  RE
  part of the Stack Exchange website:
  
 reverseengineering.stackexchange.com
 .
  
 On IRC there’s a ##re channel onFreeNode
 1
 .
  
 1
 freenode.net
  
 reddit.com/r/ReverseEngineering/
  and
  reddit.com/r/remath
  
 874",NA
Afterword,875,NA
Chapter 99,NA,NA
Questions?,"Do not hesitate to mail any questions to the author:
 <dennis(a)yurichev.com> 
 Do 
 you have any suggestion on new content for to the book?
  
 Please, do not hesitate to send any corrections (including grammar (you see how horrible my English is?)),etc.
  
 The author is working on the book a lot, so the page and listing numbers, etc. are changing very rapidly.
  
 Please, do not refer to page and listing numbers in your emails to me.
  
 There is a much simpler method: make a screenshot of the page, in a graphics editor underline the place where you see 
 the error, and send it to me. He’ll fix it much faster.
  
 And if you familiar with git and L
 A
 TEX you can fix the error right in the source 
 code: 
 GitHub
 .
  
 Do not worry to bother me while writing me about any petty mistakes you found, even if you are not very confident. I’m 
 writing for beginners, after all, so beginners’ opinions and comments are crucial for my job.
  
 876",NA
Appendix,877,NA
Appendix A,NA,NA
x86,NA,NA
A.1 ,NA,NA
Terminology,"Common for 16-bit (8086/80286), 32-bit (80386, etc), 64-bit.
  
 byte
  8-bit. The DB assembly directive is used for defining variables and arrays of bytes. Bytes are passed in the 8-bit part 
  
 of registers:
  AL/BL/CL/DL/AH/BH/CH/DH/SIL/DIL/R*L
 .
  
 word
  16-bit. DW assembly directive —”—. Words are passed in the 16-bit part of the registers:
  AX/BX/CX/DX/SI/DI/R*W
 . 
 double word
  (“dword”) 32-bit. 
  
 DD assembly directive —”—. 
  
 Double words are passed in registers (x86) or in the 32-bit 
  
 part of registers (x64). In 16-bit code, double words are passed in 16-bit register pairs.
  
 quad word
  (“qword”) 64-bit. DQ assembly directive —”—. 
  
 In 32-bit environment, quad words are passed in 32-bit register 
  
 pairs.
  
 tbyte
  (10 bytes) 80-bit or 10 bytes (used for IEEE 754 FPU registers).
  
 paragraph
  (16 bytes)— term was popular in MS-DOS environment.
  
 Data types of the same width (BYTE, WORD, DWORD) are also the same in Windows
  API
 .",NA
A.2 ,NA,NA
General purpose registers,"It is possible to access many registers by byte or 16-bit word parts. It is all inheritance from older Intel CPUs (up to the 8-
 bit 8080) still supported for backward compatibility. Older 8-bit CPUs (8080) had 16-bit registers divided by two. Programs 
 written for 8080 could access the low byte part of 16-bit registers, high byte part or the whole 16-bit register. Probably, 
 this feature was left in 8086 as a helper for easier porting. This feature is usually not present in
  RISC
  CPUs.
  
 Registers prefixed with R- appeared in x86-64, and those prefixed with E—-in 80386. 
  
 Thus, R-registers are 64-bit, and 
 E-registers—32-bit.
  
 8 more
  GPR
 ’s were added in x86-86: R8-R15.
  
 N.B.:
  
 In the Intel manuals the byte parts of these registers are prefixed by
  L
 , e.g.:
  R8L
 , but
  IDA
  names these registers by
  
 adding the
  B
  suffix, e.g.:
  R8B
 .
  
 A.2.1
  
 RAX/EAX/AX/AL
  
  
 7th
 (byte number)
  
 6th
  
 5th
  
 4th
  
 3rd
  
 2nd
  
 1st
  
 0th
  
 RAX
 x64
  
  
 EAX
  
  
 AX
  
  
 AH
  
 AL
  
 AKA
  accumulator. The result of a function if usually returned via this register.",NA
A.3 ,NA,NA
FPU registers,"8 80-bit registers working as a stack: ST(0)-ST(7). N.B.:
  IDA
  calls ST(0) as just ST. Numbers are stored in the IEEE 754 
 format.
  
 long double
  value format:
  
 79
  
 78
  
 64
  
 63
  
 62
  
 0
  
 ( S—sign, I—integer part )
  
 A.3.1 
  
 Control Word
  
 Register controlling the behaviour of the
  FPU
 .",NA
A.4 ,NA,NA
SIMD registers,"A.4.1 
  
 MMX registers
  
 8 64-bit registers: MM0..MM7.
  
 A.4.2 
  
 SSE and AVX registers
  
 SSE: 8 128-bit registers: XMM0..XMM7. In the x86-64 8 more registers were added: XMM8..XMM15. 
 AVX is the extension of all these registers to 256 bits.",NA
A.5 ,NA,NA
Debugging registers,"Used for hardware breakpoints control.
  
 • DR0 — address of breakpoint #1
  
 • DR1 — address of breakpoint #2
  
 • DR2 — address of breakpoint #3
  
 • DR3 — address of breakpoint #4
  
 • DR6 — a cause of break is reflected here
  
 • DR7 — breakpoint types are set here
  
 A.5.1
  
 DR6
  
  
 Bit (mask)
  
 Description
  
 0 (1)
  
 B0 — breakpoint #1 was triggered
  
 1 (2)
  
 B1 — breakpoint #2 was triggered
  
 2 (4)
  
 B2 — breakpoint #3 was triggered
  
 3 (8)
  
 B3 — breakpoint #4 was triggered
  
 13 (0x2000)
  
 BD — modification attempt of one of the DRx registers. 
 may be raised if GD is enabled
  
 14 (0x4000)
  
 BS — single step breakpoint (TF flag was set in EFLAGS). 
 Highest priority. Other bits may also be set.
  
 15 (0x8000)
  
 BT (task switch flag)
  
 N.B. A single step breakpoint is a breakpoint which occurs after each instruction. It can be enabled by setting TF in 
 EFLAGS (
  A.2.19 on page 881
 ).
  
 A.5.2 
  
 DR7
  
 Breakpoint types are set here.
  
 2
 Not a Number
  
 884",NA
A.6 ,NA,NA
Instructions,"Instructions marked as (M) are not usually generated by the compiler: if you see one of them, it was probably a hand-
 written piece of assembly code, or is a compiler intrinsic (
  90 on page 857
 ).
  
 Only the most frequently used instructions are listed here. You can read [
 Int13
 ] or [
 AMD13a
 ] for a full documentation. 
 Instruction’s opcodes has to be memorized? No, only those which are used for code patching (
  89.2 on page 856
 ). All the 
 rest of the opcodes don’t need to be memorized.
  
 A.6.1 
  
 Prefixes
  
 LOCK
  forces CPU to make exclusive access to the RAM in multiprocessor environment. For the sake of simplification, it can 
  
 be said that when an instruction with this prefix is executed, all other CPUs in a multiprocessor system are stopped.
  
 Most often it is used for critical sections, semaphores, mutexes. Commonly used with ADD, AND, BTR, BTS, 
 CMPXCHG, OR, XADD, XOR. You can read more about critical sections here (
  68.4 on page 699
 ).
  
 REP
  is used with the MOVSx and STOSx instructions: execute the instruction in a loop, the counter is located in the 
  
 CX/ECX/RCX register. For a detailed description, read more about the MOVSx (
  A.6.2 on page 887
 ) and STOSx (
  A.6.2 
  
 on page 889
 ) instructions.
  
 The instructions prefixed by REP are sensitive to the DF flag, which is used to set the direction.
  
 REPE/REPNE
  (
 AKA
  REPZ/REPNZ) used with CMPSx and SCASx instructions: execute the last instruction in a loop, the count 
  
 is set in the
  CX
 /
 ECX
 /
 RCX
  register. It terminates prematurely if ZF is 0 (REPE) or if ZF is 1 (REPNE).",NA
Appendix B,NA,NA
ARM,NA,NA
B.1 ,NA,NA
Terminology,"ARM was initially developed as 32-bit
  CPU
 , so that’s why a
  word
  here, unlike x86, is 32-bit. 
 byte
  8-bit. The DB assembly directive is used for defining variables and arrays of bytes. 
 halfword
  16-bit. DCW assembly directive —”—.
  
 word
  32-bit. DCD assembly directive —”—.
  
 doubleword
  64-bit.
  
 quadword
  128-bit.",NA
B.2 ,NA,NA
Versions,"• ARMv4: Thumb mode introduced.
  
 • ARMv6: used in iPhone 1st gen., iPhone 3G (Samsung 32-bit RISC ARM 1176JZ(F)-S that supports Thumb-2)• ARMv7: 
 Thumb-2 was added (2003). was used in iPhone 3GS, iPhone 4, iPad 1st gen. (ARM Cortex-A8), iPad 2 (Cortex-
  
 A9), 
 iPad 3rd gen.
  
 • ARMv7s: New instructions added. Was used in iPhone 5, iPhone 5c, iPad 4th gen. (Apple A6).
  
 • ARMv8: 64-bit CPU,
  AKA
  ARM64
  AKA
  AArch64. Was used in iPhone 5S, iPad Air (Apple A7). There is no Thumb mode 
  
 in 64-bit mode, only ARM (4-byte instructions).",NA
B.3 ,NA,NA
32-bit ARM (AArch32),"B.3.1 
  
 General purpose registers
  
 • R0— function result is usually returned using R0
  
 • R1...R12—
 GPR
 s
  
 • R13—
 AKA
  SP (
 stack pointer
 )
  
 • R14—
 AKA
  LR (
 link register
 )
  
 • R15—
 AKA
  PC (program counter) 
  
 R0
 -
 R3
  are also called “scratch registers”: the function’s arguments are usually passed in them, and the values in them are 
 not required to be restored upon the function’s exit.
  
 897",NA
B.4 ,NA,NA
64-bit ARM (AArch64),"B.4.1 
  
 General purpose registers
  
 The register count was doubled since AArch32.
  
 • X0— function result is usually returned using X0
  
 • X0...X7—Function arguments are passed here.
  
 • X8
  
 • X9...X15—are temporary registers, the callee function can use and not restore them.
  
 • 
 X16
  
 • 
 X17
  
 • 
 X18
  
 • X19...X29—callee function can use them, but must restore them upon exit.
  
 • X29—used as
  FP
  (at least GCC)
  
 • X30—“Procedure Link Register”
  AKA LR
  (
 link 
 register
 ).",NA
B.5,NA,NA
Instructions,"There is a
  -S
  suffix for some instructions in ARM, indicating that the instruction sets the flags according to the result.
  
 In-
  
 structions which lacks this suffix are not modify flags. For example
  ADD
  unlike
  ADDS
  will add two numbers, but the flags
  
 will not be touched.
  
 Such instructions are convenient to use between
  CMP
  where the flags are set and, e.g. conditional
  
 jumps, where the flags are used. They are also better in terms of data dependency analysis (because less number of 
 registers are modified during execution).
  
 B.5.1
  
 Conditional codes table
  
  
 Code
  
 Description
  
 Flags
  
 EQ
  
 Equal
  
 Z == 1
  
 NE
  
 Not equal
  
 Z == 0
  
 CS
  AKA
  HS (Higher or Same)
  
 Carry set / Unsigned, Greater than, equal
  
 C == 1
  
 CC
  AKA
  LO (LOwer)
  
 Carry clear / Unsigned, Less than
  
 C == 0
  
 MI
  
 Minus, negative / Less than
  
 N == 1
  
 PL
  
 Plus, positive or zero / Greater than, equal
  
 N == 0
  
 VS
  
 Overflow
  
 V == 1
  
 VC
  
 No overflow
  
 V == 0
  
 HI
  
 Unsigned higher / Greater than
  
 C == 1 and Z == 0
  
 LS
  
 Unsigned lower or same / Less than or equal
  
 C == 0 or Z == 1
  
 GE
  
 Signed greater than or equal / Greater than or equal
  
 N == V
  
 LT
  
 Signed less than / Less than
  
 N != V
  
 GT
  
 Signed greater than / Greater than
  
 Z == 0 and N == V
  
 LE
  
 Signed less than or equal / Less than, equal
  
 Z == 1 or N != V
  
 None / AL
  
 Always
  
 Any
  
 899",NA
Appendix C,NA,NA
MIPS,NA,NA
C.1 ,NA,NA
Registers,"( O32 calling convention )
  
 C.1.1
  
 General purpose registers
  GPR
  
  
 Number
  
 Pseudoname
  
 Description
  
 $0
  
 $ZERO
  
 Always zero. Writing to this register is effectively an idle instruction (
 NOP
 ).
  
 $1
  
 $AT
  
 Used as a temporary register for assembly macros and pseudoinstructions.
  
 $2 …$3
  
 $V0 …$V1
  
 Function result is returned here.
  
 $4 …$7
  
 $A0 …$A3
  
 Function arguments.
  
 $8 …$15
  
 $T0 …$T7
  
 Used for temporary data.
  
 $16 …$23
  
 $S0 …$S7
  
 Used for temporary data.
  
 $24 …$25
  
 $T8 …$T9
  
 Used for temporary data.
  
 $26 …$27
  
 $K0 …$K1
  
 Reserved for
  OS
  kernel.
  
 $28
  
 $GP
  
 Global Pointer.
  
 $29
  
 $SP
  
 SP
 .
  
 $30
  
 $FP
  
 FP
 .
  
 $31
  
 $RA
  
 RA
 .
  
 n/a
  
 PC
  
 PC
 .
  
 n/a
  
 HI
  
 high 32 bit of multiplication or division remainder.
  
 n/a
  
 LO
  
  
 low 32 bit of multiplication and division remainder
 ∗∗∗
 .
  
 C.1.2
  
 Floating-point registers
  
  
 Name
  
 Description
  
 $F0..$F1
  
 Function result returned here.
  
 $F2..$F3
  
 Not used.
  
 $F4..$F11
  
 Used for temporary data.
  
 $F12..$F15
  
 First two function arguments.
  
 $F16..$F19
  
 Used for temporary data.
  
 $F20..$F31
   
 Used for temporary data
 ∗
 .
  
 ∗
 —
 Callee
  must preserve the value.
 ∗∗
 —
 Callee
  must preserve the value ( except in
  PIC
  code).
 ∗∗∗
 —accessible using the
  
 MFHI
  and
  MFLO
  instructions.",NA
C.2,NA,NA
Instructions,"There are 3 kinds of instructions:
  
 • R-type: those which have 3 registers. R-instruction usually have the following form:
  
 900",NA
Appendix D,NA,NA
Some GCC library functions,"name
  
 meaning
  
 __divdi3
  
 signed division
  
 __moddi3
  
 getting remainder (modulo) of signed division
  
 __udivdi3
  
 unsigned division
  
 __umoddi3
  
 getting remainder (modulo) of unsigned division
  
 902",NA
Appendix E,NA,NA
Some MSVC library functions,"ll
  in function name stands for “long long”, e.g., a 64-bit data type.
  
 name
  
 meaning
  
 __alldiv
  
 signed division
  
 __allmul
  
 multiplication
  
 __allrem
  
 remainder of signed division
  
 __allshl
  
 shift left
  
 __allshr
  
 signed shift right
  
 __aulldiv
  
 unsigned division
  
 __aullrem
  
 remainder of unsigned division
  
 __aullshr
  
 unsigned shift right
  
 Multiplication and shift left procedures are the same for both signed and unsigned numbers, hence there is only one 
 function
  
 for each operation here.
  
 The source code of these function can be found in the installed
  MSVS
 , in
  VC/crt/src/intel/*.asm
 .",NA
Appendix F,NA,NA
Cheatsheets,NA,NA
F.1 ,NA,NA
IDA,"Hot-keys cheatsheet:
  
 key
  
 meaning
  
 Space 
 C 
  
 D 
  
 A 
  
 * 
  
 U 
  
 O 
  
 H 
  
 R 
  
 B 
  
 Q 
  
 N 
  
 ?
  
 G 
  
 : 
  
 Ctrl-X 
  
 X 
  
 Alt-I 
  
 Ctrl-I 
  
 Alt-B 
  
 Ctrl-B 
  
 Alt-T 
  
 Ctrl-T 
  
 Alt-P 
  
 Enter 
  
 Esc 
  
 Num -
 Num +
  
 switch listing and graph view 
  
 convert to code 
  
 convert to data 
  
 convert to string 
  
 convert to array 
  
 undefine 
  
 make offset of operand 
  
 make decimal number 
  
 make char 
  
 make binary number 
  
 make hexadecimal number 
  
 rename identificator 
  
 calculator 
  
 jump to address 
  
 add comment 
  
 show references to the current function, label, variable (incl. in local stack) 
 show references to the function, label, variable,etc.
  
 search for constant 
  
 search for the next occurrence of constant 
  
 search for byte sequence 
  
 search for the next occurrence of byte sequence 
 search for text (including instructions, etc) 
  
 search for the next occurrence of text 
  
 edit current function 
  
 jump to function, variable, etc 
  
 get back 
  
 fold function or selected area 
  
 unhide function or area
  
 Function/area folding may be useful for hiding function parts when you realize what they do. this is used in my script
 1
 for
  
 hiding some often used patterns of inline code.",NA
F.2 ,NA,NA
OllyDbg,"Hot-keys cheatsheet:
  
 hot-key
  
 meaning
  
 F7 
  
 F8 
  
 F9 
  
 Ctrl-
 F2
  
 trace into 
 step over 
 run 
  
 restart
  
 1
 GitHub
  
 904",NA
F.3 ,NA,NA
MSVC,"APPENDIX F. CHEATSHEETS
  
 Some useful options which were used through this book.
  
 option
  
 meaning
  
 /O1 
  
 /Ob0 
  
 /Ox 
  
 /GS-
  
 /Fa(file) 
 /Zi 
  
 /Zp(n) 
  
 /MD
  
 minimize space 
  
 no inline expansion 
  
 maximum optimizations 
  
 disable security checks (buffer overflows) 
 generate assembly listing 
  
 enable debugging information 
  
 pack structs on
  n
 -byte boundary 
  
 produced executable will use
  MSVCR*.DLL
  
 Some information about MSVC versions:
  55.1 on page 625
 .",NA
F.4 ,NA,NA
GCC,"Some useful options which were used through this book.
  
 option
  
 meaning
  
 -Os
  
 -O3
  
 -regparm=
  
 -o file
  
 -g
  
 -S
  
 -masm=intel-
 fno-inline
  
 code size optimization 
  
 maximum optimization 
  
 how many arguments are to be passed in registers set 
 name of output file 
  
 produce debugging information in resulting executable 
 generate assembly listing file 
  
 produce listing in Intel syntax 
  
 do not inline functions",NA
F.5,NA,NA
GDB,"Some of commands we used in this book:
  
 905",NA
Acronyms used,907,NA
Glossary,"real number
  numbers which may contain a dot. this is
  float
  and
  double
  in C/C++.
  205 
  
 decrement
  Decrease by 1.
  13
 ,
  174
 ,
  191
 ,
  425
 ,
  646
 ,
  774
 ,
  887
 ,
  889
 ,
  893 
  
 increment
  Increase by 1.
  14
 ,
  174
 ,
  178
 ,
  191
 ,
  196
 ,
  311
 ,
  314
 ,
  425
 ,
  770
 ,
  887 
  
 integral data type
  usual numbers, but not a real ones. may be used for passing variables of boolean data type and enumer-
  
 ations.
  220 
  
 product
  Multiplication result.
  90
 ,
  212
 ,
  215
 ,
  392
 ,
  417
 ,
  472 
  
 arithmetic mean
  a sum of all values divided by their count .
  496 
  
 stack pointer
  A register pointing to a place in the stack.
  8
 ,
  9
 ,
  14
 ,
  24
 ,
  27
 ,
  35
 ,
  47
 ,
  48
 ,
  66
 ,
  91
 ,
  525
 ,
  576
 ,
  649
 –
 652
 ,
  882
 ,
  888
 , 
  
 898
 ,
  909 
  
 tail call
  It is when the compiler (or interpreter) transforms the recursion (with which it is possible:
  tail recursion
 ) into an 
  
 iteration for efficiency:
  wikipedia
 .
  451 
  
 quotient
  Division result.
  205
 ,
  208
 ,
  210
 ,
  211
 ,
  215
 ,
  416
 ,
  469
 ,
  497
 ,
  726 
  
 anti-pattern
  Generally considered as bad practice.
  26
 ,
  68
 ,
  436 
  
 atomic operation
  “
 ατoµoς
 ” stands for “indivisible” in Greek, so an atomic operation is guaranteed not to be interrupted by 
  
 other threads.
  700
 ,
  863 
  
 basic block
  a group of instructions that do not have jump/branch instructions, and also don’t have jumps inside the block 
  
 from the outside. In
  IDA
  it looks just like as a list of instructions without empty lines .
  615
 ,
  870
 ,
  871 
  
 callee
  A function being called by another.
  23
 ,
  26
 ,
  39
 ,
  59
 ,
  77
 ,
  89
 ,
  91
 ,
  93
 ,
  145
 ,
  404
 ,
  436
 ,
  525
 ,
  576
 ,
  649
 –
 651
 ,
  654
 ,
  655
 ,
  901 
 caller
  A function calling another.
  5
 ,
  6
 ,
  8
 ,
  39
 ,
  77
 ,
  89
 ,
  90
 ,
  92
 ,
  99
 ,
  145
 ,
  404
 ,
  440
 ,
  525
 ,
  649
 ,
  651
 ,
  652
 ,
  655 
  
 compiler intrinsic
  A function specific to a compiler which is not an usual library function. The compiler generates a specific 
  
 machine code instead of a call to it. Often, it’s a pseudofunction for a specific
  CPU
  instruction. Read more: (
  90 on 
  
 page 857
 ).
  893 
  
 CP/M
  Control Program for Microcomputers: a very basic disk
  OS
  used before MS-DOS.
  809 
  
 dongle
  Dongle is a small piece of hardware connected to LPT printer port (in past) or to USB. Its function was similar to a 
  
 security token, it has some memory and, sometimes, a secret (crypto-)hashing algorithm.
  731 
  
 endianness
  Byte order:
  31 on page 433
 .
  15
 ,
  70
 ,
  331
 ,
  891 
  
 GiB
  Gibibyte:
  2
 30
 or 1024 mebibytes or 1073741824 bytes.
  11 
  
 heap
  usually, a big chunk of memory provided by the
  OS
  so that applications can divide it by themselves as they wish.
  
  
 malloc()/free() work with the heap.
  24
 ,
  26
 ,
  332
 ,
  540
 ,
  543
 ,
  555
 ,
  557
 ,
  671
 ,
  672 
  
 jump offset
  a part of the JMP or Jcc instruction’s opcode, to be added to the address of the next instruction, and this is how 
  
 the new
  PC
  is calculated. May be negative as well.
  85
 ,
  124
 ,
  887 
  
 kernel mode
  A restrictions-free CPU mode in which the OS kernel and drivers execute. cf.
  user mode
 .
  914 
  
 leaf function
  A function which does not call any other function.
  21
 ,
  26 
  
 link register
  (RISC) A register where the return address is usually stored. This makes it possible to call leaf functions 
 without 
  
 using the stack, i.e., faster.
  26
 ,
  732
 ,
  898
 ,
  899 
  
  
  
 912",NA
Index,".NET,
  677 
  
 AT&T syntax,
  10
 ,
  29 
  
 Buffer Overflow,
  261
 ,
  691 
  
 C language elements 
  
 Pointers,
  59
 ,
  66
 ,
  101
 ,
  368
 ,
  404 
 Post-
 decrement,
  425 
  
 Post-increment,
  425 
  
 Pre-decrement,
  425 
  
 Pre-increment,
  425 
  
 C99,
  100 
  
  
  
 bool,
  290 
  
  
  
 restrict,
  491 
  
  
  
 variable length arrays,
  272 
 const,
  7
 ,
  73 
  
 for,
  174
 ,
  453 
  
 if,
  115
 ,
  144 
  
 return,
  8
 ,
  78
 ,
  99 
  
 switch,
  143
 ,
  144
 ,
  153 
  
 while,
  189 
  
 C standard library 
  
 alloca(),
  27
 ,
  272
 ,
  436
 ,
  683 
  
 assert(),
  277
 ,
  636 
  
 atexit(),
  545 
  
 atoi(),
  475
 ,
  781 
  
 calloc(),
  763 
  
 close(),
  667 
  
 exit(),
  440 
  
 free(),
  436 
  
 fseek(),
  763 
  
 ftell(),
  763 
  
 getenv(),
  782 
  
 localtime(),
  584 
  
 localtime_r(),
  340 
  
 longjmp(),
  145 
  
 malloc(),
  333
 ,
  436 
  
 memchr(),
  889 
  
 memcmp(),
  489
 ,
  638
 ,
  891 
  
 memcpy(),
  10
 ,
  59
 ,
  487
 ,
  888 
  
 memset(),
  485
 ,
  803
 ,
  890 
  
 open(),
  667 
  
 pow(),
  217 
  
 puts(),
  15 
  
 qsort(),
  368 
  
 rand(),
  324
 ,
  629
 ,
  715
 ,
  718
 ,
  751 
 read(),
  
 667 
  
 realloc(),
  436 
  
 scanf(),
  59 
  
 strcmp(),
  483
 ,
  667 
  
 strcpy(),
  10
 ,
  485
 ,
  752 
  
 strlen(),
  189
 ,
  401
 ,
  485
 ,
  502
 ,
  889 
 time(),
  584 
  
 tolower(),
  769 
  
 toupper(),
  510",NA
Bibliography,"[al12] 
  
 [AMD13a] 
 [AMD13b] 
 [App10] 
  
 [ARM12] 
  
 [ARM13a] 
 [ARM13b] 
 [ARM13c] 
 [Bro] 
  
 [Bur] 
  
 [Cli] 
  
 [Cor+09] 
  
 [Dij68]
  
 [Dol13] 
  
 [Dre07] 
  
 [Dre13] 
  
 [Eic11] 
  
 [Fog13a] 
 [Fog13b] 
 [Fog14] 
  
 [haq] 
  
 [IBM00] 
  
 [Int13] 
  
 [Int14] 
  
 [ISO07] 
  
 [ISO13]
  
 Nick Montfort et al. 10 PRINT CHR$(205.5+RND(1)); : GOTO 10. Also available as
  http://go.yurichev. 
 com/17286
 . The MIT Press, 2012.
  
 AMD. AMD64 Architecture Programmer’s Manual. Also available as
  http://go.yurichev.com/17284
 . 2013.
  
 AMD. Software Optimization Guide for AMD Family 16h Processors. Also available as
  http://go.yurichev. 
 com/17285
 . 2013.
  
 Apple. iOS ABI Function Call Guide. Also available as
  http://go.yurichev.com/17276
 . 2010.
  
 ARM. ARM® Architecture Reference Manual, ARMv7-A and ARMv7-R edition. 2012.
  
 ARM. ARM Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile. 2013.
  
 ARM. ELF for the ARM 64-bit Architecture (AArch64). Also available as
  http://go.yurichev.com/17288
 . 2013.
  
 ARM. Procedure Call Standard for the ARM 64-bit Architecture (AArch64). Also available as
  http://go.yurichev. 
 com/17287
 . 2013.
  
 Ralf Brown. The x86 Interrupt List. Also available as
  http://go.yurichev.com/17292
 .
  
 Mike Burrell. “Writing Effcient Itanium 2 Assembly Code”. In: (). Also available as
  http://go.yurichev.com/ 
 17265
 .
  
 Marshall Cline. C++ FAQ. Also available as
  http://go.yurichev.com/17291
 .
  
 Thomas H. Cormen et al. Introduction to Algorithms, Third Edition. 3rd. The MIT Press, 2009. ISBN: 
 0262033844, 9780262033848.
  
 Edsger W. Dijkstra. “Letters to the editor: go to statement considered harmful”. In: Commun. ACM 11.3 (Mar. 
 1968), pp. 147–148. ISSN: 0001-0782. DOI:
  10.1145/362929.362947
 . URL:
  http://go.yurichev.com/ 17299
 .
  
 Stephen Dolan. “mov is Turing-complete”. In: (2013). Also available as
  http://go.yurichev.com/17269
 .
  
 Ulrich Drepper. What Every Programmer Should Know About Memory. Also available as
  http://go.yurichev. 
 com/17341
 . 2007.
  
 Ulrich Drepper. “ELF Handling For Thread-Local Storage”. In: (2013). Also available as
  http://go.yurichev. 
 com/17272
 .
  
 Jens Eickhoff. Onboard Computers, Onboard Software and Satellite Operations: An Introduction. 2011.
  
 Agner Fog. Optimizing software in C++: An optimization guide for Windows, Linux and Mac platforms.
  http:// 
 go.yurichev.com/17279
 . 2013.
  
 Agner Fog. The microarchitecture of Intel, AMD and VIA CPUs / An optimization guide for assembly programmers and 
 co 
 http://go.yurichev.com/17278
 . 2013.
  
 Agner Fog. Calling conventions.
  http://go.yurichev.com/17280
 . 2014.
  
 papasutra of haquebright. “WRITING SHELLCODE FOR IA-64”. In: (). Also available as
  http://go.yurichev. 
 com/17340
 .
  
 IBM. PowerPC(tm) Microprocessor Family: The Programming Environments for 32-Bit Microprocessors. Also 
 avail-able as
  http://go.yurichev.com/17281
 . 2000.
  
 Intel. Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes:1, 2A, 2B, 2C, 3A, 3B, and 3C. 
 Also available as
  http://go.yurichev.com/17283
 . 2013.
  
 Intel. Intel® 64 and IA-32 Architectures Optimization Reference Manual. Also available as
  http://go.yurichev. 
 com/17342
 . September 2014.
  
 ISO. ISO/IEC 9899:TC3 (C C99 standard). Also available as
  http://go.yurichev.com/17274
 . 2007.
  
 ISO. ISO/IEC 14882:2011 (C++ 11 standard). Also available as
  http://go.yurichev.com/17275
 . 2013.
  
 920",NA
