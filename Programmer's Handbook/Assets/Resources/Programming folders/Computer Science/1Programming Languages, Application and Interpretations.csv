Larger Text,Smaller Text,Symbol
Programming Languages: Application ,NA,NA
and Interpretation,"Version Second Edition
  
 Shriram Krishnamurthi
  
 April 14, 2017
  
 1",NA
Contents,"1
  
 Introduction
  
 7
  
 2
  
 1.1
  
 Our Philosophy . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 1.2
  
 The Structure of This Book . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 1.3
  
 The Language of This 
 Book
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 Everything (We Will Say) About Parsing
  
 10
  
 2.1
  
 A Lightweight, Built-In First Half of a Parser
  
 . . . . . . . . . . . . .
  
 10
  
 2.2
  
 A Convenient Shortcut
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 2.3
  
 Types for Parsing . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 3
  
 2.4
  
 Completing the Parser . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 12
  
 2.5
  
 Coda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 A First Look at Interpretation
  
 13
  
 4
  
 3.1
  
 Representing 
 Arithmetic
  
 . . . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 3.2
  
 Writing an Interpreter . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 3.3
  
 Did You Notice? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 3.4
  
 Growing the Language
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 A First Taste of Desugaring
  
 16
  
 5
  
 4.1
  
 Extension: Binary Subtraction
  
 . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 4.2
  
 Extension: Unary Negation . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 Adding Functions to the Language
  
 19
  
 6
  
 5.1
  
 Defining Data Representations . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 5.2
  
 Growing the Interpreter . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
  
 5.3
  
 Substitution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22
  
 5.4
  
 The Interpreter, Resumed . . . . . . . . . . . . . . . . . . . . . . . .
  
 23
  
 5.5
  
 Oh Wait, There’s More! . . . . . . . . . . . . . . . . . . . . . . . . .
  
 25
  
 From Substitution to Environments
  
 25
  
 6.1
  
 Introducing the Environment . . . . . . . . . . . . . . . . . . . . . .
  
 26
  
 6.2
  
 Interpreting with Environments . . . . . . . . . . . . . . . . . . . . .
  
 27
  
 6.3
  
 Deferring Correctly . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 29
  
 6.4
  
 Scope
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 30
  
 7
  
 6.4.1
  
 How Bad Is It?
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 30
  
 6.4.2
  
 The Top-Level Scope . . . . . . . . . . . . . . . . . . . . . .
  
 31
  
 6.5
  
 Exposing the Environment
  
 . . . . . . . . . . . . . . . . . . . . . . .
  
 31
  
 Functions Anywhere
  
 31
  
 7.1
  
 Functions as Expressions and Values . . . . . . . . . . . . . . . . . .
  
 32
  
 7.2
  
 Nested What? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 35
  
 7.3
  
 Implementing Closures . . . . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 7.4
  
 Substitution, Again . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 38
  
 7.5
  
 Sugaring Over Anonymity
  
 . . . . . . . . . . . . . . . . . . . . . . .
  
 39
  
 2",NA
1 ,NA,NA
Introduction,"1.1 Our Philosophy
  
 Please watch the video on YouTube. Someday there will be a textual description 
 here instead.
  
 1.2 The Structure of This Book
  
 Unlike some other textbooks, this one does not follow a top-down narrative. 
 Rather it has the flow of a conversation, with backtracking. We will often build 
 up programs incrementally, just as a pair of programmers would. We will 
 include mistakes, not because I don’t know the answer, but because
  this is the 
 best way for you to learn
 . Including mistakes makes it impossible for you to read 
 passively: you must instead engage with the material, because you can never be 
 sure of the veracity of what you’re reading.
  
 At the end, you’ll always get to the right answer. However, this non-linear 
 path is more frustrating in the short term (you will often be tempted to say, “Just 
 tell me the answer, already!”), and it makes the book a poor reference guide 
 (you can’t open up to a random page and be sure what it says is correct). 
 However, that feeling of frustration is the sensation of learning. I don’t know of a 
 way around it.
  
 At various points you will encounter 
 this: 
  
 Exercise
  
 This is an exercise. Do try it.
  
 This is a traditional textbook exercise. It’s something you need to do on your own. 
 If you’re using this book as part of a course, this may very well have been 
 assigned as homework. In contrast, you will also find exercise-like questions that 
 look like this: 
 Do Now!
  
 There’s an activity here! Do you see it?
  
 When you get to one of these,
  stop
 . Read, think, and formulate an answer 
 before you proceed. You must do this because this is actually an
  exercise
 , but the 
 answer is already in the book—most often in the text immediately following 
 (i.e., in the part you’re reading right now)—or is something you can determine 
 for yourself by running a program. If you just read on, you’ll see the answer 
 without having thought about it (or not see it at all, if the instructions are to run 
 a program), so you will get to neither (a) test your knowledge, nor (b) improve 
 your intuitions. In other words, these are additional, explicit attempts to 
 encourage active learning. Ultimately, however, I can only encourage it; it’s up to 
 you to practice it.
  
 1.3 The Language of This Book
  
 The main programming language used in this book is Racket. Like with all 
 operating systems, however, Racket actually supports a host of programming 
 languages, so you",NA
2 ,NA,NA
Everything (We Will Say) About Parsing,"Parsing is the act of turning an input character stream into a more structured, 
 internal representation. A common internal representation is as a tree, which 
 programs can recursively process. For instance, given the stream 
  
 23 + 5 - 6 
  
 we might want a tree representing addition whose left node represents the 
 number 23 and whose right node represents subtraction of 6 from 5. A
  parser
  is 
 responsible for performing this transformation.
  
 Parsing is a large, complex problem that is far from solved due to the 
 difficulties of ambiguity. For instance, an alternate parse tree for the above input 
 expression might put subtraction at the top and addition below it. We might also 
 want to consider whether this addition operation is commutative and hence 
 whether the order of arguments can be switched. Everything only gets much, 
 much worse when we get to full-fledged programming languages (to say nothing 
 of natural languages).
  
 2.1 A Lightweight, Built-In First Half of a Parser
  
 These problems make parsing a worthy topic in its own right, and entire books, 
 tools, and courses are devoted to it. However, from our perspective parsing is 
 mostly a dis-traction, because we want to study the parts of programming 
 languages that are
  not 
 parsing. We will therefore exploit a handy feature of 
 Racket to manage the transfor-mation of input streams into trees: read. read is 
 tied to the parenthetical form of the language, in that it parses fully (and hence 
 unambiguously) parenthesized terms into a built-in tree form. For instance, 
 running (read) on the parenthesized form of the above input—
  
 (+ 23 (- 5 6))
  
 —will produce a list, whose first element is the symbol ’+, second element is the 
 number 23, and third element is a list; this list’s first element is the symbol ’-, 
 second element is the number 5, and third element is the number 6.
  
 2.2 A Convenient Shortcut
  
 As you know you need to test your programs extensively, which is hard to do 
 when you must manually type terms in over and over again. Fortunately, as you 
 might expect, the parenthetical syntax is integrated deeply into Racket through 
 the mechanism of
  quota-tion
 . That is, ’<expr>—which you saw a moment ago in 
 the above example—acts as if you had run (read) and typed <expr> at the 
 prompt (and, of course, evaluates to the value the (read) would have).
  
 10",NA
3 ,NA,NA
A First Look at Interpretation,"Now that we have a representation of programs, there are many ways in which 
 we might want to manipulate them. We might want to display a program in an 
 attractive way (“pretty-print”), convert into code in some other format 
 (“compilation”), ask whether it obeys certain properties (“verification”), and so 
 on. For now, we’re going to focus on asking what value it corresponds to 
 (“evaluation”—the reduction of programs to 
 values
 ).
  
 Let’s write an evaluator, in the form of an
  interpreter
 , for our arithmetic 
 language. We choose arithmetic first for three reasons: (a) you already know 
 how it works, so we can focus on the mechanics of writing evaluators; (b) it’s 
 contained in every language
  
 13",NA
4 ,NA,NA
A First Taste of Desugaring,"We’ve begun with a very spartan arithmetic language. Let’s look at how we 
 might extend it with more arithmetic operations that can nevertheless be 
 expressed in terms of existing ones. We’ll add just two, because these will suffice 
 to illustrate the point.
  
 16",NA
5 ,NA,NA
Adding Functions to the Language,"Let’s start turning this into a real programming language. We could add 
 intermediate features such as conditionals, but to do almost anything interesting 
 we’re going to need functions or their moral equivalent, so let’s get to it.
  
 Exercise
  
 Add conditionals to your language. You can either add boolean 
 datatypes or, if you want to do something quicker, add a conditional 
 that treats 0 as false and everything else as true.
  
 What are the important test cases you should write?
  
 Imagine, therefore, that we’re modeling a system like DrRacket. The 
 developer defines functions in the definitions window, and uses them in the 
 interactions window. For now, let’s assume all definitions go in the definitions 
 window only (we’ll relax this soon [REF]), and all expressions in the interactions 
 window only. Thus, running a pro-gram simply loads definitions. Because our 
 interpreter corresponds to the interactions window prompt, we’ll therefore 
 assume it is supplied with a set of definitions.
  
 A
  set
  of definitions 
 suggests no 
  
 ordering, which 
  
 means, 
 presumably, any 
 definition can 
 refer to any other.
  
 That’s what I 
 intend here, but 
 when you are 
 designing your 
 own language, be 
  
 sure to think 
 about this.
  
 5.1
  
 Defining Data Representations
  
 To keep things simple, let’s just consider functions of one argument. Here are 
 some Racket examples:
  
 (
 define
  (
 double x
 ) (
 + x x
 ))",NA
6,NA,NA
From Substitution to Environments,"Though we have a working definition of functions, you may feel a slight unease 
 about it. When the interpreter sees an identifier, you might have had a sense 
 that it needs to“look it up”. Not only did it not look up anything, we defined its 
 behavior to be an error! While absolutely correct, this is also a little surprising. 
 More importantly, we write interpreters to
  understand
  and
  explain
  languages, 
 and this implementation might strike you as not doing that, because it doesn’t 
 match our intuition.
  
 25",NA
7,NA,NA
Functions Anywhere,"The introduction to the Scheme programming language definition establishes this 
 de-sign principle:
  
 Programming languages should be designed not by piling feature on 
 top of feature, but by removing the weaknesses and restrictions that 
 make ad-ditional features appear necessary. [REF]
  
 31",NA
8 ,NA,NA
Mutation: Structures and Variables,"It’s time for another 
  
 Which of these is the same?
  
 • f = 3
  
 • o.f = 3
  
 • f = 3
  
 Assuming all three are in Java, the first and third could behave exactly like 
 each other or exactly like the second: it all depends on whether f is a local 
 identifier (such as a parameter) or a field of the object (i.e., the code is really 
 this.f = 3).
  
 In either case, we are asking the evaluator to permanently change the value 
 bound to f. This has important implications for other observers. Until now, for a 
 given set of inputs, a computation always returned the same value. Now, the 
 answer depends on 
 when
  it was invoked: above, it depends on whether it was 
 invoked before or after the value of f was changed. The introduction of time has 
 profound effects on reasoning about programs.
  
 However, there are really two quite different notions of change buried in the 
 uni-form syntax above. Changing the value of a field (o.f = 3 or this.f = 3) is ex-
 tremely different from changing that of an identifier (f = 3 where f is bound 
 inside the method, not by the object). We will explore these in turn. We’ll tackle 
 fields below, and return to identifiers in section 8.2.
  
 8.1 Mutable Structures
  
 8.1.1 A Simple Model of Mutable Structures
  
 Objects are a generalization of structures, as we will soon see [REF]. Therefore, 
 fields in objects are a generalization of fields in structures and to understand 
 mutation, it is mostly (but not entirely! [REF]) sufficient to understand mutable 
 objects. To be even more reductionist, we don’t need a structure to have many 
 fields: a single one will suffice. We call this a
  box
 . In Racket, boxes support just 
 three operations:
  
 box :
  (
 '
 a ->
  (
 boxof
  '
 a
 )) 
  
 unbox :
  ((
 boxof
  '
 a
 )
  ->
  '
 a
 ) 
  
 set-box! :
  ((
 boxof
  '
 a
 )
  '
 a -> void
 )
  
 41",NA
9 ,NA,NA
Recursion and Cycles: Procedures and Data,"Recursion
  is the act of self-reference. When we speak of recursion in 
 programming languages, we may have one of (at least) two meanings in mind: 
 recursion in data, and recursion in control (i.e., of program behavior—that is to 
 say, of functions).
  
 9.1 Recursive and Cyclic Data
  
 Recursion in data can refer to one of two things. It can mean referring to 
 something of the same
  kind
 , or referring to the same
  thing
  itself.
  
 Recursion of the same kind leads to what we traditionally call
  recursive data
 . 
 For instance, a tree is a recursive data structure: each vertex can have multiple 
 children, each of which is itself a tree. But if we write a procedure to traverse the 
 nodes of a tree, we expect it to terminate without having to keep track of which 
 nodes it has already visited. They are finite data structures.
  
 In contrast, a graph is often a
  cyclic
  datum: a node refers to another node, 
 which may refer back to the original one. (Or, for that matter, a node may refer 
 directly to itself.) When we traverse a graph, absent any explicit checks for what 
 we have already visited, we should expect a computation to
  diverge
 , i.e., not 
 terminate. Instead, graph algorithms need a memory of what they have visited 
 to avoid repeating traversals.
  
 Adding recursive data, such as lists and trees, to our language is quite straightfor-
 ward. We mainly require two things:
  
 1. The ability to create compound structures (such as nodes that have 
 references to 
  
 children).
  
 2. The ability to bottom-out the recursion (such as leaves).
  
 Exercise
  
 Add lists and binary trees as built-in datatypes to the programming 
 lan-guage.
  
 Adding cyclic data is more subtle. Consider the simplest form of cyclic datum, a 
 cell referring back to itself:
  
 62",NA
10,NA,NA
Objects,"I cannot hope to 
 do justice to the 
  
 enormous space 
 of object systems.
  
 Please read 
  
 Object-Oriented 
  
 Programming 
  
 Languages: 
  
 Application and 
  
 Interpretation
  by
  
 Éric Tanter, which 
 goes into more 
  
 detail and covers 
  
 topics ignored 
 here.
  
 When a language admits functions as values, it provides developers the most 
 natural way to represent a unit of computation. Suppose a developer wants to 
 parameterize some function f. Any language lets f be parameterized by
  passive
  
 data, such as num-bers and strings. But it is often attractive to parameterize it 
 over
  active
  data: a datum that can
  compute
  an answer, perhaps in response to 
 some information. Furthermore, the function passed to f can—assuming 
 lexically-scoped functions—refer to data from the caller without those data 
 having to be revealed to f, thus providing a foundation for security and privacy. 
 Thus, lexically-scoped functions are central to the design of many secure 
 programming techniques.
  
 While a function is a splendid thing, it suffers from excessive terseness. 
 Sometimes we might want multiple functions to all close over to the same
  
 shared
  data; the sharing especially matters if some of the functions mutate it and 
 expect the others to see the result of those mutations. In such cases, it becomes 
 unwieldly to send just a single function as a parameter; it is more useful to send 
 a group of functions. The recipient then needs a way to choose between the 
 different functions in the group. This grouping of functions, and the means to 
 select one from the group, is the essence of an
  object
 . We are therefore perfectly 
 placed to study objects having covered functions (section 7) and mutation 
 (section 8)—and, it will emerge, recursion (section 9).
  
 Let’s add this notion of objects to our language. Then we’ll flesh it out and 
 grow it, and explore the many dimensions in the design space of objects. We’ll 
 first show how to add objects to the core language, but because we’ll want to 
 prototype many different ideas quickly, we’ll soon shift to a desugaring-based 
 strategy. Which one you use depends on whether you think understanding them 
 is critical to understanding the essence of your language. One way to measure 
 this is how complex your desugaring strategy becomes, and whether by adding 
 some key core language enhancements, you can greatly reduce the complexity of 
 desugaring.
  
 10.1
  
 Objects Without Inheritance
  
 The simplest notion of an object—pretty much the only thing everyone who talks 
 about objects agrees about—is that an object is
  
 • a value, that
  
 • maps names to
  
 • stuff: either other values or “methods”.
  
 67",NA
11,NA,NA
Memory Management,"It’s not free! The 
  
 machine has to 
  
 execute an 
 explicit“pop” 
 instruction to 
 recover that 
 space. As a result, 
 it is not 
 necessarily
  
 cheaper than 
 other memory 
 management 
  
 strategies.
  
 You
 , surely, are 
  
 perfect, but what 
 of your fellow 
  
 developers? And 
 by the way, the 
  
 economics 
  
 discipline has 
 been looking for 
 you.
  
 11.1
  
 Garbage
  
 We use the term
  garbage
  to refer to allocated memory that is no longer 
 necessary. There are two distinct kinds of allocations that a typical 
 programming language run-time system performs. One kind is for the 
 environment; this follows a push-and-pop discipline consistent with the nature 
 of static scope. Returning from a procedure returns that procedure’s allocated 
 environment space for subsequent use, seemingly free of cost. In contrast, 
 allocation on the store has to follow an value’s lifetime, which could outlive that 
 of the scope in which it was created—indeed, it may live forever. Therefore, we 
 need a different strategy for recovering space consumed by store-allocated 
 garbage.
  
 There are many methods for recovering this space, but they largely fall into 
 two camps: manual and automatic. Manual collection depends on the developer 
 being able to know and correctly discard unwated memory. Traditionally, 
 humans have not proven especially good at this (though in some cases they have 
 knowledge a machine might not [REF]). Over several decades, therefore, 
 automated methods have become nearly ubiquitous.
  
 11.2
  
 What is “Correct” Garbage Recovery?
  
 Garbage recovery should neither recover space too early (
 soundness
 ) nor too 
 late (
 com-pleteness
 ). While both can be regarded as flaws, they are not 
 symmetric in their impact: arguably, recovering too early is much worse. That is 
 because if we recover a store lo-cation prematurely, the computation will 
 continue to use it and potentially write other data into it, thereby working with 
 nonsensical data. This leads at the very least to pro-gram incorrectness, but in 
 more extreme situations leads to much worse phenomena such as security 
 violations. In contrast, holding on to memory for too long decreases 
 performance and eventually causes the program to terminate even though, in a 
 pla-tonic sense, it had memory available. This performance degradation and 
 premature termination is always annoying, and in certain mission-critical 
 systems can be deeply problematic, but at least the program does not compute 
 nonsense.
  
 Ideally we would love to have all three: automation, soundness, and 
 completeness. However, we face a classic “pick two” tradeoff. Ideal humans are 
 capable of attaining both soundness and completeness, but in practice rarely 
 achieve either. A computer can offer automation and either soundness or 
 completeness, but computability arguments demonstrate that automation can’t 
 be accompanied by both of the others. In practice, therefore, automated 
 techniques offer soundness, on the grounds that: (a) it does the
  
 81",NA
12 Representation Decisions,"Go back and look again at our interpreter for function as values [REF]. Do you see 
 something curiously non-uniform about it? 
  
 Do Now!
  
 No, really, do. Do you?
  
 Consider how we chose to represent our two different kinds of values: 
 numbers and functions. Ignoring the superficial numV and closV wrappers, focus 
 on the underlying data representations. We represented the interpreted 
 language’s numbers as Racket numbers, but we did not represent the 
 interpreted language’s functions (closures) as Racket functions (closures).
  
 That’s our non-uniformity. It would have been more uniform to use Racket’s 
 rep-resentations for both, or also to
  not
  use Racket’s representation for either. 
 So why did we make this particular choice?
  
 We were trying to illustrate and point, and that point is what we will explore 
 right now.
  
 12.1 Changing Representations
  
 For a moment, let’s explore numbers. Racket’s numbers make a good target for 
 reuse because they are so powerful: we get arbitrary-sized integers (
 bignums
 ), 
 rationals (which benefit from the bignum representation of integers), complex 
 numbers, and so on. Therefore, they can represent most ordinary programming 
 language number systems. However, that doesn’t mean they are what we
  want
 : 
 they could be too little or too much.
  
 • They are too much if what we want is a more restricted number system. 
 For instance, Java prescribes a very specific set of fixed-size 
 representations (e.g., int is specified to be 32-bit). Numbers that fall 
 outside these sets cannot be
  
 87",NA
13 Desugaring as a Language Feature,"We have thus far extensively discussed and relied upon desugaring, but our 
 current desugaring mechanism have been weak. We have actually used desugaring 
 in two
  
 90",NA
14 Control Operations,"The term
  control
  refers to any programming language instruction that causes 
 evalu-ation to proceed, because it “controls” the program counter of the 
 machine. In that sense, even a simple arithmetic expression should qualify as 
 “control”, and operations such as sequential program execution, or function calls 
 and returns, most certainly do. However, in practice we use the term to refer 
 primarily to those operations that cause 
 non-local
  transfer of control, especially 
 beyond that of mere functions and procedures, and the next step up, namely 
 exceptions. We will study such operations in this chapter.
  
 As we study the following control operators, it’s worth remembering that 
 even without them, we still have languages that are Turing-complete, and 
 therefore have no more “power”. Therefore, what control operators do is change 
 and potentially improve the way we express our intent, and therefore enhance 
 the structure of programs. Thus, it pays to being our study by focusing on 
 program structure.
  
 14.1
  
 Control on the Web
  
 Henceforth, 
 we’ll call this 
 our
  
 “addition 
 server”.
  
 You should, of 
  
 course, 
 understand this as 
 a stand-in for 
 more 
 sophisticated 
 applications. For 
  
 instance, the two 
  
 prompts might ask 
 for starting and 
  
 ending points for a 
 trip, and in place 
 of addition we 
 might 
  
 compute a route 
 or compute 
 airfares.
  
 There might even 
 be computation 
  
 between the two 
  
 steps: e.g., after 
  
 entering the first 
  
 city, the airline 
  
 might prompt us 
  
 with choices of 
  
 where it flies from 
 there.
  
 Let us begin our study by examining the structure of Web programs. Consider the 
 following program:
  
 (
 display 
  
  
 (
 +
  (
 read-number
  ""First number""
 ) 
  
   
 (
 read-number
  ""Second number""
 )))
  
 To test these ideas, here’s an implementation of read-number:
  
 (
 define
  (
 read-number
  [
 prompt : string
 ])
  : number 
  
 (
 begin 
  
   
 (
 display prompt
 ) 
  
   
 (
 let
  ([
 v
  (
 read
 )]) 
  
    
 (
 if
  (
 s-exp-number? v
 ) 
  
     
 (
 s-exp->number v
 ) 
  
     
 (
 read-number prompt
 )))))
  
 When run at the console or in DrRacket, this program prompts us for one 
 number, then another, and then displays their sum.
  
 Now suppose we want to run this on a Web server. We immediately 
 encounter a difficulty: the structure of server-side Web programs is such that 
 they generate a single Web page—such as the one asking for the first number—
 and then
  halt
 . As a result, the
  rest of the program
 —which in this case prompts 
 for the second number, then adds them, and then prints that result, is lost.
  
 Do Now!
  
 Why do Web servers behave in such a strange way?
  
 There are at least two reasons for this behavior: one perhaps historical, and 
 the other technical. The historical reason is that Web servers were initially 
 designed to serve
  pages
 , i.e., static content. Any program that ran had to 
 generate its output to a
  
 102",NA
15 Checking Program Invariants Statically: Types,130,NA
Contents,131,NA
16 Checking Program Invariants Dynamically: Con-,NA,NA
tracts,177,NA
Contents,178,NA
17 Alternate Application Semantics,"Long ago [REF], we considered the question of what to substitute when 
 performing application. Now we are ready to consider some alternatives. At the 
 time, we suggested just one alternative; in fact there are many more. To 
 understand this, see whether you can answer this question: 
  
 Which of these is the same?
  
 • (f x (current-seconds))
  
 • (f x (current-seconds))
  
 • (f x (current-seconds))
  
 193",NA
