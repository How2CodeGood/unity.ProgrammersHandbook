Larger Text,Smaller Text,Symbol
Structure and ,NA,NA
Interpretation of Computer ,NA,NA
Programs,NA,NA
second edition ,"Unofficial Texinfo Format 
 2.andresraba5.3",NA
Harold Abelson and ,NA,NA
Gerald Jay Sussman ,NA,NA
"with Julie Sussman, ",NA,NA
foreword by Alan J. Perlis,NA,NA
Contents,"Unofficial Texinfo Format 
  
 ix
  
 Dedication 
  
 xii
  
 Foreword 
  
 xiii
  
 Preface to the Second Edition 
  
 xix
  
 Preface to the First Edition 
  
 xxi
  
 Anowledgments 
  
 xxv
  
 1 
  
 Building Abstractions with Procedures 
  
 1
  
 1.1
  
 e Elements of Programming
  . . . . . . . . . . . . . .  
 6 
 1.1.1 
  
 Expressions
  . . . . . . . . . . . . . . . . . . . .  
 7 
 1.1.2 
  
 Naming and the Environment
  . . . . . . . . . . 
  
 10 
 1.1.3 
  
 Evaluating Combinations 
  . . . . . . . . . . . . 
  
 12 
 1.1.4 
  
 Compound Procedures
  . . . . . . . . . . . . . . 
  
 15 
 1.1.5
  
 e Substitution Model for Procedure Application
  
 18 
 1.1.6 
  
 Conditional Expressions and Predicates 
 . . . . 
  
 22",NA
Unofficial Texinfo Format,"is is the second edition 
  book, from Unofficial Texinfo 
 Format. 
 You are probably reading it in an Info hypertext browser, such 
 as the Info mode of Emacs. You might alternatively be reading it 
 TEX-formaed on your screen or printer, though that would be 
 silly. And, if printed, expensive. 
 e freely-distributed official 
 -and-
  format was first 
 con-verted personally to Unofficial Texinfo Format (
 ) version 
 1 by Lytha Ayth during a long Emacs lovefest weekend in April, 
 2001. 
 e 
  is easier to search than the 
  format. It is also 
 much more accessible to people running on modest computers, 
 such as do-nated ’386-based PCs. A 386 can, in theory, run Linux, 
 Emacs, and a Scheme interpreter simultaneously, but most 386s 
 probably can’t also run both Netscape and the necessary X 
 Window System without pre-maturely introducing budding young 
 underfunded hackers to the con-cept of
  thrashing
 . UTF can also fit 
 uncompressed on a 1.44
  floppy diskee, which may come in 
 handy for installing UTF on PCs that do not have Internet or LAN 
 access. 
 e Texinfo conversion has been a straight transliteration, to 
 the extent possible. Like the TEX-to-
  conversion, this was not 
 without some introduction of breakage. In the case of Unofficial 
 Texinfo Format,",NA
Dedication,NA,NA
T,", in respect and admiration, to the 
 spirit that lives in the computer. 
 “I think that it’s extraordinarily important that we in 
 com-puter science keep fun in computing. When it 
 started out, it was an awful lot of fun. Of course, the 
 paying customers got shaed every now and then, and 
 aer a while we began to take their complaints 
 seriously. We began to feel as if we really were 
 responsible for the successful, error-free perfect use of 
 these machines. I don’t think we are. I think we’re 
 responsible for stretching them, seing them off in 
 new di-rections, and keeping fun in the house. I hope 
 the field of computer science never loses its sense of 
 fun. Above all, I hope we don’t become missionaries. 
 Don’t feel as if you’re Bible salesmen. e world has too 
 many of those already. What you know about 
 computing other people will learn. Don’t feel as if the 
 key to successful computing is only in your hands. 
 What’s in your hands, I think and hope, is in-telligence: 
 the ability to see the machine as more than when you 
 were first led up to it, that you can make it more.” 
 —Alan J. Perlis (April 1, 1922 – February 7, 1990)",NA
Foreword,NA,NA
E ,"gram. Armies, students, and some societies are programmed. 
 An
 , 
 , 
 , psychologists, 
 and parents pro- 
 assault on large problems employs a succession of programs, most 
 of which spring into existence en route. 
 ese programs are rife 
 with is-sues that appear to be particular to the problem at hand. To 
 appreciate programming as an intellectual activity in its own right 
 you must turn to computer programming; you must read and write 
 computer programs—many of them. It doesn’t maer much what 
 the programs are about or what applications they serve. What does 
 maer is how well they per-form and how smoothly they fit with 
 other programs in the creation of still greater programs. 
 e 
 programmer must seek both perfection of part and adequacy of 
 collection. In this book the use of “program” is focused on the 
 creation, execution, and study of programs wrien in a dialect of 
 Lisp for execution on a digital computer. Using Lisp we re-strict or 
 limit not what we may program, but only the notation for our 
 program descriptions. 
 Our traffic with the subject maer of this book involves us with 
 three foci of phenomena: the human mind, collections of computer",NA
Preface to the Second Edition,"Is it possible that soware is not like anything else, 
 that it is meant to be discarded: that the whole point is 
 to always see it as a soap bubble? 
 —Alan J. Perlis",NA
T ,"computer science subject since 1980. We had been teaching 
 this ma-
  
  
  
  
  has been the basis of 
 ’s entry-level 
 terial for four years when the first edition was published, and 
 twelve more years have elapsed until the appearance of this 
 second edition. We are pleased that our work has been widely 
 adopted and incorpo-rated into other texts. We have seen our 
 students take the ideas and programs in this book and build them 
 in as the core of new computer systems and languages. In literal 
 realization of an ancient Talmudic pun, our students have become 
 our builders. We are lucky to have such ca-pable students and such 
 accomplished builders. 
 In preparing this edition, we have incorporated hundreds of 
 clarifi-cations suggested by our own teaching experience and the 
 comments of colleagues at 
  and elsewhere. We have",NA
Preface to the First Edition,"A computer is like a violin. You can imagine a novice 
 try-ing first a phonograph and then a violin. e laer, 
 he says, sounds terrible. at is the argument we have 
 heard from our humanists and most of our computer 
 scientists. Com-puter programs are good, they say, for 
 particular purposes, but they aren’t flexible. Neither is 
 a violin, or a typewriter, until you learn how to use it. 
 —Marvin Minsky, “Why Programming Is a Good 
 Medium for Expressing Poorly-Understood and 
 Sloppily-Formulated Ideas”",NA
“T ,"is the entry-level subject in computer science at the 
 Massachuses 
  S
  
  I
  
  
 C
  P
 ” 
 Institute of Technology. It is required of all students at 
  who 
 major in electrical engineering or in computer science, as one-
 fourth of the“common core curriculum,” which also includes two 
 subjects on circuits and linear systems and a subject on the design 
 of digital systems. We have been involved in the development of 
 this subject since 1978, and we have taught this material in its",NA
Acknowledgments,NA,NA
W ,"develop this book and this curriculum. 
  
  
  
  
  the many people who have 
 helped us 
 Our subject is a clear intellectual descendant of “6.231,” a 
 wonderful subject on programming linguistics and the λ-calculus 
 taught at 
  in the late 1960s by Jack Wozencra and Arthur 
 Evans, Jr. 
 We owe a great debt to Robert Fano, who reorganized 
 ’s 
 intro-ductory curriculum in electrical engineering and computer 
 science to emphasize the principles of engineering design. He led 
 us in starting out on this enterprise and wrote the first set of 
 subject notes from which this book evolved. 
 Much of the style and aesthetics of programming that we try to 
 teach were developed in conjunction with Guy Lewis Steele Jr., who 
 collaborated with Gerald Jay Sussman in the initial development of 
 the Scheme language. In addition, David Turner, Peter Henderson, 
 Dan Fried-man, David Wise, and Will Clinger have taught us many of 
 the tech-niques of the functional programming community that 
 appear in this book. 
 Joel Moses taught us about structuring large systems. His 
 experi-ence with the Macsyma system for symbolic computation",NA
Building Abstractions with ,NA,NA
Procedures,"e acts of the mind, wherein it exerts its power over 
 simple ideas, are chiefly these three: 1. Combining 
 several simple ideas into one compound one, and thus 
 all complex ideas are made. 2. 
 e second is bringing 
 two ideas, whether sim-ple or complex, together, and 
 seing them by one another so as to take a view of 
 them at once, without uniting them into one, by which 
 it gets all its ideas of relations. 3. e third is separating 
 them from all other ideas that accom-pany them in 
 their real existence: this is called abstraction, and thus 
 all its general ideas are made. 
 —John Locke,
  An Essay Concerning Human Understanding 
 (1690)",NA
W ,"putational processes are abstract beings that inhabit 
 computers. 
  
  
  
  the idea of a
  
 computational process
 . Com- 
 As they evolve, processes manipulate other abstract things called
  
 data
 . 
 1",NA
1.1 ,NA,NA
The Elements of Programming,"A powerful programming language is more than just a means for 
 in-structing a computer to perform tasks. e language also serves 
 as a framework within which we organize our ideas about 
 processes. 
 us, when we describe a language, we should pay 
 particular aention to the means that the language provides for 
 combining simple ideas to form more complex ideas. Every 
 powerful language has three mechanisms for accomplishing this: 
 •
  primitive expressions
 , which represent the simplest entities 
 the language is concerned with, 
 •
  means of combination
 , by which compound elements are built 
 from simpler ones, and 
 •
  means of abstraction
 , by which compound elements can be 
 named and manipulated as units. 
 In programming, we deal with two kinds of elements: procedures 
 and data. (Later we will discover that they are really not so 
 distinct.) Infor-mally, data is “stuff” that we want to manipulate, 
 and procedures are descriptions of the rules for manipulating the 
 data. us, any powerful programming language should be able to 
 describe primitive data and primitive procedures and should have 
 methods for combining and ab-stracting procedures and data. 
 In this chapter we will deal only with simple numerical data so 
 that we can focus on the rules for building procedures.
 4
 In later 
 chapters we 
 4
 e characterization of numbers as “simple data” is a barefaced bluff. In fact, 
 the treatment of numbers is one of the trickiest and most confusing aspects of any 
 pro-",NA
1.2 ,NA,NA
Procedures and the Processes They ,NA,NA
Generate,"We have now considered the elements of programming: We have 
 used primitive arithmetic operations, we have combined these 
 operations, and we have abstracted these composite operations by 
 defining them as compound procedures. But that is not enough to 
 enable us to say that we know how to program. Our situation is 
 analogous to that of someone who has learned the rules for how 
 the pieces move in chess but knows nothing of typical openings, 
 tactics, or strategy. Like the novice chess player, we don’t yet know 
 the common paerns of usage in the do-main. We lack the 
 knowledge of which moves are worth making (which procedures 
 are worth defining). We lack the experience to predict the 
 consequences of making a move (executing a procedure). 
 e ability to visualize the consequences of the actions under 
 con-sideration is crucial to becoming an expert programmer, just 
 as it is in any synthetic, creative activity. In becoming an expert 
 photographer, for example, one must learn how to look at a scene 
 and know how dark each region will appear on a print for each 
 possible choice of exposure and development conditions. Only 
 then can one reason backward, plan-ning framing, lighting, 
 exposure, and development to obtain the desired effects. So it is 
 with programming, where we are planning the course of action to 
 be taken by a process and where we control the process by means 
 of a program. To become experts, we must learn to visualize the 
 processes generated by various types of procedures. Only aer we 
 have developed such a skill can we learn to reliably construct 
 programs that exhibit the desired behavior. 
 A procedure is a paern for the
  local evolution
  of a 
 computational process. It specifies how each stage of the process is 
 built upon the previ-ous stage. We would like to be able to make 
 statements about the overall,",NA
1.3 ,NA,NA
Formulating Abstractions ,NA,NA
with Higher-Order Procedures,"We have seen that procedures are, in effect, abstractions that 
 describe compound operations on numbers independent of the 
 particular num-bers. For example, when we",NA
Building Abstractions with Data,"We now come to the decisive step of mathematical 
 abstrac-tion: we forget about what the symbols stand 
 for. . . .[e mathematician] need not be idle; there are 
 many operations which he may carry out with these 
 symbols, without ever having to look at the things they 
 stand for. 
 —Hermann Weyl,
  e Mathematical Way of inking",NA
W ,"on the role of procedures in program design. We saw how 
 to 
  
  Chapter 1
  on computational 
 processes and 
 use primitive data (numbers) and primitive operations (arithmetic 
 op-erations), how to combine procedures to form compound 
 procedures through composition, conditionals, and the use of 
 parameters, and how to abstract procedures by using
  define
 . We 
 saw that a procedure can be regarded as a paern for the local 
 evolution of a process, and we classified, reasoned about, and",NA
2.1 ,NA,NA
Introduction to Data Abstraction,"In
  Section 1.1.8
 , we noted that a procedure used as an element in 
 creat-ing a more complex procedure could be regarded not only as 
 a collection of particular operations but also as a procedural 
 abstraction. 
 at is, the details of how the procedure was 
 implemented could be suppressed, and the particular procedure 
 itself could be replaced by any other pro-cedure with the same 
 overall behavior. In other words, we could make an abstraction 
 that would separate the way the procedure would be used from 
 the details of how the procedure would be implemented in terms 
 of more primitive procedures. e analogous notion for compound 
 data is called
  data abstraction
 . Data abstraction is a methodology 
 that enables",NA
2.2 ,NA,NA
Hierarchical Data and the Closure Property,"As we have seen, pairs provide a primitive “glue” that we can use 
 to construct compound data objects.
  Figure 2.2
  shows a standard 
 way to visualize a pair—in this case, the pair formed by
  (cons 1 2)
 . In 
 this representation, which is called
  box-and-pointer notation
 , each 
 object is shown as a
  pointer
  to a box. e box for a primitive object 
 contains a representation of the object. For example, the box for a 
 number contains a numeral. e box for a pair is actually a double 
 box, the le part con-taining (a pointer to) the
  car
  of the pair and 
 the right part containing the
  cdr
 . 
 We have already seen that
  cons
  can be used to combine not only 
 numbers but pairs as well. (You made use of this fact, or should 
 have, in doing
  Exercise 2.2
  and
  Exercise 2.3
 .) As a consequence, 
 pairs pro-vide a universal building block from which we can 
 construct all sorts of",NA
2.3 ,NA,NA
Symbolic Data,"All the compound data objects we have used so far were 
 constructed ul-timately from numbers. In this section we extend 
 the representational capability of our language by introducing the 
 ability to work with arbi-trary symbols as data. 
 2.3.1
  otation
  
 If we can form compound data using symbols, we can have lists 
 such as 
 (
 a b c d
 ) 
  
 (23 45 17) 
  
 ((
 Norah
  12) (
 Molly
  9) (
 Anna
  7) (
 Lauren
  6) (
 Charlotte
  4))
  
 Lists containing symbols can look just like the expressions of our 
 lan-guage:",NA
2.4 ,NA,NA
Multiple Representations for Abstract Data,"We have introduced data abstraction, a methodology for 
 structuring systems in such a way that much of a program can be 
 specified indepen-dent of the choices involved in implementing the 
 data objects that the program manipulates. For example, we saw in
  
 Section 2.1.1
  how to sep-arate the task of designing a program that 
 uses rational numbers from the task of implementing rational 
 numbers in terms of the computer language’s primitive 
 mechanisms for constructing compound data. e key idea was to 
 erect an abstraction barrier—in this case, the selec-tors and 
 constructors for rational numbers (
 make-rat
 ,
  numer
 ,
  denom
 )—that 
 isolates the way rational numbers are used from their underlying 
 representation in terms of list structure. A similar abstraction 
 barrier isolates the details of the procedures that perform rational 
 arithmetic (
 add-rat
 ,
  sub-rat
 ,
  mul-rat
 , and
  div-rat
 ) from the “higher-level” 
 pro-cedures that use rational numbers. e resulting program has 
 the struc-ture shown in
  Figure 2.1
 . 
 ese data-abstraction barriers are powerful tools for 
 controlling",NA
2.5 ,NA,NA
Systems with Generic Operations,"In the previous section, we saw how to design systems in which 
 data objects can be represented in more than one way. e key idea 
 is to link the code that specifies the data operations to the several 
 represen-tations by means of generic interface procedures. Now 
 we will see how to use this same idea not only to define operations 
 that are generic over different representations but also to define 
 operations that are generic over different kinds of arguments. We 
 have already seen several dif-ferent packages of arithmetic 
 operations: the primitive arithmetic (
 +
 ,
  -
 , 
 *
 ,
  /
 ) built into our 
 language, the rational-number arithmetic (
 add-rat
 , 
 sub-rat
 ,
  mul-rat
 ,
  div-
 rat
 ) of
  Section 2.1.1
 , and the complex-number arithmetic that we 
 implemented in
  Section 2.4.3
 . We will now use data-directed 
 techniques to construct a package of arithmetic operations that 
 incorporates all the arithmetic packages we have already 
 constructed. 
 Figure 2.23
  shows the structure of the system we shall build. 
 Notice the abstraction barriers. From the perspective of someone 
 using “num-bers,” there is a single procedure
  add
  that operates on 
 whatever num-bers are supplied.
  Add
  is part of a generic interface 
 that allows the sep-arate ordinary-arithmetic, rational-arithmetic, 
 and complex-arithmetic packages to be accessed uniformly by 
 programs that use numbers. Any individual arithmetic package 
 (such as the complex package) may it-self be accessed through 
 generic procedures (such as
  add-complex
 ) that combine packages 
 designed for different representations (such as rect-angular and 
 polar). Moreover, the structure of the system is additive, so that 
 one can design the individual arithmetic packages separately and 
 combine them to produce a generic arithmetic system.",NA
"Modularity, Objects, and State","Mεταβάλλον ὰναπαύεται 
 (Even while it changes, it stands 
 still.)—Heraclitus 
 Plus ça change, plus c’est la même 
 chose.—Alphonse Karr",NA
T ,"programs are made. We saw how primitive procedures and 
 primi-
  
  
  introduced the basic 
 elements from which 
 tive data are combined to construct compound entities, and we 
 learned that abstraction is vital in helping us to cope with the 
 complexity of large systems. But these tools are not sufficient for 
 designing programs. Effective program synthesis also requires 
 organizational principles that can guide us in formulating the",NA
3.1 ,NA,NA
Assignment and Local State,"We ordinarily view the world as populated by independent 
 objects, each of which has a state that changes over time. An object 
 is said to “have state” if its behavior is influenced by its history. A 
 bank account, for example, has state in that the answer to the 
 question “Can I withdraw $100?” depends upon the history of 
 deposit and withdrawal transac-tions. We can characterize an 
 object’s state by one or more
  state vari-ables
 , which among them 
 maintain enough information about history to determine the 
 object’s current behavior. In a simple banking system, we could 
 characterize the state of an account by a current balance rather 
 than by remembering the entire history of account transactions. 
 In a system composed of many objects, the objects are rarely 
 com-pletely independent. Each may influence the states of others 
 through interactions, which serve to couple the state variables of 
 one object to those of other objects. Indeed, the view that a system 
 is composed of separate objects is most useful when the state 
 variables of the system can be grouped into closely coupled 
 subsystems that are only loosely coupled to other subsystems. 
 is view of a system can be a powerful framework for 
 organizing computational models of the system. For such a model 
 to be modular, it should be decomposed into computational 
 objects that model the actual",NA
3.2 ,NA,NA
The Environment Model of Evaluation,"When we introduced compound procedures in
  Chapter 1
 , we used 
 the substitution model of evaluation (
 Section 1.1.5
 ) to define what 
 is meant by applying a procedure to arguments: 
 • To apply a compound procedure to arguments, evaluate the 
 body of the procedure with each formal parameter replaced 
 by the cor-responding argument. 
 Once we admit assignment into our programming language, such a 
 def-inition is no longer adequate. In particular,
  Section 3.1.3
  argued 
 that, in",NA
3.3 ,NA,NA
Modeling with Mutable Data,"Chapter 2 dealt with compound data as a means for constructing 
 com-putational objects that have several parts, in order to model 
 real-world objects that have several aspects. In that chapter we 
 introduced the dis-cipline of data abstraction, according to which 
 data structures are spec-ified in terms of constructors, which 
 create data objects, and selectors, which access the parts of 
 compound data objects. But we now know that there is another 
 aspect of data that
  Chapter 2
  did not address. e desire to model 
 systems composed of objects that have changing state leads us to 
 the need to modify compound data objects, as well as to con-struct 
 and select from them. In order to model compound objects with 
 changing state, we will design data abstractions to include, in 
 addition to selectors and constructors, operations called
  mutators
 , 
 which mod-ify data objects. For instance, modeling a banking 
 system requires us to change account balances. 
 us, a data 
 structure for representing bank accounts might admit an operation 
 (
 set-balance!
  ⟨
 account
 ⟩ ⟨
 new-value
 ⟩
 ) 
  
 that changes the balance of the designated account to the 
 designated new value. Data objects for which mutators are defined 
 are known as 
 mutable data objects
 . 
 Chapter 2
  introduced pairs as a general-purpose “glue” for 
 synthe-sizing compound data. We begin this section by defining 
 basic mutators for pairs, so that pairs can serve as building blocks 
 for constructing mu-table data objects. 
 ese mutators greatly 
 enhance the representational power of pairs, enabling us to build 
 data structures other than the se-quences and trees that we 
 worked with in
  Section 2.2
 . We also present some examples of 
 simulations in which complex systems are modeled as collections 
 of objects with local state.",NA
3.4 ,NA,NA
Concurrency: Time Is of the Essence,"We’ve seen the power of computational objects with local state as 
 tools for modeling. Yet, as
  Section 3.1.3
  warned, this power 
 extracts a price: the loss of referential transparency, giving rise to 
 a thicket of questions about sameness and change, and the need to 
 abandon the substitution model of evaluation in favor of the more 
 intricate environment model. 
 e central issue lurking beneath the complexity of state, 
 sameness, and change is that by introducing assignment we are 
 forced to admit 
 time
  into our computational models. Before we 
 introduced assignment, all our programs were timeless, in the 
 sense that any expression that has a value always has the same 
 value. In contrast, recall the example of modeling withdrawals 
 from a bank account and returning the resulting balance, 
 introduced at the beginning of
  Section 3.1.1
 : 
 (
 withdraw
  25)
  
 75 
  
 (
 withdraw
  25)
  
 50
  
 Since Lisp allows us to return compound objects as values of procedures, we can 
 trans-form our imperative-style constraint language into an expression-oriented 
 style as shown in this exercise. In languages that are impoverished in handling 
 compound ob-jects, such as Algol, Basic, and Pascal (unless one explicitly uses 
 Pascal pointer vari-ables), one is usually stuck with the imperative style when 
 manipulating compound objects. Given the advantage of the expression-oriented 
 format, one might ask if there is any reason to have implemented the system in 
 imperative style, as we did in this section. One reason is that the non-expression-
 oriented constraint language provides a handle on constraint objects (e.g., the 
 value of the
  adder
  procedure) as well as on connector objects. is is useful if we 
 wish to extend the system with new operations that communicate with 
 constraints directly rather than only indirectly via operations on connectors. 
 Although it is easy to implement the expression-oriented style in terms of the 
 imperative implementation, it is very difficult to do the converse.",NA
3.5 ,NA,NA
Streams,"We’ve gained a good understanding of assignment as a tool in 
 modeling, as well as an appreciation of the complex problems that 
 assignment raises. It is time to ask whether we could have gone 
 about things in a different way, so as to avoid some of these 
 problems. In this section, 
 50
 is may seem like a strange point of view, but there are systems that work 
 this way. International charges to credit-card accounts, for example, are normally 
 cleared on a per-country basis, and the charges made in different countries are 
 periodically reconciled. 
 us the account balance may be different in different 
 countries.
  
 51
 For distributed systems, this perspective was pursued by
  Lamport (1978)
 , 
 who showed how to use communication to establish “global clocks” that can be 
 used to establish orderings on events in distributed systems.",NA
Metalinguistic Abstraction,". . . It’s in words that the magic is—Abracadabra, Open 
 Sesame, and the rest—but the magic words in one story 
 aren’t magi-cal in the next. e real magic is to understand 
 which words work, and when, and for what; the trick is to 
 learn the trick. 
 . . . And those words are made from the leers of our 
 alpha-bet: a couple-dozen squiggles we can draw with 
 the pen.is is the key! And the treasure, too, if we can 
 only get our hands on it! It’s as if—as if the key to the 
 treasure
  is
  the treasure! 
 —John Barth,
  Chimera",NA
I ,"mers control the complexity of their designs with the same 
 general  
  
  
  
  
 , we have seen that 
 expert program- 
 techniques used by designers of all complex systems. ey combine 
 primitive elements to form compound objects, they abstract 
 compound 
 487",NA
4.1 ,NA,NA
The Metacircular Evaluator,"Our evaluator for Lisp will be implemented as a Lisp program. It 
 may seem circular to think about evaluating Lisp programs using 
 an evalua-tor that is itself implemented in Lisp. However, 
 evaluation is a process, so it is appropriate to describe the 
 evaluation process using Lisp, which, aer all, is our tool for 
 describing processes.
 3
 An evaluator that is writ-ten in the same 
 language that it evaluates is said to be
  metacircular
 . 
 e metacircular evaluator is essentially a Scheme formulation 
 of the environment model of evaluation described in
  Section 3.2
 . 
 Recall that the model has two basic parts: 
 1. To evaluate a combination (a compound expression other 
 than a special form), evaluate the subexpressions and then 
 apply the value of the operator subexpression to the values 
 of the operand subexpressions. 
 2. To apply a compound procedure to a set of arguments, 
 evaluate the body of the procedure in a new environment. To 
 construct 
 3
 Even so, there will remain important aspects of the evaluation process that 
 are not elucidated by our evaluator. e most important of these are the detailed 
 mechanisms by which procedures call other procedures and return values to their 
 callers. We will address these issues in
  Chapter 5
 , where we take a closer look at 
 the evaluation process by implementing the evaluator as a simple register 
 machine.",NA
4.2 ,NA,NA
Variations on a Scheme — Lazy Evaluation,"Now that we have an evaluator expressed as a Lisp program, we 
 can experiment with alternative choices in language design simply 
 by mod-ifying the evaluator. Indeed, new languages are oen 
 invented by first writing an evaluator that embeds the new 
 language within an exist-ing high-level language. For example, if 
 we wish to discuss some aspect of a proposed modification to Lisp 
 with another member of the Lisp community, we can supply an 
 evaluator that embodies the change. 
 e recipient can then 
 experiment with the new evaluator and send back comments as 
 further modifications. Not only does the high-level imple-
 mentation base make it easier to test and debug the evaluator; in 
 addi-tion, the embedding enables the designer to snarf
 31
 features 
 from the underlying language, just as our embedded Lisp evaluator 
 uses primi-tives and control structure from the underlying Lisp. 
 Only later (if ever) need the designer go to the trouble of building a 
 complete implemen-tation in a low-level language or in hardware. 
 In this section and the next we explore some variations on Scheme 
 that provide significant ad-ditional expressive power. 
 31
 Snarf: “To grab, especially a large document or file for the purpose of using it 
 ei-ther with or without the owner’s permission.” Snarf down: “To snarf, 
 sometimes with the connotation of absorbing, processing, or understanding.” 
 (ese definitions were snarfed from
  Steele et al. 1983
 . See also
  Raymond 1993
 .)
  
 541",NA
4.3 ,NA,NA
Variations on a Scheme — Nondeterministic ,NA,NA
Computing,"In this section, we extend the Scheme evaluator to support a 
 program-ming paradigm called
  nondeterministic computing
  by 
 building into the evaluator a facility to support automatic search. 
 is is a much more profound change to the language than the 
 introduction of lazy evalua-tion in
  Section 4.2
 . 
 Nondeterministic computing, like stream processing, is useful 
 for“generate and test” applications. Consider the task of starting 
 with two lists of positive integers and finding a pair of integers—
 one from the first list and one from the second list—whose sum is 
 prime. We saw how to handle this with finite sequence operations 
 in
  Section 2.2.3
  and with infinite streams in
  Section 3.5.3
 . Our 
 approach was to generate the se-quence of all possible pairs and 
 filter these to select the pairs whose sum is prime. Whether we 
 actually generate the entire sequence of pairs first as in
  Chapter 2
 , 
 or interleave the generating and filtering as in
  Chap-ter 3
 , is 
 immaterial to the essential image of how the computation is 
 organized. 
 e nondeterministic approach evokes a different image. 
 Imagine simply that we choose (in some way) a number from the 
 first list and a number from the second list and require (using 
 some mechanism) that their sum be prime. 
 is is expressed by 
 following procedure: 
 (
 define
  (
 prime-sum-pair list1 list2
 ) 
  
 (
 let
  ((
 a
  
 (
 an-element-of list1
 )) 
  
  
  
 (
 b
  (
 an-element-of list2
 ))) 
   
 (
 require
  
 (
 prime?
  (+
  a b
 ))) 
  
   
 (
 list
  a b
 )))",NA
4.4 ,NA,NA
Logic Programming,"In
  Chapter 1
  we stressed that computer science deals with 
 imperative (how to) knowledge, whereas mathematics deals with 
 declarative (what is) knowledge. Indeed, programming languages 
 require that the pro-grammer express knowledge in a form that 
 indicates the step-by-step methods for solving particular 
 problems. On the other hand, high-level 
 594",NA
Computing with Register Machines,"My aim is to show that the heavenly machine is not a 
 kind of divine, live being, but a kind of clockwork (and 
 he who believes that a clock has soul aributes the 
 maker’s glory to the work), insofar as nearly all the 
 manifold motions are caused by a most simple and 
 material force, just as all mo-tions of the clock are 
 caused by a single weight. 
 —Johannes Kepler (leer to Herwart von Hohenburg, 1605)",NA
W ,"cesses in terms of procedures wrien in Lisp. To explain the 
 mean- 
  
  
  by studying processes and by 
 describing pro- 
 ings of these procedures, we used a succession of models of 
 evaluation: the substitution model of
  Chapter 1
 , the environment 
 model of
  Chap-ter 3
 , and the metacircular evaluator of
  Chapter 4
 .",NA
5.1 ,NA,NA
Designing Register Machines,"To design a register machine, we must design its
  data paths
  
 (registers and operations) and the
  controller
  that sequences these 
 operations. To illustrate the design of a simple register machine, 
 let us examine Eu-clid’s Algorithm, which is used to compute the 
 greatest common divi-sor (
 ) of two integers. As we saw in
  
 Section 1.2.5
 , Euclid’s Algorithm can be carried out by an iterative 
 process, as specified by the following procedure:",NA
5.2 ,NA,NA
A Register-Machine Simulator,"In order to gain a good understanding of the design of register 
 machines, we must test the machines we design to see if they 
 perform as expected. One way to test a design is to hand-simulate 
 the operation of the con-troller, as in
  Exercise 5.5
 . But this is 
 extremely tedious for all but the simplest machines. In this section 
 we construct a simulator for machines described in the register-
 machine language. 
 e simulator is a Scheme program with four 
 interface procedures. 
 e first uses a description of a register 
 machine to construct a model of the machine (a data structure 
 whose parts correspond to the parts of the machine to be 
 simulated), and the other three allow us to simulate the machine 
 by manipulating the model: 
 (
 make-machine
  ⟨
 register-names
 ⟩ ⟨
 operations
 ⟩ ⟨
 controller
 ⟩
 )
  
 constructs and returns a model of the machine with the 
 given registers, operations, and controller. 
 (
 set-register-contents!
  ⟨
 machine-model
 ⟩
  
  
 ⟨
 register-name
 ⟩
  
  
 ⟨
 value
 ⟩
 ) 
  
 stores a value in a simulated register in the given 
 machine. 
 (
 get-register-contents
  ⟨
 machine-model
 ⟩ ⟨
 register-name
 ⟩
 )
  
 returns the contents of a simulated register in the given 
 machine. 
 (
 start
  ⟨
 machine-model
 ⟩
 ) 
  
 simulates the execution of the given machine, starting 
 from the beginning of the controller sequence and 
 stopping when it reaches the end of the sequence.",NA
5.3 ,NA,NA
Storage Allocation and Garbage Collection,"In
  Section 5.4
 , we will show how to implement a Scheme evaluator 
 as a register machine. In order to simplify the discussion, we will 
 assume that our register machines can be equipped with a
  list-
 structured mem-ory
 , in which the basic operations for manipulating 
 list-structured data are primitive. Postulating the existence of such 
 a memory is a useful abstraction when one is focusing on the 
 mechanisms of control in a Scheme interpreter, but this does not 
 reflect a realistic view of the ac-tual primitive data operations of 
 contemporary computers. To obtain a more complete picture of 
 how a Lisp system operates, we must inves-tigate how list 
 structure can be represented in a way that is compatible with 
 conventional computer memories. 
 ere are two considerations in implementing list structure. e 
 first is purely an issue of representation: how to represent the 
 “box-and-pointer” structure of Lisp pairs, using only the storage 
 and addressing capabilities of typical computer memories. 
 e 
 second issue concerns the management of memory as a 
 computation proceeds. 
 e operation of a Lisp system depends 
 crucially on the ability to continually create new data objects. ese 
 include objects that are explicitly created by the Lisp procedures 
 being interpreted as well as structures created by the in-terpreter 
 itself, such as environments and argument lists. Although the 
 constant creation of new data objects would pose no problem on a 
 com-puter with an infinite amount of rapidly addressable memory, 
 computer memories are available only in finite sizes (more’s the 
 pity). Lisp sys-tems thus provide an
  automatic storage allocation
  
 facility to support the illusion of an infinite memory. When a data 
 object is no longer needed, the memory allocated to it is 
 automatically recycled and used to con-struct new data objects. 
 ere are various techniques for providing such",NA
5.4 ,NA,NA
The Explicit-Control Evaluator,"In
  Section 5.1
  we saw how to transform simple Scheme programs 
 into descriptions of register machines. We will now perform this 
 transforma-tion on a more complex program, the metacircular 
 evaluator of
  Section 4.1.1
 –
 Section 4.1.4
 , which shows how the 
 behavior of a Scheme inter-preter can be described in terms of the 
 procedures
  eval
  and
  apply
 . 
 e 
 explicit-control evaluator
  that we 
 develop in this section shows how the underlying procedure-
 calling and argument-passing mechanisms used in the evaluation 
 process can be described in terms of operations on reg-isters and 
 stacks. In addition, the explicit-control evaluator can serve as an 
 implementation of a Scheme interpreter, wrien in a language that 
 is very similar to the native machine language of conventional 
 comput-ers. e evaluator can be executed by the register-machine 
 simulator of
  Section 5.2
 . Alternatively, it can be used as a starting 
 point for build-ing a machine-language implementation of a 
 Scheme evaluator, or even a special-purpose machine for 
 evaluating Scheme expressions.
  Figure 5.16
  shows such a 
 hardware implementation: a silicon chip that acts as an evaluator 
 for Scheme. 
 e chip designers started with the data-path and 
 controller specifications for a register machine similar to the 
 evalu-ator described in this section and used design automation 
 programs to construct the integrated-circuit layout.
 19
  
 Registers and operations
  
 In designing the explicit-control evaluator, we must specify the 
 opera-tions to be used in our register machine. We described the 
 metacircular evaluator in terms of abstract syntax, using 
 procedures such as
  quoted?
  
 19
 See
  Batali et al. 1982
  for more information on the chip and the method by which 
 it was designed.",NA
5.5 ,NA,NA
Compilation,"e explicit-control evaluator of
  Section 5.4
  is a register machine 
 whose controller interprets Scheme programs. In this section we 
 will see how to run Scheme programs on a register machine whose 
 controller is not a Scheme interpreter. 
  
 e explicit-control evaluator machine is universal—it can carry 
 out any computational process that can be described in Scheme. e 
 evalu-ator’s controller orchestrates the use of its data paths to 
 perform the de-sired computation. us, the evaluator’s data paths 
 are universal: ey are sufficient to perform any computation we 
 desire, given an appro-priate controller.
 33 
  
  
 Commercial general-purpose computers are register machines 
 or- 
 33
 is is a theoretical statement. We are not claiming that the evaluator’s data 
 paths are a particularly convenient or efficient set of data paths for a general-
 purpose computer. For example, they are not very good for implementing high-
 performance floating-point calculations or calculations that intensively 
 manipulate bit vectors.",NA
References,"Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William 
 McAllis-ter, Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 
 1992. e Supercomputer Toolkit: A general framework for special-
 purpose com-puting.
  International Journal of High-Speed Electronics
  
 3(3): 337-361.
  (Onl) 
  
 Allen, John. 1978.
  Anatomy of Lisp
 . New York: 
 McGraw-Hill. 
  
  X3.226-1994.
  American National Standard for Information 
 Sys-tems—Programming Language—Common Lisp
 . 
  
 Appel, Andrew W. 1987. Garbage collection can be faster than 
 stack allocation.
  Information Processing Leers
  25(4): 275-279.
  
 (Online) 
  Backus, John. 1978. Can programming be liberated from the 
 von Neumann style?
  Communications of the 
  21(8): 613-641.
  
 (Online) 
  Baker, Henry G., Jr. 1978. List processing in real time on a 
 serial computer.
  Communications of the 
  21(4): 280-293.
  (Online) 
  
  
 Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, 
 and Daniel Weise. 1982. e Scheme-81 architecture—System and 
 chip. In 
 Proceedings of the 
  Conference on Advanced Research in 
 , edited by Paul Penfield, Jr. Dedham, MA: Artech House. 
 Borning, Alan. 1977. ingLab—An object-oriented system for 
 build-ing simulations using constraints. In
  Proceedings of the 5th 
 International Joint Conference on Artificial Intelligence
 .
  (Online)
  
 834",NA
List of Exercises,"Chapter 1
  
 1.1
  
 1.2
  
 1.3
  
 1.4
  
 1.5
  
 1.6
  
 1.7
  
 1.8
  
 1.9
  
 1.10
  
 1.11
  
 1.12
  
 1.13
  
 1.14
  
 1.15
  
 1.16
  
 1.17
  
 1.18
  
 1.19
  
 1.20
  
 1.21
  
 1.22
  
 1.23
  
 1.24
  
 1.25
  
 1.26
  
 1.27
  
 1.28
  
 1.29
  
 1.30
  
 1.31
  
 1.32
  
 1.33
  
 1.34
  
 1.35
  
 1.36
  
 1.37
  
 1.38
  
 1.39
  
 1.40
  
 1.41
  
 1.42
  
 1.43
  
 1.44
  
 1.45
  
 1.46
  
 Chapter 2
  
 2.1
  
 2.2
  
 2.3
  
 2.4
  
 2.5
  
 2.6
  
 2.7
  
 2.8
  
 2.9
  
 2.10
  
 2.11
  
 2.12
  
 2.13
  
 2.14
  
 2.15
  
 2.16
  
 2.17
  
 2.18
  
 2.19
  
 2.20
  
 2.21
  
 2.22
  
 2.23
  
 2.24
  
 2.25
  
 2.26
  
 2.27
  
 2.28
  
 2.29
  
 2.30
  
 2.31
  
 2.32
  
 2.33
  
 2.34
  
 2.35
  
 2.36
  
 2.37
  
 2.38
  
 2.39
  
 2.40
  
 2.41
  
 2.42
  
 2.43
  
 2.44
  
 2.45
  
 2.46
  
 2.47
  
 2.48
  
 2.49
  
 2.50
  
 2.51
  
 2.52
  
 2.53
  
 2.54
  
 2.55
  
 2.56
  
 2.57
  
 2.58
  
 2.59
  
 2.60
  
 2.61
  
 2.62
  
 2.63
  
 2.64
  
 2.65
  
 2.66
  
 2.67
  
 2.68
  
 2.69
  
 2.70
  
 2.71
  
 2.72
  
 2.73
  
 2.74
  
 2.75
  
 2.76
  
 2.77
  
 2.78
  
 2.79
  
 2.80
  
 2.81
  
 2.82
  
 2.83
  
 2.84
  
 2.85
  
 2.86
  
 2.87
  
 2.88
  
 2.89
  
 2.90
  
 2.91
  
 2.92
  
 2.93
  
 2.94
  
 2.95
  
 2.96
  
 2.97
  
 844",NA
List of Figures,"Chapter 1
  
 1.1
  
 1.2
  
 1.3
  
 1.4
  
 1.5
  
 Chapter 2
  
 2.1
  
 2.2
  
 2.3
  
 2.4
  
 2.5
  
 2.6
  
 2.7
  
 2.8
  
 2.9
  
 2.10
  
 2.11
  
 2.12
  
 2.13
  
 2.14
  
 2.15
  
 2.16
  
 2.17
  
 2.18
  
 2.19
  
 2.20
  
 2.21
  
 2.22
  
 2.23
  
 2.24
  
 2.25
  
 2.26
  
 Chapter 3
  
 3.1
  
 3.2
  
 3.3
  
 3.4
  
 3.5
  
 3.6
  
 3.7
  
 3.8
  
 3.9
  
 3.10
  
 3.11
  
 3.12
  
 3.13
  
 3.14
  
 3.15
  
 3.16
  
 3.17
  
 3.18
  
 3.19
  
 3.20
  
 3.21
  
 3.22
  
 3.23
  
 3.24
  
 3.25
  
 3.26
  
 3.27
  
 3.28
  
 3.29
  
 3.30
  
 3.31
  
 3.32
  
 3.33
  
 3.34
  
 3.35
  
 3.36
  
 3.37
  
 3.38
  
 Chapter 4
  
 4.1
  
 4.2
  
 4.3
  
 4.4
  
 4.5
  
 4.6
  
 846",NA
Index,"Any inaccuracies in this index may be explained by the fact 
 that it has been prepared with the help of a computer. 
 —Donald E. Knuth,
  Fundamental Algorithms
  
 (Volume 1 of
  e Art of Computer Programming
 ) 
 Symbols
  
 k
 -term finite continued fraction . . .
  
 95 
 n
 -fold smoothed function . . . . . . . .
  
 104
  
 A
  
 abstract models . . . . . . . . . . . . . . . . .
  
 123 
 abstract syntax . . . . . . . . . . . . . . . . 
 . .
  495 
 abstraction barriers . . . . . . . . .
  
 111
 ,
  119 
 accumulator . . . . . . . . . . . . . . 
 . .
  156
 ,
  303 
 acquired . . . . . . . . . . . . . . . . 
 . . . . . . . .
  421 
 action . . . . . . . . . . . . . . . . . 
 . . . . . . . . .
  677
  
 and-gate . . . . . . . . . . . . . . . . . . . . . . . .
  
 370 
 applicative-order . . . . . . . . . . . . . . 
 . .
  542 
 applicative-order evaluation . 
 . . . . . .
  21 
 arbiter. . . . . . . . . . . . . . . . . . . . 
 . . . . . .
 424 
 arguments . . . . . . . . . . . . . . . 
 . . . . . . . . .
  8 
 assembler. . . . . . . . . . . . . . . 
 . . . . . . . .
 698 
 assertions. . . . . . . . . . . . . . 
 . . . . . . . . .
 600 
 assignment operator . . 
 . . . . . . . . . . .
  297 
 atomically . . . . . . . . . . 
 . . . . . . . . . . . .
  423 
 automatic storage 
 allocation. . . . . .
 723 
 average 
 damping . . . . . . . . . . . . . . . . .
  94
  
 additive . . . . . . . . . . . . . . . . . . . . . . . .
  243 
 additively . . . . . . . . . . . . . . . . . .
  112
 ,
  
 230
  
 B
  
  
 address . . . . . . . . . . . . . . . . . . . . . . . . .
  
 724 
 address arithmetic . . . . . . . . . . . . . 
 . .
  724 
 agenda . . . . . . . . . . . . . . . . . . . . . . 
 . . .
  379 
 algebraic specification . . . . . . 
 . . . . .
  123 
 aliasing. . . . . . . . . . . . . . . . . . . 
 . . . . . .
 316
  
 848",NA
Colophon,NA,NA
O,"is image of the engraving is hosted by J. E. Johnson of
  New 
 Goland
 . from 1588. It could be seen as an early hypertext 
 navigation aid. 
  
  
  is Agostino Ramelli’s 
 bookwheel mechanism 
 e typefaces are Linux Libertine for body text and Linux 
 Biolinum for headings, both by Philipp H. Poll. Typewriter face is 
 Inconsolata created by Raph Levien and supplemented by 
 Dimosthenis Kaponis and Takashi Tanigawa in the form of 
 Inconsolata LGC. 
 Graphic design and typography are done by Andres Raba. 
 Texinfo source is converted to LaTeX by a Perl script and compiled 
 to 
  by XeLaTeX. Diagrams are drawn with Inkscape.",NA
