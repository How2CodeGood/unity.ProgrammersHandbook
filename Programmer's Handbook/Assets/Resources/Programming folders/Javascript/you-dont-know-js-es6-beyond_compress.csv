Larger Text,Smaller Text,Symbol
You Don’t Know JS: ,NA,NA
ES6 ,NA,NA
and ,NA,NA
Beyo,NA,NA
nd,NA,NA
Kyle Simpson,NA,NA
Table of Contents,"Foreword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . .  ix
  
 1. ES? Now & Future. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . .  1
  
 Versioning                                                                                                                           2 
 Transpiling                                                                                                                          3 
 Shims/Polyfills                                                                                                                4 
 Review                                                                                                                                  5
  
 2. Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . .  7
  
 Block-Scoped Declarations                                                                                               7 
 let
  Declarations                                                                                                             8 
 const
  Declarations                                                                                                       12 
 Spread / Rest                                                                                                                     13 
 Default Parameter Values                                                                                               15 
 Default Value Expressions                                                                                           17 
 Destructuring                                                                                                                   19 
 Object Property Assignment Pattern                                                                        20 
 Not Just Declarations                                                                                                   22 
 Too Many, Too Few, Just Enough                                                                               24 
 Default Value Assignment                                                                                           26 
 Nested Destructuring                                                                                                   26 
 Destructuring Parameters                                                                                           27 
 Object Literal Extensions                                                                                                32 
 Concise Properties                                                                                                       32 
 Concise Methods                                                                                                          33 
 Computed Property Names                                                                                        37 
 Setting 
 [[Prototype]]
                                                                                                 38 
 Object 
 super
                                                                                                                  40",NA
Foreword,"Kyle Simpson is a thorough pragmatist.
  
 I can’t think of higher praise than this. To me, these are two of the most 
 important qualities that a software developer must have. That’s right: 
 must
 , not 
 should
 . Kyle’s keen ability to tease apart layers of the JavaScript programming 
 language and present them in understandable and meaningful portions is 
 second to none.
  
 ES6 & Beyond
  will be familiar to readers of the 
 You Don’t Know JS
  series: they 
 can expect to be deeply immersed in everything from the obvious, to the very 
 subtle—revealing semantics that were either taken for granted or never even 
 considered. Until now, the 
 You Don’t Know JavaScript
  book series has covered 
 material that has at least some degree of familiarity to its readers. They have 
 either seen or heard about the subject matter; they may even have experience 
 with it. This entry covers material that only a very small portion of the 
 JavaScript developer community has been exposed to: the evolutionary changes 
 to the language introduced in the 
 ECMAScript 2015 Lan‐guage Specification
 .
  
 Over the last couple years, I’ve witnessed Kyle’s tireless efforts to familiarize 
 himself with this material to a level of expertise that is rivaled by only a handful 
 of his profes‐sional peers. That’s quite a feat, considering that at the time of this 
 writing, the lan‐guage specification document hasn’t been formally published! 
 But what I’ve said is true, and I’ve read every word that Kyle’s written for this 
 book. I’ve followed every change, and each time, the content only gets better and 
 provides yet a deeper level of understanding.
  
 This book is about shaking up your sense of understanding by exposing you to 
 the new and unknown. The intention is to evolve your knowledge in step with 
 your tools by bestowing you with new capabilities. It exists to give you the 
 confidence to fully embrace the next major era of JavaScript programming.
  
 Rick Waldron [@rwaldron](
 http://twitter.com/rwaldron
 ) Open Web Engineer at 
 Bocoup Ecma/TC39 Representative for jQuery
  
 ix",NA
CHAPTER 1,NA,NA
ES? Now & Future,"Before reading this book, I assume you have a solid working proficiency over 
 Java‐Script up to the most recent standard (at the time of this writing), which is 
 commonly called 
 ES5
  (technically ES 5.1). Here, we plan to talk squarely about 
 the upcoming 
 ES6
 , as well as cast our vision beyond to understand how JS will 
 evolve moving for‐ward.
  
 If you are still looking for confidence with JavaScript, I highly recommend you 
 read the other titles in this series first:
  
 •
  “Up & Going”
 : Are you new to programming and JS? This is the roadmap you 
 need to consult as you start your learning journey.
  
 •
  “Scope & Closures”
 : Did you know that JS lexical scope is based on compiler 
 (not interpreter!) semantics? Can you explain how closures are a direct 
 result of lexi‐cal scope and functions as values?
  
 •
  “this & Object Prototypes”
 : Can you recite the four simple rules for how 
 this
  is 
 bound? Have you been muddling through fake “classes” in JS instead of 
 adopting the simpler “behavior delegation” design pattern? Ever heard of 
 OLOO?
  
 •
  “Types & Grammar”
 : Do you know the built-in types in JS, and more 
 importantly do you know how to properly and safely use coercion between 
 types? How com‐fortable are you with the nuances of JS grammar/syntax?
  
 •
  “Async & Performance”
 : Are you still using callbacks to manage your 
 asynchrony? Can you explain what a promise is and why/how it solves 
 “callback hell”, and how generators improve the legibility of async code? 
 What exactly constitutes mature optimization of JS programs and individual 
 operations?
  
 1",NA
Versioning,"The JavaScript standard is referred to officially as “ECMAScript” (abbreviated 
 “ES”), and up until just recently has been versioned entirely by ordinal number 
 (i.e., “5” for“5th edition”).
  
 The earliest versions ES1 and ES2 were not widely known or implemented, but 
 ES3 was the first widespread baseline for JavaScript. ES3 constitutes the 
 JavaScript stan‐dard for browsers like IE6-8 and older Android 2.x mobile 
 browsers. For politicial reasons beyond what we’ll cover here, the ill-fated ES4 
 never came about.
  
 In 2009, ES5 was officially finalized (later ES5.1 in 2011), and settled as the 
 wide‐spread standard for JS for the modern revolution and explosion of 
 browsers, such as Firefox, Chrome, Opera, Safari, and many others.
  
 Leading up to the expected 
 next
  version of JS (slipped from 2013 to 2014 and 
 then 2015), the obvious and common label in discourse has been ES6.
  
 However, late into the ES6 specification timeline, suggestions have surfaced that 
 ver‐sioning may in the future switch to being year-based, such ES2016 (aka 
 ES7) to refer to whatever version of the specification is finalized before the end 
 of 2016. Some disa‐gree, but ES6 will likely maintain its dominant mindshare 
 over the late change substi‐tute ES2015. However ES2016 may in fact signal the 
 new versioning scheme.
  
 It has also been observed that the pace of JS evolution is much faster even than 
 single-year versioning. As soon as an idea begins to progress through standards 
 discussions,",NA
Transpiling,"Made even worse by the rapid evolution of features, a problem arises for JS 
 develop‐ers who at once may both strongly desire to use new features while at 
 the same time being slapped with the reality that their sites/apps may need to 
 support older brows‐ers without such support.
  
 The way ES5 appears to have played out in the broader industry, the typical 
 mindset was that code bases waited to adopt ES5 until most if not all pre-ES5 
 environments had fallen out of their support spectrum. As a result, many are 
 just recently (at the time of this writing) starting to adopt things like 
 strict
  mode 
 which landed in ES5 five or more years ago.
  
 This is widely considered to be a harmful approach for the future of the JS 
 ecosystem, to wait around and trail the specification by so many years. All those 
 responsible for evolving the language desire for developers to begin basing their 
 code on the new fea‐tures and patterns as soon as they stabilize in specification 
 form and browsers have a chance to implement them.
  
 So how do we resolve this seeming contradiction? The answer is tooling, 
 specifically a technique called 
 transpiling
  (transformation 
  
 compiling). Roughly, the idea is to use a special tool to transform your ES6 code 
 into equivalent (or close!) matches that work in ES5 environments.
  
 For example, consider shorthand property definitions (see “Object Literal Exten‐
 sions” in Chapter 2). Here’s the ES6 form:
  
 var
 foo
 =
 [
 1
 ,
 2
 ,
 3
 ];
  
 var
 obj
 =
 {
  
 foo
 // means `foo: foo`
  
 };
  
 obj
 .
 foo
 ;
 // [1,2,3]
  
 Transpiling 
  
 | 
  
 3",NA
Shims/Polyfills,"Not all new ES6 features need a transpiler. Polyfills (aka shims) are a pattern for 
 defining equivalent behavior from a newer environment into an older 
 environment, when possible. Syntax cannot be polyfilled, but APIs often can be.
  
 For example, 
 Object.is(..)
  is a new utility for checking strict equality of two values 
 but without the nuanced exceptions that 
 ===
  has for 
 NaN
  and 
 -0
  values. The 
 polyfill for 
 Object.is(..)
  is pretty easy:
  
 if
 (
 !
 Object
 .
 is
 ){ 
  
  
 Object
 .
 is
 =
 function
 (
 v1
 ,
 v2
 ){ 
  
  
  
 // test for `-0` 
  
  
  
 if
 (
 v1
 ===
 0
 &&
 v2
 ===
 0
 ){ 
  
  
  
  
 return
 1
 /
 v1
 ===
 1
 /
 v2
 ; 
  
  
  
 } 
  
  
  
 // test for `NaN` 
  
  
  
 if
 (
 v1
 !==
 v1
 ){ 
  
  
  
  
 return
 v2
 !==
 v2
 ; 
  
  
  
 } 
  
  
  
 // everything else 
  
  
  
 return
 v1
 ===
 v2
 ; 
  
  
 }; 
  
 }
  
  
  
 Pay attention to the outer 
 if
  statement guard wrapped around 
 the polyfill. This is an important detail, which means the 
 snippet 
 only 
 defines 
 its 
 fallback 
 behavior 
 for 
 older 
 environments where the API in question isn’t already defined; 
 it would be very rare that you’d want to overwrite an existing 
 API.
  
 4 
  
 | 
  
 Chapter 1: ES? Now & Future
  
 www.it-ebooks.info",NA
Review,"ES6 (some may try to call it ES2015) is just landing as of the time of this writing, 
 and it has lots of new stuff you need to learn!
  
 But it’s even more important to shift your mindset to align with the new way 
 that JavaScript is going to evolve. It’s not just waiting around for years for some 
 official document to get a vote of approval, as many have done in the past.
  
 Now, JavaScript features land in browsers as they become ready, and it’s up to 
 you whether you’ll get on train early or whether you’ll be playing costly catch-
 up games years from now.
  
 Whatever labels that future JavaScript adopts, it’s going to move a lot quicker 
 than it ever has before. Transpilers and shims/polyfills are important tools to 
 keep you on the forefront of where the language is headed.
  
 If there’s any narrative important to understand about the new reality for 
 JavaScript, it’s that all JS developers are strongly implored to move from the 
 trailing edge of the curve to the leading edge. And learning ES6 is where that all 
 starts!",NA
CHAPTER 2,NA,NA
Syntax,"If you’ve been writing JS for any length of time, odds are the syntax is pretty 
 familiar to you. There are certainly many quirks, but overall it’s a fairly 
 reasonable and straightforward syntax that draws many similarities from other 
 languages.
  
 However, ES6 adds quite a few new syntactic forms which are going to take 
 some get‐ting used to. In this chapter we’ll tour through them to find out what’s 
 in store.
  
  
 At the time of this writing, some of the features in this book have
  
 been implemented in various browsers (Firefox, Chrome, etc.), but
  
 many others have not, or the features are only partially imple‐
  
 mented. Your experience may be mixed trying these examples
  
 directly. If so, try them out with transpilers, as most of these fea‐
  
 tures are covered 
  
 by those 
  
 tools. 
  
 ES6Fiddle 
  
 (
 http://
  
 www.es6fiddle.net/
 ) is a great, easy-to-use playground for trying
  
 out ES6, as is the online REPL for the Babel transpiler (
 http://
  
 babeljs.io/repl/
 ).",NA
Block-Scoped Declarations,"You’re probably aware that the fundamental unit of variable scoping in 
 JavaScript has always been the 
 function
 . If you needed to create a block of scope, 
 the most preva‐lent way to do so was the IIFE (immediately invoked function 
 expression), such as:
  
 var
 a
 =
 2
 ;
  
 (
 function
 IIFE
 (){
  
 var
 a
 =
 3
 ;
  
 console
 .
 log
 (
 a
 );
 // 3
  
 })();
  
 7",NA
let,NA,NA
 Declarations,"However, we can now create declarations which are bound to any block, called 
 (unsurprisingly) 
 block scoping
 . This means all we need is a pair of 
 { .. }
  to create 
 a scope. Instead of using 
 var
 , which always declares variables attached to the 
 enclosing function (or global, if top level) scope, use 
 let
 :
  
 var
 a
 =
 2
 ;
  
 { 
  
  
 let
 a
 =
 3
 ; 
  
  
 console
 .
 log
 (
 a
 );
 // 3 
  
 }
  
 console
 .
 log
 (
 a
 );
 // 2
  
 It’s not very common or idiomatic thus far in JS to use a standalone 
 { .. }
  block as 
 shown there, but it’s always been totally valid. And developers from other 
 languages that have 
 block scoping
  will readily recognize that pattern.
  
 I’m going to suggest that I think this is the far better way to create block-scoped 
 vari‐ables, with a dedicated 
 { .. }
  block. Moreover, I will also strongly suggest you 
 should always put the 
 let
  declaration(s) at the very top of that block. If you have 
 more than one to declare, I’d recommend using just one 
 let
 .
  
 Stylistically, I even prefer to put the 
 let
  on the same line as the opening 
 {
 , to 
 make it clearer that this block is only for the purpose of declaring the scope for 
 those vari‐ables.
  
 {
 let
 a
 =
 2
 ,
 b
 ,
 c
 ; 
  
  
 // ..
  
 }
  
 Now, that’s going to look strange and it’s not likely going to match the 
 recommenda‐tions by most other ES6 literature. But I have reasons for my 
 madness.
  
 There’s another proposed form of the 
 let
  declaration called the 
 let
 -block, which 
 looks like:
  
 let
 (
 a
 =
 2
 ,
 b
 ,
 c
 ){ 
  
  
 // ..
  
 }
  
 That form is what I’d called 
 explicit
  block scoping, whereas the 
 let ..
  declaration 
 form that mirrors 
 var
  is more 
 implicit
 , since it kind of hijacks whatever 
 { .. }
  pair 
 it’s found in. Generally developers find 
 explicit
  mechanisms a bit more 
 preferable than 
 implicit
  mechanisms, and I claim this is one of those cases.
  
 8 
  
 | 
  
 Chapter 2: Syntax",NA
const,NA,NA
 Declarations,"There’s one other form of block-scoped declaration to consider, the 
 const
 , which 
 cre‐ates 
 constants
 .
  
 What exactly is a 
 constant
 ? It’s a variable that’s read-only after its initial value is 
 set. Consider:
  
 { 
  
 const
 a
 =
 2
 ; 
  
 console
 .
 log
 (
 a
 );
 // 2
  
  
 a
 =
 3
 ;
 // TypeError! 
  
 }
  
 You are not allowed to change the value of the variable once it’s been set, at 
 declara‐tion time. A 
 const
  declaration must have an explicit initialization. If you 
 wanted a 
 constant
  with the 
 undefined
  value, you’d have to declare 
 const a = 
 undefined
  to get it.
  
 Constants
  are not a restriction on the value itself, but on the variable assignment 
 of that value. In other words, the value is not frozen, just the assignment of it. If 
 the value is complex, such as an object or array, the contents of the value can 
 still be modified:
  
 { 
  
 const
 a
 =
 [
 1
 ,
 2
 ,
 3
 ]; 
  
 a
 .
 push
 (
 4
 ); 
  
 console
 .
 log
 (
 a
 );
 // [1,2,3,4]
  
  
 a
 =
 42
 ;
 // TypeError! 
  
 }
  
 The 
 a
  variable doesn’t actually hold a 
 constant
  array, it holds a 
 constant
  
 reference to the array; the array itself is freely mutable.
  
  
 Assigning an object or array as a constant means that value will 
 never be able to be garbage collected, since the reference to the 
 value can never be unset. That may be desirable, but be careful 
 if it’s not your intent!
  
 Essentially, 
 const
  declarations enforce what we’ve stylistically signaled with our 
 code for years, where we declared a variable name of all uppercase letters and 
 assigned it some literal value that we took care never to change. There’s no 
 enforcement on a 
 var 
 assignment, but there is now with a 
 const
  assignment, 
 which can help you catch unintended changes.
  
 12 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
Spread / Rest,"ES6 introduces a new 
 ...
  operator that’s typically referred to as the 
 spread
  or 
 rest 
 operator, depending on where/how it’s used. Let’s take a look:
  
 function
 foo
 (
 x
 ,
 y
 ,
 z
 ){
  
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 );
  
 }
  
 foo
 (...[
 1
 ,
 2
 ,
 3
 ]);
 // 1 2 3
  
 When 
 ...
  is used in front of an array (actually, any 
 iterable
 , which we cover in 
 Chap‐ter 3), it acts to “spread” it out into its individual values.
  
 You’ll typically see that usage as is shown in that previous snippet, when 
 spreading out an array as a set of arguments to a function call. In this usage, 
 ...
  
 acts to give us a simpler syntactic replacement for the 
 apply(..)
  method, which 
 we would typically have used pre-ES6 as:
  
 foo
 .
 apply
 (
 null
 ,[
 1
 ,
 2
 ,
 3
 ]);
 // 1 2 3
  
 But 
 ...
  can be used to spread out/expand a value in other contexts as well, such as 
 inside another array declaration:
  
 var
 a
 =
 [
 2
 ,
 3
 ,
 4
 ];
  
 var
 b
 =
 [
 1
 ,...
 a
 ,
 5
 ];
  
 console
 .
 log
 (
 b
 );
 // [1,2,3,4,5]
  
 In this usage, 
 ...
  is basically replacing 
 concat(..)
 , as the above behaves like 
 [1].con 
 cat( a, [5] )
 .
  
 The other common usage of 
 ...
  can be seen as almost the opposite; instead of 
 spreading a value out, the 
 ...
 gathers
  a set of values together into an array. 
 Consider:
  
 function
 foo
 (
 x
 ,
 y
 ,...
 z
 ){
  
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 );
  
 }
  
 foo
 (
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 );
 // 1 2 [3,4,5]
  
 Spread / Rest 
  
 | 
  
 13",NA
Default Parameter Values,"Perhaps one of the most common idioms in JavaScript relates to setting a default 
 value for a function parameter. The way we’ve done this for years should look 
 quite familiar:
  
 function
 foo
 (
 x
 ,
 y
 ){ 
  
 x
 =
 x
 ||
 11
 ; 
  
 y
 =
 y
 ||
 31
 ;
  
  
 console
 .
 log
 (
 x
 +
 y
 ); 
  
 }
  
 foo
 ();
 // 
 42 
  
 foo
 (
 5
 ,
 6
 );
 // 
 11 
  
 foo
 (
 5
 );
 // 
 36 
  
 foo
 (
 null
 ,
 6
 );
 // 17
  
 Of course, if you’ve used this pattern before, you know that it’s both helpful and 
 a lit‐tle bit dangerous, if for example you need to be able to pass in what would 
 otherwise be considered a falsy value for one of the parameters. Consider:
  
 foo
 (
 0
 ,
 42
 );
 // 53 <-- Oops, not 42
  
 Why? Because the 
 0
  is falsy, and so the 
 x || 11
  results in 
 11
 , not the directly 
 passed in 
 0
 .
  
 To fix this gotcha, some people will instead write the check more verbosely like 
 this:
  
 function
 foo
 (
 x
 ,
 y
 ){ 
  
 x
 =
 (
 x
 !==
 undefined
 )
 ?
 x
 :
 11
 ; 
  
 y
 =
 (
 y
 !==
 undefined
 )
 ?
 y
 :
 31
 ;
  
  
 console
 .
 log
 (
 x
 +
 y
 ); 
  
 }
  
 Default Parameter Values 
  
 | 
  
 15",NA
Default Value Expressions,"Function default values can be more than just simple values like 
 31
 ; they can be 
 any valid expression, even a function call:
  
 function
 bar
 (
 val
 ){ 
  
  
 console
 .
 log
 (
 ""bar called!""
 ); 
  
  
 return
 y
 +
 val
 ; 
  
 }
  
 function
 foo
 (
 x
 =
 y
 +
 3
 ,
 z
 =
 bar
 (
 x
 )){ 
  
  
 console
 .
 log
 (
 x
 ,
 z
 ); 
  
 }
  
 var
 y
 =
 5
 ; 
  
 foo
 ();
 // ""bar called"" 
  
 // 8 13 
  
 foo
 (
 10
 );
 // ""bar called"" 
  
 // 10 15 
  
 y
 =
 6
 ; 
  
 foo
 (
 undefined
 ,
 10
 );
 // 9 10
  
 As you can see, the default value expressions are lazily evaluated, meaning 
 they’re only run if and when they’re needed — that is, when a parameter’s 
 argument is omit‐ted or is 
 undefined
 .
  
 It’s a subtle detail, but the formal parameters in a function declaration are in 
 their own scope — think of it as a scope bubble wrapped around just the 
 ( .. )
  of 
 the function declaration — not in the function body’s scope. That means a 
 reference to an identifier in a default value expression first matches the formal 
 parameters’ scope before looking to an outer scope. See the 
 Scope & Closures
  
 title of this series for more information.
  
 Default Parameter Values 
  
 | 
  
 17
  
 www.it-ebooks.info",NA
Destructuring,"ES6 introduces a new syntactic feature called 
 destructuring
 , which may be a 
 little less confusing sounding if you instead think of it as 
 structured assignment
 . 
 To understand this meaning, consider:
  
 function
 foo
 (){ 
  
  
 return
 [
 1
 ,
 2
 ,
 3
 ]; 
  
 }
  
 var
 tmp
 =
 foo
 (), 
  
  
 a
 =
 tmp
 [
 0
 ],
 b
 =
 tmp
 [
 1
 ],
 c
 =
 tmp
 [
 2
 ];
  
 console
 .
 log
 (
 a
 ,
 b
 ,
 c
 );
 // 1 2 3
  
 As you can see, we created a manual assignment of the values in the array that 
 foo() 
 returns to individual variables 
 a
 , 
 b
 , and 
 c
 , and to do so we (unfortunately) 
 needed the 
 tmp
  variable.
  
 We can do similar with objects:
  
 function
 bar
 (){ 
  
  
 return
 { 
  
  
  
 x
 :
 4
 , 
  
  
  
 y
 :
 5
 , 
  
  
  
 z
 :
 6 
  
  
 }; 
  
 }
  
 var
 tmp
 =
 bar
 (), 
  
  
 x
 =
 tmp
 .
 x
 ,
 y
 =
 tmp
 .
 y
 ,
 z
 =
 tmp
 .
 z
 ;
  
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 );
 // 4 5 6
  
 The 
 tmp.x
  property value is assigned to the 
 x
  variable, and likewise for 
 tmp.y
  to 
 y
  
 and 
 tmp.z
  to 
 z
 .
  
 Destructuring 
  
 | 
  
 19",NA
Object Property Assignment Pattern,"Let’s dig into that 
 { x: x, .. }
  syntax from the previous snippet. If the property 
 name being matched is the same as the variable you want to declare, you can 
 actually shorten the syntax:
  
 var
 {
 x
 ,
 y
 ,
 z
 }
 =
 bar
 ();
  
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 );
 // 4 5 6
  
 Cool, huh!?
  
 But is 
 { x, .. }
  leaving off the 
 x:
  part or leaving off the 
 : x
  part? As we’ll see shortly, 
 we’re actually leaving off the 
 x:
  part when we use the shorter syntax. That may 
 not seem like an important detail, but you’ll understand its importance.
  
 If you can write the shorter form, why would you ever write out the longer 
 form? Because that longer form actually allows you to assign a property to a 
 different vari‐able name, which can sometimes be quite useful:
  
 var
 {
 x
 :
 bam
 ,
 y
 :
 baz
 ,
 z
 :
 bap
 }
 =
 bar
 ();
  
 console
 .
 log
 (
 bam
 ,
 baz
 ,
 bap
 );
 // 4 5 6
  
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 );
 // ReferenceError
  
 20 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
Not Just Declarations ,"So far, we’ve used destructuring assignment with 
 var
  declarations — of course, 
 they could also use 
 let
  and 
 const
  — but destructuring is a general assignment 
 operation, not just a declaration.
  
 Consider: 
  
  
 var
 a
 ,
 b
 ,
 c
 ,
 x
 ,
 y
 ,
 z
 ; 
  
  
 [
 a
 ,
 b
 ,
 c
 ]
 =
 foo
 (); 
  
  
 ({
 x
 ,
 y
 ,
 z
 }
 =
 bar
 ()); 
  
  
 console
 .
 log
 (
 a
 ,
 b
 ,
 c
 );
 // 1 2 3 
  
  
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 );
 // 4 5 6 
  
 The variables can already be declared, and then the destructuring only does 
 assign‐ments, exactly as we’ve already seen.
  
  
 For the object destructuring form specifically, when leaving off 
 a 
 var
 /
 let
 /
 const
  declarator, we had to surround the whole 
 assign‐ment expression in 
 ( )
 , because otherwise the 
 { .. }
  on the 
 left-hand side as the first element in the statement is taken to 
 be a statement block instead of an object.
  
 In fact, the assignment expressions (
 a
 , 
 y
 , etc.) don’t actually need to be just 
 variable identifiers. Anything that’s a valid assignment expression is valid. For 
 example: 
  
 var
 o
 =
 {}; 
  
  
 [
 o
 .
 a
 ,
 o
 .
 b
 ,
 o
 .
 c
 ]
 =
 foo
 (); 
  
  
 ({
 x
 :
 o
 .
 x
 ,
 y
 :
 o
 .
 y
 ,
 z
 :
 o
 .
 z
 }
 =
 bar
 ()); 
  
  
 console
 .
 log
 (
 o
 .
 a
 ,
 o
 .
 b
 ,
 o
 .
 c
 );
 // 1 2 3 
  
  
 console
 .
 log
 (
 o
 .
 x
 ,
 o
 .
 y
 ,
 o
 .
 z
 );
 // 4 5 6 
  
 You can even use computed property expressions in the destructuring. Consider: 
  
 var
 which
 =
 ""x""
 , 
  
  
  
 o
 =
 {}; 
  
  
 ({[
 which
 ]
 :
 o
 [
 which
 ]}
 =
 bar
 ()); 
  
  
 console
 .
 log
 (
 o
 .
 x
 );
 // 4
  
 22 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
"Too Many, Too Few, Just Enough","With both array destructuring assignment and object destructuring assignment, 
 you do not have to assign all the values that are present. For example:
  
 24 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
Default Value Assignment,"Both forms of destructuring can offer a default value option for an assignment, 
 using the 
 =
  syntax similar to the default function argument values discussed 
 earlier.
  
 Consider:
  
 var
 [
 a
 =
 3
 ,
 b
 =
 6
 ,
 c
 =
 9
 ,
 d
 =
 12
 ]
 =
 foo
 (); 
 var
 {
 x
 =
 5
 ,
 y
 =
 10
 ,
 z
 =
 15
 ,
 w
 =
 20
 }
 =
 bar
 ();
  
 console
 .
 log
 (
 a
 ,
 b
 ,
 c
 ,
 d
 );
 // 1 2 3 12 
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 ,
 w
 );
 // 4 
 5 6 20
  
 You can combine the default value assignment with the alternate assignment 
 expres‐sion syntax covered earlier. For example:
  
 var
 {
 x
 ,
 y
 ,
 z
 ,
 w
 :
 WW
 =
 20
 }
 =
 bar
 ();
  
 console
 .
 log
 (
 x
 ,
 y
 ,
 z
 ,
 WW
 );
 // 4 5 6 20
  
 Be careful about confusing yourself (or other developers who read your code) if 
 use an object or array as the default value in a destructuring. You can create 
 some really hard to understand code:
  
 var
 x
 =
 200
 ,
 y
 =
 300
 ,
 z
 =
 100
 ; 
  
 var
 o1
 =
 {
 x
 :
 {
 y
 :
 42
 },
 z
 :
 {
 y
 :
 z
 }};
  
 ({
 y
 :
 x
 =
 {
 y
 :
 y
 }}
 =
 o1
 ); 
  
 ({
 z
 :
 y
 =
 {
 y
 :
 z
 }}
 =
 o1
 ); 
  
 ({
 x
 :
 z
 =
 {
 y
 :
 x
 }}
 =
 o1
 );
  
 Can you tell from that snippet what values 
 x
 , 
 y
 , and 
 z
  have at the end? Takes a 
 moment to ponder, I would imagine. I’ll end the suspense:
  
 console
 .
 log
 (
 x
 .
 y
 ,
 y
 .
 y
 ,
 z
 .
 y
 );
 // 300 100 42
  
 The takeaway here: destructuring is great and can be very useful, but it’s also a 
 sharp sword that used unwisely can end up injuring (someone’s brain).",NA
Nested Destructuring,"If the values you’re destructuring have nested objects or arrays, you can 
 destructure those nested values as well:
  
 var
 a1
 =
 [
 1
 ,[
 2
 ,
 3
 ,
 4
 ],
 5
 ]; 
  
 var
 o1
 =
 {
 x
 :
 {
 y
 :
 {
 z
 :
 6
 }}};
  
 var
 [
 a
 ,[
 b
 ,
 c
 ,
 d
 ],
 e
 ]
 =
 a1
 ; 
  
 var
 {
 x
 :
 {
 y
 :
 {
 z
 :
 w
 }}}
 =
 o1
 ;
  
 console
 .
 log
 (
 a
 ,
 b
 ,
 c
 ,
 d
 ,
 e
 );
 // 1 2 3 4 5 
 console
 .
 log
 (
 w
 );
 // 6
  
 26 
  
 | 
  
 Chapter 2: Syntax",NA
Destructuring Parameters,"In the following snippet, can you spot the assignment?
  
 function
 foo
 (
 x
 ){ 
  
  
 console
 .
 log
 (
 x
 ); 
  
 }
  
 foo
 (
 42
 );
  
 The assignment is kinda hidden: the 
 argument
 42
  is assigned to the 
 parameter
 x
  
 when 
 foo(42)
  is executed. If parameter/argument pairing is an assignment, then 
 it stands to reason that it’s an assignment that could be destructured, right? Of 
 course!
  
 Consider array destructuring for parameters:
  
 function
 foo
 ([
 x
 ,
 y
 ]){ 
  
  
 console
 .
 log
 (
 x
 ,
 y
 ); 
  
 }
  
 foo
 ([
 1
 ,
 2
 ]);
 // 1 2 
  
 foo
 ([
 1
 ]);
 // 1 undefined 
  
 foo
 ([]);
 // undefined undefined
  
 Object destructuring for parameters works, too:
  
 function
 foo
 ({
 x
 ,
 y
 }){ 
  
  
 console
 .
 log
 (
 x
 ,
 y
 ); 
  
 }
  
 foo
 ({
 y
 :
 1
 ,
 x
 :
 2
 });
 // 2 1 
  
 foo
 ({
 y
 :
 42
 });
 // undefined 42 
  
 foo
 ({});
 // undefined undefined
  
 This technique is an approximation of named arguments (a long requested 
 feature for JS!), in that the properties on the object map to the destructured 
 parameters of the same names. That also means that we get optional 
 parameters (in any position) for free, as you can see leaving off the 
 x
  
 “parameter” worked as we’d expect.
  
 Destructuring 
  
 | 
  
 27",NA
Object Literal Extensions,"ES6 adds a number of important convenience extensions to the humble 
 { .. }
  
 object literal.",NA
Concise Properties,"You’re certainly familiar with declaring object literals in this form:
  
 var
 x
 =
 2
 ,
 y
 =
 3
 , 
  
  
 o
 =
 { 
  
  
  
 x
 :
 x
 , 
  
  
  
 y
 :
 y 
  
  
 };
  
 If it’s always felt redundant to say 
 x: x
  all over, there’s good news. If you need to 
 define a property that is the same name as a lexical identifier, you can shorten it 
 from 
 x: x
  to 
 x
 . Consider:
  
 32 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
Concise Methods,"In a similar spirit to concise properties we just examined, functions attached to 
 prop‐erties in object literals also have a concise form, for convenience.
  
 The old way:
  
 var
 o
 =
 { 
  
  
 x
 :
 function
 (){ 
  
  
  
 // ..
  
 }, 
  
 y
 :
 function
 (){ 
  
  
 // ..
  
  
 } 
  
 }
  
 And as of ES6:
  
 var
 o
 =
 { 
  
 x
 (){ 
  
 // ..
  
 }, 
  
 y
 (){ 
  
  
 // ..
  
  
 } 
  
 }
  
  
 While 
 x() { .. }
  seems to just be shorthand for 
 x: function() { .. }
 , 
 concise methods have special behaviors that their older 
 counterparts don’t; specifically, the allowance for 
 super
  
 (see“Object 
 super
 "" later in this chapter).
  
 Generators (see Chapter 4) also have a concise method form:
  
 var
 o
 =
 { 
  
  
 *
 foo
 (){..} 
  
 };
  
 Concisely Unnamed
  
 While that convenience shorthand is quite attractive, there’s a subtle gotcha to 
 be aware of. To illustrate, let’s examine pre-ES6 code like the following, which 
 you might try to refactor to use concise methods:
  
 Object Literal Extensions 
  
 | 
  
 33
  
 www.it-ebooks.info",NA
Computed Property Names,"You’ve probably been in a situation like the following snippet, where you have 
 one or more property names that come from some sort of expression and thus 
 can’t be put into the object literal:
  
 var
 prefix
 =
 ""user_""
 ;
  
 Object Literal Extensions 
  
 | 
  
 37",NA
Setting ,NA,NA
[[Prototype]],"We won’t cover prototypes in detail here, so for more information, see the 
 this & 
 Object Prototypes
  title of this series.
  
 38 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
Object ,NA,NA
super,"super
  is typically thought of as being only related to classes. However, due to JS’s 
 classless-objects-with-prototypes nature, 
 super
  is equally effective, and nearly 
 the same in behavior, with plain objects’ concise methods.
  
 Consider:
  
 var
 o1
 =
 { 
  
  
 foo
 (){ 
  
  
  
 console
 .
 log
 (
 ""o1:foo""
 ); 
  
  
 } 
  
 };
  
 var
 o2
 =
 { 
  
  
 foo
 (){ 
  
  
  
 super
 .
 foo
 (); 
  
  
  
 console
 .
 log
 (
 ""o2:foo""
 ); 
  
  
 } 
  
 };
  
 Object
 .
 setPrototypeOf
 (
 o2
 ,
 o1
 );
  
 o2
 .
 foo
 ();
 // o1:foo 
  
 // o2:foo
  
  
 super
  is only allowed in concise methods, not regular function 
 expression properties. It also is only allowed in 
 super.XXX
  form 
 (for property/method access), not in 
 super()
  form.
  
 The 
 super
  reference in the 
 o2.foo()
  method is locked statically to 
 o2
 , and 
 specifically to the 
 [[Prototype]]
  of 
 o2
 . 
 super
  here would basically be 
 Object.getPrototy peOf(o2)
  — resolves to 
 o1
  of course — which is how it finds 
 and calls 
 o1.foo()
 .
  
 For complete details on 
 super
 , see “Classes” in Chapter 3.",NA
Template Literals,"At the very outset of this section, I’m going to have to call out the name of this 
 ES6 feature as being awfully… misleading, depending on your experiences with 
 what the word 
 template
  means.
  
 Many developers think of templates as being reusable renderable pieces of text, 
 such as the capability provided by most template engines (Mustache, 
 Handlebars, etc.). ES6’s use of the word Template would imply something 
 similar, like a way to declare
  
 40 
  
 | 
  
 Chapter 2: Syntax",NA
Interpolated Expressions,"Any valid expression is allowed to appear inside 
 ${..}
  in an interpolated string 
 lit‐eral, including function calls, inline function expression calls, and even other 
 interpo‐lated string literals!
  
  
 As a word of caution, be very careful about the readability of 
 your code with such new found power. Just like with default 
 value expressions and destructuring assignment expressions, 
 just because you 
 can
  do something doesn’t mean you 
 should
  do 
 it. Never go so overboard with new ES6 tricks that your code 
 becomes more clever than you or your other team members.
  
 Consider:
  
 function
 upper
 (
 s
 ){ 
  
  
 return
 s
 .
 toUpperCase
 (); 
  
 }
  
 var
 who
 =
 ""reader""
  
 var
 text
 = 
  
 `
 Avery$
 {
 upper
 (
 ""warm""
 )}
 welcome 
  
 toallofyou$
 {
 upper
 (
 `
 $
 {
 who
 }
 s
 `
 )}
 !
 `
 ;
  
 console
 .
 log
 (
 text
 ); 
  
 // A very WARM welcome 
  
 // to all of you READERS!
  
 Here, the inner 
 \
 ${who}s\`` interpolated string literal was a little bit nicer 
 conve‐nience for us when combining the 
 who
  variable with the 
 ""s""
  string, as 
 opposed to 
 who + ""s""
 . There will be cases that nesting interpolated string literals 
 is helpful, but be wary if you find yourself doing that kind of thing often, or if 
 you find yourself nesting several levels deep.
  
 42 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
Tagged Template Literals,"Again, renaming the feature for sanity sake: 
 Tagged String Literals
 .
  
 To be honest, this is one of the cooler tricks that ES6 offers. It may seem a little 
 strange, and perhaps not all that generally practical at first. But once you’ve 
 spent some time with it, tagged string literals may just surprise you in their 
 usefulness.
  
 For example:
  
 function
 foo
 (
 strings
 ,...
 values
 ){ 
  
  
 console
 .
 log
 (
 strings
 ); 
  
  
 console
 .
 log
 (
 values
 ); 
  
 }
  
 var
 desc
 =
 ""awesome""
 ;
  
 foo
 `
 Everythingis$
 {
 desc
 }
 !
 `
 ; 
  
 // [ ""Everything is "", ""!""] 
  
 // [ ""awesome"" ]
  
 Template Literals 
  
 | 
  
 43",NA
Arrow Functions,"We’ve touched on 
 this
  binding complications with functions earlier in this 
 chapter, and they’re covered at length in the 
 this & Object Prototypes
  title of this 
 series. It’s important to understand the frustrations that 
 this
  based 
 programming with normal functions brings, because that is the primary 
 motivation for the new ES6 
 =>
  arrow function feature.
  
 Let’s first illustrate what an arrow function looks like, as compared to normal 
 func‐tions:
  
 function
 foo
 (
 x
 ,
 y
 ){ 
  
  
 return
 x
 +
 y
 ;
  
 46 
  
 | 
  
 Chapter 2: Syntax",NA
"Not Just Shorter Syntax, But ",NA,NA
this,"Most of the popular attention toward 
 =>
  has been on saving those precious 
 keystrokes by dropping 
 function
 , 
 return
 , and 
 { .. }
  from your code.
  
 But, there’s a big detail we’ve skipped over so far. I said at the beginning of the 
 section that 
 =>
  functions are closely related to 
 this
  binding behavior. In fact, 
 =>
  
 arrow func‐tions are 
 primarily designed
  to alter 
 this
  behavior in a specific way, 
 solving a particu‐lar and common pain point with 
 this
 -aware coding.
  
 The saving of keystrokes is a red herring, a misleading side show at best.
  
 Let’s revisit another example from earlier in this chapter:
  
 var
 controller
 =
 { 
  
  
 makeRequest
 :
 function
 (..){ 
  
  
  
 var
 self
 =
 this
 ;
  
 btn
 .
 addEventListener
 (
 ""click""
 ,
 function
 (){ 
  
  
 // ..
  
  
  
  
 self
 .
 makeRequest
 (..); 
  
  
  
 },
 false
 ); 
  
  
 } 
  
 };
  
 We used the 
 var self = this
  hack, and then referenced 
 self.makeRequest(..)
 , which 
 inside the callback function we’re passing to 
 addEventListener(..)
 , the 
 this 
 binding will not be the same as it is in 
 makeRequest(..)
  itself. In other words, 
 because 
 this
  bindings are dynamic, we fall back to the predictability of lexical 
 scope via the 
 self
  variable.
  
 Herein we finally can see the primary design characteristic of 
 =>
  arrow 
 functions. Inside arrow functions, the 
 this
  binding is not dynamic, but is instead 
 lexical. In the previous snippet, if we used an arrow function for the callback, 
 this
  will be predicta‐bly what we wanted it to be.
  
 Consider:
  
 var
 controller
 =
 { 
  
  
 makeRequest
 :
 function
 (..){ 
  
  
  
 btn
 .
 addEventListener
 (
 ""click""
 ,()
 =>
 { 
   
  
 // ..
  
 Arrow Functions 
  
 | 
  
 49
  
 www.it-ebooks.info",NA
for..of,NA,NA
 Loops,"Joining the 
 for
  and 
 for..in
  loops from the JavaScript we’re all familiar with, ES6 
 adds a 
 for..of
  loop, which loops over the set of values produced by an 
 iterator
 .
  
 The value you loop over with 
 for..of
  must be an 
 iterable
 , or it must be a value 
 which can be coerced/boxed to an object (see the 
 Types & Grammar
  title of this 
 series) that is an iterable. An iterable is simply an object that is able to produce 
 an iterator, which the loop then uses.
  
 Let’s compare 
 for..of
  to 
 for..in
  to illustrate the difference:
  
 for..of Loops 
  
 | 
  
 51
  
 www.it-ebooks.info",NA
Regular Expressions,"Let’s face it: regular expressions haven’t changed much in JS in a long time. So 
 it’s a great thing that they’ve finally learned a couple of new tricks in ES6. We’ll 
 briefly
  
 Regular Expressions 
  
 | 
  
 53",NA
Unicode Flag,"We’ll cover the topic of Unicode in more detail in “Unicode” later in this chapter. 
 Here, we’ll just look briefly at the new 
 u
  flag for ES6+ regular expressions, which 
 turns on Unicode matching for that expression.
  
 JavaScript strings are typically interpreted as sequences of 16-bit characters, 
 which correspond to the characters in the 
 Basic Multilingual Plane
  (
 BMP
 ) 
 (
 http://en.wikipe dia.org/wiki/Plane_%28Unicode%29
 ). But there are many 
 UTF-16 characters that fall outside this range, and so strings may have these 
 multibyte characters in them.
  
 Prior to ES6, regular expressions could only match based on BMP characters, 
 which means that those extended characters were treated as two separate 
 characters for matching purposes. This is often not ideal.
  
 So, as of ES6, the 
 u
  flag tells a regular expression to process a string with the 
 intepre‐tation of Unicode (UTF-16) characters, such that such an extended 
 character will be matched as a single entity.
  
  
 Despite the name implication, “UTF-16” doesn’t strictly mean 
 16 bits. Modern Unicode uses 21 bits, and standards like UTF-8 
 and UTF-16 refer roughly to how many bits are used in the 
 representa‐tion of a character.
  
 An example (straight from the ES6 specification): 𝄞(the musical symbol G-clef) 
 is Uni‐code point U+1D11E (0x1D11E).
  
 If this character appears in a regular expression pattern (like 
 /𝄞/
 ), the standard 
 BMP interpretation would be that it’s two separate characters (0xD834 and 
 0xDD1E) to match with. But the new ES6 Unicode-aware mode means that 
 /𝄞/u
  
 (or the escaped Unicode form 
 /�{1D11E}/u
 ) will match 
 ""𝄞""
  in a string as a 
 single matched charac‐ter.
  
 You might be wondering why this matters? In non-Unicode BMP mode, the 
 pattern is treated as two separate characters, but would still find the match in a 
 string with the 
 ""𝄞""
  character in it, as you can see if you try:
  
 /𝄞/
 .
 test
 (
 ""𝄞-clef""
 );
 // true
  
 The length of the match is what matters. For example:
  
 /^.-clef/
 .
 test
 (
 ""𝄞-clef""
 );
 // false 
 /^.-clef/u.test( ""𝄞-
 clef"" );        // true
  
 54 
  
 | 
  
 Chapter 2: Syntax",NA
Sticky Flag,"Another flag mode added to ES6 regular expressions is 
 y
 , which is often called 
 “sticky mode”. 
 Sticky
  essentially means the regular expression has a virtual 
 anchor at its beginning that keeps it rooted to matching at only the position 
 indicated by the regu‐lar expression’s 
 lastIndex
  property.
  
 To illustrate, let’s consider two regular expressions, the first without sticky 
 mode and the second with:
  
 var
 re1
 =
 /foo/
 ,
  
 str
 =
 ""++foo++""
 ;
  
 re1
 .
 lastIndex
 ;
 // 0
  
 re1
 .
 test
 (
 str
 );
 // true
  
 re1
 .
 lastIndex
 ;
 // 0 -- not updated
  
 re1
 .
 lastIndex
 =
 4
 ;
  
 re1
 .
 test
 (
 str
 );
 // true -- ignored `lastIndex`
  
 re1
 .
 lastIndex
 ;
 // 4 -- not updated
  
 Three things to observe about this snippet:
  
 •
  test(..)
  doesn’t pay any attention to 
 lastIndex
 ’s value, and always just per‐
 forms its match from the beginning of the input string.
  
 • Since our pattern does not have a 
 ^
  start-of-input anchor, the search for 
 ""foo""
  
 is free to move ahead through the whole string looking for a match.
  
 •
  lastIndex
  is not updated by 
 test(..)
 .
  
 Now, let’s try a sticky mode regular expression:
  
 Regular Expressions 
  
 | 
  
 55
  
 www.it-ebooks.info",NA
Regular Expression ,NA,NA
flags,"Prior to ES6, if you wanted to examine a regular expression object to see what 
 flags it had applied, you needed to parse them out — ironically, probably with 
 another regu‐lar expression — from the content of the 
 source
  property, such as:
  
 var
 re
 =
 /foo/ig
 ;
  
 re
 .
 toString
 ();
 // ""/foo/ig""
  
 var
 flags
 =
 re
 .
 toString
 ().
 match
 (
 /\/([gim]*)$/
 )[
 1
 ];
  
 flags
 ;
 // ""ig""
  
 As of ES6, you can now get these values directly, with the new 
 flags
  property:
  
 var
 re
 =
 /foo/ig
 ;
  
 re
 .
 flags
 ;
 // ""gi""
  
 It’s a small nuance, but the ES6 specification calls for the expression’s flags to be 
 listed in this order: 
 ""gimuy""
 , regardless of what order the original pattern was 
 specified with. That’s the difference between 
 /ig
  and 
 ""gi""
 .
  
 No, the order of flags specified or listed doesn’t matter.
  
 Another tweak from ES6 is that the 
 RegExp(..)
  constructor is now 
 flags
 -aware if 
 you pass it an existing regular expression:
  
 var
 re1
 =
 /foo*/y; 
  
 re1
 .
 source
 ;
 // ""foo*"" 
 re1
 .
 flags
 ;
 // ""y""
  
 var
 re2
 =
 new
 RegExp
 (
 re1
 ); 
  
 re2
 .
 source
 ;
 // ""foo*"" 
 re2
 .
 flags
 ;
 // ""y""
  
 var
 re3
 =
 new
 RegExp
 (
 re1
 ,
 ""ig""
 ); 
  
 re3
 .
 source
 ;
 // ""foo*"" 
 re3
 .
 flags
 ;
 // ""gi""
  
 60 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
Number Literal Extensions,"Prior to ES5, number literals looked like the following — the octal form was not 
 offi‐cially specified, only allowed as an extension that browsers had come to de 
 fact agree‐ment on:
  
 var
 dec
 =
 42
 , 
  
 oct
 =
 052
 , 
  
 hex
 =
 0x2a
 ;
  
  
 Though you are specifying a number in different bases, the 
 numb‐er’s mathematic value is what is stored, and the default 
 output interpretation is always base-10. The three variables in 
 the previous snippet all have the 
 42
  value stored in them.
  
 To further illustrate that 
 052
  was a non-standard form extension, consider:
  
 Number
 (
 ""42""
 );
 // 
 42 
  
 Number
 (
 ""052""
 );
 // 
 52 
  
 Number
 (
 ""0x2a""
 );
 // 42
  
 ES5 continued to permit the browser-extended octal form (including such 
 inconsis‐tencies), except that in strict mode, the octal literal (
 052
 ) form is 
 disallowed. This restriction was done mainly because many developers had the 
 habit (from other lan‐guages) of seemingly innocuously prefixing otherwise 
 base-10 numbers with 
 0
 ’s for code alignment purposes, and then running into 
 the accidental fact that they’d changed the number value entirely!
  
 ES6 continues the legacy of changes/variations to how number literals outside 
 base-10 numbers can be represented. There’s now an official octal form, an 
 amended hexadecimal form, and a brand new binary form. For web 
 compatibility reasons, the old octal 
 052
  form will continue to be legal (though 
 unspecified) in non-strict mode, but should really never be used anymore.
  
 Here are the new ES6 number literal forms:
  
 var
 dec
 =
 42
 , 
  
 oct
 =
 0
 o52
 ,
 // or `0O52` :( 
 hex
 =
 0x2a
 ,
 // or `0X2a` 
 :/ 
 bin
 =
 0
 b101010
 ;
 // or `0B101010` :/
  
 The only decimal form allowed is base-10. Octal, hexadecimal, and binary are all 
 integer forms.
  
 Number Literal Extensions 
  
 | 
  
 61
  
 www.it-ebooks.info",NA
Unicode,"Let me just say that this section is not an exhaustive everything-you-ever-
 wanted-to-know-about-Unicode resource. I want to cover what you need to 
 know that’s 
 changing 
 for Unicode in ES6, but we won’t go much deeper than 
 that. Mathias Bynens (
 http:// twitter.com/mathias
 ) has written/spoken 
 extensively and brilliantly about JS and Uni‐code 
 (
 https://mathiasbynens.be/notes/javascript-unicode
 ) 
  
 (
 http://fluentconf.com/ javascript-html-
 2015/public/content/2015/02/18-javascript-loves-unicode
 ).
  
 The Unicode characters that range from 
 0x0000
  to 
 0xFFFF
  contain all the 
 standard printed characters (in various languages) that you’re likely to have 
 seen or interacted with. This group of characters is called the 
 Basic Multilingual 
 Plane
  (
 BMP
 ). The BMP even contains fun symbols like this cool snowman 
 ☃
  
 (U+2603).
  
 There are lots of other extended Unicode characters beyond this BMP set, which 
 range up to 
 0x10FFFF
 . These symbols are often referred to as 
 astral
  symbols, 
 since that’s the name given to set of 16 
 planes
  (e.g., layers/groupings) of 
 characters beyond the BMP. Examples of astral symbols include 𝄞 (U+1D11E) 
 and 
 💩
  (U+1F4A9).
  
 Prior to ES6, JavaScript strings could specify Unicode characters using Unicode 
 escaping, such as:
  
 var
 snowman
 =
 ""☃""
 ;
  
 console
 .
 log
 (
 snowman
 );
 // ""
 ☃
 ""
  
 However, the 
 �XXXX
  Unicode escaping only supports four hexadecimal 
 characters, so you can only represent the BMP set of characters in this way. To 
 represent an astral character using Unicode escaping prior to ES6, you need to 
 use a 
 surrogate pair
  —",NA
Unicode-Aware String Operations,"By default, JavaScript string operations and methods are not sensitive to astral 
 sym‐bols in string values. So, they treat each BMP character individually, even 
 the two sur‐rogate halves that make up an otherwise single astral character. 
 Consider:
  
 var
 snowman
 =
 ""
 ☃
 ""
 ;
  
 snowman
 .
 length
 ;
 // 1
  
 var
 gclef
 =
 ""𝄞""
 ; 
  
 gclef
 .
 length
 ;
 // 2
  
 So, how do we accurately calculate the length of such a string? In this scenario, 
 this trick will work:
  
 var
 gclef
 =
 ""𝄞""
 ;
  
 [...
 gclef
 ].
 length
 ;
 // 1
  
 Array
 .
 from
 (
 gclef
 ).
 length
 ;
 // 1
  
 Recall from the ""
 for..of
  Loops” section earlier in this chapter that ES6 strings 
 have built-in iterators. This iterator happens to be Unicode-aware, meaning it 
 will auto‐matically output an astral symbol as a single value. We take advantage 
 of that using the 
 ...
  spread operator in an array literal, which creates an array of 
 the string’s sym‐bols. Then we just inspect the length of that resultant array. 
 ES6’s 
 Array.from(..) 
 does basically the same thing as 
 [...XYZ]
 , but we’ll cover that 
 utility in detail in Chapter 6.
  
  
 It should be noted that constructing and exhausting an iterator 
 just to get the length of a string is quite expensive on 
 performance, rela‐tively speaking, compared to what a 
 theoretically optimized native utility/property would do.
  
   
  
 Unicode 
  
 | 
  
 63",NA
Character Positioning,"In addition to length complications, what does it actually mean to ask, “what is 
 the character as position 2?” The naive pre-ES6 JavaScript answer comes from 
 charAt(..)
 , which will not respect the atomicity of an astral character, nor will it 
 take into account combining marks.
  
 Consider:
  
 var
 s1
 =
 ""abćd""
 , 
  
 s2
 =
 ""abćd""
 , 
  
 s3
 =
 ""ab�{1d49e}d""
 ;
  
 console
 .
 log
 (
 s1
 );
 // 
 ""abćd"" 
  
 console
 .
 log
 (
 s2
 );
 // 
 ""abćd"" 
  
 console
 .
 log
 (
 s3
 );
 // ""ab
 𝒞
 d""
  
 s1
 .
 charAt
 (
 2
 );
 // ""c"" 
  
 s2
 .
 charAt
 (
 2
 );
 // ""ć"" 
  
 s3
 .
 charAt
 (
 2
 );
 // """" <-- unprintable surrogate 
 s3
 .
 charAt
 (
 3
 );
 // """" <-- 
 unprintable surrogate
  
 So, is ES6 giving us a Unicode-aware verison of 
 charAt(..)
 ? Unfortunately, no. At 
 the time of this writing, there’s a proposal for such a utility that’s under 
 consideration for post-ES6.
  
 But with what we explored in the previous section (and of course with the 
 limitations noted thereof!), we can hack an ES6 answer:
  
 var
 s1
 =
 ""abćd""
 , 
  
 s2
 =
 ""abćd""
 , 
  
 s3
 =
 ""ab�{1d49e}d""
 ;
  
 Unicode 
  
 | 
  
 65
  
 www.it-ebooks.info",NA
Unicode Identifier Names,"Unicode can also be used in identifier names (variables, properties, etc.). Prior to 
 ES6, you could do this with Unicode-escapes, like:
  
 var
 Ω
 =
 42
 ;
  
 // same as: var Ω = 42;
  
 As of ES6, you can also use the earlier explained code point escape syntax:
  
 var �{2B400} = 42;
  
 // same as: var 
  = 42;
  
 There’s a complex set of rules around exactly which unicode characters are 
 allowed. Furthermore, some are allowed only if they’re not the first character of 
 the identifier name.
  
  
 Mathias Bynens has a great post 
 (
 https://mathiasbynens.be/notes/ javascript-identifiers-es6
 ) on 
 all the nitty gritty details.
  
 The reasons for using such unusual characters in identifier names are rather 
 rare and academic. You typically won’t be best served by writing code which 
 relies on these esoteric capabilities.",NA
Symbols,"For the first time in quite awhile, a new primitive type has been added to 
 JavaScript, in ES6: the 
 symbol
 . Unlike the other primitive types, however, 
 symbols don’t have a literal form.
  
 Here’s how you create a symbol:
  
 Symbols 
  
 | 
  
 67",NA
Symbol Registry,"One mild downside to using symbols as in the last few examples is that the 
 EVT_LOGIN 
 and 
 INSTANCE
  variables had to be stored in an outer scope (perhaps 
 even the global scope), or otherwise somehow stored in a publicly available 
 location, so that all parts of the code which need to use the symbols can access 
 them.
  
 To aid in organizing code with access to these symbols, you can create symbol 
 values with the 
 global symbol registry
 . For example:
  
 const
 EVT_LOGIN
 =
 Symbol
 .
 for
 (
 ""event.login""
 );
  
 console
 .
 log
 (
 EVT_LOGIN
 );
 // Symbol(event.login)
  
 And:
  
 function
 HappyFace
 (){
  
 const
 INSTANCE
 =
 Symbol
 .
 for
 (
 ""instance""
 );
  
 if
 (
 HappyFace
 [
 INSTANCE
 ])
 return
 HappyFace
 [
 INSTANCE
 ];
  
 // ..
  
 return
 HappyFace
 [
 INSTANCE
 ]
 =
 {..};
  
 }
  
 Symbol.for(..)
  looks in the global symbol registry to see if a symbol is already 
 stored with the provided description text, and returns it if so. If not, it creates 
 one to return. In other words, the global symbol registry treats symbol values, 
 by description text, as singletons themselves.
  
 But that also means that any part of your application can retrieve the symbol 
 from the registry using 
 Symbol.for(..)
 , as long as the matching description name 
 is used.
  
 Ironically, symbols are basically intended to replace the use of 
 magic strings
  
 (arbitrary string values given special meaning) in your application. But you 
 precisely use 
 magic 
 description string values to uniquely identify/locate them in 
 the global symbol regis‐try!
  
 To avoid accidental collisions, you’ll probably want to make your symbol 
 descriptions quite unique. One easy way of doing that is to include 
 prefix/context/namespacing information in them.
  
 For example, consider a utility like:
  
 function
 extractValues
 (
 str
 ){
  
 var
 key
 =
 Symbol
 .
 for
 (
 ""extractValues.parse""
 ),
  
 re
 =
 extractValues
 [
 key
 ]
 ||
  
 /[^=&]+?=([^&]+?)(?=&|$)/g
 ,
  
 values
 =
 [],
 match
 ;
  
 70 
  
 | 
  
 Chapter 2: Syntax",NA
Symbols as Object Properties,"If a symbol is used as a property/key of an object, it’s stored in a special way 
 that the property will not show up in a normal enumeration of the object’s 
 properties:
  
 var
 o
 =
 { 
  
  
 foo
 :
 42
 , 
  
  
 [
 Symbol
 (
 ""bar""
 )]
 :
 ""hello world""
 , 
  
  
 baz
 :
 true 
  
 };
  
 Symbols 
  
 | 
  
 71",NA
Review,"ES6 adds a heap of new syntax forms to JavaScript, so there’s plenty to learn!
  
 Most of these are designed to ease the pain points of common programming 
 idioms, such as setting default values to function parameters and gathering the 
 “rest” of the parameters into an array. Destructuring is a powerful tool for more 
 concisely express‐ing assignments of values from arrays and nested objects.
  
 While features like 
 =>
  arrow functions appear to also be all about shorter and 
 nicer looking syntax, they actually have very specific behaviors that you should 
 intention‐ally use only in appropriate situations.
  
 Expanded Unicode support, new tricks for regular expressions, and even a new 
 prim‐itive 
 symbol
  type round out the syntactic evolution of ES6.
  
 72 
  
 | 
  
 Chapter 2: Syntax
  
 www.it-ebooks.info",NA
CHAPTER 3,NA,NA
Organization,"Some of the most important changes in ES6 involve improved support for the 
 pat‐terns we already commonly use to organize JavaScript functionality. This 
 chapter will explore Iterators, Generators, Modules, and Classes.",NA
Iterators,"An 
 iterator
  is a structured pattern for pulling information from a source in one-
 at-a-time fashion. This pattern has been around programming for a long time. 
 And to be sure, JS developers have been ad hoc designing and implementing 
 iterators in JS pro‐grams since before anyone can remember, so it’s not at all a 
 new topic.
  
 What ES6 has done is introduce an implicit standardized interface for iterators. 
 Many of the built in data structures in JavaScript will now expose an iterator 
 implementing this standard. And you can also construct your own iterators 
 adhering to the same standard, for maximal interoperability.
  
 Iterators are a way of organizing ordered, sequential, pull-based consumption of 
 data.
  
 For example, you may implement a utility that produces a new unique identifier 
 each time it’s requested. Or you may produce an infinite series of values that 
 rotate through a fixed list, in round-robin fashion. Or you could attach an 
 iterator to a data‐base query result to pull out new rows one at a time.
  
 Though not as common a usage of iterators to this point in JS, iterators can also 
 be thought of as controlling behavior one step at a time. This can be illustrated 
 quite clearly when considering generators (see “Generators” later in this 
 chapter), though you can certainly do the same without generators.
  
 73",NA
Interfaces,"At the time of this writing, ES6 section 25.1.1.2 
 (
 https://people.mozilla.org/~joren dorff/es6-draft.html#sec-iterator-interface
 ) 
 details the 
 Iterator
  interface as having the following requirement:
  
 Iterator [required]
  
  
  next() {method}: retrieves next IteratorResult
  
 There are two optional members which some iterators are extended with:
  
 Iterator [optional]
  
  return() {method}: stops iterator and returns IteratorResult throw() 
 {method}: signals error and returns IteratorResult
  
 The 
 IteratorResult
  interface is specified as:
  
 IteratorResult
  
  
  value {property}: current iteration value or final return value
  
  
  (optional if `undefined`)
  
  
  done {property}: boolean, indicates completion status
  
  
 I call these interfaces implicit not because they’re not explicitly 
 called out in the specification — they are! — but because 
 they’re not exposed as direct objects accessible to code. 
 JavaScript does not, in ES6, support any notion of “interfaces”, 
 so adherence for your own code is purely conventional. 
 However, wherever JS expects an itera‐tor — a 
 for..of
  loop, for 
 instance — what you provide must adhere to these interfaces 
 or the code will fail.
  
 There’s also an 
 Iterable
  interface, which describes objects that must be able to 
 pro‐duce iterators:
  
 Iterable
  
  
  @@iterator() {method}: produces an Iterator
  
 If you recall from “Built-in Symbols” in Chapter 2, 
 @@iterator
  is the special built-
 in symbol representing the method that can produce iterator(s) for the object.
  
 IteratorResult
  
 The 
 IteratorResult
  interface specifies that the return value from any iterator 
 opera‐tion will be an object of the form:
  
 {
 value
 :
 ..,
 done
 :
 true
 /
 false
 }
  
 Built-in iterators will always return values of this form, but it is of course 
 allowed that more properties be present on the return value, as necessary.
  
 74 
  
 | 
  
 Chapter 3: Organization
  
 www.it-ebooks.info",NA
next(),NA,NA
 Iteration,"Let’s look at an array, which is an iterable, and the iterator it can produce to 
 consume its values:
  
 var
 arr
 =
 [
 1
 ,
 2
 ,
 3
 ];
  
 var
 it
 =
 arr
 [
 Symbol
 .
 iterator
 ]();
  
 it
 .
 next
 ();
 // { value: 1, done: false }
  
 it
 .
 next
 ();
 // { value: 2, done: false }
  
 it
 .
 next
 ();
 // { value: 3, done: false }
  
 it
 .
 next
 ();
 // { value: undefined, done: true }
  
 Each time the method located at 
 Symbol.iterator
  (see Chapter 2 and 7) is invoked 
 on this 
 arr
  value, it will produce a new fresh iterator. Most structures will do the 
 same, including all the built-in data structures in JS.
  
 However, it 
 is
  possible to conceive of a structure which could only produce a 
 single iterator (singleton pattern), or perhaps only allow one unique iterator at 
 a time, requiring the current one to be
  
 You’ll notice that the 
 it
  iterator in the previous snippet doesn’t report 
 done: true 
 when you received the 
 3
  value. You have to call 
 next()
  again, in essence going 
 beyond the end of the array’s values, to get the completed signal 
 done: true
 . It 
 may not be clear why until later in this section, but that design decision will 
 typically be considered a best practice.
  
 Primitive string values are also iterables by default:
  
 var
 greeting
 =
 ""hello world""
 ;
  
 var
 it
 =
 greeting
 [
 Symbol
 .
 iterator
 ]();
  
 it
 .
 next
 ();
 // { value: ""h"", done: false }
  
 Iterators 
  
 | 
  
 75
  
 www.it-ebooks.info",NA
Optional: ,NA,NA
return(..),NA,NA
 and ,NA,NA
throw(..),"The optional methods on the iterator interface — 
 return(..)
  and 
 throw(..)
  — are 
 not implemented on most of the built-in iterators. However, they definitely do 
 mean something in the context of generators, so see “Generators” for more 
 specific infor‐mation.
  
 return(..)
  is defined as sending a signal to an iterator that the consuming code is 
 complete and will not be pulling any more values from it. This signal can be used 
 to notify the producer (the iterator responding to 
 next(..)
  calls) to perform any 
 cleanup it may need to do, such as releasing/closing network, database, or file 
 handle resources, etc.
  
 If an iterator has a 
 return(..)
  present and any condition occurs which can 
 automati‐cally be interpreted as abnormal or early termination of consuming 
 the iterator, 
 return(..)
  will automatically be called. You can call 
 return(..)
  
 manually as well.
  
 return(..)
  will return an 
 IteratorResult
  object just like 
 next(..)
  does. In general, the 
 optional value you send to 
 return(..)
  would be sent back as 
 value
  in this 
 Itera 
 torResult
 , though there are nuanced cases where that might not be true.
  
 76 
  
 | 
  
 Chapter 3: Organization",NA
Iterator Loop,"As we covered in the ""
 for..of
 "" section in Chapter 2, the ES6 
 for..of
  loop directly 
 consumes a conforming iterable.
  
 If an iterator is also an iterable, it can be used directly with the 
 for..of
  loop. You 
 make an iterator an iterable by giving it a 
 Symbol.iterator
  method that simply 
 returns the iterator itself:
  
 var
 it
 =
 { 
  
 // make the `it` iterator an iterable 
  
 [
 Symbol
 .
 iterator
 ](){
 returnthis
 ;},
  
  
 next
 (){..}, 
  
  
 .. 
  
 };
  
 it
 [
 Symbol
 .
 iterator
 ]()
 ===
 it
 ;
 // true
  
 Now we can consume the 
 it
  iterator with a 
 for..of
  loop:
  
 for
 (
 var
 vofit
 ){ 
  
  
 console
 .
 log
 (
 v
 ); 
  
 }
  
 To fully understand how such a loop works, let’s consider this more manual 
 version of the previous snippet’s loop:
  
 for
 (
 var
 v
 ,
 res
 ;
 !
 (
 res
 =
 it
 .
 next
 ())
 &&!
 res
 .
 done
 ;){ 
  
 v
 =
 res
 .
 value
 ; 
  
  
 console
 .
 log
 (
 v
 ); 
  
 }
  
 Iterators 
  
 | 
  
 77
  
 www.it-ebooks.info",NA
Custom Iterators,"In addition to the standard built-in iterators, you can make your own! All it 
 takes to make them interoperate with ES6’s consumption facilities (e.g., the 
 for..of
  loop and the 
 ...
  operator) is to adhere to the proper interface(s).
  
 Let’s try constructing an iterator that produces the infinite series of numbers in 
 the Fibonacci sequence:
  
 var
 Fib
 =
 { 
  
  
 [
 Symbol
 .
 iterator
 ](){ 
  
  
  
 var
 n1
 =
 1
 ,
 n2
 =
 1
 ;
  
 return
 { 
  
 // make the iterator an iterable 
  
 [
 Symbol
 .
 iterator
 ](){
 returnthis
 ;},
  
 next
 (){ 
  
  
 var
 current
 =
 n2
 ; 
  
  
 n2
 =
 n1
 ; 
  
  
 n1
 =
 n1
 +
 current
 ; 
  
  
 return
 {
 value
 :
 current
 ,
 done
 :
 false
 }; },
  
 return
 (
 v
 ){ 
  
  
 console
 .
 log
 ( 
  
  
  
 ""Fibonacci sequence abandoned."" 
  
  
 ); 
  
  
 return
 {
 value
 :
 v
 ,
 done
 :
 true
 };
  
 78 
  
 | 
  
 Chapter 3: Organization
  
 www.it-ebooks.info",NA
Iterator Consumption,"We’ve already shown consuming an iterator item-by-item with the 
 for..of
  loop. 
 But there are other ES6 structures which can consume iterators.
  
 Let’s consider the iterator attached to this array (though any iterator we choose 
 would have the following behaviors):
  
 var
 a
 =
 [
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 ];
  
 The 
 ...
  spread operator fully exhausts an iterator. Consider:
  
 function
 foo
 (
 x
 ,
 y
 ,
 z
 ,
 w
 ,
 p
 ){
  
 console
 .
 log
 (
 x
 +
 y
 +
 z
 +
 w
 +
 p
 );
  
 }
  
 foo
 (...
 a
 );
 // 15
  
 ...
  can also spread an iterator inside an array:
  
 var
 b
 =
 [
 0
 ,...
 a
 ,
 6
 ];
  
 b
 ;
 // [0,1,2,3,4,5,6]
  
 Array destructuring (see “Destructuring” in Chapter 2) can partially or 
 completely (if paired with a 
 ...
  rest/gather operator) consume an iterator:
  
 var
 it
 =
 a
 [
 Symbol
 .
 iterator
 ]();
  
 var
 [
 x
 ,
 y
 ]
 =
 it
 ;
 // take just the first two elements from `it`
  
 var
 [
 z
 ,...
 w
 ]
 =
 it
 ;
 // take the third, then the rest all at once
  
 // is `it` is fully exhausted? Yep.
  
 it
 .
 next
 ();
 // { value: undefined, done: true }
  
 82 
  
 | 
  
 Chapter 3: Organization
  
 www.it-ebooks.info",NA
Generators,"All functions run-to-completion, right? That is, once a function starts running, it 
 fin‐ishes before anything else can interrupt.
  
 Or, so it’s been for the whole history of JavaScript up to this point. As of ES6, a 
 new somewhat exotic form of function is being introduced, called a generator. A 
 generator can pause itself in mid-execution, and can be resumed either right 
 away or at a later time. So, it clearly does not hold the run-to-completion 
 guarantee that normal func‐tions do.
  
 Moreover, each pause/resume cycle in mid-execution is an opportunity for two-
 way message passing, where the generator can return a value, and the 
 controlling code that resumes it can send a value back in.
  
 As with iterators in the previous section, there are multiple ways to think about 
 what a generator is, or rather what it’s most useful for. There’s no one right 
 answer, but we’ll try to consider several angles.
  
  
 See the 
 Async & Performance
  title of this series for more 
 informa‐tion about generators, and also see Chapter 4 of this 
 title.",NA
Syntax,"The generator function is declared with this new syntax:
  
 function
 *
 foo
 (){
  
 // ..
  
 }
  
 The position of the 
 *
  is not functionally relevant. The same declaration could be 
 writ‐ten as any of the following:
  
 function
 *
 foo
 (){..}
  
 function
 *
 foo
 (){..}
  
 function
 *
 foo
 (){..}
  
 function
 *
 foo
 (){..}
  
 ..
  
 Generators 
  
 | 
  
 83
  
 www.it-ebooks.info",NA
Iterator Control,"We briefly introduced the concept a few sections ago that generators are 
 controlled by iterators. Let’s fully dig into that now.
  
 Recall the recursive 
 *foo(..)
  from the previous section. Here’s how we’d run it:
  
 function
 *
 foo
 (
 x
 ){ 
  
  
 if
 (
 x
 <
 3
 ){ 
  
  
  
 x
 =
 yield
 *
 foo
 (
 x
 +
 1
 ); 
  
  
 } 
  
  
 return
 x
 *
 2
 ; 
  
 }
  
 var
 it
 =
 foo
 (
 1
 ); 
  
 it
 .
 next
 ();
 // { value: 24, done: true }
  
 In this case, the generator doesn’t really ever pause, as there’s no 
 yield ..
  
 expression. Instead, 
 yield *
  just keeps the current iteration step going via the 
 recursive call. So, just one call to the iterator’s 
 next()
  function fully runs the 
 generator.
  
 Now let’s consider a generator which will have multiple steps and thus multiple 
 pro‐duced values:
  
 function
 *
 foo
 (){ 
  
  
 yield
 1
 ; 
  
  
 yield
 2
 ; 
  
  
 yield
 3
 ; 
  
 }
  
 We already know we can consume an iterator, even one attached to a generator 
 like 
 *foo()
 , with a 
 for..of
  loop:
  
 for
 (
 var
 voffoo
 ()){ 
  
  
 console
 .
 log
 (
 v
 ); 
  
 } 
  
 // 1 2 3
  
  
 The 
 for..of
  loop requires an iterable. A generator function refer‐
  
   
 ence (like 
 foo
 ) by itself is not an iterable; you must execute it with
  
 foo()
  to get the iterator (which is also an iterable, as we explained
  
 earlier in this chapter). You could theoretically extend the 
 Genera
  
 torPrototype
  (the prototype of all generator functions) with a 
 Sym
  
 bol.iterator
  function which essentially just did 
 return this()
 .
  
 That would make the 
 foo
  reference itself an iterable, which means
  
 for (var v of foo) { .. }
  — notice no 
 ()
  on 
 foo
  — works.
  
  
 Generators 
  
 | 
  
 89",NA
Early Completion,"As we covered earlier in this chapter, the iterator attached to a generator 
 supports the optional 
 return(..)
  and 
 throw(..)
  methods. Both of them have the 
 effect of abort‐ing a paused generator immediately.
  
 Consider:
  
 function
 *
 foo
 (){ 
  
  
 yield
 1
 ; 
  
  
 yield
 2
 ; 
  
  
 yield
 3
 ; 
  
 }
  
 var
 it
 =
 foo
 ();
  
 it
 .
 next
 ();
 // { value: 1, done: false }
  
 it
 .
 return
 (
 42
 );
 // { value: 42, done: true }
  
 it
 .
 next
 ();
 // { value: undefined, done: true }
  
 return(x)
  is kind of like forcing a 
 return x
  to be processed at exactly that 
 moment, such that you get the specified value right back. Once a generator is 
 completed, either normally or early as shown, it no longer processes any code or 
 returns any values.
  
 In addition to 
 return(..)
  being callable manually, it’s also called automatically at 
 the end of iteration by any of the ES6 constructs that consume iterators, such as 
 the 
 for..of
  loop and the 
 ...
  spread operator.
  
 The purpose for this capability is so the generator can be notified if the 
 controlling code is no longer going to iterate over it anymore, so that it can 
 perhaps do any cleanup tasks (freeing up resources, resetting status, etc.). 
 Identical to a normal func‐tion cleanup pattern, the main way to accomplish this 
 is to use a 
 finally
  clause:
  
 function
 *
 foo
 (){ 
  
  
 try
 { 
  
  
  
 yield
 1
 ; 
  
  
  
 yield
 2
 ; 
  
  
  
 yield
 3
 ; 
  
  
 } 
  
  
 finally
 { 
  
  
  
 console
 .
 log
 (
 ""cleanup!""
 ); 
  
  
 } 
  
 }
  
 for
 (
 var
 voffoo
 ()){ 
  
  
 console
 .
 log
 (
 v
 ); 
  
 } 
  
 // 1 2 3 
  
 // cleanup!
  
 92 
  
 | 
  
 Chapter 3: Organization",NA
Error Handling,"As we’ve already hinted, error handling with generators can be expressed with 
 try..catch
 , which works in both inbound and outbound directions:
  
 function
 *
 foo
 (){ 
  
  
 try
 { 
  
  
  
 yield
 1
 ; 
  
  
 } 
  
  
 catch
 (
 err
 ){ 
  
  
  
 console
 .
 log
 (
 err
 ); 
  
  
 }
  
 yield
 2
 ;
  
  
 throw
 ""Hello!""
 ; 
  
 }
  
 94 
  
 | 
  
 Chapter 3: Organization
  
 www.it-ebooks.info",NA
Transpiling a Generator,"Is it possible to represent a generator’s capabilities prior to ES6? It turns out it 
 is, and there are several great tools which do so, including most notably the 
 Regenerator (
 https://facebook.github.io/regenerator/
 ) tool from Facebook.
  
 But just to better understand generators, let’s try our hand at manually 
 converting. Basically, we’re going to create a simple closure-based state 
 machine.
  
 We’ll keep our source generator really simple:
  
 function
 *
 foo
 (){ 
  
  
 var
 x
 =
 yield
 42
 ; 
  
  
 console
 .
 log
 (
 x
 ); 
  
 }
  
 To start, we’ll need a function called 
 foo()
  that we can execute, which needs to 
 return an iterator:
  
 function
 foo
 (){ 
  
  
 // ..
  
 return
 { 
  
  
 next
 :
 function
 (
 v
 ){ 
  
  
  
 // ..
  
 }
  
  
  
 // we'll skip `return(..)` and `throw(..)` 
  
 }; 
  
 }
  
 96 
  
 | 
  
 Chapter 3: Organization",NA
Generator Uses,"So, now that we much more deeply understand how generators work, what are 
 they useful for?
  
 We’ve seen two major patterns:
  
 •
  Producing a series of values:
  This usage can be simple like random strings or 
 incremented numbers, or it can represent more structured data access, such 
 as iterating over rows returned from a database query.
  
 Either way, we use the iterator to control a generator so that some logic can be 
 invoked for each call to 
 next(..)
 . Normal iterators on data structures merely pull 
 values without any controlling logic. * 
 Queue of tasks to perform serially:
  This 
 usage often represents flow control for the steps in an algorithm, where each 
 step requires retrieval of data from some external source. The fulfillment of 
 each piece of data may be immediate, or may be asynchronously delayed.
  
 From the perspective of the code inside the generator, the details of sync or 
 async at a 
 yield
  point are entirely opaque. Moreover, these details are 
 intentionally abstracted away, such as not to obscure the natural sequential 
 expression of steps with such implementation complications. Abstraction also 
 means the implementations can be swapped/refactored often without touching 
 the code in the generator at all.
  
 When generators are viewed in light of these uses, they become a lot more than 
 just a different or nicer syntax for a manual state machine. They are a powerful 
 abstraction tool for organizing and controlling orderly production and 
 consumption of data.",NA
Modules,"I don’t think it’s an exaggeration to suggest that the single most important code 
 orga‐nization pattern in all of JavaScript is, and always has been, the module. 
 For myself, and I think for a large cross-section of the community, the module 
 pattern drives the vast majority of code.
  
 98 
  
 | 
  
 Chapter 3: Organization",NA
The Old Way,"The traditional module pattern is based on an outer function with inner 
 variables and functions, and a returned “public API” with methods that have 
 closure over the inner data and capabilities. It’s often expressed like this:
  
 function
 Hello
 (
 name
 ){ 
  
  
 function
 greeting
 (){ 
  
  
  
 console
 .
 log
 (
 ""Hello ""
 +
 name
 +
 ""!""
 ); 
  
 }
  
  
 // public API 
  
  
 return
 { 
  
  
  
 greeting
 :
 greeting 
  
  
 }; 
  
 }
  
 var
 me
 =
 Hello
 (
 ""Kyle""
 ); 
  
 me
 .
 greeting
 ();
 // Hello Kyle!
  
 This 
 Hello(..)
  module can produce multiple instances by being called subsequent 
 times. Sometimes, a module is only called for as a singleton — just needs one 
 instance— in which case a slight variation on the previous snippet, using an 
 IIFE, is common:
  
 var
 me
 =
 (
 function
 Hello
 (
 name
 ){ 
  
  
 function
 greeting
 (){ 
  
  
  
 console
 .
 log
 (
 ""Hello ""
 +
 name
 +
 ""!""
 ); 
  
 }
  
  
 // public API 
  
  
 return
 { 
  
  
  
 greeting
 :
 greeting 
  
  
 }; 
  
 })(
 ""Kyle""
 );
  
 me
 .
 greeting
 ();
 // Hello Kyle!
  
 This pattern is tried and tested. It’s also flexible enough to have a wide 
 assortment of variations for a number of different scenarios.
  
 One of the most common is the Asynchronous Module Definition (AMD), and 
 another is the Universal Module Definition (UMD). We won’t cover the 
 particulars of these patterns and techniques here, but they’re explained 
 extensively in many places online.",NA
Moving Forward,"As of ES6, we no longer need to rely on the enclosing function and closure to 
 provide us with module support. ES6 modules have first class syntactic and 
 functional sup‐port.
  
 Modules 
  
 | 
  
 99
  
 www.it-ebooks.info",NA
The New Way,"The two main new keywords that enable ES6 classes are 
 import
  and 
 export
 . I 
 imag‐ine their overall purposes are obvious enough I don’t need to waste ink 
 explaining. However, there’s lots of nuance to the syntax, so let’s take a deeper 
 look.
  
  
 An important detail that’s easy to overlook: both 
 import
  and 
 export
  must always appear in the top-level scope of their 
 respective usage. For example, you cannot put either an 
 import
  
 or 
 export 
 inside an 
 if
  conditional; they must appear outside of 
 all blocks and functions.
  
 `export`ing API Members
  
 The 
 export
  keyword is either put in front of a declaration, or used as an operator 
 (of sorts) with a special list of bindings to export. Consider:
  
 exportfunction
 foo
 (){
  
 // ..
  
 }
  
 exportvar
 awesome
 =
 42
 ;
  
 var
 bar
 =
 [
 1
 ,
 2
 ,
 3
 ];
  
 export
 {
 bar
 };
  
 Another way of expressing the same exports:
  
 function
 foo
 (){
  
 // ..
  
 }
  
 var
 awesome
 =
 42
 ;
  
 var
 bar
 =
 [
 1
 ,
 2
 ,
 3
 ];
  
 export
 {
 foo
 ,
 awesome
 ,
 bar
 };
  
 These are all called 
 named exports
 , since you are in effect exporting the name 
 bind‐ings of the variables/functions/etc.
  
 Anything you don’t 
 label
  with 
 export
  stays private inside the scope of the 
 module. That is, even though something like 
 var bar = ..
  looks like it’s declaring at 
 the top-level global scope, the top-level scope is actually the module itself; there 
 is no global scope in modules.
  
 102 
  
 | 
  
 Chapter 3: Organization",NA
Circular Module Dependency,"A imports B. B imports A. How does this actually work?
  
 I’ll state off the bat that designing systems with intentional circular dependency 
 is generally something I try to avoid. That having been said, I recognize there 
 are rea‐sons people do this and it can solve some sticky design situations.
  
 Let’s consider how ES6 handles this. First, module 
 ""A""
 :
  
 import
 barfrom
 ""B""
 ;
  
 exportdefaultfunction
 foo
 (
 x
 ){
  
 if
 (
 x
 >
 10
 )
 return
 bar
 (
 x
 -
 1
 );
  
 return
 x
 *
 2
 ;
  
 }
  
 Modules 
  
 | 
  
 11
 1
  
 www.it-ebooks.info",NA
Module Loading,"We asserted at the beginning of this “Modules” section that the 
 import
  statement 
 uses a separate mechanism, provided by the hosting environment (browser, 
 Node.js, etc.), to actually resolve the module specifier string into some useful 
 instruction for finding and loading the desired module. That mechanism is the 
 system 
 Module Loader
 .
  
 The default module loader provided by the environment will interpret a module 
 specifier as a URL if in the browser, and (generally) as a local file system path if 
 on a server such as Node.js. The default behavior is to assume the loaded file is 
 authored in the ES6 standard module format.
  
 Moreover, you will be able to load a module into the browser via an HTML tag, 
 simi‐lar to how current script programs are loaded. At the time of this writing, 
 it’s not fully clear if this tag will be 
 <script type=""module"">
  or 
 <module>
 . ES6 
 doesn’t control that decision, but discussions in the appropriate standards 
 bodies are already well along in parallel of ES6.
  
 Whatever the tag looks like, you can be sure that under the covers it will use the 
 default loader (or a customized one you’ve pre-specified — see below).
  
 Just like the tag you’ll use in markup, the module loader itself is not specified by 
 ES6. It is a separate, parallel standard (
 http://whatwg.github.io/loader/
 ) 
 controlled currently by the WHATWG browser standards group.
  
 At the time of this writing, the following discussions reflect the expected API 
 design, but of course things are subject to change.
  
 Loading Modules Outside Of Modules
  
 One use for interacting directly with the module loader is if a non-module needs 
 to load a module. Consider:
  
 // normal script loaded in browser via `<script>`,
  
 // `import` is illegal here
  
 Modules 
  
 | 
  
 11
 3",NA
Classes,"From nearly the beginning of JavaScript, syntax and development patterns have 
 all strived (read: struggled) to put on a facade of supporting class-oriented 
 development. With things like 
 new
  and 
 instanceof
  and a 
 .constructor
  property, 
 who couldn’t help but be intrigued that JS had classes hidden somewhere inside 
 its prototype sys‐tem?
  
 Of course, JS “classes” aren’t nearly the same as traditional classical classes. The 
 differ‐ences are well documented, so I won’t belabor that point any further here.
  
  
 To learn more about the patterns used in JS to fake “classes”, 
 and an alternate view of prototypes called “delegation”, see the 
 second half of the 
 this & Object Prototypes
  title of this series.",NA
class,"Even though JS’s prototype mechanism doesn’t work like traditional classes, 
 that doesn’t stop the strong tide of demand on the language to extend the 
 syntactic sugar so that expressing “classes” looks more like real classes. Enter 
 the ES6 
 class
  keyword and its associated mechanism.
  
 This feature is the result of a highly contentious and drawn out debate, and 
 represents a smaller subset compromise from several strongly-opposed views 
 on how to approach JS classes. Most developers who want full classes in JS will 
 find parts of the new syntax quite inviting, but will find important bits still 
 missing. Don’t worry, though. TC39 is already working on additional features to 
 augment classes in the post-ES6 timeframe.
  
 At the heart of the new ES6 class mechanism is the 
 class
  keyword, which 
 identifies a 
 block
  where the contents define the members of a function’s 
 prototype. Consider:
  
 class
 Foo
 {
  
 constructor
 (
 a
 ,
 b
 ){
  
 this
 .
 x
 =
 a
 ;
  
 this
 .
 y
 =
 b
 ;
  
 }
  
 gimmeXY
 (){
  
 returnthis
 .
 x
 *
 this
 .
 y
 ;
  
 }
  
 }
  
 Some things to note:
  
 Classes 
  
 | 
  
 11
 5",NA
extends,NA,NA
 and ,NA,NA
super,"ES6 classes also have syntax sugar for establishing the 
 [[Prototype]]
  delegation 
 link between two function prototypes — commonly mislabeled “inheritance” or 
 confus‐ingly labeled “prototype inheritance"" — using the class-oriented familiar 
 terminology 
 extends
 :
  
 class
 Bar
 extends
 Foo
 { 
  
  
 constructor
 (
 a
 ,
 b
 ,
 c
 ){ 
  
  
  
 super
 (
 a
 ,
 b
 ); 
  
  
  
 this
 .
 z
 =
 c
 ; 
  
  
 }
  
  
 gimmeXYZ
 (){ 
  
  
  
 returnsuper
 .
 gimmeXY
 ()
 *
 this
 .
 z
 ; 
  
  
 } 
  
 }
  
 var
 b
 =
 new
 Bar
 (
 5
 ,
 15
 ,
 25
 );
  
 b
 .
 x
 ;
 // 5 
  
 b
 .
 y
 ;
 // 15 
  
 b
 .
 z
 ;
 // 25 
  
 b
 .
 gimmeXYZ
 ();
 // 1875
  
 A significant new addition is 
 super
 , which is actually something not directly 
 possible (without some unfortunate hack tradeoffs). In the constructor, 
 super
  
 automatically refers to the “parent constructor”, which in the previous example 
 is 
 Foo(..)
 . In a method, it refers to the “parent object”, such that you can then 
 make a property/ method access off it, such as 
 super.gimmeXY()
 .
  
 Bar extends Foo
  of course means to link the 
 [[Prototype]]
  of 
 Bar.prototype
  to 
 Foo.prototype
 . So, 
 super
  in a method like 
 gimmeXYZ()
  specifically means 
 Foo.proto type
 , whereas 
 super
  means 
 Foo
  when used in the 
 Bar
  constructor.
  
 Classes 
  
 | 
  
 11
 7
  
 www.it-ebooks.info",NA
new.target,"ES6 introduces a new concept called a “Meta Property”, in the form of 
 new.target
 . If that looks strange, it is; pairing a keyword with a 
 .
  and a property 
 name is definitely out of the ordinary pattern for JS.
  
 new.target
  is a new “magical” value available in all functions, though in normal 
 functions it will always be 
 undefined
 . In any constructor, 
 new.target
  always 
 points at the constructor 
 new
  directly invoked, even if the constructor is in a 
 parent class and was delegated to by a 
 super(..)
  call from a child constructor. 
 Consider:
  
 class
 Foo
 { 
  
  
 constructor
 (){ 
  
  
  
 console
 .
 log
 (
 ""Foo: ""
 ,
 new
 .
 target
 .
 name
 ); 
  
 } 
  
 }
  
 class
 Bar
 extends
 Foo
 { 
  
  
 constructor
 (){ 
  
  
  
 super
 (); 
  
  
  
 console
 .
 log
 (
 ""Bar: ""
 ,
 new
 .
 target
 .
 name
 ); 
  
 } 
  
  
 baz
 (){ 
  
  
  
 console
 .
 log
 (
 ""baz: ""
 ,
 new
 .
 target
 ); 
  
  
 } 
  
 }
  
 var
 a
 =
 new
 Foo
 (); 
  
 // Foo: Foo
  
 var
 b
 =
 new
 Bar
 (); 
  
 // Foo: Bar 
  
 // Bar: Bar
  
 b
 .
 baz
 (); 
  
 // baz: undefined
  
 The 
 new.target
  meta property doesn’t have much purpose in class constructors, 
 except accessing a static property/method (see the next section).
  
 If 
 new.target
  is 
 undefined
 , you know the function was not called with 
 new
 . You 
 can then force a 
 new
  invocation if that’s necessary.",NA
static,"When a subclass 
 Bar
  extends a parent class 
 Foo
 , we already observed that 
 Bar.proto type
  is 
 [[Prototype]]
 -linked to 
 Foo.prototype
 . But additionally, 
 Bar()
  is 
 [[Prototype]]
 -linked to 
 Foo()
 . That part may not have such an obvious reasoning.
  
 122 
  
 | 
  
 Chapter 3: Organization
  
 www.it-ebooks.info",NA
Review,"ES6 introduces several new features that aide in code organization:
  
 • Iterators provide sequential access to data or operations. They can be 
 consumed by new language features like 
 for..of
  and 
 ...
 .
  
 • Generators are locally pause/resume capable functions controlled by an 
 iterator. They can be used to programmatically (and interactively, through 
 yield
 / 
 next(..)
  message passing) 
 generate
  values to be consumed via 
 iteration.
  
 • Modules allow private encapsulation of implementation details with a 
 publicly exported API. Module definitions are file-based, singleton instances, 
 and stati‐cally resolved at compile time.
  
 • Classes provide cleaner syntax around prototype-based coding. The addition 
 of 
 super
  also solves tricky issues with relative references in the 
 [[Prototype]] 
 chain.
  
 124 
  
 | 
  
 Chapter 3: Organization
  
 www.it-ebooks.info",NA
CHAPTER 4,NA,NA
Async Flow Control,"It’s no secret if you’ve written any significant amount of JavaScript that 
 asynchronous programming is a required skill. The primary mechanism for 
 managing asynchrony has been the function callback.
  
 However, ES6 adds a new feature which helps address significant shortcomings 
 in the callbacks-only approach to async: 
 Promises
 . In addition, we can revisit 
 generators (from the previous chapter) and see a pattern for combining the two 
 that’s a major step forward in async flow control programming in JavaScript.",NA
Promises,"Let’s clear up some misconceptions: Promises are not about replacing callbacks. 
 Promises provide a trustable intermediary — that is, between your calling code 
 and the async code that will perform the task — to manage callbacks.
  
 Another way of thinking about a promise is as an event listener, upon which you 
 can register to listen for an event that lets you know when a task has completed. 
 It’s an event that will only ever fire once, but it can be thought of as an event 
 nonetheless.
  
 Promises can be chained together, which can sequence a series of 
 asychronously-completing steps. Together with higher-level abstractions like 
 the 
 all(..)
  method —in classic terms, a “gate"" — and the 
 race(..)
  method — in 
 classic terms, a “latch"" —Promise chains provide an approximation of async 
 flow control.
  
 Yet another way of conceptualizing a Promise is that it’s a 
 future value
 , a time-
 independent container wrapped around a value. This container can be reasoned 
 about identically whether the underlying value is final or not. Observing the 
 resolu‐tion of a Promise extracts this value once available. In other words, a 
 Promise is said to be the async version of a sync function’s return value.
  
 127",NA
Making And Using Promises,"To construct a Promise instance, use the 
 Promise(..)
  constructor:
  
 var
 p
 =
 new
 Promise
 (
 function
 (
 resolve
 ,
 reject
 ){ 
  
 // .. 
  
 });
  
 The two parameters provided to the 
 Promise(..)
  constructor are functions, and 
 are generally named 
 resolve(..)
  and 
 reject(..)
 , respectively. They are used as:
  
 • If you call 
 reject(..)
 , the promise is rejected, and if any value is passed to 
 reject(..)
 , it is set as the reason for rejection.
  
 • If you call 
 resolve(..)
  with no value, or any non-Promise value, the promise is 
 fulfilled.
  
 • If you call 
 resolve(..)
  and pass another promise, this promise simply adopts 
 the state — whether immediate or eventual — of the passed promise (either 
 ful‐fillment or rejection).
  
 Here’s how you’d typically use a Promise to refactor a callback-reliant function 
 call. If you start out with an 
 ajax(..)
  utility that expects to be able to call an error-
 first style callback:
  
 function
 ajax
 (
 url
 ,
 cb
 ){ 
  
  
 // make request, eventually call `cb(..)` 
 }
  
 // ..
  
 ajax
 (
 ""http://some.url.1""
 ,
 function
 handler
 (
 err
 ,
 contents
 ){ 
  
 if
 (
 err
 ){ 
  
  
  
 // handle ajax error 
  
  
 } 
  
  
 else
 { 
  
  
  
 // handle `contents` success
  
 128 
  
 | 
  
 Chapter 4: Async Flow Control
  
 www.it-ebooks.info",NA
Thenables,"Promises are genuine instances of the 
 Promise(..)
  constructor. However, there 
 are Promise-like objects which, generally, can interoperate with the Promise 
 mecha‐nisms, called 
 thenables
 .
  
 Any object (or function) with a 
 then(..)
  function on it is assumed to be a 
 thenable. Any place where the Promise mechanisms can accept and adopt the 
 state of a genuine Promise, they can also handle a thenable.
  
 Thenables are basically a general label for any Promise-like value that may have 
 been created by some other system than the actual 
 Promise(..)
  constructor. In 
 that per‐spective, a thenable is generally less trustable than a genuine promise. 
 Consider this misbehaving thenable, for example:
  
 var
 th
 =
 {
  
 then
 :
 function
 thener
 (
 fulfilled
 ){
  
 // call `fulfilled(..)` once every 100ms forever
  
 setInterval
 (
 fulfilled
 ,
 100
 );
  
 }
  
 };
  
 If you received that thenable and chained off it with 
 th.then(..)
 , you’d likely be 
 sur‐prised that your fulfillment handler is called repeatedly, when normal 
 Promises are supposed to only ever be resolved once.
  
 Generally, if you’re receiving what purports to be a Promise or thenable back 
 from some other system, you shouldn’t just trust it blindly. In the next section, 
 we’ll see a utility included with ES6 Promises that helps address this trust 
 concern.
  
 But to further understand the perils of this issue, consider that 
 any
  object in 
 any
  
 piece of code that’s ever been defined to have a method on it called 
 then(..)
  can 
 be poten‐tially confused as a thenable — if used with Promises, of course — 
 regardless of if that thing was ever intended to even remotely be related to 
 Promise-like async coding.
  
 Prior to ES6 there was never any special reservation made on methods called 
 then(..)
 , and as you can imagine there’s been at least a few cases where that 
 method name has been chosen prior to Promises ever showing up on the radar 
 screen. The most likely case of mistaken-thenable will be async libraries which 
 use 
 then(..)
  but which are not strictly Promises-compliant — there are several 
 out in the wild.
  
 The onus will be on you to guard against directly using values with the Promise 
 mechanism that would be incorrectly assumed to be a thenable.",NA
Promise,NA,NA
 API,"The 
 Promise
  API also provides some static methods for working with Promises.",NA
Generators + Promises,"It 
 is
  possible to express a series of promises in a chain to represent the async 
 flow control of your program. Consider:
  
 step1
 () 
  
 .
 then
 ( 
  
  
 step2
 , 
  
  
 step2Failed 
  
 ) 
  
 .
 then
 ( 
  
  
 function
 (
 msg
 ){ 
  
  
  
 return
 Promise
 .
 all
 ([ 
  
  
  
  
 step3a
 (
 msg
 ), 
  
  
  
  
 step3b
 (
 msg
 ), 
  
  
  
  
 step3c
 (
 msg
 ) 
  
  
  
 ]) 
  
  
 } 
  
 ) 
  
 .
 then
 (
 step4
 );
  
 However, there’s a much better option for expressing async flow control, and it 
 will probably be much more preferable in terms of coding style than long 
 promise chains. We can use what we learned in Chapter 3 about generators to 
 express our async flow control.
  
 The important pattern to recognize: a generator can yield a promise, and that 
 promise can then be wired to resume the generator with its fulfillment value.
  
 Consider the previous snippet’s async flow control expressed with a generator:
  
 function
 *
 main
 (){ 
  
  
 var
 ret
 =
 yield
 step1
 ();
  
 try
 { 
  
  
 ret
 =
 yield
 step2
 (
 ret
 ); 
  
 } 
  
 catch
 (
 err
 ){ 
  
  
 ret
 =
 yield
 step2Failed
 (
 err
 ); 
  
 }
  
 ret
 =
 yield
 Promise
 .
 all
 ([ 
  
 step3a
 (
 ret
 ), 
  
 step3b
 (
 ret
 ), 
  
 step3c
 (
 ret
 )
  
 134 
  
 | 
  
 Chapter 4: Async Flow Control
  
 www.it-ebooks.info",NA
Review,"As JavaScript continues to mature and grow in its widespread adoption, 
 asynchro‐nous programming is more and more of a central concern. Callbacks 
 are not fully sufficient for these tasks, and totally fall down the more 
 sophisticated the need.
  
 Thankfully, ES6 adds Promises to address one of the major shortcomings of 
 callbacks: lack of trust in predictable behavior. Promises represent the future 
 completion value from a potentially-async task, normalizing behavior across 
 sync and async bound‐aries.
  
 136 
  
 | 
  
 Chapter 4: Async Flow Control",NA
CHAPTER 5,NA,NA
Collections,"Structured collection and access to data is a critical component of just about any 
 JS program. From the beginning of the language up to this point, the array and 
 the object have been our primary mechanism for creating data structures. Of 
 course, many higher-level data structures have been built on top of these, as 
 user-land libra‐ries.
  
 As of ES6, some of the most useful (and performance-optimizing!) data structure 
 abstractions have been added as native components of the language.
  
 We’ll start this chapter first by looking at 
 Typed Arrays
 , which were technically 
 con‐temporary to ES5 efforts, but which prior to ES6 were only standardized by 
 the web platform and not JavaScript. As of ES6, these have been adopted directly 
 by the lan‐guage specification, which gives them first-class status.
  
 Then we’ll look at Maps and Sets, as well as their weak (“weak” in relation to 
 mem‐ory/garbage collection) counterparts.",NA
Typed Arrays,"As we cover in the 
 Types & Grammar
  title of this series, JS does have a set of 
 built-in types, like 
 number
  and 
 string
 . It’d be tempting to look at a feature named 
 “typed array” and assume it means an array of a specific type of values, like an 
 array of only strings.
  
 However, typed arrays are really more about providing structured access to 
 binary data using array-like semantics (indexed access, etc.). The “type” in the 
 name refers to a “view” layered on type of the bucket of bits, which is essentially 
 a mapping of whether the bits should be viewed as an array of 8-bit signed 
 integers, 16-bit signed integers, etc.
  
 139
  
 www.it-ebooks.info",NA
Endianness,"It’s very important to understand that the 
 arr
  is mapped using the endian-
 setting (big-endian or little-endian) of the platform the JS is running on. This can 
 be an issue if the binary data is created with one endianness but interpreted on 
 a platform with the opposite endianness.
  
 Endian means if the low-order byte (collection of 8-bits) of a multi-byte number 
 —such as the 16-bit unsigned ints we created in the earlier snippet — is on the 
 right or the left of the number’s bytes.
  
 For example, let’s imagine the base-10 number 
 3085
 , which takes 16-bits to 
 represent. If you have just one 16-bit number container, it’d be represented in 
 binary as 
 0000110000001101
  (hexadecimal 
 0c0d
 ) regardless of endianness.
  
 But if 
 3085
  was represented with two 8-bit numbers, the endianness would 
 signifi‐cantly affect its storage in memory:
  
 •
  0000110000001101
  / 
 0c0d
  (big endian)
  
 •
  0000110100001100
  / 
 0d0c
  (little endian)
  
 140 
  
 | 
  
 Chapter 5: Collections
  
 www.it-ebooks.info",NA
Multiple Views,"A single buffer can have multiple views attached to it, such as:
  
 var
 buf
 =
 new
 ArrayBuffer
 (
 2
 );
  
 var
 view8
 =
 new
 Uint8Array
 (
 buf
 ); 
  
 var
 view16
 =
 new
 Uint16Array
 (
 buf
 );
  
 view16
 [
 0
 ]
 =
 3085
 ; 
  
 view8
 [
 0
 ];
 // 13 
  
 view8
 [
 1
 ];
 // 12
  
 view8
 [
 0
 ].
 toString
 (
 16
 );
 // ""d"" 
  
 view8
 [
 1
 ].
 toString
 (
 16
 );
 // ""c""
  
 // swap (as if endian!) 
  
 var
 tmp
 =
 view8
 [
 0
 ];
  
 Typed Arrays 
  
 | 
  
 14
 1
  
 www.it-ebooks.info",NA
Typed Array Constructors,"In addition to the 
 (buffer,[offset, [length]])
  form examined in the previous section, 
 typed array constructors also support these forms:
  
 • [constructor]
 (length)
 : creates a new view over a new buffer of 
 length
  bytes• 
 [constructor]
 (typedArr)
 : creates a new view and buffer, and copies the 
 contents from the 
 typedArr
  view
  
 • [constructor]
 (obj)
 : creates a new view and buffer, and iterates over the 
 array-like or object 
 obj
  to copy its contents
  
 The following typed array constructors are available as of ES6:
  
 •
  Int8Array
  (8-bit signed integers), 
 Uint8Array
  (8-bit unsigned integers)
  
 —
  Uint8ClampedArray
  (8-bit unsigned integers, each value clamped on setting 
 to 
  
 the 
 0
 -
 255
  range)
  
 •
  Int16Array
  (16-bit signed integers), 
 Uint16Array
  (16-bit unsigned integers)•
  
 Int32Array
  (32-bit signed integers), 
 Uint32Array
  (32-bit unsigned integers)•
  
 Float32Array
  (32-bit floating point, IEEE-754)
  
 •
  Float64Array
  (64-bit floating point, IEEE-754)
  
 142 
  
 | 
  
 Chapter 5: Collections",NA
Maps,"Those with much JS experience know that objects are the primary mechanism 
 for creating unordered key/value-pair data structures, otherwise known as 
 maps. How‐ever, the major drawback with objects-as-maps is the inability to 
 use a non-string value as the key.
  
 For example, consider:
  
 var
 m
 =
 {};
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
 y
 =
 {
 id
 :
 2
 };
  
 m
 [
 x
 ]
 =
 ""foo""
 ; 
  
 m
 [
 y
 ]
 =
 ""bar""
 ;
  
 m
 [
 x
 ];
 // ""bar"" 
  
 m
 [
 y
 ];
 // ""bar""
  
 What’s going on here? The two objects 
 x
  and 
 y
  both stringify to 
 ""[object Object]""
 , 
 so only that one key is being set in 
 m
 .
  
 Some have implemented fake maps by maintaining a parallel array of non-string 
 keys alongside an array of the values, such as:
  
 var
 keys
 =
 [],
 vals
 =
 [];
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
 y
 =
 {
 id
 :
 2
 };
  
 keys
 .
 push
 (
 x
 ); 
  
 vals
 .
 push
 (
 ""foo""
 );
  
 keys
 .
 push
 (
 y
 ); 
  
 vals
 .
 push
 (
 ""bar""
 );
  
 Maps 
  
 | 
  
 14
 3
  
 www.it-ebooks.info",NA
Map Values ,"To get the list of values from a map, use 
 values(..)
 , which returns an iterator. In 
 Chapters 2 and 3, we covered various ways to process an iterator sequentially 
 (like an array), such as the 
 ...
  spread operator and the 
 for..of
  loop. Also, “Arrays” 
 in Chap‐ter 6 covers the 
 Array.from(..)
  method in detail.
  
  
 var
 m
 =
 new
 Map
 (); 
  
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
  
  
 y
 =
 {
 id
 :
 2
 }; 
  
  
 m
 .
 set
 (
 x
 ,
 ""foo""
 ); 
  
  
 m
 .
 set
 (
 y
 ,
 ""bar""
 ); 
  
  
 var
 vals
 =
 [...
 m
 .
 values
 ()]; 
  
  
 vals
 ;
 // [""foo"",""bar""] 
  
 To determine if a value exists in a map, use the 
 includes(..)
  method (which is the 
 same as on standard arrays as of ES6): 
  
  
 m
 .
 includes
 (
 ""foo""
 );
 // true 
  
  
 m
 .
 includes
 (
 ""baz""
 );
 // false 
  
 As discussed in the previous section, you can iterate over a map’s entries using 
 entries()
  (or the default map iterator). Consider: 
  
  
 var
 m
 =
 new
 Map
 (); 
  
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
  
  
 y
 =
 {
 id
 :
 2
 }; 
  
  
 m
 .
 set
 (
 x
 ,
 ""foo""
 ); 
  
  
 m
 .
 set
 (
 y
 ,
 ""bar""
 ); 
  
  
 var
 vals
 =
 [...
 m
 .
 entries
 ()]; 
  
  
 vals
 [
 0
 ][
 0
 ]
 ===
 x
 ;
 // true 
  
  
 vals
 [
 0
 ][
 1
 ];
 // ""foo"" 
  
  
 vals
 [
 1
 ][
 0
 ]
 ===
 y
 ;
 // true 
  
  
 vals
 [
 1
 ][
 1
 ];
 // ""bar""
  
 Maps 
  
 | 
  
 14
 5
  
 www.it-ebooks.info",NA
Map Keys ,"To get the list of keys, use 
 keys()
 , which returns an iterator over the keys in the 
 map: 
  
 var
 m
 =
 new
 Map
 (); 
  
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
  
  
 y
 =
 {
 id
 :
 2
 }; 
  
  
 m
 .
 set
 (
 x
 ,
 ""foo""
 ); 
  
  
 m
 .
 set
 (
 y
 ,
 ""bar""
 ); 
  
  
 var
 keys
 =
 [...
 m
 .
 keys
 ()]; 
  
  
 keys
 [
 0
 ]
 ===
 x
 ;
 // true 
  
  
 keys
 [
 0
 ]
 ===
 y
 ;
 // true 
  
 To determine if a map has a given key, use 
 has(..)
 : 
  
  
 var
 m
 =
 new
 Map
 (); 
  
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
  
  
 y
 =
 {
 id
 :
 2
 }; 
  
  
 m
 .
 set
 (
 x
 ,
 ""foo""
 ); 
  
  
 m
 .
 has
 (
 x
 );
 // true 
  
  
 m
 .
 has
 (
 y
 );
 // false 
  
 Maps essentially let you associate some extra piece of information (the value) 
 with an object (the key) without actually putting that information on the object 
 itself.
  
  
 If you use an object as a Map key and that object is later 
 discarded (all references unset) in attempt to have garbage 
 collection (GC) reclaim its memory, the Map itself will still 
 retain its entry. You will need to first remove the entry from 
 the Map before unsetting the last reference, or the object will 
 not be GC-able. In the next section, we’ll see WeakMaps as a 
 better option for GC-eligible object keys.
  
 While you can use any kind of value as a key for a Map, you typically will use 
 objects, as strings and other primitives are already eligible as keys of normal 
 objects. In other words, you’ll probably want to continue to use normal objects 
 for maps unless some or all of the keys need to be objects, in which case Map is 
 more appropriate.",NA
WeakMaps ,"WeakMaps are a variation on Maps, which has most of the same external 
 behavior but differs underneath in how the memory allocation (specifically its 
 GC) works.",NA
Sets,"A set is an a collection of unique values (duplicates are ignored).
  
 The API for a set is mostly identical to map. The 
 add(..)
  method takes the place of 
 the 
 set(..)
  method (somewhat ironically), and there is no 
 get(..)
  method.
  
 Sets 
  
 | 
  
 14
 7
  
 www.it-ebooks.info",NA
Set Iterators,"Sets have the same iterator methods as maps. Their behavior is different for 
 sets, but symmetric with the behavior of map iterators. Consider:
  
 var
 s
 =
 new
 Set
 ();
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
 y
 =
 {
 id
 :
 2
 };
  
 s
 .
 add
 (
 x
 ).
 add
 (
 y
 );
  
 var
 keys
 =
 [...
 s
 .
 keys
 ()], 
  
 vals
 =
 [...
 s
 .
 values
 ()], 
  
 entries
 =
 [...
 s
 .
 entries
 ()];
  
 148 
  
 | 
  
 Chapter 5: Collections
  
 www.it-ebooks.info",NA
WeakSets,"Whereas a WeakMap holds its keys weakly (but its values strongly), a WeakSet 
 holds its values weakly (there are no keys).
  
 var
 s
 =
 new
 WeakSet
 ();
  
 var
 x
 =
 {
 id
 :
 1
 }, 
  
 y
 =
 {
 id
 :
 2
 };
  
 s
 .
 add
 (
 x
 ).
 add
 (
 y
 );
  
 x
 =
 null
 ;
 // `x` is GC-able 
 y
 =
 null
 ;
 // `y` is GC-able
  
  
 WeakSet values must be objects, not primitive values as is 
 allowed with sets.",NA
Review,"ES6 defines a number of useful collections that make working with data in 
 structured ways more efficient and effective.
  
 WeakSets 
  
 | 
  
 14
 9
  
 www.it-ebooks.info",NA
CHAPTER 6,NA,NA
API Additions,"From conversions of values to mathematic calculations, ES6 adds many static 
 proper‐ties and methods to various built-in natives and objects to help with 
 common tasks. In addition, instances of some of the natives have new 
 capabilities via various new prototype methods.
  
  
 Most of these features can be faithfully polyfilled. We will not 
 dive into such details here, but check out “ES6 Shim” (
 https:// 
 github.com/paulmillr/es6-shim/
 ) 
 for 
 standards-compliant 
 shims/ polyfills.",NA
Array,"One of the most commonly extended features in JS by various user libraries is 
 the Array type. It should be no surprise that ES6 adds a number of helpers to 
 Array, both static and prototype (instance).",NA
Array.of(..),NA,NA
 Static Function,"There’s a well known gotcha with the 
 Array(..)
  constructor, which is that if 
 there’s only one argument passed, and that argument is a number, instead of 
 making an array of one element with that number value in it, it constructs an 
 empty array with a 
 length
  property equal to the number. This action produces 
 the unfortunate and quirky “empty slots” behavior that’s reviled about JS arrays.
  
 Array.of(..)
  replaces 
 Array(..)
  as the preferred function-form constructor for 
 arrays, because 
 Array.of(..)
  does not have that special single-number-argument 
 case. Consider:
  
 151
  
 www.it-ebooks.info",NA
Array.from(..),NA,NA
 Static Function,"An “array-like object” in JavaScript is an object that has a 
 length
  property on it, 
 specifically with an integer value of zero or higher.
  
 These values have been notoriously frustrating to work with in JS; it’s been 
 quite com‐mon to need to transform them into an actual array, so that the 
 various 
 Array.proto type
  methods (
 map(..)
 , 
 indexOf(..)
  etc.) are available to use 
 with it. That process usually looks like:
  
 // array-like object 
  
 var
 arrLike
 =
 { 
  
  
 length
 :
 3
 , 
  
  
 0
 :
 ""foo""
 , 
  
  
 1
 :
 ""bar"" 
  
 };
  
 var
 arr
 =
 Array
 .
 prototype
 .
 slice
 .
 call
 (
 arrLike
 );
  
 Another common task where 
 slice(..)
  is often used is in duplicating a real array:
  
 var
 arr2
 =
 arr
 .
 slice
 ();
  
 In both cases, the new ES6 
 Array.from(..)
  method can be a more understandable 
 and graceful — if also less verbose — approach:
  
 var
 arr
 =
 Array
 .
 from
 (
 arrLike
 );
  
 var
 arrCopy
 =
 Array
 .
 from
 (
 arr
 );
  
 Array.from(..)
  looks to see if the first argument is an iterable (see “Iterators” in 
 Chapter 3), and if so, it uses the iterator to produce values to “copy” into the 
 returned array. Since real arrays have an iterator for those values, that iterator 
 is automatically used.
  
 But if you pass an array-like object as the first argument to 
 Array.from(..)
 , it 
 behaves basically the same as 
 slice()
  (no arguments!) or 
 apply(..)
  does, which is 
 that it simply loops over the value, accessing numerically named properties 
 from 
 0
  up to whatever the value of 
 length
  is.
  
 Consider:
  
 var
 arrLike
 =
 { 
  
  
 length
 :
 4
 , 
  
  
 2
 :
 ""foo"" 
  
 };
  
 Array
 .
 from
 (
 arrLike
 ); 
  
 // [ undefined, undefined, ""foo"", undefined ]
  
 Array 
  
 | 
  
 15
 3
  
 www.it-ebooks.info",NA
Creating Arrays And Subtypes,"In the last couple of sections, we’ve discussed 
 Array.of(..)
  and 
 Array.from(..)
 , both 
 of which create a new array in a similar way to a constructor. But what do they 
 do in subclasses? Do they create instances of the base 
 Array
  or the derived 
 subclass?
  
 class
 MyCoolArray
 extends
 Array
 { 
  
  
 .. 
  
 }
  
 Array
 .
 of
 (
 1
 ,
 2
 )
 instanceof
 Array
 ;
 // true 
 Array
 .
 from
 ([
 1
 ,
 2
 ])
 instanceof
 Array
 ;
 // true
  
 MyCoolArray
 .
 of
 (
 1
 ,
 2
 )
 instanceof
 Array
 ;
 // false 
 MyCoolArray
 .
 from
 ([
 1
 ,
 2
 ])
 instanceof
 Array
 ;
 // false
  
 MyCoolArray
 .
 of
 (
 1
 ,
 2
 )
 instanceof
 MyCoolArray
 ;
 // true 
 MyCoolArray
 .
 from
 ([
 1
 ,
 2
 ])
 instanceof
 MyCoolArray
 ;
 // true
  
 Both 
 of(..)
  and 
 from(..)
  use the constructor that they’re accessed from to con‐
 struct the array. So if you use the base 
 Array.of(..)
  you’ll get an 
 Array
  instance, 
 but if you use 
 MyCoolArray.of(..)
 , you’ll get a 
 MyCoolArray
  instance.
  
 In “Classes” in Chapter 3, we covered the 
 @@species
  setting which all the built-
 in classes (like 
 Array
 ) have defined, which is used by any prototype methods if 
 they cre‐ate a new instance. 
 slice(..)
  is a great example:
  
 var
 x
 =
 new
 MyCoolArray
 (
 1
 ,
 2
 ,
 3
 );
  
 x
 .
 slice
 (
 1
 )
 instanceof
 MyCoolArray
 ;
 // true
  
 Generally, that default behavior will probably be desired, but as we discussed in 
 Chapter 3, you 
 can
  override if you want:
  
 Array 
  
 | 
  
 15
 5",NA
copyWithin(..),NA,NA
 Prototype Method,"Array#copyWithin(..)
  is a new mutator method available to all arrays (including 
 Typed Arrays — see Chapter 5). 
 copyWithin(..)
  copies a portion of an array to 
 another location in the same array, overwriting whatever was there before.
  
 The arguments are 
 target
  (the index to copy to), 
 start
  (the inclusive index to 
 start the copying from), and optionally 
 end
  (the exclusive index to stop copying). 
 If any of the arguments are negative, they’re taken to be relative from the end of 
 the array.
  
 Consider:
  
 [
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 ].
 copyWithin
 (
 3
 ,
 0
 );
 // [1,2,3,1,2]
  
 [
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 ].
 copyWithin
 (
 3
 ,
 0
 ,
 1
 );
 // [1,2,3,1,5]
  
 [
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 ].
 copyWithin
 (
 0
 ,
 -
 2
 );
 // [4,5,3,4,5]
  
 [
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 ].
 copyWithin
 (
 0
 ,
 -
 2
 ,
 -
 1
 );
 // [4,2,3,4,5]
  
 156 
  
 | 
  
 Chapter 6: API Additions
  
 www.it-ebooks.info",NA
fill(..),NA,NA
 Prototype Method,"Filling an existing array entirely (or partially) with a specified value is natively 
 sup‐ported as of ES6 with the 
 Array#fill(..)
  method:
  
 var
 a
 =
 Array
 (
 4
 ).
 fill
 (
 undefined
 );
  
 a
 ;
  
 // [undefined,undefined,undefined,undefined]
  
 fill(..)
  optionally takes 
 start
  and 
 end
  parameters which indicate a subset portion 
 of the array to fill, such as:
  
 var
 a
 =
 [
 null
 ,
 null
 ,
 null
 ,
 null
 ].
 fill
 (
 42
 ,
 1
 ,
 3
 );
  
 a
 ;
 // [null,42,42,null]",NA
find(..),NA,NA
 Prototype Method,"The most common way to search for a value in an array has generally been the 
 indexOf(..)
  method, which returns the index the value is found at or 
 -1
  if not 
 found:
  
 var
 a
 =
 [
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 ];
  
 (
 a
 .
 indexOf
 (
 3
 )
 !=-
 1
 );
 // true
  
 (
 a
 .
 indexOf
 (
 7
 )
 !=-
 1
 );
 // false
  
 Array 
  
 | 
  
 15
 7",NA
findIndex(..),NA,NA
 Prototype Method,"While the previous section illustrates how 
 some(..)
  yields a boolean result for a 
 search of an array, and 
 find(..)
  yields the matched value itself from the array 
 search, there’s also a need for finding the positional index of the matched value.
  
 indexOf(..)
  does that, but there’s no control over its matching logic; it always uses 
 ===
  strict equality. So ES6’s 
 findIndex(..)
  is the answer:
  
 var
 points
 =
 [ 
  
  
 {
 x
 :
 10
 ,
 y
 :
 20
 }, 
  
  
 {
 x
 :
 20
 ,
 y
 :
 30
 }, 
  
  
 {
 x
 :
 30
 ,
 y
 :
 40
 }, 
  
  
 {
 x
 :
 40
 ,
 y
 :
 50
 }, 
  
  
 {
 x
 :
 50
 ,
 y
 :
 60
 } 
  
 ];
  
 points
 .
 findIndex
 (
 function
 matcher
 (
 point
 ){ 
  
 return
 ( 
  
  
  
 point
 .
 x
 %
 3
 ==
 0
 && 
  
  
  
 point
 .
 y
 %
 4
 ==
 0 
  
  
 ); 
  
 });
 // 2
  
 points
 .
 findIndex
 (
 function
 matcher
 (
 point
 ){ 
  
 return
 ( 
  
  
  
 point
 .
 x
 %
 6
 ==
 0
 && 
  
  
  
 point
 .
 y
 %
 7
 ==
 0 
  
  
 ); 
  
 });
 // -1
  
 Array 
  
 | 
  
 15
 9
  
 www.it-ebooks.info",NA
entries(),NA,NA
", ",NA,NA
values(),NA,NA
", ",NA,NA
keys(),NA,NA
 Prototype Methods,"In Chapter 3, we illustrated how data structures can provide a patterned item-
 by-item enumeration of their values, via an iterator. We then expounded on this 
 approach in Chapter 5, as we explored how the new ES6 collections (Map, Set, 
 etc.) provide sev‐eral methods for producing different kinds of iterations.
  
 While 
 Array
  might not be thought of traditionally as a “collection” since it’s not 
 new to ES6, it is one in the sense that it provides these same iterator methods: 
 entries()
 , 
 values()
 , and 
 keys()
 . Consider:
  
 var
 a
 =
 [
 1
 ,
 2
 ,
 3
 ];
  
 [...
 a
 .
 values
 ()];
 // [1,2,3]
  
 [...
 a
 .
 keys
 ()];
 // [0,1,2]
  
 [...
 a
 .
 entries
 ()];
 // [ [0,1], [1,2], [2,3] ]
  
 [...
 a
 [
 Symbol
 .
 iterator
 ]()];
 // [1,2,3]
  
 Just like with 
 Set
 , the default 
 Array
  iterator is the same as what 
 values()
  returns.
  
 In “Avoiding Empty Slots” earlier in this chapter, we illustrated how 
 Array.from(..) 
 treats empty slots in an array as just being present slots with 
 undefined
  in them.
  
 That’s actually because under the covers, the array iterators behave that way:
  
 var
 a
 =
 [];
  
 a
 .
 length
 =
 3
 ;
  
 a
 [
 1
 ]
 =
 2
 ;
  
 [...
 a
 .
 values
 ()];
 // [undefined,2,undefined]
  
 [...
 a
 .
 keys
 ()];
 // [0,1,2]
  
 [...
 a
 .
 entries
 ()];
 // [ [0,undefined], [1,2], [2,undefined] ]
  
 160 
  
 | 
  
 Chapter 6: API Additions",NA
Object,"A few additional static helpers have been added to 
 Object
 . Traditionally, 
 functions of this sort have been seen as focused on the behaviors/capabilities of 
 object values.
  
 However, starting with ES6, 
 Object
  static functions will also be for general 
 purpose global APIs of any sort that don’t already belong more naturally in 
 some other loca‐tion (i.e., 
 Array.from(..)
 ).",NA
Object.is(..),NA,NA
 Static Function,"The 
 Object.is(..)
  static function makes value comparisons in an even more strict 
 fashion than the 
 ===
  comparison.
  
 Object.is(..)
  invokes the underlying 
 SameValue
  algorithm (ES6 spec, section 
 7.2.9). The 
 SameValue
  algorithm is basically the same as the 
 ===
  Strict Equality 
 Com‐parison Algorithm (ES6 spec, section 7.2.13), with two important 
 exceptions.
  
 Consider:
  
 var
 x
 =
 NaN
 ,
 y
 =
 0
 ,
 z
 =-
 0
 ;
  
 x
 ===
 x
 ;
 // false
  
 y
 ===
 z
 ;
 // true
  
 Object
 .
 is
 (
 x
 ,
 x
 );
 // true
  
 Object
 .
 is
 (
 y
 ,
 z
 );
 // false
  
 You should continue to use 
 ===
  for strict equality comparisons; 
 Object.is(..) 
 shouldn’t be thought of as a replacement for the operator. However, in cases 
 where you’re trying to strictly identify a 
 NaN
  or 
 -0
  value, 
 Object.is(..)
  is now the 
 prefer‐red option.
  
  
 ES6 also adds a 
 Number.isNaN(..)
  utility (discussed later in this 
 chapter) which may be a slightly more convenient test; you 
 may prefer 
 Number.isNaN(x)
  than 
 Object.is(x,NaN)
 . You 
 can
  
 accu‐rately test for 
 -0
  with a clumsy 
 x == 0 && 1 / x === -Infinity
 , 
 but in this case 
 Object.is(x,-0)
  is much better.",NA
Object.getOwnPropertySymbols(..),NA,NA
 Static Function,"Chapter 2 “Symbols” discusses the new Symbol primitive value type in ES6.
  
 Symbols are likely going to be mostly used as special (meta) properties on 
 objects. So the 
 Object.getOwnPropertySymbols(..)
  utility was introduced, which 
 retrieves only the symbol properties directly on an object:
  
 Object 
  
 | 
  
 16
 1",NA
Object.setPrototypeOf(..),NA,NA
 Static Function,"Also in Chapter 2, we mentioned the 
 Object.setPrototypeOf(..)
  utility, which 
 (unsurprisingly) sets the 
 [[Prototype]]
  of an object for the purposes of 
 behavior 
 del‐egation
  (see the 
 this & Object Prototypes
  title of this series). Consider:
  
 var
 o1
 =
 { 
  
  
 foo
 (){
 console
 .
 log
 (
 ""foo""
 );} 
  
 }; 
  
 var
 o2
 =
 { 
  
  
 // .. o2's definition ..
  
 };
  
 Object
 .
 setPrototypeOf
 (
 o2
 ,
 o1
 );
  
 // delegates to `o1.foo()` 
  
 o2
 .
 foo
 ();
 // foo
  
 Alternatively:
  
 var
 o1
 =
 { 
  
  
 foo
 (){
 console
 .
 log
 (
 ""foo""
 );} 
  
 };
  
 var
 o2
 =
 Object
 .
 setPrototypeOf
 ({ 
  
  
 // .. o2's definition ..
  
 },
 o1
 );
  
 // delegates to `o1.foo()` 
  
 o2
 .
 foo
 ();
 // foo
  
 In both previous snippets, the relationship between 
 o2
  and 
 o1
  appears at the 
 end of the 
 o2
  definition. More commonly, the relationship between an 
 o2
  and 
 o1
  
 is specified at the top of the 
 o2
  definition, as it is with classes, and also with 
 __proto__
  in object literals (see “Setting 
 [[Prototype]]
 "" in Chapter 2).
  
  
 Setting a 
 [[Prototype]]
  right after object creation is reasonable, 
 as shown. But changing it much later is generally not a good 
 idea and will usually lead to more confusion than clarity.
  
 162 
  
 | 
  
 Chapter 6: API Additions
  
 www.it-ebooks.info",NA
Object.assign(..),NA,NA
 Static Function,"Many JavaScript libraries/frameworks provide utilities for copying/mixing one 
 object’s properties into another; for example: jQuery’s 
 extend(..)
 . There are 
 various nuanced differences between these different utilities, such as whether a 
 property with value 
 undefined
  is ignored or not.
  
 ES6 adds 
 Object.assign(..)
 , which is a simplified version of these algorithms. The 
 first argument is the 
 target
 , and any other arguments passed are the 
 sources
 , 
 which will be processed in listed order. For each source, its enumerable and 
 own (e.g., not“inherited”) keys, not symbols, are copied as if by plain 
 =
  
 assignment. 
 Object.assign(..)
  returns the target object.
  
 Consider this object setup:
  
 var
 target
 =
 {}, 
  
 o1
 =
 {
 a
 :
 1
 },
 o2
 =
 {
 b
 :
 2
 }, 
  
 o3
 =
 {
 c
 :
 3
 },
 o4
 =
 {
 d
 :
 4
 };
  
 // setup read-only property 
  
 Object
 .
 defineProperty
 (
 o3
 ,
 ""e""
 ,{ 
  
  
 value
 :
 5
 , 
  
  
 enumerable
 :
 true
 , 
  
  
 writable
 :
 false
 , 
  
  
 configurable
 :
 false 
  
 });
  
 // setup non-enumerable property 
  
 Object
 .
 defineProperty
 (
 o3
 ,
 ""f""
 ,{ 
  
  
 value
 :
 6
 , 
  
  
 enumerable
 :
 false 
  
 });
  
 o3
 [
 Symbol
 (
 ""g""
 )]
 =
 7
 ;
  
 Object
 .
 setPrototypeOf
 (
 o3
 ,
 o4
 );
  
 Only the properties 
 a
 , 
 b
 , 
 c
 , and 
 e
  will be copied to 
 target
 :
  
 Object
 .
 assign
 (
 target
 ,
 o1
 ,
 o2
 ,
 o3
 );
  
 target
 .
 a
 ;
 // 
 1 
  
 target
 .
 b
 ;
 // 
 2 
  
 target
 .
 c
 ;
 // 
 3 
  
 target
 .
 e
 ;
 // 5
  
 Object
 .
 getOwnPropertyDescriptor
 (
 target
 ,
 ""e""
 ); 
 // { value: 
 5, writable: true, enumerable: true, //   configurable: true 
 }
  
 Object 
  
 | 
  
 16
 3
  
 www.it-ebooks.info",NA
Math,"ES6 adds several new mathematic utilities that fill in holes or aid with common 
 oper‐ations. All of these can be manually calculated, but most of them are now 
 defined natively so that in some cases the JS engine can either more optimally 
 perform the calculations, or perform them with better decimal precision than 
 their manual coun‐terparts.
  
 It’s likely that asm.js/transpiled JS code (see the 
 Async & Performance
  title of 
 this ser‐ies) is the more likely consumer of many of these utilities rather than 
 direct develop‐ers.
  
 Trigonometry:
  
 •
  cosh(..)
  - hyperbolic cosine
  
 •
  acosh(..)
  - hyperbolic arccosine
  
 •
  sinh(..)
  - hyperbolic sine
  
 164 
  
 | 
  
 Chapter 6: API Additions
  
 www.it-ebooks.info",NA
Number,"Accurately working with numbers is very important to your program working 
 cor‐rectly. ES6 adds some additional properties and functions to assist with 
 common numeric operations.
  
 Two additions to 
 Number
  are just references to the preexisting globals: 
 Number.par seInt(..)
  and 
 Number.parseFloat(..)
 .",NA
Static Properties,"•
  Number.EPSILON
  - the minimum value between any two numbers: 
 2^-52
  (see 
 Chapter 2 of the 
 Types & Grammar
  title of this series regarding using this value 
 as a tolerance for imprecision in floating point arithmetic)
  
 •
  Number.MAX_SAFE_INTEGER
  - The highest integer that can “safely” be 
 represented unambiguously in a JS number value: 
 2^53 - 1
  
 Number 
  
 | 
  
 16
 5",NA
Number.isNaN(..),NA,NA
 Static Function,"The standard global 
 isNaN(..)
  utility has been broken since its inception, in that 
 it returns 
 true
  for things that are not numbers, not just for the actual 
 NaN
  value, 
 because it coerces the argument to a number type (which can falsely result in a 
 NaN).
  
 ES6 adds a fixed utility 
 Number.isNaN(..)
  that works as it should:
  
 var
 a
 =
 NaN
 ,
 b
 =
 ""NaN""
 ,
 c
 =
 42
 ;
  
 isNaN
 (
 a
 );
 // true 
  
 isNaN
 (
 b
 );
 // true -- oops!
  
 isNaN
 (
 c
 );
 // false
  
 Number
 .
 isNaN
 (
 a
 );
 // true 
  
 Number
 .
 isNaN
 (
 b
 );
 // false -- fixed!
  
 Number
 .
 isNaN
 (
 c
 );
 // false",NA
Number.isFinite(..),NA,NA
 Static Function,"There’s a temptation to look at a function name like 
 isFinite(..)
  and assume it’s 
 simply “not infinite”. That’s not quite correct, though. There’s more nuance to 
 this new ES6 utility. Consider:
  
 var
 a
 =
 NaN
 ,
 b
 =
 Infinity
 ,
 c
 =
 42
 ;
  
 Number
 .
 isFinite
 (
 a
 );
 // false 
 Number
 .
 isFinite
 (
 b
 );
 // 
 false
  
 Number
 .
 isFinite
 (
 c
 );
 // true
  
 The standard global 
 isFinite(..)
  coerces its argument, but 
 Number.isFinite(..) 
 omits 
 the coercive behavior:
  
 var
 a
 =
 ""42""
 ;
  
 isFinite
 (
 a
 );
 // true 
 Number
 .
 isFinite
 (
 a
 );
 // false
  
 166 
  
 | 
  
 Chapter 6: API Additions",NA
Integer-related Static Functions,"JavaScript number valuess are always floating point (IEE-754). So the notion of 
 deter‐mining if a number is an “integer” is not about checking its type, since JS 
 makes no such distinction.
  
 Instead, you need to check if there’s any non-zero decimal portion of the value. 
 The easiest way to do that has commonly been:
  
 x
 ===
 Math
 .
 floor
 (
 x
 );
  
 ES6 adds a 
 Number.isInteger(..)
  helper utility that potentially can determine this 
 quality slightly more efficiently:
  
 Number
 .
 isInteger
 (
 4
 );
 // true
  
 Number
 .
 isInteger
 (
 4.2
 );
 // false
  
  
 In JavaScript, there’s no difference between 
 4
 , 
 4.
 , 
 4.0
 , or 
 4.0000
 . 
 All of these would be considered an “integer”, and would thus 
 yield 
 true
  from 
 Number.isInteger(..)
 .
  
 In addition, 
 Number.isInteger(..)
  filters out some clearly not-integer values that 
 x 
 === Math.floor(x)
  could potentially mix up:
  
 Number
 .
 isInteger
 (
 NaN
 );
 // false
  
 Number
 .
 isInteger
 (
 Infinity
 );
 // false
  
 Working with “integers” is sometimes an important bit of information, since it 
 can simplify certain kinds of algorithms. JS code by itself will not run faster just 
 from fil‐tering for only integers, but there are optimization techniques the 
 engine can take (e.g., asm.js) when only integers are being used.
  
 Because of 
 Number.isInteger(..)
 ’s handling of 
 NaN
  and 
 Infinity
  values, defining a 
 isFloat(..)
  utility would not be just as simple as 
 !Number.isInteger(..)
 . You’d need 
 to do something like:
  
 function
 isFloat
 (
 x
 ){
  
 return
 Number
 .
 isFinite
 (
 x
 )
 &&!
 Number
 .
 isInteger
 (
 x
 );
  
 }
  
 isFloat
 (
 4.2
 );
 // true
  
 isFloat
 (
 4
 );
 // false
  
 Number 
  
 | 
  
 16
 7
  
 www.it-ebooks.info",NA
String,"Strings already have quite a few helpers prior to ES6, but even more have been 
 added to the mix.",NA
Unicode Functions,"“Unicode-Aware String Operations” in Chapter 2 discusses 
 String.fromCode 
 Point(..)
 , 
 String#codePointAt(..)
 , and 
 String#normalize(..)
  in detail. They have been 
 added to improve Unicode support in JS string values.
  
 String
 .
 fromCodePoint
 (
 0x1d49e
 );
 // ""
 𝒞
 ""
  
 ""ab𝒞d""
 .
 codePointAt
 (
 2
 ).
 toString
 (
 16
 );
 // ""1d49e"" 
  
 The 
 normalize(..)
  string prototype method is used to perform Unicode 
 normaliza‐tions that either combine characters with adjacent “combining 
 marks” or decompose combined characters.
  
 Generally, the normalization won’t create a visible effect on the contents of the 
 string, but will change the contents of the string which can affect how things like 
 the 
 length 
 property are reported, as well as how character access by position 
 behave:
  
 var
 s1
 =
 ""é""
 ; 
  
 s1
 .
 length
 ;
 // 2
  
 168 
  
 | 
  
 Chapter 6: API Additions",NA
String.raw(..),NA,NA
 Static Function,"The 
 String.raw(..)
  utility is provided as a built-in tag function to use with 
 template string literals (see Chapter 2) for obtaining the raw string value 
 without any process‐ing of escape sequences.
  
 This function will almost never be called manually, but will be used with tagged 
 tem‐plate literals:
  
 var
 str
 =
 ""bc""
 ;
  
 String
 .
 raw
 `\
 ta$
 {
 str
 }
 d
 \
 xE9
 `
 ;
  
 // ""\tabcd\xE9"", not ""  abcdé""
  
 In the resultant string, 
 \
  and 
 t
  are separate raw characters, not the one escape 
 sequence character 
 \t
 . The same is true with the Unicode escape sequence.",NA
repeat(..),NA,NA
 Prototype Function,"In languages like Python and Ruby, you can repeat a string as:
  
 ""foo""
 *
 3
 ;
 // ""foofoofoo""
  
 That doesn’t work in JS, since 
 *
  multiplication is only defined for numbers, and 
 thus 
 ""foo""
  coerces to the 
 NaN
  number.
  
 However, ES6 defines a string prototype method 
 repeat(..)
  to accomplish the 
 task:
  
 ""foo""
 .
 repeat
 (
 3
 );
 // ""foofoofoo""",NA
String Inspection Functions,"In addition to 
 String#indexOf(..)
  and 
 String#lastIndexOf(..)
  from prior to ES6, 
 three new methods for searching/inspection have been added: 
 startsWith(..)
 , 
 end sWidth(..)
 , and 
 includes(..)
 .
  
 String 
  
 | 
  
 16
 9",NA
Review,"ES6 adds many extra API helpers on the various built-in native objects:
  
 •
  Array
  adds 
 of(..)
  and 
 from(..)
  static functions, as well as prototype functions
  
 like 
 copyWithin(..)
  and 
 fill(..)
 .
  
 •
  Object
  adds static functions like 
 is(..)
  and 
 assign(..)
 .
  
 •
  Math
  adds static functions like 
 acosh(..)
  and 
 clz32(..)
 .
  
 •
  Number
  adds static properties like 
 Number.EPSILON
 , as well as static 
 functions like
  
 Number.isFinite(..)
 .
  
 •
  String 
  
 adds static 
  
 functions like 
  
 String.fromCodePoint(..) 
  
 and
  
 String.raw(..)
 , as well as prototype functions like 
 repeat(..)
  and
  
 includes(..)
 .
  
 Most of these additions can be polyfilled (see ES6 Shim), and were inspired by 
 utilit‐
  
 ies in common JS libraries/frameworks.",NA
CHAPTER 7,NA,NA
Meta Programming,"Meta Programming is programming where the operation targets the behavior of 
 the program itself. In other words, it’s programming the programming of your 
 program. Yeah, a mouthful, huh!?
  
 For example, if you probe the relationship between one object 
 a
  and another 
 b
  
 — are they 
 [[Prototype]]
  linked? — using 
 a.isPrototype(b)
 , this is commonly 
 referred to as introspection, a form of meta programming. Macros (which don’t 
 exist in JS, yet) — where the code modifies itself at compile time — are another 
 obvious example of meta programming. Enumerating the keys of an object with 
 a 
 for..in
  loop, or checking if an object is an 
 instance of
  a “class constructor”, are 
 other common meta programming tasks.
  
 Meta programming focuses on one or more of the following: code inspecting 
 itself, code modifying itself, or code modifying default language behavior so 
 other code is affected.
  
 The goal of meta programming is to leverage the language’s own intrinsic 
 capabilities to make the rest of your code more descriptive, expressive, and/or 
 flexible. Because of the 
 meta
  nature of meta programming, it’s somewhat 
 difficult to put a more precise definition on it than that. The best way to 
 understand meta programming is to see it through examples.
  
 ES6 adds several new forms/features for meta programming on top of what JS 
 already had.
  
 171
  
 www.it-ebooks.info",NA
Function Names,"There are cases where your code may want to introspect on itself and ask what 
 the name of some function is. If you ask what a function’s name is, the answer is 
 surpris‐ingly somewhat ambiguous. Consider:
  
 function
 daz
 (){ 
  
  
 // ..
  
 }
  
 var
 obj
 =
 { 
  
  
 foo
 :
 function
 (){ 
  
  
  
 // ..
  
 }, 
  
 bar
 :
 function
 baz
 (){ 
  
  
 // ..
  
 }, 
  
 bam
 :
 daz
 , 
  
 zim
 (){ 
  
  
 // ..
  
  
 } 
  
 };
  
 In this previous snippet, “what is the name of 
 obj.foo()
 "" is slightly nuanced. Is it 
 ""foo""
 , 
 """"
 , or 
 undefined
 ? And what about 
 obj.bar()
  — is it named 
 ""bar""
  or 
 ""baz""
 ? Is 
 obj.bam()
  named 
 ""bam""
  or 
 ""daz""
 ? What about 
 obj.zim()
 ?
  
 Moreover, what about functions which are passed as callbacks, like:
  
 function
 foo
 (
 cb
 ){ 
  
  
 // what is the name of `cb()` here?
  
 }
  
 foo
 (
 function
 (){ 
  
  
 // I'm anonymous!
  
 });
  
 There are quite a few ways that functions can be expressed in programs, and it’s 
 not always clear and unambiguous what the “name” of that function should be.
  
 More importantly, we need to distinguish whether the “name” of a function 
 refers to its 
 name
  property — yes, functions have a property called 
 name
  — or 
 whether it refers to the lexical binding name, such as 
 bar
  in 
 function bar() { .. }
 .
  
 The lexical binding name is what you use for things like recursion:
  
 function
 foo
 (
 i
 ){ 
  
  
 if
 (
 i
 <
 10
 )
 return
 foo
 (
 i
 *
 2
 ); 
  
  
 return
 i
 ; 
  
 }
  
 172 
  
 | 
  
 Chapter 7: Meta Programming
  
 www.it-ebooks.info",NA
Inferences,"But what happens to the 
 name
  property if a function has no lexical name?
  
 As of ES6, there are now inference rules which can determine a sensible 
 name
  
 prop‐erty value to assign a function even if that function doesn’t have a lexical 
 name to use.
  
 Consider:
  
 var
 abc
 =
 function
 (){ 
  
  
 // ..
  
 };
  
 abc
 .
 name
 ;
 // ""abc""
  
 Had we given the function a lexical name like 
 abc = function def() { .. }
 , the 
 name
  
 property would of course be 
 ""def""
 . But in the absence of the lexical name, intui‐
 tively the 
 ""abc""
  name seems appropriate.
  
 Here are other forms which will infer a name (or not) in ES6:
  
 (
 function
 (){..});
 // name: 
 (
 function
 *
 (){..});
 // name: 
 window
 .
 foo
 =
 function
 (){..};
 // name:
  
 class
 Awesome
 { 
  
  
 constructor
 (){..}
 // name: Awesome 
  
 funny
 (){..}
 // 
 name: funny 
 }
  
 var
 c
 =
 class
 Awesome
 {..};
 // name: Awesome
  
 var
 o
 =
 { 
  
 foo
 (){..},
 // name: foo 
 *
 bar
 (){..},
 // name: bar 
 baz
 :
 ()
 =>
 {..},
 // name: baz 
 bam
 :
 function
 (){..},
 // 
 name: bam
  
 Function Names 
  
 | 
  
 17
 3
  
 www.it-ebooks.info",NA
Meta Properties,"In Chapter 3 ""
 new.target
 “, we introduced a concept new to JS in ES6: the meta 
 prop‐erty. As the name suggests, meta properties are intended to provide 
 special meta information in the form of a property access that would otherwise 
 not have been pos‐sible.
  
 In the case of 
 new.target
 , the keyword 
 new
  serves as the context for a property 
 access. Clearly 
 new
  is itself not an object, which makes this capability special. 
 How‐ever, when 
 new.target
  is used inside a constructor call (a function/method 
 invoked with 
 new
 ), 
 new
  becomes a virtual context, so that 
 new.target
  can refer to 
 the target constructor that 
 new
  invoked.
  
 This is a clear example of a meta programming operation, as the intent is to 
 deter‐mine from inside a constructor call what the original 
 new
  target was, 
 generally for the purposes of introspection (examining typing/structure) or 
 static property access.
  
 For example, you may want to have different behavior in a constructor 
 depending on if its directly invoked or invoked via a child class:
  
 class
 Parent
 { 
  
  
 constructor
 (){ 
  
  
  
 if
 (
 new
 .
 target
 ===
 Parent
 ){ 
  
  
  
  
 console
 .
 log
 (
 ""Parent instantiated""
 ); 
  
  
 } 
  
  
  
 else
 { 
  
  
  
  
 console
 .
 log
 (
 ""A child instantiated""
 ); 
  
  
 }
  
 174 
  
 | 
  
 Chapter 7: Meta Programming
  
 www.it-ebooks.info",NA
Well Known Symbols,"In Chapter 2 “Symbols”, we covered the new ES6 primitive type 
 symbol
 . In 
 addition to symbols you can define in your own program, JS pre-defines a 
 number of built-in symbols, referred to as 
 well known symbols
  (WKS).
  
 These symbol values are defined primarily to expose special meta properties 
 that are being exposed to your JS programs to give you more control over JS’s 
 behavior.
  
 We’ll briefly introduce each and discuss their purpose.",NA
Symbol.iterator,"In Chapters 2 and 3, we introduced and used the 
 @@iterator
  symbol, 
 automatically used by 
 ...
  spreads and 
 for..of
  loops. We also saw 
 @@iterator
  as 
 defined on the new ES6 collections as defined in Chapter 5.
  
 Symbol.iterator
  represents the special location (property) on any object where 
 the language mechanisms automatically look to find a method that will 
 construct an iter‐ator instance for consuming that object’s values. Many objects 
 come with a default one defined.
  
 However, we can define our own iterator logic for any object value by setting 
 the 
 Sym bol.iterator
  property, even if that’s overriding the default iterator. The 
 meta pro‐gramming aspect is that we are defining behavior which other parts of 
 JS (namely, operators and looping constructs) use when processing an object 
 value we define.",NA
Symbol.toStringTag,NA,NA
 and ,NA,NA
Symbol.hasInstance,"One of the most common meta programming tasks is to introspect on a value to 
 find out what 
 kind
  it is, usually to decide what operations are appropriate to 
 perform on it. With objects, the two most common inspection techniques are 
 toString()
  and 
 instanceof
 .
  
 Consider:
  
 function
 Foo
 (){}
  
 var
 a
 =
 new
 Foo
 ();
  
 a
 .
 toString
 ();
 // [object Object] 
 a
 instanceof
 Foo
 ;
 // true
  
 As of ES6, you can control the behavior of these operations:
  
 function
 Foo
 (
 greeting
 ){ 
  
  
 this
 .
 greeting
 =
 greeting
 ; 
  
 }
  
 Foo
 .
 prototype
 [
 Symbol
 .
 toStringTag
 ]
 =
 ""Foo""
 ;
  
 Object
 .
 defineProperty
 (
 Foo
 ,
 Symbol
 .
 hasInstance
 ,{ 
  
 value
 :
 function
 (
 inst
 ){ 
  
  
  
 return
 inst
 .
 greeting
 ==
 ""hello""
 ; 
  
  
 } 
  
 });
  
 176 
  
 | 
  
 Chapter 7: Meta Programming
  
 www.it-ebooks.info",NA
Symbol.species,"In “Classes” in Chapter 3, we introduced the 
 @@species
  symbol, which controls 
 which constructor is used by built-in methods of a class that needs to spawn 
 new instances.
  
 The most common example is when subclassing 
 Array
  and wanting to define 
 which constructor (
 Array(..)
  or your subclass) inherited methods like 
 slice(..)
  
 should use. By default, 
 slice(..)
  called on an instance of a subclass of 
 Array
  would 
 produce a new instance of that subclass, which is frankly what you’ll likely often 
 want.
  
 However, you can meta program by overriding a class’s default 
 @@species
  
 definition:
  
 class
 Cool
 { 
  
 // defer `@@species` to derived constructor 
 static
 get
 [
 Symbol
 .
 species
 ](){
 returnthis
 ;}
  
  
 again
 (){ 
  
  
  
 returnnewthis
 .
 constructor
 [
 Symbol
 .
 species
 ](); 
  
 } 
  
 }
  
 class
 Fun
 extends
 Cool
 {}
  
 class
 Awesome
 extends
 Cool
 {
  
 Well Known Symbols 
  
 | 
  
 17
 7",NA
Symbol.toPrimitive,"In the 
 Types & Grammar
  title of this series, we discussed the 
 ToPrimitive
  abstract 
 coercion operation, which is used when an object must be coerced to a primitive 
 value for some operation (such as 
 ==
  comparison or 
 +
  addition). Prior to ES6, 
 there was no way to control this behavior.
  
 As of ES6, the 
 @@toPrimitive
  symbol as a property on any object value can 
 custom‐ize that 
 ToPrimitve
  coercion by specifying a method.
  
 Consider:
  
 var
 arr
 =
 [
 1
 ,
 2
 ,
 3
 ,
 4
 ,
 5
 ];
  
 arr
 +
 10
 ;
 // 1,2,3,4,510
  
 arr
 [
 Symbol
 .
 toPrimitive
 ]
 =
 function
 (
 hint
 ){ 
  
  
 if
 (
 hint
 ==
 ""default""
 ||
 hint
 ==
 ""number""
 ){ 
   
 // 
 sum all numbers 
  
  
  
 returnthis
 .
 reduce
 (
 function
 (
 acc
 ,
 curr
 ){ 
  
  
  
 return
 acc
 +
 curr
 ; 
  
  
  
 },
 0
 ); 
  
  
 } 
  
 };
  
 arr
 +
 10
 ;
 // 25
  
 178 
  
 | 
  
 Chapter 7: Meta Programming
  
 www.it-ebooks.info",NA
Regular Expression Symbols,"There are four well known symbols that can be overridden for regular 
 expression objects, which control how those regular expressions are used by the 
 four corre‐sponding 
 String.prototype
  functions of the same name:
  
 •
  @@match
 : The 
 Symbol.match
  value of a regular expression is the method 
 used to match all or part of a string value with the given regular expression. 
 It’s used by 
 String.prototype.match(..)
  if you pass it a regular expression for 
 the pattern matching.
  
 The default algorithm for matching is laid out in section 21.2.5.6 of the ES6 
 specifica‐tion 
  
 (
 https://people.mozilla.org/~jorendorff/es6-draft.html#sec-
 regexp.prototype-@@match
 ). You could override this default algorithm and 
 provide extra regex features, such as look-behind assertions.
  
 Symbol.match
  is also used by the 
 isRegExp
  abstract operation (see the note in 
 “String Inspection Functions” in Chapter 6) to determine if an object is intended 
 to be used as a regular expression. To force this check to fail for an object so it’s 
 not treated as a regular expression, set the 
 Symbol.match
  value to 
 false
  (or 
 something falsy). * 
 @@replace
 : The 
 Symbol.replace
  value of a regular expression 
 is the method used by 
 String.prototype.replace(..)
  to replace within a string one 
 or all occurrences of character sequences that match the given regular 
 expression pattern.
  
 The default algorithm for replacing is laid out in section 21.2.5.8 of the ES6 
 specifica‐tion 
  
 (
 https://people.mozilla.org/~jorendorff/es6-draft.html#sec-
 regexp.prototype-@@replace
 ).
  
 Well Known Symbols 
  
 | 
  
 17
 9",NA
Symbol.isConcatSpreadable,"The 
 @@isConcatSpreadable
  symbol can be defined as a boolean property (
 Sym 
 bol.isConcatSpreadable
 ) on any object (like an array or other iterable) to indicate 
 if it should be 
 spread out
  if passed to an array 
 concat(..)
 .
  
 Consider:
  
 var
 a
 =
 [
 1
 ,
 2
 ,
 3
 ],
  
 b
 =
 [
 4
 ,
 5
 ,
 6
 ];
  
 b
 [
 Symbol
 .
 isConcatSpreadable
 ]
 =
 false
 ;
  
 [].
 concat
 (
 a
 ,
 b
 );
 // [1,2,3,[4,5,6]]",NA
Symbol.unscopables,"The 
 @@unscopables
  symbol can be defined as an object property 
 (
 Symbol.unscopa bles
 ) on any object to indicate which properties can and cannot 
 be exposed as lexical variables in a 
 with
  statement.
  
 Consider:
  
 var
 o
 =
 {
 a
 :
 1
 ,
 b
 :
 2
 ,
 c
 :
 3
 },
  
 a
 =
 10
 ,
 b
 =
 20
 ,
 c
 =
 30
 ;
  
 180 
  
 | 
  
 Chapter 7: Meta Programming",NA
Proxies,"One of the most obviously meta programming features added to ES6 is the 
 Proxy 
 feature.
  
 A proxy is a special kind of object you create that “wraps"" — or sits in front of —
 another normal object. You can register special handlers (aka 
 traps
 ) on the 
 proxy object which are called when various operations are performed against 
 the proxy. These handlers have the opportunity to perform extra logic in 
 addition to 
 forwarding 
 the operations on to the original target/wrapped object.
  
 One example of the kind of 
 trap
  handler you can define on a proxy is 
 get
  that 
 inter‐cepts the 
 [[Get]]
  operation — performed when you try to access a property 
 on an object. Consider:
  
 var
 obj
 =
 {
 a
 :
 1
 }, 
  
  
 handlers
 =
 { 
  
  
  
 get
 (
 target
 ,
 key
 ,
 context
 ){ 
  
  
  
  
 // note: target === obj, 
  
  
  
  
 // context === pobj 
  
  
  
  
 console
 .
 log
 (
 ""accessing: ""
 ,
 key
 ); 
   
  
 return
 Reflect
 .
 get
 ( 
  
  
  
  
  
 target
 ,
 key
 ,
 context 
  
  
  
  
 ); 
  
  
  
 } 
  
  
 }, 
  
  
 pobj
 =
 new
 Proxy
 (
 obj
 ,
 handlers
 );
  
 obj
 .
 a
 ;
  
 Proxies 
  
 | 
  
 18
 1
  
 www.it-ebooks.info",NA
Proxy Limitations,"These meta programming handlers trap a wide array of fundamental operations 
 you can perform against an object. However, there are some operations which 
 are not (yet, at least) available to intercept.
  
 For example, none of these operations are trapped and forwarded from 
 pobj
  
 proxy to 
 obj
  target:
  
 var
 obj
 =
 {
 a
 :
 1
 ,
 b
 :
 2
 }, 
  
 handlers
 =
 {..}, 
  
 pobj
 =
 new
 Proxy
 (
 obj
 ,
 handlers
 );
  
 typeof
 obj
 ; 
  
 String
 (
 obj
 ); 
  
 obj
 +
 """"
 ; 
  
 obj
 ==
 pobj
 ; 
  
 obj
 ===
 pobj
  
 Perhaps in the future, more of these underlying fundamental operations in the 
 lan‐guage will be interceptable, giving us even more power to extend JavaScript 
 from within itself.
  
  
 There are certain 
 invariants
  — behaviors which cannot be 
 overrid‐den — that apply to the use of proxy handlers. For 
 example, the result from the 
 isExtensible(..)
  handler is always 
 coerced to a 
 boolean
 . These invariants restrict some of your 
 ability to customize behaviors with proxies, but they do so only 
 to prevent you from creating strange and unusual (or 
 inconsistent) behavior. The condi‐tions for these invariants are 
 complicated so we won’t fully go into them here, but this post 
 (
 http://www.2ality.com/2014/12/es6-proxies.html#invariants
 ) 
 does a great job of covering them.
  
 184 
  
 | 
  
 Chapter 7: Meta Programming
  
 www.it-ebooks.info",NA
Revocable Proxies,"A regular proxy always traps for the target object, and cannot be modified after 
 cre‐ation — as long as a reference is kept to the proxy, proxying remains 
 possible. How‐ever, there may be cases where you want to create a proxy that 
 can be used only for a certain period of time and then disabled. The solution is 
 to create a 
 revocable proxy
 :
  
 var
 obj
 =
 {
 a
 :
 1
 }, 
  
  
 handlers
 =
 { 
  
  
  
 get
 (
 target
 ,
 key
 ,
 context
 ){ 
  
  
  
  
 // note: target === obj, 
  
  
  
  
 // context === pobj 
  
  
  
  
 console
 .
 log
 (
 ""accessing: ""
 ,
 key
 ); 
   
  
 return
 target
 [
 key
 ]; 
  
  
  
 } 
  
  
 }, 
  
  
 {
 proxy
 :
 pobj
 ,
 revoke
 :
 prevoke
 }
 = 
  
  
  
 Proxy
 .
 revocable
 (
 obj
 ,
 handlers
 );
  
 pobj
 .
 a
 ; 
  
 // accessing: a 
  
 // 1
  
 // later: 
  
 prevoke
 ();
  
 pobj
 .
 a
 ; 
  
 // TypeError
  
 A revocable proxy is created with 
 Proxy.revocable(..)
 , which is a regular function, 
 not a constructor like 
 Proxy(..)
 . Otherwise, it takes the same two arguments: 
 target 
 and 
 handlers
 .
  
 The return value of 
 Proxy.revoke(..)
  is not the proxy itself as with 
 new Proxy(..)
 . 
 Instead, it’s an object with two properties: 
 proxy
  and 
 revoke
  — we used object 
 destruc‐turing (see “Destructuring” in Chapter 2) to assign these properties to 
 pobj
  and 
 pre voke()
  variables, respectively.
  
 Once a revocable proxy is revoked, any attempts to access it (trigger any of its 
 traps) will throw a 
 TypeError
 .",NA
Using Proxies,"The meta programming benefits of these Proxy handlers should be obvious. We 
 can almost fully intercept (and thus override) the behavior of objects, meaning 
 we can extend object behavior beyond core JS in some very powerful ways. We’ll 
 look at a few example patterns to explore the possibilities.
  
 Proxies 
  
 | 
  
 18
 5",NA
Reflect,NA,NA
 API,"The 
 Reflect
  object is a plain object (like 
 Math
 ), not a function/constructor like the 
 other built-in natives.
  
 It holds static functions which correspond to various meta programming tasks 
 that you can control. These functions correspond one-to-one with the handler 
 methods (
 traps
 ) that Proxies can define.
  
 Some of the functions will look familiar as functions of the same names on 
 Object
 :
  
 •
  Reflect.getOwnPropertyDescriptor(..)
  
 •
  Reflect.defineProperty(..)
  
 •
  Reflect.getPrototypeOf(..)
  
 •
  Reflect.setPrototypeOf(..)
  
 •
  Reflect.preventExtensions(..)
  
 •
  Reflect.isExtensible(..)
  
 These utilities in general behave the same as their 
 Object.*
  counterparts. 
 However, one difference is that the 
 Object.*
  counterparts attempt to coerce their 
 first argu‐ment (the target object) to an object if it’s not already one. The 
 Reflect.*
  methods simply throw an error in that case.
  
 An object’s keys can be accessed/inspected using these utilities:
  
 •
  Reflect.ownKeys(..)
 : returns the list of all owned keys (not “inherited”), as 
 returned by both 
 Object.getOwnPropertyNames(..)
  and 
 Object.getOwnProper",NA
Property Ordering,NA,NA
Feature Testing,"What is a feature test? It’s a test that you run to determine if a feature is 
 available or not. Sometimes, the test is not just for existence, but for 
 conformance to specified behavior — features can exist but be buggy.
  
 This is a meta programming technique, to test the environment your program 
 runs in to then determine how your program should behave.
  
 The most common use of feature tests in JS is checking for the existence of an 
 API and if it’s not present, defining a polyfill (see Chapter 1). For example:
  
 if
 (
 !
 Number
 .
 isNaN
 ){
  
 Number
 .
 isNaN
 =
 function
 (
 x
 ){
  
 return
 x
 !==
 x
 ;
  
 };
  
 }
  
 The 
 if
  statement in this snippet is meta programming: we’re probing our 
 program and its runtime environment to determine if and how we should 
 proceed.
  
 196 
  
 | 
  
 Chapter 7: Meta Programming",NA
FeatureTests.io,"Defining feature tests for all of the ES6+ syntax, as well as the semantic 
 behaviors, is a daunting task you probably don’t want to tackle yourself. 
 Because these tests require dynamic compilation (
 new Function(..)
 ), there’s 
 some unfortunate performance cost.
  
 Moreover, running these tests every single time your app runs is probably 
 wasteful, as on average a user’s browser only updates once in a several week 
 period at most, and even then, new features aren’t necessarily showing up with 
 every update.
  
 Finally, managing the list of feature tests that apply to your specific code base —
 rarely will your programs use the entirety of ES6 — is unruly and error-prone.
  
 The “https://featuretests.io” feature-tests-as-a-service offers solutions to these 
 frustra‐tions.
  
 You can load the service’s library into your page, and it loads the latest test 
 definitions and runs all the feature tests. It does so using background-processing 
 with Web Workers, if possible, to reduce the performance overhead. It also uses 
 LocalStorage persistence to cache the results in a way that can be shared across 
 all sites you visit which use the service, which drastically reduces how often the 
 tests need to run on each browser instance.
  
 You get runtime feature tests in each of your users’ browsers, and you can use 
 those tests results dynamically to serve users the most appropriate code (no 
 more, no less) for their environments.
  
 198 
  
 | 
  
 Chapter 7: Meta Programming",NA
Tail Call Optimization (TCO),"Normally, when a function call is made from inside another function, a second 
 stack frame
  is allocated to separately manage the variables/state of that other 
 function invo‐cation. Not only does this allocation cost some processing time, 
 but it also takes up some extra memory.
  
 A call stack chain typically has at most 10-15 jumps from one function to 
 another and another. In those scenarios, the memory usage is not likely any kind 
 of practical problem.
  
 However, when you consider recursive programming (a function calling itself 
 repeat‐edly) — or mutual recursion with two or more functions calling each 
 other — the call stack could easily be hundreds, thousands, or more levels deep. 
 You can probably see the problems that could cause, if memory usage grows 
 unbounded.
  
 JavaScript engines have to set an arbitrary limit to prevent such programming 
 techni‐ques from crashing by running the browser and device out of memory. 
 That’s why we get the frustrating “RangeError: Maximum call stack size 
 exceeded” thrown if the limit is hit.
  
  
 The limit of call stack depth is not controlled by the 
 specification. It’s implementation dependent, and will vary 
 between browsers and devices. You should never code with 
 strong assumptions of exact observable limits, as they may 
 very well change from release to release.
  
 Certain patterns of function calls, called 
 tail calls
 , can be optimized in a way to 
 avoid the extra allocation of stack frames. If the extra allocation can be avoided, 
 there’s no reason to arbitrarily limit the call stack depth, so the engines can let 
 them run unbounded.
  
 It’s important to note that this optimization can only be applied in 
 strict
  mode. 
 Yet another reason to always be writing all your code as 
 strict
 !
  
 A tail call is a function call in the tail position — at the end of a function’s code 
 path— where nothing has to happen after the call except (optionally) returning 
 its value along to a previous function invocation.
  
 Tail Call Optimization (TCO) 
  
 | 
  
 19
 9",NA
Tail Call Rewrite,"The hitch however is that only tail calls can be optimized; non-tail calls will still 
 work of course, but will cause stack frame allocation as they always did. You’ll 
 have to be careful about structuring your functions with tail calls if you expect 
 the optimizations to kick in.
  
 If you have a function that’s not written with proper tail calls, you may find the 
 need to manually optimize your program by rewriting it, so that the engine will 
 be able to apply TCO when running it.
  
 Consider:
  
 ""use strict""
 ;
  
 function
 foo
 (
 x
 ){
  
 if
 (
 x
 <=
 1
 )
 return
 1
 ;
  
 return
 (
 x
 /
 2
 )
 +
 foo
 (
 x
 -
 1
 );
  
 }
  
 foo
 (
 123456
 );
 // RangeError
  
 The call to 
 foo(x-1)
  isn’t a proper tail call since its result has to be added to 
 (x / 2) 
 before `return`ing.
  
 However, we can reorganize this code to be eligible for TCO in an ES6 engine as:
  
 ""use strict""
 ;
  
 var
 foo
 =
 (
 function
 (){
  
 function
 _foo
 (
 acc
 ,
 x
 ){
  
 if
 (
 x
 <=
 1
 )
 return
 acc
 ;
  
 return
 _foo
 ((
 x
 /
 2
 )
 +
 acc
 ,
 x
 -
 1
 );
  
 }
  
 returnfunction
 (
 x
 ){
  
 return
 _foo
 (
 1
 ,
 x
 );
  
 };
  
 })();
  
 foo
 (
 123456
 );
 // 3810376848.5
  
 Tail Call Optimization (TCO) 
  
 | 
  
 20
 1
  
 www.it-ebooks.info",NA
Non-TCO Optimizations,"There are other techniques to rewrite the code so that the call stack isn’t 
 growing with each call.
  
 One such technique is called 
 trampolining
 , which amounts to having each partial 
 result represented as a function that either returns a another partial result 
 function or the final result. Then you can simply loop until you stop getting a 
 function, and you’ll have the result. Consider:
  
 ""use strict""
 ;
  
 function
 trampoline
 (
 res
 ){ 
  
  
 while
 (
 typeof
 res
 ==
 ""function""
 ){ 
  
  
  
 res
 =
 res
 (); 
  
  
 } 
  
  
 return
 res
 ; 
  
 }
  
 var
 foo
 =
 (
 function
 (){ 
  
  
 function
 _foo
 (
 acc
 ,
 x
 ){ 
  
  
  
 if
 (
 x
 <=
 1
 )
 return
 acc
 ; 
  
  
  
 returnfunction
 partial
 (){ 
  
  
  
  
 return
 _foo
 ((
 x
 /
 2
 )
 +
 acc
 ,
 x
 -
 1
 ); 
  
  
 }; 
  
  
 }
  
  
 returnfunction
 (
 x
 ){ 
  
  
  
 return
 trampoline
 (
 _foo
 (
 1
 ,
 x
 )); 
  
  
 }; 
  
 })();
  
 foo
 (
 123456
 );
 // 3810376848.5
  
 This reworking required minimal changes to factor out the recursion into the 
 loop in 
 trampoline(..)
 :
  
 1. First, we wrapped the 
 return _foo ..
  line in the 
 partial()
  function expres‐
  
 sion.
  
 2. Then we wrapped the 
 _foo(1,x)
  call in the 
 trampoline(..)
  call.
  
 The reason this technique doesn’t suffer the call stack limitiation is that each of 
 those inner 
 partial(..)
  functions is just returned back to the 
 while
  loop in 
 trampo 
 line(..)
 , which runs it and then loop iterates again. In other words, 
 partial(..)
  
 202 
  
 | 
  
 Chapter 7: Meta Programming
  
 www.it-ebooks.info",NA
Meta?,"So TCO is cool, right? But what does any of this have to do with meta 
 programming? Great question. You’re totally right to ask that!
  
 Short answer: I’m stretching the definition of “meta programming” to fit the TCO 
 topic into this chapter.
  
 As we covered in the “Feature Testing” section earlier, you can determine at 
 runtime what features an engine supports. This includes TCO, though 
 determining it is quite brute force. Consider:
  
 ""use strict""
 ;
  
 try
 { 
  
  
 (
 function
 foo
 (
 x
 ){ 
  
  
  
 if
 (
 x
 <
 5
 E5
 )
 foo
 (
 x
 +
 1
 ); 
  
  
 })(
 1
 );
  
  
 TCO_ENABLED
 =
 true
 ; 
  
 } 
  
 catch
 (
 err
 ){ 
  
  
 TCO_ENABLED
 =
 false
 ; 
  
 }
  
 Yuck, right?
  
 But how could meta programming around the TCO feature (or rather, the lack 
 thereof) benefit our code? The simple answer is that you could use such a 
 feature test to decide to load a version of your application’s code that uses 
 recursion, or an alter‐nate one that’s been converted/transpiled to not need 
 recursion.
  
 But here’s another way of looking at the problem:
  
 ""use strict""
 ;
  
 function
 foo
 (
 x
 ){ 
  
  
 function
 _foo
 (){ 
  
  
  
 if
 (
 x
 >
 1
 ){ 
  
  
  
  
 acc
 =
 acc
 +
 (
 x
 /
 2
 ); 
  
  
  
  
 x
 =
 x
 -
 1
 ; 
  
  
  
  
 _foo
 (); 
  
  
  
 } 
  
  
 }
  
 var
 acc
 =
 1
 ;
  
 204 
  
 | 
  
 Chapter 7: Meta Programming",NA
Review,"Meta programming is when you turn the logic of your program to focus on itself 
 (or its runtime environment), either to inspect its own structure or to modify it. 
 The pri‐mary value of meta programming is to extend the normal mechanisms 
 of the lan‐guage to provide additional capabilities.
  
 Prior to ES6, JavaScript already had quite a bit of meta programming capability, 
 but ES6 significantly ramps that up with several new features.
  
 From function name inferences for anonymous functions to meta properties 
 that give you information about things like how a constructor was invoked, you 
 can inspect the program structure while it runs more than ever before. Well 
 Known Symbols let you override intrinsic behaviors, such as coercion of an 
 object to a primitive value. Proxies can intercept and customize various low-
 level operations on objects, and 
 Reflect
  provides utilities to emulate them.
  
 Feature testing, even for subtle semantic behaviors like Proper Tail Call 
 optimiza‐tions, shifts the meta programming focus from your program to the JS 
 engine capa‐bilities itself. By knowing more about what the environment can do, 
 your programs can adjust themselves to the best fit as they run.
  
 Should you meta program? My advice is: first focus on learning how the core 
 mechanics of the language really work. But once you fully know what JS itself 
 can do, it’s time to start leveraging these powerfu meta programming 
 capabilities to push the language further!
  
 206 
  
 | 
  
 Chapter 7: Meta Programming
  
 www.it-ebooks.info",NA
CHAPTER 8,NA,NA
Beyond ES6,"At the time of this writing, the final draft of ES6 (
 ECMAScript 2015
 ) is shortly 
 headed toward its final official vote of approval by ECMA. But even as ES6 is 
 being finalized, the TC39 committee is already hard at work at on features for 
 ES7/2016 and beyond.
  
 As we discussed in Chapter 1, it’s expected that the cadence of progress for JS is 
 going to accelerate from updating one every several years to having an official 
 version update one per year (hence the year-based naming). That alone is going 
 to radically change how JS developers learn about and keep up with the 
 language.
  
 But even more importantly, the committee is actually going to work feature-by-
 feature. As soon as a feature is spec-complete and had its kinks worked out 
 through implementation experiments in a few browsers, that feature will be 
 considered stable enough to start using. We’re all strongly encouraged to adopt 
 features once they’re ready instead of waiting for some official standards vote. 
 If 
 you haven’t already learned ES6, it’s past due time to get on board!
  
 As the time of this writing, a list of future proposals and their status can be seen 
 here (
 https://github.com/tc39/ecma262#current-proposals
 ).
  
 Transpilers and polyfills are how we’ll bridge to these new features even before 
 all browsers we support have implemented them. Babel, Traceur, and several 
 other major transpilers already have support for some of the post ES6 features 
 that are most likely to stabilize.
  
 With that in mind, it’s already time for us to look at some of them. Let’s jump in!
  
 207",NA
`async function`s,"In “Generators + Promises” in Chapter 4, we mentioned that there’s a proposal 
 for direct syntactic support for the pattern of generators 
 yield`ing promises to a 
 runner-like utility that will resume it on promise completion. Let's take a brief look 
 at that proposed feature, called `async function
 .
  
 Recall this generator example from Chapter 4:
  
 run
 (
 function
 *
 main
 (){ 
  
  
 var
 ret
 =
 yield
 step1
 ();
  
 try
 { 
  
  
 ret
 =
 yield
 step2
 (
 ret
 ); 
  
 } 
  
 catch
 (
 err
 ){ 
  
  
 ret
 =
 yield
 step2Failed
 (
 err
 ); 
  
 }
  
 ret
 =
 yield
 Promise
 .
 all
 ([ 
  
  
 step3a
 (
 ret
 ), 
  
  
 step3b
 (
 ret
 ), 
  
  
 step3c
 (
 ret
 ) 
  
 ]);
  
  
 yield
 step4
 (
 ret
 ); 
  
 }) 
  
 .
 then
 ( 
  
  
 function
 fulfilled
 (){ 
  
  
  
 // `*main()` completed successfully 
  
 }, 
  
  
 function
 rejected
 (
 reason
 ){ 
  
  
  
 // Oops, something went wrong 
  
  
 } 
  
 );
  
 The proposed 
 async function
  syntax can express this same flow control logic 
 without needing the 
 run(..)
  utility, since JS will automatically know how to look 
 for promises to wait-and-resume. Consider:
  
 async
 function
 main
 (){ 
  
  
 var
 ret
 =
 awaitstep1
 ();
  
 try
 {
  
 208 
  
 | 
  
 Chapter 8: Beyond ES6
  
 www.it-ebooks.info",NA
Caveats,"One unresolved point of contention with 
 async function
  is that since it only 
 returns a promise, there’s no way from the outside to 
 cancel
  an 
 async function
  
 instance that’s currently running. This can be a problem if the async operation is 
 resource intensive, and you want to free up the resources as soon as you’re sure 
 the result won’t be needed.
  
 For example:
  
 async
 function
 request
 (
 url
 ){ 
  
  
 var
 resp
 =
 await
 ( 
  
  
  
 new
 Promise
 (
 function
 (
 resolve
 ,
 reject
 ){ 
  
  
  
 var
 xhr
 =
 new
 XMLHttpRequest
 (); 
  
  
  
  
 xhr
 .
 open
 (
 ""GET""
 ,
 url
 ); 
  
  
  
  
 xhr
 .
 onreadystatechange
 =
 function
 (){ 
  
  
  
  
 if
 (
 xhr
 .
 readyState
 ==
 4
 ){ 
  
  
  
  
  
  
 if
 (
 xhr
 .
 status
 ==
 200
 ){ 
  
  
  
  
  
  
  
 resolve
 (
 xhr
 ); 
  
  
  
  
  
  
 } 
  
  
  
  
  
  
 else
 { 
  
  
  
  
  
  
  
 reject
 (
 xhr
 .
 statusText
 ); 
  
  
  
  
  
 } 
  
  
  
  
  
 } 
  
  
  
  
 }; 
  
  
  
  
 xhr
 .
 send
 (); 
  
  
  
 }) 
  
  
 );
  
  
 return
 resp
 .
 responseText
 ; 
  
 }
  
 var
 pr
 =
 request
 (
 ""http://some.url.1""
 );
  
 pr
 .
 then
 ( 
  
  
 function
 fulfilled
 (
 responseText
 ){ 
  
  
  
 // ajax success 
  
  
 }, 
  
  
 function
 rejected
 (
 reason
 ){ 
  
  
  
 // Oops, something went wrong
  
 210 
  
 | 
  
 Chapter 8: Beyond ES6
  
 www.it-ebooks.info",NA
Object.observe(..),"One of the holy grails of front-end web development is data binding — listening 
 for updates to a data object and syncing the DOM representation of that data. 
 Most JS frameworks provide some mechanism for these sorts of operations.
  
 It appears likely that post ES6, we’ll see support added directly to the language, 
 via a utility called 
 Object.observe(..)
 . Essentially, the idea is that you can set up a 
 lis‐tener to observe an object’s changes, and have a callback called any time a 
 change occurs. You can then update the DOM accordingly, for instance.
  
 There are six types of changes that you can observe:
  
 • add
  
 • update
  
 • delete
  
 • reconfigure
  
 Object.observe(..) 
  
 | 
  
 21
 1
  
 www.it-ebooks.info",NA
Custom Change Events,"In addition to the six built-in change event types, you can also listen for and fire 
 cus‐tom change events.
  
 Consider:
  
 function
 observer
 (
 changes
 ){ 
  
  
 for
 (
 var
 changeofchanges
 ){ 
  
  
  
 if
 (
 change
 .
 type
 ==
 ""recalc""
 ){ 
  
  
  
  
 change
 .
 object
 .
 c
 = 
  
  
  
  
  
 change
 .
 object
 .
 oldValue
 + 
  
  
  
  
  
 change
 .
 object
 .
 a
 + 
  
  
  
  
  
 change
 .
 object
 .
 b
 ; 
  
  
  
 } 
  
  
 } 
  
 }
  
 function
 changeObj
 (
 a
 ,
 b
 ){ 
  
  
 var
 notifier
 =
 Object
 .
 getNotifier
 (
 obj
 );
  
 obj
 .
 a
 =
 a
 *
 2
 ; 
  
 obj
 .
 b
 =
 b
 *
 3
 ;
  
  
 // queue up change events into a set 
  
  
 notifier
 .
 notify
 ({ 
  
  
  
 type
 :
 ""recalc""
 , 
  
  
  
 name
 :
 ""c""
 , 
  
  
  
 oldValue
 :
 obj
 .
 c 
  
  
 }); 
  
 }
  
 var
 obj
 =
 {
 a
 :
 1
 ,
 b
 :
 2
 ,
 c
 :
 3
 };
  
 Object
 .
 observe
 ( 
  
  
 obj
 , 
  
  
 observer
 , 
  
  
 [
 ""recalc""
 ] 
  
 );
  
 changeObj
 (
 3
 ,
 11
 );
  
 obj
 .
 a
 ;
 // 
 12 
  
 obj
 .
 b
 ;
 // 
 30 
  
 obj
 .
 c
 ;
 // 3
  
 The change set (
 ""recalc""
  custom event) has been queued for delivery to the 
 observer, but not delivered yet, which is why 
 obj.c
  is still 
 3
 .
  
 The changes are by default delivered at the end of the current event loop (see 
 the 
 Async & Performance
  title of this series). If you want to deliver them 
 immediately, use
  
 Object.observe(..) 
  
 | 
  
 21
 3",NA
Ending Observation,"Just like with normal event listeners, you may wish to stop observing an object’s 
 change events. For that, you use 
 Object.unobserve(..)
 .
  
 For example:
  
 var
 obj
 =
 {
 a
 :
 1
 ,
 b
 :
 2
 };
  
 Object
 .
 observe
 (
 obj
 ,
 function
 observer
 (
 changes
 ){ 
  
 for
 (
 var
 changeofchanges
 ){ 
  
  
  
 if
 (
 change
 .
 type
 ==
 ""setPrototype""
 ){ 
  
  
  
  
 Object
 .
 unobserve
 ( 
  
  
  
  
  
 change
 .
 object
 ,
 observer 
  
  
  
  
 ); 
  
  
  
  
 break
 ; 
  
  
  
 } 
  
  
 } 
  
 });
  
 In this trivial example, we listen for change events until we see the 
 ""setPrototype"" 
 event come through, at which time we stop observing any more 
 change events.",NA
Exponentiation Operator,"An operator has been proposed for JavaScript to perform exponentiation in the 
 same way that 
 Math.pow(..)
  does. Consider:
  
 var
 a
 =
 2
 ;
  
 214 
  
 | 
  
 Chapter 8: Beyond ES6",NA
Objects Properties and ,NA,NA
...,"As we saw in the “Too Many, Too Few, Just Enough” section of Chapter 2, the 
 ... 
 operator is pretty obvious in how it relates to spreading or gathering arrays. But 
 what about objects?
  
 Such a feature was considered for ES6, but was deferred to be considered after 
 ES6 (aka “ES7” or “ES2016” or …). Here’s how it might work in that “beyond 
 ES6” time‐frame:
  
 var
 o1
 =
 {
 a
 :
 1
 ,
 b
 :
 2
 },
  
 o2
 =
 {
 c
 :
 3
 },
  
 o3
 =
 {...
 o1
 ,...
 o2
 ,
 d
 :
 4
 };
  
 console
 .
 log
 (
 o3
 .
 a
 ,
 o3
 .
 b
 ,
 o3
 .
 c
 ,
 o3
 .
 d
 );
  
 // 1 2 3 4
  
 The 
 ...
  operator might also be used to gather an object’s destructured properties 
 back into an object:
  
 var
 o1
 =
 {
 b
 :
 2
 ,
 c
 :
 3
 ,
 d
 :
 4
 };
  
 var
 {
 b
 ,...
 o2
 }
 =
 o1
 ;
  
 console
 .
 log
 (
 b
 ,
 o2
 .
 c
 ,
 o2
 .
 d
 );
 // 2 3 4
  
 Here, the 
 ...o2
  re-gathers the destructured 
 c
  and 
 d
  properties back into an 
 o2
  
 object (
 o2
  does not have a 
 b
  property like 
 o1
  does).
  
 Again, these are just proposals under consideration beyond ES6. But it’ll be cool 
 if they do land.",NA
Array#includes(..),"One extremely common task JS developers need to perform is searching for a 
 value inside an array of values. The way this has always been done is:
  
 var
 vals
 =
 [
 ""foo""
 ,
 ""bar""
 ,
 42
 ,
 ""baz""
 ];
  
 Objects Properties and ... 
  
 | 
  
 21
 5
  
 www.it-ebooks.info",NA
SIMD,"We cover SIMD (Single Instruction Multiple Data) in more detail in the 
 Async & 
 Per‐formance
  title of this series, but it bears a brief mention here, as its one of 
 the next likely features to land in a future JS.
  
 216 
  
 | 
  
 Chapter 8: Beyond ES6",NA
Review,"If all the other books in this series essentially propose this challenge, “you (may) 
 not know JS as much as you thought)”, this book has instead suggested, “you 
 don’t know JS anymore.” We’ve covered a ton of new stuff added to the language 
 in ES6. It’s an exciting collection of new language features and paradigms that 
 will forever improve our JS programs.
  
 But JS is not done with ES6! Not even close. There’s already quite a few features 
 in various stages of development for the beyond ES6 timeframe. In this chapter 
 we briefly looked at some of the most likely candidates to land in JS very soon.
  
 async function`s are powerful syntactic sugar on top of the generators +
  
 promises pattern (see Chapter 4). `Object.observe(..)
  adds direct native support for 
 observing object change events, which is critical for implementing data binding. 
 The 
 **
  exponentiation operator, 
 ...
  for object properties, and 
 Array#includes(..)
  
 are all simple but helpful improvements to existing mecha‐nisms. Finally, SIMD 
 ushers in a new era in the evolution of high performance JS.
  
 Cliché as it sounds, the future of JS is really bright! The challenge of this series, 
 and indeed of this book, is encumbent on every reader now. What are you 
 waiting for? Isn’t it time to get learning and exploring!?
  
 Review 
  
 | 
  
 21
 7",NA
