Larger Text,Smaller Text,Symbol
TypeScript: Modern ,NA,NA
JavaScript Development,"Leverage the features of TypeScript to boost 
  
 your development skills and create captivating 
  
 web applications",NA
A course in three modules,BIRMINGHAM - MUMBAI,NA
TypeScript: Modern JavaScript Development,"Copyright © 2016 Packt Publishing
  
 All rights reserved. No part of this course may be reproduced, stored in a retrieval 
 system, or transmitted in any form or by any means, without the prior written 
 permission of the publisher, except in the case of brief quotations embedded in critical 
 articles or reviews.
  
 Every effort has been made in the preparation of this course to ensure the accuracy of 
 the information presented. However, the information contained in this course is sold 
 without warranty, either express or implied. Neither the authors, nor Packt Publishing, 
 and its dealers and distributors will be held liable for any damages caused or alleged to 
 be caused directly or indirectly by this course.
  
 Packt Publishing has endeavored to provide trademark information about all of the 
 companies and products mentioned in this course by the appropriate use of capitals. 
  
 However, Packt Publishing cannot guarantee the accuracy of this information.
  
 Published on: December 2016
  
 Published by Packt Publishing Ltd.
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham B3 2PB, UK. 
  
 ISBN 978-1-78728-908-6
  
 www.packtpub.com",NA
Credits,"Authors 
  
 Remo H. Jansen 
  
 Vilic Vane 
  
 Ivo Gabe de Wolff
  
 Reviewers 
  
 Liviu Ignat 
  
 Jakub Jedryszek 
  
 Andrew Leith Macrae 
 Brandon Mills 
  
 Ivo Gabe de Wolff 
  
 Wander Wang 
  
 Matthew Hill
  
 Content Development Editor 
  
 Rohit Kumar Singh
  
 Graphics 
  
  
 Jason Monteiro
  
 Production Coordinator 
  
 Shraddha Falebhai",NA
Preface,"It wasn’t a long time ago that many JavaScript engineers or, most of the time, web 
 frontend engineers, were still focusing on solving detailed technical issues, such as 
 how to lay out specific content cross-browsers and how to send requests cross-
 domains.
  
 At that time, a good web frontend engineer was usually expected to have notable 
 experience on how detailed features can be implemented with existing APIs. Only a 
 few people cared about how to write application-scale JavaScript because the 
 interaction on a web page was really simple and no one wrote ASP in JavaScript.
  
 However, the situation has changed tremendously. JavaScript has become the only 
 language that runs everywhere, cross-platform and cross-device. In the main battlefield, 
 interactions on the Web become more and more complex, and people are moving 
 business logic from the backend to the frontend. With the growth of the Node.
  
 js community, JavaScript is playing a more and more important roles in our life.
  
 TypeScript is indeed an awesome tool for JavaScript. Unfortunately, intelligence is still 
 required to write actually robust, maintainable, and reusable code. TypeScript allows 
 developers to write readable and maintainable web applications. Editors can provide 
 several tools to the developer, based on types and static analysis of the code.",NA
What this learning path covers,"Module 1, Learning TypeScript
 , introduces many of the TypeScript features in a simple 
 and easy-to-understand format. This book will teach you everything you need to know 
 in order to implement large-scale JavaScript applications using TypeScript. Not only 
 does it teach TypeScript’s core features, which are essential to implement a web 
 application, but it also explores the power of some tools, design principles, best 
 practices, and it also demonstrates how to apply them in a real-life application.
  
 [
  i 
 ]",NA
What you need for this learning path,"You will need the TypeScript compiler and a text editor. This learning path explains how 
 to use Atom, but it is also possible to use other editors, such as Visual Studio 2015, 
 Visual Studio Code, or Sublime Text.
  
 You also need an Internet connection to download the required references and online 
 packages and libraries, such as jQuery, Mocha, and Gulp. Depending on your operating 
 system, you will need a user account with administrative privileges in order to install 
 some of the tools used in this learning path. Also to compile TypeScript, you need 
 NodeJS. You can find details on how you can install it in the first chapter of the third 
 module.",NA
Who this learning path is for,"This learning path is for the intermediate-level JavaScript developers aiming to learn 
 TypeScript to build beautiful web applications and fun projects. No prior knowledge of 
 TypeScript is required but a basic understanding of jQuery is expected. This learning 
 path is also for experienced TypeScript developer wanting to take their skills to the 
 next level, and also for web developers who wish to make the most of TypeScript.",NA
Reader feedback,"Feedback from our readers is always welcome. Let us know what you think about this 
 course—what you liked or disliked. Reader feedback is important for us as it helps us 
 develop titles that you will really get the most out of.
  
 To send us general feedback, simply e-mail 
 feedback@packtpub.com
 , and mention the 
 course’s title in the subject of your message.
  
 [
  ii 
 ]",NA
Customer support,"Now that you are the proud owner of a Packt course, we have a number of things to help 
 you to get the most from your purchase.",NA
Downloading the example code,"You can download the example code files for this course from your account at 
 http://www.packtpub.com
 . If you purchased this course elsewhere, you can visit 
 http://www.packtpub.com/support
  and register to have the files e-mailed directly to 
 you.
  
 You can download the code files by following these steps:
  
 1. 
 Log in or register to our website using your e-mail address and password.
  
 2. 
 Hover the mouse pointer on the 
 SUPPORT
  t0the top.
  
 3. 
 Click on 
 Code Downloads & Errata
 .
  
 4. 
 Enter the name of the course in the 
 Search
  box.
  
 5. 
 Select the course for which you’re looking to download the code files.
  
 6. 
 Choose from the drop-down menu where you purchased this course from.
  
 7. 
 Click on 
 Code Download
 .
  
 You can also download the code files by clicking on the 
 Code Files
  button on the 
 course’s webpage at the Packt Publishing website. This page can be accessed by entering 
 the course’s name in the 
 Search
  box. Please note that you need to be logged in to your 
 Packt account.
  
 Once the file is downloaded, please make sure that you unzip or extract the folder 
 using the latest version of:
  
 •
  
 WinRAR / 7-Zip for Windows
  
 •
  
 Zipeg / iZip / UnRarX for Mac
  
 •
  
 7-Zip / PeaZip for Linux
  
 The code bundle for the course is also hosted on GitHub at 
 https://github.com/ 
 PacktPublishing/TypeScript-Modern-JavaScript-Development
 . We also have 
 other code bundles from our rich catalog of books, videos, and courses available at 
 https://github.com/PacktPublishing/
 . Check them out!
  
 [
  iii 
 ]",NA
Errata,"Although we have taken every care to ensure the accuracy of our content, mistakes do 
 happen. If you find a mistake in one of our courses—maybe a mistake in the text or the 
 code—we would be grateful if you could report this to us. By doing so, you can save 
 other readers from frustration and help us improve subsequent versions of this course. 
 If you find any errata, please report them by visiting 
 http://www.
  
 packtpub.com/submit-errata
 , selecting your course, clicking on the 
 Errata 
 Submission Form
  link, and entering the details of your errata. Once your errata are 
 verified, your submission will be accepted and the errata will be uploaded to our 
 website or added to any list of existing errata under the Errata section of that title.
  
 To view the previously submitted errata, go to 
 https://www.packtpub.com/books/ 
 content/support
  and enter the name of the course in the search field. The required 
 information will appear under the 
 Errata
  section.",NA
Piracy,"Piracy of copyrighted material on the Internet is an ongoing problem across all media. At 
 Packt, we take the protection of our copyright and licenses very seriously. If you come 
 across any illegal copies of our works in any form on the Internet, please provide us with 
 the location address or website name immediately so that we can pursue a remedy.
  
 Please contact us at 
 copyright@packtpub.com
  with a link to the suspected pirated 
 material.
  
 We appreciate your help in protecting our authors and our ability to bring you 
 valuable content.",NA
Questions,"If you have a problem with any aspect of this course, you can contact us at 
 questions@packtpub.com
 , and we will do our best to address the problem.
  
 [
  iv 
 ]",NA
Module 1: Learning TypeScript,"Chapter 1: Introducing TypeScript 
 The TypeScript architecture  
 TypeScript language features  
 Putting everything together  
 Summary  
 Chapter 2: Automating Your Development Workflow 
 A modern development workflow  
 Prerequisites  
 Source control tools  
 Package management tools  
 Task runners  
 Test runners  
 Synchronized cross-device testing  
 Continuous Integration tools  
 Scaffolding tools  
 Summary  
 Chapter 3: Working with Functions 
  
 Working with functions in TypeScript  
 Asynchronous programming in TypeScript 
 Summary  
 Chapter 4: Object-Oriented Programming with TypeScript 
 SOLID principles  
 Classes  
 Interfaces  
 Association, aggregation, and composition  
 Inheritance  
 Generic classes  
 1 
  
 2  
 4  
 26  
 27 
 29 
  
 29  
 30  
 33  
 38  
 43  
 53  
 55  
 58  
 59  
 61 
 63 
  
 64  
 83  
 98 
 99 
  
 100  
 101  
 104  
 105  
 107  
 115",NA
Module 1,"Learning TypeScript
  
 Exploit the features of TypeScript to develop and maintain captivating web 
  
 applications with ease",NA
Introducing TypeScript,"This book focuses on TypeScript's object-oriented nature and how it can help you 
  
 to write better code. Before diving into the object-oriented programing features of 
  
 TypeScript, this chapter will give you an overview of the history behind TypeScript 
  
 and introduce you to some of the basics.
  
 In this chapter, you will learn about the following concepts:
  
 • 
  
 The TypeScript architecture
  
 • 
  
 Type annotations
  
 • 
  
 Variables and primitive data types
  
 • 
  
 Operators
  
 • 
  
 Flow control statements
  
 • 
  
 Functions
  
 • 
  
 Classes
  
 • 
  
 Interfaces
  
 • 
  
 Modules
  
 [
  1 
 ]",NA
The TypeScript architecture,"In this section, we will focus on the TypeScript's internal architecture and its original 
 design goals.",NA
Design goals,"In the following points, you will find the main design goals and architectural 
 decisions that shaped the way the TypeScript programming language looks like 
 today:
  
 • 
  
 • 
  
 • 
  
 • 
  
 Statically identify JavaScript constructs that are likely to be errors. The 
  
 engineers at Microsoft decided that the best way to identify and prevent 
 potential runtime issues was to create a strongly typed programming language 
 and perform static type checking at compilation time. The engineers also 
 designed a language services layer to provide developers with better tools.
  
 High compatibility with the existing JavaScript code. TypeScript is a superset of 
 JavaScript; this means that any valid JavaScript program is also a valid 
 TypeScript program (with a few small exceptions).
  
 Provide a structuring mechanism for larger pieces of code. TypeScript adds 
 class-based object orientation, interfaces, and modules. These features will help 
 us structure our code in a much better way. We will also reduce potential 
 integration issues within our development team and our code will become 
 more maintainable and scalable by adhering to the best object-oriented 
 principles and practices.
  
 Impose no runtime overhead on emitted programs. It is common to 
  
 differentiate between design time and execution time when working with 
 TypeScript. We use the term 
 design time code
  to refer to the TypeScript code 
 that we write while designing an application; we use the terms 
 execution time 
 code 
 or 
 runtime code
  to refer to the JavaScript code that is executed after 
 compiling some TypeScript code.
  
 TypeScript adds features to JavaScript but those features are only available at 
 design time. For example, we can declare interfaces in TypeScript but since 
 JavaScript doesn't support interfaces, the TypeScript compiler will not declare 
 or try to emulate this feature in the output JavaScript code. 
  
 The Microsoft engineers provided the TypeScript compiler with mechanisms such 
 as code transformations (converting TypeScript features into plain JavaScript 
 implementations) and type erasure (removing static type notation) to generate 
 really clean JavaScript code. Type erasure removes not only the type annotations 
 but also all the TypeScript exclusive language features such as interfaces.
  
 [
  2 
 ]",NA
TypeScript components,"The TypeScript language is internally divided into three main layers. Each of these 
 layers is, in turn, divided into sublayers or components. In the following diagram, we 
 can see the three layers (green, blue, and orange) and each of their internal 
 components (boxes):
  
  
  
  
  
 In the preceding diagram, the acronym 
 VS
  refers to Microsoft's Visual 
  
  
 Studio, which is the official integrated development environment for 
  
 all the Microsoft products (including TypeScript). We will learn more 
  
 about this and the other IDEs in the next chapter.
  
 [
  3 
 ]",NA
TypeScript language features,"Now that you have learned about the purpose of TypeScript, it's time to get our 
 hands dirty and start writing some code.
  
 Before you can start learning how to use some of the basic TypeScript building blocks, 
 you will need to set up your development environment. The easiest and fastest way to 
 start writing some TypeScript code is to use the online editor available on the official",NA
Types,"As we have already learned, TypeScript is a typed superset of JavaScript. TypeScript 
 added optional static type annotations to JavaScript in order to transform it into a 
 strongly typed programming language. The optional static type annotations are used as 
 constraints on program entities such as functions, variables, and properties so that 
 compilers and development tools can offer better verification and assistance (such as 
 IntelliSense) during software development.
  
 Strong typing allows the programmer to express his intentions in his code, both to 
 himself and to others in the development team.
  
 Typescript's type analysis occurs entirely at compile time and adds no runtime 
 overhead to program execution.",NA
Optional static type notation,"The TypeScript language service is really good at inferring types, but there are 
 certain cases where it is not able to automatically detect the type of an object or 
 variable. For these cases, TypeScript allows us to explicitly declare the type of a 
 variable. The language element that allows us to declare the type of a variable is 
 known as 
 optional static type notation
 . For a variable, the type notation comes 
 after the variable name and is preceded by a colon:
  
 var counter;               // unknown (any) type
  
 var counter = 0;           // number (inferred)
  
 var counter : number;      // number
  
 var counter : number = 0;  // number
  
 As you can see, the type of the variable is declared after the name, this style of type 
 notation is based on type theory and helps to reinforce the idea of types being 
 optional. When no type annotations are available, TypeScript will try to guess the type 
 of the variable by examining the assigned values. For example, in the second line in the 
 preceding code snippet, we can see that the variable counter has been identified as a 
 numeric variable because the numeric value 0 was assigned as its value. This process 
 in which types are automatically detected is known as 
 Type inference
 , when a type 
 cannot be inferred the especial type any is used as the type of the variable.
  
 [
  7 
 ]",NA
"Variables, basic types, and operators","The basic types are the Boolean, number, string, array, void types, and all user defined 
 Enum types. All types in TypeScript are subtypes of a single top type called the 
 Any type
 . 
 The 
 any
  keyword references this type. Let's take a look at each of these primitive types:
  
 Data Type
  
 Description
  
 Boolean
  
 Whereas the string and number data types can have a virtually unlimited 
 number of different values, the Boolean data type can only have two. They 
 are the literals 
 true
  and 
 false
 . A Boolean value is a truth value; it specifies 
 whether the condition is true or not.
  
 var isDone: boolean = false;
  
 Number
  
 As in JavaScript, all numbers in TypeScript are floating point values. 
 These floating-point numbers get the type 
 number
 .
  
 var height: number = 6;
  
 String
  
 You use the string data type to represent text in TypeScript. You include string 
 literals in your scripts by enclosing them in single or double quotation marks. 
 Double quotation marks can be contained in strings surrounded by single 
 quotation marks, and single quotation marks can be contained in strings 
 surrounded by double quotation marks. 
  
 var name: string = ""bob"";
  
 name = 'smith';
  
 Array
  
 TypeScript, like JavaScript, allows you to work with arrays of values. Array types 
 can be written in one of the two ways. In the first, you use the type of the 
 elements followed by 
 []
  to denote an array of that element type:
  
 var list:number[] = [1, 2, 3];
  
 The second way uses a generic array type, 
 Array
 :
  
 var list:Array<number> = [1, 2, 3];
  
 Enum
  
 An enum is a way of giving more friendly names to sets of numeric values. By 
 default, enums begin numbering their members starting at 0, but you can 
 change this by manually setting the value of one to its members.
  
 enum Color {Red, Green, Blue};
  
 var c: Color = Color.Green;
  
 [
  8 
 ]",NA
"Var, let, and const","When we declare a variable in TypeScript, we can use the 
 var
 , 
 let
 , or 
 const 
 keywords:
  
 var mynum : number = 1;
  
 let isValid : boolean = true;
  
 const apiKey : string = ""0E5CE8BD-6341-4CC2-904D-C4A94ACD276E"";
  
 Variables declared with 
 var
  are scoped to the nearest function block (or global, if 
 outside a function block).
  
 Variables declared with 
 let
  are scoped to the nearest enclosing block (or global if 
 outside any block), which can be smaller than a function block.
  
 The 
 const
  keyword creates a constant that can be global or local to the block in 
 which it is declared. This means that constants are block scoped. You will learn 
 more about scopes in 
 Chapter 5
 , 
 Runtime
 .
  
  
 The 
 let
  and 
 const
  keywords have been available since the 
  
  
 release of TypeScript 1.4 but only when the compilation target 
  
 is ECMAScript 6. However, they will also work when targeting 
  
 ECMAScript 3 and ECMAScript 5 once TypeScript 1.5 is released.",NA
Union types,"TypeScript allows you to declare union types:
  
 var path : string[]|string;
  
 path = '/temp/log.xml';
  
 path = ['/temp/log.xml', '/temp/errors.xml'];
  
 path = 1; // Error
  
 Union types are used to declare a variable that is able to store a value of two or more 
 types. In the preceding example, we have declared a variable named path that can contain 
 a single path (string), or a collection of paths (array of string). In the example, we have 
 also set the value of the variable. We assigned a string and an array of strings without 
 errors; however, when we attempted to assign a numeric value, we got a compilation 
 error because the union type didn't declare a number as one of the valid types of the 
 variable.
  
 [
  10 
 ]",NA
Type guards,"We can examine the type of an expression at runtime by using the 
 typeof
  or 
 instanceof
  operators. The TypeScript language service looks for these operators 
 and will change type inference accordingly when used in an 
 if
  block:
  
 var x: any = { /* ... */ };
  
 if(typeof x === 'string') {
  
  
  console.log(x.splice(3, 1)); // Error, 'splice' does not exist  
 on 'string'
  
 }
  
 // x is still any
  
 x.foo(); // OK
  
 In the preceding code snippet, we have declared an 
 x
  variable of type 
 any
 . Later, we 
 check the type of 
 x
  at runtime by using the 
 typeof
  operator. If the type of 
 x
  results to be 
 string, we will try to invoke the method splice, which is supposed to a member of the x 
 variable. The TypeScript language service is able to understand the usage of 
 typeof
  in a 
 conditional statement. TypeScript will automatically assume that 
 x
  must be a string and 
 let us know that the 
 splice
  method does not exist on the type string. This feature is 
 known as 
 type guards
 .",NA
Type aliases,"TypeScript allows us to declare type aliases by using the 
 type
  keyword:
  
 type PrimitiveArray = Array<string|number|boolean>;
  
 type MyNumber = number;
  
 type NgScope = ng.IScope;
  
 type Callback = () => void;
  
 Type aliases are exactly the same as their original types; they are simply alternative 
 names. Type aliases can help us to make our code more readable but it can also lead to 
 some problems.
  
 If you work as part of a large team, the indiscriminate creation of aliases can lead to 
 maintainability problems. In the book, 
 Maintainable JavaScript
 , 
 Nicholas C. Zakas
 , the 
 author recommends to avoid modifying objects you don't own. Nicholas was talking 
 about adding, removing, or overriding methods in objects that have not been declared 
 by you (DOM objects, BOM objects, primitive types, and third-party libraries) but we 
 can apply this rule to the usage of aliases as well.
  
 [
  11 
 ]",NA
Ambient declarations,"Ambient declaration allows you to create a variable in your TypeScript code that will not 
 be translated into JavaScript at compilation time. This feature was designed to facilitate 
 integration with the existing JavaScript code, the 
 DOM
  (
 Document Object Model
 ), and 
 BOM
  (
 Browser Object Model
 ). Let's take a look at an example:
  
 customConsole.log(""A log entry!"");  // error
  
 If you try to call the member log of an object named 
 customConsole
 , TypeScript will let 
 us know that the 
 customConsole
  object has not been declared:
  
 // Cannot find name 'customConsole'
  
 This is not a surprise. However, sometimes we want to invoke an object that has not 
 been defined, for example, the 
 console
  or 
 window
  objects.
  
 console.log(""Log Entry!"");
  
 var host = window.location.hostname;
  
 When we access DOM or BOM objects, we don't get an error because these objects 
 have already been declared in a special TypeScript file known as 
 declaration files
 . 
 You can use the declare operator to create an ambient declaration. 
  
 In the following code snippet, we will declare an interface that is implemented by the 
 customConsole
  object. We then use the declare operator to add the 
 customConsole 
 object to the scope:
  
 interface ICustomConsole {
  
  log(arg : string) : void;
  
 }
  
 declare var customConsole : ICustomConsole;
  
  
 Interfaces are explained in greater detail later in the chapter.
  
  
 We can then use the 
 customConsole
  object without compilation errors:
  
 customConsole.log(""A log entry!""); // ok
  
 TypeScript includes, by default, a file named 
 lib.d.ts
  that provides interface 
 declarations for the built-in JavaScript library as well as the DOM.
  
 Declaration files use the file extension 
 .d.ts
  and are used to increase the TypeScript 
 compatibility with third-party libraries and run-time environments such as Node.js or a 
 web browser.
  
 [
  12 
 ]",NA
Arithmetic operators,"There following arithmetic operators are supported by the TypeScript programming 
 language. In order to understand the examples, you must assume that variable A holds 
 10 and variable B holds 20. 
  
 Operator
  
 Description
  
 Example
  
 +
  
 This adds two operands
  
 A + B will give 30
  
 -
  
 This subtracts the second operand from the first
  
 A - B will give -10
  
 *
  
 This multiplies both the operands
  
 A * B will give 200
  
 /
  
 This divides the numerator by the denominator
  
 B / A will give 2
  
 %
  
 This is the modulus operator and remainder after 
 an integer division
  
 B % A will give 0
  
 ++
  
 This is the increment operator that increases the 
 integer value by 1
  
 A++ will give 11
  
 --
  
 This is the decrement operator that decreases the 
 integer value by 1
  
 A-- will give 9",NA
Comparison operators,"The following comparison operators are supported by the TypeScript language. In 
 order to understand the examples, you must assume that variable A holds 10 and 
 variable B holds 20.
  
 Operator
  
 Description
  
 Example
  
 ==
  
 This checks whether the values of two operands are equal or 
 not. If yes, then the condition becomes true.
  
 (A == B) is 
  
 false. A == ""10"" 
 is true.
  
 ===
  
 This checks whether the value and type of two operands 
 are equal or not. If yes, then the condition becomes true.
  
 A === B is 
  
 false. A === 
 ""10"" is false.
  
 !=
  
 This checks whether the values of two operands are equal or 
 not. If the values are not equal, then the condition becomes 
 true.
  
 (A != B) is true.
  
 [
  13 
 ]",NA
Logical operators,"The following logical operators are supported by the TypeScript language. In order to 
 understand the examples, you must assume that variable A holds 10 and variable B 
 holds 20.
  
 Operator
  
 Description
  
 Example
  
 &&
  
 This is called the logical AND operator. If both the 
 operands are nonzero, then the condition becomes true.
  
 (A && B) is true.
  
 ||
  
 This is called logical OR operator. If any of the two 
 operands are nonzero, then the condition becomes true.
  
 (A || B) is true.
  
 !
  
 This is called the logical NOT operator. It is used to 
 reverse the logical state of its operand. If a condition is 
 true, then the logical NOT operator will make it false.
  
 !(A && B) is false.",NA
Bitwise operators,"The following bitwise operators are supported by the TypeScript language. In order to 
 understand the examples, you must assume that variable A holds 2 and variable B holds 
 3.
  
 Operator
  
 Description
  
 Example
  
 &
  
 This is called the Bitwise AND operator. It performs a 
 Boolean AND operation on each bit of its integer 
 arguments.
  
 (A & B) is 2
  
 |
  
 This is called the Bitwise OR operator. It performs a 
 Boolean OR operation on each bit of its integer 
 arguments.
  
 (A | B) is 3.
  
 [
  14 
 ]",NA
Assignment operators ,"The following assignment operators are supported by the TypeScript language.
  
 Operator
  
 Description
  
 Example
  
 =
  
 This is a simple assignment operator that assigns values 
 from the right-side operands to the left-side operand.
  
 C = A + B will 
  
 assign the value 
 of A + B into C
  
 +=
  
 This adds the AND assignment operator. It adds the right 
 operand to the left operand and assigns the result to the 
 left operand.
  
 C += A is 
  
 equivalent to C = 
 C + A
  
 [
  15 
 ]",NA
Flow control statements,"This section describes the decision-making statements, the looping statements, and 
 the branching statements supported by the TypeScript programming language.",NA
The single-selection structure (if),"The following code snippet declares a variable of type Boolean and name 
 isValid
 . 
 Then, an 
 if
  statement will check whether the value of 
 isValid
  is equal to 
 true
 . If the 
 statement turns out to be true, the 
 Is valid!
  message will be displayed on the screen.
  
 var isValid : boolean = true;
  
 if(isValid) {
  
  alert(""is valid!"");
  
 }",NA
The double-selection structure (if…else),"The following code snippet declares a variable of type Boolean and name 
 isValid
 . 
 Then, an 
 if
  statement will check whether the value of 
 isValid
  is equal to 
 true
 . If the 
 statement turns out to be true, the message 
 Is valid!
  will be displayed on the screen. 
 On the other side, if the statement turns out to be false, the message 
 Is NOT valid!
  
 will be displayed on the screen.
  
 var isValid : boolean = true;
  
 if(isValid) {
  
  alert(""Is valid!"");
  
 [
  16 
 ]",NA
The inline ternary operator (?) ,"The inline ternary operator is just an alternative way of declaring a double-selection 
 structure.
  
 var isValid : boolean = true; 
  
 var message = isValid ? ""Is valid!"" : ""Is NOT 
 valid!""; alert(message);
  
 The preceding code snippet declares a variable of type Boolean and name 
 isValid
 . Then 
 it checks whether the variable or expression on the left-hand side of the operator 
 ?
  is 
 equal to true.
  
 If the statement turns out to be true, the expression on the left-hand side of the 
 character will be executed and the message 
 Is valid!
  will be assigned to the 
 message variable.
  
 On the other hand, if the statement turns out to be false, the expression on the right-
 hand side of the operator will be executed and the message, 
 Is NOT valid! 
 will be 
 assigned to the message variable.
  
 Finally, the value of the message variable is displayed on the screen.",NA
The multiple-selection structure (switch) ,"The 
 switch
  statement evaluates an expression, matches the expression's value to a 
 case clause, and executes statements associated with that case. A 
 switch
  statement 
 and enumerations are often used together to improve the readability of the code.
  
 In the following example, we will declare a function that takes an enumeration 
 AlertLevel
 . Inside the function, we will generate an array of strings to store e-mail 
 addresses and execute a 
 switch
  structure. Each of the options of the enumeration is a 
 case in the 
 switch
  structure:
  
 enum AlertLevel{
  
  
  info,
  
  
  warning,
  
  
  error 
  
 }
  
 [
  17 
 ]",NA
The expression is tested at the top of the loop ,NA,NA
(while),"The 
 while
  expression is used to repeat an operation while a certain requirement is 
 satisfied. For example, the following code snippet, declares a numeric variable 
 i
 . If the 
 requirement (the value of 
 i
  is less than 
 5
 ) is satisfied, an operation takes place (increase 
 the value of 
 i
  by 1 and display its value in the browser console). Once the operation has 
 completed, the accomplishment of the requirement will be checked again.
  
 var i : number = 0;
  
 while (i < 5) {
  
  i += 1;
  
  console.log(i);
  
 }
  
 In a 
 while
  expression, the operation will take place only if the requirement is satisfied.",NA
The expression is tested at the bottom of the loop ,NA,NA
(do…while),"The 
 do-while
  expression is used to repeat an operation until a certain requirement is 
 not satisfied. For example, the following code snippet declares a numeric variable 
 i
  and 
 repeats an operation (increase the value of 
 i
  by 
 1
  and display its value in the browser 
 console) for as long as the requirement (the value of 
 i
  is less than 
 5
 ) is satisfied.
  
 var i : number = 0;
  
 do {
  
  i += 1;
  
  console.log(i);
  
 } while (i < 5);
  
 Unlike the 
 while
  loop, the 
 do-while
  expression will execute at least once regardless of 
 the requirement value as the operation will take place before checking if a certain 
 requirement is satisfied or not.
  
 [
  19 
 ]",NA
Iterate on each object's properties (for…in),"The 
 for-in
  statement by itself is not a 
 bad practice
 ; however, it can be misused, for 
 example, to iterate over arrays or array-like objects. The purpose of the 
 for-in 
 statement is to enumerate over object properties.
  
 var obj : any = { a:1, b:2, c:3 }; 
  
 for (var key in obj) {
  
  console.log(key + "" = "" + obj[key]);
  
 }
  
 // Output:
  
 // ""a = 1""
  
 // ""b = 2""
  
 // ""c = 3""
  
 The following code snippet will go up in the prototype chain, also enumerating the 
 inherited properties. The 
 for-in
  statement iterates the entire prototype chain, also 
 enumerating the inherited properties. When you want to enumerate only the object's 
 own properties (the ones that aren't inherited), you can use the 
 hasOwnProperty 
 method:
  
 for (var key in obj) {
  
  if (obj.hasOwnProperty(prop)) { 
  
  // prop is not inherited 
  
  }
  
 }",NA
Counter controlled repetition (for),"The 
 for
  statement creates a loop that consists of three optional expressions, enclosed in 
 parentheses and separated by semicolons, followed by a statement or a set of 
 statements executed in the loop.
  
 for (var i: number = 0; i < 9; i++) {
  
  console.log(i);
  
 }
  
 The preceding code snippet contains a 
 for
  statement, it starts by declaring the variable 
 i
  and initializing it to 
 0
 . It checks whether 
 i
  is less than 
 9
 , performs the two succeeding 
 statements, and increments 
 i
  by 1 after each pass through the loop.
  
 [
  20 
 ]",NA
Functions ,"Just as in JavaScript, TypeScript functions can be created either as a named function or 
 as an anonymous function. This allows us to choose the most appropriate approach for 
 an application, whether we are building a list of functions in an API or a one-off function 
 to hand over to another function.
  
 // named function 
  
 function greet(name? : string) : string {
  
  
  if(name){
  
  
  return ""Hi! "" + name;
  
  
  }
  
  
  else
  
  
  {
  
  
  return ""Hi!"";
  
  
  } 
  
 }
  
 // anonymous function 
  
 var greet = function(name? : string) : string {
  
  if(name){
  
  
  return ""Hi! "" + name;
  
  
  }
  
  
  else
  
  
  {
  
  
  return ""Hi!"";
  
  
  } 
  
 }
  
 As we can see in the preceding code snippet, in TypeScript we can add types to each of 
 the parameters and then to the function itself to add a return type. TypeScript can infer 
 the return type by looking at the return statements, so we can also optionally leave this 
 off in many cases. 
  
 There is an alternative function syntax, which uses the arrow (
 =>
 ) operator after the 
 function’s return type and skips the usage of the 
 function
  keyword.
  
 var greet = (name : string) : string =>  {
  
  if(name){
  
  
  
  return ""Hi! "" + name;
  
  }
  
  else
  
  {
  
  
  
  return ""Hi! my name is "" + this.fullname; 
 } 
  
 };
  
 [
  21 
 ]",NA
Classes,"ECMAScript 6, the next version of JavaScript, adds class-based object orientation to 
 JavaScript and, since TypeScript is based on ES6, developers are allowed to use class-
 based object orientation today, and compile them down to JavaScript that works 
 across all major browsers and platforms, without having to wait for the next version of 
 JavaScript.
  
 [
  22 
 ]",NA
Interfaces ,"In TypeScript, we can use interfaces to enforce that a class follow the specification in a 
 particular contract.
  
 interface 
 LoggerInterface{
  
  
  log(arg : any) : void; 
  
 }
  
 class Logger implements LoggerInterface{
  
  
  log(arg){
  
  
  if(typeof console.log === ""function""){
  
    
  console.log(arg);
  
  
  }
  
  
  else
  
  
  {
  
    
  alert(arg);
  
  
  }
  
  
  } 
  
 }
  
 In the preceding example, we have defined an interface 
 loggerInterface
  and a class 
 Logger
 , which implements it. TypeScript will also allow you to use interfaces to 
 declare the type of an object. This can help us to prevent many potential issues, 
 especially when working with object literals:
  
 interface UserInterface{
  
  
  name : string;
  
  
  password : string; 
  
 }
  
 var user : UserInterface = {
  
  
  name : """",
  
  
  password : """" // error property password is missing 
 };
  
  
 We will learn more about interfaces and other object-oriented 
  
  
 programming concepts in 
 Chapter 4
 , 
 Object-Oriented Programming 
  
 with TypeScript
 .
  
 [
  24 
 ]",NA
Namespaces ,"Namespaces, also known as internal modules, are used to encapsulate features and 
 objects that share a certain relationship. Namespaces will help you to organize your 
 code in a much clearer way. To declare a namespace in TypeScript, you will use the 
 namespace
  and 
 export
  keywords.
  
 namespace Geometry{
  
  
  interface VectorInterface {
  
    
  /* ... */
  
  
  }
  
  
  export interface Vector2dInterface {
  
    
  /* ... */
  
  
  }
  
  
  export interface Vector3dInterface {
  
    
  /* ... */
  
  
  }
  
  
  export class Vector2d implements VectorInterface,  
  
  Vector2dInterface {
  
  
  /* ... */
  
  
  }
  
  
  export class Vector3d implements VectorInterface,  
  
  Vector3dInterface {
  
  
  /* ... */
  
  
  } 
  
 }
  
 var vector2dInstance : Geometry.Vector2dInterface = new 
 Geometry.Vector2d(); 
  
 var vector3dInstance : Geometry.Vector3dInterface = new 
 Geometry.Vector3d();
  
 In the preceding code snippet, we have declared a namespace that contains 
  
 the classes 
 vector2d
  and 
 vector3d
  and the interfaces 
 VectorInterface
 , 
  
 Vector2dInterface
 , and 
 Vector3dInterface
 . Note that the first interface is missing 
 the keyword 
 export
 . As a result, the interface 
 VectorInterface
  will not be accessible 
 from outside the namespace's scope.
  
  
 In 
 Chapter 4
 , 
 Object-Oriented Programming with TypeScript
 , we'll be 
  
  
 covering namespaces (internal modules) and external modules and 
  
 we'll discuss when each is appropriate and how to use them.
  
 [
  25 
 ]",NA
Putting everything together ,"Now that we have learned how to use the basic TypeScript building blocks 
 individually, let's take a look at a final example in which we will use modules, 
 classes, functions, and type annotations for each of these elements:
  
 module Geometry{
  
  
  export interface Vector2dInterface {
  
  
  toArray(callback : (x : number[]) => void) : void;
  
  
  length() : number;
  
  
  normalize();
  
  
  }
  
  
  export class Vector2d implements Vector2dInterface {
  
  
  private _x: number;
  
  
  private _y : number;
  
  
  constructor(x : number, y : number){
  
    
  this._x = x;
  
    
  this._y = y;
  
  
  }
  
  
  toArray(callback : (x : number[]) => void) : void{
  
    
  callback([this._x, this._y]);
  
  
  }
  
  
  length() : number{
  
    
  return Math.sqrt(this._x * this._x + this._y * 
 this._y);
  
  }
  
  
  normalize(){
  
    
  var len = 1 / this.length();
  
    
  this._x *= len;
  
    
  this._y *= len;
  
  
  }
  
  
  } 
  
 }
  
 The preceding example is just a small portion of a basic 3D engine written in JavaScript. 
 In 3D engines, there are a lot of mathematical calculations involving matrices and 
 vectors. As you can see, we have defined a module 
 Geometry
  that will contain some 
 entities; to keep the example simple, we have only added the class 
 Vector2d
 . This class 
 stores two coordinates (
 x
  and 
 y
 ) in 2d space and performs some operations on the 
 coordinates. One of the most used operations on vectors is normalization, which is one 
 of the methods in our 
 Vector2d
  class.
  
 [
  26 
 ]",NA
Summary,"In this chapter, you have learned about the purposes of TypeScript. You have also 
 learned about some of the design decisions made by the TypeScript engineers at 
 Microsoft.
  
 Towards the end of this chapter, you learned a lot about the basic building blocks of a 
 TypeScript application .You started to write some TypeScript code for the first time and 
 you can now work with type annotations, variables and primitive data types, operators, 
 flow control statements, functions, and classes.
  
 In the next chapter, you will learn how to automate your development workflow.
  
 [
  27 
 ]",NA
Automating Your ,NA,NA
Development Workflow,"After taking a first look at the main TypeScript language features, we will now learn 
 how to use some tools to automate our development workflow. These tools will help 
 us to reduce the amount of time that we usually spend on simple and repetitive tasks.
  
 In this chapter, we will learn about the following topics:
  
 • 
  
 An overview of the development workflow
  
 • 
  
 Source control tools
  
 • 
  
 Package management tools
  
 • 
  
 Task runners
  
 • 
  
 Test runners
  
 • 
  
 Integration tools
  
 • 
  
 Scaffolding tools",NA
A modern development workflow,"Developing a web application with high quality standards has become a 
  
 time-consuming activity. If we want to achieve a great user experience, we will need to 
 ensure that our applications can run as smoothly as possible on many different web 
 browsers, devices, Internet connection speeds, and screen resolutions. Furthermore, we 
 will need to spend a lot of our time working on quality assurance and performance 
 optimization tasks.
  
 [
  29 
 ]",NA
Prerequisites,"You are about to learn how to write a script, which will automate many tasks in your 
 development workflow; however, before that, we need to install a few tools in our 
 development environment.",NA
Node.js,"Node.js is a platform built on V8 (Google's open source JavaScript engine). Node.js 
 allows us to run JavaScript outside a web browser. We can write backend and desktop 
 applications using JavaScript with Node.js.
  
 We are not going to write server-side JavaScript applications but we are going to need 
 Node.js because many of the tools used in this chapter are Node.js applications.
  
 If you didn't install Node.js in the previous chapter, you can visit 
 https://nodejs. 
 org
  to download the installer for your operating system.",NA
Atom,"Atom is an open source editor developed by the GitHub team. The open source 
 community around this editor is really active and has developed many plugins and 
 themes. You can download Atom from 
 https://atom.io/
 .
  
 [
  30 
 ]",NA
Git and GitHub,"Towards the end of this chapter, we will learn how to configure a continuous 
 integration build server. The build server will observe changes in our application's 
 code and ensure that the changes don't break the application.
  
 In order to be able to observe the changes in the code, we will need to use a source 
 control system. There are a few source control systems available. Some of the most 
 widely used ones are Subversion, Mercurial and Git.
  
 Source control systems have many benefits. First, they enable multiple developers to 
 work on a source file without any work being overridden.
  
 Second, source control systems are also a good way of keeping previous copies of a file 
 or auditing its changes. These features can be really useful, for example, when trying to 
 find out when a new bug was introduced for the first time.
  
 While working through the examples, we will perform some changes to the source code. 
 We will use Git and GitHub to manage these changes. To install Git, go to 
 http://git-
 scm.com/downloads
  and download the executable for your operating system. Then, go 
 to 
 https://github.com/
  to create a GitHub account. While creating the GitHub 
 account, you will be offered a few different subscription plans, the free plan offers 
 everything we need to follow the examples in this chapter.",NA
Source control tools,"Now that we have installed Git and created a GitHub account, we will use GitHub to create 
 a new code repository. A repository is a central file storage location. It is used by the 
 source control systems to store multiple versions of files. While a repository can be 
 configured on a local machine for a single user, it is often stored on a server, which can be 
 accessed by multiple users.
  
 [
  33 
 ]",NA
Package management tools,"Package management tools are used for dependency management, so that we no longer 
 have to manually download and manage our application's dependencies. We will learn 
 how to work with three different package management tools: Bower, npm, and tsd.",NA
npm,"The npm package manager was originally developed as the default Node.js package 
 management tool, but today it is used by many tools. Npm uses a configuration file, 
 called 
 package.json
 , to store references to all the dependencies in our application. It is 
 important to remember that we will normally use npm to install dependencies that we 
 will use on the server side, in a desktop application, or with development tools.
  
 Before we install any packages, we should add a 
 package.json
  file to our project. We 
 can do it by executing the following command:
  
 npm init
  
 The 
 npm init
  command will ask for some basic information about our project, 
 including its name, version, description, entry point, test command, Git repository, 
 keywords, author and license.
  
  
 Refer to the official npm documentation at 
 https://docs.npmjs.
  
  
 com/files/package.json
  if you are unsure about the purposes 
  
 of some of the 
 package.json
  fields mentioned earlier.
  
 The 
 npm
  command will then show us a preview of the 
 package.json
  file that is 
 about to be generated and ask for our final confirmation.
  
  
 Remember that you need to have Node.js installed to be able to 
  
  
 use the 
 npm
  command tool.
  
 [
  38 
 ]",NA
Bower,"Bower is another package management tool. It is really similar to npm but it was 
 designed specifically to manage frontend dependencies. As a result, many of the 
 packages are optimized for its usage in a web browser.
  
 We can install Bower by using npm:
  
 npm install -g bower
  
 Instead of the 
 package.json
  file, Bower uses a configuration file named 
 bower. 
 json
 . We can use the majority of the npm commands and arguments in Bower. For 
 example, we can use the 
 bower init
  command to create the initial bower 
 configuration file:
  
 bower init
  
  
 The initial configuration file is quite similar to the 
 package.json
  
  
 file. Refer to the official documentation at 
 http://bower.io/
  
 docs/config/
  if you want to learn more about the 
 bower.json
  
 configuration fields.
  
 We can also use the 
 bower install
  command to install a package:
  
 bower install jquery
  
 [
  41 
 ]",NA
tsd,"In the previous chapter, we learned that TypeScript by default includes a file 
 lib.d.ts
  
 that provides interface declarations for the built-in JavaScript objects as well as the 
 Document Object Model
  (
 DOM
 ) and 
 Browser Object Model
  (
 BOM
 ) APIs. The 
 TypeScript files with the extension 
 .d.ts
  are a special kind of TypeScript file known as 
 type definition files
  or 
 declaration files
 .
  
 The type definition files usually contain the type declarations of third-party libraries. 
  
 These files facilitate the integration between the existing JavaScript libraries and 
 TypeScript. If, for example, we try to invoke the JQuery in a TypeScript file, we will get 
 an error:
  
 $.ajax({ / **/ }); // cannot find name '$'
  
 To resolve this issue, we need to add a reference to the JQuery type definition file in our 
 TypeScript code, as shown in the following line of code:
  
 ///<reference path=""jquery.d.ts"">
  
 Fortunately, we don't need to create the type definition files because there is an open 
 source project known as 
 DefinitelyTyped
  that already contains type definition files for 
 many JavaScript libraries. In the early days of TypeScript development, developers had 
 to manually download and install the type definition files from the DefinitelyTyped 
 project website, but those days are gone, and today we can use a much better solution 
 known as 
 tsd
 .
  
 The 
 tsd
  acronym stands for 
 TypeScript Definitions
  and it is a package manager that 
 will help us to manage the type definition files required by our TypeScript application. 
 Just like npm and bower, 
 tsd
  uses a configuration file named 
 tsd.json 
 and stores all 
 the downloaded packages under a directory named 
 typings
 .
  
 Run the following command to install tsd:
  
 npm install tsd -g
  
 [
  42 
 ]",NA
Task runners,"A task runner is a tool used to automate tasks in the development process. The task 
 can be used to perform a wide variety of operations such as the compilation of 
 TypeScript files or the compression of JavaScript files. The two most popular 
 JavaScript task runners these days are Grunt and Gulp.
  
 Grunt started to become popular in early 2012 and since then the open source 
 community has developed a large number of Grunt-compatible plugins.
  
 On the other hand, Gulp started to become popular in late 2013; therefore, there 
 are less plugins available for Gulp, but it is quickly catching up with Grunt.
  
 Besides the number of plugins available, the main difference between Gulp and Grunt is 
 that while in Grunt we will work using files as the input and output of our tasks, in Gulp 
 we will work with streams and pipes instead. Grunt is configured using some 
 configuration fields and values. However, Gulp prefers code over configuration. This 
 approach makes the Gulp configuration somehow more minimalistic and easier to read.
  
  
 In this book, we will work with Gulp; however, if you want to learn 
  
  
 more about Grunt, you can do so at 
 http://gruntjs.com/
 .
  
 In order to gain a good understanding of Gulp, we can use the project that we have 
 already created and add some extra folders and files to it. Alternatively, we can start a 
 new project from scratch. We will configure some tasks, which will reference paths, 
 folders, and files numerous times, so the following directory tree structure should help us 
 understand each of these tasks:
  
 ├── LICENSE
  
 ├── README.md
  
 ├── index.html
  
 ├── gulpfile.js
  
 ├── karma.conf.js
  
 [
  43 
 ]",NA
Checking the quality of the TypeScript code,"The 
 default
  task is not performing any operations in the preceding example, but we will 
 normally use a Gulp plugin in each task. We will now add a second task, which will use the 
 gulp-tslint
  plugin to check whether our TypeScript code follows a series of 
 recommended practices.
  
 We need to install the plugin with npm:
  
 npm install gulp-tslint --save-dev
  
 We can then load the plugin in to our 
 gulpfile.js
  file and add a new task:
  
 var tslint = require('gulp-tslint');
  
 gulp.task('lint', function() {
  
  return gulp.src([
  
  './source/ts/**/**.ts', './test/**/**.test.ts'
  
  ]).pipe(tslint())
  
  .pipe(tslint.report('verbose'));
  
 });
  
 We have named the new task 
 lint
 . Let's take a look at the operations performed by the 
 lint
  task, step by step:
  
 1. The 
 gulp src
  function will fetch the files in the directory located at 
 ./source/ts
  and its subdirectories with the file extension 
 .ts
 . We 
 will also fetch all the files in the directory located at 
 ./test
  and its 
 subdirectories with the file extension 
 .test.ts
 .
  
 2. The output stream of the 
 src
  function will be then redirected using the 
 pipe 
  
 function to be used as the 
 tslint
  function input.
  
 3. Finally, we will use the output of the 
 tslint
  function as the input of the 
  
 tslint.report
  function.
  
 Now that we have added the 
 lint
  task, we will modify the 
 gulpfile.js
  file to 
 indicate that we want to run 
 lint
  as a subtask of the default task:
  
 gulp.task('default', ['lint']);
  
 [
  45 
 ]",NA
Compiling the TypeScript code ,"We will now add two new tasks to compile our TypeScript code (one for the 
 application's logic and one for the application's unit tests).
  
 We will use the 
 gulp-typescript
  plugin, so remember to install it as a 
 development dependency using the npm package manager, just as we did 
 previously in this chapter:
  
 npm install -g gulp-typescript
  
 We can then create a new 
 gulp-typescript
  project object:
  
 var ts = require('gulp-typescript'); 
  
 var tsProject = ts.createProject({
  
  removeComments : true,
  
  noImplicitAny : true,
  
  target : 'ES3',
  
  module : 'commonjs',
  
  declarationFiles : false 
  
 });
  
  
 It has been announced that the gulp-typescript plugin will soon support 
  
  
 the usage of a special JSON file named 
 tsconfig.json
 . This file is 
  
 used to store the TypeScript compiler configuration. When the file is 
  
 available, it is used by the compiler during the compilation process.
  
 The 
 tsconfig.json
  file is useful because it prevents us from having 
  
 to write all the desired compiler parameters when using its console 
  
 interface. Refer to the gulp-typescript documentation, which can be 
  
 found at 
 https://www.npmjs.com/package/gulp-typescript
 , 
  
 to learn more about this feature.
  
 [
  46 
 ]",NA
Optimizing a TypeScript application,"When we compile our Typescript code, the compiler will generate a JavaScript file for 
 each compiled TypeScript file. If we run the application in a web browser, these files 
 won't really be useful on their own because the only way to use them would be to create 
 an individual HTML script tag for each one of them.
  
 Alternatively, we could follow two different approaches:
  
 • 
  
 • 
  
 We could use a tool, such as the RequireJS library, to load each of those files on 
 demand using AJAX. This approach is known as asynchronous module loading. 
 To follow this approach, we will need to change the configuration of the 
 TypeScript compiler to use the 
 asynchronous module definition 
 (
 AMD
 ) 
 notation.
  
 We could configure the TypeScript compiler to use the CommonJS module 
 notation and use a tool, such as Browserify, to trace the application's modules 
 and dependencies and generate a highly optimized single file, which will contain 
 all the application's modules.
  
 In this book, we will use the CommonJS method because it is highly integrated with 
 Browserify and Gulp.
  
  
 If you have never worked with AMD or CommonJS modules before, 
  
  
 don't worry too much about it for now. We will focus on modules in 
  
 Chapter 4
 , 
 Object-Oriented Programming with TypeScript
 .
  
 We can find the application's root module (named 
 main.ts
  in our example) in the 
 companion code. This file contains the following code:
  
 ///<reference path=""./references.d.ts"" />
  
 import { headerView }  from './header_view';
  
 import { footerView } from './footer_view';
  
 import { loadingView } from './loading_view';
  
 headerView.render();
  
 footerView.render();
  
 loadingView.render();
  
  
 The preceding 
 import
  statements are used to access the contents of 
  
  
 some external modules. We will learn more about external modules 
  
 in 
 Chapter 4
 , 
 Object-Oriented Programming with TypeScript
 .
  
 [
  48 
 ]",NA
Managing the Gulp tasks' execution order,"Sometimes we will need to run our tasks in a certain order (for example, we need to 
 compile our TypeScript into JavaScript before we can execute our unit tests). 
 Controlling the tasks' execution order can be challenging since in Gulp all the tasks 
 are asynchronous by default.
  
 There are three ways to make a task synchronous:
  
 • 
  
 Passing in a callback
  
 • 
  
 Returning a stream
  
 • 
  
 Returning a promise
  
 Refer to 
 Chapter 3
 , 
 Working with Functions
  to learn more about the usage callbacks and 
 promises.
  
  
 Let's take a look at the first two ways (we will not cover the usage of promises in this 
 chapter):
  
 // Passing a callback (cb)
  
 gulp.task('sync', function (cb) { // note the cb argument
  
  // setTimeout could be any async task
  
  setTimeout(function () {
  
  cb(); // note the cb usage here
  
  }, 1000);
  
 });
  
 // Returning a stream
  
 gulp.task('sync', function () {
  
 [
  51 
 ]",NA
Test runners,"A test runner is a tool that allows us to automate the execution of our application's unit 
 tests.
  
  
 Unit testing refers to the practice of testing certain functions and 
  
  
 areas (units) of our code. This gives us the ability to verify that our 
  
 functions work as expected. It is assumed that the reader has some 
  
 understanding of the unit test process, but the topics explored 
  
 here will be covered in a much higher level of detail in 
 Chapter 7
 , 
  
 Application Testing
 .
  
 We can use a test runner to automatically execute our application's test suites in 
 multiple browsers instead of having to manually open each web browser in order to 
 execute the tests.
  
 We will use a test runner known as Karma. Karma is compatible with multiple unit 
 testing frameworks, but we will use the Mocha testing framework together with two 
 libraries: Chai (an assertion library) and Sinon (a mocking framework).
  
  
 You don't need to worry too much about these libraries right now 
  
  
 because we will focus on their  usage in 
 Chapter 7
 , 
 Application Testing
 .
  
 Let's start by using npm to install the testing framework that we are going to use:
  
 npm install mocha chai sinon --save-dev
  
 We will continue by installing the 
 karma
  test runner and some dependencies:
  
 npm install karma karma-mocha karma-chai karma-sinon karma-coverage 
 karma-phantomjs-launcher gulp-karma --save-dev
  
 [
  53 
 ]",NA
Synchronized cross-device testing,"We will add one last task to the 
 gulpfile.js
  file, which will allow us to run our 
 application in a web browser. We need to install the 
 browser-sync
  package by 
 using npm:
  
 npm install -g browser-sync
  
 We will then create two new tasks. These tasks are just used to group a few tasks into one 
 main task. We are doing this because sometimes we want to refresh a webpage to see the 
 effect of changing some TypeScript code and we need to run a number of tasks 
 (compilation, bundling, and so on) before we can actually see the changes in a web 
 browser. By grouping all these tasks into higher-level tasks, we can save some time and 
 make our configuration files more readable:
  
 gulp.task('bundle', function(cb) {
  
  runSequence('build', [
  
 [
  55 
 ]",NA
Continuous Integration tools,"Continuous Integration
  (
 CI
 ) is a development practice that helps to prevent 
  
 potential integration issues. Software integration issues refers to the difficulties that may 
 arise during the practice of combining individually tested software components into an 
 integrated whole. Software is integrated when components are combined into subsystems 
 or when subsystems are combined into products.
  
 Components may be integrated after all of them are implemented and tested, as in a 
 waterfall model or a big bang approach. On the other hand, CI requires developers to 
 commit their code daily into a remote code repository. Each commit is then verified by an 
 automated build, allowing teams to detect integration issues earlier.
  
 In this chapter, we have created a remote code repository and an automated build, but we 
 haven't configured a tool to observe our commits and run the automate build accordingly. 
 We need a CI server. There are many options when it comes to choosing a CI server, but 
 exploring these options is out of the scope of this book. We will work with Travis CI 
 because it is highly integrated with GitHub and is free for open source projects and 
 learning purposes.
  
 To configure Travis CI, we need to visit the website 
 https://travis-ci.org
  and log 
 in using our GitHub credentials. Once we have logged in, we will be able to see a list of 
 our public GitHub repositories and will also be able to enable the CI.
  
  
 To finish the configuration, we need to add a file named 
 travis.yml
  to our 
 application's root directory, which contains the Travis CI configuration:
  
 language: node_js
  
 node_js:
  
  - ""0.10""""
  
  
 There are many other available TravisCI configuration options. 
  
  
 Refer to 
 http://docs.travis-ci.com/
  to learn more about 
  
 the available options.
  
 After completing these two small configuration steps, Travis CI will be ready to 
 observe the commits to our remote code repository.
  
 [
  58 
 ]",NA
Scaffolding tools,"A scaffolding tool is used to autogenerate the project structure, build scripts, and much 
 more. The most popular scaffolding tool these days is Yeoman. Yeoman uses an 
 internal command known as 
 yo
 , a package manager, and a task runner of our choice to 
 generate projects based on templates.
  
 The project templates are known as generators and the open source community has 
 already published many of them, so we should be able to find one that more or less suits 
 our needs. Alternatively, we can write and publish our own Yeoman generator.
  
 We will now create a new project to showcase how Yeoman can help us to save 
 some time. Yeoman will generate the 
 package.json
  and 
 bower.json
  files and 
 automatically install some dependencies for us.
  
 The 
 yo
  command can be installed using npm:
  
 npm install -g yo
  
 After installing the 
 yo
  command, we will need to install at least one generator. We 
 need to find a generator for the kind of project that we wish to create. 
  
 We are going create a new project using Gulp as the task runner and 
  
 TypeScript to showcase the usage of Yeoman. We can use a generator called 
 generator-typescript
 . The list of available generators can be found online at 
 http://yeoman.io/generators/
 .
  
 We can install a generator by using npm:
  
 npm install -g generator-typescript
  
 After installing the generator, we can use it with the help of the 
 yo
  command:
  
 yo typescript
  
 [
  59 
 ]",NA
Summary ,"In this chapter, you learned how to work with a source control repository and how to 
 use Gulp to manage the tasks in an automated build. The automated build helps us to 
 validate the quality of the TypeScript code, compile it, test it, and optimize it. You also 
 learned how to install third-party packages and TypeScript type definitions for those 
 third-party components.
  
 Towards the end of the chapter, you learned how to use the automated build and a 
 continuous integration server to reduce the impact of potential integration issues.
  
 In the next chapter, you will learn about functions.
  
 [
  61 
 ]",NA
Working with Functions,"In 
 Chapter 1
 , 
 Introducing TypeScript
 , we took a first look at the usage of functions. 
  
 Functions are the fundamental building block of any application in TypeScript, 
  
 and they are powerful enough to deserve the dedication of an entire chapter to 
  
 explore their potential. 
  
 In this chapter, we will learn to work with functions in depth. The chapter is divided 
  
 into two main sections. In the first section, we will start with a quick recap of some 
  
 basic concepts and then move onto some less commonly known function features 
  
 and use cases. The first section includes the following concepts:
  
 • 
  
 Function declaration and function expressions
  
 • 
  
 Function types
  
 • 
  
 Functions with optional parameters
  
 • 
  
 Functions with default parameters
  
 • 
  
 Functions with rest parameters
  
 • 
  
 Function overloading
  
 • 
  
 Specialized overloading signature
  
 • 
  
 Function scope
  
 • 
  
 Immediately invoked functions
  
 • 
  
 Generics
  
 • 
  
 Tag functions and tagged templates
  
 [
  63 
 ]",NA
Working with functions in TypeScript ,"In this 
 section, we will focus on the declaration and usage of functions, parameters, and 
 arguments. We will also introduce one of the most powerful features of TypeScript: 
 Generics.",NA
Function declarations and function ,NA,NA
expressions ,"In the first chapter, we introduced the possibility of declaring functions with (named 
 function) or without (unnamed or anonymous function) explicitly indicating its name, but 
 we didn't mention that we were also using two different types of function.
  
 In the following example, the named function 
 greetNamed
  is a function declaration 
 while 
 greetUnnamed
  is a function expression. Ignore the first two lines, which contain 
 two console log statements, for now:
  
 console.log(greetNamed(""John"")); 
  
 console.log(greetUnnamed(""John""))
 ;
  
 function greetNamed(name : string) : string {
  
  if(name) {
  
  
  return ""Hi! "" + name;
  
  
  } 
  
 }
  
 var greetUnnamed = function(name : string) : string {
  
  if(name){
  
  
  return ""Hi! "" + name;
  
  
  } 
  
 }
  
 [
  64 
 ]",NA
Function types,"We already know that it is possible to explicitly declare the type of an element in our 
 application by using the optional type declaration annotation:
  
 function greetNamed(name : string) : string {
  
  if(name) {
  
  return ""Hi! "" + name;
  
  }
  
 }
  
 In the preceding function, we have specified the type of the parameter name (string) and 
 its return type (string). Sometimes, we will need to not just specify the types of the 
 function elements, but also the function itself. Let's take a look at an example:
  
 var greetUnnamed : (name : string) => string;
  
 greetUnnamed = function (name : string) : string {
  
  if(name){
  
  return ""Hi! "" + name;
  
  }
  
 }
  
 [
  65 
 ]",NA
Functions with optional parameters,"Unlike JavaScript, the TypeScript compiler will throw an error if we attempt to invoke 
 a function without providing the exact number and type of parameters that its 
 signature declares. Let's take a look at a code sample to demonstrate it:
  
 function add(foo : number, bar : number, foobar : number) : number {
  
  return foo + bar + foobar;
  
 }
  
 [
  66 
 ]",NA
Functions with default parameters,"When a function has some optional parameters, we must check if an argument has 
 been passed to the function (just like we did in the previous example).
  
 There are some scenarios in which it would be more useful to provide a default value for a 
 parameter when it is not supplied than to make it an optional parameter. Let's rewrite the 
 add function (from the previous section) using the inline 
 if
  structure:
  
 function add(foo : number, bar : number, foobar? : number) : 
 number {
  
  return foo + bar + (foobar !== undefined ? foobar : 0);
  
 }
  
 There is nothing wrong with the preceding function, but we can improve its 
 readability by providing a default value for the 
 foobar
  parameter instead of 
 flagging it as an optional parameter:
  
 function add(foo : number, bar : number, foobar : number = 0) : 
 number {
  
  return foo + bar + foobar;
  
 }
  
 To indicate that a function parameter is optional, we just need to provide a default value 
 using the 
 =
  operator when declaring the function's signature. The TypeScript compiler 
 will generate an 
 if
  structure in the JavaScript output to set a default value for the 
 foobar
  parameter if it is not passed as an argument to the function:
  
 function add(foo, bar, foobar) {
  
  if (foobar === void 0) { foobar = 0; }
  
  return foo + bar + foobar;
  
 }
  
 Void 0
  is used by the TypeScript compiler to check if a variable is equal to undefined. 
 While most developers use the undefined variable, most compilers use 
 void 0
 .
  
 Just like optional parameters, default parameters must be always located after any 
 required parameters in the function's parameter list.
  
 [
  68 
 ]",NA
Functions with rest parameters,"We have seen how to use optional and default parameters to increase the 
 number of ways that we can invoke a function. Let's return one more time to 
 the previous example:
  
 function add(foo : number, bar : number, foobar : number = 0) : 
 number {
  
  return foo + bar + foobar;
  
 }
  
 We have seen how to make possible the usage of the 
 add
  function with two or three 
 parameters, but what if we wanted to allow other developers to pass four or five 
 parameters to our function? We would have to add two extra default or optional 
 parameters. And what if we wanted to allow them to pass as many parameters as they 
 may need? The solution to this possible scenario is the use of rest parameters. The rest 
 parameter syntax allows us to represent an indefinite number of arguments as an array:
  
 function add(...foo : number[]) : number {
  
  var result = 0;
  
  for(var i = 0; i < foo.length; i++){
  
  result += foo[i];
  
  }
  
  return result;
  
 }
  
 As we can see in the following code snippet, we have replaced the function parameters 
 foo
 , 
 bar
 , and 
 foobar
  with just one parameter: 
 foo
 . Note that the name of the 
  
 parameter 
 foo
  is preceded by an ellipsis (a set of three periods—not the actual ellipsis 
 character). A rest parameter must be of an array type or we will get a compilation error. 
  
 We can now invoke the add function with as many parameters as we may need:
  
 add();             // returns 0 
  
 add(2);            // returns 2
  
 add(2,2);          // returns 4
  
 add(2,2,2);        // returns 6
  
 add(2,2,2,2);      // returns 8
  
 add(2,2,2,2,2);    // returns 10
  
 add(2,2,2,2,2,2);  // returns 12
  
 Although there is no specific limit to the theoretical maximum number of arguments 
 that a function can take, there are, of course, practical limits. These limits are entirely 
 implementation-dependent and, most likely, will also depend exactly on how we are 
 calling the function.
  
 [
  69 
 ]",NA
Function overloading ,"Function overloading or method overloading is the ability to create multiple 
 methods with the same name and a different number of parameters or types. In 
 TypeScript, we can overload a function by specifying all function signatures of a 
 function, followed by a signature known as the implementation signature. 
  
 Let's take a look at an example:
  
 function test(name: string) : string;    // overloaded signature 
 function test(age: number) : string;     // overloaded signature 
 function test(single: boolean) : string; // overloaded signature 
 function test(value: (string | number | boolean)) : string; {  // 
 implementation signature
  
  
  switch(typeof value){
  
  
  case ""string"":
  
    
  return `My name is ${value}.`;
  
  
  case ""number"":
  
    
  return `I'm ${value} years old.`; 
  
  
  case ""boolean"":
  
    
  return value ? ""I'm single."" : ""I'm not single.""; 
  
  
  default:
  
    
  console.log(""Invalid Operation!"");
  
  
  } 
  
 }
  
 [
  71 
 ]",NA
Specialized overloading signatures,"We can use a specialized signature to create multiple methods with the same name and 
 number of parameters but a different return type. To create a specialized signature, we 
 must indicate the type of function parameter using a string. The string literal is used to 
 identify which of the function overloads is invoked:
  
 interface Document { 
  
  createElement(tagName: ""div""): HTMLDivElement; // specialized
  
  createElement(tagName: ""span""): HTMLSpanElement;  // specialized
  
  createElement(tagName: ""canvas""): HTMLCanvasElement; //   
 specialized
  
  createElement(tagName: string): HTMLElement; // non-specialized
  
 }
  
 In the preceding example, we have declared three specialized overloaded signatures and 
 one non-specialized signature for the function named 
 createElement
 .
  
 [
  72 
 ]",NA
Function scope,"Low-level languages such as C have low-level memory management features. In 
 programming languages with a higher level of abstraction such as TypeScript, values 
 are allocated when variables are created and automatically cleared from memory 
 when they are not used anymore. The process that cleans the memory is known as 
 garbage collection
  and is performed by the JavaScript runtime garbage collector.
  
 The garbage collector generally does a great job, but it is a mistake to assume that it will 
 always prevent us from facing a memory leak. The garbage collector will clear a variable 
 from the memory whenever the variable is out of the scope. Is important to understand 
 how the TypeScript scope works so we understand the lifecycle of the variables.
  
 Some programming languages use the structure of the program source code to 
 determine what variables we are referring to (lexical scoping), while others use the 
 runtime state of the program stack to determine what variable we are referring to 
 (dynamic scoping). The majority of modern programing languages use lexical scoping 
 (including TypeScript). Lexical scoping tends to be dramatically easier to understand 
 for both humans and analysis tools than dynamic scoping.
  
 While in most lexical scoped programming languages, variables are scoped to a block (a 
 section of code delimited by curly braces 
 {}
 ), in TypeScript (and JavaScript), variables 
 are scoped to a function:
  
 function foo() : void {
  
  if(true){
  
  var bar : number = 0;
  
  }
  
 [
  73 
 ]",NA
Immediately invoked functions ,"An 
 immediately invoked function expression
  (
 IIFE
 ) is a design pattern that produces a 
 lexical scope using function scoping. IIFE can be used to avoid variable hoisting from 
 within blocks or to prevent us from polluting the global scope. For example:
  
 var bar = 0; // global
  
 (function() {
  
  
  var foo : number = 0; // in scope of this function
  
  bar = 1; // in global scope
  
  
  console.log(bar); // 1
  
  
  console.log(foo); // 0 
  
 })();
  
 console.log(bar); // 1 
  
 console.log(foo); // error 
  
 In the preceding example, we have wrapped the declaration of two variables (
 foo
  and 
 bar
 ) with an IIFE. The 
 foo
  variable is scoped to the IIFE function and is not available 
 in the global scope, which explains the error when trying to access it in the last line.
  
 We can also pass a variable to the IIFE to have better control over the creation of 
 variables outside its own scope:
  
 var bar = 0; // global
  
 (function(global) {
  
  
  var foo : number = 0; // in scope of this function
  
  bar = 1; // in global scope
  
  
  console.log(global.bar); // 1
  
  
  console.log(foo); // 0 
  
 })(this);
  
 [
  76 
 ]",NA
Generics,"Andy Hunt and Dave Thomas formulated the 
 don't repeat yourself
  (
 DRY
 ) principle in 
 the book 
 The Pragmatic Programmer
 . The DRY principle aims to reduce the repetition 
 of information of all kinds. We will now take a look at an example that will help us to 
 understand what generics functions are and how they can help us follow the DRY 
 principle.
  
 We will start by declaring a really simple 
 User
  class:
  
 class User {
  
  name : string;
  
  age : number;
  
 }
  
 [
  79 
 ]",NA
Tag functions and tagged templates ,"We have already seen how to work with template strings such as the following:
  
 var name = 'remo'; 
  
 var surname = jansen; 
  
 var html = `<h1>${name} ${surname}</h1>`;
  
 However, there is one use of template strings that we deliberately skipped because it is 
 closely related to the use of a special kind of function known as 
 tag function
 .
  
 We can use a tag function to extend or modify the standard behavior of template 
 strings. When we apply a tag function to a template string, the template string 
 becomes a 
 tagged template
 .
  
 We are going to implement a tag function named 
 htmlEscape
 . To use a tag function, we 
 must use the name of the function followed by a template string:
  
 var html = htmlEscape `<h1>${name} ${surname}</h1>`;
  
 A tag template must return a string and take the following arguments:
  
 • 
  
 • 
  
 An array which contains all the static literals in the template string (
 <h1>
  and 
 </h1>
  in the preceding example) is passed as the first argument.
  
 A rest parameter is passed as the second parameter. The rest parameter 
 contains all the values in the template string (
 name
  and 
 surname
  in the 
 preceding example).
  
 We now know the signature of a tag function.
  
 tag(literals : string[], ...values : any[]) : string
  
 [
  82 
 ]",NA
Asynchronous programming in ,NA,NA
TypeScript ,"Now that we have seen how to work with functions, we will explore how we can use them, 
 together with some native objects, to write asynchronous applications.",NA
Callbacks and higher-order functions ,"In TypeScript, functions can be passed as arguments to another function. The function 
 passed to another as an argument is known as a 
 callback
 . Functions can also be 
 returned by another function. The functions that accept functions as parameters 
 (callbacks) or return functions as an argument are known as 
 higher-order functions
 . 
 Callbacks are usually anonymous functions.
  
 var foo = function() { // 
 callback
  
  
  console.log('foo');
  
 [
  83 
 ]",NA
Arrow functions ,"In TypeScript, we can declare a function using a 
 function
  expression or an arrow 
 function. An arrow function expression has a shorter syntax compared to function 
 expressions and lexically binds the value of the 
 this
  operator.
  
 The 
 this
  operator behaves a little differently in TypeScript compared to other 
 languages. When we define a class in TypeScript, we can use the 
 this
  operator to 
 refer to the class's own properties. Let's take a look at an example:
  
 class Person { 
  
 name : string;
  
  
  constructor(name : string) {
  
  
  this.name = name;
  
  
  }
  
  
  greet() {
  
  
  alert(`Hi! My name is ${this.name}`);
  
  
  } 
  
 } 
  
 var remo = new Person(""Remo""); 
  
 remo.greet(); // ""Hi! My name is Remo""
  
 We have defined a 
 Person
  class that contains a property of type string called 
 name
 . The 
 class has a constructor and a method 
 greet
 . We have created an instance named 
 remo
  
 and invoked the method named 
 greet
 , which internally uses the 
 this
  operator to access 
 the 
 remo
  property's name. Inside the 
 greet
  method, the 
 this
  operator points to the 
 object that encloses the 
 greet
  method. 
  
 We must be careful when using the 
 this
  operator because in some scenarios it can 
 point to the wrong value. Let's add an extra method to the previous example:
  
 class Person { 
  
 name : string;
  
  
  constructor(name : string) 
 {
  
  
  this.name = name;
  
  
  }
  
 [
  84 
 ]",NA
Callback hell,"We have seen that callbacks and higher order functions are two powerful and flexible 
 TypeScript features. However, the use of callbacks can lead to a maintainability issue 
 known as 
 callback hell
 . We will now write a real-life example to showcase what a 
 callback hell is and how easily we can end up dealing with it.
  
  
 Remember that you can find the complete source code for this 
  
  
 demo in the companion source code.
  
 We are going to need handlebars and jQuery libraries, so let's install these two 
 libraries and their respective type definition files using npm and tsd. We can then 
 import their type definitions:
  
 ///<reference path=""../typings/handlebars/handlebars.d.ts"" />
  
 ///<reference path=""../typings/jquery/jquery.d.ts"" />
  
 To make our code easier to read, we will create an alias for the callback type:
  
 type cb = (json : any) => void;
  
 Now we need to declare our 
 View
  class. The 
 View
  class has some properties that 
 allow us to set the following properties:
  
 • 
  
 Container
 : The DOM selector where we want our view to be inserted
  
 • 
  
 Template URL
 : The URL that will return a handlebars template
  
 [
  86 
 ]",NA
Promises ,"After seeing how the use of callbacks can lead to some maintainability problems, we will 
 now look at promises and how they can be used to write better asynchronous code. The 
 core idea behind promises is that a promise represents the result of an asynchronous 
 operation. Promise must be in one of the three following states:
  
 • 
  
 Pending
 : The initial state of a promise
  
 • 
  
 Fulfilled
 : The state of a promise representing a successful operation
  
 • 
  
 Rejected
 : The state of a promise representing a failed operation
  
 [
  90 
 ]",NA
Generators,"If we invoke a function in TypeScript, we can assume that once the function starts 
 running, it will always run to completion before any other code can run. This has been 
 the case until now. However, a new kind of function which may be paused in the 
 middle of execution—one or many times—and resumed later, allowing other code to 
 run during these paused periods, is about to arrive in TypeScript and ES6. These new 
 kinds of functions are known as 
 generators
 .
  
 A generator represents a sequence of values. The interface of a generator object is a 
 just an iterator. The 
 next()
 function can be invoked until it runs out of values.
  
 We can define the constructor of a generator by using the 
 function
  keyword 
 followed by an asterisk (
 *
 ). The 
 yield
  keyword is used to stop the execution of the 
 function and return a value. Let's take a look at an example:
  
 function *foo() {
  
  yield 1;
  
  yield 2;
  
  yield 3;
  
  yield 4;
  
  return 5;
  
 }
  
 var bar = new foo();
  
 bar.next(); // Object {value: 1, done: false}
  
 bar.next(); // Object {value: 2, done: false}
  
 bar.next(); // Object {value: 3, done: false}
  
 bar.next(); // Object {value: 4, done: false}
  
 bar.next(); // Object {value: 5, done: true}
  
 bar.next(); // Object { done: true }
  
 As you can see, this iterator has five steps. The first time we call 
 next
 , the function will 
 be executed until it reaches the first yield statement, and then it will return the value 
 1
  
 and stop the execution of the function until we invoke the generator's 
 next 
 method 
 again. As we can see, we are now able to stop the function's execution at a given point. 
 This allows us to write infinite loops without causing a stack overflow as in the 
 following example:
  
 function* foo() {
  
  var i = 1;
  
 [
  96 
 ]",NA
Asynchronous functions – async and await ,"Asynchronous functions
  are a TypeScript feature that is scheduled to arrive with the 
 upcoming TypeScript releases. An asynchronous function is a function that is expected 
 to be invoked in a synchronous operation. Developers can use the 
 await 
 keyword to 
 wait for the function results without blocking the normal execution of the program.
  
 Asynchronous functions will be implemented using promises when targeting ES6, and 
 promise fallbacks when targeting ES3 and ES5.
  
 Using asynchronous functions generally helps to increase the readability of a piece of 
 code when compared with the use of promises; but technically we can achieve the 
 same features using both promises and synchronous code.
  
 Let's take a sneak-peek at this upcoming feature:
  
 var p: Promise<number> = /* ... */;
  
 async function fn(): Promise<number> { 
  
  
  var i = await p;  
  
  
  return 1 + i;  
  
 }
  
 [
  97 
 ]",NA
Summary,"In this chapter, we saw how to work with functions in depth. We started with a quick 
 recap of some basic concepts and then moved to some lesser known function features 
 and use cases. 
  
 Once we saw how to work with functions, we focused on the usage of callbacks, 
 promises, and generators to take advantage of the asynchronous programming 
 capabilities of Typescript.
  
 In the next chapter, we will look at how to work with classes, interfaces, and other 
 object-oriented programming features of the TypeScript programming language.
  
 [
  98 
 ]",NA
Object-Oriented ,NA,NA
Programming with TypeScript,"In the previous chapter, we explored the use of functions and some asynchronous 
  
 techniques. In this chapter, we will see how to group our functions in reusable 
  
 components, such as classes or modules. This chapter is divided into two main 
  
 sections. The first part will cover the following topics:
  
 • 
  
 SOLID principles
  
 • 
  
 Classes
  
 • 
  
 Association, aggregation, and composition
  
 • 
  
 Inheritance
  
 • 
  
 Mixins
  
 • 
  
 Generic classes
  
 • 
  
 Generic constraints
  
 • 
  
 Interfaces
  
 In the second part, we will focus on the declaration and use of namespaces and 
  
 external modules. The second part will cover the following topics:
  
 • 
  
 Namespaces (internal modules)
  
 • 
  
 External modules
  
 • 
  
 Asynchronous module definition
  (
 AMD
 )
  
 • 
  
 CommonJS modules
  
 • 
  
 ES6 modules
  
 • 
  
 Browserify and 
 universal module definition
  (
 UMD
 )
  
 • 
  
 Circular dependencies
  
 [
  99 
 ]",NA
SOLID principles,"In the early days of software development, developers used to write code with 
 procedural programing languages. In procedural programming languages, the 
 programs follow a top-to-bottom approach and the logic is wrapped with functions.
  
 New styles of computer programming, such as modular programming or structured 
 programming, emerged when developers realized that procedural computer 
 programs could not provide them with the desired level of abstraction, 
 maintainability, and reusability. 
  
 The development community created a series of recommended practices and design 
 patterns to improve the level of abstraction and reusability of procedural programming 
 languages, but some of these guidelines required a certain level of expertise. In order to 
 facilitate adherence to these guidelines, a new style of computer programming known as 
 object-oriented programming
  (
 OOP
 ) was created.
  
 Developers quickly noticed some common OOP mistakes and came up with five rules 
 that every OOP developer should follow to create a system that is easy to maintain and 
 extend over time. These five rules are known as the SOLID principles. 
  
 SOLID is an acronym introduced by Michael Feathers, which stands for the 
 following principles: 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Single responsibility principle
  (
 SRP
 ): This principle states that a software 
 component (function, class, or module) should focus on one unique task (have 
 only one responsibility).
  
 Open/closed principle
  (
 OCP
 ): This principle states that software entities 
 should be designed with application growth (new code) in mind (should be open 
 to extension), but the application growth should require the fewer possible 
 number of changes to the existing code (be closed for modification).
  
 Liskov substitution principle
  (
 LSP
 ): This principle states that we should be 
 able to replace a class in a program with another class as long as both classes 
 implement the same interface. After replacing the class, no other changes 
 should be required, and the program should continue to work as it did 
 originally.
  
 Interface segregation principle
  (
 ISP
 ): This principle states that we should 
 split interfaces that are very large (general-purpose interfaces) into smaller 
 and more specific ones (many client-specific interfaces) so that clients will 
 only need to know about the methods that are of interest to them.
  
 Dependency inversion principle
  (
 DIP
 ): This principle states that entities 
 should depend on abstractions (interfaces) as opposed to depending on 
 concretion (classes).
  
 [
  100 
 ]",NA
Classes ,"We should already be familiar with the basics about TypeScript classes, as we have 
 declared some of them in previous chapters. So we will now look at some details and OOP 
 concepts through examples. Let's start by declaring a simple class:
  
 class Person {
  
  
  public name : string;
  
  
  public surname : string;
  
  
  public email : string;
  
  
  constructor(name : string, surname : string, email : string){
  
  
 this.email = email;
  
  
  this.name = name;
  
  
  this.surname = surname;
  
  
  }
  
  
  greet() {
  
  
  alert(""Hi!"");
  
  
  } 
  
 }
  
 var me : Person = new Person(""Remo"", ""Jansen"", 
 ""remo.jansen@wolksoftware.com"");
  
 We use classes to represent the type of an object or entity. A 
 class
  is composed of a 
 name, attributes, and methods. The class in the preceding example is named 
 Person
  
 and contains three attributes or properties (
 name
 , 
 surname
 , and 
 email
 ) and two 
 methods (
 constructor
  and 
 greet
 ). Class attributes are used to describe the object's 
 characteristics, while class methods are used to describe its behavior.
  
 A 
 constructor
  is a special method used by the new keyword to create instances 
 (also known as objects) of our class. We have declared a variable named me, which 
 holds an instance of the 
 Person
  class. The new keyword uses the 
 Person 
 class's 
 constructor to return an object whose type is 
 Person
 .
  
 A class should adhere to the single responsibility principle (SRP). The 
 Person
  class in 
 the preceding example represents a person, including all their characteristics 
 (attributes) and behaviors (methods). Now let's add some 
 email
  as validation logic:
  
 class Person {
  
  public name : string;
  
  public surname : 
 string;
  
 [
  101 
 ]",NA
Interfaces,"The feature that we will miss the most when developing large-scale web 
  
 applications with JavaScript is probably interfaces. We have seen that following the 
 SOLID principles can help us to improve the quality of our code, and writing good code 
 is a must when working on a large project. The problem is that if we attempt to follow 
 the SOLID principles with JavaScript, we will soon realize that without interfaces, we 
 will never be able to write SOLID OOP code. Fortunately for us, TypeScript features 
 interfaces.
  
 Traditionally, in OOP, we say that a class can extend another class and implement one 
 or more interfaces. An interface can implement one or more interfaces and cannot 
 extend another class or interface. Wikipedia's definition of interfaces in OOP is as 
 follows:
  
 In object-oriented languages, the term interface is often used to define an 
 abstract type that contains no data or code, but defines behaviors as method 
 signatures.
  
 Implementing an interface can be understood as signing a contract. The interface is a 
 contract, and when we sign it (implement it), we must follow its rules. The interface rules 
 are the signatures of the methods and properties, and we must implement them. 
  
 We will see many examples of interfaces later in this chapter.
  
 In TypeScript, interfaces don't strictly follow this definition. The two main 
 differences are that in TypeScript:
  
 • 
  
 An interface can extend another interface or class
  
 • 
  
 An interface can define data and behaviors as opposed to only behaviors
  
 [
  104 
 ]",NA
"Association, aggregation, and ",NA,NA
composition,"In OOP, classes can have some kind of relationship with each other. Now, we will take a 
 look at the three different types of relationships between classes.",NA
Association,"We call 
 association
  those relationships whose objects have an independent lifecycle and 
 where there is no ownership between the objects. Let's take an example of a teacher and 
 student. Multiple students can associate with a single teacher, and a single student can 
 associate with multiple teachers, but both have their own lifecycles (both can be create 
 and delete independently); so when a teacher leaves the school, we don't need to delete 
 any students, and when a student leaves the school, we don't need to delete any teachers.",NA
Aggregation,"We call 
 aggregation
  those relationships whose objects have an independent lifecycle, but 
 there is ownership, and child objects cannot belong to another parent object. Let's take an 
 example of a cell phone and a cell phone battery. A single battery can belong to a phone, 
 but if the phone stops working, and we delete it from our database, the phone battery will 
 not be deleted because it may still be functional. So in aggregation, while there is 
 ownership, objects have their own lifecycle.
  
  
 [
  105 
 ]",NA
Composition,"We use the term 
 composition
  to refer to relationships whose objects don't have an 
 independent lifecycle, and if the parent object is deleted, all child objects will also be 
 deleted. 
  
 Let's take an example of the relationship between questions and answers. Single 
 questions can have multiple answers, and answers cannot belong to multiple 
 questions. If we delete questions, answers will automatically be deleted.
  
 Objects with a dependent life cycle (answers, in the example) are known as 
 weak entities
 .
  
  
 Sometimes, it can be a complicated process to decide if we should use association, 
 aggregation, or composition. This difficulty is caused in part because aggregation and 
 composition are subsets of association, meaning they are specific cases of association.
  
  
 [
  106 
 ]",NA
Inheritance ,"One of the most fundamental object-oriented programming features is its capability to 
 extend existing classes. This feature is known as inheritance and allows us to create a 
 new class (child class) that inherits all the properties and methods from an existing class 
 (parent class). Child classes can include additional properties and methods not available 
 in the parent class. Let's return to our previously declared 
 Person
  class. 
  
 We will use the 
 Person
  class as the parent class of a child class named 
 Teacher
 :
  
 class Person {
  
  
  public name : string;
  
  
  public surname : string;
  
  
  public email : Email;
  
  
  constructor(name : string, surname : string, email : 
 Email){
  
  this.name = name;
  
  
  this.surname = surname;
  
  
  this.email = email;
  
  
  }
  
  
  greet() {
  
  
  alert(""Hi!"");
  
  
  } 
  
 }
  
  
 This example is included in the companion source code.
  
  
 Once we have a parent class in place, we can extend it by using the reserved 
 keyword 
 extends
 . In the following example, we declare a class called 
 Teacher
 , 
 which extends the previously defined 
 Person
  class. This means that 
 Teacher 
 will 
 inherit all the attributes and methods from its parent class: 
  
 class Teacher extends Person {
  
  
  teach() {
  
  
  alert(""Welcome to class!"");
  
  
  } 
  
 }
  
 Note that we have also added a new method named 
 teach
  to the class 
 Teacher
 . If we 
 create instances of the 
 Person
  and 
 Teacher
  classes, we will be able to see that both 
 instances share the same attributes and methods with the exception of the 
 teach
  
 method, which is only available for the instance of the 
 Teacher
  class:
  
 var teacher = new Teacher(""remo"", ""jansen"", new 
 Email(""remo.jansen@wolksoftware.com""));
  
 [
  107 
 ]",NA
Mixins,"Sometimes, we will find scenarios in which it would be a good idea to declare a 
 class that inherits from two or more classes simultaneously (known as 
 multiple 
 inheritance
 ).
  
 Let's take a look at an example. We will not add any code to the methods in this example 
 because we want to avoid the possibility of getting distracted by it; we should focus on the 
 inheritance tree:
  
 class Animal {
  
  eat() {
  
  // ...
  
  }
  
 }
  
 [
  109 
 ]",NA
Generic classes ,"In the previous chapter, we saw how to work with generic functions. We will now take 
 a look at how to work with generic classes. 
  
 Just like with generic functions, generic classes can help us to avoid the duplication of 
 code. Let's take a look at an example:
  
 class User {
  
  
  public name : string;
  
  
  public password : string; 
  
 }
  
  
 This example is included in the companion source code.
  
  
 We have declared a 
 User
  class, which contains two properties: 
 name
  and 
 password
 . We 
 will now declare a class named 
 NotGenericUserRepository
  without using generics. 
 This class takes a URL via its constructor and has a method named 
 getAsync
 . The 
 getAsync
  method will request a list of users stored in a JSON file using AJAX:
  
 class NotGenericUserRepository {
  
  
  private _url : string;
  
  
  constructor(url : string) {
  
  
  this._url = url;
  
  
  }
  
  
  public getAsync() {
  
  
  return Q.Promise((resolve : (users : User[]) => void, reject)  
  
  => {
  
    
  $.ajax({
  
     
  url: this._url,
  
 [
  115 
 ]",NA
Generic constraints ,"Sometimes, we might need to restrict the use of a generic class. Take the generic 
 repository from the previous section as an example. We have a new requirement: we 
 need to add some changes to validate the entities loaded via AJAX, and we will return 
 only the valid entities.
  
 One possible solution is to use the 
 typeof
  operator to identify the type of the 
 generic type parameter 
 T
  within a generic class or function:
  
 // ...
  
 success: (data) => {
  
  
  var list : T[];
  
  
  var items = <T[]>data.items;
  
  
  for(var i = 0; i < items.length; i++){
  
  
  if(items[i] instanceof User) {
  
    
  // validate user
  
  
  }
  
  
  if(items[i] instanceof Talk) {
  
    
  // validate talk
  
  
  }
  
  
  }
  
  
  resolve(list); 
  
 } 
  
 // ...
  
 [
  118 
 ]",NA
Multiple types in generic type constraints ,"We can only refer to one type when declaring a generic type constraint. Let's imagine that 
 we need a generic class to be constrained, so it only allows types that implement the 
 following two interfaces:
  
 interface IMyInterface {
  
  
  doSomething(); 
  
 }; 
  
 interface IMySecondInterface 
 {
  
  
  doSomethingElse(); 
  
 };
  
 We may think that we can define the required generic constraint as follows:
  
 class Example<T extends IMyInterface, IMySecondInterface> {
  
  private genericProperty : T;
  
  
  useT() {
  
  
  this.genericProperty.doSomething();
  
  
  this.genericProperty.doSomethingElse(); // error
  
  
  } 
  
 }
  
 However, this code snippet will throw a compilation error. We cannot specify 
 multiple types when declaring a generic type constraint. However, we can work 
 around this issue by transforming 
 IMyInterface
 , 
 IMySecondInterface
  in super-
 interfaces: 
  
 interface IChildInterface extends IMyInterface, IMySecondInterface {
  
 }
  
 IMyInterface
  and 
 IMySecondInterface
  are now super-interfaces because they are 
 the parent interfaces of the 
 IChildInterface
  interface. We can then declare the 
 constraint using the 
 IChildInterface
  interface:
  
 class Example<T extends IChildInterface> {
  
  
  private genericProperty : T;
  
  
  useT() {
  
  
  this.genericProperty.doSomething();
  
  
  this.genericProperty.doSomethingElse();
  
  
  } 
  
 }
  
 [
  122 
 ]",NA
The new operator in generic types,"To create a new object within generic code, we need to indicate that the generic 
 type T has a constructor function. This means that instead of using 
 type:T
 , we 
 should use 
 type: { new(): T;}
  as follows:
  
 function factoryNotWorking<T>(): T {
  
  return new T(); // compile error could not find symbol T
  
 }
  
 function factory<T>(): T {
  
  var type: { new(): T ;};
  
  return new type();
  
 }
  
 var myClass: MyClass = factory<MyClass>();",NA
Applying the SOLID principles,"As we have previously mentioned, interfaces are fundamental features when it 
 comes to following the SOLID principles, and we have already put the first two 
 SOLID principles into practice.
  
 We have already discussed the single responsibility principle. Now, we will see real 
 examples of the three remaining principles.",NA
The Liskov substitution principle,"The 
 Liskov substitution principle
  (LSP) states, 
 Subtypes must be substitutable 
 for their base types
 . Let's take a look at an example to understand what this means.
  
 We will declare a class named 
 PersistanceService
 , the responsibility of which is 
 to persist some object into some sort of storage. We will start by declaring the 
 following interface:
  
 interface PersistanceServiceInterface {
  
  save(entity : any) : number;
  
 }
  
 [
  123 
 ]",NA
The interface segregation principle,"Interfaces are used to declare how two or more software components cooperate and 
 exchange information with each other. This declaration is known as 
  
 application programming interface
  (
 API
 ). In the previous example, our interface 
 was 
 PersistanceServiceInterface
 , and it was implemented by the classes 
 LocalStoragePersitanceService
  and 
 CookiePersitanceService
 . The interface 
 was consumed by the 
 FavouritesController
  class; so we say that this class is a 
 client of the 
 PersistanceServiceInterface's
  API.
  
 The 
 interface segregation principle
  (
 ISP
 ) states that no client should be forced to 
 depend on methods it does not use. To adhere to the ISP, we need to keep in mind that 
 when we declare the API (how two or more software components cooperate and 
 exchange information with each other) of our application's components, the 
 declaration of many client-specific interfaces is better than the declaration of one 
 general-purpose interface. Let's take a look at an example.
  
 If we design an API to control all the elements in a vehicle (engine, radio, heating, 
 navigation, lights…), we could have one general-purpose interface, which allows us to 
 control every single element of the vehicle:
  
 interface VehicleInterface {
  
  getSpeed() : number;
  
  getVehicleType: string;
  
  isTaxPayed() : boolean;
  
  isLightsOn() : boolean;
  
  isLightsOff() : boolean;
  
  startEngine() : void;
  
  acelerate() : number;
  
  stopEngine() : void;
  
  startRadio() : void;
  
  playCd : void;
  
  stopRadio() : void;
  
 }
  
  
 This example is included in the companion source code.
  
  
 If a class has a dependency (client) in the 
 VehicleInterface
  interface but it only 
 wants to use the radio methods, we will be facing a violation of the ISP because, as 
 we have already seen, no client should be forced to depend on methods it does not 
 use.
  
 [
  125 
 ]",NA
The dependency inversion principle ,"The 
 dependency inversion
  (
 DI
 ) principle states, 
 Depend upon abstractions. Do not 
 depend upon concretions
 . In the previous section, we implemented 
 FavouritesController
  and we were able to replace an implementation of 
 PersistanceServiceInterface
  with another without having to perform any additional 
 change to 
 FavouritesController
 . 
  
 This was possible because we followed the DI principle, as 
 FavouritesController 
 has a dependency upon 
 PersistanceServiceInterface
  (abstractions) rather than 
 LocalStoragePersitanceService
  or 
 CookiePersitanceService
  (concretions).
  
 [
  126 
 ]",NA
Namespaces ,"TypeScript features namespaces (previously known as internal modules). 
 Namespaces are mainly used to organize our code. 
  
 If we are working on a large application, as the code base grows we will need to 
 introduce some kind of organization scheme to avoid naming collisions and make our 
 code easier to follow and understand. 
  
 We can use namespaces to encapsulate interfaces, classes, and objects that are 
 somehow related. For example, we could wrap all our application models inside an 
 internal module named model:
  
 namespace app {
  
  
  export class UserModel 
 {
  
  
  // ...
  
  
  } 
  
 }
  
 When we declare a namespace, all its entities are private by default. We can use the 
 export
  keyword to declare what parts of our namespace we wish to make public. 
  
 We are allowed to nest a namespace inside another. Let's create a file named 
 models.ts
  and add the following code snippet to it:
  
 namespace app {
  
  
  export namespace models {
  
  
  export class UserModel {
  
    
  // ...
  
  }
  
 [
  127 
 ]",NA
Modules,"TypeScript also has the concept of external modules or just modules. The main 
 difference between using modules (instead of namespaces) is that after declaring all our 
 modules, we will not import them using an HTML 
 <script>
  tag and we will be able to 
 use a module loader instead. 
  
 A 
 module loader
  is a tool that allows us to have better control over the module loading 
 process. This allows us to perform tasks such as loading files asynchronously or 
 combining multiple modules into a single highly optimized file with ease.
  
 Using the 
 <script>
  tag is not recommended because when a web browser finds a 
 <script>
  tag, it downloads the file using asynchronous requests. We should attempt to 
 load as many files as possible using asynchronous requests because doing so will 
 significantly improve the network performance of a web application.
  
  
 We will discover more about network performance in 
  
  
 Chapter 6
 , 
 Application Performance
 .
  
 [
  129 
 ]",NA
ES6 modules – runtime and design time,"TypeScript 1.5 introduces support for the ES6 module syntax. Let's define an external 
 module using it:
  
 class UserModel {
  
  // ...
  
 }
  
 export { UserModel };
  
 We have defined an external module. We don't need to use the 
 namespace
  keyword, but 
 we must continue to use the 
 export
  keyword. We used the 
 export
  keyword at the 
 bottom of the module, but it is also possible to use it just before the 
 class 
 keyword like 
 we did in the internal module example:
  
 export class UserModel {
  
  // ...
  
 }
  
 We can also export an entity using an alias:
  
 class UserModel {
  
  // ...
  
 }
  
 export { UserModel as User }; // UserModel exported as User
  
 An export declaration exports all meanings of a name:
  
 interface UserModel {
  
  // ...
  
 }
  
 class UserModel {
  
  // ...
  
 }
  
 export { UserModel }; // Exports both interface and function
  
 To import a module, we must use the 
 import
  keyword as follows:
  
 import { UserModel } from ""./models"";
  
 The 
 import
  keyword creates a variable for each imported component. In the 
 preceding code snippet, a new variable named 
 UserModel
  is declared and its value 
 contains a reference to the 
 UserModel
  class, which was declared and exported in the 
 models.ts
  file.
  
 [
  131 
 ]",NA
External modules – design time only ,"Before TypeScript 1.5, modules were declared using a kind of module syntax known as 
 external module syntax. This kind of syntax was used at design time (TypeScript code). 
 However, once compiled into JavaScript, it was transformed and executed (runtime) 
 into AMD, CommonJS, UMD, or SystemJS modules.
  
 We should try to avoid using this syntax and use the new ES6 syntax instead. 
 However, we will take a quick look at the external module syntax because we may 
 have to work on old applications or outdated documentation.
  
 We can import a module using the 
 import
  keyword:
  
 import User = require(""./user_class"");
  
 The preceding code snippet declares a new variable named 
 User
 . The 
 User
  variable 
 takes the exported content of the 
 user_class
  module as its value.
  
 To export a module, we need to use the 
 export
  keyword. We can apply the 
 export 
 keyword directly to a class or interface:
  
 export class User {
  
  // …
  
 }
  
 [
  132 
 ]",NA
AMD modules – runtime only ,"If we compile the initial external module into an AMD module (using the flag 
 --
 compile amd
 ), we will generate the following AMD module:
  
 define([""require"", ""exports""], function (require, exports) { 
 var UserModel = (function () {
  
  
  
  function UserModel() {
  
  
  
  }
  
  
  
  return UserModel;
  
  })();
  
  return UserModel; 
  
 });
  
 The define function takes an array as its first argument. This array contains a list of the 
 names of the module dependencies. The second argument is a callback that will be 
 invoked once all the module dependencies have been loaded. The callback takes each of 
 the module dependencies as its parameters and contains all the logic from our TypeScript 
 component. Notice how the return type of the callback matches the components that we 
 declared as public by using the 
 export
  keyword. AMD modules can then be loaded using 
 the RequireJS module loader. 
  
  
 We will not discuss AMD and RequireJS further in this book, 
  
  
 but if you want to learn more about them, you can do so by 
  
 visiting 
 http://requirejs.org/docs/start.html
 .
  
 [
  133 
 ]",NA
CommonJS modules – runtime only ,"We begin by compiling our external module into a CommonJS module (using the flag 
 --compile commonjs
 ). We will compile the following code snippet:
  
 class User {
  
  // …
  
 } 
  
 export = User; 
  
 As a result, the following CommonJS module is generated:
  
 var UserModel = (function () 
 {
  
  function UserModel() {
  
  
  
  //…
  
  }
  
  return UserModel; 
  
 })(); 
  
 module.exports = UserModel;
  
 As we can see in the preceding code snippet, the CommonJS module definition syntax is 
 almost identical to the deprecated TypeScript (1.4 or prior) external module syntax. 
  
 The preceding CommonJS module can be loaded by a Node.js application without any 
 additional changes using the 
 import
  keyword and the 
 require
  function:
  
 import UserModel = require('./UserModel'); 
  
 var user = new UserModel();
  
 However, if we attempt to use the 
 require
  function in a web browser, an exception will 
 be thrown because the 
 require
  function is undefined. We can easily solve this problem 
 by using Browserify. 
  
 All that we need to follow is three simple steps:
  
 1. Install Browserify using npm:
  
 npm install -g browserify
  
 2. Use Browserify to bundle all your CommonJS modules into a JavaScript file 
 that you can import using an HTML 
 <script>
  tag. We can do this by 
 executing the following command:
  
 browserify main.js -o bundle.js
  
 In the preceding command, 
 main.js
  is the file that contains the root module 
 within our application's dependency tree. The 
 bundle.js
  file is the output file 
 that we will be able to import using a HTML script tag.
  
 [
  134 
 ]",NA
UMD modules – runtime only ,"If we want to release a JavaScript library or framework, we will need to compile our 
 TypeScript application into both CommonJS and AMD modules. Our library should also 
 allow developers to load it directly in a web browser using a HTML script tag.
  
 The web development community has developed the following code snippet to help us 
 to achieve 
 universal module definition
  (
 UMD
 ) support:
  
 (function (root, factory) {
  
  
  if (typeof exports === 'object') {
  
  
  // CommonJS
  
  
  module.exports = factory(require('b'));
  
  
  } else if (typeof define === 'function' && define.amd) 
 {
  
  // AMD
  
  
  define(['b'], function (b) {
  
    
  return (root.returnExportsGlobal = factory(b));
  
  
 });
  
  
  } else {
  
  
  // Global Variables
  
  
  root.returnExportsGlobal = factory(root.b);
  
  
  } 
  
 }(this, function (b) {
  
  
  // Your actual module
  
  
  return {}; 
  
 }));
  
 This code snippet is great, but we want to avoid manually adding it to every single 
 module in our application. Fortunately, there are a few options available to achieve 
 UMD support with ease. 
  
 The first option is to use the flag 
 --compile umd
  to generate one UMD module for 
 each module in our application. The second option is to create one single UMD module 
 that will contain all the modules in the application using a module loader known as 
 Browserify.
  
 [
  135 
 ]",NA
SystemJS modules – runtime only,"While UMD gives you a way to output a single module that works in both AMD and 
 CommonJS, SystemJS will allow you to use ES6 modules closer to their native 
 semantics without requiring an ES6-compatible browser engine.
  
 SytemJS is used by Angular 2.0, which is the upcoming version of a popular web 
 application development framework. 
  
  
 Refer to the official SytemJS project website at 
 https://github.com/
  
  
 systemjs/systemjs
  to learn more about SystemJS.
  
 There is a free list of common module mistakes available online at 
  
 http://www.typescriptlang.org/Handbook#modules-
  
 pitfalls-of-modules
 .",NA
Circular dependencies,"A circular dependency is an issue that we can encounter when working with multiple 
 components and dependencies. Sometimes, it is possible to reach a point in which 
 one component (A) has a dependency on a second component (B), which depends on 
 the first component (A). In the following graph, each node is a component, and we 
 can observe that the nodes 
 circular1.ts
  and 
 circular2.ts
  have a circular dependency. 
 The node named 
 doesNotDependOnAnything.ts
  doesn't have dependencies and 
 the node named 
 onlyDependsOnOtherStuff.ts
  has a dependency on 
 circular1.ts
  but doesn't have circular dependencies..
  
 [
  136 
 ]",NA
Summary,"In this chapter, we saw how to work with classes, interfaces, and modules in depth. We 
 were able to reduce the complexity of our application by using techniques such as 
 encapsulation and inheritance.
  
 We were also able to create external modules and manage our application 
 dependencies using tools such as RequireJS or Browserify.
  
 In the next chapter, we will discuss the TypeScript runtime.
  
 [
  138 
 ]",NA
Runtime,"After completing this book, you will probably be eager to start a new project to put 
 into practice all your new knowledge. As the new project grows and you develop more 
 complex features, you might encounter some runtime issues.
  
 We should be able to resolve design-time issues with ease because in the previous 
 chapter, we looked at the main TypeScript features. 
  
 However, we have not learned much about the TypeScript runtime. The good news is 
 that, depending on your background, you may already know a lot about it, as the 
 TypeScript runtime is the JavaScript runtime. TypeScript is only used at design time; the 
 TypeScript code is then compiled into JavaScript and finally executed. The JavaScript 
 runtime is in charge of the execution. Is important to understand that we never execute 
 TypeScript code and we always execute JavaScript code. For this reason, when we refer 
 to the TypeScript runtime, we will, in fact, be talking about the JavaScript runtime.
  
 When we compile our TypeScript code, we will generate JavaScript code, which will be 
 executed on the server side (with Node.js) or on the client side (in a web browser). It is 
 then that we may encounter some challenging runtime issues.
  
 In this chapter, we will cover the following topics:
  
 • 
  
 The environment
  
 • 
  
 The event loop
  
 • 
  
 The 
 this
  operator
  
 • 
  
 Prototypes
  
 • 
  
 Closures
  
 Let's start by learning about the environment.
  
 [
  139 
 ]",NA
The environment,"The runtime environment is one of the first things that we must consider before we 
 can start developing a TypeScript application. Once we have compiled our TypeScript 
 code, it can be executed in many different JavaScript engines. While the majority of 
 those engines will be web browsers, such as Chrome, Internet Explorer, or Firefox, we 
 might also want to be able to run our code on the server side or in a desktop 
 application in environments such as Node.js or RingoJS.
  
 It is important to keep in mind that there are some variables and objects available at 
 runtime that are environment-specific. For example, we could create a library and access 
 the 
 document.layers
  variable. While 
 document
  is part of the W3C 
 Document Object 
 Model
  (
 DOM
 ) standard, the 
 layers
  property is only available in Internet Explorer and is 
 not part of the W3C DOM standard. 
  
 The W3C defines the DOM as follows:
  
 The Document Object Model is a platform- and language-neutral interface that 
 will allow programs and scripts to dynamically access and update the content, 
 structure and style of documents. The document can be further processed and 
 the results of that processing can be incorporated back into the presented 
 page.
  
 In a similar manner, we can also access a set of objects known as the 
 Browser Object 
 Model
  (
 BOM
 ) from a web browser runtime environment. The BOM consists of the 
 objects navigator, history, screen, location, and document, which are properties of the 
 window object.
  
 You need to realize that the DOM is part of the web browsers but not part of JavaScript. 
 If we want to run our application in a web browser, we will be able to access the DOM 
 and BOM. However, in environments like Node.js or RingoJS, they will not be available, 
 since they are standalone JavaScript environments completely independent of a web 
 browser. We can also find other objects on the server-side environments (such as 
 process.stdin
  in Node.js) that will not be available if we attempt to execute our code 
 in a web browser.
  
 As if this wasn't enough work, we also need to keep in mind the existence of 
  
 multiple versions of these JavaScript environments. We will have to support multiple 
 browsers and multiple versions of Node.js. The recommended practice when dealing with 
 this problem is to add logic that looks for the availability of features rather than the 
 availability of a particular environment or version.
  
  
 A really good library is available that can help us to implement feature 
  
  
 detection when developing for web browsers. The library is called 
  
 Modernizr
  and can be downloaded at 
 http://modernizr.com/
 .
  
 [
  140 
 ]",NA
The runtime,"The TypeScript runtime (JavaScript) has a concurrency model based on an 
 event loop
 . 
 This model is quite different to the models in other languages such as C or Java. Before 
 we focus on the event loop itself, you must understand some runtime concepts. 
  
 What follows is a visual representation of some important runtime concepts: heap, 
 stack, queue, and frame:
  
  
 We will now look at the role of each of these runtime concepts.",NA
Frames,"A frame is a sequential unit of work. In the preceding diagram, the frames are 
 represented by the blocks inside the stack.
  
 When a function is called in JavaScript, the runtime creates a frame in the stack. The 
 frame holds that particular function's arguments and local variables. When the 
 function returns, the frame is popped out of the stack. Let's take a look at an example:
  
 function foo(b){
  
  var a = 12;
  
  return a+b+35;
  
 }
  
 function bar(x){
  
 [
  141 
 ]",NA
Stack,"The stack contains the sequential steps (frames) that a message needs to execute. A 
 stack is a data structure that represents a simple 
 Last In First Out
  (
 LIFO
 ) collection of 
 objects. Therefore, when a frame is added to the stack, it is always added to the top of 
 the stack. 
  
 Since the stack is a LIFO collection, the event loop processes the frames stored in it 
 from top to bottom. The dependencies of a frame are added to the top of it in the stack 
 to ensure that all the dependencies of each of the frames are met.",NA
Queue,"The queue contains a list of messages waiting to be processed. Each message is associated 
 with a function. When the stack is empty, a message is taken out of the queue and 
 processed. The processing consists of calling the associated function and adding the 
 frames to the stack. The message processing ends when the stack becomes empty again.
  
 In the previous runtime diagram, the blocks inside the queue represent the messages. 
  
 [
  142 
 ]",NA
Heap,"The heap is a memory container that is not aware of the order of the items stored in it. 
 The heap contains all the variables and objects currently in use. It may also contain 
 frames that are currently out of scope but have not yet been removed from memory by 
 the garbage collector.",NA
The event loop,"Concurrency is the ability for two or more operations to be executed simultaneously. 
 The runtime execution takes place on one single thread, which means that we cannot 
 achieve real concurrency. 
  
 The event loop follows a run-to-completion approach, which means that it will 
 process a message from beginning to end before any other message is processed. 
  
  
 As we discussed in 
 Chapter 3
 , 
 Working with Functions
 , we can use the 
  
  
 yield
  keyword and generators to pause the execution of a function.
  
 Every time a function is invoked, a new message is added to the queue. If the stack is 
 empty, the function is processed (the frames are added to the stack). 
  
 When all the frames have been added to the stack, the stack is cleared from top to 
 bottom. At the end of the process, the stack is empty and the next message is 
 processed.
  
  
 Web workers can performance background tasks in a different thread. 
  
  
 They have their own queue, heap, and stack.
  
 One of the advantages of the event loop is that the execution order is quite predictable 
 and easy to follow. Another important advantage of the event loop approach is that it 
 features non-blocking I/O. This means that when the application is waiting for an input 
 and output (I/O) operation to finish, it can still process other things, such as user input.
  
 A disadvantage of this approach is that if a message takes too long to complete, the 
 application becomes unresponsive. Good practice is to make message processing 
 short, and if possible, split one message function into several messages functions.
  
 [
  143 
 ]",NA
The this operator,"In JavaScript, the 
 this
  operator behaves a little differently than other languages. The 
 value of the 
 this
  operator is often determined by the way a function is invoked. Its value 
 cannot be set by assignment during execution, and it may be different each time a 
 function is invoked.
  
  
 The 
 this
  operator also has some differences when using the 
  
  
 strict and nonstrict modes. To learn more about the strict mode, 
  
 refer to 
 https://developer.mozilla.org/en-US/docs/
  
 Web/JavaScript/Reference/Strict_mode
 .",NA
The this operator in the global context,"In the global context, the 
 this
  operator will always point to the global object. In a 
 web browser, the 
 window
  object is the global object:
  
 console.log(this === window); // true
  
 this.a = 37;
  
 console.log(window.a); // 37
  
 console.log(this.document === document === window. document); // true",NA
The this operator in a function context,"The value of 
 this
  inside a function depends on how the function is invoked. If we simply 
 invoke a function in the nonstrict mode, the value of 
 this
  within the function will point to 
 the global object:
  
 function f1(){
  
  return this;
  
 }
  
 f1() === window; // true
  
 However, if we invoke a function in the strict mode, the value of 
 this
  within the 
 function's body will point to 
 undefined
 :
  
 console.log(this); // global (window)
  
 function f2(){
  
  ""use strict"";
  
  return this; // undefined
  
 }
  
 console.log(f2()); // undefined
  
 console.log(this); // window
  
 [
  144 
 ]",NA
"The call, apply, and bind methods ","All the functions inherit the 
 call
 , 
 apply
 , and 
 bind
  methods from 
  
 Function.prototype
 . We can use these methods to set the value of the 
 this 
 operator when it is used inside the body of a function.
  
 The 
 call
  and 
 apply
  methods are almost identical; both methods allow us to invoke 
 a function and set the value of the 
 this
  operator within the function. The main 
 difference between 
 call
  and 
 apply
  is that while 
 apply
  lets us invoke the function 
 with arguments as an array and 
 call
  requires the function parameters to be listed 
 explicitly.
  
 [
  145 
 ]",NA
Prototypes,"When we compile a TypeScript program, all classes and objects become JavaScript 
 objects. Sometimes, we will encounter our application behaving unexpectedly at 
 runtime, and we will not be able to identify and understand the root cause of this 
 behavior without a good understanding of how inheritance works in JavaScript. This 
 understanding will allow us to have much better control over our application at 
 runtime.
  
 The runtime inheritance system uses a prototypal inheritance model. In a prototypal 
 inheritance model, objects inherit from objects, and there are no classes available. 
  
 However, we can use prototypes to simulate classes. Let's see how it works.
  
 At runtime, almost every JavaScript object has an internal property called prototype. 
 The value of the prototype attribute is an object, which contains some attributes (data) 
 and methods (behavior).
  
 In TypeScript, we can use a class-based inheritance system:
  
 class Person {
  
  public name : string;
  
  public surname : string;
  
  public age : number = 0;
  
  constructor(name : string, surname : string){
  
  this.name = name;
  
 [
  148 
 ]",NA
Instance properties versus class properties ,"As 
 JavaScript is a dynamic programming language, we can add properties and methods to 
 an instance of an object at runtime; and they don't need to be part of the object (class) 
 itself. Let's take a look at an example:
  
 function Person(name, surname) {
  
  // instance properties
  
  this.name = name;
  
 [
  149 
 ]",NA
Prototypal inheritance ,"You might be wondering how the 
 extends
  keyword works. Let's create a new 
 TypeScript class, which inherits from the 
 Person
  class, to help you understand it:
  
 class SuperHero extends Person {
  
  
  public superpower : string;
  
  
  constructor(name : string, surname : string, superpower :  
  
  string){
  
  
  super(name, surname);
  
  
  this.superpower = superpower;
  
  
  }
  
  
  userSuperPower() {
  
  
  return `I'm using my ${this.superpower}`
  
  
  } 
  
 }
  
 [
  152 
 ]",NA
The prototype chain ,"When we try to access a property or method of an object, the runtime will search for 
 that property or method in the object's own properties and methods. If it is not found, 
 the runtime will continue searching through the object's inherited properties by 
 navigating the entire inheritance tree. As a derived object is linked to its base object 
 through the prototype property, we refer to this inheritance tree as the prototype chain.
  
 Let's take a look at an example. We will declare two simple TypeScript classes named 
 Base
  and 
 Derived
 :
  
 class Base {
  
  
  public method1(){ return 1; };
  
  
  public method2(){ return 2; }; 
  
 }
  
 class Derived extends Base {
  
  
  public method2(){ return 3; };
  
  
  public method3(){ return 4; }; 
  
 }
  
 Now, we will examine the JavaScript code generated by TypeScript:
  
 var Base = (function () {
  
  function Base() {
  
  }
  
  Base.prototype.method1 = function () { return 1; }; ;
  
  Base.prototype.method2 = function () { return 2; }; ;
  
  return Base; 
  
 })();
  
 [
  156 
 ]",NA
Accessing the prototype of an object ,"Prototypes can be accessed in three different ways:
  
 • 
  
 • 
  
 Person.prototype
 : We can access the prototype of a function directly using the 
 prototype attribute
  
 Person.getPrototypeOf(person)
 : We want this function to access the 
 prototype of an instance of an object we can use the 
 getPrototypeOf 
 function
  
 [
  157 
 ]",NA
The new operator,"We can use the 
 new
  operator to generate an instance of 
 Person
 :
  
 var person = new Person(""remo"", ""jansen"");
  
 The runtime does not follow a class-based inheritance model. When we use the 
 new 
 operator, the runtime creates a 
 new
  object that inherits from the 
 Person
  class 
 prototype.
  
 We may conclude that the behavior of the new operator at runtime (JavaScript) is not 
 really different from the 
 extends
  keyword at design time (TypeScript).",NA
Closures,"Closures are one of the most powerful features available at runtime, but they are also one 
 of the most misunderstood. The Mozilla developer network defines closures as follows:
  
 ""Closures are functions that refer to independent (free) variables. In other 
 words, the function defined in the closure 'remembers' the environment in 
 which it was created.""
  
 We understand 
 independent (free) variables
  as variables that persist beyond the 
 lexical scope from which they were created. Let's take a look at an example:
  
 function makeArmy() {
  
  var shooters = []
  
  for(var i = 0; i < 10; i++) {
  
  var shooter = function() { // a shooter is a function
  
  alert(i) // which should alert it's number
  
  }
  
 [
  158 
 ]",NA
Static variables with closures ,"In the previous section, we saw that when a variable is declared in a closure context it 
 can be shared between multiple instances of a class, or in other words, the variable 
 behaves as a static variable.
  
 We will now see how we can create variables and methods that behave like static 
 variables. Let's start by declaring a TypeScript class named 
 Counter
 :
  
 class Counter {
  
  
  private static _COUNTER = 
 0;
  
  
  constructor() {}
  
  
  private _changeBy(val) {
  
  
  Counter._COUNTER += val;
  
  
  }
  
  
  public increment() {
  
  
  this._changeBy(1); 
  
  
  }
  
  
  public decrement() {
  
  
  this._changeBy(-1);
  
  
  }
  
  
  public value() {
  
  
  return Counter._COUNTER;
  
  
  } 
  
 }
  
 The preceding class contains a static member named 
 _COUNTER
 . The TypeScript 
 compiler transforms it into the following resulting code:
  
 var Counter = (function () {
  
  function Counter() {
  
  }
  
  Counter.prototype._changeBy = function (val) {
  
  
  Counter._COUNTER += val;
  
  };
  
  Counter.prototype.increment = function () {
  
  
  this._changeBy(1);
  
  };
  
  Counter.prototype.decrement = function () {
  
  
  this._changeBy(-1);
  
  };
  
 [
  160 
 ]",NA
Private members with closures ,"We have seen that the closure function can access variables that persist beyond the 
 lexical scope from which they were created. These variables are not part of the 
 function prototype or body, but they are part of the closure function context.
  
 As there is no way to directly access the context of a closure function, the context 
 variables and methods can be used to emulate private members. The main advantage of 
 using closures to emulate private members (instead of the TypeScript private access 
 modifier) is that closures will prevent access to private members at runtime.
  
 TypeScript avoids emulating private properties at runtime. The TypeScript compiler will 
 throw an error at compilation time if we attempt to access a private member. 
  
 However, TypeScript avoids the use of closures to emulate private members to 
 improve the application performance. If we add or remove an access modifier to or 
 from one of our classes, the resulting JavaScript code will not change at all. This means 
 that private members of a class become public members at runtime.
  
 [
  162 
 ]",NA
Summary,"In this chapter, we discovered how to understand the runtime, which allows us not only 
 to resolve runtime issues with ease but also to be able to write better TypeScript code. A 
 deep understanding of closures and prototypes will allow you to develop some complex 
 features that it would have not been possible to develop without this knowledge.
  
 In the next chapter, we will focus on performance, memory management, and 
 exception handling.
  
 [
  164 
 ]",NA
Application Performance,"In this chapter, we will take a look at how can we manage available resources in an 
 efficient manner to achieve great performance. You will understand the different types 
 of resource, performance factors, performance profiling and automation.
  
 The chapter begins by introducing some core performance concepts, such as latency or 
 bandwidth, and continues by showcasing how to measure and monitor performance as 
 part of the automated build process.
  
 As we discussed in previous chapters, we can use TypeScript to generate JavaScript code 
 that can be executed in many different environments (web browsers, Node.
  
 js, mobile devices, and so on). In this chapter, we will explore performance 
 optimization, which is mainly applicable to the development of web applications. 
  
 The following topics will be covered in this chapter:
  
 • 
  
 Performance and resources
  
 • 
  
 Aspects of performance
  
 • 
  
 Memory profiling
  
 • 
  
 Network Profiling
  
 • 
  
 CPU and GPU profiling
  
 • 
  
 Performance testing
  
 • 
  
 Performance recommendations
  
 • 
  
 Performance automation
  
 [
  165 
 ]",NA
Prerequisites,"Before we get started, we need to install Google Chrome because we will use its 
 developer tools to perform web performance analysis.",NA
Performance and resources,"Before we get our hands dirty doing some performance analysis, monitoring, and 
 automation, we must first spend some time understanding some core concepts and 
 aspects about performance.
  
 A good application is one that has a set of desirable characteristics, which includes 
 functionality, reliability, usability, reusability, efficiency, maintainability, and 
 portability. Over the course of this book so far, we have understood a lot about 
 maintainability and reusability. In this chapter, we will focus on performance, which is 
 closely related to reliability and maintainability.
  
 The term performance refers to the amount of useful work accomplished compared to 
 the time and resources used. A resource is a physical (CPU, RAM, GPU, HDD, and so on) 
 or virtual (CPU times, RAM regions, files, and so on) component with limited availability. 
 As the availability of a resource is limited, each resource is shared between processes. 
 When a process finishes using a resource, it must release the resource before any other 
 process can use it. Managing available resources in an efficient manner will help to 
 reduce the time other processes spend waiting for the resources to become available.
  
 When we work on a web application, we need to keep in mind that the following 
 resources will have limited availability:
  
 • 
  
 • 
  
 • 
  
 Central Processing Unit
  (CPU): This carries out the instructions of a 
 computer program by performing the basic arithmetic, logical, control, 
 and input/output (I/O) operations specified by the instructions.
  
 Graphics Processor Unit
  (
 GPU
 ): This is a specialized processor is used in 
 the manipulation and alteration of memory to accelerate the creation of 
 images in a frame buffer intended for output to a display. The GPU is used 
 when we create applications that use the WebGL API or when we use some 
 CSS3 animations.
  
 Random Access Memory
  (
 RAM
 ): This allows data items to be read and written 
 in approximately the same amount of time regardless of the order in which data 
 items are accessed. When we declare a variable, it will be stored in RAM 
 memory; when the variable is out of the scope, it will be removed from RAM by 
 the garbage collector.
  
 [
  166 
 ]",NA
Performance metrics,"As performance is influenced by the availability of multiple types of physical and virtual 
 device, we can find a few different performance metrics (factors to measure 
 performance). Some popular performance metrics include availability, response time, 
 processing speed, latency, bandwidth, and scalability. These measurement mechanisms 
 are usually directly related to one of the general resources (CPU, network throughput, 
 and so on) that were mentioned in the previous section. We will now look at each of 
 these performance metrics in detail.",NA
Availability,"The availability of a system is related to its performance, because if the system is not 
 available at some stage, we will perceive it as bad performance. The availability can be 
 improved by improving the reliability, maintainability, and testability of the system. 
  
 If the system is easy to test and maintain, it will be easy to increase its reliability.
  
 [
  167 
 ]",NA
The response time,"The response time is the amount of time that it takes to respond to a request for a 
 service. A service here does not refer to a web service; a service can be any unit of 
 work. The response time can be divided into three parts:
  
 • 
  
 • 
  
 • 
  
 Wait time
 : This is the amount of time that the requests will spend waiting for 
 other requests that took place earlier to be completed.
  
 Service time
 : This is the amount of time that it takes for the service (unit of 
 work) to be completed.
  
 Transmission time
 : Once the unit of work has been completed, the response 
 will be sent back to the requestor. The time that it takes for the response to be 
 transmitted is known as the transmission time.",NA
Processing speed,"Processing speed (also known as clock rate) refers to the frequency at which a 
  
 processing unit (CPU or GPU) runs. An application contains many units of work. Each 
 unit of work is composed of instructions for the processor; usually, the processors can 
 perform an instruction in each clock tick. Since a few clock ticks are required for an 
 operation to be completed, the higher the clock rate (processing speed), the more 
 instructions will be completed.",NA
Latency,"Latency is a term we can apply to many elements in a system; but when working on 
 web applications, we will use this term to refer to network latency. Network latency 
 indicates any kind of delay that occurs in data communication over the network.
  
 High latency creates bottlenecks in the communication bandwidth. The impact of 
 latency on network bandwidth can be temporary or persistent, based on the root 
 cause of the delays. High latency can be caused by problems in the medium (cables or 
 wireless signals), problems with routers and gateways, and anti-virus, among other 
 things.",NA
Bandwidth,"Just like in the case of latency, whenever we mention bandwidth in this chapter, we will 
 be referring to the network bandwidth. The bandwidth, or data transfer rate, is the 
 amount of data that can be carried from one point to another in a given time. The 
 network bandwidth is usually expressed in bits per second.
  
 [
  168 
 ]",NA
Scalability,"Scalability is the ability of a system to handle a growing amount of work. A system 
 with good scalability will be able to pass some performance tests, such as spike or 
 stress testing.
  
 We will discover more about performance tests (such as spike and stress) later in 
 this chapter.",NA
Performance analysis,"Performance analysis (also known as performance profiling) is the observation and 
 study of resource usage by an application. We will perform profiling in order to 
 identify performance issues in our applications. A different performance profiling 
 process will be carried out for each type of resource using specific tools. We will now 
 take a look at how we can use Google Chrome's developer tools to perform network 
 profiling.",NA
Network performance analysis,"We are going to start by analyzing network performance. Not so long ago, in order to be 
 able to analyze the network performance of an application, we would have had to write 
 a small network logging application ourselves. Today, things are much easier thanks to 
 the arrival of the performance timing API (
 http://www.w3.org/ TR/resource-
 timing/
 ). The performance timing API allows us to access detailed network timing data 
 for each loaded resource.
  
 [
  169 
 ]",NA
Network performance and user experience,"Now that you know how we can analyze network performance, it is time to identify the 
 performance goals we should aim for. Numerous studies have proved that it is really 
 important to keep loading times as low as possible. The Akamai study, published in 
 September 2009, interviewed 1,048 online shoppers and found the following:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 47 percent of people expect a web page to load in two seconds or less 
  
 40 percent will abandon a web page if it takes more than three seconds to load 
 52 percent of online shoppers claim that quick page loads are important for their 
 loyalty to a site 
  
 14 percent will start shopping at a different site if page loads are slow; 23 
 percent will stop shopping or even walk away from their computer 64 percent of 
 shoppers who are dissatisfied with their site visit will go somewhere else to shop 
 next time
  
 [
  174 
 ]",NA
Network performance best practices and rules,"Another easy way to analyze the performance of a web application is by using a best-
 practices tool for network performance, such as the Google PageSpeed Insights 
 application or the Yahoo YSlow application.
  
 Google PageSpeed Insights can be used online or as a Google Chrome extension. To try 
 this tool, you can visit the online version at 
 https://developers.google. 
 com/speed/pagespeed/insights/
  and insert the URL of the web application that 
 you want to analyze. In just a few seconds, you will get a report like the one in the 
 following screenshot:
  
  
 The report contains some effective recommendations that will help us to improve the 
 network performance and overall user experience of our web applications. Google 
 PageSpeed Insights uses the following rules to rate the speed of a web application:
  
 • 
  
 Avoid landing page redirects
  
 • 
  
 Enable compression
  
 [
  176 
 ]",NA
GPU performance analysis,"The rendering of some elements in web applications is accelerated by the use of the 
 GPU. The GPU is specialized in the processing of graphics-related instructions and can, 
 therefore, deliver much better performance than the CPU when it comes to graphics. For 
 example, CSS3 animations in modern web browsers are accelerated by the GPU, while 
 the CPU performs JavaScript animations. In the past, the only way to achieve some 
 animations was via JavaScript. But today, we should avoid using them when possible 
 and use CSS3 instead because it will help us to achieve great web performance.
  
 In recent years, access to the GPU has been added to browsers via the WebGL API. 
 This API allows web developers to create 3D games and other highly visual 
 applications by using the power of the GPU.",NA
Frames per second (FPS),"We will not go into much detail about the performance of 3D applications because it is 
 a really extensive field and we could write an entire book talking about it. However, we 
 will mention an important concept that can be applied to any kind of web application: 
 frames per second
  (
 FPS
 ) or frame rate. When a web application is displayed on 
 screen, it is done at a number of images (frames) per second. A low frame rate can be 
 detrimental to the overall user experience when perceived by the users. A lot of 
 research has been carried out on this topic, and 60 frames per second seems to be the 
 optimum frame rate for a great user experience.
  
 Whenever we develop a web application, we should take a look at the frame rate and try 
 to prevent it from dropping below 40 FPS. This is especially important during animations 
 and user actions.
  
 An open source library called 
 stats.js
  can help us to see the frame rate while 
 developing a web application. This library can be downloaded from GitHub at 
 https://github.com/mrdoob/stats.js/
 . We need to download the library and load 
 it in a web page. We can then load the following code snippet by adding a new file or just 
 execute it in the developer console:
  
 var stats = new Stats();
  
 stats.setMode(1); // 0: fps, 1: ms
  
 // position of the frame rate counter (align top-left)
  
 stats.domElement.style.position = 'absolute';
  
 stats.domElement.style.left = '0px';
  
 stats.domElement.style.top = '0px';
  
 [
  179 
 ]",NA
CPU performance analysis,"To analyze the usage of the processing time, we will take a look at the execution path of 
 our application. We will examine each of the functions invoked and how long it takes to 
 complete their execution. We can access all this information by opening the Chrome 
 developer tools' 
 Profiles
  tab:
  
 [
  180 
 ]",NA
Memory performance analysis,"When we declare a variable, it is allocated in the RAM. Some time after the variable is out 
 of the scope, it is cleared from memory by the garbage collector. Sometimes, we can 
 generate a scenario in which a variable never goes out of scope. If the variable never goes 
 out of scope, it will never be cleared from memory. This can eventually lead to some 
 serious memory leaking issues. A 
 memory leak
  is the continuous loss of available 
 memory.
  
 When dealing with memory leaks, we can take advantage of the Google Chrome 
 developer tools to identify the root cause of the problem with ease.
  
 The first thing that we might wonder is whether our application has memory leaks or not. 
 We can find out by visiting the timeline tab and clicking on the top-left icon to start 
 recording the resource usage. Once we stop recording, a timeline graph like the one in the 
 following screenshot will be displayed:
  
  
 In the timeline, we can select 
 Memory
  to see the memory usage (
 Used JS Heap
 ) over time 
 (the blue line in the image). In the preceding example, we can see a notable drop towards 
 the end of the line. This is a good sign because it indicates that the majority of the used 
 memory has been cleared when the page has finished loading.
  
 The memory leaks can also take place after loading; in that case, we can use the 
 application for a while and observe how the memory usage varies in the graph to 
 identify the cause of the leak.
  
 [
  183 
 ]",NA
The garbage collector,"Programing languages with a low level of abstraction have low-level memory 
 management mechanisms. On the other hand, in languages with a higher level of 
 abstraction, such as C# or JavaScript, the memory is automatically allocated and 
 freed by a process known as the garbage collector.
  
 The JavaScript garbage collector does a great job when it comes to memory 
 management, but it doesn't mean that we don't need to care about memory 
 management.
  
 [
  185 
 ]",NA
Performance automation,"In this section we will understand how we can automate many of the performance 
 optimization tasks, from concatenation and compression of contents to the automation 
 of the performance monitoring and performance testing processes.
  
 [
  186 
 ]",NA
Performance optimization automation,"After analyzing the performance of our application, we will start working on 
 some performance optimizations. Many of these optimizations involve the 
 concatenation and compression of some of the application's components. 
  
 The problem with compressed components is that they are more complicated to debug 
 and maintain. We will also have to create a new version of the concatenated and 
 compressed contents every time one of the original components (not 
  
 concatenated and not compressed) changes. As these include many highly repetitive 
 tasks, we can use the task runner Gulp to perform many of these tasks for us. We can 
 find online plugins that will allow us to concatenate and compress components, 
 optimize images, generate a cache manifest, and perform many other performance 
 optimization tasks.
  
  
 If you would like to learn more about Gulp, refer to 
  
  
 Chapter 2
 , 
 Automating Your Development Workflow
 .",NA
Performance monitoring automation,"We have seen that we can automate many of the performance optimization tasks using 
 the Gulp task runner. In a similar way, we can also automate the performance 
 monitoring process.
  
 In order to monitor the performance of an existing application, we will need to 
 collect some data that will allow us to compare the application performance over 
 time. Depending on how we collect the data, we can identify three different types of 
 performance monitoring:
  
 • 
  
 • 
  
 • 
  
 Real user monitoring
  (
 RUM
 ): This is a type of solution used to capture 
 performance data from real user visits. The collection of data is performed by a 
 small JavaScript code snippet loaded in the browser. This type of solution can 
 help us to collect data and discover performance trends and patterns.
  
 Simulated browsers
 : This type of solution is used to capture performance data 
 from simulated browsers. This is the most economic option, but it is limited 
 because simulated browsers cannot offer as accurate a representation of the real 
 user experience.
  
 Real-browser monitoring
 : This is used to capture the performance data of 
 real browsers. This information provides a more accurate representation of the 
 real user experience, as the data is collected using exactly what a user would 
 see if they visited the site with the given environment (browser, geographic 
 location, and network throughput).
  
 [
  187 
 ]",NA
Performance testing automation,"Another way to improve the performance of an application is to write automated 
 performance tests. These tests can be used to guarantee that the system meets a set of 
 performance goals. There are multiple types of performance testing, but some of the 
 most common ones include the following:
  
 • 
  
 Load testing
 : This is the most basic form of performance testing. We can use a 
 load test to understand the behavior of the system under a specific expected load 
 (number of concurrent users, number of transactions, and duration). 
  
 There are multiple types of load testing:
  
 [
  188 
 ]",NA
Exception handling,"Understanding how to use the available resources in an efficient manner will help us 
 to create better applications. In a similar manner, understanding how to handle 
 runtime errors will help us to improve the overall quality of our applications. 
 Exception handling in TypeScript involves three main language elements.",NA
The Error class,"When a runtime error takes place, an instance of the 
 Error
  class is thrown:
  
 throw new Error();
  
 [
  189 
 ]",NA
The try…catch statements and throw ,NA,NA
statements,"A 
 catch
  clause contains statements that specify what to do if an exception is thrown in 
 the 
 try
  block. We should perform some operations in the 
 try
  block, and if they fail, the 
 program execution flow will move from the 
 try
  block to the 
 catch
  block.
  
 [
  190 
 ]",NA
Summary,"In this chapter, we saw what performance is and how the availability of resources can 
 influence it. We also looked at how to use some tools to analyze the way a TypeScript 
 application uses available resources. These tools allow us to spot some possible issues, 
 such as a low frame rate, memory leaks, and high loading times. We have also 
 discovered that we can automate many kinds of performance optimization task, as well 
 as the performance monitoring and testing processes.
  
 In the following chapter, we will see how we can automate the testing process of our 
 TypeScript applications to achieve great application maintainability and reliability.
  
 [
  191 
 ]",NA
Application Testing,"In this chapter, we are going to take a look at how to write unit tests for TypeScript 
  
 applications. We will see how to use tools and frameworks to facilitate the testing 
  
 process of our applications.
  
 The contents of this chapter cover the following topics:
  
 • 
  
 Setting up a test infrastructure
  
 • 
  
 Testing planning and methodologies
  
 • 
  
 How to work with Mocha, Chai, and Sinon.JS
  
 • 
  
 How to work with test assertions, specs, and suites
  
 • 
  
 Test spies
  
 • 
  
 Test stubs
  
 • 
  
 Testing on multiple environments
  
 • 
  
 How to work with Karma and PhantomJS
  
 • 
  
 End-to-end testing
  
 • 
  
 Generating test coverage reports
  
 We will get started by installing some necessary third-party software dependencies.
  
 [
  193 
 ]",NA
Software testing glossary ,"Across this chapter, we will use some concepts that may not be familiar to those 
 readers without previous software testing experience. Let's take a quick look at 
 some of the most popular testing concepts before we get started.",NA
Assertions ,"An 
 assertion
  is a condition that must be tested to confirm that a certain piece of code 
 behaves as expected or, in other words, to confirm conformance to a requirement.
  
 Let's imagine that we are working as part of one of the Google Chrome development 
 team and we have to implement the JavaScript 
 Math
  object. If we are working on the 
 pow
  
 method, the requirement could be something like the following:
  
 ""The Math.pow(base, exponent) function should return the base (the base 
 number) to the exponent (the exponent used to raise the base power—that is, 
 base ^ exponent).""
  
 With this information, we could create the following implementation:
  
 class Math1 {
  
  
  public static pow(base: number, exponent: number) {
  
  var result = base;
  
  
  for(var i = 1; i < exponent; i++){
  
    
  result = result * base;
  
  
  }
  
  
  return result;
  
  
  } 
  
 }
  
 To ensure that the method is correctly implemented, we must test it conforms with the 
 requirement. If we analyze the requirements closely, we should identify at least two 
 necessary assertions.
  
 The function should return the base to the exponent:
  
 var actual = Math1.pow(3,5); 
  
 var expected = 243; 
  
 var asertion1 = (Math1.pow(base1, exponent1) === expected1);
  
 The exponent is not used as the base (or the base is not used as the exponent):
  
 var actual = Math1.pow(5,3); 
  
 var expected = 125; 
  
 var asertion2 = (Math1.pow(base2, exponent2) === expected2);
  
 [
  194 
 ]",NA
Specs,"Spec
  is a term used by software development engineers to refer to test specifications. A 
 test specification (not to be confused with a test plan) is a detailed list of all the scenarios 
 that should be tested, how they should be tested, and so on. We will see later in this 
 chapter how we can use a testing framework to define a test spec.",NA
Test cases,"A 
 test case
  is a set of conditions used to determine whether one of the features of an 
 application is working as it was originally established to work. We might wonder what 
 the difference between a test assertion and a test case is. While a test assertion is a 
 single condition, a test case is a set of conditions. We will see later in this chapter how 
 we can use a testing framework to define test cases.",NA
Suites,"A 
 suite
  is a collection of test cases. While a test case should focus on only one test 
 scenario, a test suite can contain test cases for many test scenarios.",NA
Spies,"Spies
  are a feature provided by some testing frameworks. They allow us to wrap a 
 method and record its usage (input, output, number of times invoked). When we wrap 
 a function with a spy, the underlying method's functionality does not change.",NA
Dummies,"A 
 dummy
  object is an object that is passed around during the execution of a test but is 
 never actually used.",NA
Stubs,"A 
 stub
  is a feature provided by some testing frameworks. Stubs also allow us to wrap a 
 method to observe its usage. Unlike spies, when we wrap a function with a stub, the 
 underlying method's functionality is replaced with a new behavior.
  
 [
  195 
 ]",NA
Mocks,"Mocks are often confused with stubs. Martin Fowler once wrote the following in an 
 article titled Mocks Aren't Stubs:
  
 In particular I see them often (mocks) confused with stubs - a common helper 
 to testing environments. I understand this confusion - I saw them as similar for 
 a while too, but conversations with the mock developers have steadily allowed 
 a little mock understanding to penetrate my tortoiseshell cranium. This 
 difference is actually two separate differences. On the one hand there is a 
 difference in how test results are verified: a distinction between state 
 verification and behavior verification. On the other hand is a whole different 
 philosophy to the way testing and design play together, which I term here as 
 the classical and mockist styles of Test Driven Development.
  
 Both mocks and stubs provide some sort of input to the test case; but, despite their 
 similarities, the flow of information from each is very different:
  
 • 
  
 • 
  
 Stubs provide input for the application under test so that the test can be 
 performed on something else
  
 Mocks provide input to the test to decide whether the test should pass or fail
  
 The difference between mocks and stubs will become clearer as we move towards the 
 end of this chapter.",NA
Test coverage,"The term test coverage refers to a unit of measurement, which is used to illustrate the 
 number of portions of code in an application that have been tested via automated tests. 
 Test coverage can be obtained by automatically generating test coverage reports. 
 Towards the end of the chapter, we will see how to create such reports using a tool called 
 Istanbul (
 http://gotwarlost.github.io/istanbul/
 ).",NA
Prerequisites,"Throughout this chapter, we will use some third-party tools, including some 
 frameworks and automation tools. We will start by looking at each tool in detail. 
 Before we get started, we need to use npm to create a 
 package.json
  file in the 
 folder that we are going to use to implement the examples in this chapter.
  
 Let's create a new folder named app and run the 
 npm init
  command inside it to 
 generate a new 
 package.json
  file:
  
 npm init
  
 [
  196 
 ]",NA
Gulp,"We will use the Gulp task runner to run some tasks necessary to execute our tests. We 
 can install Gulp using npm:
  
 npm install gulp -g
  
  
 If you are not familiar with task runners and continuous 
  
  
 integration build servers, take a look at 
 Chapter 2
 , 
 Automating 
  
 Your Development Workflow
 .",NA
Karma,"Karma is a test runner. We will use Karma to automatically execute our tests. This is 
 useful because sometimes the execution of the test will not be started by one of the 
 members of our software development team. Instead, it will be triggered by a 
 continuous integration build server (usually via a task runner).
  
 Karma can be used with multiple testing frameworks, thanks to the installation of 
 plugins. Let's install Karma using the following command:
  
 npm install --save-dev karma
  
 We will also install another Karma plugin that facilitates the creation of test 
 coverage reports:
  
 npm install --save-dev karma-coverage",NA
Istanbul,"Istanbul is a tool that identifies which lines of our application are processed during the 
 execution of the automated test. It can generate reports known as test coverage reports. 
 These reports can help us to get an idea of the level of testing of a project because they 
 show which lines of code were not executed and a percentage value that represents the 
 fraction of the application that has been tested. It is recommended that a test coverage 
 value of at least 75 percent of the overall application should be achieved, while many 
 open source projects target a test coverage of 100 percent.
  
 [
  197 
 ]",NA
Mocha,"Mocha is a popular JavaScript testing library that facilitates the creation of test suites, test 
 cases, and test specs. Mocha can be used to test TypeScript in the frontend and backend, 
 identify performance issues, and generate different types of test reports, among many 
 other features.
  
 Let's install Mocha and the Karma-Mocha plugin using the following command:
  
 npm install --save-dev mocha karma-mocha",NA
Chai,"Chai is a test assertion library that supports 
 test-driven development
  (
 TDD
 ) and 
 behavior-driven development
  (
 BDD
 ) test styles.
  
  
 We will see more about TDD and BDD later in this chapter.
  
  
 The main goal of Chai is to reduce the amount of work necessary to create a test 
 assertion and make the test more readable.
  
 We can install Chai and the Karma-Chai plugin using the following command:
  
 npm install --save-dev chai karma-chai",NA
Sinon.JS,"Sinon.JS is an isolation framework that provides us with a set of APIs (test spies, stubs, 
 and mocks) that can help us to test a component in isolation. Testing isolated software 
 components is difficult because there is a high level of coupling between the components. 
 A mocking library such as Sinon.JS can help us isolate the components in order to test 
 individual features.
  
 We can install Sinon.JS and the Karma-Sinon plugin using the following command:
  
 npm install --save-dev sinon karma-sinon",NA
Type definitions,"To be able to work with third-party libraries in JavaScript with a good support, we 
 need to import the type definitions of each library. We will use the 
 tsd
  package 
 manager to install the necessary type definitions:
  
 tsd install mocha --save
  
 [
  198 
 ]",NA
PhantomJS,"PhantomJS is a headless browser. We can use PhantomJS to run our tests in a browser 
 without having to actually open a browser. Being able to do this is useful for a few 
 reasons; the main one is that PhantomJS can be executed via a command interface, and it 
 is really easy to integrate with task runners and continuous integration servers. The 
 second reason is that not having to open a browser potentially reduces the time 
 required to complete the execution of the tests suites.
  
 We need to install the Karma plugin that will run the test in PhantomJS:
  
 npm install --save-dev phantomjs
  
 npm install --save-dev karma-phantomjs-launcher",NA
Selenium and Nightwatch.js,"Selenium is a test runner but it was especially designed to run a particular type of 
 test known as an 
 end-to-end
  (
 E2E
 ) test.
  
  
 We will learn more about E2E testing later on this chapter, so 
  
  
 we don't need to worry too much about this topic for now.
  
 Though we will see how to use selenium towards the end of the chapter, we can install it 
 now. We will not work with Selenium directly because we are going to use another tool 
 (known as Nightwatch.js) for E2E testing, which will automatically run Selenium for us.
  
 Nightwatch.js is an automated testing framework, written in Node.js for web 
 applications and websites, which uses the Selenium WebDriver API. It is a complete 
 browser automation (end-to-end) solution. 
  
 [
  199 
 ]",NA
Testing planning and methodologies,"When it comes to software development, we usually have many choices. Every time we 
 have to develop a new application, we can choose the type of database, the architecture, 
 and frameworks that we will use. Not all our choices are about technologies. For example, 
 we can also choose a software development methodology such as extreme programming 
 or scrum. When it comes to testing, there are two major styles or methodologies: test-
 driven development (TDD) and behavior-driven development (BDD).",NA
Test-driven development,"Test-driven development is a testing methodology that focuses on encouraging 
 developers to write tests before they write application code. Usually, the process of 
 writing code in TDD consists of the following basic steps:
  
 1. Write a test that fails.
  
 2. Run the test and ensure that it fails (there is no code at this point so it 
  
 should fail).
  
 3. Write the code to make the test pass.
  
 4. Run the test and ensure that it passes.
  
 5. Run all the other tests to ensure that no other parts of the application break.
  
 6. Repeat the process.
  
 The difference between using TDD or not is really a mindset. Many developers don't like 
 writing tests, so chances are that' if we leave their implementation as the last task in the 
 development process, the tests will not implemented or the application will just be 
 partially tested.
  
 [
  200 
 ]",NA
Behavior-driven development (BDD),"Behavior-driven development appeared after TDD with the mission of being a 
 refined version of TDD. BDD focuses on the way tests are described (specs) and 
 states that the tests should focus on the application requirements and not the test 
 requirements. Ideally, this will encourage developers to think less about the tests 
 themselves and more about the application as a whole.
  
  
 The original article in which the BDD principles were 
  
  
 introduced for the first time by 
 Dan North
  is available 
  
 online at 
 http://dannorth.net/introducing-bdd/
 .
  
 As we have already seen, Mocha and Chai provide APIs for the TDD and BDD 
 approaches. Later in this chapter, we will further explore these two approaches.
  
 Recommending one of these methodologies is not trivial because TDD and BDD are 
 both really good testing methodologies. However, BDD was developed after TDD with 
 the objective to improve it, so we can argue that BDD has some additional advantages 
 over TDD. In BDD, the description of a test focuses on what the application should do 
 and not what the test code is testing. This can help the developers to identify tests that 
 reflect the behavior desired by the customer. BDD tests are then used to document the 
 requirements of a system in a way that can be understood and validated by both the 
 developer and the customer. On the other hand, TDD tests cannot be understood with 
 ease by the customer.",NA
Tests plans and test types,"The term test plan is sometimes incorrectly used to refer to a test specification. 
 While tests specifications define the scenarios that will be tested and how they 
 will be tested, the test plan is a collection of all the test specs for a given area.
  
 It is recommended to create an actual planning document because a test plan can 
 involve many processes, documents, and practices. One of the main goals of a test 
 plan is to identify and define what kind of test is adequate for a particular 
 component or set of components in an application.
  
 [
  201 
 ]",NA
Setting up a test infrastructure ,"As we saw previously in this chapter when we talked about unit tests, usually, 
 testing requires being able to isolate the individual software component of our 
 applications.
  
 In order to be able to isolate the components of our application, we will need to 
 adhere to some principles (such as the dependency inversion principle) that will help 
 us to increase the level of decoupling between the components.
  
 We will now configure a testing environment using Gulp and Karma and write some 
 automated test using Mocha and Chai. By the end of this chapter, we will know how 
 writing unit tests can help us to increase the level of decoupling and isolation between 
 the components of an application, and how they can lead us to the development of 
 great applications, especially when it comes to maintainability and reliability.
  
 Let's get started by creating the folder structure of a new application. We will create two 
 folders inside the app folder that we created at the beginning of this chapter.
  
 Let's name the first folder 
 source
  and the second folder 
 test
 . Here, we can see how our 
 directory tree should look by the end of the chapter:
  
 ├──app
  
  ├── gulpfile.js
  
  ├── index.html
  
  ├── karma.conf.js
  
  ├── nightwatch.json
  
  ├── package.json
  
  ├── source
  
  │   ├── calculator_widget.ts
  
  │   ├── demos.ts
  
  │   ├── interfaces.d.ts
  
  │   ├── math_demo.ts
  
  ├── style
  
  │   └── demo.css
  
  ├── test
  
  │   ├── bdd.test.ts
  
  │   ├── e2e.test.ts
  
  │   ├── tdd.test.ts
  
  ├── tsd.json
  
  └── typings
  
 We are going to develop a really small application to be able to write a unit test. We are 
 going to write a unit test and an end-to-end test.
  
 [
  203 
 ]",NA
Building the application with Gulp ,"We will get started by creating a new 
 gulpfile.js
  file as we did in 
 Chapter 2
 , 
 Automating Your Development Workflow
 . The first thing that we are going to do is 
 import all the necessary node modules:
  
 var gulp        = require(""gulp""),
  
  browserify  = require(""browserify""),
  
  source      = require(""vinyl-source-stream""),
  
  buffer      = require(""vinyl-buffer""),
  
  run         = require(""gulp-run""),
  
  nightwatch  = require('gulp-nightwatch'),
  
  tslint      = require(""gulp-tslint""),
  
  tsc         = require(""gulp-typescript""),
  
  browserSync = require('browser-sync'),
  
  karma       = require(""karma"").server,
  
  uglify      = require(""gulp-uglify""),
  
  docco       = require(""gulp-docco""),
  
  runSequence = require(""run-sequence""),
  
  header      = require(""gulp-header""),
  
  pkg         = require(__dirname + ""/package.json"");
  
  
 Remember that we need to install all necessary packages by using the 
  
  
 npm package manager. We can take a look at the 
 package.json
  file 
  
 to see all the dependencies and their respective versions.
  
 [
  204 
 ]",NA
Running the unit test with Karma ,"We have already covered the basics of Karma in 
 Chapter 2
 , 
 Automating Your 
 Development Workflow
 . We are going to create a task to execute Karma:
  
 gulp.task(""run-unit-test"", function(cb) {
  
  
  karma.start({
  
  
  configFile : __dirname + ""/karma.conf.js"",
  
  singleRun: true
  
  
  }, cb); 
  
 });
  
 [
  207 
 ]",NA
Running E2E tests with Selenium and ,NA,NA
Nightwatch.js,"Karma (in combination with Mocha, Chai, and Sinon.JS) is a great tool when it comes to 
 writing and executing unit tests and partial integration tests. However, Karma is not the 
 best tool when it comes to writing E2E tests. For this reason, we will write a collection of 
 E2E tests that will be written and executed using a separate set of tools: Selenium and 
 Nightwatch.js.
  
 To configure Nightwatch.js, we will start by creating a new Gulp task that will be in 
 charge of the execution of the E2E tests. We only need to specify the location of an 
 external configuration file named Nightwatch.js:
  
 gulp.task('run-e2e-test', function(){
  
  return gulp.src('')
  
  .pipe(nightwatch({
  
  configFile: __dirname + '/nightwatch.json'
  
  }));
  
 });
  
 [
  210 
 ]",NA
"Creating test assertions, specs, and ",NA,NA
suites with Mocha and Chai,"Now that the test infrastructure is ready, we will start writing a unit test. We need to 
 remember that we are going to follow the BDD development testing style, which 
 means that we will write the test before we actually write the code.
  
 We will write a web calculator; because we want to keep it simple, we will only 
 implement one of its features. After doing some analysis, we have come up with a 
 design interface that will help us to understand the requirements. We will declare the 
 following interface in the 
 interfaces.d.ts
  file:
  
 interface MathInterface {
  
  PI : number;
  
  pow( base: number, exponent: number);
  
 }
  
 As we can see, the calculator will allow us to calculate the exponent of a number and to 
 get the number 
 PI
 . Now that we know the requirements, we can start writing some unit 
 tests. Let's create a file named 
 bdd.test.ts
  and add the following code:
  
 ///<reference path=""../typings/tsd.d.ts"" />
  
 ///<reference path=""../source/interfaces.d.ts"" />
  
 [
  213 
 ]",NA
Testing the asynchronous code ,"In 
 Chapter 3
 , 
 Working with Functions
 , we learned how to work with a synchronous code; 
 and in 
 Chapter 6
 , 
 Application Performance
 , we saw that using asynchronous code is one 
 of the golden rules of web application performance. We should aim to write 
 asynchronous code as much as we can, and for this reason, it is important to learn how 
 to test asynchronous code.
  
 Let's write an asynchronous version of the 
 pow
  function to demonstrate how we 
 can test an asynchronous function. We will start with the requirements:
  
 interface MathInterface {
  
  
  // ..
  
   
 powAsync(base: number, exponent: number, cb : (result : number) 
  
  => void); 
  
 }
  
 We need to implement a function named 
 powAsync
 , which takes two numeric values as 
 parameters (just like before) and a callback function. The test for the asynchronous 
 version is almost identical to the test that we wrote for the synchronous function:
  
  it('should return the correct numeric value for pow (async) \n',   
 (
 done
 ) => {
  
  var math : MathInterface = new MathDemo();
  
  math.powAsync(3, 5, function(result) {
  
  
  var expected = 243;
  
  
  expect(result).to.be.a('number');
  
  
  expect(result).to.equal(expected); 
  
    
 done();
  // invoke done() inside your call back or fulfilled 
  
  promises
  
  });
  
  });
  
 The main thing that we need to notice is that, this time, the callback passed to the 
 it 
 method receives an argument named 
 done
 . The argument is a function that we need to 
 execute to indicate that the test execution is finished.
  
 [
  217 
 ]",NA
Asserting exceptions,"Asserting the types or values of variables is straightforward, as we have been able to 
 explore in the previous examples; but there is one scenario that perhaps is not as 
 intuitive as the previous one. This scenario is testing for an exception.
  
 Let's add a new method to the 
 MathInterface
  interface with the only purpose of 
 illustrating how to test for an exception:
  
 interface MathInterface {
  
  
  // ...
  
  
  bad(foo? : any) : void; 
  
 }
  
 The 
 bad
  method throws an exception when it is invoked with a non-numeric 
 argument:
  
 public bad(foo? : any) {
  
  
  if(isNaN(foo)){
  
  
  throw new Error(""Error!"");
  
  
  }
  
  
  else {
  
  
  //...
  
  
  } 
  
 }
  
 [
  218 
 ]",NA
TDD versus BDD with Mocha and Chai,"TDD and BDD follow many of the same principles but have some differences in their 
 style. While these two styles provide the same functionality, BDD is considered to be 
 easier to read by many of the members of a software development team (not just 
 developers).
  
 The following table compares the naming and style of suites, tests, and assertions 
 between the TDD and BBD styles:
  
 TDD
  
 BDD
  
 suite
  
 describe
  
 setup
  
 before
  
 teardown
  
 after
  
 suiteSetup
  
 beforeEach
  
 suiteTeardown
  
 afterEach
  
 test
  
 it
  
 assert.equal(math.PI, 
 3.14159265359);
  
 expect(math.PI).to.equals(3.14159265359);
  
  
  
 In the companion code samples, you will find all the examples 
  
  
 in this chapter following both the TDD and BDD styles.
  
 [
  219 
 ]",NA
Test spies and stubs with Sinon.JS,"We have been working on the 
 MathDemo
  class. We have implemented and tested its 
 features using unit tests and assertions. Now we are going to create a little web 
 widget that will internally use the 
 MathDemo
  class to perform a mathematical 
 operation. We can think of this new class as a graphical user interface for the 
 MathDemo
  class. We need the following HTML:
  
 <div id=""widget"">
  
  <input type=""text"" id=""base"" />
  
  <input type=""text"" id=""exponent"" />
  
  <input type=""text"" id=""result"" />
  
  <button id=""submit"" type=""submit"">Submit</button>
  
 </div>
  
  
 In the companion code, the HTML code contains more attributes, 
  
  
 such as CSS classes; but they been have removed here for clarity.
  
 Let's create a file named 
 calculator_widget.ts
  under the source directory. We are 
 going to store the HTML code in a string variable located in the scope of the web widget. 
 The new class will be called 
 CalculatorWidget
 , and it will implement the 
 CalculatorWidgetInterface
  interface:
  
 interface CalculatorWidgetInterface {
  
  render(id : string);
  
  onSubmit() : void;
  
 }
  
 We should write the unit test before we implement the 
 CalculatorWidget
  class, but 
 this time we will break the BDD rules in an attempt to facilitate the understanding of 
 stubs and spies:
  
 ///<reference path=""./interfaces.d.ts"" />
  
 ///<reference path=""../typings/tsd.d.ts"" />
  
 var template = 'HTML...';
  
 class CalculatorWidget implements CalculatorWidgetInterface{
  
  private _math : MathInterface;
  
  private $base: JQuery;
  
  private $exponent: JQuery;
  
  private $result: JQuery;
  
  private $btn: JQuery;
  
 [
  220 
 ]",NA
Spies,"We are going to start by taking a look at the use of spies by creating a new test suite. 
 This time we will use the 
 before()
  and 
 beforeEach()
  functions. When the 
 before()
  function is invoked (before any unit test is executed), a new HTML node is 
 created to hold the widget's HTML.
  
 The 
 beforeEach()
  function is used to reset the container before each test. 
  
 This way, we can ensure that a new widget is created for each test in the test suite. 
 This is a good idea because it will prevent one test from potentially affecting the 
 results of another.
  
 describe('BDD test example for CalculatorWidget class \n', () => {
  
  before(function() {
  
  $(""body"").append('<div id=""widget""/>');
  
  });
  
 [
  223 
 ]",NA
Stubs,"It may look like we have already tested the entire application by now, but that is 
 usually never the case. Let's analyze what exactly we have tested so far:
  
 • 
  
 • 
  
 • 
  
 We have tested the entire 
 MathDemo
  class, and we know that it returns the 
 correct value when 
 pow
  is invoked
  
 We know that the 
 CalculatorWidget
  class is rendering the HTML correctly
  
 We know that the 
 CalculatorWidget
  class is setting up some events and 
 reading some values from the HTML inputs as expected
  
 So far, we have created some tests for the 
 MathDemo
  class and the 
 CalculatorWidget 
 class, but we have forgotten to test the integration between them.
  
 We have been testing using 
 2
  as base and 
 3
  as exponent, but if we wrongly used the 
 same value as base and exponent, we could have missed one potential issue: maybe 
 the 
 CalculatorWidget
  class is passing the arguments in incorrect order to the 
 MathDemo
  class when the function 
 pow()
  is invoked in the body of the 
 onSubmit()
  
 function.
  
  
 Later on in this chapter, we will see how to generate a kind 
  
  
 of report (a test coverage report) that can help us to identify 
  
 areas of our application that have not been tested.
  
 We can test this scenario by isolating the 
 CalculatorWidget
  class from its 
 dependency on the 
 MathDemo
  class. We can achieve this by using a stub. Let's 
 take a look at the upcoming unit tests to see a stub in action.
  
 [
  225 
 ]",NA
Creating end-to-end tests with ,NA,NA
Nightwatch.js ,"Writing an E2E test with Nightwatch.js is an intuitive process. We should be able to 
 read an E2E test and be able to understand it even if it is the first time that we 
 encounter one.
  
 If we take a look at the following code snippet, we will see that, once we have 
 reached the page, the test will wait 1 second for the body of the page to be visible. 
 The test will then wait 0.1 seconds for some elements to be visible. The elements can 
 be selected using CSS selectors or XPath syntax. If the elements are visible, the 
 setValue
  method will insert 
 2
  in the text input with base as ID and 
 3
  in the text 
 input with exponent as ID:
  
 var test = {
  
  
  'Calculator pow e2e test example' : function (client) {
  
  client
  
    
  .url('http://localhost:8080/')
  
    
  .waitForElementVisible('body', 1000)
  
    
  .assert.waitForElementVisible('TypeScriptTesting', 100)
    
  .assert.waitForElementVisible('input#base' ,100)
  
    
  .assert.waitForElementVisible('input#exponent', 100)
    
  .setValue('input#base', '2')
  
    
  .setValue('input#exponent', '3')
  
    
  .click('button#submit')
  
    
  .pause(100)
  
    
  .assert.value('input#result', '8')
  
    
  .end();
  
  
  } 
  
 };
  
 export = test;
  
 The test will then find the submit button and trigger an on-click event. After 0.1 seconds, 
 the test asserts that the correct value has been inserted into the text input with result as 
 ID. We can see each of these steps in the console during the test execution.
  
 We can run the tests using the following command:
  
 gulp run-e2e-test
  
  
 Remember that we must run the tasks to compile and bundle the E2E 
  
  
 tests as well as run the application in a web server with BrowserSync 
  
 and execute Selenium before being able to run E2E tests.
  
 [
  227 
 ]",NA
Generating test coverage reports ,"Earlier in in this chapter, when we configured Karma, we added some settings to 
 generate test coverage reports. Let's take a look at the 
 karma.conf.js
  file to 
 identify test coverage-related configuration:
  
 module.exports = function (config) {
  
  
  'use strict';
  
  config.set({
  
  basePath: '',
  
  frameworks: ['mocha', 'chai', 'sinon'],
  
  browsers: ['PhantomJS'],
  
  reporters: ['progress', 
 'coverage'
 ],
  
  coverageReporter: {
  
  
  
  type : 'lcov',
  
  
  
  dir : __dirname + '/coverage/'
  
  },
  
  plugins : [ 
  
  
  
 'karma-coverage'
 ,
  
  
  
  'karma-mocha',
  
  
  
  'karma-chai',
  
  
  
  'karma-sinon',
  
  
  
  'karma-phantomjs-launcher'
  
  ],
  
  preprocessors: {
  
  
  
  '**/bundled/test/bdd.test.js' : 'coverage'
  
  },
  
  files : [
  
  
  
  {
  
  
   
  pattern: ""/bundled/test/bdd.test.js"",
  
  
   
  included: true
  
  
  
  },
  
  
  
  {
  
  
   
  pattern: ""/node_modules/jquery/dist/jquery.min.js"",
  
   
  included: true
  
  
  
  },
  
  
  
  {
  
  
   
  pattern:  
  
  
   
  ""/node_modules/bootstrap/dist/js/bootstrap.min.js"",
  
   
  included: true
  
  
  
  }
  
  ],
  
  client : {
  
  
  
  mocha : {
  
  
   
  ui : ""bdd""
  
  
  
  }
  
  },
  
 [
  228 
 ]",NA
Summary,"In this chapter, we discussed some core testing concepts (including stubs, spies, 
 suites, and more). We also looked at the test-driven development and behavior-
 driven development approaches and how to work with some of the leading 
 JavaScript testing frameworks, such as Mocha, Chai, Sinon.JS, Karma, Selenium, 
 and Nightwatch.js.
  
 Towards the end of the chapter we explored how to test across multiple devices 
 and how to generate test coverage reports.
  
 In the next chapter, we will look at decorators and the metadata reflection API— two 
 exciting new features introduced by TypeScript 1.5.
  
 [
  230 
 ]",NA
Decorators,"In this chapter, you are going to learn about annotations and decorators—the two new 
 features based on the future ECMAScript 6 specification, but we can use them today 
 with TypeScript 1.5.
  
 You will learn about the following topics:
  
 • 
  
 Annotations and decorators:
  
  
  
 °
  
 Class decorators
  
  
  
 °
  
 Method decorators
  
  
  
 °
  
 Property decorators
  
  
  
 °
  
 Parameter decorators
  
  
  
 °
  
 Decorator factory
  
  
  
 °
  
 Decorators with parameters
  
 • 
  
 The reflection metadata API",NA
Prerequisites ,"The TypeScript features in this chapter require TypeScript 1.5 or higher. We can use 
 Gulp as we have done in previous chapters, but we need to ensure that the latest 
 version of TypeScript is used by the 
 gulp-typescript
  package. Let's start by 
 creating a 
 package.json
  file and installing the required packages:
  
 npm init
  
 npm install --save-dev gulp gulp-typescript typescript
  
 npm install --save reflect-metadata
  
 [
  231 
 ]",NA
Annotations and decorators ,"Annotations are a way to add metadata to class declarations. The metadata can then be 
 used by tools such as dependency injection containers.
  
 The annotations API was proposed by the Google AtScript team but annotations are not 
 a standard. However, decorators are a proposed standard for ECMAScript 7 by Yehuda 
 Katz, to annotate and modify classes and properties at design time.
  
 [
  232 
 ]",NA
The class decorators,"The official TypeScript decorator proposal defines a class decorator as follows:
  
 A class decorator function is a function that accepts a constructor function as 
 its argument, and returns either undefined, the provided constructor 
 function, or a new constructor function. Returning undefined is equivalent to 
 returning the provided constructor function.
  
  -  ""Decorators Proposal – TypeScript"" by Ron Buckton
  
 [
  233 
 ]",NA
The method decorators,"The official TypeScript decorator proposal defines a method decorator as follows.
  
 A method decorator function is a function that accepts three arguments: 
  
 The object that owns the property, the key for the property (a string or a 
 symbol), and optionally the property descriptor of the property. The function 
 must return either undefined, the provided property descriptor, or a new 
 property descriptor. Returning undefined is equivalent to returning the 
 provided property descriptor.
  
 -  ""Decorators Proposal – TypeScript"" by Ron Buckton
  
 The method decorator is really similar to the class decorator but it is used to override a 
 method, as opposed to using it to override the constructor of a class.
  
 If the method decorator returns a value different from undefined, the returned value 
 will be used to override the property descriptor of the method.
  
  
 Note that a property descriptor is an object that can be obtained by 
  
  
 invoking the 
 Object.getOwnPropertyDescriptor()
  method.
  
 Let's declare a method decorator named 
 logMethod
  without any behavior for now:
  
 function logMethod(target: any, key: string, descriptor: any) {
  
  // ...
  
 }
  
 [
  236 
 ]",NA
The property decorators,"The official TypeScript decorator proposal defines a property decorator as follows:
  
 A property decorator function is a function that accepts two arguments: The 
 object that owns the property and the key for the property (a string or a symbol). 
 A property decorator does not return.
  
 -  ""Decorators Proposal – TypeScript"" by Ron Buckton
  
 A property decorator is really similar to a method decorator. The main differences are 
 that a property decorator doesn't return a value and that the third parameter (the 
 property descriptor) is not passed to the property decorator.
  
 Let's create a property decorator named 
 logProperty
  to see how it works:
  
 function logProperty(target: any, key: string) {
  
  // ...
  
 }
  
 We can use it in one of the 
 Person
  class's properties as follows:
  
 class Person { 
  
  @logProperty
  
  public name: string;
  
  // ...
  
 [
  238 
 ]",NA
The parameter decorators ,"The official decorator proposal defines a parameter decorator as follows:
  
 A parameter decorator function is a function that accepts three arguments: The 
 object that owns the method that contains the decorated parameter, the property 
 key of the property (or undefined for a parameter of the constructor), and the 
 ordinal index of the parameter. The return value of this decorator is ignored.
  
 Decorators Proposal – TypeScript"" by Ron Buckton
  
 Let's create a parameter decorator named 
 addMetadata
  to see how it works:
  
 function addMetadata(target: any, key : string, index : number) {
  
  // ...
  
 }
  
 We can apply the property decorator to a parameter as follows:
  
 public saySomething(@addMetadatasomething : string) : string {
  
  
 return this.name + "" "" + this.surname + "" says: "" + something; }
  
 The parameter decorator doesn't return, which means that we will not be able to 
 override the method that contains the parameter being decorated.
  
 We can use parameter decorators to add some metadata to the prototype (
 target
 ) 
 class. In the following implementation, we will add an array named 
 log_${key}_ 
 parameters
  as a class property where 
 key
  is the name of the method that contains the 
 parameter being decorated:
  
 function addMetadata(target: any, key : string, index : number) {
  
  var metadataKey = `_log_${key}_parameters`;
  
  
  if (Array.isArray(target[metadataKey])) {
  
  
  target[metadataKey].push(index);
  
  
  }
  
 [
  240 
 ]",NA
The decorator factory,"The official decorator proposal defines a decorator factory as follows:
  
 A decorator factory is a function that can accept any number of arguments, 
 and must return one of the above types of decorator function.
  
 Decorators Proposal – TypeScript"" by Ron Buckton
  
 You learned to implement class, property, method, and parameter decorators. In the 
 majority of cases, we will consume decorators, not implement them. For example, in 
 Angular 2.0, we will use an 
 @view
  decorator to declare that a class will behave as a View, 
 but we will not implement the 
 @view
  decorator ourselves.
  
 We can use the decorator factory to make decorators easier to consume. Let's 
 consider the following code snippet:
  
 @logClass
  
 class Person {
  
 @logProperty
  
  public name: string;
  
 [
  242 
 ]",NA
Decorators with arguments ,"We can use a special kind of decorator factory to allow developers to configure the 
 behavior of a decorator. For example, we could pass a string to a class decorator as 
 follows:
  
 @logClass(""option"") 
  
 class Person { 
  
 // ...
  
 In order to be able to pass some parameters to a decorator, we need to wrap the 
 decorator with a function. The wrapper function takes the parameters of our choice 
 and returns a decorator:
  
 function logClass(option : string) {
  
  
  return function (target: any) {
  
   
  // class decorator logic goes here
  
   
  // we have access to the decorator parameters
   
  console.log(target, option);
  
  
  } 
  
 }
  
 This can be applied to all the kinds of decorator that you learned about in 
 this chapter.
  
 [
  244 
 ]",NA
The reflection metadata API,"You learned that decorators can be used to modify and extend the behavior of a 
 class's methods or properties. You also learned that we can use decorators to add 
 metadata to the class being decorated.
  
 For less experienced developers, the possibility of adding metadata to a class might 
 not seem really useful or exciting but it is one of the greatest things that has happened 
 to JavaScript in the past few years.
  
 As we already know, TypeScript only uses types at design time. However, some features 
 such as dependency injection, runtime type assertions, reflection, and testing are not 
 possible without the type information being available at runtime. This is not a problem 
 anymore because we can use decorators to generate metadata and that metadata can 
 contain type information. The metadata can then be processed at runtime.
  
 When the TypeScript team started to think about the best possible way to allow 
 developers to generate type information metadata, they reserved a few special 
 decorator names for this purposes.
  
 The idea was that, when an element was decorated using these reserved decorators, the 
 compiler would automatically add the type information to the element being decorated. 
 The reserved decorators were the following:
  
 TypeScript compiler will honor special decorator names and will flow 
 additional information into the decorator factory parameters annotated by 
 these decorators.
  
 @type – The serialized form of the type of the decorator target
  
 @returnType – The serialized form of the return type of the decorator target if it 
 is a function type, undefined otherwise
  
 @parameterTypes – A list of serialized types of the decorator target's arguments 
 if it is a function type, undefined otherwise
  
 @name – The name of the decorator target
  
 - ""Decorators brainstorming"" by Jonathan Turner
  
 Shortly after, the TypeScript team decided to use the reflection metadata API (one of the 
 proposed ES7 features) instead of the reserved decorators.
  
 [
  245 
 ]",NA
Summary,"In this chapter, you learned how to consume and implement the four available types of 
 decorators (class, method, property, and parameter) and how to create a decorator 
 factory to abstract developers from the decorator types when they are consumed.
  
 You also learned how to use the reflection metadata API to access type information at 
 runtime.
  
 In the next chapter, you will learn about the architecture of a TypeScript application. 
 You will also learn about how to work with some design patterns and how to create a 
 single-page web application.
  
 [
  249 
 ]",NA
Application Architecture,"In previous chapters, we have covered several aspects of TypeScript, and we should 
  
 now feel confident enough to create a small application.
  
 As we know, TypeScript was created by Microsoft to facilitate the creation of 
  
 large-scale JavaScript applications. Some TypeScript features such as modules or 
  
 classes can facilitate the process of creating large applications, but it is not enough. 
  
 We need good application architecture if we want to succeed in the long term.
  
 This chapter is divided into two main parts. In the first part, we are going to look 
  
 at the 
 single-page application
  (
 SPA
 ) architecture and some design patterns that 
  
 will help us create scalable and maintainable applications. This section covers the 
  
 following topics:
  
 • 
  
 The single-page web application architecture
  
 • 
  
 The MV* architecture
  
 • 
  
 Models and collections
  
 • 
  
 Item views and collection views
  
 • 
  
 Controllers
  
 • 
  
 Events
  
 • 
  
 Router and hash navigation
  
 • 
  
 Mediator
  
 • 
  
 Client-side rendering and virtual DOM
  
 • 
  
 Data binding and data flow
  
 • 
  
 The web component and shadow DOM
  
 • 
  
 Choosing an MV* framework
  
 [
  251 
 ]",NA
The single-page application architecture,"We are going to start by exploring what 
 single-page applications
  (
 SPAs
 ) are and 
 how they work. Numerous SPA frameworks are available that can help us develop 
 applications with a good architecture. 
  
 We could jump directly into the use of one of these frameworks, but it is always a good 
 thing to understand how a third-party software component works before we use it. 
 For this reason, we are going use the first part of this chapter to study the internal 
 architecture of an SPA. Let's start by understanding what an SPA is.
  
 An SPA is a web application in which all the resources (HTML, CSS, JavaScript, and so 
 on) are either loaded in one single request, or loaded dynamically without fully 
 reloading the page. We use the term single-page to refer to this kind of application 
 because the web page is never fully reloaded after the initial page load.
  
 In the past, the Web was just a collection of static HTML files and hyperlinks; every 
 time we clicked on a hyperlink, a new page was loaded. This affected web application 
 performance negatively because many of the contents of the page (for example, page 
 headers, page footers, side menus, scripts) were loaded again with each new page. 
  
 When AJAX support arrived for web browsers, developers started to load some of the 
 page content via AJAX requests to avoid unnecessary page reloads and provide better 
 user experience. AJAX applications and SPAs work in a very similar way. The significant 
 difference is that AJAX applications load sections of the web application as HTML. These 
 sections are ready to be appended to the DOM as soon as they finish loading. On the other 
 hand, SPAs avoid loading the HTML; instead, they load data and client-side templates. The 
 templates and data are processed and transformed into HTML in the web browser in a 
 process known as 
 client-side rendering
 . The data is usually in XML or JSON format, and 
 there are many available client-side template languages.
  
 [
  252 
 ]",NA
The MV* architecture,"As we have seen, many tasks that were traditionally performed on the server side are 
 performed on the client side in SPAs. This has caused an increase in the size of 
 JavaScript applications and the need for a better code organization. 
  
 As a result, developers have started using in the frontend some of the design patterns 
 that have been used with success in the backend over the last decade. Among those, we 
 can highlight the 
 Model-View-Controller
  (
 MVC
 ) design pattern and some of its 
 derivative versions, such as 
 Model-View-ViewModel
  (
 MVVM
 ) and 
 Model-View-
 Presenter
  (
 MVP
 ).
  
 Developers around the world started to share some SPA frameworks that somehow try 
 to implement the MVC design pattern but do not necessarily follow the MVC pattern 
 strictly. The majority of these frameworks implement Models and Views, but since not 
 all of them implement Controllers, we refers to this family of frameworks as MV*.
  
  
 We will cover concepts such as MVC, Models, and Views later 
  
  
 in this chapter.
  
 [
  258 
 ]",NA
Common components and features in the ,NA,NA
MV* frameworks,"We have seen that single-page web applications are usually developed using a 
 family of frameworks known as MV*, and we have covered the basics of some 
 common SPA architecture principles. 
  
 Let's delve further into some components and features that are commonly found in 
 MV* frameworks.
  
  
 In this section, we will use some small code snippets from some of the 
  
  
 most popular MV* frameworks. We are not attempting to learn how to 
  
 use each of these frameworks, and no previous experience with an MV* 
  
 framework is required. 
  
 Our goal should be to understand the common components and 
  
 features of an MV* framework and not focus on a particular framework.",NA
Models,"A 
 model
  is a component used to store data. The data is retrieved from an HTTP API and 
 displayed in the view. Some frameworks include a model entity that we, as developers, 
 must extend. For example, in Backbone.js (a popular MV* framework), a model must 
 extend the 
 Backbone.Model
  class:
  
 class TaskModel extends Backbone.Model{
  
  public created : number;
  
  public completed : boolean;
  
  public title : string;
  
  constructor() {
  
  super();
  
  }
  
 }
  
 A model inherits some methods that can help us interact with the web services. For 
 example, in the case of a Backbone.js model, we can use a method named 
 fetch
  to set 
 the values of a model using the data returned by a web service. In some frameworks, 
 models include logic to retrieve data from an HTTP API, while others include an 
 independent component responsible for the communication with an HTTP API.
  
 [
  259 
 ]",NA
Collections ,"Collections are used to represent a list of models. In the previous section, we saw an 
 example of a model named 
 TaskModel
 . While this model could be used to represent a 
 single task in a list of things to do, a collection could be used to represent the list of 
 tasks.
  
 In the majority of MV* frameworks that support collections, we need to specify the model 
 of the items of a collection when the collection is declared. For example, in the case of 
 Backbone.js, the Task collection could look like the following:
  
 class TaskCollection extends Backbone.Collection<TaskModel> {
  
  public model : TaskModel;
  
  
  constructor() {
  
  
  this.model = TodoModel;
  
  
  super();
  
  
  } 
  
 }
  
 Just like in the case of models, some frameworks' collections are plain arrays, and we will 
 not need to extend or instantiate one of the framework's classes. Collections can also 
 inherit some methods to facilitate interaction with web services.",NA
Item views ,"The majority of frameworks feature an item view (or just view) component. Views are 
 responsible for rendering the data stored in the models as HTML. Views usually require 
 a model, a template, and a container to be passed as a constructor argument, property, 
 or setting. 
  
 • 
  
 • 
  
 The model and the template are used to generate the HTML, as we 
 discovered earlier on in this chapter
  
 The container is usually the selector of one of the DOM elements in the page; the 
 selected DOM element is then used as a 
 container
  for the HTML, which is 
 inserted or appended to it
  
 [
  260 
 ]",NA
Collection views ,"A collection view is a special type of view. The relationship between collection views and 
 views is somehow comparable with the relationship between collections and models. 
 Collection views usually require a collection, an item view, and a container to be passed as 
 a constructor argument, property, or setting. 
  
 A collection loops through the models in the specified collection, renders each of 
 them using a specified item view, and then appends the results of the container.
  
  
 In the majority of frameworks, when a collection view is rendered, an 
  
  
 item view is rendered for each item in the collection; this can sometimes 
  
 create a performance bottleneck. 
  
 An alternative solution is to use an item view and a model in which one 
  
 of its attributes is an array. We can then use the 
 {{#each}}
  statement 
  
 in the view template to render a collection in one single operation, as 
  
 opposed to one operation for each item in the collection.
  
 The following code snippet is an example of a collection view in Marionette.js:
  
 class SampleCollectionView extends Marionette.
  
 CollectionView<SampleModel> {
  
  
  constructor(options: any = {}) {
  
  
  super(options);
  
  
  } 
  
 } 
  
 var view = new SampleCollectionView({
  
  
  collection : collection,
  
  
  el:$(""#divOutput""),
  
  
  childView : SampleView 
  
 });
  
 [
  261 
 ]",NA
Controllers,"Some frameworks feature Controllers. Controllers are usually in charge of handling the 
 lifecycle of specific models and their associated views. They are responsible for 
 instantiating connection models and collections with their respective views and 
 collection views as well as disposing them before handling the control over to another 
 controller.
  
 Interaction in MVC applications is organized around controllers and actions. 
 Controllers can include as many action methods as needed, and an action typically has 
 one-to-one mapping with user interactions.
  
 We are going to take a look at a small code snippet that uses an MV* framework 
 known as 
 Chaplin
 . Just like Marionette.js, Chaplin is a framework based on 
 Backbone.js. The following code snippet defines a class that inherits from the base 
 Controller class, which is defined by Chaplin:
  
 class LikesController extends Chaplin.Controller {
  
  public beforeAction() {
  
  this.redirectUnlessLoggedIn();
  
  }
  
  public index(params) {
  
  this.collection = new Likes();
  
  this.view = new LikesView({collection: this.collection});
  
  }
  
  public show(params) {
  
  this.model = new Like({id: params.id});
  
  this.view = new FullLikeView({model: this.model});
  
  }
  
 }
  
 In the preceding code snippet, we can see that the controller is named 
  
 LikesController
 , and it has two actions named 
 index
  and 
 show
  respectively. We 
 can also observe a method named 
 beforeAction
  that is executed by Chaplin before 
 an action is invoked.
  
 [
  262 
 ]",NA
Events,"An event is an action or occurrence detected by the program that may be handled by 
 the program. MV* frameworks usually distinguish two kinds of events:
  
 • 
  
 • 
  
 User events
 : Applications allow users to interact with it by triggering and 
 handling user events, such as clicking on a button, scrolling, or submitting a 
 form. User events are usually handled in a view.
  
 Application events
 : The application can also trigger and handle events. For 
 example, some frameworks trigger an 
 onRender
  event when a view has been 
 rendered or an 
 onBeforeRouting
  event when a controller action is about to be 
 invoked. 
  
 Application events are a good way to adhere to the Open/Close element of the 
 SOLID principle. We can use events to allow developers to extend a framework (by 
 adding event handlers) without having to modify the framework itself. 
  
 Application events can also be used to avoid direct communication between two 
 components. We will cover more about them later in this chapter when we focus on 
 a component known as Mediator.",NA
Router and hash (#) navigation,"The router is responsible for observing URL changes and passing the execution flow to a 
 controller's action that matches the URL. 
  
 The majority of frameworks use a combination of a technique known as hash 
 navigation and the usage of the HTML5 History API to handle changes in the URL 
 without reloading the page.
  
 In an SPA, the links usually contain the hash (
 #
 ) character. This character was originally 
 designed to set the focus on one of the DOM elements on a page, but it is used by MV* 
 frameworks to navigate without needing to fully reload the web page.
  
 In order to understand this concept, we are going to implement a really basic Router 
 from scratch. We are going to start by taking a look at how a route—a plain object used 
 to represent a URL—looks in the majority of MV* frameworks:
  
 class Route {
  
  public controllerName : string;
  
  public actionName : string;
  
 [
  263 
 ]",NA
Mediator,"Some MV* frameworks introduce a component known as 
 Mediator
 . The mediator is a 
 simple object all other modules use to communicate with each other. 
  
 The mediator usually implements the publish/subscribe design pattern (also known as 
 pub/sub
 ). This pattern enables modules to not depend on each other. Instead of making 
 direct use of other parts of the application, modules communicate through events. 
  
 Modules can listen for and react to events but also publish events of their own to give 
 other modules the chance to react. This ensures loose coupling of application 
 modules, while still allowing for ease of information exchange.
  
 [
  266 
 ]",NA
Dispatcher ,"There was something in the previous code snippet that may have caught your 
 attention: the event name is 
 app.dispatch
 . 
  
 The 
 app.dispatch
  event refers to an entity known as 
 Dispatcher
 . This means that 
 the router is sending an event to the dispatcher and not to a controller:
  
 class Dispatcher 
 {
  
  
  // ...
  
  public initialize() {
  
  this.meditor.subscribe(
  
  
  new AppEvent(""app.dispatch"", null, (e: any, data? : any) => {
    
  this.dispatch(data);
  
 [
  267 
 ]",NA
Client-side rendering and Virtual DOM ,"We are already familiar with the basics of client-side rendering. We know client-side 
 rendering requires a template and some data to generate HTML as output, but we 
 haven't mentioned some performance details that we need to consider when selecting 
 an MV* framework.
  
 Manipulating the DOM is one of the main potential performance bottlenecks in SPAs. For 
 this reason, it is interesting to compare how frameworks render the views internally 
 before we decide to work with one or another.
  
 Some frameworks render a view whenever the model changes, and there are two 
 possible ways to know when a model has changed:
  
 • 
  
 • 
  
 The first one is to check for changes using an interval (this operation is 
 sometimes referred as a dirty check) 
  
 The second option is to use an observable model 
  
 [
  268 
 ]",NA
User interface data binding,"User interface
  (
 UI
 ) data binding is a design pattern that aims to simplify 
 development of graphic UI applications. UI data binding binds UI elements to an 
 application domain model.
  
 A binding creates a link between two properties such that when one changes, the other 
 one is updated to the new value automatically. Bindings can connect properties on the 
 same object, or across two different objects. Most MV* frameworks include some sort of 
 binding implementation between views and models.",NA
One-way data binding,"One-way data binding is a type of UI data binding. This type of data binding only 
 propagates changes in one direction.
  
  
 In the majority of MV* frameworks, this means that any changes in the model are 
 propagated to the view. On the other hand, any changes in the view are not 
 propagated to the model.
  
 [
  269 
 ]",NA
Two-way data binding,"Two-way binding is used to ensure that any changes to the view are propagated to 
 the model and any changes in the model are propagated to the view.",NA
Data flow,"Some of the latest MV* frameworks have introduced new approaches and 
 techniques. One of these new concepts is the unidirectional data flow architecture 
 (introduced by Flux).
  
 This unidirectional data flow architecture is based on the idea that changing the value of 
 a variable should automatically force recalculation of the values of variables that depend 
 on its value.
  
 In an MVC application, a controller handles multiple Models and Views. Sometimes, a 
 View uses more than one model, and when two-way data binding is used, we can end up 
 with a complicated flow of data to follow. The following diagram illustrates such a 
 scenario:
  
 [
  270 
 ]",NA
Web components and shadow DOM,"Some frameworks use the term web component to refer to reusable user interface 
 widgets. Web components allow developers to define custom HTML elements. For 
 example, we could define a new HTML 
 <map>
  tag to display a map. Web components 
 can import their own dependencies and use client-side templates to render their 
 own HTML using a technology known as 
 shadow DOM
 .
  
 Shadow DOM allows the browser to use HTML, CSS, and JavaScript within a web 
 component. Shadow DOM is useful when developing large applications because it 
 helps to prevent CSS, HTML, and JavaScript conflicts between components.
  
  
 Some of the existing MV* frameworks (for example, Polymer) can be 
  
  
 used to implement real web components. While other frameworks 
  
 (for example, React) use the term web components to refer to reusable 
  
 user interface widgets, those components cannot be considered 
  
 real web components because they don't use the web components 
  
 technology stack (custom elements, HTML templates, shadow DOM 
  
 and HTML imports).
  
 [
  272 
 ]",NA
Choosing an application framework,"We can create a SPA from scratch, but usually we pick up an existing framework 
 before creating our own. One of the main problems of choosing a JavaScript SPA 
 framework is that there are too many choices. 
  
 The latest and greatest JavaScript framework comes around every sixteen minutes.
  
  - Allen Pike
  
 I would personally recommend considering a framework or another depending on the 
 features that you think that you will need to achieve your goals.
  
  
 For example, if we are going to work on an application with not really complex views and 
 forms, Backbone.js or one of its derivations (Marionette.js, Chaplin, and so on) should 
 work for us. However, if our application is expected to have many forms and complex 
 views, Ember.js or AngularJS might be a better option.
  
  
 If you need some extra help when choosing one framework over 
  
  
 another, you should visit 
 http://todomvc.com
 . TodoMVC is a project 
  
 that offers the same application (a task manager) implemented using 
  
 MV* concepts in most of the popular JavaScript MV* frameworks today.
  
 [
  273 
 ]",NA
Writing an MVC framework from scratch,"Now that we have a good idea about the common components of an MV* application 
 framework, we are going to try to implement our own framework from scratch.
  
  
 The framework that we are about to develop has not been designed 
  
  
 to be used in a real professional environment. Real MV* frameworks 
  
 have thousands of features and have been under intense development 
  
 for months and even years before becoming stable. 
  
 This framework has been developed not to be the most efficient or 
  
 the most maintainable MV* framework available, but to be a good 
  
 learning resource. 
  
 Our application will feature controllers, templates, views, and models as well as a 
 router, a mediator, and a dispatcher. Let's take a look at the role of each of these 
 components in our framework:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Application
 : This is the root component of an application. The application 
 component is in charge of the initialization of all the internal components of the 
 framework (mediator, router, and dispatcher).
  
 Mediator
 : The mediator is in charge of the communication between all the 
 other components in the application.
  
 Application Events
 : Application events are used to send information from one 
 component to another. An application event is identified by an identifier known 
 as a topic. The components can publish application events as well as subscribe 
 and unsubscribe to application events. 
  
 Router
 : The router observes the changes in the browser URL and creates 
 instances of the 
 Route
  class that are then sent to the Dispatcher using an 
 application event.
  
 Routes
 : These are used to represent a URL. The URLs use naming 
  
 conventions that can be used to identify which controller and action should be 
 invoked.
  
 Dispatcher
 : The dispatcher receives instances of the 
 Route
  class, which are 
 used to identify the required controller. The dispatcher can then dispose the 
 previous controller and create a new controller instance if necessary. Once the 
 controller has been initialized, the dispatcher passes the execution flow to the 
 controller using an application event.
  
 [
  274 
 ]",NA
Prerequisites ,"Just like we have been doing in the previous chapters of this book, it is recommended to 
 create a new project and configure an automated development workflow 
  
 using Gulp. 
  
 You can try to create the framework and final application following the steps described in 
 the following sections, or you can download the companion source code to get a copy of 
 the finished application.
  
 We are going to start by installing the following runtime dependencies with npm:
  
 npm init
  
 npm install animate.css bootstrap datatables handlebars jquery q -- 
 save
  
 We also need to install the following development dependencies:
  
 npm browser-sync browserify chai gulp gulp-coveralls gulp-tslint 
 gulp-typescript gulp-uglify karma karma-chai karma-mocha karma-sinon 
 mocha run-sequence sinon vinyl-buffer vinyl-source-stream --save-dev
  
 Now, let's install the required type definition files using 
 tsd
 :
  
 tsd init
  
 tsd install jquery bootstrap handlebars q chai sinon mocha 
 jquery.dataTables highcharts --save
  
 The application uses the following directory tree:
  
 ├── LICENSE
  
 ├── README.md
  
 ├── css
  
 │   └── site.css
  
 ├── data
  
 │   ├── nasdaq.json
  
 │   └── nyse.json
  
 ├── gulpfile.js
  
 ├── index.html
  
 ├── karma.conf.js
  
 ├── node_modules
  
 ├── package.json
  
 ├── source
  
 │   ├── app
  
 │   │   └── // Chapter 10 
  
 │   └── framework
  
 │       ├── app.ts
  
 │       ├── app_event.ts
  
 [
  276 
 ]",NA
Application events,"We are going to use application events that allow the communication between two 
 components. For example, when a model finishes receiving the response of an HTTP 
 API, the response of the request will be sent from the model to a view using an 
 application event. 
  
 As we saw in 
 Chapter 4
 , 
 Object-Oriented Programming with TypeScript
 , one of the SOLID 
 principles is the dependency inversion principle, which states that we should not depend 
 upon concretions (classes) and should depend upon abstractions instead (interfaces). We 
 are going to try to follow the SOLID principles, so let's get started by creating a new file 
 named 
 interfaces.ts
  inside the 
 framework
  folder and declaring the 
 IAppEvent 
 interface:
  
 interface IAppEvent {
  
  topic : string;
  
  data : any;
  
  handler: (e: any, data : any) => void;
  
 }
  
 [
  277 
 ]",NA
Mediator ,"As we already know, the mediator is a component that implements the pub/ sub 
 design pattern and is used to avoid the direct communication between two 
 components. 
  
 Let's add a new interface to the 
 interfaces.ts
  file:
  
 interface IMediator {
  
  
  publish(e : IAppEvent) : void;
  
  
  subscribe(e : IAppEvent) : void;
  
  
  unsubscribe(e : IAppEvent) : void; 
  
 }
  
 [
  278 
 ]",NA
Application ,"The application class is the root component of an application. The application class is 
 in charge of the initialization of the main components of an application (router, 
 mediator, and dispatcher). 
  
 We are going to start by declaring a couple of interfaces required by the application 
 class, so let's add the following interfaces to the 
 interfaces.td
  file:
  
 interface IAppSettings {
  
  
  isDebug : boolean,
  
  
  defaultController : string;
  
  
  defaultAction : string;
  
  
  controllers : Array<IControllerDetails>;
  
  
  onErrorHandler : (o : Object) => void; 
  
 }
  
 interface IControllerDetails {
  
  
  controllerName : string;
  
  
  controller : { new(...args : any[]): IController 
 ;}; }
  
 The 
 IAppSettings
  interface is used to indicate the available application settings. 
 We can use the application settings to enable the debug mode, set the name of the 
 default controller and action, set the available controllers, and set a global error 
 handler. Let's take a look at the actual implementation of the application class:
  
 /// <reference path=""./interfaces""/>
  
 import { Dispatcher } from ""./dispatcher""; 
  
 import { Mediator } from ""./mediator""; 
  
 import { AppEvent } from ""./app_event""; 
  
 import { Router } from ""./router"";
  
 class App {
  
  private _dispatcher : IDispatcher;
  
  private _mediator : IMediator;
  
  private _router : IRouter;
  
  private _controllers : IControllerDetails[]; 
 private _onErrorHandler : (o : Object) => void;
  
  constructor(appSettings : IAppSettings) {
  
  this._controllers = appSettings.controllers;
  
  this._mediator = new Mediator(appSettings.isDebug || false);
  
 [
  281 
 ]",NA
Route ,"In order to be able to understand the implementation of the router class, we need to 
 learn about some of its dependencies first. The first of these dependencies is the 
 Route
  
 class. 
  
 The 
 Route
  class implements the 
 Route
  interface. This interface was previously 
 explained in this chapter, so we will not go into its details again.
  
 interface IRoute {
  
  
  controllerName : 
 string;
  
  
  actionName : string;
  
  
  args : Object[];
  
  
  serialize() : string; 
  
 }
  
 We have also included the implementation of the 
 Route
  class previously in this chapter, 
 but the method named 
 serialize
  was omitted on purpose. The 
 serialize 
 method 
 transforms an instance of the 
 Route
  class into a URL.
  
 /// <reference path=""./interfaces""/>
  
 class Route implements IRoute {
  
  public controllerName : string;
  
  public actionName : string;
  
  public args : Object[];
  
  constructor(controllerName : string, actionName : string, args :   
 Object[]){
  
  this.controllerName = controllerName;
  
  this.actionName = actionName;
  
  this.args = args;
  
  }
  
   
 public serialize() : string {
  
   
  var s, sargs;
  
   
  sargs = this.args.map(a => a.toString()).join(""/"");
  
  
  s = `${this.controllerName}/${this.actionName}/${sargs}`;
   
  return s;
  
  
  } 
  
 } 
  
 export { Route };
  
 [
  283 
 ]",NA
Event emitter ,"The router also has a dependency in the 
 EventEmitter
  class. This class is 
 particularly important because every single component (except the application 
 component) in the entire framework extends it.
  
 As we already know, all the components use a mediator to communicate with each 
 other. The mediator is a singleton, which means that every single component in our 
 application needs to be provided with access to the mediator instance.
  
 The 
 EventEmitter
  class is used to reduce the amount of boilerplate code that is 
 necessary to achieve this and to provide developers with some helpers that facilitate the 
 publication and subscription of multiple application events:
  
 interface IEventEmitter {
  
  
  triggerEvent(event : IAppEvent);
  
  
  subscribeToEvents(events : Array<IAppEvent>);
  
  
 unsubscribeToEvents(events : Array<IAppEvent>); }
  
 Now, let's create a file named 
 event_emitter.ts
  under the framework directory 
 and copy the following code into it:
  
 /// <reference path=""./interfaces""/>
  
 import { AppEvent } from ""./app_event"";
  
  class EventEmitter implements IEventEmitter{ 
 protected _metiator : IMediator;
  
  protected _events : Array<IAppEvent>;
  
  constructor(metiator : IMediator) 
 {
  
  this._metiator = metiator;
  
  }
  
  public triggerEvent(event : IAppEvent){
  
  this._metiator.publish(event);
  
  }
  
  public subscribeToEvents(events : Array<IAppEvent>) { 
 this._events = events;
  
  for(var i = 0; i < this._events.length; i++) {
  
  
 this._metiator.subscribe(this._events[i]);
  
  }
  
 [
  284 
 ]",NA
Router ,"The router observes the URL for changes and generates instances of the 
 Route
  class that 
 are then passed to the dispatcher using an application event. The 
 Router
  class 
 implements the 
 IRouter
  interface:
  
 interface IRouter extends IEventEmitter {
  
  
  initialize() : void; 
  
 }
  
 Let's take a look at the internal implementation of the 
 Router
  class:
  
 /// <reference path=""./interfaces""/>
  
 import { EventEmitter } from ""./event_emitter""; 
 import { AppEvent } from ""./app_event""; 
  
 import { Route } from ""./route"";
  
 class Router extends EventEmitter implements IRouter 
 { private _defaultController : string;
  
  private _defaultAction : string;
  
  constructor(metiator : IMediator, defaultController : string,   
 defaultAction : string) {
  
  super(metiator);
  
  this._defaultController = defaultController || ""home"";
  
  this._defaultAction = defaultAction || ""index"";
  
 [
  285 
 ]",NA
Dispatcher ,"The dispatcher is a component used to create and dispose controllers when needed. 
 Disposing controllers is important because a controller can use a large number of 
 models and views, which can consume a considerable amount of memory.
  
 If we have many controllers, the amount of memory consumed could become a 
 performance issue. One of the main goals of the dispatcher is to prevent this 
 potential issue.
  
 The dispatcher implements the 
 IDispatcher
  and 
 IEventEmitter
  interfaces:
  
 interface IDispatcher extends IEventEmitter {
  
  initialize() : void; 
  
 }
  
 Let's take a look at the implementation of the 
 dispatcher
  class:
  
 /// <reference path=""./interfaces""/>
  
 import { EventEmitter } from ""./event_emitter""; 
 import { AppEvent } from ""./app_event"";
  
 class Dispatcher extends EventEmitter implements IDispatcher 
 { private _controllersHashMap : Object;
  
  private _currentController : IController;
  
  private _currentControllerName : string;
  
  constructor(metiator : IMediator, controllers :  
  
  IControllerDetails[]) {
  
  super(metiator);
  
  this._controllersHashMap = this.getController(controllers); 
 this._currentController = null;
  
  this._currentControllerName = null;
  
  }
  
 We should be starting to become familiar with how the mediator works at this point. 
 Every component inherits from the 
 EventEmitter
  class and uses its methods to 
 subscribe to some events in the method named initialize. 
  
 Later in this chapter, we will be able to observe that some classes (
 Controllers
 , 
 Views
 , 
 and 
 Models
 ) also have a method named 
 dispose
 , which is used to unsubscribe to the 
 methods to which the component subscribed in the 
 initialize
  method.
  
  // listen to app.dispatch 
 events
  
  public initialize() {
  
  this.subscribeToEvents([
  
 [
  288 
 ]",NA
Controller,"Controllers are in charge of the initialization and disposal of views and models. Since 
 controllers must be disposable by the dispatcher, a controller must implement the 
 dispose method from the 
 IController
  interface:
  
 interface IController extends IEventEmitter {
  
  initialize() : void;
  
  dispose() : void;
  
 }
  
 The models and views are set as properties of the classes that extend the 
 Controller 
 class. The 
 Controller
  class itself does not provide us with any functionality, as it is 
 meant to be implemented by developers when working on an application.
  
 /// <reference path=""./interfaces""/>
  
 import { EventEmitter } from ""./event_emitter"";
  
 import { AppEvent } from ""./app_event"";
  
 class Controller extends EventEmitter implements IController {
  
  constructor(metiator : IMediator) {
  
  super(metiator);
  
  }
  
  public initialize() : void {
  
 [
  291 
 ]",NA
Model and model settings ,"Models are used to interact with a web service and transform the data returned by it. 
 Models allow us to read, format, update, or delete the data returned by a web service. 
 Models implement the 
 IModel
  and 
 IEventEmitter
  interfaces:
  
 interface IModel extends IEventEmitter {
  
  
  initialize() : void;
  
  
  dispose() : void; 
  
 }
  
 A model needs to be provided with the URL of the web service that it consumes. We 
 are going to use a class decorator named 
 ModelSettings
  to set the URL of the service 
 to be consumed. 
  
 We could inject the service URL via its constructor, but it is considered a bad practice to 
 inject data (as opposed to a behavior) via a class constructor. The decorator includes 
 some comments to facilitate its understanding:
  
 /// <reference path=""./interfaces""/>
  
 import { EventEmitter } from ""./event_emitter"";
  
 function ModelSettings(serviceUrl : string) {
  
  
  return function(target : any) {
  
  
  // save a reference to the original constructor
  
  
 var original = target;
  
  // a utility function to generate instances of a 
 class function construct(constructor, args) {
  
  
  var c : any = function () {
  
 [
  292 
 ]",NA
View and view settings ,"Views are used to render templates and handle UI events. Just like the rest of the 
 components in our application, the 
 View
  class extends the 
 EventEmitter
  class:
  
 interface IView extends IEventEmitter {
  
  
  initialize() : void;
  
  
  dispose() : void; 
  
 }
  
 A view needs to be provided with the URL of the template that it consumes. We are going 
 to use a class decorator named 
 ViewSettings
  to set the URL of the template to be 
 consumed.
  
 We could inject the template URL via its constructor, but it is considered a bad 
 practice to inject data (as opposed to a behavior) via a class constructor. The 
 decorator includes some comments to facilitate its understanding:
  
 /// <reference path=""./interfaces""/>
  
 import { EventEmitter } from ""./event_emitter""; 
 import { AppEvent } from ""./app_event"";
  
 function ViewSettings(templateUrl : string, container : string) {
  
  return function(target : any) {
  
  
  // save a reference to the original constructor
  
  
  var original = target;
  
  // a utility function to generate instances of a 
 class function construct(constructor, args) {
  
  
  var c : any = function () {
  
   
  return constructor.apply(this, args);
  
  
  }
  
  
  c.prototype = constructor.prototype;
  
 [
  295 
 ]",NA
Framework ,"The framework file is used to provide access to all the components in the framework 
 from one single file. This means that when we implement an application using our 
 framework, we will not need to import a different file for each component:
  
 /// <reference path=""./interfaces""/>
  
 import { App } from ""./app""; 
  
 import { Route } from ""./route""; 
  
 import { AppEvent } from ""./app_event""; 
  
 import { Controller } from ""./controller""; 
  
 import { View, ViewSettings } from ""./view""; 
 import { Model, ModelSettings } from ""./model"";
  
 export { App, AppEvent, Controller, View, ViewSettings, Model, 
 ModelSettings, Route };",NA
Summary ,"In this chapter, we understood what a single-page web application is, what its common 
 components are, and what the main characteristics of this architecture are. 
  
 We also created our own MV* framework. This practical experience and knowledge will 
 help us to understand many of the available MV* frameworks.
  
 In the next chapter, we will try to put in practice many of the concepts that we have 
 learned in this book by creating a full SPA using the framework that we created in this 
 chapter.
  
 [
  299 
 ]",NA
Putting Everything Together,"In this chapter, we are going to put into practice the majority of the concepts that we 
 have covered in the previous chapters.
  
 We will develop a small single-page web application using the SPA framework that we 
 developed in 
 Chapter 9
 , 
 Application Architecture
 . 
  
 This application will allow us to find out how the NASDAQ and NYSE stocks are doing 
 on a particular day. It will not be a very large application, but it will be big enough to 
 demonstrate the advantages of working with TypeScript and using a good 
 application architecture.
  
 We will write some classes and several functions. Some of these functions will be 
 asynchronous (
 Chapter 1
 , 
 Introducing TypeScript
 ; 
 Chapter 3
 , 
 Working with Functions
 ; 
 Chapter 4
 , 
 Object-Oriented Programming with TypeScript
 ; and 
 Chapter 5
 , 
 Runtime
 ). 
  
 We will also consume some decorators provided by our SPA framework 
 (
 Chapter 8
 , 
 Decorators
 ).
  
 To complete the chapter, we will create an automated build to facilitate the 
  
 development process (
 Chapter 2
 , 
 Automating Your Development Workflow
 ), improve the 
 application performance (
 Chapter 6
 , 
 Application Performance
 ), and ensure that it works 
 correctly by writing some unit and integration tests (
 Chapter 7
 , 
 Application Testing
 ).
  
 In this chapter, we will aim to help you gain confidence with TypeScript and the SPA 
 architecture. We need to focus on the SOLID principles and the separation of concerns. 
 Our goal is to create an application that is maintainable and testable, and an 
 application that can grow over time and which components can be reused in future 
 applications.
  
 [
  301 
 ]",NA
Prerequisites,"In this application, we will use the tools and the directory tree that we created in the 
 previous chapter. You can use the 
 tsd.json
  and 
 package.json
  files included in the 
 companion source code to install the required npm packages and type definition files. 
 Refer to the prerequisites section under the 
 Writing an MVC framework from scratch
  
 section in 
 Chapter 9
 , 
 Application Architecture
 , for additional information about the 
 prerequisites of this application.",NA
The application's requirements,"We will develop a small application that will allow users to see a list of stock symbols. A 
 stock symbol represents a company that trades its shares on a stock exchange. 
  
 The application home page will display stock symbols from two popular stock 
 exchanges: 
 NASDAQ
  (
 National Association of Securities Dealers Automated 
 Quotations
 ) and 
 NYSE
  (
 New York stock exchange
 ).
  
 As you can see in the following screenshot, the web application requires a top menu 
 containing links that allow the user to see the stock symbols in one of the 
 aforementioned stock exchanges. The list of stock symbols will be displayed in a 
 table, which will include some basic details about the stocks, such as the price of a 
 share in the last sale or the name or the company:
  
  
 [
  302 
 ]",NA
The application's data,"As we explained in the previous chapter, we need an application backend that allows us to 
 query the data from a web browser using AJAX requests in order to develop an SPA. This 
 means that we are going to need an HTTP API.
  
 We will use a freely available public HTTP API that will allow us to obtain real stock 
 quote data. For the list of available stock symbols, we will use static JSON files. 
  
 These JSON files have been generated by transforming a CSV file available on the 
 NASDAQ website. The external HTTP API will also provide the line graph data.
  
 [
  303 
 ]",NA
The application's architecture ,"We will develop an SPA using our own framework. As we saw in the previous 
 chapter, our framework can map a URL with an action in a controller.
  
 Our application will have three main screens. Each screen uses a different URL, as 
 follows:
  
  
 • 
  
 #market/nasdaq
  displays stocks in the NASDAQ stock market 
  
  
  
 #market/nyse
  displays stocks in the NYSE stock market• 
  
  
 • 
  
 #symbol/quote/{symbol}
  displays a stock quote for the selected stock symbol 
 Each of the main URLs mentioned earlier will be implemented as a controller's action in 
 our application. In the previous chapter, you saw that URLs adhere to the following 
 naming convention: 
 #controllerName/actionName/arg1/arg2/argN
 .
  
 If we extrapolate this naming convention to the URLs mentioned in the 
 preceding list, we can deduce that our application will have two controllers: 
 MarketController
  and 
 SymbolController
 .
  
 The 
 MarketController
  controller will be implemented using two models and one 
 view:
  
  
 • 
  
 NasdaqModel
 : This loads a list of NASDAQ stocks from a static JSON file
  
 • 
  
 NyseModel
 : This loads a list of NYSE stocks from a static JSON file 
  
  
 MarketView
 : This renders the list of either the NASDAQ or NYSE stocks• 
  
 [
  304 
 ]",NA
The application's file structure,"Presented in this section is the folder structure of the application we are going to build. 
 In the root directory, you can find the application access point (
 index.html
 ), as well as 
 some of the automation tools' configuration files (
 gulpfile.js
 , 
 karma.
  
 conf.js
 , 
 package.json
 , and so on). You can also observe the 
 typings
  folder, 
 which contains some type definition files.
  
 Just as in the previous chapters, the application source code is located under the 
 source directory. The unit and integration tests are located in the test folder. The 
 following is the folder structure of the application:
  
 ├── LICENSE
  
 ├── README.md
  
 ├── css
  
 │   └── site.css
  
 ├── data
  
 │   ├── nasdaq.json
  
 [
  305 
 ]",NA
Configuring the automated build ,"Just as we did in 
 Chapter 2
 , 
 Automating Your Development Workflow
 , we need to create a 
 configuration file to configure the desired Gulp tasks. So let's create a file named 
 gulpfile.js
  and import the required Gulp plugins:
  
 var gulp        = require(""gulp""),
  
  browserify  = require(""browserify""),
  
  source      = require(""vinyl-source-stream""),
  
  buffer      = require(""vinyl-buffer""),
  
  tslint      = require(""gulp-tslint""),
  
  tsc         = require(""gulp-typescript""),
  
  karma       = require(""karma"").server,
  
  coveralls   = require('gulp-coveralls'),
  
  uglify      = require(""gulp-uglify""),
  
  runSequence = require(""run-sequence""),
  
  header      = require(""gulp-header""),
  
  browserSync = require(""browser-sync""),
  
  reload      = browserSync.reload,
  
  pkg         = require(__dirname + ""/package.json""); 
  
 We need to remember that before we can import one of these packages, we must first 
 install them using npm.
  
 Once the plugins have been imported, we can proceed to write our first task, which is 
 used to check for some basic name convention rules and to avoid some bad practices (the 
 TypeScript files are under the 
 source
  and 
 tests
  directories):
  
 gulp.task(""lint"", function() {
  
  
  return gulp.src([
  
   
   
  ""source/**/**.ts"", 
  
   
   
  ""test/**/**.test.ts""
  
   
  ])
  
   
  .pipe(tslint())
  
   
  .pipe(tslint.report(""verbose"")); 
 }); 
  
 We also need another task to compile our TypeScript code into JavaScript code. As we 
 are working with decorators, we need to ensure that we are using TypeScript 1.5 or 
 higher and that the 
 experimentalDecorators
  compiler settings and target are 
 configured as in the following code snippet:
  
 var tsProject = tsc.createProject({
  
  target : ""es5"",
  
  module : ""commonjs"",
  
 [
  307 
 ]",NA
The application's layout,"Let's create a new file, named 
 index.html
 , under the application's root directory. 
 The following code snippet is an altered version of the real 
 index.html
  page, which 
 is included with the companion source code:
  
  <ul class=""nav navbar-nav"">
  
  <li>
  
  <a href=""
 #market/nasdaq
 "">NASDAQ</a>
  
  </li>
  
  <li>
  
  <a href=""
 #market/nyse
 "">NYSE</a>
  
  </li>
  
  </ul>
  
  <div id=""
 outlet
 "">
  
  <!-- HTML GENERATED BY VIEWS GOES HERE -->
  
  </div>
  
 As you can see in the preceding HTML snippet, the code has two important elements. 
 The first significant element is the URL of the two links. These links include the hash 
 character (
 #
 ), and they will be processed by the application's router.
  
 The second significant element is the element that uses 
 outlet
  as ID. This node is 
 used by our framework as a container where the DOM of each new page is 
 dynamically generated and added to the page.",NA
Implementing the root component,"As you saw in the previous chapter, the root component of our custom MVC 
 framework is the 
 App
  component. So, let's create a new file, named 
 main.ts
 , 
 under the 
 source/app
  directory.
  
 We can access all the interfaces in the framework by adding a reference to the 
 source/interfaces.ts
  as follows:
  
 /// <reference path=""../framework/interfaces""/>
  
 We can then access all the components in the framework by importing the 
 framework/framework.ts
  file:
  
 import { App, View } from ""../framework/framework"";
  
 [
  310 
 ]",NA
Implementing the market controller ,"Let's create a new file named 
 market_controller.ts
  under the 
 app/controllers 
 directory. We need to import the 
 Controller
  and 
 AppEvent
  entities from the 
 framework along with some entities that are not available yet (
 NyseModel
 , 
  
 NasdaqModel
  and 
 MarketView
 ). 
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { Controller, AppEvent } from ""../../framework/framework""; 
 import { MarketView } from ""../views/market_view""; 
  
 import { NasdaqModel } from ""../models/nasdaq_model""; 
  
 import { NyseModel } from ""../models/nyse_model"";
  
 In an application that uses our framework, a controller must extend the base 
 Controller
  class and implement the 
 IController
  class:
  
 class MarketController extends Controller implements IController {
  
 We are not forced to declare the views and models used by the controller as its 
 properties, but it is recommended:
  
  private _marketView : IView;
  
  private _nasdaqModel : IModel;
  
  private _nyseModel : IModel;
  
 It is also recommended that you set the value of all the controller's dependencies 
 inside the controller constructor:
  
  constructor(metiator : IMediator) {
  
  super(metiator);
  
  this._marketView = new MarketView(metiator); 
 this._nasdaqModel = new NasdaqModel(metiator); 
 this._nyseModel = new NyseModel(metiator); }
  
  
 Instead of setting the value of all the controller's dependencies 
  
  
 inside the controller constructor, it would be even better to use an 
  
 IoC container to automatically inject the controller's dependencies 
  
 via its constructor. Though, implementing an IoC container is not 
  
 a simple task, it is beyond the scope of this book.
  
 [
  312 
 ]",NA
Implementing the NASDAQ model,"Let's create a new file named 
 nasdaq_model.ts
  under the 
 app/models
  directory. We 
 can then import the 
 Model
 , 
 AppEvent
 , and 
 ModelSettings
  from our framework and 
 declare a new class named 
 NasdaqModel
 . The new class must extend the base 
 Model
  
 class and implement the 
 IModel
  interface. 
  
 We will also use the 
 ModelSettings
  decorator to indicate the path of a web service or 
 static data file. In this case, we will use a static data file, which can be found in the 
 companion source code:
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { Model, AppEvent, ModelSettings } from ""../../framework/
  
 [
  314 
 ]",NA
Implementing the NYSE model ,"Let's create a new file named 
 nyse_model.ts
  under the 
 app/models
  directory. 
 The 
 NyseModel
  class is almost identical to the 
 NasdaqModel
  class, so we will not 
 go into too much detail:
  
 @ModelSettings(""./data/nyse.json"") 
  
 class 
 NyseModel
  extends Model implements IModel { 
 // ...
  
 } 
  
 export { 
 NyseModel
  };
  
 All we need to do is copy the contents of the 
 nasdaq_model.ts
  file into the 
 nyse_model.ts
  file and replace (case sensitive) 
 nasdaq
  with 
 nyse
 .
  
  
 This kind of code duplication is known as a code smell. A code smell 
  
  
 indicates that something is wrong and we need to refactor (improve) 
  
 it. We could avoid a lot of code duplication by using Generic types. 
  
 However generic types were not used here because we though that 
  
 showcasing the usage of decorators would be more valuable for the 
  
 readers of this book.",NA
Implementing the market view ,"Let's create a new file named 
 market_view.ts
  under the 
 app/views
  directory. We 
 can then import the 
 AppEvent
 , 
 ViewSettings
 , and 
 Route
  components from our 
 framework and declare a new class named 
 MarketView
 . The new class must extend 
 the base 
 View 
 class and implement the 
 IView 
 interface. 
  
 We will also use the 
 ViewSettings
  decorator to indicate the path, a Handlebars 
 template, and a selector, which is used to find the DOM element that will be used as 
 the parent node of the view's HTML:
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { View, AppEvent,ViewSettings, Route } from ""../../framework/ 
 framework"";
  
 [
  316 
 ]",NA
Implementing the market template ,"The template loaded and compiled by 
 MarketView
  looks as follows:
  
 <div class=""panel panel-default fadeInUp animated"">
  
  
  <div class=""panel-body"">
  
  
  <h2>{{market}}</h2>
  
  
  <table class=""table table-responsible table-condensed"">
  
   
  <thead>
  
     
  <tr>
  
     
  <th>Symbol</th>
  
     
  <th>Name</th>
  
     
  <th>Last Sale</th>
  
     
  <th>Market Capital</th>
  
     
  <th>IPO year</th>
  
     
  <th>Sector</th>
  
     
  <th>industry</th>
  
     
  <th>Quote</th>
  
     
  </tr>
  
    
  </thead>
  
    
  <tbody>
  
     
  {{#each items}}
  
     
  <tr>
  
       
  <td><span class=""label label- 
  
       
  default"">{{Symbol}}</span></td>
  
       
  <td>{{{Name}}}</td>
  
       
  <td>{{LastSale}}</td>
  
       
  <td>{{MarketCap}}</td>
  
       
  <td>{{IPOyear}}</td>
  
       
  <td>{{Sector}}</td>
  
       
  <td>{{industry}}</td>
  
       
  <td>
  
        
  <button class=""btn btn-primary btn-sm getQuote""  
  
       
  data-symbol=""{{Symbol}}"">
  
          
  <span class=""glyphicon glyphicon-stats"" aria- 
  
         
  hidden=""true""></span>
  
          
  Quote
  
        
  </button>
  
       
  </td>
  
     
  </tr>
  
     
  {{/each}}
  
    
  </tbody>
  
  
  </table>
  
  
  </div> 
  
 </div>
  
 [
  319 
 ]",NA
Implementing the symbol controller ,"Let's create a new file named 
 symbol_controller.ts
  under the 
 app/controllers 
 directory. This file will contain a new controller named 
 SymbolController
 . The 
 implementation of this controller is largely similar to the implementation of the 
 MarketController
  controller, so we are going to avoid going into too much detail.
  
 The main difference between this controller and the previous controller is that the 
 new controller uses two new models (
 QuoteModel
  and 
 ChartModel
 ) and two new 
 views (
 SymbolView
  and 
 ChartView
 ):
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { Controller, AppEvent } from ""../../framework/framework""; 
 import { QuoteModel } from ""../models/quote_model""; 
  
 import { ChartModel } from ""../models/chart_model""; 
  
 import { SymbolView } from ""../views/symbol_view""; 
  
 import { ChartView } from ""../views/chart_view"";
  
 class SymbolController extends Controller implements IController 
 {
  private _quoteModel : IModel;
  
  private _chartModel : IModel;
  
  private _symbolView : IView;
  
  private _chartView : IView;
  
  constructor(metiator : IMediator) {
  
  super(metiator);
  
  this._quoteModel = new QuoteModel(metiator); 
 this._chartModel = new ChartModel(metiator); 
 this._symbolView = new SymbolView(metiator); 
 this._chartView = new ChartView(metiator); }
  
  // initialize views/ models and strat listening to controller   
 actions
  
  public initialize() : void {
  
  // subscribe to controller action events
  
  this.subscribeToEvents([
  
  
  new AppEvent(""
 app.controller.symbol.quote
 "", null, (e, symbol  
  
  : string) => { this.quote(symbol); })
  
  ]);
  
 [
  320 
 ]",NA
Implementing the quote model ,"Let's create a new file named 
 quote_model.ts
  under the 
 app/models
  directory. 
  
 This is the third model that we have implemented so far. This means that you should 
 be familiar with the basics already, but there are some minor additions in this 
 particular model. The first thing that you will notice is that the web service is no 
 longer a static file:
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { Model, AppEvent, ModelSettings } from ""../../framework/ 
 framework"";
  
 [
  321 
 ]",NA
Implementing the symbol view ,"Let's create a new file named 
 symbol_view.ts
  under the 
 app/views
  directory. The 
 SymbolView
  view receives the stock data formatted by the 
 QuoteModel
  model 
 through the mediator using the 
 app.view.symbol.render 
 event:
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { View, AppEvent,ViewSettings } from ""../../framework/ 
 framework"";
  
 @ViewSettings(""./source/app/templates/symbol.hbs"", ""#outlet"") 
 class SymbolView extends View implements IView {
  
  constructor(metiator : IMediator) {
  
  super(metiator);
  
  }
  
 This view is just like 
 MarketView
 ; it subscribes to some events using the 
 initialize
  method, and later disposes of those events using the 
 dispose 
 method. The 
 SymbolView
  view can also initialize and dispose of user events 
 using the 
 bindDomEvents
  and 
 unbindDomEvents
  methods.
  
 [
  323 
 ]",NA
Implementing the chart model ,"Let's create a new file named 
 chart_model.ts
  under the 
 app/models
  directory. 
  
 This is the last model that we will implement:
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { Model, AppEvent, ModelSettings } from ""../../framework/ 
 framework"";
  
 @ModelSettings(""http://dev.markitondemand.com/Api/v2/InteractiveChart
 / jsonp"") 
  
 class ChartModel extends Model implements IModel {
  
  constructor(metiator : IMediator) {
  
  super(metiator);
  
  }
  
  // listen to model events
  
  public initialize() {
  
  this.subscribeToEvents([
  
  
  new AppEvent(""
 app.model.chart.change
 "", null, (e, args) => {  
  
  this.onChange(args); })
  
  ]);
  
  }
  
  // dispose model events
  
  public dispose() {
  
  this.unsubscribeToEvents();
  
  }
  
 This time, we will need to format both the request and the response. We need to 
 encode the request parameter because the web service requires a group of settings 
 that cannot be sent as parameters in the URL without encoding it first. 
  
 The 
 onChange
  method uses the browser's 
 JSON.stringify
  function to transform the 
 required web service arguments (a JSON object) into a string. The string is then 
 encoded using the browser's 
 encodeURIComponent
  function so it can be used as a 
 parameter in the URL.
  
 [
  325 
 ]",NA
Implementing the chart view ,"Let's create a new file named 
 chart_view.ts
  under the 
 app/views
  directory. This is 
 the last view that we will implement. This view is almost identical to the previous ones, 
 but there is one significant difference. As the chart is rendered by Highcharts and not 
 Handlebars, we will avoid passing a template URL to the 
 ViewSettings 
 decorator:
  
 /// <reference path=""../../framework/interfaces""/>
  
 import { View, AppEvent,ViewSettings } from ""../../framework/ 
 framework"";
  
 [
  327 
 ]",NA
Testing the application ,"We can test this application using the same set of tools that we used in the previous 
 chapters of this book. As you already know, in order to run our unit test, we need to 
 create a Gulp task like the following one:
  
 gulp.task(""run-unit-test"", function(cb) {
  
  
  karma.start({
  
  
  configFile : ""karma.conf.js"",
  
  
  singleRun: true
  
  
  }, cb); 
  
 });
  
 We have used the Karma test runner, and we need to set its configuration using the 
 karma.conf.js
  file. The 
 karma.conf.js
  file is almost identical to the one that we 
 used in 
 Chapter 7
 , 
 Application Testing
 , and will not be included here for the sake of 
 brevity.
  
 We also need a task to run some end-to-end tests: 
  
 gulp.task('run-e2e-test', function() 
 {
  
  
  return gulp.src('')
  
  
  .pipe(nightwatch({
  
    
  configFile: 'nightwatch.json'
  
  
  })); 
  
 });
  
 The 
 nightwatch.json
  file is almost identical the one that we used in 
 Chapter 7
 , 
 Application Testing
 , and thus will not be included here. 
  
 Refer to the companion source code to see the content of 
 nightwatch.json
  and the 
 karma.conf.js
  file, as well as some examples of unit tests and E2E tests.",NA
Preparing the application for a ,NA,NA
production release ,"Now that the application has been implemented and tested, we can prepare it for 
 release in a production environment.
  
 [
  330 
 ]",NA
Summary,"In this chapter, we created an MVC application that allowed us to find out how the 
 NASDAQ and NYSE stocks were doing on a particular day. This application is a single-
 page web application, and its architecture makes its components easy to extend, 
 reuse, maintain, and test.
  
 The application showcases many of the concepts that we covered in the previous 
 chapters. We created an automated build, and we used many functions, classes, 
 modules, and other core language features. We also used modules and worked with 
 some asynchronous functions, and we used some decorators. The automated build 
 performs some tasks that will help us to improve the application performance and 
 ensures that it works correctly.
  
 This application is not a very large JavaScript application. However, the application is 
 large enough to showcase the ways in which TypeScript can help us develop complex 
 applications that are ready to grow and adapt to changes with ease.
  
 I hope you enjoyed this book and feel eager to learn more about TypeScript. 
  
 If you are up for a challenge and you would like to reinforce your TypeScript skills, try 
 the following:
  
 You can try to achieve 100 percent test coverage in the application that we have 
 developed over the last two chapters. You can improve our custom SPA the 
 framework and introduce features such as using an IoC container or using a 
 unidirectional dataflow.
  
 You can also visit the TodoMVC website (
 http://todomvc.com/
 ) to find examples of 
 integration between TypeScript and popular MV* frameworks, such as Ember.js or 
 Backbone.js, to learn how to use a production-ready SPA framework.
  
 [
  332 
 ]",NA
Module 2,"TypeScript Design Patterns
  
 Boost your development efficiency by learning about design patterns in TypeScript",NA
Module 2: TypeScript Design Patterns,"Chapter 1: Tools and Frameworks
  
 7
  
 Installing the prerequisites 
  
  
 Installing Node.js 
  
  
 Installing TypeScript compiler 
  
 Choosing a handy editor 
  
  
 Visual Studio Code 
  
  
 Configuring Visual Studio Code 
  
  
 Opening a folder as a workspace 
  
  
 Configuring a minimum build task 
  
  
 Sublime Text with TypeScript plugin 
  
 Installing Package Control 
  
  
 Installing the TypeScript plugin 
  
  
 Other editor or IDE options 
  
  
 Atom with the TypeScript plugin 
  
  
 Visual Studio 
  
  
 WebStorm 
  
 Getting your hands on the workflow 
  
  
 Configuring a TypeScript project 
  
  
 Introduction to tsconfig.json 
  
  
 Compiler options 
  
  
  
 target 
  
  
  
 module 
  
  
  
 declaration 
  
  
  
 sourceMap 
  
  
  
 jsx 
  
  
  
 noEmitOnError 
  
  
  
 noEmitHelpers 
  
  
  
 noImplicitAny 
  
  
  
 experimentalDecorators* 
  
  
  
 emitDecoratorMetadata* 
  
  
  
 outDir 
  
  
  
 outFile 
  
  
  
 rootDir 
  
  
  
 preserveConstEnums 
  
  
  
 strictNullChecks 
  
  
  
 stripInternal* 
  
  
  
 isolatedModules 
  
  
 Adding source map support 
  
  
 Downloading declarations using typings 
  
 Installing typings
  
 7
  
 7
  
 8
  
 9
  
 9
  
  
 1
 0 
  
 1
 1 
  
 1
 2
  
 1
 3 
  
 1
 4 
  
 1
 4
  
 1
 4 
  
 1
 5 
  
 1
 5 
  
 1
 6
  
 16
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 8 
  
 1
 8 
  
 1
 8 
  
 1
 9 
  
 1
 9 
  
 1
 9 
  
 1
 9",NA
Tools and Frameworks ,NA,NA
,"We could always use the help of real code to explain the design patterns we'll be discussing. 
 In this chapter, we'll have a brief introduction to the tools and frameworks that you might 
 need if you want to have some practice with complete working implementations of the 
 contents of this book.
  
 In this chapter, we'll cover the following topics:
  
 Installing Node.js and TypeScript compiler
  
 Popular editors or IDEs for TypeScript
  
 Configuring a TypeScript project
  
 A basic workflow that you might need to play with your own implementations of 
  
 the design patterns in this book",NA
Installing the prerequisites,"The contents of this chapter are expected to work on all major and up-to-date desktop 
 operating systems, including Windows, OS X, and Linux.
  
 As Node.js is widely used as a runtime for server applications as well as frontend build 
 tools, we are going to make it the main playground of code in this book.
  
 TypeScript compiler, on the other hand, is the tool that compiles TypeScript source files into 
 plain JavaScript. It's available on multiple platforms and runtimes, and in this book we'll be 
 using the Node.js version.",NA
Installing Node.js,"Installing Node.js should be easy enough. But there's something we could do to minimize 
 incompatibility over time and across different environments:
  
 Version
 : We'll be using Node.js 6 with npm 3 built-in in this book. (The major 
 version of Node.js may increase rapidly over time, but we can expect minimum 
 breaking changes directly related to our contents. Feel free to try a newer version 
 if it's available.)
  
 Path
 : If you are installing Node.js without a package manager, make sure the 
  
 environment variable 
 PATH
  is properly configured.
  
 Open a console (a command prompt or terminal, depending on your operating system) and 
 make sure Node.js as well as the built-in package manager 
 npm
  is working:
  
 $ node -v 
  
 6.x.x 
  
 $ npm -v 
  
 3.x.x",NA
Installing TypeScript compiler,"TypeScript compiler for Node.js is published as an npm package with command line 
 interface. To install the compiler, we can simply use the 
 npm install
  command:
  
 $ npm install typescript -g
  
 Option 
 -g
  means a global installation, so that 
 tsc
  will be available as a command. Now 
 let's make sure the compiler works:
  
 $ tsc -v 
  
 Version 2.x.x
  
 You may get a rough list of the options your TypeScript compiler provides 
 with switch 
 -h
 . Taking a look into these options may help you discover 
 some useful features.",NA
Choosing a handy editor,"A compiler without a good editor won't be enough (if you are not a believer of Notepad). 
 Thanks to the efforts made by the TypeScript community, there are plenty of great editors 
 and IDEs ready for TypeScript development.
  
 However, the choice of an editor could be much about personal preferences. In this section, 
 we'll talk about the installation and configuration of Visual Studio Code and Sublime Text. 
 But other popular editors or IDEs for TypeScript will also be listed with brief introductions.",NA
Visual Studio Code,"Visual Studio Code is a free lightweight editor written in TypeScript. And it's an open 
 source and cross-platform editor that already has TypeScript support built-in.
  
 You can download Visual Studio Code from 
 https://code.visualstudio.com/
  and the 
 installation will probably take no more than 1 minute.",NA
Configuring Visual Studio Code,"As Code already has TypeScript support built-in, extra configurations are actually not 
 required. But if the version of TypeScript compiler you use to compile the source code 
 differs from what Code has built-in, it could result in unconformity between editing and 
 compiling.
  
 [ 10 ]",NA
Opening a folder as a workspace,"Visual Studio Code is a file- and folder-based editor, which means you can open a file or a 
 folder and start work.
  
 But you still need to properly configure the project to take the best advantage of Code. For 
 TypeScript, the project file is 
 tsconfig.json
 , which contains the description of source files and 
 compiler options. Know little about 
 tsconfig.json
 ? Don't worry, we'll come to that later.
  
 Here are some features of Visual Studio Code you might be interested in:
  
 Tasks
 : Basic task integration. You can build your project without leaving the 
  
 editor.
  
 Debugging
 : Node.js debugging with source map support, which means you can 
  
 debug Node.js applications written in TypeScript.
  
 Git
 : Basic Git integration. This makes comparing and committing changes easier.",NA
Configuring a minimum build task,"The default key binding for a build task is 
 Ctrl 
 + 
 Shift 
 + 
 B
  or 
 cmd 
 + 
 Shift 
 + 
 B
  on OS X. By 
 pressing these keys, you will get a prompt notifying you that no task runner has been 
 configured. Click 
 Configure Task Runner
  and then select a TypeScript build task template 
 (either with or without the watch mode enabled). A 
 tasks.json
  file under the 
 .vscode 
 folder 
 will be created automatically with content similar to the following:
  
 {
  
  ""version"": ""0.1.0"",
  
  ""command"": ""tsc"",
  
  ""isShellCommand"": true,
  
  ""args"": [""-w"", ""-p"", "".""],
  
  ""showOutput"": ""silent"",
  
  ""isWatching"": true,
  
  ""problemMatcher"": ""$tsc-watch"" 
  
 }
  
 Now create a 
 test.ts
  file with some hello-world code and run the build task again. You can 
 either press the shortcut we mentioned before or press Ctrl/Cmd + P, type 
 task tsc
  , and 
 enter.
  
 If you were doing things correctly, you should be seeing the output 
 test.js
  by the side of 
 test.ts
 .
  
 There are some useful configurations for tasking that can't be covered. You may find more 
 information on the website of Visual Studio Code: 
 https://code.visualstudio.com/
 .
  
 From my perspective, Visual Studio Code delivers the best TypeScript development 
 experience in the class of code editors. But if you are not a fan of it, TypeScript is also 
 available with official support for Sublime Text.",NA
Sublime Text with TypeScript plugin,"Sublime Text
  is another popular lightweight editor around the field with amazing 
 performance.
  
 The following image shows how TypeScript IntelliSense works in Sublime Text:
  
  
 The TypeScript team has officially built a plugin for Sublime Text (version 3 preferred), and 
 you can find a detailed introduction, including useful shortcuts, in their GitHub repository 
 here: 
 https://github.com/Microsoft/TypeScript-Sublime-Plugin
 .
  
 There are still some issues with the TypeScript plugin for Sublime Text. It 
 would be nice to know about them before you start writing TypeScript 
 with Sublime Text.
  
 [ 13 ]",NA
Installing Package Control,"Package Control is de facto package manager for Sublime Text, with which we'll install the 
 TypeScript plugin.
  
 If you don't have Package Control installed, perform the following steps:
  
 1. Click 
 Preferences
  > 
 Browse Packages
 …
 , it opens the Sublime Text packages 
  
 folder.
  
 2. Browse up to the parent folder and then into the 
 Install Packages
  folder, and 
 download the file below into this folder: 
 https://packagecontrol.io/Package% 
 2Control.sublime-package
  
 3. 
  
 Restart Sublime Text and you should now have a working package manager.
  
 Now we are only one step away from IntelliSense and refactoring with Sublime Text.",NA
Installing the TypeScript plugin,"With the help of Package Control, it's easy to install a plugin:
  
 1. Open the Sublime Text editor; press Ctrl + Shift + P for Windows and Linux or 
  
 Cmd + Shift + P for OS X.
  
 2.Type 
 Install Package
  in the command palette, select 
 Package Control: Install 
  
 Package
  and wait for it to load the plugin repositories.
  
 3. 
  
 Type 
 TypeScript
  and select to install the official plugin.
  
 Now we have TypeScript ready for Sublime Text, cheers!
  
 Like Visual Studio Code, unmatched TypeScript versions between the plugin and compiler 
 could lead to problems. To fix this, you can add the field 
 ""typescript_tsdk""
  with a path to 
 the TypeScript 
 lib
  in the 
 Settings 
 –
  User
  file.",NA
Other editor or IDE options,"Visual Studio Code and Sublime Text are recommended due to their ease of use and 
 popularity respectively. But there are many great tools from the editor class to full-featured 
 IDE.",NA
Atom with the TypeScript plugin,"Atom is a cross-platform editor created by GitHub. It has a notable community with plenty 
 of useful plugins, including 
 atom-typescript
 .
  atom-typescript
  is the result of the hard work of 
 Basarat Ali Syed, and it's used by my team before Visual Studio Code. It has many handy 
 features that Visual Studio Code does not have yet, such as module path suggestion, 
 compile on save, and so on.
  
 Like Visual Studio Code, Atom is also an editor based on web technologies. Actually, the 
 shell used by Visual Studio Code is exactly what's used by Atom: Electron, another popular 
 project by GitHub, for building cross-platform desktop applications.
  
 Atom is proud of being hackable, which means you can customize your own Atom editor 
 pretty much as you want.
  
 Then you may be wondering why we turned to Visual Studio Code. The main reason is that 
 Visual Studio Code is being backed by the same company that develops TypeScript, and 
 another reason might be the performance issue with Atom.
  
 But anyway, Atom could be a great choice for a start.",NA
Visual Studio,"Visual Studio is one of the best IDEs in the market. And yet it has, of course, official 
 TypeScript support.
  
 Since Visual Studio 2013, a community version is provided for free to individual 
 developers, small companies, and open source projects.
  
 If you are looking for a powerful IDE of TypeScript on Windows, Visual Studio could be a 
 wonderful choice. Though Visual Studio has built-in TypeScript support, do make sure it's 
 up-to-date. And, usually, you might want to install the newest TypeScript tools for Visual 
 Studio.",NA
WebStorm,"WebStorm is one of the most popular IDEs for JavaScript developers, and it has had an 
 early adoption to TypeScript as well.
  
 A downside of using WebStorm for TypeScript is that it is always one step slower catching 
 up to the latest version compared to other major editors. Unlike editors that directly use the 
 language service provided by the TypeScript project, WebStorm seems to have its own 
 infrastructure for IntelliSense and refactoring. But, in return, it makes TypeScript support in 
 WebStorm more customizable and consistent with other features it provides.
  
 If you decide to use WebStorm as your TypeScript IDE, please make sure the version of 
 supported TypeScript matches what you expect (usually the latest version).",NA
Getting your hands on the workflow,"After setting up your editor, we are ready to move to a workflow that you might use to 
 practice throughout this book. It can also be used as the workflow for small TypeScript 
 projects in your daily work.
  
 In this workflow, we'll walk through these topics:
  
 What is a 
 tsconfig.json
  file, and how can you configure a TypeScript project 
  
 with 
 it?
  
 TypeScript declaration files and the 
 typings
  command-line tool
  
 How to write tests running under Mocha, and how to get coverage information 
  
 using Istanbul
  
 How to test in browsers using Karma",NA
Configuring a TypeScript project,"The configurations of a TypeScript project can differ for a variety of reasons. But the goals 
 remain clear: we need the editor as well as the compiler to recognize a project and its source 
 files correctly. And 
 tsconfig.json
  will do the job.",NA
Introduction to tsconfig.json,"A TypeScript project does not have to contain a 
 tsconfig.json
  file. However, most editors 
 rely on this file to recognize a TypeScript project with specified configurations and to 
 provide related features.
  
 A 
 tsconfig.json
  file accepts three fields: 
 compilerOptions
 , 
 files
 , and 
 exclude
 . For example, a 
 simple 
 tsconfig.json
  file could be like the following:
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es5"",
  
   
  ""module"": ""commonjs"",
  
   
  ""rootDir"": ""src"",
  
   
  ""outDir"": ""out""
  
  },
  
  ""exclude"": [
  
   
  ""out"",
  
   
  ""node_modules""
  
  ] 
  
 }
  
 Or, if you prefer to manage the source files manually, it could be like this:
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es5"",
  
   
  ""module"": ""commonjs"",
  
   
  ""rootDir"": ""src"",
  
   
  ""outDir"": ""out""
  
  },
  
  ""files"": [
  
   
  ""src/foo.ts"",
  
   
  ""src/bar.ts""
  
  ] 
  
 }
  
 Previously, when we used 
 tsc
 , we needed to specify the source files explicitly. Now, with 
 tsconfig.json
 , we can directly run 
 tsc
  without arguments (or with 
 -w
 /
 --watch
  if you want 
 incremental compilation) in a folder that contains 
 tsconfig.json
 .",NA
Compiler options,"As TypeScript is still evolving, its compiler options keep changing, with new features and 
 updates. An invalid option may break the compilation or editor features for TypeScript. 
 When reading these options, keep in mind that some of them might have been changed.
  
 The following options are useful ones out of the list.",NA
target,"target
  specifies the expected version of JavaScript outputs. It could be 
 es5
  (ECMAScript 5), 
 es6
  (ECMAScript 6/2015), and so on.
  
 Features (especially ECMAScript polyfills) that are available in different compilation 
 targets vary. For example, before TypeScript 2.1, features such as 
 async
 /
 await
  were available 
 only when targeting ES6.
  
 The good news is that Node.js 6 with the latest V8 engine has supported most ES6 features.
  
 And the latest browsers have also great ES6 support. So if you are developing a Node.js 
 application or a browser application that's not required for backward compatibilities, you 
 can have your configuration target ES6.",NA
module,"Before ES6, JavaScript had no standard module system. Varieties of module loaders are 
 developed for different scenarios, such as 
 commonjs
 , 
 amd
 , 
 umd
 , 
 system
 , and so on.
  
 If you are developing a Node.js application or an npm package, 
 commonjs
  could be the 
 value of this option. Actually, with the help of modern packaging tools such as webpack 
 and browserify, commonjs could also be a nice choice for browser projects as well.",NA
declaration,"Enable this option to generate 
 .d.ts
  declaration files along with JavaScript outputs.
  
 Declaration files could be useful as the type information source of a distributed 
 library/framework; it could also be helpful for splitting a larger project to improve 
 compiling performance and division cooperation.",NA
sourceMap ,"By enabling this option, TypeScript compiler will emit source maps along with compiled
  
 JavaScript.",NA
jsx ,"TypeScript provides built-in support for React JSX (
 .tsx
 ) files. By specifying this option
  
 with value 
 react
 , TypeScript compiler will compile 
 .tsx
  files to plain JavaScript files. Or
  
 with value 
 preserve
 , it will output 
 .jsx
  files so you can post-process these files with other
  
 JSX compilers.",NA
noEmitOnError ,"By default, TypeScript will emit outputs no matter whether type errors are found or not. If
  
 this is not what you want, you may set this option to 
 true
 .",NA
noEmitHelpers ,"When compiling a newer ECMAScript feature to a lower target version of JavaScript,
  
 TypeScript compiler will sometimes generate helper functions such as 
 __extends
  (ES6 to
  
 lower versions), and 
 __awaiter
  (ES7 to lower versions).
  
 Due to certain reasons, you may want to write your own helper functions, and prevent
  
 TypeScript compiler from emitting these helpers.",NA
noImplicitAny ,"As TypeScript is a superset of JavaScript, it allows variables and parameters to have no type
  
 notation. However, it could help to make sure everything is typed.
  
 By enabling this option, TypeScript compiler will give errors if the type of a
  
 variable/parameter is not specified and cannot be inferred by its context.",NA
experimentalDecorators* ,"As decorators, at the time of writing this book, has not yet reached a stable stage of the new
  
 ECMAScript standard, you need to enable this option to use decorators.
  
 [ 19 ]",NA
emitDecoratorMetadata*,"Runtime type information could sometimes be useful, but TypeScript does not yet support 
 reflection (maybe it never will). Luckily, we get decorator metadata that will help under 
 certain scenarios.
  
 By enabling this option, TypeScript will emit decorators along with a 
  
 Reflect.metadata()
  decorator which contains the type information of the decorated 
 target.",NA
outDir,"Usually, we do not want compiled files to be in the same folder of source code. By 
 specifying 
 outDir
 , you can tell the compiler where you would want the compiled 
 JavaScript files to be.",NA
outFile,"For small browser projects, we might want to have all the outputs concatenated as a single 
 file. By enabling this option, we can achieve that without extra build tools.",NA
rootDir,"The 
 rootDir
  option is to specify the root of the source code. If omitted, the compiler would 
 use the longest common path of source files. This might take seconds to understand.
  
 For example, if we have two source files, 
 src/foo.ts
  and 
 src/bar.ts
 , and a 
  
 tsconfig.json
  file in the same directory of the 
 src
  folder, the TypeScript compiler will use 
 src
  as the 
 rootDir
 , so when emitting files to the 
 outDir
  (let's say 
 out
 ), they will be 
 out/foo.js
  
 and 
 out/bar.js
 .
  
 However, if we add another source file 
 test/test.ts
  and compile again, we'll get those 
 outputs located in 
 out/src/foo.js
 , 
 out/src/bar.js
 , and 
 out/test/test.js 
 respectively. When 
 calculating the longest common path, declaration files are not involved as they have no 
 output.
  
 Usually, we don't need to specify 
 rootDir
 , but it would be safer to have it configured.",NA
preserveConstEnums,"Enum is a useful tool provided by TypeScript. When compiled, it's in the form of an 
 Enum.member
  expression. Constant enum, on the other hand, emits number literals directly, 
 which means the 
 Enum
  object is no longer necessary.
  
 And thus TypeScript, by default, will remove the definitions of constant enums in the 
 compiled JavaScript files.
  
 By enabling this option, you can force the compiler to keep these definitions anyway.",NA
strictNullChecks,"TypeScript 2.1 makes it possible to explicitly declare a type with 
 undefined
  or 
 null
  as its 
 subtype. And the compiler can now perform more thorough type checking for empty 
 values if this option is enabled.",NA
stripInternal*,"When emitting declaration files, there could be something you'll need to use internally but 
 without a better way to specify the accessibility. By commenting this code with 
 /** 
 @internal */
  (JSDoc annotation), TypeScript compiler then won't emit them to 
  
 declaration files.",NA
isolatedModules,"By enabling this option, the compiler will unconditionally emit imports for unresolved files.
  
 Options suffixed with 
 *
  are experimental and might have already been 
 removed when you are reading this book. For a more complete and up-to-
 date compiler options list, please check out 
 http://www.typescriptlang. 
 org/docs/handbook/compiler-options.html
 .",NA
Adding source map support,"Source maps can help a lot while debugging, no matter for a debugger or for error stack 
 traces from a log.
  
 To have source map support, we need to enable the 
 sourceMap
  compiler option in 
 tsconfig.json
 . Extra configurations might be necessary to make your debugger work with 
 source maps.",NA
Downloading declarations using typings,"JavaScript has a large and booming ecosystem. As the bridge connecting TypeScript and 
 other JavaScript libraries and frameworks, declaration files are playing a very important 
 role.
  
 With the help of declaration files, TypeScript developer can use existing JavaScript libraries 
 with nearly the same experience as libraries written in TypeScript.
  
 Thanks to the efforts of the TypeScript community, almost every popular JavaScript library 
 or framework got its declaration files on a project called 
 DefinitelyTyped
 . And there has 
 already been a tool called 
 tsd
  for declaration file management. But soon, people realized the 
 limitation of a single huge repository for everything, as well as the issues 
 tsd
  cannot solve 
 nicely. Then 
 typings
  is gently becoming the new tool for TypeScript declaration file 
 management.",NA
Installing typings,"typings
  is just another Node.js package with a command-line interface like TypeScript 
 compiler. To install 
 typings
 , simply execute the following:
  
 $ npm install typings -g
  
 To make sure it has been installed correctly, you can now try the 
 typings
  command with 
 argument 
 --version
 :
  
 $ typings --version 
  
 1.x.x",NA
Downloading declaration files,"Create a basic Node.js project with a proper 
 tsconfig.json
  (module option set as 
 commonjs
 ), and a 
 test.ts
  file:
  
 import * as express from 'express';
  
 Without the necessary declaration files, the compiler would complain with 
 Cannot find 
 module express
 . And, actually, you can't even use Node.js APIs such as 
 process.exit() 
 or 
 require Node.js modules, because TypeScript itself just does not know what Node.js is.
  
 To begin with, we'll need to install declaration files of Node.js and Express:
  
 $ typings install env~node --global 
  
 $ typings install express
  
 If everything goes fine, 
 typings
  should've downloaded several declaration files and saved 
 them to folder 
 typings
 , including 
 node.d.ts
 , 
 express.d.ts
 , and so on. And I guess you've already 
 noticed the dependency relationship existing on declaration files.
  
 If this is not working for you and 
 typings
  complains with 
 Unable to 
 find
 “
 express
 ”
  (
 “
 npm
 ”
 ) in the registry
  then you might need to do it the 
 hard way 
 –
  to manually install Express declaration files and their 
 dependencies using the following command: 
  
 $ typings install dt~<package-name> 
 –
 global 
  
 The reason for that is the community might still be moving from 
  
 DefinitelyTyped
  to the 
 typings
  registry. The prefix 
 dt~
  tells 
 typings 
 to 
 download declaration files from 
 DefintelyTyped
 , and 
 --global 
 option tells 
 typings
  to save these declaration files as ambient modules (namely 
 declarations with module name specified).
  
 typings
  has several registries, and the default one is called npm (please understand this 
 npm
  registry is not the 
 npm
  package registry). So, if no registry is specified with 
 <source>~ 
 prefix or 
 --source
  option, it will try to find declaration files from its 
 npm
  registry. This 
 means that 
 typings install express
  is equivalent to 
 typings install 
  
 npm~express
  or 
 typings install express --source npm
 .
  
 While declaration files for npm packages are usually available on the 
 npm
  registry, 
 declaration files for the environment are usually available on the 
 env
 . registry. As those 
 declarations are usually global, a 
 --global
  option is required for them to install correctly.",NA
Option “save”,"typings
  actually provides a 
 --save
  option for saving the typing names and file sources to 
 typings.json
 . However, in my opinion, this option is not practically useful.
  
 It's great to have the most popular JavaScript libraries and frameworks typed, but these 
 declaration files, especially declarations not frequently used, can be inaccurate, which 
 means there's a fair chance that you will need to edit these files yourself.
  
 It would be nice to contribute declarations, but it would also be more flexible to have 
 typings
  m  managed by source control as part of the project code.",NA
Testing with Mocha and Istanbul,"Testing could be an important part of a project, which ensures feature consistency and 
 discovers bugs earlier. It is common that a change made for one feature could break another 
 working part of the project. A robust design could minimize the chance but we still need 
 tests to make sure.
  
 It could lead to an endless discussion about how tests should be written and there are 
 interesting code design techniques such as 
 test-driven development
  (
 TDD
 ); though there 
 has been a lot of debates around it, it still worth knowing and may inspire you in certain 
 ways.",NA
Mocha and Chai,"Mocha has been one of the most popular test frameworks for JavaScript, while Chai is a 
 good choice as an assertion library. To make life easier, you may write tests for your own 
 implementations of contents through this book using Mocha and Chai.
  
 To install Mocha, simply run the following command, and it will add 
 mocha
  as a global 
 command-line tool just like 
 tsc
  and 
 typings
 :
  
 $ npm install mocha -g
  
 Chai, on the other hand, is used as a module of a project, and should be installed under the 
 project folder as a development dependency:
  
 $ npm install chai --save-dev",NA
Writing tests in JavaScript,"By executing the command 
 mocha
 , it will automatically run tests inside the 
 test
  folder. 
 Before we start to write tests in TypeScript, let's try it out in plain JavaScript and make sure 
 it's working.
  
 Create a file 
 test/starter.js
  and save it with the following code:
  
 require('chai').should();
  
 describe('some feature', () => {
  
  it('should pass', () => {
  
   
  'foo'.should.not.equal('bar');
  
  });
  
  it('should error', () => {
  
   
  (() => {
  
    
  throw new Error();
  
   
  }).should.throw();
  
  }); 
  
 });
  
 Run 
 mocha
  under the project folder and you should see all tests passing.",NA
Writing tests in TypeScript,"Tests written in TypeScript have to be compiled before being run; where to put those files 
 could be a tricky question to answer.
  
 Some people might want to separate tests with their own 
 tsconfig.json
 :
  
 src/tsconfig.json 
  
 test/tsconfig.json
  
 They may also want to put output files somewhere reasonable:
  
 out/app/ 
  
 out/test/",NA
Getting coverage information with Istanbul,"Coverage could be important for measuring the quality of tests. However, it might take 
 much effort to reach a number close to 100%, which could be a burden for developers. To 
 balance efforts on tests and code that bring direct value to the product, there would go 
 another debate.
  
 Install Istanbul via 
 npm
  just as with the other tools:
  
 $ npm install istanbul -g
  
 The subcommand for Istanbul to generate code coverage information is 
 istanbul cover
 . It 
 should be followed by a JavaScript file, but we need to make it work with Mocha, which is a 
 command-line tool. Luckily, the entry of the Mocha command is, of course, a JavaScript file.
  
 To make them work together, we'll need to install a local (instead of global) version of 
 Mocha for the project:
  
 $ npm install mocha --save-dev",NA
Testing in real browsers with Karma,"We've talked about testing with Mocha and Istanbul for Node.js applications. It is an 
 important topic for testing code that runs in a browser as well.
  
 Karma is a test runner for JavaScript that makes testing in real browsers on real devices 
 much easier. It officially supports the Mocha, Jasmine, and JUnit testing frameworks, but it's 
 also possible for Karma to work with any framework via a simple adapter.",NA
Creating a browser project,"A TypeScript application that runs in browsers can be quite different from a Node.js one. 
 But if you know what the project should look like after the build, you should already have 
 clues on how to configure that project.
  
 To avoid introducing too many concepts and technologies not directly related, I will keep 
 things as simple as possible:
  
 We're not going to use module loaders such as Require.js
  
 We're not going to touch the code packaging process
  
 This means we'll go with separated output files that need to be put into an HTML file with a 
 script
  tag manually. Here's the 
 tsconfig.json
  we'll be playing with; notice that we no longer 
 have the 
 module
  option, set:
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es5"",
  
   
  ""rootDir"": ""src"",
  
   
  ""outDir"": ""out""
  
  },",NA
Installing Karma,"Karma itself runs on Node.js, and is available as an npm package just like other Node.js 
 tools we've been using. To install Karma, simply execute the 
 npm install
  command in the 
 project directory:
  
 $ npm install karma --save-dev
  
 And, in our case, we are going to have Karma working with Mocha, Chai, and the browser 
 Chrome, so we'll need to install related plugins:
  
 $ npm install karma-mocha karma-chai karma-chrome-launcher --save-dev
  
 Before we configure Karma, it is recommended to have 
 karma-cli
  installed globally so 
 that we can execute the 
 karma
  command from the console directly:
  
 $ npm install karma-cli -g",NA
Configuring and starting Karma,"The configurations are to tell Karma about the testing frameworks and browsers you are 
 going to use, as well as other related information such as source files and tests to run.
  
 To create a Karma configuration file, execute 
 karma init
  and answer its questions:
  
 Testing framework
 : Mocha
  
 Require.js
 : no
  
 Browsers
 : Chrome (add more if you like; be sure to install the corresponding 
  
 launchers)
  
 Source and test files
 :
  
 test/mocha.js
  (the file enables 
 should
  style assertion)
  
 out/*.js
  (source files)
  
 out/test/*.js
  (test files)
  
 Files to exclude
 : empty
  
 Watch for changes
 : yes
  
 Now you should see a 
 karma.conf.js
  file under the project directory; open it with your 
 editor and add 
 'chai'
  to the list of option frameworks.",NA
Integrating commands with npm,"The npm provides a simple but useful way to define custom scripts that can be run with the 
 npm run
  command. And it has another advantage 
 –
  when 
 npm run
  a custom script, it adds 
 node_modules/.bin
  to the 
 PATH
 . This makes it easier to manage project-related 
  
 command-line tools.
  
 For example, we've talked about Mocha and Istanbul. The prerequisite for having them as 
 commands is to have them installed globally, which requires extra steps other than 
 npm 
 install
 . Now we can simply save them as development dependencies, and add custom 
 scripts in 
 package.json
 :
  
 ""scripts"": {
  
  ""test"": ""mocha"",
  
  ""cover"": ""istanbul cover node_modules/mocha/bin/_mocha"" }, 
  
 ""devDependencies"": {
  
  ""mocha"": ""latest"",
  
  ""istanbul"": ""latest"" 
  
 }
  
 Now you can run 
 test
  with 
 npm run test
  (or simply 
 npm test
 ), and run 
 cover
  with 
 npm run 
 cover
  without installing these packages globally.",NA
Why not other fancy build tools?,"You might be wondering: why don't we use a build system such as Gulp to set up our 
 workflow? Actually, when I started to write this chapter, I did list Gulp as the tool we were 
 going to use. Later, I realized it does not make much sense to use Gulp to build the 
 implementations in most of the chapters in this book.
  
 There is a message I want to deliver: 
 balance
 .
  
 Once, I had a discussion on 
 balance versus principles
  with my boss. The disagreement was 
 clear: he insisted on controllable principles over subjective balance, while I prefer contextual 
 balance over fixed principles.
  
 Actually, I agree with him, from the point of view of a team leader. A team is usually built 
 up with developers at different levels; principles make it easier for a team to build high-
 quality products, while not everyone is able to find the right balance point.
  
 However, when the role turns from a productive team member to a learner, it is important 
 to learn and to feel the right balance point. And that's called experience.",NA
Summary,"The goal of this chapter was to introduce a basic workflow that could be used by the reader 
 to implement the design patterns we'll be discussing.
  
 We talked about the installation of TypeScript compiler that runs on Node.js, and had brief 
 introductions to popular TypeScript editors and IDEs. Later, we spent quite a lot of pages 
 walking through the tools and frameworks that could be used if the reader wants to have 
 some practice with implementations of the patterns in this book.
  
 With the help of these tools and frameworks, we've built a minimum workflow that 
 includes creating, building, and testing a project. And talking about workflows, you must 
 have noticed that they slightly differ among applications for different runtimes.
  
 In the next chapter, we'll talk about what may go wrong and mess up the entire project 
 when its complexity keeps growing. And we'll try to come up with specific patterns that can 
 solve the problems this very project faces.",NA
The Challenge of Increasing ,NA,NA
,NA,NA
Complexity,"The essence of a program is the combination of possible branches and automated selections 
 based on certain conditions. When we write a program, we define what's going on in a 
 branch, and under what condition this branch will be executed.
  
 The number of branches usually grows quickly during the evolution of a project, as well as 
 the number of conditions that determine whether a branch will be executed or not.
  
 This is dangerous for human beings, who have limited brain capacities.
  
 In this chapter, we are going to implement a data synchronizing service. Starting by 
 implementing some very basic features, we'll keep adding stuff and see how things go.
  
 The following topics will be covered:
  
 Designing a multi-device synchronizing strategy
  
 Useful JavaScript and TypeScript techniques and hints that are related, including 
  
 objects as maps and the string literal type
  
 How the Strategy Pattern helps in a project",NA
Implementing the basics,"Before we start to write actual code, we need to define what this synchronizing strategy will 
 be like. To keep the implementation from unnecessary distractions, the client will 
  
 communicate with the server directly through function calls instead of using HTTP requests 
 or Sockets. Also, we'll use 
 in-memory storage
 , namely variables, to store data on both client 
 and server sides.
  
 Because we are not separating the client and server into two actual applications, and we are 
 not actually using backend technologies, it does not require much Node.js experience to 
 follow this chapter.
  
 However, please keep in mind that even though we are omitting network and database 
 requests, we hope the core logic of the final implementation could be applied to a real 
 environment without being modified too much. So, when it comes to performance concerns, 
 we still need to assume limited network resources, especially for data passing through the 
 server and client, although the implementation is going to be synchronous instead of 
 asynchronous. This is not supposed to happen in practice, but involving asynchronous 
 operations will introduce much more code, as well as many more situations that need to be 
 taken into consideration. But we will have some useful patterns on asynchronous 
  
 programming in the coming chapters, and it would definitely help if you try to implement 
 an asynchronous version of the synchronizing logic in this chapter.
  
 A client, if without modifying what's been synchronized, stores a copy of all the data 
 available on the server, and what we need to do is to provide a set of APIs that enable the 
 client to keep its copy of data synchronized.
  
 So, it is really simple at the beginning: comparing the last-modified timestamp. If the 
 timestamp on the client is older than what's on the server, then update the copy of data 
 along with new timestamp.",NA
Creating the code base,"Firstly, let's create 
 server.ts
  and 
 client.ts
  files containing the 
 Server
  class and 
 Client
  
 class respectively:
  
 export class Server {
  
  
  // ...
  
 }",NA
Defining the initial structure of the data to be ,NA,NA
synchronized,"Since we need to compare the timestamps from the client and server, we need to have a 
 timestamp
  property on the data structure. I would like to have the data to synchronize as a 
 string, so let's add a 
 DataStore
  interface with a 
 timestamp
  property to the 
 server.ts 
 file:
  
 export interface DataStore {
  
  timestamp: number;
  
  data: string; 
  
 }",NA
Getting data by comparing timestamps,"Currently, the synchronizing strategy is one-way, from the server to the client. So what we 
 need to do is simple: we compare the timestamps; if the server has the newer one, it 
 responds with data and the server-side timestamp; otherwise, it responds with 
 undefined
 :
  
 class Server {
  
  store: DataStore = {
  
   
  timestamp: 0,
  
   
  data: ''
  
  };
  
  getData(clientTimestamp: number): DataStore {
  
  if 
 (clientTimestamp < this.store.timestamp) {
  
  
  return 
 this.store;
  
  
  } else {
  
   
  return undefined;",NA
Two-way synchronizing,"Usually, when we talk about synchronization, we get updates from the server and push 
 changes to the server as well. Now we are going to do the second part, pushing the changes 
 if the client has newer data.",NA
Things that went wrong while implementing the ,NA,NA
basics,"Currently, what we've written is just too simple to be wrong. But there are still some 
 semantic issues.",NA
Passing a data store from the server to the client does ,NA,NA
not make sense,"We used 
 DataStore
  as the return type of the 
 synchronize
  method on 
 Server
 . But what we were 
 actually passing through is not a data store, but information that involves data and its 
 timestamp. The information object just 
 happened to
  have the same properties as a data store 
 at this point in time
 .",NA
Making the relationships clear,"Now we have two separated interfaces, 
 DataStore
  and 
 DataSyncingInfo
 , in 
 server.ts
 .
  
 Obviously, 
 DataSyncingInfo
  should be a shared interface between the server and the client, 
 while 
 DataStore
  happens to be the same on both sides, but it's not actually shared.
  
 So what we are going to do is to create a separate 
 shared.d.ts
  (it could also be 
 shared.ts
  if 
 it contains more than 
 typings
 ) that exports 
 DataSyncingInfo
  and add another 
 DataStore
  to 
 client.ts
 .
  
 Do not follow this blindly. Sometimes it is designed for the server and the 
 client to have exactly the same stores. If that's the situation, the interface 
 should be shared.",NA
Growing features,"What we've done so far is basically useless. But, from now on, we will start to add features 
 and make it capable of fitting in practical needs, including the capability of synchronizing 
 multiple data items with multiple clients, and merging conflicts.",NA
Synchronizing multiple items,"Ideally, the data we need to synchronize will have a lot of items contained. Directly 
 changing the type of 
 data
  to an array would work if there were only very limited number 
 of these items.",NA
Simply replacing data type with an array,"Now let's change the type of the 
 data
  property of 
 DataStore
  and 
 DataSyncingInfo 
 interfaces to 
 string[]
 . With the help of TypeScript, you will get errors for unmatched 
 types this change would cause. Fix them by annotating the correct types.
  
 But obviously, this is far from an efficient solution.",NA
Server-centered synchronization,"If the data store contains a lot of data, the ideal approach would be only updating items that 
 are not up-to-date.
  
 For example, we can create a timestamp for every single item and send these timestamps to 
 the server, then let the server decide whether a specific data item is up-to-date. This is a 
 viable approach for certain scenarios, such as checking updates for software extensions. It is 
 okay to occasionally send even hundreds of timestamps with item IDs on a fast network, 
 but we are going to use another approach for different scenarios, or I won't have much to 
 write.
  
 User data synchronization of offline apps on a mobile phone is what we are going to deal 
 with, which means we need to try our best to avoid wasting network resources.
  
 Here is an interesting question. What are the differences between user 
 data synchronization and checking extension updates? Think about the 
 size of data, issues with multiple devices, and more.",NA
Synchronizing from the server to the client,"Now there seems to be quite a lot to change. Firstly, let's handle synchronizing data from 
 server to client.
  
 This is what's expected to happen on the server side:
  
 Add a timestamp and identity to every data item on the server
  
 Compare the client timestamp with every data item on the server
  
 We don't need to actually compare the client timestamp with every item 
 on server if those items have a sorted index. The performance would be 
 acceptable using a database with a sorted index.
  
 Respond with items newer than what the client has as well as a new timestamp.",NA
Synchronizing from client to server,"For a server-centered synchronizing process, most of the changes are made through clients. 
 Consequently, we need to figure out how to organize these changes before sending them 
 to the server.
  
 One single client only cares about its own copy of data. What difference would this make 
 when comparing to the process of synchronizing data from the server to clients? Well, think 
 about why we need the timestamp of every data item on the server in the first place. We 
 need them because we want to know which items are new compared to a specific client.
  
 Now, for changes on a client: if they ever happen, they need to be synchronized to the 
 server without requiring specific timestamps for comparison.
  
 However, we might have more than one client with changes that need to be synchronized, 
 which means that changes made later in time might actually get synchronized earlier, and 
 thus we'll have to resolve conflicts. To achieve that, we need to add the last modified time 
 back to every data item on the server and the changed items on the client.
  
 I've mentioned that the timestamps stored on the server for finding out what needs to be 
 synchronized to a client do not need to be (and better not be) an actual stamp of a physical 
 time point. For example, it could be the count of synchronizations that happened between 
 all clients and the server.
  
 Updating the client side
  
 To handle this efficiently, we may create a separated map with the IDs of the data items that 
 have changed as keys and the last modified time as the value in 
 ClientDataStore
 :
  
 export interface ClientDataStore {
  
  timestamp: number;
  
  items: {",NA
Synchronizing multiple types of data,"At this point, we've hard coded the data with the 
 string
  type. But usually we will need to 
 store varieties of data, such as numbers, booleans, objects, and so on.
  
 If we were writing JavaScript, we would not actually need to change anything, as the 
 implementation does not have anything to do with certain data types. In TypeScript, we 
 don't need to do much either: just change the type of every related 
 value
  to 
 any
 . But that 
 means you are losing type safety, which would definitely be okay if you are happy with 
 that.
  
 But taking my own preferences, I would like every variable, parameter, and property to be 
 typed if it's possible. So we may still have a data item with 
 value
  of type 
 any
 :
  
 export interface ClientDataItem {
  
  id: string;
  
  value: any; 
  
 }
  
 We can also have derived interfaces for specific data types:
  
 export interface ClientStringDataItem extends ClientDataItem { value: string; 
  
 }
  
 export interface ClientNumberDataItem extends ClientDataItem { value: number; 
  
 }
  
 But this does not seem to be good enough. Fortunately, TypeScript provides 
 generics
 , so we 
 can rewrite the preceding code as follows:
  
 export interface ClientDataItem<T> {
  
  id: string;
  
  value: T; 
  
 }
  
 Assuming we have a store that accepts multiple types of data items 
 –
  for example, number 
 and string 
 –
  we can declare it as follows with the help of the 
 union
  type:
  
 export interface ClientDataStore {
  
  items: {
  
   
  [id: string]: ClientDataItem<number | string>; }; 
  
 }",NA
Supporting multiple clients with incremental data,"Making the typing system happy with multiple data types is easy. But in the real world, we 
 don't resolve conflicts of all data types by simply comparing the last modified times. An 
 example is counting the daily active time of a user cross devices.
  
 It's quite clear that we need to have every piece of active time in a day on multiple devices 
 summed up. And this is how we are going to achieve that:
  
 1. Accumulate active durations between synchronizations on the client.
  
 2. Add a UID (unique identifier) to every piece of time before synchronizing with 
  
 the server.
  
 3. Increase the server-side value if the UID does not exist yet, and then add the UID 
  
 to that data item.
  
 But before we actually get our hands on those steps, we need a way to distinguish 
 incremental data items from normal ones, for example, by adding a 
 type
  property.
  
 As our synchronizing strategy is server-centered, related information is only required for 
 synchronizing requests and conflict merging. Synchronizing responses does not need to 
 include the details of changes, but just merged values.",NA
Updating the client side,"First of all, we need the client to support incremental changes. And if you've thought about 
 this, you might already be confused about where to put the extra information, such as UIDs.
  
 This is because we were mixing up the concept 
 change
  (noun) with 
 value
 . It was not a 
 problem before because, besides the last modified time, the value is what a change is about.
  
 We used a simple map to store the last modified times and kept the store clean from 
 redundancy, which balanced well under that scenario.
  
 But now we need to distinguish between these two concepts:
  
 Value
 : a value describes what a data item is in a static way
  
 Change
 : a change describes the information that may transform the value of a 
  
 data item from one to another
  
 We need to have a general type of changes as well as a new data structure for incremental 
 changes with a numeric value:
  
 type DataType = 'value' | 'increment';
  
 interface ClientChange {
  
  type: DataType; 
  
 }
  
 interface ClientValueChange<T> extends ClientChange { type: 'value';
  
  lastModifiedTime: number;
  
  value: T; 
  
 }
  
 interface ClientIncrementChange extends ClientChange { type: 'increment';
  
  uid: string;
  
  increment: number; 
  
 }",NA
Updating server side,"Before we add the logic for handling incremental changes, we need to make server-side 
 code adapt to the new data structure:
  
 for (let id of Object.keys(clientChangeLists)) { let clientChangeList = 
 clientChangeLists[id]; let type = clientChangeList.type;
  
  let clientChanges = clientChangeList.changes; if (type === 'value') {
  
   
  // ...
  
  } else if (type === 'increment') {
  
  
  // ...
  
  } else {
  
   
  throw new TypeError('Invalid data type'); } 
  
 }
  
 The change list of a normal data item will always contain one and only one change. Thus 
 we can easily migrate what we've written:
  
 let clientChange = changes[0] as ClientValueChange<any>;
  
 Now for incremental changes, we need to cumulatively apply possibly multiple changes in 
 a single change list to a data item:
  
 let item = items[id];",NA
Supporting more conflict merging,"Though we have met the needs of 80%, there is still a big chance that we might want some 
 extra features. For example, we want the ratio of the days marked as available by the user in 
 the current month, and the user should be able to add or remove days from the list. We can 
 achieve that in different ways, and we'll choose a simple way, as usual.
  
 We are going to support synchronizing a set with operations such as add and remove, and 
 calculate the ratio on the client.",NA
New data structures,"To describe set changes, we need a new 
 ClientChange
  type. When we are adding or 
 removing an element from a set, we only care about the last operation to the same element.
  
 This means that the following:
  
 1. If multiple operations are made to the same element, we only need to keep the 
  
 last one.
  
 2. 
  
 A 
 time
  property is required for resolving conflicts.
  
 So here are the new types:
  
 enum SetOperation {
  
  add,
  
  remove 
  
 }
  
 interface ClientSetChange extends ClientChange { element: number;
  
  time: number;
  
  operation: SetOperation; 
  
 }",NA
Updating client side,"And now, the client-side 
 update
  method gets a new part-time job: saving set changes just 
 like value and incremental changes. We need to update the method signature for this new 
 job (do not forget to add 
 'set'
  to 
 DataType
 ):
  
 update(
  
  id: string,
  
  type: 'set',
  
  element: number,
  
  operation: SetOperation 
  
 ): void; 
  
 update<T>(
  
  id: string,
  
  type: DataType,
  
  value: T,
  
  operation?: SetOperation 
  
 ): void;
  
 We also need to add another 
 else if
 :
  
 else if (type === 'set') {
  
  let element = <any>value as number;
  
  if (hasOwnProperty.call(storedChangeLists, id)) {
   
  // ...
  
  } else {
  
  // ...
  
  } 
  
 }",NA
Updating the server side,"Just like we've done with the client, we need to add a corresponding 
 else if
  branch to 
 merge changes of type 
 'set'
 . We are also deleting the ID from 
 clientChangeLists 
 regardless 
 of whether there are newer changes for a simpler implementation:
  
 else if (type === 'set') {
  
  let item: ServerDataItem<{
  
   
  [element: string]: ServerSetElementOperationInfo; }>;
  
  delete clientChangeLists[id]; 
  
 }
  
 The conflict resolving logic is quite similar to what we do to the conflicts of normal values. 
 We just need to make comparisons to each element, and only keep the last operation.
  
 And when preparing the response that will be synchronized to the client, we can generate 
 the set by putting together elements with 
 add
  as their last operations:
  
 if (item.type === 'set') {
  
  let operationInfos: {
  
   
  [element: string]: ServerSetElementOperationInfo; } = item.value;
  
  serverChanges[id] = Object
  
   
  .keys(operationInfos)
  
   
  .filter(element =>
  
    
  operationInfos[element].operation ===
  
     
  SetOperation.add
  
   
  )
  
   
  .map(element => Number(element)); 
  
 } else {
  
  serverChanges[id] = item.value; 
  
 }
  
 Finally, we have a working mess (if it actually works). Cheers!",NA
Things that go wrong while implementing ,NA,NA
everything,"When we started to add features, things were actually fine, if you are not obsessive about 
 pursuing the feeling of design. Then we sensed the code being a little awkward as we saw 
 more and more nested branches.",NA
Piling up similar yet parallel processes,"Most of the code in this chapter is to handle the process of synchronizing data between a 
 client and a server. To get adapted to new features, we just kept adding new things into 
 methods, such as 
 update
  and 
 synchronize
 .
  
 You might have already found that most outlines of the logic can be, and should be, shared 
 across multiple data types. But we didn't do that.
  
 If we look into what's written, the duplication is actually minor judging from the aspect of 
 code texts. Taking the 
 update
  method of the client, for example, the logic of every branch 
 seems to differ. If finding abstractions has not become your built-in reaction, you might just 
 stop there. Or if you are not a fan of long functions, you might refactor the code by splitting 
 it into small ones of the same class. That could make things a little better, but far from 
 enough.",NA
Data stores that are tremendously simplified,"In the implementation, we were playing heavily and directly with ideal 
 in-memory
  stores. It 
 would be nice if we could have a wrapper for it, and make the real store interchangeable.
  
 This might not be the case for this implementation as it is based on extremely ideal and 
 simplified assumptions and requirements. But adding a wrapper could be a way to provide 
 useful helpers.",NA
Getting things right,"So let's get out of the illusion of comparing code one character at a time and try to find an 
 abstraction that can be applied to updating all of these data types. There are two key points 
 of this abstraction that have already been mentioned in the previous section:
  
 A 
 change
  contains the information that can transform the value of an item from 
  
 one to another
  
 Multiple changes could be generated or applied to one data item during a single 
  
 synchronization
  
 Now, starting from changes, let's think about what happens when an 
 update
  method of a 
 client is called.",NA
Finding abstraction,"Take a closer look to the method 
 update
  of client:
  
 For data of the 
 'value'
  type, first we create the change, including a new value, 
 and then update the change list to make the newly created change the only one. 
 After that, we update the value of data item.
  
 For data of the 
 'increment'
  type, we add a change including the increment in the 
 change list; or if a change that has not be synchronized already exists, update the 
 increment of the existing change. And then, we update the value of the data item.
  
 Finally, for data of the 
 'set'
  type, we create a change reflecting the latest 
 operation. After adding the new change to the change list, we also remove 
 changes that are no longer necessary. Then we update the value of the data item.
  
 Things are getting clear. Here is what's happening to these data types when 
 update
  is 
 called:
  
 1. Create new change.
  
 2. Merge the new change to the change list.
  
 3. 
  
 Apply the new change to the data item.
  
 Now it's even better. Every step is different for different data types, but different steps share 
 the same outline; what we need to do is to implement different strategies for different data 
 types.",NA
Implementing strategies,"Doing all kind of changes with a single 
 update
  function could be confusing. And before we 
 move on, let's split it into three different methods: 
 update
  for normal values, 
 increase
  for 
 incremental values, and 
 addTo
 /
 removeFrom
  for sets.
  
 Then we are going to create a new private method called 
 applyChange
 , which will take the 
 change created by other methods and continue with step 2 and step 3. It accepts a strategy 
 object with two methods: 
 append
  and 
 apply
 :
  
 interface ClientChangeStrategy<T extends ClientChange> { append(list: 
 ClientChangeList<T>, change: T): void; apply(item: ClientDataItem<any>, 
 change: T): void; }
  
 For a normal data item, the strategy object could be as follows:
  
 let strategy: ClientChangeStrategy<ClientValueChange<any>> = { append(list, change) {
  
   
  list.changes = [change];
  
  },
  
  apply(item, change) {
  
   
  item.value = change.value;
  
  } 
  
 };
  
 And for incremental data item, it takes a few more lines. First, the 
 append
  method:
  
 let changes = list.changes; 
  
 let lastChange = changes[changes.length];
  
 if (!lastChange || lastChange.synced) { changes.push(change); 
  
 } else {
  
  lastChange.increment += change.increment; }
  
 The 
 append
  method is followed by the 
 apply
  method:
  
 if (item.value === undefined) {
  
  item.value = change.increment; 
  
 } else {
  
  item.value += change.increment; 
  
 }
  
 [ 63 ]",NA
Wrapping stores,"We are going to make a lightweight wrapper around plain in-memory store objects with the 
 ability to read and write, taking the server-side store as an example:
  
 export class ServerStore {
  
  private items: {
  
   
  [id: string]: ServerDataItem<any>;
  
  } = Object.create(null); 
  
 }
  
 export class Server {
  
  constructor(
  
   
  public store: ServerStore
  
  ) { } 
  
 }
  
 To fit our requirements, we need to implement 
 get
 , 
 set
 , and 
 getAll
  methods (or even 
 better, a 
 find
  method with conditions) for 
 ServerStore
 :
  
 get<T, TExtra extends ServerDataItemExtra>(id: string): ServerDataItem<T> & 
 TExtra {
  
  return hasOwnProperty.call(this.items, id) ?
  
  
  this.items[id] as ServerDataItem<T> & TExtra : undefined; }
  
 set<T, TExtra extends ServerDataItemExtra>( id: string,
  
  item: ServerDataItem<T> & Textra 
  
 ): void {
  
  this.items[id] = item; 
  
 }
  
 getAll<T, TExtra extends ServerDataItemExtra>(): 
 (ServerDataItem<T> & TExtra)[] {
  
  let items = this.items;
  
  return Object
  
   
  .keys(items)",NA
Summary,"In this chapter, we've been part of the evolution of a simplified yet reality-related project.
  
 Starting with a simple code base that couldn't be wrong, we added a lot of features and 
 experienced the process of putting acceptable changes together and making the whole thing 
 a mess.
  
 We were always trying to write readable code by either naming things nicely or adding 
 semantically necessary redundancies, but that won't help much as the complexity grows.
  
 During the process, we've learned how offline synchronizing works. And with the help of 
 the most common design patterns, such as the Strategy Pattern, we managed to split the 
 project into small and controllable parts.
  
 In the upcoming chapters, we'll catalog more useful design patterns with code examples in 
 TypeScript, and try to apply those design patterns to specific issues.
  
 [ 65 ]",NA
Creational Design Patterns ,NA,NA
,"Creational design patterns in object-oriented programming are design patterns that are to be 
 applied during the instantiation of objects. In this chapter, we'll be talking about patterns in 
 this category.
  
 Consider we are building a rocket, which has payload and one or more stages:
  
 class Payload {
  
  weight: number; 
  
 }
  
 class Engine {
  
  thrust: number; 
  
 }
  
 class Stage {
  
  engines: Engine[]; 
  
 }
  
 In old-fashioned JavaScript, there are two major approaches to building such a rocket:
  
 Constructor with 
 new
  operator
  
 Factory function
  
 For the first approach, things could be like this:
  
 function Rocket() {
  
  this.payload = {
  
   
  name: 'cargo ship'
  
  };
  
  this.stages = [",NA
Factory method,"Under some scenarios, a class cannot predict exactly what objects it will create, or its 
 subclasses may want to create more specified versions of these objects. Then, the Factory 
 Method Pattern can be applied.
  
 The following picture shows the possible structure of the Factory Method Pattern applied to 
 creating rockets:
  
  
 A 
 factory method
  is a method of a factory that builds objects. Take building rockets as an 
 example; a factory method could be a method that builds either the entire rocket or a single 
 component. One factory method might rely on other factory methods to build its target 
 object. For example, if we have a 
 createRocket
  method under the 
 Rocket
  class, it would 
 probably call factory methods like 
 createStages
  and 
 createPayload
  to get the necessary 
 components.",NA
Participants ,"The participants of a typical Factory Method Pattern implementation include the following:
  
 Product: 
 Rocket 
  
 Define an abstract class or an interface of a rocket that will be created as 
 the product.
  
 Concrete product: 
 FreightRocket 
  
   
 Implement a specific rocket product.
  
 Creator: 
 RocketFactory 
  
   
 Define the optionally abstract factory class that creates products.
  
  
 Concrete creator: 
 FreightRocketFactory 
  
 Implement or overrides specific factory methods to build products on demand.",NA
Pattern scope ,"The Factory Method Pattern decouples 
 Rocket
  from the constructor implementation and 
 makes it possible for subclasses of a factory to change what's built accordingly. A concrete 
 creator still cares about what exactly its components are and how they are built. But the 
 implementation or overriding usually focuses more on each component, rather than the 
 entire product.",NA
Implementation ,"Let's begin with building a simple one-stage rocket that carries a 0-weight payload as the 
 default implementation: 
  
  
 class RocketFactory {
  
 [ 69 ]",NA
Consequences,"In the preceding implementation, the factory method 
 buildRocket
  handles the outline of the 
 building steps. We were lucky to have the freight rocket in the same structure as the very 
 first rocket we had defined.
  
 But that won't always happen. If we want to change the class of products (
 Rocket
 ), we'll 
 have to override the entire 
 buildRocket
  with everything else but the class name. This looks 
 frustrating but it can be solved, again, by decoupling the creation of a rocket instance from 
 the building process:
  
 buildRocket(): Rocket { 
  
  
 let rocket = this.createRocket();
  
  let payload = this.createPayload();
  
  let stages = this.createStages();
  
  rocket.payload = payload;
  
  rocket.stages = stages;
  
  return rocket; 
  
 }
  
 createRocket(): Rocket {
  
  return new Rocket(); 
  
 }
  
 Thus we can change the rocket class by overriding the 
 createRocket
  method. However, the 
 return type of the 
 buildRocket
  of a subclass (for example, 
 FreightRocketFactory
 )",NA
Abstract Factory,"The Abstract Factory Pattern usually defines the interfaces of a collection of factory 
 methods, without specifying concrete products. This allows an entire factory to be 
 replaceable, in order to produce different products following the same production outline:",NA
Participants ,"The participants of a typical Abstract Factory Pattern implementation include the following:
  
 Abstract factory
 : 
 RocketFactory 
  
 Defines the 
 industrial standards
  of a factory which provide interfaces for 
 manufacturing components or complex products.
  
 Concrete factory
 : 
 ExperimentalRocketFactory
 , 
 FreightRocketFactory 
 Implements the 
 interfaces defined by the abstract factory and builds concrete products.
  
 Abstract products
 : 
 Rocket
 , 
 Payload
 , 
 Stage[] 
  
   
 Define the interfaces of the products the factories are going to build.
  
 Concrete products
 : 
 ExperimentalRocket
 /
 FreightRocket
 , 
  
 ExperimentalPayload
 /
 Satellite
 , and so on.
  
 Presents actual products that are manufactured by a concrete factory.
  
 Client
 : 
  
 Arranges the production process across factories (only if these factories 
 conform to 
 industrial standards
 ).
  
 [ 74 ]",NA
Pattern scope,"Abstract Factory Pattern makes the abstraction on top of different concrete factories. At the 
 scope of a single factory or a single branch of factories, it just works like the Factory Method 
 Pattern. However, the highlight of this pattern is to make a whole family of products 
 interchangeable. A good example could be components of themes for a UI implementation.",NA
Implementation,"In the Abstract Factory Pattern, it is the client interacting with a concrete factory for 
 building integral products. However, the concrete class of products is decoupled from the 
 client during design time, while the client cares only about what a factory and its products 
 look like instead of what exactly they are.
  
 Let's start by simplifying related classes to interfaces:
  
 interface Payload {
  
  weight: number; 
  
 }
  
 interface Stage {
  
  engines: Engine[]; 
  
 }
  
 interface Rocket {
  
  payload: Payload;
  
  stages: Stage[]; 
  
 }
  
 And of course the abstract factory itself is:
  
 interface RocketFactory {
  
  createRocket(): Rocket;
  
  createPayload(): Payload;
  
  createStages(): Stage[]; 
  
 }
  
 The building steps are abstracted from the factory and put into the client, but we still need 
 to implement it anyway:
  
 class Client {
  
  buildRocket(factory: RocketFactory): Rocket {
  
  
  let 
 rocket = factory.createRocket();",NA
Consequences,"The Abstract Factory Pattern makes it easy and smooth to change the entire family of 
 products. This is the direct benefit brought by the factory level abstraction. As a 
  
 consequence, it also brings other benefits, as well as some disadvantages at the same time.
  
 On the one hand, it provides better compatibility within the products in a specific family. As 
 the products built by a single factory are usually meant to work together, we can assume 
 that they tend to cooperate more easily.
  
 But on the other hand, it relies on a common outline of the building process, although for a 
 well-abstracted building process, this won't always be an issue. We can also parameterize 
 factory methods on both concrete factories and the client to make the process more flexible.
  
 Of course, an abstract factory does not have to be a pure interface or an abstract class with 
 no methods implemented. An implementation in practice should be decided based on 
 detailed context.
  
 Although the Abstract Factory Pattern and Factory Method Pattern have abstractions of 
 different levels, what they encapsulate are similar. For building a product with multiple 
 components, the factories split the products into components to gain flexibility. However, a 
 fixed family of products and their internal components may not always satisfy the 
  
 requirements, and thus we may consider the Builder Pattern as another option.",NA
Builder,"While Factory Patterns expose the internal components (such as the payload and stages of a 
 rocket), the Builder Pattern encapsulates them by exposing only the building steps and 
 provides the final products directly. At the same time, the Builder Pattern also encapsulates 
 the internal structures of a product. This makes it possible for a more flexible abstraction 
 and implementation of building complex objects.",NA
Participants,"The participants of a typical Builder Pattern implementation include the following:
  
 Builder
 : 
 RocketBuilder
  
 Defines the interface of a builder that builds products.
  
 Concrete builder
 : 
 FalconBuilder
  
 Implements methods that build parts of the products, and keeps track of the 
 current building state.",NA
Pattern scope,"The Builder Pattern has a similar scope to the Abstract Factory Pattern, which extracts 
 abstraction from a complete collection of operations that will finally initiate the products. 
 Compared to the Abstract Factory Pattern, a builder in the Builder Pattern focuses more on 
 the building steps and the association between those steps, while the Abstract Factory 
 Pattern puts that part into the clients and makes its factory focus on producing components.",NA
Implementation,"As now we are assuming that stages are not the concern of the clients who want to buy 
 rockets to carry their payloads, we can remove the 
 stages
  property from the general 
 Rocket
  interface:
  
 interface Rocket {
  
  payload: Payload; 
  
 }
  
 There is a rocket family called sounding rocket that sends probes to near space. And this 
 means we don't even need to have the concept of stages. 
 SoundingRocket
  is going to have 
 only one 
 engine
  property other than 
 payload
  (which will be a 
 Probe
 ), and the only engine will 
 be a 
 SolidRocketEngine
 :
  
 class Probe implements Payload {
  
  weight: number; 
  
 }
  
 class SolidRocketEngine extends Engine { }
  
 class SoundingRocket implements Rocket { payload: 
 Probe;
  
  engine: SolidRocketEngine; 
  
 }",NA
Consequences,"As the Builder Pattern takes greater control of the product structures and how the building 
 steps influence each other, it provides the maximum flexibility by subclassing the builder 
 itself, without changing the director (which plays a similar role to a client in the Abstract 
 Factory Pattern).",NA
Prototype,"As JavaScript is a prototype-based programming language, you might be using prototype 
 related patterns all the time without knowing it.
  
 We've talked about an example in the Abstract Factory Pattern, and part of the code is like 
 this:
  
 class FreightRocketFactory 
  
 implements RocketFactory<FreightRocket> { 
 createRocket(): FreightRocket {
  
   
  return new FreightRocket();
  
  } 
  
 }
  
 Sometimes we may need to add a subclass just for changing the class name while 
 performing the same 
 new
  operation. Instances of a single class usually share the same 
 methods and properties, so we can 
 clone
  one existing instance for new instances to be 
 created. That is the concept of a prototype.
  
 But in JavaScript, with the prototype concept built-in, 
 new Constructor()
  does basically 
 what a 
 clone
  method would do. So actually a constructor can play the role of a concrete 
 factory in some way:
  
 interface Constructor<T> {
  
  new (): T; 
  
 }
  
 function createFancyObject<T>(constructor: Constructor<T>): T { return new 
 constructor(); 
  
 }",NA
Singleton,"There are scenarios in which only one instance of the specific class should ever exist, and 
 that leads to Singleton Pattern.",NA
Basic implementations,"The simplest singleton in JavaScript is an object literal; it provides a quick and cheap way to 
 create a unique object:
  
 const singleton = {
  
  foo(): void {
  
   
  console.log('bar');
  
  } 
  
 };",NA
Conditional singletons,"Sometimes we might want to get 
 “
 singletons
 ”
  based on certain conditions. For example, 
 every country usually has only one capital city, thus a capital city could be treated as a 
 singleton under the scope of the specific country.
  
 The condition could also be the result of context rather than explicit arguments. Assuming 
 we have a class 
 Environment
  and its derived classes, 
 WindowsEnvironment
  and 
 UnixEnvironment
 , we would like to access the correct environment singleton across 
 platforms by using 
 Environment.default
  and apparently, a selection could be made by the 
 default
  getter.
  
 For more complex scenarios, we might want a registration-based implementation to make it 
 extendable.",NA
Summary,"In this chapter, we've talked about several important creational design patterns including 
 the Factory Method, Abstract Factory, Builder, Prototype, and Singleton.
  
 Starting with the Factory Method Pattern, which provides flexibility with limited 
  
 complexity, we also explored the Abstract Factory Pattern, the Builder Pattern and the 
 Prototype Pattern, which share similar levels of abstraction but focus on different aspects. 
 These patterns have more flexibility than the Factory Method Pattern, but are more complex 
 at the same time. With the knowledge of the idea behind each of the patterns, we should be 
 able to choose and apply a pattern accordingly.
  
 While comparing the differences, we also found many things in common between different 
 creational patterns. These patterns are unlikely to be isolated from others and some of them 
 can even collaborate with or complete each other.
  
 In the next chapter, we'll continue to discuss structural patterns that help to form large 
 objects with complex structures.",NA
Structural Design Patterns ,NA,NA
,"While creational patterns play the part of flexibly creating objects, structural patterns, on 
 the other hand, are patterns about composing objects. In this chapter, we are going to talk 
 about structural patterns that fit different scenarios.
  
 If we take a closer look at structural patterns, they can be divided into 
 structural class 
 patterns
  and 
 structural object patterns
 . Structural class patterns are patterns that play 
 with
 “
 interested parties
 ”
  themselves, while structural object patterns are patterns that 
 weave pieces together (like Composite Pattern). These two kinds of structural patterns 
 complement each other to some degree.
  
 Here are the patterns we'll walk through in this chapter:
  
 Composite
 : Builds tree-like structures using primitive and composite objects. A 
  
 good example would be the DOM tree that forms a complete page.
  
 Decorator
 : Adds functionality to classes or objects dynamically.
  
 Adapter
 : Provides a general interface and work with different adaptees by 
 implementing different concrete adapters. Consider providing different database 
 choices for a single content management system.
  
 Bridge
 : Decouples the abstraction from its implementation, and make both of 
  
 them interchangeable.
  
 Façade
 : Provides a simplified interface for the combination of complex 
  
 subsystems.
  
 Flyweight
 : Shares stateless objects that are being used many times to improve 
  
 memory efficiency and performance.",NA
Composite Pattern,"Objects under the same class could vary from their properties or even specific subclasses, 
 but a complex object can have more than just normal properties. Taking DOM elements, for 
 example, all the elements are instances of class 
 Node
 . These nodes form tree structures to 
 represent different pages, but every node in these trees is complete and uniform compared 
 to the node at the root:
  
 <html>
  
  <head>
  
   
  <title>TypeScript</title>
  
  </head>
  
  <body>
  
   
  <h1>TypeScript</h1>
  
   
  <img />
  
  </body> 
  
 </html>
  
 The preceding HTML represents a DOM structure like this:
  
  
 All of the preceding objects are instances of 
 Node
 , they implement the interface of a 
 component
  in Composite Pattern. Some of these nodes like HTML elements (except for 
 HTMLImageElement
 ) in this example have child nodes (components) while others don't.",NA
Participants,"The participants of Composite Pattern implementation include:
  
 Component
 : 
 Node
  
 Defines the interface and implement the default behavior for objects of the 
 composite. It should also include an interface to access and manage the child 
 components of an instance, and optionally a reference to its parent.
  
 Composite
 : Includes some HTML elements, like 
 HTMLHeadElement
  and 
  
 HTMLBodyElement
  
 Stores child components and implements related operations, and of course its 
 own behaviors.
  
 Leaf
 : 
 TextNode
 , 
 HTMLImageElement
  
 Defines behaviors of a primitive component.
  
 Client
 :
  
 Manipulates the composite and its components.",NA
Pattern scope,"Composite Pattern applies when objects can and should be abstracted recursively as 
 components that form tree structures. Usually, it would be a natural choice when a certain 
 structure needs to be formed as a tree, such as trees of view components, abstract syntax 
 trees, or trees that represent file structures.",NA
Implementation,"We are going to create a composite that represents simple file structures and has limited 
 kinds of components.
  
 First of all, let's import related node modules:
  
 import * as Path from 'path'; 
  
 import * as FS from 'fs';",NA
Consequences,"Both the primitive object and composite object in Composite Pattern share the component 
 interface, which makes it easy for developers to build a composite structure with fewer 
 things to remember.
  
 It also enables the possibility of using markup languages like XML and HTML to represent 
 a really complex object with extreme flexibility. Composite Pattern can also make the 
 rendering easier by having components rendered recursively.
  
 As most components are compatible with having child components or being child 
 components of their parents themselves, we can easily create new components that work 
 great with existing ones.
  
 [ 94 ]",NA
Decorator Pattern,"Decorator Pattern adds new functionality to an object dynamically, usually without 
 compromising the original features. The word decorator in Decorator Pattern does share 
 something with the word decorator in the ES-next decorator syntax, but they are not exactly 
 the same. Classical Decorator Pattern as a phrase would differ even more.
  
 The classical Decorator Pattern works with a composite, and the brief idea is to create 
 decorators as components that do the decorating work. As composite objects are usually 
 processed recursively, the decorator components would get processed automatically. So it 
 becomes your choice to decide what it does.
  
 The inheritance hierarchy could be like the following structure shown:
  
  
 The decorators are applied recursively like this:
  
  
 [ 95 ]",NA
Participants,"The participants of classical Decorator Pattern implementation include:
  
 Component
 : 
 UIComponent",NA
Pattern scope,"Decorator Pattern usually cares about objects, but as JavaScript is prototype-based, 
 decorators would work well with the classes of objects through their prototypes.
  
 The classical implementation of Decorator Pattern could have much in common with other 
 patterns we are going to talk about later, while the function one seems to share less.",NA
Implementation,"In this part, we'll talk about two implementations of Decorator Pattern. The first one would 
 be classical Decorator Pattern that decorates the target by wrapping with new classes that 
 conform to the interface of 
 UIComponent
 . The second one would be decorators written in 
 new decorator syntax that processes target objects.",NA
Classical decorators,"Let's get started by defining the outline of objects to be decorated. First, we'll have the 
 UIComponent
  as an abstract class, defining its abstract function 
 draw
 :
  
 abstract class UIComponent {
  
  abstract draw(): void; 
  
 }",NA
Decorators with ES-next syntax,"There is a limitation with classical Decorator Pattern that can be pointed out directly via its 
 nesting form of decorating. That applies to ES-next decorators as well. Take a look at the 
 following example:
  
 class Foo {
  
  @prefix
  
  @suffix
  
  getContent(): string {
  
   
  return '...';
  
  } 
  
 }
  
 What follows the 
 @
  character is an expression that evaluates to a decorator. 
 While a decorator is a function that processes target objects, we usually use 
 higher-order functions to parameterize a decorator.
  
 We now have two decorators 
 prefix
  and 
 suffix
  decorating the 
 getContent
  method. It seems 
 that they are just parallel at first glance, but if we are going to add a prefix and suffix onto 
 the content returned, like what the name suggests, the procedure would actually be 
 recursive rather than parallel just like the classical implementation.
  
 To make decorators cooperate with others as we'd expect, we need to handle things 
 carefully:
  
 function prefix(
  
  target: Object,
  
  name: string,
  
  descriptor: PropertyDescriptor 
  
 ): PropertyDescriptor {
  
  let method = descriptor.value as Function;
  
  if (typeof method !== 'function') {
  
  
  throw new Error('Expecting decorating a method'); }",NA
Consequences,"The key to the Decorator Pattern is being able to add functionalities dynamically, and 
 decorators are usually expected to play nice with each other. Those expectations of 
 Decorator Pattern make it really flexible to form a customized object. However, it would be 
 hard for certain types of decorators to actually work well together.
  
 Consider decorating an object with multiple decorators just like the second example of 
 implementation, would the decorating order matter? Or should the decorating order 
 matter?
  
 A properly written decorator should always work no matter where it is in the decorators 
 list. And it's usually 
 preferred
  that the decorated target behaves almost the same with 
 decorators decorated in different orders.",NA
Adapter Pattern,"Adapter Pattern connects existing classes or objects with another existing client. It makes 
 classes that are not designed to work together possible to cooperate with each other.",NA
Participants ,"The participants of Adapter Pattern include:
  
 Target: 
 Storage 
  
   
 Defines the interface of existing targets that works with client
  
 Adaptee
 : 
 IndexedDB 
  
   
 The implementation that is not designed to work with the client
  
 Adapter
 : 
 IndexedDBStorage 
  
   
 Conforms the interface of target and interacts with adaptee
  
 Client
 .
  
 Manipulates the target",NA
Pattern scope ,"Adapter Pattern can be applied when the existing client class is not designed to work with 
 the existing adaptees. It focuses on the unique 
 adapter
  part when applying to different 
 combinations of clients and adaptees.",NA
Implementation ,"Start with the 
 Storage
  interface: 
  
  
 interface Storage {
  
  get<T>(key: string): Promise<T>;
  
  set<T>(key: string, value: T): Promise<void>;
  
 }
  
 We defined the 
 get
  method with generic, so that if we neither specify the 
 generic type, nor cast the value type of a returned Promise, the type of the 
 value would be 
 {}
 . This would probably fail following type checking.
  
 [ 103 ]",NA
Consequences,"By applying Adapter Pattern, we can fill the gap between classes that originally would not 
 work together. In this situation, Adapter Pattern is quite a straightforward solution that 
 might come to mind.
  
 But in other scenarios like a debugger 
 adapter
  for debugging extensions of an IDE, the 
 implementation of Adapter Pattern could be more challenging.",NA
Bridge Pattern,"Bridge Pattern decouples the abstraction manipulated by clients from functional 
 implementations and makes it possible to add or replace these abstractions and 
 implementations easily.
  
 Take a set of 
 cross-API
  UI elements as an example:
  
  
 We have the abstraction 
 UIElement
  that can access different implementations of 
 UIToolkit
  for creating different UI based on either SVG or canvas. In the preceding 
 structure, the 
 bridge
  is the connection between 
 UIElement
  and 
 UIToolkit
 .",NA
Participants,"The participants of Bridge Pattern include:
  
 Abstraction: 
 UIElement
  
 Defines the interface of objects to be manipulated by the client and stores the 
 reference to its implementer.
  
 Refined abstraction
 : 
 TextElement
 , 
 ImageElement
  
 Extends abstraction with specialized behaviors.
  
 Implementer
 : 
 UIToolkit
  
 Defines the interface of a general implementer that will eventually carry out 
 the operations defined in abstractions. The implementer usually cares only 
 about basic operations while the abstraction will handle high-level 
  
 operations.
  
 Concrete implementer
 : 
 SVGToolkit
 , 
 CanvasToolkit
  
 Implements the implementer interface and manipulates low-level APIs.",NA
Pattern scope,"Although having abstraction and implementer decoupled provides Bridge Pattern with the 
 ability to work with several abstractions and implementers, most of the time, bridge 
 patterns work only with a single implementer.
  
 If you take a closer look, you will find Bridge Pattern is extremely similar to Adapter 
 Pattern. However, while Adapter Pattern tries to make existing classes cooperate and 
 focuses on the adapters part, Bridge Pattern foresees the divergences and provides a well-
 thought-out and universal interface for its abstractions that play the part of adapters.",NA
Implementation,"A working implementation could be non-trivial in the example we are talking about. But we 
 can still sketch out the skeleton easily.",NA
Consequences,"Despite having completely different names for the abstraction (
 UIElement
 ) in the example 
 above and the adapter interface (
 Storage
 ), they play similar roles in a static combination.
  
 However, as we mentioned in the pattern scope section, the intentions of Bridge Pattern and 
 Adapter Pattern differ.
  
 By decoupling the abstraction and implementer, Bridge Pattern brings great extensibility to 
 the system. The client does not need to know about the implementation details, and this 
 helps to build more stable systems as it forms a healthier dependency structure.
  
 Another bonus that might be brought by Bridge Pattern is that, with a properly configured 
 build process, it can reduce compilation time as the compiler does not need to know 
 information on the other end of the bridge when changes are made to a refined abstraction 
 or concrete implementer.",NA
Façade Pattern,"The Façade Pattern organizes subsystems and provides a unified higher-level interface. An 
 example that might be familiar to you is a modular system. In JavaScript (and of course 
 TypeScript), people use modules to organize code. A modular system makes projects easier 
 to maintain, as a clean project structure can help reveal the interconnections among different 
 parts of the project.
  
 It is common that one project gets referenced by others, but obviously the project that 
 references other projects doesn't and shouldn't care much about the inner structures of its 
 dependencies. Thus a façade can be introduced for a dependency project to provide a 
 higher-level API and expose what really matters to its dependents.
  
 Take a robot as an example. People who build a robot and its components will need to 
 control every part separately and let them cooperate at the same time. However, people 
 who want to use this robot would only need to send simple commands like 
 “
 walk
 ”
  
 and
 “
 jump
 ”
 .
  
 For the most flexible usage, the robot 
 “
 SDK
 ”
  can provide classes like 
 MotionController
 , 
 FeedbackController
 , 
 Thigh
 , 
 Shank
 , 
 Foot
  and so on. Possibly like the following image shows:
  
  
 [ 110 ]",NA
Participants,"The participants of a Façade Pattern are relatively simple when it comes to their categories:
  
 Façade
 : 
 Robot
  
 Defines a set of higher-level interfaces, and makes subsystems cooperate.
  
 Subsystems
 : 
 MotionController
 , 
 FeedbackController
 , 
 Thigh
 , 
 Shank
  and 
  
 Foot
  
 Implements their own functionalities and communicates internally with other 
 subsystems if necessary. Subsystems are dependencies of a façade, and they 
 do not depend on the façade.
  
 [ 111 ]",NA
Pattern scope,"Façades usually act as junctions that connect a higher-level system and its subsystems. The 
 key to the Façade Pattern is to draw a line between what a dependent should or shouldn't 
 care about of its dependencies.",NA
Implementation,"Consider putting up a robot with its left and right legs, we can actually add another 
 abstraction layer called 
 Leg
  that manages 
 Thigh
 , 
 Shank
  , and 
 Foot
 . If we are going to 
 separate motion and feedback controllers to different legs respectively, we may also add 
 those two as part of the 
 Leg
 :
  
 class Leg {
  
  thigh: Thigh;
  
  shank: Shank;
  
  foot: Foot;
  
  motionController: MotionController; feedbackController: 
 FeedbackController; }
  
 Before we add more details to 
 Leg
 , let's first define 
 MotionController
  and 
 FeedbackController
  .
  
 The 
 MotionController
  is supposed to control a whole leg based on a value or a set of 
 values. Here we are simplifying that as a single angle for not being distracted by this 
 impossible robot:
  
 class MotionController {
  
  constructor(
  
   
  public leg: Leg
  
  ) { }
  
  setAngle(angle: number): void {
  
  
  let {
  
   
  thigh,
  
   
  shank,
  
   
  foot
  
  
  } = this.leg;
  
   
  // ...
  
  } 
  
 }",NA
Consequences,"Façade Pattern loosens the coupling between client and subsystems. Though it does not 
 decouple them completely as you will probably still need to work with objects defined in 
 subsystems.
  
 Façades usually forward operations from client to proper subsystems or even do heavy 
 work to make them work together.
  
 With the help of Façade Pattern, the system and the relationship and structure within the 
 system can stay clean and intuitive.",NA
Flyweight Pattern,"A flyweight in Flyweight Pattern is a stateless object that can be shared across objects or 
 maybe classes many times. Obviously, that suggests Flyweight Pattern is a pattern about 
 memory efficiency and maybe performance if the construction of objects is expensive.
  
 Taking drawing snowflakes as an example. Despite real snowflakes being different to each 
 other, when we are trying to draw them onto canvas, we usually have a limited number of 
 styles. However, by adding 
 properties
  like sizes and transformations, we can create a 
 beautiful snow scene with limited snowflake styles.
  
 As a flyweight is stateless, ideally it allows multiple operations simultaneously. You might 
 need to be cautious when working with multi-thread stuff. Fortunately, JavaScript is 
 usually single-threaded and avoids this issue if all related code is synchronous. You will 
 still need to take care in detailed scenarios if your code is working asynchronously.",NA
Participants ,"The simplest implementation of Flyweight Pattern has the following participants:
  
 Flyweight
 : 
 Snowflake 
  
   
 Defines the class of flyweight objects.
  
 Flyweight factory
 : 
 FlyweightFactory 
  
   
 Creates and manages flyweight objects.
  
 [ 115 ]",NA
Pattern scope,"Flyweight Pattern is a result of efforts to improving memory efficiency and performance. 
 The implementation cares about having the instances being stateless, and it is usually 
 the client that manages detailed states for different targets.",NA
Implementation,"What makes Flyweight Pattern useful in the snowflake example is that a snowflake with the 
 same style usually shares the same image. The image is what consumes time to load and 
 occupies notable memory.
  
 We are starting with a fake 
 Image
  class that pretends to load images:
  
 class Image {
  
  constructor(url: string) { } 
  
 }
  
 The 
 Snowflake
  class in our example has only a single 
 image
  property, and that is a 
 property that will be shared by many snowflakes to be drawn. As the instance is now 
 stateless, parameters from context are required for rendering:
  
 class Snowflake {
  
  image: Image;
  
  constructor(
  
  
  public style: string
  
  ) {
  
  
  let url = style + '.png';
  
  
  this.image = new Image(url);
  
  }
  
  render(x: number, y: number, angle: number): void {
  
  // ...
  
  }",NA
Consequences,"Flyweight Pattern reduces the total number of objects involved in a system. As a direct 
 result, it may save quite a lot memory. This saving becomes more significant when the 
 flyweights get used by the client that processes a large number of targets.
  
 Flyweight Pattern also brings extra logic into the system. When to use or not to use this 
 pattern is again a balancing game between development efficiency and runtime efficiency 
 from this point of view. Though most of the time, if there's not a good reason, we go with 
 development efficiency.",NA
Proxy Pattern,"Proxy Pattern applies when the program needs to know about or to intervene the behavior 
 of accessing objects. There are several detailed scenarios in Proxy Pattern, and we can 
 distinguish those scenarios by their different purposes:
  
 Remote proxy
 : A proxy with interface to manipulate remote objects, such as data 
  
 items on a remote server",NA
Participants ,"The participants of Proxy Pattern include:
  
 Proxy
 : 
 IndexedDBStorage
  
 Defines interface and implements operations to manage access to the subject.",NA
Pattern scope,"Despite having a similar structure to Adapter Pattern, the key of Proxy Pattern is to 
 intervene the access to target objects rather than to adapt an incompatible interface. 
 Sometimes it might change the result of a specific method or the value of a certain property, 
 but that is probably for falling back or exception  handling purposes.",NA
Implementation,"There are two differences we'll have in this implementation compared to the example for 
 pure Adapter Pattern. First, we'll create the 
 IndexedDBStorage
  instance with 
  
 a constructor, and have the database opened on demand. Second, we are going to add a 
 useless permission checking for methods 
 get
  and 
 set
 .
  
 Now when we call the method 
 get
  or 
 set
 , the database could either have been opened or 
 not. Promise is a great choice for representing a value that might either be pending or 
 settled. Consider this example:
  
 let ready = new Promise<string>(resolve => { setTimeout(() 
 => {
  
   
  resolve('biu~');
  
  }, Math.random() * 1000); 
  
 });
  
 setTimeout(() => {
  
  ready.then(text => {
  
   
  console.log(text);
  
  }); 
  
 }, 999);
  
 It's hard to tell whether Promise 
 ready
  is fulfilled when the second timeout fires. But the 
 overall behavior is easy to predict: it will log the 
 'biu~'
  text in around 1 second. By 
 replacing the Promise variable 
 ready
  with a method or getter, it would be able to start the 
 asynchronous operation only when needed.",NA
Consequences,"The implementation of Proxy Pattern can usually be treated as the encapsulation of the 
 operations to specific objects or targets. It is easy to have the encapsulation augmented 
 without extra burden on the client.
  
 For example, a working online database proxy could do much more than just acting like a 
 plain surrogate. It may cache data and changes locally, or synchronize on schedule without 
 the client being aware.",NA
Summary,"In this chapter, we learned about structural design patterns including Composite, 
 Decorator, Adapter, Bridge, Façade, Flyweight, and Proxy. Again we found some of these 
 patterns are highly inter related and even similar to each other to some degree.
  
 For example, we mixed Composite Pattern with Decorator Pattern, Adapter Pattern with 
 Proxy Pattern, compared Adapter Pattern and Bridge Pattern. During the journey of 
 exploring, we sometimes found it was just a natural result to have our code end in a pattern 
 that's similar to what we've listed if we took writing 
 better code
  into consideration.
  
 Taking Adapter Pattern and Bridge Pattern as an example, when we are trying to make two 
 classes cooperate, it comes out with Adapter Pattern and when we are planning on 
  
 connecting with different classes in advance, it goes with Bridge Pattern. There are no actual 
 lines between each pattern and the applications of those patterns, though the techniques 
 behind patterns could usually be useful.
  
 In the next chapter, we are going to talk about behavioral patterns that help to form 
 algorithms and assign the responsibilities.",NA
Behavioral Design Patterns ,NA,NA
,"As the name suggests, behavioral design patterns are patterns about how objects or classes 
 interact with each other. The implementation of behavioral design patterns usually requires 
 certain data structures to support the interaction in a system. However, behavioral patterns 
 and structural patterns focus on different aspects when applied. As a result, you might find 
 patterns in the category of behavioral design patterns usually have simpler or more 
 straightforward structures compared to structural design patterns.
  
 In this chapter, we are going to talk about some of the following common behavioral 
 patterns:
  
 Chain of Responsibility
 : Organizes behaviors with different scopes
  
 Command
 : Exposes commands from the internal with encapsulated context
  
 Memento
 : Provides an approach for managing states outside of their owners 
  
 without exposing detailed implementations
  
 Iterator
 : Provides a universal interface for traversing
  
 Mediator
 : It groups coupling and logically related objects and makes 
  
 interconnections cleaner in a system that manages many objects",NA
Chain of Responsibility Pattern,"There are many scenarios under which we might want to apply certain actions that can fall 
 back from a detailed scope to a more general one.",NA
Participants,"The participants of the Chain of Responsibility Pattern include:
  
 Handler
 : Defines the interface of the handler with successor and method to 
 handle requests. This is done implicitly with classes like 
 EventEmitter
  and 
 try...catch
  syntax.
  
 Concrete handler
 : 
 EventListener
 , 
 catch
  block and 
 HandlerA
 /
 HandlerB
  in the class 
 version. Defines handlers in the form of callbacks, code blocks and classes that 
 handle requests.
  
 Client
 : Initiates the requests that go through the chain.",NA
Pattern scope,"The Chain of Responsibility Pattern itself could be applied to many different scopes in a 
 program. It requires a multi-level chain to work, but this chain could be in different forms.
  
 We've been playing with events as well as 
 try...catch
  statements that have structural 
 levels, this pattern could also be applied to scenarios that have logical levels.
  
 Consider objects marked with different scopes using string:
  
 let objectA = {
  
  scope: 'user.installation.package' 
  
 };
  
 let objectB = {
  
  scope: 'user.installation' 
  
 };
  
 Now we have two objects with related scopes specified by string, and by adding filters to 
 these scope strings, we can apply operations from specific ones to general ones.",NA
Implementation,"In this part, we are going to implement the class version we've mentioned at the end of the 
 introduction to the Chain of Responsibility Pattern. Consider requests that could either 
 ask for help information or feedback prompts:
  
 type RequestType = 'help' | 'feedback';
  
 interface Request {
  
  type: RequestType; 
  
 }
  
 We are using string literal type here with union type. It is a pretty useful 
 feature provided in TypeScript that plays well with existing JavaScript 
 coding styles.
  
 See the following link for more information: 
 http://www.typescriptlang 
 .org/docs/handbook/advanced-types.html
 .
  
 One of the key processes for this pattern is going through the handlers' chain and finding 
 out the most specific handler that's available for the request. There are several ways to 
 achieve this: by recursively invoking the 
 handle
  method of a successor, or having a separate 
 logic walking through the handler successor chain until the request is confirmed as handled.",NA
Consequences,"The Chain of Responsibility Pattern decouples the connection between objects that issue the 
 requests and logic that handles those requests. The sender assumes that its requests could, 
 but not necessarily, be properly handled without knowing the details. For some 
  
 implementations, it is also very easy to add new responsibilities to a specific handler on the 
 chain. This provides notable flexibility for handling requests.
  
 Besides the examples we've been talking about, there is another important mutation of 
 try...catch
  that can be treated in the Chain of Responsibility Pattern 
 –
  Promise. Within a 
 smaller scope, the chain could be represented as:
  
 promise
  
  .catch(TypeError, reason => {
  
   
  // handles TypeError.
  
  })
  
  .catch(ReferenceError, reason => {
  
  
  // handles ReferenceError.
  
  })
  
  .catch(reason => {
  
  
  // handles other errors.
  
  });
  
 The standard 
 catch
  method on an ES Promise object does not provide the 
 overload that accepts an error type as a parameter, but many 
  
 implementations do.
  
 In a larger scope, this chain would usually appear when the code is playing with third-party 
 libraries. A common usage would be converting errors produced by other libraries to errors 
 known to the current project. We'll talk more about error handling of asynchronous code 
 later in this book.",NA
Command Pattern,"Command Pattern involves encapsulating operations as executable commands and could 
 either be in the form of objects or functions in JavaScript. It is common that we may want to 
 make operations rely on certain context and states that are not accessible for the invokers.
  
 By storing those pieces of information with a command and passing it out, this situation 
 could be properly handled.",NA
Participants,"The participants of Command Pattern include:
  
 Command
 : Defines the general interface of commands passing around, it could 
  
 be a function signature if the commands are in the form of functions.
  
 Concrete command
 : Defines the specific behaviors and related data structure. It 
 could also be a function that matches the signature declared as 
 Command
 . The 
 cancel
  handler in the very first example is a concrete command.
  
 Context
 : The context or receiver that the command is associated with. In the first 
  
 example, it is the 
 $layer
 .
  
 Client
 : Creates concrete commands and their contexts.
  
 Invoker
 : Executes concrete commands.",NA
Pattern scope,"Command Pattern suggests two separate parts in a single application or a larger system: 
 client
  and 
 invoker
 . In the simplified example 
 wait
  and 
 cancel
 , it could be hard to 
  
 distinguish the difference between those parts. But the line is clear: 
 client
  knows or controls 
 the context of commands to be executed with, while 
 invoker
  does not have access or does 
 not need to care about that information.
  
 The key to the Command Pattern is the separation and bridging between those two parts 
 through commands that store context and states.",NA
Implementation,"It's common for an editor to expose commands for third-party extensions to modify the text 
 content. Consider a 
 TextContext
  that contains information about the text file being edited and 
 an abstract 
 TextCommand
  class associated with that context:
  
 class TextContext {
  
  content = 'text content'; 
  
 }
  
 abstract class TextCommand {
  
  constructor(
  
   
  public context: TextContext
  
  ) { }
  
  abstract execute(...args: any[]): void; }
  
 Certainly, 
 TextContext
  could contain much more information like language, encoding, and 
 so on. You can add them in your own implementation for more functionality. Now we are 
 going to create two commands: 
 ReplaceCommand
  and 
 InsertCommand
 .
  
 class ReplaceCommand extends TextCommand {
  
  execute(index: number, length: number, text: string): void {
   
  let content = 
 this.context.content;
  
   
  this.context.content =
  
    
  content.substr(0, index) +
  
    
  text +
  
    
  content.substr(index + length);
  
  } 
  
 }
  
 class InsertCommand extends TextCommand {
  
  execute(index: number, text: string): void {
  
  
  let 
 content = this.context.content;
  
   
  this.context.content =
  
    
  content.substr(0, index) +
  
    
  text +
  
    
  content.substr(index);
  
  } 
  
 }",NA
Consequences,"Command Pattern decouples the client (who knows or controls context) and the invoker 
 (who has no access to or does not care about detailed context).",NA
Memento Pattern,"We've talked about an undo support implementation in the previous section on the 
 Command Pattern, and found it was not easy to implement the mechanism purely based on 
 reversing all the operations. However, if we take snapshots of objects as their history, we 
 may manage to avoid accumulating mistakes and make the system more stable. But then we 
 have a problem: we need to store the states of objects while the states are encapsulated with 
 objects themselves.
  
 Memento Pattern helps in this situation. While a memento carries the state of an object at a 
 certain time point, it also controls the process of setting the state back to an object. This 
 makes the internal state implementation hidden from the undo mechanism in the following 
 example:",NA
Participants,"The participants of Memento Pattern include:
  
 Memento
 : Stores the state of an object and defines method 
 restore
  or other 
  
 APIs for restoring the states to specific objects
  
 Originator
 : Deals with objects that need to have their internal states stored
  
 Caretaker
 : Manages mementos without intervening with what's inside",NA
Pattern scope,"Memento Pattern mainly does two things: it prevents the caretaker from knowing the 
 internal state implementation and decouples the state retrieving and restoring process from 
 states managed by the 
 Caretaker
  or 
 Originator.
  
 When the state retrieving and restoring processes are simple, having separated mementos 
 does not help much if you are already keeping the decoupling idea in mind.",NA
Implementation,"Start with an empty 
 State
  interface and 
 Memento
  class. As we do not want 
 Caretaker
  to know 
 the details about state inside an 
 Originator
  or 
 Memento
 , we would like to make 
 state
  property 
 of 
 Memento
  private. Having restoration logic inside 
 Memento
  does also help with this, and 
 thus we need method 
 restore
 . So that we don't need to expose a public interface for reading 
 state inside a memento.
  
 And as an object assignment in JavaScript assigns only its reference, we would like to do a 
 quick copy for the states (assuming state objects are single-level):
  
 interface State { }
  
 class Memento {
  
  private state: State;",NA
Consequences,"Memento Pattern makes it easier for a caretaker to manage the states of originators and it 
 becomes possible to extend state retrieving and restoring. However, a perfect 
  
 implementation that seals everything might rely on language features as we've mentioned 
 before. Using mementos could also bring a performance cost as they usually contain 
 redundant information in trade of stability.",NA
Iterator Pattern,"Iterator Pattern provides a universal interface for accessing internal elements of an 
 aggregate without exposing the underlying data structure. A typical iterator contains the 
 following methods or getters:
  
 first()
 : moves the cursor to the 
 first
  element in the aggregates
  
 next()
 : moves the cursor to the 
 next
  element
  
 end
 : a getter that returns a Boolean indicates whether the cursor is at the end
  
 item
 : a getter that returns the element at the position of the current cursor
  
 index
 : a getter that returns the index of the element at the current cursor
  
 Iterators for aggregates with different interfaces or underlying structures usually end with 
 different implementations as shown in the following figure:",NA
Participants,"The participants of Iterator Pattern include:
  
 Iterator
 : 
 AbstractListIterator
  
 Defines the universal iterator interface that is going to transverse different 
 aggregates.
  
 Concrete iterator
 : 
 ListIterator
 , 
 SkipListIterator
  and 
  
 ReversedListIterator
  
 Implements specific iterator that transverses and keeps track of a specific 
 aggregate.
  
 Aggregate
 : 
 AbstractList
  
 Defines a basic interface of aggregates that iterators are going to work with.
  
 Concreate aggregate
 : 
 List
  and 
 SkipList
  
 Defines the data structure and factory method/getter for creating associated 
 iterators.",NA
Pattern scope,"Iterator Pattern provides a unified interface for traversing aggregates. In a system that 
 doesn't rely on iterators, the main functionality provided by iterators could be easily taken 
 over by simple helpers. However, the reusability of those helpers could be reduced as the 
 system grows.",NA
Implementation,"In this part, we are going to implement a straightforward array iterator, as well as an ES6 
 iterator.",NA
Simple array iterator,"Let's start by creating an iterator for a JavaScript array, which should be extremely easy. 
 Firstly, the universal interface:
  
 interface Iterator<T> {
  
  first(): void;
  
  next(): void;
  
  end: boolean;
  
  item: T;
  
  index: number; 
  
 }
  
 Please notice that the TypeScript declaration for ES6 has already declared 
 an interface called 
 Iterator
 . Consider putting the code in this part into a 
 namespace or module to avoid conflicts.
  
 And the implementation of a simple array iterator could be:
  
 class ArrayIterator<T> implements Iterator<T> { index = 0;
  
  constructor(
  
  
  public array: T[]
  
  ) { }
  
  first(): void {
  
  
  this.index = 0;
  
  }
  
  next(): void {
  
  
  this.index++;
  
  }
  
  get end(): boolean {
  
  
  return this.index >= this.array.length; }
  
  get item(): T {
  
  
  return this.array[this.index];",NA
ES6 iterator,"ES6 provides syntax sugar 
 for...of
  and other helpers for 
 iterable
  objects, namely the 
 objects that have implemented the 
 Iterable
  interface of the following:
  
 interface IteratorResult<T> {
  
  done: boolean;
  
  value: T; 
  
 }
  
 interface Iterator<T> {
  
  next(value?: any): IteratorResult<T>; return?(value?: any): 
 IteratorResult<T>; throw?(e?: any): IteratorResult<T>; 
  
 }
  
 interface Iterable<T> {
  
  [Symbol.iterator](): Iterator<T>; 
  
 }
  
 [ 141 ]",NA
Consequences,"Iterator Pattern decouples iteration usage from the data structure that is being iterated. The 
 direct benefit of this is enabling an interchangeable data class that may have completely 
 different internal structures, like an array and binary tree. Also, one data structure can be 
 iterated via different iterators with different traversal mechanisms and results in different 
 orders and efficiencies.
  
 A unified iterator interface in one system could also help the developer from being 
 confused when facing different aggregates. As we mentioned previously, some language 
 like your beloved JavaScript provides a language level abstraction for iterators and makes 
 life even easier.",NA
Mediator Pattern,"The connections between UI components and related objects could be extremely complex. 
 Object-oriented programming distributes functionalities among objects. This makes coding 
 easier with cleaner and more intuitive logic; however, it does not ensure the reusability and 
 sometimes makes it difficult to understand if you look at the code again after some days 
 (you may still understand every single operation but would be confused about the 
 interconnections if the network becomes really intricate).
  
 Consider a page for editing user profile. There are standalone inputs like nickname and 
 tagline, as well as inputs that are related to each other. Taking location selection for 
 example, there could easily be a tree-level location and the options available in lower levels 
 are determined by the selection of higher levels. However, if those objects are managed 
 directly by a single huge controller, it will result in a page that has limited reusability. The 
 code formed under this situation would also tend to have a hierarchy that's less clean for 
 people to understand.",NA
Participants,"The participants of Mediator Pattern include:
  
 Mediator
 :
  
 Usually, the abstraction or skeleton predefined by a framework. Defines the 
 interface that colleagues in a mediator communicate through.
  
 Concrete mediator
 : 
 LocationPicker
  
 Manages the colleagues and makes them cooperate, providing a higher 
 level interface for objects outside.
  
 Colleague classes
 : 
 CountryInput
 , 
 ProvinceInput
 , 
 CityInput
  
 Defines references to their mediator and notifies its changes to the mediator 
 and accepts modifications issued by the mediator.",NA
Pattern scope,"Mediator Pattern could connect many parts of a project, but does not have direct or 
 enormous impact on the outline. Most of the credit is given because of increased usability 
 and cleaner interconnections introduced by mediators. However, along with a nice overall 
 architecture, Mediator Pattern can help a lot with refined code quality, and make the project 
 easier to maintain.",NA
Implementation,"Using libraries like React would make it very easy to implement Mediator Pattern, but for 
 now, we are going with a relatively primitive way and handle changes by hand. Let's think 
 about the result we want for a 
 LocationPicker
  we've discussed, and hopefully, it includes 
 country
 , 
 province
  and 
 city
  fields:
  
 interface LocationResult {
  
  country: string;
  
  province: string;
  
  city: string; 
  
 }
  
 And now we can sketch the overall structure of class 
 LocationPicker
 :
  
 class LocationPicker {
  
  $country = $(document.createElement('select')); $province = 
 $(document.createElement('select')); $city = 
 $(document.createElement('select'));
  
  $element = $(document.createElement('div')) 
 .append(this.$country)
  
  .append(this.$province)
  
  .append(this.$city);
  
  get value(): LocationResult {
  
   
  return {
  
    
  country: this.$country.val(),
  
    
  province: this.$province.val(),
  
    
  city: this.$city.val()
  
   
  };
  
  } 
  
 }",NA
Consequences,"Mediator Pattern, like many other design patterns, downgrades a level-100 problem into 
 two level-10 problems and solves them separately. A well-designed mediator usually has a 
 proper size and usually tends to be reused in the future. For example, we might not want to 
 put nickname input together with the country, province, and city inputs as this combination 
 doesn't tend to occur in other situations (which means they are not strongly related).
  
 As the project evolves, a mediator may grow to a size that's not efficient anymore. So a 
 properly designed mediator should also take the dimension of time into consideration.",NA
Summary,"In this chapter, we talked about some common behavioral patterns for different scopes and 
 different scenarios. Chain of Responsibility Pattern and Command Pattern can apply to a 
 relatively wide range of scopes, while other patterns mentioned in this chapter usually care 
 more about the scope with objects and classes directly related.
  
 Behavioral patterns we've talked about in this chapter are less like each other compared to 
 creational patterns and structural patterns we previously walked through. Some of the 
 behavioral patterns could compete with others, but many of them could cooperate. For 
 example, we talked about Command Pattern with Memento Pattern to implement undo 
 support. Many others may cooperate in parallel and do their own part.
  
 In the next chapter, we'll continue talking about other behavioral design patterns that are 
 useful and widely used.",NA
Behavioral Design Patterns: ,NA,NA
,NA,NA
Continuous,"In the previous chapter, we've already talked about some of the behavioral design patterns. 
 We'll be continuing with more patterns in this category in this chapter, including: Strategy 
 Pattern, State Pattern, Template Method Pattern, Observer Pattern, and Visitor Pattern.
  
 Many of these patterns share the same idea: unify the shape and vary the details. Here is a 
 quick overview:
  
 Strategy Pattern
  and 
 Template Pattern
 : Defines the same outline of algorithms
  
 State Pattern
 : Provides different behavior for objects in different states with the 
  
 same interface
  
 Observer Pattern
 : Provides a unified process of handling subject changes and 
  
 notifying observers
  
 Visitor Pattern
 : Does similar jobs as Strategy Pattern sometimes, but avoids an 
 over complex interface that might be required for Strategy Pattern to handle 
 objects in many different types
  
 Patterns that will be discussed in this chapter could be applied in different scopes just as 
 many patterns in other categories.",NA
Strategy Pattern,"It's common that a program has similar outlines for processing different targets with 
 different detailed algorithms. Strategy Pattern encapsulates those algorithms and makes 
 them interchangeable within the shared outline.
  
 Consider conflicting merging processes of data synchronization, which we talked about in 
 Chapter 2
 , 
 The Challenge of Increasing Complexity
 . Before refactoring, the code was like this:
  
 if (type === 'value') {
  
  // ...
  
 } else if (type === 'increment') {
  
  // ...
  
 } else if (type === 'set') {
  
  // ...
  
 }
  
 But later we found out that we could actually extract the same outlines from different 
 phases of the synchronization process, and encapsulate them as different strategies. After 
 refactoring, the outline of the code became as follows:
  
 let strategy = strategies[type]; 
  
 strategy.operation();
  
 We get a lot of ways to compose and organize those strategy objects or classes sometimes in 
 JavaScript. A possible structure for Strategy Pattern could be:
  
  
 In this structure, the client is responsible for fetching specific strategies from the table and 
 applying operations of the current phase.",NA
Participants,"We've mentioned two possible structures for Strategy Pattern, so let's discuss the 
 participants separately. For the first structure, the participants include the following:
  
 Strategy
  
 Defines the interface of strategy objects or classes.
  
 Concrete strategy
 : 
 ConcreteStrategyA
  and 
 ConcreteStrategyB
  
 Implements concrete strategy operations defined by the 
 Strategy
  interface.
  
 Strategy manager
 : 
 Strategies
  
 Defines a data structure to manage strategy objects. In the example, it's just a 
 simple hash table that uses data type names as keys and strategy objects as 
 values. It could be more complex on demand: for example, with matching 
 patterns or conditions.
  
 Target
  
 The target to apply algorithms defined in strategy objects.
  
 Client
  
 Makes targets and strategies cooperate.",NA
Pattern scope,"Strategy Pattern is usually applied to scopes with small or medium sizes. It provides a way 
 to encapsulate algorithms and makes those algorithms easier to manage under the same 
 outline. Strategy Pattern can also be the core of an entire solution sometimes, and a good 
 example is the synchronization implementation we've been playing with. In this case, 
 Strategy Pattern builds the bridge of plugins and makes the system extendable. But most of 
 the time, the fundamental work done by Strategy Pattern is decoupling concrete strategies, 
 contexts, or targets.",NA
Implementation,"The implementation starts with defining the interfaces of objects we'll be playing with. We 
 have two target types in string literal type 
 'a'
  and 
 'b'
 . Targets of type 
 'a'
   have a 
 result 
 property with type 
 string
 , while targets of type 
 'b'
  have a 
 value
  property with type 
 number
 .
  
 The interfaces we'll have look, are like:
  
 type TargetType = 'a' | 'b';
  
 interface Target {
  
  type: TargetType; 
  
 }
  
 interface TargetA extends Target {
  
  type: 'a';",NA
Consequences,"Strategy Pattern makes the foreseeable addition of algorithms for contexts or targets under 
 new categories easier. It also makes the outline of a process even cleaner by hiding trivial 
 branches of behaviors selection.
  
 However, the abstraction of algorithms defined by the 
 Strategy
  interface may keep 
 growing while we are trying to add more strategies and satisfy their requirements of 
 parameters. This could be a problem for a Strategy Pattern with clients that are managing 
 targets and strategies. But for the other structures which the references of strategy objects 
 are stored by contexts themselves, we can manage to trade-off the interchangeability. This 
 would result in Visitor Pattern, which we are going to talk about later in this chapter.
  
 And as we've mentioned before, Strategy Pattern can also provide notable extensibility if an 
 extendable strategy manager is available or the client of contexts is designed to.",NA
State Pattern,"It's possible for some objects to behave completely differently when they are in different 
 states. Let's think about an easy example first. Consider rendering and interacting with a 
 custom button in two states: enabled and disabled. When the button is enabled, it lights up 
 and changes its style to active on a mouse hover, and of course, it handles clicks; when 
 disabled, it dims and no longer cares about mouse events.",NA
Participants,"The participants of State Pattern include the following:
  
 State
  
 Defines the interface of state objects that are being switched to internally.
  
 Concrete state
 : 
 StateEnabled
  and 
 StateDisabled
  
 Implements the 
 State
  interface with behavior corresponding to a specific 
 state of the context. May have an optional reference back to its context.
  
 Context
  
 Manages references to different states, and makes operations defined on the 
 active one.
  
 [ 155 ]",NA
Pattern scope,"State Pattern usually applies to the code of scopes with the size of a feature. It does not 
 specify whom to transfer the state of context: it could be either the context itself, the state 
 methods, or code that controls context.",NA
Implementation,"Start with the 
 State
  interface (it could also be an abstract class if there are operations or 
 logic to share):
  
 interface State {
  
  render(hover: boolean): void;
  
  click(): void; 
  
 }
  
 With the 
 State
  interface defined, we can move to 
 Context
  and sketch its outline:
  
 class Context {
  
  $element: JQuery;
  
  state: State;
  
  private render(hover: boolean): void {
  
  
  this.state.render(hover);
  
  }
  
  private click(): void {
  
   
  this.state.click();
  
  }
  
  onclick(): void {
  
   
  console.log('I am clicked.');
  
  } 
  
 }
  
 Now we are going to have the two states, 
 StateEnabled
  and 
 StateDisabled 
  
 implemented. First, let's address 
 StateEnabled
 , it cares about 
 hover
  status and handles 
 click
  event:
  
 class StateEnabled implements State {
  
  constructor(
  
   
  public context: Context
  
  ) { }",NA
Consequences,"State Pattern reduces conditional branches in potentially multiple methods of context 
 objects. As a trade-off, extra state objects are introduced, though it usually won't be a big 
 problem.
  
 The context object in State Pattern usually delegates operations and forwards them to the 
 current state object. Thus operations defined by a concrete state may have access to the 
 context itself. This makes reusing state objects possible with flyweights.",NA
Template Method Pattern,"When we are talking about subclassing or inheriting, the building is usually built from the 
 bottom up. Subclasses inherit the basis and then provide more. However, it could be useful 
 to reverse the structure sometimes as well.
  
 Consider Strategy Pattern which defines the outline of a process and has 
 interchangeable algorithms as strategies. If we apply this structure under the hierarchy 
 of classes, we will have Template Method Pattern.",NA
Participants,"The participants of Template Method Pattern include the following:
  
 Abstract class
 : 
 TextReader
  
 Defines the signatures of template methods, as well as the outline of 
 algorithms that weave everything together.
  
 [ 159 ]",NA
Pattern scope,"Template Method Pattern is usually applied in a relatively small scope. It provides an 
 extendable way to implement features and avoid redundancy from the upper structure of a 
 series of algorithms.",NA
Implementation,"There are two levels of the inheriting hierarchy: the 
 AsciiTextReader
  will subclass 
 TextReader
  as another abstract class. It implements method 
 decodeBytes
  but leaves 
 readAllBytes
  to its subclasses. Starting with the 
 TextReader
 :
  
 abstract class TextReader {
  
  async readAllText(): Promise<string> {
   
  let 
 bytes = await this.readAllBytes();
  
  
  let text 
 = this.decodeBytes(bytes);
  
  
  return text;
  
  }
  
  abstract async readAllBytes(): Promise<Buffer>;
  
  abstract decodeBytes(bytes: Buffer): string; }
  
 We are using Promises with 
 async
  and 
 await
  which are coming to 
 ECMAScript next. Please refer to the following links for more information: 
 https://github.com/Microsoft/TypeScript/issues/1664 
  
 https://tc39.github.io/ecmascript-asyncawait/",NA
Consequences,"Compared to Strategy Pattern, Template Method Pattern provides convenience for building 
 objects with the same outline of algorithms outside of the existing system. This makes 
 Template Method Pattern a useful way to build tooling classes instead of fixed processes 
 built-in.
  
 But Template Method Pattern has less runtime flexibility as it does not have a 
 manager
 . It 
 also relies on the client who's using those objects to do the work. And as the 
  
 implementation of Template Method Pattern relies on subclassing, it could easily result in 
 hierarchies that have a similar code on different branches. Though this could be optimized 
 by using techniques like 
 mixin
 .",NA
Observer Pattern,"Observer Pattern is an important Pattern backed by an important idea in software 
 engineering. And it is usually a key part of MVC architecture and its variants as well.
  
 If you have ever written an application with a rich user interface without a framework like 
 Angular or a solution with React, you might probably have struggled with changing class 
 names and other properties of UI elements. More specifically, the code that controls those",NA
Participants,"We've talked about the basic structure of Observer Pattern with subjects and observers, and 
 a variant with implicit subjects. The participants of the basic structure include the following:
  
 Subject
  
 Subject to be observed. Defines methods to 
 attach
  or 
 notify
  observers. A 
 subject could also be a composite that contains sub-subjects, which allows 
 multiple states to be observed with the same interface.
  
 Concrete subject
 : 
 ConnectedSubject
  and 
 LoadedSubject
  
 Contains state related to the subject, and implements methods or properties 
 to get and set their state.
  
 Observer
  
 Defines the interface of an object that reacts when an observation notifies. In 
 JavaScript, it could also be an interface (or signature) of a function.
  
 Concrete observer
 : 
 DoButtonObserver
  
 Defines the action that reacts to the notifications of subjects being observed. 
 Could be a callback function that matches the signature defined.
  
 In the variant version, the participants include the following:
  
 State manager
  
 Manages a complex, possibly multi-level state object containing multiple 
 states. Defines the interface to attach observers with subjects, and notifies 
 those observers when a subject changes.
  
 Concrete subject
  
 Keys to specific states. For example, string 
 ""connected""
  may represent state 
 stateManager.connected
 , while string 
 ""foo.bar""
  may represent state 
 stateManager.foo.bar
 .
  
 Observer
  and 
 concrete observer
  are basically the same as described in the former structure. But 
 observers are now notified by the state manager instead of subject objects.",NA
Pattern scope,"Observer Pattern is a pattern that may easily structure half of the project. In MV* 
  
 architectures, Observer Pattern can decouple the view from business logic. The concept of 
 view can be applied to other scenarios related to displaying information as well.",NA
Implementation,"Both of the structures we've mentioned should not be hard to implement, though more 
 details should be put into consideration for production code. We'll go with the second 
 implementation that has a central state manager.
  
 To simplify the implementation, we will use 
 get
  and 
 set
  methods to 
 access specific states by their keys. But many frameworks available might 
 handle those through getters and setters, or other mechanisms.
  
 To learn about how frameworks like Angular handle states changing, 
 please read their documentation or source code if necessary.
  
 We are going to have 
 StateManager
  inherit 
 EventEmitter
 , so we don't need to care much about 
 issues like multiple listeners. But as we are accepting multiple state keys as subjects, an 
 overload to method 
 on
  will be added. Thus the outline of 
 StateManager
  would be as follows:
  
 type Observer = () => void;
  
 class StateManager extends EventEmitter{ constructor(
  
   
  private state: any
  
  ) {
  
   
  super();
  
  }
  
  set(key: string, value: any): void { }
  
  get(key: string): any { }
  
  on(state: string, listener: Observer): this;
  
  on(states: string[], listener: Observer): this;
  
  on(states: string | string[], listener: Observer): this { } }
  
 [ 167 ]",NA
Consequences,"Observer Pattern decouples subjects with observers. While an observer may be observing 
 multiple states in subjects at the same time, it usually does not care about which state 
 triggers the notification. As a result, the observer may make 
 unnecessary
  updates that 
 actually do nothing to 
 –
  for example 
 –
  the view.
  
 However, the impact on performance could be negligible most of the time, not even need to 
 mention the benefits it brings.
  
 By splitting view and logic apart, Observer Pattern may reduce possible branches 
 significantly. This will help eliminate bugs caused at the coupling part between view and 
 logic. Thus, by properly applying Observer Pattern, the project will be made much more 
 robust and easier to maintain.",NA
Visitor Pattern,"Visitor Pattern provides a uniformed interface for 
 visiting
  different data or objects while 
 allowing detailed operations in concrete visitors to vary. Visitor Pattern is usually used with 
 composites, and it is widely used for walking through data structures like 
 abstract syntax 
 tree
  (
 AST
 ). But to make it easier for those who are not familiar with compiler stuff, we will 
 provide a simpler example.
  
 Consider a DOM-like tree containing multiple elements to render:
  
 [
  
  Text {
  
   
  content: ""Hello, ""
  
  },
  
  BoldText {
  
   
  content: ""TypeScript""
  
  },
  
  Text {
  
   
  content: ""! Popular editors:\n""
  
  },
  
  UnorderedList {
  
   
  items: [
  
    
  ListItem {
  
     
  content: ""Visual Studio Code""
  
    
  },
  
    
  ListItem {
  
     
  content: ""Visual Studio""
  
    
  },
  
    
  ListItem {
  
     
  content: ""WebStorm""
  
    
  }",NA
Participants,"The participants of Visitor Pattern include the following:
  
 Visitor
 : 
 NodeVisitor
  
 Defines the interface of operations corresponding to each element class. In 
 languages with static types and method overloading, the method names can 
 be unified. But as it takes extra runtime checking in JavaScript, we'll use 
 different method names to distinguish them. The operation methods are 
 usually named after 
 visit
 , but here we use 
 append
  as its more related to the 
 context.
  
 Concrete visitor
 : 
 HTMLVisitor
  and 
 MarkdownVisitor
  
 Implements every operation of the concrete visitor, and handles internal 
 states if any.
  
 Element
 : 
 Node
  
 Defines the interface of the element accepting the visitor instance. The 
 method is usually named 
 accept
 , though here we are using 
 appendTo
  for a 
 better matching with the context. Elements could themselves be composites 
 and pass visitors on with their child elements.",NA
Pattern scope,"Visitor Pattern can form a large feature inside a system. For some programs under certain 
 categories, it may also form the core architecture. For example, 
 Babel
  uses Visitor Pattern for 
 AST transforming and a plugin for Babel is actually a visitor that can visit and transform 
 elements it cares about.",NA
Implementation,"We are going to implement 
 HTMLVisitor
  and 
 MarkdownVisitor
  which may transform 
 nodes to text, as we've talked about. Start with the upper abstraction:
  
 interface Node {
  
  appendTo(visitor: NodeVisitor): void; 
  
 }
  
 interface NodeVisitor {
  
  appendText(text: Text): void;
  
  appendBold(text: BoldText): void;
  
  appendUnorderedList(list: UnorderedList): void; 
 appendListItem(item: ListItem): void; 
  
 }
  
 Continue with concrete nodes that do similar things, 
 Text
  and 
 BoldText
 :
  
 class Text implements Node {
  
  constructor(
  
   
  public content: string
  
  ) { }
  
  appendTo(visitor: NodeVisitor): void {
  
  
  
 visitor.appendText(this);
  
  } 
  
 }",NA
Consequences,"Both Strategy Pattern and Visitor Pattern could be applied to scenarios of processing 
 objects. But Strategy Pattern relies on clients to handle all related arguments and contexts, 
 this makes it hard to come out with an exquisite abstraction if the expected behaviors of 
 different objects differ a lot. Visitor Pattern solves this problem by decoupling visit actions 
 and operations to be performed.
  
 By passing different visitors, Visitor Pattern can apply different operations to objects 
 without changing other code although it usually means adding new elements and would 
 result in adding related operations to an abstract visitor and all of its concrete subclasses.
  
 Visitors like the 
 NodeVisitor
  in the previous example may store state itself (in that example, 
 we stored the output of transformed nodes) and more advanced operations can be applied 
 based on the state accumulated. For example, it's possible to determine what has been 
 appended to the output, and thus we can apply different behaviors with the node currently 
 being visited.
  
 However, to complete certain operations, extra public methods may need to be exposed 
 from the elements.",NA
Summary,"In this chapter, we've talked about other behavior design patterns as complements to the 
 former chapter, including Strategy, State, Template Method, Observer and Visitor Pattern.
  
 Strategy Pattern is so common and useful that it may appear in a project several times, with 
 different forms. And you might not know you were using Observer Pattern with 
  
 implementation in a daily framework.
  
 After walking through those patterns, you might find there are many ideas in common 
 behind each pattern. It is worth thinking what's behind them and even letting the outline go 
 in your mind.
  
 In the next chapter, we'll continue with some handy patterns related to JavaScript and 
 TypeScript, and important scenarios of those languages.",NA
Patterns and Architectures in ,NA,NA
,NA,NA
JavaScript and TypeScript,"In the previous four chapters, we've walked through common and classical design patterns 
 and discussed some of their variants in JavaScript or TypeScript. In this chapter, we'll 
 continue with some architecture and patterns closely related to the language and their 
 common applications. We don't have many pages to expand and certainly cannot cover 
 everything in a single chapter, so please take it as an appetizer and feel free to explore more.
  
 Many topics in this chapter are related to asynchronous programming. We'll start with a 
 web architecture for Node.js that's based on Promise. This is a larger topic that has 
 interesting ideas involved, including abstractions of responses and permissions, as well as 
 error handling tips. Then we'll talk about how to organize modules with 
 ECMAScript
  (
 ES
 ) 
 module syntax. And this chapter will end with several useful asynchronous techniques.
  
 Overall, we'll have the following topics covered in this chapter:
  
 Architecture and techniques related to Promise
  
 Abstraction of responses and permissions in a web application
  
 Modularizing a project to scale
  
 Other useful asynchronous techniques
  
 Again, due to the limited length, some of the related code is aggressively 
 simplified and nothing more than the idea itself can be applied practically.",NA
Promise-based web architecture,"To have a better understanding of the differences between Promises and traditional 
 callbacks, consider an asynchronous task like this:
  
 function process(callback) {
  
  stepOne((error, resultOne) => {
  
   
  if (error) {
  
    
  callback(error);
  
    
  return;
  
    
  }
  
  stepTwo(resultOne, (error, resultTwo) => {
  
  if (error) 
 {
  
   
  callback(error);
  
    
  return;
  
  
  }
  
   
  callback(undefined, resultTwo + 1);
  
   
  });
  
  }); 
  
 }
  
 If we write preceding above in Promise style, it would be as follows:
  
 function process() {
  
  return stepOne()
  
   
  .then(result => stepTwo(result)) 
  
 .then(result => result + 1); 
  
 }
  
 As in the preceding example, Promise makes it easy and 
 natural
  to write asynchronous 
 operations with a flat chain instead of nested callbacks. But the most exciting thing about 
 Promise might be the benefits it brings to error handling. In a Promise-based architecture, 
 throwing an error can be safe and pleasant. You don't have to explicitly handle errors when 
 chaining asynchronous operations, and this makes mistakes less likely to happen.
  
 With the growing usage with ES6 compatible runtimes, Promise is already there out of the 
 box. And we actually have plenty of polyfills for Promises (including my 
 ThenFail
  written in 
 TypeScript), as people who write JavaScript roughly refer to the same group of people who 
 created wheels.",NA
Promisifying existing modules or libraries,"Though Promises do best in a Promise-based architecture, it is still possible to begin using 
 Promise with a smaller scope by promisifying existing modules or libraries.
  
 Let's take Node.js style callbacks as an example:
  
 import * as FS from 'fs';
  
 FS.readFile('some-file.txt', 'utf-8', (error, text) => { if (error) {
  
   
  console.error(error);
  
   
  return;
  
  }
  
  console.log('Content:', text); 
  
 });
  
 You may expect a promisified version of the 
 readFile
  function to look like the following:
  
 FS
  
  .readFile('some-file.txt', 'utf-8')
  
  .then(text => {
  
   
  console.log('Content:', text);
  
  })
  
  .catch(reason => {
  
   
  Console.error(reason);
  
  });",NA
Views and controllers in Express,"Many of us may have already worked with frameworks such as 
 Express
 . And this is how 
 we render a view or response with JSON in Express:
  
 import * as Path from 'path'; 
  
 import * as express from 'express';
  
 let app = express();
  
 app.set('engine', 'hbs'); 
  
 app.set('views', Path.join(__dirname, '../views'));
  
 app.get('/page', (req, res) => {
  
  res.render('page', {
  
   
  title: 'Hello, Express!',
  
   
  content: '...'
  
  }); 
  
 });",NA
Abstraction of responses,"We've already been returning a Promise to tell whether an error occurs. So now the 
 returned Promise indicates the status of the response: success or failure. But why we are 
 still calling 
 res.render()
  for rendering the view? The returned promise object could be the 
 response itself rather than just an error indicator.
  
 Think about the controller again:
  
 export class Response { }
  
 export class PageResponse extends Response { 
 constructor(view: string, data: any) { } }
  
 export function foo(req: Request) {
  
  return Promise
  
   
  .all([
  
    
  Post.getContent(),
  
    
  Post.getComments()
  
   
  ])
  
   
  .then(([post, comments]) => { 
  
    
 return new PageResponse('foo', {
  
      
  post,
  
      
  comments
  
    
  });
  
   
  }); 
  
 }
  
 The response object returned could vary for different response outputs. For example, it 
 could be either a 
 PageResponse
  like it is in the preceding example, a 
 JSONResponse
 , a 
 StreamResponse
 , or even a simple 
 Redirection
 .",NA
Abstraction of permissions,"Permissions play an important role in a project, especially in systems that have different 
 user groups, for example, a forum. The abstraction of permissions should be extendable to 
 satisfy changing requirements, and it should be easy to use as well.
  
 Here, we are going to talk about the abstraction of permission in the level of controller 
 actions. Consider the legibility of performing one or more actions as a 
 privilege.
  The 
 permission of a user may consist of several privileges and usually most users at the same 
 level would have the same set of privileges. So we may have a larger concept, namely 
 groups.
  
 The abstraction could either work based on both groups and privileges or based on 
 privileges only (groups are then just aliases to sets of privileges):",NA
Expected errors,"A great concern wiped away by using Promises is that we do not need to worry about 
 throwing an error in a 
 callback
  would crash the application most of the time. The error will 
 flow through the Promises chain and, if not caught, will be handled by our router. Errors 
 can be roughly divided into expected errors and unexpected errors. Expected errors are 
 usually caused by incorrect input or foreseeable exceptions, and unexpected errors are 
 usually caused by bugs or other libraries the project relies on.",NA
Defining and throwing expected errors,"The router will need to handle different types of errors, and an easy way to achieve that is 
 to subclass a universal 
 ExpectedError
  class and throw its instances out:
  
 import ExtendableError from 'extendable-error';
  
 class ExpectedError extends ExtendableError { constructor(
  
   
  message: string,
  
   
  public code: number
  
  ) {
  
   
  super(message);
  
  } 
  
 }
  
 The 
 extendable-error
  is a package of mine that handles stack trace and the 
 message
  property. You can directly extend the 
 Error
  class as well.
  
 Thus, when receiving an expected error, we can safely output its message as part of the 
 response. And if it's not an instance of 
 ExpectedError
 , we can then output predefined 
 unknown
  error messages and have detailed error information logged.",NA
Transforming errors,"Some errors, such as those caused by unstable networks or remote services, are expected; 
 we may want to catch those errors and throw them out again as expected errors. But it is 
 rather trivial to actually do that. A centralized error-transforming process can then be 
 applied to reduce the efforts required to manage those errors.",NA
Modularizing project,"Before ES6, there were a lot of module solutions for JavaScript that worked. The two most 
 famous of them are AMD and commonjs. AMD is designed for asynchronous module 
 loading, which is mostly applied in browsers, while commonjs does module loading 
 synchronously, and that's the way the Node.js module system works.
  
 To make it work asynchronously, writing an AMD module takes more characters. And due 
 to the popularity of tools such as browserify and webpack, commonjs becomes popular 
 even for browser projects.
  
 The proper granularity of internal modules could help a project keep its structure healthy. 
 Consider a project structure like this:
  
 project
  
 ├─controllers
  
 ├─core",NA
Asynchronous patterns,"When we are writing JavaScript with network or file system I/O, there is a 95% chance that 
 we are doing it asynchronously. However, an asynchronous code may tremendously 
 decrease the determinability at the dimension of time. But we are so lucky that JavaScript is 
 usually single-threaded; this makes it possible for us to write predictable code without 
 mechanisms such as locks most of the time.",NA
Writing predictable code,"The predictable code relies on predictable tools (if you are using any). Consider a helper like 
 this:
  
 type Callback = () => void;
  
 let isReady = false; 
  
 let callbacks: Callback[] = [];
  
 setTimeout(() => {
  
  callbacks.forEach(callback => callback());
  
  callbacks = undefined;
  
  }, 100); 
  
 export function ready(callback: Callback): void { if (!callbacks) {
  
   
  callback();
  
  } else {
  
   
  callbacks.push(callback);
  
  } 
  
 }
  
 This module exports a 
 ready
  function, which will invoke the callbacks passed in 
 when
 “
 ready
 ”
 . It will assure that callbacks will be called even if added after that. 
 However, you cannot say for sure whether the callback will be called in the current event 
 loop:
  
 import { ready } from './foo';
  
 let i = 0;",NA
Asynchronous creational patterns,"We talked about many creational patterns in 
 Chapter 3
 , 
 Creational Design Patterns
 . While a 
 constructor cannot be asynchronous, some of those patterns may have problems applying to 
 asynchronous scenarios. But others need only slight modifications for asynchronous use.
  
 In 
 Chapter 4
 , 
 Structural Design Patterns
  we walked through the Adapter Pattern with a 
 storage example that opens the database and creates a storage object asynchronously:
  
 class Storage {
  
  private constructor() { }
  
  open(): Promise<Storage> {
  
   
  return openDatabase()
  
    
  .then(db => new Storage(db))
  
  } 
  
 }
  
 And in the Proxy Pattern, we made the storage object immediately available from its 
 constructor. When a method of the object is called, it waits for the initialization to 
 complete and finishes the operation:
  
 class Storage {
  
  private dbPromise: Promise<IDBDatabase>;
  
  get dbReady(): Promise<IDBDatabase> {
  
  
  if (this.dbPromise) {
  
   
  return this.dbPromise;
  
  
  }
  
  
  // ...     }
  
  get<T>(): Promise<T> {
  
  
  return this
  
   
  .dbReady
  
   
  .then(db => {
  
    
  // ...
  
   
  });
  
  } 
  
 }
  
 A drawback of this approach is that all members that rely on initialization have to be 
 asynchronous, though most of the time they just are asynchronous.",NA
Asynchronous middleware and hooks,"The concept of middleware is widely used in frameworks such as Express. Middleware 
 usually processes its target in serial. In Express, middleware is applied roughly in the order 
 it is added while there are not different phases. Some other frameworks, however, provide 
 hooks for different phases in time. For example, there are hooks that will be triggered 
 before 
 install
 , 
 after install
 , 
 after uninstall
 , and so on.
  
 The middleware mechanism of Express is actually a variant of the Chain of 
 Responsibility Pattern. And depending on the specific middleware to be 
 used, it can act more or less like hooks instead of a responsibility chain.
  
 The reasons to implement middleware or hooks vary. They may include the following:
  
 Extensibility
 : Most of the time, they are applied due to the requirement of 
 extensibility. New rules and processes could be easily added by new middleware 
 or hooks.
  
 Decoupling interactions with business logic
 : A module that should only care 
 about business logic could need potential interactions with an interface. For 
 example, we might expect to be able to either enter or update credentials while 
 processing an operation, without restarting everything. Thus we can create a 
 middleware or a hook, so that we don't need to have them tightly coupled.
  
 The implementation of asynchronous middleware could be interesting. Take the Promise 
 version as an example:
  
 type Middleware = (host: Host) => Promise<void>;
  
 class Host {
  
  middlewares: Middleware[] = [];
  
  start(): Promise<void> {
  
   
  return this
  
    
  .middlewares
  
    
  .reduce((promise, middleware) => {
  
     
  return promise.then(() => middleware(this));
  
  
  
  }, Promise.resolve());
  
  } 
  
 }",NA
Event-based stream parser,"When creating an application relies on socket, we usually need a lightweight 
 “
 protocol
 ”
  for 
 the client and server to communicate. Unlike XHR that already handles everything, by 
 using socket, you will need to define the boundaries so data won't be mixed up.
  
 Data transferred through a socket might be concatenated or split, but TCP connection 
 ensures the order and correctness of bytes gets transferred. Consider a tiny protocol that 
 consists of only two parts: a 4-byte unsigned integer followed by a JSON string with byte 
 length that matches the 4-byte unsigned integer.
  
 For example, for JSON 
 ""{}""
 , the data packet would be as follows:
  
 Buffer <00 00 00 02 7b 7d>
  
 To build such a data packet, we just need to convert the JSON string to 
 Buffer
  (with 
 encoding such as 
 utf-8
 , which is default encoding for Node.js), and then prepend its 
 length:
  
 function buildPacket(data: any): Buffer { let json = 
 JSON.stringify(data);
  
  let jsonBuffer = new Buffer(json);
  
  let packet = new Buffer(4 + jsonBuffer.length);
  
  packet.writeUInt32BE(jsonBuffer.length, 0); 
 jsonBuffer.copy(packet, 4, 0);
  
  return packet; 
  
 }
  
 A socket client emits a 
 data
  event when it receives new buffers. Assume we are going to 
 send the following JSON strings:
  
 // 00 00 00 02 7b 7d 
  
 {}
  
 // 00 00 00 0f 7b 22 6b 65 79 22 3a 22 76 61 6c 75 65 22 7d {""key"":""value""}
  
 We may be receiving them like this:
  
 Get two buffers separately; each of them is a complete packet with length and 
  
 JSON bytes",NA
Summary,"In this chapter, we discussed some interesting ideas and an architecture formed by those 
 ideas. Most of the topics focus on a small scope and do their own job, but there are also 
 ideas about putting a whole system together.
  
 The code that implements techniques such as expected error and the approach to managing 
 modules in a project is not hard to apply. But with proper application, it can bring notable 
 convenience to the entire project.
  
 However, as I have already mentioned at the beginning of this chapter, there are too many 
 beautiful things in JavaScript and TypeScript to be covered or even mentioned in a single 
 chapter. Please don't stop here, and keep exploring.
  
 Many patterns and architectures are the result of some fundamental principles in software 
 engineering. Those principles might not always be applicable in every scenario, but they 
 may help when you feel confused. In the next chapter, we are going to talk about SOLID 
 principles in object-oriented design and find out how those principles may help form a 
 useful pattern.",NA
SOLID Principles ,NA,NA
,"SOLID Principles are well-known Object-Oriented Design (
 OOD
 )principles summarized by 
 Uncle Bob (Robert C. Martin). The word SOLID comes from the initials of the five principles 
 it refers to, including 
 Single responsibility principle
 , 
 Open-closed principle
 , 
 Liskov 
 substitution principle
 , 
 Interface segregation principle
  and 
 Dependency inversion 
 principle
 . Those principles are closely related to each other, and can be a great guidance in 
 practice.
  
 Here is a widely used summary of SOLID principles from Uncle Bob:
  
 Single responsibility principle
 : A class should have one, and only one, reason to 
  
 change
  
 Open-closed principle
 : You should be able to extend a classes behavior, without 
  
 modifying it
  
 Liskov substitution principle
 : Derived classes must be substitutable for their 
  
 base classes
  
 Interface segregation principle
 : Make fine-grained interfaces that are client 
  
 specific
  
 Dependency inversion principle
 : Depend on abstractions, not on concretions
  
 In this chapter, we will walk through them and find out how those principles can help form 
 a design that 
 smells
  nice.
  
 But before we proceed, I want to mention that a few of the reasons why those principles 
 exist might be related to the age in which they were raised, the languages and their building 
 or distributing process people were working with, and even computing resources. When 
 being applied to JavaScript and TypeScript projects nowadays, some of the details may not",NA
Single responsibility principle,"The single responsibility principle declares that a class should have one, and only one 
 reason to change. And the definition of the world 
 reason
  in this sentence is important.",NA
Example,"Consider a 
 Command
  class that is designed to work with both command-line interface and 
 graphical user interface:
  
 class Command {
  
  environment: Environment;
  
  print(items: ListItem[]) {
  
   
  let stdout = this.environment.stdout;
  
   
  stdout.write('Items:\n');
  
   
  for (let item of items) {
  
    
  stdout.write(item.text + '\n');
  
   
  }
  
  }
  
  render(items: ListItem[]) {
  
   
  let element = <List items={items}></List>;
  
  
  
 this.environment.render(element);
  
  }
  
  execute() { } 
  
 }
  
 To make this actually work, 
 execute
  method would need to handle both the command 
 execution and result displaying:
  
 class Command {
  
  ..
  
  execute() {
  
  let items = ...;
  
   
  if (this.environment.type === 'cli') {
  
   
  this.print(items);
  
   
  } else {
  
    
  this.render(items);
  
   
  }
  
  } 
  
 }",NA
Choosing an axis,"You might be thinking, doesn't 
 CommandResult
  violate the single responsibility principle by 
 having the abilities to display content in a different environment? Yes, and no. When the 
 axis of this reason is set to displaying content, it does not; but if the axis is set to displaying 
 in a specific environment, it does. But take the overall structure into consideration, the result 
 of a command is expected to be an output that can adapt to a different environment. And 
 thus the reason is one-dimensional and confirms the principle.",NA
Open-closed principle,"The open-closed principle declares that you should be able to extend a class' behavior, 
 without modifying it. This principle is raised by Bertrand Meyer in 1988:
  
 Software entities (classes, modules, functions, etc.) should be open for extension, but closed 
 for modification.
  
 A program depends on all the entities it uses, that means changing the already-being-used 
 part of those entities may just crash the entire program. So the idea of the open-closed 
 principle is straightforward: we'd better have entities that never change in any way other 
 than extending itself.
  
 That means once a test is written and passing, ideally, it should never be changed for newly 
 added features (and it needs to keep passing, of course). Again, ideally.",NA
Example,"Consider an API hub that handles HTTP requests to and responses from the server. We are 
 going to have several files written as modules, including 
 http-client.ts
 , 
 hub.ts
  and 
 app.ts
  (but 
 we won't actually write 
 http-client.ts
  in this example, you will need to use some 
 imagination).
  
 Save the code below as file 
 hub.ts
 .
  
 import { HttpClient, HttpResponse } from './http-client';
  
 export function update(): Promise<HttpResponse> { let client = new 
 HttpClient();
  
  return client.get('/api/update'); 
  
 }
  
 And save the code below as file 
 app.ts
 .
  
 import Hub from './hub';
  
 Hub
  
  .update()
  
  .then(response => JSON.stringify(response.text)) .then(result => {
  
   
  console.log(result); 
  
 });",NA
Abstraction in JavaScript and TypeScript,"Guess what, our beloved JavaScript does not have an interface, and it is dynamically typed. 
 We were not even able to actually write an interface. However, we could still write down 
 documentation about the abstraction and create new concrete implementations just by 
 obeying that description.
  
 But TypeScript offers interface, and we can certainly take advantage of it. Consider the 
 CommandResult
  class in the previous section. We were writing it as a concrete class, but it 
 may have subclasses that override the 
 print
  or 
 render
  method for customized output. 
 However, the type system in TypeScript cares only about the shape of a type. That means, 
 while you are declaring an entity with type 
 CommandResult
 , the entity does not need to be 
 an instance of 
 CommandResult
 : any object with a compatible type (namely has methods 
 print
  
 and 
 render
  with proper signatures in this case) will do the job.
  
 For example, the following code is valid:
  
 let environment: Environment;
  
 let command: Command = {
  
  environment,
  
  print(items) { },
  
  render(items) { },
  
  execute() { } 
  
 };",NA
Refactor earlier,"I double stressed that the open-closed principle can only be perfectly followed under ideal 
 scenarios. That can be a result of two reasons:
  
 1.
  Not all entities in a system can be open to extension and closed to modification at the 
 same time
 . There will always be changes that need to break the closure of 
 existing entities to complete their functionalities. When we are designing the 
 interfaces, we need different strategies for creating stable closures for different 
 foreseeable situations. But this requires notable experience and no one can do it 
 perfectly.
  
 2. 
 None of us is too good at designing a program that lasts long and stays healthy forever
 . 
 Even with thorough consideration, abstractions designed at the beginning can be 
 choppy facing the changing requirements.
  
 So when we are expecting the entities to be closed for modification, it does not mean that 
 we should just stand there and watch it being closed. Instead, when things are still under 
 control, we should refactor and 
 keep the abstraction in the status of being open to extension and 
 closed to modification
  at the time point of refactoring.",NA
Liskov substitution principle,"The open-closed principle is the essential principle of keeping code maintainable and 
 reusable. And the key to the open-closed principle is abstraction with polymorphism. 
 Behaviors like implementing interfaces, or extending classes make polymorphic 
 shapes
 , but 
 that might not be enough.
  
 The Liskov substitution principle declares that derived classes must be substitutable for 
 their base classes. Or in the words of Barbara Liskov, who raised this principle:
  
 What is wanted here is something like the following substitution property: If for each object 
 o1 of type S there is an object o2 of type T such that for all programs P defined in terms of 
 T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.
  
 Never mind. Let's try another one: 
 any foreseeable usage of the instance of a class should be 
 working with the instances of its derived classes.",NA
Example,"And here we go with a straightforward violation example. Consider 
 Noodles
  and 
 InstantNoodles
  (a subclass of 
 Noodles
 ) to be cooked:
  
 function cookNoodles(noodles: Noodles) { if (noodles 
 instanceof InstantNoodles) {
  
  
  
 cookWithBoiledWaterAndBowl(noodles); } else {
  
   
  cookWithWaterAndBoiler(noodles);
  
  } 
  
 }
  
 Now if we want to have some fried noodles
 …
  The 
 cookNoodles
  function does not seem to be 
 capable of handling that. Clearly, this violates the Liskov substitution principle, though it 
 does not mean that it's a bad design.
  
 Let's consider another example written by Uncle Bob in his article talking about this 
 principle. We are creating class 
 Square
  which is a subclass of 
 Rectangle
 , but instead of 
 adding new features, it adds a constraint to 
 Rectangle
 : the width and height of a square 
 should always be equal to each other. Assume we have a 
 Rectangle
  class that allows its 
 width and height to be set:
  
 class Rectangle {
  
  constructor(
  
   
  private _width: number;
  
   
  private _height: number;
  
  ) { }
  
  set width(value: number) {
  
   
  this._width = value;
  
  }
  
  set height(value: number) {
  
   
  this._height = value;
  
  } 
  
 }
  
 Now we have a problem with its subclass 
 Square
 , because it gets 
 width
  and 
 height 
 setters 
 from 
 Rectangle
  while it shouldn't. We can certainly override those setters and make 
 both of them update width and height simultaneously. But in some situations, the client 
 might just not want that, because doing so will make the program harder to be 
 predicted.",NA
The constraints of substitution,"Type is an important part in a programming language, even in JavaScript. But having the 
 same 
 shape
 , being on the same hierarchy does not mean they can be the substitution of 
 another without some pain. More than just the 
 shape
 , the complete behavior is what really 
 matters for implementations that hold to the Liskov substitution principle.",NA
Interface segregation principle,"We've already discussed the important role played by abstractions in object-oriented design. 
 The abstractions and their derived classes without separation usually come up with 
 hierarchical tree structures. That means when you choose to create a branch, you create a 
 parallel abstraction to all of those on another branch.
  
 For a family of classes with only one level of inheritance, this is not a problem: because it is 
 just what you want to have those classes derived from. But for a hierarchy with greater 
 depth, it could be.",NA
Example,"Consider the 
 TextReader
  example we took with Template Method Pattern in 
 Chapter 6
 , 
 Behavioral Design Patterns: Continuous
  we had 
 FileAsciiTextReader
  and 
  
 HttpAsciiTextReader
  derived from 
 AsciiTextReader
 . But what if we want to have other 
 readers that understand UTF-8 encoding?
  
 To achieve that goal, we have two common options: separate the interface into two for 
 different objects that cooperate, or separate the interface into two then get them 
 implemented by a single class.",NA
Proper granularity,"It is said that by creating smaller interfaces, we can avoid a client from using big classes 
 with features that it never needs. This may cause unnecessary usage of resources, but in 
 practice, that usually won't be a problem. The most important part of the interface 
 segregation principle is still about keeping code maintainable and reusable.
  
 Then the question comes out again, how small should an interface be? I don't think I have a 
 simple answer for that. But I am sure that being too small might not help.",NA
Dependency inversion principle,"When we talk about dependencies, the natural sense is about dependencies from bottom to 
 top, just like how buildings are built. But unlike a building that stands for tens of years with 
 little change, software keeps changing during its life cycle. Every change costs, more or less.
  
 The dependency inversion principle declares that entities should depend on abstractions, 
 not on concretions. Higher level code should not depend directly on low-level 
  
 implementations, instead, it should depend on abstractions that 
 lead to
  those 
  
 implementations. And this is why things are 
 inverse
 .",NA
Example,"Still taking the HTTP client and API hub as an example, which obviously violates the 
 dependency inversion principle, taking the foreseeable application into consideration, what 
 the API hub should depend on is a messaging mechanism bridging client and server, but 
 not bare HTTP client. This means we should have an abstraction layer of messaging before 
 the concrete implementation of HTTP client:",NA
Separating layers,"Compared to other principles discussed in this chapter, the dependency inversion principle 
 cares more about the scope of modules or packages. As the abstraction might usually be 
 more stable than concrete implementations, by following dependency inversion principle, 
 we can minimize the impact from low-level changes to higher level behaviors.
  
 But for JavaScript (or TypeScript) projects as the language is dynamically typed, this 
 principle is more about an idea of guidance that leads to a stable abstraction between 
 different layers of code implementation.
  
 Originally, an important benefit of following this principle is that, if modules or packages 
 are relatively larger, separating them by abstraction could save a lot of time in compilation. 
 But for JavaScript, we don't have to worry about that; and for TypeScript, we don't have to 
 recompile the entire project for making changes to separated modules either.",NA
Summary,"In this chapter, we walked through the well-known SOLID principles with simple 
  
 examples. Sometimes, following those principles could lead us to a useful design pattern. 
 And we also found that those principles are strongly bound to each other. Usually violating 
 one of them may indicate other violations.
  
 Those principles could be extremely helpful for OOD, but could also be overkill if they are 
 applied without proper adaptions. A well-designed system should have those principles 
 confirmed just right, or it might harm.
  
 In the next chapter, instead of theories, we'll have more time with a complete workflow 
 with testing and continuous integration involved.",NA
The Road to Enterprise ,NA,NA
,NA,NA
Application,"After walking through common design patterns, we have now the basis of code designing. 
 However, software engineering is more about writing beautiful code. While we are trying 
 to keep the code healthy and robust, we still have a lot to do to keep the project and the 
 team healthy, robust, and ready to scale. In this chapter, we'll talk about popular elements 
 in the workflow of web applications, and how to design a workflow that fits your team.
  
 The first part would be setting up the build steps of our demo project. We'll quickly walk 
 through how to build frontend projects with 
 webpack
 , one of the most popular packaging 
 tools these days. And we'll configure tests, code linter, and then set up continuous 
 integration.
  
 There are plenty of nice choices when it comes to workflow integration. Personally, I prefer 
 Team Foundation Server for private projects or a combination of GitHub and Travis-CI for 
 open-source projects. While Team Foundation Server (or Visual Studio Team Services as its 
 cloud-based version) provides a one-stop solution for the entire application life cycle, the 
 combination of GitHub and Travis-CI is more popular in the JavaScript community. In this 
 chapter, we are going use the services provided by GitHub and Travis-CI for our workflow.
  
 Here are what we are going to walk through:
  
 Packaging frontend assets with webpack.
  
 Setting up tests and linter.
  
 Getting our hands on a Git flow branching model and other Git-related 
  
 workflow.
  
 Connecting a GitHub repository with Travis-CI.",NA
Creating an application,"We've talked about creating TypeScript applications for both frontend and backend projects 
 in the 
 Chapter 1
 , 
 Tools and Frameworks
 . And now we are going to create an application that 
 contains two TypeScript projects at the same time.",NA
Decision between SPA and “normal” web ,NA,NA
applications,"Applications for different purposes result in different choices. SPA (single page application) 
 usually delivers a better user experience after being loaded, but it can also lead to trade-offs 
 on SEO and may rely on more complex MV* frameworks like Angular.
  
 One solution to build SEO-friendly SPA is to build a universal (or isomorphic) application 
 that runs the 
 same
  code on both frontend and backend, but that could introduce even more 
 complexity. Or a reverse proxy could be configured to render automatically generated 
 pages with the help of tools like 
 Phantom
 .
  
 In this demo project, we'll choose a more traditional web application with multiple pages to 
 build. And here's the file structure of the client project:",NA
Taking team collaboration into consideration,"Before we actually start creating a real-world application, we need to come up with a 
 reasonable application structure. A proper application structure is more than something 
 under which the code compiles and runs. It should be a result, taking how your team 
 members work together into consideration.
  
 For example, a naming convention is involved in this demo client structure shown earlier: 
 page assets are named after page names instead of their types (for example, 
 style.scss
 ) or 
 names like 
 index.ts
 . And the consideration behind this convention is making it more 
 friendly for file navigation by the keyboard.
  
 Of course, this consideration is valid only if a significant number of developers in your team 
 are cool with keyboard navigation. Other than operation preferences, the experiences and 
 backgrounds of a team should be seriously considered as well:
  
 Should the 
 “
 full-stack
 ”
  mode be enabled for your team?
  
 Should the 
 “
 full-stack
 ”
  mode be enabled for every engineer in your team?
  
 How should you divide work between frontend and backend?
  
 Usually, it's not necessary and not efficient to limit the access of a frontend engineer to 
 client-side development. If it's possible, frontend engineers could take over the controller 
 layer of the backend and leave hardcore business models and logic to engineers that focus 
 more on the backend.
  
 We are having the client and server-side projects in the same repository for an easier 
 integration during development. But it does not mean everything in the frontend or 
 backend code base should be in this single repository. Instead, multiple modules could be 
 extracted and maintained by different developers in practice. For example, you can have 
 database models and business logic models separated from the controllers on the backend.",NA
Building and testing projects,"We have already talked about building and testing TypeScript projects at the beginning of 
 this book. In this section, we will go a little bit further for frontend projects, including the 
 basis of using Webpack to load static assets as well as 
 code linting
 .",NA
Static assets packaging with webpack,"Modularizing helps code keep a healthy structure and makes it maintainable. However, it 
 could lead to performance issues if development-time code written in 
 small
  modules are 
 directly deployed without bundling for production usage. So static assets packaging 
 becomes a serious topic of frontend engineering.
  
 Back to the old days, packaging JavaScript files was just about 
 uglifying
  source code and 
 concatenating files together. The project might be modularized as well, but in a 
 global
  way.
  
 Then we have libraries like Require.js, with modules no longer automatically exposing 
 themselves to the global scope.
  
 But as I have mentioned, having the client download module files separately is not ideal for 
 performance; soon we had tools like browserify, and later, webpack 
 –
  one of the most 
 popular frontend packaging tools these days.",NA
Introduction to webpack,"Webpack is an integrated packaging tool dedicated (at least at the beginning) to frontend 
 projects. It is designed to package not only JavaScript, but also other static assets in a 
 frontend project. Webpack provides built-in support for both 
 asynchronous module 
 definition
  (
 AMD
 ) and commonjs, and can load ES6 or other types of resources via plugins.
  
 ES6 module support will get built-in for webpack 2.0, but by the time this 
 chapter is written, you still need plugins like 
 babel-loader
  or 
 ts-loader
  to 
 make it work. And of course we are going to use 
 ts-loader 
 later.
  
 To install webpack via 
 npm
 , execute the following command:
  
 $ npm install webpack -g",NA
Bundling JavaScript,"Before we actually use webpack to load TypeScript files, we'll have a quick walk through of 
 bundling JavaScript.",NA
Loading TypeScript,"Now we are going to load and transpile our beloved TypeScript using the webpack plugin 
 ts-loader
 . Before updating the configuration, let's install the necessary npm packages:
  
 $ npm install typescript ts-loader --save-dev
  
 If things go well, you should have the TypeScript compiler as well as the 
 ts-loader
  plugin 
 installed locally. We may also want to rename and update the files 
 index.js
  and 
 foo.js 
 to 
 TypeScript files.
  
 Rename 
 index.js
  to 
 index.ts
  and update the module importing syntax:
  
 import * as Foo from './foo';
  
 Foo.test();
  
 Rename 
 foo.js
  to 
 foo.ts
  and update the module exporting syntax:
  
 export function test() {
  
  console.log('Hello, Webpack!'); 
  
 }
  
 Of course, we would want to add the 
 tsconfig.json
  file for those TypeScript files (in the 
 folder 
 client
 ):
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es5"",
  
   
  ""module"": ""commonjs""
  
  },
  
  ""exclude"": [
  
   
  ""out"",
  
   
  ""node_modules""",NA
Splitting code,"To take the advantage of code caching across pages, we might want to split the packaged 
 modules as common pieces. The webpack provides a built-in plugin called 
  
 CommonsChunkPlugin
  that can pick out common modules and have them packed 
 separately.
  
 For example, if we create another file called 
 bar.ts
  that imports 
 foo.ts
  just like 
 index.ts
  
 does, 
 foo.ts
  can be treated as a common chunk and be packed separately:
  
 module.exports = {
  
  entry: ['./src/index', './src/bar'],
  
  ...
  
  plugins: [
  
   
  new Webpack.optimize.CommonsChunkPlugin({
  
   
  name: 'common',
  
    
  filename: 'common.js'
  
   
  })
  
  ] 
  
 };
  
 For multi-page applications, it is common to have different pages with different entry 
 scripts. Instead of manually updating the 
 entry
  field in the configuration file, we can take 
 advantage of it being JavaScript and generate proper entries automatically. To do so, we 
 might want the help of the npm package 
 glob
  for matching page entries:
  
 $ npm install glob --saved-dev
  
 And then update the webpack configuration file:
  
 const glob = require('glob');",NA
Loading other static assets,"As we've mentioned, webpack can also be used to load other static assets like stylesheet and 
 its extensions. For example, you can use the combination of 
 style-loader
 , 
 css-loader 
 and 
 sass-
 loader
 /
 less-loader
  to load 
 .sass
 /
 .less
  files.
  
 The configuration is similar to 
 ts-loader
  so we'll not spend extra pages for their 
 introductions. For more information, refer to the following URLs:
  
 Embedded stylesheets in webpack: 
  
  
 https://webpack.github.io/docs/stylesheets.html
  
 SASS loader for webpack: 
 https://github.com/jtangelder/sass-loader
  
 LESS loader for webpack: 
 https://github.com/webpack/less-loader",NA
Adding TSLint to projects,"A consistent code style is an important factor of code quality, and linters are our best 
 friends when it comes to code styles (and they also helps with common mistakes). For 
 TypeScript linting, TSLint is currently the simplest choice.
  
 The installation and configuration of TSLint are easy. To begin with, let's install 
 tslint
  as a 
 global command:
  
 $ npm install tslint -g
  
 And then we need to initialize a configuration file using the following command under the 
 project root directory:
  
 $ tslint --init",NA
Integrating webpack and tslint command with ,NA,NA
npm scripts,"As we've mentioned before, an advantage of using npm scripts is that they can handle local 
 packages with executables properly by adding 
 node_modules/.bin
  to 
 PATH
 . And to make our 
 application easier to build and test for other developers, we can have 
 webpack
  and 
 tslint
  
 installed as development dependencies and add related scripts to 
 package.json
 :
  
 ""scripts"": {
  
  ""build-client"": ""cd client && webpack"",
  
  ""build-server"": ""tsc --project server"",
  
  ""build"": ""npm run build-client && npm run build-server"",
  
  ""lint"": ""tslint ./*/src/**/*.ts"",
  
  ""test-client"": ""cd client && mocha"",
  
  ""test-server"": ""cd server && mocha"",
  
  ""test"": ""npm run lint && npm run test-client && npm run test-server"" }",NA
Version control,"Thinking back to my senior high school days, I knew nothing about version control tools. 
 The best thing I could do was to create a daily archive of my code on a USB disk. And yes I 
 did lose one!
  
 Nowadays, with the boom of version control tools like Git and the availabilities of multiple 
 free services like GitHub and Visual Studio Team Services, managing code with version 
 control tools has become a daily basis for every developer.
  
 As the most popular version control tool, Git has already been playing an important role in 
 your work or personal projects. In this section, we'll talk about popular practices of using 
 Git in a team.",NA
Git flow,"Version control plays an important a role and it does not only influence the source code 
 management process but also shapes the entire workflow of product development and 
 delivery. Thus a 
 successful
  branching model becomes a serious choice.
  
 Git flow is a collection of Git extensions that provides high-level repository operations for a 
 branching model raised by Vincent Driessen. The name 
 Git flow
  usually refers to the 
 branching model as well.
  
 In this branching model, there are two main branches: 
 master
  and 
 develop
 , as well as 
 three different types of supporting branches: 
 feature
 , 
 hotfix
  , and 
 release
 .
  
 With the help of Git flow extensions, we can easily apply this branching model without 
 having to remember and type detailed sequences of commands. To install, please check out 
 the installation guide of Git flow at: 
 https://github.com/nvie/gitflow/wiki/Installat ion
 .
  
 Before we can use Git flow to create and merge branches, we'll need to make an 
 initialization:
  
 $ git flow init -d
  
 Here 
 -d
  stands for using default branch naming conventions. If you 
 would like to customize, you may omit the 
 -d
  option and answer the 
 questions about 
 git flow init
  command.
  
 This will create 
 master
  and 
 develop
  branches (if not present) and save Git flow-related 
 configuration to the local repository.",NA
Main branches,"The branching model defines two main branches: 
 master
  and 
 develop
 . Those two 
 branches exist in the lifetime of the current repository:
  
  
 The graph in the preceding shows a simplified relationship between 
 develop
  and 
 master
  branches.
  
 Branch master
 : The 
 HEAD
  of 
 master
  branch should always contain production-
 ready source code. It means that no daily development is done on 
 master
  branch 
 in this branching model, and only commits that are fully tested and can be 
 performed with a fast-forward should be merged into this branch.
  
 Branch develop
 : The 
 HEAD
  of 
 develop
  branch should contain delivered 
 development source code. Changes to 
 develop
  branch will finally be merged into 
 master
 , but usually not directly. We'll come to that later when we talk about 
 release
  branches.",NA
Supporting branches,"There are three types of supporting branches in the branching model of Git flow: 
 feature
 , 
 hotfix
 , and 
 release
 . What they roughly do has already been suggested by their names, and 
 we'll have more details to follow.",NA
Feature branches,"A feature branch has only direct interactions with the 
 develop
  branch, which means it 
 checks out from a 
 develop
  branch and merges back to a 
 develop
  branch. The feature 
 branches might be the simplest type of branches out of the three.",NA
Release branches,"In a single iteration of a product, after finishing the development of features, we usually 
 need a stage for fully testing everything, fixing bugs, and actually getting it ready to be 
 released. And work for this stage will be done on release branches.
  
 Unlike feature branches, a repository usually has only one active release branch at a time, 
 and it is usually created by the owner of the repository. When the development branch is 
 reaching a state of release and a thorough test is about to begin, we can then create a release 
 branch using the following command:
  
 $ git flow release start <version>
  
 From now on, bug fixes that are going to be released in this iteration should be merged or 
 committed to branch 
 release/<version>
  and changes to the current 
 release
  branch can be 
 merged back to the 
 develop
  branch anytime.
  
 If the test goes well and important bugs have been fixed, we can then finish this release and 
 put it online:
  
 $ git flow release finish <version>",NA
Hotfix branches,"Unfortunately, there's a phenomenon in the world of developers: bugs are always harder to 
 find before the code goes live. After releasing, if serious bugs were found, we would have to 
 use hotfixes to make things right.
  
 A 
 hotfix
  branch works kind of like a release branch but lasts shorter (because you would 
 probably want it merged as soon as possible). Unlike feature branches being checked out 
 from 
 develop
  branch, a 
 hotfix
  branch is checked out from 
 master
 . And after getting things 
 done, it should be merged back to both 
 master
  and 
 develop
  branches, just like a release 
 branch does.
  
 To create a 
 hotfix
  branch, similarly you can execute the following command:
  
 $ git flow hotfix start <hotfix-name>
  
 And to finish, execute the following command:
  
 $ git flow hotfix finish <hotfix-name>",NA
Summary of Git flow,"The most valuable idea in Git flow beside the branching model itself is, in my opinion, the 
 clear outline of one iteration. You may not need to follow every step mentioned thus far to 
 use Git flow, but just make it fit your work. For example, for small features that can be done 
 in a single commit, you might not actually need a feature branch. But conversely, Git flow 
 might not bring much value if the iteration itself gets chaotic.",NA
Pull request based code review,"Code review
  could be a very important joint of team cooperation. It ensures acceptable 
 quality of the code itself and helps newcomers correct their misunderstanding of the project 
 and accumulate experiences rapidly without taking a wrong path.
  
 If you have tried to contribute code to open-source projects on GitHub, you must be familiar 
 with pull requests or PR. There are actually tools or IDEs with code reviewing workflow 
 built-in. But with GitHub and other self-hosted services like GitLab, we can get it done 
 smoothly without relying on specific tools.",NA
Configuring branch permissions,"Restrictions on accessing specific branches like 
 master
  and 
 develop
  are not technically 
 necessary. But without those restrictions, developers can easily skip code reviewing because 
 they are just able to do so. In services provided by the Visual Studio Team Foundation 
 Server, we may add a custom check in policy to force code review. But in lighter services 
 like GitHub and GitLab, it might be harder to have similar functionality.
  
 The easiest way might be to have developers who are more qualified and familiar with the 
 current project have the permissions for writing the 
 develop
  branch, and restrict code 
 reviewing in this group verbally. For other developers working on this project, pull requests 
 are now forced for getting changes they merged.
  
 GitHub requires an organization account to specify push permissions for 
 branches. Besides this, GitHub provides a status API and can add 
  
 restrictions to merging so that only branches with a valid status can get 
 merged.",NA
Comments and modifications before merge,"A great thing about those popular Git services is that the reviewer and maybe other 
 colleagues of yours may comment on your pull requests or even specific lines of code to 
 raise their concerns or suggestions. And accordingly, you can make modifications to the 
 active pull request and make things a little bit closer to perfect.
  
 Furthermore, references between issues and pull requests are shown in the conversation. 
 This along with the comments and modification records makes the context of current pull 
 requests clear and traceable.",NA
Testing before commits,"Ideally, we would expect every commit we make to pass tests and code linting. But because 
 we are human, we can easily forget about running tests before committing changes. And 
 then, if we have already set up continuous integration (we'll come to that shortly) of this 
 project, pushing the changes would make it red. And if your colleague has set up a CI light 
 with an alarm, you would make it flash and sound out.
  
 To avoid breaking the build constantly, you might want to add a 
 pre-commit
  hook to your 
 local repository.",NA
Git hooks,"Git provides varieties of hooks corresponding to specific phases of an operation or an event. 
 After initializing a Git repository, Git will create hook samples under the directory 
  
 .git/hooks
 .
  
 Now let's create the file 
 pre-commit
  under the directory 
 .git/hooks
  with the following 
 content:
  
 #!/bin/sh 
  
 npm run test
  
 The hook file does not have to be a bash file, and it can just be any 
  
 executable. For example, if you want like to work with a Node.js hook, you 
 can update the shebang as 
 #!/usr/bin/env node
  and then write the hook in 
 JavaScript.
  
 And now Git will run tests before every commit of changes.",NA
Adding pre-commit hook automatically,"Adding hooks manually to the local repository could be trivial, but luckily we have npm 
 packages like 
 pre-commit
  that will add pre-commit hooks automatically when it's installed 
 (as you usually might need to run 
 npm install
  anyway).
  
 To use the 
 pre-commit
  package, just install it as a development dependency:
  
 $ npm install pre-commit --save-dev",NA
Continuous integration,"The
  continuous integration
  (
 CI
 ) refers to a practice of integrating multiple parts of a project 
 or solution together regularly. Depending on the size of the project, the integration could be 
 taken for every single change or on a timed schedule.
  
 The main goal of continuous integration is to avoid integration issues, and it also enforces 
 the discipline of frequent automated testing, this helps to find bugs earlier and prevents the 
 degeneration of functionalities.
  
 There are many solutions or services with continuous integration support. For example, self-
 hosted services like TFS and Jenkins, or cloud-based services like Visual Studio Team 
 Services, Travis-CI, and AppVeyor. We are going to walk through the basic configuration of 
 Travis-CI with our demo project.",NA
Connecting GitHub repository with Travis-CI,"We are going to use GitHub as the Git service behind continuous integration. First of all, 
 let's get our GitHub repository and Travis-CI settings ready:
  
 1. Create a correspondent repository as origin and push the local repository to 
  
 GitHub:",NA
Deployment automation,"Rather than a version control tool, Git is also popular for relatively simple deployment 
 automation. And in this section, we'll get our hands on and configure automated 
 deployment based on Git.",NA
Passive deployment based on Git server side ,NA,NA
hooks,"The idea of passive deployment is simple: when a client pushes commits to the bare 
 repository on the server, a 
 post-receive
  hook of Git will be triggered. And thus we can 
 add scripts checking out changes and start deployment.
  
 The elements involved in the Git deployment solution on both the client and server sides 
 includes:
  
  
 To make this mechanism work, we need to perform the following steps:
  
 1. 
  
 Create a bare repository on the server with the following command:
  
  $ mkdir deployment.git
  
  $ cd deployment.git
  
  $ git init --bare
  
 A bare repository usually has the extension 
 .git
  and can be treated as a 
 centralized place for sharing purposes. Unlike normal repositories, a bare 
 repository does not have the working copy of source files, and its structure 
 is quite similar to what's inside a 
 .git
  directory of a normal repository.
  
 2.Add 
 deployment.git
  as a remote repository of our project, and try to push the 
  
 master
  branch to the 
 deployment.git
  repository:
  
  $ cd ../demo-project
  
  $ git remote add deployment ../deployment.git $ git push -u 
 deployment master",NA
Proactive deployment based on timers or ,NA,NA
notifications,"Instead of using Git hooks, we can have other tools pull and build the application 
 automatically as well. In this way, we no longer need the client to push changes to servers 
 separately. And instead, the program on the server will pull changes from a remote 
 repository and complete deployment.
  
 A notification mechanism is preferred to avoid frequent fetching though, and there are 
 already tools like PM2 that have automated deployment built-in. You can also consider 
 building up your own using hooks provided by cloud-based or self-hosted Git services.",NA
Summary,"In this final chapter, we built the outline of a complete workflow starting with building 
 and testing to continuous integration and automated deployment. We've covered some 
 popular services or tools and provide other options for readers to discover and explore.
  
 Among the varieties of choice, you might agree that the most appropriate workflow for 
 your team is the workflow that fits the best. Taking people rather than technologies alone 
 into consideration is an important part of software engineering, and it is also the key to 
 keeping the team efficient (and happy, perhaps).
  
 The sad thing about a team, or a crowd of people is that usually only a few of them can keep 
 the passion burning. We
 ’
 ve talked about finding the balance point, but that is what we still 
 need to practice. And in most of the cases, expecting every one of your team to find the right 
 point is just unreasonable. When it comes to team projects, we'd better have rules that can 
 be validated automatically instead of conventions that are not testable.
  
 After reading this book, I hope the reader gets the outlines of the build steps, workflow, and 
 of course knowledge of common design patterns. But rather than the cold explanations of 
 different terms and patterns, there are more important ideas I wanted to deliver:
  
 We as humans are dull, and should always keep our work divided as controllable 
 pieces, instead of acting like a genius. And that's also why we need to 
 design 
 software to make our lives easier.
  
 And we are also unreliable, especially at a scale of some mass (like a team).
  
 As a learner, always try to understand the reason behind a conclusion or 
  
 mechanism behind a phenomenon.",NA
Module 3,"TypeScript Blueprints
  
 Build exciting end-to-end applications with TypeScript",NA
Module 3: TypeScript Blueprints,"Chapter 1: TypeScript 2.0 Fundamentals
  
 1
  
 What is TypeScript?
  
 Quick example 
  
  
 Transpiling 
  
  
 Type checking 
  
 Learning modern JavaScript 
  
  
 let and const 
  
  
 Classes 
  
  
 Arrow functions 
  
  
 Function arguments 
  
  
 Array spread 
  
  
 Destructuring 
  
  
 Template strings 
  
  
 New classes 
  
 Type checking 
  
  
 Primitive types 
  
  
 Defining types 
  
  
 Undefined and null 
  
  
 Type annotations 
  
 Summary
  
 Chapter 2: A Weather Forecast Widget with Angular 2
  
 1 
  
 2 
  
 3 
  
 4 
  
 4 
  
 5 
  
 6 
  
 6 
  
 7 
  
 8 
  
 8 
  
 8 
  
 9 
  
 9 
  
 9 
  
 10 
  
 11 
  
 11 
  
 12
  
 13
  
 Using modules 
  
 Setting up the project 
  
  
 Directory structure 
  
  
 Configuring TypeScript 
  
  
 Building the system 
  
  
 The HTML file 
  
 Creating the first component 
  
  
 The template 
  
  
 Testing 
  
  
 Interactions 
  
  
 One-way variable binding 
  
  
 Event listeners 
  
 Adding conditions to the template
  
 1
 4 
  
 1
 5 
  
 1
 5 
  
 1
 6 
  
 1
 6 
  
 1
 8 
  
 2
 0 
  
 2
 1 
  
 2
 1 
  
 2",NA
TypeScript 2.0 Fundamentals ,NA,NA
,"In Chapters 
 2
  through 
 5
 , we will learn a few frameworks to create (web) applications with 
 TypeScript. First you need some basic knowledge of 
 TypeScript 2.0
 . If you have used 
 TypeScript previously, then you can skim over this chapter, or use it as a reference while 
 reading the other chapters. If you have not used TypeScript yet, then this chapter will teach 
 you the fundamentals of TypeScript.",NA
What is TypeScript?,"The TypeScript language looks like JavaScript; it is JavaScript with type annotations added 
 to it. The TypeScript compiler has two main features: it is a 
 transpiler
  and a 
 type checker
 . A 
 transpiler is a special form of compiler that outputs source code. In case of the TypeScript 
 compiler, TypeScript source code is compiled to JavaScript code. A type checker searches 
 for contradictions in your code. For instance, if you assign a string to a variable, and then 
 use it as a number, you will get a type error.
  
 The compiler can figure out some types without type annotations; for others you have to 
 add type annotations. An additional advantage of these types is that they can also be used 
 in editors. An editor can provide completions and refactoring based on the type 
  
 information. Editors such as Visual Studio Code and Atom (with a plugin, namely atom-
 typescript) provide such features.",NA
Quick example,"The following example code shows some basic TypeScript usage. If you understand this 
 code, you have enough knowledge for the next chapters. This example code creates an 
 input box in which you can enter a name. When you click on the button, you will see a 
 personalized greeting:
  
 class Hello {
  
  private element: HTMLDivElement;
  
  private elementInput: HTMLInputElement;
  
  private elementText: HTMLDivElement;
  
  constructor(defaultName: string) {
  
   
  this.element = document.createElement(""div"");
  
   
  this.elementInput = document.createElement(""input"");
   
  
 this.elementText = document.createElement(""div"");
  
   
  const elementButton = document.createElement(""button"");
  
  elementButton.textContent = ""Greet"";
  
  this.element.appendChild(this.elementInput); 
 this.element.appendChild(elementButton); 
 this.element.appendChild(this.elementText);
  
  this.elementInput.value = defaultName;
  
  this.greet();
  
  
  elementButton.addEventListener(""click"",
  
  
  
 () => this.greet()
  
  
  );
  
  }
  
  show(parent: HTMLElement) {
  
  
  parent.appendChild(this.element);
  
  }
  
  greet() {
  
   
  this.elementText.textContent = `Hello,
  
  
  ${ this.elementInput.value }!`;
  
  } 
  
 }
  
 const hello = new Hello(""World""); 
  
 hello.show(document.body);",NA
Transpiling,"The compiler transpiles TypeScript to JavaScript. It does the following transformations on 
 your source code:
  
 Remove all type annotations
  
 Compile new JavaScript features for old versions of JavaScript
  
 Compile TypeScript features that are not standard JavaScript",NA
Type checking,"The most important feature of TypeScript is type checking. For instance, for the following 
 code, it will report that you cannot assign a number to a string:
  
 let x: string = 4;
  
 In the next sections, you will learn the new features of the latest JavaScript versions. 
 Afterward, we will discuss the basics of the type checker.",NA
Learning modern JavaScript,"JavaScript has different versions. Some of these are 
 ES3
 , 
 ES5
 , 
 ES2015
  (also known as 
 ES6
 ), 
 and 
 ES2016
 . Recent versions are named after the year in which they were introduced. 
 Depending on the environment for which you write code, some features might be or might 
 not be supported. TypeScript can compile new features of JavaScript to an older version of 
 JavaScript. That is not possible with all features, however.",NA
let and const,"ES2015 has introduced 
 let
  and 
 const
 . These keywords are alternatives to 
 var
 . These prevent 
 issues with scoping, as 
 let
  and 
 const
  are block scoped instead of function scoped.
  
 You can use such variables only within the block in which they were created. It is not 
 allowed to use such variables outside of that block or before its definition. The following 
 example illustrates some dangerous behavior that could be prevented with 
 let
  and 
 const
 :
  
 alert(x.substring(1, 2)); 
  
 var x = ""lorem""; 
  
 for (var i = 0; i < 10; i++) {
  
  setTimeout(function() {
  
   
  alert(i);
  
  }, 10 * i); 
  
 }
  
 The first two lines give no error, as a variable declared with 
 var
  can be used before its 
 definition. With 
 let
  or 
 const
 , you will get an error, as expected.
  
 The second part shows 
 10
  message boxes saying 
 10
 . We would expect 
 10
  messages saying 
 0
 , 
 1
 , 
 2
 , and so on up to 9. But, when the callback is executed and 
 alert
  is called, 
 i
  is already 
 10
 , so you see 
 10
  messages saying 
 10
 .
  
 When you change the 
 var
  keywords to 
 let
 , you will get an error in the first line and the 
 messages work as expected. The variable 
 i
  is bound to the loop body. For each iteration, it 
 will have a different value. The for loop is transpiled as follows:
  
 var _loop_1 = function(i) {
  
  
  setTimeout(function () {
  
  
  
  alert(i);
  
  
  }, 10 * i); 
  
 }; 
  
 for (var i = 0; i < 10; i++) {
  
  
  _loop_1(i); 
  
 }
  
 A variable declared with 
 const
  cannot be reassigned, and a variable with 
 let
  can be 
 reassigned. If you reassign a 
 const
  variable, you get a compile error.",NA
Classes,"As of ES2015, you can create classes easily. In older versions, you could simulate classes to a 
 certain extent. TypeScript transpiles a class declaration to the old way to simulate a class:
  
 class Person {
  
  age: number;
  
  constructor(public name: string) {
  
  }
  
  greet() {
  
   
  console.log(""Hello, "" + this.name);
  
  } 
  
 }
  
 const person = new Person(""World""); 
  
 person.age = 35; 
  
 person.greet();
  
 This example is transpiled to the following:
  
 var Person = (function () {
  
  
  function Person(name) {
  
  
  
  this.name = name;
  
  
  }
  
  
  Person.prototype.greet = function () {
  
  
  
 console.log(""Hello, "" + this.name);
  
  };
  
  
  return Person; 
  
 }()); 
  
 var person = new Person(""World""); 
  
 person.age = 35; 
  
 person.greet();
  
 When you prefix an argument of the constructor with public or private, it is added as a 
 property of the class. Other properties must be declared in the body of the class. This is not 
 per the JavaScript specification, but needed with TypeScript for type information.",NA
Arrow functions,"ES6 introduced a new way to create functions. 
 Arrow functions
  are function expressions 
 defined using 
 =>
 . Such function looks like the following:
  
 (x: number, y: boolean): string => {
  
  statements 
  
 }",NA
Function arguments,"It is possible to add a default value to an argument:
  
 function sum(a = 0, b = 0, c = 0) {
  
  return a + b + c; 
  
 } 
  
 sum(10, 5);
  
 When you call this function with less than three arguments, it will set the other arguments 
 to 0. TypeScript will automatically infer the types of 
 a
 , 
 b
 , and 
 c
  based on their default 
 values, so you do not have to add a type annotation there.
  
 You can also define an optional argument without a default value: 
 function a(x?: 
 number) {}
 . The argument will then be undefined when it is not provided. This is not 
 standard JavaScript, but only available in TypeScript.
  
 The 
 sum
  function can be defined even better, with a 
 rest argument
 . At the end of a function, 
 you can add a rest argument:
  
 function sum(...xs: number[]) {
  
  let total = 0;
  
  for (let i = 0; i < xs.length; i++) total += xs[i]; return total; 
  
 } 
  
 sum(10, 5, 2, 1);",NA
Array spread,"It is easier to create arrays in ES6. You can create an array literal (with brackets), in which 
 you use another array. In the following example, you can see how you can add an item to a 
 list and how you can concatenate two lists:
  
 const 
 a 
 = 
 [0, 
 1, 
 2]; 
  
 const 
 b 
 = 
 [...a, 
 3]; 
  
 const c = [...a, ...b];
  
 A similar feature for object literals will probably be added to JavaScript too.",NA
Destructuring,"With 
 destructuring
 , you can easily create variables for properties of an object or elements of 
 an array:
  
 const a = { x: 1, y: 2, z: 3 }; 
  
 const b = [4, 5, 6];
  
 const { x, y, z } = a; 
  
 const [u, v, w] = b;
  
 The preceding is transpiled to the following:
  
 var a = { x: 1, y: 2, z: 3 }; 
  
 var b = [4, 5, 6];
  
 var x = a.x, y = a.y, z = a.z; 
  
 var u = b[0], v = b[1], w = b[2];
  
 You can use destructing in an assignment, variable declaration, or argument of a 
 function header.",NA
Template strings,"With template strings, you can easily create a string with expressions in it. If you would 
 write 
 ""Hello, "" + name + ""!""
 , you can now write 
 Hello ${ name }!
 .",NA
New classes,"ES2015 has introduced some new classes, including 
 Map
 , 
 Set
 , 
 WeakMap
 , 
 WeakSet
 , and 
 Promise
 . In modern browsers, these classes are already available. For other environments, 
 TypeScript does not automatically add a fallback for these classes. Instead, you should use a 
 polyfill
 , such as es6-shim. Most browsers already support these classes, so in most cases, 
 you do not need a polyfill. You can find information on browser support at 
 http://canius 
 e.com
 .",NA
Type checking,"The compiler will check the types of your code. It has several primitive types and you can 
 define new types yourself. Based on these types, the compiler will warn when a value of a 
 type is used in an invalid manner. That could be using a string for multiplication or using a 
 property of an object that does not exist. The following code would show these errors:
  
 let x = ""foo""; 
  
 x * 2; 
  
 x.bar();
  
 TypeScript has a special type, called 
 any
 , that allows everything; you can assign every value 
 to it and you will never get type errors. The type 
 any
  can be used if you do not have an exact 
 type (
 yet
 ), for instance, because it is a complex type or if it is from a library that was not 
 written in TypeScript. This means that the following code gives no compile errors:
  
 let x: any = ""foo""; 
  
 x * 2; 
  
 x.bar();
  
 In the next sections, we will discover these types and learn how the compiler finds these 
 types.",NA
Primitive types,"TypeScript has several primitive types, which are listed in the following table:
  
 Name
  
 Values
  
 Example
  
 boolean
  
 true
 , 
 false
  
 let x: boolean = true;
  
 string
  
 Any string literal
  
 let x: string = ""foo"";",NA
Defining types,"You can define your own types in various ways:
  
 Kind
  
 Meaning
  
 Example
  
 Object type
  
 Represents an object, with the specified
  
 let x: {
  
  a: boolean,
  
 properties. Properties marked with 
 ?
  are
  
  b: string,
  
 optional. Objects can also have an indexer (for
  
  c?: number,
  
 example, like an array), or call signatures.
  
  [i: number]:
  
 Object types can be defined inline, with a class
  
 string
  
 or with an interface declaration.
  
 };
  
 x = {
  
  a: true, b: ""foo"" 
  
 }; 
  
 x[0] = ""foo"";
  
 Union type
  
 A value is assignable to a union type if it is
  
 let x: string |
  
 number;
  
 assignable to one of the specified types. In the
  
 x = ""foo"";
  
 example, it should be a string or a number.
  
 Intersection
  
 x = 42;
  
 A value is assignable to an intersection type if it is
  
 let x: { a: string }
  
 type
  
 assignable to all specified types.
  
 & { b:   number } =
  
 { a: ""foo"", b: 42 };
  
 Enum type
  
 A special number type, with several values
  
 enum E {
  
 declared. The declared members get a value
  
  X,
  
  Y = 100
  
 automatically, but you can also specify a value.
  
 }
  
 let a: E = E.X;
  
 [ 10 ]",NA
Undefined and null,"By default, 
 undefined
  and 
 null
  can be assigned to every type. Thus, the compiler cannot
  
 give you a warning when a value can possibly be undefined or null. TypeScript 2.0 has 
 introduced a new mode, called 
 strictNullChecks
 , which adds two new types:
  
 undefined
  and 
 null
 . With that mode, you do get warnings in such cases. We will discover
  
 that mode in 
 Chapter 6
 , 
 Advanced Programming in TypeScript
 .",NA
Type annotations,"TypeScript can infer some types. This means that the TypeScript compiler knows the type, 
 without a type annotation. If a type cannot be inferred, it will default to 
 any
 . In such a case,
  
 or in case the inferred type is not correct, you have to specify the types yourself. The
  
 common declarations that you can annotate are given in the following table:
  
 Location
  
 Can it be inferred?
  
 Examples
  
 let a: number; let b = 
 1;
  
 function a(x: number) {} function 
 b(x = 1) {} 
  
 [1, 2].map(
  
  
  x => x * 2 
  
 );
  
 function a(): number { } (): 
 number => { }
  
 Variable declaration
  
 Yes, based on initializer
  
 Function argument
  
 Yes, based on default value (second
  
 example) or when passing the function to 
 a typed variable or function (third 
  
 example)
  
 Function return type Yes, based on return statements in body
  
 function c() {
  
  
  return 1; 
  
 }
  
 [ 11 ]",NA
Summary,"In this chapter, you discovered the basics of TypeScript. You should now be familiar with 
 the principles of TypeScript and you should understand the code example at the beginning 
 of the chapter. You now have the knowledge to start with the next chapters, in which you 
 will learn two major web frameworks, Angular 2 and React. We will start with Angular 2 in 
 Chapter 2
 , 
 A Weather Forecast Widget with Angular 2
 .
  
 [ 12 ]",NA
A Weather Forecast Widget ,NA,NA
,NA,NA
with Angular 2,"In this chapter, we'll create a simple application that shows us the weather forecast. The 
 framework we use, Angular 2, is a new framework written by Google in TypeScript. The 
 application will show the weather of the current day and the next. In the following 
 screenshot, you can see the result. We will explore some key concepts of Angular, such as 
 data binding and directives.
  
  
 We will build the application in the following steps:
  
 Using modules
  
 Setting up the project
  
 Creating the first component
  
 Adding conditions to the template
  
 Showing a forecast
  
 Creating the forecast components",NA
Using modules,"We will use 
 modules
  in all applications in this book. Modules (also called external modules 
 and ES2015 modules) are a concept of separating code in multiple files. Every file is a 
 module. Within these modules, you can use variables, functions, and classes (members) 
 exported by other modules and you can make some members visible for other modules. To 
 use other modules, you must import them, and to make members visible, you need to 
 export them. The following example will show some basic usage:
  
 // x.ts 
  
 import { one, add, Lorem } from './y'; 
  
 console.log(add(one, 2));
  
 var lorem = new Lorem(); 
  
 console.log(lorem.name);
  
 // y.ts 
  
 export var one = 1; 
  
 export function add(a: number, b: number) { return a + b; 
  
 } 
  
 export class Lorem {
  
  name = ""ipsum""; 
  
 }
  
 You can 
 export
  declarations by prefixing them with the 
 export
  keyword or by prefixing 
 them with 
 export default
 . A default export should be imported differently though we will not 
 use such an export as it can be confusing. There are various ways to 
 import
  a file. We have 
 seen the variant that is used most times, 
 import { a, b, c } from './d'
 . The dot and slash mean 
 that the 
 d.ts
  file is located in the same directory. You can use 
 ./x/y 
 and 
 ../z
  to reference a file 
 in a subdirectory or a parent directory. A reference that does not start with a dot can be used 
 to import a library, such as Angular. Another import variant is 
 import * as e from './d'
 . This 
 will import all exports from 
 d.ts
 . These are available as 
 e.a
 , 
 e.b
 , 
 e
  is an object that contains all 
 exports.
  
 To keep code readable and maintainable, it is advisable to use multiple small files instead of 
 one big file.",NA
Setting up the project,"We will quickly set up the project before we can start writing. We will use 
 npm
  to 
 manage our dependencies and 
 gulp
  to build our project. These tools are built on 
 NodeJS
 , 
 so it should be installed from nodejs.org.
  
 First of all, we must create a new directory in which we will place all files. We must create a 
 package.json
  file used by 
 npm
 :
  
 {
  
  ""name"": ""weather-widget"",
  
  ""version"": ""1.0.0"",
  
  ""private"": true,
  
  ""description"": """" 
  
 }
  
 The 
 package.json
  file contains information about the project, such as the name, version, and 
 a description. These fields are used by 
 npm
  when you publish a project on the registry on 
 NPM, which contains a lot of open source projects. We will not publish it there. We set the 
 private
  field to 
 true
 , so we cannot accidentally publish it.",NA
Directory structure,"We will separate the TypeScript sources from the other files. The TypeScript files will be 
 added in the 
 lib
  directory. Static files, such as HTML and CSS, will be located in the 
 static
  
 directory. This directory can be uploaded to a webserver. The compiled sources will be 
 written to 
 static/scripts
 . We first install Angular and some requirements of Angular with 
 npm
 . In a terminal, we run the following command in the root directory of the project:
  
 npm install angular2 rxjs es6-shim reflect-metadata zone.js --save
  
 The console might show some warnings about unmet peer dependencies. These will 
 probably be caused by a minor version mismatch between Angular and one of its 
 dependencies. You can ignore these warnings.",NA
Configuring TypeScript,"TypeScript can be configured using a 
 tsconfig.json
  file. We will place that file in the 
 lib 
 directory, as all our files are located there. We specify the 
 experimentalDecorators
  and 
 emitDecoratorMetadata
  options, as these are necessary for Angular:
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es5"",
  
   
  ""module"": ""commonjs"",
  
   
  ""experimentalDecorators"": true,
  
   
  ""emitDecoratorMetadata"": true,
  
   
  ""lib"": [""es2015"", ""dom""]
  
  } 
  
 }
  
 The 
 target
  option specifies the version of JavaScript of the generated code. Current browsers 
 support 
 es5
 . TypeScript will compile newer JavaScript features, such as classes, to an 
 es5
  
 equivalent. With the 
 lib
  option, we can specify the version of the JavaScript library.
  
 We use the libraries from 
 es2015
 , the version after 
 es5
 . Since these libraries might not be 
 available in all browsers, we will add a polyfill for these features later on. We also include 
 the libraries for the 
 DOM
 , which contains functions such as 
 document.createElement 
 and 
 document.getElementById
 .",NA
Building the system,"With 
 gulp
 , it is easy to compile a program in multiple steps. For most webapps, multiple 
 steps are needed: compiling TypeScript, bundling modules, and finally minifying all code. 
 In this application, we need to do all of these steps.
  
 Gulp streams source files through a series of plugins. These plugins can (just like gulp itself) 
 be installed using 
 npm
 :
  
 npm install gulp --global 
  
 npm install gulp gulp-typescript gulp-sourcemaps gulp-uglify small --save-dev
  
 The 
 --global
  flag will install the dependency globally such that you can 
 call gulp from a terminal. The 
 --save-dev
  flag will add the dependency to 
 the 
 devDependencies
  (development dependencies) section of the 
 package.json
  file. Use 
 --save
  to add a runtime dependency.",NA
The HTML file,"The main file of our application is the HTML file, 
 static/index.html
 . This file will 
 reference our (compiled) scripts and stylesheet:
  
 <!DOCTYPE HTML> 
  
 <html>
  
  <head>
  
   
  <title>Weather</title>
  
   
  <link rel=""stylesheet"" href=""style.css"" /> </head>",NA
Creating the first component,"Angular is based on components. Components are built with other components and normal 
 HTML tags. Our application will have three components: the forecast page, the about page, 
 and the whole widget. The widget itself, which is referenced in the HTML page, will use the 
 other two widgets.
  
 The widget will show the 
 About
  page in the third tab, as you can see in the following 
 screenshot:
  
  
 The forecast component is shown in the first tab of the following screenshot. We will create 
 the forecast and the widget later in this chapter.
  
  
 [ 20 ]",NA
The template,"A component is a class decorated with some metadata. 
 Decorators
  are functions that can 
 modify a class or decorate it with some metadata. A simple component that does not have 
 any interaction will look like this:
  
 import { Component } from ""angular2/core"";
  
 @Component({
  
  selector: ""about-page"", 
  
 template: `
  
   
  <h2>About</h2>
  
   
  This widget shows the weather forecast of Utrecht.
  
  
  The next 24 hours are shown under 'Today' and the forecast of 24-48 hours ahead 
 under 'Tomorrow'.
  
  ` 
  
 }) 
  
 export class About { 
  
 }
  
 As a convention, you can always choose selector names with a dash (
 -
 ). 
 You can then identify components by the dash. Normal HTML tags will 
 never have names with a dash.
  
 This component will be the about page selector of our application. We will modify it in the 
 next sessions. We will use one file per component, so we save this as 
 lib/about.ts
 .",NA
Testing,"We can test the component by calling the bootstrap function. We create a new file, 
 lib/index.ts
 , which will start the application:
  
 import ""zone.js""; 
  
 import ""rxjs""; 
  
 import ""reflect-metadata""; 
  
 import ""es6-shim""; 
  
 import { bootstrap } from ""angular2/platform/browser""; import { About } 
 from ""./about"";
  
 bootstrap(About).catch(err => console.error(err));",NA
Interactions,"We can add an interaction inside the class body. We must use bindings to connect the 
 template to definitions in the body. There are three different bindings:
  
 One-way variable binding
  
 One-way event listener
  
 Two-way binding
  
 A one-way binding will connect the class body and template in one direction. In case of a 
 variable, changes of the variable will update the template, but the template cannot update 
 the variable. A template can only send an event to the class. In case of a two-way binding, a 
 change of the variable changes the template and a change in the template will change the 
 variable. This is useful for the value of an input element, for example. We will take a look at 
 one-way bindings in the next section.",NA
One-way variable binding,"In the first attempt of the about page, the location (
 Utrecht
 ) is hardcoded. In the final 
 application, we want to choose our own location. The first step we will take is to add a 
 property to the class that contains the location. Using a one-way binding, we will reference 
 that value in the template. A one-way variable binding is denoted with brackets inside 
 attributes and double curly brackets inside text:
  
 import { Component } from ""angular2/core"";
  
 @Component({
  
  selector: ""about-page"",
  
  template: `
  
   
  <h2>About</h2>
  
   
  This widget shows the weather forecast of
  
   
  <a [href]=""'https://maps.google.com/?q=' + encodedLocation"">
  
    
  {{ location }}
  
   
  </a>
  
   
  The next 24 hours are shown under 'Today' and the forecast        of 24-48 hours ahead under 
 'Tomorrow'.
  
   
  ` 
  
 }) 
  
 export class About {
  
  location = ""Utrecht"";
  
  get encodedLocation() {
  
   
  return encodeURIComponent(this.location); } 
  
 }
  
 At the time of writing this, templates aren't checked by TypeScript. Make 
 sure that you write the correct names of the variables. Variables should 
 not be prefixed by 
 this.
 , like you would do in class methods.
  
 You can add an expression in such bindings. In this example, the binding of the 
 href 
 attribute does string concatenation. However, the subset of expressions is limited. You can 
 add more complex code inside getters in the class, as done with 
 encodedLocation
 .
  
 You can also use a different getter, which would encode the location and 
 concatenate it with the Google Maps URL.",NA
Event listeners,"Event bindings can connect an event emitter of a tag or component to a method of a 
 function. Such binding is denoted with parenthesis in the template. We will add a 
 show-
 more
  button to our application:
  
 import { Component} from ""angular2/core"";
  
 @Component({
  
  selector: ""about-page"",
  
  template: `
  
   
  <h2>About</h2>
  
   
  This widget shows the weather forecast of
  
   
  <a [href]=""'https://maps.google.com/?q=' + encodedLocation"">
   
  
  
 {{ location }}
  
   
  </a>.
  
  
  The next 24 hours are shown under 'Today' and the forecast        of 24-48 hours ahead under 
 'Tomorrow'.
  
   
  <br />
  
   
  <a href=""javascript:;"" (click)=""show()"">Show more</a>
  
  
  
 <a href=""javascript:;"" (click)=""hide()"">Show less</a>
  
  
  ` 
  
 }) 
  
 export class About {
  
  location = ""Utrecht"";
  
  collapsed = true;
  
  show() {
  
   
  this.collapsed = false;
  
  }
  
  hide()
  
  {
  
   
  this.collapsed = true;
  
  }
  
  get encodedLocation() {
  
   
  return encodeURIComponent(this.location); } 
  
 }
  
 The 
 show()
  or 
 hide()
  function will be called when one of the show or hide links is clicked on.",NA
Adding conditions to the template,"The event handler in the previous section sets the property collapsed to false but that 
 does not modify the template. In normal code, we would have written 
 if (this.collapsed) { ... 
 }
 . In templates, we cannot use that, but we can use 
 ngIf
 .",NA
Directives,"A directive is an extension to normal HTML tags and attributes. It can define custom 
 behavior. A custom component, such as the 
 About
  page, can be seen as a directive too. 
 The 
 ngIf
  condition is a built-in directive in Angular. It is a custom attribute that displays 
 the content if the specified value is true.",NA
The template tag,"If a piece of a component needs to be shown a variable an amount of times, you can wrap it 
 in a 
 template
  tag. Using the 
 ngIf
  (or 
 ngFor
 ) directive, you can control how often it is shown 
 (in case of 
 ngIf
 , once or zero times). The 
 template
  tag will look like this:
  
 <template [ngIf]=""collapsed"">
  
  <div>Content</div> 
  
 </template>
  
 You can abbreviate this as follows:
  
 <div *ngIf=""collapsed"">Content</div>
  
 It is advised to use the abbreviated style, but it's good to remember that it is shorthand for 
 the 
 template
  tag.",NA
Modifying the about template,"Since 
 ngIf
  is a built-in directive, it doesn't have to be imported. Custom directives need to 
 be imported. We will see an example of using custom components later in this chapter. In 
 the template, we can use 
 *ngIf
  now. The template will thus look like this:
  
  template: `
  
  
  <h2>About</h2>
  
  
  This widget shows the weather forecast of
  
  
  <a [href]=""'https://maps.google.com/?q=' + encodedLocation"">
   
  {{ 
 location }}
  
  
  </a>.
  
  
  The next 24 hours are shown under 'Today' and the forecast        of 24-48 hours ahead under 
 'Tomorrow'.
  
  <br />
  
  <a *ngIf=""collapsed"" href=""javascript:;"" (click)=""show()"">Show more</a>
  
  <div *ngIf=""!collapsed"">
  
  The forecast uses data from <a
  
  href=""http://openweathermap.org"">Open Weather Map</a>.
  
    
  <br />
  
    
  <a href=""javascript:;"" (click)=""hide()"">Hide</a>
   
  
 </div>
  
  ` 
  
 })
  
 The class body does not have to be changed. As you can see, you can use expressions in the 
 *ngIf
  bindings, which is not surprising as it is a shorthand for one-way variable bindings.",NA
Using the component in other components,"We can use the 
 about-page
  component in other components, as if it was a normal HTML 
 tag. But the component is still boring, as it will always say that it shows the weather 
 broadcast of Utrecht. We can mark the 
 location
  property as an input. After that, 
 location
  is 
 an attribute that we can set from other components. It is even possible to bind it as a one-
 way binding. The 
 Input
  decorator, which we are using here, needs to be imported just like 
 Component
 :
  
 import { Component, Input } from ""angular2/core"";
  
 @Component({
  
  ...
  
 }) 
  
 export class About {",NA
Showing a forecast,"We still have not shown a forecast yet. We will use data from open weather map (
 http://w 
 ww.openweathermap.org
 ). You can create an account on their website. With your account, you 
 can request an API token. You need the token to request the forecast. A free account is 
 limited to 60 requests per second and 50,000 requests per day.
  
 We save the API token in a separate file, 
 lib/config.ts
 :
  
 export const openWeatherMapKey = ""your-token-here""; 
  
 export const apiURL = ""http://api.openweathermap.org/data/2.5/"";
  
 Add constants to a separate file 
  
 When you add constants in separate configuration files, you can easily 
 change them and your code is more readable. This gives you better 
 maintainable code.",NA
Using the API,"We will create a new file, 
 lib/api.ts
 , that will simplify downloading data from open weather 
 map. The API uses URLs such as 
  
 http://api.openweathermap.org/data/2.5/forecast?mode=json&q=Utrecht,NL&
  
 appid=your-token-here
 . We will create a function that will build the full URL out of 
 forecast?mode=json&q=Utrecht,NL
 . The function must check whether the path already 
 contains a question mark. If so, it must add 
 &appid=
 , otherwise 
 ?appid=
 :
  
 import { openWeatherMapKey, apiURL } from ""./config"";",NA
Typing the API,"You can open the URL in the previous section to get a look at the data you get. We will 
 write an interface for the part of the API that we will use:
  
 export interface ForecastResponse {
  
  city: {
  
   
  name: string;
  
   
  country: string;
  
  };
  
  list: ForecastItem[]; 
  
 } 
  
 export interface ForecastItem {
  
  dt: number;
  
  main: {
  
   
  temp: number
  
  };
  
  weather: {
  
   
  main: string,
  
   
  description: string
  
  }; 
  
 }
  
 JSDoc comments 
  
 You can add documentation for interfaces and their properties by adding 
 a JSDoc comment before it: 
  
 /*** Documentation here */",NA
Creating the forecast component,"As a quick recap, the forecast widget will look like this:
  
  
 What properties does the class need? The template will need forecast data of the current day 
 or the next day. The component can show the weather of 
 Today
  and 
 Tomorrow
 , so we will 
 also need a property for that. For fetching the forecast, we also need the location. To show 
 the loading state in the template, we will also store that in the class. This will result in the 
 following class, in 
 lib/forecast.ts
 :
  
 import { Component, Input } from ""angular2/core""; import { 
 ForecastResponse } from ""./api"";
  
 export interface ForecastData {
  
  date: string;
  
  temperature: number;
  
  main: string;
  
  description: string; 
  
 }
  
 enum State {
  
  Loading,
  
  Refreshing,
  
  Loaded,
  
  Error 
  
 }
  
 @Component({
  
  selector: ""weather-forecast"",
  
  template: `...` 
  
 }) 
  
 export class Forecast {
  
  temperatureUnit = ""degrees Celsius"";
  
  @Input()",NA
Templates,"The template uses the 
 ngFor
  directive to iterate over the 
 data
  array:
  
 import { Component, Input } from ""angular2/core""; import { 
 ForecastResponse } from ""./api"";
  
 ...
  
 @Component({
  
  selector: ""weather-forecast"",
  
  template: `
  
   
  <span *ngIf=""loading"" class=""state"">Loading...</span>
  
   
  <span *ngIf=""refreshing"" class=""state"">Refreshing...</span>
  
   
  <a *ngIf=""loaded || error"" href=""javascript:;""        (click)=""load()"" class=""state"">Refresh</a>
  
   
  <h2>{{ tomorrow ? 'Tomorrow' : 'Today' }}'s weather in {{ 
  
 location }}</h2>
  
   
  <div *ngIf=""error"">Failed to load data.</div>
  
   
  <ul>
  
    
  <li *ngFor=""#item of data"">
  
     
  <div class=""item-date"">{{ item.date }}</div>
  
     
  <div class=""item-main"">{{ item.main }}</div>
  
     
  <div class=""item-description"">{{ item.description }}</div>
  
     
  <div class=""item-temperature"">
  
     
  {{ item.temperature }} {{ temperatureUnit }}
  
     
  </div>
  
    
  </li>
  
   
  </ul>
  
   
  <div class=""clearfix""></div>
  
   
  `,",NA
Downloading the forecast,"To download data from the Internet in Angular, we need to get the HTTP service. We need 
 to set the 
 viewProviders
  section for that:
  
 import { Component, Input } from ""angular2/core""; 
  
 import { Http, Response, HTTP_PROVIDERS } from ""angular2/http""; import { getUrl, 
 ForecastResponse } from ""./api"";
  
 ...
  
 @Component({
  
  selector: ""weather-forecast"",
  
  viewProviders: [HTTP_PROVIDERS],
  
  template: `...`,
  
  styles: [...] 
  
 }) 
  
 export class Forecast {
  
  constructor(private http: Http) {
  
  } 
  
 ...",NA
Adding @Output,"The response of Open weather map contains the name of the city. We can use this to 
 simulate completion later on. We will create an event emitter. Other components can listen 
 to the event and update the location when the event is triggered. The whole code will look 
 like this with final changes highlighted:
  
 import { Component, Input, Output, EventEmitter } from ""angular2/core""; 
 import { Http, 
 Response, HTTP_PROVIDERS } from ""angular2/http""; 
  
 import { getUrl, ForecastResponse } from ""./api"";
  
 interface ForecastData {
  
  date: string;
  
  temperature: number;
  
  main: string;
  
  description: string; 
  
 }
  
 enum State {
  
  Loading,
  
  Refreshing,
  
  Loaded,
  
  Error 
  
 }
  
 @Component({
  
  selector: ""weather-forecast"",
  
  viewProviders: [HTTP_PROVIDERS],
  
  template: `
  
   
  <span *ngIf=""loading"" class=""state"">Loading...</span>
  
   
  <span *ngIf=""refreshing"" class=""state"">Refreshing...</span>
  
   
  <a *ngIf=""loaded || error"" href=""javascript:;""        (click)=""load()"" class=""state"">Refresh</a>
  
   
  <h2>{{ tomorrow ? 'Tomorrow' : 'Today' }}'s weather in {{ 
  
 location }}</h2>
  
   
  <div *ngIf=""error"">Failed to load data.</div>
  
   
  <ul>
  
    
  <li *ngFor=""#item of data"">
  
     
  <div class=""item-date"">{{ item.date }}</div>
  
     
  <div class=""item-main"">{{ item.main }}</div>
  
     
  <div class=""item-description"">{{ item.description }}</div>
  
     
  <div class=""item-temperature"">
  
     
  {{ item.temperature }} {{ temperatureUnit }}
  
     
  </div>
  
    
  </li>",NA
The main component,"As you can see in the screenshot in the introduction of this chapter, this component should 
 have a textbox, a button, and three tabs. Under the tabs, these component will show the 
 forecast or the A
 bout page
 .",NA
Using our other components,"We can use our components that we have already written by adding them to the 
 directives
  section and using their tag names in the template.",NA
Two-way bindings,"To get the value of the input box, we need two-way bindings. We can use the 
 ngModel 
 directive for that. The syntax combines the syntaxes of the two one-way bindings: 
 [(ngModel)]=""property""
 . The directive is again a built-in one, so we don't have to import 
 it.
  
 Using this two-way binding, we can automatically update the weather widget after every 
 key press. That would cause a lot of requests to the server, and especially on slow 
 connections, that's not desired.
  
 To prevent these issues, we will add two separate properties. The property location will 
 contain the content of the input and 
 activeLocation
  will contain the location, which is 
 being shown.",NA
Listening to our event,"We can listen to our event, just like we did with other events. We can access the event 
 content with 
 $event
 . Such a listener will look like 
 (correct-
  
 location)=""correctLocation($event)
 . When the server responds with the forecast, it also 
 provides the name of the location. If the user had a small typo in the name, the response will 
 correct that. This event will be fired in such a case and the name will be corrected in the 
 input box.",NA
Geolocation API,"Because our forecast widget supports coordinates, we can use the geolocation API to set the 
 initial location. That API can give the coordinates where the device is located (roughly). 
 Later on, we will use this API to set the widget to the current location when the page loads 
 as shown here:
  
 navigator.geolocation.getCurrentPosition(position => {
  
  const location = `Coordinate ${ position.coords.latitude }      ${ position.coords.longitude }`;
  
  this.location = location;
  
  this.activeLocation = location; 
  
 });
  
 Template string 
  
 Template strings, not to be confused with Angular templates, are strings 
 wrapped in backticks (
 `
 ). These strings can be multiline and can contain 
 expressions between 
 ${
  and 
 }
 .",NA
Component sources,"As usual, we start by importing Angular. We also have to import the two components we 
 have already written. We use an enumeration again to store the state of the component:
  
 import { Component } from ""angular2/core""; import { 
 Forecast } from ""./forecast""; import { About } from 
 ""./about"";
  
 enum State {
  
  Today,
  
  Tomorrow,
  
  About 
  
 }",NA
Summary,"In this chapter, we created an application with Angular 2. We explored Angular 2 and used 
 its directives and bindings in our components. We also used an online API. You should now 
 be able to build small Angular applications. In the next chapter, we will build a more 
 complex application in Angular, which will also use its own server.
  
 [ 44 ]",NA
Note-Taking App with a Server ,NA,NA
,"In this chapter, we will create a client-server app. The client will be written using 
 Angular 
 2 
 and the server will be written using 
 NodeJS
  and MongoDB. We can use TypeScript on 
 both sides and we will see how we can reuse code between them.
  
 The application can be used to take notes. We will implement a login page and basic 
 ,
 Create, Read
 ,
  Update
 ,
  and Delete
  (
 CRUD
 ) operations for the notes.
  
  
 In this chapter, we will cover the following topics:
  
 Setting up the project structure
  
 Getting started with NodeJS
  
 Understanding the structural type system
  
 Adding authentication
  
 Testing the API
  
 Adding CRUD operations",NA
Setting up the project structure,"First, we have to setup the project. The difference with the previous chapter is that we now 
 have to build two applications
 —
 the client side and the server side. This causes some 
 differences with the previous setup.",NA
Directories,"We will again place our TypeScript sources in the 
 lib
  directory. In that directory, we will 
 create four subdirectories: 
 client
 , 
 server
 , 
 shared
 , and 
 typings
 . The 
 lib/client 
 directory will 
 contain the client-side application and the 
 lib/server
  directory will contain the server code. 
 Codes that can be used by both the server and the client will go in 
  
 lib/shared
 . Last but not least, 
 lib/typings
  will contain type definitions for some dependencies, 
 including NodeJS.",NA
Configuring the build tool,"In 
 lib
 , we create a 
 tsconfig.json
  file that will contain some configuration for 
  
 TypeScript. We want to compile the server-side code to 
 es2015
 , so we can use some new 
 features of TypeScript and JavaScript. The client side, however, must be compiled to 
 es5
  for 
 browser support. In the 
 tsconfig
  file, we will specify 
 es2015
  as target and override it in the 
 gulp
  file. We can also specify the version of the default library that we want to use. We need 
 es2015 and dom. The first contains the recent classes and functions from JavaScript, such as 
 Map
  and 
 Object.assign
 :
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es6"",
  
   
  ""module"": ""commonjs"",
  
   
  ""experimentalDecorators"": true,
  
   
  ""emitDecoratorMetadata"": true,
  
   
  ""lib"": [""es2015"", ""dom""]
  
  } 
  
 }",NA
Type definitions,"Before a library can be used in TypeScript, you have to have type definitions for it. These are 
 stored in 
 .d.ts
  files. For some packages, these are automatically installed. For example, we 
 used Angular in the previous chapter and we didn't install the definitions manually.
  
 Packages distributed on 
 npm
  can include their type definitions in the same package. When 
 you download such a package, the 
 typings
  come along. Unfortunately, not all packages do 
 this. As of TypeScript 2.0, it is possible to download 
 typings
  for these packages on 
 npm
  too.
  
 For instance, the 
 typings
  for 
 mongodb
  are published in the 
 @types/mongodb
  package. You 
 can install types for a lot of packages this way. Types for NodeJS itself are available in 
 @types/node
 . Run these commands in the 
 root
  directory:
  
 npm install @types/node --save 
  
 npm install @types/mongodb --save",NA
Getting started with NodeJS,"In the previous chapter, we used NodeJS, as gulp uses it. Node can be used for a server and 
 for a command line tool. In this chapter, we will build a server and in 
 Chapter 9
 , 
 Playing Tic-
 Tac-Toe against an AI
 , we will create a command line application. If you haven't installed 
 Node yet, you can download it from nodejs.org.
  
 We will first create a simple server. We will use 
 Phaethon
 , a package for Node that makes it 
 easy to build a server in NodeJS. Phaethon includes type definitions, so we can use it 
 immediately. We create a file 
 lib/server/index.ts
  and add the following:
  
 import { Server } from ""phaethon""; 
  
 const server = new Server(); 
  
 server.listener = request => new phaethon.ServerResponse(""Hello""); server.listenHttp(8800);
  
 We can run this server using the following command:
  
 gulp && node dist/server
  
 When you open 
 localhost:8800
  in a web browser, the listener callback will be called and you 
 will see 
 Hello
  in the browser.",NA
Asynchronous code,"A server doesn't do all the work itself. It will also delegate some tasks. For instance, it might 
 need to download a webpage or fetch something from a database. Such a task will not give a 
 result immediately. In the meantime, the server could do something else. This style of 
 programming is called asynchronous or nonblocking, as the order of execution is not fixed 
 and such task does not block the rest of the application.
  
 Imagine we have a task that will download a webpage. The synchronous variant would 
 look like the following:
  
 function download() {
  
  return ...; 
  
 }
  
 function demo() { 
  
 // Before download 
  
 try { 
  
 const result = download(); 
  
 const result2 = download(); 
  
 // Download completed 
  
 } catch (error) {
  
  // Error 
  
 } 
  
 }",NA
Callback approach for asynchronous code,"In a webserver, this would prevent the server from handling other requests. The task blocks 
 the whole server. That is, of course, not what we want. The simplest asynchronous 
  
 approach uses callbacks. The first argument of the callback will contain an error if 
  
 something went wrong and the second argument will contain the result if there is a result:
  
 function download(callback: (error: any, result: string) => void) { ...
  
 }
  
 function demo() { 
  
 // Before download 
  
 download((error, result) => { 
  
 if (error) {
  
   
  // Error
  
  } else {
  
   
  // Download completed
  
   
  download((error2, result2) => {",NA
Disadvantages of callbacks,"The disadvantage of this is that when you have a lot of callbacks, you have to nest callbacks 
 in callbacks, which is called callback hell. In ES6, a new class was introduced, that acts like 
 an abstraction of such a task. It is called a promise. Such a value promises that there will be 
 a result now or later on. The promise can be resolved, which means that the result is ready.
  
 The promise can also be rejected, which means that there was some error:
  
 function download(): Promise<string> {
  
  ...
  
 }
  
 function demo() { 
  
 // Before download 
  
 download().then(result => {
  
  // Download completed
  
  return download(); 
  
 }).then(result2 => {
  
  // Second download completed 
  
 }); 
  
 }
  
 As you can see, the preceding code is more readable than the callbacks code. It's also easier 
 to chain tasks since you can return another promise in the 
 then
  section of a promise. 
 However, the synchronous code is still more readable. ES7 has introduced 
 async
  functions. 
 These functions are syntactic sugar around promises. Instead of calling 
 then
  on a promise, 
 you can 
 await
  it and write code as if it were synchronous.
  
 At the time of writing, 
 async
  functions can only be compiled to ES6. 
 TypeScript 2.1 will introduce support for ES5 too.",NA
The database,"A lot of programmers use MongoDB in combination with NodeJS. You can install 
 MongoDB from 
 www.mongodb.org
 . MongoDB can be started using the following command 
 in the project root:
  
 mongod --dbpath ./data
  
 You can keep the preceding command running in one terminal window and run NodeJS in 
 another terminal window later on.",NA
Wrapping functions in promises,"We will run the database on the same computer as the server and we will name the 
 database 
 notes
 . This yields the URL 
 mongodb://localhost/notes
 , which we need to connect 
 to the database. We have already installed the definitions with 
 tsd
 . MongoDB exposes an 
 API based on callbacks. We will wrap these in promises, as we will use async/await later 
 on. Wrapping a function in a promise will look like the following:
  
 function wrapped() {
  
  return new Promise<string>((resolve, reject) => {
   
  
 originalFunction((error, result) => {
  
    
  if (error) {",NA
Connecting to the database,"We add the following in 
 lib/server/database.ts
 . First we must connect to the database. 
 Instead of rejecting when the connection failed, we will throw the error. This way the server 
 will quit if it can't connect to the database:
  
 import { MongoClient, Db, Collection } from ""mongodb"";
  
 const databaseUrl = ""mongodb://localhost:27017/notes""; const database = 
 new Promise<Db>(resolve => {
  
  MongoClient.connect(databaseUrl, (error, db) => {
   
  if (error) {
  
    
  throw error;
  
   
  }
  
   
  resolve(db);
  
  }) 
  
 });
  
 Usually, you would reject the promise in case of an error. Here, we throw 
 the error and crash the server. In this case it is better since the server 
 cannot do anything without a database connection.
  
 The database contains two collections (tables): 
 users
  and 
 notes
 . Since we can only access 
 these after the connection to the database has succeeded, these should also be placed in a 
 Promise
 . Since 
 database
  already is a 
 Promise
 , we can use 
 async
 /
 await
 :
  
 async function getCollection(name: string) { const db = await 
 database;
  
  return db.collection(name); 
  
 } 
  
 export const users = getCollection(""users""); export const 
 notes = getCollection(""notes"");",NA
Querying the database,"To query the database, we will use the function 
 find
 . MongoDB returns a cursor object, 
 which allows you to stream all results. If you have a big application, and queries that return 
 a lot of results, this can improve the performance of your application. Instead of streaming 
 the results, we can also buffer them in an array with the 
 toArray
  function:
  
 export function find(table: Promise<Collection>, query: any) { const collection = await 
 table;
  
  return new Promise<U[]>((resolve, reject) => {
  
   
  collection.find(query, (error, cursor) => {
  
    
  if (error) {
  
     
  reject(error);
  
    
  } else {
  
     
  cursor.toArray((error, results) => {
  
     
  if (error) {
  
      
  reject(error);
  
      
  } else {
  
        
  resolve(results);
  
      
  }
  
     
  });
  
    
  }
  
   
  });
  
  }); 
  
 }",NA
Understanding the structural type system,"TypeScript uses a structural type system. What that means can be easily demonstrated 
 using the following example:
  
 class Person {
  
  name: string; 
  
 } 
  
 class City {
  
  name: string; 
  
 } 
  
 const x: City = new Person();
  
 In languages like C#, this would not compile. These languages use a nominal type system. 
 Based on the name, a 
 Person
  is not a 
 City
 . TypeScript uses a structural type system. Based on 
 the structure of 
 Person
  and 
 City
 , these types are equal, as they both have a 
 name 
 property. 
 This fits well in the dynamic nature of JavaScript. It can, however, lead to some unexpected 
 behavior, as the following would compile:
  
 class Foo { 
  
 } 
  
 const f: Foo = 42;
  
 Since 
 Foo
  does not have any properties, every value would be assignable to it. In cases were 
 the structural behavior is not desired, you can add a 
 brand
 , a property that adds type safety 
 but does not exist at runtime:
  
 class Foo {
  
  __fooBrand: void; 
  
 } 
  
 const f: Foo = 42;
  
 Now the last line will give an error, as expected.",NA
Generics,"The typings for MongoDB don't use generics or type arguments. Given that we already 
 have to add a tiny wrapper around it, we can also easily add generics to that wrapper. We 
 will create a new type for the data store that has generics:
  
 export interface Table<T> extends Collection { __tableBrand: T; 
  
 }",NA
Typing the API,"In 
 lib/shared/api.ts
 , we will add some typings for the API. On the server side, we can check 
 that the response has the right type:
  
 export interface LoginResult {
  
  ok: boolean;
  
  message?: string; 
  
 } 
  
 export interface MenuResult {
  
  items: MenuItem[]; 
  
 } 
  
 export interface MenuItem {
  
  id: string;
  
  title: string; 
  
 } 
  
 export interface ItemResult {
  
  id: string;
  
  content: string; 
  
 }
  
 We will now implement the functions that return these types.",NA
Adding authentication,"In 
 lib/server/index.ts
 , we will first add sessions. A session is a place to store data, which is 
 persistent for a client on the server. On the client side, a cookie will be saved, which 
 contains an identifier of the session. If a request contains a valid cookie with such an 
 identifier, you will get the same session object. Otherwise, a new session will be created:
  
 import { Server, ServerRequest, ServerResponse, ServerError, StatusCode, SessionStore } from 
 ""phaethon""; 
  
 import { ObjectID } from ""mongodb""; 
  
 import { User, login, logout } from ""./user""; 
  
 import * as note from ""./note"";
  
 With 
 import { ... }
 , we can import a set of entities from another file.
  
 With 
 import * as ...
 , we import the whole file as an object. The following 
 two snippets are equivalent: 
  
 import * as foo from ""./foo""; foo.bar(); import { bar } from ""./foo""; bar();",NA
Implementing users in the database,"Now we can implement authentication in 
 user.ts
 . For safety, we won't store plain passwords 
 in our database. Instead we 
 hash
  them. A hash is a manipulation of an input, in a way that 
 you cannot find the input based on the hash. When someone wants to log in, the password 
 is hashed and compared with the hashed password from the database. Using the built-in 
 module crypto, this can easily be done:
  
 import * as crypto from ""crypto""; 
  
 function getPasswordHash(username: string, password: string):    string { return 
 crypto.createHash(""sha256"").update(password.length + ""-""    + username + ""-"" + 
 password).digest(""hex""); 
  
 }
  
 The 
 logout
  handler is easy to write. We must remove the 
 userId
  of the session as follows:
  
 export function logout(request: ServerRequest, session: Session): LoginResult {
  
  session.userId = undefined;
  
  return { ok: true }; 
  
 }
  
 As you can see, we are using the 
 LoginResult
  interface that we wrote previously. The login 
 function will use the 
 async
 /
 await
  syntax. The function expects that the username and 
 password are available in the URL query. If they are not available, 
 validate.expect 
 will 
 throw an error, which will be displayed as a 
 Bad Request
  error:
  
 export async function login(request: ServerRequest, session:    Session): Promise<LoginResult> {
  
  const username = validate.expect(request.query[""username""], 
  
 validate.isString);
  
  const password = validate.expect(request.query[""password""], 
  
 validate.isString);
  
  constpasswordHash = getPasswordHash(username, password);
  
  const results = await find(users, { username, passwordHash }); if (results.length === 0) {
  
   
  return { ok: false, message: ""Username or password incorrect"" }; }
  
  const user = results[0];
  
  session.userId = user._id;
  
  return { ok: true }; 
  
 }
  
 [ 60 ]",NA
Adding users to the database,"To add some users to the database, we must add some code and run the server once with it. 
 In a real-world application, you would probably want to add a register form. That is 
 comparable to adding a note, which we will do later on in this chapter.
  
 We will also add two helper functions that we can use in 
 note.ts
  to check whether the 
 user is logged in:
  
 import * as crypto from ""crypto""; 
  
 import { ServerRequest, ServerResponse, ServerError, StatusCode, validate } from ""phaethon""; 
  
 import { Session } from ""./index""; 
  
 import { LoginResult } from ""../shared/api""; 
  
 import { users, find, insert } from ""./database"";
  
 export interface User {
  
  _id: string;
  
  username: string;
  
  passwordHash: string; 
  
 }
  
 function getPasswordHash(username: string, password: string): string { return 
 crypto.createHash(""sha256"").update(password.length + ""-""      + username + ""-"" + 
 password).digest(""hex""); 
  
 }
  
 insert(users, {
  
  _id: undefined,
  
  username: ""lorem"",
  
  passwordHash: getPasswordHash(""lorem"", ""ipsum"") }); 
  
 insert(users, {
  
  _id: undefined,
  
  username: ""foo"",
  
  passwordHash: getPasswordHash(""foo"", ""bar"") });
  
 export async function login(request: ServerRequest, session: Session): Promise<LoginResult> {
  
  const username = validate.expect(
  
   
  request.query[""username""], validate.isString);
  
  const password = validate.expect(
  
   
  request.query[""password""], validate.isString);
  
  const passwordHash = getPasswordHash(username, password);
  
  const results = await find(users, { username, passwordHash });
  
 [ 61 ]",NA
Testing the API,"We can start the server by running the following command:
  
 gulp && node --harmony_destructuring dist/server
  
 In a web browser, you can open 
  
 localhost:8800/api/login?username=lorem&password=ipsum
  to test the code. You can change 
 the parameters to test how a wrong username or password behaves.
  
 For debugging, you can add 
 console.log(""..."");
  calls in your code.",NA
Adding CRUD operations,"Most servers handle CRUD operations primarily. Our server must handle five different 
 requests: 
 list
  all notes of the current user, 
 find
  a specific note, 
 insert
  a new note, 
 update
  a 
 note, and 
 remove
  a note.
  
 First, we add a helper function that can be used on the server side and the client side. In 
 lib/shared/note.ts
 , we add a function that returns the title of a note
 —
 the first line, if 
 available, or 
 “
 Untitled
 ”
 :
  
 export function getTitle(content: string) { const lineEnd = 
 content.indexOf(""\n""); if (content === """" || lineEnd === 0) {
  
  
  return ""Untitled"";
  
  }
  
  if (lineEnd === -1) {
  
   
  // Note contains one line
  
   
  return content;
  
  }
  
  // Get first line
  
  return content.substring(0, lineEnd); }
  
 We write the CRUD functions in 
 lib/server/note.ts
 . We start with imports and the 
 Note
  
 definition:
  
 import { ServerRequest, ServerResponse, ServerError, StatusCode, validate } from ""phaethon""; 
  
 import { ObjectID } from ""mongodb""; 
  
 import { Session } from ""./index""; 
  
 import { getUserOrError } from ""./user""; 
  
 import { Note } from ""./note""; 
  
 import { getTitle } from ""../shared/note""; 
  
 import { MenuResult, ItemResult } from ""../shared/api""; 
  
 import * as database from ""./database"";
  
 export interface Note {
  
  _id: string;
  
  userId: string;
  
  content: string; 
  
 }",NA
Implementing the handlers,"Now we can implement the 
 list
  function. Using the helper functions we wrote previously, 
 we can easily write the following function:
  
 export async function list(request: ServerRequest, session: Session): Promise<MenuResult> {
  
  const user = await getUserOrError(session);
  
  const results = await database.find(
  
   
  database.notes, { userId: user._id });
  
  const items = results.map(note => ({
  
   
  id: note._id.toHexString(),
  
   
  title: getTitle(note.content)
  
  }));
  
  return { items }; 
  
 }
  
 With 
 toHexString
 , an 
 ObjectID
  can be converted to a string. It can be converted back using 
 new ObjectID(...)
 . The map function transforms an array with a specific callback.
  
 In the 
 find
  function, we must search for a note based on a specific ID:
  
 export async function find(request: ServerRequest, session: Session): Promise<ItemResult> {
  
  const user = await getUserOrError(session);
  
  const id = validate.expect(
  
   
  request.query[""id""], validate.isString);
  
  const notes = await database.find(database.notes,
  
   
  { _id: new ObjectID(id), userId: user._id });
  
  if (notes.length === 0) {
  
   
  throw new ServerError(StatusCode.ClientErrorNotFound);
  
  }
  
  const note = notes[0];
  
  return {
  
   
  id: note._id.toHexString(),
  
   
  content: note.content
  
  }; 
  
 }
  
 Do not forget to add the 
 userId
  in the query. Otherwise, a hacker could 
 find notes of a different user without knowing his/her password.",NA
Request handling,"In 
 lib/server/index.ts
 , we must add references to these functions in 
 handleRequest
 :
  
 async function handleRequest(request: ServerRequest, session: Session): Promise<ServerResponse | 
 Object> {
  
  const path = request.path.toLowerCase();
  
  if (path === ""/api/login"") 
  
 return login(request, session);
  
  if (path === ""/api/logout"") 
  
 return logout(request, session);
  
  if (path === ""/api/note/list"") 
  
 return note.list(request, session);
  
  if (path === ""/api/note/insert"") 
  
 return note.insert(request, session);
  
  if (path === ""/api/note/update"") 
  
 return note.update(request, session);
  
  if (path === ""/api/note/remove"") 
  
 return note.remove(request, session);
  
  if (path === ""/api/note/find"") 
  
 return note.find(request, session);
  
  throw new ServerError(StatusCode.ClientErrorNotFound); }",NA
Writing the client side,"Just like the weather widget, we will write the client side of the note application with 
 Angular 2. When the application starts, it will try to download the list of notes. If the user is 
 not logged in, we will get an 
 Unauthorized
  error (status code 
 401
 ) and show the login form. 
 Otherwise, we can show the menu with all notes, a logout button, and a button to create a 
 new note. When clicking on a note, that note is downloaded and the user can edit it in the 
 note editor. If the user clicks on the 
 new
  button, the user can write the new note in the 
 (same) note editor.
  
 The server uses a cookie to manage the session, so we do not have to do that manually on 
 the client side.
  
 We start with almost the same HTML file saved as 
 static/index.html
 :
  
 <!DOCTYPE HTML> 
  
 <html>
  
  <head>
  
   
  <title>My Notes</title>",NA
Creating the login form,"Now we can create the login form, as shown in the following screenshot:",NA
Creating a menu,"In 
 lib/client/menu.ts
 , we create the menu. In the menu, the user will see his/her notes and 
 can create a new note. The menu will look like the following:
  
  
 This component can emit two different events: create and open. The second has an 
 argument, so we have to add 
 string
  as type argument:
  
 import { Component, Input, Output, EventEmitter } from ""angular2/core""; import { MenuItem } from 
 ""../shared/api"";
  
 @Component({
  
  selector: ""notes-menu"",
  
  template: `
  
   
  <button type=""button"" (click)=""clickCreate()"">New</button>
  
  
  <ul>
  
    
  <li *ngFor=""#item of items"">
  
     
  <a href=""javascript:;"" (click)=""clickItem(item)"">{{ item.title }}</a>
  
    
  </li>
  
   
  </ul>
  
   
  ` 
  
 }) 
  
 export class Menu {
  
  @Input()
  
  items: MenuItem[];
  
  @Output()
  
  create = new EventEmitter();",NA
The note editor,"The note editor is a simple text area. Above it, we will show the title of the note. With two-
 way bindings, the title is automatically updated when the content of the text area is 
 changed.",NA
The main component,"Now we can write the main component. This component will show one of the other 
 components, depending on the state. First we must import 
 rxjs
 , Angular, and the 
 functions and components we have already written:
  
 import ""rxjs""; 
  
 import { Component } from ""angular2/core""; 
  
 import { bootstrap } from ""angular2/platform/browser""; 
  
 import { Http, HTTP_PROVIDERS, Response } from ""angular2/http""; import { getUrl } from 
 ""./api""; 
  
 import { MenuItem, MenuResult, ItemResult } from ""../shared/api""; import { LoginForm } 
 from ""./login""; 
  
 import { Menu } from ""./menu""; 
  
 import { NoteEditor } from ""./note"";",NA
Error handler,"Now we will write a function that will load the menu. Errors will be passed to 
  
 handleError
 . If the user was not authenticated, we will find the status code 
 401
  here and 
 show the login form. For a successful request, we can cast the response to the interfaces we 
 defined in 
 lib/shared/api.ts
 :
  
 handleError(error: Response) {
  
  if (error.status === 401) {
  
   
  // Unauthorized
  
   
  this.state = State.Login;
  
   
  this.menu = [];
  
   
  this.note = undefined;
  
  } else {
  
   
  this.state = State.Error;
  
  } 
  
 } 
  
 loadMenu() {
  
   
  this.state = State.Menu;
  
   
  this.menu = [];
  
   
  this.http.get(getUrl(""note/list"", {})).subscribe(response => {
  
  
  
  
 const body = <MenuResult>response.json();
  
    
  this.menu = body.items;
  
   
  }, error => this.handleError(error));
  
  }
  
 We implement the event listeners, 
 createNote
  and 
 loadNote
 , of the menu:
  
 createNote() {
  
   
  this.note = {
  
    
  id: undefined,
  
    
  content: """"
  
   
  };",NA
Running the application,"To test the application, the server and the static files have to be served from the same server. 
 To do that, you can use the 
 http-server
  package. That server can serve the static files and 
 pass through (proxy) the requests to the API server. If MongoDB is not running yet, open a 
 terminal window and run 
 mongod --dbpath ./data
 . Open a terminal window in the root of the 
 project and run the following to start the API server on 
 localhost:8800
 :
  
 gulp && node --harmony_destructuring dist/server
  
 In a new terminal window, navigate to the 
 static
  directory. Install 
 http-server
  using the 
 following command:
  
 npm install http-server -g
  
 Now you can start the server:
  
 http-server -P http://localhost:8800
  
 Open 
 localhost:8080
  in a browser and you will see the application that we have created.",NA
Summary,"In this chapter, you created a client-server application. You used NodeJS to create a server, 
 with MongoDB and Phaethon. You also learned more about asynchronous programming 
 and the structural type system. We used our knowledge of Angular from the first chapter to 
 create the client side.
  
 In the next chapter, we will create another client-server application. That application is not a 
 CRUD application, but a real-time chat application. We will be using React instead of 
 Angular.",NA
Real-Time Chat ,NA,NA
,"After having written two applications with Angular 2, we will now create one with 
 React
 . 
 The server part will also be different. Instead of a connectionless server, we will now create 
 a server with a persistent connection. In the previous chapters, the client sent requests to the 
 server and the server responded to them. Now we will write a server that can send 
  
 information at any time to the client. This is needed to send new chat messages immediately 
 to the client, as shown in the following:",NA
Setting up the project,"Before we can start coding, we have to set up the project. The directory structure will be the 
 same as in 
 Chapter 3
 , 
 Note-Taking App with Server
 ; 
 static
  contains the static files for the 
 webserver, 
 lib/client
  contains the client-side code, 
 lib/server
  contains the code for the server, 
 lib/shared
  contains the code that can be used on both sides, and 
 lib/typings 
 contains the type 
 definitions for React.
  
 We can install all dependencies, for 
 gulp
 , the server, and React, as follows:
  
 npm init 
  
 npm install react react-dom ws --save 
  
 npm install gulp gulp-sourcemaps gulp-typescript gulp-uglify small --save-dev
  
 The type definitions can be installed using 
 npm
 :
  
 cd lib 
  
 npm install @types/node @types/react @types/react-dom @types/ws --save
  
 We create 
 static/index.html
 , which will load the compiled JavaScript file:
  
 <!DOCTYPE HTML> 
  
 <html>
  
  <head>
  
   
  <title>Chat</title>
  
   
  <link href=""style.css"" rel=""stylesheet"" /> </head>
  
  <body>
  
   
  <div id=""app""></div>
  
   
  <script type=""text/javascript"">
  
    
  var process = {",NA
Configuring gulp,"We can use almost the same 
 gulpfile
 . We do not have to load any polyfills for React, so 
 the resulting file is even simpler:
  
 var gulp = require(""gulp""); 
  
 var sourcemaps = require(""gulp-sourcemaps""); var typescript 
 = require(""gulp-typescript""); var small = 
 require(""small"").gulp; 
  
 var uglify = require(""gulp-uglify"");
  
 var tsServer = typescript.createProject(""lib/tsconfig.json"", { typescript: 
 require(""typescript"") });
  
 var tsClient = typescript.createProject(""lib/tsconfig.json"", { typescript: require(""typescript""), target: ""es5"" 
 });
  
 gulp.task(""compile-client"", function() {
  
  
  return gulp.src([""lib/client/**/*.ts"", ""lib/client/**/*.tsx"",
  
  ""lib/shared/**/*.ts""], 
 { base: ""lib"" })
  
  
  
  .pipe(sourcemaps.init())
  
  
  
  .pipe(typescript(tsClient))
  
  
  
  .pipe(small(""client/index.js"", { outputFileName: {
  
  
  
  
  standalone: ""scripts.js"" }, externalResolve:
  
  
  
  
  [""node_modules""] }))
  
  
  
  .pipe(sourcemaps.write("".""))
  
  
  
  .pipe(gulp.dest(""static/scripts"")); 
  
 });",NA
Getting started with React,"Just like Angular, React is component based. Angular is called a framework, whereas React 
 is called a library. This means that Angular provides a lot of different functionalities and 
 React provides one functionality, 
 views
 . In the first two chapters, we used the HTTP service 
 of Angular. React does not provide such a service, but you can use other libraries from 
 npm 
 instead.",NA
Creating a component with JSX,"A component is a class that has a render method. That method will render the view and is 
 the replacement of the template in Angular. A simple component would look like the 
 following:",NA
Adding props and state to a component,"In the example, the component extends the 
 React.Component
  class. That class has two type 
 arguments, which represent the props and the state. The props contain the input that the 
 parent component gives to this one. You can compare that to the 
 @Input
  directive in 
 Angular. You cannot modify the props in the containing class. The state contains the other 
 properties of a component in Angular, which can be modified in the class. You can access 
 the props with 
 this.props
  and the state with 
 this.state
 . The state cannot be modified directly, 
 as you have to replace the state with a new object. Imagine the state contains two properties, 
 foo
  and 
 bar
 . If you want to modify 
 foo
  and 
 bar
 , it is not allowed with 
 this.state.foo = 42
 , but 
 you have to write 
 this.setState({ foo: 42, bar: true })
  instead. In most cases, you do not have to 
 change all properties of the state. In such cases, you only have to specify the properties that 
 you want to change. For instance, 
 this.setState({ foo: 42, bar: true })
  will change the value of 
 foo
  and keep the old value of 
 bar
 . The state object is then replaced by a new object. The state 
 object will never change. Such an object is called an immutable object. We will read more on 
 these objects in 
 Chapter 5
 , 
 Native QR Scanner App
 .
  
 The component will be re-rendered by React after calling 
 setState
 .",NA
Creating the menu,"We will start with the menu of our application. In the menu, the user can choose the chat 
 room that he/she wants to join. The menu will first ask the user for a username. Afterward, 
 the user can type the name of a chat room. The user will get completions for known rooms, 
 but he/she can also create a new room. Let's check the following screenshot as an example 
 of menu:
  
  
 The component will delegate the completions to its parent, so we need to add the current 
 list of completions to the props, such that the parent can set it. Also, we need to add a 
 callback that can be called when the completions must be fetched.
  
 The state must contain the username and the room name. React does not have two-way 
 bindings, so we have to use event listeners to update the username and room name in the 
 state.",NA
Testing the application,"To view the application in a browser, you must first build it using 
 gulp
 . You can execute 
 gulp
  in a terminal. Afterward, you can open 
 static/index.html
  in a browser.",NA
Writing the server,"To add interaction to the application, we must create the server first. We will use the 
 ws 
 package to easily create a websocket server. On the websocket, we can send messages in 
 both directions. These messages are objects converted to strings with JSON, just like in the 
 previous chapters.",NA
Connections,"In the previous chapter, we wrote a connectionless server. For every request, a new 
 connection was set up. We could store a state using a session. Such session was identified 
 with a cookie. If you were to copy that cookie to a different computer, you would have the 
 same session there.
  
 Now we will write a server that uses connections. In this way, the server can easily keep 
 track of which user is logged in and where. The server can also send a message to the client 
 without a direct request. This automatic updating is called pushing. The opposite, pulling, 
 or polling, means that the client constantly asks the server whether there is new data.
  
 With connections, the order of arrival is the same as the order of sending. With a 
 connectionless server, a second message can use a different route and arrive earlier.",NA
Typing the API,"We will type these messages in 
 lib/shared/api.ts
 . In the previous chapter, the URL 
 identified the function to be called. Now, we must include that information in the message 
 object. We type the messages from the client to the server and vice versa:
  
 export enum MessageKind {
  
  FindRooms,
  
  OpenRoom,
  
  SendMessage,",NA
Accepting connections,"In 
 lib/server/index.ts
 , we create a server that listens for new connections. We also keep 
 track of all open connections. When a message is sent in a chat room, it can be 
 forwarded to all sessions that have opened that room. We use 
 ws
  to create a websocket 
 server:
  
 import * as WebSocket from ""ws""; 
  
 import * as api from ""../shared/api"";
  
 const server = new WebSocket.Server({ port: 8800 });",NA
Storing recent messages,"You can implement this with an array by removing the first message and appending the 
 new message at the end. However, this would shift the whole array, especially large arrays 
 that can take some time. Instead, we use a different approach. We use an array that can be 
 seen as a circle: after the last element comes the first one. We use a variable that points to the 
 oldest message. When a new message is added, the item at the position of the pointer is 
 overwritten with the new message. The pointer is incremented with one and points again to 
 the oldest message. When the messages 
 A
 , 
 B
 , 
 C 
 and 
 D
  are sent with an array size of 
 3
 , this 
 can be visualized like the following:
  
 [-, 
 -, 
 -]; 
 pointer 
 = 
 0 
  
 [A, 
 -, 
 -]; 
 pointer 
 = 
 1 
  
 [A, 
 B, 
 -]; 
 pointer 
 = 
 2 
  
 [A, 
 B, 
 C]; 
 pointer 
 = 
 0 
  
 [D, B, C]; pointer = 1
  
 If you are familiar with analyzing algorithms and 
 Big-Oh
  notation, this takes 
 O(1)
 , 
 whereas the naive idea takes 
 O(n)
 . We create the array in 
 lib/server/index.ts
 :
  
 const recentMessages: api.ChatContent[] = new Array(2048); let 
 recentMessagesPointer = 0;
  
 We do not save the messages to disk. You could do that and use a cache with such array to 
 increase the performance of the server.",NA
Handling a session,"For each connection, we have to keep track of the username and room name of the user. We 
 can do that with variables inside the 
 receiveConnection
  function:
  
 function receiveConnection(ws: WebSocket) { let username: 
 string;
  
  let room: string;
  
 We can listen to the 
 message
  and 
 close
  events. The first is emitted when the client has sent a 
 message in the websocket. The second is emitted when the websocket has been closed. 
 When the socket is closed, we must not send any messages to it and we must remove it from 
 the 
 sessions
  array:
  
 ws.on(""message"", message);
  
  ws.on(""close"", close);
  
  const session: Session = { sendChatMessage }; 
 sessions.push(session);
  
  function message(data) {
  
  
  try {
  
   
  const object = <api.ClientMessage> JSON.parse(data);
   
  if (typeof 
 object.kind !== ""number"") return;
  
   
  switch (object.kind) {
  
    
  case api.MessageKind.FindRooms:
  
     
  findRooms(<api.FindRooms> object);
  
    
  case api.MessageKind.OpenRoom:
  
     
  openRoom(<api.OpenRoom> object);
  
      
  break;
  
      
  case api.MessageKind.SendMessage:
  
      
  chatMessage(<api.SendMessage> object);
  
       
  break;
  
   
  }
  
  
  } catch (e) {
  
   
  console.error(e);
  
  
  }
  
  }
  
  function close() {
  
  
  const index = sessions.indexOf(session);
  
  
  sessions.splice(index, 1);
  
  }
  
  function send(data: api.ServerMessage) {
  
  
  ws.send(JSON.stringify(data));
  
  }",NA
Implementing a chat message session,"Now we can implement the functions that are called when a message comes in. We start 
 with the function that sends a chat message to all active connections in that room and stores 
 it in the array with recent messages:
  
  function sendChatMessage(content: api.ChatContent) {
  
  if 
 (content.room === room) {
  
   
  send({
  
    
  kind: api.MessageKind.ReceiveMessage,
  
    
  content
  
   
  });
  
  
  }
  
  }
  
  function chatMessage(message: api.SendMessage) {
  
  if (typeof 
 message.content !== ""string"") return;
  
  const content: api.ChatContent = {
  
  room,
  
  username,
  
  content: message.content
  
  };
  
  recentMessages[recentMessagesPointer] = content; 
 recentMessagesPointer++;
  
  if (recentMessagesPointer >= recentMessages.length) { 
 recentMessagesPointer = 0;
  
  }
  
  
  for (const item of sessions) {
  
   
  if (session !== item) item.sendChatMessage(content);
  
  }
  
  }",NA
Connecting to the server,"We can connect to the server with the 
 WebSocket
  class:
  
 const socket = new WebSocket(""ws://localhost:8800/"");
  
 Since we're using React, we add the following to the state. We create a new component, 
 App
 , that will show the menu or a chat room based on the state. In 
  
 lib/client/index.tsx
 , we first define the state and props of that component:
  
 import * as React from ""react""; 
  
 import * as ReactDOM from ""react-dom""; 
  
 import * as api from ""../shared/api""; 
  
 import * as model from ""./model""; 
  
 import { Menu } from ""./menu""; 
  
 import { Room } from ""./room"";
  
 interface Props {
  
  apiUrl: string; 
  
 } 
  
 interface State {
  
  socket: WebSocket;
  
  username: string;
  
  connected: boolean;
  
  completions: string[];
  
  room: model.Room; 
  
 } 
  
 class App extends React.Component<Props, State> { state = {
  
   
  socket: undefined,
  
   
  username: '',
  
   
  connected: false,
  
   
  completions: [],
  
   
  room: undefined
  
  };",NA
Automatic reconnecting,"Next up, we will write a function, 
 connect
 , that connects to the server using a 
 WebSocket
 .
  
 We call that function in 
 componentDidMount
 , which is called by React. We must also call 
 connect
  when the connection gets closed for some reason (for instance, network problems).
  
 We store the socket in the state and we also keep track of whether the client is connected:
  
 connect() { 
  
 if (this.state.connected) return;",NA
Sending a message to the server,"Before writing the event handlers, we first write a small function that sends a message to 
 the server. It converts an object to JSON, and TypeScript will check that we are sending 
 a correct message to the server:
  
  private send(message: api.ClientMessage) {
  
  
  this.state.socket.send(JSON.stringify(message)); }
  
 The 
 requestCompletions
  and 
 openRoom
  functions send a message to the server. In 
 openRoom
 , we also have to store the username in the state:
  
 private requestCompletions(query: string) {
  
  
  
 this.send({
  
    
  kind: api.MessageKind.FindRooms,
  
    
  query
  
   
  });
  
  }
  
  private openRoom(username, room: string) {
  
  
  
 this.send({
  
    
  kind: api.MessageKind.OpenRoom,
  
    
  username,",NA
Writing the event handler,"For iterations in React, every element should have a key that can identify it. Thus, we need 
 to give every message such a key. We use a simple numeric key, which we will increment 
 for every message:
  
  private nextMessageId: number = 0;
  
  private post(content: string) {
  
   
  this.send({
  
    
  kind: api.MessageKind.SendMessage,
  
    
  content
  
   
  });
  
   
  this.addMessage({
  
    
  id: this.nextMessageId++,
  
    
  user: this.state.username,
  
    
  content,
  
    
  isAuthor: true
  
   
  });
  
  }
  
  private addMessage(msg: model.Message) {
  
   
  const messages = [
  
    
  ...this.state.room.messages,
  
    
  msg
  
   
  ].slice(Math.max(0, this.state.room.messages.length - 10));
  
  
  const 
 room = model.modify(this.state.room, {
  
    
  messages
  
   
  });
  
   
  this.setState({ room });
  
  }
  
  private mapMessage(msg: api.ChatContent) {
  
   
  return {
  
    
  id: this.nextMessageId++,
  
    
  user: msg.username,
  
    
  content: msg.content,
  
    
  isAuthor: msg.username === this.state.username
  
   
  };
  
  } 
  
 }",NA
Creating the chat room,"We divide the chat room into two subcomponents: a message and the input box. When the 
 user sends a new message, it is sent to the main component. Message of the user will be 
 shown on the right and other messages on the left, as shown in the following screenshot:",NA
Two-way bindings,"React does not have two-way bindings. Instead, we can store the value in the state and 
 modify it when the 
 onChange
  event is fired. For the input box, we will use 
 this
  technique. 
 The textbox should be emptied when the user has sent his/her message. With this binding, 
 we can easily do that by modifying the value in the state to an empty string:
  
 class InputBox extends React.Component<{ onSubmit(value: string): void; }, { value: string }> {
  
  state = {
  
   
  value: """"
  
 [ 94 ]",NA
Stateless functional components,"If a component doesn't need a state, then it does not need a class to store and manage that 
 state. Instead of writing a class with just a render function, you can write that function 
 without the class. These components are called stateless functional components. A message 
 is clearly stateless, as you cannot modify a message that has already been sent:
  
 function Message(props: { message: model.Message }) {
  
  return (
  
   
  <div>
  
    
  <div className={props.message.isAuthor ? ""message          message-own"" : ""message""}>
  
     
  { props.message.content }
  
     
  <div className=""message-user"">
  
     
  { props.message.user }
  
     
  </div>
  
    
  </div>
  
    
  <div style={{clear: ""both""}}></div>
  
   
  </div>
  
  ); 
  
 }",NA
Running the application,"We can now run the whole application. First, we must compile it with gulp. Second, we can 
 start the server by running 
 node dist/server
  in a terminal. Finally, we can open 
 static/index.html
  in a browser and start chatting. When you open this page multiple times, 
 you can simulate multiple users.",NA
Comparing React and Angular,"In the previous chapters, we used Angular and in this chapter we used React. Angular and 
 React are both focused on components, but there are differences, for instance, between the 
 templates in Angular and the views in React. In this section, you can read more about these 
 differences.",NA
Templates and JSX,"Angular uses a template for the view of a component. Such a template is a string that is 
 parsed at runtime. TypeScript cannot check these templates. If you misspell a property 
 name, you will not get a compile error.",NA
Libraries or frameworks,"Angular is a framework and React is a library. A library provides one functionality in the 
 case of React
 —
 the views of the application. A framework provides a lot of different 
 functionalities. For instance, Angular renders the views of the application, but also has, for 
 instance, dependency injection and an 
 Http
  service. If you want such features when you are 
 using React, you can use another library that gives that feature.
  
 React programmers often use a Flux based architecture. Flux is an application architecture 
 that is implemented in various libraries. In 
 Chapter 5
 , 
 Native QR Scanner App
 , we will take a 
 look at this architecture.",NA
Summary,"We have written an application with websockets. We have used React and JSX for the views 
 of our application. We have seen multiple ways to create components and learned how the 
 JSX transform works. In 
 Chapter 5
 , 
 Native QR Scanner App
 , we will use React again, but we 
 will first take a look at mobile apps with NativeScript in the next chapter.",NA
Native QR Scanner App ,NA,NA
,"We have already used TypeScript to build web apps and a server. TypeScript can also be 
 used to create mobile apps. In this chapter, we will build such an app. The app can scan QR 
 codes. The app shows a list of all previous scans. If a QR code contains a URL, the app can 
 open that URL in a web browser. Various frameworks exist for making mobile apps in 
 TypeScript. We will use 
 NativeScript
 , which provides a native user interface and runs on 
 Android and iOS, as shown in the following:",NA
Getting started with NativeScript,"Installing NativeScript requires several steps. For developing apps for Android, you have to
  
 install 
 Java Development Kit
  (
 JDK
 ) and the 
 Android SDK
 . Android apps can be built on
  
 Windows, Linux, and Mac. Apps for iOS can only be built on a Mac. You need to install
  
 XCode
  to build these apps.
  
 You can find more details on how to install the Android SDK at 
 https://docs.nativescri
  
 pt.org/start/quick-setup
 .
  
 After installing the Android SDK or XCode, you can install NativeScript using 
 npm
 :
  
 npm install nativescript -g
  
 You can see whether your system is configured correctly by running the following
  
 command:
  
 tns doctor",NA
Creating the project structure,"In the previous chapters, we wrote our TypeScript sources in the 
 lib
  directory. The 
 static 
 or 
 dist
  directory contained the compiled sources. However, in this chapter, we have to make a 
 different structure since NativeScript has some requirements on it. NativeScript requires 
 that the compiled sources are located in the 
 app
  directory and it uses the 
 lib 
 directory for 
 plugins, so we cannot use that directory for our TypeScript sources. Instead, we will use the 
 src
  directory.
  
 NativeScript can automatically create a basic project structure. By running the following 
 commands, a minimal project will be created:
  
 tns init 
  
 npm install
  
 The first command creates the 
 package.json
  file and the 
 app
  directory. NativeScript stores the 
 icons and splash screens (which you see when the app is loading) in 
 app
 . You can edit these 
 files when you want to publish an app. The 
 npm install
  command installs the dependencies 
 that NativeScript needs. These dependencies were added to 
 package.json 
 by the first 
 command.
  
 We need to make some adjustments to it. We must create an 
 app/package.json
  file. 
 NativeScript uses this file to get the main file of the project:
  
 {
  
  ""main"": ""app.js"" 
  
 }",NA
Adding TypeScript,"By default, NativeScript apps should be written in JavaScript. We will not use 
 gulp
  to 
 compile our TypeScript files since NativeScript has built-in support for transpilers like 
 TypeScript. We can add TypeScript to it by running the following command:
  
 tns install typescript
  
 After running this command, NativeScript will automatically compile TypeScript to 
 JavaScript. This command has created two files: 
 tsconfig.json
  and 
 references.d.ts
 .
  
 The 
 tsconfig
  file contains the configuration for TypeScript. We will add the 
 outDir 
 option to 
 tsconfig.json
  so that we do not have to place the source files in the same direction as the 
 compiled files. NativeScript requires that JavaScript files are placed in the app folder. We 
 will write our TypeScript sources in the 
 src
  folder, and the compiler will write the output 
 to the app folder:
  
 {
  
  
  ""compilerOptions"": {
  
  
  
  ""module"": ""commonjs"",
  
  
  
  ""target"": ""es5"",
  
  
  
  ""inlineSourceMap"": true,
  
  
  
  ""experimentalDecorators"": true,
  
  
  
  ""noEmitHelpers"": true,
  
  
  
  ""outDir"": ""app""
  
  
  },
  
  
  ""exclude"": [
  
  
  
  ""node_modules"",
  
  
  
  ""platforms""
  
  
  ] 
  
 }
  
 The 
 references.d.ts
  file contains a reference to the definition files (
 .d.ts
  files) of the core 
 modules of NativeScript.",NA
Creating a Hello World page,"To get started with NativeScript, we will first write a simple app. In 
 src/app.ts
 , we must 
 register 
 mainEntry
  that will create the view of the app. The entry should be a function that 
 returns a 
 Page
 . A 
 Page
  attribute is one of the classes that NativeScript uses for the user 
 interface. We can create a basic page as follows:
  
 import * as application from ""application""; import { Page } 
 from ""ui/page""; 
  
 import { Label } from ""ui/label"";
  
 application.mainEntry = () => {
  
  const page = new Page();
  
  const label = new Label();
  
  label.text = ""Hello, World"";
  
  page.content = label;
  
  return page; 
  
 }; 
  
 application.start();
  
 This will create a single label and add it to the page. The content of the page should be a 
 View
  class, which is the base class that all components (including 
 Label
 ) in NativeScript 
 inherit.
  
 You can run the app with one of the following commands for Android and iOS, 
 respectively:
  
 tns run android --emulator 
  
 tns run ios --emulator
  
 You can run the app on a device by removing 
 --emulator
 . Your device should be 
 connected using a USB cable. You can see all connected devices by running 
 tns device
 .
  
 NativeScript prints a lot on the console after the output of TypeScript. 
 Make sure you do not miss any compile errors of TypeScript.",NA
Creating the main view,"The main view will show a list of recent scans. Clicking on one of the recent scans opens a 
 details page that shows more details on the scan. When a user clicks on the 
 Scan
  button, the 
 user can scan a QR code using the camera:
  
  
 First, we create the model of a scan in 
 src/model.ts
 . We need to store the content (a 
 string) and the date of the scan:
  
 export interface Scan {
  
  content: string;
  
  date: Date; 
  
 }
  
 [ 105 ]",NA
Adding a details view,"The details view is shown when the user scans a code or clicks on an item in the recent 
 scans list. It shows the content of the scan and the date, as shown in the following 
 screenshot:
  
  
 [ 109 ]",NA
Scanning QR codes,"NativeScript has support for plugins. A plugin can add extra functionality, such as turning 
 on the flash light of a phone, vibrating the phone, logging in with Facebook, or scanning QR 
 codes. These can be installed using the command line interface of NativeScript.
  
 We will use a NativeScript plugin to scan QR codes. The plugin is called NativeScript 
 BarcodeScanner. It can scan QR codes and other barcode formats. The plugin can be 
 installed using the following command:
  
 tns plugin add nativescript-barcodescanner",NA
Type definitions,"We must add a definition file to import the plugin. The plugin does not contain type 
 definitions, and type definitions are not available on DefinitelyTyped and TSD. It is not 
 necessary to write definitions that are fully correct. We only have to type the parts of the 
 library that we are using. We use the scan function, which can take an optional settings 
 object and return a 
 Promise
 . In 
 src/definitions.d.ts
 , we write the following definition:
  
 declare module ""nativescript-barcodescanner"" { function 
 scan(options?: any): Promise<any>; }
  
 You do not need to specify the 
 export
  keyword in definition files. All 
 declarations in a module in a definition file are automatically considered 
 to be exported.",NA
Implementation,"The 
 scan
  function can now be implemented. We use the exported 
 scan
  function and listen for 
 Promise
  to resolve or reject. When 
 Promise
  resolves, we add the item to the list and open the 
 details page.
  
 We can import the plugin in 
 src/app.ts
 :
  
 import * as barcodescanner from ""nativescript-barcodescanner"";
  
 [ 113 ]",NA
Testing on a device,"In the emulator, we cannot take a picture of a QR code; thus, we have to test the app on a 
 device. We can do that by connecting the device using a USB cable and then running 
 tns run 
 android
  or 
 tns run ios
 . You can test the app using these QR codes, which contain text (left 
 image) and a URL (right image). You can scan the QR codes several times and notice the list 
 build up in the main view. When you restart the app, you will see that the list is cleared. We 
 will fix that in the next section.
  
  
 [ 115 ]",NA
Adding persistent storage,"When the user closes and reopens the app, the user sees an empty list of scans. We can 
 make the list persistent by saving it after a scan and loading it when the app starts. We can 
 use the 
 application-settings
  module to store the scans. The storage is based on 
 key-value
 : a 
 value is assigned to a specific key.
  
 Only booleans, numbers, and strings can be stored using this module. An array cannot be 
 stored. Instead, one could store the length under one key (for instance, 
 items-length
 ) and the 
 items under a set of keys (
 items-0
 , 
 items-1
 , 
 …
 ). An easier approach is to convert the array to a 
 string using 
 JSON
 .
  
 The list can be saved using the following function:
  
 function save() {
  
  applicationSettings.setString(""items"", JSON.stringify(items)); }
  
 The 
 Date
  objects are converted to strings by 
 JSON.stringify
 . Thus, we must convert them 
 back to a 
 Date
  object manually:
  
 function load() {
  
  const data = applicationSettings.getString(""items""); if (data) {
  
   
  try {
  
    
  items = (<any[]> JSON.parse(data)).map(item => ({
   
   
  content: item.content,
  
     
  date: new Date(item.date)
  
    
  }));
  
   
  } catch (e) {}
  
  } 
  
 }
  
 Before 
 application.start()
 , we must call the 
 load
  and 
 update
  functions to show the previous 
 scans:
  
 const page = createPage(index => showDetailsPage(items[index]), scan); application.mainEntry = 
 page.createView; 
  
 load(); 
  
 update(); 
  
 application.start();",NA
Styling the app,"The app can be styled using CSS. Not all CSS properties are supported, but basic settings 
 like fonts, colors, margin, and padding work. We can add a stylesheet in the app adding the 
 following code before 
 application.start()
 :
  
 application.cssFile = ""style.css"";
  
 We will change the style of the following parts of the app:
  
 In 
 app/style.css
 , we will first give the 
 ActionBar
  a background color:
  
 ActionBar {
  
  background-color: #237691;
  
  color: #fefefe; 
  
 }
  
 The stylesheet must be added in the 
 app
  folder, instead of 
 src
 .
  
 NativeScript will only load files inside 
 app
 . TypeScript files are compiled 
 into that folder, but the stylesheet should already be located there.
  
 We will add some margin to the labels in the list and details page:
  
 Label {
  
  margin: 10px; 
  
 }",NA
Comparing NativeScript to alternatives,"Various frameworks that can build mobile apps exist. Lots of developers use 
 Cordova
  or 
 Phonegap
 . These tools wrap an HTML page into an app. These apps are called hybrid, as 
 they combine HTML pages with mobile apps. The user interface is not native and can give a 
 bad user experience.
  
 Other tools have a native interface, which gives a good look and feel. 
 Titanium
 , 
  
 NativeScript
 , and 
 React Native
  do this. With these tools, less code can be shared between a 
 web app and mobile app. With React Native, apps can be written using the React 
  
 framework.
  
 [ 119 ]",NA
Summary,"In this chapter, we created a mobile app using NativeScript. We used a plugin to scan QR 
 codes. The scans are saved, so the list is persisted after a restart of the app. Finally, we 
 added custom styles to our app.
  
 In the next chapter, we will build a spreadsheet web app using React. We will discover 
 some principles of functional programming and learn how we can handle the state of an 
 application. We will also see how we can build a cross-platform application.",NA
Advanced Programming in ,NA,NA
,NA,NA
TypeScript,"In the previous chapters, we learned the basics of TypeScript and we worked with various 
 frameworks. We will discover more advanced features of TypeScript in this chapter. This 
 chapter covers the following aspects:
  
 Using type guards
  
 More accurate type guards
  
 Checking null and undefined
  
 Creating tagged union types
  
 Comparing performance of algorithms",NA
Using type guards,"Sometimes, you must check whether a value is of a certain type. For instance, if you have a 
 value of a class 
 Base
 , you might want to check if it is of a certain subclass 
 Derived
 . In 
 JavaScript you would write this with an 
 instanceof
  check. Since TypeScript is an extension of 
 JavaScript, you can also use 
 instanceof
  in TypeScript. In other typed languages, like C#, you 
 must then add a 
 type cast
 , which tells the compiler that a value is of a type, different from 
 what the compiler analyzed. You can also add type casts in two different ways. The old 
 syntax for type casts uses 
 <
  and 
 >
 , the new syntax uses the 
 as 
 keyword. You can see them 
 both in the next example:",NA
Narrowing,"The type of a variable will change (locally) after a type guard. This is called 
 narrowing
 . The 
 type will be more specific after narrowing. More specific can mean that a class type is 
 replaced by the type of a subclass, or that a union is replaced by one of its parts. The latter is 
 demonstrated in the following example:
  
 let x: string | number; 
  
 if (typeof x === ""string"") {
  
  // x: string 
  
 } else {
  
  // x: number 
  
 }
  
 As you can see, a type guard can also narrow a variable in the 
 else
  block.",NA
Narrowing any,"Narrowing will give a more specific type. For instance, 
 string
  is more specific than 
 any
 . 
 The following code will narrow 
 x
  from 
 any
  to 
 string
 :
  
 let x: any; 
  
 if (typeof x === ""string"") {
  
  // x: string 
  
 }
  
 In general, a more specific type can be used on more constructs than the initial type. For 
 instance, you can call 
 .substring
  on a string, but not on a 
 string | number
 . When narrowing 
 from any, that is not the case. You may write 
 x.abcd
  if 
 x
  has the type 
 any
 , but not when its 
 type is 
 string
 . In this case, a more specific type allows less constructs with that value. To 
 prevent these issues, the compiler will only narrow values of type 
 any
  to primitive types. 
 That means that a value can be narrowed to 
 string
 , but not to a class type, for instance. The 
 next example demonstrates a case where the compiler would give an undesired error, if this 
 was not implemented:
  
 let x: any; 
  
 if (x instanceof Object) {
  
  x.abcd(); 
  
 }
  
 In the block after the type guard, 
 x
  should not be narrowed to 
 Object
 .",NA
Combining type guards,"Type guards can be combined in two ways. First, you can nest if statements and thus apply 
 multiple type guards to a variable:
  
 let x: string | number | boolean; 
  
 if (typeof x !== ""string"") {
  
  if (typeof x !== ""number"") {
  
   
  // x: boolean
  
  } 
  
 }
  
 Secondly, you can also combine type guards with the logical operators (
 &&
  , 
 ||
 ). The 
 previous example can also be written as:
  
 let x: string | number | boolean; 
  
 if (typeof x !== ""string"" && typeof x !== ""number"") { // x: boolean 
  
 }
  
 With 
 ||
 , we can check that a value matches one of multiple type guards:
  
 let x: string | number | boolean; 
  
 if (typeof x === ""string"" || typeof x === ""number"") { // x: string | number 
  
 } else {
  
  // x: boolean 
  
 }
  
 More complex type guards can be created with user defined type guards.",NA
More accurate type guards,"Before TypeScript 2.0, the compiler did not use the control flow of the program for type 
 guards. The easiest way to see what that means, is by an example:
  
 function f(x: string | number) {
  
  if (typeof x === ""string"") {
  
   
  return;
  
  }
  
  x; 
  
 }",NA
Assignments,"Previously, the compiler did not follow assignments of a variable. If a variable was 
 reassigned in the block after an if statement, the narrowing would not be applied. Thus, in 
 the next example, the type of 
 x
  is 
 string | number
 , both before and after the assignment:
  
 let x: string | number = ...; 
  
 if (typeof x === ""string"") {
  
  x = 4; 
  
 }
  
 With control flow based type analysis, these assignments can be checked. The type of 
 x
  will 
 be string before the assignment and number after it. Narrowing after an assignment works 
 only for union types. The parts of the union type are filtered based on the assigned value.
  
 For types other than union types, the type of the variable will be reset to the initial type 
 after an assignment.
  
 This can be used to write a function that either accepts one value or a list of values, in one of 
 the following ways:
  
 function f(x: string | string[]) {
  
  if (typeof x === ""string"") x = [x];
  
  // x: string[] 
  
 } 
  
 function g(x: string | string[]) {
  
  if (x instanceof Array) {
  
   
  for (const item of x) g(item);
  
   
  return;",NA
Checking null and undefined,"TypeScript 2.0 introduces two new types: 
 null
  and 
 undefined
 . You have to set the compiler 
 option 
 strictNullChecks
  to 
 true
  to use these types. In this mode, all other types cannot 
 contain 
 undefined
  or 
 null
  anymore. If you want to declare a variable that can be 
 undefined
  
 or 
 null
 , you have to annotate it with a union type. For instance, if you want a variable that 
 should contain a 
 string
  or 
 undefined
 , you can declare it as 
 let x: string | undefined;
 .
  
 Before assignments, the type of the variable will be 
 undefined
 . Assignments and type 
 guards will modify the type locally.",NA
Guard against null and undefined,"TypeScript has various ways to check whether a variable could be 
 undefined
  or 
 null
 . The next 
 code block demonstrates them:
  
 let x: string | null | undefined = ...; 
  
 if (x !== null) {
  
  // x: string | undefined 
  
 } 
  
 if (x !== undefined) {
  
  // x: string | null 
  
 } 
  
 if (x != null) {
  
  // x: string 
  
 } 
  
 if (x) {
  
  // x: string 
  
 }
  
 The last type guard can have unexpected behavior, so it is advised to use the others instead. 
 At runtime, 
 x
  is converted to a Boolean. 
 null
  and 
 undefined
  are both converted to 
 false
 , non-
 empty strings to 
 true
 , but an empty string is converted to 
 false
 . The latter is not always 
 desired.",NA
The never type,"TypeScript 2.0 also introduced the 
 never
  type, which represents an unreachable value. For 
 instance, if you write a function that always throws an error, its return type will be 
 never
 .
  
 function alwaysThrows() {
  
  throw new Error(); 
  
 }
  
 In a union type, 
 never
  will disappear. Formally, 
 T | never
  and 
 never | T
  are equal to 
 T
 . You 
 can use this to create an assertion that a certain position in your code is unreachable:
  
 function unreachable() {
  
  throw new Error(""Should be unreachable""); } 
  
 function f() {
  
  switch (...) {
  
   
  case ...:
  
    
  return true;
  
   
  case ...:
  
    
  return false;
  
   
  default:
  
    
  return unreachable(); 
  
 }
  
 The compiler takes the union of the types of all expressions in return statements. That gives 
 boolean | never
  in this example, which is reduced to 
 boolean
 .
  
 We will use 
 strictNullChecks
  in the next chapters.",NA
Creating tagged union types,"With TypeScript 2.0, you can add a tag to union types and use these as type guards. That 
 feature is called: 
 discriminated union types
 . This sounds very difficult, but in practice it is 
 very easy. The following example demonstrates it:
  
 interface Circle {
  
  type: ""circle""; 
  
 radius: number;",NA
Comparing performance of algorithms,"We will also write some small algorithms in the next chapters. This section shows how the 
 performance of an algorithm can be estimated. During such analysis, it is often assumed 
 that only a large input gives performance problems. The analysis will show how the 
 running time scales when the input scales.",NA
Big-Oh notation,"Mathematicians created a notation to write this more simply, called Big-Oh notation. When 
 you say that the running time is 
 O(n)
 , you mean that the running time is at most 
 n * 
 something
 , for a big enough 
 n
 . In general, 
 O(f(n))
 , where 
 f(n)
  is a formula, means that the 
 running time is at most a multiple of 
 f(n)
 . More formally, if you say that the running time is 
 O(f(n))
 , you mean that for some numbers 
 N
  and 
 c
  the following holds: if 
 n > N 
 then the 
 running time is at most 
 c * f(n)
 . The condition 
 n > N
  is a formal way of saying: if 
 n
  is big 
 enough, the value of 
 c
  is the replacement of something.",NA
Optimizing algorithms,"For a large array, this function might be too slow. If we would want to optimize this 
 algorithm, we can make the second 
 for
  loop shorter.
  
 function hasDuplicate(items: number[]) {
  
  for (let i = 0; i < items.length; i++) {
  
  
  for (let j = 
 0; j < i; j++) {
  
    
  if (items[i] === items[j]) return true;
  
  
  }
  
  }
  
  return false; 
  
 }
  
 With the old version, we would compare every two items twice, but now we compare them 
 only once. We also can remove the check 
 i !== j
 . It requires some more work to analyze this 
 algorithm. The body of the second 
 for
  loop is now evaluated 
 0 + 1 + 2 + ... + (n- 1)
  times. This 
 is a sum of 
 n
  terms and the average of the terms is 
 (n - 1) / 2
 . This results in 
 n * (n-1) / 2
 , or 
 n2 
 / 2 - n / 2
 . With the Big-Oh notation, you can write this as 
 O(n 
 2
 )
 . This is the highest term, so 
 the whole algorithm still runs in 
 O(n 
 2
 )
 . As you can see, there is no difference in the Big-Oh 
 between the original and optimized versions. The algorithm will be about twice as fast, but 
 if the original algorithm was way too slow, this one is probably too slow. Real optimization 
 is a bit harder to find.",NA
Binary search,"We will first take a look at the 
 indexOf
  example, which runs in 
 O(n)
 . What if we knew that 
 the input is always a sorted list? In such a case, we can find the index much faster. If the 
 element at the center of the array is higher than the value that we search, we do not have to 
 take a look at all elements on the right side of the array. If the value at the center is lower, 
 then we can forget all elements on the left side. This is called 
 binary search
 . We can 
 implement this with two variables, 
 left
  and 
 right
 , which represent the section of the array in 
 which we are searching: 
 left
  is the first element of that section, and 
 right
  is the first element 
 after the section. So 
 right - 1
  is the last element of the section. The code works as follows: it 
 chooses the center of the section. If that element is the element that we search, we can stop. 
 Otherwise, we check whether we should search on the left or right side.
  
 When 
 left
  equals 
 right
 , the section is empty. We will then return 
 -1
 , since we did not find 
 the element.
  
 function binarySearch(items: number[], item: number) { let left = 0;
  
  let right = items.length;
  
  while (left < right) {
  
   
  const mid = Math.floor((left + right) / 2);
  
   
  if (item === items[mid]) {
  
   
  return mid;
  
   
  } else if (item < items[mid]) {
  
    
  right = mid;
  
   
  } else {
  
    
  left = mid + 1;
  
   
  }
  
  }
  
  return -1; 
  
 }
  
 What is the running time of this algorithm? To find that, we must know how often the body 
 of the loop is evaluated. Every time that the body is executed, the function returns, or the 
 length of the section is approximately divided by two. In the worst case, the length of the 
 section is constantly divided by two, until the section contains one element. That element is 
 the searched element and the function returns or the length becomes zero and the function 
 while loop stops. So, we can ask the question: how often can you divide 
 n
  by two, until it 
 becomes less than one? 
 2
 log n
  gives us that number. This algorithm runs in 
 O( 
  
 2
 log(n))
 , which is a lot faster than 
 O(n)
 . However, it only works if the array is sorted.",NA
Built-in functions,"When you use other functions in your algorithm, you must be aware of their running time. 
 We could for instance implement 
 indexOf
  like this:
  
 function fastIndexOf(items: number[], item: number) { items.sort();
  
  return binarySearch(items, item); 
  
 }
  
 Both lines of the function are only executed once, but 
 O(1)
  is not the running time of this 
 algorithm! This function calls 
 binarySearch
 , and we know that the body of the while loop in 
 that function runs, at most, approximately 
 2
 log n
  times. We do not need to know how the 
 function is implemented, we only need to know that it takes 
 O( 
 2
 log(n))
 . We also call 
 .sort()
  
 on the array. We have not written that function ourselves and we cannot analyze the code 
 for it. For these functions, you must know (or look up) the running time. For sorting, that is 
 O(n 
 2
 log(n))
 . So our 
 fastIndexOf
  is not faster than the original version, as it runs in 
 O(n 
 2
 log(n))
 .
  
 We can however use sorting to improve the 
 hasDuplicate
  function.
  
 function hasDuplicate(items: number[]) {
  
  items.sort();
  
  for (let i = 1; i < items.length; i++) {
  
   
  if (items[i] === items[i - 1]) return true; }
  
  return false; 
  
 }
  
 The loop costs 
 O(n)
  and the sorting costs 
 O(n 
 2
 log(n))
 , so this algorithm runs in 
 O(n 
 2
 log(n))
 . This is faster than our initial implementation, that took 
 O(n 
 2
 )
 .
  
 With this basic knowledge, you can analyze simple algorithms and compare their speeds 
 for large inputs. In the next chapters, we will analyze some of the algorithms that we will 
 write.
  
 [ 132 ]",NA
Summary,"In this chapter, we have seen various new features of TypeScript 2.0. In this release, lots of 
 new features for more accurate type analysis were added. We have seen control flow based 
 type analysis, null and undefined checking, and tagged union types. Finally, we have also 
 taken a look at analyzing algorithms. We will use most of these topics in the next three 
 chapters. In 
 Chapter 7
 , 
 Spreadsheet Application with Functional Programming
 , we will build a 
 spreadsheet application. We will also discover functional programming there.
  
 [ 133 ]",NA
Spreadsheet Applications with ,NA,NA
,NA,NA
Functional Programming,"In this chapter, we will explore a different style of programming: 
 functional programming
 . 
 With this style, functions should only return something and not have other side effects, such 
 as assigning a global variable. We will explore this by building a spreadsheet 
  
 application.
  
 Users can write calculations in this application. The spreadsheet contains a grid and every 
 field of the grid can contain an expression that will be calculated. Such expressions can 
 contain constants (numbers), operations (such as addition, multiplying), and they can 
 reference other fields of the spreadsheet. We will write a parser, that can convert the string 
 representation of such expressions into a data structure. Afterwards, we can calculate the 
 results of the expressions with that data structure. If necessary, we will show errors such as 
 division by zero to the user.",NA
Setting up the project,"We start by installing the dependencies that we need in this chapter using NPM:
  
 npm init -y 
  
 npm install react react-dom -save 
  
 npm install gulp gulp-typescript small --save-dev
  
 We set up TypeScript with 
 lib/tsconfig.json
 :
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es5"",
  
   
  ""module"": ""commonjs"",
  
   
  ""noImplicitAny"": true,
  
   
  ""jsx"": ""react""
  
  } 
  
 }
  
 We configure gulp in 
 gulpfile.js
 :
  
 var gulp = require(""gulp""); 
  
 var ts = require(""gulp-typescript""); 
  
 var small = require(""small"").gulp;
  
 var tsProject = ts.createProject(""lib/tsconfig.json"");",NA
Functional programming,"When you ask a developer what the definition of a function is, he would probably answer 
 something like 
 “
 something that does something with some arguments
 ”
 . Mathematicians 
 have a formal definition for a function:
  
 A function is a relation where an input has exactly one output.
  
 This means that a function should always return the same output for the same input. 
 F
 unctional programming
  (
 FP
 ) uses this mathematical definition. The following code would 
 violate this definition:
  
 let x = 1; 
  
 function f(y: number) {
  
  return x + y; 
  
 }
  
 f(1); 
  
 x = 2; 
  
 f(1);
  
 The first call to 
 f
  would return 
 2
 , but the second would return 
 3
 . This is caused by the 
 assignment to 
 x
 , which is called a 
 side effect
 . A reassignment to a variable or a property is 
 called a side effect, since function calls can give different results after it.
  
 It would be even worse if a function modified a variable that was defined outside of the 
 function:
  
 let x = 1; 
  
 function g(y: number) {
  
  x = y; 
  
 }
  
 Code like this is hard to read or test. These mutations are called side effects. When a piece of 
 code does not have side effects, it is called 
 pure
 . With functional programming, all or most 
 functions should be pure.",NA
Calculating a factorial,"We will take a look at the factorial function to see how we can surpass the limitations of 
 functional programming. The factorial function, written as 
 n!
  is defined as 
 1 * 2 * 3 * ... * n
 . 
 This can be programmed with a simple 
 for
  loop:
  
 export function factorial(x: number) {
  
  let result = 1;
  
  for (let i = 1; i <= x; i++) {
  
   
  result *= i;
  
  }
  
  return result; 
  
 }
  
 However, the value of 
 i
  is increased in the loop, which is a reassignment and thus a side 
 effect. With functional programming, recursion should be used instead of a loop. The 
 factorial of 
 x
  can be calculated using the factorial of 
 x - 1
  and multiplying it with 
 x
 , since 
 x! = 
 x * (x-1)!
  for 
 x > 1
 . The following function is pure and smaller than the iterative function. 
 Calling a function from the same function is called recursion.
  
 export function factorial(x: number): number { if (x <= 1) return 
 1;
  
  return x * factorial(x - 1); 
  
 }
  
 When you define a function with recursion, TypeScript cannot infer the 
 return type. You have to specify the return type yourself in the function 
 header.
  
 We will use this function later on, so save this as 
 lib/model/utils.ts
 .",NA
Using data types for expressions,"Fields of the spreadsheet can contain expressions, that can be calculated. To calculate these 
 values, the input of the user must be converted to a data structure, which can then be used 
 to calculate the result of that field.
  
  
  
  
  
  
  
  
  
 These expressions can contain constants, operations, references to other fields or a 
 parenthesized expression:
  
 Constants: 
 0
 , 
 42
 , 
 10.2
 , 
 4e6
 , 
 7.5e8
  
 Unary expression: 
 -expression
 , 
 expression!
  
 Binary expression: 
 expression + expression
 , 
 expression / expression
  
 References: 
 3:1
  (third column, first row)
  
 Parenthesized expression: 
 (expression)
  
 We will create these types in 
 lib/model/expression.ts
 . First we import 
 factorial
 , since we 
 will need it later on.
  
 import { factorial } from ""./utils"";",NA
Creating data types,"We can declare data types for these expression kinds. We define them using a class. We can 
 distinguish these kinds easily using 
 instanceof
 . We can declare 
 Constant
  as follows:
  
 export class Constant {
  
  constructor(
  
   
  public value: number
  
  ) {}",NA
Traversing data types,"We can distinguish these classes using 
 instanceof
 . We will demonstrate that by writing a 
 function that converts an expression to a string. TypeScript will change the type of a 
 variable after an 
 instanceof
  check. These checks are called type guards. In the code below, 
 formula instanceof Constant
  narrows the type of 
 formula
  to 
 Constant
  in the block after the 
 if
 . In 
 the 
 else
  block, 
 Constant
  is removed from the type of 
 formula
 , resulting in 
 UnaryOperation | 
 BinaryOperation | Variable | Parenthesis
 .
  
 Using a sequence of 
 if
  statements, we can distinguish all cases. For a constant, we can 
 simply convert the value to a string:
  
 export function expressionToString(formula: Expression): string { if (formula instanceof 
 Constant) {
  
   
  return formula.value.toFixed();",NA
Validating an expression,"When you are writing a function with recursion, you should always be sure that you are not 
 creating infinite recursion, similar to an infinite loop. For instance, when you forget the base 
 cases of the factorial function (
 x <= 1
 ), you would get infinite recursion.
  
 We would also get recursion when a field of the spreadsheet references itself (directly or 
 indirectly). To prevent these issues, we will validate an expression before calculating it. We 
 create the restriction that a reference should not point to itself and it may not reference a 
 higher column or row index.
  
 Later on, we will also show errors when a number is divided by zero, when the factorial of a 
 negative or non-integer is calculated, when a referenced field contains an error, and when a 
 referenced field contains text instead of a number. We define a class 
 Failure
  to represent 
 such an error:
  
 export class Failure {
  
  constructor(
  
   
  public kind: FailureKind,
  
   
  public location: Expression
  
  ) {} 
  
 } 
  
 export enum FailureKind {
  
  ForwardReference,
  
  SelfReference,
  
  TextNotANumber,
  
  DivideByZero,
  
  FactorialNegative,
  
  FactorialNonInteger,
  
  FailedDependentRow 
  
 }",NA
Calculating expressions,"The last traversal is calculating the expression. This function will return a number if the 
 calculation succeeded. Otherwise, it will return a list of errors. The arguments of the 
 function are the expression and a function that gives the value of a referenced field:
  
 export function calculateExpression(formula: Expression, resolve: (variable: Variable) => 
 number | Failure[]): number | Failure[] {
  
 For a constant, we can simply return its value:
  
  if (formula instanceof Constant) {
  
  
  return formula.value;
  
 To calculate the value of a 
 UnaryOperation
 , we first calculate its operand. If that contains an 
 error, we propagate it. Otherwise, we calculate the factorial or the negative value of it. For 
 a factorial we also show an error if it is not a non-negative integer. Because of the type 
 guard, TypeScript narrows the type of 
 value
  to a 
 number
  in the 
 else
  block:
  
  } else if (formula instanceof UnaryOperation) {
  
   
  const { expression, kind } = formula;
  
   
  const value = calculateExpression(expression, resolve);
  
   
  if (value instanceof Array) {
  
    
  return value;
  
   
  } else {
  
    
  switch (kind) {
  
     
  case UnaryOperationKind.Factorial:
  
     
  if (value < 0) {
  
      
  return [new              Failure(FailureKind.FactorialNegative, formula)];
  
     
  }
  
     
  if (Math.round(value) !== value) {
  
      
  return [new 
  
 Failure(FailureKind.FactorialNonInteger, formula)];
  
     
  }
  
     
  return factorial(Math.round(value));",NA
Parsing an expression,"A parser can convert a string to some data type. The first guess of the type of a parser 
 would be:
  
 type Parser<T> = (source: string) => T;
  
 Since we will also use a parser to parse a part of the source. For instance, when parsing a 
 factorial, we first parse the operand (which hopefully has one character remaining, the 
 exclamation mark) and then parse the exclamation mark. Thus, a parser should return the 
 resulting data and the remaining source:
  
 type Parser<T> = (source: string) => [T, string];
  
 A constant (such as 5.2) and a variable (5:2) both start with a number. Because of that, a 
 parser should return an array with all options:
  
 type Parser<T> = (source: string) => [T, string][];
  
 To demonstrate how this works, imagine that there are two parsers: one that parses 
 A
 , one 
 that parses 
 AA
  and one that parses 
 AB
 . The string 
 AAA
  could be parsed with a sequence of 
 these parsers in three different ways: 
 A-A-A
 , 
 A-AA
 , and 
 AA-A
 . Now imagine that the parsers 
 can first parse 
 A
  or 
 AA
 , and then only 
 AB
 . We will parse 
 AAB
 . The first part would result in 
 the following result:
  
 [
  
  [""A"", ""AB""]
  
  [""AA"", ""B""] 
  
 ]
  
 The remaining string of the first element (
 AB
 ), can then be parsed by the second parser (
 AB
 ). 
 This would have an empty string as the remaining part. The remaining string of the second 
 item (
 B
 ) cannot be parsed. Thus, these parses can parse 
 AAB
  as 
 A-AB
 .",NA
Creating core parsers,"We will first create two core parsers in 
 lib/model/parser.ts
 . The function 
 parse
  runs a parser 
 and returns the result if successful, 
 epsilon
  will always succeed and 
 token
  will try to parse a 
 specific string. The value can be specified as the last argument for both functions:
  
 type ParseResult<T> = [T, string][]; 
  
 type Parser<T> = (source: string) => ParseResult<T>;",NA
Running parsers in a sequence,"Another way to combine parsers is running them in a sequence. Before we can write these 
 functions, we must define two helper functions in 
 lib/model/utils.ts
 . 
 flatten
  will convert an 
 array of arrays into an array. 
 flatMap
  will first call 
 map
  on the array and secondly 
 flatten
 :",NA
Parsing a number,"A number or constant can be written in the following ways:
  
 8 (integer)
  
 8.5 (with decimal part)
  
 8e4 = 80000 (with exponent)
  
 8.5e4 = 85000 (with decimal part and exponent)
  
 We create two parsers, that will parse the decimal part and exponent of a number. They 
 fallback to a default value (0 and 1) in case the number does not have a decimal part or 
 exponent:
  
 const parseDecimal = or(
  
  epsilon(0),
  
  sequence2(
  
   
  token(""."", undefined),
  
   
  parseDigits,
  
   
  (dot, digits) => toInteger(digits) / Math.pow(10, digits.length) ) 
  
 ); 
  
 const parseExponent = or(
  
  epsilon(1),
  
  sequence2(
  
   
  token(""e"", undefined),
  
   
  parseDigits,",NA
Order of operations,"When evaluating an expression, the order of execution is important. For instance, 
 (3 * 4) + 
 2 
 equals 
 14
 , while 
 3 * (4 + 2)
  equals 
 18
 . The correct evaluation of 
 3 * 4 + 2
  is the first one. An 
 expression should be evaluated in this order:
  
 1. Parenthesis
  
 2. Multiplication and division
  
 3. Addition and subtraction
  
 4. 
  
 Unary expressions
  
 Multiple instances of the same group should be evaluated from left to right, so 
 10 - 2 + 3 = 
 (10 - 2) + 3
 .
  
 Two ways exist to implement this: parsing the source in the right order, or parsing it left to 
 right and correcting it during calculation. Since we already wrote the calculation part, we 
 will parse the source in the right order. That is also the easiest option.
  
 [ 152 ]",NA
Defining the sheet,"A spreadsheet will be a grid of fields. Every field can contain a string or an expression, as 
 demonstrated in the following screenshot:
  
  
 In 
 lib/model/sheet.ts
 , we will define the sheet and create functions to parse, show and 
 calculate all expressions in the field.
  
 First, we will import types and functions that we will use in this file.
  
 import { Expression, Variable, calculateExpression, Constant, Failure, FailureKind, validate, 
 expressionToString } from ""./expression""; import { parse, parseConstant, parseExpression} from 
 ""./parser"";
  
 We can define a field as an expression or a string, and a sheet as a grid of fields:
  
 export type Field = Expression | string; export class 
 Sheet {
  
  constructor(
  
   
  public title: string,
  
   
  public grid: Field[][]
  
  ) {} 
  
 }
  
 Now we will write functions that give the amount of columns and rows of the sheet.
  
 export function columns(sheet: Sheet) {
  
  return sheet.grid.length; 
  
 } 
  
 export function rows(sheet: Sheet) {
  
  const firstColumn = sheet.grid[0];
  
  if (firstColumn) return firstColumn.length; return 0; 
  
 }",NA
Calculating all fields,"We will write a function that calculates all expressions in the spreadsheet. A field that 
 contains an expression is converted to a number, if the calculation succeeded, or an array of 
 errors otherwise. A field that contains text does not need calculation, so the content is 
 immediately returned.
  
 This yields this type for the result of the calculation:
  
 export type Result = ResultField[][]; 
  
 export type ResultField = string | number | Failure[];
  
 We will use two nested loops to loop over each field. This is not pure, but it makes it easier 
 to resolve variables in expressions. When a valid expression is to be calculated, the 
 referenced fields would already be evaluated.
  
 export function calculateSheet({ grid }: Sheet) { const result: 
 ResultField[][] = [];",NA
Using the Flux architecture,"In React, every class component can have a state. Maintaining a state is a side effect and not 
 pure, so we will not use that in this application. Instead, we will use Stateless Functional 
 Components, which are pure. We still need to maintain the state of the application. We will 
 use the Flux architecture to do that. With Flux, you need to write a small piece of non-pure, 
 but the other parts of the application can be written pure. The architecture can be divided 
 into these parts:
  
 Store
 : Contains the state of the application
  
 View
 : React components that render the state to HTML
  
 Action
 : A function that can modify the state (example: rename the spreadsheet)
  
 Dispatcher
 : A hub modifies the state by executing an action
  
 Several implementations of Flux exist. We will build our own, so that we can understand 
 the ideas better and we can create an implementation that can be properly typed using 
 TypeScript.
  
 We will implement these parts in the following sections.",NA
Defining the state,"In 
 lib/model/state.ts
 , we can define an interface that contains the state of the 
 application. The state should contain this information:
  
 Active spreadsheet
  
 Calculated results of all expressions
  
 Selected column and row if a popup is opened
  
 Content of the textbox of the popup
  
 Whether or not the textbox of the popup contains a syntax error
  
 This yields the following declaration:
  
 import { Sheet, Result } from ""./sheet"";",NA
Creating the store and dispatcher,"We will create the store and dispatcher in 
 lib/model/store.ts
 . The dispatcher should take 
 an action and execute it. We first define an action as a function that modifies a state. 
 Since we cannot assign to the state, as that is not pure, an action should not adjust the old 
 state, but create a new state object with a certain modification.
  
 export type Action<T> = (state: T) => T;
  
 The dispatcher should accept such action. We define the dispatcher as a function with an 
 action as an argument.",NA
Creating actions,"An action should modify the state. To do that, we will first create three helper functions. 
 One to modify a part of an object, one to modify a part of an array, and one to easily create a 
 new array.
  
 We use the same update function as we did in 
 Chapter 3
 , 
 Note-Taking App with a Server
 . We 
 add this function to 
 lib/model/utils.ts
 .
  
 export function update<U extends V, V>(old: U, changes: V): U { const result = 
 Object.create(Object.getPrototypeOf(old)); for (const key of Object.keys(old)) {
  
   
  result[key] = (<any> old)[key];
  
  }
  
  for (const key of Object.keys(changes)) {
  
   
  result[key] = (<any> changes)[key];
  
  }
  
  return result; 
  
 }
  
 We also create a function that changes the element at a certain 
 index
  of an array. The other 
 elements will remain at the same location. We will use this function to change the content of 
 a field of the spreadsheet later on.
  
 export function updateArray<U>(array: U[], index: number, item: U) { return [...array.slice(0, 
 index), item, ...array.slice(index + 1)]; }",NA
Adding a column or a row,"In 
 lib/model/action.ts
 , we will create the actions for our application. First we must 
 import the types and function that we have written before.
  
 import { State } from ""./state""; 
  
 import { calculateSheet, Field, rows, fieldToString, parseField } from ""./sheet""; 
  
 import { update, updateArray, rangeMap } from ""./utils"";
  
 Now we can create an action that calculates all expressions. We will not export this action, 
 but we will use it in other actions.
  
 const modifyResult = (state: State) =>
  
  update(state, {
  
   
  result: calculateSheet(state.sheet)
  
  });
  
 With this definition, 
 modifyResult
  is a function that takes a state and returns an updated 
 state with a modified 
 result
  property. This conforms to the Action type that we defined 
 earlier.
  
 We can use this function to create the actions that add a row or column. If a new row needs 
 to be added, every column should get an extra field at the end. This field should be empty; it 
 should contain the empty string. Afterwards, we need to update the 
 result
  property of the 
 state. We will use the 
 modifyResult
  function for that.
  
 export const addRow = (state: State) =>",NA
Changing the title,"Adding a row or a column is an action that does not have arguments. Changing the title 
 does require an argument, namely the new title. Since the definition of an action does not 
 allow extra arguments, we cannot write it as a function that requires the new title and the 
 current state. Instead, we can create a function that takes the new title, and then returns a 
 function that requires the current state. That will give this definition:
  
 export const setTitle = (title: string) => (state: State) => update(state, {
  
   
  sheet: update(state.sheet, { title })
  
  });
  
 This action can be fired by running 
 dispatch(setTitle(""Untitled""))
 . If you forget the argument, 
 or specify a wrong argument, TypeScript will give an error. Other 
  
 implementations of Flux make it hard to type such actions.",NA
Showing the input popup,"We need to create several actions for the popup:
  
 Open the popup
  
 Close it
  
 Toggle it (close if it is already open, close it otherwise)
  
 Change the input of the textbox
  
 Save the new value
  
 To open the popup, we need the column and the row of the field and save them in the state.
  
 We set the input of the popup to the content of that field, either a string or the expression 
 converted to a string. When the popup is opened, it cannot have any syntax errors so we set 
 that property to false.
  
 export const popupOpen = (selectedColumn: number, selectedRow: number) => (state: State) =>
  
  update(state, {
  
   
  selectedColumn,
  
   
  selectedRow,
  
   
  popupInput: 
  
 fieldToString(state.sheet.grid[selectedColumn][selectedRow]),
  
   
  popupSyntaxError: false
  
  });
  
 The popup can be closed by setting the column and row to 
 undefined.
  
 export const popupClose = (state: State) => update(state, {
  
   
  selectedColumn: undefined,
  
   
  selectedRow: undefined,
  
   
  popupInput: """"
  
  });
  
 To toggle the popup, we check whether it opened in the specified location, and close it or 
 open it afterwards.
  
 export const popupToggle = (column: number, row: number) => (state: State) =>
  
  (column === state.selectedColumn && row === state.selectedRow)
  
   
  ? popupClose(state) : popupOpen(column, row)(state);",NA
Testing actions,"Since actions are pure functions, we can easily test them. They can be tested without the 
 store, dispatcher, and view. To demonstrate this, we will write tests for 
 addColumn
 , 
 addRow 
 and 
 setTitle
 . We start with importing AVA, these functions and some helper functions.
  
 import * as test from ""ava""; 
  
 import { empty } from ""../model/state""; 
  
 import { addColumn, addRow, setTitle } from ""../model/action""; import { columns, rows 
 } from ""../model/sheet"";
  
 We will write a test for 
 addColumn
 . We validate that the amount of columns is increased by 
 one and that the amount of rows has not been changed.
  
 test(""addColumn"", t => {
  
  const state = addColumn(empty);
  
  t.is(columns(state.sheet), columns(empty.sheet) + 1); t.is(rows(state.sheet), 
 rows(empty.sheet)); 
  
 });
  
 We write a test for 
 addRow
  too. This time, we validate that the amount of columns stayed 
 the same but the amount of rows increased.
  
 test(""addRow"", t => {
  
  const state = addRow(empty);
  
  t.is(columns(state.sheet), columns(empty.sheet)); t.is(rows(state.sheet), 
 rows(empty.sheet) + 1); });
  
 For 
 setTitle
 , we check that the title has indeed been changed and that the grid has not 
 changed.
  
 test(""setTitle"", t => {
  
  const state = setTitle(""foo"")(empty); t.is(state.sheet.title, 
 ""foo"");
  
  t.is(state.sheet.grid, empty.sheet.grid); });
  
 When you get a bug report, try to create a unit test that demonstrates 
 that error. When you have fixed the bug, you can easily validate it by 
 running the tests and you prevent the bug from returning in the feature.",NA
Writing the view,"The application will show an input box at the top of the screen, which is used to type the 
 title of the spreadsheet. Below the title, a table is shown which contains all fields of the 
 spreadsheet. When the user clicks on a field, a popup is created which allows the user to 
 change the content of that field. If the field contains errors, these errors are shown in the 
 popup:
  
  
 We will use React to create the view of our application. With Stateless Functional 
 Components, we can write pure functions that render the state.",NA
Rendering the grid,"In 
 lib/client/sheet.tsx
 , we will import React and functions and types that we created before:
  
 import * as React from ""react""; 
  
 import { Dispatch } from ""../model/store""; 
  
 import { Expression, expressionToString, failureText } from 
  
 ""../model/expression"" 
  
 import { State } from ""../model/state""; 
  
 import { Sheet, Field, Result, ResultField, columns, rows, parseField, fieldToString } from 
 ""../model/sheet""; 
  
 import { update, rangeMap } from ""../model/utils""; 
  
 import * as action from ""../model/action"";",NA
Rendering a field,"To render a field, we will first query the content of the field and check whether the popup is 
 open on this field.
  
 function RenderField({ column, row, state, dispatch }: {column: number, row: number, state: State, 
 dispatch: Dispatch<State> }) {
  
  const field = state.sheet.grid[column][row];
  
  const result = state.result[column][row];
  
  const open = state.selectedColumn === column
  
   
  && state.selectedRow === row;",NA
Showing the popup ,"We will show the popup in 
 RenderPopup
 . The popup contains an input box, a save, and 
 cancel button:
  
  
 If the field contains an error, we show it below the two buttons:
  
  
 [ 170 ]",NA
Adding styles,"In 
 static/style.css
 , we will add some more styles. We will make the text of the input box 
 for the title bigger.
  
 .sheet-title {
  
  font-size: 24pt;
  
  margin: 0 0 10px;
  
  border: 1px solid #ccc;
  
  width: 200px; 
  
 }
  
 We will add a border to the table and style the button to add a column.
  
 .sheet > table, .sheet tr, .sheet th, .sheet td { border: 1px solid #ccc;
  
  border-collapse: collapse; 
  
 } 
  
 .sheet-add-column > a {
  
  width: 70px;
  
  display: block; 
  
 }",NA
Gluing everything together,"In 
 lib/client/index.tsx
 , we will combine all parts of our application. We will create a 
 component that contains the state and renders the view. When the state is updated in the 
 store, we will propagate that to this component and render the view again.
  
 import * as React from ""react""; 
  
 import { render } from ""react-dom""; 
  
 import { createStore, Dispatch } from ""../model/store""; import { State, empty } 
 from ""../model/state""; 
  
 import { RenderSheet } from ""./sheet"";
  
 class App extends React.Component<{}, State> { dispatch: 
 Dispatch<State>;
  
  state = empty;
  
  constructor(props: {}) {
  
   
  super(props);
  
   
  this.dispatch = createStore(this.state,      state => this.setState(state));
  
  }
  
  render() {
  
   
  return (
  
    
  <div className=""sheet"">
  
     
  <RenderSheet
  
     
  state={this.state}
  
     
  dispatch={this.dispatch} />
  
    
  </div>
  
   
  );
  
  } 
  
 }",NA
Advantages of Flux,"In this section you can find some of the advantages of using Flux, the architecture that we 
 used in this chapter.
  
 Flux is based on the unidirectional flow of data. Angular supports two way bindings, which 
 allow data to flow in two directions. With this data flow, a lot of properties might get 
 changed after a single change is made. This can lead to unpredictable behavior in big 
 applications. Flow and React do not have such bindings, but instead there is a clean flow of 
 data (
 store | view | action | dispatch | store
 ).
  
 The parts of Flux are not strictly bound to each other. This makes it easy to test specific 
 parts of the application with unit tests. We already saw that the actions do not depend on 
 the view.",NA
Going cross-platform,"Since the parts of Flux are not bound, we can, relatively, replace the HTML views of the 
 application with views of a different platform. The user interface does not store the state of 
 the application, but it is managed in the store. The other parts need no modification when 
 the HTML views are replaced. This way we can port the application to a different platform 
 and go cross-platform.",NA
Summary,"We have built a spreadsheet application with functional programming, React, and Flux in 
 this chapter. We have discovered the limitations of functional programming and learned 
 how we can take advantage of it. We have written automated unit tests for parts of the code 
 that we have written. We also saw how we can traverse data structures and write a parser 
 with functional programming. With the Flux architecture, we learnt how we can write the 
 biggest part of the application with pure functions.
  
 In the next chapter, we will see more of functional programming. We will rebuild Pac-Man 
 with the HTML5 canvas.
  
 [ 176 ]",NA
Pac Man in HTML5 ,NA,NA
,"In this chapter, we will recreate Pac Man with the HTML5 canvas. Just like the previous 
 chapter, we will be using functional programming. With the HTML5 canvas and JavaScript, 
 you can play games in the browser.
  
  
 Pac Man is a classic game where the player (Pac Man, the yellow circle) must eat all of the 
 dots. The ghosts are the enemies of Pac Man: when you get caught by a ghost, you lose. If 
 you eat all of the dots without being caught by a ghost, you win the game.
  
 Drawing on a canvas is, just like modifying the HTML elements of a page, a side effect and 
 thus not pure. Since we will be using functional programming, we will create some 
 abstraction around it, similar to what React does. We will build a small non-pure 
  
 framework so we can use that to build the rest of the game with pure functions. We will 
 also use 
 strictNullChecks
  in this chapter. The compiler will check which values can be 
 undefined or null.",NA
Setting up the project,"The project structure will be similar to the previous projects. In 
 lib
 , we will place our 
 sources. We separate the files for the framework and the game in 
 lib/framework
  and 
 lib/game
 . In 
 lib/tsconfig.json
 , we configure TypeScript:
  
 {
  
  
  ""compilerOptions"": {
  
  
  
  ""target"": ""es5"",
  
  
  
  ""module"": ""commonjs"",
  
  
  ""strictNullChecks"": true
  
  
  } 
  
 }
  
 In the root directory, we set up gulp in 
 gulpfile.js
 :
  
 var gulp = require(""gulp""); 
  
 var ts = require(""gulp-typescript""); 
  
 var small = require(""small"").gulp;
  
 var tsProject = ts.createProject(""lib/tsconfig.json"");
  
 gulp.task(""compile"", function() {
  
  return gulp.src(""lib/**/*.ts"")
  
   
  .pipe(ts(tsProject))",NA
Using the HTML5 canvas,"The 
 HTML5 canvas
  is an HTML element, just like 
 <div>
 . However, the canvas does not 
 contain other HTML elements, but it can contain a drawing generated by JavaScript code. In 
 lib/game/index.ts
  we will quickly experiment with it.
  
 We can get a reference to the canvas using 
 document.getElementById
  the same way we got a 
 reference to a 
 <div>
  element:
  
 const canvas = <HTMLCanvasElement> document.getElementById(""game"");
  
 We cannot directly draw on the canvas; we have to get a rendering context first. Currently, 
 two kinds of rendering contexts exist: a two dimensional context and a 
 webgl
  context, used 
 for 3D rendering. The 
 webgl
  context is a lot harder to use. Luckily, Pac Man is 2D, so we can 
 use the 2D context:
  
 const context = canvas.getContext(""2d"");",NA
Saving and restoring the state,"The context also has the functions 
 save()
  and 
 restore()
 . With these functions, you can 
 restore
  the current draw styles, such as 
 fillStyle
 , and 
 lineWidth
 . 
 restore()
  resets the state to 
 the last time that 
 save()
  was called, based on a LIFO stack (Last In, First Out).",NA
Designing the framework,"We will design the framework based on functional programming. The framework will 
 do all non-pure work, so that the rest of the application can be built with pure functions 
 (except for 
 Math.random
 ).
  
 Strictly speaking, 
 Math.random
  is not a pure function. Given that 
  
 Math.random()
  is not always equal to 
 Math.random()
 , that function will 
 update some internal state.
  
 In pure functional languages, such a function can still exist. That function 
 takes a state and returns a random number and a new state. Since every 
 call to random will get a different state, it can return different random 
 values.
  
 A game consists of an event loop. The amount of iterations that this loop does per second is 
 called FPS or frames per second. Every step of the loop, the game state needs to be updated. 
 For instance, enemies and the player can move, and the player can eat dots in Pac Man. At 
 the end of each step, the game state must be redrawn.
  
 The game must also handle user input. When the user presses the left button, the player 
 should start moving to the left.
  
 We will split the event loop into the following components:
  
 The view, which will draw the game every step
  
 A time handler, which will be called once in every step
  
 An event handler, which will be called for every event that occurs",NA
Creating pictures,"We will start by creating data types for pictures. Some examples of a picture are a circle, a 
 line, text, or a combination of those. Such pictures can also be scaled, repositioned 
 (translated), or rotated. An empty picture is also a picture.
  
 We define a picture as the union of these different kinds:
  
 export type Picture
  
  = Empty
  
  | Rectangle
  
  | RectangleOutline
  
  | Circle
  
  | CircleOutline
  
  | Line
  
  | Text
  
  | Color
  
  | Translate
  
  | Rotate
  
  | Scale
  
  | Pictures;",NA
Wrapping other pictures,"We can wrap other pictures and create new ones. For instance, we will change the color of a 
 picture with 
 Color
 . With this definition we can write 
 new Color(""#ff0000"", new Circle(0, 0, 2, 2))
  
 to get a red circle:
  
 export class Color {
  
  __colorBrand: void;
  
  constructor(
  
   
  public color: string,
  
   
  public picture: Picture
  
  ) {} 
  
 }
  
 We could also reposition a picture. This is usually called translating. 
 new Translate(100, 100, 
 new Circle(0, 0, 2, 2))
  draws a circle around (100, 100) instead of (0, 0):
  
 export class Translate {
  
  __translateBrand: void;
  
  constructor(
  
   
  public x: number,
  
   
  public y: number,
  
   
  public picture: Picture
  
  ) {} 
  
 }",NA
Creating events,"The application can accept keyboard events. We will distinguish between two kinds of 
 event: a key press and a key release. We will not add mouse events, but you can add these 
 yourself. We define these events in 
 lib/framework/event.ts
 .
  
 Every key has a certain key code, a number that identifies a key. For instance, the left arrow 
 key has code 37. We will add the key code to the 
 event
  class:
  
 export const enum KeyEventKind {
  
  Press,
  
  Release 
  
 } 
  
 export class KeyEvent {
  
  constructor(
  
   
  public kind: KeyEventKind,
  
   
  public keyCode: number
  
  ) {} 
  
 }
  
 We define the event source as a function that will be invoked every step. It will return a list 
 of events that occurred in that step.
  
 export function createEventSource(element: HTMLElement) { let queue: 
 KeyEvent[] = [];
  
  const handleKeyEvent = (kind: KeyEventKind) => (e: KeyboardEvent) => {
  
  
  
 e.preventDefault();
  
   
  queue.push(new KeyEvent(
  
    
  kind,
  
    
  e.keyCode
  
   
  ));
  
  };
  
  const keypress = handleKeyEvent(KeyEventKind.Press);
  
  const keyup = handleKeyEvent(KeyEventKind.Release);
  
  element.addEventListener(""keydown"", keypress);
  
  element.addEventListener(""keyup"", keyup);
  
  function events() {
  
   
  const result = queue;
  
   
  queue = [];
  
   
  return result;
  
  }
  
  return events; 
  
 }",NA
Binding everything together,"In 
 lib/framework/game.ts
 , we will bind these components together. We will create a 
 function that starts the event loop and updates the state every step. The function has these 
 arguments:
  
 The canvas element on which the game will be drawn.
  
 The event element. Events on this element will be sent to the event handler. This 
 does not have to be the same element as the canvas. An element needs focus to 
 get keyboard events. Since the canvas does not always have focus, it can be better 
 to listen for events on the body element, if there is only one game on the web 
 page.
  
 The amount of frames per second.
  
 The initial state of the game.
  
 A function that draws the state.
  
 The time handler.
  
 The event handler.
  
 We register the type of the state as a generic or type argument. Users of this function can 
 provide their own type. TypeScript will automatically infer this type based on the value of 
 the 
 state
  argument:
  
 import { Picture } from ""./picture""; 
  
 import { drawPicture } from ""./draw""; 
  
 import { createEventSource, KeyEvent } from ""./event"";
  
 export function game<UState>(
  
  canvas: HTMLCanvasElement,
  
  eventElement: HTMLElement,
  
  fps: number,
  
  state: UState,
  
  drawState: (state: UState, width: number, height: number) => Picture, timeHandler: (state: UState) 
 => UState = x => x,
  
  eventHandler: (state: UState, event: KeyEvent) => UState) {
  
 With 
 createEventSource
 , which we have written before, we can get an event source for the 
 specified element:
  
  const eventSource = createEventSource(eventElement);
  
 To set up drawing, we must acquire the rendering context:",NA
Drawing on the canvas,"In 
 lib/framework/draw.ts
 , we will implement the 
 drawPicture
  function that we created 
 before. Using 
 instanceof
  we can check which kind of picture we must draw.
  
 We will interpret the location of an object as the center of it. Thus, 
 new Rectangle(10, 10, 100, 
 100)
  will draw a rectangle around 10,10. We can draw the outline of a rectangle or the whole 
 rectangle with 
 strokeRect
  and 
 fillRect
 :
  
 import { Picture, Rectangle, RectangleOutline, Circle, CircleOutline, Line, Text, Color, Translate, Rotate, 
 Scale, Pictures, Path } from ""./picture"";
  
 export function drawPicture(context: CanvasRenderingContext2D, item: Picture) {
  
  context.save();
  
  if (item instanceof RectangleOutline) {
  
   
  const { x, y, width, height, thickness } = item;
  
   
  context.strokeRect(x - width / 2, y - height / 2, width, height); } else if (item instanceof 
 Rectangle) {
  
   
  const { x, y, width, height } = item;
  
   
  context.fillRect(x - width / 2, y - height / 2, width, height);
  
 To draw a circle, we use the arc function. That function does not draw the circle itself, but 
 only registers its path. We can draw the line or fill it using stroke or fill. We must wrap 
 arc 
 with 
 beginPath
  and 
 closePath
  to do that:
  
  } else if (item instanceof CircleOutline || item instanceof Circle) {
  
  const { x, y, width, height } = 
 item;
  
  
  if (width !== height) {
  
   
  context.scale(1, height / width);
  
  
  }
  
  
  context.beginPath();
  
  
  context.arc(x, y, width / 2, 0, Math.PI * 2);
  
  
  context.closePath();
  
  
  if (item instanceof CircleOutline) {
  
   
  context.lineWidth = item.thickness;",NA
Adding utility functions,"We will write several utility functions in 
 lib/game/utils.ts
 . With 
 flatten
 , we will 
 transform an array of arrays into one array.
  
 export function flatten<U>(source: U[][]): U[] { return 
 (<U[]>[]).concat(...source); 
  
 }
  
 With update, we can modify some properties of an object. This is the same function as in 
 previous chapters.
  
 export function update<U extends V, V>(old: U, changes: V): U { const result = 
 Object.create(Object.getPrototypeOf(old)); for (const key of Object.keys(old)) {
  
   
  result[key] = (<any> old)[key];
  
  }
  
  for (const key of Object.keys(changes)) {
  
   
  result[key] = (<any> changes)[key];",NA
Creating the models,"In 
 lib/game/model.ts
 , we will create the models for the game. These models will contain the 
 state of the game, such as the location of the enemies, walls, and dots. The state must also 
 contain the current movement of the player and the difficulty level, as the game will have 
 multiple difficulties.",NA
Using enums,"We start with several enums. We can store the difficulty with such an 
 enum
 :
  
 export enum Difficulty {
  
  Easy,
  
  Hard,
  
  Extreme 
  
 }
  
 The values of an 
 enum
  are converted to numbers during compilation. TypeScript gives the 
 first element zero as the value, the next item one, and so on. In this example, 
 Easy
  is 0, 
 Hard 
 is 1, and 
 Extreme
  is 2. However, you can also provide other values. For some applications, 
 this can be useful. We will use custom values to define 
 Movement
 . This enum contains the 
 four directions in which the player can move. In case the user does not move, we use 
 None
 .
  
 We give the members a value:
  
 export enum Movement {
  
  None = 0,
  
  Left = 1,
  
  Right = -1,
  
  Top = 2,
  
  Bottom = -2 
  
 }
  
 With these values, we can easily create a function that checks whether two movements are 
 in the opposite direction: their sum should equal zero:
  
 export function isOppositeMovement(a: Movement, b: Movement) { return a + b === 0; 
  
 }
  
 Other useful patterns that are often used are bitwise values. A number is stored in a 
 computer as multiple bits. For instance, 00000011 (binary) equals 3 (decimal). You can 
 calculate the decimal value of a binary number as follows. The first position from the right 
 has value 1. The next has value 2, then 4, 8, and so on. Summing the values of the positions 
 with a one results in the decimal value.
  
 You can use this binary representation to store multiple Booleans in a number. 00000011 
 would then mean that the first two values are true, and the other values are 0. We use an 
 enum
  to define the names of these properties. 
 <<
 is the bitwise shift operator. 
 1 << x
  means 
 that 
 00000001
  is shifted 
 x
  bits to the left. For instance, 
 1 << 4
  results in 
 00010000
 :",NA
Storing the level,"Now, we will define a model that can store the state of a level. A level contains several 
 objects that are placed in a certain location:
  
 export interface Object {
  
  x: number;
  
  y: number; 
  
 }",NA
Creating the default level,"We will write a function that can parse a level, based on a string. This allows us to create the 
 level as follows:
  
 const defaultLevel = parseLevel([
  
  ""WWWWWWWWWWWWWWW"",
  
  ""W....E........W"",
  
  ""W.WWWWW.WWWWW.W"",
  
  ""W.W...W.W...W.W"",
  
  ""WE..W.....W...W"",
  
  ""W.W...W.W...W.W"",
  
  ""W.WWWWW.WWWWW.W"",
  
  ""W.............W"",",NA
Creating the state,"We store the state in a new interface. We will also define the default state for our game:
  
 export interface State {
  
  level: Level; 
  
 } 
  
 export const defaultState: State = {
  
  level: defaultLevel 
  
 };
  
 This interface is, at the moment, not very useful as you might be better off using the 
 Level 
 as the game state. However, later on in this chapter, we will also add a menu that should 
 exist in the state.",NA
Drawing the view,"In 
 lib/game/view.ts
 , we will render the game. We start with importing types that we 
 defined earlier:
  
 import { State, Level, Object, Wall, Side, Menu } from ""./model""; import { Picture, Pictures, 
 Translate, Scale, Rotate, Rectangle, Line, Circle, Color, Text, Empty } from ""../framework/picture"";
  
 We will store the font name in a variable, so we can easily change it later:
  
 const font = ""Arial"";
  
 In draw, we will render the game. For now, that means only drawing the level. Later on, we 
 will add a menu to the game:
  
 export function draw(state: State, width: number, height: number) { drawLevel(state.level, 
 width, height), 
  
 }
  
 We render the level in 
 drawLevel
 . We calculate the size of all objects with the size of the 
 grid and the canvas:
  
 function drawLevel(level: Level, width: number, height: number) {
  
  const scale = Math.min(width / (level.width + 1), height / (level.height + 1));
  
 We 
 scale
  and 
 center
  the whole level with this calculated scale:
  
  return new Scale(scale, scale,
  
   
  new Translate(-level.width / 2 + 0.5, -level.height / 2 + 0.5, new Pictures([
  
 Next, we draw all objects on the canvas. We use several functions that we create as follows:
  
   
  drawObjects(level.walls, drawWall),
  
   
  drawObjects(level.walls, drawWallLines),
   
  
 drawObjects(level.dots, drawDot),
  
   
  drawObjects(level.enemies, drawEnemy),
   
  
 drawObject(drawPlayer)(level.player)
  
  ]))
  
  );
  
 [ 200 ]",NA
Handling events,"We will create an event handler in 
 lib/game/event.ts
 . The event handler must set the correct 
 movement direction in the state. The time handler will then use this to update the 
 direction of the player. The step can only do that when the player is aligned to the grid. If 
 the player is between two fields on the grid, we will not change the direction of the player, 
 since he will then probably head into a wall.",NA
Working with key codes,"An event provides the key code of the pressed or released key. We can get this code of a 
 certain character with 
 ""x"".charCodeAt(0)
  (where 
 x
  is the character). The key codes of left, 
 top, right, and bottom are 37, 38, 39, and 40.
  
 First, we must create a helper function that transforms a key code to the Movement 
 enum 
 that we defined earlier. We store the different keys that we use in a new 
 enum
 :
  
 import { KeyEvent, KeyEventKind } from ""../framework/event""; import { State, 
 Movement } from ""./model""; 
  
 import { update } from ""./utils"";
  
 enum Keys {
  
  Top = 38,
  
  Left = 37,
  
  Bottom = 40,
  
  Right = 39,
  
  Space = "" "".charCodeAt(0) 
  
 }",NA
Creating the time handler,"The time handler requires some more work. First, we import other types and functions.
  
 import { State, Level, Object, Enemy, Wall, Movement, isOppositeMovement, onGrid, Difficulty } from 
 ""./model""; 
  
 import { update, randomInt, chance, distance, isInt } from ""./utils"";
  
 We define a 
 step
  function so that we can add the 
 menu
  later on.
  
 export function step(state: State) {
  
  return stepLevel(state); 
  
 }
  
 In 
 stepLevel
 , we can update the objects in the level. First, we update the location of the 
 enemies. We use 
 stepEnemy
 , which we define later on.
  
 function stepLevel(state: State): State {
  
  const level = state.level;
  
  const enemies = level.enemies.map(enemy => stepEnemy(enemy, level.player, level.walls, 
 level.difficulty));
  
 We update the location of the player based on the current movement:
  
  const player = stepPlayer(level.player, level.currentMovement, level.walls);
  
 Dots that are near the player, are eaten by the player and removed from the level:
  
  const dots = stepDots(level.dots, player);
  
 We change the current movement if the player is aligned on the grid or when they wants to 
 move in the opposite direction:
  
  const currentMovement = onGrid(player) || 
  
 isOppositeMovement(level.inputMovement, level.currentMovement) ?
  
 level.inputMovement : level.currentMovement;",NA
Running the game,"To start the game, we must call the 
 game
  function with the default state, draw function, 
 time handler, and event handler. In 
 lib/game/index.ts
 , we write the following code to start 
 the game:
  
 import { game } from ""../framework/game""; import { 
 defaultState } from ""./model""; import { draw } from 
 ""./view""; 
  
 import { step } from ""./step""; 
  
 import { eventHandler } from ""./event"";
  
 const canvas = <HTMLCanvasElement> document.getElementById(""game""); game(canvas, 
 document.body, 60, defaultState, draw, step, eventHandler);
  
 We can compile the game by executing 
 gulp
 . You can play the game by opening 
 static/index.html
 .
  
 As you will see, nothing happens when you have eaten all of the dots, or when you get hit 
 by an enemy. In the next section, we will implement a menu. When the player wins or loses, 
 we will show this menu.",NA
Adding a menu,"To finish off the game, we will add some menus to it. In the main menu, the user can choose 
 a difficulty. The user can select an option using the arrow keys and confirm using the 
 spacebar. The menu will look like this:
  
  
 To implement the menu, we must add it to the state. Then we can render the menu and 
 update the menu state in the event handler. We start by updating the state.",NA
Changing the model,"In 
 lib/game/model.ts
 , we will add the menus to the state. First, we will create a new type 
 for the menu. The menu contains a title, a list of options, and the index of the selected 
 button. Each option has a string and a function that applies the action by transforming the 
 state:
  
 export interface Menu {
  
  title: string;
  
  options: [string, (state: State) => State][]; selected: number; 
  
 }
  
 [ 210 ]",NA
Rendering the menu,"We must update 
 lib/game/view.ts
  to draw the menu on the canvas. We change the draw 
 function:
  
 export function draw(state: State, width: number, height: number) { return new Pictures([
  
   
  drawLevel(state.level, width, height),
  
   
  drawMenu(state.menu, width, height)
  
  ]); 
  
 }
  
 Next, we create 
 drawMenu
 , that will render the level. It will show the title and the buttons. 
 The selected button gets a different color:
  
 function drawMenu(menu: Menu | undefined, width: number, height: number): Picture {
  
  
  if (menu === undefined) return new Empty();
  
  
  const selected = menu.selected;
  
  
  const background = new Color(""rgba(40,40,40,0.8)"", new
  
  
  Rectangle(0, 0, width, height));
  
  
  const title = new Translate(0, 200, new Scale(4, 4,
  
  
  
  new Color(""#fff"", new Text(menu.title, font))
  
  
  ));
  
  
  const options = new Pictures(menu.options.map(showOption));
  
  return new Pictures([background, title, options]);
  
  function showOption(item: [string, (state: State) => State], index: number) {
  
  const isSelected = index === selected;
  
  return new Translate(0, 100 - index * 50, new Pictures([
  
  new Color(isSelected ? 
 ""#ff0000"" : ""#000000"",
  
  
  
  new Rectangle(0, 0, 200, 40)),
  
  
  new Color(isSelected ? ""#000000"" : ""#ffffff"",
  
  
  
  new Scale(1.6, 1.6, new Text(item[0], font)))",NA
Handling events,"In 
 lib/game/event.ts
 , we will handle the events for the menu. We must update the index of 
 the selected item when the user presses the up or down key. When the user presses space, 
 we execute the action of the selected button. First, we must adjust 
 eventHandler
  to call 
 eventHandlerMenu
  when the menu is visible.
  
 export function eventHandler(state: State, event: KeyEvent) { if (state.menu) {
  
   
  return eventHandlerMenu(state, event);
  
  } else {
  
   
  return eventHandlerPlaying(state, event);
  
  } 
  
 }
  
 Next, we create 
 eventHandlerMenu
 .
  
 function eventHandlerMenu(state: State, event: KeyEvent) {
  
  if (event instanceof KeyEvent && event.kind === KeyEventKind.Press) { const menu = state.menu!;
  
  let selected = menu.selected;
  
  switch (event.keyCode) {
  
  
  case Keys.Top:
  
  
  
  selected--;
  
  
  
  if (selected < 0) {
  
  
  
  
  
  selected = menu.options.length - 1;
  
  
  
  }
  
  
  
  return {
  
  
  
  
  
  menu: update(menu, {
  
  
  
  
  
  
  selected
  
  
  
  
  
  }),
  
  
  
  
  
  level: state.level
  
  
  
  };
  
  
  case Keys.Bottom:
  
  
  
  selected++;
  
  
  
  if (selected >= menu.options.length) {
  
  
  
  
  
  selected = 0;
  
  
  
  }",NA
Modifying the time handler,"In 
 lib/game/step.ts
 , we must show the menu when the user won or lost. We must 
 change the import-statement to import 
 menuLost
  and 
 menuWon
  from model:
  
 import { State, Level, Object, Enemy, Wall, Movement, isOppositeMovement, menuLost, menuWon, 
 onGrid, Difficulty } from ""./model"";
  
 In 
 newMenu
 , we check whether such a menu should be shown.
  
 function newMenu(player: Object, dots: Object[], enemies: Enemy[]) { for (const enemy of 
 enemies) {
  
   
  if (distance(enemy.x, enemy.y, player.x, player.y) <= 1) {
   
  
  return 
 menuLost;
  
   
  }
  
  }
  
  if (dots.length === 0) return menuWon;
  
  return undefined; 
  
 }
  
 In 
 stepLevel
 , we must call this function.
  
 function stepLevel(state: State): State {
  
  const level = state.level;
  
  const enemies = level.enemies.map(enemy => stepEnemy(enemy, level.player,",NA
Summary,"In this chapter, we have explored the HTML canvas. We have seen how we can design a 
 framework to use functional programming. The framework provides abstraction around 
 drawing on the canvas, which is not pure.
  
 We have built the game Pac Man. The structure of this application was similar to a Flux 
 architecture, like we saw in the previous chapter.
  
 The enemies in this game are not very smart. They easily get stuck behind a wall. In the next 
 chapter, we will take a look at another game, but we will only focus on the artificial 
 intelligence (AI). We will create an application that can play Tic-Tac-Toe without losing. We 
 will see how a Minimax strategy works and how we can implement it in TypeScript.",NA
Playing Tic-Tac-Toe against an ,NA,NA
,NA,NA
AI,"We built the game Pac Man in the previous chapter. The enemies were not very smart; you 
 can easily fool them. In this chapter, we will build a game in which the computer will play 
 well. The game is called 
 Tic-Tac-Toe
 . The game is played by two players on a grid, usually 
 three by three. The players try to place their symbols three in a row (horizontal, vertical or 
 diagonal). The first player can place crosses, the second player places circles. If the board is 
 full, and no one has three symbols in a row, it is a draw.
  
 The game is usually played on a three-by-three grid and the target is to have three symbols 
 in a row. To make the application more interesting, we will make the dimension and the 
 row length variable.
  
 We will not create a graphical interface for this application, since we have already done that 
 in
  Chapter 6
 , 
 Advanced Programming in TypeScript
 . We will only build the game mechanics and 
 the 
 artificial intelligence
  (
 AI
 ). An AI is a player controlled by the computer. If 
 implemented correctly, the computer should never lose on a standard three by three grid. 
 When the computer plays against the computer, it will result in a draft. We will also write 
 various unit tests for the application.
  
 We will build the game as a command-line application. That means you can play the game 
 in a terminal. You can interact with the game only with text input:
  
 It's player one's turn!
  
 Choose one out of these options: 
  
 1   X|X|
  
  
  -+-+-",NA
Creating the project structure,"We will locate the source files in 
 lib
  and the tests in 
 lib/test
 . We use 
 gulp
  to compile the 
 project and 
 AVA
  to run tests. We can install the dependencies of our project with NPM:
  
 npm init -y 
  
 npm install ava gulp gulp-typescript --save-dev
  
 In 
 gulpfile.js
 , we configure 
 gulp
  to compile our TypeScript files:
  
 var gulp = require(""gulp""); 
  
 var ts = require(""gulp-typescript"");
  
 var tsProject = ts.createProject(""./lib/tsconfig.json"");
  
 gulp.task(""default"", function() {
  
  return tsProject.src()
  
   
  .pipe(ts(tsProject))
  
   
  .pipe(gulp.dest(""dist"")); 
  
 });",NA
Configure TypeScript,"We can download type definitions for NodeJS with NPM:
  
 npm install @types/node --save-dev
  
 We must exclude browser files in TypeScript. In 
 lib/tsconfig.json
 , we add the 
 configuration for TypeScript:
  
 {
  
  ""compilerOptions"": {
  
   
  ""target"": ""es6"",
  
   
  ""module"": ""commonjs""
  
  }
  
 }
  
 For applications that run in the browser, you will probably want to target ES5, since ES6 is 
 not supported in all browsers. However, this application will only be executed in NodeJS, 
 so we do not have such limitations. You have to use NodeJS 6 or later for ES6 support.",NA
Adding utility functions,"Since we will work a lot with arrays, we can use some utility functions. First, we create a 
 function that flattens a two dimensional array into a one dimensional array:
  
 export function flatten<U>(array: U[][]) { return 
 (<U[]>[]).concat(...array); 
  
 }
  
 Next, we create a 
 function
  that replaces a single element of an 
 array
  with a specified 
 value. We will use functional programming in this chapter again, so we must use 
 immutable data structures. We can use map for this, since this function provides both the 
 element and the index to the callback. With this 
 index
 , we can determine whether that 
 element should be replaced:
  
 export function arrayModify<U>(array: U[], index: number, newValue: U) { return 
 array.map((oldValue, currentIndex) =>
  
   
  currentIndex === index ? newValue : oldValue); 
  
 }
  
 We also create a function that returns a random integer under a certain upper bound:
  
 export function randomInt(max: number) { return 
 Math.floor(Math.random() * max); }
  
 We will use these functions in the next sessions.",NA
Creating the models,"In 
 lib/model.ts
 , we will create the model for our game. The model should contain the 
 game state.
  
 We start with the player. The game is played by two players. Each field of the grid contains 
 the symbol of a player or no symbol. We will model the grid as a two dimensional array, 
 where each field can contain a player:
  
 export type Grid = Player[][];
  
 A player is either 
 Player1
 , 
 Player2
 , or no player:
  
 export enum Player {
  
  Player1 = 1,
  
  Player2 = -1,",NA
Showing the grid,"To show the game to the user, we must convert a grid to a string. First, we will create a 
 function that converts a player to a string, then a function that uses the previous function to 
 show a row, finally a function that uses these functions to show the complete grid.
  
 The string representation of a grid should have lines between the fields. We create these 
 lines with standard characters (
 +
 , 
 -
 , and 
 |
 ). This gives the following result:
  
 X|X|O
  
 -+-+-
  
  |O|
  
 -+-+-
  
 X| |",NA
Creating operations on the grid,"We will now create some functions that do operations on the grid. These functions check 
 whether the board is full, whether someone has won, and what options a player has.
  
 We can check whether the board is full by looking at all fields. If no field exists that has no 
 symbol on it, the board is full, as every field has a symbol:
  
 export function isFull(grid: Grid) {
  
  for (const row of grid) {
  
   
  for (const field of row) {
  
    
  if (field === Player.None) return false;
  
  
  }
  
  }
  
  return true; 
  
 }
  
 To check whether a user has won, we must get a list of all horizontal, vertical and diagonal 
 rows. For each row, we can check whether a row consists of a certain amount of the same 
 symbols on a row. We store the grid as an array of the horizontal rows, so we can easily get 
 those rows. We can also get the vertical rows relatively easily:
  
 function allRows(grid: Grid) {
  
  return [
  
   
  ...grid,
  
   
  ...grid[0].map((field, index) => getVertical(index)),
  
  
  ...
  
  ];
  
  function getVertical(index: number) {
  
   
  return grid.map(row => row[index]);
  
  } 
  
 }
  
 Getting a diagonal row requires some more work. We create a helper function that will 
 walk on the 
 grid
  from a start point, in a certain direction. We distinguish two different 
 kinds of diagonals: a diagonal that goes to the lower-right and a diagonal that goes to the 
 lower-left.
  
 For a standard three by three game, only two diagonals exist. However, a larger grid may 
 have more diagonals. If the grid is 5 by 5, and the users should get three in a row, ten 
 diagonals with a length of at least three exist:
  
 1. 0, 0 to 4, 4
  
 2. 0, 1 to 3, 4
  
 3. 0, 2 to 2, 4",NA
Creating the grid,"Before the game can be started, we must create an empty grid. We will write a function that 
 creates an empty grid with the specified size:
  
 export function createGrid(width: number, height: number) { const grid: Grid = [];
  
  for (let i = 0; i < height; i++) {
  
   
  grid[i] = [];
  
   
  for (let j = 0; j < width; j++) {
  
    
  grid[i][j] = Player.None;
  
   
  }
  
  }
  
  return grid; 
  
 }
  
 In the next section, we will add some tests for the functions that we have written. These 
 functions work on the grid, so it will be useful to have a function that can parse a grid based 
 on a string.",NA
Adding tests,"Just like in 
 Chapter 5
 , 
 Native QR Scanner App
 , we will use AVA to write tests for our 
 application. Since the functions do not have side effects, we can easily test them.
  
 In 
 lib/test/winner.ts
 , we test the 
 findWinner
  function. First, we check whether the function 
 recognizes the winner in some simple cases:
  
 import test from ""ava""; 
  
 import { Player, parseGrid, findWinner } from ""../model"";
  
 test(""player winner"", t => {
  
  t.is(findWinner(parseGrid(""   ;XXX;   ""), 3), Player.Player1); t.is(findWinner(parseGrid(""   
 ;OOO;   ""), 3), Player.Player2); t.is(findWinner(parseGrid(""   ;   ;   ""), 3), Player.None); });",NA
Random testing,"Instead of running the test on some predefined set of test cases, you can also write tests that 
 run on random data. You cannot compare the output of a function directly with an expected 
 value, but you can check some properties of it. For instance, 
 getOptions
  should return an 
 empty list if and only if the board is full. We can use this property to test 
 getOptions
  and 
 isFull
 .
  
 First, we create a function that randomly chooses a player. To higher the chance of a full 
 grid, we add some extra weight on the players compared to an empty field:
  
 import test from ""ava""; 
  
 import { createGrid, Player, isFull, getOptions } from ""../model""; import { randomInt } from 
 ""../utils"";
  
 function randomPlayer() {
  
  switch (randomInt(4)) {
  
   
  case 0:
  
   
  case 1:
  
    
  return Player.Player1;
  
   
  case 2:
  
   
  case 3:
  
    
  return Player.Player2;
  
   
  default:
  
    
  return Player.None;
  
  } 
  
 }",NA
Implementing the AI using Minimax,"We create an AI based on 
 Minimax
 . The computer cannot know what his opponent will do 
 in the next steps, but he can check what he can do in the worst-case. The minimum outcome 
 of these worst cases is maximized by this algorithm. This behavior has given Minimax its 
 name.
  
 To learn how Minimax works, we will take a look at the value or score of a grid. If the game 
 is finished, we can easily define its value: if you won, the value is 1; if you lost, -1 and if it is 
 a draw, 0. Thus, for player 1 the next grid has value 1 and for player 2 the value is -1:
  
 X|X|X
  
 -+-+-
  
 O|O|
  
 -+-+-
  
 X|O|
  
 We will also define the value of a grid for a game that has not been finished. We take a look 
 at the following grid:
  
 X| |X
  
 -+-+-
  
 O|O|
  
 -+-+-
  
 O|X|
  
 It is player 1's turn. He can place his stone on the top row, and he would win, resulting in a 
 value of 1. He can also choose to lay his stone on the second row. Then the game will result 
 in a draft, if player 2 is not dumb, with score 0. If he chooses to place the stone on the last 
 row, player 2 can win resulting in -1. We assume that player 1 is smart and that he will go 
 for the first option. Thus, we could say that the value of this unfinished game is 1.
  
 We will now formalize this. In the previous paragraph, we have summed up all options for 
 the player. For each option, we have calculated the minimum value that the player could get 
 if he would choose that option. From these options, we have chosen the maximum value.
  
 Minimax chooses the option with the highest value of all options.",NA
Implementing Minimax in TypeScript,"As you can see, the definition of Minimax looks like you can implement it with recursion. 
 We create a function that returns both the best option and the value of the game. A function 
 can only return a single value, but multiple values can be combined into a single value in a 
 tuple, which is an array with these values.
  
 First, we handle the base cases. If the game is finished, the player has no options and the 
 value can be calculated directly:
  
 import { Player, Grid, findWinner, isFull, getOpponent, getOptions } from ""./model"";
  
 export function minimax(grid: Grid, rowLength: number, player: Player): [Grid, number] {
  
  const winner = findWinner(grid, rowLength);
  
  if (winner === player) {
  
   
  return [undefined, 1];
  
  } else if (winner !== Player.None) {
  
   
  return [undefined, -1];
  
  } else if (isFull(grid)) {
  
   
  return [undefined, 0];
  
 Otherwise, we list all options. For all options, we calculate the value. The value of an option 
 is the same as the opposite of the value of the option for the opponent. Finally, we choose 
 the option with the best value:
  
  } else {
  
   
  let options = getOptions(grid, player);
  
   
  const opponent = getOpponent(player);
  
   
  return options.map<[Grid, number]>(
  
    
  option => [option, -(minimax(option, rowLength, opponent)[1])]
  
  
  ).reduce(
  
    
  (previous, current) => previous[1] < current[1] ? current : previous
  
  
  )!;
  
  } 
  
 }
  
 When you use tuple types, you should explicitly add a type definition for it. Since tuples are 
 arrays too, an array type is automatically inferred. When you add the tuple as return type, 
 expressions after the return keyword will be inferred as these tuples. For options.map, you 
 can mention the union type as a type argument or by specifying it in the callback function 
 (
 options.map((option): [Grid, number] => ...);
 ).
  
 [ 231 ]",NA
Optimizing the algorithm,"The Minimax algorithm can be slow. Choosing the first set, especially, takes a long time 
 since the algorithm tries all ways of playing the game. We will use two techniques to speed 
 up the algorithm.
  
 First, we can use the symmetry of the game. When the board is empty it does not matter 
 whether you place a stone in the upper-left corner or the lower-right corner. Rotating the 
 grid around the center 180 degrees gives an equivalent board. Thus, we only need to take a 
 look at half the options when the board is empty.
  
 Secondly, we can stop searching for options if we found an option with value 1. Such an 
 option is already the best thing to do.
  
 Implementing these techniques gives the following function:
  
 import { Player, Grid, findWinner, isFull, getOpponent, getOptions } from ""./model"";
  
 export function minimax(grid: Grid, rowLength: number, player: Player): [Grid, number] {
  
  const winner = findWinner(grid, rowLength);
  
  if (winner === player) {
  
   
  return [undefined, 1];
  
  } else if (winner !== Player.None) {
  
   
  return [undefined, -1];
  
  } else if (isFull(grid)) {
  
   
  return [undefined, 0];
  
  } else {
  
   
  let options = getOptions(grid, player);
  
   
  const gridSize = grid.length * grid[0].length;
  
   
  if (options.length === gridSize) {
  
    
  options = options.slice(0, Math.ceil(gridSize / 2));
  
   
  }
  
   
  const opponent = getOpponent(player);
  
   
  let best: [Grid, number] | undefined = undefined;
  
   
  for (const option of options) {
  
    
  const current: [Grid, number] = [option, -(minimax(option, rowLength, opponent)[1])];
  
    
  if (current[1] === 1) {
  
     
  return current;",NA
Creating the interface,"NodeJS
  can be used to create servers, as we did in chapters 2 and 3. You can also create 
 tools with a 
 command line interface (CLI).
  For instance, gulp, NPM and typings are 
 command line interfaces built with NodeJS. We will use NodeJS to create the interface for 
 our game.",NA
Handling interaction,"The interaction from the user can only happen by text input in the terminal. When the game 
 starts, it will ask the user some questions about the configuration: width, height, row length 
 for a sequence, and the player(s) that are played by the computer. The highlighted lines are 
 the input of the user:
  
 Tic-Tac-Toe
  
 Width 
  
 3 
  
 Height 
  
 3 
  
 Row length 
  
 2 
  
 Who controls player 1?
  
 1  You
  
 2  Computer
  
 1 
  
 Who controls player 2?
  
 1  You",NA
Creating players,"A player could either be a human or the computer. We create a type that can contain both 
 kinds of players.
  
 type PlayerController = (grid: Grid) => Grid | Promise<Grid>;
  
 Next we create a function that creates such a player. For a user, we must first know whether 
 he is the first or the second player. Then we return an async function that asks the player 
 which step he wants to do.
  
 const getUserPlayer = (player: Player) => async (grid: Grid) => { const options = 
 getOptions(grid, player);
  
  const index = await choose(""Choose one out of these options:"", options.map(showGrid));
  
  return options[index]; 
  
 };
  
 For the AI player, we must know the player index and the length of a sequence. We use 
 these variables and the grid of the game to run the Minimax algorithm.
  
 const getAIPlayer = (player: Player, rowLength: number) => (grid: Grid) => minimax(grid, rowLength, 
 player)[0]!;
  
 Now we can create a function that asks the player whether a player should be played by the 
 user or the computer.
  
 async function getPlayer(index: number, player: Player, rowLength: number): Promise<PlayerController> {
  
  switch (await choose(`Who controls player ${ index }?`, [""You"", 
  
 ""Computer""])) {
  
   
  case 0:
  
    
  return getUserPlayer(player);
  
   
  default:
  
    
  return getAIPlayer(player, rowLength);
  
  } 
  
 }",NA
Testing the AI,"We will add some tests to check that the AI works properly. For a standard three by three 
 game, the AI should never lose. That means when an AI plays against an AI, it should result 
 in a draw. We can add a test for this. In 
 lib/test/ai.ts
 , we import AVA and our own 
 definitions.
  
 import test from ""ava""; 
  
 import { createGrid, Grid, findWinner, isFull, getOptions, Player } from ""../model""; 
  
 import { minimax } from ""../ai""; 
  
 import { randomInt } from ""../utils"";
  
 We create a function that simulates the whole gameplay.
  
 type PlayerController = (grid: Grid) => Grid; 
  
 function run(grid: Grid, a: PlayerController, b: PlayerController): Player {
  
  const winner = findWinner(grid, 3);
  
  if (winner !== Player.None) return winner;
  
 [ 238 ]",NA
Testing with a random player,"We can also test what happens when the AI plays against a random player or when a player 
 plays against the AI. The AI should win or it should result in a draw. We run these multiple 
 times; what you should always do when you use randomization in your test.
  
 We create a function that creates the random player.
  
 const randomPlayer = (player: Player) => (grid: Grid) => { const options = 
 getOptions(grid, player);
  
  return options[randomInt(options.length)]; 
  
 };
  
 We write the two tests that both run 
 20
  games with a random player and an 
 AI
 .
  
 test(""random vs AI"", t => {
  
  for (let i = 0; i < 20; i++) {
  
   
  const result = run(createGrid(3, 3), randomPlayer(Player.Player1), aiPlayer(Player.Player2))
  
   
  t.not(result, Player.Player1);
  
  } 
  
 });
  
 test(""AI vs random"", t => {
  
  for (let i = 0; i < 20; i++) {
  
   
  const result = run(createGrid(3, 3), aiPlayer(Player.Player1), 
 randomPlayer(Player.Player2))
  
   
  t.not(result, Player.Player2);",NA
Summary,"In this chapter, we have written an AI for Tic-Tac-Toe. With the command line interface, 
 you can play this game against the AI or another human. You can also see how the AI plays 
 against the AI. We have written various tests for the application.
  
 You have learned how Minimax works for turn-based games. You can apply this to other 
 turn-based games as well. If you want to know more on strategies for such games, you can 
 take a look at game theory, the mathematical study of these games.
  
 Reading this means that you have finished the Functional Programming part of this book. 
 One chapter remains, which will explain how you can migrate a legacy JavaScript code base 
 to TypeScript.",NA
Migrate JavaScript to ,NA,NA
,NA,NA
TypeScript,"In the previous chapters, we have built new applications in TypeScript. However, you 
 might also have old code bases in JavaScript which you want to migrate to TypeScript. We 
 will see how these projects can be converted to TypeScript.
  
 You could rewrite the whole project from scratch, but that would require a lot of work for 
 big projects. Since TypeScript is based on JavaScript, this transition can be done more 
 efficiently.
  
 Since the migration process is dependent on the project, this chapter can only give 
 guidance. For various common topics, this chapter contains a recipe to migrate code. 
 Migrating a project requires knowledge of the frameworks and the structure of the project.
  
 The following steps are related to migrating a code base:
  
 Gradually migrating to TypeScript
  
 Adding TypeScript
  
 Migrating each file
  
 Refactoring the project",NA
Gradually migrating to TypeScript,"As of TypeScript 1.8, it is possible to combine JavaScript and TypeScript in the same project. 
 Thus, you can migrate a project file by file.",NA
Adding TypeScript,"Before you can convert JavaScript files to TypeScript, you must add the TypeScript compiler 
 to a project. If the project already uses a build step, the TypeScript compiler must be 
 integrated into the build step. Otherwise, a new build step must be created. In the following 
 sections, we will set up TypeScript and the build system.",NA
Configuring TypeScript,"In all cases, you should start with configuring TypeScript. This configuration will be used 
 by code editors and the build tool. The most important setting is 
 allowJs
 . This setting 
 allows JavaScript files in the TypeScript project. Other important options are target and 
 module. For target, you can choose between 
 es3
 , 
 es5
 , and 
 es2015
 . The latest version of 
 JavaScript, 
 es2015
 , is not supported in all browsers at the time of writing. You can target 
 es2015
  when you write an application for NodeJS. You can target 
 es5
  for browsers. For 
 very old environments, you must target 
 es3
 .
  
 If the project uses external modules, you should also set the 
 module
  setting. If your project 
 uses 
 CommonJS
 , mostly used in combination with NodeJS, browserify or webpack, you 
 should use 
 ""module"": ""commonjs""
 . An import in CommonJS can be recognized by a call to 
 require and an export by an assignment to 
 exports.[...]
  or 
 module.exports
 , and files are not 
 wrapped in a 
 define
  function:
  
 var path = require(""path"");",NA
Configuring the build tool,"Configuring the build depends on the build tool you use. For a few commonly used tools, 
 you can find the steps here. Most build tools require you to install a TypeScript plugin. For 
 browserify, you must install 
 tsify
  using NPM; for Grunt, 
 grunt-ts
 ; for gulp, 
 gulp-typescript
 ; 
 and for webpack, 
 ts-loader
 . If your project uses JSPM, you do not have to install a plugin.
  
 You can find various configurations with these tools at: 
 http://www.typescriptlang.org 
 /docs/handbook/integrating-with-build-tools.html
 . If you use a different build tool, you should 
 look in the documentation of the tool and search for a TypeScript plugin.
  
 Since TypeScript accepts (and needs) the JavaScript files in your project, you must provide 
 all source files to the TypeScript compiler. For gulp, that would mean that you add 
 TypeScript before other compilation steps. Imagine a task in your 
 gulp
  file looks like this:
  
 gulp.src(""lib/**/*.js"")
  
  .pipe(plugin())
  
  .pipe(gulp.dist(""dest""));
  
 You can add TypeScript to this 
 gulp
  file:
  
 var ts = require(""gulp-typescript""); 
  
 var tsProject = ts.createProject(""lib/tsconfig.json""); ...
  
 gulp.src(""lib/**/*.js"")
  
  .pipe(ts(tsProject))
  
  .pipe(plugin())
  
  .pipe(gulp.dist(""dest""));
  
 For a build tool that cannot store temporary files in memory, such as Grunt, you should 
 compile TypeScript to a temporary directory. Other steps from the build should read the 
 sources from this directory.
  
 For more information on how to configure a specific build tool, you can look at the 
 documentation of the tool and the plugin.",NA
Acquiring type definitions,"For dependencies that you use, such as jQuery, you must acquire type definitions. You can 
 install them using 
 npm.
  You can find these type definitions on 
 https://aka.ms/types
 .",NA
Testing the project,"Before going to the next step, make sure that the build is working. TypeScript should only 
 show syntax errors in JavaScript files. Also, the application should be working at runtime.
  
 If you are now using TypeScript to transpile ES modules to CommonJS, 
 you might run into problems. Babel and TypeScript handle default 
  
 imports differently. Babel looks for the default property, and if that does 
 not exist, it behaves the same as a full module import. TypeScript will only 
 look for the default property. If you get runtime errors after the migration, 
 you might need to replace a default import (
 import name from 
  
 ""package""
 ) with a full module import (
 import * as name from ""package""
 ).",NA
Migrating each file,"When the build system is set up, you can start with migrating files. It is easiest to start with 
 files that do not depend on other files, as these do not depend on types of other files. To 
 migrate a file, you must rename the file extension to 
 .ts
 , convert the module format to ES 
 modules, correct types that are inferred incorrectly, and add types to 
 untyped
  entities. In the 
 next sections, we will take a look at these tasks.",NA
Converting to ES modules,"In TypeScript files you cannot use CommonJS or AMD directly. Instead you must use ES 
 modules, like we did in the previous chapters. For an import, you must choose from these:
  
 import * as name from ""package""
 , imports the whole package, similar to 
  
 var 
 name = require(""package"")
  in CommonJS.
  
 import name from ""package""
 , imports the default export, similar to 
 var 
  
 name = require(""package"").default
 .
  
 import { name } from ""package""
 , imports a named export, similar to 
 var 
  
 name = require(""package"").name
 .",NA
Correcting types,"Since the file was a JavaScript file, it does not have any type annotations. At some 
 locations, TypeScript will infer types for variables. When you declare a variable and 
 directly assign to it, TypeScript will infer the type based on the type of the assignment. 
 Thus, when you write 
 let x = """"
 , TypeScript will type 
 x
  as a 
 string
 . However, in some cases 
 the inferred type is not correct. You can see that in the next examples.
  
 let x = {}; 
  
 x.a = true;
  
 The type of 
 x
  is inferred as 
 {}
 , an empty object. Thus, the assignment to 
 x.a
  is not allowed, 
 since the property 
 a
  does not exist. You can fix this by adding a type to the definition: 
 let x: { 
 a?: boolean } = {}
 .
  
 class Base {
  
  a: boolean; 
  
 } 
  
 class Derived extends Base {
  
  b: string; 
  
 } 
  
 let x = new Derived(); 
  
 x = new Base();
  
 In this case, the type of x is 
 Derived
 . The assignment on the last line is not allowed, since 
 Base
  is not assignable to 
 Derived
 . You can again fix this by adding a type: 
 let x: Base = new 
 Derived()
 .
  
 If the type of a variable is unknown or very complex, you can use 
 any
  as the type for the 
 variable, which disables type checking for that variable.
  
 Other possible sources of errors are classes. When you use the class keyword to create 
 classes, you can get errors that a property does not exist in the class.
  
 class A {
  
  constructor() {
  
   
  this.x = true;
  
  } 
  
 }",NA
Adding type guards and casts,"A common pattern in JavaScript is that a function accepts either a single value of a certain 
 type, or an array of multiple types. You can express such a type with a union type:
  
 function foo(input: string | string[]) { ...
  
 }
  
 In the body of such a function, you would check if the argument is an array or a single 
 string. In most cases, TypeScript can correctly follow this pattern. For instance, TypeScript 
 can change the type of input in the next example.
  
 function foo(input: string | string[]) { if (typeof input 
 === ""string"") {
  
  } else {
  
  } 
  
 }
  
 The type of input is string in the block after the 
 if
  and 
 string[]
  in the 
 else
 -block. The changing 
 of a type is called narrowing and the checks for a type are called 
 type guards
 . TypeScript 
 has built-in support for 
 typeof
  and 
 instanceof
  type guards, but you can also define your own. 
 A user defined type guard function is a function that takes the value as one of its arguments 
 and returns 
 true
  when the value is of a certain type. A type guard can be written like this:
  
 function isBar(value: Foo): value is Bar { ...
  
 }",NA
Using modern syntax,"The class keyword was introduced in 
 ES2015
 , a recent version of JavaScript. Older projects 
 created classes with a function and prototypes should migrate to the new class syntax. In 
 TypeScript, these classes can be typed better. Following are two code fragments, which 
 show the same class written with the prototype and with the class syntax.
  
 var A = (function () {
  
  
  function A() {
  
  
  
  this.x = true;
  
  
  }
  
  
  A.prototype.a = function () {
  
  
  };
  
  
  return A; 
  
 }());
  
 class A {
  
  x: boolean;
  
  constructor() {
  
   
  this.x = true;
  
  }
  
  a() {
  
  } 
  
 }",NA
Adding types,"The file compiles now, but lots of variables and parameters might be typed as 
 any
 . For 
 complex types, you can first create an interface, for object types, or a type alias, for function 
 types or union types.
  
 TypeScript does not infer types in the following cases:
  
 Variable declaration without an initializer (like 
 var x;
 )
  
 Parameters of a function definition without a default value
  
 Return type of a function that uses recursion
  
 In an editor like VS Code, you can check the type of a variable, parameter or function by 
 hovering over it. On these locations you should add a type annotation yourself.",NA
Refactoring the project,"When you have ported the project to TypeScript, you can refactor the program more easily. 
 You should remove patterns that do not fit well with TypeScript. For instance, magic string 
 values should be replaced by enums. When you have a project that uses a framework, you",NA
Enable strict checks,"You can enable stricter checks in TypeScript. These checks can improve the quality of your 
 program. Here are a few options that can be useful.
  
 noImplicitAny
 : Checks that no variables are typed as any unless you explicitly 
  
 annotated them with any.
  
 noImplicitReturns
 : Checks that all execution paths of a function return a 
  
 value.
  
 strictNullChecks
 : Enables strict checks for variables that might be undefined 
  
 or 
 null.",NA
Summary,"In this chapter, we have looked at various steps involved in migrating a project from 
 JavaScript to TypeScript. We saw how a project can be migrated gradually. We looked at 
 various ways to update an old project so that it can use new JavaScript features and how it 
 can use the type system of TypeScript. You can use your knowledge from the previous 
 chapters to make the project even better.",NA
Index,NA,NA
A ,"about-page component
  
  using, in other components  
 26 
  
 actions
  
  column, adding  
 161
  
  creating  
 160
  
  input popup, showing  
 163
  
  rows, adding  
 161
  
  testing  
 165
  
  title, changing  
 162 
  
 algorithms
  
  Big-Oh notation  
 129
  
  binary search  
 131
  
  built-in functions  
 132
  
  optimizing  
 130
  
  performances, comparing  
 128
 , 
 129 
  
 Angular 2  
 45 
  
 Angular
  
  as framework  
 98
  
  comparing, with React  
 96
  
  templates, using  
 96 
  
 API
  
  testing  
 62 
  
 artificial intelligence (AI)
  
  about  
 216
  
  implementing, with Minimax  
 230
  
  testing  
 238
  
  testing, with random player  
 239 
  
 asynchronous code, NodeJS
  
  about  
 50
  
  callback approach  
 50
  
  callback approach, disadvantages  
 51 
  
 Asynchronous Module Definition (AMD)  
 243 
 authentication
  
  adding  
 58
  
  users, adding to database  
 61
  
  users, implementing in database  
 60",NA
B ,"binary search  
 131 
  
 build tool
  
  reference link  
 244",NA
C ,"canvas
  
  drawing on  
 190
 , 
 192 
  
 chat room
  
  application, running  
 96
  
  creating  
 94
  
  stateless functional components  
 95
  
 two-way bindings  
 94 
  
 client side
  
  login form, creating  
 68
 , 
 69
  
  main component  
 71
  
  main component, error handler  
 73
  
 menu, creating  
 70
  
  note editor  
 71
  
  writing  
 66 
  
 command line interface (CLI)
  
  creating  
 233
  
  interaction, handling  
 233
  
  players, creating  
 236
 , 
 238 
  
 CommonJS  
 242 
  
 component
  
  creating  
 20
  
  event listeners  
 24
  
  interactions, adding  
 22
  
  one-way variable binding  
 23
  
  template  
 21
  
  testing  
 21 
  
 components
  
  reference link  
 111 
  
 conditions, adding to templates",NA
D ,"decorators  
 21 
  
 discriminated union types  
 127",NA
E ,"ES2015  
 249 
  
 event handler
  
  creating  
 203
  
  key code, working with  
 203
  
  key codes, working with  
 205 
  
 expressions
  
  calculating  
 145
  
  core parsers, creating  
 147
  
  data types, creating  
 139
 , 
 141
  
  data types, traversing  
 141
 , 
 142
  
  data types, using  
 139
  
  number, parsing  
 151
  
  order of operations  
 152
 , 
 154
  
  parsers, running in sequence  
 148
 , 
 150
  
 parsing  
 147
  
  validating  
 143",NA
F ,"file migration
  
  about  
 245
  
  casts, adding  
 248
  
  converting, to ES modules  
 245
  
 correcting types  
 247
  
  modern syntax, using  
 249
  
  type guards, adding  
 248
  
  types, adding  
 250 
  
 Flux architecture
  
  action  
 158
  
  @Output, adding  
 36
  
  creating  
 29
  
  data, downloading  
 32
 , 
 35
  
  templates, using  
 30 
  
 forecast
  
  API, typing  
 28
  
  API, using  
 27
  
  displaying  
 27 
  
 framework
  
  components, binding  
 188
  
  designing  
 181
  
  events, creating  
 187
  
  other pictures, wrapping  
 185
  
 pictures, creating  
 182
 , 
 184 
 functional programming (FP) 
 about  
 134
 , 
 137
  
  factorial, creating  
 138",NA
H ,"hash  
 60 
  
 HTML5 canvas
  
  state, restoring  
 181
  
  state, saving  
 180
  
  using  
 179
 , 
 180",NA
J ,"JavaScript
  
  array spread  
 8
  
  arrow functions  
 6
  
  classes, creating  
 6
  
  const  
 5
  
  destructuring  
 8
  
  ES2015 (ES6) version  
 4
  
  ES2016  
 4
  
  ES3 version  
 4
  
 [ 253 ]",NA
K ,"key-value  
 116",NA
L ,"layout container
  
  reference link  
 111 
  
 layouts, NativeScript
  
  DockLayout  
 111
  
  GridLayout  
 111
  
  WrapLayout  
 111",NA
M ,"main component
  
  about  
 40
  
  event, listening to  
 41
  
  geolocation API, using  
 41
  
  other components, using  
 40
  
  sources  
 41
  
  two-way bindings  
 40 
  
 menu, PacMan
  
  adding  
 210
  
  events, handling  
 213
  
  model, changing  
 210
  
  rendering  
 212
  
  time handler, modifying  
 214 
  
 Minimax alogrithm
  
  optimizing  
 232 
  
 Minimax
  
  implementing, in TypeScript  
 231
  
 used, for implementing AI  
 230 
 model,Tic-Tac-Toe game
  
  creating  
 219
  
  grid, creating  
 225
  
  grid, displaying  
 220
  
  operations, creating on grid  
 222
  
 random testing  
 228
 , 
 229
  
  using  
 14 
  
 MongoDB  
 45 
  
 MongoDB database, NodeJS
  
  connecting to  
 53
  
  functions, wrapping in promises  
 52
  
 querying  
 54
  
  reference link  
 52",NA
N ,"NativeScript
  
  about  
 99
  
  comparing  
 119
  
  detail view, creating  
 112
  
  details view, creating  
 109
 , 
 110
 , 
 111
  
 Hello World page, creating  
 103
  
  main view, creating  
 105
 , 
 107
 , 
 108
  
 persistent storage, adding  
 116
  
  structure, creating  
 101
  
  styling  
 117
 , 
 118
  
  TypeScript, adding  
 102
  
  working with  
 100 
  
 never type
  
  about  
 127 
  
 NodeJS
  
  about  
 45
 , 
 233
  
  asynchronous code  
 50
  
  MongoDB database  
 52
  
  starting with  
 49 
  
 note-taking app project
  
  build tool, configuring  
 46
 , 
 47
  
  directories  
 46
  
  running  
 75
  
  setting up  
 46
  
  type definitions  
 48 
  
 null type
  
  checking  
 126
  
 [ 254 ]",NA
O ,"open weather map 
 reference link  
 27
  
  summarizing  
 174 
  
 spreadsheet
  
  all fields calculating  
 156
  
  defining  
 155",NA
P ,"Pac Man
  
  about  
 177
  
 structural type system
  
  about  
 55
  
  API, typing  
 58
  
  generics  
 55
  
  
  menu, adding  
 210
  
 running  
 209
  
  setting up  
 178 
  
 Phonegap  
 119 
  
 polyfill
  
  reference link  
 9 
  
 pure code  
 137",NA
T ,"tagged union types
  
  creating  
 127 
  
 template
  
  conditions, adding  
 25 
  
 Tic-Tac-Toe game",NA
Q ,"QR codes
  
  scan function, implementing  
 113
 , 
 114
  
 scanning  
 113
  
  testing, on device  
 115
  
  type definitions  
 113
  
  about  
 216
  
  structure, creating  
 218
  
  TypeScript, configuring  
 218 
 time handler
  
  creating  
 205
 , 
 209 
  
 Titanium  
 119 
  
 TSX file  
 249",NA
R ,"React Native  
 119 
  
 React
  
  about  
 76
  
  as libraries  
 98
  
  comparing, with Angular  
 96
  
  components, creating with JSX  
 79
  
 JSX, using  
 97
  
  menu, creating  
 81
  
  props, adding to component  
 80
  
 starting with  
 79
  
  state, adding to component  
 80 
  
 Real-Time Chat project
  
  gulp, configuring  
 78
  
  setting up  
 77
  
  testing  
 84 
  
 rest argument  
 7",NA
S ,"side effect  
 137 
  
 spreadsheet application project 
 setting up  
 135
  
 type cast  
 121 
  
 type guard
  
  about  
 248
  
  accuracy, checking  
 124
  
  assignments, checking  
 125
  
 combining  
 124
  
  instanceof guard  
 122
  
  narrowing any  
 123
  
  narrowing process  
 123
  
  typeof guard  
 122
  
  user defined  
 122
  
  using  
 122 
  
 types
  
  annotations  
 11
  
  any  
 10
  
  boolean  
 9
  
  checking  
 9
  
  defining  
 10
  
  enum type  
 10
  
  function type  
 11
  
  intersection type  
 10
  
  literal types  
 10
  
  never  
 10
  
 [ 255 ]",NA
W ,"weather forecast project
  
  directory structure  
 15
  
  first component, creating  
 20
  
 HTML file  
 18
  
  setting up  
 15
  
  system, building  
 16
 , 
 18
  
  system,building  
 17
  
  TypeScript, configuring  
 16 
 websocket server
  
  API, typing  
 84",NA
U ,"undefined type
  
  checking  
 126
  
  automatically reconnecting  
 90
  
  chat message session, implementing  
 88
  
 connecting to  
 90
  
  connections  
 84
  
  
 utility functions, PacMan
  
  adding  
 192 
  
 utility functions,Tic-Tac-Toe game 
 adding  
 219
  
  connections, accepting  
 85
  
  event handler, writing  
 93
  
  event handlers, writing  
 94
  
  message, sending  
 92",NA
V,"recent messages, storing  
 86
  
  session, handling  
 87
  
  writing  
 84",NA
Bibliography,"This learning path has been prepared for you to build stunning applications by 
 leveraging the features of TypeScript. It comprises of the following Packt products:
  
 • 
  
 Learning TypeScript, Remo H. Jansen
  
  
 • 
  
 TypeScript Design Patterns, Vilic Vane
  
  
 • 
  
 TypeScript Blueprints, Ivo Gabe de Wolff
  
 [
  337 
 ]",NA
