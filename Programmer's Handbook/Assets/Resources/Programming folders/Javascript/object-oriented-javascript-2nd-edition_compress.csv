Larger Text,Smaller Text,Symbol
Object-Oriented JavaScript ,NA,NA
Second Edition,NA,NA
Learn everything you need to know about OOJS in this ,NA,NA
comprehensive guide,NA,NA
Stoyan Stefanov ,NA,NA
Kumar Chetan Sharma,BIRMINGHAM - MUMBAI,NA
Object-Oriented JavaScript,NA,NA
Second Edition,"Copyright © 2013 Packt Publishing
  
 All rights reserved. No part of this book may be reproduced, stored in a retrieval 
 system, or transmitted in any form or by any means, without the prior written 
 permission of the publisher, except in the case of brief quotations embedded in 
 critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of 
 the information presented. However, the information contained in this book is sold 
 without warranty, either express or implied. Neither the authors, nor Packt 
 Publishing, and its dealers and distributors will be held liable for any damages 
 caused or alleged to be caused directly or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the 
 companies and products mentioned in this book by the appropriate use of capitals. 
  
 However, Packt Publishing cannot guarantee the accuracy of this information.
  
 First published: July 2008
  
 Second edition: July 2013
  
 Production Reference: 1190713
  
 Published by Packt Publishing Ltd.
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham B3 2PB, UK.
  
 ISBN 978-1-84969-312-7
  
 www.packtpub.com
  
 Cover Image by Gorkee Bhardwaj (
 afterglowpictures@gmail.com
 )",NA
Credits,"Authors 
  
 Stoyan Stefanov 
  
 Kumar Chetan Sharma
  
 Reviewers 
  
 Kumar Chetan Sharma 
 Alex R. Young
  
 Acquisition Editors 
 Martin Bell 
  
 Jonathan Titmus
  
 Lead Technical Editor 
 Arun Nadar
  
 Technical Editors 
 Prasad Dalvi 
  
 Mausam Kothari 
 Worrell Lewis 
  
 Amit Ramadas
  
 Project Coordinator 
 Leena Purkait
  
 Proofreaders 
  
 Paul Hindle
  
 Linda Morris
  
 Indexer 
  
 Rekha Nair
  
 Graphics 
  
 Ronak Dhruv
  
 Production Coordinator 
 Arvindkumar Gupta
  
 Cover Work 
  
 Arvindkumar Gupta",NA
About the Authors,"Stoyan Stefanov
  is a Facebook engineer, author, and speaker. He talks regularly 
 about web development topics at conferences and his blog 
 www.phpied.com
 , and also 
 runs a number of other sites, including 
 JSPatterns.com
 —a site dedicated to 
 exploring JavaScript patterns. Previously at Yahoo!, Stoyan was the architect of YSlow 
 2.0 and creator of the image optimization tool Smush.it.
  
 A ""citizen of the world"", Stoyan was born and raised in Bulgaria, but is also a 
 Canadian citizen, currently residing in Los Angeles, California. In his offline 
 moments, he enjoys playing the guitar, taking flying lessons, and spending time 
 at the Santa Monica beaches with his family.
  
 I'd like to dedicate this book to my wife Eva and my daughters 
 Zlatina and Nathalie. Thank you for your patience, support, and 
 encouragement.
  
 To my reviewers who volunteered their time reviewing drafts of this 
 book and whom I deeply respect and look up to: a big thank you for 
 your invaluable inputs.
  
 Kumar Chetan Sharma
  studied to be an electronics engineer and has always 
 wanted to build an ultimate sound system. He then, by chance, got a part time job as a 
 trainee HTML guy. From there he picked up CSS and JavaScript and there was no 
 looking back. It was the time when JavaScript was used to validate forms or create 
 fancy DHTML effects and IE6 was the only browser the world knew. He has been 
 developing web applications since then, using LAMP stack. He has worked on white 
 label social networking applications to web control panels for telecom and networked 
 electrical charger infrastructures. He currently works as a frontend engineer for 
 Yahoo! Search.",NA
About the Reviewer,"Alex R. Young
  is an engineering graduate with over 10 years of web and mobile 
 industry experience.
  
 He's the editor-in-chief of DailyJS, and writes regularly about all things JavaScript. He 
 has also worked for major multinational corporations, including Thomson Reuters, 
 and is currently writing a book about Node.",NA
www.PacktPub.com,NA,NA
"Support files, eBooks, discount offers and more","You might want to visit 
 www.PacktPub.com
  for support files and downloads related to 
 your book. 
  
 Did you know that Packt offers eBook versions of every book published, with PDF and 
 ePub files available? You can upgrade to the eBook version at 
 www.PacktPub. com
  and 
 as a print book customer, you are entitled to a discount on the eBook copy. Get in touch 
 with us at 
 service@packtpub.com
  for more details.
  
 At 
 www.PacktPub.com
 , you can also read a collection of free technical articles, sign up for 
 a range of free newsletters and receive exclusive discounts and offers on Packt books and 
 eBooks.
  
  
 http://PacktLib.PacktPub.com
  
 Do you need instant solutions to your IT questions? PacktLib is Packt's online 
 digital book library. Here, you can access, read and search across Packt's entire 
 library of books.",NA
Why Subscribe?,"• 
  
 Fully searchable across every book published by Packt
  
 • 
  
 Copy and paste, print and bookmark content
  
 • 
  
 On demand and accessible via web browser",NA
Free Access for Packt account holders,"If you have an account with Packt at 
 www.PacktPub.com
 , you can use this to access 
 PacktLib today and view nine entirely free books. Simply use your login credentials for 
 immediate access.",NA
Table of Contents,"Preface 
  
 1
  
 Chapter 1: Object-oriented JavaScript 
  
 7
  
 A bit of history 
  
 Browser wars and renaissance 
  
 The present 
  
 The future 
  
 ECMAScript 5 
  
 Object-oriented programming 
  
 Objects 
  
 Classes 
  
 Encapsulation 
  
 Aggregation 
  
 Inheritance 
  
 Polymorphism 
  
 OOP summary 
  
 Setting up your training environment 
 WebKit's Web Inspector 
  
 JavaScriptCore on a Mac 
  
 More consoles 
  
 Summary 
  
 Chapter 2: Primitive Data Types, Arrays, Loops, and Conditions 
  
 8 
  
 9 
  
 10 
 11 
 12 
 12 
 13 
 13 
 14 
 15 
 15 
 16 
 16 
 17 
 17 
 18 
 19 
 20
  
 21
  
 Variables 
  
 Variables are case sensitive 
  
 Operators 
  
 Primitive data types 
  
 Finding out the value type – the typeof operator 
 Numbers 
  
 Octal and hexadecimal numbers 
  
 2
 1 
 2
 3 
 2
 4 
 2
 8 
 2
 8 
 2
 9 
 2
 9",NA
Preface,"This is the second edition of the highly rated book 
 Object-Oriented JavaScript
  by 
 Stoyan 
 Stefanov
 , 
 Packt Publishing
 . After the release of the first edition, in the last five years, 
 JavaScript has moved from being mostly used in browsers for client-side technologies to 
 being used even on server side. This edition explores the ""language side"" of JavaScript. 
 The stress is on the standards part of the language. The book talks about ECMA Script, 
 Object-Oriented JS, patterns, prototypal inheritance, and design patterns.
  
 The book doesn't assume any prior knowledge of JavaScript and works from the 
 ground up to give you a thorough understanding of the language. People who know 
 the language will still find it useful and informative. Exercises at the end of the 
 chapters help you assess your understanding.",NA
What this book covers,"Chapter 1
 , 
 Object-oriented JavaScript
 , talks briefly about the history, present, and 
 future of JavaScript, and then moves on to explore the basics of object-oriented 
 programming (OOP) in general. You then learn how to set up your training 
 environment (Firebug) in order to dive into the language on your own, using the 
 book examples as a base.
  
 Chapter 2
 , 
 Primitive Data Types, Arrays, Loops, and Conditions
 , discusses the language 
 basics: variables, data types, primitive data types, arrays, loops, and conditionals.
  
 Chapter 3
 , 
 Functions
 , covers functions that JavaScript uses, and here you learn to 
 master them all. You also learn about the scope of variables and JavaScript's built-
 in functions. An interesting, but often misunderstood feature of the language—
 closures—is demystified at the end of the chapter.",NA
What you need for this book,"You need a modern browser—Google Chrome or Firefox are recommended—and an 
 optional Node.js setup. The latest version of Firefox comes with web developer tools, but 
 Firebug is highly recommended. To edit JavaScript you can use any text editor of your 
 choice.",NA
Who this book is for,"This book is for anyone who is starting to learn JavaScript or who knows JavaScript but 
 isn't very good at the object-oriented part of it.",NA
Conventions,"In this book, you will find a number of styles of text that distinguish between 
 different kinds of information. Here are some examples of these styles, and an 
 explanation of their meaning.
  
 Code words in text are shown as follows: ""If you want to be sure, you can check the 
 cancellable
  property of the event object"".
  
 A block of code will be set as follows:
  
 var a;
  
 var thisIsAVariable;
  
 var _and_this_too;
  
 var mix12three;
  
 When we wish to draw your attention to an output of a code block, the relevant lines or 
 items will be shown in bold:
  
 > var case_matters = 'lower';
  
 > var CASE_MATTERS = 'upper';
  
 > case_matters;
  
 ""lower""
  
 > CASE_MATTERS;
  
 ""upper""
  
 Any command-line input or output is written as follows:
  
 alias 
 jsc='/System/Library/Frameworks/JavaScriptCore.framework/Versions/ 
 Current/Resources/jsc'
  
 [
  3 
 ]",NA
Reader feedback,"Feedback from our readers is always welcome. Let us know what you think about this 
 book—what you liked or may have disliked. Reader feedback is important for us to 
 develop titles that you really get the most out of.
  
 To send us general feedback, simply send an e-mail to 
 feedback@packtpub.com
 , 
 and mention the book title via the subject of your message.
  
 If there is a topic that you have expertise in and you are interested in either writing or 
 contributing to a book, see our author guide on 
 www.packtpub.com/authors
 .",NA
Customer support,"Now that you are the proud owner of a Packt book, we have a number of things to help 
 you to get the most from your purchase.",NA
Errata,"Although we have taken every care to ensure the accuracy of our content, mistakes do 
 happen. If you find a mistake in one of our books—maybe a mistake in the text or the 
 code—we would be grateful if you would report this to us. By doing so, you can save other 
 readers from frustration and help us improve subsequent versions of this book. If you find 
 any errata, please report them by visiting 
 http://www.packtpub. com/submit-
 errata
 , selecting your book, clicking on the 
 erratasubmissionform
  link, and entering 
 the details of your errata. Once your errata are verified, your submission will be accepted 
 and the errata will be uploaded on our website, or added to any list of existing errata, 
 under the Errata section of that title. Any existing errata can be viewed by selecting your 
 title from 
 http://www.packtpub.com/support
 .
  
 [
  4 
 ]",NA
Piracy,"Piracy of copyright material on the Internet is an ongoing problem across all media. At 
 Packt, we take the protection of our copyright and licenses very seriously. If you come 
 across any illegal copies of our works, in any form, on the Internet, please provide us 
 with the location address or website name immediately so that we can pursue a remedy.
  
 Please contact us at 
 copyright@packtpub.com
  with a link to the suspected 
 pirated material.
  
 We appreciate your help in protecting our authors, and our ability to bring you 
 valuable content.",NA
Questions,"You can contact us at 
 questions@packtpub.com
  if you are having a problem with any 
 aspect of the book, and we will do our best to address it.
  
 [
  5 
 ]",NA
Object-oriented JavaScript,"Ever since the early days of the Web, there has been a need for more dynamic and 
 responsive interfaces. While it's OK to read static HTML pages of text and even better 
 when they are beautifully presented with the help of CSS, it's much more fun to engage 
 with applications in our browsers, such as e-mail, calendars, banking, shopping, drawing, 
 playing games, and text editing. All that is possible thanks to JavaScript, the programming 
 language of the Web. JavaScript started with simple one-liners embedded in HTML, but is 
 now used in much more sophisticated ways. Developers leverage the object-oriented 
 nature of the language to build scalable code architectures made up of reusable pieces.
  
 If you look at the past and present buzzwords in web development—DHTML, Ajax, 
 Web 2.0, HTML5—they all essentially mean HTML, CSS, and JavaScript. HTML for 
 content
 , CSS for 
 presentation
 , and JavaScript for 
 behavior
 . In other words, JavaScript is 
 the glue that makes everything work together so that we can build rich web 
 applications. 
  
 But that's not all, JavaScript can be used for more than just the Web.
  
 JavaScript programs run inside a host environment. The web browser is the most 
 common environment, but it's not the only one. Using JavaScript, you can create all 
 kinds of widgets, application extensions, and other pieces of software, as you'll see in a 
 bit. Taking the time to learn JavaScript is a smart investment; you learn one language 
 and can then write all kinds of different applications running on multiple platforms, 
 including mobile and server-side applications. These days, it's safe to say that JavaScript 
 is everywhere.
  
 This book starts from zero, and does not assume any prior programming knowledge 
 other than some basic understanding of HTML. Although there is one chapter dedicated 
 to the web browser environment, the rest of the book is about JavaScript in general, so 
 it's applicable to all environments.",NA
A bit of history,"Initially, the Web was not much more than just a number of scientific publications in the 
 form of static HTML documents connected together with hyperlinks. Believe it or not, 
 there was a time when there was no way to put an image in a page. But that soon changed. 
 As the Web grew in popularity and size, the webmasters who were creating HTML pages 
 felt they needed something more. They wanted to create richer user interactions, mainly 
 driven by the desire to save server roundtrips for simple tasks such as form validation. 
 Two options came up: Java applets and LiveScript, a language conceived by Brendan Eich 
 at Netscape in 1995 and later included in the Netscape 2.0 browser under the name of 
 JavaScript.
  
 The applets didn't quite catch on, but JavaScript did. The ability to use short code snippets 
 embedded in HTML documents and alter otherwise static elements of a web page was 
 embraced by the webmaster community. Soon, the competing browser vendor Microsoft 
 shipped Internet Explorer (IE) 3.0 with JScript, which was a reverse engineered version of 
 JavaScript plus some IE-specific features. Eventually, there was an effort to standardize 
 the various implementations of the language, and this is how ECMAScript was born. 
 ECMA
  (
 European Computer Manufacturers Association
 ) created the standard called 
 ECMA-262, which describes the core parts of the JavaScript programming language 
 without browser and web page-specific features.
  
 You can think of JavaScript as a term that encompasses three pieces:
  
 • 
  
 • 
  
 ECMAScript
 —the core language—variables, functions, loops, and so on. 
 This part is independent of the browser and this language can be used in 
 many other environments.
  
 Document Object Model
  (
 DOM
 ), which provides ways to work with HTML and 
 XML documents. Initially, JavaScript provided limited access to what's scriptable 
 on the page, mainly forms, links, and images. Later it was expanded to make all 
 elements scriptable. This lead to the creation of 
  
 the DOM standard by the 
 World Wide Web Consortium
  (
 W3C
 ) as a 
  
 language-independent (no longer tied to JavaScript) way to manipulate 
 structured documents.
  
 [
  8 
 ]",NA
Browser wars and renaissance,"For better or for worse, JavaScript's instant popularity happened during the period of 
 the Browser Wars I (approximately 1996 to 2001). Those were the times during the 
 initial Internet boom when the two major browser vendors—Netscape and 
 Microsoft—were competing for market share. Both were constantly adding more bells 
 and whistles to their browsers and their versions of JavaScript, DOM, and BOM, which 
 naturally led to many inconsistencies. While adding more features, the browser 
 vendors were falling behind on providing proper development and debugging tools 
 and adequate documentation. Often, development was a pain; you would write a script 
 while testing in one browser, and once you're done with development, you test in the 
 other browser, only to find that your script simply fails for no apparent reason and the 
 best you can get is a cryptic error message like ""Operation aborted"".
  
 Inconsistent implementations, missing documentation, and no appropriate tools 
 painted JavaScript in such a light that many programmers simply refused to bother 
 with it. 
  
 On the other hand, developers who did try to experiment with JavaScript got a little 
 carried away adding too many special effects to their pages without much regard of how 
 usable the end results were. Developers were eager to make use of every new possibility 
 the browsers provided and ended up ""enhancing"" their web pages with things like 
 animations in the status bar, flashing colors, blinking texts, objects stalking your mouse 
 cursor, and many other ""innovations"" that actually hurt the user experience. These 
 various ways to abuse JavaScript are now mostly gone, but they were one of the reasons 
 why the language got some bad reputation. Many ""serious"" programmers dismissed 
 JavaScript as nothing but a toy for designers to play around with, and dismissed it as a 
 language unsuitable for serious applications. The JavaScript backlash caused some web 
 projects to completely ban any client-side programming and trust only their predictable 
 and tightly controlled server. And really, why would you double the time to deliver a 
 finished product and then spend additional time debugging problems with the different 
 browsers?
  
 [
  9 
 ]",NA
The present,"An interesting thing about JavaScript is that it always runs inside a 
 host environment
 . 
  
 The web browser is just one of the available hosts. JavaScript can also run on the 
 server, on the desktop, and on mobile devices. Today, you can use JavaScript to do all 
 of the following:
  
 • 
  
 • 
  
 Create rich and powerful web applications (the kind of applications that run 
 inside the web browser). Additions to HTML5 such as application cache, client-
 side storage, and databases make browser programming more and more 
 powerful for both online and offline applications.
  
 Write server-side code using .NET or 
 Node.js
 , as well as code that can run 
 using Rhino (a JavaScript engine written in Java).
  
 [
  10 
 ]",NA
The future,"We can only speculate what the future will be, but it's quite certain that it will include 
 JavaScript. For quite some time, JavaScript may have been underestimated and 
 underused (or maybe overused in the wrong ways), but every day we witness new 
 applications of the language in much more interesting and creative ways. It all started 
 with simple one liners, often embedded in HTML tag attributes (such as 
 onclick)
 . 
 Nowadays, developers ship sophisticated, well designed and architected, and extensible 
 applications and libraries, often supporting multiple platforms with a single codebase. 
 JavaScript is indeed taken seriously and developers are starting to rediscover and enjoy 
 its unique features more and more.
  
 Once listed in the ""nice-to-have"" sections of job postings, today, the knowledge of 
 JavaScript is often a deciding factor when it comes to hiring web developers. Common 
 job interview questions you can hear today include: ""Is JavaScript an object-oriented 
 language? Good. Now how do you implement inheritance in JavaScript?"" After reading 
 this book, you'll be prepared to ace your JavaScript job interview and even impress your 
 interviewers with some bits that, maybe, they didn't know.
  
 [
  11 
 ]",NA
ECMAScript 5,"Revision 3 of ECMAScript is the one you can take for granted to be implemented in all 
 browsers and environments. Revision 4 was skipped and revision 5 (let's call it ES5 for 
 short) was officially accepted in December 2009. 
  
 ES5 introduces some new objects and properties and also the so-called ""strict mode"". 
 Strict mode is a subset of the language that excludes deprecated features. The strict 
 mode is opt-in and not required, meaning that if you want your code to run in the strict 
 mode, you declare your intention using (once per function, or once for the whole 
 program) the following string:
  
 ""use strict"";
  
 This is just a JavaScript string, and it's OK to have strings floating around unassigned to 
 any variable. As a result, older browsers that don't ""speak"" ES5 will simply ignore it, so 
 this strict mode is backwards compatible and won't break older browsers.
  
 In future versions, strict mode is likely to become the default or the only mode. For 
 the time being, it's optional.
  
 For backwards compatibility, all the examples in this book work in ES3, but at the 
 same time, all the code in the book is written so that it will run without warnings in 
 ES5's strict mode. Additionally, any ES5-specific parts will be clearly marked. 
 Appendix C
 , 
 Built-in Objects
 , lists the new additions to ES5 in detail.",NA
Object-oriented programming,"Before diving into JavaScript, let's take a moment to review what people mean when they 
 say ""object-oriented"", and what the main features of this programming style are. Here's a 
 list of concepts that are most often used when talking about 
 object-oriented 
 programming
  (
 OOP
 ):
  
 • 
  
 Object, method, and property
  
 • 
  
 Class
  
 • 
  
 Encapsulation
  
 • 
  
 Aggregation
  
 • 
  
 Reusability/inheritance
  
 • 
  
 Polymorphism
  
 [
  12 
 ]",NA
Objects,"As the name object-oriented suggests, objects are important. An object is a 
  
 representation of a ""thing"" (someone or something), and this representation is 
 expressed with the help of a programming language. The thing can be anything—a real-
 life object, or a more convoluted concept. Taking a common object like a cat for example, 
 you can see that it has certain characteristics (color, name, weight, and so on) and can 
 perform some actions (meow, sleep, hide, escape, and so on). The characteristics of the 
 object are called 
 properties
  in OOP-speak, and the actions are called 
 methods
 .
  
 There is also an analogy with the spoken language:
  
 • 
  
 Objects are most often named using nouns (book, person, and so on)
  
 • 
  
 Methods are verbs (read, run, and so on)
  
 • 
  
 Values of the properties are adjectives
  
 Take the sentence ""The black cat sleeps on the mat"". ""The cat"" (a noun) is the object, 
 ""black"" (adjective) is the value of the 
 color
  property, and ""sleep"" (a verb) is an action, or 
 a method in OOP. For the sake of the analogy, we can go a step further and say that ""on the 
 mat "" specifies something about the action ""sleep"", so it's acting as a parameter passed to 
 the 
 sleep
  method.",NA
Classes,"In real life, similar objects can be grouped based on some criteria. A hummingbird and an 
 eagle are both birds, so they can be classified as belonging to some made up 
 Birds
  class. 
 In OOP, a class is a blueprint, or a recipe for an object. Another name for ""object"" is 
 ""instance"", so we say that the eagle is one concrete instance of the general class 
 Birds
 . 
 You can create different objects using the same class, because a class is just a template, 
 while the objects are concrete instances based on the template.
  
 [
  13 
 ]",NA
Encapsulation,"Encapsulation is another OOP-related concept, which illustrates the fact that an 
 object contains (encapsulates) both:
  
 • 
  
 Data (stored in properties)
  
 • 
  
 The means to do something with the data (using methods)
  
 One other term that goes together with encapsulation is information hiding. This is a 
 rather broad term and can mean different things, but let's see what people usually mean 
 when they use it in the context of OOP.
  
 Imagine an object, say, an MP3 player. You, as the user of the object, are given some 
 interface to work with, such as buttons, display, and so on. You use the interface in order 
 to get the object to do something useful for you, like play a song. How exactly the device 
 is working on the inside, you don't know, and, most often, don't care. In other words, the 
 implementation of the interface is hidden from you. The same thing happens in OOP 
 when your code uses an object by calling its methods. It doesn't matter if you coded the 
 object yourself or it came from some third-party library; your code doesn't need to 
 know how the methods work internally. In compiled languages, you can't actually read 
 the code that makes an object work. In JavaScript, because it's an interpreted language, 
 you can see the source code, but the concept is still the same—you work with the 
 object's interface, without worrying about its implementation.
  
 Another aspect of information hiding is the visibility of methods and properties. 
  
 In some languages, objects can have 
 public
 , 
 private
 , and 
 protected
  methods and 
 properties. This categorization defines the level of access the users of the object have. 
 For example, only the methods of the same object have access to the 
 private 
 methods, 
 while anyone has access to the 
 public
  ones. In JavaScript, all methods and properties 
 are 
 public
 , but we'll see that there are ways to protect the data inside an object and 
 achieve privacy.
  
 [
  14 
 ]",NA
Aggregation,"Combining several objects into a new one is known as 
 aggregation
  or 
 composition
 . It's 
 a powerful way to separate a problem into smaller and more manageable parts (divide 
 and conquer). When a problem scope is so complex that it's impossible to think about it 
 at a detailed level in its entirety, you can separate the problem into several smaller 
 areas, and possibly then separate each of these into even smaller chunks. This allows 
 you to think about the problem on several levels of abstraction. 
  
 Take, for example, a personal computer. It's a complex object. You cannot think about 
 all the things that need to happen when you start your computer. But, you can abstract 
 the problem saying that you need to initialize all the separate objects that your 
 Computer
  object consists of—the 
 Monitor
  object, the 
 Mouse
  object, the 
 Keyboard
  
 object, and so on. Then, you can dive deeper into each of the sub-objects. This way, 
 you're composing complex objects by assembling reusable parts.
  
 To use another analogy, a 
 Book
  object can contain (aggregate) one or more 
 Author 
 objects, a 
 Publisher
  object, several 
 Chapter
  objects, a 
 TOC
  (table of contents), and 
 so on.",NA
Inheritance,"Inheritance is an elegant way to reuse existing code. For example, you can have a 
 generic object, 
 Person
 , which has properties such as 
 name
  and 
 date_of_birth
 , and 
 which also implements the functionality 
 walk
 , 
 talk
 , 
 sleep
 , and 
 eat
 . Then, you figure 
 out that you need another object called 
 Programmer
 . You could re-implement all the 
 methods and properties that 
 Person
  has, but it would be smarter to just say that 
 Programmer
  inherits 
 Person
 , and save yourself some work. The 
 Programmer 
 object 
 only needs to implement more-specific functionality, such as the 
 writeCode 
 method, 
 while reusing all of the 
 Person
  object's functionality.
  
 In classical OOP, classes inherit from other classes, but in JavaScript, since there are no 
 classes, objects inherit from other objects.
  
 When an object inherits from another object, it usually adds new methods to the 
 inherited ones, thus extending the old object. Often, the following phrases can be used 
 interchangeably: ""B inherits from A"" and ""B extends A"". Also, the object that inherits 
 can pick one or more methods and redefine them, customizing them for its own needs. 
 This way, the interface stays the same, the method name is the same, but when called 
 on the new object, the method behaves differently. This way of redefining how an 
 inherited method works is known as 
 overriding
 .
  
 [
  15 
 ]",NA
Polymorphism,"In the preceding example, a 
 Programmer
  object inherited all of the methods of the 
 parent 
 Person
  object. This means that both objects provide a 
 talk
  method, among 
 others. Now imagine that somewhere in your code there's a variable called 
 Bob
 , and it 
 just so happens that you don't know if 
 Bob
  is a 
 Person
  object or a 
 Programmer 
 object. 
 You can still call the 
 talk
  method on the 
 Bob
  object and the code will work. 
  
 This ability to call the same method on different objects and have each of them 
 respond in their own way is called 
 polymorphism
 .",NA
OOP summary,"Here's a quick table summarizing the concepts discussed so far:
  
 Feature
  
 Illustrates concept
  
 Bob is a man (an object).
  
 Bob's date of birth is June 1, 1980, gender: male, and hair: black.
  
 Bob can eat, sleep, drink, dream, talk, and calculate his own age.
  
 Objects 
  
 Properties
  
 Methods
  
  
 Bob is an instance of the 
 Programmer
  class.
  
 Class (in classical 
  
 OOP)
  
 Bob is based on another object, called 
 Programmer
 . 
  
 Prototype 
  
 (in prototypal OOP)
  
 Bob holds data (such as 
 birth_date
 ) and methods that work 
 with the data (such as 
 calculateAge()
 ).
  
 You don't need to know how the calculation method works 
 internally. The object might have some private data, such as the 
 number of days in February in a leap year. You don't know, nor do 
 you want to know.
  
 Encapsulation 
  
 Information hiding 
  
  
 Bob is part of a 
 WebDevTeam
  object, together with Jill, a 
 Designer
  object, and Jack, a 
 ProjectManager
  object.
  
 Aggregation and 
  
 composition
  
 Designer
 , 
 ProjectManager
 , and 
 Programmer
  are all based on 
 and extend a 
 Person
  object.
  
 You can call the methods 
 Bob.talk()
 , 
 Jill.talk()
 , and 
 Jack.talk()
  and they'll all work fine, albeit producing 
  
 different results (Bob will probably talk more about performance, Jill 
 about beauty, and Jack about deadlines). Each object inherited the 
 method 
 talk
  from 
 Person
  and customized it.
  
 Inheritance 
  
 Polymorphism and 
 method overriding
  
 [
  16 
 ]",NA
Setting up your training environment ,"This book takes a ""do-it-yourself"" approach when it comes to writing code, because I 
 firmly believe that the best way to really learn a programming language is by writing 
 code. There are no cut-and-paste-ready code downloads that you simply put in your 
 pages. On the contrary, you're expected to type in code, see how it works, and then 
 tweak it and play around with it. When trying out the code examples, you're 
 encouraged to enter the code into a JavaScript console. Let's see how you go about 
 doing this.
  
 As a developer, you most likely already have a number of web browsers installed on 
 your system such as Firefox, Safari, Chrome, or Internet Explorer. All modern browsers 
 have a JavaScript console feature, which you'll use throughout the book to help you 
 learn and experiment with the language. More specifically, this book uses WebKit's 
 console (available in Safari and Chrome), but the examples should work in any other 
 console.",NA
WebKit's Web Inspector,"This example shows how you can use the console to type in some code that swaps the 
 logo on the 
 google.com
  home page with an image of your choice. As you can see, you 
 can test your JavaScript code live on any page.
  
  
 [
  17 
 ]",NA
JavaScriptCore on a Mac,"On a Mac, you don't actually need a browser; you can explore JavaScript directly from 
 your command line 
 Terminal
  application.
  
 If you've never used 
 Terminal
 , you can simply search for it in the Spotlight search. 
 Once you've launched it, type:
  
 alias 
 jsc='/System/Library/Frameworks/JavaScriptCore.framework/Versions/ 
 Current/Resources/jsc'
  
 This command makes an alias to the little 
 jsc
  application, which stands for 
 ""JavaScriptCore"" and is part of the WebKit engine. JavaScriptCore is shipped 
 together with Mac operating systems.
  
 You can add the 
 alias
  line shown previously to your 
 ~/.profile 
 file so that 
 jsc
  is 
 always there when you need it.
  
 Now, in order to start the interactive shell, you simply type 
 jsc
  from any directory. 
 Then you can type JavaScript expressions, and when you hit 
 Enter
 , you'll see the result 
 of the expression.
  
 [
  18 
 ]",NA
More consoles,"All modern browsers have consoles built in. You have seen the Chrome/Safari 
 console previously. In any Firefox version, you can install the Firebug extension, 
 which comes with a console. Additionally, in newer Firefox releases, there's a console 
 built in and accessible via the 
 Tools/Web Developer/Web Console
  menu.
  
  
 [
  19 
 ]",NA
Summary,"In this chapter, you learned about how JavaScript came to be and where it is today. You 
 were also introduced to object-oriented programming concepts and have seen how 
 JavaScript is not a class-based OO language, but a prototype-based one. Finally, you 
 learned how to use your training environment—the JavaScript console. Now you're 
 ready to dive into JavaScript and learn how to use its powerful OO features. But let's 
 start from the beginning.
  
 The next chapter will guide you through the data types in JavaScript (there are just a 
 few), conditions, loops, and arrays. If you think you know these topics, feel free to skip 
 the next chapter, but not before you make sure you can complete the few short exercises 
 at the end of the chapter.
  
 [
  20 
 ]",NA
"Primitive Data Types, Arrays, ",NA,NA
"Loops, and Conditions","Before diving into the object-oriented features of JavaScript, let's first take a look at 
 some of the basics. This chapter walks you through the following:
  
 • 
  
 The primitive data types in JavaScript, such as strings and numbers
  
 • 
  
 Arrays
  
 • 
  
 Common operators, such as 
 +
 , 
 -
 , 
 delete
 , and 
 typeof
  
 • 
  
 Flow control statements, such as loops and if-else conditions",NA
Variables,"Variables are used to store data; they are placeholders for concrete values. When 
 writing programs, it's convenient to use variables instead of the actual data, as it's much 
 easier to write 
 pi
  instead of 
 3.141592653589793
 , especially when it happens several 
 times inside your program. The data stored in a variable can be changed after it was 
 initially assigned, hence the name ""variable"". You can also use variables to store data 
 that is unknown to you while you write the code, such as the result of a later operation.
  
 Using a variable requires two steps. You need to:
  
 • 
  
 Declare the variable
  
 • 
  
 Initialize it, that is, give it a value",NA
Variables are case sensitive ,"Variable names are case sensitive. You can easily verify this statement using your 
 JavaScript console. Try typing this, pressing 
 Enter
  after each line:
  
 var case_matters = 'lower'; 
  
 var CASE_MATTERS = 'upper'; 
  
 case_matters; 
  
 CASE_MATTER;
  
 To save keystrokes, when you enter the third line, you can type 
 case
  and press the 
 Tab
  key (or right-arrow key). The console autocompletes the variable name to 
 case_matters
 . Similarly, for the last line, type 
 CASE
  and press 
 Tab
 . The end result is 
 shown in the following figure:
  
  
 Throughout the rest of this book, only the code for the examples is given instead of a 
 screenshot, like so:
  
 > var case_matters = 'lower'; 
  
 > var CASE_MATTERS = 'upper'; 
  
 > case_matters; 
  
 ""lower""
  
 > CASE_MATTERS; 
  
 ""upper""
  
 [
  23 
 ]",NA
Operators,"Operators take one or two values (or variables), perform an operation, and 
 return a value. Let's check out a simple example of using an operator, just to 
 clarify the terminology:
  
 > 1 + 2;
  
 3
  
 In this code:
  
 • 
  
 +
  is the operator
  
 • 
  
 The operation is addition
  
 • 
  
 The input values are 
 1
  and 
 2
  (the input values are also called operands)
  
 • 
  
 The result value is 
 3
  
 • 
  
 The whole thing is called an expression
  
 Instead of using the values 
 1
  and 
 2
  directly in the expression, you can use variables. You 
 can also use a variable to store the result of the operation, as the following example 
 demonstrates:
  
 > var a = 1;
  
 > var b = 2;
  
 > a + 1;
  
 2
  
 [
  24 
 ]",NA
Primitive data types,"Any value that you use is of a certain type. In JavaScript, there are just a few 
 primitive data types:
  
 1. Number: This includes floating point numbers as well as integers. 
  
 For 
 example, these values are all numbers: 
 1
 , 
 100
 , 
 3.14
 .
  
 2. String: These consist of any number of characters, for example 
 ""a""
 , 
 ""one""
 , 
  
 and 
 ""one 2 three""
 .
  
 3. Boolean: This can be either 
 true
  or 
 false
 .
  
 4. Undefined: When you try to access a variable that doesn't exist, you get the special 
 value 
 undefined
 . The same happens when you declare a variable without 
 assigning a value to it yet. JavaScript initializes the variable behind the scenes 
 with the value 
 undefined
 . The undefined data type can only have one value – 
 the special value 
 undefined
 .
  
 5. Null: This is another special data type that can have only one value, namely the 
 null
  value. It means no value, an empty value, or nothing. The difference with 
 undefined
  is that if a variable has a value 
 null
 , it's still defined, it just so 
 happens that its value is nothing. You'll see some examples shortly.
  
 Any value that doesn't belong to one of the five primitive types listed here is an object. 
 Even 
 null
  is considered an object, which is a little awkward—having an object 
 (something) that is actually nothing. We'll learn more on objects in 
 Chapter 4
 , 
 Objects
 , 
 but for the time being, just remember that in JavaScript the data types are either:
  
 • 
  
 Primitive (the five types listed previously)
  
 • 
  
 Non-primitive (objects)",NA
Finding out the value type – the typeof ,NA,NA
operator,"If you want to know the type of a variable or a value, you use the special 
 typeof 
 operator. This operator returns a string that represents the data type. The return 
 values of using 
 typeof
  are one of the following:
  
 • 
  
 ""number""
  
 • 
  
 ""string""
  
 • 
  
 ""boolean""
  
 [
  28 
 ]",NA
Numbers ,"The simplest number is an integer. If you assign 
 1
  to a variable and then use the 
 typeof
  operator, it returns the string 
 ""number""
 :
  
 > var n = 1; 
  
 > typeof n; 
  
 ""number""
  
 > 
 n 
 = 
 1234; 
  
 > 
 typeof 
 n; 
  
 ""number""
  
 In the preceding example, you can see that the second time you set a variable's value, you 
 don't need the 
 var
  statement.
  
 Numbers can also be floating point (decimals):
  
 > var n2 = 1.23; 
  
 > typeof n; 
  
 ""number""
  
 You can call 
 typeof
  directly on the value without assigning it to a variable first:
  
 > typeof 123; 
  
 ""number""",NA
Octal and hexadecimal numbers ,"When a number starts with a 0, it's considered an octal number. For example, the 
 octal 
 0377
  is the decimal 
 255
 :
  
 > var n3 = 0377; 
  
 > typeof n3; 
  
 ""number""
  
 > n3; 
  
 255
  
 [
  29 
 ]",NA
Exponent literals ,"1e1
  (also written as 
 1e+1
  or 
 1E1
  or 
 1E+1
 ) represents the number one with one zero 
 after it, or in other words, 10. Similarly, 
 2e+3
  means the number 2 with 3 zeros after it, 
 or 2000:
  
 > 
 1e1; 
  
 10
  
 > 1e+1; 
  
 10
  
 > 2e+3; 
  
 2000
  
 > typeof 2e+3; 
  
 ""number""
  
 [
  30 
 ]",NA
Infinity,"There is a special value in JavaScript called 
 Infinity
 . It represents a number too big for 
 JavaScript to handle. 
 Infinity
  is indeed a number, as typing 
 typeof Infinity 
 in the 
 console will confirm. You can also quickly check that a number with 308 zeros is ok, but 
 309 zeros is too much. To be precise, the biggest number JavaScript can handle is 
 1.7976931348623157e+308
 , while the smallest is 
 5e-324
 .
  
 > Infinity;
  
 Infinity
  
 > typeof Infinity;
  
 ""number""
  
 > 1e309;
  
 Infinity
  
 > 1e308;
  
 1e+308
  
 Dividing by zero gives you infinity:
  
 > var a = 6 / 0;
  
 > a;
  
 Infinity
  
 [
  31 
 ]",NA
NaN ,"What was this 
 NaN
  in the previous example? It turns out that despite its name, 
 ""Not a Number"", 
 NaN
  is a special value that is also a number:
  
 > typeof NaN; 
  
 ""number""
  
 > var a = NaN; 
  
 > a; 
  
 NaN
  
 [
  32 
 ]",NA
Strings,"A string is a sequence of characters used to represent text. In JavaScript, any value 
 placed between single or double quotes is considered a string. This means that 
 1
  is a 
 number, but 
 ""1""
  is a string. When used with strings, 
 typeof
  returns the string 
 ""string""
 :
  
 > var s = ""some characters"";
  
 > typeof s;
  
 ""string""
  
 > var s = 'some characters and numbers 123 5.87';
  
 > typeof s;
  
 ""string""
  
 Here's an example of a number used in the string context:
  
 > var s = '1';
  
 > typeof s;
  
 ""string""
  
 If you put nothing in quotes, it's still a string (an empty string):
  
 > var s = """"; typeof s;
  
 ""string""
  
 As you already know, when you use the plus sign with two numbers, this is the 
 arithmetic addition operation. However, if you use the plus sign with strings, this is a 
 string concatenation operation, and it returns the two strings glued together:
  
 > var s1 = ""web""; 
  
 > var s2 = ""site""; 
  
 > var s = s1 + s2; 
  
 [
  33 
 ]",NA
String conversions ,"When you use a number-like string (for example 
 ""1""
 ) as an operand in an arithmetic 
 operation, the string is converted to a number behind the scenes. This works for all 
 arithmetic operations except addition, because of its ambiguity:
  
 > var s = '1'; 
  
 > s = 3 * s; 
  
 > typeof s; 
  
 ""number""
  
 > s; 
  
 3
  
 > var s = '1'; 
  
 > s++; 
  
 > typeof s; 
  
 ""number""
  
 > s; 
  
 2
  
 A lazy way to convert any number-like string to a number is to multiply it by 1 
 (another way is to use a function called 
 parseInt()
 , as you'll see in the next chapter):
  
 > var s = ""100""; typeof 
 s; 
  
 ""string""
  
 > s = s * 1; 
  
 100
  
 > typeof s; 
  
 ""number""
  
 [
  34 
 ]",NA
Special strings ,"There are also strings with special meanings, as listed in the following table:
  
 String
  
 Meaning
  
 Example
  
 \\
  
 \
  is the escape character.
  
 > var s = 'I don't know';
  
 This is an error, because JavaScript 
  
 \'
  
 When you want to have quotes inside 
  
 thinks the string is 
 I don
  and the rest 
  
 \""
  
 your string, you escape them so that 
  
 JavaScript doesn't think they mean 
  
 is invalid code. The following 
  
 are valid:
  
 the end of the string.
  
  
 If you want to have an actual 
  
 backslash in the string, escape it with 
 another backslash.
  
 • 
 > var s = 'I don\'t 
 know';
  
 • 
 > var s = ""I don\'t 
 know"";
  
 • 
 > var s = ""I don't 
 know"";
  
 • 
 > var s = '""Hello"", he 
 said.';
  
 • 
 > var s = ""\""Hello\"", 
 he said."";
  
 Escaping the escape:
  
 > var s = ""1\\2""; s;
  
 ""1\2""
  
 [
  35 
 ]",NA
Booleans ,"There are only two values that belong to the Boolean data type: the values 
 true
  and 
 false
 , used without quotes:
  
 > var b = true; 
  
 > typeof b; 
  
 ""boolean""
  
 > var b = false; 
  
 > typeof b; 
  
 ""boolean""
  
 [
  36 
 ]",NA
Logical operators,"There are three operators, called logical operators, that work with Boolean values. 
 These are:
  
 • 
  
 !
  – logical NOT (negation)
  
 • 
  
 &&
  – logical AND
  
 • 
  
 ||
  – logical OR
  
 You know that when something is not true, it must be false. Here's how this is 
 expressed using JavaScript and the logical 
 !
  operator:
  
 > var b = !true;
  
 > b;
  
 false
  
 If you use the logical NOT twice, you get the original value:
  
 > var b = !!true;
  
 > b;
  
 true
  
 If you use a logical operator on a non-Boolean value, the value is converted to 
 Boolean behind the scenes:
  
 > var b = ""one"";
  
 > !b;
  
 false
  
 In the preceding case, the string value 
 ""one""
  is converted to a Boolean, 
 true
 , and 
 then negated. The result of negating 
 true
  is 
 false
 . In the next example, there's a 
 double negation, so the result is 
 true
 :
  
 > var b = ""one"";
  
 > !!b;
  
 true
  
 [
  37 
 ]",NA
Operator precedence ,"You might wonder why the previous expression (
 false && false || true && true
 ) 
 returned 
 true
 . The answer lies in the operator precedence. As you know from 
 mathematics: 
  
  
 > 1 + 2 * 3; 
  
  
 7 
  
 This is because multiplication has higher precedence over addition, so 
 2 * 3
  is evaluated 
 first, as if you typed: 
  
  
 > 1 + (2 * 3); 
  
  
 7 
  
 Similarly for logical operations, 
 !
  has the highest precedence and is executed first, 
 assuming there are no parentheses that demand otherwise. Then, in the order of 
 precedence, comes 
 &&
  and finally 
 ||
 . In other words, the following two code snippets are 
 the same: 
  
  
 > false && false || true && true; 
  
  
 true 
  
 and 
  
  
 > (false && false) || (true && true); 
  
  
 true
  
  
 Best practice
  
  
 Use parentheses instead of relying on operator precedence. 
  
 This makes your code easier to read and understand.
  
 [
  39 
 ]",NA
Lazy evaluation,"If you have several logical operations one after the other, but the result becomes clear at 
 some point before the end, the final operations will not be performed because they don't 
 affect the end result. Consider this:
  
 > true || false || true || false || true;
  
 true
  
 Since these are all OR operations and have the same precedence, the result will be 
 true
  
 if at least one of the operands is 
 true
 . After the first operand is evaluated, it becomes 
 clear that the result will be 
 true
 , no matter what values follow. So, the JavaScript engine 
 decides to be lazy (OK, efficient) and avoids unnecessary work by evaluating code that 
 doesn't affect the end result. You can verify this short-circuiting behavior by 
 experimenting in the console:
  
 > var b = 5;
  
 > true || (b = 6);
  
 true
  
 > b;
  
 5
  
 > true && (b = 6);
  
 6
  
 > b;
  
 6
  
 This example also shows another interesting behavior: if JavaScript encounters a 
 non-Boolean expression as an operand in a logical operation, the non-Boolean is 
 returned as a result:
  
 > true || ""something"";
  
 true
  
 > true && ""something"";
  
 ""something""
  
 > true && ""something"" && true;
  
 true
  
 [
  40 
 ]",NA
Comparison,"There's another set of operators that all return a Boolean value as a result of the 
 operation. These are the comparison operators. The following table lists them 
 together with example uses:
  
 Operator symbol
  
 Description
  
 Example
  
 ==
  
 Equality comparison: Returns true when 
  
 > 1 == 1;
  
 both operands are equal. The operands are 
  
 true
  
 converted to the same type before being 
  
 > 1 == 2;
  
 compared. Also called loose comparison.
  
 false
  
 > 1 == '1';
  
 true
  
 ===
  
 Equality and type comparison: Returns 
 true
  
 > 1 === '1';
  
 if both operands are equal and of the same 
  
 false
  
 type. It's better and safer to compare this 
  
 > 1 === 1;
  
 way because there's no behind-the-scenes 
  
 true
  
 type conversions. It is also called strict 
  
 comparison.
  
 [
  41 
 ]",NA
Undefined and null ,"If you try to use a non-existing variable, you'll get an error:
  
 > foo; 
  
 ReferenceError: foo is not 
 defined
  
 Using the 
 typeof
  operator on a non-existing variable is not an error. You get the 
 string 
 ""undefined""
  back:
  
 > typeof foo; 
  
 ""undefined""
  
 If you declare a variable without giving it a value, this is, of course, not an error. 
 But, the 
 typeof
  still returns 
 ""undefined""
 :
  
 > var somevar; 
  
 > somevar; 
  
 > typeof somevar; 
  
 ""undefined""
  
 This is because when you declare a variable without initializing it, JavaScript 
 automatically initializes it with the value 
 undefined
 :
  
 > var somevar; 
  
 > somevar === undefined; 
  
 true
  
 The 
 null
  value, on the other hand, is not assigned by JavaScript behind the scenes; it's 
 assigned by your code:
  
 > var somevar = null; 
  
 null
  
 > 
 somevar; 
  
 null
  
 > typeof somevar; 
  
 ""
 object
 ""
  
 Although the difference between 
 null
  and 
 undefined
  is small, it could be critical at 
 times. For example, if you attempt an arithmetic operation, you get different results:
  
 > var i = 1 + undefined; 
  
 > i; 
  
 NaN
  
 > var i = 1 + null; 
  
 > i; 
  
 1
  
 [
  43 
 ]",NA
Primitive data types recap ,"Let's quickly summarize some of the main points discussed so far:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 There are five primitive data types in JavaScript:
  
 °
  
 Number
  
 °
  
 String
  
 °
  
 Boolean
  
 °
  
 Undefined
  
 °
  
 Null
  
 Everything that is not a primitive data type is an object 
  
 The primitive number data type can store positive and negative integers or 
 floats, hexadecimal numbers, octal numbers, exponents, and the special 
 numbers 
 NaN
 , 
 Infinity
 , and 
 –Infinity 
  
 The string data type contains characters in quotes 
  
 The only values of the Boolean data type are 
 true
  and 
 false 
  
 The only value of the null data type is the value 
 null
  
 [
  44 
 ]",NA
Arrays,"Now that you know about the basic primitive data types in JavaScript, it's time to 
 move to a more powerful data structure—the array.
  
 So, what is an array? It's simply a list (a sequence) of values. Instead of using one 
 variable to store one value, you can use one array variable to store any number of 
 values as elements of the array. 
  
 To declare a variable that contains an empty array, you use square brackets with 
 nothing between them:
  
 > var a = [];
  
 To define an array that has three elements, you do this:
  
 > var a = [1, 2, 3];
  
 When you simply type the name of the array in the console, you get the contents of 
 your array:
  
 > a;
  
 [1, 2, 3]
  
 Now the question is how to access the values stored in these array elements. The 
 elements contained in an array are indexed with consecutive numbers starting from 
 zero. The first element has index (or position) 0, the second has index 1, and so on. 
  
 Here's the three-element array from the previous example:
  
 Index
  
 Value
  
 0
  
  
 1
  
  
 2
  
 1
  
  
 2
  
  
 3
  
 [
  45 
 ]",NA
Adding/updating array elements ,"Using the index, you can also update the values of the elements of the array. The 
 next example updates the third element (index 2) and prints the contents of the 
 new array:
  
 > a[2] = 'three'; 
  
 ""three""
  
 > a; 
  
 [1, 2, 
 ""three""]
  
 You can add more elements by addressing an index that didn't exist before:
  
 > a[3] = 'four'; 
  
 ""four""
  
 > a; 
  
 [1, 2, ""three"", 
 ""four""]
  
 If you add a new element, but leave a gap in the array, those elements in between 
 don't exist and return the 
 undefined
  value if accessed. Check out this example:
  
 > var a = [1, 2, 3]; 
  
 > a[6] = 'new'; 
  
 ""new""
  
 > a; 
  
 [1, 2, 3, undefined x 3, 
 ""new""]
  
 [
  46 
 ]",NA
Deleting elements ,"To delete an element, you use the 
 delete
  operator. However, after the deletion, the 
 length of the array does not change. In a sense, you get a hole in the array:
  
 > var a = [1, 2, 3]; 
  
 > delete a[1]; 
  
 true
  
 > a; 
  
 [1, undefined, 3]
  
 > typeof a[1]; 
  
 ""undefined""",NA
Arrays of arrays ,"Arrays can contain all types of values, including other arrays:
  
 > var a = [1, ""two"", false, null, undefined]; 
 > a; 
  
 [1, ""two"", false, null, undefined]
  
 > a[5] = [1, 2, 3]; 
  
 [1, 2, 3]
  
 > a; 
  
 [1, ""two"", false, null, undefined, 
 Array[3]]
  
 The 
 Array[3]
  in the result is clickable in the console and it expands the array values. 
 Let's see an example where you have an array of two elements, both of them being other 
 arrays:
  
 > var a = [[1, 2, 3], [4, 5, 6]]; 
  
 > a; 
  
 [Array[3], Array[3]]
  
 The first element of the array is 
 a[0]
 , and it's also an array:
  
 > a[0]; 
  
 [1, 2, 3]
  
 [
  47 
 ]",NA
Conditions and loops ,"Conditions
  provide a simple but powerful way to control the flow of code execution. 
 Loops
  allow you to perform repetitive operations with less code. Let's take a look at:
  
 • 
  
 if
  conditions
  
 • 
  
 switch
  statements
  
 • 
  
 while
 , 
 do-while
 , 
 for
 , and 
 for-in
  loops
  
 [
  48 
 ]",NA
The if condition ,"Here's a simple example of an 
 if
  condition:
  
 var result = '', a = 3; 
  
 if (a > 2) {
  
  
  result = 'a is greater than 2'; 
  
 }
  
 The parts of the 
 if
  condition are:
  
 • 
  
 The 
 if
  statement
  
 • 
  
 A condition in parentheses—""is 
 a
  greater than 2?""
  
 • 
  
 A block of code wrapped in 
 {}
  that executes if the condition is satisfied
  
 The condition (the part in parentheses) always returns a Boolean value, and may also 
 contain the following:
  
 • 
  
 A logical operation: 
 !
 , 
 &&
 , or 
 ||
  
 • 
  
 A comparison, such as 
 ===
 , 
 !=
 , 
 >
 , and so on
  
 • 
  
 Any value or variable that can be converted to a Boolean
  
 • 
  
 A combination of the above",NA
The else clause ,"There can also be an optional 
 else
  part of the 
 if
  condition. The 
 else
  statement is 
 followed by a block of code that runs if the condition evaluates to 
 false
 :
  
 if (a > 2) {
  
  
  result = 'a is greater than 2'; 
  
 } else {
  
  
  result = 'a is NOT greater than 2'; 
  
 }
  
 [
  49 
 ]",NA
Code blocks ,"In the preceding examples, you saw the use of code blocks. Let's take a moment to clarify 
 what a block of code is, because you use blocks extensively when constructing conditions 
 and loops.
  
 A block of code consists of zero or more expressions enclosed in curly brackets:
  
 {
  
  
  var a = 1;
  
  
  var b = 3; 
  
 }
  
 You can nest blocks within each other indefinitely:
  
 {
  
  
  var a = 1;
  
  
  var b = 3;
  
  
  var c, d;
  
  
  {
  
  
  c = a + b;
  
 [
  50 
 ]",NA
Checking if a variable exists ,"Let's apply the new knowledge about conditions for something practical. It's often 
 necessary to check whether a variable exists. The laziest way to do this is to simply put 
 the variable in the condition part of the 
 if
 , for example, 
 if (somevar) {...}
 . But, this 
 is not necessarily the best method. Let's take a look at an example that tests whether a 
 variable called 
 somevar
  exists, and if so, sets the 
 result
  variable to 
 yes
 :
  
 > var result = ''; 
  
 > if (somevar) { 
  
  
  result = 'yes'; 
  
  
  } 
  
 ReferenceError: somevar is not 
 defined
  
 > result; 
  
 """"
  
 [
  51 
 ]",NA
Alternative if syntax ,"When you have a simple condition, you can consider using an alternative 
 if
  syntax. 
  
 Take a look at this:
  
 var a = 1; 
  
 var result = ''; 
  
 if (a === 1) {
  
  
  result = ""a is one""; 
  
 } else {
  
  
  result = ""a is not 
 one""; 
  
 }
  
 You can also write this as:
  
 > var a = 1; 
  
 > var result = (a === 1) ? ""a is one"" : ""a is not one"";
  
 You should only use this syntax for simple conditions. Be careful not to abuse it, as it can 
 easily make your code unreadable. Here's an example.
  
 Let's say you want to make sure a number is within a certain range, say between 50 
 and 100:
  
 > var a = 123; 
  
 > a = a > 100 ? 100 : a < 50 ? 50: a; 
  
 > a; 
  
 100
  
 It may not be clear how this code works exactly because of the multiple 
 ?
 . Adding 
 parentheses makes it a little clearer:
  
 > var a = 123; 
  
 > a = (a > 100 ? 100 : a < 50) ? 50 : a; 
  
 > a; 
  
 50
  
 > var a = 123; 
  
 > a = a > 100 ? 100 : (a < 50 ? 50 : a); 
  
 > a; 
  
 100
  
 ?:
  is called a ternary operator because it takes three operands.
  
 [
  53 
 ]",NA
Switch ,"If you find yourself using an 
 if
  condition and having too many 
 else if
  parts, you could 
 consider changing the 
 if
  to a 
 switch
 :
  
 var a = '1',
  
  
  result = ''; 
  
 switch (a) { 
  
 case 1:
  
  
  result = 'Number 1';
  
  
  break; 
  
 case '1':
  
  
  result = 'String 1';
  
  
  break; 
  
 default:
  
  
  result = 'I don\'t know';
  
  
  break; 
  
 }
  
 The result after executing this is 
 ""String 1""
 . Let's see what the parts of a switch are:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 The 
 switch
  statement.
  
 An expression in parentheses. The expression most often contains a variable, but 
 can be anything that returns a value.
  
 A number of 
 case
  blocks enclosed in curly brackets.
  
 Each 
 case
  statement is followed by an expression. The result of the 
  
 expression is compared to the expression found after the 
 switch
  statement. If 
 the result of the comparison is 
 true
 , the code that follows the colon after the case 
 is executed.
  
 There is an optional 
 break
  statement to signal the end of the 
 case
  block. If 
 this 
 break
  statement is reached, the 
 switch
  is all done. Otherwise, if the 
 break
  is missing, the program execution enters the next 
 case
  block.
  
 There's an optional default case marked with the 
 default
  statement and 
 followed by a block of code. The default case is executed if none of the 
 previous cases evaluated to 
 true
 .
  
 [
  54 
 ]",NA
Loops,"The 
 if-else
  and 
 switch
  statements allow your code to take different paths, as if you're 
 at a crossroad and decide which way to go depending on a condition. Loops, on the other 
 hand, allow your code to take a few roundabouts before merging back into the main 
 road. How many repetitions? That depends on the result of evaluating a condition 
 before (or after) each iteration.
  
 Let's say you are (your program execution is) traveling from A to B. At some point, you 
 reach a place where you evaluate a condition, C. The result of evaluating C tells you if 
 you should go into a loop, L. You make one iteration and arrive at C again. 
  
 Then, you evaluate the condition once again to see if another iteration is needed. 
 Eventually, you move on your way to B.
  
  
 A
  
 C
  
 B
  
 L
  
 An infinite loop is when the condition is always 
 true
  and your code gets stuck in the 
 loop ""forever"". This is, of course, a logical error, and you should look out for such 
 scenarios.
  
 In JavaScript, there are four types of loops:
  
 • 
  
 while
  loops
  
 • 
  
 do-while
  loops
  
 • 
  
 for
  loops
  
 • 
  
 for-in
  loops",NA
While loops,"while
  loops are the simplest type of iteration. They look like this:
  
 var i = 0;
  
 while (i < 10) {
  
  i++;
  
 }
  
 [
  56 
 ]",NA
Do-while loops,"do-while
  loops are a slight variation of 
 while
  loops. An example is shown as 
 follows:
  
 var i = 0;
  
 do {
  
  i++;
  
 } while (i < 10);
  
 Here, the 
 do
  statement is followed by a code block and a condition after the block. This 
 means that the code block is always executed, at least once, before the condition is 
 evaluated.
  
 If you initialize 
 i
  to 
 11
  instead of 
 0
  in the last two examples, the code block in the first 
 example (the 
 while
  loop) will not be executed, and 
 i
  will still be 
 11
  at the end, while 
 in the second (the 
 do-while
  loop), the code block will be executed once and 
 i 
 will 
 become 
 12
 .",NA
For loops,"for
  is the most widely used type of loop, and you should make sure you're 
 comfortable with this one. It requires just a little bit more in terms of syntax.
  
  
 A
  
 0
  
 C
  
 B
  
 ++
  
 L
  
  
 In addition to the condition C and the code block L, you have the following:
  
 • 
  
 • 
  
 Initialization—code that is executed before you even enter the loop 
 (marked with 
 0
  in the diagram)
  
 Increment—code that is executed after every iteration (marked with 
 ++
  in 
 the diagram)
  
 [
  57 
 ]",NA
For-in loops,"The 
 for-in
  loop is used to iterate over the elements of an array (or an object, as you'll 
 see later). This is its only use; it cannot be used as a general-purpose repetition 
 mechanism that replaces 
 for
  or 
 while
 . Let's see an example of using a 
 for-in
  to loop 
 through the elements of an array. But, bear in mind that this is for informational purposes 
 only, as 
 for-in
  is mostly suitable for objects, and the regular 
 for
  loop should be used for 
 arrays.
  
 In this example, you iterate over all of the elements of an array and print out the 
 index (the key) and the value of each element:
  
 // example for information only
  
 // for-in loops are used for objects
  
 // regular for is better suited for arrays
  
 var a = ['a', 'b', 'c', 'x', 'y', 'z'];
  
 var result = '\n';
  
 for (var i in a) {
  
  result += 'index: ' + i + ', value: ' + a[i] + '\n';
  
 }
  
 The result is:
  
 "" 
  
 index: 0, value: a 
  
 index: 1, value: b 
  
 index: 2, value: c 
  
 index: 3, value: x 
  
 index: 4, value: y 
  
 index: 5, value: z 
  
 ""
  
 [
  60 
 ]",NA
Comments,"One last thing for this chapter: comments. Inside your JavaScript program, you can put 
 comments. These are ignored by the JavaScript engine and don't have any effect on how 
 the program works. But, they can be invaluable when you revisit your code after a few 
 months, or transfer the code to someone else for maintenance.
  
 Two types of comments are allowed:
  
 • 
  
 • 
  
 Single line comments start with 
 //
  and end at the end of the line.
  
 Multiline comments start with 
 /*
  and end with 
 */
  on the same line or any 
 subsequent line. Note that any code in between the comment start and the 
 comment end is ignored.
  
 Some examples are as follows:
  
 // beginning of line
  
 var a = 1; // anywhere on the line
  
 /* multi-line comment on a single line */
  
 /*
  
  comment that spans several lines
  
 */
  
 There are even utilities, such as JSDoc and YUIDoc, that can parse your code and 
 extract meaningful documentation based on your comments.",NA
Summary,"In this chapter, you learned a lot about the basic building blocks of a JavaScript 
 program. Now you know the primitive data types:
  
 • 
  
 Number
  
 • 
  
 String
  
 • 
  
 Boolean
  
 • 
  
 Undefined
  
 • 
  
 Null
  
 [
  61 
 ]",NA
Exercises ,"1. What is the result of executing each of these lines in the console? Why?
  
 > var a; typeof a; 
  
 > var s = '1s'; 
 s++; 
  
 > !!""false""; 
  
 > !!undefined; 
  
 > typeof -Infinity; 
  
 > 10 % ""0""; 
  
 > undefined == 
 null; 
  
 > false === """"; 
  
 > typeof ""2E+2""; 
  
 > a = 3e+3; a++;
  
 2. What is the value of 
 v
  after the following?
  
 > var v = v || 10;
  
 Experiment by first setting 
 v
  to 
 100
 , 
 0
 , or 
 null
 .
  
 3. Write a small program that prints out the multiplication table. Hint: use a 
  
 loop 
 nested inside another loop.
  
 [
  62 
 ]",NA
Functions,"Mastering functions is an important skill when you learn any programming language, 
 and even more so when it comes to JavaScript. This is because JavaScript has many uses 
 for functions, and much of the language's flexibility and expressiveness comes from 
 them. Where most programming languages have a special syntax for some object-
 oriented features, JavaScript just uses functions. This chapter will cover:
  
 • 
  
 How to define and use a function
  
 • 
  
 Passing arguments to a function
  
 • 
  
 Predefined functions that are available to you ""for free""
  
 • 
  
 The scope of variables in JavaScript
  
 • 
  
 The concept that functions are just data, albeit a special type of data
  
 Understanding these topics will provide a solid base that will allow you to dive into 
 the second part of the chapter, which shows some interesting applications of 
 functions:
  
 • 
  
 Using anonymous functions
  
 • 
  
 Callbacks
  
 • 
  
 Immediate (self-invoking) functions
  
 • 
  
 Inner functions (functions defined inside other functions)• 
  
 Functions that return functions
  
 • 
  
 Functions that redefine themselves
  
 • 
  
 Closures",NA
What is a function?,"Functions allow you to group together some code, give this code a name, and reuse it 
 later, addressing it by the name you gave it. Let's see an example:
  
 function sum(a, b) {
  
  var c = a + b;
  
  return c;
  
 }
  
 The parts that make up a function are shown as follows:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 The 
 function
  statement.
  
 The name of the function, in this case 
 sum
 .
  
 The function parameters, in this case 
 a
  and 
 b
 . A function can take any 
 number of parameters, separated by commas.
  
 A code block, also called the body of the function.
  
 The 
 return
  statement. A function always returns a value. If it doesn't return a 
 value explicitly, it implicitly returns the value 
 undefined
 .
  
 Note that a function can only return a single value. If you need to return more values, 
 you can simply return an array that contains all of the values you need as elements of 
 this array.
  
 The preceding syntax is called a function declaration. It's just one of the ways to 
 create a function in JavaScript, and more ways are coming up.",NA
Calling a function,"In order to make use of a function, you need to call it. You call a function simply by 
 using its name optionally followed by any number of values in parentheses. ""To 
 invoke"" a function is another way of saying ""to call"".
  
 Let's call the function 
 sum()
 , passing two arguments and assigning the value that the 
 function returns to the variable 
 result
 :
  
 > var result = sum(1, 2);
  
 > result;
  
 3
  
 [
  64 
 ]",NA
Parameters,"When defining a function, you can specify what parameters the function expects to 
 receive when it's called. A function may not require any parameters, but if it does and you 
 forget to pass them, JavaScript will assign the value 
 undefined
  to the ones you skipped. 
 In the next example, the function call returns 
 NaN
  because it tries to sum 
 1
  and 
 undefined
 :
  
 > sum(1);
  
 NaN
  
 Technically speaking, there is a difference between parameters and arguments, 
 although the two are often used interchangeably. Parameters are defined together 
 with the function, while arguments are passed to the function when it's called. 
  
 Consider this:
  
 > function sum(a, b) {
  
  return a + b;
  
  }
  
 > sum(1, 2);
  
 Here, 
 a
  and 
 b
  are parameters, while 
 1
  and 
 2
  are arguments.
  
 JavaScript is not picky at all when it comes to accepting arguments. If you pass more 
 than the function expects, the extra ones will be silently ignored:
  
 > sum(1, 2, 3, 4, 5);
  
 3
  
 What's more, you can create functions that are flexible about the number of 
 parameters they accept. This is possible thanks to the special value 
 arguments
  that is 
 created automatically inside each function. Here's a function that simply returns 
 whatever arguments are passed to it:
  
 > function args() {
  
  return arguments;
  
  }
  
 > args();
  
 []
  
 > args( 1, 2, 3, 4, true, 'ninja');
  
 [1, 2, 3, 4, true, ""ninja""]
  
 [
  65 
 ]",NA
Predefined functions ,"There are a number of functions that are built into the JavaScript engine and are available 
 for you to use. Let's take a look at them. While doing so, you'll have a chance to 
 experiment with functions, their arguments and return values, and become comfortable 
 working with functions. Following is a list of the built-in functions:
  
 • 
  
 parseInt()
  
 • 
  
 parseFloat()
  
 • 
  
 isNaN()
  
 [
  66 
 ]",NA
parseInt(),"parseInt()
  takes any type of input (most often a string) and tries to make an integer out 
 of it. If it fails, it returns 
 NaN
 :
  
 > 
 parseInt('123'); 
  
 123
  
 > parseInt('abc123'); 
  
 NaN
  
 > parseInt('1abc23'); 
  
 1
  
 > parseInt('123abc'); 
  
 123
  
 The function accepts an optional second parameter, which is the 
 radix
 , telling the 
 function what type of number to expect—decimal, hexadecimal, binary, and so on. For 
 example, trying to extract a decimal number out of the string 
 FF
  makes no sense, so the 
 result is 
 NaN
 , but if you try 
 FF
  as a hexadecimal, then you get 
 255
 :
  
 > parseInt('FF', 10);
  
 NaN
  
 > parseInt('FF', 16);
  
 255
  
 [
  67 
 ]",NA
parseFloat(),"parseFloat()
  is similar to 
 parseInt()
 , but it also looks for decimals when trying to 
 figure out a number from your input. This function takes only one parameter:
  
 > parseFloat('123');
  
 123
  
 > parseFloat('1.23');
  
 1.23
  
 [
  68 
 ]",NA
isNaN() ,"Using 
 isNaN()
 , you can check if an input value is a valid number that can safely be 
 used in arithmetic operations. This function is also a convenient way to check 
 whether 
 parseInt()
  or 
 parseFloat()
  (or any arithmetic operation) succeeded:
  
 > isNaN(NaN); 
  
 true
  
 > isNaN(123); 
  
 false
  
 > isNaN(1.23); 
  
 false
  
 > isNaN(parseInt('abc123')); 
  
 true
  
 [
  69 
 ]",NA
isFinite() ,"isFinite()
  checks whether the input is a number that is neither 
 Infinity
  nor 
 NaN
 :
  
 > isFinite(Infinity); 
  
 false
  
 > isFinite(-
 Infinity); 
  
 false
  
 > isFinite(12); 
  
 true
  
 > 
 isFinite(1e308); 
  
 true
  
 > 
 isFinite(1e309); 
  
 false
  
 If you are wondering about the results returned by the last two calls, 
 remember from the previous chapter that the biggest number in JavaScript is 
 1.7976931348623157e+308
 , so 
 1e309
  is effectively infinity.",NA
Encode/decode URIs,"In a 
 Uniform Resource Locator
  (
 URL
 ) or a 
 Uniform Resource Identifier
  (
 URI
 ), some 
 characters have special meanings. If you want to ""escape"" those characters, you can use 
 the functions 
 encodeURI()
  or 
 encodeURIComponent()
 . The first one will return a usable 
 URL, while the second one assumes you're only passing a part of the URL, such as a query 
 string for example, and will encode all applicable characters:
  
 > var url = 'http://www.packtpub.com/script.php?q=this and that'; 
 > encodeURI(url); 
  
 ""http://www.packtpub.com/scr%20ipt.php?q=this%20and%20that""
  
 [
  70 
 ]",NA
eval(),"eval()
  takes a string input and executes it as a JavaScript code:
  
 > eval('var ii = 2;');
  
 > ii;
  
 2
  
 So, 
 eval('var ii = 2;')
   is the same as 
 var ii = 2;
 .
  
 eval()
  can be useful sometimes, but should be avoided if there are other options. 
  
 Most of the time there are alternatives, and in most cases the alternatives are more 
 elegant and easier to write and maintain. ""Eval is evil"" is a mantra you can often hear from 
 seasoned JavaScript programmers. The drawbacks of using 
 eval()
  are:
  
 • 
  
 • 
  
 Security
  – JavaScript is powerful, which also means it can cause damage. If you 
 don't trust the source of the input you pass to 
 eval(),
  just don't use it.
  
 Performance
  – It's slower to evaluate ""live"" code than to have the code 
 directly in the script.",NA
A bonus – the alert() function,"Let's take a look at another common function—
 alert()
 . It's not part of the core 
 JavaScript (it's nowhere to be found in the ECMA specification), but it's provided by the 
 host environment—the browser. It shows a string of text in a message box. It can also be 
 used as a primitive debugging tool, although the debuggers in modern browsers are 
 much better suited for this purpose.
  
 Here's a screenshot showing the result of executing the code 
 alert(""hello!"")
 :
  
  
 [
  71 
 ]",NA
Scope of variables,"It's important to note, especially if you have come to JavaScript from another language, 
 that variables in JavaScript are not defined in a block scope, but in a function scope. This 
 means that if a variable is defined inside a function, it's not visible outside of the 
 function. However, if it's defined inside an 
 if
  or a 
 for
  code block, it's visible outside the 
 block. The term ""global variables"" describes variables you define outside of any function 
 (in the global program code), as opposed to ""local variables"", which are defined inside a 
 function. The code inside a function has access to all global variables as well as to its 
 own local ones.
  
 In the next example:
  
 • 
  
 The 
 f()
 function has access to the 
 global
  variable
  
 • 
  
 Outside the 
 f()
 function, the 
 local
  variable doesn't exist
  
 var global = 1;
  
 function f() {
  
  var local = 2;
  
  global++;
  
  return global;
  
 }
  
 Let's test this:
  
 > f();
  
 2
  
 > f();
  
 3
  
 > local;
  
 ReferenceError: local is not defined
  
 [
  72 
 ]",NA
Variable hoisting,"Here's an interesting example that shows an important aspect of local versus global 
 scoping:
  
 var a = 123;
  
 function f() {
  
  alert(a);
  
  var a = 1;
  
  alert(a);
  
 }
  
 f();
  
 You might expect that the first 
 alert()
  will display 
 123
  (the value of the global variable 
 a
 ) and the second will display 
 1
  (the local variable 
 a
 ). But, this is not the case. The first 
 alert will show 
 undefined
 . This is because inside the function the local scope is more 
 important than the global scope. So, a local variable overwrites any global variable with 
 the same name. At the time of the first 
 alert()
 , the variable 
 a 
 was not yet defined 
 (hence the value 
 undefined
 ), but it still existed in the local space due to the special 
 behavior called 
 hoisting
 .
  
 When your JavaScript program execution enters a new function, all the variables 
 declared anywhere in the function are moved (or elevated, or hoisted) to the top of the 
 function. This is an important concept to keep in mind. Further, only the declaration is 
 hoisted, meaning only the presence of the variable is moved to the top. Any assignments 
 stay where they are. In the preceding example, the declaration of the local variable 
 a
  
 was hoisted to the top. Only the declaration was hoisted, but not the assignment to 1. It's 
 as if the function was written like this:
  
 var a = 123;
  
 function f() {
  
  var a; // same as: var a = undefined;
  
  alert(a); // undefined
  
  a = 1;
  
  alert(a); // 1
  
 }
  
 You can also adopt the single var pattern mentioned previously in the best practice 
 section. In this case, you'll be doing a sort of manual variable hoisting to prevent 
 confusion with the JavaScript hoisting behavior.
  
 [
  74 
 ]",NA
Functions are data ,"Functions in JavaScript are actually data. This is an important concept that we'll need 
 later on. This means that you can create a function and assign it to a variable:
  
 var f = function () {
  
  
  return 1; 
  
 };
  
 This way of defining a function is sometimes referred to as 
 function literal notation
 .
  
 The part 
 function () { return 1; }
  is a 
 function expression
 . A function 
 expression can optionally have a name, in which case it becomes a 
 named function 
 expression
  (
 NFE
 ). So, this is also allowed, although rarely seen in practice (and causes 
 IE to mistakenly create two variables in the enclosing scope: 
 f
  and 
 myFunc
 ):
  
 var f = function myFunc() {
  
  
  return 1; 
  
 };
  
 As you can see, there's no difference between a named function expression and a 
 function declaration. But they are, in fact, different. The only way to distinguish between 
 the two is to look at the context in which they are used. Function 
  
 declarations may only appear in program code (in a body of another function or in the 
 main program). You'll see many more examples of functions later on in the book that 
 will clarify these concepts. 
  
 When you use the 
 typeof
  operator on a variable that holds a function value, it 
 returns the string 
 ""function""
 :
  
 > function define() {
  
  
  return 1; 
  
  
  }
  
 > var express = function () { 
  
  
  return 1; 
  
  
  };
  
 > typeof define; 
  
 ""function""
  
 > typeof express; 
  
 ""function""
  
 [
  75 
 ]",NA
Anonymous functions,"As you now know, there exists a function expression syntax where you can have a 
 function defined like this:
  
 var f = function (a) {
  
  return a;
  
 };
  
 This is also often called an anonymous function (as it doesn't have a name), 
 especially when such a function expression is used even without assigning it to a 
 variable. In this case, there can be two elegant uses for such anonymous functions:
  
 • 
  
 • 
  
 You can pass an anonymous function as a parameter to another function. The 
 receiving function can do something useful with the function that you pass.
  
 You can define an anonymous function and execute it right away.
  
 Let's see these two applications of anonymous functions in more detail.
  
 [
  76 
 ]",NA
Callback functions ,"Because a function is just like any other data assigned to a variable, it can be defined, 
 copied, and also passed as an argument to other functions.
  
 Here's an example of a function that accepts two functions as parameters, executes 
 them, and returns the sum of what each of them returns:
  
 function invokeAdd(a, b) 
 {
  
  
  return a() + b(); 
  
 }
  
 Now let's define two simple additional functions (using a function declaration 
 pattern) that only return hardcoded values:
  
 function one() {
  
  
  return 1; 
  
 }
  
 function two() {
  
  
  return 2; 
  
 }
  
 Now you can pass those functions to the original function, 
 invokeAdd()
 , and 
 get the result:
  
 > invokeAdd(one, 
 two); 
  
 3
  
 Another example of passing a function as a parameter is to use anonymous functions 
 (function expressions). Instead of defining 
 one()
  and 
 two()
 , you can simply do the 
 following:
  
 > invokeAdd(function () {return 1; }, function () {return 2; }); 
 3
  
 Or, you can make it more readable as shown in the following code:
  
 > invokeAdd(
  
  
  function () { return 1; }, 
  
  
  function () { return 2; }
  
  
  ); 
  
 3
  
 [
  77 
 ]",NA
Callback examples ,"Take a look at this common scenario: you have a function that returns a value, which 
 you then pass to another function. In our example, the first function, 
 multiplyByTwo(),
  accepts three parameters, loops through them, multiplies them by 
 two, and returns an array containing the result. The second function, 
 addOne()
 , takes 
 a value, adds one to it, and returns it:
  
 function multiplyByTwo(a, b, c) {
  
  
  var i, ar = [];
  
  
  for (i = 0; i < 3; i++) {
  
  
  ar[i] = arguments[i] * 2;
  
  
  }
  
  
  return ar; 
  
 }
  
 function addOne(a) {
  
  
  return a + 1; 
  
 }
  
 [
  78 
 ]",NA
Immediate functions ,"So far, we have discussed using anonymous functions as callbacks. Let's see another 
 application of an anonymous function: calling a function immediately after it's defined. 
 Here's an example:
  
 (
  
  
  function () {
  
  
  alert('boo');
  
  
  } 
  
 )();
  
 The syntax may look a little scary at first, but all you do is simply place a function 
 expression inside parentheses followed by another set of parentheses. The second set 
 says ""execute now"" and is also the place to put any arguments that your anonymous 
 function might accept:
  
 (
  
  
  function (name) {
  
  
  alert('Hello ' + name + '!');
  
  
  } 
  
 )('dude');
  
 Alternatively, you can move the closing of the first set of parentheses to the end. Both of 
 these work:
  
 (function () {
  
  
  // ...
  
 }());
  
 [
  80 
 ]",NA
Inner (private) functions ,"Bearing in mind that a function is just like any other value, there's nothing that stops 
 you from defining a function inside another function:
  
 function outer(param) {
  
  
  function inner(theinput) {
  
  
  return theinput * 2;
  
  
  }
  
  
  return 'The result is ' + inner(param); 
  
 }
  
 [
  81 
 ]",NA
Functions that return functions,"As mentioned earlier, a function always returns a value, and if it doesn't do it explicitly 
 with 
 return
 , then it does so implicitly by returning 
 undefined
 . A function can return 
 only one value, and this value can just as easily be another function:
  
 function a() {
  
  
  alert('A!');
  
  
  return function () 
 {
  
  
  alert('B!');
  
  
  }; 
  
 }
  
 In this example, the function 
 a()
  does its job (says 
 A!
 ) and returns another function that 
 does something else (says 
 B!
 ). You can assign the return value to a variable and then use 
 this variable as a normal function:
  
 > var newFunc = a();
  
 > newFunc();
  
 [
  82 
 ]",NA
"Function, rewrite thyself!","Because a function can return a function, you can use the new function to replace the old 
 one. Continuing with the previous example, you can take the value returned by the call 
 to 
 a()
  to overwrite the actual 
 a()
  function:
  
 > a = a();
  
 The above alerts 
 A!
 , but the next time you call 
 a()
  it alerts 
 B!
 . This is useful when a 
 function has some initial one-off work to do. The function overwrites itself after the 
 first call in order to avoid doing unnecessary repetitive work every time it's called.
  
 In the preceding example, the function was redefined from the outside—the returned 
 value was assigned back to the function. But, the function can actually rewrite itself from 
 the inside:
  
 function a() {
  
  alert('A!');
  
  a = function () {
  
  alert('B!');
  
  };
  
 }
  
 If you call this function for the first time, it will:
  
 • 
  
 Alert 
 A!
  (consider this as being the one-off preparatory work)
  
 • 
  
 Redefine the global variable 
 a
 , assigning a new function to it
  
 Every subsequent time that the function is called, it will alert 
 B!
  
 Here's another example that combines several of the techniques discussed in the last 
 few sections of this chapter:
  
 var a = (function () {
  
  function someSetup() {
  
 [
  83 
 ]",NA
Closures,"The rest of the chapter is about closures (what better way to close a chapter?). 
  
 Closures can be a little hard to grasp initially, so don't feel discouraged if you don't ""get it"" 
 during the first read. You should go through the rest of the chapter and experiment with 
 the examples on you own, but if you feel you don't fully understand the concept, you can 
 come back to it later when the topics discussed previously in this chapter have had a 
 chance to sink in.
  
 Before moving on to closures, let's first review and expand on the concept of scope in 
 JavaScript.",NA
Scope chain,"As you know, in JavaScript, there is no curly braces scope, but there is function scope. 
 A variable defined in a function is not visible outside the function, but a variable 
 defined in a code block (for example an 
 if
  or a 
 for
  loop) is visible outside the block:
  
 > var a = 1; 
  
 > function f() {
  
  var b = 1; 
  
  return a;
  
  }
  
 > f();
  
 1
  
 > b;
  
 ReferenceError: b is not defined
  
 The variable 
 a
  is in the global space, while 
 b
  is in the scope of the function 
 f()
 . So:
  
 • 
  
 Inside 
 f()
 , both 
 a
  and 
 b
  are visible
  
 • 
  
 Outside 
 f()
 , 
 a
  is visible, but 
 b
  is not
  
 If you define a function 
 inner()
  nested inside 
 outer()
 , 
 inner()
  will have access to 
 variables in its own scope, plus the scope of its ""parents"". This is known as a scope chain, 
 and the chain can be as long (deep) as you need it to be:
  
 var global = 1;
  
 function outer() {
  
  var outer_local = 2;
  
  function inner() {
  
  var inner_local = 3;
  
  return inner_local + outer_local + global;
  
 [
  85 
 ]",NA
Breaking the chain with a closure ,"Let's introduce closures with an illustration. Let's look at this code and see what's 
 happening there:
  
 var a = ""global variable""; 
  
 var F = function () {
  
  
  var b = ""local variable"";
  
  
  var N = function () {
  
  
  var c = ""inner local"";
  
  
  }; 
  
 };
  
 First, there is the global scope 
 G
 . Think of it as the universe, as if it contains everything:
  
 G
  
 a1
  
 a2
  
 a3
  
 a4
  
 You are here
  
 [
  86 
 ]",NA
Closure #1,"Take a look at this function, which is the same as before, only 
 F
  returns 
 N
  and also 
 N 
 returns 
 b
 , to which it has access via the scope chain:
  
 var a = ""global variable"";
  
 var F = function () {
  
  var b = ""local variable"";
  
  var N = function () {
  
  var c = ""inner local"";
  
  return b;
  
  };
  
  return N;
  
 };
  
 The function 
 F
  contains the variable 
 b
 , which is local, and therefore inaccessible from 
 the global space:
  
 > b;
  
 ReferenceError: b is not defined
  
 The function 
 N
  has access to its private space, to the 
 F()
  function's space, and to the 
 global space. So, it can see 
 b
 . Since 
 F()
  is callable from the global space (it's a global 
 function), you can call it and assign the returned value to another global variable. The 
 result: a new global function that has access to the 
 F()
  function's private space:
  
 > var inner = F();
  
 > inner();
  
 ""local variable""",NA
Closure #2,"The final result of the next example will be the same as the previous example, but the 
 way to achieve it is a little different. 
 F()
  doesn't return a function, but instead it 
 creates a new global function, 
 inner()
 , inside its body.
  
 [
  88 
 ]",NA
A definition and closure #3,"Every function can be considered a closure. This is because every function maintains a 
 secret link to the environment (the scope) in which it was created. But, most of the time 
 this scope is destroyed unless something interesting happens (as shown above) that 
 causes this scope to be maintained.
  
 Based on what you've seen so far, you can say that a closure is created when a 
 function keeps a link to its parent scope even after the parent has returned. And, 
 every function is a closure because, at the very least, every function maintains access 
 to the global scope, which is never destroyed.
  
 Let's see one more example of a closure, this time using the function parameters. 
  
 Function parameters behave like local variables to this function, but they are 
 implicitly created (you don't need to use 
 var
  for them). You can create a function 
 that returns another function, which in turn returns its parent's parameter:
  
 function F(param) {
  
  var N = function () {
  
  return param;
  
  };
  
 [
  89 
 ]",NA
Closures in a loop ,"Let's take a look at a canonical rookie mistake when it comes to closures. It can easily 
 lead to hard-to-spot bugs, because on the surface, everything looks normal.
  
 Let's loop three times, each time creating a new function that returns the loop 
 sequence number. The new functions will be added to an array and the array is 
 returned at the end. Here's the function:
  
 function F() {
  
  
  var arr = [], i;
  
  
  for (i = 0; i < 3; i++) {
  
  
  arr[i] = function () {
  
    
  return i;
  
  
  };
  
  
  }
  
  
  return arr; 
  
 }
  
 Let's run the function, assigning the result to the array 
 arr
 :
  
 > var arr = F();
  
 Now you have an array of three functions. Let's invoke them by adding parentheses after 
 each array element. The expected behavior is to see the loop sequence printed out: 
 0
 , 
 1
 , 
 and 
 2
 . Let's try:
  
 > arr[0](); 
  
 3
  
 > arr[1](); 
  
 3
  
 [
  90 
 ]",NA
Getter/setter,"Let's see two more examples of using closures. The first one involves the creation of 
 getter and setter functions. Imagine you have a variable that should contain a specific 
 type of values or a specific range of values. You don't want to expose this variable 
 because you don't want just any part of the code to be able to alter its value. 
  
 You protect this variable inside a function and provide two additional functions: one to 
 get the value and one to set it. The one that sets it could contain some logic to validate 
 a value before assigning it to the protected variable. Let's make the validation part 
 simple (for the sake of keeping the example short) and only accept number values.
  
 You place both the getter and the setter functions inside the same function that 
 contains the 
 secret
  variable so that they share the same scope:
  
 var getValue, setValue;
  
 (function () {
  
  var secret = 0;
  
  getValue = function () {
  
 [
  92 
 ]",NA
Iterator,"The last closure example (also the last example in the chapter) shows the use of a 
 closure to accomplish an iterator functionality.
  
 You already know how to loop through a simple array, but there might be cases where 
 you have a more complicated data structure with different rules as to what the sequence 
 of values has. You can wrap the complicated ""who's next"" logic into an easy-to-use 
 next()
  function. Then, you simply call 
 next()
  every time you need the consecutive 
 value.
  
 For this example, let's just use a simple array and not a complex data structure. 
 Here's an initialization function that takes an input array and also defines a secret 
 pointer, 
 i
 , that will always point to the next element in the array:
  
 function setup(x) {
  
  
  var i = 0;
  
  
  return function () 
 {
  
  
  return x[i++];
  
  
  }; 
  
 }
  
 [
  93 
 ]",NA
Summary,"You have now completed the introduction to the fundamental concepts related to 
 functions in JavaScript. You've been laying the groundwork that will allow you to quickly 
 grasp the concepts of object-oriented JavaScript and the patterns used in modern 
 JavaScript programming. So far, we've been avoiding the OO features, but as you have 
 reached this point in the book, it's only going to get more interesting from here on in. Let's 
 take a moment and review the topics discussed in this chapter:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 The basics of how to define and invoke (call) a function using either a 
 function declaration syntax or a function expression
  
 Function parameters and their flexibility
  
 Built-in functions—
 parseInt()
 , 
 parseFloat()
 , 
 isNaN()
 , 
 isFinite()
 , and 
 eval()
 —and the four functions to encode/decode a URL
  
 The scope of variables in JavaScript—no curly braces scope, variables have 
 only function scope and the scope chain
  
 Functions as data—a function is like any other piece of data that you assign to 
 a variable and a lot of interesting applications follow from this, such as:
  
 °
  
 Private functions and private variables
  
 °
  
 Anonymous functions
  
 °
  
 Callbacks
  
 °
  
 Immediate functions
  
 °
  
 Functions overwriting themselves
  
 Closures
  
 [
  94 
 ]",NA
Exercises ,"1. Write a function that converts a hexadecimal color, for example blue 
  
  
 (
 #0000FF
 ), into its RGB representation 
 rgb(0, 0, 255)
 . Name your 
  
  
 function 
 getRGB()
  and test it with the following code. Hint: treat the 
  
  
 string as an array of characters:
  
 > var a = getRGB(""#00FF00"");
  
 > a; 
  
 ""rgb(0, 255, 0)""
  
 2. What do each of these lines print in the console?
  
 > parseInt(1e1);
  
 > parseInt('1e1');
  
 > parseFloat('1e1');
  
 > isFinite(0/10);
  
 > isFinite(20/0);
  
 > isNaN(parseInt(NaN));
  
 3. What does this following code alert?
  
 var a = 1;
  
 function f() {
  
  
  function n() 
 {
  
  
  alert(a);
  
  
  }
  
  
  var a = 2;
  
  
  n(); 
  
 }
  
 f();
  
 4. All these examples alert 
 ""Boo!""
 . Can you explain why?
  
 °
  
 Example 1:
  
 var f = alert; 
  
 eval('f(""Boo!"")');
  
 °
  
 Example 2:
  
 var e; 
  
 var f = alert; 
  
 eval('e=f')('Boo!')
 ;
  
 °
  
 Example 3:
  
 (function(){
  
  
  return 
 alert;} 
  
 )()('Boo!');
  
 [
  95 
 ]",NA
Objects,"Now that you've mastered JavaScript's primitive data types, arrays, and functions, it's 
 time to make true to the promise of the book title and talk about objects.
  
 In this chapter, you will learn:
  
 • 
  
 How to create and use objects
  
 • 
  
 What are the constructor functions
  
 • 
  
 What types of built-in JavaScript objects exist and what they can do for you",NA
From arrays to objects,"As you already know from 
 Chapter 2
 , 
 Primitive Data Types, Arrays, Loops, and 
 Conditions, 
 an array is just a list of values. Each value has an index (a numeric 
 key) that starts from zero and increments by one for each value.
  
 > var myarr = ['red', 'blue', 'yellow', 'purple'];
  
 > myarr;
  
  [""red"", ""blue"", ""yellow"", ""purple""].
  
 > myarr[0];
  
 ""red""
  
 > myarr[3];
  
 ""purple""",NA
"Elements, properties, methods, and members ","When talking about arrays, you say that they contain elements. When talking about 
 objects, you say that they contain properties. There isn't any significant difference in 
 JavaScript; it's just the terminology that people are used to, likely from other 
 programming languages.
  
 A property of an object can point to a function, because functions are just data. 
 Properties that point to functions are also called methods. In the following example, 
 talk
  is a method:
  
 var dog = {
  
  
  name: 'Benji',
  
  
  talk: function () {
  
  
  alert('Woof, woof!');
  
  
  } 
  
 };
  
 [
  99 
 ]",NA
Hashes and associative arrays ,"In some programming languages, there is a distinction between:
  
 • 
  
 • 
  
 A regular array, also called an 
 indexed
  or 
 enumerated
  array 
 (the keys are numbers)
  
 An associative array, also called a 
 hash
  or a dictionary (the keys are strings)
  
 JavaScript uses arrays to represent indexed arrays and objects to represent 
 associative arrays. If you want a hash in JavaScript, you use an object.",NA
Accessing an object's properties ,"There are two ways to access a property of an object:
  
 • 
  
 Using the square bracket notation, for example 
 hero['occupation']
  
 • 
  
 Using the dot notation, for example 
 hero.occupation
  
 The dot notation is easier to read and write, but it cannot always be used. The same 
 rules apply as for quoting property names: if the name of the property is not a valid 
 variable name, you cannot use the dot notation.
  
 Let's take the 
 hero
  object again:
  
 var hero = {
  
  
  breed: 'Turtle',
  
  
  occupation: 'Ninja' 
  
 };
  
 Accessing a property with the dot notation:
  
 > hero.breed; 
  
 ""Turtle""
  
 [
  100 
 ]",NA
Calling an object's methods,"You know a method is just a property that happens to be a function, so you access 
 methods the same way as you would access properties: using the dot notation or using 
 square brackets. Calling (invoking) a method is the same as calling any other function: you 
 just add parentheses after the method name, which effectively says ""Execute!"".
  
 > var hero = {
  
  breed: 'Turtle',
  
  occupation: 'Ninja',
  
  say: function () {
  
  return 'I am ' + hero.occupation;
  
  }
  
  };
  
 > hero.say();
  
 ""I am Ninja""
  
 If there are any parameters that you want to pass to a method, you proceed as with 
 normal functions:
  
 > hero.say('a', 'b', 'c');
  
 Because you can use the array-like square brackets to access a property, this means 
 you can also use brackets to access and invoke methods:
  
 > hero['say']();
  
 This is not a common practice unless the method name is not known at the time of 
 writing code, but is instead defined at runtime:
  
 var method = 'say';
  
 hero[method]();
  
  
 Best practice tip: no quotes (unless you have to)
  
  
 Use the dot notation to access methods and properties and 
  
 don't quote properties in your object literals.",NA
Altering properties/methods,"JavaScript allows you to alter the properties and methods of existing objects at any 
 time. This includes adding new properties or deleting them. You can start with a 
 ""blank"" object and add properties later. Let's see how you can go about doing this.
  
 An object without properties is shown as follows:
  
 > var hero = {};
  
 [
  102 
 ]",NA
Using the this value ,"In the previous example, the 
 sayName()
  method used 
 hero.name
  to access the 
 name 
 property of the 
 hero
  object. When you're inside a method though, there is another way 
 to access the object the method belongs to: by using the special value 
 this
 .
  
 > var hero = {
  
  
  name: 'Rafaelo',
  
  
  sayName: function () {
  
    
  return this.name;
  
  
  }
  
  
  }; 
  
 > hero.sayName(); 
  
 ""Rafaelo""
  
 So, when you say 
 this
 , you're actually saying ""this object"" or ""the current object"".",NA
Constructor functions ,"There is another way to create objects: by using constructor functions. Let's see 
 an example:
  
 function Hero() {
  
  
  this.occupation = 'Ninja'; 
  
 }
  
 In order to create an object using this function, you use the 
 new
  operator, like this:
  
 > var hero = new Hero(); 
  
 > hero.occupation; 
  
 ""Ninja""
  
 A benefit of using constructor functions is that they accept parameters, which can be 
 used when creating new objects. Let's modify the constructor to accept one 
 parameter and assign it to the 
 name
  property:
  
 function Hero(name) {
  
  
  this.name = name;
  
  
  this.occupation = 'Ninja';
  
  
  this.whoAreYou = function () {
  
  
  return ""I'm "" +
  
    
  this.name +
  
    
  "" and I'm a "" +
  
    
  this.occupation;
  
  
  }; 
  
 }
  
 [
  104 
 ]",NA
The global object,"You have already learned a bit about global variables (and how you should avoid 
 them). You also know that JavaScript programs run inside a host environment (the 
 browser for example). Now that you know about objects, it's time for the whole 
 truth: the host environment provides a global object and all global 
  
 variables are accessible as properties of the global object.
  
 If your host environment is the web browser, the global object is called 
 window
 . 
  
 Another way to access the global object (and this is also true in most other 
 environments) is to use 
 this
  outside a constructor function, for example in the 
 global program code outside any function.
  
 As an illustration, you can declare a global variable outside any function, such as:
  
 > var a = 1;
  
 [
  105 
 ]",NA
The constructor property ,"When an object is created, a special property is assigned to it behind the scenes—the 
 constructor
  property. It contains a reference to the constructor function used to 
 create this object.
  
 Continuing from the previous example:
  
 > h2.constructor; 
  
 function Hero(name) {
  
  
  this.name = name; 
  
 }
  
 Because the 
 constructor
  property contains a reference to a function, you might as 
 well call this function to produce a new object. The following code is like saying, ""I 
 don't care how object 
 h2
  was created, but I want another one just like it"":
  
 > var h3 = new h2.constructor('Rafaello'); 
  
 > h3.name; 
  
 ""Rafaello""
  
 If an object was created using the object literal notation, its constructor is the built-in 
 Object()
  constructor function (there is more about this later in this chapter):
  
 > var o = {}; 
  
 > o.constructor; 
  
 function Object() { [native code] }
  
 > typeof o.constructor; 
  
 ""function""
  
 [
  107 
 ]",NA
The instanceof operator,"With the 
 instanceof
  operator, you can test if an object was created with a specific 
 constructor function:
  
 > function Hero() {}
  
 > var h = new Hero();
  
 > var o = {};
  
 > h instanceof Hero;
  
 true
  
 > h instanceof 
 Object; 
  
 true
  
 > o instanceof Object;
  
 true
  
 Note that you don't put parentheses after the function name (you don't use 
 h 
 instanceof Hero()
 ). This is because you're not invoking this function, but just 
 referring to it by name, as with any other variable.",NA
Functions that return objects,"In addition to using constructor functions and the 
 new
  operator to create objects, you can 
 also use a normal function to create objects without 
 new
 . You can have a function that 
 does a bit of preparatory work and has an object as a return value.
  
 For example, here's a simple 
 factory()
  function that produces objects:
  
 function factory(name) {
  
  return {
  
  name: name
  
  };
  
 }
  
 Using the 
 factory()
  function:
  
 > var o = factory('one'); 
  
 > o.name; 
  
 ""one""
  
 > o.constructor; 
  
 function Object() { [native code] }
  
 In fact, you can also use constructor functions and return objects different from 
 this
 . This means you can modify the default behavior of the constructor function. 
 Let's see how.
  
 [
  108 
 ]",NA
Passing objects ,"When you assign an object to a different variable or pass it to a function, you only pass a 
 reference to that object. Consequently, if you make a change to the reference, you're 
 actually modifying the original object.
  
 [
  109 
 ]",NA
Comparing objects ,"When you compare objects, you'll get 
 true
  only if you compare two references to the 
 same object. Comparing two distinct objects that happen to have the exact same 
 methods and properties returns 
 false
 .
  
 Let's create two objects that look the same:
  
 > var fido  = {breed: 'dog'}; 
  
 > var benji = {breed: 'dog'};
  
 Comparing them returns 
 false
 :
  
 > benji === fido; 
  
 false
  
 > benji == fido; 
  
 false
  
 You can create a new variable, 
 mydog
 , and assign one of the objects to it. This way, 
 mydog
  actually points to the same object:
  
 > var mydog = benji;
  
 [
  110 
 ]",NA
Objects in the WebKit console,"Before diving into the built-in objects in JavaScript, let's quickly say a few words 
 about working with objects in the WebKit console.
  
 After playing around with the examples in this chapter, you might have already noticed 
 how objects are displayed in the console. If you create an object and type its name, you'll 
 get an arrow pointing to the word 
 Object
 .
  
 The object is clickable and expands to show you a list of all of the properties of the 
 object. If a property is also an object, there is an arrow next to it too, so you can 
 expand this as well. This is handy as it gives you an insight into exactly what this 
 object contains.
  
  
 You can ignore 
 __proto__
  for now; there's more about it in the next chapter.
  
 [
  111 
 ]",NA
console.log,"The console also offers you an object called 
 console
  and a few methods, such as 
 console.log()
  and 
 console.error()
 , which you can use to display any value you 
 want in the console.
  
  
 console.log()
  is convenient when you want to quickly test something, as well as in 
 your real scripts when you want to dump some intermediate debugging information. 
  
 Here's how you can experiment with loops for example:
  
 > for (var i = 0; i < 5; i++) {
  
  console.log(i); 
  
  }
  
 0
  
 1
  
 2
  
 3
  
 4",NA
Built-in objects,"Earlier in this chapter, you came across the 
 Object()
  constructor function. It's returned 
 when you create objects with the object literal notation and access their 
 constructor
  
 property. 
 Object()
  is one of the built-in constructors; there are a few others, and in the 
 rest of this chapter you'll see all of them.
  
 [
  112 
 ]",NA
Object,"Object
  is the parent of all JavaScript objects, which means that every object you create 
 inherits from it. To create a new ""empty"" object, you can use the literal notation or the 
 Object()
  constructor function. The following two lines are equivalent:
  
 > var o = {};
  
 > var o = new Object();
  
 As mentioned before, an ""empty"" (or ""blank"") object is not completely useless because 
 it already contains several 
 inherited
  methods and properties. In this book, ""empty"" 
 means an object like 
 {}
  that has no properties of its own other than the ones it 
 automatically gets. Let's see a few of the properties that even ""blank"" objects already 
 have:
  
 • 
  
 • 
  
 • 
  
 The 
 o.constructor
  property returns a reference to the constructor function 
 o.toString()
  is a method that returns a string representation of the object 
 o.valueOf()
  returns a single-value representation of the object; often this is 
 the object itself
  
 Let's see these methods in action. First, create an object:
  
 > var o = new Object();
  
 [
  113 
 ]",NA
Array,"Array()
  is a built-in function that you can use as a constructor to create arrays:
  
 > var a = new Array();
  
 This is equivalent to the array literal notation:
  
 > var a = [];
  
 [
  114 
 ]",NA
A few array methods ,"In addition to the methods inherited from the parent 
 Object
 , array objects also have 
 specialized methods for working with arrays, such as 
 sort()
 , 
 join()
 , and 
 slice()
 , 
 among others (see 
 Appendix C
 , 
 Built-in Objects
 , for the full list).
  
 Let's take an array and experiment with some of these methods:
  
 > var a = [3, 5, 1, 7, 'test'];
  
 The 
 push()
  method appends a new element to the end of the array. The 
 pop() 
 method 
 removes the last element. 
 a.push('new')
  works like 
 a[a.length] = 'new' 
 and 
 a.pop()
  is like 
 a.length--
 .
  
 push()
  returns the length of the changed array, whereas 
 pop()
  returns the 
 removed element:
  
 > a.push('new'); 
  
 6
  
 > a;
  
  [3, 5, 1, 7, ""test"", 
 ""new""]
  
 > 
 a.pop(); 
  
 ""new""
  
 > a;
  
  [3, 5, 1, 7, 
 ""test""]
  
 The 
 sort()
  method sorts the array and returns it. In the next example, after the sort, 
 both 
 a
  and 
 b
  point to the same array:
  
 > var b = a.sort(); 
  
 > b; 
  
 [1, 3, 5, 7, ""test""]
  
 > a === 
 b; 
  
 true
  
 The 
 join()
  method returns a string containing the values of all the elements in the 
 array glued together using the string parameter passed to 
 join()
 :
  
 > a.join(' is not '); 
  
 ""1 is not 3 is not 5 is not 7 is not test""
  
 [
  117 
 ]",NA
Function,"You already know that functions are a special data type. But, it turns out that there's 
 more to it than that: functions are actually objects. There is a built-in constructor 
 function called 
 Function()
  that allows for an alternative (but not necessarily 
 recommended) way to create a function.
  
 The following example shows three ways to define a function:
  
 > function sum(a, b) { // function 
 declaration
  
  return a + b;
  
  
  }
  
 [
  118 
 ]",NA
Properties of function objects,"Like any other object, functions have a 
 constructor
  property that contains a 
 reference to the 
 Function()
  constructor function. This is true no matter which 
 syntax you used to create the function.
  
 > function myfunc(a) {
  
  
  return a; 
  
  
  } 
  
 > myfunc.constructor; 
  
 function Function() { [native code] 
 }
  
 Functions also have a 
 length
  property, which contains the number of formal 
 parameters the function expects.
  
 > function myfunc(a, b, c) {
  
   
  return true;
  
  
  } 
  
 > myfunc.length;
  
   
  3",NA
Prototype,"One of the most widely used properties of function objects is the 
 prototype 
 property. You'll see this property discussed in detail in the next chapter, but 
 for now, let's just say:
  
 • 
  
 • 
  
 • 
  
 The 
 prototype
  property of a function object points to another object Its 
 benefits shine only when you use this function as a constructor All objects 
 created with this function keep a reference to the 
 prototype 
 property 
 and can use its properties as their own
  
 Let's see a quick example to demonstrate the 
 prototype
  property. Take a simple 
 object that has a property 
 name
  and a method 
 say()
 .
  
 var ninja = {
  
  
  name: 'Ninja',
  
  
  say: function () {
  
  
  return 'I am a ' + this.name;
  
  
  } 
  
 };
  
 [
  120 
 ]",NA
Methods of function objects ,"Function objects, being a descendant of the top parent 
 Object
 , get the default 
 methods such as 
 toString()
 . When invoked on a function, the 
 toString() 
 method returns the source code of the function.
  
 > function myfunc(a, b, c) {
  
  return a + b + c;
  
  }
  
 > myfunc.toString();
  
 ""function myfunc(a, b, c) {
  
  return a + b + c;
  
 }""
  
 If you try to peek into the source code of the built-in functions, you'll get the string 
 [native code]
  instead of the body of the function.
  
 > parseInt.toString();
  
 ""function parseInt() { [native code] }""
  
 [
  121 
 ]",NA
Call and apply,"Function objects have 
 call()
  and 
 apply()
  methods. You can use them to invoke a 
 function and pass any arguments to it.
  
 These methods also allow your objects to ""borrow"" methods from other objects and 
 invoke them as their own. This is an easy and powerful way to reuse code.
  
 Let's say you have a 
 some_obj
  object, which contains the method 
 say()
 .
  
 var some_obj = {
  
  name: 'Ninja',
  
  say: function (who) {
  
  return 'Haya ' + who + ', I am a ' + this.name;
  
  }
  
 };
  
 You can call the 
 say()
  method, which internally uses 
 this.name
  to gain access to its 
 own 
 name
  property.
  
 > some_obj.say('Dude');
  
 ""Haya Dude, I am a Ninja""
  
 Now let's create a simple object, 
 my_obj
 , which only has a 
 name
  property.
  
 > var my_obj = {name: 'Scripting guru'};
  
 my_obj
  likes the 
 some_obj
  object's 
 say()
  method so much that it wants to invoke it as 
 its own. This is possible using the 
 call()
  method of the 
 say()
  function object.
  
 > some_obj.say.call(my_obj, 'Dude');
  
 ""Haya Dude, I am a Scripting guru""
  
 It worked! But what happened here? You invoked the 
 call()
  method of the 
 say() 
 function object passing two parameters: the object 
 my_obj
  and the string 
 'Dude'
 . The 
 result is that when 
 say()
  is invoked, the references to the 
 this
  value that it contains 
 point to 
 my_obj
 . This way, 
 this.name
  doesn't return 
 Ninja
 , but 
  
 Scripting guru
  instead.
  
 [
  122 
 ]",NA
The arguments object revisited,"In the previous chapter, you have seen how, from inside a function, you have access to 
 something called 
 arguments
 , which contains the values of all the parameters passed to 
 the function:
  
 > function f() {
  
  return arguments;
  
  }
  
 > f(1, 2, 3);
  
 [1, 2, 3]
  
 arguments
  looks like an array, but it is actually an array-like object. It resembles an 
 array because it contains indexed elements and a 
 length
  property. However, the 
 similarity ends there, as 
 arguments
  doesn't provide any of the array methods, such as 
 sort()
  or 
 slice()
 .
  
 However, you can convert 
 arguments
  to an array and benefit from all the array 
 goodies. Here's what you can do, practicing your newly-learned 
 call()
  method:
  
 > function f() {
  
  var args = [].slice.call(arguments);
  
  return args.reverse();
  
  }
  
 > f(1, 2, 3, 4);
  
 [4, 3, 2, 1]
  
 [
  123 
 ]",NA
Inferring object types ,"You can see that you have this array-like 
 arguments
  object looking so much like an 
 array object. How can you reliably tell the difference between the two? Additionally, 
 typeof
  returns 
 object
  when used with arrays. Therefore, how can you tell the 
 difference between an object and an array?
  
 The silver bullet is the 
 Object
  object's 
 toString()
  method. It gives you the internal 
 class name used to create a given object.
  
 > Object.prototype.toString.call({}); 
  
 ""[object Object]""
  
 > Object.prototype.toString.call([]); 
  
 ""[object Array]""
  
 You have to call the original 
 toString()
  method as defined in the prototype of the 
 Object
  constructor. Otherwise, if you call the 
 Array
  function's 
 toString()
 , it will 
 give you a different result, as it's been overridden for the specific purposes of the array 
 objects:
  
 > [1, 2, 3].toString(); 
  
 ""1,2,3""
  
 This is the same as:
  
 > Array.prototype.toString.call([1, 2, 3]); 
  
 ""1,2,3""
  
 Let's have some more fun with 
 toString()
 . Make a handy reference to save typing:
  
 > var toStr = Object.prototype.toString;
  
 Differentiate between an array and the array-like object 
 arguments
 :
  
 > (function () {
  
  
  return toStr.call(arguments);
  
  
  }()); 
  
 ""[object Arguments]""
  
 You can even inspect DOM elements:
  
 > toStr.call(document.body); 
  
 ""[object HTMLBodyElement]""
  
 [
  124 
 ]",NA
Boolean,"Your journey through the built-in objects in JavaScript continues, and the next three are 
 fairly straightforward; they merely wrap the primitive data types Boolean, number, and 
 string.
  
 You already know a lot about Booleans from 
 Chapter 2
 , 
 Primitive Data Types, Arrays, 
 Loops, and Conditions
 . Now, let's meet the 
 Boolean()
  constructor:
  
 > var b = new Boolean();
  
 It's important to note that this creates a new object, 
 b
 , and not a primitive Boolean 
 value. To get the primitive value, you can call the 
 valueOf()
  method (inherited from 
 Object
  and customized):
  
 > var b = new Boolean();
  
 > typeof b;
  
 ""object""
  
 > typeof b.valueOf();
  
 ""boolean""
  
 > b.valueOf();
  
 false
  
 Overall, objects created with the 
 Boolean()
  constructor are not too useful, as they 
 don't provide any methods or properties other than the inherited ones.
  
 The 
 Boolean()
  function, when called as a normal function without 
 new
 , converts 
 non-Booleans to Booleans (which is like using a double negation 
 !!value
 ):
  
 > Boolean(""test"");
  
 true
  
 > Boolean("""");
  
 false
  
 > Boolean({});
  
 true
  
 Apart from the six falsy values, everything else is true in JavaScript, including all objects. 
 This also means that all Boolean objects created with 
 new Boolean()
  are also true, as 
 they are objects:
  
 > Boolean(new Boolean(false));
  
 true
  
 [
  125 
 ]",NA
Number ,"Similarly to 
 Boolean()
 , the 
 Number()
  function can be used as:
  
 • 
  
 • 
  
 A constructor function (with 
 new
 ) to create objects.
  
 A normal function in order to try to convert any value to a number. This is 
 similar to the use of 
 parseInt()
  or 
 parseFloat()
 .
  
  
  
 > var n = Number('12.12'); 
  
  
  
 > n; 
  
  
  
 12.12 
  
  
  
 > typeof n; 
  
  
  
 ""number"" 
  
  
  
 > var n = new Number('12.12'); 
  
  
  
 > typeof n; 
  
  
  
 ""object"" 
  
 Because functions are objects, they can also have properties. The 
 Number()
  function has 
 constant built-in properties that you cannot modify: 
  
  
 > Number.MAX_VALUE; 
  
  
 1.7976931348623157e+308 
  
  
 > Number.MIN_VALUE; 
  
  
 5e-324 
  
  
 > Number.POSITIVE_INFINITY; 
  
  
 Infinity 
  
  
 > Number.NEGATIVE_INFINITY;
  
  
 -Infinity 
  
  
 > Number.NaN; 
  
  
 NaN 
  
 The number objects provide three methods: 
 toFixed()
 , 
 toPrecision()
 , and 
 toExponential()
  (see 
 Appendix C
 , 
 Built-in Objects
 , for more details): 
  
  
 > var n = new Number(123.456); 
  
  
 > n.toFixed(1); 
  
  
 ""123.5""
  
 [
  126 
 ]",NA
String ,"You can use the 
 String()
  constructor function to create string objects. String objects 
 provide convenient methods for text manipulation.
  
 Here's an example that shows the difference between a string object and a primitive 
 string data type:
  
 > var primitive = 
 'Hello'; 
  
 > typeof primitive; 
  
 ""string""
  
 > var obj = new String('world'); 
  
 > typeof obj; 
  
 ""object""
  
 [
  127 
 ]",NA
A few methods of string objects ,"Let's experiment with a few of the methods you can call on string objects 
 (see 
 Appendix C
 , 
 Built-in Objects
 , for the full list).
  
 Start off by creating a string object: 
  
  
 > var s = new String(""Couch potato""); 
  
 toUpperCase()
  and 
 toLowerCase()
  transforms the capitalization of the string: 
  
 > s.toUpperCase(); 
  
  
 ""COUCH POTATO"" 
  
  
 > s.toLowerCase(); 
  
  
 ""couch potato""
  
 [
  129 
 ]",NA
Math,"Math
  is a little different from the other built-in global objects you have seen 
 previously. It's not a function, and therefore cannot be used with 
 new
  to create 
 objects. 
 Math
  is a built-in global object that provides a number of methods and 
 properties for mathematical operations.
  
 The 
 Math
  object's properties are constants, so you can't change their values. Their 
 names are all in uppercase to emphasize the difference between them and a normal 
 property (similar to the constant properties of the 
 Number()
  constructor). Let's see a 
 few of these constant properties:
  
 • 
  
 The constant π:
  
 > Math.PI;
  
  3.141592653589793
  
 • 
  
 Square root of 2:
  
 > Math.SQRT2;
  
  1.4142135623730951
  
 • 
  
 Euler's constant:
  
 > Math.E;
  
  2.718281828459045
  
 • 
  
 Natural logarithm of 2:
  
 > Math.LN2;
  
  0.6931471805599453
  
 [
  132 
 ]",NA
Date ,"Date()
  is a constructor function that creates date objects. You can create a new object by 
 passing: 
  
 • 
  
 Nothing (defaults to today's date) 
  
 • 
  
 A date-like string 
  
 • 
  
 Separate values for day, month, time, and so on
  
 • 
  
 A timestamp
  
 Following is an object instantiated with today's date/time:
  
 > new Date(); 
  
 Wed Feb 27 2013 23:49:28 GMT-0800 
 (PST)
  
 The console displays the result of the 
 toString()
  method called on the date 
 object, so you get this long string 
 Wed Feb 27 2013 23:49:28 GMT-0800 
 (PST) 
 as a representation of the date object.
  
 Here are a few examples of using strings to initialize a date object. Note how many 
 different formats you can use to specify the date:
  
 > new Date('2015 11 12'); 
  
 Thu Nov 12 2015 00:00:00 GMT-0800 
 (PST)
  
 > new Date('1 1 2016'); 
  
 Fri Jan 01 2016 00:00:00 GMT-0800 
 (PST)
  
 > new Date('1 mar 2016 5:30'); 
  
 Tue Mar 01 2016 05:30:00 GMT-0800 
 (PST)
  
 The 
 Date
  constructor can figure out a date from different strings, but this is not 
 really a reliable way of defining a precise date, for example when passing user input 
 to the constructor. The better way is to pass numeric values to the 
 Date() 
 constructor representing:
  
 • 
  
 Year
  
 [
  134 
 ]",NA
Methods to work with date objects,"Once you've created a date object, there are lots of methods you can call on that object. 
 Most of the methods can be divided into 
 set*()
  and 
 get*()
  methods, for example, 
 getMonth()
 , 
 setMonth()
 , 
 getHours()
 , 
 setHours()
 , and so on. Let's see some 
 examples.
  
 Creating a date object:
  
 > var d = new Date(2015, 1, 1);
  
 > d.toString();
  
 Sun Feb 01 2015 00:00:00 GMT-0800 (PST)
  
 Setting the month to March (months start from 0):
  
 > d.setMonth(2);
  
 1425196800000
  
 > d.toString();
  
 Sun Mar 01 2015 00:00:00 GMT-0800 (PST)
  
 Getting the month:
  
 > d.getMonth();
  
 2
  
 In addition to all the methods of date objects, there are also two methods (plus one 
 more added in ES5) that are properties of the 
 Date()
  function/object. These do not 
 need a date object; they work just like the 
 Math
  object's methods. In class-based 
 languages, such methods would be called static because they don't require an instance.
  
 [
  136 
 ]",NA
Calculating birthdays,"Let's see one final example of working with 
 Date
  objects. I was curious about which day 
 my birthday falls on in 2016:
  
 > var d = new Date(2016, 5, 20);
  
 > d.getDay();
  
 1
  
 Starting the count from 0 (Sunday), 1 means Monday. Is that so?
  
 > d.toDateString();
  
 ""Mon Jun 20 2016""
  
 OK, good to know, but Monday is not necessarily the best day for a party. So, how about a 
 loop that shows how many times June 20th is a Friday from year 2016 to year 3016, or 
 better yet, let's see the distribution of all the days of the week. After all, with all the 
 progress in DNA hacking, we're all going to be alive and kicking in 3016.
  
 First, let's initialize an array with seven elements, one for each day of the week. These will 
 be used as counters. Then, as a loop goes up to 3016, let's increment the counters:
  
 var stats = [0, 0, 0, 0, 0, 0, 0];
  
 The loop:
  
 for (var i = 2016; i < 3016; i++) {
  
  stats[new Date(i, 5, 20).getDay()]++;
  
 }
  
 And the result:
  
 > stats;
  
 [140, 146, 140, 145, 142, 142, 145]
  
 142 Fridays and 145 Saturdays. Woo-hoo!",NA
RegExp,"Regular expressions provide a powerful way to search and manipulate text. Different 
 languages have different implementations (think ""dialects"") of the regular expressions 
 syntax. JavaScript uses the Perl 5 syntax.
  
 Instead of saying ""regular expression"", people often shorten it to ""regex"" or ""regexp"".
  
 [
  138 
 ]",NA
Properties of RegExp objects ,"Regular expression objects have the following properties: 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 global
 : If this property is 
 false
 , which is the default, the search stops when the 
 first match is found. Set this to 
 true
  if you want all matches. 
  
 ignoreCase
 : When the match is case insensitive, the defaults to 
 false 
 (meaning the default is a case sensitive match).
  
 multiline
 : Search matches that may span over more than one line default to 
 false
 .
  
 lastIndex
 : The position at which to start the search; this defaults to 0. 
 source
 : Contains the regexp pattern.
  
 None of these properties, except for 
 lastIndex
 , can be changed once the object has 
 been created.
  
 [
  139 
 ]",NA
Methods of RegExp objects,"Regex objects provide two methods you can use to find matches: 
 test()
  and 
 exec()
 . 
 They both accept a string parameter. 
 test()
  returns a Boolean (
 true
  when there's a 
 match, 
 false
  otherwise), while 
 exec()
  returns an array of matched strings. Obviously, 
 exec()
  is doing more work, so use 
 test()
  unless you really need to do something with 
 the matches. People often use regular expressions to validate data, in this case, 
 test()
  
 should be enough.
  
 In the following example, there is no match because of the capital 
 J
 :
  
 > /j.*t/.test(""Javascript"");
  
 false
  
 A case insensitive test gives a positive result:
  
 > /j.*t/i.test(""Javascript"");
  
 true
  
 [
  140 
 ]",NA
String methods that accept regular expressions as ,NA,NA
arguments ,"Previously in this chapter, you learned about string objects and how you can use the 
 indexOf()
  and 
 lastIndexOf()
 methods to search within text. Using these methods, 
 you can only specify literal string patterns to search. A more powerful solution would be 
 to use regular expressions to find text. String objects offer you this ability.
  
 String objects provide the following methods that accept regular expression objects as 
 parameters: 
  
 • 
  
 match()
  returns an array of matches
  
 • 
  
 search()
  returns the position of the first match
  
 • 
  
 replace()
  allows you to substitute matched text with another string
  
 • 
  
 split()
  also accepts a regexp when splitting a string into array elements",NA
search() and match(),"Let's see some examples of using the 
 search()
  and 
 match()
  methods. First, you 
 create a string object:
  
 > var s = new String('HelloJavaScriptWorld');
  
 Using 
 match()
 , you get an array containing only the first match:
  
 > s.match(/a/);
  
 [""a""]
  
 Using the 
 g
  modifier, you perform a global search, so the result array contains two 
 elements:
  
 > s.match(/a/g);
  
 [""a"", ""a""]
  
 A case insensitive match is as follows:
  
 > s.match(/j.*a/i);
  
 [""Java""]
  
 [
  141 
 ]",NA
replace(),"replace()
  allows you to replace the matched text with some other string. The 
 following example removes all capital letters (it replaces them with blank strings):
  
 > s.replace(/[A-Z]/g, '');
  
 ""elloavacriptorld""
  
 If you omit the 
 g
  modifier, you're only going to replace the first match:
  
 > s.replace(/[A-Z]/, '');
  
 ""elloJavaScriptWorld""
  
 When a match is found, if you want to include the matched text in the replacement 
 string, you can access it using 
 $&
 . Here's how to add an underscore before the match 
 while keeping the match:
  
 > s.replace(/[A-Z]/g, ""_$&""); 
  
 ""_Hello_Java_Script_World""
  
 When the regular expression contains groups (denoted by parentheses), the matches of 
 each group are available as 
 $1
  for the first group, 
 $2
  the second, and so on.
  
 > s.replace(/([A-Z])/g, ""_$1""); 
  
 ""_Hello_Java_Script_World""
  
 Imagine you have a registration form on your web page that asks for an e-mail 
 address, username, and password. The user enters their e-mail, and then your 
 JavaScript kicks in and suggests the username, taking it from the e-mail address:
  
 > var email = ""stoyan@phpied.com""; 
  
 > var username = email.replace(/(.*)@.*/, ""$1""); 
 > username; 
  
 ""stoyan""",NA
Replace callbacks,"When specifying the replacement, you can also pass a function that returns a string. This 
 gives you the ability to implement any special logic you may need before specifying the 
 replacements:
  
 > function replaceCallback(match) {
  
  return ""_"" + match.toLowerCase();
  
 [
  142 
 ]",NA
split(),"You already know about the 
 split()
  method, which creates an array from an input 
 string and a delimiter string. Let's take a string of comma-separated values and split 
 it:
  
 > var csv = 'one, two,three ,four';
  
 > csv.split(',');
  
 [""one"", "" two"", ""three "", ""four""]
  
 Because the input string happens to have random inconsistent spaces before and after 
 the commas, the array result has spaces too. With a regular expression, you can fix this 
 using 
 \s*
 , which means ""zero or more spaces"":
  
 > csv.split(/\s*,\s*/);
  
 [""one"", ""two"", ""three"", ""four""]",NA
Passing a string when a RegExp is expected,"One last thing to note is that the four methods that you have just seen (
 split()
 , 
 match()
 , 
 search()
 , and 
 replace()
 ) can also take strings as opposed to regular 
 expressions. In this case, the string argument is used to produce a new regex as if it 
 was passed to 
 new RegExp()
 .
  
 An example of passing a string to 
 replace
  is shown as follows:
  
 > ""test"".replace('t', 'r');
  
 ""rest""
  
 The above is the same as:
  
 > ""test"".replace(new RegExp('t'), 'r');
  
 ""rest""
  
 When you pass a string, you cannot set modifiers the way you do with a normal 
 constructor or regex literal. There's a common source of errors when using a string 
 instead of a regular expression object for string replacements, and it's due to the fact 
 that the 
 g
  modifier is 
 false
  by default. The outcome is that only the first string is 
 replaced, which is inconsistent with most other languages and a little confusing. 
  
 For example:
  
 > ""pool"".replace('o', '*');
  
 ""p*ol""
  
 Most likely, you want to replace all occurrences:
  
 > ""pool"".replace(/o/g, '*');
  
 ""p**l""
  
 [
  144 
 ]",NA
Error objects,"Errors happen, and it's good to have the mechanisms in place so that your code can 
 realize that there has been an error condition and can recover from it in a graceful 
 manner. JavaScript provides the statements 
 try
 , 
 catch
 , and 
 finally
  to help you deal 
 with errors. If an error occurs, an error object is thrown. Error objects are created by 
 using one of these built-in constructors: 
 EvalError
 , 
 RangeError
 , 
 ReferenceError
 , 
 SyntaxError
 , 
 TypeError
 , and 
 URIError
 . All of these constructors inherit from 
 Error
 .
  
 Let's just cause an error and see what happens. What's a simple way to cause an 
 error? Just call a function that doesn't exist. Type this into the console:
  
 > iDontExist();
  
 You'll get something like this:
  
  
 The display of errors can vary greatly between browsers and other host 
  
 environments. In fact, most recent browsers tend to hide the errors from the users. 
  
 However, you cannot assume that all of your users have disabled the display of errors, 
 and it is your responsibility to ensure an error-free experience for them. The previous 
 error propagated to the user because the code didn't try to trap (catch) this error. The 
 code didn't expect the error and was not prepared to handle it. Fortunately, it's trivial 
 to trap the error. All you need is the 
 try
  statement followed by a 
 catch
  statement.
  
 This code hides the error from the user:
  
 try {
  
  iDontExist();
  
 } catch (e) {
  
  // do nothing
  
 }
  
 [
  145 
 ]",NA
Summary,"In 
 Chapter 2
 , 
 Primitive Data Types, Arrays, Loops, and Conditions
 , you saw that there are 
 five primitive data types (number, string, Boolean, null, and undefined) and we also said 
 that everything that is not a primitive piece of data is an object. Now you also know that:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Objects are like arrays, but you specify the keys. 
  
 Objects contain properties. 
  
 Properties can be functions (functions are data; remember 
 var f = 
 function () {};
 ). Properties that are functions are also called methods.
  
 Arrays are actually objects with predefined numeric properties and an 
 auto-incrementing 
 length
  property.
  
 Array objects have a number of convenient methods (such as 
 sort() 
 or 
 slice()
 ).
  
 Functions are also objects and they have properties (such as 
 length
  and 
 prototype
 ) and methods (such as 
 call()
  and 
 apply()
 ). 
  
 Regarding the five primitive data types, apart from 
 undefined
  and 
 null
 , the other 
 three have the corresponding constructor functions: 
 Number()
 , 
 String()
 , and 
 Boolean()
 . Using these, you can create objects, called wrapper objects, which contain 
 methods for working with primitive data elements.
  
 Number()
 , 
 String()
 , and 
 Boolean()
  can be invoked:
  
 • 
  
 • 
  
 With the 
 new
  operator—to create new objects 
  
 Without the 
 new
  operator—to convert any value to the corresponding 
 primitive data type
  
 Other built-in constructor functions you're now familiar with include: 
 Object()
 , 
 Array()
 , 
 Function()
 , 
 Date()
 , 
 RegExp()
 , and 
 Error()
 . You're also familiar with 
 Math
 : a global object that is not a constructor.
  
 Now you can see how objects have a central role in JavaScript programming, as 
 pretty much everything is an object or can be wrapped by an object.
  
 Finally, let's wrap up the literal notations you're now familiar with:
  
 Name
  
 Literal
  
 Constructor
  
 Example
  
 Object
  
 {}
  
 new Object()
  
 {prop: 1}
  
 new Array()
  
 [1,2,3,'test']
  
 Array
  
 []
  
 Regular 
  
 /pattern/
  
 new RegExp('pattern', 
  
 /java.*/img
  
 expression
  
 modifiers
  
 'modifiers')
  
 [
  148 
 ]",NA
Exercises ,"1. Look at this code:
  
 function F() {
  
  
  function C() 
 {
  
  
  return this;
  
  
  }
  
  
  return C(); 
  
 } 
  
 var o = new 
 F();
  
 Does the value of 
 this
  refer to the global object or the object 
 o
 ?
  
 2. What's the result of executing this piece of code?
  
 function C(){ 
  
  
  this.a = 1;
  
  
  return false; 
  
 } 
  
 console.log(typeof new 
 C());
  
 3. What's the result of executing the following piece of code?
  
 > c = [1, 2, [1, 2]]; 
  
 > c.sort(); 
  
 > c.join('--'); 
  
 > console.log(c); 
  
 4. Imagine the 
 String()
  constructor didn't exist. Create a constructor function, 
 MyString()
 , that acts like 
 String()
  as closely as possible. You're not allowed 
 to use any built-in string methods or properties, and remember that 
 String()
  
 doesn't exist. You can use this code to test your constructor:
  
 > var s = new MyString('hello'); 
  
 > s.length;
  
  5
  
 > s[0];
  
  ""h""
  
 > s.toString();
  
  ""hello""
  
 > s.valueOf();
  
  ""hello""
  
 > s.charAt(1);
  
  ""e""
  
 [
  149 
 ]",NA
Prototype,"In this chapter, you'll learn about the prototype property of the function objects. 
  
 Understanding how the prototype works is an important part of learning the JavaScript 
 language. After all, JavaScript is often classified as having a prototype-based object model. 
 There's nothing particularly difficult about the prototype, but it's a new concept, and as 
 such may sometimes take a bit of time to sink in. Like closures (see 
 Chapter 3
 , 
 Functions
 ), 
 the prototype is one of those things in JavaScript, which once you ""get"", they seem so 
 obvious and make perfect sense. As with the rest of the book, you're strongly encouraged 
 to type in and play around with the examples—this makes it much easier to learn and 
 remember the concepts.
  
 The following topics are discussed in this chapter:
  
 • 
  
 Every function has a 
 prototype
  property and it contains an object
  
 • 
  
 Adding properties to the prototype object
  
 • 
  
 Using the properties added to the prototype
  
 • 
  
 The difference between own properties and properties of the prototype
  
 • 
  
 __proto__
 , the secret link every object keeps to its prototype
  
 • 
  
 Methods such as 
 isPrototypeOf()
 , 
 hasOwnProperty()
 , and 
  
 propertyIsEnumerable()
  
 • 
  
 Enhancing built-in objects, such as arrays or strings (and why that can be 
 a bad idea)",NA
The prototype property,"The functions in JavaScript are objects, and they contain methods and properties. Some 
 of the methods that you're already familiar with are 
 apply()
  and 
 call()
 , and some of 
 the other properties are 
 length
  and 
 constructor
 . Another property of the function 
 objects is 
 prototype
 .
  
 If you define a simple function, 
 foo()
 , you can access its properties as you would do 
 with any other object.
  
 > function foo(a, b) {
  
  return a * b;
  
  }
  
 > foo.length;
  
 2
  
 > foo.constructor;
  
 function Function() { [native code] }
  
 The 
 prototype
  property is a property that is available to you as soon as you define 
 the function. Its initial value is an ""empty"" object.
  
 > typeof foo.prototype;
  
 ""object""
  
 It's as if you added this property yourself as follows:
  
 > foo.prototype = {};
  
 You can augment this empty object with properties and methods. They won't have 
 any effect on the 
 foo()
  function itself; they'll only be used if you call 
 foo() 
 as a 
 constructor.",NA
Adding methods and properties using the ,NA,NA
prototype,"In the previous chapter, you learned how to define constructor functions that you can use 
 to create (construct) new objects. The main idea is that inside a function invoked with 
 new
 , you have access to the value 
 this
 , which refers to the object to be returned by the 
 constructor. Augmenting (adding methods and properties to) 
 this
  is how you add 
 functionality to the object being constructed.
  
 [
  154 
 ]",NA
Using the prototype's methods and ,NA,NA
properties ,"All the methods and properties you have added to the prototype are available as soon 
 as you create a new object using the constructor. If you create a 
 newtoy
  object using 
 the 
 Gadget()
  constructor, you can access all the methods and properties already 
 defined.
  
 > var newtoy = new Gadget('webcam', 'black'); 
 > newtoy.name; 
  
 ""webcam""
  
 [
  155 
 ]",NA
Own properties versus prototype properties ,"In 
 the preceding example, 
 getInfo()
  was used internally to access the properties of the 
 object. It could've also used 
 Gadget.prototype
  to achieve the same output.
  
  
 Gadget.prototype.getInfo = function () {
  
  
  
  return 'Rating: ' + Gadget.prototype.rating +
  
  
  
  ', price: ' + Gadget.prototype.price; 
  
  
 }; 
  
 What's the difference? To answer this question, let's examine how the prototype 
 works in more detail.
  
 [
  156 
 ]",NA
Overwriting a prototype's property with an ,NA,NA
own property,"As the above discussion demonstrates, if one of your objects doesn't have a certain 
 property of its own, it can use one (if it exists) somewhere up the prototype chain. 
 What if the object does have its own property and the prototype also has one with the 
 same name? Then, the own property takes precedence over the prototype's.
  
 [
  157 
 ]",NA
Enumerating properties ,"If you want to list all the properties of an object, you can use a 
 for-in
  loop. 
  
 In 
 Chapter 2
 , 
 Primitive Data Types, Arrays, Loops, and Conditions
 , you saw that you can 
 also loop through all the elements of an array with 
 for-in
 , but as mentioned there, 
 for
  is better suited for arrays and 
 for-in
  is for objects. Let's take an example of 
 constructing a query string for a URL from an object:
  
 var params = {
  
  
  productid: 666,
  
  
  section: 'products' 
  
 };
  
 var url = 'http://example.org/page.php?',
  
  i,
  
  query = [];
  
 for (i in params) {
  
  
  query.push(i + '=' + 
 params[i]); 
  
 }
  
 url += query.join('&');
  
 This produces the 
 url
  string as follows:
  
 ""http://example.org/page.php?productid=666&section=products""
  
 [
  159 
 ]",NA
isPrototypeOf() ,"Objects also have the 
 isPrototypeOf()
  method. This method tells you whether that 
 specific object is used as a prototype of another object.
  
 Let's take a simple object named 
 monkey
 .
  
 var monkey = { 
  
  
  hair: true,   
  
  
  feeds: 'bananas',   
  
  
  breathes: 'air' 
  
 };
  
 Now let's create a 
 Human()
  constructor function and set its prototype property to 
 point to 
 monkey
 .
  
 function Human(name) {
  
  
  this.name = name; 
  
 } 
  
 Human.prototype = monkey;
  
 Now if you create a new 
 Human
  object called 
 george
  and ask ""is 
 monkey
  the prototype of 
 george
 ?"", you'll get 
 true
 .
  
 > var george = new Human('George'); 
  
 > monkey.isPrototypeOf(george); 
  
 true
  
 Note that you have to know, or suspect, who the prototype is and then ask ""is it true that 
 your 
 prototype
  is 
 monkey
 ?"" in order to confirm your suspicion. But what if you don't 
 suspect anything and you have no idea? Can you just ask the object to tell you its 
 prototype? The answer is you can't in all browsers, but you can in most of them. Most 
 recent browsers have implemented the addition to ES5 called 
 Object. 
 getPrototypeOf()
 .
  
 > 
 Object.getPrototypeOf(george).feeds; 
  
 ""bananas""
  
 > Object.getPrototypeOf(george) === monkey; 
  
 true
  
 For some of the pre-ES5 environments that don't have 
 getPrototypeOf()
 , you can 
 use the special property 
 __proto__
 .
  
 [
  162 
 ]",NA
The secret __proto__ link ,"As you already know, the 
 prototype
  property is consulted when you try to access a 
 property that does not exist in the current object.
  
 Consider another object called 
 monkey
  and use it as a prototype when creating 
 objects with the 
 Human()
  constructor.
  
  
 > var monkey = {
  
  
  
  feeds: 'bananas',
  
  
  
  breathes: 'air'
  
  
  
  }; 
  
  
 > function Human() {} 
  
  
 > Human.prototype = monkey; 
  
 Now, let's create a 
 developer
  object and give it some properties.
  
  
 > var developer = new Human(); 
  
  
 > developer.feeds = 'pizza'; 
  
  
 > developer.hacks = 'JavaScript'; 
  
 Now let's access these properties. For example, 
 hacks
  is a property of the 
 developer
  object.
  
  
 > developer.hacks; 
  
  
 ""JavaScript"" 
  
 feeds
  could also be found in the object.
  
  
 > developer.feeds; 
  
  
 ""pizza"" 
  
 breathes
  doesn't exist as a property of the 
 developer
  object, so the prototype is 
 looked up, as if there is a secret link, or a secret passageway, that leads to the 
 prototype object.
  
  
 > developer.breathes; 
  
  
 ""air"" 
  
 The secret link is exposed in most modern JavaScript environments as the 
 __proto__ 
 property (the word ""proto"" with two underscores before and two after).
  
 > developer.__proto__ === monkey; 
  
 true
  
 [
  163 
 ]",NA
Augmenting built-in objects,"The objects created by the built-in constructor functions such as 
 Array
 , 
 String
 , and 
 even 
 Object
  and 
 Function
  can be augmented (or enhanced) through the use of 
 prototypes. This means that you can, for example, add new methods to the 
 Array 
 prototype, and in this way you can make them available to all arrays. Let's see how to do 
 this.
  
 In PHP, there is a function called 
 in_array()
 , which tells you if a value exists in an 
 array. In JavaScript, there is no 
 inArray()
  method (although in ES5 there's 
 indexOf()
 , 
 which you can use for the same purpose). So, let's implement it and add it to 
 Array.prototype
 .
  
 Array.prototype.inArray = function (needle) {
  
  for (var i = 0, len = this.length; i < len; i++) {
  
  if (this[i] === needle) {
  
  return true;
  
  }
  
  }
  
  return false;
  
 };
  
 [
  164 
 ]",NA
Augmenting built-in objects – discussion,"Augmenting built-in objects through the prototype is a powerful technique, and you can 
 use it to shape JavaScript in any way you like. Because of its power, though, you should 
 always thoroughly consider your options before using this approach.
  
 The reason is that once you know JavaScript, you're expecting it to work the same 
 way, no matter which third-party library or widget you're using. Modifying core 
 objects could confuse the users and maintainers of your code and create unexpected 
 errors.
  
 [
  165 
 ]",NA
Prototype gotchas,"There are two important behaviors to consider when dealing with prototypes:
  
 • 
  
 • 
  
 The prototype chain is live except when you completely replace the 
 prototype object
  
 prototype.constructor
  is not reliable
  
 Let's create a simple constructor function and two objects.
  
 > function Dog() {
  
  this.tail = true;
  
  }
  
 > var benji = new Dog();
  
 > var rusty = new Dog();
  
 [
  166 
 ]",NA
Summary ,"Let's summarize the most important topics you have learned in this chapter:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 All functions have a property called 
 prototype
 . Initially it contains an 
 ""empty"" object (an object without any own properties).
  
 You can add properties and methods to the prototype object. You can even 
 replace it completely with an object of your choice.
  
 When you create an object using a function as a constructor (with 
 new
 ), the 
 object gets a secret link pointing to the prototype of the constructor, and can 
 access the prototype's properties.
  
 An object's own properties take precedence over a prototype's properties 
 with the same name.
  
 Use the method 
 hasOwnProperty()
  to differentiate between an object's own 
 properties and prototype properties.
  
 There is a prototype chain. When you execute 
 foo.bar
 , and if your object 
 foo
  
 doesn't have a property called 
 bar
 , the JavaScript interpreter looks for a 
 bar
  
 property in the prototype. If none is found, it keeps searching in the 
 prototype's prototype, then the prototype of the prototype's prototype, and it 
 will keep going all the way up to 
 Object.prototype
 .
  
 You can augment the prototypes of built-in constructor functions and all objects 
 will see your additions. Assign a function to 
 Array.prototype.flip 
 and all 
 arrays will immediately get a 
 flip()
  method, as in 
 [1,2,3].flip()
 . But do 
 check if the method/property you want to add already exists, so you can future-
 proof your scripts.",NA
Exercises ,"1. Create an object called 
 shape
  that has the type 
 property
  and a 
  
  
 getType()
  method.
  
 2. Define a 
 Triangle()
  constructor function whose prototype is 
 shape
 . Objects 
 created with 
 Triangle()
  should have three own properties—
 a
 , 
 b
 , and 
 c
 , 
 representing the lengths of the sides of a triangle.
  
 3. Add a new method to the prototype called 
 getPerimeter()
 .
  
 [
  169 
 ]",NA
Inheritance,"If you go back to 
 Chapter 1
 , 
 Object-oriented JavaScript
  and review the 
 Object-oriented 
 programming
  section, you'll see that you already know how to apply most of them to 
 JavaScript. You know what objects, methods, and properties are. You know that there 
 are no classes in JavaScript, although you can achieve the same using constructor 
 functions. Encapsulation? Yes, the objects encapsulate both the data and the means 
 (methods) to do something with the data. Aggregation? Sure, an object can contain other 
 objects. In fact, this is almost always the case since methods are functions, and functions 
 are also objects.
  
 Now, let's focus on the inheritance part. This is one of the most interesting features, as it 
 allows you to reuse existing code, thus promoting laziness, which is likely to be what 
 brought human species to computer programming in the first place.
  
 JavaScript is a dynamic language and there is usually more than one way to achieve any 
 given task. Inheritance is not an exception. In this chapter, you'll see some common 
 patterns for implementing inheritance. Having a good understanding of these patterns 
 will help you pick the right one, or the right mix, depending on your task, project or your 
 style.",NA
Prototype chaining,"Let's start with the default way of implementing inheritance—inheritance chaining 
 through the prototype.
  
 As you already know, every function has a 
 prototype
  property, which points to an 
 object. When a function is invoked using the 
 new
  operator, an object is created and 
 returned. This new object has a secret link to the prototype object. The secret link 
 (called 
 __proto__
  in some environments) allows methods and properties of the 
 prototype object to be used as if they belonged to the newly-created object.",NA
Prototype chaining example,"Prototype chaining is the default way to implement inheritance. In order to 
 implement the hierarchy, let's define three constructor functions.
  
 function Shape(){
  
 this.name = 'Shape';
  
 this.toString = function () {
  
 return this.name;
  
 };
  
 }
  
 function TwoDShape(){
  
 this.name = '2D shape';
  
 [
  172 
 ]",NA
Moving shared properties to the prototype,"When you create objects using a constructor function, own properties are added using 
 this
 . This could be inefficient in cases where properties don't change across 
 instances. In the previous example, 
 Shape()
  was defined like so:
  
 function Shape(){
  
 this.name = 'Shape';
  
 }
  
 This means that every time you create a new object using 
 new Shape()
  a new 
 name 
 property is created and stored somewhere in the memory. The other option is to have 
 the 
 name
  property added to the prototype and shared among all the instances:
  
 function Shape() {}
  
 Shape.prototype.name = 'Shape';
  
 Now, every time you create an object using 
 new Shape()
 , this object doesn't get its 
 own property 
 name
 , but uses the one added to the prototype. This is more efficient, but 
 you should only use it for properties that don't change from one instance to another. 
 Methods are ideal for this type of sharing.
  
 Let's improve on the preceding example by adding all methods and suitable properties 
 to the 
 prototype
 . In the case of 
 Shape()
  and 
 TwoDShape()
  everything is meant to be 
 shared:
  
 // constructor
  
 function Shape() {}
  
 // augment prototype
  
 Shape.prototype.name = 'Shape';
  
 [
  175 
 ]",NA
Inheriting the prototype only,"As explained previously, for reasons of efficiency you should add the reusable properties 
 and methods to the prototype. If you do so, then it's a good idea to inherit only the 
 prototype, because all the reusable code is there. This means that inheriting the 
 Shape.prototype
  object is better than inheriting the object created with 
 new Shape()
 . 
 After all, 
 new Shape()
  only gives you own shape properties that are not meant to be 
 reused (otherwise they would be in the prototype). You gain a little more efficiency by:
  
 • 
  
 • 
  
 Not creating a new object for the sake of inheritance alone 
  
 Having less lookups during runtime (when it comes to searching for 
 toString()
  for example)
  
 Here's the updated code; the changes are highlighted:
  
 function Shape() {}
  
 // augment prototype
  
 Shape.prototype.name = 'Shape';
  
 Shape.prototype.toString = function () {
  
 [
  177 
 ]",NA
A temporary constructor – new F() ,"A solution to the previously outlined problem, where all prototypes point to the same 
 object and the parents get children's properties, is to use an intermediary to break the 
 chain. The intermediary is in the form of a temporary constructor function. 
  
 Creating an empty function 
 F()
  and setting its 
 prototype
  to the prototype of the 
 parent constructor, allows you to call 
 new F()
  and create objects that have no 
 properties of their own, but inherit everything from the parent's 
 prototype
 .
  
 Let's take a look at the modified code:
  
 function Shape() {} 
  
 // augment prototype 
  
 Shape.prototype.name = 'Shape'; 
  
 Shape.prototype.toString = function () { 
  
 return this.name; 
  
 };
  
 function TwoDShape() {} 
  
 // take care of inheritance 
  
 var F = function () {}; 
  
 F.prototype = Shape.prototype; 
  
 TwoDShape.prototype = new F(); 
  
 TwoDShape.prototype.constructor = TwoDShape; 
 // augment prototype 
  
 TwoDShape.prototype.name = '2D shape';
  
 function Triangle(side, height) { 
  
 this.side = side; 
  
 this.height = height; 
  
 }
  
 // take care of inheritance
  
 [
  179 
 ]",NA
Uber – access to the parent from a child ,NA,NA
object ,"Classical OO languages usually have a special syntax that gives you access to the parent 
 class, also referred to as superclass. This could be convenient when a child wants to 
 have a method that does everything the parent's method does plus something in 
 addition. In such cases, the child calls the parent's method with the same name and 
 works with the result.
  
 In JavaScript, there is no such special syntax, but it's trivial to achieve the same 
 functionality. Let's rewrite the last example and, while taking care of inheritance, also 
 create an 
 uber
  property that points to the parent's prototype object.
  
 function Shape() {} 
  
 // augment prototype 
  
 Shape.prototype.name = 'Shape'; 
  
 Shape.prototype.toString = function () { 
  
 varconst = this.constructor; 
  
 returnconst.uber
  
  ? this.const.uber.toString() + ', ' + this.name : 
 this.name; 
  
 };
  
 function TwoDShape() {} 
  
 // take care of inheritance 
  
 var F = function () {}; 
  
 F.prototype = Shape.prototype; 
  
 TwoDShape.prototype = new F(); 
  
 TwoDShape.prototype.constructor = TwoDShape; 
 TwoDShape.uber = Shape.prototype; 
  
 // augment prototype 
  
 TwoDShape.prototype.name = '2D shape';
  
 function Triangle(side, height) { 
  
 this.side = side; 
  
 this.height = height; 
  
 }
  
 // take care of inheritance 
  
 var F = function () {}; 
  
 F.prototype = TwoDShape.prototype; 
  
 Triangle.prototype = new F(); 
  
 Triangle.prototype.constructor = Triangle; 
  
 Triangle.uber = TwoDShape.prototype;
  
 [
  181 
 ]",NA
Isolating the inheritance part into a ,NA,NA
function ,"Let's move the code that takes care of all of the inheritance details from the last 
 example into a reusable 
 extend()
  function:
  
 function extend(Child, Parent) { 
  
 var F = function () {}; 
  
 F.prototype = Parent.prototype; 
  
 Child.prototype = new F(); 
  
 Child.prototype.constructor = Child; 
  
 Child.uber = Parent.prototype; 
  
 }
  
 [
  182 
 ]",NA
Copying properties,"Now, let's try a slightly different approach. Since inheritance is all about reusing code, can 
 you simply copy the properties you like from one object to another? Or from a parent to a 
 child? Keeping the same interface as the preceding 
 extend() 
 function, you can create a 
 function 
 extend2()
  which takes two constructor functions and copies all of the 
 properties from the parent's prototype to the child's prototype. 
  
 This will, of course, carry over methods too, as methods are just properties that 
 happen to be functions.
  
 function extend2(Child, Parent) {
  
 var p = Parent.prototype;
  
 var c = Child.prototype;
  
 for (vari in p) {
  
 c[i] = p[i];
  
 }
  
 c.uber = p;
  
 }
  
 As you can see, a simple loop through the properties is all it takes. As with the previous 
 example, you can set an 
 uber
  property if you want to have handy access to parent's 
 methods from the child. Unlike the previous example though, it's not necessary to 
 reset the 
 Child.prototype.constructor
  because here the child prototype is 
 augmented, not overwritten completely, so the 
 constructor
  property points to the 
 initial value.
  
 This method is a little inefficient compared to the previous method because 
  
 properties of the child prototype are being duplicated instead of simply being looked up 
 via the prototype chain during execution. Bear in mind that this is only true for properties 
 containing primitive types. All objects (including functions and arrays) are not duplicated, 
 because these are passed by reference only.
  
 Let's see an example of using two constructor functions, 
 Shape()
  and 
 TwoDShape()
 . 
 The 
 Shape()
  function's prototype object contains a primitive property, 
 name
 , and a non-
 primitive one—the 
 toString()
 method:
  
 var Shape = function () {};
  
 varTwoDShape = function () {};
  
 Shape.prototype.name = 'Shape';
  
 Shape.prototype.toString = function () {
  
 [
  184 
 ]",NA
Heads-up when copying by reference,"The fact that objects (including functions and arrays) are copied by reference could 
 sometimes lead to results you don't expect.
  
 Let's create two constructor functions and add properties to the prototype of the 
 first one:
  
 > function Papa() {}
  
 >function Wee() {}
  
 >Papa.prototype.name = 'Bear'; 
  
 >Papa.prototype.owns = [""porridge"", ""chair"", ""bed""];
  
 Now, let's have 
 Wee
  inherit from 
 Papa
  (either 
 extend()
  or 
 extend2()
  will do):
  
 >extend2(Wee, Papa);
  
 Using 
 extend2()
 , the 
 Wee
  function's prototype inherited the properties of 
 Papa. 
 prototype
  as its own.
  
 >Wee.prototype.hasOwnProperty('name');
  
 true
  
 >Wee.prototype.hasOwnProperty('owns');
  
 true
  
 The 
 name
  property is primitive so a new copy of it is created. The property 
 owns
  is an 
 array object so it's copied by reference:
  
 >Wee.prototype.owns;
  
 [""porridge"", ""chair"", ""bed""]
  
 [
  186 
 ]",NA
Objects inherit from objects,"All of the examples so far in this chapter assume that you create your objects with 
 constructor functions and you want objects created with one constructor to inherit 
 properties that come from another constructor. However, you can also create objects 
 without the help of a constructor function, just by using the object literal and this is, in 
 fact, less typing. So how about inheriting those?
  
 [
  188 
 ]",NA
Deep copy,"The function 
 extendCopy()
 , discussed previously, creates what is called a shallow 
 copy of an object, just like 
 extend2()
  before that. The opposite of a shallow copy 
 would be, naturally, a deep copy. As discussed previously (in the 
 Heads-up when 
 copying by reference 
 section ), when you copy objects you only copy pointers to the 
 location in memory where the object is stored. This is what happens in a shallow copy. 
 If you modify an object in the copy, you also modify the original. The deep copy avoids 
 this problem.
  
 [
  190 
 ]",NA
object() ,"Based on the idea that objects inherit from objects, Douglas Crockford advocates the use 
 of an 
 object()
  function that accepts an object and returns a new one that has the parent 
 as a prototype.
  
 function object(o) { 
  
 function F() {} 
  
 F.prototype = o; 
  
 return new F(); 
  
 }
  
 If you need access to an 
 uber
  property, you can modify the 
 object()
  function 
 like so:
  
 function object(o) { 
  
 var n; 
  
 function F() {} 
  
 F.prototype = o; 
  
 n = new F();
  
 [
  192 
 ]",NA
Using a mix of prototypal inheritance and ,NA,NA
copying properties ,"When you use inheritance, you will most likely want to take already existing 
  
 functionality and then build upon it. This means creating a new object by inheriting from 
 an existing object and then adding additional methods and properties. You can do this 
 with one function call, using a combination of the last two approaches just discussed.
  
 You can:
  
 • 
  
 Use prototypal inheritance to use an existing object as a prototype of a new one
  
 • 
  
 Copy all of the properties of another object into the newly created one
  
 function objectPlus(o, stuff) { 
  
 var n; 
  
 function F() {} 
  
 F.prototype = o; 
  
 n = new F(); 
  
 n.uber = o;
  
 for (vari in stuff) {
  
 [
  193 
 ]",NA
Multiple inheritance ,"Multiple inheritance is where a child inherits from more than one parent. Some OO 
 languages support multiple inheritance out of the box, and some don't. You can argue 
 both ways: that multiple inheritance is convenient, or that it's unnecessary, complicates 
 application design, and it's better to use an inheritance chain instead. 
  
 Leaving the discussion of multiple inheritance's pros and cons for the long, cold 
 winter nights, let's see how you can do it in practice in JavaScript.
  
 The implementation can be as simple as taking the idea of inheritance by copying 
 properties, and expanding it so that it takes an unlimited number of input objects to 
 inherit from.
  
 Let's create a 
 multi()
  function that accepts any number of input objects. You can wrap 
 the loop that copies properties in another loop that goes through all the objects passed 
 as 
 arguments
  to the function.
  
 function multi() { 
  
 var n = {}, stuff, j = 0, len = arguments.length; 
 for (j = 0; j <len; j++) { 
  
 stuff = arguments[j]; 
  
 for (vari in stuff) {
  
  
  if (stuff.hasOwnProperty(i)) { 
  
 n[i] = stuff[i];
  
  
  } 
  
 }
  
 [
  195 
 ]",NA
Mixins,"You might come across the term 
 mixin
 . Think of a mixin as an object that 
  
 provides some useful functionality but is not meant to be inherited and extended by 
 sub-objects. The approach to multiple inheritance outlined previously can be 
 considered an implementation of the mixins idea. When you create a new object you 
 can pick and choose any other objects to mix into your new object. By passing them all 
 to 
 multi()
  you get all their functionality without making them part of the inheritance 
 tree.",NA
Parasitic inheritance,"If you like the fact that you can have all kinds of different ways to implement 
 inheritance in JavaScript, and you're hungry for more, here's another one. This 
 pattern, courtesy of Douglas Crockford, is called parasitic inheritance. It's about a 
 function that creates objects by taking all of the functionality from another object 
 into a new one, augmenting the new object, and returning it, ""pretending that it has 
 done all the work"".
  
 Here's an ordinary object, defined with an object literal, and unaware of the fact that it's 
 soon going to fall victim to parasitism:
  
 vartwoD = {
  
 name: '2D shape',
  
 dimensions: 2
  
 };
  
 A function that creates triangle objects could:
  
 • 
  
 • 
  
 • 
  
 Use 
 twoD
  object as a prototype of an object called 
 that
  (similar to 
 this
  for 
 convenience). This can be done in any way you saw previously, for example 
 using the 
 object()
  function or copying all the properties.
  
 Augment 
 that
  with more properties.
  
 Return 
 that
 .
  
 function triangle(s, h) {
  
 var that = object(twoD);
  
 that.name ='Triangle';
  
 that.getArea = function () { 
  
 return this.side * this.height / 2; 
  
 };
  
 that.side = s;
  
 that.height = h;
  
 return that;
  
 }
  
 [
  197 
 ]",NA
Borrowing a constructor,"One more way of implementing inheritance (the last one in the chapter, I promise) has 
 to do again with constructor functions, and not the objects directly. In this pattern the 
 constructor of the child calls the constructor of the parent using either 
 call()
  or 
 apply()
  methods. This can be called 
 stealing a constructor
 , or 
 inheritance by borrowing 
 a constructor
  if you want to be more subtle about it.
  
 call()
  and 
 apply()
  were discussed in 
 Chapter 4
 , 
 Objects
  but here's a refresher: they 
 allow you to call a function and pass an object that the function should bind to its 
 this
  
 value. So for inheritance purposes, the child constructor calls the parent's constructor 
 and binds the child's newly-created 
 this
  object as the parent's 
 this
 .
  
 Let's have this parent constructor 
 Shape()
 :
  
  
 function Shape(id) { 
  
  
 this.id = id; 
  
  
 } 
  
  
 Shape.prototype.name = 'Shape'; 
  
  
 Shape.prototype.toString = function () { 
  
  
 return this.name; 
  
  
 }; 
  
 Now, let's define 
 Triangle()
  which uses 
 apply()
  to call the 
 Shape() 
 constructor, passing 
 this
  (an instance created with 
 new Triangle()
 ) 
 and any additional arguments.
  
 function Triangle() {
  
 Shape.apply(this, arguments);
  
 }
  
 Triangle.prototype.name = 'Triangle';
  
 Note, that both 
 Triangle()
  and 
 Shape()
 have added some extra properties to 
 their prototypes.
  
 [
  198 
 ]",NA
Borrow a constructor and copy its prototype ,"The problem of the double work performed by calling the constructor twice can 
 easily be corrected. You can call 
 apply()
  on the parent constructor to get all own 
 properties and then copy the prototype's properties using a simple iteration (or 
 extend2()
  as discussed previously).
  
 function Shape(id) { 
  
 this.id = id; 
  
 } 
  
 Shape.prototype.name = 'Shape'; 
  
 Shape.prototype.toString = function () { 
  
 return this.name; 
  
 };
  
 function Triangle() { 
  
 Shape.apply(this, arguments); 
  
 } 
  
 extend2(Triangle, Shape); 
  
 Triangle.prototype.name = 'Triangle';
  
 Testing:
  
 >var t = new Triangle(101); 
  
 >t.toString(); 
  
 ""Triangle"" 
  
 >t.id; 
  
 101
  
 No double inheritance:
  
 >typeoft.__proto__.id
 ; 
  
 ""undefined""
  
 [
  200 
 ]",NA
Summary,"In this chapter you learned quite a few ways (patterns) for implementing inheritance 
 and the following table summarizes them. The different types can roughly be divided 
 into:
  
 • 
  
 Patterns that work with constructors
  
 • 
  
 Patterns that work with objects
  
 You can also classify the patterns based on whether they:
  
  
 • 
  
 Use the prototype
  
  
 • 
  
 Copy properties 
  
 • 
  
 Do both (copy properties of the prototype)
  
 #
  
 Name
  
 Example
  
 Classification
  
 Notes
  
 1
  
 Prototype 
  
 Child.prototype = 
  
 • Works with 
  
 • The default 
  
 chaining
  
 new Parent();
  
 constructors
  
 mechanism. 
  
 (pseudo-
  
 • Uses the 
  
 • Tip: move all 
  
 classical)
  
 prototype 
  
 properties/
  
 chain 
  
 methods that 
  
 are meant to be 
  
 reused to the 
  
 prototype, add 
  
 the non-reusable 
  
 as own properties.
  
 [
  201 
 ]",NA
Case study – drawing shapes,"Let's finish off this chapter with a more practical example of using inheritance. The task is 
 to be able to calculate the area and the perimeter of different shapes, as well as to draw 
 them, while reusing as much code as possible.",NA
Analysis,"Let's have one 
 Shape
  constructor that contains all of the common parts. From there, 
 let's have 
 Triangle
 , 
 Rectangle
 , and 
 Square
  constructors, all inheriting from 
 Shape
 . 
  
 A square is really a rectangle with the same-length sides, so let's reuse 
 Rectangle 
 when building the 
 Square
 .
  
 In order to define a shape, you'll need points with 
 x
  and 
 y
  coordinates. A generic 
 shape can have any number of points. A triangle is defined with three points, a 
 rectangle (to keep it simpler)—with one point and the lengths of the sides. The 
 perimeter of any shape is the sum of its sides' lengths. Calculating the area is shape-
 specific and will be implemented by each shape.
  
 The common functionality in 
 Shape
  would be:
  
 • 
  
 A 
 draw()
  method that can draw any shape given the points
  
 • 
  
 A 
 getParameter()
  method
  
 • 
  
 A property that contains an array of 
 points
  
 • 
  
 Other methods and properties as needed
  
 For the drawing part let's use a 
 <canvas>
  tag. It's not supported in early IEs, but hey, this 
 is just an exercise.
  
 Let's have two other helper constructors—
 Point
  and 
 Line
 . 
 Point
  will help when 
 defining shapes; 
 Line
  will make calculations easier, as it can give the length of the line 
 connecting any two given points.
  
 [
  205 
 ]",NA
Implementation ,"Let's start by adding a canvas tag to a blank HTML page:
  
 <canvas height=""600"" width=""800"" id=""canvas"" />
  
 Then, put the JavaScript code inside 
 <script>
  tags:
  
 <script> 
  
 // ... code goes here 
  
 </script>
  
 Now, let's take a look at what's in the JavaScript part. First, the helper 
 Point 
 constructor. It just can't get any more trivial than this:
  
 function Point(x, y) 
 { 
  
 this.x = x; 
  
 this.y = y; 
  
 }
  
 Bear in mind that the coordinates of the points on the canvas start from x=0, y=0, 
 which is the top left. The bottom right will be x = 800, y = 600:
  
 0 x
  
 x = 800 
  
 y = 600
  
 y
  
 Next, the 
 Line
  constructor. It takes two points and calculates the length of the line 
 between them, using the Pythagorean Theorem a2 + b2 = c2 (imagine a right-angled 
 triangle where the hypotenuse connects the two given points).
  
 function Line(p1, p2) { 
  
 this.p1 = p1; 
  
 this.p2 = p2; 
  
 this.length = Math.sqrt( 
  
 Math.pow(p1.x - p2.x, 2) 
 + 
  
 Math.pow(p1.y - p2.y, 2) 
  
 ); 
  
 }
  
 [
  206 
 ]",NA
Testing ,"Let's test this by drawing shapes. First, define three points for a triangle:
  
 >varp1 
 = 
 new 
 Point(100, 
 100); 
  
 >varp2 
 = 
 new 
 Point(300, 
 100); 
  
 >varp3 = new Point(200, 0);
  
 Now, you can create a triangle by passing the three points to the 
 Triangle
  constructor:
  
 >var t = new Triangle(p1, p2, p3);
  
 You can call the methods to draw the triangle on the canvas and get its area and 
 perimeter:
  
 >t.draw(); 
  
 >t.getPerimeter()
 ; 
  
 482.842712474619
  
 >t.getArea(); 
  
 10000.0000000000
 02
  
 Now, let's play with a rectangle instance:
  
 >var r = new Rectangle(new Point(200, 200), 50, 100); 
 >r.draw(); 
  
 >r.getArea(); 
  
 5000
  
 >r.getPerimeter()
 ; 
  
 300
  
 And finally, a square:
  
 >var s = new Square(new Point(130, 130), 50); 
 >s.draw(); 
  
 >s.getArea(); 
  
 2500
  
 >s.getPerimeter()
 ; 
  
 200",NA
Exercises,"1. Implement multiple inheritance but with a prototypal inheritance pattern, 
  
 not property copying. For example:
  
 var my = objectMulti(obj, another_obj, a_third, {
  
 additional: ""properties""
  
 });
  
 The property 
 additional
  should be an own property, all the rest should be 
 mixed into the prototype.
  
 [
  211 
 ]",NA
The Browser Environment,"You know that JavaScript programs need a host environment. Most of what you learned 
 so far in this book was related to core ECMAScript/JavaScript and can be used in many 
 different host environments. Now, let's shift the focus to the browser, since this is the 
 most popular and natural host environment for JavaScript programs. 
  
 In this chapter, you will learn about the following elements:
  
 • 
  
 The 
 Browser Object Model
  (
 BOM
 )
  
 • 
  
 The 
 Document Object Model
  (
 DOM
 )
  
 • 
  
 Browser events
  
 • 
  
 The 
 XMLHttpRequest
  object",NA
Including JavaScript in an HTML page ,"To 
 include JavaScript in an HTML page, you need to use the 
 <script>
  tag as follows:
  
 <!DOCTYPE> 
  
 <html>
  
  
  <head>
  
  
  <title>JS test</title>
  
  
  <script src=""somefile.js""></script>
  
  
  </head>
  
  
  <body>
  
  
  <script>
  
    
  var a = 1;
  
    
  a++;
  
  
  </script>
  
  
  </body> 
  
 </html>",NA
BOM and DOM – an overview,"The JavaScript code in a page has access to a number of objects. These objects can be 
 divided into the following types:
  
 • 
  
 • 
  
 • 
  
 Core ECMAScript objects
 : All the objects mentioned in the previous chapters 
 DOM
 : Objects that have to do with the currently loaded page (the page is also 
 called the document) 
  
 BOM
 : Objects that deal with everything outside the page (the browser window 
 and the desktop screen)
  
 DOM stands for Document Object Model and BOM for Browser Object Model.
  
 The DOM is a standard, governed by the 
 World Wide Web Consortium
  (
 W3C
 ) and has 
 different versions, called levels, such as DOM Level 1, DOM Level 2, and so on. Browsers 
 in use today have different degrees of compliance with the standard but in general, they 
 almost all completely implement DOM Level 1. The DOM was standardized post-factum, 
 after the browser vendors had each implemented their own ways to access the 
 document. The legacy part (from before the W3C took over) is still around and is 
 referred to as DOM 0, although no real DOM Level 0 standard exists. Some parts of DOM 
 0 have become de-facto standards as all major browsers support them. Some of these 
 were added to the DOM Level 1 standard. The rest of DOM 0 that didn't find its way to 
 DOM 1 is too browser-specific and won't be discussed here.
  
 BOM historically has not been a part of any standard. Similar to DOM 0, it has a subset of 
 objects that is supported by all major browsers, and another subset that is browser-
 specific. The HTML5 standard codifies common behavior among browsers, and it 
 includes common BOM objects. Additionally, mobile devices come with their specific 
 objects (and HTML5 aims to standardize those as well) which traditionally have not 
 been necessary for desktop computers, but make sense in a mobile world, for example, 
 geolocation, camera access, vibration, touch events, telephony, 
  
 and SMS.
  
 [
  214 
 ]",NA
BOM,"The Browser Object Model (BOM) is a collection of objects that give you access to the 
 browser and the computer screen. These objects are accessible through the global object 
 window
 .",NA
The window object revisited,"As you know already, in JavaScript there's a global object provided by the host 
 environment. In the browser environment, this global object is accessible using 
 window
 . 
  
 All global variables are also accessible as properties of the 
 window
  object as follows:
  
 > window.somevar = 1;
  
  1
  
 > somevar;
  
  1
  
 Also, all of the core JavaScript functions (discussed in 
 Chapter 2
 , 
 Primitive Data Types, 
 Arrays, Loops, and Conditions
 ) are methods of the global object. Have a look at the 
 following code snippet:
  
 > parseInt('123a456');
  
  123
  
 > window.parseInt('123a456');
  
  123
  
 In addition to being a reference to the global object, the 
 window
  object also serves a 
 second purpose providing information about the browser environment. There's a 
 window
  object for every frame, iframe, pop up, or browser tab.
  
 [
  215 
 ]",NA
window.navigator,"The 
 navigator
  is an object that has some information about the browser and its 
 capabilities. One property is 
 navigator.userAgent
 , which is a long string of 
 browser identification. In Firefox, you'll get the following output:
  
 > window.navigator.userAgent;
  
  
  ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/536.28.10 (KHTML, like 
 Gecko) Version/6.0.3 Safari/536.28.10""
  
 The 
 userAgent
  string in Microsoft Internet Explorer would be something like the 
 following:
  
  ""Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)""
  
 Because the browsers have different capabilities, developers have been using the 
 userAgent
  string to identify the browser and provide different versions of the code. 
  
 For example, the following code searches for the presence of the string 
 MSIE
  to 
 identify Internet Explorer:
  
 if (navigator.userAgent.indexOf('MSIE') !== -1) {
  
  // this is IE
  
 } else {
  
  // not IE
  
 }
  
 It's better not to rely on the user agent string, but to use feature sniffing (also called 
 capability detection) instead. The reason for this is that it's hard to keep track of all 
 browsers and their different versions. It's much easier to simply check if the feature you 
 intend to use is indeed available in the user's browser. For example have a look at the 
 following code:
  
 if (typeof window.addEventListener === 'function') {
  
  // feature is supported, let's use it
  
 } else {
  
  // hmm, this feature is not supported, will have to
  
  // think of another way
  
 }
  
 Another reason to avoid user agent sniffing is that some browsers allow users to 
 modify the string and pretend they are using a different browser.
  
 [
  216 
 ]",NA
Your console is a cheat sheet,"The console lets you inspect what's in an object and this includes all the BOM and 
 DOM properties. Just type the following code:
  
 > navigator;
  
 Then click on the result. The result is a list of properties and their values, as shown in the 
 following screenshot:",NA
window.location,"The 
 location
  property points to an object that contains information about the URL of 
 the currently loaded page. For example, 
 location.href
  is the full URL and 
 location.hostname
  is only the domain. With a simple loop, you can see the full list of 
 properties of the 
 location
  object.
  
 Imagine you're on a page with a URL 
 http://search.phpied.com:8080/search?q 
 =java&what=script#results
 .
  
 for (var i in location) {
  
  if (typeof location[i] === ""string"") {
  
  console.log(i + ' = ""' + location[i] + '""');
  
  }
  
 [
  217 
 ]",NA
window.history ,"window.history
  allows limited access to the previously visited pages in the same 
 browser session. For example, you can see how many pages the user has visited before 
 coming to your page as follows:
  
 > window.history.length;
  
  
  5
  
 [
  218 
 ]",NA
window.frames,"window.frames
  is a collection of all of the frames in the current page. It doesn't 
 distinguish between frames and iframes (inline frames). Regardless of whether 
 there are frames on the page or not, 
 window.frames
  always exists and points to 
 window
  as follows:
  
 > window.frames === window;
  
  true
  
 [
  219 
 ]",NA
window.screen ,"screen
  provides information about the environment outside the browser. For 
 example, the property 
 screen.colorDepth
  contains the color bit-depth (the color 
 quality) of the monitor. This is mostly used for statistical purposes. Have a look at the 
 following code:
  
 > window.screen.colorDepth;
  
  
  32
  
 You can also check the available screen real estate (the resolution):
  
 > screen.width;
  
  
  1440
  
 > screen.availWidth;
  
  
  1440
  
 > screen.height;
  
  
  900
  
 > screen.availHeight;
  
  
  847
  
 The difference between 
 height
  and 
 availHeight
  is that the 
 height
  is the whole 
 screen, while 
 availHeight
  subtracts any operating system menus such as the 
 Windows task bar. The same is the case for 
 width
  and 
 availWidth
 .
  
 Somewhat related is the property mentioned in the following code:
  
 > 
 window.devicePixelRatio;
  
  
  1
  
 It tells you the difference (ratio) between physical pixels and device pixels in the 
 retina displays in mobile devices (for example, value 2 in iPhone).
  
 [
  221 
 ]",NA
window.open()/close(),"Having explored some of the most common cross-browser properties of the 
 window 
 object, let's move to some of the methods. One such method is 
 open()
 , which allows you 
 to open new browser windows (pop ups). Various browser policies and user settings 
 may prevent you from opening a pop up (due to abuse of the technique for marketing 
 purposes), but generally you should be able to open a new window if it was initiated by 
 the user. Otherwise, if you try to open a pop up as the page loads, it will most likely be 
 blocked, because the user didn't initiate it explicitly.
  
 window.open()
  accepts the following parameters:
  
 • 
  
 • 
  
 • 
  
 URL to load in the new window 
  
 Name of the new window, which can be used as the value of a form's 
 target
  attribute 
  
 Comma-separated list of features. They are as follows:
  
 °
  
 resizable
 : Should the user be able to resize the new window
  
 °
  
 width
 , 
 height
 : Width and height of the pop up
  
 °
  
 status
 : Should the status bar be visible
  
 window.open()
  returns a reference to the 
 window
  object of the newly created 
 browser instance. Following is an example:
  
 var win = window.open('http://www.packtpub.com', 'packt', 
  
  'width=300,height=300,resizable=yes');
  
 win
  points to the 
 window
  object of the pop up. You can check if 
 win
  has a falsy value, 
 which means that the pop up was blocked.
  
 win.close()
  closes the new window.
  
 It's best to stay away from opening new windows for accessibility and usability reasons. 
 If you don't like sites popping up windows to you, why do it to your users? There are 
 legitimate purposes, such as providing help information while filling out a form, but 
 often the same can be achieved with alternative solutions, such as using a floating 
 <div>
  
 inside the page.",NA
window.moveTo() and window.resizeTo(),"Continuing with the shady practices from the past, following are more methods to 
 irritate your users, provided their browser and personal settings allow you to.
  
 • 
  
 window.moveTo(100, 100)
  moves the browser window to screen location 
 x = 
 100
  and 
 y = 100
  (counted from the top-left corner)
  
 [
  222 
 ]",NA
"window.alert(), window.prompt(), and ",NA,NA
window.confirm(),"Chapter 2, 
 Primitive Data Types, Arrays, Loops, and Conditions
 , talked about the function 
 alert()
 . Now you know that global functions are accessible as methods of the global 
 object so 
 alert('Watchout!')
  and 
 window.alert('Watchout!')
  are exactly the 
 same.
  
 alert()
  is not an ECMAScript function, but a BOM method. In addition to it, two other 
 BOM methods allow you to interact with the user through system messages. 
  
 Following are the methods:
  
 • 
  
 confirm()
  gives the user two options, 
 OK
  and 
 Cancel
  
 • 
  
 prompt()
  collects textual input
  
 See how this works as follows:
  
 > var answer = confirm('Are you cool?'); 
  
 > answer;
  
 It presents you with a window similar to the following screenshot (the exact look 
 depends on the browser and the operating system):
  
  
 [
  223 
 ]",NA
window.setTimeout() and window.setInterval(),"setTimeout()
  and 
 setInterval()
  allow for scheduling the execution of a piece of 
 code. 
 setTimeout()
  attempts to execute the given code once after a specified 
 number of milliseconds. 
 setInterval()
  attempts to execute it repeatedly after a 
 specified number of milliseconds has passed.
  
 This shows an alert after approximately 2 seconds (2000 milliseconds):
  
 > function boo() { alert('Boo!'); }
  
 > setTimeout(boo, 2000);
  
  4
  
 As you can see the function returned an integer (in this case 
 4
 ) representing the ID of 
 the timeout. You can use this ID to cancel the timeout using 
 clearTimeout()
 . In the 
 following example, if you're quick enough, and clear the timeout before 2 seconds have 
 passed, the alert will never be shown as you can see in the following code:
  
 > var id = setTimeout(boo, 2000);
  
 > clearTimeout(id);
  
 Let's change 
 boo()
  to something less intrusive as follows:
  
 > function boo() { console.log('boo'); }
  
 Now, using 
 setInterval()
  you can schedule 
 boo()
  to execute every 2 seconds, 
 until you cancel the scheduled execution with 
 clearInterval()
 :
  
 > var id = setInterval(boo, 2000);
  
  boo
  
  boo
  
  boo
  
  boo
  
  boo
  
  boo
  
 > clearInterval(id);
  
 Note, that both functions accept a pointer to a callback function as a first parameter. 
  
 They can also accept a string which is evaluated with 
 eval()
  but as you know, 
 eval()
  
 is evil, so it should be avoided. And what if you want to pass arguments to the function? 
 In such cases, you can just wrap the function call inside another function.
  
 The following code is valid, but not recommended:
  
 // bad idea
  
 var id = setInterval(""alert('boo, boo')"", 2000);
  
 [
  225 
 ]",NA
window.document,"window.document
  is a BOM object that refers to the currently loaded document (page). 
 Its methods and properties fall into the DOM category of objects. Take a deep breath (and 
 maybe first look at the BOM exercises at the end of the chapter) and let's dive into the 
 DOM.
  
 [
  226 
 ]",NA
DOM,"The Document Object Model (DOM) represents an XML or an HTML document as a tree 
 of nodes. Using DOM methods and properties, you can access any element on the page, 
 modify or remove elements, or add new ones. The DOM is a language-independent API 
 (Application Programming Interface) and can be implemented not only in JavaScript, 
 but also in any other language. For example, you can generate pages on the server-side 
 with PHP's DOM implementation (
 http://php.net/dom
 ).
  
 Take a look at this example HTML page:
  
 <!DOCTYPE html> 
  
 <html>
  
  
  <head>
  
  
  <title>My page</title>
  
  
  </head>
  
  
  <body>
  
  
  <p class=""opener"">first paragraph</p>
  
  
  <p><em>second</em> paragraph</p>
  
  
  <p id=""closer"">final</p>
  
  
  <!-- and that's about it -->
  
  
  </body> 
  
 </html>
  
 Consider the second paragraph (
 <p><em>second</em> paragraph</p>
 ). You see that 
 it's a 
 <p>
  tag and it's contained in the 
 <body>
  tag. If you think in terms of family 
 relationships, you can say that 
 <body>
  is the parent of 
 <p>
  and 
 <p>
  is the child. The first 
 and the third paragraphs would also be children of the 
 <body>
 , and at the same time 
 siblings of the second paragraph. The 
 <em>
  tag is a child of the second 
 <p>
 , so 
 <p>
  is its 
 parent. The parent-child relationships can be represented graphically in an ancestry 
 tree, called the DOM tree:
  
  
 [
  227 
 ]",NA
Core DOM and HTML DOM,"One last diversion before moving on to more practical examples. As you now know, the 
 DOM represents both XML documents and HTML documents. In fact, HTML documents 
 are XML documents, but a little more specific. Therefore, as part of DOM Level 1, there is 
 a Core DOM specification that is applicable to all XML documents, and there is also an 
 HTML DOM specification, which extends and builds upon the core DOM. Of course, the 
 HTML DOM doesn't apply to all XML documents, but only to HTML documents. Let's see 
 some examples of Core DOM and HTML DOM constructors:
  
 Constructor 
  
 Inherits from 
  
 Core or 
  
 Comment 
  
 HTML 
  
 Node
  
 Node
  
 Core
  
 Any node on the tree.
  
 Document
  
 Core
  
 The 
 document
  object, the main 
  
 HTMLDocument
  
 Document
  
 entry point to any XML document.
  
 HTML
  
 This is 
 window.document
  or 
  
 Element
  
 Node
  
 simply 
 document
 , the HTML-
  
 specific version of the previous 
  
 Core
  
 object, which you'll use extensively.
  
 Every tag in the source is 
  
 HTMLElement
  
 Element
  
 represented by an element. That's 
  
 why you say ""the P element"" 
  
 HTML
  
 meaning ""the 
 <p></p>
  tag"".
  
 General-purpose constructor, all 
  
 HTMLBodyElement
  
 HTMLElement
  
 HTML
  
 constructors for HTML elements 
  
 inherit from it.
  
 Element representing the 
 <body>
  
 HTMLLinkElement
  
 HTMLElement
  
 tag.
  
 HTML
  
 An A element (an 
 <a 
  
 and other such 
  
 HTMLElement
  
 HTML
  
 href=""...""></a>
  tag).
  
 All the rest of the HTML elements.
  
 constructors.
  
 Node
  
 Core
  
 General-purpose constructor for 
  
 CharacterData
  
 Text
  
 CharacterData
  
 dealing with texts.
  
 Core
  
 Text node inside a tag. In 
  
 Comment
  
 CharacterData
  
 Core
  
 <em>second</em>
  you have the 
  
 element node EM and the text node 
  
 with value second.
  
 <!-- any comment -->
  
 [
  229 
 ]",NA
Accessing DOM nodes,"Before you can validate the user input in a form on a page or swap an image, you need 
 to get access to the element you want to inspect or modify. Luckily, there are many 
 ways to get to any element, either by navigating around traversing the DOM tree or by 
 using a shortcut.
  
 It's best if you start experimenting with all of the new objects and methods. The 
 examples you'll see use the same simple document that you saw at the beginning of the 
 DOM section, and which you can access at 
 http://www.phpied.com/files/ 
 jsoop/ch7.html
 . Open your console, and let's get started.
  
 [
  230 
 ]",NA
The document node,"document
  gives you access to the current document. To explore this object, you 
 can use your console as a cheat sheet. Type 
 console.dir(document)
  and click 
 on the result:
  
  
 Alternatively, you can you can browse all of the properties and methods of the 
 document
  object DOM properties in the 
 Elements
  panel:
  
  
 [
  231 
 ]",NA
documentElement ,"Now, let's move around the tree. XML documents always have one root node that wraps 
 the rest of the document. For HTML documents, the root is the 
 <html>
  tag. To access the 
 root, you use the 
 documentElement
  property of the 
 document
  object:
  
 > document.documentElement;
  
  
  <html>…</html>
  
 nodeType
  is 
 1
  (an element node) which can be seen as follows:
  
 > document.documentElement.nodeType;
  
  
  1
  
 For element nodes, both 
 nodeName
  and 
 tagName
  properties contain the name of the 
 tag, as seen in the following output:
  
 > document.documentElement.nodeName;
  
  
  ""HTML""
  
 > document.documentElement.tagName;
  
  
  ""HTML""
  
 [
  232 
 ]",NA
Child nodes ,"In order to tell if a node has any children you use 
 hasChildNodes()
  as follows: 
  
 > 
 document.documentElement.hasChildNodes();
  
  
  
  true 
  
 The HTML element has three children, the 
 head
  and the 
 body
  elements and the 
 whitespace between them (whitespace is counted in most, but not all browsers). You can 
 access them using the 
 childNodes
  array-like collection as follows: 
  
  
 > document.documentElement.childNodes.length;
  
  
  
  3 
  
  
 > document.documentElement.childNodes[0];
  
  
  
  <head>…</head> 
  
  
 > document.documentElement.childNodes[1];
  
  
  
  #text 
  
  
 > document.documentElement.childNodes[2];
  
  
  
  <body>…</body> 
  
 Any child has access to its parent through the 
 parentNode
  property, as seen in the 
 following code: 
  
  
 > document.documentElement.childNodes[1].parentNode;
  
  
  
  <html>…</html> 
  
 Let's assign a reference to 
 body
  to a variable as follows: 
  
  
 > var bd = document.documentElement.childNodes[2]; 
  
 How many children does the 
 body
  element have?
  
  
 > bd.childNodes.length;
  
  
   
  9 
  
 As a refresher, here again is the 
 body
  of the document:
  
  
  <body>
  
  
   
  <p class=""opener"">first paragraph</p>
  
  
  
  <p><em>second</em> paragraph</p>
  
  
   
  <p id=""closer"">final</p>
  
  
   
  <!-- and that's about it -->
  
  
  
  </body>
  
 [
  233 
 ]",NA
Attributes,"Because the first child of the body is a whitespace, the second child (index 1) is the 
 first paragraph. Refer to the following piece of code:
  
 > bd.childNodes[1];
  
  <p class=""opener"">first paragraph</p>
  
 You can check whether an element has attributes using 
 hasAttributes()
  as follows:
  
 > bd.childNodes[1].hasAttributes();
  
  true
  
 How many attributes? In this example, one is the 
 class
  attribute which can be seen as 
 follows:
  
 > bd.childNodes[1].attributes.length;
  
  1
  
 You can access the attributes by index and by name. You can also get the value using the 
 getAttribute()
  method as follows:
  
 > bd.childNodes[1].attributes[0].nodeName;
  
  ""class""
  
 > bd.childNodes[1].attributes[0].nodeValue;
  
  ""opener""
  
 > bd.childNodes[1].attributes['class'].nodeValue;
  
  ""opener""
  
 > bd.childNodes[1].getAttribute('class');
  
  ""opener""",NA
Accessing the content inside a tag,"Let's take a look at the first paragraph:
  
 > bd.childNodes[1].nodeName;
  
  ""P""
  
 [
  234 
 ]",NA
DOM access shortcuts,"By using 
 childNodes
 , 
 parentNode
 , 
 nodeName
 , 
 nodeValue
 , and 
 attributes
  you can 
 navigate up and down the tree and do anything with the document. But the fact that 
 whitespace is a text node makes this a fragile way of working with the DOM. If the page 
 changes, your script may no longer work correctly. Also, if you want to get to a node 
 deeper in the tree, it could take a bit of code before you get there. That's why you have 
 shortcut methods, namely, 
 getElementsByTagName()
 , 
 getElementsByName()
 , and 
 getElementById()
 .
  
 [
  235 
 ]",NA
"Siblings, body, first, and last child ","nextSibling
  and 
 previousSibling
  are two other convenient properties to navigate the 
 DOM tree, once you have a reference to one element:
  
 > var para = document.getElementById('closer'); 
 > para.nextSibling;
  
  
  #text
  
 > para.previousSibling;
  
  
  #text
  
 > para.previousSibling.previousSibling;
  
  
  <p>…</p>
  
 > para.previousSibling.previousSibling.previousSibling;
  
  #text
  
 > para.previousSibling.previousSibling.nextSibling.nextSibling;
  
  
 <p id=""closer"">final</p>
  
 [
  237 
 ]",NA
Walk the DOM ,"To wrap up, here's a function that takes any node and walks through the DOM tree 
 recursively, starting from the given node:
  
 function walkDOM(n) {
  
  
  do {
  
  
  console.log(n);
  
  
  if (n.hasChildNodes()) {
  
    
  walkDOM(n.firstChild);
  
  
  }
  
  
  } while (n = 
 n.nextSibling); 
  
 }
  
 You can test the function as follows:
  
 > walkDOM(document.documentElement); 
  
 > walkDOM(document.body);",NA
Modifying DOM nodes ,"Now that you know a whole lot of methods for accessing any node of the DOM tree and 
 its properties, let's see how you can modify these nodes.
  
 Let's assign a pointer to the last paragraph to the variable 
 my
  as follows:
  
 > var my = document.getElementById('closer'); 
  
 Now, changing the text of the paragraph can be as easy as changing the 
 innerHTML
  value:
  
 > my.innerHTML = 'final!!!';
  
  
  ""final!!!""
  
 Because 
 innerHTML
  accepts a string of HTML source code, you can also create a new 
 em
  
 node in the DOM tree as follows:
  
 > my.innerHTML = '<em>my</em> final';
  
  
  ""<em>my</em> final""
  
 The new 
 em
  node becomes a part of the tree:
  
 > my.firstChild;
  
  
  <em>my</em>
  
 > my.firstChild.firstChild;
  
  
  ""my""
  
 [
  239 
 ]",NA
Modifying styles,"Often you don't change the content of a node but its presentation. The elements have a 
 style
  property, which in turn has a property mapped to each CSS property. For 
 example, changing the style of the paragraph to add a red border:
  
 > my.style.border = ""1px solid red"";
  
  ""1px solid red""
  
 CSS properties often have dashes, but dashes are not acceptable in JavaScript identifiers. 
 In such cases, you skip the dash and uppercase the next letter. So 
 padding-top
  
 becomes 
 paddingTop
 , 
 margin-left
  becomes 
 marginLeft
 , and so on. 
  
 Have a look at the following code:
  
 > my.style.fontWeight = 'bold';
  
  ""bold""
  
 You also have access to 
 cssText
  property of 
 style
 , which lets you work with styles as 
 strings:
  
 > my.style.cssText;
  
  ""border: 1px solid red; font-weight: bold;""
  
 And modifying styles is a string manipulation:
  
 > my.style.cssText += "" border-style: dashed;""
  
 ""border: 1px dashed red; font-weight: bold; border-style: dashed;""",NA
Fun with forms,"As mentioned earlier, JavaScript is great for client-side input validation and can save a 
 few round-trips to the server. Let's practice form manipulations and play a little bit with 
 a form located on a popular page 
 www.google.com
 :
  
  
 [
  240 
 ]",NA
Creating new nodes,"To create new nodes, you can use the methods 
 createElement()
  and 
  
 createTextNode()
 . Once you have the new nodes, you add them to the DOM 
 tree using 
 appendChild()
  (or 
 insertBefore()
 , or 
 replaceChild()
 ).
  
 Reload 
 http://www.phpied.com/files/jsoop/ch7.html
  and let's play.
  
 Creating a new 
 p
  element and set its 
 innerHTML
 , as shown in the following code:
  
 > var myp = document.createElement('p');
  
 > myp.innerHTML = 'yet another';
  
  ""yet another""
  
 The new element automatically gets all the default properties, such as 
 style
 , which you 
 can modify:
  
 > myp.style;
  
  CSSStyleDeclaration
  
 > myp.style.border = '2px dotted blue';
  
  ""2px dotted blue""
  
 Using 
 appendChild()
  you can add the new node to the DOM tree. Calling this method 
 on the 
 document.body
  node means creating one more child node right after the last 
 child:
  
 > document.body.appendChild(myp);
  
  <p style=""border: 2px dotted blue;"">yet another</p>
  
 Here's an illustration of how the page looks like after the new node is appended:
  
  
 [
  242 
 ]",NA
DOM-only method ,"innerHTML
  gets things done a little more quickly than using pure DOM. In pure 
 DOM you need to perform the following steps:
  
 1. Create a new text node containing yet another text
  
 2. Create a new paragraph node
  
 3. Append the text node as a child to the paragraph
  
 4. Append the paragraph as a child to the body
  
 This way you can create any number of text nodes and elements and nest them 
 however you like. Let's say you want to add the following HTML to the end of the 
 body:
  
 <p>one more paragraph<strong>bold</strong></p>
  
 Presenting this as a hierarchy would be something like the following:
  
 P element
  
  text node with value ""one more paragraph"" 
 STRONG element
  
  
  
  text node with value ""bold""
  
 The code that accomplishes this is as follows:
  
 // create P 
  
 var myp = document.createElement('p'); 
  
 // create text node and append to P 
  
 var myt = document.createTextNode('one more paragraph'); 
 myp.appendChild(myt); 
  
 // create STRONG and append another text node to it var 
 str = document.createElement('strong'); 
  
 str.appendChild(document.createTextNode('bold')); 
  
 // append STRONG to P 
  
 myp.appendChild(str); 
  
 // append P to BODY 
  
 document.body.appendChild(myp);",NA
cloneNode() ,"Another way to create nodes is by copying (or cloning) existing ones. The method 
 cloneNode()
  does this and accepts a boolean parameter (
 true
  = deep copy with all the 
 children, 
 false
  = shallow copy, only this node). Let's test the method.
  
 [
  243 
 ]",NA
insertBefore(),"Using 
 appendChild()
 , you can only add new children at the end of the selected element. 
 For more control over the exact location there is 
 insertBefore()
 . This is the same as 
 appendChild()
 , but accepts an extra parameter specifying where (before which 
 element) to insert the new node. For example, the following code inserts a text node at the 
 end of the 
 body
 :
  
 > document.body.appendChild(document.createTextNode('boo!'));
  
 [
  244 
 ]",NA
Removing nodes ,"To remove nodes from the DOM tree, you can use the method 
 removeChild()
 . 
  
 Again, let's start fresh with the same page with the body:
  
  <body>
  
  <p class=""opener"">first paragraph</p>
  
  <p><em>second</em> paragraph</p>
  
  <p id=""closer"">final</p>
  
  <!-- and that's about it -->
  
  </body>
  
 Here's how you can remove the second paragraph:
  
 > var myp = 
 document.getElementsByTagName('p')[1]; > var 
 removed = document.body.removeChild(myp);
  
 The method returns the removed node if you want to use it later. You can still use all the 
 DOM methods even though the element is no longer in the tree:
  
 > removed;
  
  
  <p>…</p>
  
 > removed.firstChild;
  
  
  <em>second</em>
  
 There's also the 
 replaceChild()
  method that removes a node and puts another one in 
 its place. 
  
 After removing the node, the tree looks like the following:
  
  <body>
  
  <p class=""opener"">first paragraph</p>
  
  <p id=""closer"">final</p>
  
  <!-- and that's about it -->
  
  </body>
  
 [
  245 
 ]",NA
HTML-only DOM objects,"As you know already, the Document Object Model applies to both XML and HTML 
 documents. What you've learned above about traversing the tree and then adding, 
 removing, or modifying nodes applies to any XML document. There are, however, some 
 HTML-only objects and properties.
  
 document.body
  is one such HTML-only object. It's so common to have a 
 <body>
  
 tag in HTML documents and it's accessed so often, that it makes sense to have an 
 object that's shorter and friendlier than the equivalent 
 document. 
 getElementsByTagName('body')[0]
 .
  
 document.body
  is one example of a legacy object inherited from the prehistoric DOM 
 Level 0 and moved to the HTML extension of the DOM specification. There are other 
 objects similar to 
 document.body
 . For some of them there is no core DOM equivalent, 
 for others there is an equivalent, but the DOM0 original was ported anyway for 
 simplicity and legacy purposes. Let's see some of those objects.",NA
Primitive ways to access the document,"Unlike the DOM, which gives you access to any element (and even comments and 
 whitespace), initially JavaScript had only limited access to the elements of an HTML 
 document. This was done mainly through a number of collections:
  
 • 
  
 • 
  
 document.images
 : This is a collection of all of the images on the page. The 
 Core DOM equivalent is 
 document.getElementsByTagName('img')
  
 document.applets
 : This is the same as 
 document.
  
 getElementsByTagName('applet')
  
 • 
  
 document.links
  
 • 
  
 document.anchors
  
 • 
  
 document.forms
  
 document.links
  contains a list of all 
 <a href=""...""></a>
  tags on the page, 
 meaning the 
 <a>
  tags that have an 
 href
  attribute. 
 document.anchors
  contain all 
 links with a 
 name
  attribute (
 <a name=""...""></a>
 ).
  
 One of the most widely used collections is 
 document.forms
 , which contains a list of 
 <form>
  elements.
  
 Let's play with a page that contains a form and an input, 
 http://www.phpied.com/ 
 files/jsoop/ch7-form.html
 . The following gives you access to the first form on the 
 page:
  
 > document.forms[0];
  
 [
  247 
 ]",NA
document.write() ,"The method 
 document.write()
  allows you to insert HTML into the page while the page 
 is being loaded. You can have something like the following code: 
  
  
 <p>It is now 
  
  
  
  <script>
  
  
  
  document.write(""<em>"" + new Date() + ""</em>"");
  
  
  
  </script> 
  
  
 </p> 
  
 This is the same as if you had the date directly in the source of the HTML document as 
 follows: 
  
  
 <p>It is now 
  
  
  
  <em>Fri Apr 26 2013 16:55:16 GMT-0700 (PDT)</em> 
  
  
 </p>
  
 [
  248 
 ]",NA
"Cookies, title, referrer, domain","The four additional properties of 
 document
  you'll see in this section are also ported 
 from DOM Level 0 to the HTML extension of DOM Level 1. Unlike the previous ones, for 
 these properties there are no core DOM equivalents.
  
 document.cookie
  is a property that contains a string. This string is the content of the 
 cookies exchanged between the server and the client. When the server sends a page to the 
 browser, it may include the 
 Set-Cookie
  HTTP header. When the client sends a request to 
 the server, it sends the cookie information back with the 
 Cookie
  header. 
  
 Using 
 document.cookie
  you can alter the cookies the browser sends to the server. For 
 example, visiting 
 cnn.com
  and typing 
 document.cookie
  in the console gives you the 
 following output:
  
 > document.cookie;
  
  ""mbox=check#true#1356053765|session#1356053704195-121286#1356055565;...
  
 document.title
  allows you to change the title of the page displayed in the browser 
 window. For example, see the following code:
  
 > document.title = 'My title';
  
  ""My title""
  
 Note, that this doesn't change the value of the 
 <title>
  element, but only the 
 display in the browser window, so it's not equivalent to 
 document. 
 querySelector('title')
 .
  
 document.referrer
  tells you the URL of the previously-visited page. This is the same 
 value the browser sends in the 
 Referer
  HTTP header when requesting the page. 
 (Note, that 
 Referer
  is misspelled in the HTTP headers, but is correct in JavaScript's 
 document.referrer
 ). If you've visited the CNN page by searching on Yahoo first, you 
 can see something like the following:
  
 > document.referrer;
  
  ""http://search.yahoo.com/search?p=cnn&ei=UTF-8&fr=moz2""
  
 [
  249 
 ]",NA
Events,"Imagine you are listening to a radio program and they announce, ""Big event! Huge! 
 Aliens have landed on Earth!"" You might think ""Yeah, whatever"", some other listeners 
 might think ""They come in peace"" and some ""We're all gonna die!"". Similarly, the 
 browser broadcasts events and your code could be notified should it decide to tune in 
 and listen to the events as they happen. Some example events include:
  
 • 
  
 The user clicks a button
  
 • 
  
 The user types a character in a form field
  
 • 
  
 The page finishes loading
  
 [
  250 
 ]",NA
Inline HTML attributes,"Adding specific attributes to a tag is the laziest (but the least maintainable) way, for 
 example:
  
 <div onclick=""alert('Ouch!')"">click</div>
  
 In this case when the user clicks on the 
 <div>
 , the click event fires and the string of 
 JavaScript code contained in the 
 onclick
  attribute is executed. There's no explicit 
 function that listens to the click event, but behind the scenes a function is still created and 
 it contains the code you specified as a value of the 
 onclick
  attribute.",NA
Element Properties,"Another way to have some code executed when a click event fires is to assign a 
 function to the 
 onclick
  property of a DOM node element. For example:
  
 <div id=""my-div"">click</div>
  
 <script>
  
  var myelement = document.getElementById('my-div');
  
  myelement.onclick = function () {
  
  alert('Ouch!');
  
  alert('And double ouch!');
  
  };
  
 </script>
  
 This way is better because it helps you keep your 
 <div>
  clean of any JavaScript code. 
 Always keep in mind that HTML is for content, JavaScript for behavior, and CSS for 
 formatting, and you should keep these three separate as much as possible.
  
 This method has the drawback that you can attach only one function to the event, as if the 
 radio program has only one listener. It's true that you can have a lot happening inside the 
 same function, but this is not always convenient, as if all the radio listeners are in the 
 same room.
  
 [
  251 
 ]",NA
DOM event listeners,"The best way to work with browser events is to use the event listener approach outlined 
 in DOM Level 2, where you can have many functions listening to an event. 
  
 When the event fires, all functions are executed. All of the listeners don't need to know 
 about each other and can work independently. They can tune in and out at any time 
 without affecting the other listeners.
  
 Let's use the same simple markup from the previous section (available for you to play 
 with at 
 http://www.phpied.com/files/jsoop/ch7.html
 ). It has this piece of 
 markup as follows:
  
 <p id=""closer"">final</p>
  
 Your JavaScript code can assign listeners to the click event using the 
 addEventListener()
  method. Let's attach two listeners as follows:
  
 var mypara = document.getElementById('closer');
  
 mypara.addEventListener('click', function () {
  
  alert('Boo!');
  
 }, false);
  
 mypara.addEventListener(
  
  'click', console.log.bind(console), false);
  
 As you can see, 
 addEventListeners()
  is a method called on the node object and 
 accepts the type of event as its first parameter and a function pointer as its second. 
  
 You can use anonymous functions such as 
 function () { alert('Boo!'); }
  or 
 existing functions such as 
 console.log
 . The listener functions you specify are called 
 when the event happens and an argument is passed to them. This argument is an event 
 object. If you run the preceding code and click on the last paragraph, you can see event 
 objects being logged to the console. Clicking on an event object allows you to see its 
 properties:
  
 [
  252 
 ]",NA
Capturing and bubbling ,"In the calls to 
 addEventListener()
 , there was a third parameter, 
 false
 . Let's see 
 what is it for.
  
 Say you have a link inside an unordered list as follows:
  
 <body>
  
  
  <ul>
  
  
  <li><a href=""http://phpied.com"">my blog</a></li>
  
  </ul> 
  
 </body>
  
 [
  253 
 ]",NA
Stop propagation ,"Let's see an example of how you can stop the event from bubbling up. Going back to the 
 test document, there is this piece of code:
  
 <p id=""closer"">final</p>
  
 Let's define a function that handles clicks on the paragraph:
  
 function paraHandler() {
  
  
  alert('clicked paragraph'); 
  
 }
  
 Now, let's attach this function as a listener to the click event:
  
 var para = document.getElementById('closer'); 
  
 para.addEventListener('click', paraHandler, false);
  
 Let's also attach listeners to the click event on the body, the document, and the 
 browser window:
  
 document.body.addEventListener('click', function () {
  
  alert('clicked body'); 
  
 }, false); 
  
 document.addEventListener('click', function () {
  
  
 alert('clicked doc');
  
 [
  255 
 ]",NA
Prevent default behavior ,"Some browser events have a predefined behavior. For example, clicking a link causes 
 the browser to navigate to another page. You can attach listeners to clicks on a link 
 and you can also disable the default behavior by calling the method 
 preventDefault()
  on the event object.
  
 Let's see how you can annoy your visitors by asking ""Are you sure you want to follow 
 this link?"" every time they click a link. If the user clicks on 
 Cancel
  (causing 
 confirm()
  to return 
 false
 ), the 
 preventDefault()
  method is called as follows:
  
 // all links 
  
 var all_links = document.getElementsByTagName('a'); 
  
 for (var i = 0; i < all_links.length; i++) { // loop all 
 links
  
  all_links[i].addEventListener(
  
  
  'click',       // event type
  
  
  function (e) { // handler
  
    
  if (!confirm('Sure you want to follow this link?')) {
     
  e.preventDefault();
  
    
  }
  
  
  },
  
  
  false // don't use capturing
  
  
  ); 
  
 }
  
 Note, that not all events allow you to prevent the default behavior. Most do, but if you 
 want to be sure, you can check the 
 cancellable
  property of the event object.
  
 [
  257 
 ]",NA
Cross-browser event listeners,"As you already know, most modern browsers almost fully implement the DOM Level 1 
 specification. However, the events were not standardized until DOM 2. As a result, there 
 are quite a few differences in how IE before version 9 implements this functionality 
 compared to modern browsers.
  
 Check out an example that causes the 
 nodeName
  of a clicked element (the target 
 element) to be written to the console:
  
 document.addEventListener('click', function (e) {
  
  console.log(e.target.nodeName);
  
 }, false);
  
 Now, let's take a look at how IE is different:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 In IE there's no 
 addEventListener()
  method, although since IE Version 5 
 there is an equivalent 
 attachEvent()
 . For earlier versions, your only choice is 
 accessing the property (such as 
 onclick
 ) directly.
  
 click
  event becomes 
 onclick
  when using 
 attachEvent()
 .
  
 If you listen to events the old-fashioned way (for example, by setting a function 
 value to the 
 onclick
  property), when the callback function is invoked, it doesn't 
 get an event object passed as a parameter. But, regardless of how you attach the 
 listener in IE, there is always a global object 
 window.event
  that points to the 
 latest event.
  
 In IE the event object doesn't get a 
 target
  attribute telling you the element 
 on which the event fired, but it does have an equivalent property called 
 srcElement
 .
  
 As mentioned before, event capturing doesn't apply to all events, so only 
 bubbling should be used.
  
 There's no 
 stopPropagation()
  method, but you can set the IE-only 
 cancelBubble
  property to 
 true
 .
  
 There's no 
 preventDefault()
  method, but you can set the IE-only 
 returnValue
  property to 
 false
 .
  
 To stop listening to an event, instead of 
 removeEventListener()
  in IE you'll 
 need 
 detachEvent()
 .
  
 So, here's the revised version  of the previous code that works across browsers:
  
 function callback(evt) {
  
  // prep work
  
  evt = evt || window.event;
  
 [
  258 
 ]",NA
Types of events ,"Now you know how to handle cross-browser events. But all of the examples above 
 used only click events. What other events are happening out there? As you can 
 probably guess, different browsers provide different events. There is a subset of 
 cross-browser events and some browser-specific ones. For a full list of events, you 
 should consult the browser's documentation, but here's a selection of cross-browser 
 events:
  
 • 
  
 • 
  
 • 
  
 Mouse events
  
 °
  
 mouseup, mousedown, click (the sequence is mousedown-up-click), 
  
 dblclick
  
 °
  
 mouseover (mouse is over an element), mouseout (mouse was over 
  
  
 an element but left it), mousemove 
 Keyboard events
  
 °
  
 keydown, keypress, keyup (occur in this sequence)
  
 Loading/window events
  
 °
  
 load (an image or a page and all of its components are done loading), 
  
 unload (user leaves the page), beforeunload (the script can provide the 
 user with an option to stop the unload)
  
 °
  
 abort (user stops loading the page or an image in IE), error (a 
  
 JavaScript error, also when an image cannot be loaded in IE)
  
 °
  
 resize (the browser window is resized), scroll (the page is scrolled), 
  
 contextmenu (the right-click menu appears)
  
 [
  259 
 ]",NA
XMLHttpRequest,"XMLHttpRequest()
  is an object (a constructor function) that allows you to send HTTP 
 requests from JavaScript. Historically, 
 XMLHttpRequest
  (or XHR for short) was 
 introduced in IE and was implemented as an ActiveX object. Starting with IE7 it's a native 
 browser object, the same way as it's in the other browsers. The common implementation 
 of this object across browsers gave birth to the so-called Ajax applications, where it's no 
 longer necessary to refresh the whole page every time you need new content. With 
 JavaScript, you can make an HTTP request to the server, get the response, and update only 
 a part of the page. This way you can build much more responsive and desktop-like web 
 pages.
  
 Ajax
  stands for 
 Asynchronous JavaScript and XML
 .
  
 • 
  
 • 
  
 • 
  
 Asynchronous because after sending an HTTP request your code doesn't 
 need to wait for the response, but it can do other stuff and be notified 
 (through an event) when the response arrives.
  
 JavaScript because it's obvious that XHR objects are created with JavaScript.
  
 XML because initially developers were making HTTP requests for XML 
 documents and were using the data contained in them to update the page. This is 
 no longer a common practice, though, as you can request data in plain text, in the 
 much more convenient JSON format, or simply as HTML ready to be inserted into 
 the page.
  
 [
  260 
 ]",NA
Sending the request,"In order to create an object you simply use the following code (let's deal with 
 browser inconsistencies in just a bit):
  
 var xhr = new XMLHttpRequest();
  
 The next thing is to attach an event listener to the 
 readystatechange
  event fired by the 
 object:
  
 xhr.onreadystatechange = myCallback;
  
 Then, you need to call the 
 open()
  method, as follows:
  
 xhr.open('GET', 'somefile.txt', true);
  
 The first parameter specifies the type of HTTP request (
 GET
 , 
 POST
 , 
 HEAD
 , and so on). 
 GET
  
 and 
 POST
  are the most common. Use 
 GET
  when you don't need to send much data with 
 the request and your request doesn't modify (write) data on the server, otherwise use 
 POST
 . The second parameter is the URL you are requesting. In this example, it's the text 
 file 
 somefile.txt
  located in the same directory as the page. The last parameter is a 
 boolean specifying whether the request is asynchronous (
 true
 , always prefer this) or 
 not (
 false
 , blocks all the JavaScript execution and waits until the response arrives).
  
 The last step is to fire off the request which is done as follows:
  
 xhr.send('');
  
 The method 
 send()
  accepts any data you want to send with the request. For 
 GET 
 requests, this is an empty string, because the data is in the URL. For 
 POST
  request, it's 
 a query string in the form 
 key=value&key2=value2
 .
  
 At this point, the request is sent and your code (and the user) can move on to other 
 tasks. The callback function 
 myCallback
  will be invoked when the response comes 
 back from the server.
  
 [
  261 
 ]",NA
Processing the response,"A listener is attached to the 
 readystatechange
  event. So what exactly is the ready 
 state and how does it change?
  
 There is a property of the XHR object called 
 readyState
 . Every time it changes, the 
 readystatechange
  event fires. The possible values of the 
 readyState
  property are 
 as follows:
  
 • 
  
 0-uninitialized
  
 • 
  
 1-loading
  
 • 
  
 2-loaded
  
 • 
  
 3-interactive
  
 • 
  
 4-complete
  
 When 
 readyState
  gets the value of 4, it means the response is back and ready to be 
 processed. In 
 myCallback
  after you make sure 
 readyState
  is 4, the other thing to 
 check is the status code of the HTTP request. You might have requested a non-
 existing URL for example and get a 404 (File not found) status code. The interesting 
 code is the 200 (OK) code, so 
 myCallback
  should check for this value. The status 
 code is available in the 
 status
  property of the XHR object.
  
 Once 
 xhr.readyState
  is 4 and 
 xhr.status
  is 200, you can access the contents of the 
 requested URL using the 
 xhr.responseText
  property. Let's see how 
 myCallback 
 could 
 be implemented to simply 
 alert()
  the contents of the requested URL:
  
 function myCallback() {
  
  if (xhr.readyState < 4) {
  
  return; // not ready yet
  
  }
  
  if (xhr.status !== 200) {
  
  alert('Error!'); // the HTTP status code is not OK
  
  return;
  
  }
  
  //  all is fine, do the work
  
  alert(xhr.responseText);
  
 }
  
 Once you've received the new content you requested, you can add it to the page, or use 
 it for some calculations, or for any other purpose you find suitable.
  
 [
  262 
 ]",NA
Creating XMLHttpRequest objects in IE prior ,NA,NA
to Version 7,"In Internet Explorer prior to version 7, the 
 XMLHttpRequest
  object was an ActiveX 
 object, so creating an XHR instance is a little different. It goes like the following:
  
 var xhr = new ActiveXObject('MSXML2.XMLHTTP.3.0');
  
 MSXML2.XMLHTTP.3.0 is the identifier of the object you want to create. There are 
 several versions of the 
 XMLHttpRequest
  object and if your page visitor doesn't have the 
 latest one installed, you can try two older ones, before you give up.
  
 For a fully-cross-browser solution, you should first test to see if the user's browser 
 supports 
 XMLHttpRequest
  as a native object, and if not, try the IE way. Therefore, the 
 whole process of creating an XHR instance could be like this:
  
 var ids = ['MSXML2.XMLHTTP.3.0', 
  
  'MSXML2.XMLHTTP', 
  
  'Microsoft.XMLHTTP']; 
  
 var xhr;
  
 if (XMLHttpRequest) {
  
  xhr = new XMLHttpRequest();
  
 } else {
  
  // IE: try to find an ActiveX object to use
  
  for (var i = 0; i < ids.length; i++) {
  
  try {
  
  xhr = new ActiveXObject(ids[i]);
  
  break;
  
  } catch (e) {}
  
  }
  
 }
  
 What is this doing? The array 
 ids
  contains a list of ActiveX program IDs to 
  
 try. The variable 
 xhr
  points to the new XHR object. The code first checks to 
  
 see if 
 XMLHttpRequest
  exists. If so, this means that the browser supports 
  
 XMLHttpRequest()
  natively (so the browser is relatively modern). If it is not, the code 
 loops through 
 ids
  trying to create an object. 
 catch(e)
  quietly ignores failures and the 
 loop continues. As soon as an 
 xhr
  object is created, you 
 break
  out of the loop.
  
 [
  263 
 ]",NA
A is for Asynchronous,"Now you know how to create an XHR object, give it a URL and handle the response to 
 the request. What happens when you send two requests asynchronously? What if the 
 response to the second request comes before the first?
  
 In the example above, the XHR object was global and 
 myCallback
  was relying on the 
 presence of this global object in order to access its 
 readyState
 , 
 status
 , and 
 responseText
  properties. Another way, which prevents you from relying on global 
 variables, is to wrap the callback in a closure. Let's see how:
  
 var xhr = new XMLHttpRequest();
  
 xhr.onreadystatechange = (function (myxhr) {
  
  return function () { 
  
  myCallback(myxhr); 
  
  };
  
 }(xhr));
  
 xhr.open('GET', 'somefile.txt', true);
  
 xhr.send('');
  
 In this case 
 myCallback()
  receives the XHR object as a parameter and is not going to 
 look for it in the global space. This also means that at the time the response is received, 
 the original 
 xhr
  might have been reused for a second request. The closure keeps 
 pointing to the original object.",NA
X is for XML,"Although these days JSON (discussed in the next chapter) is preferred over XML as a 
 data transfer format, XML is still an option. In addition to the 
 responseText 
 property, the XHR objects also have another property called 
 responseXML
 . 
  
 When you send an HTTP request for an XML document, 
 responseXML
  points to 
 an XML DOM document object. To work with this document, you can use all of the 
 core DOM methods discussed previously in this chapter, such as 
 getElementsByTagName()
 , 
 getElementById()
 , and so on.
  
 [
  264 
 ]",NA
An example ,"Let's wrap up the different XHR topics with an example. You can visit the page 
 located at 
 http://www.phpied.com/files/jsoop/xhr.html
  to work on the 
 example yourself:
  
 The main page, 
 xhr.html
 , is a simple static page that contains nothing but three 
 <div>
  tags.
  
 <div 
 id=""text"">Text 
 will 
 be 
 here</div> 
  
 <div 
 id=""html"">HTML 
 will 
 be 
 here</div> 
  
 <div id=""xml"">XML will be here</div>
  
 Using the console, you can write code that requests three files and loads their 
 respective contents into each 
 <div>
 .
  
 The three files to load are:
  
 • 
  
 content.txt
 : a simple text file containing the text ""I am a text file""
  
 • 
  
 content.html
 : a file containing HTML code 
 ""I am <strong>formatted</ 
  
 strong> <em>HTML</em>""
  
 • 
  
 content.xml
 : an XML file, containing the following code:
  
 <?xml version=""1.0"" ?> 
  
 <root>
  
  I'm XML data.
  
 </root>
  
 All of the files are stored in the same directory as 
 xhr.html
 .
  
  
 For security reasons you can only use the original 
 XMLHttpRequest
  
  
 to request files that are on the same domain. However, modern 
  
 browsers support XHR2 which lets you make cross-domain requests, 
  
 provided that the appropriate Access-Control-Allow-Origin HTTP 
  
 header is in place.
  
 First, let's create a function to abstract the request/response part:
  
 function request(url, callback) {
  
  
  var xhr = new XMLHttpRequest(); 
  
  
  xhr.onreadystatechange = (function (myxhr) {
  
  
  return function () {
  
    
  if (myxhr.readyState === 4 && myxhr.status === 200) {
     
  callback(myxhr);
  
    
  }
  
  
  };
  
 [
  265 
 ]",NA
Summary,"You learned quite a bit in this chapter. You have learned some cross-browser BOM 
 (Browser Object Model) objects:
  
 • 
  
 • 
  
 Properties of the global 
 window
  object such as 
 navigator
 , 
 location
 , 
 history
 , 
 frames
 , 
 screen
  
 Methods such as 
 setInterval()
  and 
 setTimeout()
 ; 
 alert()
 , 
 confirm() 
 and 
 prompt()
 ; 
 moveTo/By()
  and 
 resizeTo/By()
  
 Then you learned about the DOM (Document Object Model), an API to represent an 
 HTML (or XML) document as a tree structure where each tag or text is a node on the 
 tree. You also learned how to do the following actions:
  
 • 
  
 • 
  
 Access nodes
  
 °
  
 Using parent/child relationship properties 
 parentNode
 , 
 childNodes
 , 
  
 firstChild
 , 
 lastChild
 , 
 nextSibling
 , and 
 previousSibling
  
 °
  
 Using 
 getElementsById()
 , 
 getElementsByTagName()
 , 
  
  
 getElementsByName()
 , and 
 querySelectorAll() 
 Modify nodes:
  
 °
  
 Using 
 innerHTML
  or 
 innerText/textContent
  
 °
  
 Using 
 nodeValue
  or 
 setAttribute()
  or just using attributes as 
  
 object properties
  
 [
  267 
 ]",NA
Exercises,"In the previous chapters, the solutions to the exercises could be found in the text of the 
 chapter. This time, some of the exercises require you to do some more reading (or 
 experimentation) outside this book.
  
 1. BOM: As a BOM exercise, try coding something wrong, obtrusive, 
  
 user-unfriendly, and all in all, very Web 1.0, the shaking browser 
  
 window. Try implementing code that opens a 200 x 200 pop up window and 
 then resizes it slowly and gradually to 400 x 400. Next, move the window 
 around as if there's an earthquake. All you'll need is one of the 
 move*()
  
 functions, one or more calls to 
 setInterval()
 , and maybe one to 
 setTimeout()
 /
 clearInterval()
  to stop the whole thing. Or here's an easier 
 one, print the current date/time in the 
 document.title
  and update it every 
 second, like a clock.
  
 2. DOM:
  
 °
  
 Implement 
 walkDOM()
  differently. Also make it accept a callback 
 function instead of hard coding 
 console.log()
  
 [
  268 
 ]",NA
Coding and Design Patterns,"Now that you know all about the objects in JavaScript, you've mastered prototypes and 
 inheritance, and you have seen some practical examples of using browser-specific 
 objects, let's move forward, or rather move a level up. Let's have a look at some 
 common JavaScript patterns.
  
 But first, what's pattern? In short, a pattern is a good solution to a common problem.
  
 Sometimes when you're facing a new programming problem, you may recognize right 
 away that you've previously solved another, suspiciously similar problem. In such 
 cases, it's worth isolating this class of problems and searching for a common solution. 
 A pattern is a proven and reusable solution (or an approach to a solution) to a class of 
 problems.
  
 There are cases where a pattern is nothing more than an idea or a name. Sometimes just 
 using a name helps you think more clearly about a problem. Also, when working with 
 other developers in a team, it's much easier to communicate when everybody uses the 
 same terminology to discuss a problem or a solution.
  
 Other times you may come across a unique problem that doesn't look like anything 
 you've seen before and doesn't readily fit into a known pattern. Blindly applying a 
 pattern just for the sake of using a pattern is not a good idea. It's preferable to not use 
 any known pattern than to try to tweak your problem so that it fits an existing solution.
  
 This chapter talks about two types of patterns:
  
 • 
  
 • 
  
 Coding patterns
 : These are mostly JavaScript-specific best practices 
  
 Design patterns
 : These are language-independent patterns, popularized by the 
 famous ""Gang of Four"" book",NA
Coding patterns,"Let's start with some patterns that reflect JavaScript's unique features. Some patterns 
  
 aim to help you organize your code (for example, namespacing), others are related to 
  
 improving performance (such as lazy definitions and init-time branching), and some 
  
 make up for missing features such as private properties. The patterns discussed in 
  
 this section include:
  
 • 
  
 Separating behavior
  
 • 
  
 Namespaces
  
 • 
  
 Init-time branching
  
 • 
  
 Lazy definition
  
 • 
  
 Configuration objects
  
 • 
  
 Private variables and methods
  
 • 
  
 Privileged methods
  
 • 
  
 Private functions as public methods
  
 • 
  
 Immediate functions
  
 • 
  
 Chaining
  
 • 
  
 JSON",NA
Separating behavior,"As discussed previously, the three building blocks of a web page are as follows:
  
 • 
  
 Content (HTML)
  
 • 
  
 Presentation (CSS)
  
 • 
  
 Behavior (JavaScript)",NA
Content,"HTML is the content of the web page, the actual text. Ideally, the content should 
  
 be marked up using the least amount of HTML tags that sufficiently describe the 
  
 semantic meaning of that content. For example, if you're working on a navigation 
  
 menu it's a good idea to use 
 <ul>
  and 
 <li>
  since a navigation menu is in essence just 
  
 a list of links.
  
 [
  272 
 ]",NA
Presentation,"A good approach to keep presentation out of the content is to reset, or nullify all 
 browser defaults. For example, using 
 reset.css
  from the Yahoo! UI library. This way 
 the browser's default rendering won't distract you from consciously thinking about 
 the proper semantic tags to use.",NA
Behavior,"The third component of a web page is the behavior. Behavior should be kept separate 
 from both the content and the presentation. Behavior is usually added by using JavaScript 
 that is isolated to 
 <script>
  tags, and preferably contained in external files. This means 
 not using any inline attributes such as 
 onclick
 , 
 onmouseover
 , and so on. Instead, you 
 can use the 
 addEventListener
 /
 attachEvent
  methods from the previous chapter.
  
 The best strategy for separating behavior from content is as follows:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Minimize the number of 
 <script>
  tags 
  
 Avoid inline event handlers 
  
 Do not use CSS expressions 
  
 Dynamically add markup that has no purpose if JavaScript is disabled by the user 
  
 Towards the end of your content when you are ready to close the 
 <body>
  tag, 
 insert a single 
 external.js
  file
  
 [
  273 
 ]",NA
Example of separating behavior ,"Let's say you have a search form on a page and you want to validate the form with 
 JavaScript. So, you go ahead and keep the form tags free from any JavaScript, and then 
 immediately before the closing the 
 </body>
  tag you insert a 
 <script>
  tag which links 
 to an external file as follows:
  
 <body>
  
  
  <form id=""myform"" method=""post"" 
 action=""server.php"">
  
  <fieldset>
  
  
  <legend>Search</legend>
  
  
  <input 
  
    
  name=""search"" 
  
    
  id=""search"" 
  
    
  type=""text"" 
  
  
  />
  
  
  <input type=""submit"" />
  
  
  </fieldset>
  
  
  </form>
  
  
  <script src=""behaviors.js""></script> 
  
 </body>
  
 In 
 behaviors.js
  you attach an event listener to the submit event. In your listener, 
 you check to see if the text input field was left blank and if so, stop the form from being 
 submitted. This way you save a round trip between the server and the client and make 
 the application immediately responsive.
  
 The content of 
 behaviors.js
  is given in the following code. It assumes that you've 
 created your 
 myevent
  utility from the exercise at the end of the previous chapter:
  
 // init 
  
 myevent.addListener('myform', 'submit', function (e) {
  
  
  // no need to propagate further
  
  
  e = myevent.getEvent(e);
  
  
  myevent.stopPropagation(e);
  
  
  // validate
  
  
  var el = document.getElementById('search');
  
  
  if (!el.value) { // too bad, field is empty
  
  
  myevent.preventDefault(e); // prevent the form submission
  
  alert('Please enter a search string');
  
  
  } 
  
 });
  
 [
  274 
 ]",NA
Asynchronous JavaScript loading,"You noticed how the script was loaded at the end of the HTML right before closing the 
 body. The reason is that JavaScript blocks the DOM construction of the page and in 
 some browsers even the downloads of the other components that follow. By moving 
 the scripts to the bottom of the page you ensure the script is out of the way and when 
 it arrives, it simply enhances the already usable page.
  
 Another way to prevent external JavaScript files from blocking the page is to load them 
 asynchronously. This way you can start loading them earlier. HTML5 has the 
 defer
  
 attribute for this purpose:
  
  <script defer src=""behaviors.js""></script>
  
 Unfortunately, the 
 defer
  attribute is not supported by older browsers, but luckily, there 
 is a solution that works across browsers, old and new. The solution is to create a script 
 node dynamically and append it to the DOM. In other words you use a bit of inline 
 JavaScript to load the external JavaScript file. You can have this script loader snippet at 
 the top of your document so that the download has an early start:
  
 ...
  
 <head>
  
 (function () {
  
  var s = document.createElement('script');
  
  s.src = 'behaviors.js';
  
  document.getElementsByTagName('head')[0].appendChild(s);
  
 }());
  
 </head>
  
 ...",NA
Namespaces,"Global variables should be avoided in order to reduce the possibility of variable naming 
 collisions. You can minimize the number of globals by namespacing your variables and 
 functions. The idea is simple, you create only one global object and all your other 
 variables and functions become properties of that object.",NA
An Object as a namespace,"Let's create a global object called 
 MYAPP
 :
  
 // global namespace
  
 var MYAPP = MYAPP || {};
  
 [
  275 
 ]",NA
Namespaced constructors ,"Using a namespace doesn't prevent you from creating constructor functions. Here is 
 how you can have a DOM utility that has an 
 Element
  constructor, which allows you to 
 create DOM elements easier:
  
 MYAPP.dom = {}; 
  
 MYAPP.dom.Element = function (type, properties) {
  
  
 var tmp = document.createElement(type);
  
  
  for (var i in properties) {
  
  
  if (properties.hasOwnProperty(i)) {
  
    
  tmp.setAttribute(i, properties[i]);
  
  
  }
  
  
  }
  
  
  return tmp; 
  
 };
  
 Similarly, you can have a 
 Text
  constructor to create text nodes:
  
 MYAPP.dom.Text = function (txt) {
  
  
  return 
 document.createTextNode(txt); 
  
 };
  
 [
  276 
 ]",NA
A namespace() method ,"You can create a namespace utility that makes your life easier so that you can use 
 more convenient syntax:
  
 MYAPP.namespace('dom.style');
  
 Instead of the more verbose syntax as follows:
  
 MYAPP.dom = {}; 
  
 MYAPP.dom.style = {};
  
 Here's how you can create such a 
 namespace()
  method. First, you create an array by 
 splitting the input string using the period (.) as a separator. Then, for every element in 
 the new array, you add a property to your global object, if one doesn't already exist as 
 follows:
  
 var MYAPP = {}; 
  
 MYAPP.namespace = function (name) {
  
  
  var parts = name.split('.');
  
  
  var current = MYAPP;
  
  
  for (var i = 0; i < parts.length; i++) {
  
  
  if (!current[parts[i]]) {
  
    
  current[parts[i]] = {};
  
  
  }
  
  
  current = current[parts[i]];
  
  
  } 
  
 };
  
 Testing the new method is done as follows:
  
 MYAPP.namespace('event'); 
  
 MYAPP.namespace('dom.style');
  
 [
  277 
 ]",NA
Init-time branching ,"In the previous chapter you noticed that sometimes different browsers have different 
 implementations for the same or similar functionalities. In such cases, you need to branch 
 your code depending on what's supported by the browser currently executing your script. 
 Depending on your program this branching can happen far too often and, as a result, may 
 slow down the script execution.
  
 You can mitigate this problem by branching some parts of the code during 
 initialization, when the script loads, rather than during runtime. Building upon the 
 ability to define functions dynamically, you can branch and define the same 
 function with a different body depending on the browser. Let's see how.
  
 First, let's define a namespace and placeholder method for the 
 event
  utility:
  
 var MYAPP = {}; 
  
 MYAPP.event = {
  
  
  addListener: null,
  
  
  removeListener: 
 null 
  
 };
  
 At this point, the methods to add or remove a listener are not implemented. Based on the 
 results from feature sniffing, these methods can be defined differently as follows:
  
 if (window.addEventListener) {
  
  
  MYAPP.event.addListener = function (el, type, fn) {
  
  
 el.addEventListener(type, fn, false);
  
  
  };
  
  
  MYAPP.event.removeListener = function (el, type, fn) {
  
  
 el.removeEventListener(type, fn, false);
  
  
  }; 
  
 } else if (document.attachEvent) { // IE
  
  
  MYAPP.event.addListener = function (el, type, fn) {
  
  
 el.attachEvent('on' + type, fn);
  
  
  };
  
  
  MYAPP.event.removeListener = function (el, type, fn) {
  
 [
  278 
 ]",NA
Lazy definition,"The lazy definition pattern is similar to the previous init-time branching pattern. The 
 difference is that the branching happens only when the function is called for the first 
 time. When the function is called, it redefines itself with the best implementation. 
  
 Unlike the init-time branching where the if happens once, during loading, here it may 
 not happen at all in cases when the function is never called. The lazy definition also 
 makes the initialization process lighter as there's no init-time branching work to be 
 done.
  
 [
  279 
 ]",NA
Configuration object ,"This pattern is convenient when you have a function or method that accepts a lot of 
 optional parameters. It's up to you to decide how many constitutes a lot. But 
 generally, a function with more than three parameters is not convenient to call 
 because you have to remember the order of the parameters, and it is even more 
 inconvenient when some of the parameters are optional.
  
 Instead of having many parameters, you can use one parameter and make it an 
 object. The properties of the object are the actual parameters. This is suitable for 
 passing configuration options because these tend to be numerous and optional 
 (with smart defaults). The beauty of using a single object as opposed to multiple 
 parameters is described as follows:
  
 • 
  
 The order doesn't matter
  
 • 
  
 You can easily skip parameters that you don't want to set
  
 [
  280 
 ]",NA
Private properties and methods,"JavaScript doesn't have the notion of access modifiers, which set the privileges of the 
 properties in an object. Other languages often have access modifiers such as:
  
 • 
  
 • 
  
 • 
  
 Public—all users of an object can access these properties (or methods) 
 Private—only the object itself can access these properties 
  
 Protected—only objects inheriting the object in question can access 
 these properties
  
 JavaScript doesn't have a special syntax to denote private properties or methods, but as 
 discussed in 
 Chapter 3
 , 
 Functions
 , you can use local variables and methods inside a 
 function and achieve the same level of protection.
  
 [
  282 
 ]",NA
Privileged methods ,"Privileged methods (this term was coined by Douglas Crockford) are normal public 
 methods that can access private methods or properties. They can act like a bridge in 
 making some of the private functionality accessible but in a controlled manner, wrapped 
 in a privileged method.
  
 [
  283 
 ]",NA
Private functions as public methods ,"Let us say you've defined a function that you absolutely need to keep intact, so you make 
 it private. But, you also want to provide access to the same function so that outside code 
 can also benefit from it. In this case, you can assign the private function to a publicly 
 available property.
  
 Let's define 
 _setStyle()
  and 
 _getStyle()
  as private functions, but then assign 
 them to the public 
 setStyle()
  and 
 getStyle()
 :
  
 var MYAPP = {}; 
  
 MYAPP.dom = (function () {
  
  
  var _setStyle = function (el, prop, value) 
 {
  
  console.log('setStyle');
  
  
  };
  
  
  var _getStyle = function (el, prop) {
  
  
  console.log('getStyle');
  
  
  };
  
  
  return {
  
  
  setStyle: _setStyle,
  
  
  getStyle: _getStyle,
  
  
  yetAnother: _setStyle
  
  
  }; 
  
 }());
  
 Now, when you call 
 MYAPP.dom.setStyle()
 , it invokes the private 
 _setStyle() 
 function. You can also overwrite 
 setStyle()
  from the outside:
  
 MYAPP.dom.setStyle = function () {alert('b');};
  
 Now, the result is as follows:
  
 • 
  
 • 
  
 • 
  
 MYAPP.dom.setStyle
  points to the new function 
  
 MYAPP.dom.yetAnother
  still points to 
 _setStyle() 
  
 _setStyle()
  is always available when any other internal code relies on it to be 
 working as intended, regardless of the outside code
  
 When you expose something private, keep in mind that objects (and functions and 
 arrays are objects too) are passed by reference and, therefore, can be modified from 
 the outside.
  
 [
  284 
 ]",NA
Immediate functions ,"Another pattern that helps you keep the global namespace clean is to wrap your code in 
 an anonymous function and execute that function immediately. This way any variables 
 inside the function are local (as long as you use the 
 var
  statement) and are destroyed 
 when the function returns, if they aren't part of a closure. This pattern was discussed in 
 more detail in 
 Chapter 3
 , 
 Functions
 . Have a look at the following code:
  
 (function () {
  
  
  // code goes 
 here...
  
 }());
  
 This pattern is especially suitable for on-off initialization tasks performed when the 
 script loads.
  
 The immediate (self-executing) function pattern can be extended to create and return 
 objects. If the creation of these objects is more complicated and involves some 
 initialization work, then you can do this in the first part of the self-executable function 
 and return a single object, which can access and benefit from any private properties in 
 the top portion as follows:
  
 var MYAPP = {}; 
  
 MYAPP.dom = (function () {
  
  
  // initialization code...
  
  function _private() {
  
  // ... 
  
  
  }
  
  
  return {
  
  
  getStyle: function (el, prop) {
  
    
  console.log('getStyle');
  
    
  _private();
  
  
  },
  
  
  setStyle: function (el, prop, value) {
  
    
  console.log('setStyle');
  
  
  }
  
  
  }; 
  
 }());
  
 [
  285 
 ]",NA
Modules ,"Combining several of the previous patterns, gives you a new pattern, commonly 
 referred to as a module pattern. The concept of modules in programming is 
 convenient as it allows you to code separate pieces or libraries and combine them as 
 needed just like pieces of a puzzle.
  
  
 Two notable facts beyond the scope of this chapter
  
  
 JavaScript doesn't have a built-in concept of modules, although this 
  
 is planned for the future via 
 export
  and 
 import
  declarations. There 
  
 is also the module specification from 
 http://www.commonjs.org
 , 
  
 which defines a 
 require()
  function and an 
 exports
  object.
  
 The module pattern includes:
  
 • 
  
 Namespaces to reduce naming conflicts among modules
  
 • 
  
 An immediate function to provide a private scope and initialization
  
 • 
  
 Private properties and methods
  
 • 
  
 Returning an object that has the public API of the module as follows:
  
 namespace('MYAPP.module.amazing');
  
 MYAPP.module.amazing = (function () {
  
  // short names for dependencies
  
  var another = MYAPP.module.another;
  
  // local/private 
 variables
  
  var i, j;
  
  // private functions
  
  function hidden() {}
  
  
  // public API
  
  
  return {
  
  
  hi: function () {
  
    
  return ""hello"";
  
  
  }
  
  
  }; 
  
 }());
  
 And using the following module:
  
 MYAPP.module.amazing.hi(); // ""hello""
  
 [
  286 
 ]",NA
Chaining ,"Chaining is a pattern that allows you to invoke multiple methods on one line as if the 
 methods are the links in a chain. This is convenient when calling several related 
 methods. You invoke the next method on the result of the previous without the use of an 
 intermediate variable.
  
 Say you've created a constructor that helps you work with DOM elements. The code 
 to create a new 
 <span>
  and add it to the 
 <body>
  could look something like the 
 following:
  
 var obj = new MYAPP.dom.Element('span'); 
  
 obj.setText('hello'); 
  
 obj.setStyle('color', 'red'); 
  
 obj.setStyle('font', 'Verdana'); 
  
 document.body.appendChild(obj);
  
 As you know, constructors return the object referred to as 
 this
  that they create. You can 
 make your methods such as 
 setText()
  and 
 setStyle()
  also return 
 this
 , which allows 
 you to call the next method on the instance returned by the previous one. This way you 
 can chain method calls:
  
 var obj = new MYAPP.dom.Element('span'); 
  
 obj.setText('hello')
  
  
  .setStyle('color', 'red')
  
  
  .setStyle('font', 'Verdana'); 
  
 document.body.appendChild(obj);
  
 You don't even need the 
 obj
  variable if you don't plan on using it after the new 
 element has been added to the tree, so the code looks like the following:
  
 document.body.appendChild(
  
  
  new MYAPP.dom.Element('span')
  
  
  .setText('hello')
  
  
  .setStyle('color', 'red')
  
  
  .setStyle('font', 'Verdana') 
  
 );
  
 A drawback of this pattern is that it makes it a little harder to debug when an error 
 occurs somewhere in a long chain and you don't know which link is to blame because 
 they are all on the same line.
  
 [
  287 
 ]",NA
JSON ,"Let's wrap up the coding patterns section of this chapter with a few words about JSON. 
 JSON is not technically a coding pattern, but you can say that using JSON is a good 
 pattern.
  
 JSON is a popular lightweight format for exchanging data. It's often preferred over XML 
 when using 
 XMLHttpRequest()
  to retrieve data from the server. 
 JSON
  stands for 
 JavaScript Object Notation
  and there's nothing specifically interesting about it other 
 than the fact that it's extremely convenient. The JSON format consists of data defined 
 using object, and array literals. Here is an example of a JSON string that your server could 
 respond with after an XHR request:
  
 {
  
  
  'name':   'Stoyan',
  
  
  'family': 'Stefanov',
  
  
  'books':  ['OOJS', 'JSPatterns', 'JS4PHP'] 
 }
  
 An XML equivalent of this would be something like the following:
  
 <?xml version=""1.1"" encoding=""iso-8859-1""?> 
  
 <response>
  
  
  <name>Stoyan</name>
  
  
  <family>Stefanov</family>
  
  
  <books>
  
  
  <book>OOJS</book>
  
  
  <book>JSPatterns</book>
  
  
  <book>JS4PHP</book>
  
  
  </books> 
  
 </response>
  
 First, you can see how JSON is lighter in terms of the number of bytes. But, the main 
 benefit is not the smaller byte size but the fact that it's trivial to work with JSON in 
 JavaScript. Let's say you've made an XHR request and have received a JSON string in the 
 responseText
  property of the XHR object. You can convert this string of data into a 
 working JavaScript object by simply using 
 eval()
 :
  
 // warning: counter-example 
  
 var response = eval('(' + xhr.responseText + 
 ')');
  
 [
  288 
 ]",NA
Design patterns,"The second part of this chapter presents a JavaScript approach to a subset of the design 
 patterns introduced by the book called 
 Design Patterns: Elements of Reusable Object-
 Oriented Software
 , an influential book most commonly referred to as the 
 Book of Four
  or 
 the 
 Gang of Four
 , or 
 GoF
  (after its four authors). The patterns discussed in the 
 GoF
  book 
 are divided into three groups:
  
 • 
  
 • 
  
 • 
  
 Creational patterns that deal with how objects are created (instantiated) 
 Structural patterns that describe how different objects can be composed in 
 order to provide new functionality 
  
 Behavioral patterns that describe ways for objects to communicate with each 
 other
  
 There are 23 patterns in the 
 Book of Four
  and more patterns have been identified since 
 the book's publication. It's way beyond the scope of this book to discuss all of them, so the 
 remainder of the chapter demonstrates only four, along with examples of their 
 implementation in JavaScript. Remember that the patterns are more about interfaces and 
 relationships rather than implementation. Once you have an understanding of a design 
 pattern, it's often not difficult to implement it, especially in a dynamic language such as 
 JavaScript.
  
 [
  289 
 ]",NA
Singleton,"Singleton is a creational design pattern meaning that its focus is on creating objects. It 
 helps when you want to make sure there is only one object of a given kind (or class). 
  
 In a classical language this would mean that an instance of a class is only created 
 once and any subsequent attempts to create new objects of the same class would 
 return the original instance.
  
 In JavaScript, because there are no classes, a singleton is the default and most natural 
 pattern. Every object is a singleton object.
  
 The most basic implementation of the singleton in JavaScript is the object literal:
  
 var single = {};
  
 That was easy, right?",NA
Singleton 2,"If you want to use class-like syntax and still implement the singleton pattern, things 
 become a bit more interesting. Let's say you have a constructor called 
 Logger()
  and 
 you want to be able to do something like the following:
  
 var my_log = new Logger();
  
 my_log.log('some event');
  
 // ... 1000 lines of code later in a different scope ...
  
 var other_log = new Logger();
  
 other_log.log('some new event');
  
 console.log(other_log === my_log); // true
  
 The idea is that although you use 
 new
 , only one instance needs to be created, and this 
 instance is then returned in consecutive calls.
  
 [
  290 
 ]",NA
Global variable,"One approach would be to use a global variable to store the single instance. Your 
 constructor could look like this:
  
 function Logger() {
  
  if (typeof global_log === ""undefined"") {
  
  global_log = this;
  
  }
  
  return global_log;
  
 }
  
 Using this constructor gives the expected result:
  
 var a = new Logger();
  
 var b = new Logger();
  
 console.log(a === b); // true
  
 The drawback is, obviously, the use of a global variable. It can be overwritten at any 
 time, even accidentally, and you lose the instance. The opposite, your global variable 
 overwriting someone else's is also possible.",NA
Property of the Constructor,"As you know, functions are objects and they have properties. You can assign the 
 single instance to a property of the constructor function as follows:
  
 function Logger() {
  
  if (Logger.single_instance) {
  
  Logger.single_instance = this;
  
  }
  
  return Logger.single_instance;
  
 }
  
 If you write 
 var a = new Logger()
 , 
 a
  points to the newly created 
 Logger.single_ 
 instance
  property. A subsequent call 
 var b = new Logger()
  results in 
 b
  pointing to 
 the same 
 Logger.single_instance
  property, which is exactly what you want.
  
 This approach certainly solves the global namespace issue because no global variables 
 are created. The only drawback is that the property of the 
 Logger 
  
 constructor is publicly visible, so it can be overwritten at any time. In such cases, the 
 single instance can be lost or modified. Of course, you can only provide so much 
 protection against fellow programmers shooting themselves in the foot. After all, if 
 someone can mess with the single instance property, they can mess up the 
 Logger 
 constructor directly, as well.
  
 [
  291 
 ]",NA
In a private property ,"The solution to the problem of overwriting the publicly visible property is not to use a 
 public property but a private one. You already know how to protect variables with a 
 closure, so as an exercise you can implement this approach to the singleton pattern.",NA
Factory ,"The factory is another creational design pattern as it deals with creating objects. The 
 factory can help when you have similar types of objects and you don't know in advance 
 which one you want to use. Based on user input or other criteria, your code determines 
 the type of object it needs on the fly.
  
 Let's say you have three different constructors, which implement similar functionality. 
 All the objects they create take a URL but do different things with it. One creates a text 
 DOM node, the second creates a link, and the third an image as follows:
  
 var MYAPP = {}; 
  
 MYAPP.dom = {}; 
  
 MYAPP.dom.Text = function (url) {
  
  
  this.url = url;
  
  
  this.insert = function (where) {
  
  
  var txt = document.createTextNode(this.url);
  
  
  where.appendChild(txt);
  
  
  }; 
  
 }; 
  
 MYAPP.dom.Link = function (url) {
  
  
  this.url = url;
  
  
  this.insert = function (where) {
  
  
  var link = document.createElement('a');
  
  
  link.href = this.url;
  
  
  link.appendChild(document.createTextNode(this.url));
  
  
 where.appendChild(link);
  
  
  }; 
  
 }; 
  
 MYAPP.dom.Image = function (url) {
  
  
  this.url = url;
  
  
  this.insert = function (where) {
  
  
  var im = document.createElement('img');
  
  
  im.src = this.url;
  
  
  where.appendChild(im);
  
  
  }; 
  
 };
  
 [
  292 
 ]",NA
Decorator,"The Decorator design pattern is a structural pattern; it doesn't have much to do with 
 how objects are created but rather how their functionality is extended. Instead of using 
 inheritance where you extend in a linear way (parent-child-grandchild), you can have 
 one base object and a pool of different decorator objects that provide extra functionality. 
 Your program can pick and choose which decorators it wants and in which order. For a 
 different program or code path, you might have a different set of requirements and pick 
 different decorators out of the same pool. Take a look at how the usage part of the 
 decorator pattern could be implemented:
  
 var obj = {
  
  doSomething: function () {
  
  console.log('sure, asap');
  
  }
  
  //  ...
  
 };
  
 obj = obj.getDecorator('deco1');
  
 obj = obj.getDecorator('deco13');
  
 obj = obj.getDecorator('deco5');
  
 obj.doSomething();
  
 You can see how you can start with a simple object that has a 
 doSomething() 
 method. 
 Then you can pick one of the decorator objects you have lying around and can be 
 identified by name. All decorators provide a 
 doSomething()
  method which first calls the 
 same method of the previous decorator and then proceeds with its own code. Every time 
 you add a decorator, you overwrite the base 
 obj
  with an improved version of it. At the 
 end, when you are finished adding decorators, you call 
 doSomething()
 . As a result all of 
 the 
 doSomething()
  methods of all the decorators are executed in sequence. Let's see an 
 example.
  
 [
  294 
 ]",NA
Decorating a Christmas tree ,"Let's illustrate the decorator pattern with an example of decorating a Christmas tree. 
  
 You start with the 
 decorate()
  method as follows:
  
 var tree = {}; 
  
 tree.decorate = function () {
  
  
  alert('Make sure the tree won\'t fall'); 
  
 };
  
 Now, let's implement a 
 getDecorator()
  method which adds extra decorators. The 
 decorators will be implemented as constructor functions, and they'll all inherit from the 
 base 
 tree
  object:
  
 tree.getDecorator = function (deco) {
  
  
  tree[deco].prototype = this;
  
  
  return new tree[deco]; 
  
 };
  
 Now, let's create the first decorator, 
 RedBalls()
 , as a property of 
 tree
  (in order to 
 keep the global namespace cleaner). The red ball objects also provide a 
 decorate() 
 method, but they make sure they call their parent's 
 decorate()
  first:
  
 tree.RedBalls = function () {
  
  
  this.decorate = function () {
  
  
  this.RedBalls.prototype.decorate();
  
  
  alert('Put on some red balls');
  
  
  }; 
  
 };
  
 Similarly, implementing 
 BlueBalls()
  and 
 Angel()
  decorators:
  
 tree.BlueBalls = function () {
  
  
  this.decorate = function () {
  
  
  this.BlueBalls.prototype.decorate();
  
  
  alert('Add blue balls');
  
  
  }; 
  
 }; 
  
 tree.Angel = function () {
  
  
  this.decorate = function () {
  
  
  this.Angel.prototype.decorate();
  
  
  alert('An angel on the top');
  
  
  }; 
  
 };
  
 [
  295 
 ]",NA
Observer,"The observer pattern (also known as the subscriber-publisher pattern) is a 
  
 behavioral pattern, which means that it deals with how different objects interact and 
 communicate with each other. When implementing the observer pattern you have the 
 following objects:
  
 • 
  
 • 
  
 One or more publisher objects that announce when they do 
 something important.
  
 One or more subscribers tuned in to one or more publishers. They listen to 
 what the publishers announce and then act appropriately.
  
 The observer pattern may look familiar to you. It sounds similar to the browser events 
 discussed in the previous chapter, and rightly so, because the browser events are one 
 example application of this pattern. The browser is the publisher, it announces the fact 
 that an event (such as a click) has happened. Your event listener functions that are 
 subscribed to (listen to) this type of event will be notified when the event happens. The 
 browser-publisher sends an event object to all of the subscribers. In your custom 
 implementations you can send any type of data you find appropriate.
  
 There are two subtypes of the observer pattern, push and pull. Push is where the 
 publishers are responsible for notifying each subscriber, and pull is where the 
 subscribers monitor for changes in a publisher's state.
  
 [
  296 
 ]",NA
Summary,"In this chapter, you learned about common JavaScript coding patterns and learned how 
 to make your programs cleaner, faster, and better at working with other programs and 
 libraries. Then you saw a discussion and sample implementations of a handful of the 
 design patterns from the 
 Book of Four
 . You can see how JavaScript is a fully featured 
 dynamic programming language and that implementing classical patterns in a dynamic 
 loosely typed language is pretty easy. The patterns are, in general, a large topic and you 
 can join the author of this book in a further discussion of the JavaScript patterns at the 
 website 
 JSPatterns.com
  or take a look at the book appropriately named ""JavaScript 
 Patterns"".
  
 [
  299 
 ]",NA
Reserved Words,"This appendix provides two lists of reserved keywords as defined in ECMAScript 5 
 (ES5). The first one is the current list of words, and the second is the list of words 
 reserved for future implementations.
  
 There's also a list of words that are no longer reserved, although they used to be 
 in ES3.
  
 You cannot use reserved words as variable names: 
  
  
 var break = 1; // syntax error 
  
 If you use these words as object properties, you have to quote them: 
  
 var o = {break: 1};   // OK in many browsers, error in IE 
  
 var o = {""break"": 1}; // Always OK 
  
  
 alert(o.break);       // error in IE 
  
  
 alert(o[""break""]);    // OK",NA
Keywords ,"The list of words currently reserved in ES5 is as follows: 
 break 
  
 case 
  
 catch 
  
 continue 
  
 debugger 
  
 default 
  
 delete",NA
Future reserved words ,"These keywords are not currently used, but are reserved for future versions of 
 the language.
  
 • 
  
 class
  
 • 
  
 const 
  
  
 enum
 • 
  
 • 
  
 export
  
 • 
  
 extends
  
 • 
  
 implements
  
 [
  302 
 ]",NA
Previously reserved words,"These words are no longer reserved starting with ES5, but best to stay away for the 
  
 sake of older browsers.
  
 • 
  
 abstract
  
 • 
  
 boolean
  
 • 
  
 byte
  
 • 
  
 char
  
 • 
  
 double
  
 • 
  
 final
  
 • 
  
 float
  
 • 
  
 goto
  
 • 
  
 int
  
 • 
  
 long
  
 • 
  
 native
  
 • 
  
 short
  
 • 
  
 synchronized
  
 • 
  
 throws
  
 • 
  
 transient
  
 • 
  
 volatile
  
 [
  303 
 ]",NA
Built-in Functions,"This appendix contains a list of the built-in functions (methods of the global object), 
 discussed in 
 Chapter 3
 , 
 Functions
 .
  
 Function
  
 Description
  
 parseInt()
  
 Takes two parameters: an input object and radix; then tries to 
 return an integer representation of the input. Doesn't handle 
 exponents in the input. The default radix is 
 10
  (a decimal number). 
 Returns 
 NaN
  on failure. Omitting the radix may lead to unexpected 
 results (for example for inputs such as 
 08
 ), so it's best to always 
 specify it.
  
 > parseInt('10e+3'); 
  
 10
  
 > parseInt('FF'); 
  
 NaN
  
 > parseInt('FF', 16); 
  
 255
  
 parseFloat()
  
 Takes a parameter and tries to return a floating-point 
 number representation of it. Understands exponents in 
 the input.
  
 > parseFloat('10e+3'); 
  
 10000
  
 > parseFloat('123.456test'); 
  
 123.456",NA
Built-in Objects,"This Appendix lists the built-in constructor functions outlined in the 
 ECMAScript 
 (
 ES
 ) standard, together with the properties and methods of the objects created by 
 these constructors. ES5-specific APIs are listed separately.",NA
Object,"Object()
  is a constructor that creates objects, for example:
  
 > var o = new Object();
  
 This is the same as using the object literal:
  
 > var o = {}; // recommended
  
 You can pass anything to the constructor and it will try to guess what it is and use a more 
 appropriate constructor. For example, passing a string to 
 new Object()
  will be the same 
 as using the 
 new String()
  constructor. This is not a recommended practice (it's better 
 to be explicit than let guesses creep in), but still possible.
  
 > var o = new Object('something');
  
 > o.constructor;
  
 function String() { [native code] }
  
 > var o = new Object(123);
  
 > o.constructor;
  
 function Number() { [native code] }
  
 All other objects, built-in or custom, inherit from 
 Object
 . So, the properties and 
 methods listed in the following sections apply to all types of objects.",NA
Members of the Object constructor ,"Have a look at the following table:
  
 Property/method
  
 Description
  
 Object.prototype
  
 The prototype of all objects (also an object itself). Anything 
 you add to this prototype will be inherited by all other objects, 
 so be careful.
  
 > var s = new String('noodles'); 
  
 > Object.prototype.custom = 1; 
  
 1
  
 > s.custom; 
  
 1",NA
The Object.prototype members ,"Have a look at the following table:
  
 Property/method
  
 Description
  
 constructor
  
 Points back to the constructor function used to create 
 the object, in this case, 
 Object
 .
  
 > Object.prototype.constructor === 
  
 Object; 
  
 true
  
 > var o = new Object(); 
  
 > o.constructor === Object; 
  
 true
  
 toString(radix)
  
 Returns a string representation of the object. If the 
 object happens to be a 
 Number
  object, the radix 
 parameter defines the base of the returned number. 
 The default radix is 
 10
 .
  
 > var o = {prop: 1};
  
 > o.toString();
  
 ""[object Object]""
  
 > var n = new Number(255);
  
 > n.toString();
  
 ""255""
  
 > n.toString(16);
  
 ""ff""
  
 [
  310 
 ]",NA
ECMAScript 5 additions to Object,"In ECMAScript 3 all object properties can be changed, added, or deleted at any time, 
 except for a few built-in properties (for example, 
 Math.PI
 ). In ES5 you have the ability to 
 define properties that cannot be changed or deleted—a privilege previously reserved for 
 built-ins. ES5 introduces the concept of 
 property descriptors
  that give you tighter 
 control over the properties you define.
  
 [
  312 
 ]",NA
Array ,"The 
 Array
  constructor creates array objects:
  
 > var a = new Array(1, 2, 3);
  
 This is the same as the array literal:
  
 > var a = [1, 2, 3]; //recommended
  
 When you pass only one numeric value to the 
 Array
  constructor, it's assumed to be the 
 array length.
  
 > var un = new Array(3); 
  
 > un.length; 
  
 3
  
 You get an array with the desired length and if you ask for the value of each of the 
 array elements, you get 
 undefined
 .
  
 > un; 
  
 [undefined, undefined, undefined]
  
 There is a subtle difference between an array full of elements and an array with no 
 elements, but just length:
  
 > '0' in a; 
  
 true
  
 > '0' in un; 
  
 false
  
 This difference in the 
 Array()
  constructor's behavior when you specify one versus 
 more parameters can lead to unexpected behavior. For example, the following use of the 
 array literal is valid:
  
 > var a = [3.14]; 
  
 > a; 
  
 [3.14]
  
 However, passing the floating-point number to the 
 Array
  constructor is an error:
  
 > var a = new 
 Array(3.14); 
  
 Range Error: invalid array length
  
 [
  318 
 ]",NA
The Array.prototype members,"Property/method
  
 Description
  
 length
  
 The number of elements in the array.
  
 > [1, 2, 3, 4].length; 
  
 4
  
 concat(i1, i2, 
 i3,...)
  
 Merges arrays together.
  
 > [1, 2].concat([3, 5], [7, 11]);
  
 [1, 2, 3, 5, 7, 11]
  
 join(separator)
  
 Turns an array into a string. The separator parameter is a string 
 with comma as the default value.
  
 > [1, 2, 3].join(); 
  
 ""1,2,3""
  
 > [1, 2, 3].join('|'); 
  
 ""1|2|3""
  
 > [1, 2, 3].join(' is less than '); 
  
 ""1 is less than 2 is less than 3""
  
 pop() 
  
 Removes the last element of the array and returns it.
  
 > var a = ['une', 'deux', 'trois']; 
  
 > a.pop(); 
  
 ""trois""
  
 > a; 
  
 [""une"", ""deux""]
  
 push(i1, i2, 
 i3,...)
  
 Appends elements to the end of the array and returns the length of the 
 modified array.
  
 > var a = []; 
  
 > a.push('zig', 'zag', 'zebra','zoo'); 
  
 4
  
 reverse() 
  
 Reverses the elements of the array and returns the modified array.
  
 > var a = [1, 2, 3]; 
  
 > a.reverse(); 
  
 [3, 2, 1] 
  
 > a; 
  
 [3, 2, 1]
  
 [
  319 
 ]",NA
ECMAScript 5 additions to Array,"Property/method
  
 Description
  
  
 Array.isArray(obj)
  
 Array.prototype.
  
 indexOf(needle, idx)
  
 Tells if an object is an array because 
 typeof
  is not good 
 enough:
  
 > var arraylike = {0: 101, length: 1}; 
 > typeof arraylike; 
  
 ""object""
  
 > typeof []; 
  
 ""object""
  
 Neither is duck-typing (if it walks like a duck and quacks 
 like a duck, it must be a duck):
  
 typeof arraylike.length; 
  
 ""number""
  
 In ES3 you need the verbose:
  
 > Object.prototype.toString.call([]) === 
 ""[object Array]""; 
  
 true
  
 > Object.prototype.toString.call
  
  
  (arraylike) === ""[object Array]""; 
 false
  
 In ES5 you get the shorter:
  
 Array.isArray([]); 
  
 true
  
 Array.isArray(arraylike); 
  
 false
  
 Searches the array and returns the index of the first match. 
 Returns 
 -1
  if there's no match. Optionally can search starting 
 from a specified index.
  
 > var ar = ['one', 'two', 'one', 'two']; 
 > ar.indexOf('two'); 
  
 1
  
 > ar.indexOf('two', 2); 
  
 3
  
 > ar.indexOf('toot');
  
 -1
  
 [
  322 
 ]",NA
Function ,"JavaScript functions are objects. They can be defined using the 
 Function
  constructor, like 
 so:
  
 var sum = new Function('a', 'b', 'return a + b;');
  
 [
  325 
 ]",NA
The Function.prototype members,"Property/Method
  
 Description
  
 apply(this_ 
 obj, params_ 
 array)
  
 Allows you to call another function while overwriting the other 
 function's this value. The first parameter that 
 apply()
  accepts is the 
 object to be bound to this inside the function and the second is an array 
 of arguments to be send to the function being called.
  
 function whatIsIt(){
  
  
  return this.toString(); 
  
 } 
  
 > var myObj = {}; 
  
 > whatIsIt.apply(myObj); 
  
 ""[object Object]""
  
 > whatIsIt.apply(window); 
  
 ""[object Window]""
  
 call(this_obj, 
 p1, p2, p3, 
  
 ...)
  
 length
  
 The same as 
 apply()
  but accepts arguments one by one, as opposed to 
 as one array.
  
 The number of parameters the function expects.
  
  
 > parseInt.length; 
  
  
 2 
  
 If you forget the difference between call() and apply():
  
 > Function.prototype.call.length; 
  
 1
  
  
 > Function.prototype.apply.length; 
  
  
 2 
  
 The call() property's length is 1 because all arguments except the first 
 one are optional.
  
 [
  326 
 ]",NA
ECMAScript 5 additions to a function,"Property/method
  
 Description
  
 Function.
  
 prototype.
  
 bind()
  
 When you want to call a function that uses this internally and you 
 want to define what this is. The methods 
 call()
  and 
 apply() 
 invoke the function while 
 bind()
  returns a new function. Useful 
 when you provide a method as a callback to a method of another 
 object and and you want this to be an object of your choice.
  
 > whatIsIt.apply(window); 
  
 ""[object Window]""",NA
Boolean ,"The 
 Boolean
  constructor creates Boolean objects (not to be confused with Boolean 
 primitives). The Boolean objects are not that useful and are listed here for the sake of 
 completeness.
  
 > var b = new Boolean(); 
  
 > b.valueOf(); 
  
 false
  
 > b.toString(); 
  
 ""false""
  
 A Boolean object is not the same as a Boolean primitive value. As you know, all 
 objects are truthy:
  
 > b === false; 
  
 false
  
 > typeof b; 
  
 ""object""
  
 Boolean objects don't have any properties other than the ones inherited from 
 Object
 .",NA
Number ,"This creates number objects:
  
 > var n = new 
 Number(101); 
  
 > typeof n; 
  
 ""object""
  
 > n.valueOf(); 
  
 101
  
 [
  327 
 ]",NA
Members of the Number constructor,"Property/method
  
 Description
  
  
 Number.MAX_VALUE
  
 Number.MIN_VALUE
  
 A constant property (cannot be changed) that contains 
 the maximum allowed number.
  
 > Number.MAX_VALUE; 
  
 1.7976931348623157e+
 308
  
 The smallest number you can work with in JavaScript. 
 > 
 Number.MIN_VALUE; 
  
 5e-324
  
 Number.NaN
  
 Contains the Not A Number number. The same as the 
 global NaN.
  
  
 > Number.NaN; 
  
  
 NaN 
  
 NaN is not equal to anything including itself.
  
 > Number.NaN === Number.NaN; 
  
 false
  
 Number.POSITIVE_INFINITY 
 Number.NEGATIVE_INFINITY
  
 The same as the global 
 Infinity
  number. 
 The same as 
 -Infinity
 .
  
 [
  328 
 ]",NA
The Number.prototype members,"Property/method
  
 Description
  
  
 toFixed(fractionDigits)
  
 toExponential 
  
 (fractionDigits)
  
 toPrecision(precision)
  
 Returns a string with the fixed-point representation of 
 the number. Rounds the returned value.
  
 > var n = new Number(Math.PI); 
 > n.valueOf(); 
  
 3.141592653589793
  
 > n.toFixed(3); 
  
 ""3.142""
  
 Returns a string with exponential notation representation of 
 the number object. Rounds the returned value.
  
 > var n = new Number(56789); 
 > n.toExponential(2); 
  
 ""5.68e+4""
  
 String representation of a number object, either 
  
 exponential or fixed-point, depending on the number 
 object.
  
 > var n = new Number(56789); 
 > n.toPrecision(2); 
  
 ""5.7e+4""
  
 > n.toPrecision(5); 
  
 ""56789""
  
 > n.toPrecision(4); 
  
 ""5.679e+4""
  
 > var n = new Number(Math.PI); 
 > n.toPrecision(4); 
  
 ""3.142""",NA
String,"The 
 String()
  constructor creates string objects. Primitive strings are turned into 
 objects behind the scenes if you call a method on them as if they were objects. 
 Omitting 
 new
  gives you primitive strings.
  
 Creating a string object and a string primitive:
  
 > var s_obj = new String('potatoes'); 
  
 > var s_prim = 'potatoes';
  
 > typeof s_obj;
  
 ""object""
  
 [
  329 
 ]",NA
Members of the String constructor,"Property/method
  
 Description
  
  
 String.fromCharCode 
 (code1, code2, 
  
 code3, ...)
  
 Returns a string created using the Unicode values of the 
 input:
  
 > String.fromCharCode(115, 99, 114, 
  
  105, 112, 116);
  
 ""script""
  
 [
  330 
 ]",NA
The String.prototype members,"Property/method
  
 Description
  
 length
  
 The number of characters in the string.
  
 > new String('four').length; 
  
 4
  
 charAt(position)
  
 Returns the character at the specified position. 
 Positions start at 0.
  
  
 > ""script"".charAt(0); 
  
  
 ""s"" 
  
 Since ES5, it's also possible to use array notation for the same 
 purpose. (This feature has been long supported in many 
 browsers before ES5, but not IE)
  
 > ""script""[0]; 
  
 ""s""
  
 charCodeAt(position)
  
 concat(str1, str2, 
  
 ....)
  
 Returns the numeric code (Unicode) of the character at the 
 specified position.
  
 > ""script"".charCodeAt(0); 
  
 115
  
 Return a new string glued from the input pieces.
  
 > """".concat('zig', '-', 'zag'); 
 ""zig-zag""
  
 indexOf(needle, 
 start)
  
 If the needle matches a part of the string, the position of the 
 match is returned. The optional second parameter defines 
 where the search should start from. Returns 
 -1
  if no match is 
 found.
  
 > ""javascript"".indexOf('scr'); 
  
 4
  
 > ""javascript"".indexOf('scr', 5);
  
 -1
  
 lastIndexOf(needle, 
 start)
  
 Same as 
 indexOf()
  but starts the search from the end of 
 the string. The last occurrence of 
 a
 :
  
 > ""javascript"".lastIndexOf('a');
  
 3
  
 [
  331 
 ]",NA
ECMAScript 5 additions to String,"Property/method
  
 Description
  
 String.prototype. 
 trim()
  
 Instead of using a regular expression to remove whitespace 
 before and after a string (as in ES3), you have a 
 trim() 
 method in ES5.
  
 > "" \t beard \n"".trim(); 
  
 ""beard""
  
 Or in ES3: 
  
 > "" \t beard \n"".replace(/\s/g, """"); 
  
 ""beard""",NA
Date ,"The 
 Date
  constructor can be used with several types of input:
  
 You can pass values for year, month, date of the month, hour, minute, second, and 
 millisecond, like so:
  
 > new Date(2015, 0, 1, 13, 30, 35, 505); 
  
 Thu Jan 01 2015 13:30:35 GMT-0800 (PST)
  
 • 
  
 You can skip any of the input parameters, in which case they are assumed to be 
 0. Note that month values are from 0 (January) to 11 (December), hours are 
 from 0 to 23, minutes and seconds 0 to 59, and milliseconds 0 to 999.
  
 [
  333 
 ]",NA
Members of the Date constructor,"Property/method
  
 Description
  
  
 Date.parse(string)
  
 Date.UTC(year, month, date, 
  
 hours, minutes, seconds, ms)
  
 Similar to passing a string to new 
 Date() 
  
 constructor, this method parses the input string in 
 an attempt to extract a valid date value. Returns a 
 timestamp on success, 
 NaN
  on failure:
  
 > Date.parse('May 5, 2015');
  
 1430809200000
  
 > Date.parse('4th');
  
 NaN
  
 Returns a timestamp but in UTC (Coordinated 
 Universal Time), not in local time.
  
 > Date.UTC 
  
  (2015, 0, 1, 13, 30, 35, 505);
  
 1420119035505
  
 [
  334 
 ]",NA
The Date.prototype members,"Property/method
  
 Description/example
  
  
 toUTCString()
  
 toDateString()
  
 toTimeString()
  
 toLocaleString() 
  
 toLocaleDateString() 
 toLocaleTimeString()
  
 getTime() 
  
 setTime(time)
  
 Same as 
 toString()
  but in universal time. Here's 
 how Pacific Standard (PST) local time differs from 
 UTC:
  
 > var d = new Date(2015, 0, 1); > 
 d.toString(); 
  
 ""Thu Jan 01 2015 00:00:00 GMT-0800 
 (PST)""
  
 > d.toUTCString(); 
  
 ""Thu, 01 Jan 2015 08:00:00 
 GMT""
  
 Returns only the date portion of 
 toString()
 :
  
 > new Date(2015, 0, 1).toDateString(); 
 ""Thu Jan 01 2010""
  
 Returns only the time portion of 
 toString()
 :
  
 > new Date(2015, 0, 1).toTimeString(); 
 ""00:00:00 GMT-0800 (PST)""
  
 Equivalent to 
 toString()
 , 
 toDateString()
 , and 
 toTimeString()
  respectively, but in a friendlier 
 format, according to the current user's locale.
  
 > new Date(2015, 0, 1).toString(); 
 ""Thu Jan 01 2015 00:00:00 GMT-0800 (PST)""
  
 > new Date(2015, 0, 1).toLocaleString(); 
 ""1/1/2015 12:00:00 AM""
  
 Get or set the time (using a timestamp) of a date 
 object. The following example creates a date and 
 moves it one day forward:
  
 > var d = new Date(2015, 0, 1); 
  
 > d.getTime(); 
  
 1420099200000 
  
 > d.setTime(d.getTime() 
  
  
  + 1000 * 60 * 60 * 24); 
  
 1420185600000 
  
 > d.toLocaleString(); 
  
 ""Fri Jan 02 2015 00:00:00 GMT-0800 
 (PST)""
  
 [
  335 
 ]",NA
ECMAScript 5 additions to Date,"Property/method
  
 Description
  
 Date.now()
  
 A convenient way to get the current timestamp:
  
 > Date.now() === new Date().getTime(); 
  
 true
  
 Date.prototype. 
 toISOString()
  
 Yet another toString().
  
 > var d = new Date(2015, 0, 1);
  
 > d.toString(); 
  
 ""Thu Jan 01 2015 00:00:00 GMT-0800 
 (PST)""
  
 > d.toUTCString(); 
  
 ""Thu, 01 Jan 2015 08:00:00 
 GMT""
  
 > d.toISOString(); 
  
 ""2015-01-
 01T00:00:00.000Z""
  
 Date.prototype. 
 toJSON()
  
 Used by JSON.stringify() (refer to the end of this appendix) 
 and returns the same as toISOString().
  
 > var d = new Date(); 
  
 > d.toJSON() === d.toISOString(); 
  
 true
  
 [
  338 
 ]",NA
Math ,"Math
  is different from the other built-in objects because it cannot be used as a 
 constructor to create objects. It's just a collection of static functions and constants. 
  
 Some examples to illustrate the differences are as follows:
  
 > typeof Date.prototype; 
  
 ""object""
  
 > typeof Math.prototype; 
  
 ""undefined""
  
 > typeof String; 
  
 ""function""
  
 > typeof Math; 
  
 ""object""",NA
Members of the Math object,"Property/method
  
 Description
  
 Math.E 
  
 Math.LN10 
  
 Math.LN2 
  
 Math.LOG2E 
  
 Math.LOG10E 
 Math.PI 
  
 Math.SQRT1_2 
 Math.SQRT2
  
 These are some useful math constants, all read-only. Here are 
 their values:
  
 > Math.E; 
  
 2.7182818284590
 45
  
 > Math.LN10; 
  
 2.3025850929940
 46
  
 > Math.LN2; 
  
 0.6931471805599
 453
  
 > Math.LOG2E; 
  
 1.4426950408889
 634
  
 > Math.LOG10E; 
  
 0.43429448190325
 18
  
 > Math.PI; 
  
 3.1415926535897
 93
  
 > Math.SQRT1_2; 
  
 0.7071067811865476
  
 > Math.SQRT2; 
  
 1.4142135623730
 951
  
 [
  339 
 ]",NA
RegExp ,"You can create a regular expression object using the 
 RegExp()
  constructor. You pass the 
 expression pattern as the first parameter and the pattern modifiers as the second.
  
 > var re = new RegExp('[dn]o+dle', 'gmi');
  
 This matches ""noodle"", ""doodle"", ""doooodle"", and so on. It's equivalent to using the 
 regular expression literal:
  
 > var re = ('/[dn]o+dle/gmi'); // recommended
  
 Chapter 4
 , 
 Objects
  and 
 Appendix D
 , 
 Regular Expressions
  contains more information on 
 regular expressions and patterns.",NA
The RegExp.prototype members,"Property/method Description
  
 global
  
 ignoreCase
  
 multiline
  
 Read-only. 
 true
  if the 
 g
  modifier was set when creating the regexp 
 object.
  
 Read-only. 
 true 
 if the 
 i
  modifier was set when creating the regexp 
 object.
  
 Read-only. 
 true
  if the 
 m
  modifier was set when creating the regexp 
 object 
  
 [
  341 
 ]",NA
Error objects,"Error objects are created either by the environment (the browser) or by your code.
  
 > var e = new Error('jaavcsritp is _not_ how you spell it');
  
 > typeof e;
  
 ""object""
  
 Other than the 
 Error
  constructor, six additional ones exist and they all inherit 
 Error
 :
  
 • 
  
 EvalError
  
 • 
  
 RangeError
  
 • 
  
 ReferenceError
  
 • 
  
 SyntaxError
  
 • 
  
 TypeError
  
 • 
  
 URIError",NA
The Error.prototype members,"Property
  
 Description
  
 name
  
 The name of the error constructor used to create the object:
  
 > var e = new EvalError('Oops');
  
 > e.name;
  
 ""EvalError""
  
 message 
  
 Additional error information:
  
 > var e = new Error('Oops... again');
  
 > e.message;
  
 ""Oops... again""",NA
JSON,"The JSON object is new to ES5. It's not a constructor (similarly to 
 Math
 ) and has only 
  
 two methods: 
 parse()
  and 
 stringify()
 . For ES3 browsers that don't support JSON 
  
 natively, you can use the ""shim"" from 
 http://json.org
 .
  
 JSON
  stands for 
 JavaScript Object Notation
 . It's a lightweight data interchange 
  
 format. It's a subset of JavaScript that only supports primitives, object literals, and 
  
 array literals.
  
 [
  343 
 ]",NA
Members of the JSON object,"Method
  
 Description
  
 parse(text, 
 callback)
  
 Takes a JSON-encoded string and returns an object: 
  
 > var data = '{""hello"": 1, ""hi"": [1, 2, 3]}';
  
 > var o = JSON.parse(data); 
  
 > o.hello; 
  
 1
  
 > o.hi; 
  
 [1, 2, 3] 
  
 The optional callback lets you provide your own function that can 
 inspect and modify the result. The callback takes 
 key
  and 
 value 
 arguments and can modify the 
 value
  or delete it (by returning 
 undefined
 ).
  
 > function callback(key, value) {
  
   
  console.log(key, value);
  
   
  if (key === 'hello') {
  
    
  return 'bonjour';
  
   
  }
  
   
  if (key === 'hi') {
  
    
  return undefined;
  
   
  }
  
   
  return value;
  
  
  }
  
 >   var o = JSON.parse(data, callback); 
  
 hello 1 
  
 0 1 
  
 1 2 
  
 2 3 
  
 hi [1, 2, 3] 
  
 Object {hello: ""bonjour""} 
  
 > o.hello; 
  
 ""bonjour""
  
 > 'hi' in o; 
  
 false
  
 [
  344 
 ]",NA
Regular Expressions,"When you use regular expressions (discussed in 
 Chapter 4
 , 
 Objects
 ), you can match 
 literal strings, for example:
  
 > ""some 
 text"".match(/me/); 
  
 [""me""]
  
 But, the true power of regular expressions comes from matching patterns, not literal 
 strings. The following table describes the different syntax you can use in your patterns, 
 and provides some examples of their use:
  
 Pattern 
  
 Description 
  
 [abc]
  
 Matches a class of characters.
  
 > ""some text"".match(/[otx]/g); 
  
 [""o"", ""t"", ""x"", ""t""]
  
 [a-z]
  
 A class of characters defined as a range. For example, [a-d] is the same as 
 [abcd], [a-z] matches all lowercase characters, [a-zA-Z0-9_] matches all 
 characters, numbers, and the underscore character.
  
 > ""Some Text"".match(/[a-z]/g); 
  
 [""o"", ""m"", ""e"", ""e"", ""x"", ""t""]
  
 > ""Some Text"".match(/[a-zA-
 Z]/g); 
  
 [""S"", ""o"", ""m"", ""e"", ""T"", ""e"", ""x"", ""t""]
  
 [^abc] 
  
 Matches everything that is not matched by the class of characters.
  
 > ""Some Text"".match(/[^a-z]/g); 
  
 [""S"", "" "", ""T""]",NA
Index,NA,NA
Symbols,"^  350 
  
 !=  42 
  
 !==  42 
  
 ?  350 
  
 .  350 
  
 (?: pattern)  
 352 
  
 *  350 
  
 \  348 
  
 \\  35 
  
 +  351 
  
 <  42 
  
 <=  42 
  
 ==  41 
  
 ===  41 
  
 >  42 
  
 >=  42 
  
 \0  349 
  
 $  350 
  
 $ character  22 
  
 [^abc]  347 
  
 [abc]  347 
  
 [a-z]  347 
  
 [\b]  349 
  
 \b  349 
  
 \B  349 
  
 \d  349 
  
 \D  349 
  
 \f  348 
  
 {min,max}  351 
  
 {n}  351 
  
 \n  36, 348
  
 --, operators  26
  
 -, operators  25 
  
 *, operators  25
  
 /, operators  25 
  
 %, operators  25 
  
 +, operators  25 
  
 ++, operators  26 
  
 (pattern)  351 
  
 \r  36, 348 
  
 \s  348 
  
 \S  348 
  
 �  36 
  
    349 
  
 \v  348 
  
 \w  348 
  
 \W  349 
  
 \x00  349",NA
A,"a(?!b)  348 
  
 a(?=b)  348 
  
 a|b  348 
  
 accessor descriptors  313 
  
 actualWork() function  84 
  
 addEventListener/attachEvent methods   
 273 addEventListener() method  258 
  
 addListener() method  279 
  
 addSubscriber() method  297 
  
 Ajax  260 
  
 anonymous function  76 
  
 array 
  
  
 about  97-99, 114-116 
  
  
 methods  117 
  
 Array constructor 
  
  
 about  318 
  
  
 Array.prototype members  319 
  
  
 ECMAScript 5 additions to Array  322 
  
 array literal notation  99",NA
B,"best practice  73 
  
 black box function  67 
  
 BOM 
  
  
 about  9, 213, 215 
  
  
 cheat sheet console  217 
  
 overview  214 
  
  
 window.alert()  223 
  
  
 window.confirm()  223 
  
  
 window.document  226 
  
 window.frames  219, 220 
  
 window.history  218, 219 
  
 window.location  217, 218 
  
 window.moveTo()  222 
  
  
 window.navigator  216
  
  
 window object, revisiting  215 
  
 window.open()/close()  222 
  
  
 window.prompt()  223, 224 
  
  
 window.resizeTo()  223 
  
  
 window.screen  221 
  
  
 window.setInterval()  225, 226 
  
 window.setTimeout()  225, 226 
 boolean  125 
  
 Boolean constructor  327 
  
 Boolean() function  125 
  
 Booleans  36 
  
 break  301 
  
 Browser Object Model. 
 See
   BOM 
 built-in Functions 
  
  
 about  305, 306 
  
  
 decodeURI()  307 
  
  
 decodeURIComponent()  307 
  
  
 encodeURI()  307 
  
  
 encodeURIComponent()  306 
  
  
 eval()  307 
  
  
 isFinite()  306 
  
  
 isNaN()  305 
  
  
 parseFloat()  305 
  
  
 parseInt()  305 
  
 built-in objects 
  
  
 array  114 
  
  
 Array constructor  318 
  
  
 augmenting  164, 165 
  
  
 boolean  125 
  
  
 Boolean constructor  327 
  
  
 data wrapper objects  113 
  
  
 date  134, 135 
  
  
 Date constructor  333 
  
  
 error objects  113, 343 
  
  
 function  118 
  
  
 Function constructor  325 
  
  
 JSON  343 
  
  
 math  132 
  
  
 Math constructor  339 
  
  
 number  126, 127 
  
  
 Number constructor  328 
  
  
 object  113 
  
  
 object constructor  309 
  
  
 prototype gotchas  166, 168 
  
  
 RegExp  138 
  
  
 RegExp constructor  341 
  
  
 string  127, 128
  
 [
  354 
 ]",NA
C,"callback function 
  
  
 about  77, 78 
  
  
 examples  78, 79 
  
 Cascading Style Sheets (CSS)  273 
  
 case  301 
  
 catch  301 
  
 chaining pattern  287 
  
 child nodes  233 
  
 child object 
  
  
 parent, accessing  181, 182 
  
 classes  13 
  
 closures 
  
  
 about  85 
  
  
 closure #1  88 
  
  
 closure #2  88 
  
  
 closure #3  89 
  
  
 getter/setter  92, 93 
  
  
 in loop  90, 92 
  
  
 iterator  93 
  
  
 scope chain  85 
  
  
 used, for chain breaking  86, 87 
  
 code blocks 
  
  
 about  50, 51 
  
  
 alternative if syntax  53 
  
  
 variable existence, checking  51, 52 
  
 coding patterns 
  
  
 about  272 
  
  
 chaining pattern  287 
  
  
 configuration object  280, 281 
  
  
 immediate functions  285 
  
  
 init-time branching  278, 279 
  
  
 JSON  288, 289 
  
  
 lazy definition pattern  279 
  
  
 modules  286 
  
  
 namespaces  275 
  
  
 private functions, as public methods  284 
  
 private properties  282, 283 
  
  
 privileged methods  283 
  
  
 web page, building blocks  272 
  
 comments  61 
  
 comparison 
  
  
 about  41
  
  
 null  43, 44 
  
  
 Operator symbols  41, 42 
  
  
 Undefined  43 
  
 compound operators  27 
  
 conditions 
  
  
 about  48 
  
  
 else clause  49, 50 
  
  
 if condition  49 
  
 Console tab  18 
  
 constructor 
  
  
 borrowing  198, 199 
  
  
 prototype, copying  200 
  
 constructor functions  104, 
 105 constructor property  107, 
 168 continue  301 
  
 core DOM  229, 230 
  
 Core ECMAScript objects  214 
 createTextNode() method  242",NA
D,"data. 
 See
   functions 
  
 data descriptors  313 
  
 Date()  134, 135 
  
 Date constructor 
  
  
 about  333, 334 
  
  
 Date.prototype members  335 
  
 ECMAScript 5 additions  338 
  
 members  334 
  
 date objects 
  
  
 working with, methods  136-138 
 date objects methods 
  
  
 getMonth()  136 
  
  
 setHours()  136 
  
  
 setMonth()  136 
  
 Date.prototype members 
  
  
 getDate()  336 
  
  
 getDay()  338 
  
  
 getFullYear()  336 
  
  
 getHours()  337 
  
  
 getMilliseconds()  337 
  
  
 getMinutes()  337 
  
  
 getMonth()  336 
  
  
 getSeconds()  337 
  
  
 getTime()  335 
  
  
 getTimezoneOffset()  337 
  
  
 getUTCDate()  336
  
 [
  355 
 ]",NA
E,"ECMA  8 
  
 ECMAScript. 
 See
  ES 
  
 ECMAScript 5. 
 See
  ES 
  
 ECMAScript 5 additions to Array 
  
  
 Array.isArray(obj)  322 
  
  
 Ar-ray.prototype.every(callback, this_obj) 
   
 324 
  
  
 Ar-ray.prototype.filter(callback, this_obj) 
   
 324 
  
  
 Ar-ray.prototype.forEach(callback, this_obj) 
   
 323 
  
  
 Ar-ray.prototype.indexOf(needle, idx)  322 
  
 Ar-ray.prototype.lastIndexOf(needle, idx) 
   
 323 
  
  
 Ar-ray.prototype.map(callback, this_obj) 
   
 325 
  
  
 Ar-ray.prototype.reduce(callback, start)  325
  
 [
  356 
 ]",NA
F,"factory() function  108, 109 
  
 factory() method  294 
  
 finally  302 
  
 firstname property  101 
  
 foo() function  154 
  
 Function() constructor 
  
  
 about  118, 119, 326 
  
  
 arguments  123 
  
  
 Function.prototype members  326 
  
  
 function objects, methods  121 
  
  
 object types, inferring  124 
  
  
 properties  120 
  
  
 prototype property  120, 121 
  
 function expression  75 
  
 function literal notation  75 
  
 function N()  89 
  
 function objects, methods 
  
  
 apply()  122, 123 
  
  
 call()  122 
  
  
 say() method  122 
  
 Func-tion.prototype.bind() property  327 
 Function.prototype members 
  
  
 apply(this_obj, params_array)  326 
  
  
 call(this_obj, p1, p2, p3, ...)  326 
  
  
 ECMAScript 5 additions to a function  327 
  
 length  326 
  
 functions 
  
  
 about  64, 75, 76 
  
  
 anonymous functions  76 
  
  
 callback functions  77 
  
  
 calling  64 
  
  
 components  64 
  
  
 immediate functions  80, 81 
  
  
 inner(private)  81 
  
  
 inner(private), benefits  82 
  
  
 parameters  65, 66 
  
  
 predefined functions  66 
  
  
 replacing  83, 84 
  
  
 returning values  82 
  
 future reserved words  302, 303",NA
G,"Gadget() constructor  155 
  
 getArea() method  196 
  
 getAttribute() method  234
  
 [
  357 
 ]",NA
H,"hash  100 
  
 hasOwnProperty() method  158, 
 160 hexadecimal numbers  29 
  
 hoisting  74 
  
 HTML DOM  229, 230 
  
 HTML-only DOM objects 
  
  
 about  247 
  
  
 accessing, primitive ways  247, 248 
  
 cookies  249 
  
  
 document.write()  248, 249 
  
  
 domain  249, 250 
  
  
 referrer  249 
  
  
 title  249 
  
 HTML page 
  
  
 JavaScript, including  213, 214",NA
I,"if condition  49 
  
 ignoreCase property  139 
  
 immediate functions  285 
  
 inArray() method  164 
  
 indexed array  100 
  
 indexOf() method  141 
  
 infinity 
  
  
 about  31, 32 
  
  
 NaN  32 
  
 inheritance  171 
  
 inheritance part 
  
  
 isolating, into function  182, 183 
 init-time branching  278 
  
 inline HTML attributes  251 
  
 inner (private) function  81, 82 
 instanceof operator  108, 174 
  
 isFinite() function  70, 306 
  
 isNaN() function  69, 70, 306 
  
 isPrototypeOf() method  162 
  
 iterator functionality  93",NA
J,"JavaScript 
  
  
 about  7 
  
  
 BOM  9 
  
  
 Browser Wars  10 
  
  
 DOM  8 
  
  
 ECMAScript  8 
  
  
 future  11 
  
  
 history  8 
  
  
 including, in HTML page  213, 214 
  
 uses  10, 11 
  
 JavaScript Object Notation. 
 See
   JSON 
 join() method  117 
  
 JSON 
  
  
 about  288, 343 
  
  
 members  344",NA
K,"keywords, ES5 
  
 break  301 
  
 case  301 
  
 catch  301 
  
 continue  301 
  
 debugger  301 
  
 default  301 
  
 delete  301 
  
 do  302 
  
 else  302 
  
 finally  302 
  
 for  302 
  
 function  302 
  
 if  302 
  
 ifn  302 
  
 instanceof  302 
  
 new  302 
  
 return  302 
  
 switch  302 
  
 this  302 
  
 throw  302 
  
 try  302 
  
 typeof  302 
  
 var  302 
  
 void  302 
  
 while  302 
  
 with  302
  
 [
  358 
 ]",NA
L,"lastIndexOf() method  141 
 lastIndex property  139, 
 342 lazy definition pattern  
 279 logical operators 
  
  
 about  37 
  
  
 lazy evaluation  40, 41 
  
  
 operator precedence  39 
  
 possible operations  38, 39 
 loops 
  
  
 about  48, 56 
  
  
 for-in loops  60 
  
  
 for loops  57, 59 
  
  
 infinite loop  56 
  
  
 while loops  56",NA
M,"make() method  297 
  
 match() method  141 
  
 Math  132, 133 
  
 Math constructor 
  
  
 about  339 
  
  
 members  339 
  
 maybeExists() function  147 
  
 members, Date constructor 
  
  
 Date.parse(string)  334 
  
  
 Date.UTC(year, month, date, hours, 
   
 minutes, seconds, ms)  334 
  
 members, JSON 
  
  
 parse(text, call-back)  344 
  
  
 stringi-fy(value, callback, white)  345 
 members, Math constructor 
  
  
 Math.abs(x)  340 
  
  
 Math.acos(x)  340 
  
  
 Math.E  339 
  
  
 Math.exp(x)  340 
  
  
 Math.LN2  339 
  
  
 Math.LN10  339 
  
  
 Math.LOG2E  339 
  
  
 Math.LOG10E  339 
  
  
 Math.log(x)  340 
  
  
 Math.max(num1, num2, num3, ...)  340 
  
 Math.PI  339 
  
  
 Math.pow(x, y)  341 
  
  
 Math.random()  341 
  
  
 Math.round(x)  340
  
  
 Math.SQRT1_2  339 
  
  
 Math.SQRT2  339 
  
  
 Math.sqrt(x)  341 
  
 members, Number constructor 
  
  
 Number.MAX_VALUE  328 
  
  
 Number.MIN_VALUE  328 
  
  
 Number.NaN  328 
  
  
 Number.NEGATIVE_INFINITY  328 
  
 Number.POSITIVE_INFINITY  328 
 members, String() constructor 
  
  
 String.fromCharCode (code1, code2, 
  
  
 code3, ...)  330 
  
 methods  99 
  
 modules  286 
  
 multi() function  195 
  
 multiline property  139 
  
 multiple inheritance 
  
  
 about  195, 196 
  
  
 mixins  197",NA
N,"named function expression. 
 See
   NFE 
 namespace() method  277 
  
 namespaces 
  
  
 constructors  276 
  
  
 namespace() method  277, 278 
  
  
 object  275 
  
 NaN  32 
  
 new F()  179, 180 
  
 new nodes 
  
  
 cloneNode()  243 
  
  
 creating  242 
  
  
 DOM-only method  243 
  
  
 insertBefore()  244 
  
 new operator  108 
  
 newtoy.toString()  157 
  
 next() function  93 
  
 NFE  75 
  
 nodes 
  
  
 removing  245, 246 
  
 now() method  137 
  
 number  126, 127 
  
 Number constructor 
  
  
 about  328 
  
  
 members  328 
  
  
 Number.prototype members  329
  
 [
  359 
 ]",NA
O,"object constructor 
  
  
 about  309 
  
  
 ECMAScript 5 additions  312-317 
  
  
 memebers  310 
  
  
 Object.prototype  310 
  
  
 Object.prototype members  311, 312 
  
 Object.create(obj, descr) property  315 
 Ob-ject.defineProperties(obj, descriptors) 
   
 property  316 
  
 Ob-ject.defineProperty(obj, descriptor) 
  
  
 property  315 
  
 Object.freeze(obj) property  317 
  
 object() function  192, 193, 197 
  
 Ob-ject.getOwnPropertyDescriptor(obj, 
  
  
 property) property  315 
  
 Ob-ject.getOwnPropertyNames(obj) 
  
   
 property  315 
  
 Ob-ject.getPrototypeOf(obj) property  314 
 Ob-ject.isExtensible(obj) property  316 
 Object.keys(obj) property  317 
  
 object literal notation  99 
  
 object-oriented programming. 
 See
   OOP 
 Ob-ject.preventExtensions(obj) 
  
   
 property  316 
  
 Object.prototype members 
  
  
 constructor  310 
  
  
 hasOwnProper-ty(prop)  312 
  
  
 isPrototypeOf(obj)  312 
  
  
 propertyIsEnumera-ble(prop)  312 
  
  
 toLocaleString()  311 
  
  
 toString(radix)  310 
  
  
 valueOf()  311 
  
 objects 
  
  
 about  13 
  
  
 comparing  110 
  
  
 global object  107 
  
  
 inheriting, from objects  188, 190 
  
  
 passing  109, 110 
  
 Object.seal(obj) property  317
  
 object's methods 
  
  
 altering  102, 103 
  
  
 calling  102 
  
 object's properties 
  
  
 accessing  100 
  
  
 calling  102, 103 
  
 objects, WebKit console 
  
  
 about  111 
  
  
 console.log  112 
  
 observer pattern  296-
 299 
  
 octal number  29 
  
 OOP 
  
  
 about  12 
  
  
 aggregation  15 
  
  
 classes  13 
  
  
 encapsulation  14 
  
  
 features  16 
  
  
 inheritance  15 
  
  
 objects  13 
  
  
 polymorphism  16 
  
  
 summary  16 
  
 operation  38 
  
 operators
  
  
 -  25
  
  
 --  26 
  
  
 *  25 
  
  
 /  25 
  
  
 %  25 
  
  
 +  25 
  
  
 ++  26 
  
  
 about  24 
  
 overriding  15",NA
P,"parasitic inheritance  197, 198 
 parseFloat() function  68, 69, 
 305 parseInt() function  67, 68, 
 305 polyfills  166 
  
 polymorphism  16 
  
 predefined functions 
  
  
 about  66 
  
  
 eval()  71 
  
  
 isFinite()  70 
  
  
 isNaN()  69, 70 
  
  
 parseFloat()  68, 69 
  
  
 parseInt()  67, 68
  
 [
  360 
 ]",NA
Q,"querySelectorAll() method  237 
 querySelector() method  237, 
 241",NA
R,"radix  67 
  
 random() function  133 
  
 rating property  157 
  
 readystatechange event  262 
  
 readyState property  262 
  
 Rectangle constructor  209 
  
 RegExp 
  
  
 about  139 
  
  
 accepting, as parameters  141 
  
  
 callbacks, replacing  142, 143 
  
  
 error objects  145-147 
  
  
 match()method  141 
  
  
 methods  140 
  
  
 properties  139 
  
  
 replace() method  142 
  
  
 search() method  141 
  
  
 split() method  144 
  
  
 string, passing  144 
  
 RegExp constructor 
  
  
 about  341 
  
  
 RegExp.prototype members  341 
 RegExp properties 
  
  
 global  139 
  
  
 ignoreCase  139 
  
  
 lastIndex  139 
  
  
 multiline  139 
  
  
 source  139, 140 
  
 RegExp.prototype members 
  
  
 exec(string)  342 
  
  
 global  341 
  
  
 ignoreCase  341 
  
  
 lastIndex  342 
  
  
 multiline  341 
  
  
 source  342 
  
  
 test(string)  342 
  
 regular expression. 
 See
  also RegExp 
 regular expression 
  
  
 ^  350 
  
  
 ?  350 
  
  
 .  350 
  
  
 (?: 
 pattern)  352 
  
  
 *  350 
  
  
 \  348 
  
  
 +  351 
  
  
 \0  349
  
 [
  361 
 ]",NA
S,"sayName() method  104 
  
 Script tab  20 
  
 search() method  141 
  
 secret __proto__ link  163 
  
 secret variable  92 
  
 setter function  92 
  
 setup() function  94 
  
 setValue()  93 
  
 shapes 
  
  
 analyzing  205 
  
  
 drawing  205 
  
  
 implementation  206-209 
  
  
 testing  210 
  
 shims  166 
  
 simple assignment operator  
 26
  
 Singleton  290 
  
 Singleton 2 
  
  
 about  290 
  
  
 Constructor property  291 
  
  
 global variable  291 
  
  
 in private property  292 
  
 slice() method  118 
  
 someSetup() function  84 
  
 sort() method  117 
  
 source property  139 
  
 splice() method  118 
  
 split() method  131, 144 
  
 stopPropagation() method  255, 258 
 string 
  
  
 about  127-129 
  
  
 methods  129 
  
 String() constructor 
  
  
 about  329, 330 
  
  
 ECMAScript 5 additions to String  333 
  
 members  330 
  
  
 String.prototype members  331 
  
 string methods 
  
  
 about  127, 128, 129 
  
  
 charAt()  130 
  
  
 indexOf()  130 
  
  
 lastIndexOf()  130 
  
  
 slice()  131 
  
  
 split() method  131 
  
  
 substring()  131 
  
  
 toLowerCase()  129 
  
 String.prototype members 
  
  
 charAt(position)  331 
  
  
 charCodeAt(position)  331 
  
  
 indexOf(needle, start)  331 
  
  
 length  331 
  
  
 localeCompare(needle)  332 
  
  
 match(regexp)  332 
  
  
 replace(needle, re-placement)  332 
  
  
 search(regexp)  332 
  
  
 slice(start, end)  332 
  
  
 split(separator, limit)  332 
  
  
 substring(start, end)  333 
  
  
 toLocaleLowerCase()  333 
  
  
 toLocaleUpperCase()  333 
  
  
 toLowerCase()  333 
  
  
 toUpperCase()  333 
  
 String.prototype.trim() property  333
  
 [
  362 
 ]",NA
T,"this value 
  
  
 using  104 
  
 toString() method  127, 157, 158, 
 173 training environment setup 
  
  
 about  17 
  
  
 consoles  19, 20 
  
  
 JavaScriptCore  18 
  
  
 WebKit's web inspector  17, 18 
  
 Triangle constructor  176 
  
 typeof operator  28, 75",NA
U,"uber property  181, 182 
  
 Uniform Resource Identifier. 
 See
   URI 
 Uniform Resource Locator. 
 See
   URL 
 URI  70 
  
 URL  70
  
 WebKit console 
  
  
 objects  111 
  
 WebKit'sWeb Inspector  17 
  
 web page, building blocks 
  
  
 Asynchronous JavaScript loading  275 
  
 behavior  273 
  
  
 behavior separation, example  274 
  
  
 content  272 
  
  
 presentation  273 
  
 while loops 
  
  
 about  56 
  
  
 do-while loops  57 
  
 window.alert()  223 
  
 window.confirm()  223 
  
 window.document  226 
  
 window.frames  219, 220 
  
 window.history  218, 219 
  
 window.location  217, 218 
  
 window.moveTo()  222 
  
 window.navigator  216 
  
 window.open()/close()  222 
  
 window.prompt()  223, 224 
  
 window.resizeTo()  222 
  
 window.screen  221 
  
 window.setInterval()  225, 226 
  
 window.setTimeout()  225, 226 
  
 World Wide Web Consortium. 
 See
   W3C",NA
V X,"valueOf() method  125 
 variables 
  
  
 $ character  22 
  
  
 about  21, 22 
  
  
 case sensitive  23, 24 
  
 hoisting  74 
  
  
 scope  72, 73",NA
W,"W3C  8, 214
  
 XMLHttpRequest 
  
  
 about  260 
  
  
 Asynchronous  264 
  
  
 example  265, 266 
  
  
 request, sending  261 
  
  
 response, processing  262 
  
  
 steps  261 
  
  
 XML  264 
  
  
 XMLHttpRequest objects, creating in IE  263 
 XMLHttpRequest object  10
  
 [
  363 
 ]",NA
Thank you for buying ,NA,NA
Object Oriented JavaScript,NA,NA
Second Edition,NA,NA
About Packt Publishing,"Packt, pronounced 'packed', published its first book ""
 Mastering phpMyAdmin for Effective 
 MySQL Management
 "" in April 2004 and subsequently continued to specialize in publishing 
 highly focused books on specific technologies and solutions.
  
 Our books and publications share the experiences of your fellow IT professionals in adapting and 
 customizing today's systems, applications, and frameworks. Our solution based books give you the 
 knowledge and power to customize the software and technologies you're using to get the job done. 
 Packt books are more specific and less general than the IT books you have seen in the past. Our 
 unique business model allows us to bring you more focused information, giving you more of what 
 you need to know, and less of what you don't.
  
 Packt is a modern, yet unique publishing company, which focuses on producing quality, 
 cutting-edge books for communities of developers, administrators, and newbies alike. For 
 more information, please visit our website: 
 www.packtpub.com
 .",NA
Writing for Packt,"We welcome all inquiries from people who are interested in authoring. Book proposals should be 
 sent to 
 author@packtpub.com
 . If your book idea is still at an early stage and you would like to 
 discuss it first before writing a formal book proposal, contact us; one of our commissioning 
 editors will get in touch with you. 
  
 We're not just looking for published authors; if you have strong technical skills but no writing 
 experience, our experienced editors can help you develop a writing career, or simply get some 
 additional reward for your expertise.",NA
Learning jQuery Third Edition ,"ISBN: 978-1-84951-654-9             Paperback: 428 pages
  
 Create better interaction, design, and web 
  
 development with simple JavaScript techniques
  
 1. 
  
 2. 
  
 3. 
  
 An introduction to jQuery that requires 
 minimal programming experience
  
 Detailed solutions to specific client-side 
 problems
  
 Revised and updated version of this popular 
 jQuery book",NA
jQuery UI 1.8: The User Interface ,NA,NA
Library for jQuery,"ISBN: 9781-8-4951-652-5            Paperback: 424 pages
  
 Build highly interactive web applications with 
 ready-to-use widgets from the jQuery User 
 Interface Library
  
 1. 
  
 2. 
  
 3. 
  
 Packed with examples and clear explanations of 
 how to easily design elegant and     powerful front-
 end interfaces for your web applications
  
 A section covering the widget factory including an 
 in-depth example on how to build a custom jQuery 
 UI widget
  
 Updated code with significant changes and 
 fixes to the previous edition
  
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
Sencha Touch Mobile JavaScript ,NA,NA
Framework,"ISBN: 978-1-84951-510-8             Paperback: 316 pages
  
 Build web applications for Apple iOS and Google 
 Android touchscreen devices with this first HTML5 
 mobile framework
  
 1. 
  
 2. 
  
 3. 
  
 Learn to develop web applications that look 
 and feel native on Apple iOS and Google 
 Android touchscreen devices using Sencha 
 Touch through examples
  
 Design resolution-independent and graphical 
 representations like buttons, icons, and tabs of 
 unparalleled flexibility
  
 Add custom events like tap, double tap, swipe, tap 
 and hold, pinch, and rotate",NA
Instant Ember.js Application ,NA,NA
Development How-to,"ISBN: 978-1-78216-338-1            Paperback: 48 pages
  
 Your first step in creating amazing web applications
  
 1. 
  
 2. 
  
 3. 
  
 4. 
  
 Learn something new in an Instant! A short, 
 fast, focused guide delivering immediate results
  
 Create semantic HTML templates using 
 Handlebars
  
 Lay the foundation for large web applications using 
 the latest version of Ember.js in an easy to follow 
 format
  
 Follow clear and concise examples to build up a 
 fully working application
  
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
