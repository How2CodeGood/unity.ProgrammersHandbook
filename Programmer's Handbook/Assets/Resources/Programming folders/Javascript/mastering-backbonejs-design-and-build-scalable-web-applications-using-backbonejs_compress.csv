Larger Text,Smaller Text,Symbol
Mastering Backbone.js,NA,NA
Design and build scalable web applications using ,NA,NA
Backbone.js,NA,NA
Abiee Echamea,"BIRMINGHAM - MUMBAI
  
 www.it-ebooks.info",NA
Mastering Backbone.js,"Copyright © 2016 Packt Publishing
  
 All rights reserved. No part of this book may be reproduced, stored in a retrieval 
 system, or transmitted in any form or by any means, without the prior written 
 permission of the publisher, except in the case of brief quotations embedded in 
 critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of 
 the information presented. However, the information contained in this book is sold 
 without warranty, either express or implied. Neither the author(s), nor Packt 
 Publishing, and its dealers and distributors will be held liable for any damages 
 caused or alleged to be caused directly or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the 
 companies and products mentioned in this book by the appropriate use of capitals. 
  
 However, Packt Publishing cannot guarantee the accuracy of this information.
  
 First published: January 2016
  
 Production reference: 1080116
  
 Published by Packt Publishing Ltd.
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham B3 2PB, UK.
  
 ISBN 978-1-78328-849-6
  
 www.packtpub.com
  
 www.it-ebooks.info",NA
Credits,"Author 
  
 Abiee Echamea
  
 Reviewers 
  
 Mudassir Ali
  
 Aleksandar Goševski
  
 Lorenzo Pisani
  
 Commissioning Editor 
 Rebika Yuvi
  
 Acquisition Editor 
 Llewellyn Rozario
  
 Content Development Editor 
 Susmita Sabat
  
 Technical Editor 
  
 Danish Shaikh
  
 Copy Editor 
  
 Vibha Shukla
  
 Project Coordinator 
 Milton Dsouza
  
 Proofreader 
  
 Safis Editing
  
 Indexer 
  
 Hemangini Bari
  
 Graphics 
  
 Disha Haria
  
 Production Coordinator 
 Arvindkumar Gupta
  
 Cover Work 
  
 Arvindkumar Gupta
  
 www.it-ebooks.info",NA
About the Author,"Abiee Echamea
  is a passionate technology software engineer; he fell in love with 
 computers at the age of 8 and wrote his first program at 12. He has written 
 applications in many technologies, from Visual Basic to full stack web applications. 
 Now, Abiee is a software architect involved in the full development cycle, creating 
 many Backbone applications successfully and designing the architecture and 
 development process. He has founded a company to work with cutting-edge 
 technology as a CTO. He has developed the skills to master the JavaScript and 
 Backbone libraries to build maintainable projects for his company. Abiee loves to 
 share his knowledge with the community and is looking for ways to improve his 
 engineering skills.
  
 www.it-ebooks.info",NA
About the Reviewers,"Mudassir Ali
  is a senior frontend engineer at DiligenceVault. After working as a full 
 stack web developer for a year and a half, he decided to specialize in frontend 
 technologies due to his passion for the development of amazing user experiences by 
 building effective user interfaces. In his three years of web development experience, he 
 has worked on three major popular JavaScript frameworks: BackboneJS, 
  
 AngularJS, and EmberJS. Besides his interest in frontend JavaScript and HTML5 
 technologies, he is also interested in designing JSON Apis using Ruby on Rails. He is also 
 a regular contributor to the StackOverflow community and occasionally contributes to 
 open source.
  
 Aleksandar Goševski
  is a frontend engineer based in Belgrade, Serbia. He is a 23-year 
 old senior developer with experience in creating websites and apps. He started with CSS 
 but always wanted to do something more. As most of his work is focused for the web, his 
 language of choice was JavaScript. Today, he uses JavaScript on both server side and client 
 side. He is very passionate about Backbone and that's his favorite framework. Aleksandar 
 is currently working for Vast.com. He is creating big single-page apps for clients mostly 
 from USA. Coca-Cola, Allianz, Yahoo, Carfax, Bing, and AOL are just some of the big 
 projects that Aleksandar has worked on.
  
 Lorenzo Pisani
  is a software engineer with over a decade of experience developing 
 applications with a large variety of languages and tools. As he slowly transitions to the 
 land of DevOps, he hopes to help educate developers on how to best plan for their 
 applications being deployed to production environments. As a huge advocate of open 
 source software, he contributes everything that he builds, outside of work, to his GitHub 
 profile (
 https://github.com/Zeelot
 ) for others to use and learn from.
  
 www.it-ebooks.info",NA
www.PacktPub.com,NA,NA
"Support files, eBooks, discount offers, and more","For support files and downloads related to your book, please visit 
 www.PacktPub.com
 .
  
 Did you know that Packt offers eBook versions of every book published, with PDF and 
 ePub files available? You can upgrade to the eBook version at 
 www.PacktPub.com 
 and 
 as a print book customer, you are entitled to a discount on the eBook copy. Get in touch 
 with us at 
 service@packtpub.com
  for more details.
  
 At 
 www.PacktPub.com
 , you can also read a collection of free technical articles, sign up for 
 a range of free newsletters and receive exclusive discounts and offers on Packt books and 
 eBooks.
  
 TM
  
 https://www2.packtpub.com/books/subscription/packtlib
  
 Do you need instant solutions to your IT questions? PacktLib is Packt's online digital 
 book library. Here, you can search, access, and readPackt's entire library of books.",NA
Why subscribe?,"•
  
 Fully searchable across every book published by Packt
  
 •
  
 Copy and paste, print, and bookmark content
  
 •
  
 On demand and accessible via a web browser",NA
Free access for Packt account holders,"If you have an account with Packt at 
 www.PacktPub.com
 , you can use this to access 
 PacktLib today and view 9 entirely free books. Simply use your login credentials for 
 immediate access.
  
 www.it-ebooks.info",NA
Table of Contents,"Preface 
  
 v
  
 Chapter 1: Architecture of a Backbone application 
  
 1
  
 Subapplications based architecture 
 Subapplication anatomy 
  
 Responsibilities of Backbone objects 
 Views 
  
 Models 
  
 Collections 
  
 Routers 
  
 Objects not provided by Backbone 
 Subapplication façade 
  
 Subapplication controller 
  
 Contacts application 
  
 File organization 
  
 Summary 
  
 Chapter 2: Managing Views 
  
 2 
  
 3 
  
 4 
  
 5 
  
 5 
  
 6 
  
 6 
  
 6 
  
 6 
  
 7 
  
 7 
  
 20 
  
 22
  
 23
  
 Identifying view types 
  
 ModelView 
  
 CollectionView 
  
 Adding new models 
  
 Deleting models 
  
 Destroying views 
  
 Resetting the collection 
  
 Region 
  
 Layout 
  
 Putting it all together 
  
 Showing a list 
  
 2
 4 
  
 2
 5 
  
 2
 8 
  
 3
 0 
  
 3
 1 
  
 3
 3 
  
 3
 4 
  
 3
 5 
  
 3
 8 
  
 4
 1 
  
 4
 3
  
 [
  i 
 ]
  
 www.it-ebooks.info",NA
Preface,"Backbone is an amazing library to build web applications; it's small, simple, and yet 
 powerful. It provides a set of small and focused objects to be used as bricks when 
 building frontend applications.
  
 The beauty of Backbone is that it gives you the freedom to build your applications with 
 your rules. However, with great power comes great responsibility; Backbone does not 
 tell you anything about how to structure your applications. Keep in mind that 
 Backbone is not a framework but a library.
  
 After years of working with Backbone projects, making code experiments, and 
 exploring code from other developers, I have identified patterns and best practices 
 when building frontend web apps with Backbone.
  
 This book explains how to give structure to your applications. It gives you the tools and 
 strategies to create robust and maintainable web apps. It will help you define and assign 
 the right responsibilities to the Backbone objects and define a new set of glue objects.
  
 In the book, you will build a functional application applying the concepts that are 
 exposed here. The application is simple enough to put in to practice the core concepts 
 when building scalable frontend applications with Backbone. At any time, you can see 
 the project code in the book repository at 
 https://github.com/abiee/ mastering-
 backbone
 .",NA
What this book covers,"Chapter 1
 , 
 Architecture of a Backbone application
 , deals with the project organization at 
 two levels: logical and physical. On the logical side, you will learn how to connect the 
 Backbone objects, while on the physical side, you will see where to put your scripts.
  
 [
  v 
 ]
  
 www.it-ebooks.info",NA
What you need for this book,"Though this book is for frontend applications, you will need to install Node version 5 or 
 superior. Node will run the example REST server, automatize common tasks, and manage 
 project dependencies.
  
 [
  vi 
 ]
  
 www.it-ebooks.info",NA
Who this book is for,"This book is made for developers who already know Backbone but want to create 
 better projects; it does not explain Backbone from scratch. Instead, I will show you 
 how to improve your skills to organize and structure your application in an effective 
 way.",NA
Conventions,"In this book, you will find a number of text styles that distinguish between different 
 kinds of information. Here are some examples of these styles and an explanation of their 
 meaning.
  
 Code words in text, database table names, folder names, filenames, file extensions, 
 pathnames, dummy URLs, user input, and Twitter handles are shown as follows: ""We 
 can include other contexts through the use of the 
 include
  directive.""
  
 A block of code is set as follows:
  
 [default]
  
 exten => s,1,Dial(Zap/1|30)
  
 exten => s,2,Voicemail(u100)
  
 exten => s,102,Voicemail(b100)
  
 exten => i,1,Voicemail(s0)
  
 When we wish to draw your attention to a particular part of a code block, the 
 relevant lines or items are set in bold:
  
 [default]
  
 exten => s,1,Dial(Zap/1|30)
  
 exten => s,2,Voicemail(u100)
  
 exten => s,102,Voicemail(b100)
  
 exten => i,1,Voicemail(s0)
  
 Any command-line input or output is written as follows:
  
 # cp /usr/src/asterisk-addons/configs/cdr_mysql.conf.sample
  
  /etc/asterisk/cdr_mysql.conf
  
 [
  vii 
 ]
  
 www.it-ebooks.info",NA
Reader feedback,"Feedback from our readers is always welcome. Let us know what you think about this 
 book—what you liked or disliked. Reader feedback is important for us as it helps us 
 develop titles that you will really get the most out of.
  
 To send us general feedback, simply e-mail 
 feedback@packtpub.com
 , and mention the 
 book's title in the subject of your message.
  
 If there is a topic that you have expertise in and you are interested in either writing or 
 contributing to a book, see our author guide at 
 www.packtpub.com/authors
 .",NA
Customer support,"Now that you are the proud owner of a Packt book, we have a number of things to help 
 you to get the most from your purchase.",NA
Downloading the example code,"You can download the example code files from your account at 
 http://www.
  
 packtpub.com
  for all the Packt Publishing books you have purchased. If you 
 purchased this book elsewhere, you can visit 
 http://www.packtpub.com/support 
 and register to have the files e-mailed directly to you.
  
 [
  viii 
 ]
  
 www.it-ebooks.info",NA
Errata,"Although we have taken every care to ensure the accuracy of our content, mistakes do 
 happen. If you find a mistake in one of our books—maybe a mistake in the text or the 
 code—we would be grateful if you could report this to us. By doing so, you can save 
 other readers from frustration and help us improve subsequent versions of this book. If 
 you find any errata, please report them by visiting 
 http://www.packtpub. 
 com/submit-errata
 , selecting your book, clicking on the 
 Errata Submission Form 
 link, and entering the details of your errata. Once your errata are verified, your 
 submission will be accepted and the errata will be uploaded to our website or added to 
 any list of existing errata under the Errata section of that title.
  
 To view the previously submitted errata, go to 
 https://www.packtpub.com/books/ 
 content/support
  and enter the name of the book in the search field. The required 
 information will appear under the 
 Errata
  section.",NA
Piracy,"Piracy of copyrighted material on the Internet is an ongoing problem across all media. At 
 Packt, we take the protection of our copyright and licenses very seriously. If you come 
 across any illegal copies of our works in any form on the Internet, please provide us with 
 the location address or website name immediately so that we can pursue a remedy.
  
 Please contact us at 
 copyright@packtpub.com
  with a link to the suspected 
 pirated material.
  
 We appreciate your help in protecting our authors and our ability to bring you 
 valuable content.",NA
Questions,"If you have a problem with any aspect of this book, you can contact us at 
 questions@packtpub.com
 , and we will do our best to address the problem.
  
 [
  ix 
 ]
  
 www.it-ebooks.info",NA
Architecture of a ,NA,NA
Backbone application,"One of the best things about Backbone is the freedom to build applications with the 
 libraries of your choice, no batteries included. Note that Backbone is not a framework but 
 a library; due to this, building applications with Backbone can be challenging as no 
 structure is provided. You, as a developer, are responsible for code organization and how 
 to wire the pieces of the code across the application; it's a big responsibility. Bad 
 decisions can lead to buggy and unmaintainable applications that nobody wants to work 
 with.
  
 Code organization on small Backbone applications is not a big deal. Create a directory for 
 models, collections, and views; put a router for all possible routes; and write the business 
 logic directly in the views. However, this way of developing Backbone applications is not 
 suitable for bigger projects. There should be a better way to separate responsibilities and 
 file organization in order to create maintainable applications.
  
 This chapter can be difficult to understand if you don't know Backbone at all; to 
 understand the principles that are exposed here better, you will need to understand at 
 least the basics of Backbone. Therefore, if you are a beginner in Backbone, I would 
 encourage you to first understand what Backbone is and how it works.
  
 The goal of this chapter is to explore the best practices of project organization on two 
 main levels: logic organization and file structure. In this chapter, you will learn the 
 following:
  
 • 
  
 • 
  
 • 
  
 • 
  
 Delegating the right responsibilities to the objects provided by Backbone 
 Defining plain JavaScript objects in order to deal with logic out of scope of 
 Backbone objects 
  
 Splitting the application in to small and maintainable scripts 
  
 Creating a clean file structure for your projects
  
 [
  1 
 ]
  
 www.it-ebooks.info",NA
Subapplications based architecture,"We can compose a Backbone application with many independent subapplications. The 
 subapplications should work independently. You can think about each one as a small 
 Backbone application, with its own dependencies and responsibilities; it should not 
 depend on other subapplications directly.
  
 Subapplications should be focused on a specific domain area. For example, you can have 
 a subapplication for invoices, another for the mailbox, and one more for payments; with 
 these subapplications in place, you can build an application in order to manage 
 payments through email.
  
 To decouple subapplications from each other, we can build an infrastructure application 
 responsible for managing the subapplications, bootstrapping the whole application, and 
 providing the subapplications with common functions and services:
  
  
 Figure 1.1. Composition of a Backbone application with subapplications
  
 You can use the infrastructure application to provide your subapplications with 
 services such as confirmation and dialog messages, notification pop-ups, modal 
 boxes, and so on. The infrastructure application does nothing by itself, it behaves as a 
 framework for the subapplications.
  
 When a subapplication wants to communicate with another subapplication, the 
 infrastructure application can be used as a communication channel, it can take 
 advantage of the 
 Backbone.Event
  object in order to send and receive messages.
  
 In the following figure, you can see a scenario where the subapplications 
  
 communicate through the infrastructure application. When the user clicks on 
 Compose message
  in the Mailbox subapplication, the infrastructure application 
 creates and renders the 
 Compose mail
  subapplication and allows the user to write an 
 e-mail.
  
 [
  2 
 ]
  
 www.it-ebooks.info",NA
Subapplication anatomy,"As mentioned earlier, a subapplication is like a small Backbone application; they 
 should be independent of other subapplications and work as a standalone. You 
 should be able to put the Compose mail subapplication on a blank page without any 
 other subapplication and still be able to send emails.
  
 To achieve this, the subapplications should contain all the necessary objects that are to 
 be auto-contained. You can see that the entry point of the subapplication is 
 Backbone.Router
 . When the browser changes the URL and a route is matched for a 
 given subapplication, the router creates a subapplication controller and delegates it the 
 route handling.
  
 The subapplication controller coordinates the models/collections and how they are 
 shown. The controller can instruct the 
 Application
  infrastructure to show a loading 
 message while the data is fetched and when it's done, the controller can build the 
 necessary views with the models and collections that are recently fetched in order to 
 show them in the DOM.
  
 [
  3 
 ]
  
 www.it-ebooks.info",NA
Responsibilities of Backbone objects,"One of the biggest issues with the Backbone documentation is not to have a clue about 
 how to use its objects. You, as developers, should figure out the 
  
 responsibilities for each object across the application; if you have some experience 
 working with Backbone, then you would know how difficult it would be to build a 
 Backbone application.
  
 [
  4 
 ]
  
 www.it-ebooks.info",NA
Views,"The only responsibilities of views are to handle the 
 Document Object Model
  (
 DOM
 ) and 
 listen for low-level events (jQuery/DOM events), and transform them into domain ones. 
 The Backbone Views works closely with template engines in order to create markups that 
 represent the information that is contained in models and collections.
  
 Views abstract the user interactions, transforming their actions into business value data 
 structures for the application. For example, when a click event is triggered from a Save 
 button in the DOM, the view should transform the event into something similar to a 
 save:contact
  event using Backbone Events with the data written in the form. Then, a 
 domain-specific object can apply some business logic to the data and show a result.
  
 It is a rule that business logic on views should be avoided; however, basic form 
 validations such as accept only numbers are allowed. Complex validations should still 
 be done on the model or the controller.",NA
Models,"Backbone Models are like database gateways in the server side, their main use is to fetch 
 and save data to and from a RESTful server and then provide an API to the rest of the 
 application in order to handle the information. They can run general-purpose business 
 logic, such as validation and data transformation, handle other server connections, and 
 upload an image for a model.
  
 The models do not know anything about views; however, they can implement 
 functionality that is useful for views. For example, you can have a view that shows the 
 total of an invoice and the invoice model can implement a method that does the 
 calculation, leaving the view without knowledge of the computation.
  
 [
  5 
 ]
  
 www.it-ebooks.info",NA
Collections,"You can think of Backbone Collections as a container of a set of Backbone Models, for 
 example, a Collection of 
 Contacts
  models. With a model, you can only fetch a single 
 document at time; however, Collections allow us to fetch lists of Models.
  
 A big difference from Models is that Collections should be used as read-only, they fetch 
 the data but they should not write in the server; also it is not usual to see business 
 logic here.
  
 Another use for Collection is to abstract RESTful APIs responses as each server has 
 different ways to deal with a list of resources. For instance, while some servers accept a 
 skip
  parameter for pagination, others have a 
 page
  parameter for the same purpose. 
  
 Another case is on responses, a server can respond with a plain array, while others 
 prefer to send an object with a 
 data
 , 
 list
 , or other key, where the array of objects is 
 placed. There is no standard way. Collections can deal with these issues, making server 
 requests transparent for the rest of the application.",NA
Routers,"Routers have a simple responsibility: listening for URL changes in the browser and 
 transforming them into a call to a handler. A router knows which handler to call for a 
 given URL. Also, they have to decode URL parameters and pass them to the handlers. 
 The infrastructure application bootstraps the application; however, routers decide 
 which subapplication will be executed. In this way, routers are a kind of entry point.",NA
Objects not provided by Backbone,"It is possible to develop Backbone applications only using the Backbone objects that are 
 described in the previous section; however, for a medium-to-large application, it's not 
 sufficient. We need to introduce a new kind of object with delimited responsibilities that 
 use and coordinate Backbone foundation objects.",NA
Subapplication façade,"This object is the public interface of the subapplications. Any interaction with the 
 subapplications should be done through its methods. The calls made directly to 
 internal objects of the subapplication are discouraged. Typically, methods on this 
 controller are called from the router; however, they can be called from anywhere.
  
 [
  6 
 ]
  
 www.it-ebooks.info",NA
Subapplication controller,"A controller acts like an air traffic controller for views, models, and collections. When 
 given a Backbone data object, it will instantiate and render the appropriate views and 
 then coordinate them. On complex layouts, it is not an easy task to coordinate the views 
 with the models and collections.
  
 The Business logic for the use cases should be implemented here. The subapplication 
 controller implements a 
 mediator pattern
 , allowing other basic objects such as views 
 and models keep it simple and loose coupling.
  
 Due to loose coupling reasons, a view should not directly call to methods or events of 
 other views Instead of this, a view triggers events and the controller handles the event 
 and orchestrates the views behavior if necessary. Note how views are isolated, handling 
 just its owned portion of DOM and triggering events when required to communicate 
 something.",NA
Contacts application,"In this book, we will develop a simple contacts application in order to demonstrate how 
 to develop Backbone applications following the principles explained 
  
 throughout this book. The application should be able to list all the available contacts in 
 RESTful API and provide the mechanisms to show and edit them.
  
 [
  7 
 ]
  
 www.it-ebooks.info",NA
File organization ,"When you work with MVC frameworks, file organization is trivial. However, Backbone 
 is not an MVC framework, therefore, bringing your own file structure is the rule. You 
 can organize the code on these paths:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 apps/
 : This directory is where modules or subapplications live. All 
 subapplications should be on this path
  
 Components/
 : These are the common components that multiple subapplications 
 require or use on the common layout as a breadcrumbs component
  
 core/
 : Under this path, we can put all the core functions such as utilities, 
 helpers, adapters, and so on
  
 vendor/
 : On vendor, you can put all third-party libraries; here you can put 
 Backbone and its dependencies.
  
 app.js
 : This is the entry point of the application that is loaded from 
  
 index.html
  
 [
  20 
 ]
  
 www.it-ebooks.info",NA
Summary,"We started by describing, in a general way, how a Backbone application works. It 
 describes two main parts: a root application and subapplications. The root 
 application provides a common infrastructure to other smaller and focused 
 applications that we call subapplications.
  
 Subapplications should be loose coupled with other subapplications and should own 
 its resources such as views, controllers, routers, and so on. A subapplication manages 
 a small part of the system with a well-focused business value and the communication 
 between subapplications and infrastructure application is made through an events-
 driven bus with 
 Backbone.Events
 .
  
 The user interacts with the application using views that a subapplication renders. A 
 subapplication controller orchestrates interaction between views, models, and 
 collections and owns the business logic for the use case.
  
 Finally, a file system organization explains the right sites to put your files and keep your 
 project clean and organized. This organization does not follow an MVC pattern; however, 
 it is powerful and simple. It encapsulates all the necessary code for a module in a single 
 path (subapplication paths) instead of putting all the code across multiple paths.
  
 In this way the structure of Backbone applications has been proven to be robust, a proof 
 for this is that several open source applications such as TodoMVC follow (more or less) 
 the principles exposed here. It facilitates the testability of the code due to separation of 
 responsibilities so that each object can be tested separately.
  
 Large Backbone applications are often built on top of Backbone Marionette as it reduces 
 the boilerplate code; however, Marionette uses its own conventions to work. If you are 
 fine with it using its own conventions, you will be happy to use Marionette on top of 
 Backbone.
  
 However, if you love the freedom of doing things your way, you may prefer plain 
 Backbone and create your own utilities and classes.
  
 In the next chapter, I will show you how to manage and organize views and simplify the 
 complex layouts, identifying the common uses of the views. You will build general 
 purpose views that will be useful for all your projects and forget about the 
 implementation of the 
 render()
  method.
  
 [
  22 
 ]
  
 www.it-ebooks.info",NA
Managing Views,"As we have seen in the previous chapter, Backbone views are responsible for 
 managing 
 DOM
  (
 Document Object Model
 ) interactions between users and 
 applications. A typical Backbone application is composed of many views with a very 
 specific behavior; for instance, we can have a view to show contact data and another 
 view to edit it. As you know, rendering a single view is a trivial task, but 
 orchestrating a complex layout with multiple views can be a pain.
  
 It's important to develop a better strategy to deal with complex view interactions to make 
 the project easier to maintain and fun to develop. If you don't put the necessary attention 
 into the organization of your views you can end up with a dirty DOM and messy code, 
 which makes it hard to introduce new features or change existing ones.
  
 As we did in the previous chapter, we are going to separate responsibilities by 
 identifying common view use cases and then will learn how to compose layouts by 
 using small views.
  
 In this chapter you will learn to:
  
 • 
  
 Identify common view types
  
 • 
  
 Implement reusable views for common types
  
 • 
  
 Use the reusable view types to compose complex views easily
  
 [
  23 
 ]
  
 www.it-ebooks.info",NA
Identifying view types,"After working with Backbone for a while you can see common use cases for views 
 emerge; they are so common they can be used for different unrelated projects. These 
 views can be extracted and can be used on any project if they are built correctly. Looking 
 at the Backbone documentation, Views do not implement a default render method, so 
 the trick here is to define a set of views with a default render method for different use 
 cases:
  
 • 
  
 • 
  
 • 
  
 • 
  
 View with model
  – Render a template with model data.
  
 View with collection
  – Render a collection of views with collection data; it 
 should update the list of views automatically when the collection changes. 
 Region
  – This view acts like a container; it points to a particular DOM node and 
 manages the content for that node. It's used to render other views. 
 Layout
  – A 
 layout is composed of one or more regions; it defines an HTML structure to 
 organize where the regions will be placed.
  
 Figure 2.1 shows a simple wireframe for an application; as you can see, it is a very 
 common layout found on web applications and is very useful to understand how the 
 common view types are related.
  
  
 Figure 2.1: Views, Regions, and Layout relationship
  
 With these foundation views you will have a simple but powerful framework to manage 
 your views, so you won't need to implement the 
 render()
  method anymore.
  
 [
  24 
 ]
  
 www.it-ebooks.info",NA
ModelView ,"The simplest implementation is to render a single model; it's a very straightforward 
 algorithm. Extract data from the model and use a template engine to make the actual 
 render with the data; finally, attach the result in the DOM:
  
 class MyView extends Backbone.View {
  
  
  constructor(options) {
  
  
  super(options);
  
  
  template: _.template($(""#my-template"").html());
  
  
 }
  
  
  render() {
  
    
  var data = this.model.toJSON();
  
  
  var renderedHtml = this.template(data);
  
  
  this.$el.html(renderedHtml);
  
  
  return this;
  
  
  } 
  
 }
  
 In the following code we can identify five steps to rendering the view.
  
 1. Get the template:
  
 $(""#my-template"").html()
  
 2. Compile the template:
  
 _.template($(""#my-template"").html())
  
 3. Get data from the model:
  
 var data = this.model.toJSON()
  
 4. Render the template with model data:
  
 renderedHtml = this.template(data)
  
 5. Put the result on the DOM:
  
 this.$el.html(renderedHtml)
  
 [
  25 
 ]
  
 www.it-ebooks.info",NA
CollectionView ,"Backbone Collections are composed of many models, so when rendering a collection 
 what we need is to render a list of 
 Views
 :
  
 class CollectionView extends Backbone.View {
  
  
  render() {
  
  
  // Render a view for each model in the collection
  
  var html = this.collection.map(model => {
  
    
  var view = new this.modelView(model);
  
    
  view.render();
  
    
  return view.$el;
  
  
  });
  
  // Put the rendered items in the DOM
  
  this.$el.html(html);
  
 [
  28 
 ]",NA
Adding new models ,"When a model is added to the collection an 
 add
  event is triggered; we can create an 
 event handler to update the view:
  
 class CollectionView extends Backbone.View {
  
  
  initialize() {
  
  
  this.listenTo(this.collection, 'add', this.addModel);
  
  
 }
  
  
  // ... 
  
 }
  
 When the 
 addModel
  method is called, it should create and render a new view with the 
 data of the model added and put it at the end of the list.
  
 var CollectionView = Backbone.View.extend({
  
  
  // ...
  
  // Render a model when is added to the collection 
 modelAdded(model) {
  
  var view = this.renderModel(model);
  
  this.$el.append(view.$el);
  
  }
  
  render() {
  
  // Render a view for each model in the collection 
 var html = this.collection.map(model => {
  
  
  var view = this.renderModel(model);
  
  
  return view.$el;
  
  });
  
  // Put the rendered items in the DOM
  
  this.$el.html(html);
  
  return this;
  
  }
  
  renderModel(model) {
  
  // Create a new view instance, modelView should 
 be // redefined as a subclass of Backbone.View
  
  var view = new this.modelView({model: model});
  
  // Keep track of which view belongs to a 
 model this.children[model.cid] = view;
  
  // Re-trigger all events in the children views, so that
  
 [
  30 
 ]
  
 www.it-ebooks.info",NA
Deleting models ,"When a model is removed from the collection, the view that contains that model 
 should be deleted from the DOM to reflect the current state of the collection. 
  
 Consider an event handler for the 
 removed
  event:
  
 function modelRemoved(model) {
  
  
  var view = getViewForModel(model); // Find view for this model
  
  view.destroy(); 
  
 }
  
 How can we obtain the view associated with the model? There is no easy way to do it 
 with the code that we have. To make it easy, we can keep track of model-view 
 associations; in this way, getting the view is very easy:
  
 class CollectionView extends Backbone.View {
  
  initialize() {
  
 [
  31 
 ]
  
 www.it-ebooks.info",NA
Destroying views ,"When a 
 CollectionView
  is destroyed, it should remove all children views to clean the 
 memory properly. This should be done by extending the 
 remove()
  method:
  
 class CollectionView extends Backbone.View {
  
  // ...
  
  // Close view of model when is removed from the collection 
 modelRemoved(model) {
  
  if (!model) return;
  
  var view = this.children[model.cid];
  
  this.closeChildView(view);
  
  }
  
  // ...
  
  // Called to close the collection view, should 
 close // itself and all the live childrens
  
  remove() {
  
  Backbone.View.prototype.remove.call(this);
  
  this.closeChildren();
  
  }
  
  // Close all the live childrens
  
  closeChildren() {
  
  var children = this.children || {};
  
  // Use the arrow function to bind correctly the ""this"" object 
 _.each(children, child => this.closeChildView(child));
  
  }
  
  closeChildView(view) {
  
  // Ignore if view is not 
 valid
  
  if (!view) return;
  
  // Call the remove function only if available 
 if (_.isFunction(view.remove)) {
  
  
  view.remove();
  
 [
  33 
 ]",NA
Resetting the collection ,"When a collection is wiped, the view should re-render the entire collection, because all 
 items were replaced:
  
 class CollectionView extends Backbone.View {
  
  initialize() {
  
  
  // ...
  
  this.listenTo(this.collection, 'reset', this.render); }
  
  
  // ... 
  
 }
  
 This works, but previous views should be closed too; as we saw in the previous 
 section, the best place to do it is in the render method:
  
 class CollectionView extends Backbone.View.extend({
  
  // ...
  
  render () {
  
  // Clean up any previous elements 
 rendered this.closeChildren();
  
  // Render a view for each model in the collection 
 var html = this.collection.map(model => {
  
  
  var view = this.renderModel(model);
  
  
  return view.$el;
  
  });
  
  // Put the rendered items in the DOM
  
 [
  34 
 ]
  
 www.it-ebooks.info",NA
Region,"A common use case is to swap between views in a common DOM element; this can be 
 done by using the same 
 el
  property in both views and calling the 
 render() 
 method 
 on the view you want to see. But this way doesn't clean the memory and event 
 bindings because both views will remain live in memory, even if they are not in the 
 DOM.
  
 A particularly useful scenario is when you need to switch between sub-applications, 
 because sub-applications are rendered in the same DOM element normally. For example, 
 when a user wants to edit contact information, he/she will click on an 
 Edit 
 button, and 
 the current view will be replaced with an edit form.
  
  
 Figure 2.2: Swapping views with regions
  
 [
  35 
 ]
  
 www.it-ebooks.info",NA
Layout,"A Layout is used to define structure; its intention is to create a skeleton where other 
 views will be placed. A common web application layout is composed of a header, a 
 sidebar, footer, and a common area, for example. With layouts we can define regions, in a 
 declarative way, where these elements will be placed. After the layout is rendered, we can 
 show the views we want on those views.
  
 In the following figure, we can see a layout; each of these elements is a region, so other 
 views should be created to fill the regions—for example, a HeaderView class for the 
 header region:
  
  
 Figure 2.3: A common web application layout
  
 An implementation of this example could be something like this:
  
 var AppLayout = new Layout({
  
  template: $('#app-layout').html(),
  
  regions: {
  
  header: 'header',
  
  sicebar: '#sidebar',
  
  footer: 'footer',
  
  main: '#main'
  
  }
  
 });
  
 Var layout = new AppLayout({ el: 'body' });
  
 [
  38 
 ]
  
 www.it-ebooks.info",NA
Putting it all together,"We have created four simple but powerful new views types that can be used easily on 
 projects, minimizing the effort and making less redundant code. In the next section, we 
 will convert our contacts project into a more complex project, using what we have 
 learned here:
  
  
 Figure 2.4: Application root layout
  
 Our application will have a root layout with three sections:
  
 • 
  
 Header – Will contain a navigation bar
  
 • 
  
 Footer – Copyright information
  
 • 
  
 Main – This element shows all sub-applications on demand
  
 [
  41 
 ]
  
 www.it-ebooks.info",NA
Showing a list ,"The 
 ContactList
  subapplication is responsible for rendering the collection in the 
 DOM. Thus, the 
 ContactList
  object will instantiate the necessary views:
  
 // apps/contacts/contactList.js 
  
 showList(contacts) {
  
  
  // Create the views
  
  
  var layout = new ContactListLayout();
  
  
  var actionBar = new ContactListActionBar();
  
  
  var contactList = new ContactListView({collection: contacts});
  
  // Show the views
  
  this.region.show(layout);
  
  
 layout.getRegion('actions').show(actionBar); 
 layout.getRegion('list').show(contactList);
  
  
  this.listenTo(contactList, 'item:contact:delete',
  
  this.deleteContact); 
  
 }
  
 A layout is created to put the 
 CollectionView
  inside; the layout template has a 
 div 
 with a 
 contact-list-layout
  id that will be used as the target region:
  
 // index.html 
  
 <script id=""contact-list-layout"" type=""text/template"">
  
  
  <div class=""actions-bar-container""></div>
  
  
  <div class=""list-container""></div>
  
  
  <div class=""footer text-muted"">
  
  
  © 2015. <a href=""#"">Mastering Backbone.js</a> by <a href=""https:// 
 twitter.com/abieealejandro"" target=""_blank"">Abiee Alejandro</a>
  
  
  </div> 
  
 </script>
  
 [
  43 
 ]",NA
Showing the details ,"The contact details show a read-only version of a single contact; here you can see all 
 the details of a given contact but no edition. The following screenshots shows how it 
 looks:
  
  
 Figure 2.5: Contact details
  
 To show a read-only version of a contact, we need to first define a layout:
  
 <script id=""contact-view-layout"" type=""text/template"">
  
  
  <div class=""row page-container"">
  
  
  <div id=""contact-widget""
  
    
  class=""col-xs-12 col-sm-4 col-md-3""></div>
  
  
  <div class=""col-xs-12 col-sm-8 col-md-9"">
  
    
  <div class=""row"">
  
     
  <div id=""about-container""></div>
  
     
  <div id=""call-log-container""></div>
  
    
  </div>
  
  
  </div>
  
  
  </div>
  
  
  <div class=""footer text-muted"">
  
  
  © 2015. <a href=""#"">Mastering Backbone.js</a> by <a href=""https:// 
 twitter.com/abieealejandro"" target=""_blank"">Abiee Alejandro</a>
  
  
  </div> 
  
 </script>
  
 [
  48 
 ]
  
 www.it-ebooks.info",NA
Editing information ,"Figure 2.6 shows how the edit form for the contacts should looks. The form view 
 should be able to grab information from the input boxes and update the Contact 
 model passed to it.
  
 A layout template should be created here to separate the widget at the left from the 
 form view at the right:
  
 <script id=""contact-form-layout"" 
 type=""text/template"">
  
  <div id=""preview-container""
  
  
  class=""col-xs-12 col-sm-4 col-md-3""></div>
  
  
  <div id=""form-container""
  
  
  class=""col-xs-12 col-sm-8 col-md-9""></div>
  
  
  <div class=""footer text-muted"">
  
  
  © 2015. <a href=""#"">Mastering Backbone.js</a> by <a href=""http:// 
 themeforest.net/user/Kopyov"" target=""_blank"">Abiee Alejandro</a>
  
  
 </div> 
  
 </script>
  
 [
  50 
 ]
  
 www.it-ebooks.info",NA
Rendering third-party plugins ,"A common issue when rendering views is not rendering plugins from others because they 
 are designed to work with traditional web applications but not with SPA; this is because 
 many plugins are DOM-dependent, which means that the target element should exist in 
 the actual DOM. To see this issue more clearly, let me show you an example with the 
 jQueryUI Calendar plugin. Let's add a 
 birthdate
  field to our 
 ContactEditor
 , replacing 
 the age field.
  
 // index.html 
  
 // ...
  
 <div class=""form-group"">
  
  
  <label for=""birthdate"">Birth date</label>
  
  
  <input id=""birthdate "" type=""text""
  
  
  class=""form-control"" value=""<%= birthdate %>"" /> 
 //...
  
 And make the proper changes in the view:
  
 class ContactForm extends ModelView {
  
  
  // ...
  
  serializeData() {
  
  return _.defaults(this.model.toJSON(), {
  
  
  name: '',
  
  
  birthdate: '',
  
  
  // ...
  
  });
  
  },
  
  saveContact(event) {
  
  event.preventDefault();
  
  this.model.set('name', this.$el.find('#name').val()); 
 this.model.set('birthdate',
  
  
  this.$el.find('#birthdate').val()
  
  );
  
  // ...
  
  
  }, 
  
 // 
 ...
  
 });
  
 [
  55 
 ]",NA
Conclusions ,"We started by creating common view types that are common for almost every 
 project. Those views are simple in principle but powerful; we can effectively 
 manage nested views without worrying about insufficient memory.
  
 We learned that, by encapsulating common patterns in the 
 render()
  method, we can 
 create useful view types; in this chapter, we have seen four of them but if you are curious I 
 encourage you to take a look at the Marionette framework, which works on top of 
 Backbone.
  
 Marionette includes all the views exposed here: 
 ItemView
 , 
 CollectionView
 , 
 LayoutView
 , Regions. and other useful view types. Marionette objects behave very 
 similarly to what we see here, so that you can easily interchange Marionette objects 
 with those described in this chapter.
  
 [
  58 
 ]
  
 www.it-ebooks.info",NA
Model Bindings,"Keeping models in sync with other objects such as views can be challenging, and if it is not 
 done correctly, it can lead to messy code. In this chapter, we will explore how to deal with 
 data synchronization to make data binding easier. But, what is data binding? Wikipedia 
 defines data binding as:
  
 Data binding is the process that establishes a connection between the application 
 UI (User Interface) and business logic. If the settings and notifications are 
 correctly set, the data reflects changes when made. It can also mean that when the 
 UI is changed, the underlying data will reflect that change.
  
 A common issue with model binding is how to deal with complex model structures that 
 include other embedded objects or lists; in this chapter, we will define a strategy to deal 
 with these scenarios. A missing feature in Backbone is two-way binding; in the next 
 sections, we will see how to implement this without a headache.
  
 Let's start the chapter describing how to bind model data with views manually to see how 
 Backbone works; after that, we can use Backbone.Stickit to make it much easier. After 
 learning how to sync model data and views, we will explore how to perform validations 
 on the models and how to display error messages.",NA
Manual binding,"To make it simple, imagine that we have a form with a simple layout: name, phone, and 
 an email address:
  
 <script id=""form-template"" type=""text/template"">
  
 <form>
  
 <div class=""form-group"">
  
 <label for=""name"">Name</label>
  
 <input id=""name"" class=""form-control"" type=""text""
  
 value=""<%= name %>"" />
  
 [
  61 
 ]
  
 www.it-ebooks.info",NA
Two-way binding,"Angular.js
  has been popularized as two-way data binding in the frontend; the idea 
 behind two-way data binding is to keep views and models in sync. When you make a 
 change in an input field the view the model should be updated immediately, and if you 
 change a property in the model the view should show the current value immediately:
  
  
 Figure 3.1 Two-way data binding with Backbone
  
 Backbone does not provide a mechanism to achieve this easily; however, we can do it 
 using the event system that Backbone models provide. Figure 3.1 shows how you can 
 make an implementation.
  
 Backbone.View
  listens for 
 keyup
  and 
 change
  events on input controls at the DOM; 
 when a change is triggered from the DOM, 
 Backbone.View
  can extract the new value 
 from the input and set the Model:
  
 class FormView extends ModelView {
  
  // ...
  
  events() {
  
 [
  64 
 ]
  
 www.it-ebooks.info",NA
References ,"Refer to the following URLs for more information:
  
 • 
  
 Why you should not use AngularJS: 
 http://bit.ly/1Mue1kC
  
 • 
  
 AngularJS Antipatterns and Pitfalls: 
 http://bit.ly/1kTHKqS
  
 • 
  
 What's wrong with Angular 1: 
 http://bit.ly/1N9wHok",NA
Data binding with plugins ,"As you can see in the previous section, Backbone does not provide an easy mechanism 
 to sync your models and the views that use them. Some plugins for Backbone have been 
 developed to minimize this issue; one of them is 
 Backbone.Stickit
 .
  
 If you want an easy and yet powerful way to bind DOM nodes and Backbone 
 models, 
 Backbone.Stickit
  will do a great job:
  
 var FormView = ModelView.extend({ 
  
 template: '#form-template',
  
  
  bindings: {
  
  
  '#name': 'name',
  
  
  '#phone': 'phone',
  
  
  '#email': 'email'
  
  
  },
  
  
  onRender: function() {
  
  
  this.stickit();
  
  
  } 
  
 });
  
 The preceding code example shows how it looks; please consult the project 
 documentation to learn more about it.
  
 [
  67 
 ]
  
 www.it-ebooks.info",NA
Binding embedded data ,"One of the most common issues with Backbone is how to deal with complex 
 model data:
  
 { 
  
 ""name"": ""John Doe"", 
  
 ""address"": { 
  
 ""street"": ""Seleme"", 
  
 ""number"": ""1975 int 6"", 
  
 ""city"": ""Culiacán""
  
  
  }, 
  
 ""phones"": [{ 
  
 ""label"": ""Home"", 
  
 ""number"": ""55 555 123""
  
  
  }, { 
  
 ""label"": ""Office"", 
  
 ""number"": ""55 555 234""
  
  
  }], 
  
 ""emails"": [{ 
  
 ""label"": ""Work"", 
  
 ""email"": ""john.doe@example.com""
  
  
  }] 
  
 }
  
 It could be easy to render a read-only view for this model data; however, the real 
 challenge is how to bind form actions with embedded arrays. In Backbone, it is difficult to 
 use the event system on array objects; if you push a new item in the list, no event will be 
 triggered. This makes it difficult to keep model data in sync with the a view that edits its 
 contents.
  
 [
  68 
 ]
  
 www.it-ebooks.info",NA
Binding an embedded list,"Imagine that our Contacts App will now allow us to add more than one phone and 
 email. We will need to change the edit form view to add support for adding, 
 removing, and modifying items on the array of phones and emails:
  
  
 Figure 3.3. Contact form layout with phone and email lists
  
 Figure 3.3 shows the result of adding a 
 New
  button to allow the user to dynamically add 
 the number of phones and emails he/she wants. Each item in the list should include a 
 Delete
  button too to allow the user to remove them.
  
 [
  69 
 ]
  
 www.it-ebooks.info",NA
Validating model data,"Usually, on frontend applications, the inputs are validated with UI plugins such as 
 jQuery Validation, which focuses on the user interface. In other words, the data is 
 validated directly on the DOM. However, on bigger applications that would not be the 
 best approach.
  
 Validations in Backbone can be done manually or through plugins. Of course, the best 
 approach is to use a plugin because it saves time and effort, but before we learn how to 
 use the 
 backbone.validation
  plugin, I want to show you how native validation works.",NA
Manual validation,"Backbone models have three properties to help us validate the model data: 
 validate()
 , 
 validationError()
 , and
  isValid()
 . The 
 validate()
 method 
 should return nothing if the model data is correct, or a value otherwise.
  
 Backbone leaves open what should be returned by the 
 validate()
  method, so you 
 can return just a plain string message or a complex object:
  
 class Chapter extends Backbone.Model{
  
  validate(attrs, options) {
  
  if (attrs.end < attrs.start) {
  
  return ""can't end before it starts"";
  
  }
  
  }
  
 }
  
 You can call the 
 isValid()
  method to ensure that your model has a valid state; 
 internally, Backbone will call the 
 validate()
  method and will return a Boolean value 
 depending on the returned value: 
 true
  if 
 validate()
  returns nothing, 
 false 
 if it 
 returns something.
  
 With 
 validationError
 , you can get the latest validation error in the model—for 
 example:
  
 var one = new Chapter({
  
  title : ""Chapter One: The Beginning"",
  
  start: 15,
  
  end: 10
  
 });
  
 If (!one.isValid()) {
  
  alert(one.validationError);
  
 }
  
 [
  79 
 ]
  
 www.it-ebooks.info",NA
Validating with the Backbone.Validation ,NA,NA
plugin ,"Backbone.Validation
  simplifies the validation process, allowing us to write 
 validation rules in a declarative way instead of programmatically. Also, it comes with 
 built-in validation rules that you can use out-of-the-box. When using 
 Backbone.
  
 Validation
 , the way you validate models is simplified, as we will show next.
  
 To start with 
 Backbone.Validation
 , install the plugin after including Backbone.
  
 <script src=""js/vendor/backbone.js""></script> 
  
 <script src=""js/vendor/backbone-validation.js""></script>
  
 Now we can use the plugin; 
 Backbone.Validation
  uses a validation property in the 
 models to specify validation rules:
  
 class Contactextends Backbone.Model { 
  
 get validation: {
  
  
  name: {
  
    
  required: true,
  
    
  minLength: 3
  
  
  }
  
  
  } 
  
 }
  
 Instead of using the 
 validate()
  method, you can write the validation rules in a 
 configuration object, where the keys of the object are the name of the fields in the 
 model; in this case, we are validating the 
 name
  field. The 
 required
  and 
 minLength 
 validation rules are applied to the 
 name
  field by 
 Backbone.Validation
 .
  
 Now that the 
 Contact
  model has the validation configuration, we need to override the 
 default 
 validate()
  method in the Backbone model to activate the 
 Backbone. 
 Validation
  plugin. To do it, we need to call the 
 Backbone.Validation.bind() 
 method in the 
 onRender()
  method:
  
 class ContactForm extends Layout 
 { 
  
 // ...
  
  onRender() {
  
  Backbone.Validation.bind(this);
  
  }
  
  
  // 
 …
  
 });
  
 [
  82 
 ]",NA
Summary,"In this chapter, we learned how to keep models and views in sync. In general, 
 syncing model and views is easy but things can turn difficult if the model has 
 embedded arrays. You can use a plugin to simplify the data binding; 
 Backbone.
  
 Stickit
  is a good option because it allows you to make your bindings in a 
 declarative way.
  
 I showed you how you can make two-way data binding with a vanilla Backbone, 
 taking advantage of the event system; it's not always a good idea to use intensive 
 two-way data binding in your applications but in some cases it can be useful.
  
 Finally, we learned how to validate models with Backbone and how to use the validation 
 API to show error messages in views. The 
 Backbone.Validation
  plugin can help you to 
 validate Backbone models easily with minimal effort, once validation callbacks are set 
 correctly.
  
 In the next chapter, we will learn how to modularize our contacts application to 
 make it more maintainable and more effectively manage dependencies. Then we will 
 bundle the whole application in a single script to load it faster.
  
 [
  85 
 ]
  
 www.it-ebooks.info",NA
Modular Code,"As your project's code grows, the number of scripts in the project will be more and 
 more, incrementing script-loading complexity. The classic way to load JavaScript files is 
 to write a
 <script>
  tags for every script you have, but you have to do it in the right 
 order; if you don't, your code could stop working. That's not an efficient way for 
 medium-size projects.
  
 What happens if you forget the order of loading? What if you make a refactorization on 
 the code and the order of the script changes? It will be a pain to fix it and keep track of 
 all the code and its dependencies.
  
 This problem has been addressed in different ways. One is to create a module syntax to 
 create, load, and declare explicitly the dependencies of modules; the syntax is called 
 AMD
  
 (
 Asynchronous Module Definition
 ). The AMD modules define a list of module 
 dependencies, and the code inside the module will be executed only after the 
 dependencies are fully loaded.
  
 The dependencies are loaded asynchronously; that means that you don't need to load all 
 the scripts in the HTML page through 
 <script>
  tags. AMD modules are better than plain 
 JavaScript because they define dependencies explicitly and can be loaded automatically.
  
 Although AMD modules are better than 
 <script>
  tags, working with AMD 
  
 modules can be a pain when unit testing comes in because you need to know the 
 intricacies of how the library loads the modules; when you want to do unit testing, you 
 need to isolate the pieces of code under test, but is hard to do it in RequireJS, and even if 
 you do it the result can be buggy.
  
 Recently another module loader and dependency manager has arrived; Browserify 
 seems to be the most popular at the moment. However, it is not the only one; there are 
 many other potentially strong choices such as jspm and steal.js.
  
 [
  87 
 ]
  
 www.it-ebooks.info",NA
CommonJS modules,"In recent years, Node has been gaining popularity in the software industry; indeed it is 
 becoming a very popular choice for backend development in a full JavaScript technology 
 stack. If you don't know about Node, you can think about it as JavaScript used in the 
 server instead of a browser.
  
 Node uses the CommonJS module syntax for its modules; a CommonJS module is a file that 
 exports a single value to be used for other modules. It is useful to use CommonJS because 
 it provides a clean way to manage JavaScript modules and dependencies.
  
 To support CommonJS, Node uses the 
 require()
  function. With 
 require()
  you can load 
 JavaScript files without the need to use 
 <script>
  tags, instead calling 
 require()
  with 
 the name of the module/dependency that you need and assigning it to a variable.
  
 To illustrate how CommonJS modules work, let's write a Node module and see how to 
 use the 
 require()
  function. The following code shows a simple module that exposes a 
 simple object with the method 
 sayHello()
 :
  
 hello = {
  
  sayHello(name) {
  
  name = name || 'world';
  
  console.log('hello', name);
  
  }
  
 }
  
 module.exports = hello;
  
 This script can be placed in a file named 
 hello.js
 , for example. The hello module can 
 be loaded from another module by calling the 
 require()
  function, as shown in the 
 following code:
  
 var hello = require('./hello');
  
 hello.sayHello('world); // prints ""hello world""
  
 [
  88 
 ]
  
 www.it-ebooks.info",NA
NPM and package.json,"With Browserify, we can create CommonJS modules that can be executed in the 
 browser. When you use CommonJS modules in the browser, Browserify will provide 
 the necessary tools to load the modules, which includes a definition for the 
 require()
  
 function.
  
 When you use Browserify, you can use the Node package manager to install and define 
 dependencies for your projects. A useful tool is the npm command tool, used to install 
 and manage project dependencies.
  
 The 
 package.json
  file in a Node project is a JSON file used to define, install, and manage 
 the version of the libraries that your project depends on. A 
 package.json 
 file can 
 contain many configuration options; you can see the complete documentation on the 
 Node website at 
 https://docs.npmjs.com/
 . Here is a list of the main values.
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Name
  – The name of the project without spaces 
  
 Description
  – A short description of the project 
  
 Version
  – A version number for the project, typically starting with 0.0.1 
 Dependencies
  – A list of libraries with the version number that the project 
 depends on 
  
 devDependencies
  – Same as dependencies, but this list is used only for 
 development environments—useful for putting libraries for testing, for instance 
 licence
  – A license name for the project code
  
 [
  89 
 ]
  
 www.it-ebooks.info",NA
Browserify ,"With Browserify we can use Node modules directly in the browser. This means that you 
 can build your projects with the power of the npm package manager and the Node 
 module syntax exposed in the previous sections. Then Browserify can take your source 
 code and apply some transformations to be able to run your code in the browser 
 environment.
  
 A very simple module that exposes an object with a method that prints a hello 
 message can be written as a Node module:
  
 // hello.js 
  
 module.exports = {
  
  
  sayHello: function(name) {
  
  
  name = name || 'world';
  
  
  console.log('hello', name);
  
  
  } 
  
 }
  
 This simple piece of code can be loaded from another script as shown next:
  
 // main.js 
  
 var hello = require('./hello'); 
  
 hello.sayHello();        // hello world 
  
 hello.sayHello('abiee'); // hello abiee
  
 This code works perfectly with Node. You can run it as follows:
  
 $ node main.js
  
 However this code will not run in the browser because the 
 require
  function and the 
 module object are not defined. Browserify takes your project entry code and tracks all 
 the dependencies to create a single file with all the scripts concatenated:
  
 $ browserify main.js 
  
 (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof 
 require==""function""&&require;if(!u&&a)return a(o,!0);if(i)return 
 i(o,!0);var f=new Error(""Cannot find module '""+o+""'"");throw 
  
 f.code=""MODULE_NOT_FOUND"",f}var l=n[o]={exports:{}};t[o][0].
  
 call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l. 
 exports,e,t,n,r)}return n[o].exports}var i=typeof 
 require==""function""& &require;for(var 
 o=0;o<r.length;o++)s(r[o]);return s})({1:[function(re 
 quire,module,exports){ 
  
 module.exports = {
  
  
  sayHello: function(name) {
  
  
  name = name || 'world';
  
  
  console.log('hello', name);
  
 [
  91 
 ]",NA
Application dependency,"When the application is loaded in the browser, it loads all the JavaScript files in 
 a specific order. The order is important because it represents the chain of 
 dependencies.
  
 <script src=""js/vendor/jquery-2.1.4.min.js""></script>
  
 <script src=""js/vendor/bootstrap.min.js""></script>
  
 <script src=""js/vendor/sweetalert.min.js""></script>
  
 <script src=""js/vendor/jquery.noty.packaged.min.js""></script>
  
 [
  92 
 ]
  
 www.it-ebooks.info",NA
Using Browserify in the app ,"Until now we have learned about what Browserify is and how to use it. Now we will apply 
 that background to our contacts app to load all the code as Node modules.
  
 Before we continue, ensure that you have installed all the required dependencies for the 
 project:
  
 {
  
  ""name"": ""mastering-backbone-
 04"",
  
  // ...
  
  ""dependencies"": {
  
  ""backbone"": ""^1.2.3"",
  
  ""backbone-validation"": ""^0.11.5"",
  
  ""body-parser"": ""^1.14.1"",
  
  ""bootstrap"": ""^3.3.5"",
  
 [
  94 
 ]",NA
Solving cyclic dependency,"Having two modules that depend on each other is called 
 cyclic dependency
 . In our 
 Contacts application, the infrastructure application depends on the subapplication 
 routers, and the routers depend on the application infrastructure to load the 
 subapplication controllers and facades. Figure 4.4 shows how this looks.
  
  
 Figure 4.4 Cyclic dependencies
  
 It is not possible to run the application properly because of the cyclic dependency. 
 Here is what happens in detail.
  
 • 
  
 The App module is executed
  
 • 
  
 The App requires 
 ContactsRouter
 :
  
 var ContactsRouter = require('./apps/contacts/router');
  
 • 
  
 ContactsRouter
  requires the App module but the App module is not 
 exported yet:
  
 var App = require('../../app'); // returns undefined
  
 • 
  
 ContactsRouter
  receives an 
 undefined
  value for the App variable
  
 • 
  
 The App module continue the execution and finally exposes the App value:
  
 var App = {
  
  // ...
  
 };
  
 module.exports = App;
  
 [
  100 
 ]
  
 www.it-ebooks.info",NA
Modularizing templates ,"Until now, templates have been declared as script tags in the 
 index.html
  file. 
 While this is a good approach for small projects, it is not a good idea to put all 
 your templates directly in the HTML file.
  
 With Browserify, you can extract all your template files into individual files, with the 
 advantage of modularization and a cleaner 
 index.html
  file. Another benefit of 
 modularizing templates is that you can pre-compile all the templates, saving 
 resources in your users' browsers.
  
 [
  101 
 ]
  
 www.it-ebooks.info",NA
Summary,"In this chapter, we have learned what Browserify is and how you can organize your 
 projects into Node modules to manage your code and dependencies in a cleaner way. To 
 make the Contacts project compatible with 
 npm
 , we had to alter the code of the project; 
 however, the changes are minimal.
  
 There are other alternatives to Browserify, too; require.js and the AMD module 
 definition are good to work with. However testing with require.js could be very 
 difficult; I don't recommend you use 
 require.js
  if you want to test isolated 
 modules (unit testing).
  
 Webpack is another popular choice to bundle and organize your code base. Its main 
 purpose is to work with frontend dependencies; it can load CommonJS modules and 
 AMD modules. However, webpack is more complicated to configure and manage.
  
 Browserify is the most popular choice for bundling JavaScript projects and is easier to 
 configure and maintain than webpack; it is useful to use the same tools that Node uses 
 to manage its dependencies and it does a great job.
  
 In the next chapter, we will explore how to deal with files in a Backbone project; 
 handling files over a RESTful API is a common issue, so we will discover what the 
 common patterns and strategies are.
  
 In Chapter 7, we will explore how to build applications with automation tools; 
 instead of manually running the Browserify command each time we change the 
 code, we will create the necessary scripts that will do it for us.
  
 [
  104 
 ]
  
 www.it-ebooks.info",NA
Dealing with Files,"When you are building a Backbone application you will consume resources from a 
 RESTful web service; however most of the RESTful services use the JSON format to 
 encode information, but JSON is not suitable to send and receive files. How we can 
 send files to a RESTful server?
  
 If you are developing an application that is not JavaScript–intensive, you can send files 
 through an HTML form, but in 
 Single Page Applications
  (
 SPA
 ) this is not the best way 
 to do it. Another issue is that Backbone does not provide an easy mechanism to send 
 files because it is not compatible with the RESTful specification.
  
 But web applications need to work with files. There are some approaches to deal 
 with this common issue. For example, you could use a traditional POST form on 
 resources where files may be included; however, that's not a good option. In this 
 chapter you will learn the following:
  
 • 
  
 Handle file uploads from an Express server
  
 • 
  
 Adopt strategies to send files to a RESTful server
  
 • 
  
 Upload files
  
 • 
  
 Create a resource that includes a file in it
  
 We will start by adding support for uploading files to an Express server because it is 
 important to know how a server can respond to upload requests.",NA
Express server,"To demonstrate how to send files to a server, in this chapter we will work with the latest 
 version of Express (the latest version available at the time of writing is Express 4.x). The 
 server will be responsible for storing the REST resources and handling file uploads. 
 Please consult the GitHub repo for this book to get the implementation of the server for 
 the previous chapters.
  
 [
  105 
 ]
  
 www.it-ebooks.info",NA
Attaching a file into a resource,"Before we start receiving files in the Express server, we need to set up a strategy 
 for that. We still want to use the RESTful services, so changing the format of the 
 transmission data is not an option.
  
 Respecting the RESTful standard (for more on the REST design for file uploads, see 
 http://bit.ly/1GXqPNY
 ), we can attach a subresource endpoint under the target 
 resource to handle the uploads, so that it will not disturb the original resource. However, 
 this approach has a limitation: the resource should exist first, which means that you 
 cannot create a contact and its avatar photo at the same time.
  
 Following this approach, the endpoint for the avatar file uploading can be located at:
  
 http://example.com/api/contacts/10/avatar
  
 [
  106 
 ]
  
 www.it-ebooks.info",NA
Uploading the avatar photo to contacts ,"Let's start by creating the endpoint to upload avatar photos:
  
 // routes.js 
  
 var controller = require('./controller');
  
 //...
  
 server.post('/api/contacts/:contactId/avatar', 
 controller.uploadAvatar);
  
 Express itself does not process files automatically; it needs a plug-in that transforms the 
 raw request into a more user-friendly API. This plug-in is named 
 multer
 ; it processes 
 multipart/form-data
 , saving the file into a temporary path or making a buffer object, 
 and then provides a JSON object with metadata information:
  
 // Avatar endpoints 
  
 var upload = multer(); 
  
 server.post('/api/contacts/:contactId/avatar', 
 upload.
  
 single('avatar'), 
  
 controller.uploadAvatar 
  
 ); 
  
 server.use('/avatar', express.static(__dirname + '/avatar'));
  
 [
  108 
 ]
  
 www.it-ebooks.info",NA
Showing the avatar ,"Now that we can upload images and the contact resource has the information about 
 where the avatar is located, we can show the avatar in our views by pointing an 
 img 
 tag 
 to the 
 avatar.url
  property in the 
 Contact
  model:
  
 <% if (avatar && avatar.url) { %> 
  
 <imgsrc=""<%= avatar.url %>"" alt=""Contact photo"" /> 
  
 <% } else { %> 
  
 <imgsrc=""http://placehold.it/250x250"" alt=""Contact photo"" /> 
 <% } %>
  
 This will show the image, if any; otherwise it will show a default one. We should 
 modify the Contact model to include a default avatar:
  
 // 
 apps/contacts/models/contact.js 
  
 'use strict';
  
 var Backbone = require('backbone');
  
 class Contact extends Backbone.Model 
 { 
  
 // ...
  
  
  get defaults() {
  
  
  return {
  
    
  name: '',
  
    
  phone: '',
  
    
  email: '',
  
    
  address1: '',
  
    
  address2: '', 
  
 facebook: '',
  
    
  twitter: '',
  
    
  google: '', 
  
 github: '',
  
    
  avatar: null
  
  
  };
  
  
  }
  
 // 
 ... 
  
 }
  
 module.exports = Contact;
  
 [
  111 
 ]",NA
Uploading images from Backbone ,"To allow us to upload files from our Backbone application, we should create an input file 
 to be able to show a 
 Choose
  file dialog. This could be done in the 
 ContactEditor 
 sub-
 application by changing the 
 ContactPreview
  class to add this functionality. So let's 
 change the current template and add the input:
  
 <div class=""box thumbnail""> 
  
 <div class=""photo""> 
  
 <% if (avatar && avatar.url) { %> 
  
 <imgsrc=""<%= avatar.url %>"" alt=""Contact photo"" /> 
  
 <% } else { %> 
  
 <imgsrc=""http://placehold.it/250x250"" alt=""Contact photo"" /> 
 <% } %> 
  
 <input id=""avatar"" name=""avatar"" type=""file"" 
  
 style=""display: none"" /> 
  
 </div> 
  
 <!-- ... --> 
  
 </div>
  
 [
  112 
 ]
  
 www.it-ebooks.info",NA
Uploading a file with AJAX ,"The 
 Client
  model receive the blob object, builds the URL to the 
 avatar
  endpoint, and 
 makes the appropriate calls to the callback objects:
  
 // apps/contacts/models/contact.js 
  
 class Contact extends Backbone.Model 
 {
  
  
  // ...
  
 uploadAvatar(imageBlob, options) {
  
  // Create a form object to emulate a multipart/form-data 
 varformData = new FormData(); 
  
 formData.append('avatar', imageBlob);
  
 varajaxOptions = { 
  
 url: '/api/contacts/' + this.get('id') + '/avatar',
  
  
  type: 'POST',
  
  
  
  data: formData,
  
  
  
  cache: false, 
  
 contentType: false, 
  
 processData: false
  
  };
  
  options = options || {};
  
  // Copy options to ajaxOptions 
  
 _.extend(ajaxOptions, _.pick(options, 'success', 'error'));
  
  // Attach a progress handler only if is defined if 
 (options.progress) { 
  
 ajaxOptions.xhr = function() { 
  
 varxhr = $.ajaxSettings.xhr();
  
  
  if (xhr.upload) {
  
  
  // For handling the progress of the upload 
 xhr.upload.addEventListener('progress', event => {
  
   
  let length = event.total;
  
  
   
  let uploaded = event.loaded;
  
  
   
  let percent = uploaded / length;
  
 options.progress(length, uploaded, percent);
  
  }, false);
  
  
  }
  
  return xhr;
  
 [
  118 
 ]",NA
Uploading the avatar image at creation ,NA,NA
time,"As we have seen so far, to upload and attach a file to a resource, it must already exist. How 
 we can create a resource with a file attached? How can we create a contact that includes 
 an avatar image?
  
 [
  119 
 ]
  
 www.it-ebooks.info",NA
Encoding the upload file ,"Another approach to uploading files is to encode the file into 
 base64
 . When you 
 encode a binary file to 
 base64
 , the result is a string that we can use as an attribute in 
 the request object.
  
 Though it can be useful to create objects with the file attached in the resource, or to 
 use it as another resource in the server, this is not a recommended approach. This 
 approach has some limitations:
  
 • 
  
 • 
  
 • 
  
 If the backend server is a node, the thread will be locked until the server 
 decodes the 
 base64
  string. This will lead to a low-performance app. You 
 cannot upload large amounts of data.
  
 If the file is large, the Backbone application will freeze until the file is 
 encoded to 
 base64
 .
  
 If you are uploading very small amounts of data and don't have a huge amount of traffic, 
 you can use this technique; otherwise, I encourage you to avoid it. Instead of uploading 
 the file we can encode it:
  
 class ContactEditor {
  
  
  // ...
  
 showEditor(contact) {
  
  
  // ...
  
 this.listenTo(contactPreview, 'avatar:selected', blob => 
 { this.setAvatar(contact, blob);
  
  });
  
 [
  123 
 ]
  
 www.it-ebooks.info",NA
Summary,"In this chapter, we have seen how to upload files to the server; this is not the only way to 
 do it, but is the more extended and flexible approach. Another possible method is to 
 serialize the image into 
 base64
  in the browser, then set the output string as an attribute 
 in the model; when ten models are saved, the file encoded in 
 base64
  will be part of the 
 payload. The server should decode the string and process the result as a file.
  
 We saw how to decouple the view from the business logic. The view should only process 
 DOM events and trigger business logic level events; then a controller can deal with blob 
 objects instead of low-level DOM nodes. This approach helped us to move upload 
 processing from the view to the model, which is the ideal way to do it.
  
 Finally, we dealt with the creation process; we cannot create a resource and attach 
 files at the same time. We should first create the resource and then send all the files to 
 the server as needed.
  
 In the next chapter, you will learn how to store information directly in the browser. 
 Instead of using a RESTful server, it might be nice to run standalone web applications 
 that don't need a server to run.
  
 [
  124 
 ]
  
 www.it-ebooks.info",NA
Store data in the Browser,"Backbone was mainly designed to work with RESTful API servers; however, you 
 don't want to always store the data in a server for offline applications or to bust 
 application loading storing cache data in the browser.
  
 We have two choices to store data in the user browser: use localStorage or the new 
 IndexedDB API. While localStorage has wide support on major browsers, IndexedDB is 
 the new specification that is yet to be supported in the near future. Another option that is 
 available currently; however, in deprecated status is Web SQL. If you are developing 
 modern web applications, you should avoid using Web SQL.
  
 In this chapter, you will learn the following topics:
  
 • 
  
 Basics of localStorage
  
 • 
  
 Basics of IndexedDB
  
 • 
  
 Using localStorage instead of a RESTful server to store information
  
 • 
  
 Using IndexedDB instead of a RESTful server to store information
  
 [
  125 
 ]
  
 www.it-ebooks.info",NA
The localStorage,"The localStorage is the simplest and the most supported browser data store. At the 
 moment of writing this book, it is supported in almost all the major browsers. As 
 shown in the figure below, the only browser that does not support localStorage is 
 Opera Mini:
  
  
 Figure 6.1 Browser support of localStorage
  
 The localStorage is a simple key/value database that is able to only store text. In 
 localStorage, you have three main methods to access the data: 
 setItem()
 , 
 getItem()
 ,and 
 removeItem()
 . With these three functions, you can manage the 
 data in the store pretty well.
  
 The downside of localStorage is that it does not have tables or collections, therefore, all 
 the data is mixed; another issue with localStorage is that it is limited to 5 Mb of 
 information. If your storage requirements are bigger than that, you will need 
 IndexedDB.",NA
Starting with localStorage,"To store the data in the localStorage store, you need to call the 
 setItem()
  method in 
 the 
 localStorage
  global object:
  
 localStorage.setItem('myKey', 'myValue');
  
 localStorage.setItem('name', 'John Doe');
  
 [
  126 
 ]
  
 www.it-ebooks.info",NA
Backbone and localStorage,"To store Backbone models in localStorage, you can use the 
 ID
  attribute as key and the 
 serialized data as the value. However, remember that all the data in localStorage is mixed 
 and this strategy will lead to identifier collisions.
  
 Consider that you have two different models (contacts and invoices) with the same 
 ID
 ; 
 when you store one of them in the localStorage, it will overwrite the other.
  
 Another issue with localStorage is that when you want to retrieve data from the store 
 before getting an item from the store, you need to know which key does it have. However, 
 in localStorage, we don't have a clue about what IDs are currently in the store, therefore, 
 we need a way to keep track of the IDs that are in the store at a given time.
  
 [
  128 
 ]
  
 www.it-ebooks.info",NA
Store models in localStorage ,"Now that you know how to store and retrieve data from localStorage, it's time to store 
 your models. In the following figure, you can see how to make data storage in local 
 instead of a remote server.
  
 By default, when you call the 
 save()
  method on a model Backbone, it transforms the 
 action into an HTTP request for a RESTFul server. To store the data in local, you need to 
 change the default behavior in order to use localStorage instead of making HTTP 
 requests; you will learn how to do this in the next section.
  
 [
  129 
 ]
  
 www.it-ebooks.info",NA
Store Backbone models in localStorage ,"It's time to use what you have learned about 
 localStorage
  to store and retrieve 
 objects. The 
 DataStore
  object is responsible to transform models into strings to be 
 stored in localStorage:
  
 class DataStore {
  
  
  constructor(name) {
  
  
  this.name = name;
  
  
  // Keep track of all ids stored for a particular collection 
 this.index = this.getIndex();
  
  
  }
  
 getIndex() { 
  
 var index = localStorage.getItem(this.name);
  
  return (index &&index.split(',')) || [];
  
  
 } 
  
 }
  
 The DataStore object needs a name to be used as a collection index prefix. The first use 
 case is to create a new item:
  
 class DataStore { 
  
 // ...
  
  
  create(model) {
  
  
  // Assign an id to new models
  
  
  if (!model.id&& model.id !== 0) {
  
    
  model.id = generateId(); 
  
 model.set(model.idAttribute, model.id);
  
  
  }
  
  // Save model in the store with an unique name, // 
 e.g. collectionName-modelId 
  
 localStorage.setItem( 
  
 this.itemName(model.id), this.serialize(model) );
  
  // Keep track of stored id 
  
 this.index.push(model.get(model.idAttribute))
 ; this.updateIndex();
  
  
  // Return stored model
  
  
  return this.find(model);
  
  
  } 
  
 }
  
 [
  131 
 ]
  
 www.it-ebooks.info",NA
Backbone.sync ,"This is responsible to handle connections between a RESTful server and the 
 Backbone application is the Backbone.sync module. It transforms the 
 fetch() 
 and 
 save()
  operations into HTTP requests:
  
 • 
  
 • 
  
 • 
  
 fetch()
  is mapped as a 
 read
  operation. This will make 
 GET
  to the the 
 urlRoot
  attribute with the model ID for a model or the 
 url
  attribute for a 
 collection.
  
 save()
  is mapped as a 
 create
  or 
 update
  operation; it depends on the 
 isNew()
  method:
  
 °
  
 This will be mapped as 
 create
  if the model does not have an ID 
  
 (
 isNew()
  method return 
 true
 ). A POST request is executed.
  
 °
  
 This will be mapped as 
 update
  if the model already has an ID 
  
 (
 isNew()
  method returns 
 false
 ). A PUT request is executed.
  
 destroy()
  is mapped as a 
 delete
  operation. This will make DELETE to the the 
 urlRoot
  attribute with the model ID for a model or the 
 url
  attribute for a 
 collection.
  
 To better understand how Backbone.sync does its job, consider the following examples:
  
 // read operation will issue a GET 
 /contacts/1 varjohn= new Contact({id: 1}); 
  
 john.fetch();
  
 // update operation will issue a PUT /contacts/1 
 john.set('name', 'Johnson'); 
  
 john.save();
  
 // delete operation will issue a DELETE /contacts/1 
 john.destroy(); 
  
 varjane = new Contact({name: 'Jane'}); 
  
 // create operation will issue a POST /contacts 
 jane.save();
  
 [
  135 
 ]
  
 www.it-ebooks.info",NA
Using localStorage as cache ,"The Datastore driver is useful to develop small applications that do not need to 
 fetch and store the data in a remote server. It can be enough to prototype small web 
 applications or store configuration data in the browser.
  
 However, another use for the driver can be cache server response in order to speed up 
 the application performance:
  
 // cachedSync.js 
  
 var _ = require('underscore'); 
  
 var Backbone = require('backbone');
  
 function getStore(model) 
 {
  
  
  return model.dataStore; 
  
 }
  
 module.exports =  _.wrap(Backbone.sync, (sync, method, model, options) 
 => { 
  
 var store = getStore(model);
  
  // Try to read from cache store
  
  if (method === 'read') {
  
  let cachedModel = getCachedModel(model);
  
  if (cachedModel) {
  
  
  
  let defer = Backbone.$.Deferred(); 
  
 defer.resolve(cachedModel);
  
  
  if (options &&options.success) 
 { 
  
 options.success(cachedModel);
  
 [
  138 
 ]",NA
IndexedDB,"As you have seen in the previous sections, localStorage is very easy; however, it has 
 the limitation of 5 MB of storage capacity. IndexedDB, on the other hand, does not have 
 this limitation; however, it has a complex API. The main downside of IndexedDB is that 
 it is not fully supported on all major browsers:
  
  
 Figure 6.4: Browser support for IndexedDB
  
 At the moment of writing this book, IndexedDB is fully supported by Chrome and 
 Firefox, while Safari and IE have partial support.
  
 A big difference between localStorage and IndexedDB is that IndexedDB is not a 
 key/value store; IndexedDB has collections (tables) and a query API. If you have 
 worked with MongoDB, you will be familiar with the way IndexedDB stores data.",NA
Getting started with IndexedDB,"An IndexedDB database is composed of one or more stores. A store is like a JSON 
 container, it contains a collection of JSON. If you have worked with SQL, then a store is like 
 a table. If you have worked with MongoDB, a store is a like a collection. In the same way as 
 MongoDB, IndexedDB is schemaless, which means that you don't need to define the 
 schema of the records (JSONs).
  
 One of the consequences of schemaless is that the data in the collections is not 
 heterogeneous, you can have different types JSON objects in the same store. For 
 example, you can store contact and invoice data in the same store.
  
 [
  142 
 ]
  
 www.it-ebooks.info",NA
Database versions,"Databases usually change with time; maybe a new feature needs a new store or adds an 
 index. All IndexedDB databases have a version number. The first time that you create a 
 new database, it starts with version 1. With the help of each version number, you can 
 define the stores and indexes as you need.
  
 IndexedDB does not allow you to create new stores or indexes, unless you have 
 changed the version number. When a new version number is detected, IndexedDB 
 enters a 
 versionchange
  state and calls the 
 onupgradedneeded()
  callback, which 
 you can use to modify the database.
  
 Every time you change the version number, you have the opportunity to run 
 database migrations in the 
 onupgradedneeded()
  callback. Every time you open a 
 connection with IndexedDB, you can specify a version number:
  
 indexedDB.open(<database name>, <version number>)
  
 The first time you open a database, IndexedDB enters the 
 versionchange
  state and 
 calls the 
 onupgradedneeded()
 callback.
  
 [
  143 
 ]
  
 www.it-ebooks.info",NA
Creating stores ,"To create stores on IndexedDB, you need to put the database on the version change 
 state, which you can do in the following two ways:
  
 1. Create a new database.
  
 2. Change the version number of the database.
  
 In the following example, we are creating a new database named library:
  
 var request = indexedDB.open(""library"");
  
 // In this callback the database is in the versionchange 
 state request.onupgradeneeded = function() {
  
  
  // The database did not previously exist, so that
  
  
  // we can create object stores and indexes.
  
 vardb = request.result; 
  
 var store = db.createObjectStore(""books"", {keyPath: ""isbn""});
  
  // Populate with initial data.
  
 store.put({ 
  
 title: ""Quarry Memories"",
  
  author: ""Fred"", 
  
 isbn: 123456}); 
  
 store.put({ 
  
 title: ""Water Buffaloes"",
  
  author: ""Fred"", 
  
 isbn: 234567}); 
  
 store.put({ 
  
 title: ""Bedrock Nights"",
  
  author: ""Barney"", 
  
 isbn: 345678}); 
  
 };
  
 request.onsuccess = function() { 
  
 window.db = request.result; 
  
 };
  
 When the 
 open()
  method is called, it returns a request object that we can use to register 
 the 
 onscuccess()
 callback called when the database is successfully opened and is ready 
 to be used. As we are creating a new database, the 
 onupgradeneeded() 
 callback is 
 called.
  
 [
  144 
 ]
  
 www.it-ebooks.info",NA
Delete a database,"You can always delete a database with the 
 deleteDatabse()
  method. If you did 
 something wrong and want to start over, just delete the database:
  
 indexedDB.deleteDatabase('library');
  
 [
  145 
 ]
  
 www.it-ebooks.info",NA
Add elements to an object store ,"You have seen how to create and delete stores. Now, you will see how to connect to a 
 database and add records to an object store outside of the 
 onupgradeneeded() 
 callback:
  
 vartx = db.transaction(""books"", ""readwrite""); 
 var store = tx.objectStore(""books"");
  
 store.put({
  
  
  title: ""Quarry Memories"",
  
  
  author: ""Fred"", 
  
 isbn: 123456 
  
 }); 
  
 store.put({
  
  
  title: ""Water Buffaloes"",
  
  
  author: ""Fred"", 
  
 isbn: 234567 
  
 }); 
  
 store.put({
  
  
  title: ""Bedrock Nights"",
  
  
  author: ""Barney"", 
  
 isbn: 345678 
  
 });
  
 tx.oncomplete = function() { 
  
 console.log('Records 
 added!'); 
  
 };
  
 Note that we are creating an IndexedDB transaction. The IndexedDB specification by W3C 
 defines a transaction as follows:
  
 A transaction is used to interact with the data in a database. Whenever data is read or 
 written to the database it is done by using a transaction.
  
 Transactions offer some protection from application and system failures. A transaction 
 may be used to store multiple data records or to conditionally modify certain data records. 
 A transaction represents an atomic and durable set of data access and data mutation 
 operations.
  
 [
  146 
 ]",NA
Performing queries ,"To query the data in an object store, you need to open a 
 readonly
  transaction:
  
 vartx = db.transaction(""books"", ""readonly""); 
 var store = tx.objectStore(""books"");
  
 var request = store.openCursor(IDBKeyRange.only(123456)); 
 request.onsuccess = function() { 
  
 var cursor = request.result;
  
  
  if (cursor) {
  
  
  // Called for each matching record.
  
 console.log(cursor.value); 
  
 cursor.continue(); 
  
 } else {
  
  
  // No more matching records, cursor === null 
 console.log('Done!');
  
  
  } 
  
 };
  
 [
  147 
 ]
  
 www.it-ebooks.info",NA
Delete objects in the store ,"To delete objects, you should call the 
 delete()
  method in the object store with a 
 query argument for these objects that you want to remove:
  
 vartx = db.transaction(""books"", ""readwrite""); 
 var store = tx.objectStore(""books"");
  
 store.delete(123456); // deletes book with isbn == 123456 
  
 store.delete(IDBKeyRange.lowerBound(456789)); // deletes books with 
 store <= 456789",NA
IndexedDB in Backbone ,"As the IndexedDB API is more complex than localStorage, it will be more difficult to 
 create an IndexedDB driver for Backbone as we did with localStorage; in this section, 
 you will use what you have learned about IndexedDB in order to build a driver for 
 Backbone.
  
 The driver should open a database and initialize the stores when it is created for the 
 first time:
  
 // indexedDB/dataStore.js 
  
 'use strict';
  
 var Backbone = require('backbone');
  
 const ID_LENGTH = 10;
  
 var contacts = [
  
 [
  149 
 ]
  
 www.it-ebooks.info",NA
Summary ,"You have learned two ways to store data in the browser and use them as a 
  
 replacement for a RESTful API server. The localStorage method has a simple API and it is 
 widely supported for all major browsers; this is going to be your first choice if you want 
 support old browsers; however, it has the limitation that you can only store five 
 megabytes.
  
 IndexedDB is powerful; however, its API is more complicated than localStorage. You need 
 to learn some concepts before you start working with it. Once you know how it works, 
 you should write your app asynchronously.
  
 [
  159 
 ]",NA
Build Like a Pro,"Some years ago, you could create a website with PHP, upload your source files through 
 FTP to a server, and then go online. During those days, JavaScript was a tight piece of 
 the whole system, used for UI tasks such as validating forms or small chunks of 
 functionality.
  
 Today, web is more JavaScript intensive, we are building web applications instead 
 websites, this means that JavaScript is no more a trivial piece of applications, it is now 
 a core piece. For this reason, it is important to pack our JavaScript application before 
 being deployed for production.
  
 You will learn the following in this chapter:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Building a workflow to automatically process your source files 
  
 Minifying the application script size 
  
 Minifying the number of requests to the server when the application 
  
 is loaded 
  
 Minifying the images 
  
 Optimizing the CSS files 
  
 Wiring up everything in an HTML file 
  
 Setting up a development environment to automatically reload the application
  
 At the time of writing this book, there are many tools to build JavaScript 
  
 applications; however, two of them are the most popular: Grunt and Gulp. Grunt is an 
 older choice with a big community around and an amazing collection of plugins 
 available. Gulp, on the other hand, is gaining more popularity each day and almost has 
 the most popular plugins that exist for Grunt.
  
 [
  161 
 ]
  
 www.it-ebooks.info",NA
Development workflow,"When you are developing an application, some tasks are very repetitive; for example, our 
 contacts application uses Browserify to manage dependencies. It needs to rebundle the 
 source code every time you make a change, which means that you need to run the 
 browserify
  command each time:
  
 $ npm bundle
  
 $ npm start
  
 To run these commands every time you make a small change is a very tedious task, 
 there should be a better way to do it:
  
 Development workflow
  
 First run
  
 Bundle application
  
 Run Browser Sync
  
 Open browser
  
 Development
  
 Source code change
  
 Bundle application
  
 Refresh the browser
  
 process
  
  
  
  
  
 Figure 7.1. Development workflow
  
 The above figure shows the ideal development process; the first time you run the 
 application, you should bundle the source files and run the BrowserSync web server and 
 then open the browser. After that, for any change that you make in any source file, the 
 application should be rebundled and then the browser should be refreshed to get the 
 new changes.
  
 Currently, we are manually doing this process; however, in the next section, you will learn 
 how to automatize this task to let the machine do all this for you.",NA
What's a task runner?,"A task runner is computer program that runs a sequence of tasks over your source code, 
 applying transformations to the files. For example, consider that you are writing a 
 source code in the CoffeeScript programming language, one task would be compiling all 
 your source code in JavaScript, other task can be concatenating all the output JavaScript 
 files in a single file, and the third task can finally be minifying the concatenated file to 
 minimize the file size.
  
 [
  162 
 ]
  
 www.it-ebooks.info",NA
How Gulp works,"As I mentioned at the beginning of the chapter, Gulp is the most popular JavaScript task 
 runner at the time of writing this book and that's the main reason why we chose it. Gulp 
 and Grunt work in a similar way, they both use third-party plugins to work. Keep in 
 mind that Gulp is more like a framework, it does not make too much by itself.
  
 Gulp acts as the glue that coordinates the build workflow; it has some basic 
 functionality and an API, which the Gulp plugins can use to do their work. The 
 plugins use the compilers and utility programs that make the real file processing, 
 such as the CoffeeScript transpiler. The plugins connect these programs to the Gulp 
 workflow:
  
 stream
  
 gulp core
  
 gulp
  
 gulp plug-ins
  
 libraries
  
 gulp-requirejs
  
 r.js
  
 gulp-uglify
  
 uglify
  
 gulp-coffeescript
  
 coffeescript
  
 api
  
 gulp-less
  
 less
  
 Figure 7.3 Relationship between Gulp plugins and libraries
  
 The preceding figure shows the relationship that was described earlier, you can get a 
 better idea of how Gulp connects with its plugins; notice how the plugins delegate the 
 file processing to the utility programs that they connect to.
  
 Gulp is composed of several named tasks where each task can have dependencies on 
 other tasks. A typical Gulp task opens a stream of files at the beginning and applies 
 transformation to each file in the stream with the installed plugins.
  
 [
  164 
 ]
  
 www.it-ebooks.info",NA
Getting started with Gulp,"First of all, install the Gulp package globally; this will give you access to the 
 gulp 
 command:
  
 $ npm install -g gulp
  
 Once you have installed Gulp globally, you will need to install it in your local project in 
 order to have access to the Gulp core utilities:
  
 $ npm install -save-dev gulp
  
 To configure the Gulp tasks, you will need to create a file called 
 gulpfile.js
  that 
 Gulp will read every time you run the 
 gulp
  command. All Gulp tasks have a name and 
 a function that is executed when the task is invoked:
  
 var gulp = require('gulp');
  
 gulp.task('hello', function() {
  
  console.log('Hello world!');
  
 });
  
 The following simple Gulp task will print Hello world! on the console:
  
 $ gulp hello
  
 [22:43:15] Using gulpfile ~/path/to/project/gulpfile.js
  
 [22:43:15] Starting 'hello'...
  
 Hello world!
  
 [22:43:15] Finished 'hello' after 118 μs
  
 Note how we invoke Gulp, 
 gulp hello
 , the argument used in the command is the name 
 of the task to be executed. This is the simplest Gulp task that you can write and it is the 
 starting point for developing an effective build pipeline.",NA
Creating a development workflow,"In this section, we will build a script to help us in the development process and, 
 later, to build a production-ready script. You will need to install the basic 
 dependencies first:
  
 $ npm install --save-dev gulp gulp-load-plugins gulp-util
  
 The 
 gulp-load-plugins
  is useful to automatically load all the available plugins 
 without manually requiring them in the 
 gulpfile.js
  script; the 
 gulp-util
  plugin 
 provides utility functions such as log messages.
  
 [
  166 
 ]
  
 www.it-ebooks.info",NA
Bundling the JavaScript files with Browserify ,"The 
 gulp-browserify
  plugin is currently deprecated and should not be used. The 
 project author recommends using one of the recipes developed by the Gulp 
 development team.
  
 The recipes described in the repository needs to install some plugins first:
  
 $ npm install --save-dev jstifywatchify vinyl-source-stream
  
 In 
 gulpfile.js
 , we can define the 
 browserify
  task:
  
 var gulp = require('gulp'); 
  
 var $ = require('gulp-load-plugins')(); 
  
 var browserify = require('browserify'); 
  
 var jstify = require('jstify'); 
  
 var source = require('vinyl-source-stream');
  
 // Bundle files with browserify 
  
 gulp.task('browserify', () => {
  
  
  // set up the browserify instance on a task basis
  
  
  var bundler = browserify({
  
  
  entries: 'app/js/main.js',
  
  
  debug: true,
  
  
  // defining transforms here will avoid crashing your stream
  
  
 transform: [jstify]
  
  
  });
  
  
  return bundler.bundle()
  
  
  .on('error', $.util.log)
  
  
  .pipe(source('app.js'))
  
  
  .pipe(gulp.dest('.tmp/js')); 
  
 });
  
 Notice how we configure the Browserify bundle, we use the Browserify 
 jstify 
 transformation to compile the underscore templates. As the 
 browserify
  task is not a 
 standard Gulp plugin, we are using 
 vinyl-source-stream
  to stream the files to the 
 bundler. Finally, we will write the output in the 
 .tmp/js
  path.
  
 Now, you can run Gulp with the Browserify argument to run the task:
  
 $ gulp browserify
  
 [07:13:18] Using gulpfile ~/path/to/your/project/gulpfile.js
  
 [07:13:18] Starting 'browserify'...
  
 [07:13:19] Finished 'browserify' after 1.13 s
  
 [
  167 
 ]
  
 www.it-ebooks.info",NA
Sourcemaps ,"When you run the project, the browser gets a single file named 
 app.js
 , which contains all 
 the concatenated source code. That's good for the production environments as it reduces 
 the number of requests made to the server in order to get the assets. However, in 
 development environments, it is more useful to see the individual files in the browser as 
 you have it in the source code for the debugging process.
  
 You can make sure that the browser shows you the original source files with 
 sourcemaps so that you can put debug breakpoints or simply inspect the code 
 without the noise of the other dependencies such as the Backbone library.
  
 To include sourcemaps in the 
 browserify
  task, you will need to install some 
 extra dependencies:
  
 $ npm install --save-dev vinyl-buffergulp-sourcemaps
  
 Then, modify the task:
  
 // ...
  
 var buffer = require('vinyl-buffer');
  
 // Bundle files with browserify 
  
 gulp.task('browserify', () => {
  
  
  // set up the browserify instance on a task basis
  
  
  var bundler = browserify({
  
  
  entries: 'app/js/main.js',
  
  
  debug: true,
  
  
  // defining transforms here will avoid crashing your stream
  
  
 transform: [jstify]
  
  
  });
  
  return bundler.bundle()
  
  .on('error', $.util.log)
  
  .pipe(source('app.js'))
  
  
  .pipe(buffer())
  
  
  .pipe($.sourcemaps.init({loadMaps: true}))
  
    
  // Add transformation tasks to the pipeline here.
  
  
   
  .on('error', $.util.log)
  
  
  
  .pipe($.sourcemaps.write('./'))
  
  .pipe(gulp.dest('.tmp/js')); 
  
 });
  
 [
  168 
 ]
  
 www.it-ebooks.info",NA
Re-bundle automatically,"If you change a source file, then you will need to run the 
 browserify
  task again. You can 
 make sure that Gulp and Browserify do this job for you. First, you will need to install 
 another Browserify plugin:
  
 $ npm install --save-dev watchify
  
 The 
 watchify
  plugin listens for file changes in the source code and can be used to 
 trigger a re-bundle task:
  
 //...
  
 var watchify = require('watchify');
  
 // Bundle files with browserify
  
 gulp.task('browserify-2', () => {
  
  // set up the browserify instance on a task basis
  
  var bundler = browserify({
  
  entries: 'app/js/main.js',
  
  debug: true,
  
  // defining transforms here will avoid crashing your stream
  
  transform: [jstify]
  
 [
  169 
 ]
  
 www.it-ebooks.info",NA
BrowserSync ,"BrowserSync is an asset server that is useful for the purpose of developing, you should 
 avoid its use for production environments. BrowserSync is a node package that runs 
 an HTTP server that automatically reloads the browser when a change on the files that 
 serve is detected. With BrowserSync, you may forget to manually refresh your browser 
 every time you make a change.
  
 You need to install the package before starting to use it:
  
 $ npm install --save-dev browser-sync
  
 Once the package is installed, we can create a new Gulp task to run BrowserSync:
  
 // ...
  
 var browserSync = require('browser-sync'); 
  
 var reload = browserSync.reload;
  
 gulp.task('serve', () =>{
  
  
  browserSync({
  
 [
  170 
 ]
  
 www.it-ebooks.info",NA
Run server with Express ,"Now that we have the assets server working, we need to run our Express server with 
 nodemon
 , this package is very similar to BrowserSync; however, it does not include the 
 browser features. With nodemon, you can run a node script that will watch for any 
 changes on the JavaScript files. When a change is detected, the node script will be 
 reloaded automatically.
  
 You need to install the npm package first:
  
 $ npm install --save-dev gulp-nodemon
  
 Then, we can create the task for nodemon:
  
 // ...
  
 var nodemon = require('gulp-nodemon');
  
 gulp.task('express', () => {
  
  
  nodemon({
  
  
  script: 'server/index.js',
  
  
  ignore: ['app']
  
  
  }); 
  
 });
  
 In this task, we are informing nodemon to ignore the changes under the 
 app 
 directory. 
 The reason for this is that the 
 app
  path is already watched by BrowserSync.
  
 Now that we have the server, and the assets are served and reloaded automatically, we 
 can merge these two tasks in order to run the project in development mode:
  
 var httpProxy = require('http-proxy');
  
 gulp.task('serve', ['browserify', 'express'], () => {
  
  var serverProxy = httpProxy.createProxyServer();
  
  browserSync({
  
  port: 9000,
  
  ui: {
  
  
  port: 9001
  
  },
  
  server: {
  
  
  baseDir: ['.tmp', 'app'],
  
  
  middleware: [
  
 [
  172 
 ]
  
 www.it-ebooks.info",NA
Creating a production workflow,"The development workflow that we built in the previous sections is an amazing 
 improvement for the project; however, we are not finished yet. In this section, you will 
 see how to optimize the project that is to be run in the production environments.
  
 In this section, you will learn how to minimize your JavaScript and CSS files to 
 obfuscate your source code and reduce the time the browser takes to load the asset 
 files. The images can also be minified in order to reduce its weight without altering its 
 appearance.",NA
Gulp useref,"The 
 gulp-useref
  plugin processes your HTML files to concatenate your JavaScript and 
 CSS assets into a single file. Please note that the JavaScript is already processed by 
 Browserify, therefore, it is not necessary to process the JavaScript files with useref; on the 
 other hand, CSS can be processed here.
  
 You will need to install the plugin with npm as a development dependency:
  
 $ npm install --save-dev gulp-useref
  
 Then, to use it, you will need to create a new task. Let's call it 
 html
 :
  
 // ...
  
 gulp.task('html', function() {
  
  var assets = $.useref.assets();
  
  return gulp.src('app/*.html')
  
  .pipe(assets)
  
  .pipe(assets.restore())
  
  .pipe($.useref())
  
  .pipe(gulp.dest('dist'));
  
 });
  
 The 
 gulp.src('app/*.html')
  function grabs all the files with the
 .html
  extension. In 
 our case, only the 
 index.html
  file exists, therefore, it is the only file that will be 
 processed. The 
 useref.assets()
  function concatenates all the assets that are found in 
 the HTML files and puts them in a stream, the 
 assets.restore()
  function will restore 
 the original stream of HTML files that are picked in the beginning.
  
 [
  174 
 ]
  
 www.it-ebooks.info",NA
Image Optimization ,"When you are developing your project in the local machine, the assets load pretty 
 fast as images and code live in the same computer; however, when you go to the 
 production images, they travel through the Internet to your user machine.
  
 With image optimization, we can compress these images in order to reduce the 
 amount of data that your app downloads from the server. With node, you can use the 
 imagemin
  package; however, as we are using Gulp, 
 gulp-imagemin
  will do the job.
  
 As we did earlier, you will need to install the plugin first:
  
 $ npm install --save-dev gulp-imagemin
  
 Now that the plugin is installed, we can use it:
  
 gulp.task('images', function() {
  
  
  gulp.src('app/images/*.{jpg,gif,svg,png}')
  
  .pipe($.imagemin())
  
  
  .pipe(gulp.dest('dist/images')); 
  
 });
  
 It grabs the images from the 
 app/images
  path and applies the 
 imagemin()
  process to 
 each image.",NA
Fonts ,"Fonts for Bootstrap are located under the 
 node_modules/
  directory. If you install other 
 type of fonts, such as Font Awesome, or download a specific fonts; they should be copied 
 to the 
 dist/
  directory. You can create a 
 fonts
  task to do this, as shown in the following:
  
 // ...
  
 gulp.task('fonts', function () {
  
  
  return gulp.src([
  
  
  'app/{,styles/}fonts/**/*',
  
  
  'node_modules/bootstrap/dist/fonts/**/*'
  
  
 ])
  
  
  .pipe($.flatten())
  
  
  .pipe(gulp.dest('dist/fonts')); 
  
 });
  
 [
  177 
 ]
  
 www.it-ebooks.info",NA
Bundle JavaScript files for production ,"The 
 browserify
  task that we have is useful for development, it creates sourcemaps and 
 the output is not minified. If you want to go to the production, you will need to remove 
 the sourcemaps and minimize the output too.
  
 For production environment, we will transform the ECMAScript 6 code into 
  
 JavaScript in order to add support for these browsers that does not support for 
 ECMAScript 6. Babel is the best transpiler at the moment to make this transformation.
  
 The babelify plugin of Browserify will apply the transformations, as follows:
  
 $ npm install --save-dev babelify
  
 You will need to configure Babel before using the babelify plugin. In Babel 6, you have 
 to install individual packages for the functions that you want to support. For this 
 project, we support ES2015:
  
 $ npm install --save-dev babel-preset-es2015
  
 In the 
 .babelrc
  file, you should configure the preset:
  
 // .babelrc 
  
 {
  
  
  ""presets"": [""es2015""] 
  
 }
  
 Once you have configured Babel properly, we can create the 
 browserify
  task for 
 production:
  
 // Bundle files with browserify for production 
  
 gulp.task('browserify:dist', function () {
  
  
  // set up the browserify instance on a task basis
  
  
  var bundler = browserify({
  
  
  entries: 'app/js/main.js',
  
  
  // defining transforms here will avoid crashing your stream
  
  
 transform: [babelify, jstify]
  
  
  });
  
  return bundler.bundle()
  
  .on('error', $.util.log)
  
  .pipe(source('app.js'))
  
 [
  178 
 ]
  
 www.it-ebooks.info",NA
Putting it all together ,"You have learned how to optimize several kind of assets: CSS, JavaScript, and 
 images. Now let's put all this together in order to build our application. The 
 serve:dist
  task wires all the processes into a pipeline:
  
 gulp.task('serve:dist', ['browserify:dist', 'images', 'fonts', 
 'express'], () => {
  
  
  var serverProxy = httpProxy.createProxyServer();
  
  
  browserSync({
  
  
  port: 9000,
  
  
  ui: {
  
    
  port: 9001
  
  
  },
  
  
  server: {
  
    
  baseDir: 'dist',
  
    
  middleware: [
  
     
  function (req, res, next) {
  
     
  if (req.url.match(/^\/(api|avatar)\/.*/)) {
       
  serverProxy.web(req, res, {
  
       
  target: 'http://localhost:8000'
  
       
  });
  
     
  } else {
  
       
  next();
  
     
  }
  
     
  }
  
    
  ]
  
  
  }
  
  
  }); 
  
 });
  
 To test our pipeline, we can run the 
 serve:dist
  task in the terminal:
  
 $ gulp serve:dist
  
 [11:18:04] Using gulpfile ~/Projects/mastering-backbone/ch07/gulpfile.js
  
 [11:18:04] Starting 'browserify:dist'...
  
 [
  179 
 ]
  
 www.it-ebooks.info",NA
Summary,"In this chapter, we have seen how to use tools to build our Backbone application. First, 
 you learned what a task runner is and the most popular choices available for Node. 
 Then, we saw how Gulp works and creates tasks.
  
 With Gulp, you can build a development environment and configure it in order to 
 apply optimizations to your assets for the production environments. Gulp is 
 stream-based, which means that you can grab a bunch of files from a 
 glob 
 specification and stream these files in order to apply transformations, such as 
 compiling, concatenating, transpiling, and so on, as you need.
  
 Task runners are amazing tools that allow you to automatize tasks. You can not only 
 create development and production workflows, but also tasks for almost anything, 
 which you don't want to repeat. For example, a task to make deployments.
  
 In the next chapter, we will see how to test the Backbone applications. You will learn 
 how to isolate and fake dependencies for easy testing, the what and how to make 
 Backbone testing.
  
 [
  181 
 ]
  
 www.it-ebooks.info",NA
Testing Backbone ,NA,NA
Applications,"It does not matter if you are an experienced programmer, it's very normal that you will 
 commit mistakes in your code at some point in time. Nobody is perfect and errors 
 happen all the time in software development. Your work as a developer is to minimize 
 the number of defects that are in your software.
  
 Errors can occur from different sources; an unexpected input, an error that is not 
 handled properly, a change in a third-party plugin, a memory issue, and so on. Your 
 code should be prepared to deal with these kind of things.
  
 In the software industry, the rule of thumb is to always test your code. When you test 
 your applications, the final product has a better quality as many defects have been 
 detected and corrected before the users notice it.
  
 Tests are not just undertaken to prevent bugs in the software. The following is a list of 
 benefits that you get when you do the testing:
  
 • 
  
 Improves end-product quality
  
 • 
  
 Makes you confident with your application
  
 • 
  
 Allows you to refactor pieces of code safely
  
 • 
  
 Preserves functionality
  
 • 
  
 Simulates errors and improves your error handling code
  
 • 
  
 Improves your code, forcing you to make testable code
  
 If you have never tested your software, now you have good reasons to start doing it. 
 Make
  testing can slow down your development process at the start; however, you will 
 see the benefits in the mid time.
  
 [
  183 
 ]
  
 www.it-ebooks.info",NA
Testing tools,"A testing tool can be a library or framework that helps you to write tests for your 
 applications and evaluate the results. Under testing tools, you can find the following:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Testing libraries
 : This gives you a hook and functions to describe tests 
 Assertion libraries
 : This gives you functions to make expectations 
  
 Test runners
 : This discovers and runs your tests 
  
 Test coverage
 : This tells you which parts of your code are tested and which are 
 not 
  
 Test reports
 : This makes reports in different formats such as HTML and JSON 
 Mocking, stubbing, faking tools
 : These give you ways to make fake objects 
 with predictable behavior 
  
 Module mocking
 : This replaces a required module with a fake module and is 
 useful to isolate modules 
  
 Stress tools
 : This makes many requests to the applications in order to see how 
 it behaves in high demand circumstances 
  
 Browser testing
 : This emulates a user making inputs in the application as a 
 whole
  
 Explaining and showing how all these tools work is out of scope of this book. In 
 this chapter, you will work with testing libraries, asserting libraries, testing 
 runners, and mocking.
  
 For JavaScript, there are many testing libraries available for you; however, two of 
 them are more popular at the moment of writing this book: 
 Jasmine
  and 
 Mocha
 .
  
 Mocha
  is a small library that allows you to write tests harness, it does not have any 
 assertion functions by itself. What it means is that you should integrate 
 Mocha
  with 
 an assertion library of your choice; a very popular choice is to use a combination of 
 Mocha and Chai.js.
  
 [
  184 
 ]
  
 www.it-ebooks.info",NA
Getting started with Jasmine,"To write tests, you should create two things: test suites and specs. A spec (short for 
 specification) is a piece of functionality that you are testing from your code; for 
 example, if your code is calculating tax of 5% for $100.00, you would expect it to be 
 $5. A test suite is a set of expectations that are grouped under a topic. In the 
 preceding example, the test suite can be ""Invoice totals calculation"".
  
 To start working with Jasmine, you should install it from npm, as follows:
  
 $ npm install --save-dev jasmine
  
 Then, you can start writing your tests. With Jasmine, you have two functions: 
 describe()
  to create test suites and 
 it()
  to make specs:
  
 // specs/mathSpec.js 
  
 describe('Basic mathematicfunctions', () => {
  
 it('should result 4 the sum of 2 + 2', () => {
  
  });
  
 it('should result 1 the substract of 3 - 2', () => {
  
  });
  
 it('should result 3 the division of 9 / 3', () => {
  
  });
  
 it('should throw an error when divide by zero', () => {
  
  });
  
 });
  
 The preceding code defines a test suite for a hypothetical set of math functions. Notice 
 how in the 
 describe()
  function, you should write a text that tells the people what is 
 the context of the tests; while in the 
 it()
  function, the text should tells what are you 
 testing.
  
 [
  185 
 ]
  
 www.it-ebooks.info",NA
Expectations ,"Expectations are functions that compare the output of a function with an expected 
 output. In the following example, we call the 
 sum()
  function with an input of 
 2 
 and 
 2
 . 
 We are expecting that the result should be 
 4
 :
  
 expect(sum(2, 2)).toEqual(4);
  
 The 
 toEqual()
 expectation function compares whether the output of the function and 
 the expected value are equal; if both are the same, the test will pass, otherwise, it will 
 fail. The following table shows the most common expectations in Jasmine, consult the 
 documentation for a complete set of available expectation functions:
  
 Expectation function
  
 Description
  
 Example
  
 toEqual
  
 The values should be exactly 
 equal
  
 expect('hello') 
  
 .toEqual('hello')
  
 [
  186 
 ]
  
 www.it-ebooks.info",NA
Testing asynchronous code,"When you need to test a code that is asynchronous like an Ajax call, you will need to 
 make an extra step. When you write the 
 it()
  function, you should pass a 
 done 
 argument and Jasmine will put a callback function there, which you should call when 
 the test is done.
  
 To illustrate this, let's simulate an asynchronous task that sum two numbers, as 
 follows:
  
 var math = {
  
  // ...
  
 asyncSum(a, b, callback) {
  
  // Will respond after 1.5 seconds.
  
 setTimeout(function() {
  
 callback(a + b);
  
  }, 1500);
  
  },
  
  // ...
  
 };
  
 Following the JavaScript standard, the 
 syncSum()
  function receives a third 
  
 argument, which is the callback function that will be called when the sum is ready. In the 
 following example, the callback function will be called after 1,500 milliseconds:
  
 math.asyncSum(2, 2, result => {
  
  // After 1500ms result will be equal to 4
  
 });
  
 [
  189 
 ]
  
 www.it-ebooks.info",NA
Karma test runner ,"Karma is a popular test runner for JavaScript, it works with many other testing 
 libraries and frameworks such as Jasmine and Mocha. The Node test runner that 
 comes with Jasmine is fine; however, Karma adds superpowers to the equation.
  
 With Karma, you can run your tests on real web browsers such as Google Chrome, 
 Firefox, Opera, and so on. Once Karma is set and running, it will take care of lookup for 
 the files to test, run it, and then give you a report.
  
 You will need to install Karma before starting to work with it:
  
 $ npm install --save-dev karma karma-jasmine karma-browserify 
 karma-chrome-launcher karma-spec-reporter
  
 Then, you can configure Karma with a script named 
 karma.conf.js
 :
  
 // Karma configuration 
  
 // http://karma-runner.github.io/0.12/config/configuration-file.html
  
 module.exports = function(config) {
  
  
  'use strict';
  
 config.set({
  
  // enable / disable watching file and executing tests whenever 
 // any file changes 
  
 autoWatch: true,
  
  // base path, that will be used to resolve files and exclude 
 basePath: '',
  
  // testing framework to use (jasmine/mocha/qunit/...) 
 frameworks: ['browserify', 'jasmine'],
  
  // list of files / patterns to load in the browser 
 files: [
  
 [
  190 
 ]
  
 www.it-ebooks.info",NA
What and how to test Backbone ,NA,NA
applications,"Backbone library has different components, each one with its own intentions and 
 responsibilities, that's why you have to test them differently. Keep it in mind that 
 you should only test your code and not the Backbone built-in functionalities.
  
 In the next sections, you will see what are the parts of your Backbone applications and 
 how to test them; we will start from simple things and then go for more complex ones. 
 Then, you will learn how to isolate modules to only test one module at time.
  
 [
  192 
 ]
  
 www.it-ebooks.info",NA
Testing models and collections ,"The most basic test is to ensure that models and collections have the right properties set 
 in order to prevent accidental changes in its properties. In the case of models, you can 
 test the default values when a new contact is created and verify that the 
 url 
 attribute is 
 right:
  
 // spec/apps/contacts/models/contactSpec.js 
  
 var Contact = require('../../../../app/js/apps/contacts/models/ 
 contact');
  
 describe('Contact model', () => { 
  
 describe('creating a new contact', () => { 
  
 it('has the default values', () => { 
  
 var contact = new Contact();
  
 expect(contact.get('name')).toEqual(''); 
 expect(contact.get('phone')).toEqual(''); 
 expect(contact.get('email')).toEqual(''); 
 expect(contact.get('address1')).toEqual(''); 
 expect(contact.get('address2')).toEqual(''); 
 expect(contact.get('avatar')).toEqual(null);
  
  });
  
  
  });
  
 it('has the rigthurl', () => { 
  
 var contact = new Contact(); 
  
 expect(contact.url()).toEqual('/api/contacts');
  
  }); 
  
 });
  
 For collections, you can verify that the 
 url
  is right:
  
 // spec/apps/contacts/collections/contactCollectionSpec.js 
  
 varContactCollection = require('../../../../app/js/apps/contacts/ 
 collections/contactCollection');
  
 describe('Contac collection', () => { 
  
 it('has the rigthurlRoot', () => { 
  
 var collection = new ContactCollection(); 
  
 expect(collection.url).toEqual('/api/contacts');
  
  }); 
  
 });
  
 [
  193 
 ]
  
 www.it-ebooks.info",NA
Testing views ,"Views manage the relationship between data (such as, models or collections) and the 
 user interactions (DOM). In the case of views, you should test for the following:
  
 • 
  
 • 
  
 • 
  
 Rendering: Given a model or collection, you should verify that the output 
 HTML is the right one 
  
 Events: This verifies that the DOM events are handled correctly 
  
 Model changes: If the model changes something, the view should be in sync
  
 For this example, we are going to test the 
 ContactForm
  view; the responsibility of this 
 view is to show a form to the user and then get the user input to update a model.
  
 When making test on views, it is recommended to use a fake model and not the original 
 Contact
  model. The main reason for this is to isolate the 
 ContactView
  object so that if a 
 test fails, you will know that the error is isolated in the view and does not depend on the 
 Contact
  model.
  
 You can start testing whether the rendered HTML is right, as follows:
  
 var Backbone = require('backbone'); 
  
 var ContactForm = 
 require('../../../../app/js/apps/contacts/views/ contactForm');
  
 describe('Contact form', () => { 
  
 var fakeContact;
  
 beforeEach(() => { 
  
 fakeContact = new Backbone.Model({ 
  
 name: 'John Doe', 
  
 facebook: 
 'https://www.facebook.com/john.doe', twitter: 
 '@john.doe', 
  
 github: 'https://github.com/johndoe', 
  
 google: 'https://plus.google.com/johndoe'
  
  
  });
  
  
  });
  
 it('has the rigth class', () => { 
  
 var view = new ContactForm({model: fakeContact}); 
 expect(view.className).toEqual('form-
 horizontal');
  
  });
  
 it('renders the rigth HTML', () => {
  
 [
  194 
 ]",NA
Testing controllers,"Controllers are more complex than test as they have more dependencies than the 
 models, collections, and views. If you explore the code on these objects, you will see 
 that the only dependencies that they have are Backbone and Underscore.
  
 You can test the controllers with all its dependencies, which means that while testing the 
 ContactEditor
  controller, you will be testing all the views and models attached to it as 
 the module requires these objects.
  
 That's not good for unit testing as you will end up with integration tests instead. If the 
 Contact
  model has a defect, then 
 ContactEditor
  will fail, even if it does not have any 
 error in it.
  
 You need to isolate the modules from the mess of other modules. Keep in mind that you 
 should trust your libraries as they will already have their test suites. We need a 
 mechanism to fake the dependencies of a module.
  
 With dependency injection, you can overwrite the 
 require()
  function, instead of 
 loading the script that points, in order to use a fake object. This will guarantee that the 
 code that is being tested is isolated and its behavior is predictable for unit testing.",NA
Mocking dependencies,"There are two main choices to mock dependencies in Node: 
 rewire
  and 
  
 proxyquireify
 ; with these libraries, you can overwrite the original dependencies of a 
 module in order to use a fake version instead.
  
 With Browserify, you should have 
 proxyquireify
 . Install it with npm, as follows:
  
 $ npm install --save-dev proxyquirefy
  
 Once the library is installed, we need to add a proper configuration in the Karma 
 configuration file:
  
 // ...
  
 browserify: {
  
 debug: true,
  
 plugin: ['proxyquireify/plugin'],
  
 transform: ['jstify'],
  
 extensions: ['.js', '.tpl']
  
 },
  
 // ...
  
 [
  198 
 ]
  
 www.it-ebooks.info",NA
Fake objects,"A fake object is a simple object that has the same functions as an original one; 
 however, with a predictable behavior so that you can use fake objects to isolate the 
 module under test. For example, all our controllers depend on the 
 App
  object to work; 
 however, it is not a good idea to use the real 
 App
  object for the purpose of testing. If 
 the 
 App
  object has an error, then the controller test will fail.
  
 A fake for the 
 App
  object is as shown in the following:
  
 // spec/fakes/app.js
  
 'use strict';
  
 var fakeRouter = {
  
 navigate: jasmine.createSpy()
  
 };
  
 var FakeApp = {
  
 [
  199 
 ]
  
 www.it-ebooks.info",NA
Testing ContactEditor ,"The 
 ContactEditor
  controller's responsibility is to render the necessary views in 
 order to allow the user to update or create new contacts. It is closely related to many 
 views and the 
 Contact
  model.
  
 We are going to use 
 proxyquireify
  to isolate the 
 ContactEditor
  controller and 
 instead of using the real objects, we will fake most of them. The first test is to check 
 whether the subapplication is rendered in the right region:
  
 // spec/apps/contacts/contactEditor.js 
  
 var proxyquery = require('proxyquireify')(require); 
 var Backbone = require('backbone');
  
 var FakeRegion = require('../../fakes/region'); 
  
 var fakes = { 
  
 './views/contactPreview': Backbone.View, 
  
 './views/phoneListView': Backbone.View, 
  
 './views/emailListView': Backbone.View, 
  
 './collections/phoneCollection': Backbone.Collection, 
 './collections/emailCollection': Backbone.Collection 
 };
  
 var ContactEditor = 
 proxyquery('../../../app/js/apps/contacts/ contactEditor', 
 fakes);
  
 describe('Contact editor', () => 
 { 
  
 var fakeContact; 
  
 var editor; 
  
 var region;
  
 beforeEach(() => { 
  
 region = new FakeRegion(); 
  
 editor = new ContactEditor({region}); 
  
 fakeContact = new Backbone.Model({ 
  
 name: 'John Doe', 
  
 facebook: 
 'https://www.facebook.com/john.doe', twitter: 
 '@john.doe', 
  
 github: 'https://github.com/johndoe', 
  
 google: 'https://plus.google.com/johndoe'
  
  
  });
  
  
  });
  
 describe('showing a contact editor', () => { 
  
 it('renders the editor in the given region', () => {
  
 [
  201 
 ]",NA
Testing the subapplication Façade ,"The subapplication façade's responsibility is to create the model or collect objects and 
 create the appropriate subapplication controller to render the fetched data. To show the 
 contact editor, the Façade should fetch the contact by its ID and then run the 
 ContactEditor
  subapplication:
  
 var proxyquery = require('proxyquireify')(require);
  
 var FakeApp = require('../../fakes/app'); 
  
 var FakeRegion = require('../../fakes/region'); 
  
 var FakeContactEditor = require('../../fakes/contactEditor');
  
 var fakes = { 
  
 '../../app': FakeApp, 
  
 './contactEditor': FakeContactEditor, 
  
 './contactList': {}, 
  
 './contactViewer': {} 
  
 };
  
 var ContactsApp = proxyquery('../../../app/js/apps/contacts/app', 
 fakes);
  
 describe('Contacts application facade', () => { 
 var app; 
  
 var region;
  
 function respond(request) { 
  
 var fakeResponse = { 
  
 name: 'John Doe', 
  
 facebook: 
 'https://www.facebook.com/john.doe', twitter: 
 '@john.doe', 
  
 github: 'https://github.com/johndoe', 
  
 google: 'https://plus.google.com/johndoe'
  
  };
  
 request.respondWith({ 
  
 status: 200, 
  
 contentType: 'application/json', 
  
 responseText: JSON.stringify(fakeResponse)
  
  
  });
  
  
  }
  
 beforeEach(() => {
  
 [
  209 
 ]",NA
Summary,"If you want to build robust applications with minimum defects, you should test your code. 
 Even if you are very good at coding, sometimes you may forget a validation or break a 
 dependency and won't know about it until the final user of your application finds the bug.
  
 As a professional developer, you should make sure that your code is always ready for 
 production; one way to successfully do it is to run tests in your development workflow. 
 Another benefit of testing applications is that you will gain confidence in your code, 
 which means that you can improve your code without the fear of breaking something 
 accidentally.
  
 In Backbone, testing depends on the responsibility of the object that you are testing. 
  
 Models, views, controllers, and facades are tested in their own way. However, it 
 doesn't matter what the object is, Jasmine does a great work in order to help you to 
 make a good test battery.
  
 In the next chapter, you will learn how to deploy your Backbone application to a server 
 for production and how to build a production environment for your applications. You will 
 setup a Heroku instance if you don't want to mess with the server configuration internals 
 or want to see how all the parts are connected in deep. I will show you how to configure 
 an Ubuntu server in order to make your deployments.
  
 [
  211 
 ]
  
 www.it-ebooks.info",NA
Deploying to Production,"You have built a great project: it is modularized, has tests, has been automatized to 
 do common tasks, and finally you have built a production version with Gulp; 
 however, now how do you deploy to a production server?
  
 This chapter examines what to do with the production version of your project. Here, you 
 will see how to run your node server and frontend assets in a production environment.
  
 There are many choices to run your project in production mode; you can deploy on a 
 bare metal server, use a virtual machine, on a shared host such as DigitalOcean or 
 RackSpace, or maybe just deploy it to a 
 PaaS
  (
 Platform as a service
 ) service such as 
 Heroku.
  
 In the following section, we will see how to deploy to an Heroku instance, this is the 
 easiest way to make a deployment as you don't have to worry about the server details 
 and you can manage all the configurations in a single configuration file.
  
 If you already have your own infrastructure or simply prefer to work with server 
 instances such as DigitalOcean or RackSpace virtual server, we will show you how to 
 configure a production environment on a server, where you have access to a shell.",NA
Heroku,"Heroku is a PaaS, which means that you don't have to worry about the details of the 
 server configuration where you are deploying your code, you only focus on your code; 
 Heroku will do the difficult job with the infrastructure configuration.
  
 Instead of using a shell to install, configure, and tune up your packages in order to run in 
 production mode, you only have to edit a configuration file and publish your changes 
 with the standard 
 git push
  command.
  
 [
  213 
 ]
  
 www.it-ebooks.info",NA
Dynos,"Heroku uses lightweight Linux containers that run a single command in order to run your 
 projects in the Heroku platform. Heroku calls these containers Dynos. A Dyno can host 
 your code and run it as a single process in an isolated Linux environment.
  
 If you don't have an experience in Linux containers such as Docker, you can imagine a 
 container to be like a small virtual machine without hardware emulation; a Linux 
 container uses the same kernel as the host machine, it means that you don't need to 
 emulate hardware:
  
  
 Figure 9.1 Difference between virtualization and containers
  
 By default, Heroku will use Celadon Cedar stack to build Dynos; and Celadon Cedar stack 
 is based on the Ubuntu distribution. With this is mind, you will get an Ubuntu-like 
 distribution, where you can run your code written on:
  
 • 
  
 Ruby on Rails
  
 • 
  
 Node.js
  
 [
  214 
 ]
  
 www.it-ebooks.info",NA
Getting started with Heroku ,"The first thing to do in order to start working with Heroku is to register with the 
 service, as follows:
  
  
 Figure 9.2 Heroku registration form
  
 [
  215 
 ]
  
 www.it-ebooks.info",NA
Production environment,"If you have a bare metal server or want to work with virtual servers, such as 
 DigitalOcean or Rackspace, you can create your own production environment. In 
 this section, you will see how to make it possible.
  
 [
  220 
 ]
  
 www.it-ebooks.info",NA
The HTTP Server,"The HTTP server handles the connections with the client and forwards all the requests 
 to the Node server. In some way, it is a kind of proxy. Currently, there are two main 
 HTTP servers on the market that were used widely in production: Apache and Nginx, 
 both can be used to server Node applications. However, in this book, we will cover 
 Nginx. The main reason for this decision is its simplicity and performance and it is 
 smaller than Apache.
  
 To install Nginx, use 
 apt-get
 :
  
 $ sudo apt-get install nginx
  
 [sudo] password for abiee:
  
 Reading package lists... Done
  
 Building dependency tree
  
 Reading state information... Done
  
 The following extra packages will be installed:
  
  nginx-common nginx-core
  
 Suggested packages:
  
 [
  222 
 ]
  
 www.it-ebooks.info",NA
Do not run as root,"Running the server process as root can be dangerous. If someone discovers a 
 vulnerability in node or in your application code, then they can cause serious damage to 
 the system. It's always a good idea to create a user to run the application server only:
  
 $ sudo useradd -m production
  
 The 
 m
  option will create a home path located at 
 /home/production
 , where you can 
 clone the project repo:
  
 $ sudo su - production
  
 $ cd ~
  
 $ git clone https://example.com/path/to/the/project.git
  
  
 Figure 9.7 After running node.js process",NA
Process Management,"Anytime you run a program in your computer, it can fail for many reasons: maybe a 
 server that it depends on is turned off or, even worst, an unhandled exception can tear 
 down the running process. That's terrible for production applications as you leave your 
 users without the server until you notice that it is not working.
  
 [
  226 
 ]
  
 www.it-ebooks.info",NA
Summary,"In this chapter, we saw how to run a Node application in the Heroku platform and in a 
 bare metal or virtual machine server with Linux. These two methods to deploy Node 
 applications are simple; however, they are the base for more complex deployments. 
 You can make deployments on Docker containers, for instance. With Docker, you will 
 need to know how to install your application in a fresh Linux installation as we did, 
 and then, manage containers as a process like Heroku does.
  
 In this chapter, we don't see many things related to Backbone; however, if you have a 
 Backbone application and it is backed by Node, you probably want to put your code in 
 production. In this chapter, we have seen how to put the output of the distribution files in 
 a production server.
  
 [
  230 
 ]
  
 www.it-ebooks.info",NA
Authentication,"Most of the web applications use some kind of authorization and authentication 
 subsystems to allow its users to access private information of the application. 
  
 However, the authentication process can be tricky if you don't have a clear idea about 
 how to implement it as Backbone does not provide a hint about how to do it.
  
 Backbone is authentication agnostic, which means that its does not provide objects or 
 tools to implement an authentication strategy. The advantage is that Backbone is not 
 coupled with an authentication mechanism and the disadvantage is that you should care 
 about it.
  
 As Backbone was made with REST APIs in mind, you will have to deal with the 
 authentication mechanisms that are common in that kind of APIs. That's a good reason 
 why Backbone does not impose or provide tools in order to authenticate users.
  
 Another thing to keep in mind is that REST APIs should be stateless, which means that 
 they do not keep track of the requests that you previously made. What it means for you 
 is that if you make a login request, you will expect the server to recognize you on the 
 subsequent requests; however, in a stateless server, it will not remember you.
  
 This may sound crazy if you have not worked with REST web services before; however, 
 you have to authenticate each time you make a requests to the server. That's necessary 
 and there are many available ways to do it; you should consult the API documentation in 
 order to know the exact details of the authentication algorithm.
  
 Despite the many options that are available, they are very similar each other with changes 
 in just some kind of details; however, in essence, they work in a very similar way. 
 Therefore, don't worry about the number of different ways that are available to 
 authenticate; learn the basics and change the details.
  
 [
  231 
 ]
  
 www.it-ebooks.info",NA
Stateless API authentication,"Authenticate against a stateless API implies that you should authenticate each time that 
 you make a request to the server; keep in mind that a stateless server does not keep 
 track of the previous requests. This means that each time you make a request to the 
 server, it will process the petition as the first one.
  
 As sessions are not stored in the server, you should put that information somewhere 
 else. For Backbone applications, the right place to store the session data is the browser, 
 you can use 
 localStorage
  to store and retrieve the session data and JavaScript to 
 manage the session.",NA
HTTP Basic authentication,"The simplest way to authenticate against a RESTFul API is with the HTTP Basic 
 Authentication. The idea behind this is simple; you should include an encoded version 
 of your username and password for every request you make. It may sound risky to 
 send your user and password for each request, and it is. For this reason, it's highly 
 advisable to only use Basic authentication where you have the HTTPS connections 
 enabled:
  
  
 Figure 10.1 Basic authentication schema
  
 The user and password should be sent under the 
 Authentication
  header of the 
 request. Consider the following scenario:
  
 • 
  
 User: myuser
  
 • 
  
 Password: 123456
  
 [
  232 
 ]
  
 www.it-ebooks.info",NA
The OAuth2 authentication,"The OAuth2 protocol was made to share resources among services without the use of a 
 user and password. It is possible that you have used an application where you can 
 authenticate using a social network account. That's OAuth2 in action. The OAuth2 
 authentication is an authorization framework described in RFC 6749, as follows:
  
  
 Figure 10.2 OAuth2 abstract flow
  
 [
  233 
 ]
  
 www.it-ebooks.info",NA
Service applications,"When you want to access the private data of a service such as Facebook, Twitter, 
 Google, and so on, you must register your application with the service first. When you 
 register your application with the service, they will ask you for an application name, 
 description, website, and so on.
  
 [
  234 
 ]
  
 www.it-ebooks.info",NA
OAuth2 grant types,"In the previous section, you have seen the OAuth2 protocol as an abstract schema of 
 authentication. The RFC 6749 document specification describes four different ways to 
 obtain an access token.",NA
Authorization code grant,"Authorization code grant is the most complete authorization flow; its main usage is to 
 access private resources of the user from another server:
  
  
 Figure 10.3 Authorization code grant
  
 [
  235 
 ]
  
 www.it-ebooks.info",NA
Implicit Grant,"This is a simplification of Authorization Code Grant; the usage of implicit grant is for pure 
 frontend applications without server or mobile applications:
  
  
 Figure 10.4 Implicit grant
  
 In the implicit grant, App Server does not exist, therefore, the Backbone App should 
 communicate directly with the API Server. Despite the simplicity of the implicit grant, 
 you should be warned about the security issues.
  
 To minimize this risk, your applications should be secured with HTTPS and do not use 
 this flow type if you don't have it enabled. Another related issue is that this grant type 
 does not issue a refresh token, which means that you should re-login when the access 
 token expires.
  
 [
  236 
 ]
  
 www.it-ebooks.info",NA
Resource Owner Password Credentials Grant,"This grant type is useful when the Backbone App and API Server are the same 
 application. In other words, the frontend application and the backend server are 
 developed by you, which means that you are not accessing to third-party resources.
  
 As your application owns all the resources, you will need the user and password of the 
 application to authenticate it:
  
  
 Figure 10.5 Resource owner password
  
 The preceding diagram is very similar to the Implicit Grant diagram; however, in this 
 case, you don't need to use ClientID and ClientSecret tokens, which simplifies the 
 authentication process.
  
 When you use this grant type, it feels like the classic way of authentication; you should 
 send your user and password to the server and it will then tell you whether your 
 credentials are valid or not. If they are valid, you will receive a valid access token that 
 you can store and use as you want.",NA
Client credentials grant,"Client credentials grant is used when you have a trusted client that accesses the server 
 resources. A business partner, for example. In this grant type, you are not authenticating 
 an user but an application, therefore, you don't need an user or password.
  
 In this grant, you should use ClientID and ClientSecret, if the API Server trusts the 
 client, an access token will be issued.
  
  
 Figure 10.6 Client credentials
  
 [
  237 
 ]
  
 www.it-ebooks.info",NA
Resume,"In the previous sections, you have seen how to use the OAuth2 framework to 
 authenticate against a REST server; in the OAuth2, specifications are described in 
 four ways to make authentication and the use of any one of them depends on the 
 requirements of the application.
  
 However, the goal of the all these grant types is to get an access token that can be used 
 for the next server request. Once you have an access token, the interaction with the API 
 server should be transparent for Backbone App, the token should be send without the 
 knowledge of rest of the application.",NA
Implementing HTTP Basic Authentication,"Let's implement the Basic Auth protocol in 
 Contacts App
 . As you have learned in the 
 previous sections, you will need to add the 
 Authorization
  header for every request 
 that you make to the server in order to be authenticated. From the server side, you will 
 need to read and parse this header.
  
 A useful 
 npm
  package to decode the 
 Authorization
  header has been developed. With 
 the 
 basic-auth
  module, you can read the request headers and return an object with 
 two fields: 
 name
  and 
 pass
 , these fields can be used to authenticate the user. For 
 simplicity, we will use a hardcoded user and password, not a real database:
  
 // server/basicAuthMiddleware.js
  
 var basicAuth = require('basic-auth');
  
 var authorizationRequired = function (req, res, next) {
  
  var credentials = basicAuth(req) || {};
  
  if (credentials.name === 'john' && credentials.pass === 'doe') {
  
  return next();
  
  } else {
  
  return res.sendStatus(401);
  
  }
  
 };
  
 module.exports = authorizationRequired;
  
 [
  238 
 ]
  
 www.it-ebooks.info",NA
Implementing OAuth authentication ,"As we did for Basic Auth, we are going to build a server-side implementation of the 
 OAuth2 protocol. As the Backbone App and Server App are both built by us, the best grant 
 type to choose is 
 Resource Owner Password Credentials Grant
 .
  
 A difference from Basic Auth is that OAuth2 needs to add an endpoint that is used to issue 
 access and refresh tokens. As described in RFC-6749, the requests made to this endpoint 
 should include the following:
  
 The client makes a request to the token endpoint by adding the 
 following parameters using the ""application/x-www-form-
 urlencoded"":
  
 grant_type: REQUIRED.  Value MUST be set to ""password"".
  
 username: REQUIRED.  The resource owner username.
  
 Password: REQUIRED.  The resource owner password.
  
 A valid request will look as shown in the following:
  
 POST /api/oauth/token HTTP/1.1
  
 Host: example.com
  
 Content-Type: application/x-www-form-urlencoded
  
 grant_type=password&username=john&password=doe
  
 Then, the server will respond with a valid access token, an optional refresh token, 
 and a token type; it could contain additional values, as follows:
  
 HTTP/1.1 200 OK 
  
 Content-Type: application/json;charset=UTF-8 
 Cache-Control: no-store 
  
 Pragma: no-cache
  
 {
  
  ""access_token"":""2YotnFZFEjr1zCsicMWpAA"", 
 ""token_type"":""example"",
  
  ""expires_in"":3600,
  
  ""refresh_token"":""tGzv3JOkF0XG5Qx2TlKWIA"", 
 ""example_parameter"":""example_value"" 
  
 }
  
 [
  249 
 ]",NA
Summary ,"Authentication in Backbone applications can be tricky if you don't have a clear vision 
 of how authentication works in REST servers. As Backbone is authentication agnostic, 
 it does not force you to use an authentication mechanism. As a developer, it's your 
 responsibility to create one or adhere to an existing one.
  
 In Backbone Apps, backed by stateless servers, you should move the session handling 
 code to the browser. In the examples shown in this chapter, we used 
 sessionStorage
  
 to store the access tokens; however, you can use another storage solution such as 
 localStorage
  and 
 indexeddb
 , or even cookies.
  
 Then, we saw how to combine the theory with the practical implementation of the 
 Basic Auth and OAuth2 protocols in Contacts App. The implementation was 
 transparent for the rest of the application, therefore, you can switch between the 
 implementations easily.
  
 [
  254 
 ]
  
 www.it-ebooks.info",NA
Index,NA,NA
A,"AJAX 
  
  
 file, uploading with  118, 119 
  
 AMD (Asynchronous Module 
  
   
 Definition)  87 
  
 application dependency  92-94 
  
 authentication 
  
  
 about  231 
  
  
 OAuth authentication  249 
  
  
 stateless API authentication  232 
 avatar photo 
  
  
 displaying  111, 112 
  
  
 uploading, at creation time  119-123 
  
 uploading, to contacts  108-110",NA
B,"Backbone 
  
  
 images, uploading from  112-117 
  
 Backbone applications 
  
  
 collections, testing  193 
  
  
 controllers, testing  198 
  
  
 models, testing  193 
  
  
 subapplication Façade, testing  209, 210 
  
 testing  183, 192 
  
  
 testing tools  184 
  
  
 views, testing  194-197 
  
 Backbone Collections  6 
  
 Backbone objects 
  
  
 responsibilities  4 
  
 Backbone.sync 
  
  
 about  135-138 
  
  
 localStorage, using as cache  138-141
  
 Backbone.Validation plugin 
  
  
 about  82 
  
  
 validating with  82-85 
  
 Browserify 
  
  
 about  91 
  
  
 cyclic dependency, solving  100, 101 
  
 using  91, 92 
  
  
 using, in contacts application  94-99 
 BrowserSync  170, 171",NA
C,"collections 
  
  
 testing  193 
  
 CollectionView 
  
  
 about  28, 29 
  
  
 collection, resetting  34, 35 
  
  
 models, deleting  31, 32 
  
  
 new models, adding  30, 31 
  
  
 views, destroying  33, 34 
  
 CommonJS modules  88, 89 
  
 configuration options, package.json file  
 89 contact details 
  
  
 displaying  48-50 
  
 ContactEditor  201 
  
 contacts 
  
  
 avatar photo, uploading to  108-110 
  
 contacts application 
  
  
 Browserify, using  94-99 
  
  
 developing  7-19 
  
 controllers, Backbone applications 
  
  
 ContactEditor, testing  201-207 
  
  
 dependencies, mocking  198, 199 
  
  
 fake object  199, 200 
  
  
 testing  198
  
 [
  255 
 ]
  
 www.it-ebooks.info",NA
D,"data binding 
  
  
 about  61 
  
  
 with plugins  67 
  
 destroy() operation  135 
  
 development workflow 
  
  
 about  162 
  
  
 BrowserSync  170, 171 
  
  
 creating  166 
  
  
 JavaScript files, building with 
  
   
 Browserify  167, 168 
  
  
 server, running with Express  172, 173 
 Document Object Model (DOM)  5, 23 
 Dynos 
  
  
 about  214 
  
  
 One-off Dynos  215 
  
  
 URL  216 
  
  
 Web Dynos  215 
  
  
 Worker Dynos  215",NA
E,"embedded data binding 
  
  
 about  68 
  
  
 embedded list, binding  69-78 
 Express server 
  
  
 files, sending to  105, 106",NA
F,"fetch() operation  135 
  
 file organization  20 
  
 files 
  
  
 attaching, into resource  106-108 
  
 sending, to Express server  105, 106 
  
 uploading, with AJAX  118, 119",NA
G,"git push command  213 
  
 Git server 
  
  
 URL  216
  
 Grunt  161 
  
 Gulp 
  
  
 about  161 
  
  
 getting started process  166 
  
  
 working  164, 165",NA
H,"Heroku 
  
  
 about  213 
  
  
 Dynos  214 
  
  
 URL  220 
  
  
 using  215-220 
  
 HTTP Basic authentication 
  
 about  232, 233 
  
  
 implementing  238-249 
  
 HTTP server 
  
  
 about  222-225 
  
  
 running, disadvantages  226",NA
I,"images 
  
  
 uploading, from Backbone  112-117 
  
 IndexedDB 
  
  
 about  142, 143 
  
  
 database, deleting  145 
  
  
 database versions  143 
  
  
 elements, adding to object store  146, 147 
  
 in Backbone  149-158 
  
  
 objects, deleting in store  149 
  
  
 queries, performing  147-149 
  
  
 stores, creating  144, 145 
  
 information 
  
  
 editing  50-54",NA
J,"Jasmine 
  
  
 about  185 
  
  
 asynchronous code, testing  189, 190 
  
  
 expectations  186-189 
  
  
 working with  185 
  
 JavaScript files, building with Browserify 
  
 about  167, 168 
  
  
 re-bundling automatically  169, 170 
  
  
 sourcemaps  168, 169
  
 [
  256 
 ]
  
 www.it-ebooks.info",NA
K O,Karma  190-192,NA
L,"layout  38-40 
  
 list 
  
  
 displaying  43-47 
  
 localStorage 
  
  
 about  126 
  
  
 Backbone  128, 129 
  
  
 Backbone models, storing in  131-135 
  
 models, storing in  129, 130 
  
  
 starting with  126-128",NA
M,"mediator pattern  7 
  
 model binding 
  
  
 about  61 
  
  
 issue  61 
  
  
 manual binding  61-64 
  
  
 two-way binding  64-67 
  
 model data validation 
  
  
 about  79 
  
  
 manual validation  79-81 
  
  
 validating, with Backbone.Validation 
   
 plugin  82-85 
  
 Models  5 
  
 models, Backbone applications 
  
  
 testing  193 
  
 models, CollectionView 
  
  
 adding  30, 31 
  
  
 deleting  31, 32 
  
 ModelView  25-28",NA
N,"Node 
  
  
 URL  89 
  
 NPM 
  
  
 using, with package.json  89, 90
  
 OAuth2 authentication 
  
  
 about  233, 234 
  
  
 Access token  234 
  
  
 Authorization server  234 
  
  
 ClientID  235 
  
  
 ClientSecret  235 
  
  
 OAuth2 grant types  235 
  
  
 Resource Owner  234 
  
  
 service applications  234 
  
  
 Web application  234 
  
 OAuth2 grant types 
  
  
 about  235 
  
  
 Authorization code grant  235 
  
  
 Client credentials grant  237 
  
  
 Implicit grant  236 
  
  
 Resource Owner Password Credentials 
   
 grant  237 
  
 OAuth authentication 
  
  
 implementing  249-253 
  
 objects, not provided by Backbone 
  
  
 about  6 
  
  
 subapplication controller  7 
  
  
 subapplication façade  6, 7",NA
P,"package.json 
  
  
 using, with NPM  89, 90 
  
 Platform as a service (PaaS)  
 213 process management  226-
 229 production environment 
  
  
 creating  220-222 
  
 production workflow 
  
  
 creating  174 
  
  
 fonts  177, 178 
  
  
 Gulp useref  174-176 
  
  
 image optimization  177 
  
  
 JavaScript files, bundling for 
  
  
 production  178, 179 
  
 program 
  
  
 failure reasons  226-229
  
 [
  257 
 ]
  
 www.it-ebooks.info",NA
R,"regions  35, 36 
  
 require() function  88 
  
 responsibilities, Backbone objects 
  
 Collections  6 
  
  
 Models  5 
  
  
 routers  6 
  
  
 Views  5",NA
S,"save() operation  135 
  
 spy function  196 
  
 stateless API authentication  232 
  
 subapplication anatomy  3, 4 
  
 subapplication Façade 
  
  
 testing  209, 210 
  
 subapplications based architecture  2, 
 3",NA
T,"task runner  162, 163 
  
 templates 
  
  
 modularizing  101-104 
  
 testing tools 
  
  
 about  184 
  
  
 assertions libraries  184 
  
  
 browser testing  184 
  
  
 faking tool  184 
  
  
 mocking tool  184 
  
  
 module mocking  184
  
  
 stress tools  184 
  
  
 stubbing tool  184 
  
  
 test coverage  184 
  
  
 testing libraries  184 
  
  
 test reports  184 
  
  
 test runners  184 
  
 third-party plugins 
  
  
 rendering  55-58 
  
 TTL (Time to live)  251 
  
 two-way binding, model binding 
  
 about  64-67 
  
  
 references  67",NA
U,"Ubuntu-14.04 box  
 222 
  
 upload file 
  
  
 encoding  123, 124",NA
V,"views 
  
  
 working  37 
  
 views, Backbone applications 
  
 testing  194-197 
  
 view types 
  
  
 CollectionView  24, 28 
  
  
 identifying  24 
  
  
 layout  24, 38, 39 
  
  
 ModelView  24, 25 
  
  
 region  24, 35 
  
  
 summarizing  41-43
  
 [
  258 
 ]",NA
Thank you for buying ,NA,NA
Mastering Backbone.js,NA,NA
About Packt Publishing,"Packt, pronounced 'packed', published its first book, 
 Mastering phpMyAdmin for Effective MySQL 
 Management
 , in April 2004, and subsequently continued to specialize in publishing highly 
 focused books on specific technologies and solutions.
  
 Our books and publications share the experiences of your fellow IT professionals in adapting and 
 customizing today's systems, applications, and frameworks. Our solution-based books give you the 
 knowledge and power to customize the software and technologies you're using to get the job done. 
 Packt books are more specific and less general than the IT books you have seen in the past. Our 
 unique business model allows us to bring you more focused information, giving you more of what 
 you need to know, and less of what you don't.
  
 Packt is a modern yet unique publishing company that focuses on producing quality, 
 cutting-edge books for communities of developers, administrators, and newbies alike. For 
 more information, please visit our website at 
 www.packtpub.com
 .",NA
About Packt Open Source,"In 2010, Packt launched two new brands, Packt Open Source and Packt Enterprise, in order to 
 continue its focus on specialization. This book is part of the Packt Open Source brand, home to 
 books published on software built around open source licenses, and offering information to 
 anybody from advanced developers to budding web designers. The Open Source brand also runs 
 Packt's Open Source Royalty Scheme, by which Packt gives a royalty to each open source project 
 about whose software a book is sold.",NA
Writing for Packt,"We welcome all inquiries from people who are interested in authoring. Book proposals should be 
 sent to 
 author@packtpub.com
 . If your book idea is still at an early stage and you would like to 
 discuss it first before writing a formal book proposal, then please contact us; one of our 
 commissioning editors will get in touch with you. 
  
 We're not just looking for published authors; if you have strong technical skills but no writing 
 experience, our experienced editors can help you develop a writing career, or simply get some 
 additional reward for your expertise.
  
 www.it-ebooks.info",NA
Backbone.js Blueprints ,"ISBN: 978-1-78328-699-7              Paperback: 256 pages
  
 Understand Backbone.js pragmatically by building 
 seven different applications from scratch
  
 1. 
  
 2. 
  
 3. 
  
 Gain insights into the inner working of 
 Backbone to leverage it better.
  
 Exploit Backbone combined with the features of a 
 Node powered server.
  
 Learn how to build seven step-by-step 
 frontend applications.",NA
Backbone.js Cookbook,"ISBN: 978-1-78216-272-8             Paperback: 282 pages
  
 Over 80 recipes for creating outstanding web 
  
 applications with Backbone.js, leveraging MVC, and 
 REST architecture principles
  
 1. 
  
 2. 
  
 3. 
  
 4. 
  
 Easy-to-follow recipes to build dynamic web 
 applications.
  
 Learn how to integrate with various frontend 
 and mobile frameworks.
  
 Synchronize data with a RESTful backend and 
 HTML5 local storage.
  
 Learn how to optimize and test Backbone 
 applications.
  
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
Backbone.js Essentials ,"ISBN: 978-1-78439-479-0            Paperback: 180 pages
  
 Build amazing high-performance web applications 
 using Backbone.js
  
 1. 
  
 2. 
  
 3. 
  
 Construct top-notch web applications by 
 mastering the powerful tools provided by 
 Backbone.js.
  
 Gain insights into how to simplify data 
 management and create single-page web 
 applications with powerful user interfaces.
  
 This is a fast-paced guide on how to test, 
  
 document, and leverage third-party libraries, 
 and helps you get the most out of Backbone.js.",NA
Backbone.js Patterns and Best ,NA,NA
Practices,"ISBN: 978-1-78328-357-6             Paperback: 174 pages
  
 A one-stop guide to best practices and design 
 patterns when building applications using 
 Backbone.js
  
 1. 
  
 2. 
  
 3. 
  
 Offers solutions to common Backbone.js related 
 problems that most developers face.
  
 Shows you how to use custom widgets, 
 plugins, and mixins to make your code 
 reusable.
  
 Describes patterns and best practices for large 
 scale JavaScript application architecture and unit 
 testing applications with QUnit and 
  
 SinonJS frameworks.
  
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
