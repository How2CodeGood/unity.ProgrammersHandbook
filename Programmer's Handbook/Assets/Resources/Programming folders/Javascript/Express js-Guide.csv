Larger Text,Smaller Text,Symbol
Express.js Guide ,NA,NA
The Comprehensive Book on Express.js ,NA,NA
Azat Mardan ,"This book is for sale at
  http://leanpub.com/express 
  
 This version was published on 2014-05-28
  
  
 This is a
  Leanpub
  book. Leanpub empowers authors and publishers with the Lean 
 Publishing process.
  Lean Publishing
  is the act of publishing an in-progress ebook using 
 lightweight tools and many iterations to get reader feedback, pivot until you have the right 
 book and build traction once you do.
  
 ©2013 - 2014 Azat Mardan
  
 www.allitebooks.com",NA
Tweet This Book!,"Please help Azat Mardan by spreading the word about this book on
  Twitter
 !
  
 The suggested tweet for this book is: 
  
 I’m reading Express.js Guide — the most popular Node.js framework’s manual by @azat_co 
 #RPJS The suggested hashtag for this book is
  #RPJS
 .
  
 Find out what other people are saying about the book by clicking on this link to search 
 for this hashtag on Twitter: 
  
 https://twitter.com/search?q=#RPJS
  
 www.allitebooks.com",NA
Also By,NA,NA
 Azat Mardan ,"Rapid Prototyping with JS 
  
 Oh My JS 
  
 JavaScript and Node FUNdamentals
  
 www.allitebooks.com",NA
Contents,"Foreword
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 i
  
 Acknowledgment
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 iii
  
 Introduction
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 iv
  
 Why . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 iv
  
 What This Book Is . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 iv
  
 What This Book is Not . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 v
  
 Who This Book is For . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 v
  
 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 v
  
 Navigation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vi
  
 How to Use the Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vii
  
 Examples 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vii
  
 About the Author . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vii
  
 Errata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . viii
  
 Contact Us . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ix",NA
I ,NA,NA
Quick Start ,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
1,"1 What is Express.js? 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 2
  
 2 How Express.js Works
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 3
  
 3 Installation
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 4
  
 4 Hello World Example
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 1
 1
  
 5 CLI
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 1
 7",NA
II The Interface ,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
 26,"8 Configuration 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 27
  
 8.1 app.set() and app.get() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 27
  
 8.2 app.enable() and app.disable() 
  
 . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 27
  
 8.3 app.enabled() and app.disabled() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 28
  
 9 Settings
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 2
 9
  
 9.1 env . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 29
  
 9.2 view cache . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 29
  
 9.3 view engine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 29
  
 9.4 views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 31
  
 9.5 trust proxy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 31
  
 9.6 jsonp callback name . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 31
  
 9.7 json replacer and json spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 32
  
 9.8 case sensitive routing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 32
  
 9.9 strict routing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 32
  
 9.10 x-powered-by . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 3
 2
  
 9.11 etag 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 32
  
 9.12 subdomain offset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 33
  
 10 Environments 
  
 . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 34
  
 10.1 app.configure() 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 34
  
 11 Applying Middleware
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 3
 6",NA
III,NA,NA
Tips and Tricks,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
 104,"21 Abstraction
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  105
  
 22 Using Databases in Modules
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  109",NA
IV ,NA,NA
Tutorials and Examples,. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA
 142,"33 Instagram Gallery
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  143 
 33.1 A File Structure . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144 33.2 Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . 145 33.3 Node.js Server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145 33.4 
 Handlebars Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 33.5 Conclusion . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
  
 34 Todo App
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  149 
 34.1 Scaffolding . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 34.2 MongoDB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 156 34.3 Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156 34.4 app.js . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 34.5 Routes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . 164 34.6 Jades . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169 34.7 LESS . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 34.8 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . 177
  
 35 REST API
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  178
  
 www.allitebooks.com",NA
Foreword,"Dear reader,
  
 You are reading a book which will lead you to the understanding and fluent use of the 
 Express.js framework — the
  de facto
  standard in web application programming on Node.js. 
 I would especially recommend this book because it was written by a practicing engineer, 
 who has comprehensive knowledge of the full stack of web application development, and 
 Express.js in particular.
  
 Azat and I worked on the same Node.js/Express.js code base at
  Storify¹
  — the social media 
 curation tool that The Washington Post, CNN, BBC, The White House press corps and other 
 news corps use. It was recently acquired by
  LiveFyre²
 . Right before the Express.js Guide’s 
 release, Azat asked me to write the foreword, because it will sound objective, sincere and 
 unbiased coming from the creator of
  another
  Node.js framework:
  CompoundJS³
 .
  
 However, nobody is reading forewords. So, instead of a foreword, I’ll share my story. 
 Actually, I never thought it was worth sharing and there’s definitely nothing exciting about 
 it. But from the other point of view — thousands of young programmers living similar 
 ordinary lives - it could be inspiring: it’s a common story, but a kind of successful one.
  
 My path to web development started when I was a student. I’d joined a team as a junior 
 PHP programmer. I was working here for about five years, and the main lesson I have 
 learned was that education is nothing compared to real work experience.
  
 The next page of my professional life was my work in outsourcing (PHP and Ruby on Rails). 
 And then I found Node.js. It was something that I always wanted: processes that do not 
 have to wait for DB/IO operations, which are keeping all the resources, but doing 
 something useful instead. That’s why I started using it — it’s more efficient compared to 
 synchronous programming environments. By “efficient” I don’t mean speed of processing, 
 but rather more flexibility in programming style.
  
 As a good example of its flexibility, I can share some solutions I recently programmed for a 
 Redis adapter for the
  Jugglingdb ORM⁴
 . The problem: during peaks in website usage, we are 
 running a lot of db queries to serve pages, and most of the queries are the same. The 
 obvious solution is to cache results of the queries, but this solution requires additional 
 coding and some logic for cache invalidation.
  
 We’ve come up with a better solution: cache queries and not results. When a query comes, 
 we don’t execute it immediately; instead, we wait for some time, collect identical queries, 
 then execute the query once and run multiple callbacks to serve all clients. This solution is 
 simple and requires no
  
 ¹
 http://storify.com
  
 ²
 http://livefyre.com
  
 ³
 http://compoundjs.com",NA
Acknowledgment,"This book would not be possible without the existence of my parents, the Internet, and 
 JavaScript. Also, words cannot express my gratitude to Ryan Dahl and TJ Holowaychuk.
  
 In addition to that, special thanks to General Assembly, pariSOMA and Marakana for giving 
 me the opportunities to test my instructions out in the wild; to Peter Armstrong for 
 LeanPub; to Sahil Lavingia for Gumroad; to Daring Fireball for Markdown; to Metaclassy for 
 Byword; to Fred Zirdung for advice; and to Rachmad Adv for the splendid cover!",NA
Introduction,NA,NA
Summary,"In this part, we’ll go over why this book was written, who might benefit from the book and 
 how to use it most efficiently.",NA
Why,"Express.js is the most popular Node.js web framework yet. As of this writing (September of 
 2013), there are no books solely dedicated to it. Its
  official website⁷
  has bits of insights for 
 advanced Node.js programmers. However, I’ve found that many people — including those 
 who go through the
  HackReactor⁸
  program and come to my Node.js classes at General 
 Assembly and pariSOMA— are interested in a definitive manual, one that would cover how 
 all the different components of Express.js work together in real life. The goal of The 
 Express.js Guide is to be that resource.",NA
What This Book Is,"Express.js Guide is an exhaustive book on
  one
  particular library. There are four distinct 
 parts:
  
 • A hands-on quick start walkthrough to get a taste of the framework
  
 • An Express.js API
  3.3.5⁹
  description which can be used as a reference
  
 • The best practices for code organization and patterns
  
 • Tutorials (meticulously depicted coding exercises) and examples (less detailed 
 explanations of more complex apps) for the real world.
  
 The Express.js Guide covers middleware, command-line interface and scaffolding, 
 rendering tem-plates, extracting params from dynamic URLs, parsing payloads and cookies, 
 managing authentica-tion with sessions, error handling, and prepping apps for production.
  
 For more details on what the book covers, please refer to the
  Table of Contents
 .
  
 ⁷
 http://expressjs.com
  
 ⁸
 http://hackreactor.com
  
 ⁹
 https://github.com/visionmedia/express/tree
 /3.3.5",NA
What This Book is Not,"This book is
  not
  an introduction to Node.js, nor is it a book that covers all aspects of 
 building a modern day web application, e.g., websockets, databases, and (of course) front-
 end development. Also keep in mind that readers
  won’t find
  Express.js Guide aids for 
 learning programming and/or JavaScript fundamentals here.
  This is not a beginners’ 
 book
 .
  
 For an introduction to Node.js, MongoDB, and front-end development with Backbone.js, you 
 might want to take a look at Azat’s book
  Rapid Prototyping with JS: Agile JavaScript 
 Development¹⁰
 .
  
 In the real world, and especially in Node.js development, due to its modularized 
 philosophy, we seldom use just a single framework. In this book, we have tried to stick to 
 Express.js and leave everything else out as much as possible, without compromising the 
 usefulness of the examples. Therefore, we intentionally left out some important chunks of 
 web development — for example databases, authentication and testing. Although these 
 elements are present in tutorials and examples, they’re not explained in detail. For those 
 materials, you could take a look at the books in the
  Related Reading and Resources
  section 
 at the end of this book.",NA
Who This Book is For,"This book is for people fluent in programming and front-end JavaScript. To get the most 
 benefits, readers must be familiar with basic Node.js concepts like
  process
  and
  global
 , and 
 know core modules, including stream, cluster, and buffer.
  
 If you’re thinking about starting a Node.js project, or about rewriting an existing one, and 
 your weapon of choice is Express.js — this guide is for you! It will answer most of your 
 “how” and “why”questions.",NA
Notation,"The code blocks will look like this:
  console.log('Hello reader!');
 . The terminal and console 
 commands will have the corresponding prefixes
  $
  and
  >
 .
  
 If we mention and use a specific file or a folder, those names will be monospaced as well:
  
 index.js
 .
  
 If there is a class or a module name in the text, it will be in bold type, e.g.,
  superagent
 .
  
 The new resources will only be hot-linked the first time we mention them.
  
 ¹⁰
 http://rpjs.co",NA
Navigation,"In PDF, EPUB/iPad and Mobi/Kindle versions of this book, you can use the
  Table of 
 Contents
  for navigation. It contains internal links that readers can use to jump to the most 
 interesting parts or chapters.
  
 For faster navigation between parts, chapters and sections of this book, please use the 
 book’s navigation pane which is based on the Table of Contents (the screenshot is below).
  
  
 The Table of Contents pane in the Mac OS X Preview app.
  
 The PDF version of the book is suitable for printing on US Letter paper because all links are 
 in the footnotes.",NA
How to Use the Book,"If you’re contemplating using Express.js or writing an app with it, read the whole book 
 from beginning to end. However, if you’re somewhat familiar with the framework, jump 
 straight to a question at hand. You can also skim through chapters if you like. The more 
 advanced chapters deal with code organization and getting apps to production.",NA
Examples,"The book contains code snippets and run-ready examples. The latter are available in the GitHub 
 repository at
  github.com/azat-co/expressjsguide¹¹
 . Additional examples can be found at
  
 http://github.com/azat-co/todo-express¹²
 ,
  github.com/azat-co/sfy-gallery¹³
  and
  github.com/azat-
 co/hackhall¹⁴
 .
  
 The provided examples were written and tested
  only
  with the given specific versions of 
 dependen-cies. Because Node.js and its ecosystem of modules are being developed rapidly, 
 please pay attention to whether new versions have breaking changes. Here is the list of 
 versions that we’ve used:
  
 • Express.js v3.3.5
  
 • Google Chrome Version 
 28.0.1500.95
  
 • Node.js v0.10.12
  
 • MongoDB v2.2.2
  
 • Redis v2.6.7
  
 • NPM v1.2.32",NA
About the Author,"Azat Mardan: A software engineer, author and yogi.
  
 ¹¹
 http://github.com/azat-
 co/expressjsguide
  
 ¹²
 http://github.com/azat-co/todo-
 express",NA
Errata,"Please help us make this book better by submitting GitHub issues to the
  expressjsguide 
 repository³⁵
 : 
 http://github.com/azat-co/expressjsguide/issues
 . Or you can submit issues 
 via other means of
  
 ¹⁵
 http://docusign.com
  
 ¹⁶
 http://storify.com
  
 ¹⁷
 http://livefyre.com
  
 ¹⁸
 http://www.crunchbase.com/company/gizmo
  
 ¹⁹
 http://500.co/
  
 ²⁰
 http://nih.gov
  
 ²¹
 http://ncbi.nlm.nih.gov
  
 ²²
 http://fdic.gov
  
 ²³
 http://lockheedmartin.com
  
 ²⁴
 http://angelhack.com
  
 ²⁵
 http://fashionmetric.com
  
 ²⁶
 http://generalassemb.ly
  
 ²⁷
 http://hackreactor.com
  
 ²⁸
 http://parisoma.com
  
 ²⁹
 http://marakana.com
  
 ³⁰
 http://webapplog.com
  
 ³¹
 http://expressjsguide.com/assets/img/expressjs-
 tutorial.png
  
 ³²
 http://expressjsguide.com
  
 ³³
 http://rpjs.co",NA
Contact Us,"Let’s be friends on the Internet!
  
 • Tweet Node.js question on Twitter:
  @azat_co³⁶
  
 • Follow Azat on Facebook:
  
 facebook.com/profile.php?id=1640484994³⁷
 • Website:
  
 expressjsguide.com³⁸
  
 • GitHub:
  github.com/azat-co/rpjs³⁹
  
 Other Ways to Reach Us
  
 • Email Azat directly:
  hi@azat.co⁴⁰
  
 • Google Group:
  rpjs@googlegroups.com⁴¹
  and
  
 https://groups.google.com/forum/#!forum/rpjs
 • Blog:
  webapplog.com⁴²
  
 •
  HackHall⁴³
 : community for hackers, hipsters and pirates
  
 Share on Twitter
  with ClickToTweet link:
  http://clicktotweet.com/HDUx0
 , or just click:
  
 “I’m reading Express.js Guide: The Comprehensive Book on Express.js by 
 @azat_co http://expressjsguide.com #nodejs #expressjs”⁴⁴
  
 ³⁶
 https://twitter.com/azat_co
  
 ³⁷
 https://www.facebook.com/profile.php?id=16404
 84994
  
 ³⁸
 http://expressjsguide.com/
  
 ³⁹
 https://github.com/azat-co/expressjsguide
  
 ⁴⁰
 mailto:hi@azat.co
  
 ⁴¹
 mailto:rpjs@googlegroups.com
  
 ⁴²
 http://webapplog.com
  
 ⁴³
 http://hackhall.com
  
 ⁴⁴
 http://ctt.ec/3zyJc",NA
I Quick Start ,NA,NA
Summary,"In this part, we’ll briefly go over what Express.js is, install it, build a few simple applications, 
 and 
 begin to touch on configurations.",NA
1 What is Express.js?,"Express.js is a web framework which is based on the core Node.js
  http
  module and
  
 Connect¹
 components. Those components are called middlewares. They are the cornerstone 
 of the frame-work’s philosophy, i.e.,
  configuration over convention
 . In other words, 
 developers are free to pick whatever libraries they need for a particular project which 
 provides them with flexibility and high customization.
  
 If you wrote any serious apps using only the core Node.js modules, you most likely found 
 yourself reinventing the wheel by constantly writing the same code for the similar tasks, 
 such as:
  
 • Parsing of HTTP request bodies
  
 • Parsing of cookies
  
 • Managing sessions
  
 • Organizing routes with a chain of
  if
  conditions based on URL paths and HTTP methods 
 of the requests
  
 • Determining proper response headers based on data types
  
 Express.js solves these and many other problems. It also provides an MVC-like structure for 
 your web apps. Those apps could vary from barebone back-end-only REST APIs to full-
 blown highly scalable full-stack (with
  jade-browser²
  and
  Socket.IO³
 ) real-time web apps.
  
 Some developers familiar with Ruby compare Express.js to Sinatra, which has a very 
 different approach contrary to the Ruby on Rails framework.
  
 ¹
 http://www.senchalabs.org/connect
 /
  
 ²
 https://npmjs.org/package/jade-
 browser
  
 ³
 http://socket.io",NA
2 How Express.js Works,"Express.js usually has an entry point, a.k.a., a main file. In that file, we perform the following 
 steps:
  
 1. Include third-party dependencies as well as our own modules such as controllers, 
 utilities, helpers and models 
  
 2. Configure Express.js app settings such as the template engine and its files’ extensions 
 3. Define middlewares such as error handlers, static files folder, cookies and other 
 parsers 4. Define routes 
  
 5. Connect to databases such as MongoDB, Redis or MySQL 
  
 6. Start the app",NA
Tip,"In the advanced case (usually leading to deployment into production), we might 
 want to use the
  forever¹
  module. We can also utilize recently added clusters (as 
 outlined in the
  Tips and Tricks
  part) to spawn multiple workers. 
 When Express.js app is running, it listens to requests. Each incoming request is processed 
 according to a defined chain of middlewares and routes starting from top to bottom. This 
 aspect is
  important 
 because it allows you to control the execution flow. For example, we 
 can have multiple functions handling each request; and some of those functions will be in 
 the middle (hence the name middleware):
  
 1. Parse cookie information and go to the next step when done 
  
 2. Parse parameters from the URL and go to the next step when done 
  
 3. Get the information from the database based on the value of the parameter if user is 
 authorized (cookie/session), and go to the next step if there is a match 
  
 4. Display the data and end the response
  
 ¹
 https://npmjs.org/package/forever",NA
3 Installation ,"Express.js comes in two versions: 
  
  
 1. Command line tool for scaffolding 
  
  
 2. Module in your Node.js app, i.e., actual dependency 
  
 To install the former, run
  $ npm install -g express
  from anywhere on your Mac/Linux machine. 
 This will download and link
  $ express
  terminal command to the proper path so that we can 
 later access its command-line interface (CLI) when creating new apps.
  
 Of course, we can be more specific and tell NPM to install v3.3.5:
  $ npm install -g express@3.3.5
 .",NA
Note ,"Most likely, your system will require a root/administrator right to write to 
 the folder. In 
 this case, you’ll need
  $ sudo npm install -g express
 .",NA
Note ,"If you attempt to run the aforementioned
  $ npm install express
  command 
 without  
 package.json
  file or
  node_modules
  folder, the
  smart
  NPM will traverse up the directory 
  
 tree to the folder that has either of those two things. This behavior somewhat 
 mimics  Git’s logic. For more information on NPM installation algorithm, please refer to
  the 
 official 
  
 documentation¹
 . 
 Alternatively, we can update the
  package.json
  file by specifying the dependency (
  ""express"": 
 ""3.3.x""
  or
  ""express"": ""3.3.5"") and run
  $ npm install‘.
  
 The
  package.json
  file with an added Express.js v3.3.5 dependency:
  
 1
  
 {
  
 ""name""
 :
  ""expressjsguide""
 ,
  
 2
  
 3
  
 ""version""
 :
  ""0.0.1""
 ,
  
 4
  
 ""description""
 :
  """"
 ,
  
 5
  
 ""main""
 :
  ""index.js""
 ,
  
 6
  
 ""scripts""
 :
  {
  
 7
  
 ""test""
 :
  ""echo
  \""
 Error: no test specified
 \""
  && exit 1""
  
 8
  
 },
  
 9
  
 ""dependencies""
 :
  {
  
 10
  
 ""express""
 :
  ""3.3.5""
  
  
 ¹
 https://npmjs.org/doc/folders.html",NA
4 Hello World Example,"In this chapter, to get our feet wet, we’ll build the quintessential programming example, the 
 “Hello World” app. If you’ve built some variation of this Express.js app (maybe following 
 some online tutorial), feel free to skip to the later chapters of the book (e.g.,
  The Interface
  
 part).
  
 In the folder
  expressjsguide
 , create a
  hello.js
  file. Use your favorite text editor, such as VIM, 
 Emacs, Sublime Text 2 or TextMate. The file
  hello.js
  server will utilize Express.js; therefore, 
 let’s include this library:
  
 1 
  
 var express
  =
  require(
 '
 express
 '
 );
  
 Now we can create an application:
  
 1 
  
 var app
  =
  express();
  
 The application is a web server that will run locally on port 3000:
  
 1 
  
 var port
  = 3000
 ;
  
 Let’s define
  a wildcard route
  (
 *
 ) with
  app.get()
  function:
  
 1 
  
 app.get(
 '*'
 ,
  function
 (req, res){
  
 2 
 res.end(
 'Hello World'
 );
  
 3 
  
 });
  
 The
  app.get()
  function above accepts
  regular expressions¹
  of the URL patterns in a string 
 format. In our example, we’re processing all URLs with the wildcard
  *
  character.
  
 The second parameter to the
  app.get()
  is
  a request handler
 . A typical Express.js request 
 handler is similar to the one we pass as a callback to the native/core Node.js
  
 http.createServer()
  method.
  
 For those unfamiliar with the core
  http
  module, request handler is a function that will be 
 executed every time the server receives a particular request, usually defined by HTTP 
 method, e.g.,
  GET
 , and the URL path, i.e., URL without the protocol, host and port.
  
 The Express.js request handler needs at least two parameters — more on this later in the
  
 Error Handling
  section — request or simply
  req
 , and response or just
  res
 . Similarly to their 
 core counterparts, we can utilize readable and writable
  streams interfaces²
  via
  res.pipe()
  
 and/or 
 res.on('data', function(chunk) {...})
 .
  
 Lastly, we start the Express.js web server and output a user-friendly terminal message in a 
 callback:",NA
Note,"res.send()
  is a special Express.js method that conveniently goes beyond what our old 
 friend from core
  http
  module
  res.end()
  does. For example, the former automatically 
 adds 
 a
  Content-Length
  HTTP header for us. It also augments
  Content-Type
  based on the data 
 provided to it — more on this later in the
  Response
  chapter. 
 The full source code of the
  hello-name.js
  file which is also in
  GitHub⁶
 :
  
 1 
  
 var
  express
  =
  require(
 'express'
 );
  
 2 
  
 var
  port
  = 3000
 ;
  
 3 
  
 var
  app
  =
  express();
  
 4",NA
5 CLI,"Comparable to Ruby on Rails and many other web frameworks, Express.js comes with a 
 command-line interface for jump-starting your development process. The CLI generates a 
 basic foundation for the most common cases.
  
 If you followed the global installation instructions in the
  Installation
  chapter, you should be 
 able to see the version number if you run the
  $ express -V
  form
  anywhere
  on your machine. 
 If we type 
 $ express -h
  or
  $ express --help
 , we’ll get the list of available options and their usage:
  
 To generate a skeleton Express.js app, we need to run a terminal command:
  express [options] 
 [dir|appname]
  where options are:
  
 •
  -s
  or
  --sessions
  adds session support
  
 •
  -e
  or
  --ejs
  adds
  EJS¹
  engine support, by default
  Jade²
  is used
  
 •
  -J
  or
  --jshtml
  adds
  JSHTML³
  engine support, by default Jade is used
  
 •
  -H
  or
  --hogan
  adds hogan.js engine support
  
 •
  -c <engine>
  or
  --css <engine>
  adds stylesheet
  <engine>
  support (e.g.,
  LESS⁴
  or
  Stylus⁵
 ), by 
 default plain CSS is used
  
 •
  -f
  or
  --force
  forces app generation on non-empty directory
  
 If the dir/appname option is omitted, Express.js will create files using the current folder as 
 the base for the project. Otherwise, the application will be under the specified directory.
  
 For the sake of experimenting, let’s run this command:
  $ express -s -e -c less -f cli-app
 . Here is 
 what will be generated:
  
 ¹
 http://embeddedjs.com/
  
 ²
 http://jade-lang.com/tutorial/
  
 ³
 http://james.padolsey.com/javascript/introducing-
 jshtml/
  
 ⁴
 http://lesscss.org/
  
 ⁵
 http://learnboost.github.io/stylus/",NA
6 Watching for File Changes,"This topic is little bit outside of Express.js, but we thought it so important that it’s worth 
 mentioning. Node.js applications are stored in memory, and if we make changes to the 
 source code, we need to restart the process, i.e., node.
  
 There are brilliant tools that can leverage
  watch¹
  method from the core Node.js
  fs
  module 
 and restart our servers when we save changes from an editor:
  
 •
  supervisor²
  (
 GitHub³
 )
  
 •
  up⁴
  (
 GitHub⁵
 )
  
 •
  node-dev⁶
  (
 GitHub⁷
 )
  
 •
  nodemon⁸
  (
 GitHub⁹
 )",NA
Tip,"It’s good to know that Express.js reloads a template file for every new request by 
 default. 
 So, no server restart is necessary. However, we can cache templates by enabling the
  
 view
  
 cache
  setting, which we’ll cover at length later in the book. 
 ¹
 http://nodejs.org/docs/latest/api/fs.html#fs_fs_watch_filename_options_l
 istener
 ²
 https://npmjs.org/package/supervisor
  
 ³
 https://github.com/isaacs/node-supervisor
  
 ⁴
 https://npmjs.org/package/up
  
 ⁵
 https://github.com/LearnBoost/up
  
 ⁶
 https://npmjs.org/package/node-dev
  
 ⁷
 https://github.com/fgnass/node-dev
  
 ⁸
 https://npmjs.org/package/nodemon
  
 ⁹
 https://github.com/remy/nodemon",NA
7 MVC Structure and Modules,"Express.js is a highly configurable framework, which means that we can apply any structure 
 we
  
 find suitable. As we’ve observed in the previous chapter
  CLI
 , this tool generates a few 
 folders for
  
 us right off the bat:
  public
 ,
  views
  and
  routes
 . What is lacking in order to adhere to the general
  
 MVC paradigm is the model. If you use something like Mongoose, you might want to create 
 a folder
  
 models
  and put the Schema objects there. More advanced applications might have a nested 
 folder
  
 structure similar to this:
  
 1 
  
 .
  
 2
  
 ├──
  app.js
  
 3
  
 ├──
  package.json
  
 4
  
 ├──
  views
  
 5
  
 └──
  *
 .jade
  
 6
  
 ├──
  routes
  
 7
  
 └──
  *
 .js
  
 8
  
 ├──
  models
  
 9
  
 └──
  *
 .js
  
 10
  
 ├──
  config
  
 11
  
 └──
  *
 .js
  
 12
  
 ├──
  public
  
 13
  
 ├──
  javascripts
  
 14
  
 └──
  *
 .js
  
 15
  
 ├──
  images
  
 16
  
 └──
  *
 .png,
  *
 .jpg
  
 17
  
 └──
  stylesheets
  
 18
  
 └──
  *
 .less,
  *
 .styl
  
 19
  
 ├──
  test
  
 20
  
 └──
  *
 .js
  
 21
  
 └──
  logs
  
 22
  
 └──
  *
 .log
  
 The best practice is to have static assets under a special folder. Those assets could also be 
 written in
  
 compilable languages like CoffeeScript or LESS.",NA
II The ,NA,NA
Interface ,NA,NA
Summary,"This part can be used as a standalone reference for the Express.js API, because it contains 
 descriptions of all the main methods and properties, as well as short examples and explanations.",NA
8 Configuration,NA,NA
8.1 app.set() and app.get(),"The method
  app.set(name, value)
  accepts two parameters: name and value, and as you might
  
 guess, it sets the value for the name. For example, we often want to store the value of the 
 port on
  
 which we plan to start our server:
  
 1 
  
 app.set(
 '
 port
 '
 ,
  3000
 );
  
 Or, for a more advanced and realistic use case, we can grab the port from system 
 environment
  
 variable PORT:
  
 1 
  
 app.set(
 '
 port
 '
 , process.env.PORT
  || 3000
 );
  
 The name value could be an Express.js setting or an arbitrary string.
  
 To get the value, we can use
  app.set(name)
  with a
  single
  parameter or more explicit method
  
 app.get(name)
 , for example:
  
 1 
  
 console.log(
 '
 Express server listening on port
  '
  +
  app.get(
 '
 port
 '
 ));
  
 The
  app.set()
  also exposes variables to templates app-wide, e.g.,
  
 1 
  
 app.set(
 'appName'
 ,
  'HackHall'
 );
  
 Will be available in
  all
  templates, e.g., in a Jade template layout, this would be valid:
  
 1 
  
 doctype
  5
  
 2 
  
 html
  
 3 
 head
  
 4 
  
 title
 = appName
  
 5 
 body
  
 6 
  
 block
  content",NA
8.2 app.enable() and app.disable(),"There are some settings that, instead of strings, can only be set to boolean false or true. For 
 such flags
  
 there are shorthands, so as an alternative to the
  app.set(name, true)
  and
  app.set(name, false)
  
 functions, we can use the concise
  app.enable(name)
  and
  app.disable(name)
  calls accordingly.",NA
8.3 app.enabled() and app.disabled(),"To check whether the aforementioned values equal true or false, we can call methods
  
 app.enabled(name)
  
 and
  app.disabled(name)
 . For example:
  
 1 
  
 app.disable(
 '
 etag
 '
 );
  
 2 
  
 console.log(app.disabled(
 '
 etab
 '
 ));
  
 will output true in the context of the Express.js app.",NA
9 Settings,"This is one of the places where Express.js shines! All the configurations are very self-
 explanatory and easy to read and understand.",NA
9.1 env,"This variable is used to store the current environment mode for this particular Node.js 
 process. The value is automatically set by Express.js from process.env.NODE_ENV (which is 
 fed to Node.js through an environmental variable of the executing machine) or if that is not 
 set, to the
  development 
 value.
  
 The other most common values for
  env
  setting are:
  
 •
  test
  
 •
  stage
  
 •
  preview
  
 •
  production
  
 We can augment the
  env
  param by adding
  app.set('env', 'preview');
  or
  process.env.NODE_-
 ENV=preview
  in our code. However, the better way is to start an app with
  $ NODE_ENV=preview 
 node app
  or set the NODE_ENV variable on the machine.
  
 Knowing in what mode the application runs is very important because logic related to error 
 handling, compilation of stylesheets, and rendering of the templates can differ dramatically. 
 Needless to say, databases and hostnames are different from environment to environment.",NA
9.2 view cache,"This flag, if set to false, which is the default, allows for painless development because 
 templates are read each time the server requests them. On the other hand, if
  view cache
  is 
 true, it facilitates templates compilation caching which is a desired behavior in production.
  
 If the previous setting
  env
  is
  production
 , then this is enabled by default.",NA
9.3 view engine,"view engine
  holds the template file extension, e.g., ‘ext’ or ‘jade’, to utilize if the file extension 
 is not passed to the
  res.render()
  function inside of the request handler.
  
 For example, if we comment out this line from
  cli-app/app.js
  example:",NA
9.4 views,"The
  views
  setting is an absolute path to a directory with templates. This setting defaults to
  
 ./views 
 relative to the main application file, e.g.,
  app.js
 , or the file where the
  __dirname
  global is 
 called.
  
 As we mentioned above in the
  MVC Structure and Modules
  chapter, changing template 
 folder name is trivial, e.g.,
  
 1 
  
 app.set(
 '
 views
 '
 , __dirname
  +
  '
 /
 templates
 '
 );",NA
9.5 trust proxy,"Set
  trust proxy
  to true if your Node.js app is working behind reverse proxy such as Varnish or 
 Ng-inx. This will permit trusting in the
  X-Forwarded-*
  headers, e.g.,
  X-Forwarded-Proto
  
 (req.protocol) or
  X-Forwarder-For
  (req.ips).
  
 trust proxy
  is disabled by default.
  
 Examples:
  
 1 
  
 app.set(
 '
 trust proxy
 '
 ,
  true
 );",NA
9.6 jsonp callback name,"If you’re building an application that serves front-end clients from different domains and 
 you don’t want to apply
  cross-origin resource sharing¹
  (CORS) mechanism, then JSONP is 
 the way to go along with the
  res.jsonp()
  method of Express.js.
  
 The default callback name, which is a prefix for our JSONP response, is usually provided in 
 the query string of the request with the name
  callback
 , e.g.,
  ?callback=updateView
 . However, if 
 you want to use something different, just set the setting
  jsonp callback name
  to that value, e.g., 
 for the requests with a query string param
  ?cb=updateView
 , we can use this:
  
 1 
  
 app.set(
 '
 jsonp callback name
 '
 ,
  '
 cb
 '
 );
  
 so that our responses would be wrapped in
  updateView && updateView(body);
  JavaScript code 
 (with the proper
  Content-Type
  header of course).
  
 In most cases, we don’t want to alter this value because the
  callback
  value is somewhat 
 standardized by jQuery JSONP functions.
  
 ¹
 http://en.wikipedia.org/wiki/Cross-origin_resource_sharing",NA
9.7 json replacer and json spaces,"Likewise, when we use the Express.js method
  res.json()
 , we can apply special parameters: 
 replacer and spaces, to
  JSON.stringify()
  function²
  in the scope of the application.
  
 Replacer acts like a filer. You can read more about it at
  Mozilla Developer Network³
  (MDN).
  
 Express.js uses
  null
  as the default value for
  json replacer
 .
  
 The
  spaces
  parameter is in essence an indentation size. Its value defaults to 2 in 
 development and to 0 in production. In most cases, we leave these settings alone.",NA
9.8 case sensitive routing,"The
  case sensitive routing
  flag should be self-explanatory. We disregard the case of the URL 
 paths when it’s false, which is the default value, and do otherwise when the value is set to 
 true. For example, if we have
  app.enable('case sensitive routing');
 , then
  /users
  and
  /Users
  won’t be 
 the same. It’s best to have this option disabled for the sake of avoiding confusion.",NA
9.9 strict routing,"The last but not least flag —
  strict routing
  — deals with cases of trailing slashes in URLs. With
  
 strict
  
 routing
  enabled, e.g.,
  app.set('strict
  
 routing',
  
 true');
 , the paths will be treated
  
 differently, e.g.,
  /users
  and
  /users/
  will be completely separate routes.
  
 By default, this parameter is set to false.",NA
9.10 x-powered-by,"Sets the HTTP response header
  X-Powered-By
  to
  Express
  value. This option is enabled by 
 default.",NA
9.11 etag,"ETag⁴
  or entity tag is one of the caching tools. If someone doesn’t know what it is or how to 
 use it, it’s better to leave it on. Otherwise, to disable it:
  app.disable('etag');
 .
  
 ²
 https://developer.mozilla.org/en-
 US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
 ³
 https://developer.mozill
 a.org/en-US/docs/Using_native_JSON#The_replacer_parameter
  
 ⁴
 http://en.wikipedia.org/wiki/HTTP_ETag",NA
9.12 subdomain offset,"The
  subdomain offset
  setting controls the value returned by
  req.subdomains
  property. This 
 setting is useful when the app is deployed on multiple subdomains, such as
  
 http://ncbi.nlm.nih.gov
 . By default, the two extreme parts in the domain are dropped and the 
 rest are returned in reversed order in the
  req.subdomains
 , so for our example, the result is
  
 ['nlm', 'ncbi']
 . However, if the app has 
 subdomain offset
  set to three by
  app.set('subdomain offset', 
 3);
 , the result of
  req.subdomains 
 will be just
  ['ncbi']
 .",NA
10 Environments,"Of course, we can write up some
  if else
  statements based on the
  process.env.NODE_ENV
  value,
  
 for example:
  
 1 
  
 if
  (
 'development'
  ===
  process.env.NODE_ENV) {
  
 2 
 //connect to development database
  
 3 
  
 }
  else if
  (
 'production'
  ===
  process.env.NODE_ENV) {
  
 4 
 //connect to production database
  
 5 
 };
  //continue for stag and preview environments
  
 or using Express.js
  env
  param (please refer to the section
  env
  above):
  
 1 
  
 //assuming that app has reference to Express.js instance
  
 2 
  
 if
  (
 'development'
  ===
  app.get(
 'env'
 )) {
  
 3 
 //connect to development database
  
 4 
  
 }
  else if
  (
 'production'
  ===
  app.get(
 'env'
 )) {
  
 5 
 //connect to production database
  
 6 
 };
  //continue for stag and preview environments
  
 However, the same algorithm could be written more elegantly with the Express.js 
 sugarcoating
  
 method
  app.configure()
 .",NA
10.1 app.configure(),"Now that we know how to set application-wide settings, we might find ourselves wanting 
 to apply
  
 whole sets of such settings. For example, for development and production, we want to use 
 different
  
 database URIs. This could be cleverly achieved with the
  app.configure()
  method which takes 
 one
  
 parameter for all environments, e.g., if we want to set admin email, we can write:
  
 1 
  
 app.configure(
 function
 (){
  
 2 
 app.set(
 'adminEmail'
 ,
  'hi@azat.co'
 );
  
 3 
  
 });",NA
Tip,"Express.js
  often
  uses the difference in the number of input parameters and their 
 types to direct functions’ behavior. Therefore, please pay close attention to how 
 you invoke your methods.",NA
11 Applying Middleware,"To set up middleware, we utilize
  app.use()
  method.",NA
11.1 app.use(),"The method
  app.use()
  has one optional string parameter path and one mandatory function
  
 parameter callback. For example, to implement a logger with a date, time, request method 
 and URL:
  
 1 
  
 //instantiate the Express.js app
  
 2 
  
 app.
 use
 (
 function
 (req, res, next) {
  
 3 
 console.log('
 %
 s
  %
 s
  —
  %
 s', (
 new
  Date).toString(), req.method, req.url);
  
 4 
 return
  next();
  
 5 
  
 });
  
 6 
  
 //implement server routes
  
 On the other hand, if we want to prefix the middleware, a.k.a.,
  mounting
 , we can use the
  path
  
 parameter which restricts the use of this particular middleware to only the routes that have 
 such a
  
 prefix. For example, to limit the logging to only the admin dashboard route
  /admin
 , we can 
 write:
  
 1 
  
 //instantiate the Express.js app
  
 2 
  
 app.
 use
 ('
 /
 admin',
  function
 (req, res, next) {
  
 3 
 console.log('
 %
 s
  %
 s
  —
  %
 s', (
 new
  Date).toString(), req.method, req.url);
  
 4 
 return
  next();
  
 5 
  
 });
  
 6
  
 7 
  
 //actually implement the /admin route
  
 Writing everything from scratch as trivial as logging and serving of the static files is 
 obviously not
  
 much fun. Therefore, Express.js comes with these (and many other) middlewares built-in:",NA
12 Types of Middleware,"As you’ve seen in the previous chapter, middleware is nothing more than a function that 
 takes
  req 
 and
  res
  objects. Express provides more middlewares right out of the box with most 
 of them coming from Sencha’s
  Connect library¹
  (
 NPM²
 ,
  GitHub³
 ).
  
 The main thing to remember when using middlewares is that the order in which they’re 
 declared via
  app.use()
  function
  matters
 . For example, a session must follow a cookie while 
 csrf requires a session.",NA
12.1 express.compress(),"This middleware allows for gzipping of transferred data and is usually placed in the very 
 be-ginning of an Express.js app configuration to precede the other middleware and routes. 
 The 
 express.compress()
  is good without extra params, but here they are just in case (gzip uses 
 core Node.js module
  zlib⁴
  and just passes these options to it):
  
 • chunkSize (default: 16*1024)
  
 • windowBits
  
 • level
  
 • memLevel
  
 • strategy
  
 • filter: function that by default tests for the
  Content-Type
  header to be json, text or 
 javascript
  
 For more information on these options, please see
  the Zlib docs⁵
 .",NA
12.2 express.logger(),"This middleware keeps track of all the requests. It takes either an
  options
  object or a
  
 format
  string, e.g.,
  
 ¹
 http://www.senchalabs.org/connect/
  
 ²
 https://npmjs.org/package/connect
  
 ³
 https://github.com/senchalabs/connect
  
 ⁴
 http://nodejs.org/api/zlib.html#zlib_opt
 ions
  
 ⁵
 http://zlib.net/manual.html#Advanced",NA
12.3 express.json(),"If the request has a MIME type of
  application/json
 , this middleware will try to parse the 
 request
  
 payload as JSON. The result will be put in the
  req.body
  object and passed to the next 
 middlewares
  
 and routes.
  
 We can pass the following options as properties:
  
 • strict: boolean true or false; if it’s true (default), then a 400 status error will be passed 
 to
  next()
  
 callback when first character is not
  [
  or
  {
  
 • reviver: is a second parameter to
  JSON.parse()
  function which transforms the output; 
 more
  
 info at
  MDN⁷
  
 • limit: max byte size; disabled by default
  
 For example, if you need to skip the private methods/properties (by convention they begin 
 with the
  
 underscore
  _
  symbol), apply non-strict parsing and have a limit of 5000 bytes:
  
 1 
  
 app.use(express.json({
  
 2 
 strict
 :
  false
 ,
  
 3 
 reviver
 :
  function
 (key, value) {
  
 4 
  
 if
  (key.substr(
 0
 ,
 1
 )
  ===
  '_'
 ) {
  
 5 
  
 return undefined
 ;
  
 6 
  
 }
  else
  {
  
 7 
  
 return
  value;
  
 8 
  
 }
  
 9 
 },
  
 10 
 limit
 : 5000
  
 11 
  
 }));",NA
12.4 express.urlencoded(),"This
  express.urlencoded()
  middleware parses
  only
  requests with the
  x-ww-form-urlencoded
  
 header. It utilizes
  qs⁸
  module’s
  querystirng.parse()
  function and puts the resulting JS object 
 into
  
 req.body
 .
  
 We can also pass the limit parameter similar to the
  express.json()
  middleware above, e.g.,
  
 1
  
 app.use(express.urlencoded({limit
 :10000
 });",NA
12.5 express.multipart(),"The
  express.multipart()
  middleware is very similar to the previous two, but deals with forms, 
 i.e., requests with the
  multipart/form-data
  header. It ignores
  GET
  and
  HEAD
  HTTP methods. The 
 middleware is built on top of Felix Geisendörfer’s
  formidable⁹
  (
 GitHub¹⁰
 ) and accepts its 
 options, e.g.,
  uploadDir: '/tpm'
 , as well as:
  
 • limit: string or number of bytes to limit the request body size to
  
 • defer: boolean true or false; if true, passes Formidable form object in
  
 req.form
  
 Example:
  
 1 
  
 app.use(express.multipart());",NA
12.6 express.bodyParser(),"The three middleware we went through previously are rarely used by themselves. 
 Therefore, 
 there’s 
 a 
 wrapper
  
 express.bodyParser()
 . 
 In 
 other 
 words,
  
 app.use(express.bodyParser(options));
  is equivalent to
  
 1 
  
 app.use(express.json(options));
  
 2 
  
 app.use(express.urlencoded(options));
  
 3 
  
 app.use(express.multipart(options));
  
 Where the
  options
  object is passed to all three calls and has the corresponding options 
 (refer to the aforementioned middlewares for more info on supported options).",NA
Warning,"bodyParser()
  middleware is known to be prone to malfunctioning when handling 
 large file uploads. The exact problem is described in
  this article¹¹
  and TJ’s 
 response. Future versions of Express.js might drop support for
  bodyParser()
 .",NA
12.7 express.cookieParser(),"The
  express.cookieParser()
  allows us to access user cookie values from the
  req.cookie
  object in 
 request handlers. The method takes a string which is used for signing cookies. Usually, it’s 
 some clever pseudo-random sequence, e.g.,
  very secret string
 .
  
 Use it like this:
  
 ⁹
 https://npmjs.org/package/formidable
  
 ¹⁰
 https://github.com/felixge/node-formidable",NA
Warning,"Never store any information in the cookies, especially sensitive user-related 
 information. In most cases, cookies are just used to store a unique and hard to 
 guess key that matches against a value on the server to retrieve a user session.",NA
12.8 express.session(),"This middleware must have
  express.cookeParser()
  enabled before its definition. The
  express.session() 
 takes these options:
  
 Options
  
 •
  key
 : cookie name defaulting to
  connect.sid
  
 •
  store
 : session store instance, usually Redis object (more about it in the
  Redis
  chapter)•
  
 secret
 : session cookie is signed with this secret to prevent tampering, usually just a 
 random string
  
 •
  cookie
 : session cookie settings, defaulting to { path: ‘/’, httpOnly: true, maxAge: null }•
  
 proxy
 : boolean that says to trust the reverse proxy when setting secure cookies (via “x-
 forwarded-proto”)
  
 By default, sessions are stored in the memory. However, we can use Redis for persistence 
 and for sharing sessions between multiple machines. For more information on Express.js 
 sessions, please refer to the
  Tips and Tricks
  part.",NA
12.9 express.csrf(),"Cross-site request forgery¹²
  (CSRF) protection is handled by Express.js by putting a
  _csrf
  
 token in the session (
 req.session._csrf
 ) and validating that value against values in
  req.body
 ,
  
 req.query 
 and the
  X-CSRF-Token
  header. If the values don’t match, the
  403 Forbidden¹³
  HTTP 
 status code is returned.
  
 This middleware doesn’t check
  GET
 ,
  HEAD
  or
  OPTIONS
  methods.
  
 You can override the default function that checks the value by passing a callback function in 
 a
  value 
 property; for example, to use a different name and check against
  only
  the request 
 body:
  
 ¹²
 http://en.wikipedia.org/wiki/Cross-
 site_request_forgery
  
 ¹³
 http://en.wikipedia.org/wiki/HTTP_403",NA
12.10 express.static(),"Already familiar with
  express.static(path, options)
  method that serves files from a specified
  
 root
  path to the folder, e.g.,
  
 1 
  
 app.use(express.
 static
 (path.join(__dirname,
  '
 public
 '
 )));
  
 or
  
 1 
  
 app.use(express.
 static
 (__dirname
  +
  '
 /
 public
 '
 ));
  
 The express.static(path, options) method takes these options:
  
 •
  maxAge
 : number of milliseconds to set for browser cache maxAge, which defaults to 0
  
 •
  hidden
 : boolean true or false which enables serving of hidden files; defaults to false for 
 security
  
 reasons
  
 •
  redirect
 : boolean true or false (default is true) that allows for a redirect to a trailing 
 slash “/”
  
 when the URL pathname is a directory
  
 Advanced use:",NA
12.11 express.basicAuth(),"Very basic HTTP authentication, e.g.,
  
 1 
  
 app.use(express.basicAuth(
 function
 (user, pass){
  
 2 
 if
  (user
  ===
  'azat'
  &&
  pass
  ===
  'expressjs'
  ) {
  
 3 
  
 return true
 ;
  
 4 
 }
  else
  {
  
 5 
  
 return false
 ;
  
 6 
 }
  
 7 
  
 }));
  
 Please see
  Tips and Tricks
  and
  Tutorials and Examples
  for more advanced and realistic 
 scenarios.",NA
12.12 Other Express.js/Connect Middlewares,"•
  directory¹⁴
  
 •
  compress¹⁵
  
 •
  errorHandler¹⁶
  
 •
  favicon¹⁷
  
 •
  limit¹⁸
  
 •
  logger¹⁹
  
 •
  
 methodOverride²⁰
  
 •
  responseTime²¹
  
 •
  staticCache²²
  
 ¹⁴
 http://www.senchalabs.org/connect/directory.html
  
 ¹⁵
 http://www.senchalabs.org/connect/compress.html
  
 ¹⁶
 http://www.senchalabs.org/connect/errorHandler.h
 tml
  
 ¹⁷
 http://www.senchalabs.org/connect/favicon.html
  
 ¹⁸
 http://www.senchalabs.org/connect/limit.html
  
 ¹⁹
 http://www.senchalabs.org/connect/logger.html
  
 ²⁰
 http://www.senchalabs.org/connect/methodOverrid
 e.html",NA
13 Different Template Engines,"To use something different, make sure you install that module with NPM, preferably by 
 adding it to 
 package.json
  as well.",NA
13.1 app.engine(),"By default, Express.js will try to require a template engine based on the extension provided. 
 That is when we call
  res.render('index.jade');
  (more on this method later) with the
  index.jade
  file 
 name, the framework is calling
  app.engine('jade', require('jade').__express);
  internally.
  
 The
  app.engine()
  method example:
  
 1 
  
 //decleare dependencies
  
 2 
  
 //instantiate the app
  
 3 
  
 //configure the app
  
 4 
  
 app.engine(
 'jade'
 , require(
 'jade'
 ).__express);
  
 5 
  
 //define the routes
  
 Therefore, to map file extensions to different template engines, please take a look at the
  
 app.engine() 
 method. The callback, i.e., the second parameter to the method, must be in a 
 special format. To ensure that the template library supports this format, we call
  __express
  on 
 it.
  
 Here is the list of the libraries that support Express.js without any modification (taken from 
 the 
 Express.js Wiki page¹
 ):
  
 •
  Jade²
  – Haml-inspired template engine
  
 •
  Haml.js³
  – Haml implementation
  
 •
  EJS⁴
  – Embedded JavaScript template engine
  
 •
  hbs⁵
  – adapter for Handlebars.js, an extension of the Mustache.js template engine
  
 •
  h4e⁶
  – adapter for Hogan.js, with support for partials and layouts
  
 •
  hulk-hogan⁷
  – adapter for Twitter’s
  Hogan.js⁸
  (Mustache syntax), with support for 
 Partials
  
 ¹
 https://github.com/visionmedia/express/wiki#template-
 engines
  
 ²
 http://github.com/visionmedia/jade
  
 ³
 http://github.com/visionmedia/haml.js
  
 ⁴
 http://github.com/visionmedia/ejs
  
 ⁵
 http://github.com/donpark/hbs
  
 ⁶
 https://github.com/tldrio/h4e",NA
14 Extracting Parameters,"To extract parameters from the URL, we can manually apply same logic to many routes. For 
 example,
  
 imagine that we need user information on a user profile page (
 /user/:username
 ) and on an admin
  
 page (
 /admin/:username
 ). This is how we can implement it:
  
 1 
  
 var
  findUserByUsername
  =
  function
  (username, callback) {
  
 2 
 //perform database query that calls callback when it’s done
  
 3 
  
 };
  
 4
  
 5 
  
 app.get(
 '/users/:username'
 ,
  function
 (req, res, next) {
  
 6 
 var
  username
  =
  ''
 ;
  
 7 
 //parse req.url to get the username
  
 8 
 fundUserByUsername(username,
  function
 (e, user) {
  
 9 
  
 if
  (e)
  return
  next(e);
  
 10 
  
 return
  res.render(user);
  
 11 
 });
  
 12 
  
 });
  
 13
  
 14 
  
 app.get(
 '/admin/:username'
 ,
  function
 (req, res, next) {
  
 15 
 var
  username
  =
  ''
 ;
  
 16 
 //parse req.url to get the username
  
 17 
 fundUserByUsername(username,
  function
 (e, user) {
  
 18 
  
 if
  (e)
  return
  next(e);
  
 19 
  
 return
  res.render(user);
  
 20 
 });
  
 21 
  
 });
  
 Even with abstracting the bulk of code into the
  findUserByUsername()
  function, we still ended up
  
 with ineloquent code. Meet the
  app.param()
  method!",NA
14.1 app.param(),"Anytime the given string is present in the URL, the callback will be triggered, e.g.,
  
 app.param('username',
  
 function(req, res, next, username){...})
 .",NA
15 Routing,"Express.js is a node.js framework that, among other things, provides a way to organize 
 routes.",NA
15.1 app.VERB(),"Each route is defined via a method call on an application object with a URL pattern as the
  
 first parameter —
  Regular Expressions¹
  (RegExps) are also supported — that is
  
 app.METHOD(path,
  
 [callback...], callback)
 ; for example:
  
 1 
  
 app.get(
 'api/v1/stories/'
 ,
  function
 (res, req){
  
 2 
 ...
  
 3 
  
 })
  
 or, for a POST method:
  
 1 
  
 app.post(
 '/api/v1/stories'
 ,
  function
 (req,res){
  
 2 
 ...
  
 3 
  
 })
  
 It’s needless to say that DELETE, PUT and other methods are
  supported as well²
 .
  
 The callbacks that we pass to
  get()
  or
  post()
  methods are called request handlers (more info 
 on
  
 them in the
  Request Handlers
  chapter), because they take requests (
 req
 ), process them and 
 write to
  
 response (
 res
 ) objects. For example:
  
 1 
  
 app.get(
 '/about'
 ,
  function
 (req,res){
  
 2 
 res.send(
 'About Us: ...'
 );
  
 3 
  
 });
  
 We can have multiple request handlers, hence the name
  middleware
 . They accept a third 
 parame-
  
 ter/function
  next
 , calling which (
 next()
 ) will switch the execution flow to the next handler:",NA
15.2 app.all(),"The
  app.all()
  method allows the execution of specified request handlers on a particular path 
 no matter what the HTTP method of the request is. This procedure might be a lifesaver 
 when defining 
 global
  or namespaced logic, e.g.,
  
 1 
  
 app.all(
 '*'
 , userAuth);
  
 2 
  
 ...
  
 3 
  
 app.all(
 '/api/*'
 , apiAuth);",NA
15.3 Trailing Slashes,"Paths with trailing slashes at the end are treated as their normal counterparts by default. 
 To turn off this feature, use
  app.enable('strict routing');
  or
  app.set('strict routing', true);
 . Learn more 
 about setting options in the
  Configuration
  and
  Settings
  chapters.
  
 ⁵
 http://tools.ietf.org/html/rfc2616
  
 ⁶
 http://tools.ietf.org/html/rfc2616#pa
 ge-51",NA
16 Request Handlers,"Request handlers in Express.js are strikingly similar to callbacks in the core Node.js
  
 http.createServer()
  
 method, because they’re just functions (anonymous, named or methods) with
  req
  and
  res
  
 parame-
  
 ters:
  
 1 
  
 var
  ping
  =
  function
 (req, res) {
  
 2 
 console.log(
 'ping'
 );
  
 3 
 res.end(
 200
 );
  
 4 
  
 };
  
 5
  
 6 
  
 app.get(
 '/'
 , ping);
  
 In addition, we can utilize the third parameter
  next()
  for control flow. It’s closely related to the
  
 error handling topic which we will cover later. Here is a simple example of two request 
 handlers,
  
 ping and pong:
  
 1 
  
 var
  ping
  =
  function
 (req, res, next) {
  
 2 
 console.log(
 'ping'
 );
  
 3 
 return
  next();
  
 4 
  
 };
  
 5 
  
 var
  pong
  =
  function
 (req, res) {
  
 6 
 console.log(
 'pong'
 );
  
 7 
 res.end(
 200
 );
  
 8 
  
 };
  
 9 
  
 app.get(
 '/'
 , ping, pong);
  
 When a request comes on the
  /
  route, Express.js calls
  ping()
  which acts as middleware in this 
 case
  
 (because it’s in the middle!). Ping in turn, when it’s done, calls pong with that finished response 
 with
  
 res.end()
 .",NA
17 Request,"Express request object is a wrapper for a core Node.js
  http.request
  object. It has some neat 
 functionality, but in its essence it supports everything that the native **http.request **can 
 do.
  
 To better understand the request object, let’s create a brand new Express.js app with the
  
 express req
  command from our
  expressjsguide
  folder:
  
  
 The result of executing a vanilla
  $ express
  command.
  
 Now we can install dependencies:
  
 1 
  
 $
  cd
  req
  
 2 
  
 $
  npm install",NA
17.1 query,"The query string is everything to the right of the question mark in a given URL, e.g., in the 
 URL 
 https://twitter.com/search?q=js&src=typd
  the query string is
  q=js&src=typd
  and the JS object 
 would be
  {q:'js', src:'typd'}
 .
  
 The
  connect.query()
  is utilized by Express.js behind the scenes without any extra 
 configurations. It resembles
  express.bodyParser()
  and
  express.cookieParser()
  in a way that it puts 
 a property (
 query
  in this case) on a request object
  req
  that is passed to the next middlewares 
 and routes.
  
 We can add this route to any Express.js server such as the one we’ve created with the CLI, 
 i.e., 
 expresjsguide/req
 :
  
 1 
  
 app.get(
 '/search'
 ,
  function
 (req, res) {
  
 2 
 console.log(req.query)
  
 3 
 res.end(JSON.stringify(req.query)
 +
 '/n'
 );
  
 4 
  
 })
  
 And make GET requests with CURL:",NA
17.2 req.params,"In the preceding chapter
  Extracting Parameters
 , we covered how to set up middleware to 
 process
  
 data taken from the URLs of the requests. However, sometimes it’s more convenient just to 
 get such
  
 values from within a specific request handler directly. For this, there’s a
  req.params
  object, 
 which
  
 is an array with key value pairs.
  
 We can add the following route to
  req/app.js
 :
  
 1 
  
 app.get(
 '/params/:role/:name/:status'
 ,
  function
 (req, res) {
  
 2 
 console.log(req.params)
  
 3 
 res.end();
  
 4 
  
 })
  
 And after running CURL terminal commands:
  
 1 
  
 $
  curl http://localhost:3000/params/admin/azat/active
  
 2 
  
 $
  curl http://localhost:3000/params/user/bob/active",NA
17.3 req.body,"The
  req.body
  object is a magic that’s provided to us via enabling
  express.bodyParser()
  middle-
  
 ware (or either one of its children — more on that in the
  Type of Middleware
  chapter above).
  
 Again, let’s reuse our previous project and add this route to see how the
  req.body
  object works,
  
 remembering that
  app.use(express.bodyParser());
  is in the code already:
  
 1 
  
 app.post(
 '/body'
 ,
  function
 (req, res){
  
 2 
 console.log(req.body);
  
 3 
 res.end(JSON.stringify(req.body)
 +
 '\n'
 );
  
 4 
  
 });
  
 CURL-ing with
  curl http://localhost:3000/body -d 'name=azat'
  and
  curl http://localhost:3000/body
  
 -d 'name=azat&role=admin'
  will yield
  req.body
 :
  
 1 
  
 { name
 :
  'azat'
  }
  
 2 
  
 { name
 :
  'azat'
 , role
 :
  'admin'
  }",NA
17.4 req.files,"req.files
  is used to handle file uploads. It is similar to
  req.body
  and is turned on either by
  
 express.bodyParser()
  or
  express.multipart()
  middlewares. Express.js (and other modules be-
  
 hind the scene) process the request data (which is usually a form) and give us extensive 
 information
  
 in the
  req.files.FIELD_NAME
  object.
  
 To illustrate how
  req.files
  works, let’s add this route to the req project:
  
 1 
  
 app.post(
 '/upload'
 ,
  function
 (req, res){
  
 2 
 console.log(req.files.archive);
  
 3 
 //read req.files.archive.path
  
 4 
 //process the data
  
 5 
 //save the data
  
 6 
 res.end();
  
 7 
  
 })",NA
17.5 req.route,"The
  req.route
  object simply has the current route’s information such as:
  
 •
  path
 : original URL pattern of the request
  
 •
  method
 : HTTP method of the request
  
 •
  keys
 : list of parameters in the URL pattern (i.e., values prefixed with
  :
 )
  
 •
  regexp
 : Express.js-generated pattern for the path
  
 •
  params
 : req.params object
  
 We can add the
  console.log(req.route);
  statement to our
  req.params
  route from the example
  
 above like this:
  
 1 
  
 app.get(
 '/params/:role/:name/:status'
 ,
  function
 (req, res) {
  
 2 
 console.log(req.params);
  
 3 
 console.log(req.route);
  
 4 
 res.end();
  
 5 
  
 });
  
 We might expect to see server logs of the
  req.route
  object:
  
 1 
  
 [ role
 :
  'admin'
 , name
 :
  'azat'
 , status
 :
  'active'
  ]
  
 2 
  
 { path
 :
  '/params/:role/:name/:status'
 ,
  
 3 
 method
 :
  'get'
 ,
  
 4 
 callbacks
 :
  [ [
 Function
 ] ],
  
 5 
 keys
 :
  
 6 
 [ { name
 :
  'role'
 , optional
 :
  false
  },
  
 7 
  
 { name
 :
  'name'
 , optional
 :
  false
  },
  
 8 
  
 { name
 :
  'status'
 , optional
 :
  false
  } ],
  
 9 
 regexp
 :
  /^\/params\/(?:([^\/]+?))\/(?:([^\/]+?))\/(?:([^\/]+?))\/?$/i
 ,
  
 10 
 params
 :
  [ role
 :
  'admin'
 , name
 :
  'azat'
 , status
 :
  'active'
  ] }",NA
17.6 req.cookies,NA,NA
17.7 req.signedCookies,"req.signedCookies
  is akin to the aforementioned
  req.cookies
 ; however, it’s used when the secret 
 string is passed to the
  express.cookieParser('some secret string');
  method.",NA
Warning,"Singed cookies
  does not
  mean that the cookie is hidden or encrypted. It’s a simple 
 way to prevent tampering by applying a private value.",NA
17.8 req.header() and req.get(),"The
  req.header
  and
  req.get
  methods are identical and allow for retrieval of the request 
 headers by their names. The naming is case-insensitive:
  
 1 
  
 app.get(
 'content-type'
 );
  
 2 
  
 app.header(
 'content-type'
 );",NA
17.9 Other Attributes and Methods,"There are plenty of other objects in the Express.js Request:
  
 •
  req.accepts()
 : true if a passed string (single or comma separated values) or an array of 
 MIME types (or extensions) matches against the request
  Accept
  header, false if 
 there’s no match (
 API¹
 )
  
 •
  req.accepted
 : an array of accepted MIME types (
 API²
 )
  
 •
  req.is()
 : true if a passed MIME type string matches the
  Content-Type
  header types, 
 false if there’s no match (
 API³
 )
  
 •
  req.ip
 : the IP address of the request, please see
  trust proxy
  configuration for proxy 
 situations (
 API⁴
 )
  
 •
  req.ips
 : an array of IPs when
  trust proxy
  config is enabled (
 API⁵
 )
  
 ¹
 http://expressjs.com/api.html#req.acce
 pts
  
 ²
 http://expressjs.com/api.html#req.acce
 pted
  
 ³
 http://expressjs.com/api.html#req.is
  
 ⁴
 http://expressjs.com/api.html#req.ip
  
 ⁵
 http://expressjs.com/api.html#req.ips",NA
18 Response,"The Express.js response object — which we get inside of the request handler callbacks — is 
 the same good old
  Node.js
  http.response
  object¹
  but on steroids. If someone ever wrote a web 
 server with only core Node.js modules, there’s only the
  res.end()
  method²
  that finishes the 
 request. The Express.js response object contains many convenient wrappers, like
  res.json()
  
 or
  res.send()
 .
  
 Let’s create a brand new Express.js app again with the
  $ express res
  terminal command.
  
  
 The result of running
  $ express res
  from the project folder.
  
 Obviously, now we need to run
  $ cd res && npm install
  to download the dependencies. For a 
 screenshot, please refer to the
  expressjsguide/req
  example in the previous chapter.",NA
18.1 res.render(),"The
  res.render()
  is the staple of Express.js. From our previous examples and from the 
 function’s name, you could guess that it has something to do with generating HTML out of 
 templates (such as
  
 ¹
 http://nodejs.org/api/http.html#http_class_http_serverrespo
 nse",NA
Note,"Jade uses Python/Haml-like syntax, which takes into account white spaces and tabs — 
 be 
 careful with the markup. We can use
  =
  as a
  print
  command (h1 tag) or nothing (p tag). 
 For 
 more information, please visit the official
  documentation³
 . 
 ³
 http://jade-lang.com/",NA
Warning,"79
  
  
 The properties of the
  data
  parameter are your
  locals
  in the template. In other 
 words, if you 
 want to access a value of a title inside of your template, the data object must contain a 
 key 
 and value pair. Nested objects are supported by most of the template engines. 
 The callback can take the place of the data due to Express.js’ ability to determine the type of 
 the
  
 parameter. This example is not within the
  res/app.js
 , but shows how to pass callbacks with 
 our
  
 data:
  
 1 
  
 app.get(
 '/render-title'
 ,
  function
 (req, res) {
  
 2 
 res.render(
 'index'
 ,
  function
  (error, html) {
  
 3 
  
 //do something
  
 4 
 });
  
 5 
  
 });
  
 Behind the scenes,
  res.render()
  calls
  res.send()
  (covered later) for successful compilation of
  
 HTML strings or
  req.next(error)
  for failure,
  if the callback is not provided
 . In other words,
  
 the default callback to
  res.render()
  is (
 GitHub⁵
 ):
  
 1 
 // default callback to respond
  
 2 
 fn
  =
  fn
  ||
  function
 (err, str){
  
 3 
  
 if
  (err)
  return
  req.next(err);
  
 4 
  
 self.send(str);
  
 5 
 };",NA
18.2 res.locals(),"The
  res.locals()
  object is another way to pass data to the templates so they both can be 
 compiled
  
 into HTML. The first way is to pass data as a parameter to the
  res.render()
  method as outlined
  
 above:
  
 1 
  
 app.get(
 '/render-title'
 ,
  function
 (req, res) {
  
 2 
 res.render(
 'index'
 , {title
 :
  'Express.js Guide'
 });
  
 3 
  
 });
  
 However, with
  res.locals
 , we can achieve the same thing. Our object will be available inside of
  
 the template:",NA
18.3 res.set(),"The
  res.set()
  method is an alias of
  res.header()
  (or the other way around) and serves as a 
 wrapper for the Node.js http core module’s
  response.setHeader()
  function⁶
 . The main 
 difference is that 
 res.set()
  is smart enough to call itself recursively when we pass multiple 
 header-value pairs to it in the form of an object.
  
 Here is an example of setting a single response header:
  
 ⁶
 http://nodejs.org/api/http.html#http_response_setheader_name_value",NA
Exercise,"84
  
  The screenshot of the
  res.set()
  example above was taken after adding the route to the 
 app.js
  file of the
  res
  project. Readers are encouraged to try doing this on their own.",NA
18.4 res.status(),"The
  res.status()
  accepts an
  HTTP status code⁷
  number and sends it in response. The only 
 difference between its
  core counterpart⁸
  is that
  res.status()
  is chainable:
  
 1
  
  
 2
  
  
 3
  
 app.get(
 '/status'
 ,
  function
 (req, res) { 
 res.status(
 200
 ).send(
 'alive'
 ); 
  
 });
  
  
 ⁷
 http://www.w3.org/Protocols/rfc2616/rfc2616-
 sec10.html
  
 ⁸
 http://nodejs.org/api/http.html#http_response_statu
 scode",NA
18.5 res.send(),"The
  res.send()
  method lies somewhere between high-level
  res.render()
  and low-level
  res.end()
 . 
 The
  res.send()
  conveniently outputs any data application thrown at it (such as strings, 
 JavaScript objects, and even Buffers) with automatically generated proper HTTP headers, 
 e.g., Content-Length, ETag or Cache-Control.
  
 Due to its omnivorous behavior (cause by
  arguments.length
 ),
  res.send()
  can be used in 
 countless ways:
  
 • Status code number:
  res.send(500);
  for Server Error or
  res.send(200);
  for OK",NA
Note,"Please note that virtually all core Node.js methods (and ConnectJS methods as well) are 
 available in Express.js objects. Therefore, we have access to
  res.end()
  and other methods 
 in Express.js response API.",NA
18.6 res.json(),"The
  res.json()
  method is a convenient way of sending JSON data. It’s equivalent to
  res.send()
  
 when data passed is Array or Object type. In other cases,
  res.json()
  forces data conversion 
 with",NA
Exercise,"The screenshot of the
  res.json()
  example above was taken after adding the route to the 
 res/app.js
  file of the
  expressjsguide/res
  project. Readers are encouraged to try doing 
 this on their own. 
 Other uses of
  res.json()
  are possible as well — for example, with no status code:",NA
18.7 res.jsonp(),"The
  res.jsonp()
  method is similar to
  res.json()
 , but provides JSONP response. That is, the JSON
  
 data is wrapped in a JavaScript function call, e.g.,
  processResponse({...});
 . This is usually used
  
 for cross-domain calls support. By default, Express.js uses a
  callback
  name to extract the 
 name of
  
 the callback function. It’s possible to override this value with
  json callback name
  settings 
 (more
  
 on that in the
  Settings
  chapter). If there is no proper callback specified in the query string of 
 the
  
 request (e.g.,
  ?callback=cb
 ), then the response is simply JSON.
  
 Assume that we need to serve CSV data to a front-end request via JSONP:
  
 1 
  
 app.get(
 '/'
 ,
  function
  (req, res) {
  
 2 
 res.jsonp(
 200
 , [{title
 :
  'Express.js Guide'
 , tags
 :
  'node.js express.js'
 },
  
 3 
  
 {title
 :
  'Rapid Prototyping with JS'
 , tags
 :
  'backbone.js, node.js, mongodb'
 },
  
 4 
  
 {title
 :
  'JavaScript: The Good Parts'
 , tags
 :
  'javascript'
 }
  
 5 
 ]);
  
 6 
  
 });",NA
Exercise,"The screenshot of the
  res.json()
  example above was taken after adding the route to the 
 index.js
  file of the
  cli-app
  project. Readers are encouraged to try doing this on their own.",NA
18.8 res.redirect(),"Sometimes it’s needed just to redirect users/requests to another route. We can use 
 absolute, relative
  
 or full paths:",NA
18.9 Other Response Methods and Properties,"Most of these methods and properties are convenient alternatives to the methods covered 
 already in the book. In other words, we can accomplish most of the logic with the main 
 methods, but knowing the following shortcuts can save developers a few keystrokes and 
 improve readability. For example, 
 res.type()
  is a niche case of
  res.header()
  for a Content-Type 
 only header.
  
 •
  res.get()
 : string value of response header for a passed header type (
 API¹⁰
 )
  
 •
  res.cookie()
 : takes cookie key-value pair and sets it on response (
 API¹¹
 )
  
 •
  res.clearCookie()
 : takes cookie key/name and optional path parameter to clear the 
 cookies (
 API¹²
 )
  
 •
  res.location()
 : takes relative, absolute or full paths as a string and sets that value to 
 Location response header (
 API¹³
 )
  
 •
  res.charset
 : the charset value of the response (
 API¹⁴
 )
  
 •
  res.type()
 : takes a string and sets it as a value of Content-Type header (
 API¹⁵
 )
  
 •
  res.format()
 : takes an object as a mapping of types and responses and executes them 
 according to Accepted request header (
 API¹⁶
 )
  
 •
  res.attachment()
 : takes optional filename as a string and sets Content-Disposition (and if 
 filename provided Content-Type) header(s) to
  attachment
  and file type accordingly 
 (
 API¹⁷
 )
  
 •
  res.sendfile()
 : takes path to a file on the server and various options and callback 
 parameters, and sends the file to the requester (
 API¹⁸
 )
  
 ⁹
 http://www.w3.org/Protocols/rfc2616/rfc2616-
 sec10.html
  
 ¹⁰
 http://expressjs.com/api.html#res.get
  
 ¹¹
 http://expressjs.com/api.html#res.cookie
  
 ¹²
 http://expressjs.com/api.html#res.clearCookie
  
 ¹³
 http://expressjs.com/api.html#res.location
  
 ¹⁴
 http://expressjs.com/api.html#res.charset
  
 ¹⁵
 http://expressjs.com/api.html#res.type
  
 ¹⁶
 http://expressjs.com/api.html#res.format
  
 ¹⁷
 http://expressjs.com/api.html#res.attachment
  
 ¹⁸
 http://expressjs.com/api.html#res.sendfile",NA
19 Error Handling,"Due to the asynchronous nature of Node.js and callback patterns, the state in which errors 
 happen
  
 is not that trivial to catch and log for future analysis. In the
  Tips and Tricks
  chapter, we 
 cover the
  
 use of domains with Express.js apps. It’s a more advanced technique and for most 
 implementations
  
 right out of the box framework error handling might prove sufficient.
  
 We can start with the basic
  errorHandler()
  middleware from our
  cli-app
  example which is 
 enabled
  
 by this code:
  
 1 
  
 // development only
  
 2 
  
 if
  (
 'development'
  ==
  app.get(
 'env'
 )) {
  
 3 
 app.use(express.errorHandler());
  
 4 
  
 }
  
 This makes sense because error handling is typically used across the whole application; 
 therefore
  
 it’s best to implement it as a middleware.
  
 For custom error handler implementations, the middleware is the same as any other except 
 that it
  
 has one more param,
  error
  or
  err
  for short:
  
 1 
  
 //main middlewares
  
 2 
  
 app.use(
 function
 (err, req, res, next) {
  
 3 
 //do logging and user-friendly error message display
  
 4 
 console.error(err);
  
 5 
 res.send(
 500
 );
  
 6 
  
 });
  
 7 
  
 //routes
  
 In fact, the response can be anything: JSON, text, a redirect to a static page or something 
 else.
  
 For most front-end and other JSON clients, the preferred format is of course JSON:",NA
Note,"97
  
  
 Developers can use the
  req.xhr
  property or check if Accepted request header has 
 application/json
  value. 
 The most straightforward way is to just send a text:
  
 1 
  
 app.use(
 function
 (err, req, res, next) {
  
 2 
 //do logging and user-friendly error message display
  
 3 
 console.error(err);
  
 4 
 res.send(
 500
 ,
  'internal server error'
 );
  
 5 
  
 })
  
 Or, if we know that it’s secure to output the error message:
  
 1 
  
 app.use(
 function
 (err, req, res, next) {
  
 2 
 //do logging and user-friendly error message display
  
 3 
 console.error(err);
  
 4 
 res.send(
 500
 ,
  'internal server error: '
  +
  err);
  
 5 
  
 })
  
 To simply render a static error page with the name
  500
  and the default extension:
  
 1 
  
 app.use(
 function
 (err, req, res, next) {
  
 2 
 //do logging and user-friendly error message display
  
 3 
 console.error(err);
  
 4 
 //assuming that template engine is plugged in
  
 5 
 res.render(
 '500'
 );
  
 6 
  
 })
  
 Or, for a full filename of
  500.html
 :
  
 1 
  
 app.use(
 function
 (err, req, res, next) {
  
 2 
 //do logging and user-friendly error message display
  
 3 
 console.error(err);
  
 4 
 //assuming that template engine is plugged in
  
 5 
 res.render(
 '500.html'
 );
  
 6 
  
 })
  
 We can also use
  res.redirect()
 :",NA
20 Running an App,NA,NA
20.1 app.locals,"The
  app.locals
  object is similar to the aforementioned
  res.locals
  in the sense that it exposes
  
 data to templates. However, there’s a main difference:
  app.locals
  makes its properties 
 available
  
 in
  all
  templates rendered by app, while
  res.locals
  restricts them
  only
  to that request. 
 Therefore,
  
 developers need to be careful not to reveal any sensitive information via
  app.locals
 . The best 
 use
  
 case for this is app-wide settings like locations, URLs, contact info, etc., e.g.,
  
 1 
  
 app.locals.lang
  =
  'en'
 ;
  
 2 
  
 app.locals.appName
  =
  'HackHall'
 ;
  
 The
  app.locals
  can also be invoked like a function:
  
 1 
  
 app.locals([
  
 2 
 author
 :
  'Azat Mardan'
 ,
  
 3 
 email
 :
  'hi@azat.co'
 ,
  
 4 
 website
 :
  'http://expressjsguide.com'
  
 5 
  
 ]);",NA
20.2 app.render(),"The
  app.render()
  method is invoked either with a view name and a callback or with a view 
 name,
  
 data and a callback. For example, the system might have an email template for a
  Thank you 
 for
  
 signing up
  message and another for
  Reset your password
 :
  
 1
  
 var
  sendgrid
  
 =
  require(
 'sendgrid'
 )(api_user, api_key);
  
 2
  
 3 
  
 var
  sendThankYouEmail
  =
  function
  (userEmail) {
  
 4 
 app.render(
  
 5 
  
 'emails/thank-you'
 ,
  
 6 
  
 function
 (err, html){",NA
Note ,"The sendgrid module used in the example available at
  NPM¹
  and
  
 GitHub²
 . 
  
 ¹
 http://npmjs.org/sendgrid
  
 ²
 https://github.com/sendgrid/sendgrid-
 nodejs",NA
20.3 app.routes,"The
  app.routes
  object merely contains Express.js app routes where properties are HTTP 
 methods.
  
 For example,
  expressjsguide/res
  from the
  Response
  chapter has the following
  app.routes
  object:
  
 1 
  
 { get
 :
  
 2 
 [ { path
 :
  '/'
 ,
  
 3 
  
 method
 :
  'get'
 ,
  
 4 
  
 callbacks
 :
  [
 Object
 ],
  
 5 
  
 keys
 :
  [],
  
 6 
  
 regexp
 :
  /^\/\/?$/i
  },
  
 7 
  
 { path
 :
  '/users'
 ,
  
 8 
  
 method
 :
  'get'
 ,
  
 9 
  
 callbacks
 :
  [
 Object
 ],
  
 10 
  
 keys
 :
  [],
  
 11 
  
 regexp
 :
  /^\/users\/?$/i
  },
  
 12 
  
 { path
 :
  '/render'
 ,
  
 13 
  
 method
 :
  'get'
 ,
  
 14 
  
 callbacks
 :
  [
 Object
 ],
  
 15 
  
 keys
 :
  [],
  
 16 
  
 regexp
 :
  /^\/render\/?$/i
  },
  
 17 
  
 { path
 :
  '/render-title'
 ,
  
 18 
  
 method
 :
  'get'
 ,
  
 19 
  
 callbacks
 :
  [
 Object
 ],
  
 20 
  
 keys
 :
  [],
  
 21 
  
 regexp
 :
  /^\/render-title\/?$/i
  },
  
 22 
  
 { path
 :
  '/locals'
 ,
  
 23 
  
 method
 :
  'get'
 ,
  
 24 
  
 callbacks
 :
  [
 Object
 ],
  
 25 
  
 keys
 :
  [],
  
 26 
  
 regexp
 :
  /^\/locals\/?$/i
  },
  
 27 
  
 { path
 :
  '/set-html'
 ,
  
 28 
  
 method
 :
  'get'
 ,
  
 29 
  
 callbacks
 :
  [
 Object
 ],
  
 30 
  
 keys
 :
  [],
  
 31 
  
 regexp
 :
  /^\/set-html\/?$/i
  },
  
 32 
  
 { path
 :
  '/set-csv'
 ,
  
 33 
  
 method
 :
  'get'
 ,
  
 34 
  
 callbacks
 :
  [
 Object
 ],",NA
20.4 app.listen(),"The Express.js
  app.listen()
  method is akin to
  server.listen()
 ³
  from the core Node.js core http 
 module. This method is the cornerstone for starting Express.js apps. There are two ways to 
 do it.
  
 The first way is to spin up the Express.js app directly on a particular port:
  
 ³
 http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback",NA
III Tips and Tricks,NA,NA
Summary,"In this part we’ll cover some common patterns for Node.js/Express.js development such 
 as code organization, streams, Redis, clusters, authentication, Stylus, LESS and SASS, 
 domains, security and Socket.IO.",NA
21 Abstraction,"Middleware concept provides flexibility. Software engineers can use anonymous or named 
 functions
  
 as middlewares. However, the best thing is to abstract them into external modules based on
  
 functionality. Let’s say we have a REST API with stories, elements and users. We can 
 separate
  
 request handlers into files accordingly, so that
  routes/stories.js
  has:
  
 1 
  
 module.exports.findStories
  =
  function
 (req, res, next) {
  
 2 
  
 ...
  
 3 
  
 };
  
 4 
  
 module.exports.createStory
  =
  function
 (req, res, next) {
  
 5 
  
 ...
  
 6 
  
 };
  
 The
  routes/users.js
  holds the logic for user entities:
  
 1 
  
 module.exports.findUser
  =
  function
 (req, res, next){
  
 2 
  
 ...
  
 3 
  
 };
  
 4 
  
 module.exports.updateUser
  =
  function
 (req, res, next){
  
 5 
  
 ...
  
 6 
  
 };
  
 7 
  
 module.exports.removeUser
  =
  function
 (req, res, next){
  
 8 
  
 ...
  
 9 
  
 };
  
 The main app file can use the modules above in this manner:
  
 1 
  
 ...
  
 2 
  
 var
  stories
  =
  require(
 './routes/stories'
 );
  
 3 
  
 var
  users
  =
  require(
 './routes/users'
 );
  
 4 
  
 ...
  
 5 
  
 app.get(
 '/stories'
 , stories.findStories);
  
 6 
  
 app.post(
 '/stories'
 , stories.createStory);
  
 7 
  
 app.get(
 '/users/:user_id'
 , users.findUser);
  
 8 
  
 app.put(
 '/users/:user_id'
 , users.updateUser);",NA
Note,"The
  __dirname
  global provides an absolute path to the file that uses it, while
  ./
  returns 
 current working directory, which might be different depending on where we execute 
 the Node.js script (e.g,
  $
  
 exception to the
  ./
  rule is when it’s used in the
  require()
  function, e.g.,
  conf 
  
 node
  
 ∼
 /code/app/index.js
  vs.
  $ 
  
 node 
  
 index.js
 ). One 
 =
  
 require('./config.json');
 ; then it acts as
  __dirname
 . 
 As you can see, middleware/request handler use is a powerful concept for keeping code 
 organized.
  
 The best practice is to keep the router lean and thin by moving all of the logic into 
 corresponding
  
 external modules/files. This way, important server configuration parameters will all be 
 neatly in one
  
 place when you need them! :-)",NA
22 Using Databases in Modules,"With the native Node.js MongoDB driver, the Express.js server needs to wait for the 
 connection to
  
 be created before it can use the database:
  
 1 
  
 ...
  
 2 
  
 var
  mongodb
  =
  require (
 'mongodb'
 );
  
 3 
  
 var
  Db
  =
  mongodb.Db;
  
 4 
  
 var
  db
 =
 new
  Db (
 'test'
 ,
  new
  Server(dbHost, dbPort, {}));
  
 5 
  
 ...
  
 6 
  
 db.open(
 function
 (error, dbConnection){
  
 7 
 var
  app
  =
  express();
  
 8 
 app.get(...);
  
 9 
 ...
  
 10 
 app.listen(
 3000
 );
  
 11 
  
 });
  
 Thanks to more advanced libraries like Mongoskin, Monk and Mongoose that have 
 buffering,
  
 developers’ tasks can be as easy as:
  
 1 
  
 var
  express
  =
  require(
 'express'
 ),
  
 2 
 mongoskin
  =
  require(
 'mongoskin'
 );
  
 3
  
 4 
  
 var
  app
  =
  express();
  
 5 
  
 app.use(express.bodyParser());
  
 6
  
 7 
  
 var
  db
  =
  mongoskin.db(
 'localhost:27017/test'
 , {safe
 :
 true
 });
  
 8 
  
 ...
  
 9 
  
 app.get(
 '/'
 ,
  function
 (req, res) {
  
 10 
 res.send(
 'please select a collection, e.g., /collections/messages'
 )
  
 11 
  
 });
  
 12 
  
 ...
  
 13 
  
 app.listen(
 3000
 );",NA
23 Keys and Passwords,"A typical web service will likely require connections to other services via usernames and 
 passwords in the case of databases, and API keys and secrets/tokens in the case of third-
 party APIs. As readers might guess, it’s not a good idea to store this sensitive data in the 
 source code! The two most widespread approaches to solving this issue are:
  
 1. JSON file 
  
 2. Environmental 
 variables
  
 The JSON file approach is as easy as it sounds. All we need is a JSON file. For example, 
 suppose we have a local database and two external services, such as HackHall and Twitter 
 in
  conf/keys.json
 :
  
 1
  
 {
  
 ""db""
 :
  {
  
 2
  
 3
  
 }
  
 ""host""
 :
  ""http://localhost""
 ,
  
 4
  
 ""port""
 : 27017
 ,
  
 5
  
 ""username""
 :
  ""azat""
 ,
  
 6
  
 ""password""
 :
  ""CE0E08FE-E486-4AE0-8441-2193DF8D5ED0""
  
 7
  
 },
  
 8
  
 ""hackhall""
 :
  {
  
 9
  
 ""api_key""
 :
  ""C7C211A6-D8A7-4E41-99E6-DA0EB95CD864""
  
 10
  
 },
  
 11
  
 ""twitter""
 :
  {
  
 12
  
 ""consumer_key""
 :
  ""668C68E1-B947-492E-90C7-F69F5D32B42E""
 ,
  
 13
  
 ""consumer_secret""
 :
  ""4B5EE783-E6BB-4F4E-8B05-2A746056BEE1""
  
 14
  
 }
  
 15
  
 The latest versions of Node.js allow developers to import JSON files with the
  require()
  
 function. Hurray for not messing around with the
  fs
  module! Therefore, the main 
 application file might use these statements:
  
 1 
  
 var
  configurations
  =
  require(
 '/conf/keys.json'
 );
  
 2 
  
 var
  twitterConsumerKey
  =
  configurations.twitter.consumer_key;
  
 Alternatively, we can just read the file manually with the
  fs
  module and parse the stream 
 into a JavaScript object. Try this on your own.
  
 As far as access to
  configurations
  goes, it’s even better if we can share this configuration 
 object globally:",NA
24 Streams,"The Express.js request and response objects are readable and writable Node.js streams 
 respectably.
  
 For those vaguely familiar with streams, they’re powerful tools for processing chunks of data 
 before
  
 a particular process (reading, receiving, writing, sending) actually ends. This makes streams 
 useful
  
 when dealing with huge data such as audio or video. Another case for streams is when 
 performing
  
 big database migrations.",NA
Tip,"For more information on how to use streams, there are amazing resources by
  substack¹
 : 
 stream-handbook²
  and
  stream-adventure³
 . 
 Here is an example of piping a stream to a normal response from
  expressjsguide/streams-http-res.js
 :
  
 1 
  
 var
  http
  =
  require(
 'http'
 );
  
 2 
  
 var
  fs
  =
  require(
 'fs'
 );
  
 3 
  
 var
  server
  =
  http.createServer(
 function
  (req, res) {
  
 4 
  
 fs.createReadStream(
 'users.csv'
 ).pipe(res);
  
 5 
  
 });
  
 6 
  
 server.listen(
 3000
 );
  
 The GET request with CURL from the terminal looks like this:
  
 1 
  
 $
  curl http://localhost:3000
  
 The line above will cause the server to output the content of the file
  users.csv
 , e.g.,",NA
Tip,"In some cases, it’s good to have a pass-through logic that doesn’t consume too many 
 resources. For that, check out module
  through⁶
  (
 GitHub⁷
 ). Another useful module is
  
 concat-
  
 stream⁸
  (
 GitHub⁹
 ). It allows concatenation of streams. 
 ⁶
 https://npmjs.org/package/through
  
 ⁷
 https://github.com/dominictarr/through
  
 ⁸
 https://npmjs.org/package/concat-stream
  
 ⁹
 https://github.com/maxogden/node-concat-stream",NA
25 Redis,"Redis is often used in Express.js applications for sessions persistence, because storing 
 sessions in
  
 a physical storage keeps apps from losing users’ data during times when systems are 
 restarted or
  
 redeployed. It also enables the use of multiple RESTful servers due to the fact that they can 
 connect
  
 to the same Redis. In addition, Redis can be used for queues and scheduling tasks (e.g., 
 email jobs).
  
 To download Redis 2.6.7, follow these simple steps:
  
 1 
  
 $
  wget http://download.redis.io/releases/redis-2.6.7.tar.gz
  
 2 
  
 $
  tar xzf redis-2.6.7.tar.gz
  
 3 
  
 $
  cd
  redis-2.6.7
  
 4 
  
 $
  make
  
 Or for more Redis instructions, you can visit
  redis.io/download¹
 .
  
 To start Redis:
  
 1 
  
 $
  src/redis-server
  
 To stop it, just press
  control + c
 .
  
 To access the Redis command-line interface:
  
 1 
  
 $
  src/redis-cli
  
 Below is an uncomplicated illustration of how to use Redis to manage Express.js sessions.
  
 First, to access Redis, we can utilize the
  connect-redis
  driver. This can be done with the 
 familiar
  
 dependency key-value pair in
  package.json
 :",NA
Tip ,"For a deeper study of Redis, an interactive tutorial is available at
  
 try.redis.io⁴
 . 
 ²
 https://npmjs.org/package/redis
  
 ³
 https://github.com/mranney/node_redis
  
 ⁴
 http://try.redis.io/",NA
26 Authentication,"The most common authentication is a username and password combination. We can check 
 for the
  
 match against our database and then store an
  authenticated=true
  flag in the session. The 
 session
  
 data is automatically stored by Express.js for
  every
  other request by that agent:
  
 1 
  
 app.use(
 function
 (req, res, next) {
  
 2 
 if
  (req.session
  &&
  req.session.authenticated)
  
 3 
  
 return
  next();
  
 4 
 else
  {
  
 5 
  
 return
  res.redirect(
 '/login'
 );
  
 6 
 }
  
 7 
  
 }
  
 In case we need additional user information, it also can be stored in the session:
  
 1 
  
 app.post(
 '/login'
 ,
  function
 (req, res) {
  
 2 
 // check the database for the username and password combination
  
 3 
 db.findOne({username
 :
  req.body.username,
  
 4 
  
 password
 :
  req.body.password},
  
 5 
  
 function
 (error, user) {
  
 6 
  
 if
  (error)
  return
  next();
  
 7 
  
 if
  (
 !
 user)
  return
  next(
 new
  Error
 (
 'Bad username/password'
 );
  
 8 
  
 req.session.user
  =
  user;
  
 9 
  
 res.redirect (
 '/protected_area'
 );
  
 10 
  
 }
  
 11 
 );
  
 12 
  
 });
  
 Authentication with third parties is often done via OAuth. For a working example of the
  
 oauth¹
  
 (
 GitHub²
 ) module (to which the author,
  Azat
 , contributed some docs), take a look at the
  
 HackHall
  
 chapter.
  
 OAuth 1.0/2.0 require callback routes for the user redirect back to our sites. This is 
 effortless with",NA
27 Multi-Threading with Clusters,"There are a lot of arguments out there against Node.js, which are rooted on the myth that 
 Node.js-based systems
  have
  to be single-threaded. Nothing can be further from the truth — 
 and with
  cluster 
 module we can skillfully utilize all machines’ CPUs.
  
 Here is a working example of an Express.js app that runs on four processes. At the 
 beginning of the file, we import dependencies:
  
 1 
  
 var
  cluster
  =
  require(
 'cluster'
 );
  
 2 
  
 var
  http
  =
  require(
 'http'
 );
  
 3 
  
 var
  numCPUs
  =
  require(
 'os'
 ).cpus().length;
  
 4 
  
 var
  express
  =
  require(
 'express'
 );
  
 The cluster module has a property that tells us if the process is master or child. We use it to 
 spawn four workers (the default workers will use the same file, but this can be overwritten 
 with 
 setupMaster¹
 ). In addition to that, we can attach event listeners and receive messages 
 from workers (e.g., ‘kill’).
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 if
  (cluster.isMaster) { 
  
 console.log ( 
  
   
 ' Fork %s worker(s) from master'
 , 
  
   
 numCPUs 
  
 ) 
  
 for
  (
 var
  i
  = 0
 ; i
  <
  numCPUs; i
 ++
 ) { 
  
   
 cluster.fork(); 
  
 }; 
  
 cluster.on(
 'online'
 ,
  function
 (worker) { 
  
   
 console.log ( 
  
    
 'worker is running on %s pid'
 , 
  
    
 worker.process.pid 
  
   
 ) 
  
 }); 
  
 cluster.on(
 'exit'
 ,
  function
 (worker, code, signal) { 
  
  
 console.log( 
  
    
 'worker with %s is closed'
 , 
  
    
 worker.process.pid
  
  
 ¹
 http://nodejs.org/docs/v0.9.0/api/cluster.html#cluster_cluster_setupmaster_settings",NA
Tip,"If someone prefers ready solutions to low-level libraries (like cluster), check out the 
 real- 
 world production library created and used by eBay:
  cluster2²
  (
 GitHub³
 ). 
 ²
 https://npmjs.org/package/cluster2
  
 ³
 https://github.com/ql-io/cluster2",NA
28 Consolidate.js,"The
  consolidate library¹
  (
 GitHub²
 ) streamlines and generalizes a few dozen template 
 engine modules
  
 so they play nicely with Express.js.
  
 The Consolidate.js example:
  
 1 
  
 var express
  =
  require(
 '
 express
 '
 );
  
 2 
  
 var consolidate
  =
  require(
 '
 consolidate
 '
 );
  
 3
  
 4 
  
 var app
  =
  express();
  
 5
  
 6 
  
 //configure template engine:
  
 7 
  
 app.engine(
 '
 html
 '
 , consolidate.handlebars);
  
 8 
  
 app.set(
 '
 view engine
 '
 ,
  '
 html
 '
 );
  
 9 
  
 app.set(
 '
 views
 '
 , __dirname
  +
  '
 /
 views
 '
 );
  
 That’s it,
  res.render()
  is ready to use Handlebars!
  
 All the template engines that consolidate support as of this writing (taken from its GitHub
  
 page³
 ):
  
 •
  atpl⁴
  
 •
  dust⁵ (website)⁶
  
 •
  eco⁷
  
 •
  ect⁸ (website)⁹
  
 •
  ejs¹⁰
  
 •
  haml¹¹ (website)¹²
  
 •
  haml-coffee¹³ (website)¹⁴
  
 ¹
 https://npmjs.org/package/consolidate
  
 ²
 https://github.com/visionmedia/consolidate.js
  
 ³
 https://github.com/visionmedia/consolidate.js/blob/master/Readme.md
  
 ⁴
 https://github.com/soywiz/atpl.js
  
 ⁵
 https://github.com/akdubya/dustjs
  
 ⁶
 http://akdubya.github.com/dustjs/
  
 ⁷
 https://github.com/sstephenson/eco
  
 ⁸
 https://github.com/baryshev/ect
  
 ⁹
 http://ectjs.com/
  
 ¹⁰
 https://github.com/visionmedia/ejs
  
 ¹¹
 https://github.com/visionmedia/haml.js
  
 ¹²
 http://haml-lang.com/
  
 ¹³
 https://github.com/9elements/haml-coffee",NA
"29 Stylus, LESS and SASS","CSS is tedious to write and manage in complex projects. Stylus, LESS and SASS bring so 
 much
  
 needed sanity of reusability (mixins, extend, vars, etc.) to stylesheets.",NA
29.1 Stylus,"Stylus is a sibling of Express.js and the most-often used CSS framework. To install Stylus, 
 type and
  
 run
  $ npm install stylus --save
 . Then, to apply
  static
  middleware, include this in your server
  
 file:
  
 1 
  
 ...
  
 2 
  
 app.use(require(
 'stylus'
 ).middleware(__dirname
  +
  '/public'
 ));
  
 3 
  
 app.use(express.
 static
 (path.join(__dirname,
  'public'
 )));
  
 4 
  
 ...
  
 Put
  *.styl
  file(s) inside of the folder that we expose (e.g.,
  public/css
 ) and include them in Jade
  
 templates with
  *.css
  extension
 :
  
 1 
  
 ...
  
 2 
 head
  
 3 
  
 link(rel
 =
 '
 stylesheet
 '
 , href
 =
 '
 /
 stylesheets
 /
 style.css
 '
 )
  
 4 
  
 ...
  
 Or, in any other templates of your choice, or in plain HTML file(s):
  
 1
  
 <
 link rel
 =
 ""stylesheet""
  href
 =
 ""/stylesheets/style.css""
 />
  
 -c
  
 stylus
  
 express-app
  
 For a project created from scratch, someone can use the
  $
  
 express
  
 command.
  
 You’ll find the stylus-enabled project in the
  expressjsguide/stylus
  folder as well as on
  GitHub¹
 .",NA
29.2 LESS,"To use LESS with Express.js v3.x, we’ll need
  less-middleware²
  which is an external NPM 
 module:
  
 ¹
 https://github.com/azat-co/expressjsguide/tree/master/stylus",NA
29.3 SASS,"To use SASS with Express.js v 3.x, we need
  node-sass⁴
 (
 GitHub⁵
 ) which is an external NPM 
 module:
  
 1 
  
 $
  npm install node-sass --save
  
 This is our Express.js plug-in for SASS:
  
 ³
 https://github.com/azat-co/expressjsguide/tree/master/less
  
 ⁴
 https://npmjs.org/package/node-sass",NA
30 Security,NA,NA
30.1 CSRF,"CSRF middleware was briefly covered in
  The Interface
  part. It does most of the job of 
 matching
  
 incoming values from requests for us. However, we still need to expose it in responses and 
 pass it
  
 back to server in templates (or JavaScript XHRs). One of the ways to implement it is to use 
 custom
  
 middleware:
  
 1 
  
 app.use(
 function
  (req, res, next) {
  
 2 
 res.locals.csrftoken
  =
  req.session._csrf;
  
 3 
 next();
  
 4 
  
 });
  
 And then render the value in the template (this is Jade language):
  
 1 
  
 doctype 5
  
 2 
  
 html
  
 3 
 head
  
 4 
  
 title= title
  
 5 
  
 link(rel='stylesheet', href='/stylesheets/style.css')
  
 6 
 body
  
 7 
  
 form(method=""post"", action=""/login"")
  
 8 
  
 input(type=""hidden"", name=""_csrf"", value=""#{csrftoken}"")
  
 9 
  
 input(type=""text"", name=""username"", placeholder=""Username"")
  
 10 
  
 input(type=""password"", name=""password"", placeholder=""Password"")
  
 11 
  
 button(type=""submit"") Login",NA
30.2 Permissions,"Obviously, it’s usually a bad idea to run web services as a root. Operations developers can 
 utilize
  
 Ubuntu’s
  authbind¹
  to bind to privileged ports (e.g., 80 for HTTP and 443 for HTTPS) 
 without giving
  
 root access.",NA
30.3 Headers,"There is Express.js middleware called
  helmet³
  (
 GitHub⁴
 ) that provides most of the security 
 headers described in
  Seven Web Server HTTP Headers that Improve Web Application 
 Security for Free⁵
 .
  
 In addition to that, programmers can use
  express-secure-skeleton⁶
  to jumpstart their secure 
 app.
  
 ³
 https://npmjs.org/package/helmet
  
 ⁴
 https://github.com/evilpacket/helmet
  
 ⁵
 http://recxltd.blogspot.com/2012/03/seven-web-server-http-headers-
 that.html
 ⁶
 https://github.com/evilpacket/express-secure-skeleton",NA
31 Socket.IO,"Full coverage of the
  Socket.IO¹
  library deserves its own book. However, it’s so cool and easy 
 to start using with Express.js that we included a basic example. The example will echo 
 (browser to server and back) our input in reverse in real time.
  
 ¹
 http://socket.io",NA
32 Domains,"Contrary to its more popular homonym, domain is a core Node.js
  module¹
 . It aids 
 developers in
  
 tracking and isolating errors that could be a juggernaut task. Think of domains as a smarter 
 version
  
 of try/catch
  statements²
 .
  
 When it comes to Express.js, we can apply domains in error-prone routes. Before the 
 routes, we need
  
 to define custom handlers to catch errors from domains:
  
 1 
  
 var
  domain
  =
  require(
 'domain'
 );
  
 2 
  
 var
  defaultHandler
  =
  express.errorHandler();
  
 3 
  
 app.use(
 function
  (error, req, res, next) {
  
 4 
 if
  (domain.active) {
  
 5 
  
 console.info(
 'caught with domain'
 )
  
 6 
  
 domain.active.emit(
 ""error""
 , error);
  
 7 
 }
  else
  {
  
 8 
  
 console.info(
 'no domain'
 )
  
 9 
  
 defaultHandler(error, req, res, next);
  
 10 
 }
  
 11 
  
 });
  
 Here is a crashy route:
  
 1 
  
 app.get(
 ""/e""
 ,
  function
  (req, res, next) {
  
 2 
 var
  d
  =
  domain.create();
  
 3 
 d.on(
 ""error""
 ,
  function
  (error) {
  
 4 
  
 console.error(error.stack)
  
 5 
  
 res.send(
 500
 , {
 ""error""
 :
  error.message});
  
 6 
 });
  
 7 
 d.run(
 function
  () {
  
 8 
  
 //error prone code goes here
  
 9 
  
 throw new
  Error
 (
 ""Database is down.""
 );
  
 10 
 });
  
 11 
  
 });
  
 On the other hand, we can call next with an error object (e.g., when an error variable comes 
 from",NA
Warning,"Domain module is in
  experimental
  stage. This means that it’s likely that methods and 
 behavior will change. Therefore, stay updated and use exact versions in the
  package.json
  
 file. 
 ⁴
 http://othiym23.github.io/nodeconf2013-domains/#/4/1",NA
IV Tutorials and Examples,NA,NA
Summary,"This part contains tutorials which are step-by-step learning guides, and examples that are 
 more complex but less meticulous. The former group includes the Instagram Gallery, 
 Todo App and REST API. They’ll introduce readers to how Express.js interacts with other 
 aspects of web services. We’ll learn how to make requests to a third-party site, connect to 
 a database and perform CRUD (create, read, update and delete) operations on it, render 
 Jade templates, compile LESS stylesheets, utilize CSRF and build Mocha tests. The 
 HackHall example, on the other hand, can serve as a reference and give you hints on how 
 to use Mongoose and OAuth sessions and prepare an app for deployment.",NA
33 Instagram Gallery,NA,NA
Summary,"This tutorial will demonstrate how to use Express.js external third-party services. In this 
 tutorial, in addition to Express.js, we’ll use Instagram photos via Storify API, SuperAgent, 
 Consolidate and Handlebars modules.",NA
Example,"The full source code of this example is available at
  https://github.com/azat-co/sfy-
 gallery
 . 
 Storify¹
  runs on
  Node.js²
  and
  Express.js³
 ; therefore, why not use these technologies to write 
 an application that demonstrates how to build apps that rely on third-party APIs and HTTP 
 requests?
  
 The Instagram Gallery app will fetch a story object and display its title, description, and a 
 gallery of the elements/images like this:
  
 ¹
 http://storify.com
  
 ²
 http://nodejs.org
  
 ³
 http://expressjs.co
 m",NA
33.1 A File Structure,"1
  
 - index.js
  
 2
  
 - package.json
  
 3
  
 - views/index.html
  
 4
  
 - css/bootstrap-responsive.min.css
  
 5
  
 - css/flatly-bootstrap.min.css
  
 Where
  index.js
  is our main Node.js file and
  index.html
  is the Handlebars template.",NA
33.2 Dependencies,"Our dependencies include:
  
 • express: 3.2.5 for Express.js framework
  
 • superagent: 0.14.6 for making HTTP requests
  
 • consolidate: 0.9.1 for using Handlebars with Express.js
  
 • handlebars: 1.0.12 for using Handlebars template engine
  
 The
  package.json
  file:
  
 1
  
 {
  
 ""name""
 :
  ""sfy-demo""
 ,
  
 2
  
 3
  
 }
  
 ""version""
 :
  ""0.0.0""
 ,
  
 4
  
 ""description""
 :
  ""Simple Node.js demo app on top of Storify API""
 ,
  
 5
  
 ""main""
 :
  ""index.js""
 ,
  
 6
  
 ""scripts""
 :
  {
  
 7
  
 ""test""
 :
  ""echo
  \""
 Error: no test specified
 \""
  && exit 1""
  
 8
  
 },
  
 9
  
 ""dependencies""
 :
  {
  
 10
  
 ""express""
 :
  ""3.2.5""
 ,
  
 11
  
 ""superagent""
 :
  ""0.14.6""
 ,
  
 12
  
 ""consolidate""
 :
  ""0.9.1""
 ,
  
 13
  
 ""handlebars""
 :
  ""1.0.12""
  
 14
  
 },
  
 15
  
 ""repository""
 :
  """"
 ,
  
 16
  
 ""author""
 :
  ""Azat Mardan""
 ,
  
 17
  
 ""license""
 :
  ""BSD""
  
 18",NA
33.3 Node.js Server,"At the beginning of the file, we require dependencies:
  
 1 
  
 var
  express
  =
  require(
 'express'
 );
  
 2 
  
 var
  superagent
  =
  require(
 'superagent'
 );
  
 3 
  
 var
  consolidate
  =
  require(
 'consolidate'
 );
  
 4
  
 5 
  
 var
  app
  =
  express();
  
 Then, configure template engine:",NA
33.4 Handlebars Template,"The
  views/index.html
  file:
  
 1 
  
 <!DOCTYPE html lang=""en"">
  
 2 
  
 <html>
  
 3 
 <head>
  
 4 
  
 <link
  type=
 ""text/css""
  
 5 
  
 href=
 ""css/flatly-bootstrap.min.css""
  
 6 
  
 rel=
 ""stylesheet""
  />
  
 7 
  
 <link
  type=
 ""text/css""
  
 8 
  
 href=
 ""css/bootstrap-responsive.min.css""
  
 9 
  
 rel=
 ""stylesheet""
 />
  
 10 
 </head>
  
 11
  
 12 
 <body
  class=
 ""container""
 >
  
 13 
  
 <div
  class=
 ""row""
 >
  
 14 
  
 <h1>
 {{title}}
 <small>
  by {{author.name}}
 </small></h1>
  
 15 
  
 <p>
 {{description}}
 </p>
  
 16 
  
 </div>
  
 17 
  
 <div
  class=
 ""row""
 >
  
 18 
  
 <ul
  class=
 ""thumbnails""
 >",NA
33.5 Conclusion,"Express.js and SuperAgent allow developers to retrieve and manipulate data provided by 
 third-party services such as Storify, Twitter and Facebook in just a few lines of code.",NA
Note,"In most cases, service providers (such as Google, Facebook and Twitter) require 
 authen- 
 tication (which is not the case with Storify API as of this writing). To make OAuth 1.0, 
 OAuth 2.0 and OAuth Echo requests, consider
  oauth⁶
  (
 GitHub⁷
 ),
  everyauth⁸
  (
 GitHub⁹
 ) 
 and/or
  Passport¹⁰
 (
 website¹¹
  and
  GitHub¹²
 ). 
 ⁶
 https://npmjs.org/package/oauth
  
 ⁷
 https://github.com/ciaranj/node-
 oauth
  
 ⁸
 https://npmjs.org/package/everyauth
  
 ⁹
 https://github.com/bnoguchi/everyaut
 h
  
 ¹⁰
 http://passportjs.org/
  
 ¹¹
 http://passportjs.org/
  
 ¹²
 https://github.com/jaredhanson/pass
 port",NA
34 Todo App,NA,NA
Summary ,"Todo apps are considered quintessential in showcasing frameworks and are akin to the 
 famous 
 Todomvc.com
  for front-end JavaScript frameworks. In this example, we’ll use 
 Jade, forms, LESS, AJAX/XHR and CSRF. 
 http://todomvc.com
  
 In our Todo app, we’ll intentionally not use Backbone.js or Angular to demonstrate how to 
 build 
 traditional
  websites with the use of forms and redirects. We’ll also explain how to 
 plug in CSRF and LESS.",NA
Example ,"All the source code is in
  github.com/azat-co/todo-express¹
  for your 
 convenience. 
 Here are some screenshots of the Todo app in which we start from a home page:
  
 ¹
 http://github.com/azat-co/todo-express",NA
34.1 Scaffolding,"As usual, we start by running",NA
34.2 MongoDB,"Install MongoDB if you don’t have it already.
  
 1 
  
 $
  brew update 
  
 2 
  
 $
  brew install mongodb 
  
 3 
  
 $
  mongo --version
  
 For more flavors of MongoDB installation, check out
  the official docs²
 .",NA
34.3 Structure,"The final version of the app has the following folder/file structure (
 GitHub³
 ):
  
 ²
 http://docs.mongodb.org/manual/tutorial/install-mongodb-
 on-os-x/
  
 ³
 http://github.com/azat-co/todo-express",NA
34.4 app.js,"This is a breakdown of the Express.js-generated
  app.js
  file with the addition of routes, 
 database, session, LESS and param middlewares.
  
 Firstly, we import dependencies with the Node.js global
  require()
  function:
  
 1 
  
 var
  express
  =
  require(
 'express'
 );
  
 Similarly, we get access to our own modules, which are the app’s routes:
  
 ⁴
 http://getbootstrap.com/
  
 ⁵
 https://github.com/twbs/bootstrap/tree/mas
 ter/less",NA
34.5 Routes,"There are only two files in the
  routes
  folder. One of them serves the home page (e.g.,
  
 http://localhost:
  
 3000/
 ) and is straightforward:
  
 1 
  
 /*
  
 2 
 * GET home page.
  
 3 
 */
  
 4
  
 5 
  
 exports.index
  =
  function
 (req, res){
  
 6 
 res.render(
 'index'
 , { title
 :
  'Express.js Todo App'
  });
  
 7 
  
 };
  
 The remaining logic that deals with tasks itself has been placed in
  todo-express/routes/tasks.js
 .
  
 Let’s break it down a bit.
  
 We start by exporting a
  list()
  request handler that gives us a list of incomplete tasks:
  
 1 
  
 exports.list
  =
  function
 (req, res, next){
  
 To do so, we perform a database search with completed=false query:
  
 1 
 req.db.tasks.find({
  
 2 
  
 completed
 :
  false
  
 3 
 }).toArray(
 function
 (error, tasks){
  
 In the callback, we need to check for any errors:
  javascript if (error) return next(error);
  
 Since we use
  toArray()
 , we can send the date directly to the template:",NA
34.6 Jades,"In the Todo app, we use four templates:
  
 •
  layout.jade
 : the skeleton of HTML pages that is used on all pages
  
 •
  index.jade
 : home page
  
 •
  tasks.jade
 : Todo List page
  
 •
  tasks_completed.jade
 : Completed page
  
 Let’s go through each file starting with
  layout.jade
 . It starts with doctype, html and head 
 types:",NA
34.7 LESS,"As we’ve mentioned before, after applying proper middleware in
  app.js
  files, we can put
  *.less
  
 files anywhere under the
  public
  folder. Express.js works by accepting a request for some
  .css
  
 file
  
 and tries to match the corresponding file by name. Therefore, we include
  *.css
  files in our 
 jades.
  
 Here is the content of the
  todo-express/public/stylesheets/main.less
  file:
  
 1 
  
 *
  {
  
 2 
 font
 -
 size
 :20
 px;
  
 3 
  
 }
  
 4 
  
 .btn {
  
 5 
 // margin-left: 20px;
  
 6 
 // margin-right: 20px;
  
 7 
  
 }
  
 8 
  
 .num {
  
 9 
 // margin-right: 3px;
  
 10 
  
 }
  
 11 
  
 .item {
  
 12 
 height:
  44
 px;
  
 13 
 width:
  100%
 ;
  
 14 
 clear:
  both;
  
 15 
 .name {
  
 16 
  
 width:
  300
 px;
  
 17 
 }
  
 18 
 .action {
  
 19 
  
 width:
  100
 px;
  
 20 
 }
  
 21 
 .delete {
  
 22 
  
 width:
  100
 px
  
 23 
 }
  
 24 
 div {
  
 25 
  
 float:
 left;
  
 26 
 }
  
 27 
  
 }
  
 28 
  
 .home {
  
 29 
 margin
 -
 top
 : 40
 px;",NA
34.8 Conclusion,"The Todo app is considered classic because it doesn’t rely on any front-end framework. 
 This was done intentionally to show how easy it is to use Express.js for such tasks. In 
 modern-day development, people often leverage some sort of REST API server architecture 
 with a front-end client built with Backbone.js, Angular, Ember or
  something else⁷
 . Our next 
 examples dive into the details about how to write such servers.
  
 ⁷
 http://todomvc.com",NA
35 REST API,NA,NA
Summary,"In this tutorial, in addition to Express.js, we’ll use MongoDB via Mongoskin. We’ll also use 
 Mocha and SuperAgent to write functional tests. 
 This tutorial will walk you through the writing test using the
  Mocha¹
  and
  Super Agent²
  
 libraries, and then use them in a test-driven development manner to build a
  Node.js³
  free 
 JSON REST API server, utilizing the
  Express.js⁴
  framework and
  Mongoskin⁵
  library for
  
 MongoDB⁶
 .",NA
Example,"All the source code is in
  github.com/azat-co/rest-api-express⁷
  for your convenience. 
 In this REST API server, we’ll perform
  create, update, remove and delete
  (CRUD) 
 operations and harness the Express.js
  middleware⁸
  concept with
  app.param()
  and
  app.use()
  
 methods.",NA
35.1 Test Coverage,"Before anything else, let’s write functional tests that make HTTP requests to our soon-to-
 be-created REST API server. If you know how to use
  Mocha⁹
  or just want to jump straight 
 to the Express.js app implementation, feel free to do so. You can use CURL terminal 
 commands for testing too.
  
 Assuming we already have Node.js,
  NPM¹⁰
  and MongoDB installed, let’s create a
  new
  folder 
 (or if you wrote the tests, use that folder):
  
 ¹
 http://visionmedia.github.io/mocha/
  
 ²
 http://visionmedia.github.io/superagent
 /
  
 ³
 http://nodejs.org
  
 ⁴
 http://expressjs.com/
  
 ⁵
 https://github.com/kissjs/node-
 mongoskin
  
 ⁶
 http://www.mongodb.org/
  
 ⁷
 https://github.com/azat-co/rest-api-",NA
Tip,"Installing Mocha locally will give us the ability to use different versions at the 
 same time. To run tests, simply point to
  ./node_modules/mocha/bin/mocha
 . A better 
 alternative would be to use Makefile as outlined in the HackHall example. 
 Now let’s create an
  express.test.js
  file in the same folder, which will have six suites:
  
 • creating a new object
  
 • retrieving an object by its ID
  
 • retrieving the whole collection
  
 • updating an object by its ID
  
 • checking an updated object by its 
 ID
  
 • removing an object by its ID
  
 HTTP requests are a breeze with SuperAgent’s chained functions, which we’ll put inside of 
 each test suite.
  
 Here is the full source code for the
  rest-api-express/express.test.js
  file:
  
 ¹¹
 http://visionmedia.github.io/mocha/
  
 ¹²
 https://github.com/LearnBoost/expe
 ct.js/",NA
35.2 Dependencies,"In this tutorial, we’ll utilize
  Mongoskin¹⁴
 , a MongoDB library, which is a better alternative 
 to the plain good old
  native MongoDB driver for Node.js¹⁵
 . In addition, Mongoskin is more 
 lightweight than Mongoose and schema-less. For more insight, please check out this
  
 Mongoskin comparison blurb¹⁶
 .
  
 Express.js¹⁷
  is a wrapper for core Node.js
  HTTP module¹⁸
  objects. The Express.js 
 framework is built on top of
  Connect¹⁹
  middleware and provides tons of convenience. 
 Some people compare the framework to Ruby’s Sinatra because it’s non-opinionated and 
 configurable.
  
 If you’ve created a
  rest-api
  folder in the previous section
  Test Coverage
 , simply run these 
 commands to install modules for the application:
  
 1 
  
 npm install express
  
 2 
  
 npm install mongoskin",NA
35.3 Implementation,"First things first. Let’s define our dependencies:
  
 1 
  
 var
  express
  =
  require(
 'express'
 )
  
 2 
 , mongoskin
  =
  require(
 'mongoskin'
 )
  
 After version 3.x, Express streamlines the instantiation of its app instance, so that this line 
 will give us a server object:
  
 1 
  
 var
  app
  =
  express()
  
 To extract params from the body of the requests, we’ll use
  bodyParser()
  middleware which 
 looks more like a configuration statement:
  
 1
  
 app.use(express.bodyParser())
  
 ¹⁴
 https://github.com/kissjs/node-mongoskin
  
 ¹⁵
 https://github.com/mongodb/node-mongodb-
 native
  
 ¹⁶
 https://github.com/kissjs/node-
 mongoskin#comparation
  
 ¹⁷
 http://expressjs.com/",NA
Note,"If you wish to connect to a remote database, e.g.,
  MongoHQ²³
  for instance, substitute 
 the string with your username, password, host and port values. Here is the format of 
 the URI string:
  mongodb://[username:password@] host1[:port1][,host2[:port2],...
  
 [,hostN[:portN]]] [/[database][?options]]
  
 The
  app.param()
  method is another Express.js middleware. It basically says “
 do something 
 every
  
 time there is this value in the URL pattern of the request handler.
 ” In our case, we select a 
 particular
  
 collection when a request pattern contains a string
  collectionName
  prefixed with a colon 
 (you’ll
  
 see it later in the routes):
  
 1 
  
 app.param(
 'collectionName'
 ,
  function
 (req, res, next, collectionName){
  
 2 
 req.collection
  =
  db.collection(collectionName)
  
 3 
 return
  next()
  
 4 
  
 })
  
 Merely to be user-friendly, let’s put a root route with a message:
  
 1 
  
 app.get(
 '/'
 ,
  function
 (req, res, next) {
  
 2 
 res.send(
 'please select a collection, e.g., /collections/messages'
 )
  
 3 
  
 })
  
 Now the real work begins. Here is how we retrieve a list of items sorted by
  _id
  and that has a 
 limit
  
 of 10:",NA
35.4 Conclusion,"The Express.js and Mongoskin libraries are great when you need to build a simple REST API 
 server in a few lines of code. Later, if you need to expand the libraries, they also provide a 
 way to configure and organize your code.
  
 NoSQL databases like MongoDB are good at handling free-REST APIs. We don’t have to 
 define schemas and can throw any data at it and it’ll be saved.
  
 The full code for both test and app files:
  https://gist.github.com/azat-co/6075685
 .
  
 If you would like to learn more about Express.js and other JavaScript libraries, take a look 
 at the series
  Intro to Express.js tutorials²⁴
 .",NA
Note,"In this example, I’m using a semicolon-less style. Semicolons in JavaScript are
  
 absolutely optional²⁵
  except in two cases: in the for loop and before 
 expressions/statements that start with parenthesis (e.g.,
  Immediately-Invoked 
 Function Expression²⁶
 ). 
 ²⁴
 http://webapplog.com/tag/intro-to-express-js/
  
 ²⁵
 http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-
 regarding
 ²⁶
 http://en.wikipedia.org/wiki/Immediately-
 invoked_function_expression",NA
36 HackHall,NA,NA
Summary,"The HachHall app is a REST API server with a front-end client that is written in 
 Backbone.js and Underscore. For the purpose of this book, we’ll illustrate how to use 
 Express.js with MongoDB via Mongoose for the back-end REST API server. In addition, the 
 project utilizes OAuth and sessions, and Mocha for TDD.",NA
Example,"The HackHall source code is in the public
  GitHub repository¹
 . 
 The live demo is accessible at
  hackhall.com²
 , either with AngelList or pre-filled email 
 (1@1.com) and password (1).",NA
36.1 What is HackHall,"HackHall (ex-Accelerator.IO) is an open-source invite-only social network and 
 collaboration tool for hackers, hipsters, entrepreneurs and pirates (just kidding). HackHall 
 is akin to Reddit, plus Hacker News, plus Facebook Groups with curation.
  
 The HackHall project is in its early stage and roughly a beta. We plan to extend the code 
 base in the future and bring in more people to share skills, wisdom and passion for 
 programming.
  
 In this chapter, we’ll cover the
  1.0 release³
  which has:
  
 • OAuth 1.0 with oauth modules and AngelList API
  
 • Email and password authentication
  
 • Mongoose models and schemas
  
 • Express.js structure with routes in modules
  
 • JSON REST API
  
 • Express.js error handling
  
 ¹
 http://github.com/azat-co/hackhall
  
 ²
 http://hackhall.com
  
 ³
 https://github.com/azat-
 co/hackhall/releases/tag/1.0",NA
36.2 Running HackHall,"To get the source code, you can navigate to the
  hackhall
  folder or clone it from GitHub:
  
 1 
  
 $
  git clone git@github.com:azat-co/hackhall
  
 2 
  
 $
  git checkout 1.0
  
 3 
  
 $
  npm install
  
 If you plan to test an AngelList (optional), HackHall is using a Heroku and Foreman setup 
 for
  
 AngelList API keys, storing them in environmental variables, so we need to add an
  .evn
  file 
 like
  
 this (below are fake values):
  
 1 
  
 ANGELLIST_CLIENT_ID
 =
 254C0335-5F9A-4607-87C0
  
 2 
  
 ANGELLIST_CLIENT_SECRET
 =
 99F5C1AC-C5F7-44E6-81A1-8DF4FC42B8D9
  
 The keys can be found at
  angel.co/api⁵
  after someone creates and registers his/her 
 AngelList app.
  
 Download and install MongoDB if you don’t have it already. The databases and third-party 
 libraries
  
 are outside of the scope of this book. However, you can find enough materials
  online⁶
  and in
  
 Rapid
  
 Prototyping with JS⁷
 .
  
 To start the MongoDB server, open a new terminal window and run:
  
 1 
  
 $
  mongod
  
 Go back to the project folder and run:
  
 1 
  
 $
  foreman start",NA
36.3 Structure,"Here are what each of the folders and files contain:
  
 •
  /api
 : app-shared routes
  
 •
  /models
 : Mongoose models
  
 •
  /public
 : Backbone app, static files like front-end JavaScript, CSS, 
 HTML•
  /routes
 : REST API routes
  
 •
  /tests
 : Mocha tests
  
 •
  .gitignore
 : list of files that git should ignore
  
 •
  Makefile
 : make file to run tests",NA
36.4 Express.js App,"Let’s jump straight to the
  server.js
  file and learn how it’s implemented. Firstly, we declare
  
 dependencies:
  
 1 
  
 var
  express
  =
  require(
 'express'
 ),
  
 2 
 routes
  =
  require(
 './routes'
 ),
  
 3 
 http
  =
  require(
 'http'
 ),
  
 4 
 util
  =
  require(
 'util'
 ),
  
 5 
 oauth
  =
  require(
 'oauth'
 ),
  
 6 
 querystring
  =
  require(
 'querystring'
 );
  
 Then, we initialize the app and configure middlewares. The
  process.env.PORT
  is populated by
  
 Heroku, and in the case of a local setup, falls back on 3000.",NA
36.5 Routes,"The HackHall routes reside in the
  hackhall/routes
  folder and are grouped into several 
 modules:
  
 •
  hackhall/routes/index.js
 : bridge between
  server.js
  and other routes in the folder
  
 •
  hackhall/routes/auth.js
 : routes that handle OAuth dance with AngelList API
  
 •
  hackhall/routes/main.js
 : login, logout and other routes
  
 •
  hackhall/routes/users.js
 : routes related to users’ REST API
  
 •
  hackhall/routes/application.js
 : submission of application to become a user
  
 •
  hackhall/routes/posts.js
 : routes related to posts’ REST API",NA
36.5.1 index.js,"Let’s peek into
  hackhall/routes/index.js
  where we’ve included other modules:
  
 1 
  
 exports.posts
  =
  require(
 './posts'
 );
  
 2 
  
 exports.main
  =
  require(
 './main'
 );
  
 3 
  
 exports.users
  =
  require(
 './users'
 );
  
 4 
  
 exports.application
  =
  require(
 './application'
 );
  
 5 
  
 exports.auth
  =
  require(
 './auth'
 );",NA
36.5.2 auth.js,"In this module, we’ll handle OAuth
  dance
  with AngelList API. To do so, we’ll have to rely on 
 the",NA
36.5.3 main.js,"The
  hackhall/routes/main.js
  file is also interesting.
  
 The
  checkAdmin()
  function performs authentication for admin privileges. If the session object
  
 doesn’t carry the proper flag, we call Express.js
  next()
  function with an error object:
  
 1 
  
 exports.checkAdmin
  =
  function
 (request, response, next) {
  
 2 
 if
  (request.session
  
 3 
  
 &&
  request.session.auth
  
 4 
  
 &&
  request.session.userId
  
 5 
  
 &&
  request.session.admin) {
  
 6 
  
 console.info(
 'Access ADMIN: '
  +
  request.session.userId);
  
 7 
  
 return
  next();
  
 8 
 }
  else
  {
  
 9 
  
 next(
 'User is not an administrator.'
 );
  
 10 
 }
  
 11 
  
 };
  
 Similarly, we can check only for the user without checking for admin rights:
  
 1 
  
 exports.checkUser
  =
  function
 (req, res, next) {
  
 2 
 if
  (req.session
  &&
  req.session.auth
  &&
  req.session.userId
  
 3 
  
 &&
  (req.session.user.approved
  ||
  req.session.admin)) {
  
 4 
  
 console.info(
 'Access USER: '
  +
  req.session.userId);
  
 5 
  
 return
  next();
  
 6 
 }
  else
  {
  
 7 
  
 next(
 'User is not logged in.'
 );
  
 8 
 }
  
 9 
  
 };
  
 If an application is just an unapproved user object, we can also check for that:",NA
36.5.4 users.js,"The full source code for
  hackhall/routes/users.js
  files:",NA
36.5.5 applications.js,"In the current version, submitting and approving an application won’t trigger an email 
 notification.
  
 Therefore, users have to come back to the website to check their status.
  
 Merely add a user object (with approved=false by default) to the database:
  
 1 
  
 exports.add
  =
  function
 (req, res, next) {
  
 2 
 req.db.User.create({
  
 3 
  
 firstName
 :
  req.body.firstName,
  
 4 
  
 lastName
 :
  req.body.lastName,
  
 5 
  
 displayName
 :
  req.body.displayName,
  
 6 
  
 headline
 :
  req.body.headline,
  
 7 
  
 photoUrl
 :
  req.body.photoUrl,
  
 8 
  
 password
 :
  req.body.password,
  
 9 
  
 email
 :
  req.body.email,",NA
36.5.6 posts.js,"The last routes module that we bisect is
  hackhall/routes/posts.js
 . It takes care of adding, 
 editing
  
 and removing posts, as well as commenting, watching and liking.
  
 We use object ID for conversion from HEX strings to proper objects:
  
 1 
  
 objectId
  =
  require(
 'mongodb'
 ).ObjectID;
  
 The coloring is nice for logging, but it’s of course optional. We accomplish it with escape 
 sequences:
  
 1 
  
 var
  red, blue, reset;
  
 2 
  
 red 
  
 =
  '[31m'
 ;
  
 3 
  
 blue 
  
 =
  '[34m'
 ;
  
 4 
  
 reset
  =
  '[0m'
 ;
  
 5 
  
 console.log(red
  +
  'This is red'
  +
  reset
  +
  ' while '
  +
  blue
  +
  ' this is blue'
  +
  re
 \
  
 6 
  
 set);
  
 The default values for the pagination of posts:
  
 1 
  
 var
  LIMIT
  = 10
 ;
  
 2 
  
 var
  SKIP
  = 0
 ;
  
 The
  add()
  function handles creation of new posts:",NA
36.6 Mogoose Models,"Ideally, in a big application, we would break down each model into a separate file. Right 
 now in the
  
 HackHall app, we have them all in
  hackhall/models/index.js
 .
  
 As always, our dependencies look better at the top:
  
 1 
  
 var
  mongoose
  =
  require(
 'mongoose'
 );
  
 2 
  
 var
  Schema
  =
  mongoose.Schema;
  
 3 
  
 var
  roles
  =
  'user staff mentor investor founder'
 .split(
 ' '
 );
  
 The Post model represents post with its likes, comments and watches.
  
 1 
  
 exports.Post
  =
  new
  Schema ({
  
 2 
 title
 :
  {
  
 3 
  
 required
 :
  true
 ,
  
 4 
  
 type
 :
  String
 ,
  
 5 
  
 trim
 :
  true
 ,
  
 6 
  
 // match: /^([[:alpha:][:space:][:punct:]]{1,100})$/
  
 7 
  
 match
 :
  /^([\w ,.!?]{1,100})$/
  
 8 
 },
  
 9 
 url
 :
  {
  
 10 
  
 type
 :
  String
 ,
  
 11 
  
 trim
 :
  true
 ,
  
 12 
  
 max
 : 1000
  
 13 
 },
  
 14 
 text
 :
  {
  
 15 
  
 type
 :
  String
 ,
  
 16 
  
 trim
 :
  true
 ,
  
 17 
  
 max
 : 2000
  
 18 
 },
  
 19 
 comments
 :
  [{
  
 20 
  
 text
 :
  {
  
 21 
  
 type
 :
  String
 ,
  
 22 
  
 trim
 :
  true
 ,
  
 23 
  
 max
 :2000",NA
36.7 Mocha Tests,"One of the benefits of using REST API server architecture is that each route and the 
 application as a whole become very testable. The assurance of the passed tests is a 
 wonderful supplement during development — the so-called test-driven development 
 approach.
  
 To run tests, we utilize Makefile:
  
 1 
  
 REPORTER
  =
  list
  
 2 
  
 MOCHA_OPTS
  = --
 ui tdd
  --
 ignore
 -
 leaks
  
 3
  
 4
  
 test:
  
 clear
  
 5
  
 6
  
 echo Starting test
  *********************************************************
  
 7
  
 .
 /
 node_modules
 /
 mocha
 /
 bin
 /
 mocha \
  
 8
  
 --
 reporter
  $
 (REPORTER) \
  
 9
  
 $
 (MOCHA_OPTS) \
  
 10
  
 tests
 /*
 .js
  
 11
  
 echo Ending test
  
 12
  
 13
  
 test
 -
 w
 :
  
 .
 /
 node_modules
 /
 mocha
 /
 bin
 /
 mocha \
  
 14
  
 15
  
 --
 reporter
  $
 (REPORTER) \
  
 16
  
 --
 growl \
  
 17
  
 --
 watch \
  
 18
  
 $
 (MOCHA_OPTS) \
  
 19
  
 tests
 /*
 .js
  
 20
  
 21
  
 users:
  
 mocha tests
 /
 users.js
  --
 ui tdd
  --
 reporter list
  --
 ignore
 -
 leaks
  
 22
  
 23
  
 24
  
 posts:
  
 clear
  
 25
  
 26
  
 echo Starting test
  *********************************************************
  
 27
  
 .
 /
 node_modules
 /
 mocha
 /
 bin
 /
 mocha \
  
 28
  
 --
 reporter
  $
 (REPORTER) \
  
 29
  
 $
 (MOCHA_OPTS) \
  
 30
  
 tests
 /
 posts.js
  
 31
  
 echo Ending test
  
 32",NA
Warning ,"Please don’t store plain passwords/keys in the database. Any serious production 
 app should 
 at least
  salt the passwords¹¹
  before storing them.",NA
36.8 Conclusion,"HackHall is still in development, but there are important real production application 
 components, such as REST API architecture, OAuth, Mongoose and its models, MVC 
 structure of Express.js apps, access to environment variables, etc.
  
 ¹¹
 https://crackstation.net/hashing-security.htm",NA
ExpressWorks,NA,NA
Summary,"ExpressWorks is an automated workshop that will walk you through the building of Express.js 
 servers, processing of GET, POST and PUT requests, and the extraction of query string, payload 
 and URL parameters.",NA
What is ExpressWorks Based On?,"ExpressWorks is the Express.js workshop based on
  workshopper¹²
  and inspired by
  stream-
 adventure¹³
 by
  @substack¹⁴
  and
  @maxogden¹⁵
 .
  
 ¹²
 https://github.com/rvagg/workshopper
  
 ¹³
 https://github.com/substack/stream-
 adventure
  
 ¹⁴
 https://twitter.com/substack
  
 ¹⁵
 https://twitter.com/maxogden",NA
Installation (recommended),"Recommended global installation:
  
 1 
  
 $
  npm install -g expressworks
  
 2 
  
 $
  expressworks
  
 If you see errors, try:",NA
Local Installation (advanced),"Run and install locally:
  
 1 
  
 $
  npm install expressworks
  
 2 
  
 $
  cd
  expressworks
  
 3 
  
 $
  npm install
  
 4 
  
 $
  node expressworks",NA
Usage,"ExpressWorks understands these commands:
  
 1 
  
 Usage
  
 2
  
 3 
 expressworks
  
 4 
  
 Show a menu to interactively select a workshop.
  
 5 
 expressworks list
  
 6 
  
 Show a newline
 -
 separated list of all the workshops.
  
 7 
 expressworks select NAME
  
 8 
  
 Select a workshop.
  
 9 
 expressworks current
  
 10 
  
 Show the currently selected workshop.
  
 11 
 expressworks run program.js
  
 12 
  
 Run your program against the selected input.
  
 13 
 expressworks verify program.js
  
 14 
  
 Verify your program against the expected output.",NA
Reset,"If you want to reset the list of completed tasks, clean the
  ∼
 /.config/expressworks/completed.json 
 file.",NA
Steps,NA,NA
Hello World,"Create an Express.js app that runs on localhost:3000, and outputs “Hello World!” when 
 somebody goes to root ‘/home’.
  
 process.argv[2]
  will be provided by expressworks to you. This is the port number.",NA
Jade,"Create an Express.js app with a home page (/home) rendered by a Jade template engine 
 that shows the current date (toDateString).",NA
Good Old Form,"Write a route (‘/form’) that processes an HTML form input (
 <form><input 
 name=""str""/></form>
 ) and prints the str value backwards.",NA
Static,"Apply static middleware to the server index.html file without any routes. The index.html 
 file is provided and usable via the
  process.argv[3]
  value of the path to it. However, you can 
 use your own file with this content:",NA
Stylish CSS,"Style your HTML from the previous example with some Stylus middleware. The path to the main.styl
  
 file is provided in
  process.argv[3]
 , or you can create your own file/folder from these:
  
 1
  
 p
  
 color red
  
 2
  
 The index.html file:
  
 1 
 <html>
  
 2 
  
 <head>
  
 3 
  
 <title>
 expressworks
 </title>
  
 4 
  
 <link
  rel=
 ""stylesheet""
  type=
 ""text/css""
  href=
 ""/main.css""
 />
  
 5 
  
 </head>
  
 6 
  
 <body>
  
 7 
  
 <p>
 I am red!
 </p>
  
 8 
  
 </body>
  
 9 
 </html>",NA
Param Pam Pam,"Create an Express.js server that processes PUT
  /message/:id
  requests, e.g., PUT
  
 /message/526aa677a8ceb64569c9d
  
 The response of this request returns id SHA1 hashed with a date:
  
 1 
 require(
 'crypto'
 )
  
 2 
  
 .createHash(
 'sha1'
 )
  
 3 
  
 .update(
 new
  Date
 ().toDateString().toString()
  +
  id)
  
 4 
  
 .digest(
 'hex'
 )",NA
What’s in a Query ,"Write a route that extracts data from a query string in the GET
  /search
  URL route, e.g., 
 ?results=recent&include_tabs=true
 , and then transforms and outputs it back to the user in JSON 
 format.",NA
JSON Me ,"Write a server that reads a file (file name is passed in
  process.argv[3]
 ), then parses it to JSON, 
 and outputs the content to the user with
  res.json(object)
 .",NA
Related Reading and Resources,NA,NA
Summary,"In this short chapter, we’ll provide a list of the most useful Node.js resources for further 
 learning.",NA
Other Node.js Frameworks,"The Express.js framework is no doubt the most mature, popular, robust, tested and used 
 project for Node.js web services. As of this writing, Express.js is also the most starred NPM 
 repository with 2x more stars that
  request¹⁶
  and
  async¹⁷
  libraries. There are plenty of real 
 production apps that rely on Express 2.x and 3.x including
  Storify¹⁸
  (acquired by
  
 LiveFyre¹⁹
 ),
  DocuSign²⁰
 , new
  MySpace²¹
 , 
 LearnBoost²²
 ,
  Geekli.st²³
 ,
  Klout²⁴
 ,
  Prismatic²⁵
 ,
  
 Segment.io²⁶
  and
  more²⁷
 .
  
 ¹⁶
 http://npmjs.org/request
  
 ¹⁷
 http://npmjs.org/async
  
 ¹⁸
 http://storify.com
  
 ¹⁹
 http://livefyre.com
  
 ²⁰
 http://docusign.com
  
 ²¹
 http://new.myspace.com
  
 ²²
 https://www.learnboost.com/
  
 ²³
 http://geekli.st/
  
 ²⁴
 http://klout.com/
  
 ²⁵
 http://getprismatic.com/
  
 ²⁶
 http://segment.io/
  
 ²⁷
 http://expressjs.com/applications.h
 tml",NA
Node.js Books,"For more core Node.js overview and/or other components of the Node.js stack, such as 
 databases and websockets, please consider these resources:
  
 •
  Rapid Prototyping with JS: Agile JavaScript Development³¹
  (Azat Mardan) — 
 beginner-to-intermediate book on Node.js, MongoDB and Backbone.js
  
 •
  JavaScript and Node FUNdamentals: A Collection of Essential Basics³²
  (Azat Mardan) 
 — short read on simple but important concepts of browser JS and Node
  
 •
  Pro Node.js³³
  (Colin J. Ihrig) — ISBN: 978-1-4302-5860-5, comprehensive low-level 
 book on Node.js sans any non-core modules
  
 •
  Node.js in Action³⁴
  (TJ Holowaychuk et al) — ISBN: 9781617290572 not yet 
 published (est. end of 2013). Book about Express.js from the creators of the framework
  
 •
  Learning Node³⁵
  (Shelley Powers) — ISBN: 978-1-4493-2307-3 book covers Express, 
 MongoDB, Mongoose and Socket.IO
  
 •
  Node Cookbook³⁶
  (David Mark Clements) — ISBN: 978-1-84951-718-8 book covers 
 databases and websockets
  
 •
  Node: Up and Running³⁷
  (Tom Hughes-Croucher et al) brief overview of Node.js
  
 •
  Smashing Node.js³⁸
  (Guillermo Rauch) covers Express.js, Jade, and Stylus from the 
 creator of Mongoose ORM for MongoDB",NA
JavaScript Classics,"For deeper understanding of the most misunderstood and most popular programming 
 language, please make sure to read these proven classics:
  
 •
  Eloquent JavaScript³⁹
 : programming fundamentals in the JavaScript coating
  
 •
  JavaScript: The Good Parts⁴⁰
 : tricky part of the language
  
 ³¹
 http://rpjs.co
  
 ³²
 https://leanpub.com/jsfun
  
 ³³
 http://www.apress.com/9781430258605
  
 ³⁴
 http://www.manning.com/cantelon/
  
 ³⁵
 http://shop.oreilly.com/product/0636920024606.do
  
 ³⁶
 http://my.safaribooksonline.com/9781849517188
  
 ³⁷
 http://shop.oreilly.com/product/0636920015956
  
 ³⁸
 http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-
 Magazine/dp/1119962595
 ³⁹
 http://eloquentjavascript.net/
  
 ⁴⁰
 http://www.amazon.com/dp/0596517742",NA
Contact Us,"Let’s be friends on the Internet!
  
 • Tweet Node.js question on Twitter:
  @azat_co⁴¹
  
 • Follow Azat on Facebook:
  
 facebook.com/profile.php?id=1640484994⁴²
 • Website:
  
 expressjsguide.com⁴³
  
 • GitHub:
  github.com/azat-co/rpjs⁴⁴
  
 Other Ways to Reach Us
  
 • Email Azat directly:
  hi@azat.co⁴⁵
  
 • Google Group:
  rpjs@googlegroups.com⁴⁶
  and
  
 https://groups.google.com/forum/#!forum/rpjs
 • Blog:
  webapplog.com⁴⁷
  
 •
  HackHall⁴⁸
 : community for hackers, hipsters and pirates
  
 Share on Twitter
  with ClickToTweet link:
  http://ctt.ec/dd0Nc
 , or just click:
  
 “I’ve finished reading Express.js Guide — The Comprehensive Book on 
 Express.js by @azat_co #RPJS #Node.js”⁴⁹
  
 ⁴¹
 https://twitter.com/azat_co
  
 ⁴²
 https://www.facebook.com/profile.php?id=16404
 84994
  
 ⁴³
 http://expressjsguide.com/
  
 ⁴⁴
 https://github.com/azat-co/expressjsguide
  
 ⁴⁵
 mailto:hi@azat.co
  
 ⁴⁶
 mailto:rpjs@googlegroups.com
  
 ⁴⁷
 http://webapplog.com
  
 ⁴⁸
 http://hackhall.com
  
 ⁴⁹
 http://ctt.ec/dd0Nc",NA
Appendix A: Migrating Express.js 3.x ,NA,NA
"to 4.x: Middleware, Route and ",NA,NA
Other Changes,"Express.js⁵⁰
  4 is the latest (as of May 2014) version of the most popular mature and robust 
 Node.js framework for web apps, services and APIs. There are some breaking changes 
 going from 3.x to 4.x, so here’s a brief migration guide:
  
 • Replacing Unbundled Middleware in Express.js 4
  
 • Removing Deprecated Methods from Express.js 4 Apps
  
 • Other Express.js 4 Changes
  
 • Express.js 4 Route Instance and Chaining It
  
 • Further Express.js 4 Migration Reading Links",NA
Replacing Unbundled Middleware in Express.js 4,"Let’s start with the biggest change that will break most of your Express.js 3.x projects. This 
 is also the most discussed news (and long awaited?) on the Internet. Yes, it’s unbundled 
 middleware.
  
 Personally, I’m not sure whether it’s good or bad, because I kind of liked not having to 
 declare extra dependencies. However, I can see the arguments for unbundling as well, 
 including things like keeping the Express.js module small, upgrading middleware packages 
 independently, etc.
  
 So what is unbundled middleware? Remember the magic middleware that we used by just 
 typing 
 app.use(express.middlwarename())
 ? Well, they were coming from the Connect library and 
 now they are gone from Express.js. It was customary to write, for example
  
 app.use(express.cookieParser()) 
 in Express.js 3.x. Those modules are very important and essential 
 for pretty much any web application. They were part of the Connect library, but Express.js 4.x 
 doesn’t have Connect as a dependency. This means that if we want to use it (and we sure do!), 
 we’ll need to explicitly include middleware like this:
  
 1 
  
 $
  npm install body-parse@1.0.2 --save
  
 And then in the Express.js main configuration file (e.g.,
  app.js
 ), use the included module like this:
  
 ⁵⁰
 http://expressjs.com/",NA
Removing Deprecated Methods from Express.js 4 Apps,NA,NA
app.configure(),"I don’t think most people ever used it.
  app.configure()
  was a sugar-coating which was nice but 
 a non-essential piece mostly meant for setting up environments. If you have it, just replace 
 app.configure('name', function(){...})
  with
  if (process.env.NODE_ENV === 'name') {...}
 .
  
 For example, this old Express.js 3 production configuration:
  
 1 
  
 app.configure(
 'production'
 ,
  function
 () {
  
 2 
 app.set(
 'port'
 ,
  80
 )
  
 3 
  
 })
  
 In Express.js 4.x, becomes:
  
 1 
  
 if
  (process.env.NODE_ENV
  ===
  '
 production) {
  
 2 
 app.set(
 '
 port
 '
 ,
  80
 )
  
 3 
  
 })
  
 PS: If you look into Express.js 3.x code on GitHub, that’s exactly what
  app.configure()
  did. ;-)
  
 ⁶⁶
 https://github.com/jed/cookies
  
 ⁶⁷
 https://github.com/jed/keygrip
  
 ⁶⁸
 https://github.com/stream-utils/raw-body
  
 ⁶⁹
 https://github.com/superjoe30/connect-
 multiparty
  
 ⁷⁰
 https://github.com/mscdex/connect-busboy
  
 ⁷¹
 https://github.com/visionmedia/node-
 querystring
  
 ⁷²
 https://github.com/isaacs/st
  
 ⁷³
 https://github.com/andrewrk/connect-static
  
 ⁷⁴
 https://github.com/senchalabs/connect#midd
 leware",NA
app.router,"One of the good changes is that the need to write
  app.router
  has been eliminated! So now, 
 basically
  
 the order of middleware and routes is the only thing that counts, but before developers 
 were able to
  
 augment the order of execution by placing
  app.router
  somewhere in the middle.
  
 If you had any middleware that is supposed to be after the routes (but in the old wasn’t due 
 to
  
 deprecated
  app.router
 ) move it
  after the route
 , just in the order you want them.
  
 For example before, there is error handling middleware which is executed after routes in 
 the
  
 Express.js 3.x:
  
 1 
  
 app.use(express.cookieParser())
  
 2 
  
 app.use(app.router)
  
 3 
  
 app.use(express.errorHandler())
  
 4 
  
 app.get(
 '/'
 , routes.index)
  
 5 
  
 app.post(
 '
 /
 signup
 '
 , routes.signup)
  
 Migrates into this code in Express.js 4.x:
  
 1 
  
 var cookieParse
  =
  require(
 '
 cookie
 -
 parser
 '
 )
  
 2 
  
 var errorHandler
  =
  require(
 '
 errorhandler
 '
 )
  
 3 
  
 ...
  
 4 
  
 app.use(cookieParser())
  
 5 
  
 app.get(
 '/'
 , routes.index)
  
 6 
  
 app.post(
 '
 /
 signup
 '
 , routes.signup)
  
 7 
  
 app.use(errorHandler())
  
 In other words,
  app.use()
  and routes with verbs such as
  app.get()
 ,
  app.post()
 ,
  app.put()
  and
  
 app.del()
  became equal counterparts.",NA
res.on(‘header’),"res.on('header')
  was removed from Connect 3.",NA
res.charset,"In Express.js 4.x, use
  res.type()
  or
  res.set('content-type')
  instead of
  res.charset
  in Express.js
  
 3.x.",NA
res.headerSent,"Use
  res.headersSent
  instead.",NA
req.accepted(),"Use
  req.accepts()
  instead.
  
 req.accepted
  in Express.js 4.x is powered by the module
  accepts
  (
 GitHub⁷⁵
 ), which was 
 “extracted
  
 from
  Koa.js⁷⁶
  for general use” as the documentation says.",NA
Other Express.js 4 Changes,NA,NA
app.use(),"Amazingly,
  app.use()
  now accepts URL parameters. This is another step towards making
  
 app.use()
  
 and verb route methods equal and less confusing. The parameter is in the
  req.params
  object.
  
 For example, if we need to get ID from the URL, in Express.js 4.x middleware, we can write:
  
 1 
  
 app.use(
 '/posts/:slug'
 ,
  function
 (req, res, next) {
  
 2 
 req.db.findPostBySlug(req.params.slug,
  function
 (post){
  
 3 
 ...
  
 4 
 })
  
 5 
  
 })",NA
res.location(),It’s not resolving relative URL.,NA
app.route,Look below at the section called “Express.js 4 Route Instance and Chaining It”.,NA
json spaces,"json spaces
  is off by default in development",NA
req.params,"req.params
  is an object, not an array.
  
 ⁷⁵
 https://github.com/expressjs/accepts",NA
res.locals,"res.locals
  is an object now.",NA
req.is,"req.is
  in Express.js 4.x was replaced by the module
  type-is
  (
 GitHub⁷⁷
 ), which was also 
 “extracted
  
 from [Koa.js](http://koajs.com for general use” as the documentation says.",NA
Express.js Command-Line Generator,"For the command-line generator use
  
 1 
  
 $
  sudo npm install -g express-generator
  
 Instead of old plain
  $ sudo npm install -g express
 .",NA
Express.js 4 Route Instance and Chaining It,"The
  app.route()
  method gives us the new Express.js 4 Route instance, but before we explore 
 it, let’s
  
 take a look at the router itself.
  
 The Router class has been supercharged in Express.js 4.x. Before the app instance used 
 router, but
  
 now we can create many route instances and use the for specific paths by attaching 
 particular
  
 middleware and other logic. This can be used to re-organize code. This of Router as a mini 
 Express.js
  
 application!
  
 Here’s a basic example on how developers can use Router in Express.js 4.x. Let’s say we 
 have reviews
  
 for two categories: books and games. The reviews logic is similar to and packaged as a router:
  
 1 
  
 var
  express
  =
  require(
 'express'
 )
  
 2 
  
 var
  app
  =
  express()
  
 3 
  
 var
  router
  =
  express.Router()
  
 4
  
 5 
  
 router.use(
 function
 (req, res, next) {
  
 6 
 //process each request",NA
Further Express.js 4 Migration Reading Links,"So overall, the Express.js 4.x changes are not very dramatic, and the migration can go 
 relatively painless. But just before you hit
  $ git checkout -b express4
  to create a new branch for 
 your migration from 3.x, think if you really need to do it! I know many successful 
 production applications that haven’t updated their main framework versions. At Storify, we 
 used to run Express.js 2.x when 3.x was available and it was a big deal. Another example 
 from the Ruby world, I know many apps and developers who still work with Ruby on Rails 
 2.x when there is Ruby on Rails 4.x.
  
 In case you decide to go with Express.js 4, don’t rely just on this brief overview. Take a look 
 at these additional resources to help make a transition from Express.js 3.x to 4.x easier:
  
 •
  The official migration guide⁷⁸
  
 •
  New features in Express.js 4.x⁷⁹
  
 •
  Express.js 4.x documentation⁸⁰
  
 •
  Express.js 4, Node.js and MongoDB REST API Tutorial⁸¹
  
 ⁷⁸
 https://github.com/visionmedia/express/wiki/Migrating-from-3.x-
 to-4.x
 ⁷⁹
 https://github.com/visionmedia/express/wiki/New-features-
 in-4.x
  
 ⁸⁰
 http://expressjs.com/4x/api.html
  
 ⁸¹
 http://webapplog.com/express-js-4-node-js-and-mongodb-rest-api-
 tutorial/",NA
"Appendix B: Express.js 4, Node.js and ",NA,NA
MongoDB REST API Tutorial,"Usually good things don’t stay the same, so our
  tutorial⁸²
  on building a JSON REST API 
 server with Node.js and MongoDB using Mongoskin and Express.js, and testing it with 
 Mocha and Superagent, has became a bit outdated with the new Express.js 4 version 
 release. Here’s a brand new, revisited tutorial for
  Express.js 4, Node.js and MongoDB
  
 (Mongoskin) free-JSON RESTful API server.
  
 The code for this new tutorial is available at
  github.com/azat-co/rest-api-express⁸³
  (
 master
  
 branch). The old tutorial’s code for Express 3.x, is still working and in the
  express3
  branch.
  
 Express.js 4 and MongoDB REST API Tutorial consists of these parts:
  
 1. Node.js and MongoDB REST API Overview 
  
 2. REST API Tests with Mocha and Superagent 
  
 3. NPM-ing Node.js Server Dependencies 
  
 4. Express.js 4.x Middleware Caveat 
  
 5. Express.js and MongoDB (Mongoskin) Implementation 
  
 6. Running The Express.js 4 App and Testing MongoDB Data with 
 Mocha 7. Conclusion and Further Express.js and Node.js Reading
  
 Instead of TL;DR:
  
 If you’re only interested in a working code from the repository and
  know what to do
 , here 
 are brief instructions on how to download and run the REST API server:
  
 1 
  
 $
  git clone git@github.com:azat-co/rest-api-express.git
  
 2 
  
 $
  npm install
  
 3 
  
 $
  node express.js
  
 Start MongoDB with
  $ mongod
 . Then, in a new terminal window run the Mocha tests:
  
 1 
  
 $
  mocha express.test.js
  
 Or, if you don’t have mocha installed globally:
  
 ⁸²
 http://webapplog.com/tutorial-node-js-and-mongodb-json-rest-api-server-with-mongoskin-and-
 express-js/
 ⁸³
 https://github.com/azat-co/rest-api-express",NA
Node.js and MongoDB REST API Overview,"This Node.js, Express.js and MongoDB (Mongoskin) tutorial will walk you through writing 
 the test using the
  Mocha⁸⁴
  and
  Super Agent⁸⁵
  libraries. This is needed for a test-driven 
 development building of a
  Node.js⁸⁶
  free JSON REST API server.
  
 The server application itself will utilize
  Express.js⁸⁷
  4.x framework and
  Mongoskin⁸⁸
  
 library for 
 MongoDB⁸⁹
 . In this REST API server, we’ll perform
  create, read, update and 
 delete
  (CRUD) operations and harness Express.js
  middleware⁹⁰
  concept with
  app.param()
  
 and
  app.use()
  methods.
  
 First of all, make sure you have MongoDB installed. You can follow the steps on
  the official 
 website⁹¹
 .
  
 We’ll be using the following versions of libraries:
  
 •
  express
 :
  ∼
 4.1.1
  
 •
  body-parser
 :
  ∼
 1.0.2
  
 •
  mongoskin
 :
  ∼
 1.4.1
  
 •
  expect.js:
  ∼
 0.3.1
  
 •
  mocha
 :
  ∼
 1.18.2
  
 •
  superagent
 :
  ∼
 0.17.0
  
 If you try to attempt to use later or older versions the code might not work. :-(",NA
REST API Tests with Mocha and Superagent,"Before anything else, let’s write functional tests that make HTTP requests to our soon-to-
 be-created REST API server. If you know how to use
  Mocha⁹²
  or just want to jump straight 
 to the Express.js app implementation, feel free to do so. You can use CURL terminal 
 commands for testing too.
  
 Assuming we already have Node.js,
  NPM⁹³
  and MongoDB installed, let’s create a
  new
  folder 
 (or if you wrote the tests use that folder):
  
 ⁸⁴
 http://visionmedia.github.io/mocha/
  
 ⁸⁵
 http://visionmedia.github.io/superag
 ent/
  
 ⁸⁶
 http://nodejs.org
  
 ⁸⁷
 http://expressjs.com/
  
 ⁸⁸
 https://github.com/kissjs/node-
 mongoskin
  
 ⁸⁹
 http://www.mongodb.org/
  
 ⁹⁰
 http://expressjs.com/api.html#middl",NA
NPM-ing Node.js Server Dependencies,"In this tutorial, we’ll utilize
  Mongoskin⁹⁷
 , a MongoDB library which is a better alternative to 
 the
  
 plain, good old
  native MongoDB driver for Node.js⁹⁸
 . In addition, Mongoskin is more 
 lightweight
  
 than Mongoose and schema-less. For more insight, please check out
  Mongoskin comparison 
 blurb⁹⁹
 .
  
 Express.js¹⁰⁰
  is a wrapper for the core Node.js
  HTTP module¹⁰¹
  objects. The Express.js 
 framework is
  
 built on top of
  Connect¹⁰²
  middleware and provides tons of convenience. Some people 
 compare the
  
 ⁹⁷
 https://github.com/kissjs/node-mongoskin
  
 ⁹⁸
 https://github.com/mongodb/node-mongodb-native",NA
Express.js 4 and MongoDB (Mongoskin) ,NA,NA
Implementation,"First thing’s first, so let’s define our dependencies:
  
 1 
  
 var
  express
  =
  require(
 'express'
 )
  
 2 
 , mongoskin
  =
  require(
 'mongoskin'
 )
  
 3 
 , bodyParser
  =
  require(
 'body-parser'
 )
  
 After the version 3.x (this of course includes v4), Express.js streamlines the instantiation of 
 its app instance, this line will give us a server object:
  
 1 
  
 var
  app
  =
  express()
  
 To extract params from the body of the requests, we’ll use
  bodyParser()
  middleware which 
 looks more like a configuration statement:
  
 1 
  
 app.use(bodyParser())
  
 Middleware (in
  this¹⁰³
  and
  other forms¹⁰⁴
 ) is a powerful and convenient pattern in 
 Express.js and 
 Connect¹⁰⁵
  to organize and re-use code.
  
 As with the
  bodyParser()
  method that saves us from the hurdles of parsing a body object of 
 HTTP request,
  Mongoskin¹⁰⁶
  makes it possible to connect to the MongoDB database in one 
 effortless line of code:
  
 ¹⁰³
 http://expressjs.com/api.html#app.u
 se
  
 ¹⁰⁴
 http://expressjs.com/api.html#middl
 eware",NA
Running The Express.js 4 App and Testing MongoDB,NA,NA
Data with Mocha,NA,NA
Conclusion and Further Express.js and Node.js Reading,"The Express.js 4 and MongoDB/Mongoskin libraries are great when you need to build a 
 simple REST API server in a few lines of code. Later, if you need to expand the libraries they 
 also provide a way to configure and organize your code.
  
 NoSQL databases like MongoDB are good at free-REST APIs where we don’t have to define 
 schemas and can throw any data and it’ll be saved.
  
 The full source code for
  express.text.js
 ,
  express.js
  and
  package.json
  is available at
  github.com/azat-
 co/rest-api-express¹⁰⁸
 .
  
 If you would like to learn more about Express.js and other JavaScript libraries, take a look 
 at the following books by Azat:
  
 •
  Practical Node.js: Building Real-world Scalable Web Apps¹⁰⁹
  [2014, Apress]
  
 • Pro Express.js [2014, Apress]
  
 In addition, checkout the
  free series of posts
  on webapplog.com:
  Intro to Express.js 
 tutorials¹¹⁰
 .
  
 Note
 : In this example I’m using semi-colon less style. Semi-colons in JavaScript are
  
 absolutely optional¹¹¹
  except in two cases: in the for loop and before expression/statement 
 that starts with parenthesis (e.g.,
  Immediately-Invoked Function Expression¹¹²
 ).
  
 ¹⁰⁸
 https://github.com/azat-co/rest-api-express
  
 ¹⁰⁹
 http://amzn.to/NuQ0fM
  
 ¹¹⁰
 http://webapplog.com/tag/intro-to-express-js/
  
 ¹¹¹
 http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-
 regarding
 ¹¹²
 http://en.wikipedia.org/wiki/Immediately-
 invoked_function_expression",NA
Appendix C: Express.js 4 Cheatsheet,"•
  Buy an awesome print-ready PDF¹¹³",NA
Installation,"•
  $ sudo npm install express
 : install the latest Express.js locally‘
  
 •
  $ sudo npm install express@4.2.0 --save
 : install Express.js v4.2.0 locally and save to 
 package.json
  
 •
  $
  
 sudo
  
 npm
  
 install
  
 -g
  
 express-generator@4.0.0
 : install Express.js command-line
  
 generator v4.0.0",NA
Generator,"Usage:
  $ express [options] [dir]
  
 Options:
  
 •
  -h
 : print the usage information
  
 •
  -V
 : print the express-generator version number
  
 •
  -e
 : add ejs engine support, defaults to jade if 
 omitted•
  -H
 : add hogan.js engine support
  
 •
  -c <library>
  add CSS support for
  
 •
  -f
 : generate into a non-empty directory",NA
Basics,"•
  var express = require('express')
 : include the module
  
 •
  var app = express()
 : create an instance
  
 •
  app.listen(portNumber, callback)
 : start the Express.js server
  
 •
  http.createServer(app).listen(portNumber, callback)
 : start the Express.js server•
  
 app.set(key, value)
 : set a property value by the key
  
 •
  app.get(key)
 : get a property value by the key
  
 ¹¹³
 https://gum.co/NQiQ",NA
HTTP Verbs and Routes,"•
  app.get()
  
 •
  app.post()
  
 •
  app.put()
  
 •
  app.del()
  
 •
  app.all()
  
 •
  app.param()
 :
  
 •
  app.use()",NA
Request,"•
  request.params
 : parameters middlware
  
 •
  request.param
 : extract one parameter
  
 •
  request.query
 : extract query string parameter
  
 •
  request.route
 : return route string
  
 •
  request.cookies
 : cookies, requires cookieParser
  
 •
  request.signedCookies
 : signed cookies, requires
  cookie-parser
 •
  
 request.body
 : payload, requires
  body-parser",NA
Request Header Shortcuts,"•
  request.get(headerKey)
 : value for the header key•
  
 request.accepts(type)
 : checks if the type is accepted•
  
 request.acceptsLanguage(language)
 : checks language•
  
 request.acceptsCharset(charset)
 : checks charset• 
 ‘request.is(type): checks the type
  
 •
  request.ip
 : IP address
  
 •
  request.ips
 : IP addresses (with trust-proxy on)
  
 •
  request.path
 : URL path
  
 •
  request.host
 : host without port number
  
 •
  request.fresh
 : checks freshness
  
 •
  request.stale
 : checks staleness
  
 •
  request.xhr
 : true for AJAX-y requests
  
 •
  request.protocol
 : returns HTTP protocol
  
 •
  request.secure
 : checks if protocol is
  https
  
 •
  request.subdomains
 : array of subdomains
  
 •
  request.originalUrl
 : original URL",NA
Response,"•
  response.redirect(status, url)
 : redirect request
  
 •
  response.send(status, data)
 : send response
  
 •
  response.json(status, data):
  send JSON and force proper headers•
  
 response.sendfile(path, options, callback)
 : send a file
  
 • ‘response.render(templateName, locals, callback): render a 
 template•
  response.locals
 : pass data to template",NA
Handlers Signatures,"•
  function(request, response, next) {}
 : request handler signature•
  
 function(error, request, response, next) {}
 : error handler signature",NA
Stylus and Jade,"1 
  
 app.set(
 '
 views
 '
 , path.join(__dirname,
  '
 views
 '
 ))
  
 2 
  
 app.set(
 '
 view engine
 '
 ,
  '
 jade
 '
 )
  
 app.use(require('stylus').middleware(path.join(__dirname, 'public')))",NA
Body,"1 
  
 var bodyParser
  =
  require(
 '
 body
 -
 parser
 '
 )
  
 2 
  
 app.use(bodyParser.json())
  
 3 
  
 app.use(bodyParser.urlencoded())",NA
Static,"app.use(express.static(path.join(__dirname, 'public')))",NA
Connect Middleware,"$ sudo npm install <package_name> --save
  
 •
  body-parser¹¹⁴
  request payload
  
 ¹¹⁴
 https://github.com/expressjs/body-parser",NA
Other Popular Middleware,"•
  cookies¹²⁹
  and
  keygrip¹³⁰
 : analogous to
  
 cookieParser
 •
  raw-body¹³¹
  
 •
  connect-multiparty¹³²
 ,
  connect-busboy¹³³
  
 •
  qs¹³⁴
 : analogous to
  query
  
 •
  st¹³⁵
 ,
  connect-static¹³⁶
  analogous to
  staticCache
  
 ¹¹⁵
 https://github.com/expressjs/compression
  
 ¹¹⁶
 https://github.com/expressjs/timeout
  
 ¹¹⁷
 https://github.com/expressjs/cookie-parser
  
 ¹¹⁸
 https://github.com/expressjs/cookie-session
  
 ¹¹⁹
 https://github.com/expressjs/csurf
  
 ¹²⁰
 https://github.com/expressjs/errorhandler
  
 ¹²¹
 https://github.com/expressjs/session
  
 ¹²²
 https://github.com/expressjs/method-
 override
  
 ¹²³
 https://github.com/expressjs/morgan
  
 ¹²⁴
 https://github.com/expressjs/response-time
  
 ¹²⁵
 https://github.com/expressjs/serve-favicon
  
 ¹²⁶
 https://github.com/expressjs/serve-index
  
 ¹²⁷
 https://github.com/expressjs/serve-static
  
 ¹²⁸
 https://github.com/expressjs/vhost
  
 ¹²⁹
 https://github.com/jed/cookies
  
 ¹³⁰
 https://github.com/jed/keygrip
  
 ¹³¹
 https://github.com/stream-utils/raw-body
  
 ¹³²
 https://github.com/superjoe30/connect-
 multiparty
  
 ¹³³
 https://github.com/mscdex/connect-busboy
  
 ¹³⁴
 https://github.com/visionmedia/node-
 querystring",NA
