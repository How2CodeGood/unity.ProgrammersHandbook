Larger Text,Smaller Text,Symbol
Lua Programming Gems,NA,NA
Lua Programming Gems,edited by,NA
Luiz Henrique de Figueiredo,NA,NA
Waldemar Celes,NA,NA
Roberto Ierusalimschy,NA,NA
Lua.org,"Rio de Janeiro
  
 2008",NA
Contents,"Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vii
  
 Foreword, by Cameron Laird 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ix
  
 Lua and Lightroom, by Mark Hamburg . . . . . . . . . . . . . . . . . . . . . . 
  
 xi
  
 Contributors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 xiii
  
 I Programming Techniques 
  
 1 
  
 Lua Per-Thread Library Context . . . . . . . . . . . . . . . . . . . . . . 
  
 3
  
 Doug Currie
  
 2
  
 Lua Performance Tips . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 Roberto Ierusalimschy
  
 3
  
 Vardump: The Power of Seeing What’s Behind
  
 . . . . . . . . . . . . .
  
 29
  
 Tobias S¨ulzenbr¨uck and Christoph Beckmann
  
 4
  
 Serialization with Pluto . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 33
  
 Ben Sunshine-Hill
  
 5
  
 Abstractions for LuaSQL . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 43
  
 Tom´as Guisasola Gorham
  
 6
  
 Boostrapping a Forth in 40 Lines of Lua Code . . . . . . . . . . . . . .
  
 57
  
 Eduardo Ochs
  
 7
  
 Effecting Large-Scale Change (with little trauma) using Metatables . .
  
 71
  
 S´ergio Alvares Maffra and Pedro Miller Rabinovitch
  
 II
  
 Design Techniques
  
 . . . . . . . . . . . . . . . . . . .
  
 85
  
 8
  
 MVC Web Development with Kepler
  
 Andr´e Carregal and Yuri Takhteyev
  
 9
  
 Filters, Sources, Sinks, and Pumps . . . . . . . . . . . . . . . . . . . .
  
 97
  
 Diego Nehab
  
 10
  
 Lua as a Protocol Language . . . . . . . . . . . . . . . . . . . . . . . .
  
 109
  
 Patrick Rapin
  
 v",NA
Preface,"It gives us great pleasure to publish this collection of Lua gems. Not only does it 
 record some of the existing wisdom and practice on how to program well in Lua, but 
 it also reflects the maturity of the Lua community. It is gratifying to see that Lua has 
 motivated other people to learn it well and to share their knowledge with other users. 
 In well-written articles that go much beyond the brief informal exchange of tips in the 
 mailing list or the wiki, the authors share their mastery of all aspects of Lua 
 programming, elementary and advanced.
  
 Producing this book has required several steps. In response to a call for con-
 tributions, we received over 70 abstracts, selected 43, and received full versions for 
 28 of these. The authors received our comments and suggestions to prepare the final 
 version of their articles. The whole process took two years, much longer than we had 
 imagined. The selection of abstracts proved to be surprisingly dif-ficult. Many 
 potentially good submissions could not be accepted due to space limitations. Despite 
 the long time it took and the amount of work it required (or because of it!), we are 
 very happy to have this collection of articles on Lua contributed by members of our 
 community. We trust the book was worth waiting for.
  
 We thank all the authors for their hard work on the articles and everyone that 
 submitted abstracts in the first phase. 
  
 We also thank the whole Lua 
 community for its friendliness and expertise. The active participation of our users has 
 been to us a constant source of motivation for improving Lua. Finally, we give our 
 warm thanks to Cameron Laird and Mark Hamburg for writing forewords to this 
 book.
  
 Additional material and errata will appear in the book web site:
  
 http://www.lua.org/gems/
  
 The Lua team 
  
 Rio de Janeiro, November 2008
  
 vii",NA
Foreword,NA,NA
by Cameron Laird,"When I need a programming language that’s as easy as possible to embed, I choose 
 Lua. Lua isn’t just supple, free, portable, and compact, though; it’s also powerful — 
 and to get the most out of it, I’m glad I have
  Lua Programming Gems
 .
  
 I need to explain that I mean something specific by that. Most of my read-ing is on 
 the ’Net: I look up references, I read tutorials for unfamiliar material, I moderate a 
 half-dozen Wikis, and I chat about specific techniques with col-leagues on-line. My 
 consumption of books has nose-dived.
  Lua Programming Gems
  is a book worth 
 reading, though: its individual chapters get across ideas that simply aren’t explained 
 anywhere else.
  
 Lua Programming Gems
  emphasizes practicality in a way I like. While the six 
 authors in Part III certainly employ classroom concepts correctly in their 
 examinations of “Algorithms and Data Structures”, they do it all with working Lua 
 code. The same pattern is apparent throughout
  Lua Programming Gems
 : it’s filled 
 with ideas likely to help me in my next programming project.
  
 You If you’re new to Lua, you might be anxious about what you’ll find.
  
 can see that Lua offers definite advantages, but how hard is it to pick up what’s 
 undeniably a minority language?
  Lua Programming Gems
  will ease your concerns: the 
 authors write clearly, modestly, and even deftly. The very first chapter, for example, 
 tackles difficult material, including dynamically-allocated per-thread storage. The 
 tone is consistent throughout the book. Rather than show off their expertise or 
 indulge in private jokes, habits common for authors from other domains, the
  Lua 
 Programming Gems
  authors focus on the specific details and examples that best teach 
 their chosen topics. They make it inviting to dig deeper in Lua than you might do on 
 your own.
  
 Among the highlights of
  Lua Programming Gems
  for me: Part IV gives insight into 
 “Game Programming”, an area where I’ll probably never work, although many of the 
 techniques apply more broadly; Part V on “Embedding and Extending” is crucial for 
 much of the programming I like; and Chapter 13,“Exceptions in Lua”, is a particular 
 interest of mine.
  
 ix",NA
Lua and Lightroom,NA,NA
Mark Hamburg ,"Founder, Adobe Photoshop 
 Lightroom
  
 When we started work on the project that would become Adobe Photoshop 
 Lightroom, we knew we wanted to make scriptability an important part of our story, 
 so early on we reviewed the usual suspects. What drew us to Lua was its combination 
 of simplicity, power, ease of embedding, and relatively high-performance. Having a 
 straightforward license helped too when it came time to talk to Adobe’s lawyers. 
 Personally, as an old Scheme fan, I was drawn to its first-class closure support. I also 
 found the coroutine system intriguing. The relative minimalism also resonated with a 
 back-to-basics attitude that had us weaning ourselves away from intensive C++ usage 
 and back toward C.
  
 Still, it was hard to position Lua as anything other than an obscure choice. We 
 could cite heavy use in the games community and we had set out with a mission of 
 learning something from game developers, but if asked what mate-rials one could 
 turn to learn Lua or where we would find experienced Lua pro-grammers, the 
 answers were limited. For the former, we had the well-written reference manual, 
 some good material on the Lua users wiki, and an intelligent forum on the Lua 
 mailing list. This was good material, but there wasn’t a lot of it. For the latter 
 question, our answer was essentially “Any programmer worth hiring ought to be able 
 to learn Lua quickly.” This was a situation we were pre-pared to deal with and the 
 arrival of
  Programming in Lua
  certainly helped, but it was easy to understand why it 
 might be off putting to someone looking in from the outside.
  
 Why this matters is that along with Lua’s simplicity come some issues that make 
 people with backgrounds in other languages stumble. The beauty of a small core is 
 that there is a real opportunity for mastery. This is one of C’s great strengths as well. 
 That small core, however, comes at a price. For example, Lua has no syntax for 
 exception handling. C doesn’t either but having one seems
  
 almost required in modern languages.
  
 Lua has a syntax for object-oriented
  
 xi",NA
Contributors,"Following the Brazilian tradition, the contributors are listed in alphabetical order of 
 first name.
  
 Andr´e Carregal
  was introduced to Lua in 1994 during his MSc in Computer 
 Science, which was supervised by Roberto Ierusalimschy. He has been working with 
 web development using Lua since 1996. 
  
 He currently coordinates the 
 Kepler project and the LuaForge site while working as a consultant for Lua-related 
 projects.
  
 Ben Sunshine-Hill
  is a PhD student at the University of Pennsylvania, studying 
 computer graphics. He did his undergraduate studies at the University of Southern 
 California and received an MSc from the University of California, Los Angeles. He has 
 been a game developer at several mobile and mainstream game development studios, 
 and has previously published work on real-time rendering methods.
  
 Diego Nehab
  was introduced to Lua in 1996, while working for Tecgraf in PUC-Rio. 
  
 Over the years, he has been involved in a variety of Lua-related projects, 
 including the IupLua, CDLua, IMLua, and LuaSQL libraries. He is best known as the 
 author of the LuaThreads and LuaSocket libraries. Diego received a BEng in Computer 
 Engineering and an MSc in Programming Lan-guages from PUC-Rio, under the 
 supervision of Roberto Ierusalimschy. He later received an MSc and a PhD in 
 Computer Graphics from Princeton University. His research now focuses on high-
 quality shape acquisition and on real-time rendering techniques.
  
 Doug Currie
  develops award-winning medical devices with Sunrise Labs, Inc. in 
 Auburn, New Hampshire, USA. Over a thirty-year career, Doug has led electronics, 
 mechanical, and software teams developing high-tech products with particular 
 emphasis on reliability and adaptability. Some of these products, based on a 
 massively parallel computing architecture Doug invented, are used in national 
 transportation and world-class manufacturing operations. With a
  
 xiii",NA
Part I ,NA,NA
Programming Techniques,NA,NA
1 ,NA,NA
Lua Per-Thread Library ,NA,NA
Context,NA,NA
Doug Currie,"Libraries written in C for use with Lua sometimes have a context that can be modified 
 by the Lua program. For example, in the decNumber library, the Lua program may 
 select the rounding mode and precision for arithmetic operations. The decNumber 
 library user expects the context to be applied during library operations, and remain 
 fixed until explicitly changed.
  
 There are many other examples of library context. Libraries may need to maintain a 
 per-thread global variable, like the POSIX library’s errno. 
  
 The 
 C standard libraries have a current input file and current output file that are implied 
 for many operations.
  
 It would be wrong for a context setting in one Lua thread to affect the setting in 
 another Lua thread. The other thread would get an unexpected rounding error, or an 
 unexpected errno value, for example. 
  
 Each thread should have its 
 own context so that the library functions it uses operate the same way independent of 
 the activities of other threads.
  
 Lua does not provide a per-thread variables mechanism directly, though there are 
 many ways to create this affect. The solution presented in this gem is to use the 
 mechanism provided by LUA_ENVIRONINDEX. All functions in the library share a 
 common closure. In this closure is a table used to map the thread’s identity, i.e., L to a 
 context. Since only the functions in the library have access to the common closure, 
 there is no chance of interference from other libraries. The mechanism is fast, and can 
 be made even faster with caching.
  
 This gem presents the solution in a straightforward implementation, and adds 
 userdata context functions, caching, and performance measurement in incremental 
 steps.
  
 Copyright c
 ⃝
  2008 by Doug Currie. Used by permission. 
  
 3",NA
Implementation alternatives,"So, how do we implement a per-thread library context?
  
 The Lua 5.1 Reference Manual describes a “thread environment” that is ac-
 cessible using LUA_GLOBALSINDEX. But all threads share the same global table as 
 their thread environment by default. This prevents the thread environment’s",NA
Using,NA,NA
 LUA ENVIRONINDEX,NA,NA
 for library private storage,"Lua 5.1 also provides a little documented mechanism using a pseudo-index called 
 LUA_ENVIRONINDEX. The Lua 5.1 Reference Manual (§3.3) simply says that “the 
 environment 
 of 
 the 
 running 
 C 
 function 
 is 
 always 
 at 
 pseudo-index 
 LUA_ENVIRONINDEX”.
  
 What is the environment of a running C function?
  
 Digging into the Lua 5.1 source code, we find uses of LUA_ENVIRONINDEX in 
 liolib.c and loadlib.c where the function environment mechanism is used create a 
 table shared privately among all the functions of a library. How does this work?
  
 When a C function closure is created with lua_pushcclosure, which is used by 
 luaL_register when registering a library’s C functions for example, the current C 
 function environment is saved in the new C function’s closure as its C environment. 
 The function lua_replace may be used to set the current C function environment to a 
 newly allocated table. This table will then be shared by all subsequently created C 
 function closures.
  
 A function’s environment may also be set using lua_setfenv — but this is not nearly as 
 useful for our purposes! 
  
 It would mean iterating over all the 
 functions in the library after they were created by luaL_register duplicating a lot of 
 effort.
  
 So, for example, registering your library’s functions could be done with:",NA
Using library private storage to implement per-thread,NA,NA
private storage,"Now that we have library private storage, how do we use it to implement per-thread 
 library private storage? The simple answer is to use the current thread as a key for 
 the library private storage table. 
  
 Then each Lua thread in the 
 system will have one value in our library private storage.
  
 Our example accessing the library private storage from functions in 
 lib_luaL_reg_array becomes:
  
 lua_pushthread (L); 
  
 /* key */ 
  
 lua_pushvalue (L, index); 
  
 /* value */ 
  
 lua_rawset (L, LUA_ENVIRONINDEX);
  
 to save the thread’s value, and
  
 lua_pushthread (L); 
  
 /* key */ 
  
 lua_rawget (L, LUA_ENVIRONINDEX);
  
 to retrieve the thread’s value.
  
 If multiple values must be stored for each thread, we can make the thread’s value a 
 table or userdata and store several values in it.
  
 There is one further thing we must do to make this mechanism a good Lua citizen. By 
 using threads as our library private storage table keys, we are preventing Lua from 
 ever garbage collecting the threads that use our library. The solution is making our 
 library private storage table a weak table on its keys. Registering our library’s 
 functions becomes:",NA
Using per-thread private storage for per-thread library,NA,NA
context,"Now that we have per-thread library-private storage we are ready to implement per-
 thread library context. For this implementation we will use userdata for the per-
 thread context. This supports adding as many fields of context for each thread as 
 necessary while having only one value in the thread private storage for each thread.
  
 For Lua decNumber, a wrapper for the IBM decNumber library, the context is 
 simply the decContext structure defined by the underlying decNumber library. The 
 examples in subsequent sections will use Lua decNumber code. To use these 
 techniques in your own code, simply substitute your own context structure for the 
 decContext structure.
  
 The mechanism has just a few pieces:
  
 • The weak key table implementation of per-thread library private storage, 
  
 above;
  
 • Functions to create and type-check a context userdata;
  
 • Functions to get and set the current thread’s context;
  
 • A function to push current thread’s context to return it to Lua code.",NA
Caching per-thread library context,"While the implementation of per-thread library context using library private storage 
 is quite fast, there is room for improvement. We can avoid the table lookup in the 
 library private storage if we cache the last lookup. This will be beneficial in a couple 
 common cases:
  
 • The library is only used from only one thread;
  
 • The library is used several times between thread yields.
  
 First we will develop a caching approach, and then explore its benefits, measuring its 
 performance advantage, and discuss some potential drawbacks.
  
 The caching technique is quite straightforward: we simply record the thread (L) 
 and context on each lookup in the library private storage. Each reference to the 
 thread context first checks if the reference is from the last thread to perform a 
 lookup, and if so returns the cached value avoiding the second and subsequent 
 lookups.
  
 This implementation depends on threads and userdata not being moved by the 
 garbage collector. Fortunately, this is true for present Lua implementations, and 
 those in the foreseeable future since the Lua authors “have no intention of allowing 
 userdata addresses to change during GC” (http://lua-users.org/ lists/lua-l/2006-
 04/msg00384.html).
  
 Lua doesn’t provide a way to push a userdata from the C library; the pointer 
 returned by lua_touserdata or luaL_checkudata is incremented past the Lua userdata 
 header. The userdata header structure is opaque to the C library. Most of the time the 
 library doesn’t care about this; it just wants a pointer to the context and doesn’t need 
 to put it on the Lua stack. In these cases the cache works fine. In other rare cases, the 
 C library must push the context to pass it as an argument to Lua code or return it to 
 the Lua library caller. In these situations the cache is simply bypassed.
  
 Another optimization is that ldn_set_context now takes the decContext as an 
 argument. This avoids having to convert the context value on the stack to a userdata 
 pointer for storage into the cache. The caller generally has this pointer in hand at the 
 time of the call.
  
 Our C code is uses preprocessor macros to enable and disable caching so we can build 
 with either implementation. Here are the updated functions:",NA
Testing and performance measurement,"The Lua decNumber library is delivered with extensive test suite, both the IBM 
 decTest suite as well as Lua implementation specific tests. There are over 30,000 test 
 cases. 
  
 Among these tests are some performance measurements of Lua 
 decNumber with and without caching of the per-thread library context. There are 
 specific tests of correctness of the per-thread context using two Lua threads, and 
 implementation of cache hit and miss counters.
  
 The performance measurement is done with an included Lua library pro-viding 
 access to the Windows high resolution QueryPerformanceCounter API. Please 
 experiment with these tools on your system.
  
 Two test cases were studied to determine if per-thread library context caching is 
 beneficial: a minimal arithmetic loop (one decNumber add and assignment to a local), 
 and a more complex calculation involving decNumber division, remain-der, square 
 root, and exponentiation. Both cases were timed in single threaded mode — this is 
 the best case for caching since all but the first context access will hit.
  
 The testing method was simple: Time N iterations of an empty loop and N 
 iterations of each calculation. Repeat this several times and discard the obvi-ous 
 outliers (best and worst). Subtract the empty loop time from the calculation loop 
 times. Compare the cache and non-cache results:
  
 • For the simple arithmetic loop, caching gave a bit over a 21% reduction in 
 compute time. In other words, the arithmetic loop run with the context-cache-
 enabled library ran in 79% of the time of the no-context-cache li-brary.
  
 • For the complex calculation loop, caching gave a bit over a 0.6% reduction in 
 compute time. Lua table lookup is quite fast compared with this calcu-lation!
  
 So, as you’d expect, the benefits of caching the library context will depend a lot on the 
 time complexity of your library functions.",NA
Conclusion,"Caching the per-thread library context provides a small increase in performance. The 
 caching failure mode identified above is highly unlikely, but catastrophic. The 
 solutions to avoid the failure are either Lua implementation dependent, or put a per-
 thread initialization obligation on library users. Fortunately, the non-cache version of 
 per-thread library context performs quite well. Unless you need the small 
 performance gain, or until Lua implements a gc hook, the cache may be more trouble 
 than it’s worth. If you need the performance, use a solution to avoid the failure that’s 
 best for your application.
  
 Lua’s LUA_ENVIRONINDEX mechanism has several interesting uses. It was a joy to 
 discover, and seems to be just the right approach for per-thread library context. The 
 mechanism is so easy to implement that every library with context should use per-
 thread library context.",NA
2 ,NA,NA
Lua Performance ,NA,NA
Tips,NA,NA
Roberto Ierusalimschy,"In Lua, as in any other programming language, we should always follow the two 
 maxims of program optimization:
  
 Rule #1:
  Don’t do it
 .
  
 Rule #2:
  Don’t do it yet.
  (for experts only)
  
 Those rules are particularly relevant when programming in Lua. Lua is famous for its 
 performance, and it deserves its reputation among scripting languages.
  
 Nevertheless, we all know that performance is a key ingredient of program-ming. 
 It is not by chance that problems with exponential time complexity are called
  
 intractable
 . A too late result is a useless result. So, every good program-mer should 
 always balance the costs from spending resources to optimize a piece of code against 
 the gains of saving resources when running that code.
  
 The first question regarding optimization a good programmer always asks is:“Does 
 the program needs to be optimized?” If the answer is positive (but only then), the 
 second question should be: “Where?”
  
 To answer both questions we need some instrumentation. We should not try to 
 optimize software without proper measurements. The difference between 
 experienced programmers and novices is
  not
  that experienced programmers are 
 better at spotting where a program may be wasting its time: The difference is that 
 experienced programmers know they are not good at that task.
  
 A few years ago, Noemi Rodriguez and I developed a prototype for a CORBA ORB 
 (Object Request Broker) in Lua, which later evolved into OiL (
 Orb in Lua
 ). As a first 
 prototype, the implementation aimed at simplicity. To avoid
  
 Copyright c
 ⃝
  2008 by Roberto Ierusalimschy. Used by permission. 
  
 15",NA
Basic facts,"Before running any code, Lua translates (precompiles) the source into an in-ternal 
 format. This format is a sequence of instructions for a virtual machine, similar to 
 machine code for a real CPU. This internal format is then interpreted by C code that is 
 essentially a
  while
  loop with a large
  switch
  inside, one case for each instruction.
  
 Perhaps you have already read somewhere that, since version 5.0, Lua uses a 
 register-based virtual machine. The “registers” of this virtual machine do not 
 correspond to real registers in the CPU, because this correspondence would be not 
 portable and quite limited in the number of registers available. Instead, Lua uses a 
 stack (implemented as an array plus some indices) to accommodate its registers. 
 Each active function has an
  activation record
 , which is a stack slice wherein the 
 function stores its registers. So, each function has its own registers
 2
 . Each function 
 may use up to 250 registers, because each instruction has only 8 bits to refer to a 
 register.
  
 Given that large number of registers, the Lua precompiler is able to store all local 
 variables in registers. The result is that access to local variables is very fast in Lua. 
 For instance, if a and b are local variables, a Lua statement like a = a + b generates one 
 single instruction: ADD 0 0 1 (assuming that a and b are in registers 0 and 1, 
 respectively). For comparison, if both a and b were globals, the code for that addition 
 would be like this:
  
 GETGLOBAL
  
 0 0
  
 ; a
  
 GETGLOBAL
  
 1 1
  
 ; b
  
 ADD
  
 0 0 1
  
 ; a
  
 SETGLOBAL
  
 0 0
  
 So, it is easy to justify one of the most important rules to improve the perfor-mance of 
 Lua programs:
  use locals!
  
 If you need to squeeze performance out of your program, there are several places 
 where you can use locals besides the obvious ones. For instance, if you call a function 
 within a long loop, you can assign the function to a local variable.
  
 For instance, the code
  
 for i = 1, 1000000 do 
  
 local x = math.sin(i) 
  
 end
  
 runs 30% slower than this one:
  
 local sin = math.sin 
  
 for i = 1, 1000000 do 
  
 local x = sin(i) 
  
 end
  
 2
 This is similar to the
  register windows
  found in some CPUs.",NA
About tables,"Usually, you do not need to know anything about how Lua implement tables to use 
 them. Actually, Lua goes to great lengths to make sure that implementation details do 
 not surface to the user. 
  
 However, these details show themselves 
 through the performance of table operations. So, to optimize programs that use tables 
 (that is, practically any Lua program), it is good to know a little about how Lua 
 implements tables.
  
 The implementation of tables in Lua involves some clever algorithms. Every table 
 in Lua has two parts: the
  array
  part and the
  hash
  part. The array part stores entries 
 with integer keys in the range 1 to n, for some particular n. (We will discuss how this 
 n is computed in a moment.) All other entries (including integer keys outside that 
 range) go to the hash part.
  
 As the name implies, the hash part uses a hash algorithm to store and find its keys. 
 It uses what is called an
  open address
  table, which means that all entries are stored in 
 the hash array itself. A hash function gives the primary index of a key; if there is a 
 collision (that is, if two keys are hashed to the same position), the keys are linked in a 
 list, with each element occupying one array entry.
  
 When Lua needs to insert a new key into a table and the hash array is full, Lua 
 does a
  rehash
 . The first step in the rehash is to decide the sizes of the new array part 
 and the new hash part. So, Lua traverses all entries, counting and classifying them, 
 and then chooses as the size of the array part the largest power of 2 such that more 
 than half the elements of the array part are filled. The hash size is then the smallest 
 power of 2 that can accommodate all the remaining entries (that is, those that did not 
 fit into the array part).
  
 When Lua creates an empty table, both parts have size 0 and, therefore, there are 
 no arrays allocated for them. Let us see what happens when we run the following 
 code:
  
 local a = {} 
  
 for i = 1, 3 do 
  
 a[i] = true 
  
 end
  
 It starts by creating an empty table a. In the first loop iteration, the assignment 
 a[1]=true triggers a rehash; Lua then sets the size of the array part of the table to 1 
 and keeps the hash part empty. In the second loop iteration, the assignment a[2]=true 
 triggers another rehash, so that now the array part of the table has size 2. Finally, the 
 third iteration triggers yet another rehash, growing the size of the array part to 4.",NA
About strings,"As with tables, it is good to know how Lua implements strings to use them more 
 efficiently.
  
 The way Lua implements strings differs in two important ways from what is done 
 in most other scripting languages. First, all strings in Lua are
  internalized
 ; this means 
 that Lua keeps a single copy of any string. Whenever a new string appears, Lua checks 
 whether it already has a copy of that string and, if so, reuses that copy. Internalization 
 makes operations like string comparison and table indexing very fast, but it slows 
 down string creation.
  
 Second, variables in Lua never hold strings, but only references to them. This 
 implementation speeds up several string manipulations. For instance, in Perl, when 
 you write something like $x = $y, where $y contains a string, the assignment copies 
 the string contents from the $y buffer into the $x buffer. If the string is long, this 
 becomes an expensive operation. In Lua, this assignment involves only copying a 
 pointer to the actual string.
  
 This implementation with references, however, slows down a particular form of 
 string concatenation. In Perl, the operations $s = $s . ""x"" and $s .= ""x"" are quite 
 different. In the first one, you get a copy of $s and adds ""x"" to its end. In the second 
 one, the ""x"" is simply appended to the internal buffer kept by the $s variable. So, the 
 second form is independent from the string size (assuming the buffer has space for 
 the extra text). If you have these commands inside loops, their difference is the 
 difference between a linear and a quadratic algorithm. For instance, the next loop 
 takes almost five minutes to read a 5MByte file:
  
 $x = """"; 
  
 while (<>) { 
  
 $x = $x . $_; 
  
 }
  
 If we change $x = $x . $_ to $x .= $_, this time goes down to 0.1 seconds!
  
 Lua does not offer the second, faster option, because its variables do not have 
 buffers associated to them. So, we must use an explicit buffer: a table with the string 
 pieces does the job. The next loop reads that same 5MByte file in 0.28 seconds. Not as 
 fast as Perl, but quite good.",NA
"Reduce, reuse, recycle","When dealing with Lua resources, we should apply the same three R’s promoted for 
 the Earth’s resources.
  
 Reduce is the simplest alternative. There are several ways to avoid the need for 
 new objects. For instance, if your program uses too many tables, you may consider a 
 change in its data representation. As a simple example, consider that your program 
 manipulates polylines. The most natural representation for a polyline in Lua is as a 
 list of points, like this:
  
 polyline = { { x = 10.3, y = 98.5 }, 
  
 { x = 10.3, y = 18.3 }, 
  
 { x = 15.0, y = 98.5 }, 
  
 ...
  
 }
  
 Although natural, this representation is not very economic for large polylines, as it 
 needs a table for each single point. A first alternative is to change the records into 
 arrays, which use less memory:
  
 polyline = { { 10.3, 98.5 }, 
  
 { 10.3, 18.3 }, 
  
 { 15.0, 98.5 }, 
  
 ...
  
 }
  
 For a polyline with one million points, this change reduces the use of memory from 
 95 KBytes to 65 KBytes. Of course, you pay a price in readability: p[i].x is easier to 
 understand than p[i][1].
  
 A yet more economic alternative is to use one list for the x coordinates and another 
 one for the y coordinates:
  
 polyline = { x = { 10.3, 10.3, 15.0, ...}, 
  
  
 y = { 98.5, 18.3, 98.5, ...} 
  
 }
  
 The original p[i].x now is p.x[i]. With this representation, a one-million-point polyline 
 uses only 24 KBytes of memory.
  
 A good place to look for chances of reducing garbage creation is in loops. For 
 instance, if a constant table is created inside a loop, you can move it out the loop, or 
 even out of the function enclosing its creation. Compare:",NA
Final remarks,"As we discussed in the introduction, optimization is a tricky business. There are 
 several points to consider, starting with whether the program needs any optimization 
 at all. If it has real performance problems, then we must focus on where and how to 
 optimize it.",NA
3,NA,NA
Vardump: The Power ,NA,NA
of Seeing What’s ,NA,NA
Behind,NA,NA
Tobias S¨ulzenbr¨uck and Christoph Beckmann,"A universal debugging tool is popular in other programming languages, such as the 
 scripting language PHP. When coming to writing code it seems as an advantage for us 
 to work with a quite usable built-in function called vardump to quickly overview 
 variable contents. There the contents are structured in order by their appearance in 
 arrays or by their data types which makes it easier to read the variables and refer to 
 them.
  
 This means in detail that when programming you may want to supervise 
  
  
 This abstract description of the problem covers nearly all issues your data.
  
 when dealing with complex program structures or when having trouble because 
 some variables or classes get out of hand. For instance, you are implementing a non-
 trivial algorithm and while testing certain functionality you will print out variables to 
 control single values.
  
 But what to do with complex data structures? You will need a tool that is capable of 
 dealing with custom-made structures. For instance, a nested table containing data 
 should be printed out. Instead of reinventing a special output function for your 
 problem, it is likely better to use an generic function that covers all possible data 
 types. This fact becomes more important in dynamically typed languages like Lua. (In 
 the beginning of experiencing Lua we hardly missed such a functionality as described 
 above.) 
  
 In this gem, we introduce a universal debugging tool for Lua. This solution covers 
 many demands that programmers have in their development workflow.
  
 Copyright c
 ⃝
  2008 by Tobias S¨ulzenbr¨uck and Christoph Beckmann. Used by permission. 
  
 29",NA
Implementation,"As shown in Listing 1, vardump is a Lua function with three parameters: one for the 
 resulting data value and two others reserved for the recursive function invocation 
 through itself.
  
 First the
  key
  parameter is checked for adding a line prefix. This is used when 
 printing tables to also print out the index of the table cell. Second, depending on the 
 table depth (i.e., the current iteration step when printing a table), spaces are added in 
 front of each line to enhance the readability. When calling vardump with a simple 
 data type, such as a string, the afore mentioned additions to lines have no influence 
 on those. As said before, this is only interesting when printing out tables, because the 
 Lua print function automatically adds a line break.
  
 Next the value is checked against some basic types. This includes
  tables
 , 
 functions
 ,
  
 threads
 ,
  userdata
 , and all other types the data in vardump can have. When the 
 resulting type is a simple data type, it is displayed with the Lua print function. The 
 data type is printed in brackets in front of the value. Functions, threads, userdata, and 
 nil values are printed without their data types at the beginning of the line. E.g. the 
 vardump of a function will print out its memory address, as the standard print 
 function will do.
  
 Tables are the universal structure in Lua and they need special handling in 
 vardump. As tables may contain other tables it is essential to get all information out 
 of them, no matter how deep the nesting is. The output of vardump for a set of nested 
 tables is shown in Listing 2.
  
 The function begins with obtaining the current iteration depth. From the depth value, 
 the amount of fore-standing spaces in determined. A table can contain other tables or 
 the special
  metatable
 . If so, the current value is replaced by the contents of the 
 metatable. Next, vardump is invoked recursively for each pair in the table. 
  
 The 
 new value and the corresponding key are two of the arguments for the call. The third 
 parameter is the current depth, as mentioned for adding spaces at the beginning of 
 the line.",NA
Conclusion,"The functionality of vardump is powerful and a must for any developer. vardump 
 gives you the transparency you need for every variable you use. One improve-ment 
 for extending vardump to adapt it to your workflow might be another argu-ment that 
 describes the maximum iteration depth for tables — this is very useful when handling 
 large, deeply nested tables.",NA
4 ,NA,NA
Serialization with ,NA,NA
Pluto,NA,NA
Ben Sunshine-Hill,"Serialization refers to the process of taking a piece or set of data from a running 
 program and writing it to a one-dimensional datastream (such as could be stored in a 
 string or a file), with the goal of restoring that data later from the datastream. The 
 most common use of serialization is implementing a “save”feature. 
  
 In this 
 instance, the serialized data is the data in a spreadsheet application, or the state of the 
 gameboard in a chess game. A closely related use is the creation of “rollback points”, 
 useful in simulations and databases, which allows the application to revert to an 
 earlier state. The idea of rollback points is particularly interesting as it relates to 
 coroutines, because the state of the application is contained not only in the data of the 
 program, but in the execution state of all extant coroutines. A similar situation can 
 easily be encountered in a save-game feature in video games, particularly where the 
 state of a character’s AI is embodied in a coroutine.
  
 The plot, therefore, thickens: like many problems in computer science, seri-
 alization starts out sounding trivial, and becomes more complex as the full scope of 
 the problem is examined. An additional level of complexity arises when one begins to 
 consider the practical aspects of serialization as opposed to treating it as an exercise 
 in theory. Indeed, the creation of a serialization system that is both correct and useful 
 is a remarkably involved task. Because of this, premade serialization libraries are a 
 convenient way to reduce development time while ensuring a robust, efficient result. 
 In the ideal case, the complexities of deciding on a file format and keeping the loading 
 and saving code in sync are swept away in favor of a simple “serialize this”. Pluto is 
 one such system, which handles the
  
 Copyright c
 ⃝
  2008 by Ben Sunshine-Hill. Used by permission. 
  
 33",NA
The complexities of serialization,"This section covers some of the theoretical aspects of serialization. If the 
 phrase“depth-first graph traversal” makes your eyes glaze over, you can skip to the 
 next section.
  
 Much of the complexity of serialization arises from the fact that a single piece of 
 “data” is rarely confined to a single object. The string ""foo"" is a single object, as is the 
 string ""bar"", but the table {foo = ""bar""} consists of three objects: the table, the key, 
 and the value. And we must deal with more than simple asso-ciative mappings: the 
 table {{""foo""},{""bar"",""baz"",{""qux"",""quux""}}} consists of four tables and five strings (not 
 counting the implicit integer keys). The real problems, though, begin to arise when 
 the data is structured not as a tree but as a generalized graph. Consider the data 
 returned by the following function:
  
 function creategraph() 
  
 local a = {} 
  
 local b = {} 
  
 a.foo = b 
  
 b.foo = a 
  
 return a 
  
 end
  
 The returned object is a table, which has as its single value a table, which has as its 
 single value the first table. 
  
 This structure cannot be represented 
 declaratively, because of the cyclic links. Likewise, during deserialization the 
 structure cannot be rebuilt without visiting at least one of the tables twice: If the first 
 table is rebuilt first, it cannot refer to a fully rebuilt second table; and vice versa.
  
 The solution employed by most serialization libraries, including Pluto, is to layer a 
 new container over the objects. The data returned by creategraph above could be 
 equivalently generated by the function in Listing 1. The array objs is first filled with 
 every object in the data, each one initially “empty” but referenceable. The objects are 
 then filled, one by one, with the other objects which they reference, and the root 
 objects (the initial set of objects explicitly chosen to be serialized) are returned. It 
 should be clear from the above code that the ordering of the objects in obj can be 
 arbitrary: as long as all objects are created before all objects are filled, the creation 
 and filling of individual objects can be performed in any order.
  
 In practice, these two phases may be interleaved. The algorithm is closely based 
 on a depth-first graph traversal, and is as follows. During serialization, maintain a 
 table of written objects and the integer indices assigned to them. To write an object, 
 check whether that object has already been written. If it has, output the integer index 
 assigned to the object when it was first written.",NA
Using Pluto,"Pluto is implemented as a Lua module in C, which must be built for a particular 
 version of the Lua interpreter (due to its direct manipulation of Lua’s data",NA
Other approaches to general-purpose serialization,"In this section, I will examine two other serialization possiblities available to the Lua 
 programmer, covering both the concepts behind their implementation and the 
 practicalities of choosing each one for a serialization system. Although Pluto is a 
 robust and general-purpose library, these approaches have advantages of their own.",NA
Conclusion,"Serialization is an important task for many applications, and often a compli-cated 
 one, particularly if it is not planned for from the outset. At the same time, it is 
 undeniably prosaic. The implementation of a robust serialization system is a task to 
 be deferred to third-party solutions whenever possible, to allow the programmer to 
 concentrate on application-specific tasks. If you are planning out the technology to be 
 used for an application, or if you need to graft serialization or persistence onto an 
 existing project, Pluto can minimize the pain involved in integrating serialization.",NA
5,NA,NA
Abstractions for LuaSQL,NA,NA
Tom´as Guisasola Gorham,"This article shows how to build an abstraction layer over LuaSQL to ease the most 
 common uses of the library made by application developers. 
  
 The 
 reader is expected to know Lua and the basics of LuaSQL: how to install, open a 
 connection, and execute SQL statements. We will show some common uses of 
 LuaSQL’s API, extracted from our own experience, and try to develop, step by step, a 
 set of abstractions to simplify them, aiming at a higher level programming style.
  
 We will begin by showing an example from which we point out common pieces of 
 code that are found in many programs. The following four sections will de-tail those 
 constructions, showing some forms of generalization and abstraction that should help 
 make the whole program easier to write, maintain and under-stand. Finally, a 
 complete abstraction is obtained in the form of a library that encapsulates the main of 
 LuaSQL.",NA
Common uses,"Listing 1 shows an example of a common use of LuaSQL library, which includes 
 almost all the points we plan to examine. These points are marked with num-bers 
 between parentheses.
  
 The example starts by loading a LuaSQL driver and opening the connection. This 
 initialization phase is marked by number (1). Then the example builds an SQL 
 statement (2), sends it to the database and checks for errors (3), and finally
  
 Copyright c
 ⃝
  2008 by Tom´as Guisasola Gorham. Used by permission. 
  
 43",NA
Defining a module,"As mentioned above, we will develop a Lua module to group all the abstractions 
 together. We shall use a table to encapsulate the actual LuaSQL connection and add 
 functions/methods to its metatable. The programmer can access the actual LuaSQL 
 object to perform other operations such as turn the auto-commit mode on or off, or 
 call the commit and the rollback methods. Let us start with a constructor of this new 
 type of object, which will be also responsible for opening the connection to the 
 database, and a closing function. This will constitute the file database.lua.
  
 local assert, require, setmetatable = assert, require, setmetatable 
 module""database"" 
  
 local mt = { __index = _M, } -- _M is the module itself 
  
 function connect (dbname, user, pass, driver) 
  
  
 local luasql = require(""luasql.""..driver) 
  
  
 local env = assert (luasql[driver] ()) 
  
  
 local obj = { conn = assert (env:connect (dbname, user, pass)) } 
  
 setmetatable (obj, mt) 
  
  
 return obj 
  
 end
  
 function close (obj) 
  
  
 setmetatable (obj, nil) 
  
  
 return obj.conn:close () 
  
 end
  
 We will also write a test file. It will be useful for testing, but also as a set of use 
 samples.
  
 local database = require""database"" 
  
 local db = database.connect (""lpg"", nil, nil, ""postgres"")
  
 From now on, we will develop the following two files in parallel: the module file 
 (database.lua) and the test file. 
  
 Sometimes we will enhance a piece of code 
 that had been developed earlier and thus it will be replaced by the new 
 implementation.
  
 1
 The code that retrieves the results set can be more compact like this: 
  
  
 for id, name in cur.fetch, cur do print (id, name) end 
  
 I chose the more verbose version mainly because I could not found any use of this compact form in a search 
 in the Internet, at least by the time of this writing. Anyway, my point is that legibility could be improved in 
 both forms.",NA
Error handling,"LuaSQL handles errors just like the standard Lua libraries: an error is raised only if 
 the arguments do not follow the types defined by the API. Errors gener-ated by the 
 database client, such as incorrect SQL syntax, unknown identifiers, or even violation 
 of database restrictions, are informed in the conventional way, by returning false and 
 an error message. This behavior provides the program-mer with the freedom to 
 check for errors
  only when they show up
 . Although it is tedious to write down an if-
 test everywhere, the fact is that they are not usually written anywhere! However, a 
 simple function can do this for us. Let us add the following definition to our module:
  
 function assertexec (self, stmt) 
  
  
 local cur, msg = self.conn:execute (stmt) 
  
  
 return cur or error ((msg or ’’).."" SQL = { ""..stmt.."" }"", 2) end
  
 To test it, let us create a test database and insert some rows into it, not forgetting to 
 check if it raises errors properly:
  
 assert (pcall (db.assertexec, db, ""wrong SQL statement"") == false) 
 db:assertexec[[create table people ( 
  
 id 
  
 integer, 
  
 name 
  
 varchar (100), 
  
 sex 
  
 char(1), 
  
 tel 
  
 varchar (10) 
  
 )]]
  
 -- Adding content to the table 
  
 db:assertexec""insert into people values (1, ’John Doe’, ’M’, ’12’)"" 
 db:assertexec""insert into people values (2, ’Jane Doe’, ’F’, ’01’)"" db:assertexec""insert 
 into people values (3, ’O\\’Neill’, ’M’, ’98’)""
  
 Now we can try a query and make sure it executes correctly:
  
 local stmt = ""select * from people where name = ’John Doe’"" assert (pcall 
 (db.assertexec, db, stmt))
  
 Since it is a frequent mistake to forget the quotes around a string, we should add a 
 test to make sure the system always raises an error in this situation:
  
 local stmt = ""select * from people where name = John Doe"" assert (not 
 pcall (db.assertexec, db, stmt))",NA
Result set iterator,"Now we will try to generalize the iteration loop, by adding an iterator factory to our 
 module:",NA
SQL statement constructors,"Our final subject is the creation of SQL statements. This task is completely dif-ferent 
 from everything done to our module so far. One might prefer to develop",NA
Extensions,"Here we explore the facility to extend this library by showing a pair of examples and 
 proposing others. LuaSQL is not supposed to be extended directly and for security 
 reasons it has to be that way. On the other hand, our library is easily extendable, such 
 as most Lua libraries.
  
 Complete result set
  
 The easiest way to extend our library is by adding a function to it. A useful function is 
 one that builds the entire result set as an array of rows. It could be simple as:
  
 function selectall (self, columns, tabname, cond, other, modestring) 
  
 modestring = 
 modestring or ’a’
  
  
 local r = {} 
  
  
 for row in self:select (columns, tabname, cond, other, modestring) do 
  
 r[#r+1] 
 = row 
  
  
 end 
  
  
 return r 
  
 end",NA
Discussion,"Our implementation is now complete, although it can receive some additions. The test 
 case should be much better developed but as the goal here was to show how to do it, I 
 left this task to be done as an exercise.
  
 I think the main functions should check their arguments’ types whenever possible, 
 using features such as the luaL check* set of functions in the Lua auxiliary library. 
 However, these C functions are not exported to Lua and implementing them in Lua 
 can cause a significant performance penalty. In fact, this could be the subject for 
 another gem.
  
 A last but not less important point regards my decisions on the API style and its 
 organization. I chose the arguments of the SQL constructors guided by our own usage 
 and, I have to confess, changed them a little while writing this document. Take the 
 result set iterator, for instance: it could receive five lengthy arguments which can 
 make the call difficult to understand. To reduce this problem, the function could have 
 been implemented to receive a table with the arguments in particular fields, as the 
 following example:
  
 db:select{ 
  
  
 columns = ""col1, col2, col3, col4"", 
  
  
 from = ""tablename t inner join othertable o"", 
  
 having = ""t.fk = o.id and t.col3 > 10"", 
  
  
 groupby = ""..."", 
  
 }
  
 The drawbacks of this approach are the growth of the library size and the 
 possibility of having to deal with differences between the accepted SQL syntax of the 
 databases or even limit the use of particular extensions.
  
 The functions I grouped as “infrastructure” (escape, quote, twolists and pairslist) 
 could be generalized and stored in pre-existing packages, such as",NA
Conclusion,"To illustrate the point we have made, let us rewrite the first example in the article 
 using the tools developed:
  
 -- Initialization (1) 
  
 local database = require""database"" 
  
 local db = database.connect(""lpg"", ""tomas"", nil, ""postgres"")
  
 -- Building SQL statement (2) 
  
 local _, course_list = db.twolists{ ""Music"", ""Literature"", } local year = 2007 
  
 local cond = string.format([[c.name in (%s) and adm_year = %s]], 
  
 course_list, year) 
  
 local tab = ""alumn a inner join course c on (a.course_id = c.id)""
  
 -- SQL execution and error handling (3) and Iteration loop (4) for id, name in 
 db:select(""a.id, a.name"", tab, cond) do 
  
  
 print(id, name) 
  
 end
  
 There is a huge difference from the previous version to this one. The former 
 explicitly checked for errors, while in the new one, this is performed automati-cally 
 by the library functions. The iteration loop is now a concise for-construct without 
 repeated calls to the fetch method. In addition, the SQL statement construction is now 
 much better supported, which helps build correct and more legible code in a 
 convenient way.
  
 Finally, this library settles a new ground over which other abstractions could be 
 defined. Some applications are already constructed on top of it and so are other 
 libraries. An example is a module that provides facilities to the definition of classes 
 and objects directly associated with database tables and rows. It takes advantage of 
 the homogeneity of the API (insert and update methods) and also of the SQL 
 statements creation (table of fields becomes a where clause).",NA
6,NA,NA
Boostrapping a Forth ,NA,NA
in 40 Lines of Lua ,NA,NA
Code,NA,NA
Eduardo Ochs,"The core of a conventional Forth system is composed of two main programs: an outer 
 interpreter, which interprets textual scripts, and an inner interpreter, which runs 
 bytecodes. The outer interpreter switches between an “immediate mode”, where 
 words as executed as soon as they are read, and a “compile mode”, where the words 
 being read are assembled into bytecodes to define new words.
  
 In Forth all variables are accessible from all parts of the system. Several important 
 words use that to affect the parsing: they read parts of the input text themselves, 
 process that somehow, and advance the input pointer — and with that they 
 effectively implement other languages, with arbitrary syntax, on top of the basic 
 language of the outer interpreter.
  
 Due mostly to cultural reasons, Forths tend to be built starting from very low-
 level pieces: first the inner interpreter, in Assembly or C, then the basic libraries and 
 the outer interpreter, in Forth bytecodes or (rarely) in C. We take another approach. 
 If we consider that Lua is more accessible to us than C or Assembly —and thus for us 
 Lua is “more basic” — then it is more natural to start from the outer interpreter, and 
 the dictionary only has to have the definition for one word, one that means “interpret 
 everything that follows, up to a given delimiter, as Lua code, and execute that”. An 
 outer interpreter like that fits in less than 40 lines of Lua code, and it can be used to 
 bootstrap a whole Forth-like language.
  
 Copyright c
 ⃝
  2008 by Eduardo Ochs. Used by permission. 
  
 57",NA
Introduction,"The real point of this article is to propose a certain way of implementing a Forth 
 virtual machine; let’s call this new way “mode-based”. The main loop of a mode-based 
 Forth is just this:
  
 while mode ~= ""stop"" do modes[mode]() end
  
 In our mode-based Forth, which is implemented in Lua and that we will refer to as 
 “miniforth”, new modes can be added dynamically very easily. We will start with a 
 virtual machine that “knows” only one mode — “interpret”, which corresponds to less 
 than half of the “outer interpreter” of traditional Forths —and with a dictionary that 
 initially contains just one word, which means “read the rest of the line and interpret 
 that as Lua code”. 
  
 That minimal virtual 
 machine fits in 40 lines of Lua, and is enough to bootstrap the whole system.
  
 But, “Why Forth?”, the reader will ask. “Forth is old and weird, why shouldn’t we 
 stick to modern civilized languages, and ignore Forth? What do you still like in 
 Forth?”. My feeling here is that Forth is one of the two quintessential extensible 
 languages, the other one being Lisp. Lisp is very easy to extend and to modify, but 
 only within certain limits: its syntax, given by ‘read’, is hard to change(1). If we want 
 to implement a little language (as in [1]) with a free-from syntax on top of Lisp, and 
 we know Forth, we might wonder that perhaps the right tool for that would have to 
 have characteristics from both Lisp and Forth. And this is where Lua comes in — as a 
 base language for building extensible languages.
  
 Disclaimer: I’m using the term “Forth” in a loose sense throughout this article. I will say 
 more about this in the last section.",NA
Forth via examples,"Any “normal” Forth has an interactive interface where the user types a line, then hits 
 the “return” key, and then the Forth executes that line, word by word, and displays 
 some output; our miniforth does not have an interactive interface, but most ideas still 
 carry on. Here’s a very simple program; the text on the left of‘-->’ is the user input, the 
 text on the right is the output from the Forth system. Note that “words” are sequences 
 on non-whitespace characters, delimited by whitespace.
  
 5 DUP * .
  
 -->
  
 25 ok
  
 This program can be “read aloud” as this: “Put 5 on the stack; run ‘DUP’, i.e., duplicate 
 the element on the top of the stack; multiply the two elements on the top of the stack, 
 replacing them by their product; print the element at the top of the stack and remove 
 it from the stack.”
  
 Here’s a program that defines two new functions (“words”, in the Forth jargon):",NA
Bootstrapping miniforth,"The program in Listing 1 is all that we need to bootstrap miniforth. It defines the 
 main loop (run), one mode (interpret), the dictionary (_F), and one word in the 
 dictionary: %L, meaning “evaluate the rest of the current line as Lua code”.
  
 The program below is a first program in miniforth. It starts with only ""%L"" 
 defined and it defines several new words: what to do on end-of-line, on end-of-text, 
 and ""[L"", which evaluates blocks of Lua code that may span more than one line; then 
 it creates a data stack DS and defines the words ""DUP"", ""*"", ""5"", and ""."", which operate 
 on it.
  
 subj = [=[ 
  
 %L _F[""\n""] = function () end 
  
 %L _F[""""] 
  
 = function () mode = ""stop"" end 
  
 %L _F[""[L""] = function () eval(parsebypattern(""^(.-)%sL]()"")) end [L 
  
 DS = { n = 0 } 
  
 push = function (stack, x) 
  
   
  
  
 stack.n = stack.n + 1; stack[stack.n] = x end pop 
  
 = 
 function (stack) 
  
   
  
  
 local x = stack[stack.n]; stack[stack.n] = nil; 
  
  
   
 stack.n = stack.n - 1; return x end 
  
 _F[""5""] 
  
 = function () push(DS, 5) end 
  
 _F[""DUP""] = function () push(DS, DS[DS.n]) end 
  
 _F[""*""] 
  
 = function () push(DS, pop(DS) * pop(DS)) end 
  
 _F["".""] 
  
 = function () io.write("" ""..pop(DS)) end 
  
 L] 
  
 ]=]
  
 -- Now run it. There’s no visible output.
  
 pos = 1 
  
 mode = ""interpret"" 
  
 run()
  
 -- At this point the dictionary (_F) has eight words.
  
 After running this program the system is already powerful enough to run simple 
 Forth programs like, for example,
  
 5 DUP * .
  
 Note that to “run” this Forth program what we need to do is:
  
 subj = ""5 DUP * .""; pos = 1; mode = ""interpret""; run()
  
 It is as if we were setting the memory (here the subj) and the registers of a primitive 
 machine by hand, and then pressing its “run” button. Clearly, that interface could be 
 made better, but here we have other priorities.",NA
Modes,"When the inner interpret runs — i.e., when the mode is “head” or “forth”; see Figure 5 
 — , at each step the processor reads the contents of the memory at IP and processes 
 it. When the outer interpreter runs, at each step it reads a word from subj starting at 
 pos, and processes it. There’s a parallel between these behaviors. . .
  
 I have never seen any references to “modes” in the literature about Forth. In the 
 usual descriptions of inner interpreters for Forth, the “head” mode is not something 
 separate; it is just a transitory state that is part of the semantics of executing a Forth 
 word. Also, the “interpret” and “compile” modes do not exist: the outer interpreter is 
 implemented as a Forth word containing a loop; it reads one word at a time, and 
 depending on the value of a state variable, it either“interprets” or “compiles” that 
 word. So, in a sense, “interpret” and “compile”are “virtual modes”. . .
  
 Let me explain how I arrived at this idea of “modes” — and what I was trying to do 
 that led me there.
  
 Some words interfere with the variables of the outer interpreter. For ex-ample, "":"" 
 reads the word the pos is pointing at (for example, SQUARE), adds a definition for 
 that word (SQUARE) to the dictionary, and advances pos. When the control returns to 
 modes.interpret(), the variable pos is pointing to the posi-tion after SQUARE — 
 modes.interpret() never tries to process the word SQUARE. Obviously, this can be 
 used to implement new languages, with arbitrary syntax, on top of Forth.
  
 Some words interfere with the variables of the inner interpreter — they mod-ify 
 the return stack. Let’s use a more colorful terminology: we will speak of words that 
 “eat text” and of words that “eat bytecode”. As we have seen, "":"" is a word that eats 
 text; numerical literals are implemented in Forth code using a word, LIT, that eats 
 bytecode. In the program below,
  
 : DOZENS 12 * ;
  
 -->
  
 ok
  
 5 DOZENS . 60
  
 -->
  
 ok
  
 the word DOZENS is represented in bytecode in miniforth as:
  
 memory = {""DOCOL"", ""LIT"", 12, ""*"", ""EXIT""}
  
 -- 1
  
 2
  
 3
  
 4
  
 5
  
 -- DOZENS",NA
Virtual modes,"How can we create words that eat bytecode, like LIT, in Forth? In the program below, 
 the word TESTLITS call first LIT, then VLIT; VLIT should behave similarly to LIT, but 
 LIT is a primitive and VLIT is not.
  
 memory = {""DOCOL"", ""R>P"", ""PCELL"", ""P>R"", ""EXIT"",
  
 --
  
 1
  
 2
  
 3
  
 4
  
 5
  
 --
  
 VLIT <---------------+
  
 --
  
 |
  
 ""DOCOL"", ""LIT"", 123, 1, 234, ""EXIT"",}
  
 --
  
 6
  
 7
  
 8
  
 9
  
 10
  
 11
  
 --
  
 TESTLITS",NA
A bytecode for polynomials,"A polynomial with fixed numerical coefficients can be represented in memory as first 
 the number of these coefficients, then the value of each of them; for example, P(x) = 
 2x
 3
 + 3x
 2
 + 4x + 5.5 is represented as {..., 
  
 4, 2, 3, 4, 5.5, ...}. We will 
 call this representation — number of coefficients, then coefficients — the“data of the 
 polynomial”. Let’s start with a primitive, PPOLY, that works like",NA
A bytecode language for propositional calculus,"Here is another example. Let’s write ‘=>’ for “implies”, and ‘&’ for “and”. Then 
 (Q=>R)=>((P&Q)=>(P&R)) is a “formula”, or a “proposition”, in Propositional Cal-
 culus; incidentally, it is a tautology, i.e., always true.
  
 In some situations, for example, if we want to find a proof for that proposition, or 
 if we want to evaluate its truth value for some assignment of truth values to P, Q, and 
 R, we need to refer to subformulas of that formula. If we represent the formula in 
 bytecode using Polish Notation (not Reverse Polish Notation! Can you see why?) then 
 this becomes trivial:
  
 memory = { ""=>"", ""=>"", ""Q"", ""R"", ""=>"", ""&"", ""P"", ""Q"", ""&"", ""P"", ""R"" }
  
 --
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 8
  
 9
  
 10
  
 11
  
 Subformulas can now be referred to by numbers: the position in the memory 
 where they start. We can write a word to parse a proposition starting at some 
 position in the memory; if that position contains a binary connective like ‘=>’ or‘&’, 
 then that word calls itself twice to parse the subformulas at the “left” and at the 
 “right” of the connective. If the word memoizes the resulting structure by storing it in 
 a table named formulas, then re-parsing the formula that starts at the position, say, 6, 
 becomes very quick: the result is formulas[6], and the pointer should be advanced to 
 formulas[6].next. Here are the contents of that table after parsing the formula that 
 starts at memory[1].
  
 1: { addr=1, cc=""=>"", l=2, 
  
 r=5, 
  
 next=12, name=""((Q=>R)=>((P&Q)=>(P&R)))"" } 2: { 
 addr=2, cc=""=>"", l=3, 
  
 r=4, 
  
 next=5, 
  
 name=""(Q=>R)"" } 
  
 3: { addr=3, 
  
   
  
 next=4, 
  
 name=""Q"" } 4: { addr=4, 
   
  
 next=5, 
  
 name=""R"" } 
  
 5: { addr=5, cc=""=>"", l=6, 
  
 r=9, 
  
 next=12, name=""((P&Q)=>(P&R))"" } 
  
 6: { addr=6, cc=""&"", 
  
 l=7, 
  
 r=8, 
  
 next=9, 
  
 name=""(P&Q)"" } 
  
 7: { addr=7, 
  
  
  
 next=8, 
  
 name=""P"" } 
  
 8: { addr=8, 
  
  
  
 next=9, 
  
 name=""Q"" } 
  
 9: { addr=9, cc=""&"", 
  
 l=10, r=11, next=12, name=""(P&R)"" } 
  
 10: { addr=10, 
  
  
  
 next=11, name=""P"" } 
  
 11: { addr=11, 
  
  
  
 next=12, name=""R"" }",NA
(Meta)Lua on miniforth,"The parser for the language for Propositional Calculus in the last section had to be 
 recursive, but it didn’t need backtracking to work. Here is a language that is evidently 
 useful — even if at this context it looks like an academic exercise —and whose parser 
 needs a bit of backtracking, or at least lookahead. Consider the following program in 
 Lua:
  
 foo = function () 
  
  
 local storage 
  
  
 return function () return storage end, 
  
   
 function (x) 
  
 storage = x end 
  
 end",NA
Why Forth?,"Caveat lector: there is no single definition for what “Forth” is. . . Around 1994 the 
 community had a big split, with some people working to create an ANSI Standard for 
 Forth, and the creator of the language and some other people going in another 
 direction, and not only creating new Forths that went against ideas of the Standard, 
 but also stating that ANS Forth “was not Forth”. I can only write this section clearly 
 and make it brief if I choose a very biased terminology; also, I’m not going to be 
 historically precise, either — I will simplify and distort the story a bit to get my points 
 across. You have been warned!
  
 Forth was very popular in certain circles at a time when computers were much less 
 powerful than those of today. Some of the reasons for that popularity were easy to 
 quantify: compactness of programs, speed, proximity to machine code, simplicity of 
 the core of the language, i.e., of the inner and the outer interpreters. 
  
 None of 
 these things matter so much anymore: computers got bigger and faster, their 
 assembly languages became much more complex, and we’ve learned to take for 
 granted several concepts and facilities — malloc and free, high-level data structures, 
 BNF — and now we feel that it is “simpler” to send characters through stdout than 
 poking bytes at the video memory. Our notion of simplicity has changed.
  
 In the mid-90s came the ANS-Forth Standard, and with it a way to write Forth 
 source that would run without changes in Forths with different memory models, on 
 different CPU architectures. At about the same time the creator of the language, 
 Chuck Moore, started to distance himself from the rest of the community, to work on 
 Forths that were more and more minimalistic, and on specialized processors that ran 
 Forth natively.",NA
Conclusion,"After a draft of this article had been written, Marc Simpson engaged in a long series of 
 discussions with me about Forths, Lisp, SmallTalk, several approaches to minimality, 
 etc., and at one point, over the course of one hectic weekend in December, 2007, he 
 implemented a usable (rather than just experimental) dialect of Forth — based 
 mainly on Frank Sergeant’s Pygmy Forth and Chuck Moore’s cmForth, and borrowing 
 some ideas from this article — on top of Ruby (“RubyForth”), and later ported his 
 system to Python and C. A port of it to Lua is underway.
  
 I thank Marc Simpson and Yuri Takhteyev for helpful discussions.",NA
References,"[1] Jon Bentley:
  More Programming Pearls
 , Addison-Wesley, 1990 (chapter 9: 
  
 Little Languages
 ).
  
 [2] James T. Callahan: HS-Forth (program and manual). Harvard Softworks, 
  
 1986–1993.
  
 [3] Anton Ertl: 
  
 Threaded Code. http://www.complang.tuwien.ac.at/forth/ 
  
 threaded-code.html
  
 [4] Brad Rodriguez: A BNF Parser in Forth. http://www.zetetics.com/bj/ 
  
 papers/bnfparse.htm
  
 [5] Fabien Fleutot: MetaLua. http://metalua.luaforge.net/
  
 [6] Kein-Hong Man: 
  
 A No-Frills Introduction to Lua 5.1 VM Instructions. 
  
 http://luaforge.net/docman/view.php/83/98",NA
7,NA,NA
Effecting Large-Scale Change,NA,NA
(with little ,NA,NA
trauma) ,NA,NA
using ,NA,NA
Metatables,NA,NA
S´ergio Alvares Maffra & Pedro Miller Rabinovitch,NA,NA
Introduction,"In real-world conditions, software maintenance becomes as important as soft-ware 
 development. Environments change, business partners choose different strategies, 
 technology evolves — and devolves. Distributed systems become cen-tralized, and 
 centralized ones get scattered around. In particular, requirements have a peculiar 
 way of being significantly altered once a project approaches com-pletion. . . or the day 
 after it has been deployed.
  
 It becomes more and more important to be able to quickly adapt to these 
 changing conditions. In the following sections we’ll discuss the application of a 
 particularly powerful feature of Lua to this end. We’ll start by presenting a short 
 review of metamethods along with a couple of simple examples. We will then show 
 how Lua’s metatables were used to dramatically change the performance profile of an 
 application with little effort. Finally, we conclude showing a few examples where 
 metatables can help developers change the key features of a system even if it’s 
 already in a late development phase or even in production.",NA
Metamethods and environments,"Metatables offer an unique way to intercept and change language events in specific 
 objects. By specifying code to be executed when simple operations are attempted on 
 specific objects, developers can provide a scripting environment where values behave 
 the way they’re expected to, which is particularly useful where non-programmers are 
 concerned (e.g., AI scripting or other problem do-main specific scripting). However, 
 much more interesting applications are avail-able. The index and newindex 
 metamethods, in particular, are specially useful since they allow one to check for 
 variable resolution and provide missing values on the fly in a just-in-time fashion. 
 This, of course, is perfect for default values and inheritance (as described in detail in
  
 Programming in Lua
 ) and lazy evalu-ation procedures, where values are computed as 
 required, but always accessed in a transparent and consistent manner.
  
 The index metamethod is called every time a table is indexed and there’s no 
 appropriate value set for the relevant key. Listing 1 shows an example of index being 
 used to calculate values on the fly as the cache (or look-up) table is indexed. The first 
 time the user attempts to index the table where there’s no value set, the metamethod 
 is called. After the computing is done, the metamethod sets the value at the table, 
 memoizing it for the next time it’s needed. When the same key of the table is indexed 
 again further down the line, the value is already there, and the method is not called.
  
 The newindex metamethod works in an analogue fashion — it is called every time 
 the table has a new value being set. This means that we can watch a table for change 
 and record every time one of its values is updated by an operation, as long as we keep 
 the relevant fields of the table empty (typically by using a proxy table).
  
 The mechanisms above become even more useful because of Lua’s environ-ment 
 functions, getfenv and setfenv. These functions allow us to change the global 
 environment of any given executing routine. The call getfenv(0), in par-ticular, 
 returns a reference to the table that contains all global variables in our program at 
 the current context, and which will be inherited when we require other modules. 
 Since it’s a table, we can set metamethods on it, and watch as global variables are 
 accessed and updated should we so desire.",NA
Our sample problem,"Consider an application heavily based in Lua. As development progresses, the 
 number of Lua files in the project increases, and the dependency graph grows more 
 and more complex at each iteration. At a certain point, the application starts taking a 
 long time to compile at run time, since all the modules are loaded right at the 
 beginning of the execution in a long series of requires or dofiles. This series of module 
 loading instructions also presume a certain order, since dependency issues must not 
 be ignored. At first, this is taken in stride — the target equipment that will run the 
 application is well-known and established as",NA
Resolution through “Origins”,"The new release of the GUI library used in our application was expected with great 
 anxiety at the time. We had been eagerly waiting for it for about a year. We couldn’t 
 wait to use the new features (and get rid of the old bugs!). Unfortu-nately, what 
 should have been a joyful occasion, became a great disappointment. Moreover, we 
 had a big problem in our hands. Sooner or later, we would have to upgrade to the 
 latest release, since there was no support for the old ones.
  
 A deeper investigation showed us that the GUI library was taking a lot longer to 
 create dialogs due to the new widget placement algorithm. In our application all 
 dialogs were created at startup, what explained the humongous loading time we were 
 experiencing. 
  
 Fortunately, the solution was, actually, quite simple: the 
 dialogs should be individually created when needed and not all at once at startup. 
 Given that our application is composed of quite a few hundred source files, this 
 solution fits well in the “easier said than done” category. At first glance,
  
 1
 Actually, you can solve a couple of your problems. The memory and processing issue will be solved, but 
 the perverse naming conventions are more into the realm of physical punishment.",NA
Limitations,"The library uses variable and function names as keys; therefore, conditional file 
 loading might cause problems if they define functions by the same name. Consider the 
 code in Listing 9. The execution path taken during setup time would be the one 
 “Origins” considers as the source of out write.
  
 There is a way to pause processing, however (the stopWatching method). This 
 enables developers to circumvent said limitation. The use of a quick setup script as 
 described previously would also resolve the situation by not including either module 
 and only loading them at the original point in run time, as intended by the code.
  
 Even if conditional loading is not an issue, what should happen if a global
  
 variable is set in more than one module?
  
 Such a naming conflict does not",NA
Further development,"The system introduced here could be the basis for further development. Con-sider a 
 scheme where standard Lua libraries installed at predetermined path locations were 
 loaded at run time as code in execution needed them, without preloading them 
 through require. We could delay library module loading un-til code is necessary by 
 implementing “Origins” on a system-wide range. One could get rid of requires by 
 stipulating that all libraries should be installed through a program responsible for 
 managing a library function catalog, much in the manner of a package manager. After 
 that, any running applications that tried to execute cataloged functions would have 
 the appropriate module loaded and ready at the first call attempt. Module 
 dependencies, of course, would be handled automatically.
  
 Some work would have to be done to keep different versions working correctly 
 together when required. Packaging schemes with property files that describe 
 required module versions come to mind. 
  
 But scripting, in particular, would 
 greatly benefit from such a scheme — specially if an automated download and 
 installation procedure was available at run time.",NA
Other uses for metatables,"Metatables can be used in many ways to significantly change system behavior with 
 little source code alteration. We present some examples below.
  
 Mutexes for concurrent access.
  If we change an application from a single-threaded 
 approach to a multi-threaded one, access to shared values becomes an is-sue. 
 Fields in a table (or even global variables) could be watched by a basic",NA
Conclusion,"We have presented in this gem a simple use of what we consider as one of the most 
 versatile and powerful features of Lua. 
  
 It is easy to see how a simple 
 change implemented this way could alter the execution of a large system as a whole, 
 making a significant and perceptible difference on application perfor-mance and 
 usage. In our case it represented the difference between a bit of de-velopment work 
 and rewriting the entire GUI system in order to spare process-ing and memory. By 
 implementing the dynamic loading mechanism presented here we prevented much 
 unnecessary expenditures with little development cost. The most important lesson to 
 keep, however, is that metatables offer a way to effect system-wide change with little 
 use of search-and-replacing and other po-tentially traumatic methods.",NA
Part II ,NA,NA
Design Techniques,NA,NA
8,NA,NA
MVC Web ,NA,NA
Developme,NA,NA
nt with ,NA,NA
Kepler,NA,NA
Andr´e Carregal and Yuri Takhteyev,"Kepler is a Lua-based web development platform that is modular and flexible. Kepler 
 1.1 adds support for the developing web applications using the increas-ingly more 
 popular Model-View-Controller (MVC) style. This article discusses several 
 approaches to MVC web development and shows how they can be imple-mented in 
 Kepler.",NA
Introduction,"Kepler
 1
 is an open source web development platform based on Lua that brings many 
 of Lua’s advantages to the development of web applications.
 2
 Like Lua, Kepler is small, 
 portable, and flexible. Kepler 1.1 provides support for web ap-plication development 
 that follows the Model-View-Controller (MVC) paradigm, bringing to Lua some of the 
 benefits provided by popular web frameworks writ-ten for other programming 
 languages.
  
 MVC refers to the division of application code into three sections and was 
 originally brought to desktop GUI programming by Smalltalk. When applied to
  
 1
 http://www.keplerproject.org/ 
  
 2
 Since this article addresses readers already familiar with Lua, we do not discuss here the exact advantages 
 that Lua offers in general or specifically for web development. Such advantages are discussed, however, on 
 the Kepler site.",NA
Request dispatching,"Overview
  
 The general problem of HTTP request dispatching is to map an incoming request to 
 an action within the system. The action must at the minimum generate a response 
 that will be sent to the client, but may also have side effects, such as altering the data 
 stored in the model. Here is a general model of the way the MVC controller handles an 
 HTTP request:
  
  
 For the purpose of this article we will consider a simplified version of this model, 
 which assumes that the controller relies only on the URL and uses neither other parts 
 of the request nor the internal state: We do not discuss the use of HTTP headers and 
 POST parameters, though those parts of the request are already provided by Kepler 
 in an simple way and their use presents no",NA
Content generation,"Overview
  
 After dispatching, the controller must generate the necessary parts of an HTTP 
 response: the HTTP status, the HTTP headers, and the content part. 
  
 This 
 section focuses on the approaches to generating content. One approach is to generate 
 the content programmatically, pushing one string after another into a buffer. Another 
 approach is to define template strings that are filled with content when they are 
 processed. We call the first method “scripting” and the second method “templating”.",NA
Conclusion,"Kepler allows for MVC-style web development using many of the currently popular 
 approaches. 
  
  
 Instead of locking the user into a specific solutions to such 
 problems as request dispatching and content generation, Kepler focuses on making 
 web applications portable across operating systems and servers, letting the 
 application developers choose higher-level solutions appropriate to their specific 
 case. 
  
 Your choice between the above mentioned approaches to 
 request dispatching may depend on how “clean” you want your URLs to be, how much 
 control you need over them, and whether the system needs to support resource-
 specific actions. Similarly, the choice of method for content generation may depend 
 on the degree to which you want to separate design work from programming. Lua 
 Pages may offer a simpler solution in cases where design and coding is done by the 
 same person, while a safe template solution like Cosmo may make your life easier if 
 the design work is to be delegated to a designer or even to anonymous end users.",NA
9,NA,NA
"Filters, Sources, Sinks & ",NA,NA
Pumps ,NA,NA
or Functional programming for ,NA,NA
the rest of us,NA,NA
Diego Nehab,"Certain data processing operations can be implemented in the form of filters. A filter 
 is a function that can process data received in consecutive invocations, returning 
 partial results each time it is called. Examples of operations that can be implemented 
 as filters include the end-of-line normalization for text, Base64 and Quoted-Printable 
 transfer content encodings, the breaking of text into lines, SMTP dot-stuffing, and 
 many others. Filters become even more powerful when we allow them to be chained 
 together to create composite filters. In this context, filters can be seen as the internal 
 links in a chain of data transformations. Sources and sinks are the corresponding end 
 points in these chains. A source is a function that produces data, chunk by chunk, and 
 a sink is a function that takes data, chunk by chunk. Finally, pumps are procedures 
 that actively drive data from a source to a sink, and indirectly through all intervening 
 filters. In this article, we describe the design of an elegant interface for filters, sources, 
 sinks, chains, and pumps, and we illustrate each step with concrete examples.",NA
Introduction,"Within the realm of networking applications, we are often required to apply 
 transformations to streams of data. Examples include the end-of-line normaliza-tion 
 for text, Base64 and Quoted-Printable transfer content encodings, breaking
  
 Copyright c
 ⃝
  2008 by Diego Nehab. Used by permission. 
  
 97",NA
Filter chains,"Chains greatly increase the power of filters. 
  
 For example, according to the 
 standard for Quoted-Printable encoding, text should be normalized to a canonic end-
 of-line marker prior to encoding. After encoding, the resulting text must be broken 
 into lines of no more than 76 characters, with the use of soft line breaks (a line 
 terminated by the = sign). To help specifying complex transformations like this, we 
 define a chain factory that creates a composite filter from one or more filters. A 
 chained filter passes data through all its components, and can be used wherever a 
 primitive filter is accepted.
  
 The chaining factory is very simple. The auxiliary function chainpair chains two 
 filters together, taking special care if the chunk is the last. This is because the final nil 
 chunk notification has to be pushed through both filters in turn:",NA
"Sources, sinks, and pumps","The filters we introduced so far act as the internal nodes in a network of 
 transformations. Information flows from node to node (or rather from one filter to 
 the next) and is transformed along the way. Chaining filters together is our way to 
 connect nodes in this network. As the starting point for the network, we need a 
 source node that produces the data. In the end of the network, we need a sink node 
 that gives a final destination to the data.
  
 Sources
  
 A source returns the next chunk of data each time it is invoked. When there are no 
 more data, it simply returns nil. In the event of an error, the source can inform the 
 caller by returning nil followed by the error message.
  
 Below are two simple source factories. The empty source returns no data,
  
 possibly returning an associated error message. 
 contents of a file in a chunk by chunk fashion:
  
 function source.empty(err) 
  
  
 return function() 
  
   
 return nil, err 
  
  
 end 
  
 end
  
 The file source yields the",NA
Exploding filters,"Our current filter interface has one serious shortcoming. Consider for example a gzip 
 decompression filter. During decompression, a small input chunk can be exploded 
 into a huge amount of data. To address this problem, we decided to change the filter 
 interface and allow exploding filters to return large quantities of output data in a 
 chunk by chunk manner.
  
 More specifically, after passing each chunk of input to a filter, and collecting the 
 first chunk of output, the user must now loop to receive other chunks from the filter 
 until no filtered data are left. Within these secondary calls, the caller",NA
A complex example,"The LTN12 module in the LuaSocket distribution implements all the ideas we have 
 described. 
  
 The MIME and SMTP modules are tightly integrated with LTN12, 
 and can be used to showcase the expressive power of filters, sources, sinks, and 
 pumps. Below is an example of how a user would proceed to define and send a 
 multipart message, with attachments, using LuaSocket:
  
 local smtp = require""socket.smtp"" 
  
 local mime = require""mime"" 
  
 local ltn12 = require""ltn12"" 
  
 local message = smtp.message{ 
  
  
 headers = { 
  
   
 from = ""Sicrano <sicrano@example.com>"", 
  
   
 to = ""Fulano <fulano@example.com>"", 
  
   
 subject = ""A message with an attachment""}, 
  
  
 body = { 
  
   
 preamble = ""Hope you can see the attachment"" .. CRLF, 
  
  
 [1] = { 
  
    
 body = ""Here is our logo"" .. CRLF}, 
  
   
 [2] = { 
  
    
 headers = { 
  
    
 [""content-type""] = ’image/png; name=""luasocket.png""’, 
   
  
 [""content-disposition""] =
  
      
 ’attachment; filename=""luasocket.png""’, 
  
    
 [""content-description""] = ’LuaSocket logo’, 
  
    
 [""content-transfer-encoding""] = ""BASE64""}, 
  
    
 body = ltn12.source.chain( 
  
    
 ltn12.source.file(io.open(""luasocket.png"", ""rb"")), 
  
  
  
 ltn12.filter.chain( 
  
      
 mime.encode(""base64""), 
  
      
 mime.wrap()))}}}",NA
Conclusion,"In this article, we introduced the concepts of filters, sources, sinks, and pumps to the 
 Lua language. These are useful tools for stream processing in general. Sources 
 provide a simple abstraction for data acquisition. Sinks provide an ab-straction for 
 final data destinations. Filters define an interface for data trans-formations. The 
 chaining of filters, sources and sinks provides an elegant way to create arbitrarily 
 complex data transformations from simpler components. Pumps simply push the 
 data through.
  
 Acknowledgments
  
 The concepts described in this text are the result of long discussions with David 
 Burgess. A version of this text has been released on-line as the Lua Technical Note 
 012, hence the name of the corresponding LuaSocket module, LTN12. Wim 
 Couwenberg contributed to the implementation of the module, and Adrian Sietsma 
 was the first to notice the correspondence between sources and Lua iterators.",NA
10,NA,NA
Lua as a Protocol Language,NA,NA
Patrick Rapin,"This article describes the use of Lua as a communication vector between a client and 
 a server programs. In addition to some implementation choices, we discuss the 
 advantages and drawbacks of this approach, with a special point made on security.",NA
Background,"Our company is using a custom source control system program called Code-
 Administrator, a tool I wrote several years ago in C++ using Microsoft Foun-dation 
 Classes (MFC). The program has run to satisfaction until now; however it has some 
 limitations: it can only run on Windows and it cannot be used over a regular Internet 
 connection, only through a virtual private network.
  
 We tried to find a way to keep the compatibility of the source database and 
 version numbers, while adding support for Unix-based systems and Internet 
 functionality. An idea for a solution arose: rewrite the core of the program using Lua, 
 into a new tool called Lua CodeAdministrator or LCA. At first at least, there is no need 
 to port all features, notably the administrative tasks, since it is aimed to be a user 
 add-on to the original tool rather than a full replacement. Although the goal of this 
 article is to discuss the ideas beyond the protocol used, it will refer to this particular 
 program when needed for the explanation.
  
 Copyright c
 ⃝
  2008 by Patrick Rapin. Used by permission. 
  
 109",NA
Choice of language,"What are the advantages of using Lua to implement a version checking utility? 
 Compared to compiled languages, using a scripting language simplifies the 
 implementation a lot because:
  
 • It is easy to ensure the portability of the program.
  
 • The code is typically shorter compared to C functions.
  
 • It is easy to customize functions, for example by overriding global vari-
  
 ables.
  
 • Configuration files can be written in the same language as the main pro-
  
 gram.
  
 • The protocol itself can use the same language, which is the main subject of 
  
 this 
 article.
  
 Other scripting languages would certainly also fit the requirements for this tool. The 
 reasons we prefer Lua are the following:
  
 • It is fast, compared to most other scripting languages.
  
 • It is small, thus there is no practical problem embedding it into programs.
  
 • It is easy to compile on all platforms.
  
 • We have a very good experience with the language since we are using it for 
  
 our 
 printers.",NA
Protocol,"Like for example CVS, LCA can be run in four different modes:
  
 Standalone.
  The user directory and the repository can both be accessed directly, 
 either on a local hard drive or over a mapped network drive. There is no need 
 to worry too much about security in this case: we can assume that the file 
 system management already checks for read and write authorizations.
  
 Client.
  The user directory can be accessed directly by the program, and any read or 
 write action to the repository must be performed through a request over the 
 network to the server. Security is not a problem on this side; we assume that 
 the user has authorized access to his computer. But the client must be able to 
 provide security checks to the server.
  
 Server.
  Unlike the other two modes, which are run once for each operation requested, 
 the server must run permanently, as a daemon. 
  
 It has full 
 direct access to the repository, but each time it needs reading or writing to the user 
 directory, it issues requests back to the client. Security is an important issue for any 
 program accepting requests from the Internet. The user must first log in, and data can 
 be encrypted to ensure confidentiality. Other tricks are used, as discussed later.",NA
Compression,"The original database format uses BZIP2 compression library to drastically decrease 
 its size. By the way, we were surprised to observe that CA databases for typical C 
 projects have an overall compression ratio of about 95% (or 20 times)! LCA must of 
 course use this library to open the source code database. The same algorithm is also 
 used to compress the Lua source code stored inside the executable file, and to 
 compress data sent over the Internet socket. The latter is optional, because on a local 
 network the transfer time is probably lower",NA
Encryption,"Optionally, data can also be encrypted using an MD5 library in cypher-feedback 
 mode. We chose this algorithm simply because a standard Lua module exists. The 
 security of this algorithm is certainly enough for our application. The same Load 
 function is used for this case. This is no requisite; an idiom like this one would do the 
 same thing, although it is a little more verbose:
  
 loadstring(Uncompress(Decrypt(string_data)))()
  
 Of course, when combining compression and encryption, we must first apply 
 compression and then encryption; inversely, first decryption and then decom-
 pression. This is because an encrypted message compresses very badly, since it just 
 looks like random data.",NA
Secured mode,"There are two running modes for the server: secured and unsecured. 
  
 The 
 unsecured mode is targeted to be used inside a secured local network, while the 
 secured mode could be opened on the whole Internet.
  
 In secured mode, the authorized user must log in with a password before he can 
 make any operation. An MD5 hash of a challenge phrase is used for the authentication 
 procedure. Before login is complete, the only global value in the environment is the 
 authorization function itself. The server will check and refuse any request that do not 
 look like a valid authorization request.
  
 If the login succeeds, most of the other custom functions become available, as in 
 the unsecured mode. Critical functions that could destroy the database may only be 
 executed over a secured local network.",NA
Benchmark,"A small benchmark run between the original MFC program and the Lua-based version 
 showed surprising results, which may be of interest to other Lua pro-grammers. For 
 the key feature of extracting a version, the equivalent of cvs checkout -r tag, LCA in 
 standalone mode happens to take roughly the same",NA
Security,"Security is a major issue for any system opening sockets over the Internet. As the 
 protocol consists of plain scripting code, this is quite an invitation for hackers to send 
 malicious code to the server!
  
 Library functions
  
 Fortunately, Lua gives us some weapons to fight against hacking. First, in this 
 language we have full control of which functions are exported into the global 
 environment. None of the standard Lua functions is present in the environment used 
 to evaluate external command scripts. 
  
 These functions are in reality 
 present in Lua state memory, but only as local variables, so there is no way to access 
 them even with a malicious code.
  
 Of the standard libraries, the coroutine, math, table and string libraries are 
 normally harmless. They are not exported nevertheless because we do not need 
 them, and do not want to give these facilities to the outside world.
  
 On the other hand, the io, os, and debug libraries are very dangerous. If a hacker has 
 direct access to io.open or os.execute function, he can delete or create files on the 
 server system nearly as he wants (just limited by the operating system permissions). 
  
 The base function dofile and the package library may be used to run external Lua 
 code present somewhere on the server hard disk, providing the hacker has the 
 knowledge of the place to find these.",NA
Conclusion,"This experience shows that it is possible to use Lua as a protocol language over an 
 Internet socket. 
  
 Such a protocol simplifies the implementation and 
 debugging of the communication tool, if a Lua interpreter is used for other tasks as 
 well. However, it is clearly not a good choice for critical services, because the scripting 
 language opens a number of security issues. This approach is best targeted to quickly 
 developed enterprise tools, run over a secured local area network.",NA
11 ,NA,NA
Lua Script ,NA,NA
Packaging,NA,NA
Han Zhao,NA,NA
Why do we need to package script files together?,"In real world applications, the logic or data described in Lua will be distributed into 
 many .lua files that may be scattered in different directories. 
  
 During 
 development this directory structure reflects the organization of modules or 
 resources (if Lua serves as a data description language). But when release time 
 comes, there might be too many files to deliver. After installation, all script source 
 files will be visible to the end user — that may not be acceptable for a commercial 
 product for both maintenance and security reasons. A packaging mechanism is 
 necessary to avoid exposing the internal details of an application.",NA
First try: luac -o,"During development, .lua files are usually organized in a directory hierarchy. If you 
 use luac to compile .lua source files into a single pre-compiled file as in
  
 luac -o dest-file src-file-list
  
 the directory hierarchy will be lost — all source files are compiled and packed 
 together flatly. For simple projects, it’s possible to build a utility to map the directory 
 hierarchy to the flat structure of the release package. But there will be a maintenance 
 overhead — the developer will have to keep in mind where a file is located in the 
 release package. We don’t want our modularization strategy for
  
 Copyright c
 ⃝
  2008 by Han Zhao. Used by permission. 
  
 119",NA
Mock require and dofile,"To load Lua files from a package, we need to modify the default behavior of standard 
 require and dofile.
  
 How does the standard require work?
  
 According to Programming in Lua Chapter 15.1, the require function works in 
 following steps:
  
 “Its first step is to check in table package.loaded whether the module is 
 already loaded. 
  
 If so, require returns its corresponding value. 
 Therefore, once a module is loaded, other calls to require simply return the 
 same value, without loading the module again. 
  
 If the 
 module is not loaded yet, require tries to find a loader for this module [. . . ] 
  
  
 Its first attempt is to query the given library name in table 
 package.preload. If it finds a function there, it uses this function as the 
 module loader.”
  
 Besides the internal mystery require does, require itself is just a normal Lua function 
 which we can replace with our mocked package-friendly one.
  
 Mock require
  
 We’ll leverage the module loading mechanism described above to build a deco-rator 
 around the standard require to do the extra work: plugging our module loader onto 
 package.preload table to load a .lua file from package and leaving the rest to the 
 standard require.
  
 The mocked require looks like this:
  
 -- rename standard require 
  
 local lua_require = require
  
 -- mocked require 
  
 function require(mod_name)
  
  
 -- redirect loading function to our package (.dat) loader 
  
 package.preload[mod_name] = fio_loader
  
  
 -- Lua standard loading routine 
  
  
 lua_require(mod_name) 
  
 end
  
 The package loader (fio_loader) will convert the given module name to a format 
 needed by the packaging format. Then fio_loader will load the module (.lua file) 
 referenced by module name from the package:",NA
Choose a packaging algorithm/utility,"The mocked require and dofile hides the file loading mechanism from Lua. We can 
 choose any packaging algorithm that best suits our needs. Though the zlib-alike .dat 
 format we’ve used for illustration is good enough for general purpose packaging, you 
 can build your own home-brew format or even no packaging at all, just a dumb 
 wrapper around the standard require and dofile.
  
 .dat format
  
 Here is a brief description of the .dat format.
  
 .dat is a format used in Black Isle Studio’s Fallout role-playing game series for 
 game resource packaging. Its simple structure makes it a good candidate. A .dat file 
 contains a sequence of gzip compressed files with a record at the tail describing each 
 file’s reference name, file size, and offset.
 1
 In our implementa-tion, DatFileReg holds 
 the .dat file, maintains a map from reference name to offset; DatFile is responsible for 
 reading a single zip file (located by a reference name) in which a resource file is 
 packed. The format has been well studied and supported by the Fallout modding 
 community — there are many .dat pack-ers/unpackers available (both command line 
 and GUI ones).
 2
 It’s convenient to choose this format instead of inventing a new one 
 and building the tool set from scratch.
  
 Compiled vs plain .lua files
  
 Simple packaging of plain .lua files has one drawback: anyone can view the source 
 code with a text editor. To protect the source code, you can pack compiled .lua files 
 instead of plain source files. 
  
 Since the Lua file loader treats both 
 formats in the same way, here’s a trick to make our mocked require and dofile still 
 work for compiled files: when compiling, you just need to name the output file the 
 same as the original .lua file:
  
 luac -o output\foo.lua foo.lua
  
 Or use the following command if you’re working in batch mode on Windows:
  
 for %%f in (*.lua) do luac -o output\%%f %%f
  
 Please note that the compiled file is still easy to be hacked — there are some 
 decent decompilers for Lua out there. You can use the technique described here as a 
 starting point to build more advanced features like accessing verification or 
 encryption into your packaging algorithm to protect the source code.
  
 1
  .dat file format description: http://wiki.fifengine.de/index.php?title=DAT architecture# DAT2 
  
 2
  .dat file tools: http://www.teamx.ru/eng/files/utils/ F2 DAT-files packer/unpacker (DAT2), command 
 line tool; DatMan! Light, GUI tool.",NA
Conclusion,"We started from Lua’s basic facilities (require, dofile, and the binding API) to build a 
 flexible and powerful packaging mechanism. With Lua script packaging, we can setup 
 a direct mapping from the development structure to the deploy-ment structure that 
 hides internal organizing details from the end user. The application will be easier to 
 develop, deploy, and maintain.
  
 The technique described here has been applied in two game projects and a shareware 
 product.",NA
12,NA,NA
"Objects, Lua-style",NA,NA
Reuben Thomas,"Object-oriented programming is one of the most thoroughly explored and hotly 
 debated topics in Lua, as in so many languages that lack built-in objects. Con-
 siderable effort has been expended to implement objects in many different ex-isting 
 styles. Often the aim is to integrate smoothly with existing OO systems, in C, C++ or 
 Java; sometimes it seems to degenerate into a “me-too” exercise. Rarely is the 
 question approached from the other direction: what is the most Lua-ish way to do 
 objects? In a sense, the answer is already present: the lan-guage already has basic 
 support for object orientation, with tables as objects, the table:function() syntactic 
 sugar for method dispatch, and the __index metamethod for inheritance. However, 
 there is no built-in instantiation or sub-typing mechanism.
  
 I present a prototype-based object implementation in 35 lines lines of Lua (most 
 of which is actually just three important functions on tables). Although the 
 framework is based on a consideration of the design of Lua, rather than that of any 
 particular OO system, it has been successfully used with existing code, in particular to 
 wrap non-OO C code into easier-to-use OO Lua. It fits well with the Lua philosophy, 
 and adds little overhead, in space, time or complexity.
  
 Having presented, examined and discussed the model and implementation, I end 
 by re-examining the justification for programming in an OO style in Lua at all, and 
 suggest that it is needed less often than one might think.
  
 Copyright c
 ⃝
  2008 by Reuben Thomas. Used by permission. 
  
 129",NA
The object model,"It’s so simple that there’s little more to do than state the obvious. First, note that 
 there is no
  a priori
  distinction between objects and classes, though it is common to 
 make “class objects” that are used to create all objects of a class, and for no other 
 purpose. Below, class objects’ names are capitalized. Similarly, fields and methods are 
 only distinguished by type: a field which is a function, or a table with a __call 
 metamethod, is usually considered to be a method.
  
 Create an object:
  object = prototype{value, ...; field = value, ...} object is created by 
 cloning prototype (typically, a class object). The table passed to it is used to 
 initialize fields as follows: keyed fields are straight-forwardly initialized, while 
 unkeyed fields (to be precise, non-negative in-teger fields) are assigned to the 
 fields whose keys are listed in the prototype object’s init field, as a convenience 
 (any excess arguments are simply kept as a fields with numeric indices). This is 
 best illustrated:
  
 Point = Object{_init = {""x"", ""y""}} 
  
 p = Point{-5, 3; color = ""blue""}
  
 assigns −5 to p’s x field, 3 to its y field, and “blue” to its color field. (Note that we 
 use a table rather than a normal argument list so that both named and unnamed 
 fields may be conveniently initialized.)
  
 Strictly speaking, the above is only true when the prototype object’s _code field 
 is unmodified. It may usefully be overridden to add initialization code.
  
 An object has no record of its prototype. One can be made explicitly, or a 
 _prototype field could be set by the default _clone method.
  
 By convention, fields have string keys, and private fields have keys starting with 
 an underscore. 
  
 Since private fields aren’t hidden, it’s up to the 
 programmer to ensure they don’t clash.
  
 Access field:
  object.field 
  
 Since object fields are normal table entries, the standard syntax is used to read 
 and write to them.
  
 Call method:
  object:method(...) 
  
 As for field access, method invocation works using the standard syntax.
  
 Call class method:
  Class.method(object, ...) 
  
 The obvious way to call a class method is used: simply use dot rather than colon 
 notation, to pass the object explicitly.",NA
A judicious justification,"By now, some readers are probably verging on apoplexy, either because of the use of 
 prototypes, or because of the object model’s extreme simplicity. Such readers",NA
A delightful detour,"Our object implementation needs some basic functions which should be in any Lua 
 programmer’s toolbox: clone, merge and rearrange. The following imple-mentations 
 are taken from the stdlib project (http://luaforge.net/projects/ stdlib). The code 
 verges on the trivially simple; precisely for this reason I repro-duce it here for the 
 reader’s enjoyment. Of crucial importance is that all three routines are
  functional
 : 
 they do not have any side effects. Though Lua is an imperative language, it is well-
 suited to a functional style, which in my opinion should be used whenever applicable, 
 as it encourages clear, robust and re-usable code.
  
 clone makes a shallow copy of a table, including any metatable:
  
 function clone(t) 
  
 local u = setmetatable({}, getmetatable(t)) for i, v in 
 pairs(t) do 
  
  
 u[i] = v 
  
 end 
  
 return u 
  
 end
  
 merge merges two tables. The merge, like assignment, goes right to left: fields of 
 the second argument override those of the first, but the result’s metatable, if any, is 
 that of the first argument. The left-hand argument, though, is not overwritten.",NA
Implementation,"Given the functions above, the actual object implementation is brief.
  
 Object = { 
  
 _init = {}, 
  
 _clone = function(self, values) 
  
   
 local object = merge(self, rearrange(self._init, values)) 
  
  
 return setmetatable(object, object) 
  
  
 end, 
  
 __call = function(...) 
  
   
 return (...)._clone(...) 
  
  
 end, 
  
 } 
  
 setmetatable(Object, Object)
  
 The careful reader will want to check that the innocuous-looking first line of 
 _clone really does what it should, and note that the odd-looking implementation of 
 __call really is correct: the first (...) adjusts the list to one element, the object, while the 
 second passes the entire argument list to _clone, which is really a method, so its first 
 argument is indeed the object itself.",NA
Weaknesses,"The default _clone could be made to discard excess numbered initializers, but that 
 feels un-Lua-ish, as it imposes behavior that is not required for correct functioning.
  
 There are also some obvious major omissions. First, since our objects can be indexed 
 just like ordinary Lua tables, there’s nothing to stop the programmer treating them as 
 such. In other words, we lack information hiding, one of the main planks of object 
 orientation. I don’t think this is a problem, however. Lua is not designed for opacity, 
 and is not a good choice when strong type discipline is required. 
  
 (This is not 
 to ignore Lua’s excellence as a language for safe, sandboxed scripting, which rests on 
 its namespace control.) 
  
 Secondly, there is no multiple inheritance. With prototypes, multiple inher-itance is 
 often replaced by aggregation: a number of classes objects are cloned and merged 
 together. For example:
  
 o = merge(c1._clone(), merge(c2._clone(), c3._clone()))
  
 This could be abbreviated
  
 o = subclass(c1, c2, c3)
  
 where subclass is defined:
  
 function subclass(...) 
  
 local r = {} 
  
 for c in {...} do 
  
  
 r = merge(r, c) 
  
 end 
  
 return r 
  
 end
  
 I didn’t include this in the package because I haven’t yet needed it.",NA
Inconclusion,"In conclusion, we can pertinently wonder whether having a general-purpose object 
 system in Lua is useful at all. The principle advantages of an OO style in Lua are 
 encapsulation of readable syntax for well-structured data types supporting a limited 
 range of operations. However, it’s often possible to write shorter, clearer code 
 without objects. 
  
 For example, when processing poorly 
 structured, unstructured or arbitrarily structured data, such as text, tag soup or XML, 
 a table-oriented approach is often clearer, and a functional style briefer. One example 
 of this is the utility functions used to implement objects, which perform general table 
 operations. The use of general-purpose functions, helps ensure that the object model 
 has no undefined behavior and is robust, as well as avoiding the need to write special-
 purpose code.
  
 The real conclusion is that Lua is flexible, and lends itself to a variety of approaches. 
 Each should be used when appropriate, but none taken too far.",NA
13,NA,NA
Exceptions in Lua,NA,NA
John Belmonte,"Despite the well known advantages of using exceptions for program errors, the 
 mechanism is underutilized in Lua — both in quantity and quality. One aspect of this 
 relates to the Lua core and standard library, which tend to raise exceptions only in the 
 most serious situations such as parse errors, type errors, and invalid arguments. 
  
 When exceptions are thrown, they are exclusively string values which 
 are not enumerated as part of the API. Tables, the primary data structure, yield nil for 
 a nonexistent key rather than raise an error. All of this leads to an unspoken bias in 
 Lua that exceptions are something to be thrown but rarely caught — that they are 
 serious errors which normally go unhandled. In the few situations where we do catch 
 them, no distinction is made with respect to the cause of the error.
  
 The core and standard libraries arguably work well as they are, and their use of 
 errors may not warrant meddling. But why are exceptions also under-utilized within 
 Lua programs and third party modules? 
  
 One problem is the 
 unfriendliness of Lua’s protected call interface to programmers expecting a na-tive 
 try–catch construct. This in turn discourages library authors from using exceptions 
 for fear of alienating users. The inability to use coroutines within a protected call also 
 works to limit uptake by libraries.
  
 Lua possesses the necessary building blocks for exceptions; however, rough edges 
 appear when one tries to assemble them. 
  
 This perpetuates disuse of 
 exceptions and strengthens anti-exception patterns such as signaling errors by way of 
 return values. To break the cycle, we first need to promote idioms and know-how for 
 richer use of exceptions. As more Lua developers encounter
  
 Copyright c
 ⃝
  2008 by John Belmonte. Used by permission. 
  
 135",NA
What is an error?,"What failure situations should be considered a first-class error, warranting the use of 
 exceptions? 
  
 Calling a function with invalid arguments is an obvious error. In 
 contrast, a negative result from a string matching function is normally not considered 
 an error. In between these is an expanse of various error-like situations. What about 
 an attempt to append to a read-only file; a failed hash table lookup; a database 
 conflict; or an HTTP connection failure? We need a guideline for evaluating these.
  
 On this subject, “Programming in Lua” suggests that if an error cannot be easily 
 avoided, it should be signaled with a return code rather than exception. This logic is 
 geared towards letting you handle error situations without the need for a try–catch 
 — a decidedly conservative view on the use of exceptions. What effect does it have on 
 a program?
  
 Let’s consider a Lua program which outputs the length of a file given its name on the 
 command line:
  
 local f = io.open(arg[1]) 
  
 local length = f:seek(’end’) 
  
 print(length)
  
 The program lacks error handling — it may be the work of a novice program-mer 
 or a lazy expert programmer. How does it behave when things go wrong?
  
 Let’s try an input file, “abc”, which doesn’t exist:
  
 $ lua file-length.lua abc 
  
 lua: file-length.lua:2: attempt to index local ’f’ (a nil value)
  
 The good news is that an unhandled exception occurred, causing the program to 
 return a non-zero exit code. This is the bare minimum behavior we need from a 
 command-line program on error. The error message, however, is not very helpful. 
  
 In this simple program we can look at the source code and quickly deduce that 
 io.open returned nil instead of a file object, causing an error on call of the seek 
 method. In a complex program, debugging could be much more difficult. The file 
 object could be passed to a different place in the program, and perhaps not used until 
 long after the io.open call.",NA
A simple try–catch construct,"Now that we’ve planted the seed for more exceptions, we can focus on how to catch 
 them. As mentioned, Lua lacks the common try–catch construct for dealing with 
 exceptions, which may put off some programmers. 
  
 By creating 
 something in pure Lua close to that familiar construct, perhaps we can lower the 
 barrier to more extensive use of exceptions.
  
 Lua supports catching of exceptions through a functional interface, namely pcall. 
 It expects that the code to be attempted is itself defined as a function. Those 
 constraints leave us with few options — our try–catch will have to be functional also, 
 with the “try” and “catch” blocks of code passed in as functions. Nonetheless, with the 
 help of in-line anonymous functions and some creative formatting, we can approach 
 the feel of a native try–catch construct. Here is a template for use of our utility 
 function, simply called “try”:
  
 1
 Wrapping a call with assert assumes it follows the convention of returning a nil and error message 
 tuple on failure. The convention can’t be used, however, if nil or false happen to be valid outputs. It can also 
 interfere with code readability when a function has multiple outputs and the caller elects not to wrap with 
 assert (e.g., a function returns coordinates x and y, but on error y doubles as a message).",NA
Custom error objects,"Putting our new try–catch construct to use, let’s say we have a transactional database 
 application. If a database conflict error occurs — perhaps because two programs 
 tried to increment the same balance field of some record — we’d like to retry the 
 transaction. Coding our simplistic example:",NA
Exception safety,"With exceptions comes the issue of exception safety — proper cleanup of acquired 
 resources and program state when an exception does occur. Acquired resources 
 might include memory allocated from special pools, device handles, and mutex 
 objects. Consider the following simplistic function to paint a logo onto the screen:
  
 function display_logo(display_buffer, x, y) 
  
  
 local canvas = allocate_canvas(50, 50) 
  
  
 render_logo(canvas) 
  
  
 display_buffer:lock() 
  
  
 display_buffer:copy(canvas, x, y) 
  
  
 display_buffer:unlock() 
  
  
 canvas:free() 
  
 end
  
 During the course of this function we acquire a graphic canvas (perhaps off-screen 
 video memory) and a lock on the display buffer. If the render_logo function happens 
 to throw an exception then the canvas may not be freed in a timely manner — it may 
 happen automatically when the canvas value is garbage collected, but we don’t know 
 when that will be. More seriously, if the display_buffer:copy call throws an exception 
 because the input coordinates are out of range, the display is never unlocked. Clearly, 
 if resources like this are going to be exposed to the scripting environment, we need a 
 way to free them even if an exception occurs.
  
 Even if we decide not to expose management of critical resources to scripting, 
 there are common cases where we must ensure that some program state is restored 
 despite an error. Say we’d like the text output of a certain third party function 
 directed to a file, but the module has been hard-coded to use standard output. We 
 could work around the limitation by changing Lua’s default output temporarily:
  
 local out = io.output() 
  
 io.output(log_file) 
  
 somelib.do_task() 
  
 io.output(out)",NA
A simple scope manager,"We define a utility function “scope”, which takes a single function argument and calls 
 it. Within the environment of the given function, an on_exit function is made available 
 for registering cleanup functions. Here is how the scope utility looks when applied to 
 our display_logo example:
  
 function display_logo(display_buffer, x, y) 
  
  
 scope(function() 
  
  
  
 local canvas = allocate_canvas(50, 50) 
  
  
  
 on_exit(function() canvas:free() end) 
  
  
  
 render_logo(canvas) 
  
  
  
 display_buffer:lock() 
  
  
  
 on_exit(function() display_buffer:unlock() end) 
  
  
 display_buffer:copy(canvas, x, y) 
  
  
 end) 
  
 end
  
 Notice that no nesting is needed for consecutively acquired resources as in the 
 try-finally solution. Also, each piece of cleanup code is positioned logically so that, as 
 the code is read from top to bottom, one can see exactly when it becomes active 
 within the scope.
  
 To round out our cleanup utility, we’ll make two more registration functions 
 available within the scope: on_failure and on_success. The on_failure hook might be 
 used to roll back a pending database transaction or other tentative state change. 
 Although a try–catch could be used here instead, on_failure is more readable and 
 avoids having the user take responsibility for re-raising the caught error. The 
 on_success hook will likely be least used of the three, but
  
 2
 The ability to hook into scope exit is the only fundamental building block I’ve noticed as missing from 
 Lua 5.1. I hope that this can be resolved in a future version of the language — perhaps by creating a new 
 class of variable which notifies its value when it goes out of scope, or by adding a construct along the lines 
 of Python’s “with” statement.",NA
Part III,NA,NA
Algorithms ,NA,NA
and ,NA,NA
Data Structures,NA,NA
14 ,NA,NA
Word ,NA,NA
Ladders,NA,NA
Gavin Wraith,"Word Ladders
  or
  Doublets
  is a word game whose invention has been attributed to 
 Lewis Carroll. The idea is to transform one word into another by changing only a 
 single letter at each step.
  
 Here is a simple example:
  
 BEST
  →
  PEST
  →
  POST
  →
  POSE
  →
  ROSE
  →
  RISE
  →
  RISK
  
 We present a small Lua program which, given a lexicon of words as a com-mand 
 line argument, takes a word from the standard input and prints the words in the 
 lexicon that can be obtained from it by such transformations. This pro-gram is really 
 just an excuse for presenting a more abstract application: a mod-ule for calculating 
 the strata of the connected component of a vertex in an undi-rected graph.",NA
Undirected graphs,"From the earliest days of programming this game has been a vehicle for demon-
 strating algorithms about undirected graphs. An undirected graph may be de-fined as 
 a set of
  vertices
  together with a Boolean-valued function on the set of unordered pairs 
 of distinct vertices, which tells which vertices are joined by an 
 edge
 . In what follows 
 the term
  graph
  should be read as
  undirected graph
 .
  
 If two vertices can be joined by a sequence of edges then we say that they belong 
 to the same
  component
  of the graph. Given a lexicon of words we can construct a 
 graph whose vertices are words, where two vertices are joined by an
  
 Copyright c
 ⃝
  2008 by Gavin Wraith. Used by permission. 
  
 149",NA
Word Ladder game,"The Word Ladder game itself can be coded as in Listing 2. The program uses a lexicon 
 of words in a file whose pathname is passed in as a command line argument, and a 
 starting word which is input by the user. It outputs the words in the strata in order.
  
 The program asks for the start word to be input, and transforms it to lower case. 
 The lexicon is a file consisting of lower case words separated by white space and 
 newlines. The table called lexicon is set to have as keys the words found in the lexicon 
 file to be of the same length as the start word, as this version of the game does not 
 allow the length of words to change. A function string.vary is added to the string 
 library which creates a pattern matched by any word that differs in only one letter 
 from its first argument, whose position is the second argument. The reason for 
 adding it to the string library is a trivial aesthetic one: it makes the pretty colon 
 notation available. The function differby1 is a Boolean-valued function that tells when 
 words differ by only one letter. The graph wordgraph is defined by the lexicon table 
 and the differby1 function. A function printout is defined to print out the contents of 
 the strata; it converts all words to upper case and first prints the stratum level. The 
 graph library is loaded and finally the result is output.",NA
Summary,"The graph module and the ladder program that uses it are tiny and straightfor-ward, 
 and in themselves unremarkable. They are simply pegs on which to hang some 
 observations. Readers are, of course, free to quarrel with my personal preferences.
  
 • I like to use comments, but not too many. It is pointless to overcomment if 
  
 meaningful variable names tell the story.
  
 • I like to indent to make chunks easily identifiable.
  
 • I like to comment the
  end
  keyword whenever feasible.
  
 • I like to reduce the use of global variables as much as possible.",NA
15,NA,NA
Building Data ,NA,NA
Structures and ,NA,NA
Iterators in Lua,NA,NA
Luis Carvalho,"Besides being lightweight and fast, Lua is also highly regarded for being an elegant 
 and expressive language. The main purpose of this gem is to reinforce this impression 
 by showing how powerful and straightforward the concerted application of tables, 
 metamethods, and coroutines is in the implementation of complex data structures 
 and their iterators.
  
 Here we implement a graph object module where graphs are modeled us-ing a 
 vertex set, a weighted edge/arc set and adjacency lists (set objects are as described in 
 “Programming in Lua” (PiL)). Graph vertex sets can be iterated by depth first search 
 (DFS), breadth first search (BFS), and topological sorting, which illustrate well the 
 application of closures and coroutines. Moreover, classi-cal routines for shortest 
 paths from a vertex and minimum spanning tree (MST) are also provided. These 
 routines require additional data structures in order to achieve optimal time 
 complexity: queues (similar to the ones implemented in PiL) are used in the BFS 
 iterator, while heaps and partition sets (both as trees with special properties) are 
 used in the MST routine. Each data structure, on its own, comprises an individual 
 pure Lua module whose methods satisfy the usual colon calling convention for 
 objects. A few examples and direct applications of the routines are also presented.
  
 Copyright c
 ⃝
  2008 by Luis Carvalho. Used by permission. 
  
 155",NA
Introduction,"The study and development of algorithms and data structures are tightly cou-pled 
 together: appropriate data structures are the core of well designed, optimal 
 algorithms. Besides designing suitable data structures, it is also important to use a 
 programming language that allows easy specification and implementation of a data 
 structure and that is rich and expressive enough to favor the realiza-tion of abstract 
 concepts and possible future extensions. This gem aims to show that Lua is such a 
 language: with its many appealing resources — including a powerful unique data 
 structure building block, the table, metamethods, and coroutines — we can 
 implement many data structures effortlessly.
  
 The main data structure portrayed in the text is a graph, but we also present 
 others in order to solve some classical graph problems efficiently. A complete listing 
 of all routines, which are encapsulated in modules, one per data struc-ture, can be 
 found in the gem repository.
  
 Although we provide an explanation for each method in the text, we try to be as 
 terse as possible to keep the text short. Familiarity with data structures and design of 
 algorithms is highly desirable — this way you can concentrate in enjoying the Lua 
 code! — but not necessary; however, the reader should refer to many excellent books 
 that cover these topics for more details
 1
 . We should mention the excellent
  
 “Programming in Lua”
  (PiL)
 2
 , by Roberto Ierusalimschy, one of Lua’s creators: we 
 make many references to it, and try to draw inspiration from it whenever possible.",NA
Queues,"Our first data structure is a
  queue
 , a list in which elements are always inserted to the
  
 front
  and retrieved at the
  rear
 , that is, in a first-in, first-out fashion. Although simple, 
 our queue implementation will be useful later on this chapter when we talk about 
 graph traversal and can serve as good warm-up exercise. The implementation 
 comprises a module Queue, very similar to the one in PiL: a queue object is a table 
 with two pointers, first and last, indicating the current positions of the queue’s front 
 and rear. A queue is then initialized by
  
 local modenv = getfenv() -- module environment 
  
 function new () 
  
 return setmetatable({first = 1, last = 0}, {__index = modenv}) end
  
 where we use __index to enable colon call notation in our objects. Note that getfenv 
 takes 1 as default argument and returns the current, module, environ-
  
 1
 We particularly recommend the classical
  “Design and analysis of computer algorithms”
 , by Aho, 
 Hopcroft and Ullman, and the more modern
  “Introduction to algorithms”
 , by Cormen, Leiserson, Rivest, and 
 Stein.
  
 2
 PiL’s first edition is available online at http://www.lua.org/pil.",NA
Heaps,"We now implement a
  heap
  data structure, which is a binary tree stored in an array. 
 For each node in the tree we associate a record
  numeric
  field such that the tree 
 satisfies the (min) heap property: for every node v, record(v) ≤min{record(l), 
 record(r)}, where l and r are the left and right children of v. If a tree is a heap, its root 
 contains the smallest record over all nodes in the tree.
  
 Heaps have many applications, but in this gem we focus on heaps as
  priority 
 queues
 , that is, as a data structure for keeping a set of objects ordered by their record 
 field. Priority queues will be at the core of our solutions to the minimum spanning 
 tree and shortest path problems in a latter section about graphs. Since records in a 
 heap represent some object feature — such as the time of occurrence of events in a 
 simulation engine — it is then desirable to have a correspondence between nodes in 
 the heap and objects. We use two additional fields for this
  
 3
 They are called
  push
  and
  pop
  in PiL.
  
 4
 For a more thorough presentation, check PiL’s chapter on object-oriented programming, more specifically 
 on the section about classes.",NA
Partition sets,"Consider now a set S and a
  partition
  {S
 i
 } over S, that is, the sets S
 i
  are disjoint,∩
 i
 S
 i
  = ∅, 
 and their union is S, ∪
 i
 S
 i
  = S. We want an efficient way to implement two operations 
 for partition sets:
  merge
  two sets into their union and, given an element e ∈ S,
  find
  the 
 set to which e belongs.
  
 A good representation for partition sets is a forest where every set is repre-sented 
 by a tree and is identified by the element at the root of its tree. This way, merging two 
 sets S
 1
  and S
 2
  requires a simple attachment of the tree represent-ing S
 1
  as a subtree in 
 S
 2
 . In addition, finding the set that contains a random element involves a tree 
 climbing routine from the element up to the root of the tree representing the 
 containing set. As we will see shortly, to guarantee effi-ciency we also need to 
 perform these operations according to some rules, but for now let’s just assume that 
 we need to keep track of the number of elements in each set.
  
 Our partition sets are represented by a table with two fields: card, a table storing the 
 cardinality of each set, and parent, a table storing the parent of An element e is the 
 root of a set S if and an element in its containing set.
  
 only if card[e] contains the number of elements in S — e represents S — and 
 parent[e] == nil. New partition objects are created with
  
 function new () 
  
 return setmetatable({card = {}, parent = {}}, {__index = modenv}) end
  
 while set takes a new element and creates a new set in the partition containing only 
 the argument,
  
 function set (P, e) 
  
 assert(e ~= nil, ""set cannot contain nil"") 
  
 assert(P.card[e] == nil and P.parent[e] == nil, 
  
 ""element 
 already in partition"") 
  
 P.card[e] = 1 -- e is root of new set 
  
 end
  
 and sameset checks if two elements belong to the same set in the partition:
  
 function sameset (P, e1, e2) 
  
 return find(P, e1) == find(P, e2) 
  
 end
  
 Now we need to provide find. 
  
 As stated before, to find to which set an 
 element e belongs, we just need to climb the tree from e up to the root. It is clear that 
 the shorter the tree the more efficient this task is; to favor this feature in our sets, we 
 then implement a compacting rule where all the internal nodes in the path from e up 
 to the root are collapsed into one level with the internal nodes becoming children of 
 the root:",NA
Graphs,"There are many ways to represent a graph data structure, each being better suited to 
 a particular application. For our graph object we adopt a representa-tion using
  
 adjacency lists
  — or better, tables — where the keys are vertices and the values hold 
 adjacency relations.
  
 Vertices can be of any type but nil, and are stored in the graph’s vertex set, vset; 
 similarly, we store the edges or arcs of a graph, if it is undirected or directed 
 respectively, in its edge (or arc) set eset. To avoid redundancy, vset is actually the 
 adjacency list: vset[v] is a table where each key is a neighbor u of v and the 
 corresponding value is the edge {u,v}, also a table. The edge set eset can be a regular 
 set as presented in PiL — keys are edges and values are true — or values can hold 
 edge
  weights
 .
  
 Graphs are created with our (now canonical) new method:
  
 function new() 
  
 return setmetatable({vset = {}, eset = {}}, {__index = modenv}) end
  
 As basic graph operations we offer the addition of vertices,
  
 function addvertex (G, v) 
  
 assert(v ~= nil, ""cannot add nil as vertex"") local vs = G.vset 
  
 assert(vs[v] == nil, ""vertex already in graph"") vs[v] = {} -- 
 new adjacency list 
  
 end
  
 and edges to a graph,
  
 function addedge (G, v1, v2, w) 
  
 assert(v1 ~= nil and v2 ~= nil, ""cannot add nil as vertex"") local vs = G.vset
  
 -- add v1 and v2 if not in G 
  
 if not vs[v1] then vs[v1] = {} end 
  
 if not vs[v2] then vs[v2] = {} end
  
 -- update v1 and v2 adjacency lists 
  
 local e = {v1, v2} -- new edge 
  
 vs[v1][v2] = e -- v1 -> v2 
  
 vs[v2][v1] = e -- v1 <- v2
  
 -- update edge set 
  
 G.eset[e] = w or true 
  
 end
  
 Addition of arcs can be handled by a very similar method where the adjacency lists 
 are updated only according to the arc direction.
  
 It is useful to have some iterators for traversing the vertex and edge sets, and the
  
 neighborhood
  of a vertex v — the set of vertices adjacent to v. We can derive such 
 iterators by mimicking the stateless pairs iterator:",NA
Conclusions,"This gem highlights Lua’s simplicity and expressiveness through the implemen-tation 
 of data structures and iterators. Data structures are easily realized by using tables 
 and their __index metamethod for object-like notation, while iter-ators can be build 
 using Lua’s generic for loop, closures and coroutines. The resulting code is simple, 
 high-level and abstract, mostly composed of table ac-cesses and object method calls.
  
 One of the main motivations of this text is to show many possible ways of 
 achieving a goal in Lua. For instance, there are many ways to construct an iterator in 
 Lua according to PiL; we cover them all here. Another motivation is to be true to one 
 of Lua’s maxims in PiL — “Lua gives you the power, you build the mechanisms” — by 
 providing iterators instead of tables, for example, or ways of generating a desired 
 table instead of the table itself, as in the backtracker factory.",NA
16,NA,NA
A Primer ,NA,NA
of Scientific Computing in ,NA,NA
Lua,NA,NA
Luis Carvalho,"Lua is a fast, resourceful, easily embeddable and extensible programming lan-guage; 
 this set of features makes Lua very suitable for scientific computing applications. This 
 gem implements a simple interface to two cornerstones of scientific computing: 
 numerical linear algebra and discrete Fourier transforms (DFTs). More specifically, 
 one module for (two-dimensional) matrices is imple-mented using some of Lua’s 
 unique resources, namely: weak tables, coroutines, metamethods, and environments.
  
 The matrix module defines a matrix object and its methods. A matrix object is a 
 userdatum containing a lua_Number pointer as the data core and other de-scriptive 
 parameters: number of rows and columns and stride. Data cores are allocated as new 
 matrices are created and are then stored in weak-keyed table as values, whereas the 
 corresponding keys are matrices that reference them. Matrix rows are objects where 
 the data core is a pointer to the “parent” matrix’s data core, and are lazily interned on 
 the parent’s userdatum environment table when a call to __index is made. Most 
 routines, like addition and scalar multi-plication, are thin wrappings around simple 
 (level 1) routines in the ubiquitous BLAS library. A routine to perform the discrete 
 cosine transform of a vector is also provided based on a routine from the — equally 
 ubiquitous — FFTW library. The C side of the matrix module is kept to the minimal 
 necessary extent for
  
 Copyright c
 ⃝
  2008 by Luis Carvalho. Used by permission. 
  
 173",NA
Introduction,"Lua tables are fast enough for many numerical applications. However, for more 
 specific applications performance is usually critical. One way to achieve a high 
 performance environment in Lua is to extend the language with suitable objects and 
 methods from efficient numerical libraries. 
  
 Of course, these extensions 
 should profit from Lua’s expressiveness and resourcefulness.
  
 In this gem we explore two common numerical extensions: matrices and dis-crete 
 Fourier transforms. These together allow us to implement many standard scientific 
 computing algorithms including numerical linear algebra, interpola-tions, and 
 quadratures. Moreover, with Lua we are able to devise very efficient implementations 
 that can beat even well-known scientific computing software!
  
 We assume the reader is fairly familiar with Lua’s C API and feels comfort-able 
 managing the Lua–C virtual stack. Due to the numerical nature of the text, a 
 background in engineering or numerical analysis is desirable, but not needed; the last 
 section, however, deals with more mathematically sophisticated appli-cations and 
 relies on some knowledge of elementary calculus and linear algebra.",NA
Matrices,"In order to keep our interface simple our matrices are real two-dimensional arrays 
 stored in column-major order. Column-major order is essential because we will be 
 using Fortran libraries, and that is Fortran’s storage mode for arrays.
  
 The first issue we need to address when representing matrices in Lua is indexing. 
 For a one-dimensional array (a vector) that is simple enough: just create a userdatum 
 with fields size and data and return data[i] for index i. For matrices this is a bit more 
 complicated since we have to go through two dimensions to access an entry. One 
 solution to accessing index (i, j) is to return the i-th row as a matrix which in turn 
 behaves like a vector and returns the j-th entry.
  
 Since matrices are stored in column-major order, rows in a matrix have an offset 
 from one entry to the next, that is, between consecutive columns. This row offset is 
 the number of rows from the matrix referenced by the row. We call this offset
  stride
 , 
 and we keep track of it in our data structure.
  
 It is not uncommon to use a matrix without referencing its entries, that 
   
 That 
 is actually the most efficient way is, by only using matrix operations.
  
 to use our library: operate in the higher level, say, adding, multiplying or 
 transforming matrices, and leave the heavy-duty operations to the optimized, 
 architecture-dependent libraries under the hood; seasoned users of numerical 
 software usually refer to this strategy as “vectorizing your code”. This practice 
 suggests that we should adopt a
  lazy interning
  strategy and only create the rows",NA
Applications,"Armed with our matrix module, we can now work on some applications. Since the 
 methods we implemented are basic, we need to illustrate their power with some 
 simple — but not elementary! — applications. 
  
 In the next sections we 
 will first exercise our module with some straightforward tasks to gain more
  
 10
 A good exercise is to provide a
  stateless
  iterator for vectors; check the repository for a solution.",NA
Conclusions,"In this gem, we have implemented a matrix library and a few applications. Lua’s 
 resources, including userdatum environments, metamethods, function closures, first 
 class functions, and proper lexical scoping were invaluable for a simple yet powerful 
 implementation: our matrices have lazily interned rows, efficient functional facilities, 
 and proper arithmetic operators, while our Chebyshev in-terpolants can compute the 
 integral of any function with arbitrary precision and limits of integration.
  
 Thanks to the C API, it is almost straightforward to extend Lua by either wrapping 
 routines from high performance, specialized, external libraries or providing your own 
 routines. We hope this gem inspires the reader to create new libraries — especially 
 numerical ones! — by following the same approach. One could also extend the 
 current implementation as suggested in the footnotes, or even by enhancing the 
 matrix object to account for multidimensionality and a typing system that would elect 
 the best routine for a specific task if the matrix were, say, triangular or symmetric. 
  
  
 For an implementation of these latter improvements and other scientific 
 computing facilities, including random deviates for a number of probability 
 distributions, complex number support, and specialized functions, the reader can 
 refer to the
  Numeric Lua
  project at http://numlua.luaforge.net.",NA
17 ,NA,NA
Complex Structured Data ,NA,NA
Input,NA,NA
Julio M. Fern´andez-D´ıaz,"Lua is very good at describing (often complex) data structures through tables. 
 However, apart from spotting syntax errors, Lua cannot deal directly with the logical 
 structure of read tables.
  
 This gem explains a small library which, in combination with data templates, 
 enables the user to: introduce complex, controlled structures to any depth; in-clude 
 test functions to check the validity of the input; declare optional values at any level 
 for missing fields, if desired; etc. An example, including the appropri-ate driver, which 
 runs in a convenient protected mode, is also shown.",NA
The problem,"As a developer, you are preparing a program (to be used by other people) which 
 requires (relatively general) data to be processed: control parameters in a chem-ical 
 plant, objects characteristics in an arcade game, etc.
  
 You may also wish to develop programs that allow some external configura-tion: 
 sometimes for self use; at other times, the end users wish to adapt the program to 
 their particular needs (which always adds value to the product).
  
 On other occasions, you are preparing a complex program with a graphical user 
 interface: windows, menus, buttons, radio-buttons, etc. A tool to facili-tate the 
 implementation would be welcome: a system that describes the menu structure both 
 well and clearly (with the corresponding actions) would be very useful. Then, by 
 adding only a general function for managing the structure, we have nearly all the 
 necessary parts for an operative program.
  
 Copyright c
 ⃝
  2008 by Julio M. Fern´andez-D´ıaz. Used by permission. 
  
 201",NA
The solution,"The initial idea was to include in the program a table with the structure of the desired 
 input data and to compare the value type field by field. However, this",NA
Justification and explanation,"Although the ensemble datatest.main/template now appears somewhat sim-ple, its 
 development underwent several improvement stages. The first improve-ment, from 
 the initial idea set out at the beginning of Section 17, consisted of a more advanced 
 type checking through test functions. One possibility which was initially analyzed was 
 to add an auxiliary table to these. However, some fields do not require more than a 
 type checking (such as some text labels or un-bounded numbers), and this is not 
 convenient. Finally, the tests were added to the template as
  control fields
  (three 
 initially, CONTAINS, VALUE and TEST).
  
 After the idea of control fields was ‘discovered’, others were included. STRICT is of 
 major usefulness: by means of this, errors in the field names are detected, since we 
 can enforce their uniqueness at a given level in the template. This control gave rise to 
 ALLSTRICT, which extended the same idea to all the sub-tables from a given depth.
  
 However, the user should sometimes not be forced to give data for all fields. This 
 was achieved by means of the control OPTIONAL. On other occasions, it is of interest 
 for the program to give some values for optional, not provided fields in data. This was 
 achieved using the control DEFAULT, which contains the default value.
  
 For the sake of brevity, the explanation of datatest.main, following Listing 2, is 
 simplified. The reader can explore the complete routine in the repository. The main 
 characteristic of the routine is that it is a wrapper, which hides some necessary 
 variables inside it, when treating the successive template levels.
  
 In the first lines, the function prepares two containers for possible error messages 
 and stores a pointer to the original table (to use it in default value assignment inside 
 the recursive function that follows).
  
 Then it defines the local function maintest, which actually does the work and calls 
 itself if necessary. As arguments, it has: a template (or sub-template) template, the 
 target table (or sub-table) data, a Boolean variable allstrict to indicate whether all 
 branches of the target table could have more fields than the template or not, and 
 finally the name of the field to process, field.
  
 After the definition of maintest, the first invocation of it appears, with nil for the 
 last two arguments. Finally, datatest.main returns with the appropriate messages if 
 an error is detected.
  
 We shall now describe the function maintest. At its beginning, some local 
 variables are defined from the information in the control fields of template (VALUE, 
 OPTIONAL, etc.). Also, a variable to store the error status of the execution and a label 
 for displaying purposes are prepared.",NA
How to use,"A driver for the above example is shown in Listing 3. Data processing is per-formed in 
 a protected environment, which allows assignments, calling functions from the 
 libraries math, string, table, and the ones defined in process (like box). This 
 methodology is known as ‘sandboxing’. The use of a protected environment is very 
 important in the present case: it avoids undue use of some dangerous functions (like 
 os.execute and os.remove) by the user.
  
 Employing this method, variables can be included in the data file for their use in some 
 parts of the data. For example, we can define a color:
  
 reddish = {r = 0.8, g = 0.4, b = 0.4}
  
 to be used subsequently, in a consistent way, in any place in which we need this color 
 by putting color = reddish. 
  
 If auxiliary variables are used, we also 
 recommend strict.lua to avoid problems with the variables used and not defined by 
 mistake.
  
 On the other hand, as the data file is a chunk of Lua, we can program inside it. We can 
 obtain some effects with loops and conditionals; for example:
  
 for k = 1, 10 do 
  
 w = k; h = 11-k 
  
 if k ~= 3 then box{width = w, height = h, <<other fields>>} end end",NA
Weaknesses and suggested improvements,"The main weakness of the proposed system is that the user might define a 
 substitution for the function box inside the data file, for example:
  
 local function box (b) <<some code>> end
  
 From this point on, our (correct) function box is no longer accessible inside the data 
 file. This problem is impossible to overcome because a local variable can always be 
 defined without limitations inside the data file
 1
 . However, this
  
 1
 In contrast, a global table can be defined read-only with a metatable; see PIL2, p. 127.",NA
Conclusions,"Sooner or later programmers using Lua are confronted with often complex data input, 
 which is frequently not under their control (because other people use the",NA
18 ,NA,NA
Lua Implementations of ,NA,NA
Common Data Structures,NA,NA
Matthew M. Burke,"In Lua, as with any programming language, one should learn the style and idioms that 
 best take advantage of the language’s features, rather than utilizing techniques from 
 other languages. Jung and Brown state “[b]ecause of tables’flexibility, you often don’t 
 need a customized data structure. Just ask yourself how you most often want to 
 access your data — usually an associative table or an array will do the job” [7, pg. 
 157].
  
 Lua provides a single built-in data structuring mechanism, the “table,” which 
 combines the functionality of (re-sizable) arrays and hashes. Any of the fun-damental 
 data structures and their associated algorithms can be implemented using Lua tables, 
 but it is not always clear how best to do so. After a brief discussion of how tables are 
 implemented in Lua, this article describes imple-mentations of several of the most 
 important and common data structures: lists, stacks and queues, trees, graphs, and 
 sets. Next, several specialized data struc-tures, including dictionaries and multisets, 
 are presented. Finally, a few tips are provided on how to structure data in 
 concordance with the spirit of Lua.
  
 Code examples
  
 Good Lua practice dictates that the functions associated with a data structure be 
 collected in a (meta)table associated with the data structure. Not only does this 
 reduce pollution of the global namespace, but it allows one to program in an object-
 oriented style.
  
 Copyright c
 ⃝
  2008 by Matthew M. Burke. Used by permission. 
  
 211",NA
Lua tables,"Lua tables function as a combination of (adjustable-size) arrays and associative 
 arrays depending on what kinds of values are used as keys. In this article, a Lua table 
 that has exclusively integral keys is referred to as an array, provided the table also 
 satisfies the condition that there are no gaps in the sequence of key values. Tables 
 that do not qualify as arrays will be referred to as
  mixed tables
 , or simply,
  tables
 .
  
 Lua table implementation
  
 The implementation of tables in Lua 5.x is described in [3]. Of course, the full details 
 are always available in the source code. The following is a brief exposition of the most 
 important points.
  
 Tables have a hash portion and an array portion, either (or both) of which can be 
 zero bytes in size. Both portions are resized as necessary. Whenever possible, items 
 with integer keys are stored in the array portion. This eliminates the need for 
 explicitly storing the key and thus reduces memory requirements. The hash portion 
 of tables is implemented using chained scatter table with Brent’s variation [3, pg. 18]. 
 This algorithm performs well even at 100 percent load.
  
 Assigning a value to an array index is typically considered to be O(1). But in the 
 case of Lua tables, this is correct only if one is not performing insertions and 
 deletions on the table. Insertions and deletions may cause the table to adjust the sizes 
 of its array and hash parts. When one of these re-sizings occurs, memory is allocated 
 and items are copied; this is not a constant-time operation. So, to be more precise, 
 access has an
  amortized
  cost of O(1).
  
 The fact that table access does not have a hard upper bound can be significant if 
 one has tight time constraints on individual actions. If it is assumed that a high 
 startup cost is acceptable, one could create a table and prefill it with a number of 
 entries whose values are some sentinel value.",NA
Lists,"There are two common ADTs for Lists. The first is the Array List
 2
 , whose ADT is 
 presented in Table 2. The second is the Node List with ADT in Table 3.
  
 get(i) 
  
 set(i, e) 
 add(i, e) 
 remove(i)
  
 Return the element of the list with index i 
  
 Replace with e and return the element at index i Insert 
 a new element e into the list to have index i Remove 
 the element at index i
  
 Table 2.
  Array List ADT.
  
 2
 which does not necessarily imply an array implementation.",NA
"Stacks, queues, and dequeues","Stacks, queues, and double-ended queues (dequeues) can be implemented quite 
 simply with the insert and remove functions from Lua’s standard table library. The 
 ADTs for these three data structures are presented in Tables 4, 5, and 6. As 
 mentioned before, if amortized costs are acceptable, one can rely on the automatic 
 resizing of tables to relieve the need to explicitly manage memory.
  
 push(e) 
 pop() 
  
 top()
  
 Insert element e as the new top of stack 
  
 Remove and return the top element of the stack 
  
 Return the top element of the stack without removing it
  
 Table 4.
  Stack ADT.
  
 enqueue(e) 
 dequeue() 
 front()
  
 Insert element e at the end of the queue 
  
 Remove and return the object at the front of the queue 
  
 Return the object at the front of the queue without removing it
  
 Table 5.
  Queue ADT.
  
 addFirst(e) 
 addLast(e) 
 getFirst() 
 getLast() 
  
 first() 
  
 last()
  
 Insert element e at the beginning of the dequeue 
  
 Insert element e at the end of the dequeue 
  
 Remove and return the object at the front of the dequeue 
  
 Remove and return the object at the end of the dequeue 
  
 Return the object at the front of the dequeue without removing it 
 Return the object at the end of the dequeue without removing it
  
 Table 6.
  Dequeue ADT.",NA
Trees,"The Tree ADT is presented in Table 7. In the case of binary trees, additional functions 
 are typically implemented. These are described in Table 8. Trees are typically 
 implemented in one of two fashions: either collections of linked nodes or arrays with 
 a protocol for making use of entries. Lua works well for both implementations. 
 Linked node implementations will be discussed first.
  
 root() 
  
 Return the tree’s root 
  
 addRoot(e) 
  
 Create a root node with value e 
  
 parent(v) 
  
 Return the parent of v 
  
 children(v) 
  
 Return a list containing the children of node v 
 insertChild(v, i, e) 
  
 Create a new node with value e and 
  
  
  
 insert it as the i-th child of node v 
  
 isInternal(v) 
  
 Test whether node v is internal 
  
 isExternal(v) 
  
 Test whether node v is external 
  
 isRoot(v) 
  
  
 Test whether node v is the root replace(v, e) 
  
 Replace with e and return the element stored at v 
 remove(v) 
  
 Remove the subtree rooted at node v
  
 Table 7.
  Tree ADT.",NA
Maps and dictionaries,"The Map ADT is presented in Table 9. Maps are usually defined so that each object 
 has a distinct key. Relaxing that assumption yields the Dictionary ADT, presented in 
 Table 10.
  
 get(k) 
  
 put(k, v) 
 remove(k) 
 keys() 
  
 values()
  
 Return the value with key k 
 Insert value v with key k 
  
 Remove the value with key k 
 Return a list of keys 
  
 Return a list of values
  
 Table 9.
  Map ADT.
  
 find(k) 
  
 findAll(k) 
  
 insert(k, v) 
 remove(k, v) 
 keys()
  
 Return a value with key k 
  
 Return a list of all values with key k 
 Insert value v with key k 
  
 Remove value v with key k 
  
 Return a list of keys
  
 Table 10.
  Dictionary ADT.
  
 Note that almost all of the Map ADT is already provided by Lua tables. Below are 
 implementations of the functions keys and values. One can implement the Dictionary 
 ADT by storing a table of values at each index in a Lua table. See the following 
 implementation for details.
  
 Dictionary = {} 
  
 Dictionary.__index = Dictionary
  
 function Dictionary:new() 
  
  
 local l = { __size = 0 } 
  
  
 return setmetatable(l, self) 
  
 end
  
 function Dictionary:find(k) 
  
  
 local matches = self[k] 
  
  
 if (matches == nil) then 
  
  
 return nil 
  
  
 else 
  
  
 local _, match = next(matches) 
  
  
 return match 
  
  
 end 
  
 end
  
 function Dictionary:findAll(k) 
  
  
 return self[k] 
  
 end",NA
Sets,"The mathematical definition of a set is a collection of distinct objects. In partic-ular, 
 sets do not allow for duplicates, and there is no notion of order amongst the elements. 
 In addition to functions that manipulate set elements, several binary operations are 
 defined on sets. The most common of these operations are union (members of the 
 new set are all objects that are members of either of the input sets), intersection 
 (whose members are only those objects that belong to both input sets), and 
 difference (all members of the first set that are not members of",NA
Graphs,"A graph is composed of a set of vertices and a set of edges which connect the vertices. 
 It is important to remember that a graph is a topological object rather than a 
 geometric one, i.e., it is the connections between vertices that is important, not the 
 precise picture used to illustrate a graph. Normally in a graph, if a node u is connected 
 to a node v, this implies that node v is connected to node u. In a directed graph, 
 however, it is possible for a node u to be connected to a node v while node v is not 
 connected to node u. A good analogy to help understand the difference between 
 directed and undirected graphs is to think of a road map. A directed graph is a 
 network of one-way streets, whereas an undirected graph is a network of two-way 
 roads. A graph, either directed or undirected, may have weights assigned to the 
 edges. Again, if one considers the road map analogy, weights would correspond to the 
 distances between cities.
  
 There are two common representations of graphs: the adjacency matrix and the 
 vertex list. Adjacency matrices are simple but waste space in the cases of non-directed 
 graphs and sparse graphs. When using Lua tables, however, adjacency matrices, even 
 for sparse graphs, are memory efficient. Therefore, the vertex list representation of 
 graphs is not discussed in this article.",NA
Text processing,"Most books on data structures contain a chapter discussing text processing, 
 particularly pattern matching and compression. This article does not cover these 
 topics, but the interested reader is directed to read the documentation for Lua’s 
 string library [4]
 3
 , Reuben Thomas and Shmuel Zeigerman’s rex library [13], and 
 Roberto Ierusalimschy’s LPEG library [6].",NA
Augmented data structures,"In many circumstances, an operation on a data structure can be made more efficient 
 by including additional information. This technique is known as using augmented 
 data structures. For example, threaded trees use additional pointers so that it is 
 possible to find the pre-order successor to a given node in O(1) time.
  
 A particularly elegant example of an augmented data structure is the use of an 
 augmented binary search tree to enable determination of k-th order statistics in O(log 
 n) time. An implementation based on the discussion in [11] follows.
  
 require ’NTree’
  
 OrderTree = {} 
  
 OrderTree.__index = OrderTree
  
 function OrderTree:new() 
  
  
 local l = { } 
  
  
 l.tree = NTree:new() 
  
  
 return setmetatable(l, self) 
  
 end
  
 3
 and, of course, refer to the source code.",NA
Homogeneous data structures,"In Lua, values are typed, but variables are not. In other words, a particular variable, 
 say my variable, may refer to a string at one point during a program’s execution, a 
 table at a later point, and, perhaps, a number later on. Thus, the data structures 
 discussed here are all heterogeneous, i.e., they can simultane-ously store values of 
 different types.
  
 Often, however, it is necessary to restrict a data structure to values of a particular 
 type. For example, suppose one is collecting a list of expenses with the intent of 
 calculating an average expense. If a non-numeric value is inadvertently inserted, the 
 result would either be an erroneous result or a run-time error.",NA
Working with Lua,"To paraphrase an anonymous saying, “any programmer can write a C program in 
 Lua.” For the most part, the data structures presented here were developed in 
 response to the constraints of languages such as C and Fortran. In some 
 circumstances, these data structures can be the best choice in Lua programs. 
 Whenever possible, however, it is preferable to develop data structures that take 
 advantage of the strengths of Lua. A few heuristics to aid one in this task follow.
  
 1. Take advantage of table resizing.
  
 2. Consider using values as keys (such as in the Set implementation).
  
 3. Remember that objects of any type can be table keys (except nil).
  
 4. Make use of both the array portion and hash portion of a table.",NA
Resources,"There are a number of resources available to Lua programmers to aid in the design of 
 data structures. These include both existing libraries and reference",NA
References,"[1] Chisano, Paul. Sano Library. http://luaforge.net/projects/sano/.
  
 [2] Goodrich, Michael T. and Roberto Tamassia. Data Structures and Algo-
  
 rithms 
 in Java. 4
 th
 Ed. John Wiley and Sons, 2006.
  
 [3] Ierusalimschy, Roberto, de Figueiredo, Luiz H. and Waldemar Celes. “The 
 implementation of Lua 5.0,” Journal of Universal Computer Science, Vol. 11, No. 
 7, 2005.
  
 [4] Ierusalimschy, Roberto, de Figueiredo, Luiz H. and Waldemar Celes. Lua 
  
 5.1 
 Reference Manual, Lua.org. 2006.
  
 [5] Ierusalimschy, Roberto. Programming in Lua. 2
 nd
 Ed. 1006.
  
 [6] Ierusalimschy, Roberto. lpeg. http://luaforge.net/projects/lpeg/.
  
 [7] Jung, Kurt and Aaron Brown. Beginning Lua Programming. Wiley, Indi-
  
 anapolis, IN, 2007.
  
 [8] Knuth, Donald. “Structured Programming with go to Statements,” ACM 
  
 Computing Surveys, Vol 6, No. 4, Dec. 1974.
  
 [9] Lua Community. Lua Users’ Wiki. http://www.lua-users.org/wiki.
  
 [10] Lua Community. lua-l. http://www.lua.org/lua-l.html.
  
 [11] Ottmann,
  
 Thomas.
  
 http://electures.informatik.uni-freiburg.de/
  
 catalog/chapter.do?courseId=advancedAD2005&chapter=9
  
 [12] Thomas, Reuben. stdlib. http://luaforge.net/projects/stdlib/.
  
 [13] Thomas, Reuben and Shmuel Zeigerman. lrexlib. http://luaforge.net/ 
  
 projects/lrexlib/.",NA
19,NA,NA
Tic-Tac-Toe and ,NA,NA
the Minimax Decision ,NA,NA
Algorithm,NA,NA
Rafael Moreira ,NA,NA
Savelli and Roberto de Beauclair ,NA,NA
Seixas,"We present a way to implement the minimax algorithm from scratch in Lua. First, we 
 start with some game-playing concepts. Then, we explain how could tables handle 
 with required data structures specifications such as trees and nodes, and present a 
 Lua implementation of the minimax algorithm, showing how those tables are 
 manipulated. Its performance is evaluated based on the worst case execution time 
 defined by the game-playing concepts. In addition, in order to confirm the given 
 approach, we also implemented the well-known tic-tac-toe and checkers games as 
 case studies. At the end practical results are commented proving that, like many other 
 languages, Lua can easily handle this sort of adaptive search problems.",NA
Introduction,"Humans started to play games a long time ago and just after the firsts civiliza-tions 
 have existed. The main purpose of them were basically for entertainment. Since then, 
 more and more games have been created so that future generations still spend their 
 time with game playing.
  
 Copyright c
 ⃝
  2008 by Rafael Savelli and Roberto de Beauclair Seixas. Used by permission. 
  
 239",NA
Search problems,"In order to solve search problems we build a tree that is superimposed over the 
 problem space and find a solution by searching node-after-node until reaching the 
 desired goal node. However, in some cases, building such tree is not an easy task. 
 Even a simple problem can generate a huge amount of data and, in this case, the 
 resulting tree becomes intractable even when submitted to modern computers. This 
 can be observed by looking at Table 1 which shows a hypothetical computer times 
 and memories usage for a given number of tree depth.
  
 Even with this exponential growth, the most common difficulties related to 
 problem solving is finding a good strategy for searching among those trees. This is 
 almost always the majority of work in the area of search problems. The strategy can 
 be classified in term of four different criteria as presented on following:
  
 Completeness.
  Is the strategy guaranteed to find a solution if one exists?
  
 Time Complexity.
  How long does it take to find a solution?
  
 Space Complexity.
  How much memory does it need to perform that search?
  
 Optimality.
  Does the strategy find the highest-quality solution when there are several 
 different solutions?",NA
Games,"An important consideration when designing games is to treat them as search 
 problems. However, the presence of an opponent makes the decision problem",NA
The minimax algorithm,"Having defined the main game concepts and its data structure, we are now ready to 
 understand the essence of minimax algorithm. The minimax algorithm is designed to 
 determine the optimal strategy for one player at a time informing the best move for 
 that player. The entire algorithm consists of four steps:
  
 1. Generate the whole game tree, all the way down to the terminal states.
  
 2. Evaluate the utility function to each terminal state to get its value.",NA
Case study,"Up to this point, we have been using the tic-tac-toe game in our explanations. In fact, 
 this game was chosen to be our case study for several reasons. First, it is a well-
 known and popular game with dismiss any rules explanations. Second, other games 
 like checkers (also known as draughts) and chess are much more
  
 complex than tic-tac-toe.
  
 For instance, tic-tac-toe has a maximal branching
  
 factor of 9 while in chess the average is about 35. 
  
 Moreover, tic-tac-toe has
  
 exactly 623530 nodes in its search tree but chess can easily achieve 35
 100
 .",NA
Conclusions,"The first conclusion is that implementing the minimax strategy in Lua is an easy task. 
 The Lua combine tables facility to form matrices speeds up users implementation 
 skills keeping the source code simple and clear. The memory manipulation 
 abstraction also contributes to make Lua an easy programming language.
  
 Another important Lua approach consists in collecting any memory garbage with 
 frees programmers from this responsibilities.
  
 Yet Lua is a powerful programming language and also provides extensions.
  
 One future work could be implementing other games concepts such as alpha-beta 
 pruning. 
  
 Alpha-beta pruning is a technique where a large amount of nodes are 
 securely removed from search tree and for this reason they are not processed. 
 Avoiding unnecessary processing means increasing the computer answer velocity.",NA
References,"[1] J. D. Funge.
  Artificial Intelligence for Computer Games
 . Peters Corp., 2004.
  
 [2] R. Ierusalimschy.
  Programming in Lua
 . Lua.org, 2006.
  
 [3] S. Russel and P. Norvig.
  
 Artificial Intelligence:
  
 A Modern Approach
 .
  
 Prentice-Hall, 1995.",NA
Part IV ,NA,NA
Game ,NA,NA
Programming,NA,NA
20,NA,NA
Using Lua ,NA,NA
in Game and Tool ,NA,NA
Creation,NA,NA
Konstantin Sokharev and Vadim Groznov,"Nowadays, when development costs are skyrocketing, selection of tools and 
 instruments for creating and designing your game is of utter importance. This article 
 discusses the use of Lua as a language for writing game and its game play, and as a 
 platform for the creation of a game editor. Writing high quality code is impossible 
 without a good convenient IDE. In this article we discuss struggle for higher 
 performance and lower memory consumption, and issues of readability that arise 
 when the volume of Lua code grows significantly.",NA
Programmable access via Lua,"Our earliest architectural solutions used Lua to script events in game missions, 
 allowing designers to realise a lot of ideas and make missions sufficiently di-verse. 
 Usage of Lua also allows to differentiate tasks between scripters and programmers 
 (in spite of scripter being a programmer too — but a programmer of less complex 
 constructions), which is extremely useful from the production process viewpoint 
 (Listing 1).
  
 Actually, this approach allowed quick prototyping and production of missions (of 
 an RTS/Action game in production at that time). Later, we researched Lua’s 
 capabilities further and understood that usage of such architectural features as
  
 Copyright c
 ⃝
  2008 by Konstantin Sokharev and Vadim Groznov. Used by permission. 
  
 249",NA
IDE (debugger),"Soon we understood that, with all the convenience and flexibility of Lua, at large 
 volume of code (over 10 Lua files at several thousand lines each) means of debugging 
 are lacking, so we decided to write full-featured Lua script debugger. Such a debugger 
 was written and built into the game. 
  
 It has a convenient IDE with game files 
 navigation tree, search, multitabs, syntax highlighting, and all the functionality for 
 debugging: breakpoints, step in, step out, edit 
  
 It significantly 
 simplified and sped up and continue, watches, expressions.
  
 development, because earlier we had to debug code by logging.
  
 It is worthy of note that for text representation we used Scintilla middleware, 
 while Lua middleware has all the functionality for the creation of a good debug-ger 
 (i.e., we didn’t have to change anything in Lua source code), so the creation of a 
 debugger took only one man-month.",NA
Excessive flexibility of Lua,"Despite seeming simplicity and beauty of code, Lua conceals some dangers. A sudden 
 problem arose — excessive flexibility of Lua. For example, access to any member of 
 any object at any place in the script (as an example) is a straight way to “hacks” — 
 often forgetting to write “local” inside a function you create a global. A conclusion that 
 can be made — strict coding standards are a must, i.e.:
  
 • All structural definitions must
  always
  have the same format (Lua allows 
  
 to do 
 one thing by several means). 
  
 For example, function declaration: 
  
 function Running() or Running = function() — you must choose most con-
  
 venient.
  
 • Names of different entities must be created by one mnemonic rule — or 
  
 the 
 code will become very difficult to understand. For example, signal 
  
 enumerator: 
 SGN_USE1, SGN_CAMERA_ROTATE, SGN_MOVE.
  
 • Despite Lua being a type-less language, type shall be pointed in variable name. 
 For example, vPos (Vector), fRadius (float), blsCovered (boolean).
  
 To conclude this topic, good advice: frequently make a code review to solidify 
 structures (we advise to include it into the weekly development cycle).",NA
Performance issues,"One of the most important questions with script language usage is “Will it be fast 
 enough?”. We conducted preliminary synthetic tests and found that perfor-mance 
 was sufficient even with several hundred units operating simultaneously in game. In 
 reality, it turned out to be slower — in massive combats with many game entities 
 (30–60 fighting units on-screen), the game began to lag signifi-cantly. An important 
 conclusion was made: game designers’ vision of battles in game and other scripted 
 events happening simultaneously on the map must be taken into account beforehand. 
 Then most critical (performance-wise) stuff must be exposed and it should be 
 decided whether to keep it in C++ or transfer it to Lua. Regrettably, we made this too 
 late, so we had to fix these problems dur-ing production. We decided to integrate a 
 Lua profiler (from the Kelper project), which did its job well and showed up 
 bottlenecks, and did it in runtime, with-out stopping game in needed game situations, 
 which is very important. That way we found out that significant amount of processing 
 time was consumed by Lua-to-C++ data transfer (we will elaborate on that later), and 
 next function used for looking through table elements. A conclusion can be made: 
 thoroughly plan structure of data that you will store in script (use massives 
 extensively and tables where you really need them.) Remember that performance 
 impact when looking through larger number of elements is significantly heavier in 
 Lua then in C++. Also, there is sense in using custom containers, exported from C++, 
 with faster look through elements.",NA
Lua–C++ data transferring,"One of the important moments in integration of C/C++ code and Lua is data transfer 
 and class exporting. For this we first used a proxy class that made Lua and C++ 
 integration less solid and allowed usage of another scripting language, but profiling 
 showed that significant memory overhead and excessive calls happened. Our latest 
 solution is based totally on #defines and works directly with Lua stack. See Listing 4. 
 You can see pseudo-C++ code where we have bindings macros part, example Obj class 
 method (GetAnimations) and so called “exportmap” below separated by comments.",NA
Lua and .NET,"Our second case of Lua usage was as a script language for creation of tools in a game 
 editor. It was decided to use .NET platform because of its capabilities",NA
Conclusion,"Our experience showed that utilization of Lua as a convenient database and a means 
 for rapid creation of game entities is quite possible, provided you have a convenient 
 IDE for debugging and navigation of code.
  
 Well thought-out architecture of Lua allowed for good integration with .NET and 
 usage of Lua as a tool for creating plug-ins for a game editor.
  
 When using Lua, one should consider memory consumption, execution speed and 
 “excessive” flexibility of Lua code — overlooking these peculiarities you may hinder 
 all your efforts to improve your system.",NA
21 ,NA,NA
Leveraging Lua and C++ to ,NA,NA
Create a Dynamic and Flexible ,NA,NA
Event System for Script-,NA,NA
Driven Games,NA,NA
Robert Oates,"Lua boasts several features that make it an attractive option for use in event-driven 
 applications such as video games. 
  
 These programs are made much 
 easier to program through judicious application of the
  subscriber
  pattern, and can be 
 given a lot of runtime flexibility through the
  strategy
  pattern. In this article I will 
 explain what these patterns are, how they are beneficial to game development, and 
 finally how we can implement and optimize these patterns easily with Lua.",NA
The subscriber,"The subscriber pattern is absolutely integral to event-driven programming. Ob-jects 
 will
  subscribe
  to events through an
  event manager
 , and the event manager notifies the 
 subscribers when the event occurs. There is a lot of room for creative implementation 
 with this pattern, so let’s step back a moment and consider the requirements we have 
 for our application and see if that helps narrow down the possibilities.
  
 Copyright c
 ⃝
  2008 by Robert Oates. Used by permission. 
  
 259",NA
Strategy,"I mentioned earlier that one of the great things about Lua is that its functions are 
 first-class. This language feature immensely facilitates the
  strategy
  design pattern. 
 The strategy pattern creates differences between objects at runtime by changing their 
 function references. We can leverage the event manager we created above as a way to 
 implement strategy in our application by specifying different callbacks for different 
 objects (as in the very first code example), but we can also override functions directly 
 when it suits us. Consider the code below:
  
 function Fly()
  
  
 --Do stuff 
  
 end
  
 function Walk()
  
  
 --Do Stuff 
  
 end
  
 local enemy1 = 
  
 local enemy2 =
  
 ThisLevel:NewActor(""BlobMonster"") 
 ThisLevel:NewActor(""BlobMonster"")
  
 enemy1.MoveFunc = Fly 
  
 enemy2.MoveFunc = Walk
  
 Now if we have a list of similar enemies we can simply iterate through it and call 
 MoveFunc for each one. This is similar to inheritance, with the exception that you can 
 actually alter the behavior during runtime.",NA
Extra credit,"Serialization of this event data is very straightforward, and even allows us to leverage 
 our existing event system for sending network messages. Consider the following 
 example:
  
 local MyChatWindow = GUI:NewWindow(""ChatWindow"") 
  
 MyChatWindow:Subscribe(""OnNetChatMessage"", NetChatMsgFunc)
  
 Where will the “OnNetChatMessage” event be generated? From the other com-puter 
 we’re connected to, of course! What we need to do to make this work is cre-ate a 
 method for remote systems to tell our event manager to broadcast the On-
 NetChatMessage event — with proper data and all. This gets a little involved, but it’s 
 definitely worth it. This section was written with winsock and C++ in mind, but the 
 theory should apply to any network API you can use through Lua.
  
 The remote system wants to send an event to our system. The data will need to be 
 serialized into a stream of bytes by the remote system, sent across the network, and 
 then deserialized into a meaningful event on our system. How should we approach 
 this given that we do not predefine event templates? With a little trickery, of course! 
 We will give events a predictable header that tells the receiver how to decode them 
 on the fly. So what sort of information do we need to send so the receiver can decode 
 our byte string?
  
 • We should send the length of the serialized data as the first integer.
  
 • We will need to store the name string of the event.
  
 –
  All strings will require an integer prefix to describe their length.
  
 • We need to define the event table data.
  
 –
  We should consider adding a “sender” member to the table with our IP 
 address or a connection ID, so the receiver knows who sent this message.
  
 –
  For all tables we need to specify the table size, along with each ele-
  
 ment’s type.
  
 –
  We need to differentiate between (string) keyed tables and array- type 
  
 tables.",NA
Closing,"Hopefully the simple examples I have provided are adequate to illustrate the power 
 and flexibility of these patterns. When combined with Lua’s advanced features 
 (closures, first-class functions) they can be used to build a solid founda-tion for any 
 script-driven game.",NA
22 ,NA,NA
Lua for Game ,NA,NA
Programming,NA,NA
Steve Gargolinski,"The goal of this article is to describe a breadth of ways that Lua can be used to 
 supplement a traditional (C++) game engine. The three areas that we will take a look 
 at specifically are data representation, adding an extensible structure for providing 
 dynamic in-game challenges to the player, and supplementing our game world with 
 Lua-driven artificial intelligence.
  
 When video games were young, all pieces of a typical game were coded directly 
 into the engine. Maps, sprites, the user interface, game logic, and AI were all 
 represented in assembly code or C, and later C++. This approach was cumbersome 
 and inflexible, requiring a build step in between changing any sort of game data and 
 being able to view it in the game. Before long, the concept of separating the game 
 engine from its external components became possible. Maps are now created by 
 editors as external files, Non-Player Character (NPC) dialogue is stored in a text file 
 rather than C++ code, and sprites are stored as textures. It is no longer necessary to 
 perform a costly build step after changing one line of NPC dialogue.
  
 After moving game assets out of the engine and into data, the next step is to create 
 a separation between our engine code and game logic, which can be achieved by 
 exposing select areas of the game engine to a scripting language such as Lua. This 
 separation allows programmers to define clean interfaces between select areas of the 
 game and the chosen scripting solution. Also, less technically proficient designers can 
 work at a higher level and tinker with game systems without needing to write actual 
 C++ code, compile, or fully understand the engine. Much of the game experience can 
 be tweaked and tuned without requiring the game to be rebuilt or even restarted.
  
 Copyright c
 ⃝
  2008 by Steve Gargolinski. Used by permission. 
  
 269",NA
Example game,"To clearly illustrate the goals of this article, we will refer to a sample game. Hopefully 
 you all remember the classic game Adventure (or Zork). The frame-work game we 
 are going to use is a very simple version of these “text adven-tures”.
  
 In this sample game there is a World made up of Locations. Locations are 
 connected to each other in a sparse graph. There are Items in this World which can 
 either be at a Location or in the possession of an Actor who can be either the Player 
 or an NPC. Actors are able to pick up items, drop them, and move between connected 
 Locations in the World. It is as simple as that.
  
 Note that this article assumes an existing C++/Lua binding solution. 
  
 A 
 description of the different available techniques is beyond the scope of this article, 
 but Celes et al.
 1
 provide a solid discussion.",NA
Data representation,"Games use huge amounts of data. 
  
 In a typical game there are models, ani-
 mations, maps, entities, and sounds, each with its own data format. Figuring out the 
 best way to represent this data is an involved decision with many im-plication details 
 including: platform-specific issues, memory limitations, and designer/artist workflow 
 patterns.
  
 Lua can be used to efficiently and flexibly handle loading designer-defined data. 
 Assume that in the realm of our example game, designers are in charge of creating 
 each Location in the World. The code in Listing 1 describes a way to load in two 
 Locations by defining them as a Lua table.
  
 LoadAllLocations is responsible for building up a locationTable and pass-ing it 
 along to LoadLocationsFromTable where the information is extracted and used to 
 add Locations to the World through a minimal number of exposed C++
  
 1
 W. Celes, L. H. de Figueiredo, and R. Ierusalimschy, “Binding C/C++ Objects to Lua”,
  Game Programming 
 Gems 6
 , Charles River Media: pp. 351–355, 2006.",NA
Dynamic challenges,"The goal of this section is to add a mechanism to present the player with chal-lenges 
 — focused, mix-in situations with risk/reward structures to drive and con-trol the 
 overall flow of the game. We will be creating a simple example challenge called 
 “Water The Forest”, in which the player must bring the “Water Jug” Item to the 
 “Forest” Location in the World. This is a very simple challenge based on our example 
 game, but the mechanism is powerful and can be applied to many different types of 
 games. The idea here is that high-level control of the chal-lenges (initialization, 
 updating, etc.) is handled in the game engine, but the content is completely controlled 
 through Lua scripts. Each challenge is defined in terms of a single Lua file. For the 
 purposes of this article we will keep things very simple — Lua file only needs to 
 implement four functions: EvaluatePre-Reqs(), Update(), Success(), and Failure(). 
 EvaluatePreReqs() is responsible for controlling when a particular challenge is given 
 out. This function returns a boolean value indicating true whenever the pre-
 requisites for this challenge are met, and false otherwise. We will use the results of 
 EvaluatePreReqs() when deciding which challenge to present to the player. Here is 
 some simple example (engine level) pseudocode for using EvaluatePreReqs() to 
 choose a valid chal-lenge based on the current game state:
  
 Array<Challenges> validChallenges; 
  
 for i = 1; i < allChallenges.size(); ++i 
  
 { 
  
 if (allChallenges[i]->TriggerEvaluatePreReqs() == true) 
  
  
 validChallenges.push(allChallenges[i]); 
  
 } 
  
 activeChallenge = validChallenges[RandInt(0, validChallenges.size)];
  
 This piece of code will loop through all of our challenges, building up an array of the 
 ones which pass our EvaluatePreReqs() test. We then set our active challenge to a 
 random entry in this array. Something important to note here is how the 
 allChallenges array gets filled in. Since each of our challenges is contained within a 
 Lua file, we can simply iterate on all the .lua files in a specified challenges directory, 
 adding each one to the allChallenges array. This discovery mechanism is a very useful 
 property since it does not require a list of challenges to be stored anywhere. Adding a 
 new challenge only requires the addition of a new file. If we decide to release an 
 expansion pack, downloadable content, or some combination of the two, there is no 
 need to coordinate an index file of challenges between these permutations. 
  
 Each 
 expansion pack simply needs to drop a few files in the challenges directory. After the 
 engine has chosen an active challenge, the next responsibility of the engine is to 
 trigger an update",NA
AI and state machines,"AI programmers have long used Finite State Machines (FSMs) in all (ok, most) of your 
 favorite games to successfully create the appearance of enemy/opponent intelligence. 
 There are a number of ways to implement an FSM structure with Lua. It can be done 
 completely in Lua code (and for certain situations this might make sense), but for this 
 example we’re going to stick with the pattern of supplementing a traditional FSM 
 structure with Lua instead of moving over the entire implementation. This gives us 
 the power to set breakpoints and monitor variables in C++ while retaining the 
 flexibility of Lua.
  
 It can make a lot of sense to expose your FSM functionality to a script-ing solution 
 such as Lua. 
  
 This choice carries with it a lot of familiar bene-
 fits/drawbacks of exposing a game system to scripts. A data-driven AI solution can 
 provide some serious power. With script-controlled game agents, it is quick and easy 
 to make widespread changes. New AI logic can be quickly tested and iterated on. After 
 exposing the necessary sections of the AI system to Lua, it is possible to hand off the 
 state machine implementation to designers — allowing them complete control over 
 the characters in game with no C++ knowledge re-quired. However, with this amount 
 of power comes the natural ability to screw",NA
Generic Lua function exposure,"A powerful and simple use of Lua in a game engine is to expose arbitrary Lua script 
 execution at run time via your game’s command console or debug tools. All that you 
 need to do is give the development team access to something as basic as: runluascript 
 file.lua function.
  
 This simple addition will be beneficial for everyone on the development team 
 from programmers to artists to designers to QA. The ability to quickly, easily, and 
 repeatedly run a set of actions contained in a script has advantages on many different 
 levels. Designers can force situations they want to mess around with",NA
Conclusion,"Hopefully this article has given you some ideas on how to supplement your game 
 engine by exposing key areas to a Lua scripting solution.
  
 The techniques discussed here barely scratch the surface of potential uses of Lua 
 for game programming. Before you delve in, analyze the problems that your 
 particular game is trying to solve and identify areas which lend themselves well to a 
 data-driven, scripted solution.",NA
23 ,NA,NA
Designing an Efficient Lua ,NA,NA
Driven Game Scripting ,NA,NA
Engine,NA,NA
Nicolas Peri,"When designing a modern game engine, able to handle hundreds of 
 “intelligent”objects with various complex behaviors, you need to deal with two major 
 issues: runtime speed and ease of development. Using traditional C/C++ 
 programming to define your objects behaviors implies recompiling your game code 
 each time you make a modification in order to test it, which is a big time wasting. On 
 the other hand, using a script driven game code will offer you a huge gain of 
 development time, allowing you to perform “in game programming”, but a bad 
 integration can quickly result in poor runtime performance. The ease of use and the 
 execution speed of Lua are not to prove anymore. 
  
 However, 
 a well-done integration is not an easy thing to do, if you do not understand exactly 
 how Lua works and how to use it efficiently. This article explains how to take 
 advantage of Lua to design a powerful and flexible game engine with autonomous 
 object behaviors, using scripted event handlers, and how to avoid the common 
 performance pitfalls.",NA
The problem — motivation and statement,"We can consider a game as a collection of scenes, also known as levels. Each scene 
 represents an area in the universe, containing objects like flowers, trees, birds, and so 
 on. Many objects do not need to have an artificial life, like flowers or dead trees, but 
 some must have particular dynamic behavior, like birds flying
  
 Copyright c
 ⃝
  2008 by Nicolas Peri. Used by permission. 
  
 281",NA
The solution — description,"Use an object local solution
  
 Every “intelligent” object in the scene must have its own behavior. We will call an 
 AIModel the data structure defining an object’s behavior: it can be compared to a C++ 
 or Java class, with the main difference that all the code is written in Lua. An AIModel 
 basically contains member variables and functions. Each instance of an AIModel has 
 his own set of member variables, with or without initial values, allowing every 
 instance to be independent and quite different from others. Each object will have one 
 or more AIModel instances controlling it. For example, an object representing a 
 soldier could have an AIModel dedicated to the path finding and another one to the 
 attack.
  
 Use frame-by-frame execution
  
 Ideally, autonomous behaviors should be done by using one thread for each AIModel 
 instance. For performance reasons, this is just impossible in a game engine. The 
 execution of each AIModel instance must thus be designed frame by frame, with the 
 aim to emulate multithreading: each AIModel must for example implement a 
 runOneFrame function, written in Lua, that will be in charge to step for each frame 
 the desired behavior. In pseudo code, the engine loop would basically be:
  
 while ( gameIsRunning ) 
  
 do 
  
 for each Object o in the Scene 
  
 do 
  
  
 for each AIModel instance ai controlling o 
  
 do 
  
   
 ai.runOneFrame ( ) 
  
  
 done 
  
 done 
  
 scene.draw ( ) 
  
 done
  
 Member variables are used to maintain the state of an AIModel instance, frame to 
 frame. Nothing remains at the end of the frame but those.",NA
Explanation and justification,"Taken one by one, each of the recommendations done just before can look neg-ligible, 
 but if all are respected, the speed improvements will make it possible to use Lua as a 
 runtime language for fast applications such as games. Indeed, we passed from a naive 
 solution to an optimized one by reducing Lua runtime intrinsics, scripts execution, 
 C/C++ communication and the number of calls.",NA
Weaknesses and suggested improvements,"Even with all of that, the same work done with C/C++ compiled behaviors will always 
 be faster. 
  
 A solution would be to allow Lua code to be translated to C/C+ 
 code then compiled, at product releasing time, scripting being used just for 
 development time. If you follow the recommendations written in this gem, and 
 strictly use nothing but Lua simple types and loops, this should be a quite easy thing.",NA
Conclusion,"Making a well done integration of Lua in your game engine finally implies two major 
 things: finding a way to execute only the scripts that are really needed (but every 
 engine should already do that for all other sub systems like animation or dynamics, so 
 doing it for AI should not be a big deal), and reducing the overheads of Lua execution 
 by avoiding time consuming operations and providing high level dedicated function 
 packages. Lua scripted behaviors would also be useful for remote programming and 
 debugging: it is possible to change the behavior of one object in a game running on a 
 game console, by simply uploading a string containing the new script, which will 
 automatically be taken in account at the next frame.",NA
Part V ,NA,NA
Embedding and Extending,NA,NA
24 ,NA,NA
Enhanced Coroutines in ,NA,NA
Lua,NA,NA
Patrick Rapin,"This article describes a method to increase the power of coroutines by using 
 preemptive native threads together with standard collaborative Lua threads. This 
 way coroutines are able to perform blocking operations, like reading data from a 
 opened pipe, without freezing all the other coroutines. 
  
 This is done 
 by having a dynamic pool of preemptive threads executing commands on the 
 background, while the associated coroutine is suspended from the Lua point of view.",NA
History,"Our company, Olivetti, is active in the ink-jet printer industry. We have always 
 written specific programs in order to drive our printers for testing and produc-tion. 
 The most recent one is a very powerful tool, called LuaDura, based on Lua 5.1. This 
 program can send low level commands to the printer, through a dedicated 
 communication channel. The protocol used here is similar to the Mass Storage Class 
 of USB: the host sends a binary command, optionally followed by data; the printer 
 always sends back a status, along with additional response data. Several 
 communication channels can be used for this task: USB, serial port, Ethernet. Other 
 ones may be added in the future, like Bluetooth or WiFi.
  
 We wanted to be able to drive several printers simultaneously within a single Lua 
 script, for example in a mass production test board. The problem is that all 
 input/output commands through the preceding channels are blocking: it is therefore 
 difficult to drive several printers in a single thread. This is why we need some form of 
 true multithreading for our application.
  
 Copyright c
 ⃝
  2008 by Patrick Rapin. Used by permission. 
  
 291",NA
Multithreading models,"In the book “Programming in Lua” (second edition), Roberto Ierusalimschy explains 
 in chapter 30 that Lua supports two models for multithreading. The third model is 
 the one we will describe.
  
 Lua collaborative threads with memory sharing
  
 In the first model, there is only one Lua state, but several coroutines running 
 sequentially inside it, by explicit yielding and resuming. As they run in the same state, 
 all these threads can access the global variables and the registry, so it is easy to share 
 data between them. 
  
 However, the operating system has 
 no knowledge about this mechanism. If one collaborative thread performs a blocking 
 I/O operation, all other coroutines are stopped during that time. Consequently, this 
 model does not fit our requirement. An option could be to use asynchronous 
 input/output, as they are available on most operating systems. Unfortunately, this has 
 several drawbacks: it is hard to implement, not portable across platforms, and not all 
 operations can be done that way.
  
 Preemptive threads in separate Lua states, sharing no memory
  
 In the second model, several Lua states are created, each running in a different native 
 preemptive thread. Because there is no connection between separate Lua threads, C 
 code must be added in order to share data between the interpreters. This could be a 
 solution for our application: we could imagine a C function, taking as parameter a 
 function to execute, that would create a preemptive thread, which in turn would 
 create a new Lua state and run the function
  
 until it exits.
  
 A blocking command only stops that specific thread.
  
 While
  
 possible, we don’t like this option, as it would be hard for the main script to monitor 
 the simultaneous processes without heavy intervention of C code and OS semaphores.
  
 Preemptive threads associated with coroutines
  
 The third model is essentially an enhanced version of the first one. There is only one 
 Lua state, and several coroutines running inside it. 
  
 Therefore the threads can easily 
 share data between them. 
  
 The key trick is to enable a 
 native preemptive thread to executes the input/output commands instead a Lua 
 coroutine. It works like this: the coroutine calls a C function when it has to perform a 
 blocking operation. That function checks if there is an idle native thread from the 
 pool, or instantiates a new one. It then sends a message to it, and yields. Lua 
 interpreter will switch to another coroutine, while the command really starts 
 executing in the background. To prevent memory corruption, the native thread has no 
 access to the Lua state: all its input arguments, output results and error messages 
 must be passed through the message structure.",NA
Implementation,"The annexed file thread.c implements this third solution for multithreading. It is 
 partly based on the source code of LuaDura, but with all references to printer 
 communication removed. Instead, it exports some simple tasks, which are widely 
 available and used. 
  
 The implementation is aimed to be both an 
 example program and a startup file in which you can add features for your 
 application.
  
 The code supports both Windows and POSIX preemptive threads. To mini-mize 
 the number of compilation switches, the following POSIX functions are im-plemented 
 under Windows using native objects: sem init, sem post, sem wait, sem destroy, 
 pthread create, and pthread cancel. With a simple similar in-terface, it should be 
 possible to run the example on other operating systems as well.
  
 The implementation does not need any change in Lua 5.1 sources. 
  
 Like 
 all standard Lua libraries, this code only uses the official API. And like Lua itself, it is 
 written in clean C, thus should compile unmodified in both C and C++ languages.
  
 A pool of C threads is maintained in the form of four lists, all initially empty. When 
 a coroutine ask for a blocking operation, we look at the idle list of threads and take 
 one from that list. If the list is empty, a new native thread is allocated and initialized. 
 A table placed in Lua registry is used to keep track of which coroutine is using which 
 C thread at any time.
  
 Like with the coroutines, there is no need to explicitly close the threads. They will 
 be collected like any other objects. If you are low in system resources, you can force a 
 garbage collection by calling collectgarbage explicitly. For this purpose, a second 
 table is present in the registry. Each time a thread is taken from the pool to execute a 
 command, a userdatum is created and placed in the table. When the thread becomes 
 idle again, the table entry is set back to nil.
  
 Because this userdatum is bound to a metatable of which the
  
 gc method is
  
 overridden, the unused operating system resources can be freed when a garbage 
 collection occurs.
  
 The module exports one global thread table with a few functions. Four user 
 functions are exported into that thread table. They were chosen because they are 
 blocking functions, are simple and are available on most platforms. They only pretend 
 to be examples for user needs, although they may be useful as is.
  
 • thread.sleep(milliseconds): a delay function, implemented with Sleep 
  
 on 
 Windows and usleep on Unix.
  
 • thread.system(command): calls the ANSI system function, which in turn 
  
 starts a command interpreter: sh on Unix, cmd.exe on Windows NT.",NA
Coding,"Now let’s take a closer look into the C implementation. Each C thread has a state 
 variable associated with it for the synchronization mechanism. The four states used 
 by the state machine are as follows:
  
 • IDLE: Lua can send a command to the native thread.
  
 • REQUEST: A command has been sent, execution can start. Lua coroutine 
  
 yields.
  
 • WORKING: A command is in execution in native thread. Lua coroutine also 
  
 yields.
  
 • FINISHED: A command has finished execution, Lua can read back results.
  
 There are four double linked lists of threads, one for each state. Each time a 
 thread state changes, its item is removed from one list and placed into the next one. A 
 shared semaphore assures that operations on these list cannot be interrupted by 
 other threads. Also to avoid any real time problem, Lua is only allowed to exchange 
 data with the thread during IDLE state for the command, and during FINISHED state 
 for the output read back.
  
 An important helper function is retrieve thread data. Given the Lua corou-tine 
 represented by the current lua State parameter, it returns a pointer to a C thread 
 structure. Four situations can occur:
  
 • If called from the main Lua thread (lua pushthread returned 1), simply 
  
 returns nil.
  
 • If a command is already started for the coroutine, uses the mapping table 
  
 to 
 return the associated thread.
  
 • If the list of idle threads is not empty, returns its first element.
  
 • Otherwise, allocates a new structure and fills it with a C thread and two 
  
 semaphores. The mapping table is updated accordingly.",NA
Example of Lua code,"Scheduler
  
 Besides the C implementation of this thread library, let’s have a look of some Lua 
 code using it. First, we need some form of scheduler function, which is a sort of 
 operating system replacement. The simplest form of the scheduler is this one:
  
 function thread.sched(threads) 
  
  
 while next(threads) do 
  
   
 local thr = thread.wait() 
  
   
 if not thr then thr = next(threads) end 
   
 if 
 not coroutine.resume(thr, thread) then 
  
  
 threads[thr] = nil 
  
   
 end 
  
  
 end 
  
 end
  
 The argument is a table of coroutine objects. Repeatedly, while there are still active 
 threads, it waits for the first thread that has finished a blocking com-mand. It tries to 
 resume it, passing the global table thread as argument to coroutine.resume, so that 
 the loop of previous listing knows that it had yielded.",NA
Complete example,"The web site contains a more complete example for running simple user scripts. All 
 four user functions previously discussed are run in parallel. You may notice that they 
 do not to worry about the underlying multithreading; the scheduler function with the 
 help of the thread.wait function takes care about all low-level synchronization 
 management.",NA
25,NA,NA
Using Lua in Pascal,NA,NA
Jeremy Darling,NA,NA
Why Lua?,"In the world of Pascal development there are plenty of native solutions for scripting 
 an application. 
  
 Most of these are built with the Pascal language itself 
 and this only leads to limiting the user base for the scripting language in question. 
 Utilizing a well known and commonly used scripting language within our applications 
 only helps to expand our user base in the end.
  
 There are other common scripting languages out there (JavaScript, Monkey, and 
 VBA to name a few), but as of the time of this writing, Lua is the most robust and 
 supported scripting language available. Due to the nature of how it is built, Lua allows 
 for great flexibility within an application and it incorporates into Pascal applications 
 seamlessly.",NA
The basic needs,"Before we start talking about how to use Lua within an application, we need to 
 discuss what is needed to get Lua on your system and use it within your projects.
  
 First, you will need a copy of the Lua interpreter, you can download that from 
 lua.org easily enough. You will also need a copy of the Pascal headers for Lua: I 
 personally recommend the version on my website called pLua. You can get it at 
 http://www.eonclash.com/ just look under “Projects/Pascal Wrappers”. Make sure 
 you download the latest version of pLua and not the Generic Pascal
  
 Copyright c
 ⃝
  2008 by Jeremy Darling. Used by permission. 
  
 301",NA
The problem,"In order to provide the best walkthrough of integrating Lua into a Pascal appli-cation 
 as possible, I’ll present an application that would benefit well from Lua integration. 
 The application is a game of sorts where the user is up against the HAL 9000 and 
 must convince it to release control of the ship.
  
 To keep with the ubiquitous first project (“Hello World”), our first implemen-tation 
 will load whatever script is passed in and execute it.
  
 Project foundations (setting up the project)
  
 The same process will be true for all projects here on out, so it will only be covered 
 here once. Setting up a new project to use Lua within Lazarus requires that the 
 compiler know where the libraries are and where to output the final application. (The 
 same is true for Delphi, Kylix, or FPC.) 
  
 Open Lazarus and click on Project/New Project, click Program, then Create. You 
 should be presented with a blank project and the basics of a console appli-cation. 
 Now, click on Project/Compiler Options, select the Paths tab, and enter in the 
 appropriate location (where you extracted the Lua wrappers to) into the“Other Unit 
 Files (-Fu)” and “Other Sources (.pp/.pas, used only by IDE not com-piler)” edit boxes: 
  
 [pic] 
  
 Click Ok to close the dialog. Then do a Save All.
  
 This sets up the Lazarus environment so that it knows where our Lua source files 
 are located (Other Sources edit box). The Other Unit Files edit box tells it where to 
 find the Lua libraries when it compiles our source.
  
 Next change the uses section to include the proper units that you will need access 
 to (if you want to make sure that all units are available and compliable then include 
 lua, LuaWrapper, LuaObject, Cutils, and LuaUtils).
  
 Perform a build to test everything (Ctrl+F9) and you should get a message stating 
 “Project
  name
  successfully built”.
  
 Defining HAL 9000
  
 Before we can actually build anything we need to define exactly what we are going to 
 build. As it’s outside the scope of this document to explain project design and 
 documentation, here is a basic idea showing what HAL 9000 will do:",NA
Read and writing variables,"Having a scripting language integrated into your application is more than just loading 
 a script and executing it. 
  
 It is having the ability to read and write 
 variables, objects, records, and other information to and from the script itself, thus 
 allowing you to change the way that your application reacts or interacts with the user.
  
 The next logical step in getting Lua integrated into your application is to setup 
 global variables that can be modified and read inside the Lua script and inside your 
 application. With this little bit of knowledge you could easily use Lua as a 
 configuration storage device that will give you more flexibility than say .ini or registry 
 files.
  
 If you have read up on Lua outside of this article (and I hope you have), then you 
 know that Lua works on a stack and uses different global spaces to store information. 
 One of these spaces is LUA_GLOBALSINDEX, which is a table that is used to store 
 global name/value pairs to be accessed by the current script.
  
 Writing
  
 To modify or create a new global value we need to do three things: first, we have to 
 push the name or index associated with our value; second. we have to push the value 
 itself onto the stack; finally, we have to tell Lua to set the value in the global table:
  
 Lua_pushliteral(L, ’MyIdentifier’); 
  
 Lua_pushstring(L, ’Some Value’); 
  
 Lua_settable(L, LUA_GLOBALSINDEX);
  
 As you can see in the code above (lua_pushstring), there are methods to read and 
 write each variable type that we use (at least until we start using the variant type 
 wrappers presented within the pLua unit). This should be nothing new if you have 
 stored or retrieved information from a standard .ini or registry object.
  
 We place our identifier onto the stack first with a call to lua_pushliteral; this could 
 also be done with a call to any of the lua_push* methods. Lua uses a hash table 
 lookup, so any type (except nil) can be used as a key within a Lua",NA
More on methods,"Once we can read and write global variables, the next logical step is to move up to 
 surfacing methods (procedures and functions) from our Pascal environment to our 
 Lua environment. We will also need a way to call Lua methods (functions) from 
 within our Pascal source code. We touched lightly on this before, but this time we will 
 be looking at the specific needs of methods inside and out.
  
 Differences between Lua and Pascal
  
 One of the first things to keep note of is the difference between return values and 
 arguments. In Pascal we can mark a method argument as a var arg, or input/output 
 variable, out arg, and we can pass back a single value from any",NA
Using records and objects,"Within Lua there is no object type defined. Yet, it would be very difficult to think of 
 integrating a scripting language into an application without the ability",NA
Back to the registry,"In order for Lua to make use of Pascal objects we will need to make sure that Lua 
 does not garbage collect its part of the object. The object will also need to retain a 
 pointer back into Lua so that it can retrieve method pointers, variable values, and 
 anything else that we choose to allow Lua to control.
  
 This is where the Lua registry comes in. When we create a new object (either from 
 a Lua script or from our application), we will need a way to let Lua know about it and 
 let Lua know that we are managing it. The registry is the best place (note that’s best 
 and not only place) to do this.
  
 Upon our objects instantiation we will need to request a registry entry. To do this, we 
 will use the pLuaObjects unit and a few calls to luaL_* methods.
  
 We also need a way to remove our reference when the object is destroyed so that Lua 
 can garbage collect its part of the equation.
  
 Hopefully the comments within the source will give good presence as to what is 
 going on, but if they don’t then please use your favorite search engine to learn more 
 about the Lua registry and garbage collection.",NA
Object properties,"Lua tables have built-in meta-methods to allow developers to modify their de-fault 
 behavior. We will use this to our advantage to implement variables (read and write 
 for the case of this document; read only or write only should be easy to figure out) 
 and methods. For variables we will need to override the default __index and 
 __newindex table entries to call our own getters and setters.",NA
Object methods,"Methods are a bit trickier. We will need to tell Lua that the method exists and what 
 class type the methods are tied to. We will then need to write a method handler that 
 prepares the proper arguments and then passes them to the object instances actual 
 method. We will need to check for results and out parameters and put them back on 
 the Lua stack. The latter part is the same as when we covered methods above, the 
 former is explained in the source code.",NA
And the object,"From everything above we can finally implement objects into our application and 
 have them extended by Lua scripts with events, methods, and properties. H9K shows 
 exactly how all of this comes together and allows you to create and extend Pascal 
 objects from within Lua itself.
  
 Records
  
 While I know that I said if we supported objects that records would fall in 
 automatically, but there is one caveat to records. You must use record pointers 
 instead of actual record types. This is due to the way that records are passed and 
 assigned within Pascal. If you assign an object instance to an object variable, the 
 variable contains a pointer to the object instance. On the other hand, if you assign a 
 record to a record variable then the entire contents of the record are copied over to 
 the variable. If you can keep this in mind and use record 
  
 First, you will 
 pointers in all locations, then you will actually gain twofold.
  
 guarantee that your records will work properly, and second, you will notice that your 
 application uses less memory.",NA
Calling within a loop,"There is a special case when it comes to Lua. That is calling a Lua script or method 
 from within a loop. If you have jumped ahead and attempted to do this",NA
Final words,"Everything that has been covered in this article has been wrapped up into a nice little 
 package for you to work with. The files LuaWrapper.pas, pLuaObjects.pas, and 
 LuaObject.pas have helper classes, functions, and base classes for you to extend and 
 use. They have been built from experience and have quite a bit of testing going on 
 with them all of the time. As with all libraries though, you should read and 
 understand them as the author(s) are not responsible for any damage to your system.",NA
26,NA,NA
Porting Lua to a Microcontroller,NA,NA
Ralph Hempel,"The Lua language was designed from the beginning to be small in its memory 
 footprint for both the developer and the target machine. The basic philosophy is to 
 provide a concise and unambiguous syntax that the developer can use and depend 
 upon.
  
 The purpose of this gem is to outline some of the issues that come up when 
 porting Lua to an extremely memory constrained target. I’ll go over a basic in-
 troduction to the target, which is the LEGO MINDSTORMS NXT brick, talk a bit about 
 how the run-time library is designed, and then introduce my compro-mise between 
 32-bit long integers and single-precision floating-point numbers, which I call “flongs”.",NA
The target processor – why use Lua to program LEGO?,"I have been fascinated by little languages ever since I started programming 
 embedded systems over 20 years ago. At the time, Forth was one of the few languages 
 that could be ported to a microcontroller and provide a mechanism for compiling and 
 interpreting right on the target hardware.
  
 In late 1997, the original LEGO MINDSTORMS RCX system was released. It had an 
 H8/300 microcontroller with 32K of OTP memory containing the basic firmware and 
 about 32K of external RAM for applications. Again, at the time
  
 Copyright c
 ⃝
  2008 by Ralph Hempel. Used by permission. 
  
 313",NA
Think before you get started,"The porting project did not have any immediate urgency, which gave me lots of time 
 to think about it before I ever got started. It also gave me time to read about Lua, poke 
 around in the Lua mailing list archive, and write a few non-trivial programs in Lua. I 
 was able to take the time to browse the Lua source at leisure, noting how the 
 different layers were isolated into separate files, and generally getting the lay of the 
 land.
  
 Basically, I’m lazy. This forces me to work smart to get as much done as 
   
 The 
 weeks I spent getting the feel of the Lua somebody that works hard.
  
 code convinced me that any time I spent fiddling with the source code would be 
 completely wasted. Eventually I had absorbed enough to put down these guidelines 
 to get me started:
  
 1. Use as much of the stock Lua source distribution as possible.
  
 2. Only load the base, table, and string libraries initially.
  
 3. Add target specific routines in their own library.
  
 Being lazy has also made me dependent on make, which I use in all kinds of 
 projects to make sure that I have to think and type as little as possible once I’ve 
 figured out how to get a job done.
  
 I have a standard framework that I set up for any embedded systems project, 
 which I won’t describe in detail here but is available in the pbLua distribution. In 
 general terms, it starts with a directory that has the processor specific startup",NA
Building a better run-time library,"After building and linking a minimal Lua system, you’re left with a lot of undefined 
 symbols which are generally part of the run-time library (RTL). This is something 
 that systems developers don’t think too much about because the libraries are often 
 part of the operating system distribution.
  
 Embedded systems developers have a couple of choices in the matter. The first is 
 to use the RTL that ships with your development system. In most cases this is fine, 
 but sometimes it’s a good idea to start from first principles and build your own RTL.
  
 In the case of GNU gcc, the standard embedded RTL is newlib. It’s a fine library 
 that gets a lot of use, but for this project I felt it was a bit bloated especially in the IO 
 section.
  
 One reason to build your own RTL is that it can follow you around to other 
 projects, and you’ll have a better appreciation of some of the tradeoffs that different 
 implementations will give you. This is especially true in the standard IO library.
  
 Building your own RTL is not as hard as you might think if you break the job down 
 into smaller pieces and are careful in choosing the base code for each part. Being lazy 
 comes in handy again if you take the time to scour the web for libraries that are 
 already written and tested. Look for code that’s written to be portable and runs on a 
 variety of hardware. If you’re concerned about licensing, look for code with an MIT 
 style license (like Lua) or maybe a BSD license (like FreeBSD). These give you the 
 most flexibility in using the code but they do not require you to publish the changes 
 or improvements you might make.
  
 Thread-safe considerations
  
 One of the buzzwords you’ll hear in a discussion on embedded libraries is “thread-safe” 
 or “re-entrant”. In multi-tasking systems it is quite common for a routine called by a 
 task to be interrupted at any time for a task switch. The new task may call the original 
 routine as well. If the routine is thread safe, it won’t get confused and return incorrect 
 results to either task.
  
 One of the first steps towards becoming thread safe is to not use global variables. 
 As long as a routine allocates all of its variables on the calling task’s stack, then 
 chances are the routine is thread safe.
  
 The ANSI C library
  
 The ANSI C library is a set of basic routines that are used by almost every program 
 you are likely to write, so it’s a good idea to get the most complete one you can find.
  
 The first and most obvious set of routines to get into the library are the string 
 routines. These are often written in assembler, but modern compilers do such a good 
 job of optimizing them that it’s often more trouble than it’s worth to do it",NA
A new kind of math using “flongs”,"The standard Lua programming language is compiled to use double-precision 
 floating-point math, which makes sense on a standard desktop or server class 
 computer. Double-precision math has the advantage of being able to represent the 
 full range of 32-bit integers exactly in addition to a very large dynamic range with 
 about 14 digits of accuracy.
  
 For small embedded systems, and certainly for the LEGO MINDSTORM NXT, 
 double-precision math comes with a penalty. The ARM processor inside the NXT 
 handles 32-bit integers very efficiently, but must do a lot of extra work to do floating-
 point calculations.
  
 Fortunately, the designers of Lua thought about the speed-versus-precision tradeoff 
 at a very fundamental level and came up with a clever macro based scheme to 
 decouple the implementation of the arithmetic operations from the language. What 
 this means for some applications is that we can specify the underlying numerical type 
 for all of Lua’s arithmetic operations. 
  
 (Note that 
 there is a distinction between arithmetic operations that are intrinsic operations like 
 + and * in the Lua language, and the math operations such as sqrt and sin that are part 
 of the math library.) The actual implementation is a section in luaconf.h that tells the 
 compiler how you’d like to handle the numbers and was discussed in the section on 
 adding the Lua kernel to the build system.
  
 One part that I did not mention was that the Lua arithmetic operations were 
 based on standard C operators and are defined as macros in luaconf.h In other words, 
 the basic operators — addition, multiplication, modulo, etc. — all result in standard C 
 expressions, and depending on the underlying type of the macro parameters, the 
 compiler chooses either fixed or floating-point math.
 1
  
 Trading speed for accuracy
  
 In the process of thinking about how best to take advantage of the processor in the 
 NXT, I decided to make long the default arithmetic type for Lua. Most of the routines 
 in the NXT firmware source use long parameters. This includes timers, rotation 
 counters, and many other fundamental structures. If we had to convert between float 
 to long all the time we’d be wasting all kinds of CPU cycles in the process.
  
 If doubles are too onerous, then what not use a single-precision float? The 
 standard single-precision float has one disadvantage, and that’s a significantly 
 reduced range of precision when it comes to fixed-point numbers, and for that
  
 1
 As an aside, one of the things I like to do when I’m evaluating a new programming language is to read 
 and try to understand how it’s implemented underneath. The first language I learned (besides assembler 
 and C) was Forth. It had a wonderful structure that made it obvious how it worked. When I saw the Lua 
 source code, I knew I was looking at something that had evolved over time and had some deep thought 
 behind it. It looks obvious when you read the code that this is the “right way” but based on my experience, 
 there were probably a few failed attempts before this. . . From the high level parser to the virtual machine, 
 and the API that handles the interaction between C or assembler libraries and Lua itself, the Lua core is 
 beautifully organized and a model of good code. I have much greater confidence that code is correct if it 
 looks like it was carefully crafted.",NA
Conclusion,"Building a complete Lua interpreter under Linux, BSD, OSX, or even Windows is 
 relatively simple when you use the makefiles provided with the source code. Building 
 Lua for use on a microcontroller with no underlying OS support re-quires more 
 careful consideration of tradeoffs between speed, size, and accuracy.
  
 Embedding Lua on a constrained micro forces the programmer to think hard about 
 many things that are taken for granted on a desktop system. 
  
 From 
 math to memory, strings to stdio, almost everything is under the control of the 
 designer, and knowing what the tradeoffs are can help you to make better decisions.
  
 In the future, this project may take advantage of other work being done in the Lua 
 world, including keeping some table information in non-volatile memory,",NA
27 ,NA,NA
Writing C/C++ Modules for ,NA,NA
Lua,NA,NA
Ralph Steggink and Wim Couwenberg,"We use Lua mostly as an embedded scripting environment in our software. Over the 
 years we have developed many C and C++ libraries that integrate tightly with Lua 
 code. Since one of us started to use Lua 4.0, a lot has changed in the newer releases of 
 Lua. The changes that have impacted our way of binding C/C++ code the most are the 
 introduction of metatables, environments, and a standard module system.
  
 Even with the now default module system there are still lots of ways that modules 
 can be written, both in Lua and in C. The module system is carefully designed to 
 support different approaches to modules on different target plat-forms. It uses 
 loaders to extend or modify the way in which modules are found and activated [1]. 
 There really is no preferred way, by design, to write modules.
  
 This gem presents our approach to writing C/C++ modules for Lua. It was adapted 
 and tweaked over the last couple of years based on experience in several of our 
 projects. 
  
 We illustrate our method by wrapping an essential portion 
  
  
  
 From its of the well known “libevent” library written by Niels 
 Provos [2].
  
 documentation: “Libevent is an event notification library [. . . ]. The libevent API 
 provides a mechanism to execute a callback function when a specific event occurs on 
 a file descriptor or after a timeout has been reached.”",NA
Generic module layout,"Compared to our approach in the Lua 4.0 days, one change that stands out in 
 particular is the shift in focus from C code to Lua code in the implementation
  
 Copyright c
 ⃝
  2008 by Ralph Steggink and Wim Couwenberg. Used by permission. 
  
 325",NA
Objects,"Mostly a library’s API is structured in an object-oriented way. This is obvious for C++ 
 interfaces but is equally true for many C interfaces. 
  
 For example, 
 libevent really introduces an “event” object of which the event_set function is a 
 constructor and the event_add function (among others) is a method. This object-
 oriented approach is really convenient from a scripting point of view, so we will want 
 to structure the event module’s interface in terms of objects.
  
 An object is modeled as a combination of a Lua table and a full userdata. The 
 userdata part represents an object from the C library while the Lua table is used to 
 store additional information with this object. For libevent we reserve space for an 
 event structure in a userdata. A Lua table is used to store the callback function for an 
 event. The Lua table can be set as the environment of the userdata to make it easily 
 obtainable from the userdata. Also, the userdata can be put in the Lua table (by 
 assigning it to some “private” field __udata say), so that the userdata can be accessed 
 from Lua.
  
 The possibility to set an environment table for a userdata was introduced in Lua 
 5.1 and is a great help to associate Lua data with userdata. In Lua 5.0 we could only 
 do this by maintaining a userdata-to-table mapping. Such a mapping can still be 
 necessary for some other purposes even in Lua 5.1, as we will see in the libevent 
 example, where we use it to retrieve a Lua object from a pointer-to-void callback 
 argument.
  
 When writing a module primarily in Lua we are confronted with the follow-ing 
 restrictions of environments and metatables:
  
 1. A userdata’s metatable cannot be set in a Lua script.
  
 2. A userdata’s environment cannot be set or obtained in a lua script.
  
 Restriction 1 means that the module’s C code must have access to the metat-able 
 to construct a userdata object since it cannot be set by the Lua script later on. In our 
 libevent example we put all metatables in the aux table (the environ-ment of all C API 
 functions) exactly for this reason.
  
 Restriction 2 hinders the implementation of object methods in the following 
 sense. We could simply implement an object as a userdata with a metatable and an 
 environment to store associated data. In this case, each method receives a userdata 
 instance as their first self parameter. If object methods are written in Lua (which we 
 aim for), then a method cannot get at the environment ta-ble of self — an 
 inconvenient situation. Even though we could work our way around this 
 inconvenience (via a getenv function in the module’s prv table), we implement 
 objects differently.",NA
Boxing and packing,"Objects from C/C++ can be put into a userdata in several ways. 
  
 Common practices are 
 to “box” or “pack” objects into userdata. 
  
 Boxing an object in 
 userdata means that only a pointer to the object is stored in the userdata. A NULL 
 pointer can then be used to indicate that the object is no longer valid (e.g., it is 
 explicitly discarded or got garbage collected). Lua’s io library boxes a file pointer 
 (FILE*) into a userdata and uses the NULL pointer to indicate that the file is closed.
  
 Packing an object in userdata means that the storage space for the object is 
 directly allocated in the userdata itself. Depending on the object type that is packed, 
 you might need to reserve some extra space for a field that indicates the object’s 
 validity, much like the NULL pointer does for boxed objects. In our libevent example 
 we chose to pack the event object instead of boxing it. Note that even a C++ class 
 instance with a non-trivial constructor and destructor can be packed by using the 
 placement operator new and an explicit destructor call. The example in Listing 1 
 shows how to properly pack an instance of class type T.
  
 (This example omits a “validity” flag.) 
  
 Note that Lua’s garbage collector will free the actual space that was reserved for a 
 userdata. Do not delete a packed object since the object is not allocated by operator 
 new (the runtime library will most likely assert if you try).",NA
Packing modules into a single library,"During development of C modules for Lua it is practical to put each module in its own 
 library. When deploying final code we find it convenient to distribute only a single 
 library containing all needed C modules. It took us some time to realize that Lua 5.1 
 offers such a facility out of the box via what is called the “all-in-one loader”. Requiring 
 ”distro.C-Event” will eventually try to locate a library called distro.so (or distro.dll) 
 containing a function named luaopen_Event. Multiple modules can be contained in 
 the single library distro.so in this way.
  
 Moreover, providing a separate library distro/C-Event.so in a distro sub-directory 
 will override module “C-Event” in distro.so since require will locate",NA
A libevent module,"Finally, we present some of the techniques that we discussed to make a Lua module 
 for the libevent library. 
  
 The code below is fully functional but still 
 intended as an example. Only a very small part of libevent’s API is included, but 
 enough to see that it is actually working. 
  
 Of course, there is room for lots 
 of improvements and variations. Function and method parameters could be checked 
 for preconditions and error return codes translated into something more sensible. 
 However, what this example aims to show is that such things are really easy to add 
 simply in the module’s Lua script.
  
 First, a small example that uses the Event module to echo stdin with a timeout of 5 
 seconds:",NA
References,"[1] Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes,
  
 “Lua 5.1 Reference Manual”, Lua.org, 2006.
  
 [2] Niels Provos, “libevent – an event notification library”.
  
 http://www.monkey.org/
 ∼
 provos/libevent
  
 [3] Roberto Ierusalimschy, “Technical Note 7 – Modules & Packages”.
  
 http://www.lua.org/notes/ltn007.html",NA
28,NA,NA
Interpreted C Modules,NA,NA
J´erˆome Vuarand,"Lua 5.1 provides a flexible and powerful module mechanism. It can load two types of 
 modules: Lua modules, which are written in Lua, and binary modules, which are 
 written in any compilable language that can produce shared libraries. Through this 
 mechanism it is possible extend Lua in many ways, making it a truly extensible 
 language, for use as a general scripting tool.
  
 However in certain circumstances these two extension mechanisms may not be 
 enough. Hopefully, the Lua module mechanism has been carefully written and is itself 
 extensible thanks to a searcher concept. The stock Lua interpreter comes with a few 
 searchers that implement the Lua 5.1 module system. But it is possible to create 
 additional searchers that will inject code inside the Lua interpreter state in whatever 
 way may be needed.
  
 In this article I will introduce a method to extend the Lua module mechanism to 
 other kinds of modules. As an example, I will show how to support modules written 
 in uncompiled C, with the help of a tiny embeddable C compiler, TCC (for Tiny C 
 Compiler). This mechanism will allow us to load uncompiled C modules, and to 
 compile them on the fly. I will first explain how the searcher mechanism of Lua works 
 in detail, and how to hook into it. I will present TCC, and especially libtcc, which is a 
 library that is able to compile C code and relocate it in the current executable for 
 immediate use. We will finally see how to create a small binding library for TCC that 
 injects its C compilation ability in the Lua module framework.
  
 Copyright c
 ⃝
  2008 by J´erˆome Vuarand. Used by permission. 
  
 337",NA
The Lua module system,"The Lua module system is based on two global functions, require and module. Both 
 use the package table to store information concerning already loaded mod-ules and 
 how to load additional modules. The basic usage of the module system consists in 
 loading Lua files or shared libraries to expose a table containing func-tions to the 
 script being executed. But these functions are much more powerful than that. require 
 has been designed with flexibility in mind, and its behaviour can be totally 
 configured. While module sticks closely to the module system and in fact defines it, 
 require is just a wrapper around a searcher concept, and what exactly a searcher 
 does is not limited. require existed before the Lua 5.1 mod-ule system was 
 introduced, and it has been carefully redesigned to keep its old behaviour while 
 allowing module to do its job.",NA
"require, searchers, and loaders","require defines a protocol to locate and execute external code. require is called with a 
 single parameter, which usually represents the module name (
 modname
 ). For the 
 moment try to consider a module as an abstract concept; it may be any form of 
 external code that can be executed. Actually, loading a module means executing the 
 module loader. For Lua modules the loader is the module main chunk. For binary 
 modules the loader is a function named luaopen_
 modname
 . For other types of 
 modules it’s up to the searcher designer to determine what the loader is.
  
 require will first look in package.loaded to see if the module is already loaded. 
  
 This 
 allows modules to control whether they can be loaded twice or not. If a module loader 
 sets package.loaded[
 modname
 ] to a value resolving to true, the module won’t be re-
 loadable. If it sets that entry to false or nil, the module can reloaded. Manually 
 resetting that value allows to force a module reloading next time it is require’d.
  
 If require determines that it must load the module, it will look for the module loader 
 and execute it. To find a loader, require uses searchers. Searchers are located in the 
 package.loaders array: they are functions. 
  
 require will call 
 each searcher, starting at index 1, with the module name as only parameter. A 
 searcher can have three possible behaviours. If it doesn’t find the module, it returns a 
 string that will be displayed by require if no searcher finds the module. If it finds the 
 module without any problem, it returns the module loader (a function). Finally, if the 
 searcher finds the module but is not able to extract its loader, it can throw an error. 
 This is the case for example when a Lua module contains syntax errors. This error will 
 propagate outside require.
  
 If require has found a loader, it executes it with the module name as sin-gle 
 parameter, in an unprotected call. That way, if the loaders throws an er-ror it is 
 propagated outside of require, for example when a Lua module con-tains a runtime 
 error. 
 The 
 first 
 return 
 value 
 of 
 the 
 module 
 loader 
 is 
 stored 
 in 
 package.loaded[
 modname
 ]. If the module loader returns no value and has not",NA
TCC,"Tiny C Compiler
  
 TCC is a C compiler targeted for x86 platforms written by Fabrice Bellard (of ffmpeg 
 and QEMU fame). It is very small and very fast. It is so fast that it is used as a JIT 
 compiler to interpret C programs, and that’s precisely the feature we’ll be using in 
 this gem. Originally TCC was derived from OTCC, which is aimed to be the smallest 
 self-compiling C compiler. OTCC was not capable of compiling full C99, only a subset 
 of it, but that subset was C99 compliant and enough to build itself. TCC has kept that 
 minimalistic approach while being much more usable in a production environment.
  
 TCC is heading toward full ISO C99 compliance. It does have some exten-sions, but 
 not as numerous as GCC’s. It has almost no support for older versions of C not 
 covered by C99. Also it has no support for C++, so C++ programmers used to GCC 
 extensions must take care to program strictly in C. But past these little restrictions, 
 TCC can compile most C code without any problem and very quickly (for example it 
 can boot a typical Linux 2.4 from sources in less than 15 seconds on an average PC).
  
 libtcc
  
 TCC can be used as a standalone compiler, but it is internally built around a compiling 
 library, libtcc. That library can be used from external projects, to compile and link C 
 code. But libtcc is also able to relocate dynamically generated code into memory, and 
 to return pointers to functions and other symbols in that",NA
TCC binding,"The TCC binding I’m going to expose here was originally based on the one written by 
 Javier Guerra. 
  
 It has been widely rewritten and extended to be used 
 as a Lua searcher. This binding is split in two parts. The first part, the luatcc module 
 presented in this section, is a simple binding to libtcc and allows to compile and 
 execute C code. The second part, the luatcc.loader module, is a module searcher that 
 locates C source files and compiles them as Lua modules.
  
 The TCC binding is articulated around a context or state concept. A context is like 
 an instance of the compiler. It has its own paths, you can add several source files, 
 declare several libraries, and it can produce a single output binary. However, you can 
 access several symbols in that binary. To create a context, just call the luatcc.new 
 function. The module source code is not of much interest:",NA
TCC searcher,"The TCC searcher is very simple.
  
 It mimics Lua and C searchers.
  
 We will
  
 examine its source code and comment each section.
  
 The module header
  
 module(..., package.seeall) 
  
 local luatcc = require(""luatcc"") 
  
 local function new_context() 
  
  
 local context = luatcc.new()
  
  
 --context:add_include_path(""some/path/to/header/files"")
  
 --
 context:add_library_path(""some/path/to/library/files"") 
  
 return 
 context 
  
 end 
  
 local DIRSEP = ’/’
  
 We first declare the searcher module itself, with the name provided by require. We 
 then require luatcc as a dependency, since we will use it to compile the inter-preted C 
 module. The new_context function is used to create a luatcc context. It exists 
 primarily to ease addition of searcher-wide compilation parameters, such as standard 
 include paths or library paths. DIRSEP is the directory separator. You may have to 
 modify it to fit your OS.",NA
Conclusion,"The main purpose of this gem was to show you how easy it is to add a completely new 
 kind of module to Lua. With only a few tens of lines, you can convert an existing 
 binding to some other form of programming into a module searcher. My example, 
 which is able to load uncompiled C modules, is just an example. With the same 
 principle, you could load Java classes or their .NET equivalents. You could access 
 some web services, just by loading some interface definition file. You could load 
 modules from Python, TCL, or Ruby.
  
 With There is also another field of development for more Lua searchers.
  
 new module searchers, you could simply change the way the searcher locates the 
 code. 
  
 Instead of loading the modules from some directory according to 
 package.path, you could look for the modules online, either in some company-
  
 specific intranet or in the wild internet.
  
 You could load the modules from a",NA
