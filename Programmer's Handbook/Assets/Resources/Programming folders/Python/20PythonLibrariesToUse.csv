Larger Text,Smaller Text,Symbol
Caleb Hattingh,NA,NA
20 Python Libraries You,NA,NA
Aren’t Using (But Should),"Boston
 Farnham
 Sebastopol
 Tokyo
 Beijing
 Boston
 Farnham
 Sebastopol
 Tokyo
 Beijing",NA
Table of Contents,"1.
 Expanding Your Python Knowledge: Lesser-Known Libraries. . . . . . .  1
 The Standard Library                                                                          2
 In the Wild                                                                                          15
 Easier Python Packaging with flit                                                    16
 Command-Line Applications                                                          19
 Graphical User Interfaces                                                                 26
 System Tools                                                                                       34
 Web APIs with hug                                                                            41
 Dates and Times                                                                                 46
 General-Purpose Libraries                                                               53
 Conclusion                                                                                          66
 v",NA
CHAPTER 1,NA,NA
Expanding Your,NA,NA
Python Knowledge:,NA,NA
Lesser-Known Libraries,"The Python ecosystem is vast and far-reaching in both scope and
 depth. Starting out in this crazy, open-source forest is daunting, and
 even with years of experience, it still requires continual effort to
 keep up-to-date with the best libraries and techniques.
 In this report we take a look at some of the lesser-known Python
 libraries and tools. Python itself already includes a huge number of
 high-quality libraries; collectively these are called the 
 standard
 library
 . The standard library receives a lot of attention, but there are
 still some libraries within it that should be better known. We will
 start out by discussing several, extremely useful tools in the standard
 library that you may not know about.
 We’re also going to discuss several exciting, lesser-known libraries
 from the third-party ecosystem. Many high-quality third-party
 libraries are already well-known, including Numpy and Scipy,
 Django, Flask, and Requests; you can easily learn more about these
 libraries by searching for information online. Rather than focusing
 on those standouts, this report is instead going to focus on several
 interesting libraries that are growing in popularity.
 Let’s start by taking a look at the standard library.
 1",NA
The Standard Library,"The libraries that tend to get all the attention are the ones heavily
 used for operating-system interaction, like 
 sys
 , 
 os
 , 
 shutil
 , and to a
 slightly lesser extent, 
 glob
 . This is understandable because most
 Python applications deal with input processing; however, the Python
 standard library is very rich and includes a bunch of additional
 functionality that many Python programmers take too long to dis‐
 cover. In this chapter we will mention a few libraries that every
 Python programmer should know very well.",NA
collections 1,"First up we have the 
 collections
  module. If you’ve been working
 with Python for any length of time, it is very likely that you have
 made use of the this module; however, the batteries contained
 within are so important that we’ll go over them anyway, 
 just in case
 .
 collections.OrderedDict
 collections.OrderedDict
  gives you a 
 dict
  that will preserve the
 order in which items are added to it; note that this is 
 not
  the same as
 a sorted order.
 The need for an 
 ordered
  
 dict
  comes up surprisingly often. A com‐
 mon example is processing lines in a file where the lines (or some‐
 thing within them) maps to other data. A mapping is the right
 solution, and you often need to produce results in the same order in
 which the input data appeared. Here is a simple example of how the
 ordering changes with a normal 
 dict
 :
 >>>
  
 dict
 (
 zip
 (
 ascii_lowercase
 , 
 range
 (
 4
 )))
 {
 'a'
 : 
 0
 , 
 'b'
 : 
 1
 , 
 'c'
 : 
 2
 , 
 'd'
 : 
 3
 }
 >>>
  
 dict
 (
 zip
 (
 ascii_lowercase
 , 
 range
 (
 5
 )))
 {
 'a'
 : 
 0
 , 
 'b'
 : 
 1
 , 
 'c'
 : 
 2
 , 
 'd'
 : 
 3
 , 
 'e'
 : 
 4
 }
 >>>
  
 dict
 (
 zip
 (
 ascii_lowercase
 , 
 range
 (
 6
 )))
 {
 'a'
 : 
 0
 , 
 'b'
 : 
 1
 , 
 'c'
 : 
 2
 , 
 'd'
 : 
 3
 , 
 'f'
 : 
 5
 , 
 'e'
 : 
 4
 } 
 2 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
contextlib,"A context manager is what you use with the 
 with
  statement. A very
 common idiom in Python for working with file data demonstrates
 the context manager:
 with
  
 open
 (
 'data.txt'
 , 
 'r'
 ) 
 as
  
 f
 :
     
 data
  
 =
  
 f
 .
 read
 ()
 This is good syntax because it simplifies the 
 cleanup
  step where the
 file handle is closed. Using the context manager means that you
 don’t have to remember to do 
 f.close()
  yourself: this will happen
 automatically when the 
 with
  block exits.
 You can use the 
 contextmanager
  decorator from the 
 contextlib
 library to benefit from this language feature in your own nefarious
 schemes. Here’s a creative demonstration where we create a new
 context manager to print out performance (timing) data.
 This might be useful for quickly testing the time cost of code snip‐
 pets, as shown in the following example. The numbered notes are
 intentionally not in numerical order in the code. Follow the notes in
 numerical order as shown following the code snippet.
 from
  
 time
  
 import
  
 perf_counter
 from
  
 array
  
 import
  
 array
 from
  
 contextlib
  
 import
  
 contextmanager
 6 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
concurrent.futures,"The 
 concurrent.futures
  module that was introduced in Python 3
 provides a convenient way to manage pools of workers. If you have
 previously used the threading module in the Python standard
 library, you will have seen code like this before:
 import
  
 threading
 def
  
 work
 ():
     
 return
  
 sum
 (
 x
  
 for
  
 x
  
 in
  
 range
 (
 1000000
 ))
 thread
  
 =
  
 threading
 .
 Thread
 (
 target
 =
 work
 )
 thread
 .
 start
 ()
 thread
 .
 join
 ()
 This code is very clean with only one thread, but with many threads
 it can become quite tricky to deal with sharing work between them.
 Also, in this example the result of the 
 sum
  is not obtained from the
 work function, simply to avoid all the extra code that would be
 required to do so. There are various techniques for obtaining the
 result of a work function, such as passing a queue to the function, or
 subclassing 
 threading.Thread
 , but we’re not going discuss them
 8 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
logging,"The 
 logging
  module is very well known in the web development
 community, but is far less used in other domains, such as the scien‐
 tific one; this is unfortunate, because even for general use, the log‐
 ging module is far superior to the 
 print()
  function. It doesn’t seem
 that way at first, because the 
 print()
  function is so simple; however,
 once you initialize 
 logging
 , it can look very similar. For instance,
 compare these two:
 print
 (
 'This is output to the console'
 )
 logger
 .
 debug
 (
 'This is output to the console'
 )
 The huge advantage of the latter is that, with a single change to a set‐
 ting on the logger instance, you can either show or hide all your
 debugging messages. This means you no longer have to go through
 the process of commenting and uncommenting your 
 print()
  state‐
 ments in order to show or hide them. 
 logging
  also gives you a few
 different 
 levels
  so that you can adjust the verbosity of output in your
 programs.  Here’s an example of different levels:
 logger
 .
 debug
 (
 'This is for debugging. Very talkative!'
 )
 logger
 .
 info
 (
 'This is for normal chatter'
 )
 logger
 .
 warning
 (
 'Warnings should almost always be seen.'
 )
 logger
 .
 error
 (
 'You definitely want to see all errors!'
 )
 logger
 .
 critical
 (
 'Last message before a program crash!'
 )
 Another really neat trick is that when you use logging, writing mes‐
 sages during exception handling is a whole lot easier. You don’t have
 to deal with 
 sys.exc_info()
  and the 
 traceback
  module merely for
 printing out the exception message with a traceback. You can do this
 instead:
 try
 :
     
 1
 /
 0
 except
 :
     
 logger
 .
 exception
 (
 ""Something failed:""
 )
 Just those four lines produces a full traceback in the output:
 ERROR:root:Something failed:
 Traceback (most recent call last):
   File ""logtb.py"", line 5, in <module>
     1/0
 ZeroDivisionError: division by zero
 The Standard Library 
 | 
 11",NA
sched 4,"There is increasing interest in the creation of bots
  and other moni‐
 toring and automation applications. For these applications, a com‐
 mon requirement is to perform actions at specified times or
 specified intervals. This functionality is provided by the 
 sched
  mod‐
 ule in the standard library. There are already similar tools provided
 by operating systems, such as 
 cron
  on Linux and 
 Windows Task
 Scheduler
 , but with Python’s own 
 sched
  module you can ignore
 these platform differences, as well as incorporate scheduled tasks
 into a program that might have many other functions.
 The 
 documentation
  for sched is rather terse, but hopefully these
 examples will get you started.  The easy way to begin is to schedule a
 function to be executed after a specified delay (this is a complete
 example to make sure you can run it successfully):
 import
  
 sched
 import
  
 time
 from
  
 datetime
  
 import
  
 datetime
 , 
 timedelta
 scheduler
  
 =
  
 sched
 .
 scheduler
 (
 timefunc
 =
 time
 .
 time
 )  
 def
  
 saytime
 ():  
 The Standard Library 
 | 
 13",NA
In the Wild,"From here on we’ll look at some third-party Python libraries that
 you might not yet have discovered. There are thousands of excellent
 packages described at 
 the Python guide
 .
 There are quite a few guides similar to this report that you can find
 online. There could be as many “favorite Python libraries” lists as
 there are Python developers, and so the selection presented here is
 necessarily subjective. I spent a lot of time finding and testing vari‐
 ous third-party libraries in order to find these hidden gems.
 In the Wild 
 | 
 15",NA
Easier Python Packaging with flit,"flit
  is a tool that dramatically simplifies the process of submitting a
 Python package to the Python Package Index (PyPI). The 
 traditional
 process
  begins by creating a 
 setup.py
  file; simply figuring out how
 to do that requires a considerable amount of work even to under‐
 stand what to do. In contrast, flit will create its config file interac‐
 tively, and for typical simple packages you’ll be ready to upload to
 PyPI almost immediately. Let’s have a look: consider this simple
 package structure:
 16 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
Command-Line Applications,"If you’ve spent any time whatsoever developing Python code, you
 will surely have used several command-line applications. Some
 command-line programs seem much friendlier than others, and in
 this chapter we show two fantastic libraries that will make it easy for
 you to offer the best experience for users of your own command-
 line applications. 
 colorama
  allows you to use colors in your output,
 while 
 begins
  makes it easy to provide a rich interface for specifying
 and processing command-line options.",NA
colorama,"Many of your desktop Python programs will only ever be used on
 the command line, so it makes sense to do whatever you can to
 improve the experience of your users as much as possible. The use
 of 
 color
  can dramatically improve your user interface, and 
 colorama
 makes it very easy to add splashes of color into your command-line
 applications.
 Let’s begin with a simple example.
 Command-Line Applications 
 | 
 19",NA
begins,"As far as user-interfaces go, most Python programs start out as
 command-line applications, and many remain so. It makes sense to
 offer your users the very best experience you can. For such pro‐
 grams, options are specified with command-line arguments, and the
 Python standard library offers the 
 argparse
  library to help with that.
 argparse
  is a robust, solid implementation for command-line pro‐
 cessing, but it is somewhat verbose to use. For example, here we
 have an extremely simple script that will add two numbers passed
 on the command line:
 import
  
 argparse
 def
  
 main
 (
 a
 , 
 b
 ):
     
 """""" Short script to add two numbers """"""
     
 return
  
 a
  
 +
  
 b
 if
  
 __name__
  
 ==
  
 '__main__'
 :
     
 parser
  
 =
  
 argparse
 .
 ArgumentParser
 (
         
 description
 =
 ""Add two numbers""
 )
     
 parser
 .
 add_argument
 (
 '-a'
 ,
                         
 help
 =
 'First value'
 ,
                         
 type
 =
 float
 ,
                         
 default
 =
 0
 )
 22 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
Graphical User Interfaces,"Python offers a wealth of options for creating graphical user inter‐
 faces (GUIs) including 
 PyQt
 , 
 wxPython
 , and 
 tkinter
 , which is also
 available directly in the standard library. In this chapter we will
 describe two significant, but largely undiscovered, additions to the
 lineup. The first, 
 pyqtgraph
 , is much more than simply a chart-
 plotting library, while 
 pywebview
  gives you a full-featured web-
 technology interface for your desktop Python applications.",NA
pyqtgraph,"The most popular chart-plotting library in Python is 
 matplotlib
 , but
 you may not yet have heard of the wonderful alternative, 
 pyqtgraph
 .
 Pyqtgraph is not a one-to-one replacement for matplotlib; rather, it
 offers a different selection of features and in particular is excellent
 for real-time and interactive visualization.
 26 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
pywebview,"There are a huge number of ways to make 
 desktop
  GUI applications
 with Python, but in recent years the idea of using a browser-like
 interface as a desktop client interface has become popular. This
 approach is based around tools like 
 cefpython
  (using the Chrome-
 embedded framework) and 
 Electron
 , which has been used to build
 many popular tools such as the Atom text editor and Slack social
 messaging application.
 Usually, such an approach involves bundling a browser engine with
 your application, but 
 Pywebview
  gives you a one-line command to
 create a GUI window that wraps a 
 system native
  “web view” window.
 By combining this with a Python web abb like Flask or Bottle, it
 becomes very easy to create a local application with a GUI, while
 also taking advantage of the latest GUI technologies that have been
 developed in the browser space. The benefit to using the system
 native browser widget is that you don’t have to distribute a poten‐
 tially large application bundle to your users.
 Let’s begin with an example. Since our application will be built up as
 a web-page template in HTML, it might be interesting to use a
 Python tool to build the HTML rather than writing it out by hand.
 Graphical User Interfaces 
 | 
 29",NA
System Tools,"Python is heavily used to make tools that work closely with the
 operating system, and it should be no surprise to discover that there
 are excellent libraries waiting to be discovered. The 
 psutil
  library
 gives you all the access to operating-system and process information
 you could possibly hope for, while the 
 Watchdog
  library gives you
 hooks into system file-event notifications. Finally, we close out this
 chapter with a look at 
 ptpython
 , which gives you a significantly
 enriched interactive Python prompt.",NA
psutil,"Psutil provides complete access to system information. Here’s a sim‐
 ple example of a basic report for CPU load sampled over 5 seconds:
 import
  
 psutil
 cpu
  
 =
  
 psutil
 .
 cpu_percent
 (
 interval
 =
 5
 , 
 percpu
 =
 True
 )
 print
 (
 cpu
 )
 Output:
 [
 21.4
 , 
 1.2
 , 
 18.0
 , 
 1.4
 , 
 15.6
 , 
 1.8
 , 
 17.4
 , 
 1.6
 ]
 It produces one value for each logical CPU: on my computer, eight.
 The rest of the 
 psutil
  API is as simple and clean as this example
 shows, and the API also provides access to memory, disk, and net‐
 work information. It is 
 very
  extensive.  
 There is also detailed information about processes. To demonstrate,
 here is a program that monitors its own memory consumption and
 throws in the towel when a limit is reached:
 import
  
 psutil
 import
  
 os
 ,
  
 sys
 ,
  
 time
 pid
  
 =
  
 os
 .
 getpid
 ()  
 p
  
 =
  
 psutil
 .
 Process
 (
 pid
 )  
 print
 (
 'Process info:'
 )
 print
 (
 '  name  :'
 , 
 p
 .
 name
 ())
 print
 (
 '  exe   :'
 , 
 p
 .
 exe
 ())
 data
  
 =
  []
 while
  
 True
 :
     
 data
  
 +=
  
 list
 (
 range
 (
 100000
 ))  
     
 info
  
 =
  
 p
 .
 memory_full_info
 ()
     
 # Convert to MB
 34 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
Watchdog,"Watchdog
  is a high-quality, cross-platform library for receiving noti‐
 fications of changes in the file system. Such file-system notifications
 is a fundamental requirement in many automation applications, and
 Watchdog
  handles all the low-level and cross-platform details of
 notifications for system events. And, the great thing about 
 Watchdog
 is that it doesn’t use 
 polling
 .
 The problem with polling is that having many such processes run‐
 ning can sometimes consume more resources than you may be will‐
 ing to part with, particularly on lower-spec systems like the
 Raspberry Pi
 . By using the native notification systems on each plat‐
 form, the operating system 
 tells you
  immediately when something
 has changed, rather than you having to ask. On Linux, the 
 inotify
 API is used; on Mac OS X, either 
 kqueue
  or 
 FSEvents
  are used; and
 on Windows, the 
 ReadDirectoryChangesW
  API is used. 
 Watchdog
 allows you to write cross-platform code and not worry too much
 about how the sausage is made.
 Watchdog
  has a mature API, but one way to get immediate use out of
 it is to use the included 
 watchmedo
  command-line utility to run a
 shell command when something changes. Here are a few ideas for
 inspiration:
 •Compiling template and markup languages:
 # Compile Jade template language into HTML
 $ 
 watchmedo shell-command 
 \
       --patterns
 =
 ""*.jade""
  
 \
       --command
 =
 'pyjade -c jinja ""${watch_src_path}""'
  
 \ 
  
       --ignore-directories
 # Convert an asciidoc to HTML
 $ 
 watchmedo shell-command 
 \
       --patterns
 =
 ""*.asciidoc""
  
 \
       --command
 =
 'asciidoctor ""${watch_src_path}""'
  
 \ 
  
       --ignore-directories
 Watchdog will substitute the name of the specific changed file
 using this template name.
 36 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
ptpython,"ptpython
  is an alternative interpreter interface, offering a beautiful
 interactive Python experience. As such, 
 ptpython
  is more like a tool
 than a library to include in your own projects, but what a tool!
 Figure 1-8
  shows a screenshot showing the basic user interface.
 When you need to work with blocks in the interpreter, like classes
 and functions, you will find that accessing the command history is
 much more convenient than the standard interpreter interface:
 when you scroll to a previous command, the entire block is shown,
 not only single lines, as shown in 
 Figure 1-9
 .
 Here, I retrieved the code for the function declaration by pressing
 the up arrow (or Ctrl-p) and the entire block is shown, rather than
 having to scroll through lines separately.
 The additional features include 
 vi
  and 
 Emacs
  keys, theming support,
 docstring hinting, and input validation, which checks a command
 (or block) for syntax errors before allowing evaluation. To see the
 full set of configurable options, press F2, as seen in 
 Figure 1-10
 .
 Figure 1-8. The code-completion suggestions pop up automatically as
 you type.
 System Tools 
 | 
 39",NA
Web APIs with hug,"Python is famously used in a large number of web frameworks, and
 an extension of this area is the web services domain in which APIs
 are exposed for other users’ programs to consume. In this domain,
 Django REST framework
  and 
 Flask
  are very popular choices, but
 you may not yet have heard of 
 hug
 .
 hug
  is a library that provides an extremely simple way to create
 Internet APIs for web services. By exploiting some of the language
 features of Python, much of the usual boilerplate normally required
 when creating APIs for web services is removed.
 Here is a small web service that converts between the hex value of a
 color and its 
 CSS3 name
 :
 import
  
 hug
 import
  
 webcolors
 @hug.get
 ()
 def
  
 hextoname
 (
 hex
 : 
 hug
 .
 types
 .
 text
 ):
     
 return
  
 webcolors
 .
 hex_to_name
 (
 '#'
  
 +
  
 hex
 )
 @hug.get
 ()
 def
  
 nametohex
 (
 name
 : 
 hug
 .
 types
 .
 text
 ):
     
 return
  
 webcolors
 .
 name_to_hex
 (
 name
 )
 We are also using the 
 webcolors
  library here: your one-
 stop shop for converting web-safe colors between vari‐
 ous formats like name, hex, and 
 rgb
 . Don’t forget that
 you can also convert between 
 rgb
  and other formats
 like 
 hsl
  with the 
 colorsys
  library that’s already
 included in the Python standard library!
 Web APIs with hug 
 | 
 41",NA
Dates and Times,"Many Python users cite two major pain points: the first is 
 packaging
 ,
 and for this we covered 
 flit
  in an earlier chapter. The second is
 working with dates and times. In this chapter we cover two libraries
 that will make an enormous difference in how you deal with tempo‐
 ral matters. 
 arrow
  is a reimagined library for working with 
 datetime
 objects in which timezones are always present, which helps to mini‐
 mize a large class of errors that new Python programmers encounter
 frequently. 
 parsedatetime
  is a library that lets your code parse
 natural-language inputs for dates and times, which can make it
 vastly easier for your users to provide such information.
 46 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
arrow,"Though opinions differ, there are those who have found the stan‐
 dard library’s 
 datetime
  module confusing to use. The module docu‐
 mentation itself in the 
 first few paragraphs
  explains why: it provides
 both 
 naive
  and 
 aware
  objects to represent dates and times. The 
 naive
 ones are the source of confusion, because application developers
 increasingly find themselves working on projects in which time‐
 zones are critically important. The dramatic rise of cloud infrastruc‐
 ture and software-as-a-service applications have contributed to the
 reality that your application will frequently run in a different time‐
 zone (e.g., on a server) than where developers are located, and dif‐
 ferent again to where your users are located.
 The 
 naive
  
 datetime
  objects are the ones you typically see in demos
 and tutorials:
 import
  
 datetime
 dt
  
 =
  
 datetime
 .
 datetime
 .
 now
 ()
 dt_utc
  
 =
  
 datetime
 .
 datetime
 .
 utcnow
 ()
 difference
  
 =
  (
 dt
  
 -
  
 dt_utc
 )
 .
 total_seconds
 ()
 print
 (
 'Total difference: 
 %.2f
  seconds'
  
 %
  
 difference
 )
 This code could not be any simpler: we create two 
 datetime
  objects,
 and calculate the difference. The problem is that we probably
 intended both 
 now()
  and 
 utcnow()
  to mean 
 now
  as in “this moment
 in time,” but perhaps in different timezones. When the difference is
 calculated, we get what seems an absurdly large result:
 Total
  
 difference
 : 
 36000.00
  
 seconds
 The difference is, in fact, the timezone difference between my cur‐
 rent location and UTC: +10 hours. This result is the worst kind of
 “incorrect” because it is, in fact, 
 correct
  if timezones are not taken
 into account; and here lies the root of the problem: a misunder‐
 standing of what the functions actually do. The 
 now()
  and 
 utcnow()
 functions 
 do
  return the current time in local and UTC timezones,
 but unfortunately both results are 
 naive
  
 datetime
  objects and there‐
 fore lack timezone data.
 Note that it 
 is
  possible to create 
 datetime
  objects with timezone data
 attached, albeit in a subjectively cumbersome manner: you create an
 aware
  
 datetime
  by setting the 
 tzinfo
  attribute to the correct time‐
 zone. In our example, we could (and should!) have created a current
 Dates and Times 
 | 
 47",NA
parsedatetime,"parsedatetime
  is a wonderful library with a dedicated focus: pars‐
 ing text into dates and times. As you’d expect, it can be obtained
 with 
 pip install parsedatetime
 . The 
 official documentation
  is
 very API-like, which makes it harder than it should be to get a quick
 overview of what the library offers, but you can get a pretty good
 idea of what’s available by browsing the extensive 
 test suite
 .
 The minimum you should expect of a 
 datetime
 -parsing library is to
 handle the more common formats, and the following code sample
 demonstrates this:
 50 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
General-Purpose Libraries,"In this chapter we take a look at a few batteries that have not yet
 been included in the Python standard library, but which would
 make excellent additions.
 General-purpose libraries are quite rare in the Python world because
 the standard library covers most areas sufficiently well that library
 authors usually focus on very specific areas. Here we discuss
 boltons
  (a play on the word 
 builtins
 ), which provides a large num‐
 ber of useful additions to the standard library. We also cover the
 Cython
  library, which provides facilities for 
 both
  massively speeding
 up Python code, as well as bypassing Python’s famous 
 global inter‐
 preter lock
  (GIL) to enable true multi-CPU multi-threading.",NA
boltons,"The 
 boltons
  library is a general-purpose collection of Python mod‐
 ules that covers a wide range of situations you may encounter. The
 library is well-maintained and high-quality; it’s well worth adding to
 your toolset.
 As a general-purpose library, 
 boltons
  does not have a specific focus.
 Instead, it contains several smaller libraries that focus on specific
 areas. In this section I will describe a few of these libraries that 
 bol
 tons
  offers.
 boltons.cacheutils
 boltons.cacheutils
  provides tools for using a 
 cache
  inside your
 code. Caches are very useful for saving the results of expensive oper‐
 ations and reusing those previously calculated results.
 The 
 functools
  module in the 
 standard library
  already provides a
 decorator called 
 lru_cache
 , which can be used to 
 memoize
  calls: this
 means that the function remembers the parameters from previous
 calls, and when the same parameter values appear in a new call, the
 previous answer is returned directly, bypassing any calculation.
 General-Purpose Libraries 
 | 
 53",NA
Cython,"Cython
  is a magical tool! As with most magical devices, it is difficult
 to describe exactly what it is. Cython is a tool that converts Python
 General-Purpose Libraries 
 | 
 59",NA
awesome-python,"Finally, we have 
 awesome-python
 . It’s not a library, but rather a
 huge, curated list of a high-quality Python libraries covering a large
 number of domains.  If you have not seen this list before, make sure
 to reserve some time before browsing because once you begin, you’ll
 have a hard time tearing yourself away!",NA
Conclusion,"There is much more to discover than what you’ve seen in this report.
 One of the best things about the Python world is its enormous
 repository of high-quality libraries.
 You have seen a few of the very special features of the standard
 library like the 
 collections
  module, 
 contextlib
 , the 
 concur
 rent.futures
  module, and the 
 logging
  module. If you do not yet
 use these heavily, I sincerely hope you try them out in your next
 project.
 In addition to those standard library modules, we also covered sev‐
 eral excellent libraries that are also available to you on the PyPI.
 You’ve seen how:
 66 
 | 
 Chapter 1: Expanding Your Python Knowledge: Lesser-Known Libraries",NA
About the Author,"Caleb Hattingh
  is passionate about coding and has been program‐
 ming for over 15 years, specializing in Python. He holds a master’s
 degree in chemical engineering and has consequently written a great
 deal of scientific software within chemical engineering, from
 dynamic chemical reactor models all the way through to data analy‐
 sis. He is very experienced with the Python scientific software stack,
 CRM, financial software development in the hotels and hospitality
 industry, frontend web experience using HTML, Sass, JavaScript
 (loves RactiveJS), and backend experience with Django and web2py.
 Caleb is a regular speaker at PyCon Australia and is actively engaged
 in the community as a CoderDojo Mentor, Software Carpentry
 helper, Govhacker, Djangogirls helper, and even Railsgirls helper.
 Caleb is the founder of 
 Codermoji
 , and posts infrequent idle rants
 and half-baked ideas to his blog at 
 pythonomicon.com
 .",NA
