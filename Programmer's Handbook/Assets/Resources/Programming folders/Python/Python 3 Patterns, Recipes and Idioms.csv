Larger Text,Smaller Text,Symbol
"Python 3 Patterns, Recipes and Idioms ",NA,NA
Release 1.0,NA,NA
Bruce Eckel,"September 27, 2017",NA
Contents,"1
  
 Contributors
  
 1
  
 1.1
  
 Thanks To
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
  
 2
  
 ToDo List
  
 3
  
 3
  
 The remainder are from context, from the book.
  
 5
  
 4
  
 A Note To Readers
  
 7
  
 5
  
 Introduction
  
 9
  
 6
  
 5.1
  
 A Team Effort
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 5.2
  
 Not an Introductory Book
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 5.3
  
 The License
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 5.4
  
 The Printed Book
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 5.5
  
 Translations
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 5.6
  
 My Motives
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 Teaching Support
  
 13
  
 7
  
 Book Development Rules
  
 15
  
 8
  
 7.1
  
 Contribute What You Can
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 7.2
  
 Don’t Get Attached
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 7.3
  
 Credit
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 7.4
  
 Mechanics
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 7.5
  
 Diagrams
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 Developer Guide
  
 19
  
 8.1
  
 Getting Started: The Easiest Approach
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 8.2
  
 For Windows Users
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 8.3
  
 Installing Sphinx
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 20
  
 8.4
  
 Getting the Development Branch of the Book
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 20
  
 8.5
  
 Building the Book
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
  
 8.6
  
 Building the PDF
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
  
 8.7
  
 Setting up Mercurial
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
  
 8.8
  
 Working with BitBucket and Mercurial
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22
  
 8.9
  
 A Simple Overview Of Editing and Merging
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 23
  
 8.10
  
 Emacs for Editing Restructured Text
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 23
  
 i",NA
CHAPTER,NA,NA
 1,NA,NA
Contributors,"List of contributors.
  
 Note:
  
 This needs some thought. I want to include everyone who makes a contribution, but I’d also like
  
 to indicate people who have made larger contributions – there’s no automatic way to do this now that we 
 have moved to BitBucket and are using Wikis to allow people to make contributions more simply in the 
 beginning.",NA
Thanks To,"• BitBucket.org and the creators of Mercurial
  
 • Creator(s) of Sphinx
  
 • And of course, Guido and the team for their incessant improvement of Python, especially for taking 
  
 the risk in breaking backward compatibility in Python 3.0 to refactor the language.
  
 Todo 
  
 Yarko (example label of ToDo):
  
  
 • update CSS styles for todo’s & todo lists;
  
  
 • look at
  http://sphinx.pocoo.org/ext/coverage.html
  for example.
  
 • Autogenerated ToDoLists do not appear in LaTeX output - debug, fix;
  
 • DONE: - ToDo does not appear to be created by make dependencies (it’s autogenerated); - update 
  
 Makefile to always re-generate todo lists;
  
 1",NA
CHAPTER,NA,NA
 2,NA,NA
ToDo List,"Currently, this doesn’t seem to link into the index, as I’d hoped.
  
 • Refine “Printed Book” and “Translations”
  
 • Code extractor for rst files (maybe part of intro chapter?)• 
 Code updater to put code in/refresh code into book.
  
 • Move frontmatter into its own directory
  
 • <!> Seems to be a warning sign (but initial tests didn’t work)
  
 • Idea: decorator on a dictionary object, to turn it into an ordered dictionary.
  
 • “Other resources” at the end of each chapter
  
 • For print version, convert hyperlinks into footnotes.
  
 –
  build tool for this, or check int rst handling of this - see if it works with Sphinx;
  
 3",NA
CHAPTER,NA,NA
 3,NA,NA
"The remainder are from context, from the book.","Todo 
  
 Yarko (example label of ToDo):
  
  
 • update CSS styles for todo’s & todo lists;
  
  
 • look at
  http://sphinx.pocoo.org/ext/coverage.html
  for example.
  
 • Autogenerated ToDoLists do not appear in LaTeX output - debug, fix;
  
 • DONE: - ToDo does not appear to be created by make dependencies (it’s autogenerated); - update 
  
 Makefile to always re-generate todo lists;
  
 (The original entry is located in /home/docs/checkouts/readthedocs.org/user_builds/python-3-patterns-
 idioms-test/checkouts/latest/docs/Contributors.rst, line 27.)
  
 Todo 
  
 The remainder of this document needs rewriting. Rewrite this section for BitBucket & Mercurial; make some 
 project specific diagrams;
  
 (The original entry is located in /home/docs/checkouts/readthedocs.org/user_builds/python-3-patterns-
 idioms-test/checkouts/latest/docs/DeveloperGuide.rst, line 138.)
  
 Todo 
  
 This section still work in progress:
  
  
 • hg branch lp:python3patterns
  
  
 • hg commit -m 'initial checkout'
  
  
 • (hack, hack, hack....)
  
  
 • hg merge (pull new updates)
  
 5",NA
CHAPTER,NA,NA
 4,NA,NA
A Note To Readers,"What you see here is an early version of the book. We have yet to get everything working right and rewritten 
 for Python. Or even to get the book testing systems in place.
  
 If you’re here because you’re curious, that’s great. But please don’t expect too much from the book just yet. 
 When we get it to a point where everything compiles and all the Java references, etc. have been rewritten out, 
 then this note will disappear. Until then,
  caveat emptor
 .
  
 7",NA
CHAPTER,NA,NA
 5,NA,NA
Introduction,NA,NA
A Team Effort,"This book is an experiment to see if we can combine everyone’s best efforts to create something great.
  
 You can find the contributors right before this introduction. They are listed in order of
  Karma Points
 , a sys-
 tem Launchpad.net uses to keep track of contributions from everyone working on an open-source project.
  
 In my case, I will write new material, as well as rewriting other contributions to clarify and give voice, setting 
 up the architecture and being the
  Benevolent Dictator
  for the book. But I definitely won’t be doing everything; 
 my goal is that this is a team project and that everyone who wants to will have something useful to 
 contribute.
  
 We’ll be using Launchpad.net’s “Blueprints” facility to add “features” to the book, so that’s where you’ll find 
 the main repository of things to do.
  
 What can you contribute? Anything as small as spelling and grammatical correctons, and as large as a whole 
 chapter. Research into new topics and creating examples is what takes me the most time, so if you know 
 something already or are willing to figure it out, don’t worry if your writing or programming isn’t perfect – 
 contribute it and I and the rest of the group will improve it.
  
 You may also have talents in figuring things out. Sphinx formatting, for example, or how to produce camera-
 ready formatting. These are all very useful things which will not only benefit this book but also any future 
 book built on this template (every bit of the build system for the book will be out in the open, so if you want to 
 take what we’ve done here and start your own book, you can).
  
 Of course, not everything can make it into the final print book, but things that don’t fit into the main book can 
 be moved into an “appendix book” or a “volume 2” book or something like that.",NA
Not an Introductory Book,"Although there is an introduction for programmers, this book is not intended to be introductory. There are 
 already lots of good introductory books out there.
  
 9",NA
The License,"Unless otherwise specified, the material in this book is published under a
  Creative Commons Attribution-
 Share Alike 3.0 license
 .
  
 If you make contributions, you must own the rights to your material and be able to place them under this 
 license. Please don’t contribute something unless you are sure this is the case (read your company’s 
 employment contract – these often specify that anything you think of or create at any time of day or night 
 belongs to the company).",NA
The Printed Book,"Because of the creative commons license, the electronic version of the book as well as all the sources are 
 available, can be reproduced on other web sites, etc. (again, as long as you attribute it).
  
 You can print your own version of the book. I will be creating a printed version of the book for sale, with a 
 nice cover and binding. Many people do like to have a print version of the book, and part of the motivation for 
 doing a print version is to make some income off the effort I put into the book.
  
 But buying my particular print version of the book is optional. All of the tools will be downloadable so that 
 you can print it yourself, or send it to a copy shop and have it bound, etc. The only thing you won’t get is my 
 cover and binding.",NA
Translations,"Launchpad.net, where this project is hosted, has support for doing translations and this gave me an idea. I had 
 just come back from speaking at the Python conference in Brazil, and was thinking about the user group there 
 and how I might support them. (We had done a seminar while I was there in order to help pay for my trip and 
 support the organization).
  
 If the book can be kept in a Sphinx restructured text format that can be turned directly into camera-ready 
 PDF (the basic form is there but it will take somebody messing about with it to get it into camera-ready 
 layout), then the job of translation can be kept to something that could be done by user groups during sprints. 
 The user group could then use a print-on-demand service to print the book, and get the group members to 
 take them to local bookstores and do other kinds of promotions. The profits from the book could go to the 
 user group (who knows, just like the Brazillian group, your group may end up using some of those profits to 
 bring me to speak at your conference!).
  
 10
  
 Chapter 5. Introduction",NA
My Motives,"Just so it’s clear, I have the following motives for creating this book:
  
 1. Learn more about Python and contribute to the Python community, to help create more and better 
  
 Python programmers.
  
 2. Develop more Python consulting and training clients through the publicity generated by the book 
  
 (see
  here
 ).
  
 3. Experiment with group creation of teaching materials for the book, which will benefit me in my own 
 training (see the previous point) but will also benefit anyone choosing to use the book as a text in a 
 course or training seminar. (See
  Teaching Support
 ).
  
 4. Generate profits by selling printed books. (But see above about the ability to print the book yourself).
  
 5. Help raise money for non-U.S. Python user groups via translations, from which I might gain a small 
  
 percentage.
  
 5.6. My Motives
  
 11",NA
CHAPTER,NA,NA
 6,NA,NA
Teaching Support,"Teachers and lecturers often need support material to help them use a book for teaching. I have put some 
 exercises in, and I hope we can add more.
  
 I’d also like to create teaching materials like slides and exercises as a group effort with a creative commons 
 license, especially by allying with those people who are in the teaching professions. I’d like to make it 
 something that everyone would like to teach from – including myself.
  
 Here are some places to get ideas for exercises and projects:
  
 •
  For coding dojos
  
 •
  Rosetta Code
  
 13",NA
CHAPTER,NA,NA
 7,NA,NA
Book Development Rules,"Guidelines for the creation process.
  
 Note:
  This is just a start. This document will evolve as more issues appear.",NA
Contribute What You Can,"One of the things I’ve learned by holding open-spaces conferences is that everyone has something useful to 
 contribute, although they often don’t know it.
  
 Maybe you’re don’t feel expert enough at Python to contribute anything yet. But you’re in this field, so you’ve 
 got some useful abilities.
  
 • Maybe you’re good at admin stuff, figuring out how things work and configuring things.
  
 • If you have a flair for design and can figure out Sphinx templating, that will be useful.
  
 • Perhaps you are good at Latex. We need to figure out how to format the PDF version of the book from the 
 Sphinx sources, so that we can produce the print version of the book without going through hand work 
 in a layout program.
  
 • You probably have ideas about things you’d like to understand, that haven’t been covered elsewhere.
  
 • And sometimes people are particularly good at spotting typos.",NA
Don’t Get Attached,"Writing is rewriting. Your stuff will get rewritten, probably multiple times. This makes it better for the reader. 
 It doesn’t mean it was bad. Everything can be made better.
  
 15",NA
Credit,"As much as possible, I want to give credit to contributions. Much of this will be taken care of automatically by 
 the Launchpad.net “Karma” system. However, if you contribute something significant, for example the bulk of 
 a new chapter, then you should put “contributed by” at the beginning of that chapter, and if you make 
 significant improvements and changes to a chapter you should say “further contributions by” or“further 
 changes by”, accordingly.",NA
Mechanics,"• Automate everything. Everything should be in the build script; nothing should be done by hand.
  
 • All documents will be in Sphinx restructured text format. Here’s the
  link to the Sphinx documenta-
  
 tion
 .
  
 • Everything goes through Launchpad.net and uses Launchpad’s Bazzar distributed version control 
  
 system.
  
 • Follow PEP8 for style. That way we don’t have to argue about it.
  
 • Camelcasing for naming. PEP8 suggests underscores as a preference rather than a hard-and fast rule, and 
 camelcasing
  feels
  more like OO to me, as if we are emphasizing the design here (which I want to do) and 
 putting less focus on the C-ish nature that
  can
  be expressed in Python.
  
 The above point
  is
  still being debated
 .
  
 • Four space indents.
  
 • We’re not using chapter numbers because we’ll be moving chapters around. If you need to cross-
  
 reference a chapter, use the chapter name and a link.
  
 • Index as you go. Indexing will happen throughout the project. Although finalizing the index is a task in 
 itself, it will be very helpful if everyone adds index entries anytime they occur to you. You can find 
 example index entries by going to the index, clicking on one of the entries, then selecting“view source” 
 in the left-side bar (Sphinx cleverly shows you the Sphinx source so you can use it as an example).
  
 • Don’t worry about chapter length. Some chapters may be very small, others may be quite significant. It’s 
 just the nature of this book. Trying to make the chapters the same length will end up fluffing some up 
 which will not benefit the reader. Make the chapters however long they need to be, but no longer.
  
 16
  
 Chapter 7. Book Development Rules",NA
Diagrams,"Create diagrams using whatever tool is convenient for you, as long as it produces formats that Sphinx can use.
  
 It doesn’t matter if your diagram is imperfect. Even if you just sketch something by hand and scan it in, it will 
 help readers visualize what’s going on.
  
 At some point, diagrams will be redone for consistency using a single tool, with print publication in mind. This 
 tool may be a commercial product. However, if you need to change the diagram you can replace it with your 
 new version using your tool of choice. The important thing is to get the diagram right; at some point it will be 
 redone to look good.
  
 Note that all image tags should use a * at the end, not the file extension name. For example ..image:: 
 _images/foo.*. This way the tag will work for both the HTML output and the Latex output. Also, all images 
 should be placed in the _images directory.
  
 Here’s an example which was done with the free online service Gliffy.com, then modified using the free 
 Windows program Paint.NET (note, however, that we should not use color because it won’t translate well to 
 the print book):
  
 7.5. Diagrams
  
 17",NA
CHAPTER,NA,NA
 8,NA,NA
Developer Guide,Details for people participating in the book development process.,NA
Getting Started: The Easiest Approach,"If all of the details are a little overwhelming at first, there’s an easy way for you to make contributions without 
 learning about distributed version control and Sphinx: 
  
  
 1. Create an account at
  http://www.BitBucket.org
 .
  
 2. In your account, you get a wiki. In your wiki, create a page for your contribution. Just add your code 
  
 and descriptions using plain text.
  
 3. Point us to your wiki via the
  newsgroup
 .
  
 4. We’ll take your contribution and do the necessary formatting.
  
 If you want to take another step, you can learn how to format your wiki page using Sphinx by looking at the 
 source for pages in the book. You can try it right now – on the left side of this page (in the HTML book) you’ll 
 see a header that says
  This Page
  and underneath it
  Show Source
 . Click on
  Show Source
  and you’ll see the 
 Sphinx source for this page. Just look at the page sources and imitate that.
  
 When you’re ready, you can learn more about Sphinx and Mercurial and begin making contributions that way.
  
 The following sections are for those who are ready to build the book on their own machines.",NA
For Windows Users,"You need to install Cygwin; go to: 
  
  
 http://www.cygwin.com
  
 19",NA
Installing Sphinx,"Because we are sometimes pushing the boundaries of Sphinx, you’ll need to get the very latest development 
 version (a.k.a. the “tip”).
  
 1. Get mercurial: 
  
 http://www.selenic.com/mercurial 
  
 Avoid installing the tortoiseHG part - it has caused trouble w/ Python debuggers.
  
 2. To get the Sphinx trunk, start with:
  
 $ hg clone http://www.bitbucket.org/birkenfeld/sphinx/ and to update, use:
  
 $ hg pull 
  
 Once you update, run
  
 $ python setup.py install 
  
 (You can repeat this step whenever you need to update).
  
 We may talk about minimum version numbers to process the book. Check your version with:
  
  
   
 $ hg identify -n 
  
 The full anouncement from Georg (Sphinx creator) is here: 
  
  
  
 http://groups.google.com/group/sphinx-dev/browse_thread/thread/6dd415847e5cbf7c 
 Mercurial Cheat sheets & quick starts should be enough to answer your questions:
  
  
 •
  http://edong.net/2008v1/docs/dongwoo-Hg-120dpi.png
  
  
 •
  http://www.ivy.fr/mercurial/ref/v1.0/",NA
Getting the Development Branch of the Book,"This book uses BitBucket.org tools, and additional tools if necessary.
  
 1. Sign up for an account at
  http://BitBucket.org
 .
  
 2. You must create an rsa key. Under OSX and Linux, and if you installed openssh with Cygwin under 
  
 windows, you run ssh-keygen to generate the key, and then add it to your BitBucket account. 3. Go to
  
 http://www.bitbucket.org/BruceEckel/python-3-patterns-idioms/
 , and you’ll see instruc-
  
 tions for 
 getting a branch for development.
  
 20
  
 Chapter 8. Developer Guide",NA
Building the Book,"To ensure you have Cygwin installed correctly (if you’re using windows) and to see what the options are, type:
  
 make
  
 at a shell prompt. Then you can use make html to build the HTML version of the book, or make htmlhelp to 
 make the windows help version, etc.
  
 You can also use the build system I’ve created (as a book example; it is part of the distribution). This will call 
 make and it simplifies many of the tasks involved. Type:
  
 build help
  
 to see the options.
  
 Todo
  
 The remainder of this document needs rewriting. Rewrite this section for BitBucket & Mercurial; make some 
 project specific diagrams;",NA
Building the PDF,"In order to build the Acrobat PDF verion of the book, you must install some additional software:
  
 Mac OSX
 : Install the
  http://www.tug.org/mactex/
  distribution. Although this is a Mac installer, it installs all 
 the necessary command-line binaries to create the PDF of the book, and modifies your PATH variable.
  
 Windows
 : Install following these instructions:
  http://www.tug.org/texlive/windows.html
  
 Linux
 : Your Linux install may already have support, but if not, install following these instructions:
  http: 
 //www.tug.org/texlive/quickinstall.html
  
 Once TeX is installed, move to this book’s
  src
  directory and run make latex. When that command runs 
 successfully, it will give you instructions as to how to finish.",NA
Setting up Mercurial,"It’s easier if you put a configuration file called
  .hgrc
  in your home directory. Here’s one that sets up the user 
 name and configures
  kdiff3
  as the diff tool for Mercurial to use when showing you differences between files:
  
 # This is a Mercurial configuration file.
  
 [ui] 
  
 username = Firstname Lastname <email@mailer.net>
  
 [merge-tools] 
  
 # Override stock tool location 
  
 kdiff3.executable = /usr/bin/kdiff3 
  
 # Specify command line
  
  
 8.5. Building the Book
  
 21",NA
Working with BitBucket and Mercurial,"Note:
  Adapted from a posting by Yarko 
 Tymciurak 
  
 This assumes that you have created a l it 
 merged with the trunk.
  
 That is, you’ve done:
  
  
 • Forked a branch of
  http://ww 
  
  
 trunk; this fork will provide a pla
  
 • cloned the trunk to your local m 
  
  
 python-3-patterns-idioms/
  
  
 • cloned your local copy of trunk t 
  
  
 devel
  
 Todo 
  
 This section still work in progress:
  
  
 • hg branch lp:python3patterns
  
 • hg commit -m 'initial checkout'
  
 • (hack, hack, hack....)
  
  
 • hg merge (pull new updates)
  
  
 • hg commit -m 'checkin aft
  
  
 • ... and so on...
  
 When you have a new function idea, or
  
 • If you have a new feature, create 
  
 • If you have found a bug, make a 
  
  
 branch to it);
  
  
 • If you want to work on a project, 
  
  
 below...
  
 When you are ready to share your wor
  
 22
  
 o Tymciurak 
  
 ocal branch on your private machine where you do work, and keep
  
 w.bitbucket.org/BruceEckel/python-3-patterns-idioms/
  (the main ce 
 for review and comment) 
  
    
 achine: - hg clone
  https://my_login@bitbucket.org/BruceEckel/ 
 o 
 create a working directory: - hg clone python-3-patterns-idioms
  
 rns
  
 ckout'
  
 er merge...'
  
  think you’ve found a bug, ask Bruce on the group.
  
 a wiki page on BitBucket and describe what you’re going to do. bug 
 report on BitBucket (later assign it to yourself, and link your look for 
 an unassigned bug and try to work it out - then proceed as k have 
 others review, register a branch.
  
 Chapter 8. Developer Guide",NA
A Simple Overview Of Editing and Merging,"1. hg pull http://www.bitbucket.org/BruceEckel/python-3-patterns-idioms/ 2. hg merge This brought up 
 kdiff3 (note: this requires a separate installation of
  kdiff3
 )on any file’s w/ 
  
 conflicts, and you get to 
 just visually look - left-to-right at A:base, B:mine, and C:yours.... the NICE 
  
 thing is when you want BOTH the 
 other and yours, you can click BOTH B & C buttons — sweeet! 
  
 you can also review the “automatic” 
 merges, choose which - conflicts only, or any merge.
  
 3. ... make html; make latex ...... look at outputs (simultaneously, comparatively)... make any 
  
 changes.... repeat....
  
 4. hg ci without a message, it brought up an editor with a list of all changed files - so you can comment 
  
 individually.",NA
Emacs for Editing Restructured Text,"If you want an editing system with support for restructured text, one choice is the free text editor
  emacs
 , 
 which has an add-on mode for restructured text. Emacs has a long and venerable history, and is an ex-tremely 
 powerful editor. Emacs also has versions that are customized for operating systems to make it much more 
 familiar.
  
 Here’s a
  simple introduction to emacs
  and a
  useful introductory help guide
 . For Windows, there’s
  a special 
 FAQ
 .
  
 Mac OSX
 : Comes with built-in emacs which you can invoke from the command line. For a nicer version, install
  
 Aquamacs
 , which looks and feels like a native Mac application.
  
 Windows
 : You can download the latest windows installer
  here (choose the highest numbered zip file 
 with“bin” in the name)
 .
  This blog
  gives useful tips to make emacs on Windows even friendlier (in particular, it 
 puts emacs on the right-click menu and improves the startup settings).
  
 8.9. A Simple Overview Of Editing and Merging
  
 23",NA
CHAPTER,NA,NA
 9,NA,NA
Part I: Foundations,25,NA
CHAPTER,NA,NA
 10,NA,NA
Python for Programmers,"This book assumes you’re an experienced programmer, and it’s best if you have learned Python through 
 another book. For everyone else, this chapter gives a programmer’s introduction to the language.
  
 This is not an introductory book. I am assuming that you have worked your way through at least
  Learning 
 Python
  (by Mark Lutz & David Ascher; Oreilly, 1999) or an equivalent text before coming to this book.
  
 This brief introduction is for the experienced programmer (which is what you should be if you’re reading this 
 book). You can refer to the full documentation at
  www.Python.org
 .
  
 I find the HTML page
  A Python Quick Reference
  to be incredibly useful.
  
 In addition, I’ll assume you have more than just a grasp of the syntax of Python. You should have a good 
 understanding of objects and what they’re about, including polymorphism.
  
 On the other hand, by going through this book you’re going to learn a
  lot
  about object-oriented program-ming 
 by seeing objects used in many different situations. If your knowledge of objects is rudimentary, it will get 
 much stronger in the process of understanding the designs in this book.",NA
Scripting vs. Programming,"Python is often referred to as a scripting language, but scripting languages tend to be limiting, especially in 
 the scope of the problems that they solve. Python, on the other hand, is a programming language that also 
 supports scripting. It
  is
  marvelous for scripting, and you may find yourself replacing all your batch files, shell 
 scripts, and simple programs with Python scripts. But it is far more than a scripting language.
  
 The goal of Python is improved productivity. This productivity comes in many ways, but the language is 
 designed to aid you as much as possible, while hindering you as little as possible with arbitrary rules or any 
 requirement that you use a particular set of features. Python is practical; Python language design decisions 
 were based on providing the maximum benefits to the programmer.
  
 Python is very clean to write and especially to read. You will find that it’s quite easy to read your own code 
 long after you’ve written it, and also to read other people’s code. This is accomplished partially through clean, 
 to-the-point syntax, but a major factor in code readability is indentation - scoping in Python is determined by 
 indentation. For example:
  
 27",NA
Built-In Containers,"With languages like C++ and Java, containers are add-on libraries and not integral to the language. In Python, 
 the essential nature of containers for programming is acknowledged by building them into the core of the 
 language: both lists and associative arrays (a.k.a. maps, dictionaries, hash tables) are fundamental data types. 
 This adds much to the elegance of the language.
  
 In addition, the
  for
  statement automatically iterates through lists rather than just counting through a se-
 quence of numbers. This makes a lot of sense when you think about it, since you’re almost always using a 
 for
  
 loop to step through an array or a container. Python formalizes this by automatically making
  for
  use an 
 iterator that works through a sequence. Here’s an example:
  
 # PythonForProgrammers/list.py 
  
 list
  =
  [
  1
 ,
  3
 ,
  5
 ,
  7
 ,
  9
 ,
  11
  ] 
  
 print
 (
 list
 ) 
  
 list
 .
 append(
 13
 ) 
  
 for
  x
  in
  list
 : 
  
  
 print
 (x)
  
 The first line creates a list. You can print the list and it will look exactly as you put it in (in contrast, remember 
 that I had to create a special
  Arrays2
  class in
  Thinking in Java
  in order to print arrays in Java). Lists are like 
 Java containers - you can add new elements to them (here,
  append( )
  is used) and they will automatically 
 resize themselves. The
  for
  statement creates an iterator
  x
  which takes on each value in the list.
  
 You can create a list of numbers with the
  range( )
  function, so if you really need to imitate C’s
  for
 , you can.
  
 Notice that there aren’t any type declarations - the object names simply appear, and Python infers their type 
 by the way that you use them. It’s as if Python is designed so that you only need to press the keys that 
 absolutely must. You’ll find after you’ve worked with Python for a short while that you’ve been using up a lot 
 of brain cycles parsing semicolons, curly braces, and all sorts of other extra verbiage that was demanded
  
 28
  
 Chapter 10. Python for Programmers",NA
Functions,"To create a function in Python, you use the
  def
  keyword, followed by the function name and argument list, and 
 a colon to begin the function body. Here is the first example turned into a function:
  
 # PythonForProgrammers/myFunction.py 
  
 def
  myFunction
 (response): 
  
  
 val
  =
  0 
  
  
 if
  response
  ==
  ""yes""
 : 
  
  
  
 print
 (
 ""affirmative""
 ) 
  
  
  
 val
  =
  1 
  
  
 print
 (
 ""continuing...""
 ) 
  
  
 return
  val
  
 print
 (myFunction(
 ""no""
 )) 
  
 print
 (myFunction(
 ""yes""
 ))
  
 Notice there is no type information in the function signature - all it specifies is the name of the function and 
 the argument identifiers, but no argument types or return types. Python is a
  structurally-typed
  language, 
 which means it puts the minimum possible requirements on typing. For example, you could pass and return 
 different types from the same function:
  
 # PythonForProgrammers/differentReturns.py 
  
 def
  differentReturns
 (arg): 
  
  
 if
  arg
  ==
  1
 : 
  
  
  
 return
  ""one"" 
  
  
 if
  arg
  ==
  ""one""
 : 
  
  
  
 return True
  
 print
 (differentReturns(
 1
 )) 
  
 print
 (differentReturns(
 ""one""
 ))
  
 The only constraints on an object that is passed into the function are that the function can apply its opera-
 tions to that object, but other than that, it doesn’t care. Here, the same function applies the ‘
 +
 ‘ operator to 
 integers and strings:
  
 # PythonForProgrammers/sum.py 
  
 def
  sum
 (arg1, arg2): 
  
  
 return
  arg1
  +
  arg2
  
 print
 (
 sum
 (
 42
 ,
  47
 )) 
  
 print
 (
 sum
 (
 'spam '
 ,
  ""eggs""
 ))
  
 When the operator ‘
 +
 ‘ is used with strings, it means concatenation (yes, Python supports operator over-
 loading, and it does a nice job of it).",NA
Strings,"The above example also shows a little bit about Python string handling, which is the best of any language I’ve 
 seen. You can use single or double quotes to represent strings, which is very nice because if you surround a 
 string with double quotes, you can embed single quotes and vice versa:
  
 10.3. Functions
  
 29",NA
Classes,"Like everything else in Python, the definition of a class uses a minimum of additional syntax. You use the 
 class
  
 keyword, and inside the body you use
  def
  to create methods. Here’s a simple class:
  
 # PythonForProgrammers/SimpleClass.py 
  
 class
  Simple
 : 
  
  
 def
  __init__
 (
 self
 ,
  str
 ): 
  
  
  
 print
 (
 ""Inside the Simple constructor""
 ) 
  
  
 self
 .
 s
  =
  str 
  
  
 # Two methods: 
  
  
 def
  show
 (
 self
 ): 
  
  
  
 print
 (
 self
 .
 s) 
  
  
 def
  showMsg
 (
 self
 , msg): 
  
  
  
 print
 (msg
  +
  ':'
 , 
  
  
  
 self
 .
 show())
  # Calling another method
  
 if
  __name__
  ==
  ""__main__""
 : 
  
 # Create an object: 
  
 x
  =
  Simple(
 ""constructor argument""
 )
  
  
 30
  
 Chapter 10. Python for Programmers",NA
Useful Techniques,"• You can turn a list into function arguments using *:
  
 def
  f
 (a,b,c):
  print
  a, b, c 
  
 x
  =
  [
 1
 ,
 2
 ,
 3
 ] 
  
 f(
 *
 x) 
  
 f(
 *
 (
 1
 ,
 2
 ,
 3
 ))
  
 • You can compose classes using import. Here’s a method that can be reused by multiple classes:
  
 # PythonForProgrammers/utility.py 
  
 def
  f
 (
 self
 ):
  print
  ""utility.f()!!!""
  
 Here’s how you compose that method into a class:
  
 # PythonForProgrammers/compose.py 
  
 class
  Compose
 : 
  
  
 from
  utility
  import
  f
  
 Compose()
 .
 f()
  
 • Basic functional programming with map() etc.
  
 Note:
  Suggest Further Topics for inclusion in the introductory chapter",NA
Further Reading,"Python Programming FAQ:
  http://www.python.org/doc/faq/programming/
  
 Python idioms:
  http://jaynes.colorado.edu/PythonIdioms.html
  
 Python Tips, Tricks and Hacks:
  http://www.siafoo.net/article/52
  
 Building a Virtual Environment for Running Python 3: 
 virtualenv
  
 http://pypi.python.org/pypi/
  
 Excellent Newsfeed Following Python Articles from Everywhere:
  http://www.planetpython. org/
  
 10.6. Useful Techniques
  
 33",NA
CHAPTER,NA,NA
 11,NA,NA
Initialization and Cleanup,NA,NA
Initialization,"Constructor Calls 
  
 Automatic base-class constructor calls.
  
 Calling the base-class constructor first, how to do it using super(), why you should always call it first even if it’s 
 optional when to call it.
  
 __new__() vs. __init__() 
  
 Static Fields 
  
 An excellent example of the subtleties of initialization is static fields in classes.
  
 ::
  
 >>>
  class
  Foo
 (
 object
 ): 
  
 ... 
 x
  =
  ""a"" 
  
 ...
  
 >>>
  Foo
 .
 x 
  
 'a' 
  
 >>>
  f
  =
  Foo() 
  
 >>>
  f
 .
 x 
  
 'a' 
  
 >>>
  f2
  =
  Foo() 
  
 >>>
  f2
 .
 x 
  
 'a' 
  
 >>>
  f2
 .
 x
  =
  'b' 
  
 >>>
  f
 .
 x 
  
 'a' 
  
 >>>
  Foo
 .
 x
  =
  'c'
  
 35",NA
Cleanup,"Cleanup happens to globals by setting them to None (what about locals?). Does the act of setting them to None 
 cause __del__ to be called, or is __del__ called by Python before a global is set to None?
  
 Consider the following:
  
 class
  Counter
 : 
  
  
 Count
  =
  0 
  
 # This represents the count of objects of this class 
  
 def
  __init__
 (
 self
 , 
 name): 
  
  
  
 self
 .
 name
  =
  name 
  
  
  
 print
  name,
  'created' 
  
  
  
 Counter
 .
 Count
  +=
  1 
  
  
 def
  __del__
 (
 self
 ): 
  
  
  
 print self
 .
 name,
  'deleted' 
  
  
  
 Counter
 .
 Count
  -=
  1 
  
  
  
 if
  Counter
 .
 Count
  ==
  0
 : 
  
  
  
  
 print
  'Last Counter object deleted' 
  
  
  
 else
 : 
  
  
  
  
 print
  Counter
 .
 Count,
  'Counter objects remaining'
  
 x
  =
  Counter(
 ""First""
 ) 
  
 del
  x
  
 Without the final del, you get an exception. Shouldn’t the normal cleanup process take care of this?
  
 36
  
 Chapter 11. Initialization and Cleanup",NA
Further Reading,"11.3. Further Reading
  
 37",NA
CHAPTER,NA,NA
 12,NA,NA
Unit Testing & Test-Driven Development,"Note:
  This chapter has not had any significant translation yet. Should introduce and compare the various 
 common test systems.
  
 One of the important recent realizations is the dramatic value of unit testing.
  
 This is the process of building integrated tests into all the code that you create, and running those tests every 
 time you do a build. It’s as if you are extending the compiler, telling it more about what your program is 
 supposed to do. That way, the build process can check for more than just syntax errors, since you teach it how 
 to check for semantic errors as well.
  
 C-style programming languages, and C++ in particular, have typically valued performance over program-ming 
 safety. The reason that developing programs in Java is so much faster than in C++ (roughly twice as fast, by 
 most accounts) is because of Java’s safety net: features like better type checking, enforced exceptions and 
 garbage collection. By integrating unit testing into your build process, you are extending this safety net, and 
 the result is that you can develop faster. You can also be bolder in the changes that you make, and more easily 
 refactor your code when you discover design or implementation flaws, and in general produce a better 
 product, faster.
  
 Unit testing is not generally considered a design pattern; in fact, it might be considered a “development 
 pattern,” but perhaps there are enough “pattern” phrases in the world already. Its effect on development is so 
 significant that it will be used throughout this book, and thus will be introduced here.
  
 My own experience with unit testing began when I realized that every program in a book must be auto-
 matically extracted and organized into a source tree, along with appropriate makefiles (or some equivalent 
 technology) so that you could just type
  make
  to build the whole tree. The effect of this process on the code 
 quality of the book was so immediate and dramatic that it soon became (in my mind) a requisite for any 
 programming book-how can you trust code that you didn’t compile? I also discovered that if I wanted to make 
 sweeping changes, I could do so using search-and-replace throughout the book, and also bashing the code 
 around at will. I knew that if I introduced a flaw, the code extractor and the makefiles would flush it out.
  
 As programs became more complex, however, I also found that there was a serious hole in my system. Being 
 able to successfully compile programs is clearly an important first step, and for a published book it seemed
  
 39",NA
Write Tests First,"As I mentioned, one of the problems that I encountered-that most people encounter, it turns out-was sub-
 mitting to the pressures of publishing and as a result letting tests fall by the wayside. This is easy to do if you 
 forge ahead and write your program code because there’s a little voice that tells you that, after all, you’ve got 
 it working now, and wouldn’t it be more interesting/useful/expedient to just go on and write that other part 
 (we can always go back and write the tests later). As a result, the tests take on less impor-tance, as they often 
 do in a development project.
  
 The answer to this problem, which I first found described in
  Extreme Programming Explained
 , is to write the 
 tests
  before
  you write the code. This may seem to artificially force testing to the forefront of the development 
 process, but what it actually does is to give testing enough additional value to make it essential. If you write 
 the tests first, you:
  
 1. Describe what the code is supposed to do, not with some external graphical tool but with code that 
  
 actually lays the specification down in concrete, verifiable terms.
  
 2. Provide an example of how the code should be used; again, this is a working, tested example, nor-mally 
 showing all the important method calls, rather than just an academic description of a library.
  
 3. Provide a way to verify when the code is finished (when all the tests run correctly).
  
 Thus, if you write the tests first then testing becomes a development tool, not just a verification step that can 
 be skipped if you happen to feel comfortable about the code that you just wrote (a comfort, I have found, that 
 is usually wrong).
  
 You can find convincing arguments in
  Extreme Programming Explained
 , as “write tests first” is a fundamental 
 principle of XP. If you aren’t convinced you need to adopt any of the changes suggested by XP, note that 
 according to Software Engineering Institute (SEI) studies, nearly 70% of software organizations are stuck in 
 the first two levels of SEI’s scale of sophistication: chaos, and slightly better than chaos. If you change nothing 
 else, add automated testing.",NA
Simple Python Testing,"Sanity check for a quick test of the programs in this book, and to append the output of each program (as a 
 string) to its listing:
  
 1
  http://www.junit.org
  
 40
  
 Chapter 12. Unit Testing & Test-Driven Development",NA
A Very Simple Framework,"As mentioned, a primary goal of this code is to make the writing of unit testing code very simple, even simpler 
 than with JUnit. As further needs are discovered
  during the use
  of this system, then that functionality can be 
 added, but to start with the framework will just provide a way to easily create and run tests, and report 
 failure if something breaks (success will produce no results other than normal output that may occur during 
 the running of the test). My intended use of this framework is in makefiles, and
  make
  aborts if there is a non- 
 zero return value from the execution of a command. The build process will consist of compilation of the 
 programs and execution of unit tests, and if
  make
  gets all the way through successfully then the system will 
 be validated, otherwise it will abort at the place of failure. The error messages will report the test that failed 
 but not much else, so that you can provide whatever granularity that you need by writing as many tests as 
 you want, each one covering as much or as little as you find necessary.
  
 In some sense, this framework provides an alternative place for all those “print” statements I’ve written and 
 later erased over the years.
  
 To create a set of tests, you start by making a
  static
  inner class inside the class you wish to test (your test code 
 may also test other classes; it’s up to you). This test code is distinguished by inheriting from
  UnitTest
 :
  
 # UnitTesting/UnitTest.py 
  
 # The basic unit testing class
  
  
 12.3. A Very Simple Framework
  
 41",NA
Writing Tests,"Writing tests becomes very simple. Here’s an example that creates the necessary
  static
  inner class and 
 performs trivial tests:
  
 # UnitTesting/TestDemo.py 
  
 # Creating a test
  
 class
  TestDemo
 : 
  
  
 objCounter
  =
  0 
  
  
 id
  = ++
 objCounter 
  
  
 def
  TestDemo
 (String s): 
  
  
  
 print
 (s
  +
  "": count = ""
  +
  id
 )
  
 def
  close
 (
 self
 ): 
  
  
 print
 (
 ""Cleaning up: ""
  +
  id
 )
  
 def
  someCondition
 (
 self
 ):
  return True 
  
 class
  Test
 (UnitTest): 
  
  
 TestDemo test1
  =
  TestDemo(
 ""test1""
 ) 
  
  
 TestDemo test2
  =
  TestDemo(
 ""test2""
 ) 
  
  
 def
  cleanup
 (
 self
 ): 
  
  
 test2
 .
 close() 
  
  
 test1
 .
 close()
  
 def
  testA
 (
 self
 ): 
  
 print
 (
 ""TestDemo.testA""
 ) 
  
 affirm(test1
 .
 someCondition())
  
 def
  testB
 (
 self
 ):
  
  
  
 2
  I had originally called this
  assert()
 , but that word 
 42
  
  became reserved in JDK 1.4 when assertions were added to the language.
  
 Chapter 12. Unit Testing & Test-Driven Development",NA
White-Box & Black-Box Tests,"The unit test examples so far are what are traditionally called
  white-box tests
 . This means that the test code 
 has complete access to the internals of the class that’s being tested (so it might be more appropriately 
 called“transparent box” testing). White-box testing happens automatically when you make the unit test class 
 as an inner class of the class being tested, since inner classes automatically have access to all their outer class 
 elements, even those that are
  private
 .
  
 A possibly more common form of testing is
  black-box testing
 , which refers to treating the class under test as 
 an impenetrable box. You can’t see the internals; you can only access the
  public
  portions of the class. Thus, 
 black-box testing corresponds more closely to functional testing, to verify the methods that the client 
 programmer is going to use. In addition, black-box testing provides a minimal instruction sheet to the client 
 programmer - in the absence of all other documentation, the black-box tests at least demonstrate how to 
 make basic calls to the
  public
  class methods.
  
 To perform black-box tests using the unit-testing framework presented in this book, all you need to do is 
 create your test class as a global class instead of an inner class. All the other rules are the same (for example, 
 the unit test class must be
  public
 , and derived from
  UnitTest
 ).
  
 There’s one other caveat, which will also provide a little review of Java packages. If you want to be com-
 pletely rigorous, you must put your black-box test class in a separate directory than the class it tests, oth-
 erwise it will have package access to the elements of the class being tested. That is, you’ll be able to access 
 protected
  and
  friendly
  elements of the class being tested. Here’s an example:
  
 # UnitTesting/Testable.py
  
 class
  Testable
 : 
  
 def
  f1
 ():
  pass 
  
 def
  f2
 (
 self
 ):
  pass
  # ""Friendly"": package access 
 def
  f3
 (
 self
 ):
  pass
  # 
 Also package access 
  
 def
  f4
 (
 self
 ):
  pass
  
 Normally, the only method that should be directly accessible to the client programmer is
  f4( )
 . However, if 
 you put your black-box test in the same directory, it automatically becomes part of the same package (in this 
 case, the default package since none is specified) and then has inappropriate access:
  
 # UnitTesting/TooMuchAccess.py 
  
 class
  TooMuchAccess
 (UnitTest):
  
  
 44
  
 Chapter 12. Unit Testing & Test-Driven Development",NA
Running tests,"The program that runs the tests makes significant use of reflection so that writing the tests can be simple for 
 the client programmer:
  
 # UnitTesting/RunUnitTests.py 
  
 # Discovering the unit test 
  
 # class and running each test.
  
 class RunUnitTests: 
  
  
 def require(requirement, errmsg): 
  
  
  
 if(!requirement): 
  
  
  
  
 print(errmsg) 
  
  
  
  
 sys.exit()
  
 def main(self, args):
  
  
 12.6. Running tests
  
 45",NA
Automatically Executing Tests,NA,NA
Exercises,"1. Install this book’s source code tree and ensure that you have a
  make
  utility installed on your system 
 (Gnu
  make
  is freely available on the internet at various locations). In
  TestDemo.py
 , un-comment 
 test3( )
 , then type
  make
  and observe the results.
  
 2. Modify TestDemo.py by adding a new test that throws an exception. Type
  make
  and observe the 
  
 results.
  
 3. Modify your solutions to the exercises in Chapter 1 by adding unit tests. Write makefiles that incor-
  
 porate the unit tests.
  
 12.7. Automatically Executing Tests
  
 47",NA
CHAPTER,NA,NA
 13,NA,NA
Python 3 Language Changes,"Covers language features that don’t require their own chapters.
  
 Note:
  If a section in this chapter grows too large it may require its own chapter.
  
 49",NA
CHAPTER,NA,NA
 14,NA,NA
Decorators,"Note:
  This chapter is a work in progress; it’s probably better if you don’t begin making changes until I’ve 
 finished the original version, which is being posted as a series on my weblog.
  
 This amazing feature appeared in the language almost apologetically and with concern that it might not be 
 that useful.
  
 I predict that in time it will be seen as one of the more powerful features in the language. The problem is that 
 all the introductions to decorators that I have seen have been rather confusing, so I will try to rectify that 
 here.",NA
Decorators vs. the Decorator Pattern,"First, you need to understand that the word “decorator” was used with some trepidation in Python, because 
 there was concern that it would be completely confused with the
  Decorator
  pattern from the
  Design Patterns 
 book
 . At one point other terms were considered for the feature, but “decorator” seems to be the one that 
 sticks.
  
 Indeed, you can use Python decorators to implement the
  Decorator
  pattern, but that’s an extremely limited 
 use of it. Python decorators, I think, are best equated to macros.",NA
History of Macros,"The macro has a long history, but most people will probably have had experience with C preprocessor 
 macros. The problems with C macros were (1) they were in a different language (not C) and (2) the behavior 
 was sometimes bizarre, and often inconsistent with the behavior of the rest of C.
  
 Both Java and C# have added
  annotations
 , which allow you to do some things to elements of the language. 
 Both of these have the problems that (1) to do what you want, you sometimes have to jump through some
  
 51",NA
The Goal of Macros,"I think it’s safe to say that the goal of macros in a language is to provide a way to modify elements of the 
 language. That’s what decorators do in Python – they modify functions, and in the case of
  class decorators
 , 
 entire classes. This is why they usually provide a simpler alternative to metaclasses.
  
 The major failings of most language’s self-modification approaches are that they are too restrictive and that 
 they require a different language (I’m going to say that Java annotations with all the hoops you must jump 
 through to produce an interesting annotation comprises a “different language”).
  
 Python falls into Fowler’s category of “enabling” languages, so if you want to do modifications, why create a 
 different or restricted language? Why not just use Python itself? And that’s what Python decorators do.",NA
What Can You Do With Decorators?,"Decorators allow you to inject or modify code in functions or classes. Sounds a bit like
  Aspect-Oriented 
 Programming
  (AOP) in Java, doesn’t it? Except that it’s both much simpler and (as a result) much more 
 powerful. For example, suppose you’d like to do something at the entry and exit points of a function (such as 
 perform some kind of security, tracing, locking, etc. – all the standard arguments for AOP). With decorators, it 
 looks like this:
  
 @entryExit 
  
 def
  func1
 (): 
  
  
 print
 (
 ""inside func1()""
 )
  
 @entryExit 
  
 def
  func2
 (): 
  
  
 print
 (
 ""inside func2()""
 )
  
 The @ indicates the application of the decorator.",NA
Function Decorators,"A function decorator is applied to a function definition by placing it on the line before that function defini-tion 
 begins. For example:
  
 @myDecorator 
  
 def
  aFunction
 (): 
  
  
 print
 (
 ""inside aFunction""
 )
  
 When the compiler passes over this code, aFunction() is compiled and the resulting function object is passed 
 to the myDecorator code, which does something to produce a function-like object that is then substituted for 
 the original aFunction().
  
 52
  
 Chapter 14. Decorators",NA
Slightly More Useful,"Now let’s go back and implement the first example. Here, we’ll do the more typical thing and actually use the 
 code in the decorated functions:
  
 # PythonDecorators/entry_exit_class.py 
  
 class
  entry_exit
 (
 object
 ):
  
 def
  __init__
 (
 self
 , f): 
  
  
 self
 .
 f
  =
  f
  
 def
  __call__
 (
 self
 ): 
  
 print
 (
 ""Entering""
 ,
  self
 .
 f
 .
 __name__
 ) 
  
 self
 .
 f() 
  
 print
 (
 ""Exited""
 ,
  self
 .
 f
 .
 __name__
 )
  
 @entry_exit 
  
 def
  func1
 (): 
  
  
 print
 (
 ""inside func1()""
 )
  
 @entry_exit 
  
 def
  func2
 (): 
  
  
 print
 (
 ""inside func2()""
 )
  
 func1() 
  
 func2()
  
 The output is:
  
 Entering func1 
  
 inside func1() 
  
 Exited func1 
  
 Entering func2 
  
 inside func2() 
  
 Exited func2
  
 You can see that the decorated functions now have the “Entering” and “Exited” trace statements around the 
 call.
  
 The constructor stores the argument, which is the function object. In the call, we use the __name__ attribute of 
 the function to display that function’s name, then call the function itself.",NA
Using Functions as Decorators,"The only constraint on the result of a decorator is that it be callable, so it can properly replace the decorated 
 function. In the above examples, I’ve replaced the original function with an object of a class that has a 
 __call__() method. But a function object is also callable, so we can rewrite the previous example using a 
 function instead of a class, like this:
  
 54
  
 Chapter 14. Decorators",NA
Review: Decorators without Arguments,"If we create a decorator without arguments, the function to be decorated is passed to the constructor, and the 
 __call__() method is called whenever the decorated function is invoked:
  
 # PythonDecorators/decorator_without_arguments.py 
 class
  
 decorator_without_arguments
 (
 object
 ):
  
 def
  __init__
 (
 self
 , f): 
  
 """""" 
  
 If there are no decorator arguments, the function to be decorated is 
 passed to the constructor.
  
 """""" 
  
 print
 (
 ""Inside __init__()""
 ) 
  
 self
 .
 f
  =
  f
  
  
 14.8. Review: Decorators without Arguments
  
 55",NA
Decorators with Arguments,"The decorator mechanism behaves quite differently when you pass arguments to the decorator.
  
 Let’s modify the above example to see what happens when we add arguments to the decorator:
  
 # PythonDecorators/decorator_with_arguments.py 
 class
  
 decorator_with_arguments
 (
 object
 ):
  
 def
  __init__
 (
 self
 , arg1, arg2, arg3): 
  
 """""" 
  
 If there are decorator arguments, the function to be decorated is not 
 passed to the constructor!
  
 """""" 
  
 print
 (
 ""Inside __init__()""
 ) 
  
 self
 .
 arg1
  =
  arg1 
  
 self
 .
 arg2
  =
  arg2
  
  
 56
  
 Chapter 14. Decorators",NA
Decorator Functions with Decorator Arguments,"Finally, let’s look at the more complex decorator function implementation, where you have to do everything all 
 at once:
  
 # PythonDecorators/decorator_function_with_arguments.py 
 def
  
 decorator_function_with_arguments
 (arg1, arg2, arg3): 
  
 def
  wrap
 (f): 
  
  
  
 print
 (
 ""Inside wrap()""
 ) 
  
  
  
 def
  wrapped_f
 (
 *
 args): 
  
  
  
  
 print
 (
 ""Inside wrapped_f()""
 ) 
  
  
  
  
 print
 (
 ""Decorator arguments:""
 , arg1, arg2, arg3) 
   
  
 f(
 *
 args) 
  
  
  
  
 print
 (
 ""After f(*args)""
 ) 
  
  
  
 return
  wrapped_f 
  
  
 return
  wrap
  
 @decorator_function_with_arguments
 (
 ""hello""
 ,
  ""world""
 ,
  42
 ) 
 def
  sayHello
 (a1, 
 a2, a3, a4): 
  
  
 print
 (
 'sayHello arguments:'
 , a1, a2, a3, a4)
  
 print
 (
 ""After decoration""
 )
  
 print
 (
 ""Preparing to call sayHello()""
 ) 
  
 sayHello(
 ""say""
 ,
  ""hello""
 ,
  ""argument""
 ,
  ""list""
 ) 
  
 print
 (
 ""after first sayHello() call""
 ) 
  
 sayHello(
 ""a""
 ,
  ""different""
 ,
  ""set of""
 ,
  ""arguments""
 ) 
 print
 (
 ""after second 
 sayHello() call""
 )
  
 Here’s the output:
  
 Inside wrap() 
  
 After decoration 
  
 Preparing to call sayHello() 
  
 Inside wrapped_f() 
  
 Decorator arguments: hello world
  42 
  
 sayHello arguments: say hello argument
  list 
  
 After f(
 *
 args) 
  
 after first sayHello() call 
  
 Inside wrapped_f() 
  
 Decorator arguments: hello world
  42 
  
 sayHello arguments: a different
  set
  of arguments After f(
 *
 args) 
  
 after second sayHello() call
  
 The return value of the decorator function must be a function used to wrap the function to be decorated. That 
 is, Python will take the returned function and call it at decoration time, passing the function to be decorated. 
 That’s why we have three levels of functions; the inner one is the actual replacement function.
  
 Because of closures, wrapped_f() has access to the decorator arguments arg1, arg2 and arg3,
  without 
 having 
 to explicitly store them as in the class version. However, this is a case where I find “explicit is better than 
 implicit,” so even though the function version is more succinct I find the class version easier to understand 
 and thus to modify and maintain.
  
 58
  
 Chapter 14. Decorators",NA
Further Reading,"http://wiki.python.org/moin/PythonDecoratorLibrary
  More examples of decorators. Note the 
 number of these examples that use classes rather than functions as decorators.
  
 http://scratch.tplus1.com/decoratortalk
  Matt Wilson’s
  Decorators Are Fun
 .
  
 http://loveandtheft.org/2008/09/22/python-decorators-explained
  Another introduction to 
 dec-orators.
  
 http://www.siafoo.net/article/68 
  
 http://www.ddj.com/web-development/184406073
  Philip Eby introduces 
 decorators.
  
 http://www.informit.com/articles/article.aspx?p=1309289&seqNum=4
  Class Decorators. 
 http://www.phyast.pitt.edu/~micheles/python/documentation.html
  Michele Simionato’s 
 dec-orator module wraps functions for you. The page includes an introduction and some ex-
 amples.
  
 http://www.blueskyonmars.com/projects/paver/
  Kevin Djangoor’s replacement for make; 
 heavy use of decorators.
  
 http://blog.doughellmann.com/2009/01/converting-from-make-to-paver.html
  Doug 
 Hellman describes the experience of converting from make to paver.
  
 http://www.informit.com/articles/article.aspx?p=1309289&seqNum=4
  Class decorators
  
 14.11. Further Reading
  
 59",NA
CHAPTER,NA,NA
 15,NA,NA
Metaprogramming,"Note:
  This chapter is written using Python 2.6 syntax; it will be converted to Python 3 at a later date.
  
 Objects are created by other objects: special objects called “classes” that we can set up to spit out objects that 
 are configured to our liking.
  
 Classes are just objects, and they can be modified the same way:
  
 >>>
  class
  Foo
 :
  pass 
  
 ...
  
 >>>
  Foo
 .
 field
  =
  42 
  
 >>>
  x
  =
  Foo() 
  
 >>>
  x
 .
 field 
  
 42 
  
 >>>
  Foo
 .
 field2
  =
  99 
  
 >>>
  x
 .
 field2 
  
 99 
  
 >>>
  Foo
 .
 method
  =
  lambda
  self
 :
  ""Hi!"" 
  
 >>>
  x
 .
 method() 
  
 'Hi!'
  
 To modify a class, you perform operations on it like any other object. You can add and subtract fields and 
 methods, for example. The difference is that any change you make to a class affects all the objects of that class, 
 even the ones that have already been instantiated.
  
 What creates these special “class” objects? Other special objects, called metaclasses.
  
 The default metaclass is called type and in the vast majority of cases it does the right thing. In some situations, 
 however, you can gain leverage by modifying the way that classes are produced – typically by performing 
 extra actions or injecting code. When this is the case, you can use
  metaclass programming
  to modify the way 
 that some of your class objects are created.
  
 It’s worth re-emphasizing that in
  the vast majority of cases, you don’t need metaclasses
 , because it’s a fascinating 
 toy and the temptation to use it everywhere can be overwhelming. Some of the examples in this chapter
  
 61",NA
Basic Metaprogramming,"So metaclasses create classes, and classes create instances. Normally when we write a class, the default 
 metaclass type is automatically invoked to create that class, and we aren’t even aware that it’s happening.
  
 It’s possible to explicitly code the metaclass’ creation of a class. type called with one argument produces the 
 type information of an existing class; type called with three arguments creates a new class object. The 
 arguments when invoking type are the name of the class, a list of base classes, and a dictionary giving the 
 namespace for the class (all the fields and methods). So the equivalent of:
  
 class
  C
 :
  pass
  
 is:
  
 C
  =
  type
 (
 'C'
 , (), {})
  
 Classes are often referred to as “types,” so this reads fairly sensibly: you’re calling a function that creates a new 
 type based on its arguments.
  
 We can also add base classes, fields and methods:
  
 # Metaprogramming/MyList.py
  
 def
  howdy
 (
 self
 , you): 
  
  
 print
 (
 ""Howdy, ""
  +
  you)
  
 MyList
  =
  type
 (
 'MyList'
 , (
 list
 ,),
  dict
 (x
 =
 42
 , howdy
 =
 howdy))
  
 ml
  =
  MyList() 
  
 ml
 .
 append(
 ""Camembert""
 ) 
  
 print
 (ml) 
  
 print
 (ml
 .
 x) 
  
 ml
 .
 howdy(
 ""John""
 )
  
 print
 (ml
 .
 __class__
 .
 __class__
 )
  
 """""" Output: 
  
 ['Camembert'] 
  
 42 
  
 Howdy, John 
  
 """"""
  
 Note that printing the class of the class produces the metaclass.
  
 The ability to generate classes programmatically using type opens up some interesting possibilities. Con-sider 
 the GreenHouseLanguage.py example in the Jython chapter – all the subclasses in that case were written 
 using repetetive code. We can automate the generation of the subclasses using type:
  
 # Metaprogramming/GreenHouse.py
  
  
 62
  
 Chapter 15. Metaprogramming",NA
The Metaclass Hook,"So far, we’ve only used the type metaclass directly. Metaclass programming involves hooking our own 
 operations into the creation of class objects. This is accomplished by:
  
 1. Writing a subclass of the metaclass type.
  
 2. Inserting the new metaclass into the class creation process using the
  metaclass hook
 .
  
 In Python 2.x, the metaclass hook is a static field in the class called __metaclass__. In the ordinary case, this is 
 not assigned so Python just uses type to create the class. But if you define __metaclass__ to point to a callable, 
 Python will call __metaclass__() after the initial creation of the class object, passing in the class object, the 
 class name, the list of base classes and the namespace dictionary.
  
 Python 2.x also allows you to assign to the global __metaclass__ hook, which will be used if there is not a class-
 local __metaclass__ hook (is there an equivalent in Python 3?).
  
 Thus, the basic process of metaclass programming looks like this:
  
 # Metaprogramming/SimpleMeta1.py 
  
 # Two-step metaclass creation in Python 2.x
  
 class
  SimpleMeta1
 (
 type
 ): 
  
  
 def
  __init__
 (
 cls
 , name, bases, nmspc): 
  
  
  
 super
 (SimpleMeta1,
  cls
 )
 .
 __init__
 (name, bases, nmspc) 
  
  
 cls
 .
 uses_metaclass
  =
  lambda
  self
  :
  ""Yes!""
  
 class
  Simple1
 (
 object
 ): 
  
 __metaclass__
  =
  SimpleMeta1 
  
 def
  foo
 (
 self
 ):
  pass 
  
 @staticmethod 
  
 def
  bar
 ():
  pass
  
 simple
  =
  Simple1() 
  
 print
 ([m
  for
  m
  in
  dir
 (simple)
  if not
  m
 .
 startswith(
 '__'
 )]) 
 # A new method has been 
 injected by the metaclass: 
  
 print
  simple
 .
 uses_metaclass()
  
  
 64
  
 Chapter 15. Metaprogramming",NA
Example: Self-Registration of Subclasses,"It is sometimes convienient to use inheritance as an organizing mechanism – each sublclass becomes an 
 element of a group that you work on. For example, in
  CodeManager.py
  in the
  Comprehensions
  chapter, the 
 subclasses of
  Language
  were all the languages that needed to be processed. Each
  Language
  subclass 
 described specific processing traits for that language.
  
 To solve this problem, consider a system that automatically keeps a list of all of its “leaf” subclasses (only the 
 classes that have no inheritors). This way we can easily enumerate through all the subtypes:
  
 # Metaprogramming/RegisterLeafClasses.py
  
 class
  RegisterLeafClasses
 (
 type
 ): 
  
  
 def
  __init__
 (
 cls
 , name, bases, nmspc): 
  
  
  
 super
 (RegisterLeafClasses,
  cls
 )
 .
 __init__
 (name, bases, nmspc) 
   
 if not
  hasattr
 (
 cls
 ,
  
 'registry'
 ): 
  
  
  
  
 cls
 .
 registry
  =
  set
 () 
  
  
  
 cls
 .
 registry
 .
 add(
 cls
 ) 
  
  
  
 cls
 .
 registry
  -=
  set
 (bases)
  # Remove base classes 
  
  
 # Metamethods, called on class objects: 
  
  
 def
  __iter__
 (
 cls
 ): 
  
  
  
 return
  iter
 (
 cls
 .
 registry) 
  
  
 def
  __str__
 (
 cls
 ): 
  
  
  
 if
  cls
  in
  cls
 .
 registry: 
  
  
  
  
 return
  cls
 .
 __name__ 
  
  
  
 return
  cls
 .
 __name__
  +
  "": ""
  +
  "", ""
 .
 join([sc
 .
 __name__
  for
  sc
  in
  cls
 ])
  
 class
  Color
 (
 object
 ): 
  
  
 __metaclass__
  =
  RegisterLeafClasses
  
 class
  Blue
 (Color):
  pass 
  
 class
  Red
 (Color):
  pass 
  
 class
  Green
 (Color):
  pass 
  
 class
  Yellow
 (Color):
  pass 
  
 print
 (Color) 
  
 class
  PhthaloBlue
 (Blue):
  pass 
  
 class
  CeruleanBlue
 (Blue):
  pass 
  
 print
 (Color)
  
  
 66
  
 Chapter 15. Metaprogramming",NA
Example: Making a Class “Final”,"It is sometimes convenient to prevent a class from being inherited:
  
 # Metaprogramming/Final.py 
  
 # Emulating Java's 'final'
  
 class
  final
 (
 type
 ): 
  
  
 def
  __init__
 (
 cls
 , name, bases, namespace): 
  
  
  
 super
 (final,
  cls
 )
 .
 __init__
 (name, bases, namespace) 
  
  
  
 for
  klass
  in
  bases: 
  
  
  
  
 if
  isinstance
 (klass, final): 
  
  
  
  
  
 raise
  TypeError
 (
 str
 (klass
 .
 __name__
 )
  +
  "" is final""
 )
  
  
 15.4. Example: Making a Class “Final”
  
 67",NA
Using __init__ vs. __new__ in Metaclasses,"It can be confusing when you see metaclass examples that appear to arbitrarily use __new__ or __init__– why 
 choose one over the other?
  
 __new__ is called for the creation of a new class, while __init__ is called after the class is created, to perform 
 additional initialization before the class is handed to the caller:
  
 # Metaprogramming/NewVSInit.py 
  
 from
  pprint
  import
  pprint
  
 class
  Tag1
 :
  pass 
  
 class
  Tag2
 :
  pass 
  
 class
  Tag3
 : 
  
  
 def
  tag3_method
 (
 self
 ):
  pass
  
 class
  MetaBase
 (
 type
 ): 
  
  
 def
  __new__
 (mcl, name, bases, nmspc): 
  
  
  
 print
 (
 'MetaBase.__new__
 \n
 '
 ) 
  
  
  
 return
  super
 (MetaBase, mcl)
 .
 __new__
 (mcl, name, bases, nmspc)
  
 def
  __init__
 (
 cls
 , name, bases, nmspc): 
  
 print
 (
 'MetaBase.__init__
 \n
 '
 ) 
  
 super
 (MetaBase,
  cls
 )
 .
 __init__
 (name, bases, nmspc)
  
 class
  MetaNewVSInit
 (MetaBase): 
  
  
 def
  __new__
 (mcl, name, bases, nmspc):
  
  
 68
  
 Chapter 15. Metaprogramming",NA
Class Methods and Metamethods,"A metamethod can be called from either the metaclass or from the class, but not from an instance. A 
 classmethod can be called from either a class or its instances, but is not part of the metaclass.
  
 (Is a similar relationship true with attributes, or is it different?)
  
 Intercepting Class Creation
  
 This example implements
  Singleton
  using metaclasses, by overriding the __call__() metamethod, which is 
 invoked when a new instance is created:
  
 # Metaprogramming/Singleton.py
  
 class
  Singleton
 (
 type
 ):
  
 instance
  =
  None
  
 def
  __call__
 (
 cls
 ,
  *
 args,
  **
 kw): 
  
  
 if not
  cls
 .
 instance:
  
  
 cls
 .
 instance
  =
  super
 (Singleton,
  cls
 )
 .
 __call__
 (
 *
 args,
  **
 kw) 
 return
  cls
 .
 instance
  
  
 70
  
 Chapter 15. Metaprogramming",NA
The __prepare__() Metamethod,"One of the things you
  can’t
  do with class decorators is to replace the default dictionary. In Python 3 this is
  
 enabled with the __prepare__() metamethod:
  
 @classmethod 
  
 def
  __prepare__
 (mcl, name, bases): 
  
  
 return
  odict()
  
 For an example of using both __prepare__() and __slots__ in metaclasses, see
  Michele Simionato’s
  
 article
 .
  
 72
  
 Chapter 15. Metaprogramming",NA
Module-level __metaclass__ Assignment,(Does this work in Python 3? If not is there an alternative?),NA
Metaclass Conflicts,"Note that the metaclass argument is singular – you can’t attach more than one metaclass to a class. However, 
 through multiple inheritance you can
  accidentally
  end up with more than one metaclass, and this produces a 
 conflict which must be resolved.
  
 http://code.activestate.com/recipes/204197/",NA
Further Reading,"Excellent step-by-step introduction to metaclasses:
  http://cleverdevil.org/computing/78/ 
 Metaclass intro and comparison of syntax between Python 2.x and 3.x:
  http://mikewatkins.
  
 ca/2008/11/29/python-2-and-3-metaclasses/ 
  
 David Mertz’s metaclass primer:
  http://www.onlamp.com/pub/a/python/2003/04/17/ 
  
 metaclasses.html 
  
 Three-part in-depth coverage of metaclasses on IBM Developer Works. Quite useful and 
 authoritative:
  
  
 •
  http://www.ibm.com/developerworks/linux/library/l-pymeta.html
  
  
 •
  http://www.ibm.com/developerworks/linux/library/l-pymeta2/
  
  
 •
  http://www.ibm.com/developerworks/linux/library/l-pymeta3.html 
  
 Michele Simionato’s articles on Artima, with special emphasis on the difference between Python 2.x and 3.x 
 metac
  
  
 •
  http://www.artima.com/weblogs/viewpost.jsp?thread=236234
  
  
 •
  http://www.artima.com/weblogs/viewpost.jsp?thread=236260 
  
 Once you understand the foundations, you can find lots of examples by searching for “meta-class” 
 within the Python Cookbook:
  http://code.activestate.com/recipes/langs/python/ 
 The printed 
 version of the Python Cookbook has far fewer examples than the online version, but the print 
 version has been filtered and edited and so tends to be more authoritative.
  
 Ian Bicking writes about metaclasses:
  
   
 •
  http://blog.ianbicking.org/a-conservative-metaclass.html
  
   
 •
  http://blog.ianbicking.org/metaclass-fun.html
  
   
 •
  http://blog.ianbicking.org/A-Declarative-Syntax-Extension.html
  
   
 •
  http://blog.ianbicking.org/self-take-two.html 
  
 Lots of good information about classes, types, metaclasses, etc., including historical stuff in the 
 Python 2.2 docs (is this duplicated in later versions of the docs):
  
 •
  http://www.python.org/download/releases/2.2/descrintro/ 
  
 For more advanced study, the book
  Putting Metaclasses to Work
 .",NA
CHAPTER,NA,NA
 16,NA,NA
"Generators, Iterators, and Itertools",75,NA
CHAPTER,NA,NA
 17,NA,NA
Comprehensions,"History: where did they come from?
  
 They require a mind shift.
  
 What makes them so compelling (once you ‘get it’)?
  
 Comprehensions are constructs that allow sequences to be built from other sequences. Python 2.0 intro-duced 
 list comprehensions and Python 3.0 comes with dictionary and set comprehensions.",NA
List Comprehensions,"A list comprehension consists of the following parts:
  
  
 • An Input Sequence.
  
 • A Variable representing members of the input sequence.
  
 • An Optional Predicate expression.
  
 • An Output Expression producing elements of the output list from members of the Input Sequence 
  
 that satisfy the predicate.
  
 Say we need to obtain a list of all the integers in a sequence and then square them:
  
 a_list = [1, ‘4’, 9, ‘a’, 0, 4] 
  
 squared_ints = [ e**2 for e in a_list if type(e) == types.IntType ] print squared_ints 
  
 # [ 1, 81, 0, 16 ]
  
 77",NA
Nested Comprehensions,"An identity matrix of size n is an n by n square matrix with ones on the main diagonal and zeros elsewhere. A 3 
 by 3 identity matrix is:
  
 78
  
 Chapter 17. Comprehensions",NA
Techniques,"Using zip() and dealing with two or more elements at a time:
  
 [
 '
 %s
 =
 %s
 '
  %
  (n, v)
  for
  n, v
  in
  zip
 (
 self
 .
 all_names,
  self
 )]
  
 Multiple types (auto unpacking of a tuple):
  
 [f(v)
  for
  (n, f), v
  in
  zip
 (
 cls
 .
 all_slots, values)]
  
 A two-level list comprehension using os.walk():
  
 # Comprehensions/os_walk_comprehension.py 
  
 import
  os 
  
 restFiles
  =
  [os
 .
 path
 .
 join(d[
 0
 ], f)
  for
  d
  in
  os
 .
 walk(
 "".""
 ) 
  
  
 for
  f
  in
  d[
 2
 ]
  if
  
 f
 .
 endswith(
 "".rst""
 )] 
  
 for
  r
  in
  restFiles: 
  
  
 print
 (r)
  
  
 17.3. Techniques
  
 79",NA
A More Complex Example,"Note:
  This will get a full description of all parts.
  
 # CodeManager.py 
  
 """""" 
  
 TODO: Break check into two pieces?
  
 TODO: update() is still only in test mode; doesn't actually work yet.
  
 Extracts, displays, checks and updates code examples in restructured text (.rst) files.
  
 You can just put in the codeMarker and the (indented) first line (containing the file path) into your restructured text 
 file, then run the update program to automatically insert the rest of the file.
  
 """""" 
  
 import
  os
 ,
  re
 ,
  sys
 ,
  shutil
 ,
  inspect
 ,
  difflib
  
 restFiles
  =
  [os
 .
 path
 .
 join(d[
 0
 ], f)
  for
  d
  in
  os
 .
 walk(
 "".""
 )
  if not
  ""_test""
  in
  d[
 0
 ] 
  
 for
  f
  in
  d[
 2
 ]
  if
  f
 .
 endswith(
 "".rst""
 )]
  
 class
  Languages
 : 
  
  
 ""Strategy design pattern""
  
 class
  Python
 : 
  
 codeMarker
  =
  ""::
 \n\n
 "" 
  
 commentTag
  =
  ""#"" 
  
 listings
  =
  re
 .
 compile(
 ""::
 \n\n
 (
  {4}
 #.*(?:
 \n
 +
  {4}
 .*)*)""
 )
  
 class
  Java
 : 
  
  
 codeMarker
  =
  "".. 
  
 code-block:: java
 \n\n
 "" 
  
  
 commentTag
  =
  ""//"" 
  
  
 listings
  =
  \ 
  
  
 re
 .
 compile(
 "".. *code-block:: *java
 \n\n
 (
  {4}
 //.*(?:
 \n
 +
  {4}
 .*)*)""
 )
  
 def
  shift
 (listing): 
  
  
 ""Shift the listing left by 4 spaces"" 
  
  
 return
  [x[
 4
 :]
  if
  x
 .
 startswith(
 "" 
  
 ""
 )
  else
  x
  for
  x
  in
  listing
 .
 splitlines()]
  
 # TEST - makes duplicates of the rst files in a test directory to test update(): 
 dirs
  =
  set
 ([os
 .
 path
 .
 join(
 ""_test""
 , 
 os
 .
 path
 .
 dirname(f))
  for
  f
  in
  restFiles]) 
 if
  [os
 .
 makedirs(d)
  for
  d
  in
  dirs
  if not
  os
 .
 path
 .
 exists(d)]: 
  
  
 [shutil
 .
 copy(f, os
 .
 path
 .
 join(
 ""_test""
 , f))
  for
  f
  in
  restFiles] 
  
 testFiles
  =
  [os
 .
 path
 .
 join(d[
 0
 ], f)
  for
  d
  in
  os
 .
 walk(
 ""_test""
 ) 
  
  
  
 for
  f
  in
  d[
 2
 ]
  if
  f
 .
 endswith(
 "".rst""
 )]
  
 class
  Commands
 : 
  
 """""" 
  
 Each static method can be called from the command line. Add a new static method here to add a new 
 command to the program.
  
 """"""
  
 @staticmethod 
  
 def
  display
 (language): 
  
  
 """""" 
  
  
 Print all the code listings in the .rst files.
  
  
 80
  
 Chapter 17. Comprehensions",NA
Set Comprehensions,"Set comprehensions allow sets to be constructed using the same principles as list comprehensions, the only 
 difference is that resulting sequence is a set.
  
 Say we have a list of names. The list can contain names which only differ in the case used to represent them, 
 duplicates and names consisting of only one character. We are only interested in names longer then one 
 character and wish to represent all names in the same format: The first letter should be capitalised, all other 
 characters should be lower case.
  
 Given the list:
  
 names
  =
  [
  'Bob'
 ,
  'JOHN'
 ,
  'alice'
 ,
  'bob'
 ,
  'ALICE'
 ,
  'J'
 ,
  'Bob'
  ]
  
 We require the set:
  
 {
  'Bob'
 ,
  'John'
 ,
  'Alice'
  }
  
 Note the new syntax for denoting a set. Members are enclosed in curly braces.
  
 The following set comprehension accomplishes this:
  
 { name[
 0
 ]
 .
 upper()
  +
  name[
 1
 :]
 .
 lower()
  for
  name
  in
  names
  if
  len
 (name)
  >
  1
  }",NA
Dictionary Comprehensions,"Say we have a dictionary the keys of which are characters and the values of which map to the number of times 
 that character appears in some text. The dictionary currently distinguishes between upper and lower case 
 characters.
  
 We require a dictionary in which the occurrences of upper and lower case characters are combined:
  
 mcase
  =
  {
 'a'
 :
 10
 ,
  'b'
 :
  34
 ,
  'A'
 :
  7
 ,
  'Z'
 :
 3
 } 
  
 mcase_frequency
  =
  { k
 .
 lower() : mcase
 .
 get(k
 .
 lower(),
  0
 )
  +
  mcase
 .
 get(k
 .
 upper(),
  0
 )
  for
 ˓→
 k
  in
  mcase
 .
 keys() } 
  
 # mcase_frequency == {'a': 17, 'z': 3, 'b': 34}
  
  
 Note:
  Contributions by Michael Charlton, 3/23/09
  
 17.5. Set Comprehensions
  
 83",NA
CHAPTER,NA,NA
 18,NA,NA
"Coroutines, Concurrency & Distributed Systems","[[ Will probably need to expand this to multiple chapters: 
  
  
 1. Concurrency Concepts 
  
  
 2. Coroutines 
  
  
 3. Processes 
  
  
 4. Threads 
  
 (this isn’t final; may need different organization or finer grained. However, it should start with simpler 
 concepts and progress to the more difficult ones, as above.) 
  
 ]] 
  
 Primary focus should be on: 
  
  
 1. Using yield to create coroutines 
  
  
 2. Using the new multiprocessing module 
  
 and then showing some alternative techniques.
  
 foo bar input() baz.",NA
The GIL,"The GIL prevents context switches from happening in the middle of C code. Basically, it makes any C code into 
 a critical section, except when that C code explicitly releases the GIL. This greatly simplifies the task of writing 
 extension modules as well the Python core.
  
 The designers of Python made a design decision that extension writers would not have to take care of locking. 
 Thus, Python is intended to be simple/easy to integrate with any C library. In order to remove the GIL, you’d 
 have to go into all existing C code and write explicit locking/unlocking code, and you’d have to do this with 
 every new C library as well.
  
 [[ Description of how it supports/impacts reference-counted garbage collection]]
  
 85",NA
Multiprocessing,"Example by Michele Simionato in comp lang python. Here is an example of using multiprocessing (which is 
 included in Python 2.6 and easy_installable in older Python versions) to print a spin bar while a compu-tation 
 is running:
  
 import
  sys
 ,
  time 
  
 import
  multiprocessing 
  
 DELAY
  =
  0.1 
  
 DISPLAY
  =
  [
  '|'
 ,
  '/'
 ,
  '-'
 ,
  '
 \\
 '
  ] 
  
 def
  spinner_func
 (before
 =
 ''
 , after
 =
 ''
 ): 
  
  
 write, flush
  =
  sys
 .
 stdout
 .
 write, sys
 .
 stdout
 .
 flush 
  
 pos
  = -
 1 
  
  
 while True
 : 
  
  
  
 pos
  =
  (pos
  +
  1
 )
  %
  len
 (DISPLAY) 
  
  
  
 msg
  =
  before
  +
  DISPLAY[pos]
  +
  after 
  
  
  
 write(msg); flush() 
  
  
  
 write(
 '
 \x08
 '
  *
  len
 (msg)) 
  
  
  
 time
 .
 sleep(DELAY) 
  
 def
  long_computation
 (): 
  
  
 # emulate a long computation 
  
  
 time
 .
 sleep(
 3
 ) 
  
 if
  __name__
  ==
  '__main__'
 : 
  
  
 spinner
  =
  multiprocessing
 .
 Process( 
  
  
  
 None
 , spinner_func, args
 =
 (
 'Please wait ... '
 ,
  ''
 )) 
  
 spinner
 .
 start() 
  
  
 try
 : 
  
  
  
 long_computation() 
  
  
  
 print
  'Computation done' 
  
  
 finally
 : 
  
  
  
 spinner
 .
 terminate()
  
 On the Erlang mail list, four years ago, Erlang expert Joe Armstrong posted this:
  
 In Concurrency Oriented (CO) programming you concentrate on the concurrency and the mes-
 sages between the processes. There is no sharing of data.
  
 [A program] should be thought of thousands of little black boxes all doing things in parallel -these 
 black boxes can send and receive messages. Black boxes can detect errors in other black boxes - 
 that’s all. ... Erlang uses a simple functional language inside the [black boxes] - this is not 
 particularly interesting -
  any
  language that does the job would do - the important bit is the 
 concurrency.
  
 On the Squeak mail list in 1998, Alan Kay had this to say:
  
 ...Smalltalk is not only NOT its syntax or the class library, it is not even about classes. I’m sorry 
 that I long ago coined the term “objects” for this topic because it gets many people to focus on the 
 lesser idea.
  
 The big idea is “messaging” – that is what the kernal of Smalltalk/Squeak is all about... The key in 
 making great and growable systems is much more to design how its modules communicate rather 
 than what their internal properties and behaviors should be. Think of the internet – to live, it (a) 
 has to allow many different kinds of ideas and realizations that are beyond any single standard 
 and (b) to allow varying degrees of safe interoperability between these ideas.
  
 If you focus on just messaging – and realize that a good metasystem can late bind the various 2nd 
 level architectures used in objects – then much of the language-, UI-, and OS based discus-sions on 
 this thread are really quite moot.
  
 86
  
 Chapter 18. Coroutines, Concurrency & Distributed Systems",NA
Further Reading,"This article
  argues that large-scale parallelism – which is what multiprocessing supports – is the 
 more important problem to solve, and that functional languages don’t help that much with this 
 problem.
  
 http://jessenoller.com/2009/02/01/python-threads-and-the-global-interpreter-lock/
  
 18.3. Further Reading
  
 87",NA
CHAPTER,NA,NA
 19,NA,NA
Jython,"Note:
  
 This chapter is being brought up to date with Jython 2.5, and will need changes when Jython 3
  
 comes out.
  
 Note:
  Some of the descriptions in this chapter are introductory, so that the material can be used to introduce 
 Java programmers to Jython.
  
 Sometimes it’s easier and faster to temporarily step into another language to solve a particular aspect of your 
 problem.
  
 This chapter looks at the value of crossing language boundaries. It is often advantageous to solve a problem 
 using more than one programming language; as you’ll see, a problem that is very difficult or tedious to solve 
 in one language can often be solved quickly and easily in another. By combining languages, you can create 
 your product much more quickly and cheaply.
  
 One use of this idea is the
  Interpreter
  design pattern, which adds an interpreted language to your program to 
 allow the end user to easily customize a solution. If the application user needs greater run time flexibil-ity, for 
 example to create scripts describing the desired behavior of the system, you can use
  Interpreter
  by creating 
 and embedding a language interpreter into your program.
  
 In Java, the easiest and most powerful way to do this is with
  Jython
 1
 , an implementation of Python in pure Java 
 byte codes. As you will see, this brings together the benefits of both worlds.
  
 Jython is generated entirely in Java byte codes, so incorporating it into your application is quite simple, and 
 it’s as portable as Java is. It has an extremely clean interface with Java: Java can call Python classes, and 
 Python can call Java classes.
  
 Because Jython is just Java classes, it can often be “stealthed” into companies that have rigid processes for 
 using new languges and tools. If Java has been accepted, such companies often accept anything that runs on 
 the JVM without question.
  
  
 1
  The original version of this was called
  JPython
 , but the project changed and the name was changed to emphasize the distinctness of 
 the new version.
  
 89",NA
Installation,"To install Jython, go to
  http://jython.sourceforge.net
 .
  
 Note:
  Select “test the beta”.
  
 The download is a
  .class
  file, which will run an installer when you execute it using java -jar.
  
 You also need the Java Development Kit (JDK), and to add
  jython-complete.jar
  to your Java CLASSPATH. As 
 an example, here is the appropriate section in my .bashrc for
  *nix
 ; for Windows you need to do the 
 equivalent:
  
 export set JYTHON_HOME=""/Users/bruceeckel/jython2.5b0"" export set 
 CLASSPATH=.:..:$JYTHON_HOME/jython-complete.jar
  
  
 When you run Jython, you might get the warning:
  
 can't create package cache dir, '/
  
 cachedir/packages'. Jython will still work, but startup will be slower because caching isn’t happen-ing. Jython 
 caching requires /cachedir/packages/ in the python.home directory. It is often the case on
  *nix
  that users 
 lack sufficient priveleges to create or write to this directory. Because the problem is merely permissions, 
 something like mkdir cachedir; chmod a+rw cachedir within the Jython di-rectory should eliminate this 
 warning message.
  
 Getting the Trunk
  
 Note:
  This section has not been successfuly tested yet.
  
 The Jython development trunk is very stable so it’s safe to get as the most recent version of the implemen-
 tation. The subversion command is:
  
 svn co https:
 //
 jython
 .
 svn
 .
 sourceforge
 .
 net
 /
 svnroot
 /
 jython
 /
 trunk
 /
 jython
  
 Then just invoke ant against the build.xml file. dist/bin/jython is a shell script that starts up jython in console 
 mode. Lastly, modify the registry (in dist/registry) so that:
  
 python
 .
 console
 =
 org
 .
 python
 .
 util
 .
 ReadlineConsole 
 python
 .
 console
 .
 readlinelib
 =
 GnuReadline
  
 (readline is GPL, so it makes it a bit harder to automate this part of the distro). See:
  http://wiki.python. 
 org/jython/ReadlineSetup
  
 90
  
 Chapter 19. Jython",NA
Scripting,"One compelling benefit of using a dynamic language on the JVM is scripting. You can rapidly create and test 
 code, and solve problems more quickly.
  
 Here’s an example that shows a little of what you can do in a Jython script, and also gives you a sense of 
 performance:
  
 # Jython/Simple.py 
  
 import
  platform
 ,
  glob
 ,
  time 
  
 from
  subprocess
  import
  Popen, PIPE
  
 print
  platform
 .
 uname()
  # What are we running on?
  
 print
  glob
 .
 glob(
 ""*.py""
 )
  # Find files with .py extensions # Send a command to the 
 OS and capture the results: 
 print
  Popen([
 ""ping""
 ,
  ""-c""
 ,
  ""1""
 ,
  ""www.mindview.net""
 ], 
  
  
 stdout
 =
 PIPE)
 .
 communicate()[
 0
 ] 
  
 # Time an operation: 
  
 start
  =
  time
 .
 time() 
  
 for
  n
  in
  xrange(
 1000000
 ): 
  
  
 for
  i
  in
  xrange(
 10
 ): 
  
  
  
 oct
 (i) 
  
 print
  time
 .
 time()
  -
  start
  
 Note:
  The timeit module in the alpha distribution could not be used as it tries to turn off the Java garbage 
 collector.
  
 If you run this program under both cpython and Jython, you’ll see that the timed loop produces very similar 
 results; Jython 2.5 is in beta so this is quite impressive and should get faster – there’s even talk that Jython 
 could run faster than cpython, because of the optimization benefits of the JVM. The total runtime of the 
 cpython version is faster because of its rapid startup time; the JVM always has a delay for startup.
  
 Note that things that are very quick to write in Jython require much more code (and often research) in Java. 
 Here’s an example that uses a Python
  list comprehension
  with the
  os.walk()
  function to visit all the 
 directories in a directory tree, and find all the files with names that end in
  .java
  and contain the word 
 PythonInterpreter
 :
  
 # Jython/Walk_comprehension.py 
  
 import
  os 
  
 restFiles
  =
  [os
 .
 path
 .
 join(d[
 0
 ], f)
  for
  d
  in
  os
 .
 walk(
 "".""
 ) 
  
  
  
 for
  f
  in
  d[
 2
 ]
  if
  f
 .
 endswith(
 "".java""
 )
  and 
  
  
  
 ""PythonInterpreter""
  in
  open
 (os
 .
 path
 .
 join(d[
 0
 ], f))
 .
 read()] 
 for
  r
  in
  restFiles: 
  
  
 print
 (r)
  
 You can certainly achieve this in Java. It will just take a lot longer.
  
 Often more sophisticated programs begin as scripts, and then evolve. The fact that you can quickly try things 
 out allows you to test concepts, and then create more refined code as needed.
  
 19.2. Scripting
  
 91",NA
Interpreter Motivation,"Remember that each design pattern allows one or more factors to change, so it’s important to first be aware 
 of which factor is changing. Sometimes the end users of your application (rather than the programmers of 
 that application) need complete flexibility in the way that they configure some aspect of the program. That is, 
 they need to do some kind of simple programming. The
  Interpreter
  pattern provides this flexibility by adding 
 a language interpreter.
  
 The problem is that creating your own language and building an interpreter is a time-consuming distraction 
 from the process of developing your application. You must ask whether you want to finish writing your 
 application or make a new language. The best solution is to reuse code: embed an interpreter that’s already 
 been built and debugged for you.
  
 Creating a Language
  
 It turns out to be remarkably simple to use Jython to create an interpreted language inside your application. 
 Consider the greenhouse controller example from
  Thinking in Java
 . This is a situation where you want the end 
 user – the person managing the greenhouse – to have configuration control over the system, and so a simple 
 scripting language is an ideal solution. This is often called a
  domain-specific language
  (DSL) because it solves a 
 particular domain problem.
  
 To create the language, we’ll simply write a set of Python classes, and the constructor of each will add itself to 
 a (static) master list. The common data and behavior will be factored into the base class
  Event
 . Each 
 Event
  
 object will contain an
  action
  string (for simplicity – in reality, you’d have some sort of functionality) and a 
 time when the event is supposed to run. The constructor initializes these fields, and then adds the new
  Event
  
 object to a static list called
  events
  (defining it in the class, but outside of any methods, is what makes it 
 static):
  
 # Jython/GreenHouseLanguage.py
  
 class
  Event
 : 
  
  
 events
  =
  []
  # static
  
 def
  __init__
 (
 self
 , action, time): 
  
 self
 .
 action
  =
  action 
  
 self
 .
 time
  =
  time 
  
 Event
 .
 events
 .
 append(
 self
 )
  
 def
  __cmp__
  (
 self
 , other): 
  
 ""So sort() will compare only on time."" 
  
 return
  cmp
 (
 self
 .
 time, other
 .
 time)
  
 def
  run
 (
 self
 ): 
  
  
 print
 (
 ""
 %.2f
 :
  %s
 ""
  %
  (
 self
 .
 time,
  self
 .
 action))
  
 @staticmethod 
  
 def
  run_events
 (): 
  
  
 Event
 .
 events
 .
 sort(); 
  
  
 for
  e
  in
  Event
 .
 events: 
  
  
 e
 .
 run()
  
 class
  LightOn
 (Event): 
  
  
 def
  __init__
 (
 self
 , time): 
  
  
  
 Event
 .
 __init__
 (
 self
 ,
  ""Light on""
 , time)
  
 class
  LightOff
 (Event):
  
  
 92
  
 Chapter 19. Jython",NA
Using Java libraries,"Jython wraps Java libraries so that any of them can be used directly or via inheritance. In addition, Python 
 shorthand simplifies coding.
  
 As an example, consider the
  HTMLButton.java
  example from
  Thinking in Java
 . Here is its conversion to 
 Jython:
  
 # Jython/PythonSwing.py 
  
 # The HTMLButton.java example from ""Thinking in Java"" # converted into 
 Jython.
  
 from
  javax.swing
  import
  JFrame, JButton, JLabel 
 from
  java.awt
  
 import
  FlowLayout
  
 frame
  =
  JFrame(
 ""HTMLButton""
 , visible
 =
 1
 , 
  
 defaultCloseOperation
 =
 JFrame
 .
 EXIT_ON_CLOSE)
  
 def
  kapow
 (e): 
  
  
 frame
 .
 contentPane
 .
 add(JLabel(
 ""<html>""
 + 
  
  
  
 ""<i><font size=+4>Kapow!""
 )) 
  
  
 # Force a re-layout to 
  
  
 # include the new label: 
  
  
 frame
 .
 validate()
  
 button
  =
  JButton(
 ""<html><b><font size=+2>""
  + 
  
 ""<center>Hello!<br><i>Press me now!""
 , 
  
 actionPerformed
 =
 kapow)
  
  
 94
  
 Chapter 19. Jython",NA
Controlling Java from Jython,"There’s a tremendous amount that you can accomplish by controlling Python from Java. But one of the 
 amazing things about Jython is that it makes Java classes almost transparently available from within Jython. 
 Basically, a Java class looks like a Python class. This is true for standard Java library classes as well as classes 
 that you create yourself, as you can see here:
  
 # Jython/JavaClassInPython.py 
  
 # Using Java classes within Jython 
  
 # run with: jython.bat JavaClassInPython.py 
  
 from
  java.util
  import
  Date, HashSet, HashMap 
  
 from
  Jython.javaclass
  import
  JavaClass 
  
 from
  math
  import
  sin
  
 d
  =
  Date()
  # Creating a Java Date object 
  
 print
 (d)
  # Calls toString()
  
 # A ""generator"" to easily create data: 
  
 class
  ValGen
 : 
  
  
 def
  __init__
 (
 self
 , maxVal): 
  
  
  
 self
 .
 val
  =
  range
 (maxVal) 
  
  
 # Called during 'for' iteration: 
  
  
 def
  __getitem__
 (
 self
 , i): 
  
  
  
 # Returns a tuple of two elements: 
  
  
  
 return
  self
 .
 val[i], sin(
 self
 .
 val[i])
  
 # Java standard containers: 
  
 jmap
  =
  HashMap() 
  
 jset
  =
  HashSet()
  
 for
  x, y
  in
  ValGen(
 10
 ): 
  
 jmap
 .
 put(x, y) 
  
 jset
 .
 add(y) 
  
 jset
 .
 add(y)
  
 print
 (jmap) 
  
 print
 (jset)
  
 # Iterating through a set: 
  
 for
  z
  in
  jset: 
  
  
 print
 (z, z
 .
 __class__
 )
  
 print
 (jmap[
 3
 ])
  # Uses Python dictionary indexing 
 for
  x
  in
  
 jmap
 .
 keySet():
  # keySet() is a Map method 
  
 print
 (x, jmap[x])
  
 # Using a Java class that you create yourself is # just as easy: 
  
 jc
  =
  JavaClass()
  
  
 96
  
 Chapter 19. Jython",NA
Controlling the Interpreter,"In the rest of this chapter, we shall look at more sophisticated ways to interact with Jython. The simplest way 
 to exercise more control over the
  PythonInterpreter
  object from within Java is to send data to the 
 interpreter, and pull data back out.
  
 Putting Data In
  
 To inject data into your Python program, the
  PythonInterpreter
  class has a deceptively simple method: 
 set()
 . However,
  set()
  takes many different data types and performs conversions upon them. The follow-ing 
 example is a reasonably thorough exercise of the various
  set()
  possibilities, along with comments that should 
 give a fairly complete explanation:
  
 // Jython/PythonInterpreterSetting.java 
  
 // Passing data from Java to python when using // the 
 PythonInterpreter object.
  
 import
  org.python.util.PythonInterpreter
 ; 
  
 import
  org.python.core.*
 ; 
  
 import
  java.util.*
 ;
  
 public class
  PythonInterpreterSetting
  { 
  
 public static
  void
  main
 (
 String
 []
  args
 )
  throws
  PyException 
  
 { 
   
 PythonInterpreter interp
  =
  new
  PythonInterpreter
 (); 
  
   
 // It automatically converts Strings 
  
   
 // into native Python strings: 
  
   
 interp
 .
 set
 (
 ""a""
 ,
  ""This is a test""
 ); 
  
   
 interp
 .
 exec
 (
 ""print(a)""
 ); 
  
   
 interp
 .
 exec
 (
 ""print(a[5:])""
 );
  // A slice 
  
   
 // It also knows what to do with arrays: 
  
   
 String
 []
  s
  = {
  ""How""
 ,
  ""Do""
 ,
  ""You""
 ,
  ""Do?""
  }; 
  
   
 interp
 .
 set
 (
 ""b""
 ,
  s
 ); 
  
   
 interp
 .
 exec
 (
 ""for x in b: print(x[0], x)""
 ); 
  
   
 // set() only takes Objects, so it can't 
  
   
 // figure out primitives. Instead, 
  
   
 // you have to use wrappers: 
  
   
 interp
 .
 set
 (
 ""c""
 ,
  new
  PyInteger
 (
 1
 )); 
  
   
 interp
 .
 set
 (
 ""d""
 ,
  new
  PyFloat
 (
 2.2
 )); 
  
   
 interp
 .
 exec
 (
 ""print(c + d)""
 ); 
  
   
 // You can also use Java's object wrappers: 
  
   
 interp
 .
 set
 (
 ""c""
 ,
  new
  Integer
 (
 9
 )); 
  
   
 interp
 .
 set
 (
 ""d""
 ,
  new
  Float
 (
 3.14
 )); 
  
   
 interp
 .
 exec
 (
 ""print(c + d)""
 ); 
  
   
 // Define a Python function to print arrays: 
  
   
 interp
 .
 exec
 ( 
  
    
 ""def prt(x): \n""
  + 
  
    
 "" 
  
 print(x)\n""
  + 
  
    
 "" 
  
 for i in x: \n""
  + 
  
    
 "" 
  
 print(i,)\n""
  + 
  
    
 "" 
  
 print(x.__class__)\n""
 ); 
  
   
 // Arrays are Objects, so it has no trouble 
  
   
 // figuring out the types contained in arrays: 
  
   
 Object
 []
  types
  = { 
  
    
 new
  boolean
 []{
  true
 ,
  false
 ,
  false
 ,
  true
  }, 
  
    
 new
  char
 []{
  'a'
 ,
  'b'
 ,
  'c'
 ,
  'd'
  }, 
  
    
 new
  byte
 []{
  1
 ,
  2
 ,
  3
 ,
  4
  }, 
  
    
 new
  int
 []{
  10
 ,
  20
 ,
  30
 ,
  40
  },
  
  
 19.6. Controlling the Interpreter
  
 99",NA
Creating Java classes with Jython,"Note:
  
 Jython 2.5.0 does not support
  jythonc
 . Support is planned for 2.5.1.
  jythonc
  basically converted
  
 python source to java source, the replacement will generate bytecodes directly, and enable jython code to be 
 imported directly into java (via generated proxies).
  
 Jython can also create Java classes directly from your Jython code. This can produce very useful results, as you 
 are then able to treat the results as if they are native Java classes, albeit with Python power under the hood.
  
 To produce Java classes from Python code, Jython comes with a compiler called
  jythonc
 .
  
 The process of creating Python classes that will produce Java classes is a bit more complex than when call-ing 
 Java classes from Python, because the methods in Java classes are statically typed, while Python func-tions 
 and methods are dynamically typed. Thus, you must somehow tell
  jythonc
  that a Python method is intended 
 to have a particular set of argument types and that its return value is a particular type. You accom-plish this 
 with the
  @sig
  string, which is placed right after the beginning of the Python method definition (this is the 
 standard location for the Python documentation string). For example:
  
 def
  returnArray
 (
 self
 ): 
  
  
 ""@sig public java.lang.String[] returnArray()""
  
 The Python definition doesn’t specify any return type, but the @sig string gives the full type information 
 about what is being passed and returned. The
  jythonc
  compiler uses this information to generate the correct 
 Java code.
  
 There’s one other set of rules you must follow in order to get a successful compilation: you must inherit from 
 a Java class or interface in your Python class (you do not need to specify the
  @sig
  signature for meth-ods 
 defined in the superclass/interface). If you do not do this, you won’t get your desired methods –
 unfortunately,
  jythonc
  gives you no warnings or errors in this case, but you won’t get what you want. If you 
 don’t see what’s missing, it can be very frustrating.
  
 In addition, you must import the appropriate java class and give the correct package specification. In the 
 example below,
  java
  is imported so you must inherit from
  java.lang.Object
 , but you could also say 
 from 
 java.lang import Object
  and then you’d just inherit from
  Object
  without the package specification. 
 Unfortunately, you don’t get any warnings or errors if you get this wrong, so you must be patient and keep 
 trying.
  
 Here is an example of a Python class created to produce a Java class. In this case, the Python file is used to build 
 a Java
  .class
  file, so the class file is the desired target:
  
 # Jython/PythonToJavaClass.py 
  
 # A Python class converted into a Java class 
  
 # Compile with: 
  
 # jythonc --package python.java.test PythonToJavaClass.py 
 from
  jarray
  import
  
 array 
  
 import
  java
  
 class
  PythonToJavaClass
 (java
 .
 lang
 .
 Object): 
  
  
 # The '@sig' signature string is used to create the 
  
 # proper signature in 
 the resulting Java code: 
  
 def
  __init__
 (
 self
 ): 
  
  
  
 ""@sig public PythonToJavaClass()"" 
  
  
  
 print
 (
 ""Constructor for PythonToJavaClass""
 )
  
 def
  simple
 (
 self
 ):
  
  
 106
  
 Chapter 19. Jython",NA
Summary,"This chapter has arguably gone much deeper into Jython than required to use the interpreter design pattern. 
 Indeed, once you decide that you need to use interpreter and that you’re not going to get lost inventing your 
 own language, the solution of installing Jython is quite simple, and you can at least get started by following 
 the
  GreenHouseController
  example.
  
 Of course, that example is often too simple and you may need something more sophisticated, often requir-ing 
 more interesting data to be passed back and forth. When I encountered the limited documentation, I felt it 
 necessary to come up with a more thorough examination of Jython.
  
 In the process, note that there could be another equally powerful design pattern lurking in here, which could 
 perhaps be called
  multiple languages
  or
  language hybridizing
 . This is based on the experience of having each 
 language solve a certain class of problems better than the other; by combining languages you can solve 
 problems much faster than with either language by itself. CORBA is another way to bridge across languages, 
 and at the same time bridging between computers and operating systems.
  
 To me, Python and Java present a very potent combination for program development because of Java’s 
 architecture and tool set, and Python’s extremely rapid development (generally considered to be 5-10 times 
 faster than C++ or Java). Python is usually slower, however, but even if you end up re-coding parts of your 
 program for speed, the initial fast development will allow you to more quickly flesh out the system and 
 uncover and solve the critical sections. And often, the execution speed of Python is not a problem – in those 
 cases it’s an even bigger win. A number of commercial products already use Java and Jython, and because of 
 the terrific productivity leverage I expect to see this happen more in the future.",NA
Exercises,"1. Modify
  GreenHouseLanguage.py
  so that it checks the times for the events and runs those events at 
  
 the appropriate times.
  
 2. Modify
  GreenHouseLanguage.py
  so that it calls a function for
  action
  instead of just printing a string.
  
 3. Create a Swing application with a
  JTextField
  (where the user will enter commands) and a
  JTextArea 
 (where the command results will be displayed). Connect to a
  PythonInterpreter
  object so that the 
 output will be sent to the
  JTextArea
  (which should scroll). You’ll need to locate the
  PythonInterpreter 
 command that redirects the output to a Java stream.
  
 4. Modify
  GreenHouseLanguage.py
  to add a master controller class (instead of the static array inside 
 Event
 ) and provide a
  run()
  method for each of the subclasses. Each
  run()
  should create and use an 
 object from the standard Java library during its execution. Modify
  GreenHouseController.java
  to use 
 this new class.
  
 5. Modify the resulting
  GreenHouseLanguage.py
  from exercise two to produce Java classes (add the @sig 
 documentation strings to produce the correct Java signatures, and create a makefile to build the Java
  
 .class
  files). Write a Java program that uses these classes.
  
 6. Modify
  GreenHouseLanguage.py
  so that the subclasses of
  Event
  are not discrete classes, but are instead
  
 generated
  by a single function which creates the class and the associated string dynamically.
  
 110
  
 Chapter 19. Jython",NA
CHAPTER,NA,NA
 20,NA,NA
Part II: Idioms,111,NA
CHAPTER,NA,NA
 21,NA,NA
Discovering the Details About Your Platform,"The Python library XXX will give you some information about your machine, but it falls short. Here’s a
  
 rather messy, but useful way to figure out everything else.
  
 Just a starting point:
  
 # MachineDiscovery/detect_CPUs.py 
  
 def
  detect_CPUs
 (): 
  
  
 """""" 
  
  
 Detects the number of CPUs on a system. Cribbed from pp.
  
 """""" 
  
 # Linux, Unix and MacOS: 
  
 if
  hasattr
 (os,
  ""sysconf""
 ): 
  
  
 if
  os
 .
 sysconf_names
 .
 has_key(
 ""SC_NPROCESSORS_ONLN""
 ): 
  
 # Linux & Unix: 
  
  
 ncpus
  =
  os
 .
 sysconf(
 ""SC_NPROCESSORS_ONLN""
 ) 
  
  
 if
  isinstance
 (ncpus,
  int
 )
  and
  ncpus
  >
  0
 : 
  
  
  
  
 return
  ncpus 
  
  
 else
 :
  # OSX: 
  
  
 return
  int
 (os
 .
 popen2(
 ""sysctl -n hw.ncpu""
 )[
 1
 ]
 .
 read()) 
 # Windows: 
  
 if
  os
 .
 environ
 .
 has_key(
 ""NUMBER_OF_PROCESSORS""
 ): 
  
  
 ncpus
  =
  int
 (os
 .
 environ[
 ""NUMBER_OF_PROCESSORS""
 ]); 
  
 if
  ncpus
  >
  0
 : 
  
  
  
  
 return
  ncpus 
  
 return
  1
  # Default
  
 113",NA
CHAPTER,NA,NA
 22,NA,NA
A Canonical Form for Command-Line Programs,"Creating Python programs for command-line use involves a certain amount of repetitious coding, which can 
 often be left off or forgotten. Here is a form which includes everything.
  
 Note that if you are using Windows, you can add Python programs to your “File New” menu and auto-
 matically include the above text in the new file.
  This article
  shows you how. Other operating systems have 
 their own automation features.
  
 115",NA
CHAPTER,NA,NA
 23,NA,NA
Messenger/Data Transfer Object,"The
  Messenger
  or
  Data Transfer Object
  is a way to pass a clump of information around. The most typical place 
 for this is in return values from functions, where tuples or dictionaries are often used. However, those rely on 
 indexing; in the case of tuples this requires the consumer to keep track of numerical order, and in the case of 
 a
  dict
  you must use the d[""name""] syntax which can be slightly less desireable.
  
 A Messenger is simply an object with attributes corresponding to the names of the data you want to pass 
 around or return:
  
 # Messenger/MessengerIdiom.py
  
 class
  Messenger
 : 
  
  
 def
  __init__
 (
 self
 ,
  **
 kwargs): 
  
  
  
 self
 .
 __dict__
  =
  kwargs
  
 m
  =
  Messenger(info
 =
 ""some information""
 , b
 =
 [
 'a'
 ,
  'list'
 ]) m
 .
 more
  =
  11 
  
 print
  m
 .
 info, m
 .
 b, m
 .
 more
  
 The trick here is that the __dict__ for the object is just assigned to the
  dict
  that is automatically created by the 
 **kwargs argument.
  
 Although one could easily create a Messenger class and put it into a library and import it, there are so few 
 lines to describe it that it usually makes more sense to just define it in-place whenever you need it – it is 
 probably easier for the reader to follow, as well.
  
 117",NA
CHAPTER,NA,NA
 24,NA,NA
Part III: Patterns,119,NA
CHAPTER,NA,NA
 25,NA,NA
The Pattern Concept,"“Design patterns help you learn from others’ successes instead of your own failures
 1
 .”
  
 Probably the most important step forward in object-oriented design is the “design patterns” movement, 
 chronicled in
  Design Patterns (ibid)
 2
 . That book shows 23 different solutions to particular classes of prob-
 lems. In this book, the basic concepts of design patterns will be introduced along with examples. This should 
 whet your appetite to read
  Design Patterns
  by Gamma, et. al., a source of what has now become an essential, 
 almost mandatory, vocabulary for OOP programmers.
  
 The latter part of this book contains an example of the design evolution process, starting with an initial 
 solution and moving through the logic and process of evolving the solution to more appropriate designs. The 
 program shown (a trash sorting simulation) has evolved over time, and you can look at that evolution as a 
 prototype for the way your own design can start as an adequate solution to a particular problem and evolve 
 into a flexible approach to a class of problems.",NA
What is a Pattern?,"Initially, you can think of a pattern as an especially clever and insightful way of solving a particular class of 
 problems. That is, it looks like a lot of people have worked out all the angles of a problem and have come up 
 with the most general, flexible solution for it. The problem could be one you have seen and solved before, but 
 your solution probably didn’t have the kind of completeness you’ll see embodied in a pattern.
  
 Although they’re called “design patterns,” they really aren’t tied to the realm of design. A pattern seems to 
 stand apart from the traditional way of thinking about analysis, design, and implementation. Instead, a 
 pattern embodies a complete idea within a program, and thus it can sometimes appear at the analysis phase 
 or high-level design phase. This is interesting because a pattern has a direct implementation in code and so 
 you might not expect it to show up before low-level design or implementation (and in fact you might not 
 realize that you need a particular pattern until you get to those phases).
  
 The basic concept of a pattern can also be seen as the basic concept of program design: adding a layer of 
 abstraction. Whenever you abstract something you’re isolating particular details, and one of the most
  
 1
  From Mark Johnson.
  
 2
  But be warned: the examples are in C++.
  
 121",NA
Classifying Patterns,"The
  Design Patterns
  book discusses 23 different patterns, classified under three purposes (all of which re-
 volve around the particular aspect that can vary). The three purposes are:
  
 1.
  Creational
 : how an object can be created. This often involves isolating the details of object creation so 
 your code isn’t dependent on what types of objects there are and thus doesn’t have to be changed when 
 you add a new type of object. The aforementioned
  Singleton
  is classified as a creational pattern, and 
 later in this book you’ll see examples of
  Factory Method
  and
  Prototype
 .
  
 2.
  Structural
 : designing objects to satisfy particular project constraints. These work with the way objects 
 are connected with other objects to ensure that changes in the system don’t require changes to those 
 connections.
  
 3.
  Behavioral
 : objects that handle particular types of actions within a program. These encapsulate pro-
 cesses that you want to perform, such as interpreting a language, fulfilling a request, moving through a 
 sequence (as in an iterator), or implementing an algorithm. This book contains examples of the 
 Observer
  
 and the
  Visitor
  patterns.
  
 The
  Design Patterns
  book has a section on each of its 23 patterns along with one or more examples for each, 
 typically in C++ but sometimes in Smalltalk. (You’ll find that this doesn’t matter too much since you can easily 
 translate the concepts from either language into Python.) This book will not repeat all the patterns shown in
  
 Design Patterns
  since that book stands on its own and should be studied separately. Instead, this book will 
 give some examples that should provide you with a decent feel for what patterns are about and why they are 
 so important.
  
 After years of looking at these things, it began to occur to me that the patterns themselves use basic prin-
 ciples of organization, other than (and more fundamental than) those described in
  Design Patterns
 . These 
 principles are based on the structure of the implementations, which is where I have seen great similarities
  
 122
  
 Chapter 25. The Pattern Concept",NA
Pattern Taxonomy,"One of the events that’s occurred with the rise of design patterns is what could be thought of as the “pol-
 lution” of the term - people have begun to use the term to mean just about anything synonymous with“good.” 
 After some pondering, I’ve come up with a sort of hierarchy describing a succession of different types of 
 categories:
  
 1.
  Idiom
 : how we write code in a particular language to do this particular type of thing. This could be 
 something as common as the way that you code the process of stepping through an array in C (and not 
 running off the end).
  
 2.
  Specific Design
 : the solution that we came up with to solve this particular problem. This might be a 
  
 clever design, but it makes no attempt to be general.
  
 3.
  Standard Design
 : a way to solve this
  kind
  of problem. A design that has become more general, 
  
 typically 
 through reuse.
  
 4.
  Design Pattern
 : how to solve an entire class of similar problem. This usually only appears after 
 applying a standard design a number of times, and then seeing a common pattern throughout these 
 applications.
  
 I feel this helps put things in perspective, and to show where something might fit. However, it doesn’t say that 
 one is better than another. It doesn’t make sense to try to take every problem solution and generalize it to a 
 design pattern - it’s not a good use of your time, and you can’t force the discovery of patterns that way; they 
 tend to be subtle and appear over time.
  
 One could also argue for the inclusion of
  Analysis Pattern
  and
  Architectural Pattern
  in this taxonomy.",NA
Design Structures,"One of the struggles that I’ve had with design patterns is their classification - I’ve often found the GoF ap-
 proach to be too obscure, and not always very helpful. Certainly, the
  Creational
  patterns are fairly straight-
 forward: how are you going to create your objects? This is a question you normally need to ask, and the name 
 brings you right to that group of patterns. But I find
  Structural
  and
  Behavioral
  to be far less useful 
 distinctions. I have not been able to look at a problem and say “clearly, you need a structural pattern here,”so 
 that classification doesn’t lead me to a solution (I’ll readily admit that I may be missing something here).
  
 I’ve labored for awhile with this problem, first noting that the underlying structure of some of the GoF 
 patterns are similar to each other, and trying to develop relationships based on that similarity. While this was 
 an interesting experiment, I don’t think it produced much of use in the end because the point is to solve 
 problems, so a helpful approach will look at the problem to solve and try to find relationships between the 
 problem and potential solutions.
  
 To that end, I’ve begun to try to collect basic design structures, and to try to see if there’s a way to relate those 
 structures to the various design patterns that appear in well thought-out systems. Currently, I’m just trying to 
 make a list, but eventually I hope to make steps towards connecting these structures with patterns (or I may 
 come up with a different approach altogether - this is still in its formative stages).
  
 Here
 3
 is the present list of candidates, only some of which will make it to the final list. Feel free to suggest
  
 3
  This list includes suggestions by Kevlin Henney, David Scott, and others.
  
 25.3. Pattern Taxonomy
  
 123",NA
Design Principles,"When I put out a call for ideas in my newsletter
 4
 , a number of suggestions came back which turned out to be 
 very useful, but different than the above classification, and I realized that a list of design principles is at least 
 as important as design structures, but for a different reason: these allow you to ask questions about your 
 proposed design, to apply tests for quality.
  
 •
  Principle of least astonishment
  (don’t be astonishing).
  
 •
  Make common things easy, and rare things possible
  
 •
  Consistency
 . One thing has become very clear to me, especially because of Python: the more ran-
  
 dom rules you pile onto the programmer, rules that have nothing to do with solving the problem at 
  
 hand, the slower the programmer can produce. And this does not appear to be a linear factor, but an 
  
 exponential one.
  
 •
  Law of Demeter
 : a.k.a. “Don’t talk to strangers.” An object should only reference itself, its attributes, 
  
 and the arguments of its methods. This may also be a way to say “minimize coupling.”
  
 •
  Independence
  or
  Orthogonality
 . Express independent ideas independently. This complements Sep-
  
 aration, Encapsulation and Variation, and is part of the Low-Coupling-High-Cohesion message.
  
 •
  Managed Coupling
 . Simply stating that we should have “low coupling” in a design is usually too vague - 
 coupling happens, and the important issue is to acknowledge it and control it, to say “cou-pling can 
 cause problems” and to compensate for those problems with a well-considered design or pattern.
  
 •
  Subtraction
 : a design is finished when you cannot take anything else away
 5
 .
  
 4
  A free email publication. See
  www.BruceEckel.com
  to subscribe.
  
 5
  This idea is generally attributed to Antoine de St. Exupery from
  The Little Prince
 : “La perfection est atteinte non quand il ne reste 
 rien à ajouter, mais quand il ne reste rien à enlever,” or: “perfection is reached not when there’s nothing left to add, but when there’s 
 nothing left to remove”.
  
 124
  
 Chapter 25. The Pattern Concept",NA
Further Reading,"Alex Martelli’s Video Lectures on Design Patterns in Python:
  http://www.catonmat.net/blog/ 
 learning-python-design-patterns-through-video-lectures/
  
 6
  From an email from Kevlin Henney.
  
 25.6. Further Reading
  
 125",NA
CHAPTER,NA,NA
 26,NA,NA
The Singleton,"Possibly the simplest design pattern is the
  singleton
 , which is a way to provide one and only one object
  
 of a particular type. To accomplish this, you must take control of object creation out of the hands of the
  
 programmer. One convenient way to do this is to delegate to a single instance of a private nested inner
  
 class:
  
 # Singleton/SingletonPattern.py
  
 class OnlyOne: 
  
  
 class __OnlyOne: 
  
  
  
 def __init__(self, arg): 
  
  
  
  
 self.val = arg 
  
  
  
 def __str__(self): 
  
  
  
  
 return repr(self) + self.val 
  
  
 instance = None 
  
  
 def __init__(self, arg): 
  
  
  
 if not OnlyOne.instance: 
  
  
  
  
 OnlyOne.instance = OnlyOne.__OnlyOne(arg) 
  
  
 else: 
  
  
  
  
 OnlyOne.instance.val = arg 
  
  
 def __getattr__(self, name): 
  
  
  
 return getattr(self.instance, name)
  
 x = OnlyOne('sausage') 
  
 print(x) 
  
 y = OnlyOne('eggs') 
  
 print(y) 
  
 z = OnlyOne('spam') 
  
 print(z) 
  
 print(x) 
  
 print(y) 
  
 print(`x`) 
  
 print(`y`) 
  
 print(`z`) 
  
 output = ''' 
  
 <__main__.__OnlyOne instance at 0076B7AC>sausage
  
 127",NA
Exercises,"1.
  SingletonPattern.py
  always creates an object, even if it’s never used. Modify this program to use
  lazy
  
 initialization
 , so the singleton object is only created the first time that it is needed.
  
 2. Using
  SingletonPattern.py
  as a starting point, create a class that manages a fixed number of its own
  
 objects. Assume the objects are database connections and you only have a license to use a fixed
  
 quantity of these at any one time.
  
 3. Modify
  BorgSingleton.py
  so that it uses a class
  __new__( )
  method.
  
 26.1. Exercises
  
 131",NA
CHAPTER,NA,NA
 27,NA,NA
Building Application Frameworks,"An application framework allows you to inherit from a class or set of classes and create a new application, 
 reusing most of the code in the existing classes and overriding one or more methods in order to customize the 
 application to your needs. A fundamental concept in the application framework is the
  Template Method 
 which 
 is typically hidden beneath the covers and drives the application by calling the various methods in the base 
 class (some of which you have overridden in order to create the application).
  
 For example, whenever you create an applet you’re using an application framework: you inherit from 
 JApplet
  
 and then override
  init( )
 . The applet mechanism (which is a
  Template Method
 ) does the rest by drawing the 
 screen, handling the event loop, resizing, etc.",NA
Template Method,"An important characteristic of the
  Template Method
  is that it is defined in the base class and cannot be 
 changed. It’s sometimes a
  private
  method but it’s virtually always
  final
 . It calls other base-class methods (the 
 ones you override) in order to do its job, but it is usually called only as part of an initialization process (and 
 thus the client programmer isn’t necessarily able to call it directly):
  
 # AppFrameworks/TemplateMethod.py 
  
 # Simple demonstration of Template Method.
  
 class
  ApplicationFramework
 : 
  
  
 def
  __init__
 (
 self
 ): 
  
  
  
 self
 .
 __templateMethod() 
  
  
 def
  __templateMethod
 (
 self
 ): 
  
  
  
 for
  i
  in
  range
 (
 5
 ): 
  
  
  
  
 self
 .
 customize1() 
  
  
  
  
 self
 .
 customize2()
  
 # Create an ""application"": 
  
 class
  MyApp
 (ApplicationFramework): 
  
  
 def
  customize1
 (
 self
 ): 
  
  
  
 print
 (
 ""Nudge, nudge, wink, wink! ""
 ,)
  
 133",NA
Exercises,"1. Create a framework that takes a list of file names on the command line. It opens each file except the last 
 for reading, and the last for writing. The framework will process each input file using an undetermined 
 policy and write the output to the last file. Inherit to customize this framework to create two separate 
 applications:
  
 (a) Converts all the letters in each file to uppercase.
  
 (b) Searches the files for words given in the first file.
  
 134
  
 Chapter 27. Building Application Frameworks",NA
CHAPTER,NA,NA
 28,NA,NA
Fronting for an Implementation,"Both
  Proxy
  and
  State
  provide a surrogate class that you use in your code; the real class that does the work is 
 hidden behind this surrogate class. When you call a method in the surrogate, it simply turns around and calls 
 the method in the implementing class. These two patterns are so similar that the
  Proxy
  is simply a special case 
 of
  State
 . One is tempted to just lump the two together into a pattern called
  Surrogate
 , but the term “proxy” 
 has a long-standing and specialized meaning, which probably explains the reason for the two different 
 patterns.
  
 The basic idea is simple: from a base class, the surrogate is derived along with the class or classes that provide 
 the actual implementation:
  
  
 When a surrogate object is created, it is given an implementation to which to send all of the method calls.
  
 Structurally, the difference between
  Proxy
  and
  State
  is simple: a
  Proxy
  has only one implementation, while 
 State
  has more than one. The application of the patterns is considered (in
  Design Patterns
 ) to be distinct: 
 Proxy
  is used to control access to its implementation, while
  State
  allows you to change the implementation 
 dynamically. However, if you expand your notion of “controlling access to implementation” then the two fit 
 neatly together.
  
 135",NA
Proxy,"If we implement
  Proxy
  by following the above diagram, it looks like this:
  
 # Fronting/ProxyDemo.py 
  
 # Simple demonstration of the Proxy pattern.
  
 class
  Implementation
 : 
  
  
 def
  f
 (
 self
 ): 
  
  
  
 print
 (
 ""Implementation.f()""
 ) 
  
  
 def
  g
 (
 self
 ): 
  
  
  
 print
 (
 ""Implementation.g()""
 ) 
  
  
 def
  h
 (
 self
 ): 
  
  
  
 print
 (
 ""Implementation.h()""
 )
  
 class
  Proxy
 : 
  
  
 def
  __init__
 (
 self
 ): 
  
  
  
 self
 .
 __implementation
  =
  Implementation() 
  
 # Pass 
 method calls to the implementation: 
  
 def
  f
 (
 self
 ):
  
 self
 .
 __implementation
 .
 f() 
  
  
 def
  g
 (
 self
 ):
  self
 .
 __implementation
 .
 g() 
  
  
 def
  h
 (
 self
 ):
  self
 .
 __implementation
 .
 h()
  
 p
  =
  Proxy() 
  
 p
 .
 f(); p
 .
 g(); p
 .
 h()
  
 It isn’t necessary that
  Implementation
  have the same interface as
  Proxy
 ; as long as
  Proxy
  is 
 somehow“speaking for” the class that it is referring method calls to then the basic idea is satisfied (note that 
 this statement is at odds with the definition for Proxy in GoF). However, it is convenient to have a common 
 interface so that
  Implementation
  is forced to fulfill all the methods that
  Proxy
  needs to call.
  
 Of course, in Python we have a delegation mechanism built in, so it makes the
  Proxy
  even simpler to 
 implement:
  
 # Fronting/ProxyDemo2.py 
  
 # Simple demonstration of the Proxy pattern.
  
 class
  Implementation2
 : 
  
  
 def
  f
 (
 self
 ): 
  
  
  
 print
 (
 ""Implementation.f()""
 ) 
  
  
 def
  g
 (
 self
 ): 
  
  
  
 print
 (
 ""Implementation.g()""
 ) 
  
  
 def
  h
 (
 self
 ): 
  
  
  
 print
 (
 ""Implementation.h()""
 )
  
 class
  Proxy2
 : 
  
  
 def
  __init__
 (
 self
 ): 
  
  
  
 self
 .
 __implementation
  =
  Implementation2() 
  
 def
  
 __getattr__
 (
 self
 , name): 
  
  
  
 return
  getattr
 (
 self
 .
 __implementation, name)
  
 p
  =
  Proxy2() 
  
 p
 .
 f(); p
 .
 g(); p
 .
 h();
  
 The beauty of using
  __getattr__( )
  is that
  Proxy2
  is completely generic, and not tied to any particular im-
 plementation (in Java, a rather complicated “dynamic proxy” has been invented to accomplish this same 
 thing).
  
 136
  
 Chapter 28. Fronting for an Implementation",NA
State,"The
  State
  pattern adds more implementations to
  Proxy
 , along with a way to switch from one implementation 
 to another during the lifetime of the surrogate:
  
 # Fronting/StateDemo.py 
  
 # Simple demonstration of the State pattern.
  
 class
  State_d
 : 
  
  
 def
  __init__
 (
 self
 , imp): 
  
  
  
 self
 .
 __implementation
  =
  imp 
  
  
 def
  changeImp
 (
 self
 , newImp): 
  
  
  
 self
 .
 __implementation
  =
  newImp 
  
  
 # Delegate calls to the implementation: 
  
  
 def
  __getattr__
 (
 self
 , name): 
  
  
  
 return
  getattr
 (
 self
 .
 __implementation, name)
  
 class
  Implementation1
 : 
  
  
 def
  f
 (
 self
 ): 
  
  
  
 print
 (
 ""Fiddle de dum, Fiddle de dee,""
 ) 
  
 def
  
 g
 (
 self
 ): 
  
  
  
 print
 (
 ""Eric the half a bee.""
 ) 
  
  
 def
  h
 (
 self
 ): 
  
  
  
 print
 (
 ""Ho ho ho, tee hee hee,""
 )
  
 class
  Implementation2
 : 
  
  
 def
  f
 (
 self
 ): 
  
  
  
 print
 (
 ""We're Knights of the Round Table.""
 ) 
  
 def
  g
 (
 self
 ): 
  
  
  
 print
 (
 ""We dance whene'er we're able.""
 ) 
  
 def
  h
 (
 self
 ): 
  
  
  
 print
 (
 ""We do routines and chorus scenes""
 )
  
 def
  run
 (b): 
  
 b
 .
 f() 
  
 b
 .
 g() 
  
 b
 .
 h() 
  
 b
 .
 g()
  
 b
  =
  State_d(Implementation1()) 
  
 run(b) 
  
 b
 .
 changeImp(Implementation2()) 
  
 run(b)
  
 You can see that the first implementation is used for a bit, then the second implementation is swapped in and 
 that is used.
  
 The difference between
  Proxy
  and
  State
  is in the problems that are solved. The common uses for
  Proxy
  as 
 described in
  Design Patterns
  are: 
  
  
 1.
  Remote proxy
 . This proxies for an object in a different address space. A remote proxy is created for 
  
  
 you automatically by the RMI compiler
  rmic
  as it creates stubs and skeletons.
  
 2.
  Virtual proxy
 . This provides “lazy initialization” to create expensive objects on demand.
  
 3.
  Protection proxy
 . Used when you don’t want the client programmer to have full access to the proxied 
  
 object.
  
 4.
  Smart reference
 . To add additional actions when the proxied object is accessed. For example, or to
  
 28.2. State
  
 137",NA
CHAPTER,NA,NA
 29,NA,NA
StateMachine,"While
  State
  has a way to allow the client programmer to change the implementation,
  StateMachine
  imposes a 
 structure to automatically change the implementation from one object to the next. The current implemen-
 tation represents the state that a system is in, and the system behaves differently from one state to the next 
 (because it uses
  State
 ). Basically, this is a “state machine” using objects.
  
 The code that moves the system from one state to the next is often a
  Template Method
 , as seen in the following 
 framework for a basic state machine.
  
 Each state can be
  run( )
  to perform its behavior, and (in this design) you can also pass it an “input” object so 
 it can tell you what new state to move to based on that “input”. The key distinction between this design and 
 the next is that here, each
  State
  object decides what other states it can move to, based on the “input”, whereas 
 in the subsequent design all of the state transitions are held in a single table. Another way to put it is that 
 here, each
  State
  object has its own little
  State
  table, and in the subsequent design there is a single master 
 state transition table for the whole system:
  
 # StateMachine/State.py 
  
 # A State has an operation, and can be moved 
  
 # into the next State given an Input:
  
 class
  State
 : 
  
  
 def
  run
 (
 self
 ): 
  
  
  
 assert
  0
 ,
  ""run not implemented"" 
  
  
 def
  next
 (
 self
 ,
  input
 ): 
  
  
  
 assert
  0
 ,
  ""next not implemented""
  
 This class is clearly unnecessary, but it allows us to say that something is a
  State
  object in code, and pro-vide 
 a slightly different error message when all the methods are not implemented. We could have gotten basically 
 the same effect by saying:
  
 class
  State
 :
  pass
  
 because we would still get exceptions if
  run( )
  or
  next( )
  were called for a derived type, and they hadn’t been 
 implemented.
  
 139",NA
Table-Driven State Machine,"The advantage of the previous design is that all the information about a state, including the state transition 
 information, is located within the state class itself. This is generally a good design principle.
  
 However, in a pure state machine, the machine can be completely represented by a single state-transition 
 table. This has the advantage of locating all the information about the state machine in a single place, which 
 means that you can more easily create and maintain the table based on a classic state-transition diagram. The 
 classic state-transition diagram uses a circle to represent each state, and lines from the state pointing to all 
 states that state can transition into. Each transition line is annotated with conditions for transition and an 
 action during transition. Here’s what it looks like: 
  
 (Simple State Machine Diagram) 
  
 Goals:
  
  
 • Direct translation of state diagram
  
  
 • Vector of change: the state diagram representation
  
  
 • Reasonable implementation
  
  
 • No excess of states (you could represent every single change with a new state)
  
  
 • Simplicity and flexibility 
  
 Observations:
  
  
 • States are trivial - no information or functions/data, just an identity
  
  
 • Not like the State pattern!
  
  
 • The machine governs the move from state to state
  
  
 • Similar to flyweight
  
  
 • Each state may move to many others
  
  
 • Condition & action functions must also be external to states
  
  
 • Centralize description in a single table containing all variations, for ease of configuration 
 Example:
  
  
 • State Machine & Table-Driven Code
  
  
 • Implements a vending machine
  
  
 • Uses several other patterns
  
 144
  
 Chapter 29. StateMachine",NA
Tools,"Another approach, as your state machine gets bigger, is to use an automation tool whereby you configure a 
 table and let the tool generate the state machine code for you. This can be created yourself using a language 
 like Python, but there are also free, open-source tools such as
  Libero
 , at
  http://www.imatix.com
 .",NA
Exercises,"1. Create an example of the “virtual proxy.”
  
 2. Create an example of the “Smart reference” proxy where you keep count of the number of method 
  
 calls to a particular object.
  
 3. Create a program similar to certain DBMS systems that only allow a certain number of connections at 
 any time. To implement this, use a singleton-like system that controls the number of 
 “connection”objects that it creates. When a user is finished with a connection, the system must be 
 informed so that it can check that connection back in to be reused. To guarantee this, provide a proxy 
 object instead of a reference to the actual connection, and design the proxy so that it will cause the 
 connection to be released back to the system.
  
 4. Using the
  State
 , make a class called
  UnpredictablePerson
  which changes the kind of response to its 
 hello( )
  method depending on what kind of
  Mood
  it’s in. Add an additional kind of
  Mood
  called 
 Prozac
 .
  
 5. Create a simple copy-on write implementation.
  
 6. Apply
  TransitionTable.py
  to the “Washer” problem.
  
 7. Create a
  StateMachine
  system whereby the current state along with input information determines the 
 next state that the system will be in. To do this, each state must store a reference back to the proxy 
 object (the state controller) so that it can request the state change. Use a
  HashMap
  to create a table of 
 states, where the key is a
  String
  naming the new state and the value is the new state object. Inside each 
 state subclass override a method
  nextState( )
  that has its own state-transition table. The input to 
 nextState( )
  should be a single word that comes from a text file containing one word per line.
  
 8. Modify the previous exercise so that the state machine can be configured by creating/modifying a 
  
 single multi-dimensional array.
  
 9. Modify the “mood” exercise from the previous session so that it becomes a state machine using 
  
 StateMachine.py
  
 10. Create an elevator state machine system using StateMachine.py
  
 11. Create a heating/air-conditioning system using StateMachine.py
  
 12. A
  generator
  is an object that produces other objects, just like a factory, except that the generator func-
 tion doesn’t require any arguments. Create a
  MouseMoveGenerator
  which produces correct
  Mouse-
 Move
  actions as outputs each time the generator function is called (that is, the mouse must move in the 
 proper sequence, thus the possible moves are based on the previous move - it’s another state
  
 29.2. Tools
  
 151",NA
CHAPTER,NA,NA
 30,NA,NA
Decorator: Dynamic Type Selection,"Note:
  I think we can rewrite this chapter to use Python decorators as implementation (thus the decorators 
 chapter should precede this one).
  
 The use of layered objects to dynamically and transparently add responsibilities to individual objects is 
 referred to as the
  decorator
  pattern.
  
 Used when subclassing creates too many (& inflexible) classes 
  
 All decorators that wrap around the original object must have the same basic interface 
 Dynamic proxy/surrogate?
  
 This accounts for the odd inheritance structure 
  
 Tradeoff: coding is more complicated when using decorators
  
 153",NA
Basic Decorator Structure,NA,NA
A Coffee Example,"Consider going down to the local coffee shop,
  BeanMeUp
 , for a coffee. There are typically many different 
 drinks on offer – espressos, lattes, teas, iced coffees, hot chocolate to name a few, as well as a number of 
 extras (which cost extra too) such as whipped cream or an extra shot of espresso. You can also make certain 
 changes to your drink at no extra cost, such as asking for decaf coffee instead of regular coffee.
  
 Quite clearly if we are going to model all these drinks and combinations, there will be sizeable class di-
 agrams. So for clarity we will only consider a subset of the coffees: Espresso, Espresso Con Panna, CaféLate, 
 Cappuccino and Café Mocha. We’ll include 2 extras - whipped cream (“whipped”) and an extra shot of 
 espresso; and three changes - decaf, steamed milk (“wet”) and foamed milk (“dry”).",NA
Class for Each Combination,"One solution is to create an individual class for every combination. Each class describes the drink and is 
 responsible for the cost etc. The resulting menu is huge, and a part of the class diagram would look something 
 like this:
  
 154
  
 Chapter 30. Decorator: Dynamic Type Selection",NA
The Decorator Approach,"Another approach would be to break the drinks down into the various components such as espresso and 
 foamed milk, and then let the customer combine the components to describe a particular coffee.
  
 In order to do this programmatically, we use the Decorator pattern. A Decorator adds responsibility to a 
 component by wrapping it, but the Decorator conforms to the interface of the component it encloses, so the 
 wrapping is transparent. Decorators can also be nested without the loss of this transparency.
  
 156
  
 Chapter 30. Decorator: Dynamic Type Selection",NA
Compromise,"The previous approach takes too long to describe a coffee. There will also be certain combinations that you will 
 describe regularly, and it would be convenient to have a quick way of describing them.
  
 The 3rd approach is a mixture of the first 2 approaches, and combines flexibility with ease of use. This
  
 158
  
 Chapter 30. Decorator: Dynamic Type Selection",NA
Other Considerations,"What happens if we decide to change the menu at a later stage, such as by adding a new type of drink? If we 
 had used the class per combination approach, the effect of adding an extra such as syrup would be an 
 exponential growth in the number of classes. However, the implications to the all decorator or compromise 
 approaches are the same - one extra class is created.
  
 How about the effect of changing the cost of steamed milk and foamed milk, when the price of milk goes up? 
 Having a class for each combination means that you need to change a method in each class, and thus maintain 
 many classes. By using decorators, maintenance is reduced by defining the logic in one place.
  
 160
  
 Chapter 30. Decorator: Dynamic Type Selection",NA
Further Reading,NA,NA
Exercises,"1. Add a Syrup class to the decorator approach described above. Then create a Café Latte (you’ll need 
  
 to use steamed milk with an espresso) with syrup.
  
 2. Repeat Exercise 1 for the compromise approach.
  
 3. Implement the decorator pattern to create a Pizza restaurant, which has a set menu of choices as well as 
 the option to design your own pizza. Follow the compromise approach to create a menu consist-ing of a 
 Margherita, Hawaiian, Regina, and Vegetarian pizzas, with toppings (decorators) of Garlic, Olives, 
 Spinach, Avocado, Feta and Pepperdews. Create a Hawaiian pizza, as well as a Margherita decorated 
 with Spinach, Feta, Pepperdews and Olives.
  
 30.7. Further Reading
  
 161",NA
CHAPTER,NA,NA
 31,NA,NA
Iterators: Decoupling Algorithms from Containers,"Note:
  This chapter has not had any significant translation yet.
  
 Alexander Stepanov thought for years about the problem of generic programming techniques before cre-ating 
 the STL (along with Dave Musser). He came to the conclusion that all algorithms are defined on algebraic 
 structures - what we would call containers.
  
 In the process, he realized that iterators are central to the use of algorithms, because they decouple the 
 algorithms from the specific type of container that the algorithm might currently be working with. This 
 means that you can describe the algorithm without worrying about the particular sequence it is operating on. 
 More generally,
  any
  code that you write using iterators is decoupled from the data structure that the code is 
 manipulating, and thus your code is more general and reusable.
  
 The use of iterators also extends your code into the realm of
  functional programming
 , whose objective is to 
 describe
  what
  a program is doing at every step rather than
  how
  it is doing it. That is, you say “sort” rather 
 than describing the sort. The objective of the C++ STL was to provide this
  generic programming
  approach for 
 C++ (how successful this approach will actually be remains to be seen).
  
 If you’ve used containers in Java (and it’s hard to write code without using them), you’ve used iterators -in the 
 form of the
  Enumeration
  in Java 1.0/1.1 and the
  Iterator
  in Java 2. So you should already be familiar with 
 their general use. If not, see Chapter 9,
  Holding Your Objects
 , under
  Iterators
  in
  Thinking in Java, 3rd edition
  
 (freely downloadable from
  www.BruceEckel.com
 ).
  
 Because the Java 2 containers rely heavily on iterators they become excellent candidates for 
 generic/functional programming techniques. This chapter will explore these techniques by converting the 
 STL algorithms to Java, for use with the Java 2 container library.",NA
Type-Safe Iterators,"In
  Thinking in Java
 , I show the creation of a type-safe container that will only accept a particular type of object. 
 A reader, Linda Pazzaglia, asked for the other obvious type-safe component, an iterator that would
  
 163",NA
CHAPTER,NA,NA
 32,NA,NA
Factory: Encapsulating Object Creation,"When you discover that you need to add new types to a system, the most sensible first step is to use 
 polymorphism to create a common interface to those new types. This separates the rest of the code in your 
 system from the knowledge of the specific types that you are adding. New types may be added without 
 disturbing existing code ... or so it seems. At first it would appear that the only place you need to change the 
 code in such a design is the place where you inherit a new type, but this is not quite true. You must still create 
 an object of your new type, and at the point of creation you must specify the exact constructor to use. Thus, if 
 the code that creates objects is distributed throughout your application, you have the same problem when 
 adding new types-you must still chase down all the points of your code where type matters. It happens to be 
 the
  creation
  of the type that matters in this case rather than the
  use
  of the type (which is taken care of by 
 polymorphism), but the effect is the same: adding a new type can cause problems.
  
 The solution is to force the creation of objects to occur through a common
  factory
  rather than to allow the 
 creational code to be spread throughout your system. If all the code in your program must go through this 
 factory whenever it needs to create one of your objects, then all you must do when you add a new object is to 
 modify the factory.
  
 Since every object-oriented program creates objects, and since it’s very likely you will extend your program by 
 adding new types, I suspect that factories may be the most universally useful kinds of design patterns.",NA
Simple Factory Method,"As an example, let’s revisit the
  Shape
  system.
  
 One approach is to make the factory a
  static
  method of the base class:
  
 # Factory/shapefact1/ShapeFactory1.py 
  
 # A simple static factory method. 
  
 from
  __future__
  import
  generators 
  
 import
  random
  
 class
  Shape
 (
 object
 ): 
  
 # Create based on class name: 
  
 def
  factory
 (
 type
 ):
  
 165",NA
Polymorphic Factories,"The static
  factory( )
  method in the previous example forces all the creation operations to be focused in one 
 spot, so that’s the only place you need to change the code. This is certainly a reasonable solution, as it throws 
 a box around the process of creating objects. However, the
  Design Patterns
  book emphasizes that
  
 32.2. Polymorphic Factories
  
 167",NA
Abstract Factories,"The
  Abstract Factory
  pattern looks like the factory objects we’ve seen previously, with not one but several 
 factory methods. Each of the factory methods creates a different kind of object. The idea is that at the point of 
 creation of the factory object, you decide how all the objects created by that factory will be used. The example 
 given in
  Design Patterns
  implements portability across various graphical user interfaces (GUIs): you create a 
 factory object appropriate to the GUI that you’re working with, and from then on when you ask it for a menu, 
 button, slider, etc. it will automatically create the appropriate version of that item for the GUI. Thus you’re 
 able to isolate, in one place, the effect of changing from one GUI to another.
  
 As another example suppose you are creating a general-purpose gaming environment and you want to be able 
 to support different types of games. Here’s how it might look using an abstract factory:
  
 # Factory/Games.py 
  
 # An example of the Abstract Factory pattern.
  
 class
  Obstacle
 : 
  
  
 def
  action
 (
 self
 ):
  pass
  
 class
  Character
 : 
  
  
 def
  interactWith
 (
 self
 , obstacle):
  pass
  
 class
  Kitty
 (Character): 
  
  
 def
  interactWith
 (
 self
 , obstacle): 
  
  
  
 print
 (
 ""Kitty has encountered a""
 , 
  
  
  
 obstacle
 .
 action())
  
 class
  KungFuGuy
 (Character): 
  
  
 def
  interactWith
 (
 self
 , obstacle): 
  
  
  
 print
 (
 ""KungFuGuy now battles a""
 , 
  
  
  
 obstacle
 .
 action())
  
 class
  Puzzle
 (Obstacle): 
  
  
 def
  action
 (
 self
 ): 
  
  
  
 print
 (
 ""Puzzle""
 )
  
 class
  NastyWeapon
 (Obstacle): 
  
  
 def
  action
 (
 self
 ): 
  
  
  
 print
 (
 ""NastyWeapon""
 )
  
 # The Abstract Factory: 
  
 class
  GameElementFactory
 : 
  
  
 def
  makeCharacter
 (
 self
 ):
  pass 
  
  
 def
  makeObstacle
 (
 self
 ):
  pass
  
 # Concrete factories: 
  
 class
  KittiesAndPuzzles
 (GameElementFactory): 
  
  
 def
  makeCharacter
 (
 self
 ):
  return
  Kitty() 
  
  
 def
  makeObstacle
 (
 self
 ):
  return
  Puzzle()
  
  
 32.3. Abstract Factories
  
 169",NA
Exercises,"1. Add a class
  Triangle
  to
  ShapeFactory1.py
  
 2. Add a class
  Triangle
  to
  ShapeFactory2.py
  
 3. Add a new type of
  GameEnvironment
  called
  GnomesAndFairies
  to
  GameEnvironment.py
  
 4. Modify
  ShapeFactory2.py
  so that it uses an
  Abstract Factory
  to create different sets of shapes (for 
 example, one particular type of factory object creates “thick shapes,” another creates “thin shapes,”but 
 each factory object can create all the shapes: circles, squares, triangles etc.).
  
 32.4. Exercises
  
 171",NA
CHAPTER,NA,NA
 33,NA,NA
Function Objects,"In
  Advanced C++:Programming Styles And Idioms (Addison-Wesley, 1992)
 , Jim Coplien coins the term
  functor 
 which is an object whose sole purpose is to encapsulate a function (since “functor” has a meaning in math-
 ematics, in this book I shall use the more explicit term
  function object
 ). The point is to decouple the choice of 
 function to be called from the site where that function is called.
  
 This term is mentioned but not used in
  Design Patterns
 . However, the theme of the function object is re-peated 
 in a number of patterns in that book.",NA
Command: Choosing the Operation at Runtime,"This is the function object in its purest sense: a method that’s an object. By wrapping a method in an object, 
 you can pass it to other methods or objects as a parameter, to tell them to perform this particular operation in 
 the process of fulfilling your request:
  
 # FunctionObjects/CommandPattern.py
  
 class
  Command
 : 
  
  
 def
  execute
 (
 self
 ):
  pass
  
 class
  Loony
 (Command): 
  
  
 def
  execute
 (
 self
 ): 
  
  
  
 print
 (
 ""You're a loony.""
 )
  
 class
  NewBrain
 (Command): 
  
  
 def
  execute
 (
 self
 ): 
  
  
  
 print
 (
 ""You might even need a new brain.""
 )
  
 class
  Afford
 (Command): 
 def
  execute
 (
 self
 ): 
 print
 (
 ""I couldn't afford a whole 
 new brain.""
 )
  
 # An object that holds commands: 
  
 class
  Macro
 :
  
 173",NA
Strategy: Choosing the Algorithm at Runtime,"Strategy
  appears to be a family of
  Command
  classes, all inherited from the same base. But if you look at 
 Command
 , you’ll see that it has the same structure: a hierarchy of function objects. The difference is in the 
 way this hierarchy is used. As seen in
  patternRefactoring:DirList.py
 , you use
  Command
  to solve a particular 
 problem-in that case, selecting files from a list. The “thing that stays the same” is the body of the method 
 that’s being called, and the part that varies is isolated in the function object. I would hazard to say that
  
 Command
  provides flexibility while you’re writing the program, whereas
  Strategy
 ‘s flexibility is at run time.
  
 Strategy
  also adds a “Context” which can be a surrogate class that controls the selection and use of the 
 particular strategy object-just like
  State
 ! Here’s what it looks like:
  
 # FunctionObjects/StrategyPattern.py
  
 # The strategy interface: 
  
 class
  FindMinima
 : 
  
  
 # Line is a sequence of points: 
  
  
 def
  algorithm
 (
 self
 , line) :
  pass
  
 # The various strategies: 
  
 class
  LeastSquares
 (FindMinima): 
  
  
 def
  algorithm
 (
 self
 , line): 
  
  
  
 return
  [
  1.1
 ,
  2.2
  ]
  # Dummy
  
 class
  NewtonsMethod
 (FindMinima): 
  
  
 def
  algorithm
 (
 self
 , line): 
  
  
  
 return
  [
  3.3
 ,
  4.4
  ] 
  
 # Dummy
  
  
 174
  
 Chapter 33. Function Objects",NA
Chain of Responsibility,"Chain of Responsibility
  might be thought of as a dynamic generalization of recursion using
  Strategy
  objects. 
 You make a call, and each
  Strategy
  in a linked sequence tries to satisfy the call. The process ends when one of 
 the strategies is successful or the chain ends. In recursion, one method calls itself over and over until a 
 termination condition is reached; with
  Chain of Responsibility
 , a method calls itself, which (by moving down 
 the chain of
  Strategies
 ) calls a different implementation of the method, etc., until a termination condition is 
 reached. The termination condition is either the bottom of the chain is reached (in which case a default object 
 is returned; you may or may not be able to provide a default result so you must be able to determine the 
 success or failure of the chain) or one of the
  Strategies
  is successful.
  
 Instead of calling a single method to satisfy a request, multiple methods in the chain have a chance to satisfy 
 the request, so it has the flavor of an expert system. Since the chain is effectively a linked list, it can be 
 dynamically created, so you could also think of it as a more general, dynamically-built
  switch
  statement.
  
 In the GoF, there’s a fair amount of Thidiscussion of how to create the chain of responsibility as a linked list. 
 However, when you look at the pattern it really shouldn’t matter how the chain is maintained; that’s
  
 33.3. Chain of Responsibility
  
 175",NA
Exercises ,"1. Use
  Command
  in Chapter 3, Exercise 1.
  
 2. Implement
  Chain of Responsibility
  to create an “expert system” that solves problems by successively
  
 trying one solution after another until one matches. You should be able to dynamically add solu-
  
 tions to the expert system. The test for solution should just be a string match, but when a solution
  
 fits, the expert system should return the appropriate type of
  ProblemSolver
  object. What other pat-
  
 tern/patterns show up here?
  
 178
  
 Chapter 33. Function Objects",NA
CHAPTER,NA,NA
 34,NA,NA
Changing the Interface,"Sometimes the problem that you’re solving is as simple as “I don’t have the interface that I want.” Two of the 
 patterns in
  Design Patterns
  solve this problem:
  Adapter
  takes one type and produces an interface to some 
 other type.
  Façade
  creates an interface to a set of classes, simply to provide a more comfortable way to deal 
 with a library or bundle of resources.",NA
Adapter,"When you’ve got
  this
 , and you need
  that
 ,
  Adapter
  solves the problem. The only requirement is to produce a 
 that
 , and there are a number of ways you can accomplish this adaptation:
  
 # ChangeInterface/Adapter.py 
  
 # Variations on the Adapter pattern.
  
 class
  WhatIHave
 : 
  
 def
  g
 (
 self
 ):
  pass 
  
 def
  h
 (
 self
 ):
  pass
  
 class
  WhatIWant
 : 
  
  
 def
  f
 (
 self
 ):
  pass
  
 class
  ProxyAdapter
 (WhatIWant): 
  
  
 def
  __init__
 (
 self
 , whatIHave): 
  
  
  
 self
 .
 whatIHave
  =
  whatIHave
  
 def
  f
 (
 self
 ): 
  
 # Implement behavior using 
  
 # methods in WhatIHave: 
  
 self
 .
 whatIHave
 .
 g() 
  
 self
 .
 whatIHave
 .
 h()
  
 class
  WhatIUse
 : 
  
  
 def
  op
 (
 self
 , whatIWant):
  
 179",NA
Façade,"A general principle that I apply when I’m casting about trying to mold requirements into a first-cut object is 
 “If something is ugly, hide it inside an object.” This is basically what
  Façade
  accomplishes. If you have a rather 
 confusing collection of classes and interactions that the client programmer doesn’t really need to see, then 
 you can create an interface that is useful for the client programmer and that only presents what’s necessary.
  
 Façade is often implemented as singleton abstract factory. Of course, you can easily get this effect by creating a 
 class containing
  static
  factory methods:
  
 180
  
 Chapter 34. Changing the Interface",NA
Exercises,"1. Create an adapter class that automatically loads a two-dimensional array of objects into a dictionary
  
 as key-value pairs.
  
 34.3. Exercises
  
 181",NA
CHAPTER,NA,NA
 35,NA,NA
Table-Driven Code: Configuration Flexibility,NA,NA
Table-Driven Code Using Anonymous Inner Classes,"See
  ListPerformance
  example in TIJ from Chapter 9
  
 Also
  GreenHouse.py
  
 183",NA
CHAPTER,NA,NA
 36,NA,NA
Observer,"Decoupling code behavior
  
 Observer
 , and a category of callbacks called “multiple dispatching (not in
  Design Patterns
 )” including the 
 Visitor
  from
  Design Patterns
 . Like the other forms of callback, this contains a hook point where you can 
 change code. The difference is in the observer’s completely dynamic nature. It is often used for the specific 
 case of changes based on other object’s change of state, but is also the basis of event management. Anytime 
 you want to decouple the source of the call from the called code in a completely dynamic way.
  
 The observer pattern solves a fairly common problem: What if a group of objects needs to update them-selves 
 when some object changes state? This can be seen in the “model-view” aspect of Smalltalk’s MVC (model-
 view-controller), or the almost-equivalent “Document-View Architecture.” Suppose that you have some data 
 (the “document”) and more than one view, say a plot and a textual view. When you change the data, the two 
 views must know to update themselves, and that’s what the observer facilitates. It’s a common enough 
 problem that its solution has been made a part of the standard
  java.util
  library.
  
 There are two types of objects used to implement the observer pattern in Python. The
  Observable
  class 
 keeps track of everybody who wants to be informed when a change happens, whether the “state” has changed 
 or not. When someone says “OK, everybody should check and potentially update themselves,”the
  Observable
  
 class performs this task by calling the
  notifyObservers( )
  method for each one on the list. The
  
 notifyObservers( )
  method is part of the base class
  Observable
 .
  
 There are actually two “things that change” in the observer pattern: the quantity of observing objects and the 
 way an update occurs. That is, the observer pattern allows you to modify both of these without affecting the 
 surrounding code.
  
 Observer
  is an “interface” class that only has one member function,
  update( )
 . This function is called by the 
 object that’s being observed, when that object decides its time to update all its observers. The arguments are 
 optional; you could have an
  update( )
  with no arguments and that would still fit the observer pattern; 
 however this is more general-it allows the observed object to pass the object that caused the update (since an
  
 Observer
  may be registered with more than one observed object) and any extra information if that’s helpful, 
 rather than forcing the
  Observer
  object to hunt around to see who is updating and to fetch any other 
 information it needs.
  
 The “observed object” that decides when and how to do the updating will be called the
  Observable
 .
  
 185",NA
Observing Flowers,"Since Python doesn’t have standard library components to support the observer pattern (like Java does), we 
 must first create one. The simplest thing to do is translate the Java standard library
  Observer
  and 
 Observable
  classes. This also provides easier translation from Java code that uses these libraries.
  
 In trying to do this, we encounter a minor snag, which is the fact that Java has a
  synchronized
  keyword that 
 provides built-in support for thread synchronization. We could certainly accomplish the same thing by hand, 
 using code like this:
  
 # Util/ToSynch.py
  
 import
  threading 
  
 class
  ToSynch
 : 
  
  
 def
  __init__
 (
 self
 ): 
  
  
  
 self
 .
 mutex
  =
  threading
 .
 RLock() 
  
  
  
 self
 .
 val
  =
  1 
  
  
 def
  aSynchronizedMethod
 (
 self
 ): 
  
  
  
 self
 .
 mutex
 .
 acquire() 
  
  
  
 try
 : 
  
  
  
  
 self
 .
 val
  +=
  1 
  
  
  
  
 return
  self
 .
 val 
  
  
  
 finally
 : 
  
  
  
  
 self
 .
 mutex
 .
 release()
  
 But this rapidly becomes tedious to write and to read. Peter Norvig provided me with a much nicer solu-tion:
  
 # Util/Synchronization.py 
  
 '''Simple emulation of Java's 'synchronized' 
  
 keyword, from Peter Norvig.''' 
  
 import
  threading
  
 def
  synchronized
 (method): 
  
  
 def
  f
 (
 *
 args): 
  
  
  
 self
  =
  args[
 0
 ] 
  
  
  
 self
 .
 mutex
 .
 acquire(); 
  
  
  
 # print(method.__name__, 'acquired')
  
  
 186
  
 Chapter 36. Observer",NA
CHAPTER,NA,NA
 37,NA,NA
Multiple Dispatching,"When dealing with multiple types which are interacting, a program can get particularly messy. For ex-ample, 
 consider a system that parses and executes mathematical expressions. You want to be able to say 
 Number + 
 Number
 ,
  Number * Number
 , etc., where
  Number
  is the base class for a family of numerical objects. But 
 when you say
  a + b
 , and you don’t know the exact type of either
  a
  or
  b
 , so how can you get them to interact 
 properly?
  
 The answer starts with something you probably don’t think about: Python performs only single dispatch-ing. 
 That is, if you are performing an operation on more than one object whose type is unknown, Python can 
 invoke the dynamic binding mechanism on only one of those types. This doesn’t solve the problem, so you 
 end up detecting some types manually and effectively producing your own dynamic binding behavior.
  
 The solution is called
  multiple dispatching
 . Remember that polymorphism can occur only via member func-
 tion calls, so if you want double dispatching to occur, there must be two member function calls: the first to 
 determine the first unknown type, and the second to determine the second unknown type. With multiple 
 dispatching, you must have a polymorphic method call to determine each of the types. Generally, you’ll set up 
 a configuration such that a single member function call produces more than one dynamic member function 
 call and thus determines more than one type in the process. To get this effect, you need to work with more 
 than one polymorphic method call: you’ll need one call for each dispatch. The methods in the following 
 example are called
  compete( )
  and
  eval( )
 , and are both members of the same type. (In this case there will be 
 only two dispatches, which is referred to as
  double dispatching
 ). If you are working with two different type 
 hierarchies that are interacting, then you’ll have to have a polymorphic method call in each hierarchy.
  
 Here’s an example of multiple dispatching:
  
 # MultipleDispatching/PaperScissorsRock.py 
  
 # Demonstration of multiple dispatching.
  
 from
  __future__
  import
  generators 
  
 import
  random
  
 # An enumeration type: 
  
 class
  Outcome
 : 
  
  
 def
  __init__
 (
 self
 , value, name): 
  
  
  
 self
 .
 value
  =
  value
  
 197",NA
CHAPTER,NA,NA
 38,NA,NA
Visitor,"The visitor pattern is implemented using multiple dispatching, but people often confuse the two, because they 
 look at the implementation rather than the intent.
  
 The assumption is that you have a primary class hierarchy that is fixed; perhaps it’s from another vendor and 
 you can’t make changes to that hierarchy. However, your intent is that you’d like to add new polymor-phic 
 methods to that hierarchy, which means that normally you’d have to add something to the base class 
 interface. So the dilemma is that you need to add methods to the base class, but you can’t touch the base class. 
 How do you get around this?
  
 The design pattern that solves this kind of problem is called a “visitor” (the final one in the
  Design Patterns 
 book), and it builds on the double dispatching scheme shown in the last section.
  
 The visitor pattern allows you to extend the interface of the primary type by creating a separate class 
 hierarchy of type
  Visitor
  to virtualize the operations performed upon the primary type. The objects of the 
 primary type simply “accept” the visitor, then call the visitor’s dynamically-bound member function:
  
 # Visitor/FlowerVisitors.py 
  
 # Demonstration of ""visitor"" pattern.
  
 from
  __future__
  import
  generators 
  
 import
  random
  
 # The Flower hierarchy cannot be changed: 
  
 class
  Flower
 (
 object
 ): 
  
  
 def
  accept
 (
 self
 , visitor): 
  
  
  
 visitor
 .
 visit(
 self
 ) 
  
  
 def
  pollinate
 (
 self
 , pollinator): 
  
  
  
 print
 (
 self
 ,
  ""pollinated by""
 , pollinator) 
  
 def
  eat
 (
 self
 , 
 eater): 
  
  
  
 print
 (
 self
 ,
  ""eaten by""
 , eater) 
  
  
 def
  __str__
 (
 self
 ): 
  
  
  
 return
  self
 .
 __class__
 .
 __name__
  
 class
  
 Gladiolus
 (Flower):
  
 pass 
  
 class
  
 Runuculus
 (Flower):
  
 pass 
  
 class
  Chrysanthemum
 (Flower):
  pass
  
 201",NA
Exercises,"1. Create a business-modeling environment with three types of
  Inhabitant
 :
  Dwarf
  (for engineers),
  Elf 
 (for 
 marketers) and
  Troll
  (for managers). Now create a class called
  Project
  that creates the different 
 inhabitants and causes them to
  interact( )
  with each other using multiple dispatching.
  
 2. Modify the above example to make the interactions more detailed. Each
  Inhabitant
  can randomly 
 produce a
  Weapon
  using
  getWeapon( )
 : a
  Dwarf
  uses
  Jargon
  or
  Play
 , an
  Elf
  uses
  InventFeature 
 or
  
 SellImaginaryProduct
 , and a
  Troll
  uses
  Edict
  and
  Schedule
 . You must decide which weapons“win” 
 and “lose” in each interaction (as in
  PaperScissorsRock.py
 ). Add a
  battle( )
  member function to
  
 Project
  that takes two
  Inhabitant
 s and matches them against each other. Now create a
  meeting( ) 
 member function for
  Project
  that creates groups of
  Dwarf
 ,
  Elf
  and
  Manager
  and battles the groups 
 against each other until only members of one group are left standing. These are the “winners.”
  
 3. Modify
  PaperScissorsRock.py
  to replace the double dispatching with a table lookup. The easiest way to 
 do this is to create a
  Map
  of
  Map
 s, with the key of each
  Map
  the class of each object. Then you
  
 202
  
 Chapter 38. Visitor",NA
CHAPTER,NA,NA
 39,NA,NA
Pattern Refactoring,"Note:
  This chapter has not had any significant translation yet.
  
 This chapter will look at the process of solving a problem by applying design patterns in an evolutionary 
 fashion. That is, a first cut design will be used for the initial solution, and then this solution will be examined 
 and various design patterns will be applied to the problem (some of which will work, and some of which 
 won’t). The key question that will always be asked in seeking improved solutions is “what will change?”
  
 This process is similar to what Martin Fowler talks about in his book
  Refactoring: Improving the Design of 
 Existing Code [#]_
  (although he tends to talk about pieces of code more than pattern-level designs). You start 
 with a solution, and then when you discover that it doesn’t continue to meet your needs, you fix it. Of course, 
 this is a natural tendency but in computer programming it’s been extremely difficult to accomplish with 
 procedural programs, and the acceptance of the idea that we
  can
  refactor code and designs adds to the body 
 of proof that object-oriented programming is “a good thing.”",NA
Simulating the Trash Recycler,"The nature of this problem is that the trash is thrown unclassified into a single bin, so the specific type 
 information is lost. But later, the specific type information must be recovered to properly sort the trash. In the 
 initial solution, RTTI (described in
  Thinking in Java
 ) is used.
  
 This is not a trivial design because it has an added constraint. That’s what makes it interesting-it’s more like 
 the messy problems you’re likely to encounter in your work. The extra constraint is that the trash arrives at 
 the trash recycling plant all mixed together. The program must model the sorting of that trash. This is where 
 RTTI comes in: you have a bunch of anonymous pieces of trash, and the program figures out exactly what type 
 they are:
  
 # PatternRefactoring/recyclea/RecycleA.py 
  
 # Recycling with RTTI.
  
 class
  Trash
 :
  
 205",NA
Improving the Design,"The solutions in
  Design Patterns
  are organized around the question “What will change as this program 
 evolves?” This is usually the most important question that you can ask about any design. If you can build your 
 system around the answer, the results will be two-pronged: not only will your system allow easy (and 
 inexpensive) maintenance, but you might also produce components that are reusable, so that other systems 
 can be built more cheaply. This is the promise of object-oriented programming, but it doesn’t happen 
 automatically; it requires thought and insight on your part. In this section we’ll see how this process can 
 happen during the refinement of a system.
  
 The answer to the question “What will change?” for the recycling system is a common one: more types will be 
 added to the system. The goal of the design, then, is to make this addition of types as painless as possible. In 
 the recycling program, we’d like to encapsulate all places where specific type information is mentioned, so (if 
 for no other reason) any changes can be localized to those encapsulations. It turns out that this process also 
 cleans up the rest of the code considerably.
  
 “Make More Objects”
  
 This brings up a general object-oriented design principle that I first heard spoken by Grady Booch: “If the 
 design is too complicated, make more objects.” This is simultaneously counterintuitive and ludicrously 
 simple, and yet it’s the most useful guideline I’ve found. (You might observe that “making more objects”is 
 often equivalent to “add another level of indirection.”) In general, if you find a place with messy code, 
 consider what sort of class would clean that up. Often the side effect of cleaning up the code will be a system 
 that has better structure and is more flexible.
  
 Consider first the place where
  Trash
  objects are created, which is a
  switch
  statement inside
  main( )
 :
  
 # PatternRefactoring/clip1.py 
  
  
 for
 (
 int
  i
  =
  0
  i
  <
  30
  i
 ++
 ) 
  
  
  
 switch((
 int
 )(Math
 .
 random()
  *
  3
 )): 
  
  
  
  
 case
  0
  : 
  
  
  
  
  
 bin
 .
 add(new 
  
  
  
  
  
  
 Aluminum(Math
 .
 random()
  *
  100
 )) 
  
  
  
  
 break 
  
  
  
  
 case
  1
  : 
  
  
  
  
  
 bin
 .
 add(new 
  
  
  
  
  
  
 Paper(Math
 .
 random()
  *
  100
 )) 
  
  
  
  
 break 
  
  
  
  
 case
  2
  : 
  
  
  
  
  
 bin
 .
 add(new 
  
  
  
  
  
  
 Glass(Math
 .
 random()
  *
  100
 ))
  
 This is definitely messy, and also a place where you must change code whenever a new type is added. If new 
 types are commonly added, a better solution is a single method that takes all of the necessary information and 
 produces a reference to an object of the correct type, already upcast to a trash object. In
  Design Patterns 
 this is 
 broadly referred to as a
  creational pattern
  (of which there are several). The specific pattern that will be
  
 208
  
 Chapter 39. Pattern Refactoring",NA
A Pattern for Prototyping Creation,"A problem with the design above is that it still requires a central location where all the types of the objects 
 must be known: inside the
  factory( )
  method. If new types are regularly being added to the system, the 
 factory( )
  method must be changed for each new type. When you discover something like this, it is useful to 
 try to go one step further and move
  all
  of the information about the type-including its creation-into the class 
 representing that type. This way, the only thing you need to do to add a new type to the system is to inherit a 
 single class.
  
 To move the information concerning type creation into each specific type of
  Trash
 , the “prototype” pattern 
 (from the
  Design Patterns
  book) will be used. The general idea is that you have a master sequence of objects, 
 one of each type you’re interested in making. The objects in this sequence are used
  only
  for making new 
 objects, using an operation that’s not unlike the
  clone( )
  scheme built into Java’s root class
  Object
 . In this 
 case, we’ll name the cloning method
  tClone( )
 . When you’re ready to make a new object, presumably you 
 have some sort of information that establishes the type of object you want to create, then you move through 
 the master sequence comparing your information with whatever appropriate information is in the prototype 
 objects in the master sequence. When you find one that matches your needs, you clone it.
  
 In this scheme there is no hard-coded information for creation. Each object knows how to expose appro-
 priate information and how to clone itself. Thus, the
  factory( )
  method doesn’t need to be changed when a 
 new type is added to the system.
  
 One approach to the problem of prototyping is to add a number of methods to support the creation of new 
 objects. However, in Java 1.1 there’s already support for creating new objects if you have a reference to the 
 Class
  object. With Java 1.1
  reflection
  (introduced in
  Thinking in Java
 ) you can call a constructor even if you 
 have only a reference to the
  Class
  object. This is the perfect solution for the prototyping problem.
  
 The list of prototypes will be represented indirectly by a list of references to all the
  Class
  objects you want to 
 create. In addition, if the prototyping fails, the
  factory( )
  method will assume that it’s because a particular 
 Class
  object wasn’t in the list, and it will attempt to load it. By loading the prototypes dynamically like this, 
 the
  Trash
  class doesn’t need to know what types it is working with, so it doesn’t need any modifications 
 when you add new types. This allows it to be easily reused throughout the rest of the chapter:
  
 # PatternRefactoring/trash/Trash.py 
  
 # Base class for Trash recycling examples.
  
 class
  Trash
 : 
  
 def
  __init__
 (
 self
 , wt):
  self
 .
 weight
  =
  wt 
  
 def
  getValue
 (
 self
 ):
  pass 
  
 def
  getWeight
 (
 self
 ):
  return
  weight 
  
 # Sums the value of Trash given an
  
  
 210
  
 Chapter 39. Pattern Refactoring",NA
Abstracting Usage,"With creation out of the way, it’s time to tackle the remainder of the design: where the classes are used. Since 
 it’s the act of sorting into bins that’s particularly ugly and exposed, why not take that process and hide it 
 inside a class? This is the principle of “If you must do something ugly, at least localize the ugliness inside a 
 class.” It looks like this:
  
  
 The
  TrashSorter
  object initialization must now be changed whenever a new type of
  Trash
  is added to the 
 model. You could imagine that the
  TrashSorter
  class might look something like this:
  
 class
  TrashSorter
 (ArrayList): 
  
 def
  sort
 (
 self
 , Trash t):
  /* ... */
  
  
 216
  
 Chapter 39. Pattern Refactoring",NA
Multiple Dispatching,"The above design is certainly satisfactory. Adding new types to the system consists of adding or modifying 
 distinct classes without causing code changes to be propagated throughout the system. In addition, RTTI is 
 not “misused” as it was in
  RecycleA.py
 . However, it’s possible to go one step further and take a purist 
 viewpoint about RTTI and say that it should be eliminated altogether from the operation of sorting the trash 
 into bins.
  
 To accomplish this, you must first take the perspective that all type-dependent activities-such as detecting the 
 type of a piece of trash and putting it into the appropriate bin-should be controlled through polymor-phism 
 and dynamic binding.
  
 The previous examples first sorted by type, then acted on sequences of elements that were all of a particular 
 type. But whenever you find yourself picking out particular types, stop and think. The whole idea of 
 polymorphism (dynamically- bound method calls) is to handle type-specific information for you. So why are 
 you hunting for types?
  
 The answer is something you probably don’t think about: Python performs only single dispatching. That is, if 
 you are performing an operation on more than one object whose type is unknown, Python will invoke the 
 dynamic binding mechanism on only one of those types. This doesn’t solve the problem, so you end up 
 detecting some types manually and effectively producing your own dynamic binding behavior.
  
 The solution is called
  multiple dispatching
 , which means setting up a configuration such that a single method 
 call produces more than one dynamic method call and thus determines more than one type in the process. To 
 get this effect, you need to work with more than one type hierarchy: you’ll need a type hierarchy for each 
 dispatch. The following example works with two hierarchies: the existing
  Trash
  family and a hierarchy of the 
 types of trash bins that the trash will be placed into. This second hierarchy isn’t always obvious and in this 
 case it needed to be created in order to produce multiple dispatching (in this case there will be only two 
 dispatches, which is referred to as
  double dispatching
 ).
  
 Implementing the Double Dispatch
  
 Remember that polymorphism can occur only via method calls, so if you want double dispatching to occur, 
 there must be two method calls: one used to determine the type within each hierarchy. In the Trash hier-
 archy there will be a new method called addToBin( ), which takes an argument of an array of TypedBin. It 
 uses this array to step through and try to add itself to the appropriate bin, and this is where you’ll see the 
 double dispatch.
  
 39.5. Multiple Dispatching
  
 219",NA
The,NA,NA
 Visitor,NA,NA
 Pattern,"Now consider applying a design pattern that has an entirely different goal to the trash sorting problem.
  
 For this pattern, we are no longer concerned with optimizing the addition of new types of
  Trash
  to the 
 system. Indeed, this pattern makes adding a new type of
  Trash
  more
  complicated. The assumption is that you 
 have a primary class hierarchy that is fixed; perhaps it’s from another vendor and you can’t make changes to 
 that hierarchy. However, you’d like to add new polymorphic methods to that hierarchy, which means that 
 normally you’d have to add something to the base class interface. So the dilemma is that you need to add 
 methods to the base class, but you can’t touch the base class. How do you get around this?
  
 The design pattern that solves this kind of problem is called a “visitor” (the final one in the
  Design Patterns 
 book), and it builds on the double dispatching scheme shown in the last section.
  
 The visitor pattern allows you to extend the interface of the primary type by creating a separate class 
 hierarchy of type
  Visitor
  to virtualize the operations performed upon the primary type. The objects of the 
 primary type simply “accept” the visitor, then call the visitor’s dynamically-bound method. It looks like this:
  
 224
  
 Chapter 39. Pattern Refactoring",NA
RTTI Considered Harmful?,"Various designs in this chapter attempt to remove RTTI, which might give you the impression that 
 it’s“considered harmful” (the condemnation used for poor, ill- fated
  goto
 , which was thus never put into 
 Java). This isn’t true; it is the
  misuse
  of RTTI that is the problem. The reason our designs removed RTTI is 
 because the misapplication of that feature prevented extensibility, while the stated goal was to be able to add 
 a new type to the system with as little impact on surrounding code as possible. Since RTTI is often misused by 
 having it look for every single type in your system, it causes code to be non-extensible: when you add a new 
 type, you have to go hunting for all the code in which RTTI is used, and if you miss any you won’t get help 
 from the compiler.
  
 However, RTTI doesn’t automatically create non-extensible code. Let’s revisit the trash recycler once more. 
 This time, a new tool will be introduced, which I call a
  TypeMap
 . It contains a
  HashMap
  that holds
  Ar-
 rayList
 s, but the interface is simple: you can
  add( )
  a new object, and you can
  get( )
  an
  ArrayList
  containing 
 all the objects of a particular type. The keys for the contained
  HashMap
  are the types in the associated 
 ArrayList
 . The beauty of this design (suggested by Larry O’Brien) is that the
  TypeMap
  dynamically adds a 
 new pair whenever it encounters a new type, so whenever you add a new type to the system (even if you add 
 the new type at run time), it adapts.
  
 Our example will again build on the structure of the
  Trash
  types in
  package patternRefactoring.Trash
  (and 
 the
  Trash.dat
  file used there can be used here without change):
  
 # PatternRefactoring/dynatrash/DynaTrash.py 
  
 # Using a Map of Lists and RTTI 
  
 # to automatically sort trash into 
  
 # ArrayLists. This solution, despite the 
  
 # use of RTTI, is extensible.
  
 # Generic TypeMap works in any situation: 
  
 class
  TypeMap
 : 
  
  
 t
  =
  HashMap() 
  
  
 def
  add
 (
 self
 , Object o): 
  
  
  
 Class
  type
  =
  o
 .
 getClass() 
  
  
  
 if
 (
 self
 .
 t
 .
 has_key(
 type
 )) 
  
  
  
  
 self
 .
 t
 .
 get(
 type
 )
 .
 add(o) 
  
  
  
 else
 : 
  
  
  
  
 List v
  =
  ArrayList() 
  
  
  
  
 v
 .
 add(o) 
  
  
  
  
 t
 .
 put(
 type
 ,v)
  
 def
  get
 (
 self
 , Class
  type
 ):
  
  
 230
  
 Chapter 39. Pattern Refactoring",NA
Summary,"Coming up with a design such as
  TrashVisitor.py
  that contains a larger amount of code than the earlier 
 designs can seem at first to be counterproductive. It pays to notice what you’re trying to accomplish with 
 various designs. Design patterns in general strive to
  separate the things that change from the things that stay 
 the same
 . The “things that change” can refer to many different kinds of changes. Perhaps the change occurs 
 because the program is placed into a new environment or because something in the current environment 
 changes (this could be: “The user wants to add a new shape to the diagram currently on the screen”). Or, as in 
 this case, the change could be the evolution of the code body. While previous versions of the trash sorting 
 example emphasized the addition of new
  types
  of
  Trash
  to the system,
  TrashVisitor.py
  allows you to easily 
 add new
  functionality
  without disturbing the
  Trash
  hierarchy. There’s more code in
  TrashVisitor.py
 , but 
 adding new functionality to
  Visitor
  is cheap. If this is something that happens a lot, then it’s worth the extra 
 effort and code to make it happen more easily.
  
 The discovery of the vector of change is no trivial matter; it’s not something that an analyst can usually detect 
 before the program sees its initial design. The necessary information will probably not appear until later 
 phases in the project: sometimes only at the design or implementation phases do you discover a deeper or 
 more subtle need in your system. In the case of adding new types (which was the focus of most of the“recycle” 
 examples) you might realize that you need a particular inheritance hierarchy only when you are in the 
 maintenance phase and you begin extending the system!
  
 One of the most important things that you’ll learn by studying design patterns seems to be an about-face from 
 what has been promoted so far in this book. That is: “OOP is all about polymorphism.” This statement can 
 produce the “two-year- old with a hammer” syndrome (everything looks like a nail). Put another way, it’s 
 hard enough to “get” polymorphism, and once you do, you try to cast all your designs into that one particular 
 mold.
  
 What design patterns say is that OOP isn’t just about polymorphism. It’s about “separating the things that 
 change from the things that stay the same.” Polymorphism is an especially important way to do this, and it 
 turns out to be helpful if the programming language directly supports polymorphism (so you don’t have to 
 wire it in yourself, which would tend to make it prohibitively expensive). But design patterns in general show
  
 other
  ways to accomplish the basic goal, and once your eyes have been opened to this you will begin to search 
 for more creative designs.
  
 Since the
  Design Patterns
  book came out and made such an impact, people have been searching for other 
 patterns. You can expect to see more of these appear as time goes on. Here are some sites recommended by 
 Jim Coplien, of C++ fame (
 http://www.bell-labs.com/~cope
 ), who is one of the main proponents of the patterns 
 movement:
  
 http://st-www.cs.uiuc.edu/users/patterns 
  
 http://c2.com/cgi/wiki 
  
 http://c2.com/ppr 
  
 http: 
 //www.bell-labs.com/people/cope/Patterns/Process/index.html http://www.bell-labs.com/cgi-user/ 
 OrgPatterns/OrgPatterns 
  
 http://st-www.cs.uiuc.edu/cgi-bin/wikic/wikic 
  
  
 http://www.cs.wustl.edu/ 
 ~schmidt/patterns.html http://www.espinc.com/patterns/overview.html
  
 Also note there has been a yearly conference on design patterns, called PLOP, that produces a published 
 proceedings, the third of which came out in late 1997 (all published by Addison-Wesley).",NA
Exercises,"1. Add a class
  Plastic
  to
  TrashVisitor.py
 .
  
 232
  
 Chapter 39. Pattern Refactoring",NA
CHAPTER,NA,NA
 40,NA,NA
Projects,"Note:
  This chapter has not had any significant translation yet.
  
 A number of more challenging projects for you to solve. [[Some of these may turn into examples in the book, 
 and so at some point might disappear from here]]",NA
Rats & Mazes,"First, create a
  Blackboard
  (cite reference) which is an object on which anyone may record information. This 
 particular blackboard draws a maze, and is used as information comes back about the structure of a maze 
 from the rats that are investigating it.
  
 Now create the maze itself. Like a real maze, this object reveals very little information about itself - given a 
 coordinate, it will tell you whether there are walls or spaces in the four directions immediately surrounding 
 that coordinate, but no more. For starters, read the maze in from a text file but consider hunting on the 
 internet for a maze-generating algorithm. In any event, the result should be an object that, given a maze 
 coordinate, will report walls and spaces around that coordinate. Also, you must be able to ask it for an entry 
 point to the maze.
  
 Finally, create the maze-investigating
  Rat
  class. Each rat can communicate with both the blackboard to give 
 the current information and the maze to request new information based on the current position of the rat. 
 However, each time a rat reaches a decision point where the maze branches, it creates a new rat to go down 
 each of the branches. Each rat is driven by its own thread. When a rat reaches a dead end, it terminates itself 
 after reporting the results of its final investigation to the blackboard.
  
 The goal is to completely map the maze, but you must also determine whether the end condition will be 
 naturally found or whether the blackboard must be responsible for the decision.
  
 An example implementation by Jeremy Meyer:
  
 # Projects/ratsAndMazes/Maze.py
  
 235",NA
CHAPTER,NA,NA
 41,NA,NA
Indices and tables,"• genindex
  
 • search
  
 241",NA
Index,NA,NA
C,"canonical form 
  
  
 script command-line,
  113 
 class decorators,
  59 
  
 command-line 
  
  
 canonical form, script,
  113 
 comprehension 
  
  
 generator,
  75 
  
  
 list,
  75 
  
 concurrency,
  83 
  
 coroutines,
  83",NA
D,"Python 3 
  
 Language differences,
  47",NA
S,"script 
  
 command-line canonical form,
  113",NA
T,"threads,
  83
  
 data transfer object (messenger),
  115 
  
 decorator: Python decorators,
  49",NA
G,"generator 
  
  
 comprehension,
  75 
  
 generators,
  73 
  
 GIL: Global Interpreter Lock,
  83",NA
I,"iterators,
  
 73 
  
 itertools,
  73",NA
L,"Language differences 
  
  
 Python 3,
  47 
  
 list 
  
  
 comprehension,
  75",NA
M,"messenger (data transfer object),
  115 
  
 Metaprogramming,
  59 
  
 multiprocessing,
  83",NA
P,"parallelism,
  83
  
 243",NA
