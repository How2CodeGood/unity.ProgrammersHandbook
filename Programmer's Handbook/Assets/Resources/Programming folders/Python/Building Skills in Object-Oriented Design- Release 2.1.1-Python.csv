Larger Text,Smaller Text,Symbol
Building Skills in Object-Oriented Design ,NA,NA
Release 2.1.1-Python,NA,NA
Steven F. Lott,"December 30, 2009",NA
CONTENTS,"I
  
 Front Matter
  
 3
  
  
 1
  
 Preface
  
 1.1 Why Read This Book? 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.2 Audience
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.3 Organization of This Book
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.4 Why This Subject? 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.5 Programming Style 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.6 Conventions Used in This Book 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.7 Acknowledgements
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5 
  
 5 
  
 6 
  
 7 
  
 9 
  
 9 
  
 1
 0 
 1
 1
  
 2
  
 Foundations
  
 2.1 Problem Statement 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.2 Our Simulation Application
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.3 Soapbox on Use Cases
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.4 Solution Approach
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.5 Methodology, Technique and Process 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.6 Deliverables 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
 3 
 1
 3 
 1
 5 
 1
 5 
 1
 6 
 1
 7 
 2
 2
  
 II
  
 Roulette
  
 2
 5
  
 3
  
 Roulette Details 
  
 3.1 Roulette Game
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 3.2 Available Bets in Roulette
  . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 3.3 Some Betting Strategies
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2
 9 
 2
 9 
 2
 9 
 3
 2
  
 4
  
 Roulette Solution Overview
  
 4.1 Preliminary Survey of Classes 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.2 Preliminary Roulette Class Structure 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.3 A Walkthrough of Roulette
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.4 Roulette Solution Questions and Answers
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
 5 
 3
 5 
 3
 6 
 3
 7 
 3
 8
  
 5
  
 Outcome Class
  
 5.1 Outcome Overview 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.2 Design Decision – Object Identity
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.3 Outcome Design
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.4 Outcome Deliverables
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.5 Message Formatting
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
 1 
 4
 1 
 4
 1 
 4
 4 
 4
 5 
 4
 5
  
 6
  
 Bin Class
  
 47
  
 i",NA
Part I ,NA,NA
Front Matter,3,NA
ONE,NA,NA
PREFACE,"Pensés, The Provincial Letters: Provincial letter 16, p. 571.
  
 The present letter is a very long one, simply because I had no leisure to make it shorter.
  
 – BLAISE PASCAL",NA
1.1 Why Read This Book?,"The coffee-shop reason for reading this book is to provide the beginning designer with a sequence of 
 interesting and moderately complex exercises in OO design.
  
 If that’s all you needed to know, skip to the next chapter. It’s okay. We don’t mind.
  
 The Problem
 . Some software developers find themselves stalled when trying to do object-oriented (OO) 
 design. As programmers, they’ve understood the syntax of a programming language, and pieced together 
 small examples. However, it is often difficult to take the next step to becoming a designer. The transition from 
 guided learning of language features to self-directed design work is often ignored. Programmers are left to 
 struggle through their first design projects without appropriate skills or support.
  
 This may be you. You’ve learned the language, but you can’t take the next step.
  
 While it is critically important to read examples of good design, a finished product doesn’t reveal the author’s 
 decision-making process that created the design. There’s little support that helps a programmer come to 
 understand the design process that leads to a final product.
  
 The most notable consequence of this skills gap is some n00b programmers will create of software that is far 
 more complex than necessary to effectively solve a given problem. This, in turn, leads to software with high 
 maintenance costs stemming from the low quality. It also leads to an unfair indictment of OO technology; this 
 is usually voiced as “we tried OO programming and it failed.”
  
 Unrealistic Expectations
 . As programming team leaders, educators and consultants, we find that software 
 development training is focused on the programming tools, but does not expose the process of creating a 
 design. We all start out building software designed by someone else. What’s involved in design?
  
 In the building trades, we would neither expect nor allow apprentice plumbers to design the sanitary sewage 
 system for an urban office building. Yet, in too many
  Information Technology
  (IT) departments, software 
 developers are expected to leap from basic training in their tools to application design.
  
 To continue this rant, we also find that some managers are entrusted with significant projects, but are 
 uncomfortable with OO design on modern high-performance hardware. They tend to focus their design 
 energies on the kinds of software architectures that were appropriate when the enterprise owned a single 
 computer, when 64 megabytes of memory was all the enterprise would ever need, and centralized disk 
 storage was charged back to end user departments at a rate of pennies per track per month. In some 
 organizations,
  
 5",NA
1.2 Audience,"Our primary audience – you – includes programmers who are new to OO programming.
  
 You need to have an exposure to the language, but you need more time to understand objects and object-
 orientation. We will provide exercises that have four key features: just complex enough to require careful 
 design work, just fun enough to be engaging, easy enough that results are available immediately, and can be 
 built in simple stages.
  
 In our effort to support you, we’ll provide a few additional details on language features. We’ll mark these as 
 “Tips”. For more advanced students, these tips will be review material. We will not provide a thorough 
 background in any programming language. The student is expected to know the basics of the language and 
 tools.
  
 Helpful additional skills include using one of the various unit test and documentation frameworks available. 
 We’ve included information in the appendices.
  
 OO Misdirection
 . Have you found your first exposure to objects to be more distasteful than empowering? 
 Why does this happen?
  
 Some instructors preface a course on a language (like Python or Java) with an extensive presentations on 
 object orientation. It’s not easy to grasp OO design concepts before getting to the language fundamentals.
  
 In some cases, this leaves students lost as to how they will accomplish the noble and lofty goals of OO.
  
 Other instructors leave OO for last, exposing the procedural side of the language first, and treating objects as a 
 kind of add-on. This leaves students feeling that objects are optional. Additionally, some very skilled 
 instructors are not skilled developers, and will often show examples that don’t reflect currently accepted best 
 practices.
  
 6
  
 Chapter 1.
  
 Prefac
 e",NA
1.3 Organization of This Book,"This book presents a series of exercises to build simulations of the common, popular casino table games: 
 Roulette, Craps and Blackjack. Each simulation can be extended to include variations on the player’s betting 
 system. With a simple statistical approach, we can show the realistic expectations for any betting system. 
 Each of these games has a separate part in this book. Each part consists of a number of individual exercises to 
 build the entire simulation. The completed project results in an application that can provide simple tabular 
 results that shows the average losses expected from each betting strategy.
  
 The interesting degree of freedom in each of the simulations is the player’s betting strategy. The design will 
 permit easy adaptation and maintenance of the player’s strategies. The resulting application program can be 
 extended by inserting additional betting systems, which allows exploration of what (if any) player actions can 
 minimize the losses.
  
 1.3.
  
 Organization of This Book
  
 7",NA
1.4 Why This Subject?,"Casino table games may seem like an odd choice of subject matter for programming exercises. We find that 
 casino games have a number of advantages for teaching OO design and OO programming.
  
 • Casino games have an almost ideal level of complexity. If they were too simple, the
  house edge
  would be 
 too obvious and people would not play them. If they were too complex, people would not enjoy them as 
 simple recreation. Years (centuries?) of experience in the gaming industry has fine-tuned the table 
 games to fit nicely with the limits of our human intellect.
  
 • Simulation of discrete phenomena lies at the origin of OO programming. We have found it easier to mo-
 tivate, explain and justify OO design when solving simulation problems. The student can then leverage 
 this insight into other applications of OO programming for more common transactional applications.
  
 • The results are sophisticated but easy to interpret. Probability theory has been applied by others to 
 develop precise expectations for each game. These simulations should produce results consistent with 
 the known probabilities. This book will skim over the probability theory in order to focus on the 
 programming. For a few exercises, the theoretical results will be provided to serve as checks on the 
 correctness of the student’s work.
  
 • They’re more fun than most other programming problems.
  
 This book does not endorse casino gaming. Indeed, one of the messages of this book is that all casino games 
 are biased against the player. Even the most casual study of the results of the exercises will allow the student 
 to see the magnitude of the
  house edge
  in each of the games presented.",NA
1.5 Programming Style,"We have to adopt a
  style
  for each of the languages we’re presenting. We won’t present a complete set of
  
 coding standards
 ; we will omit a number of issues that should be standardized. Some IT shops have 
 documents they call “coding standards”, but are little more than descriptive style guides. What follows is not 
 this kind of style guide; instead, it is some justification of the style we use for the examples in this book.
  
 Just to continune this rant, we find that source code examples speak louder than any gratuitously 
 detailed“specification” of the desired style. We find that some IT organizations waste time trying to write 
 definitions of the preferred style. A good example trumps the description of the example. In particular, as 
 consultants, we are often asked to provide standards to an inexperienced team of programmers. While the 
 programmers only look at the examples (often cutting and pasting them), some managers prefer to spend 
 money on empty verbiage peripheral to the useful example.
  
 Terminology
 . We tend to prefer Java-centric terminology: “field” and “method”. Occasionally, we will em-
 phasize the differences between Java and Python by using the Python terms “attribute”, “instance variable”or 
 “method function” .
  
 Naming Style
 . We avoid using complex prefixes for variable names. In particular, we find prefixes to be little 
 more than visual clutter. For example, an integer parameter with the amount of a bet might be called 
 pi_amount where the prefix indicates the scope (
 p
  for a parameter) and type (
 i
  for an integer).
  
 1.4.
  
 Why This Subject?
  
 9",NA
1.6 Conventions Used in This Book,"Here is a Python example.
  
 Typical Python Example
  
 from
  collections
  import
  defaultdict 
  
 combo
  =
  defaultdict(
 int
 ) 
  
 for
  i
  in
  range
 (
 1
 ,
 7
 ): 
  
 for
  j
  in
  range
 (
 1
 ,
 7
 ): 
  
  
  
 roll
 =
  i
 +
 j 
  
  
  
 combo[roll]
  +=
  1 
  
 for
  n
  in
  range
 (
 2
 ,
 13
 ): 
  
 print
  ""
 %d %.2f%%
 ""
  %
  ( n, combo[n]
 /
 36.0
  )
  
 1. We create a Python dictionary, a map from key to value. We use the collections.defaultdict so that missing 
 keys are created in the dictionary with an initial value created by the int() function.
  
 2. We iterate through all combinations of two dice, using variables i and j to represent each die.
  
 3. We sum the dice to create a roll. We increment the value in the dictionary based on the roll.
  
 4. Finally, we print each member of the resulting dictionary.
  
 The output from the above program will be shown as follows:
  
 2 0.03% 
  
 3 0.06% 
  
 4 0.08% 
  
 5 0.11% 
  
 6 0.14% 
  
 7 0.17% 
  
 8 0.14% 
  
 9 0.11% 
  
 10 0.08% 
  
 11 0.06% 
  
 12 0.03%
  
 We will use the following type styles for references to a specific Class, method(), or variable.
  
 Most of the design specifications will provide Java-style method and variable descriptions. Python doesn’t use 
 type specifications, and Python programmers will have to translate the Java specifications into Python by 
 removing the type names.
  
 10
  
 Chapter 1.
  
 Prefac
 e",NA
1.7 Acknowledgements,"We would like to thank Chuck Pyrak for putting us up to this. His idea of a One Room Schoolhouse to teach 
 Java to an audience at multiple skill levels was a great idea. Additionally, our colleagues who collaborated 
 through BLOKI brought infinte wisdom and insight to a complex and difficult project.
  
 Thanks to Dion Dock and Robert Lucente for comments and corrections.",NA
TWO,NA,NA
FOUNDATIONS,"We’ll set our goal by presenting several elements that make up a complete
  problem statement
 : a
  context 
 in 
 which the problem arises, the
  problem
 , the
  forces
  that influence the choice of solution, the
  solution
  that 
 balances the forces, and some
  consequences
  of the chosen solution.
  
 Based on the problem statement, we’ll present the high-level use case that this software implements. The use 
 case is almost too trivial to bother defining. However, we have seen many projects run aground because they 
 lacked even the most rudimentary description of the actor, the system and how the system helps the actor 
 create value.
  
 We will summarize the approach to the solution, describing the overall strategy that we will follow. This is a 
 kind of overall design pattern that we’ll use to establish some areas of responsibility.
  
 We will also describe the technical foundations. In this case, they are not terribly complex, but this is an 
 important part of describing any software solution, no matter how simple.
  
 We will dance around the methodology issue. Our intent is not to sell a particular methodology, but to provide 
 some perspective on how we broke the work into manageable pieces.
  
 Finally, we’ll present some important parts of getting started on the solution. 
 technical considerations that define common aspects of our approach.
  
 These are more specific,",NA
2.1 Problem Statement,"We’ll start with a big-picture overview of our problem. We’ll present the context in which the problem arises, 
 a summary of the problem, and a “business use case”. This will show how our application is used.
  
 We can then dig into the details of our application.
  
 Important: 
 Fools Rush In
  
 It’s important not to rush in to programming.
  
 Here’s the rule:
  The first person to cut code loses
 .
  
 Be sure you understand the problem being solved and how software solves that problem.
  
 Context
 . Our context is the “classic” casino table games played against the house, including Roulette, Craps 
 and Blackjack. We want to explore the consequences of various betting strategies for these casino games.
  
 Questions include “How well does the Cancellation strategy work?” “How well does the Martingale strategy 
 works for the Come Line odds bet in Craps?” “How well does this Blackjack strategy I found on the Internet 
 compare with the strategy card I bought in the gift shop?”
  
 13",NA
2.2 Our Simulation Application,"The previous section was a fluffy overview of what we’re trying to accomplish. It sets some goals and provides 
 a detailed context for who’s using this application and why.
  
 Armed with that informatin, we can look at the simulation application we’re going to write.
  
 Our simulation application will allow a programmer to experiment with different casino game betting strate-
 gies. We’ll build a simple, command-line simulator that provides a reliable, accurate model of the game. We 
 need to be able to easily pick one of a variety of player betting strategies, play a number of simulated rounds 
 of the game, and produce a statistical summary of the results of that betting strategy.
  
 This leads us to a small
  essential use case
 . There is a single
  actor
 , the “investigator”. The actor’s goal is to see 
 the expected results of using a particular strategy for a particular game. The typical scenario is the following.
  
 Essential Use Case
  
 1.
  Actor
 . Specifies which game and betting strategy to test.
  
 The game may require additional parameters, like betting limits.
  
 The strategy may need additional parameters, like an initial budget, or
  stake
 .
  
 2.
  System
 . Responds with a statistical summary of the outcomes after a fixed number of cycles (spins, or 
 throws or hands). The number of cycles needs to be small (on the order of 200, to reflect only a few 
 hours of play).
  
 On Simplicity
 . Yes, this use case is very simple. It’s a command-line application: it’s supposed to be simple.
  
 The point is to explore OO design, not development of a fancy GUI or web application.
  
 Simplicity is a virtue. You can add a fancy GUI or web presentation of the results later. First, create some 
 results.",NA
2.3 Soapbox on Use Cases,"We feel that the use case technique is badly abused by some IT organizations. Quoting from 
 [Jacobson95]
 . “A use case is a sequence of transactions in a system whose task is to yield a result 
 of measurable value to an individual actor of the system.”
  
 A use case will clearly identify an actor, define the value created, and define a sequence of 
 transactions. A use case will be a kind of system test specification. A use case will define the 
 system’s behavior, and define why an actor bothers to interact with it.
  
 2.2.
  
 Our Simulation Application
  
 15",NA
2.4 Solution Approach,"From reading the problem and use case information, we can identify at least the following four general 
 elements to our application.
  
 • The game being simulated. This includes the various elements of the game: the wheel, the dice, the 
  
 cards, the table and the bets.
  
 • The player being simulated. This includes the various decisions the player makes based on the state 
  
 of the game, and the various rules of the betting system the player is following.
  
 • The statistics being collected.
  
 • An overall control component which processes the game, collects the statistics and writes the details 
  
 or the final summary.
  
 When we look at common design patterns, the
  Model-View-Control
  pattern often helps to structure ap-
 plications. A more sophisticated, transactional application may require a more complex structure. However, 
 in this case, the game, the player, and the statistics are the model. The command line selection of player
  
 16
  
 Chapter 2.
  
 Foundation
 s",NA
"2.5 Methodology, Technique and Process","We want to focus on technical skills; we won’t follow any particular software development methodology too 
 closely. We hesitate to endorse a specific methodology; doing so inevitably alienates readers who embrace a 
 different methodology. 
  
 To continue this rant, we find that almost everyone has an existing notion of the 
 proper way to organize software development work. This leads to the common practice of customizing 
 methodologies, in most cases without a deep background in the methodology or the changes being made.
  
 We prefer to lift up a few techniques which have a great deal of benefit.
  
 • Incremental Development. Each chapter is a “sprint” that produces some collection of deliverables. 
  
 Each part is a complete release.
  
 • Unit Testing. We don’t dwell on test-driven development, but each chapter explicitly requires unit 
  
 tests for the classes built.
  
 2.5.
  
 Methodology, Technique and Process
  
 17",NA
2.6 Deliverables,"Each chapter defines the classes to be built and the unit testing that is expected. A third deliverable is merely 
 implied. The purpose of each chapter is to write the source files for one or more classes, the source files for 
 one or more unit tests, and assure that a minimal set of API documentation is available.
  
 •
  Source Files
 . The source files are the most important deliverable. In effect, this is the working 
  
 application program. Generally, you will be running this application from within your Integrated 
  
 Development Environment (IDE). You may want to create a stand-alone program.
  
 In the case of Java, we might also deliver the collection of class files. Additionally, we might bundle the 
 class files into an executable JAR file. The source is the principle deliverable; anyone should be able to 
 produce class and JAR files using readily available tools.
  
 In the case of Python, it’s the packages of .py files. There really isn’t much more to deliver. The interested 
 student might want to look at the Python distutils and setuptools to create a distribution
  
 22
  
 Chapter 2.
  
 Foundation
 s",NA
Part II ,NA,NA
Roulette,25,NA
THREE,NA,NA
ROULETTE DETAILS,"In the first section,
  Roulette Game
 , we will present a summary of the game of Roulette as played in most 
 American casinos.
  
 We will follow this with a review the various bets available on the Roulette table in
  Available Bets in Roulette
 . 
 The definition of the various bets is an interesting programming exercise, and the first four exercise chapters 
 will focus on this.
  
 In
  Some Betting Strategies
 , we will describe some common betting strategies that we will simulate. The 
 betting strategies are interesting and moderately complex algorithms for changing the amount that is used 
 for each bet in an attempt to recoup losses.",NA
3.1 Roulette Game,"The game of Roulette centers around a
  wheel
  with thirty-eight numbered
  bins
 . The numbers include 0, 00 
 (double zero), 1 through 36. The
  table
  has a surface marked with spaces on which players can place
  bets
 .
  
 The spaces include the 38
  numbers
 , plus a variety of additional bets, which will be detailed below.
  
 After the bets are placed by the players, the wheel is spun by the house, a small ball is dropped into the 
 spinning wheel; when the wheel stops spinning, the ball will come to rest in one of the thirty-eight numbered 
 bins, defining the winning number. The winning number and all of the related winning bets are paid off; the 
 losing bets are collected. Roulette bets are all paid off using
  odds
 , which will be detailed with each of the bets, 
 below.
  
 The numbers from 1 to 36 are colored red and black in an arbitrary pattern. They fit into various ranges, as 
 well as being even or odd, which defines many of the winning bets related to a given number. The numbers 0 
 and 00 are colored green, they fit into none of the ranges, and are considered to be neither even nor odd. 
 There are relatively few bets related to the zeroes. The geometry of the betting locations on the table defines 
 the relationships between number bets.
  
 Note: 
  
 American Rules
  
 There are slight variations in Roulette between American and European casinos. We’ll focus strictly on the 
 American version.",NA
3.2 Available Bets in Roulette,"There are a variety of bets available on the Roulette table. Each bet has a payout, which is stated as
  n
  :1 where
  
 n
  is the multiplier that defines the amount won based on the amount bet.
  
 29",NA
3.3 Some Betting Strategies,"Perhaps because Roulette is a relatively simple game, elaborate betting systems have evolved around it. 
 Searches on the Internet turn up a many copies of the same basic descriptions for a number of betting 
 systems. Our purpose is not to uncover the actual history of these systems, but to exploit them for simple OO 
 design exercises. Feel free to research additional betting systems or invent your own.
  
 Martingale
 . The
  Martingale
  system starts with a base wagering amount,
  w
 , and a count of the number of 
 losses,
  c
 , initially 0. Each loss doubles the bet.
  
 Any given spin will place an amount of
  w ×
  2
 c
 on a 1:1 proposition (for example, red). When a bet wins, the loss 
 count is reset to zero; resetting the bet to the base amount,
  w
 . This assures that a single win will recoup all 
 losses.
  
 Note that the casinos effectively prevent successful use of this system by imposing a table limit. At a $10 
 Roulette table, the limit may be as low as $1,000. A Martingale bettor who lost six times in a row would be 
 facing a $640 bet, and after the seventh loss, their next bet would exceed the table limit. At that point, the 
 player is unable to recoup all of their losses. Seven losses in a row is only a 1 in 128 probability; making this a 
 relatively likely situation.
  
 Waiting
 . Another system is to wait until some number of losses have elapsed. For example, wait until the 
 wheel has spun seven reds in a row, and then bet on black. This can be combined with the Martingale system 
 to double the bet on each loss as well as waiting for seven reds before betting on black.
  
 This “wait for a favorable state” strategy is based on a confusion between the outcome of each individual spin 
 and the overall odds of given collections of spins. If the wheel has spun seven reds in a row, it’s “due”to spin 
 black.
  
 1-3-2-6 System
 . Another betting system is called the
  1-3-2-6
  system. The idea is to avoid the doubling of the 
 bet at each loss and running into the table limit. Rather than attempt to recoup all losses in a single win, this 
 system looks to recoup all losses by waiting for four wins in a row.
  
 32
  
 Chapter 3.
  
 Roulette Details",NA
FOUR,NA,NA
ROULETTE SOLUTION OVERVIEW,"The first section,
  Preliminary Survey of Classes
 , is a survey of the classes gleaned from the general problem 
 statement. Refer to
  Problem Statement
  as well as the problem details in
  Roulette Details
 . This survey is drawn 
 from a quick overview of the key nouns in these sections.
  
 We’ll amplify this survery with some details of the class definitions in
  Preliminary Roulette Class Structure
 .
  
 Given this preliminary of the candidate classes,
  A Walkthrough of Roulette
  is a walkthrough of the possible 
 design that will refine the definitions, and give us some assurance that we have a reasonable architecture. We 
 will make some changes to the preliminary class list, revising and expanding on our survey.
  
 We will also include a number of questions and answers about this preliminary design information. This 
 should help clarify the design presentation and set the stage for the various development exercises in the 
 chapters that follow.",NA
4.1 Preliminary Survey of Classes,"To provide a starting point for the development effort, we have to identify the objects and define their 
 responsibilities. The central principle behind the allocation of responsibility is
  encapsulation
 ; we do this by 
 attempting to
  isolate the information
  or
  isolate the processing
  that must be done. Encapsulation assures that 
 the methods of a class are the exclusive users of the fields of that class. It also makes each class very loosely 
 coupled with other classes; this permits change without a ripple through the application. For example, each 
 Outcome
  contains both the name and the payout odds. That way each
  Outcome
  can be used to compute a 
 winning amount, and no other element of the simulation needs to share the odds information or the payout 
 calculation.
  
 In a few cases, we have looked forward to anticipate some future considerations. One such consideration is 
 the house
  rake
 , also known as the
  vigorish
 ,
  vig
 , or
  commission
 . In some games, the house makes a 5% 
 deduction from some payouts. This complexity is best isolated in the
  Outcome
  class. Roulette doesn’t have 
 any need for a rake, since the presence of the 0 and 00 on the wheel gives the house a little over 5% edge on 
 each bet. We’ll design our class so that this can be added later when we implement Craps.
  
 In reading the background information and the problem statement, we noticed a number of nouns that 
 seemed to be important parts of the game we are simulating.
  
 • Wheel
  
 • Bet
  
 • Bin
  
 • Table
  
 • Red
  
 35",NA
4.2 Preliminary Roulette Class Structure,"We’ll summarize some of the classes and responsibilities that we can identify from the problem statement. 
 This is not the complete list of classes we need to build. As we work through the exercises, we’ll discover 
 additional classes and rework some of these preliminary classes more than once.
  
 We’ll describe each class with respect to the responsibility allocated to the class and the collaborators. Some 
 collabotors are used by an object to get work done. We have a number of “uses-used by” collaborative 
 relationships among our various classes.
  
 Outcome Responsibilities
 .
  
 A name for the bet and the payout odds. This isolates the calculation of the payout amount.
  
 Example: “Red”, “1:1”.
  
 Collaborators
 .
  
 Collected by
  Wheel
  into the bins that reflect the bets that win; collected by
  Table
  into the 
 available bets for the
  Player
 ; used by
  Game
  to compute the amount won from the amount 
 that was bet.
  
 Wheel Responsibilities
 .
  
 Selects the
  Outcome
  s that win. This isolates the use of a random number generator to select
  
 Outcome
 s; and it encapsulates the set of winning
  Outcome
 s that are associated with each 
 individual number on the wheel. Example: the “1” bin has the following winning 
 Outcome
 s: 
 “1”, “Red”, “Odd”, “Low”, “Column 1”, “Dozen 1-12”, “Split 1-2”, “Split 1-4”,“Street 1-2-3”, 
 “Corner 1-2-4-5”, “Five Bet”, “Line 1-2-3-4-5-6”, “00-0-1-2-3”, “Dozen 1”,“Low” and “Column 
 1”.
  
 Collaborators
 .
  
 Collects the
  Outcome
 s into bins; used by the overall
  Game
  to get a next set of winning 
 Outcome
 s.
  
 Table Responsibilities
 .
  
 A collection of bets placed on
  Outcome
 s by a
  Player
 . This isolates the set of possible bets and 
 the management of the amounts currently at risk on each bet. This also serves as the 
 interface between the
  Player
  and the other elements of the game.
  
 Collaborators
 .
  
 36
  
 Chapter 4.
  
 Roulette Solution 
 Overview",NA
4.3 A Walkthrough of Roulette,"A good preliminary task is to review these responsibilities to confirm that a complete cycle of play is possible. 
 This will help provide some design details for each class. It will also provide some insight into classes that 
 may be missing from this overview.
  
 A good way to structure this task is to do a Class-Reponsibility-Collaborators (CRC)
  walkthrough
 .
  
 As preparation, get some 5” x 8” notecards. On each card, write down the name of a class, the responsibilities 
 and the collaborators. Leave plenty of room around the responsibilities and collaborators to write notes. 
 We’ve only identified five classes, so far, but others always show up during the walkthrough.
  
 During the walkthrough, we identify areas of responsibility, allocate them to classes of objects and define any 
 collaborating objects. An area of responsibility is a thing to do, a piece of information, a result. Sometimes a 
 big piece of responsibility can be broken down into smaller pieces, and those smaller pieces assigned to other 
 classes. There are a lot of reasons for decomposing, the purpose of this book is to explore many of them in 
 depth. Therefore, we won’t justify any of our suggestions until later in the book. For now, follow along closely 
 to get a sense of where the exercises will be leading.
  
 The basic processing outline is the responsibility of the
  Game
  class. To start, locate the
  Game
  card.
  
 1. Our preliminary note was that this class “Runs the game.” The responsibilities section has a summary 
  
 of four steps involved in running the game.
  
 2. The first step is “gets bets from :class:Player‘.” Find the
  Player
  card.
  
 3. Does a
  Player
  collaborate with a
  Game
  to place bets? If not, update the cards as necessary to include 
  
 this.
  
 4. One of the responsibilities of a
  Player
  is to place bets. The step in the responsibility statement is merely 
 “Places bets on :class:”Outcome‘s.” Looking at the classes, we note that the
  Table
  contains the amounts 
 placed on the Bets. Fix the collaboration information on the
  Player
  to name the
  Table 
 class. Find the
  
 Table
  card.
  
 5. Does a
  Table
  collaborate with a
  Player
  to accept the bets? If not, update the cards as necessary to 
  
 include this.
  
 4.3.
  
 A Walkthrough of Roulette
  
 37",NA
4.4 Roulette Solution Questions and Answers,"Why does the
  Game
  class run the sequence of steps? Isn’t that the responsibility of some “main program?”
  
 Coffee Shop Answer
 . We haven’t finished designing the entire application, so we need to reflect 
 our own ignorance of how the final application will be assembled from the various parts. Rather 
 than allocate too many responsibilities to
  Game
 , and possibly finding conflicts or complication, 
 we’d rather allocate too few responsibilities until we know more.
  
 From another point of view, designing the main program is premature because we haven’t 
 finished designing the
  entire
  application. We anticipate a
  Game
  object being invoked from some 
 statistical data gathering object to run one game. The data gathering object will then get the final 
 stake from the player and record this.
  Game
  ‘s responsibilities are focused on playing the game 
 itself. We’ll need to add a responsibility to
  Game
  to collaborate with the data gathering class to 
 run a number of games as a “session”.
  
 Deeper Answer
 . In procedural programming (especially in languages like COBOL), the “main 
 program” is allocated almost all of the responsibilities. These procedural main programs usually 
 contain a number of elements, all of which are very tightly coupled. We have seen highly skilled 
 programmers who are able to limit the amount of work done in the main program, even in proce-
 dural languages. In OO languages, it becomes possible for even moderately skilled programmers 
 to reduce the main program to a short list of object constructors, with the real work delegated to 
 the objects. We find that “main program” classes are relatively hard to reuse, and prefer to keep 
 them as short as possible.
  
 Why is
  Outcome
  a separate class? Each object that is an instance of
  Outcome
  only has two attributes; why not 
 use an array of Strings for the names, and a parallel array of integers for the odds?
  
 Representation
 . We prefer not to decompose an object into separate data elements. If we do 
 decompose this object, we will have to ask which class would own these two arrays? If
  Wheel 
 keeps these, then
  Table
  becomes very tightly coupled to these two arrays that should be
  Wheel
 ‘s 
 responsibility. If
  Table
  keeps these, then
  Wheel
  is priviledged to know details of how
  Table
  is
  
 38
  
 Chapter 4.
  
 Roulette Solution 
 Overview",NA
FIVE,NA,NA
OUTCOME CLASS,"In addition to defining the fundamental
  Outcome
  on which all gambling is based, this chapter provides a 
 sidebar discussion on the notion of object identity and object equality. This is important because we will be 
 dealing with a number of individual
  Outcome
  objects, and we need to be sure we can test for
  equality
  of two 
 different objects. This is different from the test for
  identity
 .",NA
5.1 Outcome Overview,"The first class we will tackle is a small class that encapsulates each outcome. This class will contain the name 
 of the outcome as a String, and the odds that are paid as an integer. We will use these objects when placing a 
 bet and also when defining the Roulette wheel.
  
 There will be several hundred instances of this class on a given Roulette table. The bins on the wheel, 
 similarly, collect various
  Outcome
 s together. The minimum set of
  Outcome
  instances we will need are the 38 
 numbers, Red and Black. The other instances add details to our simulation.
  
 In Roulette, the amount won is a simple multiplication of the amount bet and the odds. In other games, 
 however, there may be a more complex calculation because the house keeps 5% of the winnings, called 
 the“rake”. While it is not part of Roulette, it is good to have our
  Outcome
  class designed to cope with these 
 more complex payout rules.
  
 Also, we know that other casino games, like Craps, are stateful. An
  Outcome
  may change the game state. We 
 can foresee reworking this class to add in the necessary features to change the state of the game.
  
 While we are also aware that some odds are not stated as
  x
 :1, we won’t include these other kinds of odds in 
 this initial design. Since all Roulette odds are
  x
 :1, we’ll simply assume that the denominator is always 1. We 
 can forsee reworking this class to handle more complex odds, but we don’t need to handle the other cases yet.",NA
5.2 Design Decision – Object Identity,"Our design will depend on matching
  Outcome
  objects. We’ll be testing objects for equality.
  
 The player will be placing bets that contain
  Outcome
 s; the table will be holding bets. The wheel will select the 
 winning
  Outcome
 s. We need a simple test to see if two objects of the
  Outcome
  class are the same.
  
 Was the
  Outcome
  for a bet equal to the
  Outcome
  contained in a spin of the wheel?
  
 It turns out that this comparison between objects has some subtlety to it.
  
 Outcomes have Names
 . Since each instance of
  Outcome
  has a distinct
  Outcome.name
  attribute, it seems 
 simple enough to compare names. This is one sense of “equal” that seems to be appropriate.
  
 41",NA
5.3 Outcome Design,"class Outcome
 () 
  
 Outcome
  contains a single outcome on which a bet can be placed.
  
 In Roulette, each spin of the wheel has a number of
  Outcome
 s with bets that will be paid off.
  
 For example, the “1” bin has the following winning
  Outcome
 s: “1”, “Red”, “Odd”, “Low”, “Column 1”,“Dozen 1-
 12”, “Split 1-2”, “Split 1-4”, “Street 1-2-3”, “Corner 1-2-4-5”, “Five Bet”, “Line 1-2-3-4-5-6”,“00-0-1-2-3”, 
 “Dozen 1”, “Low” and “Column 1”. All of these bets will payoff if the wheel spins a “1”.
  
 5.3.1 Fields
  
 nam
 e 
 odds
  
 Holds the name of the
  Outcome
 . Examples include ""1"", ""Red"".
  
 Holds the payout odds for this
  Outcome
 . 
  
 Most odds are stated as 1:1 or 17:1, we only keep the 
 numerator (17) and assume the denominator is 1.
  
 We can use name to provide hash codes and do equality tests.
  
 5.3.2 Constructors
  
 __init__
 (
 self, name, odds
 ) 
  
  
 Parameters
  
  
 •
  name
  (str) – The name of this outcome
  
  
 •
  odds
  (int) – The payout odds of this outcome.
  
 Sets the instance name and odds from the parameter name and odds.
  
 5.3.3 Methods
  
 For now, we’ll assume that we’re going to have global instances of each
  Outcome
 .
  
 winAmount
 (
 self, amount
 ) 
  
  
 Multiply this
  Outcome
 ‘s odds by the given amount. The product is returned.
  
  
  
 Parameter
  amount
  (number) – amount being bet 
 __eq__
 (
 self, other
 ) 
  
  
 Compare the name attributes of self and other.
  
 44
  
 Chapter 5.
  
 Outcome Class",NA
5.4 Outcome Deliverables,"There are two deliverables for this exercise. Both will have Javadoc comments or Python docstrings.
  
 • The
  Outcome
  class.
  
 • A class which performs a unit test of the
  Outcome
  class. The unit test should create a three instances of 
 Outcome
 , two of which have the same name. It should use a number of individual tests to establish that 
 two
  Outcome
  with the same name will test true for equality, have the same hash code, and establish that 
 the winAmount() method works correctly.",NA
5.5 Message Formatting,"For the very-new-to-Python, there are few variations on creating a formatted string.
  
 Generally, we simply use something like this.
  
 def
  __str__
 (
  self
  ):
  
 return
  ""
 %s
  (
 %d
 :1)""
  %
  (
  self
 .
 name,
  self
 .
 odds )
  
 5.4.
  
 Outcome Deliverables
  
 45",NA
SIX,NA,NA
BIN CLASS,"This chapter will present the design for the
  Bin
  class. In addition to that, we’ll examine the collection classes 
 available in Java and Python. We’ll also present present some questions and answers on this particular class 
 and the process of creating a design.",NA
6.1 Bin Overview,"The Roulette wheel has 38 bins, identified with a number and a color. Each of these bins defines a number of 
 closely related winning
  Outcome
  s. At this time, we won’t enumerate each of the 38
  Bin
 s of the wheel and 
 each of the winning
  Outcome
 s (from two to fourteen in each
  Bin
 ); we’ll save that for a later exercise.
  
 At this time, we’ll define the
  Bin
  class, and use this class to contain a number of
  Outcome
  objects.
  
 Two of the
  Bin
 s have relatively few
  Outcome
 s. Specifically, the 0
  Bin
  only contains the basic “0”
  Outcome
  and 
 the “00-0-1-2-3”
  Outcome
  . The 00
  Bin
  , similarly, only contains the basic “00”
  Outcome
  and the “00-0-1-2-
 3”
 Outcome
  .
  
 The other 36
  Bin
 s contain the straight bet, split bets, street bet, corner bets, line bets and various outside bets 
 (column, dozen, even or odd, red or black, high or low) that will win if this
  Bin
  is selected. Each number bin 
 has from 12 to 14 individual winning
  Outcome
 s.
  
 Some
  Outcome
 s, like “red” or “black”, occur in as many as 18 individual
  Bin
 s. Other
  Outcome
 s, like the 
 straight bet numbers, each occur in only a single
  Bin
 . We will have to be sure that our
  Outcome
  objects are 
 shared appropriately by the
  Bin
 s.
  
 Since a
  Bin
  is just a collection of individual
  Outcome
  objects, we have to select a collection class to contain the 
 objects. In Java we have five basic choices, with some variations based on performance needs. In Python, we 
 have two basic choices.",NA
6.2 Design Decision – Choosing A Collection,"There are five basic Python types that are a containers for other objects.
  
 •
  Immutable Sequence
  tuple. A tuple is immutable sequence of objects. This is a good candidate for the 
 kind of collection we need, since the elements of a
  Bin
  don’t change. Howver, a tuple allows duplicates 
 and retains things in a specific order; we can’t tolerate duplicates, and order doesn’t matter.
  
 •
  Mutable Sequence
  list. A list is a sequence of objects that can be changed. While handy for the initial 
 construction of the bin, this isn’t really useful because the contents of a bin don’t change once they have 
 been enumerated.
  
 47",NA
6.3 Bin Questions and Answers,"Why wasn’t
  Bin
  in the design overview?
  
 The definition of the Roulette game did mention the 38 bins of the wheel. 
  
 However, when 
 identifying the nouns, it didn’t seem important. Then, as we started designing the
  Wheel
  class, the 
 description of the wheel as 38 bins came more fully into focus. Rework of the preliminary design is 
 part of detailed design. This is the first of several instances of rework.
  
 Why introduce an entire class for the bins of the wheel? Why can’t the wheel be an array of 38 individual 
 arrays?
  
 There are two reasons for introducing
  Bin
  as a separate class: to improve the fidelity of our object 
 model of the problem, and to reduce the complexity of the
  Wheel
  class. The definition of the game 
 describes the wheel as having 38 bins, each bin causes a number of individual
  Outcome
 s to win. 
 Without thinking too deeply, we opted to define the
  Bin
  class to hold a collection of 
 Outcome
 s. At 
 the present time, we can’t foresee a lot of processing that is the responsibility of a
  Bin
 . But 
 allocating a class permits us some flexibility in assigning responsibilities there in the future.
  
 Additionally, looking forward, it is clear that the
  Wheel
  class will use a random number generator 
 and will pick a winning
  Bin
 . In order to keep this crisp definition of responsibilities for the
  Wheel 
 class, it makes sense to delegate all of the remaining details to another class.
  
 Isn’t an entire class for bins a lot of overhead?
  
 The short answer is no, class definitions are almost no overhead at all. Class definitions are part of 
 the compiler’s world; at run-time they amount to a few simple persistent objects that define the 
 class. It’s the class instances that cause run-time overhead.
  
 In a system where were are counting individual instruction executions at the hardware level, this 
 additional class may slow things down somewhat. In most cases, however, the extra few 
 instructions required to delegate a method to an internal object is offset by the benefits gained 
 from additional flexibility.
  
 How can you introduce Set, List, Vector when these don’t appear in the problem?
  
 We have to make a distinction between the classes that are uncovered during analysis of the 
 problem in general, and classes are that just part of the implementation of this particular solution. 
 This emphasizes the distinction between
  the problem
  as described by users and
  a solution
  as 
 designed by software developers. The collections framework are part of a solution, and hinted at 
 by the definition of the problem. Generally, these solution-oriented classes are part of frameworks 
 or libraries that came with our tools, or that we can license for use in our application. The 
 problem-oriented classes, however, are usually unique to our problem.
  
 48
  
 Chapter 6.
  
 Bin Class",NA
6.4 Bin Design,"class Bin
 ()
  
 Bin
  contains a collection of
  Outcome
 s which reflect the winning bets that are paid for a particular bin on a 
 Roulette wheel. In Roulette, each spin of the wheel has a number of
  Outcome
  s. Example: A spin of 1, selects 
 the “1” bin with the following winning
  Outcome
 s: “1” , “Red” , “Odd” , “Low” , “Column 1” , “Dozen 1-12”, “Split 
 1-2” , “Split 1-4” , “Street 1-2-3” , “Corner 1-2-4-5” , “Five Bet” , “Line 1-2-3-4-5-6” , “00-0-1-2-3”, “Dozen 1” , 
 “Low” and “Column 1” . These are collected into a single
  Bin
  .
  
 6.4.1 Fields
  
 outcomes 
  
  
 A frozenset that holds the collection of individual
  Outcome
 s.
  
 6.4.2 Constructors
  
 Python programmers should provide an initializer that uses the
  *
  modifier so that all of the individual 
 arguments appear as a single list within the initializer.
  
 __init__
 (
 self, * outcomes
 )
  
 Parameter
  outcomes
  – any number of outcomes used to populate the Bin initially.
  
 This constructor can be used as follows.
  
 Python Bin Construction
  
 five
 =
  Outcome(
  ""00-0-1-2-3""
 ,
  6
  )
  
 zero
 =
  Bin( Outcome(
 ""0""
 ,
 35
 ), five )
  
 zerozero
 =
  Bin( Outcome(
 ""00""
 ,
 35
 ), five )
  
 1. zero is based on references to two objects: the “0”
  Outcome
  and the “00-0-1-2-3”
  Outcome
 .
  
 2. zerozero is based on references to two objects: the “00”
  Outcome
  and the “00-0-1-2-3”
  Outcome
 .
  
 6.4.3 Methods
  
 add
 (
 self, outcome
 ) 
  
 Adds an
  Outcome
  to this
  Bin
 . This can be used by a builder to construct all of the bets in this
  Bin
 . Since 
 this class is really just a façade over the underlying collection object, this method could simply delegate 
 the real work to the underlying collection.
  
 Note that a frozenset is immutable; unlike a list it does not have an append() method. Instead, a new 
 frozenset can be constructed by using the
  |
  operator which creates a new frozenset from a frozenset 
 and a frozenset or set
  
 >>>
  zero
 =
  Outcome(
 ""0""
 ,
 35
 )
  
 >>>
  zerozero
 =
  Outcome(
 ""00""
 ,
 35
 )
  
 >>>
  b
  =
  frozenset
 ( [zero] )
  
 >>>
  b
  
 frozenset([<roulette.Outcome object at 0x6002d0>])
  
 6.4.
  
 Bin Design
  
 49",NA
6.5 Bin Deliverables,"There are two deliverables for this exercise. Both will have Javadoc comments or Python docstrings.
  
 • The
  Bin
  class.
  
 • A class which performs a unit test of the
  Bin
  class. The unit test should create several instances of 
  
 Outcome
 , two instances of
  Bin
  and establish that
  Bin
  s can be constructed from the
  Outcome
 s.
  
 Programmers who are new to OO techniques are sometimes confused when reusing individual
  
 Outcome 
 instances. This unit test is a good place to examine the ways in which object
  references
  are 
 shared. A single
  Outcome
  object can be referenced by several
  Bin
 s. We will make increasing use of this 
 in later sections.
  
 50
  
 Chapter 6.
  
 Bin Class",NA
SEVEN,NA,NA
WHEEL CLASS,"This chapter builds on the previous two chapters, creating a more complete composite object from the 
 Outcome
  and
  Bin
  classes we have already defined. We’ll introduce some basic subclass constructor 
 techniques, also.",NA
7.1 Wheel Overview,"The wheel has two responsibilities: it is a container for the
  Bin
 s and it picks one
  Bin
  at random. We’ll also 
 have to look at how to initialize the various
  Bin
 s that comprise a standard Roulette wheel.
  
 7.1.1 The Container Responsibility
  
 Since the
  Wheel
  is 38
  Bin
 s, it is a collection. We can review our survey of available collections in
  Design 
 Decision – Choosing A Collection
  for some guidance here.
  
 In this case, the choice of the winning
  Bin
  will be selected by a random numeric index. We need some kind of 
 sequential collection.
  
 This makes an immutable tuple very appealing. This is a subclass of collections.Sequence and has the features 
 we’re looking for.
  
 One consequence of using a sequential collection is that we have to choose an index for the various
  Bin
 s. Each
  
 Bin
  contains a variety of individual
  Outcome
 s. However, each single number
  Outcome
  will be unique to each
  
 Bin
 .
  
 The index values of 1 to 36 become the index to their respective
  Bin
 s. The Bin at index 1 is the only bin which 
 contains ‘Outcome( ""1"", 35 )’.
  
 We have a small problem, however, with 0 and 00: we need two separate indexes. While 0 is a valid index, 
 what do we do with 00?
  
 Enumerate some possible solutions before reading on.
  
 Since the index of the
  Bin
  doesn’t have any significance at all, we can assign the
  Bin
  that has the 00
  Outcome 
 to 
 position 37 in the Vector. This gives us a unique place for all 38
  Bin
 s.
  
 51",NA
7.2 Wheel Design,"class Wheel
 ()
  
 Wheel
  contains the 38 individual bins on a Roulette wheel, plus a random number generator. It can select a
  
 Bin
  at random, simulating a spin of the Roulette wheel.
  
 7.2.1 Fields
  
 bins
  
 Contains the individual
  Bin
  instances.
  
 This is a tuple of 38 elements. This can be built with ‘tuple( Bin() for i in range(38) )’
  
 rng
  
 The random number generator to use to select a
  Bin
  from the bins collection.
  
 This is not always simply ‘random.Random()’. For testing, we need to inject a non-random random 
 number generator in place of the system random number generator.
  
 7.2.2 Constructors
  
 __init__
 (
 self, rng
 )
  
 52
  
 Chapter 7.
  
 Wheel Class",NA
7.3 Non-Random Design,"We need a controlled kind of random number generation for testing purposes.
  
 We’ll define a class NonRandom that extends random.Random, but provides a more testable sequence of 
 values. One approach is to simply return a given integer value.
  
 7.3.1 Fields
  
 value 
  
  
 The non-random value to return.
  
 7.3.2 Constructors
  
 __init__
 (
 self
 ) 
  
  
 Creates a non-random “random” number generator.
  
 7.3.
  
 Non-Random Design
  
 53",NA
7.4 Wheel Deliverables,"There are three deliverables for this exercise. The new class and the unit test will have Javadoc comments or 
 Python docstrings.
  
 • The
  Wheel
  class.
  
 • A class which performs a unit test of building the
  Wheel
  class. The unit test should create several 
 instances of
  Outcome
 , two instances of
  Bin
 , and an instance of
  Wheel
 . The unit test should establish that
  
 Bin
 s can be added to the
  Wheel
 .
  
 • A Non-Random Random Number Generator class, to be used for testing.
  
 • A class which tests the Wheel and NonRandom class by selecting values from a
  Wheel
  object.
  
 54
  
 Chapter 7.
  
 Wheel Class",NA
EIGHT,NA,NA
BIN BUILDER CLASS,"This is a rather long chapter, which describes a number of design considerations surrounding
  Outcome
 ,
  Bin 
 and
  Wheel
 . The second section presents a number of algorithms to group
  Outcome
 s based on the geometry of 
 the table. These algorithms are presented at a high level, leaving much of the detailed design to the student.",NA
8.1 Bin Builder Overview,"It is clear that enumerating each
  Outcome
  in the 38
  Bin
 s is a tedious undertaking. Most
  Bin
 s contain about 
 fourteen individual
  Outcome
 s.
  
 It is often helpful to create a class that is used to build an instance of another class. This is a design pattern 
 sometimes called a
  Builder
 . We’ll design an object that builds the various
  Bin
 s and assigns them to the 
 Wheel
 . This will fill the need left open in the
  Wheel Class
 .
  
 Additionally, we note that the complex algorithms to construct the
  Bin
 s are only tangential to the operation of 
 the
  Wheel
  object. While not essential to the design of the
  Wheel
  class, we find it is often helpful to segregate 
 these rather complex builder methods into a separate class.
  
 The
  BinBuilder
  class will have a method that enumerates the contents of each of the 36 number
  Bin
 s, building 
 the individual
  Outcome
  instances. We can then assign these
  Outcome
  objects to the
  Bin
 s of a
  Wheel 
 instance. 
 We will use a number of steps to create the various types of
  Outcome
 s, and depend on the
  Wheel 
 to assign 
 each
  Outcome
  object to the correct
  Bin
 .
  
 The Roulette Outcomes
 . Looking at the
  Available Bets in Roulette
  gives us a number of geometric rules for 
 determining the various
  Outcome
 s that are combinations of individual numbers. These rules apply to the 
 numbers from one to thirty-six. A different – and much simpler – set of rules applies to 0 and 00. First, we’ll 
 survey the table geometry, then we’ll develop specific algorithms for each kind of bet.
  
 •
  Split Bets
 . Each number is adjacent to two, three or four other numbers. The four corners (1, 3, 34, and 
 36) only participate in two split bets. The center column of numbers (5, 8, 11, ..., 32) each participate in 
 four split bets. The remaining “edge” numbers participate in three split bets. While this is moderately 
 complex, the bulk of the layout (from 4 to 32) can be handled with a simple rule to distinguish the 
 center column from the edge columns. The ends (1, 2, 3, 34, 35 and 36) are a little more complex.
  
 •
  Street Bets
 . Each number is a member of one of the twelve street bets.
  
 •
  Corner Bets
 . Each number is a member of one, two or four corner bets. As with split bets, the bulk of the 
 layout can be handled with a simple rule to distinguish the column, and hence the “corners”. A number 
 in the center column (5, 8, 11, ..., 32) is a member of four corners. At the ends, 1, 3, 34, and 36, are 
 members of just one corner. All of the remaining numbers are along an edge and are members of two 
 corners.
  
 55",NA
8.2 Bin Builder Algorithms,"This section provides the algorithms for nine kinds of bets.
  
 8.2.1 Generating Straight Bets
  
 Straight bet Outcomes are the easiest to generate.
  
 For All Numbers
 . For each number,
  n
 , 1
  ≤ n <
  37: 
  
 Create Outcome
 . Create an
  Outcome
  from the number,
  n
 , with odds of 35:l.
  
 Assign to Bin
 . Assign this new
  Outcome
  to
  Bin
  n
 .
  
 Zero
 . Create an
  Outcome
  from the “0” with odds of 35:l. Assign this to
  Bin
  0.
  
 Double Zero
 . Create an
  Outcome
  from the “00” with odds of 35:l. Assign this to
  Bin
  37.
  
 8.2.2 Generating Split Bets
  
 Split bet Outcomes are more complex because of the various cases: corners, edges and down-the-middle.
  
 We note that there are two kinds of split bets:
  
 •
  left-right pairs
 . These pairs all have the form (
  n
  ,
  n
  +1).
  
 •
  up-down paris
 . These paris have the form (
  n
  ,
  n
  +3).
  
 We can look at the number 5 as being part of 4 different pairs: (4,4+1), (5,5+1), (2,2+3), (5,5+3). The corner 
 number 1 is part of 2 split bets: (1,1+1), (1,1+3).
  
 We can generate the “left-right” split bets by iterating through the left two columns; the numbers 1, 4, 7, ..., 34 
 and 2, 5, 8, ..., 35.
  
 For All Rows
 . For each row,
  r
 , where 0
  ≤ r <
  12:
  
 56
  
 Chapter 8.
  
 Bin Builder Class",NA
8.3 BinBuilder Design,"class BinBuilder
 () 
  
 BinBuilder
  creates the
  Outcome
 s for all of the 38 individual
  Bin
  on a Roulette wheel.
  
 8.3.1 Constructors
  
 __init__
 (
 self
 ) 
  
  
 Initializes the
  BinBuilder
 .
  
 8.3.2 Methods
  
 buildBins
 (
 self, wheel
 ) 
  
 Creates the
  Outcome
  instances and uses the addOutcome() method to place each
  Outcome
  in the 
 appropropriate
  Bin
  of
  wheel
  .
  
 Parameter
  wheel
  (Wheel) – The Wheel with Bins that must be populated with Outcomes.
  
 There should be separate methods to generate the straight bets, split bets, street bets, corner bets, line bets, 
 dozen bets and column bets, even money bets and the special case of zero and double zero.
  
 Each of the methods will be relatively simple and easy to unit test. Details are provided in
  Bin Builder 
 Algorithms
 .",NA
8.4 Bin Builder Deliverables,"There are three deliverables for this exercise. 
 docstrings.
  
 • The
  BinBuilder
  class.
  
 The new classes will have Javadoc comments or Python
  
 • A class which performs a unit test of the
  BinBuilder
  class. The unit test invoke each of the various 
  
 methods that create
  Outcome
  instances.
  
 • Rework the unit test of the
  Wheel
  class. The unit test should create and initialize a
  Wheel
 . It can use 
  
 the Wheel.getBin() method to check selected
  Bin
 s for the correct
  Outcome
 s.
  
 8.3.
  
 BinBuilder Design
  
 59",NA
8.5 Internationalization and Localization,"An an advanced topic, we need to avoid
  hard coding
  the names of the bets. Both Java and Python provide 
 extensive tools for localization (l10n) of programs. Since both applications already use Unicode strings, they 
 support non-Latin characters, handling much of the internationalization (i18n) part of the process.
  
 Python localization depends on the locale and gettext modules. The locale module provides a number of 
 functions and constants to help format dates and times for the user’s selected locale. The gettext module 
 provides a mechanism for getting translated text from a message catalog with messages in a variety of 
 languages.
  
 We won’t dwell on the l10n issue. However, the right preparation for l10n is to isolate all Strings used for 
 messages, and format all dates and numbers with formatters found in the locale module. In this case, our 
 Outcome
  names may be displayed, and should be isolated into a separate object. Even something as simple as 
 ‘blackBetName = _(""Black"")’ will set the stage for fetching strings from a gettext message catalog.
  
 In order to define the _(string) function, the following fragment should be used. While not ubiquitous in 
 Python programs, doing this now establishes a standard practice that will permit easy localization of an 
 application program.
  
 import
  gettext
  
 gettext
 .
 NullTranslations()
 .
 install()
  
 print
  _(
 ""String To Be Translated""
 )
  
 1. This constructs an instance of NullTranslations. This is then installed as a function named _(), which 
 finds a translation for the default C-locale string. This class does nothing; but it can be replaced with the 
 GNUTranslations class, which uses a message catalog to replace the default strings with localized 
 strings.
  
 2. This shows how to use the _() function to translate a default C-locale string to a localized string.
  
 60
  
 Chapter 8.
  
 Bin Builder Class",NA
NINE,NA,NA
ROULETTE BET CLASS,"In addition to the design of the
  Bet
  class, this chapter also presents some additional questions and answers on 
 the nature of an object, identity and state change. This continues some of the ideas from
  Design Decision– 
 Object Identity
 .",NA
9.1 Roulette Bet Overview,"A
  Bet
  is an amount that the player has wagered on a specific
  Outcome
 . This class has the responsibilty for 
 maintaining the association between an amount, an
  Outcome
 , and a specific
  Player
 .
  
 This is the classic
  record declaration
 : a passive association among data elements. The only methods we can see 
 are three pairs of
  getters and setters
  to get and set each of the three attributes.
  
 The general scenario is to have a
  Player
  construct a number of
  Bet
  instances. The wheel is spun to select a 
 winning
  Bin
 . Then each of the
  Bet
  objects will be checked to see if they are winners or losers.
  
 A winning
  Bet
  has an
  Outcome
  that matches one in the winning
  Bin
 ; winners will return money to the 
 Player
 . 
 All other bets aren’t in the winning
  Bin
 ; they are losers, which removes the money from the 
 Player
 .
  
 Locating Outcomes
 . We have a design decision to make. Do we create a fresh
  Outcome
  object with each 
 Bet
  or 
 do we locate an existing
  Outcome
  object?",NA
9.2 Design Decision – Create or Locate an Outcome,"Building a
  Bet
  involves two parts: an
  Outcome
  and an amount.
  
 Problem
 . Do we get an create an
  Outcome
  object with a
  Bet
 ? Or do we locate an
  Outcome
  object in some 
 collection or as a variable?
  
 Forces
 . One option is to create an
  Outcome
  object as part of constructing a
  Bet
  object.
  
 Here’s what it might look like in Python.
  
 my_bet
 =
  Bet( Outcome(
 ""red""
 ,
  2
 ),
  25
  )
  
 One unfortunate feature of this is that we have to repeat the odds when creating an Outcome. This violates the 
 DRY principle.
  
 The other option is to locate an existing
  Outcome
  object as part of creating a
  Bet
  instance.
  
 Here’s what it might look like in Python.
  
 61",NA
9.3 Design Decision – Where to Keep the Outcome Map,"Building a
  Bet
  involves two parts: an
  Outcome
  and an amount. Since we can’t create an outcome, we need to get 
 an outcome from some other object. There are several objects that could contain this
  Outcome
  map.
  
 Problem
 . What class contains the mapping from name to
  Outcome
  so we can reuse references to those 
 objects?
  
 Forces
 . In
  Outcome Class
  we looked at three ways to achieve a single instance of an
  Outcome
 . This assured 
 that we could have multiple references to a single instance of an
  Outcome
 . We’ll modify that list slightly and 
 reuse it here.
  
 • Global Outcome Mapping. 
  
 We can declare some global mapping object to keep references to out 
  
 Outcome
 s. This object is more-or-less immutable, once the initial set of
  Outcome
 s have been built.
  
 It’s not a global variable, so it is a usable technique.
  
 • Outcome Factory Object. We can define a class which produces references to
  Outcome
 s as needed. By 
 using this object, we can be sure we’re getting a reference to the one-and-only instance of the
  Outcome
 .
  
 • The Outcome Class Itself. We can define the
  Outcome
  class to retain a static mapping to each
  Outcome 
 that gets created. By using the static Outcome.getInstance() method, we can be sure we’re getting a 
 reference to the one-and-only instance of the
  Outcome
 .
  
 This, however, limits our ability to create subclasses of
  Outcome
 .
  
 After creating the
  BinBuilder
 , we can see that we – in effect – chose the
  Factory
  design for creating 
 Outcome
  
 instances.
  
 However, the class:
 BinBuilder
  doesn’t – currently – have a handy mapping so that we can look up an
  Outcome 
 based on the name of the outcome. But is this the right place to do the lookup? What about the
  Wheel
 ?
  
 Alternative Solutions
 . We have a number of potential ways to gather all
  Outcome
  objects that were created 
 by the
  BinBuilder
 .
  
 • Clearly, the
  BinBuilder
  can create the mapping from name to each distinct
  Outcome
 . To do this, we’d 
  
 have to do several things.
  
 First, we expand the
  BinBuilder
  to keep a simple Map of the various
  Outcome
 s that are being assigned 
 via the Wheel.add() method.
  
 62
  
 Chapter 9.
  
 Roulette Bet Class",NA
9.4 Roulette Bet Questions and Answers,"Why not update each
  Outcome
  with the amount of the bet?
  
 We are isolating the static definition of the
  Outcome
  from the presence or absence of an amount 
 wagered. Note that the
  Outcome
  is shared by the wheel’s
  Bin
  s, and the available betting spaces on 
 the
  Table
 , possibly even the
  Player
  class. Also, if we have multiple
  Player
 , then we need to 
 distinguish bets placed by the individual players.
  
 Changing a field’s value has an implication that the thing has changed state. In Roulette, there isn’t 
 any state change in the definition of an
  Outcome
 . However, when we look at Craps, we will see 
 that changes in the game’s state will enable and disable whole sets of
  Outcome
  s.
  
 Does an individual bet really have unique identity? Isn’t it just anonymous money?
  
 9.4.
  
 Roulette Bet Questions and Answers
  
 63",NA
9.5 Roulette Bet Design,"class Bet
 () 
  
 Bet
  associates an amount and an
  Outcome
 . In a future round of design, we can also associate a
  Bet
  with a 
 Player
 .
  
 9.5.1 Fields
  
 amountBet 
  
  
 The amount of the bet.
  
 outcome 
  
  
 The
  Outcome
  on which the bet is placed.
  
 9.5.2 Constructors
  
 __init__
 (
 self, amount, outcome
 ) 
  
  
 Parameters
  
  
 •
  amount
  (int) – The amount of the bet.
  
 •
  outcome
  (Outcome) – The
  Outcome
  we’re betting on.
  
 Create a new Bet of a specific amount on a specific outcome.
  
 For these first exercises, we’ll omit the
  Player
 . We’ll come back to this class when necessary, and add that 
 capability back in to this class.
  
 9.5.3 Methods
  
 winAmount
 (
 self
 ) 
  
  
  
 Returns
  amount won 
  
  
  
 Return type
  int 
  
  
 Uses the
  Outcome
 ‘s winAmount to compute the amount won, given the amount of this bet. Note 
  
 that the amount bet must also be added in. A 1:1 outcome (e.g. a bet on Red) pays the amount 
  
 bet 
 plus the amount won.
  
 loseAmount
 (
 self
 ) 
  
 Returns
  amount lost 
  
 Return type
  int
  
 64
  
 Chapter 9.
  
 Roulette Bet Class",NA
9.6 Roulette Bet Deliverables,"There are four deliverables for this exercise. The new classes will have Javadoc comments or Python doc-
 strings.
  
 • The expanded
  Wheel
  class which creates a mapping of string name to
  Outcome
 .
  
 • Expanded unit tests of
  Wheel
  that confirm that the mapping is being built correctly.
  
 • The
  Bet
  class.
  
 • A class which performs a unit test of the
  Bet
  class. The unit test should create a couple instances of 
  
 Outcome
 , and establish that the winAmount() and loseAmount() methods work correctly.
  
 9.6.
  
 Roulette Bet Deliverables
  
 65",NA
TEN,NA,NA
ROULETTE TABLE CLASS,"This section provides the design for the
  Table
  to hold the bets. It also introduces the concepts behind 
 exception handling, and the proper role of exceptions.",NA
10.1 Roulette Table Overview,"The
  Table
  has the responsibility to keep the
  Bet
 s created by the
  Player
 . Additionally, the house imposes 
 table 
 limits
  on the minimum amount that must be bet and the maximum that can be bet. Clearly, the
  Table 
 has all 
 the information required to evaluation these conditions.
  
 Note: 
  
 Betting Constraints
  
 Casinos prevent the
  Martingale
  betting system from working by imposing a table limit on each game. To 
 cover the cost of operating the table game, the casino also imposes a minimum bet. Typically, the maximum is 
 a multiplier of the minimum bet, often in the range of 10 to 50; a table with a $5 minimum might have a $200 
 limit, a $10 minimum may have only a $300 limit.
  
 It isn’t clear where the responsibility lies for determining winning and losing bets. The money placed on 
 Bet
 s 
 on the
  Table
  is “at risk” of being lost. If the bet is a winner, the house pays the
  Player
  an amount based on the
  
 Outcome
 ‘s odds and the
  Bet
 ‘s amount. If the bet is a loser, the amount of the
  Bet
  is forfeit by the
  Player
 . 
 Looking forward to stateful games like Craps, we’ll place the responsibility for determining winners and 
 losers with the game, and not with the
  Table
  object.
  
 We’ll wait, then, until we write the game to finalize paying winning bets and collecting losing bets.
  
 Winning vs. Losing
 . Our second open question is the timing of the payment for the bet from the player’s 
 stake. In a casino, the payment to the casino – effectively – happens when the bet is placed on the table. In our 
 Roulette simulation, this is a subtlety that doesn’t have any practical consequences. We could deduct the 
 money as part of
  Bet
  creation, or we could deduct the money as part of resolving the spin of the wheel. In 
 other games, however, there may several events and several opportunities for placing additional bets. For 
 example, splitting a hand in blackjack, or placing additional odds bets in Craps.
  
 Because we can’t allow a player to bet more than their stake, we should deduct the payment as the
  Bet
  is 
 created.
  
 A consequence of this is a change to our definition of the
  Bet
  class. We don’t need to compute the amount that 
 is lost. We’re not going to deduct the money when the bet resolved, we’re going to deduct the money from the
  
 Player
 ‘s stake as part of creating the
  Bet
 . This will become part of the design of
  Player
  and
  Bet
 .
  
 Looking forward a little, a stateful game like Craps will introduce a subtle distinction that may be appropriate 
 for a future subclass of
  Table
 . When the game is in the point off state, some of the bets on the table are not 
 allowed, and others become inactive. When the game is in the point on state, all bets are allowed and
  
 67",NA
10.2 InvalidBet Exception Design,"exception InvalidBet 
  
  
 InvalidBet
  is raised when the
  Player
  attempts to place a bet which exceeds the table’s limit.
  
 This class simply inherits all features of its superclass.
  
 68
  
 Chapter 10.
  
 Roulette Table Class",NA
10.3 Roulette Table Design,"class Table
 ()
  
 Table
  contains all the
  Bet
  s created by the
  Player
 . A table also has a betting limit, and the sum of all of a 
 player’s bets must be less than or equal to this limit. We assume a single
  Player
  in the simulation.
  
 10.3.1 Fields
  
 limit 
  
  
 This is the table limit. The sum of a
  Player
  ‘s bets must be less than or equal to this limit.
  
 bets
  
 This is a list of the
  Bet
 s currently active. These will result in either wins or losses to the
  Player
 .
  
 10.3.2 Constructors
  
 Table
 () 
  
  
 Creates an empty list of bets.
  
 Methods
  
 isValid
 (
 self, bet
 )
  
 Parameter
  bet
  (Bet) – A Bet instance to be validated.
  
 Validates this bet. If the sum of all bets is less than or equal to the table limit, then the bet is valid, 
 return true. Otherwise, return false.
  
 placeBet
 (
 self, bet
 )
  
 Parameter
  bet
  (Bet) – A Bet instance to be validated.
  
 Raises
  InvalidBet
  
 Adds this bet to the list of working bets. If the sum of all bets is greater than the table limit, then 
 an exception should be thrown (Java) or raised (Python). This is a rare circumstance, and 
 indicates a bug in the
  Player
  more than anything else.
  
 __iter__
 () 
  
 Returns an iterator over the available list of
  Bet
  instances. This simply returns the iterator over the list 
 of
  Bet
  objects.
  
 Note that we need to be able remove Bets from the table. Consequently, we have to update the list, 
 which requires that we create a copy of the list. This is done with ‘bets[:]’.
  
 Returns
  iterator over all bets
  
 __str__
 () 
  
  
 Return String representation of all current bets.",NA
10.4 Roulette Table Deliverables,"There are three deliverables for this exercise. Each of these will have complete Javadoc comments or Python 
 docstring comments.
  
 10.3.
  
 Roulette Table Design
  
 69",NA
ELEVEN,NA,NA
ROULETTE GAME CLASS,"Between
  Player
  and
  Game
 , we have a
  chicken-and-egg design problem
 . In this chapter, we’ll describe the 
 design for
  Game
  in detail. However, in order to create the deliverables, we have to create a version of
  Player 
 that we can use just to get started. In the long run, we’ll need to create a sophisticated hierarchy of players. 
 Rather than digress too far, we’ll create a simple player, Pssenger57 (they always bet on black), which will be 
 the basis for further design in later chapters.",NA
11.1 Roulette Game Overview,"The RouletteGame‘s responsibility is to cycle through the various steps of the game procedure, getting bets 
 from the player, spinning the wheel and resolving the bets. This is an
  active
  class that makes use of the classes 
 we have built so far. The hallmark of an active class is longer or more complex methods. This is distinct from 
 most of the classes we have considered so far, which have relatively trivial methods that are little more than 
 getters and setters of instance variables.
  
 The sequence of operations in one round of the game is the following.
  
 A Single Round of Roulette
  
 1.
  Place Bets
 . Notify the
  Player
  to create
  Bet
  s. The real work of placing bets is delegated to the 
 Player
  
 class. Note that the money is committed at this point; they player’s stake should be reduced as part of 
 creating a
  Bet
 .
  
 2.
  Spin Wheel
 . Get the next spin of the
  Wheel
 , giving the winning
  Bin
 ,
  w
 . This is a collection of 
  
 individual
  Outcome
 ‘s which will be winners.
  
 3.
  Resolve All Bets
 .
  
 For each
  Bet
 ,
  b
  placed by the
  Player
 :
  
 (a)
  Winner?
  If
  Bet
  b
 ‘s
  Outcome
  is in the winning
  Bin
 ,
  w
 , then notify the
  Player
  that
  Bet
  b
  was a 
  
 winner and update the
  Player
 ‘s stake.
  
 (b)
  Loser?
  If
  Bet
  b
 ‘s
  Outcome
  is not in the winning
  Bin
 ,
  w
 , then notify the
  Player
  that
  Bet
  b
  was 
  
 a loser. This allows the
  Player
  to update the betting amount for the next round.
  
 Matching Algorithm
 . This
  Game
  class will have the responsibility for matching the collection of
  Outcome
 s in 
 the
  Bin
  of the
  Wheel
  with the collection of
  Outcome
 s of the
  Bet
 s on the
  Table
 . We have two collections that 
 must be matched:
  Bin
  and
  Table
 . We’ll need to structure a loop or nested loops to compare individual 
 elements from these two collections.
  
 71",NA
11.2 Passenger57 Design,"class Passenger57
 ()
  
 Passenger57
  constructs a
  Bet
  based on the
  Outcome
  named ""Black"". This is a very persistent player.
  
 We’ll need a source for the Black outcome. We have several choices; we looked at these in
  Roulette Bet Class
 . 
 We will query the
  Wheel
  for the needed
  Outcome
  object.
  
 In the long run, we’ll have to define a
  Player
  superclass, and make
  Passenger57
  class a proper subclass of 
 Player
 . However, our focus now is on getting the
  Game
  designed and built.
  
 11.2.1 Fields
  
 black 
  
  
 This is the outcome on which this player focuses their betting.
  
 This
  Player
  will get this from the
  Wheel
  using a well-known bet name.
  
 table 
  
  
 The
  Table
  that is used to place individual
  Bet
 s.
  
 11.2.2 Constructors
  
 __init__
 (
 self, table
 )
  
 Parameter
  table
  (Table) – A Table instance on which bets are placed.
  
  
 Constructs the
  Player
  with a specific table for placing bets. 
  
 This also creates the “black”
  
 Outcome
 . This is saved in a variable named
  Passenger57.black
  for use in creating bets.
  
 72
  
 Chapter 11.
  
 Roulette Game Class",NA
11.3 Roulette Game Design,"class Game
 () 
  
 Game
  manages the sequence of actions that defines the game of Roulette. This includes notifying the
  Player 
 to 
 place bets, spinning the
  Wheel
  and resolving the
  Bet
 s actually present on the
  Table
 .
  
 11.3.1 Fields
  
 wheel 
  
  
 The
  Wheel
  that returns a randomly selected
  Bin
  of
  Outcome
 s.
  
 table 
  
  
 The
  Table
  which contains the
  Bet
 s placed by the
  Player
 .
  
 player 
  
  
 The
  Player
  which creates
  Bet
 s at the
  Table
 .
  
 11.3.2 Constructors
  
 We based the Roulette Game constructor on a design that allows any of the fields to be replaced. 
 This is the
  Strategy
  design pattern. Each of these collaborating objects is a replaceable strategy, 
 and can be changed by the client that uses this game.
  
 Additionally, we specifically do not include the
  Player
  instance in the constructor. The
  Game 
 exists 
 independently of any particular
  Player
 , and we defer binding the
  Player
  and
  Game
  until we are 
 gathering statistical samples.
  
 __init__
 (
 self, wheel, table
 ) 
  
  
 Parameters
  
  
 •
  wheel
  (Wheel) – The wheel which produces random events
  
 •
  
 table
  (Table) – The table which holds bets to be resolved.
  
 Constructs a new
  Game
 , using a given
  Wheel
  and
  Table
 .
  
 11.3.
  
 Roulette Game Design
  
 73",NA
11.4 Roulette Game Questions and Answers,"Why are
  Table
  and
  Wheel
  part of the constructor while
  Player
  is given as part of the
  cycle()
  method?
  
 We are making a subtle distinction between the casino table game (a Roulette table, wheel, plus 
 casino staff to support it) and having a player step up to the table and play the game. The game 
 exists without any particular player. By setting up our classes to parallel the physical entities, we 
 give ourselves the flexibility to have multiple players without a significant rewrite. We allow 
 ourselves to support multiple concurrent players or multiple simulations each using a different 
 player object.
  
 Also, as we look forward to the structure of the future simulation, we note that the game objects 
 are largely fixed, but there will be a parade of variations on the player. We would like a main 
 program that simplifies inserting a new player subclass with minimal disruption.
  
 Why do we have to include the odds with the
  Outcome
  ? This pairing makes it difficult to create an
  Outcome 
 from scratch.
  
 The odds are an essential ingredient in the
  Outcome
  . It turns out that we want a short-hand name 
 for each Outcome. We have three ways to provide a short name.
  
 • A variable name. 
  
 Since each variable is owned by a specific class instance, we need to 
  
 allocate this to some class. The
  Wheel
  or the
  BinBuilder
  make the most sense for owning 
  
 this variable.
  
 • A key in a mapping. In this case, we need to allocate the mapping to some class. Again, 
  
 the
  
 Wheel
  or
  BinBuilder
  make the most sense for owning the mapping.
  
 • A method which returns the
  Outcome
  . The method can use a fixed variable or can get a 
  
 value from a mapping.",NA
11.5 Roulette Game Deliverables,"There are three deliverables for this exercise. The stub does not need documentation, but the other classes do 
 need complete Javadoc or Python docstrings.
  
 • The
  Passenger57
  class. We will rework this design later. This class always places a bet on Black. Since 
 this is simply used to test
  Game
  , it doesn’t deserve a very sophisticated unit test of its own. It will be 
 replaced in a future exercise.
  
 • The RouletteGame class.
  
 74
  
 Chapter 11.
  
 Roulette Game Class",NA
11.6 Additional Roulette Design Considerations,"In European casinos, the wheel has a single zero. In some casinos, the zero outcome has a special
  en prison 
 rule: all losing bets are split and only half the money is lost, the other half is a push and is returned to the 
 player. The following design notes discuss the implementation of this additional rule.
  
 This is a payout variation that depends on a single
  Outcome
 . We will need an additional subclass of
  Outcome 
 that has a more sophisticated losing amount method: it would push half of the amount back to the
  Player
 ‘s 
 stake. We’ll call this subclass the the PrisonOutcome class.
  
 In this case, we have a kind of hybrid resolution: it is a partial loss of the bet. In order to handle this, we’ll 
 need to have a loss() method in
  Bet
  as well as a win() method. Generally, the loss() method does nothing 
 (since the money was removed from the
  Player
 ‘s stake when the bet was created.) However, for the 
 PrisonOutcome class, the loss() method returns half the money to the
  Player
 .
  
 We can also introduce a subclass of
  BinBuilder
  that creates only the single zero, and uses this new 
 PrisonOutcome subclass of
  Outcome
  for that single zero. 
  
 We can call this the EuroBinBuilder . The 
 EuroBinBuilder does not create the five-way
  Outcome
  of 00-0-1-2-3, either; it creates a four-way for 0-1-2-3.
  
 After introducing these two subclasses, we would then adjust
  Game
  to invoke the loss() method of each losing
  
 Bet
 , in case it resulted in a push. For an American-style casino, the loss() method does nothing. For a 
 European-style casino, the los() method for an ordinary
  Outcome
  also does nothing, but the los() for a 
 PrisonOutcome would implement the additional rule pushing half the bet back to the
  Player
  . The special 
 behavior for zero then emerges from the collaboration between the various classes.
  
 We haven’t designed the
  Player
  yet, but we would have to bear this push rule in mind when designing the 
 player.
  
 The uniform interface between
  Outcome
  and PrisonOutcome is a design pattern called
  polymorphism
 . We will 
 return to this principle many times.
  
 11.6.
  
 Additional Roulette Design Considerations
  
 75",NA
TWELVE,NA,NA
REVIEW OF TESTABILITY,"This chapter presents some design rework and implementation rework for testability purposes. While testa-
 bility is very important, new programmers can be slowed to a crawl by the mechanics of building test drivers 
 and test cases. We prefer to emphasize the basic design considerations first, and address testability as a 
 feature to be added to a working class.
  
 Additionally, we’ll address some issues in construction of class instances and an idealized structure for the 
 main procedure.",NA
12.1 Testability Overview,"Without pausing, we charged past the elephant standing in the saloon. It’s time to pause a moment a take a 
 quick glance back at the pachyderm we ignored.
  
 Back in
  Wheel Class
  we skipped over the problem of testing an application that includes a
  random number 
 generator
  (RNG). There are two questions raised:
  
 1. How can we develop formalized unit tests when we can’t predict the random outcomes? This is a serious 
  
 testability issue in randomized simulations. 
  
 This question also arises when considering interactive 
  
 applications, particularly for performance tests of web applications where requests are received at 
  
 random intervals.
  
 2. Are the numbers really random? This is a more subtle issue, and is only relevant for more serious 
  
 applications. 
  
 Cryptographic, applications may care more deeply about the randomness of random 
  
 numbers. This is a large subject, and well beyond the scope of this book. We’ll just assume that our 
  
 random number generator is good enough.
  
 To address the testing issue, we need to develop some scaffolding that permits controlled testing. There are 
 three approaches to replacing the random behavior with something more controlled.
  
 • One approach is to create a subclass of
  Wheel
  to create a more testable version without the random 
 number generator. This MockWheel call be used to test classes that require a specific sequence of 
 outcomes.
  
 • A second approach is to record the sequence of random numbers actually generated from a particular 
  
 seed value and use this to define the exected test results.
  
 • Instead of changing Wheel or analyzing the results of a random number generator, we can define a 
 subclass of java.util.Random (or Python’s random.Random) that isn’t actually random. Without much 
 analysis, we suggest this in
  Wheel Class
 .
  
 This is called the
  Mock Objects
  approach. We created a Mock Random Number Generator.
  
 77",NA
12.2 Test-Driven Design,"Good testability is achieved when there are no changes to the target software. For this reason, we don’t want 
 to have two versions of
  Wheel
 .
  
 Instead of having two versions of Wheel, it’s slightly better to have a random number generator that creates a 
 known sequence with which we can test. To get this known sequence, we have a choice between creating a 
 non-random subclass of java.util.Random or controlling the seed for the random number generator used by
  
 Wheel
 . Both will produce a known sequence of non-random values.
  
 An important consequence of these design decisions is that we have to make the random number generator in
  
 Wheel
  visible. This creates a tension between the encapsulation principle and the testability principle.
  
 By
  Encapsulation
  we mean the design strategy where we define a class to encapsulate the details of it’s 
 implementation. It’s unclear if the random number generator is an implementation detail or an explicit part of 
 the wheel.
  
 Generally, for must of the normal use cases, the
  Wheel
 ‘s random number generator is an invisible imple-
 mentation detail. However, for testing purposes, the random number generator needs to be a configurable 
 feature of the
  Wheel
  instance.
  
 Our favorite approach to making something more visible is to provide default values in the constructor for the 
 object.
  
 class
  Wheel
 (
  object
  ): 
  
 def
  __init___
 (
  self
 , rng
 =
 None
  ):
  
 self
 .
 rng
 =
  rng
  if
  rng
  is no
  
 ...
  rest of Wheel construction
  ...
  
 Note: 
  
 Python Subclass Design
  
 Because of the late binding in Pyth 
 strict subclass inheritance to replace t 
 generator. We only have to provide 
  
 While legal, we prefer not to bypass 
 easier to maintain if reasonable care 
 precisely as possible. In this case, 
 Random class.
  
 78
  
 t
  None
  else
  random
 .
 Random()
  
 tion
  ...
  
 on, and the lack of compile-time type checking 
 he Python random number generator with our o 
 a class with the minimal interface that our appl
  
  the inheritance tree in Python. We fnd that is 
 taken to assure that the classes and interfa we’ll 
 want to make our non-random generator 
  
 Chapter 12.
  
 , we don’t have to use 
 wn non-random 
 number ication 
 requires.
  
  applications are much 
 ces are matched up as a 
 strict subclass of the
  
 Review of Testability",NA
12.3 Capturing Pseudo-Radom Data,"We’ll need to build and execute a program that reveals the fixed sequence of spins that are created by the 
 non-random number generator.
  
 Create an instance of NonRandom or Random. Set the seed of the this random number generator to a fixed 
 value, for example, 3.
  
 Create an instance of
  Wheel
  using this non-random number generator.
  
 Call the Wheel.next() method six times, and print the winning
  Bin
  instances. This sequence will always be the 
 result for a seed value of 3.
  
 This discovery procedure will give you the results needed to create unit tests for
  Wheel
  and anything that 
 uses it, for example,
  Game
 .",NA
12.4 Testability Questions and Answers,"Why are we making the random number generator more visible? Isn’t object design about encapsulation?
  
 Encapsulation isn’t the same thing as “information hiding” . For some people, the information 
 hiding concept can be a useful way to begin to learn about encapsulation. However, information 
 hiding is misleading because it is often taken to exremes. In this case, we want to encapsulate the 
 bins of the wheel and the procedure for selecting the winning bin into a single object. However, 
 the exact random-number generator (RNG) is a separate component, allowing us to bind any 
 suitable RNG.
  
 Consider the situation where we are generating random numbers for a cryptographic application. 
 In this case, the built-in random number generator may not be random enough. In this case, we 
 may have a third-party Super-Random-Generator that should replace the built-in generator. We 
 would prefer to minimize the changes required to introduce this new class.
  
 Our initial design has isolated the changes to the
  Wheel
 , but required us to change the 
 constructor. Since we are changing the source code for a class, we must to unit test that change. 
 Further, we are also obligated unit test all of the classes that depend on this class. Changing the 
 source for a class deep within the application forces us to endure the consequence of retesting 
 every class that depends on this deeply buried class. This is too much work to simply replace one 
 object with another.
  
 We do, however, have an alternative. We can change the top-level main() method, altering the 
 concrete object instances that compose the working application. By making the change at the top 
 of the application, we don’t need to change a deeply buried class and unit test all the classes that 
 depend on the changed class. Instead, we are simply choosing among objects with the same 
 superclass or interface.
  
 12.3.
  
 Capturing Pseudo-Radom Data
  
 79",NA
12.5 Testable Random Events Design,"We’ll present the design modification for
  Wheel
  first. 
 NonRandom in both Java and Python.
  
 12.5.1 Wheel Rework
  
 This will be followed by design information for
  
 Wheel
  contains the 38 individual bins on a Roulette wheel, plus a random number generator. It can select a
  
 Bin
  at random, simulating a spin of the Roulette wheel.
  
 Note that we will be rewriting some methods to change their implementation. The external definitions of the 
 methods don’t change, but the implementations can (and do) change. This is the real strength of OO design. 
 Once we have a well-defined interface (defined by the public methods and attributes), we are free to change 
 the implementation as necessary.
  
 This kind of rework – making a fundamental change to the implementation without touching the interface– is 
 essential to successful OO programming.
  
 Constructors
  
 __init__
 (
 rng=None
 ) 
  
 Create a wheel with the given random number generator. This will define the various bins and 
 outcomes using an instance of
  BinBuilder
 .
  
 Parameter
  rng
  (random.Random) – Random number generator
  
  
 Note:
  
 Common n00b Mistake
  
 Note that you cannot provide an instance of random.Random as the default argument. 
  
 A
  
 random.Random is a mutable object, and using a mutable object as a default value of a function
  
 will lead to weird problems because that single object instance will be reused for every
  Wheel
  built
  
 during testing and actual simulation runs.
  
 80
  
 Chapter 12.
  
 Review of 
 Testability",NA
12.6 Testability Deliverables,"There are three deliverables for this exercise. All of these deliverables need appropriate Javadoc comments or 
 Python docstrings.
  
 • A modified design for
  Wheel
 . This add the second constructor that allows us to omit the random 
  
 number 
 generator when constructing
  Wheel
 .
  
 • Revised unit tests for
  Wheel
  based on the fixed sequence of responses from the non-random number 
  
 generator.
  
 • Revised unit tests for Game based on this revised version of
  Wheel
  based on the fixed sequence of 
  
 responses from the non-random number generator.
  
 12.6.
  
 Testability Deliverables
  
 81",NA
THIRTEEN,NA,NA
PLAYER CLASS,"The variations on
  Player
 , all of which reflect different betting strategies, is the heart of this application. In 
 Roulette Game Class
 , we roughed out a stub class for
  Player
 . In this chapter, we will complete that design. We 
 will also expand on it to implement the Matingale betting strategy.",NA
13.1 Roulette Player Overview,"We have now built enough infrastructure that we can begin to add a variety of players and see how their 
 betting strategies work. Each player is betting algorithm that we will evaluate by looking at the player’s stake 
 to see how much they win, and how long they play before they run out of time or go broke.
  
 The
  Player
  has the responsibility to create bets and manage the amount of their stake. To create bets, the 
 player must create legal bets from known
  Outcome
 s and stay within table limits. To manage their stake, the 
 player must deduct money when creating a bet, accept winnings or pushes, report on the current value of the 
 stake, and leave the table when they are out of money.
  
 We have an interface that was roughed out as part of the design of
  Game
  and
  Table
 . In designing
  Game
 , we 
 put a placeBets() method in
  Player
  to place all bets. We expected the
  Player
  to create
  Bet
  s and use the 
 placeBet() method of
  Table
  class to save all of the individual
  Bet
 s.
  
 In an earlier exercise, we built a stub version of
  Player
  in order to test
  Game
 . See
  Passenger57 Design
 . When 
 we finish creating the final superclass,
  Player
 , we will also revise our
  Passenger57
  to be a subclass of 
 Player
 , 
 and rerun our unit tests to be sure that our more complete design still handles the basic test cases correctly.
  
 Objectives
 . Our objective is to have a new abstract class,
  Player
 , with two new concrete subclasses: a revision 
 to
  Passenger57
  and a new player that follows the Martingale betting system.
  
 We’ll defer some of the design required to collect detailed measurements for statistical analysis. In this first 
 release, we’ll simply place bets.
  
 There are four design issues tied up in
  Player
  : tracking stake, keeping within table limits, leaving the table, 
 and creating bets. We’ll tackle them in separate subsections.
  
 Tracking the Stake
 . One of the more important features we need to add to
  Player
  are the methods to track 
 the player’s stake. The initial value of the stake is the player’s budget. There are two significant changes to the 
 stake.
  
 • Each bet placed will deduct the bet amount from the
  Player
 ‘s stake. We are stopped from placing 
  
 bets when our stake is less than the table minimum.
  
 • Each win will credit the stake. The
  Outcome
  will compute this amount for us.
  
 • Additionally, a push will put the original bet amount back. This is a kind of win with no odds applied.
  
 83",NA
13.2 Player Design,"class Player
 ()
  
 We’ll design the base class of
  Player
  and a specific subclass,
  Martingale
 . This will give us a working player that 
 we can test with.
  
 Player
  places bets in Roulette. This an abstract class, with no actual body for the placeBets() method. 
 However, this class does implement the basic win() method used by all subclasses.
  
 13.2.1 Fields
  
 stake 
  
  
 The player’s current stake. Initialized to the player’s starting budget.
  
 roundsToGo 
  
 The number of rounds left to play. Initialized by the overall simulation control to the maximum number 
 of rounds to play. In Roulette, this is spins. In Craps, this is the number of throws of the dice, which may 
 be a large number of quick games or a small number of long-running games. In Craps, this is the number 
 of cards played, which may be large number of hands or small number of multi-card hands.
  
 table 
  
 The
  Table
  used to place individual
  Bet
 s. The
  Table
  contains the current
  Wheel
  from which the player 
 can get Outcomes used to build
  Bet
 s.
  
 13.2.2 Constructors
  
 __init__
 (
 self, table
 ) 
  
  
 Constructs the
  Player
  with a specific
  Table
  for placing
  Bet
 s.
  
 Parameter
  table
  (Table) – the table to use
  
 13.2.3 Methods
  
 playing
 (
 self
 )
  
 13.2.
  
 Player Design
  
 85",NA
13.3 Martingale Player Design,"class Martingale
 () 
  
 Martingale
  is a
  Player
  who places bets in Roulette. This player doubles their bet on every loss and resets their 
 bet to a base amount on each win.
  
 13.3.1 Fields
  
 lossCount 
  
  
 The number of losses. This is the number of times to double the bet.
  
 betMultiple 
  
 The the bet multiplier, based on the number of losses. This starts at 1, and is reset to 1 on each win. It is 
 doubled in each loss. This is always equal to 2
 lossCount
 .
  
 13.3.2 Methods
  
 placeBets
 (
 self
 ) 
  
 Updates the
  Table
  with a bet on “black”. The amount bet is 2
 lossCount
 , which is the value of 
 betMultiple.
  
 win
 (
 self, bet
 ) 
  
  
  
 Parameter
  bet
  (Bet) – The bet which won 
  
  
 Uses the superclass win() method to update the stake with an amount won. This method then 
  
 resets lossCount to zero, and resets betMultiple to 1.
  
 lose
 (
 self, bet
 ) 
  
  
  
 Parameter
  bet
  (Bet) – The bet which won 
  
  
 Uses the superclass lose() to do whatever bookkeeping the superclass already does. Increments 
  
 lossCount by 1 and doubles betMultiple.
  
 86
  
 Chapter 13.
  
 Player 
 Class",NA
13.4 Player Deliverables,"There are six deliverables for this exercise. The new classes must have Javadoc comments or Python doc-
 strings.
  
 • The
  Player
  abstract superclass. Since this class doesn’t have a body for the placeBets(), it can’t be 
  
 unit tested directly.
  
 • A revised
  Passenger57
  class. This version will be a proper subclass of
  Player
 , but still place bets on black 
 until the stake is exhausted. The existing unit test for
  Passenger57
  should continue to work correctly 
 after these changes.
  
 • The
  Martingale
  subclass of
  Player
 .
  
 • A unit test class for
  Martingale
 . This test should synthesize a fixed list of
  Outcome
  s,
  Bin
  s, and calls a
  
 Martingale
  instance with various sequences of reds and blacks to assure that the bet doubles 
 appropriately on each loss, and is reset on each win.
  
 • A revised
  Game
  class. This will check the player’s playing() method before calling placeBets(), and do 
 nothing if the player withdraws. It will also call the player’s win() and lose() methods for winning and 
 losing bets.
  
 • A unit test class for the revised
  Game
  class. Using a non-random generator for
  Wheel
 , this should be 
  
 able to confirm correct operation of the
  Game
  for a number of bets.
  
 13.4.
  
 Player Deliverables
  
 87",NA
FOURTEEN,NA,NA
OVERALL SIMULATION CONTROL,"This section starts to address the overall “main program” that pulls the various classes together to create a 
 finished application. Additionally, we’ll also address some issues in how Java handles collections of primitive 
 data types like integers.",NA
14.1 Simulation Control Overview,"We can now use our application to generate some more usable results. We can perform a number of 
 simulation runs and evaluate the long-term prospects for the Martingale betting system. We want to know a 
 few things about the game:
  
  
 • How long can we play with a given budget? In other words, how many spins before we’ve lost our 
  
  
 stake.
  
 • How much we can realistically hope to win? How large a streak can we hope for? How far ahead can 
  
 we hope to get before we should quit?
  
 The
  Simulator
  will be an active class with a number of responsibilities
  
 • Create the
  Wheel
 ,
  Table
  and
  Game
  objects.
  
 • Simulate a number of sessions (typically 100), saving the maximum stake and length of each session.
  
 • For each session: initialize the
  Player
  and
  Game
  , cycle the game a number of times, collect the size of 
  
 the
  Player
  ‘s stake after each cycle.
  
 • Write a final summary of the results.
  
 At this point, we’ll need for formalize some definitions, just to be crystal clear on the responisbility allocation.",NA
14.2 Simulation Terms,"cycle 
  
 A single cycle of betting and bet resolution. This depends on a single random event: a spin of the 
 wheel or a throw of the dice. Also known as a round of play.
  
 session 
  
 One or more cycles. The session begins with a player having their full stake. A session ends when 
 the play elects to leave or can no longer participate. A player may elect to leave because of elapsed 
 time (typically 250 cycles), or they have won a statistically significant amount. A player can no 
 longer participate when their stake is too small to make the minimum bet for the table.
  
 89",NA
14.3 Simulator Design,"class Simulator
 ()
  
 Simulator
  exercises the Roulette simulation with a given
  Player
  placing bets. It reports raw statistics on a 
 number of sessions of play.
  
 Handling Lists of Values in Java
  
 Java programmers can’t easily accumulate a List of int values. This is because a primitive int value is not 
 an object. The usual solution is to make an Integer value from the int, and put the Integer object into the 
 list.
  
 When getting values back out of the list, there is a two-step dance: cast the item in the list to be an 
 Integer, then get the int value of that object. The following examples show this as two steps.
  
 for
 (
  Iterator
 <
 Integer
 >
  i
  =
  someList
 .
 iterator
 ();
  i
 .
 hasNext
 (); ) {
  
 int
  value
  =
  i
 .
 next
 ().
 intValue
 ();
  
 ...
  processing of value
  ...
  
 }
  
  
 14.3.1 Fields
  
 initDuration 
  
  
 The duration value to use when initializing a
  Player
  for a session. A default value of 250 is a good
  
 14.3.
  
 Simulator Design
  
 91",NA
14.4 Player Rework,"The current design for the
  Player
  doesn’t provide all the methods we need.
  
 We’ll can add two new methods: one will set the stake and the other will set the roundsToGo.
  
 setStake
 (
 self, stake
 ) 
  
  
 Parameter
  stake
  (integer) – the Player’s initial stake 
 setRounds
 (
 self, rounds
 ) 
  
  
 Parameter
  rounds
  (integer) – the Player’s duration of play",NA
14.5 Simulation Control Deliverables,"There are five deliverables for this exercise. Each of these classes needs complete Javadoc or Python docstring 
 comments.
  
 • Revision to the
  Player
  class. Don’t forget to update unit tests.
  
 • The
  Simulator
  class.
  
 • The expected outcomes from the non-random wheel can be rather complex to predict. Because of this, 
 one of the deliverables is a demonstration program that enumerates the actual sequence of non-random 
 spins. From this we can derive the sequence of wins and losses, and the sequence of
  Player
  bets. This 
 will allow us to predict the final outcome from a single session.
  
 • A unit test of the
  Simulator
  class that uses the non-random generator to produce the predictable 
  
 sequence of spins and bets.
  
  
 • A main application function that creates the necessary objects, runs the
  Simulator
 ‘s gather() method, 
  
  
 and writes the available outputs to sys.stdout 
  
 For this initial demonstration program, it should simply print the list of maxima, and the list of session 
 lengths. This raw data can be redirected to a file, loaded into a spreadsheet and analyzed.
  
 14.4.
  
 Player Rework
  
 93",NA
FIFTEEN,NA,NA
SEVENREDS PLAYER CLASS,"This section introduces an additional specialization of the Martingale strategy. 
  
 Additionally, we’ll also 
 address some issues in how an overall application is composed of individual class instances. Adding this new 
 subclass should be a small change to the main application class.",NA
15.1 SevenReds Player Overview,"The SevenReds player waits for seven red wins in a row before betting black. This is a subclass of
  Player
 . We 
 can create a subclass of our main
  Simulator
  to use this new
  SevenReds
  class.
  
 We note that
  Passenger57
 ‘s betting is stateless: this class places the same bets over and over until they are 
 cleaned out or their playing session ends.
  
 The
  Martingale
  player’s betting, however, is stateful. This player changes the bet based on wins and losses. 
 The state is a loss counter than resets to zero on each win, and increments on each loss.
  
 Our
  SevenReds
  player will have two states: waiting and betting. In the waiting state, they are simply counting 
 the number of reds. 
  
 In the betting state, they have seen seven reds and are now playing the 
 Martingale system on black. We will defer serious analysis of this
  stateful
  betting until some of the more 
 sophisticated subclasses of
  Player
 . For now, we will simply use an integer to count the number of reds.
  
 Game Changes
 . Currently, a
  Player
  is not informed of the final outcome unless they place a bet. We designed 
 the
  Game
  to evaluate the
  Bet
  instances and notify the
  Player
  of just their
  Bet
 s that were wins or losses. We 
 will need to add a method to
  Player
  to be given the overall list of winning
  Outcome
 s even when the
  Player
  has 
 not placed a bet.
  
 Once we have updated the design of
  Game
  to notify
  Player
 , we can add the new
  SevenReds
  class. Note that we 
 are can intoduce each new betting strategy via creation of new subclasses. A relatively straightforward 
 update to our simulation main program allows us to use these new subclasses. The previously working 
 subclasses are left in place, allowing graceful evolution by adding features with minimal rework of existing 
 classes.
  
 In addition to waiting for the wheel to spin seven reds, we will also follow the Martingale betting system to 
 track our wins and losses, assuring that a single win will recoup all of our losses. This makes
  SevenReds
  a 
 further specialization of
  Martingale
 . We will be using the basic features of
  Martingale
 , but doing additional 
 processing to determine if we should place a bet or not.
  
 Introducing a new subclass should be done by upgrading the main program. See
  Soapbox on Composition 
 for 
 comments on the ideal structure for a main program. Additionally, see the
  Roulette Solution Questions and 
 Answers
  FAQ entry.
  
 95",NA
15.2 SevenReds Design,"class SevenReds
 ()
  
 SevenReds
  is a
  Martingale
  player who places bets in Roulette. This player waits until the wheel has spun red 
 seven times in a row before betting black.
  
 15.2.1 Fields
  
 redCount 
  
 The number of reds yet to go. This starts at 7 , is reset to 7 on each non-red outcome, and decrements by 
 1 on each red outcome.
  
 Note that this class inherits betMultiple. This is initially 1, doubles with each loss and is reset to one on each 
 win.
  
 15.2.2 Methods
  
 placeBets
 (
 self
 )
  
 96
  
 Chapter 15.
  
 SevenReds Player Class",NA
15.3 Player Rework,"We’ll need to revise the
  Player
  class to add the following method. The superclass version doesn’t do anything 
 with this information. Some subclasses, however, will process this.
  
 winners
 (
 self, outcomes
 )
  
 Parameter
  outcomes
  (Set of Outcome) – The set of
  Outcome
  instances that are part of the 
  
 current win.
  
 The game will notify a player of each spin using this method. This will be invoked even if the player 
 places no bets.",NA
15.4 Game Rework,"We’ll need to revise the
  Game
  class to extend the cycle method. This method must provide the winning bin’s 
 Outcome
  set.",NA
15.5 SevenReds Player Deliverables,"There are six deliverables from this exercise. The new classes will require complete Javadoc comments or 
 Python docstrings.
  
 • A revision to the
  Player
  to add the
  Player.winners()
  method. The superclass version doesn’t do 
  
 anything with this information. Some subclasses, however, will process this.
  
 • A revision to the
  Player
  unit tests.
  
 • A revision to the
  Game
  class. This will call the winners() with the winning
  Bin
  instance before paying 
  
 off the bets.
  
 • The
  SevenReds
  subclass of
  Player
 .
  
 • A unit test of the
  SevenReds
  class. This test should synthesize a fixed list of
  Outcome
 s,
  Bin
 s and the call a
  
 SevenReds
  instance with various sequences of reds and blacks. One test cases can assure that no bet is 
 placed until 7 reds have been seen. Another test case can assure that the bets double (following the 
 Martingale betting strategy) on each loss.
  
 • A main application function that creates the necessary objects, runs the
  Simulator
 ‘s gather() method, 
  
 and writes the available outputs to sys.stdout
  
 For this initial demonstration program, it should simply print the list of maxima, and the list of session 
 lengths. This raw data can be redirected to a file, loaded into a spreadsheet and analyzed.
  
 15.3.
  
 Player Rework
  
 97",NA
SIXTEEN,NA,NA
STATISTICAL MEASURES,"This section presents two ordinary statistical algorithms: mean and standard deviation. In one sense, this 
 section could be treated as optional. Instead of having the simulator present useful summary statistics, raw 
 data can be put into a spreadsheet for creating the statistics.
  
 However, the process of designing these statistical processing classes is very interesting. This chapter exam-
 ines some ways to add features to the built-in collection classes.",NA
16.1 Statistics Overview,"Currently, the
  Simulator
  class collects two Lists. 
  
 One has the length of a session, the other has the
  
 maximum stake during a session. We need to create some descriptive statistics to summarize these stakes
  
 and session lengths.
  
  
 On Statistics
  
 In principle, we could apply basic probability theory to predict the statistics generated by this simula-
 tion. Indeed, some of the statistics we are gathering are almost matters of definition, rather than actual 
 unknown data. We are, however, much more interested in the development of the software than we are 
 in applying probability theory to a relatively simple casino game. As a consequence, the statistical 
 analysis here is a little off-base.
  
 In spite of our problems, we will build a relatively simple-minded set of descriptive statistics. We will 
 average two metrics: the peak stake for a session and the duration of the session. Both of these values 
 have some statistical problems. The peak stake, for instance, is already a summary number. We have to 
 be cautious in our use of summarized numbers, since we have lost any sense of the frequency with 
 which the peaks occured. For example, a player may last 250 cycles of play, with a peak stake of 130. We 
 don’t know if that peak occurred once or 100 times out of that 250. Additionally, the length of the 
 session has an upper bound on the number of cycles. This forces the distribution of values to be skewed 
 away from the predictable distribution.
  
   
 We will design a Statistics class with responsibility to retain and summarize a list of numbers and produce the 
 average (also known as the mean) and standard deviation. 
  
 The
  Simulator
  can then use this this 
 Statistics class to get an average of the maximum stakes from the list of session-level measures. The 
 Simulator
  
 can also apply this Statistics class to the list of session durations to see an average length of game play before 
 going broke.
  
 We can encapsulate this statistical processing in two ways: we could extend an existing class or we could 
 delegate the statistical functions to a separate class. If we extend the library java.util.List, we can add the 
 needed statistical summary features; given this new class, we can replace the original List of sample values 
 with a StatisticalList that both saves the values and computes descriptive statistics. In addition
  
 99",NA
16.2 Some Foundations,"For those programmers new to statistics, this section covers the Sigma operator, Σ.
  
 ∑
 f
 (
 i
 )
  
 The Σ operator has three parts to it. Below it is a bound variable,
  i
 , and the starting value for the range, 
 written as
  i
  = 0. Above it is the ending value for the range, usually something like
  n
 . To the right is some 
 function to execute for each value of the bound variable. In this case, a generic function,
  f
 (
 i
 ) is shown. This is 
 read as “sum
  f
  (
  i
  ) for
  i
  in the range 0 to
  n
 “.
  
 One common definition of Σ uses a closed range, including the end values of 0 and
  n
  . However, since this is 
 not a helpful definition for software, we will define Σ to use a half-open interval. It has exactly
  n
  elements, 
 including 0 and
  n
  -1; mathematically, 0
  ≤ i < n
 .
  
 Consequently, we prefer the following notation, but it is not often used. Since statistical and mathematical 
 texts often used 1-based indexing, some care is required when translating formulae to programming 
 languages that use 0-based indexing.
  
 0
 ≤i<n
 ∑
 f
 (
 i
 )
  
 Our two statistical algorithms have a form more like the following function. In this we are applying some 
 function,
  f
 , to each value,
  x
 i
  of an list,
  x
 .
  
 When computing the mean, as a special case, there is no function applied to the values in the list. When 
 computing standard deviation, the function involves subtracting and multiplying.
  
 0
 ≤i<n
 ∑
  
 f
 (
 x
 i
 )
  
 We can transform this definition directly into a for loop that sets the bound variable to all of the values in the 
 range, and does some processing on each value of the List of Integers.
  
 100
  
 Chapter 16.
  
 Statistical Measures",NA
16.3 Statistical Algorithms,"16.3.1 Mean
  
 Computing the mean of a list of values is relatively simple. The mean is the sum of the values divided by the 
 number of values in the list. Since the statistical formula is so closely related to the actual loop, we’ll provide 
 the formula, followed by an overview of the code.
  
 µ
 x
  =
  
 0
 ≤i<n
 ∑
  
 n
  
 x
 i
  
 The definition of the Σ mathematical operator leads us to the following method for computing the mean:
  
 Computing The Mean of a List,
  X
 , with
  n
  elements.
  
 1.
  Initialize
 . Set
  s ←
  0.
  
 2.
  Iterate
 . For each value,
  x
 i
  in the list:
  
  
 Sum and Count
 . Set
  s ← s
  +
  x
 i
 . 
  
 3.
  Result
 . Return
  s ÷ n
 .
  
 16.3.2 Standard Deviation
  
 The standard deviation can be done a few ways. We’ll use the formula shown below. This computes a deviation 
 measurement as the square of the difference between each sample and the mean.
  
 The sum of these measurements is then divided by the number of values times the number of degrees of 
 freedom to get a standardized deviation measurement.
  
 Again, the formula summarizes the loop, so we’ll show the formula followed by an overview of the code.
  
 σ
 x
  =
  
 0
 ≤i<n
 ∑(
 x
 i
  − µ
 x
 )
 2
  
 n −
  1
  
 The definition of the Σ mathematical operator leads us to the following method for computing the standard 
 deviation:
  
 16.3.
  
 Statistical Algorithms
  
 101",NA
16.4 IntegerStatistics Design,"class IntegerStatistics
 () 
  
 IntegerStatistics
  computes several simple descriptive statistics of Integer values in a List.
  
 In Python, we don’t actually need a class definition, we can simply declare two functions outside any class. 
 However, to be consistent with Java, it’s easier to define these functions in a class.
  
 16.4.1 Constructors
  
 Since this class has entirely static methods, it doesn’t really need a constructor.
  
 16.4.2 Methods
  
 mean
 (
 values
 ) 
  
  
 This requires the
  @staticmethod
  decorator.
  
 Parameter
  values
  (list) – The list of values we are summarizing. 
 Computes the mean of the List of Integer values.
  
 stdev
 (
 values
 ) 
  
  
 This requires the
  @staticmethod
  decorator.
  
 Parameter
  values
  (list) – The list of values we are summarizing. 
 Computes the standard deviation of the List of Integer values.
  
 102
  
 Chapter 16.
  
 Statistical Measures",NA
16.5 Statistics Deliverables,"There are three deliverables for this exercise. These classes will include the complete Javadoc comments or 
 Python dostring.
  
 • The
  IntegerStatistics
  class.
  
 • A unit test of the
  IntegerStatistics
  class.
  
 Prepare some simple list (or tuple) of test data.
  
 The results can be checked with a spreadsheet
  
  
 • An update to the overall
  Simulator
  that gets uses an
  IntegerStatistics
  object to compute the mean 
  
  
 and standard deviation of the peak stake. It also computest the mean and standard deviation of the 
  
  
 length of each session of play.
  
 Here is some standard deviation unit test data.
  
 Sample Value 9 
  
 8 
  
 5 
  
 9 
  
 9 
  
 4 
  
 5 
  
 8 
  
 10 
  
 7 
  
 8 
  
 8
  
 Here are some intermediate results and the correct answers given to 6 significant digits. Your answers should 
 be the same to the precision shown.
  
 sum
  90 
  
 count
  12 
  
 mean
  7.5 
  
 sum d*d
  608.668 
  
 stdev
  1.88293
  
 16.5.
  
 Statistics Deliverables
  
 103",NA
SEVENTEEN,NA,NA
RANDOM PLAYER CLASS,"This section will introduce a simple subclass of
  Player
  who bets at random.",NA
17.1 Random Player Overview,"One possible betting strategy is to bet completely randomly. This serves as an interesting benchmark for 
 other betting strategies.
  
 We’ll write a subclass of
  Player
  which steps through all of the bets available on the
  Wheel
 , selecting one or 
 more of the available outcomes at random. This
  Player
 , like others, will have a fixed initial stake and a limited 
 amount of time to play.
  
 The
  Wheel
  class can provide an Iterator over the collection of
  Bin
  instances. We could revise
  Wheel
  to 
 provide a binIterator() method that we can use to return all of the
  Bin
 s. From each
  Bin
 , we will need an 
 iterator we can use to return all of the
  Outcome
 s.
  
 To collect a list of all possible
  Outcome
 s, we would use the following algorithm:
  
 Locating all Outcomes
  
 1.
  Empty List of Outcomes
 . Create an empty set of all
  Outcome
 s, all_OC.
  
 2.
  Get Bin Iterator
 . Get the Iterator from the
  Wheel
  that lists all
  Bin
 s.
  
 3.
  For each Bin
 .
  
 Get Outcome Iterator
 . Get the Iterator that lists all
  Outcome
 s.
  
 For each Outcome
 .
  
 Save Outcome
 . Save a reference to each
  Outcome
  in the set of all known outcomes, all_OC.
  
 To place a random bet, we would use the following algorithm:
  
 Placing a Random Bet
  
 1. Get the size of the pool of all possible
  Outcome
  s,
  s
 .
  
 2. Get a random number,
  u
 , from zero to the total size-1. That is, 0 <=
  u
  <=
  s
  -1.
  
 3. Return element
  u
  from the pool of
  Outcome
  s.
  
 105",NA
17.2 Random Player Design,"class PlayerRandom
 () 
  
 PlayerRandom
  is a
  Player
  who places bets in Roulette. This player makes random bets around the layout.
  
 17.2.1 Fields
  
 rng
  
 A Random Number Generator which will return the next random number.
  
 17.2.2 Constructors
  
 __init__
 (
 table, rng
 ) 
  
 This uses the super() construct to invoke the superclass constructor using the
  Table
 . Then it saves the 
 random number generator. This could be an instance of either Random or NonRandom.
  
 Parameters
  
 •
  table
  (Table) – The
  Table
  which will accept the bests.
  
 •
  rng
  (random.Random) – A :class:random.Random‘ random number generator.
  
 17.2.3 Methods
  
 placeBets
 (
 self
 ) 
  
  
 Updates the
  Table
  with a randomly placed bet.",NA
17.3 Random Player Deliverables,"There are five deliverables from this exercise. The new classes need Javadoc comments or Python docstrings.• 
 Updates to the class
  Bin
  to return an iterator over available
  Outcome
 s. Updates to unittests for the class
  Bin
 , 
 also.
  
 • Updates to the
  Wheel
  to return an iterator over available
  Bin
 s. Updates to the unittests for the class 
  
 Wheel
 , also.
  
 • The
  PlayerRandom
  class.
  
 • A unit test of the
  PlayerRandom
  class. This should use the NonRandom number generator to iterate 
  
 through all possible
  Outcome
 s.
  
 • An update to the overall
  Simulator
  that uses the
  PlayerRandom
 .
  
 106
  
 Chapter 17.
  
 Random Player Class",NA
EIGHTEEN,NA,NA
PLAYER 1-3-2-6 CLASS,"This section will describe a player who has a complex internal state. We will also digress on the way the states 
 can be modeled using a group of polymorphic classes. This section also has an advanced exercise that shows 
 some alternative implementations for the state objects, using the
  Singleton
  design pattern.",NA
18.1 Player 1-3-2-6 Overview,"On the Internet, we found descriptions of a betting system called the “1-3-2-6” system. This system looks to 
 recoup losses by waiting for four wins in a row. The sequence of numbers (1, 3, 2 and 6) are the multipliers to 
 use when placing bets after winning. At each loss, the sequence resets to the multiplier of 1. At each win, the 
 multiplier is advanced. After one win, the bet is now 3x. After a second win, the bet is reduced to 2x, and the 
 winnings of 4x are “taken down” or removed from play. In the event of a third win, the bet is advanced to 6x. 
 Should there be a fourth win, the player has doubled their money, and the sequence resets.
  
 This betting system makes our player more stateful than in previous betting systems. 
 SevenReds
 , we noted that this player was stateful; that case, the state was a simple count.
  
 When designing
  
 In this case, the description of the betting system seems to identify four states: no wins, one win, two wins, 
 and three wins. In each of these states, we have specific bets to place, and state transition rules that tell us 
 what to do next. The following table summarizes the states, the bets and the transition rules.
  
 Table 18.1: 1-3-2-6 Betting States
  
 State 
  
 No Wins 
  
 One Win 
  
 Two Wins 
  
 Three Wins
  
 Bet 
 1 
  
 3 
  
 2 
  
 6
  
 Next State 
 On Win 
  
 One Win 
  
 Two Wins 
  
 Three Wins 
 No Wins
  
 On Loss 
  
 No Wins 
 No Wins 
 No Wins 
 No Wins
  
 When we are in a given state, the table gives us the amount to bet in the
  Bet
  column. If this bet wins, we 
 transition to the state named in the
  On Win
  column, otherwise, we transition to the state named in the
  On Loss
  
 column. We always start in the No
  Wins
  state.
  
 Design Pattern
 . We can exploit the
  State
  design pattern to implemente this more sophisticated player. This 
 pattern suggests that we design a hierarchy of classes to represent these four states. Each state will have a 
 slightly different bet amount, and different state transition rules. Each individual state class will be relatively 
 simple, but we will have isolated the processing unique to each state into separate classes.
  
 One of the consequences of the
  State
  design pattern is that it obligates us to define the interface between the
  
 Player
  and the object that holds the
  Player
 ‘s current state.
  
 107",NA
18.2 On Polymorphism,"One very important note is that we never have to check the class of any object. This is so important, we will 
 repeat it here.
  
 Important: 
 We don’t use isistance().
  
 We use
  polymorphism
  and design all subclasses to have the same interface.
  
 Python relies on
  duck typing
  (“if it walks like a duck and quacks like a duck, it is a duck”).
  
 Additionally, Python relies on the principle that it’s better to seek forgiveness than ask permission. What this 
 translates to is an approach where an object’s methods are simply invoked. If the object imple-ments the 
 methods, then it walked like a duck and – for all practical purposes – actually
  was
  a duck. If the method is not 
 implemented, the application has a serious design problem and needs to crash.
  
 We find that isinstance() is sometimes used by beginning programmers who have failed to properly delegate 
 processing to the subclass.
  
 Often, when a responsibility has been left out of the class hierarchy, it is allocated to the client object. The 
 typical Pretty-Poor Polymorphism looks like the following:
  
 class SomeClient( object ): 
  
 def someMethod( self ): 
  
  
  
 if isinstance(x, AClass): 
  
  
  
  
 Special Case that should have been part of AClass
  
 In all cases, uses of isinstance() must be examined critically.
  
 This will usually lead to refactoring the special case out of the collaborating class. There will be three changes 
 as part of the refactoring.
  
 1. We will move the special-case the functionality into the class being referenced by instanceof. In the 
  
 above example, the special case is moved to AClass.
  
 2. We will usually have to add default processing to the superclass of AClass so that all other sibling 
  
 classes of AClass lack this special-case feature.
  
 3. We simply call the refactored method from the client class.
  
 This refactoring leads to a class hierarchy that has the property of being
  polymorphic
 : all of the subclasses 
 have the same interface: all objects of any class in the hierarchy are interchangable. Each object is, therefore, 
 responsible for correct behavior. More important, a client object does not need to know which subclass the 
 object is a member of: it simply invokes methods which are defined with a uniform interface across all 
 subclasses.
  
 108
  
 Chapter 18.
  
 Player 1-3-2-6 Class",NA
18.3 Player 1-3-2-6 Questions and Answers,"Why code the state as objects?
  
 The reason for encoding the states as objects is to encapsulate the information and the behavior 
 associated with that state. In this case, we have both the bet amount and the rules for transition to 
 next state. While simple, these are still unique to each state.
  
 Since this is a book on design, we feel compelled to present the best design. 
  
 In games like 
 blackjack, the player’s state may have much more complex information or behavior. In those 
 games, this design pattern will be very helpful. In this one case only, the design pattern appears to 
 be over-engineered.
  
 We will use this same design pattern to model the state changes in the Craps game itself. In the 
 case of the Craps game, there is additional information as well as behavior changes. When the 
 state changes, bets are won or lost, bets are working or not, and outcomes are allowed or 
 prohibited.
  
 Isn’t it simpler to code the state as a number? We can just increment when we win, and reset to zero when we 
 lose.
  
 The answer to all “isn’t it simpler” questions is “yes, but...” In this case, the full answer is “Yes, but 
 what happens when you add a state or the states become more complex?”
  
 This question arises frequently in OO programming. Variations on this question include “Why is 
 this an entire object?” and “Isn’t an object over-engineering this primitive type?” See
  Design 
 Decision – Object Identity
  FAQ entry on the
  Outcome
  class for additional background on object 
 identity.
  
 Our goal in OO design is to isolate responsibility. First, and most important, we can unambigu-
 ously isolate the responsibilities for each individual state. Second, we find that it is very common 
 that only one state changes, or new states get added. Given these two conditions, the best object 
 model is separate state objects.
  
 Doesn’t this create a vast number of state objects?
  
 Yes.
  
 There are two usual follow-up questions: “Aren’t all those objects a lot of memory overhead?” or “...a lot of 
 processing overhead?”
  
 Since Java and Python remove unused objects, the old state definitions are cleaned up by the 
 garbage collection thread. A few tests will demonstrate that the Java memory management is 
 efficient and reliable.
  
 Object creation is an overhead that we can control. One common approach is to use the
  Sin-
 gleton
  design pattern. In this case, this should be appropriate because we only want a single 
 instance of each of these state classes.
  
 Note that using the
  Singleton
  design pattern doesn’t change any interfaces except the initial-
 ization of the
  Player1326
  object with the starting state.
  
 Is Polymorphism necessary?
  
 In some design patterns, like
  State
  and
  Command
 , it is essential that all subclasses have the same 
 interface and be uniform, indistinguishable, almost anonymous instances. Because of this 
 polymorphic property, the objects can be invoked in a completely uniform way.
  
 In our exercise, we will design a number of different states for the player. Each state has the same 
 interface. The actual values for the instance variables and the actual operation implemented by
  
 18.3.
  
 Player 1-3-2-6 Questions and Answers
  
 109",NA
18.4 Player1326 State Design,"class Player1326State
 ()
  
 Player1326State
  is the superclass for all of the states in the 1-3-2-6 betting system.
  
 18.4.1 Fields
  
 player 
  
 The
  Player1326
  player who is currently in this state. This player will be used to provide the
  Outcome 
 that will be used to create the
  Bet
 .
  
 18.4.2 Constructors
  
 __init__
 (
 self, player
 )
  
 The constructor for this class saves the
  Player1326
  which will be used to provide the
  Outcome 
 on 
 which we will bet.
  
 18.4.3 Methods
  
 currentBet
 (
 self
 ) 
  
 Constructs a new
  Bet
  from the player’s preferred
  Outcome
 . Each subclass has a different multiplier used 
 when creating this
  Bet
 .
  
 In Python, this method should return NotImplemented. This is a big debugging aid, it helps us locate 
 subclasses which did not provide a method body. This raise statement is the functional equivalent of the 
 Java abstract declaration.
  
 nextWon
 (
 self
 ) 
  
  
 Constructs the new
  Player1326State
  instance to be used when the bet was a winner.
  
 In Python, this method should return NotImplemented. This is a big debugging aid, it helps us locate 
 subclasses which did not provide a method body. This raise statement is the functional equivalent of the 
 Java abstract declaration.
  
 nextLost
 (
 self
 )
  
 Constructs the new
  Player1326State
  instance to be used when the bet was a loser. This method is 
 the same for each subclass: it creates a new instance of
  Player1326NoWins
 .
  
 This defined in the superclass to assure that it is available for each subclass.
  
 110
  
 Chapter 18.
  
 Player 1-3-2-6 Class",NA
18.5 Player1326 No Wins Design,"class Player1326NoWins
 () 
  
 Player1326NoWins
  defines the bet and state transition rules in the 1-3-2-6 betting system. When there are no 
 wins, the base bet value of 1 is used.
  
 18.5.1 Methods
  
 currentBet
 (
 self
 ) 
  
  
 Constructs a new
  Bet
  from the player’s outcome information. The bet multiplier is 1.
  
 nextWon
 (
 self
 ) 
  
  
 Constructs the new
  Player1326OneWin
  instance to be used when the bet was a winner.",NA
18.6 Player1326 One Win Design,"class Player1326OneWin
 () 
  
 Player1326OneWin
  defines the bet and state transition rules in the 1-3-2-6 betting system. When there is one 
 wins, the base bet value of 3 is used.
  
 18.6.1 Methods
  
 currentBet
 (
 self
 ) 
  
  
 Constructs a new
  Bet
  from the player’s outcome information. The bet multiplier is 3.
  
 nextWon
 (
 self
 ) 
  
  
 Constructs the new
  Player1326TwoWins
  instance to be used when the bet was a winner.",NA
18.7 Player1326 Two Wins Design,"class Player1326TwoWins
 () 
  
 Player1326TwoWins
  defines the bet and state transition rules in the 1-3-2-6 betting system. When there are 
 two wins, the base bet value of 2 is used.
  
 18.7.1 Methods
  
 currentBet
 (
 self
 ) 
  
  
 Constructs a new
  Bet
  from the player’s outcome information. The bet multiplier is 2.
  
 nextWon
 (
 self
 ) 
  
  
 Constructs the new
  Player1326ThreeWins
  instance to be used when the bet was a winner.
  
 18.5.
  
 Player1326 No Wins Design
  
 111",NA
18.8 Player1326 Three Wins,"class Player1326ThreeWins
 () 
  
 Player1326ThreeWins
  defines the bet and state transition rules in the 1-3-2-6 betting system. When there are 
 three wins, the base bet value of 6 is used.
  
 18.8.1 Methods
  
 currentBet
 (
 self
 ) 
  
  
 Constructs a new
  Bet
  from the player’s outcome information. The bet multiplier is 6.
  
 nextWon
 (
 self
 ) 
  
  
 Constructs the new
  Player1326NoWins
  instance to be used when the bet was a winner.
  
 An alternative is to update the player to indicate that the player is finished playing.",NA
18.9 Player1326 Design,"class Player1326
 () 
  
 Player1326
  follows the 1-3-2-6 betting system. The player has a preferred
  Outcome
 , an even money bet like 
 red, black, even, odd, high or low. The player also has a current betting state that determines the current bet 
 to place, and what next state applies when the bet has won or lost.
  
 18.9.1 Fields
  
 outcome 
  
  
 This is the player’s preferred
  Outcome
 . During construction, the Player must fetch this from the
  Wheel
 .
  
 state 
  
  
 This is the current state of the 1-3-2-6 betting system. 
  
 It will be an instance of a subclass of 
  
 Player1326State
 . 
  
 This will be one of the four states: No Wins, One Win, Two Wins or Three 
  
 Wins.
  
 18.9.2 Constructors
  
 __init__
 (
 self
 ) 
  
 Initializes the state and the outcome. The state is set to the initial state of an instance of
  Player1326NoWins
 . 
 The outcome is set to some even money proposition, for example ""Black"".
  
 18.9.3 Methods
  
 placeBets
 (
 self
 )
  
 Updates the
  Table
  with a bet created by the current state. 
 creation to state object’s currentBet() method.
  
 win
 (
 self, bet
 )
  
 This method delegates the bet
  
 112
  
 Chapter 18.
  
 Player 1-3-2-6 Class",NA
18.10 Player 1-3-2-6 Deliverables,"There are eight deliverables for this exercise. 
 exercise in a separate section.
  
 Additionally, there is an optional, more advanced design
  
 • The five classes that make up the
  Player1326State
  class hierarchy.
  
 • The
  Player1326
  class.
  
 • A Unit test for the entire
  Player1326State
  class hierarchy. It’s possible to unit test each state class, 
  
 but they’re so simple that it’s often easier to simply test the entire hierarchy.
  
 • A unit test of the
  Player1326
  class. This test should synthesize a fixed list of
  Outcome
 s,
  Bin
 s, and calls a
  
 Player1326
  instance with various sequences of reds and blacks. There are 16 different sequences of 
 four winning and losing bets. These range from four losses in a row to four wins in a row.
  
 • An update to the overall
  Simulator
  that uses the
  Player1326
 .",NA
18.11 Advanced Exercise – Refactoring,"Initially, each subclass of
  Player1326State
  has a unique currentBet() method.
  
 This class can be simplified slightly to have the bet multiplier coded as an instance variable, betAmount. The 
 currentBet() method can be refactored into the superclass to use the betAmount value.
  
 This would simplify each subclass to be only a constructor that sets the betAmount multiplier to a value of 1, 
 3, 2 or 6.
  
 Similarly, we could have the next state after winning defined as an instance variable, nextStateWin. We can 
 initialized this during construction. Then the nextWon() method could also be refactored into the superclass, 
 and would return the value of the nextStateWin instance variable.
  
 The deliverable for this exercise is an alternative
  Player1326State
  class using just one class and distinct 
 constructors that create each state object with an appropriate bet multipler and and next state win value.",NA
18.12 Advanced Exercise – Less Object Creation,"The object creation for each state change can make this player rather slow.
  
 There are a few design pattens that can reduce the number of objects that need to be created.
  
 18.10.
  
 Player 1-3-2-6 Deliverables
  
 113",NA
NINETEEN,NA,NA
CANCELLATION PLAYER CLASS,"This section will describe a player who has a complex internal state that can be modeled using existing library 
 classes.",NA
19.1 Cancellation Player Overview,"One method for tracking the lost bets is called the “cancellation” system or the “Labouchere” system. The 
 player starts with a betting budget allocated as a series of numbers.
  
 The usual example sequence is [ 1, 2, 3, 4, 5, 6 ].
  
 Each bet will be the sum of the first and last numbers in the last.
  
 In this example, the end values of 1+6 leads the player to bet 7.
  
 When the player wins, the player cancels the two numbers used to make the bet. In the event that all the 
 numbers are cancelled, the player has doubled their money, and can retire from the table happy.
  
 For each loss, however, the player adds the amount of the bet to the end of the sequence; this is a loss to be 
 recouped. This adds the loss to the amount bet to assure that the next winning bet both recoups the most 
 recent loss and provides a gain. Multiple winning bets will recoup multiple losses, supplemented with small 
 gains.
  
 Example
 . Here’s an example of the cancellation system using ‘[ 1, 2, 3, 4, 5, 6 ]’
  
 1. Bet 1+6. A win. Cancel 1 and 6 leaving ‘[ 2, 3, 4, 5 ]’
  
 2. Bet 2+5. A loss. Add 7 leaving ‘[ 2, 3, 4, 5, 7 ]’
  
 3. Bet 2+7. A loss. Add 9 leaving ‘[ 2, 3, 4, 5, 7, 9 ]’
  
 4. Bet 2+9. A win. Cancel 2 and 9 leaving ‘[ 3, 4, 5, 7 ]’
  
 5. Next bet will be 3+7.
  
 State
 . The player’s state is a list of individual bet amounts. This list grows and shrinks; when it is empty, the 
 player leaves the table. We can keep a List of individual bet amounts. The total bet will be the first and last 
 elements of this list. Wins will remove elements from the collection; losses will add elements to the collection. 
 Since we will be accessing elements in an arbitrary order, we will want to use an ArrayList. We can define the 
 player’s state with a simple list of values.",NA
19.2 PlayerCancellation Design,"class PlayerCancellation
 ()
  
 115",NA
19.3 Cancellation Player Deliverables,"There are three deliverables for this exercise.
  
 • The
  PlayerCancellation
  class.
  
 • A unit test of the
  PlayerCancellation
  class. This test should synthesize a fixed list of
  Outcome
 s,
  Bin 
 s, and 
 calls a
  PlayerCancellation
  instance with various sequences of reds and blacks. There are 16 different 
 sequences of four winning and losing bets. These range from four losses in a row to four wins in a row. 
 This should be sufficient to exercise the class and see the changes in the bet amount.
  
 • An update to the overall
  Simulator
  that uses the
  PlayerCancellation
 .
  
 116
  
 Chapter 19.
  
 Cancellation Player 
 Class",NA
TWENTY,NA,NA
FIBONACCI PLAYER CLASS,"This section will describe a player who has an internal state that can be modeled using methods and simple 
 values instead of state objects.
  
 This is a variation on the Martingale System. See
  Martingale Player Design
  for more information.",NA
20.1 Fibonacci Player Overview,"A player could use the
  Fibonacci Sequence
  to structure a series of bets in a kind of cancellation system. The 
 Fibonacci Sequence is
  
  
 • 1
  
  
 • 1
  
  
 • 2
  
  
 • 3
  
  
 • 5
  
  
 • 8
  
  
 • 13
  
  
 • ...
  
 At each loss, the sum of the previous two bets is used, which is the next number in the sequence. In the event 
 of a win, we revert to the basic bet.
  
 Example
 . Here’s an example of the Fibonacci system.
  
 1. Bet 1. A win.
  
 2. Bet 1. A loss. The next value in the sequence is 1.
  
 3. Bet 1. A loss. The next value in the sequence is 2.
  
 4. Bet 2. A loss. The next value in the sequence will be 3 
  
 5. Bet 3. In the event of a loss, the next bet is 5. Otherwise, the bet is 1.
  
 State
 . In order to compute the Fibonacci sequence, we need to retain the two previous bets as the player’s 
 state. In the event of a win, we revert to the basic bet value of 1.
  
 In the event of a loss, we can update the two numbers to show the next step in the sequence. The player’s state 
 is just these two numeric values.
  
 117",NA
20.2 PlayerFibonacci Design,"class PlayerFibonacci
 () 
  
 PlayerFibonacci
  uses the Fibonacci betting system. This player allocates their available budget into a 
 sequence of bets that have an accelerating potential gain.
  
 20.2.1 Fields
  
 recent 
  
  
 This is the most recent bet amount. Initially, this is 1.
  
 previous 
  
  
 This is the bet amount previous to the most recent bet amount. Initially, this is zero.
  
 20.2.2 Constructors
  
 __init__
 (
 self
 ) 
  
  
 Initialize the Fibonacci player.
  
 20.2.3 Methods
  
 win
 (
 self, bet
 ) 
  
  
  
 Parameter
  bet
  (Bet) – The bet which won 
  
  
 Uses the superclass method to update the stake with an amount won. It resets recent and 
  
 previous to their initial values of 1 and 0.
  
 lose
 (
 self, bet
 ) 
  
  
  
 Parameter
  bet
  (Bet) – The bet which lost 
  
  
 Uses the superclass method to update the stake with an amount lost. This will go “forwards” in 
  
 the 
 sequence. It updates recent and previous as follows.
  
  
 next ← recent
  +
  previous 
  
 previous ← recent 
  
  
  
 recent ← next 
  
 param bet
  The
  Bet
  which lost.
  
 type bet
  Bet",NA
20.3 Fibonacci Player Deliverables,"There are three deliverables for this exercise.
  
 • The
  PlayerFibonacci
  class.
  
 • A unit test of the
  PlayerFibonacci
  class. This test should synthesize a fixed list of
  Outcome
 s,
  Bin
 s, and calls 
 a
  PlayerFibonacci
  instance with various sequences of reds and blacks. There are 16 different sequences 
 of four winning and losing bets. These range from four losses in a row to four wins in a row. This should 
 be sufficient to exercise the class and see the changes in the bet amount.
  
 118
  
 Chapter 20.
  
 Fibonacci Player Class",NA
TWENTYONE,NA,NA
CONCLUSION,"The game of Roulette has given us an opportunity to build an application with a considerable number of 
 classes and objects. It is comfortably large, but not complex; we have built tremendous fidelity to a real-world 
 problem. Finally, this program produces moderately interesting simulation results.
  
 We note that a great many of our design decisions were not easy to make without exploring a great deal of the 
 overall application’s design. There are two ways to do this exploration: design everything in advance or 
 design just enough but remain tolerant of our own ignorance.
  
 Experienced designers can often design an entire, complex application before building any software. The 
 process of doing this design, however, is internally iterative. Some parts are designed in detail, with tolerance 
 for future changes; then other parts are designed in detail and the two design elements reconciled.
  
 For new designers, we can’t give enough emphasis to the importance of creating a trial design, exploring the 
 consequences of that design, and then doing rework of that design. Too often, we have seen trial designs 
 finalized into deliverables with no opportunity for meaningful rework. In
  Review of Testability
 , we presented 
 one common kind of rework to support more complete testing. In
  Player Class
 , we presented another kind of 
 rework to advance a design from a stub to a complete implementation.
  
 We also feel compelled to point out the distinction between relatively active and passive classes in this 
 design. We had several passive classes, like
  Outcome
 ,
  Bet
  and
  Table
 , which had few responsibilities beyond 
 collecting a number of related attributes and providing simple functions. We also had several complex, active 
 classes, like
  Game
 ,
  BinBuilder
  and all of the variations on
  Player
 . These classes, typically, had fewer attributes 
 and more complex methods. In the middle of the spectrum is the
  Wheel
 . We find this distinction to be an 
 enduring feature of OO design: there are
  things
  and
  actors
 ; the things tend to be passive, acted upon by the 
 actors. The overall system behavior emerges from the collaboration among all of the objects in the system; 
 primarily – but not exclusively – the behavior of the active classes.
  
 121",NA
Part III ,NA,NA
Craps,123,NA
TWENTYTWO,NA,NA
CRAPS DETAILS,"In the first section we will present elements of the game of Craps. Craps is a stateful game, and we’ll describe 
 the state changes in some detail.
  
 We will review some of the bets available on the Craps table in some depth. Craps offers some very obscure 
 bets, and part of this obscurity stems from the opaque names for the various bets. Creating this wide variety 
 of bets is an interesting programming exercise, and the first four exercise chapters will focus on this.
  
 Finally, we will describe some common betting strategies that we will simulate. 
  
 The betting strategies 
 described in
  Roulette
  will be applied to Craps bets, forcing us to examine the Roulette solution for reuse 
 opportunities.",NA
22.1 Craps Game,"Craps centers around a pair of
  dice
  with six sides. The 36 combinations form eleven numbers from 2 to 12; 
 additionally, if the two die are equal, this is called a
  hardways
  , because the number was made “the hard way” . 
 The
  table
  has a surface marked with spaces on which players can place
  bets
  . The names of the bets are 
 opaque, and form an obscure jargon. There are several broad classification of bets, including those which 
 follow the sequence of dice throws that make up a complete
  game
  ,
  propositions
  based on only the next throw 
 of the dice, and hardways bets. These bets will be defined more completely, below.
  
 When the bets are placed, the dice are thrown by one of the players. This number resolves the one-roll bets 
 that are winners or losers; it also determines the state change in the game, which may resolve any game-
 based winners and losers. The first roll of the dice can be an immediate win or loss for the game, or it can 
 establish the
  point
  for the following rounds of this game. Subsequent rolls either make the point and win the 
 game, roll a seven and lose the game, or the game continues. When the game is won, the winning player 
 continues to shoot; a losing player passes the dice around the table to the next player.
  
 In addition to the bets marked on the table, there are some additional bets which are not marked on the table. 
 Some of these are called
  odds bets
 , or
  free odds bets
 , and pay off at odds that depend on the dice, not on the bet 
 itself. An odds bet must be associated with a bet called a
  line bet
 , and are said to be “behind”the original bet; 
 they can be called “behind the line odds” bets. The four line bets will be defined more fully, below.
  
 Note: 
  
 Casino Variation
  
 There are slight variations in the bets available in different casinos. We’ll focus on a common subset of bets.
  
 The dice form a frequency distribution with values from 2 to 12. An interesting preliminary exercise is to 
 produce a table of this distribution with a small demonstration program. This frequency distribution is 
 central to understanding the often cryptic rules for Craps. See
  Creating A Dice Frequency Distribution
  for a 
 small application to develop this frequency distribution.
  
 127",NA
22.2 Creating A Dice Frequency Distribution,"Since Python is interpreted, you can enter the following directly in the interpreter and get the frequency of 
 each number.
  
 In Python, you will have to write and run a short program to produce the frequency distribution.
  
 from
  collections
  import
  defaultdict
  
 freq
 =
  defaultdict(
 int
 ) 
  
 for
  d1
  in
  range
 (
 6
 ):
  
 for
  d2
  in
  range
 (
 6
 ): 
  
  
 n
 =
  d1
 +
 d2
 +
 2 
  
  
  
 freq[n]
  +=
  1 
  
 print
  freq",NA
22.3 Available Bets,"There are four broad classifcation of bet 
 complete
  game
 , those based on just the n 
 and the unmarked bets. The game bets a
  
 128
  
 s: those which follow the sequence of dice throws 
 ext throw of the dice (called
  proposition bets
 ), the re 
 called line bets, can be supplemented with additi
  
 Chapter 22.
  
 that make up a 
 hardways bets 
 onal odds bets,
  
 Craps Details",NA
22.4 Some Betting Strategies,"All of the Roulette betting strategies apply to Craps. However, the additional complication of Craps is the 
 ability to have multiple working bets by placing additional bets during the game. The most important of these 
 additional bets are the behind the line odds bets. Since these are paid at proper odds, they are the most 
 desirable bets on the layout. The player, therefore, should place a Line bet, followed by a behind the line odds 
 bet.
  
 The other commonly used additional bets are the Come (or Don’t Come) bets. These increase the number of 
 working bets. Since the additional odds bets for these pay proper odds, they are also highly desirable. A 
 player can place a Come bet, followed by a behind the line odds bet on the specific number rolled.
  
 Beyond this, there are the various proposition and hardways bets that can be placed in addition to other bets. 
 While these propositions have odds that are incorrect, some players will count the number of throws in game, 
 and place a “7” bet if the game lasts more than six throws. This is a form of betting against one’s self: there is a 
 Pass Line bet that the game will be won, diluted by a 7 bet that the game will be lost. While the common 
 rationale is that the second bet protects against a loss, it also reduces the potential win. We can simulate this 
 kind of betting and examine the potential outcomes.",NA
22.5 Wrong Betting,"Craps has two forms of odds betting: right and wrong. The Pass Line and Come Line, as well as buying odds, 
 are all “right”. The Don’t Pass, Don’t Come and Laying Odds are all “wrong”. Sometimes wrong betting is also 
 called “the dark side”.
  
 Right betting involves odds that provide a large reward for a small wager. The odds on a Pass Line bet for the 
 number 4 are 2:1, you will win double your bet if the point is made. You put up $10 at risk to make $20.
  
 Wrong betting involves odds that provide a small reward for a large wager. The odds on a Don’t Pass Line bet 
 for the number 4 are described as “laid at 2:1” – in effect it is a 1:2 bet, you will win half of what you bet if the 
 point is missed. You put $20 at risk to make $10.
  
 22.4.
  
 Some Betting Strategies
  
 131",NA
TWENTYTHREE,NA,NA
CRAPS SOLUTION OVERVIEW,"We will present a survey of the classes gleaned from the general problem statement in
  Problem Statement
  as 
 well as the problem details in
  Craps Details
 . This survey is drawn from a quick overview of the key nouns in 
 these sections.
  
 Given this survey of the candidate classes, we will then do a walkthrough to refine the definitions, and assure 
 ourselves that we have a reasonable architecture. We will make some changes to the preliminary class list, 
 revising and expanding on our survey.
  
 We will also include a number of questions and answers about this preliminary design information. This 
 should help clarify the design presentation and set the stage for the various development exercises in the 
 chapters that follow.",NA
23.1 Preliminary Survey of Classes,"We have divided up the responsibilities to provide a starting point for the development effort. The central 
 principle behind the allocation of responsibility is
  encapsulation
  . In reading the background information and 
 the problem statement, we noticed a number of nouns that seemed to be important parts of the Craps game.
  
  
 • Dice
  
  
 • Bet
  
  
 • Table
  
  
 • Point
  
  
 • Proposition
  
  
 • Number
  
  
 • Odds
  
  
 • Player
  
  
 • House 
  
 The following table summarizes some of the classes and responsibilities that we can identify from the 
 problem statement. This is not the complete list of classes we need to build. As we work through the exercises, 
 we’ll discover additional classes and rework some of these classes more than once.
  
 We also have a legacy of classes available from the Roulette solution. 
 infrastructure as much as possible.
  
 We would like to build on this
  
 133",NA
23.2 Preliminary Class Structure,"Outcome Responsibilities 
  
 A name for a particular betting opportunity. Most outcomes have fixed odds, but the behind 
 the line odds bets have odds that depend on a point value.
  
 Collaborators 
  
 Collected by
  Table
  into the available bets for the
  Player
 ; used by
  Game
  to compute the amount 
 won from the amount that was bet.
  
 Dice Responsibilities 
  
 Selects any winning propositions as well as next state of the game.
  
 Collaborators 
  
 Used by the overall
  Game
  to get a next set of winning
  Outcome
  s, as well as change the state of 
 the
  Game
  .
  
 Table Responsibilities 
  
 A collection of bets placed on
  Outcome
  s by a
  Player
  . This isolates the set of possible bets and 
 the management of the amounts currently at risk on each bet. This also serves as the interface 
 between the
  Player
  and the other elements of the game.
  
 Collaborators 
  
 Collects the
  Outcome
  s; used by
  Player
  to place a bet amount on a specific
  Outcome
  ; used by
  
 Game
  to compute the amount won from the amount that was bet.
  
 Player Responsibilities 
  
 Places bets on
  Outcome
  s, updates the stake with amounts won and lost. This is the most 
 important responsibility in the application, since we expect to update the algorithms this class 
 uses to place different kinds of bets. Clearly, we need to cleanly encapsulate the
  Player 
 , so 
 that changes to this class have no ripple effect in other classes of the application.
  
 Collaborators 
  
 Uses
  Table
  to place
  Bet
  s on preferred
  Outcome
  s; used by
  Game
  to record wins and losses.
  
 Game Responsibilities 
  
 Runs the game: gets bets from
  Player
  , throws the
  Dice
  , updates the state of the game, collects 
 losing bets, pays winning bets. This encapsulates the basic sequence of play into a single class. 
 The overall statistical analysis is based on playing a finite number of games and seeing the 
 final value of the
  Player
  ‘s stake.
  
 Collaborators 
  
 Uses
  Dice
  ,
  Table
  ,
  Outcome
  ,
  Player
  .",NA
23.3 A Walkthrough of Craps,"A good preliminary task is to review these responsibilities to confirm that a complete cycle of play is possible. 
 This will help provide some design details for each class. It will also provide some insight into classes that 
 may be missing from this overview. A good way to structure this task is to do a CRC walkthrough. For more 
 information on this technique see
  A Walkthrough of Roulette
  .
  
 The basic processing outline is the responsibility of the
  Game
  class. To start, locate the
  Game
  card.
  
 134
  
 Chapter 23.
  
 Craps Solution 
 Overview",NA
23.4 Craps Solution Questions and Answers,"Why is
  Outcome
  a separate class? Each object that is an instance of
  Outcome
  is merely a number from 2 to 12.
  
 Here we have complex interdependency between the dice, the game states, the bets and 
 outcomes. An outcome has different meanings in different game states: sometimes a 7 is an 
 immediate winner, other times it as an immediate loser. Clearly, we need to isolate these various 
 rules into separate objects to be sure that we have captured them accurately without any 
 confusion, gaps or conflicts.
  
 We can foresee three general kinds of
  Outcome
  s: the propositions that are resolved by a single 
 throw of the dice, the hardways that are resolved periodically, and the game bets which are 
 resolved when a point is made or missed. Some of the outcomes are only available in certain game 
 states.
  
 23.4.
  
 Craps Solution Questions and Answers
  
 135",NA
TWENTYFOUR,NA,NA
OUTCOME CLASS,"This chapter will examine the
  Outcome
  class, and its suitability for the game of Craps. We’ll present some 
 additional code samples to show a way to handle the different kinds of constuctors that this class will need.",NA
24.1 Outcome Overview,"For Craps, we have to be careful to disentangle the random events produced by the
  Dice
  and the outcomes on 
 which a
  Player
  creates a
  Bet
 . In Roulette, this relationship was simple: a
  Bin
  was a container of
  Outcome
 s; a 
 player’s
  Bet
  referenced one of these
  Outcome
 s. In Craps, however, we have one-roll outcomes, hardways 
 outcomes, plus outcomes that aren’t resolved until the end of the game. Keeping this in mind, we’ll defer 
 details of dice and game problem until later, and focus on just the bet
  Outcome
 s first.
  
 Varietals
 . There is a rich variety of bet
  Outcome
 s. We’ll itemize them so that we can confirm the respon-
 sibilities for this class.
  
 • The Line Bets: these are the Pass Line, Don’t Pass Line, Come Line, Don’t Come Line. These outcomes 
  
 have fixed odds of 1:1.
  
 • The four Hardways bets: 4, 6, 8 and 10. These outcomes also have fixed odds which depend on the 
  
 number.
  
 • The various one-roll propositions. All of these have fixed odds. These are most like the original
  Outcome 
  
 used for Roulette.
  
 • The six Come-point bets (4, 5, 6, 8, 9 and 10). Each of these has fixed odds. Also, the initial line bet is 
 moved to a point number from the Come Line bet, based on the number shown on the dice. We’ll 
 examine these is some detail, below.
  
 • The Odds bets placed behind the Line bets. These have odds based on the point, not the outcome 
  
 itself. 
 We’ll have to look at these more closely, also.
  
 • The six Placed Numbers have odds are based on the number placed. These outcomes have fixed odds. 
 Once the bet is placed, these bets are resolved when the number is rolled or when a game losing seven 
 is rolled.
  
 • The Buy and Lay bets require a commission payment, called a vigorish, when the bet is placed. The 
 outcomes have simple, fixed odds. As with the placed number bets, these bets are resolved when the 
 number is rolled or when a game losing seven is rolled.
  
 Looking more closely at the bets with payout odds that depend on the point rolled, we note that the Come 
 Line (and Don’t Come) odds bets are moved to a specific number when that point is established. 
  
 Fo
 r example, the player places a Come bet, the dice roll is a 4; the come bet is moved into the box labeled “4”. 
 Any additional odds bet is placed in this box, also.
  
 137",NA
24.2 Overloaded Methods,"We’ll be extending the definition of
  Outcome
 . We don’t want to disturb the simple case of Roulette when we 
 add the more complex case of Craps. We’ll do this with an overloaded constructor; a single method name that 
 two different sets of parameters.
  
 In Python, we use optional parameters to provide default values. We declare the default value as part of the 
 method definition. This works well when we are initializing values to any of the immutable object classes. It 
 doesn’t, however, work well for mutable lists and mappings; these must be handled specially. The following 
 example shows a simple required argument, followed by an optional argument.
  
 class SomeClass: 
  
 def __init__( self, reqArg, optArg=1 ): 
  
  
  
 initialize using reqArg and optArg
  
 Note that Python mutable types (lists, sets, maps) should not be provided as default values for an initializer. 
 This is because one initialization object is created when the class is defined, and all instances will share this 
 singleton initializer object. To avoid this undesirable sharing of an instance of the default value, we have to do 
 the following.
  
 class SomeClass: 
  
 def __init__( self, aList=None ): 
  
  
  
 if aList: 
  
  
  
  
 initialize using aList 
  
  
  
 else: 
  
  
  
  
 default initialization using a fresh []",NA
24.3 Outcome Rework,"Outcome
  contains a single outcome on which a bet can be placed. In Roulette, each spin of the wheel has a 
 number of
  Outcome
 s. For example, the “1” bin has the following winning
  Outcome
 s: “1”, “Red”, “Odd”,“Low”, 
 “Column 1”, “Dozen 1-12”, “Split 1-2”, “Split 1-4”, “Street 1-2-3”, “Corner 1-2-4-5”, “Five Bet”,“Line 1-2-3-4-5-
 6”, “00-0-1-2-3”, “Dozen 1”, “Low” and “Column 1” .
  
 24.3.1 Fields
  
 nam
 e
  
 Holds the name of the
  Outcome
 . Examples include ""1"", ""Red"", ""Pass Line"".
  
 numerator 
  
 Holds the numerator portion of odds for this
  Outcome
 . This is the multiplier in the odds fraction. For 
 right bets in Craps, this is larger than the denominator. For wrong bets, it is smaller than the 
 denominator.
  
 denominator 
  
  
 Holds the denominator portion of odds for this
  Outcome
 . For Roulette, this is always 1.
  
 24.2.
  
 Overloaded Methods
  
 139",NA
24.4 Outcome Deliverables,"There are three deliverables for this exercise.
  
 • The revised
  Outcome
  class that handles more complex odds and returns type double from winAmount().• 
 A class which performs a unit test of the
  Outcome
  class. The unit test should create a couple instances of
  
 Outcome
 , and establish that the winAmount() method works correctly.
  
 • A revision to each subclass of
  Player
  to correctly implement the revised result from winAmount().
  
 Currently, there are six subclasses of
  Player
  :
  Passenger57
 ,
  SevenReds
 ,
  PlayerRandom
 ,
  Player1326
 , 
 PlayerCancellation
 , and
  PlayerFibonacci
 .",NA
24.5 Advanced Exercise,"For the more advanced student, locate or develop a class to work with rational numbers, represented as an 
 integer numerator and denominator. Use this for all stakes, odds and bet payoffs, replacing any double 
 variables.
  
 140
  
 Chapter 24.
  
 Outcome Class",NA
TWENTYFIVE,NA,NA
THROW CLASS,"In Craps, a throw of the dice may change the state of the game. This close relationship between the
  Throw 
 and
  
 CrapsGame
  leads to another chicken-and-egg design problem. We’ll design
  Throw
  in detail, but provide a 
 rough stub for
  CrapsGame
 .
  
 Additionally, this chapter will introduce the subtle issue of over-engineering when doing design work. We’ll 
 revist these issues a number of times in order to provde examples of good design and the issues that can lead 
 to poor design.",NA
25.1 Throw Overview,"The pair of dice can throw a total of 36 unique combinations. These are summarized into fifteen distinct 
 outcomes: the eleven numbers from 2 to 12, plus the four hardways variations for 4, 6, 8 and 10.
  
 In Roulette, the randomized positions on the wheel were called
  Bin
  s and each one had a very simple 
 collection of winning
  Outcome
  s. In Craps, however, the randomized throws of the dice serve three purposes: 
 they resolve simple one-roll proposition bets, they may resolve hardways bets, and they change the game 
 state (which may resolve game bets). From this we can allocate three responsibilities. We’ll look at each of 
 these responsibilities individually.
  
 One-Throw Propositions
 . A
  Throw
  of the dice includes a collection of proposition
  Outcome
 s which are 
 immediate winners. This collection will be some combination of 2, 3, 7, 11, 12, Field, Any Craps, or Horn. For 
 completeness, we note that each throw could also contain one of the 21 hop-bet
  Outcome
 s; however, we’ll 
 ignore the hop bets.
  
 Multi-Throw Propositions
 . A
  Throw
  of the dice may resolve hardways bets (as well as place bets and buy 
 bets). There are three possible conditions for a given throw: some bets may be winners, some bets may be 
 losers, and some bets may remain unresolved. This tells us that a
  Throw
  may be more than a simple collection 
 of winning
  Outcome
 s. A
  Throw
  must also contain a list of losing
  Outcome
 s. For example, any of the two easy 8 
 rolls (6-2 or 5-3) would contain winning
  Outcome
 s for the place-8 bet and buy-8 bet, as well as a losing
  
 Outcome
  for a hardways-8 bet. The hard 8 roll (4-4), however, would contain winning
  Outcome
  s for the 
 place-8 bet, buy-8 bet, and hardways-8 bet
  
 Game State Change
 . Most importantly, a
  Throw
  of the dice can lead to a state change of the
  Game
 . This may 
 resolve game-level bets. From the
  Craps Game
 , we see that the state changes depend on both the
  Game 
 state 
 plus the kind of
  Throw
 . The rules identify the following species of
  Throw
 .
  
 •
  Craps
 . These are throws of 2, 3 or 12. On a come-out roll, this is an immediate loss. On any other 
  
 roll, this 
 is ignored. There are 4 of these throws.
  
 •
  Natural
 . This is a throw of 7. On a come-out roll, this is an immediate win. On any other roll, this 
  
 is an 
 immediate loss and a change of state. There are 6 of these throws.
  
 141",NA
25.2 Throw Design,"class Throw
 ()
  
 Throw
  is the superclass for the various throws of the dice. 
 numbers, based on the rules for Craps.
  
 Each subclass is a different grouping of the
  
 142
  
 Chapter 25.
  
 Throw Class",NA
25.3 Natural Throw Design,"class NaturalThrow
 () 
  
 Natural Throw is a subclass of
  Throw
  for the natural number, 7.
  
 25.3.1 Constructors
  
 __init__
 (
 self, d1, d2
 ) 
  
  
 Parameters
  
  
 •
  d1
  – The value of one die
  
  
 •
  d2
  – The value of the other die
  
 25.3.
  
 Natural Throw Design
  
 143",NA
25.4 Craps Throw Design,"class CrapsThrow
 () 
  
 Craps Throw is a subclass of
  Throw
  for the craps numbers 2, 3 and 12.
  
 25.4.1 Constructors
  
 __init__
 (
 self, d1, d2
 ) 
  
  
  
 Parameters
  
  
  
 •
  d1
  – The value of one die
  
  
  
 •
  d2
  – The value of the other die 
  
  
 Creates this throw. The constraint is that
  d
 1 +
  d
 2
  ∈ {
 2
 ,
  3
 ,
  12
 }
 . If the constraint is not satisfied, 
 simply raise an exception.
  
 This uses the superclass constructor to add appropriate
  Outcome
 s for a throw of craps.
  
 25.4.2 Methods
  
 hard
 (
 self
 ) 
  
  
 The craps numbers are never part of “hardways” bets. This method always returns false.
  
 updateGame
 (
 self, game
 ) 
  
  
 Parameter
  game
  (CrapsGame) – the Game to be updated based on this throw.
  
 Calls the craps() method of a game
  Game
 . This may change the game state and resolve bets.",NA
25.5 Eleven Throw Design,"class ElevenThrow
 () 
  
 Eleven Throw is a subclass of
  Throw
  for the number, 11. This is special because 11 has one effect on a come-
 out roll and a different effect on point rolls.",NA
25.6 Point Throw Design,"class PointThrow
 () 
  
 Point Throw is a subclass of
  Throw
  for the point numbers 4, 5, 6, 8, 9 or 10.
  
 25.6.1 Constructors
  
 __init__
 (
 self, d1, d2
 ) 
  
  
  
 Parameters
  
  
  
 •
  d1
  – The value of one die
  
  
  
 •
  d2
  – The value of the other die 
  
  
 Creates this throw. The constraint is that
  d
 1 +
  d
 2
  ∈ {
 4
 ,
  5
 ,
  6
 ,
  8
 ,
  9
 ,
  10
 }
 . If the constraint is not 
 satisfied, simply raise an exception.
  
 This uses the superclass constructor to add appropriate
  Outcome
 s for a throw of craps.
  
 25.6.2 Methods
  
 hard
 (
 self
 ) 
  
  
 Eleven is odd and never part of “hardways” bets. This method always returns false.
  
 Returns true if d1 is equal to d2. This helps determine if hardways bets have been won or lost.
  
 updateGame
 (
 self, game
 ) 
  
  
 Parameter
  game
  (CrapsGame) – the Game to be updated based on this throw.",NA
25.7 Craps Game Design,"class CrapsGame
 () 
  
 CrapsGame
  is a preliminary design for the game of Craps. This initial design contains the interface used by the
  
 Throw
  class hierarchy to implement game state changes.
  
 25.7.1 Fields
  
 point 
  
  
 The current point. This will be replaced by a proper
  State
  design pattern.
  
 25.7.2 Constructors
  
 __init__
 (
 self
 ) 
  
  
 Creates this Game. This will be replaced by a constructor that uses
  Dice
  and CrapsTable.
  
 25.7.3 Methods
  
 craps
 (
 self
 ) 
  
  
 Resolves all current 1-roll bets.
  
 If the point is zero, this was a come out roll: Pass Line bets are an immediate loss, Don’t Pass Line 
 bets are an immediate win.
  
 If the point is non-zero, Come Line bets are an immediate loss; Don’t Come Line bets are an 
 immediate win.
  
 The state doesn’t change.
  
 A future version will delegate responsibility to the craps() method of a current state object.
  
 natural
 (
 self
 ) 
  
  
 Resolves all current 1-roll bets.
  
 If the point is zero, this was a come out roll: Pass Line bets are an immediate win; Don’t Pass Line 
 bets are an immediate loss.
  
 If the point is non-zero, Come Line bets are an immediate win; Don’t Come bets are an immediate 
 loss; the point is also reset to zero because the game is over.
  
 Also, hardways bets are all losses.
  
 A future version will delegate responsibility to the natural() method of a current state object.
  
 eleven
 (
 self
 ) 
  
  
 Resolves all current 1-roll bets.
  
 If the point is zero, this is a come out roll: Pass Line bets are an immediate win; Don’t Pass Line 
 bets are an immediate loss.
  
 146
  
 Chapter 25.
  
 Throw Class",NA
25.8 Throw Deliverables,"There are eleven deliverables for this exercise.
  
 • A stub class for
  CrapsGame
  with the various methods invoked by the throws. The design information 
 includes details on bet resolution that doesn’t need to be fully implemented at the present time. For this 
 stub class, the change to the point variable is required for unit testing. The other information should be 
 captured as comments and output statements that help confirm the correct behavior of the game.
  
 • The
  Throw
  superclass, 
  
 PointThrow
 .
  
 and the four subclasses:
  
 CrapsThrow
 ,
  
 NaturalThrow
 ,
  
 ElventThrow,
  
 • Five classes which perform unit tests on the various classes of the
  Throw
  class hierarchy.
  
 25.8.
  
 Throw Deliverables
  
 147",NA
TWENTYSIX,NA,NA
DICE CLASS,"Unlike Roulette, where a single
  Bin
  could be identified by the number in the bin, dice use a pair of numbers. In 
 this chapter, we design
  Dice
 , as well as designing an inner class that is used only to make a single key out of a 
 composite object.",NA
26.1 Dice Overview,"The dice have two responsibilities: they are a container for the
  Throw
  s and they pick one of the
  Throw
 s at 
 random.
  
 We find that we have a potential naming problem: both a
  Wheel
  and the
  Dice
  are somehow instances of a 
 common abstraction. Looking forward, we may wind up wrestling with a deck of cards trying to invent a 
 common nomenclature for the classes. They create random events, and this leads us to a possible superclass: 
 Randomizer. 
  
 Rather than over-engineer this, we’ll hold off on adding this design element until we find 
 something else that is common among them. See
  Soapbox on Over-Engineering
  for some additional opinions 
 on this subject.
  
 Container
 . Since the
  Dice
  have 36 possible
  Throw
 s, it is a collection. We can review our survey of the 
 collections in
  Design Decision – Choosing A Collection
  for some guidance here. In this case, we note that the 
 choice of
  Throw
  can be selected by a random numeric index.
  
 For Python programmers, this makes the a list very appealing.
  
 After selection a collection type, we must then deciding how to index each
  Throw
  in the
  Dice
  collection. Recall 
 that in Roulette, we had 38 numbers: 1 to 36, plus 0 and 00. By using 37 for the index of the
  Bin 
 that 
 contained 00, we had a simple integer index for each
  Bin
 .
  
 For Craps it seems better to use a two-part index with the values of two independent dice.
  
 Index Choices
 . In this case, we have two choices for computing the index into the collection,
  
 • We can rethink our use of a simple sequential structure. 
  
 If we use a Map, we can use an object 
  
 representing the pair of numbers as an index instead of a single int value.
  
 • We have to compute a unique index position from the two dice values.
  
 Decision Forces
 . There are a number of considerations to choosing between these two representations.
  
 1. If we create a new class to contain each unique pair of integers, we can then use that object to be the 
  
 index for a Map. The Map associates this “pair of numbers” object with its
  Throw
 .
  
 In Python, a tuple does this job nicely. We don’t need to define a whole new class.
  
 We can pick one of the existing
  NumberPair
  objects at random from the collection of keys for the Map 
 that contains the individual
  Throw
 s.
  
 149",NA
26.2 Throw Rework,"We need to update
  Throw
  to return an appropriate key object.
  
 There are two parts to this. First, we need a “getter” to return the key.
  
 We’ll add a method to
  Throw
  to return the tuple that is a key for this
  Throw
 .
  
 getKey
 (
 self
 ) 
  
 Second, we need to update the
  Throw
  constructor to create the key when the
  Throw
  is being built. This will 
 allow all parts of the application to share references to a single instance of the key.",NA
26.3 NumberPair Design,"class NumberPair
 () 
  
 In Python, it’s often easiest to use a “named tuple” rather than use a simple tuple.
  
 from
  collections
  import
  namedtuple 
  
 NumberPair
  =
  namedtuple(
 'NumberPair'
 , [
 'd1'
 ,
 'd2'
 ])
  
 This can make the tuple slightly easier to work with.
  
 26.3.1 Fields
  
 d1
  
 Contains the face of one die.",NA
26.4 Dice Design,"class Dice
 ()
  
 Dice
  contains the 36 individual throws of two dice, plus a random number generator. It can select a
  Throw 
 at 
 random, simulating a throw of the Craps dice.
  
 26.4.1 Fields
  
 throws 
  
  
 This is a dict that associates a
  NumberPair
  with a
  Throw
 .
  
 rng
  
 An instance of random.Random
  
 Generates the next random number, used to select a
  Throw
  from the throws collection.
  
 26.4.2 Constructors
  
 __init__
 (
 self, rng=None
 ) 
  
  
 Build the dictionary of
  Throw
  instances.
  
 Parameter
  rng
  (random.Random) – The random number generator to use.
  
 At the present time, this does not do the full initialization of all of the
  Throw
 s. We’re only building 
 the features of
  Dice
  related to random selection. We’ll extend this class in a future exercise.
  
 26.4.3 Methods
  
 addThrow
 (
 self, throw
 )
  
 Parameter
  throw
  (Throw) – The
  Throw
  to add.
  
 Adds the given
  Throw
  to the mapping maintained by this instance of
  Dice
 . The key for this 
 Throw
  is 
 available from the
  Throw.getKey()
  method.
  
 next
 (
 self
 ) 
  
  
 Returns the randomly selected
  Throw
 .
  
 First, get the list of keys from the throws.
  
 The random.Random.choice() method will select one of the available keys from the the list.
  
 This is used to get the corresponding
  Throw
  from the throws Map.
  
 26.4.
  
 Dice Design
  
 151",NA
26.5 Dice Deliverables,"There are three deliverables for this exercise. In considering the unit test requirements, we note that we will 
 have to follow the design of the
  Wheel
  class for convenient testability: we will need a way to get a particular 
 Throw
  from the
  Dice
 , as well as replacing the random number generator with one that produces a known 
 sequence of numbers.
  
 • The
  Dice
  class.
  
 • A class which performs a unit test of building the
  Dice
  class. The unit test should create several instances 
 of
  Outcome
 , two instances of
  Throw
 , and an instance of
  Dice
 . The unit test should establish that
  Throw
 s 
 can be added to the
  Dice
 .
  
 • A class which performs a demonstration of selecting non-random values from the
  Dice
  class. By setting a 
 particular seed, the
  Throw
 s will be returned in a fixed order. To discover this non-random order, a 
 demonstration should be built which includes the following.
  
 1. Create several instances of
  Outcome
 .
  
 2. Create two instances of
  Throw
  that use the available
  Outcome
 s.
  
 3. Create one instance of
  Dice
  that uses the two
  Throw
 s.
  
 4. A number of calls to the
  next()
  method should return randomly selected
  Throw
 s.
  
 Note that the sequence of random numbers is fixed by the seed value. The default constructor for a 
 random number generator creates a seed based on the system clock. If your unit test sets a particular 
 seed value, you will get a fixed sequence of numbers that can be used to get a consistent result.",NA
26.6 Dice Optimization,"First, we note that premature optimization is a common trap.
  
  
 “We should forget about small efficiencies, say about 97% of the time: premature optimization 
  
 is 
 the root of all evil. 
  
 Yet we should not pass up our opportunities in that critical 3%. 
  
 A 
  
 good programmer will not be lulled into complacency by such reasoning, he will be wise to look 
  
 carefully at the critical code; but only after that code has been identified”
  
  
  
  
 —Donald Knuth
  
 “Structured Programming with Goto Statements”. Computing Surveys 6:4 (1974), 261-301. In this 
 exercise, it appears that the
  NumberPair
  is superfluous.
  
 We can work directly with a list of Throws, bypassing any mapping between
  NumberPair
  and
  Throw
 .
  
 152
  
 Chapter 26.
  
 Dice Class",NA
TWENTYSEVEN,NA,NA
THROW BUILDER CLASS,"This chapter identifies some subtleties of bets in Craps, and proposes some rather involved design rework to 
 resolve the issues that are raised. Specifically, we didn’t allow for an
  Outcome
  to have odds based on a throw 
 of the dice. We’ll need to add this feature carefully.
  
 We’ll present two solutions: “Design Heavy” and “Design Light”. While we recommend “Design Heavy”, we 
 find that many programmers and project managers object to the apparent over-engineering of the approach. 
 We have found that it is almost impossible justify the design heavy approach. See our
  Soapbox on Justifi-cation
  
 for more on this common blind spot. Instead, we provide the “light” alternative, which will become 
 increasingly unwieldy throughout this part. At some point, we will eventually be forced to adopt the design 
 heavy approach.
  
 We’ll present sidebars on the proper design of subclasses and the proper architecture for the packages that 
 make up an application. Additionally, we’ll provide a brief FAQ on the design issues raised.",NA
27.1 Throw Builder Overview,"Enumerating each
  Outcome
  in the 36
  Throw
 s could be a tedious undertaking. It may be slightly simpler to 
 hand-code the various combinations., For complete flexibility, we’ll design a
  Builder
  to enumerate all of the 
 Throw
 s and their associated list of
  Outcome
 s. This will build the
  Dice
 , finishing the elements we deferred 
 from
  Dice Class
 .
  
 The 36 ways the dice fall can be summarized into 15 kinds of
  Throw
 , with a fixed distribution of probabilities. 
 We could develop a
  Builder
  class that enumerates the 36 individual
  Throw
 s, assigning the appropriate 
 attribute values to each object. An alternative is for a
  Builder
  class to step through the 15 kinds of
  Throw
 s, 
 creating the proper number of instances of each kind. It seems slightly simpler to examine each pair of dice 
 and determine which kind of
  Throw
  to build.
  
 The proposition bets define eight one-roll
  Outcome
 s that need to be assigned to the various
  Throw
  instances 
 we are building. We will share references to the following
  Outcome
  objects among the
  Throw
 s:
  
 • The number 2, with 30:1 odds.
  
 • The number 3, with 15:1 odds.
  
 • The number 7, with 4:1 odds.
  
 • The number 11, with 15:1 odds.
  
 • The number 12, with 30:1 odds.
  
 • The “any craps” outcome, with 7:1 odds. This belongs to throws for 2, 3 and 12.
  
 • The “horn” outcome, with two sets of odds. This belongs to throws for 2, 3, 11 and 12. For 2 and 12, 
  
 the odds are 27:4; for 3 and 11, the odds are 3:1.
  
 155",NA
27.2 Outcomes with Variable Odds,"Our detailed examination of the bets has turned up an interesting fact about Field bets and Horn bets: these 
 bets also have payoffs that depend on the number on the dice. In our earlier
  Outcome Class
 , we missed this 
 nuance, and did not provide for a Dice.winAmount() method that depends on the
  Dice
 . We’ll present the 
 solution to this as a fairly formal procedure that we find helps to resolve these kind of design issues.
  
 Problem Statement
 . Unlike the Pass Line and Come Line bets, Field bets and Horn bets have payoffs that 
 depend on the number currently showing on the dice. Unlike Come Line bets, these bets are not moved on the 
 table to a new
  Outcome
  when the point is established. How do we compute the win amount for Field and 
 Horn bets?
  
 Context
 . Our design objective is to have a
  Bet
  reference a single
  Outcome
  object. The
  Bet
  is compared with a 
 Set of winning
  Outcome
 s. We’d like to have a single horn
  Outcome
  object and field
  Outcome
  object shared by 
 multiple instances of
  Throw
  to make this comparison work in a simple, general way.
  
 As an example, the player can place a bet on the Field
  Outcome
 , which is shared by all of the field numbers (2, 
 3, 4, 9, 10, 11, 12). The problem we have is that for 2 and 12, the outcome pays 2:1 and for the other field 
 numbers it pays 1:1, and our design only has a single set of payout odds.
  
 Forces
 . In order to handle this neatly, we have two choices.
  
 • One choice is to have two
  Outcome
 s bundled into a single bet. This allows us to create a
  Bet
  that includes 
 both the low-odds field outcome (3, 4, 9, 10 and 11) plus the high-odds field outcome (2 and 12). One of 
 the nice features of this is that it is a small expansion to
  Bet
 . However, further research shows us that 
 there are casino-specific variations on the field bet, including the possibility of three separate
  Outcome
 s 
 for those casinos that pay 3:1 on 12. This makes construction of the
  Bet
  rather
  
 156
  
 Chapter 27.
  
 Throw Builder 
 Class",NA
27.3 Refactoring The Outcome Hierarchy,"Consequent Problem: Class Hierarchy
 . While it appears simplest to add a “variable odds” subclass of
  
 Outcome
  with a new method that uses the number on the dice, we find that there are some additional 
 considerations.
  
 Our design depends on polymorphism among objects of the
  Outcome
  class: all instances have the same 
 interface. In order to maintain this polymorphism, we need to add this new method to the superclass. The 
 superclass version of the new winAmount() based on the Craps
  Throw
  can return an answer computed by the 
 original winAmount() method. We can then override this in a subclass for Field and Horn bets in Craps.
  
 An alternative is to break polymorphism and create a Craps-specific
  Outcome
  subclass. This would ripple out 
 to
  Throw
 ,
  Bet
 ,
  Table
 ,
  Player
 . This is an unpleasant cascade of change, easily avoided by assuring that the 
 entire
  Outcome
  class hierarchy is polymorphic.
  
 Solution
 . Our second design decision, then, is to insert the change at the top of the
  Outcome
  class hierarchy, 
 and override this new winAmount() method in just the few subclasses that we use to create Horn and Field 
 Outcome
 s.
  
 • The Horn bet’s winAmount() method applies one of two odds, based on the event’s value.
  
 • The Field bet may have any of two or three odds, depending on the casino’s house rules. It is difficult to 
 identify a lot of commonality between Horn bets and Field bets. Faced with these irreconcilable 
 differences, we will need two different winAmount() methods, leading us to create two subclasses: 
 OutcomeField
  and
  OutcomeHorn
 .
  
 The differences are minor, merely a list of numbers and odds. However, our design objective is to minimize if-
 statements. We prefer many simple classes over a single class with even a moderately complex method.
  
 Consequent Problem: 
  
 Dependencies
 . 
  
 We’ve 
  
 decided 
  
 to 
  
 add 
  
 a
  
 Outcome.winAmount()
 ; specifically, we’ve made it dependent on a
  Throw
  object.
  
 for Craps, it makes very little sense for Roulette.
  
 dependency to 
  
 the
  
 While this works well
  
 27.3.
  
 Refactoring The Outcome Hierarchy
  
 157",NA
27.4 Soapbox on Subclasses,"Designers new to OO techniques are sometimes uncomfortable with the notion of highly-
 specialized subclasses. We’ll touch on two reasons why specialized subclasses are far superior to 
 the alternatives.
  
  
 One approach to creating common features is to add nested if-statements instead of creating 
 subclasses. In our example, we might have elected to add if-statements that would determine if 
 this was a variable-odds outcome, and then determine which of the available odds would be used. 
 The first test (for being a variable-odds outcome) is, in effect, a determination of the subclass of
  
 Outcome
 . Since an object’s membership in a class determines the available methods, there’s no 
 reason to
  test
  for membership. In most cases, a test for membership in a class is also done at 
 construction time. If we use that initial decision to select the subclass (with appropriate subclass-
 specific methods) we do not repeat that decision every time a method is invoked. This is the 
 efficiency rationale for introducing a subclass to handle these special cases.
  
 The more fundamental reason is that specialized subclasses usually represent distinct kinds of 
 real-world things, which we are modeling in software-world. 
  
 In contrast, a procedural view-
 point is that the variant behavior is a special case: a condition or situation that requires unique 
 processing. This view often confuses the implementation of the special case (via an if-statement) 
 with the nature of the specialization. In our case, we have a number of distinct things, some
  
 158
  
 Chapter 27.
  
 Throw Builder 
 Class",NA
27.5 Soapbox on Architecture,"There are a number of advanced considerations behind the Design Heavy section. 
  
 This is a 
 digression on architecture and
  packages of classes
 . While this is beyond the basics of OO design, it 
 is a kind of justification for the architecture we’ve chosen.
  
 A good design balances a number of forces. One example of this is our use of a class hierarchy to 
 decompose a problem into related class descriptions, coupled with the collaboration among 
 individual objects to compose the desired solution. 
  
 The desired behavior emerges from this 
 tension between decomposition of the class design and composition of the objects to create the 
 desired behavior.
  
 Another example of this decomposition vs. composition is the organization of our classes into 
 packages. We have, in this book, avoided discussion of how we package classes. It is a more subtle 
 aspect of a good design, consequently we find it challenging to articulate sound principles behind 
 the layers and partitions of a good collection of packages. There are some design patterns that 
 give us packaging guidance, however.
  
 Design Patterns
 . 
  
 One packaging pattern is the
  5-Layer Design
 , which encourages us to 
 separate our design into
  layers
  of
  view
 ,
  control
 ,
  model
 ,
  access
  and
  persistence
 . For our current 
 application, the view is the output log written to System.out, the control is the overall main method 
 and the Simulation class, the model is the casino game model. We don’t have any data access or 
 data persistence issues, but these are often implemented with
  JDBC
  and a
  relational database
 .
  
 While one of the most helpful architectural patterns, this version of the
  5-Layer Design
  still leaves 
 us with some unsatisfying gaps. For example, common or
  infrastructure
  elements don’t have a 
 proper home. They seem to form another layer (or set of layers). Further, the model layer often 
 decomposes into domain elements, plus elements which are specializations focused on unique 
 features of the business, customer, vendor or product.
  
 Another packaging pattern is the
  Sibling Partition
 , which encourages us to separate our 
 application-specific elements to make them parallel
  siblings
  of a superclass so that we can more
  
 27.5.
  
 Soapbox on Architecture
  
 159",NA
27.6 Throw Builder Questions and Answers,"Why is do we need
  RandomEvent
 ? Isn’t this overengineering?
  
 Clean separation between Craps and Roulette isn’t necessary, but is highly desirable. We pre-fer 
 not to have Roulette classes depend in any way on Craps classes. Instead of having them entangled, 
 we factor out the entanglement and make a new class from this. This is also called reducing the 
 coupling between classes. 
  
 We prefer the term “entanglement” because it has a 
 suitably negative connotation.
  
 Didn’t we notice the need for this
  RandomEvent
  class back in
  Soapbox on Overengineering
 ? Why was it a bad 
 idea then and a good idea now?
  
 Some experienced designers immediately notice this kind of commonality between
  Throw
  and
  
 Bin
 , and can handle it without getting badly side-tracked. However, some beginning designers can 
 spend too much time searching for this kind of commonality. We’ve seen examples of improper 
 factoring where classes were combined in an early phase of design, only to lead to expensive 
 rework when distinctions were uncovered later, invalidating large parts of the design. We prefer 
 to wait until we are sure we’ve understood the problem and the solution before committing to a 
 particular class design.
  
 Isn’t the goal to leave Roulette alone? Isn’t the ideal to extend the design with subclasses, leaving the original 
 design in place?
  
 Yes, the goal is to extend a design via subclasses. But, this is only possible if the original design is 
 suitable for extension by subclassing. We find that it is very difficult to create a design that both 
 solves a problem and can be extended to solve a number of related problems.
  
 Note that a general, extensible design has two independent feature sets. On one level it solves a 
 useful problem. Often, this is a difficult problem in its own right, and requires considerable skill 
 merely to ferret out the actual problem and craft a usable solution within budget, time and skill 
 constraints.
  
 On another, deeper level, our ideal design can be extended. This is a different kind of problem that 
 requires us to consider the various kinds of
  design mutations
  that may occur as the software is 
 maintained and adapted. This requires some in-depth knowledge of the problem domain. We 
 need to know how the current problem is a specialization of other more general problems. We 
 also need to note how our solution is only one of many solutions to the current problem. We have 
 two dimensions of generalization: problem generalization as well as solution generalization.
  
 Our initial design for roulette just barely provided the first level of solution. We didn’t make any 
 effort to plan for generalization. The “Design Heavy” solution generalizes Roulette to make it more 
 suitable for Craps, also. Looking forward, we’ll have to make even more adjustments before we 
 have a very tidy, general solution.",NA
27.7 Soapbox on Justification,"It is very difficult to justify design rework. Most managers and designers share a common blind-
 spot on the amount of evidence required to justify rework. The conversations have the following 
 form.
  
 Architect
 . We need to disentangle Roulette and Craps so that Craps is not a subclass of Roulette. 
 I’ve got a revised design that will take
  X
  hours of effort to implement.
  
 Manager
 . I’ll need some justification. Why do we have to fix it?
  
 27.6.
  
 Throw Builder Questions and Answers
  
 161",NA
27.8 Design Light,"In order to get the Craps game to work, we can minimize the amount of design. This minimal rework is a 
 revision to
  Outcome
 .
  
 This is followed by Common Design: the two subclasses of
  Outcome
  (
 OutcomeField
 , and
  OutcomeHorn
 ), and 
 the initializer for
  Dice
 .
  
 This minimal design effort has one unpleasant consequence: Roulette’s
  Outcome
  instances will depend on the 
 Craps-specific
  Throw
  class. This entangles Roulette and Craps around a feature that is really a special case for 
 Craps only. This kind of entanglement often limits our ability to successfully package and reuse these classes.
  
 27.8.1 Outcome Rework
  
 The class
  Outcome
  needs a method to compute the win amount based on a
  Throw
 .
  
 In Python, we use optional parameters to achieve the same degree of flexibility.
  
 winAmount
 (
 self, throw=None
 ) 
  
 Returns the product this
  Outcome
 ‘s odds numerator by the given amount, divided by the odds denom-
 inator.
  
 Parameter
  throw
  (Throw) – An optional
  Throw
  that determines the actual odds to use. If 
  
 not 
 provided, this
  Outcome
 ‘s odds are used.
  
 For Craps Horn bet and Field bets, a subclass will override this method to check the specific value 
 of the throw and compute appropriate odds.",NA
27.9 Design Heavy,"In order to produce a solution that has a better architecture with more reusable components, we need to do 
 some additional generalization. This design effort disentangles Roulette and Craps; they will not share the 
 Throw
  class that should only be part of Craps. Instead, the highly reused
  Outcome
  class depends only on a 
 new superclass,
  RandomEvent
 , which is not specific to either game.
  
 Given the new generalization,
  RandomEvent
 , we can rework the
  Outcome
  to use this for computing win 
 amounts. We will have to rework
  Bin
 ,
  Wheel
 , and
  Throw
  to make proper use of this new superclass.
  
 Then we can move to the Common Design features: the craps-specific subclasses (
 OutcomeField
 , and 
 OutcomeHorn
 ), and the initializer for
  Dice
 .
  
 27.9.1 RandomEvent class
  
 class RandomEvent
 ()
  
 27.8.
  
 Design Light
  
 163",NA
27.10 Common Design,"27.10.1 OutcomeField Design
  
 class OutcomeField
 ()
  
 OutcomeField
  contains a single outcome for a field bets that has a number of different odds, and the odds used 
 depend on a
  RandomEvent
 .
  
 164
  
 Chapter 27.
  
 Throw Builder 
 Class",NA
27.11 Throw-Builder Deliverables,"There are two deliverables for the light version of this exercise.
  
 • Rework the
  Outcome
  class to add the new winAmount() method that uses a
  Throw
 .
  
 • Rework the
  Outcome
  class unit test to exercise the new winAmount() method that uses a
  Throw
 . For all 
 current subclasses of
  Outcome
 , the results of both versions of the winAmount() method produce the 
 same results.
  
 There are five deliverables for the heavy version of this exercise.
  
 • Create the
  RandomEvent
  class.
  
 • Rework the
  Bin
  class to be a subclass of
  RandomEvent
 . The existing unit tests for
  Bin
  should continue 
  
 to work correctly.
  
 • Rework the
  Throw
  class to be a subclass of
  RandomEvent
 . The existing unit tests should continue to 
  
 work correctly.
  
 • Rework the
  Outcome
  class to add the new winAmount() method that uses a
  RandomEvent
 .
  
 • Rework the
  Outcome
  class unit test to exercise the new winAmount() method that uses a
  RandomEvent
 .
  
 For all current subclasses of
  Outcome
 , the results of both versions of the winAmount() method produce 
 the same results.
  
 There a six common deliverables no matter which approach you take.
  
 • Create the
  OutcomeField
  class.
  
 • Create a unit test for the
  OutcomeField
  class. Two instances of
  Throw
  are required: a 2 and a 3. This 
  
 should confirm that there are different values for winAmount() for the two different
  Throw
  instances.• 
 Create the
  OutcomeHorn
  class.
  
 • Create a unit test for the
  OutcomeHorn
  class. Two instances of
  Throw
  are required: a 2 and a 3. This 
  
 should confirm that there are different values for winAmount() for the two different
  Throw
  instances.• 
 Create the
  ThrowBuilder
 . This was our objective, after all.
  
 • Rework the unit test of the
  Dice
  class. The unit test should create and initialize a
  Dice
 . It can use 
  
 the 
 getThrow() method to check selected
  Throw
 s for the correct
  Outcome
 s.
  
 The correct distribution of throws is as follows. 
 ThrowBuilder
 .
  
 Throw 
  
 2 
  
 3 
  
 easy 4 
  
 hard 4 
  
 5 
  
 easy 6 
  
 hard 6 
  
 7 
  
 easy 8 
  
 hard 8 
  
 9 
  
 easy 10 
 hard 10 
 11 
  
 12
  
 Frequency 
 1 
  
 2 
  
 2 
  
 1 
  
 4 
  
 4 
  
 1 
  
 6 
  
 4 
  
 1 
  
 4 
  
 2 
  
 1 
  
 2 
  
 1
  
  
 This information will help confirm the results of
  
 166
  
 Chapter 27.
  
 Throw Builder 
 Class",NA
TWENTYEIGHT,NA,NA
BET CLASS,"This chapter will examine the
  Bet
  class, and its suitability for the game of Craps. We’ll expand the design to 
 handle additional complications present in real casino games.",NA
28.1 Bet Overview,"A
  Bet
  is an amount that the player has wagered on a specific
  Outcome
 . This is a simple association of an 
 amount, an
  Outcome
 , and a specific
  Player
 .
  
 When considering the various line bet outcomes (Pass Line, Come Line, Don’t Pass and Don’t Come), we noted 
 that when a point was established the bet was either a winner or a loser, or it was moved from the line to a 
 particular number based on the throw of the dice. We’ll need to add this responsibility to our existing 
 definition of
  Bet
 . This responsibility can be implemented as a setOutcome() method that leaves the amount 
 intact, but changes the
  Outcome
  from the initial Pass Line or Come Line to a specific point outcome.
  
 A complexity of placing bets in Craps is the commission (or vigorish) required for Buy bets and Lay bets. This 
 is a 5% fee, in addition to the bet amount. A player puts $21 down, which is a $20 bet and a $1 commission. 
 We’ll need to add a a commission or vig responsibility to our definition of
  Bet
 .
  
 This price to place a bet generalizes nicely to all other bets. For most bets, the price is simply the amount of 
 the bet. For Buy bets, the price is 5% higher than the amount of the bet; for Lay bets, the price depends on the 
 odds. This adds a new method to
  Bet
  that computes the price of the bet. This has a ripple effect throughout 
 our
  Player
  hierarchy to reflect this notion of the price of a bet. We will have to make a series of updates to 
 properly deduct the price from the player’s stake instead of deducting the amount of the bet.
  
 There are two parts to creating a proper Craps bet: a revision of the base
  Bet
  to separate the price from the 
 amount bet, and a
  CommissionBet
  subclass to compute prices properly for the more complex Craps bets.",NA
28.2 Bet Rework,"Bet
  associates an amount and an
  Outcome
 . The
  Game
  may move a
  Bet
  to a different
  Outcome
  to reflect a 
 change in the odds used to resolve the
  Bet
 . In a future round of design, we can also associate a it with a 
 Player
 .
  
 28.2.1 Methods
  
 setOutcome
 (
 self, outcome
 )
  
 Parameter
  outcome
  (Outcome) – The new outcome for this bet amount
  
 167",NA
28.3 CommissionBet Design,"class CommissionBet
 () 
  
 CommissionBet
  is a
  Bet
  with a commission payment (or vigorish) that determines the price for placing the 
 bet.
  
 28.3.1 Fields
  
 vig
  
 Holds the amount of the vigorish. This is almost universally 5%.
  
 28.3.2 Methods
  
 price
 (
 self
 ) 
  
  
 Computes the price for this bet. There are two variations: Buy bets and Lay bets.
  
 A Buy bet is a right bet; it has a numerator greater than or equal to the denominator (for example, 
 2:1 odds, which risks 1 to win 2), the price is 5% of the amount bet. A $20 Buy bet has a price of 
 $21.
  
 A Lay bet is a wrong bet; it has a denominator greater than the numerator (for example, 2:3 odds, 
 which risks 3 to win 2), the price is 5% of 2/3 of the amount. A $30 bet Layed at 2:3 odds has a 
 price of $31, the $30 bet, plus the vig of 5% of $20 payout.",NA
28.4 Bet Deliverables,"There are three deliverables for this exercise.
  
 • The revised
  Bet
  class.
  
 • The new
  CommissionBet
  subclass. This computes a price that is 5% of the bet amount.
  
 • A class which performs a unit test of the various
  Bet
  classes. The unit test should create a couple 
 instances of
  Outcome
 , and establish that the winAmount() and price() methods work correctly. It 
 should also reset the
  Outcome
  associated with a
  Bet
  
 We could rework the entire
  Player
  class hierarchy for Roulette to compute the
  Bet
 ‘s price in the placeBets(), 
 and deduct that price from the player’s stake. 
  
 For Roulette, however, this subtlety is at 
 the fringe of over-engineering, as no bet in Roulette has a commission.
  
 168
  
 Chapter 28.
  
 Bet Class",NA
TWENTYNINE,NA,NA
CRAPS TABLE CLASS,"In Roulette, the table was a passive repository for
  Bet
 s. 
  
 In Craps, however, the table and game must 
 collaborate to accept or reject bets based on the state of the game. This validation includes rules based on the 
 total amount bet as well as rules for the individual bets.
  
 In
  Throw Class
 , we roughed out a stub version of
  CrapsGame
  that could be used to test
  Throw
 . In this section, 
 we will extend this stub with additional features required by the table.",NA
29.1 Craps Table Overview,"The
  Table
  is where the
  Bet
 s are placed. The money placed on
  Bet
 s on the
  Table
  is “at risk”; these bets either 
 win an amount based on the odds, or lose the amount placed by the player.
  
 • The Don’t Come and Don’t Pass bets may be returned, called a “push”.
  
 • The Buy and Lay bets include a commission (or vigorish) to place the bet; the commission is lost 
  
 money; 
 the balance of the bet, however, may win or lose.
  
 The responsibility for a push is something we can allocate to
  Game
 , the commission price belongs to
  Bet
 .
  
 Some
  Bet
 s (specifically Pass, Don’t Pass, Come and Don’t Come) may have their
  Outcome
  changed. The use 
 case works like this.
  
 1. The bet is created by the Player with one
  Outcome
 , for example, “Pass”. The Table accepts this bet.
  
 2. That bet may be resolved as an immediate winner or loser. The Game and Throw will determine if 
  
 the Bet is a winner as placed.
  
 More commonly, the
  Bet
  may be changed to a new
  Outcome
 , possibly with different odds.
  
 In a casino, the chips initially placed on Come Line and Don’t Come bets are relocated to a point number 
 box to show this change. In the case of Pass Line and Don’t Pass bets, the “On” marker is placed on the 
 table to show an implicit movement of all of those line bets.
  
 The change is the responsibility of the
  Game
 ; however, the
  Table
  must provide an iterator over the line bets 
 that the
  Game
  will move.
  
 Game State
 . Each change to the game state changes the allowed bets as well as the active bets. When the 
 point is off, most of the bets on the table are not allowed, and some others are inactive, or not “working”.
  
 When a point is established, all bets are allowed, and all bets are active. We’ll examine the rules in detail, 
 below.
  
 The
  Table
  must be able to reject bets which are inappropriate for the current
  Game
  state.
  
 169",NA
29.2 Design Decision – Table vs. Game Responsibility,"We’ve identified two responsibilities that are part of handling Craps:
  
 • changing
  Bet
 s,
  
 • inactivating outcomes and rejecting bets based on
  Game
  state.
  
 Clearly, these require additional collaboration between
  Game
  and
  Table
 . We will have to add methods to 
 CrapsGame
  that will allow or deny some bets, as well as methods that will active or deactive some bets.
  
 We have to choose where in the class hierarchy we will retrofit this additional collaboration.
  
 Problem
 . Should we put these new responsibilities at a high-enough level that we’ll add table and game 
 collaboriation to the
  Table
  class used for Roulette?
  
 Forces
 . If we do add this for Roulette, we could simply return true from the method that validates the allowed 
 bets, since all bets are allowed in Roulette.
  
 However, our overall application design does not depend on all subclasses of
  Game
  and
  Table
  being polymor-
 phic; we will never mix and match different combinations of Craps Table and Roulette Game.
  
 Solution
 . Because we don’t need polymorphism between Craps and Roulette, we can create a subclass of 
 Table
  with a more complex interface and leave Roulette untouched. Perhaps we’ll call it CrapsTable.",NA
29.3 Design Decision – Allowable Outcomes,"After deciding to create a CrapsTable subclass, we have several consequent decisions. First, we turn the 
 interesting question of how best to allocate responsibility for keeping the list of
  Outcome
 s which change with 
 the game state.
  
 Problem
 . Which class determines the valid and invalid
  Outcome
 s?
  
 Forces
 . We can see three places to place this responsibility.
  
 1. We could make CrapsTable responsible; it could have methods to return the lists of
  Outcome
 s that are 
 allowed or not allowed.
  CrapsGame
  can make a call to get the list of
  Outcome
 s and make the changes. 
 Making each change would involve the CrapsTable a second time to mark the individual
  Outcome
 s. This 
 information is then used by the CrapsTable to validate individual
  Bet
 s.
  
 2. We could
  CrapsGame
  responsible; it could invoke a method of CrapsTable that changes a single
  
 Outcome
 ‘s state to makt it inactive. This information is then used by the CrapsTable to validate 
 individual 
 Bet
 s.
  
 3. An appealing choice is to have the validBet() method of CrapsTable depend on
  CrapsGame
  to determine 
 which bets are allowed or denied. In this case,
  CrapsGame
  has the responsibility to respond to requests 
 from either CrapsTable or
  Player
  regarding a specific
  Outcome
 s.
  
 The third choice seems to focus bet-handling responsibility mostly on
  CrapsGame
 .
  
 Solution
  We need to place a valid method in the CrapsTable; but the Table simply delegates the details to the
  
 CrapsGame
 . This allows the Player to deal directly with the Table. But it centralizes the actual decision-
 making on the Game.
  
 Consequences
 . The game must move
  Outcome
 s for certain kinds of bets. Additionally, the CrapsTable‘s 
 isValid() method will use the
  CrapsGame
  to both check the validity of individual bets as well as the entire set 
 of bets created by a player. The first check allows or denies individual bets, something CrapsTable must do in 
 collaboration with
  CrapsGame
 . For the second check, the CrapsTable assures that the total of the bets is 
 within the table limits; something for which only the table has the information required.
  
 170
  
 Chapter 29.
  
 Craps Table Class",NA
29.4 CrapsGame Stub,"CrapsGame
  is a preliminary design for the game of Craps. In addition to features required by the
  Throw
 , this 
 version includes features required by the CrapsTable class.
  
 29.4.1 Methods
  
 isAllowed
 (
 self, outcome
 )
  
 Parameter
  outcome
  (Outcome) – An
  Outcome
  that may be allowed or not allowed, depend-
  
 ing on the game state.
  
 Determines if the
  Outcome
  is allowed in the current state of the game. When the point is zero, it is 
 the come out roll, and only Pass, Don’t Pass, Come and Don’t Come bets are allowed. Otherwise, all 
 bets are allowed.
  
 isWorking
 (
 self, outcome
 )
  
 Parameter
  outcome
  (Outcome) – An
  Outcome
  that may be allowed or not allowed, depend-
  
 ing on the game state.
  
 Determines if the
  Outcome
  is working in the current state of the game. When the point is zero, it is 
 the come out roll, odds bets placed behind any of the six come point numbers are not working.",NA
29.5 CrapsTable Design,"CrapsTable is a subclass of
  Table
  that has an association with a
  CrapsGame
  object. As a
  Table
 , it contains all 
 the
  Bet
 s created by the
  Player
 . It also has a betting limit, and the sum of all of a player’s bets must be less than 
 or equal to this limit. We assume a single
  Player
  in the simulation.
  
 29.4.
  
 CrapsGame Stub
  
 171",NA
29.6 Craps Table Deliverables,"There are three deliverables for this exercise.
  
 • A revision of the stub
  CrapsGame
  class to add methods for validating bets in different game states. In the 
 stub, the point value of 0 means that only the “Pass Line” and “Don’t Pass Line” bets are valid, where a 
 point value of non-zero means all bets are valid.
  
 • The CrapsTable subclass.
  
 • A class which performs a unit test of the CrapsTable class. The unit test should create a couple 
  
 instances of
  Bet
 , and establish that these
  Bet
 s are managed by the table correctly.
  
 For testing purposes, it is easiest to have the test method simply set the the point variable in the 
 CrapsGame
  instance to force a change in the game state. While public instance variables are considered 
 by some to be a bad policy, they facilitate the creation of unit test classes.
  
 172
  
 Chapter 29.
  
 Craps Table Class",NA
THIRTY,NA,NA
CRAPSGAME CLASS,"In
  Throw Class
 , we roughed out a stub version of
  CrapsGame
  that could be used to test
  Throw
 . We extended 
 that stub in
  Craps Table Class
 . In this chapter, we will revise the game to provide the complete process for 
 Craps. This involves a number of features, and we will have a state hierarchy as well as the Game class itself.
  
 In the process of completing the design for
  CrapsGame
 , we will uncover another subtlety of craps: winning 
 bets and losing bets. Unlike Roulette, where a
  Bin
  contained winning
  Outcome
 s and all other
  Outcome
 s where 
 losers, Craps includes winning
  Outcome
 s, losing
  Outcome
 s, and unresolved
  Outcome
 s. This will lead to some 
 rework of previously created Craps classes.
  
 We can see three necessary features to the
  CrapsGame
 :• 
 Game State,
  
 • Resolving Bets,
  
 • Moveable Bets when a point is established.
  
 Also, we will discover some additional design features to add to other classes.",NA
30.1 Game State,"A
  CrapsGame
  object cycles through the various steps of the Craps game; this sequence is shown in
  Game State
 . 
  
 For statistical sampling purposes, we don’t want to process complete games, since they have an 
 arbitrary number of dice throws, and each throw offers additional betting opportunities. Because of all the 
 betting opportunities, we will gather data from each individual throw of the dice. Since the dice are thrown at 
 a predictable average rate, the length of a session depends on the number of throws and has little to do with 
 the number of games.
  
 Since we will follow the
  State
  design pattern, we have three basic design decisions. First, we have to design 
 the state class hierarchy to own responsibilities for the unique processing of the individual states. Second, we 
 have to design an interface for the game state objects to interact with the overall
  CrapsGame
 . Additionally, we 
 will need to keep an object in the
  CrapsGame
  which contains the current state. Each throw of the dice will 
 update the state, and possibly resolve game bets. To restart the game, we can create a fresh object for the 
 initial point-off state.
  
 The following procedure provides the detailed algorithm for the game of Craps.
  
 173",NA
30.2 Game State Class Hierarchy,"We have identified some processing that is unique to each game state. Both states will have a unique list of 
 allowed bets, a unique list of non-working bets, a unique list of throws that cause state change and resolve 
 game bets, and throws that resolve hardways bets.
  
 In the Craps Table (
 Craps Table Overview
 ), we allocated some responsibilities to
  CrapsGame
  so that a 
 CrapsTable could validate bets and determine which bets were working.
  
 Our further design details have shown that the work varies by state. Therefore, the methods in
  CrapsGame 
 will delegate the real work to each state’s methods. The current stub implementation checks the value of the 
 point variable to determine the state. We’ll replace this with simply calling an appropriate method of the 
 current state object.
  
 State Responsibilities
 . Each CrapsGameState subclass, therefore, will have an isValid() method that 
 implements the state-specific bet validation rules. In this case, a point-off state object only allows the two 
 Pass Line bets: Pass Line, Don’t Pass Line. The point-on state allows all bets. Additionally, we’ve assigned to 
 the CrapsTable has to determine if the total amount of all a player’s bets meets or exceeds the table limits.
  
 Each subclass of CrapsGameState will override an isWorking() method with one that validates the state-
 specific rules for the working bets. In this case, a point-off state object will identify the the six odds bets 
 placed behind the come point numbers (4, 5, 6, 8, 9 and 10) as non-working bets, and all other bets will be 
 working bets. A point-on state object will simply identify all bets as working.
  
 The subclasses of CrapsGameState will need methods with which to collaborate with a
  Throw
  object to update 
 the state of the
  CrapsGame
 .
  
 Changing Game State
 . We have identified two game states: point-off (also know as the come out roll) and 
 point-on. 
  
 We have also set aside four methods that the various
  Throw
  objects will use to change
  
 30.2.
  
 Game State Class Hierarchy
  
 175",NA
30.3 Resolving Bets,"The
  CrapsGame
  class also has the responsibility for matching the
  Outcome
 s in the current
  Throw
  with the 
 Outcome
 s of the
  Bet
 s on the CrapsTable.
  
 In addition to matching
  Outcome
 s in the
  Throw
 , we also have to match the
  Outcome
 s of the current game 
 state.
  
 Finally, the
  CrapsGame
  class must also resolve hardways bets, which are casually tied to the current game 
 state. We’ll look at each of these three resolution procedures in some detail before making any final design 
 decisions.
  
 Resolving Bets on Proposition Outcomes
 . We’ll need a bet resolution method that handles one-roll 
 propositions. This is similar to the bet resolution in the Roulette game class. The current
  Throw
  contains a 
 collection of
  Outcome
 s which are resolved as winners. All other
  Outcome
 s will be losers. While appropriate 
 for the one-roll propositions, we’ll see that this doesn’t generalize for other kinds of bets.
  
 Resolving Bets on Game Outcomes
 . The second, and most complex bet resolution method handles game 
 outcomes. Bets on the game as a whole have three groups of
  Outcome
 s: winners, losers and unresolved.
  
 176
  
 Chapter 30.
  
 CrapsGame Class",NA
30.4 Moveable Bets,"In the casino, the Come (and Don’t Come) Line bets start on the given line. If a come point is established, the 
 come line bet is moved to a numbered box. When you add behind the line odds bets, you place the chips 
 directly on the numbered box for the Come Point number.
  
 This procedure is different from the Pass (and Don’t Pass) Line bet. The bet is is placed on the line. If a point is 
 established, a large white “On” token shows the numbered box where, in effect, the behind the line odds chips 
 belong.
  
 Note that the net effect of both bets is identical. The pass line and behind-the-line odds bets have a payout 
 that depends on the “On” token. The come line bets are moved and odds a place in a box on which the payout 
 depends.
  
 Moving Bets
 . One of the things the
  CrapsGame
  does is change the
  Outcome
  of the Come and Don’t Come Line 
 bets. If a Come or Don’t Come Line bet is placed and the throw is a point number (4, 5, 6, 8, 9, or 10), the bet is 
 not resolved on the first throw; it is moved to one of the six point number
  Outcome
 s.
  
 When designing the
  Bet
  class, in the Craps Bet
  Bet Overview
 , we recognized the need to change the
  Outcome 
 from a generic “Pass Line Odds” to a specific point with specific odds of 2:1, 3:2 or 6:5.
  
 We’ll develop a moveToThrow() method that accepts a
  Bet
  and the current
  Throw
  and move that bet to an 
 appropriate new
  Outcome
 .
  
 In addition to moving bets, we also need to create bets based on the currently established point. We also need 
 to deactivate bets based on the established point.
  
 As an example, the Pass Line Odds and Don’t Pass Odds are created after the point is established. Since the 
 point is already known, creating these bets is best done by adding a
  CrapsGame.pointOutcome()
  method that 
 returns an
  Outcome
  based on the current point. This allows the CrapsPlayer to get the necessary 
 Outcome
  
 object, create a
  Bet
  and give that
  Bet
  to the CrapsTable.
  
 30.4.
  
 Moveable Bets
  
 177",NA
"30.5 Design Decision – Win, Lose, Wait","Bet resolution in Craps is more complex than simply paying winners and collecting all other bets as losers. In 
 craps, we have winners, losers and unresolved bets. Further, some bets have a resolution in which only the 
 original price of the bet is returned. This is a kind of 1:1 odds special case.
  
 This leaves us with a design decision on how best to handle the wide variety of bets that will be on the 
 CrapsTable.
  
 Problem
 . What’s the best way to retain a collection of
  Outcome
 s that are resolved as a mixture of winning, 
 losing, unresolved and pushes.
  
 Note that if we elect to introduce a more complex multi-way bet resolution, we have to decide if we should 
 reimplement the bet resolution in Roulette. Using very different bet resolution algorithms for Craps and 
 Roulette would increase the cost of maintenance and adaptation. While a uniform approach is beneficial, it 
 would involve some rework of the Roulette game to make use of a more sophisticated design.
  
 Alternatives
  We’ll look at three altenative responsibility assignments in some depth.
  
 •
  Winning and Losing Collections
 . 
  
 We could expand the
  Throw
  to keep separate collections of 
  
 winners and losers. We could expand the CrapsGameState to detail the winning and losing
  Outcome
 s 
  
 for each state. All other
  Outcome
 s would be left unresolved.
  
 This is a minor revision to
  Dice
  and
  Throw
  to properly create the two groups of
  Outcome
 s. 
 Consequently 
 ThrowBuilder
  will have to be expanded to identify losing
  Outcome
 s in addition to the 
 existing winning 
 Outcome
 s.
  
 This will require the
  CrapsGame
  to make two passes through the bets. It must match all active
  Bet
 s on 
 the CrapsTable against the winning
  Outcome
 s in the current CrapsGameState; the matches are paid a 
 winning amount and removed. It must also match match all active
  Bet
 s on the CrapsTable against the 
 losing
  Outcome
 s in the current CrapsGameState; these are removed as losers.
  
 •
  Winning and Losing Codes, Evaluated by CrapsGame
 . We could enumerate three code values that 
 represent actions to take: these actions are “win”, “lose”, and “unresolved”. The class
  Game
  and each 
 subclass of GameState would have a resolution method that examines a
  Bet
  and returns the appropriate 
 code value.
  
 This is a minor revision to
  Dice
  and
  Throw
  to properly associate a special code with each
  Outcome
 . 
 Consequently
  ThrowBuilder
  will have to be expanded to identify losing
  Outcome
 s in addition to the 
 existing winning
  Outcome
 s.
  
 Each
  GameState
  would also need to respond with appropriate codes.
  
 This will require the
  CrapsGame
  to make one pass through the
  Bet
 s, passing each each bet to the 
 GameState resolution method. Based on the code returned, the
  CrapsGame
  would then have an if-
 statement to decide to provide bets to the
  Player.win()
  or
  Player.lose()
  method.
  
 •
  Wining and Losing Commands
 . We could define a hierarchy of three subclasses. Each subclass 
  
 implements winning, losing or leaving a bet unresolved.
  
 This is a minor revision to
  Dice
  and
  Throw
  to properly associate a special object with each
  Outcome
 . We 
 would create single objects of each resolution subclass. The
  ThrowBuilder
  will have to be expanded to 
 associate the loser Command or winner command with each
  Outcome
 . 
  
 Further, the unresolved 
 Command would have to be associated with all
  Outcome
 s that are not resolved by the
  Throw
  or 
 GameState
 .
  
 This will require the
  CrapsGame
  to make one pass through the
  Bet
 s, using the associated resolution 
 object. The resolution object would then handle winning, losing and leaving the bet unresolved.
  
 Before making a determination, we’ll examine the remaining bet resolution issue to see if a single approach 
 can cover single-roll, game and hardways outcomes.
  
 178
  
 Chapter 30.
  
 CrapsGame Class",NA
30.6 Additional Craps Design,"We will have to rework our design for
  Throw
  to have both a one-roll resolution method and a hardways 
 resolution method. Each of these methods will accept a single active
  Bet
 . Each resolution method could use a 
 Set of winner
  Outcome
 s and a Set of loser
  Outcome
 s to attempt to resolve the
  Bet
 .
  
 We will also need to rework our design for
  Dice
  to correctly set both winners and losers for both one-roll and 
 harways bets when constructing the 36 individual
  Throw
  instances.
  
 We can use the following expanded algorithm for building the
  Dice
 . This is a revision to
  Throw Builder 
 Overview
  to include lists of losing bets as well as winning bets.
  
 Building Dice With Winning and Losing Outcomes
  
 For All Faces Of Die 1
 . For all
  d
 1
 , such that 1
  ≤ d
 1
  <
  7: 
  
 For All 
 Faces Of A Die 2
 . For
  d
 2
 , such that 1
  ≤ d
 2
  <
  7: 
  
  
 Sum the 
 Dice
 . Compute the sum,
  s ← d
 1
  +
  d
 2
 .
  
 Craps?
  If
  s
  is in 2, 3, and 12, we create a
  CrapsThrow
  instance. The winning bets include 
 one of the 2, 3 or 12 number
  Outcome
 , plus all craps, horn and field
  Outcome
 s. The losing 
 bets include the other number
  Outcome
 s. 
  
 This throw does not resolve 
 hardways bets.
  
 Point?
  For
  s
  in 4, 5, 6, 8, 9, and 10 we will create a
  PointThrow
  instance.
  
 30.6.
  
 Additional Craps Design
  
 179",NA
30.7 Craps Game Implementation Overview,"Changing the
  Throw
  to include both winning and losing
  Outcome
 s is an important change. Once we have fixed 
 the
  Throw
  class, we can update the
  ThrowBuilder
  class to do a correct initialization using both winners and 
 losers. Note that we have encapsulated this information so that there is no change to
  Dice
 .
  
 We will also update
  Bet
  to carry a reference to the
  Player
  to make it easier to post winning and losing 
 information directly to the player object.
  
 We will need to create a stub CrapsPlayer for testing purposes.
  
 We will also need to create our CrapsGameState class hierarchy to represent the two states of the game.
  
 Once the preliminary work is complete, we can then transform the
  CrapsGame
  we started in
  CrapsGame Stub
  
 into a final version of
  CrapsGame
 . 
  
 It will collaborate with a CrapsPlayer and maintain a correct 
 CrapsGameState. It will be able to get a random
  Throw
  and resolve
  Bet
 s.",NA
30.8 Throw Rework,"Throw
  is the superclass for the various throws of the dice. A
  Throw
  identifies two sets of
  Outcome
 s: 
 immediate winners and immediate losers. Each subclass is a different grouping of the numbers, based on the 
 state-change rules for Craps.
  
 180
  
 Chapter 30.
  
 CrapsGame Class",NA
30.9 ThrowBuilder Rework,"ThrowBuilder
  initializes the 36
  Throw
 s, each initialized with the appropriate
  Outcome
 s. 
 override this to reflect different casino-specific rules for odds on Field bets.
  
 Subclasses can
  
 30.9.1 Methods
  
 buildThrows
 (
 self, dice
 ) 
  
  
  
 Para dice
  The Dice to build 
  
  
 Creates the 8 one-roll
  Outcome
  instances (2, 3, 7, 11, 12, Field, Horn, Any Craps), as well as the 
  
 8 
 hardways
  Outcome
  instances (easy 4, hard 4, easy 6, hard 6, easy 8, hard 8, easy 10, hard 10). 
  
 It 
 then creates each of the 36
  Throw
 s, each of which has the appropriate combination of
  Outcome
 s 
  
 for 
 one-roll and hardways. The various
  Throw
 s are assigned to dice.
  
 182
  
 Chapter 30.
  
 CrapsGame Class",NA
30.10 Bet Rework,"Bet
  associates an amount, an
  Outcome
  and a
  Player
 . The
  Game
  may move a
  Bet
  to a different
  Outcome
  to 
 reflect a change in the odds used to resolve the
  Bet
 .
  
 30.10.1 Constructors
  
 __init__
 (
 self, amount, outcome, player=None
 ) 
  
  
 This replaces the existing constructor and adds an optional parameter.
  
 Parameters
  
 •
  amount
  (int) – The amount being wagered.
  
 •
  outcome
  (Outcome) – The specific outcome on which the wager is placed.
  
 •
  player
  (CrapsPlayer) – The player who will pay a losing bet or be paid by a winning 
  
 bet.
  
 Initialize the instance variables of this bet. This works by saving the additional player informa-tion, 
 then using the existing
  Bet.Bet()
  constructor.",NA
30.11 CrapsPlayer Class Stub,"CrapsPlayer constructs a
  Bet
  based on the
  Outcome
  named ""Pass Line"". This is a very persistent player.
  
 30.11.1 Fields
  
 passLine 
  
 This is the
  Outcome
  on which this player focuses their betting. It will be an instance of the ""Pass Line""
  
 Outcome
 , with 1:1 odds.
  
 workingBet 
  
  
 This is the current Pass Line
  Bet
 .
  
 Initially this is None. Each time the bet is resolved, this is reset to None.
  
 This assures that only one bet is working at a time.
  
 table 
  
  
 That
  Table
  which collects all bets.
  
 30.11.2 Constructors
  
 __init__
 (
 self, table
 )
  
 Parameter
  table
  (Table) – The
  Table
 .
  
 Constructs the CrapsPlayer with a specific table for placing bets. The player creates a single ""Pass 
 Line""
  Outcome
 , which is saved in the passLine variable for use in creating
  Bet
 s.
  
 30.10.
  
 Bet Rework
  
 183",NA
30.12 CrapsGameState Class,"CrapsGameState defines the state-specific behavior of a Craps game. Individual subclasses provide methods 
 used by CrapsTable to validate bets and determine the active bets. Subclasses provide state-specific methods 
 used by a
  Throw
  to possibly change the state and resolve bets.
  
 30.12.1 Fields
  
 gam
 e
  
 The overall
  CrapsGame
  for which this is a specific state. From this object, the various next state-change 
 methods can get the CrapsTable and an Iterator over the active
  Bet
 s.
  
 30.12.2 Constructors
  
 __init__
 (
 self, game
 ) 
  
  
  
 Parameter
  game
  (Game) – The game to which this state applies 
  
 Saves the overall
  CrapsGame
  object to which this state applies.
  
 30.12.3 Methods
  
 isValid
 (
 self, outcome
 ) 
  
  
  
 Parameter
  outcome
  (Outcome) – The outcome to be tested for validity 
  
 Returns true if this is a valid outcome for creating bets in the current game state.
  
 Each subclass provides a unique definition of valid bets for their game state.
  
 isWorking
 (
 self, outcome
 ) 
  
  
  
 Parameter
  outcome
  (Outcome) – The outcome to be tested for if it’s working 
  
 Returns true if this is a working outcome for existing bets in the current game state.
  
 Each subclass provides a unique definition of active bets for their game state.
  
 craps
 (
 self, throw
 ) 
  
  
 Parameter
  throw
  (Throw) – The throw that is associated with craps.
  
 Return an appropriate state when a 2, 3 or 12 is rolled. It then resolves any game bets. Each 
 subclass provides a unique definition of what new state and what bet resolution happens.
  
 natural
 (
 self, throw
 )
  
 184
  
 Chapter 30.
  
 CrapsGame Class",NA
30.13 CrapsGamePointOff Class,"CrapsGamePointOff defines the behavior of the Craps game when the point is off. It defines the allowed bets 
 and the active bets. It provides methods used by a
  Throw
  to change the state and resolve bets. All four of the 
 game update methods (craps, natural, eleven and point) use the same basic algorithm. The method will get the 
 CrapsTable from theGame. From the CrapsTable, the method gets the Iterator over the
  Bet
 s. It can then match 
 each
  Bet
  against the various
  Outcome
 s which win and lose, and resolve the bets.
  
 30.13.1 Constructors
  
 __init__
 (
 self, game
 ) 
  
  
 Parameter
  game
  (CrapsGame) – The game to which this state applies.
  
 Uses the superclass constructor to save the overall
  CrapsGame
  object.
  
 30.13.
  
 CrapsGamePointOff Class
  
 185",NA
30.14 CrapsGamePointOn Class,"CrapsGamePointOn defines the behavior of the Craps game when the point is on. It defines the allowed bets 
 and the active bets. It provides methods used by a
  Throw
  to change the state and resolve bets.
  
 186
  
 Chapter 30.
  
 CrapsGame Class",NA
30.15 CrapsGame Class,"CrapsGame
  manages the sequence of actions that defines the game of Craps. This includes notifying the 
 Player
  
 to place bets, throwing the
  Dice
  and resolving the
  Bet
  s actually present on the
  Table
 .
  
 Note that a single cycle of play is one throw of the dice, not a complete craps game. The state of the game may 
 or may not change.
  
 30.15.1 Fields
  
 dice
  
 Contains the dice that returns a randomly selected
  Throw
  with winning and losing
  Outcome
 s. This is an 
 instance of
  Dice
 .
  
 table 
  
  
 The CrapsTable contains the bets placed by the player.
  
 player 
  
  
 The CrapsPlayer who places bets on the CrapsTable.
  
 30.15.2 Constructors
  
 We based this constructor on an design that allows any of these objects to be replaced. This is the
  Strategy 
 design pattern. Each of these objects is a replaceable strategy, and can be changed by the client that uses this 
 game.
  
 Additionally, we specifically do not include the
  Player
  instance in the constructor. The
  Game
  exists indepen-
 dently of any particular
  Player
 , and we defer binding the
  Player
  and
  Game
  until we are gathering statistical 
 samples.
  
 __init__
 (
 self, dice, table
 )
  
 188
  
 Chapter 30.
  
 CrapsGame Class",NA
30.16 Craps Game Deliverables,"There are over a dozen deliverables for this exercise. This includes significant rework for
  Throw
  and
  Dice
 . It 
 also includes development of a stub CrapsPlayer, the CrapsGameState hierarchy and the first version of the
  
 CrapsGame
 . We will break the deliverables down into two groups.
  
 Rework
 . The first group of deliverables includes the rework for
  Throw
  and
  Dice
 , and all of the associated unit 
 testing.
  
 • The revised and expanded
  Throw
  class. This will ripple through the constructors for all four subclasses, 
  
 NaturalThrow
 ,
  CrapsThrow
 ,
  ElevenThrow
 ,
  PointThrow
 .
  
 • Five updated unit tests for the classes in the
  Throw
  class hierarchy. This will confirm the new func-
  
 tionality for holding winning as well as losing
  Outcome
 s.
  
 • The revised and expanded
  ThrowBuilder
 . This will construct
  Throw
 s with winning as well as losing 
  
 Outcome
 s.
  
 • A unit test for the
  Dice
  class that confirms the new initializer that creates winning as well as losing 
  
 Outcome
 s.
  
 New Development
 . The second group of deliverables includes development of a stub CrapsPlayer, the 
 CrapsGameState hierarchy and the first version of the
  CrapsGame
 . This also includes significant unit testing.
  
 • The CrapsPlayer class stub. We will rework this design later. This class places a bet on the Pass Line 
 when there is no Pass Line
  Bet
  on the table. One consequence of this is that the player will be given 
 some opportunities to place bets, but will decline. Since this is simply used to test
  CrapsGame
 , it doesn’t 
 deserve a very sophisticated unit test of its own. It will be replaced in a future exercise.
  
 • A revised
  Bet
 , which carries a reference to the
  Player
  who created the
  Bet
 . This will ripple through all 
 subclasses of
  Player
 , forcing them to all add the this parameter when constructing a new
  Bet
 .
  
 • The
  CrapsGame
  class.
  
 • A class which performs a demonstration of the
  CrapsGame
  class. This demo program creates the
  Dice
 , the 
 stub CrapsPlayer and the CrapsTable. It creates the
  CrapsGame
  object and cycles a few times. Note that 
 we will need to configure the
  Dice
  to return non-random results.
  
 We could, with some care, refactor our design to create some common superclasses between Roulette and 
 Craps to extract features of
  Throw
  so they can be shared by
  Throw
  and
  Bin
 . Similarly, there may be more 
 common features between RouletteGame and
  CrapsGame
 . We’ll leave that as an exercise for more advanced 
 students.",NA
30.17 Optional Working Bets,"Some casinos may give the player an option to declare the odds bet behind a come point as “on” or “off”. This 
 is should not be particularly complex to implement. There are a number of simple changes required if we 
 want to add this interaction between CrapsPlayer and
  CrapsGame
 .
  
 1. We must add a method to the CrapsPlayer to respond to a query from the
  CrapsGame
  that determines 
  
 if the player wants their come point odds bet on or off.
  
 2. We need to update
  Bet
  to store the
  Player
  who created the
  Bet
 . Third, the
  CrapsGame
  gets the 
  
 relevant
  
 Bet
 s from the
  Table
 , and interrogates the
  Player
  for the disposition of the
  Bet
 .
  
 190
  
 Chapter 30.
  
 CrapsGame Class",NA
THIRTYONE,NA,NA
CRAPSPLAYER CLASS,"The variations on
  Player
 , all of which reflect different betting strategies, is the heart of this application. In 
 Roulette Game Class
 , we roughed out a stub class for
  Player
 , and refined it in
  Player Class
 . We will further 
 refine this definition of
  Player
  for use in Craps.",NA
31.1 Craps Player Overview,"We have now built enough infrastructure that we can begin to add a variety of players and see how their 
 betting strategies work. Each player is betting algorithm that we will evaluate by looking at the player’s stake 
 to see how much they win, and when they stop playing because they’ve run out of time or gone broke.
  
 The
  Player
  has the responsibility to create bets and manage the amount of their stake. To create bets, the 
 player must create legal bets from known
  Outcome
  s and stay within table limits. To manage their stake, the 
 player must deduct the price of a bet when it is created, accept winnings or pushes, report on the current 
 value of the stake, and leave the table when they are out of money.
  
 We have an interface that was roughed out as part of the design of
  CrapsGame
  and CrapsTable. In designing 
 CrapsGame
 , we put a placeBets() method in CrapsPlayer to place all bets. We expected the CrapsPlayer to 
 create
  Bet
  s and use the placeBet() method of CrapsTable class to save all of the individual
  Bet
 s.
  
 In an earlier exercise, we built a stub version of CrapsPlayer in order to test
  Game
 . See
  CrapsPlayer Class Stub
 . 
 When we finish creating the final superclass, CrapsPlayer, we will also revise our CrapsPlayerStub to be more 
 complete, and rerun our unit tests to be sure that our more expanded design still handles the basic test cases 
 correctly.
  
 Our objective is to have a new abstract class, CrapsPlayer, with a concrete subclass that follows the Martingale 
 system, using simple Pass Line bets and behind the line odds bets.
  
 We’ll defer some of the design required to collect detailed measurements for statistical analysis. In this first 
 release, we’ll simply place bets. Most of the
  Simulator
  class that we built for Roulette should be applicable to 
 Craps without significant modification.
  
 Some Basic Features
 . Our basic CrapsPlayer will place a Pass Line bet and a Pass Line Odds bet. This 
 requires the player to interact with the CrapsTable or the
  CrapsGame
  to place bets legally. On a come out roll, 
 only the Pass Line will be legal. After that, a single Pass Line Odds bet can be placed. This leads to three 
 betting rules:
  
 • Come Out Roll. Condition: No Pass Line Bet is currently placed and only the Pass Line bet is legal. 
  
 Action: Place a Pass Line bet.
  
 • First Point Roll. Condition: No odds bets is currently placed and odds bets are legal. Action: Place 
  
 a Pass Line Odds bet.
  
 • Other Point Roll. Condition: An odds bets is currently placed. Action: Do Nothing.
  
 191",NA
31.2 CrapsPlayer Superclass Design,"CrapsPlayer is a subclass of
  Player
  and places bets in Craps. This an abstract class, with no actual body for the
  
 Player.placeBets()
  method. 
  
 However, this class does implement the basic win() and lose() 
 methods used by all subclasses.
  
 Since this is a subclass of the basic Roulette player, we inherit several useful features. Most of the features of
  
 Player
  are repeated here for reference purposes only.
  
 31.2.1 Fields
  
 stake 
  
  
 The player’s current stake. Initialized to the player’s starting budget.
  
 roundsToGo 
  
 The number of rounds left to play. Initialized by the overall simulation control to the maximum number 
 of rounds to play. In Roulette, this is spins. In Craps, this is the number of throws of the dice, which may 
 be a large number of quick games or a small number of long-running games. In Craps, this is the number 
 of cards played, which may be large number of hands or small number of multi-card hands.
  
 table 
  
  
 The CrapsTable used to place individual
  Bet
 s.
  
 31.2.2 Constructors
  
 __init__
 (
 self, table
 )
  
 Parameter
  table
  (CrapsTable) – The table
  
 Constructs the
  Player
  with a specific CrapsTable for placing
  Bet
 s.
  
 31.2.3 Methods
  
 playing
 (
 self
 )
  
 Returns true while the player is still active. 
  
 A player with a stake of zero will be inactive. 
 Because of the indefinite duration of a craps game, a player will only become inactive after their 
 roundsToGo is zero and they have no more active bets. 
  
 This method, then, must check the 
 CrapsTable to see when all the bets are fully resolved. Additionally, the player’s betting rules 
 should stop placing new bets when the roundsToGo is zero.
  
 placeBets
 (
 self
 )
  
 192
  
 Chapter 31.
  
 CrapsPlayer 
 Class",NA
31.3 CrapsPlayerPass Subclass,"The amount of money won is
  
 CrapsPlayerPass is a CrapsPlayer who places a Pass Line bet in Craps.
  
 31.3.1 Methods 
  
 placeBets
 (
 self
 ) 
  
  
 If no Pass Line bet is present, this will update the
  Table
  with a bet on the Pass Line at the base 
  
 bet 
 amount.
  
 Otherwise, this method does not place an additional bet.",NA
31.4 Craps Martingale Subclass,"CrapsMartingale is a CrapsPlayer who places bets in Craps. This player doubles their Pass Line Odds bet on 
 every loss and resets their Pass Line Odds bet to a base amount on each win.
  
 31.4.1 Fields 
  
 lossCount 
  
  
 The number of losses. This is the number of times to double the pass line odds bet.
  
 betMultiple 
  
 The the bet multiplier, based on the number of losses. This starts at 1, and is reset to 1 on each win. It is 
 doubled in each loss. This is always set so that
  betMultiple
  = 2
 lossCount
 .
  
 31.4.2 Methods 
  
 placeBets
 (
 self
 )
  
 31.3.
  
 CrapsPlayerPass Subclass
  
 193",NA
31.5 Craps Player Deliverables,"There are six deliverables for this exercise.
  
 • The CrapsPlayer abstract superclass. 
  
 method, it can’t be unit tested directly.
  
 Since this class doesn’t have a body for the placeBets()
  
 • A CrapsPlayerPass class that is a proper subclass of CrapsPlayer, but simply places bets on Pass 
  
 Line 
 until the stake is exhausted.
  
 • A unit test class for CrapsPlayerPass. This test should synthesize a fixed list of
  Outcome
 s,
  Throw
  s, and 
 calls a CrapsPlayerPass instance with various sequences of craps, naturals and points to assure that the 
 pass line bet is made appropriately.
  
 • The CrapsMartingale subclass of CrapsPlayer.
  
 • A unit test class for CrapsMartingale. This test should synthesize a fixed list of
  Outcome
 s,
  Throw
  s, and 
 calls a CrapsMartingale instance with various sequences of craps, naturals and points to assure that the 
 bet doubles appropriately on each loss, and is reset on each win.
  
 • The unit test class for the
  CrapsGame
  class should still work with the new CrapsPlayerPass. Using a non-
 random generator for
  Dice
 , this should be able to confirm correct operation of the
  CrapsGame
  for a 
 number of bets.
  
 194
  
 Chapter 31.
  
 CrapsPlayer 
 Class",NA
THIRTYTWO,NA,NA
DESIGN CLEANUP AND ,NA,NA
REFACTORING,"We have taken an intentionally casual approach to the names chosen for our various classes and the rela-
 tionships among those classes. At this point, we have a considerable amount of functionality, but it doesn’t 
 reflect our overall purpose, instead it reflects the history of its evolution. This chapter will review the design 
 from Craps and more cleanly separate it from the design for Roulette.
  
 We expect two benefits from the rework in this chapter. First, we expect the design to become “simpler”in the 
 sense that Craps is separated from Roulette, and this will give us room to insert Blackjack into the structure 
 with less disruption in the future. Second, and more important, the class names will more precisely reflect the 
 purpose of the class, making it easier to understand the system, which means it will be easier to debug, 
 maintain and adapt.",NA
32.1 Design Review,"We can now use our application to generate some more usable results. We would like the
  Simulator
  class to 
 be able to use our Craps game, dice, table and players in the same way that we use our Roulette game, wheel, 
 table and players. The idea would be to give the
  Simulator
 ‘s constructor Craps-related objects instead of 
 Roulette-related objects and have everything else work normally. Since we have generally made Craps a 
 subclass of Roulette, we are reasonably confident that this should work.
  
 Our
  Simulator
 ‘s constructor requires a
  Game
  and a
  Player
 . Since
  CrapsGame
  is a subclass of
  Game
  and 
 CrapsPlayer is a subclass of
  Player
 , we can construct an instance of
  Simulator
 .
  
 Looking at this, however, we find a serious problem with the names of our classes and their relationships. 
 When we designed Roulette, we used generic names like
  Table
 ,
  Game
  and
  Player
  unwisely. Further, there’s no 
 reason for Craps to be dependent on Roulette. We would like them to be siblings, and both children of some 
 abstract game simulation.
  
 195",NA
32.2 RandomEventFactory Design,"RandomEventFactory is a superclass for Dice, Wheel, Cards, and other casino random-event generators.
  
 32.2.1 Fields
  
 rng
  
 The random number generator, a subclass of random.Random.
  
 Generates the next random number, used to select a
  RandomEvent
  from the bins collection.
  
 current 
  
  
 The most recently returned
  RandomEvent
 .
  
 32.2.
  
 RandomEventFactory Design
  
 199",NA
32.3 Wheel Class Design,"Wheel
  is a subclass of RandomEventFactory that contains the 38 individual
  Bin
 s on a Roulette wheel. As a 
 RandomEventFactory, it contains a random number generator and can select a
  Bin
  at random, simulating a 
 spin of the Roulette wheel.
  
 32.3.1 Constructors
  
 __init__
 (
 self, rng
 ) 
  
 Creates a new wheel. Create a sequence of the Wheel.events with with 38 empty
  Bin
 s. Use the 
 superclass to save the given random number generator instance and invoke initialize().
  
 32.3.2 Methods
  
 addOutcome
 (
 self, bin, outcome
 ) 
  
  
 Adds the given
  Outcome
  to the
  Bin
  with the given number.
  
 initialize
 (
 self
 ) 
  
  
 Creates the events vector with the pool of possible events. 
  
 This will create an instance of 
  
 BinBuilder
 , bb, and delegate the construction to the buildBins() method of the bb object.
  
 32.3.3 Dice Class
  
 Dice
  is a subclass of RandomEventFactory that contains the 36 individual throws of two dice. 
  
 As a
  
 RandomEventFactory, it contains a random number generator and can select a
  Throw
  at random, simu-
  
 lating a throw of the Craps dice.
  
 200
  
 Chapter 32.
  
 Design Cleanup and Refactoring",NA
32.4 Table Class,"Table
  contains all the
  Bet
 s created by the
  Player
 . 
  
 A table has an association with a
  Game
 , which is 
 responsible for validating individual bets. A table also has betting limits, and the sum of all of a player’s bets 
 must be within this limits.
  
 32.4.1 Fields 
  
 minimum 
  
  
 This is the table lower limit. The sum of a
  Player
 ‘s bets must be greater than or equal to this limit.
  
 maximum 
  
  
 This is the table upper limit. The sum of a
  Player
 ‘s bets must be less than or equal to this limit.
  
 bets
  
 gam
 e
  
 This is a LinkedList of the
  Bet
 s currently active. These will result in either wins or losses to the 
 Player
 .
  
 The
  Game
  used to determine if a given bet is allowed in a particular game state.
  
 32.4.2 Constructors 
  
 __init__
 (
 self
 ) 
  
  
 Creates an empty LinkedList of bets.
  
 32.4.3 Methods 
  
 setGame
 (
 self, game
 ) 
  
  
 Saves the given
  Game
  to be used to validate bets.
  
 isValid
 (
 self, bet
 )
  
 32.4.
  
 Table Class
  
 201",NA
32.5 Game Class,"Game
  manages the sequence of actions that defines casino games, including Roulette, Craps and Blackjack. 
 Individual subclasses implement the detailed playing cycles of the games. This superclass has methods for 
 notifying the
  Player
  to place bets, getting a
  RandomEvent
  and resolving the
  Bet
  s actually present on the 
 Table
 .
  
 32.5.1 Fields
  
 eventFactory 
  
 Contains a
  Wheel
  or
  Dice
  or other subclass of RandomEventFactory that returns a randomly selected 
 RandomEvent
  with specific
  Outcome
  s that win or lose.
  
 table 
  
  
 Contains a CrapsTable or RouletteTable which holds all the
  Bet
 s placed by the
  Player
 .
  
 player 
  
  
 Holds the
  Player
  who places bets on the
  Table
 .
  
 32.5.2 Constructors
  
 We based this constructor on an design that allows any of these objects to be replaced. This is the
  
 Strategy
  (or
  Dependency Injection
 ) design pattern. Each of these objects is a replaceable 
 strategy, and can be changed by the client that uses this game.
  
 32.5.
  
 Game Class
  
 203",NA
32.6 RouletteGame Class,"RouletteGame is a subclass of
  Game
  that manages the sequence of actions that defines the game of Roulette.
  
 32.6.1 Methods
  
 cycle
 (
 self, player
 )
  
 This will execute a single cycle of the Roulette with a given
  Player
 . It will call player.placeBets() to 
 get bets. It will call wheel.next() to get the next winning
  Bin
  . It will then call table.bets() to get an 
 Iterator over the
  Bet
 s. Stepping through this Iterator returns the individual
  Bet
  objects. If the 
 winning
  Bin
  contains the
  Outcome
 , call the thePlayer win(), otherwise call the thePlayer lose().",NA
32.7 CrapsGame Class,"CrapsGame
  is a subclass of
  Game
  that manages the sequence of actions that defines the game of Craps.
  
 Note that a single cycle of play is one throw of the dice, not a complete craps game. The state of the game may 
 or may not change.
  
 32.7.1 Methods
  
 cycle
 (
 self, player
 )
  
 This will execute a single cycle of play with a given
  Player
 .
  
 1. It will call player.placeBets() to get bets. It will validate the bets, both individually, 
  
 based on 
 the game state, and collectively to see that the table limits are met.
  
 204
  
 Chapter 32.
  
 Design Cleanup and Refactoring",NA
32.8 Refactoring Deliverables,"There are six deliverables for this exercise.
  
 • If necessary, create
  RandomEvent
 , and revisions to
  Throw
  and
  Bin
 . See
  Design Heavy
  .
  
 • Create RandomEventFactory, and associated changes to
  Wheel
  and
  Dice
 . The existing unit tests will 
  
 confirm that this change has no adverse effect.
  
 • Refactor
  Table
  and CrapsTable to make a single class of these two. The unit tests for the original 
  
 CrapsTable should be merged with the unit tests for the original
  Table
 .
  
 • Refactor
  Player
  and CrapsPlayer to create a better class hierarchy with CrapsPlayer and RoulettePlayer 
 both sibling subclasses of
  Player
  . The unit tests should confirm that this change has no adverse effect.
  
 • Refactor
  Game
  and
  CrapsGame
  to create three classes:
  Game
 , RouletteGame and
  CrapsGame
 . The unit 
  
 tests should confirm that this change has no adverse effect.
  
 • Create a new main program class that uses the existing
  Simulator
  with the
  CrapsGame
  and 
  
 CrapsPlayer classes.
  
 32.8.
  
 Refactoring Deliverables
  
 205",NA
THIRTYTHREE,NA,NA
SIMPLE CRAPS PLAYERS,"This chapter defines a variety of player strategies. 
  
 Most of this is based on strategies already defined in
  
 Roulette
 , making the explanations considerably simpler. Rather than cover each individual design in separate 
 chapters, we’ll rely on the experience gained so far, and cover four variant Craps players in this chapter. We’ll 
 mention a fifth, but leave that as a more advanced exercise.",NA
33.1 Simple Craps Players Overview,"When we looked at our
  Player
  hierarchy, we noted that we could easily apply a number of strategies to the 
 Pass Line Odds bet. We use the Martingale strategy for our CrapsMartingale player. We could also use the 1-3-
 2-6 system, the Cancellation system, or the Fibonacci system for those odds bets. In each of these cases, we 
 are applying the betting strategy to one of the two bets the player will use.
  
 An additional design note for this section is the choice of the two basic bets: the Pass Line and the Pass Line 
 Odds bet. It is interesting to compare the results of these bets with the results of the Don’t Pass Line and the 
 Don’t Pass Odds Bet. In particular, the Don’t Pass Odds Bets involve betting large sums of money for small 
 returns; this will be compounded by any of these betting systems which accelerate the amount of the bet to 
 cover losses. This change should be a simple matter of changing the two base bets used by all these variant 
 players.
  
 All of these players have a base bet (either Pass Line or Don’t Pass) and an odds bet (either Pass Line Odds or 
 Don’t Pass Odds). If we create a superclass, called SimpleCraps , we can assure that all these simple betting 
 variations will work for Pass Line as well as Don’t Pass Line bets. The responsibility of this superclass is to 
 define a consistent set of fields and constructor for all of the subclasses.
  
 Craps 1-3-2-6
 . This player uses the 1-3-2-6 system for managing their odds bet. From the Roulette 1-3-2-6 
 player (see
  Player 1-3-2-6 Overview
 ) we can see that this player will need to use the
  Player1326State
  class 
 hierarchy. The craps player will use one of these objects track the state changes of their odds. The base bet 
 will not change.
  
 However, the current definitions of the
  Player1326State
  class hierarchy specifically reference Roulette1326. 
 Presenting us with an interesting design problem. How do we repair our design so that
  Player1326State 
 can 
 work with Roulette1326 and Craps1326?
  
 The only dependency is the field outcome, which both Roulette1326 and Craps1326 must provide to 
 Player1326State
  objects. We have three choices: extract the field and make it part of an interface, refactor the 
 field up to the superclass, change the defintion of
  Player1326State
  to make it more self-contained.
  
 •
  Common Interface
 . The relationship between a subclass of
  Player
  and
  Player1326State
  can
  
 be formalized through an interface. We could define something like Bet1326_Able, and use this for
  
 Roulette1326 and Craps1326. 
  
 In this case, this appears to be an example of the
  Very Large
  
 Hammer
  design pattern. The problem seems too small for this language feature.
  
 207",NA
33.2 CrapsPlayer Design,"We’ll extend CrapsPlayer to create a CrapsSimplePlayer that can place both Pass Line and Pass Line Odds 
 bets, as well as Don’t Pass Line and Don’t Pass Odds bets. This will allow us to drop the CrapsPlayerPass class, 
 and revise the existing CrapsMartingale.
  
 We have to rework the original Roulette-focused
  Player1326State
  hierarchy, and the Roulette1326 class to use 
 the new version of the state objects.
  
 Once this rework is complete, we can add our Craps1326 and CrapsCancellation players.
  
 For additional exposure, the more advanced student can rework the Roulette Fibonacci player to create a 
 CrapsFibonacci player.",NA
33.3 CrapsSimplePlayer superclass,"CrapsSimplePlayer is a subclass of CrapsPlayer and places two bets in Craps. The simple player has a base bet 
 and an odds bet. The base bet is one of the bets available on the come out roll (either Pass Line
  
 208
  
 Chapter 33.
  
 Simple Craps 
 Players",NA
33.4 Craps Martingale Player,"CrapsMartingale is a subclass of CrapsSimplePlayer who places bets in Craps. This player doubles their Pass 
 Line Odds bet on every loss and resets their Pass Line Odds bet to a base amount on each win.
  
 33.4.
  
 Craps Martingale Player
  
 209",NA
33.5 Player1326 State,"Player1326State
  is the superclass for all of the states in the 1-3-2-6 betting system.
  
 33.5.1 Fields
  
 outcome 
  
  
 The
  Outcome
  on which a
  Player
  will bet.
  
 33.5.2 Constructors
  
 __init__
 (
 self, outcome
 ) 
  
  
  
 Parameter
  outcome
  (Outcome) – The outcome on which to bet 
  
 The 
 constructor for this class saves
  Outcome
  on which a
  Player
  will bet.
  
 33.5.3 Methods
  
 Much of the original design for this state hierarchy should remain in place. See
  Player 1-3-2-6 Class
  for more 
 information on the original design.
  
 nextLost
 (
 self
 )
  
 210
  
 Chapter 33.
  
 Simple Craps 
 Players",NA
33.6 Craps1326 Player,"Craps1326 is a subclass of CrapsSimplePlayer who places bets in Craps. This player changes their Pass Line 
 Odds bet on every loss and resets their Pass Line Odds bet to a base amount on each win. The sequence of bet 
 multipliers is given by the current
  Player1326State
  object.
  
 33.6.1 Fields
  
 state 
  
 This is the current state of the 1-3-2-6 betting system. It will be an instance of one of the four states: No 
 Wins, One Win, Two Wins or Three Wins.
  
 33.6.2 Constructors
  
 __init__
 (
 self, table, line, odds
 )
  
 Parameters
  
 •
  table
  (CrapsTable) – The table on which bets are palced
  
 •
  line
  (Outcome) – The line bet outcome
  
 •
  odds
  (Outcome) – The odds bet outcome
  
 Uses the superclass to initialize the Craps1326 instance with a specific
  Table
  for placing
  Bet
 s, and 
 set the line bet (Pass Line or Don’t Pass Line) and odds bet (Pass Line Odds or Don’t Pass Odds).
  
 Then the initial state of
  Player1326NoWins
  is constructed using the odds bet.
  
 33.6.3 Methods
  
 placeBets
 (
 self
 )
  
 Updates the
  Table
  with a bet created by the current state. 
 creation to state object’s currentBet() method.
  
 win
 (
 self, bet
 ) 
  
  
 Parameter
  bet
  (Bet) – The bet that was a winner
  
 This method delegates the bet
  
 Uses the superclass method to update the stake with an amount won. Uses the current state to 
 determine what the next state will be by calling state‘s objects nextWon() method and saving the 
 new state in state
  
 lose
 (
 self, bet
 )
  
 Parameter
  bet
  (Bet) – The bet that was a loser
  
 33.6.
  
 Craps1326 Player
  
 211",NA
33.7 CrapsCancellation Player,"CrapsCancellation is a subclass of CrapsSimplePlayer who places bets in Craps. This player changes their Pass 
 Line Odds bet on every win and loss using a budget to which losses are appended and winings are cancelled.
  
 33.7.1 Fields
  
 sequence 
  
 This List keeps the bet amounts; wins are removed from this list and losses are appended to this list. 
 THe current bet is the first value plus the last value.
  
 33.7.2 Constructors
  
 __init__
 (
 self, table, line odds
 ) 
  
  
  
 Parameters
  
  
  
 •
  table
  (CrapsTable) – The table on which bets are palced
  
  
  
 •
  line
  (Outcome) – The line bet outcome
  
  
  
 •
  odds
  (Outcome) – The odds bet outcome 
  
  
 Invokes the superclass constructor to initialize this instance of CrapsCancellation. Then calls 
  
 resetSequence() to create the betting budget.
  
 33.7.3 Methods
  
 There are few real changes to the original implementation of CancellationPlayer.
  
 See
  Cancellation Player Class
  for more information.
  
 placeBets
 (
 self
 ) 
  
 Creates a bet from the sum of the first and last values of sequence and the preferred outcome. This 
 uses the essential line bet and odds bet algorithm defined above. If no line bet, this is created.
  
 If there’s s line bet and no odds bet, then the odds bet is created.
  
 If both bets are created, there is no more betting to do.",NA
33.8 Simple Craps Players Deliverables,"There are eight deliverables for this exercise.
  
 • The CrapsSimplePlayer abstract superclass. Since this class doesn’t have a body for the oddsBet() 
  
 method, it can’t be unit tested directly.
  
 212
  
 Chapter 33.
  
 Simple Craps 
 Players",NA
THIRTYFOUR,NA,NA
ROLL-COUNTING PLAYER CLASS,"Craps allows a large number of opportunities to bet. The bets have different resolutions, leading to quite a 
 complex game.
  
 In Roulette, each bet’s odds are easier to calculate becuase all bets are resolved at once. Placing multiple bets 
 in Roulette is a simple modification to the payout odds and the probability of a win.
  
 A common Craps strategy is to add bets as a kind of “insurance” against losing the line bet. This means that 
 we’ll have numerous working bets: the mandatory line bet, the behind the line odds bet, plus an additional 
 bets. For example, buying the 6 or 8 is a bet that has a payout that matches the actual odds.
  
 We’ll tackle a particularly complex betting strategy. In this case, a player that judges that a game has gone“too 
 long” without a successful resolution. This is a common fallacy in probability theory. A seven is not“due”. The 
 odds of throwing a seven are always 1/6.",NA
34.1 Roll-Counting Overview,"There is a distinction between one-roll odds and cumulative odds. The one roll odds of rolling a 7 are 1/6. 
 This means that a Pass Line bet will win one time in six on the come out roll. The cumulative odds of rolling a 
 7 on a number of rolls depends on not rolling a seven (a 5/6 chance) for some number of rolls, followed by 
 rolling a 7. The odds are given in the following table.
  
  
 Throws 
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6
  
 Rule
  
 1/6
  
 5/6
  ×
  1/6 
  
 (5/6)
 2
 ×
  1/6 
 (5/6)
 3
 ×
  1/6 
 (5/6)
 4
 ×
  1/6
  
 Odds of 7 
 17% 
  
 31% 
  
 42% 
  
 52% 
  
 60% 
  
 67%
  
 (5/6)
 5
 ×
  1/6
  
 This cumulative chance of rolling a 7 means that the odds of the game ending with a loss because of throwing
  
 a 7 grow as the game progresses.
  
 We can compute the following sequence of odds of losing for larger numbers of rolls of the dice after the point 
 is established: 17%, 28%, 35%, 40%, 43%, 46%, 47%, 48%, 49%.
  
 The idea is that the longer a game runs, the more likely you are to lose your initial Pass Line bet. Con-
 sequently, some players count the thows in the game, and effectively cancel their bet by betting against 
 themselves on the Seven proposition. Note that the Seven proposition is a 1/6 probability that pays “5 for 1”, 
 (effectively 4:1).
  
 While the basic probability analysis of this bet is not encouraging, it does have an interesting design problem: 
 the player now has multiple states. They have Pass Line bet, they can use a Martingale strategy for their Pass
  
 215",NA
34.2 BettingStrategy Design,"BettingStrategy is the abstract superclass for all betting strategies. It contains a single
  Outcome
 , tracks wins 
 and losses of
  Bet
  s built on this
  Outcome
 , and computes a bet amount based on a specific betting strategy.
  
 34.2.1 Fields
  
 outcome 
  
  
 This is the
  Outcome
  that will be watched for wins and losses, as well as used to create new
  Bet
 s.
  
 34.2.2 Constructors
  
 __init__
 (
 self, outcome
 )
  
 Parameter
  outcome
  (Outcome) – The outcome on which this strategy will create bets
  
 Initializes this betting strategy with the given
  Outcome
 .
  
 34.2.3 Methods
  
 createBet
 (
 self
 )
  
 Returns a new
  Bet
  using the outcome
  Outcome
  and any other internal state of this object.
  
 win
 (
 self, bet
 )
  
 Parameter
  bet
  (Bet) – The bet which was a winner
  
 Notification from the
  Player
  that the
  Bet
  was a winner. 
  
 The
  Player
  has responsibility for 
 handling money, this class has responsibility for tracking bet changes.
  
 lose
 (
 self, bet
 )
  
 Parameter
  bet
  (Bet) – The bet which was a loser
  
 Notification from the
  Player
  that the
  Bet
  was a loser.
  
 __str__
 (
 self
 )
  
 Returns a string with the name of the class and appropriate current state information. 
  
 For 
 the superclass, it simply returns the name of the class. Subclasses will override this to provide 
 subclass-specific information.",NA
34.3 NoChangeBetting Class,"NoChangeBetting is a subclass of BettingStrategy that uses a single, fixed amount for the bet. This is useful for 
 unit testing, for modeling simple-minded players, and for line bets in Craps.
  
 34.3.1 Fields
  
 betAmount 
  
  
 This is the amount that will be bet each time. A useful default value is 1.
  
 34.2.
  
 BettingStrategy Design
  
 217",NA
34.4 MartingaleBetting Class,"MartingaleBetting is a subclass of BettingStrategy that doubles the bet on each loss, hoping to recover the 
 entire loss on a single win.
  
 34.4.1 Fields
  
 lossCount 
  
  
 The number of losses. This is the number of times to double the pass line odds bet.
  
 betMultiple 
  
 The the bet multiplier, based on the number of losses. This starts at 1, and is reset to 1 on each win. It is 
 doubled in each loss. This is always
  betMultiple
  = 2
 lossCount
 .
  
 34.4.2 Constructors
  
 __init__
 (
 self, outcome
 ) 
  
  
  
 Parameter
  outcome
  (Outcome) – The outcome on which this strategy will create bets 
  
 Uses the superclass initializer with the given
  Outcome
 . Sets the initial lossCount and betMulti-
  
 plier.
  
 218
  
 Chapter 34.
  
 Roll-Counting Player Class",NA
34.5 Bet1326Betting Class,"Bet1326Betting is a subclass of BettingStrategy that advances the bet amount through a sequence of 
 multipliers on each win, and resets the sequence on each loss. The hope is to magnify the gain on a sequence 
 of wins.
  
 34.5.1 Fields
  
 state 
  
 This is the current state of the 1-3-2-6 betting system. It will be an instance of one of the four subclasses 
 of
  Player1326State
 : No Wins, One Win, Two Wins or Three Wins.
  
 34.5.2 Constructors
  
 __init__
 (
 self, outcome
 ) 
  
  
 Parameter
  outcome
  (Outcome) – The outcome on which this strategy will create bets
  
 Initializes this betting strategy with the given
  Outcome
 . 
 Player1326NoWins
  using outcome.
  
 34.5.3 Methods
  
 createBet
 (
 self
 )
  
 Creates an initial instance of
  
 Returns a new
  Bet
  using the currentBet() method from the state object.
  
 win
 (
 self, bet
 ) 
  
  
  
 Parameter
  bet
  (Bet) – The bet which was a winner 
  
  
 Determines the next state when the bet is a winner. Uses state‘s nextWon() method and saves 
  
 the 
 new state in state.
  
 lose
 (
 self, bet
 )
  
 34.5.
  
 Bet1326Betting Class
  
 219",NA
34.6 CrapsOneBetPlayer class,"CrapsOneBetPlayer is a subclass of CrapsPlayer and places one bet in Craps. The single bet is one of the bets 
 available on the come out roll (either Pass Line or Don’t Pass Line). This class implements the basic procedure 
 for placing the line bet, using an instance of BettingStrategy to adjust that bet based on wins and losses.
  
 34.6.1 Fields
  
 lineStrategy 
  
  
 An instance of BettingStrategy that applies to the line bet.
  
 Generally, this is an instance of NoChangeBetting because we want to make the minimum line bet and 
 the maximum odds bet behind the line.
  
 34.6.2 Constructors
  
 __init__
 (
 self, table, lineStrategy
 ) 
  
 Constructs the CrapsOneBetPlayer with a specific
  Table
  for placing
  Bet
  s. This will save the given 
 BettingStrategy in lineStrategy.
  
 Python Creation of A Player
  
 passLine= table.dice.get( ""Pass Line"" )
  
 bet= new MartingaleBetting( passLine )
  
 passLineMartin= new CrapsOneBetPlayer( bet );
  
 1. Get the basic Pass Line
  Outcome
  from the Dice.
  
 2. Creates a Martingale betting strategy focused on the basic Pass Line outcome.
  
 3. Creates a one-bet player, who will employ the Martingale betting strategy focused on the basic Pass 
  
 Line outcome.
  
 34.6.3 Methods
  
 placeBets
 (
 self
 )
  
 Updates the
  Table
  with the various
  Bet
  s. There is one basic betting rule.
  
 1. If there is no line bet, create the line
  Bet
  from the lineStrategy.
  
 220
  
 Chapter 34.
  
 Roll-Counting Player Class",NA
34.7 CrapsTwoBetPlayer class,"CrapsTwoBetPlayer is a subclass of CrapsOneBetPlayer and places one or two bets in Craps. The base bet is 
 one of the bets available on the come out roll (either Pass Line or Don’t Pass Line). In addition to that, an odds 
 bet (either Pass Line Odds or Don’t Pass Odds) can also be placed. This class implements the basic procedure 
 for placing the line and odds bets, using two instances of BettingStrategy to adjust the bets based on wins and 
 losses.
  
 Typically, the line bet uses an instance of NoChangeBetting.
  
 The odds bets, however, are where we want to put more money in play.
  
 34.7.1 Fields
  
 oddsStrategy 
  
  
 An instance of BettingStrategy that applies to the line bet.
  
 34.7.2 Constructors
  
 34.7.3 Methods
  
 placeBets
 (
 self
 )
  
 Updates the
  Table
  with the various
  Bet
  s. There are two basic betting rules.
  
 1. If there is no line bet, create the line
  Bet
  from the lineStrategy.
  
 2. If there is no odds bet, create the odds
  Bet
  from the oddsStrategy.
  
 win
 (
 self, bet
 )
  
 Parameter
  bet
  (Bet) – The bet which was a winner
  
 Notification from the
  Game
  that the
  Bet
  was a winner. The superclass handles the money won and 
 the line bet notification. This subclass adds a comparison between the bet’s
  Outcome
  and the
  
 34.7.
  
 CrapsTwoBetPlayer class
  
 221",NA
34.8 CrapsSevenCountPlayer class,"CrapsSevenCountPlayer is a subclass of CrapsTwoBetPlayer and places up to three bets in Craps. The base bet 
 is a Pass Line bet. In addition to that, a Pass Line Odds bet can also be placed. If the game runs to more than 
 seven throws, then the “7” proposition bet (at 4:1) is placed, using the Martingale strategy.
  
 The Pass Line bet uses an instance of NoChangeBetting. 
 Bet1326Betting.
  
 34.8.1 Fields
  
 The Pass Line Odds bet uses an instance of
  
 sevenStrategy 
  
 The BettingStrategy for the seven bet. Some argue that this should be a no-change strategy. The bet is 
 rare, and – if effect – the player bets against themself with this. One could also argue that it should be a 
 Martingale because each throw after the seventh are less and less likely to win.
  
 throwCount 
  
 The number of throws in this game. This is set to zero when we place a line bet, and incremented each 
 time we are allowed to place bets.
  
 34.8.2 Constructors
  
 __init__
 (
 self, table
 )
  
 This will create a NoChangeBetting strategy based on the Pass Line
  Outcome
 . It will also create a 
 MartingaleBetting strategy based on the Pass Line Odds
  Outcome
 . These will be given to the 
 superclass constructor to save the game, the line bet and the odds bet. Then this constructor 
 creates a Bet1326Betting strategy for the Seven Proposition
  Outcome
 .
  
 34.8.3 Methods
  
 placeBets
 (
 self
 )
  
 Updates the
  Table
  with the various
  Bet
  s. There are three basic betting rules.
  
 1. If there is no line bet, create the line
  Bet
  from the lineStrategy. Set the throwCount to 
  
 zero.
  
 2. If there is no odds bet, create the odds
  Bet
  from the oddsStrategy.
  
 3. If the game is over seven throws and there is no seven proposition bet, create the proposition 
  
 Bet
  from the sevenStrategy.
  
 Each opportunity to place bets will also increment the throwCount by one.
  
 222
  
 Chapter 34.
  
 Roll-Counting Player Class",NA
34.9 Roll-Counting Deliverables,"There are two groups of deliverables for this exercise. The first batch of deliverables are the new Betting 
 Strategy class hierarchy and unit tests. The second batch of deliverables are the two revised Craps Player 
 classes, the final Roll Counter Player, and the respective unit tests.
  
 Also, note that these new classes make the previous CrapsSimplePlayer, CrapsMartingale, Craps1326 and 
 CrapsCancellation classes obsolete. There are two choices for how to deal with this change: remove and 
 reimplement. The old calsses can be removed, and the Simulator reworked to use the new versions. The 
 alternative is to reimplement the original classes as
  Facade
  over the new classes.
  
 Betting Strategy class hierarchy
 . There are four classes, each with an associated unit test in this group of 
 deliverables.
  
 • The BettingStrategy superclass. This class is abstract; there is no unit test.
  
 • The NoChangeBetting class.
  
 • A unit test for the NoChangeBetting class. 
  
 methods do not change the bet amount.
  
 • The MartingaleBetting class.
  
 This will simply confirm that the win() and lose()
  
 • A unit test for the MartingaleBetting class. This will confirm that the win() method resets the bet 
  
 amount 
 and lose() method doubles the bet amount.
  
 • The Bet1326Betting class.
  
 • A unit test for the Bet1326Betting class. This will confirm that the win() method steps through the 
  
 various states, and the lose() method resets the state.
  
 CrapsPlayer class hierarchy
 . There are three classes, each with an associated unit test in this group of 
 deliverables.
  
 • The CrapsOneBetPlayer class.
  
 • A unit test for the CrapsOneBetPlayer class. One test can provide a No Change strategy for a Pass Line bet 
 to verify that the player correctly places Line bets. Another test can provide a Martingale strategy for a 
 Pass Line bet to verify that the player correctly changes bets on wins and losses.
  
 • The CrapsTwoBetPlayer class.
  
 • A unit test for the CrapsTwoBetPlayer class. One test can provide a No Change strategy for a Pass Line bet 
 and a Martingale strategy for a Pass Line Odds bet to verify that the player correctly places Line bets 
 and correctly changes bets on wins and losses.
  
 • The CrapsSevenCountPlayer class.
  
 34.9.
  
 Roll-Counting Deliverables
  
 223",NA
THIRTYFIVE,NA,NA
CONCLUSION,"The game of Craps has given us an opportunity to extend and modify an application with a considerable 
 number of classes and objects. It is large, but not overly complex, and produces interesting results. Further, as 
 a maintenance and enhancement exercise, it gave us an opportunity to work from a base of software, 
 extending and refining the quality of the design.
  
 We omitted exercises which would integrate this package with the
  Simulator
  and collect statistics. This step, 
 while necessary, doesn’t include many interesting design decisions. The final deliverable should be a working 
 application that parses command-line parameters, creates the required objects, and creates an instance of
  
 Simulator
  to collect data.
  
 Refactoring
 . We note that many design decisions required us to explore and refactor a great deal of the 
 application’s design. In writing this part, we found it very difficult to stick to our purpose of building up the 
 design using realistic steps and realistic problem solving. A book with a description of an already-completed 
 structure does not help new designers learn the
  process
  of design, and does not help people to identify design 
 problems and correct them. Because of that philosophy, the complete refactoring of the design in the
  Design 
 Cleanup and Refactoring
  chapter was an important activity because it is the kind of thing that distinguishes a 
 good design from a haphazard design.
  
 Our observation is that this kind of design rework happens late in the life of a project, and project managers 
 are uncomfortable evaluating the cost and benefit of the change. Further, programmers are unable to express 
 the cost of accumulating
  technical debt
  by making a series of less-than-optimal decisions.
  
 Simpler is Better
 . Perhaps, the most important lesson that we have is the constant search for something we 
 call
  The Big Simple
 . We see the history of science as a search for simpler explanations of natural phenomena. 
 The canonical example of this is the distinction between the geocentric model and the heliocentric model of 
 the solar system. Both can be made to work: astronomers carefully built extremely elaborate models of the 
 geocentric heavens and produced accurate predictions of planetary positions. However, the model of 
 planetary motion around the sun describes real phenomena more accurately and has the added benefit of 
 being much simpler than competing models.
  
 To continue this rant, we find that software designers and their managers do not feel the compulsion and do 
 not budget the time to identify the grand simplification that is possible. In some cases, the result of 
 simplifying the design on one axis will create more classes. Designers lack a handy metric for “understand-
 ability”; managers are able to count individual classes, no matter how transparently simple. Designers often 
 face difficulties in defending a design with many simple classes; some people feel that a few complex classes is 
 “simpler” because it has fewer classes.
  
 As our trump card, we reference the metrics for complexity. McCabe’s Cyclomatic Complexity penalizes if-
 statements. By reducing the number of if-statements to just those required to create an object of the proper 
 class, we reduce the complexity. The Halstead metrics penalize programs with lots of internal operators and 
 operands when compared with the number of operands in the interface. Halstead measures simple, 
 transparent classes as less complex. Neither measure penalizes overall size in lines of code, but rather they
  
 225",NA
Part IV ,NA,NA
Blackjack,227,NA
THIRTYSIX,NA,NA
BLACKJACK DETAILS,"In the first section we will present elements of the game of Blackjack. Blackjack uses cards and has fairly 
 complex rules for counting the number of points in a hard of cards.
  
 Blackjack offers relatively few bets, most of which are available based on the state of the game. We’ll cover 
 these bets and the conditions under which they are allowed in the second sectionj.
  
 Finally, we will describe some common betting and playing strategies that we will simulate. In this case, we 
 have playing strategies that are unique to Blackjack, combined with betting strategies initially defined in
  
 Roulette
  and reworked in
  Craps
 .",NA
36.1 Blackjack Game,"Blackjack centers around
  hands
  composed of
  cards
  drawn from one or more standard 52-card
  decks
 . The 
 standard deck has 13
  ranks
  in 4
  suits
 ; the suit information has no bearing on game play. The player and the 
 house are both dealt hands, starting with two cards. The house has one card exposed (the
  up card
  ) and one 
 card concealed (the
  hole card
  ), leaving the player with incomplete information about the state of the game. 
 The player’s objective is to make a hand that has more points than the dealer, but less than or equal to 21 
 points. The player is responsible for placing bets when they are offered, and taking additional cards to 
 complete their hand. The dealer will draw additional cards according to a simple rule: when the dealer’s hand 
 is 16 or less, they will draw cards (or
  hit
 ), when it is 17 or more, they will not draw additional cards (or
  stand 
 pat
 ).
  
 An interesting complication is the point values of the cards. The number cards (2-10) have the expected point 
 values. The face cards (Jack, Queen and King) all have a value of 10 points. The Ace can count as one point or 
 eleven points. Because of this, an Ace and a 10 or face card totals 21. This two-card winner is called 
 “blackjack”. Also, when the points include an ace counting as 11, the total is called
  soft
  ; when the ace counts 
 as 1, the total is called
  hard
 . For example, A-5 is called a soft 16 because it could be considered a hard 6. A-10-
 5 is a hard 16.
  
 The betting surface is marked with two places for bets: a single bet, placed before any cards are dealt, and an 
 insurance bet, offered only when the dealer’s up card is an ace. There are a few additional bets, and a few 
 player choices. We’ll step through some variations on the sequence of play to see the interactions a player has 
 during a game. Note that a casino table seats a number of players; like Craps and Roulette, the player opposes 
 the house, and the presence or absence of other players has no bearing on the game.
  
 Note: 
  
 Rule Variations
  
 There are seemingly endless variations in the exact playing rules used by different casinos. We’ll focus on a 
 relatively common version of the rules. With this as a basis, a number of variations can be explored.
  
 Typical Scenario
 . The player places an initial bet. Since the bet is “blind”, it is like an ante in poker. The player 
 and dealer are each dealt a pair of cards. Both of the player’s are face up, the dealer has one
  
 231",NA
36.2 Available Bets and Choices,"Unlike Roulette and Craps, Blackjack has only a few available bets. Generally, the following choices all involve 
 accepting an offer by creating an additional bet.
  
 •
  Ante
 . This bet is mandatory to play. It must be within the table limits.
  
 •
  Insurance
 . This bet is offered only when the the dealer shows an ace. The amount must be half the ante. 
 Note that the even money offer is an option for resolution of the ante instead of an insurance bet. It is 
 sometimes described as a separate kind of bet, but this doesn’t seem accurate.
  
 •
  Split
 . This can be thought of as a bet that is offered only when the the player’s hand has two cards are of 
 equal rank. Or this can be thought of as a playing option, akin to hitting or standing. The amount of the 
 bet must match the original ante.
  
 •
  Double
 . This can be thought of as a bet that is offered instead of a taking an ordinary hit. Some casions 
 only offer this when the the player’s hand has two cards. Or this can be thought of as a playing option, 
 akin to hitting or standing. The amount of the bet must match the original ante.
  
 Blackjack also offers the player some choices that don’t involve creating additional bets. In the casino these 
 are shown through gestures that can be seen clearly by dealers and other casino staff.
  
 •
  Even Money
 . This resolution of insurance is offered only when the the dealer shows an ace and the 
 player shows 21 in two cards. It is offered instead of an insurance bet. If accepted, the hand is resolved. 
 If declined, the insurance offer can then be accepted or declined.
  
 •
  Hit
 . The player is offered the opporutunity to take another card when their total is less than 21. If they 
 decline the hit, they are standing pat. In casinos that allow a double down on any number of cards, the 
 player has three choices: hit, double down or stand.
  
 Play begins with a sequence of offers which can be accepted or declined: insurance, even money resolution of 
 insurance, and splitting a hand. After these offers, the player must select between the three remaining choices 
 (hit, double or stand) for each of their hands with a total less than 21.
  
 In Roulette, there are no additional offers for the player to accept or decline. In Craps, we ignored the only 
 offer made to a player. See
  Some Betting Strategies
  for details on this rule. Adding this interaction to Craps 
 would require defining an additional method for CrapsPlayer to accept or decline an offer. We would also 
 have the
  CrapsGame
  interrogate the
  Table
  for the presence of come point odds bets, make the offer to the 
 player, and then activate or deactivate the bet for the next throw only. This level of interaction was a nuance 
 we elected to ignore at that time.",NA
36.3 Betting Strategies,"Because of the complexity of Blackjack, the strategies for play focus on the cards themselves, not on the bets. 
 Some players use a single fixed bet amount. Some players will attempt to count cards, in an effort to 
 determine the approximate distribution of cards in the deck, and vary their play or bets accordingly. The 
 casinos actively discourage counting in a number of ways. The most common way is to shuffle 5 decks of 
 cards together, and only deal the first 156 or so of the available 260 cards. Additionally, they will ask people 
 to leave who are obviously counting.
  
 The player’s responses to the various offers are what defines the playing strategy in Blackjack. The informa-
 tion available to the player is their hand (or hands), and the dealer’s up card. Therefore, all of the strategies 
 for play decompose to a matrix showing the player’s total vs. dealer’s up card and a recommendation for 
 which offers to accept or decline.
  
 36.2.
  
 Available Bets and Choices
  
 233",NA
THIRTYSEVEN,NA,NA
BLACKJACK SOLUTION OVERVIEW,"We will present a survey of the new classes gleaned from the general problem statement in
  Problem 
 Statement 
 as well as the problem details in
  Blackjack Details
 . This survey is drawn from a quick overview of 
 the key nouns in these sections. We will not review those nouns already examined for Craps and Roulette.",NA
37.1 Preliminary Survey of Classes,"In reading the background information and the problem statement, we noticed a number of nouns that 
 seemed to be new to the game of Blackjack.
  
  
 • Card
  
  
 • Deck
  
  
 • Point Value
  
  
 • Hand
  
  
 • Number Card
  
  
 • Face Card
  
  
 • Offer
  
  
 • Insurance
  
  
 • Split
  
  
 • Double
  
  
 • Hit
  
  
 • Stand
  
  
 • Player
  
  
 • Game 
  
 The following table summarizes some of the new classes and responsibilities that we can identify from the 
 problem statement. This is not the complete list of classes we need to build. As we work through the exercises, 
 we’ll discover additional classes and rework some of these classes more than once.
  
 We also have a legacy of classes available from the Roulette and Craps solutions. We would like to build on 
 this infrastructure as much as possible.
  
 235",NA
37.2 Preliminary Class Structure,"Card Responsibilities 
  
 Three apparent subclasses: NumberCard, FaceCard and Ace` 
  
 A standard playing card with a rank and a suit. Also has a
  point value
  from 1 to 11. Aces have 
 point values that depend on the
  Hand
 .
  
 Collaborators 
  
 Collected in a Deck; collected into
  Hand
 s for each
  Player
 ; collected into a
  Hand
  for the dealer; 
 added to by
  Game
 .
  
 Deck Responsibilities 
  
 A complete set of 52 standard
  Card
 s.
  
 Collaborators 
  
 Used by the
  Game
  to contain
  Card
 s.
  
 Hand Responsibilities 
  
 A collection of
  Card
 s with one or two point values: a hard value (an ace counts as 1) and a soft 
 value (an ace counts as 11). The house will reveal one
  Card
  to the player.
  
 Collaborators 
  
 A
  Player
  may have 1 or more
  Hand
 s; a
  Hand
  has 2 or more
  Card
 s. The
  Game
  adds
  Card
 s to the
  
 Hand
 . The
  Game
  checks the number of cards, the point totals and the ranks of the cards to 
 offer different bets. The
  Game
  compares the point totals to resolve bets.
  
 Player Responsibilities 
  
 Places the initial ante
  Bet
 s, updates the stake with amounts won and lost. 
  
 Accepts or 
 declines offered additional bets, including insurance, and split. Accepts or declines offered 
 resolution, including even money. Chooses among hit, double and stand options.
  
 Collaborators 
  
 Uses
  Table
 , and one or more
  Hand
 s. Examines the dealer’s
  Hand
 . Used by game to respond to 
 betting offers. Used by
  Game
  to record wins and losses.
  
 Game Responsibilities 
  
 Runs the game: offers bets to
  Player
 , deals the Cards from the Deck to
  Hand
 s, updates the 
 state of the game, collects losing bets, pays winning bets. Splits
  Hand
 s. Responds to player 
 choices of hit, double and stand. This encapsulates the basic sequence of play into a single 
 class.
  
 Collaborators 
  
 Uses Deck,
  Table
 ,
  Outcome
 ,
  Player
 .",NA
37.3 A Walkthrough,"The unique, new feature of Blackjack is the more sophisticated collaboration between the game and the 
 player. This interaction involves a number of offers for various bets, and bet resolution. Additionally, it 
 includes offers to double, hit or stand. We’ll examine parts of a typical sequence of play to assure ourselves 
 that we have all of the necessary collaborations and responsibilities.
  
 236
  
 Chapter 37.
  
 Blackjack Solution 
 Overview",NA
37.4 Blackjack Solution Questions and Answers,"Will we really need both Deck and the multiple deck Shoe? Wouldn’t it be simpler to combine this func-
 tionality into a single class?
  
 There are two separate responsibilities here. The deck owns the basic responsibility to build the 52 
 cards. The shoe, on the other hand, owns the responsibility to deal cards to hands.
  
 We want to be able to simulate games with 1 to 8 decks. A single deck game can simply deal 
 directly from the deck. In a multi-deck game, all of the decks are shuffled together and loaded into 
 a
  shoe
  for dealing. The difference between one deck and a five-deck shoe is that the shoe can 
 produce 20 kings in a row. While rare, our simulation does need to cover situations like this.
  
 Also, we may want to build a slightly different shoe that simulates the continuous shuffling 
 machine that some casinos use. In this case, each hand is reshuffled back into the shoe, preventing 
 any attempt at card counting. We don’t want to disturb the basic, common deck when introducing 
 this additional feature.
  
 Won’t all those player interactions break our design?
  
 That’s unlikely. All of that player interaction is in addition to the placeBets() interface. Since we’ve 
 separated the core features of all players from the game-specific features, we can add a subclass 
 to player that will be handle the Blackjack interaction. This new player subclass will have a 
 number of additional methods to handle insurance, even money, split and the regular play 
 questions of hit, double and stand.
  
 In parallel, we’ve separated the core features of all games from the unique features for a specific 
 game. We can now add a subclass for Blackjack which adds a number of methods to offer 
 insurance, even money, split and the regular play questions of hit, double and stand to the 
 Blackjack player.
  
 I can’t find an Outcome in Blackjack. Is it the Ante? If so, the odds vary based on the player’s Hand, but that 
 doesn’t seem to be a RandomEvent.
  
 Good point. We’ll examine this in detail in the exercises. Clearly, the bets are placed on the Ante 
 and Insurance as the two core
  Outcome
  s in Blackjack. The Insurance outcome (really a“dealer has 
 blackjack” outcome) is fixed at 2:1. The ante payoff depends on a complex condition of the hand: 
 for a soft 21, or blackjack, it pays 3:2; otherwise it pays 1:1. This will lead to a new subclass of
  
 Outcome
  that collaborates with the hand to determine the payout to use.
  
 The “even money” is offered before ordinary insurance to a player with blackjack. It, however, 
 pays even money on the ante, and doesn’t create a new bet; in this respect it could be thought of 
 as a change in the outcome on which the ante bet is created. Accepting the even money offer is a 
 little bit like moving the ante to a “even money for dealer blackjack” outcome, which has 1:1 odds 
 instead of 3:2 odds. Further, this special outcome is resolved before the dealer peeks at their hole 
 card. Perhaps this is a special best resolution procedure, not a proper instance of 
 Outcome
 .
  
 238
  
 Chapter 37.
  
 Blackjack Solution 
 Overview",NA
THIRTYEIGHT,NA,NA
"CARD, DECK AND SHOE CLASSES","This chapter introduces a number of simple classes. When exploring Roulette, we introduced classes very 
 slowly. In this chapter, we are introducing the class hierarchy for cards, the deck of cards and the shoe, used 
 by the dealer to create hands. The next chapter will introduce the hand, and the problems of scoring the value 
 of the hand.",NA
"38.1 Card, Deck and Shoe Overview","Card
 . The standard playing card has two attributes: a rank (Ace, 2 through 10, Jack, Queen, or King) and a suit 
 (Clubs, Diamonds, Hearts or Spades). The set of all 52 combinations comprises a full deck. Additionally, in 
 Blackjack, a card has a point value, which is a number from 1 to 11, and is based on the rank. In the case of an 
 Ace, it is also based on the hand in which the card is evaluated. This collaboration with a hand complicates the 
 responsibilities for a single card. However, the basic set of responsibilities of the
  Card
  class include keeping 
 the rank, suit and point value of a single standard playing card.
  
 The issue of suit requires some care. In the game of Blackjack, suits don’t matter. Indeed, for the purposes of 
 simulation, we could simply discard the notion of suit. However, for the purposes of making a reasonably 
 complete model of real-world objects, it makes sense to implement the suit of a card, even if we do nothing 
 with it.
  
 We’d like to provide symbolic variable names for the suits. In Java we’ll use static final variables to define the 
 suits. In Python we’ll use class variables. This will give us four named constants for each of the suits, 
 something that tends to make the software easier to read. Similarly, we’ll provide named constants for the 
 three face cards and the ace.
  
 Points
 . We have three different rules for establishing the point value of a card. This is a big hint that we have 
 three subclasses. One subclass includes the Aces, which are either 1 or 11 points. Another subclass includes 
 the number cards from 2 to 10, where the rank is the point value. Finally, the third subclass includes the face 
 cards, where the point value is fixed at 10. These three subclasses implement slightly different versions of a 
 method to return the point value of the card. For more discussion on this, see
  Card-Deck-Shoe Questions and 
 Answers
  FAQ for more discussion.
  
 The problem of determining the value of aces is something we will have to defer until after we create the 
 hand class. First, we’ll implement the basic card, then we’ll develop the hand, and decide how the hand 
 computes its number of points from the cards. We do note that the terminology used gives us some hint as to 
 how to structure our design. Players refer to a
  soft
  total and a
  hard
  total. An A-6 hand is called a soft 17, and a 
 hard 7. A soft hand has some flexibility in how it is played. If you hit a soft 17, and get a face card (for example, 
 a Jack), you now have an A-J-6, totalling hard 17. Considering this, we can provide two point-value functions 
 for each rank, a hard value and a soft value. For all but aces, the two values are the same. For aces, the two 
 values are different. This would allow a hand to compute a hard total and a soft
  
 239",NA
38.2 Card-Deck-Shoe Questions and Answers,"Why are there three subclasses of Card? Isn’t it simpler to have one class and use an if-statement to sort out 
 the point values.
  
 Primarily, there are three classes because they have different behaviors. Merging them into a single 
 class and sorting out the behaviors with an if-statement is often a problem.
  
 240
  
 Chapter 38.
  
 Card, Deck and Shoe Classes",NA
38.3 Card Superclass,"class Card
 ()
  
 Card
  defines a basic playing card. It has a rank, a suit, a hard point value and a soft point value. The point 
 value methods are defined for the number cards from 2 to 10. Two subclasses handle face cards, where the 
 point values are both 10, and aces, where the soft point value is 1, and the hard point value is 11.
  
 This class also defines symbolic names for the suits (Clubs, Diamonds, Hearts and Spades) and face cards 
 (Jack, Queen and King).
  
 Here are Unicode characters for the suits.
  
 38.3.
  
 Card Superclass
  
 241",NA
38.4 FaceCard Class,"FaceCard is a
  Card
  with a point value of 10. This defines jack, queens and kings.
  
 38.4.1 Methods
  
 softValue
 (
 self
 )
  
 Returns the soft value of this card, 10.
  
 hardValue
 (
 self
 )
  
 Returns the hard value of this card, 10.
  
 __str__
 (
 self
 )
  
 Returns a short String displaying the rank and suit of this card. The ranks should be translated to 
 single letters: 11 to 'J', 12 to 'Q' and 13 to 'K'.",NA
38.5 AceCard Class,"AceCard is a
  Card
  with a soft point value of 11 and a hard point value of 1. This definces Aces.
  
 38.5.1 Methods
  
 softValue
 (
 self
 )
  
 Returns the soft value of this card, 11.
  
 hardValue
 (
 self
 )
  
 Returns the hard value of this card, 1.
  
 __str__
 (
 self
 )
  
 Returns a short String displaying the rank and suit of this card. The rank is always 'A'.",NA
38.6 Deck class,"Deck defines the standard deck of 52 cards. It both constructs the deck and acts as a container for one 
 instance of a deck.
  
 38.4.
  
 FaceCard Class
  
 243",NA
38.7 Shoe class,"Shoe defines the dealer’s shoe, which contains from 1 to 8 decks of cards. For one deck shoes, one card is 
 reserved as undealable. For multiple deck shoes from 1 to 3 decks can be left undealt. The exact number is 
 selected at random within 6 cards of the expected number of decks.
  
 38.7.1 Fields
  
 deal
  
 An Interator that is used to pick the next card from the shoe.
  
 stopDeal 
  
  
 The approximate number of decks to be left undealt in the shoe.
  
 244
  
 Chapter 38.
  
 Card, Deck and Shoe Classes",NA
38.8 Card-Deck-Shoe Deliverables,"There are ten deliverables for this exercise.
  
 • The three classes of the
  Card
  class hierarchy, including FaceCard and AceCard.
  
 • A class which performs a unit tests of the
  Card
  class hierarchy. The unit test should create several 
  
 instances of
  Card
 , FaceCard and AceCard.
  
 • The Deck class.
  
 • A class which performs a unit test of the Deck class. This simply creates a Deck object and confirms the 
 total number of cards. A thorough test would also check some individual
  Card
  objects in the cards 
 collection.
  
 • The Shoe class.
  
 • A class which performs a unit test of the Shoe class. This simply creates a Shoe object and confirms that it 
 deals cards. In order to test the shuffle() method, you will need to construct the Shoe with a random 
 number generator that has a fixed seed and produces cards in a known sequence.",NA
THIRTYNINE,NA,NA
HAND AND OUTCOME CLASSES,"This chapter introduces the hand, and the problems of scoring the value of the hand. It also introduces a 
 subclass of
  Outcome
  that can handle the more complex evaluation rules for Blackjack.",NA
39.1 Hand Overview,"The hand of cards is both a container for cards, but is also one dimension of the current state of the player’s 
 playing strategy. A player may have multiple hands, and the hands are resolved independently.
  
 For each hand, the responsibilities include collecting the cards, producing a hard and soft point total and 
 determining the appropriate payout odds.
  
 Collecting cards is trivial. Each hand is a simple
  bag
  or
  multiset
  of cards. A hand can’t be any kind of Set 
 because there can easily be duplicate cards in a multiple deck game. In an 8-deck game, there are 8 separate",NA
39.2 Hand Total Class Design,"HandTotal computes a total of the cards in a hand. There are distinct subclasses for the two algorithms.
  
 39.2.1 Constructor
  
 __init__
 (
 self, hand
 ) 
  
  
  
 Parameter
  hand
  (Hand) – The hand for which to compute a total 
  
 Creates a new HandTotal object associated with a given hand.
  
 39.2.2 Methods
  
 total
 (
 self, card=None
 ) 
  
 Computes a total of all the cards in the associated hand. If card is not None, omit the the indicated card 
 from the total.
  
 This method is abstract, it should return
  NotImplemented
 . Each subclass will provide an implemen-
 tation.
  
 Parameter
  card
  (Card) – A card to exclude from the total",NA
39.3 Hand Hard Total Class Design,"class HandHardTotal
 () 
  
  
 Computes a hard total of the cards in a hand.
  
 total
 (
 self, card=None
 ) 
  
 Computes the hard total of all the cards in the associated hand. If card is not None, omit the the 
 indicated card from the total.
  
 Parameter
  card
  (Card) – A card to exclude from the total",NA
39.4 Hand Soft Total Class Design,"class HandSoftTotal
 () 
  
  
 Computes a soft total of the cards in a hand.
  
 250
  
 Chapter 39.
  
 Hand and Outcome Classes",NA
39.5 Card Class Updates,"Each subclass of Card needs to provide a method that sets the hand’s total algorithm.
  
 setAltTotal
 (
 hand
 ) 
  
  
  
 Parameter
  hand
  (Hand) – The hand for which to set a total algorithm 
  
 There are two different implementations for this method in
  Card
 , and AceCard.
  
 Note that each implementation differs only in what is done with the soft total is 21 or less. With a 
 little care, this single difference can be factored out into the AceCard subclass.
  
 39.5.1 Card Class
  
 To determine what alternative total object is appropriate for this hand, do the following.
  
 1. Get the soft total of all cards except this one.
  
 2. Add the soft points of this card. This happens to be the same as the hard points, but a good program 
  
 doesn’t repeat this piece of information; it uses the
  Card.softValue()
  method.
  
 3. If this is over 21, then set the
  Hand.altTotal
  to to
  Hand.hard
 .
  
 If the soft total is 21 or less, then the
  Hand.altTotal
  is left untouched.
  
 39.5.2 AceCard Class
  
 To determine what alternative total object is appropriate for this hand, do the following.
  
 1. Get the soft total of all cards except this one.
  
 2. Add the soft points of this card. This happens to be 11 for an Ace, but a good program doesn’t repeat 
  
 this piece of information; it uses the
  Card.softValue()
  method.
  
 3. If this is over 21, then set the
  Hand.altTotal
  to to
  Hand.hard
 .
  
 Otherwise, the soft total is 21 or less, then set the
  Hand.altTotal
  to
  Hand.soft
 .",NA
39.6 Hand Class Design,"class Hand
 () 
  
 Hand
  contains a collection of individual
  Card
 s, and determines an appropriate total point value for the hand.
  
 39.5.
  
 Card Class Updates
  
 251",NA
39.7 Hand Deliverables,"There are six deliverables for this exercise.
  
 • The HandTotal class hierarchy: HandTotal,
  HandHardTotal
 ,
  HandSoftTotal
 .
  
 • A unit test for each of these classes.
  
 • The
  Hand
  class.
  
 • A class which performs a unit tests of the
  Hand
  class. The unit test should create several instances of 
  
 Card
 , FaceCard and AceCard, and add these to instances of
  Hand
 , to create various point totals.
  
 • The
  Card
  and AceCard modifications required to set the appropriate values in a
  Hand
  
 • A set of unit tests for assembling a hand and changing the total object in use to correctly compute 
  
 hard or soft totals for the hand.
  
 39.7.
  
 Hand Deliverables
  
 253",NA
FORTY,NA,NA
BLACKJACK TABLE CLASS,"The bets in Blackjack are associated with a hand. This will lead us to create a subclass of table to handle this 
 complexity. In order to manage the relationships between hand and bet, we’ll rework hand, also.",NA
40.1 Blackjack Table Overview,"When we look at the game of Blackjack, we note that a player’s
  Hand
  can be split. In some casinos, resplits are 
 allowed, leading to the possibility of 3 or more
  Hand
 s. Each individual
  Hand
  has a separate ante
  Bet
  and 
 seperate resolution. This is different from the way bets are currently managed for Roulette and Craps.
  
 We have several alternatives.
  
 • Assign responsibility to the
  Table
  to keep track of bets by
  Player
  tied to the various
  Hand
 s.
  
 This would make the
  Hand
  a potential key into a Map that associated a
  Hand
  with a
  Bet
 . However, 
 Hand
 s change state, making them poor choices for keys to a Map.
  
 • We could put a reference to a
  Hand
  into the
  Bet
 . In this way, as each
  Bet
  is resolved, the relevant
  Hand 
  
 can be evaluated.
  
 • We could put a reference to the Ante
  Bet
  in the
  Hand
 . In this way, as each
  Hand
  is resolved, the 
  
 relevant
  
 Bet
  can be paid or lost.
  
 We’ll design
  Hand
  to contain the associated ante
  Bet
 . This is least disruptive to the
  Bet
  which is a simple thing 
 used widely in other games.
  
 Additional Bets
 . While most
  Bet
 s are associated with a specific
  Hand
 , the insurance
  Bet
  is always resolved 
 before an additional hand can be created. There doesn’t seem to be an essential association between the 
 initial
  Hand
  and the insurance
  Bet
 . We can treat insurance as a
  Bet
  that follows the model established for 
 Craps and Roulette.
  
 Currently,
  Bet
 s are placed on the
  Table
 . If we create a subclass named
  BlackjackTable
  that uses a
  Hand 
 when 
 creating a
  Bet
 , we can have this method do both tasks: it can attach the
  Bet
  to the
  Hand
 , and it can save the
  
 Bet
  on the
  Table
 .",NA
40.2 BlackjackTable Class,"class BlackjackTable
 ()
  
 BlackjackTable
  is a
  Table
  that handles the additional association between
  Bet
 s and specific
  Hand
 s in 
 Blackjack.
  
 255",NA
40.3 Hand Rework,"Hand
  contains a collection of individual
  Card
 s, and determines an appropriate total point value for the hand. 
 We need to add a field and some appropriate methods for associating a Bet with a Hand.
  
 40.3.1 Fields
  
 ante
  
 Holds a reference to the ante
  Bet
  for this hand. When this hand is resolved, the associated bet is paid 
 and removed from the table.
  
 40.3.2 Methods
  
 setBet
 (
 self, ante
 ) 
  
  
  
 Parameter
  ante
  (Bet) – The initial bet required to play 
  
 Sets 
 the ante
  Bet
  that will be resolved when this hand is finished.
  
 getBet
 (
 self
 ) 
  
  
 Returns the ante
  Bet
  for this hand.",NA
40.4 Blackjack Table Deliverables,"There are four deliverables for this exercise.
  
 • The revised
  Hand
  class.
  
 • A class which performs a unit tests of the
  Hand
  class. The unit test should create several instances of
  
 Card
 , FaceCard and AceCard, and add these to instances of
  Hand
 , to create various point totals. 
 Additionally, the unit test should create a
  Bet
  and associate it with the
  Hand
 .
  
 256
  
 Chapter 40.
  
 Blackjack Table Class",NA
FORTYONE,NA,NA
BLACKJACK GAME CLASS,"After reviewing the procedure provided in
  A Walkthrough
 , we’ll define the basic game class for Blackjack. 
 This will require a stub class for a Blackjack Player. We’ll also revisit the fundamental relationship between 
 Game, Hand and Player. We’ll invert our viewpoint from the Player containing a number of Hands to the 
 Hands sharing a common Player.",NA
41.1 Blackjack Game Overview,"The sequence of operations in the game of Blackjack is quite complex. We can describe the game in either of 
 two modes: as a sequential procedure or as a series of state changes.
  
 • A sequential description means that the state is identified by the step that is next in the sequence.
  
 • The state change description is what we used for Craps, see
  Craps Game
 . Each state definition included a 
 set of methods that represented conditions that could change state; and each
  Throw
  object invoked one 
 of those methods, in effect, announcing a condition that caused a state change.
  
 Additionally, we need to look at the various collaborations of the Game. We also need to address the question 
 of handling the dealer’s rules.
  
 Maintaining State
 . The sequential description of state, where the current state is defined by the step that is 
 next, is the default description of state in most programming languages. While it seems obvious beyond 
 repeating, it is important to note that each statement in a method changes the state of the application; either 
 by changing state of the object that contains the method, or invoking methods of other, collaborating objects. 
 In the case of an
  active
  class, this description of state as next statement is adequate. In the case of a 
 passive
  
 class, this description of state doesn’t work out well because passive classes have their state changed by 
 collaborating objects. For passive objects, instance variables and state objects are a useful way to track state 
 changes.
  
 In the case of Roulette, the cycle of betting and the game procedure were a simple sequence of actions. In the 
 case of Craps, however, the game was only loosely tied to each the cycle of betting and throwing the dice, 
 making the game state a passive part of the cycle of play. In the case of Blackjack, the cycle of betting and 
 game procedure are more like Roulette.
  
 Most of a game of Blackjack is simply sequential in nature: the initial offers of even money, insurance and 
 splitting the hands are optional steps that happen in a defined order. When filling the player’s
  Hand
 s, there 
 are some minor sub-states and state changes. Finally, when all of the player’s
  Hand
 s are bust or standing pat, 
 the dealer fills their hand. Finally, the hands are resolved with no more player intervention.
  
 Most of the game appears to be a sequence of offers from the
  Game
  to the
  BlackjackPlayer
 ; these are offers to 
 place bets, or accept cards, or a combination of the two, for each of the player’s
  Hand
 s.
  
 259",NA
41.2 Blackjack Collaboration,"In Craps and Roulette, the
  Player
  was the primary collaborator with the Game. In Blackjack, however, focus 
 shifts from the
  Player
  to the
  Hand
 . This changes the responsibilities of a
  BlackjackPlayer
 : the
  Hand 
 can 
 delegate certain offers to the
  BlackjackPlayer
  for a response. The
  BlackjackPlayer
  can become a plug-in 
 strategy to the
  Hand
 , providing responses to offers of insurance, even money, splitting, doubling-down, 
 hitting and standing pat. The
  BlackjackPlayer
 ‘s response will change the state of the
  Hand
 . Some state 
 changes involve getting a card, and others involve placing a bet, and some involve a combination of the two.
  
 We’ll use the procedure definition in
  A Walkthrough
 . Following this procedure, we see the following methods 
 that a
  Hand
  and a
  BlackjackPlayer
  will need to respond to the various offers from the
  BlackjackGame
 . The 
 first portion of the game involves the
  BlackjackPlayer
 , the second portion invovles one or more
  Hand 
 s. The 
 collaboration is so intensive, we have created a kind of swimlane table, showing the operations each object 
 must perform. This will allow us to expand
  Hand
  and
  BlackjackTable
  as well as define the interface for
  
 BlackjackPlayer
 .
  
 Table 41.1: Blackjack Overall Collaboration
  
 BlackjackGame
  
 Hand
  
 BlackjackPlayer
  
 Blackjack-
 Table
  
 calls player’s placeBet
  
 gets the initial hand; deal 2 cards to 
  
 hand 
  
 deal 2 cards to dealer’s hand 
  
 gets up card from dealer’s hand; if this card 
 requires insurance, do the insurance 
 procedure 
  
 iterate through all hands; is the given hand 
 splittable?
  
 if the hand is splittable, offer a split bet
  
 if splitting, move card and deal cards; 
 loop back, looking for split offers 
  
 iterate through all hands; if the hand is 
 less than 21, do the fill-hand procedure 
 while the dealer’s point value is 16 or 
 less, deal another card
  
 if the dealer busts, iterate through all 
 hands resolving the ante as a winner
  
 if the dealer does not bust, iterate 
  
 through all hands comparing against the 
 dealer’s points, determining win, loss or 
 push
  
 add cards
  
 add cards 
  
 return up card
  
 return true if 
  
 two cards of the 
 same rank 
  
 get the player’s 
 response; 
  
 return it to the 
 game 
  
 take a card out; 
 add a card
  
 return point 
 value of the 
 hand; add a 
 card 
  
 return point 
 value of the 
 hand 
  
 return point 
 value of the 
 hand
  
 creates empty Hand, 
  
 creates initial Ante Bet
  
 returns the initial hand
  
 returns a list iterator
  
 to split: create a split 
 bet, and an empty 
  
 hand; return the new 
 hand
  
 returns a list iterator
  
 returns a list iterator
  
 returns a list iterator
  
 accepts the 
  
 ante bet, 
  
 associate with 
 the hand
  
 accept the split 
 bet for the new 
 hand
  
 resolve bet as 
  
 winner and 
  
 remove 
  
 resolve bet and 
 remove
  
 There are a few common variation in this procedure for play. We’ll set them aside for now, but will visit them 
 in
  Variant Game Rules
 .
  
 260
  
 Chapter 41.
  
 Blackjack Game Class",NA
41.3 Dealer Rules,"In a sense, the dealer is a special player. They have a fixed set of rules for hitting and standing. They are not 
 actually offered an insurance bet, nor can they split or double down.
  
 However, the dealer does participate in the hand-filling phase of the game, deciding to hit or stand pat. The 
 dealer’s rules are quite simple. Should the Dealer be a special subclass of
  BlackjackPlayer
 ; one that 
 implements only the dealer’s rules?
  
 Or should the Dealer be a feature of the Game. In this case, the Game would maintain the dealer’s Hand and 
 execute the card-filling algorithm.
  
 Using an subclass of
  BlackjackPlayer
  is an example of
  Very Large Hammer
  design pattern. We only want a 
 few features of the
  BlackjackPlayer
  class.
  
 Refactoring
 . To avoid over-engineering these, we could refactor player into two components. An object that 
 handles hand-filling, and an object that handles betting strategies.
  
 The dealer would only use the hand-filling component of a player.
  
 Mutability
 . To avoid over-engineering this, we can look at features that are likely to change. The dealer hand-
 filling rules seem well-established throughout the industry.
  
 Further, a change to the hand-filling rules of the dealer would change the nature of the game enough that we 
 would be hard-pressed to call in Blackjack. A different hand-filling rule would constitute a new kind of game.
  
 We’re confident, then, that the dealer’s hand can be a feature of the
  BlackjackGame
  class.",NA
41.4 BlackjackPlayer Class,"class BlackjackPlayer
 () 
  
 BlackjackPlayer
  is a subclass of
  Player
  that responds to the various queries and interactions with the game of 
 Blackjack.
  
 41.4.1 Fields
  
 han
 d
  
 Some kind of List which contains the initial
  Hand
  and any split hands that may be created.
  
 41.4.2 Constructors
  
 __init__
 (
 self, table
 ) 
  
  
  
 Parameter
  table
  (BlackjackTable) – The table on which bets are placed 
  
  
 Uses the superclass to construct a basic
  Player
 . Uses the newGame() to create an empty List fot 
  
 the 
 hands.
  
 41.4.3 Methods
  
 newGame
 (
 self
 )
  
 262
  
 Chapter 41.
  
 Blackjack Game Class",NA
41.5 Card Rework,"Card
  must provide the Game some information required to offer insurance bets.
  
 We’ll need to add an offerInsurance() method on the class
  Card
 . The
  Card
  superclass must respond with False. 
 This means that the FaceCard subclass will also respond with False.
  
 The AceCard subclass, however, must respond with True to this method.",NA
41.6 Hand Rework,"Hand
  should retain some additional hand-specific information. Since some game allow resplitting of split 
 hands, it’s helpful to record whether or not a player has declined or accepted the offer of a split.
  
 41.6.1 Fields
  
 player 
  
 Holds a reference to the
  Player
  who owns this hand. Each of the various offers from the
  Game
  are 
 delegated to the
  Player
 .
  
 splitDeclined 
  
 Set to true if split was declined for a splittable hand. Also set to true if the hand is not splittable. The 
 split procedure will be done when all hands return true for split declined.
  
 41.6.2 Methods
  
 splittable
 (
 self
 )
  
 Returns true if this hand has a size of two and both
  Card
 s have the same rank. 
 Hand.splitDeclined
  to true if the hand is not splittable.
  
 Also sets
  
 getUpCard
 (
 self
 )
  
 Returns the first
  Card
  from the list of cards, the up card.",NA
41.7 BlackjackGame Class,"class BlackjackGame
 ()
  
 BlackjackGame
  is a subclass of
  Game
  that manages the sequence of actions that define the game of Blackjack.
  
 Note that a single cycle of play is one complete Blackjack game from the initial ante to the final resolution of 
 all bets. Shuffling is implied before the first game and performed as needed.
  
 264
  
 Chapter 41.
  
 Blackjack Game Class",NA
41.8 Blackjack Game Deliverables,"There are eight deliverables for this exercise.
  
 • The stub
  BlackjackPlayer
  class.
  
 • A class which performs a unit test of the
  BlackjackPlayer
  class. Since this player will mimic the dealer, 
 hitting a 16 and standing on a 17, the unit test can provide a variety of
  Hand
  s and confirm which offers 
 are accepted and rejected.
  
 • The revised
  Hand
  class.
  
 • A class which performs a unit tests of the
  Hand
  class. The unit test should create several instances of 
 Card
 , FaceCard and AceCard, and add these to instances of
  Hand
 , to create various point totals. Since 
 this version of
  Hand
  interacts with a
  BlackjackPlayer
 , additional offers of split, double, and hit can be 
 made to the
  Hand
 .
  
 • The revised
  Card
  class.
  
 • Revised unit tests to exercise the Card.offerInsurance() method.
  
 • The revised
  BlackjackGame
  class.
  
 266
  
 Chapter 41.
  
 Blackjack Game Class",NA
FORTYTWO,NA,NA
SIMPLE BLACKJACK PLAYER CLASS,"Our objective is to provide variant player strategies. This chapter will upgrade our stub player class to give it 
 a complete, working strategy. This simple player can serve as the superclass for more sophisticated 
 strategies.",NA
42.1 Blackjack Player Overview,"In addition to the player’s own hand, the player also has the dealer’s up card available for determining their 
 response to the various offers. The player has two slightly different goals: not bust and have a point total 
 larger than the dealer’s. While there is some overlap between these goals, these lead to two strategies based 
 on the dealer’s up card. When the dealer has a relatively low card (2 through 6), the dealer has an increased 
 probability of going bust, so the player’s strategy is to avoid going bust. When the dealer has a relatively high 
 card (7 through 10), the dealer will probably have a good hand, and the player has to risk going bust when 
 looking for a hand better than the dealer’s.
  
 A Simple Strategy
 . We’ll provide a few rules for a simple player strategy. This strategy is not particularly 
 good. Any book on Blackjack, and a number of web sites, will have a superior strategy. A better strategy will 
 also be considerably more complex. We’ll implement this one first, and leave it to the student to research 
 more sophisticated strategies.
  
 1. Reject insurance and even money offers.
  
 2. Accept split for aces and eights. Reject split on other pairs.
  
 3. Hit any hand with 9 or less. The remaining rules are presented in the following table.
  
 Table 42.1: Blackjack Player Strategy
  
 Player Shows
  
 2-6
  
 7-10, Ace
  
 10 or 11 
  
 hard 12 to 16 
 soft 12 to 16 
 17 to 21
  
 hit 
  
 stand 
 hit 
  
 stand
  
 double down 
 hit 
  
 hit 
  
 stand
  
 These rules will boil down to short sequences of if-statements in the split(), hit() and doubleDown() methods.
  
 In some contexts, complex if-statements are deplorable. Specifically, complex if-statements are often a stand-
 in for proper allocation of responsibility. In this class, however, the complex if-statements implement a kind 
 of index or lookup scheme. We have, for this exercise, 8 alternatives which depend on a two-dimensional 
 index. One dimension contains four conditions that describe the player’s hand. The other dimension involves 
 two conditions that describe the dealer’s hand. When we look at the various collections, we see that we can
  
 269",NA
42.2 SimpleBlackjackPlayer Design,"class SimpleBlackjackPlayer
 () 
  
 SimpleBlackjackPlayer
  is a subclass of
  BlackjackPlayer
  that responds to the various queries and inteac-tions 
 with the game of Blackjack.
  
 This player implements a very simple strategy, shown above in the Blackjack Player Strategy table.
  
 42.2.1 Methods
  
 evenMoney
 (
 self, hand
 ) 
  
  
  
 Parameter
  hand
  (Hand) – the hand which is being offered even money 
  
  
 Returns true if this Player accepts the even money offer. This player always rejects this offer.
  
 insurance
 (
 self, hand
 ) 
  
  
  
 Parameter
  hand
  (Hand) – the hand which is being offered insurance 
  
  
 Returns true if this Player accepts the insurance offer. This player always rejects this offer.
  
 split
 (
 self, hand
 ) 
  
  
  
 Parameter
  hand
  (Hand) – the hand which is being offered the opportunity to split 
  
 Returns a new, empty
  Hand
  if this Player accepts the split offer for this
  Hand
 . The Player must 
  
 create a new
  Hand
 , create an Ante
  Bet
  and place the on the new
  Hand
  on the
  BlackjackTable
 . 
  
 If 
 the offer is declined, both set
  Hand.splitDeclined
  to true and return null.
  
 This player splits when the hand’s card’s ranks are aces or eights, and declines the split for all 
 other ranks.
  
 doubleDown
 (
 self, hand
 ) 
  
  
  
 Parameter
  hand
  (Hand) – the hand which is being offered the opportunity to double down 
  
 Returns true if this Player accepts the double offer for this
  Hand
 . The Player must also update 
  
 the
  
 Bet
  associated with this
  Hand
 .
  
 This player tries to accept the offer when the hand points are 10 or 11, and the dealer’s up card is 7 
 to 10 or ace. Otherwise the offer is rejected.
  
 270
  
 Chapter 42.
  
 Simple Blackjack Player Class",NA
42.3 Blackjack Player Deliverables,"There are two deliverables for this exercise.
  
 • The
  SimpleBlackjackPlayer
  class.
  
 • A class which performs a unit test of the
  SimpleBlackjackPlayer
  class. The unit test can provide a 
  
 variety 
 of
  Hand
 s and confirm which offers are accepted and rejected.
  
 42.3.
  
 Blackjack Player Deliverables
  
 271",NA
FORTYTHREE,NA,NA
VARIANT GAME RULES,"There are a number of variations in the sequence of game play offered by different casinos. In addition to 
 having variations on the player’s strategy, we also need to have variations on the casino rules.",NA
43.1 Variant Game Overview,"There are wide variations in the ways people conduct Blackjack games. We’ll list a few of the variations we 
 have heard of.
  
 •
  Additional Win Rule: 
  
 Charlie
 . 
  
 Informal games may allow a “five-card Charlie” or “six-card 
  
 Charlie” win. If the player’s hand stretches to five (or six) cards, they are paid at 1:1.
  
 •
  Additional Offer: Surrender
 . This variation allows the player to lose only half their bet. The offer is 
 made after insurance and before splitting. Surrender against ace and 10 is a good strategy, if this offer is 
 part of the game.
  
 •
  No Resplit
 . This variation limits the player to a single split. In the rare event of another matching 
  
 card, resplitting is not allowed.
  
 •
  No Double After Split
 . This variation prevents the player from a double-down after a split. Ordi-
  
 narily, 
 splitting Aces is followed by double-downs because 4/13 cards will lead to blackjack.
  
 •
  Dealer Hits Soft 17
 . This variation forces the dealer to hit soft 17 instead of standing. This tends 
  
 in increase the house edge slightly.
  
 •
  Blackjack Pays 6:5
 . This variation is often used in single-deck games. It limits the value of card-
  
 counting, since the house edge is stacked more heavily against the player.
  
 The restrictions on splitting and doubling down are small changes to the offers made by a variation on 
 BlackjackGame
 . This would require creating a subclass of
  BlackjackGame
  to implement the alternative rules.
  
 The variations in the dealer’s rules (hitting a soft 17) is also a small change best implemented by creating a 
 subclass of
  BlackjackGame
 .
  
 Reducing the number of decks is an easy change to our application. Since our main application constructs the 
 Shoe before constructing the
  Game
 , it can construct a single-deck Shoe.
  
 Payout Odds
 . Handling the variations in the payout odds is a bit more complex.
  
 1. The Player creates each Hand, associated with a Bet. The Bet is associated with the simple Ante 
  
 outcome.
  
 2. At the end of the Game, the Hand does a comparison between itself and the Dealer’s Hand to determine 
  
 the odds for the Ante outcome.
  
 273",NA
43.2 BlackjackGame Rework,"BlackjackGame
  is a subclass of
  Game
  that manages the sequence of actions that define the game of Blackjack. 
 Note that a single cycle of play is one complete Blackjack game from the initial ante to the final resolution of 
 all bets. Shuffling is implied before the first game and performed as needed.
  
 43.2.1 Methods
  
 adjustOdds
 (
 self, hand
 ) 
  
  
  
 Parameter
  hand
  (Hand) – The hand which has the ante bet odd’s corrected 
  
 This method is used at the end of the game to resolve the player’s Ante bet. 
  
 If the 
 player went bust, their hand was already resolved.
  
 If the dealer went bust, all remaining bets are resolved as winners.
  
 The remaining 
  
 situation 
  
 (both player
  
 BlackjackGame.adjustOdds() method.
  
 3:2 if the player holds Blackjack.",NA
43.3 OneDeckGame Class,"and dealer have non-bust hands) requires this
  
 This method will set the hand’s outcome’s odds to
  
 OneDeckGame is a subclass of
  BlackjackGame
  that manages the sequence of actions for a one-deck game of 
 Blackjack with a 6:5 blackjack OutcomeAnteLowOdds.
  
 Typically, this is built with a one-deck instance of Shoe.
  
 The OneDeckGame.adjustOdds() method overrides the superclass. This method will set the hand’s out-come’s 
 odds to 6:5 if the player holds Blackjack.",NA
43.4 Variant Game Deliverables,"There are three deliverables for this exercise.
  
 • The revised
  BlackjackGame
  class. All of the original unit tests should apply to the refactored function 
  
 that sets the outcome odds.
  
 • The OneDeckGame class.
  
 • A class to perform a unit test of the OneDeckGame class.
  
 274
  
 Chapter 43.
  
 Variant Game Rules",NA
FORTYFOUR,NA,NA
CONCLUSION,"The game of Blackjack has given us an opportunity to further extend and modify an application with a 
 considerable number of classes and objects. These exercises gave us an opportunity to work from a base of 
 software, extending and refining our design.
  
 We omitted concluding exercises which would integrate this package with the
  Simulator
  and collect statistics. 
 This step, while necessary, doesn’t include many interesting design decisions. The final deliverable should be 
 a working application that parses command-line parameters, creates the required objects, and creates an 
 instance of
  Simulator
  to collect data.
  
 We have specifically omitted delving into the glorious details of specific player strategies. We avoided these 
 details for two reasons.
  
 •
  Intellectual Property
 . We didn’t create any strategies. Rather than get permission to quote existing 
 blackjack strategies, we leave it to the interested student to either buy any of the available books on 
 Blackjack or download a strategy description from the Internet.
  
 •
  Irrelevant Complexity
 . We find that all of the detailed programming required to implement a 
  
 particular strategy doesn’t have too much to do with object-oriented design. Rather, it is an exercise 
  
 in construction of detailed if-statements. It appears to be the wrong focus for learning OO design.
  
 Next Steps
 . 
  
 There are a number of logical next steps for the programmers looking to build skills in object-
 oriented design. We’ll split these along several broad fronts.
  
 •
  Additional Technology
 . There are several technology directions that can be pursued for further 
  
 design experience.
  
 This application is a command-line application, which makes it easy to build and test.
  
 Another area for building skills in design is the implementation of programs that make extensive use of 
 a database.
  
 A graphical user interface (GUI) application will add the technology for graphical display, and re-
 sponding to user input events.
  
 A web application will add the technology for HTTP web transactions, HTML, CSS, and – potentially– a 
 database.
  
 •
  Application Areas
 . We selected simulation because it’s part of the historical foundation for object-
  
 oriented programming. We selected casino games because they have a reasonable level of complexity.
  
 Clearly, numerous other application areas can be selected as the basis for problems. The number and 
 variety of human endevors that can be automated is quite large.
  
 Moving beyond simulation or doing simulation on something more complex than a casino table game is 
 a good next step.
  
 275",NA
Part V ,NA,NA
Fit and Finish,277,NA
FORTYFIVE,NA,NA
PYTHON UNITTEST TESTING,"Python
  unittest
  encourages us to build a test module separate from the application class we’re testing. The 
 test module will have one more more TestCase classes, each of which has one or more test methods. 
 Workflow
 . One approach to unit testing is to build the tests first, then write a class which at least doesn’t 
 crash, but may not pass all the tests. Once we have this in place, we can now debug the tests until everything 
 looks right. This is called test-driven development.
  
 We’d start with unittest files in the test directory of our project. In this case, we’d have testCard.py and 
 testDeck.py. We also need skeleton files in our src directory: cards.py and deck.py.
  
 Generally, the process for creating a class with the unit tests has the following outline.
  
 1. Write a skeleton for the target class. One that doesn’t really do anything, but at least compiles and 
  
 has the right method names.
  
 2. Write the test class. This will create instances of the target class, exercise those instances, and make 
  
 assertions about the state of those instances.
  
 3. Run the test, knowing that will fail. Sometimes our target class is so simple that we get it right the first 
 time. Other times, the target class is more complex and there are parts we didn’t finish when we wrote 
 the skeleton version.
  
 4. While tests are still failing.
  
 (a) Refactor. We finish our target class. Sometimes we simply fill in the missing parts. Other times, 
  
 we have more serious design work to do.
  
 (b) Run the test suite.
  
 5. At this point, the target class passes the suite of tests. However, it may still fail to meet other quality 
 criteria. For example, it may have a convoluted structure, or it may be inefficient, or it may lack 
 appropriate documentation. In any case, we’re not really done with development.
  
 While our target class fails to meet our quality standards.
  
 (a) Refactor. We correct the quality problems in our target class.
  
 (b) Run the test suite. If we have refactored properly, the tests still pass. If we have introduced a 
  
 problem, tests will fail.
  
 Using unittest
 . A test runner will locate all the TestCase instances, execute them and summarize the pass/fail 
 status of each individual test method.
  
 Generally, we’ll organize our project directory to have a test directory and a src directory.
  
 Here is an example of running a test from the command line.
  
 281",NA
45.1 Dependencies,"Let’s assume we’ve built two classes in some chapter; pretend that we’re building
  Card
  and Deck . One class 
 defines a standard playing card and the other class deals individual card instances. We need unit tests for 
 each class.
  
 Generally, unit tests are taken to mean that a class is tested in isolation. In our case, a unit test for Card is 
 completely isolated because it has no dependencies.
  
 However, our Deck class depends on Card, leading us to make a choice. Either we have to create a Mock Card 
 that can be used to test Deck in complete isolation, or our Deck test will depend on both Deck and Card. The 
 choice depends on the relative complexity of Card, and whether or not Deck and Card will evolve 
 independently.
  
 Some folks demand that all testing be done in “complete” isolation with a lot of mock classes. Other folks are 
 less strict on this, recognizing that Deck and Card are very tightly coupled and Card is very simple. The Mock 
 Card is almost as complex as Card.",NA
45.2 Example,"testCard.py
  
 import
  unittest 
  
 import
  card 
  
 class
  TestCard
 ( unittest
 .
 TestCase ): 
  
 def
  setUp
 (
  self
  ): 
  
  
  
 self
 .
 aceClubs
 =
  card
 .
 Card(
 1
 ,card
 .
 Clubs) 
  
  
  
 self
 .
 twoClubs
 =
  card
 .
 Card(
 2
 ,card
 .
 Clubs) 
  
  
  
 self
 .
 tenClubs
 =
  card
 .
 Card(
 10
 ,card
 .
 Clubs) 
  
  
  
 self
 .
 kingClubs
 =
  card
 .
 Card(
 13
 ,card
 .
 Clubs) 
  
  
  
 self
 .
 aceDiamonds
 =
  card
 .
 Card(
 1
 ,card
 .
 Diamonds) 
  
 def
  testString
 (
  self
  ): 
  
  
  
 self
 .
 assertEquals(
  "" AC""
 ,
  str
 (
 self
 .
 aceClubs) ) 
  
  
 self
 .
 assertEquals(
  "" 2C""
 ,
  str
 (
 self
 .
 twoClubs) ) 
  
  
 self
 .
 assertEquals(
  ""10C""
 ,
  str
 (
 self
 .
 tenClubs) ) 
 def
  testOrder
 (
  self
  ): 
  
  
  
 self
 .
 assertTrue(
  self
 .
 tenClubs
  <
  self
 .
 kingClubs ) 
  
  
 self
 .
 assertFalse(
  self
 .
 tenClubs
  >=
  self
 .
 kingClubs ) 
  
  
 self
 .
 assertTrue(
  self
 .
 kingClubs
  <
  self
 .
 aceClubs ) 
  
  
 self
 .
 assertTrue(
  self
 .
 aceClubs
  ==
  self
 .
 aceDiamonds )
  
 if
  __name__
  ==
  ""__main__""
 : 
  
 unittest
 .
 main()
  
 282
  
 Chapter 45.
  
 Python unittest Testing",NA
FORTYSIX,NA,NA
PYTHON DOCTEST TESTING,"Python
  doctest
  module requires us to put our test cases and expected results into the docstring comments on 
 a class, method or function. The test case information becomes a formal part of the API documentation. When 
 a docstring includes doctest comments, the string serves dual duty as formal test and a working example.
  
 Workflow
 . To use
  doctest
  is to build the class, exercise it in the Python interpreter, then put snippets of the 
 interactive log into our docstrings.
  
 Generally, we follow this outline.
  
 1. Write and debug the class, including docstring comments.
  
 2. Exercise the class in an interactive Python interpreter. You can use
  IDLE
  or any other command line. 3. 
 Copy the snippets out of the interactive log. Paste them into the docstring comments.
  
 4. Run doctest to be sure that you’ve copied and pasted correctly.
  
 Using Doctest
 . There are two ways to use doctest.
  
 Start with Python 2.6, you can run doctest from the command line like this.
  
 python -m doctest -v roulette.py
  
 You can also add a test function to a module which runs doctest on the module. This test function should have 
 a name which begins with _ to make it a name that’s private to the module and not part fo the module’s 
 interface.
  
 def
  _test
 (): 
  
 import
  doctest 
  
 doctest
 .
 testmod() 
  
 if
  __name__
  ==
  ""__main__""
 : 
  
 _test()
  
 This _test() function is the main function of the module, so that when you run the module, it performs it’s 
 internal doctests.
  
 python roulette.py
  
 Test-Driven Development
 . Note that the strict test-driven development (TDD) approach to unit testing is to 
 build the tests first, then write a class which at least doesn’t crash, but may not pass all the tests. Once we 
 have this in place, we can now debug the tests until everything looks right. This is called test-driven 
 development, because the test cases come first, driving the rest of the work.
  
 285",NA
46.1 Example,"Let’s assume we’ve built two classes in some chapter; pretend that we’re building
  Card
  and Deck. One class 
 defines a standard playing card and the other class deals individual card instances. We’ll define some minimal 
 doctests.
  
 The first step is to develop our baseline class. Here’s a module that seems like it works.
  
 This version uses ASCII suit names instead of Unicode suit names.
  
 card.py - Initial
  
 Clubs
 =
 ""C""
  
 Diamonds
 =
 ""D""
  
 Hearts
 =
 ""H""
  
 Spades
 =
 ""S""
  
 class
  Card
 (
  object
  ):
  
 """"""The card superclass, appropriate for number cards.
  
 .. todo:: Doctest goes here
  
 """"""
  
 def
  __init__
 (
  self
 , rank, suit ):
  
 self
 .
 rank
 =
  rank
  
 self
 .
 suit
 =
  suit
  
 self
 .
 points
 =
  rank
  
 def
  hardValue
 (
  self
  ):
  
 return
  self
 .
 points
  
 def
  softValue
 (
  self
  ): 
  
 return
  self
 .
 points
  
 def
  __eq__
 (
  self
 , other ):
  
 return
  self
 .
 rank
  ==
  other
 .
 rank
  
 286
  
 Chapter 46.
  
 Python doctest Testing",NA
46.2 Add the Test Framework,"There are two doctest frameworks. Doctest can be used for “stand-alone” testing. It can also be incorpo-rated 
 into unittest testing.
  
 The general approach to stand-alone testing is to add the following to a module. When you run the module, it 
 executes all doctest strings found throughout the module. Tests will pass silently. Any output is a failure of 
 some kind.
  
 def
  _test
 (): 
  
 import
  doctest 
  
 doctest
 .
 testmod() 
  
 if
  __name__
  ==
  ""__main__""
 : 
  
 _test()",NA
46.3 Mixed unittest and doctest,"A more complete approach is to use unittest for most testing and doctest to emphasize specific use cases in the 
 docstrings. When doing this, you’ll have a test module that looks something like the following.
  
 288
  
 Chapter 46.
  
 Python doctest Testing",NA
FORTYSEVEN,NA,NA
PYTHON DOCUMENTATION,"Application Program Interface (API) documentation is absolutely essential. The easiest and most reliable way 
 to produce this documentation is by using a tool that examines the source itself and develops the document 
 directly from the programs. By using cleverly formatted Python docstrings, we can augment that analysis 
 with easy-to-understand descriptions.
  
 In the case of Python, there are several tools for extracting documentation from the source. Two populare ones 
 are
  
 •
  Epydoc
  http://epydoc.sourceforge.net/
 .
  
 •
  Sphinx
  http://sphinx.pocoo.org/
 .
  
 Workflow
 . Generally, the workflow has the following outline.
  
 1. Develop the skeleton class.
  
 2. Develop unit tests for most features.
  
 3. Rework the class until it passes the unit tests. This may involve adding or modifying tests as we 
  
 understand the class better. This also involves writing docstrings for modules, classes and methods.
  
 4. Revisit the modules, classes and methods, finishing each description using the ReStructured Text (RST) 
 markup language. We won’t cover all of this language, just enough to provide a sense of how the tool is 
 used to make clean, professional API documentation.
  
 5. Run the documentation tool (epydoc or sphinx) to create the documentation. Fix any errors in your 
 docstring markup. Also, rework the documentation as necessary to be sure that you’ve capture im-
 portant information about the class, the methods, the design decisions.
  
 Using the Epydoc
 . When you install Epydoc, it creates a script that you can use. To run Epydoc, you’ll use a 
 command similar to the following.
  
 epydoc
  
 -v --docformat restructuredtext --output apidoc card.py
  
 The
  -v
  option provides detailed debugging information for incorrectly formatted docstrings. 
  
 The
 --docformat
  option specifies that the various docstrings use RST markup. The
  --output
  option defines the 
 directory to which the documentation is written. The arguments (in this case, card.py) is a list of package 
 directories or module files to be documented.
  
 Note that RST is not the default markup language for Epydoc. You must either specify this on the command 
 line or in the module source. To identify the formatting in each module you must provide the format as the 
 value of a __docformat__ module global variable.
  
 #!/usr/bin/env python
  
 """"""
  
 291",NA
47.1 Basic RST Markup,"We write our module, class and method docstrings using the RST markup language. RST is one of many 
 structured text
  markup languages, where simple indentation and formatting rules are used to interpret your 
 documetation. These formatting rules help the tools deduces the structure of your document (sections, list, 
 etc.) and the presentation (bold, italic, or font changes.) These rules are – generally – pretty simple rules that 
 plain text documents have been using since documents were first stored on computers.
  
 Fundamentally, the RST formatting rules are implemented by a module named
  docutils
 . For additional 
 documentation on RST, see the Sphinx web site (
 http://sphinx.pocoo.org
 ) and the Docutils web site 
 (
 http://docutils.sourceforge.net/
 ).
  
 In addition to document structure, deduced from the layout, RST also uses explicit directives and interpreted 
 text (or “inline”) markup.
  
 Document Structure
 . Generally, you must write in paragraphs. A blank line is the end of one paragraph and 
 the beginning of another. Also, different indentation will signal paragaph changes. The indent rule is handy 
 for making bullet lists or numbered lists.
  
 A line that is indented and begins with - is a bulleted list.
  
 A line that starts with digits and periods is a numbered list. Lists can nest within each other.
  
 If you need to have sections and subsections (you’ll almost always do this in the docstring for a module or 
 package), you “underline” the title with lines of ===, --- or ~~~.
  
 292
  
 Chapter 47.
  
 Python Documentation",NA
47.2 RST Field Markup,"RST Field markup is primarily used to tie your documentation directly to Python language structures. Field 
 markup is a separate paragraph of the form ‘:tag arg: body’. We won’t cover all of the tags, just enough to 
 produce basic documentation.
  
 Field markup also provides several standard kinds of standard “formal paragraphs” within your document. 
 We’ll look at these separately.
  
 Functions and Method Functions
 . The following tags are used to define detailed features of a method function.
  
 • :param p: description A description of the parameter,
  p
 , for a function or method.
  
 • :return: description A description of the return value from the function or method.
  
 • :keyword k: description A description of the keyword parameter,
  k
 , for a function or method.
  
 Here’s an example of a method function docstring that uses @param tags.
  
 def
  __init__
 (
  self
 , rank, suit ):
  
 """"""Build a card with a given rank and suit.
  
 :param rank: numeric rank, ace is 1, 2-13 for 2 though King.
  
 :param suit: String suit, use one of the module constants.
  
 """"""
  
 self
 .
 rank
 =
  14
  if
  rank
  ==
  1
  else
  rank
  
 self
 .
 suit
 =
  suit
  
 Classes and Modules
 . The following tags are used to define specific variables in a module or class.
  
 • :ivar v: description A description of the an instance variable of a class. Generally, this will be in 
  
 the class 
 level docstring, and will refer to one of the class’s self. variables.
  
 • :var v: description A global variable of a module. Generally, this will be in the module docstring, 
  
 and will 
 refer to one of the global variables created by the module.
  
 Here’s an example of a class definition docstring that uses :ivar: tags.
  
 class
  Card
 (
  object
  ):
  
  
  
 """"""A single playing card, suitable for Blackjack or
  
 Poker.
  
 While a suit is retained, it doesn't figure into
  
 the ordering of cards, as it would in Bridge.
  
 294
  
 Chapter 47.
  
 Python Documentation",NA
47.3 Class Example,"Here’s an example of a module with detailed class documentation.
  
 #!/usr/bin/env python 
  
 """"""The cards module defines the Card class and constants for the four 
 suits.
  
 :author: S. Lott 
  
 :license: http://creativecommons.org/licenses/by-nc-nd/3.0/us/
  
 .. data:: Clubs 
  
 Use this to build Cards in the clubs suit
  
 .. data:: Diamonds 
  
 Use this to build Cards in the diamonds suit
  
 .. data:: Hearts 
  
 Use this to build Cards in the hearts suit
  
 :.. data:: Spades: 
  
 Use this to build Cards in the spades suit 
  
 """""" 
  
 Clubs
 =
 ""C"" 
  
 Diamonds
 =
 ""D"" 
  
 Hearts
 =
 ""H"" 
  
 Spades
 =
 ""S""
  
 class
  Card
 (
  object
  ): 
  
 """"""A single playing card, suitable for Blackjack or Poker. 
  
 While a suit is 
 retained, it doesn't figure into the ordering of cards, as it would in Bridge.
  
 .. note:: Aces and Facecards.
  
 Ace and Facecards are separate subclasses.
  
 .. attribute:: rank 
  
  
  
 The numeric rank of the card. 
  
 2-13, 
  
 ace has an effective 
  
  
 rank of 14 when used in Poker.
  
 .. attribute:: suit 
  
  
  
 The string suit of the card. 
  
 This should be from the 
  
  
 named constants (Clubs, Diamonds, Hearts, Spades).
  
 """""" 
  
 def
  __init__
 (
  self
 , rank, suit ): 
  
  
 """"""Build a card with a given rank and suit.
  
 :param rank: numeric rank, 2-10. 
  
 Aces and FaceCards are separate. :type 
 rank: integer in the range 2 to 10 inclusive.
  
 :param suit: String suit, use one of the module constants.
  
 """""" 
  
 self
 .
 rank
 =
  rank 
  
 self
 .
 suit
 =
  suit 
  
 self
 .
 points
 =
  rank
  
 def
  hardValue
 (
  self
  ):
  
 296
  
 Chapter 47.
  
 Python Documentation",NA
Part VI ,NA,NA
Back Matter,299,NA
FORTYEIGHT,NA,NA
BIBLIOGRAPHY,NA,NA
48.1 Use Cases ,NA,NA
48.2 Computer Science ,NA,NA
48.3 Design Patterns ,NA,NA
48.4 Statistics ,NA,NA
48.5 Python ,NA,NA
48.6 Java ,NA,NA
48.7 Casino Games,301,NA
FORTYNINE,NA,NA
TOOLSET,"The following toolset was used for production of this book.
  
 • 
 Python 2.6.3.
  
 • Sphinx 0.63.
  
 • Docutils 0.5.
  
 • Komodo Edit 5.2.2.
  
 • pyPDF 1.12.
  
 • MacTeX-2008.
  
 303",NA
FIFTY,NA,NA
INDICES AND TABLES,"•
  Index
  
 •
  Search Page
  
 305",NA
BIBLIOGRAPHY,"[Jacobson92] Ivar Jacobson, Magnus Christerson, Patrik Jonsson, Gunnar Övergaard.
  Object-Oriented Soft-
  
 ware Engineering
 . A Use Case Driven Approach. 1992. Addison-Wesley. 0201544350.
  
 [Jacobson95] Ivar Jacobson, Maria Ericsson, Agenta Jacobson.
  The Object Advantage
 . Business Process 
  
 Reengineering with Object Technology. 1995. Addison-Wesley. 0201422891.
  
 [Parnas72] Parnas D.
  On the Criteria to Be Used in Decomposing Systems into Modules
 . 1053-1058. 1972. 
  
 Communications of the ACM.
  
 [Gamma95] Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides.
  Design Patterns
 . Elements of 
  
 Object-
 Oriented Software. 1995. Addison-Wesley Professional. 0201633612.
  
 [Larman98] Craig Larman.
  Applying UML and Patterns
 . An Introduction to Object-Oriented Analysis and 
  
 Design. 1998. Prentice-Hall. 0137488807.
  
 [Neter73] John Neter, William Wasserman, G. A. Whitmore.
  Fundamental Statistics for Business and Eco-
  
 nomics
 . 4. 1973. Allyn and Bacon, Inc.. 020503853.
  
 [vanRossum04] Guido van Rossum, Fred L. Drake.
  Python Documentation
 . 2004. Python Labs.
  
 [Silberstang05] Edwin Silberstang.
  The Winner’s Guide to Casino Gambling
 . 4th. 2005. Owl Books. 
  
 0805077650.
  
 [Skiena01] Steven Skiena.
  Calculated Bets
 . Computers, Gambling, and Mathematical Modeling to Win. 2001. 
  
 Cambridge University Press. 0521009626.
  
 [Shackleford04] Michael Shackleford.
  The Wizard Of Odds
 . 2004.
  
 307",NA
