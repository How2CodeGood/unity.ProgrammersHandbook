Larger Text,Smaller Text,Symbol
Practical Programming,"I wish I could go back in time and give this book to my 10-year-old self when I first learned 
 programming! It’s so much more engaging, practical, and accessible than the dry 
 introductory programming books that I tried (and often failed) to comprehend as a kid. I 
 love the authors’ hands-on approach of mixing explanations with code snippets that 
 students can type into the Python prompt.
  
 ➤
  Philip Guo 
  
 Creator of Online Python Tutor (
 www.pythontutor.com
 ), Assistant Professor, Depart-ment 
 of Cognitive Science, UCSD
  
 Practical Programming
  delivers just what it promises: a clear, readable, usable introduction 
 to programming for beginners. This isn’t just a guide to hacking together programs. The 
 book provides foundations to lifelong programming skills: a crisp, consistent, and visual 
 model of memory and execution and a design recipe that will help readers produce quality 
 software.
  
 ➤
  Steven Wolfman 
  
 Professor of Teaching, Department of Computer Science, University of British Columbia",NA
"Practical Programming, Third Edition ",NA,NA
An ,NA,NA
Introduction to Computer Science Using Python 3.6,NA,NA
Paul Gries ,NA,NA
Jennifer Campbell ,NA,NA
Jason Montojo,NA,NA
The Pragmatic Bookshelf ,"Raleigh, North 
 Carolina",NA
Contents,"Acknowledgments
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 xi
  
  
  
 Preface
  .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
   
 .
    
 xiii
  
 1.
  
 What’s Programming?
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
   
 .
  
 1
  
  
 Programs and Programming
  
     
 2
  
  
 What’s a Programming Language?
  
     
 3
  
  
 What’s a Bug?
  
     
 4
  
  
 The Difference Between Brackets, Braces, and Parentheses
  
     
 5
  
  
 Installing Python
  
     
 5
  
 2.
  
 .
  
   
 .
  
 7
  
 Hello, Python
  .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
  
 How Does a Computer Run a Python Program?
  
     
 7
  
  
 Expressions and Values: Arithmetic in Python
  
     
 9
  
  
 What Is a Type?
  
     
 12
  
  
 Variables and Computer Memory: Remembering Values
  
     
 15
  
  
 How Python Tells You Something Went Wrong
  
     
 22
  
  
 A Single Statement That Spans Multiple Lines
  
     
 23
  
  
 Describing Code
  
     
 25
  
  
 Making Code Readable
  
     
 26
  
  
 The Object of This Chapter
  
     
 27
  
  
 Exercises
  
     
 27
  
 3.
  
   
 .
   
 31
  
 Designing and Using Functions
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
 .
  
  
 Functions That Python Provides
  
     
 31
  
  
 Memory Addresses: How Python Keeps Track of Values
  
     
 34
  
  
 Defining Our Own Functions
  
     
 35
  
  
 Using Local Variables for Temporary Storage
  
     
 39
  
  
 Tracing Function Calls in the Memory Model
  
     
 40
  
  
 Designing New Functions: A Recipe
  
     
 47
  
  
 Writing and Running a Program
  
     
 58",NA
Acknowledgments,"This book would be confusing and riddled with errors if it weren’t for a bunch of 
 awesome people who patiently and carefully read our drafts.
  
 We had a great team of people provide technical reviews for this edition and previous 
 editions: in no particular order, Frank Ruiz, Stefan Turalski, Stephen Wolff, Peter W.A. 
 Wood, Steve Wolfman, Adam Foster, Owen Nelson, Arturo Martínez Peguero, C. Keith 
 Ray, Michael Szamosi, David Gries, Peter Beens, Edward Branley, Paul Holbrook, Kristie 
 Jolliffe, Mike Riley, Sean Stickle, Tim Ottinger, Bill Dudney, Dan Zingaro, and Justin 
 Stanley. We also appreciate all the people who reported errata: your feedback was 
 invaluable.
  
 Greg Wilson started us on this journey when he proposed that we write a textbook, and 
 he was our guide and mentor as we worked together to create the first edition of this 
 book.
  
 Finally, we would like to thank our editor Tammy Coron, who set up a workflow that 
 made the tight timeline possible. Tammy, your gentle nudges kept us on track 
 (squirrel!) and helped us complete this third edition in record time.
  
 report erratum  •  discuss",NA
Preface,"This book uses the Python programming language to teach introductory computer 
 science topics and a handful of useful applications. You’ll certainly learn a fair amount 
 of Python as you work through this book, but along the way you’ll also learn about 
 issues that every programmer needs to know: ways to approach a problem and break 
 it down into parts, how and why to document your code, how to test your code to help 
 ensure your program does what you want it to, and more.
  
 We chose Python for several reasons:
  
 •
  It is free and well documented.
  In fact, Python is one of the largest and best-organized 
 open source projects going.
  
 •
  It runs everywhere.
  The reference implementation, written in C, is used on 
 everything from cell phones to supercomputers, and it’s supported by 
 professional-quality installers for Windows, macOS, and Linux.
  
 •
  It has a clean syntax.
  Yes, every language makes this claim, but during the several 
 years that we have been using it at the University of Toronto, we have found that 
 students make noticeably fewer “punctuation” mistakes with Python than with C-
 like languages.
  
 •
  It is relevant.
  Thousands of companies use it every day: it is one of the languages 
 used at Google, Industrial Light & Magic uses it extensively, and large portions of 
 the game EVE Online are written in Python. It is also widely used by academic 
 research groups.
  
 •
  It is well supported by tools.
  Legacy editors like vi and Emacs all have Python editing 
 modes, and several professional-quality IDEs are available. (We use IDLE, the free 
 development environment that comes with a standard Python installation.)
  
 report erratum  •  discuss",NA
Our Approach,"We have organized the book into two parts. The first covers fundamental pro-
 gramming ideas: how to store and manipulate information (numbers, text, lists, sets, 
 dictionaries, and files), how to control the flow of execution (conditionals and loops), 
 how to organize code (functions and modules), how to ensure your code works (testing 
 and debugging), and how to plan your program (algorithms).
  
 The second part of the book consists of more or less independent chapters on more 
 advanced topics that assume all the basic material has been covered. The first of these 
 chapters shows how to create and manage your own types of information. It 
 introduces object-oriented concepts such as encapsulation, inheritance, and 
 polymorphism. The other chapters cover testing, databases, and graphical user 
 interface construction.",NA
Further Reading,"Lots of other good books on Python programming exist. Some are accessible to novices, 
 such as 
 Introduction to Computing and Programming in Python: A Multimedia Approach 
 [GE13]
  and 
 Python Programming: An Introduction to Computer Science [Zel03]
 ; others 
 are for anyone with any previous programming experience (
 How to Think Like a 
 Computer Scientist: Learning with Python [DEM02]
 , 
 Object-Oriented Programming in 
 Python [GL07]
 , and 
 Learning Python [Lut13]
 ). You may also want to take a look at 
 Python Education Special Interest Group (EDU-SIG) [Pyt11]
 , the special interest group 
 for educators using Python.
  
 Python Resources
  
 Information about a variety of Python books and other resources is available at 
 http://wiki.python.org/moin/FrontPage
 .
  
 After you have a good grasp of programming in Python, we recommend that you learn a 
 second programming language. There are many possibilities, such as well-known 
 languages like C, Java, C#, and Ruby. Python is similar in concept to those languages. 
 However, you will likely learn more 
 and become a better programmer
  if you learn a 
 programming language that requires a 
 3
  In any case, we different mindset, such as 
 Racket, 
 1
  Erlang, 
 2
  or Haskell.
  
 strongly recommend learning a second programming language.
  
 1. 
 2. 
 3.
  
 See 
 http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html
 . 
  
 See 
 http://learnyousomeerlang.com
 .
  
 See 
 http://learnyouahaskell.com
 .
  
 report erratum  •  discuss",NA
What You’ll See,"In this book, we’ll do the following:
  
 • We’ll show you how to develop and use programs that solve real-world problems. 
 Most of the examples will come from science and engineering, but the ideas can be 
 applied to any domain.
  
 • We’ll start by teaching you the core features of Python. These features are included 
 in most modern programming languages, so you can use what you learn no matter 
 what you work on next.
  
 • We’ll also teach you how to think methodically about programming. In particular, 
 we will show you how to break complex problems into simple ones and how to 
 combine the solutions to those simpler problems to create complete applications.
  
 • Finally, we’ll introduce some tools that will help make your programming more 
 productive, as well as some others that will help your applications cope with 
 larger problems.",NA
Online Resources,"All the source code, errata, discussion forums, installation instructions, and exercise 
 solutions are available at 
 http://pragprog.com/book/gwpy3/practical-programming
 .
  
 report erratum  •  discuss",NA
1,NA,NA
What’s Programming?,"(Photo credit: NASA/Goddard Space Flight Center Scientific Visualization Studio)
  
 Take a look at the pictures above. The first one shows forest cover in the Amazon basin 
 in 1975. The second one shows the same area twenty-six years later. Anyone can see 
 that much of the rainforest has been destroyed, but how much is “much”?
  
 Now look at this:
  
  
 (Photo credit: CDC)
  
 report erratum  •  discuss",NA
Programs and Programming,"A 
 program
  is a set of instructions. When you write down directions to your house for a 
 friend, you are writing a program. Your friend “executes” that program by following 
 each instruction in turn.
  
 Every program is written in terms of a few basic operations that its reader already 
 understands. For example, the set of operations that your friend can understand might 
 include the following: “Turn left at Darwin Street,” “Go forward three blocks,” and “If 
 you get to the gas station, turn around—you’ve gone too far.”
  
 Computers are similar but have a different set of operations. Some operations are 
 mathematical, like “Take the square root of a number,” whereas others include “Read a 
 line from the file named 
 data.txt
 ” and “Make a pixel blue.”
  
 report erratum  •  discuss",NA
What’s a Programming Language?,"Directions to the nearest bus station can be given in English, Portuguese, Mandarin, 
 Hindi, and many other languages. As long as the people you’re talking to understand 
 the language, they’ll get to the bus station.
  
 In the same way, there are many programming languages, and they all can add 
 numbers, read information from files, and make user interfaces with windows and 
 buttons and scroll bars. The instructions look different, but
  
 report erratum  •  discuss",NA
What’s a Bug?,"Pretty much everyone has had a program crash. A standard story is that you were 
 typing in a paper when, all of a sudden, your word processor crashed. You had 
 forgotten to save, and you had to start all over again. Old versions of Microsoft 
 Windows used to crash more often than they should have, showing the dreaded “blue 
 screen of death.” (Happily, they’ve gotten a 
 lot 
 better in the past several years.) Usually, 
 your computer shows some kind of cryptic error message when a program crashes.
  
 What happened in each case is that the people who wrote the program told the 
 computer to do something it couldn’t do: open a file that didn’t exist, perhaps, or keep 
 track of more information than the computer could handle, or maybe repeat a task 
 with no way of stopping other than by rebooting the computer. (Programmers don’t 
 mean to make these kinds of mistakes, they are just part of the programming process.)
  
 Worse, some bugs don’t cause a crash; instead, they give incorrect information. (This is 
 worse because at least with a crash you’ll notice that there’s a prob-lem.) As a real-life 
 example of this kind of bug, the calendar program that one of the authors uses contains 
 an entry for a friend who was born in 1978. That friend, according to the calendar 
 program, had his 5,875,542nd birthday this past February. Bugs can be entertaining, 
 but they can also be tremendously frustrating.
  
 Every
  piece of software that you can buy has bugs in it. Part of your job as a 
 programmer is to minimize the number of bugs and to reduce their severity. In order 
 to find a bug, you need to track down where you gave the wrong
  
 report erratum  •  discuss",NA
"The Difference Between Brackets, Braces, and Parentheses","One of the pieces of terminology that causes confusion is what to call certain characters. 
 Several dictionaries use these names, so this book does too:
  
 () 
  
 Parentheses
  
 [] 
  
 Brackets
  
 {} 
  
 Braces (Some people call these 
 curly brackets
  or 
 curly braces
 , but we’ll 
  
 stick 
 to just 
 braces
 .)",NA
Installing Python,"Installation instructions and use of the IDLE programming environment are available on 
 the book’s website: 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 report erratum  •  discuss",NA
2,NA,NA
"Hello, Python","Programs are made up of commands that tell the computer what to do. These 
 commands are called 
 statements
 , which the computer executes. This chapter describes 
 the simplest of Python’s statements and shows how they can be used to do arithmetic, 
 which is one of the most common tasks for computers and also a great place to start 
 learning to program. It’s also the basis of almost everything that follows.",NA
How Does a Computer Run a Python Program?,"In order to understand what happens when you’re programming, it helps to have have a 
 mental model of how a computer executes a program.
  
 The computer is assembled from pieces of hardware, including a 
 processor 
 that can 
 execute instructions and do arithmetic, a place to store data such as a 
 hard drive
 , and 
 various other pieces, such as a screen, a keyboard, an Ethernet controller for 
 connecting to a network, and so on.
  
 To deal with all these pieces, every computer runs some kind of 
 operating system
 , such 
 as Microsoft Windows, Linux, or macOS. An operating system, or OS, is a program; 
 what makes it special is that it’s the only program on the computer that’s allowed 
 direct access to the hardware. When any other application (such as your browser, a 
 spreadsheet program, or a game) wants to draw on the screen, find out what key was 
 just pressed on the keyboard, or fetch data from storage, it sends a request to the OS 
 (see the top 
 image on page 8
 ).
  
 This may seem like a roundabout way of doing things, but it means that only the people 
 writing the OS have to worry about the differences between one graphics card and 
 another and whether the computer is connected to a network through Ethernet or 
 wireless. The rest of us—everyone analyzing
  
 report erratum  •  discuss",NA
Expressions and Values: Arithmetic in Python,"You’re familiar with mathematical expressions like 
 3 + 4
  (“three plus four”) and 
 2 - 3 / 5
  
 (“two minus three divided by five”); each expression is built out of 
 values
  like 
 2
 , 
 3
 , and 
 5
  
 and 
 operators
  like 
 +
  and 
 -
 , which combine their 
 operands 
 in different ways. In the 
 expression 
 4 / 5
 , the operator is “
 /
 ” and the operands are 
 4
  and 
 5
 .
  
 Expressions don’t have to involve an operator: a number by itself is an expression. For 
 example, we consider 
 212
  to be an expression as well as a value.
  
 Like any programming language, Python can 
 evaluate
  basic mathematical expressions. 
 For example, the following expression adds 
 4
  and 
 13
 :
  
 >>>
  4 + 13 
  
 17
  
 The 
 >>>
  symbol is called a 
 prompt
 . When you opened IDLE, a window should have 
 opened with this symbol shown; you don’t type it. It is prompting you to type 
 something. Here we typed 
 4 + 13
 , and then we pressed the Return (or Enter) key in 
 order to signal that we were done entering that 
 expression
 . Python then evaluated the 
 expression.
  
 When an expression is evaluated, it produces a single value. In the previous expression, 
 the evaluation of 
 4 + 13
  produced the value 
 17
 . When you type the expression in the 
 shell, Python shows the value that is produced.
  
 report erratum  •  discuss",NA
What Is a Type?,"We’ve now seen two types of numbers (integers and floating-point numbers),
  
 so we ought to explain what we mean by a 
 type
 . In Python, a type consists
  
 of two things:
  
 • A set of values
  
 • A set of operations that can be applied to those values
  
 For example, in type 
 int
 , the values are …, 
 -3
 , 
 -2
 , 
 -1
 , 
 0
 , 
 1
 , 
 2
 , 
 3
 , … and we have seen
  
 that these operators can be applied to those values: 
 +
 , 
 -
 , 
 *
 , 
 /
 , 
 //
 , 
 %
 , and 
 **
 .
  
 The values in type 
 float
  are a subset of the real numbers, and it happens that
  
 the same set of operations can be applied to 
 float
  values. We can see what
  
 happens when these are applied to various values in 
 Table 1, 
 Arithmetic
  
 Operators
 , on page 13
 . If an operator can be applied to more than one type
  
 of value, it is called an 
 overloaded operator
 .
  
 Finite Precision
  
 Floating-point numbers are not exactly the fractions you learned in grade school. For 
 example, look at Python’s version of the fractions 
 2
 ⁄
 3
  and 
 5
 ⁄
 3
 :
  
 report erratum  •  discuss",NA
Variables and Computer Memory: Remembering Values,"Like mathematicians, programmers frequently name values so that they can use them 
 later. A name that refers to a value is called a 
 variable
 . In Python, variable names can 
 use letters, digits, and the underscore symbol (but they can’t start with a digit). For 
 example, 
 X
 , 
 species5618
 , and 
 degrees_celsius
  are all allowed, but 
 777
  isn’t (it would be 
 confused with a number), and neither is 
 no-way!
  (it contains punctuation). Variable 
 names are case sensitive, so 
 ph
  and 
 pH
  are two different names.
  
 You create a new variable by 
 assigning
  it a value:
  
 >>>
  degrees_celsius = 26.0
  
 This statement is called an 
 assignment statement
 ; we say that 
 degrees_celsius
  is 
 assigned
  the 
 value 
 26.0
 . That makes 
 degrees_celsius
  refer to the value 
 26.0
 . We can
  
 report erratum  •  discuss",NA
How Python Tells You Something Went Wrong,"Broadly speaking, there are two kinds of errors in Python: 
 syntax errors
 , which happen 
 when you type something that isn’t valid Python code, and 
 semantic errors
 , which 
 happen when you tell Python to do something that it just can’t do, like divide a number 
 by zero or try to use a variable that doesn’t exist.
  
 report erratum  •  discuss",NA
A Single Statement That Spans Multiple Lines,"Sometimes statements get pretty intricate. The recommended Python style is to limit 
 lines to 80 characters, including spaces, tabs, and other 
 whitespace 
 characters, and 
 that’s a common limit throughout the programming world. Here’s what to do when 
 lines get too long or when you want to split it up for clarity.
  
 report erratum  •  discuss",NA
Describing Code,"Programs can be quite complicated and are often thousands of lines long. It can be 
 helpful to write a 
 comment
  describing parts of the code so that when you or someone 
 else reads it the meaning is clear.
  
 In Python, any time the 
 #
  character is encountered, Python will ignore the rest of the 
 line. This allows you to write English sentences:
  
 >>>
  # Python ignores this sentence because of the # symbol.
  
 report erratum  •  discuss",NA
Making Code Readable,"Much like there are spaces in English sentences to make the words easier to read, we 
 use spaces in Python code to make it easier to read. In particular, we always put a 
 space before and after every binary operator. For example, we write 
 v = 4 + -2.5 / 3.6
  
 instead of 
 v=4+-2.5/3.6
 . There are situations where it may not make a difference, but 
 that’s a detail we don’t want to fuss about, so we always do it: it’s almost never 
 harder
  
 to read if there are spaces.
  
 Psychologists have discovered that people can keep track of only a handful of things at 
 any one time (
 Forty Studies That Changed Psychology [Hoc04]
 ). Since programs can get 
 quite complicated, it’s important that you choose names for your variables that will 
 help you remember what they’re for. 
 id1
 , 
 X2
 , and 
 blah
  won’t remind you of anything 
 when you come back to look at your program next week: use names like 
 celsius
 , 
 average
 , 
 and 
 final_result
  instead.
  
 Other studies have shown that your brain automatically notices differences between 
 things—in fact, there’s no way to stop it from doing this. As a result, the more 
 inconsistencies there are in a piece of text, the longer it takes to read. (JuSt thInK a 
 bout how long It w o u l d tAKE you to rEa d this cHaPTer iF IT wAs fORmaTTeD like 
 thIs.) It’s therefore also important to use consistent names for variables. If you call 
 something 
 maximum
  in one place, don’t call it 
 max_val
  in another; if you use the name 
 max_val
 , don’t also use the name 
 maxVal
 , and so on.
  
 These rules are so important that many programming teams require members to 
 follow a style guide for whatever language they’re using, just as newspapers and book 
 publishers specify how to capitalize headings and whether to use a comma before the 
 last item in a list. If you search the Internet for 
 program-ming style guide
  
 (
 https://www.google.com/search?q=programming+style+guide
 ), 
 you’ll 
 discover 
 links 
 to 
 hundreds of examples. In this book, we follow the style guide for Python from 
 http://www.python.org/dev/peps/pep-0008/
 .
  
 You will also discover that lots of people have wasted many hours arguing over what 
 the “best” style for code is. Some of your classmates (and your
  
 report erratum  •  discuss",NA
The Object of This Chapter,"In this chapter, you learned the following:
  
 • An operating system is a program that manages your computer’s hardware on 
 behalf of other programs. An interpreter or virtual machine is a program that sits 
 on top of the operating system and runs your programs for you. The Python shell 
 is an interpreter, translating your Python statements into language the operating 
 system understands and translating the results back so you can see and use them.
  
 • Programs are made up of statements, or instructions. These can be simple 
 expressions like 
 3 + 4
  and assignment statements like 
 celsius = 20
  (which create new 
 variables or change the values of existing ones). There are many other kinds of 
 statements in Python, and we’ll introduce them throughout the book.
  
 • Every value in Python has a specific type, which determines what opera-tions can 
 be applied to it. The two types used to represent numbers are 
 int
  and 
 float
 . Floating-
 point numbers are approximations to real numbers.
  
 • Python evaluates an expression by applying higher-precedence operators before 
 lower-precedence operators. You can change that order by putting parentheses 
 around subexpressions.
  
 • Python stores every value in computer memory. A memory location con-taining a 
 value is called an object.
  
 • Variables are created by executing assignment statements. If a variable already 
 exists because of a previous assignment statement, Python will use that one 
 instead of creating a new one.
  
 • Variables contain memory addresses of values. We say that variables refer to values.
  
 • Variables must be assigned values before they can be used in expressions.",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 report erratum  •  discuss",NA
3,NA,NA
Designing and Using Functions,"Mathematicians create 
 functions
  to make calculations (such as Fahrenheit-to-Celsius 
 conversions) easy to reuse and to make other calculations easier to read because they 
 can use those functions instead of repeatedly writing out equations. Programmers do 
 this too, at least as often as mathematicians. In this chapter we will explore several of 
 the built-in functions that come with Python, and we’ll also show you how to define 
 your own functions.",NA
Functions That Python Provides,"Python comes with many 
 built-in functions
  that perform common operations. One 
 example is 
 abs
 , which produces the absolute value of a number:
  
 >>>
  abs(-9) 
  
 9 
  
 >>>
  abs(3.3) 
  
 3.3
  
 Each of these statements is a 
 function call
 .
  
 Keep Your Shell Open
  
 As a reminder, we recommend that you have IDLE open (or another Python editor) and that you 
 try all the code under discussion; this is a good way to cement your learning.
  
 The general form of a function call is as follows:
  
 «
 function_name
 »
 (
 «
 arguments
 »
 )
  
 An 
 argument
  is an expression that appears between the parentheses of a function call. 
 In 
 abs(-9)
 , the argument is 
 -9
 .
  
 report erratum  •  discuss",NA
Memory Addresses: How Python Keeps Track of Values,"Back in 
 Values, Variables, and Computer Memory
 , on page 16
 , you learned that
  
 Python keeps track of each value in a separate object and that each object has a
  
 memory address. You can discover the actual memory address of an object using
  
 built-in function 
 id
 :
  
 report erratum  •  discuss",NA
Defining Our Own Functions,"The built-in functions are useful but pretty generic. Often there aren’t built-
  
 in functions that do what we want, such as calculate mileage or play a game
  
 of cribbage. When we want functions to do these sorts of things, we have to
  
 write them ourselves.
  
 Because we live in Toronto, Canada, we often deal with our neighbor to the
  
 south. The United States typically uses Fahrenheit, so we convert from
  
 Fahrenheit to Celsius and back a lot. It sure would be nice to be able to do
  
 this:
  
 >>>
  convert_to_celsius(212) 
  
 100.0 
  
 >>>
  convert_to_celsius(78.8) 
  
 26.0 
  
 >>>
  convert_to_celsius(10.4)
  
 -12.0
  
 report erratum  •  discuss",NA
Using Local Variables for Temporary Storage,"Some computations are complex, and breaking them down into separate steps
  
 can lead to clearer code. In the next example, we break down the evaluation of the 
 quadratic polynomial 
 ax
 2
 + bx + c
  into several steps. Notice that all the
  
 statements inside the function are indented the same amount of spaces in
  
 order to be aligned with each other. You may want to type this example into
  
 an editor first (without the leading 
 >>>
  and 
 ...
 ) and then paste it to the Python
  
 shell. That makes fixing mistakes much easier:
  
 >>>
  def quadratic(a, b, c, x): 
  
 ... 
  
 first = a * x ** 2 
  
 ... 
  
 second = b * x 
  
 ... 
  
 third = c 
  
  
 return first + second + third 
 ...
  
 ...
  
 >>>
  quadratic(2, 3, 4, 0.5) 
  
 6.0 
  
 >>>
  quadratic(2, 3, 4, 1.5) 
  
 13.0
  
 Variables like 
 first
 , 
 second
 , and 
 third
  that are created within a function are called
  
 local variables
 . Local variables get created each time that function is called, and
  
 they are erased when the function returns. Because they only exist when the
  
 function is being executed, they can’t be used outside of the function. This means
  
 that trying to access a local variable from outside the function is an error, just
  
 like trying to access a variable that has never been defined is an error:
  
 >>>
  quadratic(2, 3, 4, 1.3) 
  
 11.280000000000001 
  
 >>>
  first 
  
 Traceback (most recent call last): 
  
 File ""<stdin>"", line 1, in <module> 
  
 NameError: name 'first' is not defined
  
 A function’s parameters are also local variables, so we get the same error if
  
 we try to use them outside of a function definition:
  
 report erratum  •  discuss",NA
Tracing Function Calls in the Memory Model,"Read the following code. Can you predict what it will do when we run it?
  
 >>>
  def f(x): 
  
 ... 
  
 x = 2 * x 
  
 ... 
  
 return x 
  
 ...
  
 >>>
  x = 1 
  
 >>>
  x = f(x + 1) + f(x + 2)
  
 That code is confusing, in large part because 
 x
  is used all over the place. However, it 
 is
  
 pretty short and it only uses Python features that we have seen so far: assignment 
 statements, expressions, function definitions, and function calls. We’re missing some 
 information: Are all the 
 x
 ’s the same variable? Does Python make a new 
 x
  for each 
 assignment? For each function call? For each function definition?
  
 Here’s the answer: whenever Python executes a function call, it creates a 
 namespace
  
 (literally, a space for names) in which to store local variables for that call. You can 
 think of a namespace as a scrap piece of paper; Python writes down the local variables 
 on that piece of paper, keeps track of them as long as the function is being executed, 
 and throws that paper away when the function returns.
  
 Separately, Python keeps another namespace for variables created in the shell. That 
 means that the 
 x
  that is a parameter of function 
 f
  is a different variable than the 
 x
  in the 
 shell!
  
 report erratum  •  discuss",NA
Designing New Functions: A Recipe,"Writing a good essay requires planning: deciding on a topic, learning the background 
 material, writing an outline, and then filling in the outline until you’re done.
  
 Similarly, writing a good function also requires planning. You have an idea of what you 
 want the function to do, but you need to decide on the details. 
 Every time you write a 
 function, you need to figure out the answers to the fol-lowing questions:
  
 • What do you name the function?
  
 • What are the parameters, and what types of information do they refer to?• What 
 calculations are you doing with that information?
  
 • What information does the function return?
  
 • Does it work like you expect it to?
  
 The function design recipe helps you find answers to all these questions.
  
 This section describes a step-by-step recipe for designing and writing a function. Part 
 of the outcome will be a working function, but almost as important is the 
 documentation
  for the function. Python uses three double quotes to start and end this 
 documentation; everything in between is meant for humans to read. This notation is 
 called a 
 docstring
 , which is short for 
 documentation string
 .
  
 Here is an example of a completed function. We’ll show you how we came up with this 
 using a function design recipe (FDR), but it helps to see a completed example first:
  
 >>>
  def days_difference(day1: int, day2: int) -> int: 
  
 ... 
  
 """"""Return the number of days between day1 and day2, which are ... 
  
 both in the range 
 1-365 (thus indicating the day of the ... 
  
 year).
  
 ...
  
 ... 
  
 >>> days_difference(200, 224) 
  
 ... 
  
 24 
  
 ... 
  
 >>> days_difference(50, 50) 
  
 ... 
  
 0 
  
 ... 
  
 >>> days_difference(100, 99) 
  
 ...
  
 -1 
  
 ... 
  
 """""" 
  
 ... 
  
 return day2 - day1 
  
 ...
  
 Here are the parts of the function, including the docstring:
  
 report erratum  •  discuss",NA
Writing and Running a Program,"So far, we have used the shell to investigate Python. As you have seen, the
  
 shell will show you the result of evaluating an expression:
  
 >>>
  3 + 5 / abs(-2) 
  
 5.5
  
 In a program that is supposed to interact with a human, showing the result
  
 of every expression is probably not desirable behavior. (Imagine if your web
  
 browser showed you the result of every calculation it performed.)
  
 report erratum  •  discuss",NA
Omitting a return Statement: None,"If you don’t have a 
 return
  statement in a function, nothing is produced:
  
 >>>
  def f(x): 
  
 ... 
  
 x = 2 * x 
  
 ...
  
 >>>
  res = f(3) 
  
 >>>
  res 
  
 >>>
  
 Wait, that can’t be right—if 
 res
  doesn’t have a value, shouldn’t we get a
  
 NameError
 ? Let’s investigate:
  
 >>>
  print(res) 
  
 None 
  
 >>>
  id(res) 
  
 1756120",NA
Dealing with Situations That Your Code Doesn’t Handle,"You’ll often write a function that works only in some situations. For example,
  
 you might write a function that takes as a parameter a number of people who
  
 want to eat a pie and returns the percentage of the pie that each person gets
  
 to eat. If there are five people, each person gets 20% of the pie; if there are
  
 two people, each person gets 50%; if there is one person, that person gets
  
 100%; but if there are zero people, what should the answer be?
  
 Here is an implementation of this function:
  
 def
  pie_percent(n: int) -> int: 
  
 """"""Assuming there are n people who want to eat a pie, return the percentage of the pie that 
 each person gets to eat.
  
 >>> pie_percent(5) 
  
 20 
  
 >>> pie_percent(2) 
  
 50 
  
 >>> pie_percent(1) 
  
 100 
  
 """"""
  
 return
  int(100 / n)
  
 Reading the code, if someone calls 
 pie_percent(0)
 , then you probably see that
  
 this will result in a 
 ZeroDivisionError
 . There isn’t anything that anyone can do
  
 about this situation; there isn’t a sensible answer.
  
 As a programmer, you warn other people about situations that your function
  
 isn’t set up to handle by describing your assumptions in a 
 precondition
 . Here
  
 is the same function with a precondition:",NA
What Did You Call That?,"• A function definition introduces a new variable that refers to a function object. The 
 return
  statement describes the value that will be produced as a result of the 
 function when this function is done being executed.
  
 • A parameter is a variable that appears between the parentheses of a function 
 header.
  
 • A local variable is a variable that is used in a function definition to store an 
 intermediate result in order to make code easier to write and read.
  
 • A function call tells Python to execute a function.
  
 • An argument is an expression that appears between the parentheses of a function 
 call. The value that is produced when Python evaluates the expression is assigned 
 to the corresponding parameter.
  
 • If you made assumptions about the values of parameters or you know that your 
 function won’t work with particular values, write a precondition to warn other 
 programmers.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Two of Python’s built-in functions are 
 min
  and 
 max
 . In the Python shell, 
  
 execute the following function calls:
  
 a. 
  
 min(2, 3, 4)
  
 b. 
  
 max(2, -3, 4, 7, -5)
  
 c. 
  
 max(2, -3, min(4, 7), -5)
  
 2. 
  
 For the following function calls, in what order are the subexpressions 
  
 evaluated?
  
 a. 
  
 min(max(3, 4), abs(-5))
  
 b. 
  
 abs(min(4, 6, max(2, 8)))
  
 c. 
  
 round(max(5.572, 3.258), abs(-2))
  
 3. 
  
 Following the function design recipe, define a function that has one 
  
 parameter, a 
 number, and returns that number tripled.
  
 4. 
  
 Following the function design recipe, define a function that has two 
  
 parameters, 
 both of which are numbers, and returns the absolute value 
  
 of the difference of the 
 two. Hint: Call built-in function 
 abs
 .
  
 5. 
  
 Following the function design recipe, define a function that has one 
  
 parameter, a 
 distance in kilometers, and returns the distance in miles.
  
 (There are 1.6 kilometers per mile.)
  
 6. 
  
 Following the function design recipe, define a function that has three 
  
 parameters, 
 grades between 0 and 100 inclusive, and returns the average 
  
 of those grades.
  
 7. 
  
 Following the function design recipe, define a function that has four 
  
 parameters, 
 all of them grades between 0 and 100 inclusive, and returns 
  
 the average of the 
 best 
 3
  of those grades. Hint: Call the function that you 
  
 defined in the previous 
 exercise.
  
 8. 
  
 Complete the examples in the docstring and then write the body of the 
  
 following function:
  
 report erratum  •  discuss",NA
4,NA,NA
Working with Text,"From email clients and web browsers to calendars and games, text plays a central role 
 in computer programs. This chapter introduces a non-numeric data type that 
 represents text, such as the words in this sentence or the sequence of bases in a strand 
 of DNA. Along the way, we will see how to make programs a little more interactive by 
 printing messages to our programs’ users and getting input from them.",NA
Creating Strings of Characters,"Computers may have been invented to do arithmetic, but these days, most of them 
 spend a lot of their time processing text. Many programs create text, store it, search it, 
 and move it from one place to another.
  
 In Python, text is represented as a 
 string
 , which is a sequence of 
 characters 
 (letters, 
 digits, and symbols). The type whose values are sequences of charac-ters is 
 str
 . The 
 characters consist of those from the Latin alphabet found on most North American 
 keyboards, as well as Chinese morphograms, chemical symbols, musical symbols, and 
 much more.
  
 In Python, we indicate that a value is a string by putting either single or double quotes 
 around it. As we will see in 
 Using Special Characters in Strings
 , on page 68
 , single and 
 double quotes are equivalent except for strings that contain quotes. You can use 
 whichever you prefer. (For docstrings, the Python style guidelines say that double 
 quotes are preferred.) Here are two examples:
  
 >>>
  'Aristotle' 
  
 'Aristotle' 
  
 >>>
  ""Isaac Newton"" 
  
 'Isaac Newton'
  
 The opening and closing quotes must match:
  
 report erratum  •  discuss",NA
Using Special Characters in Strings,"Suppose you want to put a single quote inside a string. If you write it directly, an
  
 error occurs:
  
 >>>
  'that'
 s not going to work' 
  
 File ""<stdin>"", line 1 
  
   
 'that's not going to work' 
  
   
 ^ 
  
 SyntaxError: invalid syntax
  
 When Python encounters the second quote—the one that is intended to be
  
 part of the string—it thinks the string is ended. It doesn’t know what to do
  
 with the text that comes after the second quote.
  
 report erratum  •  discuss",NA
Creating a Multiline String,"If you create a string using single or double quotes, the whole string must fit
  
 onto a single line.
  
 Here’s what happens when you try to stretch a string across multiple lines:
  
 >>>
  'one 
  
 File ""<stdin>"", line 1 
  
   
 'one 
  
    
 ^ 
  
 SyntaxError: EOL while scanning string literal
  
 As we saw in 
 Creating Strings of Characters
 , on page 65
 , EOL stands for “end
  
 of line”. So in this error report, Python is saying that it reached the end of
  
 the line before it found the end of the string.
  
 To span multiple lines, put three single quotes or three double quotes around
  
 the string instead of one. The string can then span as many lines as you want:
  
 >>>
  ''
 'one 
  
 ...
  two 
  
 ...
  three
 ''
 ' 
  
 'one\ntwo\nthree'
  
 Notice that the string Python creates contains a 
 \n
  sequence everywhere our
  
 input started a new line. Each newline is a character in the string.
  
 Normalizing Line Endings
  
 Each of the three major operating systems uses a different set of characters to indicate
  
 the end of a line. This set of characters is called a 
 newline
 . On Linux and macOS, a newline is one 
 \n
  character; on version 9 and earlier of Mac OS, it is one 
 \r
 ; and on Windows, the ends of lines 
 are marked with both characters as 
 \r\n
 .
  
 Python always uses a single 
 \n
  to indicate a newline, even on operating systems like
  
 Windows that do things other ways. This is called 
 normalizing
  the string; Python does
  
 this so that you can write exactly the same program no matter what kind of machine
  
 you’re running on.",NA
Printing Information,"In 
 Writing and Running a Program
 , on page 58
 , built-in function 
 print
  was used
  
 to print values to the screen. We will use 
 print
  to print messages to the users
  
 of our program. Those messages may include the values that expressions
  
 produce and the values that the variables refer to. Here are two examples of
  
 printing:
  
 report erratum  •  discuss",NA
Getting Information from the Keyboard,"In 
 Chapter 3, 
 Designing and Using Functions
 , on page 31
 , we explored some
  
 built-in functions. Another built-in function is 
 input
 , which reads a single line
  
 of text from the keyboard. It returns whatever the user enters as a string,
  
 even if it looks like a number:
  
 >>>
  species = input() 
  
 Homo sapiens 
  
 >>>
  species 
  
 'Homo sapiens' 
  
 >>>
  population = input() 
  
 6973738433 
  
 >>>
  population 
  
 '6973738433' 
  
 >>>
  type(population) 
  
 <class 'str'>
  
 report erratum  •  discuss",NA
Quotes About Strings,"In this chapter, you learned the following:
  
 • Python uses type 
 str
  to represent text as sequences of characters.
  
 • Strings are created by placing pairs of single quotes 
 '
  or double quotes 
 ""
  
 around the text.
  
 •
 '''Should you want a string 
  
 that crosses multiple lines, 
  
 Use matched triple quotes.'''
  
 • Special characters like newline (
 \n
 ) and tab (
 \t
 ) are represented using escape
  
 sequences that begin with a backslash. For example, 
 'this string\nspans\nthree
  
 lines'.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available
  
 at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 What value does each of the following expressions evaluate to? Verify your
  
 answers by typing the expressions into the Python shell.
  
 a. 
  
 'Computer' + ' Science'
  
 b. 
  
 'Darwin\'s'
  
 c. 
  
 'H2O' * 3
  
 d. 
  
 'CO2' * 0
  
 2. 
  
 Express each of the following phrases as Python strings using the
  
 appropriate type of quotation marks (single, double, or triple) and, if
  
 necessary, escape sequences. There is more than one correct answer for
  
 each of these phrases.
  
 a. 
  
 They’ll hibernate during the winter.
  
 b.
  
 “Absolutely not,” he said.
  
 c.
  
 “He said, ‘Absolutely not,’” recalled Mel.
  
 d. 
  
 hydrogen sulfide
  
 e. 
  
 left\right
  
 3. 
  
 Rewrite the following string using single or double quotes instead of triple
  
 quotes:
  
 '''A
  
 B
  
 C'''
  
 4. 
  
 Use built-in function 
 len
  to find the length of the empty string.
  
 5. 
  
 Given variables 
 x
  and 
 y
 , which refer to values 
 3
  and 
 12.5
 , respectively, use
  
 function 
 print
  to print the following messages. When numbers appear in
  
 the messages, variables 
 x
  and 
 y
  should be used.
  
 a. 
  
 b.
  
 The rabbit is 3.
  
 The rabbit is 3 years old.
  
 report erratum  •  discuss",NA
5,NA,NA
Making Choices,"This chapter introduces another fundamental concept of programming: making 
 choices. We do this whenever we want our program to behave differ-ently depending 
 on the data it’s working with. For example, we might want to do different things 
 depending on whether a solution is acidic or basic, or depending on whether a user 
 types yes or no in response to a call on built-in function 
 input
 .
  
 We’ll introduce statements for making choices in this chapter called 
 control flow
  
 statements (because they control the way the computer executes pro-grams). These 
 statements involve a Python type that is used to represent truth and falsehood. Unlike 
 the integers, floating-point numbers, and strings we have already seen, this type has 
 only two values and three operators.",NA
A Boolean Type,"In Python, there is a type called 
 bool
  (without an “e”). Unlike 
 int
  and 
 float
 , which have 
 billions of possible values, 
 bool
  has only two: 
 True
  and 
 False
 . 
 True
  and 
 False 
 are values, just 
 as much as the numbers 
 0
  and 
 -43.7
 .
  
 George Boole
  
 In the 1840s, the mathematician George Boole showed that the classical rules of logic could be 
 expressed in purely mathematical form using only the two values 
 true 
 and 
 false
 . A century later, 
 Claude Shannon (the inventor of information theory) realized that Boole’s work could be used 
 to optimize the design of electromechanical telephone switches. His work led directly to the use 
 of 
 Boolean logic
  to design computer circuits.
  
 In honor of Boole’s work, most modern programming languages use a type named after him to 
 keep track of what’s true and what isn’t.
  
 report erratum  •  discuss",NA
Choosing Which Statements to Execute,"An 
 if
  statement lets you change how your program behaves based on a condi-
  
 tion. The general form of an 
 if
  statement is as follows:
  
 if
  «
 condition
 »
 :
  
 «
 block
 »
  
 The 
 condition
  is an expression, such as 
 color != “neon green”
  or 
 x < y
 . (Note that
  
 this doesn’t have to be a Boolean expression. As we discussed in 
 Using Num-
  
 bers and Strings with Boolean Operators
 ,  on page 84
 , non-Boolean values
  
 are treated as 
 True
  or 
 False
  when required.)
  
 As with function bodies, the block of statements inside an 
 if
  must be indented.
  
 As a reminder, the standard indentation for Python is four spaces.
  
 If the condition is true, the statements in the block are executed; otherwise,
  
 they are not. As with functions, the block of statements must be indented to
  
 show that it belongs to the 
 if
  statement. If you don’t indent properly, Python
  
 might raise an error, or worse, might happily execute the code that you wrote
  
 report erratum  •  discuss",NA
Nested if Statements,"An 
 if
  statement’s block can contain any type of Python statement, which
  
 implies that it can include other 
 if
  statements. An 
 if
  statement inside another
  
 is called a 
 nested
  if
  statement.
  
 value = input(
 'Enter the pH level: '
 ) 
  
 if
  len(value) > 0: 
  
  
 ph = float(value) 
  
  
 if
  ph < 7.0: 
  
  
  
 print
 (ph,
  ""is acidic.""
 ) 
  
  
 elif
  ph > 7.0: 
  
  
  
 print
 (ph,
  ""is basic.""
 ) 
  
  
 else
 : 
  
  
  
 print
 (ph,
  ""is neutral.""
 ) 
  
 else
 : 
  
  
 print
 (
 ""No pH value was given!""
 )
  
 In this case, we ask the user to provide a pH value, which we’ll initially receive
  
 as a string. The first, or 
 outer
 , 
 if
  statement checks whether the user typed some-
  
 thing, which determines whether we examine the value of 
 pH
  with the 
 inner
  if
  
 statement. (If the user didn’t enter a number, then function call 
 float(value)
  will
  
 produce a 
 ValueError
 .)
  
 Nested 
 if
  statements are sometimes necessary, but they can get complicated and
  
 difficult to understand. To describe when a statement is executed, we have to
  
 mentally combine conditions; for example, the statement 
 print(ph, ""is acidic."")
  is exe-
  
 cuted only if the length of the string that 
 value
  refers to is greater than 
 0
  and
  pH <
  
 7.0
  also evaluates to 
 True
  (assuming the user entered a number).",NA
Remembering Results of a Boolean Expression Evaluation,"Take a look at the following line of code and guess what value is assigned to 
 x
 :
  
 >>>
  x = 15 > 5
  
 report erratum  •  discuss",NA
You Learned About Booleans: True or False?,"In this chapter, you learned the following:
  
 • Python uses Boolean values, 
 True
  and 
 False
 , to represent what is true and
  
 what isn’t. Programs can combine these values using three operators: 
 not
 ,
  
 and
 , and 
 or
 .
  
 • Boolean operators can also be applied to numeric values. 
 0
 , 
 0.0
 , the empty
  
 string, and 
 None
  are treated as 
 False
 ; all other numeric values and strings
  
 are treated as 
 True
 . It is best to avoid applying Boolean operators to non-
  
 Boolean values.
  
 • Relational operators such as “equals” and “less than” compare values and
  
 produce a Boolean result.
  
 • When different operators are combined in an expression, the order of prece-
  
 dence from highest to lowest is arithmetic, relational, and then Boolean.
  
 •
  if
  statements control the flow of execution. As with function definitions, the
  
 bodies of 
 if
  statements are indented, as are the bodies of 
 elif
  and 
 else
  clauses.",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available
  
 at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 What value does each expression produce? Verify your answers by typing
  
 the expressions into Python.
  
 a. 
  
 b. 
  
 c.
  
 True and not False 
  
 True and not false
  (Notice the capitalization.) 
  
 True or True and False
  
 report erratum  •  discuss",NA
6,NA,NA
A Modular Approach,NA,NA
to Program Organization,"Mathematicians don’t prove every theorem from scratch. Instead, they build
  
 their proofs on the truths their predecessors have already established. In the
  
 same way, it’s rare for someone to write all of a program alone; it’s much more
  
 common—and productive—to make use of the millions of lines of code that
  
 other programmers have written before.
  
 What Happens When You Import This?
  
 >>>
  import this 
  
 The Zen of Python, by Tim Peters
  
 Beautiful is better than ugly.
  
 Explicit is better than implicit.
  
 Simple is better than complex.
  
 Complex is better than complicated.
  
 Flat is better than nested.
  
 Sparse is better than dense.
  
 Readability counts.
  
 Special cases aren't special enough to break the rules.
  
 Although practicality beats purity.
  
 Errors should never pass silently.
  
 Unless explicitly silenced.
  
 In the face of ambiguity, refuse the temptation to guess.
  
 There should be one -- and preferably only one -- obvious way to do it.
  
 Although that way may not be obvious at first unless you're Dutch. Now is better than never.
  
 Although never is often better than *right* now.
  
 If the implementation is hard to explain, it's a bad idea.
  
 If the implementation is easy to explain, it may be a good idea.
  
 Namespaces are one honking great idea -- let's do more of those!
  
 report erratum  •  discuss",NA
Importing Modules,"To gain access to the variables and functions from a module, you have to
  
 import
  it. To tell Python that you want to use functions in module 
 math
 , for
  
 example, you use this 
 import
  statement:
  
 >>>
  import math
  
 Importing a module creates a new variable with that name. That variable
  
 refers to an object whose type is 
 module
 :
  
 >>>
  type(math) 
  
 <class 'module'>
  
 Once you have imported a module, you can use built-in function 
 help
  to see
  
 what it contains. Here is the first part of the help output:
  
 >>>
  help(math) 
  
 Help on module math:
  
 NAME 
  
  
 math
  
 MODULE REFERENCE 
  
  
 https://docs.python.org/3.6/library/math
  
 The following documentation is automatically generated from the Python source files. 
  
 It may be 
 incomplete, incorrect or include features that are considered implementation detail and may vary 
 between Python implementations. 
  
 When in doubt, consult the module reference at the 
 location listed above.
  
 DESCRIPTION 
  
  
 This module is always available. 
  
 It provides access to the 
  
 mathematical functions defined by the C standard.
  
 FUNCTIONS 
  
  
 acos(...) 
  
  
  
 acos(x) 
  
  
  
 Return the arc cosine (measured in radians) of x.
  
 acosh(...) 
  
 acosh(x) 
  
 Return the inverse hyperbolic cosine of x.
  
 [Lots of other functions not shown here.]
  
 report erratum  •  discuss",NA
Defining Your Own Modules,"Writing and Running a Program
 , on page 58
 , explained that in order to save
  
 code for later use, you can put it in a file with a 
 .py
  extension, and it demon-
  
 strated how to run that code. 
 Chapter 3, 
 Designing and Using Functions
 , on
  
 page 31
 , also included this function definition:
  
 >>>
  def convert_to_celsius(fahrenheit: float) -> float: 
  
 ... 
  
 """"""Return the number of Celsius degrees equivalent to fahrenheit ... 
  
 degrees.
  
 ...
  
 ... 
  
 >>> convert_to_celsius(75) 
  
 ... 
  
 23.88888888888889 
  
 ... 
  
 """""" 
  
 ... 
  
 return (fahrenheit - 32.0) * 5.0 / 9.0 
  
 ...
  
 Put the function definition for 
 convert_to_celsius
  from 
 Defining Our Own Functions
 ,
  
 on page 35
 , in a file called 
 temperature.py
 . (You can save this file anywhere you
  
 like, although most programmers create a separate directory for each set of
  
 related files that they write.) Add another function to 
 temperature.py
  called
  
 above_freezing
  that returns 
 True
  if and only if its parameter 
 celsius
  is above freezing
  
 as shown in the 
 screenshot on page 105
 .
  
 Congratulations—you have created a module called 
 temperature
 . Now that you’ve
  
 created this file, you can run it and import it like any other module:
  
 >>>
  import temperature 
  
 >>>
  celsius = temperature.convert_to_celsius(33.3) 
 >>>
  
 temperature.above_freezing(celsius) 
  
 True
  
 report erratum  •  discuss",NA
Testing Your Code Semiautomatically,"In 
 Designing New Functions: A Recipe
 , on page 47
 , we introduced the function design 
 recipe (FDR). Following the FDR, the docstrings that we write include example 
 function calls.
  
 The last step of the FDR involves testing the function. Up until now, we have been 
 typing the function calls from the docstrings to the shell (or copying and pasting them) 
 to run them and then have been comparing the results with what we expect to make 
 sure they match.
  
 report erratum  •  discuss",NA
Tips for Grouping Your Functions,"Put functions and variables that logically belong together in the same module. If there 
 isn’t some logical connection—for example, if one of the functions calculates how much 
 carbon monoxide different kinds of cars produce, while another figures out bone 
 strength given the bone’s diameter and density—then you shouldn’t put them in one 
 module just because you happen to be the author of both.
  
 Of course, people often have different opinions about what is logical and what isn’t. Take 
 Python’s 
 math
  module, for example; should functions to multiply matrices go in there too, or 
 should they go in a separate linear algebra module? What about basic statistical functions? 
 Going back to the previous paragraph, should a function that calculates gas mileage go in 
 the same module as one that
  
 report erratum  •  discuss",NA
Organizing Our Thoughts,"In this chapter, you learned the following:
  
 • A module is a collection of functions and variables grouped together in a file. To use 
 a module, you must first import it using 
 import «modulename»
 . After it has been 
 imported, you refer to its contents using 
 «modulename».«func-tionname»
  or 
 «modulename».«variable»
 .
  
 • Variable 
 __name__
  is created by Python and can be used to specify that some code 
 should only run when the module is run directly and not when the module is 
 imported.
  
 • Programs have to do more than just run to be useful; they have to run correctly. 
 One way to ensure that they do is to test them, which you can do in Python using 
 module 
 doctest
 .",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Import module 
 math
 , and use its functions to complete the following 
  
 exercises. 
 (You can call 
 dir(math)
  to get a listing of the items in 
 math
 .)
  
 a. 
  
 Write an expression that produces the floor of 
 -2.8
 .
  
 b. 
  
 Write an expression that rounds the value of 
 -4.3
  and then produces 
  
 the 
 absolute value of that result.
  
 c. 
  
 Write an expression that produces the ceiling of the sine of 
 34.5
 .
  
 2. 
  
 In the following exercises, you will work with Python’s 
 calendar
  module:
  
 a. 
  
 Visit the Python documentation website at 
 http://docs.python.org/release/ 
  
 3.6.0/py-modindex.html
 , and look at the documentation on module 
 calendar
 .
  
 report erratum  •  discuss",NA
7,NA,NA
Using Methods,"So far we’ve seen lots of functions: built-in functions, functions inside modules,
  
 and functions that we’ve defined. A 
 method
  is another kind of function that
  
 is attached to a particular type. There are 
 str
  methods, 
 int
  methods, 
 bool
  
 methods, and more—every type has its own set of methods. In this chapter,
  
 we’ll explore how to use methods and also how they differ from the rest of the
  
 functions that we’ve seen.",NA
"Modules, Classes, and Methods","In 
 Importing Modules
 , on page 100
 , we saw that a module is a kind of object,
  
 one that can contain functions and other variables. There is another kind of
  
 object that is similar to a module: a 
 class
 . You’ve been using classes all along,
  
 probably without realizing it: a class is how Python represents a type.
  
 You may have called built-in function 
 help
  on 
 int
 , 
 float
 , 
 bool
 , or 
 str
 . We’ll do that
  
 now with 
 str
  (notice that the first line says that it’s a class):
  
 >>>
  help(str) 
  
 Help on class str in module builtins:
  
 class str(object) 
  
 | 
  
 str(object='') -> str 
  
 | 
  
 str(bytes_or_buffer[, encoding[, errors]]) -> str 
  
 | 
  
 | 
  
 Create a new string object from the given object. If encoding or | 
  
 errors is specified, then 
 the object must expose a data buffer | 
  
 that will be decoded using the given encoding and error 
 handler.
  
 | 
  
 Otherwise, returns the result of object.__str__() (if defined) | 
  
 or repr(object).
  
 | 
  
 encoding defaults to sys.getdefaultencoding().
  
 | 
  
 errors defaults to 'strict'.
  
 | 
  
 | 
  
 Methods defined here: 
  
 |
  
 report erratum  •  discuss",NA
Calling Methods the Object-Oriented Way,"Because every method in class 
 str
  requires a string as the first argument (and, more 
 generally, because every method in any class requires an object of that class as the first 
 argument), Python provides a shorthand form for calling a method where the object 
 appears first and then the method call:
  
 >>>
  'browning'
 .capitalize() 
  
 'Browning' 
  
 >>>
  'Sonnet 43'
 .center(26) 
  
 ' 
  
 Sonnet 43 
  
  
 ' 
  
 >>>
  'How do I love thee? 
  
 Let me count the ways.'
 .count(
 'the'
 ) 
 2
  
 When Python encounters one of these method calls, it translates it to the more long-
 winded form. We will use this shorthand form throughout the rest of the book.
  
 The help documentation for methods uses this form. Here is the help for method 
 lower
  
 in class 
 str
 . (Notice that we can get help for a single method by prefixing it with the 
 class it belongs to.)
  
 >>>
  help(str.lower) 
  
 Help on method_descriptor:
  
 lower(...) 
  
  
 S.lower() -> str
  
 Return a copy of the string S converted to lowercase.
  
 Contrast that documentation with the help for function 
 sqrt
  in module 
 math
 :
  
 report erratum  •  discuss",NA
Exploring String Methods,"Strings are central to programming; almost every program uses strings in some way. 
 We’ll explore some of the ways in which we can manipulate strings and, at the same 
 time, firm up our understanding of methods.
  
 Listed in 
 Table 8, 
 Common String Methods
 ,
 are the most commonly used string methods. 
 (You can find the complete list in Python’s online documentation, or type 
 help(str)
  into 
 the shell.)
  
 Method
  
 Description
  
 str.capitalize()
  
 Returns a copy of the string with the first letter
  
 capitalized and the rest lowercase.
  
 str.count(s) 
  
 Returns the number of nonoverlapping occurrences 
  
 of 
 s
  
 in the string.
  
 str.endswith(end) 
  
 Returns 
 True
  if and only if the string ends with the 
  
 characters in the 
 end
  string—this is case sensitive.
  
 str.find(s) 
  
  
 Returns the index of the first occurrence of 
 s
  in the 
  
 string, or 
 -1
  if 
 s
  doesn’t occur in the string—the first 
  
  
 character is at index 0. This is case sensitive.
  
 str.find(s, beg) 
  
  
 Returns the index of the first occurrence of 
 s
  at or 
  
 after index 
 beg
  in the string, or 
 -1
  if 
 s
  doesn’t occur 
  
  
 in the string at or after index 
 beg
 —the first character 
  
  
 is at index 0. This is case sensitive.
  
 str.find(s, beg, end) 
  
  
 Returns the index of the first occurrence of 
 s
  between 
  
 indices 
 beg
  (inclusive) and 
 end
  (exclusive) in the 
  
  
 string, or 
 -1
  if 
 s
  does not occur in the string between 
  
 indices 
 beg
  and 
 end
 —the first character is at index 
  
 0. 
 This is case sensitive.
  
 str.format(«expressions») 
  
 Returns a string made by substituting for placehold-
  
 er 
 fields in the string—each field is a pair of braces 
  
  
 (
 '{'
  and 
 '}'
 ) with an 
 integer in between; the expression 
  
 arguments are numbered from left to right 
 starting
  
 report erratum  •  discuss",NA
What Are Those Underscores?,"Any method (or other name) beginning and ending with two underscores is
  
 considered special by Python. The help documentation for strings shows these
  
 methods, among many others:
  
 | 
  
 Methods defined here: 
  
 | 
  
 | 
  
 __add__(self, value, /) 
  
 | 
   
 Return self+value.
  
 These methods are typically connected with some other syntax in Python:
  
 use of that syntax will trigger a method call. For example, string method 
 __add__
  
 is called when anything is added to a string:
  
 report erratum  •  discuss",NA
A Methodical Review,"In this chapter, you learned the following:
  
 • Classes are like modules, except that classes contain methods and mod-
  
 ules contain functions.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available
  
 at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 In the Python shell, execute the following method calls:
  
 a. 
  
 'hello'.upper()
  
 b. 
  
 'Happy Birthday!'.lower()
  
 c. 
  
 'WeeeEEEEeeeEEEEeee'.swapcase()
  
 d. 
  
 'ABC123'.isupper()
  
 e. 
  
 'aeiouAEIOU'.count('a')
  
 f. 
  
 'hello'.endswith('o')
  
 g. 
  
 'hello'.startswith('H')
  
 h. 
  
 'Hello {0}'.format('Python')
  
 i. 
  
 'Hello {0}! Hello {1}!'.format('Python', 'World')
  
 2. 
  
 Using string method 
 count
 , write an expression that produces the number
  
 of 
 o
 ’s in 
 'tomato'
 .
  
 3. 
  
 Using string method 
 find
 , write an expression that produces the index of
  
 the first occurrence of 
 o
  in 
 'tomato'
 .
  
 4. 
  
 Using string method 
 find
 , write a 
 single
  expression that produces the index
  
 of the 
 second
  occurrence of 
 o
  in 
 'tomato'
 . Hint: Call 
 find
  twice.
  
 5. 
  
 Using your expression from the previous exercise, find the second 
 o
  in
  
 'avocado'
 . If you don’t get the result you expect, revise the expression and
  
 try again.
  
 6. 
  
 Using string method 
 replace
 , write an expression that produces a string
  
 based on 
 'runner'
  with the 
 n
 ’s replaced by 
 b
 ’s.
  
 report erratum  •  discuss",NA
8,NA,NA
Storing Collections of Data Using Lists,"Up to this point, we have seen numbers, Boolean values, strings, functions, and a few 
 other types. Once one of these objects has been created, it can’t be modified. In this 
 chapter, you will learn how to use a Python type named 
 list
 . Lists contain zero or more 
 objects and are used to keep track of collections of data. Unlike the other types you’ve 
 learned about, lists can be modified.",NA
Storing and Accessing Data in Lists,"Table 9 shows the number of gray whales counted near the Coal Oil Point 
  
 1 
 Natural 
 Reserve in a two-week period starting on February 24, 2008.
  
 Day
  
 Number of Whales
  
 Day
  
 Number of Whales
  
 1
  
 5
  
 8
  
 6
  
 2
  
 4
  
 9
  
 4
  
 3
  
 7
  
 10
  
 2
  
 4
  
 3
  
 11
  
 1
  
 5
  
 2
  
 12
  
 7
  
 6
  
 3
  
 13
  
 1
  
 7
  
 2
  
 14
  
 3
  
 Table 9—Gray Whale Census
  
 Using what we have seen so far, we would have to create fourteen variables to keep 
 track of the number of whales counted each day as shown in the 
 figure on page 130
 .
  
 1.
  
 Gray Whales Count nonprofit 501(c)(3) corporation for research and education:
  
 http://www.graywhalescount.org/gwc/GWC_REPORTS.html
 .
  
 report erratum  •  discuss",NA
Type Annotations for Lists,"When writing type contracts for functions, often we’ll want to specify that the values in 
 a 
 list
  parameter are all of a particular type. For example, we might write a function to 
 calculate the average of a list of floats:
  
 >>>
  def average(L: list) -> float: 
  
 ... 
  
 """"""Return the average of the values in L. ...
  
 ... 
  
 >>> average([1.4, 1.6, 1.8, 2.0]) 
  
 ... 
  
 1.7 
  
 ... 
  
 """"""
  
 There is currently no indication that the function works only with lists of numbers, but 
 it would be odd to call it with a list of strings, for example. To address this, Python 
 includes module 
 typing
  that allows us to specify the expected type of value contained in 
 a list (and in other types that you’ll encounter in 
 Chapter 10, 
 Reading and Writing Files
 , 
 on page 173
  and 
 Chapter 11, 
 Storing Data Using Other Collection Types
 , on page 203
 ). 
 In order to prevent conflicts with type 
 list
 , this module contains a capitalized version, 
 List
 , that we can use in the type annotation:
  
 >>>
  from typing import List 
  
 >>>
  def average(L: List[float]) -> float: 
  
 ... 
  
 """"""Return the average of the values in L. ...
  
 ... 
  
 >>> average([1.4, 1.6, 1.8, 2.0]) 
  
  
 1.7 ...
  
 ... 
  
 """"""
  
 This doesn’t prevent a programmer from calling our function with other kinds of data 
 (even though this would often result in an error), but it does indicate what we expect 
 when someone calls our function.",NA
Modifying Lists,"Suppose you’re typing in a list of the noble gases and your fingers slip:
  
 >>>
  nobles = [
 'helium'
 ,
  'none'
 ,
  'argon'
 ,
  'krypton'
 ,
  'xenon'
 ,
  'radon'
 ]
  
 report erratum  •  discuss",NA
Operations on Lists,"Functions That Python Provides
 , on page 31
 , and 
 Operations on Strings
 , on
  
 page 66
 , introduced a few of Python’s built-in functions. Some of these, such
  
 as 
 len
 , can be applied to lists, as well as others we haven’t seen before. (See
  
 the following table.)
  
 Function
  
 Description
  
 len(L) 
  
 max(L) 
  
 min(L) 
  
 sum(L) 
  
 sorted(L)
  
 Returns the number of items in list 
 L 
  
 Returns the maximum value in list 
 L 
  
 Returns the minimum value in list 
 L 
  
 Returns the sum of the values in list 
 L 
  
 Returns a copy of list 
 L
  where the items are in order from
  
 smallest to largest (This does not mutate 
 L
 .)
  
 Table 10—List Functions
  
 Here are some examples. The half-life of a radioactive substance is the time
  
 taken for half of it to decay. After twice this time has gone by, three-quarters
  
 of the material will have decayed; after three times, seven-eighths will have
  
 decayed, and so on.
  
 An 
 isotope
  is a form of a chemical element. Plutonium has several isotopes,
  
 and each has a different half-life. Here are some of the built-in functions in
  
 action working on a list of the half-lives of plutonium isotopes Pu-238, Pu-239,
  
 Pu-240, Pu-241, and Pu-242:
  
 >>>
  half_lives = [887.7, 24100.0, 6563.0, 14, 373300.0] 
 >>>
  len(half_lives) 
  
 5 
  
 >>>
  max(half_lives) 
  
 373300.0 
  
 >>>
  min(half_lives)
  
 report erratum  •  discuss",NA
Slicing Lists,"Geneticists describe 
 C. elegans
  phenotypes (nematodes, a type of microscopic
  
 worms) using three-letter short-form markers. Examples include 
 Emb
  
 (embryonic lethality), 
 Him
  (high incidence of males), 
 Unc
  (uncoordinated), 
 Dpy
  
 (dumpy: short and fat), 
 Sma
  (small), and 
 Lon
  (long). We can keep a list:
  
 >>>
  celegans_phenotypes = [
 'Emb'
 ,
  'Him'
 ,
  'Unc'
 ,
  'Lon'
 ,
  'Dpy'
 ,
  'Sma'
 ] 
 >>>
  celegans_phenotypes 
  
 ['Emb', 'Him', 'Unc', 'Lon', 'Dpy', 'Sma']
  
 It turns out that 
 Dpy
  worms and 
 Sma
  worms are difficult to distinguish from
  
 each other, so they aren’t as easily differentiated in complex strains. We can
  
 report erratum  •  discuss",NA
Aliasing: What’s in a Name?,"An 
 alias
  is an alternative name for something. In Python, two variables are
  
 said to be aliases when they contain the same memory address. For example,
  
 the following code creates two variables, both of which refer to a single list:
  
 id7
 :list
  
 celegans_markers
  
 id7
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 id6
 :str
  
 id8
 :str
  
 celegans_alias
  
 id7
  
 id1
  
 id2
  
 id3
  
 id4
  
 id5
  
 id8
  
 id2
 :str
  
 id3
 :str
  
 id4
 :str
  
 id5
 :str
  
 id1
 :str
  
  
 ""Emb""
  
  
  
 ""Him""
  
  
  
 ""Unc""
  
  
  
 ""Lon""
  
  
  
 ""Dpy""
  
  
  
 ""Sma""
  
  
  
 ""Lvl""
  
  
 When we modify the list using one of the variables, references through the
  
 other variable show the change as well:
  
 >>>
  celegans_phenotypes = [
 'Emb'
 ,
  'Him'
 ,
  'Unc'
 ,
  'Lon'
 ,
  'Dpy'
 ,
  'Sma'
 ] 
 >>>
  celegans_alias = 
 celegans_phenotypes 
  
 >>>
  celegans_phenotypes[5] =
  'Lvl' 
  
 >>>
  celegans_phenotypes 
  
 ['Emb', 'Him', 'Unc', 'Lon', 'Dpy', 'Lvl'] 
  
 >>>
  celegans_alias 
  
 ['Emb', 'Him', 'Unc', 'Lon', 'Dpy', 'Lvl']
  
 Aliasing is one of the reasons why the notion of mutability is important. For
  
 example, if 
 x
  and 
 y
  refer to the same list, then any changes you make to the
  
 report erratum  •  discuss",NA
List Methods,"Lists are objects and thus have methods. 
 Table 11, 
 List Methods
 , on page 142
  
 gives some of the most commonly used list methods.
  
 Here is a sample interaction showing how we can use list methods to construct
  
 a list of many colors:
  
 >>>
  colors = [
 'red'
 ,
  'orange'
 ,
  'green'
 ] 
  
 >>>
  colors.extend([
 'black'
 ,
  'blue'
 ]) 
  
 >>>
  colors 
  
 ['red', 'orange', 'green', 'black', 'blue'] 
  
 >>>
  colors.append(
 'purple'
 ) 
  
 >>>
  colors 
  
 ['red', 'orange', 'green', 'black', 'blue', 'purple'] 
  
 >>>
  colors.insert(2,
  'yellow'
 ) 
  
 >>>
  colors 
  
 ['red', 'orange', 'yellow', 'green', 'black', 'blue', 'purple'] 
 >>>
  colors.remove(
 'black'
 ) 
  
 >>>
  colors 
  
 ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
  
 All the methods shown here modify the list instead of creating a new list. The
  
 same is true for the methods 
 clear
 , 
 reverse
 , 
 sort
 , and 
 pop
 . Of those methods, only
  
 pop
  returns a value other than 
 None
 . (
 pop
  returns the item that was removed
  
 report erratum  •  discuss",NA
Working with a List of Lists,"We said in 
 Lists Are Heterogeneous
 , on page 132
  that lists can contain any type of data. 
 That means that they can contain other lists. A list whose items are lists is called a 
 nested list
 . For example, the following nested list describes life expectancies in different 
 countries:
  
 >>>
  life = [[
 'Canada'
 , 76.5], [
 'United States'
 , 75.5], [
 'Mexico'
 , 72.0]]
  
 report erratum  •  discuss",NA
A Summary List ,"In this chapter, you learned the following:
  
  
 • Lists are used to keep track of zero or more objects. The objects in a list 
  
  
 are called items or elements. Each item has a position in the list called 
   
 an 
 index and that position ranges from zero to one less than the length 
  
  
 of 
 the list.
  
 • Lists can contain any type of data, including other lists.
  
 • Lists are mutable, which means that their contents can be modified.• Slicing is used 
 to create new lists that have the same values or a subset of the values of the originals.
  
 • When two variables refer to the same object, they are called aliases.• Module 
 typing
  
 contains type 
 List
 , and this can be used in type contracts to annotate the type of values 
 a particular list is expected to contain.",NA
Exercises ,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Variable 
 kingdoms
  refers to the list 
 ['Bacteria', 'Protozoa', 'Chromista', 'Plantae', 'Fungi', 
  
 'Animalia']
 . Using 
 kingdoms
  and either slicing or indexing with positive indices, 
  
 write 
 expressions that produce the following: 
  
  
  
 The first item of 
 kingdoms 
 a.
  
 b. 
  
 The last item of 
 kingdoms 
  
 c. 
  
 The list 
 ['Bacteria', 'Protozoa', 'Chromista'] 
  
 d. 
  
 The list 
 ['Chromista', 'Plantae', 'Fungi'] 
  
  
 The list 
 ['Fungi', 'Animalia'] 
 e.
  
 f. 
  
 The empty list
  
 2. 
  
 Repeat the previous exercise using negative indices.
  
 3. 
  
 Variable 
 appointments
  refers to the list 
 ['9:00', '10:30', '14:00', '15:00', '15:30']
 . An 
  
 appointment is scheduled for 16:30, so 
 '16:30'
  needs to be added to the list.
  
 a. 
  
 Using list method 
 append
 , add 
 '16:30'
  to the end of the list that 
 appoint-
  
 ments
  
 refers to.
  
 report erratum  •  discuss",NA
9,NA,NA
Repeating Code Using Loops,"This chapter introduces another fundamental kind of control flow: repetition.
  
 Up to now, to execute an instruction two hundred times, you would need to
  
 write that instruction two hundred times. Now you’ll see how to write the
  
 instruction once and use loops to repeat that code the desired number of
  
 times.",NA
Processing Items in a List,"With what you’ve learned so far, to print the items from a list of velocities of
  
 falling objects in metric and Imperial units, you would need to write a call on
  
 function 
 print
  for each velocity in the list:
  
 >>>
  velocities = [0.0, 9.81, 19.62, 29.43] 
  
 >>>
  print(
 'Metric:'
 , velocities[0],
  'm/sec;'
 , 
  
 ...
  'Imperial:'
 , velocities[0] * 3.28,
  'ft/sec'
 ) 
  
 Metric: 0.0 m/sec; Imperial: 0.0 ft/sec 
  
 >>>
  print(
 'Metric:'
 , velocities[1],
  'm/sec;'
 , 
  
 ...
  'Imperial:'
 , velocities[1] * 3.28,
  'ft/sec'
 ) 
  
 Metric: 9.81 m/sec; Imperial: 32.1768 ft/sec 
  
 >>>
  print(
 'Metric:'
 , velocities[2],
  'm/sec; '
 , 
  
 ...
  'Imperial:'
 , velocities[2] * 3.28,
  'ft/sec'
 ) 
  
 Metric: 19.62 m/sec; Imperial: 64.3536 ft/sec 
  
 >>>
  print(
 'Metric:'
 , velocities[3],
  'm/sec; '
 , 
  
 ...
  'Imperial:'
 , velocities[3] * 3.28,
  'ft/sec'
 ) 
  
 Metric: 29.43 m/sec; Imperial: 96.5304 ft/sec
  
 This code is used to process a list with just four values. Imagine processing
  
 a list with a thousand values. Lists were invented so that you wouldn’t have
  
 to create a thousand variables to store a thousand values. For the same rea-
  
 son, Python has a 
 for loop
  that lets you process each element in a list in turn
  
 without having to write one statement per element. You can use a 
 for
  loop to
  
 print the velocities:
  
 report erratum  •  discuss",NA
Processing Characters in Strings,"It is also possible to loop over the characters of a string. The general form of
  
 a 
 for
  loop over a string is as follows:
  
 for
  «
 variable
 »
  in
  «
 str
 »
 :
  
  
 «
 block
 »
  
 As with a 
 for
  loop over a list, the loop variable gets assigned a new value at
  
 the beginning of each iteration. In the case of a loop over a string, the variable
  
 is assigned a single character.
  
 For example, we can loop over each character in a string, printing the
  
 uppercase letters:
  
 >>>
  country =
  'United States of America' 
  
 >>>
  for ch in country: 
  
 ... 
  
 if ch.isupper(): 
  
 ... 
  
 print(ch) 
  
 ...
  
 U
  
  
 S 
  
 A",NA
Looping Over a Range of Numbers,"We can also loop over a range of values. This allows us to perform tasks a certain
  
 number of times and to do more sophisticated processing of lists and strings. To
  
 begin, we need to generate the range of numbers over which to iterate.
  
 Generating Ranges of Numbers
  
 Python’s built-in function 
 range
  produces an object that will generate a
  
 sequence of integers. When passed a single argument, as in 
 range(stop)
 , the
  
 sequence starts at 
 0
  and continues to the integer before 
 stop
 :
  
 >>>
  range(10) 
  
 range(0, 10)
  
 This is the first time that you’ve seen Python’s 
 range
  type. You can use a loop
  
 to access each number in the sequence one at a time:
  
 >>>
  for num in range(10): 
  
 ... 
  
 print(num) 
  
 ...
  
 0 
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9
  
 To get the numbers from the sequence all at once, we can use built-in function
  
 list
  to create a list of those numbers:
  
 >>>
  list(range(10)) 
  
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  
 Here are some more examples:
  
 >>>
  list(range(3)) 
  
 [0, 1, 2] 
  
 >>>
  list(range(1)) 
  
 [0] 
  
 >>>
  list(range(0)) 
  
 []
  
 report erratum  •  discuss",NA
Processing Lists Using Indices,"The loops over lists that we have written so far have been used to access list
  
 items. But what if we want to change the items in a list? For example, suppose
  
 we want to double all of the values in a list. The following doesn’t work:
  
 >>>
  values = [4, 10, 3, 8, -6] 
  
 >>>
  for num in values: 
  
 ... 
  
 num = num * 2 
  
 ...
  
 >>>
  values 
  
 [4, 10, 3, 8, -6]
  
 Each loop iteration assigned an item in the list 
 values
  to variable 
 num
 . Doubling
  
 that value inside the loop changes what 
 num
  refers to, but it 
 doesn’t
  mutate
  
 the list object. For example, after one iteration of the loop, the list is
  
 unchanged and 
 num
  refers to 
 8
  (twice its original value):
  
  
 Let’s add a call on function 
 print
  to show how the value that 
 num
  refers to
  
 changes during each iteration:
  
 >>>
  values = [4, 10, 3, 8, -6] 
  
 >>>
  for num in values: 
  
 ... 
  
 num = num * 2 
  
 ... 
  
 print(num) 
  
 ...
  
 8 
  
 20 
  
 6 
  
 16
  
 -12 
  
 >>>
  print(values) 
  
 [4, 10, 3, 8, -6]",NA
Nesting Loops in Loops,"The block of statements inside a loop can contain another loop. In this code,
  
 the inner loop is executed once for each item of list 
 outer
 :
  
 >>>
  outer = [
 'Li'
 ,
  'Na'
 ,
  'K'
 ] 
  
 >>>
  inner = [
 'F'
 ,
  'Cl'
 ,
  'Br'
 ] 
  
 >>>
  for metal in outer: 
  
 ... 
  
 for halogen in inner: 
  
 ... 
  
 print(metal + halogen) 
  
 ...
  
 ...",NA
Looping Until a Condition Is Reached,"for
  loops are useful only if you know how many iterations of the loop you need.
  
 In some situations, it is not known in advance how many loop iterations to
  
 execute. In a game program, for example, you can’t know whether a player
  
 is going to want to play again or quit. In these situations, we use a 
 while
  loop.
  
 The general form of a 
 while
  loop is as follows:
  
 while
  «
 expression
 »
 :
  
  
 «
 block
 »
  
 The 
 while
  loop expression is sometimes called the 
 loop condition
  and it is similar
  
 to condition of an 
 if
  statement. When Python executes a 
 while
  loop, it evaluates
  
 the expression. If that expression evaluates to 
 False
 , that is the end of the exe-
  
 cution of the loop. If the expression evaluates to 
 True
 , on the other hand, Python
  
 executes the loop body once and then goes back to the top of the loop and
  
 reevaluates the expression. If it still evaluates to 
 True
 , the loop body is executed
  
 again. This is repeated—expression, body, expression, body—until the expres-
  
 sion evaluates to 
 False
 , at which point Python stops executing the loop.
  
 Here’s an example:
  
 >>>
  rabbits = 3 
  
 >>>
  while rabbits > 0: 
  
 ... 
  
 print(rabbits) 
  
 ... 
  
 rabbits = rabbits - 1 
  
 ...
  
 3 
  
 2 
  
 1
  
 report erratum  •  discuss",NA
rabbits > 0,NA,NA
True,NA,NA
block,NA,NA
False,"As a more useful example, we can calculate the growth of a bacterial colony
  
 using a simple exponential growth model, which is essentially a calculation
  
 of compound interest:
  
 P(t + 1) = P(t) + rP(t)
  
 In this formula, 
 P(t)
  is the population size at time 
 t
  and 
 r
  is the growth rate.
  
 Using this program, let’s see how long it takes the bacteria to double their
  
 numbers:
  
 time = 0 
  
 population = 1000 
  
 # 1000 bacteria to start with 
 growth_rate = 0.21
  
 # 21% growth per minute 
  
 while
  population < 2000: 
  
  
 population = population + growth_rate * population 
  
 print
 (round(population)) 
  
  
 time = time + 1
  
 print
 (
 ""It took""
 , time,
  ""minutes for the bacteria to double.""
 ) 
 print
 (
 ""The final population was""
 , 
 round(population),
  ""bacteria.""
 )
  
 Because variable 
 time
  was updated in the loop body, its value after the loop
  
 was the time of the last iteration, which is exactly what we want. Running
  
 this program gives us the answer we were looking for:
  
 1210 
  
 1464 
  
 1772 
  
 2144 
  
 It took 4 minutes for the bacteria to double. 
  
 The final population was 2144 bacteria.
  
 report erratum  •  discuss",NA
Repetition Based on User Input,"We can use function 
 input
  in a loop to make the chemical formula translation example 
 from 
 Choosing Which Statements to Execute
 , on page 86
 , interactive. We will ask the 
 user to enter a chemical formula, and our program, which is
  
 report erratum  •  discuss",NA
Controlling Loops Using break and continue,"As a rule, 
 for
  and 
 while
  loops execute all the statements in their body on each
  
 iteration. However, sometimes it is handy to be able to break that rule. Python
  
 provides two ways of controlling the iteration of a loop: 
 break
 , which terminates
  
 execution of the loop immediately, and 
 continue
 , which skips ahead to the next
  
 iteration.
  
 The break Statement
  
 In 
 Repetition Based on User Input
 , on page 162
 , we showed a program that
  
 continually read input from a user until the user typed 
 quit
 . Here is a program
  
 that accomplishes the same task, but this one uses 
 break
  to terminate execution
  
 of the loop when the user types 
 quit
 :
  
 report erratum  •  discuss",NA
Repeating What You’ve Learned,"In this chapter, you learned the following:
  
 •
  Repeating a block is a fundamental way to control a program’s behavior. A 
 for
  loop can 
 be used to iterate over the items of a list, over the characters of a string, and over a 
 sequence of integers generated by built-in function 
 range
 .
  
 • The most general kind of repetition is the 
 while
  loop, which continues executing as 
 long as some specified Boolean condition is true. However,
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Write a 
 for
  loop to print all the values in the 
 celegans_phenotypes
  list from 
  
 Slicing Lists
 , on page 137
 , one per line. 
 celegans_phenotypes
  refers to 
 ['Emb', 
  
 'Him', 
 'Unc', 'Lon', 'Dpy', 'Sma']
 .
  
 2.
  
 Write a 
 for
  loop to print all the values in the 
 half_lives
  list from 
 Operations
  
 on Lists
 , on page 135
 , all on a single line. 
 half_lives
  refers to 
 [87.74, 24110.0, 6537.0, 14.4, 
 376000.0]
 .
  
 3.
  
 Write a 
 for
  loop to add 
 1
  to all the values from 
 whales
  from 
 Storing and
  
 Accessing Data in Lists
 , on page 129
 , and store the converted values in a new list 
 called 
 more_whales
 . The 
 whales
  list shouldn’t be modified. 
 whales
  refers to 
 [5, 4, 7, 3, 2, 3, 
 2, 6, 4, 2, 1, 7, 1, 3]
 .
  
 4. 
  
 In this exercise, you’ll create a nested list and then write code that per-
  
 forms operations on that list.
  
 a. 
  
 Create a nested list where each element of the outer list contains the 
  
 atomic number and atomic weight for an alkaline earth metal. The 
  
 values are beryllium (4 and 9.012), magnesium (12 and 24.305), cal-
  
 cium 
 (20 and 40.078), strontium (38 and 87.62), barium (56 and 
  
 137.327), and radium 
 (88 and 226). Assign the list to variable 
  
 alkaline_earth_metals
 .
  
 b. 
  
 Write a 
 for
  loop to print all the values in 
 alkaline_earth_metals
 , with the 
  
 atomic number and atomic weight for each alkaline earth metal on a 
  
 different line.
  
 c. 
  
 Write a 
 for
  loop to create a new list called 
 number_and_weight
  that contains 
  
 the 
 elements of 
 alkaline_earth_metals
  in the same order but not nested.
  
 5. 
  
 The following function doesn’t have a docstring, type annotations, or com-
  
 ments. Write enough of all three to make it easy for another programmer to
  
 report erratum  •  discuss",NA
10,NA,NA
Reading and Writing Files,"Data is often stored in plain-text files, which can be organized in several dif-ferent 
 ways. For example, the rainfall amounts in Oregon for each separate day in a study 
 period might be stored one value per line in a file, using a newline as a 
 delimiter
  to 
 separate the values and make the data easier for humans to read. Alternatively, each 
 line might store the values for an entire week or month, separating values within a line 
 using a delimiter such as a space, tab, or comma.
  
 Often, data organization is more complex. For example, a study might keep track of the 
 heights, weights, and ages of the participants. Each 
 record
  can appear on a line by itself, 
 with the pieces of data in each record separated by delimiters. Some records might 
 even span multiple lines, in which case each record will usually have some kind of a 
 separator (such as a blank line) or use special symbols to mark the start or end of each 
 record.
  
 In this chapter, you’ll learn about different file formats, common ways to organize data, 
 and how to read and write that data using Python. You’ll first learn how to open and 
 read information from files. After that, you’ll learn about the different techniques for 
 writing to files, and then you’ll see several case studies that use the various techniques.",NA
What Kinds of Files Are There?,"There are many kinds of files. Text files, music files, videos, and various word 
 processor and presentation documents are common. Text files contain only characters; 
 all the other file formats include formatting information that is specific to that 
 particular file format, and in order to use a file in a particular format you need a special 
 program that understands that format.
  
 report erratum  •  discuss",NA
Opening a File,"When you want to write a program that opens and reads a file, that program needs to 
 tell Python where that file is. By default, Python assumes that the file you want to read 
 is in the same directory as the program that is doing the reading. If you’re working in 
 IDLE as you read this book, there’s a little setup you should do:
  
 1. 
  
 Make a directory, perhaps called 
 file_examples
 .
  
 2. 
  
 In IDLE, select File→New Window and type (or copy and paste) the 
  
 following:
  
 First line of text 
  
 Second line of text 
  
 Third line of text
  
 3. 
  
 Save this file in your 
 file_examples
  directory under the name 
 file_example.txt
 .
  
 4. 
  
 In IDLE, select File→New Window and type (or copy and paste) this 
  
 program:
  
 file = open(
 'file_example.txt'
 ,
  'r'
 ) 
  
 contents = file.read() 
  
 file.close() 
  
 print
 (contents)
  
 5. 
  
 Save this as 
 file_reader.py
  in your 
 file_examples
  directory.
  
 When you run this program, this is what gets printed:
  
 First line of text 
  
 Second line of text 
  
 Third line of text
  
 It’s important that you save the two files in the same directory, as you’ll see in the next 
 section. Also, this won’t work if you try those same commands from the Python shell.
  
 Built-in function 
 open
  opens a file (much like you open a book when you want to read 
 it) and returns an object that knows how to get information from the file. This object 
 also keeps track of how much you’ve read and which part of the file you’re about to 
 read next. The marker that keeps track of the current location in the file is called a 
 file 
 cursor
  and acts much like a bookmark. The file cursor is initially at the beginning of the 
 file, but as we read or write data it moves to the end of what we just read or wrote.
  
 The first argument in the example call on function 
 open
 , 
 'file_example.txt'
 , is the name of the 
 file to open, and the second argument, 
 'r'
 , tells Python that you
  
 report erratum  •  discuss",NA
Techniques for Reading Files,"As we mentioned at the beginning of the chapter, Python provides several techniques 
 for reading files. You’ll learn about them in this section.
  
 All of these techniques work starting at the current file cursor. That allows us to 
 combine the techniques as we need to.
  
 The Read Technique
  
 Use this technique when you want to read the contents of a file into a single string, or 
 when you want to specify exactly how many characters to read. This technique was 
 introduced in 
 Opening a File
 , on page 175
 ; here is the same example:
  
 with
  open(
 'file_example.txt'
 ,
  'r'
 )
  as
  file: 
  
  
 contents = file.read()
  
 print
 (contents)
  
 When called with no arguments, method 
 read
  reads everything from the current file 
 cursor all the way to the end of the file and moves the file cursor to the end of the file. 
 When called with one integer argument, it reads that many characters and moves the 
 file cursor after the characters that were just read. Here is a version of the same 
 program in a file called 
 file_reader_with_10.py
 ; it reads ten characters and then the rest of 
 the file:
  
 with
  open(
 'file_example.txt'
 ,
  'r'
 )
  as
  example_file: first_ten_chars = 
 example_file.read(10) 
  
 the_rest = example_file.read()
  
 print
 (
 ""The first 10 characters:""
 , first_ten_chars) 
 print
 (
 ""The rest of the 
 file:""
 , the_rest)
  
 Method call 
 example_file.read(10)
  moves the file cursor, so the next call, 
 exam-ple_file.read()
 , 
 reads everything from character 11 to the end of the file.
  
 Reading at the End of a File
  
 When the file cursor is at the end of the file, methods 
 read
 , 
 readlines
 , and 
 readline
  all return an 
 empty string. In order to read the contents of a file a second time, you’ll need to close and 
 reopen the file.
  
 The Readlines Technique
  
 Use this technique when you want to get a Python list of strings containing the 
 individual lines from a file. Function 
 readlines
  works much like function
  
 report erratum  •  discuss",NA
Files over the Internet,"These days, of course, the file containing the data we want could be on a
  
 machine half a world away. Provided the file is accessible over the Internet,
  
 though, we can read it just as we do a local file. For example, the Hopedale
  
 data not only exists on our computers, but it’s also on a web page. At the
  
 time of writing, the URL for the file is 
 http://robjhyndman.com/tsdldata/ecology1/hope-
  
 dale.dat
  (you can look at it online!).
  
 (Note that the examples in this section will work only if your computer is
  
 actually connected to the Internet.)
  
 report erratum  •  discuss",NA
Writing Files,"This program opens a file called 
 topics.txt
 , writes the words 
 Computer Science
  to
  
 the file, and then closes the file:
  
 with
  open(
 'topics.txt'
 ,
  'w'
 )
  as
  output_file: 
  
  
 output_file.write(
 'Computer Science'
 )
  
 In addition to writing characters to a file, method 
 write
  returns the number of
  
 characters written. For example, 
 output_file.write('Computer Science')
  returns 
 16
 .
  
 To create a new file or to replace the contents of an existing file, we use write
  
 mode (
 'w'
 ). If the filename doesn’t exist already, then a new file is created;
  
 otherwise the file contents are erased and replaced. Once opened for writing,
  
 you can use method 
 write
  to write a string to the file.
  
 Rather than replacing the file contents, we can also add to a file using append
  
 mode (
 'a'
 ). When we write to a file that is opened in append mode, the data
  
 we write is added to the end of the file and the current file contents are not
  
 overwritten. For example, to add to our previous file 
 topics.txt
 , we can append
  
 the words 
 Software Engineering
 :
  
 with
  open(
 'topics.txt'
 ,
  'a'
 )
  as
  output_file: 
  
  
 output_file.write(
 'Software Engineering'
 )
  
 At this point, if we print the contents of 
 topics.txt
 , we’d see the following:
  
 Computer ScienceSoftware Engineering
  
 Unlike function 
 print
 , method 
 write
  doesn’t automatically append a newline; if you want a 
 string to end in a newline, you have to include it manually using 
 '\n'
 .
  
 The next example, in a file called 
 total.py
 , is more complex, and it involves both
  
 reading from and writing to a file. Notice that it uses 
 typing.TextIO
  as the type
  
 annotation for an open file. “IO” is short for “Input/Output.” Our input file
  
 contains two numbers per line separated by a space. The output file will
  
 contain three numbers per line: the two from the input file followed by their
  
 sum (all separated by spaces).
  
 from
  typing
  import
  TextIO 
  
 from
  io
  import
  StringIO
  
 def
  sum_number_pairs(input_file: TextIO, output_file: TextIO) -> None: 
 """"""Read the data from input_file, which 
 contains two floats per line separated by a space. output_file for writing and, for each line in input_file, 
 write a line to output_file that contains the two floats from the corresponding line of input_file plus a space 
 and the sum of the two floats.
  
 """"""
  
 report erratum  •  discuss",NA
Writing Example Calls Using StringIO,"In order to follow the function design recipe, we need to write example calls.
  
 Writing these calls using real files would involve creating test files for each
  
 of the situations you want to demonstrate. This is fragile, because it means
  
 that you can’t just give the program to someone—you need to remember to
  
 include the test files in case they want to try your function, and it’s also not
  
 optimal because anyone trying to understand the function needs to open the
  
 input and output files.
  
 Python provides a class, 
 StringIO
 , in module 
 io
 , that can be used as a 
 mock
  
 open file. That means that you can read from it using the regular file-reading
  
 techniques as if it were a real file. 
 StringIO
  objects can be used anywhere 
 TextIO
  
 are expected.
  
 Here, we create a 
 StringIO
  object containing the same information as file 
 num-
  
 ber_pairs.txt
 , and read the first line:
  
 >>>
  from io import StringIO 
  
 >>>
  input_string =
  '1.3 3.4\n2 4.2\n-1 1\n' 
  
 >>>
  infile = StringIO(input_string) 
  
 >>>
  infile.readline() 
  
 '1.3 3.4\n'
  
 report erratum  •  discuss",NA
Writing Algorithms That Use the File-Reading Techniques,"There are several common ways to organize information in files. The rest of
  
 this chapter will show how to apply the various file-reading techniques to
  
 these situations and how to develop some algorithms to help with this.
  
 Skipping the Header
  
 Many data files begin with a header. As described in 
 The Readline Technique
 ,
  
 on page 181
 , TSDL files begin with a one-line description followed by comments
  
 in lines beginning with a 
 #
 , and the Readline technique can be used to skip
  
 that header. The technique ends when we read the first real piece of data,
  
 which will be the first line after the description that doesn’t start with a 
 #
 .
  
 In English, we might try this algorithm to process this kind of a file:
  
 Skip the first line in the file 
  
 Skip over the comment lines in the file 
  
 For each of the remaining lines in the file: 
  
  
 Process the data on that line
  
 The problem with this approach is that we can’t tell whether a line is a com-
  
 ment line until we’ve read it, but we can read a line from a file only
  
 once—there’s no simple way to “back up” in the file. An alternative approach
  
 is to read the line, skip it if it’s a comment, and process it if it’s not. Once
  
 we’ve processed the first line of data, we process the remaining lines:
  
 Skip the first line in the file 
  
 Find and process the first line of data in the file For each of the remaining 
 lines: 
  
  
 Process the data on that line
  
 The thing to notice about this algorithm is that it processes lines in two places:
  
 once when it finds the first “interesting” line in the file and once when it
  
 handles all of the following lines:
  
 from
  typing
  import
  TextIO 
  
 from
  io
  import
  StringIO
  
 def
  skip_header(reader: TextIO) -> str: 
  
  
 """"""Skip the header in reader and return the first real piece of data.
  
 >>> infile = StringIO('Example\\n# Comment\\n# Comment\\nData line\\n') >>> skip_header(infile) 
  
 'Data line\\n' 
  
 """"""
  
 # Read the description line 
  
 line = reader.readline()
  
 report erratum  •  discuss",NA
Multiline Records,"Not every data record will fit onto a single line. Here is a file in simplified
  
 Protein Data Bank (PDB) format that describes the arrangements of atoms
  
 in ammonia:
  
 COMPND
  
 1
  
 AMMONIA
  
 -0.363
  
 0.000
  
 ATOM
  
 N
  
 0.257
  
 ATOM
  
 2
  
 H
  
 0.257
  
 0.727
  
 0.000
  
 ATOM
  
 3
  
 H
  
 0.771
  
 -0.727
  
 0.890
  
 ATOM
  
 4
  
 H
  
 0.771
  
 -0.727
  
 -0.890
  
 END
  
 report erratum  •  discuss",NA
Looking Ahead,"Let’s add one final complication. Suppose that molecules didn’t have 
 END 
 markers but 
 instead just a 
 COMPND
  line followed by one or more 
 ATOM
  lines.
  
 How would we read multiple molecules from a single file in that case?
  
 COMPND
  
 1
  
 AMMONIA
  
 -0.363
  
 0.000
  
 ATOM
  
 N
  
 0.257
  
 ATOM
  
 2
  
 H
  
 0.257
  
 0.727
  
 0.000
  
 ATOM
  
 3
  
 H
  
 0.771
  
 -0.727
  
 0.890
  
 ATOM
  
 4
  
 H
  
 0.771
  
 -0.727
  
 -0.890
  
 COMPND
  
 1
  
 METHANOL
  
 -0.015
  
 0.024
  
 ATOM
  
 C
  
 -0.748
  
 ATOM
  
 2
  
 O
  
 0.558
  
 0.420
  
 -0.278
  
 ATOM
  
 3
  
 H
  
 -1.293
  
 -0.202
  
 -0.901
  
 ATOM
  
 4
  
 H
  
 -1.263
  
 0.754
  
 0.600
  
 ATOM
  
 5
  
 H
  
 -0.699
  
 -0.934
  
 0.609
  
 ATOM
  
 6
  
 H
  
 0.716
  
 1.404
  
 0.137
  
 At first glance, it doesn’t seem much different from the problem we just solved: 
 read_molecule
  could extract the molecule’s name from the 
 COMPND
  line and then read 
 ATOM
  lines until it got either an empty string signaling the end of the file or another 
 COMPND
  line signaling the start of the next molecule. But once it has read that 
 COMPND
  
 line, the line isn’t available for the next call to 
 read_molecule
 , so how can we get the name 
 of the second molecule (and all the ones following it)?
  
 To solve this problem, our functions must always “look ahead” one line. Let’s start with 
 the function that reads multiple molecules:
  
 report erratum  •  discuss",NA
Notes to File Away,"In this chapter, you learned the following:
  
 • When files are opened and read, their contents are commonly stored in lists of 
 strings.
  
 • Data stored in files is usually formatted in one of a small number of ways, from one 
 value per line to multiline records with explicit end-of-record markers. Each 
 format can be processed in a stereotypical way.
  
 • Data processing programs should be broken into input, processing, and output 
 stages so that each can be reused independently.
  
 • Files can be read (content retrieved), written to (content replaced), and added to 
 (new content appended). When a file is opened in writing mode and it doesn’t 
 exist, a new file is created.
  
 • Data files come in many different formats, so custom code is often re-quired, but we 
 can reuse as much as possible by writing helper functions.
  
 • To make the functions usable by different types of readers, the reader (for a file or 
 web page) is opened outside the function, passed as an argument to the function, 
 and then closed outside the function.
  
 •
  typing.TextIO
  is used in type annotations to indicate an open file.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Write a program that makes a backup of a file. Your program should 
  
 prompt the 
 user for the name of the file to copy and then write a new file 
  
 with the same 
 contents but with 
 .bak
  as the file extension.
  
 2. 
  
 Suppose the file 
 alkaline_metals.txt
  contains the name, atomic number, and 
  
 atomic weight of the alkaline earth metals:
  
 beryllium 4 9.012 
  
 magnesium 12 24.305 
  
 calcium 20 20.078 
  
 strontium 38 87.62 
  
 barium 56 137.327 
  
 radium 88 226
  
 Write a 
 for
  loop to read the contents of 
 alkaline_metals.txt
  and store it in a list of lists, 
 with each inner list containing the name, atomic number, and atomic weight for an 
 element. (Hint: Use 
 string.split
 .)
  
 3. 
  
 All of the file-reading functions we have seen in this chapter read forward 
  
 through the file from the first character or line to the last. How could you 
  
 write 
 a function that would read backward through a file?
  
 4.
  
 In 
 Processing Whitespace-Delimited Data
 , on page 192
 , we used the “For
  
 Line in File” technique to process data line by line, breaking it into pieces using 
 string method 
 split
 . Rewrite function 
 process_file
  to skip the header as normal but 
 then use the Read technique to read all the data at once.
  
 5.
  
 Modify the file reader in 
 read_smallest_skip.py
  of 
 Skipping the Header
 , on page
  
 188
  so that it can handle files with no data after the header.
  
  
 6.
  
 Modify the file reader in 
 read_smallest_skip.py
  of 
 Skipping the Header
 , on page
  
 188
 , so that it uses a 
 continue
  inside the loop instead of an 
 if
 . Which form do you find 
 easier to read?
  
 7.
  
 Modify the PDB file reader of 
 Multiline Records
 , on page 195
 , so that it ignores
  
 blank lines and comment lines in PDB files. A blank line is one that contains only space 
 and tab characters (that is, one that looks empty when viewed). A comment is any line 
 beginning with the keyword 
 CMNT
 .
  
 8. 
  
 Modify the PDB file reader to check that the serial numbers on atoms 
  
 start at 1 and 
 increase by 1. What should the modified function do if it 
  
 finds a file that doesn’t obey 
 this rule?
  
 report erratum  •  discuss",NA
11,NA,NA
Storing Data Using Other Collection ,NA,NA
Types,"In 
 Chapter 8, 
 Storing Collections of Data Using Lists
 , on page 129
 , you learned how to 
 store collections of data using lists. In this chapter, you will learn about three other 
 kinds of collections: sets, tuples, and dictionaries. With four different options for 
 storing your collections of data, you will be able to pick the one that best matches your 
 problem in order to keep your code as clean and efficient as possible.",NA
Storing Data Using Sets,"A 
 set
  is an unordered collection of distinct items. 
 Unordered
  means that items aren’t stored 
 in any particular order. Something is either in the set or it’s not, but there’s no notion of it 
 being the first, second, or last item. 
 Distinct
  means that any item appears in a set at most 
 once; in other words, there are no duplicates.
  
 Python has a type called 
 set
  that allows us to store mutable collections of unordered, 
 distinct items. (Remember that a 
 mutable
  object is one that you can modify.) Here we 
 create a set containing the vowels:
  
 >>>
  vowels = {
 'a'
 ,
  'e'
 ,
  'i'
 ,
  'o'
 ,
  'u'
 } 
  
 >>>
  vowels 
  
 {'a', 'u', 'o', 'i', 'e'}
  
 It looks much like a list, except that sets use braces (that is, 
 {
  and 
 }
 ) instead of brackets 
 (that is, 
 [
  and 
 ]
 ). Notice that, when displayed in the shell, the set is unordered. Python 
 does some mathematical tricks behind the scenes to make accessing the items very 
 fast, and one of the side effects of this is that the items aren’t in any particular order.
  
 Here we show that each item is distinct; duplicates are ignored:
  
 >>>
  vowels = {
 'a'
 ,
  'e'
 ,
  'a'
 ,
  'a'
 ,
  'i'
 ,
  'o'
 ,
  'u'
 ,
  'u'
 } 
 >>>
  vowels 
  
 {'u', 'o', 'i', 'e', 'a'}
  
 report erratum  •  discuss",NA
Storing Data Using Tuples,"Lists aren’t the only kind of ordered sequence in Python. You’ve already
  
 learned about one of the others: strings (see 
 Chapter 4, 
 Working with Text
 ,
  
 on page 65
 ). Formally, a string is an immutable sequence of characters. The
  
 characters in a string are ordered and a string can be indexed and sliced like
  
 a list to create new strings:
  
 >>>
  rock =
  'anthracite' 
  
 >>>
  rock[9] 
  
 'e' 
  
 >>>
  rock[0:3] 
  
 'ant' 
  
 >>>
  rock[-5:] 
  
 'acite' 
  
 >>>
  for character in rock[:5]: 
  
 ... 
  
 print(character) 
  
 ...
  
 a 
  
 n 
  
 t 
  
 h 
  
 r
  
 report erratum  •  discuss",NA
Storing Data Using Dictionaries,"Here is the same bird-watching observation file that we saw in 
 Set Example:
  
 Arctic Birds
 , on page 207
 :
  
 canada goose 
  
 canada goose 
  
 long-tailed jaeger 
  
 canada goose 
  
 snow goose 
  
 canada goose 
  
 long-tailed jaeger 
  
 canada goose 
  
 northern fulmar
  
 Suppose we want to know how often each species was seen. Our first attempt uses
  
 a list of lists, in which each inner list has two items. The item at index 
 0
  of the inner
  
 list contains the species, and the item at index 
 1
  contains the number of times it
  
 has been seen so far. To build this list, we iterate over the lines of the observations
  
 file. For each line, we search the outer list, looking for the species on that line. If we
  
 find that the species occurs in the list, we add one to the number of times it has
  
 been observed; if we do not find it, we add a new entry for the species:
  
 from
  typing
  import
  TextIO, List, Any 
  
 from
  io
  import
  StringIO
  
 def
  count_birds(observations_file: TextIO) -> List[List[Any]]: 
  
 """"""Return a set of the bird species listed in observations_file, which has one bird species per line.
  
 >>> infile = StringIO('bird 1\\nbird 2\\nbird 1\\n') >>> count_birds(infile) 
  
 [['bird 1', 2], ['bird 2', 1]] 
  
 """""" 
  
 bird_counts = [] 
  
 for
  line
  in
  observations_file: 
  
  
 bird = line.strip() 
  
  
 found = False 
  
  
 # Find bird in the list of bird counts.
  
 for
  entry
  in
  bird_counts: 
  
 if
  entry[0] == bird: 
  
  
  
 entry[1] = entry[1] + 1 
  
  
  
 found = True 
  
 if not
  found: 
  
 bird_counts.append([bird, 1])
  
 return
  bird_counts
  
 report erratum  •  discuss",NA
Inverting a Dictionary,"You might want to print the birds in another order—in order of the number
  
 of observations, for example. To do this, you need to 
 invert
  the dictionary;
  
 that is, create a new dictionary in which you use the values as keys and the
  
 keys as values. This is a little trickier than it first appears. There’s no guar-
  
 antee that the values are unique, so you have to handle what are called
  
 collisions
 . For example, if you invert the dictionary 
 {'a': 1, 'b': 1, 'c': 1}
 , a key
  
 would be 
 1
 , but it’s not clear what the value associated with it would be.
  
 Since you’d like to keep all of the data from the original dictionary, you may
  
 need to use a collection, such as a list, to keep track of the values associated
  
 with a key. If we go this route, the inverse of the dictionary shown earlier
  
 would be 
 {1: ['a', 'b', 'c']}
 . Here’s a program to invert the dictionary of birds to
  
 observations:
  
 >>>
  bird_to_observations 
  
 {'canada goose': 5, 'northern fulmar': 1, 'long-tailed jaeger': 2, 'snow goose': 1} 
  
 >>> 
  
 >>>
  # Invert the dictionary 
  
 >>>
  observations_to_birds_list = {} 
  
 >>>
  for bird, observations in bird_to_observations.items(): 
  
  
 if observations in observations_to_birds_list: 
 ...
  
 ... 
  
 observations_to_birds_list[observations].append(bird) 
 ... 
  
 else: 
  
 ... 
  
 observations_to_birds_list[observations] = [bird] 
 ...
  
 >>>
  observations_to_birds_list 
  
 {1: ['northern fulmar', 'snow goose'], 2: ['long-tailed jaeger'], 5: ['canada goose']}
  
 This program loops over each key/value pair in the original dictionary,
  
 bird_to_observations
 . If that value is not yet a key in the inverted dictionary,
  
 observations_to_birds_list
 , it is added as a key and its value is a single-item list
  
 containing the key associated with it in the original dictionary. On the other
  
 hand, if that value is already a key, then the key associated with it in the
  
 original dictionary is appended to its list of values.
  
 report erratum  •  discuss",NA
"Using the in Operator on Tuples, Sets, and Dictionaries","As with lists, the 
 in
  operator can be applied to tuples and sets to check whether
  
 an item is a member of the collection:
  
 >>>
  odds = set([1, 3, 5, 7, 9]) 
  
 >>>
  9 in odds 
  
 True 
  
 >>>
  8 in odds 
  
 False 
  
 >>>
  '9'
  in odds 
  
 False 
  
 >>>
  evens = (0, 2, 4, 6, 8) 
  
 >>>
  4 in evens 
  
 True 
  
 >>>
  11 in evens 
  
 False
  
 When used on a dictionary, 
 in
  checks whether a value is a key in the dictionary:
  
 >>>
  bird_to_observations = {
 'canada goose'
 : 183,
  'long-tailed jaeger'
 : 71, 
 ... 
  
 'snow goose'
 : 63,
  
 'northern fulmar'
 : 1} 
  
 >>>
  'snow goose'
  in bird_to_observations 
  
 True 
  
 >>>
  183 in bird_to_observations 
  
 False
  
 Notice that the values in the dictionary are ignored; the 
 in
  operator only looks
  
 at the keys.",NA
Comparing Collections,"You’ve now seen strings, lists, sets, tuples, and dictionaries. They all have
  
 their uses. Here is a table comparing them:
  
 Collection
  
 Mutable?
  
 Ordered?
  
 Use When…
  
 str
  
 No
  
 Yes
  
 You want to keep track of text.
  
 list
  
 Yes
  
 Yes
  
 You want to keep track of an ordered
  
 sequence that you want to update.
  
 tuple
  
 No
  
 Yes
  
 You want to build an ordered sequence that
  
 you know won’t change or that you want to
  
 use as a key in a dictionary or as a value
  
 in a set.
  
 set
  
 Yes
  
 No
  
 You want to keep track of values, but order
  
 doesn’t matter, and you don’t want to keep
  
 duplicates. The values must be immutable.
  
 dictionary
  
 Yes
  
 No
  
 You want to keep a mapping of keys to val-
  
 ues. The keys must be immutable.
  
 Table 17—Features of Python Collections",NA
Creating New Type Annotations,"In addition to type annotations for built-in types such as 
 int
  and 
 str
 , module
  
 typing
  provides types 
 List
 , 
 Set
 , 
 Tuple
 , and 
 Dict
 . For each, you can specify the kind
  
 of thing it contains, including type 
 Any
  for function parameters that work with
  
 a mixed set of types.
  
 To explore this, we’ll revisit atoms and molecules from 
 Multiline Records
 , on
  
 page 195
 , using dictionaries and tuples in addition to lists.
  
 Recall functions 
 read_molecule
  and 
 read_all_molecules
 ; here are the headers and
  
 docstrings:
  
 def
  read_molecule(reader: TextIO) -> list: 
  
  
 """"""Read a single molecule from reader and return it, or return None to 
  
 signal end of file. 
  
 The 
 first item in the result is the name of the 
  
 compound; each list contains an atom type and the X, Y, and Z 
 coordinates 
  
 of that atom.
  
 >>> instring = 'COMPND TEST\\nATOM 1 N 0.1 0.2 0.3\\nATOM 2 N 0.2 0.1 0.0\\nEND\\n' >>> infile = 
 StringIO(instring) 
  
 >>> read_molecule(infile) 
  
 ['TEST', ['N', '0.1', '0.2', '0.3'], ['N', '0.2', '0.1', '0.0']] 
  
 """"""
  
 report erratum  •  discuss",NA
A Collection of New Information,"In this chapter, you learned the following:
  
 • Sets are used in Python to store unordered collections of unique values. They 
 support the same operations as sets in mathematics.
  
 • Tuples are another kind of Python sequence. Tuples are ordered sequences like lists, 
 except they are immutable.
  
 • Dictionaries are used to store unordered collections of key/value pairs. The keys 
 must be immutable, but the values need not be.
  
 • Looking things up in sets and dictionaries is much faster than searching through 
 lists. If you have a program that is doing the latter, consider changing your choice 
 of data structures.",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Write a function called 
 find_dups
  that takes a list of integers as its input argu-
  
 ment 
 and returns a set of those integers occurring two or more times in the list.
  
 2. 
  
 Write the bodies of the new versions of functions 
 read_molecule
  and 
 read_all_molecules 
  
 from 
 Creating New Type Annotations
 , on page 224
 .
  
  
 3.
  
 Python’s set objects have a method called 
 pop
  that removes and returns an
  
 arbitrary element from the set. If the set 
 gerbils
  contains five cuddly little ani-mals, for 
 example, calling 
 gerbils.pop()
  five times will return those animals one by one, leaving the 
 set empty at the end. Use this to write a function called 
 mating_pairs
  that takes two equal-
 sized sets called 
 males
  and 
 females
  as input and returns a set of pairs; each pair must be a 
 tuple containing one male and one female. (The elements of 
 males
  and 
 females
  may be 
 strings containing gerbil names or gerbil ID numbers—your function must work with 
 both.)
  
 4. 
  
 The PDB file format is often used to store information about molecules. A 
  
 PDB file may 
 contain zero or more lines that begin with the word 
 AUTHOR
  (which 
  
 may be in uppercase, 
 lowercase, or mixed case), followed by spaces or tabs, 
  
 followed by the name of the 
 person who created the file. Write a function that 
  
 takes a list of filenames as an input 
 argument and returns the set of all author 
  
 names found in those files.
  
 5. 
  
 The keys in a dictionary are guaranteed to be unique, but the values are not. 
  
 Write 
 a function called 
 count_values
  that takes a single dictionary as an argument
  
 report erratum  •  discuss",NA
12,NA,NA
Designing Algorithms,"An 
 algorithm
  is a set of steps that accomplishes a task, such as the steps involved in 
 synthesizing caffeine. Each function in a program, as well as the program itself, is an 
 algorithm that is written in a programming language like Python. Writing a program 
 directly in Python, without careful planning, can waste hours, days, or even weeks of 
 effort. Instead, programmers often write algorithms in a combination of English and 
 mathematics and then translate it into Python.
  
 In this chapter, you’ll learn an algorithm-writing technique called 
 top-down design
 . You 
 start by describing your solution in English and then mark the phrases that correspond 
 directly to Python statements. Those that don’t cor-respond are then rewritten in more 
 detail in English, until everything in your description can be written in Python.
  
 Looking Ahead: Testing Your Algorithms
  
 Top-down design is easy to describe, but doing it requires a little practice. Often, parts of an 
 algorithm written in English will be tricky to translate into Python; in fact, an implementation 
 may 
 look
  reasonable but will contain bugs. This is common in many fields. In mathematics, for 
 example, the first versions of “proofs” often handle common cases well but fail for odd cases 
 (
 Proofs and Refutations [Lak76]
 ). Mathemati-cians deal with this by looking for 
 counterexamples, and programmers (good program-mers, at least) deal with it by testing their 
 code as they write it.
  
 In this chapter, we have skipped a discussion of how we tested the algorithms we present. The 
 first versions we wrote had minor bugs in them, and we found them only by doing thorough 
 testing. We will talk more about testing in 
 Chapter 15, 
 Testing and Debugging
 , on page 303
 .
  
 report erratum  •  discuss",NA
Searching for the Two Smallest Values,"This section will explore how to find the index of the two smallest items in an
  
 unsorted list using three quite different algorithms. We’ll go through a top-
  
 down design using each approach.
  
 To start, suppose we have data showing the number of humpback whales
  
 sighted off the coast of British Columbia over the past ten years:
  
 809
  
 834
  
 477
  
 478
  
 307
  
 122
  
 96
  
 102
  
 324
  
 476
  
 The first value, 
 809
 , represents the number of sightings ten years ago; the last
  
 one, 
 476
 , represents the number of sightings last year.
  
 We’ll start with a simpler problem: what is the smallest value during those
  
 years? This code tells us just that:
  
 >>>
  counts = [809, 834, 477, 478, 307, 122, 96, 102, 324, 476] 
 >>>
  min(counts) 
  
 96
  
 If we want to know in which year the population bottomed out, we can use
  
 list.index
  to find the index of the smallest value:
  
 >>>
  counts = [809, 834, 477, 478, 307, 122, 96, 102, 324, 476] 
 >>>
  low = 
 min(counts) 
  
 >>>
  counts.index(low) 
  
 6
  
 Or, more succinctly:
  
 >>>
  counts = [809, 834, 477, 478, 307, 122, 96, 102, 324, 476] 
 >>>
  
 counts.index(min(counts)) 
  
 6
  
 Now, what if we want to find the indices of the 
 two
  smallest values? Lists
  
 don’t have a method to do this directly, so we’ll have to design an algorithm
  
 ourselves and then translate it to a Python function. Here is the header for
  
 a function that does this:
  
 from
  typing
  import
  List, Tuple
  
 def
  find_two_smallest(L: List[float]) -> Tuple[int, int]: 
  
  
 """"""Return a tuple of the indices of the two smallest values in list L.
  
 >>> items = [809, 834, 477, 478, 307, 122, 96, 102, 324, 476] >>> find_two_smallest(items) 
  
 (6, 7) 
  
 >>> items == [809, 834, 477, 478, 307, 122, 96, 102, 324, 476] True 
  
 """"""
  
 report erratum  •  discuss",NA
Timing the Functions,"Profiling
  a program means measuring how long it takes to run and how much memory 
 it uses. These measures—time and space—are fundamental to the theoretical study of 
 algorithms. They are also important from a pragmatic point of view. Fast programs are 
 more useful than slow ones, and programs that need more memory than what your 
 computer has aren’t particularly useful at all.
  
 This section introduces one way to time how long code takes to run. You’ll see how to 
 run the three functions we developed to find the two lowest values in a list on 1,400 
 monthly readings of air pressure in Darwin, Australia, from 
  
 1 
  
 1882 to 1998.
  
 Module 
 time
  contains functions related to time. One of these functions is 
 perf_counter
 , 
 which returns a time in seconds. We can call it before and after the code we want to 
 time and take the difference to find out how many seconds elapsed. We multiply by 
 1000 in order to convert from seconds to milliseconds:
  
 import
  time
  
 t1 = time.perf_counter()
  
 # Code to time goes here
  
 t2 = time.perf_counter() 
  
 print
 (
 'The code took {:.2f}ms'
 .format((t2 - t1) * 1000.))
  
 We’ll want to time all three of our 
 find_two_smallest
  functions. Rather than copying and 
 pasting the timing code three times, we’ll write a function that takes another function 
 as a parameter as well as the list to search in. We use type annotation 
 typing.Callable
  for 
 this parameter:
  
 Callable[[
 «
 parameter types
 »
 ],
  «
 return type
 »
 ]
  
 Since we’re not interested in what this function parameter returns, we use 
 typing.Any
  as 
 the return type. This timing function will return how many mil-liseconds it takes to 
 execute a call on the function. After the timing function is the main program that reads 
 the file of sea level pressures and then calls the timing function with each of the 
 find_two_smallest
  functions:
  
 1.
  
 See 
 http://www.stat.duke.edu/~mw/ts_data_sets.html
 .
  
 report erratum  •  discuss",NA
"At a Minimum, You Saw This","In this chapter, you learned the following:
  
 • The most effective way to design algorithms is to use top-down design, in which 
 goals are broken down into subgoals until the steps are small enough to be 
 translated directly into a programming language.
  
 • Almost all problems have more than one correct solution. Choosing be-tween them 
 often involves a trade-off between simplicity and performance.
  
 • The performance of a program can be characterized by how much time and 
 memory it uses. This can be determined experimentally by profiling its execution. 
 One way to profile time is with function 
 perf_counter
  from module 
 time
 .",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 A DNA sequence is a string made up of the letters 
 A
 , 
 T
 , 
 G
 , and 
 C
 . To find 
  
 the 
 complement of a DNA sequence, 
 A
 s are replaced by 
 T
 s, 
 T
 s by 
 A
 s, 
 G
 s 
  
 by 
 C
 s, and 
 C
 s 
 by 
 G
 s. For example, the complement of AATTGCCGT is 
  
 TTAACGGCA.
  
 a. 
  
 Write an outline in English of the algorithm you would use to find the 
  
 complement.
  
 b. 
  
 Review your algorithm. Will any characters be changed to their com-
  
 plement and then changed back to their original value? If so, rewrite 
  
 your 
 outline. Hint: Convert one character at a time, rather than all of 
  
 the 
 A
 s, 
 T
 s, 
 G
 s, 
 or 
 C
 s at once.
  
 report erratum  •  discuss",NA
13,NA,NA
Searching and Sorting,"A huge part of computer science involves studying how to organize, store, and retrieve 
 data. There are many ways to organize and process data, and you need to develop an 
 understanding of how to analyze how good an approach is. This chapter introduces 
 you to some tools and concepts that you can use to tell whether a particular approach 
 is faster or slower than another.
  
 As you know, there are many solutions to each programming problem. If a problem 
 involves a large amount of data, a slow algorithm will mean the problem can’t be 
 solved in a reasonable amount of time, even with an incredibly powerful computer. 
 This chapter includes several examples of both slower and faster algorithms. Try 
 running them yourself; experiencing just how slow (or fast) something is has a much 
 more profound effect on your understanding than the data we include in this chapter.
  
 Searching and sorting data are fundamental parts of programming. In this chapter, we 
 will develop several algorithms for searching and sorting lists, and then we will use 
 them to explore what it means for one algorithm to be faster than another. As a bonus, 
 this approach will give you another set of examples of how there are many solutions to 
 any problem, and that the approach you take to solving a problem will dictate which 
 solution you come up with.",NA
Searching a List,"As you have already seen in 
 Table 11, 
 List Methods
 , on page 142
 , Python lists have a 
 method called 
 index
  that searches for a particular item:
  
 index(...) 
  
  
 L.index(value, [start, [stop]]) -> integer -- return first index of value
  
 report erratum  •  discuss",NA
Binary Search,"Consider a list of 1 million 
 sorted
  values. Linear search starts at the beginning of the list 
 and asks, “Is this value what I’m looking for?” If it isn’t, the same is
  
 report erratum  •  discuss",NA
Sorting,"Now let’s look at a slightly harder problem. The following table 
 1
  shows the number of 
 acres burned in forest fires in Canada from 1918 to 1987. What were the worst years?
  
 563
  
 7590
  
 1708
  
 2142
  
 3323
  
 6197
  
 1985
  
 1316
  
 1824
  
 472
  
 1346
  
 6029
  
 2670
  
 2094
  
 2464
  
 1009
  
 1475
  
 856
  
 3027
  
 4271
  
 3126
  
 1115
  
 2691
  
 4253
  
 1838
  
 828
  
 2403
  
 742
  
 1017
  
 613
  
 3185
  
 2599
  
 2227
  
 896
  
 975
  
 1358
  
 264
  
 1375
  
 2016
  
 452
  
 3292
  
 538
  
 1471
  
 9313
  
 864
  
 470
  
 2993
  
 521
  
 1144
  
 2212
  
 2212
  
 2331
  
 2616
  
 2445
  
 1927
  
 808
  
 1963
  
 898
  
 2764
  
 2073
  
 500
  
 1740
  
 8592
  
 10856
  
 2818
  
 2284
  
 1419
  
 1328
  
 1329
  
 1479
  
 Table 22—Acres Lost to Forest Fires in Canada (in thousands), 1918–1987
  
 One way to find out how much forest was destroyed in the 
 N
  worst years is to sort the 
 list and then take the last 
 N
  values, as shown in the following code:
  
 def
  find_largest(n: int, L: list) -> list: 
  
  
 """"""Return the n largest values in L in order from smallest to largest.
  
 >>> L = [3, 4, 7, -1, 2, 5] 
  
 >>> find_largest(3, L) 
  
 [4, 5, 7] 
  
 """"""
  
 copy = sorted(L) 
  
 return
  copy[-n:]
  
 This algorithm is short, clean, and easy to understand, but it relies on a bit of black 
 magic. How 
 does
  function 
 sorted
  (and also method 
 list.sort
 ) work? And how efficient are 
 they?
  
 It turns out that many sorting algorithms have been developed over the years, each 
 with its own strengths and weaknesses. Broadly speaking, they can be divided into two 
 categories: those that are simple but inefficient and those
  
 1.
  
 http://robjhyndman.com/tsdldata/annual/canfire.dat
 : Number of acres burned in forest fires in
  
 Canada, 1918–1987.
  
 report erratum  •  discuss",NA
More Efficient Sorting Algorithms,"The analysis of selection and insertion sort begs the question, how can 
 list.sort 
 be so 
 much more efficient? The answer is the same as it was for binary search: by taking 
 advantage of the fact that some values are already sorted.
  
 A First Attempt
  
 Consider the following function:
  
 import
  bisect
  
 def
  bin_sort(values: list) -> list:
  
 """"""Return a sorted version of the values. >>> L = [3, 4, 7, -1, 2, 
 5] 
  
 >>> bin_sort(L) 
  
 [-1, 2, 3, 4, 5, 7] 
  
 """"""
  
 (This does not mutate values.)
  
 report erratum  •  discuss",NA
Merge Sort: A Faster Sorting Algorithm,"There are several well-known, fast sorting algorithms; merge sort, quick sort, and heap 
 sort are the ones you are most likely to encounter in a future com-puter science course. 
 Most of them involve techniques that we haven’t taught you yet, but merge sort can be 
 written to be more accessible. Merge sort is built around the idea that taking two 
 sorted lists and merging them is propor-tional to the number of items in both lists. The 
 running time for merge sort is 
 N
  log
 2
  N
 .
  
 We’ll start with very small lists and keep merging them until we have a single sorted list.
  
 report erratum  •  discuss",NA
Sorting Out What You Learned,"In this chapter, you learned the following:
  
 • An invariant describes the data being used in a loop. The initial values for the 
 variables used in the loop will establish the invariant, and the work done inside 
 the loop will make progress toward the solution. When the loop terminates, the 
 invariant is still true, but the solution will have been reached.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available
  
 at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 All three versions of linear search start at index 0. Rewrite all to search from
  
 the end of the list instead of from the beginning. Make sure you test them.
  
 2. 
  
 For the new versions of linear search: if there are duplicate values, which
  
 do they find?
  
 3. 
  
 Binary search is significantly faster than the built-in search but requires
  
 that the list is sorted. As you know, the running time for the best sorting
  
 algorithm is on the order of 
 N
  log
 2
  N
 , where 
 N
  is the length of the list. If
  
 we search a lot of times on the same list of data, it makes sense to sort
  
 it once before doing the searching. Roughly how many times do we need
  
 to search in order to make sorting and then searching faster than using
  
 the built-in search?
  
 4. 
  
 Given the unsorted list 
 [6, 5, 4, 3, 7, 1, 2]
 , show what the contents of the list
  
 would be after each iteration of the loop as it is sorted using the following:
  
 a. 
  
 Selection sort
  
 b. 
  
 Insertion sort
  
 5. 
  
 Another sorting algorithm is 
 bubble sort
 . Bubble sort involves keeping a
  
 sorted section at the end of the list. The list is traversed, pairs of elements
  
 are compared, and larger elements are swapped into the higher position.
  
 This is repeated until all elements are sorted.
  
 a. 
  
 Using the English description of bubble sort, write an outline of the
  
 bubble sort algorithm in English.
  
 b. 
  
 Continue using top-down design until you have a Python algorithm.
  
 c. 
  
 Turn it into a function called 
 bubble_sort(L)
 .
  
 d. 
  
 Try it out on the test cases from 
 selection_sort
 .
  
 6. 
  
 In the description of bubble sort in the previous exercise, the sorted section
  
 of the list was at the end of the list. In this exercise, bubble sort will
  
 maintain the sorted section at the beginning of the list. Make sure that
  
 you are still implementing bubble sort!
  
 report erratum  •  discuss",NA
14,NA,NA
Object-Oriented Programming,"Imagine you’ve been hired to help write a program to keep track of books in
  
 a bookstore. Every record about a book would probably include the title,
  
 authors, publisher, price, and ISBN, which stands for International Standard
  
 Book Number, a unique identifier for a book.
  
 Read this code and try to guess what it prints:
  
 python_book = Book( 
  
 'Practical Programming'
 , 
  
 [
 'Campbell'
 ,
  'Gries'
 ,
  'Montojo'
 ], 
  
 'Pragmatic Bookshelf'
 , 
  
 '978-1-6805026-8-8'
 , 
  
 25.0)
  
 survival_book = Book( 
  
 ""New Programmer's Survival Manual""
 , 
  
 [
 'Carter'
 ], 
  
 'Pragmatic Bookshelf'
 , 
  
 '978-1-93435-681-4'
 , 
  
 19.0)
  
 print
 (
 '{0} was written by {1} authors and costs ${2}'
 .format( 
  
  
 python_book.title, python_book.num_authors(), python_book.price))
  
 print
 (
 '{0} was written by {1} authors and costs ${2}'
 .format( 
  
  
 survival_book.title, survival_book.num_authors(), survival_book.price))
  
 You might guess that this code creates two book objects, one called 
 Practical
  
 Programming
  and one called 
 New Programmer’s Survival Manual
 . You might
  
 even guess the output:
  
 Practical Programming was written by 3 authors and costs $25.0 
  
 New Programmer's Survival Manual was written by 1 authors and costs $19.0
  
 There’s a problem, though: this code doesn’t run. Python doesn’t have a 
 Book
  type.
  
 And that is what this chapter is about: how to define and use your own types.
  
 report erratum  •  discuss",NA
Understanding a Problem Domain,"In our book example, we wrote the code based on what we 
 wanted
  to do with books. 
 The idea of a 
 Book
  type comes from the 
 problem domain
 : keeping track of books in a 
 bookstore. We thought about this problem domain and figured out what features of a 
 book we cared about.
  
 We might have decided to keep track of the number of pages, the date it was published, 
 and much more; what you decide to keep track of depends exactly on what your 
 program is supposed to do.
  
 It’s common to define multiple related types. For example, if this code was part of an 
 online store, we might also have an 
 Inventory
  type, perhaps a 
 Shop-pingCart
  type, and 
 much more.
  
 Object-oriented programming revolves around defining and using new types. As you 
 learned in 
 Modules, Classes, and Methods
 , on page 115
 , a class is how Python represents 
 a type. Object-oriented programming involves at least these phases:
  
 1. 
  
 Understanding the problem domain.
  This step is crucial: you need to know 
  
 what 
 your customer wants (your boss, perhaps a friend or business con-
  
 tact, perhaps 
 yourself) before you can write a program that does what the 
  
 customer wants.
  
 2. 
  
 Figuring out what type(s) you might want.
  A good starting point is to read 
  
 the 
 description of the problem domain and look for the main nouns and 
  
 noun phrases.
  
 3. 
  
 Figuring out what features you want your type to have.
  Here you should 
  
 write 
 some code that 
 uses
  the type you’re thinking about, much like we 
  
 did with the 
 Book
  code 
 at the beginning of this chapter. This is a lot like 
  
 the Examples step in the 
 function design recipe, where you decide what 
  
 the code that you’re about to write 
 should do.
  
 4. 
  
 Writing a class that represents this type.
  You now need to tell Python about 
  
 your 
 type. To do this, you will write a class, including a set of methods 
  
 inside that class. (You 
 will use the function design recipe as you design 
  
 and implement each of your 
 methods.)
  
 5. 
  
 Testing your code.
  Your methods will have been tested separately as you 
  
 followed the function design recipe, but it’s important to think about how 
  
 the 
 various methods will interact.
  
 report erratum  •  discuss",NA
"Function isinstance, Class object, and Class Book","Function 
 isinstance
  reports whether an object is an 
 instance
  of a class—that
  
 is, whether an object has a particular type:
  
 >>>
  isinstance(
 'abc'
 , str) 
  
 True 
  
 >>>
  isinstance(55.2, str) 
  
 False
  
 'abc'
  is an instance of 
 str
 , but 
 55.2
  is not.
  
 Python has a class called 
 object
 . Every other class is based on it:
  
 >>>
  help(object) 
  
 Help on class object in module builtins:
  
 class object 
  
 | 
  
 The most base type
  
 Function 
 isinstance
  reports that both 
 'abc'
  and 
 55.2
  are instances of class 
 object
 :
  
 >>>
  isinstance(55.2, object) 
  
 True 
  
 >>>
  isinstance(
 'abc'
 , object) 
  
 True
  
 Even classes and functions are instances of 
 object
 :
  
 >>>
  isinstance(str, object) 
  
 True 
  
 >>>
  isinstance(max, object) 
  
 True
  
 What’s happening here is that every class in Python is 
 derived
  from class
  
 object
 , and so every instance of every class is an 
 object
 .
  
 Using object-oriented lingo, we say that class 
 object
  is the 
 superclass
  of class
  
 str
 , and class 
 str
  is a 
 subclass
  of class 
 object
 . The superclass information is
  
 available in the 
 help
  documentation for a type:
  
 >>>
  help(int) 
  
 Help on class int in module builtins:
  
 class int(object)
  
 Here we see that class 
 SyntaxError
  is a subclass of class 
 Exception
 :
  
 >>>
  help(SyntaxError) 
  
 Help on class SyntaxError in module builtins:
  
 class SyntaxError(Exception)
  
 report erratum  •  discuss",NA
Writing a Method in Class Book,"As you saw in 
 Chapter 7, 
 Using Methods
 , on page 115
 , there are two ways to
  
 call a method. One way is to access the method through the class, and the
  
 other is to use object-oriented syntax. These two calls are equivalent:
  
 >>>
  str.capitalize(
 'browning'
 ) 
  
 'Browning' 
  
 >>>
  'browning'
 .capitalize() 
  
 'Browning'
  
 We’d like to be able to write similar code involving class 
 Book
 . For example,
  
 we might want to be able to ask how many authors a 
 Book
  has:
  
 >>>
  Book.num_authors(ruby_book) 
  
 3 
  
 >>>
  ruby_book.num_authors() 
  
 3
  
 To get this to work, we’ll define a method called 
 num_authors
  inside 
 Book
 . Here it is:
  
 class
  Book: 
  
  
 """"""Information about a book.""""""
  
 def
  num_authors(self) -> int: 
  
  
 """"""Return the number of authors of this book.
  
 """"""
  
 return
  len(self.authors)
  
 Book
  method 
 num_authors
  looks just like a function except that it has a parameter called 
 self
 , 
 which refers to a 
 Book
 . Assuming this class is defined in the file 
 book.py
 , we can import it, 
 create a 
 Book
  object, and call 
 num_authors
  in two different ways:
  
 >>>
  import book 
  
 >>>
  ruby_book = book.Book() 
  
 >>>
  ruby_book.title =
  'Programming Ruby' 
  
 >>>
  ruby_book.authors = [
 'Thomas'
 ,
  'Fowler'
 ,
  'Hunt'
 ] 
 >>>
  
 book.Book.num_authors(ruby_book) 
  
 3 
  
 >>>
  ruby_book.num_authors() 
  
 3
  
 report erratum  •  discuss",NA
Plugging into Python Syntax: More Special Methods,"In 
 What Are Those Underscores?
 , on page 123
 , you learned that some Python syntax, such as 
 +
  or 
 ==
 , triggers method calls. For example, when Python sees 
 'abc' + '123'
 , it turns that into 
 'abc'.__add__('123')
 . When we call 
 print(obj)
 , then 
 obj.__str__()
  is called to find out what string to 
 print.
  
 You can do this too. All you need to do is define these special methods inside your classes.
  
 The output Python produces when we print a 
 Book
  isn’t particularly useful:
  
 >>>
  python_book = Book( 
  
 ... 
  
 'Practical Programming'
 , 
  
 ... 
  
 [
 'Campbell'
 ,
  'Gries'
 ,
  'Montojo'
 ], 
  
 ... 
  
 'Pragmatic Bookshelf'
 , 
  
  
 '978-1-6805026-8-8'
 , 
 ...
  
 ... 
  
 25.0) 
  
 >>>
  print(python_book) 
  
 <book.Book object at 0x59f410>
  
 report erratum  •  discuss",NA
A Little Bit of OO Theory,"Classes and objects are two of programming’s power tools. They let good
  
 programmers do a lot in very little time, but with them, bad programmers
  
 can create a real mess. This section will introduce some underlying theory
  
 that will help you design reliable, reusable object-oriented software.
  
 Encapsulation
  
 To 
 encapsulate
  something means to enclose it in some kind of container. In
  
 programming, 
 encapsulation
  means keeping data and the code that uses it
  
 in one place and hiding the details of exactly how they work together. For
  
 example, each instance of class 
 file
  keeps track of what file on the disk it is
  
 reading or writing and where it currently is in that file. The class hides the
  
 details of how this is done so that programmers can use it without needing
  
 to know the details of how it was implemented.
  
 report erratum  •  discuss",NA
"A Case Study: Molecules, Atoms, and PDB Files","Molecular graphic visualization tools allow for interactive exploration of molecular
  
 structures. Most read PDB-formatted files, which we describe in 
 Multiline Records
 ,
  
 on page 195
 . For example, Jmol (in the following graphic) is a Java-based open
  
 source 3D viewer for these structures.
  
  
 report erratum  •  discuss",NA
Classifying What You’ve Learned,"In this chapter, you learned the following:
  
 •
  In object-oriented languages, new types are defined by creating classes. Classes support 
 encapsulation; in other words, they combine data and the operations
  
 on it so that other parts of the program can ignore implementation details.
  
 •
  Classes also support polymorphism. If two classes have methods that work the same 
 way, instances of those classes can replace one another without
  
 the rest of the program being affected. This enables “plug-and-play” program-
  
 ming, in which one piece of code can perform different operations depending
  
 on the objects it is operating on.
  
 •
  Finally, new classes can be defined by inheriting features from existing ones. The new 
 class can override the features of its parent and/or add new features.
  
 •
  When a method is defined in a class, its first argument must be a variable that represents 
 the object the method is being called on. By convention, this
  
 argument is called 
 self
 .
  
 •
  Some methods have special predefined meanings in Python; to signal this, their names 
 begin and end with two underscores. Some of these methods are
  
 called when constructing objects (
 __init__
 ) or converting them to strings (
 __str__
  
 and 
 __repr__
 ); others, like 
 __add__
  and 
 __sub__
 , are used to imitate arithmetic.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available
  
 at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 In this exercise, you will implement class 
 Country
 , which represents a
  
 country with a name, a population, and an area.
  
 a. 
  
 Here is a sample interaction from the Python shell:
  
 >>>
  canada = Country(
 'Canada'
 , 34482779, 9984670) 
 >>>
  
 canada.name 
  
 'Canada' 
  
 >>>
  canada.population 
  
 34482779 
  
 >>>
  canada.area 
  
 9984670
  
 This code cannot be executed yet because class 
 Country
  does not exist.
  
 Define 
 Country
  with a constructor (method 
 __init__
 ) that has four parameters:
  
 a country, its name, its population, and its area.
  
 b. 
  
 Consider this code:
  
 >>>
  canada = Country(
 'Canada'
 , 34482779, 9984670) 
  
 >>>
  usa = Country(
 'United States of America'
 , 313914040, 9826675) 
 >>>
  
 canada.is_larger(usa) 
  
 True
  
 In class 
 Country
 , define a method named 
 is_larger
  that takes two 
 Country
  
 objects and returns 
 True
  if and only if the first has a larger area than the
  
 second.
  
 c. 
  
 Consider this code:
  
 >>>
  canada.population_density() 
  
 3.4535722262227995
  
 In class 
 Country
 , define a method named 
 population_density
  that returns
  
 the population density of the country (people per square kilometer).
  
 d. 
  
 Consider this code:
  
 >>>
  usa = Country(
 'United States of America'
 , 313914040, 9826675) 
 >>>
  print(usa) 
  
 United States of America has a population of 313914040 and is 9826675 square km.
  
 In class 
 Country
 , define a method named 
 __str__
  that returns a string
  
 representation of the country in the format shown here.
  
 report erratum  •  discuss",NA
15,NA,NA
Testing and Debugging,"How can you tell whether the programs you write work correctly? Following the 
 function design recipe from 
 Designing New Functions: A Recipe
 , on page 47
 , you include 
 an example call or two in the docstring. The last step of the recipe is calling your 
 function to make sure it returns what you expect. But are one or two calls enough? If 
 not, how many do you need? How do you pick the arguments for those function calls? 
 In this chapter, you’ll learn how to choose good test cases and how to test your code 
 using Python’s 
 unittest
  module.
  
 Finally, what happens if your tests fail, revealing a bug? (See 
 What's a Bug?
 , on page 4
 .) 
 How can you tell where the problem is in your code? This chapter will also teach you 
 how to find and fix bugs in your programs.",NA
Why Do You Need to Test?,"Quality assurance
 , or QA, checks that software is working correctly. Over the last fifty 
 years, programmers have learned that quality isn’t some kind of magic pixie dust that 
 you can sprinkle on a program after it has been written. Quality has to be designed in, 
 and software must be tested and retested to check that it meets standards.
  
 The good news is that putting effort into QA actually makes you more produc-tive 
 overall. The later you find a bug, the more expensive it is to fix, so catching bugs early 
 reduces overall effort. The reason can be seen in Boehm’s curve as 
 shown on page 304
 .
  
 Most good programmers today don’t just test their software while writing it; they build 
 their tests so that other people can rerun them months later and a dozen time zones 
 away. This takes a little more time up front but makes programmers more productive 
 overall, since every hour invested in preventing bugs saves two, three, or ten 
 frustrating hours tracking bugs down.
  
 report erratum  •  discuss",NA
Case Study: Testing above_freezing,"The first function that we’ll test is 
 above_freezing
  from 
 Testing Your Code Semiauto-matically
 , on 
 page 110
 :
  
 def
  above_freezing(celsius: float) -> bool: 
  
  
 """"""Return True iff temperature celsius degrees is above freezing.
  
 >>> above_freezing(5.2) 
  
 True 
  
 >>> above_freezing(-2) 
  
 False 
  
 """"""
  
 return
  celsius > 0
  
 In that section, we ran the example calls from the docstring using 
 doctest
 . But we’re missing 
 a test: what happens if the temperature is zero? In the next section, we’ll write another 
 version of this function that behaves differently at zero and we’ll discuss how our current 
 set of tests is incomplete.
  
 Choosing Test Cases for above_freezing
  
 Before writing our testing code, we must decide which test cases to use. Function 
 above_freezing
  takes one argument, a number, so for each test case,
  
 report erratum  •  discuss",NA
Case Study: Testing running_sum,"In 
 Case Study: Testing above_freezing
 , on page 304
 , we tested a program that involved 
 only immutable types. In this section, you’ll learn how to test func-tions involving 
 mutable types, like lists and dictionaries.
  
 Suppose we need to write a function that modifies a list so that it contains a running 
 sum of the values in it. For example, if the list is 
 [1, 2, 3]
 , the list should be mutated so 
 that the first value is 
 1
 , the second value is the sum of the first two numbers, 
 1 + 2
 , and 
 the third value is the sum of the first three numbers, 
 1 + 2 + 3
 , so we expect that the list 
 [1, 2, 3]
  will be modified to be 
 [1, 3, 6]
 .
  
 Following the function design recipe (see 
 Designing New Functions: A Recipe
 , on page 
 47
 ), here is a file named 
 sums.py
  that contains the completed function with one 
 (passing) example test:
  
 report erratum  •  discuss",NA
Choosing Test Cases,"Having a set of tests that pass is good; it shows that your code does what it should in 
 the situations you’ve thought of. However, for any large project there will be situations 
 that 
 don’t
  occur to you. Tests can show the absence of many bugs, but it can’t show that 
 a program is fully correct.
  
 It’s important to make sure you have good 
 test coverage
 : that your test cases cover 
 important situations. In this section, we provide some heuristics that will help you 
 come up with a fairly thorough set of test cases.
  
 Now that you’ve seen two example sets of tests, we’ll give you an overview of things to 
 think about while you’re developing tests for other functions. Some of them overlap 
 and not all will apply in every situation, but they are all worth thinking about while you 
 are figuring out what to test.
  
 •
  Think about size.
  When a test involves a collection such as a list, string, dictionary, or 
 file, you need to do the following:
  
  
 – Test the empty collection.
  
 – Test a collection with one item in it.
  
 – Test a general case with several items.
  
 – Test the smallest interesting case, such as sorting a list containing 
  
 two 
 values.
  
 •
  Think about dichotomies.
   A 
 dichotomy
  is a contrast between two things. Examples 
 of 
 dichotomies 
 are 
 empty/full, 
 even/odd, 
 positive/negative, 
 and 
 alphabetic/nonalphabetic. If a function deals with two or more differ-ent 
 categories or situations, make sure you test all of them.
  
 •
  Think about boundaries.
  If a function behaves differently around a partic-ular 
 boundary or threshold, test exactly that boundary case.
  
 •
  Think about order.
  If a function behaves differently when values appear in different 
 orders, identify those orders and test each one of them. For
  
 report erratum  •  discuss",NA
Hunting Bugs,"Bugs are discovered through testing and through program use, although the latter is 
 what good testing can help avoid. Regardless of how they are discov-ered, tracking 
 down and eliminating bugs in your programs is part of every programmer’s life. This 
 section introduces some techniques that can make debugging more efficient and give 
 you more time to do the things you’d rather be doing.
  
 Debugging a program is like diagnosing a medical condition. To find the cause, you 
 start by working backward from the symptoms (or, in a program, its incorrect 
 behavior), then you come up with a solution and test it to make sure it actually fixes 
 the problem.
  
 At least, that’s the right way to do it. Many beginners make the mistake of skipping the 
 diagnosis stage and trying to cure the program by changing things at random. 
 Renaming a variable or swapping the order in which two functions are defined might 
 actually fix the program, but millions of such changes are possible. Trying them one 
 after another in no particular order can be an inefficient waste of many, many hours.
  
 Here are some rules for tracking down the cause of a problem:
  
 1. 
  
 Make sure you know what the program is supposed to do.
  Sometimes this 
  
 means doing the calculation by hand to see what the correct answer is. 
  
 Other times it means reading the documentation (or the assignment 
  
 handout) 
 carefully or writing a test.
  
 2. 
  
 Repeat the failure.
  You can debug things only when they go wrong, so find 
  
 a test 
 case that makes the program fail reliably. Once you have one, try 
  
 to find a simpler one; 
 doing this often provides enough clues to allow you 
  
 to fix the underlying problem.
  
 report erratum  •  discuss",NA
Bugs We’ve Put in Your Ear,"In this chapter, you learned the following:
  
 • Finding and fixing bugs early reduces overall effort.
  
 • When choosing test cases, you should consider size, dichotomies, boundary cases, 
 and order.
  
 • To test your functions, you can write subclasses of 
 unittest
 ’s 
 TestCase
  class. The 
 advantages of using 
 unittest
  include keeping the testing code separate from the 
 code being tested, being able to keep the tests independent of one another, and 
 being able to document each individual test case.
  
 • To debug software, you have to know what it is supposed to do and be able to 
 repeat the failure. Simplifying the conditions that make the program fail is an 
 effective way to narrow down the set of possible causes.",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Your lab partner claims to have written a function that replaces each 
  
 value in a list 
 with twice the preceding value (and the first value with 0). 
  
 For example, if the list 
 [1, 2, 3]
  is passed as an argument, the function is 
  
 supposed to turn it into 
 [0, 2, 4]
 . Here’s 
 the code:
  
 report erratum  •  discuss",NA
16,NA,NA
Creating Graphical User Interfaces,"Most of the programs in previous chapters are not interactive. Once launched, they run 
 to completion without giving us a chance to steer them or provide new input. The few 
 that do communicate with us do so through the kind of text-only 
 command-line user 
 interface
 , or CLUI, that would have already been considered old-fashioned in the early 
 1980s.
  
 As you already know, most modern programs interact with users via a 
 graphical user 
 interface
 , or GUI, which is made up of windows, menus, buttons, and so on. In this 
 chapter, we will show you how to build simple GUIs using a Python module called 
 tkinter
 . Along the way, we will introduce a different way of structuring programs called 
 event-driven programming
 . A traditionally structured program usually has control over 
 what happens when, but an event-driven program must be able to respond to input at 
 unpredictable moments.
  
 tkinter
  is one of several toolkits you can use to build GUIs in Python. It is the only one 
 that comes with a standard Python installation.",NA
Using Module tkinter,"Every 
 tkinter
  program consists of these things:
  
 • Windows, buttons, scrollbars, text areas, and other 
 widgets
 —anything that you can 
 see on the computer screen. (Generally, the term 
 widget 
 means any useful object; 
 in programming, it is short for “window gadget.”)
  
 • Modules, functions, and classes that manage the data that is being shown in the 
 GUI—you are familiar with these; they are the tools you’ve seen so far in this book.
  
 • An event manager that 
 listens
  for events such as mouse clicks and keystrokes and 
 reacts to these events by calling event handler functions.
  
 report erratum  •  discuss",NA
Building a Basic GUI,"Label
 s are widgets that are used to display short pieces of text. Here we create a 
 Label
  
 that belongs to the root window—its 
 parent widget
 —and we specify the text to be 
 displayed by assigning it to the 
 Label
 ’s 
 text
  parameter.
  
 import
  tkinter
  
 window = tkinter.Tk() 
  
 label = tkinter.Label(window, text=
 'This is our label.'
 ) label.pack()
  
 window.mainloop()
  
 Here is the resulting GUI:
  
  
 Method call 
 label.pack()
  is crucial. Each widget has a method called 
 pack
  that places it in 
 its parent widget and then tells the parent to resize itself as nec-essary. If we forget to 
 call this method, the child widget (in this case, 
 Label
 ) won’t be displayed or will be 
 displayed improperly.
  
 Label
 s display text. Often, applications will want to update a label’s text as the program 
 runs to show things like the name of a file or the time of day. One way to do this is 
 simply to assign a new value to the widget’s text using method 
 config
 :
  
 report erratum  •  discuss",NA
"Models, Views, and Controllers, Oh My!","Using a 
 StringVar
  to connect a text-entry box and a label is the first step toward 
 separating 
 models
  (How do we represent the data?), 
 views
  (How do we display the 
 data?), and 
 controllers
  (How do we modify the data?), which is the key to building 
 larger GUIs (as well as many other kinds of applications). This MVC design helps 
 separate the parts of an application, which will make the appli-cation easier to 
 understand and modify. The main goal of this design is to keep the representation of 
 the data separate from the parts of the program that the user interacts with; that way, 
 it is easier to make changes to the GUI code without affecting the code that manipulates 
 the data.
  
 As its name suggests, a view is something that displays information to the user, like 
 Label
 . Many views, like 
 Entry
 , also accept input, which they display immediately. The key 
 is that they don’t do anything else: they don’t calculate average temperatures, move 
 robot arms, or do any other calculations.
  
 Models, on the other hand, store data, like a piece of text or the current inclination of a 
 telescope. They also don’t do calculations; their job is simply to keep track of the 
 application’s current state (and, in some cases, to save that state to a file or database 
 and reload it later).
  
 Controllers are the pieces that convert user input into calls on functions in the model 
 that manipulate the data. The controller is what decides whether two gene sequences 
 match well enough to be colored green or whether someone is allowed to overwrite an 
 old results file. Controllers may update an application’s models, which in turn can 
 trigger changes to its views.
  
 The following code shows what all of this looks like in practice. Here the model is kept 
 track of by variable 
 counter
 , which refers to an 
 IntVar
  so that the view will update itself 
 automatically. The controller is function 
 click
 , which updates the model whenever a 
 button is clicked. Four objects make up the view: the root window, a 
 Frame
 , a 
 Label
  that 
 shows the current value of 
 counter
 , and a button that the user can click to increment the 
 counter
 ’s value:
  
 import
  tkinter
  
 # The controller.
  
 def
  click(): 
  
  
 counter.set(counter.get() + 1)
  
 if
  __name__ ==
  '__main__'
 : 
  
 window = tkinter.Tk() 
  
 # The model.
  
 counter = tkinter.IntVar() 
  
 counter.set(0)
  
 report erratum  •  discuss",NA
Customizing the Visual Style,"Every windowing system has its own 
 look and feel
 —square or rounded corners, 
 particular colors, and so on. In this section, we’ll see how to change the appearance of 
 GUI widgets to make applications look more distinctive.
  
 A note of caution before we begin: the default styles of some windowing systems have 
 been chosen by experts trained in graphic design and human-computer interaction. 
 The odds are that any radical changes on your part will make things worse, not better. 
 In particular, be careful about color (Roughly 8% percent of the male population with 
 Northern European ancestry have red-green color blindness 
 1
 ) and font size (many 
 people, particularly the elderly, cannot read small text).
  
 Changing Fonts
  
 Let’s start by changing the size, weight, slant, and family of the font used to display 
 text. To specify the size, we provide the height as an integer in points. We can set the 
 weight to either bold or normal and the slant to either italic (slanted) or roman (not 
 slanted).
  
 The font families we can use depend on what system the program is running on. 
 Common families include Times, Courier, and Verdana, but dozens of others are 
 usually available. One note of caution, though: if you choose an unusual font, people 
 running your program on other computers might not have it, so your GUI might appear 
 different than you’d like for them. Every operating system has a default font that will 
 be used if the requested font isn’t installed.
  
 1.
  
 See 
 https://nei.nih.gov/health/color_blindness/facts_about
 .
  
 report erratum  •  discuss",NA
Introducing a Few More Widgets,"To end this chapter, we will look at a few more commonly used widgets.
  
 Using Text
  
 The 
 Entry
  widget that we have been using since the start of this chapter allows for only 
 a single line of text. If we want multiple lines of text, we use the 
 Text 
 widget instead, as 
 shown here:
  
 report erratum  •  discuss",NA
Object-Oriented GUIs,"The GUIs we have built so far have not been particularly well structured. Most of the code to 
 construct them has not been modularized in functions, and they have relied on global 
 variables. We can get away with this for very small examples, but if we try to build larger 
 applications this way, they will be difficult to under-stand and debug.
  
 For this reason, almost all real GUIs are built using classes and objects that tie models, 
 views, and controllers together in one tidy package. In the counter shown next, for example, 
 the application’s model is a member variable of class 
 Counter
 , accessed using 
 self.state
 , and its 
 controllers are the methods 
 up_click
  and 
 quit_click
 .
  
 import
  tkinter
  
 class
  Counter: 
  
 """"""A simple counter GUI using object-oriented programming."""""" 
 def
  __init__(self, parent):
  
 """"""Create the GUI.""""""
  
 # Framework.
  
 self.parent = parent 
  
 self.frame = tkinter.Frame(parent) 
  
 self.frame.pack()
  
 report erratum  •  discuss",NA
Keeping the Concepts from Being a GUI Mess,"In this chapter, you learned the following:
  
 • Most modern programs provide a graphical user interface (GUI) for dis-
  
 playing information and interacting with users. GUIs are built out of
  
 widgets, such as buttons, sliders, and text panels; all modern programming
  
 languages provide at least one GUI toolkit.
  
 • Unlike command-line programs, GUI applications are usually event-driven.
  
 In other words, they react to events such as keystrokes and mouse clicks
  
 when and as they occur.
  
 • Experience shows that GUIs should be built using the model-view-con-
  
 troller pattern. The model is the data being manipulated; the view displays
  
 the current state of the data and gathers input from the user, while the
  
 controller decides what to do next.
  
 • Lambda expressions create functions that have no names. These are often
  
 used to define the actions that widgets should take when users provide
  
 input, without requiring global variables.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 Write a GUI application with a button labeled “Goodbye.” When the button 
  
 is 
 clicked, the window closes.
  
 2. 
  
 Write a GUI application with a single button. Initially the button is labeled 
  
 0, 
 but each time it is clicked, the value on the button increases by 1.
  
 3. 
  
 What is a more readable way to write the following?
  
 x =
  lambda
 : y
  
 4. 
  
 A DNA sequence is a string made up of 
 A
 s, 
 T
 s, 
 C
 s, and 
 G
 s. Write a GUI 
  
 application in 
 which a DNA sequence is entered, and when the Count 
  
 button is clicked, the number of 
 A
 s, 
 T
 s, 
 C
 s, and 
 G
 s are counted and dis-
  
 played in the window (see the following image).
  
  
 5.
  
 In 
 Defining Our Own Functions
 , on page 35
 , we wrote a function to convert
  
 degrees Fahrenheit to degrees Celsius. Write a GUI application that looks like the 
 following image.
  
  
 report erratum  •  discuss",NA
17,NA,NA
Databases,"In earlier chapters, we used files to store data. This is fine for small problems, but as 
 our data sets become larger and more complex, we need something that will let us 
 search for data in many different ways, control who can view and modify the data, and 
 ensure that the data is correctly formatted. In short, we need a database.
  
 Many different kinds of databases exist. Some are like a dictionary that automatically 
 saves itself on disk, whereas others store backup copies of the objects in a program. 
 The most popular by far, however, are 
 relational databases
 , which are at the heart of 
 most large commercial and scientific software systems. In this chapter, you will learn 
 about the key concepts behind relational databases and how to perform a few common 
 operations.",NA
Overview,"A relational database is a collection of 
 tables
 , each of which has a fixed number of 
 columns and a variable number of rows. Each column in a table has a name and 
 contains values of the same data type, such as integer or string. Each row, or 
 record
 , 
 contains values that are related to each other, such as a particular patient’s name, date 
 of birth, and blood type.
  
 Patients
  
 name
  
 birthday
  
 blood_type
  
 row
  
 Alice
  
 1978/04/02
  
 A
  
 Bob
  
 1954/03/10
  
 AB
  
 Carol
  
 1963/09/29
  
 A
  
 Liz
  
 1977/12/15
  
 B
  
 Wally
  
 1949/07/05
  
 O
  
 column
  
 report erratum  •  discuss",NA
Creating and Populating,"As a running example, we will use the predictions for regional populations in the year 
 2300, which is taken from 
 http://www.worldmapper.org
 . The first table that we’ll work 
 with, 
 Table 30, 
 Estimated World Population in 2300
 , on page 345
 , has one column that 
 contains the names of regions and another that contains the populations of regions, so 
 each row of the table represents a region and its population.
  
 report erratum  •  discuss",NA
Retrieving Data,"Now that our database has been created and populated, we can run 
 queries
  to search for data 
 that meets specified criteria. The general form of a query is as follows:
  
 SELECT
  «
 ColumnName
 »
  , ...
  FROM
  «
 TableName
 »
  
 The 
 TableName
  is the name of the table to get the data from and the column names specify 
 which columns to get values from. For example, this query retrieves all the data in the table 
 PopByRegion
 :
  
 >>>
  cur.execute(
 'SELECT Region, Population FROM PopByRegion'
 )
  
 Once the database has executed this query for us, we can access the results one record at a 
 time by calling the cursor’s 
 fetchone
  method, just as we can read one line at a time from a file 
 using 
 readline
 :
  
 >>>
  cur.fetchone() 
  
 ('Central Africa', 330993)
  
 report erratum  •  discuss",NA
Updating and Deleting,"Data often changes over time, so we need to be able to change the information
  
 stored in databases. To do that, we can use the 
 UPDATE
  command, as shown in
  
 the 
 code on page 351
 .
  
 >>>
  cur.execute(
 'SELECT * FROM PopByRegion WHERE Region = ""Japan""'
 ) 
 <sqlite3.Cursor 
 object at 0x102e3e490> 
  
 >>>
  cur.fetchone() 
  
 ('Japan', 100562) 
  
 >>>
  cur.execute(
 ''
 'UPDATE PopByRegion SET Population = 100600 
  
 WHERE 
 Region = ""Japan""''') 
  
 <sqlite3.Cursor object at 0x102e3e490> 
  
 >>>
  cur.execute(
 'SELECT * FROM PopByRegion WHERE Region = ""Japan""'
 ) 
 <sqlite3.Cursor 
 object at 0x102e3e490> 
  
 >>>
  cur.fetchone() 
  
 ('Japan', 100600)
  
 We can also delete records from the database:
  
 >>>
  cur.execute(
 'DELETE FROM PopByRegion WHERE Region < ""L""'
 ) 
  
 <sqlite3.Cursor object at 0x102e3e490> 
  
 >>>
  cur.execute(
 'SELECT * FROM PopByRegion'
 ) 
  
 <sqlite3.Cursor object at 0x102e3e490> 
  
 >>>
  cur.fetchall() 
  
 [('Southeastern Africa', 743112), ('Northern Africa', 1037463), 
  
 ('Southern Asia', 2051941), ('Middle East', 687630), ('South America', 593121), ('North America', 
 661157), ('Western Europe', 387933)])]
  
 In both cases, all records that meet the 
 WHERE
  condition are affected. If we don’t
  
 include a 
 WHERE
  condition, then all rows in the database are updated or removed.
  
 Of course, we can always put records back into the database:
  
 >>>
  cur.execute(
 'INSERT INTO PopByRegion VALUES (""Japan"", 100562)'
 )
  
 To remove an entire table from the database, we can use the 
 DROP
  command:
  
 DROP TABLE
  TableName
  
 report erratum  •  discuss",NA
Using NULL for Missing Data,"In the real world, we often don’t have all the data we want. We might be missing the 
 time at which an experiment was performed or the postal code of a patient being given 
 a new kind of treatment. Rather than leave what we 
 do
  know out of the database, we 
 may choose to insert it and use the value 
 NULL
  to represent the missing values. For 
 example, if there is a region whose population we don’t know, we could insert this into 
 our database:
  
 >>>
  cur.execute(
 'INSERT INTO PopByRegion VALUES (""Mars"", NULL)'
 )
  
 On the other hand, we probably don’t ever want a record in the database that has a 
 NULL
  region name. We can prevent this from ever happening, stating that the column is 
 NOT NULL
  when the table is created:
  
 >>>
  cur.execute(
 'CREATE TABLE Test (Region TEXT NOT NULL, ' 
 ... 
  
 'Population 
 INTEGER)'
 )
  
 Now when we try to insert a 
 NULL
  region into our new 
 Test
  table, we get an error 
 message:
  
 >>>
  cur.execute(
 'INSERT INTO Test VALUES (NULL, 456789)'
 ) 
 Traceback (most 
 recent call last): 
  
 File ""<pyshell
 #45>"", line 1, in <module> 
  
   
 cur.execute('INSERT INTO Test VALUES (NULL, 456789)') 
 sqlite3.IntegrityError: Test.Region may not be NULL
  
 Stating that the value must not be 
 NULL
  is not always necessary, and imposing such a 
 constraint may not be reasonable in some cases. Rather than using 
 NULL
 , it may 
 sometimes be more appropriate to use the value zero, an empty string, or 
 false
 . You 
 should do so in cases where you know something about the data and use 
 NULL
  only in 
 cases where you know nothing at all about it.
  
 In fact, some experts recommend not using 
 NULL
  at all because its behavior is 
 counterintuitive (at least until you’ve retrained your intuition). The general rule is that 
 operations involving 
 NULL
  produce 
 NULL
  as a result; the reasoning is that if the 
 computer doesn’t know what one of the operation’s inputs is, it can’t know what the 
 output is either. Adding a number to 
 NULL
  therefore
  
 report erratum  •  discuss",NA
Using Joins to Combine Tables,"When designing a database, it often makes sense to divide data between two or more 
 tables. For example, if we are maintaining a database of patient records, we would 
 probably want at least four tables: one for the patient’s personal information (such as 
 name and date of birth), a second to keep track of appointments, a third for 
 information about the doctors who are treating the patient, and a fourth for 
 information about the hospitals or clinics those doctors work at.
  
 Appointment 
  
 Patient
  
 patient 
  
 name 
  
 doctor 
  
 birthday 
  
 date
  
 Hospital 
  
 Doctor
  
 name 
  
 name 
  
 address 
  
 hospital
  
 We could store all of this in one table, but then a lot of information would be needlessly 
 duplicated as shown in the 
 image on page 354
 .
  
 report erratum  •  discuss",NA
Keys and Constraints,"Our query in the previous section relied on the fact that our regions and
  
 countries were uniquely identified by their names. A column in a table that
  
 is used this way is called a 
 key
 . Ideally, a key’s values should be unique, just
  
 like the keys in a dictionary. We can tell the database to enforce this constraint
  
 by adding a 
 PRIMARY KEY
  clause when we create the table. For example, when
  
 we created the 
 PopByRegion
  table, we should have specified the primary key:
  
 >>>
  cur.execute(
 ''
 'CREATE TABLE PopByRegion ( 
  
 Region TEXT NOT NULL, 
  
 Population INTEGER NOT NULL, 
  
 PRIMARY KEY (Region))''')
  
 Just as a key in a dictionary can be made up of multiple values, the primary
  
 key for a database table can consist of multiple columns.
  
 report erratum  •  discuss",NA
Advanced Features,"The SQL we have seen so far is powerful enough for many everyday tasks, but other 
 questions require more powerful tools. This section introduces a handful and shows 
 when and how they are useful.
  
 Aggregation
  
 Our next task is to calculate the total projected world population for the year 2300. We 
 will do this by adding up the values in 
 PopByRegion
 ’s 
 Population
  column using the SQL 
 aggregate
  function 
 SUM
 :
  
 >>>
  cur.execute(
 'SELECT SUM (Population) FROM PopByRegion'
 ) 
 <sqlite3.Cursor 
 object at 0x102e3e490> 
  
 >>>
  cur.fetchone() 
  
 (8965762,)
  
 SQL provides several other aggregate functions (see 
 Table 33, 
 Aggregate Functions
 , on page 
 359
 ). All of these are 
 associative
 ; that is, the result doesn’t depend on the order of 
 operations. This ensures that the result doesn’t depend on the order in which records are 
 pulled out of tables.
  
 Addition and multiplication are associative, since 
 1 + (2 + 3)
  produces the same results 
 as 
 (1 + 2) + 3
 , and 
 4 * (5 * 6)
  produces the same result as 
 (4 * 5) * 6
 . By contrast, subtraction 
 isn’t associative: 
 1 - (2 - 3)
  is not the same thing as 
 (1 - 2) - 3
 . Notice that there isn’t a 
 subtraction aggregate function.
  
 report erratum  •  discuss",NA
-,"Eastern Asia
  
 (SELECT DISTINCT Region
  
  FROM            PopByCountry",NA
=,"WHERE           (PopByCountry.Population = 8764))
  
  
 North America
  
 >>>
  cur.execute(
 ''
 ' 
  
 SELECT DISTINCT Region 
  
 FROM PopByCountry 
  
 WHERE (PopByCountry.Population = 8764) 
  
 ''') 
  
 <sqlite3.Cursor object at 0x102e3e490> 
  
 >>>
  cur.fetchall() 
  
 [('Eastern Asia',)
  
 Now we want to get the names of regions that were not in the results of our
  
 first query. To do this, we will use a 
 WHERE
  condition and 
 NOT IN
 :
  
 >>>
  cur.execute(
 ''
 ' 
  
 SELECT DISTINCT Region 
  
 FROM PopByCountry 
  
 WHERE Region NOT IN 
  
  
 (SELECT DISTINCT Region 
  
  
  
 FROM PopByCountry 
  
  
  
 WHERE (PopByCountry.Population = 8764)) 
  
 ''') 
  
 <sqlite3.Cursor object at 0x102e3e490> 
  
 >>>
  cur.fetchall() 
  
 [('North America',)]
  
 This time we got what we were looking for. Nested queries are often used for
  
 situations like this one, where negation is involved.
  
 Transactions
  
 A 
 transaction
  is a sequence of database operations that are interdependent.
  
 No operation in a transaction can be committed unless every single one can
  
 be successfully committed in sequence. For example, if an employer is paying
  
 an employee, there are two interdependent operations: withdrawing funds
  
 from the employer’s account and depositing funds in the employee’s account.",NA
Some Data Based On What You Learned,"In this chapter, you learned the following:
  
 • Most large applications store information in relational databases. A database is 
 made up of tables, each of which stores logically related information. A table has 
 one or more columns—each of which has a name and a type—and zero or more 
 rows, or records. In most tables, each row can be identified by a unique key, which 
 consists of one or more of the values in the row.
  
 • Commands to put data into databases, or to get data out, can be written in a 
 specialized language called SQL.
  
 • SQL commands can be sent to databases interactively from GUIs or command-line 
 tools—but for larger jobs, it is more common to write pro-grams that create SQL 
 and process the results.
  
 • Changes made to a database don’t actually take effect until they are committed. 
 This ensures that if two or more programs are working with a database at the 
 same time, it will always be in a consistent state. How-ever, it also means that 
 operations in one program can fail because of something that another program is 
 doing.
  
 • SQL queries must specify the table(s) and column(s) that values are to be taken 
 from. They may also specify Boolean conditions those values must satisfy and the 
 ordering of results.
  
 report erratum  •  discuss",NA
Exercises,"Here are some exercises for you to try on your own. Solutions are available at 
 http://pragprog.com/titles/gwpy3/practical-programming
 .
  
 1. 
  
 In this exercise, you will create a table to store the population and land 
  
 area 
 of the Canadian provinces and territories according to the 2001 
  
 census. Our data is 
 taken from 
 http://www12.statcan.ca/english/census01/home/ 
  
 index.cfm
 .
  
 Province/Territory
  
 Population
  
 Land Area
  
 Newfoundland and Labrador
  
 512930
  
 370501.69
  
 Prince Edward Island
  
 135294
  
 5684.39
  
 Nova Scotia
  
 908007
  
 52917.43
  
 New Brunswick
  
 729498
  
 71355.67
  
 Quebec
  
 7237479
  
 1357743.08
  
 Ontario
  
 11410046
  
 907655.59
  
 Manitoba
  
 1119583
  
 551937.87
  
 Saskatchewan
  
 978933
  
 586561.35
  
 Alberta
  
 2974807
  
 639987.12
  
 British Columbia
  
 3907738
  
 926492.48
  
 Yukon Territory
  
 28674
  
 474706.97
  
 Northwest Territories
  
 37360
  
 1141108.37
  
 Nunavut
  
 26745
  
 1925460.18
  
 Table 34—2001 Canadian Census Data
  
 Write Python code that does the following:
  
 a. 
  
 Creates a new database called 
 census.db
  
 b. 
  
 Makes a database table called 
 Density
  that will hold the name of the 
  
 province or territory (
 TEXT
 ), the population (
 INTEGER
 ), and the land area 
  
 (
 REAL
 )
  
 report erratum  •  discuss",NA
Bibliography,"[DEM02] 
  
 Allen Downey, Jeff Elkner, and Chris Meyers. 
 How to Think Like a Computer
  
 Scientist: Learning with Python
 . Green Tea Press, Needham, MA, 2002.
  
 [GE13] 
  
 Mark J. Guzdial and Barbara Ericson. 
 Introduction to Computing and Pro-
  
 gramming in Python: A Multimedia Approach
 . Prentice Hall, Englewood
  
 Cliffs, NJ, Third, 2013.
  
 [GL07] 
  
 Michael H. Goldwasser and David Letscher. 
 Object-Oriented Programming
  
 in Python
 . Prentice Hall, Englewood Cliffs, NJ, 2007.
  
 [Hoc04] 
  
 Roger R. Hock. 
 Forty Studies That Changed Psychology
 . Prentice Hall,
  
 Englewood Cliffs, NJ, 2004.
  
 [Hyn06] 
  
 R. J. Hyndman. 
 Time Series Data Library
 . http://www.robjhyndman.com,
  
 http://www.robjhyndman.com, 2006.
  
 [Lak76] 
  
 Imre Lakatos. 
 Proofs and Refutations
 . Cambridge University Press, Cam-
  
 bridge, United Kingdom, 1976.
  
 [Lut13] 
  
 Mark Lutz. 
 Learning Python
 . O’Reilly & Associates, Inc., Sebastopol, CA,
  
 Fifth, 2013.
  
 [Pyt11] 
  
 Python EDU-SIG. 
 Python Education Special Interest Group (EDU-SIG)
 . Python
  
 EDU-SIG, http://www.python.org/community/sigs/current/edu-sig, 2011.
  
 [Win06] 
  
 Jeannette M. Wing. Computational Thinking. 
 Communications of the ACM
 .
  
 49[3]:33–35, 2006.
  
 [Zel03] 
  
 John Zelle. 
 Python Programming: An Introduction to Computer Science
 .
  
 Franklin Beedle & Associates, Wilsonville, OR, 2003.
  
 report erratum  •  discuss",NA
Index,"SYMBOLS
  
 in function definition, 
 38
  
 <
  (less than), relational opera-
  
 in 
 if
  statements, 
 86
  
 tor, 
 80
 , 
 350
  
 &
  (ampersand), set intersec-
  
 in list slices, 
 138
  
 <=
  (less than or equal to)
  
 tion, 
 207
  
 in for loops, 
 150
  
 relational operator, 
 80
 , 
  
 >>>
  (angle bracket, triple)
  
 in while loops, 
 160
  
 350
  
 prompt, IDLE, 
 9
  
 ,
  (comma), indicating tuples,
  
 set subset operator, 
 207
  
 *
  (asterisk)
  
 210
 , 
 213
  
 -
  (minus sign)
  
 multiplication operator,
  
 =
  (equal sign)
  
 negation operator, 
 12
 , 
 15
  
 10
 , 
 15
 , 
 136
  
 assignment operator, 
 16
 , 
  
 set difference, 
 207
  
 string repeat operator, 
 68
  
 18
  
 subtraction operator, 
 10
 , 
  
 **
  (asterisk, double) exponen-
  
 equal to operator, in
  
 15
  
 tiation operator, 
 12
  
 queries, 
 350
  
 -=
  (minus sign, equal sign),
  
 **=
  (asterisk, double, equal
  
 ==
  (equal sign, double) equal
  
 subtraction assignment op-
  
 sign) exponentiation assign-
  
 to operator, 
 80
  
 erator, 
 22
  
 ment operator, 
 22
  
 !=
  (exclamation, equal sign)
  
 ()
  (parentheses)
  
 *=
  (asterisk, equal sign), mul-
  
 not equal to operator, 
 80
 , 
  
 about, 
 5
  
 tiplication assignment oper-
  
 350
  
 enclosing tuples, 
 210
  
 ator, 
 22
  
 / (forward slash)
  
 function call, 
 31
  
 \ (backslash)
  
 directory separator, 
 177
  
 function definition, 
 38
  
 division operator, 
 10
 , 
 15
  
 line breaks within, 
 24
  
 directory separator, 
 177
  
 overriding precedence, 
 15
  
 escape character, 
 69
  
 //
  (forward slash, double) inte-
  
 line-continuation charac-
  
 %
  (percent sign) modulo oper-
  
 ger division operator, 
 11
 , 
  
 ter, 
 24
  
 ator, 
 11
 , 
 15
  
 15
  
 {}
  (braces)
  
 %=
  (percent sign, equal sign)
  
 //=
  (forward slash, double,
  
 about, 
 5
  
 equal sign) integer division
  
 modulo assignment opera-
  
 enclosing dictionaries,
  
 assignment operator, 
 22
  
 tor, 
 22
  
 216
  
 . (period) dot operator, 
 101
  
 /=
  (forward slash, equal sign),
  
 enclosing sets, 
 203
  
 division assignment opera-
  
 .. (period, double) directory
  
 []
  (brackets)
  
 tor, 
 22
  
 up one level, 
 178
  
 about, 
 5
  
 >
  (greater than), relational
  
 ...
  (period, triple) prompt,
  
 enclosing dictionary keys,
  
 operator, 
 80
 , 
 350
  
 continuation, 
 24
  
 216
  
 >=
  (greater than or equal to)
  
 +
  (plus sign)
  
 enclosing lists, 
 130
 , 
 132
  
 relational operator, 
 80
 , 
  
 addition operator, 
 9
 , 
 15
  
 ^
  (caret), set symmetric differ-
  
 350
  
 concatenation operator,
  
 ence, 
 207
  
 set superset operator,
  
 66
 , 
 136
 , 
 142
  
 : (colon)
  
 207
  
 +=
  (plus sign, equal sign), ad-
  
 in dictionaries, 
 216
  
 #
  (hash mark) comment sym-
  
 dition assignment operator,
  
 in field numbers, 
 122
  
 bol, 
 26
  
 22",NA
"More Python, More Exercises ","Learn how to properly test your Python code, and strengthen your skills with these coding challenges.",NA
Python Testing with pytest,"Do less work when testing your Python code, but be just as 
 expressive, just as elegant, and just as readable.
  
 The pytest testing framework helps you write tests quickly 
 and keep them readable and maintain-
  
 able—with no boilerplate code. Using a robust yet simple 
 fixture model, it’s just as easy to write small tests with pytest 
 as it is to scale up to complex func-tional testing for 
 applications, packages, and libraries. This book shows you 
 how.
  
 Brian Okken 
  
 (220 pages) 
 ISBN
 : 9781680502404. $43.95 
 https://pragprog.com/book/bopytest",NA
Exercises for Programmers,"When you write software, you need to be at the top of your 
 game. Great programmers practice to keep their skills sharp. 
 Get sharp and stay sharp with more than fifty practice 
 exercises rooted in real-world scenarios. If you’re a new 
 programmer, these challenges will help you learn what you 
 need to break into the field, and if you’re a seasoned pro, you 
 can use these exercises to learn that hot new language for 
 your next gig.
  
 Brian P. Hogan 
  
 (118 pages) 
 ISBN
 : 9781680501223. $24 
 https://pragprog.com/book/bhwb",NA
Level Up ,"From data structures to architecture and design, we have what you need.",NA
A Common-Sense Guide to Data ,NA,NA
Structures and Algorithms,"If you last saw algorithms in a university course or at a job 
 interview, you’re missing out on what they can do for your 
 code. Learn different sorting and searching techniques, and 
 when to use each. Find out how to use recursion effectively. 
 Discover structures for spe-cialized applications, such as 
 trees and graphs. Use Big O notation to decide which 
 algorithms are best for your production environment. 
 Beginners will learn how to use these techniques from the 
 start, and experienced developers will rediscover approaches 
 they may have forgotten.
  
 Jay Wengrow 
  
 (218 pages) 
 ISBN
 : 9781680502442. $45.95 
 https://pragprog.com/book/jwdsal",NA
Design It!,"Don’t engineer by coincidence—design it like you mean it! 
 Grounded by fundamentals and filled with practical design 
 methods, this is the perfect introduction to software 
 architecture for programmers who are ready to grow their 
 design skills. Ask the right stakeholders the right questions, 
 explore design options, share your design decisions, and 
 facilitate collaborative workshops that are fast, effective, and 
 fun. Become a better pro-grammer, leader, and designer. Use 
 your new skills to lead your team in implementing software 
 with the right capabilities—and develop awesome software!
  
 Michael Keeling 
  
 (358 pages) 
 ISBN
 : 9781680502091. $41.95 
 https://pragprog.com/book/mkdsa",NA
Long Live the ,NA,NA
Command Line! ,"Use tmux and Vim 
 for incredible mouse-free productivity.",NA
tmux 2,"Your mouse is slowing you down. The time you spend context 
 switching between your editor and your con-soles eats away 
 at your productivity. Take control of your environment with 
 tmux, a terminal multiplexer that you can tailor to your 
 workflow. With this updated second edition for tmux 2.3, 
 you’ll customize, script, and leverage tmux’s unique abilities 
 to craft a produc-tive terminal environment that lets you 
 keep your fin-gers on your keyboard’s home row.
  
 Brian P. Hogan 
  
 (102 pages) 
 ISBN
 : 9781680502213. $21.95 
 https://pragprog.com/book/bhtmux2",NA
Modern Vim,"Turn Vim into a full-blown development environment using 
 Vim 8’s new features and this sequel to the beloved bestseller 
 Practical Vim
 . Integrate your editor with tools for building, 
 testing, linting, indexing, and searching your codebase. 
 Discover the future of Vim with Neovim: a fork of Vim that 
 includes a built-in terminal emulator that will transform your 
 workflow. Whether you choose to switch to Neovim or stick 
 with Vim 8, you’ll be a better developer.
  
 Drew Neil 
  
 (190 pages) 
 ISBN
 : 9781680502626. $39.95 
 https://pragprog.com/book/modvim",NA
The Modern Web ,"Get up to speed on the latest HTML, CSS, and JavaScript techniques, and secure your Node applications.",NA
HTML5 and CSS3 (2nd edition),"HTML5 and CSS3 are more than just buzzwords –they’re the 
 foundation for today’s web applications. This book gets you 
 up to speed on the HTML5 elements and CSS3 features you 
 can use right now in your cur-rent projects, with backwards 
 compatible solutions that ensure that you don’t leave users of 
 older browsers behind. This new edition covers even more 
 new fea-tures, including CSS animations, IndexedDB, and 
 client-side validations.
  
 Brian P. Hogan 
  
 (314 pages) 
 ISBN
 : 9781937785598. $38 
 https://pragprog.com/book/bhh52e",NA
Secure Your Node.js Web Application,"Cyber-criminals have your web applications in their 
 crosshairs. They search for and exploit common secu-rity 
 mistakes in your web application to steal user data. Learn 
 how you can secure your Node.js applications, database and 
 web server to avoid these security holes. Discover the 
 primary attack vectors against web appli-cations, and 
 implement security best practices and effective 
 countermeasures. Coding securely will make you a stronger 
 web developer and analyst, and you’ll protect your users.
  
 Karl Düüna 
  
 (230 pages) 
 ISBN
 : 9781680500851. $36 
 https://pragprog.com/book/kdnodesec",NA
Kick your Career up a Notch ,"Ready to blog or promote yourself for real? Time to refocus your personal priorities? We’ve got you 
 covered.",NA
Technical Blogging,"Technical Blogging
  is the first book to specifically teach 
 programmers, technical people, and technically-orient-ed 
 entrepreneurs how to become successful bloggers.
  
 There is no magic to successful blogging; with this book you’ll 
 learn the techniques to attract and keep a large audience of 
 loyal, regular readers and leverage this popularity to achieve 
 your goals.
  
 Antonio Cangiano 
  
 (288 pages) 
 ISBN
 : 9781934356883. $33 
 https://pragprog.com/book/actb",NA
New Programmer’s Survival Manual,"It’s your first day on the new job. You’ve got the pro-
 gramming chops, you’re up on the latest tech, you’re sitting at 
 your workstation… now what? 
 New Program-mer’s Survival 
 Manual
  gives your career the jolt it needs to get going: 
 essential industry skills to help you apply your raw 
 programming talent and make a name for yourself. It’s a no-
 holds-barred look at what 
 really
  goes on in the office—and 
 how to not only survive, but thrive in your first job and 
 beyond.
  
 Josh Carter 
  
 (256 pages) 
 ISBN
 : 9781934356814. $29 
 https://pragprog.com/book/jcdeg",NA
Seven in Seven ,"You need to learn at least one new language every year. Here are fourteen excellent sugges-tions to get 
 started.",NA
Seven Languages in Seven Weeks,"You should learn a programming language every year, as 
 recommended by 
 The Pragmatic Programmer
 . But if one per 
 year is good, how about 
 Seven Languages in Seven Weeks
 ? In 
 this book you’ll get a hands-on tour of Clojure, Haskell, Io, 
 Prolog, Scala, Erlang, and Ruby. Whether or not your favorite 
 language is on that list, you’ll broaden your perspective of 
 programming by examining these languages side-by-side. 
 You’ll learn something new from each, and best of all, you’ll 
 learn how to learn a language quickly.
  
 Bruce A. Tate 
  
 (330 pages) 
 ISBN
 : 9781934356593. $34.95 
 https://pragprog.com/book/btlang",NA
Seven More Languages in Seven Weeks,"Great programmers aren’t born—they’re made. The industry 
 is moving from object-oriented languages to functional 
 languages, and you need to commit to radi-cal improvement. 
 New programming languages arm you with the tools and 
 idioms you need to refine your craft. While other language 
 primers take you through basic installation and “Hello, 
 World,” we aim higher.
  
 Each language in 
 Seven More Languages in Seven Weeks
  will 
 take you on a step-by-step journey through the most 
 important paradigms of our time. You’ll learn seven exciting 
 languages: Lua, Factor, Elixir, Elm, Julia, MiniKanren, and 
 Idris.
  
 Bruce Tate, Fred Daoud, Jack Moffitt, Ian Dees (318 
 pages) 
 ISBN
 : 9781941222157. $38 
  
 https://pragprog.com/book/7lang",NA
Seven in Seven ,"From Web Frameworks to Concurrency Models, see what the rest of the world is doing with this 
 introduction to seven different approaches.",NA
Seven Web Frameworks in Seven Weeks,"Whether you need a new tool or just inspiration, 
 Seven Web 
 Frameworks in Seven Weeks
  explores modern options, giving 
 you a taste of each with ideas that will help you create better 
 apps. You’ll see frameworks that leverage modern 
 programming languages, employ unique architectures, live 
 client-side instead of server-side, or embrace type systems. 
 You’ll see everything from familiar Ruby and JavaScript to the 
 more exotic Erlang, Haskell, and Clojure.
  
 Jack Moffitt, Fred Daoud 
  
 (302 pages) 
 ISBN
 : 9781937785635. $38 
 https://pragprog.com/book/7web",NA
Seven Concurrency Models in Seven Weeks,"Your software needs to leverage multiple cores, handle 
 thousands of users and terabytes of data, and continue 
 working in the face of both hardware and software failure. 
 Concurrency and parallelism are the keys, and 
 Seven 
 Concurrency Models in Seven Weeks
  equips you for this new 
 world. See how emerging technologies such as actors and 
 functional programming address issues with traditional 
 threads and locks development. Learn how to exploit the 
 parallelism in your computer’s GPU and leverage clusters of 
 machines with MapRe-duce and Stream Processing. And do it 
 all with the confidence that comes from using tools that help 
 you write crystal clear, high-quality code.
  
 Paul Butcher 
  
 (296 pages) 
 ISBN
 : 9781937785659. $38 
 https://pragprog.com/book/pb7con",NA
Put the “Fun” in Functional ,"Elixir puts the “fun” back into functional programming, on top of the robust, battle-tested, industrial-
 strength environment of Erlang.",NA
Programming Elixir 1.3,"Explore functional programming without the academic 
 overtones (tell me about monads just one more time).
  
 Create concurrent applications, but get them right without all 
 the locking and consistency headaches. Meet Elixir, a modern, 
 functional, concurrent language built on the rock-solid Erlang 
 VM. Elixir’s pragmatic syntax and built-in support for 
 metaprogramming will make you productive and keep you 
 interested for the long haul. Maybe the time is right for the 
 Next Big Thing. Maybe it’s Elixir. This book is 
 the
  introduction 
 to Elixir for experienced programmers, completely up-dated 
 for Elixir 1.3.
  
 Dave Thomas 
  
 (362 pages) 
 ISBN
 : 9781680502008. $38 
 https://pragprog.com/book/elixir13",NA
Programming Phoenix,"Don’t accept the compromise between fast and beauti-ful: 
 you can have it all. Phoenix creator Chris McCord, Elixir 
 creator José Valim, and award-winning author Bruce Tate 
 walk you through building an application that’s fast and 
 reliable. At every step, you’ll learn from the Phoenix creators 
 not just what to do, but why. Packed with insider insights, 
 this definitive guide will be your constant companion in your 
 journey from Phoenix novice to expert, as you build the next 
 gener-ation of web applications.
  
 Chris McCord, Bruce Tate, and José Valim (298 
 pages) 
 ISBN
 : 9781680501452. $34 
 https://pragprog.com/book/phoenix",NA
The Joy of Mazes and ,NA,NA
Math ,Rediscover the joy and fascinating weirdness of mazes and pure mathematics.,NA
Mazes for Programmers,"A book on mazes? Seriously?
  
 Yes!
  
 Not because you spend your day creating mazes, or 
 because you particularly like solving mazes.
  
 But because it’s fun. Remember when programming used to 
 be fun? This book takes you back to those days when you 
 were starting to program, and you wanted to make your code 
 do things, draw things, and solve puzzles. It’s fun because it 
 lets you explore and grow your code, and reminds you how it 
 feels to just think.
  
 Sometimes it feels like you live your life in a maze of twisty 
 little passages, all alike. Now you can code your way out.
  
 Jamis Buck 
  
 (286 pages) 
 ISBN
 : 9781680500554. $38 
 https://pragprog.com/book/jbmaze",NA
Good Math,"Mathematics is beautiful—and it can be fun and excit-ing as 
 well as practical. 
 Good Math
  is your guide to some of the most 
 intriguing topics from two thousand years of mathematics: 
 from Egyptian fractions to Tur-ing machines; from the real 
 meaning of numbers to proof trees, group symmetry, and 
 mechanical compu-tation. If you’ve ever wondered what lay 
 beyond the proofs you struggled to complete in high school 
 geom-etry, or what limits the capabilities of the computer on 
 your desk, this is the book for you.
  
 Mark C. Chu-Carroll 
  
 (282 pages) 
 ISBN
 : 9781937785338. $34 
 https://pragprog.com/book/mcmath",NA
Past and Present ,"To see where we’re going, remember how we got here, and learn how to take a healthier approach to 
 programming.",NA
Fire in the Valley,"In the 1970s, while their contemporaries were 
  
 protesting the computer as a tool of dehumanization and 
 oppression, a motley collection of college dropouts, hippies, 
 and electronics fanatics were engaged in something much 
 more subversive. Obsessed with the idea of getting computer 
 power into their own hands, they launched from their 
 garages a hobbyist movement that grew into an industry, and 
 ultimately a social and technological revolution. What they 
 did was invent the personal computer: not just a new device, 
 but a water-shed in the relationship between man and 
 machine. This is their story.
  
 Michael Swaine and Paul Freiberger (422 
 pages) 
 ISBN
 : 9781937785765. $34 
 https://pragprog.com/book/fsfire",NA
The Healthy Programmer,"To keep doing what you love, you need to maintain your own 
 systems, not just the ones you write code for. Regular 
 exercise and proper nutrition help you learn, remember, 
 concentrate, and be creative—skills critical to doing your job 
 well. Learn how to change your work habits, master exercises 
 that make working at a computer more comfortable, and 
 develop a plan to keep fit, healthy, and sharp for years to 
 come.
  
 This book is intended only as an informative guide for those 
 wishing to know more about health issues. In no way is this 
 book intended to replace, countermand, or conflict with the 
 advice given to you by your own 
  
 healthcare provider including Physician, Nurse Practi-tioner, 
 Physician Assistant, Registered Dietician, and other licensed 
 professionals.
  
 Joe Kutner 
  
 (254 pages) 
 ISBN
 : 9781937785314. $36 
 https://pragprog.com/book/jkthp",NA
The Pragmatic Bookshelf,"The Pragmatic Bookshelf features books written by developers for developers. The titles
  
 continue the well-known Pragmatic Programmer style and continue to garner awards and
  
 rave reviews. As development gets more and more difficult, the Pragmatic Programmers will
  
 be there with more titles and products to help you stay on top of your game.",NA
Visit Us Online,"This Book’s Home Page
  
 https://pragprog.com/book/gwpy3
  
 Source code from this book, errata, and other resources. Come give us feedback, too!
  
 Register for Updates
  
 https://pragprog.com/updates
  
 Be notified when updates and new books become available.
  
 Join the Community
  
 https://pragprog.com/community
  
 Read our weblogs, join our online discussions, participate in our mailing list, interact with
  
 our wiki, and benefit from the experience of other Pragmatic Programmers.
  
 New and Noteworthy
  
 https://pragprog.com/news
  
 Check out the latest pragmatic developments, new titles and other offerings.",NA
Buy the Book,"If you liked this eBook, perhaps you’d like to have a paper copy of the book. It’s available
  
 for purchase at our store: 
 https://pragprog.com/book/gwpy3",NA
Contact Us,"Online Orders: 
  
 https://pragprog.com/catalog
  
 Customer Service: 
  
 support@pragprog.com
  
 International Rights: 
  
 translations@pragprog.com
  
 Academic Use: 
  
 academic@pragprog.com
  
 Write for Us: 
  
 http://write-for-us.pragprog.com
  
 Or Call: 
  
 +1 800-699-7764",NA
