Larger Text,Smaller Text,Symbol
Algorithmic Problem Solving with Python,NA,NA
John B. Schneider,NA,NA
Shira Lynn Broschat,NA,NA
Jess Dahmen,NA,NA
22-Feb-19,NA,NA
Contents,"1
  
 Introduction
  
 1
  
 2
  
 1.1
  
 Modern Computers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
 1.2
  
 Computer Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2
  
 1.3
  
 Pytho
 n
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.4
  
 Algorithmic Problem Solving . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 1.5
  
 Obtaining Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 1.6
  
 Running Python
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 1.6.1
  
 Interactive Sessions and Comments . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 1.6.2
  
 Running Commands from a File . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 1.7
  
 Bugs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 12
  
 1.8
  
 The
  help()
  Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 1.9
  
 Comments on Learning New Languages . . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 1.10 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 1.11 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 Core Basics
  
 19
  
 3
  
 2.1
  
 Literals and 
 Types
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 2.2
  
 Expressions, Arithmetic Operators, and Precedence . . . . . . . . . . . . . . . . .
  
 22
  
 2.3
  
 Statements and the Assignment 
 Operator
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 2.4
  
 Cascaded and Simultaneous 
 Assignment
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 27
  
 2.5
  
 Multi-Line Statements and Multi-Line Strings . . . . . . . . . . . . . . . . . . . .
  
 29
  
 2.6
  
 Identifiers and Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 30
  
 2.7
  
 Names and 
 Namespaces
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 32
  
 2.8
  
 Additional Arithmetic Operators . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 2.8.1
  
 Exponentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 2.8.2
  
 Floor Division
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 2.8.3
  
 Modulo and
  divmod()
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 38
  
 2.8.4
  
 Augmented Assignment
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 40
  
 2.9
  
 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 42
  
 2.10 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 43
  
 2.11 Exercises
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 49
  
 Input and Type Conversion
  
 51
  
 3.1
  
 Obtaining Input:
  input()
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 51
  
 3.2
  
 Explicit Type Conversion:
  int()
 ,
  float()
 , and
  str()
  . . . . . . . . . . . . .
  
 53
  
 iii",NA
Chapter 1,NA,NA
Introduction,NA,NA
1.1,NA,NA
Modern Computers,"At their core, computers are remarkably simple devices. Nearly all computers today are 
 built using electronic devices called transistors. These transistors serve as switches that 
 behave much like simple light switches—they can be on or they can be off. In a digital 
 computer each
  bit
  of information (whether input, memory, or output) can be in only one of 
 two states: either off or on, or we might call these states low or high, or perhaps zero or 
 one. When we say “bit,” we have in mind the technical definition. A bit is a
  b
 inary dig
 it
  that 
 can be either 0 or 1 (zero or one). In a very real sense computers only “understand” these 
 two numbers. However, by combining thousands or millions or even billions of these 
 transistor switches we can achieve fantastically complicated behavior. Thus, rather than 
 keeping track of a single binary digit, with computers we may be able to work with a 
 stream of bits of arbitrary length.
  
 For each additional bit we use to represent a quantity, we double the number of 
 possible unique values the quantity can have. One bit can represent only two “states” or 
 values: 0 and 1. This may seem extremely limiting, but a single bit is enough to represent 
 whether the answer to a question is yes or no or a single bit can be used to tell us whether a 
 logical statement evaluates to either true or false. We merely have to agree to interpret 
 values consistently, for example, 0 represents no or false while 1 represents yes or true. 
 Two bits can represent four states which we can write as: 00, 01, 10, and 11 (read this as 
 zero-zero, zero-one, one-zero, one-one). Three bits have eight unique combinations or 
 values: 000, 001, 010, 011, 100, 101, 110, and 111. In general, for
  n
  bits the number of 
 unique values is 2
 n
 .
  
 For
  n
  = 7 bits, there are 2
 7
 = 128 unique values. This is already more than the number of 
 all the keys on a standard keyboard, i.e., more than all the letters in the English alphabet 
 (both uppercase and lowercase), plus the digits (0 through 9), plus all the standard 
 punctuation marks. So, by using a mapping (or
  encoding
 ) of keyboard characters to unique 
 combinations of binary digits, we can act as though we are working with characters when, 
 really, we are doing nothing more than manipulating binary numbers.
  
 We can also take values from the (real) continuous world and “digitize” them. Rather 
 than having values such as the amplitude of a sound wave or the color of an object vary 
 continuously, we restrict the amplitude or color to vary between fixed values or levels. This 
 process is also known
  
 From the file: intro.tex",NA
1.2,NA,NA
Computer Languages,"Computers, though remarkably simple at their core, have, nevertheless, truly 
 revolutionized the way we live. They have enabled countless advances in science, 
 engineering, and medicine. They have affected the way we exchange information, how we 
 socialize, how we work, and how we play. To a large degree, these incredible advances have 
 been made possible through the development of new “languages” that allow humans to tell 
 a computer what it should do. These so-called
  computer languages
  provide a way for us to 
 express what we want done in a way that is more natural to the way we think and yet 
 precise enough to control a computer.
  
 We, as humans, are also phenomenal computing devices, but the way we think and 
 communi-cate is generally a far cry from the way computers “think” and communicate. 
 Computer languages provide a way of bridging this gap. But, the gap between computers 
 and humans is vast and, for those new to computer programming, these languages can 
 often be tremendously challenging to master. There are three important points that one 
 must keep in mind when learning computer languages.
  
 First, these languages are
  not
  designed to provide a means for having a two-way dialog 
 with a computer. These languages are more like “instruction sets” where the human 
 specifies what the computer should do. The computer blindly follows these instructions. In 
 some sense, computer languages provide a way for humans to communicate
  to
  computers 
 and with these languages we also have to tell the computers how we want them to 
 communicate back to us (and it is extremely rare that we want a computer to communicate 
 information back to us in the same language we used to communicate to it).
  
 Second, unlike with natural languages
 1
 , there is no ambiguity in a computer language. 
 State-ments in natural languages are often ambiguous while also containing redundant or 
 superfluous content. Often the larger context in which a statement is made serves to 
 remove the ambiguity while the redundant content allows us to make sense of a statement 
 even if we miss part of it. As you will see, there may be a host of different ways to write 
 statements in a computer language that ultimately lead to the same outcome.
  However
 , the 
 path by which an outcome is reached is precisely determined by the 
 statements/instructions that are provided to the computer. Note that we will often refer to 
 statements in a computer language as “computer code” or simply “code.”
 2 
 We will call a 
 collection of statements that serves to complete a desired task a
  program
 .
 3 
 The third 
 important point about computer languages is that a computer can never infer meaning or 
 intent. You may have a very clear idea of what you want a computer to do, but if you do not 
 ex-plicitly state your desires using precise
  syntax
  and
  semantics
 , the chances of obtaining 
 the desired outcome are exceedingly small. When we say syntax, we essentially mean the 
 rules of grammar
  
 1
 By natural languages we mean languages that humans use with each other.",NA
1.3,NA,NA
Python,"There are literally thousands of computer languages. There is no single computer language 
 that can be considered the best. A particular language may be excellent for tackling 
 problems of a certain type but be horribly ill-suited for solving problems outside the 
 domain for which it was designed. Nevertheless, the language we will study and use, 
 Python, is unusual in that it does so many things and does them so well. It is relatively 
 simple to learn, it has a rich set of features, and it is quite expressive (so that typically just a 
 few lines of code are required in order to accomplish what would take many more lines of 
 code in other languages). Python is used throughout academia and industry. It is very much 
 a “real” computer language used to address problems on the cutting edge of science and 
 technology. Although it was not designed as a language for teaching computer 
 programming or algorithmic design, Python’s syntax and idioms are much easier to learn 
 than those of most other full-featured languages.
  
 When learning a new computer language, one typically starts by considering the code 
 required to make the computer produce the output “Hello World!”
 5
 With Python we must 
 pass our code through the Python
  interpreter
 , a program that reads our Python statements 
 and acts in accordance with these statements (more will be said below about obtaining and 
 running Python). To have Python produce the desired output we can write the statement 
 shown in Listing 1.1.
  
 4
 The computer language we will use, Python, is not like this. Typically Python programs are executed as 
 the lines of code are read, i.e., it is an
  interpreted
  language. Thus, egregious syntactic bugs may be present in 
 the program and yet the program may run properly if, because of the flow of execution, the flawed statements 
 are not executed. On the other hand, if a bug is in the flow of execution in a Python program, generally all the",NA
1.4,NA,NA
Algorithmic Problem Solving,"A computer language provides a way to tell a computer what we want it to do. We can 
 consider a computer language to be a technology or a tool that aids us in constructing a 
 solution to a problem or accomplishing a desired task. A computer language is not 
 something that is timeless. It is exceedingly unlikely that the computer languages of today 
 will still be with us 100 years from now (at least not in their current forms). However, at a 
 more abstract level than the code in a particular language is the
  algorithm
 . An algorithm is 
 the set of rules or steps that need to be followed to perform a calculation or solve a 
 particular problem. Algorithms can be rather timeless. For example, the algorithm for 
 calculating the greatest common denominator of two integers dates back thousands of 
 years and will probably be with us for thousands of years more. There are efficient 
 algorithms for sorting lists and performing a host of other tasks. The degree to which these",NA
1.5,NA,NA
Obtaining Python,"Python is open-source software available for free. You can obtain the latest version for 
 Linux/Unix, Macintosh, and Windows via the download page at
  python.org
 . As of this 
 writing, the current version of Python is 3.2.2. You should install this (or a newer version if 
 one is available). There is also a 2.x version of Python that is actively maintained and 
 available for download, but it is not compatible with Python 3.x and, thus, you should not 
 install it.
 11
 Mac and Linux machines typically ship with Python pre-installed but it is usually 
 version 2.x. Because this book is for version 3.x of Python, you must have a 3.x version of 
 Python.
  
 Computer languages provide a way of describing what we want the computer to do. 
 Differ-ent implementations may exist for translating statements in a computer language 
 into something that actually performs the desired operations on a given computer. There 
 are actually several dif-",NA
1.6,NA,NA
Running Python,"With Python we can use interactive sessions in which we enter statements one at a time 
 and the interpreter acts on them. Alternatively, we can write all our commands, i.e., our 
 program, in a file that is stored on the computer and then have the interpreter act on that 
 stored program. In this case some compilation may be done behind the scenes, but Python 
 will still not typically provide speeds comparable to a true compiled language.
 13
 We will 
 discuss putting programs in files in Sec. 1.6.2. First, we want to consider the two most 
 common forms of interactive sessions for the Python interpreter.
  
 Returning to the statements in Listing 1.3, if they are entered in an interactive session, it 
 is difficult to observe the behavior that was described for that listing because the print() 
 state-ments have to be entered one at a time and output will be produced immediately 
 after each entry. In Python we can have multiple statements on a single line if the 
 statements are separated by a semicolon. Thus, if you want to verify that the code in Listing 
 1.3 is correct, you should enter it as shown in Listing 1.5.
  
 12
 Compiled languages, such as C++ and Java, typically have an advantage in speed over interpreted 
 languages such as Python. When speed is truly critical in an application, it is unlikely one would want to use 
 Python. However, in most applications Python is “fast enough.” Furthermore, the time required to develop a 
 program in Python is typically much less than in other languages. This shorter development time can often 
 more than compensate for the slower run-time. For example, if it takes one day to write a program in Python 
 but a week to write it in Java, is it worth the extra development time if the program takes one second to run in 
 Java but two seconds to run in Python? Sometimes the answer to this is definitely yes, but this is more the 
 exception rather than the rule. Although it is beyond the scope of this book, one can create programs that use 
 Python together with code written in C. This approach can be used to provide execution speeds that exceed 
 the capabilities of programs written purely in Python.
  
 13
 When the CPython interpreter runs commands from a file for the first time, it compiles a “bytecode” 
 version of the code which is then run by the interpreter. The bytecode is stored in a file with a .pyc extension.",NA
1.6.1,NA,NA
Interactive Sessions and Comments,"When you install Python, an application called IDLE will be installed on your system. On a 
 Mac, this is likely to be in the folder /Applications/Python 3.2. On a Windows machine, 
 click the Start button in the lower left corner of the screen. A window should pop up. If you 
 don’t see any mention of Python, click All Programs. You will eventually see a large listing 
 of programs. There should be an entry that says Python 3.2. Clicking Python 3.2 will bring 
 up another list in which you will see IDLE (Python GUI) (GUI stands for Graphical User 
 Interface).
  
 IDLE is an integrated development environment (IDE). It is actually a separate program 
 that stands between us and the interpreter, but it is not very intrusive—the commands we 
 enter are still sent to the interpreter and we can obtain on-the-fly feedback. After starting 
 IDLE, you should see (after a bit of boilerplate information) the Python interactive prompt 
 which is three greater-than signs (>>>). At this point you are free to issue Python 
 commands. Listing 1.6 demonstrates how the window will appear after the code from 
 Listing 1.1 has been entered. For interactive sessions, programmer input will be shown in 
 bold
  Courier
  font although, as shown in subsequent listings, comments will be shown in a 
 slanted, orange
  Courier
  font.
  
 Listing 1.6
  An IDLE session with a Hello-World statement. Programmer input is shown in 
 bold. The information on the first three lines will vary depending on the version and system.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 Python 3.2.2 (v3.2.2:137e45f15c0b, Sep  
 3 2011, 17:28:59)  
 [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin  
 Type ""copyright"", ""credits"" or ""license()"" for more information. 
 >>>
  print
 (
 ""Hello World!""
 ) 
  
 Hello World! 
 >>>
  
  
 To execute the print() statement shown on line 4, one merely types in the statement as 
 shown and then hits the enter (or return) key.
  
 An alternative way of running an interactive session with the Python interpreter is via 
 the 
 command line
 .
 14
 To accomplish this on a Mac, go to the folder /Applications/Utilities 
 and open the application Terminal. After Terminal has started, type python3 and hit return.
  
 14
 IDLE is built using a graphics package known as tkinter which also comes with Python. When you use 
 tkinter graphics commands, sometimes they can interfere with IDLE so it’s probably best to open an 
 interactive session using the command line instead of IDLE.",NA
1.6.2,NA,NA
Running Commands from a File,"There are various ways you can store commands in a file and then have the Python 
 interpreter act on them. Here we will just consider how this can be done using IDLE. After 
 starting IDLE, the window that appears with the interactive prompt is titled Python Shell. 
 Go to the File menu and select New Window. Alternatively, on a Mac you can type 
 command-N, while on a Windows machine you would type control-N. Henceforth, when we 
 refer to a keyboard shortcut such as C-N, we mean command-N on a Mac and control-N 
 under Windows. The letter following “C-” will vary depending on the shortcut (although 
 this trailing letter will be written in uppercase, it is not necessary to press the shift key).
  
 After selecting New Window or typing C-N, a new window will appear with the title 
 Untitled. No interactive prompt appears. You can enter Python statements in this window 
 but the interpreter will not act on these statements until you explicitly ask it to. Once you 
 start typing in this window the title will change to *Untitled*. The asterisks indicate that the 
 contents of this window have changed since the contents were last saved to a file.
  
 Before we can run the statements in the window we opened, we must save the file. To 
 do this, either select Save from the File menu or type C-S. This will bring up a “Save” 
 window where you indicate the folder and the file name where you want the contents of 
 the window to be saved. Whatever file name you choose, you should save it with an 
 extension of “.py” which indicates this is a Python file. Once you have saved the file, the title 
 of the Window will change to reflect the new file name (and the folder where it is stored).
  
 Once the file has been saved, it can be run through the Python interpreter. To do this, 
 you can either go to the Run menu and select Run Module or you can type F5 (function key 
 5—on a Mac laptop you will have to hold down the fn key, too). To illustrate what happens 
 now, assume a programmer has entered and saved the two lines of code shown in Listing 
 1.9.
  
 Listing 1.9
  Two lines of code that we assume have been saved to a file via IDLE. (This code 
 is not entered directly in the interactive environment.)
  
  
 15
 If an
  expression
  is entered in the interactive environment, Python displays the result of the expression. 
 Expressions are discussed in Chap. 2.",NA
1.7,NA,NA
Bugs,"You should keep in mind that, for now, you cannot hurt your computer with any bugs or 
 errors you may write in your Python code. Furthermore, any errors you make will not 
 crash the Python interpreter. Later, when we consider opening or manipulating files, we 
 will want to be somewhat cautious that we don’t accidentally delete a file, but for now you 
 shouldn’t hesitate to experiment with code. If you ever have a question about whether 
 something will or won’t work, there is no harm in trying it out to see what happens.
  
 Listing 1.11 shows an interactive session in which a programmer wanted to find out 
 what would happen when entering modified versions of the Hello-World program. In line 2, 
 the programmer wanted to see if Print() could be use instead of print(). In line 7 the 
 programmer attempted to get rid of the parentheses. And, in line 13, the programmer tried 
 to do away with the quotation marks. Code that produces an error will generally be shown 
 in
  red
 .
  
 16
 Note that we will say “run the file” although it is more correct to say “run the program contained in the file.”",NA
1.8,NA,NA
The help() Function,"The Python interpreter comes with a help() function. There are two ways to use help(). 
 First, you can simply type help(). This will start the online help utility and the prompt will 
 change to help>. You then get help by typing the name of the thing you are interested in 
 learning about. Thus far we have only considered one built-in function: print(). Listing 1.12 
 shows the message provided for the print() function. To exit the help utility, type quit.
  
 Listing 1.12
  Information provided by the online help utility for the print() function.",NA
1.9,NA,NA
Comments on Learning New Languages,"When learning a new skill, it is often necessary to practice over and over again. This holds 
 true for learning to play an instrument, play a new sport, or speak a new language. If you 
 have ever studied a foreign language, as part of your instruction you undoubtedly had to 
 say certain things over and over again to help you internalize the pronunciation and the 
 grammar.
  
 Learning a computer language is similar to learning any new skill: You must actively 
 practice it to truly master it. As with natural languages, there are two sides to a computer 
 language: the ability to comprehend the language and the ability to speak or write the 
 language. Comprehension (or analysis) of computer code is
  much
  easier than writing (or 
 synthesis of) computer code. When reading this book or when watching somebody else 
 write code, you may be able to easily follow what is going on. This comprehension may lead 
 you to think that you’ve “got it.” However, when it comes to
  writing
  code, at times you will 
 almost certainly feel completely lost concerning something that you thought you 
 understood. To minimize such times of frustration, it is vitally important that you practice 
 what has been presented. Spend time working through assigned exercises, but also 
 experiment with the code yourself. Be an active learner. As with learning to play the piano, 
 you can’t learn to play merely by watching somebody else play!
  
 You should also keep in mind that you can learn quite a bit from your mistakes. In fact, 
 in some ways, the more mistakes you make, the less likely you are to make mistakes in the 
 future. Spending time trying to decipher error messages that are produced in connection 
 with relatively simple code will provide you with the experience to more quickly decipher 
 bugs in more complicated code. Pixar Animation Studios has combined state-of-the-art 
 technology and artistic talent to produce several of the most successful movies of all time. 
 The following quote is from Lee Unkrich, a director at Pixar, who was describing the 
 philosophy they have at Pixar.
 17
 You would do well to adopt this philosophy as your own in 
 your approach to learning to program:
  
 17
 From
  Imagine: How Creativity Works
 , by Jonah Lehrer, Houghton Mifflin Harcourt, 2012, pg. 169.",NA
1.1,NA,NA
Chapter Summary,"Comments are indicated by a hash sign # 
 (also known as the pound or number sign). 
 Text to the right of the hash sign is ignored. 
 (But, hash loses its special meaning if it is 
 part of a string, i.e., enclosed in quotes.)
  
 print()
 : is used to produce output. The op-
 tional arguments sep and end control what 
 ap-pears between values and how a line is 
 termi-
  
 nated, respectively.",NA
1.11,NA,NA
Review Questions,"Note:
  Many of the review questions are meant to be challenging. At times, the questions 
 probe material that is somewhat peripheral to the main topic. For example, questions may 
 test your ability to spot subtle bugs. Because of their difficulty, you should not be 
 discouraged by incorrect answers to these questions but rather use challenging questions 
 (and the understanding a correct answer) as opportunities to strengthen your overall 
 programming skills.
  
 1. True or False: When Python encounters an error, it responds by raising an exception.
  
 2. A comment in Python is indicated by a:
  
 (a) colon (:)
  
 (b) dollar sign ($)
  
 (c) asterisk (*)
  
 (d) pound sign (#)
  
 3. What is the output produced by print() in the following code?
  
 print(""Tasty organic"", ""carrots."")
  
 (a) ""Tasty organic"", ""carrots.""
  
 (b) ""Tasty organic carrots.""",NA
Chapter 2,NA,NA
Core Basics,"In this chapter we introduce some of the basic concepts that are important for 
 understanding what is to follow. We also introduce a few of the fundamental operations 
 that are involved in the vast majority of useful programs.",NA
2.1,NA,NA
Literals and Types,"Section 1.3 introduced the string literal. A string literal is a collection of characters enclosed 
 in quotes. In general, a
  literal
  is code that exactly represents a value. In addition to a string 
 literal, there are numeric literals.
  
 There are actually a few different types of numeric values in Python. There are integer 
 values which correspond to whole numbers (i.e., the countable numbers that lack a 
 fractional part). In Python, an integer is known as an int. A number that can have a 
 fractional part is called a float (a float corresponds to a real number). For example, 42 is an 
 int while 3.14 is a float. The presence of the decimal point makes a number a float—it 
 doesn’t matter if the fractional part is zero. For example, the literal 3.0, or even just 3., are 
 also floats
 1
 despite the fact that these numbers have fractional parts of zero.
 2 
  
 There are some important differences between how computers work with ints and floats. 
 For example, ints are stored exactly in the computer while, in general, floats are only stored 
 approximately. This is a consequence of the fact that we are entering numbers as decimal 
 numbers, i.e., numbers in the base 10 counting system, but the computer stores these 
 numbers internally as a finite number of binary (base 2) digits. For integers we can 
 represent a number exactly in any counting system. However, for numbers with fractional 
 parts, this is no longer true. Consider the number one-third, i.e., 1/3. To represent this as a 
 decimal number (base 10) requires an infinite number of digits: 0
 .
 3333
  · · ·
  . But, if one uses 
 the base 3 (ternary) counting system, one-third is
  
  
  
 From the file: core-basics.tex 
  
  
 1
 We will write the plural of certain nouns that have meaning in Python as a mix of fonts. The noun itself 
 will be in Courier and the trailing “s” will be in Times-Roman, e.g., floats.
  
  
 2
 Other numeric data types that Python provides are complex, Decimal, and Fraction. 
  
 Of these, only 
 complex numbers can be entered directly as literals. They will be considered in Chap. 8. Decimals provide a 
 way of representing decimal numbers in a manner that is consist with how humans think of decimal numbers 
 and do not suffer from the approximation inherent in floats. Fractions are rational numbers where the 
 numerator and denominator are integers.",NA
2.2,NA,NA
"Expressions, Arithmetic Operators, and Precedence","An
  expression
  is code that returns data, or, said another way, evaluates to a value.
 7
 In 
 Python, it is more correct to say that an expression returns an
  object
  instead of a
  value
  or
  
 data
 , but we will ignore this distinction for now (and return to it later). The literal values 
 considered in Sec. 2.1 are the simplest form of an expression. When we write a literal, we 
 are providing (fixed) data. We can also have expressions that evaluate to a new value. For 
 example, we can add two numbers that may be entered as literals. The result of this 
 expression is the new value given by the sum of the numbers. When an expression is 
 entered in an interactive environment, Python will display the result of the expression, i.e., 
 the value to which the expression evaluates.
  
 Python provides the standard arithmetic operations of addition, subtraction, 
 multiplication, and division which are invoked via the
  operators
  +, -, *, and /, respectively. 
 The numbers to either side of these operators are known as the
  operands
 . Listing 2.4 
 demonstrates the use of these operators.
  
 Listing 2.4
  Demonstration of the basic arithmetic operators.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 >>>
  4 - 5 
  
 # Difference of two ints.
  
 -1 
 >>>
  5 + 4 
  
 # Sum of two ints.
  
 9 
 >>>
  5 + 4. 
  
 # Sum of int and float.",NA
2.3,NA,NA
Statements and the Assignment Operator,"A
  statement
  is a complete command (which may or may not produce data). We have 
 already been using print() statements. print() statements produce output but they do not 
 produce data. At this point this may be a confusing distinction, but we will return to it 
 shortly.
  
 In the previous section we discussed the arithmetic operators that you probably first 
 encoun-tered very early in your education (i.e., addition, subtraction, etc.). What you 
 learned previously about these operators still pertains to how these operators behave in 
 Python. Shortly after be-ing introduced to addition and subtraction, you were probably 
 introduced to the equal sign (=). Unfortunately,
  the equal sign in Python does not mean 
 the same thing as in math!
  
 In Python (and in many other computer languages), the equal sign is the
  assignment 
 operator
 . This is a binary operator. When we write the equal sign we are telling Python: 
 “Evaluate the operand/expression on the right side of the equal sign and assign that to the 
 operand on the left.”The left operand must be something to which we can assign a value. 
 Sometimes this is called an“lvalue” (pronounced ell-value). In Python we often call this left 
 operand an
  identifier
  or a
  name
 . In many other computer languages (and in Python) a more 
 familiar name for the left operand is simply 
 variable
 .
 9
 You should be familiar with the 
 notion of variables from your math classes. A variable provides a name for a value. The 
 term variable can also imply that something is changing, but this isn’t necessarily the case 
 in programs—a programmer may define a variable that is associated with a value that 
 doesn’t change throughout a program.
  
 In a math class you might see the following statements:
  x
  = 7 and
  y
  =
  x
 . In math, how is
  x 
 related to
  y
  if
  x
  changes to, say, 9? Since we are told that
  y
  is equal to
  x
 , we would say that
  y
  
 must also be equal to 9. In general,
  this is not how things behave in computer languages!
  
 In Python we can write statements that
  appear
  to be identical to what we would write 
 in a math class, but they are not the same. Listing 2.5 illustrates this. (For brevity, we will 
 use single-character variable names here. The rules governing the choice of variable names 
 are discussed in Sec. 2.6.)
  
 Listing 2.5
  Demonstration of the assignment operator.",NA
2.4,NA,NA
Cascaded and Simultaneous Assignment,"There are a couple of variations on the use of the assignment operator that are worth 
 noting. First, it is possible to assign the same value to multiple variables using
  cascaded
  
 assignments. Listing 2.8 provides an example. In line 1 the expression on the right side is 
 evaluated. The value of this expression, 11, is assigned to x, then to y, and then to z. We can 
 cascade any number of assignments but, other than the operand on the extreme right, all 
 the other operands must be lvalues/variables. However, keep in mind that, as discussed in 
 Sec. 2.3, even though x, y, and z are set to the same value, we can subsequently change the 
 value of any one of these variables, and it will not affect the values of the others.
  
 Listing 2.8
  An example of cascading assignment in which the variables x, y, and z are set to 
 the same value with a single statement.
  
 1
  
  
 2
  
  
 3
  
  
 >>>
  z = y = x = 2 + 7 + 2 
  
 >>>
  x, y, z 
  
 (11, 11, 11) 
  
 A cascading assignment is a construct that exists in many other computer languages. It 
 is a useful shorthand (allowing one to collapse multiple statements into one), but typically 
 doesn’t change the way we think about implementing an algorithm. Cascaded assignments 
 can make the code somewhat harder to read and thus should be used sparingly.
  
 Python provides another type of assignment, known as simultaneous assignment, that is not 
 common in other languages. Unlike cascaded assignments, the ability to do simultaneous 
 assign-ment
  can
  change the way we implement an algorithm. With simultaneous 
 assignment we have multiple expressions to the right of the assignment operator (equal 
 sign) and multiple lvalues (vari-ables) to the left of the assignment operator. The 
 expressions and lvalues are separated by commas. For simultaneous assignment to succeed, 
 there must be as many lvalues to the left as there are comma-separated expressions to the 
 right.
 11 
  
 Listing 2.9 provides an example in which initially the variable c points to a string that is 
 considered the “current” password and the variable o points to a string that is assumed to 
 be the “old” password. The programmer wants to exchange the current and old passwords. 
 This is accomplished using simultaneous assignment in line 5.
  
 Listing 2.9
  An example of simultaneous assignment where the values of two variables are 
 ex-changed with the single statement in line 5.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 >>>
  c =
  ""deepSecret"" 
  
 # Set current password.
  
 >>>
  o =
  ""you’ll never guess""
  # Set old password.
  
 >>>
  c, o 
  
 # See what passwords are.
  
 (’deepSecret’, ""you’ll never guess"") 
 >>>
  c, o = o, c 
  
 # Exchange the passwords.
  
  
  
 11
 It is also possible to have a single lvalue to the left of the assignment operator and multiple expressions to 
 the right. This, however, is not strictly simultaneous assignment. Rather, it is a regular assignment where a 
 single tuple, which contains the multiple values, is assigned to the variable. We will return to this in Chap. 6.",NA
2.5,NA,NA
Multi-Line Statements and Multi-Line Strings,"The end of a line usually indicates the end of a statement. However, statements can span 
 multiple lines if we
  escape
  the newline character at the end of the line or if we use enclosing 
 punctuation marks, such as parentheses, to span multiple lines. To escape a character is to 
 change its usual meaning. This is accomplished by putting a forward slash (\) in front of the 
 character. The usual meaning of a newline character is that a statement has ended.
 12
 If we 
 put the forward slash at the end of the line, just before typing return on the keyboard, then 
 we are saying the statement continues on the next line. This is demonstrated in Listing 2.12 
 together with the use of parentheses to construct multi-line statements.
  
 Listing 2.12
  Constructing multi-line statements by either escaping the newline character at 
 the end of the line (as is done in line 1) or by using parentheses (as is done in lines 3 and 5).
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 >>>
  x = 3 + \ 
  
 ... 4 
  
 >>>
  y = (123213123123121212312 * 3242342423 ... + 
 2343242332 + 67867687678 - 2 
  
 ... + 6) 
  
 >>>
  x, y 
  
 (7, 399499136172418158920598441990) 
  
 Here we see, in lines 2, 4, and 5, that the prompt changes to triple dots when the interpreter 
 is expecting more input.
  
 The converse of having a statement span multiple lines is having multiple statements on 
 a single line. The ability to do this was mentioned in Sec. 1.3 and demonstrated in Listing 
 1.5. One merely has to separate the statements with semicolons. However, for the sake of 
 maximizing code readability, it is best to avoid putting multiple statements on a line.
  
 Often we want to construct multi-line strings. This can be done in various ways but the 
 simplest technique is to enclose the string in either a single or double quotation mark that 
 is repeated three times.
 13
 This is illustrated in Listing 2.13.
  
 Listing 2.13
  Using triple quotation marks to construct multi-line strings.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 >>>
  s =
  """"""This string 
  
 ... spans 
  
 ... multiple lines."""""" 
  
 >>>
  t =
  ’’’This 
  
 ... sentence 
  
 ... no
  
  
  
  
 12
 Keep in mind that although we cannot see a newline character, there is a collection of bits at the end of a 
 line that tells the computer to start subsequent output on a new line.
  
 13
 When using triple quotation marks, the string doesn’t have to span multiple lines, but since one can use a 
 single set of quotation marks for a single-line string, there is typically no reason to use triple quotation marks 
 for a single-line string.",NA
2.6,NA,NA
Identifiers and Keywords,"In addition to assigning names to values (or objects), there are other entities, such as 
 functions and classes, for which programmers must provide a name. These names are 
 known as
  identifiers
 . The rules that govern what is and isn’t a valid identifier are the same 
 whether we are providing a name for a function or variable or anything else. A valid 
 identifier starts with a letter or an underscore and then is followed by any number of 
 letters, underscores, and digits. No other characters are allowed. Identifiers are case 
 sensitive so that, for example, ii, iI, Ii, and II, are all unique names.
  
 Examples of some valid and invalid identifiers are shown in Listing 2.14.
  
 Listing 2.14
  Some valid and invalid identifiers.
  
 one2three  
 one 2 three  
 1 2 three  
 one-2-three  
 n31  
 n.31  
 trailing  
 leading  
 net worth  
 vArIaBlE 
 Valid. 
 Valid. 
 Invalid. Cannot start with a digit. 
 Invalid. Cannot have hyphens (minus 
 signs). Valid. 
 Invalid. Cannot have periods. 
 Valid. 
 Valid. 
 Invalid. Cannot have blank spaces. 
 Valid. 
 14
 If you were paying close attention to the output presented in Listing 1.12, you would have noticed
  \
 n in it.",NA
2.7,NA,NA
Names and Namespaces,"Let us now delve deeper into what happens when a value is assigned to a variable. A 
 variable has a name, i.e., an identifier. The assignment serves to associate the value with the 
 name. This value really exists in the form of an
  object
 . (We aren’t concerned here with the 
 details of objects,
 17
 so we
  
 16
 If you want to learn more now, there is a built-in function called list(). Lists are commonly used in Python 
 and it is tempting to use list as an identifier of your own. You can do this, but you will then lose easy access to 
 the built-in function list(). However, one further aside: If you ever mask one of the built-in functions by 
 assigning a value to the function’s identifier, you can recover the built-in function by deleting, using the del() 
 function, your version of the identifier. Returning to Listing 2.16 as an example, to recover the built-in print() 
 function you would issue the statement del(print). Note that del is a keyword and hence you cannot accidently 
 assign it a new value. 
 17
 Objects are discussed in Chap. 5.",NA
2.8,NA,NA
Additional Arithmetic Operators,"There are other arithmetic operators in Python that are somewhat less common than those 
 discussed in Sec. 2.2, but are nevertheless quite important in the implementation of many 
 algorithms.",NA
2.8.1 ,NA,NA
Exponentiation,"Exponentiation is obtained with the operator **. The expression x ** y says to calculate
  x
 y
 . 
 This operator is unlike the other arithmetic operators in that it associates (or evaluates) 
 right to left. The expression x ** y ** z is equivalent to
  x
 y
 z
 =
  x
 (
 y
 z
 )
 and
  not
  (
 x
 y
 )
 z
 . If both operands 
 are ints, the result is an int. If either operand is a float, the result is a float. Listing 2.18 
 demonstrates the use of exponentiation.
  
 Listing 2.18
  Demonstration of the ** (exponentiation) operator.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14
  
  
 >>>
  2 ** 3
  
 8 
 >>>
  2 ** 3 ** 4 
  
 # Operator is right associative.
  
 2417851639229258349412352 
 >>>
  3 ** 4
  
 81 
 >>>
  (2 ** 3) ** 4 
  
 # Use parentheses to change order of operation.
  
 4096 
 >>>
  3 ** 400 
  
 # A big number. 
  
 Exact value as an int.
  
 70550791086553325712464271575934796216507949612787315762871223209262085 
 55158293415657929852944713415815495233482535591186692979307182456669414 
 5084454535257027960285323760313192443283334088001 
 >>>
  3.0 ** 400
  
 # A big number.
  
 Approximate value as a float.
  
 7.055079108655333e+190 
  
  
 In line 1 we calculate 2
 3
 and in line 3 we calculate 2
 3
 4
 = 2
 81
 . In line 9 3
 400
 is calculated using 
 integers. The result shown on the next three lines is the exact result; this number is actually 
 returned as one continuous number (i.e., without explicit line breaks) but here the number 
 has been split into three lines for the sake of readability. Lines 13 and 14 show what 
 happens when one of the arguments is a float. The result in line 14 is an approximation to 
 the exact answer. The float result has about 16 digits of precision whereas the exact result 
 has 191 digits.",NA
2.8.2 ,NA,NA
Floor Division,"Recall from Sec. 2.2 that float division is represented by the operator /. (If one simply 
 says“division,” float division is implied.) Python provides another type of division which is 
 known as floor division. Many computer languages provide two types of division and 
 Python’s floor division is similar to what is known as integer division in most other 
 languages. In most other languages, both integer and float division share the same symbol,",NA
2.8.3 ,NA,NA
Modulo and divmod(),"Another arithmetic operator that you may not have encountered before is the
  modulo
 , or 
 sometimes called
  remainder
 , operator. In some sense, modulo is the complement of floor 
 division. It tells us what remains after the left operand is divided by the right operand an 
 integer number of times. The symbol for modulo is %. An expression such as 17 % 5 is read 
 as seventeen mod five (this expression evaluates to 2 since 5 goes into 17 three times with 
 a remainder of 2). Although modulo may be new to you, it is extremely useful in a wide 
 range of algorithms. To give a hint of this, assume we want to express 257 seconds in terms 
 of minutes and seconds. From Listing 2.19 we already know how to obtain the number of 
 minutes using floor division. How do we obtain the number of seconds? If we have the 
 number of minutes, we can calculate the remaining number of seconds as line 3 of Listing 
 2.20 shows.",NA
2.8.4 ,NA,NA
Augmented Assignment,"As mentioned in Sec. 2.3, it is quite common to assign a new value to a variable that is 
 based on the old value of that variable, e.g., x = x + 1. In fact, this type of operation is so 
 common that many languages, including Python, provide arithmetic operators that serve as 
 a shorthand for this. These are known as
  augmented assignment operators.
  These operators 
 use a compound symbol consisting of one of the “usual” arithmetic operators together with 
 the assignment operator. For example, += is the addition augmented assignment operator. 
 Other examples include -= and *= (which are the subtraction augmented assignment 
 operator and the multiplication augmented assignment operator, respectively).
  
 To help explain how these operators behave, let’s write a general augmented 
 assignment oper-ator as
  <op>
 = where
  <op>
  is a placeholder for one of the usual arithmetic 
 operators such +, -, or *. A general statement using an augmented assignment operator can 
 be written as
  
 <lvalue> <op>
 =
  <expression>",NA
2.9,NA,NA
Chapter Summary,"Literals are data that are entered directly into 
 the
  
 string.
  
 code.
  
 An
  expression
  produces data. The simplest ex-
  
 Data has
  type
 , for example,
  int
  (integer),
  
 pression is a literal.
  
 float
  (real number with finite precision), and 
 str
  (string, a collection of characters).
  
 There are numerous arithmetic operators.
  Bi-
 nary operators
  (which require two operands) 
 in-
  
 type()
  returns the type of its argument.
  
 clude:
  
 A literal float has a decimal point or con-
 tains the power-of-ten exponent indicator e, 
 e.g., 1.1e2, 11e1, and 110.0 are equivalent 
 floats.
  
 A literal int does not contain a decimal point 
 (nor the power-of-ten exponent indicator e).
  
 +, -
  
 ⊔
  
 ⊔
  
 ⊔
  
 ⊔
  
 ⊔
  
 addition and subtraction
  
 /, //
  
 float and floor division
  
 %
  
 modulo (or remainder)
  
 *
  
 multiplication
  
 **
  
 exponentiation
  
 float division
  (/) yields a float regard-less of 
 the types of the operands. For all other
  
 A literal str is enclosed in either a matching 
 pair of double or single quotes. Quotation 
 marks can be repeated three times at the 
 beginning and end of a string, in which case 
 the string can span multiple lines.
  
 arithmetic 
 operators, 
 only 
 when
  both
  
 operands are integers does the operation 
 yield an integer. Said another way, when 
 either or both operands are floats, the 
 arithmetic operation yields a float.
  
 \n is used in a string to indicate the newline 
 character.
  
 Floor division
  (//) yields a whole number 
 (which may be either an int or a float, de-
  
 pending on the operands).
  
 The result is the
  
 Characters in a string may be
  escaped
  by pre-
  
 largest whole number that does not exceed 
 the value that would be obtained with float 
 divi-sion.
  
 ceding the character with a backslash.
  
 This
  
 causes the character to have a different mean-
  
 ing than usual, e.g., a backslash can be 
 placed before a quotation mark in a string to 
 prevent it from indicating the termination of 
 the string; the quotation mark is then 
 treated as part of the
  
 Modulo
  (%) yields the remainder (which 
 may be either an int or a float, depending on 
 the operands) after floor division has been 
 per-formed.",NA
2.1,NA,NA
Review Questions,"1. What does Python print as a result of this statement:
  
 print
 (7 + 23)
  
 (a) 7 + 23 
  
 (b) 7 + 23 = 30",NA
2.11,NA,NA
Exercises,"1. Write a small program that assigns an angle in degrees to a variable called degrees. 
 The program converts this angle to radians and assigns it to a variable called radians. 
 To convert from degrees to radians, use the formula radians = degrees
  ×
  3
 .
 14
 /
 180 
 (where we are using 3
 .
 14 to approximate
  π
 ). Print the angle in both degrees and 
 radians.
  
 The following demonstrates the program output when the angle is 150 degrees:
  
 1 
  
 2
  
  
 Degrees: 
  
 150
  
 Radians: 
  
 2.616666666666667
  
  
 2. Write a program that calculates the average score on an exam. Assume we have a 
 small class of only three students. Assign each student’s score to variables called 
 student1, student2, and student3 and then use these variables to find the average 
 score. Assign the average to a variable called average. Print the student scores and 
 the average score.
  
 The following demonstrates the program output when the students have been 
 assigned scores of 80.0, 90.0, and 66.5:
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 Student scores: 
  
 80.0 
  
 90.0 
  
 66.5 
  
 Average: 
  
 78.83333333333333
  
  
 3. Imagine that you teach three classes. These classes have 32, 45, and 51 students. You 
 want to divide the students in these classes into groups with the same number of 
 students in each group but you recognize that there may be some “left over” students. 
 Assume that you would like there to be 5 groups in the first class (of 32 students), 7 
 groups in the second class (of 45 students), and 6 groups in the third class (of 51 
 students). Write a program that uses the divmod() function to calculate the number 
 of students in each group (where each group has the same number of students). Print 
 this number for each class and also print the number of students that will be 
 “leftover” (i.e., the number of students short of a full group). Use simultaneous 
 assignment to assign the number in each group and the “leftover” to variables.
  
 The following demonstrates the program’s output:",NA
Chapter 3,NA,NA
Input and Type Conversion,"It is hard to imagine a useful program that doesn’t produce some form of output. From the 
 last two chapters we know how to generate text output in Python using print(),
 1
 but the 
 output produced by a program doesn’t have to be text. Instead, it can be an image sent to 
 your screen or written to a file; it can be an audio signal sent to your speakers; and it can 
 even be data generated solely to pass along to another program (without needing to be 
 sent to your screen or a file).
  
 In general, programs not only generate output, they also work with input. This input 
 may come from the user via a keyboard or mouse, from a file, or from some other source 
 such as another program or a network connection. In this chapter we implement programs 
 that perform both
  input and output
  (often abbreviated as I/O) but restrict ourselves to 
 obtaining input only from a keyboard.",NA
3.1,NA,NA
Obtaining Input: input(),"The built-in function input() takes a string argument. This string is used as a prompt. When 
 the input() function is called, the prompt is printed and the program waits for the user to 
 provide input via the keyboard. The user’s input is sent back to the program once the user 
 types return. input()
  always returns the user’s input as a string
 . This is true even if we are 
 interested in obtaining a numeric quantity (we will see how to convert strings to numeric 
 values in the next section).
  
 Before demonstrating the use of the input() function, let’s expand on what we mean 
 when we say a function
  returns
  a value. As we will see, functions can appear in expressions. 
 When Python encounters a function in an expression, it evaluates (calls) that function. If a 
 function appears in an expression, it will almost certainly
  return
  some form of data.
 2
 As it 
 evaluates the ex-pression, Python will replace the function with whatever the function 
 returned. For the input() function, after it has been called, it is as though it disappears and 
 is replaced by whatever string the function returns.
  
 Listing 3.1 demonstrates the behavior of the input() function. Here the goal is to obtain
  
 From the file: input.tex 
  
 1
 For now, our output only goes to a screen. In a later chapter we will learn how to write output 
 to a file.
  
 2
 Not all functions return data. The print() function is an example of a function that does not return data—
 although it generates output, it does not produce data that can be used in an expression. This is considered in 
 greater detail in Chap. 4.",NA
3.2,NA,NA
"Explicit Type Conversion: int(), float(), and str()","We have seen that there are instances in which data of one type are implicitly converted to 
 another type. For example, when adding an integer and a float, the integer is implicitly 
 converted to a float and the result is a float. This might lead us to ask: What happens if we 
 try to add a string and an integer or perhaps multiply a string and a float? Our intuition 
 probably leads us to guess that such operations will produce an error if the string doesn’t 
 look like a number, but the answer isn’t necessarily obvious if we have a string such as 
 ""1492"" or ""1.414"". We’ll try a few of these types of operations.
  
 Listing 3.2 illustrates a couple of attempts to use strings in arithmetic operations.
  
 Listing 3.2
  Attempts to add a string and an integer and to multiply a string and a float. Both 
 attempts result in errors.
 3
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 >>>
  ""1492"" + 520 
  
 Traceback (most recent call last):  
 File ""<stdin>"", line 1, in <module>  
 TypeError: cannot convert ’int’ object to str implicitly 
 >>>
  ""1.414"" * 1.414 
  
 Traceback (most recent call last):  
 File ""<stdin>"", line 1, in <module>  
 TypeError: cannot multiply sequence by non-int of type ’float’ 
  
 Line 1 attempts to add the string ""1492"" and the integer 520. This attempt fails and 
 produces a TypeError. However, note carefully the error message on line 4. It says that it 
 cannot convert an integer to a string
  implicitly
 . This suggests that perhaps
  explicit
  
 conversion is possible, i.e., we have to state more clearly the type of conversion we want to 
 occur. (Also, we want the string to be converted to an integer, not the other way around.) 
  
 The attempt to multiply a string and a float in line 5 also fails and produces a TypeError. 
 Here the error message is a bit more cryptic and, at this stage of our knowledge of Python, 
 doesn’t suggest a fix. But, the way to “fix” the statement in line 1 is the way to fix the 
 statement in line 4: we need to explicitly convert one of the operands to a different type to 
 obtain a valid statement.
  
 The int() function converts its argument to an integer while the float() function 
 converts its argument to a float. The arguments to these functions can be either a string or 
 a number (or an expression that returns a string or a number). If the argument is a string, it 
 must “appear” to be an appropriate numeric value. In the case of the int() function, the 
 string must look like an",NA
3.3,NA,NA
Evaluating Strings: eval(),"Python provides a powerful function called eval() that is sometimes used to facilitate 
 obtain-ing input. However, because of this function’s power, one should be cautious about 
 using it in situations where users could potentially cause problems with “inappropriate” 
 input. The eval() function takes a string argument and
  evaluates
  that string as a Python 
 expression, i.e., just as if the programmer had directly entered the expression as code. The 
 function returns the result of that expression. Listing 3.7 demonstrates eval().
  
 Listing 3.7
  Basic demonstration of the eval() function.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18 
 19 
 20 
 21 
 22
  
  
 >>>
  string =
  ""5 + 12""
  # Create a string. 
 >>>
  
 print
 (string) 
  
 # Print the string.
  
 5 + 12  
 >>>
  eval
 (string) 
  
 # Evaluate the string.
  
 17  
 >>>
  print
 (string,
  ""=""
 ,
  eval
 (string)) 
  
 5 + 12 = 17  
 >>>
  eval
 (
 ""print(’Hello World!’)""
 )
  # Can call functions from eval(). 
 Hello World! 
 >>>
  # Using eval() we can accept all kinds of input...
  
 >>>
  age =
  eval
 (
 input
 (
 ""Enter your age: ""
 )) 
 Enter your 
 age:
  57.5 
  
 >>>
  age 
  
 57.5  
 >>>
  age =
  eval
 (
 input
 (
 ""Enter your age: ""
 )) 
 Enter your 
 age:
  57 
  
 >>>
  age 
  
 57  
 >>>
  age =
  eval
 (
 input
 (
 ""Enter your age: ""
 )) 
 Enter your 
 age:
  40 + 17 + 0.5 
  
 >>>
  age 
  
 57.5 
  
 In line 1 a string is created that looks like an expression. In line 2 this string is printed and 
 the output is the same as the string itself. In line 4, the string is the argument to the eval() 
 function.",NA
3.4,NA,NA
Chapter Summary,"eval()
 : Returns the result of evaluating its 
 string argument as any Python expression, 
 in-cluding 
 arithmetic 
 and 
 numerical 
 expressions.
  
 Functions such as the four listed above can 
 be 
 nested
 . Thus, for example,
  float(input()) 
 can be used to obtain input in string form 
 which is then converted to a float value.
  
 input()
 : Prompts the user for input with its 
 string argument and returns the string the 
 user enters.
  
 int()
 : Returns the integer form of its argu-
 ment.
  
 float()
 : Returns the float form of its ar-
 gument.",NA
3.5,NA,NA
Review Questions,"1. The following code is executed
  
 x =
  input
 (
 ""Enter x: ""
 )
  
 In response to the prompt the user enters",NA
3.6,NA,NA
Exercises,"1. A commonly used method to provide a rough estimate of the right length of 
 snowboard for a rider is to calculate 88 percent of their height (the actual ideal length 
 really depends on a large number of other factors). Write a program that will help 
 people estimate the length of snowboard they should buy. Obtain the user’s height in 
 feet and inches (assume these values will be entered as integers) and display the 
 length of snowboard in centimeters to the user. There are 2.54 centimeters in an inch.
  
 The following demonstrates the proper behavior of the program:
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 Enter your height.
  
 Feet:
  5 
  
 Inches:
  4
  
 Suggested board length: 143.0528 cm
  
  
 2. Newton’s Second Law of motion is expressed in the formula
  F
  =
  m × a
  where
  F
  is force, 
 m
  
 is mass, and
  a
  is acceleration. Assume that the user knows the mass of an object and the
  
 force on that object but wants to obtain the object’s acceleration
  a
 . Write a program 
 that prompts the user to enter the mass in kilograms (kg) and the force in Newtons 
 (N). The user should enter both values on the same line separated by a comma. 
 Calculate the acceleration using the above formula and display the result to the user.
  
 The following demonstrates the proper behavior of the program:
  
 1
  
  
 2
  
  
 3
  
  
 Enter the mass in kg and the force in N:
  55.4, 6.094 
 The acceleration is 
 0.11000000000000001",NA
Chapter 4,NA,NA
Functions,"In this chapter we consider another important component of useful programs:
  functions
 . A 
 pro-grammer often needs to solve a problem or accomplish a desired task but may not be 
 given a precise specification of
  how
  the problem is to be solved. Determining the “how” and 
 implementing the solution is the job of the programmer. For all but the simplest programs, 
 it is best to divide the task into smaller tasks and associate these subtasks with
  functions
 .
  
 Most programs consist of a number of functions.
 1
 When the program is run, the functions 
 are 
 called
  or
  invoked
  to perform their particular part of the overall solution. We have 
 already used a few of Python’s built-in functions (e.g., print() and input()), but most 
 programming languages, including Python, allow programmers to create their own 
 functions.
 2 
  
 The ability to organize programs in terms of functions provides several advantages over 
 using a monolithic collection of statements, i.e., a single long list of statements:
  
 •
  Even before writing any code, functions allow a hierarchical approach to
  thinking 
 about
  and solving the problem. As mentioned, one divides the overall problem or task 
 into smaller tasks. Naturally it is easier to think about the details involved in solving 
 these subtasks than it is to keep in mind all the details required to solve the entire 
 problem. Said another way, the ability to use functions allows us to adopt a
  divide and 
 conquer
  approach to solve a problem.
  
 •
  After determining the functions that are appropriate for a solution, these functions can 
 be implemented, tested, and debugged, individually. Working with individual functions 
 is often far simpler than trying to implement and debug monolithic code.
  
 •
  Functions provide
  modularization
  (or compartmentalization). Suppose a programmer 
 asso-ciates a particular task with a particular function, but after implementing this 
 function, the programmer determines a better way to implement what this function 
 does. The programmer can rewrite (or replace) this function. It the programmer does 
 not change the way data are entered into the function nor the way data are returned 
 by the function, the programmer can replace this function without fear of affecting 
 any other aspect of the overall program. (With monolithic code, this is generally not 
 the case.)",NA
4.1,NA,NA
Void Functions and None,"Before turning to the creation of our own functions, let us further consider the print() 
 function. As we’ve seen, the print() function produces output, but it is, in fact, a
  void 
 function
 . If a function doesn’t explicitly return data and yet it is used in an expression, the 
 function evaluates to None (None is one of the keywords listed in Listing 2.15). None is, in 
 some ways, Python’s way of saying, “I’m nothing. I don’t exist.”
  
 To illustrate how None can appear in code, consider Listing 4.1.",NA
4.2,NA,NA
Creating Void Functions,"To create a function, one uses the template shown in Listing 4.2 where the terms in angle 
 brackets are replaced with appropriate values as discussed below.",NA
4.3,NA,NA
Non-Void Functions,NA,NA
Scope of Variables,CHAPTER 4. FUNCTIONS,NA
4.4,"For now, you should always use parameters to pass data into a function and always use the 
 return statement to obtain data from a function. (There are other ways to exchange data 
 with a function using what are known as
  global variables
 , but the use of global variables is 
 generally considered to be a dangerous programming practice.) Something that you need 
 to keep in mind is that all the parameters and variables that are defined in a function are
  
 local
  to a function, meaning that these variables cannot be “seen” by code outside of the 
 function.
  
 The code over which a variable is accessible or visible is known as the variable’s scope. 
 The scope of a variable within a function is from the point it is created (either in the 
 parameter list or in the body via an assignment operation) to the end of the function.
  
 Although scope is an important and, at times, complicated issue, it is not something we 
 want to belabor here. Nevertheless, there are a few issues related to scope about which you 
 should be aware as this awareness may help prevent bugs from appearing in your code.
  
 Listing 4.8 again uses the get wh() function that was used in Listing 4.7.
  
 Listing 4.8
  Demonstration that variables are local to a function.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18
  
  
 >>>
  def
  get_wh(): 
  
 ... 
  
 """"""Obtain weight and height from user."""""" 
  
 ... 
  
 weight =
  float
 (
 input
 (
 ""Enter weight [pounds]: ""
 )) ... 
  
 height =
  
 float
 (
 input
 (
 ""Enter height [inches]: ""
 )) 
  
 return
  weight, height ...
  
 ...
  
 >>>
  get_wh() 
  
 Enter weight [pounds]:
  120 
  
 Enter height [inches]:
  60 
  
 (120.0, 60.0) 
  
 >>>
  print(weight) 
  
 Traceback (most recent call last): 
 File ""<stdin>"", line 1, in <module> 
 NameError: name ’weight’ is not defined 
 >>>
  
 print(height) 
  
 Traceback (most recent call last): 
 File ""<stdin>"", line 1, in <module> 
 NameError: name ’height’ is not defined 
  
 Lines 1 through 5 define get wh() as before. This function is invoked in line 7. The user 
 enters 120 for the weight and 60 for the height. Since the return value of this function is not 
 assigned to anything, the interactive environment displays the return value in line 10 
 (were this code run from within a file, the return value would simply be ignored—it would 
 not appear as output). In lines 11 and 15 an attempt is made to print the weight and height, 
 respectively, that exist in the get wh() function. Both these attempts produce NameErrors 
 with a statement that the variables are not defined. Again, these variables exist in the get 
 wh() function and only in get wh().",NA
4.5,NA,NA
Scope of Functions,"As described in Secs. 4.2 and 4.3, a def statement is used to create a function. So far, all the 
 functions we have created have been defined outside the body of any other function. 
 Defining a function in this way gives the function
  global scope
  meaning it is visible 
 everywhere—we can call a function with global scope from within another function or call 
 it while outside of any function (i.e., directly from the interactive prompt).
  
 However, it is also possible to define a function within the body of another. When this is 
 done, the inner function can only be invoked from within the function in which it was 
 defined.
 7
 Thus the scope of the inner function is local to the outer function. This is 
 demonstrated in Listing 4.11 where the function g0() is defined in the body of f0(). g0() 
 returns the cube of its argument. f0() passes its argument to g0(), raises that to the fourth 
 power, adds 4, and returns the resulting value.
  
 Listing 4.11
  Demonstration that one function can be defined within another. However, 
 when this is done, the scope of the inner function is restricted to the outer function in which 
 it was defined.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17
  
  
 >>>
  def
  f0(x):
  
 ... ... 
 ... ...
  
 def
  g0(y): 
  
 return
  y ** 3 + 3 
  
 return
  g0(x) ** 4 + 4
  
 >>>
  f0(4)
  
 20151125  
 >>>
  g0(4)
  
 Traceback (most recent call last): 
 File ""<stdin>"", line 1, in <module> 
 NameError: name ’g0’ is not defined  
 >>>
  def
  f1(x):
  
 ... ...
  
 return
  g1(x) ** 4 + 4
  
 >>>
  def
  g1(x):
  
 ... ...
  
 return
  x ** 3 + 3
  
  
  
  
 7
 Also, the function can only be called
  after
  it is defined.",NA
4.6,NA,NA
print() vs. return,"In some situations print() statements and return statements appear to behave the same 
 way. 
 However,
  print()
  and
  return
  are fundamentally different and a failure to understand 
 how they differ can lead to errors.
  To illustrate this, consider the code in Listing 4.12. Two 
 functions are defined, p() and r(). Both take a single argument and both multiply this 
 argument by 2. p()
  prints
  the result of this multiplication whereas r()
  returns
  this result.
  
 Listing 4.12
  Demonstration of the difference between a function that prints a value and one 
 that returns the same value.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
   
 >>>
  def
  p(x):
  
 # p() prints a result
  
 # r() returns a result
  
 ...
  
 print
 (2 * x)
  
 ...
  
 >>>
  def
  r(x):
  
 ...
  
 return
  2 * x
  
 ...
  
 >>>
  p(10)",NA
4.7,NA,NA
Using a main() Function,"In some popular computer languages it is required that every program has a function called 
 main(). This function tells the computer where to start execution. Since Python is a
  scripted
  
 language in which execution starts at the beginning of a file and subsequent statements are 
 executed sequen-tially, there is no requirement for a main() function. Nevertheless, many 
 programmers carry over this convention to Python—they write programs in which, other 
 than function definitions themselves, nearly all statements in the program are contained 
 within one function or another. The programmers create a main() function and often call 
 this in the final line of code in the program. Thus, after all the functions have been defined, 
 including main() itself, the main() function is called.
  
 Listing 4.14 provides an example of a program that employs this type of construction. 
 Here it is assumed this code is stored in a file (hence the interactive prompt is not shown). 
 When this file is executed, for example, in an IDLE session, the last statement is a call to the 
 main() function. Everything prior to that final invocation of main() is a function definition. 
 main() serves to call the other three functions that are used to prompt for input, calculate a 
 BMI, and display that BMI.",NA
4.8,NA,NA
Optional Parameters,"Python provides many built-in functions. The first function we introduced in this book was 
 the built-in function print(). The print() function possesses a couple of interesting features 
 that we don’t yet know how to incorporate into our own functions: print() can take a 
 variable number of parameters, and it also accepts optional parameters. The optional 
 parameters are sep and end which specify the string used to separate arguments and what 
 should appear at the end of the output, respectively. To demonstrate this, consider the code 
 shown in Listing 4.15.
  
 Listing 4.15
  Demonstration of the use of the sep and end optional parameters for print().
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
  
 >>>
  # Separator defaults to a blank space.
  
 >>>
  print
 (
 ""Hello""
 ,
  ""World""
 ) 
  
 Hello World  
 >>>
  # Explicitly set separator to string ""-*-"".
  
 >>>
  print
 (
 ""Hello""
 ,
  ""World""
 , sep=
 ""-*-""
 ) 
  
 Hello-*-World  
 >>>
  # Issue two separate print() statements. 
  
 (Multiple statements can 
 >>>
  # 
 appear on a line if they are separated by semicolons.)",NA
4.9,NA,NA
Chapter Summary,NA,NA
4.1,NA,NA
Review Questions,"1. The following code is executed
  
 def
  f(x): 
  
  
 return
  x + 2, x * 2
  
 x, y = f(5) 
  
 print
 (x + y)
  
 What is the output produced by the print() statement?",NA
4.11,NA,NA
Exercises,"1. Write a function called convert to days() that takes no parameters. Have your func-
 tion prompt the user to input numbers of hours, minutes, and seconds. Write a helper 
 func-tion called get days() that uses these values and converts them to days in float 
 form (fractions of a day are allowed). get days() should return the number of days. 
 Use this helper function within the convert to days() function to display the numbers 
 of days to the user. The built-in function round() takes two arguments: a number and 
 an integer indicating the desired precision (i.e., the desired number of digits beyond 
 the decimal point). Use this function to round the number of days four digits after the 
 decimal point.
  
 The following demonstrates the proper behavior of convert to days():
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 >>>
  convert_to_days() 
  
 Enter number of hours:
  97 
  
 Enter number of minutes:
  54 
  
 Enter number of seconds:
  45
  
 The number of days is:
  4.0797
  
  
 2. Write a function called calc weight on planet() that calculates your equivalent weight on 
 another planet. This function takes two arguments: your weight on Earth in pounds 
 and the surface gravity of the planet of interest with units m/s
 2
 . Make the second 
 argument op-tional and supply a default value of 23.1 m/s
 2
 which is the approximate",NA
Chapter 5,NA,NA
Introduction to Objects,"In the coming chapters, we want to unleash some of the power of Python. To access this 
 power we have to introduce something that is syntactically different from what we have 
 seen so far. In order to understand the reason for this change in syntax, it is best to have a 
 simple understanding of
  objects
  and
  object oriented programming
 .
  
 Computer languages, considered as a whole, differ widely in how they allow 
 programmers to construct a program. There are some languages that permit object 
 oriented programming, often ab-breviated OOP. Python is one such language (C++, Java, 
 and C# are other popular OOP languages). As will be described, OOP provides a way of 
 organizing programs that is more similar to the way people think (i.e., more so than if one 
 uses a non-OOP approach). Thus, in many instances an OOP approach provides the clearest 
 and simplest route to a solution. However, as you might imagine, when something attempts 
 to reflect the way humans think, there can be many subtleties and several layers of 
 complexity. We do
  not
  want to explore any of these subtleties and complexities here.
  
 At the conclusion of this chapter you should have a sufficiently clear understanding of a 
 couple of aspects of OOP—to the point where you should be comfortable with the material 
 in chapters that follow. But, there is no expectation that this chapter will enable you to 
 write your own programs that fully exploit the power of OOP. (So, if some questions about 
 OOP linger at the end of this chapter, it is to be expected and should not be a concern. At the 
 end of the chapter we will revisit the “take away” message of this material.)",NA
5.1,NA,NA
Overview of Objects and Classes,"In previous chapters we considered data such as strings, integers, and floats. We also 
 considered functions that can accept data via a parameter (or parameters) and can return 
 data via a return statement. Functions are created to accomplish particular tasks and are 
 invariably restricted in the type of data they can accept. For example, if we write a function 
 to capitalize the characters in a string, it doesn’t make sense to pass numeric data to this 
 function. As another example, if a function calculates the absolute value, it doesn’t make 
 sense to pass this function a string.
  
 When you pause to think about data and functions, you quickly realize they are related 
 in some way. The fact that only certain forms of data make sense with certain functions ties 
 data and functions together conceptually. In OOP there is still the ability to work with 
 traditional data and
  
 From the file: object-basics.tex",NA
5.2,NA,NA
Creating a Class: Attributes,"In OOP, the programmer uses a
  class statement
  to provide something of a blueprint for the 
 attributes an object has (we’ll turn our attention to an object’s methods in the next section). 
 Let’s use a slightly contrived scenario to help illustrate the creation of a class. Assume a 
 programmer works for a hospital and needs to develop a program that deals with patients. 
 These patients have only three attributes: name, age, and malady. To tell Python what 
 constitutes a patient, the programmer creates a class with a statement that follows the 
 template shown in Listing 5.1.
 2
  
 Listing 5.1
  Basic template for creating a class.
  
 1 
  
 2
  
  
 class
  <ClassName>
 : 
  
  
 <body>
  
  
 Line 1 provides the class header which starts with the keyword class. This is followed by 
 <ClassName>
  which is the name of the class and can be any valid identifier.
 3
 The header is 
 terminated with a colon. The header is followed by the
  <body>
  which provides statements 
 that specify the attributes and methods in the class (we defer consideration of methods to 
 the next section). As was the case for a function definition, the
  <body>
  must be indented. 
 The body can consist of any number of statements and is terminated by halting indentation 
 of the code (or by entering a blank line in the interactive environment or in IDLE).
  
 Although there are various ways to implement a Patient class, a programmer might use 
 the class statement shown in lines 1 through 4 of Listing 5.2.
 4
 This statement creates the 
 attributes name, age, and malady simply by using the assignment operator to assign default 
 values to these identifiers. Keep in mind that this class statement itself does
  not
  actually 
 create a Patient. Rather, it tells us what attributes a Patient has. In some ways this is similar 
 to what we do with functions. We define a function with a def statement, but this doesn’t 
 invoke the function. After the function is defined, we are free to call it as needed. The 
 creation of a class is somewhat similar. After we create a class with a class statement, we 
 are free to call the class to create as many objects (of that class) as needed. (Creating an 
 object is often called
  instantiation
  and we will use the terms object and
  instance
  
 synonymously.) The rest of the code in Listing 5.2 is discussed in more detail following the 
 listing.
  
 Listing 5.2
  class statement that defines the Patient class where a Patient has a name, age, 
 and malady. Each of these attributes is given a default value.
  
 1
  
  
 2
  
  
 3
  
  
 >>>
  class
  Patient: 
  
 ... 
  
 name =
  ""Jane Doe"" 
  
 ... 
  
 age = 0
  
  
  
  
 2
 A more complicated class statement is available that allows one class to inherit properties from another, 
 but we have no need for it here.
  
  
 3
 The class identifier is usually written using the “CapWords” convention where the first letter of each word 
 is capitalized and, of course, there are no spaces between the words (since there can be no spaces in an 
 identifier). 
  
 4
 A construct like this would almost certainly
  not
  be used in practice, but this implementation is",NA
5.3,NA,NA
Creating a Class: Methods,"In lines 18 and 19 of Listing 5.2 a function is defined to show a Patient’s attributes. 
 Although this function only works for Patients, it is not truly affiliated with the Patient 
 class—the function stands on its own. We could, perhaps, accidentally call the show() 
 function with a string as the parameter. If we did, an error would occur (since strings don’t 
 have attributes of name, age, and malady).
  
 Instead of defining a function such that it exists outside the class, we can include a 
 function as a method within the class if we move the associated def statement into the class 
 statement. By doing this, we can ensure the method only operates on the objects for which 
 it is designed to operate. A method is almost exactly like a function but there are a couple of 
 notable differences: one affects how we define a method and the other affects how we 
 invoke it. Let us first consider the difference in invocation.
  
 Similar to the show() function in Listing 5.2, assume we have written a
  method
  that 
 shows the attributes of a Patient. To distinguish this from the show() function, let’s call this 
 method display(). In Listing 5.2, the
  function
  to show the object’s attributes is invoked with 
 an argu-ment of sally using this statement:
  
 show(sally)
  
 Since display() is a method, where it is defined in the class statement, we invoke it using this 
 statement:
  
 sally.display()
  
 We’ll discuss this in more detail in a moment, but we want to state up front that this 
 invocation 
 does
  pass sally as a parameter to the display() method.
 6
 To invoke a method, we 
 provide an instance of the class (which is sally here) and then, using dot notation, specify 
 the method. The parentheses are necessary. sally “knows” her attributes but she also 
 “knows” her methods; hence the dot notation allows us to access not only the attributes, 
 but also the methods within sally’s class.
  
  
 6
 The fact that sally is passed as a parameter to the display() method is done implicitly when the method is 
 called, but, as will be shown soon, is indicated explicitly in the method definition.",NA
5.4,NA,NA
The dir() Function,"When we create a class, we create a new type of data. (We can see this if we use the type() 
 function to check on the type of one of the Patient’s we created above.) Given that all data 
 in Python are actually objects of classes means that all data are collections of attributes and 
 methods. This is indeed the case and the built-in function dir() provides a way to see this 
 collection, albeit not necessarily in the prettiest form. You can think of dir() as providing a
  
 dir
 ectory of sorts.
  
 Listing 5.4 is a continuation of Listing 5.3 in which the Patient class is defined and 
 samuel is an instance of this class. In line 19 we use the type() function to ask what the type 
 is of the Patient class. In line 20 we see that a Patient’s type is type! This tells us that a 
 Patient is its own (new) form of data.
  
 In line 21 we ask for samuel’s type. We see that samuel is a Patient but we are also given 
 some additional information. This additional information relates to where the class is 
 defined, but this doesn’t concern us now.
 7
 In lines 23 and 24, type() shows that samuel’s age 
 attribute is an integer. Lines 25 and 26 show that samuel.display is a method. The rest of 
 this code is discussed following the listing.
  
 Listing 5.4
  Illustration that a class is a type of data (and hence a new class is a new type of 
 data). Also, this code demonstrates the use of the dir() function. This is a continuation of 
 Listing 5.3.
  
 1
 9 
 2
 0 
 2
 1 
 2
 2 
 2
 3 
 2
 4 
 2
 5 
 2
 6 
 2
 7 
 2
 8 
 2
 9 
 3
 0 
 3
  
 >>>
  type
 (Patient) 
  
 <class ’type’>  
 >>>
  type
 (samuel) 
  
 <class ’__main__.Patient’>  
 >>>
  type
 (samuel.age) 
  
 <class ’int’>  
 >>>
  type
 (samuel.display) 
  
 <class ’method’>  
 >>>
  dir
 (samuel) 
  
 [’__class__’, ’__delattr__’, ’__dict__’, ’__doc__’, ’__eq__’, 
 ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’,
 ’__init__’
 , ’__le__’, ’__lt__’, ’__module__’, 
 ’__ne__’, ’__new__’,’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__setattr__’, 
 ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’__weakref__’,
  ’age’,’malady’, ’name’, ’display’
 ] 
  
 In line 27 dir() is used to show all the attributes and methods associated with Patient. We 
 are shown a collection of strings.
 8
 Notice the last four strings correspond to the attributes 
 and the
  
 7
 Since we used the interactive environment to define the Patient class, this class is said to have been 
 created in
  
 main
  
 which is Python’s name for the “top-level script environment.”",NA
5.5,NA,NA
The,NA,NA
init () Method,"We now return to the
  
 init () method mentioned in connection with Listing 5.4.
 9
 (Depending
  
 on the display device you use to read this material, it may not be obvious, but this method 
 starts and ends with
  two
  underscores.) If a programmer defines this method, it is called 
 automatically when
  
 an object is created. Hence
  
 init () serves as the
  init
 ialization method. Using this method
  
 we can set the values of an object’s attributes when the object is created (this is in contrast to 
 the examples in Figs. 5.2 and 5.3 where the objects are created first and then their attributes 
 are set
  
 using additional statements). Any parameters given to the class are passed along 
 to
  
 init ().
  
 This is best illustrated with an example.
  
  
 inside the
  
 init () method that starts on line 2. In this example the
  
 init () method
  
  
 takes four parameters. In general
  
 init () must have at least one parameter but could have",NA
5.6,NA,NA
Operator Overloading,"If you are shown a plus sign and asked what it does or what it represents, the first answer 
 that springs to mind will probably pertain to the addition of two numbers. But, when you 
 think about it a bit more, you realize the plus sign can mean different things in different 
 contexts. For example, if you see +5.234, the plus sign is not indicating a sum: rather, it is 
 indicating 5.234 is a positive number. Graffiti that says “
 pat + chris
 ” indicates the existence 
 of a couple where there is a lot of room for further interpretation. So, we should recognize 
 that not only is the plus sign a convenient and familiar symbol, it can mean different things 
 in different contexts.
  
 Although we haven’t dwelt on it, we’ve already seen that symbols in computer 
 languages can mean different things in different “contexts.” We’ve seen that a plus sign can 
 mean addition (with the need for two operands) but it can also indicate sign (with a single 
 operand). We’ve seen that a minus sign can mean subtraction, but it can also indicate sign 
 (as in -5.234) or produce a change in sign (as in -x).
  
 We’ve seen that a plus sign can be put between two ints or two floats or between an int 
 and a float. We typically think of these operations as simply the sum of two numbers, but 
 because of the way numbers are represented in a computer and the implementation of the 
 underlying hardware, summing two ints requires actions on the part of the computer that 
 are different from the actions involved in summing two floats. Also, when we sum an int 
 and float, the computer must first
  promote
  the int to a float and then perform the sum. In 
 Python, when we place the plus sign between two operands, the interpreter is aware of the 
 class to which the operands belong (or, said another way, the types of the operands). Thus, 
 Python will do“the right thing” whether we are summing ints or floats or anything else. In 
 some cases, “the right thing” is to report an error if, for example, we try to sum an int and a 
 string.
  
 When we say a symbol can mean different things in different contexts, we take it as 
 understood that the “context” is determined by the associated operand or operands for the 
 symbol. For exam-ple, when a plus sign appears between two integers, the context is one 
 involving integers and the plus sign needs to be interpreted in a way that is appropriate for 
 integers. When a plus sign appears between an integer and a float, the context is now one of 
 mixed types and the plus sign must be interpreted in a way that is appropriate for these 
 specific types. With OOP, it is typically possible to specify what a symbol means or does in a 
 given context, e.g., the programmer can dictate what should be done when a plus sign is 
 used in a particular context. Defining a new interpretation of a symbol and how it should 
 behave in a given context is known as
  operator overloading
 . We won’t consider how one 
 implements operator overload, but we do want to be aware of its existence.
 10
  
 10
 Although the details aren’t import to us and hence won’t be covered, we will say that when objects appear 
 to the",NA
5.7,NA,NA
Take-Away Message,"This chapter seemingly provides quite a bit of material and the initial exposure to OOP 
 nomencla-ture can be, shall we say, challenging.
  However
 , there are really just three 
 messages you need to",NA
5.8,NA,NA
Chapter Summary,"tribute operator
 , i.e., a dot (.), followed by 
 the desired attribute or method. (Keep in 
 mind that the dot is an operator and cannot 
 be part of an identifier.)
  
 dir()
 : provides a listing of the attributes and 
 methods of an object.
  
 Operators, such as the plus sign, can be
  over-
 loaded
  so that the operation performed 
 depends
  
 An
  object
  is a collection of
  attributes
  (data) 
 and 
 methods
  (functions).
  
 Objects are said to be instances of a
  class
 .
  
 A
  class
  statement provides a blueprint for 
 cre-ating objects.
  
 In Python all data are objects. An object’s 
 type corresponds to its class.
  
 To access an object’s attributes or methods, 
 one writes the object followed by the
  access 
 at-
  
 on the types of the operands.
  
 For example,
  
 strings can be
  concatenated
  if they are 
 “added”together.",NA
Chapter 6,NA,NA
Lists and for-Loops,"To facilitate solving various problems, we often organize data in some form of
  data 
 structure
 . There are several different kinds of data structures used in computer science. 
 The basic concepts behind some of these structures are already quite familiar to you. For 
 example, there is a structure known as a
  stack
  that is similar to a stack of plates or trays, 
 but instead of plates we work with data that is only added or removed from the top of the 
 stack. Another data structure is a
  queue 
 which is similar to a line at a checkout counter, but 
 instead of customers, we work with data that is added to the back of the queue but 
 removed from the front of the queue. In contrast to stacks and queues, other ways of 
 organizing data, such as in a binary
  tree
 , probably aren’t familiar to you. The reason there 
 are different types of data structures is that there is no single “best” data structure: one 
 structure may be ideal for solving one type of problem but poorly suited for solving 
 problems of a different type.
  
 In this chapter we introduce what is perhaps the simplest data structure but also 
 arguably the most important, a
  list
 .
 1
 You are already well acquainted with lists and have 
 certainly been using them for most of your life. Perhaps you’ve written “to do” lists, grocery 
 lists, invitation lists, or wish lists. You’ve seen lists of capitals, countries, colleges, and 
 courses. Lists may be organized in a particular order, such as a top-ten list, or in no 
 particular order, such as the list of nominees for the Academy Awards. Clearly, lists are a 
 part of our daily lives.
  
 When we create a list, it serves to collect the associated data into one convenient 
 “place.” There is the list as a whole and then there are the individual items in the list which 
 we typically refer to as the
  elements
  of the list. In Python, a list is an object with its own 
 class, the list class. Thus, we will typically use Courier font when we refer to a list in the 
 Python sense of the word. Since a list is an object, there are various methods that come 
 with it. We will explore a few of these in this chapter.
  
 In the implementation of algorithms, it is quite common that certain statements need to 
 be repeated multiple times. Thus, computer languages invariably provide ways to construct
  
 loops
 . In this chapter we will also introduce one such construct: a for-loop. In Python a for-
 loop is a form of
  definite loop
 , meaning that the number of passes through the loop can be 
 determined in advance (or, said another way, the number of times the loop will execute is 
 known
  a priori
 ). So, for example, we might write a for-loop to do something with each 
 element in a list of five items. We thus know the loop will execute five times. On the other 
 hand, as we will see in Sec. 11.6, there",NA
6.1,NA,NA
lists,"In Python a list is created when comma-separated expressions are placed between square 
 brack-ets. For example, [1, ""two"", 6 / 2] is a list. This list has three elements: the first is an 
 integer (1); the second is a string (""two""); and the third is a float since 6 / 2 evaluates to 3.0. 
 Note that Python will evaluate each expression to determine the value of each element of 
 the list. A list can be either homogeneous, containing only one type of data, or 
 inhomogeneous, containing different types of data. The example above is inhomogeneous 
 since it contains an inte-ger, a string, and a float. (Since a list is a form of data, a list can, in 
 fact, contain another list as one of its elements!) 
  
 lists can be assigned to a variable or returned by a function. This is demonstrated in Listing 
 6.1 where a list is assigned to x in line 1. The print() statement in line 2 shows the result of 
 this assignment. The function f(), defined in lines 4 and 5, returns a list that contains the first 
 four multiples of the parameter passed to the function (actually, as described in more detail 
 below, this is something of an understatement of what f() can do).
  
 Listing 6.1
  lists can be assigned to a variable and returned by a function.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15
  
  
 >>>
  x = [1,
  ""two""
 , 6 / 2] 
  
 >>>
  print
 (x) 
  
 [1, ’two’, 3.0]  
 >>>
  def
  f(n):
  
 ... ...
  
 return
  [n, 2 * n, 3 * n, 4 * n]
  
 >>>
  f(2) 
  
 [2, 4, 6, 8]  
 >>>
  y = f(49) 
  
 >>>
  type
 (y) 
  
 <class ’list’>  
 >>>
  print
 (y) 
  
 [49, 98, 147, 196]  
 >>>
  f(
 ’yo’
 ) 
  
 [’yo’, ’yoyo’, ’yoyoyo’, ’yoyoyoyo’] 
  
 In line 8 we see the list produced by the function call f(2) in line 7. In line 9 the list returned 
 by f(49) is assigned to the variable y. Lines 10 and 11 show that y has a type of list. Then, in 
 line 12, a print() statement is used to display y.",NA
6.2,NA,NA
list Methods,"Because list is a class, the objects in this class (or, said another way, the instances of this 
 class) will have various methods and attributes which can be listed using the dir() function. 
 Additionally, operator overloading can be used with lists. As with strings, we can use the 
 plus sign to concatenate lists and the multiplication sign for repetition. The length of a list 
 (or tuple) can be determined using the built-in function len(). Listing 6.3 illustrates these 
 features and also demonstrates the creation of a list with no element, i.e., a so-called
  empty 
 list
  (which we will have occasion to use later).
  
 Listing 6.3
  Demonstration of list concatenation, the len() function, and some of the methods 
 available for lists.
  
 1 
  
 2
  
  
 >>>
  # Concatenate two lists.
  
 >>>
  w = [
 ’a’
 ,
  ’bee’
 ,
  ’sea’
 ] + [
 ""solo""
 ,
  ""duo""
 ,
  ""trio""
 ]",NA
6.3,NA,NA
for-Loops,"The previous section showed some examples of creating a list. When we displayed the lists, 
 we simply displayed the entire list. However, we are often interested in working with the 
 indi-vidual elements of a list. A for-loop provides a convenient way to do this. for-loops can 
 be used with more than just lists. In Python lists are considered a type of
  iterable
 . An 
 iterable is a data type that can return its elements separately, i.e., one at a time. for-loops 
 are, in general, useful when working with any iterable, but here we are mainly concerned 
 with using them with lists.",NA
6.4,NA,NA
Indexing,"As shown in the previous section, for-loops provide a convenient way to sequentially 
 access all the elements of a list. However, we often want to access an individual element 
 directly. This is accomplished by enclosing the
  index
  of the element in square brackets 
 immediately following the list itself (or a list identifier). The index must be an integer (or 
 an expression that returns an integer). You are undoubtedly used to associating an index of 
 one with the first element of a list. However, this is
  not
  what is done in many computer 
 languages. Instead, the first element of a list has an index of zero. Although this may seem 
 strange at first, there are compelling reasons for this. In Python (and in C, C++, Java, etc.), 
 you should think of the index as representing the offset from the start of the list. Thus, an 
 index of zero represents the first element of a list, one is the index of the second element, 
 and so on. Pausing for a moment, you may realize that we already have a general way to 
 obtain the index of the last element in the list. This is demonstrated in Listing 6.7.",NA
range(),"CHAPTER 6. LISTS AND
  FOR
 -LOOPS",NA
6.5,"In line 2 of Listing 6.8 a list called indices was created that contains the valid indices for the 
 list fruits. We are indeed often interested in accessing each element of a list via an index. 
 However, it would be quite inconvenient if we always had to create an indices list, as was 
 done in Listing 6.8, that explicitly listed all the indices of interest. Fortunately there is a 
 much better way to obtained the desired indices.
  
 Python provides a function, called range(), that generates a sequence of integers. We can use 
 this function to generate the integers corresponding to all the valid indices for a given list. 
 Or, as you will see, we can use it to generate some subset of indices. The range() function 
 does not actually produce a list of integers.
 5
 However, we can force range() to show the 
 entire sequence of values that it ultimately produces if we enclose range() in the function 
 list().
 6 
 The range() function is used as indicated in Listing 6.9.
  
 Listing 6.9
  The range() function and its parameters. Parameters in brackets are optional. 
 See the text for further details.
  
 range
 ([start,] stop [, increment])
  
 In its most general form, the range() function takes three parameters that we identify as 
 start, stop, and increment. The start and increment parameters are optional and hence are 
 shown in square brackets.
 7
 When they are not explicitly provided, start defaults to zero and 
 increment defaults to positive one. There is no default value for stop as this value must 
 always be provided explicitly. When two parameters are given, they are taken to be start 
 and stop.
  
 The first integer produced by range() is start. The next integer is given by start + 
 increment, the next is start + 2 * increment, and so on. increment may be positive or 
 negative, so the values may be increasing or decreasing. Integers continue to be produced 
 until reaching the last value “before” stop. If increment is positive, the sequence of integers 
 ends at the greatest value that is still strictly less than stop. On the other hand, if increment 
 is negative, then the sequence ends with the smallest value that is still strictly greater than 
 stop.
  
 Admittedly, it can be difficult to understand what a function does simply by reading a 
 descrip-tion of it (such as given in the previous paragraph). However, a few examples 
 usually help clarify the description. Listing 6.10 provides several examples illustrating the 
 behavior of the range() function. The list() function is used so that we can see, all at once, 
 the values produced by range().
  
  
 5
 range() returns an
  iterable
  that can be used in a for-loop header. With each pass of the loop, the range() 
 function provides the next integer in the sequence.
  
 6
 The built-in function list() attempts to convert its argument to a list. If the conversion is not possible, an 
 exception is raised (i.e., an error is generated). Thus, as with int(), float(), and the str() function, the list() 
 function performs a form of data conversion. The reason we avoid using “list” as a variable name is so that we 
 don’t mask this function in a manner similar to the way print() was masked in Listing 2.16.
  
  
 7
 This way of indicating optional arguments is fairly common and the square brackets here have nothing to 
 do with lists.",NA
6.6,NA,NA
"Mutability, Immutability, and Tuples","A list serves as a way to collect and organize data. As shown above, we can append or 
 extend a list. But, we can also change the values of individual elements of a list. We say that 
 a list is mutable which merely means we can change it. The mutability of lists is 
 demonstrated in Listing 6.12.
  
 Listing 6.12
  Demonstration of the mutability of a list.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 >>>
  x = [1, 2, 3, 4] 
  
 # Create list of integers.
  
 >>>
  x[1] = 10 + 2 
  
 # Change second element.
  
 >>>
  x 
  
 # See what x is now.
  
 [1, 12, 3, 4] 
 >>>
  x[
 len
 (x) - 1] =
  ""the end!"" 
  
 # Change last element to a string.
  
 >>>
  x
  
 [1, 12, 3, ’the end!’] 
  
 A list x is created in line 1. In line 2 the second element of the list is assigned a new value 
 (that is obtained from the expression on the right). Lines 3 and 4 display the change. In line 
 5 the last element of x is set equal to a string. Note that it does not matter what the 
 previous type of an element was—we are free to set an element to anything we wish.
  
 It is worthwhile to spend a bit more time considering line 2. Line 2 employs the 
 assignment operator. Previously we said that, in statements such as this, the expression to 
 the right of the equal sign is evaluated and then the resulting value is assigned to the
  lvalue
  
 to the left of the equal sign. You may have wondered why we didn’t just say “assigned to the
  
 variable
  to the left of the equal sign” or “to the
  identifier
  to the left of the equal sign.” Line 2 
 shows us the reason for using lvalue instead of variable. If, in line 2, we had written x = 10 + 
 2, then we would indeed have assigned the value on the right to the variable on the left 
 (and, in this case, x would now point to the int 12 rather than to the list it was originally 
 assigned). But, instead, in line 2 we have x[1] = 10 + 2. In this case the variable x is 
 associated with the entire list while x[1] is a single",NA
6.7,NA,NA
Nesting Loops in Functions,"It is possible to have a for-loop contained within the body of a function: The for-loop is said 
 to be
  nested
  inside the function. Since a for-loop has a body of its own, its body must be 
 indented farther than the statements of the body in which it is nested. Listing 6.15 provides 
 a template for a for-loop nested inside a function. As indicated in lines 2 and 5, there can be 
 code both before and after the loop, though neither is required.
  
 8
 But, in fact, the original tuple wasn’t changed—if another variable references this data, the tuple will 
 persist in memory in its original form. The list that is created is a
  copy
  of the tuple that will occupy different 
 memory than the tuple. As mentioned, if this new list is assigned to the same identifier as was used for the 
 tuple, then this identifier references this new list/new memory. However, the assignment, in itself, does not 
 destroy the original tuple.",NA
6.8,NA,NA
Simultaneous Assignment with Lists,"Simultaneous assignment is discussed in Sec. 2.4. In simultaneous assignment there are 
 two or more comma-separated expressions to the right of the equal sign and an equal 
 number of comma-separated lvalues to the left of the equal sign. As discussed in Sec. 6.6, a 
 comma-separated collec-tion of expressions automatically forms a tuple (whether or not it 
 is surrounded by parentheses). Thus, another way to think of the simultaneous assignment 
 operations we have seen so far is as fol-lows: The number of lvalues to the left of the equal 
 sign must be equal to the number of elements in the tuple to the right of the equal sign.
  
 Given the claim in Sec. 6.6 that lists and tuples are nearly identical (with the exception 
 that lists are mutable and tuples are not), one might guess that lists can be used in 
 simultaneous assignment statements too. This is indeed the case. Listing 6.19 illustrate this.
  
 Listing 6.19
  Demonstration that lists, like tuples, can be used in simultaneous assignment 
 statements. The assignments in lines 1 and 4 involve tuples while the ones in lines 7 and 11 
 involve lists. All behave the same way in terms of the actual assignment to the lvalues on 
 the left side of the equal sign.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13
  
  
 >>>
  x, y, z = 1, 2, 3 
  
 # Tuple to right, without parentheses.
  
 >>>
  print
 (x, y, z) 
  
 1 2 3  
 >>>
  r, s, t = (1, 2, 3)
  # Tuple to right, with parentheses.
  
 >>>
  print
 (r, s, t) 
  
 1 2 3  
 >>>
  a, b, c = [1, 2, 3]
  # List to right.
  
 >>>
  print
 (a, b, c) 
  
 1 2 3  
 >>>
  xlist = [1, 2, 3] 
  
 >>>
  i, j, k = xlist 
  
 >>>
  print
 (i, j, k) 
  
 1 2 3",NA
6.9,NA,NA
Examples,"In this section we present three examples that demonstrate the utility of lists, for-loops, and 
 the range() function. We also introduce the concept of an accumulator.",NA
6.9.1 ,NA,NA
Storing Entries in a,NA,NA
 list,"Assume we want to allow the user to enter a list of data. For now we will require that the 
 number of entries be specified in advance and that the entries will be simply stored as 
 strings (if we want to store integers or floats, we can use, as appropriate, int(), float(), or 
 eval() to perform the desired conversion of the input).",NA
6.9.2 ,NA,NA
Accumulators,"Often we want to perform a calculation that requires the accumulation of values, i.e., the 
 final value is the result of obtaining contributions from multiple parts. Assume we want to 
 find the value of the following series, where
  N
  is some integer value:
  
 1 + 1 2 + 1 3 + 1 4 +
  · · ·
  + 1 
 N .
  
 You may already be familiar with the mathematical representation of this series where one 
 would
  
 write:
  
 N
  
 k
 = 1 + 1 2 + 1 3 + 1 4 +
  · · ·
  + 1 
 N .
  
  
 k
 =1
  
 The symbol Σ is the Greek letter sigma which we use to stand for “sum.” The term below 
 Σspecifies the starting value of the “summation variable.” In this case the summation 
 variable is
  k 
 and it starts with a value of 1. The term above Σ specifies the final value of this 
 variable. In this particular case we haven’t yet said explicitly what the final numeric value 
 is. Instead, we write that the final value is
  N
  with the understanding that this has to be 
 specified (as an integer) when we actually calculate the series. The expression immediately 
 to the right of Σ is a general expression for the individual terms in the sum—the actual 
 value is obtained by plugging in the value of the summation variable as it varies between 
 the initial and final values.
  
 We can’t calculate this series all at once. Instead, we start with the first term in the 
 series. We then add the next term. We store this result and then add the next term, and so 
 on. Thus we 
 accumulate
  the terms until we have added all of them. For example, if
  N
  is 4, 
 we start with the first term of 1 (
 k
  = 1). We add 0.5 (
 k
  = 2) to obtain 1.5. We add 0.33333... 
 (
 k
  = 3) to obtain 1.83333. . . ; and then we add 0.25 (
 k
  = 4) to obtain 2.0833333....
  
 Problems that involve the accumulation of data are quite common. Typically we 
 initialize an identifier to serve as an
  accumulator
 . This initialization involves setting the 
 accumulator to an appropriate value outside a for-loop. Then, in the body of the loop, the 
 desired data contribute to the accumulator as necessary. An accumulator is essentially a 
 variable that is used to accumulate information (or data) with each pass of a loop. When an 
 accumulator is modified, its new value is based in some way on its previous value. The 
 example in Listing 6.21 actually also involves an accumulator, albeit of a different type. In 
 that example we accumulated strings into a list. The accumulator is the list names which 
 started as an empty list.",NA
6.9.3 ,NA,NA
Fibonacci Sequence,"The Fibonacci sequence starts with the numbers 0 and 1. Then, to generate any other 
 number in the sequence, you add the previous two. In general, let’s identify numbers in the 
 sequence as
  F
 n 
 where
  n
  is an index that starts from 0. We identify the first two numbers in 
 the sequence as
  F
 0
  = 0",NA
6.1,NA,NA
Chapter Summary,"A list is a sequential collection of data. The
  
 Repetition of a list can be obtained using the
  
 data can differ in terms of type, i.e., a list can 
 be inhomogeneous.
  
 *operator (where one of the operands is a list 
 and the other is an integer).
  
 lists can be created by enclosing comma-
  
 The
  append()
  method can be used to ap-
  
 separated expressions in square brackets, e.g.,
  
 pend its argument to the end of a list. The
  
 [2, ""t"", 1 + 1].
  
 extend()
  method can be used to add the ele-
  
 An empty list has no elements, i.e., [] is an 
 empty list.
  
 ments of the argument list to the list for
  
 which the method is invoked.
  
 The
  sort()
  
 method sorts the elements of a list in place,
  
 Two lists can be concatenated using the + op-
 erator.
  
 i.e., a new list isn’t created but rather the 
 orig-inal list is changed.
  
 An individual element of a list can be ac-",NA
6.11,NA,NA
Review Questions,"1. True or False: The length of a list is given by the length() function.
  
 2. True or False: The index for the first element of a list is 1, e.g., xlist[1] is the first 
 element of the list xlist.
  
 3. What is the output produced by the following code?
  
 xlist = [] 
  
 xlist.append(5) 
  
 xlist.append(10) 
  
 print
 (xlist)",NA
Chapter 7,NA,NA
"More on for-Loops, Lists, and Iterables","The previous chapter introduced lists, tuples, the range() function, and for-loops. The 
 reason for introducing these concepts in the same chapter is because either they are closely 
 related (as is true with lists and tuples) or they are often used together (as is true, for 
 example, with the range() function and for-loops). In this chapter we want to extend our 
 understanding of the ways in which for-loops and iterables can be used. Although the 
 material in this chapter is often presented in terms of lists, you should keep in mind that the 
 discussion almost always pertains to tuples too—you could substitute a tuple for a list in the 
 given code and the result would be the same. (This is not true only when it comes to code 
 that assigns values to individual elements. Recall that lists are mutable but tuples are not. 
 Hence, once a tuple is created, we cannot change its elements.) 
  
 The previous chapter mentioned that a list can have elements that are themselves lists, but 
 no details were provided. In this chapter we will dive into some of these details. We will also 
 consider nested for-loops, two new ways of indexing (specifically
  negative indexing
  and
  
 slicing
 ), and the use of strings as
  sequences
  or iterables. We start by considering nested for-
 loops.",NA
7.1,NA,NA
for,NA,NA
#NAME?,NA,NA
 for,NA,NA
#NAME?,"There are many algorithms that require that one loop be
  nested
  inside another. For 
 example, nested loops can be used to generate data for a table where the inner loop 
 dictates the column and the outer loop dictates the row. In fact, it is not uncommon for 
 algorithms to require several levels of nesting (i.e., a loop within a loop within a loop and so 
 on). As you will see, nested loops are also useful for processing data organized in the form 
 of lists within a list. We start this section by showing some of the general ways in which for-
 loops can be nested. This is presented primarily in terms of generating various patterns of 
 characters. After introducing lists of lists (in Sec. 7.2) we will consider more practical 
 applications for nested for-loops.
  
 Assume we want to generate the following output:
  
 1
  
  
 2
  
  
 3
  
  
 1 
  
 12 
  
 123
  
  
  
 From the file: more-on-iterables.tex",NA
7.2,NA,NA
lists of lists,"A list can contain a list as an element or, in fact, contain any number of lists as elements. 
 When one list is contained within another, we refer to this as
  nesting
  or we may say that 
 one list is
  embedded
  within another. We may also refer to an
  inner
  list which is contained in 
 a surrounding
  outer
  list. Nesting can be done to any level. Thus, for example, you can have a 
 list that contains a list that contains a list and so on.
  
 Listing 7.7 illustrates the nesting of one list within another.
  
 2
 Unfortunately, if the user specifies that the number of rows or columns is greater than 11 (so that the row 
 or column indices have more than one digit), the ordered pairs will no longer line up as nicely as shown here. 
 When we cover string formatting, we will see ways to ensure the output is formatted “nicely” even for 
 multiple digits.",NA
7.2.1 ,NA,NA
Indexing Embedded lists,"We know how to index the elements of a list, but now the question is: How do you index the 
 elements of a list that is embedded within another list? To do this you simply add another 
 set of brackets and specify within these brackets the index of the desired element. So, for 
 example, if the third element of xlist is itself a list, the second element of this embedded list 
 is given by xlist[2][1]. The code in Listing 7.10 illustrates this type of indexing.
  
 Listing 7.10
  Demonstration of the use of multiple brackets to access an element of a nested 
 list.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15
  
  
 >>>
  toyota = [
 ""Toyota""
 , [
 ""Prius""
 ,
  ""4Runner""
 ,
  ""Sienna""
 ,
  ""Camry""
 ]] 
 >>>
  toyota[0]
  
 ’Toyota’ 
 >>>
  toyota[1] 
  
 [’Prius’, ’4Runner’, ’Sienna’, ’Camry’]  
 >>>
  toyota[1][0]
  
 ’Prius’ 
 >>>
  toyota[1][3]
  
 ’Camry’ 
 >>>
  len
 (toyota) 
  
 # What is length of outer list?
  
 2  
 >>>
  len
 (toyota[1]) 
  
 # What is length of embedded list?
  
 4  
 >>>
  toyota[1][
 len
 (toyota[1]) - 1]
  
 ’Camry’ 
  
 In line 1 the list toyota is created with two elements: a string and an embedded list of four 
 strings. Lines 2 and 3 display the first element of toyota. In lines 4 and 5 we see that the 
 second element of toyota is itself a list. In line 6 two sets of brackets are used to specify the 
 desired element. Interpreting these from right to left, these brackets (and the integers they 
 enclose) specify that we want the first element of the second element of toyota. The first set 
 of brackets (i.e., the left-most brackets) contains the index 1, indicating the second element 
 of toyota, while the second set of brackets contains the index 0, indicating the first element 
 of the embedded list. Despite the fact that we (humans) might read or interpret brackets 
 from right to left, Python evaluates multiple brackets from left to right. So, in a sense, you 
 can think of toyota[1][0] as being equivalent to (toyota[1])[0], i.e., first we obtain the list 
 toyota[1] and then from this we obtain the first element. You can, in fact, add parentheses 
 in this way, but it isn’t necessary or recommended. You should, instead, become familiar 
 and comfortable with this form of multi-index notation as it is used in many computer 
 languages.
  
 Lines 10 and 11 of Listing 7.10 show the length of the toyota list is 2—as before, the 
 embedded list counts as one element. Lines 12 and 13 show the length of the embedded list 
 is 4. Line 14 uses a rather general approach to obtain the last element of a list (which here
  
 be wrapped around at the border of the screen. This wrapping is not because of newline characters 
 embedded in the output, but rather is a consequence of the way text is handled that is wider than can be",NA
7.2.2 ,NA,NA
Simultaneous Assignment and lists of lists,"We have seen that lists can be used with simultaneous assignment (Sec. 6.8). When dealing 
 with embedded lists, simultaneous assignment is sometimes used to write code that is 
 much more readable than code that does not employ simultaneous assignment. For 
 example, in the code in Listings 7.11 and 7.12 the list toyota was created. The element 
 toyota[0] contains the make while toyota[1] contains the models. When writing a program 
 that may have multiple functions and many lines of code, it may be easy to lose sight of the 
 fact that a particular element maps to a particular thing. One way to help alleviate this is to 
 “unpack” a list into parts that are associated with appropriately named variables. This 
 unpacking can be done with simultaneous assignment. Listing 7.14 provides an example.
 5
  
 Listing 7.14
  Demonstration of “unpacking” a list that contains an embedded list. Simul-
 taneous assignment is used to assign the elements of the toyota list to appropriately named 
 variables.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11
  
  
 >>>
  toyota = [
 ""Toyota""
 , [
 ""Prius""
 ,
  ""4Runner""
 ,
  ""Sienna""
 ,
  ""Camry""
 ]] 
 >>>
  make, models 
 = toyota 
 # Simultaneous assignment.
  
 >>>
  
 make
  
 ’Toyota’ 
 >>>
  for
  model
  in
  models:
  
 ...
  
 print
 (
 ""
  
 ""
 , model)
  
 ...
  
 Prius  
 4Runner  
 Sienna  
 Camry 
  
 In line 1 the toyota list is created with the brand name (i.e., the make) and an embedded list 
 of models. Line 2 uses simultaneous assignment to “unpack” this two-element list to two 
 appropriately named variables, i.e., make and models. Lines 3 and 4 show make is correctly 
 set. The for-loop in lines 5 and 6 cycles through the models list to produce the output 
 shown in lines 8 through 11.
  
 Let us consider another example where the goal now is to write a function that cycles 
 through a list of artists similar to the list that was constructed in Listing 7.9. Let’s call the 
 function show artists(). This function should cycle through each element (i.e., each artist) of 
 the list it is passed. For each artist it should display the name and the songs associated with 
 the artist. Listing 7.15 shows a suitable implementation of this function.
  
 5
 This is somewhat contrived in that a list is created and then immediately unpacked. Try instead to 
 imagine this type of unpacking being done in the context of a much larger program with multiple lists of 
 brands and lists being passed to functions.",NA
7.3,NA,NA
References and list Mutability,"In Sec. 4.4 we discussed the scope of variables. We mentioned that we typically want to 
 pass data into a function via the parameters and obtain data from a function using a return 
 statement. However, because a list is a mutable object, the way it behaves when passed to a 
 function is somewhat different than what we have seen before. In fact, we don’t even have 
 to pass a list to a function to observe this different behavior. In this section we want to 
 explore this behavior. The primary goal of the material presented here is to help you 
 understand the cause of bugs that may appear in your code. We do not seek to fully flesh 
 out the intricacies of data manipulation and storage in Python.
  
 First, recall that when we assign a value, such as an integer or float, to a variable and 
 then assign that variable to a second variable, changes to the first variable do not 
 subsequently affect the second variable (or vice versa). This is illustrated in the following 
 (please read the comments embedded in the code):
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 >>>
  x = 11 
  
 # Assign 11 to x.
  
 >>>
  y = x 
  
 # Assign value of x to y
  
 >>>
  print
 (x, y) 
  
 # Show x and y.
  
 11 11",NA
"x = [2, “two”]",(b),NA
"x = [2, “two”] ",NA,NA
x.append(4 / 2),(c),NA
"x = [2, “two”] ",NA,NA
x.append(4 / 2) ,NA,NA
y = x,(d),NA
"x = [2, “two”] ",NA,NA
x.append(4 / 2) ,NA,NA
y = x ,NA,NA
y[1] = x[0] + x[2],(e),NA
"x = [2, “two”] ",NA,NA
x.append(4 / 2) ,NA,NA
y = x ,NA,NA
y[1] = x[0] + x[2] ,NA,NA
x = 5,"Namespace
  
 Names",NA
x,Objects,NA
"[ , ]",NA,NA
2,NA,NA
“two”,"Namespace
  
 Names",NA
x,Objects,NA
"[ , , ]",NA,NA
2,NA,NA
“two”,NA,NA
2,"Namespace
  
 Names",NA
x ,NA,NA
y,Objects,NA
"[ , , ]",NA,NA
2,NA,NA
“two”,NA,NA
2,"Namespace
  
 Names",NA
x ,NA,NA
y,Objects,NA
"[ , , ]",NA,NA
2,NA,NA
4,NA,NA
2,"Namespace
  
 Names",NA
x ,NA,NA
y,Objects,NA
"[ , , ]",NA,NA
2,NA,NA
4,NA,NA
2,NA,NA
5,"Figure 7.1: Depiction of the behavior of a namespace when various statements are issued 
 involving a list.",NA
7.4,NA,NA
Strings as Iterables or Sequences,"We will have much more to say about strings in Chap. 9, but it is appropriate now to 
 consider a couple of aspects of strings. As you know, strings are a sequential collection of 
 characters. As such, each character has a well defined position within the string. This is 
 similar to the elements within lists and tuples. Thus, it may come as no surprise that we can 
 access individual characters in a string by indicating the desired character with an integer 
 index enclosed in square brackets following the string. As with lists and tuples, an index of 0 
 is used for the first character of a string—the index represents the offset from the beginning. 
 Additionally, the len() function provides the length of a string, i.e., the total number of 
 characters. The individual characters of a string are themselves strings (with lengths of 1).
 7 
  
 Listing 7.22 illustrates accessing individual characters of a string by explicit indexing.
  
 Listing 7.22
  Explicit indexing used to access the characters of a string. As with tuples and 
 lists, the index represents the offset from the beginning.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11
  
  
 >>>
  hi =
  ""Hello World!"" 
  
 >>>
  hi[0] 
  
 # First character.
  
 ’H’ 
 >>>
  hi[6] 
  
 # Seventh character.
  
 ’W’ 
  
 # Length of string. 
 >>>
  
 len
 (hi) 
  
 12  
 >>>
  hi[
 len
 (hi) - 1] 
  
 # Last character.
  
 ’!’ 
 >>>
  print
 (hi[0], hi[1], hi[5], hi[7], hi[9], hi[10], hi[11], sep =
  """"
 ) 
 He old! 
  
  
  
 7
 In some computer languages individual characters have a different data type than strings, but this is
  not
  
 the case in Python.",NA
7.5,NA,NA
Negative Indices,"In addition to the positive indexing we have been using, an element of a sequence can also 
 be specified using a
  negative
  index. In terms of negative indexing, the last element of a 
 sequence has an index of -1. When the last element of a sequence is desired, it is generally 
 more convenient to use negative indexing. For example, if one is interested in the last 
 element of the list xlist, it is certainly more convenient to write xlist[-1] than xlist[len(xlist) 
 - 1].
  
 Listing 7.25 shows the positive and negative indices for the string ""Hello!"". The positive 
 indices vary between zero and one less than the length (corresponding to the first and last 
 char-acters, respectively). The negative indices vary between the negative of the length to -
 1 (again, corresponding to the first and last characters, respectively).
  
 Listing 7.25
  Positive and negative indices for the string ""Hello!"".
  
  
 0 
 1 
 2 
 3 
 4 
 5 
 <=> Positive indices 
 +---+---+---+---+---+---+ 
 | H | e | l | l | o | ! | 
 +---+---+---+---+---+---+ 
 -6 
 -5 
 -4 
 -3 
 -2 
 -1 
 <=> Negative indices 
  
 Listing 7.26 demonstrates negative indexing to access characters of a string. A six-
 character string is created in line 1 and assigned to the variable hi. The first element is 
 accessed in line 2 by explicitly putting the negative index corresponding to the first 
 character. In line 4 the len() function is used to obtain an expression that, in general, 
 produces the first character of a string of arbitrary length. In line 6 the last character of the 
 string is accessed.
  
 Listing 7.26
  Demonstration of negative indexing for a string. Elements of a tuple or a list 
 can also be accessed using negative indexing.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16
  
  
 >>>
  hi =
  ""Hello!"" 
  
 # Create a six-character string.
  
 >>>
  hi[-6] 
  
 # Explicitly access first element.
  
 ’H’ 
 >>>
  hi[-
 len
 (hi)] 
  
 # General construct for accessing first element.
  
 ’H’ 
 >>>
  hi[-1] 
  
 # Last element of string.
  
 ’!’ 
 >>>
  for
  i
  in range
 (1,
  len
 (hi) + 1): 
  
 ... 
  
 print
 (-i, hi[-i]) 
  
 ...
  
 -1 ! 
 -2 o 
 -3 
 l 
 -4 
 l 
 -5 e 
 -6 H",NA
7.6,NA,NA
Slicing,"Slicing provides a convenient way to extract or access a subset of a sequence. In many ways 
 slicing is akin to the two-argument or three-argument forms of the range() function. To 
 obtain a slice of a sequence, one specifies an integer start value and an integer stop value. 
 These values are given in square brackets following the sequence (where one would 
 normally provide a single index). These start and stop values are separated by a colon. The 
 resulting slice is the portion of the original sequence that starts from the index start and 
 ends just before stop. For example, assuming xlist is a list and that the start and stop values 
 are both non-negative, the expression
  
 xlist[start : stop]
  
 returns a new list with elements
  
 [xlist[start], xlist[start + 1], ..., xlist[stop - 1]]
  
 If start is omitted, it defaults to 0. If stop is omitted, it defaults to the length of the sequence.
  
 As a slight twist on the description above, positive or negative indices can be used for 
 either the start or stop value. As before, when one index is positive and the other negative, 
 the resulting slice starts with the specified start index and progresses up to, but does not 
 include, the stop index. However, when using indices of mixed sign, one cannot interpret 
 the resulting slice in terms of the indexing shown above (where the index of successive 
 elements is incremented by +1 from the start). Instead, one has to translate a negative 
 index into its equivalent positive value. This fact will become more clear after considering a 
 few examples.
  
 Listing 7.27 provides various examples of slicing performed on a string. The comments in 
 the code provide additional information.
  
 Listing 7.27
  Demonstration of slicing a string.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11
  
   
 >>>
  #
  
 0123456789012345
  
 -> index indicator
  
 >>>
  s =
  ""Washington State""
  # Create a string.
  
 >>>
  s[1 : 4] 
 # Second through fourth characters.
  
 ’ash’ 
 >>>
  s[ : 4] 
 # Start through fourth character.
  
 ’Wash’ 
 >>>
  s[4 : 6] 
 # Fifth and sixth characters.
  
 ’in’ 
 >>>
  s[4 : ] 
 # Fifth character through the end.
  
 ’ington State’ 
 >>>
  s[-3 : ] 
 # Third character from end to end.",NA
7.7,NA,NA
list Comprehension (optional),"We often need to iterate through the elements of a list, perform operation(s) on those 
 elements, and store the resulting values in a new list, leaving the original list unchanged. 
 Although this can be accomplished using a for-loop, to make this pattern easier to 
 implement and more concise, Python provides a construct known as
  list comprehension
 . The 
 syntax may look strange at first, but if you understand the fundamentals of lists and for-
 loops you have all the tools you need to understand list comprehensions!
 10 
  
 Recall the function doubler() from Listing 7.21 that doubled the elements of a list. This 
 doubling was done “in place” such that the list provided as an argument to the function had 
 its el-ements doubled. Now we want to write a function called newdoubler() that, like 
 doubler(), doubles every element of the list provided as an argument. However, 
 newdoubler() does not modify the original list argument. Instead, it returns a new list 
 whose elements are double
  
  
 10
 Despite the elegance and utility of list comprehensions, they will not be used in the remainder of this book 
 and hence the material in this section is not directly relevant to any material in the subsequent chapters.",NA
7.8,NA,NA
Chapter Summary,"One for-loop can be nested inside another.
  
 specifies the inner element. For example, if x
  
 One list can be nested inside another. Ele-
 ments of the outer list are specified by one 
 index enclosed in brackets. An element of an 
 in-terior list is specified by two indices 
 enclosed
  
 corresponds to the list [[1, 2], [’a’,
  
 ’b’, ’c’]],
  
 then x[1] corresponds to
  
 [’a’, ’b’, ’c’] and x[1][2] corre-sponds to ’c’.
  
 in two pairs of brackets. The first index spec-
  
 Nesting can be done to any level. Specification
  
 ifies the outer element and the second element
  
 of an element at each level requires a separate",NA
7.9,NA,NA
Review Questions,"1. What output isproduced by the following code?
  
 xlist = [1, [1, 2], [1, 2, 3]] 
  
 print
 (xlist[1])
  
 2. What output is produced by the following code?
  
 xlist = [1, [1, 2], [1, 2, 3]] 
  
 print
 (xlist[1][1])
  
 3. What output is produced by the following code?
  
 xlist = [1, [1, 2], [1, 2, 3]] 
  
 print
 (xlist[1] + [1])
  
 4. What output is produced by the following code?
  
 def
  sum_part(xlist, n): 
  
 sum
  = 0 
  
 for
  x
  in
  xlist[n]:",NA
Chapter 8,NA,NA
Modules and import Statements,"The speed and accuracy with which computers perform computations are obviously 
 important for solving problems or implementing tasks. However, quick and accurate 
 computations, by them-selves, cannot account for the myriad ways in which computers 
 have revolutionized the way we live. Assume a machine is invented that can calculate the 
 square root of an arbitrary number to any desired precision and can perform this 
 calculation in a single attosecond (10
 −
 18
 seconds). This is far beyond the ability of any 
 computer currently in existence. But, assume this machine can only calculate square roots. 
 As remarkable as this machine might be, it will almost certainly not revolutionize human 
 existence.
  
 Coupled with their speed and accuracy, it is flexibility that makes computers such 
 remarkable devices. Given sufficient time and resources, computers are able to solve any 
 problem that can be described by an algorithm. As discussed in Chap. 1, an algorithm must 
 be translated into instruc-tions the computer understands. In this book we write 
 algorithms in the form of Python programs. So far, the programs we have written use built-
 in operators, built-in functions (or methods), as well as functions that we create.
  
 At this point it is appropriate to ask: What else is built into Python? Perhaps an engineer 
 wants to use Python and needs to perform calculations involving trigonometric functions 
 such as sine, cosine, or tangent. Since inexpensive calculators can calculate these functions, 
 you might expect a modern computer language to be able to calculate them as well. We’ll 
 return to this point in a moment. Let’s first consider a programmer working in the 
 information technology (IT) group of a company who wants to use Python to process Web 
 documents. For this programmer the ability to use sophisticated string-matching tools that 
 employ what are known as
  regular expressions
  might be vitally important. Are functions for 
 using regular expressions built into Python? Note that an engineer may never need to use 
 regular expressions while a typical IT worker may never need to work with trigonometric 
 functions. When you consider all the different ways in which program-mers want to use a 
 computer, you quickly realize that it is a losing battle to try to provide all the built-in 
 features needed to satisfy everybody.
  
 Rather than trying to anticipate the needs of all programmers, at its core Python 
 attempts to remain fairly simple. We can, in fact, obtain a list of all the “built-ins” in Python. 
 If you is-
  
 sue the command dir() with no arguments, you obtain a list of the methods and attributes
  
 currently defined. One of the items in this list is
  
 builtins . If we issue the command
  
 From the file: import.tex",NA
8.1,NA,NA
Importing Entire Modules,"The math module provides a large number of mathematical functions. To gain access to 
 these functions, we can write the keyword import followed by the name of the module, e.g., 
 math. We typically write this statement at the start of a program or file of Python code. By 
 issuing this statement we create a module object named math. The “functions” we want to 
 use are really methods of this object. Thus, to access these methods we have to use the 
 “dot-notation” where we provide the object name, followed by a dot (i.e., the access 
 operator), followed by the method name. This is illustrated in Listing 8.2. The code is 
 discussed following the listing.
  
 Listing 8.2
  Use of an import statement to gain access to the methods and attributes of the 
 math module.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10
  
  
 >>>
  import
  math 
  
 >>>
  type
 (math) 
  
 <class ’module’>  
 >>>
  dir
 (math) 
  
 [’__doc__’, ’__file__’, ’__name__’, ’__package__’, ’acos’, ’acosh’,’asin’, ’asinh’, ’atan’, ’atan2’, ’atanh’, 
 ’ceil’, ’copysign’,’cos’, ’cosh’, ’degrees’, ’e’, ’erf’, ’erfc’, ’exp’, ’expm1’,’fabs’, ’factorial’, ’floor’, 
 ’fmod’, ’frexp’, ’fsum’, ’gamma’,’hypot’, ’isfinite’, ’isinf’, ’isnan’, ’ldexp’, ’lgamma’, ’log’,’log10’, 
 ’log1p’, ’modf’, ’pi’, ’pow’, ’radians’, ’sin’, ’sinh’, 
  
  
 2
 The complete documentation for the standard library can be found at
  docs.python.org/py3k/library/
 .",NA
8.2,NA,NA
Introduction to Complex Numbers,"Another data type that Python provides is the complex type for complex numbers. Complex 
 numbers are extremely important in a wide range of problems in math, science, and 
 engineering. Complex numbers and the complex mathematical framework that surrounds 
 them provide beauti-fully elegant solutions to problems that are cumbersome or even 
 impossible to solve using only real numbers. Complex numbers can be thought of as points 
 in a plane, which is commonly referred to as the
  complex plane
 , as depicted in Fig. 8.1.
  
 Instead of specifying the points as an ordered pair of numbers as you might with points 
 in a Cartesian plane (i.e., an “(
 x, y
 ) pair”), we describe points in a complex plane as 
 consisting of a real part and an imaginary part. The use of the word “imaginary” is rather 
 unfortunate since imaginary can imply something fictitious or made up. But imaginary 
 numbers are just as real as“real” numbers—they provide ways for us to describe and 
 quantify the world. The real part of a complex number represents the projection of the 
 complex number onto the “real axis” (i.e., the",NA
Imaginary,NA,NA
y ,NA,NA
=Im[,NA,NA
z,NA,NA
],NA,NA
Axis,NA,NA
z ,NA,NA
=,NA,NA
 x + j y,NA,NA
r ,NA,NA
=,NA,NA
√,NA,NA
x,2,NA
 + ,NA,NA
y,2,NA
 ,NA,NA
#NAME?,1,NA
(,NA,NA
y/x,NA,NA
),NA,NA
Real ,NA,NA
Axis,NA,NA
x ,NA,NA
=Re[,NA,NA
z,NA,NA
],"Figure 8.1: Representation of the complex number
  z
  in the
  complex plane
 . The number has 
 a real part
  ⊔
 [
 z
 ] =
  x
  (which gives the displacement along the horizontal, i.e., real, axis) and 
 an imaginary part
  ⊔
 [
 z
 ] =
  y
  (which gives the displacement along the vertical, i.e., imaginary, 
 axis). The number can also be specified in polar form,
  z
  =
  r θ
  where the magnitude
  r
  is the 
 displacement from the origin and the phase
  θ
  is the angle between the positive real axis 
 and a ray from the origin to the point.
  
 real number line). The
  imaginary part
  of a complex number is itself a real number! This 
 number represents the projection of the complex number onto the “imaginary axis” which 
 is orthogonal to the real axis. You can think of the real axis as corresponding to the
  x
  axis 
 and the imaginary axis as corresponding to the
  y
  axis in a Cartesian plane. In fact, we often 
 write a complex number 
 z
  as
  x
  +
  jy
  where
  x
  is the real part of
  z
  and
  y
  is the imaginary part 
 of
  z
 . Again,
  y
  is a real number. However,
  j
  is defined as the “imaginary” number such that it 
 is the square root of
  −
 1, i.e.,
 √−
 1 =
  ±j
  or, thought of another way, (
 ±j
 )
 2
 =
  −
 1. In the complex 
 plane, the number
  j
  is located along the imaginary axis a unit distance from the origin (a 
 distance of 1 from the origin).
  
 When we write
  jy
 , we mean a displacement of
  y
  from the origin along the imaginary axis.
  
 As with the usual representation of points in a plane, complex numbers can be also be 
 expressed in polar form (ref. Fig. 8.1). We can write
  z
  =
  r θ
 , where
  r
  is known as the 
 magnitude (or modulus or absolute value) of
  z
  and is the displacement from the origin to 
 the point
  z
 , and
  θ
  is known as the phase (or argument) and is the angle between the 
 positive real axis and a ray from the origin to the point
  z
 . One can relate the Cartesian and 
 polar forms of a complex number via
  x
  =
  r
  cos(
 θ
 ) and
  y
  =
  r
  sin(
 θ
 ). Though we won’t explore 
 it here, one of the remarkable and beautiful properties of complex numbers is described by 
 Euler’s formula which states
  e
 jθ
 = cos(
 θ
 ) +
  j
  sin(
 θ
 ). Given this, we can write a complex 
 number
  z
  either as
  x
  +
  jy
  or
  re
 jθ
 .",NA
8.3,NA,NA
Complex Numbers and the cmath Module,"Given this background on complex numbers, we now can ask: How do we calculate the 
 square root or cosine of a complex number? These are, in fact, well defined operations 
 mathematically, but can Python do them?
  
 Listing 8.6 illustrates what happens when we try to use complex numbers with the 
 functions from the math module. In line 1 the math module is imported. In line 2 the 
 complex number z1 is created with a real part of zero and an imaginary part of 1.0. (Note 
 that if no real part is given, such as the case here, then it is zero. Also, both the real and 
 imaginary parts of a complex number are stored as floats.) Line 3 shows that when we 
 square z1, we obtain the complex number (-1+j0). Another thing to note is that complex 
 numbers are not converted back to floats when their imaginary part is zero nor are they 
 converted to integers even when they correspond to whole numbers. The discussion 
 continues following the listing.
  
 Listing 8.6
  Attempt to use complex numbers with functions from the math module.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18 
 19
  
  
 >>>
  import
  math
  
 >>>
  z1 = 1j 
 >>>
  z1 * z1 
 (-
 1+0j) 
 # z1 has zero real part and imaginary part of 1. # z1 squared is 
 negative 1.
  
 >>>
  # Cannot use math.sqrt() on a complex number.
  
 >>>
  math.sqrt(z1) 
  
 Traceback (most recent call last):  
 File ""<stdin>"", line 1, in <module>  
 TypeError: can’t convert complex to float  
 >>>
  # Cannot use math.sqrt() on a complex number.
  
 >>>
  math.sqrt(-1) 
  
 Traceback (most recent call last):  
 File ""<stdin>"", line 1, in <module>  
 ValueError: math domain error  
 >>>
  # Cannot use math.cos() on a complex number.
  
 >>>
  math.cos(5.6 - 7.3j) 
  
 Traceback (most recent call last):  
 File ""<stdin>"", line 1, in <module> TypeError: can’t 
 convert complex to float 
  
 In lines 6 through 9 we see that we cannot use math.sqrt() with a complex number. In fact, 
 lines 11 through 14 show that we cannot even use math.sqrt() with a negative real number. 
 Lines 16 through 19 show that math.cos() cannot be used with complex numbers.
  
 Not at all. Rather this serves as a reminder that Python tries to compartmentalize the 
 functionality So, does that mean that one cannot calculate things such as
 √j
  or cos(5
 .
 6
  − j
 7
 .
 3) 
 in Python?
  
 it provides. There are many programmers who may need to work with real numbers and 
 real functions and yet will never need to work with complex numbers. In the interest of 
 speed and program size, it is best if these programmers do not have to work with functions 
 that are designed to deal with the “complexity” of complex numbers.",NA
8.4,NA,NA
Importing Selected Parts of a Module,"Often there is no reason to import all the methods and attributes contained in a module. 
 Perhaps an engineer needs to work with the cosine function and the number
  π
  but does not 
 need anything more than these from the math module. There are alternate forms of the 
 import statement by which one can specify the individual objects to be imported. Listing 
 8.9 provides templates for these alternatives. Each statement starts with the keyword from. 
 This is followed by the module name and then the keyword import. The remainder of the 
 statement specifies what is to be imported and, if an as qualifier is present, what the 
 identifier should be for the specified object (as is also a keyword). If more than one object 
 is to be imported, the objects are separated by commas. When importing multiple objects, 
 the as qualifier may be added or omitted as appropriate.
  
 Listing 8.9
  Using the from-import construct to select individual components of a module.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
  
 # Import a single object.
  
 from
  <module>
  import
  <object> 
  
 # Import a single object and assign to an alternative name.
  
 from
  <module>
  import
  <object>
  as
  <ident> 
 # Import 
 multiple objects.
  
 from
  <module>
  import
  <object1>
 ,
  <object2>
 , ...,
  <objectN> 
 # Import multiple 
 objects and assign to alternative names.",NA
8.5,NA,NA
Importing an Entire Module Using *,"Assume a programmer needs to work with most, or even all, of the objects contained in a 
 module. In this case it can be tiresome to have to type module.object whenever accessing 
 one of the objects. As you saw in the previous section, one can use the from variant of an 
 import statement to import objects so that they are available directly in the local scope, i.e., 
 we don’t need to use the module-dot notation (in fact, we
  cannot
  use it). So, one possibility 
 is to use a from-import statement where one lists all the objects in a module. However, this 
 is rather cumbersome. Fortunately there is a better way.
  
 Python allows you to import everything from a module if, in a from-import statement, 
 you simply write an asterisk for the object you want to import. The asterisk serves as a 
 “wildcard,”meaning everything. The code in Listing 8.13 demonstrates how this is done.
  
 Listing 8.13
  Demonstration of directly importing all the contents of a module into the local 
 scope.",NA
8.6,NA,NA
Importing Your Own Module,"A module is simply a .py file. Thus, we can easily create our own modules that contain a 
 collec-tion of functions or other objects. Let us consider an example. Assume the code 
 shown in Listing 8.14 has been placed in the file my mod.py. The file starts with a multi-line 
 string that gives a brief description of the module. In line 6 the variable scale is assigned 
 the value 2. Since this assignment is made outside any function, scale is globally defined 
 within this module—any function can use or change this variable. Also, as we will see, this 
 variable is “visible” wherever this module is imported. The module also contains two 
 function definitions. The first function, scaler(), returns scale times its argument while the 
 second function, reverser() returns the reverse of its argument (thus, of course, there are 
 restrictions on what arguments can be passed to these functions). Note that the body of 
 each function contains a docstring (docstrings were discussed in Sec. 4.3).
  
 Listing 8.14
  Code used to demonstrate importing a module of our own.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
  
 """""" 
  
 This module contains two functions and one globally defined integer.
  
 """"""
  
 scale = 2",NA
8.7,NA,NA
Chapter Summary,2. import <module> as <id>,NA
8.8,NA,NA
Review Questions,"1. Which statement would import all of the objects of a module called mymodule so that 
 they could be used directly (without dot notation).
  
 (a) import mymodule 
  
 (b) import mymodule.* 
  
 (c) import * from mymodule 
  
 (d) from mymodule import all 
  
 (e) from mymodule import *
  
 2. What statement allows the math module to be used in a program?
  
 (a) input math 
  
 (b) import * from math 
  
 (c) import math 
  
 (d) Either (b) or (c).
  
 ANSWERS:
  1) e; 2) c.",NA
Chapter 9,NA,NA
Strings,"You are probably accustomed to referring to a collection of readable characters as “text.” 
 By“readable characters,” we mean the symbols that one typically finds on a keyboard such 
 as letters of the alphabet, digits zero through nine, and punctuation marks (including a 
 blank space). As we will soon see, computers use a mapping between characters and 
 numbers: each character has a corresponding unique numeric value. With this mapping in 
 place, we can interpret (and display) the ones and zeros stored in the computer as a 
 character or we can interpret (and display) them as a number. In either case, we are talking 
 about the same combination of ones and zeros. The only thing that differs is whether we 
 decide to interpret the combination as a number or, using the established mapping, as a 
 character.
  
 The first standardized mapping created for numbers and characters was the American 
 Standard Code for Information Interchange (ASCII) which is still in use today. ASCII 
 specifies the numeric values corresponding to 128 characters and we will focus our 
 attention on these 128 characters.
  
 If text is stored in a computer using only ASCII characters, we refer to this as “plain 
 text.”So, for example, a Word document is
  not
  a plain text file. A Word document contains 
 information that goes far beyond the text you ultimately read in the rendered document. 
 For example, a Word document contains information pertaining to the page layout, the 
 fonts to be used, and the history of previous edits. On the other hand, a plain-text file 
 specifies none of this. The Python files you create with IDLE (i.e., the .py files) are plain-text 
 files. They contain the ASCII characters corresponding to the code and nothing more. 
 Essentially every byte of information in the file is“visible” when you open the file in IDLE 
 (this “visibility” may be in the form of space or a new line). The file contains no information 
 about fonts or page size or anything other than the code itself.
  
 Many cutting-edge problems involve the manipulation of plain text. For example, Web 
 pages typically consist of plain text (i.e., hyper-text markup language [HTML]) commands. 
 The headers of email messages are in plain text. Data files often are written in the form of 
 plain text. XML (extensible markup language) files are written in plain text. Thus, the ability 
 to manipulate plain text is a surprisingly important skill when solving problems in 
 numerous disciplines.
  
 As you have seen, in Python we store a collection of characters in a data type known as 
 a string, i.e., a str. When we say “text” we will typically be using it in the usual sense of the 
 word to refer to readable content. On the other hand, when we say “string” we will be 
 referring to the",NA
9.1,NA,NA
String Basics,"The following summarizes several string-related features or tools that we discussed 
 previously:
  
 •
  A string literal is enclosed in either single quotes, double quotes, or either quotation 
 mark repeated three times. When the quotation mark is repeated three times, the string 
 may span multiple lines.
  
 •
  Strings are immutable.
  
 •
  Strings can be concatenated using the plus operator.
  
 •
  A string can be repeated by multiplying it by an integer.
  
 •
  The str() function converts its argument to a string.
  
 •
  A string is a sequence. Thus:
  
 –
  A string can be used as the iterable in the header of a for-loop (in which case the 
 loop variable takes on the values of the individual characters of the string).
  
 –
  The len() function returns the length of a string, i.e., the number of characters.
  
 –
  An individual character in a string can be accessed by specifying the character’s 
 index within brackets.
  
 –
  Slicing can be used to obtain a portion (or all) of a string.
  
 Listing 9.1 demonstrates several basic aspects of strings and string literals. Note that in 
 line 5 triple quotes are used for a string literal that spans two lines. In this case the newline 
 character becomes part of the string. In contrast to this, in line 13 a string is enclosed in 
 single quotes and the string itself is written across two lines. To do this, the newline 
 character is escaped (i.e., the backslash is entered immediately before typing return). In 
 this case s3 is a single-line string—the newline character is not embedded in the string. In 
 line 21 a string is created that includes the hash symbol (#). When the hash symbol appears 
 in a string, it becomes part of the string and does not specify the existence of a comment.
  
 Listing 9.1
  Demonstration of several basic string operations including the different ways in 
 which a literal can be quoted.",NA
9.2,NA,NA
The ASCII Characters,"As discussed in Chap. 1 and in the introduction to this chapter, all data are stored as 
 collections of ones and zeros. This is true of the characters of a string as well. In the early 
 1960’s a standard was published, known as the American Standard Code for Information 
 Interchange (ASCII, pro-nounced “ask-ee”), which specifies a mapping of binary values to 
 characters. The word “code” is not meant to imply anything having to do with encryption. 
 Rather, this is a mapping of numeric values to 128 characters. These characters, together 
 with their ASCII values, are shown in Listing 9.4. This character set consists of both non-
 printable characters and graphic (or printable) char-acters. The non-printable characters 
 are indicated by a two- or three-letter abbreviation and these are often identified as 
 “control characters.” Some of the non-printable characters are discussed following the 
 listing and the remainder are listed in an appendix.
  
 Listing 9.4
  The 128 ASCII characters together with their corresponding ASCII value. 
  
 Non
 -printable characters are listed by their two- or three-letter abbreviations. The space 
 character (32) is indicated by a blank space.
  
  
 0 
 NUL 
 1 
  SOH 
 2 
  STX 
 3 
 ETX 
 4 
 EOT 
 5 
 ENQ 
 6 
 ACK 
 7 
  BEL 
 8 
  BS 
 9 
  HT 
 10
  LF 
 11
  VT 
 12
  FF 
 13
  CR 
 14
  SO 
 15
  SI 
 16
  DLE 
 17
  DC1 
 18
  DC2 
 19
  DC3 
 20
  DC4 
 21
  NAK 
 22
  SYN 
 23
  ETB 
 24
  CAN 
 25
  EM 
 26
  SUB 
 27
  ESC 
 28
  FS 
 29
  GS 
 30
  RS 
 31
  US 
 32
  
 33 
  ! 
 34 
  "" 
 35 
 # 
 36 
 $ 
 37 
  % 
 38 
 & 
 39
  ’ 
 40 
 ( 
 41 
  ) 
 42
  
 * 
  
 43 
 + 
 44 
 , 
 45
  - 
 46 
 . 
 47 
  / 
 48 
 0 
 49 
  1 
 50 
  2 
 51 
 3 
 52 
 4 
 53 
  5 
 54 
 6 
 55 
  7 
 56 
 8 
 57 
  9 
 58 
  : 
 59 
 ; 
 60 
 < 
 61 
  = 
 62 
 > 
 63 
  ? 
 64 
 @ 
 65 
  A 
 66 
  B 
 67 
 C 
 68 
 D 
 69 
  E 
 70 
 F 
 71 
  G 
 72 
 H 
 73 
  I 
 74 
  J 
 75 
 K 
 76 
 L 
 77 
  M 
 78 
 N 
 79 
  O 
 80 
 P 
 81 
  Q 
 82 
  R 
 83 
 S 
 84 
 T 
 85 
  U 
 86 
 V 
 87 
  W 
 88 
 X 
 89 
  Y 
 90 
  Z 
 91 
 [ 
 92 
 \ 
 93 
  ] 
 94
 ˆ 
 95 
  _ 
 96
 ‘ 
 97 
  a 
 98 
  b 
 99 
 c 
 100
  d 
 101
  e 
 102
  f 
 103
  g 
 104
  h 
 105
  i 
 106
  j 
 107
  k 
 108
  l 
 109
  m 
 110
  n 
 111
  o 
 112
  p 
 113
  q 
 114
  r 
 115
  s 
 116
  t 
 117
  u 
 118
  v 
 119
  w 
 120
  x 
 121
  y 
 122
  z 
 123
  { 
 124
  | 
 125
  } 
 126
  ˜ 
 127
 DEL 
 The ASCII character set is obviously limited in that it was not designed to handle 
 characters from other languages. Newer codes exist, such as Unicode, that attempt to 
 accommodate all lan-guages. The Unicode standard currently defines more than 110,000 
 characters! Although Python provides support for Unicode, we will use ASCII almost 
 exclusively. One thing to be aware of is that the larger codes invariably include ASCII as a 
 subset. Thus, everything we will consider here remains true in the larger character sets.
  
 ASCII is also somewhat dated in that it was designed to accommodate hardware that 
 existed in the early 1960’s and yet it did not precisely specify the behavior associated with",NA
9.3,NA,NA
Escape Sequences,"Escape sequences were introduced in Sec. 2.5 where we saw we could write \n to include a 
 newline character within a string. The backslash is used to indicate that the character 
 following it does not have the usual meaning we associate with it within a string context 
 (sometimes the backslash escapes multiple characters as will be shown). Given the 
 description above of ASCII characters, we know the newline character (LF with a value of 
 10) is really no more than a binary value corresponding to the decimal number 10. To 
 represent a newline character we write \n. Put another way, \n serves to place the ASCII 
 Line Feed (LF) character in a string (i.e., the numeric equivalent of 10 is placed in the 
 string). This escape sequence is used by Python and most other major computer languages.
  
 As listed in Listing 9.5, Python provides escape sequences for eight of the ASCII 
 characters. It is unlikely you will ever need Null (\0), Backspace (\b), Vertical Tab (\v), 
 Form Feed (\f), or Carriage Return (\r). On the other hand, Bell (\a) can be useful. It 
 typically causes the computer to “beep” or sound some tone.
 3
 Horizontal Tab (\t) and Line 
 Feed (\n) are used frequently and we often refer to them simply as tab and newline, 
 respectively.
  
 Listing 9.5
  ASCII characters for which Python provides a two-character escape sequence.
  
 2
 In the early days of computers the eighth bit was sometimes used as a
  parity bit
 . A parity bit can be used 
 to check whether an error has occurred in the storage or transmission of data. For example, the value of the 
 bit can ensure the total number of bits in the byte that are set to one sums to an even number. To do so, the 
 parity bit is zero if the other bits sum to an even number and is one if the other bits sum to an odd number. A",NA
9.4,NA,NA
chr() and ord(),"The built-in function chr() takes an integer argument and produces the corresponding 
 character. The built-in function ord() is effectively the inverse of chr(). ord() takes a string 
 of length one, i.e., a single character, and returns the corresponding ASCII value. The code 
 in Listing 9.9 illustrates the behavior of these functions.
  
 Listing 9.9
  Demonstration of the use of ord() and chr().
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10
  
  
 >>>
  ord
 (
 ’A’
 ),
  ord
 (
 ’B’
 ),
  ord
 (
 ’!’
 ),
  ord
 (
 ’ ’
 ) 
  
 (65, 66, 33, 32)  
 >>>
  chr
 (65),
  chr
 (66),
  chr
 (33),
  chr
 (32) 
  
 (’A’, ’B’, ’!’, ’ ’)  
 >>>
  ord
 (
 ’Z’
 ),
  chr
 (90)
  # 90 and Z are ASCII pairs.
  
 (90, ’Z’)  
 >>>
  ord
 (
 chr
 (90)) 
  
 # ord(chr()) returns original argument.
  
 90  
 >>>
  chr
 (
 ord
 (
 ’Z’
 )) 
  
 # chr(ord()) returns original argument.
  
 ’Z’",NA
9.5,NA,NA
Assorted String Methods,"String objects provide several methods. These can be listed using the dir() function with an 
 argument of a string literal, a string variable, or even the str() function (with or without the 
 parentheses). So, for example, dir("""") and dir(str) both list all the methods available for 
 strings. This listing is shown in Listing 5.5 and not repeated here. To obtain help on a 
 particular method, don’t forget that help() is available. For example, to obtain help on the 
 count() method, one could type help("""".count). In this section we will consider a few of the 
 simpler string methods.
  
 Something to keep in mind with all string methods is that they never change the value 
 of a string. Indeed, they
  cannot
  change it because strings are immutable. If we want to 
 modify the string associated with a particular identifier, we have to create a new string 
 (perhaps using one or more string methods) and then assign this new string back to the 
 original identifier. This is demonstrated in the examples below.",NA
9.5.1 ,NA,NA
"lower(), upper(), capitalize(), title(), and swapcase()","Methods dealing with case return a new string with the case of the original string 
 appropriately modified. It is unlikely that you will have much need for the swapcase() 
 method. title() and capitalize() can be useful at times, but the most useful case-related 
 methods are lower() and upper(). These last two methods are used frequently to implement 
 code that yields the same result independent of the case of the input, i.e., these methods are 
 used to make the code “insensi-tive” to case. For example, if input may be in either uppercase 
 or lowercase, or even a mix of cases, and yet we want to code to do the same thing regardless 
 of case, we can use lower() to ensure the resulting input string is in lowercase and then 
 process the string accordingly. (Or, similarly, we could use upper() to ensure the resulting 
 input string is in uppercase.) These five methods are demonstrated in Listing 9.16. The 
 print() statement in line 12 and the subsequent output in line 13 show that the value of the 
 string s has been unchanged by the calls to the various methods. To change the string 
 associated with s we have to assign a new value to it as is done in line 14 where s is reset to 
 the lowercase version of the original string. The print() statement in line 15 confirms that s 
 has changed.
  
 Listing 9.16
  Demonstration of the methods used to establish the case of a string.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11
  
  
 >>>
  s =
  ""Is this IT!?"" 
  
 >>>
  s.capitalize()
  # Capitalize only first letter of entire string.
  
 ’Is this it!?’ 
 >>>
  s.title() 
  
 # Capitalize first letter of each word.
  
 ’Is This It!?’ 
 >>>
  s.swapcase() 
  
 # Swap uppercase and lowercase.
  
 ’iS THIS it!?’ 
 >>>
  s.upper() 
  
 # All uppercase.
  
 ’IS THIS IT!?’ 
 >>>
  s.lower() 
  
 # All lowercase.
  
 ’is this it!?’",NA
9.5.2,NA,NA
count(),"The count() method returns the number of “non-overlapping” occurrences of a substring 
 within a given string. By non-overlapping we mean that a character cannot be counted 
 twice. So, for example, the number of times the (sub)string zz occurs in zzz is once. (If 
 overlapping were allowed, the middle z could serve as the end of one zz and the start of a 
 second zz and thus the count would be two. But this is
  not
  what is done.) The matching is 
 case sensitive. Listing 9.17 demonstrates the use of count(). Please see the comments 
 within the listing.
  
 Listing 9.17
  Demonstration of the count() method.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
  
 >>>
  s =
  ""I think, therefore I am.""
  
 >>>
  s.count(
 ""I""
 ) 
  
 # Check number of uppercase I’s in s.
  
 2 
 >>>
  s.count(
 ""i""
 ) 
  
 # Check number of lowercase i’s in s.
  
 1 
 >>>
  s.count(
 ""re""
 ) 
  
 # Check number of re’s in s.
  
 2 
 >>>
  s.count(
 ""you""
 )
  # Unmatched substrings result in 0.
  
 0",NA
9.5.3,NA,NA
"strip(), lstrip(), and rstrip()","strip(), lstrip(), and rstrip() remove leading and/or trailing whitespace from a string. 
 lstrip() removes leading whitespace (i.e., removes it from the left of the string), rstrip() 
 removes trailing whitespace (i.e., removes it from the right of the string), and strip() 
 removes both leading and trailing whitespace. As we will see in Sec. 10.1.1, when reading 
 lines of text from a file, the newline character terminating the line is considered part of the 
 text. Such terminating whitespace is often unwanted and can be conveniently removed 
 with strip() or rstrip(). Listing 9.18 demonstrates the behavior of these methods. Please 
 read the comments within the listing.
  
 Listing 9.18
  Demonstration of the strip(), lstrip(), and rstrip() methods.
  
 1
  
  
 2
  
  
 3
  
  
 >>>
  # Create a string with leading, trailing, and embedded whitespace.
  
 >>>
  s =
  "" 
  
 Indent a line\n and another\nbut not this. 
  
 \n""
  
 >>>
  print
 (s) 
  
 # Print original string.",NA
9.5.4,NA,NA
repr (),"All objects in Python contain the method __repr__(). This method provides the 
 “official”string representation of a given object, i.e., you can think of __repr__() as standing 
 for “repre-sentation.” As with most methods that begin with underscores, this is not a 
 method you typically use in day-to-day programming. However, it can be useful when 
 debugging. Consider the string s new created in line 22 of Listing 9.18. In line 25 this string 
 is entered at the interactive prompt. The interactive environment echoes the string 
 representation of this object.
  But
 , this is not the same as printing the object. Were we to 
 print s new, we would see the same output shown in lines 18 through 20. Note that in this 
 output we cannot truly tell if the spaces were removed from the end of the line (we can tell 
 the newline character was removed, but not the spaces that came before the newline 
 character). However, from the output in line 26, we can see that these trailing spaces were 
 removed.
  
 Now assume you are writing (and running) a program but not working directly in the 
 interactive environment. You want to quickly see if the internal representation of a string 
 (such as s new in the example above) is correct. What should you do? If you print() the 
 string itself, it might mask the detail you seek. Instead, you can use the __repr__() method 
 with print() to see the internal representation of the object. This is illustrated in Listing 
 9.19.",NA
9.5.5,NA,NA
find() and index(),"The find() and index() methods search for one string within another. The search is case 
 sensitive. Both return the starting index where a substring can be found within a string. 
 They only differ in that find() returns -1 if the substring is not found while index() 
 generates a ValueError (i.e., an exception) if the substring is not found. You may wonder 
 why there is a need for these two different functions. Other than for convenience, there 
 isn’t a true need for two different functions. However, note that, because of negative 
 indexing, -1 is a valid index: it corresponds to the last element of the string. So, find() 
 always returns a valid index and it is up to your code to recognize that -1 really means “not 
 found.” In some situations it may be preferable to produce an error when the substring is 
 not found. But, if you do not want this error to terminate your program, you must provide 
 additional code to handle the exception.
  
 The code in Listing 9.20 demonstrates basic operation of these two methods. In line 1 a 
 string is created that has the character I in the first and 20th positions, i.e., in locations 
 corresponding to indices of 0 and 19. The find() method is used in line 2 to search for an 
 occurrence of I and the result, shown in line 3, indicates I is the first character of the string. 
 You may wonder if it is possible to find all occurrences of a substring, rather than just the 
 first. The answer is yes and we’ll return to this issue following the listing. Lines 4 and 5 
 show that the search is case sensitive, i.e., i and I do not match. Line 6 shows that one can 
 search for a multi-character substring within a string. Here index() is used to search for ere 
 in the string s. The resulting value of 11 gives the index where the substring starts within 
 the string. In line 8 find() is used to search for You within the string. Since this does not 
 occur in s, the result is -1 as shown in line 9. Finally, in line 10, index() is used to search for 
 You. Because this string is not found, index() produces a ValueError.
  
 Listing 9.20
  Demonstration of the use of the find() and index() methods.",NA
9.5.6 ,NA,NA
replace(),"The replace() method is used to replace one substring by another. By default, all 
 occurrences of the string targeted for replacement are replaced. An optional third 
 argument can be given that specifies the maximum number of replacements. The use of the 
 replace() method is demon-strated in Listing 9.23.
  
 Listing 9.23
  Demonstration of the replace() method. The optional third argument specifies 
 the maximum number of replacements. It is not an error if the substring targeted for 
 replacement does not occur.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
  
 >>>
  s =
  ""I think, therefore I am.""
  
 >>>
  s.replace(
 ""I""
 ,
  ""You""
 ) 
  
 # Replace I with You.
  
 ’You think, therefore You am.’ 
 >>>
  s.replace(
 ""I""
 ,
  ""You""
 , 1) 
  
 # Replace only once.
  
 ’You think, therefore I am.’ 
 >>>
  s.replace(
 ""I""
 ,
  ""You""
 , 5) 
  
 # Replace up to 5 times.
  
 ’You think, therefore You am.’ 
 >>>
  s.replace(
 ""He""
 ,
  ""She""
 , 5) 
  
 # Target substring not in string.
  
 ’I think, therefore I am.’",NA
9.6,NA,NA
split() and join(),"split() breaks apart the original string and places each of the pieces in a list. If no argument 
 is given, the splitting is done at every whitespace occurrence; consecutive whitespace 
 characters",NA
9.7,NA,NA
Format Strings and the format() Method,"We have used the print() function to generate output and we have used the interactive 
 inter-preter to display values (by entering an expression at the interactive prompt and then 
 hitting return). In doing so, we have delegated the task of formatting the output to the the 
 print() function or to the interactive interpreter.
 7
 Often, however, we need to exercise finer 
 control over the appearance of our output. We can do this by creating strings that have 
 precisely the appearance we desire.
  
 These strings are created using
  format strings
  in combination with the format() method.
  
  
 7
 Actually, the formatting is largely dictated by the objects themselves since it 
 is the that specifies how an object should appear.
  
 str () method of an object",NA
9.7.1,NA,NA
Replacement Fields as Placeholders,"For examples of the use of format strings, consider the code in Listing 9.30. In these 
 examples the replacement fields, which are the braces, are simply placeholders—they mark 
 the location (or locations) where the argument(s) of the format() method should be placed. 
 There is a one-to-one correspondence between the (placeholder) replacement fields and 
 the arguments of format(). This code is discussed further following the listing.
  
 Listing 9.30
  Demonstration of format strings where the replacement fields provide only 
 place-ment information (not formatting information).
  
 1 
  
 2
  
  
 >>>
  ""Hello {}!""
 .
 format
 (
 ""Jack""
 )
  
 ’Hello Jack!’ 
  
  
 8
 Complete details can be found at
  docs.python.org/py3k/library/string.html#formatstrings
 .",NA
Format Specifier: Width,CHAPTER 9. STRINGS,NA
9.7.2,"The contents of a replacement field can also provide instructions about the formatting of 
 output. We will consider several of the myriad ways in which the output can be formatted. 
 Section 9.7.1 explains that replacement fields can be named. To provide formatting 
 information, we must provide a
  format specifier
  within the replacement field. The format 
 specifier must be preceded by a colon. The field name, if present, appears to the left of this 
 colon. Thus, we can think of a general replacement field as consisting of
  
 <replacement_field>
  = {
 <field_name>
 :
 <format_specifier>
 }
  
 As both the field name and format specifier are optional, alternate forms of replacement 
 fields are
  
 <replacement_field>
  = {}
  
 and
  
 <replacement_field>
  = {
 <field_name>
 }
  
 and
  
 <replacement_field>
  = {:
 <format_specifier>
 }
  
 Perhaps the simplest formatting information is the (minimum) width of the resulting 
 field. Thus, for a particular replacement field, this is the number of spaces provided to hold 
 the string representation of the corresponding object given as an argument to format(). If 
 the number of spaces is insufficient to display the given object, Python will use as many 
 additional spaces as necessary. If the object requires fewer characters than the given width, 
 the “unused” spaces are, by default, filled with blank spaces. The code in Listing 9.33 
 demonstrates various aspects of the width specifier.
  
 Listing 9.33
  Demonstration of the width specifier. If the string representation of the 
 correspond-ing object is longer than the width, the output will exceed the width as 
 necessary. If the object is shorter than the width, blank spaces are used to fill the field.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15
  
  
 >>>
  ""{0:5}, {1:5}, and {2:5}!""
 .
 format
 (
 ""Red""
 ,
  ""White""
 ,
  ""Periwinkle""
 )
 ’Red  , White, and 
 Periwinkle!’ 
 >>>
  ""{0:5}, {1:5}, and {2:5}!""
 .
 format
 (5, 10, 15)
  
 ’ 
 5, 
 10, and 
 15!’ 
 >>>
  # ""Name"" portion of replacement field is unnecessary when there is 
 >>>
  # a one-to-one and in-
 order correspondence between the fields and 
 >>>
  # arguments of format().
  
 >>>
  ""{:5}, {:5}, and {:5}!""
 .
 format
 (5, 10, 15)
  
 ’ 
 5,  
 10, and  
 15!’ 
 >>>
  # Colon in replacement field is not an operator. 
  
 Cannot have 
 >>>
  # spaces between the field name and colon.
  
 >>>
  ""{0 : 5}, {1 : 5}, and {2 : 7}!"".format(5, 10, 15) 
 Traceback (most 
 recent call last): 
 File ""<stdin>"", line 1, in <module> 
 KeyError: ’0 ’",NA
9.7.3 ,NA,NA
Format Specifier: Alignment,"Listing 9.33 shows that, by default, strings are left-justified while numbers are right-
 justified within their fields, but we can override this default behavior. We can explicitly 
 control the alignment by providing one of four characters prior to the width: < for left 
 justification, ˆ for centering, > for right justification, and = to left-justify the sign of a 
 number while right-justifying its magnitude. This is demonstrated in Listing 9.34. The same 
 format string is used in both lines 1 and 3. This string has three replacement fields. The 
 first specifies left justification, the second specifies center-ing, and the third specifies right 
 justification. The output in lines 2 and 4 demonstrates the desired behavior. The 
 expressions in lines 5 and 7 use the = alignment character. By default the plus sign is not 
 displayed for positive numbers.
  
 Listing 9.34
  Alignment of output within a field can be controlled with the aligned 
 characters < (left), ˆ (centering), and > (right).
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
  
 >>>
  print
 (
 ""|{:<7}||{:ˆ7}||{:>7}|""
 .
 format
 (
 ""bat""
 ,
  ""cat""
 ,
  ""dat""
 ))
  
 |bat 
 || 
 cat 
 || 
 dat| 
 >>>
  print
 (
 ""|{:<7}||{:ˆ7}||{:>7}|""
 .
 format
 (123, 234, 345))
  
 |123 
 || 
 234 
 || 
 345| 
 >>>
  ""{:=7}""
 .
 format
 (-123)
  
 ’- 
 123’ 
 >>>
  ""{:=7}""
 .
 format
 (123)",NA
9.7.4,NA,NA
Format Specifier: Fill and Zero Padding,"One can also specify a “fill character.” If an object does not fill the allocated space of the re-
 placement field, the default “fill character” is a blank space. However, this can be 
 overridden by providing an additional character between the colon and the alignment 
 character, i.e., at the start of the format specifier.
 11
 This is demonstrated in Listing 9.35. In 
 line 1 the fill characters for the three fields are <, *, and =. In line 3 the fill characters are >, 
 ˆ, and 0. The last fill character is of particular interest for reasons that will become clear 
 shortly. The discussion of this code continues following the listing.
  
 Listing 9.35
  A “fill character” can be specified between the colon and alignment character. 
 This character will be repeated as necessary to fill any spaces that would otherwise be 
 blank.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14
  
  
 >>>
  print
 (
 ""|{:<<7}||{:*ˆ7}||{:=>7}|""
 .
 format
 (
 ""bat""
 ,
  ""cat""
 ,
  ""dat""
 )) 
 |bat<<<<||**cat**||====dat|  
 >>>
  print
 (
 ""|{:><7}||{:ˆˆ7}||{:0>7}|""
 .
 format
 (123, 234, 345)) 
 |123>>>>||ˆˆ234ˆˆ||0000345|  
 >>>
  ""{:07} {:07} {:07}""
 .
 format
 (345, 2.5, -123)
  
 ’0000345 00002.5 -000123’ 
 >>>
  ""{:0=7} {:0=7} {:0>7}""
 .
 format
 (2.5, -123, -123)
  
 ’00002.5 -000123 000-123’ 
 >>>
  ""{:07}"".format(""mat"") 
  
 Traceback (most recent call last):  
 File ""<stdin>"", line 1, in <module>  
 ValueError: ’=’ alignment not allowed in string format specifier 
 >>>
  
 ""{:0>7}""
 .
 format
 (
 ""mat""
 )
  
 ’0000mat’ 
  
 When the argument of the format() method is a numeric value, a zero (0) can precede 
 the width specifier. This indicates the field should be “zero padded,” i.e., any unused spaces 
 should be filled with zeroes, but the padding should be done between the sign of the 
 number and its magnitude. In fact, a zero before the width specifier is translated to a fill 
 and alignment specifier of 0=. This is demonstrated in lines 5 through 8 of Listing 9.35. In 
 line 5 the arguments of format() are an integer, a float, and a negative integer. For each of 
 these the format specifier is simply 07 and the output on line 6 shows the resulting zero-
 padding. In line 7 the arguments of format() are a float and two negative integers. The first 
 two replacement fields use 0=7 as the format specifier. The resulting output on line 8 
 indicates the equivalence of 07 and 0=7. However, the third field in line 7 uses 0>7 as the 
 format specifier. This is
  not
  equivalent to 07 (or 0=7) in that the sign of the number is now 
 adjacent to the magnitude rather than on the left side of the field.
  
 11
 One restriction is that the fill character cannot be a closing brace (
 }
 ).",NA
9.7.5 ,NA,NA
Format Specifier: Precision (Maximum Width),"Section 9.7.2 describes how an integer is used to specify the (minimum) width of a field. 
 Somewhat related to this is the
  precision
  specifier. This is also an integer, but unlike the 
 width specifier, the precision specifier is preceded by a dot. Precision has different 
 meanings depending on the type of the object being formatted. If the object is a float, the 
 precision dictates the number of digits to display. If the object is a string, the precision 
 indicates the maximum number of characters allowed to represent the string. (One cannot 
 specify a precision for an integer argument.) As will be shown in a moment, when a width 
 is specified, it can be less than, equal to, or greater than the precision. Keep in mind that the 
 width specifies the size of the field while the precision more closely governs the characters 
 used to format a given object.
  
 Listing 9.36 demonstrate how the precision specifier affects the output. Line 1 defines a 
 float with several non-zero digits while line 2 defines a float with only three non-zero 
 digits. Line 3 defines a string with seven characters. Lines 5 and 6 show the default 
 formatting of these variables. The output in line 6 corresponds to the output obtained 
 when we write print(x, y, s) (apart from the leading and trailing quotation marks 
 identifying this as a string). The discussion continues following the listing.
  
 Listing 9.36
  Use of the precision specifier to control the number of digits or characters 
 displayed.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15
  
  
 >>>
  x = 1 / 7 
  
 # float with lots of digits. 
 >>>
  y = 12.5 
  
 # 
 float with only three digits. 
 >>>
  s =
  ""stringy"" 
  
 # String with seven 
 characters. 
 >>>
  # Use default formatting.
  
 >>>
  ""{}, {}, {}""
 .
 format
 (x, y, s)
  
 ’0.14285714285714285, 12.5, stringy’ 
 >>>
  # Specify a precision of 5.
  
 >>>
  ""{:.5}, {:.5}, {:.5}""
 .
 format
 (x, y, s)
  
 ’0.14286, 12.5, strin’ 
 >>>
  # Specify a width of 10 and a precision of 5.
  
 >>>
  ""{:10.5}, {:10.5}, {:10.5}""
 .
 format
 (x, y, s)
  
 ’ 
 0.14286, 
 12.5, strin 
 ’ 
 >>>
  # Use alternate numeric formatting for second term. 
 >>>
  ""{:10.5}, 
 {:#10.5}, {:10.5}""
 .
 format
 (x + 100, y, s)
  
 ’ 
 100.14, 
 12.500, strin 
 ’",NA
9.7.6 ,NA,NA
Format Specifier: Type,"Finally, the format specifier may be terminated by a character that is the
  type specifier
 . The 
 type specifier is primarily used to control the appearance of integers or floats. There are 
 some type specifiers that can only be applied to integers. One of these is b which dictates 
 using the binary representation of the number rather than the usual decimal 
 representation. Two other type specifiers that pertain only to integers are d and c. A 
 decimal representation is obtained with the d type specifier, but this is the default for 
 integers and thus can be omitted if decimal output is desired. The type specifier c indicates 
 that the value should be displayed as a character (as if using chr()).
  
 The type specifiers that are nominally for floats also work for integer values. These type 
 specifiers include f for fixed-point representation, e for exponential representation (with 
 one digit to the left of the decimal point), and g for a “general format” that typically tries to 
 format the number in the “nicest” way. If the value being formatted is a float and no type 
 specifier is provided, then the output is similar to g but with at least one digit beyond the 
 decimal point (by default g will not print the decimal point or a trailing digit if the value is a 
 whole number).
  
 The use of type specifiers is demonstrated in Listing 9.37. The code is discussed following 
 the listing.
  
 Listing 9.37
  Use of various type specifiers applied to an integer and two floats.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 >>>
  # b, c, d, f, e, and g type specifiers with an integer value.
  
 >>>
  ""{0:b}, {0:c}, {0:d}, {0:f}, {0:e}, {0:g}""
 .
 format
 (65)
 ’1000001, A, 65, 65.000000, 
 6.500000e+01, 65’ 
 >>>
  # f, e, and g with a float value with zero fractional part.
  
 >>>
  ""{0:f}, {0:e}, {0:g}""
 .
 format
 (65.0)
  
 ’65.000000, 6.500000e+01, 65’ 
 >>>
  # f, e, and g with a float value with non-zero fractional part.
  
 >>>
  ""{0:f}, {0:e}, {0:g}""
 .
 format
 (65.12345)
 ’65.123450, 
 6.512345e+01, 65.1235’",NA
9.7.7,NA,NA
Format Specifier: Summary,"To summarize, a format specifier starts with a colon and then may contain any of the terms 
 shown in brackets in the following (each of the terms is optional):
  
 :[[fill]align][sign][#][0][width][,][.precision][type]
  
 A brief description of the terms is provided below. We note that not all of these terms have 
 been discussed in the preceding material. The interested reader is encouraged either to 
 read the for-matting information available online
 12
 or simply to enter these in a format 
 string and observe the resulting output.
  
 fill
 : 
  
 Fill character (may be any character other than
  }
 ). When given, the fill 
 character must be followed by an alignment character.
  
 align
 : 
  
 < (left), ˆ (center), > (right), or = (for numeric values left-justify sign 
 and 
  
 right-justify magnitude).
  
 12
 docs.python.org/py3k/library/string.html#formatstrings
 .",NA
9.7.8 ,NA,NA
A Formatting Example,"Assume we must display a time in terms of minutes and seconds down to a tenth of a 
 second. (Here we are thinking of “time” as a duration, as in the time it took a person to 
 complete a race. We are not thinking in terms of time of day.) In general, times are 
 displayed with the minutes and seconds separated by a colon. For example, 19:34.7 would 
 be 19 minutes and 34.7 seconds.
  
 Assume we have a variable mm that represents the number of minutes and a variable ss 
 that represents the number of seconds. The question now is: How can we put these 
 together so that the result has the “standard” form of MM:SS.s? The code in Listing 9.39 
 shows an attempt in line 3 to construct suitable output for the given minutes and seconds, 
 but this fails because of the spaces surrounding the colon. In line 5 a seemingly successful 
 attempt is realized using a statement similar to the one in line 3 but setting sep to the 
 empty string. Line 7 also appears to yield the desired output by converting the minutes and 
 seconds to strings and then concatenating these together with a colon. But, are the 
 statements in lines 5 and 7 suitable for the general case?
  
 Listing 9.39
  Attempt to construct a “standard” representation of a time to the nearest tenth 
 of a second.",NA
9.8,NA,NA
Chapter Summary,"Strings are
  immutable
 , i.e., they cannot be
  
 Strings have many methods including the fol-
  
 changed (although an identifier assigned to a
  
 lowing, where “a given string” means the 
 string
  
 string variable can be assigned to a new 
 string).
  
 on which the method is invoked:
  
 Strings can be concatenated using the plus 
 oper-ator. With operator overloading, a string 
 can be
  
 •
  split()
 : Returns a list of elements 
 obtained by splitting the string apart at 
 the
  
 repeated by multiplying it by an integer.
  
 specified substring argument. Default is
  
 Indexing and slicing of strings is the same as 
 for lists and tuples (but working with 
 charac-ters rather than elements).
  
 to split on whitespace.
  
 •
  join()
 : Concatenates the (string) ele-
 ments of the list argument with a given 
 string inserted between the elements. 
 The
  
 The
  len()
  function returns the number of char-
  
 insertion may be any string including 
 an
  
 acters in its string argument.
  
 empty string.
  
 The
  str()
  function returns the string 
 represen-tation of its argument.
  
 •
  capitalize()
 ,
  title()
 ,
  lower()
 , 
 upper()
 ,
  
 swapcase()
 : Case meth-
  
 ods that return a new string with the 
 case
  
 ASCII provides a mapping of characters to
  
 set appropriately.
  
 numeric values.
  
 There are a total of 128
  
 •
  count()
 : Returns the number of times 
 the substring argument occurs in a given
  
 string.
  
 ASCII characters, 95 of which are printable 
 (or graphic) characters.
  
 The
  ord()
  function returns the numeric 
 value of its character argument. The
  chr()
  
 function returns the character for its 
 numeric argument. ord() and chr() are 
 inverses.
  
 •
  find()
  and
  index()
 : Return the in-dex 
 at which the substring argument oc-
 curs within a given string. Optional 
 argu-ments can be used to specify the 
 range of the search. find() returns -1 if 
 the sub-
  
 An
  escape sequence
  within a string begins with
  
 string is not found while index() raises
  
 the backslash character which alters the usual
  
 an exception if the substring is not 
 found.
  
 meaning of the adjacent character or 
 characters. For example, ’\n’ is the escape 
 sequence for the newline character.
  
 •
  lstrip()
 , Strip whitespace from a given 
 string (from 
  
  
 rstrip()
 , 
  
 strip()
 :
  
 the left, right, or from both ends, 
 respec-
  
 tively).",NA
9,NA,NA
9,NA,NA
Review Questions,"1. What is printed by the following Python fragment?
  
 s =
  ""Jane Doe"" 
  
 print
 (s[1])
  
 (a) J 
  
 (b) e 
  
 (c) Jane 
  
 (d) a
  
 2. What is printed by the following Python fragment?
  
 s =
  ""Jane Doe"" 
  
 print
 (s[-1])
  
 (a) J 
  
 (b) e 
  
 (c) Jane 
  
 (d) a
  
 3. What is printed by the following Python fragment?
  
 s =
  ""Jane Doe"" 
  
 print
 (s[1:3])
  
 (a) Ja 
  
 (b) Jan 
  
 (c) an 
  
 (d) ane
  
 4. What is the output from the following program, if the input is Spam And Eggs?",NA
Chapter 10,NA,NA
Reading and Writing Files,"Up to this point we have entered data into our programs either literally (i.e., hardwired into 
 the code when the code is written) or obtained it from the user via an input() statement. 
 However, we often need to work with data stored in a file. Furthermore, rather than 
 displaying results on the screen, sometimes the desired action is to store the results in a 
 file. In this chapter we explore the reading and writing of files. In general, the content of a 
 file is in the form of (readable) text or in the form of binary or “raw” data. In this chapter 
 we will only consider the reading and writing of text, i.e., files that consist of characters 
 from the ASCII character set.",NA
10.1,NA,NA
Reading a File,"To open a file for reading we use the built-in function open(). The first argument is the 
 name of the file and the second argument is the
  mode
 . When we want to read from an 
 existing file, the mode is set to the character ’r’ (as opposed to the character ’w’ which 
 indicates we want to write to a new file).
 1
 For the file to be opened successfully, it must be 
 in one of the directories where Python searches, i.e., the file must be somewhere in 
 Python’s
  path
 . Controlling Python’s path for the reading and writing of files is no different 
 than controlling the path for importing modules. Thus, the discussion in Sec. 8.6 is directly 
 relevant to the material in this chapter. As a reminder, perhaps the simplest way to ensure 
 Python will find an existing file is to set the
  current working directory 
 to the directory 
 where the file resides. For example, assume there is a file called info.txt
 2
 in the Documents 
 directory of a Macintosh or Linux machine or in the My Documents folder of a Windows 
 machine.
 3
 The statements shown in Listing 10.1 are appropriate for opening this file for the 
 user guido. The first two lines of both sets of instructions serve to set the current working 
 directory to the desired location. Even if more than one file in this directory is opened, the 
 first two statements are issued just once (however, there must be one open() statement for 
 each file).
  
  
  
 From the file: files.tex 
  
  
 1
 Actually open() can be used with a single argument—the file name—in which case it is understood that 
 the file should be opened for reading, i.e., ’r’ is the default mode.
  
 2
 There is no restriction on a file name. Often files will have an extension of .txt or .dat, but this is not 
 necessary. 
 3
 We use the terms
  folder
  and
  directory
  interchangeably.",NA
10.1.1 ,NA,NA
"read(), close(), and tell()","When one uses the read() method, the entire file is read and its contents are returned as a 
 single string. This is demonstrated in Listing 10.3. In line 1 the file is opened. In line 2 the 
 read() method is called and the result is stored to the identifier all. Line 3 serves to echo 
 the contents of all which we see in lines 4 and 5.
 5
 The output in lines 4 and 5 is not 
 formatted, e.g., newlines are indicated by \n. To obtain output that mirrors the contents of 
 the file in the way it is typically displayed, we can simply print this string as is done in line 
 6. Note that the print() statement has the optional argument end set to the empty string. 
 This is done because the string all already contains all the newline characters that were 
 contained in the file itself. Thus, because all ends with a newline character, if we do not set 
 end to the empty string, there will be an additional blank line at the end of the output.
  
 Listing 10.3
  Use of the read() method to read an entire file as one string.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11
  
  
 >>>
  file
  =
  open
 (
 ""info.txt""
 ,
  ""r""
 ) 
  
 # Open file for reading.
  
 >>>
  all
  =
  file
 .read() 
  
 # Read the entire file.
  
 >>>
  all 
  
 # Show the resulting string.
  
 ’This file contains some numbers (and text).\n4,  
 5,  
 6,  
 12\n 
 12.3 37.2 -15.7\n\nThis is the last line.\n’ 
 >>>
  print
 (
 all
 , end=
 """"
 ) 
  
 # Print the contents of the file.
  
 This file contains some numbers (and text). 
 4, 
 5, 
 6, 
 12 
 12.3 37.2 -15.7 
 This is the last line. 
  
 After reading the contents of a file with read(), we can call read() again.
  However,
  rather 
 than obtaining the entire contents of the file, we get an empty string. Python maintains a
  
 stream position
  that indicates where it is in terms of reading a file, i.e., the index of the next 
 character to be read. When a file is first opened, this position is at the very start of the file. 
 After invoking the read() method the position is at the end of the file, i.e., there are no more 
 characters to read. If you invoke the read() method with the stream position at the end of 
 the file, you merely obtain
  
  
 5
 An explicit line break has been added for display purposes—Python tries to display the string on a single 
 line but the output is “wrapped” to the following line at the edge of the window.",NA
10.1.2 ,NA,NA
readline(),"Unlike read(), which reads the entire contents of a file in one shot, the readline() method 
 reads a single line and returns this line as a string. This is illustrated in Listing 10.6 where 
 the file info.txt is read one line at a time. To illustrate how Python keeps track of where it is 
 within the file, the tell() method is also called to show the stream position. Typically there 
 is no reason to display this information—it is sufficient that Python is keeping track of it. 
 The code is discussed following the listing.
  
 Listing 10.6
  Demonstration of the use of readline() to read the contents of a file one line at 
 a time. The tell() method is used merely to show how the stream position advances with 
 each invocation of readline().
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12
  
  
 >>>
  file
  =
  open
 (
 ""info.txt""
 ,
  ""r""
 ) 
  
 >>>
  file
 .readline() 
  
 # Read one line.
  
 ’This file contains some numbers (and text).\n’
 >>>
  file
 .tell() 
  
 # 
 Check on stream position.
  
 44  
  
  
  
  
 # Read second line. 
 >>>
  
 file
 .readline()
  
 ’4,  
 5,  
 6,  
 12\n’ 
 >>>
  file
 .tell() 
  
 63  
  
  
  
  
 # Read third line. 
 >>>
  
 file
 .readline()
  
 ’12.3 37.2 -15.7\n’ 
 >>>
  file
 .tell()",NA
10.1.3 ,NA,NA
readlines(),"An alternative approach for conveniently reading the entire contents of a file is offered by 
 the readlines() method. The readlines() method is somewhat like read() in that it reads the 
 entire file.
 6
 However, rather than returning a single string, readlines() returns a list in 
 which each element of the list is a line from the file. This is demonstrated in Listing 10.7 
 which is discussed following the listing.
  
 Listing 10.7
  Demonstration of the use of the readlines() method .
  
 1 
  
 2
  
  
 >>>
  file
  =
  open
 (
 ""info.txt""
 ,
  ""r""
 ) 
  
 >>>
  lines =
  file
 .readlines() 
  
 # Read all lines into a list.
  
  
  
  
 6
 Actually these methods read from the current stream position to the end of the file as discussed in more 
 detail later.",NA
10.1.4 ,NA,NA
File Object Used as an Iterable,"Rather than using readlines() to read the lines of file into a list and
  then
  using a for-loop to 
 cycle through the elements of this list, one can use the file object itself as the iterable in the 
 for-loop header. In this case the file will be read line-by-line, i.e., for each iteration of the 
 for-loop the loop variable will be assigned a string corresponding to a line of the file. Lines 
 are read, in order, from the current stream position until the end of the file.
  
 In some applications input files are huge. It thus requires significant memory to read 
 and store the entirety of these files. However, by using the file object as the for-loop 
 iterable, only one line is read (and processed) at a time. In this way it is possible to process 
 files that are tremendously large without using much memory.
  
 The use of a file object as the iterable of a for-loop is illustrated in Listing 10.8.",NA
10.1.5 ,NA,NA
Using More than One Read Method,"As mentioned in Sec. 10.1.3, when the read() or readlines() methods are called, the reading 
 starts from the current stream position. To help illustrate this, consider a situation in which 
 the first two lines of a file are comment lines or provide header information or simply need 
 to be handled differently than the rest of the file. In this case these two lines could be read 
 using the readline() method and then the remainder of the file could be conveniently read 
 using either readlines() or read().
  
 The “mixing” of read methods is demonstrated in Listing 10.10. The file is opened in line 
 1. The first and second lines are read in lines 2 and 3, respectively. Then, in line 4, the 
 readlines() method is invoked as the iterable of the for-loop. The strings returned by 
 readlines() are assigned to the loop variable line and printed using the print() statement in 
 line 5. The fact that there are only three lines of output (shown in lines 7 through 9) shows 
 that readlines() starts reading the file from its third line.
  
 Listing 10.10
  The first two lines of a file are read using readline() and the remainder of the 
 file is read using readlines().
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
  
 >>>
  file
  =
  open
 (
 ""info.txt""
 ,
  ""r""
 ) 
  
 >>>
  line_one =
  file
 .readline() 
  
 >>>
  line_two =
  file
 .readline() 
  
 >>>
  for
  line
  in file
 .readlines(): 
  
 ... 
  
 print
 (line, end=
 """"
 ) 
  
 ...
  
 12.3 37.2 -15.7 
 This is the last line.",NA
10.2,NA,NA
Writing to a File,"The converse of reading from a file is writing to a file. To do this, we again open the file 
 with the open() function. As with opening a file for reading, the first argument is the file 
 name. Now, however, the second argument (the mode) must be ’w’.
  Caution:
  When you 
 open a file for writing, you destroy any previous file that existed with this file name in the 
 current working directory.
  Because open() can destroy existing files, any time you plan to 
 open a file for writing",NA
10.2.1 ,NA,NA
write() and print(),"The write() method takes a single argument which is the string to be written to the file. The 
 write() method is much less flexible than the print() function. With the print() function we 
 can use any number of arguments and the arguments can be of any type. Furthermore, 
 using the optional sep and end parameters, we can specify the separator to appear between 
 objects and how the line should be terminated. In contrast, the write() method only accepts 
 a single
  string 
 as its argument (or, of course, any expression that returns a string). 
 However, this is not quite as restrictive as it might first appear. Using string formatting, we 
 can easily represent many objects as a single string. As an example of such a construction, 
 first consider the code in Listing 10.11 which uses the print() function to display three 
 variables.
  
 Listing 10.11
  Use of the print() function to display three values.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 >>>
  a = 1.0 
  
 >>>
  b =
  ""this"" 
  
 >>>
  c = [12, -4] 
  
 >>>
  print
 (a, b, c) 
  
 1.0 this [12, -4] 
  
 The code in Listing 10.12 produces the same output as Listing 10.11, but in this case the 
 output goes to the file foo.dat. In line 1 the file is opened and assigned to the identifier file 
 out. In line 5 the write() method is called with a single string argument. However, this 
 string is the one produced by the format() method acting on the given format string which 
 contains three replacement fields (see the discussion of replacement fields in Sec. 9.7). The 
 resulting string is the same as representation of the three objects displayed in line 5 of 
 Listing 10.11, i.e., after this code has been run, the file foo.dat will contain the same output 
 as shown in line 5 of Listing 10.11. Line 7 of Listing 10.12 invokes the close() method on 
 file out. If you look at the contents of the file foo.dat before calling the close() method, you 
 will probably
  not
  see the output generated by the write() method. The reason is that, in the 
 interest of speed and efficiency, the output is
  buffered
 . Writing from internal computer 
 memory to external memory (such as a disk drive) can be slow. The fewer times such an 
 operation occurs, the better. When output is buffered, it is stored internally and not written 
 to the file until there are “many” characters to write or until the file is closed.
 7
  
 Listing 10.12
  Use of the write() method to write a single string. Use of a format string and 
 the format() method gives the same representation of the three objects as produced by the 
 print() statement in Listing 10.11.",NA
10.2.2,NA,NA
writelines(),"The writelines() method takes a sequence as an argument, e.g., a tuple or a list. Each element 
 of the sequence must be a string. In some sense writelines() is misnamed in that it doesn’t 
 necessarily write
  lines
 . Instead, it writes elements of a sequence (but a method name of 
 writeelementsofsequence() isn’t very appealing). If all the elements of the sequence end with 
 the newline character, then the output will indeed be as if writelines() writes lines. Consider 
 the code shown in Listing 10.15 which creates two files, out 1.txt and out 2.txt. The 
 writelines() method is used to write the list values 1 to out 1.txt and the tuple values 2 to out 
 2.txt. The significant difference between these two statements is not that one argument is a 
 tuple and the other is a list (this distinction is of no concern to writelines()). Rather, it is that 
 the strings in values 2 are terminated with newline charac-ters but the strings in values 1 are 
 not. The discussion continues following the listing.
  
 Listing 10.15
  Demonstration of the use of the writelines() method.",NA
10.3,NA,NA
Chapter Summary,"If the stream position is at the end of a file, 
 read() and readline() return empty strings 
 while readlines() returns an empty list.
  
 A file object can be used as the iterable in a 
 for-loop.
  
 The
  close()
  method is used to close a file ob-
 ject. It is an error to read from a closed file.
  
 The
  write()
  method can be used to write a 
 string to a file.
  
 A print() statement can also be used to print 
 to a file (i.e., write a string to a file) using the 
 optional file argument. A file object must be 
 provided with this argument.
  
 The
  writelines()
  method takes a sequence 
 of strings as its argument and writes them to 
 the given file as a continuous string.
  
 Files are opened for reading or writing using 
 the open() function. The first argument is 
 the file name and the second is the mode (’r’ 
 for read,’w’ for write). Returns a
  file object
 .
  
 The stream position indicates the next 
 character to be read from a file. When the 
 file is first opened, the stream position is 
 zero.
  
 Contents of a file can be obtained using the 
 fol-lowing file-object methods:
  
 •
  read()
 : Returns a string corresponding 
 to the contents of a file from the current 
 stream position to the end of the file.
  
 •
  readline()
 : Returns, as a string, a sin-gle 
 line from a file.
  
 •
  readlines()
 : strings, one for each line of 
 a file, from the Returns a list of
  
 current stream position to the end of",NA
Review Questions,CHAPTER 10. READING AND WRITING FILES,NA
10.4,"1. Assume the file input.txt is opened successfully in the following. What is the type of the 
 variable z after the following code is executed:
  
 file
  =
  open
 (
 ""input.txt""
 ,
  ""r""
 ) 
  
 z =
  file
 .readlines()
  
 (a) list
  
 (b) str
  
 (c) file object
  
 (d) None of the above.
  
 (e) This code produces an error.
  
 For problems 2 through 9, assume the file foo.txt contains the following:
  
 This is 
  
 a test.
  
 Isn’t it? 
  
 I think so.
  
 2. What output is produced by the following?
  
 file
  =
  open
 (
 ""foo.txt""
 ,
  ""r""
 ) 
  
 s =
  file
 .read() 
  
 print
 (s[2])
  
 3. What output is produced by the following?
  
 file
  =
  open
 (
 ""foo.txt""
 ,
  ""r""
 ) 
  
 file
 .readline() 
  
 print
 (
 file
 .readline(), end=
 """"
 )
  
 4. What output is produced by the following?
  
 file
  =
  open
 (
 ""foo.txt""
 ,
  ""r""
 ) 
  
 for
  line
  in file
 : 
  
  
 print
 (line[0], end=
 """"
 )
  
 5. What output is produced by the following?
  
 file
  =
  open
 (
 ""foo.txt""
 ,
  ""r""
 ) 
  
 s =
  file
 .read() 
  
 xlist = s.split() 
  
 print
 (xlist[1])",NA
Chapter 11,NA,NA
Conditional Statements,"So far we have written code that is executed sequentially, i.e., statements are executed in 
 the order in which they are written. However there are times when we need to alter a 
 program’s flow of execution so that certain statements are only executed when a condition 
 is met. To accomplish this we use
  conditional statements
 . For example, a conditional 
 statement can be used to check whether a student’s score on an exam is above a given 
 value. If it is, perhaps a particular message is printed; if not, a different message is printed. 
 As a second example, assume some operation must be performed on lines read from a file, 
 but lines that start with a certain character should be ignored (perhaps this character 
 indicates the line is a comment). In this case we use a conditional statement to check the 
 first character of the line and have the program act appropriately.
  
 The simplest form of a conditional statement is an if statement. As you will see, in an if 
 statement a
  test expression
  is checked to see if it is “true.” If it is, the body of the if statement 
 is executed. Conversely, if the test expression is “false,” the body of the if statement is not 
 executed.
  
 In this chapter we define what we mean by true and false in the context of conditional 
 state-ments. We also explore many other programming elements related to conditional 
 statements, in-cluding Boolean variables, comparison operators, logical operators, and 
 while-loops.",NA
11.1,NA,NA
"if Statements, Boolean Variables, and bool()","George Boole was an English mathematician and logician who lived in the 1800’s and 
 formalized much of the math underlying digital computers. A
  Boolean expression
  is an 
 expression in which the terms have one of only two states which we conveniently think of 
 as true or false. Furthermore, a Boolean expression evaluates to only one of two states: true 
 or false. Although you probably aren’t acquainted with all the rigors of Boolean 
 expressions, you are already quite familiar with them at some level because you frequently 
 encounter them in your day-to-day life.
  
 As an example of a Boolean expression, assume you are considering whether or not to 
 go to a Saturday matinee. You might boil your decision down to the weather (you rather be 
 outside when the weather is nice)
  and
  the movie’s rating at
  rottentomatoes.com
  (perhaps 
 you only go to movies that have a rating over 80 percent). We can think of your decision as 
 being governed by a Boolean expression. The terms in the expression are “nice weather”",NA
11.2,NA,NA
Comparison Operators,"The fact that Python is able to treat every object (and hence every expression) as either 
 True or False provides a convenient way to construct parts of many programs. However, 
 we are often interested in making a decision based on a comparison. For example, when it 
 comes to determining whether the weather is “nice” we may want to base our decision on 
 the temperature and wind speed, for example, is the temperature greater than 60 but less 
 than 80 and is the wind speed less than 15 mph? In order to accomplish such comparisons 
 we use
  comparison operators
 .
 2
  
 2
 In other languages these are often called relational operators.",NA
11.3,NA,NA
Compound Conditional Statements,"In the add day() function in Listing 11.12 there are some statements that should be 
 executed only if the given day is not the last day of the month. On the other hand, there are 
 other statements that should only be executed if the day
  is
  the last day of the month. In this 
 function an if statement coupled with a return statement ensures that only one set of 
 statements is executed. There are many instances like this one in which we want either one 
 block of code or another to be executed. However, we generally can’t use (or don’t want to 
 use) the return statement as is done in the add day() function. Instead, we should use an if-
 else statement. Extending this idea, there are times when there are several different blocks 
 of code that we want to select from, i.e., only one of multiple possible blocks should be 
 executed. In such cases we should use an if-elif-else statement. We explore both if-else and 
 if-elif-else statements in this section.",NA
11.3.1 ,NA,NA
if-else Statements,"The template for an if-else statement is shown in Listing 11.13.
  
 Listing 11.13
  Template for an if-else statement.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 if
  <test_expression>
 : 
  
  
 <body_1> 
  
 else
 : 
  
  
 <body_2>
  
  
 As with an if statement, if the test expression in the header evaluates to True, then the code 
 immediately following the header is executed, i.e., the code identified as body 1. However, if 
 the test expression evaluates to False, then the code following the else is executed, i.e., body 
 2 is executed but body 1 is skipped. Thus, one body of code is executed but not the other. 
 Listing 11.14 demonstrates the use of if-else statements.
  
 Listing 11.14
  Demonstration of an if-else statement.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 >>>
  grade = 95 
  
 >>>
  if
  grade > 80: 
  
 ... 
  
 print
 (
 ""Keep up the good work.""
 ) ...
  else
 : 
  
 ... 
  
 print
 (
 ""Try working harder.""
 ) ...
  
 Keep up the good work. 
  
 In line 1 grade is assigned the value 95. In line 2 we ask if the grade is greater than 80. Since 
 it is, the first body is executed (and the second body is skipped). This results in the output 
 shown in line 7.",NA
11.3.2,NA,NA
if-elif-else Statements,"Using an if-elif-else statement we can write programs that execute at most one among 
 multiple bodies of code. 
  
 The elif should be thought of as “else if.”
  
 The template for an 
 if-elif-else statement is shown in Listing 11.18. The statement must start with an if header 
 (and its corresponding body). This is followed by any number of elif headers (and their 
 bodies). Each elif header has its own test expression. The final else is optional. When this 
 statement is executed, the first test expression is evaluated. If it is True, the first body is 
 executed and the rest of the if-elif-else statement is skipped. If the first test expression 
 evaluates to False, the first body is skipped and the second test expression is evaluated. If it 
 is True, the second body is executed and the rest of the if-elif-else statement is skipped. If 
 the second test expression evaluates to False, the second body is skipped and the third test 
 expression is evaluated. And so on. If none of the test expressions are True, then the body 
 accompanying the else part of the statement is executed if it is present. However, since the 
 else part is optional, it may be that none of the bodies are executed.
  
 Listing 11.18
  Template for an if-elif-else statement.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
  
 if
  <test_expression_1>
 : 
  
  
 <body1> 
  
 elif
  <test_expression_2>
 : 
  
  
 <body2> 
  
 elif
  <test_expression_3>
 : 
  
  
 <body3> 
  
  
  
 .",NA
11.4,NA,NA
Logical Operators,"We started Sec. 11.1 with a description of a Boolean expression taken from daily life, 
 namely the decision to go to the matinee if the following evaluates to true:
  not
  nice weather
  
 and
  rating over 80 percent. Deciding what constitutes “nice” weather may be a complicated 
 one, but let us assume we are thinking Pythonically and have a Boolean variable nice 
 weather that has been appropriately set. Further assume we have a variable rating that 
 stores the rating for a particular movie (and perhaps we’ll need a for-loop to cycle through 
 the ratings of multiple",NA
11.5,NA,NA
Multiple Comparisons,"In the show grade() function in Listing 11.19 an if-elif-else statement was used to 
 determine the range within which a given score fell. This construct relied upon the fact that 
 we progressively tested to see if a value exceeded a certain threshold. Once the value 
 exceeded that threshold, the appropriate block of code was executed. But, what if we want 
 to directly check if a value falls within certain limits? Say, for example, we want to test if a 
 score is greater than or equal to 80 but less than 90. If a value falls in this range, assume we 
 want to print a message, for example, This score corresponds to a B. How should you 
 implement this? Prior to learning the logical operators in the previous section, we would 
 have used nested if statements such as:
  
 if
  score >= 80: 
  
  
 if
  score < 90: 
  
  
  
 print
 (
 ""This score corresponds to a B.""
 )
  
 Having learned about the logical operators, we can write this more succinctly as
  
 if
  score >= 80
  and
  score < 90: 
  
  
 print
 (
 ""This score corresponds to a B.""
 )
  
 In the majority of computer languages this is how you would implement this conditional 
 statement. However, Python provides another way to implement this that is aligned with 
 how ranges are often expressed in mathematics. We can directly “chain” comparison 
 operators. So, the code above can be implemented as
  
 if
  80 <= score < 90: 
  
  
 print
 (
 ""This score corresponds to a B.""
 )
  
 or
  
 if
  90 > score >= 80: 
  
  
 print
 (
 ""This score corresponds to a B.""
 )
  
 This can be generalized to any number of operators. If cmp is a comparison operator and op 
 is an operand, Python translates expressions of the form
  
 op1 cmp1 op2 cmp2 op3 ... opN cmpN op{N+1}
  
 to
  
 6
 This expression is known as the
  exclusive or
  of x and y.",NA
11.6,NA,NA
while-Loops,"By now, we are quite familiar with for-loops. for-loops are definite loops in that we can 
 typically determine in advance how many times the loop will execute. (A possible exception 
 to this is when a for-loop is in a function and there is a return statement in the body of the 
 loop. Once the return statement is encountered, the loop is terminated as well as the 
 function that contained the loop.) However, often we need to have looping structures in 
 which the number of iterations of the loop cannot be determined in advance. For example, 
 perhaps we want to prompt a user for data and allow the user to keep entering data until 
 the user provides some signal that they are done. Rather than signaling when they are 
 done, the user can potentially be asked to start by specifying the amount of data to be 
 entered. In this case we can stick to using a for-loop, but this can be quite inconvenient for 
 the user. Rather than using a definite loop, we want to use an
  indefinite loop",NA
11.6.1,NA,NA
Infinite Loops and break,"There is something slightly awkward about the code in Listing 11.24. Note that there is one 
 call to input() outside the loop (line 3) and another inside the loop (line 7). Both these calls 
 use the same prompt and assign input()’s return value to the same variable, so there 
 appears to be a needless duplication of code, but there doesn’t seem to be a simple way 
 around this duplication. The first call to input() starts the process. If a user enters a name at 
 the first prompt, then the while-loop is executed to obtain a list with as many additional 
 names as the user cares to enter.
  
 However, there is an alternative construction that is arguably “cleaner.” The new 
 implementa-tion relies on the use of a break statement. break statements are placed inside 
 loops and are almost always embodied within an if statement. When a break statement is 
 executed, the sur-rounding loop is terminated immediately (i.e., regardless of the value of 
 the test expression in the header) and execution continues with the statement following 
 the loop. break statements can be used with for-loops and while-loops.
  
 Before showing examples of break statements, let us consider
  infinite loops
 . Infinite 
 loops are loops that theoretically run forever because the text expression in the header of 
 the loop never evaluates to False. Such a situation may arise either because the loop was 
 intentionally coded in such a way or because of a coding error. For example, consider the 
 following code where perhaps
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 the programmer intended to print the numbers 0.1, 0.2,
  · · ·
  , 0.9:
  
 x = 0.0 
  
 while
  x != 1.0: 
  
  
 x = x + 0.1 
  
  
 print
 (x)
  
  
 In line 1 x is initialized to 0.0. The header of the while-loop in line 2 dictates that the loop 
 should be executed if x is not equal to 1.0. Looking at line 3 in the body of the loop we see 
 that x is incremented by 0.1 for each iteration of the loop. Thus it seems the loop should 
 execute 10 times and then stop. However this is not the case. Recalling the discussion of 
 Listing 11.10, we know that, because of the round-off error in floats, summing 0.1 ten times 
 does not equal 1.0. Thus the value of x is never equal to 1.0 and hence the loop does not 
 stop of its own accord (we have to terminate the loop either by hitting control-C on a Mac 
 or Linux machine or by typing control-Z followed by a return on a Windows machine).
  
 If a while-loop’s test expression is initially True and there is nothing done in the body of 
 the loop to affect the test expression, the loop is an infinite loop. It is not uncommon to",NA
11.6.2 ,NA,NA
continue,"There is one more useful statement for controlling the flow of loops. The continue 
 statement dictates termination of the current iteration and a return to execution at the top 
 of the loop, i.e., the test expression should be rechecked and if it evaluates to True, the body 
 of the loop should be executed again.
  
 For example, assume we again want to obtain a list of names, but with the names 
 capitalized. If the user enters a name that doesn’t start with an uppercase letter, we can 
 potentially convert the string to a capitalized string ourselves. However, perhaps the user 
 made a typo in the entry. So, rather than trying to fix the name ourselves, let’s start the loop 
 over and prompt for another name. The code in Listing 11.27 implements this function and 
 is similar to the code in Listing 11.26. The difference between the two implementations 
 appears in lines 6 through 8 of Listing 11.27. In line 6 we use the islower() method to check 
 if the first character of the name is lowercase. If it is, the print() in line 7 is executed to 
 inform the user of the problem. Then the continue statement in line 8 is executed to start 
 the loop over. This ensures uncapitalized names are not appended to the names list. The 
 remainder of the listing demonstrates that the code works properly.
  
 Listing 11.27
  A while loop that uses a continue statement to ensure all entries in the names 
 list are capitalized
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17 
 18 
 19 
 20 
 21
  
  
 >>>
  names = [] 
  
 >>>
  while True
 : 
  
 ... 
  
 name =
  input
 (
 ""Enter name [<ret> when done]: ""
 ) 
  
 ... 
  
 if not
  name: 
  
 ... 
  
  
 break 
  
 ... 
  
 if
  name[0].islower(): 
  
 ... 
  
  
 print
 (
 ""The name must be capitalized. 
  
 Try again...""
 ) ... 
  
  
 continue 
  
  
 names.append(name) ...
  
 ...
  
 Enter name [<ret> when done]:
  Miya 
  
 Enter name [<ret> when done]:
  maude 
  
 The name must be capitalized. Try again... 
 Enter name [<ret> when done]:
  Maude 
  
 Enter name [<ret> when done]:
  Mary 
  
 Enter name [<ret> when done]:
  mabel 
  
 The name must be capitalized. Try again... 
 Enter name [<ret> when done]:
  Mabel 
  
 Enter name [<ret> when done]:  
 >>>
  print
 (names) 
  
 [’Miya’, ’Maude’, ’Mary’, ’Mabel’] 
  
 The continue statement can be used with for-loops as well. Let’s consider one more 
 example that again ties together many things we have learned in this chapter and in 
 previous ones. Assume we want to write code that will read lines from a file. If a line starts 
 with the hash symbol (#), it is taken to be a comment line. Comment lines are printed to the 
 output and the rest of the",NA
11.7,NA,NA
Short-Circuit Behavior,"The logical operators and and or are sometimes referred to as
  short-circuit operators
 . This 
 has to do with the fact that Python will not necessarily evaluate both operands in a logical 
 expres-sion involving and and or. Python only evaluates as much as needed to determine if 
 the overall expression is equivalent to True or False. Furthermore, these logical 
 expressions don’t nec-essarily
  evaluate
  to the literal Booleans True or False. Instead, they 
 evaluate to the value of one operand or the other, depending on which operand ultimately 
 determines whether the expres-sion should be considered True or False. Exploiting the 
 short-circuit behavior of the logical operators is a somewhat advanced programming 
 technique. It is described here for three reasons: (1) short-circuit behavior can lead to bugs 
 that can be extremely difficult to detect if you don’t understand short-circuit behavior, (2) 
 the sake of completeness, and (3) as you progress in your programming you are likely to 
 encounter code that uses short-circuit behavior.
  
 Let us first consider the short-circuit behavior of and. If the first operand evaluates to 
 False, there is no need to evaluate the second operand because False and’ed with anything 
 will still be False. To help illustrate this, consider the code in Listing 11.29. In line 1 False is 
 and’ed with a call to the print() function. If print() is called, we see an output of Hi. 
 However, Python doesn’t call print() because it can determine this expression evaluates to 
 False regardless of what the second operand returns. In line 3 there is another and 
 expression but this time the first operand is True. So, Python must evaluate the second 
 operand to determine if this expression should be considered True or False. The output of 
 Hi on line 4 shows that the print() function is indeed called. But, what does the logical 
 expression in line 3 evaluate to? The output in line 4 is rather confusing. Does this 
 expression evaluate to the string Hi? The answer is no, and the subsequent lines of code, 
 discussed below the listing, help explain what is going on.
  
 Listing 11.29
  Demonstration of the use of and as a short-circuit operator.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12
  
  
 >>>
  False and print
 (
 ""Hi""
 ) 
  
 False  
 >>>
  True and print
 (
 ""Hi""
 ) 
  
 Hi  
 >>>
  x =
  True and print
 (
 ""Hi""
 ) 
  
 Hi  
 >>>
  print
 (x) 
  
 None  
 >>>
  if True and print
 (
 ""Hi""
 ): 
  
 ... 
  
 print
 (
 ""The text expression evaluated to True.""
 ) ...
  else
 : 
  
 ... 
  
 print
 (
 ""The text expression evaluated to False.""
 )",NA
11.8,NA,NA
The in Operator,"Two comparison operators were omitted from the listing in Listing 11.9: in and is. The is 
 operator is discussed in Sec. 7.3. It returns True if its operands refer to the same memory 
 and returns False otherwise. The is operator can be a useful debugging or instructional 
 tool, but otherwise it is not frequently used. In contrast to this, the in operator provides a 
 great deal of utility and is used in a wide range of programs. The in operator answers the 
 question: is the left operand contained in the right operand? The right operand must be a 
 “collection,” i.e., an iterable such as a list or tuple.
  
 We can understand the operation of the in operator by writing a function that mimics 
 its be-havior. Listing 11.34 defines a function called my in() that duplicates the behavior of 
 the in operator. The only real difference between my in() and in is that the function takes 
 two argu-ments whereas the operator is written between two operands. The function is 
 defined in lines 1 through 5. It has two parameters called target and container. The goal is 
 to return True if target matches one of the (outer) elements of container. (If container has 
 other contain-ers nested inside it, these are not searched.) If target is not found, the 
 function returns False. The body of the function starts with a for-loop which cycles over the 
 elements of container. The if statement in line 3 tests whether the element matches the 
 target. (Note that the test uses the “double equal” comparison operator.) If the target and 
 element are equal, the body of the if statement is executed and returns True, i.e., the 
 function is terminated at this point and control returns to the point of the program at 
 which the function was called. If the for-loop cylces through all the elements of the 
 container without finding a match, we reach the last statement in the body of the function, 
 line 5, which simply returns False. Discussion of this code continues following the listing.
  
 Listing 11.34
  The function my in() duplicates the functionality provided by the in operator.
  
 1
  
  
 >>>
  def
  my_in(target, container):",NA
11.9,NA,NA
Chapter Summary,"True.
  
 The
  bool()
  function returns either True or 
 False depending on whether its argument is 
 equivalent to True or False.
  
 The template for an
  if
  statement is
  
 if
  <test_expression>: 
 <body>
  
  
 Python provides the Boolean literals
  True
  
 and 
 False
 .
  
 When used in a conditional statement, all 
 ob-jects are equivalent to either True or 
 False. Numeric values of zero, empty 
 containers (for example, empty strings and 
 empty lists), None, and False itself are 
 considered to be False. All other objects are 
 considered to be",NA
11.1,NA,NA
Review Questions,"1. Consider the following code. When prompted for input, the user enters the string 
 SATURDAY. What is the output?
  
 day =
  input
 (
 ""What day is it? ""
 ) 
  
 day = day.lower()",NA
Chapter 12,NA,NA
Recursion,NA,NA
12.1,NA,NA
Background,"Recursion is a powerful programming construct that provides an elegant way to solve large 
 prob-lems by breaking them down into simpler subproblems. In this way it is often 
 possible to solve seemingly complex problems via repeated application of very simple 
 solutions to the subproblems.
  
 In programming languages, when we talk about recursion we talk in terms of recursive 
 func-tions.
 1
 A recursive function is a function that calls itself somewhere in its definition, 
 i.e., in some sense, the function is defined in terms of itself. At first this may seem confusing. 
 After all, if we use a word to define itself, for example, if we say, “a tautology is a tautology,” 
 then we haven’t helped to clarify what a tautology is.
 2
 So, clearly there must be something 
 more to a useful recursive function than the mere fact that it uses itself within its own 
 definition.",NA
12.2,NA,NA
Flawed Recursion,"We will consider the proper implementation of a recursive function in a moment, but let’s 
 start by considering some flawed implementations because it is important to recognize 
 how you must 
 not
  implement a recursive function. You could easily write a function that 
 uses itself in its own definition and hence is arguably a recursive function. Consider the 
 function r1() defined in Listing 12.1 which is the simplest possible (albeit flawed) 
 implementation of a recursive function. This function has no arguments and the entire 
 body of the function is merely a call to the function itself. Thus, when we call r1(), the body 
 of the function says to call the function r1(). So, r1() will be called again only to find that 
 r1() should be called again, and so on. In theory, these successive calls would go on forever, 
 never doing anything useful. However, in practice, these successive calls can’t go on 
 forever; something must ultimately break if r1() is called (for example, it requires some 
 memory to keep track of function calls so perhaps your computer ultimately runs out of 
 memory).
  
 From the file: recursion.tex 
  
 1
 Not all computer languages support recursive functions, but nearly all modern 
 languages do.
  
  
 2
 A tautology is, according to Webster’s Collegiate Dictionary, 5th ed., “needless repetition of meaning in 
 other words; also, an instance of this as ‘audible to the ear’.”",NA
12.3,NA,NA
Proper Recursion,"Now we can ask: What causes the errors shown in Listings 12.1 and 12.3? Thinking about 
 how r1() and r2() are defined, we see that they “never” stop calling themselves, i.e., they 
 keep calling themselves until the recursion limit is reach. When this limit is reached one 
 obtains the RuntimeError error messages shown in the listings. To prevent this error and 
 to make a useful recursive function,
  a recursive function must possess two vital features
 :
  
 3
 On the system on which this particular example was run, the maximum recursion depth was set to 1000. 
 This
  
 is true despite the fact that there are 997 integer values displayed in the output.
  
 You can obtain the recursion
  
 limit with the following two statements: import sys; print(sys.getrecursionlimit()). The func-tion 
 getrecursionlimit() in the sys module is used to set the recursion limit to a different value.",NA
Merge Sort,CHAPTER 12. RECURSION,NA
12.4,"All the previous examples were intended to illustrate the implementation and behavior of 
 recursive functions. They were not, however, very practical and there are much simpler 
 ways to obtain identical results without using recursion. Now we want to consider a much 
 more practical, “real world” application of recursion. We want to demonstrate how 
 recursion can be used to efficiently sort the elements of a list. Before digging into the 
 details, there are two important things to note. First, the subject of sorting is actually quite 
 a complicated one! Though quite interesting at times, we will not delve into any of the 
 complexities of the subject. Suffice it to say that, although the algorithm we will consider 
 here is quite good, it is not optimum. Second, don’t forget that lists have a sort() method 
 and, in fact, there is a built-in function called sorted() that can be used to sort iterables. 
 These can be used to sort iterables more efficiently than the approach described here.
  
 The algorithm we will implement is called merge-sort. A key component of the algorithm is 
 the ability to merge two lists that are assumed to be in sorted order. The resulting list is also 
 in sorted order. Given the ability to merge lists in this way, we can start with an unsorted list 
 and (recursively) break it down into a collection of single-element lists. A single-element list 
 is inherently sorted. We can merge the single-element lists into sorted two-element lists. We 
 can then merge the resulting two-element lists into four-element lists, and so on, until we 
 have obtained all the elements in sorted order. (Despite the description here, the number of 
 elements does not have to be a power of two as will be made more clear below.) 
  
 Let’s start by considering the merge() function shown in Listing 12.12. This is a non-
 recursive function that returns the a single list that contains all the elements of the two lists 
 it is given as arguments. It is assumed the two lists this function is passed are already 
 sorted. The list the function returns is also sorted. So, for example, if the function is passed 
 the lists [1, 4] and [2, 3], the resulting list is [1, 2, 3, 4]. The discussion continues following 
 the listing.
  
 Listing 12.12
  The merge() function that merges two sorted lists and returns a single sorted 
 list.
  
 1 
  
 2 
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13 
  
 14 
  
 15
  
  
 >>>
  def
  merge(left, right):
  
 ... 
  
 result = [] 
  
 # Accumulator for merged list.
  
 ... 
  
 while len
 (left) > 0
  or len
 (right) > 0:
  
 ... 
  
 if len
 (left) > 0
  and len
 (right) > 0:
  
 ... 
  
 if
  left[0] <= right[0]: 
  
 # left smaller than right.
  
 ... result.append(left[0]) 
  
 # Append element from left.
  
 ... left = left[1 : ] 
  
 # Remove first left element
  
 ... 
  
 else
 : 
  
 # right smaller than left.
  
 ... result.append(right[0])
  # Append element from right.
  
 ... right = right[1 : ] 
  
 # Remove first right element.
  
 ... 
  
 elif len
 (left) == 0: 
  
 # No elements in left.
  
 ... 
  
 result.extend(right) 
  
 # Extend by remaining right elements.
  
 ... 
  
 break 
  
 # Terminate loop.
  
 ... 
  
 else
 : 
  
 # No elements in right.
  
 ... 
  
 result.extend(left) 
  
 # Extend by remaining left elements.",NA
Chapter 13,NA,NA
Turtle Graphics,NA,NA
13.1,NA,NA
Introduction,"Graphical User Interfaces (GUI’s) provide a rich environment in which information can be 
 ex-changed between a user and the computer. GUI’s are not limited to simply displaying 
 text and reading text from the keyboard. GUI’s enable users to control the behavior of a 
 program by per-forming actions such as using the mouse to drag or click on graphical 
 objects. GUI’s can make using programs much more intuitive and easier to learn since they 
 provide users with immediate visual feedback that shows the effects of their actions.
  
 There are many Python packages that can be used to create graphics and GUI’s. Two 
 graphics modules, called turtle and tkinter, come as a part of Python’s standard library. 
 tkinter is primarily designed for creating GUI’s. In fact, IDLE is built using tkinter. However, 
 we will focus on the turtle module that is primarily used as a simple graphics package but 
 can also be used to create simple GUI’s.
  
 The turtle module is an implementation of turtle graphics and uses tkinter for the 
 creation of the underlying graphics. Turtle graphics dates back to the 1960’s and was part 
 of the Logo programming language.
 1
 This chapter provides an introduction to using the 
 graphics capabilities of the turtle module and demonstrates the creation of simple images 
 and simple GUI’s for games and applications. We will not delve into the details of building 
 and designing GUI’s, but many of the skills developed here can be applied to more 
 complicated GUI designs if you wish to pursue that in the future. In addition to helping you 
 gain practical programming skills, learning to use turtle graphics is fun and it enables you 
 to use Python to be visually creative!",NA
13.2,NA,NA
Turtle Basics,"Among other things, the methods in the turtle module allow us to draw images. The idea 
 behind the turtle part of “turtle graphics” is based on a metaphor. Imagine you have a turtle 
 on a canvas that is holding a pen. The pen can be either up (not touching the canvas) or 
 down (touching the canvas). Now think of the turtle as a robot that you can control by 
 issuing commands. When the
  
 From the file: turtle-graphics.tex 
  
 1
 See
  en.wikipedia.org/wiki/Turtle graphics",NA
13.2.1 ,NA,NA
Importing Turtle Graphics,"In order to start using turtle graphics, we need to import the turtle module. Start 
 Python/IDLE and type the following:
  
 Listing 13.1
  Importing the turtle module.
  
 >>>
  import
  turtle
  as
  t
  
 This imports the turtle module using the identifier t. By importing the module this way 
 we access the methods within the module using t.
 <object>
  instead of turtle.
 <object>
 . To 
 ensure that the module was properly imported, use the dir() function as shown in Listing 
 13.2.
  
 Listing 13.2
  Using dir() to view the turtle module’s methods and attributes.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 >>>
  dir
 (t) 
  
 [
 ’Canvas’
 ,
  ’Pen’
 ,
  ’RawPen’
 ,
  ’RawTurtle’
 ,
  ’Screen’
 ,
  ’ScrolledCanvas’
 ,
 ’Shape’
 ,
  ’TK’
 ,
  ’TNavigator’
 ,
  
 ’TPen’
 ,
  ’Tbuffer’
 ,
  ’Terminator’
 ,
 ’Turtle’
 ,
  ’TurtleGraphicsError’
 ,
  ’TurtleScreen’
 ,
  
 ’TurtleScreenBase’
 ,
 ’Vec2D’
 ,
  ’_CFG’
 ,
  ’_LANGUAGE’
 ,
  ’_Root’
 ,
  ’_Screen’
 ,
  ’_TurtleImage’
 ,
 ’__all__’
 ,
  
 ’__builtins__’
 ,
  ’__cached__’
 ,
  ’__doc__’
 ,
  ’__file__’
 , 
  
  
 ... 
  
 <<MANY LINES OF OUTPUT 
 DELETED>>
  
 ’window_width’
 ,
  ’write’
 ,
  ’write_docstringdict’
 ,
  ’xcor’
 ,
  ’ycor’
 ]
  
  
 The list returned by the dir() function in Listing 13.2 has been truncated—in all, there 
 are 173 items in this list. To learn more about any of these attributes or methods, you can 
 use the help() function. For example, to learn about the forward() method, enter the 
 statement shown in line 1 of Listing 13.3.
  
 Listing 13.3
  Learning about the forward() method using help().
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
 >>>
  help
 (t.forward) 
  
 Help on function forward in module turtle: 
 forward(distance)  
  
 Move the turtle forward by the specified distance.",NA
13.2.2 ,NA,NA
Your First Drawing,"Let’s begin by telling our turtle to draw a line. Try entering the command shown in Listing 
 13.4.
  
 Listing 13.4
  Drawing a line with a length of 100 units.
  
 >>>
  t.fd(100)
  
 As shown in Fig. 13.1, a graphics window should appear in which you see a small arrow 
 100 units to the right of the center of the window.
 2
 A thin black line is drawn from the 
 center of the window to the tail of the arrow. The arrow represents our “turtle” and the 
 direction the arrow is pointing indicates the current heading. The fd() method is a 
 shorthand for the forward() method—the two methods are identical. fd() takes one integer 
 argument that specifies the num-ber of units you want to move the turtle forward in the 
 direction of the current heading.
 3
 If you provide a negative argument, the turtle moves 
 backwards the specified amount. Alternatively, to move backward one can call either 
 backward(), back(), or bk().
  
 The default shape for our turtle is an arrow but if we wanted to have it look like a turtle we 
 could type the command shown in Listing 13.5.
  
 Listing 13.5
  Changing the shape of the turtle.
  
 >>>
  t.shape(
 ""turtle""
 )
  
 This replaces the arrow with a small turtle. We can change the shape of our turtle to a 
 number of other built in shapes using the shape() method. We can also create custom 
 shapes although we won’t cover that here.
  
  
 2
 When it first opens, this window may appear behind previously opened windows. So, you may have to 
 search for it.",NA
13.3,NA,NA
Basic Shapes and Using Iteration to Generate ,NA,NA
Graphics,"The commands shown in Listing 13.8 that we used to draw a square box would be rather 
 cum-bersome to type repeatedly if we wanted to draw more than one box. Observe that we 
 are typing the same commands four times. As you already know, this sort of iteration can 
 be accomplished in a much simpler way using a for-loop. Let’s create a function called 
 square() that draws a square using a for-loop. The function takes one argument which is 
 the length of the square’s sides. Enter the commands in Listing 13.12 that define this 
 function and then call it three times, each time with a different length. The result should be 
 the squares that are shown in Fig. 13.4.
  
 Listing 13.12
  A function that draws a square using a for-loop.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 >>>
  def
  square(length): 
  
 ... 
  
 for
  i
  in range
 (4): 
  
 ... 
  
  
 t.fd(length) 
  
 ... 
  
  
 t.left(90) 
  
 ...
  
 >>>
  square(60) 
  
 >>>
  square(100) 
  
 >>>
  square(200)
  
  
 Building a square from straight lines is relatively straightforward, but what if we want 
 to draw circles? Turtle provides a method called circle() that can be used to tell the turtle to 
 draw a complete circle or only a part of a circle, i.e., an arc. The circle() method has one 
 mandatory argument which is the radius of the circle. Optional arguments specify the 
 “extent,” which is the degrees of arc that are drawn, and the “steps,” which are the number 
 of straight-line segments used to approximate the circle. If the radius is positive, the circle 
 is drawn (starting from the current position) by turning to the left (counterclockwise). If 
 the radius is negative, the circle is drawn (starting from the current position) by turning to 
 the right (clockwise). To demonstrate this, enter the commands shown in Listing 13.13. 
 After issuing these commands, the graphics window should appear as shown in Fig. 13.5
  
 Listing 13.13
  Drawing circles using the circle() method.",NA
13.3.1 ,NA,NA
Controlling the Turtle’s Animation Speed,"If you have been watching the turtle move in the graphics window as you issue commands, 
 you will have noticed that the turtle goes through its motions relatively slowly. Sometimes 
 watching the turtle move can be helpful but there are ways that you can speed up the 
 movement (and hence speed up the drawing process). There is a speed() method for which 
 the argument specifies the speed as an integer between 0 and 10. A value of 1 is the slowest 
 speed. Speeds generally increase with increasing arguments so that 2 is faster than 1, three 
 is faster than 2, and so on. However, rather than 10 being be fastest speed, it is actually the 
 second to the fastest speed—0 is the fastest speed. The default speed is 3. To demonstrate 
 this, issue the commands shown in Listing 13.14.
  
 Listing 13.14
  Speeding up the animation by using the speed() method.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 >>>
  t.reset() 
  
 >>>
  t.speed(0) 
  
 >>>
  t.circle(100) 
  
 >>>
  t.circle(-50)
  
  
 The image should be the same as 13.5, but it should render noticeably faster than it did 
 previ-ously. However, even though supplying the speed() method with an argument of 0 
 makes the animation faster, it is still quite slow if we want to draw a more complex 
 drawing. In order to make our drawing appear almost immediately we can make use of the 
 tracer() method. tracer() takes two arguments. One controls how often screens should be 
 updated and the other controls the delay between these update. To obtain the fastest 
 possible rendering, both these arguments should be set to zero as shown in Listing 13.15.
  
 Listing 13.15
  Turning off the animation with tracer().
  
 >>>
  tracer(0, 0)
  
 By calling tracer() with bother arguments set to zero, we are essentially turning off all 
 animation and our drawings will be drawn “immediately.” However, if we turn the 
 animation off in this way we need to explicitly update the image with the update() method 
 after we are done issuing drawing commands.
  
 If you want to reset tracer() to its original settings, its arguments should be 1 and 10, as 
 shown in Listing 13.16.
  
 Listing 13.16
  Restoring animation to the default settings.
  
 >>>
  tracer(1, 10)",NA
Colors and Filled Shapes,CHAPTER 13. TURTLE GRAPHICS,NA
13.4,"Now that we know how to create some basic shapes, let’s explore how we can create more 
 complex images. In order to change the color of our turtle’s pen we can use the color() 
 method as shown in line 2 of Listing 13.17.
  
 Listing 13.17
  Changing the color of the turtle’s pen.
  
 1 
  
 2
  
  
 >>>
  t.reset() 
  
 >>>
  t.color(
 ""blue""
 )
  
  
 This change the turtle’s pen to blue. There are actually numerous ways of specifying a 
 color in Python’s implementation of turtle graphics. You can, as shown in Listing 13.17, 
 specify a color via a string.
 4
 Alternatively, we can specify a color by providing numeric 
 values the specify the amount of red, green, and blue. To learn more about the use of colors, 
 use the help() function to read about t.color or t.pencolor.
  
  
 Figure 13.6: A blue line with a thickness and width of 100.
  
 We can also change the thickness of the turtle’s pen by using the pensize() method and 
 passing it an integer argument that specifies the thickness. This is demonstrated in Listing 
 13.18. After issuing these commands (and those of Listing 13.17), you will see that a thick 
 blue line has been drawn in the graphics window as shown in Fig. 13.6
  
  
 4
 The string must be one of the Tk color specifications. 
 www.tcl.tk/man/tcl8.4/TkCmd/colors.htm.
  
 A listing of these can be found at",NA
13.4.1 ,NA,NA
Strange Errors,"As you work through the examples in this chapter you may encounter strange, complicated 
 errors that result from small typos or bugs in your code. These errors may look alarming 
 and confusing but you can usually discern the cause of the error if you look at the last few 
 lines. For example, enter the command shown in line 1 of Listing 13.22.
  
 Listing 13.22
  Error example.
  
 1 
  
 >>>
  t.color(
 ""pumpkin""
 )
  
 2 
  
 Traceback (most recent call last): File
  ""<stdin>""
 , line 1,
  in
  <module>
  
 3 
  
 File
  ""<string>""
 , line 1,
  in
  color File
  
 4 
  
 ""/Library/Frameworks/Python.framework/Versions/3.2/lib/python3.2/turtle.py""
 ,
  
 5 
  
 line 2209,
  in
  color pcolor = self._colorstr(pcolor) File
  
 6 
  
 ""/Library/Frameworks/Python.framework/Versions/3.2/lib/python3.2/turtle.py""
 ,
  
 7 
  
 line 2689,
  in
  _colorstr
  return
  self.screen._colorstr(args) File
  
 8 
  
 ""/Library/Frameworks/Python.framework/Versions/3.2/lib/python3.2/turtle.py""
 ,
  
 9 
  
 line 1151,
  in
  _colorstr
  raise
  TurtleGraphicsError(
 ""bad color string: %s""
  %
  
 10 
 str
 (color)) turtle.TurtleGraphicsError: bad color string: pumpkin
  
 The resulting error message, shown in lines 2 through 10, is long and possibly confusing 
 but if you look at the last line it tells you that “pumpkin” is not a valid color string.
  
 In the introduction to this chapter we mentioned that the turtle module uses tkinter for 
 its underlying graphics. Sometimes the errors you get will contain messages that pertain to 
 tkinter errors by using tk in the message. If you encounter one of these errors you typically 
 do not need to know anything about tkinter. It is likely the cause of the error is somewhere 
 in your turtle code, e.g., you are passing a method an incorrect value, so review your code 
 carefully and make sure it conforms to the requirements of the turtle module.",NA
13.4.2 ,NA,NA
Filled Shapes,"We can also fill the shapes we draw by using the methods begin fill() and end fill(). To fill a 
 shape, we must call first begin fill(), then issue commands to draw the desired shape, and 
 finally call end fill(). When we call end fill() the shape will be filled with the currently set 
 color. To demonstrate this, try entering the commands of Listing 13.23. After entering 
 these commands you should see a green filled box in the graphics window as shown in Fig. 
 13.9.
  
 Listing 13.23
  Commands to create a filled green box.
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 >>>
  t.reset() 
  
 >>>
  t.color(
 ""green""
 ) 
  
 >>>
  t.begin_fill() 
  
 >>>
  square(100)
  # The square() function of Listing 13.12.
  
 >>>
  t.end_fill()",NA
13.5,NA,NA
Visualizing Recursion,"Chapter 12 provides an introduction to recursion. If you haven’t done so already, it is 
 recommended that you read that chapter before working through the examples in this 
 section.",NA
13.6,NA,NA
Simple GUI Walk-Through,"The turtle module provides simple GUI functionality. One common way GUI’s interact with 
 a user is to respond to the user’s mouse clicks and perform certain actions based on those 
 clicks. This section provides a walk-through for building a simple GUI application using 
 “callback” functions to respond to mouse clicks. Callback functions are functions we write 
 that specify what should be done when a particular event occurs. We need to “register” a 
 callback function with the GUI software so that the appropriate function be called when the 
 event occurs that the function was written to process.",NA
13.6.1 ,NA,NA
Function References,"We have previously seen that we can have a reference or alias to a list, i.e., we can have 
 differ-ent identifiers that point to the same underlying memory. Also, when we pass a list 
 as an actual parameter to a function, the function’s formal parameter is a reference to that 
 list. Python also allows us to have references to functions or, to put it another way, Python 
 allows us to assign func-tions to identifiers. When we write a function name followed 
 parentheses we are indicating that we want to call that function but what happens when 
 we write a function name without parentheses? To find out, try typing the code shown in 
 Listing 13.30.",NA
Callback functions,CHAPTER 13. TURTLE GRAPHICS,NA
13.6.2,"In order to make our GUI application respond to a user’s mouse clicks, we must write a 
 function that will be called whenever the mouse is used to click on the graphics window. 
 First, as shown in Listing 13.33, let’s define a function that takes two arguments and prints 
 the value of those two arguments.
  
 Listing 13.33
  Function that prints its two arguments.
  
 1 
  
 2
  
  
 >>>
  def
  printxy(x, y): 
  
 ... 
  
 print
 (x, y)
  
  
 turtle graphics has a method called onscreenclick() that takes a single parameter. This 
 parameter is assumed to be a reference to a function that takes two arguments. This 
 function will be called whenever there is a mouse click on the graphics window. The 
 arguments passed to the function will be the
  x
  and
  y
  coordinates of the point where the 
 click occurred. To illustrate this, assuming you have entered the code in Listing 13.33, type 
 the code shown in Listing 13.34. In line 1 we “register” the printxy() function so that it will 
 be “called back” whenever there is a click on the graphics window. If you are using IDLE, 
 you will also need to call mainloop() to enable to processing of events. Once you call 
 mainloop(), the interactive prompt will disappear and it won’t reappear until you close the 
 graphics window (using the close button and the top of the window).
  
 Listing 13.34
  Use of the onscreenclick() method to register the printxy() function as a 
 callback function.
  
 >>>
  t.onscreenclick(printxy) 
  
 >>>
  t.mainloop() 
  
 # If you are using IDLE.
  
 Once you have done this, click on the graphics window in various places. You should see 
 pairs of numbers corresponding to the location of the point that was clicked! Note that 
 these pairs of numbers will be displayed in environment in which you have been issuing 
 the Python commands—the numbers will not appear in the graphics window.",NA
13.6.3 ,NA,NA
A simple GUI,"Now let’s write a more complicated turtle GUI using the square() function you wrote in Sec. 
 13.4.2. First, let’s set up the window where we exercise some fine-grain control of the 
 window’s size and coordinates. The code in Listing 13.35 show how this can be 
 accomplished using a combination of the methods setup(), screensize(), and 
 setworldcoordinates().
  
 Listing 13.35
  Dividing the graphics window into thirds.",NA
Chapter 14,NA,NA
Dictionaries,"lists and tuples are
  containers
  in which data are collected so that elements of the data can 
 be easily accessed. lists and tuples are also
  sequences
  in that data are organized in a well 
 defined sequential manner. One element follows another. The first element has an index of 
 0, the next has an index of 1, and so on. Alternatively, negative indexing can be used to 
 specify an offset from the last element of a list or tuple. We’ve discussed the use of slices 
 where a portion of a list or tuple is specified by indices that indicate the start and end of the 
 slice. Almost everything we have done in terms of accessing the elements of a list or tuple 
 has been related to the sequential nature of the container and has relied on numeric 
 indexing.
  
 However, as you know from your day-to-day experiences, there are many situations in 
 which we don’t think of collections of data in a sequential manner. For example, your name, 
 your height, and your age are all data associated with you, but you don’t think about these 
 in any particular order. Your name is simply your name. If we want to store a person’s 
 name, height, and age in a Python program, we can easily store this information in a list (if 
 we want the information to be mutable) or a tuple (if we want the information to be 
 immutable). If we do this, the order of an element dictates how it should be interpreted. So, 
 for example, perhaps the first element in a list is a name (a string), the second element is an 
 age (an integer), and the third element is a height (a float or integer in centimeters). Within 
 a program this organization of information can work well, but there are limits to this. What 
 if we want to keep track of many more facts about a person? Assume, perhaps, there are 15 
 separate pieces of data we want to record and use. The code to manipulate this information 
 can become difficult to understand and maintain if the programmer only has the position 
 within a list as the key to determining how the data should be interpreted.
  
 As an alternative to lists and tuples, Python provides another container known as a dic-
 tionary or dict. Dictionaries share some syntactic properties with lists and tuples but there 
 are many important differences. First, dictionaries are
  not
  sequential collections of data. 
 Instead, dictionaries consist of key-value pairs. To obtain a “value” (i.e., the data of 
 interest), you specify its associated key. In this way you can create a collection of data in 
 which perhaps the keys are the strings ’name’, ’age’, and ’height’. The order in which 
 Python stores the key-value pairs is not a concern. We merely need to know that when we 
 specify the key ’name’, Python will provide the associated name. When we specify the key 
 ’age’, Python will provide the associated age. And, when we specify the key ’height’, Python 
 will provide the associated height.
  
 From the file: dictionaries.tex",NA
14.1,NA,NA
Dictionary Basics,"To create a dict, we use curly braces, i.e., {}. If there is nothing between the braces (other 
 than whitespace), the dict is empty. It is not uncommon to start with an empty dictionary 
 and later add key-value pairs. Alternatively, key-value pairs can be specified when the 
 dictionary is created. This is done by separating the key from the value by a colon and 
 separating key-value pairs by a comma. This is illustrated in Listing 14.1 which is discussed 
 below the listing.
  
 Listing 14.1
  Creation of dictionaries.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13 
 14 
 15 
 16 
 17
  
  
 >>>
  abe = {
 ’name’
  :
  ’Abraham Lincoln’
 ,
  ’age’
  : 203,
  ’height’
  : 193} 
 >>>
  abe[
 ’height’
 ] 
  
 193  
 >>>
  abe[
 ’name’
 ]
  
 ’Abraham Lincoln’ 
 >>>
  james = {} 
  
 >>>
  james[’name’] 
  
 Traceback (most recent call last): 
 File ""<stdin>"", line 1, in <module> 
 KeyError: ’name’ 
 >>>
  james[
 ’name’
 ] =
  ’James Madison’
  
 >>>
  james[
 ’height’
 ] = 163 
  
 >>>
  james[
 ’age’
 ] = 261 
  
 >>>
  print
 (abe) 
  
 {’age’: 203, ’name’: ’Abraham Lincoln’, ’height’: 193} 
 >>>
  james 
  
 {’age’: 261, ’name’: ’James Madison’, ’height’: 163} 
  
 In line 1 the dictionary abe is created with three key-value pairs. The use of whitespace 
 surround-ing a colon is optional. Although not done here, the declaration can span multiple 
 lines because the opening brace behaves something like an opening parentheses and the 
 declaration does not end until the corresponding closing brace is entered. To obtain the 
 value associated with a key, the key is specified within square brackets as shown in lines 2 
 and 4.",NA
14.2,NA,NA
Cycling through a Dictionary,"Although a dict is not a sequence like a list or a tuple, it is an
  iterable
  and can be used in a 
 for-loop header. This is demonstrated in Listing 14.4 where the dictionary abe is created in 
 line 1 and then used as the iterable in the for-loop in line 2. Here we use foo for the loop 
 variable name to indicate that it is not obvious what value is assigned to this variable. The 
 body of the loop (line 3) simply prints the value of the loop variable. We see in the output in 
 lines 5 through 7 that the loop variable is assigned the values of the keys. By invoking the 
 keys() method on the dictionary abe, the for-loop defined in lines 8 and 9 explicitly says 
 that the iterable should be the keys of the dict. This loop is functionally identical to the loop 
 in lines 2 and 3. Since it is superfluous, typically one does not invoke the keys() method in 
 the header of a for-loop and instead writes the header as shown in line 2. (Another 
 common idiom is to name the loop variable key.)
  
 Listing 14.4
  When a dict is used as the iterable in a for-loop, the loop variable takes on the 
 values of keys.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10
  
  
 >>>
  abe = {
 ’name’
  :
  ’Abraham Lincoln’
 ,
  ’age’
  : 203,
  ’height’
  : 193} 
 >>>
  for
  foo
  in
  abe: 
  
 ... 
  
 print
 (foo) 
  
 ...
  
 age 
 name 
 height  
 >>>
  for
  foo
  in
  abe.keys(): 
  
 ... 
  
 print
 (foo) 
  
 ...",NA
14.3,NA,NA
get(),"The dictionary method get() provides another way to obtain the value associated with a 
 key. However, there are two important differences between the way get() behaves and the 
 way dic-tionaries behave when a key is specified within brackets. The first argument to 
 get() is the key. If the key does not exist within the dictionary, no error is produced. 
 Instead, get() returns None. This is demonstrated in Listing 14.9. In line 1 a dictionary is 
 created with keys ’age’and ’height’. The header of the for-loop in line 2 explicitly sets the 
 loop variable key to’name’, ’age’, and ’height’. In the body of the loop, in line 3, the get() 
 method is used to obtain the value associated with the given key. The output in line 5 
 shows that the method re-turns None for the key ’name’. The for-loop in lines 8 and 9 is 
 similar to the previous loop except here the values are obtained using james[key] rather 
 than james.get(key). This results in an error because the key ’name’ is not defined. This 
 error terminates the loop, i.e., we do not see the other values for which a key is defined.
  
 Listing 14.9
  The get() method can be used to look up values for a given key. If the key does 
 not exist, the method returns None.
  
 1 2 
 3 4 
 5 6 
 7 8 
 9 
 10 
 11 
 12 
 13
  
  
 >>>
  james = {
 ’age’
 : 261,
  ’height’
 : 163} 
  
 >>>
  for
  key
  in
  [
 ’name’
 ,
  ’age’
 ,
  ’height’
 ]: 
  
 ... 
  
 print
 (key,
  ’:\t’
 , james.get(key), sep=
 """"
 ) ...
  
 name:  
 None 
 age:  
 261 
 height: 163  
 >>>
  for
  key
  in
  [
 ’name’
 ,
  ’age’
 ,
  ’height’
 ]: ... 
  
 print(key, ’:\t’, 
 james[key], sep="""") 
 ...
  
 Traceback (most recent call last): 
 File ""<stdin>"", line 2, in <module> 
 KeyError: ’name’ 
  
 The other important difference between using get() and specifying a key within 
 brackets is that get() takes an optional second argument that specifies what should be 
 returned when a key does not exist. In this way we can obtain a value other than None for 
 undefined keys. Effectively",NA
14.4,NA,NA
Chapter Summary,"The value associated with a given key can be 
 ob-tained by giving the dictionary name 
 followed by the key enclosed in square 
 brackets. For ex-ample, for the dictionary d, 
 the value associated with the key k is given 
 by d[k]. It is an error to attempt to access a 
 non-existent key this way.
  
 Dictionaries consist of key-value pairs. Any 
 ob-ject consisting of immutable components 
 can be used as a key. Values may be any 
 object. 
 Dic-tionaries 
 themselves 
 are 
 mutable.
  
 Dictionaries are unordered collections of 
 data (i.e., they are not sequences).",NA
14.5,NA,NA
Review Questions,"1. What is the output produced by the following code?
  
 d = {
 ’a’
  : 0,
  ’b’
 : 1,
  ’c’
  : 2} 
  
 print
 (d[
 ’c’
 ])
  
 (a) c 
  
 (b) 2 
  
 (c) ’c’ : 2 
  
 (d) This code produces an 
 error.
  
 2. What is the output produced by the following code?
  
 d = {
 ’a’
  : 0,
  ’b’
 : 1,
  ’c’
  : 2} 
  
 print
 (d[2])
  
 (a) c 
  
 (b) 2 
  
 (c) ’c’ : 2 
  
 (d) This code produces an 
 error.
  
 3. What is the output produced by the following code?",NA
Appendix A ,NA,NA
ASCII Non-printable ,NA,NA
Characters,NA,NA
Index,"Symbols 
  
 != . . . . . . . . . . . . . . . . . . . . . . . . . .
  see
  not equal to 
 \
 . . . . . . . . . . . .
 see
  escaping or escape 
 sequences **. . . . . . . . . . . . . . . . . . . . . . .
  see
  
 exponentiation / . . . . . . . . . . . . . . . . . . . . . . .
  see
  
 division, float // . . . . . . . . . . . . . . . . . . . . . . . .
  see
  
 division, floor < . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 see
  less than <=. . . . . . . . . . . . . . . . . . .
 see
  less 
 than or equal to = . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 see
  assignment ==. . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
 see
  equal to > . . . . . . . . . . . . . . . . . . . . . . . . . . .
  see
  
 greater than >= . . . . . . . . . . . . . . . .
  see
  greater 
 than or equal to #. . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
 see
  comment % . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . .
  see
  modulo
  
 A 
  
 accumulator . . . . . . . . . . . . . . . . . . . . . . . . 129–
 130 alias . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158, 
 330 and . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273–
 275 application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 2f argument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5, 
 5f argument, complex number. . . . . . . . . . . . . . 
 .182 arithmetic operators . . . . . . . . . . . . . . . . . . . 
 22–24 ASCII. . . . . . . . . . . . . . . . . . . . . . . . .195, 
 199–200 assignment . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . 24–28 
  
 augmented. . . . . . . . . . . . . . . . . . . . 
 . . . .40–42 
  
 cascaded . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . 27 
  
 operator . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . 24 
  
 simultaneous. . . . . . . . . . . . . . . . . . 
 . . . .27–28 
  
  
 lists . . . . . . . . . . . . . . . . . . . . 
 . . . 126–127 attributes . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . 96
  
 B 
  
 base 
  
  
 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 
  
 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 
  
 10. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .19 
 binary operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 24",NA
