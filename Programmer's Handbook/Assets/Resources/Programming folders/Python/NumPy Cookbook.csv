Larger Text,Smaller Text,Symbol
Powerful Techniques for Perl and Other Tools,NA,NA
Mastering,NA,NA
Regular,NA,NA
Expressions,NA,NA
Jeffrey E. F. Friedl,NA,NA
Ta ble of Contents,"Preface
  .....................................................................................................................
  xv
  
 1: Introduction to Regular Expressions
  ......................................................
  1
  
 Solving Real Problems ........................................................................................ 2 Regular 
 Expressions as a Language ................................................................... 4 The Filename 
 Analogy ................................................................................. 4 The Language Analogy 
 ................................................................................ 5 The Regular-Expr ession Frame of 
 Mind ............................................................ 6 If You Have Some Regular-Expr ession 
 Experience ................................... 6 Searching Text Files: Egrep 
 ......................................................................... 6 Egr ep Metacharacters 
 .......................................................................................... 8 Start and End of the Line 
 ............................................................................. 8 Character Classes 
 .......................................................................................... 9 Matching Any Character with 
 Dot ............................................................. 11 Alter nation 
 .................................................................................................. 13 Ignoring Differ ences in 
 Capitalization ...................................................... 14 Word Boundaries 
 ........................................................................................ 15 In a Nutshell 
 ............................................................................................... 16 Optional Items 
 ............................................................................................ 17 Other Quantifiers: Repetition 
 .................................................................... 18 Par entheses and Backrefer ences 
 ............................................................... 20 The Great Escape 
 ....................................................................................... 22 Expanding the Foundation 
 ............................................................................... 23 Linguistic Diversification 
 ............................................................................ 23 The Goal of a Regular Expression 
 ............................................................ 23
  
 vii
  
 5 May 2003 08:41",NA
 LM,"For putting up with me.
  
 And for the years I worked on this book,
  
 for putting up without me.",NA
Preface,"This book is about a powerful tool called “regular expressions”. It teaches you how to use 
 regular expressions to solve problems and get the most out of tools and languages that 
 provide them. Most documentation that mentions regular expres-sions doesn’t even begin to 
 hint at their power, but this book is about
  mastering 
 regular expressions.
  
 Regular expressions are available in many types of tools (editors, word processors, system 
 tools, database engines, and such), but their power is most fully exposed when available as 
 part of a programming language. Examples include Java and JScript, Visual Basic and 
 VBScript, JavaScript and
  ECMAS
 cript, C, C
 ++
 , C#, elisp, Perl, Python, Tcl, Ruby,
  PHP
 , sed, 
 and awk. In fact, regular expressions are the very heart of many programs written in some of 
 these languages.
  
 Ther e’s a good reason that regular expressions are found in so many diverse lan-guages and 
 applications: they are extr emely power ful. At a low level, a regular expr ession describes a 
 chunk of text. You might use it to verify a user’s input, or perhaps to sift through large 
 amounts of data. On a higher level, regular expres-sions allow you to master your data. 
 Control it. Put it to work for you. To master regular expressions is to master your data.",NA
The Need for This Book,"I finished the first edition of this book in late 1996, and wrote it simply because ther e was a 
 need. Good documentation on regular expressions just wasn’t avail-able, so most of their 
 power went untapped. Regular-expr ession documentation was available, but it centered on 
 the “low-level view.” It seemed to me that they wer e analogous to showing someone the 
 alphabet and expecting them to learn to speak.
  
 xv
  
 27 April 2003 17:10",NA
Why I’ve Written the Second Edition,"In the five and a half years since the first edition of this book was published, the world of 
 regular expressions expanded considerably. The regular expressions of almost every tool and 
 language became more power ful and expressive. Perl, Python, Tcl, Java, and Visual Basic all 
 got new regular-expr ession backends. New languages with regular expression support, like 
 Ruby,
  PHP
 , and C#, were devel-oped and became popular. During all this time, the basic 
 core of the book
  —
  how to truly understand regular expressions and how to get the most 
 from them
  —
 remained as important and relevant as ever.
  
 Gradually, the first edition started to show its age. It needed updating to reflect the new 
 languages and features, as well as the expanding role that regular expressions play in today’s 
 Internet world. When I decided to update the first edition, it was with a promise to my wife 
 that it would take no more than three months. Two years later, luckily still married, almost 
 the entire book has been rewritten from scratch. It’s good, though, that it took so long, for it 
 brought me into 2002, a par-ticularly active year for regular expressions. In early 2002, both 
 Java 1.4 (with 
 java.util.regex
 ) and Microsoft’s .
 NET
  wer e released, and Perl 5.8 was released 
 that summer. They are all covered fully in this book.",NA
Intended Audience,"This book will interest anyone who has an opportunity to use regular expressions. If you 
 don’t yet understand the power that regular expressions can provide, you should benefit 
 greatly as a whole new world is opened up to you. This book should expand your 
 understanding, even if you consider yourself an accomplished regular-expr ession expert. 
 After the first edition, it wasn’t uncommon for me to receive an email that started “I
  thought
  I 
 knew regular expressions until I read 
 Mastering Regular Expressions
 .
  Now
  I do.”
  
 Pr ogrammers working on text-related tasks, such as web programming, will find an absolute 
 gold mine of detail, hints, tips, and
  understanding
  that can be put to immediate use. The detail 
 and thoroughness is simply not found anywhere else.
  
 Regular expressions are an idea
  —
 one that is implemented in various ways by vari-ous 
 utilities (many, many more than are specifically presented in this book). If you master the 
 general concept of regular expressions, it’s a short step to mastering a particular 
 implementation. This book concentrates on that idea, so most of the knowledge presented 
 here transcends the utilities and languages used to present the examples.
  
 27 April 2003 17:10",NA
How to Read This Book,"This book is part tutorial, part refer ence manual, and part story, depending on when you use 
 it. Readers familiar with regular expressions might feel that they can immediately begin using 
 this book as a detailed refer ence, flipping directly to the section on their favorite utility. I 
 would like to discourage that.
  
 To get the most out of this book, read the first six chapters as a story. I have found that 
 certain habits and ways of thinking can be a great help to reaching a full understanding, but 
 such things are absorbed over pages, not merely memorized fr om a list.
  
 This book tells a story, but one with many details. Once you’ve read the story to get the 
 overall picture, this book is also useful as a refer ence. The last three chap-ters (covering 
 specifics of Perl, Java, and .
 NET
 ) rely heavily on your having read the first six chapters. To 
 help you get the most from each part, I’ve used cross ref-er ences liberally, and I’ve worked 
 hard to make the index as useful as possible.
  
 (Cr oss refer ences ar e often presented as “” followed by a page number.)
  
 Until you read the full story, this book’s use as a refer ence makes little sense. Befor e 
 reading the story, you might look at one of the tables, such as the chart on page 91, and 
 think it presents all the relevant information you need to know. But a great deal of 
 background information does not appear in the charts themselves, but rather in the 
 associated story. Once you’ve read the story, you’ll have an appr eciation for the issues, what 
 you can remember off the top of your head, and what is important to check up on.",NA
Organization,"The nine chapters of this book can be logically divided into roughly three parts. Her e’s a 
 quick overview:
  
 The Introduction 
  
  
 Chapter 1 introduces the concept of regular expressions.
  
 Chapter 2 takes a look at text processing with regular expressions.
  
 Chapter 3 provides an overview of features and utilities, plus a bit of history.
  
 The Details 
  
  
 Chapter 4 explains the details of how regular expressions work.
  
 Chapter 5 works through examples, using the knowledge from Chapter 4. Chapter 6 
 discusses efficiency in detail.
  
 Tool-Specific Infor mation 
  
  
 Chapter 7 covers Perl regular expressions in detail.
  
 Chapter 8 looks at regular-expr ession packages for Java.
  
 Chapter 9 looks at .
 NET
 ’s language-neutral regular-expr ession package.
  
 27 April 2003 17:10",NA
The Introduction,"The introduction elevates the absolute novice to “issue-aware” novice. Readers with a fair 
 amount of experience can feel free to skim the early chapters, but I par-ticularly recommend 
 Chapter 3 even for the grizzled expert.
  
 •
  
 Chapter 1,
  Intr oduction to Regular Expressions
 , is gear ed toward the complete 
  
 novice. I 
 introduce the concept of regular expressions using the widely avail-
  
 able program
  egr 
 ep
 , and offer my perspective on how to
  think
  regular expres-
  
 sions, instilling a solid 
 foundation for the advanced concepts presented in later 
  
 chapters. Even readers with 
 former experience would do well to skim this first 
  
 chapter.
  
 •
  
 Chapter 2,
  Extended Introductory Examples
 , looks at real text processing in a 
  
 pr 
 ogramming language that has regular-expr ession support. The additional 
  
 examples provide 
 a basis for the detailed discussions of later chapters, and 
  
 show additional important 
 thought processes behind crafting advanced regular 
  
 expr essions. To provide a feel for 
 how to “speak in regular expressions,” this 
  
 chapter takes a problem requiring an advanced 
 solution and shows ways to 
  
 solve it using two unrelated regular-expr ession–
 wielding tools.
  
 •
  
 Chapter 3,
  Overview of Regular Expression Features and Flavors
 , provides an 
  
 overview 
 of the wide range of regular expressions commonly found in tools 
  
 today. Due to 
 their turbulent history, current commonly-used regular-expr es-
  
 sion flavors can differ 
 greatly. This chapter also takes a look at a bit of the his-
  
 tory and evolution of regular 
 expressions and the programs that use them. The 
  
 end of this chapter also contains the 
 “Guide to the Advanced Chapters.” This 
  
 guide is your road map to getting the most out 
 of the advanced material that 
  
 follows.",NA
The Details,"Once you have the basics down, it’s time to investigate the
  how
  and the
  why
 . Like the “teach a 
 man to fish” parable, truly understanding the issues will allow you to apply that knowledge 
 whenever and wherever regular expressions are found.
  
 •
  
 Chapter 4,
  The Mechanics of Expression Processing
 , ratchets up the pace sev-
  
 eral 
 notches and begins the central core of this book. It looks at the important 
  
 inner 
 workings of how regular expression engines really work from a
  practi-
  
 cal
  point of view. 
 Understanding the details of how regular expressions are 
  
 handled goes a very long 
 way toward allowing you to master them.
  
 •
  
 Chapter 5,
  Practical Regex Techniques
 , then puts that knowledge to high-level, 
  
 practical 
 use. Common (but complex) problems are explor ed in detail, all with 
  
 the aim of 
 expanding and deepening your regular-expr ession experience.
  
 27 April 2003 17:10",NA
Tool-Specific Infor mation,"Once the lessons of Chapters 4, 5, and 6 are under your belt, there is usually little to say 
 about specific implementations. However, I’ve devoted an entire chapter to each of three 
 popular systems:
  
 •
  
 Chapter 7,
  Perl
 , closely examines regular expressions in Perl, arguably the 
  
 most 
 popular regular-expr ession–laden pr ogramming language in use today. It 
  
 has only four 
 operators related to regular expressions, but their myriad of 
  
 options and special 
 situations provides an extremely rich set of programming 
  
 options
  —
  and pitfalls. The 
 very richness that allows the programmer to move 
  
 quickly from concept to program can 
 be a minefield for the uninitiated. This 
  
 detailed chapter clears a path.
  
 •
  
 Chapter 8,
  Java
 , surveys the landscape of regular-expr ession packages avail-
  
 able for 
 Java. Points of comparison are discussed, and two packages with 
  
 notable strengths 
 are cover ed in more detail.
  
 •
  
 Chapter 9,
  .
 NET
 , is the documentation for the .
 NET
  regular-expr ession library 
  
 that Microsoft neglected to provide. Whether using VB.NET, C#, C
 ++
 , JScript, 
  
 VBscript,
  ECMAS
 cript, or any of the other languages that use .
 NET
  components, 
  
 this chapter provides the details you need to employ .
 NET
  regular-expr essions 
  
 to the fullest.",NA
Typog raphical Conventions,"When doing (or talking about) detailed and complex text processing, being pre-cise is 
 important. The mere addition or subtraction of a space can make a world of dif ference, so 
 I’ve used the following special conventions in typesetting this book:
  
 •
  A regular expression generally appears like
  !this""
 . Notice the thin corners which flag “this 
 is a regular expression.” Literal text (such as that being searched) generally appears like 
 ‘
 this
 ’. At times, I’ll leave off the thin corners or quotes when obviously unambiguous. 
 Also, code snippets and screen shots ar e always presented in their natural state, so the 
 quotes and corners are not used in such cases.
  
 •
  I use visually distinct ellipses within literal text and regular expressions. For example
  [
 ˙˙˙
 ]
  
 repr esents a set of square brackets with unspecified contents, while
  [ . . . ]
  would be a set 
 containing three periods.
  
 27 April 2003 17:10",NA
2 ,NA,NA
1 ,NA,NA
|,"a space character 
  
 a tab character 
  
 a newline character 
  
 a carriage-r eturn character
  
 •
  At times, I use underlining or shade the background to highlight parts of literal text or a 
 regular expression. In this example the underline shows where in the text the expression 
 actually matches:
  
 Because
  !cat""
  matches ‘
 It indicates your cat is
 ˙˙˙
 ’ instead of the word ‘
 cat
 ’, we 
 realize . . .
  
 In this example the underlines highlight what has just been added to an expr ession 
 under discussion:
  
 To make this useful, we can wrap
  !Subject;Date""
  with parentheses, and append 
 a colon and a space. This yields
  !(Subject;Date): ""
 .
  
 •
  This book is full of details and examples, so to help you get the most out of it, I’ve 
 provided an extensive set of cross refer ences. They often appear in the text in a “123” 
 notation, which means “see page 123.” For example, it might appear like “ . . . is 
 described in Table 8-1 ( 373).”",NA
Exer cises,"Occasionally, and particularly in the early chapters, I’ll pose a question to highlight the 
 importance of the concept under discussion. They’re not there just to take up space; I really 
 do want you to try them before continuing. Please. So as not to dilute their importance, I’ve 
 sprinkled only a few throughout the entire book. They also serve as checkpoints: if they take 
 more than a few moments, it’s probably best to go over the relevant section again before 
 continuing on.
  
 To help entice you to actually think about these questions as you read them, I’ve made 
 checking the answers a breeze: just turn the page. Answers to questions marked with
  O
  ar e 
 always found by turning just one page. This way, they’re out of sight while you think about 
 the answer, but are within easy reach.
  
 27 April 2003 17:10",NA
"Links, Code, Errata, and Contacts","I lear ned the hard way with the first edition that
  URL
 s change more quickly than a printed 
 book can be updated, so rather than providing an appendix of
  URL
 s, I’ll pr ovide just one:
  
 http://regex.info/
  
 Ther e you can find regular-expr ession links, many of the code snippets from this book, a 
 searchable index, and much more. In the unlikely event this book con-tains an error
  :-)
 , the 
 errata will be available as well.
  
 If you find an error in this book, or just want to drop me a note, you can contact me at
  
 jfriedl@regex.info
 .
  
 The publisher can be contacted at:
  
 O’Reilly & Associates, Inc.
  
 1005 Gravenstein Highway North 
  
 Sebastopol, CA 95472 
  
 (800) 998-9938 (in the United States or Canada) 
  
 (707) 829-0515 (international/local) 
  
 (707) 829-0104 (fax)
  
 bookquestions@oreilly.com
  
 For more infor mation about books, conferences, Resource Centers, and the O’Reilly 
 Network, see the O’Reilly web site at:
  
 http://www.oreilly.com",NA
Personal Comments and ,NA,NA
Acknowledgments,"Writing the first edition of this book was a grueling task that took two and a half years and 
 the help of many people. After the toll it took on my health and sanity, I pr omised that I’d 
 never put myself through such an experience again.
  
 I’ve many people to thank for helping me break that promise. Foremost is my wife, Fumie. 
 If you find this book useful, thank her; without her support and understanding, I would have 
 never had the sanity to make it through what turned out to be almost a two year complete 
 rewrite.
  
 I also appreciate the support of Yahoo! Inc., where I have enjoyed slinging regular expr 
 essions for five years, and my manager Mike Bennett. His flexibility and understanding 
 allowed this project to happen.
  
 27 April 2003 17:10",NA
1,NA,NA
Introduction to ,NA,NA
Regular Expressions,"Her e’s the scenario: you’re given the job of checking the pages on a web server for doubled 
 words (such as “this this”), a common problem with documents sub-ject to heavy editing. 
 Your job is to create a solution that will:
  
 •
  Accept any number of files to check, report each line of each file that has doubled words, 
 highlight (using standard
  ANSI
  escape sequences) each dou-bled word, and ensure that 
 the source filename appears with each line in the report.
  
 •
  Work across lines, even finding situations where a word at the end of one line 
  
 is 
 repeated at the beginning of the next.
  
 •
  Find doubled words despite capitalization differ ences, such as with ‘
 The the
 ˙˙˙
 ’, as well as 
 allow differing amounts of
  whitespace
  (spaces, tabs, new-lines, and the like) to lie between 
 the words.
  
 •
  Find doubled words even when separated by
  HTML
  tags.
  HTML
  tags are for marking up 
 text on World Wide Web pages, for example, to make a word bold: ‘
 ˙˙˙
 it is <B>very</B> 
 very important
 ˙˙˙
 ’.
  
 That’s certainly a tall order! But, it’s a real problem that needs to be solved. At one point 
 while working on the manuscript for this book, I ran such a tool on what I’d written so far 
 and was surprised at the way numerous doubled words had crept in. Ther e ar e many 
 programming languages one could use to solve the problem, but one with regular expression 
 support can make the job substantially easier.
  
 Regular expressions
  ar e the key to powerful, flexible, and efficient text processing. Regular 
 expressions themselves, with a general pattern notation almost like a mini pr ogramming 
 language, allow you to describe and parse text. With additional sup-port provided by the 
 particular tool being used, regular expressions can add, remove, isolate, and generally fold, 
 spindle, and mutilate all kinds of text and data.
  
 1
  
 27 April 2003 17:11",NA
Solving Real Problems,"Knowing how to wield regular expressions unleashes processing powers you might not even 
 know were available. Numerous times in any given day, regular expr essions help me solve 
 problems both large and small (and quite often, ones that are small but would be large if not 
 for regular expressions).
  
 Showing an example that provides the key to solving a large and important prob-lem 
 illustrates the benefit of regular expressions clearly, but perhaps not so obvi-ous is the way 
 regular expressions can be used throughout the day to solve rather“uninter esting” pr 
 oblems. I use “uninteresting” in the sense that such problems are not often the subject of 
 bar-r oom war stories, but quite interesting in that until they’r e solved, you can’t get on with 
 your real work.
  
 As a simple example, I needed to check a lot of files (the 70 or so files comprising the source 
 for this book, actually) to confirm that each file contained ‘
 SetSize
 ’exactly as often (or as 
 rarely) as it contained ‘
 ResetSize
 ’. To complicate matters, I needed to disregard capitalization 
 (such that, for example, ‘
 setSIZE
 ’ would be counted just the same as ‘
 SetSize
 ’). Inspecting the 
 32,000 lines of text by hand certainly wasn’t practical.
  
 27 April 2003 17:11",NA
Regular Expressions as a Language,"Unless you’ve had some experience with regular expressions, you won’t under-stand the 
 regular expression
  !ˆ( From;Subject ):""
  fr om the last example, but ther e’s nothing magic 
 about it. For that matter, ther e is nothing magic about magic. The magician merely 
 understands something simple which doesn’t
  appear
  to be simple or natural to the untrained 
 audience. Once you learn how to hold a card while making your hand look empty, you only 
 need practice before you, too, can“do magic.” Like a foreign language
  —
  once you learn it, it 
 stops sounding like gibberish.",NA
The Filename Analogy,"Since you have decided to use this book, you probably have at least some idea of just what a 
 “regular expression” is. Even if you don’t, you are almost certainly alr eady familiar with the 
 basic concept.
  
 You know that
  report.txt
  is a specific filename, but if you have had any experience with Unix 
 or
  DOS
 /Windows, you also know that the pattern “
 +.txt
 ” can be used to select multiple files. 
 With filename patterns like this (called
  file globs
  or
  wild-car ds
 ), a few characters have special 
 meaning. The star means “match anything,”and a question mark means “match any one 
 character.” So, with the file glob“
 +.txt
 ”, we start with a match-anything
  !+""
  and end with the 
 literal
  ! .txt""
 , so we end up with a pattern that means “select the files whose names start with 
 anything and end with
  .txt
 ”.
  
 Most systems provide a few additional special characters, but, in general, these filename 
 patterns are limited in expressive power. This is not much of a shortcom-ing because the 
 scope of the problem (to provide convenient ways to specify gr oups of files) is limited, well, 
 simply to filenames.
  
 On the other hand, dealing with general text is a much larger problem. Prose and poetry, 
 program listings, reports,
  HTML
 , code tables, word lists... you name it, if a particular need is 
 specific enough, such as “selecting files,” you can develop some kind of specialized scheme 
 or tool to help you accomplish it. However, over the years, a
  generalized pattern language
  has 
 developed, which is powerful and expr essive for a wide variety of uses. Each program 
 implements and uses them dif ferently, but in general, this powerful pattern langua ge and 
 the patterns them-selves are called
  regular expressions
 .
  
 27 April 2003 17:11",NA
The Language Analog y,"Full regular expressions are composed of two types of characters. The special characters (like 
 the
  +
  fr om the filename analogy) are called
  metacharacters
 , while the rest are called
  literal
 , or 
 nor mal text characters. What sets regular expressions apart from filename patterns are the 
 advanced expressive powers that their meta-characters provide. Filename patterns provide 
 limited metacharacters for limited needs, but a regular expression “language” provides rich 
 and expressive metachar-acters for advanced uses.
  
 It might help to consider regular expressions as their own language, with literal text acting as 
 the words and metacharacters as the grammar. The words are com-bined with grammar 
 according to a set of rules to create an expression that com-municates an idea. In the email 
 example, the expression I used to find lines beginning with ‘
 From:
 ’ or ‘
 Subject:
 ’ was
  
 !ˆ(From;Subject):""
 . The metachar-acters are underlined; we’ll get to their interpretation soon.
  
 As with learning any other language, regular expressions might seem intimidating at first. 
 This is why it seems like magic to those with only a superficial understand-ing, and perhaps 
 completely unapproachable to those who have never seen it at all. But, just as
  
 abcdefghi
 !
 †
 would soon become clear to a student of Japanese, the regular expression in
  
 s!<emphasis>([0-9]+(\.[0-9]+){3})</emphasis>!<inet>$1</inet>!
  
 will soon become crystal clear to you, too.
  
 This example is from a Perl language script that my editor used to modify a manuscript. The 
 author had mistakenly used the typesetting tag
  <emphasis>
  to mark Internet
  IP
  addr esses 
 (which are sets of periods and numbers that look like 
 209.204.146.22
 ). The incantation uses 
 Perl’s text-substitution command with the regular expression
  
 !<emphasis>([0-9]+(\.[0-9]+){3})</emphasis>
  
 to replace such tags with the appropriate
  <inet>
  tag, while leaving other uses of 
 <emphasis>
  
 alone. In later chapters, you’ll learn all the details of exactly how this type of incantation is 
 constructed, so you’ll be able to apply the techniques to your own needs, with your own 
 application or programming language.
  
 † “Regular expressions are easy!” A somewhat humorous comment about this: as Chapter 3 explains, the term
  
 regular expression
  originally comes from formal algebra. When people ask me what my book is about, the answer 
 “regular expressions” draws a blank face if they are not already familiar with the concept. The Japanese word for 
 regular expression,
  abcd
 , means as little to the average Japanese as its English counterpart, but my reply in 
 Japanese usually draws a bit more than a blank star e. You see, the “regular” part is unfortunately pronounced 
 identically to a much more common word, a medical term for “repr oductive organs.” You can only imagine 
 what flashes through their minds until I explain!
  
 27 April 2003 17:11",NA
The Regular-Expression Frame of Mind,"As we’ll soon see, complete regular expressions are built up from small building-block units. 
 Each individual building block is quite simple, but since they can be combined in an infinite 
 number of ways, knowing how to combine them to achieve a particular goal takes some 
 experience. So, this chapter provides a quick overview of some regular-expr ession concepts. 
 It doesn’t go into much depth, but pr ovides a basis for the rest of this book to build on, and 
 sets the stage for impor-tant side issues that are best discussed before we delve too deeply 
 into the regular expr essions themselves.
  
 While some examples may seem silly (because some
  ar e
  silly), they repr esent the kind of 
 tasks that you will want to do
  —
  you just might not realize it yet. If each point doesn’t seem 
 to make sense, don’t worry too much. Just let the gist of the lessons sink in. That’s the goal 
 of this chapter.",NA
If You Have Some Regular-Expression Experience,"If you’re alr eady familiar with regular expressions, much of this overview will not be new, 
 but please be sure to at least glance over it anyway. Although you may be awar e of the basic 
 meaning of certain metacharacters, perhaps some of the ways of thinking about and looking 
 at regular expressions will be new.
  
 Just as there is a dif ference between playing a musical piece well and
  making music
 , ther e is a 
 differ ence between knowing about regular expressions and
  really understanding
  them. Some of 
 the lessons present the same information that you ar e alr eady familiar with, but in ways that 
 may be new and which are the first steps to
  really understanding
 .",NA
Sear ching Te xt Files: Egre p,"Finding text is one of the simplest uses of regular expressions
  —
  many text editors and word 
 processors allow you to search a document using a regular-expr ession patter n. Even 
 simpler is the utility
  egr ep
 . Give
  egr ep
  a regular expression and some files to search, and it 
 attempts to match the regular expression to each line of each file, displaying only those lines 
 in which a match is found.
  egr ep
  is freely available
  
 27 April 2003 17:11",NA
Eg rep Metacharacter s,"Let’s start to explore some of the
  egr ep
  metacharacters that supply its regular-expr ession 
 power. I’ll go over them quickly with a few examples, leaving the detailed examples and 
 descriptions for later chapters.
  
 Typographical Conventions 
  
 Befor e we begin, please make sure to review the 
 typographical conventions explained in the preface, on page
  xix
 . This book forges a bit of 
 new ground in the area of typesetting, so some of my notations may be unfamiliar at first.",NA
Star t and End of the Line,"Pr obably the easiest metacharacters to understand are
  !ˆ""
  (
 car et
 ) and
  !$""
  (
 dollar
 ), which repr 
 esent the start and end, respectively, of the line of text as it is being checked. As we’ve seen, 
 the regular expression
  !cat""
  finds
  c
  
  a
  
  t
  anywher e on the line, but
  !ˆcat""
  matches only if 
 the
  c
  
  a
  
  t
  is at the beginning of the line
  —
  the
  !ˆ""
  is used to effectively
  anchor
  the match 
 (of the rest of the regular expression) to the start of the line. Similarly,
  !cat$""
  finds
  c
  
  a
  
  t
  
 only at the end of the line, such as a line ending with
  scat
 .
  
 It’s best to get into the habit of interpreting regular expressions in a rather literal way. For 
 example, don’t think 
  
  
  
 !ˆcat""
  matches a line with
  cat
  at the beginning 
  
 but rather: 
  
  
  
 !ˆcat""
  matches if you have the beginning of a line, followed immediately 
  
 by
  c
 , 
 followed immediately by
  a
 , followed immediately by
  t
 .
  
 They both end up meaning the same thing, but reading it the more literal way allows you to 
 intrinsically understand a new expression when you see it. How would
  egr ep
  interpr et
  !ˆcat$""
 ,
  
 !ˆ$""
 , or even simply
  !ˆ""
  alone?
  O
  Turn the page to check your interpretations.
  
 The caret and dollar are special in that they match a
  position
  in the line rather than any actual 
 text characters themselves. Of course, there are various ways to actually match real text. 
 Besides providing literal characters like
  !cat""
  in your regular expr ession, you can also use 
 some of the items discussed in the next few sections.
  
 27 April 2003 17:11",NA
Character Classes,"Matching any one of several character s
  
 Let’s say you want to search for “grey,” but also want to find it if it were spelled“gray.” The 
 regular-expr ession construct
  ![
 ˙˙˙
 ]""
 , usually called a
  character class
 , lets you list the characters 
 you want to allow at that point in the match. While
  !e 
 matches just an
  e
 , and
  !a""
  matches just 
 an
  a
 , the regular expression
  ![ea]""
  matches either. So, then, consider
  !gr[ea]y""
 : this means to 
 find “
  g
 , followed by
  r
 , followed by either an
  e
  or an
  a
 , all followed by
  y
  .” Because I’m a 
 really poor speller, I’m always using regular expressions like this against a huge list of English 
 words to figur e out proper spellings. One I use often is
  !sep[ea]r[ea]te""
 , because I can never 
 remember whether the word is spelled “seperate,” “separate,” “separ ete,” or what. The one 
 that pops up in the list is the proper spelling; regular expressions to the rescue.
  
 Notice how outside of a class, literal characters (like the
  !g""
  and
  !r""
  of
  !gr[ae]y""
  ) have an 
 implied “and then” between them
  —
  “match
  !g""
  and then match
  !r""
  . . .” It’s completely 
 opposite inside a character class. The contents of a class is a list of characters that can match 
 at that point, so the implication is “or.”
  
 As another example, maybe you want to allow capitalization of a word’s first letter, such as 
 with
  ![Ss]mith""
 . Remember that this still matches lines that contain
  smith 
 (or
  Smith
 ) 
 embedded within another word, such as with
  blacksmith
 . I don’t want to harp on this 
 throughout the overview, but this issue does seem to be the source of problems among 
 some new users. I’ll touch on some ways to handle this embedded-word problem after we 
 examine a few more metacharacters.
  
 You can list in the class as many characters as you like. For example,
  ![123456] 
 matches any 
 of the listed digits. This particular class might be useful as part of 
 !<H[123456]>""
 , which 
 matches
  <H1>
 ,
  <H2>
 ,
  <H3>
 , etc. This can be useful when searching for
  HTML
  headers.
  
 Within a character class, the
  character-class metacharacter
  ‘
 -
 ’ (
 dash
 ) indicates a range of characters:
  
 !<H[1-6]>""
  is identical to the previous example.
  ![0-9]""
  and 
 ![a-z]""
  ar e common shorthands 
 for classes to match digits and English lowercase letters, respectively. Multiple ranges are 
 fine, so
  ![0123456789abcdefABCDEF]""
  can be written as
  ![0-9a-fA-F]""
  (or, perhaps,
  ![A-Fa-f0-
 9]""
 , since the order in which ranges are given doesn’t matter). These last three examples can 
 be useful when pr ocessing hexadecimal numbers. You can freely combine ranges with literal 
 char-acters:
  ![0-9A-ZR!.?]""
  matches a digit, uppercase letter, underscor e, exclamation point, 
 period, or a question mark.
  
 Note that a dash is a metacharacter only within a character class
  —
  otherwise it matches the 
 normal dash character. In fact, it is not even always a metacharacter within a character class. 
 If it is the first character listed in the class, it can’t possibly
  
 27 April 2003 17:11",NA
Reading,NA,NA
 !,NA,NA
ˆcat$,NA,NA
"""",NA,NA
" ,",NA,NA
 !,NA,NA
ˆ$,NA,NA
"""",NA,NA
" , and",NA,NA
 !,NA,NA
ˆ,"O
 Answers to the questions on page 8.
  
 !ˆcat$""
  Literally means: matches if the line has a beginning-of-line (which, of course, all 
 lines have), followed immediately by
  c
  
  a
  
  t
 , and then fol-lowed 
 immediately by the end of the line.
  
 Ef fectively means: a line that consists of only
  cat
  — no extra words, spaces, 
 punctuation... just ‘
 cat
 ’.
  
 !ˆ$ 
 Literally means: matches if the line has a beginning-of-line, followed immediately 
 by the end of the line.
  
 Ef fectively means: an empty line (with nothing in it, not even 
 spaces).
  
 !ˆ
 Literally means: matches if the line has a beginning-of-line.
  
 Ef fectively
  meaningless
  ! Since every line has a beginning, every line will 
 match
 —
 even lines that are empty!
  
 indicate a range, so it is not considered a metacharacter. Along the same lines, the question 
 mark and period at the end of the class are usually regular-expr ession metacharacters, but 
 only when
  not
  within a class (so, to be clear, the only special characters within the class in
  ![0-
 9A-ZR!.?]""
  ar e the two dashes).
  
 Consider character classes as their own mini language. The rules regard-ing which 
 metacharacters are supported (and what they do) are com-pletely differ ent inside 
 and outside of character classes.
  
 We’ll see more examples of this shortly.
  
 Negated character classes
  
 If you use
  ![ˆ
 ˙˙˙
 ]""
  instead of
  ![
 ˙˙˙
 ]""
 , the class matches any character that
  isn’t
  listed. For example,
  
 ![ˆ1-6]""
  matches a character that’s
  not
  1
  thr ough
  6
 . The leading
  ˆ
  in the class “negates” the 
 list, so rather than listing the characters you want to include in the class, you list the 
 characters you don’t want to be included.
  
 You might have noticed that the
  ˆ
  used here is the same as the start-of-line caret intr oduced 
 on page 8. The character is the same, but the meaning is completely dif ferent. Just as the 
 English word “wind” can mean differ ent things depending on the context (sometimes a 
 strong breeze, sometimes what you do to a clock), so can a metacharacter. We’ve already 
 seen one example, the range-building dash. It is valid only inside a character class (and at 
 that, only when not first inside the class).
  ˆ
  is a line anchor outside a class, but a class 
 metacharacter inside a class (but, only when it is immediately after the class’s opening 
 bracket; otherwise, it’s
  
 27 April 2003 17:11",NA
Matching Any Character with Dot,"The metacharacter
  ! .""
  (usually called
  dot
  or
  point
 ) is a shorthand for a character class that 
 matches any character. It can be convenient when you want to have an“any character here” 
 placeholder in your expression. For example, if you want to search for a date such as
  
 03/19/76
 ,
  03-19-76
 , or even
  03.19.76
 , you could go to the trouble to construct a regular 
 expression that uses character classes to explicitly allow ‘
 /
 ’, ‘
 -
 ’, or ‘
 .
 ’ between each number, 
 such as
  !03[-./]19[-./]76""
 . However, you might also try simply using
  !03.19.76""
 .
  
 Quite a few things are going on with this example that might be unclear at first. In 
 !03[-
 ./]19[-./]76""
 , the dots are
  not
  metacharacters because they are within a character class. 
 (Remember, the list of metacharacters and their meanings are dif-fer ent inside and outside 
 of character classes.) The dashes are also not class meta-characters
  in this case
  because each is 
 the first thing after
  [
  or
  [ˆ
 . Had they not been first, as with
  ![.-/]""
 , they would be the class 
 range metacharacter, which would be a mistake in this situation.
  
 27 April 2003 17:11",NA
Quiz Answer,"O
 Answer to the question on page 11.
  
 Why doesn’t
  !
 q[ˆu]
 ""
  match ‘Qantas’ or ‘Iraq’?
  
 Qantas
  didn’t match because the regular expression called for a lowercase
  q
 , wher eas 
 the
  Q
  in Qantas is uppercase. Had we used
  !Q[ˆu]""
  instead, we would have found it, but 
 not the others, since they don’t have an uppercase 
 Q
 . The expression
  ![Qq][ˆu]""
  would 
 have found them all.
  
 The
  Iraq
  example is somewhat of a trick question. The regular expression calls for
  q
  
 followed by a character
  that’s not
  u
 , which precludes matching
  q 
 at the end of the line
 . Lines 
 generally have newline characters at the very end, but a little fact I neglected to 
 mention
  (sorry!)
  is that
  egr ep
  strips those befor e checking with the regular expression, 
 so after a line-ending
  q
 , ther e’s no non-
 u
  to be matched.
  
 Don’t feel too bad because of the trick question.
 †
 Let me assure you that had 
 egr ep
  not 
 automatically stripped the newlines (many other tools don’t strip them), or had
  Iraq
  
 been followed by spaces or other words or whatnot, the line would have matched. It is 
 important to eventually understand the little details of each tool, but at this point what 
 I’d like you to come away with fr om this exercise is that
  a character class, even negated, still 
 requir es a char-acter to match.
  
 With
  !03.19.76""
 , the dots
  ar e
  metacharacters
  —
  ones that match any character (including the 
 dash, period, and slash that we are expecting). However, it is important to know that each 
 dot can match any character at all, so it can match, say, ‘
 lottery numbers: 19 203319 7639
 ’.
  
 So,
  !03[-./]19[-./]76""
  is more precise, but it’s more dif ficult to read and write. 
 !03.19.76""
  is 
 easy to understand, but vague. Which should we use? It all depends upon what you know 
 about the data being searched, and just how specific you feel you need to be. One important, 
 recurring issue has to do with balancing your knowledge of the text being searched against 
 the need to always be exact when writing an expression. For example, if you know that with 
 your data it would be highly unlikely for
  !03.19.76""
  to match in an unwanted place, it would 
 certainly be reasonable to use it. Knowing the target text well is an important part of wield-
 ing regular expressions effectively.
  
 † Once, in fourth grade, I was leading the spelling bee when I was asked to spell “miss.” My answer was “
 m
  
  i
  
  
 s
  
  s
 .” Miss Smith relished in telling me that no, it was “
 M
  
  i
  
  s
  
  s
 ” with a capital
  M
 , that I should have asked 
 for an example sentence, and that I was out. It was a traumatic moment in a young boy’s life. After that, I never 
 liked Miss Smith, and have since been a very poor speler.
  
 27 April 2003 17:11",NA
Alter nation,"Matching any one of several subexpressions
  
 A very convenient metacharacter is
  !;""
 , which means “or.” It allows you to combine multiple 
 expressions into a single expression that matches any of the individual ones. For example,
  
 !Bob""
  and
  !Robert""
  ar e separate expressions, but
  !Bob;Robert""
  is one expression that 
 matches either. When combined this way, the subexpressions ar e called
  alter natives
 .
  
 Looking back to our
  !gr[ea]y""
  example, it is interesting to realize that it can be written as
  
 !grey;gray""
 , and even
  !gr(a;e)y""
 . The latter case uses parentheses to constrain the alternation. 
 (For the record, parentheses are metacharacters too.) Note that something like
  !gr[a;e]y""
  is
  
 not
  what we want
  —
  within a class, the ‘
 ;
 ’character is just a normal character, like
  !a""
  and
  !e""
 .
  
 With
  !gr(a;e)y""
 , the parentheses are requir ed because without them,
  !gra;ey 
 means “
  !gra""
  or
  
 !ey""
  ,” which is not what we want here. Alternation reaches far, but not beyond parentheses. 
 Another example is
  !(First;1st) [Ss]treet""
 .
 †
 Actually, since both
  !First""
  and
  !1st""
  end with
  !st""
 , 
 the combination can be shortened to 
 !(Fir;1)st [Ss]treet""
 . That’s not necessarily quite as easy 
 to read, but be sure to understand that
  !(first;1st)""
  and
  !(fir;1)st""
  ef fectively mean the same 
 thing.
  
 Her e’s an example involving an alternate spelling of my name. Compare and con-trast the 
 following three expressions, which are all effectively the same:
  
 !Jeffrey;Jeffery 
  
 !Jeff(rey;ery) 
  
 !Jeff(re;er)y
  
 To have them match the British spellings as well, they could be:
  
 !(Geoff;Jeff)(rey;ery) 
  
 !(Geo;Je)ff(rey;ery) 
  
 !(Geo;Je)ff(re;er)y
  
 Finally, note that these three match effectively the same as the longer (but simpler) 
 !Jeffrey;Geoffery;Jeffery;Geoffrey""
 . They’r e all differ ent ways to specify the same desired 
 matches.
  
 Although the
  !gr[ea]y""
  versus
  !gr(a;e)y""
  examples might blur the distinction, be car eful not 
 to confuse the concept of alternation with that of a character class. A character class can 
 match just a
  single character
  in the target text. With alternation, since each alternative can be a 
 full-fledged regular expression in and of itself, each
  
 † Recall from the typographical conventions on page
  xx
  that “ ” is how I sometimes show a space 
  
 character 
 so it can be seen easily.
  
 27 April 2003 17:11",NA
Ignor ing Differences in Capitalization,"This email header example provides a good opportunity to introduce the concept of a
  case-
 insensitive
  match. The field types in an email header usually appear with leading capitalization, 
 such as “Subject” and “From,” but the email standard actually allows mixed capitalization, so 
 things like “DATE” and “from” are also allowed. Unfortunately, the regular expression in 
 the previous section doesn’t match those.
  
 One approach is to replace
  !From""
  with
  ![Ff][Rr][Oo][Mm]""
  to match any form of“fr om,” 
 but this is quite cumbersome, to say the least. Fortunately, there is a way to tell
  egr ep
  to 
 ignore case when doing comparisons, i.e., to perfor m the match in a 
 case insensitive
  manner in 
 which capitalization differ ences ar e simply ignored. It is
  
 27 April 2003 17:11",NA
Word Boundar ies,"A common problem is that a regular expression that matches the word you want can often 
 also match where the “word” is embedded within a larger word. I men-tioned this briefly in 
 the
  cat
 ,
  gray
 , and
  Smith
  examples. It turns out, though, that some versions of
  egr ep
  of fer 
 limited support for word recognition: namely the abil-ity to match the boundary of a word 
 (where a word begins or ends).
  
 You can use the (perhaps odd looking)
  metasequences
  !\<""
  and
  !\>""
  if your version happens to 
 support them (not all versions of
  egr ep
  do). You can think of them as word-based versions 
 of
  !ˆ""
  and
  !$""
  that match the
  position
  at the start and end of a word, respectively. Like the line 
 anchors caret and dollar, they anchor other parts of the regular expression but don’t actually 
 consume any characters during a match. The expression
  !\<cat\>""
  literally means “ match if 
 we can find a start-of-word position, followed immediately by
  c
  
  a
  
  t
 , followed 
 immediately by an end-of-word position .” Mor e naturally, it means “find the word
  cat
 .” If 
 you wanted, you could use
  !\<cat""
  or
  !cat\>""
  to find words starting and ending with
  cat
 .
  
 Note that
  !<""
  and
  !>""
  alone are not metacharacters
  —
  when combined with a back-slash, the
  
 sequences
  become special. This is why I called them “metasequences.”It’s their special 
 interpretation that’s important, not the number of characters, so for the most part I use 
 these two meta-words interchangeably.
  
 Remember, not all versions of
  egr ep
  support these word-boundary metacharacters, and those 
 that do don’t magically understand the English language. The “start of a word” is simply the 
 position where a sequence of alphanumeric characters begins;“end of word” is where such a 
 sequence ends. Figure 1-2 on the next page shows a sample line with these positions marked.
  
 The word-starts (as
  egr ep
  recognizes them) are marked with up arrows, the word-ends with 
 down arrows. As you can see, “start and end of word” is better phrased as “start and end of 
 an alphanumeric sequence,” but perhaps that’s too much of a mouthful.
  
 27 April 2003 17:11",NA
In a Nutshell,"Table 1-1 summarizes the metacharacters we have seen so far.
  
 Table 1-1: Summary of Metacharacters Seen So Far
  
 Metacharacter 
  
 Name
  
 Matches
  
 .
  
 [
 ˙˙˙
 ] 
  
 [ˆ
 ˙˙˙
 ]
  
 dot 
  
 character class 
  
 negated character class
  
 any one character 
  
 any character listed 
  
 any character not listed
  
 ˆ
  
 $ 
  
 \< 
  
 \>
  
 car et 
  
 dollar 
  
 backslash less-than 
  
 backslash greater-than
  
 the position at the start of the line 
  
 the position at the end of the line
  
 †
 the position at the start of a word
  
 †
 the position at the end of a word
  
  
 †
 not supported by all versions of egrep
  
 ; 
  
 (
 ˙˙˙
 )
  
 or
 ;
  bar 
  
 par entheses
  
 matches either expression it separates 
  
 used to limit scope of
  !;""
 , plus additional uses yet 
 to be discussed
  
 In addition to the table, important points to remember include:
  
 •
  The rules about which characters are and aren’t metacharacters (and exactly what they 
 mean) are dif ferent inside a character class. For example, dot is a metacharacter outside 
 of a class, but not within one. Conversely, a dash is a metacharacter within a class 
 (usually), but not outside. Moreover, a car et has one meaning outside, another if 
 specified inside a class immediately after the opening
  [
 , and a third if given elsewhere in 
 the class.
  
 •
  Don’t confuse alternation with a character class. The class
  ![abc]""
  and the alter-nation
  
 !(a;b;c)""
  ef fectively mean the same thing, but the similarity in this example does not 
 extend to the general case. A character class can match exactly one character, and that’s 
 true no matter how long or short the speci-fied list of acceptable characters might be.
  
 27 April 2003 17:11",NA
Optional Items,"Let’s look at matching
  color
  or
  colour
 . Since they are the same except that one has a
  u
  and 
 the other doesn’t, we can use
  !colo
 u?
 r""
  to match either. The metachar-acter
  !?""
  (
 question mark
 ) 
 means
  optional
 . It is placed after the character that is allowed to appear at that point in the 
 expression, but whose existence isn’t actu-ally requir ed to still be considered a successful 
 match.
  
 Unlike other metacharacters we have seen so far, the question mark attaches only to the 
 immediately-preceding item. Thus,
  !colou?r""
  is interpreted as “
  !c""
  then
  !o 
 then
  !l""
  then
  !o""
  
 then
  !u?""
  then
  !r""
 . ”
  
 The
  !u?""
  part is always successful: sometimes it matches a
  u
  in the text, while other times it 
 doesn’t. The whole point of the
  ?
 -optional part is that it’s successful either way. This isn’t to 
 say that any regular expression that contains
  ?
  is always success-ful. For example, against 
 ‘
 semicolon
 ’, both
  !colo""
  and
  !u?""
  ar e successful (matching 
 colo
  and nothing, respectively). 
 However, the final
  !r""
  fails, and that’s what dis-allows
  semicolon
 , in the end, from being 
 matched by
  !colou?r""
 .
  
 As another example, consider matching a date that repr esents July fourth, with the“July” 
 part being either
  July
  or
  Jul
 , and the “fourth” part being
  fourth
 ,
  4th
 , or simply
  4
 . Of course, 
 we could just use
  !(July;Jul) (fourth;4th;4)""
 , but let’s explor e other ways to express the same 
 thing.
  
 First, we can shorten the
  !(July;Jul)""
  to
  !(Jul
 y?
 )""
 . Do you see how they are effec-tively the 
 same? The removal of the
  !;""
  means that the parentheses are no longer really needed. 
 Leaving the parentheses doesn’t hurt, but with them removed, 
 !July?""
  is a bit less cluttered. 
 This leaves us with
  !July? (fourth;4th;4)""
 .
  
 † Recall from the typographical conventions (page
  xx
 ) that something like “ 15” is a shorthand for a 
  
 refer ence 
 to another page of this book.
  
 27 April 2003 17:11",NA
Other Quantifier s: Repetition,"Similar to the question mark are
  !+""
  (
 plus
 ) and
  !+""
  (an asterisk, but as a regular-expr ession 
 metacharacter, I prefer the term
  star
 ). The metacharacter
  !+""
  means “one or more of the 
 immediately-preceding item,” and
  !+""
  means “any number, including none, of the item.” 
 Phrased differ ently,
  !
  ˙˙˙
 +""
  means “try to match it as many times as possible, but it’s okay to 
 settle for nothing if need be.” The construct with plus, 
 !
  ˙˙˙
 +""
 , is similar in that it also tries to 
 match as many times as possible, but differ ent in that it fails if it can’t match at least once. 
 These three metacharacters, question mark, plus, and star, are called
  quantifiers
  because they 
 influence the quantity of what they govern.
  
 Like
  !
  ˙˙˙
 ?""
 , the
  !
  ˙˙˙
 +""
  part of a regular expression always succeeds, with the only issue being 
 what text (if any) is matched. Contrast this to
  !
  ˙˙˙
 +""
 , which fails unless the item matches at 
 least once.
  
 For example,
  ! ?""
  allows a single optional space, but
  ! +""
  allows
  any number
  of optional spaces. 
 We can use this to make page 9’s
  <H[1-6]>
  example flexible. The 
 HTML
  specification
 †
 says 
 that spaces are allowed immediately before the closing
  >
 ,
  
 such as with
  <H3 >
  and
  <H4
  
 >
 . Inserting
  ! +""
  into our regular expression where
  
 we want to allow (but not requir e) spaces, we get
  !<H[1-6] +>""
 . This still matches 
 <H1>
 , as 
 no spaces are requir ed, but it also flexibly picks up the other versions.
  
 † If you are not familiar with
  HTML
 , never fear. I use these as real-world examples, but I provide all the details 
 needed to understand the points being made. Those familiar with parsing
  HTML
  tags will likely recognize 
 important considerations I don’t address at this point in the book.
  
 27 April 2003 17:11",NA
Making a Subexpression Optional,"O
 Answer to the question on page 19.
  
 In this case, “optional” means that it is allowed once, but is not requir ed. That means 
 using
  !?""
 . Since the thing that’s optional is larger than one charac-ter, we must use 
 parentheses:
  !(
 ˙˙˙
 )?""
 . Inserting into our expression, we get:
  
 !<HR( +SIZE += +[0-9]+)? +>
  
 Note that the ending
  ! +""
  is kept outside of the
  !(
 ˙˙˙
 )?""
 . This still allows some-thing such 
 as
  <HR >
 . Had we included it within the parentheses, ending spaces would have been 
 allowed only when the size component was pr esent.
  
 Similarly, notice that the
  ! +""
  befor e
  SIZE
  is
  included within the parentheses. Were it 
 left outside them, a space would have been requir ed after the
  HR
 , even when the
  SIZE
  
 part wasn’t there. This would cause ‘
 <HR>
 ’ to not match.
  
 Table 1-2: Summary of Quantifier “Repetition Metacharacters”
  
  
 Minimum 
 Required 
  
 Maximum 
 to Tr y
  
 Meaning
  
 ? 
  
 + 
  
 +
  
 none 
  
 none 
  
 1
  
 1 
  
 no limit no 
 limit 
  
 one allowed; none requir ed (“
 one optional
  ”) 
  
 unlimited allowed; none requir ed (“
 any amount okay
  ”) unlimited 
 allowed; one requir ed (“
 at least one
  ”)
  
 Defined range of matches: intervals
  
 Some versions of
  egr ep
  support a metasequence for providing your own minimum and 
 maximum:
  !
  ˙˙˙
 {
 min
 ,
 max
 }""
 . This is called the
  interval
  quantifier. For example, 
 !
  ˙˙˙
 {3,12}""
  matches up 
 to 12 times if possible, but settles for three. One might use 
 ![a-zA-Z]{1,5}""
  to match a US 
 stock ticker (from one to five letters). Using this notation,
  {0,1}
  is the same as a question 
 mark.
  
 Not many versions of
  egr ep
  support this notation yet, but many other tools do, so it’s 
 covered in Chapter 3 when we look in detail at the broad spectrum of meta-characters in 
 common use today.",NA
Parentheses and Backreferences,"So far, we have seen two uses for parentheses: to limit the scope of alternation,
  !;""
 , and to 
 group multiple characters into larger units to which you can apply quanti-fiers like question 
 mark and star. I’d like to discuss another specialized use that’s not common in
  egr ep
  
 (although
  GNU
 ’s popular version does support it), but which is commonly found in many 
 other tools.
  
 27 April 2003 17:11",NA
The Great Escape,"One important thing I haven’t mentioned yet is how to actually match a character that a 
 regular expression would normally interpret as a metacharacter. For exam-ple, if I searched 
 for the Internet hostname
  ega.att.com
  using
  !ega.att.com""
 , it
  
 could end up matching something like
  megawatt computing
 . Remember,
  ! .""
  is a
  
 metacharacter that matches any character, including a space.
  
 The metasequence to match an actual period is a period preceded by a backslash: 
 !ega
 \.
 att
 \.
 com""
 . The sequence
  !\.""
  is described as an
  escaped period
  or
  escaped dot,
  and you can 
 do this with all the normal metacharacters, except in a character-class.
 †
  
 A backslash used in this way is called an “escape”
  —
  when a metacharacter is escaped, it 
 loses its special meaning and becomes a literal character. If you like, you can consider the 
 sequence to be a special metasequence to match the literal character. It’s all the same.
  
 As another example, you could use
  !
 \(
 [a-zA-Z]+
 \)
 ""
  to match a word within par entheses, 
 such as ‘
 (very)
 ’. The backslashes in the
  !\(""
  and
  !\)""
  sequences remove the special 
 interpretation of the parentheses, leaving them as literals to match parentheses in the text.
  
 When used before a non-metacharacter, a backslash can have differ ent meanings depending 
 upon the version of the program. For example, we have already seen how some versions 
 treat
  !\<""
 ,
  !\>""
 ,
  !\1""
 , etc. as metasequences. We will see many mor e examples in later 
 chapters.
  
 † Most programming languages and tools allow you to escape characters within a character class as well, but most 
 versions of
  egr ep
  do not, instead treating ‘
 \
 ’ within a class as a literal backslash to be included in the list of 
 characters.
  
 27 April 2003 17:11",NA
Expanding the Foundation,"I hope the examples and explanations so far have helped to establish the basis for a solid 
 understanding of regular expressions, but please realize that what I’ve pro-vided so far lacks 
 depth. There’s so much more out there.",NA
Linguistic Diver sification,"I mentioned a number of regular expression features that most versions of
  egr ep 
 support. 
 There are other features, some of which are not supported by all ver-sions, which I’ll leave 
 for later chapters.
  
 Unfortunately, the regular expression language is no differ ent fr om any other in that it has 
 various dialects and accents. It seems each new program employing reg-ular expressions 
 devises its own “improvements.” The state of the art continually moves forward, but 
 changes over the years have resulted in a wide variety of reg-ular expression “flavors.” We’ll 
 see many examples in the following chapters.",NA
The Goal of a Regular Expression,"Fr om the broadest top-down view, a regular expression either matches within a lump of text 
 (with
  egr ep
 , each line) or it doesn’t. When crafting a regular expres-sion, you must consider 
 the ongoing tug-of-war between having your expression match the lines you want, yet still 
 not matching lines you don’t want.
  
 Also, while
  egr ep
  doesn’t care wher e in the line the match occurs, this concern is important 
 for many other regular-expr ession uses. If your text is something such as
  
 ...
 zip is 44272. If you write, send $4.95 to cover postage and
 ...
  
 and you merely want to find lines matching
  ![0-9]+""
 , you don’t care which num-bers are 
 matched. However, if your intent is to
  do something
  with the number (such as save to a file, 
 add, replace, and such
  —
  we will see examples of this kind of processing in the next 
 chapter), you’ll care very much exactly
  which
  numbers ar e matched.",NA
A Few More Examples,"As with any language, experience is
  a very good thing
 , so I’m including a few mor e examples of 
 regular expressions to match some common constructs.
  
 Half the battle when writing regular expressions is getting successful matches when and 
 where you want them. The other half is to
  not
  match when and where you don’t want. In 
 practice, both are important, but for the moment, I would like to concentrate on the “getting 
 successful matches” aspect. Even though I don’t take these examples to their fullest depths, 
 they still provide useful insight.
  
 27 April 2003 17:11",NA
Regular Expression Nomenclature,"Regex
  
 As you might guess, using the full phrase “regular expression” can get a bit tiring, particularly 
 in writing. Instead, I normally use “regex.” It just rolls right off the tongue (it rhymes with 
 “FedEx,” with a hard
  g
  sound like “regular” and not a soft one like in “Regina”) and it is 
 amenable to a variety of uses like “when you regex...,” “budding regexers,” and even 
 “regexification.”
 †
 I use the phrase “regex engine” to refer to the part of a program that 
 actually does the work of carrying out a match attempt.
  
 Matching
  
 When I say a regex “matches” a string, I really mean that it matches
  in
  a string. Technically, 
 the regex
  !a""
  doesn’t
  match
  cat
 , but matches the
  a
  in
  cat
 . It’s not
  
 something that people tend to confuse, but it’s still worthy of mention.
  
 Metacharacter
  
 Whether a character is a metacharacter (or “metasequence”
  —
 I use the words inter-
 changeably) depends on exactly where in the regex it’s used. For example,
  !+""
  is a 
 metacharacter, but only when it’s not within a character class and when not escaped. 
 “Escaped” means that it has a backslash in front of it
  —
 usually. The star is escaped in
  !\+""
 , 
 but not in
  !\\+""
  (wher e the first backslash escapes the second), although the star “has a 
 backslash in front of it” in both examples.
  
 Depending upon the regex flavor, ther e ar e various situations when certain charac-ters are 
 and aren’t metacharacters. Chapter 3 discusses this in more detail.
  
 Flavor
  
 As I’ve hinted, differ ent tools use regular expressions for many differ ent things, and the set 
 of metacharacters and other features that each support can differ. Let’s look at word 
 boundaries again as an example. Some versions of
  egr ep
  support the 
 \<
 ˙˙˙
 \>
  notation we’ve 
 seen. However, some do not support the separate word-start and word-end, but one catch-
 all
  !\b""
  metacharacter (which we haven’t seen yet
  —
  we’ll see it in the next chapter). Still 
 others support both, and many others support neither.
  
 I use the term “flavor” to describe the sum total of all these little implementation decisions. 
 In the language analogy, it’s the same as a dialect of an individual speaker. Super ficially, this 
 concept refers to which metacharacters are and aren’t
  
 † You might also come across the decidedly unsightly “regexp.” I’m not sure how one would pro-
  
 nounce 
 that, but those with a lisp might find it a bit easier.
  
 27 April 2003 17:11",NA
Extending the Time Regex to Handle a 24-Hour Clock,"O
 Answer to the question on page 26.
  
 Ther e ar e various solutions, but we can use similar logic as before. This time,
  
 I’ll break the task into three groups: one for the morning (hours
  00
  thr ough
  
 09
 , with the leading zero being optional), one for the daytime (hours
  10
  
 thr ough
  19
 ), and one for the evening (hours
  20
  thr ough
  23
 ). This can be
  
 render ed in a pretty straightforward way:
  !0?[0-9]<1[0-9]<2[0-3]""
 .
  
 Actually, we can combine the first two alternatives, resulting in the shorter
  
 ![01]?[0-9]<2[0-3]""
 . You might need to think about it a bit to convince
  
 yourself that they’ll really match exactly the same text, but they do. The fig-
  
 ur e below might help, and it shows another approach as well. The shaded
  
 gr oups repr esent numbers that can be matched by a single alternative.
  
 [01]?[0-9]|2[0-3]
  
 [01]?[4-9]|[012]?[0-3]
  
 0
 0 
 0
 1
  0
 2
  0
 3
  0
 4
  0
 5
  0
 6
  0
 7
  0
 8
  0
 9 
  
 0 123456789
  
 00 01 02 03 04 05 06 07 08 09 
  
 00 01 02 03 04 05 06 07 08 09
  
 10 11 12 13 14 15 16 17 18 19 
  
 10 11 12 13 14 15 16 17 18 19
  
 20 21 22 23 
  
 20 21 22 23
  
 supported, but there’s much more to it. Even if two programs both support 
 !\<
 ˙˙˙
 \>""
 , they 
 might disagree on exactly what they do and don’t consider to be a word. This concern is 
 important when you
  use
  the tool.
  
 Don’t confuse “flavor” with “tool.” Just as two people can speak the same dialect, two 
 completely differ ent pr ograms can support exactly the same regex flavor. Also, two 
 programs with the same name (and built to do the same task) often have slightly (and 
 sometimes not-so-slightly) differ ent flavors. Among the various pr ograms called
  egr ep
 , ther 
 e is a wide variety of regex flavors supported.
  
 In the late 1990s, the particularly expressive flavor offer ed by the Perl program-ming 
 language was widely recognized for its power, and soon other languages wer e of fering Perl-
 inspir ed regular expressions (many even acknowledging the inspirational source by labeling 
 themselves “Perl-compatible”). The adopters include Python, many Java regex packages, 
 Microsoft’s .
 NET
  Framework, Tcl, and a variety of C libraries, to name a few. Yet, all are dif 
 ferent in important respects. On top of this, Perl’s regular expressions themselves are 
 evolving and growing (some-times, now, in response to advances seen with other tools). As 
 always, the overall landscape continues to become more varied and confusing.
  
 27 April 2003 17:11",NA
Improving on the Status Quo,"When it comes down to it, regular expressions are not difficult. But, if you talk to the 
 average user of a program or language that supports them, you will likely find someone that 
 understands them “a bit,” but does not feel secure enough to really use them for anything 
 complex or with any tool but those they use most often.
  
 Traditionally, regular expression documentation tends to be limited to a short and 
 incomplete description of one or two metacharacters, followed by a table of the rest. 
 Examples often use meaningless regular expressions like
  !a+((ab)+;b+)""
 , and text like ‘
 a xxx 
 ce xxxxxx ci xxx d
 ’. They also tend to completely ignore subtle but important points, and 
 often claim that their flavor is the same as some other well-known tool, almost always 
 forgetting to mention the exceptions where they inevitably differ. The state of regex 
 documentation needs help.
  
 Now, I don’t mean to imply that this chapter fills the gap for all regular expres-sions, or even 
 for
  egr ep
  regular expressions. Rather, this chapter merely provides the foundation upon 
 which the rest of this book is built. It may be ambitious, but I hope this book does fill the 
 gaps for you. I received many gratifying responses to the first edition, and have worked very 
 hard to make this one even better, both in br eadth and in depth.
  
 Perhaps because regular-expr ession documentation has traditionally been so lack-ing, I feel 
 the need to make the extra effort to make things particularly clear. Because I want to make 
 sure you can use regular expressions to their fullest potential, I want to make sure you really,
  
 really
  understand them.
  
 This is both good and bad.
  
 It is good because you will learn how to
  think
  regular expressions. You will learn which differ 
 ences and peculiarities to watch out for when faced with a new tool with a differ ent flavor. 
 You will know how to express yourself even with a weak, stripped-down regular expression 
 flavor. You will understand what makes one expr ession mor e ef ficient than another, and 
 will be able to balance tradeoffs among complexity, efficiency, and match results. When 
 faced with a particularly complex task, you will know how to work through an expression 
 the way the
  
 27 April 2003 17:11",NA
Summar y,"Table 1-3 summarizes the
  egr ep
  metacharacters we’ve looked at in this chapter.
  
 Table 1-3: Egr ep Metacharacter Summary
  
 Items to Match a Single Character Metacharacter 
  
 Matches
  
 .
  
 [
 ˙˙˙
 ] 
  
 [ˆ
 ˙˙˙
 ] 
  
 \
 char
  
 dot 
  
 character class 
  
 negated character class escaped 
 character
  
 Matches any one character 
  
 Matches any one character listed 
  
 Matches any one character not listed 
  
 When
  char
  is a metacharacter, or the escaped 
 combination is not otherwise special, matches the 
 literal
  char
  
 Items Appended to Provide “Counting” : The Quantifiers
  
 ?
  
 + 
  
 + 
  
 {
 min
 ,
 max
 }
  
 question 
  
 star 
  
 plus 
  
 specified range
 †
  
 One allowed, but it is optional 
  
 Any number allowed, but all are optional At least 
 one requir ed; additional are optional 
 Min
  requir 
 ed,
  max
  allowed
  
 Items That Match a Position
  
 ˆ
  
 $ 
  
 \< 
  
 \>
  
 car et 
  
 dollar 
  
 wor d boundary
 †
 wor d 
 boundary
 †
  
 Matches the position at the start of the line 
 Matches the position at the end of the line 
 Matches the position at the start of a word 
 Matches the position at the end of a word
  
 Other
  
 ; 
  
 (
 ˙˙˙
 )
  
 \1
 ,
  \2
 , ...
  
 alter nation 
  
 par entheses
  
 backr efer ence
 †
  
 Matches either expression it separates
  
 Limits scope of alternation, provides grouping for 
 the quantifiers, and “captures” for 
  
 backr efer ences
  
 Matches text previously matched within first, 
 second, etc., set of parentheses.
  
 †
 not supported by all versions of egrep
  
 In addition, be sure that you understand the following points:
  
 •
  Not all
  egr ep
  pr ograms ar e the same. The metacharacters supported, as well as their exact 
 meanings, are often differ ent
  —
  see your local documentation ( 23).
  
 •
  Thr ee reasons for using parentheses are constraining alternation ( 13), 
  
 gr ouping ( 14), 
 and capturing ( 21).
  
 •
  Character classes are special, and have their own set of metacharacters totally 
  
 distinct 
 from the “main” regex language ( 10).
  
 27 April 2003 17:11",NA
Personal Glimpses,"The doubled-word task at the start of this chapter might seem daunting, yet regu-lar 
 expressions are so power ful that we could solve much of the problem with a tool as limited 
 as
  egr ep
 , right here in the first chapter. I’d like to fill this chapter with flashy examples, but 
 because I’ve concentrated on the solid foundation for the later chapters, I fear that someone 
 completely new to regular expressions might read this chapter, complete with all the 
 warnings and cautions and rules and such, and feel “why bother?”
  
 Recently, my brothers were teaching some friends how to play
  schaf fkopf
 , a card game that’s 
 been in my family for generations. It is much more exciting than it appears at first glance, 
 but has a rather steep learning curve. After about half an hour, my sister-in-law Liz, normally 
 the quintessence of patience, got frustrated with the seemingly complex rules and said “Can’t 
 we just play rummy?” Yet, as it tur ned out, they ended up playing late into the night. Once 
 they were able to get
  
 27 April 2003 17:11",NA
2,NA,NA
Extended ,NA,NA
Introductor y Examples,"Remember the doubled-word problem from the first chapter? I said that a full solu-
  
 tion could be written in just a few lines in a language like Perl. Such a solution
  
 might look like:
  
 $/ = "".\n""; 
  
 while (<>) { 
  
 next if !s/
 \b([a-z]+)((?:\s
 <
 <[ˆ>]+>)+)(\1\b)
 /\e[7m$1\e[m$2\e[7m$3\e[m/ig; 
 s/
 ˆ(?:[ˆ\e]
 ,
 \n)+
 //mg; 
  
 #
  Remove any unmarked lines.
  
 }
  
 s/
 ˆ/$ARGV:
  /mg; 
  
 #
  Ensur e lines begin with filename.
  
 print;
  
 Yup, that’s the
  whole
  pr ogram.
  
 Even if you’re familiar with Perl, I don’t expect you to understand it (
 yet!
  ). Rather, I wanted 
 to show an example beyond what
  egr ep
  can allow, and to whet your appetite for the real 
 power of regular expressions.
  
 Most of this program’s work revolves around its three regular expressions:
  
 •
  !\b([a-z]+)((?:\s;<[ˆ>]+>)+)(\1\b)
  
 •
  !ˆ(?:[ˆ\e]+\n)+
  
 •
  !ˆ
  
 Though this is a Perl example, these three regular expressions can be used verba-tim (or with 
 only a few changes) in many other languages, including Python, Java, Visual Basic .
 NET
 , Tcl, 
 and more.
  
 Now, looking at these, that last
  !ˆ""
  is certainly recognizable, but the other expres-sions have 
 items unfamiliar to our
  egr ep
 -only experience. This is because Perl’s regex flavor is not the 
 same as
  egr ep
 ’s. Some of the notations are dif ferent, and Perl (as well as most modern tools) 
 tend to provide a much richer set of metachar-acters than
  egr ep
 . We’ll see many examples 
 throughout this chapter.
  
 35
  
 29 April 2003 20:21",NA
About the Examples,"This chapter takes a few sample problems
  —
  validating user input; working with email 
 headers; converting plain text to
  HTML
  —
  and wanders through the regular expr ession 
 landscape with them. As I develop them, I’ll “think out loud” to offer a few insights into the 
 thought processes that go into crafting a regex. During our jour ney, we’ll see some 
 constructs and features that
  egr ep
  doesn’t have, and we’ll take plenty of side trips to look at 
 other important concepts as well.
  
 Toward the end of this chapter, and in subsequent chapters, I’ll show examples in a variety 
 of languages including Java and Visual Basic .
 NET
 , but the examples thr oughout most of 
 this chapter are in Perl. Any of these languages, and most oth-ers for that matter, allow you 
 to employ regular expressions in much more com-plex ways than
  egr ep
 , so using any of them 
 for the examples would allow us to see interesting things. I choose to start with Perl 
 primarily because it has the most ingrained, easily accessible regex support among the 
 popular languages. Also, Perl pr ovides many other concise data-handling constructs that 
 alleviate much of the“dirty work” of our example tasks, letting us concentrate on regular 
 expressions.
  
 Just to quickly demonstrate some of these powers, recall the file-check example fr om page 
 2, where I needed to ensure that each file contained ‘
 ResetSize
 ’exactly as many times as 
 ‘
 SetSize
 ’. The utility I used was Perl, and the com-mand was:
  
 % perl -0ne ’print ""$ARGV\n"" if s/ResetSize//ig != s/SetSize//ig’ +
  
 (I don’t expect that you understand this yet
  —
  I hope merely that you’ll be impr essed with 
 the brevity of the solution.)
  
 I like Perl, but it’s important not to get too caught up in its trappings here. Remember, this 
 chapter concentrates on
  regular expressions
 . As an analogy, con-sider the words of a computer 
 science professor in a first-year course: “You’r e going to learn computer-science concepts 
 here, but we’ll use Pascal to show you.”
 †
  
 Since this chapter doesn’t assume that you know Perl, I’ll be sure to intr oduce enough to 
 make the examples understandable. (Chapter 7, which looks at all the nitty-gritty details of 
 Perl, does assume some basic knowledge.) Even if you have experience with a variety of 
 programming languages, normal Perl may seem quite odd at first glance because its syntax is 
 very compact and its semantics thick. In the interest of clarity, I won’t take advantage of 
 much that Perl has to offer, instead pr esenting pr ograms in a more generic, almost pseudo-
 code style. While not “bad,”the examples are not the best models of The Perl Way of 
 programming. But, we 
 will
  see some great uses of regular expressions.
  
 † Pascal is a traditional programming language originally designed for teaching. Thanks to William F. 
  
 Maton, and 
 his professor, for the analogy.
  
 29 April 2003 20:21",NA
A Shor t Introduction to Perl,"Perl is a powerful scripting language first developed in the late 1980s, drawing ideas from 
 many other programming languages and tools. Many of its concepts of text handling and 
 regular expressions are derived from two specialized languages called awk and sed, both of 
 which are quite differ ent fr om a “traditional” language such as C or Pascal.
  
 Perl is available for many platforms, including
  DOS
 /Windows, Mac
 OS
 ,
  OS
 /2,
  VMS
 , and 
 Unix. It has a powerful bent toward text handling, and is a particularly com-mon tool used 
 for Web-r elated pr ocessing. See
  www.perl.com
  for information on how to get a copy of Perl 
 for your system.
  
 This book addresses the Perl language as of Version 5.8, but the examples in this chapter are 
 written to work with versions as early as Version 5.005.
  
 Let’s look at a simple example:
  
 $celsius = 30; 
  
 $fahrenheit = ($celsius + 9 / 5) + 32; #
  calculate Fahrenheit 
  
 print ""$celsius C is $fahrenheit F.\n""; #
  report both temperatures
  
 When executed, this produces:
  
 30 C is 86 F.
  
 Simple variables, such as
  $fahrenheit
  and
  $celsius
 , always begin with a dollar sign, and can 
 hold a number or any amount of text. (In this example, only num-bers are used.) Comments 
 begin with
  #
  and continue for the rest of the line.
  
 If you’re used to languages such as C, C#, Java, or VB.NET, perhaps most surpris-ing is that 
 in Perl, variables can appear within a double-quoted string. With the string
  ""$celsius C is 
 $fahrenheit F.\n""
 , each variable is replaced by its value. In this case, the resulting string is 
 then printed. (The
  \n
  repr esents a newline.)
  
 Perl offers control structures similar to other popular languages:
  
 $celsius = 20; 
  
 while ($celsius <= 45) 
  
 { 
  
 $fahrenheit = ($celsius + 9 / 5) + 32; #
  calculate Fahrenheit 
  
 print ""$celsius C is $fahrenheit F.\n""; 
  
 $celsius = $celsius + 5; 
  
 }
  
 The body of the code controlled by the
  while
  loop is executed repeatedly so long as the 
 condition (the
  $celsius <= 45
  in this case) is true. Putting this into a file, say
  temps
 , we can 
 run it directly from the command line.
  
 29 April 2003 20:21",NA
Matching Text with Regular Expressions,"Perl uses regular expressions in many ways, the simplest being to check if a regex matches 
 text (or some part thereof) held in a variable. This snippet checks the string held in variable
  
 $reply
  and reports whether it contains only digits:
  
 if ($reply =˜ m/
 ˆ[0-9]+$
 /) { 
  
 print ""only digits\n""; 
  
 } else { 
  
 print ""not only digits\n""; 
  
 }
  
 The mechanics of the first line might seem a bit strange: the regular expression is 
 !ˆ[0-9]+$""
 , 
 while the surrounding
  m/
 ˙˙˙
 /
  tells Perl what to do with it. The
  m
  means to attempt a
  regular 
 expression match
 , while the slashes delimit the regex itself.
 †
 The preceding
  =˜
  links
  m/
 ˙˙˙
 /
  with 
 the string to be searched, in this case the con-tents of the variable
  $reply
 .
  
 Don’t confuse
  =˜
  with
  =
  or
  ==
 . The operator
  ==
  tests whether two numbers are the same. 
 (The operator
  eq
 , as we will soon see, is used to test whether two 
 strings
  ar e the same.) The
  =
  
 operator is used to assign a value to a variable, as with
  $celsius = 20
 . Finally,
  =˜
  links a regex 
 search with the target string to be searched. In the example, the search is
  m/ˆ[0-9]+$/
  and 
 the target is
  $reply
 . Other languages approach this differ ently, and we’ll see examples in the 
 next chapter.
  
 † In many situations, the
  m
  is optional. This example can also appear as
  $reply =˜ /ˆ[0-9]+$/
 , which some readers 
 with past Perl experience may find to be more natural. Personally, I feel the
  m
  is descriptive, so I tend to use it.
  
 29 April 2003 20:21",NA
To ward a More Real-World Example,"Let’s extend this example to allow negative and fractional temperature values. The math part 
 of the program is fine
  —
  Perl normally makes no distinction between integers and floating-
 point numbers. We do, however, need to modify the regex to let negative and floating-point 
 values pass. We can insert a leading
  !-?""
  to allow a leading minus sign. In fact, we may as well 
 make that
  ![-+]?""
  to allow a leading plus sign, too.
  
 To allow an optional decimal part, we add
  !(
 \.[0-9]
 ,)?""
 . The escaped dot matches a literal 
 period, so
  !\.[0-9]+""
  is used to match a period followed by any number of optional digits. 
 Since
  !\.[0-9]+""
  is enclosed by
  !(
 ˙˙˙
 )?""
 , the whole subex-pr ession becomes optional. (Realize 
 that this is very differ ent fr om
  !\.?[0-9]+""
 ,
  
 which incorrectly allows additional digits to match even if
  !\.""
  does not match.)
  
 Putting this all together, we get
  
 if ($celsius =˜ m/ˆ[-+]?[0-9]+(\.[0-9]+)?$/) {
  
  
 as our check line. It allows numbers such as
  32
 ,
  -3.723
 , and
  +98.6
 . It is actually not quite 
 perfect: it doesn’t allow a number that begins with a decimal point (such as
  .357
 ). Of course, 
 the user can just add a leading zero to allow it to match (e.g., 
 0.357
 ), so I don’t consider it a 
 major shortcoming. This floating-point problem can have some interesting twists, and I look 
 at it in detail in Chapter 5 ( 194).",NA
Side Effects of a Successful Match,"Let’s extend the example further to allow someone to enter a value in either Fahr enheit or 
 Celsius. We’ll have the user append a
  C
  or
  F
  to the temperature enter ed. To let this pass our 
 regular expression, we can simply add
  ![CF]""
  after the expr ession to match a number, but we 
 still need to change the rest of the program to recognize which kind of temperature was 
 entered, and to compute the other.
  
 In Chapter 1, we saw how some versions of
  egr ep
  support
  !\1""
 ,
  !\2""
 ,
  !\3""
 , etc. as 
 metacharacters to refer to the text matched by parenthesized subexpressions
  
 29 April 2003 20:21",NA
Inter twined Regular Expressions,"With advanced programming languages like Perl, regex use can become quite intertwined 
 with the logic of the rest of the program. For example, let’s make three useful changes to our 
 program: allow floating-point numbers as we did earlier, allow for the
  f
  or
  c
  enter ed to be 
 lowercase, and allow spaces between the num-ber and letter. Once all these changes are 
 done, input such as ‘
 98.6 f
 ’ will be allowed.
  
 Earlier, we saw how we can allow floating-point numbers by adding
  !(\.[0-9]+)? 
 to the 
 expression:
  
 if ($input =˜ m/ˆ
 (
 [-+]?[0-9]+(\.[0-9]+)?
 )
 ([CF])$/)
  
 Notice that it is added
  inside
  the first set of parentheses. Since we use that first set to capture 
 the number to compute, we want to make sure that they capture the fractional portion as 
 well. However, the added set of parentheses, even though ostensibly used only to group for 
 the question mark, also has the side effect of capturing into a variable. Since the opening 
 parenthesis of the pair is the second (fr om the left), it captures into
  $2
 . This is illustrated in 
 Figure 2-3.
  
 matches into 
 $1
  
 into 
 $2
  
 into 
 $3
  
 $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)([CF])$/
  
 1
 st 
 open parenthesis
  
 2
 nd
  open parenthesis
  
 3
 rd 
 open parenthesis
  
  
 Figur e 2-3: Nesting par entheses
  
 29 April 2003 20:21",NA
Non-Captur ing Parentheses:,NA,NA
 !,NA,NA
(?:,˙˙˙,NA
),"In Figure 2-3, we use the parentheses of the
  !
 (
 \.[0-9]+
 )
 ?""
  part for their gr ouping pr 
 operty, so we could apply a question mark to the whole of 
 !\.[0-9]+""
  and make it 
 optional. Still, as a side effect, text matched within these parentheses is captured and 
 saved to
  $2
 , which we don’t use. Wouldn’t it be better if there wer e a type of 
 parentheses that we could use for group-ing which didn’t involve the overhead (and 
 possible confusion) of capturing and saving text to a variable that we never intend to 
 use?
  
 Perl, and recently some other regex flavors, do provide a way to do this. Rather than 
 using
  !(
 ˙˙˙
 )""
 , which group and capture, you can use the special notation
  !(?:
 ˙˙˙
 )""
 , which 
 group
  but do not capture
 . With this notation, the“opening parentheses” is the three-
 character sequence
  (?:
 , which certainly looks odd. This use of ‘
 ?
 ’ has no relation to the 
 “optional”
  !?""
  metacharacter. (Peek ahead to page 90 for a note about why this odd 
 notation was chosen.)
  
 So, the whole expression becomes:
  
 if ($input =˜ m/ˆ([-+]?[0-9]+
 (?:
 \.[0-9]+
 )
 ?)([CF])$/)
  
 Now, even though the parentheses surrounding
  ![CF]""
  ar e ostensibly the third set, the 
 text they match goes to
  $2
  since, for counting purposes, the
  !(?:
 ˙˙˙
 ) 
 set doesn’t, well, 
 count.
  
 The benefits of this are twofold. One is that by avoiding the unnecessary capturing, 
 the match process is more efficient (efficiency is something we’ll look at in great detail 
 in Chapter 6). Another is that, overall, using exactly the type of parentheses needed for 
 each situation may be less confusing later to someone reading the code who might 
 otherwise be left wondering about the exact nature of each set of parentheses.
  
 On the other hand, the
  !(?:
 ˙˙˙
 )""
  notation
  is
  somewhat unsightly, and perhaps makes the 
 expression more dif ficult to grasp at a glance. Are the benefits worth it? Well, 
 personally, I tend to use exactly the kind of parentheses I need, but in this particular 
 case, it’s probably not worth the confusion. For example, efficiency isn’t really an issue 
 since the match is done just once (as opposed to being done repeatedly in a loop).
  
 Thr oughout this chapter, I’ll tend to use
  !(
 ˙˙˙
 )""
  even when I don’t need their capturing, 
 just for their visual clarity.
  
 The similarity is convenient, but I can’t stress enough how important it is to main-tain the 
 distinction between the differ ent types of metacharacters. It may not seem important for 
 such a simple example as
  \t
 , but as we’ll later see when looking at numer ous dif ferent 
 languages and tools, knowing which metacharacters are being used in each situation is 
 extremely important.
  
 29 April 2003 20:21",NA
Quiz Answer,"O
 Answer to the question on page 44.
  
 How do
  !
 [
  2
 ]
 ,""
  and
  ! ,<2, ""
  compare?
  
 !( +;2+)""
  allows either
  ! +""
  or
  !2+""
  to match, which allows either some spaces (or 
 nothing) or some tabs (or nothing). It doesn’t, however, allow a
  combi-nation
  of spaces 
 and tabs.
  
 On the other hand,
  ![ 2]+""
  matches
  ![ 2]""
  any number of times. With a string such as ‘
 2
 ’ 
 it matches three times, a tab the first time and spaces the rest.
  
 ![ 2]+""
  is logically equivalent to
  !( ;2)+""
 , although for reasons shown in Chapter 4, a 
 character class is often much more efficient.
  
 We have already seen multiple sets of metacharacters conflict. In Chapter 1, while working 
 with
  egr ep
 , we generally wrapped our regular expressions in single quotes. The whole
  egr ep
  
 command line is written at the command-shell prompt, and the shell recognizes several of its 
 own metacharacters. For example, to the shell, the space is a metacharacter that separates the 
 command from the arguments and the arguments from each other. With many shells, single 
 quotes are metachar-acters that tell the shell to not recognize other shell metacharacters in 
 the text between the quotes. (
 DOS
  uses double quotes.)
  
 Using the quotes for the shell allows us to use spaces in our regular expression. Without the 
 quotes, the shell would interpret the spaces in its own way instead of passing them through 
 to
  egr ep
  to interpret in
  its
  way. Many shells also recognize metacharacters such as
  $
 ,
  +
 ,
  ?
 , and 
 so on
  —
 characters that we are likely to want to use in a regex.
  
 Now, all this talk about other shell metacharacters and Perl’s string metacharacters has 
 nothing to do with regular expressions themselves, but it has everything to do with
  using
  
 regular expressions in real situations. As we move through this book, we’ll see numerous 
 (sometimes complex) situations where we need to take advan-tage of multiple levels of 
 simultaneously interacting metacharacters.
  
 And what about this
  !\b""
  business? This
  is
  a regex thing: in Perl regular expres-sions,
  !\b""
  nor 
 mally matches a word boundary, but within a character class, it matches a backspace. A word 
 boundary would make no sense as part of a class, so Perl is free to let it mean something 
 else. The warnings in the first chapter about how a character class’s “sub language” is differ 
 ent fr om the main regex lan-guage certainly apply to Perl (and every other regex flavor as 
 well).
  
 29 April 2003 20:21",NA
Inter mission,"Although we have spent much of this chapter coming up to speed with Perl, we’ve 
 encountered a lot of new information about regexes:
  
 1
 . Most tools have their own particular flavor of regular expressions. Perl’s appear to be of 
 the same general type as
  egr ep
 ’s, but has a richer set of meta-characters. Many other 
 languages, such as Java, Python, the .
 NET
  languages, and Tcl, have flavors similar to Perl’s.
  
 2
 . Perl can check a string in a variable against a regex using the construct 
 $variable =˜ m/
 rege 
 x
 /
 . The
  m
  indicates that a
  match
  is requested, while the slashes delimit (and are not part of) 
 the regular expression. The whole test, as a unit, is either true or false.
  
 3
 . The concept of metacharacters
  —
  characters with special interpretations
  —
  is not unique 
 to regular expressions. As discussed earlier about shells and dou-ble-quoted strings, 
 multiple contexts often vie for interpretation. Knowing the various contexts (shell, regex, 
 and string, among others), their metacharacters, and how they can interact becomes more 
 important as you learn and use Perl, Java, Tcl,
  GNU
  Emacs, awk, Python, or other advanced 
 languages. (And of course, within regular expressions, character classes have their own mini 
 language with a distinct set of metacharacters.)
  
 4
 . Among the more useful shorthands that Perl and many other flavors of regex pr ovide 
 (some of which we haven’t seen yet) are:
  
 \t 
 a tab character 
  
 \n 
 a newline character 
  
 \r 
 a carriage-r eturn character 
  
 \s 
 matches any “whitespace” character (space, tab, newline, formfeed, and such) 
 \S 
 anything 
 not
  !\s 
  
 \w ![a-zA-Z0-9R]""
  (useful as in
  !\w+""
 , ostensibly to match a word) 
  
 \W 
 anything not
  !\w""
 , i.e.,
  ![ˆa-zA-Z0-9R] 
  
 \d ![0-9]""
 , i.e., a digit 
  
 \D 
 anything not
  !\d""
 , i.e.,
  ![ˆ0-9]
  
 5
 . The
  /i
  modifier makes the test case-insensitive. Although written in prose as“
 /i
 ”, only “
 i
 ” 
 is actually appended after the match operator’s closing delimiter.
  
 6
 . The somewhat unsightly
  !(?:
 ˙˙˙
 )""
  non-capturing parentheses can be used for gr ouping 
 without capturing.
  
 7
 . After a successful match, Perl provides the variables
  $1
 ,
  $2
 ,
  $3
 , etc., which hold the text 
 matched by their respective
  !(
 ˙˙˙
 )""
  par enthesized subexpr essions in the regex. In concert 
 with these variables, you can use a regex to pluck infor mation fr om a string. (Other 
 languages provide the same type of infor-mation in other ways; we’ll see many examples in 
 the next chapter.)
  
 29 April 2003 20:21",NA
Modifying Text with Regular Expressions,"So far, the examples have centered on finding, and at times, “plucking out” infor-mation 
 from a string. Now we look at
  substitution 
  
 (also called
  sear ch and 
 replace
 ), a regex feature that Perl and many tools offer.
  
 As we have seen,
  $var =˜ m/
 rege x
 /
  attempts to match the given regular expres-sion to the 
 text in the given variable, and retur ns true or false appropriately. The similar construct
  $var 
 =˜ s/
 rege x
 /
 replacement
 /
  takes it a step further: if the regex is able to match somewhere in the 
 string held by
  $var
 , the text actually matched is replaced by
  replacement
 . The regex is the same 
 as with
  m/
 ˙˙˙
 /
 , but the replace-ment (between the middle and final slash) is treated as a 
 double-quoted string. This means that you can include refer ences to variables, including
  $1
 ,
  
 $2
 , and so on to refer to parts of what was just matched.
  
 Thus, with
  $var =˜ s/
 ˙˙˙
 /
 ˙˙˙
 /
  the value of the variable is actually changed. (If ther e is no match 
 to begin with, no replacement is made and the variable is left unchanged.) For example, if
  
 $var
  contained
  Jeff Friedl
  and we ran
  
 $var =˜
  s/
 Jeff
 /
 Jeffrey
 /
 ;
  
 $var
  would end up with
  Jeffrey Friedl
 . And if we did that again, it would end up with
  
 Jeffreyrey Friedl
 . To avoid that, perhaps we should use a word-boundary metacharacter. As 
 mentioned in the first chapter, some versions of
  egr ep 
 support
  !\<""
  and
  !\>""
  for their
  start-of-
 wor d
  and
  end-of-wor d
  metacharacters. Perl, however, provides the catch-all
  !\b""
 , which 
 matches either:
  
 $var =˜ s/
 \b
 Jeff
 \b
 /Jeffrey/;
  
 Her e’s a slightly tricky quiz: like
  m/
 ˙˙˙
 /
 , the
  s/
 ˙˙˙
 /
 ˙˙˙
 /
  operation can use modifiers, such as the
  /i
  
 fr om page 47. (The modifier goes after the replacement.) Practically speaking, what does
  
  
 $var =˜ s/\bJeff\b/Jeff/
 i
 ; 
  
 accomplish?
  O
  Flip the page to check your answer.",NA
Example: For m Letter,"Let’s look at a rather humorous example that shows the use of a variable in the replacement 
 string. I can imagine a form-letter system that might use a letter tem-plate with markers for 
 the parts that must be customized for each letter.
  
 29 April 2003 20:21",NA
Example: Prettifying a Stock Price,"As another example, consider a problem I faced while working on some stock-pricing 
 software with Perl. I was getting prices that looked like “9.0500000037272”. The price was 
 obviously 9.05, but because of how a computer repr esents the num-ber internally, Perl 
 sometimes prints them this way unless special formatting is used. Normally, I would just use
  
 printf
  to display the price with exactly two dec-imal digits as I did in the temperature-
 conversion example, but that was not
  
 29 April 2003 20:21",NA
Quiz Answer,"O
 Answer to the question on page 50.
  
 Just what does
  
 $var =˜ s/\bJeff\b/Jeff/i
  
 do?
  
 It might be tricky because of the way I posed it. Had I used
  !\bJEFF\b""
  or 
 !\bjeff\b""
  or 
 perhaps
  !\bjEfF\b""
  as the regex, the intent might have been mor e obvious. Because of
  
 /i
 , the word “Jeff” will be found without regard to capitalization. It will then be 
 replaced by ‘
 Jeff
 ’, which has exactly the capi-talization you see. (
 /i
  has no effect on the 
 replacement text, although there ar e other modifiers examined in Chapter 7 that do.)
  
 The end result is that “
 jeff
 ”, in any capitalization, is replaced by exactly‘
 Jeff
 ’.
  
 appr opriate in this case. At the time, stock prices were still given as fractions, and a price 
 that ended with, say,
 1
 /
 8
 , should be shown with three decimals (“.125”), not two.
  
 I boiled down my needs to “always take the first two digits after the decimal point, and take 
 the third digit only if it is not zero. Then, remove any other digits.” The result is that
  
 12.3750000000392
  or the already correct
  12.375
  is retur ned as
  
  
 “12.375”, yet
  37.500
  is reduced to “37.50”. Just what I wanted.
  
 So, how would we implement this? The variable
  $price
  contains the string in question, so 
 let’s use:
  
 $price =˜ s/
 (
 \.\d\d[1-9]?
 )
 \d+/$1/
  
 (Reminder:
  !\d""
  was introduced on page 49, and matches a digit.)
  
 The initial
  !\.""
  causes the match to start at the decimal point. The subsequent
  !\d\d 
 then 
 matches the first two digits that follow. The
  ![1-9]?""
  matches an additional non-zer o digit if 
 that’s what follows the first two. Anything matched so far is what we want to
  keep
 , so we 
 wrap it in parentheses to capture to
  $1
 . We can then use 
 $1
  in the replacement string. If this 
 is the only thing that matches, we replace exactly what was matched with itself
  —
  not very 
 useful. However, we go on to match other items outside the
  $1
  par entheses. They don’t find 
 their way to the replacement string, so the effect is that they’re removed. In this case, the “to 
 be removed” text is any extra digits, the
  !\d+""
  at the end of the regex.
  
 Keep this example in mind, as we’ll come back to it in Chapter 4 when looking at the 
 important mechanics of just what goes on behind the scenes during a match.
  
 Some very interesting lessons can be learned by playing with this example.
  
 29 April 2003 20:21",NA
Automated Editing,"I encounter ed another simple yet real-world example while working on this chap-ter. I was 
 logged in to a machine across the Pacific, but the network was particu-larly slow. Just getting 
 a response from hitting
  RETURN
  took more than a minute, but I needed to make a few 
 small changes to a file to get an important program going. In fact, all I wanted to do was 
 change every occurrence of
  sysread
  to 
 read
 . Ther e wer e only a few such changes to make, 
 but with the slow response, the idea of starting up a full-screen editor was impractical.
  
 Her e’s all I did to make all the changes I needed:
  
 %
  perl -p -i -e ’s/sysread/read/g’
  file
  
 This runs the Perl program
  s/sysread/read/g
 . (Yes, that’s the whole program
  —
 the
  -e
  flag 
 indicates that the entire program follows right there on the command line.) The
  -p
  flag 
 results in the substitution being done for every line of the named file, and the
  -i
  flag causes 
 any changes to be written back to the file when done.
  
 Note that there is no explicit target string for the substitute command to work on (that is, no
  
 $var =˜
  
 ˙˙˙
 ) because conveniently, the
  -p
  flag implicitly applies the pr ogram, 
 in turn, to each line of the file. Also, because I used the
  /g
  modifier, I’m sur e to replace 
 multiple occurrences that might be in a line.
  
 Although I applied this to only one file, I could have easily listed multiple files on the 
 command line and Perl would have applied my substitution to each line of each file. This 
 way, I can do mass editing across a huge set of files, all with one simple command. The 
 particular mechanics with which this was done are unique to Perl, but the moral of the story 
 is that regular expressions as part of a scripting language can be very powerful, even in small 
 doses.",NA
A Small Mail Utility,"Let’s work on another example tool. Let’s say we have an email message in a file, and we 
 want to prepar e a file for a reply. During the preparation, we want to quote the original 
 message so we can easily insert our own reply to each part. We also want to remove 
 unwanted lines from the header of the original message, as well as prepar e the header of our 
 own reply.
  
 The sidebar on the next page shows an example. The header has interesting fields
 —
  date, 
 subject, and so on
  —
  but also much that we are not interested in that we’ll want to remove. 
 If the script we’re about to write is called
  mkr eply
 , and the origi-nal message is in the file
  
 king.in
 , we would make the reply template with:
  
 %
  perl -w mkreply king.in > king.out
  
 (In case you’ve forgotten, the
  -w
  option enables extra Perl warnings 38.)
  
 29 April 2003 20:21",NA
A Sample Email Message,"From elvis Fri Feb 29 11:15 2002 
  
 Received: from elvis@localhost by tabloid.org (8.11.3) id KA8CMY Received: from 
 tabloid.org by gateway.net (8.12.5/2) id N8XBK To: jfriedl@regex.info (Jeffrey Friedl) 
  
 From: elvis@tabloid.org (The King) 
  
 Date: Fri, Feb 29 2002 11:15 
  
 Message-Id: <2002022939939.KA8CMY@tabloid.org> 
  
 Subject: Be seein’ ya around 
  
 Reply-To: elvis@hh.tabloid.org 
  
 X-Mailer: Madam Zelda’s Psychic Orb [version 3.7 PL92]
  
 Sorry I haven’t been around lately. A few years back I checked into that ole heartbreak 
 hotel in the sky, ifyaknowwhatImean. The Duke says ""hi"".
  
 Elvis
  
 We want the resulting file,
  king.out
 , to contain something like:
  
 To: elvis@hh.tabloid.org (The King) 
  
 From: jfriedl@regex.info (Jeffrey Friedl) 
  
 Subject: Re: Be seein’ ya around
  
 On Fri, Feb 29 2002 11:15 The King wrote: 
  
 ;> Sorry I haven’t been around lately. A few years back I checked ;> into that ole heartbreak 
 hotel in the sky, ifyaknowwhatImean. ;> The Duke says ""hi"".
  
 ;> 
  
 Elvis
  
 Let’s analyze this. To print out our new header, we need to know the destination addr ess (in 
 this case
  elvis@hh.tabloid.org
 , derived from the
  Reply-To
  field of the original), the recipient’s 
 real name (
 The King
 ), our own address and name, as well as the subject. Additionally, to print 
 out the introductory line for the message body, we need to know the message date.
  
 The work can be split into three phases:
  
 1
 . Extract information from the message header 
  
 2
 . Print out the reply header 
  
 3
 . Print out the original message, indented by ‘
 ;>
  ’
  
 I’m getting a bit ahead of myself
  —
  we can’t worry about processing the data until we 
 determine how to read the data into the program. Fortunately, Perl makes this a breeze with 
 the magic “
 < >
 ” operator. This funny-looking construct gives you the next line of input 
 when you assign from it to a normal
  $variable
 , as with“
 $variable = < >
 ”. The input comes 
 from files listed after the Perl script on the command line (from
  king.in
  in the previous 
 example).
  
 Don’t confuse the two-character operator
  < >
  with the shell’s “
 >
  filename
 ” redir ec-tion or 
 Perl’s greater-than/less-than operators. It is just Perl’s funny way to express a kind of a
  
 getline( )
  function.
  
 29 April 2003 20:21",NA
A War ning About,NA,NA
 !,NA,NA
 .,NA,NA
"+""","The expression
  ! .+""
  is often used to mean “a bunch of anything,” since dot can match 
 anything (with some tools, anything except newlines) and star means that any amount 
 is allowed, but none requir ed. This can be quite useful.
  
 However, some hidden “gotchas” can bite the user who doesn’t fully under-stand the 
 implications of how it works when used as part of a larger expres-sion. We’ve already 
 seen one example ( 26), and will see many more in Chapter 4 when this topic is 
 discussed in depth ( 164).
  
 Similarly, we can look for the
  Date
  and
  Reply-To
  fields:
  
 if (
 $line =˜ m/ˆDate: (.
 ,
 )/i
 ) { 
  
  
 $date = $1; 
  
 } 
  
 if (
 $line =˜ m/ˆReply-To: (.
 ,
 )/i
 ) { 
  
  
 $replyRaddress = $1; 
  
 }
  
 The
  From:
  line involves a bit more work. First, we want the one that begins with‘
 From:
 ’, not 
 the more cryptic first line that begins with ‘
 From
  ’. We want:
  
 From: elvis@tabloid.org (The King)
  
 It has the originating address, as well as the name of the sender in parentheses; our goal is to 
 extract the name.
  
 To match up through the address, we can use
  !ˆFrom: (\S+)""
 . As you might guess, 
 !\S""
  
 matches anything that’s
  not
  whitespace ( 49), so
  !\S+""
  matches up until the first whitespace 
 (or until the end of the target text). In this case, that’s the originat-ing address. Once that’s 
 matched, we want to match whatever is in parentheses. Of course, we also need to match 
 the parentheses themselves. This is done using 
 !\(""
  and
  !\)""
 , escaping the parentheses to 
 remove their special metacharacter mean-ing. Inside the parentheses, we want to match 
 anything
  —
  anything except another par enthesis! That’s accomplished with
  ![ˆ()]+""
 . 
 Remember, the character-class metacharacters are dif ferent from the “normal” regex 
 metacharacters; inside a char-acter class, parentheses are not special and do not need to be 
 escaped.
  
 So, putting this all together we get:
  
 !ˆFrom: (\S+) \(([ˆ()]+)\)""
 .
  
 At first it might be a tad confusing with all those parentheses, so Figure 2-4 on the facing 
 page shows it more clearly.
  
 29 April 2003 20:21",NA
Adding Commas to a Number with Lookaround,"Pr esenting large numbers with commas often makes reports more readable. Some-thing like
  
 print ""The US population is $pop\n"";
  
 might print out “The US population is 281421906,” but it would look more natural to most 
 English speakers to use “281,421,906” instead. How might we use a regu-lar expression to 
 help?
  
 Well, when we insert commas mentally, we count sets of digits by threes from the right, and 
 insert commas at each point where ther e ar e still digits to the left. It’d be nice if we could 
 apply this natural process directly with a regular expression, but regular expressions generally 
 work left-to-right. However, if we distill the idea of wher e commas should be inserted as 
 “locations having digits on the right in exact sets of three, and at least some digits on the 
 left,” we can solve this problem easily using a set of relatively new regex features collectively 
 called
  lookar ound
 .
  
 Lookar ound constructs are similar to word-boundary metacharacters like
  !\b""
  or the anchors
  
 !ˆ""
  and
  !$""
  in that they don’t match text, but rather match
  positions
  within
  
 29 April 2003 20:21",NA
Quiz Answer,"O
 Answer to the question on page 63.
  
 What does 
  
 s/(?=s\b)(?<=\b Jeff)/’/g
  do?
  
 In this case, it doesn’t matter which order
  !(?=s\b)""
  and
  !(?<=\b Jeff)""
  ar e arranged. 
 Whether “checking on the right, then the left” or the other way ar ound, the key is that 
 both checks must succeed at the same position for the combination of the two checks 
 to succeed. For example, in the string‘
 Thomas Jefferson
 ’, both
  !(?=s\b)""
  and
  !(?<=\b 
 Jeff)""
  can match (at the two locations marked), but since there is no one position 
 where both can be successful, the combination of the two cannot match.
  
 It’s fine for now to use the somewhat vague phrase “combination of the two”to talk 
 about this, as the meaning is fairly intuitive in this case. There are times, however, 
 when exactly
  how
  a regex engine goes about applying a regex may not necessarily be 
 quite so intuitive. Since how it works has immediate practical effects on what our 
 regular expressions really mean, Chapter 4 discusses this in explicit detail.
  
 work properly with two of them.
  O
  Think about which ones would work, and why, and then 
 turn the page to check your answer.
  
 Back to the comma example . . .
  
 You’ve probably already realized that the connection between the “Jeffs” example and the 
 comma example lies in our wanting to insert something at a
  location
  that we can describe with 
 a regular expression.
  
 Earlier, we realized that we wanted to insert commas at “locations having digits on the right 
 in exact sets of three, and at least some digits on the left.” The second requir ement is simple 
 enough with lookbehind. One digit on the left is enough to fulfill the “some digits on the 
 left” requir ement, and that’s
  !(?<=
 \d
 )""
 .
  
 Now for “locations having digits on the right in exact sets of three.” An exact set of thr ee 
 digits is
  !\d\d\d""
 , of course. We can wrap it with
  !(
 ˙˙˙
 )+""
  to allow more than one (the “sets” of 
 our requir ement), and append
  !$""
  to ensure that nothing follows (the “exact” of our requir 
 ement). Alone,
  !(\d\d\d)+$""
  matches sets of triple digits to the end of the string, but when 
 inserted into the
  !(?=
 ˙˙˙
 )""
  lookahead construct, it matches at
  locations
  that are even sets of triple 
 digits from the end of the string, such as at the marked locations in ‘
 123456789
 ’. That’s 
 actually more than we want
  
 —
 we don’t want to put a comma before the first digit
  —
 so we add
  !(?<=
 \d
 )""
  to fur-ther limit 
 the match locations.
  
 29 April 2003 20:21",NA
Quiz Answer,"O
 Answer to the question on page 64.
  
 Which “Jeffs” solutions would preser ve case when applied with
  /i
 ?
  
 To preserve case, you’ve got to either replace the exact characters consumed (rather 
 than just always inserting ‘
 Jeff’s
 ’), or not consume any letters. The second solution 
 listed in Table 2-1 takes the first approach, capturing what is consumed and using
  $1
  
 and
  $2
  to put it back. The last two solutions in the table take the “don’t consume 
 anything” approach. Since they don’t consume text, they have nothing to preserve.
  
 The first and third solutions hard-code the replacement string. If applied with 
 /i
 , they 
 don’t preserve case. They end up incorrectly replacing
  JEFFS
  with 
 Jeff’s
  and
  Jeff’S
 , 
 respectively.
  
 and
  positive lookbehind
 , since they are successful at positions where their subex-pr ession is 
 able to match. As Table 2-2 shows, their converse,
  negative lookahead 
 and
  negative lookbehind
 , are 
 also available. As their name implies, they are suc-cessful as positions where their 
 subexpression is not able to match.
  
 Table 2-2: Four Types of Lookaround
  
 Type 
  
 Regex 
  
 Successful if the enclosed subexpression . . .
  
 Positive Lookbehind 
 Negative Lookbehind
  
 (?<=
 ......
 ) 
 (?<!
 ......
 )
  
 successful if
  can
  match to the
  left 
  
 successful if
  can not
  match to the
  left
  
 Positive Lookahead 
 Negative Lookahead
  
 (?=
 ......
 ) 
 (?!
 ......
 )
  
 successful if
  can
  match to the
  right 
 successful if
  can not
  match to the
  right
  
 So, if a word boundary is a position with
  !\w""
  on one side and not
  !\w""
  on the other, we can 
 use
  !(?<
 !
 \w)(?
 =
 \w)""
  as a start-of-word boundary, and its complement 
 !(?<
 =
 \w)(?
 !
 \w)""
  as an 
 end-of-word boundary. Putting them together, we could use 
 !(?<!\w)(?=\w)<(?<=\w)(?!\w)""
  
 as a replacement for
  !\b""
 . In practice, it would be silly to do this for languages that natively 
 support
  \b
  (
 \b
  is much more dir ect and ef ficient), but the individual alternatives may 
 indeed be useful ( 132).
  
 For our comma problem, though, we really need only
  !
 (?!
 \d
 )
 ""
  to cap our sets of thr ee digits. 
 We use that instead of
  !\b""
  or
  !$""
 , which leaves us with:
  
 $text =˜ s/(?<=\d)
 (?=
 (\d\d\d)+(?!\d)
 )
 /,/g;
  
  
 This now works on text like “ . . . tone of 12345Hz,” which is good, but unfortu-nately it 
 also matches the year in “ . . .  the 1970s . . .” Actually, any of these match“ . . .  in 1970 . . . 
 ,” which is not good. There’s no substitute for knowing the data",NA
Te xt-to-,NA,NA
HTML,NA,NA
 Conversion,"Let’s write a little tool to convert plain text to
  HTML
 . It’s difficult to write a general tool 
 that’s useful for every situation, so for this section we’ll just write a simple tool whose main 
 goal is to be a teaching vehicle.
  
 In all our examples to this point, we’ve applied regular expressions to variables containing 
 exactly one line of text. For this project, it is easier (and more inter est-ing) if we have the 
 entire text we wish to convert available as one big string. In Perl, we can easily do this with:
  
 undef $/; 
  
 #
  Enter ""file-slurp"" mode.
  
 $text = < >; #
  Slurp up the first file given on the command line.
  
 29 April 2003 20:21",NA
Quiz Answer,"O
 Answer to the question on page 67.
  
 Does 
  
 $text =˜ s/(\d)((\d\d\d)+\b)/$1,$2/g
  ""commaify"" a number?
  
 This won’t work the way we want. It leaves results such as “281,421906.” This is 
 because the digits matched by
  !(\d\d\d)+""
  ar e now actually part of the final match, 
 and so are not left “unmatched” and available to the next itera-tion of the regex via 
 the
  /g
 .
  
 When one iteration ends, the next picks up the inspection of the text at the point 
 where the previous match ended. We’d like that to be the point where the comma was 
 inserted so we can go ahead and check to see whether addi-tional commas need to be 
 inserted later in the same number. But, in this case, that restarting point is at the end 
 of all the digits. The whole point of using lookahead was to get the positional check 
 without actually having the inspected text check count toward the final “string that 
 matched.”
  
 Actually, this expression can still be used to solve this problem. If the expres-sion is 
 applied repeatedly by the host language, such as via a while loop, the newly-modified 
 text is completely revisited each time. With each such appli-cation, one more comma is 
 added (to each number in the target string, due to the
  /g
  modifier). Here’s an example:
  
 while ( $text =˜ s/(\d)((\d\d\d)+\b)/$1,$2/g ) { 
  
  
 #
  Nothing to do inside the body of the while -- we merely want to reapply the regex until it fails 
 }
  
 If our sample file contains the three short lines
  
 This is a sample file. 
  
 It has three lines.
  
 That’s all
  
 the variable
  $text
  will then contain
  
 This is a sample file.1 It has three lines.1 That’s all1
  
 although depending on the system, it could instead be
  
 This is a sample file.|1 It has three lines.|1 That’s all|1
  
 since most systems use a newline to end lines, but some (most notably Windows) use a 
 carriage-retur n/newline combination. We’ll be sure that our simple tool works with either.
  
 Cooking special character s
  
 Our first step is to make any ‘
 &
 ’, ‘
 <
 ’, and ‘
 >
 ’ characters in the original text “safe” by 
 converting them to their proper
  HTML
  encodings, ‘
 &amp;
 ’, ‘
 &lt;
 ’, and ‘
 &gt;
 ’respectively. 
 Those characters are special to
  HTML
 , and not encoding them
  
 29 April 2003 20:21",NA
That Doubled-Word Thing,"The doubled-word problem in Chapter 1 hopefully whetted your appetite for the power of 
 regular expressions. I teased you at the start of this chapter with a cryp-tic bunch of symbols 
 I called a solution:
  
 $/ = "".\n""; 
  
 while (<>) { 
  
 next if !s/
 \b([a-z]+)((?:\s
 <
 <[ˆ>]+>)+)(\1\b)
 /\e[7m$1\e[m$2\e[7m$3\e[m/ig; 
 s/
 ˆ(?:[ˆ\e]
 ,
 \n)+
 //mg; 
  
 #
  Remove any unmarked lines.
  
 }
  
 s/
 ˆ/$ARGV:
  /mg; 
  
 #
  Ensur e lines begin with filename.
  
 print;
  
 Now that you’ve seen a bit of Perl, you hopefully understand at least the general for m
  —
  the
  
 < >
 , the three
  s/
 ˙˙˙
 /
 ˙˙˙
 /
 , and the
  print
 . Still, it’s rather heady stuff! If this chapter has been your 
 only exposure to Perl (and these chapters your only exposur e to regular expressions), this 
 example is probably a bit beyond what you want to be getting into at this point.
  
 However, when it comes down to it, I don’t think the regex is really so difficult. Befor e 
 looking at the program again, it might be good to review the specification found on page 1, 
 and to see a sample run:
  
 %
  perl -w FindDbl ch01.txt 
  
 ch01.txt: check for doubled words (such as this this this this ), a common problem with ch01.txt: + Find 
 doubled words despite capitalization differences, such as with ‘The ch01.txt: the the
  ˙˙˙
 ’, as well as allow 
 differing amounts of whitespace (space, tabs, ch01.txt: /\<(1,000,000;million;thousand 
  
 thousand thousand thousand )/. But alternation can’t be ch01.txt: of this chapter. If you knew the the the the 
 specific doubled word to find (such 
  
 + 
  
  
 + 
  
  
 +
  
 29 April 2003 20:21",NA
3,NA,NA
Over view of ,NA,NA
Regular Expression ,NA,NA
Features and Flavors,"Now that you have a feel for regular expressions and a few diverse tools that use them, you 
 might think we’re ready to dive into using them wherever they’re found. But even a simple 
 comparison among the
  egr ep
  versions of the first chapter and the Perl and Java in the 
 previous chapter shows that regular expressions and the way they’re used can vary wildly 
 from tool to tool.
  
 When looking at regular expressions in the context of their host language or tool, ther e ar e 
 thr ee br oad issues to consider:
  
 •
  What metacharacters are supported, and their meaning. Often called the regex
  
 “flavor.”
  
 •
  How regular expressions “interface” with the language or tool, such as how to specify 
 regular-expr ession operations, what operations are allowed, and what text they operate 
 on.
  
 •
  How the regular-expr ession engine actually goes about applying a regular expr ession to 
 some text. The method that the language or tool designer uses to implement the 
 regular-expr ession engine has a strong influence on the results one might expect from 
 any given regular expression.
  
 Regular Expressions and Cars
  
 The considerations just listed parallel the way one might think while shopping for a car. With 
 regular expressions, the metacharacters are the first thing you notice, just as with a car it’s the 
 body shape, shine, and nifty features like a CD player and leather seats. These are the types 
 of things you’ll find splashed across the pages of a glossy brochur e, and a list of 
 metacharacters like the one on page 32 is the reg-ular-expr ession equivalent. It’s important 
 information, but only part of the story.
  
 83
  
 29 April 2003 09:19",NA
A Casual Stroll Across the Regex Landscape,"I’d like to start with the story about the evolution of some regular expression fla-vors and 
 their associated programs. So, grab a hot cup (or frosty mug) of your favorite brewed 
 beverage and relax as we look at the sometimes wacky history behind the regular expressions 
 we have today. The idea is to add color to our regex understanding, and to develop a feeling 
 as to why “the way things are” are the way things are. There are some footnotes for those 
 that are inter ested, but for the most part, this should be read as a light story for enjoyment.",NA
The Origins of Regular Expressions,"The seeds of regular expressions were planted in the early 1940s by two neuro-physiologists, 
 Warr en McCulloch and Walter Pitts, who developed models of how they believed the 
 nervous system worked at the neuron level.
 †
 Regular expressions became a reality several 
 years later when mathematician Stephen Kleene formally described these models in an 
 algebra he called
  regular sets
 . He devised a simple notation to express these regular sets, and 
 called them
  regular expressions
 .
  
 Thr ough the 1950s and 1960s, regular expressions enjoyed a rich study in theoreti-cal 
 mathematics circles. Robert Constable has written a good summary
 ‡
 for the mathematically 
 inclined.
  
 Although there is evidence of earlier work, the first published computational use of regular 
 expressions I have actually been able to find is Ken Thompson’s 1968 article
  Regular 
 Expression Search Algorithm
 §
 in which he describes a regular-expr ession compiler that 
 produced IBM 7094 object code. This led to his work on 
 qed
 , an editor that formed the basis 
 for the Unix editor
  ed
 .
  
 ed
  ’s regular expressions were not as advanced as those in
  qed
 , but they were the first to gain 
 widespread use in non-technical fields.
  ed
  had a command to display lines of the edited file 
 that matched a given regular expression. The command,“
  g/
 Regular Expression
 /p
  ”, was read 
 “Global Regular Expr ession Print.” This particu-
  
  
   
 lar function was so useful that it was made into its own utility,
  gr ep
  (after which 
 egr ep
  —
 extended
  gr ep
  —
 was later modeled).
  
 † “A logical calculus of the ideas imminent in nervous activity,” first published in
  Bulletin of Math. Bio-physics
  5 (1943) 
 and later reprinted in
  Embodiments of Mind
  (
 MIT
  Pr ess, 1965). The article begins with an interesting summary of 
 how neurons behave (did you know that intra-neuron impulse speeds can range from 1 all the way to 150 meters 
 per second?), and then descends into a pit of for-mulae that is, literally, all Greek to me.
  
 ‡ Robert L. Constable, “The Role of Finite Automata in the Development of Modern Computing The-ory,” in
  The 
 Kleene Symposium
 , Eds. Barwise, Keisler, and Kunen (North-Holland Publishing Com-pany, 1980), 61–83.
  
 §
  Communications of the
  ACM
 , Vol.11, No. 6, June 1968.
  
 29 April 2003 09:19",NA
At a Glance,"A chart showing just a few aspects of some common tools gives a good clue to how differ 
 ent things still are. Table 3-3 provides a very superficial look at a few aspects of the regex 
 flavors of a few tools.
  
 Table 3-3: A (Very) Superficial Look at the Flavor of a Few Common Tools
  
 Feature
  
 Moder n 
 gr ep
  
 Moder n 
 egr ep
  
  GNU 
 Emacs
  
 Tcl
  
 Perl 
  
 .
 NET
  
 Sun’s Java 
 packa ge
  
 +
 ,
  ˆ
 ,
  $
 ,
  [
 ˙˙˙
 ]
  
  
  
  
  
  
  
  
  
 ?
  
 +
  
 ;
  
  
 \? \+ \;
  
  
 ?
  
 +
  
 ;
  
  
  
 ?
  
 +
  
 \;
  
  
  
 ?
  
 +
  
 ;
  
  
  
 ?
  
 +
  
 ;
  
  
  
 ?
  
 +
  
 ;
  
  
  
 ?
  
 +
  
 ;
  
  
 gr ouping
  
 \(
 ˙˙˙
 \) 
  
 (
 ˙˙˙
 )
  
 \(
 ˙˙˙
 \) 
  
 (
 ˙˙˙
 )
  
 (
 ˙˙˙
 )
  
 (
 ˙˙˙
 )
  
 (
 ˙˙˙
 )
  
 (?:
 ˙˙˙
 )
  
  
  
  
  
  
  
  
 word boundary
  
  
 \< \>
  
 \< \> \b
 ,
 \B 
  
 \m
 ,
  \M
 ,
  \y 
  
 \b
 ,
 \B 
  
 \b
 ,
 \B 
  
 \b
 ,
 \B
  
 \w
 ,
  \W
  
  
  
  
  
  
  
  
 backr efer ences
  
  
  
  
  
  
  
  
  supported
  
 29 April 2003 09:19",NA
Care and Handling of ,NA,NA
Regular Expressions,"The second concern outlined at the start of the chapter is the syntactic packaging that tells 
 an application “Hey, here’s a regex, and this is what I want you to do with it.”
  egr ep
  is a 
 simple example because the regular expression is expected as an argument on the command 
 line. Any extra syntactic sugar, such as the single quotes I used throughout the first chapter, 
 are needed only to satisfy the command shell, not
  egr ep
 . Complex systems, such as regular 
 expressions in programming languages, requir e mor e complex packaging to inform the 
 system exactly what the regex is and how it should be used.
  
 The next step, then, is to look at what you can do with the results of a match. Again,
  egr ep
  is 
 simple in that it pretty much always does the same thing (displays
  
 29 April 2003 09:19",NA
Integ rated Handling,"We’ve already seen a bit of Perl’s integrated approach, such as this example from page 55:
  
 if (
 $line
  =˜ m/
 ˆSubject: (.+)
 /i)
  {
  
  
 $subject
  =
  $1
 ; 
  
 }
  
 Her e, for clarity, variable names I’ve chosen are in italic, while the regex-r elated items are 
 bold, and the regular expression itself is underlined. We know that Perl applies the regular 
 expression
  !ˆSubject: (.+)""
  to the text held in
  $line
 , and if a match is found, executes the 
 block of code that follows. In that block, the variable 
 $1
  repr esents the text matched within 
 the regular expression’s parentheses, and this gets assigned to the variable
  $subject
 .
  
 Another example of an integrated approach is when regular expressions are part of a 
 configuration file, such as for
  pr ocmail
  (a Unix mail-processing utility.) In the configuration 
 file, regular expressions are used to route mail messages to the sec-tions that actually process 
 them. It’s even simpler than with Perl, since the operands (the mail messages) are implicit.
  
 What goes on behind the scenes is quite a bit more complex than these examples show. An 
 integrated approach simplifies things to the programmer because it hides in the background 
 some of the mechanics of preparing the regular expression, set-ting up the match, applying 
 the regular expression, and deriving results from that application. Hiding these steps makes 
 the normal case very easy to work with, but as we’ll see later, it can make some cases less 
 efficient or clumsier to work with.
  
 29 April 2003 09:19",NA
Procedural and Object-Oriented Handling,"Pr ocedural and object-oriented handling are fairly similar. In either case, regex functionality 
 is provided not by built-in regular-expr ession operators, but by nor-mal functions 
 (procedural) or constructors and methods (object-oriented). In this case, there are no true 
 regular-expr ession operands, but rather normal string argu-ments that the functions, 
 constructors, or methods choose to interpret as regular expr essions.
  
 The next sections show examples in Java, VB.NET, and Python.
  
 Regex handling in Java
  
 Let’s look at the equivalent of the “Subject” example in Java, using Sun’s 
 java.util.regex
  
 package. (Java is covered in depth in Chapter 8.)
  
 import
  java.util.regex.
 ,; //
  Make regex classes easily available 
 ++ 
  
 +
  
 –
  
 —
  
 ˜
  
 ™
  
 Pattern
  r
  =
  Pattern.compile
 (""ˆSubject: (.+)"",
  Pattern.CASE
 Q
 INSENSITIVE
 ); 
 Matcher
  m
  =
  
 r
 .matcher
 (
 line
 ); 
  
 if (
 m
 .find()
 ) { 
  
  
 subject
  =
  m
 .
 group(
 1
 )
 ;
  
 }
  
 Variable names I’ve chosen are again in italic, the regex-r elated items are bold, and the 
 regular expression itself is underlined. Well, to be precise, what’s underlined is a nor mal 
 string literal
  to be interpreted
  as a regular expression.
  
 This example shows an object-oriented approach with regex functionality supplied by two 
 classes in Sun’s
  java.util.regex
  package:
  Pattern
  and
  Matcher
 . The actions perfor med ar e:
  
 –
  
 Inspect the regular expression and compile it into an internal form that 
  
 matches 
 in a case-insensitive manner, yielding a “
 Pattern
 ” object.
  
 —
  
 Associate it with some text to be inspected, yielding a “
 Matcher
 ” object.
  
 ˜
  
 Actually apply the regex to see if there is a match in the previously-associ-
  
 ated text, 
 and let us know the result.
  
 ™
  
 If there is a match, make available the text matched within the first set of 
  
 capturing 
 parentheses.
  
 Actions similar to these are requir ed, explicitly or implicitly, by any program wish-ing to use 
 regular expressions. Perl hides most of these details, and this Java implementation usually 
 exposes them.
  
 29 April 2003 09:19",NA
A Sear ch-and-Replace Example,"The “Subject” example is pretty simple, so the various approaches really don’t have an 
 opportunity to show how differ ent they really are. In this section, we’ll look at a somewhat 
 more complex example, further highlighting the differ ent designs.
  
 29 April 2003 09:19",NA
Sear ch and Replace in Other Languages,"Let’s quickly look at a few examples from other traditional tools and languages.
  
 Awk
  
 Awk uses an integrated approach,
  /
 rege x
 /
 , to per form a match on the current input line, and 
 uses “
 var ˜
  
 ˙˙˙
 ” to per form a match on other data. You can see wher e 
 Perl got its notation for matching. (Perl’s substitution operator, however, is modeled after 
 sed’s.) The early versions of awk didn’t support a regex substitution, but modern versions 
 have the
  sub(
 ˙˙˙
 )
  operator:
  
 sub(/mizpel/, ""misspell"")
  
 This applies the regex
  !mizpel""
  to the current line, replacing the first match with 
 misspell
 . 
 Note how this compares to Perl’s (and sed’s)
  s/mizpel/misspell/
 .
  
 To replace all matches within the line, awk does not use any kind of
  /g
  modifier, but a differ 
 ent operator altogether:
  gsub(/mizpel/, ""misspell"")
 .
  
 29 April 2003 09:19",NA
Care and Handling: Summary,"As you can see, there’s a wide range of functionalities and mechanics for achiev-ing them. If 
 you are new to these languages, it might be quite confusing at this point. But, never fear! 
 When trying to learn any one particular tool, it is a simple matter to learn its mechanisms.",NA
"Str ings, Character Encodings, and Modes","Befor e getting into the various type of metacharacters generally available, there are a 
 number of global issues to understand: regular expressions as strings, character encodings, 
 and match modes.
  
 These are simple concepts, in theory, and in practice, some indeed are. With most, though, 
 the small details, subtleties, and inconsistencies among the various imple-mentations 
 sometimes makes it hard to pin down exactly how they work in prac-tice. The next sections 
 cover some of the common and sometimes complex issues you’ll face.",NA
Str ings as Regular Expressions,"The concept is simple: in most languages except Perl, awk, and sed, the regex engine accepts 
 regular expressions as normal strings
  —
  strings that are often pro-vided as string literals like
  
 ""ˆFrom:(.+)""
 . What confuses many, especially early on, is the need to deal with the language’s 
 own string-literal metacharacters when composing a string to be used as a regular expression.
  
 Each language’s string literals have their own set of metacharacters, and some lan-guages 
 even have more than one type of string literal, so there’s no one rule that works everywhere, 
 but the concepts are all the same. Many languages’ string liter-als recognize escape sequences 
 like
  \t
 ,
  \\
 , and
  \x2A
 , which are interpr eted while the string’s value is being composed. The 
 most common regex-r elated aspect of this is that each backslash in a regex requir es two 
 backslashes in the correspond-ing string literal. For example,
  ""\\n""
  is requir ed to get the 
 regex
  !\n""
 .
  
 If you forgot the extra backslash for the string literal and used
  ""\n""
 , with many languages 
 you’d then get
  !1 ""
 , which just happens to do exactly the same thing as 
 !\n""
 . Well, actually, if 
 the regex is in an
  /x
  type of free-spacing mode,
  !1 ""
  becomes empty, while
  !\n""
  remains a 
 regex to match a newline. So, you can get bitten if you forget. Table 3-4 on the next page 
 shows a few examples involving
  \t
  and
  \x2A 
 (
 2A
  is the
  ASCII
  code for ‘
 +
 ’.) The second pair 
 of examples in the table show the unintended results when the string-literal metacharacters 
 aren’t taken into account.
  
 Every language’s string literals are dif ferent, but some are quite differ ent in that ‘
 \
 ’is not a 
 metacharacter. For example. VB.NET’s string literals have only one
  
 29 April 2003 09:19",NA
Character-Encoding Issues,"A character encoding is merely an explicit agreement on how bytes with various values 
 should be interpreted. A byte with the decimal value 110 is interpreted as the character ‘
 n
 ’ 
 with the
  ASCII
  encoding, but as ‘
 >
 ’ with
  EBCDIC
 . Why? Because that’s what someone 
 decided
  —
  ther e’s nothing intrinsic about those values and characters that makes one 
 encoding better than the other. The byte is the same; only the interpretation changes.
  
 ASCII
  defines characters for only half the values that a byte can hold. The encoding 
 ISO-
 8859-1
  (commonly called
  Latin-1
  ) fills in the blank spots with accented char-acters and 
 special symbols, making an encoding usable by a larger set of lan-guages. With this encoding, 
 a byte with a decimal value of 234 is to be interpreted as
  ê
 , instead of being undefined as it is 
 with
  ASCII
 .
  
 The important question for us is this: when we
  intend
  for a certain set of bytes to be
  consider ed
  
 in the light of a particular encoding, does the program actually treat them that way? For 
 example, if we have four bytes with the values 234, 116, 101, and 115 that we intend to be 
 considered as Latin-1 (repr esenting the French word“êtes”), we’d like the regex
  !ˆ\w+$""
  or
  
 !ˆ\b""
  to match. This happens if the program’s 
 \w
  and
  \b
  know to treat those bytes as Latin-1 
 characters, and probably doesn’t happen otherwise.
  
 Richness of encoding-related support
  
 Ther e ar e many encodings. When you’re concer ned with a particular one, impor-tant 
 questions you should ask include:
  
 •
  Does the program understand this encoding?
  
 •
  How does it know to treat this data as being of that encoding?
  
 •
  How rich is the regex support for this encoding?
  
 29 April 2003 09:19",NA
Regex Modes and Match Modes,"Most regex engines support a number of differ ent modes for how a regular expr ession is 
 interpreted or applied. We’ve seen an example of each with Perl’s
  /x 
 modifier (regex mode 
 that allows free whitespace and comments 72) and
  /i 
 modifier (match mode for case-
 insensitive matching 47).
  
 Modes can generally be applied globally to the whole regex, or in many modern flavors, 
 partially, to specific subexpressions of the regex. The global application is achieved through 
 modifiers or options, such as Perl’s
  /i
  or
  java.util.regex
 ’s 
 Pattern.CASERINSENSITIVE
  flag ( 98). 
 If supported, the partial application of a mode is achieved with a regex construct that looks 
 like
  !(?i)""
  to turn on case-in-sensitive matching, or
  !(?-i)""
  to turn it off. Some flavors also 
 support
  !(?i:
 ˙˙˙
 )""
  and 
 !(?-i:
 ˙˙˙
 )""
 , which turn on and off case-insensitive matching for the 
 subexpression enclosed.
  
 How these modes are invoked within a regex is discussed later in this chapter ( 133). In this 
 section, we’ll merely review some of the modes commonly avail-able in most systems.
  
 Case-insensitive match mode
  
 The almost ubiquitous case-insensitive match mode ignores letter case during matching, so 
 that
  !b""
  matches both ‘
 b
 ’ and ‘
 B
 ’. This feature relies upon proper char-acter encoding 
 support, so all the cautions mentioned earlier apply.
  
 Historically, case-insensitive matching support has been surprisingly fraught with bugs. Most 
 have been fixed over the years, but some still linger. As we saw in the first chapter,
  GNU
  egr 
 ep
 ’s case-insensitive matching doesn’t apply to backrefer-ences. Ruby’s case-insensitive 
 matching doesn’t apply to octal and hex escapes.
  
 Ther e ar e special Unicode-related issues with case-insensitive matching (which Unicode 
 calls “loose matching” ). For starters, not all alphabets have the concept of upper and lower 
 case, and some have an additional
  title case
  used only at the start
  
 29 April 2003 09:19",NA
Common Metacharacter s and Features,"The following overview of current regex metacharacters covers common items and 
 concepts. It doesn’t discuss every issue, and no one tool includes everything pre-sented here. 
 In one respect, this is just a summary of much of what you’ve seen in the first two chapters, 
 but in light of the wider, mor e complex world presented at the beginning of this chapter. 
 During your first pass through this section, a light glance should allow you to continue on to 
 the next chapters. You can come back her e to pick up details as you need them.
  
 Some tools add a lot of new and rich functionality and some gratuitously change common 
 notations to suit their whim or special needs. Although I’ll sometimes comment about 
 specific utilities, I won’t address too many tool-specific concerns her e. Rather, in this 
 section I’ll just try to cover some common metacharacters and their uses, and some concerns 
 to be aware of. I encourage you to follow along with the manual of your favorite utility.
  
 † Tcl normally lets its dot match everything, so in one sense it’s more straightforward than other lan-guages. In Tcl 
 regular expressions, newlines are not normally treated specially in any way (neither to dot nor to the line anchors), 
 but by using match modes, they become special. However, since other systems have always done it another way, 
 Tcl could be considered confusing to those used to those other ways.
  
 29 April 2003 09:19",NA
Character Representations,"This group of metacharacters provides visually pleasing ways to match specific characters 
 that are otherwise difficult to repr esent.
  
 Character shorthands
  
 Many utilities provide metacharacters to repr esent certain control characters that ar e 
 sometimes machine-dependent, and which would otherwise be difficult to input or to 
 visualize:
  
 \a 
  
 Aler t (e.g., to sound the bell when “printed”) Usually maps to the
  ASCII 
  
 <BEL>
  
 character,
  007
  octal.
  
 \b 
  
 Backspace Usually maps to the
  ASCII
  <BS>
  character,
  010
  octal. (Note
  !\b 
  
 often is a 
 word-boundary metacharacter instead, as we’ll see later.)
  
 \e 
  
 Escape character Usually maps to the
  ASCII
  <ESC>
  character,
  033
  octal.
  
 \f 
  
 Form feed Usually maps to the
  ASCII
  <FF>
  character,
  014
  octal.
  
 \n 
  
 Newline On most platforms (including Unix and
  DOS
 /Windows), usually 
  
 maps to 
 the
  ASCII
  <LF>
  character,
  012
  octal. On Mac
 OS
  systems, usually 
  
 maps to the
  ASCII
  
 <CR>
  character,
  015
  octal. With Java or any .
 NET
  lan-
  
 guage, always the
  ASCII
  
 <LF>
  character regardless of platform.
  
 \r 
  
 Car ria ge retur n Usually maps to the
  ASCII
  <CR>
  character. On Mac
 OS
  sys-
  
 tems, usually maps to the
  ASCII
  <LF>
  character. With Java or any .
 NET
  lan-
  
 guage, 
 always the
  ASCII
  <CR>
  character regardless of platform.
  
 \t 
  
 Nor mal (hor izontal) ta b Usually maps to the
  ASCII
  <HT>
  character,
  011 
  
 octal.
  
 \v 
  
 Vertical tab Usually maps to the
  ASCII
  <VT>
  character,
  013
  octal.
  
 Table 3-6 lists a few common tools and some of the character shorthands they pro-vide. As 
 discussed earlier, some languages also provide many of the same short-hands for the string 
 literals they support. Be sure to review that section ( 101) for some of the associated pitfalls.
  
 These are machine dependent?
  
 As noted in the list,
  \n
  and
  \r
  ar e operating-system dependent in many tools,
 †
 so, it’s best to 
 choose carefully when you use them. When you need, for example, “a
  
 † If the tool itself is written in C or C
 ++
 , and converts its regex backslash escapes into C backslash escapes, the 
 resulting value is dependent upon the compiler used, since the C standard leaves the actual values to the 
 discretion of the compiler vendor. In practice, compilers for any particular plat-for m ar e standardized around 
 newline support, so it’s safe to view these as
  operating-system depen-dent
 . Further more, it seems that only
  \n
  and
  \r
  
 vary across operating systems , so the others can be consider ed standard across all systems.
  
 29 April 2003 09:19",NA
Character Classes and Class-Like Constr ucts,"Moder n flavors provide a number of ways to specify a set of characters allowed at a 
 particular point in the regex, but the simple character class is ubiquitous.
  
 Nor mal classes:
  [a-z]
  and
  [ˆa-z]
  
 The basic concept of a character class has already been well covered, but let me emphasize 
 again that the metacharacter rules change depending on whether you’r e in a character class 
 or not. For example,
  !+""
  is never a metacharacter within a class, while
  !-""
  usually is. Some 
 metasequences, such as
  !\b""
 , sometimes have a dif ferent meaning within a class than outside 
 of one ( 115).
  
 29 April 2003 09:19",NA
Anchor s and Other “Zero-Width Assertions”,"Anchors and other “zero-width assertions” don’t match actual text, but rather
  posi-tions
  in the 
 text.
  
 Star t of line/string:
  ˆ
 ,
  \A
  
 Car et
  !ˆ""
  matches at the beginning of the text being searched, and, if in an enhanced line-
 anchor match mode ( 111), after any newline. In some systems, an enhanced-mode
  !ˆ""
  can 
 match after Unicode line terminators, as well ( 108).
  
 When supported,
  !\A""
  always matches only at the start of the text being searched, regardless 
 of any match mode.
  
 End of line/string:
  $
 ,
  \Z
 ,
  \z
  
 As Table 3-11 on the next page shows, the concept of “end of line” can be a bit mor e 
 complex than its start-of-line counterpart.
  !$""
  has a variety of meanings among differ ent 
 tools, but the most common meaning is that it matches at the end of the target string, and 
 before a
  string-ending
  newline, as well. The latter is com-mon, to allow an expression like
  !s$""
  
 (ostensibly, to match “a line ending with
  s
 ”) to match ‘
 ˙˙˙
 s1
 ’, a line ending with
  s
  that’s capped 
 with an ending newline.
  
 29 April 2003 09:19",NA
Advanced Use of,NA,NA
 \G,NA,NA
 with Perl,"Her e’s the outline of a snippet that perfor ms simple validation on the
  HTML 
 in the 
 variable
  $html
 , ensuring that it contains constructs from among only a very limited 
 subset of
  HTML
  (simple
  <IMG>
  and
  <A>
  tags are allowed, as well as simple entities like
  
 &gt;
 ). I’ve used this method at Yahoo!, for example, to validate that a user’s
  HTML
  
 submission met certain guidelines.
  
 This code relies heavily on the behavior of Perl’s
  m/
 ˙˙˙
 /gc
  match operator, which 
 applies the regular expression to the target string once, picking up fr om wher e the 
 last successful match left off, but
  not
  resetting that position if it fails ( 315).
  
 Using this feature, the various expressions used below all “tag team” to work their way 
 through the string. It’s similar in theory to having one big alterna-tion with all the 
 expressions, but this approach allows program code to be executed with each match, 
 and to include or exclude expressions on the fly.
  
 my $needRcloseRanchor = 0; #
  True if we’ve seen <A>, but not its closing </A>.
  
 while (not $html =˜ m/\G\z/gc) #
  While we haven’t worked our way to the end . . .
  
 { 
  
 if ($html =˜ m/
 \G(\w+)
 /gc) { 
  
   
 . . . have a word or number in $1 -- can now check for profanity, for example . . .
  
 } elsif ($html =˜ m/
 \G[ˆ<>&\w]+
 /gc) { 
  
 #
  Other non-HTML stuff -- simply allow it.
  
 } elsif ($html =˜ m/
 \G<img\s+([ˆ>]+)>
 /gci) { 
  
 . . . 
 have an image tag -- can check that it’s appropriate . . .
  
  
 + 
  
  
 + 
  
  
 + 
  
 } elsif (not $needRcloseRanchor and $html =˜ m/
 \G<A\s+([ˆ>]+)>
 /gci) { 
  
 . . . have a link anchor — 
 can validate it . . .
  
  
 + 
  
  
 + 
  
  
 + 
  
 $needRcloseRanchor = 1; #
  Note that we now need </A> 
  
 } elsif ($needRcloseRanchor and $html =˜ m{
 \G</A>
 }gci){ 
  
 $needRcloseRanchor = 0; #
  Got what we needed; don’t allow again 
  
 } elsif ($html =˜ m/
 \G&(#\d+
 <
 \w+);
 /gc){ 
  
 #
  Allow entities like &gt; and &#123; 
  
 } else { 
  
 #
  Nothing matched at this point, so it must be an error. Note the locationn, and grab a dozen or so 
 #
  characters from the HTML 
 so that we can issue an informative error message.
  
 my $location = pos($html); #
  Note where the unexpected HTML starts.
  
  
 my ($badstuff) = $html =˜ m/
 \G(.{1,12})
 /; 
  
  
 die ""Unexpected HTML at position $location: $badstuff\n""; } 
  
 }
  
 #
  Make sure ther e’s no dangling <A> 
  
 if ($needRcloseRanchor) { 
  
  
 die ""Missing final </A>"" 
  
 }
  
 29 April 2003 09:19",NA
Comments and Mode Modifier s,"With many flavors, the regex modes and match modes described earlier ( 109) can be 
 modified within the regex (on the fly, so to speak) by the following constructs.
  
 Mode modifier:
  (?
 modifier
 )
 , such as
  (?i)
  or
  (?-i)
  
 Many flavors now allow some of the regex and match modes ( 109) to be set within the 
 regular expression itself. A common example is the special notation 
 !(?i)""
 , which turns on 
 case-insensitive matching, and
  !(?-i)""
 , which turns it off. For example,
  !<B>(?i)very(?-i)</B>""
  
 has the
  !very""
  part match with case insensitiv-ity, while still keeping the tag names case-
 sensitive. This matches ‘
 <B>VERY</B>
 ’and ‘
 <B>Very</B>
 ’, for example, but not 
 ‘
 <b>Very</b>
 ’.
  
 This example works with most systems that support 
  
 !(?i)""
 , including Perl, 
 java.util.regex
 , Ruby, and the .
 NET
  languages. But, some systems have differ-ent semantics. 
 With Python, for example, the appearance of
  !(?i)""
  anywher e in the regex turns on case-
 insensitive matching for the entire regex, and Python doesn’t support turning it off with
  !(?-
 i)""
 . Tcl’s case-insensitive matching is also all-or-nothing, but Tcl requir es the
  !(?i)""
  to be at 
 the beginning of the regex
  —
  anywher e else is an error. Ruby has a bug whereby sometimes
  
 !(?i)""
  doesn’t apply to
  !;""
 -sepa-rated alternatives that are lowercase (but does if they’re 
 uppercase).
  PHP
  has the special case that if
  !(?i)""
  is used outside of all parentheses, it applies 
 to the entire regex. So, in
  PHP
 , we’d have to write our example with an extra set of 
 “constrain-ing” parentheses:
  !<B>
 (?:
 (?i)very(?-i)
 )
 </B>""
 .
  
 Actually, that last
  PHP
  example can be simplified a bit because with many imple-mentations 
 (including
  PHP
 ’s), when
  !(?i)""
  is used within any type of parentheses, its effects are limited by 
 the parentheses (i.e., turn off at the closing parentheses). So, the
  !(?-i)""
  can simply be 
 eliminated:
  !<B>
 (?:
 (?i)very
 )
 </B>""
 .
  
 29 April 2003 09:19",NA
"Grouping, Capturing, Conditionals, and Control","Captur ing/Grouping Parentheses:
  (
 ˙˙˙
 )
  and
  \1
 ,
  \2
 , ...
  
 Common, unadorned parentheses generally perfor m two functions, grouping and capturing. 
 Common parentheses are almost always of the form
  !(
 ˙˙˙
 )""
 , but a few fla-vors use
  !\(
 ˙˙˙
 \)""
 . 
 These include
  GNU
  Emacs, sed,
  vi
 , and
  gr ep
 .
  
 Capturing parentheses are number ed by counting their opening parentheses from the left, as 
 shown in figures on pages 41, 43, and 57. If
  backr efer ences
  ar e avail-able, the text matched 
 via an enclosed subexpression can itself be matched later in the same regular expression with
  
 !\1""
 ,
  !\2""
 , etc.
  
 One of the most common uses of parentheses is to pluck data from a string. The text 
 matched by a parenthesized subexpression (also called “the text matched by the 
 parentheses”) is made available after the match in differ ent ways by differ ent pr ograms, 
 such as Perl’s
  $1
 ,
  $2
 , etc. (A common mistake is to try to use the
  !\1 
 syntax
  outside
  the regular 
 expression; something allowed only with sed and
  vi
 .)
  
 Table 3-14 on the next page shows how a number of programs make the captured text 
 available after a match. It shows how to access the text matched by the whole expr ession, 
 and the text matched by a set of capturing parentheses.
  
 29 April 2003 09:19",NA
Guide to the Advanced Chapters,"Now that we’re familiar with metacharacters, flavors, syntactic packaging, and the like, it’s 
 time to start getting into the nitty-gritty details of the third concern raised at the start of this 
 chapter, the specifics of how a tool’s regex engine goes about applying a regex to some text. 
 In Chapter 4,
  The Mechanics of Expression Process-ing
 , we see how the implementation of the 
 match engine influences
  whether
  a match is achieved,
  which
  text is matched, and
  how much time
  
 the whole thing takes. We’ll look at all the details. As a byproduct of this knowledge, you’ll 
 find it much easier to craft complex expressions with confidence. Chapter 5,
  Practical Regex 
 Techniques
  helps to solidify that knowledge with extended examples.
  
 That brings us to Chapter 6,
  Crafting an Efficient Expression
 . Once you know the basics about 
 how an engine works, you can learn techniques to take full advan-tage of that knowledge. 
 Chapter 6 looks at regex pitfalls that often lead to unwel-come surprises, and turns the tables 
 to put them to use for us.
  
 Chapters 4, 5, and 6 are the central core of this book. These first three chapters mer ely lead 
 up to them, and the discussions in the tool-specific chapters that fol-low rely on them. 
 They’re not necessarily what you would call “light reading,” but I’ve taken great care to stay 
 away from math, algebra, and all that stuff that’s just mumbo-jumbo to most of us. As with 
 any large amount of new information, it likely takes time to sink in and internalize.
  
 29 April 2003 09:19",NA
4,NA,NA
The Mechanics ,NA,NA
of Expression ,NA,NA
Processing,"The previous chapter started with an analogy between cars and regular expres-sions. The 
 bulk of the chapter discussed features, regex flavors, and other “glossy br ochure” issues of 
 regular expressions. This chapter continues with that analogy, talking about the all-important 
 regular-expr ession engine, and how it goes about its work.
  
 Why would you care how it works? As we’ll see, there are several types of regex engines, and 
 the type most commonly used
  —
  the type used by Perl, Tcl, Python, the .
 NET
  languages, 
 Ruby,
  PHP
 , all Java packages I’ve seen, and more
  —
  works in such a way that
  how
  you craft 
 your expression can influence
  whether
  it can match a particular string,
  wher e
  in the string it 
 matches, and
  how quickly
  it finds the match or reports the failure. If these issues are important 
 to you, this chapter is for you.",NA
Star t Your Engines!,"Let’s see how much I can milk this engine analogy. The whole point of having an engine is 
 so that you can get from Point A to Point B without doing much work. The engine does the 
 work for you so you can relax and enjoy the sound system. The engine’s primary task is to 
 turn the wheels, and how it does that isn’t really a concer n of yours. Or is it?
  
 143
  
 29 April 2003 09:21",NA
Tw o Kinds of Engines,"Well, what if you had an electric car? They’ve been around for a long time, but they aren’t as 
 common as gas cars because they’re hard to design well. If you had one, though, you would 
 have to remember not to put gas in it. If you had a gaso-line engine, well, watch out for 
 sparks! An electric engine more or less just runs, but a gas engine might need some 
 babysitting. You can get much better perfor-mance just by changing little things like your 
 spark plug gaps, air filter, or brand of gas. Do it wrong and the engine’s perfor mance 
 deteriorates, or, worse yet, it stalls.
  
 Each engine might do its work differ ently, but the end result is that the wheels tur n. You 
 still have to steer properly if you want to get anywhere, but that’s an entir ely dif ferent issue.",NA
New Standards,"Let’s stoke the fire by adding another variable: the California Emissions Standards.
 †
 Some 
 engines adhere to Califor nia’s strict pollution standards, and some engines don’t. These 
 aren’t really differ ent kinds of engines, just new variations on what’s alr eady ar ound. The 
 standard regulates a result of the engine’s work, the emis-sions, but doesn’t say anything 
 about how the engine should go about achieving those cleaner results. So, our two classes of 
 engine are divided into four types: electric (adhering and non-adhering) and gasoline 
 (adhering and non-adhering).
  
 Come to think of it, I bet that an electric engine can qualify for the standard with-out much 
 change
  —
 the standard just “blesses” the clean results that are alr eady par for the course. 
 The gas engine, on the other hand, needs some major tweaking and a bit of re-tooling before 
 it can qualify. Owners of this kind of engine need to pay particular care to what they feed it
  
 —
  use the wrong kind of gas and you’re in big trouble.
  
 The impact of standards
  
 Better pollution standards are a good thing, but they requir e that the driver exer-cise more 
 thought and foresight (well, at least for gas engines). Frankly, however, the standard doesn’t 
 impact most people since all the other states still do their own thing and don’t follow 
 California’s standard.
  
 So, you realize that these four types of engines can be classified into three groups (the two 
 kinds for gas, and electric in general). You know about the differ ences, and that in the end 
 they all still turn the wheels. What you don’t know is what the heck this has to do with 
 regular expressions! More than you might imagine.
  
 † Califor nia has rather strict standards regulating the amount of pollution a car can produce. Because 
  
 of this, 
 many cars sold in America come in “California” and “non-California” models.
  
 29 April 2003 09:21",NA
Regex Eng ine Types,"Ther e ar e two fundamentally differ ent types of regex engines: one called “
 DFA
 ”(the 
 electric engine of our story) and one called “
 NFA
 ” (the gas engine). The details of what
  NFA
  
 and
  DFA
  mean follow shortly ( 156), but for now just con-sider them names, like Bill and 
 Ted. Or electric and gas.
  
 Both engine types have been around for a long time, but like its gasoline counter-part, the
  
 NFA
  type seems to be used more often. Tools that use an
  NFA
  engine include the .
 NET
  
 languages, Ruby, Perl, Python,
  GNU
  Emacs,
  ed
 , sed,
  PHP
 ,
  vi
 , most versions of
  gr ep
 , and even 
 a few versions of
  egr ep
  and awk. On the other hand, a 
 DFA
  engine is found in almost all 
 versions of
  egr ep
  and awk, as well as
  lex
  and 
 flex
  . Some systems have a multi-engine hybrid 
 system, using the most appropriate engine for the job (or even one that swaps between 
 engines for differ ent parts of the same regex, as needed to get the best combination of 
 features and speed). Ta-ble 4-1 lists a few common programs and the regex engine that most 
 versions use. If your favorite program is not in the list, the section “Testing the Engine 
 Type” on the next page can help you find out which it is.
  
 Table 4-1: Some Tools and Their Regex Engines
  
 Eng ine type 
  
 Programs
  
 DFA
  
 awk
  (most versions)
 ,
  egr ep
  (most versions)
 , flex, lex, MySQL, Procmail
  
 Traditional
  NFA
  
 GNU
  Emacs, Java,
  gr ep
  (most versions)
 ,
  less
 ,
  mor e
 , .
 NET
  languages, 
 PCRE
  
 library, Perl,
  PHP (pcr e routines)
 , Python, Ruby, 
  
 sed
  (most versions)
 ,
  vi
  
 POSIX NFA
  
 mawk
 , Mortice Kern Systems’ utilities,
  GNU
  Emacs
  (when requested)
  
 Hybrid
  NFA
 /
 DFA
  
 GNU
  awk,
  GNU
  gr ep
  /
 egr ep
 , Tcl
  
 As Chapter 3 illustrated, 20 years of development with both
  DFA
 s and
  NFA
 s resulted in a lot 
 of needless variety. Things were dirty. The
  POSIX
  standard came in to clean things up by 
 clearly specifying not only which metacharacters and fea-tur es an engine should support, as 
 mentioned in the previous chapter, but also 
 exactly the results you could expect from them
 . Super 
 ficial details aside, the
  DFA
 s (our electric engines) were alr eady well suited to adhere to this 
 new standard, but the kind of results an
  NFA
  traditionally provided were dif ferent, so 
 changes were needed. As a result, broadly speaking, there are thr ee types of regex engines:
  
 •
  DFA
  (
 POSIX
  or not
 —
 similar either way)
  
 •
  Traditional
  NFA
  (most common: Perl, .
 NET
 , Java, Python, . . . )
  
 •
  POSIX NFA
  
 Her e, we use “
 POSIX
 ” to refer to the match
  semantics
  —
  the expected operation of a regex 
 that the
  POSIX
  standard specifies (which we’ll get to later in this chapter). Don’t confuse this 
 use of “
 POSIX
 ” with uses surrounding regex
  featur es
  intr oduced
  
 29 April 2003 09:21",NA
Fr om the Depar tment of Redundancy Depar tment,"At this point, I’ll ask you to go back and review the story about engines. Every sentence 
 there rings with some truth about regular expressions. A second reading should raise some 
 questions. Particularly, what does it mean that an electric
  DFA 
 regex engine more or less 
 “just runs?” What affects a gas-powered
  NFA
 ? How can I tune my regular expressions to run 
 as I want on an
  NFA
 ? What special concerns does an emissions-controlled
  POSIX NFA
  have? 
 What’s a “stalled engine” in the regex world?",NA
Testing the Engine Type,"Because the type of engine used in a tool influences the type of features it can of fer, and 
 how those features appear to work, we can often learn the type of engine a tool has merely 
 by checking to see how it handles a few test expressions. (After all, if you can’t tell the differ 
 ence, the differ ence doesn’t matter.) At this point in the book, I wouldn’t expect you to 
 understand why the following test results indicate what they do, but I want to offer these 
 tests now so that if your favorite tool is not listed in Table 4-1, you can investigate before 
 continuing with this and the subsequent chapters.
  
 Tr aditional
  NFA
  or not?
  
 The most commonly used engine is a Traditional
  NFA
 , and spotting it is easy. First, ar e lazy 
 quantifiers ( 140) supported? If so, it’s almost certainly a Traditional
  NFA
 . As we’ll see, lazy 
 quantifiers are not possible with a
  DFA
 , nor would they make any sense with a
  POSIX NFA
 . 
 However, to make sure, simply apply the regex 
 !nfa;nfa not""
  to the string ‘
 nfa not
 ’
  —
  if only 
 ‘
 nfa
 ’ matches, it’s a Traditional
  NFA
 . If the entire ‘
 nfa not
 ’ matches, it’s either a
  POSIX NFA
  
 or a
  DFA
 .
  
 29 April 2003 09:21",NA
Match Basics,"Befor e looking at the differ ences among these engine types, let’s first look at their 
 similarities. Certain aspects of the drive train are the same (or for all practical pur-poses 
 appear to be the same), so these examples can cover all engine types.",NA
About the Examples,"This chapter is primarily concerned with a generic, full-function regex engine, so some tools 
 won’t support exactly everything presented. In my examples, the dip-stick might be to the 
 left of the oil filter, while under your hood it might be behind the distributor cap. Your goal 
 is to understand the concepts so that you can drive and maintain your favorite regex package 
 (and ones you find interest in later).
  
 I’ll continue to use Perl’s notation for most of the examples, although I’ll occasion-ally show 
 others to remind you that the
  notation
  is superficial and that the issues under discussion 
 transcend any one tool or flavor. To cut down on wordiness her e, I’ll rely on you to check 
 Chapter 3 ( 113) if I use an unfamiliar construct.
  
 This chapter details the practical effects of how a match is carried out. It would be nice if 
 everything could be distilled down to a few simple rules that could be memorized without 
 needing to understand what is going on. Unfortunately, that’s not the case. In fact, with all 
 this chapter offers, I identify only two all-encompass-ing rules:
  
 1
 . The match that begins earliest (leftmost) wins.
  
 2
 . The standard quantifiers (
 !+""
 ,
  !+""
 ,
  !?""
 , and
  !{m,n}""
  ) are greedy.
  
 We’ll look at these rules, their effects, and much more thr oughout this chapter. Let’s start by 
 diving into the details of the first rule.
  
 29 April 2003 09:21",NA
Rule 1: The Match That Begins Earliest Wins,"This rule says that any match that begins earlier (leftmost) in the string is always pr eferr ed 
 over any plausible match that begins later. This rule doesn’t say anything about how long the 
 winning match might be (we’ll get into that shortly), merely that among all the matches 
 possible anywhere in the string, the one that begins leftmost in the string is chosen. Actually, 
 since more than one plausible match can start at the same earliest point, perhaps the rule 
 should read “
 a
  match...” instead of“
 the
  match...,” but that sounds odd.
  
 Her e’s how the rule comes about: the match is first attempted at the very begin-ning of the 
 string to be searched (just before the first character). “Attempted”means that every 
 permutation of the entire (perhaps complex) regex is tested start-ing right at that spot. If all 
 possibilities are exhausted and a match is not found, the complete expression is re-tried 
 starting from just before the second character. This full retry occurs at each position in the 
 string until a match is found. A “no match” result is reported only if no match is found after 
 the full retry has been attempted at each position all the way to the end of the string (just 
 after the last character).
  
 Thus, when trying to match
  !ORA""
  against
  FLORAL
 , the first attempt at the start of the string 
 fails (since
  !ORA""
  can’t match
  FLO
 ). The attempt starting at the second charac-ter also fails (it 
 doesn’t match
  LOR
  either). The attempt starting at the third posi-tion, however, does match, 
 so the engine stops and reports the match:
  FLORAL
 .
  
 If you didn’t know this rule, results might sometimes surprise you. For example, when 
 matching
  !cat""
  against
  
 The dragging belly indicates your cat is too fat
  
 the match is in
  indicates
 , not at the word
  cat
  that appears later in the line. This
  
 word
  cat
  could
  match, but the
  cat
  in
  indi
 cat
 es
  appears earlier in the string, so it is the one 
 matched. For an application like
  egr ep
 , the distinction is irrelevant because it cares only
  
 whether
  ther e is a match, not
  wher e
  the match might be. For other uses, such as with a search-
 and-r eplace, the distinction becomes paramount.
  
 Her e’s a (hopefully simple) quiz: where does
  !fat;cat;belly;your""
  match in the string ‘
 The 
 dragging belly indicates your cat is too fat
 ’?
  O
  Turn the page to check your answer.
  
 The “transmission” and the bump-along
  
 It might help to think of this rule as the car’s transmission, connecting the engine to the 
 drive train while adjusting for the gear you’re in. The engine itself does the real work (turning 
 the crank); the transmission transfers this work to the wheels.
  
 29 April 2003 09:21",NA
Eng ine Pieces and Par ts,"An engine is made up of parts of various types and sizes. You can’t possibly hope to truly 
 understand how the whole thing works if you don’t know much about the individual parts. 
 In a regex, these parts are the individual units
  —
  literal characters, quantifiers (star and 
 friends), character classes, parentheses, and so on, as described in Chapter 3 ( 113). The 
 combination of these parts (and the engine’s tr eatment of them) makes a regex what it is, so 
 looking at ways they can be com-bined and how they interact is our primary interest. First, 
 let’s take a look at some of the individual parts:
  
 Literal text (e.g.,
  
 a
  
 \+
  
 !
  
 M
  ... )
  
 With a literal, non-metacharacter like
  !z""
  or
  !!""
 , the match attempt is simply“Does this 
 literal character match the current text character?” If your regex is only literal text, such 
 as
  !usa""
 , it is treated as “
  !u""
  and then
  !s""
  and then
  !a""
 . ”  It’s a bit more complicated if 
 you have the engine do a case-insensitive match, wher e
  !b""
  matches
  B
  and vice-versa, 
 but it’s still pretty straightforward. (With Unicode, there are a few additional twists 
 109.)
  
 Character classes, dot, Unicode proper ties, and the like 
  
 Matching dot, character classes, Unicode properties, and the like ( 117) is usually a 
 simple matter: regardless of the length of the character class, it still matches just one 
 character.
 †
  
 Dot is just a shorthand for a large character class that matches almost any character ( 
 110), so its actions are simple, as are the other shorthand conve-niences such as
  !\w""
 ,
  
 !\W""
 , and
  !\d""
 .
  
 Captur ing parentheses 
  
 Par entheses used only for capturing text (as opposed to those used for gr ouping) 
 don’t change how the match is carried out.
  
 † Actually, as we saw in the previous chapter ( 126), a
  POSIX
  collating sequence
  can
  match multiple characters, but 
 this is not common. Also, certain Unicode characters can match multiple characters when applied in a case-
 insensitive manner ( 109), although most implementations do not sup-port this.
  
 29 April 2003 09:21",NA
Quiz Answer,"O
 Answer to the question on page 148.
  
 Remember, the regex is tried
  completely
  each time, so
  !fat;cat;belly;your 
 matches ‘
 The 
 dragging belly indicates your cat is too fat
 ’ rather than
  fat
 , even though
  !fat""
  is listed 
 first among the alternatives.
  
 Sur e, the regex could conceivably match
  fat
  and the other alternatives, but since they 
 are not the
  earliest
  possible match (the match starting furthest to the left), they are not 
 the one chosen. The entire regex is attempted com-pletely from one spot before 
 moving along the string to try again from the next spot, and in this case that means 
 trying each alternative
  !fat""
 ,
  !cat""
 , 
 !belly""
 , and
  !your""
  at each position before moving 
 on.
  
 Anchor s (e.g.,
  
 !ˆ
  
 !\Z
  
 !(?<=\d)""
  ... )
  
 Ther e ar e two basic types of anchors: simple ones (
 ˆ
 ,
  $
 ,
  \G
 ,
  \b
 , ... 127) and complex 
 ones (lookahead and lookbehind 132). The simple ones are indeed simple in that they 
 test either the quality of a particular location in the target string (
 ˆ
 ,
  \Z
 , ...), or compare 
 two adjacent characters (
 \<
 ,
  \b
 , ...). On the other hand, the lookaround constructs can 
 contain arbitrary sub-expres-sions, and so can be arbitrarily complex.
  
 No “electric” parentheses, backreferences, or lazy quantifier s
  
 I’d like to concentrate here on the similarities among the engines, but as foreshad-owing of 
 what’s to come in this chapter, I’ll point out a few interesting differ ences. Capturing 
 parentheses (and the associated backrefer ences and
  $1
  type functional-ity) are like a gas 
 additive
  —
  they affect a gasoline (
 NFA
 ) engine, but are irr elevant to an electric (
 DFA
 ) 
 engine. The same thing applies to lazy quantifiers. The way a 
 DFA
  engine works completely 
 precludes these concepts.
 †
 This explains why tools developed with
  DFA
 s don’t provide these 
 features. You’ll notice that awk,
  lex
 , and 
 egr ep
  don’t have backrefer ences or any
  $1
  type 
 functionality.
  
 You might, however, notice that
  GNU
 ’s version of
  egr ep
  does support backrefer-ences. It 
 does so by having two complete engines under the hood! It first uses a 
 DFA
  engine to see 
 whether a match is likely, and then uses an
  NFA
  engine (which supports the full flavor, 
 including backrefer ences) to confirm the match. Later in this chapter, we’ll see why a
  DFA
  
 engine can’t deal with backrefer ences or captur-ing, and why anyone ever would want to use 
 such an engine at all. (It has some major advantages, such as being able to match very 
 quickly.)
  
 † This does not mean that there can’t be some mixing of technologies to try to get the best of both 
  
 worlds. 
 This is discussed in a sidebar on page 183.
  
 29 April 2003 09:21",NA
Rule 2: The Standard Quantifier s Are Greedy,"So far, we have seen features that are quite straightforward. They are also rather boring
  —
  
 you can’t
  do
  much without involving more-power ful metacharacters such as star, plus, 
 alternation, and so on. Their added power requir es mor e infor mation to understand them 
 fully.
  
 First, you need to know that the standard quantifiers (
 ?
 ,
  +
 ,
  +
 , and
  {
 min
 ,
 max
 }
 ) are 
 gr eedy
 . When 
 one of these governs a subexpression, such as
  !a""
  in
  !a?""
 , the
  !(
 expr
 ) 
 in
  !(
 expr
 )+""
 , or
  ![0-9]""
  in
  
 ![0-9]+""
 , ther e is a minimum number of matches that are requir ed befor e it can be 
 considered successful, and a maximum number that it will ever attempt to match. This has 
 been mentioned in earlier chapters
  —
  what’s new here concer ns the rule that they always 
 attempt to match as much as possi-ble. (Some flavors provide other types of quantifiers, but 
 this section is concerned only with the standard, greedy ones.)
  
 To be clear, the standard quantifiers settle for something less than the maximum number of 
 allowed matches
  if they have to
 , but they always attempt to match as many times as they can, 
 up to that maximum allowed. The only time they settle for anything less than their maximum 
 allowed is when matching too much ends up causing some later part of the regex to fail. A 
 simple example is using 
 !\b
 \w+
 s\b""
  to match words ending with an ‘
 s
 ’, such as ‘
 regexes
 ’. 
 The
  !\w+""
  alone is happy to match the entire word, but if it does, it leaves nothing for the
  !s""
  
 to match. To achieve the overall match, the
  !\w+""
  must settle for matching only‘
 regexes
 ’, 
 thereby allowing
  !s\b""
  (and thus the full regex) to match.
  
 If it turns out that the only way the rest of the regex can succeed is when the gr eedy 
 construct in question matches nothing, well, that’s perfectly fine, if zero matches are allowed 
 (as with star, question, and
  {0,
 max
 }
  intervals). However, it tur ns out this way only if the requir 
 ements of some later subexpression force the issue. It’s because the greedy quantifiers always 
 (or, at least, try to) take more than they minimally need that they are called greedy.
  
 Gr eediness has many useful (but sometimes troublesome) implications. It explains, for 
 example, why
  ![0-9]+""
  matches the full number in
  March 1998
 . Once the ‘
 1
 ’has been 
 matched, the plus has fulfilled its minimum requir ement, but it’s greedy, so it doesn’t stop. 
 So, it continues, and matches the ‘
 998
 ’ befor e being forced to stop by the end of the string. 
 (Since
  ![0-9]""
  can’t match the nothingness at the end of the string, the plus finally stops.)
  
 A subjective example
  
 Of course, this method of grabbing things is useful for more than just numbers. Let’s say 
 you have a line from an email header and want to check whether it is the subject line. As we 
 saw in earlier chapters ( 55), you simply use
  !ˆSubject:""
 .
  
 29 April 2003 09:21",NA
Regex-Directed Ver sus Te xt-Directed,"The two basic engine types reflect a fundamental differ ence in algorithms available for 
 applying a regular expression to a string. I call the gasoline-driven
  NFA
  engine“r egex-dir 
 ected,” and the electric-driven
  DFA
  “text-dir ected.”",NA
NFA,NA,NA
 Eng ine: Regex-Directed,"Let’s consider one way an engine might match
  !to(nite;knight;night)""
  against the text 
 ‘
 ˙˙˙
 tonight
 ˙˙˙
 ’. Starting with the
  !t""
 , the regular expression is examined one component at a time, 
 and the “current text” is checked to see whether it is matched by the current component of 
 the regex. If it does, the next component is checked, and so on, until all components have 
 matched, indicating that an overall match has been achieved.
  
 29 April 2003 09:21",NA
Quiz Answer,"O
 Answer to the question on page 153.
  
 When
  !
 ˆ.
 ,
 ([0-9]+)
 ""
  is applied to ‘
 Copyright 2003.
 ’, what is captured by the parentheses?
  
 The desire is to get the last whole number, but it doesn’t work. As before, 
 ! .+""
  is 
 forced to relinquish some of what it had matched because the subse-quent
  ![0-9]+""
  
 requir es a match to be successful. In this example, that means unmatching the final 
 period and ‘
 3
 ’, which then allows
  ![0-9]""
  to match. That’s governed by
  !+""
 , so 
 matching just once fulfills its minimum, and now facing ‘
 .
 ’ in the string, it finds 
 nothing else to match.
  
 Unlike before, though, there’s then nothing further that
  must
  match, so
  ! .+""
  is not 
 forced to give up the
  0
  or any other digits it might have matched. Wer e 
 ! .+""
  to do so, 
 the
  ![0-9]+""
  would certainly be a grateful and greedy recipient, but nope, first come 
 first served. Greedy constructs give up something they’ve matched only when forced. 
 In the end,
  $1
  gets only ‘
 3
 ’.
  
 If this feels counter-intuitive, realize that
  ![0-9]+""
  is at most one match away fr om
  ![0-
 9]+""
 , which is in the same league as
  ! .+""
 . Substituting that into 
 !ˆ.+([0-9]+)""
 , we get
  
 !ˆ.+(.+)""
  as our regex, which looks suspiciously like the
  !ˆSubject: (.+).+""
  example from 
 page 152, where the second
  ! .+""
  was guaranteed to match nothing.
  
 With the
  !to(nite;knight;night)""
  example, the first component is
  !t""
 , which repeatedly fails 
 until a ‘
 t
 ’ is reached in the target string. Once that happens, the
  !o 
 is checked against the next 
 character, and if it matches, control moves to the next
  
 component. In this case, the “next component” is
  !(nite;knight;night)""
  which really means “
  
 !nite""
  or
  !knight""
  or
  !night""
 . ”  Faced with three possibilities, the engine just tries each in 
 turn. We (humans with advanced neural nets between our
  
 ears) can see that if we’re matching
  tonight
 , the third alternative is the one that
  
 leads to a match. Despite their brainy origins ( 85), a regex-dir ected engine can’t come to 
 that conclusion until actually going through the motions to check.
  
 Attempting the first alternative,
  !nite""
 , involves the same component-at-a-time tr eatment as 
 before: “ Try to match
  !n""
 , then
  !i""
 , then
  !t""
 , and finally
  !e""
 . ”  If this fails, as it eventually 
 does, the engine tries another alternative, and so on until it
  
 achieves a match or must report failure. Control moves within the regex from com-
  
 ponent to component, so I call it “regex-dir ected.”
  
 29 April 2003 09:21",NA
DFA,NA,NA
 Eng ine: Te xt-Directed,"Contrast the regex-dir ected
  NFA
  engine with an engine that, while scanning the string, keeps 
 track of all matches “currently in the works.” In the
  tonight
  exam-ple, the moment the 
 engine hits
  t
 , it adds a potential match to its list of those cur-rently in progr ess:
  
 in string 
  
 in regex
  
 after
 ˙˙˙
 tonight
 ˙˙˙
  
 possible matches:
  !to(nite;knight;night)
  
 Each subsequent character scanned updates the list of possible matches. After a few more 
 characters are matched, the situation becomes
  
 in string 
  
 in regex
  
 after
 ˙˙˙
 tonight
 ˙˙˙
  
 possible matches:
  !to(nite;knight;night)
  
 with two possible matches in the works (and one alternative,
  knight
 , ruled out). With the
  g
  
 that follows, only the third alternative remains viable. Once the
  h
  and
  t 
 ar e scanned as well, 
 the engine realizes it has a complete match and can retur n success.
  
 I call this “text-directed” matching because each character scanned from the text contr ols 
 the engine. As in the example, a partial match might be the start of any number of differ ent, 
 yet possible, matches. Matches that are no longer viable are pruned as subsequent characters 
 are scanned. There are even situations where a“partial match in progr ess” is also a full 
 match. If the regex were
  !to(
 ˙˙˙
 )
 ?
 ""
 , for example, the parenthesized expression becomes 
 optional, but it’s still greedy, so it’s always attempted. All the time that a partial match is in 
 progr ess inside those par entheses, a full match (of ‘
 to
 ’) is already confirmed and in reserve 
 in case the longer matches don’t pan out.
  
 29 April 2003 09:21",NA
First Thoughts:,NA,NA
 NFA,NA,NA
 and,NA,NA
 DFA,NA,NA
 in Comparison,"If you compare these two engines based only on what I’ve mentioned so far, you might 
 conclude that the text-directed
  DFA
  engine is generally faster. The regex-dir ected
  NFA
  
 engine might waste time attempting to match differ ent subexpr es-sions against the same 
 text (such as the three alternatives in the example).
  
 You would be right. During the course of an
  NFA
  match, the same character of the target 
 might be checked by many differ ent parts of the regex (or even by the same part, over and 
 over). Even if a subexpression can match, it might have to be applied again (and again and 
 again) as it works in concert with the rest of the regex to find a match. A local subexpression 
 can fail or match, but you just never know about the overall match until you eventually work 
 your way to the end of the regex. (If I could find a way to include “It’s not over until the fat 
 lady sings.” in this paragraph, I would.) On the other hand, a
  DFA
  engine is
  deter ministic
  —
  
 each character in the target is checked once (at most). When a character matches, you don’t 
 know yet if it will be part of the final match (it could be part of a possible match that doesn’t 
 pan out), but since the engine keeps track of all possible matches in parallel, it needs to be 
 checked only once, period.
  
 The two basic technologies behind regular-expr ession engines have the somewhat imposing 
 names
  Nondeter ministic Finite Automaton
  (
 NFA
 ) and
  Deter ministic Finite Automaton
  (
 DFA
 ). With 
 mouthfuls like this, you see why I stick to just “
 NFA
 ” and“
 DFA
 .” We won’t be seeing these 
 phrases spelled out again.
 †
  
 Consequences to us as users
  
 Because of the regex-dir ected natur e of an
  NFA
 , the details of how the engine attempts a 
 match are very important. As I said before, the writer can exercise a fair amount of control 
 simply by changing how the regex is written. With the
  tonight 
 example, perhaps less work 
 would have been wasted had the regex been written dif ferently, such as in one of the 
 following ways:
  
 •
  
 •
  
 •
  
 !to
 (
 ni(ght;te)<knight
 ) 
  
 !tonite;toknight;tonight 
  
 !to(k?night;nite)
  
 † I suppose I could explain the underlying theory that goes into these names, if I only knew it! As I hinted, the word
  
 deter ministic
  is pretty important, but for the most part the theory is not relevant, so long as we understand the 
 practical effects. By the end of this chapter, we will.
  
 29 April 2003 09:21",NA
Backtracking,"The essence of an
  NFA
  engine is this: it considers each subexpression or compo-nent in 
 turn, and whenever it needs to decide between two equally viable options, it selects one and 
 remembers the other to retur n to later if need be.
  
 Situations where it has to decide among courses of action include anything with a quantifier 
 (decide whether to try another match), and alternation (decide which alter native to try, and 
 which to leave for later).
  
 Whichever course of action is attempted, if it’s successful and the rest of the regex is also 
 successful, the match is finished. If anything in the rest of the regex eventu-ally causes 
 failure, the regex engine knows it can
  backtrack
  to where it chose the first option, and can 
 continue with the match by trying the other option. This way, it eventually tries all possible 
 permutations of the regex (or at least as many as needed until a match is found).
  
 29 April 2003 09:21",NA
A Really Crummy Analog y,"Backtracking is like leaving a pile of bread crumbs at every fork in the road. If the path you 
 choose turns out to be a dead end, you can retrace your steps, giving up gr ound until you 
 come across a pile of crumbs that indicates an untried path. Should that path, too, turn out 
 to be a dead end, you can backtrack further, retrac-ing your steps to the next pile of crumbs, 
 and so on, until you eventually find a path that leads to your goal, or until you run out of 
 untried paths.
  
 Ther e ar e various situations when the regex engine needs to choose between two (or more) 
 options
  —
  the alternation we saw earlier is only one example. Another example is that upon 
 reaching
  !
  ˙˙˙
 x?
 ˙˙˙
 ""
 , the engine must decide whether it should attempt
  !x""
 . Upon reaching
  !
  ˙˙˙
 x+
 ˙˙˙
 ""
 , 
 however, ther e is no question about trying to match
  !x""
  at least once
  —
  the plus requir es at 
 least one match, and that’s non-nego-tiable. Once the first
  !x""
  has been matched, though, the
  
 requir ement
  is lifted and it then must decide to match another
  !x""
 . If it decides to match, it 
 must decide if it will then attempt to match yet another... and another... and so on. At each 
 of these many decision points, a virtual “pile of crumbs” is left behind as a reminder that 
 another option (to match or not to match, whichever wasn’t chosen at each point) remains 
 viable at that point.
  
 A crummy little example
  
 Let’s look at a full example using our earlier
  !to(nite;knight;night)""
  regex on the string ‘
 hot 
 tonic tonight!
 ’ (silly, yes, but a good example). The first com-ponent,
  !t""
 , is attempted at the 
 start of the string. It fails to match
  h
 , so the entire regex fails at that point. The engine’s 
 transmission then bumps along to retry the regex from the second position (which also fails), 
 and again at the third. This time the
  !t""
  matches, but the subsequent
  !o""
  fails to match 
 because the text we’re at is now a space. So, again, the whole attempt fails.
  
 The attempt that eventually starts at
 ˙˙˙
 tonic
 ˙˙˙
  is more inter esting. Once the
  to
  has
  
 been matched, the three alternatives become three available options. The regex engine picks 
 one to try, remembering the others (“leaving some bread crumbs”) in case the first fails. For 
 the purposes of discussion, let’s say that the engine first chooses
  !nite""
 . That expression 
 breaks down to “
 !n""
  +
  !i""
  +
  !t""
  ...,” which gets to
 ˙˙˙
 tonic
 ˙˙˙
  befor e failing. Unlike the earlier 
 failures, this failure doesn’t mean the
  
 end of the overall attempt because other options
  —
  the as-of-yet untried alterna-tives
  —
  still 
 remain. (In our analogy, we still have piles of breadcrumbs we can retur n to.) The engine 
 chooses one, we’ll say
  !knight""
 , but it fails right away because
  !k""
  doesn’t match ‘
 n
 ’. That 
 leaves one final option,
  !night""
 , but it too even-tually fails. Since that was the final untried 
 option, its failure means the failure of the entire attempt starting at
  
 ˙˙˙
 tonic
 ˙˙˙
 , so the 
 transmission kicks in again.
  
 29 April 2003 09:21",NA
Tw o Impor tant Points on Backtracking,"The general idea of how backtracking works is fairly simple, but some of the details are quite 
 important for real-world use. Specifically, when faced with multi-ple choices, which choice 
 should be tried first? Secondly, when forced to back-track, which saved choice should the 
 engine use? The answer to that first question is this important principle:
  
 In situations where the decision is between “make an attempt” and “skip an 
 attempt,” as with items governed by quantifiers, the engine always chooses to first
  
 make
  the attempt for
  gr eedy
  quantifiers, and to first
  skip 
 the attempt for
  lazy
  (non-
 gr eedy) ones.
  
 This has far-r eaching repercussions. For starters, it helps explain why the greedy quantifiers 
 are greedy, but it doesn’t explain it completely. To complete the pic-tur e, we need to know 
 which (among possibly many) saved options to use when we backtrack. Simply put:
  
 The most recently saved option is the one retur ned to when a local fail-ur e forces 
 backtracking. They’re used
  LIFO
  (last in first out).
  
 This is easily understood in the crummy analogy
  —
  if your path becomes blocked, you 
 simply retrace your steps until you come back across a pile of bread crumbs. The first you’ll 
 retur n to is the one most recently laid. The traditional analogy for describing
  LIFO
  also 
 holds: like stacking and unstacking dishes, the most-recently stacked will be the first 
 unstacked.",NA
Saved States,"In
  NFA
  regular expression nomenclature, the piles of bread crumbs are known as saved
  
 states
 . A state indicates where matching can restart from, if need be. It reflects both the 
 position in the regex and the point in the string where an untried option begins. Because this 
 is the basis for
  NFA
  matching, let me show the implica-tions of what I’ve already said with 
 some simple but verbose examples. If you’re comfortable with the discussion so far, feel free 
 to skip ahead.
  
 29 April 2003 09:21",NA
Backtracking and Greediness,"For tools that use this
  NFA
  regex-dir ected backtracking engine, understanding how 
 backtracking works with your regular expression is the key to writing expressions that 
 accomplish what you want, and accomplish it quickly. We’ve seen how
  !? 
 gr eediness and
  !??""
  
 laziness works, so now let’s look at star and plus.
  
 Star, plus, and their backtracking
  
 If you consider
  !x+""
  to be more or less the same as
  !x?x?x?x?x?x?
 ˙˙˙
 ""
  (or, mor e appr opriately,
  
 !(x(x(x(x
 ˙˙˙
 ?)?)?)?)?""
  ),
 †
 it’s not too differ ent fr om what we have alr eady seen. Before 
 checking the item quantified by the star, the engine saves a state indicating that if the check 
 fails (or leads to failure), the match can pick up after the star. This is done repeatedly, until 
 an attempt via the star actually does fail.
  
 Thus, when matching
  ![0-9]+""
  against ‘
 a 1234 num
 ’, once
  ![0-9]""
  fails to match the space 
 after the
  4
 , ther e ar e four saved states corresponding to locations to which the plus can 
 backtrack:
  
 a 1234 num
  
 a 1234 num
  
 a 1234 num
  
 a 1234 num
  
 These repr esent the fact that the attempt of
  ![0-9]""
  had been optional at each of these 
 positions. When
  ![0-9]""
  fails to match the space, the engine backtracks to the most recently 
 saved state (the last one listed), picking up at ‘
 a 1234 num
 ’ in the
  
 text and at
  ![0-9]+ ""
  in the regex. Well, that’s at the end of the regex. Now that
  
 we’r e actually there and notice it, we realize that we have an overall match.
  
 Note that ‘
 a 1234 num
 ’ is not in the list of positions, because the first match using
  
 the plus quantifier is requir ed, not optional. Would it have been in the list had the
  
 regex been
  ![0-9]+ ""
  ? 
 answer.
  
 (hint: it’s a trick question)
  O
  Turn the page to check your
  
 Revisiting a fuller example
  
 With our more detailed understanding, let’s revisit the
  !ˆ.+([0-9][0-9])""
  example fr om page 
 152. This time, instead of just pointing to “greediness” to explain why the match turns out as 
 it does, we can use our knowledge of
  NFA
  mechanics to explain why in precise terms.
  
 I’ll use ‘
 CA 95472, USA
 ’ as an example. Once the
  ! .+""
  has successfully matched to the end of 
 the string, there are a baker’s dozen saved states accumulated from the
  
 † Just for comparison, remember that a
  DFA
  doesn’t care much about the form you use to express 
  
 which 
 matches are possible; the three examples
  ar e
  identical to a
  DFA
 .
  
 29 April 2003 09:21",NA
More About Greediness ,NA,NA
and Backtracking,"Many concerns (and benefits) of greediness are shar ed by both an
  NFA
  and a
  DFA
 . (A
  DFA
  
 doesn’t support laziness, which is why we’ve concentrated on greediness up to this point.) 
 I’d like to look at some ramifications of greediness for both, but with examples explained in 
 terms of an
  NFA
 . The lessons apply to a
  DFA
  just as well, but not for the same reasons. A
  
 DFA
  is greedy, period, and there’s not much
  
 29 April 2003 09:21",NA
Quiz Answer,"O
 Answer to the question on page 162.
  
 When matching
  !
 [0-9]
 , ""
  against ‘
 a 1234 num
 ’, would ‘
 a 1234 num
 ’ be par t of a saved 
 state?
  
 The answer is “no.” I posed this question because the mistake is commonly made. 
 Remember, a component that has star applied can
  always
  match. If that’s the entire 
 regex, it can always match anywhere. This certainly includes the attempt when the 
 transmission applies the engine the first time, at the start of the string. In this case, the 
 regex matches at ‘
 a 1234 num
 ’ and that’s the end of it
 —
 it never even gets as far the 
 digits.
  
 In case you missed this, there’s still a chance for partial credit. Had there been 
 something in the regex after the
  ![0-9]+""
  that kept an overall match fr om happening 
 before the engine got to:
  
 at ‘
 a 1234
 ˙˙˙
 ’
  
 matching
  ![0-9]+
 ˙˙˙
  
 then indeed, the attempt of the ‘
 1
 ’ also creates the state:
  
 at ‘
 a 1234
 ˙˙˙
 ’
  
 matching
  ![0-9]+
 ˙˙˙
  
 mor e to say after that. It’s very easy to use, but pretty boring to talk about. An
  NFA
 , 
 however, is inter esting because of the creative outlet its regex-dir ected natur e pr o-vides. 
 Besides lazy quantifiers, there are a variety of extra features an
  NFA
  can sup-port, including 
 lookaround, conditionals, backrefer ences, and atomic grouping. And on top of these, an
  
 NFA
  af fords the regex author direct control over how a match is carried out, which can be a 
 benefit when used properly, but it does cre-ate some efficiency-r elated pitfalls (discussed in 
 Chapter 6.)
  
 Despite these differ ences, the match results are often similar. For the next few pages, I’ll 
 talk of both engine types, but describe effects in terms of the regex-dir ected
  NFA
 . By the 
 end of this chapter, you’ll have a firm grasp of just when the results might differ, as well as 
 exactly why.",NA
Problems of Greediness,"As we saw with the last example,
  ! .+""
  always marches to the end of the line.
 †
 This is because
  ! 
 .+""
  just thinks of itself and grabs what it can, only later giving up some-thing if it is requir ed 
 to achieve an overall match.
  
 † With a tool or mode where a dot can match a newline,
  ! .+""
  applied to strings that contain multiline 
  
 data 
 matches through all the logical lines to the end of the whole string.
  
 29 April 2003 09:21",NA
Multi-Character “Quotes”,"In the first chapter, I talked a bit about matching
  HTML
  tags, such as the sequence 
 <B>very</B>
  that renders the “very” in bold if the browser can do so. Attempting to match 
 a
  <B>
  ˙˙˙
 </B>
  sequence seems similar to matching a quoted string, except the “quotes” in this 
 case are the multi-character sequences
  <B>
  and
  </B>
 . Like the quoted string example, 
 multiple sets of “quotes” cause problems if we use
  ! .+""
 :
  
 ˙˙˙
 <B>Billions</B> and <B>Zillions</B> of suns
 ˙˙˙
  
 With
  !<B> .+</B>""
 , the greedy
  ! .+""
  causes the match in progr ess to zip to the end of the line, 
 backtracking only far enough to allow the
  !</B>""
  to match, matching the last
  </B>
  on the 
 line instead of the one corresponding to the opening
  !<B>""
  at the start of the match.
  
 29 April 2003 09:21",NA
Using Lazy Quantifier s,"These problems arise because the standard quantifiers are greedy. Some
  NFA
 s sup-port lazy 
 quantifiers ( 140), with
  +?
  being the lazy version of
  +
 . With that in mind, let’s apply
  
 !<B>
 .
 ,
 ?
 </B>""
  to:
  
 ˙˙˙
 <B>Billions</B> and <B>Zillions</B> of suns
 ˙˙˙
  
 After the initial
  !<B>""
  has matched,
  ! .+?""
  immediately decides that since it doesn’t requir e 
 any matches, it lazily doesn’t bother trying to perfor m any. So, it immedi-ately passes 
 control to the following
  !<""
 :
  
 at ‘
 ˙˙˙
 <B>Bi l l i o n s
 ˙˙˙
 ’
  
 matching
  !<B>.+?</B>
  
 The
  !<""
  doesn’t match at that point, so control retur ns back to
  ! .+?""
  wher e it still has its 
 untried option to attempt a match (to attempt multiple matches, actually). It
  
 begrudgingly does so, with the dot matching the underlined
  B
  in
  
 ˙˙˙
 <B>Billions
 ˙˙˙
 .
  
  
 Again, the
  +?
  has the option to match more, or to stop. It’s lazy, so it first tries stopping. The 
 subsequent
  !<""
  still fails, so
  ! .+?""
  has to again exercise its untried match option. After eight 
 cycles,
  ! .+?""
  eventually matches
  Billions
 , at which point the subsequent
  !<""
  (and the whole
  
 !</B>""
  subexpr ession) is finally able to match:
  
 ˙˙˙
 <B>Billions</B> and <B>Zillions</B> of suns
 ˙˙˙
  
  
 So, as we’ve seen, the greediness of star and friends can be a real boon at times, while 
 troublesome at others. Having non-greedy, lazy versions is wonderful, as they allow you to 
 do things that are otherwise very difficult (or even impossible). Still, I’ve often seen 
 inexperienced programmers use lazy quantifiers in inappropri-ate situations. In fact, what 
 we’ve just done may not be appropriate. Consider applying
  !<B> .+?</B>""
  to:
  
 ˙˙˙
 <B>Billions and <B>Zillions</B> of suns
 ˙˙˙
  
 It matches as shown, and while I suppose it depends on the exact needs of the sit-uation, I 
 would think that in this case that match is not desired. However, ther e’s nothing about
  ! .+?""
  
 to stop it from marching right past the Zillion’s
  <B>
  to its
  </B>
 .
  
 29 April 2003 09:21",NA
Greediness and Laziness Always Favor a Match,"Recall the price display example from Chapter 2 ( 51). We’ll examine this exam-ple in detail 
 at a number of points during this chapter, so I’ll recap the basic issue: due to floating-point 
 repr esentation pr oblems, values that should have been“1.625” or “3.00” were sometimes 
 coming out like “1.62500000002828” and“3.00000000028822”. To fix this, I used
  
 $price =˜ s/(\.\d\d[1-9]?)\d+/$1/;
  
 to lop off all but the first two or three decimal digits from the value stored in the variable
  
 $price
 . The
  !\.\d\d""
  matches the first two decimal digits regardless, while the
  ![1-9]?""
  
 matches the third digit only if it is non-zero.
  
 29 April 2003 09:21",NA
"The Essence of Greediness, Laziness, ",NA,NA
and Backtracking,"The lesson of the preceding section is that it makes no differ ence whether there ar e gr eedy 
 or lazy components to a regex; an overall match takes precedence over an overall non-
 match. This includes taking from what had been greedy (or giving to what had been lazy) if 
 that’s what is requir ed to achieve a match, because when
  
 29 April 2003 09:21",NA
Possessive Quantifier s and Atomic Grouping,"The ‘
 .625
 ’ example on the facing page shows important insights about
  NFA
  match-ing as we 
 know it, and how with that particular example our naïve intents were thwarted. Some flavors 
 do provide tools to help us here, but before looking at them, it’s absolutely essential to fully 
 understand the preceding section, “The Essence of Greediness, Laziness, and Backtracking.” 
 Be sur e to review it if you have any doubts.
  
 So, continuing with the ‘
 .625
 ’ example and recalling what we really want to hap-pen, we 
 know that if the matching can successfully get to the marked position in 
 !(\.\d\d[1-9]?)\d+""
 , 
 we never want it to go back. That is, we want
  ![1-9]""
  to
  
 match if possible, but if it does, we don’t want that match to be given up. Saying it mor e 
 forcefully, we would rather have the entire match attempt fail, if need be, befor e giving up 
 something matched by the
  ![1-9]""
 . (As you’ll recall, the problem befor e when this regex was 
 applied to ‘
 .625
 ’ was that it indeed
  didn’t
  fail, but instead went back to try the remaining skip-
 me alternative.)
  
 Well, what if we could somehow eliminate that skip-me alternative (eliminate the state that
  
 !?""
  saves before it makes the attempt to match
  ![1-9]""
  ) ?  If ther e was no state to go back to, 
 a match of
  ![1-9]""
  wouldn’t be given up. That’s what we want! Ah, but if there was no skip-
 me state to go back to, what would happen if we
  
 29 April 2003 09:21",NA
Quiz Answer,"O
 Answer to the question on page 171.
  
 What does
  !(?>
 .
 ,
 ?
 )""
  match?
  
 It can never match, anything. At best, it’s a fairly complex way to accomplish nothing!
  
 !+?""
  is the lazy
  !+""
 , and governs a dot, so the first path it attempts is the skip-the-dot 
 path, saving the try-the-dot state for later, if requir ed. But the moment that state has 
 been saved, it’s thrown away because matching exits the atomic grouping, so the skip-
 the-dot path is the only one ever taken. If something is always skipped, it’s as if it’s not 
 there at all.
  
 All that backtracking is a lot of work that after just a glance we know to be unnec-essary. If 
 the colon can’t match after the last letter, it certainly can’t match one of the letters the
  !+""
  is 
 forced to give up!
  
 So, knowing that none of the states left by
  !\w+""
 , once it’s finished, could possibly lead to a 
 match, we can save the regex engine the trouble of checking them: 
 !ˆ
 (?>
 \w+
 )
 :""
  By adding the 
 atomic grouping, we use our global knowledge of the regex to enhance the local working of
  
 !\w+""
  by having its saved states (which we know to be useless) thrown away. If there
  is
  a 
 match, the atomic grouping won’t have mattered, but if there’s not to be a match, having 
 thrown away the useless states lets the regex come to that conclusion more quickly. (An 
 advanced imple-mentation may be able to apply this optimization for you automatically 251.)
  
 As we’ll see in the Chapter 6 ( 269), this technique shows a very valuable use of atomic 
 grouping, and I suspect it will become the most common use as well.",NA
"Possessive Quantifier s,",NA,NA
 ?+,NA,NA
",",NA,NA
 ++,NA,NA
",",NA,NA
 ++,NA,NA
", and",NA,NA
" {m,n}+","Possessive quantifiers are much like greedy quantifiers, but they never give up a partial 
 amount of what they’ve been able to match. Once a plus, for example, fin-ishes its run, it has 
 created quite a few saved states, as we saw with the
  !ˆ\w+ 
 example. A
  possessive
  plus simply 
 throws those states away (or, mor e likely, doesn’t bother creating them in the first place).
  
 As you might guess, possessive quantifiers are closely related to atomic grouping. Something 
 possessive like
  !\w++""
  appears to match in the same way as
  !
 (?>
 \w+
 )
 ""
 ; one is just a 
 notational convenience for the other.
 †
 With possessive quantifiers, 
 !ˆ
 (?>
 \w+
 )
 :""
  can be 
 rewritten as
  !ˆ\w++:""
 , and
  !(\.\d\d
 (?>
 [1-9]?
 )
 )\d+""
  can be rewritten as
  !(\.\d\d[1-9]?
 +
 )\d+""
 .
  
 † A smart implementation may be able to make the possessive version a bit more efficient than its 
  
 atomic-gr 
 ouping counterpart ( 250).
  
 29 April 2003 09:21",NA
The Backtracking of Lookaround,"It might not be apparent at first, but lookaround (introduced in Chapter 2 59) is closely 
 related to atomic grouping and possessive quantifiers. There are four types of lookaround: 
 positive and negative flavors of lookahead and lookbehind. They simply test whether their 
 subexpression can and can’t match starting at the current location (lookahead), or ending at 
 the current location (lookbehind).
  
 Looking a bit deeper, how does lookaround work in our
  NFA
  world of saved states and 
 backtracking? As a subexpression within one of the lookaround constructs is being tested, 
 it’s as if it’s in its own little world. It saves states as needed, and backtracks as necessary. If 
 the entire subexpr ession is able to match successfully, what happens? With
  positive
  lookar 
 ound, the construct, as a whole, is considered a success, and with
  negative
  lookar ound, it’s 
 considered a failure. In either case, since the only concern is whether there’s a match (and we 
 just found out that, yes, ther e’s a match), the “little world” of the match attempt, including 
 any saved states that might have been left over from that attempt, is thrown away.
  
 What about when the subexpression within the lookaround can’t match? Since it’s being 
 applied in its “own little world,” only states created within the current look-ar ound 
 construct are available. That is, if the regex finds that it needs to backtrack further, beyond 
 where the lookaround construct started, it’s found that the current subexpr ession can not 
 match. For positive lookahead, this means failure, while for negative lookahead, it means 
 success. In either case, there are no saved states left over (had there been, the subexpression 
 match would not have finished), so ther e’s no “little world” left to throw away.
  
 So, we’ve seen that in all cases, once the lookaround construct has finished, there ar e no 
 saved states left over from its application. Any states that might have been left over, such as 
 in the case of successful positive lookahead, are thr own away.
  
 29 April 2003 09:21",NA
Is Alternation Greedy?,"How alternation works is an important point because it can work in fundamentally dif ferent 
 ways with differ ent regex engines. When alternation is reached, any num-ber of the 
 alternatives might be able to match at that point, but which will? Put another way, if more 
 than one can match, which will? If it’s always the one that matches the most text, one might 
 say that alternation is greedy. If it’s always the shortest amount of text, one might say it’s 
 lazy? Which (if either) is it?
  
 Let’s look at the Traditional
  NFA
  engine used in Perl, Java packages, .
 NET
  lan-guages, and 
 many others ( 145). When faced with alternation, each alternative is checked in the left-to-
 right order given in the expression. With the example regex of
  !ˆ(Subject;Date): ""
 , when the
  
 !Subject;Date""
  alter nation is reached, the first alter native,
  !Subject""
 , is attempted. If it 
 matches, the rest of the regex (the subse-quent
  !: ""
  ) is given a chance. If it turns out that it 
 can’t match, and if other alterna-tives remain (in this case,
  !Date""
  ), the regex engine 
 backtracks to try them.
  This is just another case of the regex engine backtracking to a point where untried 
 options ar e still available
 . This continues until an overall match is achieved, or until all options 
 (in this case, all alternatives) are exhausted.
  
 29 April 2003 09:21",NA
Taking Advantage of Ordered Alternation,"Let’s revisit the
  !
 (
 \.\d\d[1-9]?
 )
 \d+""
  example from page 167. If we realize that 
 !\.\d\d[1-9]?""
 , 
 in effect, says “allow either
  !\.\d\d""
  or
  !\.\d\d[1-9]""
  ”, we can rewrite the entire expr ession 
 as
  !
 (
 \.\d\d<\.\d\d[1-9]
 )
 \d+""
 . (Ther e is no com-pelling reason to make this change
  —
  it’s 
 merely a handy example.) Is this
  really 
 the same as the original? If alternation is truly greedy, 
 then it is, but the two are quite differ ent with ordered alternation.
  
 Let’s consider it as ordered for the moment. The first alternative is selected and tested, and if 
 it matches, control passes to the
  !\d+""
  that follows the alternation. If ther e ar e digits 
 remaining, the
  !\d+""
  matches them, including any initial non-zero digit that was the root of 
 the original example’s problem (if you’ll recall the origi-nal problem, that’s a digit we want to 
 match only within the parentheses, not by the
  !\d+""
  after the parentheses). Also, realize that 
 if the first alternative can’t match, the second alternative will certainly not be able to, as it 
 begins with a copy of the entir e first alternative. If the first alternative doesn’t match, 
 though, the regex engine nevertheless expends the effort for the futile attempt of the second.
  
 Inter estingly, if we swap the alternatives and use
  !
 (
 \.\d\d[1-9]<\.\d\d
 )
 \d+""
 , we do 
 effectively get a replica of the original greedy
  !
 (
 \.\d\d[1-9]?
 )
 \d+""
 . The alter nation has 
 meaning in this case because if the first alternative fails due to the trailing
  ![1-9]""
 , the second 
 alternative still stands a chance. It’s still ordered alterna-tion, but now we’ve selected the 
 order to result in a greedy-type match.
  
 29 April 2003 09:21",NA
A Few Ways to Slice and Dice a Date,"A few approaches to the date-matching problem posed on page 176. The calendar 
 associated with each regex shows what can be matched by each alter native color-
 coded within the regex.
  
  1  2  3  4  5  6  7  8  9
  
 01 02 03 04 05 06 07
  
 08
  
 09
  
 10
  11 12 13 14 15 16 17 18 19
  
 20
  21 22 23 24 25 26 27 28 29 
 30 
 31
  
 31|[123]0|
 [012]?[1-9]
  
 0
 1
  0
 2
   3  4  5  6  7  8  9
  
  1  2  3
  
  4
  
  5  6  7  8  9
  
 01 02 03 04 05 06 07
  
 08
  
 09
  
 10 11 12 13 14 15 16 17 18 19 
 20 21 22 23 24 25 26 27 28 29 
 30 31
  
 [12][0-9]|3[01]|
 0?[1-9]
  
 01 02 03 04 05 06 07
  
 08
  
 09
  
 10 11 12 13 14 15 16 17 18 19
  
 20 21 22 23 24 25 26 27 28 29
  
 30 31
  
 0[1-9]|[12][0-9]?|
 3[01]?
 |
 [4-9]",NA
NFA,NA,NA
",",NA,NA
 DFA,NA,NA
", and",NA,NA
 POSIX,NA,NA
“T he Longest-Leftmost”,"Let me repeat what I’ve said before: when the transmission starts a
  DFA
  engine fr om some 
 particular point in the string, and there exists a match or matches to be found at that 
 position, the
  DFA
  finds the longest possible match, period. Since it’s the longest from among 
 all possible matches that start equally furthest to the left, it’s the “longest-leftmost” match.
  
 Really, the longest
  
 Issues of which match is longest aren’t confined to alternation. Consider how an 
 NFA
  
 matches 
 the 
 (horribly 
 contrived)
  
 !one(self)?(selfsufficient)?""
  
 against 
 the 
 string
  
 oneselfsufficient
 . An
  NFA
  first matches
  !one""
  and then the greedy 
 !(self)?""
 , leaving
  
 !(selfsufficient)?""
  left to try against
  sufficient
 . It doesn’t match, but that’s okay since it is 
 optional. So, the Traditional
  NFA
  retur ns 
 oneselfsufficient
  and discards the untried states. 
 (A
  POSIX NFA
  is another story
  
 that we’ll get to shortly.)
  
 29 April 2003 09:21",NA
POSIX,NA,NA
 and the Longest-Leftmost Rule,"The
  POSIX
  standard requir es that if you have multiple possible matches that start at the 
 same position, the one matching the most text must be the one retur ned.
  
 The
  POSIX
  standard document uses the phrase “longest of the leftmost.” It doesn’t say you 
 have to use a
  DFA
 , so if you want to use an
  NFA
  when creating a
  POSIX
  
 29 April 2003 09:21",NA
Speed and Efficienc y,"If efficiency is an issue with a Traditional
  NFA
  (and with backtracking, believe me, it can be), 
 it is doubly so with a
  POSIX NFA
  since there can be so much more back-tracking. A
  POSIX 
 NFA
  engine really does have to try every possible permutation of the regex, every time. 
 Examples in Chapter 6 show that poorly written regexes can suf fer extr emely sever e per 
 formance penalties.
  
 DFA
  efficienc y
  
 The text-directed
  DFA
  is a really fantastic way around all the inefficiency of back-tracking. It 
 gets its matching speed by keeping track of all possible ongoing matches at once. How does 
 it achieve this magic?
  
 The
  DFA
  engine spends extra time and memory when it first sees the regular expr ession, 
 befor e any match attempts are made, to analyze the regular expression mor e thor oughly 
 (and in a differ ent way) from an
  NFA
 . Once it starts actually attempting a match, it has an 
 internal map describing “If I read such-and-such a character now, it will be part of this-and-
 that possible match.” As each character of the string is checked, the engine simply follows 
 the map.
  
 Building that map can sometimes take a fair amount of time and memory, but once it is 
 done for any particular regular expression, the results can be applied to an unlimited amount 
 of text. It’s sort of like charging the batteries of your electric car. First, your car sits in the 
 garage for a while, plugged into the wall, but when you actually use it, you get consistent, 
 clean power.
  
 29 April 2003 09:21",NA
NFA,NA,NA
: Theor y Versus Reality,"The true mathematical and computational meaning of “
 NFA
 ” is dif ferent from what 
 is commonly called an “
 NFA
  regex engine.” In theory,
  NFA
  and
  DFA 
 engines should 
 match exactly the same text and have exactly the same fea-tur es. In practice, the desire 
 for richer, mor e expr essive regular expressions has caused their semantics to diverge. 
 An example is the support for backr efer ences.
  
 The design of a
  DFA
  engine precludes backrefer ences, but it’s a relatively small task to 
 add backrefer ence support to a true 
  
 (mathematically speaking)
  NFA 
 engine. 
 In doing so, you create a more power ful tool, but you also make it decidedly
  nonr egular 
  
 (mathematically speaking)
 . What does this mean? At most, that 
 you should probably stop calling it an
  NFA
 , and start using the phrase“nonr egular expr 
 essions,” since that describes 
  
  
 (mathematically speaking)
  the new situation. No one has actually 
 done this, so the
  name
  “
 NFA
 ” has lingered, even though the implementation is no 
 longer
  (mathematically speaking)
  an
  NFA
 .
  
 What does all this mean to you, as a user? Absolutely nothing. As a user, you don’t 
 care if it’s regular, nonr egular, unr egular, irr egular, or incontinent. So long as you 
 know what you can expect from it (something this chapter shows you), you know all 
 you need to care about.
  
 For those wishing to learn mor e about the theory of regular expressions, the classic 
 computer-science text is chapter 3 of Aho, Sethi, and Ullman’s
  Com-pilers
  —
  Principles, 
 Techniques, and Tools
  (Addison-Wesley, 1986), commonly called “The Dragon Book” 
 due to the cover design. More specifically, this is the “red dragon.” The “green 
 dragon” is its predecessor, Aho and Ullman’s 
 Principles of Compiler Design
 .
  
 The work done when a regex is first seen (the once-per-r egex overhead) is called 
 compiling the 
 regex
 . The map-building is what a
  DFA
  does. An
  NFA
  also builds an inter nal repr esentation 
 of the regex, but an
  NFA
 ’s repr esentation is like a mini pro-gram that the engine then 
 executes.",NA
Summar y:,NA,NA
 NFA,NA,NA
 and,NA,NA
 DFA,NA,NA
 in Comparison,"Both
  DFA
  and
  NFA
  engines have their good and bad points.
  
 DFA
  versus
  NFA
 : Differences in the pre-use compile
  
 Befor e applying a regex to a search, both types of engines compile the regex to an inter nal 
 for m suited to their respective match algorithms. An
  NFA
  compile is gener-ally faster, and 
 requir es less memory. There’s no real differ ence between a Tradi-tional and
  POSIX NFA
  
 compile.
  
 29 April 2003 09:21",NA
DFA,NA,NA
 Speed with,NA,NA
 NFA,NA,NA
 Capabilities: Regex Nir vana?,"I’ve said several times that a
  DFA
  can’t provide capturing parentheses or backr efer 
 ences. This is quite true, but it certainly doesn’t preclude hybrid appr oaches that mix 
 technologies in an attempt to reach regex nirvana. The sidebar on page 180 told how
  
 NFA
 s have diverged from the theoretical straight and narrow in search of more power, 
 and it’s only natural that the same happens with
  DFA
 s. A
  DFA
 ’s construction makes it 
 more dif ficult, but that doesn’t mean impossible.
  
 GNU
  gr ep
  takes a simple but effective approach. It uses a
  DFA
  when possible, 
 reverting to an
  NFA
  when backrefer ences ar e used.
  GNU
  awk does something similar
  
 —
 it uses
  GNU
  gr ep
 ’s fast shortest-leftmost
  DFA
  engine for simple “does it match” 
 checks, and reverts to a differ ent engine for checks where the actual extent of the 
 match must be known. Since that other engine is an
  NFA
 , 
 GNU
  awk can conveniently 
 offer capturing parentheses, and it does via its special
  gensub
  function.
  
 Tcl’s regex engine is a true hybrid, custom built by Henry Spencer (whom you may 
 remember having played an important part in the early develop-ment and 
 popularization of regular expressions 88). The Tcl engine some-times appears to be an
  
 NFA
  —
  it has lookaround, capturing parentheses, back-refer ences, and lazy 
 quantifiers. Yet, it has true
  POSIX
  longest-leftmost match ( 177), and doesn’t suffer 
 from some of the
  NFA
  pr oblems that we’ll see in Chapter 6. It really seems quite 
 wonderful.
  
 Curr ently, this engine is available only to Tcl, but Henry tells me that it’s on his to-do 
 list to break it out into a separate package that can be used by others.",NA
Summar y,"If you understood everything in this chapter the first time you read it, you proba-bly didn’t 
 need to read it in the first place. It’s heady stuff, to say the least. It took me quite a while to 
 understand it, and then longer still to
  understand
  it. I hope this one concise presentation 
 makes it easier for you. I’ve tried to keep the expla-nation simple without falling into the trap 
 of oversimplification (an unfortunately all-too-common occurrence which hinders true 
 understanding). This chapter has a lot in it, so I’ve included a lot of page refer ences in the 
 following summary, for when you’d like to quickly check back on something.
  
 Ther e ar e two underlying technologies commonly used to implement a regex match engine, 
 “regex-dir ected
  NFA
 ” ( 153) and “text-directed
  DFA
 ” ( 155). The abbr eviations ar e spelled 
 out on page 156.
  
 29 April 2003 09:21",NA
5,NA,NA
Practical Regex Techniques,"Now that we’ve covered the basic mechanics of writing regular expressions, I’d like to put 
 that understanding to work in handling situations more complex than those in earlier 
 chapters. Every regex strikes a balance between matching what you want, but not matching 
 what you don’t want. We’ve already seen plenty of examples where greediness can be your 
 friend if used skillfully, and how it can lead to pitfalls if you’re not careful, and we’ll see 
 plenty more in this chapter.
  
 For an
  NFA
  engine, another part of the balance, discussed primarily in the next chapter, is 
 efficiency. A poorly designed regex
 —
 even one that would otherwise be consider ed corr 
 ect
 —
 can cripple an engine.
  
 This chapter is comprised mostly of examples, as I lead you through my thought pr ocesses 
 in solving a number of problems. I encourage you to read through them even if a particular 
 example seems to offer nothing toward your immediate needs.
  
 For instance, even if you don’t work with
  HTML
 , I encourage you to absorb the examples 
 that deal with
  HTML
 . This is because writing a good regular expression is mor e than a skill
  
 —
  it’s an art. One doesn’t teach or learn this art with lists or rules, but rather, thr ough 
 experience, so I’ve written these examples to illustrate for you some of the insight that 
 experience has given me over the years.
  
 You’ll still need your own experience to internalize that insight, but spending time with the 
 examples in this chapter is a good first step.
  
 185
  
 29 April 2003 09:22",NA
Regex Balancing Act,"Writing a good regex involves striking a balance among several concerns:
  
 •
  Matching what you want, but only what you want
  
 •
  Keeping the regex manageable and understandable
  
 •
  For an
  NFA
 , being efficient (creating a regex that leads the engine quickly to a 
  
 match or 
 a non-match, as the case may be)
  
 These concerns are often context-dependent. If I’m working on the command line and just 
 want to
  gr ep
  something quickly, I probably don’t care if I match a bit mor e than I need, and 
 I won’t usually be too concerned to craft just the right regex for it. I’ll allow myself to be 
 sloppy in the interest of time, since I can quickly peruse the output for what I want. 
 However, when I’m working on an important program, it’s worth the time and effort to get 
 it right: a complex regular expr ession is okay if that’s what it takes. There is a  balance 
 among all these issues.
  
 Ef ficiency is context-dependent, even in a program. For example, with an
  NFA
 , something 
 long like
  !ˆ-(display;geometry;cemap;
  
 ˙˙˙
 ;quick24;random;raw)$ 
 to check command-line 
 arguments is inefficient because of all that alternation, but since it is only checking 
 command-line arguments (something done perhaps a few times at the start of the program) 
 it wouldn’t matter if it took 100 times longer than needed. It’s just not an important place to 
 worry much about efficiency. Wer e it used to check each line of a potentially large file, the 
 inefficiency would penalize you for the duration of the program.",NA
A Few Shor t Examples,NA,NA
Continuing with Continuation Lines,"With the continuation-line example from the previous chapter ( 178), we found that
  !ˆ\w+ = 
 .+
 (\\ \n.
 ,
 )
 ,""
  applied with a Traditional
  NFA
  doesn’t properly match both lines of:
  
 SRC=array.c builtin.c eval.c field.c gawkmisc.c io.c main.c \ 
  
 missing.c msg.c 
 node.c re.c version.c
  
 The problem is that the first
  ! .+""
  matches past the backslash, pulling it out from under the
  
 !(\\\n.+)+""
  that we want it to be matched by. Well, here’s the first les-
  
 son of the chapter: if we don’t want to match past the backslash, we should say that in the 
 regex. We can do this by changing each dot to
  ![ˆ\n \\]""
 . (Notice how I’ve made sure to 
 include
  \n
  in the negated class? You’ll remember that one of the assumptions of the original 
 regex was that dot didn’t match a newline, and we don’t want its replacement to match a 
 newline either 118.)
  
 29 April 2003 09:22",NA
Matching an,NA,NA
 IP,NA,NA
 Address,"As another example that we’ll take much further, let’s match an
  IP
  (Inter net Pr oto-col) 
 address: four numbers separated by periods, such as
  1.2.3.4
 . Often, the numbers are padded 
 to three digits, as in
  001.002.003.004
 . If you want to check a string for one of these, you 
 could use
  ![0-9]+\.[0-9]+\.[0-9]+\.[0-9]+""
 , but that’s so vague that it even matches ‘
 and then . 
 . . ..?
 ’. Look at the regex: it
  
 doesn’t even
  requir e
  any numbers
  —
  its only requir ements ar e thr ee periods (with nothing 
 but digits,
  if anything
 , between).
  
 To fix this regex, we first change the star to a plus, since we know that each num-ber must 
 have at least one digit. To ensur e that the entire string is only the
  IP 
 addr ess, we wrap the 
 regex with
  !ˆ
 ˙˙˙
 $""
 . This gives us:
  
 !ˆ[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$
  
 Using
  !\d""
  instead of
  ![0-9]""
 , it becomes
  !ˆ\d+\.\d+\.\d+\.\d+$""
 , which you may find to be 
 more easily readable,
 †
 but it still matches things that aren’t
  IP
  addr esses,
  
 † Or maybe not
  —
  it depends on what you are used to. In a complex regex, I find
  !\d""
  mor e readable than
  ![0-9]""
 , 
 but note that on some systems, the two might not be exactly the same. Systems that sup-port Unicode, for 
 example, may have their
  !\d""
  match non-
 ASCII
  digits as well ( 119).
  
 29 April 2003 09:22",NA
Working with Filenames,"Working with file and path names, like
  /usr/local/bin/perl
  on Unix, or per-haps something 
 like
  \Program Files\Yahoo!\Messenger
  on Windows, can pro-vide many good regular-expr 
 ession examples. Since “using” is more inter esting than “reading,” I’ll sprinkle in a few 
 examples coded in Perl, Java, and VB.NET. If you’r e not interested in these particular 
 languages, feel free to skip the code snip-pets
 —
 it’s the regex concepts used in them that are 
 important.
  
 Removing the leading path from a filename
  
 As a first example, let’s remove the leading path from a filename, turning 
 /usr/local/bin/gcc
 , 
 for instance, into
  gcc
 . Stating problems in a way that makes solutions amenable is half of the 
 battle. In this case, we want to remove anything up to (and including) the final slash 
 (backslash for Windows pathnames). If there is no slash, it’s fine as is, and nothing needs to 
 be done. I’ve said a num-ber of times that
  ! .+""
  is often overused, but its greediness is desired 
 here. With 
 !ˆ.+/""
 , the
  ! .+""
  consumes the whole line, but then backs off (that is, backtracks) to 
 the last slash to achieve the match.
  
 Her e’s code to do it in our three test languages, ensuring that a filename in the variable
  f
  has 
 no leading path. First, for Unix filenames:
  
 Langua ge 
  
 Code Snippet
  
  
 Perl 
  
 $f
  =˜ s{
 ˆ.+/
 }{}
 ; 
  
 java.util.regex 
  
 f = f.
 replaceFirst
 (""ˆ.+/"", """"); 
 VB.NET 
  
 f =
  
 Regex.Replace
 (f, ""ˆ.+/"", """")
  
 The regular expression (or string to be interpreted as a regular expression) is underlined, and 
 regex components are bold.
  
 For comparison, here they are for Windows filenames:
  
 Langua ge 
  
 Code Snippet
  
  
 Perl 
  
 $f
  =˜ s/
 ˆ.+\\
 //
 ; 
  
 java.util.regex 
  
 f = f.
 replaceFirst
 (""ˆ.+\\\\"", """"); 
 VB.NET 
  
 f =
  
 Regex.Replace
 (f, ""ˆ.+\\"", """")
  
 It’s interesting to compare the differ ences needed for each language when going fr om one 
 example to the other, particularly the quadruple backslashes needed in Java ( 101).
  
 Please keep in mind this key point: always consider what will happen if there is no match. In 
 this case, if there is no slash in the string, no substitution is done and the string is left 
 unchanged. That’s just what we want.
  
 29 April 2003 09:22",NA
Matching Balanced Sets of Parentheses,"Matching balanced sets of parentheses, brackets, and the like presents a special dif ficulty. 
 Wanting to match balanced parentheses is quite common when parsing many kinds of 
 configuration files, programs, and such. Imagine, for example, that you want to do some 
 processing on all of a function’s arguments when parsing a language like C. Function 
 arguments are wrapped in parentheses following the function name, and may themselves 
 contain parentheses resulting from nested function calls or math grouping. At first, ignoring 
 that they may be nested, you might be tempted to use
  !\b foo\(
 [
 ˆ)
 ]
 +\)""
 , but it won’t work.
  
 In hallowed C tradition, I use
  foo
  as the example function name. The marked part of the 
 expression is ostensibly meant to match the function’s arguments. With
  
 examples such as
  foo(2, 4.0)
  and
  foo(somevar, 3.7)
 , it works as expected.
  
  
 Unfortunately, it also matches
  foo(bar(somevar), 3.7)
 , which is not as we
  
 want. This calls for something a bit “smarter” than
  ![ˆ)]+""
 .
  
 To match the parenthesized expression part, you might consider the following reg-ular 
 expressions, among others:
  
 1
 .
  
 \(.+\)
  
 literal parentheses with anything in between
  
 2
 .
  
 \(
 [
 ˆ)
 ]
 +\)
  
 fr om an opening parenthesis to the next closing parenthesis
  
 3
 .
  
 \(
 [
 ˆ()
 ]
 +\)
  
 fr om an opening parenthesis to the next closing parenthesis, but
  
 no other opening parentheses allowed in between
  
 Figur e 5-1 illustrates where these match against a sample line of code.
  
 desired match
  
 val = foo(bar(this), 3.7) + 2 * (that - 1);
  
 regex #2 would match
  
 regex #1 would match
  
 Figur e 5-1: Match locations of our sample regexes
  
 We see that regex #1 matches too much,
 †
 and regex #2 matches too little. Regex #3 doesn’t 
 even match successfully. In isolation, #3 would match ‘
 (this)
 ’, but because it must come 
 immediately after the
  foo
 , it fails. So, none of these work.
  
 † The use of
  ! .+""
  should set off war ning alar ms. Always pay particular attention to decide whether dot is really 
 what you want to apply star to. Sometimes that is exactly what you need, but
  ! .+""
  is often used inappropriately.
  
 29 April 2003 09:22",NA
Watching Out for Unwanted Matches,"It’s easy to forget what happens if the text is not formed just as you expect. Let’s say you are 
 writing a filter to convert a text file to
  HTML
 , and you want to replace a line of hyphens by
  
 <HR>
 , which repr esent a horizontal rule (a line across the page). If you used a
  s/-+/<HR>/
  
 search-and-r eplace command, it would replace the sequences you wanted, but only when 
 they’re at the beginning of the line. Surprised? In fact,
  s/-+/<HR>/
  adds
  <HR>
  to the 
 beginning of
  every
  line, whether they begin with a sequence of hyphens or not!
  
 Remember, anything that isn’t requir ed is always considered successful. The first time
  !-+""
  is 
 attempted at the start of the string, it matches any hyphens that might be there. However, if 
 ther e ar en’t any, it is still happy to successfully match noth-ing. That’s what star is all about.
  
 Let’s look at a similar example I once saw in a book by a respected author, in which he 
 describes a regular expression to match a number, either integer or float-ing-point. As his 
 expression is constructed, such a number has an optional leading minus sign, any number of 
 digits, an optional decimal point, and any number of digits that follow. His regex is
  !-?[0-
 9]+\.?[0-9]+""
 .
  
 Indeed, this matches such examples as
  1
 ,
  
 -272.37
 ,
  
 129238843.
 ,
  
 .191919
 ,
  
 and even something like
  -.0
 . This is all good, and as expected.
  
 However, how do you think it matches in a string like ‘
 this has no number
 ’,‘
 nothing here
 ’, or 
 even an empty string? Look at the regex closely
  —
  everything
  is optional.
  If
  a number is there, 
 and
  if
  it is at the beginning of the string, it is matched, but
  nothing is requir ed
 . This regex can 
 match all three non-number
  
 29 April 2003 09:22",NA
Matching Delimited Text,"Matching a double-quoted string and matching an
  IP
  addr ess ar e just two exam-ples of a 
 whole class of matching problem that often arises: the desire to match text delimited (or 
 perhaps separated) by some other text. Other examples include:
  
 •
  Matching a C comment, which is surrounded by ‘
 /+
 ’ and ‘
 +/
 ’.
  
 •
  Matching an
  HTML
  tag, which is text wrapped by
  <
 ˙˙˙
 >
 , such as
  <CODE>
 .
  
 •
  Extracting items
  between
  HTML
  tags, such as the ‘
 super exciting
 ’ of the 
  
 HTML
  ‘
 a <I>super 
 exciting</I> offer!
 ’
  
 •
  Matching a line in a
  .mailr c
  file. This file gives email aliases, where each line 
  
 is in the 
 form of
  
 alias
  
 shorthand 
  
 full-address
  
 such as ‘
 alias jeff jfriedl@regex.info
 ’. (Here, the delimiters are the whitespace between 
 each item, as well as the ends of the line.)
  
 •
  Matching a quoted string, but allowing it to contain quotes if they are escaped, 
  
 as in ‘
 a 
 passport needs a ""2\""x3\"" likeness"" of the holder.
 ’
  
 •
  Parsing
  CSV
  (comma-separated values) files.
  
 In general, the requir ements for such tasks can be phrased along the lines of:
  
 1
 . Match the opening delimiter
  
 2
 . Match the main text 
  
 (which is really “match anything that is not the closing delimiter”)
  
 3
 . Match the closing delimiter
  
 As I mentioned earlier, satisfying these requir ements can become complicated when the 
 closing delimiter has more than one character, or when it may appear within the main text.
  
 Allowing escaped quotes in double-quoted strings
  
 Let’s look at the
  2\""x3\""
  example, where the closing delimiter is a quote, yet can appear 
 within the main part if escaped. It’s easy enough to match the opening and closing quotes; 
 the trick is to match the main text without overshooting the closing quote. Thinking clearly 
 about which items the main text allows, we know that if a character is not a double quote (in 
 other words, if it’s
  ![ˆ""]""
  ), it is certainly okay. However, if it
  is
  a double quote, it is okay if 
 preceded by a backslash. Translating that literally, using lookbehind ( 132) for the “if 
 preceded” part, it becomes 
 !""
 (
 [ˆ""]<(?<=\\)""
 )
 +""
 , which indeed properly matches our
  2\""x3\""
  
 example.
  
 29 April 2003 09:22",NA
Knowing Your Data and Making Assumptions,"This is an opportune time to highlight a general point about constructing and using regular 
 expressions that I’ve briefly mentioned a few times. It is important to be aware of the 
 assumptions made about the kind of data with which, and situa-tions in which, a regular 
 expression will be used. Even something as simple as
  !a 
 assumes that the target data is in the 
 same character encoding ( 105) as the author intends. This is pretty much common sense, 
 which is why I haven’t been too picky about saying these things.
  
 However, many assumptions that might seem obvious to one person are not nec-essarily 
 obvious to another. For example, the solution in the previous section assumes that escaped 
 newlines shouldn’t be matched, or that it will be applied in a dot-matches-all mode ( 110). If 
 we really want to ensure that dot can match a newline, we should write that by using
  !(?s:.)""
 , 
 if supported by the flavor.
  
 Another assumption made in the previous section is the type of data to which the regex will 
 be applied, as it makes no provisions for any other uses of double quotes in the data. If you 
 apply it to source code from almost any programming language, for example, you’ll find that 
 it breaks because there can be double quotes within comments.
  
 Ther e is nothing wrong with making assumptions about your data, or how you intend a 
 regex to be used. The problems, if any, usually lie in overly optimistic
  
 29 April 2003 09:22",NA
Str ipping Leading and Trailing Whitespace,"Removing leading and trailing whitespace from a line is not a challenging prob-lem, but it’s 
 one that seems to come up often. By far the best all-around solution is the simple use of two 
 substitutions:
  
 s/ˆ\s+//; 
  
 s/\s+$//;
  
 As a measure of efficiency, these use
  !+""
  instead of
  !+""
 , since there’s no benefit to doing the 
 substitution unless there is actually whitespace to remove.
  
 For some reason, it seems to be popular to try to find a way to do it all in one expr ession, so 
 I’ll offer a few methods for comparison. I don’t recommend them, but it’s educational to 
 understand why they work, and why they’re not desirable.
  
 s/\s+(.+?)\s+$/$1/s 
  
 This used to be given as a great example of lazy quantifiers, but not any mor e, because 
 people now realize that it’s so much slower than the simple appr oach. (In Perl, it’s 
 about 5× slower). The lack of speed is due to the need to check
  !\s+$""
  befor e
  each
  
 application of the lazy-quantified dot. That requir es a lot of backtracking.
  
 s/ˆ\s+
 (
 (?:.+\S)?
 )
 \s+$/$1/s 
  
 This one looks more complex than the previous example, but its matching is mor e 
 straightforward, and is only twice as slow as the simple approach. After the initial
  !ˆ\s+""
  
 has bypassed any leading whitespace, the
  ! .+""
  in the middle matches all the way to the 
 end of the text. The
  !\S""
  that follows forces it to backtrack to the last non-whitespace 
 in the text, thereby leaving the trailing whitespace matched by the final
  !\s+$""
 , outside 
 of the capturing parentheses.
  
 The question mark is needed so that this expression works properly on a line that has 
 only whitespace. Without it, it would fail to match, leaving the white-space-filled line 
 unchanged.
  
 s/ˆ\s+;\s+$//g 
  
 This is a commonly thought-up solution that, while not incorrect (none of these are 
 incorr ect), it has top-level alternation that removes many optimiza-tions (covered in 
 the next chapter) that might otherwise be possible.
  
 The
  /g
  modifier is requir ed to allow each alternative to match, to remove both leading
  
 and
  trailing whitespace. It seems a waste to use
  /g
  when we know we intend at most 
 two matches, and each with a differ ent subexpr es-sion. This is about 4× slower than 
 the simple approach.
  
 29 April 2003 09:22",NA
HTML,NA,NA
-Related Examples,"In Chapter 2, we saw an extended example that converted raw text to
  HTML 
 ( 67), including 
 regular expressions to pluck out email addresses and
  http
  URL
 s fr om the text. In this 
 section, we’ll do a few other
  HTML
 -r elated tasks.",NA
Matching an,NA,NA
 HTML,NA,NA
 Tag,"It’s common to see
  !<[ˆ>]+>""
  used to match an
  HTML
  tag. It usually works fine, such as in 
 this snippet of Perl that strips tags:
  
 $html =˜ s/<[ˆ>]+>//g;
  
 However, it matches improperly if the tag has ‘
 >
 ’ within it, as with this perfectly valid
  HTML
 :
  
 <
 input name=dir value="">""
 >
 . Although it’s not common or recom-mended,
  HTML
  allows a 
 raw ‘
 <
 ’ and ‘
 >
 ’ to appear within a quoted tag attribute. Our simple
  !<[ˆ>]+>""
  doesn’t allow for 
 that, so, we must make it smarter.
  
 Allowed within the ‘
 <
 ˙˙˙
 >
 ’ are quoted sequences, and “other stuff” characters that may appear 
 unquoted. This includes everything except ‘
 >
 ’ and quotes.
  HTML 
 allows both single- and 
 double-quoted strings. It doesn’t allow embedded quotes to be escaped, which allows us to 
 use simple regexes
  !""[ˆ""]+""
  and
  !’[ˆ’]+’""
  to match them.
  
 Putting these together with the “other stuff” regex
  ![ˆ’"">]""
 , we get:
  
 !<
 (
 ""[ˆ""]+""<’[ˆ’]+’<[ˆ’"">]
 )
 ,>
  
 That may be a bit confusing, so how about the same thing shown with comments in a free-
 spacing mode:
  
 <
  
 (
  
 ""[ˆ""]+""
  
 #
  Opening ""<""
  
 #
  
 Any amount of . . .
  
 #
  
 double-quoted string,
  
 >
  
 )+
  
 ;
  
 #
  
 or . . .
  
 ’[ˆ’]+’
  
 #
  
 single-quoted string,
  
 ;
  
 #
  
 or . . .
  
 [ˆ’"">] 
  
 #
  
 ""other stuff""
  
 #
  
 #
  Closing "">""
  
 29 April 2003 09:22",NA
Matching an,NA,NA
 HTML,NA,NA
 Link,"Let’s say that now we want to match sets of
  URL
  and link text from a document, such as 
 pulling the marked items from:
  
 ˙˙˙
 <a href=""http://www.oreilly.com"">O’Reilly And Associates</a>
 ˙˙˙
  
 Because the contents of an
  <A>
  tag can be fairly complex, I would approach this task in two 
 parts. The first is to pluck out the “guts” of the
  <A>
  tag, along with the link text, and then 
 pluck the
  URL
  itself from those
  <A>
  guts.
  
 A simplistic approach to the first part is a case-insensitive, dot-matches-all applica-tion of
  
 !<a\b([ˆ>]+)>(.+?)</a>""
 , which features the lazy star quantifier. This puts the
  <A>
  guts into
  
 $1
  and the link text into
  $2
 . Of course, as earlier, instead of 
 ![ˆ>]+""
  I should use what we 
 developed in the previous section. Having said that, I’ll continue with this simpler version, 
 for the sake of keeping that part of the regex shorter and cleaner for the discussion.
  
 Once we have the
  <A>
  guts in a string, we can inspect them with a separate regex. In them, 
 the
  URL
  is the value for the
  href=
 value
  attribute.
  HTML
  allows spaces on either side of the 
 equal sign, and the value can be quoted or not, as described in
  
 29 April 2003 09:22",NA
Examining an,NA,NA
 HT TP URL,"Now that we’ve got a
  URL
 , let’s see if it’s an
  http
  URL
 , and if so, pluck it apart into its 
 hostname and path components. Since we know we have something intended to be a
  URL
 , 
 our task is made much simpler than if we had to
  identify
  a
  URL
  fr om among random text. 
 That much more dif ficult task is investigated a bit later in this chapter.
  
 So, given a
  URL
 , we mer ely need to be able to recognize the parts. The hostname is 
 everything after
  !ˆhttp://""
  but before the next slash (if there is another slash), and the path is 
 everything else:
  !ˆhttp://([ˆ/]+)(/.+)?$
  
 Actually, a
  URL
  may have an optional port number between the hostname and the path, with 
 a leading colon:
  !ˆhttp://([ˆ/
 :
 ]+)
 (:(\d+))?
 (/.+)?$
  
 Her e’s a Perl snippet to report about a
  URL
 :
  
 if ($url =˜ m{ˆhttp://([ˆ/:]+)(:(\d+))?(/.+)?$}i) 
  
 { 
  
 my $host = $1; 
  
 my $port = $3 ;; 80; #
  Use $3 if it exists; otherwise default to 80. 
  
 my $path = $4 ;; ""/""; #
  Use $4 if it exists; otherwise default to ""/"".
  
 print ""host: $host\n""; 
  
 print ""port: $port\n""; 
  
 print ""path: $path\n""; 
  
 } else { 
  
 print ""not an http url\n""; 
  
 }",NA
Validating a Hostname,"In the previous example, we used
  ![ˆ/:]+""
  to match a hostname. Yet, in Chapter 2 ( 76), we 
 used the more complex
  ![-a-z]+(\.[-a-z]+)+\.(com;edu;
 ˙˙˙
 ;info)""
 . Why the differ ence in 
 complexity for finding ostensibly the same thing?
  
 Well, even though both are used to “match a hostname,” they’r e used quite differ-ently. It’s 
 one thing to pluck out something from a known quantity (e.g., from something you know to 
 be a
  URL
 ), but it’s quite another to accurately and unam-biguously pluck out that same type 
 of something from among random text. Specif-ically, in the previous example, we made the 
 assumption that what comes after the‘
 http://
 ’ is a hostname, so the use of
  ![ˆ/:]+""
  mer ely to 
 fetch it is reasonable. But in the Chapter 2 example, we use a regex to find a hostname in 
 random text, so it must be much more specific.
  
 Now, for a third angle on matching a hostname, we can consider validating host-names with 
 regular expressions. In this case, we want to check whether a string is a well-for med, 
 syntactically correct hostname. Officially, a hostname is made up of dot-separated parts, 
 where each part can have
  ASCII
  letters, digits, and hyphens, but a part can’t begin or end 
 with a hyphen. Thus, one part can be matched with
  
 29 April 2003 09:22",NA
Link Checker in VB.NET,"This Program reports on links within the
  HTML
  in the variable
  Html
 :
  
 Imports System.Text.RegularExpressions 
  
  
 + 
  
  
 + 
  
  
 +
  
 ’
  Set up the regular expressions we’ll use in the loop 
  
 Dim ARRegex as Regex = New Regex( 
  
 R 
  
 ""<a\b(?<guts>[ˆ>]+)>(?<Link>.+?)</a>"", R 
  
 RegexOptions.IgnoreCase)
  
 Dim GutsRegex as Regex = New Regex( R 
  
  
 ""\b HREF 
  
 (?# ’href’ attribute 
  
 )"" & R 
  
 ""\s+ = \s+ 
  
 (?# ’=’ with optional whitespace )"" & R 
  
 ""(?: 
  
 (?# 
  
  
 Value is ... 
  
 )"" & R 
  
 "" 
  
 """"(?<url>[ˆ""""]+)"""" 
  
 (?# 
  
  
 double-quoted string, 
  
 )"" & R 
  
 "" 
  
 ; 
  
 (?# 
  
  
 or ... 
  
 )"" & R 
  
 ""
  
 ’(?<url>[ˆ’]+)’ 
  
 (?# 
  
  
 single-quoted string, 
  
 )"" & R 
  
 "" 
  
 ; 
  
 (?# 
  
  
 or ... 
  
 )"" & R 
  
 "" 
  
 (?<url>[ˆ’"""">\s]+) 
  
  
 (?#
   
 ’other stuff’
  
 )"" & R 
  
 "") 
  
 (?# 
   
  
 )"", 
  
 R 
  
 RegexOptions.IgnoreCase OR RegexOptions.IgnorePatternWhitespace)
  
 ’
  Now check the ’Html’ Variable . . .
  
 Dim CheckA as Match = ARRegex.Match(Html)
  
 ’
  For each match within . . .
  
 While CheckA.Success
  
  
 ’
  We matched an <a> tag, so now check for the URL.
  
  
 Dim UrlCheck as Match = R 
  
  
  
 GutsRegex.Match(CheckA.Groups(""guts"").Value) 
  
  
 If UrlCheck.Success
  
  
  
 ’
  We’ve got a match, so have a URL/link pair 
  
  
  
 Console.WriteLine(""Url "" & UrlCheck.Groups(""url"").Value & R 
  
  
 "" WITH 
 LINK "" & CheckA.Groups(""Link"").Value) 
  
 End If 
  
  
 CheckA = CheckA.NextMatch 
  
 End While
  
 A few things to notice:
  
 •
  VB.NET programs using regular expressions requir e that first
  Imports 
  
 line to 
 tell the compiler what object libraries to use.
  
 •
  I’ve used
  !(?#
 ˙˙˙
 )""
  style comments because it’s inconvenient to get a new-line into a 
 VB.NET string, and normal ‘
 #
 ’ comments carry on until the next newline or the 
 end of the string (which means that the first one would make the entire rest of the 
 regex a comment). To use normal
  !#
 ˙˙˙
 comments, add
  &chr(10)
  at the end of each 
 line ( 414).
  
 •
  Each double quote in the regex requir es ‘
 """"
 ’ in the literal string ( 102).
  
 •
  Named capturing is used in both expressions, allowing the more descrip-
  
 tive
  
 Groups(""url"")
  instead of
  Groups(1)
 ,
  Groups(2)
 , etc.
  
 29 April 2003 09:22",NA
Plucking Out a,NA,NA
 URL,NA,NA
 in the Real World,"Working for Yahoo! Finance, I write programs that process incoming financial news and 
 data feeds. News articles are usually provided to us in raw text, and my pr ograms convert 
 them to
  HTML
  for a pleasing presentation. (Read financial news
  
 29 April 2003 09:22",NA
Extended Examples,"The next few examples illustrate some important techniques about regular expres-
  
 sions. The discussions are longer, and show more of the thought processes and
  
 mistaken paths that eventually lead to a working conclusion.",NA
Keeping in Sync with Your Data,"Let’s look at a lengthy example that might seem a bit contrived, but which illus-
  
 trates some excellent points on why it’s important to keep in sync with what
  
 you’r e trying to match (and provides some methods to do so).
  
 Let’s say that your data is a series of five-digit
  US
  postal codes (
 ZIP
  codes) that are
  
 run together, and that you need to retrieve all that begin with, say,
  44
 . Her e is a
  
 sample line of data, with the codes we want to retrieve in bold:
  
 03824531449411615213
 44182
 95035
 44272
 752010217443235
  
 29 April 2003 09:22",NA
Building Up a Regex Through Var iables in Java,"String SubDomain 
  
 = ""(?i:[a-z0-9];[a-z0-9][-a-z0-9]+[a-z0-9])""; String TopDomains = 
 ""(?x-i:com\\b 
  
 \n"" + 
  
  
  
 "" 
  
 ;edu\\b 
  
 \n"" + 
  
  
  
 "" 
  
  
 ;biz\\b 
  
 \n"" + 
  
  
 "" 
  
 ;in(?:t;fo)\\b 
 \n"" + 
  
  
  
 "" 
  
 ;mil\\b 
  
 \n"" + 
  
  
  
 "" 
  
  
 ;net\\b 
  
 \n"" + 
  
  
 "" 
  
 ;org\\b 
  
 \n"" 
 + 
  
  
  
 "" 
  
 ;[a-z][a-z]\\b \n"" + //
  country codes 
  
  
 "") 
  
  
  
 \n""; String Hostname = ""(?:"" + SubDomain + ""\\.)+"" + 
 TopDomains;
  
 String NOTRIN 
  
 = "";\""’<>()\\[\\]\\{\\}\\s\\x7F-\\xFF""; 
  
 String NOTREND = ""!.,?""; 
  
 String ANYWHERE = ""[ˆ"" + NOTRIN + NOTREND + ""]""; 
  
 String EMBEDDED = ""["" + NOTREND + ""]""; 
  
 String UrlPath 
  
 = ""/""+ANYWHERE + ""+(""+EMBEDDED+""+""+ANYWHERE+""+)+"";
  
 String Url = 
  
 ""(?x: 
  
 \n""+ "" 
  
 \\b 
  
 \n""+ "" 
  
 ## match the hostname part 
  
  
 \n""+ "" 
  
 ( 
  
  
 \n""+ "" 
   
 (?: ftp 
 ; http s? ): // [-\\w]+(\\.\\w[-\\w]+)+ \n""+ "" 
  
  
 ; 
  
   
 \n""+ "" 
  
  
 "" + Hostname + "" 
  
 \n""+ "" 
  
 ) 
   
 \n""+ "" 
  
  
 # allow optional port 
  
 \n""+ "" 
  
 (?: \\d+ )? 
  
 \n""+ "" 
   
   
 \n""+ "" 
  
  
 # rest of url is optional, and begins with / 
  
 \n""+ "" 
 (?: "" + UrlPath + "")? 
  
 \n""+ 
 "")"";
  
 //
  Now convert string we’ve built up into a real regex object 
 Pattern 
 UrlRegex = Pattern.compile(Url); //
  Now ready to apply to raw 
 text to find urls . . .
  
 + 
  
 + 
  
 +
  
 As a starting point, consider that
  !\d\d\d\d\d""
  can be used repeatedly to match all the
  ZIP
  
 codes. In Perl, this is as simple as
  @zips = m/\d\d\d\d\d/g;
  to create a list with one
  ZIP
  
 code per element. (To keep these examples less cluttered, they assume the text to be 
 matched is in Perl’s default target variable
  $
 Q
  79.) With other languages, it’s usually a simple 
 matter to call the regex “find” method in a loop. I’d like to concentrate on the regular 
 expression rather than that mechanics particular to each language, so will continue to use 
 Perl to show the examples.
  
 Back to
  !\d\d\d\d\d""
 . Her e’s a point whose importance will soon become appar-ent: the 
 regex never fails until the entire list has been parsed
  —
 ther e ar e absolutely
  
 29 April 2003 09:22",NA
Parsing,NA,NA
 CSV,NA,NA
 Files,"As anyone who’s ever tried to parse a
  CSV
  (Comma Separated Values) file can tell you, it can 
 be a bit tricky. The biggest problem is that it seems every program that pr oduces a
  CSV
  file 
 has a differ ent idea of just what the format should be. In this section, I’ll start off with 
 methods to parse the kind of
  CSV
  file that Microsoft Excel generates, and we’ll move from 
 there to look at some other format permutations.
 †
  
 Luckily, the Microsoft format is one of the simplest. The values, separated by com-mas, are 
 either “raw” (just sitting there between the commas), or within double
  
 † The final code for processing the Microsoft style
  CSV
  files is presented in Chapter 6 ( 271) after the 
  
 ef ficiency 
 issues discussed in that chapter are taken into consideration.
  
 29 April 2003 09:22",NA
CSV,NA,NA
 Processing in Java,"Her e’s the
  CSV
  example with Sun’s
  java.util.regex
 . This is designed to be clear and 
 simple
 —
 a mor e ef ficient version is given in Chapter 8 ( 386).
  
 import java.util.regex.+; 
  
  
 + 
  
  
 + 
  
  
 + 
  
 Pattern
  fieldRegex
  = Pattern.compile( 
  
  
 ""\\G(?:ˆ;,) 
   
 \n""+ 
  
 ""(?: 
  
  
  
   
 \n""+ 
  
 "" # Either a double-quoted field 
 ... \n""+ 
  
 "" \"" 
  
 # field’s opening quote 
  
 \n""+ 
  
 "" 
  
  
 ( 
  
 (?: [ˆ\""]++ ; \""\"" )++ 
  
 ) \n""+ 
  
 "" \"" 
  
 # 
 field’s closing quote 
  
  
 \n""+ 
  
 "" #  ... or ... 
  
  
 \n""+ 
  
 "" ; 
  
  
   
   
 \n""+ 
  
 "" # ... some non-
 quote/non-comma text ... \n""+ 
  
 "" ( [ˆ\"",]+ ) 
   
 \n""+ 
  
 "" ) 
    
   
 \n"", Pattern.COMMENTS); 
 Pattern
  quotesRegex
  = Pattern.compile(""\""\""""); 
  
  
 + 
  
  
 + 
  
  
 + 
  
 //
  Given the string in ’line’, find all the fields . . .
  
 Matcher
  m
  =
  fieldRegex
 .matcher(
 line
 ); 
  
 while (
 m
 .find()) 
  
 { 
  
 String
  field
 ; 
  
 if (
 m
 .group(1) != null) { 
  
  
  
 field
  =
  quotesRegex
 .matcher(
 m
 .group(1)).replaceAll(""\""""); } else { 
  
  
  
 field
  =
  m
 .group(2); 
  
 } 
  
 //
  We can now work with the field . . .
  
 System.out.println(""["" +
  field
  + ""]""); }
  
  
 Another approach.
  
 The beginning of this section noted two approaches to
  
 ensuring we stay properly aligned with the fields. The other is to be sure that a match begins 
 only where a field is allowed. On the surface, this is similar to pr epending
  !ˆ;,""
 , except using 
 lookbehind as with
  !(?<=
 ˆ
 <
 ,
 )""
 .
  
 Unfortunately, as the section in Chapter 3 explains ( 132), even if lookbehind is supported, 
 variable-length lookbehind sometimes isn’t, so this approach may not work. If the variable 
 length is the issue, we could replace
  !(?<=
 ˆ
 <
 ,
 )""
  with 
 !
 (?:
 ˆ<(?<=,)
 )
 ""
 , but this seems overly 
 complex considering that we already have the first approach working. Also, it reverts to 
 relying on the transmission’s bump-along to bypass the commas, so if we’ve made a mistake 
 elsewhere, it could allow a match to begin at a location like ‘
 ˙˙˙
 ""10,000""
 ˙˙˙
 ’. All in all, it just 
 seems safer to
  
 use the first approach.
  
 29 April 2003 09:22",NA
CSV,NA,NA
 Processing in VB.NET,"Imports System.Text.RegularExpressions 
  
  
 + 
  
  
 + 
  
  
 + 
  
 Dim FieldRegex as Regex = New Regex( R 
  
  
 ""(?:ˆ;,) 
  
  
 "" & R 
  
 ""(?: 
  
  
  
  
   
 "" & R 
  
 "" 
  
 (?# 
 Either a doublequoted field ...) 
  
 "" & R 
  
 "" 
  
 """" 
  
 (?# field’s opening quote ) 
  
 "" & R 
  
 "" 
  
 ( 
  
  
 (?> [ˆ""""]+ ; """""""" )+ 
  
 ) 
  
 "" & R 
  
 "" 
  
 """" 
  
 (?# field’s closing quote ) 
  
  
 "" & R 
  
 "" (?# ... or ...) 
  
  
 "" & R 
  
 "" ; 
   
   
   
 "" & R 
  
 "" 
  
 (?# ... some non-quote/non-comma text ...) 
  
 "" & R 
  
 "" 
  
 ( [ˆ"""",]+ ) 
   
 "" & R 
  
 "" )"", RegexOptions.IgnorePatternWhitespace)
  
 Dim QuotesRegex as Regex = New Regex("" """" """" "") ’
 A string with two double quotes 
  
 + 
  
  
 + 
  
  
 + 
  
 Dim FieldMatch as Match = FieldRegex.Match(Line) 
  
 While FieldMatch.Success 
  
  
 Dim Field as String 
  
  
 If FieldMatch.Groups(1).Success 
  
  
   
 Field = QuotesRegex.Replace(FieldMatch.Groups(1).Value, """""""") 
  
 Else 
  
  
   
 Field = FieldMatch.Groups(2).Value 
  
  
 End If
  
 Console.WriteLine(""["" & Field & ""]"")
  
 ’ Can now work with ’Field’.
 ˙˙˙
  
  
 FieldMatch = FieldMatch.NextMatch 
  
 End While
  
 29 April 2003 09:22",NA
6,NA,NA
Crafting an Efficient Expression,"With the regex-dir ected natur e of an
  NFA
  engine, as is found in Perl, Java pack-ages, the 
 .
 NET
  languages, Python, and
  PHP
  (just to name a few; see the table on page 145 for more), 
 subtle changes in an expression can have major effects on what or how it matches. Issues 
 that don’t matter with a
  DFA
  engine become paramount. The fine control an
  NFA
  engine 
 affords allows you to really
  craft
  an expr ession, although it can sometimes be a source of 
 confusion to the unaware. This chapter helps you learn this art.
  
 At stake are both correctness and efficiency: matching just what you want and no mor e, and 
 doing it quickly. Chapters 4 and 5 examined correctness; here we’ll look at the efficiency-r 
 elated issues of
  NFA
  engines, and how to make them work to our advantage. (
 DFA
 -r elated 
 issues are mentioned when appropriate, but this chapter is primarily concerned with
  NFA
 -
 based engines.) In a nutshell, the key is to understand the full implications of backtracking, 
 and to learn techniques to avoid it where possible. Armed with the detailed understanding of 
 the processing mechanics, not only will you maximize the speed of matches, you will also be 
 able to write more complex expressions with confidence.
  
 In This Chapter 
  
 To arm you well, this chapter first illustrates just how important these 
 issues can be, then prepar es you for some of the more advanced techniques pr esented later 
 by reviewing the basic backtracking described in the previous chapters with a strong 
 emphasis on efficiency and backtracking’s global ramifica-tions. Then we’ll look at some of 
 the common internal optimizations that can have a fairly substantial impact on efficiency, 
 and on how expressions are best written for implementations that employ them. Finally, I 
 bring it all together with some killer techniques to construct lightning-fast
  NFA
  regexes.
  
 221
  
 29 April 2003 20:38",NA
A Sober ing Example,"Let’s start with an example that really shows how important a concern backtrack-ing and 
 efficiency can be. On page 198, we came up with
  !""
 (
 \\.<[ˆ""\\]
 )
 ,""
  to match a quoted string, 
 with internal quotes allowed if escaped. This regex works, but if it’s used with an
  NFA
  
 engine, the alternation applied at each character is very inef ficient. With every “normal” 
 (non-escape, non-quote) character in the string, the engine has to test
  !\\.""
 , fail, and 
 backtrack to finally match with
  ![ˆ""\\]""
 . If used where efficiency matters, we would certainly 
 like to be able to speed this regex up a bit.
  
 29 April 2003 20:38",NA
A Simple Change,NA,NA
—,NA,NA
Placing Your Best Foot Forward,"Since the average double-quoted string has more nor mal characters than escaped ones, one 
 simple change is to swap the order of the alternatives, putting
  ![ˆ""\\] 
 first and
  !\\.""
  second. 
 By placing
  ![ˆ""\\]""
  first, alternation backtracking need be done only when there actually is an 
 escaped item in the string (and once for when the star fails, of course, since all alternatives 
 must fail for the alternation as a whole to stop). Figure 6-1 illustrates this differ ence visually. 
 The reduction of arr ows in the bottom half repr esents the increased number of times when 
 the first alter native matches. That means less backtracking.
  
 Regular Expression 
  
 Literal String
  
 ""(\\.|[^""\\])*""
  
 ""([^""\\]|\\.)*""
  
 ""2\""x3\"" likeness""
  
 ""2\""x3\"" likeness""
  
 - Positions at which an alternation-backtrack occurs
  
 Figur e 6-1: Effects of alternative order (Traditional
  NFA
 )
  
 In evaluating this change, consider:
  
 •
  Does this change benefit a Traditional
  NFA
 ,
  POSIX NFA
 , or both?
  
 •
  Does this change offer the most benefit when the text matches, when the 
  
 match 
 fails, or at all times?
  
 O
 Consider these questions and flip the page to check your answers. Make sure that you have 
 a good grasp of the answers (and reasons) before continuing on to the next section.",NA
Efficienc y Verses Correctness,"The most important question to ask when making any change for efficiency’s sake is whether 
 the change affects the correctness of a match. Reordering alternatives, as we did earlier, is 
 okay only if the ordering is not relevant to the success of a match. Consider
  !""
 (
 \\.<[ˆ""]
 )
 +""
 , 
 which is an earlier ( 197) but flawed version of the regex in the previous section. It’s missing 
 the backslash in the negated char-acter class, and so can match data that should not be 
 matched. If the regex is only ever applied to valid data that
  should
  be matched, you’d never 
 know of the prob-
  
 29 April 2003 20:38",NA
Effects of a Simple Change,"O
 Answers to the questions on page 223.
  
 Ef fect for which type of engine? 
  
 The change has virtually no effect whatso-ever 
 for a
  POSIX NFA
  engine. Since it must eventually try every permutation of the regex 
 anyway, the order in which the alternatives are tried is irrele-vant. For a Traditional
  
 NFA
 , however, ordering the alternatives in such a way that quickly leads to a match is a 
 benefit because the engine stops once the first match is found.
  
 Ef fect during which kind of result? 
  
 The change results in a faster match only when 
 there
  is
  a match. An
  NFA
  can fail only after trying all possible permuta-tions of the 
 match (and again, the
  POSIX NFA
  tries them all anyway). So if indeed it ends up failing, 
 every permutation must have been attempted, so the order does not matter.
  
 The following table shows the number of tests (“tests”) and backtracks (“b.t.”) for 
 several cases (smaller numbers are better):
  
  
 Sample string 
  
 Tr aditional
  NFA
  
 !""(
 \\.
 ;[ˆ""\\])+"" 
  
 !""([ˆ""\\];
 \\.
 )+""
  
 tests 
  
 b.t. tests 
  
 b.t. 
  
 POSIX NFA 
  
 either 
  
 tests 
  
 b.t.
  
  
 ""2\""x3\"" likeness""
  
 32 
  
 14
  
 22 
  
 4
  
 48 
  
 30
  
 ""makudonarudo""
  
 28 
  
 14
  
 16 
  
 2
  
 40 
  
 26
  
 ""very
 ...
 99 more chars
 ...
 long""
  
 218 
  
 109
  
 111 
  
 2
  
 325 
  
 216
  
 ""No \""match\"" here
  
 124 
  
 86
  
 124 
  
 86
  
 124 
  
 86
  
 As you can see, the
  POSIX NFA
  results are the same with both expressions, while the 
 Traditional
  NFA
 ’s perfor mance incr eases (backtracks decrease) with the new 
 expression. Indeed, in a non-match situation (the last example in the table), since both 
 engine types must evaluate all possible permutations, all results are the same.
  
 lem. Thinking that the regex is good and reordering alternatives now to gain more ef 
 ficiency, we’d be in real trouble. Swapping the alternatives so that
  ![ˆ""]""
  is first actually 
 ensures that it matches incorrectly every time the target has an escaped quote:
  
 ""You need a 2\""3\"" photo.""
  
 So, be sure that you’re comfortable with the correctness of a match before you worry too 
 much about efficiency.
  
 29 April 2003 20:38",NA
Advancing Further,NA,NA
—,NA,NA
Localizing the Greediness,"Figur e 6-1 makes it clear that in either expression, the star must iterate (or cycle, if you like) 
 for each normal character, entering and leaving the alternation (and the par entheses) over 
 and over. These actions involve overhead, which means extra work
 —
 extra work that we’d 
 like to eliminate if possible.
  
 Once while working on a similar expression, I realized that I could optimize it by taking into 
 account that since
  ![ˆ""\\]""
  matches the “normal” (non-quote, non-backslash) case, using
  
 ![ˆ""\\]
 +
  ""
  instead allows one iteration of
  (
 ˙˙˙
 )+
  to read as many normal characters as there are 
 in a row. For strings without any escapes, this would be the entire string. This allows a match 
 with almost no backtracking, and also reduces the star iteration to a bare minimum. I was 
 very pleased with myself for making this discovery.
  
 We’ll look at this example in more depth later in this chapter, but a quick look at some 
 statistics clearly shows the benefit. Figure 6-2 looks at this example for a Tra-ditional
  NFA
 . 
 In comparison to the original
  !""
 (
 \\.<[ˆ""\\]
 )
 ,""""
  (the top of the upper pair of Figure 6-2), 
 alternation-r elated backtracks and star iterations are both reduced. The lower pair in Figure 
 6-2 illustrates that perfor mance is enhanced even further when this change is combined with 
 our previous reordering.
  
 Regular Expression 
  
 Literal String
  
 "" ( \ \ . | [ ^ "" \ \ ] ) * ""
  
 "" 2 \ "" x 3 \ ""  l i k e n e s s ""
  
 "" ( \ \ . | [ ^ "" \ \ ] + ) * ""
  
 "" 2 \ "" x 3 \ ""  l i k e n e s s ""
  
  
 "" ( [ ^ "" \ \ ] | \ \ . ) * ""
   
 "" 2 \ "" x 3 \ ""  l i k e n e s 
 s ""
  
 "" ( [ ^ "" \ \ ] + | \ \ . ) * ""
  
 "" 2 \ "" x 3 \ ""  l i k e n e s s ""
  
 - Positions at which an alternation-backtrack occurs
  
 Figur e 6-2: Effects of an added plus (Traditional
  NFA
 )
  
 The big gain with the addition of plus is the resulting reduction in the number of alter nation 
 backtracks, and, in turn, the number of iterations by the star. The star quantifies a 
 parenthesized subexpression, and each iteration entails some amount
  
 29 April 2003 20:38",NA
Reality Check,"Yes, I was quite pleased with myself for this discovery. However, as wonder ful as this 
 “enhancement” might seem, it is really a disaster waiting to happen. You’ll notice that when 
 extolling its virtues, I didn’t give statistics for a
  POSIX NFA
  engine.
  
 If I had, you might have been surprised to find the
  ""very
  
 ˙˙˙
  long""
  example
  
 requir es over
  thr ee hundr ed thousand million billion trillion
  backtracks (for the record, the actual 
 count would be 324,518,553,658,426,726,783,156,020,576,256, or about 325 nonillion). 
 Putting it mildly, that is a
  LOT
  of work. This would take well over 50
  quintillion
  years, take or 
 leave a few hundred trillion millennia.
 †
  
 Quite surprising indeed! So, why does this happen? Briefly, it’s because something in the 
 regex is subject to both an immediate plus and an enclosing star, with noth-ing to differ 
 entiate which is in control of any particular target character. The result-ing nondeterminism 
 is the killer. The next section explains a bit more.
  
 “Exponential” matches
  
 Befor e adding the plus,
  ![ˆ""\\]""
  was subject to only the star, and the number of possible 
 ways for the effective
  !([ˆ""\\]),""
  to divvy up the line was limited. It matched one character, 
 then another, and so forth, until each character in the tar-get text had been matched at most 
 one time. It may not have matched everything in the target, but at worst, the number of 
 characters matched was directly propor-tional to the length of the target string. The possible 
 amount of work rose in step with the length of the target string.
  
 †
  The reported time is an estimation based on other benchmarks; I did not actually run the test that long.
  
 29 April 2003 20:38",NA
A Global View of Backtracking,"On a local level, backtracking is simply the retur n to attempt an untried option. That’s 
 simple enough to understand, but the global implications of backtracking ar e not as easily 
 grasped. In this section, we’ll take an explicit look at the details of backtracking, both during 
 a match and during a non-match, and we’ll try to make some sense out of the patterns we 
 see emerge.
  
 Let’s start by looking closely at some examples from the previous chapters. From page 165, 
 if we apply
  !"".+""
  to
  
 The name ""McDonald’s"" is said ""makudonarudo"" in Japanese
  
 we can visualize the matching action as shown in Figure 6-3.
  
 The regex is attempted starting at each string position in turn, but because the initial quote 
 fails immediately, nothing interesting happens until the attempt start-ing at the location 
 marked
  A
 . At this point, the rest of the expression is attempted, but the transmission ( 148) 
 knows that if the attempt turns out to be a dead end, the full regex can still be tried at the 
 next position.
  
 The
  ! .+""
  then matches to the end of the string, where the dot is unable to match the 
 nothingness at the end of the string and so the star finally stops. None of the 46 characters 
 matched by
  ! .+""
  is requir ed, so while matching them, the engine accumulated 46 more 
 situations to where it can backtrack if it turns out that it matched too much. Now that
  ! .+""
  
 has stopped, the engine backtracks to the last of those saved states, the “ try
  !"".+""
  at
  
 ˙˙˙
 anese
  ” state.
  
 This means that we try to match the closing quote at the end of the string. Well, a quote can 
 match nothingness no better than dot, so this fails too. The engine backtracks again, this 
 time trying to match the closing quote at
 ˙˙˙
 Japanese
 , which
  
 also fails.
  
 29 April 2003 20:38",NA
More Work for a,NA,NA
 POSIX NFA,"For
  POSIX NFA
 , the match noted earlier is remember ed as “the longest match we’ve seen 
 so far,” but all remaining states must still be explored to see whether they could come up 
 with a longer match. We know this won’t happen in this case, but the regex engine must find 
 that out for itself.
  
 So, the states are tried and immediately discarded except for the remaining two sit-uations 
 where ther e is a quote in the string available to match the final quote. Thus, the sequences
  
 D
 -
 E
 -
 F
  and
  F
 -
 G
 -
 H
  ar e similar to
  B
 -
 C
 -
 D
 , except the matches at 
 F
  and
  H
  ar e discarded as 
 being shorter than a previously found match at
  D
  
 By
  I
 , the only remaining backtrack is the “bump along and retry” one. However, since the 
 attempt starting at
  A
  was
  able to find a match (three in fact), the
  POSIX NFA
  engine is finally 
 done and the match at
  D
  is reported.
  
 29 April 2003 20:38",NA
Work Required During a Non-Match,"We still need to look at what happens when there is no match. Let’s look at 
 !"".+""!""
 . We know 
 this won’t match our example text, but it comes close on a num-ber of occasions throughout 
 the match attempt. As we’ll see, that results in much mor e work.
  
 Figur e 6-4 illustrates this work. The
  A
 -
 I
  sequence looks similar to that in Figure 6-3. One 
 differ ence is that this time it does not match at point
  D
  (because the end-ing exclamation 
 point can’t match). Another differ ence is that the entire sequence in Figure 6-4 applies to 
 both Traditional and
  POSIX NFA
  engines: finding no match, the Traditional
  NFA
  must try as 
 many possibilities as the
  POSIX NFA
  —
  all of them.
  
 KEY
  
 Match of:
  "".*""!
  
 attempt-but-fail 
  
 backtrack-and-attempt, but 
 fail
  
 successful match of regex component
  
 The name ""McDonald’s"" is said ""makudonarudo"" in Japanese
  
 Sub-attempt
  
 A
  
 I
  
 G
  
 J
  
 H
  
 E
  
 Q
  
 F
  
 C
  
 D
  
 B
  
 Sub-attempt
  
 P
  
 N
  
 O
  
 L
  
 M
  
 K
  
 Sub-attempt
  
 S
  
 T
  
 R
  
 U
  
 Sub-attempt
  
 V
  
 X
  
 W
  
 Y
  
 Figur e 6-4: Failing attempt to match
  !
 "".
 +
 ""!
  
 Since there is no match from the overall attempt starting at
  A
  and ending at
  I
 , the 
 transmission bumps along to retry the match. Attempts eventually starting at points 
 J
 ,
  Q
 , 
 and
  V
  look promising, but fail similarly to the attempt at
  A
 . Finally at
  Y
 , ther e ar e no more 
 positions for the transmission to try from, so the overall attempt fails. As Figure 6-4 shows, 
 it took a fair amount of work to find this out.
  
 29 April 2003 20:38",NA
Being More Specific,"As a comparison, let’s replace the dot with
  ![ˆ""]""
 . As discussed in the previous chapter, this 
 gives less surprising results because it is more specific, and the end result is that with it, the 
 new regex is more efficient to boot. With
  !""
 [ˆ""]
 +""!""
 , the 
 ![ˆ""]+""
  can’t get past the closing 
 quote, eliminating much matching and subse-quent backtracking.
  
 Figur e 6-5 shows the failing attempt (compare to Figur e 6-4). As you can see, much less 
 backtracking is needed. If the differ ent results suit your needs, the reduced backtracking is a 
 welcome side effect.
  
  
  
 KEY
  
  
  
  
 Match of:
  ""[^""]*""!
  
 attempt-but-fail
  
  
 backtrack-and-attempt, but fail
  
  
 successful match of regex component
  
 The name ""McDonald’s"" is said ""makudonarudo"" in Japanese
  
 Sub-attempt
  
 A
  
 I
  
 G
  
 H
  
 N
  
 O
  
 S
  
 T
  
 Sub-attempt
  
 J
  
 P
  
 Sub-attempt
  
 Q
  
 U
  
 Sub-attempt
  
 V
  
 X
  
 W
  
 Y
  
 Figur e 6-5: Failing attempt to match
  !
 ""[ˆ""]
 +
 ""!",NA
Alter nation Can Be Expensive,"Alter nation can be a leading cause of backtracking. As a simple example, let’s use our
  
 makudonarudo
  test string to compare how
  !u;v;w;x;y;z""
  and
  ![uvwxyz]""
  go about matching. 
 A character class is usually a simple test,
 †
 so
  ![uvwxyz]""
  suf fers only the bump-along 
 backtracks (34 of them) until we match at:
  
 The name ""McDonald’s"" is said ""mak
 u
 donarudo"" in Japanese
  
 † Some implementations are not as efficient as others, but it’s safe to assume that a class is always 
  
 faster than 
 the equivalent alternation.
  
 29 April 2003 20:38",NA
Benchmarking,"Because this chapter talks a lot about speed and efficiency, and I often mention benchmarks 
 I’ve done, I’d like to mention a few principles of benchmarking. I’ll also show simple ways to 
 benchmark in a few languages.
  
 Basic benchmarking is simply timing how long it takes to do some work. To do the timing, 
 get the system time, do the work, get the system time again, and report the differ ence 
 between the times as the time it took to do the work. As an exam-ple, let’s compare
  
 !ˆ(a;b;c;d;e;f;g)+$""
  with
  !ˆ[a-g]+$""
 . We’ll first look at benchmarking in Perl, but will see it in 
 other languages in a bit. Here’s a simple (but as we’ll see, somewhat lacking) Perl script:
  
 use Time::HiRes ’time’; #
  So time() gives a high-resolution value.
  
 $StartTime = time(); 
  
 ""abababdedfg"" =˜ m/ˆ(a;b;c;d;e;f;g)+$/; 
  
 $EndTime = time(); 
  
 printf(""Alternation takes %.3f seconds.\n"", $EndTime - $StartTime);
  
 $StartTime = time(); 
  
 ""abababdedfg"" =˜ m/ˆ[a-g]+$/; 
  
 $EndTime = time(); 
  
 printf(""Character class takes %.3f seconds.\n"", $EndTime - $StartTime);
  
 It looks (and is) simple, but there are some important points to keep in mind while 
 constructing a test for benchmarking:
  
 •
  Time only “interesting” work Time as much of the “work” as possible, but as 
  
 little 
 “non-work” as possible. If there is some initialization or other setup that 
  
 must be 
 done, do it before the starting time is taken. If there’s cleanup, do it 
  
 after the ending 
 time is taken.
  
 •
  Do “enough” work Often, the time it takes to do what you want to test is 
  
 very 
 short, and a computer’s clock doesn’t have enough granularity to give 
  
 meaning to the 
 timing.
  
 29 April 2003 20:38",NA
Know What You’re Measur ing,"It might be interesting to see what happens when the initialization is changed to:
  
 $TimesToDo = 1000000; 
  
 $TestString = ""abababdedfg"";
  
 Now, the test string is 1,000× shorter, but the test is done 1,000× more times. The total 
 number of characters tested and matched by each regex remains the same, and so 
 conceptually, one might think that the amount of “work” should also remain the same the 
 same. Howver, the results are quite differ ent:
  
 Alternation takes 18.167 seconds. 
  
 Character class takes 5.231 seconds.
  
 Both are now much slower than before. This is due to all the extra “non-work”overhead
  —
  
 the update and testing of
  $Count
 , and the setup of the regex engine, now each happen 
 1,000× more than before.
  
 The extra overhead adds almost five seconds to the faster test, but more than 10 seconds to 
 the alternation test. Why is the alternation test affected so much more? It’s mostly due to the 
 extra overhead of the capturing parenthses (which requir e their own extra processing before 
 and after each test, and doing that 1,000× more adds up).
  
 In any case, the point of this change is to illustrate that the results are str ongly influenced by 
 how much real work vs. non-work overtime is part of the timing.",NA
Benchmarking with Java,"Benchmarking Java can be a slippery science, for a number of reasons. Let’s first look at a 
 somewhat naïve example, and then look at why it’s naïve, and at what can be done to make it 
 less so. The listing on the facing page shows the bench-mark example with Java, using Sun’s
  
 java.util.regex
 .
  
 Notice how the regular expressions are compiled in the initialization part of the pr ogram? 
 We want to benchmark the matching speed, not the compile speed.
  
 Speed is dependent upon which virtual machine (
 VM
 ) is used. Sun standard
  JRE
 †
 comes with 
 two virtual machines, a
  client
  VM
  optimized for fast startup, and a 
 server
  VM
  optimized for 
 heavy-duty long-haul work.
  
 † I had to use a shorter string for this test to run on my Linux system, as a longer string somehow tick-les a problem 
 with the
  VM
 , causing the test to abort. Engineers at Sun tell me it’s due to an unex-pected interaction between the 
 aggressively optimizing C compiler used to build the
  VM
  (gcc), and an overly conservative use of Linux’s stack-
 monitoring hooks. It may be fixed as early as Java 1.4.1. To compensate for the shortened string in the current 
 test, I’ve increased the number of times the loop executes the match, so these results should be comparable to 
 the original.
  
 29 April 2003 20:38",NA
Benchmarking with VB.NET,"The benchmark example in VB.NET is shown in the listing on the facing page. On
  
 my system, it produces:
  
 Alternation takes 13.311 seconds 
  
 Character Class takes 1.680 seconds
  
 The .
 NET
  Framework allows a regex to be compiled to an even more efficient
  
 for m, by providing
  RegexOptions.Compiled
  as a second argument to each
  
 Regex
  constructor ( 404). Doing that results in:
  
 Alternation takes 5.499 seconds 
  
 Character Class takes 1.157 seconds
  
 Both tests are faster using the
  Compiled
  option, but alternation sees a greater rela-
  
 tive benefit (its almost 3× faster when
  Compiled
 , but the class version is only
  
 about 1.5× faster), so it seems that alternation benefits from the more efficient
  
 compilation relatively more than a character class does.
  
 29 April 2003 20:38",NA
Benchmarking with Python,"The benchmark example in Python is shown in the listing on the next page.
  
 For Python’s regex engine, I had to cut the size of the string a bit because the
  
 original causes an internal error (“maximum recursion limit exceeded”) within the
  
 regex engine. To compensate, I increased the number of times the test is done by
  
 a proportional amount.
  
 On my system, the benchmark produces:
  
 Alternation takes 10.357 seconds 
  
 Character Class takes 0.769 seconds
  
 29 April 2003 20:38",NA
Benchmarking with Ruby,"Her e’s the benchmark example in Ruby:
  
 TimesToDo=1000 
  
 testString="""" 
  
 for i in 1..1000 
  
 testString += ""abababdedfg"" 
  
 end
  
 Regex1 = Regexp::new(""ˆ(a;b;c;d;e;f;g)+$""); 
  
 Regex2 = Regexp::new(""ˆ[a-g]+$"");
  
 startTime = Time.new.toRf 
  
 for i in 1..TimesToDo 
  
 Regex1.match(testString) 
  
 end 
  
 print ""Alternation takes %.3f seconds\n"" % (Time.new.toRf - startTime);
  
 startTime = Time.new.toRf 
  
 for i in 1..TimesToDo 
  
 Regex2.match(testString) 
  
 end 
  
 print ""Character Class takes %.3f seconds\n"" % (Time.new.toRf - startTime);
  
 On my system, it produces:
  
 Alternation takes 16.311 seconds 
  
 Character Class takes 3.479 seconds
  
 29 April 2003 20:38",NA
Benchmarking with Tcl,"Her e’s the benchmark example in Tcl:
  
 set TimesToDo 1000 
  
 set TestString """" 
  
 for {set i 1000} {$i > 0} {incr i -1} { 
  
 append TestString ""abababdedfg"" 
  
 }
  
 set Count $TimesToDo 
  
 set StartTime [clock clicks -milliseconds] 
  
 for {} {$Count > 0} {incr Count -1} { 
  
 regexp {ˆ(a;b;c;d;e;f;g)+$} $TestString 
  
 } 
  
 set EndTime [clock clicks -milliseconds] 
  
 set Seconds [expr ($EndTime - $StartTime)/1000.0] 
  
 puts [format ""Alternation takes %.3f seconds"" $Seconds]
  
 set Count $TimesToDo 
  
 set StartTime [clock clicks -milliseconds] 
  
 for {} {$Count > 0} {incr Count -1} { 
  
 regexp {ˆ[a-g]+$} $TestString 
  
 } 
  
 set EndTime [clock clicks -milliseconds] 
  
 set Seconds [expr ($EndTime - $StartTime)/1000.0] 
  
 puts [format ""Character class takes %.3f seconds"" $Seconds]
  
 On my system, this benchmark produces:
  
 Alternation takes 0.362 seconds 
  
 Character class takes 0.352 seconds
  
 Wow, they’re both about the same speed! Well, recall from the table on
  
 page 145 that Tcl has a hybrid
  NFA
 /
 DFA
  engine, and these regular expressions are
  
 exactly the same to a
  DFA
  engine. Most of what this chapter talks about simply
  
 does not apply to Tcl. See the sidebar on page 243 for more.",NA
Common Optimizations,"A smart regex implementation has many ways to optimize how quickly it produces
  
 the results you ask of it. Optimizations usually fall into two classes:
  
 •
  Doing something faster 
  
 Some types of operations, such as
  !\d+""
 , are so com-
  
 mon that the engine might have special-case handling set up to execute them
  
 faster than the general engine mechanics would.
  
 •
  Av oiding work 
  
 If the engine can decide that some particular operation is
  
 unneeded in producing a correct result, or perhaps that some operation can
  
 be applied to less text than originally thought, skipping those operations can
  
 result in a time savings. For example, a regex beginning with
  !\A""
  (start-of-line) can 
 match only when started at the beginning of the string, so if no match is
  
 found there, the transmission need not bother checking from other positions.
  
 29 April 2003 20:38",NA
No Free Lunch,"Optimizations often result in a savings, but not always. There’s a benefit only if the amount 
 of time saved is more than the extra time spent checking to see whether the optimization is 
 applicable in the first place. In fact, if the engine checks to see if an optimization is 
 applicable and the answer is “no,” the overall result is
  slower 
 because it includes the fruitless 
 check on top of the subsequent normal application of the regex. So, there’s a balance among 
 how much time an optimization takes, how much time it saves, and importantly, how likely 
 it is to be invoked.
  
 Let’s look at an example. The expression
  !\b\B""
  (
 wor d boundary
  at the same loca-tion as a
  non-
 wor d boundary
 ) can’t possibly match. If an engine were to realize that a regex contained
  
 !\b\B""
  in such a way that it was requir ed for any match, the engine would know that the 
 overall regex could never match, and hence never have to actually apply that regex. Rather, it 
 could always immediately report fail-ur e. If applied to long strings, the savings could be 
 substantial.
  
 Yet, no engine that I know of actually uses this optimization. Why not? Well, first of all, it’s 
 not necessarily easy to decide whether it applies to a particular regex. It’s certainly possible 
 for a regex to have
  !\b\B""
  somewher e in it, yet still match,
 †
 so the engine has to do extra 
 work ahead of time to be absolutely certain. Still, the savings could be truly substantial, so it 
 could be worth doing the extra work if 
 !\b\B""
  was expected to be common. But, it’s not 
 common (I think it’s silly!), so even though the savings could be huge, it’s not worth slowing 
 every other regex by the extra overhead requir ed to do the check.",NA
Ever yone’s Lunch is Different,"Keep this in mind when looking at the various kinds of optimizations that this chapter 
 discusses. Even though I’ve tried to pick simple, clean names for each one, it may well be 
 that every engine that implements it does so in a differ ent way. A seemingly innocuous 
 change in a regex can cause it to become substan-tially faster with one implementation, but 
 substantially slower with another.
  
 † I’ve used
  !\b\B""
  befor e to cause one part of a larger expression to fail, during testing. For example, I 
  
 might insert 
 it at the marked point of
  !
 ˙˙˙
 (this ;this other)
 ˙˙˙
 ""
  to guaranteed failure of the first alter-
  
 native. These days, when I need a “must fail” component, I use
  !(?!)""
 . You can see an interesting Perl-specific 
 example of this on page 333.
  
 29 April 2003 20:38",NA
The Mechanics of Regex Application,"Befor e looking at the ways advanced systems optimize their regex perfor mance, and ways 
 we can take advantage of those optimizations, it’s important to first understand the basics of 
 regex application. We’ve already covered the details about backtracking, but in this short 
 section, we’ll step back a bit to look at the br oader pictur e.
  
 Her e ar e the main steps taken in applying a regular expression to a target string:
  
 1
 .
  
 Regex Compilation
  
 The regex is inspected for errors, and if valid, compiled
  
 into an internal form.
  
 2
 .
  
 Tr ansmission Begins
  
 The transmission “positions” the engine at the start of
  
 the target string.
  
 3
 .
  
 Component Tests
  
 The engine works through the regex and the text, moving
  
 fr om component to component in the regex, as described in Chapter 4. We’ve alr eady 
 cover ed backtracking for
  NFA
 s in great detail, but there are a few additional points to 
 mention:
  
 •
  With components next to each other, as with the
  !S""
 ,
  !u""
 ,
  !b""
 ,
  !j""
 ,
  !e""
  . . . ,  of 
  
 !Subject""
 , each component is tried in turn, stopping only if one fails.
  
 •
  With quantifiers, control jumps between the quantifier (to see whether the quantifier 
 should continue to make additional attempts) and the com-ponent quantified (to 
 test whether it matches).
  
 •
  Ther e is some overhead when control enters or exits a set of capturing par 
 entheses. The actual text matched by the parentheses must be remem-ber ed so 
 that
  $1
  and the like are supported. Since a set of parentheses may be “backtracked 
 out of,” the state of the parentheses is part of the states used for backtracking, so 
 entering and exiting capturing parenthe-ses requir es some modification of that 
 state.
  
 4
 . Finding a Match 
  
 If a match is found, a Traditional
  NFA
  “locks in” the current 
  
 state and reports overall success. On the other hand, a
  POSIX NFA
  mer ely 
  
 remembers the possible match if it is the longest seen so far, and continues 
  
 with any 
 saved states still available. Once no more states are left, the longest 
  
 match that was 
 seen is the one reported.
  
 5
 . Tr ansmission Bump-Along 
  
 If no match is found, the transmission bumps the 
  
 engine along to the next character in the text, and the engine applies the 
  
 regex all 
 over again (going back to step 3).
  
 6
 . Overall Failure If no match is found after having applied the engine at every 
  
 character 
 in the target string (and after the last character as well), overall fail-
  
 ur e must be 
 reported.
  
 29 April 2003 20:38",NA
Pre-Application Optimizations,"A good regex engine implementation can reduce the amount of work that needs to be done 
 before the actual application of a regex, and sometimes can even decide quickly beforehand 
 that the regex can never match, thereby avoiding the need to even apply the regex in the first 
 place.
  
 Compile caching
  
 Recall the mini mail program from Chapter 2 ( 57). The skeleton of the main loop, which 
 processes every line of the header, looks like:
  
 while (
 ˙˙˙
 ) { 
  
 if ($line =˜ m/
 ˆ\s
 ,
 $
 / )
 ˙˙˙
  
 if ($line =˜ m/
 ˆSubject: (.
 ,
 )
 /)
 ˙˙˙
  
 if ($line =˜ m/
 ˆDate: (.
 ,
 )
 /)
 ˙˙˙
  
 if ($line =˜ m/
 ˆReply-To: (\S+)
 /)
 ˙˙˙
  
 if ($line =˜ m/
 ˆFrom: (\S+) \(([ˆ()]
 ,
 )\)
 /)
 ˙˙˙
  
  
  
 + 
  
  
  
 + 
  
  
  
 + 
  
 }
  
 The first thing that must be done before a regular expression can be used is that it must be 
 inspected for errors, and compiled into an internal form. Once compiled, that internal form 
 can be used in checking many strings, but will it? It would cer-tainly be a waste of time to 
 recompile each regex each time through the loop. Rather, it is much more time efficient (at 
 the cost of some memory) to save, or 
 cache
 , the internal form after it’s first compiled, and 
 then use that same internal for m for each subsequent application during the loop.
  
 The extent to which this can be done depends on the type of regular-expr ession handling 
 the application offers. As described starting on page 93, the three types of handling are
  
 integrated
 ,
  pr ocedural
 , and
  object-oriented
 .
  
 Compile caching in the integrated approach 
  
 An integrated approach, like Perl’s and awk’s, allows compile caching to be done with ease. 
 Internally, each regex is associated with a particular part of the code, and the compiled form 
 can be associated with the code the first time it’s executed, and merely refer enced 
 subsequent times. This provides for the maximum opti-mization of speed at the cost of the 
 memory needed to hold all the cached expr essions.
  
 The ability to interpolate variables into the regex operand (that is, use the contents of a 
 variable as part of the regular expression) throws somewhat of a monkey wr ench into the 
 caching plan. When variables are interpolated, as with something like
  m/
 ˆSubject: \Q
  
 $DesiredSubject
  \E\s+$
 /
 , the actual regular expression
  
 29 April 2003 20:38",NA
DFA,NA,NA
"s, Tcl, and Hand-Tuning Regular Expressions","For the most part, the optimizations described in this chapter simply don’t apply to
  
 DFA
 s. The
  compile caching
  optimization, discussed on page 242, does apply to all types 
 of engines, but none of the techniques for hand-tun-ing discussed throughout this 
 chapter apply to
  DFA
 s. As Chapter 4 makes clear ( 157), expressions that are logically 
 equivalent —
  !this;that""
  and 
 !th(is;at)""
 , for example —
  ar e
  equivalent to a
  DFA
 . It’s 
 because they’re not necessarily equivalent to an
  NFA
  that this chapter exists.
  
 But what about Tcl, which has a hybrid
  DFA
 /
 NFA
  engine? Tcl’s regex engine was 
 custom built for Tcl by regular-expr ession legend Henry Spencer ( 88), who has done 
 a fantastic job blending the best of both
  DFA
  and
  NFA
  worlds.
  
 Henry noted himself in an April 2000 Usenet posting:
  
 In general, the Tcl RE-matching engine is much less sensitive to the exact for m of 
 the RE than traditional matching engines. Things that it does quickly will be fast no 
 matter how you write them; things that it does slowly will be slow no matter how 
 you write them. The old folklore about hand-optimizing your REs simply does not 
 apply.
  
 Henry’s Tcl regex engine is an important step forward. If this technology wer e mor e 
 widespr ead, much of this chapter would not be needed.
  
 may change from iteration to iteration because it depends on the value in the vari-able, 
 which can change from iteration to iteration. If it changes every time, the regex must be 
 compiled every time, so nothing can be reused.
  
 Well, the regular expression
  might
  change with each iteration, but that doesn’t mean it needs 
 to be recompiled each time. An intermediate optimization is to check the results of the 
 interpolation (the actual value to be used as the regular expr ession), and recompile only if 
 it’s differ ent fr om the previous time. If the value actually changes each time, there’s no 
 optimization, as the regex indeed must be recompiled each time. But, if it changes only 
 sporadically, the regular expression need only be checked (but not compiled) most times, 
 yielding a handsome optimization.
  
 Compile caching in the procedural approach 
  
 With an integrated approach, regex use is associated with a particular location in a pr ogram, 
 so the compiled version of the regex can be cached and used the next time that location in 
 the program is executed. But, with a procedural approach, ther e is just a general “apply this 
 regex” function that is called as needed. This means that there’s no location in a program 
 with which to associate the compiled for m, so the next time the function is called, the regex 
 must be compiled from scratch again. That’s how it works in theory, but in practice, it’s 
 much too
  
 29 April 2003 20:38",NA
Optimizations with the Transmission,"If the regex engine can’t decide ahead of time that a particular string can never match, it may 
 still be able to reduce the number of locations that the transmission actually has to apply the 
 regex.
  
 Star t of string/line anchor optimization
  
 This optimization recognizes that any regex that begins with
  !ˆ""
  can match only when applied 
 where
  !ˆ""
  can match, and so need be applied at those locations only.
  
 The comments in the “Pre-check of requir ed character/substring” section on the facing 
 page about the ability of the regex engine to derive just when the optimiza-tion is applicable 
 to a regex is also valid here. Any implementation attempting this optimization should be able 
 to recognize that
  !ˆ(this;that)""
  can match starting
  
 29 April 2003 20:38",NA
Optimizations of the Regex Itself,"Literal string concatenation optimization
  
 Perhaps the most basic optimization is that
  !abc""
  can be treated by the engine as“one part,” 
 rather than the three parts “
 !a""
  then
  !b""
  then
  !c""
 .” If this is done, the one part can be applied 
 by one iteration of the engine mechanics, avoiding the over-head of three separate iterations.
  
 Simple quantifier optimization
  
 Uses of star, plus, and friends that apply to simple items, such as literal characters and 
 character classes, are often optimized such that much of the step-by-step over-head of a 
 normal
  NFA
  engine is removed. The main control loop inside a regex engine must be general 
 enough to deal with all the constructs the engine supports. In programming, “general” often 
 means “slow,” so this important optimization makes simple quantifiers like
  ! .+""
  into one 
 “part,” replacing the general engine mechanics of quantifier processing with fast, specialized 
 processing. Thus, the general engine is short-circuited for these tests.
  
 For example,
  ! .+""
  and
  !(?:.)+""
  ar e logically identical, but for systems with this opti-mization, 
 the simple
  ! .+""
  is substantially faster than
  !(?:.)+""
 . A few examples: with Sun’s Java regex 
 package, it’s about 10% faster, but with Ruby and the .
 NET
  lan-guages, it’s about two and a 
 half times faster. With Python, it’s about 50 times faster, and with
  PCRE
 /
 PHP
 , it’s about 150 
 times faster. Because Perl has the
  
 29 April 2003 20:38",NA
Under standing Benchmarks in This Chapter,"For the most part, benchmarks in this chapter are reported as relative ratios for a 
 given language. For example, on page 247, I note that a certain opti-mized construct is 
 10% faster than the unoptimized construct, at least with Sun’s Java regex package. In 
 the .
 NET
  Framework, the optimized and unopti-mized constructs differ by a factor of 
 two and a half, but in
  PCRE
 , it’s a factor of about whopping 150×. In Perl, it’s a factor 
 of one (i.e., they are the same speed
 —
 no differ ence).
  
 Fr om this, what can you infer about the speed of one language compared to another? 
 Absolutely nothing. The 150× speedup for the optimization in
  PCRE 
 may mean that 
 the optimization has been implemented particularly well, rel-ative to the other 
 languages, or it may mean that the unoptimized version is particularly slow. For the 
 most part, I report very little timing information about how languages compare against 
 each other, since that’s of interest mostly for bragging rights among language 
 developers.
  
 But, for what it’s worth, it may be interesting to see the details behind such dif ferent 
 results as Java’s 10% speedup and
  PCRE
 ’s 150× speedup. It turns out that
  PCRE
 ’s 
 unoptimized
  !(?:.)+""
  is about 11 times
  slower
  than Java’s, but its optimized
  ! .+""
  is about 
 13 times
  faster
 . Java’s and Ruby’s optimized versions ar e about the same speed, but 
 Ruby’s unoptimized version is about 2.5 times slower than Java’s unoptimized version. 
 Ruby’s unoptimized version is only about 10% slower than Python’s unoptimized 
 version, but Python’s optimized version is about 20 times faster than Ruby’s 
 optimized version.
  
 All of these are slower than Perl’s. Both Perl’s optimized and unoptimized versions are 
 10% faster than Python’s fastest. Note that each language has its own strong points, 
 and these numbers are for only one specific test case.
  
 For an example of a head-to-head comparison, see “War ning: Benchmark results can 
 cause drowsiness!” in Chapter 8 ( 376).
  
 29 April 2003 20:38",NA
Automatic “Possessification”,"Recall the example from Chapter 4 ( 171) where
  !ˆ\w+:""
  is applied to‘
 Subject
 ’. Once
  
 !\w+""
  matches to the end of the string, the subsequent colon can’t match, and the 
 engine must waste the effort of trying
  !:""
  at each position wher e backtracking forces
  
 !\w+""
  to give up a character. The example then concluded that we could have the 
 engine avoid that extra work by using atomic grouping,
  !ˆ
 (?>
 \w+
 )
 :""
 , or possessive 
 quantifiers,
  !ˆ\w+
 +
 :""
 .
  
 A smart implementation should be able to do this for you. When the regex is first 
 compiled, the engine can see that what
  follows the quantifier
  can’t be matched by what
  is 
 quantified
 , so the quantifier can be automatically turned into a possessive one.
  
 Although I know of no system that currently has this optimization, I include it here to 
 encourage developers to consider it, for I believe it can have a sub-stantial positive 
 impact.
  
 Small quantifier equivalence
  
 Some people like to write
  !\d\d\d\d""
  dir ectly, while some like to use a small quan-tifier and 
 write
  !\d{4}""
 . Is one more efficient than the other? For an
  NFA
 , the answer is almost 
 certainly “yes,” but which is faster depends on the tool. If the tool’s quantifier has been 
 optimized, the
  !\d{4}""
  version is likely faster unless the version without the quantifier can 
 somehow be optimized more. Sound a bit con-fusing? It is.
  
 My tests show that with Perl, Python,
  PCRE
 , and .
 NET
 ,
  !\d{4}""
  is faster by as much as 20%. 
 On the other hand, with Ruby and Sun’s Java regex package,
  !\d\d\d\d""
  is faster
  —
  
 sometimes several times faster. So, this seems to make it clear that the small quantifier is 
 better for some, but worse for others. But, it can be more com-plex than that.
  
 Compar e
  !====""
  with
  !={4}""
 . This is a quite differ ent example because this time, the subject 
 of the repetition is a literal character, and perhaps using
  !====""
  dir ectly makes it easier for 
 the regex engine to recognize the literal substring. If it can, the highly effective
  initial 
 character/substring discrimination
  optimization ( 246) can kick in, if supported. This is exactly the 
 case for Python and Sun’s Java regex package, for whom the
  !====""
  version can be up to 
 100× faster than
  !={4}""
 .
  
 29 April 2003 20:38",NA
Techniques for Faster Expressions,"The previous pages list the kinds of optimizations that I’ve seen implemented in Traditional
  
 NFA
  engines. No one program has them all, and whichever ones your favorite program 
 happens to have now, they’re certain to change sometime in the futur e. But, just 
 understanding the kinds of optimizations that can be done gives you an edge in writing more 
 efficient expressions. Combined with the understand-ing of how a Traditional
  NFA
  engine 
 works, this knowledge can be applied in thr ee power ful ways:
  
 •
  Wr ite to the optimizations 
  
 Compose expressions such that known optimiza-
  
 tions (or ones that might be added in the future) can kick in. For example, 
  
 using
  
 !xx+""
  instead of
  !x+""
  can allow a variety of optimizations to more readily 
  
 kick in, such as the 
 check of a requir ed character or string ( 244), or initial-
  
 character discrimination ( 
 246).
  
 •
  Mimic the optimizations 
  
 Ther e ar e situations where you know your program 
  
 doesn’t have a particular optimization, but by mimicking the optimization 
  
 yourself, 
 you can potentially see a huge savings. As an example that we’ll 
  
 expand on soon, 
 consider adding
  !(?=t)""
  to the start of
  !this;that""
 , to some-
  
 what mimic the initial-
 character discrimination ( 246) in systems that don’t 
  
 alr eady deter mine fr om the regex 
 that any match must begin with ‘
 t
 ’.
  
 •
  Lead the engine to a match 
  
 Use your knowledge of how a Traditional
  NFA 
  
 engine works to lead the engine to a match more quickly. Consider the 
  
  
 !this;that""
  example. Each alternative begins with
  !th""
 ; if the first’s alternative 
  
 can’t 
 match its
  !th""
 , the second alternative’s
  !th""
  certainly can’t match, so the
  
 29 April 2003 20:38",NA
Common Sense Techniques,"Some of the most beneficial things you can do requir e only common sense.
  
 Avoid recompiling
  
 Compile or define the regular expression as few times as possible. With object-ori-ented 
 handling ( 95), you have the explicit control to do this. If, for example, you want to apply a 
 regex in a loop, create the regex object
  outside
  of the loop, then
  use
  it repeatedly inside the 
 loop.
  
 With a procedural approach, as with
  GNU
  Emacs and Tcl, try to keep the number of regular 
 expressions used within a loop below the cached threshold of the tool ( 243).
  
 With an integrated approach like Perl, try not to use variable interpolation within a regex 
 inside a loop, because at a minimum, it causes the regex value to be reeval-uated at each 
 iteration, even if you know the value never changes. (Perl does, however, provide efficient 
 ways around the problem 348.)
  
 Use non-capturing parentheses
  
 If you don’t use the capturing aspect of capturing parentheses, use non-capturing 
 !(?:
 ˙˙˙
 )""
  par 
 entheses ( 45). Besides the direct savings of not having to capture, ther e can be residual 
 savings because it can make the state needed for backtrack-ing less complex, and hence 
 faster. It can also open up additional optimizations, such as needless-parentheses elimination 
 ( 248).
  
 Don’t add superfluous parentheses
  
 Use parentheses as you need them, but adding them otherwise can prohibit opti-mizations 
 from kicking in. Unless you need to know the last character matched by 
 ! .+""
 , don’t use
  !(.)+""
 . 
 This may seem obvious, but after all, this is the “common sense techniques” section.
  
 Don’t use superfluous character classes
  
 This may seem to be overly obvious as well, but I’ve often seen expressions like 
 !ˆ.+[:]""
  fr om 
 novice programmers. I’m not sure why one would ever use a class with a single character in 
 it
  —
  it incurs the processing overhead of a class without gaining any multi-character 
 matching benefits of a class. I suppose that when the character is a metacharacter, such as
  
 ![.]""
  and
  ![+]""
 , it’s probably because the author didn’t know about escaping, as with
  !\.""
  and
  
 !\+""
 . I see this most often with white-space in a free-spacing mode ( 110).
  
 29 April 2003 20:38",NA
Expose Literal Text,"Many of the native optimizations we’ve seen in this chapter hinge on the regex engine’s 
 ability to recognize that there is some span of literal text that must be part of any successful 
 match. Some engines are better at figuring this out than others, so here are some hand-
 optimization techniques that help “expose” literal text, incr easing the chances that an engine 
 can recognize more of it, allowing the vari-ous literal-text optimizations to kick in.
  
 “Factor out” required components from quantifier s
  
 Using
  !xx+""
  instead of
  !x+""
  exposes ‘
 x
 ’ as being requir ed. The same logic applies to the 
 rewriting of
  !-{5,7}""
  as
  !------{0,2}""
 .
  
 “Factor out” required components from the front of alternation
  
 Using
  !th(?:is;at)""
  rather than
  !(?:this;that)""
  exposes that
  !th""
  is requir ed. You can also 
 “factor out” on the right side, when the common text follows the differing text:
  
 !(?:optim;standard)ization""
 . As the next section describes, these can be particularly 
 important when what is being factored out includes an anchor.",NA
Expose Anchors,"Some of the most fruitful internal regex optimizations are those that take advan-tage of 
 anchors (like
  !ˆ""
 ,
  !$""
 , and
  !\G""
  ) that tie the expression to one end of the target string or 
 another. Some engines are not as good as others at understanding when such an 
 optimization can take place, but there are techniques you can use to help.
  
 29 April 2003 20:38",NA
Lazy Ver sus Greedy: Be Specific,"Usually, the choice between lazy and greedy quantifiers is dictated by the specific needs of 
 the regex. For example,
  !ˆ.,
 :
 ""
  dif fers substantially from
  !ˆ.,
 ?
 :""
  in that the for mer one matches 
 until the final colon, while the latter one matches until the first. But, suppose that you knew 
 that your target data had exactly one colon on it. If that’s the case, the semantics of both are 
 the same (“match until the colon”), so it’s probably smart to pick the one that will run 
 fastest.
  
 It’s not always obvious which is best, but as a rule of thumb when the target strings are long, 
 if you expect the colon to generally be near the start of the string, using the lazy quantifier 
 allows the engine to find the colon sooner. Use the gr eedy quantifier if you expect the colon 
 to be toward the end of the string. If the data is random, and you have no idea which will be 
 more likely, use a greedy quantifier, as they are generally optimized a bit better than non-
 greedy quantifier, especially when what follows in the regex disallows the
  character following 
 lazy quantifier
  optimization ( 249).
  
 29 April 2003 20:38",NA
Split Into Multiple Regular Expressions,"Ther e ar e cases where it’s much faster to apply many small regular expressions instead of 
 one large one. For a somewhat contrived example, if you wanted to check a large string to 
 see if it had any of the month names, it would probably be much faster to use separate 
 checks of
  !January""
 ,
  !February""
 ,
  !March""
 , etc., than to use one
  !January;February;March;
 ˙˙˙
 ""
 . 
 With the latter, ther e’s no literal text known to be requir ed for any match, so an
  embedded 
 literal string check
  optimiza-tion ( 247) is not possible. With the all-in-one regex, the mechanics 
 of testing each subexpression at each point in the text can be quite slow.
  
 Her e’s an interesting situation I ran into at about the same time that I was writing this 
 section. When working with a Perl data-handling module, I realized that I had a bug with my 
 client program that caused it to sent bogus data that looked like‘
 HASH(0x80f60ac)
 ’ instead 
 of the actual data. So, I thought I’d augment the mod-ule to look for that kind of bogus data 
 and 
 report 
 an 
 error. 
 The 
 straightforward 
 regex 
 for 
 what 
 I 
 wanted 
 is
  
 !\b
 (?:
 SCALAR<ARRAY<
 ˙˙˙
 <HASH
 )
 \( 0x [0-9a-fA-F]+ \)""
 .
  
 This was a situation where efficiency was extremely important. Would this be fast? Perl has a 
 debugging mode that can tell you about some of the optimizations it uses with any particular 
 regex ( 361), so I checked. I hoped to find that the
  pr e-check of requir ed string
  optimization ( 
 244) would kick in, since an advanced enough engine should be able to figure out that ‘
 (0x
 ’ 
 is requir ed in any match. Knowing the data that I’d apply this to would almost never have 
 ‘
 (0x
 ’, I knew that such a pre-check would eliminate virtually every line. Unfortunately, Perl 
 didn’t pick this out, so I was left with a regex that would entail a lot of alternation at every 
 character of every target string. That’s slower than I wanted.
  
 Since I was in the middle of researching and writing about optimizations, I thought hard 
 about how I could rewrite the regex to garner some of the better optimizations. One 
 thought I had was to rewrite it along the form of the somewhat complex
  
 !\(0x
 (?<=
 (?:SCALAR;
 ˙˙˙
 ;HASH)\(0x
 )
 [0-9a-fA-F]+ \)""
 . The approach her e is that once
  !\(0x""
  
 has matched, the positive lookbehind (underlined for clar-ity) makes sure that what came 
 before is allowed, and then checks that what
  
 29 April 2003 20:38",NA
Mimic Initial-Character Discrimination,"If the
  initial-character discrimination
  optimization ( 246) is not done by your implementation, 
 you can mimic it yourself by adding appropriate lookahead ( 132) to the start of the regex. 
 The lookahead can “pre-check” that you’re at an appr opriate starting character before you 
 let 
 the 
 rest 
 of 
 the 
 regex 
 match. 
 For 
 exam-ple, 
 for
  
 !Jan;Feb;
 ˙˙˙
 ;Dec""
 , 
 use
  
 !
 (?=[JFMASOND])(?:
 Jan;Feb;
 ˙˙˙
 ;Dec
 )
 ""
 . The leading 
 ![JFMASOND]""
  repr esents letters that can 
 begin the month names in English. This must be done with care, though, because the added 
 overhead of the lookahead may overshadow the savings. In this particular example, where 
 the lookahead is pr e-checking for many alternatives that are likely to fail, it is beneficial for 
 most systems I’ve tested (Java, Perl, Python, Ruby, .
 NET
  languages, and
  PCRE
 ), none of 
 which apparently are able to derive
  ![JFMASOND]""
  fr om
  !Jan;Feb;
 ˙˙˙
 ;Dec""
  them-selves. (
 PCRE
  
 can do it with the use of
  pcreRstudy
 , and Tcl, of course, can do it per fectly 243.)
  
 A behind-the-scenes check of
  ![JFMASOND]""
  by an engine’s native optimization is certainly 
 faster than the same check explicitly added by us to the regex proper. Is ther e a way we can 
 modify the regex so that the engine will check natively? Well, with many systems, you can by 
 using the horribly contorted:
  
 ![JFMASOND]
 (?:
 (?<=J)an<(?<=F)eb<
 ˙˙˙
 <(?<=D)ec
 )
  
 † You can see this in action for yourself. The module in question,
  DBIx::DWIW
  (available on
  CPAN
 ), 
  
 allows very 
 easy access to a MySQL database. Jeremy Zawodny and I developed it at Yahoo!.
  
 29 April 2003 20:38",NA
Use Atomic Grouping and Possessive Quantifier s,"Ther e ar e many cases when atomic grouping ( 137) and possessive quantifiers ( 140) can 
 greatly increase the match speed, even though they don’t change the kind of matches that are 
 possible. For example, if
  !ˆ[ˆ:]+:""
  can’t match the first time the colon is attempted, it certainly 
 can’t match after backtracking back into the
  ![ˆ:]+""
 , since any character “given up” by that 
 backtracking, by definition, can’t match a colon. The use of atomic grouping
  !ˆ
 (?>
 [ˆ:]+
 )
 :""
  or a 
 possessive quanti-fier
  !ˆ[ˆ:]+
 +
 :""
  causes the states from the plus to be thrown away, or not 
 created in the first place. Since this leaves nothing for the engine to backtrack to, it ensures 
 that it doesn’t backtrack unfruitfully. (The sidebar on page 251 suggests that this can be done 
 automatically by a smart enough engine.)
  
 However, I must stress that misusing either of these constructs can inadvertently change 
 what kind of matches are allowed, so great care must be taken. For exam-ple, using them 
 with
  !ˆ.+:""
 , as with
  !ˆ
 (?>
 .+
 )
 :""
 , guarantees failure. The entire line is matched by
  ! .+""
 , and this 
 includes any colon that the later
  !:""
  needs. The atomic gr ouping removes the ability for the 
 backtracking requir ed to let
  !:""
  match, so fail-ur e is guaranteed.
  
 29 April 2003 20:38",NA
Lead the Engine to a Match,"One concept that goes a long way toward more efficient
  NFA
  regular expressions is pushing 
 “control” issues as far back in the matching process as possible. One example we’ve seen 
 already is the use of
  !th(?:is;at)""
  instead of
  !this;that""
 . With the latter, the alternation is a top-
 level control issue, but with the former, the relatively expensive alternation is not considered 
 until
  !th""
  has been matched.
  
 The next section, “Unrolling the Loop,” is an advanced form of this, but there are a few 
 simple techniques I can mention here.
  
 Put the most likely alter native fir st
  
 Thr oughout the book, we’ve seen a number of situations where the order in which 
 alternatives are presented matters greatly ( 28, 176, 189, 216). In such situ-ations, the 
 correctness of the match take precedence over optimization, but other-wise, if the order 
 doesn’t matter to the correctness, you can gain some efficiency by placing the most-likely 
 alternatives first.
  
 For example, when building a regex to match a hostname ( 205) and listing the final domain 
 parts, some might find it appealing to list them in alphabetical order, as with
  
 !(?:aero;biz;com;coop;
 ˙˙˙
 )""
 . However, some of those early in the list are new and not currently 
 popular, so why waste the time to check for them first when you know they will likely fail 
 most of the time? An arrangement with the mor e popular first, such as
  
 !(?:com;edu;org;net;
 ˙˙˙
 )""
 , is likely to lead to a match mor e quickly, more often.
  
 Of course, this matters only for a Traditional
  NFA
  engine, and then, only for when ther e
  is
  a 
 match. With a
  POSIX NFA
 , or with a failure, all alternatives must be checked and so the 
 ordering doesn’t matter.
  
 Distr ibute into the end of alternation
  
 Continuing with a convenient example, compare
  
 !
 (?:
 com<edu<
 ˙˙˙
 <[a-z][a-z]
 )\b 
 with
  
 !com
 \b
 ;edu
 \b
 ;
 ˙˙˙
 \b
 ;[a-z][a-z]
 \b
 ""
 . In the latter, the
  !\b""
  after the alternation has been 
 distributed onto the end of each alternative. The possible benefit is that it may allow an 
 alternative that matches, but whose match would have been undone by the
  !\b""
  after the 
 alternation, to fail a bit quicker, inside the alternation. This allows the failure to be 
 recognized before the overhead of exiting the alterna-tion is needed.
  
 This is perhaps not the best example to show the value of this technique, since it shows 
 promise only for the specific situation when an alternative is likely to match, but what comes 
 right after is likely to fail. We’ll see a better example of this concept later in this chapter
 —
 look for the discussion of
  $OTHER+
  on page 280.
  
 29 April 2003 20:38",NA
Unrolling the Loop,"Regardless of what native optimizations a system may support, perhaps the most important 
 gains are to be had by understanding the basics of how the engine works, and writing 
 expressions that help lead the engine to a match. So, now that we’ve reviewed the basics in 
 excruciating detail, let’s step up to the big leagues with a technique I call “unrolling the 
 loop.” It’s effective for speeding up certain common expressions. Using it, for example, to 
 transform the neverending match fr om near the start of this chapter ( 226) results in an 
 expression that actually fin-ishes a non-match in our lifetime, and as a bonus is faster with a 
 match as well.
  
 The “loop” in the name is the implicit loop imparted by the star in an expression that fits a
  
 !(
 this
 ;
 that
 ;
 ˙˙˙
 )+""
  patter n. Indeed, our earlier
  !""(\\.;[ˆ""\\]
 +
 ),""
  nev-er ending match fits this 
 pattern. Considering that it takes approximately forever to report a non-match, it’s a good 
 example to try to speed up!
  
 Ther e ar e two competing roads one can take to arrive at this technique:
  
 1
 . We can examine which parts of
  !
 (
 \\.<[ˆ""\\]+
 )
 ,""
  actually succeed during a variety of 
 sample matches, leaving a trail of used subexpressions in its wake. We can then reconstruct 
 an efficient expression based upon the patterns we see emerge. The (perhaps far-fetched) 
 mental image I have is that of a big ball, repr esenting a
  !(
 ˙˙˙
 )+""
  regex, being rolled over some 
 text. The parts inside 
 (
 ˙˙˙
 )
  that are actually used then stick to the text they match, leaving a 
 trail of subexpr essions behind like a dirty ball rolling across the carpet.
  
 2
 . Another approach takes a higher-level look at the construct we want to match. We’ll 
 make an informed assumption about the likely target strings, allowing us to take advantage 
 of what we believe will be the common situa-tion. Using this point of view, we can 
 construct an efficient expression.
  
 Either way, the resulting expressions are identical. I’ll begin from the “unrolling”point of 
 view, and then converge on the same result from the higher-level view.
  
 29 April 2003 20:38",NA
Method 1: Building a Regex From Past Experiences,"In analyzing
  !
 ""
 (
 \\.
 ;
 [ˆ""\\]+
 )+
 ""
 , it’s instructive to look at some matching strings to see exactly 
 which subexpressions are used during the overall match. For exam-ple, with ‘
 ""hi""
 ’, the 
 expression effectively used is just
  !""[ˆ""\\]+ """"
 . This illustrates that the overall match used the 
 initial
  !""
 , one application of the alternative 
 ![ˆ""\\]+""
 , and the closing
  !""
 . With
  
 ""he said \""hi there\"" and left""
  
 it is
  !""[ˆ""\\]+ \\. \\.[ˆ""\\]+ \\. \\.[ˆ""\\]+""
 . In this example, as well as in Table 6-2, I’ve marked 
 the expressions to make the patterns apparent. It would be nice if we could construct a 
 specific regex for each particular input string. That’s not pos-sible, but we can still identify 
 common patterns to construct a more efficient, yet still general, regular expression.
  
 Table 6-2: Unr olling-the-Loop Example Cases 
  
 Target String 
  
 Effective Expression
  
 ""hi there"" 
  
 ""[ˆ""\\]+"" 
  
 ""just one \"" here"" 
  
 ""[ˆ""\\]+ \\. \\.[ˆ""\\]+""
  
 ""some \""quoted\"" things"" ""with 
 \""a\"" and \""b\"".""
  
 ""[ˆ""\\]+ \\. \\.[ˆ""\\]+ \\"" \\""[ˆ""\\]+""
  
 ""[ˆ""\\]+ \\. \\.[ˆ""\\]+ \\. \\.[ˆ""\\]+ \\. \\.[ˆ""\\]+ \\. \\.[ˆ""\\]+""
  
 ""\""ok\""\n"" 
  
 ""\\. \\.[ˆ""\\]+ \\. \\. \\. \\.""
  
 ""empty \""\"" quote"" 
  
 ""[ˆ""\\]+ \\. \\. \\. \\.[ˆ""\\]+""
  
 For the moment, let’s concentrate on the first four examples in Table 6-2. I’ve
  
 underlined the portions that refer to “an escaped item, followed by further normal
  
 characters.” This is the key point: in each case, the expression between the quotes
  
 begins with
  ![ˆ""\\]+""
  and is followed by some number of
  !\\. \\.[ˆ""\\]+""
  sequences.
  
 Rephrasing this as a regular expression, we get
  ![ˆ""\\]+ (\\. \\.[ˆ""\\]+)+""
 . This is
  
 a specific example of a general pattern that can be used for constructing many
  
 useful expressions.
  
 Constr ucting a general “unrolling-the-loop” pattern
  
 In matching the double-quoted string, the quote itself and the escape are “special”
  
 —
  the quote because it can end the string, and the escape because it means that
  
 whatever follows won’t end the string. Everything else,
  ![ˆ""\\]""
 , is “nor mal.” Look-
  
 ing at how these were combined to create
  ![ˆ""\\]+ (\\. \\.[ˆ""\\]+)+""
 , we can see
  
 that it fits the general pattern
  !
 nor mal
 +(
 special special normal
 +)+""
 .
  
 29 April 2003 20:38",NA
The Real “Unrolling-the-Loop” Patter n,"Putting it all together, then, our expression to match a double-quoted string with escaped-
 items is
  !""[ˆ""\\]+(\\.[ˆ""\\]+)+""
 . This matches exactly the same strings as our alternation 
 version, and it fails on the same strings that the alterna-tion version fails on. But, this 
 unrolled version has the added benefit of finishing in our lifetime because it is much more 
 efficient and avoids the neverending-match pr oblem.
  
 29 April 2003 20:38",NA
+,"closing
  "" 
 Avoiding the neverending match
  
 Thr ee extr emely important points prevent
  !""[ˆ""\\]+(\\. \\.[ˆ""\\]+)+""
  fr om becoming a 
 neverending match:
  
 The star t of special and normal must never inter sect 
  
 The
  special
  and
  nor mal
  subexpr essions must be written such that they can never match at the 
 same point. With our ongoing example, where
  nor mal
  is
  ![ˆ""\\]""
  and 
 special
  is
  !\\.""
 , it’s clear 
 that they can never begin a match at the same character since the latter one requir es a 
 leading backslash, while the former one explicitly disallows a leading backslash.
  
 On the other hand,
  !\\.""
  and
  ![ˆ""]""
  can both match starting at ‘
 ""Hello\n""
 ’, so they
  
 ar e inappr opriate as
  special
  or
  nor mal
 . If ther e is a way they can match starting at the same 
 location, it’s not clear which should be used at such a point, and the non-deter minism cr 
 eates a never ending match. The ‘
 makudonarudo
 ’ example illus-
  
 trates this graphically ( 227). A failing match (or any kind of match attempt with 
 POSIX NFA
  
 engines) has to test all these possibilities and permutations. That’s too bad, since the whole 
 reason to re-engineer in the first place was to avoid this.
  
 If we ensure that
  special
  and
  nor mal
  can never match at the same point,
  special 
 acts to 
 checkpoint the nondeterminism that would arise when multiple applica-tions of
  nor mal
  
 could, by differ ent iterations of the
  !(
 ˙˙˙
 )+""
  loop, match the same text. If we ensure that
  special
  
 and
  nor mal
  can never match at the same point, ther e is exactly one “sequence” of
  specials
  and
  
 nor mals
  in which a particular tar-get string matches. Testing this one sequence is much faster 
 than testing a hundred million of them, and thus a neverending match is avoided.
  
 Special must not match nothingness 
  
 The second important point is that
  special
  must always match at least one charac-ter if it 
 matches anything at all. If it were able to match without consuming charac-ters, adjacent 
 normal characters would be able to be matched by differ ent iterations of
  !
 (
 special special 
 normal
 +
 )
 ,""
 , bringing us right back to the basic
  (
 ˙˙˙
 +)+ 
 pr oblem.
  
 For example, choosing a
  special
  of
  !(\\.)+""
  violates this point. In trying to match the ill-fated
  
 !""[ˆ""\\]+((\\.), (\\.),[ˆ""\\]+)+""
  against ‘
 ""Tubby
 ’ (which fails), the engine must try every 
 permutation of how multiple
  ![ˆ""\\]+""
  might match ‘
 Tubby
 ’befor e concluding that the 
 match is a failure. Since
  special
  can match nothingness, it doesn’t act as the checkpoint it 
 purports to be.
  
 29 April 2003 20:38",NA
Method 2: A Top-Down View,"Recall that I said that there wer e two paths to the same “unrolling the loop”expr ession. In 
 this second path, we start by matching only what’s most common in the target, then adding 
 what’s needed to handle the rare cases. Let’s consider what the neverending
  !
 (
 \\. 
 \\.<[ˆ""\\]+
 )
 ,""
  attempts to accomplish and where it will likely be used. Normally, I would 
 think, a quoted string would have more regular char-acters than escaped items, so
  ![ˆ""\\]+""
  
 does the bulk of the work. The
  !\\.""
  is needed only to take care of the occasional escaped 
 item. Using alternation to allow either makes a useful regex, but it’s too bad that we need to 
 compromise the efficiency of the whole match for the sake of a few (or more commonly, 
 no) escaped characters.
  
 If we think that
  ![ˆ""\\]+""
  will normally match most of the body of the string, we know that 
 once it finishes we can expect either the closing quote or an escaped item. If we have an 
 escape, we want to allow one more character (whatever it might be), and then match more of 
 the bulk with another
  ![ˆ""\\]+""
 . Every time 
 ![ˆ""\\]+""
  ends, we are in the same position we 
 were befor e: expecting either the closing quote or another escape.
  
 Expr essing this naturally as a single expression, we arrive at the same expression we had 
 early in Method 1:
  !""[ˆ""\\]+ ( \\. \\.[ˆ""\\]+)+""
 . Each time the matching reaches the point 
 marked by, we know that we’re expecting either a backslash or a closing quote. If the 
 backslash can match, we take it, the character that fol-lows, and more text until the next 
 “expecting a quote or backslash” point.
  
 As in the previous method, we need to allow for when the initial non-quote seg-ment, or 
 inter-quote segments, are empty. We can do this by changing the two pluses to stars, which 
 results in the same expression as we ended up with on page 263.
  
 29 April 2003 20:38",NA
Method 3: An Internet Hostname,"I promised two methods to arrive at the
  unr olling-the-loop
  technique, but I’d like to present 
 something that can be considered a third. It struck me while working with a regex to match a 
 hostname such as
  www.yahoo.com
 . A hostname is essen-tially dot-separated lists of 
 subdomain names, and exactly what’s allowed for one subdomain name is fairly complex to 
 match ( 203), so to keep this example less clutter ed, we’ll just use
  ![a-z]+""
  to match a 
 subdomain.
  
 If a subdomain is
  ![a-z]+""
  and we want a dot-separated list of them, we need to match one 
 subdomain first. After that, further subdomains requir e a leading period. Expressing this 
 literally, we get:
  ![a-z]+ ( \.[a-z]+ )+""
 . Now, if I add an underline and some gray,
  ![a-z]+ (\. 
 \.[a-z]+)+""
 , it sur e looks like it almost fits a very familiar pattern, doesn’t it!
  
 To illustrate the similarity, let’s try to map this to our double-quoted string exam-ple. If we 
 consider a string to be sequences of our
  nor mal
  ![ˆ\\""]""
 , separated by 
 special
  !\\.""
 , all within 
 ‘
 ""
 ˙˙˙
 ""
 ’, we can plug them into our unrolling-the-loop pattern to form
  !""[ˆ\\""]+ (\\. \\. 
 [ˆ\\""]+)+""
 , which is exactly what we had at one point while discussing Method 1. This means 
 that conceptually, we can take the view we used with a hostname
  —
  stuf f separated by 
 separators
  —
  and apply it to double-quoted strings, to give us “sequences of non-escaped 
 stuff separated by escaped items.” This might not seem intuitive, but it yields an interesting 
 path to what we’ve already seen.
  
 The similarity is interesting, but so are the differ ences. With Method 1, we went on to 
 change the regex to allow empty spans of
  nor mal
  befor e and after each
  special
 , but we don’t 
 want to do that here because a subdomain part cannot be empty. So, even though this 
 example isn’t exactly the same as the previous ones, it’s in the same class, showing that the 
 unrolling technique is powerful
  and
  flexible.
  
 Ther e ar e two differ ences between this and the subdomain example:
  
 •
  Domain names don’t have delimiters at their start and end.
  
 •
  The
  nor mal
  part of a subdomain can never be empty (meaning two periods ar e not 
 allowed in a row, and can neither start nor end the match). With a double-quoted string, 
 there is no requir ement that there be any
  nor mal
  parts at all, even though they are likely, 
 given our assumptions about the data.
  
 That’s why we were able to change the
  ![ˆ\\""]+""
  to
  ![ˆ\\""]+""
 . We can’t do
  
  
 that with the subdomain example because
  special
  repr esents a
  separator
 , which is requir 
 ed.
  
 29 April 2003 20:38",NA
Obser vations,"Recapping the double-quoted string example, I see many benefits to our expres-sion,
  
 !""[ˆ""\\]+(\\.[ˆ""\\]+)+""
 , and few pitfalls.
  
 Pitfalls:
  
 •
  Reada bility 
  
 The biggest pitfall is that the original
  !""([ˆ""\\];\\.)+""
  is 
  
 pr obably easier to 
 understand at first glance. We’ve traded a bit of readability 
  
 for efficiency.
  
 •
  Maintaina bility Maintaining
  !""[ˆ""\\]+(\\.[ˆ""\\]+)+""
  might be more dif fi-
  
  
 cult, since the two copies of
  ![ˆ""\\]""
  must be kept identical across any changes. We’ve 
 traded a bit of maintainability for efficiency.
  
 Benefits:
  
 •
  Speed The new regex doesn’t buckle under when no match is possible, or 
  
 when 
 used with a
  POSIX NFA
 . By car efully crafting the expression to allow 
  
 only one way for 
 any particular span of text to be matched, the engine quickly 
  
 comes to the conclusion 
 that non-matching text indeed does not match.
  
 •
  More speed 
  
 The regex “flows” well, a subject taken up in “The Freeflowing 
  
 Regex” ( 277). In my benchmarks with a Traditional
  NFA
 , the unrolled ver-
  
 sion is 
 consistently faster than the old alternation version. This is true even for 
  
 successful 
 matches, where the old version did not suffer the lockup problem.",NA
Using Atomic Grouping and Possessive Quantifier s,"The problem with our original neverending match regex,
  !""(\\.;[ˆ""\\]+ )+""
 , is that it bogs 
 down when there is no match. When there
  is
  a match, though, it’s quite fast. It’s quick to 
 find the match because the
  ![ˆ""\\]+""
  component is what matches most of the target string 
 (the
  nor mal
  in the previous discussion). Because 
 ![
 ˙˙˙
 ]+""
  is usually optimized for speed ( 247), 
 and because this one component handles most of the characters, the overhead of the 
 alternation and the outer 
 !(
 ˙˙˙
 )+""
  quantifier is greatly reduced.
  
 So, the problem with
  !""(\\.;[ˆ""\\]+ )+""
 , is that it bogs down on a non-match, backtracking 
 over and over to what we know will always be unfruitful states. We know they’re unfruitful 
 because they’re just testing differ ent per mutations of the same thing. (If
  !
 a
 bc""
  doesn’t 
 match ‘
 foo
 ’, neither will
  !a
 b
 c""
  or
  !ab
 c
 ""
  (or
  !
 ab
 c""
 ,
  !a
 bc
 ""
 , or 
 !
 abc
 ""
 , for that matter). So, if we 
 could throw those states away, this regex would report the non-match quickly.
  
 Ther e ar e two ways to actually throw away (or otherwise ignore) states: atomic gr ouping ( 
 137) and possessive quantifiers ( 140). At the time of this writing, only Sun’s regex package 
 for Java supports possessive quantifiers, but I believe they’ll gain popularity soon, so I’ll 
 cover them here.
  
 29 April 2003 20:38",NA
Shor t Unrolling Examples,"Now that we’ve got the basic idea of unrolling under our belt, let’s look at some
  
 examples from earlier in the book, and see how unrolling applies to them.
  
 Unrolling “multi-character” quotes
  
 In Chapter 4 on page 167, we saw this example:
  
 <B> 
  
 #
  Match the opening <B>
  
 ( 
  
 #
  Now, only as many of the following as needed . . .
  
 (?! <
  /?
  B> ) 
  
 # 
  
 If not <B>, and not </B> . . .
  
 . 
  
 # 
 . . . any character is okay
  
 )+ 
  
 #
  
 </B> 
  
 # 
  
 . . . until the closing delimiter can match.
  
 With a
  nor mal
  of
  ![ˆ<]""
  and a
  special
  of
  !(?! </?B>) <""
 , her e’s the unrolled version:
  
 <B> 
  
 #
  Match the opening <B>
  
 (?> [ˆ<]+ ) 
  
 #
  Now match any ""normal"" . . .
  
 (?> 
  
 #
  Any amount of . . .
  
 (?! < /? B> ) # 
  
 if not at <B> or </B>,
  
 < # 
  
 match one ""special""
  
 [ˆ<]+ # 
  
 and then any amount of ""normal""
  
 )+ #
  
 </B> 
  
 #
  And finally the closing </B>
  
 The use of atomic grouping is not requir ed, but does make the expression faster
  
 when there’s only a partial match.
  
 Unrolling the continuation-line example
  
 The continuation-line example from the start of the previous chapter ( 186) left
  
 of f with
  !ˆ\w+ =
 (
 [ˆ\n \\]<\\ .
 )
 ,""
 . Well, that certainly looks ripe for unrolling:
  
 ˆ \w+ = #
  leading field name and ’=’
  
 #
  Now read (and capture) the value . . .
  
 (
  
 (?> [ˆ\n\\]+ ) #
  ""nor mal""*
  
 (?> \\. [ˆ\n\\]+ )+ #
  ( ""special"" ""normal""* )*
  
 )
  
 As with earlier examples of unrolling, the atomic grouping is not requir ed for this
  
 to work, but helps to allow the engine to announce a failure mor e quickly.
  
 29 April 2003 20:38",NA
Unrolling C Comments,"I’d like to give an example of unrolling the loop with a somewhat more complex target. In 
 the C language, comments begin with
  /
 ,
 , end with
  ,
 /
 , and can span acr oss lines, but can’t be 
 nested. (C
 ++
 , Java, and C# also allow this type of com-ment.) An expression to match such 
 a comment might be useful in a variety of sit-uations, such as in constructing a filter to 
 remove them. It was when working on this problem that I first came up with my unrolling 
 technique, and the technique has since become a staple in my regex arsenal.
  
 To unroll or to not unroll . . .
  
 I originally developed the regex that is the subject of this section back in the early 1990s. 
 Prior to that, matching C comments with a regular expression was consid-er ed dif ficult at 
 best, if not impossible, so when I developed something that worked, it became the standard 
 way to match C comments. But, when Perl intro-duced lazy quantifiers, a much simpler 
 approach became evident: a dot-matches-all application of
  !/\+.+?\+/""
 .
  
 Had lazy quantifiers been around when I first developed the unrolling technique, I might not 
 have bothered to do so, for the need wouldn’t have been so apparent. Yet, such a solution 
 was still valuable because with that first version of Perl sup-porting lazy quantifiers, the 
 unrolled version is faster than the lazy-quantifier ver-sion by a significant amount (in the 
 variety of tests I’ve done, anywhere from about 50% faster, to 3.6× faster).
  
 Yet, with today’s Perl and its differ ent mix of optimizations, those numbers go the other 
 way, with the lazy-quantifier version running anywhere from about 50% faster to 5.5× faster. 
 So, with modern versions of Perl, I’d just use
  !/\+.+?\+/""
  to match C comments and be 
 done with it.
  
 Does this mean that the unrolling-the-loop technique is no longer useful for matching C 
 comments? Well, if an engine doesn’t support lazy quantifiers, the abil-ity to use the 
 unrolling technique certainly becomes appealing. And not all regex engines have the same 
 mix of optimizations: the unrolling technique is faster with every other language I’ve tested
  
 —
  in my tests, up to 60 times faster! The unrolling technique is definitely useful, so the 
 remainder of this example explores how to apply it to matching C comments.
  
 Since there are no escapes to be recognized within a C comment the way
  \""
  must be 
 recognized within a double-quoted string, one might think that this should make things 
 simpler, but actually, it’s much more complex. This is because
  +/
 , the“ending quote,” is mor 
 e than one character long. The simple
  !/\+[ˆ+]+\+/""
  might look good, but that doesn’t match
  
 /
 ,+ some comment here +,
 /
  because it has a‘
 +
 ’ within. It should be matched, so we need a 
 new approach.
  
 29 April 2003 20:38",NA
Tr anslating Between English and Regex,"On page 273, when discussing two ways one might consider the C comment“anything 
 that is not the ending delimiter,” I presented one idea as
  
  
 “
  x
 , so long as not followed by a slash: 
  
 !x[ˆ/]""
  ”
  
 and another as:
  
  
 “ a  slash, so long as not preceded by
  x
 : 
  
  
 ![ˆx]/""
  ”
  
 In doing so, I was being informal
  —
 the English descriptions are actually quite dif ferent 
 from the regexes. Do you see how?
  
 To see the differ ence, consider the first case with the string ‘
 regex
 ’
  —
  it cer-tainly has 
 an
  x
  not followed by a slash, but it would
  not
  be matched by match 
 !x[ˆ/]""
 . The 
 character class requir es a character to match, and although that character can’t be a 
 slash, it still must be
  something
 , and there’s nothing after the
  x
  in ‘
 regex
 ’. The second 
 situation is analogous. As it turns out, what I need at that point in the discussion are 
 those specific expres-sions, so it’s the English that is in error.
  
 If you have lookahead, “
 x
 , so long as not followed by a slash” is simply 
 !x(?!/)""
 . If you 
 don’t, you might try to get by with
  !x
 (
 [ˆ/]<$
 )
 ""
 . It still matches a character after the
  x
 , 
 but can also match at the end of the line. If you have lookbehind, “slash, so long as 
 not preceded by
  x
 ” becomes 
 !(?<!x)/""
 . If you don’t have it, you have to make due with
  
 !
 (ˆ
 <[ˆx]
 )
 /""
 .
  
 We won’t use any of these while working with C comments, but it’s good to understand 
 the issue.
  
 This leaves us with:
  !/x
 (
 [ˆx]<x+[ˆ/x]
 )
 +x+/""
  to match our pseudo comments.
  
 Phew! 
 Somewhat confusing, isn’t it? Real comments (with
  +
  instead of
  x
 ) requir e 
 !/\+
 (
 [ˆ+]<\++[ˆ/+]
 )
 +\++/""
  which is even more confusing. It’s not easy to read; just 
 remember to keep your wits about you as you carefully parse complex expr essions in your 
 mind.
  
 Unrolling the C loop
  
 For efficiency’s sake, let’s look at unrolling this regex. Table 6-3 on the next page shows the 
 expressions we can plug in to our unrolling-the-loop pattern.
  
 Like the subdomain example, the
  !
 nor mal
 +""
  is not actually free to match nothing-ness. With 
 subdomains, it was because the normal part was not allowed to be empty. In this case, it’s 
 due to how we handle the two-character ending delimiter. We ensur e that any
  nor mal
  
 sequence ends with the first character of the ending delimiter, allowing
  special
  to pick up the 
 ball only if the following character does not complete the ending.
  
 29 April 2003 20:38",NA
The Freef lowing Regex,"We just spent some time constructing a regex to match a C comment, but left off with the 
 problem of how to stop comment-like items within strings from being matched. Using Perl, 
 we might mistakenly try to remove comments with:
  
 $prog =˜
  s{
 /\+[ˆ+]+\++(?:[ˆ/+][ˆ+]+\++)+/
 }{}g
 ; #
  remove C comments (and more!)
  
 Text in the variable
  $prog
  that is matched by our regex is removed (that is, replaced by 
 nothing). The problem with this is that there’s nothing to stop a match fr om starting
  within
  a 
 string, as in this C snippet:
  
 char +CommentStart = ""/+"";
 /
 ,
  
 start of comment
  ,
 / 
 char +CommentEnd = ""+/"";
  
 /
 ,
  end of 
 comment
  ,
 /
  
 Her e, the underlined portions are what the regex finds, but the bold portions are what we
  
 wish
  to be found. When the engine is searching for a match, it tries to match the expression 
 at each point in the target. Since it is successful only from wher e a comment begins (or 
 where it looks like one begins), it doesn’t match at most locations, so the transmission 
 bump-along bumps us right into the double-quoted string, whose contents look like the start 
 of a comment. It would be nice if we could tell the regex engine that when it hits a double-
 quoted string, it should zip right on past it. Well, we can.",NA
A Helping Hand to Guide the Match,"Consider:
  
 $COMMENT =
  qr{
 /\+[ˆ+]+\++(?: [ˆ/+][ˆ+]+\++)+/
 }
 ; #
  regex to match a comment 
 $DOUBLE =
  
 qr{
 ""(?:\\.;[ˆ""\\])+""
 }
 ; 
  
 #
  regex to match double-quoted string 
 $text =˜
  
 s/
 $DOUBLE;$COMMENT
 //g
 ;
  
 Ther e ar e two new things here. One is that this time the regex operand, 
 $DOUBLE;$COMMENT
 , is made up of two variables, each of which is constructed with Perl’s 
 special
  qr/
 ˙˙˙
 /
  regex-style “double-quoted string” operator. As discussed at length in Chapter 
 3 ( 101), one must be careful when using strings that are meant to be interpreted as regular 
 expressions. Perl alleviates this problem by pro-viding the
  qr/
 ˙˙˙
 /
  operator, which treats its 
 operand as a regular expression, but doesn’t actually apply it. Rather, it retur ns a “regex 
 object” value that can later be used to build up a larger regular expression. It’s extremely 
 convenient, as we saw briefly in Chapter 2 ( 76). Like
  m/
 ˙˙˙
 /
  and
  s/
 ˙˙˙
 /
 ˙˙˙
 /
 , you can pick 
 delimiters to suit your needs ( 71), as we’ve done here using braces.
  
 The other new thing here is the matching of double-quoted strings via the 
 $DOUBLE
  
 portion. When the transmission has brought us to a position where the 
 $DOUBLE
  part can 
 match, it will do so, thereby bypassing the whole string in one fell swoop. It is possible to 
 have both alternatives because they are entir ely
  
 29 April 2003 20:38",NA
A Well-Guided Regex is a Fast Regex,"With just a little hand holding, we can help direct the flow of the regex engine’s attention to 
 match much faster. Let’s consider the long spans of normal C code between the comments 
 and strings. For each such character, the regex engine has to try each of the four alternatives 
 to see whether it’s something that should be gobbled up, and only if all four fail does it 
 bump-along to bypass the character as uninter esting. This is a lot of work that we really 
 don’t need to do.
  
 We know, for example, that for any of the alternatives to have a chance at match-ing, the 
 lead character must be a slash, a single quote, or a double quote. One of these doesn’t 
 guarantee a match, but
  not
  being one does guarantee a non-match. So, rather than letting the 
 engine figure this out the slow and painful way, let’s just tell it directly by adding
  ![ˆ’""/]""
  as an 
 alternative. In fact, any number of such characters in a row can be scooped right up, so let’s 
 use
  ![ˆ’""/]
 +
  ""
  instead. If you remember the neverending match, you might feel worried about 
 the added plus. Indeed, it could be of great concern if it wer e within some kind of
  (
 ˙˙˙
 )+
  loop, 
 but in this stand-alone case it’s quite fine (there’s nothing that follows that could force it to 
 backtrack at all). So, adding:
  
 $OTHER =
  qr{
 [ˆ""’/]
 }
 ; 
  
 #
  Stuf f that couldn’t possibly begin one of the other alternatives 
 + 
  
 + 
  
 + 
  
 $text =˜
  s/
 ($DOUBLE;$SINGLE;$OTHER+);$COMMENT;$COMMENT2
 /$1/g
 ;
  
 For reasons that will become apparent after a bit, I’ve put the plus quantifier after 
 $OTHER
 , 
 rather than part of the contents of
  $OTHER
 .
  
 So, I retry my benchmarks, and wow, this one change cuts the time by over 75%! We’ve 
 crafted the regex to remove most of the overhead of having to try all the alter natives so 
 often. There are still a few cases where none of the alternatives can match (such as at ‘
 c/ 
 3.14
 ’), and at such times, we’ll have to be content with the bump-along to get us by.
  
 However, we’r e not done yet
 —
 we can still help the engine flow to a faster match:
  
 •
  In most cases, the most popular alternative will be
  !$OTHER+""
 , so let’s put that first inside 
 the parentheses. This isn’t an issue for a
  POSIX NFA
  engine because it must always 
 check all alternatives anyway, but for a Traditional
  NFA
 , which stops once a match has 
 been found, why make it check for relatively rare matches before checking the one we 
 believe will match most often?
  
 29 April 2003 20:38",NA
Wrapup,"We’r e not quite done yet. Don’t forget, each of the quoted-string subexpressions is ripe for 
 unrolling
  —
  heck, we spent a long section of this chapter on that very topic. So, as a final 
 change, let’s replace the two string subexpressions with:
  
 29 April 2003 20:38",NA
In Summary: Think!,"I’d like to end this chapter with a story that illustrates just how much benefit a lit-tle thought 
 can go when using
  NFA
  regular expressions. Once when using
  GNU 
 Emacs, I wanted a 
 regex to find certain kinds of contractions such as “don’t,” “I’m,”“we’ll,” and so on, but to 
 ignore other situations where a single quote might be next to a word. I came up with a regex 
 to match a word,
  !\<\w+""
 , followed by the Emacs equivalent of
  !’([tdm];re;ll;ve)""
 . It worked, 
 but I realized that using 
 !\<\w+""
  was silly when I needed only
  \w
 . You see, if there is a
  \w
  
 immediately befor e the apostrophe,
  \w+
  is certainly there too, so having the regex check for 
 something we know is there doesn’t add any new information unless I want the exact extent 
 of the match (which I didn’t, I merely wanted to get to the area). Using
  \w
  alone made the 
 regex more than 10 times faster.
  
 Yes, a little thought can go a long way. I hope this chapter has given you a little to think 
 about.
  
 29 April 2003 20:38",NA
7,NA,NA
Perl,"Perl has been featured prominently in this book, and with good reason. It is popu-lar, extr 
 emely rich with regular expressions, freely and readily obtainable, easily appr oachable by the 
 beginner, and available for a remarkably wide variety of plat-for ms, including pretty much 
 all flavors of Windows, Unix, and the Mac.
  
 Some of Perl’s programming constructs superficially resemble those of C or other traditional 
 programming languages, but the resemblance stops there. The way you wield Perl to solve a 
 problem
  —
  The Perl Way
  —
  is differ ent fr om traditional lan-guages. The overall layout of a 
 Perl program often uses traditional structured and object-oriented concepts, but data 
 processing often relies heavily on regular expr essions. In fact, I believe it is safe to say that 
 regular expressions play a key role in virtually all Perl programs. This includes everything 
 from huge 100,000-line systems, right down to simple one-liners, like
  
 % perl -pi -e ’s{([-+]?\d+(\.\d+)?)F\b}{sprintf ""%.0fC"",($1-32)+5/9}eg’ +.txt
  
 which goes through
  +.txt
  files and replaces Fahrenheit values with Celsius ones (r eminiscent 
 of the first example from Chapter 2).
  
 In This Chapter 
  
 This chapter looks at everything regex about Perl,
 †
 including details of its regex flavor and the 
 operators that put them to use. This chapter presents the regex-r ele-vant details from the 
 ground up, but I assume that you have at least a basic famil-iarity with Perl. (If you’ve read 
 Chapter 2, you’re alr eady familiar enough to at least start using this chapter.) I’ll often use, in 
 passing, concepts that have not yet been examined in detail, and I won’t dwell much on non-
 regex aspects of the lan-guage. It might be a good idea to keep the Perl documentation 
 handy, or perhaps O’Reilly’s
  Pr ogramming Perl
 .
  
 † This book covers features of Perl as of Version 5.8.
  
 283
  
 29 April 2003 20:47",NA
Regular Expressions as a Language ,NA,NA
Component,"An attractive feature of Perl is that regex support is so deftly built in as part of the language. 
 Rather than providing stand-alone functions for applying regular expres-sions, Perl provides 
 regular-expr ession
  operators
  that are meshed well with the rich set of other operators and 
 constructs that make up the Perl language.
  
 With as much regex-wielding power as Perl has, one might think that it’s over-flowing with 
 differ ent operators and such, but actually, Perl provides only four regex-r elated operators, 
 and a small handful of related items, shown in Table 7-1.
  
 Table 7-1: Overview of Perl’s Regex-Related Items
  
 Regex-Related Operator s
  
 m/
 regex
 /
 mods 
  
 ( 306)
  
 s/
 regex
 /
 replacement
 /
 mods 
  
 ( 318)
  
 qr/
 regex
 /
 mods 
 ( 303)
  
 split(
 ˙˙˙
 ) 
  
 ( 321)
  
 Modifier s 
  
 Modify How . . .
  
 /x /o 
  
 regex is interpreted
  ( 292, 348)
  
 /s /m /i 
  
 engine considers target text
  ( 292)
  
 /g /c /e 
  
 other
  ( 311, 315, 319)
  
 After-Match Var iables
  ( 299)
  
 $1
 ,
  $2
 , etc. 
  
 captured text
  
 $ˆN $+ 
  
 latest/highest filled
  $1
 ,
  $2
 , . . .
  
 @- @+ 
  
 arrays of indices into target
  
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
 $‘ $& $’
  
 text before, of, and after match
  
 (
 best to avoid—see “Perl Efficiency Issues” 356
 )
  
 Related Pragmas
  
 use charnames ’:full’; 
  
 ( 290)
  
 use overload; 
  
 ( 341)
  
 use re ’eval’; 
 ( 337)
  
 use re ’debug’; 
  
 ( 361)
  
 Related Functions 
  
 lc lcfirst uc ucfirst
  ( 290) 
 pos
  ( 313) 
 quotemeta
  ( 290) 
  
 reset
  ( 308) 
  
 study
  ( 359)
  
 Related Var iables 
  
 $R 
  
 default search target
  ( 308) 
 $ˆR 
  
 embedded-code result
  ( 302)
  
 29 April 2003 20:47",NA
Perl’s Greatest Strength,"The richness of variety and options among Perl’s operators and functions is per-haps its 
 greatest feature. They can change their behavior depending on the context in which they’re 
 used, often doing just what the author naturally intends in each dif fering situation. In fact, 
 O’Reilly’s
  Pr ogramming Perl
  goes so far as to boldly state “In general, Perl operators do 
 exactly what you want....” The regex match operator
  m/
 regex
 /
 , for example, offers an 
 amazing variety of differ ent functionality depending upon where, how, and with which 
 modifiers it is used.",NA
Perl’s Greatest Weakness,"This concentrated richness in expressive power is also one of Perl’s least-attractive featur es. 
 Ther e ar e innumerable special cases, conditions, and contexts that seem to change out from 
 under you without warning when you make a subtle change in your code
  —
 you’ve just hit 
 another special case you weren’t aware of.
 †
 The
  Pr o-gramming Perl
  quote in the previous 
 paragraph continues “...unless you want consistency.” Certainly, when it comes to computer 
 science, there is a certain appr eciation to boring, consistent, dependable interfaces. Perl’s 
 power can be a devastating weapon in the hands of a skilled user, but it sometimes seems 
 with Perl, you become skilled by repeatedly shooting yourself in the foot.",NA
Perl’s Regex Flavor,"Table 7-2 on the facing page summarizes Perl’s regex flavor. It used to be that Perl had many 
 metacharacters that no other system supported, but over the years, other systems have 
 adopted many of Perl’s innovations. These common features ar e cover ed by the overview 
 in Chapter 3, but there are a few Perl-specific items discussed later in this chapter. (Table 7-2 
 has refer ences to where each item is discussed.)
  
 The following notes supplement the table:
  
 •
  !\b""
  matches a backspace only in class; otherwise, it’s a word boundary.
  
 •
  Octal escapes accept two- and three-digit numbers.
  
 •
  The
  !\x
 num
  ""
  hex escape accepts two-digit numbers (and one-digit numbers, but with a 
 warning if warnings are tur ned on). The
  !\x{
 num
 }""
  syntax accepts a hexadecimal number 
 of any length.
  
 † That they’re innumerable doesn’t stop this chapter from trying to cover them all!
  
 29 April 2003 20:47",NA
Regex Operands and Regex Literals,"The final items in Table 7-2 are marked “regex literals only.” A
  regex literal
  is the“
 regex
  ” part 
 of
  m/
 rege x
 /
 , and while casual conversation refers to that as “the regu-lar expression,” the 
 part between the ‘
 /
 ’ delimiters is actually parsed using its own unique rules. In Perl jargon, a 
 regex literal is treated as a “regex-awar e double-quoted string,” and it’s the result of that 
 processing that’s passed to the regex engine. This regex-literal processing offers special 
 functionality in building the reg-ular expression.
  
 For example, a regex literal offers
  variable interpolation
 . If the variable
  $num
  con-tains
  20
 , the 
 code
  m/:.{$num}:/
  pr oduces the regex
  !:.{20} :""
 . This way, you can
  
 29 April 2003 20:47",NA
How Regex Literals Are Par sed,"For the most part, one “just uses” the regex-literal features just discussed, without the need 
 to understand the exact details of how Perl converts them to a raw regu-lar expression. Perl 
 is very good at being intuitive in this respect, but there are times when a more detailed 
 understanding can help. The following lists the order in which processing appears to happen:
  
 1
 . The closing delimiter is found, and the modifiers (such as
  /i
 , etc.) are read. The rest of 
 the processing then knows if it’s in
  /x
  mode.
  
 2
 . Variables are interpolated.
  
 3
 . If regex overloading is in effect, each part of the literal is given to the over-load routine 
 for processing. Parts are separated by interpolated variables; the values interpolated are not 
 made available to overloading.
  
 If regex overloading is not in effect,
  \N{
 ˙˙˙
 }
  sequences are processed.
  
 4
 . Case-folding constructs (e.g.,
  \Q
 ˙˙˙
 \E
 ) are applied.
  
 5
 . The result is presented to the regex engine.
  
 This describes how the processing appears to the programmer, but in reality, the inter nal pr 
 ocessing done by Perl is quite complicated. Even step #2 must under-stand the regular-expr 
 ession metacharacters, so as not to, for example, treat the underlined portion of
  !this$;that$""
  
 as a variable refer ence.",NA
Regex Modifier s,"Perl’s regex operators allow
  regex modifiers
 , placed after the closing delimiter of the regex 
 literal (like the
  i
  in
  m/
 ˙˙˙
 /
 i
 ,
  s/
 ˙˙˙
 /
 ˙˙˙
 /
 i
 , or
  qr/
 ˙˙˙
 /
 i
 ). There are five core modifiers that all regex 
 operators support, shown in Table 7-3.
  
 The first four, described in Chapter 3, can also be used within a regex itself as a mode-
 modifier ( 133) or mode-modified span ( 134). When used both within
  
 29 April 2003 20:47",NA
Regex-Related Perlisms,"A variety of general Perl concepts pertain to our study of regular expressions. The next few 
 sections discuss:
  
 •
  Context An important concept in Perl is that many functions and operators 
  
 respond 
 to the
  context
  they’r e used in. For example, Perl expects a scalar 
  
 value as the 
 conditional of a
  while
  loop, but a list of values as the arguments 
  
 to a
  print
  
 statement. Since Perl allows expressions to “respond” to the con-
  
 text in which 
 they’re in, identical expressions in each case might produce 
  
 wildly differ ent results.
  
 •
  Dynamic Scope 
  
 Most programming languages support the concept of local 
  
 and global variables, but Perl provides an additional twist with something 
  
 known as
  
 dynamic scoping
 . Dynamic scoping temporarily “protects” a global 
  
 variable by saving 
 a copy of its value and automatically restoring it later. It’s 
  
 an intriguing concept that’s 
 important for us because it affects
  $1
  and other 
  
 match-r elated variables.
  
 † Because modifiers can appear in any order, a large portion of a programmer’s time is spent adjusting the order to 
 achieve maximum cuteness. For example,
  learn/by/osmosis
  is valid code (assuming you have a function called
  
 learn
 ). The
  o s m o s i s
  ar e the modifiers. Repeating modifiers is allowed, but meaningless (except for the 
 substitution-operator’s
  /e
  modifier, discussed later).
  
 29 April 2003 20:47",NA
Expression Context,"The notion of
  context
  is important throughout Perl, and in particular, to the match operator. 
 An expr ession might find itself in one of three contexts,
  list
 ,
  scalar
 , or 
 void
 , indicating the 
 type of value expected from the expression. Not surprisingly, a 
 list context
  is one where a list 
 of values is expected of an expression. A
  scalar context
  is one where a single value is expected. 
 These two are very common and of great interest to our use of regular expressions.
  Void 
 context
  is one in which no value is expected.
  
 Consider the two assignments:
  
 $s =
  expression one
 ; 
  
 @a =
  expression two
 ;
  
 Because
  $s
  is a simple scalar variable (it holds a single value, not a list), it expects a simple 
 scalar value, so the first expression, whatever it may be, finds itself in a scalar context. 
 Similarly, because
  @a
  is an array variable and expects a list of val-ues, the second expression 
 finds itself in a list context. Even though the two expr essions might be exactly the same, 
 they might retur n completely differ ent val-ues, and cause completely differ ent side effects 
 while they’re at it. Exactly what happens depends on each expression.
  
 For example, the
  localtime
  function, if used in a list context, retur ns a list of val-ues repr 
 esenting the current year, month, date, hour, etc. But if used in a scalar context, it retur ns a 
 textual version of the current time along the lines of ‘
 Mon Jan 20 22:05:15 2003
 ’.
  
 As another example, an
  I/O
  operator such as
  <MYDATA>
  retur ns the next line of the file in a 
 scalar context, but retur ns a list of all (remaining) lines in a list context.
  
 Like
  localtime
  and the
  I/O
  operator, many Perl constructs respond to their con-text. The 
 regex operators do as well
  —
  the match operator
  m/
 ˙˙˙
 /
 , for example, sometimes retur ns a 
 simple true/false value, and sometimes a list of certain match results. All the details are 
 found later in this chapter.
  
 Contor ting an expression
  
 Not all expressions are natively context-sensitive, so Perl has rules about what happens when 
 a general expression is used in a context that doesn’t exactly match the type of value the 
 expression normally retur ns. To make the square peg fit into a round hole, Perl “contorts” 
 the value to make it fit. If a scalar value is retur ned in a list context, Perl makes a list 
 containing the single value on the fly. Thus, 
 @a = 42
  is the same as
  @a = (42)
 .
  
 29 April 2003 20:47",NA
Dynamic Scope and Regex Match Effects,"Perl’s two types of storage (global and private variables) and its concept of 
 dynamic scoping
  ar e 
 important to understand in their own right, but are of partic-ular interest to our study of 
 regular expressions because of how after-match infor-mation is made available to the rest of 
 the program. The next sections describe these concepts, and their relation to regular 
 expressions.
  
 Global and private var iables
  
 On a broad scale, Perl offers two types of variables: global and private. Private variables are 
 declar ed using
  my(
 ˙˙˙
 )
 . Global variables are not declared, but just pop into existence when 
 you use them. Global variables are always visible from any-wher e and everywhere within the 
 program, while private variables are visible, lex-ically, only to the end of their enclosing 
 block. That is, the only Perl code that can dir ectly access the private variable is the code that 
 falls between the
  my
  declaration and the end of the block of code that encloses the
  my
 .
  
 The use of global variables is normally discouraged, except for special cases, such as the 
 myriad of special variables like
  $1
 ,
  $R
 , and
  @ARGV
 . Regular user variables ar e global unless 
 declared with
  my
 , even if they might “look” private. Perl allows the names of global variables 
 to be partitioned into groups called
  packages
 , but the variables are still global. A global 
 variable
  
 $Debug
  within the package 
 Acme::Widget
  has a
  fully qualified name
  of
  
 $Acme::Widget::Debug
 , but no matter how it’s refer enced, it’s still the same global variable. 
 If you
  use strict;
 , all (non-special) globals must either be refer enced via fully-qualified 
 names, or via a name declared with
  our
  (
 our
  declar es a
  name
 , not a new variable
  —
 see the 
 Perl documentation for details).
  
 Dynamically scoped values
  
 Dynamic scoping is an interesting concept that few programming languages pro-vide. We’ll 
 see the relevance to regular expressions soon, but in a nutshell, you can have Perl save a 
 copy of the value of a global variable that you intend to
  
 29 April 2003 20:47",NA
Special Var iables Modified by a Match,"A successful match or substitution sets a variety of global, read-only variables that ar e 
 always automatically dynamically scoped. These values
  never
  change if a match attempt is 
 unsuccessful, and are
  always
  set when a match is successful. When appropriate, they are set to 
 the empty string (a string with no characters in it), or undefined (a “no value” value, similar 
 to, yet testably distinct from, an empty string). Table 7-5 shows examples.
  
 In more detail, here are the variables set after a match:
  
 $& 
  
 A copy of the text successfully matched by the regex. This variable (along 
  
 with
  $‘
  
 and
  $’
 , described next) is best avoided for perfor mance reasons. 
  
 (See the discussion on page 
 356.)
  $&
  is never undefined after a successful 
  
 match, although it can be an empty string.
  
 29 April 2003 20:47",NA
The,NA,NA
 qr,NA,NA
/,NA,NA
˙˙˙,NA,NA
/ Operator and Regex Objects,"Intr oduced briefly in Chapter 2 and Chapter 6 ( 76; 277),
  qr/
 ˙˙˙
 /
  is a unary oper-ator that 
 takes a regex operand and retur ns a
  regex object
 . The retur ned object can then be used as a 
 regex operand of a later match, substitution, or
  split
 , or can be used as a sub-part of a larger 
 regex.
  
 Regex objects are used primarily to encapsulate a regex into a unit that can be used to build 
 larger expressions, and for efficiency (to gain control over exactly when a regex is compiled, 
 discussed later).
  
 As described on page 291, you can pick your own delimiters, such as
  qr{
 ˙˙˙
 }
  or 
 qr!
 ˙˙˙
 !
 . It 
 supports the core modifiers
  /i
 ,
  /x
 ,
  /s
 ,
  /m
 , and
  /o
 .",NA
Building and Using Regex Objects,"Consider the following, with expressions adapted from Chapter 2 ( 76):
  
 my
  $HostnameRegex
  =
  qr/
 [-a-z0-9]+(?:\.[-a-z0-9]+)+\.(?:com;edu;info)
 /i
 ;
  
 my $HttpUrl =
  qr{ 
  
  
 http://
  $HostnameRegex
  \b #
  Hostname 
  
  
 (?: 
  
  
  
 / [-a-z0-9R:\@&?=+,.!/˜+’%\$]+ #
  Optional path 
  
  
  
  
 (?<![.,?!]) #
  Not allowed to end with [.,?!] 
  
  
 )?
  
 }ix
 ;
  
 29 April 2003 20:47",NA
Viewing Regex Objects,"The previous paragraph talks about how regex objects logically wrap their regular expr 
 ession with mode-modified spans like
  !(?x-ism:
 ˙˙˙
 )""
 . You can actually see this for yourself, 
 because if you use a regex object where Perl expects a string, Perl kindly gives a textual repr 
 esentation of the regex it repr esents. For example:
  
 %
  perl -e ’print qr/\b \w+ \b/x, ""\n""’
  
 (?x-ism:\b \w+ \b)
  
 29 April 2003 20:47",NA
Using Regex Objects for Efficienc y,"One of the main reasons to use regex objects is to gain control, for efficiency rea-sons, of 
 exactly when Perl compiles a regex to an internal form. The general issue of regex 
 compilation was discussed briefly in Chapter 6, but the more complex Perl-r elated issues, 
 including regex objects, are discussed in “Regex Compilation, the
  /o
  Modifier,
  qr/
 ˙˙˙
 /
 , and 
 Efficiency” ( 348).",NA
The Match Operator,"The basic match
  
 $text =˜ m/
 regex
 /
  
 is the core of Perl regular-expr ession use. In Perl, a regular-expr ession match is an 
 operator
  
 that takes two
  operands
 , a target string operand and a regex operand, and retur ns a value.
  
 How the match is carried out, and what kind of value is retur ned, depend on the context the 
 match is used in ( 294), and other factors. The match operator is quite flexible
  —
 it can be 
 used to test a regular expression against a string, to pluck data from a string, and even to 
 parse a string part by part in conjunction with other match operators. While powerful, this 
 flexibility can make mastering it more complex. Some areas of concern include:
  
 •
  How to specify the regex operand
  
 •
  How to specify match modifiers, and what they mean
  
 •
  How to specify the target string to match against
  
 •
  A match’s side effects
  
 •
  The value retur ned by a match
  
 •
  Outside influences that affect the match
  
 29 April 2003 20:47",NA
Match’s Regex Operand,"The regex operand can be a regex literal or a regex object. (Actually, it can be a string or any 
 arbitrary expression, but there is little benefit to that.) If a regex lit-eral is used, match 
 modifiers may also be specified.
  
 Using a regex literal
  
 The regex operand is most often a regex literal within
  m/
 ˙˙˙
 /
  or just
  /
 ˙˙˙
 /
 . The lead-ing
  m
  is 
 optional if the delimiters for the regex literal are forward slashes or ques-tion marks 
 (delimiters of question marks are special, discussed in a bit). For consistency, I prefer to 
 always use the
  m
 , even when it’s not requir ed. As described earlier, you can choose your 
 own delimiters if the
  m
  is present ( 291).
  
 When using a regex literal, you can use any of the core modifiers described on page 292. The 
 match operator also supports two additional modifiers,
  /g
  and
  /c
 , discussed in a bit.
  
 Using a regex object
  
 The regex operand can also be a regex object, created with
  qr/
 ˙˙˙
 /
 . For example:
  
 my
  $regex
  = qr/
 regex
 /; 
  
 + 
  
 + 
  
 + 
  
 if ($text =˜
  $regex
 ) { 
  
   
 + 
  
   
 + 
  
   
 +
  
 You can use
  m/
 ˙˙˙
 /
  with a regex object. As a special case, if the
  only
  thing within the “regex 
 literal” is the interpolation of a regex object, it’s exactly the same as using the regex object 
 alone. This example’s
  if
  can be written as:
  
 if ($text =˜
  m/
 $regex
 /
 ) { 
  
 + 
  
 + 
  
 +
  
 This is convenient because it perhaps looks more familiar, and also allows you to use the
  /g
  
 modifier with a regex object. (You can use the other modifiers that 
 m/
 ˙˙˙
 /
  supports as well, 
 but they’re meaningless in this case because they can never override the modes locked in a 
 regex object 304.)
  
 29 April 2003 20:47",NA
Specifying the Match Target Operand,"The normal way to indicate “this is the string to search” is using
  =˜
 , as with 
 $text =˜ m/
 ˙˙˙
 /
 . 
 Remember that
  =˜
  is
  not
  an assignment operator, nor is it a com-parison operator. It is mer 
 ely a funny-looking way of linking the match operator with one of its operands. (The 
 notation was adapted from awk.)
  
 Since the whole “
  expr
  =˜ m/
 ˙˙˙
 /
  ” is an expr ession itself, you can use it wherever an 
 expression is allowed. Some examples (each separated by a wavy line):
  
 $text =˜ m/
 ˙˙˙
 /; #
  Just do it, presumably, for the side effects.
  
  
 if ($text =˜ m/
 ˙˙˙
 /) { 
  
 #
  Do code if match is successful 
  
   
 + 
  
   
 + 
  
   
 +
  
  
 $result = ( $text =˜ m/
 ˙˙˙
 / ); #
  Set $result to result of match against $text
  
 $result =
  
 $text =˜ m/
 ˙˙˙
 /
  
 ; #
  Same thing; =˜ has higher precedence than =
  
  
 $copy = $text;
  
 =˜ m/
 ˙˙˙
 /; 
  
 #
  Copy $text to $copy ...
  
 $copy 
  
 #
  ... and perfor m match on $copy
  
  
 ( $copy = $text ) =˜ m/
 ˙˙˙
 /; 
  
 The default target
  
 #
  Same thing in one expression
  
 If the target string is the variable
  $R
 , you can omit the “
  $
 Q
  =˜
  ” parts altogether. In other 
 words, the default target operand is
  $R
 .",NA
Different Uses of the Match Operator,"You can always use the match operator as if it retur ns a simple true/false indicat-ing the 
 success of the match, but there are ways you can get additional informa-tion about a 
 successful match, and to work in conjunction with other match operators. How the match 
 operator works depends primarily on the
  context
  in which it’s used ( 294), and whether the
  /g
  
 modifier has been applied.
  
 29 April 2003 20:47",NA
"Iterative Matching: Scalar Context, with /g","A scalar-context
  m/
 ˙˙˙
 /g
  is a special construct quite differ ent fr om the others. Like a nor mal
  
 m/
 ˙˙˙
 /
 , it does just one match, but like a list-context
  m/
 ˙˙˙
 /g
 , it pays atten-tion to where 
 previous matches occurred. Each time a scalar-context
  m/
 ˙˙˙
 /g
  is reached, such as in a loop, it 
 finds the “next” match. If it fails, it resets the “current position,” causing the next 
 application to start again at the beginning of the string.
  
 Her e’s a simple example:
  
 $text = ""WOW! This is a SILLY test."";
  
 $text =˜ m/\b([a-z]+\b)/
 g
 ; 
  
 print ""The first all-lowercase word: $1\n"";
  
 $text =˜ m/\b([A-Z]+\b)/
 g
 ; 
  
 print ""The subsequent all-uppercase word: $1\n"";
  
 With both scalar matches using the
  /g
  modifier, it results in:
  
 The first all-lowercase word: is 
  
 The subsequent all-uppercase word: SILLY
  
 The two scalar-
 /g
  matches work together: the first sets the “current position” to just after 
 the matched lowercase word, and the second picks up from there to find the first uppercase 
 word
  that follows
 . The
  /g
  is requir ed for either match to pay attention to the “current 
 position,” so if
  either
  didn’t have
  /g
 , the second line would refer to ‘
 WOW
 ’.
  
 29 April 2003 20:47",NA
The Match Operator’s Environmental Relations,"The following sections summarize what we’ve seen about how the match operator influences 
 the Perl environment, and vice versa.
  
 29 April 2003 20:47",NA
The Substitution Operator,"Perl’s substitution operator
  s/
 ˙˙˙
 /
 ˙˙˙
 /
  extends a match to a full match-and-replace. The general 
 form is:
  
 $text =˜ s/
 regex
 /
 replacement
 /
 modifiers
  
 In short, the text first matched by the regex operand is replaced by the value of the 
 replacement operand. If the
  /g
  modifier is used, the regex is repeatedly applied to the text 
 following the match, with additional matched text replaced as well.
  
 As with the match operator, the target text operand and the connecting
  =˜
  ar e optional if the 
 target is the variable
  $R
 . But unlike the match operator’s
  m
 , the sub-stitution’s
  s
  is never 
 optional.
  
 We’ve seen that the match operator is fairly complex
  —
  how it works, and what it retur ns, is 
 dependent upon the context it’s called in, the target string’s
  pos
 , and the modifiers used. In 
 contrast, the substitution operator is simple: it always retur ns the same information (an 
 indication of the number of substitutions done), and the modifiers that influence how it 
 works are easy to understand.
  
 You can use any of the core modifiers described on page 292, but the substitution operator 
 also supports two additional modifiers:
  /g
  and, described in a bit,
  /e
 .
  
 29 April 2003 20:47",NA
The Replacement Operand,"With the normal
  s/
 ˙˙˙
 /
 ˙˙˙
 /
 , the replacement operand immediately follows the regex operand, 
 using a total of three instances of the delimiter rather than the two of 
 m/
 ˙˙˙
 /
 . If the regex uses 
 balanced delimiters (such as
  <
 ˙˙˙
 >
 ), the replacement operand then has its own independent 
 pair of delimiters (yielding a total of four). For example,
  s{
 ˙˙˙
 }{
 ˙˙˙
 }
  and
  s[
 ˙˙˙
 ]/
 ˙˙˙
 /
  and
  s<
 ˙˙˙
 >’
 ˙˙˙
 ’
  ar e all 
 valid. In such cases, the two sets may be separated by whitespace, and if so, by comments as 
 well. Bal-anced delimiters are commonly used with
  /x
  or
  /e
 :
  
 $text =˜
  s{ 
  
 ...some big regex here, with lots of comments and such...
  
 } { 
  
 ...a Perl code snippet to be evaluated to produce the replacement text...
  
 }ex
 ;
  
 Take care to separate in your mind the regex and replacement operands. The regex operand 
 is parsed in a special regex-specific way, with its own set of special delimiters ( 291). The 
 replacement operand is parsed and evaluated as a normal double-quoted string. The 
 evaluation happens after the match (and with
  /g
 , after each match), so
  $1
  and the like are 
 available to refer to the proper match slice.
  
 Ther e ar e two situations where the replacement operand is not parsed as a dou-ble-quoted 
 string:
  
 •
  When the replacement operand’s delimiters are single quotes, it is parsed as a 
  
 single-
 quoted string, which means that no variable interpolation is done.
  
 •
  If the
  /e
  modifier (discussed in the next section) is used, the replacement operand is 
 parsed like a little Perl script instead of like a double-quoted string. The little Perl script 
 is executed after each match, with its result being used as the replacement.",NA
The /e Modifier,"The
  /e
  modifier causes the replacement operand to be evaluated as a Perl code snippet, as if 
 with
  eval {
 ˙˙˙
 }
 . The code snippet’s syntax is checked to ensure it’s valid Perl when the script is 
 loaded, but the code is evaluated afresh after each match. After each match, the replacement 
 operand is evaluated in a scalar context, and the result of the code is used as the 
 replacement. Here’s a simple example:
  
 $text =˜
  s/
 -time-
 /
 localtime
 /ge
 ;
  
 This replaces occurrences of
  !-time-""
  with the results of calling Perl’s
  localtime 
 function in a 
 scalar context (which retur ns a textual repr esentation of the current time, such as “
 Wed Sep 
 25 18:36:51 2002
 ”).
  
 Since the evaluation is done after each match, you can refer to the text just matched with the 
 after-match variables like
  $1
 . For example, special characters
  
 29 April 2003 20:47",NA
Quiz Answer,"O
 Answer to the question on page 318.
  
 The question snippets on page 318 produce:
  
 WHILE stooge is Larry. 
  
 WHILE stooge is Curly.
  
 WHILE stooge is Moe.
  
 IF stooge is Larry.
  
 FOREACH 
 stooge 
 is 
 Moe. 
  
 FOREACH 
 stooge 
 is 
 Moe. 
  
 FOREACH stooge is Moe.
  
 Note that if the
  print
  within the
  foreach
  loop had referr ed to
  $R
  rather than
  $&
 , its 
 results would have been the same as the
  while
 ’s. In this 
 foreach
  case, however, the 
 result retur ned by the
  m/
 ˙˙˙
 /g
 ,
  (
 ’Larry’,’Curly’, ’Moe’
 )
 , goes unused. Rather, the side 
 effect
  $&
  is used, which almost certainly indicates a programming mistake, as the side 
 effects of a list-context
  m/
 ˙˙˙
 /g
  ar e not often useful.
  
 that might not otherwise be allowed in a
  URL
  can be encoded using
  %
  followed by their two-
 digit hexadecimal repr esentation. To encode all non-alphanumerics this way, you can use
  
 $url =˜ s/([ˆa-zA-Z0-9])/
 sprintf(’%%%02x’, ord($1))
 /ge;
  
 and to decode back to the original, you can use:
  
 $url =˜ s/%([0-9a-f][0-9a-f])/
 pack(""C"", hex($1))
 /ige;
  
 In short,
  sprintf(’%%%02x’, ord(
 character
 ))
  converts characters to their numeric 
 URL
  repr 
 esentation, while 
 pack(""C"",
  value
 )
  does the opposite; consult your favorite Perl documentation 
 for more infor mation.
  
 Multiple uses of /e
  
 Nor mally, repeating a modifier with an operator doesn’t hurt (except perhaps to confuse the 
 reader), but repeating the
  /e
  modifier actually changes how the replacement is done. 
 Normally, the replacement operand is evaluated once, but if mor e than one ‘
 e
 ’ is given, the 
 results of the evaluation are themselves evaluated as Perl, over and over, for as many extra ‘
 e
 ’ 
 as are provided. This is perhaps useful mostly for an Obfuscated Perl Contest.
  
 Still, it can be useful. Consider interpolating variables into a string manually (such as if the 
 string is read from a configuration file). That is, you have a string that looks like ‘
 ˙˙˙
  $var
  
 ˙˙˙
 ’ and you want to replace the substring ‘
 $var
 ’ with the value of the 
 variable
  $var
 .
  
 29 April 2003 20:47",NA
Context and Return Value,"Recall that the match operator retur ns dif ferent values based upon the particular 
 combination of context and
  /g
 . The substitution operator, however, has none of these 
 complexities
  —
 it always retur ns either the number of substitutions perfor med or, if none 
 were done, an empty string.
  
 Conveniently, when interpreted as a Boolean (such as for the conditional of an 
 if
 ), the retur n 
 value is taken as true if any substitutions are done, false if not.",NA
The Split Operator,"The multifaceted
  split
  operator (often called a
  function
  in casual conversation) is commonly 
 used as the converse of a list-context
  m/
 ˙˙˙
 /g
  ( 311). The latter retur ns text matched by the 
 regex, while a
  split
  with the same regex retur ns text
  sepa-rated
  by matches. The normal match
  
 $text =˜ m/:/g
  applied against a
  $text
  of‘
 IO.SYS:225558:95-10-03:-a-sh:optional
 ’, retur ns 
 the four-element list
  
 ( ’:’
 ,
  ’:’
 ,
  ’:’
 ,
  ’:’ ) 
  
 which doesn’t seem useful. On the other hand,
  split(/:/, $text)
  retur ns the five-element list:
  
 ( ’IO.SYS’
 ,
  ’225558’
 ,
  ’95-10-03’
 ,
  ’-a-sh’
 ,
  ’optional’ ) 
  
 Both examples reflect that
  !:""
  matches four times. With
  split
 , those four matches partition a 
 copy of the target into five chunks, which are retur ned as a list of five strings.
  
 That example splits the target string on a single character, but you can split on any arbitrary 
 regular expression. For example,
  
 @Paragraphs = split(m/\s+<p>\s+/i, $html);
  
 splits the
  HTML
  in
  $html
  into chunks, at
  <p>
  or
  <P>
 , surr ounded by optional whitespace. 
 You can even split on locations, as with
  
 @Lines = split(m/ˆ/m, $lines);
  
 to break a string into its logical lines.
  
 In its most simple form with simple data like this,
  split
  is as easy to understand as it is useful. 
 However, ther e ar e many options, special cases, and special
  
 29 April 2003 20:47",NA
Basic Split,"split
  is an operator that looks like a function, and takes up to three operands:
  
 split(
 match operand
 ,
  target string
 ,
  chunk-limit operand
 )
  
 The parentheses are optional. Default values (discussed later in this section) are pr ovided for 
 operands left off the end.
  
 split
  is always used in a list context. Common usage patterns include:
  
 ($
 var1
 , $
 var2
 , $
 var3
 ,
 ˙˙˙
 ) = split(
 ˙˙˙
 );
  
  
 @
 array
  = split(
 ˙˙˙
 );
  
  
 for my $item (split(
 ˙˙˙
 )) { 
  
  
 + 
  
  
 + 
  
  
 + 
  
 }
  
 Basic match operand
  
 The match operand has several special-case situations, but it is normally the same as the 
 regex operand of the match operator. That means that you can use
  /
 ˙˙˙
 /
  and 
 m{
 ˙˙˙
 }
  and the like, 
 a regex object, or any expression that can evaluate to a string. Only the core modifiers 
 described on page 292 are supported.
  
 If you need parentheses for grouping, be sure to use the
  !(?:
 ˙˙˙
 )""
  non-capturing kind. As we’ll 
 see in a few pages, the use of capturing parentheses with
  split 
 tur ns on a very special feature.
  
 Target string operand
  
 The target string is inspected, but is never modified by
  split
 . The content of
  $R
  is the default 
 if no target string is provided.",NA
Retur ning Empty Elements,"The basic premise of
  split
  is that it retur ns the text separated by matches, but ther e ar e 
 times when that retur ned text is an empty string (a string of length zero, e.g.,
  """"
 ). For 
 example, consider
  
 @nums = split(m/:/, ""12:34::78"");
  
 This retur ns
  
 (
 ""12"", ""34"", """", ""78""
 )
  
 The regex
  !:""
  matches three times, so four elements are retur ned. The empty third element 
 reflects that the regex matched twice in a row, with no text in between.
  
 Tr ailing empty elements
  
 Nor mally, trailing empty elements are
  not
  retur ned. For example,
  
 @nums = split(m/:/, ""12:34::78:::"");
  
 sets
  @nums
  to the same four elements
  
 (
 ""12"", ""34"", """", ""78""
 )
  
 as the previous example, even though the regex was able to match a few extra times at the 
 end of the string. By default,
  split
  does not retur n empty elements at the end of the list. 
 However, you can have
  split
  retur n all trailing elements by using an appropriate chunk-limit 
 operand . . .
  
 The chunk-limit operand’s second job
  
 In addition to possibly limiting the number of chunks, any non-zero chunk-limit operand 
 also preserves trailing empty items. (A chunk limit given as zero is exactly the same as if no 
 chunk limit is given at all.) If you don’t want to limit the number of chunks retur ned, but do 
 want to leave trailing empty elements intact, simply choose a very large limit. Or, better yet, 
 use
  -1
 , because a negative chunk limit is taken as an arbitrarily large limit:
  split(/:/, $text, -1)
  
 retur ns all elements, including any trailing empty ones.
  
 At the other extreme, if you want to remove
  all
  empty items, you could put 
 grep {length}
  
 befor e the
  split
 . This use of
  grep
  lets pass only list elements with non-zer o lengths (in other 
 words, elements that aren’t empty):
  
 my @NonEmpty = grep { length } split(/:/, $text);
  
 Special matches at the ends of the string
  
 A match at the very beginning normally produces an empty element:
  
 @nums = split(m/:/, "":12:34::78"");
  
 29 April 2003 20:47",NA
Split’s Special Regex Operands,"split
 ’s match operand is normally a regex literal or a regex object, as with the match operator, 
 but there are some special cases:
  
 •
  An empty regex for
  split
  does not mean “Use the current default regex,” but to split the 
 target string into a list of characters. We saw this before at the start of the
  split
  
 discussion, noting that
  split(//, ""short test"")
  retur ns a list of ten elements:
  (""s"", ""h"", 
 ""o"",
  ˙˙˙
 , ""s"", ""t"")
 .
  
 •
  A match operand that is a
  string
  (not a regex) consisting of exactly one space is a special 
 case. It’s almost the same as
  /\s+/
 , except that leading whitespace is skipped. This is all 
 meant to simulate the default input-record-separator splitting that awk does with its 
 input, although it can certainly be quite useful for general use.
  
 If you’d like to keep leading whitespace, just use
  m/\s+/
  dir ectly. If you’d like to keep 
 trailing whitespace, use
  -1
  as the chunk-limit operand.
  
 •
  If no regex operand is given, a string consisting of one space (the special case in the 
 previous point) is used as the default. Thus, a raw
  split
  without any operands is the same 
 as
  split(’ ’, $
 Q
 , 0)
 .
  
 •
  If the regex
  !ˆ""
  is used, the
  /m
  modifier (for the enhanced line-anchor match mode) is 
 automatically supplied for you. (For some reason, this does not hap-pen for
  !$""
 .) Since 
 it’s so easy to just use
  m/ˆ/
 m
  explicitly, I would recommend doing so, for clarity. 
 Splitting on
  m/ˆ/m
  is an easy way to break a multiline string into individual lines.
  
 Split has no side effects
  
 Note that a
  split
  match operand often
  looks
  like a match operator, but it has none of the side 
 effects of one. The use of a regex with
  split
  doesn’t affect the default regex for later match 
 or substitution operators. The variables
  $&
 ,
  $’
 ,
  $1
 ,
  
 29 April 2003 20:47",NA
Split’s Match Operand with Capturing Parentheses,"Capturing parentheses change the whole face of
  split
 . When they are used, the retur ned list 
 has additional, independent elements interjected for the item
 (
 s
 )
  cap-tur ed by the 
 parentheses. This means that some or all text normally
  not
  retur ned by
  split
  is now included 
 in the retur ned list.
  
 For example, as part of
  HTML
  pr ocessing,
  split(/
 (
 <[ˆ>]+>
 )
 /)
  tur ns
  
 ˙˙˙
  and
  <B>
 very
  <FONT color=red>
 very
 </FONT>
  much
 </B>
  effort
 ˙˙˙
  
 into:
  
 ( ’... and ’
 ,
  ’<B>’
 ,
  ’very ’
 ,
  ’<FONT color=red>’
 ,
  
 ’very’
 ,
  ’</FONT>’
 ,
  ’ much’
 ,
  ’</B>’, ’ effort...’ )
  
 With the capturing parentheses removed,
  split(/<[ˆ>]+>/)
  retur ns:
  
 ( ’... and ’
 ,
  ’very ’
 ,
  ’very’
 ,
  ’ much’
 ,
  ’ effort...’ )
  
 The added elements do not count against a chunk limit. (The chunk limit limits the chunks 
 that the original string is partitioned into, not the number of elements retur ned.)
  
 If there are multiple sets of capturing parentheses, multiple items are added to the list with 
 each match. If there are sets of capturing parentheses that don’t contribute to a match,
  undef
  
 elements are inserted for them.",NA
Fun with Perl Enhancements,"Many regular-expr ession concepts that are now available in other languages were first made 
 available only in Perl. Examples include non-capturing parentheses, lookahead, (and later, 
 lookbehind), free-spacing mode, (most modes, actually
  —
 and with them comes
  !\A""
 ,
  !\z""
 , 
 and
  !\Z""
  ), atomic grouping,
  !\G""
 , and the conditional construct. However, these are no 
 longer Perl specific, so they are all covered in the main chapters of this book.
  
 Still, Perl developers remain innovative, so there are some major concepts avail-able at this 
 time only in Perl. One of the most interesting is the ability to execute arbitrary code
  during the 
 match attempt
 . Perl has long featured strong integration of regular expressions into code, but 
 this brings integration to a whole new level.
  
 † Actually, there is one side effect remaining from a feature that has been deprecated for many years, but has not 
 actually been removed from the language yet. If
  split
  is used in a scalar or void con-text, it writes its results to the
  
 @R
  variable (which is also the variable used to pass function argu-ments, so be careful not to use
  split
  in these 
 contexts by accident).
  use warnings
  or the
  -w
  com-mand-line argument warns you if
  split
  is used in either 
 context.
  
 29 April 2003 20:47",NA
Using a Dynamic Regex to Match Nested Pair s,"A dynamic regex’s main use is to allow a regex to match arbitrarily nested con-structs 
 (something long thought to be impossible with regular expressions). Its quintessential 
 example is to match content with arbitrarily nested parentheses. To see how a dynamic regex 
 is useful for this, let’s first look at why it’s not possible with traditional constructs.
  
 This simple regex matches a parenthesized run of text:
  !\(
 ([ˆ()] )
 ,\)""
 . It doesn’t allow 
 parentheses within the outer parentheses, so it doesn’t allow any nesting (that is, it supports 
 zero levels of nesting). We can put it into a regex object and use it like this:
  
 my $Level0 = qr/ \(
  
 ( [ˆ()] )+
  
 \) /x; #
  Par enthesized text
  
 + 
  
 + 
  
 + 
  
 if ($text =˜ m/\b( \w+$Level0 )/x) { 
  
   
 print ""found function call: $1\n""; 
  
 }
  
 This would match “
 substr($str, 0, 3)
 ”, but not “
 substr($str, 0, (3+2))
 ”because it has nested 
 parentheses. Let’s expand our regex to handle it. That means accommodating one level of 
 nesting.
  
 29 April 2003 20:47",NA
\,NA,NA
(,NA,NA
(,NA,NA
 [^,(),NA
]|,NA,NA
),NA,NA
* \,NA,NA
) ,NA,NA
\,NA,NA
(,NA,NA
(,NA,NA
 [^,(),NA
]|,NA,NA
),NA,NA
* \,NA,NA
) ,NA,NA
\,NA,NA
(,NA,NA
(,NA,NA
 [^,(),NA
]|,NA,NA
),NA,NA
* \,NA,NA
),Level 0,NA
\,NA,NA
(,NA,NA
(,NA,NA
 [^,()],NA
),NA,NA
* \,NA,NA
),"Figur e 7-1: Matching a few levels of parentheses
  
 It’s interesting to see the result of all those levels. Here’s what
  $Level3
  boils down to:
  
 \(([ˆ()];\(([ˆ()];\(([ˆ()];\(([ˆ()])+\))+\))+\))+\)
  
 Wow, that’s ugly.
  
 29 April 2003 20:47",NA
Using the Embedded-Code Construct,"The embedded-code construct is particularly useful for regex debugging, and for 
 accumulating information about a match while it’s happening. The next few pages walk 
 through a series of examples that eventually lead to a method for mimicking 
 POSIX
  match 
 semantics. The journey there is perhaps more inter esting than the actual destination (unless 
 you need
  POSIX
  match semantics, of course) because of the useful techniques and insight we 
 gain along the way.
  
 We’ll start with some simple regex debugging techniques.
  
 Using embedded code to display match-time infor mation
  
 This code:
  
 ""abcdefgh"" =˜ m{ 
  
 (?{
  print ""starting match at [$‘;$’]\n""
  }) 
  
 (?:d;e;f) 
  
 }x;
  
 pr oduces:
  
 starting 
 match 
 at 
 [;abcdefgh] 
  
 starting 
 match 
 at 
 [a;bcdefgh] 
  
 starting 
 match 
 at 
 [ab;cdefgh] 
  
 starting match at [abc;defgh]
  
 The embedded-code construct is the first thing in the regex, and so executes
  
 print ""starting match at [$‘;$’]\n""
  
 whenever the regex starts a new match attempt. The displayed string uses the
  $‘
 and
  $’
  
 variables ( 300)
 †
 to print the target text being matched, with ‘
 ;
 ’ inserted to mark the current 
 location in the match (which in this case is where the match attempt is starting). From the 
 result, you can tell that the regex was applied four times by the transmission ( 148) before it 
 was successful.
  
 † Nor mally, I recommend against using the special match variables
  $‘
 ,
  $&
 , and
  $’
 , as they can inflict a 
  
 major 
 efficiency penalty on the entire program ( 356), but they’re fine for temporary debugging.",NA
panic: top_env,"If you’re working with embedded code or a dynamic regex, and your pro-gram suddenly 
 ends with an unceremonial
  
 panic: topRenv
  
 it is likely due to a syntax error in the code part of the regex. Perl currently doesn’t 
 handle certain kinds of broken syntax well, and the panic is the result. The solution, of 
 course, is to correct the syntax.
  
 Using embedded code to see all matches
  
 Perl has a Traditional
  NFA
  engine, so it stops the moment a match is found, even though 
 there may be additional possible matches. With the clever use of embed-ded code, we can 
 trick Perl into showing us
  all
  possible matches. To see how, let’s revisit the silly ‘
 oneself
 ’ 
 example from page 177:
  
 ""oneselfsufficient"" =˜ m{ 
  
 one(self)?(selfsufficient)?
  
  
 (?{
  print ""matched at [$‘<$&>$’]\n""
  }) 
  
 }x;
  
 29 April 2003 20:47",NA
Using,NA,NA
 local,NA,NA
 in an Embedded-Code Construct,"The use of
  local
  within an embedded-code construct takes on special meaning. 
 Understanding it requir es a good understanding of
  dynamic scoping
  ( 295) and of the “crummy 
 analogy” from the Chapter 4’s discussion of how a regex-dir ected 
 NFA
  engine goes about 
 its work ( 158). The following contrived (and, as we’ll see, flawed) example helps to illustrate 
 why, without a lot of extraneous clutter. It
  
 29 April 2003 20:47",NA
Interpolating Embedded Perl,"As a security measure, Perl doesn’t normally allow an embedded-code con-struct
  
 !(?{
 ˙˙˙
 })""
  or a dynamic-subexpression construct
  !(??{
 ˙˙˙
 })""
  to be interpo-lated into the 
 regex from a string variable. (They are allowed, though, from a regex object, as with
  
 $RecordPossibleMatch
  on page 334.) That is,
  
 m{ 
  
 (?{ print ""starting\n"" })
  
 some regex
 ˙˙˙
  
 }x;
  
 is allowed, but
  
 my
  $ShowStart
  =
  ’
 (?{ print ""starting\n"" })
 ’
 ; 
 + 
  
 + 
  
 + 
  
 m{
  $ShowStart
  some regex
 ˙˙˙
  
 }x;
  
 is not. This limitation is imposed because it has long been common to include user 
 input as part of a regex, and the introduction of these constructs suddenly allowing 
 such a regex to run arbitrary code creates a huge security hole. So, the default is that 
 it’s disallowed.
  
 If you’d like to allow this kind of interpolation, the declaration:
  
 use re ’eval’;
  
 lifts the restriction. (With differ ent arguments, the
  use re
  pragma can also be used for 
 debugging; 361.)
  
 Sanitizing user input for interpolation
  
 If you use this and do allow user input to be interpolated, be sure that it has no 
 embedded-Perl or dynamic-regex constructs. You can do this by checking against
  
 !\(\s+\?+[p{]""
 . If this matches the input, it’s not safe to use in a regex. The
  !\s+""
  is 
 needed because the
  /x
  modifier allows spaces after the opening parentheses. (I’d think 
 that they shouldn’t be allowed there, but they are.) The plus quantifies
  !\?""
  so that 
 both constructs are recognized. Finally, the
  p
  is included to catch the now-deprecated
  
 !(?p{
 ˙˙˙
 })""
  construct, the forerunner of
  !(??{
 ˙˙˙
 })""
 .
  
 I think it would be useful if Perl supported a modifier of some sort that allowed or 
 prohibited embedded code on a per-r egex or subexpression basis, but until one is 
 introduced, you’ll have to check for it yourself, as described above.
  
 So,
  local
  is requir ed to keep
  $Count
  consistent until the end of the regex. If we wer e to put
  
 !(?{ print ""Final count is $Count.\n"" })""
  at the end of the regex, it would report the proper 
 count. Since we want to use
  $Count
  after the match, we need to save it to a non-localized 
 variable at some point before the match officially ends. This is because all values that had 
 been localized during the match are lost when the match finishes.
  
 29 April 2003 20:47",NA
A War ning About Embedded Code and,NA,NA
 my,NA,NA
 Variables,"If you have a
  my
  variable declared
  outside
  a regex, but refer to it from
  inside
  regex
  
 embedded code, you must be very careful about a subtle issue with Perl’s variable
  
 binding that has a very unsubtle impact. Before describing the issue, I’ll note up
  
 fr ont that if you use only global variables within regex embedded code, you don’t
  
 have to worry about this issue, and you can safely skip this section. War ning: this
  
 section is not light reading.
  
 This contrived example illustrates the problem:
  
 sub CheckOptimizer 
  
 { 
  
 my $text = shift; #
  The first argument is the text to check.
  
 my
  $start
  = undef; #
  We’ll note here wher e the regex is first applied.
  
 my $match = $text =˜ m{ 
  
  
 (?{
  $start
  = $-[0] if not defined
  $start
 }) #
  Save the first starting position 
  
 \d #
  This is the regex 
 being tested 
  
 }x;
  
 if (not defined
  $start
 ) { 
  
  
 print ""The whole match was optimized away.\n""; 
  
  
 if ($match) { 
  
  
  
 #
  This can’t possibly happen!
  
  
  
 print ""Whoa, but it matched! How can this happen!?\n""; 
   
 } 
  
 } elsif (
 $start
  == 0) { 
  
  
  
 print ""The match start was not optimized.\n""; 
  
 } else { 
  
  
  
 print ""The optimizer started the match at character
  $start
 .\n"" } 
  
 }
  
 This code has three
  my
  variables, but only one,
  $start
 , is related to this issue (the
  
 others are not refer enced fr om within embedded code, so are not at issue). It
  
 29 April 2003 20:47",NA
Matching Nested Constructs with Embedded Code,"The example on page 328 shows how to match arbitrarily nested pairs using a dynamic 
 regex. That’s generally the easiest way to do it, but it’s instructive to see a method using only 
 embedded-code constructs, so I’d like to show it to you here.
  
 The approach is simply this: keep a count of how many open parentheses we’ve seen that 
 have not yet been closed, and allow a closing parenthesis only if there ar e outstanding 
 opens. We’ll use embedded code to keep track of the count as we match through the text, 
 but before looking at that, let’s look at a (not yet working) skeleton the expression:
  
 my $NestedGuts = qr{ 
  
 (?> 
  
  
 (?: 
  
   
 #
  Stuf f not parenthesis 
  
    
  
 [ˆ()]+ 
  
   
 #
  An opening parenthesis 
  
   
 ; 
  
 \( 
  
   
 #
  A closing parenthesis 
  
   
 ; 
  
 \) 
  
  
 )+ 
  
 ) 
  
 }x;
  
 The atomic grouping is requir ed for efficiency, to keep the
  !( [
 ˙˙˙
 ]
 +
  ;
  ˙˙˙
 ),""
  fr om becoming a 
 neverending match ( 226) if
  $NestedGuts
  is used as part of some larger expression that could 
 cause backtracking. For example, if we used it as part of
  m/ˆ\( $NestedGuts \)$/x
  and 
 applied it to ‘
 (this is missing the close
 ’, it would track and backtrack for a long time if atomic 
 grouping didn’t prune the redundant states.
  
 To incorporate the counting, we need these four steps:
  
 –
 Befor e beginning, the count must be initialized to zero:
  
 (?{ local $OpenParens = 0 })
  
 —
 When an open parenthesis is seen, we increment the count to indicate that one more set 
 of parentheses has yet to balance.
  
 (?{ $OpenParens++ })
  
 ˜
 When a close parenthesis is seen, we check the count, and if it’s currently positive, we 
 decrement the count to recognize that one less set remains unbalanced. On the other 
 hand, if the count is zero, we can’t allow the match to continue (because the close 
 parenthesis does not balance with an open), so we apply
  !(?!)""
  to force failure:
  
 (?(?{ $OpenParens }) (?{ $OpenParens-- }) ; (?!) )
  
 This uses an
  !
 (?
 if then
  <
 else
 )
 ""
  conditional ( 138), with an embedded-code construct 
 checking the count as the
  if
 .
  
 29 April 2003 20:47",NA
Overloading Regex Literals,"You can pre-pr ocess the literal parts of a regex literal in any way you like with 
 overloading
 . 
 The next sections show examples.
  
 Adding start- and end-of-word metacharacter s
  
 Perl doesn’t support
  !\<""
  and
  !\>""
  as start- and end-of-word metacharacters, and that’s 
 probably because it’s rare that
  !\b""
  doesn’t suffice. However, if we wish to have them, we 
 can support them ourselves using overloading to replace ‘
 \<
 ’ and‘
 \>
 ’ in a regex by
  
 !(?<!\w)(?=\w)""
  and
  !(?<=\w)(?!\w)""
 , respectively.
  
 29 April 2003 20:47",NA
Problems with Regex-Literal Overloading,"Regex-literal overloading can be extremely powerful, at least in theory, but unfor-tunately, 
 it’s not very useful in practice. The problem is that it applies to only the 
 literal
  part of a regex 
 literal, and not the parts that are interpolated. For example, with the code
  m/($MyStuff)
 ,
 +/
  
 our
  MungeRegexLiteral
  function is called twice, once with the literal part of the regex before 
 the variable interpolation (“
 (
 ”), and once with the part after (“
 )
 ,
 +
 ”). (It’s never even given 
 the contents of 
 $MyStuff
 .) Since our function requir es both parts at the same time, variable 
 inter-polation effectively disables it.
  
 This is less of an issue with the support for
  \<
  and
  \>
  we added earlier, since they’r e not 
 likely to be broken up by variable interpolation. But since overloading doesn’t affect the 
 contents of an interpolated variable, a string or regex object con-taining ‘
 \<
 ’ or ‘
 \>
 ’ would 
 not be processed by overloading. Also, as the previous section touched on, when a regex 
 literal is processed by overloading, it’s not easy to be complete and accurate every time. Even 
 something as simple as our support for
  \>
  gets in the way when given ‘
 \\>
 ’, ostensibly to 
 match a ‘
 \
 ’ followed by ‘
 >
 ’.
  
 Another problem is that there’s no way for the overload processing to know about the 
 modifiers that the regex was applied with. In particular, it may be crucial to know whether
  /x
  
 was specified, but there’s currently no way to know that.
  
 Finally, be warned that using overloading disables the ability to include characters by their 
 Unicode name (
 !\N{
 name
 }""
  290).",NA
Mimicking Named Capture,"Despite the shortcomings of overloading, I think it’s instructive to see a complex example 
 bringing together many special constructs. Perl doesn’t offer named cap-tur e ( 137), but it 
 can be mimicked with capturing parentheses and the
  $ˆN
  vari-able ( 301), which refer ences 
 the text matched by the most-recently-closed set of capturing parentheses. (I put on the hat 
 of a Perl developer and added
  $ˆN
  sup-port to Perl expressly to allow named-capture to be 
 mimicked.)
  
 29 April 2003 20:47",NA
Mimicking Named Capture,"package MyRegexStuff; 
  
 use strict; 
  
 use warnings; 
  
 use overload; 
  
 sub import { overload::constant(’qr’ => \&MungeRegexLiteral) }
  
 my $NestedStuffRegex; #
  This should be predeclar ed, because it’s used in its own definition.
  
 $NestedStuffRegex = qr{ 
  
 (?> 
  
   
 (?: #
  Stuf f not parens, not ’#’, and not an escape . . .
  
 [ˆ()\#\\]+ 
  
 #
  Escaped stuff . . .
  
 ; (?s: \\. ) 
  
  
 #
  Regex comment . . .
  
 ; \#.+\n 
  
  
 #
  Matching parens, with more nested stuff inside . . .
  
 ;
  
 \( (??{ $NestedStuffRegex })
  
 \)
  
   
 )+ 
  
 ) 
  
 }x;
  
 sub SimpleConvert($); #
  This must be predeclar ed, as it’s used recursively 
  
 sub SimpleConvert($) 
  
 { 
   
 my $re = shift; 
  
 #
  Regex to mangle 
  
  
 $re =˜ s{ 
  
    
 \(\? # 
   
 ""(?"" 
  
     
 < 
   
 ( (?>\w+) ) > 
  
 # 
  
  
 < $1 >
  $1 is an identifier 
  
     
 ( $NestedStuffRegex ) # 
  
  
 $2 -
  possibly-nested stuff 
  
    
 \) 
          
 # 
  
  
 "")"" 
  
 }{ 
  
   
 my $id 
   
 = $1; 
  
   
 my $guts = SimpleConvert($2); 
  
   
 #
  We change 
  
   
 # 
    
 (?<id>guts) 
  
   
 #
  to 
  
   
 # 
    
 (?: (guts) 
  
 #
  match the guts 
  
   
 # 
       
 (?{ 
  
   
 # 
          
 local($ˆN{$id}) = $guts #
  Save to a localized element of %ˆT 
   
 # 
        
 }) 
  
   
 # 
     
 ) 
  
   
 ""(?:($guts)(?{ local(\$ˆT{’$id’}) = \$ˆN }))"" 
  
  
 }xeog; 
  
  
 return $re; 
   
 #
  Retur n mangled regex 
  
 }
  
 sub MungeRegexLiteral($) 
  
 { 
   
 my ($RegexLiteral) = @R; #
  Ar gument is a string 
  
  
 # print ""BEFORE: $RegexLiteral\n""; #
  Uncomment this for debugging 
  
 my $new = 
 SimpleConvert($RegexLiteral); 
  
  
 if ($new ne $RegexLiteral) 
  
  
 { 
  
   
 my $before = q/(?{ local(%ˆT) = () })/; #
  Localize temporary hash
  
 my $after
  
 = q/(?{ %ˆN = %ˆT
  
 })/; #
  Copy temp to ""real"" hash
  
   
 $RegexLiteral = ""$before(?:$new)$after""; 
  
  
 } 
  
  
 # print ""AFTER: 
  
 $RegexLiteral\n""; #
  Uncomment this for debugging 
  
 return 
 $RegexLiteral; 
  
 }
  
 1;
  
 29 April 2003 20:47",NA
Perl Eff icienc y Issues,"For the most part, efficiency with Perl regular expressions is achieved in the same way as 
 with any tool that uses a Traditional
  NFA
 . Use the techniques discussed in Chapter 6
  —
  the 
 internal optimizations, the unrolling methods, the “Think” section
 —
 all apply to Perl.
  
 Ther e ar e, of course, Perl-specific issues as well, and in this section, we’ll look at the 
 following topics:
  
 •
  There’s More Than One Way To Do It 
  
 Perl is a toolbox offering many 
  
 appr oaches to a solution. Knowing which problems are nails comes with 
  
 understanding
  The Perl Way
 , and knowing which hammer to use for any par-
  
 ticular 
 nail goes a long way toward making more efficient and more under-
  
 standable 
 programs. Sometimes efficiency and understandability seem to be 
  
 mutually exclusive, 
 but a better understanding allows you to make better 
  
 choices.
  
 •
  Regex Compilation,
  qr/
 ˙˙˙
 /
 , the
  /o
  Modifier, and Efficiency 
  
 The interpolation 
  
 and compilation of regex operands are fertile ground for saving time. The
  /o 
  
 modifier, 
 which I haven’t discussed much yet, along with regex objects 
  
 (
 qr/
 ˙˙˙
 /
 ), gives you 
 some control over when the costly re-compilation takes 
  
 place.
  
 •
  The
  $&
  Penalty 
  
 The three match side effect variables,
  $‘
 ,
  $&
 , and
  $’
 , can be 
  
 convenient, but there’s a hidden efficiency
  gotcha
  waiting in store for any 
  
 script 
 that uses them, even once, anywhere. Heck, you don’t even have to
  use 
  
 them
  —
  the entire 
 script is penalized if one of these variables even
  appears
  in 
  
 the script.
  
 •
  The Study Function 
  
 Since ages past, Perl has provided the
  study(
 ˙˙˙
 )
  func-
  
 tion. 
 Using it supposedly makes regexes faster, but it seems that no one really 
  
 understands if it 
 does, or why. We’ll see whether we can figure it out.
  
 •
  Benchmarking 
  
 When it comes down to it, the fastest program is the one that 
  
 finishes first. (You can quote me on that.) Whether a small routine, a major 
  
 function, 
 or a whole program working with live data, benchmarking is the 
  
 final word on 
 speed. Benchmarking is easy and painless with Perl, although 
  
 ther e ar e various ways to 
 go about it. I’ll show you the way I do it, a simple 
  
 method that has served me well for 
 the hundreds of benchmarks I’ve done 
  
 while preparing this book.
  
 •
  Perl’s Regex Debugg ing 
  
 Perl’s regex-debug flag can tell you about some of 
  
 the optimizations the regex engine and transmission do, or don’t do, with your 
  
 regexes. We’ll look at how to do this and see what secrets Perl gives up.
  
 29 April 2003 20:47",NA
“T here’s More Than One Way to Do It”,"Ther e ar e often many ways to go about solving any particular problem, so there’s no 
 substitute for really knowing all that Perl has to offer when balancing efficiency and 
 readability. Let’s look at the simple problem of padding an
  IP
  addr ess like‘
 18.181.0.24
 ’ such 
 that each of the four parts becomes exactly three digits:‘
 018.181.000.024
 ’. One simple and 
 readable solution is:
  
 $ip = sprintf(""%03d.%03d.%03d.%03d"", split(/\./, $ip));
  
 This is a fine solution, but there are certainly other ways to do the job. In the inter est of 
 comparison, Table 7-6 examines various ways to achieve the same goal, and their relative 
 efficiency (they’re listed from the most efficient to the least). This example’s goal is simple 
 and not very interesting in and of itself, yet it repr esents a common text-handling task, so I 
 encourage you to spend some time understand-ing the various approaches. You may even 
 see some Perl techniques that are new to you.
  
 Each approach produces the same result when given a correct IP address, but fails in differ 
 ent ways if given something else. If there is any chance that the data will be malformed, 
 you’ll need more car e than any of these solutions provide. That aside, the practical differ 
 ences lie in efficiency and readability. As for readability, #1 and #13 seem the most 
 straightforward (although it’s interesting to see the wide gap in efficiency). Also 
 straightforward are #3 and #4 (similar to #1) and #8 (simi-lar to #13). The rest all suffer 
 from varying degrees of crypticness.
  
 So, what about efficiency? Why are some less efficient than others? It’s the interac-tions 
 among how an
  NFA
  works (Chapter 4), Perl’s many regex optimizations (Chapter 6), and the 
 speed of other Perl constructs (such as
  sprintf
 , and the mechanics of the substitution 
 operator). The substitution operator’s
  /e
  modifier, while indispensable at times, does seem to 
 be mostly at the bottom of the list.
  
 It’s interesting to compare two pairs, #3/#4 and #8/#14. The two regexes of each pair 
 differ only in their use of parentheses
  —
  the one without the parentheses is just a bit faster 
 than the one with. But #8’s use of
  $&
  as a way to avoid parenthe-ses comes at a high cost 
 not shown by these benchmarks ( 355).",NA
"Regex Compilation, the /o Modifier,",NA,NA
 qr,NA,NA
/,˙˙˙,NA
"/, ",NA,NA
and Efficienc y,"An important aspect of Perl’s regex-r elated ef ficiency relates to the setup work Perl must 
 do behind the scenes when program execution reaches a regex operator, befor e actually 
 applying the regular expression. The precise setup depends on the
  
 29 April 2003 20:47",NA
Under standing the “Pre-Match” Copy,"While doing matches and substitutions, Perl sometimes must spend extra time and memory 
 to make a pre-match copy of the target text. As we’ll see, sometimes this copy is used in 
 support of important features, but sometimes it’s not. When the copy is made but not used, 
 the wasted effort is an inefficiency we’d like to avoid, especially in situations where the target 
 text is very long, or speed particularly important.
  
 In the next sections, we’ll look at when and why Perl might make a pre-match copy of the 
 target text, when the copy is actually used, and how we might avoid the copy when efficiency 
 is at a premium.
  
 Pre-match copy suppor ts
  $1
 ,
  $&
 ,
  $’
 ,
  $+
 , . . .
  
 Perl makes a pre-match copy of the original target text of a match or substitution to support
  
 $1
 ,
  $&
 , and the other after-match variables that actually hold text ( 299). After each match, 
 Perl doesn’t actually create each of these variables because many (or all) may never be used 
 by the program. Rather, Perl just files away a copy of the original text, remembers
  wher e
  in 
 that original string the vari-ous matches happened, and then refers to that if and when
  $1
  or 
 the like is actu-ally used. This requir es less work up-front, which is good, because often, 
 some or all of these after-match variables are not even used. This is a form of “lazy evalua-
 tion,” and successfully avoids a lot of unneeded work.
  
 Although Perl saves work by not creating
  $1
  and the like until they’re used, it still has to do 
 the work of saving the extra copy of the target text. But why does this really need to be 
 done? Why can’t Perl just refer to that original text to begin with?
  
 Well, consider:
  
 $Subject =˜ s/ˆ(?:Re:\s+)+//;
  
 After this,
  $&
  pr operly refers to the text that was removed from
  $Subject
 , but since it was
  
 removed
  fr om
  $Subject
 , Perl can’t refer to
  $Subject
  itself when pro-viding for a subsequent 
 use of
  $&
 . The same logic applies for something like:
  
 if ($Subject =˜ m/ˆSPAM:(.+)/i) { 
  
 $Subject = ""-- spam subject removed --""; 
  
 $SpamCount{$1}++; 
  
 }
  
 By the time
  $1
  is refer enced, the original
  $Subject
  has been erased. Thus, Perl must make an 
 internal pre-match copy.
  
 The pre-match copy is not always needed
  
 In practice, the primary “users” of the pre-match copy are
  $1
 ,
  $2
 ,
  $3
 , and the like. But what if 
 a regex doesn’t even have capturing parentheses? If it doesn’t, there’s
  
 29 April 2003 20:47",NA
How to Check Whether Your Code is Tainted by,NA,NA
 $&,"It’s not always easy to notice whether your program is naughty (refer ences 
 $&
 ,
  $‘
 , or
  $’
 ), 
 especially with the use of libraries, but there are several ways to find out. The easiest, if 
 your
  perl
  binary has been compiled with the
 -DDEBUGGING
  option, is to use the
  -c
  and
  -
 Mre=debug
  command-line argu-ments ( 361) and look toward the end of the output 
 for a line that says either
 ‘
 Enabling $‘ $& $’ support
 ’
  or
  ‘
 Omitting $‘ $& $’ support
 ’
 . If it’s 
 enabled, the code is tainted.
  
 It’s possible (but unlikely) that the code could be tainted by the use of a naughty 
 variable within an eval that’s not known to Perl until it’s executed. One option to 
 catch those as well is to install the
  Devel::SawAmpersand 
 package from
  CPAN
  
 (
 http://www.cpan.org
 ):
  
 END { 
  
   
 require Devel::SawAmpersand; 
  
   
 if (Devel::SawAmpersand::sawampersand) { 
  
  
 print ""Naughty variable was used!\n""; 
  
  
 } 
  
 }
  
 Included with
  Devel::SawAmpersand
  comes
  Devel::FindAmpersand
 , a package that 
 purportedly shows you where the offending variable is located. Unfortunately, it 
 doesn’t work reliably with the latest versions of Perl. Also, they both have some 
 installation issues, so your mileage may vary. (Check 
 http://regex.info/
  for possible 
 updates.)
  
 Also, it may be interesting to see how you can check for naughtiness by just checking 
 for the perfor mance penalty:
  
 use Time::HiRes; 
  
 sub CheckNaughtiness() 
  
 { 
  
 my $text = ’x’ x 10R000; #
  Cr eate some non-small amount of data.
  
 #
  Calculate the overhead of a do-nothing loop. 
  
 my $start = Time::HiRes::time();
  
 for (my $i = 0; $i < 5R000; $i++)
  
 {
  
 }
  
 my $overhead = Time::HiRes::time() - $start;
  
 #
  Now calculate the time for the same number of simple matches. 
 $start = 
 Time::HiRes::time();
  
 for (my $i = 0; $i < 5R000; $i++)
  
 { $text =˜ m/ˆ/
  
 }
  
 my $delta = Time::HiRes::time() - $start;
  
 #
  A dif ferential of 5 is just a heuristic.
  
 printf ""It seems your code is %s (overhead=%.2f, delta=%.2f)\n"", 
  
 ($delta > 
 $overhead+5) ? ""naughty"" : ""clean"", $overhead, $delta; }
  
 29 April 2003 20:47",NA
The Study Function,"In contrast to optimizing the regex itself,
  study(
 ˙˙˙
 )
  optimizes certain kinds of searches of a
  
 string
 . After studying a string, a regex (or multiple regexes) can ben-efit from the cached 
 knowledge when applied to the string. It’s generally used like this:
  
 while (<>) 
  
 { 
  
  
 study($R); #
  Study the default target $_ before doing lots of matches on it 
  
  
 if (m/
 regex 1
 /) {
 ˙˙˙
  } 
  
  
 if (m/
 regex 2
 /) {
 ˙˙˙
  } 
  
  
 if (m/
 regex 3
 /) {
  
 ˙˙˙
  } 
  
 if (m/
 regex 4
 /) {
 ˙˙˙
  } 
  
 }
  
 What
  study
  does is simple, but understanding when it’s a benefit can be quite dif-ficult. It 
 has no effect whatsoever on any values or results of a program
  —
  the only ef fects ar e that 
 Perl uses more memory, and that overall execution time might incr ease, stay the same, or 
 (here’s the goal) decrease.
  
 When a string is studied, Perl takes some time and memory to build a list of places in the 
 string that each character is found. (On most systems, the memory requir ed is four times 
 the size of the string).
  study
 ’s benefit can be realized with each sub-sequent regex match 
 against the string, but only until the string is modified. Any modification of the string 
 invalidates the
  study
  list, as does studying a differ ent string.
  
 How helpful it is to have the target string
  study
 ied is highly dependent on the regex 
 matching against it, and the optimizations that Perl is able to apply. For example, searching 
 for literal text with
  m/foo/
  can see a huge speedup due to 
 study
  (with large strings, speedups 
 of 10,000× are possible). But, if
  /i
  is used, that speedup evaporates, as
  /i
  curr ently removes 
 the benefit of
  study
  (as well as some other optimizations).
  
 When not to use study
  
 •
  Don’t use
  study
  on strings you intend to check only with
  /i
 , or when all lit-eral text is 
 governed by
  !(?i)""
  or
  !(?i:
 ˙˙˙
 )""
 , as these disable the benefits of 
 study
 .
  
 •
  Don’t use
  study
  when the target string is short. In such cases, the normal fixed-string 
 cognizance optimization should suffice ( 247). How short is“short”? String length is just 
 one part of a large, hard-to-pin-down mix, so when it comes down to it, only 
 benchmarking
  your
  expr essions on
  your
  data will tell you if
  study
  is a benefit. But for 
 what it’s worth, I generally don’t even consider
  study
  unless the strings are at least 
 several kilobytes long.
  
 29 April 2003 20:47",NA
Benchmarking,"If you really care about efficiency, it may be best to try benchmarking. Perl comes standard 
 with the
  Benchmark
  module, which has fine documentation (“
 perldoc Benchmark
 ”). Perhaps 
 more out of habit than anything else, I tend to write my benchmarks from scratch. After
  
 use Time::HiRes ’time’;
  
 I wrap what I want to test in something simple like:
  
 my $start = time; 
  
 + 
  
 + 
  
 + 
  
 my $delta = time - $start; 
  
 printf ""took %.1f seconds\n"", $delta;
  
 Important issues with benchmarking include making sure to benchmark enough work to 
 show meaningful times, and to benchmark as much of the work you want to measure while 
 benchmarking as little of the work you don’t. This is discussed in more detail in Chapter 6 ( 
 232). It might take some time to get used to bench-marking in a reasonable way, but the 
 results can be quite enlightening and rewarding.
  
 29 April 2003 20:47",NA
Regex Debugg ing Infor mation,"Perl carries out a phenomenal number of optimizations to try to arrive at a match result 
 quickly; some of the less esoteric ones are listed in Chapter 6’s “Common Optimizations” ( 
 239), but there are many more. Most optimizations apply to only very specific cases, so any 
 particular regex benefits from only some (or none) of them.
  
 Perl has debugging modes that tell you about some of the optimizations. When a regex is 
 first compiled, Perl figures out which optimizations go with the regex, and the debugging 
 mode reports on some of them. The debugging modes can also tell you a lot about how the 
 engine actually applies that expression. A detailed analy-sis of this debugging information is 
 beyond the scope of even this book, but I’ll pr ovide a short introduction here.
  
 You can turn on the debugging information by putting
  use re ’debug’;
  in your code, and you 
 can turn it back off with
  no re ’debug’;
 . (We’ve seen this
  use re
  pragma before, with differ 
 ent arguments, to allow embedded code in interpo-lated variables 337.)
  
 Alter natively, if you want to turn it on for the entire script, you can use the
 -Mre=debug
  
 command-line argument. This is particularly useful just for inspecting how a single regex is 
 compiled. Here’s an example (edited to remove some lines that are not of interest):
  
 –
 %
  perl -cw -Mre=debug -e ’m/ˆSubject: (.
 ,
 )/’
  
 —
 Compiling REx ‘ˆSubject: (.+)’
  
 ˜
 rarest char j at 3
  
 ™
  
 1: BOL(2)
  
 š
  
 2: EXACT <Subject: >(6) 
  
  
  
 ++ 
  
  
  
 +
  
 ›
 12: END(0)
  
 œ
 anchored ‘Subject: ’ at 0 (checking anchored) anchored(BOL) minlen 9
 •
 Omitting $‘ $& $’ support.
  
 At
  –
 , I invoke
  perl
  at my shell prompt, using the command-line flags
  -c
  (which means to 
 check the script, but don’t actually execute it),
  -w
  (issue warnings about things Perl thinks are 
 dubious
  —
  always used as a matter of principle), and
 -Mre=debug
  to turn on regex 
 debugging. The
  -e
  flag means that the following argument, ‘
 m/ˆSubject: (.+)/
 ’, is actually a 
 mini Perl program to be run or checked.
  
 Line
  ˜
  reports the “rarest” character (the least common, as far as Perl guesses) fr om among 
 those in the longest fixed substring part of the regex. Perl uses this for some optimizations 
 (such as pre-check of requir ed character/substring 244).
  
 29 April 2003 20:47",NA
Final Comments,"I’m sure it’s obvious that I’m quite enamored with Perl’s regular expressions, and as I noted 
 at the start of the chapter, it’s with good reason. Larry Wall, Perl’s cre-ator, appar ently let 
 himself be ruled by common sense and the Mother of Inven-tion. Yes, the implementation 
 has its warts, but I still allow myself to enjoy the delicious richness of the regex language and 
 the integration with the rest of Perl.
  
 However, I’m not a blind fanatic
 —
 Perl does not offer features that I wish for. Since several 
 of the features I pined for in the first edition of this book were eventually added, I’ll go 
 ahead and wish for more her e. The most glaring omission offer ed by other 
 implementations is named capture ( 137). This chapter offers a way to mimic them, but with 
 severe restrictions; it would be much nicer if they were built in. Class set operations ( 123) 
 would also be very nice to have, even though with some effort, they can already be 
 mimicked with lookaround ( 124).
  
 29 April 2003 20:47",NA
8,NA,NA
Ja va,"Java didn’t come with a regex package until Java 1.4, so early programmers had to do 
 without regular expressions. Over time, many programmers independently developed Java 
 regex packages of varying degrees of quality, functionality, and complexity. With the early-
 2002 release of Java 1.4, Sun entered the fray with their 
 java.util.regex
  package. In preparing 
 this chapter, I looked at Sun’s package, and a few others (detailed starting on page 372). So 
 which one is best? As you’ll soon see, there can be many ways to judge that.
  
 In This Chapter 
  
 Befor e looking at what’s in this chapter, it’s important to mention what’s
  
 not
  in this chapter. In short, this chapter doesn’t restate everything from Chapters 1 through 
 6. I understand that some readers interested only in Java may be inclined to start their 
 reading with this chapter, and I want to encourage them not to miss the benefits of the 
 preface and the earlier chapters: Chapters 1, 2, and 3 introduce basic concepts, features, and 
 techniques involved with regular expr essions, while Chapters 4, 5, and 6 offer important 
 keys to regex understand-ing that directly apply to every Java regex package that I know of.
  
 As for this chapter, it has several distinct parts. The first part, consisting of “Judging a Regex 
 Package” and “Object Models,” looks abstractly at some concepts that help you to 
 understand an unfamiliar package more quickly, and to help judge its suit-ability for your 
 needs. The second part, “Packages, Packages, Packages,” moves away from the abstract to 
 say a few words about the specific packages I looked at while researching this book. Finally, 
 we get to the real fun, as the third part talks in specifics about two of the packages, Sun’s
  
 java.util.regex
  and Jakarta’s
  ORO 
 package.
  
 365
  
 29 April 2003 20:54",NA
Judg ing a Regex Package,"The first thing most people look at when judging a regex package is the regex fla-vor itself, 
 but there are other technical issues as well. On top of that, “political”issues like source code 
 availability and licensing can be important. The next sec-tions give an overview of some 
 points of comparison you might use when select-ing a regex package.",NA
Technical Issues,"Some of the technical issues to consider are:
  
 •
  Eng ine Type? 
  
 Is the underlying engine an
  NFA
  or
  DFA
 ? If an
  NFA
 , is it a
  POSIX 
  
 NFA
  or a Traditional
  NFA
 ? (See Chapter 4 143)
  
 •
  Rich Flavor? 
  
 How full-featured is the flavor? How many of the items on 
  
 page 113 
 are supported? Are they supported well? Some things are mor e 
  
 important than 
 others: lookaround and lazy quantifiers, for example, are mor e 
  
 important than possessive 
 quantifiers and atomic grouping, because look-
  
 ar ound and lazy quantifiers can’t be 
 mimicked with other constructs, whereas 
  
 possessive quantifiers and atomic grouping 
 can be mimicked with lookahead 
  
 that allows capturing parentheses.
  
 •
  Unicode Support? 
  
 How well is Unicode supported? Java strings support Uni-
  
 code intrinsically, but does
  !\w""
  know which Unicode characters are “word”
  
 characters? What about
  !\d""
  and
  !\s""
 ? Does
  !\b""
  understand Unicode? (Does its 
  
 idea of a word character match
  !\w""
 ’s idea of a word character?) Are Unicode 
  
 pr 
 operties supported? How about blocks? Scripts? ( 119) Which version of 
  
 Unicode’s mappings do they support: Version 3.0? Version 3.1? Version 3.2? 
  
 Does 
 case-insensitive matching work properly with the full breadth of Uni-
  
 code characters? 
 For example, does a case-insensitive ‘
 ß
 ’ really match ‘
 SS
 ’?
  
 (Even in lookbehind?)
  
 •
  How Flexible? 
  
 How flexible are the mechanics? Can the regex engine deal 
  
 only with
  
 String
  objects, or the whole breadth of
  CharSequence
  objects? Is it 
  
 easy to use in a 
 multi-threaded environment?
  
 •
  How Convenient? 
  
 The raw engine may be powerful, but are ther e extra
  
 “convenience functions” that make it easy to do the common things without a 
  
 lot of 
 cumbersome overhead? Does it, borrowing a quote from Perl, “make the 
  
 easy 
 things easy, and the hard things possible?”
  
 •
  JRE
  Requirements? 
  
 What version of the
  JRE
  does it requir e? Does it need the 
  
 latest version, which many may not be using yet, or can it run on even an old 
  
 (and 
 perhaps more common)
  JRE
 ?
  
 29 April 2003 20:54",NA
Social and Political Issues,"Some of the non-technical issues to consider are:
  
 •
  Documented? 
  
 Does it use Javadoc? Is the documentation complete? Correct? 
  
 Appr oachable? Understandable?
  
 •
  Maintained? 
  
 Is the package still being maintained? What’s the turnar ound 
  
 time for 
 bugs to be fixed? Do the maintainers really care about the package? Is 
  
 it being enhanced?
  
 •
  Suppor t and Popular ity? 
  
 Is there official support, or an active user community 
  
 you can turn to for reliable support (and that you can provide support to, 
  
 once you 
 become skilled in its use)?
  
 •
  Ubiquity? Can you assume that the package is available everywhere you go, 
  
 or do 
 you have to include it whenever you distribute your programs?
  
 •
  Licensing? 
  
 May
  you redistribute it when you distribute your programs? Are 
  
 the terms 
 of the license something you can live with? Is the source code avail-
  
 able for 
 inspection?
  May
  you redistribute modified versions of the source 
  
 code?
  Must
  you?
  
 Well, there are certainly a lot of questions. Although this book can give you the answers to 
 some of them, it can’t answer the most important question:
  which is right for you?
  I make some 
 recommendations later in this chapter, but only you can decide which is best for you. So, to 
 give you more backgr ound upon which to base your decision, let’s look at one of the most 
 basic aspects of a regex package: its object model.
  
 29 April 2003 20:54",NA
Object Models,"When looking at differ ent regex packages in Java (or in any object-oriented lan-guage, for 
 that matter), it’s amazing to see how many differ ent object models are used to achieve 
 essentially the same result. An object model is the set of class structur es thr ough which 
 regex functionality is provided, and can be as simple as one object of one class that’s used 
 for everything, or as complex as having sepa-rate classes and objects for each sub-step along 
 the way. There is not an object model that stands out as the clear, obvious choice for every 
 situation, so a lot of variety has evolved.",NA
A Few Abstract Object Models,"Stepping back a bit now to think about object models helps prepar e you to more readily 
 grasp an unfamiliar package’s model. This section presents several repr e-sentative object 
 models to give you a feel for the possibilities without getting mir ed in the details of an actual 
 implementation.
  
 Starting with the most abstract view, here are some tasks that need to be done in using a 
 regular expression:
  
 Setup . . .
  
 –
 Accept a string as a regex; compile to an internal form.
  
 —
 Associate the regex with the target text.
  
 Actually apply the regex . . .
  
 ˜
 Initiate a match attempt.
  
 See the results . . .
  
 ™
 Lear n whether the match is successful.
  
 š
 Gain access to further details of a successful attempt.
  
 ›
 Query those details (what matched, where it matched, etc.).
  
 These are the steps for just one match attempt; you might repeat them from
  ˜
  to find the 
 next match in the target string.
  
 Now, let’s look at a few potential object models from among the infinite variety that one 
 might conjure up. In doing so, we’ll look at how they deal with matching 
 !\s+(\d+)""
  to the 
 string ‘
 May 16, 1998
 ’ to find out that ‘
  16
 ’ is matched overall, and ‘
 16
 ’ matched within the 
 first set of parentheses (within “group one”). Remem-ber, the goal here is to mer ely get a 
 general feel for some of the issues at hand
  —
 we’ll see specifics soon.
  
 29 April 2003 20:54",NA
Growing Complexity,"These conceptual models are just the tip of the iceberg, but give you a feel for some of the 
 differ ences you’ll run into. They cover only simple matches
  —
  when you bring in search-
 and-r eplace, or perhaps string splitting (splitting a string into substrings separated by 
 matches of a regex), it can become much more complex.
  
 Thinking about search-and-r eplace, for example, the first thought may well be that it’s a 
 fairly simple task, and indeed, a simple “replace
  this
  with
  that
 ” inter face is easy to design. But 
 what if the “that” needs to depend on what’s matched by the“this,” as we did many times in 
 examples in Chapter 2 ( 67). Or what if you need to execute code upon every match, using 
 the resulting text as the replacement? These, and other practical needs, quickly complicate 
 things, which further incr eases the variety among the packages.",NA
"Packages, Packages, Packages","Ther e ar e many regex packages for Java; the list that follows has a few words about those 
 that I investigated while researching this book. (See this book’s web page,
  http://regex.info/
 , 
 for links). The table on the facing page gives a super-ficial overview of some of the differ 
 ences among their flavors.
  
 Sun
  
 java.util.regex 
  
 Sun’s own regex package, finally standard as of Java 1.4. It’s a 
 solid, actively maintained package that provides a rich Perl-like flavor. It has the best 
 Unicode support of these packages. It provides all the basic func-tionality you might 
 need, but has only minimal convenience functions. It matches against
  CharSequence
  
 objects, and so is extremely flexible in that respect. Its documentation is clear and 
 complete. It is the all-around fastest of the engines listed here. This package is described 
 in detail later in this chapter. Version Tested: 1.4.0.
  
 License: comes as part of Sun’s
  JRE
 . Source code is available under
  SCSL (Sun Community 
 Source Licensing)
  
 IBM
  
 com.ibm.regex 
 This is
  IBM
 ’s commercial regex package (although it’s said to be similar to 
 the
  org.apache.xerces.utils.regex
  package, which I did not investigate). It’s actively 
 maintained, and provides a rich Perl-like flavor, although is somewhat buggy in certain 
 areas. It has very good Unicode sup-port. It can match against
  char[]
 ,
  CharacterIterator
 , 
 and
  String
 . Overall, not quite as fast as Sun’s package, but the only other package that’s in 
 the same class.
  
 Version Tested: 1.0.0.
  
 License: commercial product
  
 29 April 2003 20:54",NA
Why So Many “Perl5” Flavors?,"The list mentions “Perl-like” fairly often; the packages themselves advertise “Perl5 support.” 
 When version 5 of Perl was released in 1994 ( 89), it introduced a new level of regular-expr 
 ession innovation that others, including Java regex developers, could well appreciate. Perl’s 
 regex flavor is powerful, and its adoption by a wide variety of packages and languages has 
 made it somewhat of a de facto standard.
  
 However, of the many packages, programs, and languages that claim to be “Perl5 
 compliant,” none truly are. Even Perl itself differs from version to version as new featur es 
 ar e added and bugs are fixed. Some of the innovations new with early 5.x versions of Perl 
 were non-capturing parentheses, lazy quantifiers, lookahead, inline mode modifiers like
  !(?i)""
 , 
 and the
  /x
  fr ee-spacing mode (all discussed in Chapter 3). Packages supporting only these 
 features claim a “Perl5” flavor, but miss out on later innovations, such as lookbehind, atomic 
 grouping, and conditionals.
  
 Ther e ar e also times when a package doesn’t limit itself to only “Perl5” enhance-ments. 
 Sun’s package, for example, supports possessive quantifiers, and both Sun and
  IBM
  support 
 character class set operations. Pat offers an innovative way to do lookbehind, and a way to 
 allow matching of simple arbitrarily nested constructs.",NA
"Lies, Damn Lies, and Benchmarks","It’s probably a common twist on Sam Clemens’ famous “lies, damn lies, and statis-tics” 
 quote, but when I saw its use with “benchmarks” in a paper from Sun while doing research 
 for this chapter, I knew it was an appropriate introduction for this section. In researching 
 these seven packages, I’ve run literally thousands of bench-marks, but the only fact that’s 
 clearly emerged is that there are no clear conclusions.
  
 Ther e ar e several things that cloud regex benchmarking with Java. First, there are language 
 issues. Recall the benchmarking discussion from Chapter 6 ( 234), and the special issues that 
 make benchmarking Java a slippery science at best (primar-ily, the effects of the Just-In-
 Time or Better-Late-Than-Never compiler). In doing these benchmarks, I’ve made sure to 
 use a server
  VM
  that was “warmed up” for the benchmark (see “
 BLTN
 ” 235), to show the 
 truest results.
  
 29 April 2003 20:54",NA
Recommendations,"Ther e ar e many reasons one might choose one package over another, but Sun’s 
 java.util.regex
  package
  —
  with its high quality, speed, good Unicode support, advanced 
 features, and future ubiquity
  —
 is a good recommendation. It comes inte-grated as part of 
 Java 1.4:
  String.matches()
 , for example, checks to see whether the string can be completely 
 matched by a given regex.
  
 29 April 2003 20:54",NA
Sun’s Regex Package,"Sun’s regex package,
  java.util.regex
 , comes standard with Java as of Version 1.4. It provides 
 powerful and innovative functionality with an uncluttered (if some-what simplistic) class 
 interface to its “match state” object model discussed ( 370).
  
 It has fairly good Unicode support, clear documentation, and good efficiency.
  
 We’ve seen examples of
  java.util.regex
  in earlier chapters ( 81, 95, 98, 217, 234). We’ll see 
 more later in this chapter when we look at its object model and how to actually put it to use, 
 but first, we’ll take a look at the regex flavor it sup-ports, and the modifiers that influence 
 that flavor.",NA
Regex Flavor,"java.util.regex
  is powered by a Traditional
  NFA
 , so the rich set of lessons from Chapters 4, 5, 
 and 6 apply. Table 8-2 on the facing page summarizes its metachar-acters. Certain aspects of 
 the flavor are modified by a variety of match modes, tur ned on via flags to the various 
 functions and factories, or turned on and off via 
 !(?
 mods
 -
 mods
 )""
  and
  !(?
 mods
 -
 mods
 :
 ˙˙˙
 )""
  modifiers 
 embedded within the regular expres-sion itself. The modes are listed in Table 8-3 on page 
 380.
  
 A regex flavor certainly can’t be described with just a tidy little table, so here are some notes 
 to augment Table 8-2:
  
 •
  The table shows “raw” backslashes, not the doubled backslashes requir ed when regular 
 expressions are provided as Java string literals. For example,
  !\n 
 in the table must be 
 written as
  ""\\n""
  as a Java string. See “Strings as Regular Expr essions” ( 101).
  
 •
  With the
  Pattern.COMMENTS
  option ( 380),
  #
 ˙˙˙
 1
  sequences are taken as comments. (Don’t 
 forget to add newlines to multiline string literals, as in the sidebar on page 386.) 
 Unescaped
  ASCII
  whitespace is ignored. Note: unlike most implementations that 
 support this type of mode, comments and free whitespace
  ar e
  recognized within 
 character classes.
  
 29 April 2003 20:54",NA
Using java.util.regex,"The mechanics of wielding regular expressions with
  java.util.regex
  ar e fairly simple. Its 
 object model is the “match state” model discussed on page 370. The functionality is 
 provided with just three classes:
  
 java.util.regex.Pattern 
  
 java.util.regex.Matcher 
  
 java.util.regex.PatternSyntaxException
  
 Infor mally, I’ll refer to the first two simply as “
 Pattern
 ” and “
 Matcher
 ”. In short, the
  
 Pattern
  object is a compiled regular expression that can be applied to any number of strings, 
 and a
  Matcher
  object is an individual instance of that regex being applied to a specific target 
 string. The third class is the exception thrown upon the attempted compilation of an ill-
 formed regular expression.
  
 Sun’s documentation is sufficiently complete and clear that I refer you to it for the complete 
 list of all methods for these objects (if you don’t have the documentation locally, see
  
 http://regex.info
  for links). The rest of this section highlights just the main points.
  
 29 April 2003 20:54",NA
Sun’s java.util.regex “Line Ter minators”,"Traditionally, pre-Unicode regex flavors treat a newline specially with respect to 
 dot
 ,
  !ˆ""
 ,
  !$""
 , 
 and
  !\Z""
 . However, the Unicode standard suggests the larger set of “line ter minators” 
 discussed in Chapter 3 ( 108). Sun’s package supports a subset of these consisting of these 
 five characters and one character sequence:
  
 Character Codes
  
 Nicknames 
  
 Description
  
 U
 +000A
  
 LF
  
 \n
  
 ASCII
  Line Feed
  
 U
 +000D
  
 CR
  
 \r
  
 ASCII
  Carriage Return
  
 U
 +000D
  U
 +000A
  
 CR/LF
  
 \r\n
  
 ASCII
  Carriage Return / Line Feed
  
 U
 +0085
  
 NEL
  
 Unicode
  NEXT LINE
  
 U
 +2028
  
 LS
  
 Unicode
  LINE SEPARATOR
  
 U
 +2029
  
 PS
  
 Unicode
  PARAGRAPH SEPARATOR
  
 This list is related to the
  dot
 ,
  !ˆ""
 ,
  !$""
 , and
  !\Z""
  metacharacters, but the relationships ar e 
 neither constant (they change with modes), nor consistent (one would expect 
 !ˆ""
  and
  !$""
  to 
 be treated similarly, but they are not).
  
 Both the
  Pattern.UNIXRLINES
  and
  Pattern.DOTALL
  match modes (available also via
  !(?d)""
  
 and
  !(?s)""
  ) influence what
  dot
  matches.
  
 !
 ˆ
 ""
  can always match at the beginning of the string, but can match elsewhere under the
  (?m) 
 Pattern.MULTILINE
  mode. It also depends upon the
  !(?d) Pattern.UNIXRLINES
  mode.
  
 !
 $
 ""
  and
  !
 \Z
 ""
  can always match at the end of the string, but they can also match just befor e 
 certain string-ending line terminators. With the
  Pattern.MULTILINE 
 mode,
  !$""
  can match 
 after certain embedded line terminators as well. With Java 1.4.0,
  Pattern.UNIXRLINES
  does 
 not influence
  !$""
  and
  !\Z""
  in the same way (but it’s slated to be fixed in 1.4.1 such that it 
 does). The following table summarizes the relationships as of 1.4.0.
  
 LF 
  
 CR 
  
 CR/LF 
  
 NEL 
  
 LS 
  
 PS
  
  
 Default action, without modifiers
  
 dot
  matches all but:
  
  
  
  
  
 ˆ
  matches at beginning of string only 
  
 $
  and
  \Z
  match before string-ending: 
  
 With
  Pattern.MULTILINE
  or
  (?m)
  
 ˆ
  matches after any:
  
  
  
  
  
  
  
 $
  matches before any: 
  
 With
  Pattern.DOTALL
  or
  (?s) 
  
  
 dot
  matches any character
  
  
 — does not apply if
  Pattern.UNIXRLINES
  or
  (?d)
  is in effect
  
 Finally, note that there is a bug in Java 1.4.0 that is slated to be fixed in 1.4.1: 
 !$""
  and
  
 !\Z""
  actually
  match
  the line terminators, when present, rather than mer ely matching
  at
  
 line terminators.
  
 29 April 2003 20:54",NA
The,NA,NA
 Pattern.compile(),NA,NA
 Factor y,"A
  Pattern
  regular-expr ession object is created with
  Pattern.compile(
 ˙˙˙
 )
 . The first argument is 
 a string to be interpreted as a regular expression ( 101). Option-ally, compile-time options 
 shown in Table 8-3 on page 380 can be provided as a second argument. Here’s a snippet that 
 creates a
  Pattern
  object from the string in the variable
  sampleRegex
 , to be matched in a case-
 insensitive manner:
  
 Pattern
  pat
  = Pattern.compile(
 sampleRegex
 , 
  
  
 Pattern.CASERINSENSITIVE ; Pattern.UNICODERCASE);
  
 A call to
  Pattern.compile(
 ˙˙˙
 )
  can throw two kinds of exceptions: an invalid reg-ular 
 expression throws
  
 PatternSyntaxException
 , and an invalid option value thr ows
  
 IllegalArgumentException
 .
  
 29 April 2003 20:54",NA
The,NA,NA
 Matcher,NA,NA
 Object,"Once you’ve associated a regular expression with a target string by creating a 
 Matcher
  object, 
 you can instruct it to apply the regex in various ways, and query the results of that 
 application. For example, given a
  Matcher
  object
  m
 , the call 
 m.find()
  actually applies
  m
 ’s 
 regex to its string, retur ning a Boolean indicating whether a match is found. If a match is 
 found, the call
  m.group()
  retur ns a string repr esenting the text actually matched.
  
 The next sections list the various
  Matcher
  methods that actually apply a regex, followed by 
 those that query the results.
  
 Applying the regex
  
 Her e ar e the main
  Matcher
  methods for actually applying its regex to its string:
  
 find() 
  
 Applies the object’s regex to the object’s string, retur ning a Boolean indicating whether 
 a match is found. If called multiple times, the next match is retur ned each time.
  
 find(
 of fset
  ) 
  
 If
  find(
 ˙˙˙
 )
  is given an integer argument, the match attempt starts from the given
  of fset
  
 number of characters from the start of the string. It throws 
 IndexOutOfBoundsException
  
 if the
  of fset
  is negative or beyond the end of the string.
  
 matches() 
  
 This method retur ns a Boolean indicating whether the object’s regex
  exactly 
 matches the 
 object’s string. That is, the regex is wrapped with an implied 
 !\A
 ˙˙˙
 \z""
 .
 ‡
 This is also 
 available via
  String
 ’s
  matches()
  method. For example, 
 ""123"".matches(""\\d+"")
  is true.
  
 † Actually,
  matcher
 ’s argument can be any object implementing the
  CharSequence
  inter face (of which 
 String
 ,
  
 StringBuffer
 , and
  CharBuffer
  ar e examples). This provides the flexibility to apply regular expr essions to a wide 
 variety of data, including text that’s not even kept in contiguous strings.
  
 ‡ Due to the bug with
  !\Z""
  mentioned at the bottom of page 382, with version 1.4.0, the regex actually 
  
 appears to 
 be wrapped with an implied
  !\A
 ˙˙˙
 \Z
 ""
  instead.
  
 29 April 2003 20:54",NA
CSV Par sing with java.util.regex,"Her e’s the
  java.util.regex
  version of the CSV example from Chapter 6 ( 271). The 
 regex has been updated to use possessive quantifiers ( 140) for a bit of extra efficiency.
  
 First, we set up
  Matcher
  objects that we’ll use in the actual processing. The‘
 \n
 ’ at the 
 end of each line is needed because we use
  !#
 ˙˙˙
 ""
  comments, which end at a newline.
  
 //
 Pr epar e the regexes we’ll use
  
 Pattern
  pCSVmain
  = Pattern.compile(
  
 ""
  
 \\G(?:ˆ;,) 
  
 )
  
 \n""+
  
 ""
  
 (?: 
  
 \n""+
  
 ""
  
 # Either a double-quoted field...
  
 \n""+
  
 ""
  
 \"" # field’s opening quote
  
 \n""+
  
 ""
  
 (
  
 (?> [ˆ\""]++ ) (?> \""\"" [ˆ\""]++ )++
  
  \n""+
  
 ""
  
 \"" # field’s closing quote
  
 \n""+
  
 ""
  
 # ... or ...
  
 \n""+
  
 ""
  
 ;
  
 \n""+
  
 ""
  
 # ... some non-quote/non-comma text ...
  
 \n""+
  
 ""
  
 ( [ˆ\"",]++ ) 
  
 \n""+
  
 ""
  
 )
  
 \n"",
  
 Pattern.COMMENTS); 
  
 Pattern
  pCSVquote
  = Pattern.compile(""\""\""""); //
  Now create Matcher 
 objects, with dummy text, that we’ll use later.
  
 Matcher
  mCSVmain 
  
 =
  pCSVmain
 .matcher(""""); Matcher
  
 mCSVquote
  =
  pCSVquote
 .matcher("""");
  
 Then, to parse the string in
  csvText
  as
  CSV
  text, we use those
  Matcher 
 objects to 
 actually apply the regex and use the results:
  
 mCSVmain
 .reset(
 csvText
 ); //
  Tie the target text to the mCSVmain object 
 while (
  
 mCSVmain
 .find() ) 
  
 { 
  
 String
  field
 ; //
  We’ll fill this in with $1 or $2 . . .
  
 String
  second
  =
  mCSVmain
 .group(2); 
  
 if (
  second
  != null ) 
  
  
 field
  =
  second
 ; 
  
 else { 
  
  
  
 //
  If $1, must replace paired double-quotes with one double quote 
  
 mCSVquote
 .reset(
 mCSVmain
 .group(1)); 
  
  
 field
  =
  mCSVquote
 .replaceAll(""\""""); 
  
 } 
  
 //
  We can now work with field . . .
  
 System.out.println(""Field ["" +
  field
  + ""]""); }
  
 This is more efficient than the similar version shown on page 217 for two reasons: the 
 regex is more efficient (as per the Chapter 6 discussion), and that one
  Matcher
  object 
 is reused, rather than creating and disposing of new ones each time (as per the 
 discussion on page 385).
  
 29 April 2003 20:54",NA
Other,NA,NA
 Pattern,NA,NA
 Methods,"In addition to the main
  compile(
 ˙˙˙
 )
  factories, the
  Pattern
  class contains some helper functions 
 and methods that don’t add new functionality, but make the cur-rent functionality more 
 easily accessible.
  
 Pattern.matches(
 patter n
 ,
  text
  ) 
  
 This static function retur ns a Boolean indicating whether the string
  patter n
  can match 
 the
  CharSequence
  (e.g.,
  String
 )
  text
 . Essentially, this is:
  
 Pattern.compile(
 pattern
 ).matcher(
 text
 ).matches();
  
 If you need to pass compile options, or need to gain access to more infor ma-tion about 
 the match than whether it was successful, you’ll have to use the methods described 
 earlier.
  
 Patter n’s split method, with one argument
  
 split(
 text
  ) 
  
 This
  Pattern
  method accepts
  text
  (a
  CharSequence
 ) and retur ns an array of strings from
  
 text
  that are delimited by matches of the object’s regex. This is also available via a
  
 String
 ’s
  split
  method.
  
 This trivial example
  
 String[] result = Pattern.compile(""\\."").split(""209.204.146.22"");
  
 retur ns the array of four strings (‘
 209
 ’, ‘
 204
 ’, ‘
 146
 ’, and ‘
 22
 ’) that are separated by the three 
 matches of
  !\.""
  in the text. This simple example splits on only a single lit-eral character, but 
 you can split on an arbitrary regular expression. For example, you might approximate 
 splitting a string into “words” by splitting on non-alphanu-merics:
  
 String[] result = Pattern.compile(""\\W+"").split(
 Text
 );
  
 When given a string like ‘
 What’s up, Doc
 ’ it retur ns the four strings (‘
 What
 ’, ‘
 s
 ’,
  
 ‘
 up
 ’, and ‘
 Doc
 ’) delimited by the three matches of the regex. (If you had non-
 ASCII 
 text, 
 you’d probably want to use
  !\P{L}+""
 , or perhaps
  ![ˆ\p{L}\p{N}R]""
 , as the regex, instead of
  
 !\W+""
  380.)
  
 Empty elements with adjacent matches 
  
 If the object’s regex can match at the beginning of the
  text
 , the first string retur ned by
  split
  is 
 an empty string (a valid string, but one that contains no characters). Similarly, if the regex can 
 match two or more times in a row, empty strings are retur ned for the zero-length text 
 “separated” by the adjacent matches. For example,
  
 String[]
  result
  = Pattern.compile(""\\s+,\\s+"").split("", one, two , ,, 3"");
  
 splits on a comma and any surrounding whitespace, retur ning an array of five strings: an 
 empty string, ‘
 one
 ’, ‘
 two
 ’, two empty strings, and ‘
 3
 ’.
  
 29 April 2003 20:54",NA
A Quick Look at Jakar ta-,NA,NA
ORO,"Jakarta-
 ORO
  (fr om now on, just “
 ORO
 ”) is a vast, modular framework of mostly
  
 regex-r elated text-pr ocessing featur es containing a dizzying eight interfaces and
  
 35+ classes. When first faced with the documentation, you can be intimidated until
  
 you realize that you can get an amazing amount of use out of it by knowing just
  
 one class,
  Perl5Util
 , described next.",NA
ORO,NA,NA
’s,NA,NA
 Perl5Util,"This
  ORO
  version of the example from page 383 shows how simple
  Perl5Util
  is
  
 to work with:
  
 import org.apache.oro.text.perl.Perl5Util;
  
 public class
  SimpleRegexTest
  { 
  
 public static void main(String[]
  args
 ) 
  
 { 
  
   
 String
  sampleText
  = ""this is the 1st test string""; 
  
   
 Perl5Util
  engine
  = new Perl5Util();
  
   
 if (
 engine
 .match(""
 /
 \\d+\\w+
 /
 "",
  sampleText
 )) { 
  
   
 String
  matchedText
  =
  engine
 .group(0); 
  
   
 int 
  
 matchedFrom
  =
  engine
 .beginOffset(0); 
  
   
 int 
  
 matchedTo 
  
 =
  engine
 .endOffset(0); 
  
   
 System.out.println(""matched ["" +
  matchedText
  + ""] from "" + 
   
  
   
 matchedFrom
  + "" to "" +
  matchedTo
  + "".""); 
  
  
 } else { 
  
   
 System.out.println(""didn’t match""); 
  
   
 } 
  
 } 
  
 }
  
 One class hides all the messy details about working with regular expressions
  
 behind a simple façade that somewhat mimics regular-expr ession use in Perl.
  
 Wher e Perl has
  
 $input =˜ /ˆ([-+]?[0-9]+(\.[0-9]+)?)\s+([CF])$/i
  
 (fr om an example in Chapter 2 48),
  ORO
  allows:
  
 engine
 .match(""/ˆ([-+]?[0-9]+(\\.[0-9]+)?)\\s+([CF])$/i"",
  input
 )
  
 Wher e Perl then has
  
 $InputNum = $1; 
  
 #
  Save to named variables to make the ... 
  
 $Type 
  
 = $3; #
  ... rest of the program easier to read.
  
 ORO
  pr ovides for:
  
 inputNum
  =
  engine
 .group(1); //
  Save to named variables to make the ... 
  
 type 
 =
  engine
 .group(3); //
  ... rest of the program easier to read.
  
 If you’re not familiar with Perl, the
  /
 ˙˙˙
 /i
  trappings may seem a bit odd, and they
  
 can be cumbersome at times, but it lowers the barrier to regex use about as low as
  
 29 April 2003 20:54",NA
A Mini,NA,NA
 Perl5Util,NA,NA
 Reference,"The
  ORO
  suite of text-processing tools at first seems complex because of the raw number of 
 classes and interfaces. Although the documentation is well-written, it’s hard to know exactly 
 where to start. The
  Perl5Util
  part of the documentation, however, is fairly self-contained, so 
 it’s the only thing you really need at first. The next sections briefly go over the main 
 methods.
  
 Perl5Util
  basics
 —
 initiating a match
  
 match(
 expr ession
 ,
  tar get
  ) 
  
 Given a match
  expr ession
  in Perl notation, and a
  tar get
  string, retur ns true if the regex 
 can match somewhere in the string:
  
 if (
 engine
 .match(""
 /
 ˆSubject: (.+)
 /im
 "",
  emailMessageText
 )) 
  
 { 
  
 + 
  
 + 
  
 +
  
 As with Perl, you can pick your own delimiters, but unlike Perl, the leading
  m 
 is not 
 requir ed, and
  ORO
  does not support nested delimiters (e.g.,
  m{
 ˙˙˙
 }
 ).
  
 † One further step, I think, would be to remove the Perl trappings and just have separate arguments for the regex 
 and modifier. The whole
  m/
 ˙˙˙
 /
  bit may be convenient for those coming to Java from a Perl background, but it 
 doesn’t seem “natural” in Java.
  
 29 April 2003 20:54",NA
Using,NA,NA
 ORO,NA,NA
’s Underlying Classes,"If you need to do things that
  Perl5Util
  doesn’t allow, but still want to use
  ORO
 ,
  
 you’ll need to use the underlying classes (the “vast, modular framework”) directly.
  
 As an example, here’s an
  ORO
  version of the
  CSV
 -pr ocessing script on page 386.
  
 First, we need these 11 classes:
  
 import org.apache.oro.text.regex.PatternCompiler; 
  
 import org.apache.oro.text.regex.Perl5Compiler; 
  
 import org.apache.oro.text.regex.Pattern; 
  
 import org.apache.oro.text.regex.PatternMatcher; 
  
 import org.apache.oro.text.regex.Perl5Matcher; 
  
 import org.apache.oro.text.regex.MatchResult; 
  
 import org.apache.oro.text.regex.Substitution; 
  
 import org.apache.oro.text.regex.Util; 
  
 import org.apache.oro.text.regex.Perl5Substitution; 
  
 import org.apache.oro.text.regex.PatternMatcherInput; 
  
 import org.apache.oro.text.regex.MalformedPatternException;
  
 Then, we prepar e the regex engine
 —
 this is needed just once per thread:
  
 PatternCompiler
  compiler
  = new Perl5Compiler();
  
 PatternMatcher
  
 matcher
  
 = new Perl5Matcher();
  
 Now we declare the variables for our two regexes, and also initialize an object
  
 repr esenting the replacement text for when we change ‘
 """"
 ’ to ‘
 ""
 ’:
  
 Pattern
  rCSVmain 
  
 = null; 
  
 Pattern
  rCSVquote
  = null; 
  
 //
  When rCSVquote matches, we’ll want to replace with one double quote: 
  
 Substitution
  sCSVquote
  = new Perl5Substitution(""\"""");
  
 29 April 2003 20:54",NA
9,NA,NA
.,NA,NA
NET,"Micr osoft’s .
 NET
  Framework, usable with Visual Basic, C#, and C++ (among other 
 languages), offers a shared regular-expr ession library that unifies regex semantics among the 
 languages. It’s a full-featured, powerful engine that allows you the maximum flexibility in 
 balancing speed and convenience.
  
 Each language has a differ ent syntax for handling objects and methods, but those 
 underlying objects and methods are the same regardless of the language, so even complex 
 examples shown in one language directly translate to the other languages of the .
 NET
  
 language suite. Examples in this chapter are shown with Visual Basic.
  
 In This Chapter 
  
 Befor e looking at what’s in this chapter, it’s important to empha-size 
 that this chapter relies heavily on the base material in Chapters 1 through 6. I understand that 
 some readers interested only in .
 NET
  may be inclined to start their reading with this chapter, 
 and I want to encourage them not to miss the benefits of the preface (in particular, the 
 typographical conventions) and the earlier chapters: Chapters 1, 2, and 3 introduce basic 
 concepts, features, and techniques involved with regular expressions, while Chapters 4, 5, 
 and 6 offer important keys to regex understanding that directly apply to .
 NET
 ’s regex engine.
  
 This chapter first looks at .
 NET
 ’s regex flavor, including which metacharacters are supported 
 and how,
 †
 as well as the special issues that await the .
 NET
  pr ogrammer. Then there’s a quick 
 overview of .
 NET
 ’s regex-r elated object model, and how it’s been designed to allow you to 
 wield a regex, followed by a detailed look at each of the core regex-r elated classes. It all ends 
 with an example of how to build a personal regex library by encapsulating pre-built regular 
 expressions into a shared assembly.
  
 † This book covers .
 NET
  “Version 2002.” While researching this book, I uncovered a few bugs, which 
  
 Micr osoft 
 tells me will be fixed in the 2004 release of .
 NET
 .
  
 399
  
 29 April 2003 09:31",NA
.,NA,NA
NET,NA,NA
’s Regex Flavor,".
 NET
  has been built with a Traditional
  NFA
  regex engine, so all the important
  NFA
 -related 
 lessons from Chapters 4, 5, and 6 are applicable. Table 9-1 on the facing page summarizes 
 .
 NET
 ’s regex flavor, most of which is discussed in Chapter 3.
  
 Certain aspects of the flavor can be modified by
  match modes
  ( 109), turned on via option flags 
 to the various functions and constructors that accept regular expr essions, or in some cases, 
 turned on and off within the regex itself via 
 !(?
 mods
 -
 mods
 )""
  and
  !(?
 mods
 -
 mods
 :
 ˙˙˙
 )""
  constructs. The 
 modes are listed in Table 9-2 on page 402.
  
 A regex flavor can’t be described with just a simple table or two, so here are some notes to 
 augment Table 9-1:
  
 •
  In the table, “raw” escapes like
  !\w""
  ar e shown. These can be used directly in VB.NET 
 string literals (
 ""\w""
 ), and in C# verbatim strings (
 @""\w""
 ). In languages without regex-
 friendly string literals, such as C
 ++
 , each backslash in the regex requir es two in the 
 string literal (
 ""\\w""
 ). See “Strings as Regular Expressions”( 101).
  
 •
  \b
  is valid as a backspace only within a character class (outside, it matches a 
  
 word 
 boundary).
  
 •
  \x
 ##
  allows exactly two hexadecimal digits, e.g.,
  !
 \xFC
 ber""
  matches ‘
 ü
 ber
 ’.
  
 •
  �
 ####
  allows exactly four hexadecimal digits, e.g.,
  !
 ü
 ber""
  matches
  
 ‘
 ü
 ber
 ’, 
 and
  !€""
  matches ‘
 P
 ’.
  
 •
  \w
 ,
  \d
 , and
  \s
  (and their uppercase counterparts) normally match the full range of 
 appropriate Unicode characters, but change to an
  ASCII
 -only mode with the
  
 RegexOptions.ECMAScript
  option ( 406).
  
 •
  In its default mode,
  \w
  matches the Unicode properties
  \p{Ll}
 ,
  \p{Lu}
 , 
 \p{Lt}
 ,
  \p{Lo}
 ,
  
 \p{Nd}
 , and
  \p{Pc}
 . Note that this does not include the 
 \p{Lm}
  pr operty. (See the table 
 on page 121 for the property list.)
  
 •
  In its default mode,
  \s
  matches
  ![ \f\n\r\t\v \x85 \p{Z}]""
 .
  U
 +0085
  is the Unicode
  NEXT 
 LINE
  contr ol character, and
  \p{Z}
  matches Unicode “separator”characters ( 120).
  
 •
  \p{
 ˙˙˙
 }
  and
  \P{
 ˙˙˙
 }
  support most standard Unicode properties and blocks. Uni-code scripts 
 are not supported. Only the short property names like
  \p{Lu}
  ar e supported
  —
  long 
 names like
  \p{LowercaseRLetter}
  ar e not supported. (See the tables on pages 120 and 
 121.) Note, however, that the special composite pr operty
  \p{L&}
  is not supported, nor, 
 for some reason, are the
  \p{Pi}
  and 
 \p{Pf}
  pr operties. Single-letter properties
  do
  requir e 
 the braces (that is, the 
 \pL
  shorthand for
  \p{L}
  is
  not
  supported).
  
 29 April 2003 09:31",NA
Additional Comments on the Flavor,"A few issues merit longer discussion than a bullet point allows.
  
 Named capture
  
 .
 NET
  supports named capture ( 137), through the
  !(?<
 name
  >
 ˙˙˙
 )""
  or
  !(?’
 name
 ’
 ˙˙˙
 ) 
 syntax. Both 
 syntaxes mean the same thing and you can use either freely, but I pr efer the syntax with
  <
 ˙˙˙
 >
 , 
 as I believe it will be more widely used.
  
 29 April 2003 09:31",NA
Using .,NA,NA
NET,NA,NA
 Regular Expressions,".
 NET
  regular expressions are power ful, clean, and provided through a complete and easy-to-
 use class interface. But as wonderful a job that Microsoft did building the package, the 
 documentation is just the opposite
  —
  it’s horrifically bad. It’s woe-fully incomplete, poorly 
 written, disorganized, and sometimes even wrong. It took me quite a while to figure the 
 package out, so it’s my hope that the presentation in this chapter makes the use of .
 NET
  
 regular expressions clear for you.",NA
Regex Quickstar t,"You can get quite a bit of use out of the .
 NET
  regex package without even know-ing the 
 details of its regex class model. Knowing the details lets you get more infor mation mor e ef 
 ficiently, but the following are examples of how to do simple operations without explicitly 
 creating any classes. These are just examples; all the details follow shortly.
  
 Any program that uses the regex library must have the line
  
 Imports System.Text.RegularExpressions
  
 at the beginning of the file ( 409), so these examples assume that’s there.
  
 The following examples all work with the text in the
  String
  variable
  TestStr
 . As with all 
 examples in this chapter, names I’ve chosen are in italic.
  
 Quickstar t: Checking a string for match
  
 This example simply checks to see whether a regex matches a string:
  
 If Regex.IsMatch(
 TestStr
 , ""ˆ\s+$"") 
  
  
 Console.WriteLine(""line is empty"") 
  
 Else 
  
  
 Console.WriteLine(""line is not empty"") 
  
 End If
  
 This example uses a match option:
  
 If Regex.IsMatch(
 TestStr
 , ""ˆsubject:"", RegexOptions.IgnoreCase) 
  
 Console.WriteLine(""line is a subject line"") 
  
 Else 
  
  
 Console.WriteLine(""line is not a subject line"") 
  
 End If
  
 29 April 2003 09:31",NA
Package Overview,"You can get the most out .
 NET
  regular expressions by working with its rich and
  
 convenient class structure. To give us an overview, here’s a complete console
  
 application that shows a simple match using explicit objects:
  
 Option Explicit On ’
  These are not specifically requir ed to use regexes, 
  
 Option Strict On’
  but their use is good general practice.
  
 ’
  Make regex-r elated classes easily available.
  
 Imports System.Text.RegularExpressions
  
 Module
  SimpleTest 
  
 Sub Main() 
  
  
 Dim
  SampleText
  as String = ""this is the 1st test string"" 
  
 Dim
  R
  as Regex = 
 New Regex(""\d+\w+"") ’
 Compile the pattern.
  
 Dim
  M
  as Match =
  R
 .match(
 SampleText
 ) ’
 Check against a string.
  
 If not
  M
 .Success 
  
 Console.WriteLine(""no match"") 
  
 Else 
  
 Dim
  MatchedText
  as String 
  
 =
  M
 .Value ’
 Query the results . . .
  
  
 Dim
  MatchedFrom
  as Integer =
  M
 .Index 
  
  
 Dim
  MatchedLen 
  
 as Integer =
  M
 .Length 
  
  
 Console.WriteLine(""matched ["" &
  MatchedText
  & ""]"" & R 
  
  
  
  
  
 "" from char#"" &
  MatchedFrom
 .ToString() & R 
  
  
  
  
 "" for "" &
  MatchedLen
 .ToString() & "" chars."") 
  
 End If 
  
 End Sub 
  
 End Module
  
 When executed from a command prompt, it applies
  !\d+\w+""
  to the sample text and 
 displays:
  
 matched [1st] from char#12 for 3 chars.
  
 Impor ting the regex namespace
  
 Notice the
  Imports System.Text.RegularExpressions
  line near the top of the
  
 pr ogram? That’s requir ed in any
  VB
  pr ogram that wishes to access the .
 NET
  regex
  
 objects, to make them available to the compiler.
  
 29 April 2003 09:31",NA
Core Object Over view,"Befor e getting into the details, let’s first take a step back and look the .
 NET
  regex object 
 model. An object model is the set of class structures through which regex functionality is 
 provided. .
 NET
  regex functionality is provided through seven highly-interwoven classes, but 
 in practice, you’ll generally need to understand only the three shown visually in Figure 9-1 on 
 the facing page, which depicts the repeated application of
  !\s+(\d+)""
  to the string ‘
 May 16, 
 1998
 ’.
  
 Regex
  objects
  
 The first step is to create a
  Regex
  object, as with:
  
 Dim R as Regex = New Regex(""\s+(\d+)"")
  
 Her e, we’ve made a regex object repr esenting
  !\s+(\d+)""
  and stored it in the
  R 
 variable. 
 Once you’ve got a
  Regex
  object, you can apply it to text with its 
 Match(
 text
  )
  method, which 
 retur ns infor mation on the first match found:
  
 Dim M as Match = R.Match(""May 16, 1998"")
  
 29 April 2003 09:31",NA
Core Object Details,"Now that we’ve seen an overview, let’s look at the details. First, we’ll look at how to create a
  
 Regex
  object, followed by how to apply it to a string to yield a
  Match 
 object, and how to 
 work with that object and its
  Group
  objects.
  
 In practice, you can often avoid having to explicitly create a
  Regex
  object, but it’s good to be 
 comfortable with them, so during this look at the core objects, I’ll always explicitly create 
 them. We’ll see later what shortcuts .
 NET
  pr ovides to make things more convenient.
  
 In the lists that follow, I don’t mention little-used methods that are mer ely inher-ited from 
 the
  Object
  class.
  
 29 April 2003 09:31",NA
Creating,NA,NA
 Regex,NA,NA
 Objects,"The constructor for creating a
  Regex
  object is uncomplicated. It accepts either one argument 
 (the regex, as a string), or two arguments (the regex and a set of options). Here’s a one-
 argument example:
  
 Dim StripTrailWS = new Regex(""\s+$"") ’
  for removing trailing whitespace
  
 This just creates the
  Regex
  object, preparing it for use; no matching has been done to this 
 point.
  
 Her e’s a two-argument example:
  
 Dim GetSubject = new Regex(""ˆsubject: (.+)"", RegexOptions.IgnoreCase)
  
 That passes one of the
  RegexOptions
  flags, but you can pass multiple flags if they’r e
  OR
 ’d 
 together, as with:
  
 Dim GetSubject = new Regex(""ˆsubject: (.+)"", R 
  
 RegexOptions.IgnoreCase OR RegexOptions.Multiline)
  
 Catching exceptions
  
 An
  ArgumentException
  err or is thrown if a regex with an invalid combination of 
 metacharacters is given. You don’t normally need to catch this exception when using regular 
 expressions you know to work, but it’s important to catch it if using regular expressions 
 from “outside” the program (e.g., entered by the user, or read fr om a configuration file). 
 Here’s an example:
  
 Dim
  R
  As Regex 
  
 Try 
  
  
 R
  = New Regex(SearchRegex) 
  
 Catch
  e
  As ArgumentException 
  
  
 Console.WriteLine(""+ERROR+ bad regex: "" &
  e
 .ToString) 
  
  
 Exit Sub 
  
 End Try
  
 Of course, depending on the application, you may want to do something other than writing 
 to the console upon detection of the exception.
  
 Regex options
  
 The following option flags are allowed when creating a
  Regex
  object:
  
 RegexOptions.
 IgnoreCase 
  
 This option indicates that when the regex is applied, it should be done in a case-
 insensitive manner ( 109).
  
 RegexOptions.
 IgnorePatternWhitespace 
  
 This option indicates that the regex should be parsed in a free-spacing and comments 
 mode ( 110). If you use raw
  !#
 ˙˙˙
 ""
  comments, be sure to include a newline at the end of 
 each logical line, or the first raw comment “comments out” the entire rest of the regex.
  
 29 April 2003 09:31",NA
Using,NA,NA
 Regex,NA,NA
 Objects,"Just having a regex object is not useful unless you apply it, so the following meth-ods swing 
 it into action.
  
 RegexObj
 .IsMatch(
 tar get
  ) 
  
 Retur n type:
  Boolean 
 RegexObj
 .IsMatch(
 tar get
 ,
  of fset
  )
  
 The
  IsMatch
  method applies the object’s regex to the
  tar get
  string, retur ning a simple
  
 Boolean
  indicating whether the attempt is successful. Here’s an example:
  
 Dim R as RegexObj = New Regex(""ˆ\s+$"") 
  
  
 + 
  
  
 + 
  
  
 + 
  
 If R.IsMatch(Line) Then
  
  
 ’
  Line is blank . . .
  
 + 
  
 + 
  
 + 
  
 Endif
  
 If an
  of fset
  (an integer) is provided, that many characters in the target string are bypassed 
 before the regex is first attempted.
  
 RegexObj
 .Match(
 tar get
  ) 
  
 Retur n type:
  Match
  object 
 RegexObj
 .Match(
 tar get
 ,
  of fset
  ) 
  
 RegexObj
 .Match(
 tar get
 ,
  of fset
 ,
  maxlength
  )
  
 The
  Match
  method applies the object’s regex to the
  tar get
  string, retur ning a 
 Match
  object. 
 With this
  Match
  object, you can query information about the results of the match (whether it 
 was successful, the text matched, etc.), and initiate the“next” match of the same regex in the 
 string. Details of the
  Match
  object follow, starting on page 421.
  
 If an
  of fset
  (an integer) is provided, that many characters in the target string are bypassed 
 before the regex is first attempted.
  
 If you provide a
  maxlength
  argument, it puts matching into a special mode where the
  maxlength
  
 characters starting
  of fset
  characters into the
  tar get
  string are taken
  
 29 April 2003 09:31",NA
Special Per-Match Replacement Sequences,"Both the
  Regex.Replace
  method and the
  Match.Result
  method accept a“r eplacement” 
 string that’s interpreted specially. Within it, the following sequences are replaced by 
 appropriate text from the match:
  
 Sequence 
  
 Replaced by
  
 $& 
  
 $1
 ,
  $2
 , . . . 
  
 ${
 name
 } $‘
  
 $’
  
 $$ 
  
 $R 
  
 $+
  
 text matched by the regex (also available as
  $0
 ) 
  
 text matched by the corresponding set of capturing parentheses text 
 matched by the corresponding named capture 
  
 text of the target string
  befor e
  the match location 
  
 text of the target string
  after
  the match location 
  
 a single ‘
 $
 ’ character 
  
 a copy of the entire original target string 
  
 (see text below)
  
 The
  $+
  sequence is fairly useless as currently implemented. Its origins lie with Perl’s 
 useful
  $+
  variable, which refer ences the highest-numbered set of capturing 
 parentheses that
  actually participated
  in the match. (There’s an example of it in use on 
 page 202.) This .
 NET
  replacement-string
  $+
 , though, mer ely refer ences the highest-
 numbered set of capturing parentheses in the regex. It’s particularly useless in light of 
 the capturing-parentheses renumber-ing that’s automatically done when named 
 captures are used ( 403).
  
 Any uses of ‘
 $
 ’ in the replacement string in situations other than those described in the 
 table are left unmolested.
  
 Using a replacement delegate 
  
 The
  replacement
  argument isn’t limited to a simple string. It can be a
  delegate 
 (basically, a 
 pointer to a function). The delegate function is called after each match to generate the text to 
 use as the replacement. Since the function can do any pro-cessing you want, it’s an extremely 
 powerful replacement mechanism.
  
 The delegate is of the type
  MatchEvaluator
 , and is called once per match. The function it 
 refers to should accept the
  Match
  object for the match, do whatever pr ocessing you like, and 
 retur n the text to be used as the replacement.
  
 29 April 2003 09:31",NA
Using,NA,NA
 Match,NA,NA
 Objects,"Match
  objects are created by a
  Regex
 ’s
  Match
  method, the
  Regex.Match
  static function 
 (discussed in a bit), and a
  Match
  object’s own
  NextMatch
  method. It encapsulates all 
 information relating to a single application of a regex. It has the following properties and 
 methods:
  
 MatchObj
 .Success
  
 This retur ns a Boolean indicating whether the match was successful. If not, the object is a 
 copy of the static
  Match.Empty
  object.
  
 29 April 2003 09:31",NA
Displaying Infor mation about a Regex Object,"This displays what’s known about the
  Regex
  object in the variable
  R
 :
  
 ’
 Display information known about the Regex object in the variable R 
 Console.WriteLine(""Regex is: "" &
  R
 .ToString()) 
 Console.WriteLine(""Options are: "" &
  R
 .Options) If
  R
 .RightToLeft 
  
  
 Console.WriteLine(""Is Right-To-Left: True"") Else 
  
  
 Console.WriteLine(""Is Right-To-Left: False"") End If
  
 Dim
  S
  as String 
  
 For Each
  S
  in
  R
 .GetGroupNames() 
  
 Console.WriteLine(""Name """""" &
  S
  & """""" is Num #"" & R 
  
 R
 .GroupNumberFromName(
 S
 )) 
  
 Next 
  
 Console.WriteLine(""---"") 
  
 Dim
  I
  as Integer 
  
 For Each
  I
  in
  R
 .GetGroupNumbers() 
  
 Console.WriteLine(""Num #"" &
  I
  & "" is Name """""" & R 
  
 R
 .GroupNameFromNumber(
 I
 ) & """""""") Next
  
 Run twice, once with each of the two
  Regex
  objects created with
  
 New Regex(""ˆ(\w+)://([ˆ/]+)(/\S+)"")
  
 New Regex(""ˆ(?<proto>\w+)://(?<host>[ˆ/]+)(?<page>/\S+)"", 
  
 RegexOptions.Compiled)
  
 the following output is produced (with one regex cut off to fit the page):
  
 Regex is: ˆ(\w+)://([ˆ/]+)(/\S+) Option are: 0 
  
 Is Right-To-Left: False 
  
 Name ""0"" is Num #0 
  
 Name ""1"" is Num #1 
  
 Name ""2"" is Num #2 
  
 Name ""3"" is Num #3
  
 ---
  
 Num #0 is Name ""0"" 
  
 Num #1 is Name ""1"" 
  
 Num #2 is Name ""2"" 
  
 Num #3 is Name ""3""
  
 Regex is: ˆ(?<proto>\w+)://(?<host>
  
 Option 
 are: 8 
  
 Is Right-To-Left: False 
  
 Name ""0"" is Num #0 
  
 Name ""proto"" is Num #1 
  
 Name ""host"" is Num #2 
  
 Name ""page"" is Num #3
  
 ---
  
 Num #0 is Name ""0"" 
  
 Num #1 is Name ""proto"" 
  
 Num #2 is Name ""host"" 
  
 Num #3 is Name ""page""
  
  
 MatchObj
 .Value 
  
 MatchObj
 .ToString() 
  
 These retur n copies of the text actually matched.
  
 29 April 2003 09:31",NA
Using,NA,NA
 Group,NA,NA
 Objects,"A
  Group
  object contains the match information for one set of capturing parenthe-ses (or, if a 
 zer oth gr oup, for an entire match). It has the following properties and methods:
  
 GroupObj
 .Success
  
 This retur ns a Boolean indicating whether the group participated in the match. Not all 
 groups necessarily “participate” in a successful overall match. For example, if 
 !(this)<(that)""
  
 matches successfully, one of the sets of parentheses is guaranteed to have participated, while 
 the other is guaranteed to have not. See the footnote on page 138 for another example.
  
 GroupObj
 .Value 
  
 GroupObj
 .ToString()
  
 These both retur n a copy of the text captured by this group. If the match hadn’t been 
 successful, these retur n an empty string.
  
 GroupObj
 .Length
  
 This retur ns the length of the text captured by this group. If the match hadn’t been 
 successful, it retur ns zer o.
  
 GroupObj
 .Index
  
 This retur ns an integer indicating where in the target text the group match was found. The 
 retur n value is a zero-based index, so it’s the number of characters fr om the start (left) of 
 the string to the start (left) of the captured text. (This is true even if
  
 RegexOptions.RightToLeft
  had been used to create the regex that gen-erated this
  Match
  
 object.)
  
 GroupObj
 .Captures
  
 The
  Group
  object also has a
  Captures
  pr operty discussed starting on page 431.
  
 29 April 2003 09:31",NA
Static “Convenience” Functions,"As we saw in the “Regex Quickstart” beginning on page 407, you don’t always have to create 
 explicit
  Regex
  objects. The following static functions allow you to apply with regular 
 expressions directly:
  
 Regex.IsMatch(
 target
 ,
  pattern
 ) 
  
 Regex.IsMatch(
 target
 ,
  pattern
 ,
  options
 )
  
 Regex.Match(
 target
 ,
  pattern
 ) 
  
 Regex.Match(
 target
 ,
  pattern
 ,
  options
 )
  
 Regex.Matches(
 target
 ,
  pattern
 ) 
  
 Regex.Matches(
 target
 ,
  pattern
 ,
  options
 )
  
 Regex.Replace(
 target
 ,
  pattern
 ,
  replacement
 ) 
  
 Regex.Replace(
 target
 ,
  pattern
 ,
  replacement
 ,
  options
 )
  
 Regex.Split(
 target
 ,
  pattern
 ) 
  
 Regex.Split(
 target
 ,
  pattern
 ,
  options
 )
  
 Inter nally, these are just wrappers around the core
  Regex
  constructor and methods we’ve 
 already seen. They construct a temporary
  Regex
  object for you, use it to call the method 
 you’ve requested, and then throw the object away. (Well, they don’t actually throw it away
 —
 mor e on this in a bit.)
  
 Her e’s an example:
  
 If Regex.IsMatch(
 Line
 , ""ˆ\s+$"") 
  
 + 
  
 + 
  
 +
  
 That’s the same as
  
 Dim
  TemporaryRegex
  = New Regex(""ˆ\s+$"") 
  
 If
  TemporaryRegex
 .IsMatch(
 Line
 ) 
  
 + 
  
 + 
  
 +
  
 or, mor e accurately, as:
  
 If New Regex(""ˆ\s+$"").IsMatch(
 Line
 ) 
  
 + 
  
 + 
  
 +
  
 The advantage of using these convenience functions is that they generally make simple tasks 
 easier and less cumbersome. They allow an object-oriented package to appear to be a 
 procedural one ( 95). The disadvantage is that the
  patter n 
 must be reinspected each time.
  
 If the regex is used just once in the course of the whole program’s execution, it doesn’t 
 matter from an efficiency standpoint whether a convenience function is used. But, if a regex 
 is used multiple times (such as in a loop, or a commonly-called function), there’s some 
 overhead involved in preparing the regex each time ( 241). The goal of avoiding this usually 
 expensive overhead is the primary rea-son you’d build a
  Regex
  object once, and then use it 
 repeatedly later when actu-ally checking text. However, as the next section shows, .
 NET
  of 
 fers a way to have the best of both worlds: procedural convenience with object-oriented 
 efficiency.
  
 29 April 2003 09:31",NA
Regex Caching,"Having to always build and save a separate
  Regex
  object for every little regex you’d like to 
 use can be extremely cumbersome and inconvenient, so it’s wonder-ful that the .
 NET
  regex 
 package employs
  regex caching
 . If you use a pat-ter n/option combination that has already 
 been used during the execution of the pr ogram, the internal
  Regex
  object that had been built 
 the first time is reused, sav-ing
  you
  the drudgery of having to save and manage the
  Regex
  
 object.
  
 .
 NET
 ’s regex caching seems to be very efficient, so I would feel comfortable using the 
 convenience functions in most places. There is a small amount of overhead, as the cache 
 must compare the pattern string and its list of options to those it already has, but that’s a 
 small tradeoff for the enhanced program readability of the less-complicated approach that 
 convenience functions offer. I’d still opt for building and managing a raw
  Regex
  object in 
 very time-sensitive situations, such as apply-ing regexes in a tight loop.",NA
Suppor t Functions,"Besides the convenience functions described in the previous section, there are a few other 
 static support functions:
  
 Match.Empty
  
 This function retur ns a
  Match
  object that repr esents a failed match. It is perhaps useful for 
 initializing a
  Match
  object that you may or may not fill in later, but do intend to query later. 
 Her e’s a simple example:
  
 Dim
  SubMatch
  as Match = Match.Empty ’
 Initialize, in case it’s not set in the loop below 
 + 
  
 + 
  
 + 
  
 Dim
  Line
  as String 
  
 For Each
  Line
  in
  EmailHeaderLines
  
   
 ’
 If this is the subject, save the match info for later . . .
  
   
 Dim
  ThisMatch
  as Match = Regex.Match(
 Line
 , ""ˆSubject:\s+(.+)"", R 
  
  
    
 RegexOptions.IgnoreCase) 
  
  
 If
  ThisMatch
 .Success 
  
     
 SubMatch
  =
  ThisMatch 
  
   
 End If 
  
    
 + 
  
    
 + 
  
    
 + 
  
 Next 
  
 + 
  
 + 
  
 + 
  
 If
  SubMatch
 .Success 
  
   
 Console.WriteLine(
 SubMatch
 .Result(""The subject is: $1"")) 
  
 Else 
  
   
 Console.WriteLine(""No subject!"") 
  
 End If
  
 If the string array
  EmailHeaderLines
  actually has no lines (or no
  Subject
  lines), the loop that 
 iterates through them won’t ever set
  SubMatch
 , so the inspection of
  
 29 April 2003 09:31",NA
Advanced .,NA,NA
NET,"The following pages cover a few features that haven’t fit into the discussion so far: building a 
 regex library with regex assemblies, using an interesting .
 NET
 -only regex feature for 
 matching nested constructs, and a discussion of the
  Capture 
 object.
  
 29 April 2003 09:31",NA
Regex Assemblies,".
 NET
  allows you to encapsulate
  Regex
  objects into an assembly, which is useful in
  
 cr eating a regex library. The example in the sidebar on the facing page shows
  
 how to build one.
  
 When the sidebar example executes, it creates the file
  JfriedlsRegexLibrary.DLL
  in
  
 the project’s
  bin
  dir ectory.
  
 I can then use that assembly in another project, after first adding it as a refer ence
  
 via Visual Studio .
 NET
 ’s
  Pr oject
  >
  Add Reference
  dialog.
  
 To make the classes in the assembly available, I first import them:
  
 Imports jfriedl
  
 I can then use them just like any other class, as in this example::
  
 Dim
  FieldRegex
  as
  CSV.GetField
  = New
  CSV.GetField
  ’
 This makes a new Regex object 
 + 
  
 + 
  
 + 
  
 Dim
  FieldMatch
  as Match =
  FieldRegex
 .Match(
 Line
 ) ’
 Apply the regex to a string . . .
  
 While
  FieldMatch
 .Success 
  
 Dim
  Field
  as String 
  
 If
  FieldMatch
 .Groups(1).Success 
  
   
 Field
  =
  FieldMatch
 .Groups(""QuotedField"").Value 
  
   
 Field
  = Regex.Replace(
 Field
 , """""" """" "", """""""") ’
 replace two double quotes with one 
 Else 
  
   
 Field
  =
  FieldMatch
 .Groups(""UnquotedField"").Value 
  
 End If
  
 Console.WriteLine(""["" &
  Field
  & ""]"")
  
 ’ Can now work with ’
 Field
 ’....
  
 FieldMatch
  =
  FieldMatch
 .NextMatch 
  
 End While
  
 In this example, I chose to import only from the
  jfriedl
  namespace, but could
  
 have just as easily imported from the
  jfriedl.CSV
  namespace, which then would
  
 allow the
  Regex
  object to be created with:
  
 Dim
  FieldRegex
  as
  GetField
  = New
  GetField
  ’
 This makes a new Regex object
  
 The differ ence is mostly a matter of style. You can also choose to not import any-
  
 thing, but rather use them directly:
  
 Dim
  FieldRegex
  as
  jfriedl.CSV.GetField
  = New
  jfriedl.CSV.GetField
  
 This is a bit more cumbersome, but documents clearly where exactly the object is
  
 coming from. Again, it’s a matter of style.
  
 29 April 2003 09:31",NA
Creating Your Own Regex Librar y With an Assembly,"This example builds a small regex library. This complete program builds an
  
 assembly (
 DLL
 ) that holds three pre-built
  Regex
  constructors I’ve named
  
 jfriedl.Mail.Subject
 ,
  jfriedl.Mail.From
 , and
  jfriedl.CSV.GetField
 .
  
 The first two are simple examples just to show how it’s done, but the com-
  
 plexity of the final one really shows the promise of building your own
  
 library. Note that you don’t have to give the
  RegexOptions.Compiled
  flag,
  
 as that’s implied by the process of building an assembly.
  
 See the text ( 428) for how to use the assembly after it’s built.
  
 Option Explicit On
  
 Option Strict On
  
 Imports System.Text.RegularExpressions
  
 Imports System.Reflection
  
 Module
  BuildMyLibrary
  
 Sub Main()
  
 ’
 The calls to RegexCompilationInfo below provide the pattern, regex options, name within the class,
  
 ’
 class name, and a Boolean indicating whether the new class is public. The first class, for example,
  
 ’
 will be available to programs that use this assembly as ""jfriedl.Mail.Subject"", a Regex constructor.
  
 Dim
  RCInfo
 () as RegexCompilationInfo = { 
  
 R
  
 New RegexCompilationInfo( 
  
 R
  
 ""ˆSubject:\s+(.+)"", RegexOptions.IgnoreCase, 
  
 R
  
 ""Subject"", ""jfriedl.Mail"", true), 
  
 R
  
 New RegexCompilationInfo( 
  
 R
  
 ""ˆFrom:\s+(.+)"", RegexOptions.IgnoreCase, 
  
 R
  
 ""From"", ""jfriedl.Mail"", true), 
  
 R
  
 New RegexCompilationInfo( 
  
 R
  
 ""\G(?:ˆ;,) "" & 
  
 R
  
 ""(?: "" & 
  
 R
  
 "" 
  
 (?# Either a double-quoted field... ) "" & 
  
 R
  
 "" 
  
 """" (?# field’s opening quote ) "" & 
  
 R
  
 "" 
  
 (?<QuotedField> (?> [ˆ""""]+ ; """""""" )+ 
  
 ) "" & 
  
 R
  
 "" 
  
 """" (?# field’s closing quote ) "" & 
  
 R
  
 "" (?# ...or... ) "" & 
  
 R
  
 "" ; "" & 
  
 R
  
 "" 
  
 (?# ...some non-quote/non-comma text... ) "" & 
  
 R
  
 "" 
  
 (?<UnquotedField> [ˆ"""",]+ ) "" & 
  
 R
  
 "" )"", 
  
 R
  
 RegexOptions.IgnorePatternWhitespace, 
  
 R
  
 ""GetField"", ""jfriedl.CSV"", true) 
  
 R
  
 }
  
 ’
 Now do the heavy lifting to build and write out the whole thing . . .
  
 Dim
  AN
  as AssemblyName = new AssemblyName()
  
 AN
 .Name = ""JfriedlsRegexLibrary"" ’
 This will be the DLL’s filename
  
 AN
 .Version = New Version(""1.0.0.0"")
  
 Regex.CompileToAssembly(
 RCInfo
 ,
  AN
 ) ’
 Build everything
  
 End Sub
  
 End Module
  
 29 April 2003 09:31",NA
Matching Nested Constructs,"Micr osoft has included an interesting innovation for matching balanced constructs 
 (historically, something not possible with a regular expression). It’s not particularly easy to 
 understand
 —
 this section is short, but be warned, it is very dense.
  
 It’s easiest to understand with an example, so I’ll start with one:
  
 Dim
  R
  As Regex = New Regex("" \( 
  
  
  
 "" & R 
  
  
 "" 
  
 (?> 
  
 "" & R 
   
 "" 
   
  
 [ˆ()]+ 
  
 "" & R 
   
 "" 
  
 ; 
  
  
 "" 
 & R 
  
  
 "" 
  
   
 \( (?<DEPTH>) 
  
 "" & R 
  
  
 "" 
  
 ; 
  
  
  
 "" & R 
   
 "" 
   
  
 \) 
 (?<-DEPTH>) "" & R 
  
  
 "" 
  
 )+ 
   
  
 "" 
 & R 
  
  
 "" 
  
 (?(DEPTH)(?!)) 
  
  
 "" & R 
  
  
 "" \) 
   
  
 "", 
  
 R RegexOptions.IgnorePatternWhitespace)
  
 This matches the first properly-pair ed nested set of parentheses, such as the under-lined 
 portion of ‘
 before (nope (yes (here) okay) after
 ’. The first parenthe-
  
 sis isn’t matched because it has no associated closing parenthesis.
  
 Her e’s the super-short overview of how it works:
  
 1
 . With each ‘
 (
 ’ matched,
  !(?<DEPTH>)""
  adds one to the regex’s idea of how deep the 
 parentheses are curr ently nested (at least, nested beyond the initial 
  
  
 !\(""
  at 
 the start of the regex).
  
 2
 . With each ‘
 )
 ’ matched,
  !(?<-DEPTH>)""
  subtracts one from that depth.
  
 3
 . 
 !(?(DEPTH) (?!))""
  ensur es that the depth is zero befor e allowing the final lit-eral
  !\)""
  to 
 match.
  
 This works because the engine’s backtracking stack keeps track of successfully-matched 
 groupings.
  !(?<DEPTH>)""
  is just a named-capture version of
  !()""
 , which is always successful. 
 Since it has been placed immediately after
  !\(""
 , its success (which remains on the stack until 
 removed) is used as a marker for counting opening parentheses.
  
 Thus, the number of successful ‘
 DEPTH
 ’ groupings matched so far is maintained on the 
 backtracking stack. We want to subtract from that whenever a closing paren-theses is found. 
 That’s accomplished by .
 NET
 ’s special
  !(?<-DEPTH>)""
  construct, which removes the most 
 recent “successful
  DEPTH
 ” notation from the stack. If it tur ns out that there aren’t any, the
  
 !(?<-DEPTH>)""
  itself fails, thereby disallowing the regex from over-matching an extra closing 
 parenthesis.
  
 Finally,
  !(?(DEPTH) (?!))""
  is a normal conditional that applies
  !(?!)""
  if the ‘
 DEPTH
 ’gr ouping is 
 currently successful. If it’s still successful by the time we get here, ther e was an unpaired 
 opening parenthesis whose success had never been
  
 29 April 2003 09:31",NA
Capture,NA,NA
 Objects,"Ther e’s an additional component to .
 NET
 ’s object model, the
  Capture
  object, which I 
 haven’t discussed yet. Depending on your point of view, it either adds an inter esting new 
 dimension to the match results, or adds confusion and bloat.
  
 A
  Capture
  object is almost identical to a
  Group
  object in that it repr esents the text matched 
 within a set of capturing parentheses. Like the
  Group
  object, it has meth-ods for
  Value
  (the 
 text matched),
  Length
  (the length of the text matched), and 
 Index
  (the zero-based number of 
 characters into the target string that the match was found).
  
 The main differ ence between a
  Group
  object and a
  Capture
  object is that each 
 Group
  object 
 contains a collection of
  Captures
  repr esenting all the
  inter mediary 
 matches by the group 
 during the match, as well as the final text matched by the gr oup.
  
 Her e’s an example with
  !ˆ(..)+""
  applied to ‘
 abcdefghijk
 ’:
  
 Dim
  M
  as Match = Regex.Match(""abcdefghijk"", ""ˆ(..)+"")
  
 The regex matches four sets of
  !(..)""
 , which is most of the string: ‘
 abcdefghijk
 ’.
  
 Since the plus is outside of the parentheses, they recaptur e with each iteration of the plus, 
 and are left with only ‘
 ij
 ’ (that is,
  M.Groups(1).Value
  is ‘
 ij
 ’). How-ever, that
  M.Groups(1)
  also 
 contains a collection of
  Captures
  repr esenting the complete ‘
 ab
 ’, ‘
 cd
 ’, ‘
 ef
 ’, ‘
 gh
 ’, and ‘
 ij
 ’ that
  
 !(..)""
  walked through during the match:
  
 M
 .Groups(1).Captures(0).Value
  
 is 
 ‘
 ab
 ’
  
 M
 .Groups(1).Captures(1).Value
  
 is 
 ‘
 cd
 ’
  
 M
 .Groups(1).Captures(2).Value
  
 is 
 ‘
 ef
 ’
  
 M
 .Groups(1).Captures(3).Value
  
 is 
 ‘
 gh
 ’
  
 M
 .Groups(1).Captures(4).Value
  
 is 
 ‘
 ij
 ’
  
 M
 .Groups(1).Captures.Count
  is 5.
  
 You’ll notice that the last capture has the same ‘
 ij
 ’ value as the overall match, 
 M.Groups(1).Value
 . It tur ns out that the
  Value
  of a
  Group
  is really just a short-hand notation 
 for the group’s final capture.
  M.Groups(1).Value
  is really:
  
 M.Groups(1).Captures(
  M.Groups(1).Captures.Count - 1
  ).Value
  
 29 April 2003 09:31",NA
Index,"O 
 xx
  
 \G
  
 128-131, 212, 315-316, 362
  
 \?
  
 139
  
 (also see
  pos
 )
  
  
 \<
 ˙˙˙
 \>
  
 21, 25, 50, 131-132, 150
  
 advanced example 130 
  
 in Java 373 
  
 in .
 NET
  402 
  
 optimization 246
  
 in
  egr ep
  15 
  
 in Emacs 100 
  
 mimicking in Perl 341-342
  
 \+
  
 139
  
 \k
 name
  
 (see named capture)
  
 \(
 ˙˙˙
 \)
  
 135
  
 \l
  
 290
  
 ‘
 \+
 ’
  
 history 87
  
 \L
 ˙˙˙
 \E
  
 290
  
 \0
  
 116-117
  
 inhibiting 292
  
 \1
  
 136, 300, 303
  
 \n
  
 49, 114-115
  
 (also see backrefer ences) 
  
 in Perl 41
  
 intr oduced 44 
  
 machine-dependency 114
  
 \A
  
 111, 127-128
  
 \N{LATIN SMALL LETTER SHARP S}
  
 290
  
 (also see enhanced line-anchor mode) in 
 Java 373 
  
 optimization 246
  
 \N{
 name
 }
  
 290
  
 (also see pragma) 
  
 inhibiting 292
  
 \a
  
 114-115
  
 \p{
 ˙˙˙
 }
  
 119
  
 \b
  
 65, 114-115, 400
  
 (also see Unicode, properties)
  
 (also see: word boundaries; backspace) 
 backspace and word boundary 44, 46 in Perl 
 286
  
 \p{ˆ
 ˙˙˙
 }
  
 288
  
 \p{all}
  
 380
  
 \p{All}
  
 123
  
 \b\B
  
 240
  
 in Perl 288
  
 \C
  
 328
  
 \p{Any}
  
 123
  
 \D
  
 49, 119
  
 in Perl 288
  
 \d
  
 49, 119
  
 \p{Arrows}
  
 122
  
 in Perl 288
  
 \p{Assigned}
  
 123-124
  
 \e
  
 79, 114-115
  
 in Perl 288
  
 \E
  
 290
  
 \p{BasicRLatin}
  
 122
  
 (also see literal-text mode)
  
 \p{BoxRDrawing}
  
 122
  
 \f
  
 114-115
  
 \p{C}
  
 120
  
 intr oduced 44
  
 \p{Cc}
  
 121
  
 \p{Cf}
  
 121
  
 \p{Cherokee}
  
 120
  
 433
  
 5 May 2003 08:41",NA
