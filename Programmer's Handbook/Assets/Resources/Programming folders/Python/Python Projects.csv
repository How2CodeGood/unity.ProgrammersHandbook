Larger Text,Smaller Text,Symbol
PYTHON,®,NA
 PROJECTS,"INTRODUCTION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxv
  
 CHAPTER 1 
  
 Reviewing Core Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
  
 CHAPTER 2 
  
 Scripting with Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
  
 CHAPTER 3 
  
 Managing Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
  
 CHAPTER 4 
  
 Building Desktop Applications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
  
 CHAPTER 5 
  
 Python on the Web  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
  
 CHAPTER 6 
  
 Python in Bigger Projects  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
  
 CHAPTER 7 
  
 Exploring Python’s Frontiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
  
 APPENDIX A 
  
 Answers to Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
  
 APPENDIX B 
  
 Python Standard Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
  
 APPENDIX C 
 Useful Python Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
  
 REFERENCES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
  
 INDEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
  
 www.it-ebooks.info",NA
Python,NA,NA
®,NA,NA
 Projects,www.it-ebooks.info,NA
Python,NA,NA
®,NA,NA
 Projects,"Laura Cassell 
  
 Alan Gauld
  
 www.it-ebooks.info",NA
ABOUT THE AUTHORS,"LAURA CASSELL
  has been poking at code on the web since 1997. She taught herself Perl in the early 2000s 
 where she discovered that programming materials were in dire need of an overhaul and the barrier to 
 entry to teach programming was incredibly high. Thus, her journey to learn programming so she can 
 bring it to other people began.
  
 Originally from Atlanta, GA, Laura founded PyLadies Atlanta, and got her start teaching Python and 
 JavaScript for Big Nerd Ranch. She has since moved on to engineering management and currently 
 resides in Portland, OR where she manages a team of Pythonistas doing software analytics for New 
 Relic, Inc. She still volunteers for teaching and speaking gigs when time permits.
  
 ALAN GAULD
  is an enterprise architect with more than 40 years of experience in IT, working mainly in the 
 telecommunications and customer service areas. He has programmed in more than 20 languages, 
 producing everything from mainframe billing systems through embedded micro-controllers. For the 
 last 15 years, his preference has been for Python. He is the author of a beginner’s book on Python and is 
 co-moderator of the python-tutor mailing list.
  
 When not programming, he likes climbing, backpacking, and skiing. He is also a keen 
 photographer, artist, and acoustic music enthusiast. He lives in Scotland with his wife, Heather.
  
 www.it-ebooks.info",NA
ABOUT THE TECHNICAL EDITORS,"ALEX BRADBURY
  is a compiler hacker, Linux geek, and Free Software enthusiast. He has been a long 
 time contributor to the Raspberry Pi project and also co-authored 
 Learning Python with Raspberry Pi
 . 
 He is currently a researcher at the University of Cambridge Computer Laboratory and is a co-founder 
 of lowRISC, a non-profi t project to produce a complete open-source System-on-Chip (SoC).
  
 TODD SHANDELMAN
  fondly remembers coding assembly language programs on punch cards for IBM 
 System/370 mainframes. After occupying various other ecological niches in software technology over 
 the years (C, C++, and Perl, to name but a few), Todd’s best days are now spent coding pure Python 2.x 
 and 3.x from the Linux command line. In his spare time he is a professional translator of Russian and 
 Hebrew, specializes in foreign-language typography, and can fi nd his way in the dark around Unicode 
 and UTF-8. Todd earned a Bachelor of Science degree in Business Administration from the University of 
 the State of New York. He lives in Houston, Texas, with his wife and son.
  
 www.it-ebooks.info",NA
CREDITS,"Acquisitions Editor 
  
 Jim Minatel
  
 Project Editor 
  
 Jennifer Lynn
  
 Technical Editors 
  
 Alex Bradbury 
  
 Todd Shandelman
  
 Production Editor 
  
 Christine Mugnolo
  
 Copy Editor 
  
 Kimberly A. Cofer
  
 Production Manager 
  
 Kathleen Wisor
  
 Manager of Content Development and 
 Assembly 
  
 Mary Beth Wakefi eld 
  
 Marketing Director
  
 Professional Technology & Strategy 
 Director 
  
 Barry Pruett
  
 Business Manager 
  
 Amy Knies
  
 Associate Publisher 
  
 Jim Minatel
  
 Project Coordinator, Cover 
 Patrick Redmond
  
 Proofreader 
  
 Sarah Kaikini, Word One New York
  
 Indexer 
  
 Johnna Dinse
  
 Cover Designer 
  
 Wiley
  
 Cover Image
  
 © iStock.com/skodonnell
  
 David Mayhew
  
 Marketing Manager
  
 Carrie Sherrill
  
 www.it-ebooks.info",NA
ACKNOWLEDGMENTS,"I’D LIKE TO GIVE 
 a big thank you to Alan Gauld, who helped put so much of this book together, and to 
 Mary James and Jennifer Lynn for making sure this idea came to fruition. It’s a better book because of 
 all of you.
  
 Thank you also to the Python community, you are all the most welcoming community that I’ve ever 
 found. You have created a place where people feel welcome and able to approach everyone, experts to 
 novices alike. Keep up the good work and thank you for allowing me to be a part of this wonderful 
 community.
  
 —Laura Cassell 
 I’D LIKE TO GIVE 
 a shout out to Laura Cassell for kick-starting this project, Jennifer Lynn for 
 steering us through it, and the Python community for their support over the last 15 years.
  
 —Alan Gauld 
 www.it-ebooks.info",NA
CONTENTS,"INTRODUCTION 
  
 CHAPTER 1: REVIEWING CORE PYTHON 
  
 xxv 
  
 1
  
 Exploring the Python Language and the Interpreter 
 Reviewing the Python Data Types  
  
 Numeric Types: Integer and Float 
  
  
 The Boolean Type 
  
  
 The None Type 
  
  
 Collection Types 
  
  
  
 Strings 
  
 Bytes and ByteArrays 
  
 Tuples 
  
 Lists 
  
 Dictionaries 
  
  
  
 Sets 
  
 Using Python Control Structures  
  
 Structuring Your Program 
  
  
 Using Sequences, Blocks and Comments 
  
 Selecting an Execution Path 
  
  
 Iteration 
  
  
 Handling Exceptions 
  
  
 Managing Context 
  
 Getting Data In and Out of Python  
  
 Interacting with Users 
  
  
 Using Text Files 
  
 Extending Python  
  
 Defi ning and Using Functions 
  
  
  
 Generator Functions 
  
  
  
 Lambda Functions 
  
  
 Defi ning and Using Classes and Objects 
 Creating 
 and Using Modules and Packages  
 Using and 
 Creating Modules 
  
  
 Using and Creating Packages 
  
 Creating an Example Package  
 Using Third‐Party Packages  
 Summary  
 2  
 3  
 4 
  
 5 
  
 6 
  
 6 
  
 7
  
 8
  
 10
  
 10
  
 12
  
 13 
  
 15  
 15 
  
 16 
  
 17 
  
 18 
  
 20 
  
 21 
  
 21  
 21 
  
 23 
  
 24  
 24 
  
 26
  
 27 
  
 28 
  
 33  
 33 
  
 34 
  
 36  
 42  
 43 
 www.it-ebooks.info",NA
 INTRODUCTION ,"AFTER A CONFERENCE ONE YEAR, 
 an e-mail went around the PyLadies organizers mailing list asking, “Is 
 anyone interested in writing a Python book?” I had kicked around the idea of a programming book for 
 a while. After teaching for a couple years and mentoring at PyLadies and other coding meetups, I 
 realized there was a need for a new, specifi c sort of programming book. I didn’t jump to replying to 
 the e-mail, however. I knew that writing a book would be a big process (boy is it!) and that it would 
 take a lot of time and effort on my part, in the way of working on the weekends and holidays (yep, 
 check!). I also knew that I had a full‐time job teaching programming, I was the lead organizer for my 
 local PyLadies chapter in Atlanta, Georgia, and I had children that would soon start asking, “Are you 
 writing this weekend?”
  
  All of the above was true (a little more than I originally thought, actually), but I knew that the book was 
 important. There were so many of my students asking me at the end of class, “Now that I know the 
 basics of Python, what do I do?” My answer was always something along the lines of, “You can get 
 involved in open‐source projects!” or “Take the advanced Python class!” But none of those answers 
 satisfi ed them or me. The answer is, “You have to really start looking for something to work on—a 
 problem to solve, a need that must be met.” Because, the only way to really know and understand 
 programming and a programming language is to solve problems with said language. 
  
  But then the problem of “But I don’t have a problem that really needs to be solved” cropped up. So 
 while I could send my students off to look at open‐source projects that do, in fact, need the help, if 
 they didn’t understand the technology, they’d be lost and give up. Then the community loses yet 
 another programmer who may have brought interesting things to the table. So, that’s when, after lots 
 of talking to friends and family, I realized that this book needed to be written.",NA
 WHY WE WROTE THIS BOOK ,"For all those people who came up to us and asked, over the years, “What can I do now that I 
 understand Python basics? What things can I learn? Where do I go?” That’s why we wrote this book.
  
  The most chronic problem in programming books that we’ve experienced and that others have also 
 felt they experienced is that it goes from “These are the basics of a language” into very deep 
 concepts that only people who hold Computer Science (CS) degrees would understand. And that’s 
 not cool. Programming should be open to anyone who is interested. We should all be working 
 toward making the bar into programming a little lower. We feel that Python accomplishes this, but 
 we need to take it a step further and begin to understand how people learn abstract ideas and 
 concepts, to help us help them learn. 
  
  Think of programming like learning how to build a house, but only understanding that wood is 
 needed and how the wood works to build a house. You still need to understand structural 
 engineering, electrical, plumbing, ventilation, HVAC, etc. The same concept is true for 
  
 www.it-ebooks.info",NA
 WHO THIS BOOK FOR,"This book is not for beginners who want to learn Python. Rather, as a reader of this book, you need to 
 already have some Python programming under your belt. That means you’ve done some tutorials. You 
 also understand that whitespace matters in Python and that lists are denoted with hard braces ( 
 [ ]
  ) 
 while dicts (dictionaries) are denoted with curly braces (  
 { }
   ). This book is for those people who are 
 still beginners, but who have completed a tutorial or two—folks who understand the basics of Python, 
 but are interested to learn what all they can do with Python. 
  
  “Need is the mother of invention” goes the saying, and when you’re learning to program, this is very 
 true. If you need a piece of software that can perform a specifi c function or task, it’s easy to learn a 
 language around that need. You have a need, the language will help you, you learn the language, you 
 solve the problem, you’ve learned a thing, and you’ve put it to use immediately. This is awesome and 
 fantastic! However, what if you think programming is interesting, but you’re missing the need? What if 
 you don’t know what to make? That’s where this book comes in. 
  
  This book will help you to learn the parts of Python that most people don’t think to tell new 
 programmers about. Most of the things covered in this book are tools and technologies that one may 
 only discover when they are faced with working with them. However, for new programmers who don’t 
 have a specifi c problem to solve, learning these tools can be diffi cult. Most of the time no one thinks to 
 introduce these topics to programmers because they are used so regularly. We hope to take you on a 
 journey through the power of Python and all of its splendor. 
  
  You will learn how to make a web app, how to talk to a database using Python libraries, and which 
 system tools can help speed up your workfl ow, if you’re a systems administrator. We will briefl y 
 touch on topics such as security and best practices. You’ll get an overview of creating graphical user 
 interfaces (GUIs) using Python libraries. We will cover consuming and producing application 
 programming interfaces (APIs) and many other topics that are benefi cial to Python programmers.",NA
 WHAT YOU WILL LEARN,"We hope to take you on a small tour of the basics that are available in the Python ecosystem. We’ll 
 introduce you to many concepts that are usually discovered only while working on a problem to solve. 
 While we can’t put everything into the context of problems that you may need to solve in the future, 
 we hope that we can illustrate the powerful features of the Python language and the available 
 packages and technology that are available to you, the new Python programmer. 
  
  We will start out with a brief “crash course” in Python, in case you’ve forgotten anything. We’ll go 
 over the basics, and then you can decide if you want to read that chapter in its entirety or not. 
  
 Next, we go over Python as a scripting language. You’ll get to get your hands dirty, as it were, by 
 writing small scripts to access parts of your system, using Python. This should illustrate the 
  
 xxvi
  
 www.it-ebooks.info",NA
 WHAT YOU NEED TO USE THIS BOOK ,"In order to get the most out of this book, we recommend you have a modern computer running 
 Python 3.3 or later, a good text editor that you are comfortable using, an Internet connection (for 
 some parts of the book), and a healthy dose of patience and wonderment. We also 
  
 recommend that you utilize Internet searching for any problems that may arise. Professional 
 programmers don’t actually know it all; they usually only know those problems that they deal with 
 day in and day out. A lot of the time of a professional programmer is spent researching and tracking 
 down why a behavior is occurring. No one should ever feel bad for relying on a Google search to 
 solve a problem. Sometimes, your Googling abilities are just as important as your programming 
 ones. 
  
  To work through the examples and projects in this book, you will also need the source code. The 
 source code for the samples is available for download from the Wrox website at: 
  
 www.wrox.com/go/pythonprojects
  
 xxvii
  
 www.it-ebooks.info",NA
 CONVENTIONS ,"To help you get the most from the text and keep track of what’s happening, we’ve used a number of 
 conventions throughout the book.
  
  TRY IT OUT 
  
  The 
 Try It Out
  is an exercise you should work through, following the text in the book.
  
  1.
  
  They usually consist of a set of steps. 
  
  2.
  
  Each step has a number. 
  
  3.
  
  Follow the steps through with your copy of the database.
  
  How It Works 
  
  After each  
 Try It Out
  , the code you’ve typed will be explained in detail. 
  
 WARNING 
  Warnings hold important, not‐to‐be‐forgotten information that is 
 directly relevant to the surrounding text. 
  
  
 NOTE 
  Notes indicate notes, tips, hints, tricks, or asides to the current discussion. 
  
  As for styles in the text: 
  
 ➤
  
  We highlight new terms and important words when we introduce them.
  
 ➤
  
  We show keyboard strokes like this: Ctrl+A.
  
 ➤
  
  We show fi lenames, URLs, and code within the text like so:  
 persistence.properties
  . 
  
 ➤
  
  We present code in two different ways:
  
  We use a monofont type with no highlighting for most code examples.
  
 We use bold to emphasize code that is particularly important in the 
 present context or to show changes from a previous code snippet.",NA
 SOURCE CODE,"As you work through the examples in this book, you may choose either to type in all the code 
 manually, or to use the source code fi les that accompany the book. All the source code used in this 
 book is available for download at 
 www.wrox.com
  . Specifi cally for this book, the code download is on 
 the Download Code tab at:
  
 www.wrox.com/go/pythonprojects
  
 xxviii
  
 www.it-ebooks.info",NA
 ERRATA,"We make every effort to ensure that there are no errors in the text or in the code. However, no one is 
 perfect, and mistakes do occur. If you fi nd an error in one of our books, like a spelling mistake or 
 faulty piece of code, we would be very grateful for your feedback. By sending in errata, you may save 
 another reader hours of frustration, and at the same time, you will be helping us provide even higher 
 quality information. 
  
  To fi nd the errata page for this book, go to: 
  
 www.wrox.com/go/pythonprojects
  
  And click the Errata link. On this page you can view all errata that has been submitted for this book and 
 posted by Wrox editors.
  
  If you don’t spot “your” error on the Book Errata page, go to  
 www.wrox.com/contact/ 
  
 techsupport.shtml
  and complete the form there to send us the error you have found. We’ll check the 
 information and, if appropriate, post a message to the book’s errata page and fi x the problem in 
 subsequent editions of the book.",NA
 P2P.WROX.COM,"For author and peer discussion, join the P2P forums at 
 http://p2p.wrox.com
  . The forums are a 
 Web‐based system for you to post messages relating to Wrox books and related technologies and 
 interact with other readers and technology users. The forums offer a subscription feature to e‐mail 
 you topics of interest of your choosing when new posts are made to the forums. Wrox authors, editors, 
 other industry experts, and your fellow readers are present on these forums. 
  
  At 
 http://p2p.wrox.com
  , you will fi nd a number of different forums that will help you, not only as 
 you read this book, but also as you develop your own applications. To join the forums, just follow these 
 steps:
  
 1. 
  
 2. 
  
 3.
  
 4.
  
  Go to 
 http://p2p.wrox.com
  and click the Register link.
  
  Read the terms of use and click Agree. 
  
  Complete the required information to join, as well as any optional information you wish to 
 provide, and click Submit.
  
  You will receive an e‐mail with information describing how to verify your account and 
 complete the joining process. 
  
 xxix
  
 www.it-ebooks.info",NA
 1 ,"WHAT YOU WILL LEARN IN THIS CHAPTER: 
  
 ➤
  
  The basic features of the Python language 
  
 ➤
  
  How to use the Python module mechanism 
  
 ➤
  
  How to create a new module 
  
 ➤
  
  How to create a new package 
  
  WROX.COM CODE DOWNLOADS FOR THIS CHAPTER 
  
  You can fi nd the wrox.com downloads for this chapter at  
 www.wrox.com/go/pythonprojects 
 on the Download Code tab. The code is in the Chapter   1 download and individually named 
 according to the names throughout the chapter. 
  
  This chapter starts with a brief review of Python—in case you have forgotten some of the 
 basics—and provides a foundation upon which the rest of the book is built. If you are confi dent 
 in your ability with basic Python coding, feel free to skip ahead until you see content that might 
 be of interest to you. After all, you can always come back to this chapter later if you fi nd you need 
 a refresher. 
  
  In this chapter you start off by looking at the Python ecosystem, the data types, and the major 
 control structures and then move on to defi ning functions and classes. Next, you look at the 
 Python module and package system. And, fi nally, you create a basic new package of modules. 
  
  By the end of this chapter, you should be ready to take the next step and start working with the 
 standard Python modules on real project tasks. 
  
 www.it-ebooks.info",NA
 EXPLORING THE PYTHON LANGUAGE AND ,NA,NA
THE INTERPRETER ,"Python is a dynamic but strictly typed programming language. It is both interpreted and compiled in 
 that the original source code is compiled into byte code and then interpreted, but this happens 
 transparently to the user; you do not have to explicitly ask Python to compile your code.
  
  The Python language has several implementations, but the most common is the version written in C, 
 often referred to as  
 CPython
  . Other implementations include Jython, written in Java, and IronPython, 
 written for the Microsoft .NET platform. CPython is the implementation used in this book.
  
 NOTE 
  At the time of writing, there are two version streams of Python: versions 2.x and 
 3.x. This book focuses on version 3, and the code has been tested on several releases 
 within that stream—up to release 3.4. Where major compatibility issues arise with 2.x, 
 reference will be made to version 2.7. 
  
  Python programs are written in text fi les that customarily have the extension 
 .py
  . The Python 
 interpreter, called  
 python
  (in lowercase) does not actually care about the extension; it is only for the 
 user’s benefi t (and in some operating systems to allow the fi le and interpreter to be linked).
  
  You can also input Python code directly to the interpreter. This method makes for a highly 
 interactive development style where ideas are prototyped or tested in the interpreter and then 
 transferred into a code editor. The Python interpreter is a powerful learning tool when you are 
 starting to use a new concept or code module. 
  
  When working in this mode, you start the interpreter by typing 
 python
  at an operating system 
 command prompt. The system will respond with a message telling you the Python version and some 
 build details, followed by the interactive prompt at which you type code. It looks like this: 
  
  ActivePython 3.3.2.0 (ActiveState Software Inc.) based on
  
  Python 3.3.2 (default, Sep 16 2013, 23:10:06) [MSC v.1600 32 bit (Intel)] on 
 win  32 
  
  Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
  
  >>> 
  
  This message says that this interpreter is for version 3.3.2.0 of Python, it is the ActiveState distribution 
 (as opposed to the 
 python.org
  distribution), and it was built for 32‐bit Windows. Your message may 
 differ slightly, but should contain the same types of information. 
  
  If instead of running the Python interpreter interactively you want to execute a program stored in a 
 fi le, then at the operating system prompt you simply append the name of the fi le after the  
 python 
 command: 
  
 $ python myscript.py
  
 www.it-ebooks.info",NA
 REVIEWING THE PYTHON DATA TYPES,"Python supports many powerful data types. Superfi cially, these look like their counterparts in other 
 programming languages, but in Python they often come with super powers. Everything in Python is an 
 object and, therefore, has methods. This means that you can perform a host of operations on any 
 variable. The built‐in 
 dir()
  and 
 help()
  functions will reveal all. In this section you look at the standard 
 data types and their most important operations. 
  
 TIP 
  The Python Reference Manual ( 
 http://docs.python.org/3.3/ 
 reference/
  ) provides the full detail should you need it. 
  
  You need to be aware of some underlying concepts in Python. First, Python variables are just names. 
 You create variable names by assigning them to objects that are instances of types. Variables do not, of 
 themselves, have a type; it is the object to which they are bound that has a type. The name is just a label 
 and, as such, it can be reassigned to a completely different object. Assignment is performed using  
 =
  , so 
 assigning a value to a variable looks like this: 
  
  aVariable = aValue 
  
  This code binds the value  
 aValue
  to the variable name 
 aVariable
  and, if the name does not already 
 exist, the interpreter adds the name to the appropriate namespace. 
  
  The distinction between a variable and its underlying value (an object) is thus crucial in Python. You 
 can test variables for equality using a double equal sign (
 ==
  ) and object identity (that is, if two names 
 refer to the same object) is compared using the  
 is
  operator, as shown: 
  
 >>> aString = 'I love spam' 
  
 >>> anotherString = 'I love 
 spam'",NA
 Numeric Types: Integer and Float ,"Python supports several numeric types including the most basic forms: integer and fl oating 
 point.
  
  Python integers are unusual in that they are theoretically of infi nite size. In practice, integers are 
 limited by the size of your computer’s memory. Integers support all the usual numeric operations, 
 such as addition, subtraction, multiplication and so on. You perform arithmetic operations using 
 traditional infi x notation. For example, to add two integers, 
  
  >>> 5 + 4
  
  9 
  
  or: 
  
 >>> result = 12 + 
 8 
  
 >>> print (result)
  
  20 
  
  Literal integer values are, by default, expressed in decimal. You can use other bases by prefi xing the 
 number with a zero and the base’s initial. Thus, binary is represented as  
 0bnnn
  , octal as  
 0onnn
  , and 
 hexadecimal as 
 0xnnn
  . 
  
 www.it-ebooks.info",NA
 The Boolean Type ,"Python supports a Boolean type, 
 bool
  , with literal values  
 True
  and  
 False
  . The default value of a 
 bool
  is  
 False
  ; that is, 
 bool()
  yields  
 False
  . 
  
  Python also supports the concept of  
 truth‐like
  values for other types. For example, integers are 
 considered 
 False
  if their value is zero. Anything else is considered  
 True
  . The same applies to fl oat 
 values where 
 0.0
  is 
 False
  and anything else is 
 True
  . 
  
  You can convert Boolean values to integers using  
 int()
  , in which case  
 False
  is represented as 
 0
  and 
 True
  as 
 1
  .
  
  The Boolean type has most of the Boolean algebra operations you’d expect, including 
 and
  ,  
 or
  , and 
 not
  , but—surprisingly—not 
 xor
  . 
  
 NOTE 
  Booleans are implemented as a subclass of integer and so also support a bunch 
 of operations that you might not expect, such as exponentiation. You can type things 
 like  
 True**False
  and get a result of 1. You should basically just pretend these 
 “features” don’t exist and treat them as an implementation detail; otherwise, your code 
 will become very confusing. 
  
 www.it-ebooks.info",NA
 The None Type,"The  
 None
  type represents a null object. There is only one 
 None
  object in the Python environment, 
 and all references to 
 None
  use that same single instance. This means that equality tests with  
 None 
 are usually replaced by an identity test, like so,
  
  aVariable is None 
  
  rather than: 
  
  aVariable == None 
  
 None
  is the default return value of a Python function. It is also often used as a place marker or fl ag for 
 default parameters in functions.  
 None
  is not callable and so cannot be used as a conversion function 
 to convert other types to 
 None
  .  
 None
  is considered to have a Boolean value of 
 False
  .",NA
 Collection Types,"As already mentioned Python has several types representing different kinds of collections or 
 sequences. These are: strings, bytes, tuples, lists, dictionaries and sets. You will see the similarities and 
 differences in each as they are discussed in the following sections. A standard library module called 
 collections
  provides several other more specialized collection types. You will see occasional 
 references to these in the sections that follow. 
  
 NOTE 
  In many of the following discussions, you will see references to 
  
 operations accepting a collection type. Usually this includes what Python calls 
 iterables
  , which are objects that conform to Python’s iteration protocol. In simple 
 terms iterables are objects that you can use in loop constructs. In most cases you will 
 not need to worry about them, but they are described in the Python documentation if 
 you are interested in reading the technical details. A good place to start is:  
 https://wiki.python.org/moin/Iterator
  . 
  
  Several common features apply to all collections, and rather than bore you by repeating them for 
 each type, they are covered here.
  
  You can get the length of any collection in Python by using the built‐in  
 len()
  function. It takes a 
 collection object argument and returns the number of elements. 
  
  You can access the individual elements of a collection using indexing. You do this by providing an 
 index number (or a valid key value for dictionaries) inside square brackets. Collection indices start 
  
 www.it-ebooks.info",NA
 USING PYTHON CONTROL STRUCTURES,"In this section you fi rst look at the overall structure of a Python program and then consider each of 
 the basic structures: sequence, selection, and iteration. Finally, you look at how Python handles 
 errors, review context managers, and investigate how to exchange data with the outside world.",NA
 Structuring Your Program,"Python programs do not have any required, predefi ned entry point (for example a  
 main()
  function) 
 and are simply expressed as source code in a text fi le that is read and executed in order starting at the 
 top of the fi le. (Defi nitions, such as functions, are executed in the sense that the function is created and 
 assigned to a name, but the internal code is not executed until the function is called.)
  
  Python does not have any special syntax to indicate whether a source fi le is a program or a module 
 and, as you will see, a given fi le can be used in either role. A typical executable program fi le 
  
 www.it-ebooks.info",NA
" Using Sequences, Blocks and Comments","The most fundamental programming structure is a sequence of statements. Normally Python 
 statements occur on a line by themselves, so a sequence is simply a series of lines.
  
  x 
 = 
 2 
  
  y 
 = 
 7 
  
  z 
 = 
 9 
  
  In this case the statements are all assignments. Other valid statements include function calls, module 
 imports or defi nitions. Defi nitions include functions and classes. The various control structures 
 described in the following sections are also valid statements. 
  
 NOTE 
  Python does enable you to include multiple statements on a single line by 
 separating them with a semicolon. Thus the following line of code consists of three 
 statements: 
  
  x = 2; y = 7; z = 9
  
  This style is not recommended by the Python community; using separate lines is 
 preferred. 
  
  Python is a block‐structured language, and blocks of code are indicated by indentation level. The 
 amount of indentation is quite fl exible; although most Python programmers stick to using three",NA
 Selecting an Execution Path ,"Python supports a limited set of selection options. The most basic structure is the  
 if/elif/else 
 construct. The  
 elif
  and 
 else
  parts are optional. It looks like this: 
  
  if pages < 9: 
  
  
  print(""It's too short"") 
  
  elif pages > 99: 
  
  
  print(""It's too long"") 
  
  else: print(""Perfect"")
  
  Notice the colon at the end of each test expression. That is Python’s indicator that a new block of code 
 is coming up. It has no start and end block markers (such as  
 {}
  ); the colon is the only indication, and 
 the block must either occur on the same line as the colon, if it’s only a single line block, or as an 
 indented block of code. Many Python programmers prefer the indented block style even for single line 
 blocks.
  
  Also note that there can be an arbitrary number of  
 elif
  tests, but only a single  
 else
  clause—or 
 none at all.
  
  The other selection structure you will fi nd in Python is the conditional expression selector. This 
 produces one of several values depending on the given test conditions. It looks like this:
  
  <a value> if <an expression> else <another value>
  
  An example might be where a screen coordinate is being incremented until a certain limit (perhaps 
 the screen’s maximum resolution) and then reset to 
 0
  . That could be written as:
  
  coord = coord + increment if coord < limit else 0
  
  This is equivalent to the more traditional structure shown here:
  
  if coord < limit 
  
  
  coord += 
 increment
  
  else: 
  
  
  coord = 0
  
  You should use caution when using conditional expressions because it is very easy to create obscure 
 code. If in doubt you should use the expanded if/else form.",NA
 Iteration ,"Python offers several alternatives for iteration. The most fundamental and general is the 
 while
  loop. It 
 looks like this: 
  
  while 
 BooleanExpression:
  
  aBlockOfCode 
  
  else: 
  
  anotherBlock 
  
  Notice the colon ( 
 :
  ) at the end of the 
 while
  statement, which signifi es that a block of code follows.
  
 Also notice the indentation of the block. The block will, in principle, be executed for as long as 
 BooleanExpression
  remains true. However, there are two ways you can exit out of a  
 while
  loop 
 regardless of the  
 BooleanExpression
  value. These are the  
 break
  statement, which exits the loop 
 immediately, and a 
 return
  statement if the loop is inside a function defi nition. A  
 return
  statement 
 exits the function immediately and so will also exit any loop within the function. 
  
  The  
 else
  clause is optional and is rarely used in practice. It is executed any time the 
  
 BooleanExpression
  is  
 False
  , including when the loop exits normally. It will not be executed if the 
 loop is exited by a  
 break
  or  
 return
  statement.
  
  One very common 
 while
  loop idiom is to use 
 True
  as the test condition to create an infi nite loop and 
 then have a  
 break
  test within the body of the loop. Here is an example where the loop reads user 
 commands and processes them. If the command contains the letter  
 q
  , it exits. 
  
  while True:
  
  
  command = input('Enter a command[rwq]: 
 ')
  
  
  if 'q' in command.lower(): break
  
  
  if command.lower() == 'r': 
  
  
  
  # process 'r'
  
  
  elif command.lower() == 'w':
  
  
  
  # process 'w'
  
  
  else:
  
  print('Invalid command, try again') 
  
  There is a companion statement to 
 break
  , namely 
 continue
  . Whereas  
 break
  exits both the block 
 and the loop,  
 continue
  exits the block for the current loop iteration only. Control then returns to the  
 while
  statement and, if appropriate, a new iteration of the block will commence.",NA
 Handling Exceptions,"There are two approaches to detecting errors. The fi rst involves explicitly checking each action as it’s 
 performed; the other attempts the operations and relies on the system generating an error condition, 
 or  
 exception
  , if something goes wrong. Although the fi rst approach is appropriate in some situations, 
 in Python, it’s far more common to use the second. Python supports this technique with the 
 try/except/else/finally
  construct. In its general form, it looks like this:
  
  try: 
  
    
  A block of application code
  
  except <an error type> as 
 <anExceptionObject>:
  
  
  A block of error handling code
  
  else: 
  
  
  Another block of application code
  
  finally:
  
  
  A block of clean-up code 
  
  The  
 except
  ,  
 else
  , and 
 finally
  are all optional, although at least one of 
 except
  or  
 finally
  must 
 exist if a 
 try
  statement is used. There can be multiple 
 except
  clauses, but only one 
 else
  or  
 finally
 . 
  
 You can omit the 
 as…
   part of an 
 except
  statement line if the exception details are not required.
  
  The  
 try
  block is executed and, if an error is encountered, the exception class is tested. If an 
 except 
 statement exists for that type of error, the corresponding block is executed. (If multiple exception 
 blocks specify the same exception type, only the fi rst matching clause is executed.) If no matching 
 except
  statement is found, the exception is propagated upwards until the top‐level interpreter is 
 reached and Python generates its usual traceback error report. Note that an empty  
 except
  statement 
 will catch any error type; however, this is usually a bad idea because it hides the occurrence of any 
 unexpected errors.
  
  The  
 else
  block is executed if the 
 try
  block succeeds without any errors. In practice the 
 else
  is 
 rarely used. Regardless of whether an error is caught or propagated, or whether the  
 else
  clause is 
 executed, the 
 finally
  clause will always be executed, thus providing an opportunity to release any 
 computing resources in a locked state. This is true even when the  
 try/except
  clause is left via a 
 break
  or  
 return
  statement.
  
  You can use a single 
 except
  statement to process multiple exception types. You do this by listing the 
 exception classes in a tuple (parentheses are required). The optional exception object contains details of 
 where the exception occurred and provides a string conversion method so that a meaningful error 
 message may be provided by printing the object.
  
  It is possible to raise exceptions from your own code. It is also possible to use any of the existing 
 exception types or to defi ne your own by subclassing from the 
 Exception
  class. You can also pass 
 arguments to exceptions you raise, and you can access these in the exception object in the  
 except 
 clause using the  
 args
  attribute of the error object. 
  
 www.it-ebooks.info",NA
 Managing Context,"Python has the concept of a runtime  
 context
  . This typically includes a temporary resource of some 
 kind that your program wants to interact with. A typical example might be an open fi le or a 
 concurrent thread of execution. To handle this Python uses the keyword 
 with
  and a  
 context manager
  
 protocol. This protocol enables you to defi ne your own context manager classes, but you will mostly 
 use the managers provided by Python.
  
  You use a context manager by invoking the 
 with
  statement:
  
  with open(filename, mode) as 
 contextName: 
  
  
  process file here
  
  The context manager ensures the fi le is closed after use. This is fairly typical of a context manager’s 
 role—to ensure that valuable resources are freed after use or that proper sharing precautions are taken 
 on fi rst use. Context managers often remove the need for a 
 try/finally
  construct. The 
 contextlib
  
 module provides support for building your own context managers.
  
  You have now seen the different types of data that Python can process as well as the control 
 structures you can use to do that processing. It is now time to fi nd out how to get data into and out of 
 your Python programs and that is the subject of the next section.",NA
 GETTING DATA IN AND OUT OF PYTHON ,"Basic input and output of data is a major requirement of any programming language. You need to 
 consider how your programs will interact with users and with data stored in fi les.",NA
 Interacting with Users ,"To send data to users via 
 stdout
  , you use the 
 print()
  function, which you’ve seen several times 
 already. You learn how to control the output more precisely in this section. To read data from users, 
 you use the 
 input()
  function, which prompts the user for input and then returns a string of raw 
 characters from  
 stdin
  . 
  
  The  
 print()
  function is more complex than it fi rst appears in that it has several optional 
 parameters. At its simplest level, you simply pass a string and  
 print()
  displays it on  
 stdout",NA
 Using Text Files ,"Text fi les are the workhorses of programming when it comes to saving data, and Python supports 
 several functions for dealing with text fi les.
  
 NOTE 
  The fi le interface in Python is really a specialization of a higher‐level abstract 
 interface starting with a class called 
 io.IOBase
  . You can mostly ignore these; they 
 simply create a standardized set of operations that applies to text fi les and other “fi 
 le like” objects.
  
  You saw the 
 open()
  function used in previous sections and it takes a fi lename and a mode as 
 arguments. The mode can be any of 
 r
  ,  
 w
  , 
 rw
  , and  
 a
  for read, write, read‐write, and append 
 respectively. (Some other modes are less often used. There are also a few optional parameters that 
 control how the data is interpreted, see the documentation for details.) The  
 r
  mode requires the fi le to 
 exist; the  
 w
  and 
 rw
  modes create a new empty fi le (or overwrite any existing fi le of the same name). 
 The 
 a
  mode opens an existing fi le or creates a new empty fi le if a fi le of the specifi ed fi lename does 
 not already exist. The fi le object returned is also a context manager and can be used in a 
 with
  block as 
 you saw in the context manager section. If a 
 with
  block is not used, you should explicitly close the fi le 
 using the 
 close()
  method when you are fi nished with it, thus ensuring that any data sitting in memory 
 buffers is sent to the physical fi le on disk. 
  
 The  
 with
  construct calls  
 close()
  automatically, which is one of the advantages of using the 
 context manager approach.
  
  Once you have an open fi le object, you can use  
 read()
  , 
 readlines()
  , or  
 readline()
  as required. 
 read()
  reads the entire fi le contents as a single string complete with embedded newline characters. 
 readlines()
  reads line by line into a list, and the newline characters are retained.  
 readline()
  reads 
 the next line in the fi le, again retaining the newline. The fi le object is an iterable, so you can use it 
  
 www.it-ebooks.info",NA
 EXTENDING PYTHON,"The simplest way of extending Python is by writing your own functions. You can defi ne these in the 
 same fi le as the code that uses them, or you can create a new module and import the functions from 
 there. You look at modules in the next section; for now you will create the functions and use them in the 
 same fi le. In fact, you will mostly be using the interactive prompt for the examples in this section. 
  
  The next step in creating new functionality in Python is to defi ne your own classes and create objects 
 from them. Again, it is common to create classes in modules, and you see how to do so in the next 
 section. The examples here are simple enough that you can just use the Python prompt.
  
  Python programmers frequently use documentation strings in their programs. Documentation 
 strings are string literals that are not assigned to a variable and respect the indentation level at which 
 they are defi ned. You use documentation strings to describe functions, classes, or modules. The  
 help()
  function reads and presents documentation strings.",NA
 Defi ning and Using Functions,"Several types of functions are available in Python. This section looks at the standard variety fi rst, 
 followed by a generator function, and concludes with the slightly enigmatic lambda function. 
  
  You defi ne functions in Python using the  
 def
  keyword. The form looks like this: 
  
  def functionName(parameter1, 
 param2,...): 
  
  function block 
  
  Python functions always return a value. You can specify an explicit return value using the  
 return 
 keyword; otherwise, Python returns  
 None
  by default. (If you fi nd unexpected  
 None
  values appearing 
 in your output, check that the function concerned has an explicit 
 return
  statement in its body.) You 
  
 www.it-ebooks.info",NA
 Defi ning and Using Classes and Objects,"Python supports object‐oriented programming using a traditional class‐based approach. Python 
 classes support multiple inheritance and operator overloading (but not method overloading), as well 
 as the usual mechanisms of encapsulation and message passing. Python classes do not directly 
 implement data hiding, although some naming conventions are used to provide a thin layer of privacy 
 for attributes and to suggest when attributes should not be used directly by clients. Class methods 
 and data are supported as well as the concepts of  
 properties
  and 
 slots
  . Classes have both a 
 constructor (  
 __new__ ()
 ) and an initializer (  
 __init__ ()
  ), as well as a destructor mechanism (  
 __del__ ()
 ), although the latter is not always guaranteed to be called. Classes act as namespaces for 
 the methods and data defi ned therein. 
  
  Objects are instances of classes. Instances can have their own attributes added after instantiation, 
 although this is not normal practice. 
  
  A class is defi ned using the 
 class
  keyword followed by the class name and a parenthesized list of 
 super‐classes. The class defi nition contains a set of class data and method defi nitions. A method defi 
 nition has as its fi rst parameter a reference to the calling instance, traditionally called  
 self
  . A 
 simple class defi nition looks like this: 
  
  class MyClass(object):
  
  
  instance_count = 0
  
  
  def __init__(self, value): 
  
  
  self.__value = value 
  
  
  
  
  MyClass.instance_count += 1
  
  
  print(""instance No {} created"".format(MyClass.instance_count))
  
  def aMethod(self, aValue): 
  
  
  
  
  self.__value *= aValue 
  
  
  def __str__(self):
  
  
  
  
  return ""A MyClass instance with value: "" + str(self.__value) 
  
  def __del__(self):
  
  
  
  
  MyClass.instance_count -= 1
  
  The class name traditionally starts with an uppercase letter. In Python 3 the super class is always 
 object
  unless specifi cally stated otherwise, so the use of  
 object
  as the super class in the preceding 
 example is actually redundant. The  
 instance _ count
  data item is a class attribute because it",NA
 CREATING AND USING MODULES AND PACKAGES,"Modules are fundamental to most programming environments intended for nontrivial programming 
 tasks. They allow programs to be broken up into manageable chunks and provide a mechanism for code 
 reuse across projects. In Python, modules are simply source fi les, ending in  
 .py
  and located 
 somewhere that Python can fi nd them. In practice, that means the fi le must be located in the current 
 working directory or a folder listed in the  
 sys.path
  variable. You can add your own folders to this 
 path by specifying them in the 
 PYTHONPATH
  environment variable for your system or dynamically at run 
 time.
  
  Although modules provide a useful way of packaging up small amounts of source code 
  
 for reuse, they are not entirely satisfactory for larger projects such as GUI frameworks or 
  
 mathematical function libraries. For these Python provides the concept of a  
 package
  . A package is 
 essentially a folder full of modules. The only requirement is that the folder should contain a fi le called 
 __ init __ .py
  , which may be empty. To the user a package looks a lot like a module, and the 
 submodules within the package look like module attributes.",NA
 Using and Creating Modules ,"You access modules using the 
 import
  keyword, which has many variations in Python. The most 
 common forms are shown here:
  
  import aModule 
  
  import aModule as anAlias 
  
  import firstModule, secondModule, 
 thirdModule...
  
  from aModule import anObject 
  
  from aModule import anObject as anAlias 
  
  from aModule import firstObject,secondObject, 
 thirdObject...
  
  from aModule import *
  
  The last form imports all the visible names from 
 aModule
  into the current namespace. (You learn how 
 to control visibility shortly.) This carries a signifi cant risk of creating naming confl icts with built‐in 
 names or names you have defi ned, or will defi ne, locally. It is therefore recommended that you use 
 only the last import form for testing modules at the Python prompt. The small amount of extra typing 
 involved in using the other forms is a small price to pay compared to the confusion that can result from 
 a name clash. The other  
 from...
  forms are much safer because you only import specifi ed names and, 
 if necessary, rename them with an alias. This makes clashes with other local names much less likely. 
  
  Once you import a module using any of the fi rst three forms, you can access its contents by prefi xing 
 the required name with the module name (or alias) using dot notation. You have already seen 
 examples of that in the previous sections; for example, 
 sys.path
  is an attribute of the  
 sys 
 module. 
  
  Having said that modules are simply source fi les, in practice, you should observe some do’s and 
 don’ts when creating modules. You should avoid top‐level code that will be run when the module is 
 imported, except, possibly, for some initialization of variables that may depend on the local 
 environment. This means that the code you want to reuse should be packaged as a function or a 
 class. It’s also common to provide a test function that exercises all the functions and classes in the 
 module. Module names are also traditionally lowercase only.",NA
Using and Creating Packages,"You discovered at the start of this section that a Python package is just a folder with a fi le called 
 __ 
 init __ .py
  . All other Python fi les within that folder are the modules of the package. Python 
 considers packages as just another type of module, which means that Python packages can contain 
 other packages within them to an arbitrary depth—provided each subpackage also has its own 
 __ 
 init __ .py
  fi le, it is a valid package.
  
 NOTE 
  Having just said that a package was defi ned by having an  
 __ init __ .py
 , 
 this is not strictly true. The real defi ning feature of a package is that it has a 
 __ path 
 __
  attribute. However, in practice, you don’t need to provide that because Python does 
 it for you. So, if you create an 
 __ init __ .py
  , all will be well.
  
 The  
 __ init __ .py
  fi le itself is not particularly special; it is just another Python fi le, and it 
 will be loaded when you import the package. This means that the fi le can be empty, in which case 
 importing the package simply gives access to the included modules, or it can have Python code 
  
 www.it-ebooks.info",NA
 CREATING AN EXAMPLE PACKAGE,"You’ve read the theory; now it’s time to put it into practice. In this section you create a couple of 
 modules and bundle them as a package. You utilize the bitwise logical operators mentioned in “The 
 Boolean Type” section. The intention is to provide a functional interface to those operators and extend 
 their scope to include testing of individual bit values. In doing this you also see several of the Python 
 core language features that were discussed previously. The modules you develop are not optimized for 
 performance, but are designed to illustrate the concepts. However, it would not be diffi cult to refi ne 
 them into genuinely useful tools.
  
  TRY IT OUT 
 Creating a Module (bits.py) 
  
  In this Try It Out, you start out by creating a simple, conventional module based on integer inputs. You 
 then create another module that defi nes a class that can be used to represent a piece of binary data and 
 expose the bitwise functions as methods. Finally, you create a package containing both modules.
  
  1.
  
  2.
  
  Create a new folder called  
 bitwise
  . This eventually becomes your package.
  
  In that folder create a Python script called  
 bits.py
  containing the following code (or load it from 
 the book’s downloadable fi lenamed  
 bits.py
  ): 
  
  #! /bin/env python3
  
  ''' Functional wrapper around the bitwise 
 operators. 
  
  Designed to make their use more intuitive to users 
 not  familiar with the underlying C operators. 
  
  Extends the functionality with bitmask read/set operations.
  
  The inputs are integer values and
  
  return types are 16 bit integers or 
 boolean. 
  
  bit indexes are zero based 
  
  Functions implemented are: 
  
  
  NOT(int)           -> int 
  
  
  AND(int, int)      -> int 
  
  
  OR(int,int)        -> int 
  
  
  XOR(int, int)      -> int 
  
  
  shiftleft(int, num)  -> int
  
  
  shiftright(int, num) -> int
  
  
  bit(int,index)     -> bool 
  
  
  setbit(int, index) -> int 
  
  
  zerobit(int,index) -> int 
  
  
   
  listbits(int,num) -> 
 [int,int...,int]
  
  ''' 
  
  def NOT(value): 
  
  
  return ~value",NA
USING THIRD‐PARTY PACKAGES,"Many third‐party packages are available for Python. Binary distributions of many of these packages, 
 complete with installer programs, are available for most common operating systems. If a binary 
 installer is available, either on the package website or, for Linux users, in your package management 
 tool, you should use it because it will be the simplest way of getting things up and running. If a 
 binary package is not available, you need to download and install the base package. 
  
 You can fi nd many of these third‐party packages in the Python Package Index (PyPI) at 
 https:// 
 pypi.python.org/pypi
  . They are distributed in a special format that itself requires the installation of 
 a third‐party package! This chicken‐and‐egg situation often confuses beginners, so this section 
 describes how to set up your environment such that you can access these third‐party packages. 
  
 PyPI packages come in the form of something called an 
 egg
  . A Python egg is capable of delivering either 
 a standard Python package or a binary package written in C, or a mix of Python and C code. 
  
  THE FUTURE OF PYTHON PACKAGING 
  
  
  The egg format has some issues and is itself being replaced by something called a
  
  
 wheel
  . This is all part of a wider strategy to rationalize the multiple methods of 
  
  
 distributing Python packages and applications. The Python Package Authority is
  
  
 leading this project. Eventually, all the tools needed to both build and install Python",NA
 SUMMARY ,"In this chapter you reviewed the core language features of Python. You looked at the interpreter 
 environment, the core data types, and the language control structures and syntax. You also 
 considered how Python can be extended by writing functions, classes, modules, and packages.",NA
 2 ,"WHAT YOU WILL LEARN IN THIS CHAPTER: 
  
 ➤
  
  Accessing and managing computer resources via the operating 
  
 system 
  
 ➤
  
  Handling common fi le formats such as CSV and XML 
  
 ➤
  
  Working with dates and times 
  
 ➤
  
  Automating applications and accessing their APIs 
  
 ➤
  
  Using third‐party modules to extend automation beyond the 
  
 standard library capabilities 
  
  WROX.COM DOWNLOADS FOR THIS CHAPTER 
  
  For this chapter the wrox.com code downloads are found at  
 www.wrox.com/go/ 
  
 pythonprojects
  on the Download Code tab. The code is in the Chapter  2 download, called 
 Chapter2.zip,
  and individually named according to the names throughout the chapter.
  
  Often, you may fi nd yourself undertaking tasks that involve many repetitive operations. 
  
 To combat this repetition of work, it may be possible to write a macro to automate those 
 operations within a single application but, if the operations span several applications, macros 
 are rarely effective. For example, if you back up and archive a large multimedia web application, 
 you may have to deal with content produced by one or more media tools, code from an IDE, and 
 probably some database fi les, too. Instead of macros, you need an external programming tool to 
 drive each application, or utility, to perform its part of the whole. Python is well suited to this 
 kind of orchestration role. 
  
 www.it-ebooks.info",NA
ACCESSING THE OPERATING SYSTEM ,"Most of the tasks that a typical programmer needs to undertake using the operating system—for 
 example, collecting user information or navigating the fi le system—can be done in a generic way using 
 Python’s standard library of modules. (Recall that modules are reusable pieces of code that can be 
 shared across multiple programs.) The key modules have been written in such a way that the 
 peculiarities of individual operating system behaviors have been hidden behind a higher level set of 
 objects and operations. The modules that you consider in this section are:  
 os/path
  , 
 pwd
  , 
 glob
  , 
 shutil
  , 
 and 
 subprocess
  . The material here focuses on how to use these modules in common scenarios; it does 
 not try to cover every possible permutation or available option.",NA
 Obtaining Information About Users and Their Computer,"One of the fi rst things you can do when exploring the OS modules is to fi nd out what they can tell 
 you about users. Specifi cally, you can fi nd out the user’s ID, login name, and some of his default 
 settings.
  
  Like most new things in Python, the best way to get familiar is via the interactive prompt, so fi re up the 
 Python interpreter and try it out. 
  
  TRY IT OUT 
 Identifying the User 
  
  In this Try It Out, you fi nd out some information about the current user. To do so, follow these steps:
  
  1.
  
  Start the Python interpreter.
  
 www.it-ebooks.info",NA
 Obtaining Information About the Current Process,"It can be useful for a program to know something about its current status and runtime environment. 
 For example, you might want to know the process identity or if the process has a preferred folder in 
 which to write its data fi les or read confi guration data. The OS modules provide functions for 
 determining these values.
  
  One such source of process information is the process environment, as defi ned by environment 
 variables. The 
 os
  module provides a dictionary called 
 os.environ
  that holds all the environment 
 variables for the current process. 
  
 NOTE 
  The number of variables on any given system depends on all sorts of local 
 considerations, including the number and nature of the applications installed, 
 because many applications create their own environment values during 
 installation. 
  
  The disadvantage of environment variables is that they are highly volatile. Users can create them and 
 remove them. Applications can do likewise, so it is dangerous to rely on the existence of an 
 environment variable; you should always have a default value that you can fall back on. Fortunately, 
 some values are fairly reliable and usually present. Three of these are particularly useful for Windows 
 users because the  
 pwd.getpwuid()
  and  
 os.uname()
  functions discussed earlier are not available. 
 These are 
 HOME
 ,  
 OS
 , and  
 PROCESSOR _ ARCHITECTURE
  . 
  
  If you do try to access a variable that is not defi ned, you get the usual Python dictionary 
 KeyError
  . 
 On most, but not all, operating systems, a program can set, or modify, environment variables. If this 
 feature is supported for your OS, then Python refl ects any changes to the 
 os.environ
  dictionary back 
 into the OS environment. In addition to using environment variables as a source of user information, 
 it is quite common to use them to defi ne user‐specifi c confi guration details about a program—for 
 example, the location of a database. This practice is slightly frowned upon nowadays, and it’s 
 considered better to use a confi guration fi le for such details. But if you are working with older 
 applications, you may need to refer to the environment for such things.
  
 www.it-ebooks.info",NA
 Managing Other Programs ,"It is often useful to be able to run other programs from within a script, and the  
 subprocess
  module is 
 the preferred tool for this. The  
 subprocess
  module contains a class called 
 Popen
  that provides a very 
 powerful and fl exible interface to external programs. The module also has several convenience 
 functions that you can use when a simpler approach is preferred. The documentation describes how to 
 use all of these features; in this section you use only the simplest function, 
 subprocess.call()
  , and 
 the 
 Popen
  class. 
  
 NOTE 
  Historically, Python has had several ways to run subprocesses. This has led 
 to considerable confusion and a proliferation of options. Most of these mechanisms 
 are still available so as not to break old code, but you are strongly advised to use 
 the 
 subprocess
  module discussed here for any new code you write.
  
  The most basic use of the  
 subprocess
  module is to call an external OS command and simply allow it 
 to run its course. The output is usually displayed on screen or stored in a data fi le somewhere. After 
 the program completes, you can ask the user to make some kind of selection based on what was 
 displayed or you can access the data fi le directly from your code. You can force many OS tools, 
 especially on UNIX‐based systems, into producing a data fi le as output by providing suitable 
 command‐line options or by using OS fi le redirection. This technique is a very powerful way to 
 harness the power of OS utilities in a way that Python can use for further processing. 
  
  This basic mechanism for calling a program is wrapped up in the  
 subprocess.call()
  function. This 
 function has a list of strings as its fi rst parameter, followed by several optional keyword parameters 
 that are used to control the input and output locations and a few other things.
  
  The easiest way to see how it works is to try it out.
  
 www.it-ebooks.info",NA
 Managing Subprocesses More Effectively ,"You can use the 
 Popen
  class to create an instance of a process, or command. Unfortunately, the 
 documentation can appear rather daunting because the  
 Popen
  constructor has quite a few parameters. 
 The good news is that nearly all of those parameters have useful default values and can be ignored in 
 the simplest cases. Thus, to simply run an OS command from within a script, you only need to do this 
 (Windows users should substitute the  
 dir
  command from the previous example):
  
  >>> 
 import subprocess as sub
  
  >>> 
 sub.Popen(['ls', '*.*'], 
 shell=True) 
  
  <subprocess.Popen object at 0x7fd3edec> 
  
  >>> book  tmp 
  
  Notice the 
 shell=True
  argument. This is necessary to get the command interpreted by the OS 
 command processor, or 
 shell
  . Doing so ensures that the wildcard characters ( 
 '*.*'
  ) as well as any 
 string quotes and the like are all interpreted the way you expect. If you do not use the 
 shell 
 parameter, this happens:
  
  >>> 
 sub.Popen(['ls', '*.*']) 
  
  <subprocess.Popen object at 0x7fcd328c> 
  
  >>> ls: cannot access *.*: No such file or 
 directory 
  
  Without specifying 
 shell=True
  , the operating system tries to fi nd a fi le with the literal name 
 '*.*'
  , which doesn’t exist.
  
  The problem with using 
 shell=True
  is that it also creates security issues in the form of a potential 
 injection attack, so never use this if the commands are formulated from dynamically created strings, 
 such as those read from a fi le or from a user.
  
 NOTE 
  An injection attack is where a malicious (or very slapdash) user types an input 
 string that is read and interpreted by your program but, rather than containing 
 harmless data, it contains potentially harmful commands, possibly resulting in 
 deletion of fi les or worse. The 
 shlex
  module contains a 
 quote() 
 function that can 
 mitigate the risks, but care should still be exercised when running dynamically 
 generated strings.
  
  To access the output of the command being run, you can add a couple of extra features to the call, like 
 so:
  
  >>> 
 lsout = sub.Popen(['ls', '*.*'], shell=True, 
 stdout=sub.PIPE).stdout 
  >>> for line in lsout: 
  
 ...
     print (line) 
  
  Here you specify that 
 stdout
  should be a 
 sub.PIPE
  and then assign the  
 stdout
  attribute of the 
 Popen
  instance to  
 lsout
  . (A 
 pipe
  is just a data connection to another process, in this case between",NA
 Obtaining Information About Files (and Devices),"The os module is heavily biased to the UNIX way of doing things. As such it treats devices and fi les 
 similarly. So fi nding out about devices such as the current terminal session looks a lot like fi nding out 
 about fi les. In this section you now look at how you can determine fi le status and permissions and 
 even how to change some of their properties from within your programs. Consider the following code: 
  
  >>> import os 
  
  >>> 
 os.listdir('.')",NA
 Navigating and Manipulating the File system,"Python provides built‐in functions for opening, reading, and writing individual fi les. The os module 
 adds functions to manipulate fi les as complete entities—for example, renaming, deleting, and creating 
 links are all catered for. However, the 
 os
  module itself provides only half of the story when it comes to 
 working with fi les. You look at the other half when you explore the  
 shutil
  module and other utility 
 modules that work alongside 
 os
  . 
  
 NOTE 
  In Python 3.4 a new module was introduced called 
 pathlib
  , which aims to 
 provide an object‐oriented view of the fi le system. This potentially replaces much of 
 that functionality discussed in this section. However, 
 pathlib 
 is marked as 
 provisional, which means that the interfaces could change 
  
 signifi cantly in future releases or the module could even be removed from the library. 
 Because of this uncertainty, 
 pathlib
  is not used here. 
  
 www.it-ebooks.info",NA
 Plumbing the Directory Tree Depths ,"One common automation operation is to start at a given location and apply a particular action to 
 every fi le (or type of fi le) in the fi le system below that location. This is often called “walking the 
 directory tree,” and the os module contains a powerful and fl exible function called 
 os.walk()
  that 
 helps you do just that. It is not the most straightforward function to use, so you spend this section 
 looking at its key features.
  
  You consider an example of  
 os.walk()
  being used to fi nd a specifi c fi le located somewhere 
 within a given directory tree or subtree. You then create a new module with a 
 findfile()
  function 
 that you can use in your programs. That foundation can go on to form the basis for a whole group of 
 functions that you can use to process directory trees.
  
  First you need to create a test environment consisting of a hierarchy of folders under a root 
 directory. (You can generate this structure by extracting the fi le  
 TreeRoot.zip
  from the  
 Chapter2.zip
  master fi le on the download site and then extracting the fi les within 
 TreeRoot.zip
  , or you can use the OS tools to generate it manually.) Each folder contains some fi 
 les, and one of the folders contains the fi le you want to fi nd, namely 
 target.txt
  . You can see 
 this structure here:
  
  TreeRoot
  
  
  
  FA.txt 
  
  
  FB.txt 
  
  
  D1
  
  
  
  FC.txt 
  
  
   
  D1-1 
  
  
   
   
  FF.txt
  
  
  
  D2
  
  
   
  FD.txt 
  
  
  D3
  
  
   
  FE.txt 
  
  
  
  D3-1 
  
  
   
   
  target.txt
  
  The  
 os.walk()
  function takes a starting point as an argument and returns a generator yielding tuples 
 with 3 members (sometimes called a 
 3‐tuple
  or  
 triplet
 ): the root, a list of directories in the current root, 
 and a list of the current fi les in that root. If you look at the hierarchy you have created, you would 
 expect the top‐level tuple to look like this:
  
  ( 'TreeRoot', ['D1','D2','D3'], ['FA.txt','FB.txt']) 
  
  You can check that easily by writing a 
 for
  loop at the interactive prompt: 
  
  >>> 
 import os 
  
  >>> 
 for t in 
 os.walk('TreeRoot'): 
  
 ...print (t) 
  
 ...
  
  ('TreeRoot', ['D1', 'D2', 'D3'], ['FA.txt', 
 'FB.txt'])  ('TreeRoot/D1', ['D1-1'], ['FC.txt'])
  
  ('TreeRoot/D1/D1-1', [], ['FF.txt'])
  
  ('TreeRoot/D2', [], ['FD.txt'])
  
  ('TreeRoot/D3', ['D3-1'], ['FE.txt'])
  
  ('TreeRoot/D3/D3-1', [], ['target.txt'])",NA
 WORKING WITH DATES AND TIMES ,"One of the most common features of scripting tasks is the use of dates and times. This could be to 
 identify fi les older than a certain date or between a certain range or it might be to set a process to 
 run at a certain time or interval. You might need to compare dates and times in data to select an 
 appropriate subset of a fi le’s content. Reading dates and times and comparing their values is 
 necessary in many scenarios. 
  
  Unfortunately, dates and times are not clearly defi ned values like integers or fl oats. They tend to be 
 stored in strings with a multitude of formats. For example 2016‐02‐07, 02/07/2016, and 07/02/2016 
 are all possible representations for the 7th day in February, 2016. The situation is further 
  
 complicated by the possibility of rendering months and days using name abbreviations such as Jan, Feb, 
 or Mon, Tue, and so on. Add the fact that years may be abbreviated to two digits and the separators can 
 be any of a number of characters, and you start to see the complexity. How can you reliably read a date 
 value from a given string? Time values are almost as complex, especially if you have to consider time 
 zones and daylight saving rules. Fortunately, Python offers several modules to help you do just that. 
 The most basic is the  
 time
  module, augmented by the 
 datetime
  module and, for some tasks, the 
 calendar
  module.",NA
 Using the time Module ,"The  
 time
  module stores times (including dates) in two different formats. The fi rst is the number of 
 seconds since the  
 epoch
  , which is simply a fi xed date in history. For UNIX‐based systems that’s 1st 
 January 1970. (Did you notice that’s yet another date representation?) The other representation is as 
 a tuple of fi elds representing the various parts of a date/time: year, month, day, hour, minute, second, 
 and so on. The details are all found in the 
 time
  module documentation, but you need to remember 
 which underlying format you are using. The time modules contain various conversion functions to 
 switch between them.
  
  Two very important functions for reading and writing times as strings take into account most of the 
 issues just discussed. These functions are called 
 strptime()
  (the “p” stands for parse) and 
 strftime()
  (the “f” stands for format). The secret to using these functions lies in a format string. This 
 string tells the function how to map string values to/from time values. The format string uses  
 % 
 markers to indicate a fi eld and a set of character codes to indicate what the fi eld should contain. For 
 example, 
 %Y
  indicates a four‐digit year whereas 
 %y
  indicates a two‐digit year. 
 %m
  indicates a two‐digit 
 month, and 
 %B
  indicates the full month name (taking into account the local language settings). A table in 
 the 
 time
  module documentation for  
 strftime()
  provides the defi nitive list.
  
 NOTE 
  One quirk of the time string functions of which you should be aware is that the 
 strftime()
  function takes the format string as its fi rst argument and the tuple to 
 convert as its second. The 
 strptime()
  function takes the input string as its fi rst 
 argument and the format string as its second. 
  
  The easiest way to come to grips with these functions is to play with them at the Python prompt. 
 You can try it out now. 
  
 www.it-ebooks.info",NA
 Introducing the datetime Module,"The  
 datetime
  module includes several objects and methods that represent both absolute dates and 
 times as well as relative dates and times. Relative values are used for computing differences between 
 times and avoid you having to do messy calculations on second-based values, dividing by 60 and 24, 
 and so on. Some overlap exists between the 
 time
  functions and the 
 datetime
  objects. In general, if you 
 are doing comparisons or time‐based calculations, you should use the 
 datetime
  module rather than  
 time
  . If you are using both in the same code, use the most basic  
 import
  style to ensure no name 
 collisions occur. 
  
  The main classes exposed by the 
 datetime
  module are  
 date
  ,  
 time
  , and 
 datetime
  , whose names are 
 indicative of their scope. 
 datetime
  and  
 time
  objects can have a  
 timezone
  attribute set to a 
 timezone
  
 object to take account of time zone effects. If you have complex time processing to do, you may need to 
 subclass the 
 timezone
  class to provide any non‐trivial algorithms required. In this book you only use 
 the basic objects from the module. The other, and perhaps most useful, object type exposed is the 
 timedelta
  class, which handles time durations such as the result of a time computation or a relative 
 period such as a year or a month. The 
 datetime
  module supports many time‐based calculations using 
 timedelta
  objects, including addition, subtraction, multiplication of a delta by a number, and even 
 various forms of division. 
  
  You can initialize the 
 date
  object by passing year, month, and day values, all of which are mandatory. 
 You can initialize the  
 time
  object passing hour, minute, and second values, all of which are optional 
 and default to zero. The 
 datetime 
  object, you will not be surprised to learn, uses the full gamut of 
 year, month, day, hour, minute, and second. Some helpful class methods return instances based on 
 object arguments. An example is the 
 date.today()
  method that returns today’s date or the  
 date.fromtimestamp()
  method that takes a time value in seconds as its argument. Various 
 attributes and methods exist for extracting data about the 
 date
  after it has been created. 
  
 The  
 date
  class includes a 
 strftime()
  method similar to the one in the time module (but has no 
 corresponding  
 strptime()
  ; for that, you must look to the 
 datetime
  object).
  
  The  
 time
  object is conceptually similar but, as mentioned earlier, includes the capability to take 
 account of time zone data including daylight savings information. 
 time
  objects, like 
 date
  objects, 
 support a  
 strftime()
  method only.
  
 datetime
  objects are a combination of both 
 date
  and 
 time
  objects and support a combination of 
 both objects’ methods. 
 datetime
  also adds a few extra methods of its own, including a  
 now()
  class 
 method for initialization to the current date and time, and 
 combine()
  class method that takes  
 date 
 and 
 time
  objects as arguments and returns a combined  
 datetime
  object with the same values. You 
 can do basic arithmetic using a combination of 
 datetime
  and  
 timedelta
  objects, the latter being 
 either an argument or result as appropriate.  
 datetime
  objects also support both  
 strftime()
  and 
 strptime()
  methods, which work in the same way as those in the 
 time
  module described earlier.
  
  You use the 
 datetime
  objects as part of a larger example in the Try It Out “Parsing XML with 
 ElementTree” later in the chapter. 
  
 www.it-ebooks.info",NA
 Introducing the   calendar  Module,"The  
 calendar
  module is the simplest of the time‐based modules in Python’s standard library. 
 Essentially, it generates a calendar for a given year. The calendar is a 
 calendar.Calendar
  class 
 instance that has several support methods that allow you to, for example, iterate over the days in a 
 given month or produce various formatted text strings that can be useful in presenting user 
 messages in a script. Calendars can be formatted as plaintext or in HTML.
  
 calendar
  is probably the least used of the three modules discussed, but it has some useful features that 
 are not available elsewhere and would be time consuming to reproduce. Among these are some utility 
 functions such as  
 isleap()
  , which reports whether or not the specifi ed year is a leap year, and 
 timegm()
  , which converts a 
 time.gmtime()
  tuple into seconds (why it is located in the  
 calendar 
 module instead of  
 time
  is something of a mystery). 
  
  Finally, a couple of printing functions, 
 prcal()
  and 
 prmonth()
  , take a year and a year/month 
 combination, respectively, as arguments and display their output on  
 stdout
  . These can be useful 
 when you want to prompt your user to choose a date. 
  
  There are some third‐party modules available that try to simplify date and time handling in Python 
 by combining all the functions from all of the standard modules into a single more user‐friendly 
 module. Some examples include 
 arrow
  and  
 delorean
  , but an Internet search will reveal several 
 others.
  
  In the next section, you see how Python assists in reading and writing several common data fi le 
 formats.",NA
 HANDLING COMMON FILE FORMATS ,"When writing scripts to control several applications or utilities, it’s common to use fi les as the data 
 transfer mechanism between applications. Unfortunately the output format of one application may not 
 be in exactly the right format for the next application to read. At this point the script itself must convert 
 the output fi le into the appropriate form for the next application to read. Most applications produce 
 and consume variants of a few standard formats such as CSV (comma‐separated values), HTML 
 (HyperText Markup Language), XML (eXtended Markup Language), Windows INI (named after the fi le 
 extension) and, more recently, JSON (JavaScript Object Notation). You now look at how Python’s 
 standard library supports these various formats. (JSON is covered in Chapter  5  ,“Python on the Web,” 
 because it is most commonly associated with web applications.) These modules make it easier to read 
 and write data than if you tried to do it using the standard Python text‐processing tools such as string 
 methods or regular expressions.",NA
 Using Comma‐Separated Values,"The comma‐separated value (CSV) format has been around for many years. Its name is something of a 
 misnomer because, though commas are the most common separator, the term CSV is often applied to fi 
 les using tabs or pipes ( 
 |
  ) or, indeed, just about any other kind of character, as a separator. 
  
 At fi rst glance it might seem easy to parse data from such a fi le using the built‐in string  
 split() 
 method. The problem is that the format is not absolutely standardized, and different fi les have 
 different ways of representing fi elds that contain the separator within them. Also, lines of data can 
  
 www.it-ebooks.info",NA
 Working with Confi g Files ,"Confi g fi les or, as they are often called, Windows “INI” fi les, have a very readable format that is also 
 easy to work with programmatically. They have fallen out of favor in recent years because Microsoft 
 now advocates the Windows Registry and non‐Microsoft applications are moving to XML‐based storage. 
 However, there are plenty of legacy applications around that use this format. (A search for 
 *.ini
  on a 
 relatively clean installation of Windows 8.1 found several hundred fi les, so it is far from dead!)
  
  The format is very good at storing multiple instances of similar data, such as per‐node settings on a 
 network, or for multiple categories of options, such as various screen sizes, or online versus offl ine 
 operational parameters. The disadvantage of the Confi g format is that it can sometimes be too 
 simple with the result that complex data is harder to fi t into the format. Python provides the 
 configparser
  module for reading and writing Confi g format data. 
  
 NOTE 
  The  
 configparser
  module is one that has had a name change for Python 
 version 3. In Python 2 it was known as 
 ConfigParser
  (capitalized), but in Python 3, 
 it is now all lowercase: 
 configparser
  . If you are working across Python versions, be 
 aware of the name change. The functionality remains the same.
  
  The basic structure of a Confi g fi le is as shown here: 
  
  [DEFAULT]
  
  
 Option1=value1 
  
  [SECTION1]
  
  
 Option2=value2 
  
  
 Option3=value3 
  
  [SECTION2]
  
  
 Option4=value4 
  
  etc. 
  
  The  
 DEFAULT
  section is noteworthy because options defi ned there apply to all following sections. 
 The format has a lot of fl exibility, with spaces and indentation optional, embedded sections, and 
 various other variants, including the ability to interpolate a value from one option into another",NA
 Working with XML and HTML fi les,"You are probably familiar with HTML as the language of web pages. XML is also widely used, as a so‐
 called self‐describing data format. XML and HTML are closely related formats. XML is a much more 
 rigidly defi ned format, and that makes it easier to process using a computer. HTML is very forgiving of 
 malformed content and, although that makes it easy to create by hand, as well as with specialized 
 editors, HTML is much more hit or miss to process accurately. HTML also has many variations because 
 of web browser proprietary extensions. All of this means that HTML parsers have a trickier job and 
 often yield less than perfect results when faced with badly formatted fi les. Because XML is easier to 
 handle programmatically, you look at parsing it fi rst and then extend the technique to cover HTML.
  
 NOTE 
  A form of HTML, known as XHTML, is also valid XML. XHTML is starting to 
 appear on websites as increasing numbers of web publishing tools support it. This 
 means that you can use XML parsers to parse XHTML as well as other forms of XML. 
 However, HTML5 has, in effect, deprecated XHTML, so its use in the future is likely to 
 diminish rather than increase. 
  
  Parsing XML Files
  
  Many different parsers are available for parsing XML. The Python standard library contains no less 
 than fi ve (
 dom
  ,  
 minidom
  , 
 expat
  , 
 ElementTree
  , and 
 sax
  ). These all fall into two categories: those 
 that read the entire fi le into a tree‐like data structure called a document object model (DOM) or those 
 that read the fi le looking for items of interest (an “event”) and triggering a response as the items are 
 found. The former are more fl exible for complex, or multiple, queries on the same set of data. The latter 
 tend to be faster and slightly simpler to use. In this book you only look at two of the parsers, each 
 representing one of these two approaches.
  
  The fi rst parser you consider is 
 sax
  , which is an example of an event‐based parser. To 
 understand how event‐based parsers work, consider the following example that parses some 
 plaintext: 
  
  >>> 
 text = """"""mary had a little 
 lamb 
  
  ... 
 its fleece was white as snow 
  
  ... 
 and everywhere that mary went 
  
  ... 
 the lamb was sure to go"""""" 
  
  >>> 
 def has_mary(aLine): 
  
  ...   
 print( ""We found: "", aLine) 
  
  ... 
  
 www.it-ebooks.info",NA
ACCESSING NATIVE APIS WITH ctypes AND pywin32,"Some applications or OS functions are not easily accessed from regular Python code because no 
 Python API exists or no user‐friendly operations are exposed that you can call from Python. The 
 ctypes
  module can provide an alternative means of access by exposing to Python the C code 
 libraries from which the application is built. In Windows these libraries are typically a set of DLL",NA
Accessing the Operating System Libraries,"One area that is usually well documented is the OS application programming interface (API) that is 
 exposed in standard system libraries. In this section you use the OS libraries to perform some fairly 
 simple tasks that are nonetheless not available via Python’s 
 os
  module. This method is particularly 
 useful for Windows users because many of the UNIX‐like features in the 
 os
  module do not work, or 
 only work partially, under Windows. Accessing the Win32 API directly via 
 ctypes
  (or 
  pywin32
  ) is 
 often the only option. 
  
 NOTE 
 ctypes
  does not work with static libraries nor does it work with C++ 
 libraries, unless the functions have been explicitly exported as C functions from the 
 C++ code. 
  
 The following sections show  
 ctypes
  being used on Windows and Linux systems, but the principles 
 are identical, apart from getting the initial reference to the C library.",NA
 Accessing a Windows Application Using COM ,"Accessing an application library is almost as easy as accessing an OS system library, provided you can 
 get documentation for the contents of the library. However, that is not always readily available. Another 
 option on Windows is to use the OS functions to access the COM objects and then manipulate the COM 
 objects from Python. Unfortunately, COM is a complex technology and has been extended over time to 
 include features such as distribution over a network as well as various data access mechanisms. 
 Compounding the diffi culty is the fact that documentation for COM objects is often sparse and hard to fi 
 nd. Nonetheless, COM is often the most effective option for automating Windows applications.
  
  The easiest way to use COM objects in Python is to use the  
 pywin32
  package, written by Mark 
 Hammond and available for download from the SourceForge website or included as standard in the 
 ActiveState distribution of Python. The following Try It Out demonstrates the use of 
 pywin32
  to open 
 Excel preloaded with the  
 toolhire.xlsx
  fi le you used in the earlier sections of this chapter.
  
  TRY IT OUT 
 Using COM to Present a File‐Open Dialog (toolhireCOM.py) 
  
  This Try It Out demonstrates how to use the Excel COM interface to open the application and let the user 
 select a fi le—all from within Python. If you are using Windows, follow along with these steps (this example 
 works under Windows only):",NA
 AUTOMATING TASKS INVOLVING MULTIPLE APPLICATIONS,"Scripting was defi ned at the start of this chapter as “coordinating the actions of other programs or 
 applications to perform a task.” So far, you have seen several enabling modules that can help you to 
 interface with these external programs, but the bigger picture of how to automate a full workfl ow has 
 not been discussed. 
  
  Normally, when you approach a workfl ow automation project, you look at what the human process 
 is. You identify the systems used and the actions taken. You look at the input and output data. You 
 then try to replicate that using whatever automation options are available for each system and 
 process. You should take one other step before jumping in too quickly and that is to eliminate any 
 steps that are done purely for the human user’s convenience—for example, formatting data into a 
 more readable layout when the data is only an intermediate result. If the computer can read the data 
 without that formatting, it’s an unnecessary step. Once you have identifi ed the necessary steps, along 
 with the systems and tools to be used, you can look at the automation options.
  
  This section considers some guidelines that should minimize the pain in developing such multi‐
 application scripts. As a general rule, use the following techniques in the order discussed.",NA
 Using Python First,"Python comes with many support modules that enable you to replicate the OS functions and 
 commands directly from your code. Other modules provide access to different fi le formats and 
 network protocols. For example, Python has modules for directly manipulating the Windows registry 
 and the UNIX password fi le that avoid calling external programs. Using Python directly provides an 
 effi cient and fl exible solution that will be easier to maintain in the future. This should always be the 
 fi rst choice if possible.",NA
 Using Operating System Utilities,"The OS provides many tools and commands for performing system administration. Many of these 
 tools have command line interfaces (CLIs) that make them easy to call from Python code using the 
 subprocess
  module. Tools that operate without interaction are the easiest to work with, even if this 
 means using data fi les as an intermediate step because the fi les can be used as a recovery point 
 should the process fail: You simply restart with the last successful step.",NA
 Using Data Files,"Many tools and OS commands use confi guration fi les to control how they function. By creating or 
 modifying these confi guration fi les prior to running the command, you can often control the behavior 
 without the complexity of interacting with the processes in real time. In addition, you can usually drive 
 such tools by using input fi les and generating output fi les rather than interactively providing data at 
 prompts. You can build such fi les (or read them) using Python code, and you have seen how Python 
 modules can assist in parsing many common data formats.
  
 www.it-ebooks.info",NA
 Using a Third‐Party Module,"Many popular applications have third‐party modules that facilitate interacting with the application or 
 direct manipulation of their data fi les. Microsoft Excel is a good example, with several modules 
 available to assist in manipulating spreadsheets. You can manipulate many other proprietary fi le 
 formats using third‐party modules. Use your favorite search engine to fi nd such modules. Include 
 keywords like the application name, “python”, and “module”, and you should fi nd what you are 
 looking for fairly quickly. 
  
  The main caveat with this approach is that third‐party modules often work only with older Python 
 versions and may not be updated to the latest build. Most such modules are open source, with 
 generous license conditions, so you usually have the option of updating the code yourself or, if that is 
 too big a project, perhaps copying just the code that you need for your project. Due credit to the 
 original authors should, of course, be given.",NA
 Interacting with Subprocesses via a CLI ,"If a tool has a CLI but cannot be driven using a data fi le, you can still use the 
 subprocess
  module and 
 interact with the process using 
 stdin
  and 
 stdout
  as was demonstrated with the 
 ex
  editor earlier in 
 the “Managing Subprocesses” section of this chapter. This is a potentially complex strategy because 
 you have to anticipate every possible response or input request that the application may make. 
 Similarly, error handling can be diffi cult to control and often, if an application deviates from the 
 expected interaction, you may have no choice but to abort your script and try to recover manually. 
 This is why using data fi les is preferable if at all possible.
  
 NOTE 
  On Mac OS X there is an alternative technology, which is not covered in detail 
 in this book, but can be useful for scripting Mac applications. It is based on 
 AppleScript technology and its command‐line interface:  
 osascript
  . 
  
 By writing small AppleScript programs and calling them from Python via 
 osascript
  , you can often get Apple programs to “join in the dance” so to speak. 
 Third‐party modules are available for interacting with 
 osascript
  , but you can 
 run it directly, using the 
 subprocess
  module, too. 
  
  There is a third‐party module called  
 pexpect
  that makes interacting with an external console‐based 
 program easier. It works by looking for expected (hence the name) prompt strings from the target 
 application and then responding by allowing the programmer to send responses. This works well for 
 login dialogs and similar interactions.",NA
 Using Web Services for Server‐Based Applications ,"Some applications provide web services as an interface option. This is often an attractive alternative to 
 using a third‐party module, although the trade‐off is often slower performance and the added 
  
 www.it-ebooks.info",NA
 Using a Native Code API ,"If the application you need to control offers a C library as an API, you can use  
 ctypes
  to access it 
 from Python. The biggest problem you are likely to face with this approach is fi nding good 
 documentation for the API. If documentation exists, this can be a very effective technique, but if not, 
 it can involve a lot of painful trial and error. The Python interactive prompt is an invaluable tool in 
 these scenarios. 
  
  For Windows applications you can often fi nd a COM interface and access that via the win32 
 package. As with using  
 ctypes
  , the lack of documentation is often the biggest obstacle.",NA
 Using GUI Robotics ,"The fi nal option for GUI applications with no API is to interact with the GUI itself by sending user 
 event messages into the application. Such events could include key‐presses, mouse‐clicks, and so forth. 
 This technique is known as  
 robotics
  because you are simulating a human user from your Python 
 program. It is really an extension of the native code access described in the previous section, but 
 operating at a much lower level. 
  
  This is a frustrating technique that is very error prone and also very vulnerable to changes in the 
 application being controlled—for example, if an upgrade changes the screen layout, your code will 
 likely break. Because of the diffi culty of writing the code, as well as the fragility of the solution, you 
 should avoid this unless every other possibility has failed.",NA
 SUMMARY ,"This chapter looked at how to automate tasks involving several different applications or OS utilities. 
 You saw that Python’s standard library contains several powerful modules to assist in this. The 
 os
  , 
 os.path
  ,  
 shutil
  , and 
 glob
  modules, for example, can provide much information about computer 
 resources and help you manage fi les directly from within Python.
  
  The  
 subprocess
  module provides a mechanism to launch and interact with command line programs 
 from within your scripts.
  
  The  
 time
  , 
 datetime
  , and 
 calendar
  modules can assist with time‐related tasks and calculations. The  
 time.sleep()
  function can introduce a pause to your script’s execution while waiting for other 
 processes to complete.
  
  You also saw that common data fi les that can be generated, or used as input by applications, can be 
 created or read by Python using modules such as 
 csv
  , 
 v configparser
  , 
 r htmllib
  , and 
 xml.etree
  . 
  
  If no other form of access is available, it may be possible to use  
 ctypes
  to access C functions exposed 
 by dynamic libraries. On Windows similar functions exposed as a COM interface may be available, 
 and the  
 pywin32
  modules simplify access somewhat. These techniques are usually more complex 
 than using data fi les or calling 
 subprocess
  functions. 
  
 www.it-ebooks.info",NA
 3 ,"WHAT YOU WILL LEARN IN THIS CHAPTER: 
  
 ➤
  
  What data persistence means 
  
 ➤
  
  How to store data in fi les 
  
 ➤
  
  How to store data in a database 
  
 ➤
  
  How databases search, sort, and access data 
  
 ➤
  
  Other options for data storage 
  
  WROX.COM DOWNLOADS FOR THIS CHAPTER 
  
  For this chapter the wrox.com code downloads are found at 
 www.wrox.com/go/pythonprojects 
 on the Download Code tab. The code is in the Chapter   3  
 download, called  
 Chapter3.zip
  , and individually named according to the names throughout 
 the chapter. 
  
  In many scenarios you need to store data between executions of your program. The data you 
 want to store could be local status information, such as the current location in an e‐book reader 
 or the current working fi lename, or it could be administrative data such as usernames and 
 passwords or server addresses. Often it will be large volumes of business‐oriented data such as 
 customer orders, inventory, or address information. Many business applications consist of little 
 more than a mechanism to create, view, and edit stored data. 
  
  This capability to store data in such a way that it is available for use on subsequent invocations 
 of your program is known as  
 data persistence
  because the data persists beyond the lifetime of 
 the process that created it. To implement data persistence you need to store the data somewhere, 
 either in a fi le or in a database. 
  
  This chapter is a bit like a history of computing storage technologies. That’s because the need to 
 store data has grown—and continues to grow—ever more complex with the passage of time. You 
 now have a broad range of technologies available covering every storage need, from 
  
 www.it-ebooks.info",NA
 STORING DATA USING PYTHON ,"The simplest storage is a plaintext fi le. You have already seen in Chapter   2 how to use a text fi le to 
 store data in various formats, such as CSV and XML, as well as how to store unformatted text. These 
 formats are fi ne if you need to store the data only when the program closes and read it back when the 
 program is started again. This situation makes these formats very suitable for confi guration data or 
 application status information. These fl at‐fi le formats are less useful when you need to handle large 
 volumes of data non‐sequentially or search for specifi c records or fi elds. For that, you need a database. 
  
  A database is just a data storage system that enables you to create, read, update, and delete 
 individual records—this set of four fundamental data management functions is often referred to 
 as a 
 CRUD
  interface. Database records consist of one or more key fi elds that uniquely identify the 
 record, plus any other fi elds needed to represent the attributes of the entity that the record 
 represents.
  
  A Python dictionary can be used as a type of non‐persistent database in that you can use the dictionary 
 key to create, read, update, or delete a value associated with a given dictionary key; that could be a 
 tuple of fi elds, or a record. All that’s missing is the ability to store the data between sessions. The 
 concept of a dictionary as a database has been exploited over the years, and various forms of persistent 
 dictionaries exist. The oldest are the database management (DBM) family of fi les.",NA
 Using DBM as a Persistent Dictionary ,"DBM fi les originated in UNIX but have been developed over the years for other platforms as well. 
 Python supports several variations. These variations are hidden by the 
 dbm
  module that 
 automatically determines the best solution based on which libraries are supported by the OS 
 installation at hand. If no native DBM library can be found, a basic, pure Python version is used.
  
  The DBM system is a simplifi ed version of a dictionary in that both the keys and values must be 
 strings, which means that some data conversion and string formatting is necessary if you are using 
 non‐string data. The advantages of a DBM database are that it is simple to use, fast, and fairly compact. 
  
  You can see how DBM works by revisiting the tool‐hire example from Chapter  2  . When you last 
 looked at it you were working from a spreadsheet as the master data source. Suppose you decided to 
 migrate the solution to a pure Python application? You would need a storage mechanism for the 
 various data elements. 
  
  Recall that the spreadsheet had two sheets, one representing the tools for hire and the other the 
 actual loans by the members. The record formats are shown in Table   3-1  . 
  
 www.it-ebooks.info",NA
 Using Pickle to Store and Retrieve Objects ,"The  
 pickle
  module is designed to convert Python objects into sequences of binary bytes. The object 
 types converted include the basic data types, such as integers and boolean values, as well as system‐and 
 user‐defi ned classes and even collections such as lists, tuples, and functions (except those defi ned 
 using 
 lambda
  ). A few restrictions exist on objects that can be pickled; these are described in the 
 module documentation.",NA
 Accessing Objects with shelve,"The  
 shelve
  module combines the 
 dbm
  module’s ability to provide random access to fi les with 
 pickle
  
 ’s ability to serialize Python objects. It is not a perfect solution in that the key fi eld must still be a string 
 and the security issue with  
 pickle
  also applies to  
 shelve
  , so you must ensure your data sources are 
 safe. Also, like  
 dbm
  fi les the module cannot tell if you modify data read into memory, so you must 
 explicitly write any changes back to the fi le by reassigning to the same key. Finally, 
 dbm
  fi les impose 
 some limits around the size of objects they can store and are not designed for concurrent access from, 
 for example, multiple threads or users. However, for many projects, 
 shelve 
 provides a simple, 
 lightweight, and fairly fast solution for storing and accessing data. 
  
  So as far as you are concerned, 
 shelve
  acts just like a dictionary. Almost everything you do with a 
 dictionary you can also do with 
 shelve
  instances. The only difference is that the data remains on the 
 disk rather than being in memory. This has obvious speed implications, but on the other hand, it means 
 you can work with very large dictionaries even when memory is limited. 
  
  Before you build  
 LendyDB
  with  
 shelve
  , you’ll experiment with some dummy data that includes a 
 bigger selection of data types, including a user‐defi ned class. The fi rst thing you do is create the 
 shelve
  database fi le (or, as they are sometimes known, a 
 shelf
 ):
  
 >>>
   shelf = shelve.open('fundata.shelve','c')
  
  The  
 open
  function takes the same arguments as the  
 dbm
  version discussed earlier. Because you are 
 creating a new shelf, you use mode  
 c
  for create. Now you can start adding items to the shelf: 
  
 >>>
   shelf['tuple'] = (1,2,'a','b',True,False) 
  
 >>>
   shelf['lists'] = [[1,2,3],[True,False],[3.14159, 
 ‐
 66]]
  
  With these commands, you saved two items, each of which contains a mix of Python data types, and 
 shelve
  happily stored them without any data conversion required by you. You can check that 
 shelve
  saved the items by reading the values back: 
  
 >>>
   shelf['tuple'] 
  
  (1, 2, 'a', 'b', True, False) 
  
 >>>
   shelf['lists'] 
  
  [[1, 2, 3], [True, False], [3.14159, -
 66]]",NA
 ANALYZING DATA WITH PYTHON ,"Once you have a set of data, you usually want to ask questions about it. For example, in the lending 
 library example, you might want to know the total cost of the items or even the average cost of an item. 
 You might want to know who contributed the most items, which items are out on loan at any given 
 time, and so on. You can do that using Python, and you could write functions using all the standard 
 Python features that would answer those questions. However, Python has some powerful features that 
 often get overlooked that are especially useful for analyzing data sets.
  
  In this section you look at some of the built‐in features you can use, especially the functional 
 programming features of the language. Then you turn your attention to the  
 itertools
  module, 
 which offers more advanced features that often save time and computing resources when compared 
 with the standard alternatives.",NA
 Analyzing Data Using Built‐In Features of Python ,"When you analyze data, it is important to select the right data structure. For example, Python includes 
 a  
 set
  data type that automatically eliminates duplicates. If you care only about unique values, 
 converting (or extracting) the data to a set can simplify the process considerably. Similarly, using 
 Python dictionaries to provide keyword access rather than numeric indices often improves code 
 readability, and thus reliability (you saw an example of that in Chapter   2 that compared the CSV 
 dictionary-based reader with the standard tuple-based reader). If you are fi nding that your code is 
 getting complicated, it’s often worthwhile to stop and consider whether a different data structure 
 would help. 
  
  In addition to the wide variety of data structures, Python also offers many built‐in and standard 
 library functions that you can use, such as  
 any
  , 
 y all
  ,  
 map
  ,  
 sorted
  , and slicing. (Slicing isn’t 
 technically a function but an operation, however it does return a value in a similar way that a 
 function would.) When you combine these functions with Python generator expressions and list 
 comprehensions, you have a powerful toolkit for slicing and dicing your data.
  
  You can apply these techniques to your 
 LendyDB
  data to answer the questions raised in the opening 
 paragraph of this “Analyzing Data with Python” section. You can try that now.
  
  TRY IT OUT 
 Analyzing LendyDB with Python (lendydata.py)
  
  In this Try It Out, you use standard Python features to answer the questions about the  
 LendyDB 
 data raised earlier: 1) What is the total cost of all items? 2) What is the average cost of an item?",NA
 Analyzing Data with itertools ,"The  
 itertools
  module of the standard Python library provides a set of tools that utilize functional 
 programming principles to consume iterable objects and produce other iterables as results. This 
 means that the functions can be combined to build sophisticated data fi lters. 
  
  Before looking at how  
 itertools
  can be used on the  
 LendyDB
  data, you should look at some of the 
 functions provided using simpler data sets. These functions are powerful, but operate in slightly 
 different ways than most of the functions you have dealt with in the past. In particular, they are all 
 geared around processing iterators. You should recall that all the standard Python collections, as well 
 as objects such as fi les, are iterators. You can also create your own custom iterators by defi ning some 
 methods that adhere to the Python iterator protocol. The simplest iterators are strings, so that’s 
 mainly what the documentation uses to demonstrate the  
 itertools
  functions, but remember that 
 these functions work with any kind of iterator, not just strings.
  
  Utility Functions
  
  The fi rst group of functions you look at includes relatively simple functions that you typically use to 
 provide input to the other functions in the module. The 
 count()
  function works a lot like the built‐in 
 range()
  function, except where 
 range()
  generates numbers up to a limit,  
 count()
  generates an indefi 
 nite series of numbers from a start point, incrementing by a given, optional, 
 stepsize
  . It looks like 
 this:
  
 >>>
   import itertools as it 
  
 >>>
   for n in it.count(15,2) : 
  
 ...
       if n < 40: print(n, end=' 
 ') 
  
 ...
       else: break 
  
 ...
  
  15 17 19 21 23 25 27 29 31 33 35 37 39 
  
  The  
 repeat()
  function is even simpler; it just repeats its argument continuously, or for the number 
 of repetitions specifi ed, like this: 
  
 >>>
   for n in range(7): 
  
 ...
      print(next(it.repeat('yes ')), 
 end='') 
  
 ...
  
  yes yes yes yes yes yes yes 
 >>> 
  
 >>>
   list(it.repeat(6,3))
  
  [6, 6, 6] 
  
 >>>",NA
 Using itertools to Analyze LendyDB Data ,"You’ve seen what  
 itertools
  has to offer, so now it’s time to try using it with your  
 LendyDB
  data.
  
 You want to repeat the analysis that you did using the standard tools, but see how the  
 itertools 
 functions can be brought to bear, too. Remember, the real point of the 
 itertools
  module is not so 
 much that it gives you new features, but rather that it lets you process large volumes of data more effi 
 ciently. Given the tiny amount of data you are using in this chapter, you won’t actually see any effi 
 ciency improvements, but as you scale the data volumes up, it does make a difference.
  
  TRY IT OUT 
 Analyzing the LendyDB Data Using itertools
  
  In this Try It Out, you repeat the earlier analysis of the 
 LendyDB
  data using some of the  
 itertools 
 functions. To achieve this, follow these steps:
  
 1.
  
  Change into the folder where you stored the  
 lendydata.py
  fi le. 
  
 2.
  
  Start the Python interpreter and import the data fi le using the following command:
  
 >>>
   from lendydata import *
  
 3.
  
  Import the  
 itertools
  module: 
  
 >>>
   from itertools import *
  
 4.
  
  To answer the question, “What is the total cost of all items?” type this: 
  
 >>>
   def cost(item): 
  
 ...
      return 
 int(item[4][1:]) 
  
 ...
  
 >>>
   for n in islice(accumulate(cost(item) for item in 
 items[1:]), 
 ...
                  len(items)
 ‐
 2,None): 
  
 ...
       print(n) 
  
 ...
  
 1100 
  
 5.
  
  To answer the question, “What is the average cost of an item?” type this: 
  
 >>>
   n/len(items)
 ‐
 1 
  
 183.33333333334 
  
 >>>
  
 6.
  
  To answer the question, “Who contributed the most items?” type this: 
  
 >>>
   def owner(item): return 
 item[3] 
  
 ...",NA
 MANAGING DATA USING SQL,"In this section you are introduced to some of the concepts behind SQL and relational databases. You fi 
 nd out how to use SQL to create data tables and populate them with data, and how to manipulate the 
 data contained within those tables. You go on to link tables to capture the relationships between data 
 and fi nally apply all of these techniques to your lending library data.",NA
Relational Database Concepts,"The basic principle of a relational database is very simple. It’s simply a set of two‐dimensional 
 tables
  . Columns are known as 
 fi elds
  and rows as 
 records
  . Field values can refer to other records, 
 either in the same table, or in another table—that’s the “relational” part. 
  
 A table holding data about employees might look like Table   3-3  . 
  
 TABLE 3-3:  
  Employee Data 
  
 EMPID
  
 NAME
  
 HIREDATE
  
 GRADE
  
 MANAGERID
  
 1020304
  
 John Brown
  
 20030623
  
 Foreman
  
 1020311
  
 1020305
  
 Fred Smith
  
 20040302
  
 Laborer
  
 1020304
  
 1020307
  
 Anne Jones
  
 19991125
  
 Laborer
  
 1020304
  
 Notice a couple of conventions demonstrated by this data:
  
 ➤
  
  You have an identifi er (ID) fi eld to uniquely identify each row; this ID is known as the 
  
 primary key
  . It is possible to have other keys too, but conventionally, there is nearly always 
  
 an 
 ID fi eld to uniquely identify a record. This helps should an employee decide to change her 
  
 name, for example.
  
 ➤
  
  You can link one row to another by having a fi eld that holds the primary key value for 
  
 another row. Thus an employee’s manager is identifi ed by the 
 ManagerID
  fi eld, which is 
  
 simply a reference to another 
 EmpID
  entry in the same table. Looking at your data, you see 
  
 that both 
 Fred
  and  
 Anne
  are managed by 
 John
  who is, in turn, managed by someone else, 
  
 whose details are not visible in this section of the table. 
  
  RELATIONSHIP CARDINALITY 
  
  
  Relationships within a database link two or more entities together. The number
  
 of each entity involved in the relationship is known as its 
 cardinality
 . The 
  
 relationships can be one‐to‐one, where one record links to exactly one other record. 
 They can also be one‐to‐many, such as the employee‐to‐manager relationship in the 
 example. 
  
  A relationship can also be many‐to‐many. This relationship is best explained by an 
 example. Suppose you introduced a new table of tasks. Each task could have many 
 employees assigned to it. At the same time, each employee could have several tasks.
  
 There is, therefore, a many‐to‐many relationship between employees and tasks.
  
  Much of the work in any database application is focused on maintaining the many‐to‐
 many relationships within the database. Several forms of graphical notation (known 
 as  
 entity‐relationship diagrams
 ) are used to describe database structures. Most of 
 these notations have a strong emphasis on showing the cardinality of each 
 relationship. 
  
 www.it-ebooks.info",NA
 Structured Query Language,"The Structured Query Language, or SQL (pronounced either as Sequel or as the letters S‐Q‐L), is the 
 standard software tool for manipulating relational databases. In SQL an expression is often referred 
 to as a   
 query
  , regardless of whether it actually returns any data. 
  
  SQL is comprised of two parts. The fi rst is the 
 data defi nition language
  (DDL). This is the set of 
 commands used to create and alter the shape of the database itself—its structure. DDL tends to be 
 quite specifi c to each database, with each vendor’s DLL having a slightly different syntax. 
  
  The other part of SQL is the 
 data manipulation language
  (DML). DML, used to manipulate database 
 content rather than structure, is much more highly standardized between databases. You spend the 
 majority of your time using DML rather than DDL.
  
 NOTE 
  In this book you use the SQLite database system, which has three big 
 advantages. First, it has an API module provided as part of Python's standard library. 
 Second, it is a simple dialect of SQL to learn. Third, and by no means least, SQLite works 
 from a single data fi le and code library so you don't need to set up a database server 
 or worry about any of the database administration duties normally associated with 
 maintaining relational databases.
  
  You only look briefl y at DDL, just enough to create (with the 
 CREATE
  command) and destroy (with the  
 DROP
  command) your database tables so that you can move on to fi lling them with data, retrieving that 
 data in interesting ways, and even modifying it, using the DML commands ( 
 INSERT
  , 
 SELECT
  ,  
 UPDATE
  , 
 and 
 DELETE
  ). 
  
 www.it-ebooks.info",NA
 Linking Data Across Tables,"The possibility of linking data between tables was mentioned earlier, in the section on  
 SELECT
  . 
 However, this is such a fundamental part of relational database theory that you consider it in more 
 depth here. The links between tables represent the 
 relationships
  between data  
 entities
  that give a 
 relational database
  such as SQLite its name. The database maintains not only the raw data about the 
 entities, but also information about the relationships. 
  
  The information about the relationships is stored in the form of database constraints, applied when 
 you defi ne the database structure using the 
 CREATE
  statement. Before you see how to use constraints 
 to model relationships, you fi rst need to look deeper into the kinds of constraints available in SQLite. 
  
  Digging Deeper into Data Constraints
  
  You normally express the constraints on a fi eld‐by‐fi eld basis within the 
 CREATE
  statement. This 
 means you can expand the basic  
 CREATE
   defi nition from,
  
  CREATE Tablename (Column, Column,...); 
  
  to: 
  
  CREATE Tablename (
  
  ColumnName Type Constraints, 
  
  ColumnName Type Constraints, 
  
  ...); 
  
  The most common constraints are:
  
 ➤
  
 NOT NULL
  
 ➤
  
 PRIMARY KEY [AUTOINCREMENT]
  
 ➤
  
 UNIQUE
  
 ➤
  
 DEFAULT value
  
 NOT NULL
  is fairly self‐explanatory; it indicates that the value must exist and not be  
 NULL
  . A 
 NULL 
 value is simply one that has no specifi ed value, rather like 
 None
  in Python. If no suitable value is 
 provided for a fi eld governed by a 
 NOT NULL
  constraint, data insertion will utterly fail—quite possibly 
 not only for that particular fi eld, but also for the entire row. (Or, far worse, violation of the constraint 
 could cause a very large database update transaction—possibly involving hundreds or thousands of 
 rows—to fail in its entirety.)
  
 PRIMARY KEY
  tells SQLite to use this column as the main key for lookups (in practice this means it is 
 optimized for faster searches). The optional 
 AUTOINCREMENT
  keyword means that an 
 INTEGER 
 type 
 value is automatically assigned on each  
 INSERT
  and the value automatically incremented by one. This 
 saves a lot of work for the programmer in maintaining separate counts. Note that the  
 AUTOINCREMENT
  “keyword” is not normally used; rather, it is implied from a type/constraint 
 combination of 
 INTEGER PRIMARY KEY
  . This not‐so‐obvious quirk of the SQLite documentation trips 
 up enough people for it to appear at the top of the SQLite Frequently Asked Questions page, found 
 here:  
 http://sqlite.org/faq.html
  . 
  
 www.it-ebooks.info",NA
 Many‐to‐Many Relationships ,"One scenario you haven’t covered is where two tables are linked in a 
 many‐to‐many
  relationship. 
 That is, a row in one table can be linked to several rows in a second table and a row in the second 
 table can  
 at the same time
  be linked to many rows in the fi rst table. 
  
  Consider an example. Imagine creating a database to support a book publishing company. It needs lists 
 of authors and lists of books. Each author may write one or more books. Each book may have one or 
 more authors. How do you represent that in a database? The solution is to represent the relationship 
 between books and authors as a table in its own right. Such a table is often called an 
 intersection table
  
 or a 
 mapping table
  . Each row of this table represents a book/author relationship. Now each book has 
 potentially many book/author relationships, but each relationship only has one book and one author, 
 so you have converted a many‐to‐many relationship into two one‐to‐many relationships. And you 
 already know how to build one‐to‐many relationships using IDs. It looks like this (you can fi nd the code 
 in the fi le  
 books.sql
  in the 
 SQL
  folder of the  
 .zip
  fi le): 
  
 PRAGMA Foreign_Keys=True;
  
 drop table author;",NA
 MIGRATING LENDYDB TO AN SQL DATABASE ,"In this section you re‐create the  
 LendyDB
  database using a combination of SQL and Python code. 
 Before getting into the nitty‐gritty, you need to see how Python and SQL come together.",NA
 Accessing SQL from Python ,"SQLite provides an   
 application programming interface
  or  
 API
  consisting of a number of standard 
 functions that allow programmers to perform all the same operations that you have been doing 
 without using the interactive SQL prompt. The SQLite API is written in C, but wrappers have been 
 provided for other languages, including Python. Python has similar interfaces to many other 
 databases, and they all provide a standard set of functions and provide very similar functionality. This 
 interface is called the Python DBAPI, and its existence makes porting data between databases much 
 easier than if each database had its own interface.
  
  The DBAPI defi nes a couple of useful conceptual objects that form the core of the interface. These are  
 connections
  and  
 cursors
  . 
  
  Using SQL Connections 
  
  A connection is the conduit between your application code and the database’s SQL engine. The name 
 comes from the client‐server architecture used by most SQL databases whereby the client must connect 
 to the server over a network. For SQLite the connection is actually to the data fi le via the SQLite library. 
 The arguments passed to create the connection are of necessity database‐specifi c. For example, many 
 databases require a user ID and password, and some require IP addresses and ports, whereas SQLite 
 just requires a fi lename. It looks like this: 
  
  >>>  
 import sqlite3
  
  >>>  
 db = 
 sqlite3.connect('D:/PythonCode/Chapter3/SQL/lendy.db')
  
  Once a connection has been established, you can go on to create cursors, which are the mechanism 
 used to issue SQL commands and receive their output. In principle you can have more than one cursor 
 per connection, but in practice that is rarely needed. 
  
 Using a Cursor
  
  When accessing a database from within a program, one important consideration is how to access the 
 many rows of data potentially returned by a  
 SELECT
  statement without running out of memory.
  
 The answer is to use what is known in SQL as a 
 cursor
  . A cursor is a Python iterator so it can be 
 accessed iteratively one row at a time. Thus, by selecting data into a cursor and using the cursor 
 methods to extract the results either as a list (for smaller volumes of data), or row by row, you can 
 process large collections of data. You now try that out.",NA
 Creating the LendyDB SQL Database ,"The database design is not signifi cantly different from its previous incarnations. You just have to 
 translate it into SQL syntax and add in some constraints to improve data integrity. 
  
  The initial database setup is usually easiest to do using raw SQL commands as you did in the earlier 
 sections. Although it is possible to do it all from Python, occasionally another tool is better suited to the 
 task at hand.
  
 NOTE 
  If you don’t have the SQLite interpreter installed, you can still execute a SQL 
 script using the 
 executescript()
  method of the cursor object. This method takes 
 an SQL script as an argument. The script can be read from a fi le or a standard 
 Python string, which could be a multiline triple‐quoted string. Note that you need to 
 terminate the SQL statements with semicolons just as you did when using the  
 sqlite3
  interpreter. 
  
  The code looks like this (and is available in the fi le 
 lendydb.sql
  in the  
 SQL
  folder of the  
 .zip
  fi le): 
  
 PRAGMA Foreign_Keys=True;
  
 drop table loan;
  
 www.it-ebooks.info",NA
 Inserting Test Data ,"The database design now includes some referential constraints so you need to think about the order in 
 which you populate the data. The member data has no references, so it can be loaded fi rst. The item 
 data only references members, so it comes next. Finally, the loan data references both members and 
 items, so it must come last.
  
  For the data insertion, you are essentially repeating the same  
 INSERT
  operation over and over with 
 different data values. This time Python is the better solution because you can write the SQL once and 
 execute it many times using either the  
 executemany()
  method of the cursor object or by calling the  
 execute()
  method from within a Python 
 for
  loop. It looks like this (and the code is in the fi le 
 lendydata
 ‐
 sql.py
  ):
  
 import sqlite3
  
 members = [ 
  
 ['Fred', 
 'fred@lendylib.org'], 
  
 ['Mike', 'mike@gmail.com'], 
  
 ['Joe', 'joe@joesmail.com'], 
  
 ['Rob', 'rjb@somcorp.com'], 
  
 ['Anne', 'annie@bigbiz.com'],
  
 www.it-ebooks.info",NA
 Creating a LendyDB API ,"When defi ning an API for a database, it’s normal to start off by thinking about the basic entities and 
 providing functions to create, read, update, and delete the items. (This is often known as a CRUD 
 interface after the initials of the operations.) The temptation is to provide these functions as a thin 
 wrapper around the corresponding SQL commands. However, to the application programmer it is not 
 particularly useful to just be given an ID of a member—for example, it would be much better in most 
 cases to get the member name instead. Otherwise, the programmer must perform multiple reads of the 
 member database to create a useful display for the user. On the other hand, there may
  
 www.it-ebooks.info",NA
 EXPLORING OTHER DATA MANAGEMENT OPTIONS ,"You have many options for managing large amounts of data. In this section you look at traditional 
 client‐server databases, newer databases known as “NoSQL” databases, and how cloud storage is 
 changing approaches to data management. Finally, you consider some powerful data analysis tools 
 that can be accessed from Python using third‐party modules.",NA
 Client‐Server Databases,"The traditional SQL database is rather different from SQLite in the way it is constructed. In these 
 databases you have a database server process accessed over a network by multiple clients. The Python 
 DBAPI is designed so that you can work with these databases just as easily as you did with SQLite. Only 
 minor changes in the way you initialize the database connection are usually all that is necessary. 
 Occasionally you’ll see minor changes to the SQL syntax, and the parameter substitution symbol is 
 sometimes different, too. But, in general, swapping from one SQL interface to another is a relatively 
 painless experience.
  
  Several reasons exist for wanting to adopt a client‐server database or to migrate to one from SQLite. 
 The fi rst is capacity; most client‐server databases can scale up to much larger volumes of data than 
 SQLite. In addition, they can be confi gured to distribute their processing over several servers and disks, 
 which greatly improves performance when multiple users are accessing the data concurrently.
  
 The second reason for migrating from SQLite is that larger databases usually come with a much richer 
 set of SQL commands and query types as well as more data types. Many even support object‐oriented 
 techniques and have their own built‐in programming languages that enable you to write stored 
 procedures, effectively putting the API into the database itself. Usually, a much richer set of database 
 constraints can be used to tighten up data integrity far beyond the simple foreign key checks that SQLite 
 performs.
  
 www.it-ebooks.info",NA
 NoSQL,"As data storage needs have expanded both in size and in variety, several projects have been exploring 
 alternatives to SQL. Many of these projects are associated with what is called “Big Data,” which usually 
 relates to the harvesting of large volumes of, often unstructured, data from places such as social media 
 sites or from sensors in factories or hospitals and so on. One of the features of this kind of data is that 
 most of it is of little signifi cance to the database user, but amongst the detritus are gems to be had that 
 can infl uence sales strategy or alert you to imminent failure of components or processes so that action 
 can be taken in advance. The nature, volumes, and need for rapid access of such data means that 
 traditional SQL databases are not well suited to the task.
  
  The solution has been a variety of technologies that go under the collective term  
 NoSQL
  . NoSQL does 
 not mean that no SQL is used, but rather it stands for Not Only SQL. SQL may still be available for 
 traditional queries on these new databases, but alternative query techniques are also used, especially 
 for searching unstructured data. Some examples of NoSQL approaches (with typical implementations) 
 are Document (MongoDB), Key‐Value (Dynamo), Columnar (HBase), and Graphs (Allegro). All of these 
 diverge to some degree or other from the traditional relational model of multiple, two‐dimensional 
 tables with cross‐references. To get the best from these systems, you need to consider which 
 architecture best suits the nature of your data. Many solutions are open source, but commercial 
 offerings exist, too. 
  
  Although NoSQL databases do provide the potential for faster and more fl exible access to a wider 
 variety of data, they generally sacrifi ce qualities like data integrity, transactional control, and 
 usability. The products are all evolving rapidly, although at the time of writing they require lower‐
 level programming skills to utilize the data compared to traditional SQL databases that could 
 change quite quickly. Most of the popular databases offer Python modules that facilitate 
 programming them from Python.",NA
 The Cloud,"Cloud computing has become popular in recent years with its promise of computing on‐demand. 
  
 This potentially offers lower costs, more fl exibility, and lower risks than traditional data center–based 
 solutions. It brings its own set of concerns, of course, especially for sensitive data or where network 
 reliability is an issue. The biggest use of cloud technologies in the database world has been in 
 combination with the NoSQL solutions, discussed in the previous section, and other Big Data solutions 
 such as Hadoop. Many cloud storage providers offer these technologies on a software‐as‐a‐service 
 (SAAS) basis. This offers an attractive option for those just dipping a toe into the Big Data or NoSQL 
 world.
  
 www.it-ebooks.info",NA
 Data Analysis with RPy,"Though client‐server SQL, NoSQL, and cloud computing all provide solutions for handling large data 
 volumes or many users, you have other data management issues to consider. Often, the processing of 
 large volumes of data is more important than the storage or retrieval. If that processing involves a high 
 degree of statistical exploration or manipulation, Python offers a basic  
 statistics
  module 
 (introduced to the standard library in version 3.4). If that is not enough, there is the R programming 
 language. R is a specialized language designed for statistical number crunching on a large scale. Like 
 Python it has accumulated a large library of add‐in modules, and many statistical researchers use R as 
 their platform of choice, publishing their research using R.
  
  The good news for Python programmers is that there is an interface from Python to R called  
 rpy2 
 that 
 opens up this processing power without having to become an expert in R. Knowing the basics of R, 
 especially its data handling concepts, is pretty much essential, but much of your Python knowledge can 
 be applied, too. You can fi nd  
 rpy2
  on the Python Package Index and install it via 
 pip
  . 
  
 www.it-ebooks.info",NA
 SUMMARY ,"In this chapter you learned how to store and retrieve data so that your application can pick up from 
 where it left off or so that you can work on multiple different projects. You saw how you could do 
 this with fl at fi les using indexed fi les (DBM), pickles, and shelves. You then looked at SQL and 
 relational databases using SQLite and concluded with a review of some alternative technologies.
  
  Flat fi les are good for storing small amounts of data or for saving the program’s state information 
 when it shuts down. They are less useful where multiple queries have to be made, especially if 
 querying on more than one key value. DBM fi les act like persistent dictionaries that can only store 
 strings. Pickles turn binary objects into strings. Shelves combine DBM and  
 pickle
  to act like 
 persistent dictionaries, albeit limited to using strings for the keys.
  
  SQL is used to manage data in a relational database management system (RDBMS). Relational 
 databases are conceptually made up of one or more two‐dimensional tables, each representing one 
 logical entity. Cross‐references between tables act as a model for the relationships between entities. 
  
 SQL provides commands to build and manage the tables in a database as well as operations to 
 create, delete, query, and update the data within those tables. 
  
  Python provides the DBAPI, which is a standard protocol for accessing SQL‐based databases. The 
 DBAPI primarily consists of two objects: a connection and a cursor. The cursor is the primary object 
 used for executing SQL commands and retrieving their results. Results are returned as a list of tuples.
  
  The SQLite database interface is provided in Python’s standard library, and you can download a 
 standalone interpreter. SQLite, as the name suggests, is a lightweight version of SQL that stores the 
 entire database in a single fi le and supports a lightweight subset of the SQL language. SQLite can be 
 used on small‐ to medium‐sized projects, and it is then relatively easy to migrate to a larger database if 
 the project expands in scale. DBAPI libraries are available for most major databases and can be 
 downloaded from third parties. 
  
  By using the DBAPI it is possible to build a data abstraction layer that hides both the details of the 
 database design and the SQL language from the application programmer, further facilitating the 
 migration process if it becomes necessary. 
  
  Several other database technologies exist, and this is an active area of development with several 
 NoSQL projects vying for popular support. These databases tend to have quite specifi c areas of 
 applicability, and no single solution suits all scenarios. Many are focused on the challenges of 
 managing “Big Data” and are well suited to cloud‐based solutions. 
  
 www.it-ebooks.info",NA
 4 ,"WHAT YOU LEARN IN THIS CHAPTER: 
  
 ➤
  
  How to structure and build command-line applications 
  
 ➤
  
  How to enrich command-line applications 
  
 ➤
  
  How to structure and build GUI applications with Tkinter 
  
 ➤
  
  How to enrich Tkinter applications with Tix and ttk 
  
 ➤
  
  How third‐party frameworks extend your GUI options 
  
 ➤
  
  How to localize and internationalize your applications 
  
  WROX.COM DOWNLOADS FOR THIS CHAPTER 
  
  For this chapter the wrox.com code downloads are found at  
 www.wrox.com/go/ 
  
 pythonprojects
  on the Download Code tab. The code is in the Chapter 4 download, called 
 Chapter4.zip
  , and individually named according to the names throughout the chapter. 
  
  Python is a general‐purpose programming language. That means it can be used for many 
 different types of programs. You have already seen how it can be used as a scripting language to 
 glue applications together, as well as its use in managing data persistence and access. You now 
 look at how it can be used to build complete desktop applications. 
  
  Desktop applications are the mainstay of personal computing. They include such standard 
 facilities as word‐processing programs, spreadsheets, and even games. They often function 
 entirely on the desktop, with no network access required. At other times they may be inherently 
 network oriented, as is the case with a web browser or a client–server database application. The 
 distinguishing feature is that the bulk of the functionality is executed on the local PC. 
  
 www.it-ebooks.info",NA
 STRUCTURING APPLICATIONS,"The key to building effective, extensible applications is to apply a layered architecture. The most 
 common approach is to split the application into three layers: the user interface, the core logic (also 
 known as the business logic), and the data. There may also be a network layer when the application 
 uses the network extensively.
  
 NOTE 
  There is a more formal version of this multi‐layer architecture known as 
 client‐server computing. In the client‐server model, a strict hierarchy of request–
 response operation is maintained. Each layer is a client of the layer below and makes 
 requests that receive responses. The lower layers are servers to the layers above. The 
 core logic layer acts as both a server to the user interface layer and a client of the 
 data layer. True client‐server design is beyond the scope of this book, but the 
 multilayer approach demonstrated incorporates many of the same concepts.
  
  The user interface should present the application logic to the user, but not implement that logic. Its 
 role is to make navigation of the application’s features as simple as possible and to display results or 
 outcomes as clearly as possible. The user interface controls which functions are available at any point 
 in time—for example, it should not be possible to close a document if no document is open. If using an 
 object‐oriented program (OOP), the objects will typically represent things like menus, buttons, and 
 windows. The user interface accesses the core logic by calling functions or methods provided by the 
 logic layer. 
  
  The core logic layer contains all of the algorithms and state management of the data. This is where 
 you write the code that changes the data values, creates new entities, opens and closes fi les, and so 
 on. The aim here is to provide a set of functions, or services, that can be accessed from the user
  
 www.it-ebooks.info",NA
 BUILDING COMMAND-LINE INTERFACES ,"In this section you build a very simple command-line interface application for the well‐known game 
 tic‐tac‐toe. The principles discussed in the earlier sections are applied, but in a very simple form so that 
 you can focus on the program structure rather than the detail of what the code is doing. (The code is 
 included in the  
 Chapter4.zip
  fi le under the folder 
 OXO
  .)",NA
 Building the Data Layer,"You start off creating this game by designing the data layer. For this game you need only a simple text 
 fi le to hold the state of the game so that it can be saved or resumed. A tic‐tac‐toe game consists of a 
 board with nine squares. Each square can be empty or have the letter ‘X’ or ‘O’ in it. You can represent 
 those three options with a simple list of characters. For storage you convert that list into a simple 
 character string. 
  
  The only other piece of data needed is which player is due to move next but, in a computer versus 
 human game, you can assume the human is always next to go. So your data layer interface consists of 
 only two exposed, or published, methods:
  
  saveGame()
  
  restoreGame() 
  
  Because you want to keep your layers separate, you should put these methods into a module. To 
 create this module, type the following code and save it as 
 oxo_data.py
  (or load it from the 
 OXO 
 folder of the  
 Chapter4.zip
  download): 
  
 ''' oxo_data is the data module for a tic
 ‐
 tac
 ‐
 toe (or OXO) 
 game. 
  
 It saves and restores a game board. The functions are:
  
  
  saveGame(game) 
 ‐
 > None
  
  
  
  restoreGame() 
 ‐
 > game 
  
  
 Note that no limits are placed on the size of the data.
  
 The game implementation is responsible for 
 validating all data in and out.'''
  
 import os.path 
  
 game_file = "".oxogame.dat""
  
 def _getPath(): 
  
 ''' getPath 
 ‐
 > string 
  
 Returns a valid path for data 
 file.
  
 Tries to use the users home folder, defaults to cwd'''
  
 try:
  
  game_path = os.environ['HOMEPATH'] or os.environ['HOME'] 
 if not os.path.exists(game_path):
  
  
  game_path = os.getcwd() 
  
 except (KeyError, TypeError):
  
  game_path = os.getcwd() 
  
 return game_path
  
 def saveGame(game): 
  
  
 ''' saveGame(game) 
 ‐
 > 
 None",NA
 Building the Core Logic layer ,"You now create the core logic of the game. For that you need to defi ne a number of functions that are 
 used throughout the course of a game. However, to know what those functions are, you fi rst need to 
 think about how the game will be played. So, before diving into logic code, you need to map out the 
 sequence of play and, for that, you can use a sequence diagram.",NA
Building the User Interface,NA,NA
 USING THE CMD MODULE TO BUILD A ,NA,NA
COMMAND-LINE INTERFACE,"Python has a module in its standard library called 
 cmd
  that is specifi cally designed for building 
 command-line interfaces. In particular it creates the type of interface that you use for Python’s help and 
 debugger systems. It presents a command prompt, and you can type in a command. You can request 
 help, and a help screen is presented with the list of available commands. If you type “help <command>”, 
 you get a screen explaining how to use the specifi ed command.
  
  In this section you build a 
 cmd
  ‐based version of the tic‐tac‐toe game from the previous section. It has 
 the same four options that you displayed in the opening menu. The game play part is exactly the same 
 as before. (The fi nished code is in the fi le 
 oxo
 ‐
 cmd.py
  in the 
 OXO
  folder of the 
 Chapter4.zip
  
 download.)
  
 cmd
  is based on an object‐oriented framework whereby you defi ne a new subclass of the 
 cmd.Cmd 
 class. This subclass overrides some key methods to provide your application‐specifi c behavior. You 
 then defi ne a set of methods whose names begin with the string 
 do_
 . The class then interprets the 
 part following the underscore as a command word that the user can type.
  
  You can build a skeleton version of your tic‐tac‐toe game by defi ning some methods that simply 
 print a message to see how it works. It looks like this:
  
 import cmd
  
 class Oxo_cmd(cmd.Cmd): 
  
 intro = ""Enter a command: new, resume, quit. Type 'help' or '?' for 
 help"" prompt = ""(oxo) """,NA
 READING COMMAND-LINE ARGUMENTS ,"When you start a command-line program, the command line itself is stored as a list of strings in 
 sys.argv
  . The fi rst element is the script name, and the following elements are the arguments to the 
 command. Thus, if you had a fi le copying script you might call it like this: 
  
  $ python mycopy.py originalfile copyfile 
  
  And the 
 sys.argv
  value would be:
  
  [""mycopy.py"", ""originalfile"", ""copyfile""] 
  
  However, it’s often the case that command-line scripts take optional arguments to control the display 
 or functionality. For example, many programs offer a “ 
 ‐
 h
  ” or “
 –-help
  ” option that causes the 
 command’s help information to be displayed. You can process those options by examining the 
 contents of  
 sys.argv
  , but it’s a nontrivial task so Python includes the 
 argparse
  module to assist in 
 handling these kinds of command options.
  
  You now modify the original tic‐tac‐toe code to display the help message if either 
 ‐
 h
  or  
 --help
  is 
 specifi ed on the command line. It also goes direct to a new game if 
 ‐
 n
  or  
 --new
  is specifi ed, and it 
 goes straight to a restored game if 
 ‐
 r
  or  
 --res
  or 
  --restore
  is given. This enables experienced 
 tic‐tac‐toe players to bypass the initial menu if they wish.
  
 NOTE 
  Python argument processing assumes UNIX‐style arguments—that is, they start 
 with either one or two hyphens. The traditional option style on DOS or Windows is a 
 forward slash; 
 argparse
  does not process those arguments by default, but you can 
 specify prefi x characters as an optional argument when creating the parser if you 
 need to support other styles. 
  
  The fi rst thing you need to do is import the module:
  
 import argparse as ap",NA
 JAZZING UP THE COMMAND-LINE INTERFACE WITH ,NA,NA
SOME DIALOGS ,"It is possible to add a few GUI elements to a command-line interface application without the complexity 
 of building a completely graphical user interface. In particular you can pop up information or warning 
 boxes instead of simply printing a message on the terminal. This often makes the messages stand out 
 more to the user—they do not get lost in the mass of text on the screen. You can also use the standard fi 
 le selection dialogs when choosing fi lenames. In this section you add some GUI message boxes to the 
 tic‐tac‐toe user interface to highlight error messages and to notify the user of the fi nal outcome of a 
 game.
  
 TIP 
  It is usually a good idea to allow the code to write to the terminal, too, just in case 
 the user is not running a GUI environment—for example, if they are logging in 
 remotely over  
 ssh
  or similar. You can do this as a matter of course or have a 
 command-line option, such as 
 --nogui
  , to control how the prompts are displayed.
  
  Before you start modifying the game itself, you can explore how these message boxes work at the 
 command-line prompt. They are defi ned in submodules of the 
 tkinter
  package that you explore 
 more fully later in the chapter. These submodules are:
  
 ➤
  
 tkinter.messagebox
  
 ➤
  
 tkinter.filedialog
  
 ➤
  
 tkinter.simpledialog
  
 ➤
  
 tkinter.colorchooser
  
 ➤
  
 tkinter.font
  
  You only use the fi rst module in this section, but the principle is the same for all of them. 
 Unfortunately, the offi cial documentation is very sparse, so a bit of experimentation at the Python 
 prompt goes a long way. You can try that now with the  
 tkinter.messagebox
  module. 
  
  TRY IT OUT 
 Exploring Tkinter Message Boxes 
  
 In this Try It Out, you play with the various message boxes available in Python’s 
 tkinter.messagebox 
 module. You learn how to incorporate these into a non‐GUI program and how to deal with a couple of 
 minor niggles that arise. Complete the following steps:
  
 1.
  
  Start the Python interpreter and type the following code: 
  
  >>>  
 import tkinter.messagebox as mb
  
  >>> 
 mb.showinfo(""Title"", ""Your message 
 here"")
  
  'ok' 
  
  >>> 
  
 www.it-ebooks.info",NA
 PROGRAMMING GUIS WITH TKINTER,"In this section you fi nd out how to create GUIs using Python’s standard GUI toolkit, Tkinter. All GUIs 
 are built on top of a toolkit of functions or, more commonly, a class library. You look at some of the 
 other toolkits that you can use with Python later in the chapter, but for now the Tkinter toolkit provides 
 a solid foundation for the basic principles. 
  
  You start out by examining some of the basic concepts of GUI design, including how GUI toolkits are 
 structured and used.",NA
 Introducing Key GUI Principles,"Virtually all GUIs are event driven. That means you need to write your code to respond to certain 
 events generated by the GUI toolkit. GUIs come with a whole language of their own in terms of the 
 objects from which a GUI is built. There are windows, frames, controls, and so on. These objects are all 
 connected by something called a 
 containment tree
  . You see what each of these concepts means and how 
 they fi t together to form a GUI in the following sections.
  
  Event‐Based Programming 
  
  You saw how programs can be event driven back in Chapter   2  , “Scripting with Python,” when you 
 explored the parsing of XML and HTML fi les. Essentially, the parsers used an internal loop, and 
 whenever they encountered an item of interest, they sent a message to your code. In effect they called 
 a function that you provided.
  
 NOTE 
  This type of function is sometimes called a “callback” because you register 
 it with the framework and then the framework calls it back. GUI programming 
 uses callback functions extensively.
  
  GUI programs function in a similar manner. The toolkit has an infi nite loop within it and, as the user 
 clicks buttons, moves the mouse, or presses keys, the toolkit generates events that result in functions 
 being called. You write functions and register them with particular events so that when a user selects, 
 say the 
 File
 ‐
 > Save
  menu item, your function 
 doFileSave()
  gets called.
  
  This means the shape of your program code changes. Instead of you controlling the fl ow of the 
 program from beginning to end, you instead initialize your data and then hand control over to the 
 toolkit. This can be an unsettling experience for some programmers at fi rst, but once you get used to 
 it, you will fi nd it actually frees you from a lot of mundane control‐fl ow programming and lets you 
 focus on what your program needs to do.
  
 www.it-ebooks.info",NA
 Building a Simple GUI ,"It’s time to turn this discussion into real code. You start by building the application illustrated in 
 Figure  4-3  in the previous section. The code looks like this (and can be loaded from the fi le 
 demo1.py
  in the  
 Tkinter
  folder of the 
 Chapter4.zip
  fi le): 
  
 import tkinter as tk
  
 # create the top level window/frame 
  
 top = tk.Tk() 
  
 F = tk.Frame(top) 
  
 F.pack(fill=""both"")
  
 # Now the frame with text entry 
  
 fEntry = tk.Frame(F, border=1) 
  
 eHello = tk.Entry(fEntry) 
  
 eHello.pack(side=""left"") 
  
 lHistory = tk.Label(fEntry, text=""     "", 
 foreground=""steelblue"") lHistory.pack(side=""bottom"", fill=""x"") 
  
 fEntry.pack(side=""top"")
  
 www.it-ebooks.info",NA
 Building a Tic‐Tac‐Toe GUI ,"In this section you build a GUI for your tic‐tac‐toe game using exactly the same logic and data layers as 
 previously. This GUI is much closer to the kind of GUI you would expect to see on a modern desktop 
 application, complete with menus, buttons, and mouse interaction rather than relying on keyboard 
 input. By using the same tic‐tac‐toe logic as before, you can focus on the structure of the GUI without 
 thinking too much about how the application itself works.
  
  Sketching a UI Design
  
  When building a substantial GUI application, it often helps to sketch out roughly what you want it to 
 look like before jumping into code. For a tic‐tac‐toe game, you want a menu bar with  
 File
  and 
 Help
  
 menus. The 
 File
  menu has 
 New
  ,  
 Resume
  ,  
 Save
  , and 
 Exit
  menu items. (You could have called",NA
 Extending Tkinter,"The two biggest criticisms leveled at Tkinter are that it doesn’t have enough widgets and it looks 
 ugly. In comparison to the other GUI toolkits, these are valid issues. However, in recent releases, 
 Tkinter has been fi ghting back with the introduction of two new modules built on top of Tkinter. 
 These are  
 tix
  , which adds several new widgets, and 
 ttk
  , which enables  
 theming,
  which basically, 
 just means the GUI can look more like the native OS GUI. 
  
 NOTE 
  Both 
 tix
  and 
 ttk
  are dependent on the underlying libraries from the Tcl/Tk 
 project being installed. If you have problems getting 
 tix
  or 
 ttk
  to work, check that the 
 Tcl/Tk libraries are all installed. Normally, the Python installers do this for you, but 
 sometimes confl icts can arise, and you need to sort things out manually.
  
  Unfortunately, the documentation for these modules is not as comprehensive as you would want, 
 and at the time of writing, the Python documentation often just contains links to the Tcl/Tk 
 documentation. Once you get used to it, you can usually fi gure out what options you need from there, 
 but it’s not ideal. However, the power of the Python interactive prompt comes to the rescue once 
 again, because you can play with them and experiment to fi nd out what they have to offer. Both 
 modules support most of the same Tkinter widgets that you have used so far; so you should be able to 
 take your Tkinter program and convert it to using ttk or Tix fairly easily. For Tix it is as simple as 
 changing the 
 tkinter
  import line as shown:
  
  import tkinter.tix as tk
  
  This is one benefi t of using the 
 tk
  alias when importing—you don’t need to change all your 
 tkinter 
 prefi xes to  
 tix
  ; you simply set the import to use the same alias. You can try that on your tic‐tac‐toe 
 game if you like. It functions identically to the Tkinter version except that the title bar of the window 
 displays 
 tix
  instead of 
 Tk
  . 
  
  For  
 ttk
  it’s marginally more complicated because  
 ttk
  uses the 
 tkinter mainloop
  and top‐level 
 window so you need to import both. You then refer to  
 ttk
  when creating widgets and  
 tkinter 
 when controlling the top window and event loop. You see this in practice later, in the “Using 
 ttk”section. 
  
  Using Tix 
  
  Because  
 tix
  is so similar to  
 tkinter
  , you can translate all you know about 
 tkinter
  into 
 tix
  and 
 jump straight into learning about the new widgets. There are more than 40 of them, but some are very 
 poorly documented, even in the Tcl/Tk community. If you stick to the subset listed on the Python 
 documentation page, you should be fi ne. You only dip a toe in the water here, but hopefully it is enough 
 to demonstrate that  
 tix
  is a valuable addition to the Tkinter family.
  
 www.it-ebooks.info",NA
Revisiting the Lending Library,"You’ve now looked at several parts of the Tkinter toolset. It is time to wrap things up by bringing 
 these pieces together in a larger example based on something less frivolous than a tic‐tac‐toe game. 
  
 You revisit the lending library database that you created in Chapter  3 and build a GUI front end. This 
 will reinforce much of what you have already done, but also introduces some new elements and 
 techniques: 
  
 ➤
  
  The  
 ScrolledListBox
  widget 
  
 ➤
  
  How to capture low‐level events such as mouse double‐click and window‐level events 
  
 ➤
  
  How to create and use custom dialog boxes 
  
 ➤
  
  How to set fonts
  
 ➤
  
  How to activate/deactivate widgets using the  
 state
  attribute 
  
 ➤
  
  How to build a GUI using object‐oriented techniques 
  
  You’ll build this in the following Try It Out.
  
 www.it-ebooks.info",NA
 Exploring Other GUI Toolkits for Python ,"There are many GUI toolkits around, ranging from the very specifi c native toolkits for Windows, 
 MacOS X, and X windows, to more generic, multiplatform toolkits. Most of them have a wrapper layer of 
 some kind available for Python. They all have the same core ideas and concepts that you saw in Tkinter, 
 although some require an object‐based approach while others, like Tkinter, permit a procedural style of 
 programming, too. If Tkinter is not working for you, or if your main area of interest is GUI development, 
 then these other toolkits may hold the answer. In the following sections, you fi nd out about the 
 strengths and weaknesses of each, and for the platform independent toolkits a very short “hello world” 
 style sample program. If you want to run these, you need to install the toolkits because they are all 
 provided by third parties.
  
 www.it-ebooks.info",NA
STORING LOCAL DATA,"In Chapter   3 you saw various strategies for storing data. Earlier in this chapter, you saw how an 
 application can be structured in layers with a data layer at the bottom of the stack. That data layer is 
 concerned with managing the core entities of your application. Those core entities are not the only 
 kinds of data you need to store. You often need to store data about the application itself. That confi 
 guration data is specifi c to a single user or perhaps to the local computer system and hence is called 
 local data. Typically, it is stored in a confi guration fi le or as environment variables. You saw how to 
 read that data in Chapter  2  . In this section you consider the various kinds of local data that an 
 application may need to maintain and the options available for storing it.
  
 Applications have several different types of confi guration data. Some of it is concerned with getting 
 the application to work in the fi rst place, for example, the network address of a server or the 
 location of the data fi les. These values are typically specifi c to a given installation or computer 
 system rather than to an individual user.
  
 Other types of confi guration data are things like user preferences. For example, the user may have 
 some control over the layout of the user interface, the colors used, the location and size of the Windows 
 on screen, and so on. Another common category of user‐confi gured data is the selection of helper 
 applications used, for example, the user’s preferred text or image editing software. Some of these details 
 could be exposed in a preferences dialog that the user edits and explicitly saves. Indeed it may even be 
 possible to store different preferences for different usage scenarios for the same application. 
  
 Other settings may be stored by the application itself so that it can restore itself to the last state when 
 it restarts. These settings might include the last opened fi le, the currently open windows and dialogs, 
 and the screen coordinates of each.
  
 The fi nal data type you might want to store is information about how the application is functioning. In 
 particular, error conditions or unexpected inputs can be recorded. This is generically known as logging 
 and involves storing information in a log fi le that can be examined later either as part of a debug 
 process or to improve effectiveness of the design.",NA
Storing Application‐Specifi c Data ,"Application specifi c data could be stored on the local computer, or it could be stored in a local network 
 location that all instances of the application can reach. This raises the question of how the computer 
 knows where to look. The usual solution to this problem is to set an environment variable or use a local 
 confi guration fi le stored in the startup folder of the application. This can then be set as part of the 
 installation procedure. It can even be provided as a startup parameter.
  
 The advantage of storing this kind of information on the network is that it is shared so that any 
 changes made, for example if the database is moved, can be detected immediately by all of the 
 installed instances on the network without having to manually reconfi gure each machine or user 
 confi guration. It also allows for a backup confi guration to be available in the event of a system 
 failure and by changing one environment variable or confi guration setting on the local computers 
 the new central confi guration can be accessed with minimal downtime. 
  
 www.it-ebooks.info",NA
 Storing User‐Selected Preferences,"User preferences are nearly always stored in the local computer, and often in a confi guration fi le 
 stored in the user’s home directory. Occasionally, applications store user preferences in the main 
 database, especially if the database contains a signifi cant amount of user data anyway. The 
 disadvantage of using the database is that the application can access the preferences only if the 
 database is accessible, which may not be the case if the user is mobile. It is disconcerting for a user 
 to fi nd that the application appears or functions differently depending on whether they are 
 connected to their network or not. Local storage is defi nitely the preferred option for this kind of 
 data. 
  
  Locating the data should be straightforward if a standard fi lename is used and the location is the 
 home directory, because the home directory is nearly always obtainable either as an environment 
 setting or as a user database value. (See Chapter  2 for guidance on how to determine user details 
 such as the home directory.)
  
  The format is normally a text fi le using either Windows INI or XML format. If the number of 
 settings is very large, a small local database using SQLite might be appropriate, but this would be 
 separate from the main application data store.
  
  One other factor to consider when dealing with user preferences is how these are set and modifi ed. If 
 the settings are few and simple in nature (for example boolean or integer values), then it might be 
 acceptable to generate a default preferences fi le and ask the user to manually edit the fi le. This does 
 carry a risk if the user is not familiar with text editors and uses a rich format word processor to edit the 
 fi le. This can render the confi guration fi le unreadable by the application. However, if the users are 
 likely to be experienced in editing text, such as developers or system administrators, then this approach 
 can work well. If the confi guration data is not simple or is stored in a structured fi le using XML or 
 similar, then user editing is much less suitable and error prone, and a preferences dialog needs to be 
 included in the application itself. 
  
  STORING AND NAMING CONFIGURATION DATA 
  
  
  Some operating systems or environments have preferred ways to store confi guration
  
  
 data. Microsoft recommends that Windows applications use the Windows Registry
  
  
 (for which Python provides the 
 winreg
  module). The registry can store data for 
  
  
 individual users or for the computer as a whole. The disadvantage of the registry 
  
  
 is that it is Windows specifi c, and if your code is intended to run on multiple
  
  
 operating systems, you need to have two storage mechanisms, so many developers 
  
  
 prefer to standardize on confi guration fi les even for Windows.",NA
Storing Application State ,"Storing application state is the least standardized form of local data storage. The location and format of 
 the storage is down to the developer. Some applications make the choice of whether to save-state a 
 user preference; others do it automatically, while most do not save state (except perhaps for a list of 
 recently accessed fi les). You need to decide how much state information you want to store, where to 
 store it, and what format to use.
  
 To keep application behavior consistent, you should choose a local storage option so that the 
 application behaves as expected even when disconnected from the network. However, you need to be 
 careful with error handling because, if the application was closed while online but then opened offl 
 ine, many of the resources previously used may not be accessible. You need to have a working 
 fallback confi guration that can be used when things go wrong.
  
 The format of the state data is likely to be quite complex because it may involve multiple windows 
 and even tabs and control settings within windows. This almost inevitably requires a rich storage 
 format such as XML. On the other hand, if you are only saving the open fi le history, a simple text fi le 
 may suffi ce, or you could even append it to the user’s preference data in their confi guration fi le.",NA
Logging Error Information ,"You often want to keep a record of unexpected events or inputs so that you can analyze them later. This 
 could be during testing, following a system failure, or even as a continuous improvement 
  
 www.it-ebooks.info",NA
 UNDERSTANDING LOCALIZATION,"Localization is the name given to the various actions required to make a computer application usable 
 in different localities. That includes such features as time zone differences, date and time formatting, 
 currency symbols, numeric formatting and, of course, language differences. In extreme cases it might 
 require a new UI layout to take account of reading direction, such as right to left.
  
 Your computer operating system likely has many of these features controlled by a confi guration 
 setting, usually created when the operating system is fi rst installed. Most users never change this 
 setting and therefore take it for granted and never think about it. As a programmer your code may 
 have to run on different computers each with potentially different localization options.
  
  In this section you learn about how Python provides support for localization through the use of 
 locales
  
 and the 
 Unicode
  character set. A  
 locale
  is simply a code value that indicates a standardized group of 
 localized settings (time zone, date format, currency, and so on). Unicode is an international standard 
 for representing characters in different alphabets, for example, Latin, Arabic, Chinese, and so on, as 
 well as different symbols such as punctuation marks and math. 
  
  Unicode is all very well in that it enables you to use different alphabets, but how do you 
  
 translate the strings used in your applications into different languages? That process is known as 
 internationalization
  . There is a standard industry process for this using a mechanism called 
 gettext 
 that generates language‐specifi c fi les containing mappings from your embedded strings to the 
 different language versions. Python supports this mechanism via the  
 gettext
  module. Localization 
 includes the ability to select the correct string translation using  
 gettext
  .",NA
 Using Locales,"Python supports different locales via the locale module. The way the module works is quite complex 
 and uses a layered approach; however, mostly you don’t need to know about that. You can use a very 
 small subset and generally you pick up the correct locale for your user.
  
  When your program starts, it is usually set to the “C” locale by default (although that may not always 
 be the case, and local confi guration settings may have changed it). However, you usually want to set 
 the locale that your user has chosen. The way to do that is to call the  
 locale 
  
 .setlocale()
  function with an empty locale argument. This causes the system locale to be selected. 
  
 Most of the time, that’s all you need to do. You are strongly recommended to do this only once in your 
 program and to do so near the start of your code.
  
  You can then use 
 locale.getlocale()
  to fetch the local details if you need to fi nd out what has 
 been set up (you see that in action in the next section where you look at how to translate your 
 program’s strings into the local language). 
  
  Unfortunately, setting the locale is not the end of the story. If you want that change to take effect, 
 there are some changes you need to make to your code. Specifi cally, there are some type conversion 
 and comparison operations that are not locale-aware in the standard library and built‐in functions. 
 To get around that, the locale module provides alternatives. In other cases the standard functions
  
 www.it-ebooks.info",NA
 Using Unicode in Python ,"Computers store data as binary numbers. Characters are mapped onto these numbers so that when 
 the computer prints a string of characters it maps the numeric data in memory to a set of character 
 representations on screen. Back in the dawn of computing, characters were represented by as few as 
 5 bits and more commonly using 7 or 8 bits. All of these encodings could fi t into a single 8‐bit byte of 
 storage, so it was very compact. Unfortunately, a single byte can only cater to 256 different 
 combinations, which is fi ne for the Latin alphabets, used in the Western nations where modern 
 computing originated, but nowhere near enough for all the alphabets in the world as a whole. Over 
 time each country and corporation invented its own encoding system, and software engineers had to 
 write lots of code to cater to these if their software was to be used in different localities. The solution 
 was the Unicode standard. 
  
  Unicode is a 32‐bit character catalog that can store a huge number of possible characters. Unicode 
 characters are represented by entities called 
 code points
  that are the numeric values that map onto 
 characters. Code points are described using the format U+xxxx. The U+ indicates that it is a Unicode 
 code point and the xxxx is the hexadecimal number representing the location of the code point in 
 Unicode (there can be up to 8 hex digits not just 4). Code points are then mapped to characters that also 
 have descriptive names. Thus the character “A” is listed as “U+0041 LATIN CAPITAL LETTER A”. The 
 Python representation of the Unicode encoding is 
 �xxxx
  for 4 digits or  
 �xxxxxxxx
  for 8 digits, which 
 is a fairly obvious translation of the Unicode format, simply replacing U+ with 
 �
  or  
 �
  . The codes and 
 names can all be found on the Unicode website at 
 http://www.unicode.org/Public/UNIDATA/NamesList.txt
  . It is important to realize that Unicode 
 defi nes the character only, not its appearance. What you see as a character on your computer screen, or 
 printed out on paper, is known as a 
 glyph,
  which is a graphical representation of that character in some 
 font or other. Unicode does not specify the font family, weight, size, or any other details about 
 appearance, only the actual character.
  
  The Unicode data has to be stored on the computer as a set of bytes that, as you recall, can only store 
 values from 0–255. The simplest translation, or 
 encoding
 , of Unicode is known as UTF‐32 and is a one-
 to-one mapping from the Unicode code point value to a 32‐bit number. This is simple to understand, but 
 requires 4 bytes for every character, making it very memory and bandwidth hungry. 
  
 To conserve space two other encodings are used. UTF‐16 uses 16‐bit blocks to represent most 
 characters, but with an option to extend that to two 16‐bit blocks for some rarely used characters. 
 Microsoft Windows uses UTF‐16 by default. 
  
 NOTE 
  The extension in UTF‐16 is known as a 
 surrogate
  and is indicated by a block 
 containing a value in the range 0xD800‐0xDFFF. UTF‐8 uses a different scheme 
 whereby if a byte has a value greater than 128 it indicates that it is part of a multibyte 
 sequence.
  
  UTF‐8 stores the most commonly used characters in a single 8‐bit block, but can be extended to use 2, 
 3, or 4 blocks for less commonly used characters. This makes UTF‐8 the most compact format if you 
 are using the right set of characters—specifi cally the Latin alphabet. UTF‐8 also has
  
 www.it-ebooks.info",NA
 Using gettext,"To translate your program strings using the 
 gettext
  mechanism, there is a standard set of steps you 
 need to take. First, you have to use 
 gettext
  functions to identify the strings in your code that you 
 want translated. Second, you run a utility to extract those strings into a template fi le, typically called 
 messages.po
  . After that you have to produce translation fi les based on  
 messages.po
  , ideally by 
 hiring a set of translators or perhaps by trusting Google translate or similar tools! Third, use another 
 tool to convert the translation fi les to the language specifi c  
 .mo
  format used by  
 getttext
  , for 
 example, 
 messages _ en.mo
  for the English version. Finally, you need to ship the folder with the 
 .mo
  
 fi les in it along with your translation. There are various different tools available depending on the 
 operating system. For Windows users there are a couple of scripts in the 
 Tools/i18n
  folder of your 
 Python distribution. For UNIX‐like systems there are operating system utilities available that are 
 Python aware.
  
  You now walk through a simple example—the ubiquitous “Hello world” script. The fi rst step is to use 
 the 
 gettext
  module and its functions to mark your program strings that require translation. You 
 start by creating a new Python code fi le called  
 gettext _ demo.py
  (or load it from the 
 gettext 
 folder of the zip fi le):
  
 import gettext 
  
 import locale as loc
  
 # Set up the locale and translation 
 mechanism 
  
 #############################",NA
 SUMMARY ,"In this chapter you saw the power of structuring applications in layers to separate out the data 
 processing from the core, or business, logic and the presentation. In particular you saw how you could 
 build multiple user interfaces on top of the same core logic and data layers. In the process you explored 
 several variations of command-line interfaces including different styles of user interaction and 
 powerful command-line options. 
  
  You also saw how to build GUI applications using Tkinter, the standard GUI toolkit in Python, along 
 with its ancillary modules that offer more widgets and improved appearance. You concluded this 
 exploration by building a signifi cant user interface on top of an existing data layer using many of the 
 features already explored but using an object-oriented style rather than a procedural approach. Finally, 
 you reviewed some alternative third‐party GUI frameworks that offer even more power than Tkinter 
 should you wish to get more serious about GUI applications.
  
  The chapter looked at some wider issues in building applications for other people to use. It covered the 
 various types of non‐core data (such as confi guration values) that you can store and the options 
 available for each type. You also covered the use of the Python 
 logging
  module to record signifi cant 
 events and how you can manage the levels of logging and how it is stored.",NA
 5 ,"WHAT YOU WILL LEARN IN THIS CHAPTER: 
  
 ➤
  
  Understanding how Python works on the web 
  
 ➤
  
  Creating a web app with Python 
  
 ➤
  
  Connecting a web app to a database 
  
 ➤
  
  Creating an API 
  
 ➤
  
  Parsing and manipulating data in a web app 
  
  WROX.COM DOWNLOADS FOR THIS CHAPTER 
  
  For this chapter the wrox.com code downloads are found at  
 www.wrox.com/go/ 
  
 pythonprojects
  on the Download Code tab. The code is in the Chapter  5 download, called 
 Chapter5.zip
  , and individually named according to the names throughout the chapter. 
  
  Up to this point you’ve been using Python locally to investigate and parse data on your local 
 machine. But what about when you want to use Python for remote data manipulation, or across 
 “the wire”? 
  
  Python is a very powerful language, and it’s not just for doing system administration tasks or fi le 
 system tasks locally. You can use Python across networks to handle tasks using REST and 
 XMLRPC. This chapter looks into both of these, but the focus is on the most popular method of 
 using Python remotely: HTTP using REST. 
  
  In this chapter you use some of the more popular web technologies with Python, including HTTP 
 and REST, to create a web app that links to a database. You use technologies such as Flask and 
 SQLite to complete the web app, and fi nally, you create an application programming interface 
 (API) and learn to parse and manipulate data in the web app. 
  
 www.it-ebooks.info",NA
 PYTHON ON THE WEB,"As you may know, the web is made up of a few technologies, not just one. Figure  5-1  shows a high‐
 level overview of the structure of a modern web app.
  
 Browser
  
 HTML 
  
 CSS
  
 Javascript
  
 CLIENT-SIDE
  
 SERVER-SIDE
  
 API
  
 Python 
  
 Ruby 
  
 Java 
  
 Etc.
  
 Date
  
 SQLite 
  
 SQL 
  
 Postgres 
  
 Redis 
  
 Etc.
  
  FIGURE  5-1: 
  Note the two sides of a web app: client‐side and server‐side. Server‐side data is served via a web server 
 such as Apache or Nginx. 
  
 www.it-ebooks.info",NA
 Parts of a Web Application,"You can serve data across networks in a few ways. Python is a language that 
 can handle almost all of those ways. We briefl y touch on the most common 
 uses of Python as a server‐side language, and then we use the most modern 
 and most common way of using Python on the web: building a web 
 application.
  
  The basic structure of any network request is shown in Figure  5-2  . What 
 happens between “Server Receives Request” and “Server Returns Data to 
 Requestor”? That is where Python lives.
  
  Because browsers can’t ship with every interpreter ever created—and we
  
 Request Is Made
  
  
 Server Receives Request
  
  
  
 Server Returns Data 
   
 to Requestor 
  
 FIGURE  5-2:  
  Structure 
 of a network request
  
 certainly don’t want them to come with compilers—we needed to fi nd a 
  
 way to bridge static pages and dynamic data so that we could have interactive, dynamic web pages. We 
 know that we have a web server that is serving up fi les that make up our web app, but how does the 
 server know what fi les we’re using? How can the server tell that the app is written in Python and not, 
 say, Ruby?
  
  Welcome WSGI! WSGI, or 
 Web Server Gateway Interface
  , is how your web server (like Apache) knows 
 about and can run Python fi les. It is beyond the scope of this book to delve into the 
  
 intricacies of WSGI; just know that most modern web servers support it, and if you want to run Python 
 on a server, that server needs to have WSGI available. If you’re interested in a deeper understanding of 
 server operations and what is known as “DevOps,” it is recommended that you research the more 
 lower‐level technologies, such as WSGI. For our purposes, however, we’ll be using a framework that has 
 already taken care of that piece of server architecture for us and uses WSGI. You will see this term 
 referenced throughout when discussing Python on the web, so hopefully you’ll remember it and 
 understand what part it plays in the grand scheme of things.
  
 www.it-ebooks.info",NA
 The Client‐Server Relationship,"What is a client? In web development, a 
 client
  usually refers to a web browser, which sends out 
 requests to your web server for fi les. However, you will see other uses of the term “client” to mean 
 another server that is requesting data from a second server. For the purposes of this chapter, a client is 
 basically a browser—in other words, the part of the web app that wants to display the data that the app 
 is returning.
  
 This is also the part of the web app that the user will be interacting with. If you’ve ever heard the term 
 “client‐side JavaScript” and never really understood it, this should clear up that confusion: Client‐side 
 JavaScript is JavaScript that is only on the client side and performs actions directly in the client (a web 
 browser), and not on the server. This includes, for example, changing colors or styles on a webpage 
 when certain events are fi red (i.e., a button-click changes the color of a background). These functions 
 never actually talk to a server and can be used locally, if needed (without an Internet connection).
  
  So, what is server‐side JavaScript, then? As you probably guessed, it’s JavaScript that is executed on the 
 server, usually by an event from the client side, such as a GET request or client‐side JavaScript. We 
 won’t be dealing with any server‐side JavaScript in this book because we’re using Python, which is our 
 server‐side language of choice. This is where our logic will live. This is the part of the app that takes the 
 actions from the client and makes magic happen.",NA
 Middleware and MVC,"Middleware
  is a fairly new term in web development. It refers to the part of the technology stack that 
 will take in data from the front end (the client), manipulate it, pass it into or out of the database (or 
 other service that may be running), and then send it back to the front end. Basically, the logic of your 
 system/app should live in your middle layer, your data should live in your data layer, and your styles 
 should live in the front end. It is never ideal to have your front end (JavaScript) doing much data logic, 
 which can be better handled in your middle layer.
  
  All of these pieces actually have a nice name—it is called  
 model‐view‐controller
  (MVC) . Most modern 
 frameworks use some sort of MVC architecture. The benefi t of MVC is that your client doesn’t have to 
 deal with the logic of your app, and your logic doesn’t have to deal with your data models. You can set 
 your data models and forget 'em! (sorta).
  
  Say you’re working on a large project and you have web designers writing your HTML and CSS and 
 some of the JavaScript that makes your web app look slick and shiny. Then you have very smart 
 mathematicians working on your data layer, because you need precise numbers to be calculated from 
 data inputted from your slick, shiny client. What happens if you have your logic code in your client‐side 
 fi les? Let’s say you put your calculations in the templates that the web designers were working on. 
 Furthermore, let’s say that your web designers wanted to manipulate something and they thought your 
 calculation was the problem. This isn’t ideal, is it? MVC somewhat solves this problem by separating 
 out your data layer (the data   
 model
  that is storing your precise calculations), from the 
 controllers
  
 you’re writing to do your precise calculations, with the 
 view
  that your web designers are working on to 
 make a shiny, slick web app.
  
  So, what does all this mean in the Python world? Well, you’re going to come across the term“MVC” and 
 you should understand the overview of the architecture. We use a framework in this chapter that 
 utilizes a sort of MVC architecture, so you should now have a better understanding of why we’ve made 
 most of the decisions we’ve made, moving forward.",NA
 HTTP Methods and Headers ,"HTTP stands for 
 HyperText Transfer Protocol
  . This is the protocol that is used to pass data around on 
 the web, usually via a web browser. When a client makes a request, it uses this HTTP protocol.
  
 This might look familiar to anyone who’s done any web programming with HyperText Markup 
 Language (HTML). HTTP is made to pass HTML. 
  
  HTTP methods are the verbs of the web. The two most basic methods are GET and POST. These do 
 what you might expect. When you send the web server a GET request, you are requesting to 
 get
  data 
 from
  the server. This request, or GET, is used every time you load a web page into your browser. 
  
 So, when you go to twitter.com, your browser is sending a GET request to the Twitter servers and 
 asking for information. 
  
  What about when you type out a tweet and hit the Tweet button? When you are sending data 
 to
   the 
 server, you are using a POST method call. This indicates to the server that you are going to attempt to 
 post
  data 
 to
  the server. (We lightly touch on some other method calls as you go through the process of 
 building your app.)
  
 NOTE 
  If you plan to use Python for web development, it is highly 
  
 recommended that you familiarize yourself with all the HTTP methods available. 
  
  So, how does the web server know what method is being sent? It does this via the HTTP headers 
 (see Figure  5-3  ).
  
  
  FIGURE  5-3: 
  The Chrome Developer Tools, illustrating the headers of a server request for a fi le
  
 www.it-ebooks.info",NA
What Is an API?,"API stands for 
 application programming interface
  . An API is simply the approved way for others to 
 interact with an outside application, without actually having access to the database itself. Take Twitter, 
 for example. How do the many Twitter clients out there get the Twitter data? Does Twitter just let 
 anyone onto its systems? No, not really. Twitter uses an API to allow other developers to utilize its data. 
 The modern use of an API is a RESTful API, meaning that you use URLs to talk to the remote 
 application’s API, and the remote application returns data depending on the data you’ve sent to the 
 specifi ed URL. 
  
 You can fi nd many tutorials online that show you how to use certain libraries in Python to access an 
 API and pull data. You will be going a step farther than that—you will create your own API to serve 
 data. You will then use that API to code up your client‐side fi les to pull in the correct data. But fi rst, 
 let’s look at the data that most APIs return: JSON. 
  
  JSON (JAVASCRIPT OBJECT NOTATION) 
  
  
  If you’ve ever heard the term “JSON” (jay‐sahn), you’ve probably thought it was 
  
  
 some magical secret that only supersmart computer scientists understood. Or you 
  
  
 just thought it was some weird thing that web developers kept going on about.
  
  
 Either way, it’s very easy—almost too easy—to understand.",NA
 WEB PROGRAMMING WITH PYTHON ,"In the preceding section, you took a look at the Requests library. In this section you’re going to see a 
 little bit of the technologies Requests employs under the hood. Then, using the Flask web framework ( 
 http://flask.pocoo.org
  ), you’ll take the lending library, give it a web interface, and make it 
 interactive via a browser. But fi rst, you should understand just how things are working before you put 
 big bows on them.",NA
 Using the Python HTTP Modules ,"Python is incredibly powerful, versatile, and easy to use. Part of the reason for this is all the built‐in 
 functionality that comes with the base Python install. When you install Python, you also get a plethora 
 of modules that you can use. Included in these modules are the 
 http
  modules— 
 http .server
  , 
 r 
 http.client
  —and a few others. In this section you work with the  
 http.server
  module to see just 
 how easy it is to spin up a quick HTTP server so that you can quickly begin serving web pages for 
 debugging/testing purposes. This section also illustrates just how some of the more popular third‐
 party libraries use Python’s built‐in modules to create incredibly powerful tools for the Python 
 developer.
  
  Let’s take a look at the  
 http.server
  module and see just how quickly you can get an HTTP server up 
 and running locally. 
  
  Creating an HTTP Server 
  
  In this Try It Out, you set up, in just a few lines of code, an HTTP server that will run locally and serve 
 up pages that you’ll create and serve out of your local directory. After this exercise, you should have a 
 good idea of just how some of the more popular frameworks and third‐party libraries implement 
 Python’s built‐in modules to harness incredible power to create easy‐to‐use tools.
  
  TRY IT OUT 
 Serving Local Files via http.server 
  
  This Try It Out demonstrates how you can serve fi les in your local directory, via a web browser, to test or 
 debug any code that may need a web server running. This also illustrates just how powerful Python’s 
 built‐in modules can be. 
  
 1.
  
  In your project directory, create a directory for Chapter  5 and, using your editor of choice, create 
 an 
 index.html
  fi le with the following code and save it:
  
 <!doctype html> 
  
 <html> 
  
  
 <head> 
  
   
 <title>HELLO WORLD!</title> 
  
  
 </head> 
  
 <body> 
  
  
 <p> Hello World! I am serving this page via Python! 
 WOWZERS!</p> </body>
  
 </html>
  
 www.it-ebooks.info",NA
MORE ON PYTHON AND THE WEB ,"Creating web apps with Python is incredibly easy. You can do all the heavy lifting yourself, or you can 
 try one of the many open source frameworks out there to help you with it, or help with just a few 
 parts. You can build websites in two main ways with Python: static site generators and full‐on",NA
 Static Site Generators ,"Static site generators are usually used for things like blogs and other documentation—where you 
 may make a new page at a time and want to serve out that page but the content on the page won’t be 
 changing once it’s published. Some of the more popular static site generators include, but are not 
 limited to:
  
 ➤
  
 Pelican:
  Probably the most popular and well‐known static site generator in Python. There is 
  
 also lots of community support, including plug‐ins and themes for Pelican.
  
 ➤
  
 Hyde:
  A little larger than Pelican, with a bit more of a learning curve, but quite robust. 
  
 ➤
  
 Nikola:
  Fully featured, lots of community involvement and support. Also supports custom-
  
 ization, including themes and plug‐ins.
  
 ➤
  
 Mynt:
  Used by 
 www.pyladies.com
  and a few other sites. Mynt lauds itself as having the fea-
  
 tures of a content management system (CMS) without the rigid implementation.",NA
 Web Frameworks,"Web frameworks are all‐in‐one systems that give you the power to create APIs, web apps, and even a 
 comprehensive CMS. Here are a few we recommend:
  
 ➤
  
 Flask:
  Flask is quite versatile, from creating simple APIs that others will access to creating full 
  
 web apps.
  
 ➤
  
 Django:
  Django is quite popular and very robust. It even includes an admin interface that 
  
 allows users to put entries in the database with an easy‐to‐navigate user interface that is 
  
 highly customizable.
  
 ➤
  
 Bottle:
  Bottle is smaller than Flask and simply gives you just what you need to create a website, 
  
 with very little overhead and limited functionality. It’s perfect for smaller websites and pages.
  
 ➤
  
 Pyramid:
  Pyramid is similar to Flask in that it can be used for small projects, but you can also 
  
 use it for larger projects, and it can be scaled up as needed. 
  
  Of course, many more web frameworks are available. We recommend fi nding one that suits you and 
 your project, or just play around with a few to fi nd one you feel more comfortable with.",NA
 USING PYTHON ACROSS THE WIRE ,"You can do many different tasks across a network connection. Whether that connection is the public 
 Internet, a local area network, or a private network, you can process data, serve web pages, and even 
 run Python scripts remotely. This section introduces a few of the simple, different ways you can run 
 Python across a wire. None of the examples are production‐ready code, but this should be a good way to 
 get you familiar with the different powers Python can provide.
  
 www.it-ebooks.info",NA
 XML‐RPC ,"XML‐Remote Procedure Call (XML‐RPC) is an older technology that is still used in a few legacy systems. 
 This is how data was once processed across the Internet, using XML. We now use JSON to pass data 
 back and forth; however, some systems still use XML and require remote procedural calls.
  
 Because of this Python has a built‐in XML‐RPC module. Let’s make one and watch it in action. 
  
  In this Try It Out, you set up, in just a few lines of code, an XML‐RPC server that will run locally in one 
 Terminal and serve up a simple Python script, which you create. You then open another Terminal 
 window and run the code remotely. 
  
  TRY IT OUT 
 Running Python Code Remotely 
  
  This Try It Out demonstrates how you can serve fi les in your local directory, via an XMLRPC server.
  
 1.
  
  Open your Python interpreter and import the  
 xmlrpc.server
  object from the 
 SimpleXMLRPCServer module:
  
  Python 3.3.3 (default, Feb 14 2014, 12:35:03)
  
  [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwin  
 Type ""help"", ""copyright"", ""credits"" or ""license"" for more 
 information.
  
  >>> 
 from xmlrpc.server import SimpleXMLRPCServer
  
 2.
  
  Similar to the HTTP code earlier in the chapter, you have to create a server object. You also want to 
 create some sort of system feedback that will tell you that your code is working:
  
  >>> 
 server = SimpleXMLRPCServer((""localhost"", 8080))
  
 3.
  
  Set up your server with the code you will be running, in this case a simple function that will square a 
 number that is passed in:
  
  >>> 
 def square(n): 
  
 ...    return n * n 
  
 ...    print(""We've got a connection and are listening on port 
 8080...huzzah!"")
  
 4.
  
  Next you’re going to register your function, so that it can be used by the client code you’ll be 
 creating in just a moment:
  
  >>> 
 server.register_function(square, ""square"")
  
 5.
  
  Finally, you want to start the server:
  
  >>> 
 server.serve_forever()
  
  You should now see your print statement print out to let you know that you’re serving on port 
 8080. 
  
  Do not close this Terminal or stop the process; you need it to continue running to complete the 
 next part of the example. 
  
 6.
  
  Open a new Terminal window, start a Python interpreter, and import the  
 xmlrpc.client
  library: 
  
  Python 3.3.3 (default, Feb 14 2014, 12:35:03)
  
  [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwin  
 Type ""help"", ""copyright"", ""credits"" or ""license"" for more 
 information.
  
  >>> 
 import xmlrpc.client",NA
 Socket Servers ,"If you’ve ever heard anyone talk about “Websockets” or “streaming data,” they’re usually talking about 
 TCP and socket servers. These servers utilize TCP, or 
 Transmission Control Protocol
  . You may have 
 heard of TCP/IP, which this is the same thing. Python, of course, has some built‐in libraries that can 
 enable you to create TCP sockets to send and receive data between two points using the Internet 
 Protocol.
  
  In this Try It Out you get a bit more involved with some Python, and do some things in a more 
 “pythonic” way. You’re going to again set up a server and a client, so you’ll need two Terminal 
 windows running to complete this task. However, you’re also going to create a class to handle your 
 TCP requests to illustrate the use of classes in Python. 
  
 www.it-ebooks.info",NA
 MORE NETWORKING FUN IN PYTHON,"You may be interested in delving a bit deeper into networking with Python. If so, here is a short list of 
 some of the more popular networking libraries available for download: 
  
 ➤
  
 Twisted (
 http://twistedmatrix.com
 ):
  Twisted is very large, very powerful, and full of 
  
 networking goodness. However, as of this writing it is not fully functional with Python 3.
  
 If you’re interested in doing some event‐driven networking, Twisted is for you. Support for 
 SMTP, POP3, IMAP, SSHv2, and DNS is included. So if you’ve always wanted to make your own 
 e‐mail server, you and Twisted may be a match made in heaven. If you’re interested in setting 
 up your own SSL server—get Twisted!
  
 ➤
  
 Tornado (
 http://www.tornadoweb.org
 ):
  Tornado is lauded as a web framework and 
  
 asynchronous networking library. Mainly made for larger applications that may need long‐
  
 lived connections, Tornado uses non‐blocking I/O and is perfect for Websockets and long 
  
 polling. We put Tornado in the “networking” section rather than the “web frameworks”
  
 section because it’s more focused on the networking side of web frameworks than on creating 
  
 templates and making things pretty.
  
 ➤
  
 gevent (
 http://www.gevent.org
 ):
  According to gevent’s own website, gevent is “a 
  
 coroutine‐based Python networking library….that provides a high‐level synchronous API…”
  
 When you need to do some crazy coroutines across your network, you may want to take a 
  
 gander at gevent. Currently, gevent is only for Python 2. 
  
  You should now have a good idea of the power and ease with which Python can be used to send and 
 receive data across the wire. If you’re interested in any sort of data passing using Python, this 
 chapter should have given you a nice jumping-off point to go explore more and hopefully create 
 interesting things with your discoveries.
  
  Python’s community is full of helpful people, so if you happen to fi nd a framework or library that you 
 particularly like, join the mailing lists, the IRC channels, and any other conversations you can fi nd. 
 Contribute to those projects, and help the communities grow larger and stronger. Participation in 
 technologies that you fi nd interesting and/or helpful not only helps the projects and organization that 
 is offering the technology, but it helps all developers who may need to use or want to learn that 
 technology. 
  
 www.it-ebooks.info",NA
 SUMMARY ,"You started off this chapter by learning about how Python works on the web. The front end of a web 
 app consists of a browser that handles the HTML, CSS, and JavaScript. The middle layer, in this case, is 
 Python. The back end houses your database (SQLite) and web server. You also learned about APIs 
 (application programming interfaces), which is the approved way for others to interact with an outside 
 application, without actually having access to the database itself. Next, you practiced using a third‐
 party API and the Requests library. Along with that, you explored the technologies Requests employs 
 under the hood. Then, using the Flask web framework, you took the lending library, gave it a web 
 interface, and made it interactive via a browser. Finally, you learned a few of the various easy ways you 
 can run Python across a wire. 
  
 EXERCISES 
  
 1.
   Consider our code from earlier in this chapter: 
  
  >>>for result in results['results']:
  
  ...     id = result['id']
  
  ...     print(id) 
  
  ...     print (result['id']) 
  
  ...     details = requests.get(market + id).json() 
 ...     print (details)
  
  ...     print (details['marketdetails']) 
  
  ...  print 
 (details['marketdetails']['GoogleLink']) 
  
  Using what you know about Python, can you fi gure out a way to create a list comprehension that 
 will do the same thing as the preceding code? Remember that list comprehensions are 
 constructed like this:
  
  [expression for item in list if conditional] 
  
 2.  Using what you know so far about how to use fi les in Python, can you save the output of your call to 
 the USDA's API to a fi le on your machine, to parse later? (Is saving it as a .txt fi le fi ne?) 
  
 3.  Can you fi nd the docs for Flask that would help us to break our app into smaller, modularized fi les 
 with our endpoints/views in a separate fi le, rather than having one big Python fi le with 
 everything in it? (Hint: It is one concept/feature that Flask offers.) 
  
 4.  What other HTTP methods can you fi nd? Can you fi nd ways to use them in a Flask app?
  
 5.  By reading the Requests docs, can you fi nd the method call needed to output the HTML of a website 
 by passing the URL to a requests method?",NA
 6 ,"WHAT YOU WILL LEARN IN THIS CHAPTER: 
  
 ➤
  
  Testing your Python code 
  
 ➤
  
  Debugging your Python code 
  
 ➤
  
  Handling errors in your Python code 
  
 ➤
  
  Structuring and releasing your Python code 
  
 ➤
  
  Tuning the performance of your Python code
  
  WROX.COM DOWNLOADS FOR THIS CHAPTER 
  
  You can fi nd the wrox.com downloads for this chapter at  
 www.wrox.com/go/pythonprojects 
 on the Download Code tab. The code is in the Chapter  6 download, called  
 Chapter  6  .zip
  , 
 and individually named according to the names throughout the chapter. 
  
  So far you’ve looked at many ways to use Python. You’ve made local scripts to handle small tasks, 
 you’ve handled medium‐sized tasks locally, and you’ve even made a small web app using Flask. 
 But what if you fi nd yourself in the midst of a larger project? Python, as you have seen by now, is 
 a very powerful language. It’s also very open, meaning you, the developer, have access to all 
 aspects of the language. This openness, however, makes testing your Python code more important 
 than ever. Every object in Python is a fi rst‐class object, so you can change and manipulate any 
 object available to you. Because you can change and manipulate objects, you must make sure to 
 test and verify the logic of our code. 
  
  Python is not a “typed” language in the same way that C and Java are explicitly typed. You can 
 pass objects around in Python and the interpreter will try to manipulate them to the best of its 
 ability. If it cannot perform an operation on an object or data that is available, however, it raises 
 an exception, which causes your program to crash. So, how can you prevent this? 
  
 How can you write code, share that code, and guarantee that others can use it and that the 
 code will function as expected? Testing. 
  
 www.it-ebooks.info",NA
 TESTING WITH THE DOCTEST MODULE ,"The simplest form of testing in Python is the doctest module. This module is made for testing the 
 simpler parts of your code, to verify that it will function as expected, as written in your document 
 strings (triple quotes 
 '''...'''
  or 
  """"""...""""""
  , single or double quotes will both work). Doctest tests 
 are written like this: 
  
  ''' 
  
  this function should take in a number and return its squared 
 value  >>> sq(3)
  
  9 
  
  ''' 
  
  def sq(n):
  
  return n*n 
  
 WARNING 
  With doctest, your code indentation matters. The indentation of your fi rst 
 line dictates further indentations, so you are committed to that pattern. Your doctest 
 strings will be fed into the interpreter exactly as you have written them—if the 
 interpreter is expecting a certain indentation, you need to make sure your doctest 
 strings have that indentation pattern.
  
  Also, keep in mind that as Python changes and evolves, indentation patterns may 
 change, so your doctest strings may fail in the future. This is one reason why many 
 people do not rely heavily on doctest for signifi cant testing. 
  
  The usual way of writing doctest tests is to use the interpreter, write the code, and then run it in the 
 interpreter. Then you copy and paste the interpreter text into the doctest string, as follows: 
  
  Python 3.3.3 (default, Feb 14 2014, 12:35:03)
  
  [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwin  
 Type ""help"", ""copyright"", ""credits"" or ""license"" for more 
 information.
  
  >>> def sq(n): 
  
  ...     return 
 n*n 
  
  ... 
  
  >>> sq(3)
  
  9 
  
  >>> 
  
  So you would simply copy the following lines, and put them in your doctest strings: 
  
  >>> sq(3)
  
  9 
  
  Doctest is not suitable for testing of large, complicated methods or functions. But it is really good 
 at“contract programming.” By using doctest strings and saying “this function, when passed a 3 as an 
 argument, will return a 9” and then calling the function, you are setting up a contract: if you pass a 
 certain piece of data, the function will behave as you expect it to. However, you cannot test every 
 possible outcome, so doctest will hit its limitations fairly quickly with larger projects.
  
  In the following example you create and then run a small Python script with some doctest strings to 
 test your code.",NA
 TESTING WITH THE UNITTEST MODULE,"What if you need signifi cant testing and you want to verify that your codebase is operating as 
 expected? This is a job for the unittest module. This module is more robust than the doctest module, 
 and will test your code thoroughly. Unittest is like the baseline testing module on which most testing 
 libraries are based. It is also an excellent introduction to test‐driven development (TDD) in Python. 
  
  The term   
 unit test
  is not unique to Python. If you’re familiar with other languages and 
  
 programming, you have no doubt heard of unit testing. Unit testing is simply testing your code in 
 units. So, if you have fi ve functions in your code, you want to have a minimum of fi ve units in
  
 www.it-ebooks.info",NA
 TEST‐DRIVEN DEVELOPMENT IN PYTHON,"A term that is becoming more and more popular in the Python community is   
 test‐driven 
  
 development
  (TDD). What exactly does that mean? Although TDD is a very important topic when it 
 comes to Python development, it is also a very robust topic. Therefore, this section gives only a very 
 brief introduction of TDD so that you can familiarize yourself with the term and its basic defi nition.
  
  TDD simply means writing your tests fi rst. Most developers groan when they hear the word“testing.” 
 They think it means longer development time and more effort on their part, and less of the fun stuff like 
 writing the actual code that will make their project run. However, testing can be just as fun as the other 
 stuff. And although it does require the developer to write more lines of code, it leads to better quality 
 code and more maintainability later on in the project. Your future self and co‐collaborators will thank 
 you for taking the time to write tests fi rst and develop against those tests. 
  
  So, how exactly does TDD work? Write tests! It’s really that simple. There is, of course, an art form to 
 writing good tests, and it’s important that you take the time to study up and become familiar with 
 proper TDD practices. Here are the basics:
  
 1.
  
  Write tests fi rst.
  
 2.
  
  All tests should fail at fi rst.
  
 3.
  
  Write code.
  
 4.
  
  Test code against tests. 
  
 5.
  
  Rewrite code.
  
 6.
  
  Retest code against tests. 
  
 7.
  
  Repeat until all tests are passing. 
  
  This is the gist of TDD. You can probably see why doctest may not be the best answer for all testing 
 situations. Once you have to test and retest, and you begin testing more complex ideas, doctest will hit 
 its limitations. As stated, there is an art to writing  
 effective
  tests, however, and that is where the beauty 
 of TDD comes in.",NA
 DEBUGGING YOUR PYTHON CODE ,"Most developers will likely tell you that they hate debugging. It’s tedious, persnickety, and can 
 become rather boring or infuriating fairly quickly. It doesn’t have to be this way. Taking a new look at 
 debugging and testing can make even the most cynical developer a little less irritated. 
  
  When you run into a bug with your code, rather than think about how annoying it is (don’t worry, it’s 
 the natural reaction), think about how this is actually an opportunity to learn. Something is broken 
 somewhere, some stone has gone unturned. This is your chance to fi nd that stone, turn it
  
 www.it-ebooks.info",NA
 Handling Exceptions in Python ,"Python is an interpreted language, which means that there is no compiler to compile your code and fi 
 nd any logic or syntax errors before you run it. So how does Python handle this? Python uses exceptions 
 to handle errors. This type of handling can mean that making one small mistake in your code can cause 
 your entire program to fail. Because of this you want to test thoroughly, but on top of that, you also 
 want to set up some fail-safes in case you encounter exceptions with your code during run time. 
  
  For example, if you try the following code in your interpreter,
  
  >>> def sum(a, b): 
  
  ...     return a + 
 b
  
  ... 
  
  >>> sum(""no"", 4) 
  
  you’ll get the following error:
  
  Traceback (most recent call last):
  
  
  File ""<stdin>"", line 1, in <module> 
  
  
  File ""<stdin>"", line 2, in sum
  
  TypeError: Can't convert 'int' object to str 
 implicitly 
  
  As you can see, when you try to pass a string to a mathematic function, which can only operate on 
 integers and fl oats, it throws a 
 TypeError
  . This tells you that the data you sent to the function is not of 
 the correct type. Because Python is not a strongly typed language, nor is it compiled, the only errors 
 that you will get are exceptions, which will crop up at run time. When an exception is thrown at run 
 time, your entire program will quit if there is no exception handling in place. It is imperative that you 
 check for these sorts of “gotchas.” Not checking for them can render your code unusable, and that’s not 
 a very good codebase to have!
  
  A number of exceptions are built into the Python language. Here is a list of those exceptions:
  
  BaseException 
  
  +-- SystemExit 
  
  +-- KeyboardInterrupt
  
  +-- GeneratorExit 
  
  +-- Exception 
  
  
  +-- StopIteration
  
  
  +-- StandardError
  
  
  |    +-- BufferError 
  
  
  |    +-- ArithmeticError 
  
  
  |    |    +-- FloatingPointError 
  
  
  |    |    +-- OverflowError
  
  
  |    |    +-- ZeroDivisionError
  
  
  |    +-- AssertionError 
  
  
  |    +-- AttributeError",NA
 WORKING ON LARGER PYTHON PROJECTS,"When developing with Python you may fi nd that different projects have different versions of different 
 packages. What do you do when your local environment is Python 2.7, but that project you want to 
 work on (or inherited) is 2.6? Or 3.4? This is a problem that many Python developers have 
 encountered, so of course they created a solution. Enter virtualenv.
  
 Virtualenv
  is a virtual environment for your Python projects. It enables you to create numerous 
 Python instances and develop against all the libraries you need for certain projects. Say you want to 
 work on a project that uses Python 2.7, which you have installed locally, but the project needs a",NA
RELEASING PYTHON PACKAGES,"The  
 __init __.py ('dunder, init, dunder')
  fi le is fairly important when releasing code out into 
 the wild. For Python projects,  
 __init __.py
  needs to be at each level of the codebase’s directory 
 structure. For example, say you have a rather large codebase that has multiple  
 .py
  fi les. You start by 
 putting a  
 __init __.py
  in the fi rst layer of the directory structure:
  
  my_package
  
  
  
  |----__init__.py
  
  
  |---- my_package.py
  
  
   
  |---- my_subpackage 
  
  
   
  
  |---- __init__.py
  
  
   
  
  |---- my_subpackage.py 
  
 This tells the Python interpreter that you want to treat the directory as a Python package. The cool part 
 is that you can leave the  
 __init __.py
  fi le empty, or you can put confi guration variables in it. 
 Commonly, folks will import modules/libraries, or other confi gurations in their 
 __init __.py
  fi le—
 basic setup work to help the package function. 
  
 So what happens when you create an  
 __init __.py
  fi le and import something? How does Python’s 
 namespacing work now? Suppose you have the following import statement in  
 my _ package/ __ 
 init __.py
  :",NA
SUMMARY ,"We’ve looked over some of the basics of testing and packaging for your Python projects. You should 
 now have a clear idea of just how most Python packages and modules/libraries are architected and 
 created. A good exercise for the reader is to go back through the beginning of the book and work 
 through the exercises using the concepts you’ve learned in this chapter. Can you rewrite the code in 
 Chapter  3   to be test‐driven? Can you package your Flask app from Chapter  5 and send it to another 
 computer to be run and developed? You should try these things out so that you have a clear idea of just 
 how all parts and pieces of Python packages are working together. 
  
 EXERCISES 
  
 1.
   In the zip fi le for this chapter, open the fi le 
 markets.py
  and write a doctest string to test the value 
 being returned by the function in the fi le. Can you think of a reason why a simple doctest string in 
 this code could be incredibly useful for maintaining the code in the future? 
  
 2.
   Write a unittest for a function that will take a string and return that string reversed. Make sure 
  
 the test fails, because you haven’t written the function to test, yet. 
  
 3.
   Write a function for your unittest that takes a string and returns the reverse of that string. Now, 
  
 run your unittest against that function and modify the function until it passes.",NA
 7 ,"WHAT YOU WILL LEARN IN THIS CHAPTER: 
  
 ➤
  
 Specialist application areas using Python
  
 ➤
  
 Third‐party packages for specialist applications
  
 ➤
  
 How to contribute to Python’s development
  
  WROX.COM CODE DOWNLOADS FOR THIS CHAPTER 
  
  There are no Wrox code downloads for this chapter, but the various solutions discussed all 
 have packages that are available for download. Many of these are available via the Python 
 Package Index (PyPI) or have binary installers that you can download from the package’s 
 home site. Each section provides information about download locations for the associated 
 packages.
  
  In the earlier chapters of this book, you looked at how Python can be used to interact with your 
 operating system and other programs, how it can manage data using fl at fi les and databases, and 
 how you can build both desktop and web‐based applications. You have also seen some of the 
 techniques and tools that can help you build larger scale programs effi ciently and reliably.
  
  In this concluding chapter, you see how Python can support you in many wider areas of 
 programming. You consider the various frameworks, packages, libraries, and even distinct 
 Python distributions that have been developed to support specialist areas of interest such as 
 science and language processing. You also see how some niche application types have acquired 
 specialist tools and packages to support their specifi c needs. Finally, you look at how you can 
 contribute to the Python community itself to help make Python even better. 
  
 www.it-ebooks.info",NA
 DRAWING PICTURES WITH PYTHON ,"Many tools are available for drawing and processing graphics in Python. These range from simple 
 drawing libraries like  
 turtle
  to highly specialized modules and frameworks like 
 matplotlib
  and 
 Pillow
  . The following sections describe the capabilities and areas of application of each option.",NA
 Using Turtle Graphics ,"The easiest way to draw pictures from code is probably to use 
 turtle graphics
  . Turtle graphics was 
 invented as a way of drawing pictures using the programming language Logo. The idea was to issue 
 directional commands to a robotic device—the turtle—with a pen attached that, in turn, produced a 
 drawing. The concept proved popular, and now most languages provide some kind of turtle graphics 
 support. In Python, it comes in the form of the 
 turtle
  module. By default, the module presents the 
 graphics in a small pop‐up window built using Tkinter. You can specify a Tk canvas object (see the 
 next section for more details about canvas objects) when you initialize the turtle system from within 
 an application, or you can use the module at the interactive prompt to experiment with the system. 
 The offi cial documentation gives a comprehensive description of the functions and methods 
 available, and you can get a good feel for what is possible by running the demonstration. Type the 
 following at the OS command prompt: 
  
  python -m turtledemo
  
  This brings up a window with a menu of examples that you can start and stop, and also displays the 
 code of the running example so that you can see how to achieve the same effects in your programs.",NA
 Using GUI Canvas Objects ,"Most GUI frameworks include a 
 canvas
  object. A canvas is an area on-screen in which you can draw 
 lines and shapes, add images, and even insert text. The Tkinter 
 Canvas
  object is fairly typical and 
 supports drawing arcs, ovals (including circles), lines, rectangles, polygons, text, images, and even 
 windows (so you can embed a widget inside a canvas). A minimal canvas program showing a red circle 
 looks like this:
  
  >>>  
 import Tkinter as tk
  
  >>>  
 top = tk.Tk()
  
  >>>  
 c = tk.Canvas(top, width=50, height=50)
  
  >>>  
 c.pack()
  
  >>>  
 c.create_oval(10,10,40,40,outline='red',fill='red')
  1 
  
  >>>  
 top.mainloop()
  
  The  
 Canvas
  class contains many, many methods that enable you to build sophisticated graphics 
 programs.
  
  This is all at a very low level of abstraction. For a higher level you can turn to other libraries such as 
 the 
 turtle
  module discussed earlier, or some more exotic, third‐party options such as those 
 discussed next.
  
 www.it-ebooks.info",NA
 Plotting Data,"The most popular data‐plotting tool for Python is  
 matplotlib
  , which you can fi nd at  
 http:// 
 matplotlib.org/
  and downloaded from PyPI or included as part of the 
 scipy
  package discussed 
 later in this chapter. The website includes links to many examples and tutorials.
  
 matplotlib
  is closely tied into the other 
 scipy
  packages and, as such, can be rather intimidating if you 
 only want a simple graph. Several other lightweight packages are available on PyPI that attempt to 
 address this and provide an easier‐to‐use plotting library, but for serious plotting 
 matplotlib
  is the 
 best solution.",NA
 Using imghdr ,"If your graphics interests are more focused on images than data, the 
 imghdr
  module offers some useful 
 help in determining what kind of image fi le you are dealing with. The module is part of the standard 
 library and is quite simple to use. Rather than relying on the fi lename extension, it tests the data 
 content of the fi le to determine the image type.
  
  The module consists of a single function,  
 what()
  , which takes either a fi lename or fi lestream as 
 an argument and returns the image type. The module supports most common fi le types, but you can 
 extend its range by adding your own custom test functions to handle other image types.",NA
 Introducing Pillow,"For many years the standard solution for manipulating images in Python was the Python Imaging 
 Library (PIL). PIL has not been ported to Python version 3; instead, a replacement library, called 
 Pillow, has been created that builds on PIL but adds some new features.
  
  Pillow’s homepage is at 
 http://pillow.readthedocs.org
  . You can install it via PyPI.
  
  Pillow is based on an 
 Image
  class that can be opened and saved. By specifying the appropriate 
 parameters, converting a JPEG fi le to a PNG fi le, for example, can be as simple as this: 
  
  >>>  
 from PIL import Image
  
  >>> 
 Image
 .open('foo.jpg').save('foo.png')
  
  You can also use the  
 Image
  object to retrieve information about the image, such as its size. Many more 
 powerful options are available, too. For example, you can transpose images by fl ipping them or rotating 
 them, as well as resizing and applying fi lters. Pillow is like an image editing program that you drive 
 programmatically.",NA
 Trying Out ImageMagick ,"ImageMagick is a similar tool to Pillow, but it’s based on the command‐line suite of tools of the 
 same name. The command‐line website is at  
 http://www.imagemagick.org/
  . 
  
  The Python package, 
 wand
  , is on PyPI and uses 
 ctypes
  to harness much of ImageMagick’s power. You 
 can fi nd the website here:  
 http://docs.wand
 ‐
 py.org
  . The site has documentation, including a user 
 guide and references.",NA
 DOING SCIENCE WITH PYTHON,"Python has a long tradition of use within the scientifi c and mathematical communities. As a result, 
 many modules and packages have been created to meet the specialized needs of the communities. 
 Before looking at the third‐party options available, you should fi rst consider the built‐in support that 
 Python offers. 
  
  Python’s native types offer much for scientifi c computing. In particular, the Python integer type with 
 its effectively unlimited size makes it well suited for working with large volumes and long series 
 calculations. Python’s fl oating‐point type is comparable to that of other languages, but in addition you 
 have the options of using decimal and fraction types that reduce errors due to rounding. Finally, Python 
 is one of the few languages that natively supports the complex, or “imaginary,” number type used so 
 extensively in science and engineering applications. 
  
  Of course, having a variety of data types is only half the story; along with the data you need operations 
 to support them. Once again, Python’s built‐in operations are supplemented by the standard library 
 with modules like  
 math
  , 
 cmath
  , and  
 statistics
  providing a wide range of options.
  
 Modules, such as the  
 collections
  module, also provide support for more exotic data types like 
 named tuples, ordered dictionaries, and chain maps—used as an effi cient way to link multiple 
 mappings. 
  
  Although these are all powerful tools, they still do not provide the specifi c support needed for 
 performing detailed scientifi c analysis, and this is where the special third‐party libraries come into 
 play. Chief among these is the SciPy package, discussed next.",NA
 Introducing SciPy,"SciPy has a long history, evolving out of several independent development streams. These have 
 gradually come together to form a powerful integrated whole. The SciPy project incorporates six 
 separate bundles that form an integrated “stack” of tools. You can fi nd the SciPy website at 
 http://www.scipy.org/
  . 
  
  The six bundles are:
  
 ➤
  
 NumPy:
  One of the oldest mathematical packages for Python and the foundation of many 
  
 others. NumPy includes a set of types and operations suitable for numerical analysis and 
  
 simulations. These include an N dimensional array object, linear algebra, Fourier transforms,",NA
 Doing Bioscience with Python ,"One area of science that has come to the fore in recent years is bioscience, and particularly the 
 analysis of DNA. The bioPython package has been developed to meet this need ( 
 http:// 
 biopython.org/
  ). The package includes support for reading and writing most of the standard fi les 
 used in bioinformatics as well as a  
 Sequence
  class for analyzing DNA sequences.
  
  In addition to bioPython, some other modules are available, and you can fi nd them using your 
 preferred search engine. Before trying to reinvent the wheel, it is always wise to check whether 
 somebody else has already done the work for you!",NA
 Using GIS,"With the explosion of satellite navigation and mobile electronic mapping software, the fi eld of 
 Geographic Information Systems (GIS) has seen an upsurge of interest. ArcGIS (
 https://www 
 .arcgis.com
  ) is a standardized set of tools for geo‐processing. Python support for ArcGIS comes in the 
 form of ArcPy, a package that has the goal of providing “access to geo‐processing tools as well as 
 additional functions, classes, and modules that enable you to create simple or complex workfl ows 
 quickly and easily.”
  
  There is one big problem. At the time of writing, ArcPy is only available for Python v2.7, not for 
 Python v3. However, for GIS processing ArcPy really is the best option currently available.",NA
 Watching Your Language ,"The study of human language and processing natural languages into data has been an area of study for 
 many years. There have been rapid advances in recent years, and with increased computing power 
 natural language processing is starting to appear in mainstream projects.
  
  Python has the Natural Language ToolKit to support this area, and its homepage is located at 
 http://www.nltk.org/
  . The toolkit provides access to several specialized tools and enables 
 programmers to parse and tokenize text, analyze its structure, and categorize it. You can fi nd and 
 install NLTK from PyPI.",NA
 Getting It All ,"Although all of the previously discussed packages are powerful tools, getting them installed into a 
 standard Python distribution can be a complex process using the normal installation tools. 
  
 Fortunately, you have alternatives in the shape of Anaconda and Enthought Canopy. These are 
 distributions of Python packaged up with all of the science tools you are likely to need. In addition to 
 the SciPy and NLTK frameworks already discussed, Anaconda has more than 100 other specialist 
 packages built in. The distribution is made available by Continuum Analytics, which also offers other 
 packages on a commercial basis. Canopy is a very similar concept with a free basic version available as 
 well as enhanced, commercial offerings. 
  
  Anaconda can be installed on Windows, Mac OS, or Linux and does not interfere with existing 
 installations of Python. Anaconda supports Python versions 2.6 through 3.4 at the time of writing.
  
 The Anaconda homepage is located at 
 https://store.continuum.io/cshop/anaconda/
  . 
  
 www.it-ebooks.info",NA
 PLAYING GAMES WITH PYTHON,"You have already seen how Python can be used to build basic games in Chapter   4  , “Building Desktop 
 Applications,” where you built several variations on the classic tic‐tac‐toe game. However, most game 
 players today expect something a tad more exciting and dynamic. Python can support many types of 
 games and has comprehensive support for generating random numbers, an essential part of any game, 
 built right into the  
 random
  module of the standard library. The module has functions that can simulate 
 dice rolls, pick random choices from a selection, or just generate a random number in a variety of 
 formats.",NA
 Enriching the Experience with PyGame,"If you want a rich game experience using multimedia, the PyGame third‐party package is a good place 
 to start. It provides a set of modules that encapsulate the Simple DirectMedia Layer (SDL) that enables 
 programs to access audio, keyboard, joystick, and graphics hardware. It is also cross‐platform, so 
 PyGame works with most popular OSes. It is modular so you only need to use the bits that are useful 
 to you, keeping your code small.
  
  Its website at  
 http://www.pygame.org
  includes many example programs, as well as several tutorials. 
 PyGame has an active community of users for help and support. Several books on building games using 
 Python and PyGame are also available.",NA
 Exploring Other Options ,"PyGame is not the only gaming‐focused library. You can use several other options. One example is 
 Pyganim, which is a sprite animation module built on top of the PyGame infrastructure, but easier to 
 use. Albow is a GUI toolkit specifi cally targeted at building games with PyGame. Many other packages 
 are written on top of PyGame, bearing witness to its popularity as a foundation games framework.
  
  Of course, you don’t have to use PyGame. Other packages access the low‐level hardware and 
 libraries. PyOpenGL, as the name implies, provides access to the OpenGL libraries.
  
  One feature of gaming that is also supported is the back‐end physics engines needed to model the 
 real‐world behavior of physical objects. Python also has tools to support this in the shape of packages 
 like 
 pymunk
  for 2‐D modeling. Panda3d and the Python Computer Graphics Kit (
 cgkit
  ) provide 
 support for 3‐D.
  
  In addition to graphics, most games also need sound. For that you can use built‐in modules in the 
 standard library including  
 aifc
  ,  
 wave
  , and 
 sunau
  . The  
 winsound
  module provides low‐level access 
 to Windows sound facilities. On top of these low‐level libraries, the gaming community has built 
 several packages to assist in generating suitably exciting sounds to accompany your action. 
  
  Many other libraries are available, too. In fact, the number of options available for the games 
 programmer can be bewildering. You can fi nd a useful summary at  
 https://wiki.python.org/ 
 moin/PythonGameLibraries
  . 
  
 www.it-ebooks.info",NA
 GOING TO THE MOVIES ,"Python has a long history in the movie business, with several computer‐generated imagery (CGI) 
 studios adopting Python as a scripting engine. Several well‐known movies had Python doing some of 
 the production work behind the scenes. To support this, various packages have been developed and 
 made available to a wider audience.  Examples include Nuke, Maya, and Blender. Many of these are built 
 on a foundation provided by the 
 cgkit
  package mentioned in the “Playing Games with Python” section 
 earlier in this chapter. This means that you have lots of scope for using Python while creating and 
 editing your next video masterpiece.",NA
 The Computer Graphics Kit ,"The  
 cgkit
  package provides a set of low‐level types and operations needed to create 3‐D scenes. It 
 also provides a rendering engine, although the results can be displayed in other rendering engines if 
 required.  
 cgkit
  includes bindings to the Pixar RenderMan API.  
 cgkit
  also includes the Maya plug‐ins 
 that enable Maya (see the next section) to interact with Python and vice versa. 
  
  Tutorials and reference documentation are available, although they do expect a basic knowledge of 3‐
 D computer graphics principles such as would be acquired by using 3‐D modeling applications. 
  
  Version 2 of the  
 cgkit
  was released in early 2013.  
 cgkit
  is available for Python versions 2 and 3. 
 The package is stable with very little new development underway. 
  
  The homepage for the 
 cgkit
  is at 
 http://cgkit.sourceforge.net/introduction.html
  .",NA
 Modeling and Animation ,"Many tools are available for digital compositing of video images. Those discussed here are a 
 representative selection, and all include some degree of Python integration. 
  
  The NUKE family of products is aimed squarely at the professional end of the video graphics market. 
 It is a commercial compositing tool that integrates with Python but has a price to match its target 
 audience, although a free trial is available as is a limited‐functionality Personal Learning Edition for 
 non‐commercial use. You can fi nd the NUKE homepage at  
 http://www.thefoundry 
 .co.uk/products/nuke
 ‐
 product
 ‐
 family/
  . NUKE uses Python 2.7. 
  
  Maya is another 3‐D animation and compositing tool. It, too, is a commercial product, competing with 
 NUKE, and also offers a free trial. It can be scripted using Python, and you can incorporate Maya 
 animations into your Python programs. The Maya/Python integration is part of the  
 cgkit 
 bundle 
 described in the previous section. You can fi nd the Maya homepage at  
 http://www 
 .autodesk.co.uk/products/autodesk
 ‐
 maya/overview
  . 
  
  Blender is yet another animation and compositing package, but it is open source and therefore free, 
 making it much more accessible to the consumer market. It, too, uses Python for its scripting engine. 
 The homepage is at 
 http://www.blender.org/features/
  . Blender uses Python 3.",NA
 Photo Processing,"For processing photographic images, many of the solutions discussed in the “Drawing Pictures with 
 Python” section at the start of the chapter apply. Pillow and ImageMagick are both effective
  
 www.it-ebooks.info",NA
Working with Audio ,"You’ve already heard about the built‐in modules in the standard library:  
 aifc
  , 
 wave
  ,  
 sunau
  , and the 
 winsound
  . These are just as applicable for non‐gaming sound applications. 
  
  SciPy and its various packages can also be used to process sound fi les, especially in conjunction with 
 some of the SciKit add‐ons. This is especially useful for analyzing sound content or plotting signal 
 waveforms. 
  
  There is a useful Python wiki-page listing many sound‐ and music‐oriented projects at 
 https:// 
 wiki.python.org/moin/PythonInMusic
  .",NA
INTEGRATING WITH OTHER LANGUAGES,"The normal Python distribution that you have been using until now is written and built using the C 
 language and is often referred to as CPython. There are other implementations of the Python language 
 in other languages. These non‐C based interpreters facilitate integration of the other language with 
 Python. Two of the best known of these alternate Python versions are Jython, written in Java, and 
 IronPython, an implementation for Microsoft’s .NET environment. A third alternative is Cython, which 
 is not strictly an implementation of Python but a very closely related subset that can be compiled into C 
 to provide very fast performance while still providing the speed of development of a Python‐like 
 language. Finally, it is possible to access Tcl/Tk code from within the Tkinter package.",NA
Jython ,"The Java implementation of Python offers many advantages to Java programmers looking for an 
 interactive environment in which to test their Java classes or to build prototype solutions that can, if 
 necessary, be converted to full Java later. 
  
  The distribution includes both an interpreter and a compiler. The interpreter comes with the familiar 
 interactive prompt, as well as the ability to run scripts directly. In addition to importing Python 
 modules (including many of the regular Python standard library modules), Jython can import Java 
 libraries, making the classes available to the Python interpreter as if they were regular 
  
 www.it-ebooks.info",NA
 IronPython,"IronPython is a version of Python written for the Microsoft .NET framework. .NET is not a single 
 language system; rather, it depends on a common bytecode to which several languages can be compiled. 
 The modules so produced can then be shared between languages. Thus, code written in IronPython can 
 import modules written in C#, C++, Visual Basic, and several other .NET‐compatible languages. 
 Similarly, IronPython modules can be imported by any of those other .NET languages. 
  
 IronPython is an extremely appealing prospect for developers working on the .NET platform.
  
  Better still is the fact that an open source variant of .NET called Mono has been produced that can run 
 under Linux and Mac OS X and many others, including mainframe computers and games consoles. 
 This is achieved while maintaining binary‐level compatibility with the Microsoft .NET 
 implementation. (At the other end of the spectrum, a slightly limited version, called Mono Touch, runs 
 on iOS and Android for building smartphone apps.) As .NET becomes the de facto standard for 
 building applications on Microsoft Windows, the availability of Python within that framework is a 
 major boon for Python programmers.
  
  The IronPython implementation supports most of the standard Python library as well as the .NET 
 module system. Modules in .NET are called assemblies, but they are imported into IronPython in exactly 
 the same way that ordinary Python modules are imported. Some issues exist due to the dynamic typing 
 used by Python and the .NET type system, which is more static in nature. However, once understood 
 these can be worked around using some helper features built into IronPython. Full documentation is 
 provided on the IronPython documentation site at 
 http://ironpython.net/ documentation/
  . 
  
  At the time of writing, IronPython was compatible with Python version 2.7, and a project was 
 underway to develop a Python 3 version. A set of tools is available to enable IronPython development 
 within the Microsoft VisualStudio IDE, which is the default IDE for .NET development.",NA
 Cython,"Cython is signifi cantly different from the other language integration options discussed here. It is, in 
 effect, a separate language from Python but is highly compatible with it, describing itself as a
  
 www.it-ebooks.info",NA
Tcl/Tk ,"The  
 tkinter
  and 
 tix
  GUI modules are built on top of the Tcl/Tk and Tix toolkits. As such, they 
 have the ability to execute Tcl code from within Python by using a method of the embedded  
 tk 
 object:  
 self.tk.call()
  . 
  
  This method is the key to how the  
 tix
  module is built. If you look at the code in  
 tix.py
  , you fi nd 
 many method defi nitions that look like this example from the 
 Notebook
  class: 
  
  def raised(self):
  
  return self.tk.call(self._w, 'raised')
  
  As you can see, the method is simply a wrapper for a call to the underlying Tix widget ( 
 self. _ w)
  . If 
 you are familiar with Tcl/Tk and Tix, you can fairly easily extend the existing Python widgets to utilize 
 some Tcl features that are not otherwise available. An alternative method to  
 call()
  is 
 eval()
  , which 
 evaluates an input string as a Tcl expression.
  
  But the integration does not need to stop with GUI widget access. You can pass arbitrary Tcl code to 
 the  
 eval()
  method and have it executed by the embedded Tcl interpreter. This could include 
 importing Tcl modules that provide features that Python does not. Of course, you need to know Tcl to 
 use this effectively! Here is the basic “Hello World” script that can be run in any command‐line 
 console using the standard output stream:
  
  >>>  
 import tkinter
  
  >>>  
 tcl = 
 tkinter.Tcl()
  
  >>>  
 tcl.eval('''",NA
 GETTING PHYSICAL,"There has been an upsurge of hobbyists interested in programming physical devices in recent years. 
  
 Low‐cost, highly fl exible products such as the Arduino microcontroller card and the RaspberryPi single 
 board computer (SBC) have become available at very low cost. Python is well suited to programming 
 such devices, and several libraries exist to assist in the process. Indeed, Python is one of the 
 recommended languages for the RaspberryPi.
  
  It is not necessary to spend money on hardware to connect Python to the outside world. Most 
 computers still have a serial port running the RS232 protocol, and it is possible to connect that to 
 various peripheral devices and access them using Python. Similarly, the MIDI interface can be used to 
 access musical instruments, and even the ubiquitous USB interface can be manipulated with the right 
 modules in place. 
  
  As is the case in any kind of integration, you need to understand both ends of the connection. If you are 
 not familiar with the physical devices to which you want to connect, you will struggle. The fi rst step in 
 integrating Python with anything is to fi rst fi nd out how the target device interacts with the world. 
 Only then will the libraries discussed in the following sections become useful to you.",NA
 Introducing Serial Options ,"You can access the RS232 communications port on a computer (or indeed any other serial port, 
 including old‐style PS‐2 mice or pens) using the  
 serial
  module made available by the PySerial 
 project, which has its homepage at 
 http://pyserial.sourceforge.net/
  . Comprehensive 
 documentation and examples are included. 
  
  The module provides support for several OSes including Windows and Linux, as well as Jython and 
 IronPython. It can be installed from PyPI, or as a Linux package in most distributions, or, for 
 Windows, as a binary installer. It works with Python versions 2 and 3.
  
  The PyUSB library is available for USB access. It is written in Python using 
 ctypes
  under the covers 
 to access the low‐level code. You can fi nd PyUSB at  
 https://github.com/walac/pyusb
  . The 
 website is a tad sparse, but it includes a tutorial with several examples. It is assumed that you already 
 understand how USB interfaces function.
  
  PyUSB is available from the GitHub repository, but is easier to install via the PyPI.",NA
 Programming the RaspberryPi ,"The RaspberryPi is a single board computer, about the size of a credit card, and sold at very low cost. 
 It was originally intended to encourage interest in computing technology and programming.",NA
 Talking to the Arduino,"The Arduino products are, in many ways, complementary to the RaspberryPi. Where the 
 RaspberryPi aims to teach about computing and programming, Arduino is more directly aimed at 
 the electronics enthusiast. It enables experimentation with interfaces, both analog and digital.
  
 The various microcontroller circuit boards in the Arduino range come in various confi gurations of 
 inputs and outputs. Typically they include a USB interface, several analog input pins, as well as some 
 digital I/O pins, thus enabling the user to attach various external devices. 
  
  Accessories are also available to extend the types of devices that can be connected. Also included is a 
 code library, called Wiring, written in C, that provides access to the various ports. There is an IDE that 
 helps users write their code and provides a single‐click mechanism to upload it to the board. The 
 Arduino homepage is at  
 http://www.arduino.cc/
 . 
  
  Although the Arduino processor normally has to have a binary application downloaded, it can also be 
 controlled by connecting the Arduino to a controlling computer, such as a RasberryPi. This enables 
 Python to be used to send instructions to the Arduino via the USB or serial ports. There is a library to 
 facilitate this called 
 pyfirmata
  , which is available from PyPI. There is a web page that discusses this 
 further, with several examples of what is possible, at 
 http://playground.arduino 
 .cc/interfacing/python
  .",NA
 Exploring Other Options ,"The popularity of the RaspberryPi and Arduino projects has spawned several competing products.
  
 Many of these are simply low‐cost clones of the other projects, especially the Arduino, but others are 
 genuine alternatives with a slightly different set of objectives or presentation of the ideas; for example, 
 creating the smallest board possible. In most cases Python can be used to access the boards over a 
 serial link or even by a network connection using standard Python modules.
  
  Your favorite search engine should fi nd many candidates. You should check the nature of the 
 interfaces provided and how the programming is done. Some Arduino clones require you to 
  
 www.it-ebooks.info",NA
 BUILDING PYTHON,"One area of special interest for Python programmers is Python itself. Python is a very open 
 architecture with many features that enable the programmer to inspect the internal workings of the 
 interpreter, as well as the data structures within the program. Being an open source project means that 
 the development of the language is a community affair and everyone who uses Python can share in its 
 development. If there is a feature of Python that you think is broken or can be improved, there is a 
 process for fi xing it. If there is a feature you’d like to add, there is a process for adding it.
  
  If you want to get involved in Python development, whether because you have a personal itch to 
 scratch or just as a way of giving back to the community that gave you Python, you have several 
 ways to get started. You can fi nd a good introduction to all of the options at  
 https://docs 
 .python.org/devguide/index.html
  .",NA
 Fixing Bugs,"Perhaps the most obvious place to start getting involved with Python is in fi xing bugs. The very act of 
 reporting bugs is a useful contribution, but supplying fi xes is even better. There is an offi cial bug 
 tracker application, and before submitting a bug you should check whether it has already been 
 reported, and what, if anything, is being done to fi x it. If it’s a new bug, you can fi ll in a report (and 
 optionally supply a fi x).
  
  Once a bug has been reported, the tracker supports a conversational model whereby users can 
 suggest fi xes, comment on patches, and so on. The bug tracker homepage is at 
 https://docs 
 .python.org/3/bugs.html
  .",NA
 Documenting ,"In most open source projects, it is easier to get someone to write code than to get someone to write 
 documentation. Python is no exception. Although the offi cial documentation is quite good for an open 
 source project, it still has many areas that are sketchy at best and in some cases completely lacking. 
 (You saw an example of that with the  
 tix
  module used in Chapter  4  . Several  
 tix
  widgets are 
 available that are not described in the offi cial documentation.) 
  
  Volunteering to document some of these darker corners of Python is a worthwhile endeavor, and one 
 that provides a relatively gentle introduction to open source community. Documentation issues are 
 reported on the standard Python bug tracker that you can use to submit bug reports and suggested fi 
 xes. If you want to get more fully involved, you can subscribe to the 
 docs@python.org 
 mailing list. 
 You can fi nd more specifi c details on the process on this website:  
 https://docs 
 .python.org/devguide/docquality.html
  .
  
  The documentation is actually generated using a purpose‐built document processor called Sphinx. 
 The Sphinx content is created in reStructuredText (reST), a lightweight markup system similar to 
  
 www.it-ebooks.info",NA
 Testing,"Unless you plan on getting involved in core Python development, the best way to contribute to testing 
 is to download and use the early beta releases. You can then report bugs found using the bug tracker as 
 usual.",NA
 Adding Features,"If your itch is not due to a bug but due to a missing or incomplete feature, either in the Python language 
 itself or in a module, you should consider submitting the idea to the 
 python
 ‐
 ideas
  mailing list. You can 
 sign up to the list at  
 https://mail.python.org/mailman/listinfo/python
 ‐
 ideas
  . 
  
 The list enables your idea to be discussed by the wider community. If yours is considered a good 
 idea, you may be invited to submit a Python Enhancement Proposal, or PEP.
  
  It must be said you have far more chance of getting a module change approved than a core language 
 feature, but language changes do happen, and if it’s a good idea it is worth trying.",NA
 Attending Conferences ,"Another, altogether easier, way of getting involved in the Python community is to attend the various 
 local user groups and conferences held every year. These afford opportunities to learn about Python 
 and its infrastructure, hear about successful projects based on Python, and, of course, to present your 
 own experiences with Python. 
  
  Several major international Python conferences are held annually, as well as some smaller events 
 either focused on a local area or a special interest group. Details of these are often announced 
 online, in the various Python mailing lists, and a list is maintained here:  
 https://wiki.python 
 .org/moin/PythonEvents
  .",NA
 SUMMARY ,"In this chapter you looked at the wider world of Python. In particular, you considered the specialist 
 areas that are not covered by the standard library but have extensive support from Python in the 
 wider community.
  
  You’ve seen how graphics can be produced and manipulated using core Python modules as well as 
 various third‐party libraries, especially Pillow and ImageMagick.
  
  Many third‐party libraries are available in the fi eld of science, and the foundation for many of these is 
 the SciPy bundle of packages and tools. Distributions like Anaconda make installation of these packages 
 much easier. 
  
  For games programming you discovered that the PyGame package provides low‐level graphics and 
 multimedia access. Third‐party computational engines also help you to develop realistic game play.
  
 www.it-ebooks.info",NA
 A,NA,NA
 Chapter   1  Solutions ,"1.
  
 How do you convert between the different Python data types? What data quality 
 issues arise when converting data types?
  
  You convert between types using the type functions. Thus, to convert a fl oat or string to 
 an integer, you use the 
 int()
  type function. To convert an object to a string, you use the 
 str()
  type function. And so on.
  
  When making the conversion, it is possible that you might lose some data in the 
 process. For example, converting a fl oating‐point number to an integer loses the 
 decimal part of the number (for example, 
 int(2.3)
  results in 
 2
  ). If it’s important to 
 retain the detail, you must retain a copy of the original as well. 
  
 2.
  
 Which of the Python collection types can be used as the key in a dictionary? Which 
 of the Python data types can be used as a value in a dictionary?
  
  Dictionary keys must be immutable. That means that of the basic Python types, integers, 
 booleans, fl oats, strings, and tuples can all be used as keys (although fl oats are not 
 recommended due to their imprecision, especially if you will be computing the key value 
 rather than just storing it). Other custom types, such as 
 frozenset
  , can also be used as 
 keys provided they are immutable. 
  
  Dictionary values can be of any type regardless of mutability.
  
 3.
  
 Write an example program using an
 if/elif
 chain involving at least four 
 different selection expressions.
  
  You could use any number of choices here. This example uses colors. Your 
 if/elif/ 
 else
  code should look something like the following: 
  
  (red, orange, yellow, green, blue, violet) = 
 range(6)  color = int(input('Type a number between 1 
 and 6'))-1  if color == red: 
  
  print ('You picked red') 
  
 www.it-ebooks.info",NA
 Chapter  2  Solutions ,"1.
  
 Explore the
 os
 module to see what else you can discover about your computer. Be sure 
 to read the relevant parts of the Python documentation for the
 os
 and
 stat
 modules.
  
  Start the Python interpreter and type the following:
  
  >>>  
 import os
  
  >>>  
 os.nice(0)
        # get relative process priority  
 0 
  
  >>>  
 os.nice(1)
        # change relative priority
  
  1 
  
  >>>  
 os.times()
        # process times: system, user 
 etc...
  
  posix.times_result(user=0.02, system=0.01, 
  
  children_user=0.0, children_system=0.0, elapsed=1398831612.5)
  
  >>>  
 os.isatty(0)
      # is the file descriptor arg a tty?(0 = 
 stdin)  True 
  
  >>>  
 os.isatty(4)
      # 4 is just an arbitrary test value 
  
  False 
  
  >>>  
 os.getloadavg()
   # UNIX only 
 ‐
  number of processes in queue 
 (0.56, 0.49, 0.44) 
  
  >>>  
 os.cpu_count()
    # New in Python 3.4
  
  4 
  
  There are many other functions you could try. For example: 
 os.getpriority()
  , 
 os.get_exec_path()
  , 
 os.strerror()
  , and so on. 
  
 2.
  
 Try adding a new function to the
 file_tree
 module called
 find_dirs()
 that searches 
 for directories matching a given regular expression. Combine both to create a third 
 function,
  
 find_all()
 , that searches both fi les and directories.
  
  See Chapter2.zip 
 solutions/findfiles.py
  . The  
 findfiles.py
  module included in the 
 solutions download provides solutions to all three of the functions in the exercise as well as 
 a couple of alternatives that you might fi nd useful. The specifi c code for the examples is 
 reproduced here:
  
 def find_dirs(pattern, base='.'): 
  
 """"""Finds directories under base based on pattern
  
 Walks the filesystem starting at base and 
  
 returns a list of directory names matching 
 pattern""""""
  
 regex = re.compile(pattern) 
  
 matches = [] 
  
 for root, dirs, files in os.walk(base):
  
  
  for d in dirs:
  
  
  
  if regex.match(d):
  
  
  
  
  matches.append( path.join(root,d) 
 ) return matches
  
 def find_all(pattern, base='.'): 
  
 """"""Finds files and folders under base based on pattern
  
 Returns the combined results of find_files and find_dirs""""""",NA
 Chapter  3   Solutions ,"1.
  
 To appreciate the work that
 pickle
 does for you, try building a simple serialization 
 function for numbers, called
 ser_num()
 . It should accept any valid integer or fl oat 
 number
  
 as an argument and convert it into a byte string. You should also write a function to 
 perform the reverse operation to read a byte string produced by 
 your
 ser_num()
 function and con-vert it back to a number of the appropriate type. 
 (Hint: You may fi nd the
 struct
 module useful for this exercise.)",NA
 Chapter  4  Solutions ,"1. 
  
 Convert the
 oxo
 ‐
 logic.py
 module to refl ect OOP design by creating a
 Game
 class
  . 
  
  See the following code (available in the  
 Chapter4.zip
  fi le, in the 
 Solutions
  folder as 
 ex4
 ‐
 1.py
  ): 
  
  import os, random 
  
  import oxo_data 
  
  class Game(): 
  
  def __init__(self):
  
  
  self.board = list("" "" * 9)
  
  def save(self, game): 
  
  ' save game to disk ' 
  
  oxo_data.saveGame(self.board) 
  
  def restore(self):
  
  
  ''' restore previously saved game. 
  
  
  If game not restored successfully return new game'''  
 try:
  
  
  self.board = oxo_data.restoreGame()
  
  
  if len(self.board) != 9:
  
  
  
  self.board =  list("" "" * 9) 
  
  
  return self.board 
  
  except IOError:
  
  
  self.board = list("" "" * 9) 
  
  
  return self.board 
  
  def _generateMove(self): 
  
  
  ''' generate a random cell from those 
 available. 
  
  
  
  If all cells are used return -1'''
  
  options = [i for i in range(len(self.board)) if  self.board[i] == "" 
 ""]  if options:
  
  return random.choice(options) 
  
  else: return -1
  
  def _isWinningMove(self): 
  
  
  wins = ((0,1,2), (3,4,5), (6,7,8), 
  
  
  
  
  
  (0,3,6), (1,4,7), (2,5,8), 
  
  
  
  
  
  (0,4,8), (2,4,6))
  
  
  game = self.board 
  
  
  for a,b,c in wins: 
  
  
  
  chars = game[a] + game[b] + 
 game[c]
  
  
  
  if chars == 'XXX' or chars == 
 'OOO':
  
  
  
  return True 
  
  
  return False
  
  def userMove(self,cell): 
  
  
  if self.board[cell] != ' ':
  
  
  
  raise ValueError('Invalid cell') 
  
  
  else: 
  
  
  
  self.board[cell] = 'X'
  
  
  if self._isWinningMove():",NA
 Chapter  5  Solutions ,"1. 
  
 Consider our code from earlier in this chapter:
  
  >>>for result in results['results']:
  
  ...     id = result['id'] 
  
  ...     print(id) 
  
  ...     print (result['id']) 
  
  ...     details = requests.get(market + id).json()  
 ...     print (details)
  
  ...     print (details['marketdetails']) 
  
  ...  print 
 (details['marketdetails']['GoogleLink']) 
  
  Using what you know about Python, can you fi gure out a way to create a list 
 comprehension that will do the same thing as the preceding code? Remember that list 
 comprehensions are constructed like this: 
  
  [expression for item in list if conditional]
  
  Here is the solution: 
  
  print([requests.get(market + 
 result['id'].json()['marketdetails']['GoogleLink']) for result in 
 results['results']])
  
 2.
  
 Using what you know so far about how to use fi les in Python, can you save the output 
 of your call to the USDA
 ’
 s API to a fi le on your machine, to parse later? (Saving it as a 
 .txt fi le 
  
 is fi ne.)
  
  You can use the list comprehension above to simply write to a fi le as such:
  
  file = open(""markets.txt"", ""w"")
  
  file.write([requests.get(market +
  
  
 result['id'].json()['marketdetails']['GoogleLink'])  
 for result in results['results']\n])
  
  file.close
  
 3.
  
 Can you fi nd the docs for Flask that would help us to break our app into smaller, 
 modular-ized fi les with our endpoints/views in a separate fi le, rather than having 
 one big Python fi le
  
 with everything in it? (Hint: It is one concept/feature that Flask offers.)
  
  Flask docs can be found at ( 
 http://flask.pocoo.org/docs/blueprints/#blueprints
  ). 
  
  Blueprints are how we can separate our app into separate fi les so that we don’t have one 
 large python fi le with every piece of functionality in it. 
  
 4. 
  
 What other HTTP methods can you fi nd? Can you fi nd ways to use them in a Flask app?
  
  Depending on how the reader researches the question, they will fi nd there are a few other 
 HTTP methods; GET, PUT, DELETE, OPTIONS. The second part of this exercise will vary, but 
 the point is to get the reader reading docs and learning how to fi nd answers, and explore 
 what is available to them.",NA
Chapter   6   Solutions ,"1.
  
 In the zip fi le for this chapter, open the fi 
 le
 markets.py
  
 and write a doctest string to test 
 the
  
 value being returned by the function in the fi le. Can you think of a reason why a simple 
 doct-
  
 est string in this code could be incredibly useful for maintaining the code in the future?
  
  Depending on the static data you’ve decided to use, answers will vary, however here is one 
 example using the ZIP code in the code (you may have changed this):
  
 import requests 
  
 results =  
 requests.get(""http://search.ams.usda.gov/farmersmarkets/v1/data.svc/ 
 zipSearch?zip=46201"").json() 
  
 def get_details(results): 
  
  
 ''' 
  
  
 >>> print(get_details(results)) 
  
  
 http://maps.google.com/?q=39.7776%2C%20
 ‐
 86.0782%20(%22Irvington+Farmers+ 
  
 Market+%22Error! Hyperlink reference not valid.
  
  
  
  ''' 
  
 market = 
 ""http://search.ams.usda.gov/farmersmarkets/v1/data.svc/mktDetail?id="" for 
 result in results['results']:
  
  
  id = result['id']
  
  
  details = requests.get(market+id).json()
  
  
  return details['marketdetails']['GoogleLink']
  
 2.
  
 Write a unittest for a function that will take a string and return that string reversed. 
 Make sure the test fails, because you haven’t written the function to test… yet.
  
  import unittest 
  
  from reverse import rev
  
  class TestRev(unittest.TestCase):
  
  def test_rev(self):
  
  
  
  self.assertEqual(rev('robot'), 
 'tobor')
  
  '''
  
 3.
  
 Write a function for your unittest that takes a string and returns the reverse of that 
 string. Now, run your unittest against that function and modify the function until it 
 passes.
  
  #reverse.py
  
  def rev(chars): 
  
  chars.sort(reverse=True)
  
  
  
  return chars",NA
 Chapter  7  Solutions ,"1.
  
 In the section on SciPy you discovered that there were many more areas of science 
 with Python libraries available. Pick some areas of science and see what support you 
 can fi nd in 
  
 the Python community. (Hint: The Anaconda and Enthought Canopy distributions 
 contain much more than the basic SciPy bundle of packages.)
  
  The Anaconda and Canopy websites list the modules included in their respective 
 distributions. Here is just a sample of the obviously scientifi c options:
  
 2.
  
 ➤
  
  astroid
  
 ➤
  
  astropy
  
 ➤
  
  biopython
  
 ➤
  
  bokeh 
  
 ➤
  
  geos
  
 ➤
  
  libffi 
  
 ➤
  
  libnetcdf 
  
 ➤
  
  libsodium
  
 ➤
  
  mccab 
  
 In the “Going to the Movies” section you saw that commercial (and open source) 
 applica-tions can be scripted using Python as a macro language. This is not the only 
 area where this
  
 is possible. Research the use of Python as a macro language and produce a list of some 
 popu-lar applications that can be scripted using Python.
  
  The Python wiki has a page dedicated to this topic. Here is the address: 
 https://wiki 
 .python.org/moin/AppsWithPythonScripting
  .
  
  As you can see, the list encompasses everything from the GIMP image toolkit, to the vim and 
 emacs editors, to the OpenOffi ce productivity suite. Doubtless there are others not listed on the 
 wiki-page, but there should be plenty here for you to get going with. 
  
 3.
  
 Python is used in many other niche areas. Try to identify an area that you have an 
 interest in and fi nd out what support might be available. (Hint: PyPI has a search 
 facility.)
  
  One area many people are passionate about is music. Python supports this in various ways 
 including several audio players, MIDI tools, audio servers, fi le format convertors, and so on. 
  
  However, Python also supports the creation of original music via a piano tutor (The 
 Turcanator), musical notation editors (Frescobaldi), analysis of sounds (pcsets), and 
 generation of sounds (Cabel). 
  
  There are many others ranging from easy‐to‐use applications to highly technical APIs for 
 audio professionals. 
  
 www.it-ebooks.info",NA
 B ,"The Python standard library contains well over 200 modules, although the exact number varies 
 between distributions. Not all of these modules are recommended for use by the typical Python 
 programmer; many have specialized uses associated with the Python internal modules and are 
 intended mainly for use by developers working on Python itself. And certain other modules, 
 remnants of older Python versions now superseded by more modern alternatives, are retained 
 mainly for compatibility with old code. 
  
  This appendix lists all of the standard packages and modules that are recommended for 
 “normal use” and highlights, in bold, those used or discussed in this book. Modules marked in 
 the offi cial documentation as deprecated, or intended for use by core developers, as well as 
 some designed to be development tools, have been omitted from the list. A few minor clarifi 
 cations to the descriptions have been added. Not all packages have been expanded to show the 
 individual modules, and in these cases a package‐level description is provided.",NA
a ,"aifc
  
 Read and write audio fi les in AIFF or AIFC format.
  
 argparse
  
 Command‐line option and argument-parsing library.
  
 array
  
 Space‐effi cient arrays of uniformly typed numeric values.
  
 asynchat
  
 Support for asynchronous command/response protocols.
  
 asyncio
  
 Asynchronous I/O, event loop, coroutines, and tasks.
  
 asyncore
  
 A base class for developing asynchronous socket‐handling services.
  
 atexit
  
 Register and execute cleanup functions.
  
 audioop
  
 Manipulate raw audio data.
  
 Copyright © 2001-2014 Python Software Foundation; All Rights Reserved.
  
 www.it-ebooks.info",NA
b,"RFC 3548: Base16, Base32, Base64 Data Encodings; Base85, and ASCII85.
  
 binascii
  
 Tools for converting data to and from various ASCII‐encoded binary 
 representations.
  
 binhex
  
 Encode and decode fi les in binhex4 format.
  
 bisect
  
 Array bisection algorithms for binary searching.
  
 bz2
  
 Interfaces for bzip2 compression and decompression.",NA
c,"calendar
  
 Functions for working with calendars, including some emulation of the UNIX 
 cal(1) program.
  
 cgi
  
 Helpers for running Python scripts via the common gateway interface (CGI).
  
 cgitb
  
 Confi gurable traceback handler for CGI scripts.
  
 chunk
  
 Module to read Interchange File Format (IFF) chunks.
  
 cmath
  
 Mathematical functions for complex numbers.
  
 cmd
  
 Build line‐oriented command interpreters.
  
 code
  
 Facilities to implement read‐eval‐print loops.
  
 codecs
  
 Encode and decode data and streams.
  
 collections
  
 Container data types.
  
 collections.abc
  
 Abstract base classes for containers.
  
 colorsys
  
 Conversion functions between RGB and other color systems.
  
 compileall
  
 Tools for byte‐compiling all Python source fi les in a directory tree or some 
 subset thereof.
  
 concurrent
  
 Execute computations concurrently using threads or processes.
  
 confi gparser
  
 Confi guration fi le parser.
  
 contextlib
  
 Utilities for with‐statement contexts.
  
 copy
  
 Shallow and deep copy operations.
  
 copyreg
  
 Register pickle support functions.
  
 crypt (UNIX)
  
 The 
 crypt()
  function used to check UNIX passwords.
  
 csv
  
 Write and read tabular data to and from comma‐delimited data fi les. (Other 
 delimiters can also be used.)
  
 ctypes
  
 A foreign function library for Python.
  
 curses (UNIX)
  
 An interface to the curses library, providing portable terminal handling.
  
 www.it-ebooks.info",NA
 d ,"datetime
  
 Basic date and time types.
  
 dbm
  
 Interfaces to various key‐value database formats.
  
 decimal
  
 Implementation of the General Decimal Arithmetic Specifi cation.
  
 diffl ib
  
 Helper classes and functions for computing differences between objects.
  
 distutils
  
 Support for building and installing Python modules into an existing Python 
 installation.
  
 doctest
  
 Test snippets of code appearing within docstrings.",NA
 e ,"e-mail
  
 Package supporting the parsing, manipulating, and generating of e‐mail 
 messages, including MIME documents.
  
 encodings
  
 Package supporting various character encodings.
  
 enum
  
 Implementation of an enumeration class.
  
 errno
  
 Standard errno system symbols.",NA
 f ,"fcntl (UNIX)
  
 The 
 fcntl()
  and  
 ioctl()
  system calls.
  
 fi lecmp
  
 Compare fi les effi ciently.
  
 fi leinput
  
 Loop over standard input or a list of fi les.
  
 fnmatch
  
 UNIX shell–style fi lename pattern matching.
  
 fractions
  
 Rational numbers.
  
 ftplib
  
 FTP protocol client (requires sockets).
  
 functools
  
 Higher‐order functions and operations on callable objects.",NA
 g ,"Portable reading of passwords and retrieval of the user ID.
  
 gettext
  
 Multilingual internationalization services.
  
 glob
  
 UNIX shell–style pathname pattern expansion.
  
 grp (UNIX)
  
 The group database (
 getgrnam()
  and friends).
  
 gzip
  
 Interfaces for gzip compression and decompression using fi le objects.
  
 www.it-ebooks.info",NA
h ,"hashlib
  
 Secure hash and message digest algorithms.
  
 heapq
  
 Heap queue algorithm (aka, priority queue).
  
 hmac
  
 Keyed‐Hashing for Message Authentication (HMAC) implementation for 
 Python.
  
 html.entities
  
 Data structures useful for processing HTML.
  
 html.parser
  
 A simple parser that can handle HTML and XHTML.
  
 http
  
 Package supporting use of HTTP including client, server, and cookie 
 management.
  
 http.server
  
 HTTP server and request handlers.",NA
i,"IMAP4 protocol client (requires sockets).
  
 imghdr
  
 Determine the type of image contained in a fi le or byte stream.
  
 io
  
 Core tools for working with streams.
  
 ipaddress
  
 IPv4/IPv6 manipulation library.
  
 itertools
  
 Functions creating iterators for effi cient looping.",NA
 j,"json
  
 Encode and decode the JSON data format.",NA
k ,"keyword
  
 Test whether a given string is a Python keyword.",NA
l,"linecache
  
 Provides random access to individual lines from text fi les using a cache.
  
 locale
  
 Internationalization services.
  
 logging
  
 Flexible event logging for applications.
  
 lzma
  
 A Python wrapper for the liblzma compression library.
  
 www.it-ebooks.info",NA
 m ,"macpath
  
 Mac OS 9 path manipulation functions.
  
 mailbox
  
 Manipulate mailboxes in various formats.
  
 mailcap
  
 Mailcap fi le handling.
  
 math
  
 Mathematical functions [
 sin()
 , and so on].
  
 mimetypes
  
 Mapping of fi lename extensions to MIME types.
  
 mmap
  
 Interface to memory‐mapped fi les for UNIX and Windows.
  
 msvcrt (Windows)
  
 Miscellaneous useful routines from the MS VC++ run time.
  
 multiprocessing
  
 Package for process‐based parallelism.",NA
 n ,"netrc
  
 Loading of 
 .netrc
  fi les.
  
 nis (UNIX)
  
 Interface to Sun’s NIS (Yellow Pages) library.
  
 nntplib
  
 NNTP protocol client (requires sockets).
  
 numbers
  
 Abstract base classes for numeric types (Complex, Real, Integral, and so on).",NA
 o ,"operator
  
 Functions corresponding to the standard operators (add, subtract, and so on).
  
 os
  
 Miscellaneous operating system interfaces.
  
  As Chapter  2 makes clear, the
   os 
  module is one of several modules used to 
 interact with the OS on Python, and the selection of functions provided is 
 somewhat arbitrary and inconsistent.
  
 os.path
  
 Provides helper functions for manipulating and testing fi le paths.
  
 ossaudiodev (Linux, 
 FreeBSD)
  
 Access to OSS‐compatible audio devices.",NA
 p ,"pathlib
  
 Provides an object‐oriented model of fi le system paths.
  
 pdb
  
 A debugger for interactive Python interpreters.
  
 pickle
  
 Convert Python objects to streams of bytes and back.
  
 pipes (UNIX)
  
 A Python interface to UNIX shell pipelines.
  
 platform
  
 Retrieves as much platform identifying data as possible.
  
 plistlib
  
 Generate and parse Mac OS X plist fi les.
  
 www.it-ebooks.info",NA
 q,"queue
  
 A queue class suitable for communicating between threads.
  
 quopri
  
 Encode and decode fi les using the MIME quoted‐printable encoding.",NA
 r,"Generate pseudorandom numbers with various common distributions.
  
 re
  
 Regular‐expression operations.
  
 readline (UNIX)
  
 GNU readline support for Python.
  
 reprlib
  
 An alternate 
 repr()
  implementation with size limits.
  
 resource (UNIX)
  
 An interface to provide resource usage information about the current 
 process.",NA
 s,"sched
  
 General‐purpose event scheduler.
  
 select
  
 Wait for I/O completion on multiple streams.
  
 selectors
  
 High‐level I/O multiplexing.
  
 shelve
  
 Python object persistence.
  
 shlex
  
 Simple lexical analysis for UNIX shell–like languages.
  
 shutil
  
 High‐level fi le operations, including copying.
  
 signal
  
 Set handlers for asynchronous events.
  
 smtpd
  
 An SMTP server implementation in Python.
  
 smtplib
  
 SMTP protocol client (requires sockets).
  
 sndhdr
  
 Determine the type of sound fi le.
  
 socket
  
 Low‐level networking interface.
  
 socketserver
  
 A framework for network servers.
  
 spwd (UNIX)
  
 The shadow password database [
 getspnam()
  and friends].
  
 sqlite3
  
 A DB‐API 2.0 implementation using SQLite 3.x.
  
 ssl
  
 TLS/SSL wrapper for socket objects.
  
 www.it-ebooks.info",NA
 t,"tarfi le
  
 Read and write tar‐format archive fi les.
  
 telnetlib
  
 Telnet client class.
  
 tempfi le
  
 Generate temporary fi les and directories.
  
 termios (UNIX)
  
 POSIX style TTY control.
  
 textwrap
  
 Text wrapping and fi lling.
  
 threading
  
 Parallel processing based on threads.
  
 time
  
 Time access and conversions.
  
 timeit
  
 Measure the execution time of code snippets.
  
 tkinter
  
 Interface to Tcl/Tk for graphical user interfaces.
  
 tkinter.messagebox
  
 Standard message dialogs.
  
 tkinter.tix
  
 Tk Extension Widgets for Tkinter.
  
 tkinter.ttk
  
 Tk themed widget set.
  
 tkinter.fi ledialog
  
 Variations on standard File dialogs.
  
 tkinter.simpledialog
  
 A base class for building custom dialogs.
  
 tty (UNIX)
  
 Utility functions that perform common terminal control operations.
  
 turtle
  
 An educational framework for developing simple graphics applications.
  
 types
  
 Names for Python’s built‐in types.",NA
 u ,"Access the Unicode database.
  
 unittest
  
 Unit testing framework for Python.
  
 urllib
  
 Package for processing URLs including requests, responses, errors, and so on.
  
 uu
  
 Encode and decode fi le‐like objects to and from uuencode format.
  
 uuid
  
 UUID objects (universally unique identifi ers) according to RFC 4122.
  
 www.it-ebooks.info",NA
w,"warnings
  
 Issue warning messages and control their disposition.
  
 wave
  
 Provide an interface to the WAV sound format.
  
 weakref
  
 Support for weak references and weak dictionaries.
  
 webbrowser
  
 Easy‐to‐use controller for web browsers.
  
 win32com.client
  
 Third‐party module providing access to the native Win32 API.
  
 winreg (Windows)
  
 Provides helper functions and a Key class for manipulating the Windows 
 registry.
  
 winsound (Windows)
  
 Access to the sound‐playing machinery for Windows.
  
 wsgiref
  
 Package providing a reference implementation of WSGI along with various 
 WSGI utility functions and classes.",NA
 x ,"xdrlib
  
 Encoders and decoders for the External Data Representation (XDR).
  
 xml
  
 Package containing XML processing modules.
  
 xml.dom
  
 Document object model (DOM) API for Python.
  
 xml.minidom
  
 Minimal document object model (DOM) implementation.
  
 xml.etree
  
 Implementation of the ElementTree API.
  
 Xml.parsers.expat
  
 An interface to the Expat non‐validating XML parser.
  
 xml.sax
  
 Package containing SAX2 base classes and convenience functions.
  
 xml.sax.handler
  
 Base classes for SAX event handlers.
  
 xmlrpc
  
 Package providing support for XMLRPC.
  
 Xmlrpc.client
  
 Provides helper functions and classes for XML‐RPC client access.
  
 Xmlrpc.server
  
 Basic XML‐RPC server implementations.",NA
z,"zipfi le
  
 Read and write zip‐format archive fi les.
  
 zlib
  
 Low‐level interface to compression and decompression routines compatible 
 with gzip.
  
 www.it-ebooks.info",NA
 C ,"This appendix lists some useful resources for the intermediate‐level Python programmer. The 
 list does include a few tutorials, but these are either more in‐depth than most beginner’s tutorials 
 or they cover specifi c topic areas. Many of the links point to user support forums and mailing 
 lists. Several of the resources were recommended by the Python “Tutor” mailing list community 
 following a request for suggestions.",NA
ASKING QUESTIONS: MAILING LISTS AND MORE ,"Many Python mailing lists are available, covering a wide variety of topics and interest areas. 
  
 The Python “Tutor” mailing list is specifi cally targeted at those learning Python and its 
 standard library along with the fundamentals of programming. The main Python mailing list is a 
 source of information about all aspects of Python, but is populated by a particularly Python‐
 savvy team who may be less tolerant of poorly researched questions. You can fi nd the offi cial 
 Python mailing lists at  
 https://mail.python.org/mailman/listinfo
  . 
  
  At the time of writing, almost 200 lists are available; however, many relate to special events such 
 as conferences or local user groups. Nonetheless, many technical lists are available on the offi cial 
 site. 
  
  Many third‐party packages also have their own mailing lists or web forums for support and 
 maintenance. Examples include the wxPython GUI library and the Django web framework. 
  
  The  
 gmane.org
  website and news server offers access to all the offi cial mailing lists as well as 
 many other lists. At the time of writing it hosts more than 230 top‐level Python mailing lists, and 
 many of these have several sublists. All of these are available in web, usenet, and e‐mail formats. 
 Other related technologies such as SQLite, Tcl/Tk, and the various OSes all have extensive lists 
 available, too. 
  
  Newsgroups are a legacy from the early pre‐web days of the Internet, but are still heavily used by 
 professional programmers. They often provide more direct access to a true expert than some of 
 the more casual web forums. The general Python mailing list is also available on usenet as  
 news://comp.lang.python
  . 
  
 www.it-ebooks.info",NA
READING BLOGS,"If you don’t have specifi c questions and just want to fi nd out what other Python programmers are 
 doing or thinking, a blog may be your best bet. Here are a few blog sites with useful material: 
  
 ➤
  
  Doug Hellman has a long established website at  
 http://pymotw.com/2/contents.html 
  
 that features different Python modules on a weekly basis. In addition, he maintains a more 
  
 informal but useful blog at 
 http://doughellmann.com/
  . 
  
 ➤
  
  The effbot site is not strictly a blog in the traditional sense, but it contains a miscellany of 
  
 useful articles and information from Python stalwart Frederick Lundh and is well worth a 
  
 browse. You can fi nd it at  
 http://effbot.org/
  . 
  
 ➤
  
  The fi nal suggestion is not Python specifi c, but a general programming blog. The author has 
  
 strong opinions, sometimes controversial, but that just adds to the interest. It is written by 
  
 Joel Spolsky and is located at 
 http://www.joelonsoftware.com/index.html
  .",NA
STUDYING TUTORIALS AND REFERENCES ,"Many universities now use Python in their programming courses. This has led to a number of online 
 courses and tutorials being produced by the universities or their students. Some are basic and aimed at 
 beginners, but others feature specifi c packages or libraries or teach more advanced techniques. 
  
  The University of Cambridge has several short courses available as PDF fi les. You can fi nd them 
 linked from this site: 
 http://www.ucs.cam.ac.uk/docs/course
 ‐
 notes/unix
 ‐
 courses/ 
 PythonProgIntro
  . 
  
  You can fi nd other similar courses with the aid of your favorite search engine.
  
  In addition, several computer companies use Python or encourage programmers to learn about it. 
 Two well‐known examples are Apple and Google, both of which provide Python courses featuring 
 multimedia instruction. You can fi nd their courses at the following URLs.
  
  This one is for iTunes users:  
 https://itunes.apple.com/gb/itunes
 ‐
 u/hands
 ‐
 on
 ‐
 python
 ‐
 tutorial
 ‐
 chapter/id448754574?mt=10
  . This is for the Google fans: 
 https://developers 
 .google.com/edu/python/
  . 
  
 www.it-ebooks.info",NA
 WATCHING VIDEOS,"YouTube has several videos on Python. The quality ranges from excellent to poor, as is usually the 
 case on community‐based sites like YouTube. However, if you learn well from video it’s worth a 
 browse; you can always hit the stop button if you don’t like what you fi nd. YouTube is, of course, 
 located at 
 https://www.youtube.com/
  . 
  
  ShowMeDo is a web‐based video training site. It offers a mix of free and paid‐for training materials. The 
 quality is more consistent than YouTube and well worth a browse. Check it out at 
 http:// 
 showmedo.com/
  .",NA
 AND NOW FOR SOMETHING COMPLETELY DIFFERENT… ,"As a fi nal treat, you can try the Python Challenge. This is a bit like an adventure game for Python 
 programmers. You start with easy examples, which then become more progressively diffi cult. The 
 location of the next challenge is revealed by solving the current one. If you fi nd that you are writing a 
 lot of code for any individual challenge, you are probably going the wrong way about solving it. The 
 fun starts here: 
 http://www.pythonchallenge.com/
  . 
  
 www.it-ebooks.info",NA
REFERENCES ,"A.   Church . ( 1985 ).  
 The Calculi of Lambda‐Conversion
  .  Princeton University Press :  Princeton, 
 NJ . 
  
  M.   Hammond &  A.   Robson  . ( 2000 ).  
 Python Programming On Win32: Help for Windows 
 Programmers
  .  O’Reilly Media :  Sebastopol, CA . 
  
  J.  Grayson  . ( 2000 ).  
 Python and Tkinter Programming
  .  Manning Publications :  Shelter Island, 
 NY .
  
  M.   Lutz  . ( 2011 ).  
 Programming Python
  .  O’Reilly Media :  Sebastopol, CA . 
  
  N.   Rappin  &  R.   Dunn  . ( 2006 ).  
 WxPython in Action
  .  Manning Publications :  Shelter Island, 
 NY .
  
 www.it-ebooks.info",NA
INDEX,"Symbols & numbers 
  
 == (double equal), variable equality and, 3 ; 
 (semi-colon), in statements, 16 
  
 3-tuple, 69
  
  
 data layer, 164–165 
  
  
 dialogs, 177–181 
  
 Flask framework, 239–247 
  
 server-based, web services, 99–100 
 structure, 162–163
  
 user interface, 169–173
  
 A
  
 accumulate( )
  function, 122, 125 
  
 add_cascade( )
  function, 187 
  
 aifc
  module, 291, 319 
  
 all( )
  function, 7 
  
 analyzing data 
  
  
 built-in features and, 116–119 
  
  
 itertools
  module, 119–124 
  
 animation, 292 
  
 answers to exercises, 303–317 
  
 any( )
  function, 7 
  
 APIs (application programming interfaces) 
  
 ctypes
  module and, 93–97 
  
  
 JSON, 230–231 
  
  
 pywin32
  module and, 93–97 
  
  
 third-party, 231–234 
  
  
 web, 230–234 
  
  
 Windows, access, 96–97 
  
 application libraries, 96–97 
  
 application state, storage, 212 
  
 applications 
  
  
 architecture, 162 
  
  
 command line interfaces 
  
   
 arguments, 175–176 
  
   
 cmd
  module, 173–175 
  
   
 core logic layer, 165–169
  
 application-specifi c data, storage, 210–211 
 Arduino products, 297 
  
 argparse
  module, 176, 319 
  
 ArgumentParser, 176 
  
 argument-parsing library, 319 
  
 arguments, command line interfaces, 175–176 
 array
  module, 319 
  
 ASCII characters, 217 
  
 askyesno
  dialog, 179 
  
 asynchat
  module, 319 
  
 asyncio
  module, 319 
  
 asyncore
  module, 319 
  
 atexit
  module, 319 
  
 atof( )
  function, 215 
  
 atoi( )
  function, 215 
  
 audience for book, xxiv 
  
 audio, 293 
  
 audioop
  module, 319 
  
 AUTOINCREMENT
  keyword, 134–135 
  
 automation, multiple applications and 
  
  
 data fi les, 98 
  
  
 GUI robotics, 100 
  
  
 native code APIs, 100 
  
  
 operating system utilities, 98 
  
  
 server-based, 99–100 
  
  
 subprocesses, 99 
  
  
 third-party modules, 99
  
 333
  
 www.it-ebooks.info",NA
WILEY END USER LICENSE ,NA,NA
AGREEMENT,"Go to www.wiley.com/go/eula to access Wiley’s ebook
  
 EULA.
  
 www.it-ebooks.info",NA
